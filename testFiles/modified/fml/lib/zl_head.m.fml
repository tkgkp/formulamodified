:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: zl_head.fml
:: Utworzony: 22.06.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Obsługa nagłówków zleceń (selekcja i redakcja) - tabela ZL
::            Plik biblioteczny - wspólna obsługa dla czynności obszaru roboczego TTE_PZL:
::            - TTE_PZL_PZLE
::            - TTE_PZL_PWAR
::            - TTE_PZL_DZLE
::            - TTE_PZL_DWAR
::            - TTE_PZL_DZLP
::            - TTE_PZL_DZLN
::            - TTE_PZL_MZLE
::            - TTE_PZL_MZLP
::            - TTE_PZL_SZLE
::======================================================================================================================


\action_modify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Rejestracja nagłówka zlecenia - akcja Popraw
::----------------------------------------------------------------------------------------------------------------------
_il_before:=ZL.IL;
:: NUCO - tymczasowe uzupełnienie znacznika - bo technologia źródłowa ginie !!!
{? ZL.SRCTECH='N' & ZL.TYP().TYP='P'
|| ZL.SRCTECH:='T';ZL.put()
?};

_args:=exec('mp_run_a','#b__box');
:: NUCO - zawsze modyfikujemy - przy modyfikacji ;)
_a:=ZL.TYP().WP;
_b:=ZL.RODZAJ;
_c:='O';
_args.ACT_UID:=exec('zl_act_uid','zl_head',_a,_b,_c);
:: koniec
_args.UIDREF:=ZL.uidref();
_args.AKCJA:='POPRAW';
:: NUCO - każde popraw do proces - aby aktualizować plan strategiczny i aktualizować dane w zleceiu
::_args.PROC_START:={? ZL.STAN='O' || 'T' || 'N' ?};
_args.PROC_START:='T';
_args.CONTEXT:=obj_new('ZL'); _args.CONTEXT.ZL:=ZL.ref();

exec('mp_run','#b__box',_args);

{? ZL.STAN='O'
|| ZL.get();
   {? _il_before<>ZL.IL || params_get().env.ZLIM_reload:=1 ?}
?};
~~


\action_copy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Rejestracja nagłówka zlecenia - akcja Kopiuj
::----------------------------------------------------------------------------------------------------------------------
::NUCO - wycofanie ewentualnego zlecenia zbiorczego jeśli jest zamknięte
exec('otw_zlec','qprocesy',ZL.ref(),0,0,0,'');

_ref:=#ZL.ref();
{? exec('zl_lock','zl_common',_ref,'N')
|| _familyres:=exec('zl_lockfamily','zl_common',_ref,'N');
   {? _familyres.LOCKED>0
   || _args:=exec('mp_run_a','#b__box');
      _args.ACT_UID:=exec('zl_act_uid','zl_head',ZL.TYP().WP,ZL.RODZAJ);
      _args.AKCJA:='KOPIUJ';
      _args.PROC_START:='T';
      _args.CONTEXT:=obj_new('ZL'); _args.CONTEXT.ZL:=ZL.ref();

      exec('mp_run','#b__box',_args)
   || FUN.info('Jedno z powiązanych zleceń jest redagowanie.\nKopiowanie niemożliwe.'@)
   ?};
   exec('zl_unlockfamily','zl_common',_familyres.TAB,'N');
   exec('zl_unlock','zl_common',_ref,'N')
?}


\action_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Rejestracja nagłówka zlecenia - akcja Usuń
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

ZL.cntx_psh();
_up_zl:=exec('get_nadzlec','zl_link',ZL.ref());
{? ZL.prev() || _prev_zl:=ZL.ref() || _prev_zl:=null() ?};
ZL.cntx_pop();

:: NUCO - przy usuwaniu ze zleceń usuwamy najpierw z planu strategicznego
{? ZL.PLAN_PX='T' & ZL.PLAN_PO<>'T'
|| exec('zl_ps_us','qprocesy',ZL.ref())
?};

_args:=exec('mp_run_a','#b__box');
_args.ACT_UID:=exec('zl_act_uid','zl_head',ZL.TYP().WP,ZL.RODZAJ);
_args.UIDREF:=ZL.uidref();
_args.AKCJA:='USUŃ';
_args.GRUPA:={? ZL.sel_size()>0 || 'T' || 'N' ?};
_args.CONTEXT:=obj_new('ZL','RESULT'); _args.CONTEXT.ZL:=ZL.ref(); _args.CONTEXT.RESULT:=0;

exec('mp_run','#b__box',_args);
{? _args.CONTEXT.RESULT
|| ZL.seek(_prev_zl);
   {? cur_win(1,1)='STRUCT' & ZL.size()>0
   || _env.ZL_UP:=_up_zl
   ?}
?};
~~


\icon_stat_pl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Ikona statusu planowania
::  OLD: \icon_stat_pl/zl.fml
::----------------------------------------------------------------------------------------------------------------------
:: Jeżeli w planie operacyjnym
{? ZL.PLAN_PO='T'
||
::   NUCO - dodatkowa ikona na zlecenie w planie operacyjnym - nie do końca zaplanowane
   {? sql('select ZGP.REFERENCE as REF from ZGP where ZGP.ZL=:_a and ZGP.STARTD is null',ZL.ref()).first()
   || 'xwin16.png:185'
   || exec('pl_plan','icon')
   ?}

:: Jeżeli w planie strategicznym
|? ZL.PLAN_PX='T'
|| exec('px_plan','icon')

:: Bez planu
|| exec('pusta','#icon')
?}


\zl_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Przed 'Popraw' zlecenia (w przygotowaniu, otwarte)
::   WE: _a - ZL.ref()
::       _b - czy uruchomiona w procesie (dostępny przycisk Zakończ)
::       [_c] - czy dostępny przycisk OK (domyślnie 1-tak)
::       [_d] - czy dostępny dialog (domyślnie 1-tab)
::       [_e] - bufor tabeli ZL z wartościami, którymi zastąpić aktualne wartości
::       [_f] - INTEGER - [0]/1 - czy aktualizować limit na zleceniu nadrzędnym
::       [_g] - INTEGER - [0]/1 - czy uruchamiane podczas podziału zlecenia
::   WY: 0 / 1
::  OLD: \zl_b_pop/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_proces:=_b;
_btn_ok:={? var_pres('_c')=type_of(0) || _c || 1 ?};
_dialog:={? var_pres('_d')=type_of(0) || _d || 1 ?};
{? var_pres('_e')>100 || _buffer_in:=_e || _buffer_in:=exec('buffer','zl_head'); _buffer_in.bl_void() ?};
_lim_nad:={? var_pres('_f')=type_of(0) || _f || 0 ?};
_split:={? var_pres('_g')=type_of(0) || _g || 0 ?};
_res:=0;
_can_continue:=1;

ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
||
   _buffer:=exec('buffer','zl_head');
   _buffer.get();

   _buffer_tmp:=exec('buffer','zl_head');
   _buffer_tmp.get();
   _buffer_in.mask(_buffer_tmp);
   _buffer_tmp.setf();

   _atrmjs:=ATR.MJS;
   ATR.MJS:='ZL';
   ATR.M_ATR:=ZL.KTM().M_ATR;
   ATR.UZUP:=exec('wz_uzup','mat_atr',ATR.M_ATR);
   {? ZL.DK_C<>null() & ZL.DK_C().M_ATR<>null()
   || {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=($('ZL.DK_C().WAR'+form(_i,-2,,'99')))() !}
   || {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !}
   ?};
   {? ZL.STAN<>'N'
   || ATR.FLAG_ED:=0;
      ATR.FLAG:=0
   || ATR.FLAG_ED:=(1+ZL.MG().TYP)='D' & ATR.CZY_ATR & ATR.M_ATR().EDIT;
      ATR.FLAG:={? ATR.FLAG_ED & ZL.KTM().M_ATR<>null() || 2 || 0 ?};
      {? ATR.FLAG_ED || {? ZL.KTM().M_ATR<>null() || ATR.FLAG_ED:=2 ?} ?}
   ?};

   exec('tktl_use','tech_common');
   _wp:=ZL.TYP().WP;
   DK_C.cntx_psh();
   {? ZL.DK_C<>null() & ref_name(ZL.DK_C)<>DK_C.name() || DK_C.use(ref_name(ZL.DK_C)) ?};
   _ok:={? _wp='P'
        || _red:=exec('mk_edit','zl_head',_wp,ZL.RODZAJ);
           exec('add_btn','zl_head',_red,_proces,_btn_ok);
           exec('set_dict','zl_head');
           ZL.win_edit(_red);
           1
        |? _wp='W'
        || _red:=exec('mk_edit','zl_head',_wp);
           exec('add_btn','zl_head',_red,_proces,_btn_ok);
           exec('set_dict','zl_head');
           ZL.win_edit(_red);
           1
        || 0
        ?};

:: Wyjścia awaryjne - uwaga na konteksty!
   {? ZTP.KOD_ZLC=''
   || FUN.emsg('Funkcja niedostępna — typ zlecenia nie ma określonego sposobu numeracji.'@);
      DK_C.cntx_pop();
      ZL.cntx_pop();
      return(0)
   ?};
   {? ZTP.WP='P' & ZTP.KOD_ZLP=''
   || FUN.emsg('Funkcja niedostępna — typ zlecenia nie ma określonego sposobu numeracji podzleceń.'@);
      DK_C.cntx_pop();
      ZL.cntx_pop();
      return(0)
   ?};

   exec('add_grnr','numery','ZLC');
   exec('add_grnr','numery','ZLP');
   {? VAR.A_ZLNAD<>null() || POM.TYPDOK:=ZTP.KOD_ZLP || POM.TYPDOK:=ZTP.KOD_ZLC ?};
   POM.TAB:='ZL';

   _il:=ZL.IL;
   _sprawdz:=exec('sprawdz_podzlecenia','zl_link',ZL.ref());
   {? _sprawdz || _sprawdz:=~exec('has_zgh','zl_common',ZL.ref()) ?};
   {? _sprawdz || _sprawdz:=~exec('is_zlim_zl','zl_limit',ZL.ref()) ?};

   KOMM.init(250,,'Korekta zlecenia'@,'');
   {? _ok
   ||
::    Zapamiętuje wartości atrybutów przed poprawieniem
      VAR_DEL.delete('DKC_BEF');
      DKC_BEF:=exec('buffer','mat_atr');
      {? ZL.DK_C<>null()
      || DK_C.cntx_psh();
         DK_C.clear();
         {? DK_C.seek(ZL.DK_C)
         || DKC_BEF.get_dkc()
         ?};
         DK_C.cntx_pop()
      ?};

      {? exec('enabled','zl_uslugi')
      || exec('mat_grp_f3','zl_uslugi',0,'W')
      || exec('slo_m_ok','material','T',0,,'W');
         exec('filter','material','WP')
      ?};
      MG.f_clear();

      {? (ZL.STAN='O' & ZL.RODZAJ<>'N') | exec('zlhead_chk','zl_head')
      || {? exec('zl_lock','zl_common',,'N')
         ||
            _familyres:=exec('zl_lockfamily','zl_common',,'N');
            {? _familyres.LOCKED>0
            ||
               exec('ustaw_pola','zl_head');

               _args:=obj_new('buffer','sprawdz','edit');
               _args.buffer:=_buffer;
               _args.sprawdz:=_sprawdz;
               _args.edit:=1;
               params_set('args',_args);

               ZL.memo_get(,'OPIS_DOD',0);

::             ZLECENIE PRODUKCYJNE
               {? _wp='P'
               || _valid:=$("params_exec('valid_modify','zl_head','P',"+$_proces+","+$_dialog+","+$_split+")");
                  exec('efld_opt','zl_head',_red);
                  menu_txt(,'Popraw');
                  _args.buffer.STAT_N:=ZL.STAT_N;
                  {? {? _dialog
                     || {? ZL.edit(_valid)
                        ||
::                         Sprawdzam czy aktualizowane zlecenie nie jest powiązane z limitem zlecenia nadrzędnego
                           {? ZL.NRPZL>0 & ZL.RTMATSRC<>'' & ZL.RP='T' & ZL.IL<>_buffer.IL
                           || _ktm:=ZL.KTM;
::                              _zl:=ZL.ref();
::                            szukam zlecenia nadrzędnego
                              ZL.cntx_psh();
                              ZL.index('UNRZL');
                              ZL.prefix(ZL.NRPZL);
                              {? ZL.first()
                              || ZLIM.cntx_psh();
                                 exec('openmask','zl_common',ZL.ref());
                                 ZLIM.clear();
                                 ZLIM.index('ZKK');
                                 ZLIM.prefix(ZL.ref(),'T',0,_ktm);
                                 {? ZLIM.first()
                                 ||
                                    _msg:='Zlecenie powiązane jest z limitem zlecenia nadrzędnego.\n'
                                          'Czy automatycznie skorygować ilość na tym limicie?'@;
                                    _lim_nad:=FUN.ask(_msg)
                                 ?};
                                 ZLIM.cntx_pop()
                              ?};
                              ZL.cntx_pop()
                           ?};
                           1
                        ?}
                     || VAR.ZRED_KTL:=ZL.KTL().NRK;
                        _valid()=''
                     ?}
                  ||
                     {? ZL.RODZAJ='N'
                     || _has_zgh:=0;
                        _has_part:=0
                     || _main_podzlec:=exec('main_podzlec','zl_link');
                        {? ZL.RODZAJ='Z'
                        || _has_zgh:=exec('get_ilosc_zgh','zl_common',_main_podzlec)
                        || _has_zgh:=exec('get_ilosc_zgh','zl_common',ZL.ref())
                        ?};
                        _has_part:=exec('zl_ile_part','zl_partie',_main_podzlec)
                     ?};

                     _il_zl_zgh:=0;
                     _il_zl_part:=0;
                     _il_zgh:=0;
                     _il_part:=0;
                     _tree:=1;

                     {? ZL.RODZAJ='Z' & exec('kor_coef_equal','zl_head')=0
                     || _msg:='Ilość na zleceniach podrzędnych była korygowana ręcznie.\n'
                              'Zmiana ilości na tym zleceniu nie zostanie naniesiona na strukturę zleceń podrzędnych.\n\n'
                              'Kontynuować?';
                        _can_continue:=FUN.ask(_msg);
                        _tree:=0
                     ?};

                     {? _can_continue>0
                     ||
                        _oper:='';
                        _tktl:='';
                        {? ZL.RTKTL<>''
                        || _tktl:=ZL.RTKTL
                        |? ZL.RKTL<>''
                        || _tktl:=ZL.RKTL
                        ?};
                        {? _tktl<>''
                        || _oper:=exec('FindAndGet','#table',TKTL,_tktl,,"TYP().OPER",'N')
                        ?};

                        {? ZL.IL>_buffer.IL & _has_zgh>=_buffer.IL & _oper='T'
                        ||
::                         Jeżeli zwiększam ilość to najpierw pytanie o podział na przewodniki
::                         o ile nie jest skonfigurowana wtyczka ZGH_F_ILGEN_001
                           {? Plugin.runnable('ZGH_F_ILGEN_001')
                           || _il_zl_zgh:=-1;
                              _il_zgh:=-1
                           || _res_ilosc:=exec('generuj_get_ilosc','zl_guide',,_dialog,0,0);
                              {? _res_ilosc.OK>0
                              || _il_zl_zgh:=_res_ilosc.IL_ZL;
                                 _il_zgh:=_res_ilosc.IL_ZGH
                              || _can_continue:=0
                              ?}
                           ?}
                        |? ZL.IL>_buffer.IL & _has_part>=_buffer.IL
                        ||
::                         Jeżeli zwiększam ilość to najpierw pytanie o podział na partie
                           _can_continue:=exec('generuj_get_ilosc','zl_partie',,_dialog);
                           {? _can_continue>0
                           || _il_zl_part:=ZLEC.IL_ZL;
                              _il_part:=ZLEC.IL_PART
                           ?}
                        |? ZL.IL<_buffer.IL
                        ||
                           _coef:={? _buffer.IL<>0 || ZL.IL/_buffer.IL || 0 ?};
::                         Sprawdzam czy ilości na podzleceniach po korekcie nie będą mniejsze od ilości zaraportowanej
                           _result:=exec('kor_chk_ildok','zl_head',ZL.ref(),_coef,_tree);
                           _can_continue:=_result.RESULT;
                           {? _can_continue=0
                           ||_msg:='Do zlecenia %1 wygenerowano dokumenty raportujące na ilość %2. \n'
                                 'Ilość na zleceniu po korekcie nie może być mniejsza od ilości zaraportowanej.'@
                                 [_result.ZL_SYM,$_result.MIN_IL];
                              {? _dialog
                              || FUN.emsg(_msg)
                              || KOMM.add(_msg,2)
                              ?}
                           ?}
                        ?}
                     ?};

                     _locked:=exec('ref_table','#table');
                     {? _can_continue>0 & ZL.IL<>_buffer.IL
                     ||
::                      Nastąpiło zwiększenie ilości więc przed transakcją blokuje wszystkie
::                      przewodniki żeby im później móc wygenerować powiązania
                        _zl_main:=exec('main_podzlec','zl_link',VAR.A_ZLEC);

::                      Najpierw blokowanie wszystkich przewodników
                        ZGH.index('ZLNR');
                        ZGH.prefix(_zl_main);
                        {? ZGH.first()
                        || {!
                           |? {? exec('blk_lock','#table','ZGH',ZGH.ref())>0
                              || _locked.add(ZGH.ref())
                              || _can_continue:=0;
                                 _msg:='Przewodnik %1 zablokowany, funkcji nie można kontynuować.'@[ZGH.NRPRZ];
                                 {? _dialog
                                 || FUN.emsg(_msg)
                                 || KOMM.add(_msg,2)
                                 ?}
                              ?};
                              ZGH.next() & _can_continue>0
                           !}
                        ?}
                     ?};

::                   Ostrzeżenie o nieaktywnej/archiwalnej technologii
                     {? _can_continue>0  & _args.buffer.STAT_N='T' & ZL.STAT_N<>_args.buffer.STAT_N
                        & exec('FindAndGet','#table',TKTL,ZL.RKTL,,"TKTL.ARCH",'')='T'
                     || _can_continue:=0;
                        _msg:='Nie można zakończyć redakcji nagłówka. Do zlecenia %1 przypisana jest archiwalna technologia'@[ZL.SYM];
                        {? _dialog
                        || FUN.emsg(_msg)
                        || KOMM.add(_msg,2)
                        ?}
                     |? _can_continue>0 & _args.buffer.STAT_N='T' & ZL.STAT_N<>_args.buffer.STAT_N & ZL.KTL<>null & ~exec('tktl_act','tech_head',1)
                     ||
                        _msg:='Do zlecenia %1 przypisana jest nieaktualna karta technologiczna.Czy zakończyć redakcję nagłówka zlecenia na jej podstawie?'@[ZL.SYM];
                        _choice:=FUN.choice(_msg,,'Tak',,,,'Nie');
                        {? _choice
                        || _can_continue:=1
                        || _can_continue:=0;
                           _msg:='Nie zakończono redakcji nagłówka. Do zlecenia %1 przypisana jest nieaktualna technologia'@[ZL.SYM];
                           {? _dialog
                           || FUN.emsg(_msg)
                           || KOMM.add(_msg,2)
                           ?}
                        ?}
                     ?};
::                   Jeżeli zwiększam ilość (i będą generowane przewodiki) to najpierw pytanie
::                   czy generować operacje wariantowe ostatniego przewodnika
                     {? _can_continue>0 & _il_zgh<>0 & ZL.IL>_buffer.IL
                     || {? exec('zl_has_wariant','zl_head',ZL.ref(),'LAST',_tree)>0
                        || _msg:='Technologia zlecenia posiada zdefiniowane wariantowe operacje ostatniego przewodnika.\n'
                                 'Czy wygenerować takie operacje do tworzonego przewodnika oraz usunać '
                                 'wariantowe operacje z aktualnie ostatniego przewodnika?'@;
                           _choice:=FUN.choice(_msg,,'Generuj i usuń'@,'Generuj i nie usuwaj'@,,,'Nie generuj'@);
                           {? _choice=2
                           || VAR.WAR_GEN:='T';
                              VAR.WAR_DEL:='N'
                           |? _choice=1
                           || VAR.WAR_GEN:='T';
                              VAR.WAR_DEL:='T'
                           || VAR.WAR_GEN:='N';
                              VAR.WAR_DEL:='N'
                           ?}
                        ?}
                     ?};

                     {? _can_continue>0
                     ||
::                      Rozpoczęcie transakcji
                        do();
                        ZL.STAT_N:=_args.buffer.STAT_N;
                        _coef_top:={? _buffer.IL<>0 || ZL.IL/_buffer.IL || 0 ?};
                        {? _buffer.IL<>ZL.IL
                        || ZL.KOR_COEF:=_coef_top
                        ?};
::                      Modyfikacje ZLZAM dotyczą zlecenia prostego albo nagłówka złożonego
::                     {? exec('top_rodzaj','zl_link',ZL.ref())='Z'
::                     || _zlec:=exec('top_level','zl_link',ZL.ref())
::                     || _zlec:=ZL.ref()
::                     ?};
:: NUCO - zdjęcie aktualizacji mimo numeru nadrzędnego - zlecenia niezależne
::                        {? ZL.RODZAJ='Z' | ZL.RODZAJ='P' & ZL.NRNZL=0
                        {? ZL.RODZAJ='Z' | ZL.RODZAJ='P'
                        || _zlec:=ZL.ref();
::                         Gdy zmniejszona ilość na zleceniu to sprawdzamy czy powiązane z zamówieniem
                           {? ZL.IL<_buffer.IL
                           || _can_continue:=exec('zlzam_decrease','zl_gen',,ZL.IL);
                              {? _can_continue>0
                              || _can_continue:=ZL.put()
                              ?}
                           || _can_continue:=ZL.put();
                              {? _can_continue>0
                              || exec('add_zleczam','zl_gen',_zlec,ZL.IL-_il)
                              ?}
                           ?}
                        |? ZL.RODZAJ='P' & ZL.NRNZL<>0 & exec('top_rodzaj','zl_link',ZL.ref())='Z'
                        ||
::                         Gdy zlecenie pojedyncze w strukturze zlecenia złożonego, usuwamy powiązania między przewodnikami
                           _can_continue:=ZL.put();
                           {? _can_continue>0
                           || _var_zlec:=VAR.A_ZLEC;
                              VAR.A_ZLEC:=exec('root_zlec','zl_link',ZL.ref());
                              exec('gendom_zl','zl_guide','N',0);
                              VAR.A_ZLEC:=_var_zlec
                           ?}
                        || _can_continue:=ZL.put()
                        ?};
::                      Usunięcie wariantowych operacji ostatniego przewodnika
                        {? _can_continue>0 & VAR.WAR_DEL='T'
                        || ZGH.cntx_psh();
                           ZGH.index('ZLNR');
                           ZGH.prefix(ZL.ref(),);
                           {? ZGH.last()
                           || ZGP.cntx_psh();
                              ZGP.index('WHERE');
                              ZGP.prefix(ZGH.ref(),'O',);
                              {? ZGP.first()
                              || VAR_DEL.delete('_visited');
                                 _visited:=exec('ref_table','#table');
                                 {!
                                 |?
                                    _del:=0;
                                    {? _visited.r_find(ZGP.ref())=0
                                    || _visited.add(ZGP.ref());
                                       _del:=exec('zgp_del','zl_guide',1)
                                    ?};
                                    {? _del=0
                                    || _next:=ZGP.next()
                                    |? _del=1
                                    || _next:=0
                                    || _next:=1
                                    ?};
                                    _next
                                 !};
                                 VAR_DEL.delete('_visited')
                              ?};
                              ZGP.cntx_pop()
                           ?};
                           ZGH.cntx_pop()
                        ?};

                        {? _can_continue>0 & ZL.STAN='O'
                        || exec('obl_prod','magazyn_stan',ZL.KTM,ZL.MG,2)
                        ?};
                        {? _can_continue>0 & _tree>0
                        ||
::                         Nanoszę współczynnik korekty na podzlecenia
                           _can_continue:=exec('kor_coef_set','zl_head',,ZL.KOR_COEF)
                        ?};
                        _zgh_corrected:=exec('ref_table','#table');
                        {? _can_continue>0
                        ||
::                         Po zaputowaniu zlecenia uruchamiamy faktyczne modyfikacje przewodników, limitów itp
                           _can_continue:=exec('zl_il_change','zl_head',,_buffer
                                                                        ,ZL.IL
                                                                        ,_buffer.IL
                                                                        ,_buffer.KTM
                                                                        ,_buffer.KTL
                                                                        ,
                                                                        ,
                                                                        ,_il_zl_zgh
                                                                        ,_il_zgh
                                                                        ,_il_zl_part
                                                                        ,_il_part
                                                                        ,
                                                                        ,_tree
                                                                        ,_zgh_corrected
                                                                        ,_lim_nad)
                        ?};

                        {? _can_continue>0
                        ||
::                         Jeżeli stoję na zleceniu montażowym, to uruchamiam też na zleceniu na samej górze
                           _top_rodzaj:=exec('top_rodzaj','zl_link',ZL.ref());
                           {? _top_rodzaj='Z' & exec('is_main_podzlec','zl_link')
                           || _top_level:=exec('top_level','zl_link',ZL.ref());

                              {? _can_continue>0 & _tree>0
                              ||
::                               Nanoszę współczynnik korekty na nadzlecenie
                                 _can_continue:=exec('kor_coef_set','zl_head',_top_level,ZL.KOR_COEF,0)
                              ?};
                              {? _can_continue>0
                              ||
                                 _can_continue:=exec('zl_il_change','zl_head',_top_level
                                                                              ,_buffer,ZL.IL
                                                                              ,_buffer.IL
                                                                              ,_buffer.KTM
                                                                              ,_buffer.KTL
                                                                              ,
                                                                              ,
                                                                              ,_il_zl_zgh
                                                                              ,_il_zgh
                                                                              ,_il_zl_part
                                                                              ,_il_part
                                                                              ,1
                                                                              ,0
                                                                              ,_zgh_corrected
                                                                              ,_lim_nad)
                              ?}
                           ?}
                        ?};

                        {? _can_continue>0
                        || {? _args.buffer.STAT_N='T'
                           || exec('akt_terminy','zl_common',_buffer,0)
                           ?}
                        ?};
                        {? _can_continue>0
                        || {? _args.buffer.STAT_N='T'
                           || exec('akt_plany','zl_common',_buffer.STARTD,_buffer.STARTT,_buffer.ENDD,_buffer.ENDT,0)
                           ?}
                        ?};
                        {? _can_continue>0
                        || exec('akt_znaczniki','zl_common',_buffer.PL_FORCE,_buffer.PL_DIR)
                        ?};
                        {? _can_continue>0
                        || GROPP.cntx_psh();
                           GROPP.index('ZL');
                           GROPP.prefix(ZL.ref());
                           {? GROPP.first()
                           || {!
                              |? exec('termin_update','zl_grop',GROPP.GROP);
                                 GROPP.next()
                              !}
                           ?};
                           GROPP.cntx_pop()
                        ?};
                        {? _can_continue>0
                        || exec('akt_projekty','zl_common',_buffer.PROJEKTY)
                        ?};

                        {? _can_continue>0
                        || ZL.memo_put(,'OPIS_DOD');
                           {? ZL.SCEAN<>'' & ZL.KTM().IDMOB='Z'
                           || exec('mkodkadd','kody_kresk',ZL.KTM,ZL.SCEAN,$ZL.ref())
                           ?}
                        ?};
                        {? _can_continue>0
                        ||
::                         Aktualizacja obiektu planowanego dotyczącego zlecenia
                           exec('zl2obj','px_obj',ZL.ref());
::                         Poprawienie słowników użytkownika
                           exec('pop_slo','slo_slu','ZL')
                        ?};

                        {? _can_continue>0
                        ||
::                         Porównuje wartości cechy po poprawieniu
                           _dkc_after:=exec('buffer','mat_atr');
                           {? ZL.DK_C<>null()
                           || DK_C.cntx_psh();
                              DK_C.clear();
                              {? DK_C.seek(ZL.DK_C)
                              || _dkc_after.get_dkc()
                              ?};
                              DK_C.cntx_pop()
                           ?};
                           {? DKC_BEF.compare(_dkc_after)<>1
                           ||
::                            Jeśli wartości atrybutów się zmieniły to aktualizuje podzlecenia
                              exec('podzlec_dkc_upd','zl_common',ZL.ref())
                           ?}
                        ?};
                        {? _can_continue<=0
                        || undo()
                        ?};
                        end()
                     ?};

::                   Odblokowuje wszystkie zablokowane przewodniki
                     _tab:=_locked.tab;
                     _tab.prefix();
                     {? _tab.first()
                     || {!
                        |? exec('blk_unlock','#table','ZGH',ref_name(_tab.SQL),BIT.sqlint(_tab.SQL));
                           _tab.next()
                        !}
                     ?};
                     ~~
                  ||
::                   Użytkownik nacisnął ESC lub walidacja nie udana jak bezdialogowo
                     _can_continue:=0
                  ?}
::             ZLECENIE WARSZTATOWE
               || _valid:=$("params_exec('valid_modify','zl_head','W',"+$_proces+")");
                  menu_txt(,'Popraw');
                  _args.buffer.STAT_N:=ZL.STAT_N;
                  {? {? _dialog
                     || ZL.edit(_valid)
                     || _valid()=''
                     ?}
                  || ZL.STAT_N:=_args.buffer.STAT_N;
                     _can_continue:=ZL.put();
                     {? _can_continue>0
                     || ZL.memo_put(,'OPIS_DOD');
                        {? ZL.SCEAN<>'' & ZL.KTM().IDMOB='Z' || exec('mkodkadd','kody_kresk',ZL.KTM,ZL.SCEAN,$ZL.ref()) ?};
::                      Aktualizacja obiektu planowanego dotyczacego zlecenia
                        exec('zl2obj','px_obj',ZL.ref());
::                      Poprawienie słowników użytkownika
                        exec('pop_slo','slo_slu','ZL')
                     ?}
                  ||
::                Użytkownik nacisnął ESC
                     _can_continue:=0
                  ?}
               ?}
            ?};
            exec('zl_unlockfamily','zl_common',_familyres.TAB,'N');
            exec('zl_unlock','zl_common',,'N')
         ?}
      ?};
::    Przywracam tytuł i akcje w słowniku materiałów
      exec('filter_clear','material')
   ?};
   VAR_DEL.delete('DKC_BEF');
   KOMM.select();
   DK_C.cntx_pop();
   VAR.A_STAN:=ZL.STAN;
   VAR.WAR_GEN:='T';
   VAR.WAR_DEL:='N';
   ATR.MJS:=_atrmjs
?};
ZL.cntx_pop();
{? _can_continue>0
|| _res:=1
?};
_res


\kopiuj
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Kopiowanie zlecenia
::   WE: _a - ZL.ref()
::       [_b] - nadawać wartości początkowe dla wybranych pól i tworzyć rekord ZLZAM?
::       [_c] - bufor tabeli ZL z wartościami, którymi zastąpić wygenerowane wartości
::   WY: ZL.ref() nowego zlecenia albo null(), gdy nie udane
::  OLD: \kopiuj/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
{? var_pres('_b')=type_of(0) || _blank:=_b || _blank:=1 ?};
{? var_pres('_c')>100 || _buffer_in:=_c || _buffer_in:=exec('buffer','zl_head'); _buffer_in.bl_void() ?};

_zl_new:=null();

ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
||
:: Dane źródłowego zlecenia:
   _sym:=ZL.SYM;
   _rodzaj:=ZL.RODZAJ;
   _wp:=ZL.TYP().WP;
   _aut:=ZL.AUTGENZL;
   _tktl:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,"ref()",null());
   _nrnzl:=0;
   _ref_nrnzl:={? ZL.NRNZL>0 || exec('GetZLref4UNRZL','zl_common',ZL.NRNZL) || null() ?};
   {? _ref_nrnzl<>null() & exec('FindAndGet','#table',ZL,_ref_nrnzl,,"{? RODZAJ='N' || 1 || 0 ?}",0)
   || _nrnzl:=ZL.NRNZL
   ?};

:: POCZĄTEK TRANSAKCJI
   do();

   ZL.prefix();
   ZL.AR:=ST.AR;
:: Nowe zlecenie nie jest nigdy podzleceniem
   ZL.NRNZL:=_nrnzl;
:: NUCO - Zachowanie opisu grupy zleceń
   {? _blank || ZL.OPIS:=ZL.OPIS+'; kopia z: '+_sym ?};
   {? _blank || ZL.OD:=date() ?};
   ZL.DO:=date(0,0,0);
   ZL.STAN:='N';
   ZL.TKTL:=null();
   ZL.RTKTL:='';
   ZL.POWOL:=OPERATOR.USER;
   ZL.DZATW:=date(0,0,0);
   ZL.ZATW:=null();
   ZL.CLOSED:=null();
   ZL.HIDDEN:='T';
   ZL.ZMASK:=20*'1';
   {? _blank || ZL.DTR:=date()+exec('get','#params',500103,1) ?};
   ZL.MASKA:='____';
   ZL.ILWYK:=0;
   ZL.ILWYK_D:=0;
   ZL.ILDOK:=0;
   ZL.HWYK:=0;
   ZL.STARTD:=ZL.ENDD:=date(0,0,0);
   ZL.STARTT:=ZL.ENDT:=time(0,0,0);
   {? _blank || ZL.PL_DATA:=ZL.DTR ?};
   {? _blank || ZL.PL_TIME:=time(0,0,0) ?};
   {? _nrnzl=0 || ZL.TREE:=0 ?};
   ZL.NSTAN:=ZL.STAN+'_';
   ZL.SCEAN:=exec('blzl_sce','kody_kresk');
   ZL.ZLEAN:=exec('blzl2sce','kody_kresk');
   ZL.ID_KSG:=exec('zl_idksg_bl','zl_head');
   ZL.STAT_N:=ZL.STAT_T:='N';
   ZL.IDSRC:=ZL.IDADD;
   ZL.PLAN_PO:='N';
   ZL.PLAN_PX:='N';
   ZL.TREE_TYP:=ZL.RODZAJ;
   ZL.PRIORITY:=0;
   {? ZL.TREE || ZL.NODE:=exec('node','zl_head') ?};
   exec('ust_znac','zl_head');
   ZL.SYM:='~'+$ZL.tm_stamp();
   ZL.memo_get(,'OPIS_DOD',0);
   _buffer:=exec('buffer','zl_head');
   _buffer.get();

   _buffer_tmp:=exec('buffer','zl_head');
   _buffer_tmp.get();
   _buffer_in.mask(_buffer_tmp);
   _buffer_tmp.setf();

   {? ZL.add()
   || POM.TAB:='ZL';
      exec('add_grnr','numery','ZLC');
      exec('add_grnr','numery','ZLP');
      POM.TYPDOK:={? ZL.NRNZL=0 || ZL.TYP().KOD_ZLC || ZL.TYP().KOD_ZLP ?};
      ZL.NR:=0;
      ZL.NR:=exec('numer_new','numery','PACZKA');
      exec('znak','numery','ZL',1);
::      NUCO - dodanie kodu wydziału do symbolu zlecenia
      exec('symbol_zl','qtte');
::      Koniec zmiany
      ZL.memo_put(,'OPIS_DOD');
      {? ZL.TREE=0 || ZL.NODE:=exec('node','zl_head'); ZL.put() ?};
      {? ZL.SCEAN<>'' & ZL.KTM().IDMOB='Z' || exec('mkodkadd','kody_kresk',ZL.KTM,ZL.SCEAN,$ZL.ref()) ?};
::    tutaj replika nagłówka zlecenia z drobnymi modyfikacjami
      _zl_new:=ZL.ref();
      {? _blank || exec('add_zleczam','zl_gen',ZL.ref(),ZL.IL) ?};
      VAR.A_ZLEC:=ZL.ref();
      _ok:=exec('add_zwar_pos','zl_common','_n',0);
      {? _ok
      || UAT.cntx_psh();
         UAT.index('TR');
         UAT.prefix('ZL'+'*',#_zl,ref_name(_zl)+'*',);
         {? UAT.first()
         || _uat:=FUN.ask('Czy kopiować atrybuty zlecenia?'@)
         || _uat:=0
         ?};
         UAT.cntx_pop();
         {? _uat
         || _ok:=exec('uat_copy','tech_arch',,'ZL',_zl,ZL.ref())
         ?}
      ?};
      {? _ok
      || _ok:=DocLib.copy('ZL',_zl,'ZL',ZL.ref())
      ?};

:: TODO: kopiowanie pozostałych elementów wyłączone - powinno być obsłużone w procesie
::      {? _ok
::      ||
::::       Zlecenie produkcyjne proste = kopiowanie karty technologicznej
::         {? _rodzaj='P' & _wp='P'
::         || {? _tktl<>null()
::            || _args:=exec('args_copy','tech_arch');
::               _args.DIR:='KARTOTEKA';
::               _args.MASK_SRC:=(8+ref_name(_tktl))+3;
::               _args.TKTL_SRC:=_tktl;
::               _args.DST_TMASK:=exec('samejedynki','#blank');
::               _args.DST_TORW:='Z';
::               _args.DST_STAN:='N';
::               _args.DST_ZL:=ZL.ref();
::               _args.DST_ZLNAD:=exec('get_nadzlec','zl_link',ZL.ref());
::               _args.DST_SYM:=ZL.SYM;
::               _args.DST_WER:=exec('tktl_wer_bl','tech_head');
::               _args.TPAR_ASK:=0;
::               _args.M_ONLY:=ZL.KTM;
::               _args.M_VALS:=ZL.KTM;
::               _args.FILL_SRC:=1;
::               {? exec('tktl_copy','tech_arch',_args)
::               || ZL.TKTL:=_args.TKTL_DST;
::                  _ok:=ZL.put()
::               || _ok:=0
::               ?};
::               obj_del(_args)
::            ?}
::
::::       Zlecenie produkcyjne złożone = kopiowanie struktury podzleceń
::         |? _wp='P' & ((_rodzaj='Z' & _aut='T') | _rodzaj='N')
::         || _ok:=exec('zktlnew','zl_head',ZL.ref(),_zl,1,ZL.UNRZL)
::
::::       Zlecenie warsztatowe = kopiowanie przewodników i limitów
::         |? _wp='W'
::         || _ok:=exec('cp_zlec','zl_common',ZL.ref(),_zl)
::
::         ?}
::      || undo()
::      ?};
      {? ~_ok
      || undo()
      ?}
   || undo()
   ?};

:: KONIEC TRANSAKCJI
   {? end()
   ||
      _msg:=
         'Na podstawie zlecenia '+_sym+' zostało wygenerowane zlecenie o symbolu: '+
          ZL.SYM+{? ZL.KTM<>null() || ' dla produktu: '+ZL.KTM().KTM || '' ?};
      {? ZL.TYP().WP<>'W' & ZL.RODZAJ<>'N' & ZL.KTL=null() & ZL.SRCTECH='T'
      || KOMM.sect_beg(_msg,'xwin16.png:38');
         KOMM.add('Zlecenie powołane na podstawie archiwalnej technologii'@,'xwin16.png:3');
         KOMM.sect_end()
      || KOMM.add(_msg,'xwin16.png:38')
      ?};
      {? ~exec('ctrl_zl','zl_view',ZL.ref())
      || KOMM.add(' Uwaga. W celu podglądu zlecenia należy zmienić aktualny zakres zleceń.'@,3)
      ?};
      exec('zl2obj','px_obj')
   ||
      KOMM.add(
         'Nie udało się utworzyć zlecenia na podstawie '+
          _sym +{? ZL.KTM<>null() || ' dla produktu: '+ZL.KTM().KTM || '' ?},
          'xwin16.png:81'
       )
   ?}
?};
ZL.cntx_pop();
_zl_new


\rkprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.53]
:: OPIS: Wylicza procenty zaawansowania (wolne pola) oraz koloruje rekordy zleceń (faktyczna akcja przed rekord)
::   WY: schemat kolorów
::  OLD: \procent/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
:: Środowisko potrzebne tylko do kolorowania panelu struktury (patrz na koniec formuły)
:: Dodatkowo zabezpieczenie, gdy odświeżanie okna wykonane zostanie w niespodziewanym kontekście
{? cur_win(1,1)='STRUCT'
|| _params:=params_get();
   {? var_pres('_params')>100 & var_pres('env',_params)>100
   || _env:=params_get().env
   || _env:=~~
   ?}
?};

:: Wylicza procenty zaawansowania
exec('procent','zl_head');

:: Wyświetla stan magazynowy
{? ZL.TYP().WP='W'
|| SM.blank(1)
|| {? ZL.RODZAJ='N'
   || SM.blank(1)
   |? ZL.RODZAJ='Z'
   || SM.index('SM');
      SM.prefix(ZL.MG,ZL.KTM);
      {? ~SM.first() || SM.blank(1) ?}
   |? exec('is_main_podzlec','zl_link',ZL.ref())
   || SM.index('SM');
      SM.prefix(ZL.MG,ZL.KTM);
      {? ~SM.first() || SM.blank(1) ?}
   || {? ZL.MG<>null()
      || _mag:=ZL.MG().SYM
      || _mag:=exec('get','#params',500005)
      ?};
      {? _mag=''
      || SM.blank(1)
      || SM.index('SMM');
         SM.prefix(ZL.KTM,_mag,);
         {? ~SM.first() || SM.blank(1) ?}
      ?}
   ?}
?};
VAR1.SD:=SM.SD;
:: Zmienna dla bieżącego zlecenia
VAR.A_ZLEC:=ZL.ref();

:: Zmienne dla zleceń podrzędnych
{? ZL.RODZAJ='P' & ZL.NRNZL<>0
|| ZL.cntx_psh();
   ZL.clear();
   ZL.index('UNRZL');
   ZL.prefix(ZL.NRNZL);
   {? ZL.first()
   || VAR.A_UNRZL:=ZL.UNRZL;
      VAR.A_ZLNAD:=ZL.ref()
   || VAR.A_UNRZL:=0;
      VAR.A_ZLNAD:=null()
   ?};
   ZL.cntx_pop()
|| VAR.A_UNRZL:=0;
   VAR.A_ZLNAD:=null()
?};

:: NUCO -  Kolorowanie na podstawie informacji o ilościach zaraportowanych, a nie wykonanych
_res:='';

:: Kolorowanie
{? cur_win(1,1)='STRUCT' & type_of(_env)>100 &
   exec('green_branch','zl_view',exec('FindAndGet','#table',ZL,_env.ZL_TREE),ZL.ref())=0
|| _res:='ZL#01#15'
::|| {? ZL.TYP().TOL>=100-VAR.REAL
:: NUCO -  Kolorowanie na podstawie informacji o ilościach zaraportowanych, a nie wykonanych
|| {? {? ZL.JORG().KOD='MSU' | ZL.JORG().KOD='MMO'
      || (ZL.IL*0.9)<=ZL.ILDOK
      || ZL.IL<=ZL.ILDOK
      ?}
   || _res:='ZL#01#01'
   ?};
   {? ZL.PLAN_PO='T' & ZL.ST_W='T'
   || _res:='ZKP#02#04'
   ?};
   {? ZL.ST_Z='T'
   || _res:='ZL#01#15'
   ?}
?};

_res


\dtr_spr
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Po redakcji pola ZL.DTR
::   WY: 0 / 1
::  OLD: \dtr_spr/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZL.DTR<date() & ZL.DTR<>date(0,0,0)
|| FUN.emsg('Termin realizacji nie może być wcześniejszy od daty dzisiejszej.'@);
   return(0)
?};

:: Dla zleceń podrzędnych dodatkowa kontrola przekroczenia terminu ze zlecenia nadrzędnego
{? ZL.NRNZL<>0
|| ZL.cntx_psh();
   ZL.index('UNRZL');
   ZL.prefix(ZL.NRNZL);
:: NUCO - dodatkowa zmiana daty jeśli zlecenie jest typu N - niezależne
   _typ:='x';
   _ref_zl_nad:=null();
   {? ZL.first()
   || _dtr:=ZL.DTR;
      _typ:=ZL.RODZAJ;
      _ref_zl_nad:=ZL.ref()
   || _dtr:=date(0,0,0)
   ?};
   ZL.cntx_pop();
   {? ZL.DTR>_dtr
   ||  {? _typ<>'N'
       || FUN.emsg(
            'Termin realizacji podzlecenia nie może być późniejszy niż dla zlecenia głównego (%1).\n'
            'Należy podać wcześniejszą datę.'@[$_dtr]
          );
          return(0)
       || _args:=obj_new('DTR');
          _args.DTR:=ZL.DTR;
          {? exec('FindAndGet','#table',ZL,_ref_zl_nad,,"DTR:=_b.DTR; ZL.put()",0,_args)
          || FUN.info('Pomyślnie zmieniono termin realizacji dla zlecenia nadrzędnego.')
          || FUN.error('Nie udało się zmienić terminu realizacji dla zlecenia nadrzędnego.\n'+
                       'Sprawdź czy inny operator nie obsługuje zlecenia nadrzędnego i ponów próbę zmiany daty.');
             return(0)
          ?}
       ?}
   ?}
?};

:: Jezeli wewnętrzny termin realizacji nie jest określony, to przypisuje taki jak termin realizacji
{? ZL.PL_DATA=date(0,0,0) || ZL.PL_DATA:=ZL.DTR ?};
1


\zl_pldt_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Po redakcji pola ZL.PL_DATA
::   WY: 0 / 1
::  OLD: \zl_pldt_ae/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
:: Dla zleceń podrzędnych dodatkowa kontrola przekroczenia terminu ze zlecenia nadrzednego
{? ZL.NRNZL<>0
|| ZL.cntx_psh();
   ZL.index('UNRZL');
   ZL.prefix(ZL.NRNZL);
:: NUCO - dodatkowa zmiana daty jeśli zlecenie jest typu N - niezależne
   _typ:='x';
   _ref_zl_nad:=null();
   {? ZL.first()
   || _pl_data:=ZL.PL_DATA;
      _typ:=ZL.RODZAJ;
      _ref_zl_nad:=ZL.ref()
   || _pl_data:=date(0,0,0)
   ?};
   ZL.cntx_pop();
   {? ZL.PL_DATA>_pl_data
   ||  {? _typ<>'N'
       || FUN.emsg(
            'Wewnętrzny termin realizacji podzlecenia nie może być późniejszy niż dla zlecenia głównego (%1).\n'
            'Należy podać wcześniejszą datę.'@[$_pl_data]
                  );
          return(0)
       || _args:=obj_new('PL_DATA');
          _args.PL_DATA:=ZL.PL_DATA;
          {? exec('FindAndGet','#table',ZL,_ref_zl_nad,,"PL_DATA:=_b.PL_DATA; ZL.put()",0,_args)
          || FUN.info('Pomyślnie zmieniono termin wewnętrznej realizacji dla zlecenia nadrzędnego.')
          || FUN.error('Nie udało się zmienić terminu wewnętrznej realizacji dla zlecenia nadrzędnego.\n'+
                       'Sprawdź czy inny operator nie obsługuje zlecenia nadrzędnego i ponów próbę zmiany daty.');
             return(0)
          ?}
       ?}
   ?}
?};
1

\zl_plforce_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed redagowaniem pola ZL.PL_FORCE
::  OLD:\zl_plforce_be/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------

:: NUCO - dla zleceń niezależnych kierunek powinien być redagowany niezależnie od zlecenia zbiorczego
ZL.NRNZL=0 | sql('select ZL.RODZAJ from ZL where UNRZL=:_a',ZL.NRNZL).RODZAJ='N'



\valid_modify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.28]
:: OPIS: Walidacja przy poprawianiu nagłówka zlecenia
::   WE: _a - 'W'arsztatowe/'P'rodukcyjne
::       _b - czy uruchomiona w procesie
::       _c - czy sprawdzać warunki dotyczących korekty powiązanego limitu - [0]/1
::       [_d] - INTEGER - [0]/1 - czy uruchamiane podczas podziału zlecenia
::   WY: '' albo akronim pola, do którego powrocić
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_wp:=_a;
_proces:=_b;
_czy_kor:={? var_press('_c')=type_of(0) || _c || 0 ?};
_split:={? var_press('_d')=type_of(0) || _d || 0 ?};
_result:='';
{? _wp='P'
||
   _buffer:=params_get().args.buffer;

   {? _result='' & ZL.NR=0
   || {? exec('wol_nr','numery','ZL')>0
      || FUN.info('Numer zlecenia musi być wypełniony.'@);
         _result:='NR'
      ?}
   ?};

:: Sprawdzenie produktu w zleceniach nadrzędnych
   {? _result='' & _buffer.KTM<>ZL.KTM & ZL.TREE<>0 & ZL.KTM<>null()
   || {? exec('chk_ktm','zl_head',ZL.TREE,ZL.KTM)>0
      || FUN.info('Indeks produktu jest wykorzystany w zleceniu wyższego poziomu.'@);
         _result:='KTM'
      ?}
   ?};

   {? _result='' & (ZL.RODZAJ='P' & ZL.TYP().TECH='N' | ZL.RODZAJ='Z') & VAR.ZRED_KTL=''
   || TKTLW.index('KSN');
      TKTLW.prefix('T',ZL.KTM,'T','N');
      {? TKTLW.first()
      || FUN.info('Należy wypełnić pole \'\'Technologia\'\'.'@);
         _result:='ZRED_KTL'
      || FUN.info('Należy zmienić produkt.'@);
         _result:='KTM'
      ?}
   ?};

   {? _result='' & _split=0 & ZL.RODZAJ='P' & VAR.ZRED_KTL='' & ZL.SRCTECH='T'
   || _result:={? exec('valid_tech','zl_head') || '' || 'ZRED_KTL' ?}
   ?};

   {? _proces
   || {? _result='' & ZL.DTR<>date(0,0,0) & ZL.DTR<date() & exec('zl_fld_be','zl_head','DTR')>0
      || FUN.info('Termin realizacji zlecenia %1 nie może być wcześniejszy od daty dzisiejszej.'@[ZL.SYM]);
         _result:='DTR'
      ?}
   ?};

   {? ZL.PL_DATA=date(0,0,0) || ZL.PL_DATA:=ZL.DTR ?};
   {? _result='' & ZL.PL_DATA>ZL.DTR & exec('zl_fld_be','zl_head','PL_DATA')>0
   || FUN.info(
         'Wewnętrzny termin realizacji nie może być późniejszy niż planowany termin realizacji zlecenia.\n'
         'Należy podać wcześniejszą datę.'@
      );
      _result:='PL_DATA'
   ?};

   {? _result=''
   || {? _buffer.IL>ZL.IL & exec('zl_il_zam','zl_gen',ZL.ref())>0
      ||
::       Ostrzeżenie przed zmniejszeniem ilości na zleceniu wygenerowanym z zamówienia
         {? FUN.ask(
               'Zlecenie %1 zostało wygenerowane z pozycji zamówienia.\n\n'
               'Zmniejszenie ilości może spowodować,\n'
               'że zamówienie nie zostanie w całości zrealizowane.\n\nCzy kontynuować?'@[ZL.SYM]
            )=0
         || _result:='IL'
         ?}
      ?}
   ?};

   {? _result=''
   || {? _buffer.IL>ZL.IL & exec('chk_zl','zl_grop',ZL.ref())>0
      ||
::       Ostrzeżenie przed zmniejszeniem ilości na zleceniu użytym w grupach operacji
         {? FUN.ask(
               'Operacje zlecenia %1 zostały wykorzystane w grupach operacji.\n\n'
               'Zmniejszenie ilości może spowodować,\n'
               'że grupy zostaną nieprawidłowo skonfigurowane.\n\nCzy kontynuować?'@[ZL.SYM]
            )=0
         || _result:='IL'
         ?}
      ?}
   ?};

   {? _result=''
   ||
::    Blokada zmniejszania ilości jeżeli zlecenie jest w planie operacyjnym
      {? _buffer.IL>ZL.IL
      ||
         {? ZL.RODZAJ='Z'
         ||
::          Zlecenie złożone - sprawdzam podzlecenia
            ZL.cntx_psh();
            ZL.clear();
            ZL.index('NRNZL');
            ZL.prefix(ZL.UNRZL);
            {? ZL.first()
            || {!
               |?
                  {? exec('zlec_planned','po_plan',$ZL.ref())
                  || _msg:='Jedno ze zleceń podrzędnych zlecenia %1 znajduje się w Planie operacyjnym.'
                           '\nAby zmniejszyć ilość należy usunąć to zlecenie z planu.'@[ZL.SYM];
                     FUN.emsg(_msg);
                     _result:='IL'
                  ?};
                  _result='' & ZL.next()
               !}
            ?};
            ZL.cntx_pop()
         |? ZL.RODZAJ='P'
         ||
            {? exec('zlec_planned','po_plan',$ZL.ref())>=ZL.IL
            || _msg:='Zlecenie %1 znajduje się w Planie operacyjnym.'
                     '\nAby zmniejszyć ilość należy usunąć zlecenie z planu.'@[ZL.SYM];
               FUN.emsg(_msg);
               _result:='IL'
            ?}
         ?}
      ?}
   ?};

   {? _result=''
   ||
::    Blokada zmniejszania ilości poniżej ilości w planie strategicznym
      {? _buffer.IL>ZL.IL
      ||
         {? ZL.RODZAJ='Z'
         || _il_nad:=ZL.IL;
::          Zlecenie zlożone - sprawdzam podzlecenia
            ZL.cntx_psh();
            ZL.clear();
            ZL.index('NRNZL');
            ZL.prefix(ZL.UNRZL);
            {? ZL.first()
            || {!
               |?
                  _proporcja:=ZL.IL/_buffer.IL;
                  _il_prop:=_il_nad*_proporcja;
                  {? exec('zl_utilization','px_plan',ZL.ref())>0
                  || _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
                     {? _px_obj<>null()
                     || _mainver:=exec('get_mainversion','px_ver');
                        _il_queued:=exec('get_ilosc_que','px_obj',_mainver,_px_obj);

                        {? _il_queued>_il_prop
                        || _msg:='Jedno ze zleceń podrzędnych zlecenia %1 znajduje się w Planie strategicznym.'
                                 '\nAby zmniejszyć ilość poniżej %2, należy usunąć zlecenie z planu.'@
                                 [ZL.SYM,$_il_queued];
                           FUN.emsg(_msg);
                           _result:='IL'
                        ?}
                     ?}
                  ?};
                  _result='' & ZL.next()
               !}
            ?};
            ZL.cntx_pop()
         |? ZL.RODZAJ='P'
         ||  _il_nad:=ZL.IL;
             _proporcja:=ZL.IL/_buffer.IL;
             _il_prop:=_il_nad*_proporcja;
            {? exec('zl_utilization','px_plan',ZL.ref())>0
            || _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
               {? _px_obj<>null()
               || _mainver:=exec('get_mainversion','px_ver');
                  _il_queued:=exec('get_ilosc_que','px_obj',_mainver,_px_obj);

                  {? _il_queued>ZL.IL
:: NUCO - umożliwienie zmniejszenia ilości i uzgodnienie planu strategicznego
                  || _msg:='Zlecenie %1 znajduje się w Planie strategicznym.\nKolejka plany zostanie zaktualizowana, czy kontynuować?'@
                           [ZL.SYM];
                     {? FUN.ask(_msg)
                     || _result:=''
                     || _result:='IL'
                     ?}
                  ?}
               ?}
            ?}
         ?}
      ?}
   ?};

   {? _result=''
   ||
::    Blokada zmniejszenia ilości jeżeli partie powiązane z dokumentami
      {? _buffer.IL>ZL.IL
      ||
         _zl_to_chk:=ZL.ref();
         {? ZL.RODZAJ='Z'
         ||
::          Zlecenie zlożone - sprawdzam partie na zleceniu montażowym
            _zl_to_chk:=exec('main_podzlec','zl_link',ZL.ref())
         ?};
         {? _zl_to_chk<>null()
         ||
            ZL.cntx_psh(); ZL.prefix();
            {? ZL.seek(_zl_to_chk)
            || _il_part:=exec('zl_ile_part','zl_partie',ZL.ref());
               {? _il_part>0
               || _il_part_free:=exec('zl_ile_part_free','zl_partie',ZL.ref());
                  _il_part_zaj:=(_il_part-_il_part_free);
                  {? ZL.IL<_il_part_zaj
                  || _msg:='Zlecenie %1 posiada partie powiązane z dokumentami.'
                           '\nNie można zmniejszyć ilości poniżej: %2.'@[ZL.SYM,$_il_part_zaj];
                     FUN.emsg(_msg);
                     _result:='IL'
                  ?}
               ?}
            ?};
            ZL.cntx_pop()
         ?}
      ?};
      ~~
   ?};

   {? _result=''
   || _result:={? ZL.RODZAJ='N'
               || __CHK.record2(ZL,'TYP',,'MG',,'PWYD',,'OPIS',)
               || __CHK.record2(ZL,'TYP',,'MG',,'PWYD',,'KTM',,'IL','Ilość','OPIS',)
               ?}
   ?};

:: Sprawdzam czy magazyn jest z tego samego oddziału co zlecenie
   {? _result='' & ZL.MG().ODDZ<>ZL.ODDZ
   || FUN.emsg('Magazyn przypisany do zlecenia %1 musi być powiązany z tym samym oddziałem co zlecenie.'@[ZL.SYM]);
      _result:='MG'
   ?};

:: Sprawdzam czy magazyn kooperacyjny
   {? _result='' & ZL.MG().KOOP='T'
   || FUN.emsg('Magazyn przypisany do zlecenia %1 nie może służyć do rejestracji kooperacji.'@[ZL.SYM]);
      _result:='MG'
   ?};

:: Sprawdzam dokumenty dostępne w magazynie
   {? _result='' & exec('chk_mg4zl','zl_common',ZL.MG)=0
   || FUN.emsg(
         'Magazyn przypisany do zlecenia %1 powinien mieć przypisany przynajmniej jeden typ dokumentu\n'
         'określony parametrem %2 %3.'@[ZL.SYM,'500701',exec('name','#params',500701,'A')]
      );
      _result:='MG'
   ?};

:: Sprawdzam czy magazyn zlecenia jest zgodny z cechą zlecenia
   {? _result='' & ZL.DK_C<>null()
   || {? ~(ZL.MG().TYP*'DOST')
      || FUN.emsg('Zlecenie ma wypełnioną cechę. '
                  'Magazyn przypisany do zlecenia musi być typu: \'\'%1\'\' lub \'\'%2\'\'.'@['DOSTAWY','DOSTEWI']);
         _result:='MG'
      ?}
   ?};

:: Sprawdzam czy magazyn zlecenia jest zgodny z partiowalnością wyrobu zlecenia
   {? _result='' & exec('material_party','material',ZL.KTM)>0
   || {? ~(ZL.MG().TYP*'DOST')
      || FUN.emsg('Produkt zlecenia jest partiowany. '
                  'Magazyn przypisany do zlecenia musi być typu: \'\'%1\'\' lub \'\'%2\'\'.'@['DOSTAWY','DOSTEWI']);
         _result:='MG'
      ?}
   ?};

:: Dołączenie cechy dostawy
   {? _result='' & (1+ZL.MG().TYP)='D' & ATR.FLAG_ED & ATR.FLAG<>1
   || exec('akcepatr','mat_atr',0,1)
   ?};

:: Sprawdzanie poprawności zwrotu planowania i znacznika kontynuacji po przekroczeniu
   {? _result=''
   || _result:=exec('pl_force_chk','px_utils','ZL')
   ?};

:: Projekty
   {? _result='' & ZL.PROJEKTY<>null()
   || _result:=exec('tabdok_chk','projekty',ZL)
   ?};

:: Porównuje wartości cechy po poprawieniu
   _dkc_after:=exec('buffer','mat_atr');
   {? ZL.DK_C<>null()
   || DK_C.cntx_psh();
      DK_C.clear();
      {? DK_C.seek(ZL.DK_C)
      || _dkc_after.get_dkc()
      ?};
      DK_C.cntx_pop()
   ?};
   {? DKC_BEF.compare(_dkc_after)<>1
   ||
      _zl_top:=ZL.ref();
      _main_podzlec:=exec('main_podzlec','zl_link',ZL.ref());
      {? ZL.ref()=_main_podzlec
      || _zl_top:=exec('top_level','zl_link',ZL.ref())
      ?};
::    Sprawdzam czy limity dziedziczyły atrybut i wyświetlam ostrzeżenie
      {? exec('zl_dkc_update','zl_head',_zl_top,_dkc_after)>0
      || {? ZL.KTM().M_ATR().EDIT
         ||
::          Redakcja bezposrednia - wracam do pierwszego redagowalnego pola
            _red_field:=exec('chk_red_field','mat_atr');
            {? _red_field<>''
            || _result:=5-_red_field
            || _result:='DK_C'
            ?}
         ||
::          Redakcja niebezposrednia - wracam do cechy
            _result:='DK_C'
         ?}
      ?}
   ?};

:: Identyfikator księgowy
   {? _result='' & ZL.ID_KSG<>0
   || ZL.cntx_psh();
      ZL.index('ID_KSG');
      ZL.prefix(ZL.ID_KSG);
      _idadd:=ZL.IDADD;
      {? ZL.first() & _idadd<>ZL.IDADD
      || FUN.emsg('Istnieje zlecenie o identyfikatorze księgowym: %1.'@[$ZL.ID_KSG]);
         _result:='ID_KSG'
      ?};
      ZL.cntx_pop()
   ?};
   {? _result='' & _buffer.IL<>ZL.IL
   ||
::    sprawdzamy czy są jakieś niezatwierdzone limity lub korekty
      ZLIM.cntx_psh();
      ZLIM.index('ZKN');
      ZLIM.prefix(VAR.A_ZLEC,'T');
      {? ZLIM.first()
      || {!
         |? {? ZLIM.AKC='N'
            || FUN.info(
                  'Istnieją niezaakceptowane limity lub korekty.\nNie jest możliwa zmiana ilości na zleceniu %1.'@
                  [ZL.SYM]
               );
               _result:='IL'
            ?};
            ZLIM.next() & _result=''
         !}
      ?};
      ZLIM.cntx_pop()
   ?};

   _top:=exec('top_level','zl_link',VAR.A_ZLEC);

   {? _result='' & _buffer.IL>ZL.IL
   ||
::    sprawdzamy, czy są oddane przewodniki
      ZGH.index('ZLNR');
:: NUCO - weryfikacja tylko zlecenia aktualnie weryfikowanego - bez zleceń w zleceniu zbiorczym
::     ZGH.prefix(_top);
      ZGH.prefix(VAR.A_ZLEC);
      {? ZGH.first()
      || {!
         |? {? ZGH.STAN='T'
            || FUN.info('Istnieją oddane przewodniki.\nNie jest możliwe zmniejszenie ilości na zleceniu %1.'@[ZL.SYM]);
               _result:='IL'
            ?};
            ZGH.next() & _result=''
         !}
      ?}
   ?};
   {? _result='' & _buffer.IL<>ZL.IL
   || {? exec('has_closed','zl_link')>0
      || FUN.info(
            'Redagowane zlecenie %1, lub któreś z jego podzleceń jest zamknięte. Redakcja ilości niemożliwa.'@
            [ZL.SYM]
         );
         _result:='IL'
      ?}
   ?};

   {? _result='' & _buffer.IL>ZL.IL
   ||
      ZL.cntx_psh();
      ZL.clear();
:: NUCO - weryfikacja tylko zlecenia aktualnie weryfikowanego - bez zleceń w zleceniu zbiorczym
::      {? ZL.seek(_top)
      {? ZL.seek(VAR.A_ZLEC)
      || ZL.index('NRNZL');
         ZL.prefix(ZL.UNRZL);
         {? ZL.first()
         || ZGH.cntx_psh();
            ZGH.index('ZLNR');
            {!
            |?
               ZGH.prefix(ZL.ref());
               {? ZGH.first()
               || {!
                  |? {? ZGH.STAN='T'
                     || FUN.info(
                           'Istnieją oddane przewodniki.\nNie jest możliwe zmniejszenie ilości na zleceniu %1.'@[ZL.SYM]
                        );
                        _result:='IL'
                     ?};
                     ZGH.next() & _result=''
                  !}
               ?};
               ZL.next() & _result=''
            !};
            ZGH.cntx_pop()
         ?}
      ?};
      ZL.cntx_pop()
   ?};

   {? _result=''
   || {? ZL.STARTD>ZL.ENDD & ZL.ENDD<>date(0,0,0) | ZL.STARTD=ZL.ENDD & ZL.STARTT>ZL.ENDT & exec('zl_fld_be','zl_head','STARTD')>0
      || FUN.info('Data rozpoczęcia zlecenia %1 musi być wcześniejsza od daty zakończenia.'@[ZL.SYM]);
         _result:='STARTD'
      ?}
   ?};

:: Sprawy związane ze zmianą ilości
   {? _result='' & ZL.IL<>_buffer.IL
   ||
      _ok:=1;
      _star_il:=_buffer.IL;
      ZL.cntx_psh();
      _il:=exec('spr_ilosc','zl_guide',_star_il);
      _ilk:=exec('spr_ilosc','zl_guide',_star_il,1);
      _ilw:=exec('spr_ilwyk','zl_guide',_star_il);
::      _ilr:=exec('spr_ilrea','zl_limit',_star_il);
      ZL.cntx_pop();
      {? _star_il<ZL.IL
      ||
::       Zwiększenie serii
         {? _il>ZL.IL
         ||
::          Przypadek gdy było już zarejetrowane więcej robocizny niż zwiększyłem ilości na zleceniu
            _msg:='Zwiększenie serii z %1 do %2 jest możliwe.\n\nAkord został już zarejestrowany dla %3'
                  '\% produktu.\nSugerowana minimalna ilość jaką można wpisać to: %4'
                  '\n\nCzy pozostawiasz ilość: %2?'@[form(_star_il),$ZL.IL,form(_il/_star_il*100,,2),form(_il)];

            _choice:=FUN.choice(_msg,,'Pozostaw: %1'@[$ZL.IL],'Zmień na: %1'@[form(_il)]);
            {? _choice=1
            ||
::             Zostawiam taką ilość jaka była w oknie, nic się nie dzieje
               ~~
            |? _choice=2
            ||
::             Wpisuję ilość sugerowaną w komunikacie
               ZL.IL:=_il
            ||
::             Użytkownik anulował, wracam do redakcji pola
               _result:='IL'
            ?}
         |? _buffer.ILDOK>ZL.IL
         ||
::          Przypadek gdy było już zarejestrowane więcej na dokumentach RP niż zwiększyłem ilości na zleceniu
            _msg:='Zwiększenie serii z %1 do %2 jest możliwe.\n\Dokumenty raportujace zostały już zarejestrowane na %3 %4'
                  '\nSugerowana minimalna ilość jaką można wpisać to: %3'
                  '\n\nCzy pozostawiasz ilość: %2?'@[form(_star_il),$ZL.IL,form(_buffer.ILDOK),ZL.KTM().J().KOD];

            _choice:=FUN.choice(_msg,,'Pozostaw: %1'@[$ZL.IL],'Zmień na: %1'@[form(_buffer.ILDOK)]);
            {? _choice=1
            ||
::             Zostawiam taką ilość jaka była w oknie, nic się nie dzieje
               ~~
            |? _choice=2
            ||
::             Wpisuję ilość sugerowaną w komunikacie
               ZL.IL:=_buffer.ILDOK
            ||
::             Użytkownik anulował, wracam do redakcji pola
               _result:='IL'
            ?}
         ?}
      ||
::       Zmniejszenie serii
::         {? _ilw>ZL.IL
::         || FUN.emsg('Zmniejszenie serii nie jest możliwe.\n\nWykonano już %1'
::               '\% produktu.\nMinimalna ilość jaką można wpisać to: %2.'@[form(_ilw/_star_il*100,,2),form(_ilw)]
::            );
::            _result:='IL'
::         |? _il>ZL.IL
::         || FUN.emsg('Zmniejszenie serii nie jest możliwe.\n\nAkord został już zarejestrowany dla %1'
::               '\% produktu.\nMinimalna ilość jaką można wpisać to: %2.'@[form(_il/_star_il*100,,2),form(_il)]
::            );
::            _result:='IL'
         {? _ilk>ZL.IL
         || FUN.emsg('Zmniejszenie serii nie jest możliwe.\n\nKooperację wydano już dla %1'
               '\% produktu.\nMinimalna ilość jaką można wpisać to: %2.'@[form(_ilk/_star_il*100,,2),form(_ilk)]
            );
            _result:='IL'
         ?}
      ?}
   ?};
   {? _result='' & ZL.IL<_buffer.IL
   ||
::    Sprawdzamy czy można zmniejszyć ilość w oparciu o to o ile można zmniejszyć przewodniki
::    Na przewodnikach ta ilość jest wyliczana w oparciu o robociznę i rozliczenie partii
      _obj:=obj_new('COEF');
      _coef:=1-(ZL.IL/_buffer.IL);
      _obj.COEF:=~~;
      exec('get_ilosc2decrease_zl','zl_head',ZL.ref,_obj,_coef);

      {? type_of(_obj.COEF)>0
      ||
::       Mam współczynnik więc obliczam o ile można zmniejszyć
         {? _obj.COEF>0
         || _min_ilosc:=_buffer.IL*_obj.COEF
         || _min_ilosc:=ZL.IL
         ?};
         _min_ilosc:=exec('zaokr','jm',_min_ilosc,ZL.KTM);

         {? _min_ilosc>0 & ZL.IL<_min_ilosc
         ||
::          Użytkownik wpisał mniej niż dozwolone, komunikat i powrót do redagowania
            _msg:=
               'Nie można zmniejszyć ilości na zleceniu %1 do %2.\n\n'
               'Minimalna ilość wyliczona w oparciu o istniejącą robociznę,\nrozliczenie partii to: %3.'@
               [ZL.SYM,$ZL.IL,$_min_ilosc];
            FUN.emsg(_msg);
            _result:='IL'
         ?}
      ?}
   ?};

:: Sprawdzam czy po ewentualnej korekcie ilości na podzleceniach i powiązanych z nimi limitach będą zgodne
   {? _czy_kor & _result='' & ZL.IL<>_buffer.IL
   ||
      _coef:={? _buffer.IL<>0 || ZL.IL/_buffer.IL || 0 ?};
      {? exec('subsubzlec_exist','zl_link',ZL.ref())>0
      || _limzl:=exec('kor_chk_limzl','zl_common',ZL.ref(),_coef);
         {? _limzl.RESULT=0
         || _msg:='UWAGA!\nPo wprowadzeniu korekty ilość na przynajmniej jednym limicie nie będzie zgodna z '
                  'ilością powiązanego z nim zlecenia.\n\nDla przykładu:\n'
                  'Ilość na zleceniu %1 po korekcie:%2.\n'
                  'Ilość na powiązanym limicie:%3.\n\n'
                  'Do zachowania spójności wymagane będzie przeprowadzenie dodatkowych korekt.\n'
                  'Czy mimo to zatwierdzić modyfikacje danych zlecenia?'@[_limzl.ZL,$_limzl.IL_ZL,$_limzl.IL_ZLIM];
            {? ~FUN.ask(_msg)
            || _result:='IL'
            ?}
         ?}
      ?}
   ?}
||
:: Zlecenie warsztatowe
   {? _proces
   || {? _result='' & ZL.DTR<>date(0,0,0) & ZL.DTR<date() & exec('zl_fld_be','zl_head','DTR')>0
      || FUN.info('Termin realizacji zlecenia %1 nie może być wcześniejszy od daty dzisiejszej.'@[ZL.SYM]);
         _result:='DTR'
      ?}
   ?};

   {? ZL.PL_DATA=date(0,0,0) || ZL.PL_DATA:=ZL.DTR ?};
   {? _result='' & ZL.NR=0
   || {? exec('wol_nr','numery','ZL')>0
      || FUN.info('Numer zlecenia musi być wypełniony.'@);
         _result:='NR'
      ?}
   ?};

   {? _result='' & ZL.PL_DATA>ZL.DTR & exec('zl_fld_be','zl_head','PL_DATA')>0
   || FUN.info(
         'Wewnętrzny termin realizacji nie może być późniejszy niż planowany termin realizacji zlecenia %1.\n'
         'Należy podać wcześniejszą datę.'@[ZL.SYM]
      );
      _result:='PL_DATA'
   ?};

   {? _result='' || _result:=__CHK.record(ZL,,'TYP','PWYD','OPIS') ?};

   {? _result=''
   || {? ZL.STARTD>ZL.ENDD & ZL.ENDD<>date(0,0,0) | ZL.STARTD=ZL.ENDD & ZL.STARTT>ZL.ENDT & exec('zl_fld_be','zl_head','STARTD')>0
      || FUN.info('Data rozpoczęcia zlecenia %1 musi być wcześniejsza od daty zakończenia.'@[ZL.SYM]);
         _result:='STARTD'
      ?}
   ?};

:: Sprawdzanie poprawnosci zwrotu planowania i znacznika kontynuacji po przekroczeniu
   {? _result=''
   || _result:=exec('pl_force_chk','px_utils','ZL')
   ?};

:: Identyfikator księgowy
   {? _result='' & ZL.ID_KSG<>0
   || ZL.cntx_psh();
      ZL.index('ID_KSG');
      ZL.prefix(ZL.ID_KSG);
      _idadd:=ZL.IDADD;
      {? ZL.first() & _idadd<>ZL.IDADD
      || FUN.emsg('Istnieje zlecenie o identyfikatorze księgowym: %1.'@[$ZL.ID_KSG]);
         _result:='ID_KSG'
      ?};
      ZL.cntx_pop()
   ?}
?};

:: Jeżeli wszystko dobrze, to dodatkowa walidacja za pomocą wtyczki (tylko podczas modyfikacji w oknie redagowania)
{? _result='' & cur_kwin()='e_edit' & cur_tab(1,1)=ZL
|| ZL.cntx_psh();
   _result:=Plugin.run('ZL_VALID_001','MOD');
   ZL.cntx_pop()
?};
_result

