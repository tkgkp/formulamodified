:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku:  px_grp.fml [12.10]
:: Utworzony: 2011-07-19
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Obiekty grupujace (elementy kolejki) w planie strategicznym (wielowymiarowym planie pojemnosciowym)
::======================================================================================================================


\px_grp_tmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: Utworzenie tabeli tymczasowej na podstawie PX_GRP
::       Kontekst wywolania: PxSelect.VER_QUE albo PxSelect.VER_QUE1 (w zaleznosci od parametru _a)
::   WE: [_a] - 0 (domyslnie) podstawowa kolejka, 1 - kopia kolejki
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _kopia:=_a || _kopia:=0 ?};

:: ukrywamy akcje - standardowe z okna obiektu jtree (Dolacz, Zmiany):
_hide:='DZ:DZ';

:: ukrywamy akcje, gdy wyłączone redagowanie (Popraw, pOrządkuj, Blokuj, odbloKuj, usuń z plAnu, pRzesuń)
:: oraz gdy kopia:
{? PX_VAR.EDIT<>1 | _kopia | ~exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPLA')
|| _hide:='POUBKAR'+_hide
?};

:: ukrywamy akcje dla widoku w zakladkach
{? exec('queue_in_tabs','px_param') || _hide:='T'+_hide ?};

{? _kopia || _hide:='M'+_hide+'M' ?};

:: UWAGA: w formułach dotyczących porównywania kolejek actions() jest wpisane jawnie, więc w razie modyfikacji
::        w tym miejscu, trzeba zmodyfikować również exec('queue_select','px_grp')

_debug:=0;
PxSelect.mask:=PX_GRP.name();

($('PxSelect.Pxgrp'+{? _kopia || '1' || '' ?}))():=obj_new(@.CLASS.TREEVIEW,_hide,_debug);
_obiekt:={? _kopia || PxSelect.Pxgrp1 || PxSelect.Pxgrp ?};
_obiekt.KOPIA:=_kopia;

_obiekt.fld('UID','STRING[20]','Unikalny symbol'@, 11,0,1,0);
_obiekt.fld('TYP','STRING[8]','Typ węzła'@, 11,0,1,0);
_obiekt.fld('PX_GRPI','STRING[16]','$PX_GRP', 11,0,1,0);
_obiekt.fld('PX_CONN','STRING[16]','$PX_CONN', 11,0,1,0);
_obiekt.fld('LP_Q','REAL','LP grupujące'@, 3,0,1,0);
_obiekt.fld('SYMBOL','STRING[60]','Symbol'@, 20,0,1,0);
_obiekt.fld('NAZWA','STRING[60]','Nazwa'@, 20,0,1,0);
_obiekt.fld('M','STRING[100]','Materiał'@, 20,0,1,0);
_obiekt.fld('ILOSC','REAL','Ilość'@, 10,ST.DOKL,1,0);
_obiekt.fld('DIR','STRING[2]','Zwrot'@, 3,0,1,0);
_obiekt.fld('BLK','STRING[1]','Blokada'@, 2,0,1,0);
_obiekt.fld('PLAN_OPR','STRING[1]','Plan operacyjny'@, 2,0,1,0);
_obiekt.fld('PX_TEX','REAL','Przepis planowania'@, 3,0,1,0);
_obiekt.fld('STARTD','REAL','Początek planu [data]'@, 11,0,1,0);
_obiekt.fld('STARTT','STRING[8]','Początek planu [godzina]'@, 8,0,1,0);
_obiekt.fld('TM_START','REAL','Początek planu [tm_stamp]'@, 24,0,1,0);
_obiekt.fld('ENDD','REAL','Koniec planu [data]'@, 11,0,1,0);
_obiekt.fld('ENDT','STRING[8]','Koniec planu [godzina]'@, 8,0,1,0);
_obiekt.fld('TM_END','REAL','Koniec planu [tm_stamp]'@, 24,0,1,0);
_obiekt.fld('C_ILOSC','REAL','Ilość'@, 10,ST.DOKL,0,1);
_obiekt.fld('LP_GRP','REAL','LP w grupie'@, 3,0,1,0);
_obiekt.fld('PX_OBJ','STRING[16]','wskazanie na PX_OBJ', 11,0,1,0);
_obiekt.fld('JM','STRING[10]','jm'@, 5,0,0,0);
_obiekt.fld('T_REAL','STRING[10]','Termin realizacji'@,-11,0,0,0);
_obiekt.fld('T_QUEUE','STRING[10]','Planowana realizacja'@,10,0,1,0);
_obiekt.fld('T_PLAN','STRING[19]','Planowana realizacja'@,-11,0,0,0);
_obiekt.fld('T_START','STRING[19]','Planowany początek prac'@,-11,0,1,0);
_obiekt.fld('KOLOR','STRING[23]','', 3,0,1,0);
_obiekt.fld('ZNACZNIK','STRING[1]','Zwrot'@,3,0,0,0);
_obiekt.fld('PROBLEMS','STRING[20]','Problemy'@,20,0,1,0);
_obiekt.fld('STATUS','STRING[20]','Status'@,20,0,1,0);
_obiekt.fld('CMP','STRING[2]','Status porównania wersji'@,1,0,1,0);
_obiekt.fld('KOM_ERR','STRING[1]','Komunikaty planu - błędy'@,1,0,1,0);
_obiekt.fld('KOM_WARN','STRING[1]','Komunikaty planu - ostrzeżenia'@,1,0,1,0);
_obiekt.fld('KOM_INFO','STRING[1]','Komunikaty planu - informacje'@,1,0,1,0);
_obiekt.fld('PX_POINT','STRING[1]','Czy są punkty czasowe [T/N]'@,1,0,1,0);
_obiekt.fld('PL_FORCE','STRING[1]','Kontynuować planowanie poza termin?'@,1,0,1,0);
_obiekt.fld_fml('TXT','BEFORE_DISPLAY','exec(\'txt_bd\',\'px_grp\')');
_obiekt.fld_fml('T_REAL','BEFORE_DISPLAY','exec(\'t_real_bd\',\'px_grp\')');
_obiekt.fld_fml('ZNACZNIK','BEFORE_DISPLAY','cur_tab(1,1).KOLOR');
_obiekt.fld_fml('DIR','DISPLAY_FORMAT','\'empty=1\'');
:: szerokosc wyswietlanego okienka
_obiekt.SZEROK:=60;

set_virt(_obiekt,'f_record',"
   exec('px_grp_rkprz','px_grp')
");

set_virt(_obiekt,'f_legend',"
   exec('px_grp_legenda','px_grp')
");
:: Takie czary żeby mechanizm tłumaczeń złapał
'Kolejka: %1'@[''];
set_virt(_obiekt,'title',"
   PX_VAR.VER_QUE:={? .KOPIA || PxSelect.VER_QUE1 || PxSelect.VER_QUE ?};
   'Kolejka: %1'@[PX_VAR.VER_QUE().SYMBOL]
");
:: Takie czary żeby mechanizm tłumaczeń złapał
'Lp.'@;
'Symbol'@;
set_virt(_obiekt,'hdr_1st',"
   '%1 | %2'@['Lp.'@,'Symbol'@]
");

set_virt(_obiekt,'f_displ',"
   exec('px_grp_display','px_grp')
");

set_virt(_obiekt,'load',"
   .TAB.erase();
   .TAB.cntx_psh();
   PX_GRP.cntx_psh();
   PX_GRP.index('VISIBLE');

:: Pokazujemy tylko niewykonane w calosci
   PX_GRP.prefix({? .KOPIA || PxSelect.VER_QUE1 || PxSelect.VER_QUE ?},'T','Z');
   {? PX_GRP.first()
   || {!
      |? exec('level1','px_grp',0,.);
         PX_GRP.next()
      !}
   ?};
   PX_GRP.cntx_pop();
   .TAB.cntx_pop();
   ~~
");

set_virt(_obiekt,'win_fml',"
  \"
   {? cur_afld()='TXT'
   || {? cur_tab(1,1).LEV=1
      || _ok:=0;
         PX_CONN.cntx_psh();
         PX_GRP.cntx_psh();
         PX_GRP.clear();
         {? PX_GRP.seek(cur_tab(1,1).PX_GRPI,8+cur_tab(1,1).PX_GRPI)
         || _ref:=PX_GRP.ref();
            PX_CONN.index('PX_GRP');
            PX_CONN.prefix(_ref);
            _ok:=PX_CONN.first()
         ?};
         PX_CONN.cntx_pop();
         PX_GRP.cntx_pop();
         {? _ok
         ||
            {? cur_tab(1,1).PLAN_OPR='T'
            || exec('pl_plan','icon')
            |? cur_tab(1,1).BLK='T' | cur_tab(1,1).BLK='Z'
            || 'xwin16.png:157'
            |? cur_tab(1,1).PROBLEMS<>exec('problem_none','px_obj')

            || 'xwin16.png:4'
            || {? cur_tab(1,1).tr_state()
               || 'xwin16.png:75'
               || 'xwin16.png:74'
               ?}
            ?}
         || 'xwin16.png:76'
         ?}
      || ''
      ?}
   |? cur_afld()='DIR'
   || {? cur_tab(1,1).DIR='1'
      || 'xwin16.png:22'
      |? cur_tab(1,1).DIR='-1'
      || 'xwin16.png:85'
      || ''
      ?}
   |? cur_afld()='T_PLAN'
   || {? cur_tab(1,1).PX_POINT='T'
      || 'xwin16.png:133'
      || 'xwin16.png:110'
      ?}
   |? cur_afld()='C_ILOSC' & cur_tab(1,1).PX_OBJ=''
   || {? cur_tab(1,1).STATUS=exec('status_wyk1','px_grp')
      || 'xwin16.png:72'
      |? cur_tab(1,1).STATUS=exec('status_wyk2','px_grp')
      || 'xwin16.png:13'
      || ''
      ?}
   || ''
   ?}
  \"
");

set_virt(_obiekt,'f_delete',"
:: tu usuwamy rekord lub rekordy powiazane
   exec('usu','px_grp',!.)
");

set_virt(_obiekt,'f_del_bg',"
   exec('usu_gb','px_grp',!.)
");

set_virt(_obiekt,'f_del_ag',"
   exec('usu_ga','px_grp',!.)
");

set_virt(_obiekt,'f_modify',"
   exec('px_grp_correct','px_grp',!.)
");

set_virt(_obiekt,'f_mod_bg',"
   exec('px_grp_corr_bg','px_grp',!.)
");

set_virt(_obiekt,'f_mod_ag',"
   VAR.GRUPA:='N';
   ~~
");
:: Takie czary żeby mechanizm tłumaczeń złapał tekst
'Usuń z pl&anu'@;
set_virt(_obiekt,'f_akcje',"
   .TAB.win_fml(.WERT,,'TXT',,'ICON_BEFORE',.win_fml());
   .TAB.win_fml(.WERT,,'DIR',,'ICON_BEFORE',.win_fml(),2);
   .TAB.win_fml(.WERT,,'T_PLAN',,'ICON_BEFORE',.win_fml(),2);
   .TAB.win_fml(.WERT,,'C_ILOSC',,'ICON_BEFORE',.win_fml());
   {? PX_VAR.EDIT=1
   || _akcja:=\"exec('px_que_organize','px_grp',PxSelect.VER_QUE)\";
      .TAB.win_act(.WERT,0,'Formuła','P&orządkuj'@@,,,_akcja,,0,,,,'O');
      task_attach('TPP_PPS_DPLA')
   ?};

   _akcja:=\"exec('go_obj_date','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Do da&ty'@@,,,_akcja,,0,,,,'T');

   _akcja:=\"exec('block_action','px_grp')\";
   _akcjabg:=\"exec('block_actionb','px_grp')\";
   _akcjaag:=\"exec('block_actiona','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','&Blokuj'@@,,,_akcja,,0,1,_akcjabg,_akcjaag,'B');
   task_attach('TPP_PPS_DPLA');

   _akcja:=\"exec('unblock_action','px_grp')\";
   _akcjabg:=\"exec('unblock_actionb','px_grp')\";
   _akcjaag:=\"exec('unblock_actiona','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Odblo&kuj'@@,,,_akcja,,0,1,_akcjabg,_akcjaag,'K');
   task_attach('TPP_PPS_DPLA');

   _akcja:=\"exec('select_komm','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Komu&nikaty'@@,,,_akcja,,0,,,,'N');

   _akcja:=\"exec('del_direct_act','px_grp')\";
   _akcjabg:=\"exec('del_direct_gr1','px_grp')\";
   _akcjaag:=\"exec('del_direct_gr2','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Usuń z pl&anu'@@,,,_akcja,,0,1,_akcjabg,_akcjaag,'A');
   task_attach('TPP_PPS_DPLA');

   {? PxSelect.Context<>'ZAM' & PxSelect.Context<>'ZL'
   ||
      _akcja:=\"exec('select_action','px_point')\";
      .TAB.win_act(.WERT,0,'Formuła','Punkty &czasowe'@@,,,_akcja,,0,,,,'C')
   ?};

:: Menu Przesuń
   .TAB.win_act(.WERT,0,'Menu','P&rzesuń'@,,,,,,,,,'R');
   _akcja:=\"exec('move_grp_up','px_grp',0)\";
   .TAB.win_act(.WERT,0,'Formuła','(n) w gó&rę'@@,'#R',,_akcja,,,,,,'R');
   task_attach('TPP_PPS_DPLA');
   .TAB.act_icn(.WERT,0,'RR','xwin16.png:103');
   _akcja:=\"exec('move_grp_up','px_grp',1)\";
   .TAB.win_act(.WERT,0,'Formuła','(1) w &górę'@@,'#R',,_akcja,,,,,,'G');
   task_attach('TPP_PPS_DPLA');
   .TAB.act_icn(.WERT,0,'RG','xwin16.png:104');
   _akcja:=\"exec('move_grp_down','px_grp',1)\";
   .TAB.win_act(.WERT,0,'Formuła','(1) w &dół'@@,'#R',,_akcja,,,,,,'D');
   task_attach('TPP_PPS_DPLA');
   .TAB.act_icn(.WERT,0,'RD','xwin16.png:105');
   _akcja:=\"exec('move_grp_down','px_grp',0)\";
   .TAB.win_act(.WERT,0,'Formuła','(n) &w dół'@@,'#R',,_akcja,,,,,,'W');
   task_attach('TPP_PPS_DPLA');
   .TAB.act_icn(.WERT,0,'RW','xwin16.png:106');
   .TAB.win_act(.WERT,0,'Formuła','--X','#R');
   task_attach('TPP_PPS_DPLA');
   _akcja:=\"exec('move_grp_to','px_grp')\";
   _akcja_bg:=\"exec('move_grp_to_bg','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Do &numeru'@@,'#R',,_akcja,,,1,_akcja_bg,,'N');
   task_attach('TPP_PPS_DPLA');
   .TAB.act_icn(.WERT,0,'RN','xwin16.png:107');

:: Menu Funkcje
   .TAB.win_act(.WERT,0,'Menu','Funkcje'@,,,,,,,,,'F');
   _fb:=\"exec('sel_sur_pxver','px_sur',PX_VAR.VIE_VER)\";
   .TAB.win_act(.WERT,0,'Formuła','&Zapotrzebowania'@@,'#F',,_fb,,,,,,'Z');
   _fb:=\"exec('select_grp','px_poz')\";
   .TAB.win_act(.WERT,0,'Formuła','&Pozycje planu dla grupy'@@,'#F',,_fb,,,,,,'P');
   _fb:=\"exec('diagram','px_con_g',PX_VAR.VER_QUE)\";
   .TAB.win_act(.WERT,0,'Formuła','&Diagram'@@,'#F',,_fb,,,,,,'D');
   {? PX_VAR.EDIT=1
   ||
      .TAB.win_act(.WERT,0,'Formuła','--Q','#F');
      _fb:=\"exec('action_generuj','!tte_pzl_dzpx')\";
      _gr1:=\"exec('action_generuj_gr1','!tte_pzl_dzpx',PxSelect.Pxgrp)\";
      _gr2:=\"exec('action_generuj_gr2','!tte_pzl_dzpx',PxSelect.Pxgrp)\";
      .TAB.win_act(.WERT,0,'Formuła','Generuj zlecenia'@@,'#F',,_fb,,,1,_gr1,_gr2,'G');
      task_attach('TTE_PZL_DZPX')
   ?};
   _fb:=\"exec('zlecenia','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Z&lecenia'@@,'#F',,_fb,,,,,,'L');

:: Menu kolejka
   .TAB.win_act(.WERT,0,'Menu','Kol&ejka'@,,,,,,,,,'E');
   _fb:=\"exec('scal_obj','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','&Scal obiekty'@@,'#E',,_fb,,,,,,'S');
   task_attach('TPP_PPS_DPLA');
   _fb:=\"exec('queue_copy','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','&Kopiuj kolejkę'@@,'#E',,_fb,,,,,,'K');
   task_attach('TPP_PPS_DPLA');
   _fb:=\"exec('queue_cmp','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Po&równaj kolejki'@@,'#E',,_fb,,,,,,'R');
   _fb:=\"exec('queue_merge','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Prz&ywróć kolejkę'@@,'#E',,_fb,,,,,,'Y');
   task_attach('TPP_PPS_DPLA');


:: Menu Podgląd
   .TAB.win_act(.WERT,0,'Menu','Pod&gląd'@,,,,,,,,,'G');
   _fb:=\"exec('wer_px_txt_v','px_grps')\";
   .TAB.win_act(.WERT,0,'Formuła','Podgląd prz&episu'@@,'#G',,_fb,,0,,,,'E');
   task_attach('TPP_PPS_DPPL');
   task_attach('TPP_PPS_PPPL');
   _fb:=\"exec('select_paczka','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Przep&is źródłowy'@@,'#G',,_fb,,0,,,,'I');
   .TAB.win_act(.WERT,0,'Formuła','--X','#G');
   _fb:=\"exec('view_act_queue','px_plan')\";
   .TAB.win_act(.WERT,0,'Formuła','&Kolejka'@@,'#G',,_fb,,,,,,'K');
   _fb:=\"exec('view_act_obj','px_plan')\";
   .TAB.win_act(.WERT,0,'Formuła','&Obiekty'@@,'#G',,_fb,,,,,,'O');
   _fb:=\"exec('view_act_queue_obj','px_plan')\";
   .TAB.win_act(.WERT,0,'Formuła','Ko&lejka+obiekty'@@,'#G',,_fb,,,,,,'L');
   _fb:=\"exec('view_act_queue_obj','px_plan')\";

:: NUCO - menu X funkcje NUCO
   .TAB.win_act(.WERT,0,'Menu','(&X)Funkcje NUCO',,,,,,,,,'X');
   _fb:=\"exec('zlecenie_px_grp','qprodukcja')\";
   .TAB.win_act(.WERT,0,'Formuła','Uruchom proces generowania zlecenia','#X',,_fb);

::   _akcja:=\"exec('px_grp_sur','px_grp')\";
::   .TAB.win_act(.WERT,0,'Formuła','Surow&ce',,,_akcja,,0);

::   {? PX_VAR.VER_QUE().STATUS=exec('status_ready','px_ver')
::   || _akcja:=\"exec('accept','px_ver',PX_VAR.VIE_VER)\";
::      PxSelect.Pxgrp.TAB.win_act(PxSelect.Pxgrp.WERT,0,'Formuła','Akceptuj plan',,,_akcja,,1);
::      PxSelect.Pxgrp.TAB.win_act(PxSelect.Pxgrp.WERT,1,'Formuła','Akceptuj plan',,,_akcja,,1)
::   || _akcja:=\"exec('px_que_accept','px_grp',PX_VAR.VER_QUE)\";
::      PxSelect.Pxgrp.TAB.win_act(PxSelect.Pxgrp.WERT,0,'Formuła','Akceptuj kolejkę',,,_akcja,,1);
::      PxSelect.Pxgrp.TAB.win_act(PxSelect.Pxgrp.WERT,1,'Formuła','Akceptuj kolejkę',,,_akcja,,1)
::   ?};
   ~~
");

_obiekt.init();
_obiekt.NDX_UP;
_obiekt.TAB.index(_obiekt.NDX_UP);
_obiekt.TAB.prefix();
_obiekt.update();

:: Przyciski (tylko jak redagowanie)
{? PX_VAR.EDIT=1 & ~_kopia & exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPLA')
||
   _btn:=_obiekt.TAB.win_btn(_obiekt.WERT,'icon=xwin16.png:103,panel=right,align=begin','menu:RR');
   _obiekt.TAB.btn_sopt(_obiekt.WERT,_btn,'tooltip='+'Przesunięcie w górę o N pozycji'@);
   _btn:=_obiekt.TAB.win_btn(_obiekt.WERT,'icon=xwin16.png:104,panel=right,align=begin','menu:RG');
   _obiekt.TAB.btn_sopt(_obiekt.WERT,_btn,'tooltip='+'Przesunięcie w górę o 1 pozycję'@);
   _btn:=_obiekt.TAB.win_btn(_obiekt.WERT,'icon=xwin16.png:105,panel=right,align=begin','menu:RD');
   _obiekt.TAB.btn_sopt(_obiekt.WERT,_btn,'tooltip='+'Przesunięcie w dół o 1 pozycję'@);
   _btn:=_obiekt.TAB.win_btn(_obiekt.WERT,'icon=xwin16.png:106,panel=right,align=begin','menu:RW');
   _obiekt.TAB.btn_sopt(_obiekt.WERT,_btn,'tooltip='+'Przesunięcie w dół o N pozycji'@);
   _btn:=_obiekt.TAB.win_btn(_obiekt.WERT,'icon=xwin16.png:107,panel=right,align=begin','menu:RN');
   _obiekt.TAB.btn_sopt(_obiekt.WERT,_btn,'tooltip='+'Przesunięcie na N-tą pozycję'@);
   ~~
?};

:: tu zrobimy dnd w okienku zmiana kolejnosci
{? PX_VAR.EDIT=1 & ~_kopia & exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPLA')
|| _obiekt.TAB.dnd_sel(_obiekt.WERT,,'records.#tree_wert',"exec('dnd_renum','px_grp')")
?};
_obiekt.TAB.first();
~~


\gx_grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: opis galezi drzewa
::   WE: _a - Obiekt, np. '@.PxSelect.Pxgrp'
::----------------------------------------------------------------------------------------------------------------------
_obiekt:=($(_a))();
{? _obiekt.TAB.PX_OBJ=''
|| PX_GRP.cntx_psh();
   PX_GRP.clear();
:: NUCO - dodatkowe opisy dla grupy obiektów planu strategicznego
   _wyn:={? PX_GRP.seek(_obiekt.TAB.PX_GRPI,PxSelect.mask)
         || $PX_GRP.LP_Q+'. '+PX_GRP.SYMBOL +' - '+ PX_GRP.M().N + ' ('+ PX_GRP.M().KTM + ')'
         || {? PX_GRP.NAZWA=''
            || '<BRAK - technologii>' + ' - '+ PX_GRP.M().N + ' ('+ PX_GRP.M().KTM + ')'
            || PX_GRP.NAZWA +' - '+ PX_GRP.M().N + ' ('+ PX_GRP.M().KTM + ')'
            ?}
         ?};
   PX_GRP.cntx_pop()
|| PX_CONN.cntx_psh();
   PX_CONN.clear();
:: NUCO - dodatkowe opisy dla grupy obiektów planu strategicznego
   _wyn:={? PX_CONN.seek(_obiekt.TAB.PX_CONN,'pxcon'+(PxSelect.mask+3))
         || $PX_CONN.LP_GRP +'. '+PX_CONN.PX_OBJ().SYMBOL +' - '+ PX_CONN.M().N
         || '1. '+'<NIE ZNALEZIONO OBIEKTU>'
         ?};
   PX_CONN.cntx_pop()
?};
_wyn


\to_queue
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: ranking
::   WE: _a - tabela przenoszonych rekordow
::       _b - na co upuszczamy
::       [_c] - czy uzyc win_disp() po reorganziacji kolejki (domyslnie 1 = tak)
::       [_d] - PX_VER.ref() - wersja planu
::       [_e] - INTEGER - 0/[1] - czy wyświetlać okno edycyjne, czy dodawać wg domyślnych wartości
::       [_f] - INTEGER - 0/[1] - czy sprawdzać poprawność dodawania
::       [_g] - INTEGER - [0]/1 - czy akcja grupowa czy pojedyncza, jeśli nie podane to określane
::                                na podstawie rozmiaru _a
::       [_h] - INTEGER  - [0]/1 - czy automatycznie ustalać zestaw, czy brać bieżący ustawiony
::       [_i]   - INTEGER - tryb dialogów:   0 - brak,
::                                           1 - komunikaty na ekran
::                                           2 - komunikaty do KOMMa,
::                                           3 - komunikaty do PX_KOMM i do _mp.error
::       [_j] - PX_TAG.ref - grupa obiektów
::       [_k] - GROP.ref - grupa operacji
::   WY: 0 - nie dodano do kolejki
::       1 - dodano
::  OLD: \grupowanie/px_grp.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
exec('dropped_update','px_grp',_a);

{? var_pres('_c')=type_of(0) || _win_disp:=_c || _win_disp:=1 ?};
__dropped:=_dropped:=_a;
_drop_dest:=_b;
{? var_pres('_c')=type_of(0) || _win_disp:=_c || _win_disp:=1 ?};

{? var_pres('_d')=type_of(PX_VER.ref())
|| _px_ver:=_d
|| _px_ver:=PxSelect.VER_QUE
?};
_edit:=1;
{? var_pres('_e')=type_of(0)
|| _edit:=_e
?};

_ctrl:=1;
{? var_pres('_f')=type_of(0)
|| _ctrl:=_f
?};

{? var_pres('_g')=type_of(0)
|| _grupa:=_g
|| _grupa:={? _dropped.size()>1 || 1 || 0 ?}
?};

_autoset:=0;
{? var_pres('_h')=type_of(0)
|| _autoset:=_h
?};
_dialog:=1;
{? var_pres('_i')=type_of(0)
|| _dialog:=_i
?};
_px_tag:=null();
{? var_pres('_j')=type_of(PX_TAG.ref())
|| _px_tag:=_j
?};
_grop:=null();
{? var_pres('_k')=type_of(PX_TAG.ref())
|| _grop:=_k
?};

_result:=0;
_can_continue:=1;

__blokada:=0;
PX_VAR.GROPS:=null();
PX_VAR.GROP:=_grop;
PL_RES.blank();

{? _grupa=0
||
   PX_VAR.TM_END:=0;
   PX_VAR.TM_GRN:=0;
   PX_VAR.GRN_DATA:=date();
   PX_VAR.GRN_TIME:=time(0,0,0);
   PX_VAR.AGR:='N';
   PX_VAR.PL_FORCE:='N';
   ~~
?};
_ok:=1;

PX_OBJ.cntx_psh(); PX_OBJ.clear();
PX_GRP.cntx_psh(); PX_GRP.clear();
PX_CONN.cntx_psh(); PX_CONN.clear();
PX_TEX.cntx_psh(); PX_TEX.clear();
PX_SET.cntx_psh();
GROPS.cntx_psh();

_one_ver:=exec('is_one_version','px_param');

_drop_grp:=null;

{? _drop_dest<>null()
|| {? ref_tab(_drop_dest)=PX_GRP
   || _drop_grp:=_drop_dest
   ||
      PxSelect.Pxgrp.TAB.cntx_psh();
      PxSelect.Pxgrp.TAB.clear();
      {? PxSelect.Pxgrp.TAB.seek(_drop_dest)
      ||
         {? _one_ver
         || _drop_grp:=PX_GRPS.PX_GRP
         || {? PX_GRP.seek(PxSelect.Pxgrp.TAB.PX_GRPI,8+PxSelect.Pxgrp.TAB.PX_GRPI)
            || _drop_grp:=PX_GRP.ref()
            ?}
         ?}
      || FUN.emsg('Nie znaleziono gałęzi, przenoszenie zostaje przerwane.'@);
         _can_continue:=0
      ?}
   ?}
?};
:: Kontrola czy wybrany zestaw, jesli zestawy dostepne
{? _edit>0 & _autoset=0 & exec('is_px_set','px_param')>0 & PX_VAR.PX_SET=null()
|| FUN.emsg('Aby umieścić coś w kolejce należy pracować w kontekście zestawu planistycznego.'@);
   _can_continue:=0
?};

VAR_DEL.delete('__dropped');

:: Po dodaniu rekordow ustawie sie na rekordzie o takim zrodlowym refie
_viewport:=null();

{? _edit>0
|| KOMM.init(250,,'Dodawanie pozycji do kolejki planu.'@,'')
?};

_ok:=0;

_agr:='N';
{? PX_VAR.AGR<>''
|| _agr:=PX_VAR.AGR
?};
_group:=0;
{? VAR.GRUPA='T'
|| _group:=1
?};
_locked:=null();

{? _px_tag<>null()
|| _drop_grp:=exec('find_match','px_tag',_px_ver,_px_tag)
?};

_dropped.cntx_psh();
{? _dropped.first() & _can_continue>0
||
   {? _drop_grp<>null()
   ||
::    DROP NA ISTNIEJACA GRUPE
      __blokada:=1;
      {? exec('lock','px_grp',_drop_grp)
      || _locked:=_drop_grp;
         _can_continue:=1
      || _can_continue:=0
      ?};
      ~~
   ?};

:: NUCO - zmiana aktualizacja daty rozpoczęcia planowania
   PX_OBJ.cntx_psh();
   {? PX_OBJ.seek(_dropped.REF,)
   || exec('ustal_startd','qtpp',PX_OBJ.ref)
   ?};
   PX_OBJ.cntx_pop()
:: KONIEC ZMIANY

?};
_dropped.cntx_pop();

:: KONTROLA POPRAWNOŚCI
{? _can_continue>0 & _ctrl>0
|| _can_continue:=exec('to_queue_ctrl','px_grp',_dropped
                                                ,_px_ver
                                                ,_drop_grp
                                                ,0
                                                ,_grupa
                                                ,_dialog)
?};


:: EDYCJA
{? _can_continue>0
|| _can_continue:=exec('to_queue_edit','px_grp',_dropped
                                               ,_px_ver
                                               ,_drop_grp
                                               ,0
                                               ,_grupa
                                               ,_edit
                                               ,_px_tag)
?};

_env_grp:=exec('to_group_env','px_grp',_px_ver,_dialog);


{? _grop<>null() & _can_continue>0
||
:: BRAK GRUPOWANIA DLA GRUP OPERACJI
   {? _dropped.first()
   || {!
      |? {? PX_OBJ.seek(_dropped.REF,)
         || _mode:='GROUP_GROPS';
            _ilosc:=_dropped.ILOSC;
            _px_tex:=null();
            _dir:=PX_OBJ.DIR;
            {? PX_VAR.ADD_DIR<>0
            || _dir:=PX_VAR.ADD_DIR;
               ~~
            ?};

            _grops:=null();
            {? var_pres('GROPS',_dropped)>0
            || _grops:=exec('FindAndGet','#table',GROPS,_dropped.GROPS,,,null())
            ?};
            exec('to_group','px_grp',_env_grp,,_mode,_ilosc,_px_tex,_grops,_dir)
         ?};
         _dropped.next()
      !}
   ?}
|? _px_tag<>null() & _can_continue>0
|| _agr:='T';
:: GRUPOWANIE ZA POMOCĄ PX_TAG
   PX_OBJ.cntx_psh();
   PX_TAG.cntx_psh(); PX_TAG.prefix();
   {? PX_TAG.seek(_px_tag)
   || PX_VAR.ADD_TX:=exec('get_default_tex','px_tag',PX_TAG.ref(),1);

      {? PX_VAR.ADD_TX<>null()
      ||
::       Weryfikacja czy przepis ma poprawnie utworzone powiazania
         _can_continue:=exec('conns_ok','px_tex',PX_VAR.ADD_TX);
         {? _can_continue=0
         || _msg:='Dla: %1 domyślny przepis planistyczny posiada nieprawidłowe powiązania między etapami.'@[PX_OBJ.SYMBOL];
            {? _dialog=2
            || KOMM.add(_msg,2,,1)
            |? _dialog=3
            || _komm_args:=exec('add_komm_a','px_komm');
               _komm_args.PX_VER:=_px_ver;
               _komm_args.PX_OBJ:=PX_OBJ.ref();
               _komm_args.TYP:=exec('type_error','px_komm');
               _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args);
               ~~
            ?};
            ~~
         ?}
      || _msg:='Dla grupy obiektów: %1 nie znaleziono przepisu planistycznego.'@[exec('PX_TAG','#to_string')];
         {? _dialog=2
         || KOMM.add(_msg,2,,1)
         |? _dialog=3
         || _komm_args:=exec('add_komm_a','px_komm');
            _komm_args.PX_VER:=_px_ver;
            _komm_args.PX_OBJ:=PX_OBJ.ref();
            _komm_args.TYP:=exec('type_error','px_komm');
            _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
            _komm_args.MESSAGE:=_msg;
            exec('add_komm','px_komm',_komm_args);
            ~~
         ?};
         ~~
      ?};

      {? _can_continue>0
      ||
         PX_OBJ.index('PX_TAG');
         PX_OBJ.prefix(PX_TAG.ref());
         {? PX_OBJ.first()
         || {!
            |?
               _mode:='GROUP_TAG';
               _ilosc:=-1;
               _px_tex:=null();
               _dir:=0;
               {? PX_VAR.ADD_DIR<>0
               || _dir:=PX_VAR.ADD_DIR;
                  ~~
               ?};
               exec('to_group','px_grp',_env_grp,,_mode,_ilosc,_px_tex,,_dir);
               PX_OBJ.next()
            !}
         ?}
      ?}
   ?};
   PX_TAG.cntx_pop();
   PX_OBJ.cntx_pop();
   ~~
||
:: STARE GRUPOWANIE PO TECHNOLOGII
   {? _can_continue>0
   ||
::    ROZPOCZECIE GRUPOWANIA DO TABEL RANKINGOWYCH
      _dropped.first();
      {!
      |? {? PX_OBJ.seek(_dropped.REF,)
         ||
::          Uwaga: tymczasowe zalozenie, ze dla operacji grupowej musza byc technologie jedynie sluszne, nawet jak agregacja
            {? _grupa>0 | _edit=0
            || PX_VAR.ADD_TX:=exec('get_default_tex','px_tex',PX_OBJ.ref(),1)
            ?};
            {? PX_VAR.ADD_TX<>null()
            ||
::             Weryfikacja czy przepis ma poprawnie utworzone powiazania
               _can_continue:=exec('conns_ok','px_tex',PX_VAR.ADD_TX);
               {? _can_continue=0
               || _msg:='Dla: %1 domyślny przepis planistyczny posiada nieprawidłowe powiązania między etapami.'@[PX_OBJ.SYMBOL];
                  {? _dialog=2
                  || KOMM.add(_msg,2,,1)
                  |? _dialog=3
                  || _komm_args:=exec('add_komm_a','px_komm');
                     _komm_args.PX_VER:=_px_ver;
                     _komm_args.PX_OBJ:=PX_OBJ.ref();
                     _komm_args.TYP:=exec('type_error','px_komm');
                     _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
                     _komm_args.MESSAGE:=_msg;
                     exec('add_komm','px_komm',_komm_args);
                     ~~
                  ?};
                  ~~
               ||
                  _mode:='GROUP_NONE';
                  {? _agr='T'
                  || _mode:='GROUP_TEX'
                  ?};
                  _ilosc:=-1;
                  _px_tex:=null();
                  _dir:=0;

                  {? _edit>0 | _group>0
                  || _dir:=PX_VAR.ADD_DIR
                  ?};
                  {? _edit>0 & _group=0
                  || _ilosc:=PX_VAR.ADD_IL
                  ?};
                  {? _group=0
                  || _px_tex:=PX_VAR.ADD_TX
                  ?};
                  exec('to_group','px_grp',_env_grp,,_mode,_ilosc,_px_tex,,_dir)
               ?}
            ||
               _mode:='GROUP_NONE';
               {? _agr='T'
               || _mode:='GROUP_TEX'
               ?};
               _ilosc:=-1;
               _px_tex:=null();
               _dir:=0;

               {? _edit>0 | _group>0
               || _dir:=PX_VAR.ADD_DIR
               ?};
               {? _edit>0 & _group=0
               || _ilosc:=PX_VAR.ADD_IL
               ?};
               {? _group=0
               || _px_tex:=PX_VAR.ADD_TX
               ?};
               exec('to_group','px_grp',_env_grp,,_mode,_ilosc,_px_tex,,_dir)
            ?}
         ?};
         _dropped.next()
      !}
   ?}
?};

{? _can_continue>0
||
   _tab:=_env_grp.TAB;
   exec('to_group_update','px_grp',_env_grp);

:: Informacje diagnostyczne
::   _tab.index(_env_grp.NDX_TREE);
::   exec('select','#table',_tab,1);

:: PRZEKSZTALCENIE TABEL RANKINGOWYCH W PRAWDZIWE REKORDY

:: Zmieniamy kolejnosc w tabeli rankingowej - sa posortowane wg kolejnosci dodawania czyli tak
:: jak byly posortowane rekordy w tabeli _dropped

   _tab.index(_env_grp.NDX_ADD);
   _tab.prefix('G');
   {? _tab.first()
   || {!
      |?
         _reft:=null();
         {? _tab.PX_TEX<>'' & PX_TEX.seek(_tab.PX_TEX)
         || _reft:=PX_TEX.ref()
         ?};
         {? _drop_grp=null() & PX_VAR.AGR_UID<>'' & _px_tag=null()
         ||
::          Jeżeli włączone agregowanie to szukam grupy wśród utworzonych w tej akcji
::          grupowej do której mogę dokleić ten obiekt
            PX_GRP.cntx_psh();
            PX_GRP.index('AGR_UID');
            PX_GRP.prefix(_px_ver,_tab.GRP_STR,PX_VAR.AGR_UID,);
            {? PX_GRP.first()
            || _drop_grp:=PX_GRP.ref()
            ?};
            PX_GRP.cntx_pop()
         ?};

         {? _drop_grp=null()
         ||
::          Tworzenie PX_GRP
            PX_GRP.clear();
            PX_GRP.blank();
            PX_GRP.PX_VER:=_px_ver;
            PX_TEX.cntx_psh();
            PX_TEX.clear();

            _symbol:='<BRAK - technologii>'@;
            _nazwa:='<BRAK - technologii>'@;
            {? _px_tag<>null()
            || PX_TAG.cntx_psh(); PX_TAG.prefix();
               {? PX_TAG.seek(_px_tag)
               || _symbol:=PX_TAG.ID;
                  _nazwa:=PX_TAG.ID
               ?};
               PX_TAG.cntx_pop()
            |? PX_TEX.seek(_reft)
            || _symbol:=exec('get_symbol','px_grp',PX_TEX.ref());
               _nazwa:=exec('get_nazwa','px_grp',PX_TEX.ref())
            ?};
            PX_TEX.cntx_pop();
            PX_GRP.PX_TEX:=_reft;
            PX_GRP.SYMBOL:=_symbol;
            PX_GRP.NAZWA:=_nazwa;
            PX_GRP.DIR:=_tab.DIR;
            {? PX_GRP.DIR>0
            || PX_GRP.PL_FORCE:=PX_VAR.PL_FORCE
            || PX_GRP.PL_FORCE:='N'
            ?};
            PX_GRP.AGR_UID:=PX_VAR.AGR_UID;
            PX_GRP.AGR_SRC:=_tab.GRP_STR;
            {? _tab.GROPS<>''
            || PX_VAR.GROPS:=exec('FindAndGet','#table',GROPS,_tab.GROPS,,,null())
            ?};

            {? PX_VAR.GROPS<>null()
            || PX_VAR.GROP:=PX_VAR.GROPS().GROP;
               PX_GRP.KIND:='G';
               PX_GRP.SYMBOL:=PX_VAR.GROPS().GROP().KOD+' ('+PX_VAR.GROPS().PL_RES().SYM+')';
               PX_GRP.NAZWA:=PX_VAR.GROPS().GROP().OPIS;
               PX_GRP.GROPS:=PX_VAR.GROPS
            || PX_GRP.KIND:='Z'
            ?};
            PX_GRP.ILOSC:=_tab.IL;
            PX_GRP.cntx_psh();
            PX_GRP.index('LP');
            PX_GRP.prefix(_px_ver,PX_GRP.KIND,);
            _nr:={? PX_GRP.last()
                 || PX_GRP.LP_Q+1
                 || 1
                 ?};
            PX_GRP.cntx_pop();
            PX_GRP.LP_Q:=_nr;

            JM.cntx_psh();
            JM.index('KOD');
            JM.prefix(_tab.JM,_tab.JM);
            {? JM.first()
            || PX_GRP.JM:=JM.ref()
            ?};
            JM.cntx_pop();

            {? exec('is_whatif','px_ver',_px_ver)>0
            || PX_GRP.SIM_MOD:='T'
            ?};
            PX_GRP.PX_TAG:=_px_tag;
            _can_continue:=PX_GRP.add();

            {? _can_continue>0
            ||
::             Ustalanie granic czasowych dla grupy
               {? exec('is_px_set','px_param')>0
               ||
::                Praca na zestawie
                  {? _autoset>0
                  || PX_GRP.SET_SRC:=exec('FindAndGet','#table',PX_SET,_tab.PX_SET,,,null())
                  || PX_GRP.SET_SRC:=PX_VAR.PX_SET
                  ?};
::                Granicą od jest aktualny czas zaokraglony do pojemnikow na pierwszym zasobie
                  {? var_pres('_pxpack')>100
                  || obj_del(_pxpack)
                  ?};
                  _pxpack:=exec('trzepaczka','px_tex',PX_GRP.PX_TEX,PX_GRP.ILOSC,PX_GRP.ref());
::                Wyznaczam czas startowy jaki powinien byc na PX_GRP
                  _tm_start:=exec('round_start_pck','px_tex',_pxpack.Paczka);
                  PX_GRP.STARTD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',_tm_start));
                  PX_GRP.STARTT:=exec('tm_stamp2time','#tm_stamp',_tm_start);
::                Granicą do jest zawsze najmniejszy termin realizacji skladowych grupy
                  {? _tab.TM_REA>0
                  || PX_GRP.ENDD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',_tab.TM_REA));
                     PX_GRP.ENDT:=exec('tm_stamp2time','#tm_stamp',_tab.TM_REA)
                  ?}
               ||
::                Praca bez zestawów

                  {? PX_GRP.DIR>0
                  ||
::                   Planowanie w przod
                     _startd:=PX_VAR.GRN_DATA;
                     _startt:=PX_VAR.GRN_TIME;
                     {? _startd>date(0,0,0)
                     ||
                        PX_GRP.STARTD:=exec('get','daty',PX_VAR.GRN_DATA);
                        PX_GRP.STARTT:=PX_VAR.GRN_TIME
                     ||
                        PX_GRP.STARTD:=exec('get','daty',date());
                        PX_GRP.STARTT:=time()
                     ?};
                     {? _tab.TM_REA>0
                     || PX_GRP.ENDD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',_tab.TM_REA));
                        PX_GRP.ENDT:=exec('tm_stamp2time','#tm_stamp',_tab.TM_REA)
                     ?}
                  ||
::                   Planowanie w tyl
                     PX_GRP.STARTD:=exec('get','daty',date());
                     PX_GRP.STARTT:=time();

                     _endd:=PX_VAR.GRN_DATA;
                     _endt:=PX_VAR.GRN_TIME;
                     {? _endd>date(0,0,0)
                     ||
::                      Jesli w oknie data wypelniona to ja przypisuje do grupy
                        PX_GRP.ENDD:=exec('get','daty',PX_VAR.GRN_DATA);
                        PX_GRP.ENDT:=PX_VAR.GRN_TIME
                     ||
::                      Jesli w oknie data niewypelniona, to moze w polu _tab.TM_REA znajduje sie minimalny termin
::                      ze wszystkich skladowych grupy
                        {? _tab.TM_REA>0
                        || PX_GRP.ENDD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',_tab.TM_REA));
                           PX_GRP.ENDT:=exec('tm_stamp2time','#tm_stamp',_tab.TM_REA)
                        ?}
                     ?}
                  ?}
               ?};
               _can_continue:=PX_GRP.put()
            ?};

            {? _can_continue>0 & PX_GRP.GROPS<>null()
            || exec('sequence4pxgrp','px_grop');
               exec('grop_plan_px_set','px_grop',PX_GRP.GROPS().GROP,'Q');
::             "Naprawa" GROPS - nie zawsze udana, bo ilość niekoniecznie jest już dobra
               exec('plan_restore_grop','zl_grop',PX_GRP.GROPS().GROP)
            ?};

            {? _can_continue>0
            ||
               {? exec('is_px_set','px_param')>0 & PX_GRP.SET_SRC<>null()
               ||
::                Nanosze na PX_GRPS'a info o zwrocie i granicy czasowej jaka ustalilem
::                podczas wrzucania do swojej kolejki
                  {? var_pres('_args_grps')>100
                  || obj_del(_args_grps)
                  ?};
                  _args_grps:=exec('add_a','px_grps');
                  _args_grps.PX_GRP:=PX_GRP.ref();
                  _args_grps.PX_SET:=PX_GRP.SET_SRC;
                  _args_grps.GRN_DATA:=PX_VAR.GRN_DATA;
                  _args_grps.GRN_TIME:=PX_VAR.GRN_TIME;
                  _args_grps.DIR:=PX_GRP.DIR;
                  exec('update','px_grps',_args_grps.PX_GRP,_args_grps.PX_SET,_args_grps);

::                Tworze automatyczne punkty czasowe dla pracy na zestawie
                  {? PX_VAR.GRN_DATA<>date(0,0,0)
                  ||
                     {? var_pres('_args_poi')>100
                     || obj_del(_args_poi)
                     ?};
                     _tm_grn:=exec('create','#tm_stamp',PX_VAR.GRN_DATA,PX_VAR.GRN_TIME);
                     _args_poi:=exec('auto_args_grp','px_point',,_tm_grn);
                     exec('auto_point','px_point',_args_poi)
                  ?}
               ?};
::             Stempluje modyfikacje kolejki w wersji
               exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER)
            ?};
            _ref:=PX_GRP.ref()
         || _ref:=_drop_grp;
            {? _px_tag<>null()
            ||
::             Jeżeli dogrupowałem do już istniejącego PX_GRP to przepisuję na tego PX_GRP
::             termin realizacji z PX_TAGA bo mógł się zmienić w międzyczasie
               PX_GRP.ENDD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',PX_TAG.TM_REA));
               PX_GRP.ENDT:=exec('tm_stamp2time','#tm_stamp',PX_TAG.TM_REA);
               PX_GRP.put()
            ?}
         ?};
         _tab.cntx_psh();
         _tab.index(_env_grp.NDX_TREE);
         _tab.prefix(#_tab.ref());
         {? _tab.first() & _can_continue>0
         ||
            {!
            |? {? _tab.Z='T'
               ||
::                Tworzenie PX_CONN
                  PX_CONN.blank();
                  PX_CONN.PX_VER:=_px_ver;
                  PX_CONN.ILOSC:=_tab.IL;
                  PX_CONN.PX_GRP:=_ref;
                  PX_CONN.cntx_psh();
                  PX_CONN.index('PX_GRP');
                  PX_CONN.prefix(_ref);
                  _il:={? PX_CONN.first()
                       || PX_CONN.size()+1
                       || 1
                       ?};
                  PX_CONN.cntx_pop();
                  PX_CONN.LP_GRP:=_il;
                  PX_OBJ.cntx_psh();
                  PX_OBJ.clear();
                  _obj:={? PX_OBJ.seek(_tab.PX_OBJ,8+_tab.PX_OBJ)
                        || PX_OBJ.ref()
                        || null()
                        ?};
                  {? PX_CONN.ILOSC<=PX_OBJ.IL - exec('get_ilosc_que','px_obj',_px_ver,PX_OBJ.ref)
                  || _ok:=1
                  || {? _grupa=0
                     || PX_CONN.cntx_psh();
                        PX_CONN.index('PX_GRP');
                        PX_CONN.prefix(_ref);
                        {? ~PX_CONN.first()
                        || exec('delete','px_grp',_ref)
                        ?};
                        PX_CONN.cntx_pop()
                     ?};
                     _can_continue:=0
                  ?};
                  PX_OBJ.cntx_pop();
                  {? _can_continue>0
                  || {? _obj<>null()
                     || PX_CONN.PX_OBJ:=_obj;
                        PX_CONN.M:=exec('FindAndGet','#table',PX_OBJ,_obj,,"PX_OBJ.M",null);
                        {? PX_CONN.add()
                        ||
::                         aktualizuje pole materiału
                           exec('update_m','px_grp',PX_CONN.PX_GRP);

::                         Stempluje modyfikacje kolejki w wersji
                           exec('mod_stamp_queue','px_ver',PX_CONN.PX_VER);

::                         Ustawiam rekord na ktorym ustawie sie po zregenerowaniu widoku - pierwszy dodany PX_CONN
                           {? _viewport=null()
                           || _viewport:=PX_CONN.ref()
                           ?};

::                         Dla pozostalych technologii danego obiektu wylaczamy Z=N
                           {? _grupa>1
                           || KOMM.add('Dodanie pozycji: %1 do kolejki'@[PX_CONN.PX_OBJ().SYMBOL],13)
                           ?};
                           {? _agr='N'
                           || PX_GRP.NAZWA:=PX_CONN.PX_OBJ().SYMBOL;
                              PX_GRP.put()
                           ?};
::                           {? PX_CONN.PX_GRP().GROPS<>null()
::                           || exec('ran_off_grops','px_grp',_tab.PX_OBJ,$PX_GRP.GROPS)
::                           || exec('ran_off','px_grp',_tab.PX_OBJ,{? _agr='T'
::                                                                   || __ran_conn.PX_TEX
::                                                                   || PX_CONN.PX_OBJ().SYMBOL
::                                                                   ?})
::                           ?};
                           ~~
                        ?}
                     ?}
                  || PX_CONN.PX_OBJ:=_obj;
                     KOMM.add('Dla: %1 próba dodania ilości większej niż w obiekcie.'@[PX_CONN.PX_OBJ().SYMBOL],14);
                     {? _agr='N'
                     || {? PX_GRP.seek(#_ref,8+$_ref)
                        || PX_CONN.cntx_psh();
                           PX_CONN.index('PX_GRP');
                           PX_CONN.prefix(PX_GRP.ref());
                           {? ~PX_CONN.first()
                           || exec('delete','px_grp',PX_GRP.ref())
                           ?};
                           PX_CONN.cntx_pop()
                        ?}
                     ?}
                  ?}
               ?};
               _tab.next()
            !}
         ?};
         _tab.cntx_pop();
         _tab.next()
      !}
   ||
::    W tabelach rankingowych pusto wiec nie wykonuje dalej niepotrzebnych krokow
      _can_continue:=0
   ?};
:: Uzupelnia powiazania miedzy grupami obiektow
::   exec('UpdatePX_VER','px_con_g',PX_VAR.VER_QUE)
   ~~
?};

{? _grupa=0 & _can_continue>0
||
:: Odtwarzanie kolejności w kolejce
   exec('prenumber','px_grp',_px_ver)
?};

:: Ponowne załadowanie widoku kolejki
{? _grupa=0 & var_pres('PxSelect')>100
|| {? ~_one_ver || exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp) ?}
?};

:: Aktualizuje przyciski dot przeliczania jednej wersji planu
{? _grupa=0 & _one_ver>0 & var_pres('PxSelect')>100
|| exec('przelicz_btn','px_plan')
?};

:: Odblokowuje zablokowana wczesniej grupe
{? _locked<>null()
|| exec('unlock','px_grp',_locked)
?};

:: Ustawienie sie na pierwszym dodanym węźle w kolejce (PX_CONN)
{? _grupa=0 & var_pres('PxSelect')>100
|| {? ~_one_ver || exec('viewport_set','px_grp',PxSelect.Pxgrp,_viewport) ?}
?};

{? _win_disp
|| win_disp()
?};

{? _drop_dest<>null() & var_pres('PxSelect')>100
||
   {? ref_tab(_drop_dest)=PX_GRP
   || ~~
   || PxSelect.Pxgrp.TAB.cntx_pop();
      PxSelect.Pxgrp.TAB.seek(_drop_dest)
   ?}
?};

&__blokada;
VAR_DEL.delete('__dropped');
{? _edit>0
|| KOMM.select()
?};
PX_VAR.ADD_SYM:=''; PX_VAR.ADD_OPIS:='';

::zdejmuje filtr z tabeli PX_TEX
exec('tex_f_clear','px_tex');

GROPS.cntx_pop();
PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
PX_CONN.cntx_pop();
PX_TEX.cntx_pop();
PX_SET.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result
