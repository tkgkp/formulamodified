:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: zl_wyk.fml
:: Utworzony: 12.01.2016
:: Autor: WH
::======================================================================================================================
:: Zawartość: Formuły do obsługi rejestracji wykonań do zleceń:
::            obsługa PROD_REJ, ZLGD, ZLGB
::======================================================================================================================


\update_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Aktualizacja tabel PROD_REJ i PROD_NXT
::       na podstawie zmian w tabelach ZGP, NASZGP, ZGH, ZL, KAP, ZLGD, GROP (obsługa triggerów)
::   WE: _a - rodzaj triggera: 'add', 'put', 'del'
::       _b - tabela: ZGP, NASZGP, ZGH, ZL, KAP, ZLGD, GROP
::   WY: wynik sterujacy dla triggera, czyli ~~ albo 0/1
::  OLD: \update_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? _b=ZGP
||
   {? _a='add'
   ||
      Cntx.psh(PROD_REJ,PROD_NXT,ZGH,ZL);

::    UWAGA: Podczytanie ZGH zlecenia podrzędnego oraz zlecenia podrzędnego
      ZGP.NRZLP().ZLEC();

::    Pominięcie przewodników technicznych
      {? ZGH.KIND='T' || Cntx.pop(PROD_REJ,PROD_NXT,ZGH,ZL); return() ?};

      PROD_REJ.clear();
      PROD_REJ.blank(1);
      {? ZGP.WEW='T'
      || PROD_REJ.STARTD:={? ZGP.STARTD=date(0,0,0) || ZL.OD || ZGP.STARTD ?};
         PROD_REJ.STARTT:=ZGP.STARTT;
         PROD_REJ.ENDD:={? ZGP.ENDD=date(0,0,0) || ZL.DTR || ZGP.ENDD ?};
         PROD_REJ.ENDT:=ZGP.ENDT
      || PROD_REJ.STARTD:={? ZGP.STARTDK=date(0,0,0) || ZL.OD || ZGP.STARTDK ?};
         PROD_REJ.STARTT:=ZGP.STARTTK;
         PROD_REJ.ENDD:={? ZGP.ENDDK=date(0,0,0) || ZL.DTR || ZGP.ENDDK ?};
         PROD_REJ.ENDT:=ZGP.ENDTK
      ?};
:: [areKc] - Ustalenie zmiany wykonującej pozycję z przewodnika.
      PROD_REJ.QZMIANA:=exec('zmiana','zl_common',PROD_REJ.STARTT);
      exec('fields_4rej','zl_wyk');
      PROD_REJ.WYD:=exec('wyd','zl_guide');
      PROD_REJ.PRIORITY:='N';
      PROD_REJ.SRODZ:='ZL';
      PROD_REJ.SOURCE:=$ZGP.ref();
      PROD_REJ.ZL:=ZL.ref();
      PROD_REJ.ZGH:=ZGH.ref();
      PROD_REJ.ZGP:=ZGP.ref();
      PROD_REJ.M:=ZL.KTM;
      PROD_REJ.JM:=ZL.KTM().J;
      {? ZGP.WEW='T'
      || PROD_REJ.RES_SYM:=ZGP.PLACE().KOD;
         PROD_REJ.RES_NAZ:=TWRKPLC.NA
      || PROD_REJ.RES_SYM:='{KOOPERACJA}';
         PROD_REJ.RES_NAZ:='Kooperacja'
      ?};
      PROD_REJ.KH:=ZGP.KONTRAH;
      PROD_REJ.GKTL:=ZGP.NRPRZ().GKTL;
      PROD_REJ.IL:=ZGP.ILOSC;
      PROD_REJ.ILC:=ZGP.ILOSC;
      PROD_REJ.START:='N';
      PROD_REJ.OK:='N';
      PROD_REJ.POTW:='N';
      PROD_REJ.PROBLEM:='N';
      PROD_REJ.PROBKLAS:='';
      PROD_REJ.PRAC:='N';
      PROD_REJ.BRYG:='N';
      PROD_REJ.KOOP:={? ZGP.WEW='T' || 'N' || 'T' ?};
      PROD_REJ.RP:='N';
      PROD_REJ.IL_KAP:=exec('prod_rej_il_kap','prod_rej');
      {? ZGP.DOK<>null()
      || PROD_REJ.RP:='T'
      ?};
      PROD_REJ.A:={? ZL.STAN='O' & ZGH.STAN='N' || 'T' || 'N' ?};
      PROD_REJ.DOREJ:={? ZGP.STATUS=exec('status_pending','zl_guide') || 'T' || 'N' ?};
      PROD_REJ.KONTROLA:={? ZGP.KONTROLA='T' || 'T' || 'N'?};
      PROD_REJ.KJ_BAD:=ZGP.KJ_BAD;
      {? PROD_REJ.add(1)
      ||
         _prod_rej:=PROD_REJ.ref();
         PROD_NXT.clear();

::       Dodanie następnika, jeżeli operacja Tpz
         {? ZGP.TPZ='T'
         || ZGP.cntx_psh();
            ZGP.index('UID');
            ZGP.prefix(ZGP.UID_TPZ);
            {? ZGP.first()
            ||
               PROD_NXT.blank(1);
               PROD_NXT.PROD_REJ:=PROD_REJ.ref();
               PROD_REJ.index('ZGP');
               PROD_REJ.prefix('ZL',ZGP.ref());
               {? PROD_REJ.first()
               ||
                  PROD_NXT.NEXT:=PROD_REJ.ref();
                  PROD_NXT.add(1)
               ?}
            ?};
            ZGP.cntx_pop()
         ?}
      ?};

      Cntx.pop(PROD_REJ,PROD_NXT,ZGH,ZL);
::    Aktualizacja pól ZGH.W_FIRST i ZGH.W_LAST
      {? ZGP.WHERE<>'W'
      || ZGH.cntx_psh();
         ZGP.NRPRZ();
         {? ZGP.WHERE='P' & ZGH.W_FIRST='N'
         || ZGH.W_FIRST:='T';
            ZGH.put()
         |? ZGP.WHERE='O' & ZGH.W_LAST='N'
         || ZGH.W_LAST:='T';
            ZGH.put()
         ?};
         ZGH.cntx_pop()
      ?};
      ~~
   |? _a='put'
   ||
      Cntx.psh(PROD_REJ,ZGH,ZL);

::    UWAGA: Podczytanie ZGH zlecenia podrzędnego oraz zlecenia podrzędnego
      ZGP.NRZLP().ZLEC();

::    Pominięcie przewodników technicznych
      {? ZGH.KIND='T' || Cntx.pop(PROD_REJ,ZGH,ZL); return() ?};

      PROD_REJ.index('ZGP');
      PROD_REJ.prefix('ZL',ZGP.ref());
      {? PROD_REJ.first()
      ||
         {? ZGP.WEW='T'
         || PROD_REJ.STARTD:={? ZGP.STARTD=date(0,0,0) || ZL.OD || ZGP.STARTD ?};
            PROD_REJ.STARTT:=ZGP.STARTT;
            PROD_REJ.ENDD:={? ZGP.ENDD=date(0,0,0) || ZL.DTR || ZGP.ENDD ?};
            PROD_REJ.ENDT:=ZGP.ENDT
         || PROD_REJ.STARTD:={? ZGP.STARTDK=date(0,0,0) || ZL.OD || ZGP.STARTDK ?};
            PROD_REJ.STARTT:=ZGP.STARTTK;
            PROD_REJ.ENDD:={? ZGP.ENDDK=date(0,0,0) || ZL.DTR || ZGP.ENDDK ?};
            PROD_REJ.ENDT:=ZGP.ENDTK
         ?};
:: [areKc] - Ustalenie zmiany wykonującej pozycję z przewodnika.
         PROD_REJ.QZMIANA:=exec('zmiana','zl_common',PROD_REJ.STARTT);
         PROD_REJ.WYD:=exec('wyd','zl_guide');
         exec('fields_4rej','zl_wyk');
::         PROD_REJ.PRIORITY:='N';
         {? ZGP.WEW='T'
         ||
            PROD_REJ.RES_SYM:=ZGP.PLACE().KOD;
            PROD_REJ.RES_NAZ:=TWRKPLC.NA
         ||
            PROD_REJ.RES_SYM:='{KOOPERACJA}';
            PROD_REJ.RES_NAZ:='Kooperacja'
         ?};
         PROD_REJ.KH:=ZGP.KONTRAH;
         PROD_REJ.GKTL:=ZGP.NRPRZ().GKTL;
         _change:=ZGP.ILOSC-PROD_REJ.ILC;
         PROD_REJ.IL+=_change;
         PROD_REJ.ILC:=ZGP.ILOSC;
         PROD_REJ.A:={? ZL.STAN='O' & ZGH.STAN='N' || 'T' || 'N' ?};
         PROD_REJ.DOREJ:={? ZGP.STATUS=exec('status_pending','zl_guide') || 'T' || 'N' ?};
         PROD_REJ.OK:={? ZGP.STATUS=exec('status_end','zl_guide') || 'T' || 'N' ?};
::       Sprawdzenie wykorzystania w grupach operacji
         {? ZGP.PL_GRP='T'
         || {? exec('FindInSet','#table','GROPP','ZGP',ZGP.ref(),,"1",,,0)
            || PROD_REJ.DOREJ:='N';
               PROD_REJ.A:='N'
            ?}
         ?};
         PROD_REJ.PROBLEM:={? ZGH.PROBLEM='T' || 'T' || ZGP.PROBLEM ?};
         PROD_REJ.PROBKLAS:={? ZGH.PROBLEM='T' || exec('prob_class_blocking','zl_wkj') || ZGP.PROBKLAS ?};
         PROD_REJ.KONTROLA:={? ZGP.KONTROLA='T' || 'T' || 'N' ?};
         PROD_REJ.KJ_BAD:=ZGP.KJ_BAD;
         PROD_REJ.IL_KAP:=exec('prod_rej_il_kap','prod_rej');
         PROD_REJ.put()
      ?};

      Cntx.pop(PROD_REJ,ZGH,ZL);
      ~~
   |? _a='del'
   ||
::    Przed usunięciem pozycji przewodnika usuwany jest zapis PROD_REJ i ewentualnie PROD_NXT do niego
      Cntx.psh(PROD_REJ);

      PROD_REJ.index('ZGP');
      PROD_REJ.prefix('ZL',ZGP.ref());
      {? PROD_REJ.first()
      ||
         PROD_NXT.index('PROD_REJ');
         PROD_NXT.prefix(PROD_REJ.ref());
         {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};
         PROD_NXT.index('NEXT');
         PROD_NXT.prefix(PROD_REJ.ref());
         {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};
         PROD_REJ.del()
      ?};
      _res:=~PROD_REJ.first();

      Cntx.pop(PROD_REJ);
      _res
   ?}

|? _b=NASZGP
||
   {? _a='add'
   ||
::    Po dodaniu następnika dołączane są zapisy PROD_NXT
      Cntx.psh(PROD_REJ,PROD_NXT,ZGP,GROPP);
      Cntx.clr(PROD_NXT);

::    1) Połączenie wg NASZGP między ZGP a ZGP - uwzględnia Tpz
      PROD_REJ.index('ZGP');
      PROD_REJ.prefix('ZL',NASZGP.OPER);
      {? PROD_REJ.first()
      ||
         _prod_rej:=PROD_REJ.ref();

         PROD_NXT.blank(1);
         PROD_NXT.PROD_REJ:=PROD_REJ.ref();
         PROD_REJ.prefix('ZL',NASZGP.NRNAST);
         {? PROD_REJ.first()
         ||
::          Jeżeli następnik ma Tpz, to biorę go w zamian tego następnika
            _prod_rej:=PROD_REJ.ref();
            ZGP.index('TPZ');
            ZGP.prefix('T',NASZGP.NRNAST().UID);
            {? ZGP.first()
            || PROD_REJ.index('ZGP');
               PROD_REJ.prefix('ZL',ZGP.ref());
               {? PROD_REJ.first()
               || _prod_rej:=PROD_REJ.ref()
               ?}
            ?};
            PROD_NXT.NEXT:=_prod_rej;
            PROD_NXT.add(1)
         ?}
      ?};

::    2) Połączenie wg NASZGP między GROPP dla danego ZGP (poprzednika) a ZGP (następnika)
      PROD_REJ.index('GROP');
      GROPP.index('ZGP');
      GROPP.prefix(NASZGP.OPER);
      {? GROPP.first()
      || {!
         |? PROD_REJ.prefix('ZL',GROPP.GROP);
            {? PROD_REJ.first()
            || PROD_NXT.blank(1);
               PROD_NXT.PROD_REJ:=PROD_REJ.ref();
               PROD_REJ.index('ZGP');
               PROD_REJ.prefix('ZL',NASZGP.NRNAST);
               {? PROD_REJ.first()
               || PROD_NXT.NEXT:=PROD_REJ.ref();
                  PROD_NXT.add(1)
               ?}
            ?};
            GROPP.next()
         !}
      ?};

::    3) Połączenie wg NASZGP między ZGP (poprzednika) a GROPP dla danego ZGP (następnika)
      PROD_REJ.index('ZGP');
      PROD_REJ.prefix('ZL',NASZGP.OPER);
      {? PROD_REJ.first()
      || _prod_rej:=PROD_REJ.ref();
         GROPP.index('ZGP');
         GROPP.prefix(NASZGP.NRNAST);
         {? GROPP.first()
         || {!
            |? PROD_REJ.index('GROP');
               PROD_REJ.prefix('ZL',GROPP.GROP);
               {? PROD_REJ.first()
               || PROD_NXT.PROD_REJ:=_prod_rej;
                  PROD_NXT.NEXT:=PROD_REJ.ref();
                  PROD_NXT.add(1)
               ?};
               GROPP.next()
            !}
         ?}
      ?};

      Cntx.pop(PROD_REJ,PROD_NXT,ZGP,GROPP);
      ~~
   |? _a='put'
   ||
      ~~
   |? _a='del'
   ||
::    Przed usunięciem następnika usuwane są zapisy PROD_NXT
      Cntx.psh(PROD_REJ,PROD_NXT,GROPP);

      _result:=0;

      PROD_REJ.index('ZGP');

      _to:=null();
      PROD_REJ.prefix('ZL',NASZGP.NRNAST);
      {? PROD_REJ.first()
      || _to:=PROD_REJ.ref()
      ?};

      _from:=null();
      PROD_REJ.prefix('ZL',NASZGP.OPER);
      {? PROD_REJ.first()
      || _from:=PROD_REJ.ref()
      ?};

      PROD_NXT.index('PROD_REJ');

::    1) Połączenie wg NASZGP między ZGP a ZGP - uwzględnia Tpz
      PROD_NXT.prefix(_from,_to);
      {? PROD_NXT.first() || PROD_NXT.del() ?};
      _result:=(PROD_NXT.size()=0);

::    2) Połączenie wg NASZGP między GROPP dla danego ZGP (poprzednika) a ZGP (następnika)
      GROPP.index('ZGP');
      GROPP.prefix(NASZGP.OPER);
      {? GROPP.first()
      || {!
         |? PROD_REJ.index('GROP');
            PROD_REJ.prefix('ZL',GROPP.GROP);
            {? PROD_REJ.first()
            || PROD_NXT.prefix(PROD_REJ.ref(),_to);
               {? PROD_NXT.first() || PROD_NXT.del() ?};
               _result:=(PROD_NXT.size()=0)*_result
            ?};
            GROPP.next()
         !}
      ?};

::    3) Połączenie wg NASZGP między ZGP (poprzednika) a GROPP dla danego ZGP (następnika)
      GROPP.index('ZGP');
      GROPP.prefix(NASZGP.NRNAST);
      {? GROPP.first()
      || {!
         |? PROD_REJ.index('GROP');
            PROD_REJ.prefix('ZL',GROPP.GROP);
            {? PROD_REJ.first()
            || PROD_NXT.prefix(_from,PROD_REJ.ref());
               {? PROD_NXT.first() || PROD_NXT.del() ?};
               _result:=(PROD_NXT.size()=0)*_result
            ?};
            GROPP.next()
         !}
      ?};

      Cntx.pop(PROD_REJ,PROD_NXT,GROPP);
      _result
   ?}

|? _b=ZGH
||
:: Po poprawieniu nagłówka przewodnika aktualizacja ilości w PROD_REJ
:: Dla 'add' i 'del' nic nie robimy, bo nie ma ZGP a tym bardziej PROD_REJ
   {? _a='put'
   ||
      Cntx.psh(PROD_REJ,ZL,ZGP);

      PROD_REJ.index('ZGH');
      PROD_REJ.prefix('ZL',ZGH.ref());
      {? PROD_REJ.first()
      || {!
         |? {? PROD_REJ.ZGP<>null()
            || _change:=PROD_REJ.ZGP().ILOSC-PROD_REJ.ILC
            || _change:=ZGH.ILNPRZ-PROD_REJ.ILC
            ?};
::          nie zmieniane: PROD_REJ.ILW
            PROD_REJ.IL+=_change;
            {? PROD_REJ.ZGP<>null()
            || PROD_REJ.ILC:=PROD_REJ.ZGP().ILOSC
            || PROD_REJ.ILC:=ZGH.ILNPRZ
            ?};
            PROD_REJ.A:={? ZGH.ZLEC().STAN='O' & ZGH.STAN='N' || 'T' || 'N' ?};
            PROD_REJ.IL_KAP:=exec('prod_rej_il_kap','prod_rej');
            PROD_REJ.PROBLEM:={? ZGH.PROBLEM='T' || 'T' || ZGP.PROBLEM ?};
            PROD_REJ.PROBKLAS:={? ZGH.PROBLEM='T' || exec('prob_class_blocking','zl_wkj') || ZGP.PROBKLAS ?};
            PROD_REJ.put();
            PROD_REJ.next()
         !}
      ?};

      Cntx.pop(PROD_REJ,ZL,ZGP);
      ~~
   |? _a='del'
   ||
::    Przed usunięciem przewodnika usuwane są wszystkie z nim skojarzone zapisy PROD_REJ (o ile pozostały)
      Cntx.psh(PROD_REJ,PROD_NXT);

      PROD_REJ.index('ZGH');
      PROD_REJ.prefix('ZL',ZGH.ref());
      {? PROD_REJ.first()
      || {!
         |? PROD_NXT.index('PROD_REJ');
            PROD_NXT.prefix(PROD_REJ.ref());
            {? PROD_NXT.first()
            || {! |? PROD_NXT.del() !}
            ?};
            PROD_NXT.index('NEXT');
            PROD_NXT.prefix(PROD_REJ.ref());
            {? PROD_NXT.first()
            || {! |? PROD_NXT.del() !}
            ?};
            PROD_REJ.del()
         !}
      ?};
      _res:=~PROD_REJ.first();

      Cntx.pop(PROD_REJ,PROD_NXT);
      _res
   ?}

|? _b=ZL
||
:: Po zamknięciu zlecenia nadrzędnego - usuwanie PROD_REJ, przy otwarciu awaryjnym - odtworzenie.
:: Po poprawieniu zlecenia aktualizacja dat i stanu aktywnosci PROD_REJ
:: Dla 'add' i 'del' nic nie robimy, bo nie ma ZGP a tym bardziej PROD_REJ
   {? _a='put'
   ||
      Cntx.psh(PROD_REJ,ZGH,ZGP);

      {? ZL.STAN='Z'
      || {? bfld('STAN')<>'Z' || exec('del_4rej','zl_wyk',ZL.ref()) ?}
      |? bfld('STAN')='Z'
      || exec('load_one4rej','zl_wyk',ZL.ref())
      || PROD_REJ.index('ZL');
         PROD_REJ.prefix('ZL',ZL.ref());
         {? PROD_REJ.first()
         || {!
            |?
               {? PROD_REJ.ZGP().STARTD=date(0,0,0) || PROD_REJ.STARTD:=ZL.OD ?};
               {? PROD_REJ.ZGP().ENDD=date(0,0,0) || PROD_REJ.ENDD:=ZL.DTR ?};
               PROD_REJ.A:={? ZL.STAN='O' & PROD_REJ.ZGH().STAN='N' || 'T' || 'N' ?};
::             Sprawdzenie wykorzystania w grupach operacji
               {? ZGP.PL_GRP='T'
               || {? exec('FindInSet','#table','GROPP','ZGP',ZGP.ref(),,"1",,,0)
                  || PROD_REJ.DOREJ:='N';
                     PROD_REJ.A:='N'
                  ?}
               ?};
               PROD_REJ.put();
               PROD_REJ.next()
            !}
         ?}
      ?};

      Cntx.pop(PROD_REJ,ZGH,ZGP);
      ~~
   ?}

|? _b=ZLGD
||
:: Na podstawie rejestracji robocizny:
   {? _a='add' || _zgp:=ZLGD.ZGP; _grops:=ZLGD.GROPS;
                  _before:=0; _after:=ZLGD.IL; _bbefore:=0; _bafter:=ZLGD.IL_BRAK;
                  _potw:=ZLGD.POTW; _ok:=ZLGD.OK
   |? _a='put' || _zgp:=ZLGD.ZGP; _grops:=ZLGD.GROPS;
                  _before:=bfld('IL'); _after:=ZLGD.IL; _bbefore:=bfld('IL_BRAK'); _bafter:=ZLGD.IL_BRAK;
                  _potw:=ZLGD.POTW; _ok:=ZLGD.OK
   |? _a='del' || _zgp:=bfld('ZGP'); _grops:=bfld('GROPS');
                  _before:=bfld('IL'); _after:=0; _bbefore:=bfld('IL_BRAK'); _bafter:=0;
                  _potw:='N'; _ok:='N'
               || return()
   ?};

   Cntx.psh(PROD_REJ,ZGP,GROP);

:: - Aktualizacja ilosci - PROD_REJ.IL (ilość do wykonania), PROD_REJ.ILW (ilość wykonana), PROD_REJ.ILWB (ilość braków)
   {? _grops<>null()
   || PROD_REJ.index('GROPS');
      PROD_REJ.prefix('ZL',_grops);
      {? PROD_REJ.first()
      || PROD_REJ.ILW+=_after-_before;
         PROD_REJ.ILWB+=_bafter-_bbefore;
         PROD_REJ.IL-=_after-_before;
         PROD_REJ.OK:='N';
         {? _ok='T' || PROD_REJ.OK:='T' ?};
         {? PROD_REJ.IL<=0 || PROD_REJ.OK:='T' ?};
         PROD_REJ.POTW:=_potw;
         PROD_REJ.put()
      ?}
   || PROD_REJ.index('ZGP');
      PROD_REJ.prefix('ZL',_zgp);
      {? PROD_REJ.first()
      || PROD_REJ.ILW+=_after-_before;
         PROD_REJ.ILWB+=_bafter-_bbefore;
::         PROD_REJ.IL-=_after-_before;
         _zgp_il:=exec('FindAndGet','#table',ZGP,_zgp,,"ZGP.ILOSC",0);
         PROD_REJ.IL:=_zgp_il-PROD_REJ.ILW;
         {? PROD_REJ.IL<0 || PROD_REJ.IL:=0 ?};
::       Aktualizacja znacznika START (czy operacja rozpoczęta na e-kiosku)
         PROD_REJ.START:={? exec('czyStartProdRej','ekioski',0) || 'T' || 'N' ?};
::      {? PROD_REJ.IL<=0 || PROD_REJ.OK:='T' || PROD_REJ.OK:='N' ?};
         PROD_REJ.put()
      ?}
   ?};
::   _ilc:=PROD_REJ.ILC;
::   _ilw:=PROD_REJ.ILW;
::   _ilwb:=PROD_REJ.ILWB;
::   _il:=PROD_REJ.IL;

   Cntx.pop(PROD_REJ,ZGP,GROP);
   ~~

|? _b=KAP
||
:: Aktualizacja znacznika PROD_REJ.PRAC, PROD_REJ.BRYG, PROD_REJ.IL_KAP
   {? _a='add' | _a='put'
   ||
      Cntx.psh(PROD_REJ,KAP,ZGP);

      {? exec('zgp_is_kap','zl_kap',KAP.ZGP)>0
      || _kap:='T'
      || _kap:='N'
      ?};

      PROD_REJ.index('ZGP');
      PROD_REJ.prefix('ZL',KAP.ZGP);
      {? PROD_REJ.first()
      || {? PROD_REJ.ZGP().BRYG='T' || PROD_REJ.BRYG:=_kap || PROD_REJ.PRAC:=_kap ?};
         PROD_REJ.IL_KAP:=exec('prod_rej_il_kap','prod_rej');
         PROD_REJ.put()
      ?};

      Cntx.pop(PROD_REJ,KAP,ZGP);
      ~~
   |? _a='del'
   ||
      Cntx.psh(PROD_REJ,KAP,ZGP);

      {? exec('zgp_is_kap','zl_kap',bfld('ZGP'))>0
      || _kap:='T'
      || _kap:='N'
      ?};

      PROD_REJ.index('ZGP');
      PROD_REJ.prefix('ZL',bfld('ZGP'));
      {? PROD_REJ.first()
      || {? PROD_REJ.ZGP().BRYG='T' || PROD_REJ.BRYG:=_kap || PROD_REJ.PRAC:=_kap ?};
         PROD_REJ.IL_KAP:=exec('prod_rej_il_kap','prod_rej');
         PROD_REJ.put()
      ?};

      Cntx.pop(PROD_REJ,KAP,ZGP);
      ~~
   ?}
?}


\load_one4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ładuje dane do rejestracji wykonań dla jednego zlecenia (jeśli złożone/niezależne, to cała struktura)
::   WE: _a - ZL.ref()
::  OLD: \load_one4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(PROD_REJ,PROD_NXT,ZL,ZGH,ZGP);
Cntx.clr(PROD_REJ,PROD_NXT,ZL,ZGH);

{? ZL.seek(_a) & (ZL.STAN<>'Z' | ZL.RODZAJ='N')
||
   {? ZL.RODZAJ='Z'
   || ZGH.f_set(
         'UID_VIEW,NRPRZ',,
         'ZGH.UID_VIEW=\':_a\'',
         ZL.uidref()
      )
   |? ZL.RODZAJ='N'
   || ZGH.f_set(
         'ZLEC,NRPRZ',
         'join ZL join ZL as ZL1 using(ZL1.UNRZL,ZL.NRNZL)',
         'ZL.STAN<>\'Z\' and ZL1.REFERENCE=:_a',
         ZL.ref()
      )
   || ZGH.f_set(
         'ZLEC,NRPRZ',,
         'ZGH.ZLEC=:_a',
         ZL.ref()
      )
   ?};

:: Przewodniki do zlecenia głównego - pierwsze naliczenie tworzy zapisy PROD_REJ
   {? ZGH.f_first()
   || {!
      |?
         {? ZGH.KIND='N'
         ||
            ZGP.index('NRPP');
            ZGP.prefix(ZGH.ref());
            {? ZGP.first()
            || {!
               |?
                  Cntx.psh(ZL,ZGH);
::                UWAGA: Podczytanie zlecenia podrzędnego
                  ZGH.ZLEC();

                  PROD_REJ.blank(1);
                  {? ZGP.WEW='T'
                  || PROD_REJ.STARTD:={? ZGP.STARTD=date(0,0,0) || ZL.OD || ZGP.STARTD ?};
                     PROD_REJ.STARTT:=ZGP.STARTT;
                     PROD_REJ.ENDD:={? ZGP.ENDD=date(0,0,0) || ZL.DTR || ZGP.ENDD ?};
                     PROD_REJ.ENDT:=ZGP.ENDT
                  || PROD_REJ.STARTD:={? ZGP.STARTDK=date(0,0,0) || ZL.OD || ZGP.STARTDK ?};
                     PROD_REJ.STARTT:=ZGP.STARTTK;
                     PROD_REJ.ENDD:={? ZGP.ENDDK=date(0,0,0) || ZL.DTR || ZGP.ENDDK ?};
                     PROD_REJ.ENDT:=ZGP.ENDTK
                  ?};
:: [areKc] - Ustalenie zmiany wykonującej pozycję z przewodnika.
                  PROD_REJ.QZMIANA:=exec('zmiana','zl_common',PROD_REJ.STARTT);
                  exec('fields_4rej','zl_wyk');
                  PROD_REJ.WYD:=exec('wyd','zl_guide');
                  PROD_REJ.PRIORITY:='N';
                  PROD_REJ.SRODZ:='ZL';
                  PROD_REJ.SOURCE:=$ZGP.ref();
                  PROD_REJ.ZL:=ZL.ref();
                  PROD_REJ.ZGH:=ZGH.ref();
                  PROD_REJ.ZGP:=ZGP.ref();
                  PROD_REJ.M:=ZL.KTM;
                  PROD_REJ.JM:=ZL.KTM().J;
                  {? ZGP.WEW='T'
                  ||
                     PROD_REJ.RES_SYM:=ZGP.PLACE().KOD;
                     PROD_REJ.RES_NAZ:=TWRKPLC.NA
                  ||
                     PROD_REJ.RES_SYM:='{KOOPERACJA}';
                     PROD_REJ.RES_NAZ:='Kooperacja'
                  ?};
                  PROD_REJ.KH:=ZGP.KONTRAH;
                  PROD_REJ.GKTL:=ZGP.NRPRZ().GKTL;
::                Zlicz ilości z rejestracji źródłowych
                  ZLGD.cntx_psh();
                  _oddzial:=ZL.ODDZ;
                  {? _oddzial='' || _oddzial:='_' ?};
                  _rok1:=ZL.OD~1;
                  _rok2:=date()~1;
                  _il:=0; _ilb:=0;
                  {! _it:=_rok1.._rok2
                  |!
                     _rok:=form(_it,-4,,'0')+2;
                     ZLGD.use('zlgd_'+_oddzial+_rok);
                     ZLGD.index('ZLPP');
                     ZLGD.prefix(ZGH.ZLEC,ZGH.ref(),ZGP.ref());
                     {? ZLGD.first()
                     || {!
                        |? _il+=ZLGD.IL;
                           _ilb+=ZLGD.IL_BRAK;
                           ZLGD.next()
                        !}
                     ?}
                  !};
                  ZLGD.cntx_pop();
                  {? PROD_REJ.ZGP<>null()
                  || PROD_REJ.ILC:=ZGP.ILOSC
                  || PROD_REJ.ILC:=ZGH.ILNPRZ
                  ?};
                  PROD_REJ.ILW:=_il;
                  PROD_REJ.ILWB:=_ilb;
                  {? PROD_REJ.ZGP<>null()
                  || PROD_REJ.IL:=ZGP.ILOSC-_il
                  || PROD_REJ.IL:=ZGH.ILNPRZ-_il
                  ?};
                  {? PROD_REJ.IL<0 || PROD_REJ.IL:=0 ?};
                  PROD_REJ.START:={? exec('czyStartProdRej','ekioski',0) || 'T' || 'N' ?};
                  PROD_REJ.OK:={? ZGP.STATUS=exec('status_end','zl_guide') || 'T' || 'N' ?};
                  PROD_REJ.POTW:='N';
                  PROD_REJ.PROBLEM:={? ZGH.PROBLEM='T' || 'T' || ZGP.PROBLEM ?};
                  PROD_REJ.PROBKLAS:={? ZGH.PROBLEM='T' || exec('prob_class_blocking','zl_wkj') || ZGP.PROBKLAS ?};
                  PROD_REJ.PRAC:='N';
                  PROD_REJ.BRYG:='N';
                  PROD_REJ.KOOP:={? ZGP.WEW='T' || 'N' || 'T' ?};
                  PROD_REJ.A:={? ZL.STAN='O' & ZGH.STAN='N' || 'T' || 'N' ?};
                  PROD_REJ.KONTROLA:={? ZGP.KONTROLA='T' || 'T' || 'N' ?};
                  PROD_REJ.KJ_BAD:=ZGP.KJ_BAD;
                  PROD_REJ.RP:='N';
                  {? ZGP.DOK<>null()
                  || PROD_REJ.RP:='T'
                  ?};
::                Domyślnie zablokowane do rejestracji, chyba że Tpz (już inaczej)
                  PROD_REJ.DOREJ:=
                     {? ZGP.STATUS=exec('status_pending','zl_guide')
                     || 'T'
                     || 'N'
                     ?};
::                  {? ZGP.TPZ='T' || 'T' || 'N' ?};
::                Sprawdzenie wykorzystania w grupach operacji
                  {? ZGP.PL_GRP='T'
                  || {? exec('FindInSet','#table','GROPP','ZGP',ZGP.ref(),,"1",,,0)
                     || PROD_REJ.DOREJ:='N';
                        PROD_REJ.A:='N'
                     ?}
                  ?};
                  {? exec('zgp_is_kap','zl_kap',ZGP.ref())>0
                  || {? ZGP.BRYG='T' || PROD_REJ.BRYG:='T' || PROD_REJ.PRAC:='T' ?}
                  ?};
                  PROD_REJ.IL_KAP:=exec('prod_rej_il_kap','prod_rej');
                  PROD_REJ.add(1);

                  Cntx.pop(ZL,ZGH);

                  ZGP.next()
               !}
            ?}
         ?};
         ZGH.f_next()
      !}
   ?};

:: Przewodniki do zlecenia głównego - drugie naliczenie tworzy zapisy PROD_NXT
   {? ZGH.f_first()
   || {!
      |?
         {? ZGH.KIND='N'
         ||
            ZGP.index('NRPP');
            ZGP.prefix(ZGH.ref());
            {? ZGP.first()
            || {!
               |?
                  PROD_REJ.index('ZGP');
                  PROD_REJ.prefix('ZL',ZGP.ref());
                  {? PROD_REJ.first()
                  ||
                     _prod_rej:=PROD_REJ.ref();

::                   Następniki
                     PROD_REJ.cntx_psh();
                     _next:=exec('tab_zgp_next','zl_guide',ZGP.ref());
                     {? _next.first()
                     || {!
                        |?
                           PROD_REJ.index('ZGP');
                           PROD_REJ.prefix('ZL',_next.REF);
                           {? PROD_REJ.first()
                           || PROD_NXT.PROD_REJ:=_prod_rej;
                              PROD_NXT.NEXT:=PROD_REJ.ref();
                              PROD_NXT.add(1)
                           ?};
                           _next.next()
                        !}
                     ?};
                     obj_del(_next);
                     PROD_REJ.cntx_pop();

::                   Poprzedniki - na wszelki wypadek
                     PROD_REJ.cntx_psh();
                     _prev:=exec('tab_zgp_prev','zl_guide',ZGP.ref());
                     {? _prev.first()
                     || {!
                        |?
                           PROD_REJ.index('ZGP');
                           PROD_REJ.prefix('ZL',_prev.REF);
                           {? PROD_REJ.first()
                           || PROD_NXT.PROD_REJ:=PROD_REJ.ref();
                              PROD_NXT.NEXT:=_prod_rej;
                              PROD_NXT.add(1)
                           ?};
                           _prev.next()
                        !}
                     ?};
                     obj_del(_prev);
                     PROD_REJ.cntx_pop();
                     ~~
                  ?};
                  ZGP.next()
               !}
            ?}
         ?};
         ZGH.f_next()
      !}
   ?}
?};

ZGH.f_clear();
Cntx.pop(PROD_REJ,PROD_NXT,ZL,ZGH,ZGP);
~~


\fields_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ustala wartosci pol PROD_REJ zalezne od innych pol
::       Do uzycia w formulach exec('update_4rej','zl_wyk'), exec('load_4rej','zl_wyk')
::  OLD: \fields_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
:: Pobrany symbol zlecenia i przewodnika
:: (w przypadku zlecenia zlozonego kontekst powinien byc ustawiony na zlecenie podrzedne)

:: NUCO - dodanie do opisu informacji o wykonywanej operacji oraz numeru zlecenia zbiorczego
:: PROD_REJ.OPIS:=ZGH.ZLEC().SYM+' - '+ZGH.NRPRZ+' - '+$ZGP.NRP+{? ZGP.TPZ='T' || ' [1Tpz]' || ' [2G]' ?};
_zl_nad:='';
{? ZGP.NRPRZ().ZLEC().NRNZL<>0
|| _zl_nad_ref:=exec('top_level','zl_link', ZGP.NRPRZ().ZLEC);
   {? _zl_nad_ref<>ZGP.NRPRZ().ZLEC
   || _zl_nad:=exec('FindAndGet','#table',ZL,_zl_nad_ref,,"' ('+SYM+') '",'')
   ?}
?};
PROD_REJ.OPIS:=ZGP.NRPRZ().NRPRZ+'-'+$ZGP.NRP+' '+_zl_nad+ZGP.OPIS;
PROD_REJ.OPER:='['+$PROD_REJ.STARTD+' '+$PROD_REJ.STARTT+'] '+PROD_REJ.OPIS;
ZL.cntx_pop();
~~


\wykon_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Wykonano' w oknie rejestracji wykonań - przewodnik/grupa operacji
::  OLD: \wykon_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_no_error:=0;
_is_term:=VEK.TERM='T' | VAR1.ZAK_EK='T';
{? ~exec('access','zl_wyk') || return(_res) ?};

:: NUCO - kontrola czy zlecenie znajduje się w Planie operacyjnym
{? PROD_REJ.ZL().PLAN_PO<>'T' & sql('select count(*) as ZO from ZWAR where ZWAR.ZL=:_a and ZWAR.KIND=\'ZO\'',PROD_REJ.ZL).ZO=0
|| {? exec('get_w','#params',9985,2,OPERATOR.USER)<>'T'
   || FUN.error('Zlecenie nie zostało umieszczone w planie operacyjnym !!!\n'+
                 'Rejestracja produkcji nie jest możliwa, skontaktuj się z planistą.');
      return(_res)
   ?}
?};
::----------------------------------------------------------------------------------------------------------------------
:: Merit_2325_test - modyfikacja:  2024 Lut 08 12:18
:: TP, opis : Wartości domyślnej dla zmiennej VPRODREJ i możliwość edycji początku operacji
::----------------------------------------------------------------------------------------------------------------------
VPRODREJ.ZMIANA:=PROD_REJ.QZMIANA;
VPRODREJ.STARTD:=PROD_REJ.STARTD;
VPRODREJ.EDIT_STA:=1;
::----------------------------------------------------------------------------------------------------------------------
{? date(ST.AR,ST.AM,0)>date(,,0)
|| _txt:='Nie można rejestrować wykonania — wybrany okres obrachunkowy nie może być późniejszy od bieżącej daty.'@;
   {? VAR1.KN3='N'
   || KOMM.add(_txt,5)
   || FUN.info(_txt)
   ?};
   return(_res)
?};

{? PROD_REJ.A<>'T'
|| _txt:='Zapis nieaktywny — nie można rejestrować wykonania.'@;
   {? VAR1.KN3='N'
   || KOMM.add(_txt,5)
   || FUN.info(_txt)
   ?};
   return(_res)
?};

{? PROD_REJ.PROBLEM='T' & PROD_REJ.PROBKLAS<>exec('prob_class_information','zl_wkj')
|| _txt:='Zgłoszony problem klasy \'%1\' — nie można rejestrować wykonania.'@[PROD_REJ.PROBKLAS];
   {? VAR1.KN3='N'
   || KOMM.add(_txt,5)
   || FUN.info(_txt)
   ?};
   return(_res)
?};

{? PROD_REJ.ZGP<>null() & PROD_REJ.ZGP().SRW='M'
|| _txt:='Rejestracja wykonań możliwa poprzez moduł magazynowy.'@;
   {? VAR1.KN3='N'
   || KOMM.add(_txt,5)
   || FUN.info(_txt)
   ?};
   return(_res)
?};

{? PROD_REJ.ZGP<>null() & exec('FindInSet','#table','GROPP','ZGP',PROD_REJ.ZGP)
|| _txt:='Zapis użyty w grupie operacji — nie można bezpośrednio rejestrować wykonania.'@;
   {? VAR1.KN3='N'
   || KOMM.add(_txt,5)
   || FUN.info(_txt)
   ?};
   return(_res)
?};

{? PROD_REJ.GROP<>null()
|| {? PROD_REJ.GROPS=null()
   || _txt:='Grupa operacji nieplanowana — nie można rejestrować wykonania.'@;
      {? VAR1.KN3='N'
      || KOMM.add(_txt,5)
      || FUN.info(_txt)
      ?};
      return(_res)
   ?};
   GROPP.index('GROP');
   GROPP.prefix(PROD_REJ.GROP);
   {? GROPP.first()
   || {!
      |? {? GROPP.ZGP().NRZLP().ZLEC().STAN<>'O'
         ||
            {? VAR1.KN3='N'
            || KOMM.add(
                  'W skład grupy wchodzi operacja zlecenia %1, które nie jest otwarte.\n'
                  'Nie można rejestrować wykonania dla tej grupy.'@[ZL.SYM],5
               )
            || FUN.info(
                  'W skład grupy wchodzi operacja zlecenia %1, które nie jest otwarte.\n'
                  'Nie można rejestrować wykonania dla tej grupy.'@[ZL.SYM]
               )
            ?};
            return(_res)
         ?};
         GROPP.next()
      !}
   ?}
?};

_date:=date();
{? VAR1.ZAK_EK<>'T'
|| {? date(ST.AR,ST.AM,0)<>date(,,0)
   || {? VAR1.KN3<>'N' & ~FUN.ask('Wybrany okres obrachunkowy nie jest zgodny z bieżącą datą.\n\nCzy rejestrować wykonania z datą %1?'@
                  [$date(ST.AR,ST.AM,0)]
         )
      || {? VAR1.KN3='N'
         || KOMM.add('Wybrany okres obrachunkowy nie jest zgodny z bieżącą datą.'@,5)
         ?};
         return(_res)
      || _date:=date(ST.AR,ST.AM,0)
      ?}
   ?}
?};

{? PROD_REJ.ZL<>null() & PROD_REJ.ZL().OD>_date
|| _txt:='Zlecenie powołane z późniejszą datą.'@;
   {? VAR1.KN3='N'
   || KOMM.add(_txt,5)
   || FUN.emsg(_txt)
   ?};
   return(_res)
?};

::{? PROD_REJ.GROP<>null() & PROD_REJ.GROP().DATA>_date
::|| FUN.emsg('Grupa operacji zaplanowana do realizacji z późniejszą datą.'@);

::   return(_res)
::?};

_forced:=0;
{? PROD_REJ.OK='T'
|| {? _is_term
   || {? FUN.ask('Wykonanie operacji zostało już zakończone.'@+'\n'+
                  'Czy na pewno zarejestrować wykonanie?'@)
      || _forced:=1
      || return(_res)
      ?}
   || _txt:='Wykonanie operacji zostało już zakończone.'@;
      {? VAR1.KN3='N'
      || KOMM.add(_txt,5)
      || FUN.info(_txt)
      ?};
      return(_res)
   ?}
?};

_chkak:=exec('get','#params',500631,2);
{? _chkak='T' & PROD_REJ.DOREJ<>'T'
|| {? _is_term & _forced
   || ~~
   || _txt:='Zapis niedostępny do rejestracji — najpierw należy zarejestrować operacje poprzedzające.'@;
      {? VAR1.KN3='N'
      || KOMM.add(_txt,5)
      || FUN.info(_txt)
      ?};
      return(_res)
   ?}
?};

_p500645:=exec('get','#params',500645,2);

Cntx.psh(ZL,ZGH,ZGP,KAP,GROP);
Cntx.clr(ZL,ZGH,ZGP,KAP,GROP);

:: Odnalezienie źródłowego GROP
{? PROD_REJ.GROP<>null() & GROP.seek(PROD_REJ.GROP)
   & exec('blk_lock','#table','GROP',PROD_REJ.GROP,,1,'Grupa operacji jest redagowana'@)
||
   _bryg:=exec('grop_bryg','zl_grop',GROP.ref());
   {? _bryg='N'
   || {? _is_term
      || _pracownik:=VEK.P
      || {? exec('is_fast_wyk','prod_rej')
         || _pracownik:=exec('p_select_simple','prod_rej')
         || _pracownik:=exec('p_select','prod_rej')
         ?}
      ?};
      _zlbr:=null();
      _ok:=_pracownik<>null()
   || _pracownik:=null();
      _zlbr:={? _is_term || VEK.A_ZLBR || exec('zlbr_select','prod_rej') ?};
::    Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (tylko Merit, ekiosk sprawdzany później)
      _dalej:={? _is_term || 1 || exec('zlbr_chk_zlbs','prod_rej',_zlbr) ?};
      _ok:=_zlbr<>null() & _dalej>0
   ?};

   {? _ok
   || {? ~_is_term & exec('get','#params',500602)='T'
      || _ok:=exec('grop_full_edit','zl_wyk',
            {? exec('grop_bryg','zl_grop',GROP.ref())='T' || 'B' || 'P' ?},
            _pracownik,
            _zlbr,
            0
         );
         {? _ok
         || _args:=exec('add_akord_a','zl_wyk');
            _args.GROP:=GROP.ref();
            _args.GROPS:=PROD_REJ.GROPS;
            _args.IL:=VPRODREJ.IL;
            _args.IL_BRAK:=VPRODREJ.IL_BRAK;
            _args.OK:=VPRODREJ.OK;
            _args.P:=_pracownik;
            _args.ZLBR:=_zlbr;
            _args.TIME:=VPRODREJ.TIME;
            _args.ZMIANA:=VPRODREJ.ZMIANA;
            _args.R:=VPRODREJ.R;
            _args.ST:=VPRODREJ.ST;
            _args.PLACE:=VPRODREJ.PLACE;
            _res:=exec('add_akord','zl_wyk',_args);
            {? _res>0 & FUN.ask('Czy potwierdzić wykonanie operacji?'@)
            || exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"exec('zlgd_potw','zl_grop')")
            ?}
         ?}
      || _ok:=exec('grop_edit','zl_wyk');
         {? _ok
         || _args:=exec('add_akord_a','zl_wyk');
            _args.GROP:=GROP.ref();
            _args.GROPS:=PROD_REJ.GROPS;
            _args.IL:=VPRODREJ.IL;
            _args.OK:=VPRODREJ.OK;
            _args.P:=_pracownik;
            _args.ZLBR:=_zlbr;
            _args.TIME:=VPRODREJ.TIME;
            _args.ENDD:=VPRODREJ.ENDD;
            _args.ENDT:=VPRODREJ.ENDT;
            {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
            {? _args.ENDT<>time(0,0,0) & _p500645='C'
            || _args.ZMIANA:='C'
            |? _args.ENDT<>time(0,0,0) & _p500645='K'
            || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
            || _args.ZMIANA:=''
            ?};
            _args.PLACE:=VPRODREJ.PLACE;
            {? _is_term & VPRODREJ.WYD<>null()
            || _args.WYD:=VPRODREJ.WYD
            ?};
::          Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (ekiosk)
            _dalej:={? _is_term & _zlbr<>null() || exec('zlbr_chk_zlbs','prod_rej',_zlbr,_args.DT) || 1 ?};
            {? _dalej>0
            || {? _is_term
               ||
::                Jeżeli rejestracja na ilość zerową  to potwierdzenie grupy operacji następuje bezdialogowo
                  {? _args.IL=0
                  || _choice:=2
                  ||  _choice:=FUN.choice('Czy zarejestrować wykonanie operacji grupowej?'@,,'Tak'@,
                        'Tak, z potwierdzeniem'@)
                  ?};
                  {? _choice=1
                  || _res:=exec('add_akord','zl_wyk',_args)
                  |? _choice=2
                  || _res:=exec('add_akord','zl_wyk',_args);
                     {? _res>0
                     || exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"exec('zlgd_potw','zl_grop')")
                     ?}
                  ?}
               || _res:=exec('add_akord','zl_wyk',_args);
                  {? _res>0 & FUN.ask('Czy potwierdzić wykonanie operacji?'@)
                  || exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"exec('zlgd_potw','zl_grop')")
                  ?}
               ?}
            ?}
         ?}
      ?}
   ?};

   exec('blk_unlock','#table','GROP',PROD_REJ.GROP)

:: Odnalezienie źródłowego ZGP
|? ZGP.seek(PROD_REJ.ZGP)
   & exec('blk_lock','#table','ZGH',PROD_REJ.ZGH,,1,'Przewodnik jest redagowany'@)
||
   {? VAR1.KN3<>'N' || VPRODREJ.ZPARN:=null() ?};

   _party_req:=exec('party_req','zl_wyk',PROD_REJ.ZL);
:: Sprawdzam czy zlecenie na którym powstaje produkt jest zleceniem partiowanym
   {? _party_req>0
   ||
::    Sprawdzam czy zlecenie produkcyjne jest zleceniem na które rejestruję robociznę
::    jeśli tak, to mogę spróbować podpowiedzieć partie. Jeśli nie to pewnie jest przypadek
::    zlecenia złożonego i nie mogę podpowiedzieć partii
::    Jeśli zlecenie jest partiowane to sprawdzam ile partii ma przewodnik - jeśli tylko jedną
::    to podpowiadam partię
      ZPARN.cntx_psh();
      ZPARN.index('ZGH');
      _zgh:=null();
      _zgp:=null();
      {? PROD_REJ.SRODZ='ZL'
      || _zgh:=PROD_REJ.ZGH;
         _zgp:=PROD_REJ.ZGP
      |? PROD_REJ.SRODZ='PL'
      || _zgh:=PROD_REJ.PL_OPER().ZGP().NRZLP;
         _zgp:=PROD_REJ.PL_OPER().ZGP
      ?};

      {? _zgh<>null()
      ||
         _party_zgh:=exec('party_first_zgh','zl_guide',_zgh);
         {? _party_zgh<>null()
         ||
            {? exec('is_fast_wyk','prod_rej')
            || VPRODREJ.ZPARN:=exec('first_not_completed','zl_partie',null(),_party_zgh,'R',_zgp)
            ||
            ZPARN.prefix(_party_zgh);
            {? ZPARN.size()=1
            || {? ZPARN.first()
               || VPRODREJ.ZPARN:=ZPARN.ref()
               ?}
            ?}
            ?};
            ~~
         ?}
      ?};
      ZPARN.cntx_pop()
   ?};

:: Kontekst dla kart pracy - bieżący okres
   KAP.index('ZGP_PB');
   KAP.prefix(ZGP.ref());

   {? ZGP.NRPRZ().STAN='T'
   || _txt:='Przewodnik oddany — rejestracja nie jest możliwa.'@;
      {? VAR1.KN3='N'
      || KOMM.add(_txt,5)
      || FUN.info(_txt)
      ?}

   |? ZGP.NRPRZ().KIND='T'
   || _txt:='Przewodnik "techniczny" — rejestracja nie jest możliwa.'@;
      {? VAR1.KN3='N'
      || KOMM.add(_txt,5)
      || FUN.info(_txt)
      ?}

   |? ZGP.NRPRZ().ZLEC().STAN<>'O'
   || _txt:='Zlecenie nie jest otwarte — rejestracja nie jest możliwa.'@;
      {? VAR1.KN3='N'
      || KOMM.add(_txt,5)
      || FUN.info(_txt)
      ?}

:: Rejestracja kooperacji - bezpośrednio do pozycji przewodnika
   |? PROD_REJ.KOOP='T'
   ||
      exec('wykon_start','zl_wyk',ZGP.ref());
      {? ZGP.NRPRZ().ZLEC().TYP().WP='W'
      ||
         _ok:=FUN.ask('Czy zarejestrować całkowite wykonanie kooperacji?'@);
         {? _ok
         ||
            _args:=exec('add_akord_a','zl_wyk');
            _args.ZGP:=ZGP.ref();
            _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
            _args.OK:='T';
            _args.ZPARN:=VPRODREJ.ZPARN;
            _res:=exec('add_akord','zl_wyk',_args)
         ?}
      ||
         _ok:=exec('ile_edit','zl_wyk');
         {? _ok
         ||
            _args:=exec('add_akord_a','zl_wyk');
            _args.ZGP:=ZGP.ref();
            _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
            _args.IL:=VPRODREJ.IL;
            _args.IL_BRAK:=VPRODREJ.IL_BRAK;
            _args.OK:=VPRODREJ.OK;
            _args.ZPARN:=VPRODREJ.ZPARN;
            _args.BRAKI_R:=VPRODREJ.BRAKI_R;
            _res:=exec('add_akord','zl_wyk',_args)
         ?}
      ?}

:: Rejestracja gdy brak czasu dla pracownika - bezpośrednio do pozycji przewodnika
   |? ZGP.NTIME=0
   || exec('wykon_start','zl_wyk',ZGP.ref());
      {? ~_is_term & exec('get','#params',500602)='T'
      || _ok:=exec('full_edit','zl_wyk');
         {? _ok
         ||
            _args:=exec('add_akord_a','zl_wyk');
            _args.ZGP:=ZGP.ref();
            _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
            _args.IL:=VPRODREJ.IL;
            _args.IL_BRAK:=VPRODREJ.IL_BRAK;
            _args.OK:=VPRODREJ.OK;
            _args.ZPARN:=VPRODREJ.ZPARN;
            _args.TIME:=VPRODREJ.TIME;
            _args.ZMIANA:=VPRODREJ.ZMIANA;
            _args.R:=VPRODREJ.R;
            _args.ST:=VPRODREJ.ST;
            _args.PLACE:=VPRODREJ.PLACE;
            _args.BRAKI_R:=VPRODREJ.BRAKI_R;
            _res:=exec('add_akord','zl_wyk',_args)
         ||
            _res:=0
         ?}
      |? ZGP.NRPRZ().ZLEC().TYP().WP='W'
      || _ok:=exec('work_edit','zl_wyk',,0);
         {? _ok
         ||
            _args:=exec('add_akord_a','zl_wyk');
            _args.ZGP:=ZGP.ref();
            _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
            _args.IL:=0;
            _args.IL_BRAK:=0;
            _args.OK:=VPRODREJ.OK;
            _args.ZPARN:=VPRODREJ.ZPARN;
            _args.PLACE:=VPRODREJ.PLACE;
            {? _is_term & VPRODREJ.WYD<>null()
            || _args.WYD:=VPRODREJ.WYD
            ?};
            _args.ZMIANA:='';
            _res:=exec('add_akord','zl_wyk',_args)
         ?}
      || _ok:=exec('ile_edit','zl_wyk');
         {? _ok
         ||
            _args:=exec('add_akord_a','zl_wyk');
            _args.ZGP:=ZGP.ref();
            _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
            _args.IL:=VPRODREJ.IL;
            _args.IL_BRAK:=VPRODREJ.IL_BRAK;
            _args.OK:=VPRODREJ.OK;
            _args.ZPARN:=VPRODREJ.ZPARN;
            _args.PLACE:=VPRODREJ.PLACE;
            {? _is_term & VPRODREJ.WYD<>null()
            || _args.WYD:=VPRODREJ.WYD
            ?};
            _args.BRAKI_R:=VPRODREJ.BRAKI_R;
            {? _p500645<>'K' || _args.ZMIANA:='' ?};
            _res:=exec('add_akord','zl_wyk',_args)
         ?}
      ?}

:: Rejestracja operacji dla brygady wg karty pracy (gdy są karty w bieżącej masce - roku)
   |? PROD_REJ.BRYG='T' &
      ({? _is_term || KAP.prefix(ZGP.ref(),null(),VEK.A_ZLBR) || KAP.prefix(ZGP.ref()) ?};
      KAP.first() & VAR1.BEZ_KAP<>'T')
   ||
      exec('wykon_start','zl_wyk',ZGP.ref());
::      KAP.win_sel('SLO_BZ');
      KAP.win_sel(exec('win_grp','zl_kap',,1,'SLO_BZ'));
      '-*-e-kioski-*-';
      _kap_sel:=exec('findFirstKap','ekioski');
      {? VAR1.BEZ_KAP='T'
      ||
::       Rejestracja z pominięciem kart pracy
::       !!! REKURENCJA !!!
         _res:=exec('wykon_4rej','zl_wyk');
         {? ~_is_term
         || VAR1.BEZ_KAP:='N'
         ?}
      ||
      {? _kap_sel
      ||
         _ile:=KAP.IL;
         _time:=KAP.TIME;
         _czy_zlgd:=0;
         Cntx.psh(ZLGD);
         ZLGD.index('KAP');
         ZLGD.prefix(KAP.ref());
         {? ZLGD.first()
         || {!
            |? _ile-=ZLGD.IL;
               _time-=ZLGD.TIME;
::             Sprawdzam czy do karty pracy zarejestrowano (zakończone) wykonanie produkcji
               {? _czy_zlgd=0 & ZLGD.ZAK='T'
               || _czy_zlgd:=1
               ?};
               ZLGD.next()
            !}
         ?};
         Cntx.pop(ZLGD);
::       Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (tylko Merit, ekiosk sprawdzany później)
         _zlbr:=KAP.B;
            _dalej:={? _is_term || 1 || exec('zlbr_chk_zlbs','prod_rej',_zlbr,,0) ?};

         {? KAP.IL>0 & _ile<=0
         || FUN.info('Do tej karty pracy zarejestrowano już całą ilość.'@);
            _res:=0
         |? KAP.IL=0 & KAP.TIME=0 & _czy_zlgd=1
         || FUN.info('Do tej karty pracy zarejestrowano już wszystkie wykonania.'@);
            _res:=0
         |? _dalej=0
         || FUN.emsg('Pusty skład brygady na dzień %1.'@[$_date]);
            _res:=0
         ||
               {? ~_is_term & exec('get','#params',500602)='T'
            || _ok:=exec('full_edit','zl_wyk',
                  {? KAP.ZGP().BRYG='T' || 'B' || 'P' ?},,
                  KAP.B,
                  {? KAP.ZGH().ZLEC().TYP().WP='W' | KAP.ZGP().TPZ='T' || 0 || _ile ?},
                  {? KAP.ZGH().ZLEC().TYP().WP='W' | KAP.ZGP().TPZ='T' || {? _time<0 || 0 || _time ?} || 0 ?},
                  KAP.ref()
               );
               {? _ok
               ||
                  _args:=exec('add_akord_a','zl_wyk');
                  _args.KAP:=KAP.ref();
                  _args.ZGP:=KAP.ZGP;
                  _args.ZLBR:=KAP.B;
                  _args.TIME:=VPRODREJ.TIME;
                  _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                  _args.IL:=VPRODREJ.IL;
                  _args.IL_BRAK:=VPRODREJ.IL_BRAK;
                  _args.OK:=VPRODREJ.OK;
                  _args.ZPARN:=VPRODREJ.ZPARN;
                  _args.ZMIANA:=VPRODREJ.ZMIANA;
                  _args.R:=VPRODREJ.R;
                  _args.ST:=VPRODREJ.ST;
                  _args.PLACE:=VPRODREJ.PLACE;
                  _args.BRAKI_R:=VPRODREJ.BRAKI_R;
                  _res:=exec('add_akord','zl_wyk',_args)
               ||
                  _res:=0
               ?}
            ||
               {? KAP.ZGH().ZLEC().TYP().WP='W'
               ||
                  _ok:=exec('work_edit','zl_wyk',_time);
                  {? _ok
                  ||
                     _args:=exec('add_akord_a','zl_wyk');
                     _args.KAP:=KAP.ref();
                     _args.ZGP:=KAP.ZGP;
                     _args.ZLBR:=KAP.B;
                     _args.TIME:=VPRODREJ.TIME;
                     _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                     _args.OK:=VPRODREJ.OK;
                     _args.ZPARN:=VPRODREJ.ZPARN;
                     _args.ENDD:=VPRODREJ.ENDD;
                     _args.ENDT:=VPRODREJ.ENDT;
                     {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                     {? _args.ENDT<>time(0,0,0) & _p500645='C'
                     || _args.ZMIANA:='C'
                     |? _args.ENDT<>time(0,0,0) & _p500645='K'
                     || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                     || _args.ZMIANA:=''
                     ?};
                     _args.PLACE:=VPRODREJ.PLACE;
                        {? _is_term & VPRODREJ.WYD<>null()
                        || _args.WYD:=VPRODREJ.WYD
                        ?};
::                   Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (ekiosk)
                        _dalej:={? _is_term || exec('zlbr_chk_zlbs','prod_rej',_zlbr,_args.DT) || 1 ?};
                     {? _dalej>0
                     || _res:=exec('add_akord','zl_wyk',_args)
                     ?}
                  || _res:=0
                  ?}
               |? KAP.ZGP().TPZ='T'
               ||
                  _ok:=exec('tpz_edit','zl_wyk',_time);
                  {? _ok
                  ||
                     _args:=exec('add_akord_a','zl_wyk');
                     _args.KAP:=KAP.ref();
                     _args.ZGP:=KAP.ZGP;
                     _args.ZLBR:=KAP.B;
                     _args.TIME:=VPRODREJ.TIME;
                     _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                     _args.OK:=VPRODREJ.OK;
                     _args.ENDD:=VPRODREJ.ENDD;
                     _args.ENDT:=VPRODREJ.ENDT;
                     {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                     {? _args.ENDT<>time(0,0,0) & _p500645='C'
                     || _args.ZMIANA:='C'
                     |? _args.ENDT<>time(0,0,0) & _p500645='K'
                     || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                     || _args.ZMIANA:=''
                     ?};
                     _args.PLACE:=VPRODREJ.PLACE;
                        {? _is_term & VPRODREJ.WYD<>null()
                        || _args.WYD:=VPRODREJ.WYD
                        ?};
::                    Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (ekiosk)
                        _dalej:={? _is_term || exec('zlbr_chk_zlbs','prod_rej',_zlbr,_args.DT) || 1 ?};
                     {? _dalej>0
                     || _res:=exec('add_akord','zl_wyk',_args)
                     ?}
                  || _res:=0
                  ?}
               ||
                  _ok:=exec('ile_edit','zl_wyk',_ile);
                  {? _ok
                  ||
                     _args:=exec('add_akord_a','zl_wyk');
                     _args.KAP:=KAP.ref();
                     _args.ZGP:=KAP.ZGP;
                     _args.ZLBR:=KAP.B;
                     _args.TIME:=VPRODREJ.TIME;
                     _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                     _args.IL:=VPRODREJ.IL;
                     _args.IL_BRAK:=VPRODREJ.IL_BRAK;
                     _args.OK:=VPRODREJ.OK;
                     _args.ZPARN:=VPRODREJ.ZPARN;
                     _args.ENDD:=VPRODREJ.ENDD;
                     _args.ENDT:=VPRODREJ.ENDT;
                     {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                     {? _args.ENDT<>time(0,0,0) & _p500645='C'
                     || _args.ZMIANA:='C'
                     |? _args.ENDT<>time(0,0,0) & _p500645='K'
                     || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                     || _args.ZMIANA:=''
                     ?};
                     _args.PLACE:=VPRODREJ.PLACE;
                        {? _is_term & VPRODREJ.WYD<>null()
                        || _args.WYD:=VPRODREJ.WYD
                        ?};
                     _args.BRAKI_R:=VPRODREJ.BRAKI_R;
::                    Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (ekiosk)
                        _dalej:={? _is_term || exec('zlbr_chk_zlbs','prod_rej',_zlbr,_args.DT) || 1 ?};
                     {? _dalej>0
                     || _res:=exec('add_akord','zl_wyk',_args)
                     ?}
                  ||
                     _res:=0
                  ?}
               ?}
            ?}
         ?}
      ||
         _res:=0
      ?}
      ?}

:: Rejestracja operacji dla pracownika wg karty pracy (gdy są karty w bieżącej masce - roku)
   |? PROD_REJ.PRAC='T' &
      ({? _is_term || KAP.prefix(ZGP.ref(),VEK.P,null()) || KAP.prefix(ZGP.ref()) ?};
      KAP.first() & VAR1.BEZ_KAP<>'T')
   ||
      exec('wykon_start','zl_wyk',ZGP.ref());
      KAP.win_sel('SLO_Z');

      '-*-e-kioski-*-';
      _kap_sel:=exec('findFirstKap','ekioski');
      {? VAR1.BEZ_KAP='T'
      ||
::       Rejestracja z pominięciem kart pracy
::       !!! REKURENCJA !!!
         _res:=exec('wykon_4rej','zl_wyk');
         {? ~_is_term
         || VAR1.BEZ_KAP:='N'
         ?}
      ||
      {? _kap_sel
      ||
         _ile:=KAP.IL;
         _time:=KAP.TIME;
         _czy_zlgd:=0;
         ZLGD.cntx_psh();
         ZLGD.index('KAP');
         ZLGD.prefix(KAP.ref());
         {? ZLGD.first()
         || {!
            |? _ile-=ZLGD.IL;
               _time-=ZLGD.TIME;
::             Sprawdzam czy do karty pracy zarejestrowano (zakończone) wykonanie produkcji
               {? _czy_zlgd=0 & ZLGD.ZAK='T'
               || _czy_zlgd:=1
               ?};
               ZLGD.next()
            !}
         ?};
         ZLGD.cntx_pop();
         {? KAP.IL>0 & _ile<=0
         || FUN.info('Do tej karty pracy zarejestrowano już całą ilość.'@);
            _res:=0
         |? KAP.IL=0 & KAP.TIME=0 & _czy_zlgd=1
         || FUN.info('Do tej karty pracy zarejestrowano już wszystkie wykonania.'@);
            _res:=0
         ||
               {? ~_is_term & exec('get','#params',500602)='T'
            || _ok:=exec('full_edit','zl_wyk',
                  {? KAP.ZGP().BRYG='T' || 'B' || 'P' ?},
                  KAP.P,,
                  {? KAP.ZGH().ZLEC().TYP().WP='W' | KAP.ZGP().TPZ='T' || 0 || _ile ?},
                  {? KAP.ZGH().ZLEC().TYP().WP='W' | KAP.ZGP().TPZ='T' || {? _time<0 || 0 || _time ?} || 0 ?},
                  KAP.ref()
               );
               {? _ok
               ||
                  _args:=exec('add_akord_a','zl_wyk');
                  _args.KAP:=KAP.ref();
                  _args.ZGP:=KAP.ZGP;
                  _args.P:=KAP.P;
                  _args.TIME:=VPRODREJ.TIME;
                  _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                  _args.IL:=VPRODREJ.IL;
                  _args.IL_BRAK:=VPRODREJ.IL_BRAK;
                  _args.OK:=VPRODREJ.OK;
                  _args.ZPARN:=VPRODREJ.ZPARN;
                  _args.ZMIANA:=VPRODREJ.ZMIANA;
                  _args.R:=VPRODREJ.R;
                  _args.ST:=VPRODREJ.ST;
                  _args.PLACE:=VPRODREJ.PLACE;
                  _args.BRAKI_R:=VPRODREJ.BRAKI_R;
                  _res:=exec('add_akord','zl_wyk',_args)
               ||
                  _res:=0
               ?}
            || {? KAP.ZGH().ZLEC().TYP().WP='W'
               ||
                  _ok:=exec('work_edit','zl_wyk',_time);
                  {? _ok
                  ||
                     _args:=exec('add_akord_a','zl_wyk');
                     _args.KAP:=KAP.ref();
                     _args.ZGP:=KAP.ZGP;
                     _args.P:=KAP.P;
                     _args.TIME:=VPRODREJ.TIME;
                     _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                     _args.OK:=VPRODREJ.OK;
                     _args.ZPARN:=VPRODREJ.ZPARN;
                     _args.ENDD:=VPRODREJ.ENDD;
                     _args.ENDT:=VPRODREJ.ENDT;
                     {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                     {? _args.ENDT<>time(0,0,0) & _p500645='C'
                     || _args.ZMIANA:='C'
                     |? _args.ENDT<>time(0,0,0) & _p500645='K'
                     || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                     || _args.ZMIANA:=''
                     ?};
                     _args.PLACE:=VPRODREJ.PLACE;
                        {? _is_term & VPRODREJ.WYD<>null()
                        || _args.WYD:=VPRODREJ.WYD
                        ?};
                     _res:=exec('add_akord','zl_wyk',_args)
                  || _res:=0
                  ?}
               |? KAP.ZGP().TPZ='T'
               ||
                  _ok:=exec('tpz_edit','zl_wyk',_time);
                  {? _ok
                  ||
                     _args:=exec('add_akord_a','zl_wyk');
                     _args.KAP:=KAP.ref();
                     _args.ZGP:=KAP.ZGP;
                     _args.P:=KAP.P;
                     _args.TIME:=VPRODREJ.TIME;
                     _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                     _args.OK:=VPRODREJ.OK;
                     _args.ZPARN:=VPRODREJ.ZPARN;
                     _args.ENDD:=VPRODREJ.ENDD;
                     _args.ENDT:=VPRODREJ.ENDT;
                     {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                     {? _args.ENDT<>time(0,0,0) & _p500645='C'
                     || _args.ZMIANA:='C'
                     |? _args.ENDT<>time(0,0,0) & _p500645='K'
                     || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                     || _args.ZMIANA:=''
                     ?};
                     _args.PLACE:=VPRODREJ.PLACE;
                        {? _is_term & VPRODREJ.WYD<>null()
                        || _args.WYD:=VPRODREJ.WYD
                        ?};
                     _res:=exec('add_akord','zl_wyk',_args)
                  ||
                     _res:=0
                  ?}
               ||
                  _ok:=exec('ile_edit','zl_wyk',_ile);
                  {? _ok
                  ||
                     _args:=exec('add_akord_a','zl_wyk');
                     _args.KAP:=KAP.ref();
                     _args.ZGP:=KAP.ZGP;
                     _args.P:=KAP.P;
                     _args.TIME:=VPRODREJ.TIME;
                     _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                     _args.IL:=VPRODREJ.IL;
                     _args.IL_BRAK:=VPRODREJ.IL_BRAK;
                     _args.OK:=VPRODREJ.OK;
                     _args.ZPARN:=VPRODREJ.ZPARN;
                     _args.ENDD:=VPRODREJ.ENDD;
                     _args.ENDT:=VPRODREJ.ENDT;
                     {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                     {? _args.ENDT<>time(0,0,0) & _p500645='C'
                     || _args.ZMIANA:='C'
                     |? _args.ENDT<>time(0,0,0) & _p500645='K'
                     || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                     || _args.ZMIANA:=''
                     ?};
                     _args.PLACE:=VPRODREJ.PLACE;
                        {? _is_term & VPRODREJ.WYD<>null()
                        || _args.WYD:=VPRODREJ.WYD
                        ?};
                     _args.BRAKI_R:=VPRODREJ.BRAKI_R;
                     _res:=exec('add_akord','zl_wyk',_args)
                  ||
                     _res:=0
                  ?}
               ?}
            ?}
         ?}
      ||
         _res:=0
      ?}
      ?}

:: Rejestracja operacji dla brygady bezpośrednio do pozycji przewodnika
   |? ZGP.BRYG='T'
   ||
      exec('wykon_start','zl_wyk',ZGP.ref());
      {? _is_term
      || _zlbr:=VEK.A_ZLBR
      || _zlbr:={? VAR1.KN3='N' & FILTER.PR_ZLBR<>null()
                || FILTER.PR_ZLBR
                || exec('zlbr_select','prod_rej')
                ?};
::        Jak rejestracja z poziomu partii to przypisuje do zmiennej wybraną brygadę
         {? VAR1.KN3='N' & FILTER.PR_ZLBR=null() & _zlbr<>null()
         || FILTER.PR_ZLBR:=_zlbr
         |? VAR1.KN3='N' & _zlbr=null()
         || _no_error:=1
         ?}
      ?};
::    Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (tylko Merit, ekiosk sprawdzany później)
      _dalej:={? _is_term || 1 || exec('zlbr_chk_zlbs','prod_rej',_zlbr) ?};
      {? _dalej=0 & VAR1.KN3='N' || _no_error:=1 ?};

      {? _zlbr<>null() & _dalej>0
      ||
::       Podpowiadam czas tylko dla operacji TPZ lub zleceń warsztatowych
         _do_rej:={? ZGP.NRPRZ().ZLEC().TYP().WP='W' | ZGP.TPZ='T'
                  || ZGP.NTIME-exec('zgp_time_rej','zl_wyk',ZGP.ref())
                  || 0
                  ?};
         {? ~_is_term & exec('get','#params',500602)='T'
         || _ok:=exec('full_edit','zl_wyk',{? ZGP.BRYG='T' || 'B' || 'P' ?},,_zlbr,,{? _do_rej<0 || 0 || _do_rej ?});
            {? _ok
            ||
               _args:=exec('add_akord_a','zl_wyk');
               _args.ZGP:=ZGP.ref();
               _args.ZLBR:=_zlbr;
               _args.TIME:=VPRODREJ.TIME;
               _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
               _args.IL:=VPRODREJ.IL;
               _args.IL_BRAK:=VPRODREJ.IL_BRAK;
               _args.OK:=VPRODREJ.OK;
               _args.ZPARN:=VPRODREJ.ZPARN;
               _args.ZMIANA:=VPRODREJ.ZMIANA;
               _args.R:=VPRODREJ.R;
               _args.ST:=VPRODREJ.ST;
               _args.PLACE:=VPRODREJ.PLACE;
               _args.BRAKI_R:=VPRODREJ.BRAKI_R;
               _res:=exec('add_akord','zl_wyk',_args)
            ||
               _res:=0
            ?}
         ||
            {? ZGP.NRPRZ().ZLEC().TYP().WP='W'
            ||
               _ok:=exec('work_edit','zl_wyk',{? _do_rej<0 || 0 || _do_rej ?});
               {? _ok
               ||
                  _args:=exec('add_akord_a','zl_wyk');
                  _args.ZGP:=ZGP.ref();
                  _args.ZLBR:=_zlbr;
                  _args.TIME:=VPRODREJ.TIME;
                  _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                  _args.OK:=VPRODREJ.OK;
                  _args.ZPARN:=VPRODREJ.ZPARN;
                  _args.ENDD:=VPRODREJ.ENDD;
                  _args.ENDT:=VPRODREJ.ENDT;
::----------------------------------------------------------------------------------------------------------------------
:: Merit_2325_test - modyfikacja:  2024 Lut 08 12:14
:: TP, opis : dodanie obsługi domyślnej zmiany oraz startu operacji
::----------------------------------------------------------------------------------------------------------------------
                  _args.ZMIANA:=VPRODREJ.ZMIANA;
                  _args.STARTD:=VPRODREJ.STARTD;
::----------------------------------------------------------------------------------------------------------------------
                  {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                  {? _args.ENDT<>time(0,0,0) & _p500645='C'
                  || _args.ZMIANA:='C'
                  |? _args.ENDT<>time(0,0,0) & _p500645='K'
                  || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                  || _args.ZMIANA:=''
                  ?};
                  _args.PLACE:=VPRODREJ.PLACE;
                  {? _is_term & VPRODREJ.WYD<>null()
                  || _args.WYD:=VPRODREJ.WYD
                  ?};
::                 Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (ekiosk)
                  _dalej:={? _is_term || exec('zlbr_chk_zlbs','prod_rej',_zlbr,_args.DT) || 1 ?};
                  {? _dalej>0
                  || _res:=exec('add_akord','zl_wyk',_args)
                  ?}
               || _res:=0
               ?}
            |? ZGP.TPZ='T'
            ||
               _ok:=exec('tpz_edit','zl_wyk',{? _do_rej<0 || 0 || _do_rej ?});
               {? _ok
               ||
                  _args:=exec('add_akord_a','zl_wyk');
                  _args.ZGP:=ZGP.ref();
                  _args.ZLBR:=_zlbr;
                  _args.TIME:=VPRODREJ.TIME;
                  _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                  _args.OK:=VPRODREJ.OK;
                  _args.ZPARN:=VPRODREJ.ZPARN;
                  _args.ENDD:=VPRODREJ.ENDD;
                  _args.ENDT:=VPRODREJ.ENDT;
                  {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                  {? _args.ENDT<>time(0,0,0) & _p500645='C'
                  || _args.ZMIANA:='C'
                  |? _args.ENDT<>time(0,0,0) & _p500645='K'
                  || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                  || _args.ZMIANA:=''
                  ?};
                  _args.PLACE:=VPRODREJ.PLACE;
                  {? _is_term & VPRODREJ.WYD<>null()
                  || _args.WYD:=VPRODREJ.WYD
                  ?};
::                 Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (ekiosk)
                  _dalej:={? _is_term || exec('zlbr_chk_zlbs','prod_rej',_zlbr,_args.DT) || 1 ?};
                  {? _dalej>0
                  || _res:=exec('add_akord','zl_wyk',_args)
                  ?}
               || _res:=0
               ?}
            ||
               _ok:=exec('ile_edit','zl_wyk');
               {? _ok
               ||
                  _args:=exec('add_akord_a','zl_wyk');
                  _args.ZGP:=ZGP.ref();
                  _args.ZLBR:=_zlbr;
                  _args.TIME:=VPRODREJ.TIME;
                  _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                  _args.IL:=VPRODREJ.IL;
                  _args.IL_BRAK:=VPRODREJ.IL_BRAK;
                  _args.OK:=VPRODREJ.OK;
                  _args.ZPARN:=VPRODREJ.ZPARN;
                  _args.ENDD:=VPRODREJ.ENDD;
                  _args.ENDT:=VPRODREJ.ENDT;
::----------------------------------------------------------------------------------------------------------------------
:: Merit_2325_test - modyfikacja:  2024 Lut 08 12:14
:: TP, opis : dodanie obsługi domyślnej zmiany oraz startu operacji
::----------------------------------------------------------------------------------------------------------------------
                  _args.ZMIANA:=VPRODREJ.ZMIANA;
                  _args.STARTD:=VPRODREJ.STARTD;
::----------------------------------------------------------------------------------------------------------------------
                  {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                  {? _args.ENDT<>time(0,0,0) & _p500645='C'
                  || _args.ZMIANA:='C'
                  |? _args.ENDT<>time(0,0,0) & _p500645='K'
                  || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                  || _args.ZMIANA:=''
                  ?};
                  _args.PLACE:=VPRODREJ.PLACE;
                  {? _is_term & VPRODREJ.WYD<>null()
                  || _args.WYD:=VPRODREJ.WYD
                  ?};
                  _args.BRAKI_R:=VPRODREJ.BRAKI_R;
::                 Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (ekiosk)
                  _dalej:={? _is_term || exec('zlbr_chk_zlbs','prod_rej',_zlbr,_args.DT) || 1 ?};
                  {? _dalej>0
                  || _res:=exec('add_akord','zl_wyk',_args)
                  ?}
               ||
                  _res:=0
               ?}
            ?}
         ?}
      ||
         _res:=0
      ?}

:: Rejestracja operacji dla pracownika bezpośrednio do pozycji przewodnika
   ||
      exec('wykon_start','zl_wyk',ZGP.ref());
      '-*-e-kioski-*-';
      {? _is_term
      || _pracownik:=VEK.P
      || _pracownik:={? VAR1.KN3='N' & FILTER.PR_P<>null()
                     || FILTER.PR_P
                     || {? exec('is_fast_wyk','prod_rej')
                        || exec('p_select_simple','prod_rej')
                     || exec('p_select','prod_rej')
                        ?}
                     ?};
::        Jak rejestracja z poziomu partii to przypisuje do zmiennej wybranego pracownika
         {? VAR1.KN3='N' & FILTER.PR_P=null() & _pracownik<>null()
         || FILTER.PR_P:=_pracownik
         |? VAR1.KN3='N' & _pracownik=null()
         || _no_error:=1
         ?}
      ?};

      {? _pracownik<>null()
      ||
::       Podpowiadam czas tylko dla operacji TPZ lub zleceń warsztatowych
         _do_rej:={? ZGP.NRPRZ().ZLEC().TYP().WP='W' | ZGP.TPZ='T'
                  || ZGP.NTIME-exec('zgp_time_rej','zl_wyk',ZGP.ref())
                  || 0
                  ?};
         {? ~_is_term & exec('get','#params',500602)='T'
         || _ok:=exec('full_edit','zl_wyk',{? ZGP.BRYG='T' || 'B' || 'P' ?},_pracownik,,,{? _do_rej<0 || 0 || _do_rej ?});
            {? _ok
            ||
               _args:=exec('add_akord_a','zl_wyk');
               _args.ZGP:=ZGP.ref();
               _args.P:=_pracownik;
               _args.TIME:=VPRODREJ.TIME;
               _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
               _args.IL:=VPRODREJ.IL;
               _args.IL_BRAK:=VPRODREJ.IL_BRAK;
               _args.OK:=VPRODREJ.OK;
               _args.ZPARN:=VPRODREJ.ZPARN;
               _args.ZMIANA:=VPRODREJ.ZMIANA;
               _args.R:=VPRODREJ.R;
               _args.ST:=VPRODREJ.ST;
               _args.PLACE:=VPRODREJ.PLACE;
               _args.BRAKI_R:=VPRODREJ.BRAKI_R;
               _res:=exec('add_akord','zl_wyk',_args)
            ||
               _res:=0
            ?}
         ||
            {? ZGP.NRPRZ().ZLEC().TYP().WP='W'
            ||
               _ok:=exec('work_edit','zl_wyk',{? _do_rej<0 || 0 || _do_rej ?});
               {? _ok
               ||
                  _args:=exec('add_akord_a','zl_wyk');
                  _args.ZGP:=ZGP.ref();
                  _args.P:=_pracownik;
                  _args.TIME:=VPRODREJ.TIME;
                  _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                  _args.OK:=VPRODREJ.OK;
                  _args.ZPARN:=VPRODREJ.ZPARN;
                  _args.ENDD:=VPRODREJ.ENDD;
                  _args.ENDT:=VPRODREJ.ENDT;
                  _args.PLACE:=VPRODREJ.PLACE;
::----------------------------------------------------------------------------------------------------------------------
:: Merit_2325_test - modyfikacja:  2024 Lut 08 12:14
:: TP, opis : dodanie obsługi domyślnej zmiany oraz startu operacji
::----------------------------------------------------------------------------------------------------------------------
                  _args.ZMIANA:=VPRODREJ.ZMIANA;
                  _args.STARTD:=VPRODREJ.STARTD;
::----------------------------------------------------------------------------------------------------------------------
                  {? _is_term & VPRODREJ.WYD<>null()
                  || _args.WYD:=VPRODREJ.WYD
                  ?};
                  {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                  {? _args.ENDT<>time(0,0,0) & _p500645='C'
                  || _args.ZMIANA:='C'
                  |? _args.ENDT<>time(0,0,0) & _p500645='K'
                  || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                  || _args.ZMIANA:=''
                  ?};
                  _res:=exec('add_akord','zl_wyk',_args)
               || _res:=0
               ?}
            |? ZGP.TPZ='T'
            ||
               _ok:=exec('tpz_edit','zl_wyk',{? _do_rej<0 || 0 || _do_rej ?});
               {? _ok
               ||
                  _args:=exec('add_akord_a','zl_wyk');
                  _args.ZGP:=ZGP.ref();
                  _args.P:=_pracownik;
                  _args.TIME:=VPRODREJ.TIME;
                  _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                  _args.OK:=VPRODREJ.OK;
                  _args.ZPARN:=VPRODREJ.ZPARN;
                  _args.ENDD:=VPRODREJ.ENDD;
                  _args.ENDT:=VPRODREJ.ENDT;
                  _args.PLACE:=VPRODREJ.PLACE;
                  {? _is_term & VPRODREJ.WYD<>null()
                  || _args.WYD:=VPRODREJ.WYD
                  ?};
                  {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                  {? _args.ENDT<>time(0,0,0) & _p500645='C'
                  || _args.ZMIANA:='C'
                  |? _args.ENDT<>time(0,0,0) & _p500645='K'
                  || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                  || _args.ZMIANA:=''
                  ?};
                  _res:=exec('add_akord','zl_wyk',_args)
               ||
                  _res:=0
               ?}
            ||
               _ok:=exec('ile_edit','zl_wyk');
               {? _ok
               ||
                  _args:=exec('add_akord_a','zl_wyk');
                  _args.ZGP:=ZGP.ref();
                  _args.P:=_pracownik;
                  _args.TIME:=VPRODREJ.TIME;
                  _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                  _args.IL:=VPRODREJ.IL;
                  _args.IL_BRAK:=VPRODREJ.IL_BRAK;
                  _args.OK:=VPRODREJ.OK;
                  _args.ZPARN:=VPRODREJ.ZPARN;
                  _args.ENDD:=VPRODREJ.ENDD;
                  _args.ENDT:=VPRODREJ.ENDT;
                  _args.PLACE:=VPRODREJ.PLACE;
::----------------------------------------------------------------------------------------------------------------------
:: Merit_2325_test - modyfikacja:  2024 Lut 08 12:14
:: TP, opis : dodanie obsługi domyślnej zmiany oraz startu operacji
::----------------------------------------------------------------------------------------------------------------------
                  _args.ZMIANA:=VPRODREJ.ZMIANA;
                  _args.STARTD:=VPRODREJ.STARTD;
::----------------------------------------------------------------------------------------------------------------------
                  {? _is_term & VPRODREJ.WYD<>null()
                  || _args.WYD:=VPRODREJ.WYD
                  ?};
                  _args.BRAKI_R:=VPRODREJ.BRAKI_R;
                  {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                  {? _args.ENDT<>time(0,0,0) & _p500645='C'
                  || _args.ZMIANA:='C'
                  |? _args.ENDT<>time(0,0,0) & _p500645='K'
                  || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                  || _args.ZMIANA:=''
                  ?};
                  _res:=exec('add_akord','zl_wyk',_args)
               ||
                  _res:=0
               ?}
            ?}
         ?}
      ||
         _res:=0
      ?}
   ?};

   exec('blk_unlock','#table','ZGH',PROD_REJ.ZGH)

?};

Cntx.pop(ZL,ZGH,ZGP,KAP,GROP);
:: Jeżeli rejestracja od strony partii i użytkownik wyszedł z selekcji pracownika/brygady to zawracam -1, żeby nie
:: wyświetlać komunikatu błędu
{? VAR1.KN3='N' & _no_error>0
|| _res:=-1
?};
_res


\add_akord
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Dodaje rekord/rekordy ZLGD/ZLGB wg zadanych kryteriow
::       Dzialanie:
::       - jezeli podany ZGH, a brak ZGP, KAP, to zbiorcza rejestracja calego przewodnika
::       - jezeli podany ZGP, a brak KAP, to rejestracja do pozycji przewodnika
::       - jeżeli podany GROP (brak ZGH, ZGP, KAP), to rejestracja do grupy operacji
::       - jezeli podany KAP, to rejestracja do karty pracy
::   WE: _args - argumenty funkcji - wynik exec('add_akord_a','zl_wyk')
::   WY: 0 / 1 - czy operacja sie udala
::       Dodatkowo w _args.ZLGD przekazywany jest ZLGD.ref() dolaczonego rekordu
::  OLD: \add_akord/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_args:={? _=1 || _a || exec('add_akord_a','zl_wyk') ?};

_res:=0;

Cntx.psh(KAP,ZLGB,ZLGD,ZGH,ZGP,GROP,GROPS);

:: Otwieram maski zgodne z parametrami pracy
ZLGD.use(5+ZLGD.name()+ST.ODDZ+(2-form(ST.AR,-4,,'99')));
ZLGB.use(5+ZLGB.name()+ST.ODDZ+(2-form(ST.AR,-4,,'99')));
ZL_WYRGD.use(5+ZL_WYRGD.name()+ST.ODDZ+(2-form(ST.AR,-4,,'99')));

Cntx.clr(KAP,ZLGB,ZLGD,ZGH,ZGP,GROP,GROPS);
_cntx_pop:="Cntx.pop(KAP,ZLGB,ZLGD,ZGH,ZGP,GROP,GROPS)";

:: Sprawdzic zgodnosc ZGH i ZGP
{? _args.ZGH<>null() & _args.ZGP<>null()
|| {? ZGP.seek(_args.ZGP)
   || {? ZGP.NRZLP<>_args.ZGH
      || FUN.info('Niezgodność przekazanych danych — nagłówek i pozycja przewodnika.'@);
         _cntx_pop();
         return(0)
      ?}
   ?}
?};

:: Sprawdzic zgodnosc GROP i GROPS
{? _args.GROP<>null() & _args.GROPS<>null()
|| {? GROPS.seek(_args.GROPS)
   || {? GROPS.GROP<>_args.GROP
      || FUN.info('Niezgodność przekazanych danych — grupa operacji i zasób.'@);
         _cntx_pop();
         return(0)
      ?}
   ?}
?};
:: Sprawdzic zgodnosc KAP z ZGP
{? _args.KAP<>null() & _args.ZGP<>null()
|| {? KAP.seek(_args.KAP)
   || {? KAP.ZGP<>_args.ZGP
      || FUN.info('Niezgodność przekazanych danych — karta pracy i pozycja przewodnika.'@);
         _cntx_pop();
         return(0)
      ?}
   ?}
?};

:: pracownik/brygada z karty pracy, ilosci domyslnie z karty pracy, ale mozna zmienic
:: Kontekst tabel zrodlowych: KAP ustawione juz wczesniej
{? _args.KAP<>null()
|| {? KAP.seek(_args.KAP)
   || KAP.ZGP(); KAP.ZGH(); ZGH.ZLEC()
   || _cntx_pop();
      return(0)
   ?}

:: pracownik/brygada do wyboru, ilosci domyslnie z pozycji przewodnika, ale mozna zmienic
|? _args.ZGP<>null()
|| {? ZGP.seek(_args.ZGP)
   || ZGP.NRZLP(); ZGH.ZLEC()
   || _cntx_pop();
      return(0)
   ?}

:: grupa operacji
|? _args.GROPS<>null()
|| {? GROPS.seek(_args.GROPS)
   || GROPS.GROP()
   || _cntx_pop();
      return(0)
   ?}

|| _cntx_pop();
   return(0)
?};

'-*-e-kioski-*-';
{? VEK.TERM='T' | VAR1.ZAK_EK='T'
|| _ref:=exec('findZlgdZ','ekioski',_args.ZGP,_args.P,_args.ZLBR,_args.GROPS);
:: Dla operacji z czasem tylko maszynowycm czyścimy pracownika i brygadę
   {? _ref<>null() & _args.ZGP<>null() & exec('FindAndGet','#table',ZGP,_args.ZGP,,"ZGP.NTIME=0",0)
   || _args.P:=null(); _args.ZLBR:=null()
   ?}
|| _ref:=null()
?};
_add:=1;
{? _ref
||
   {? ref_name(_ref)<>ZLGD.name()
   || ZLGD.use(ref_name(_ref));
      ZLGB.use((5+ZLGB.name())+(ZLGD.name()+3));
      ZL_WYRGD.use((5+ZL_WYRGD.name())+(ZLGD.name()+3))
   ?};
   ZLGD.clear();
   {? ZLGD.seek(_ref)
   || _add:=0
   ?}
?};
{? _add
|| ZLGD.blank(1)
?};
{? _args.GROP<>null() | _args.GROPS<>null()
|| ZLGD.GROP:=_args.GROP;
   ZLGD.GROPS:=_args.GROPS;
   ZLGD.BP:={? _args.ZLBR<>null() || 'B' || 'P' ?}
|| ZLGD.ZL:=ZL.ref();
   ZLGD.ZGH:=ZGH.ref();
   ZLGD.ZGP:=ZGP.ref();
   ZLGD.BP:={? ZGP.BRYG='T' || 'B' || 'P' ?}
?};
ZLGD.B:=_args.ZLBR;
ZLGD.P:=_args.P;
ZLGD.DT:=_args.DT;
ZLGD.O:=_args.OKR;
ZLGD.IL_N:=0;      'ilosc nominalna';
ZLGD.TIME:=0;      'czas rzeczywisty';
ZLGD.IL:=0;        'ilosc rzeczywista';
ZLGD.IL_BRAK:=0;
ZLGD.DEK_IL:=0;
ZLGD.DEK_BR:=0;
ZLGD.ST:=0;        'stawka rzeczywista';
ZLGD.KW:=0;        'kwota rzeczywista';
ZLGD.WYD:=_args.WYD;
ZLGD.PLNX:=0;      'placa na XJM';
ZLGD.PLNH:=0;      'placa na godzine';
ZLGD.NTIME:=0;     'norma czasowa';
ZLGD.TIME_P:=0;    'czas kalkulowany';
ZLGD.ILGEN:=0;     'ilosc w raportach';
ZLGD.R:=_args.R;
ZLGD.KAP:=_args.KAP;
ZLGD.PLACE:=_args.PLACE;
ZLGD.STAT_B:=_args.STAT_B;
'-*-e-kioski-*-';
:: NUCO - ustalenie wydziału na podstawie miejsca wykonania - stanowiska i jego przydziału
{? _args.PLACE<>null()
|| ZLGD.WYD:=exec('szukaj_ud_skl','schemat','PODZORG',ZLGD.PLACE().WYD().KOD)
?};


{? _add & _args.STARTD<>date(0,0,0)
|| ZLGD.STARTD:=exec('get','daty',_args.STARTD);
   ZLGD.STARTT:=_args.STARTT
?};
ZLGD.ENDD:=exec('get','daty',_args.ENDD);
ZLGD.ENDT:=_args.ENDT;
{? _args.ZMIANA='C' & ZLGD.STARTD<>null()
|| ZLGD.ZMIANA:=exec('zmiana_czasowo','zl_common',ZLGD.STARTD().DATA,ZLGD.STARTT,ZLGD.ENDD().DATA,ZLGD.ENDT)
|? _args.ZMIANA<>'' & _args.ZMIANA<>'C'
|| ZLGD.ZMIANA:=_args.ZMIANA
|? ZLGD.ZMIANA=''
|| ZLGD.ZMIANA:=exec('zmiana','zl_common',{? _args.STARTD=date(0,0,0) || time() || _args.STARTT ?})
?};
ZLGD.AUTO:=_args.AUTO;
ZLGD.PL_WYK:=_args.PL_WYK;
ZLGD.ZLGD_SRC:=_args.ZLGD_SRC;
ZLGD.USER:=OPERATOR.USER;
ZLGD.OK:=_args.OK;
{? VAR1.REJ_WYR='T'
||
:: Jeżeli rejestraja do wielu wyrobów to na zapisie robocizny nie ma partii - partie rozpisane na zapisach ZL_WYRGD
   ZLGD.ZPARN:=null()
|| ZLGD.ZPARN:=_args.ZPARN
?};
{? ZLGD.ZGP<>null()
|| ZLGD.KOOP:={? ZGP.WEW='T' || 'N' || 'T' ?};
   {? ZGP.KJ_BAD='N' || ZLGD.KJ_DONE:='N' || ZLGD.KJ_DONE:='P' ?};
   ZLGD.KJ_NEED:={? ZLGD.KJ_DONE='P' || 'T' || 'N' ?}
?};
'-*-e-kioski-*-';
ZLGD.ZAK:=_args.ZAK;
ZLGD.POTW:='N';

:: Wyliczenie pol analogicznie jak przy redagowaniu akordu
exec('wylicz_zlgd','zl_wyk');
:: Wyliczenie pozostalych pol, rozpisanie skladu brygady (ZLGB - jezeli wymagane)
VAR1.IL:=_args.IL;
VAR1.IL_BRAK:=_args.IL_BRAK;
VAR1.BRAKI_R:=_args.BRAKI_R;
{? _args.IL_DEKL='T'
|| ZLGD.DEK_IL:=VAR1.IL;
   ZLGD.DEK_BR:=VAR1.IL_BRAK;
   ZLGD.DEK_RBR:=_args.BRAKI_R
|| ZLGD.IL:=VAR1.IL;
   ZLGD.IL_BRAK:=VAR1.IL_BRAK;
   ZLGD.BRAKI_R:=_args.BRAKI_R
?};
{? _args.TIME<>0
|| ZLGD.TIME:=_args.TIME
|? ZLGD.STARTD<>null() & ZLGD.ENDD<>null() & exec('get','#params',500644)='T'
|| ZLGD.TIME:=(exec('create','#tm_stamp',ZLGD.ENDD().DATA,ZLGD.ENDT)
               -exec('create','#tm_stamp',ZLGD.STARTD().DATA,ZLGD.STARTT))/exec('hour','#tm_stamp')
|| ZLGD.TIME:=ZLGD.TIME_P
?};
exec('zlgd_kw','zl_wyk');
:: Zapis dla grupy operacji akceptowany bezwarunkowo
{? _args.GROP<>null() | exec('po_zg_is','zl_wyk','add_akord')
|| '-*-e-kioski-*-';
   {? do_state()
   || {? {? _add || ZLGD.add() || ZLGD.put() ?}
      || _args.ZLGD:=ZLGD.ref();
         '-*-e-kioski-*-';
         {? ZLGD.ZAK='T' & _args.GROP=null()
         || exec('zlgb_se1','zl_wyk')
         ?};
::       Utworzenie zapisów robocizny w rozbiciu na wyroby
         {? VAR1.REJ_WYR='T'
         || exec('zl_wyrgd_from_tab','zl_wyr')
         |? VAR1.KN3='N' & exec('zgp_czy_wyr','zl_wyr',ZLGD.ZGP)
         ||
::          Rejestracja wykonań od strony partii - tworzony 1 zapis zl_wyrgd na całą ilość na produkt główny zlec.
            exec('zl_wyrgd_add_main','zl_wyr')
         ?};
         _res:=1
      ?}
   || ZLGD.win_edit('RED');
      {?
::         Do testow mozna wlaczyc okno, w ktorym wyswietlane sa dane akordowe
::         ZLGD.edit("exec('chk_rec_zlgd','zl_akor1')")
         1
      || {? {? _add || ZLGD.add() || ZLGD.put() ?}
         || _args.ZLGD:=ZLGD.ref();
            '-*-e-kioski-*-';
            {? ZLGD.ZAK='T' & _args.GROP=null()
            || exec('zlgb_se1','zl_wyk')
            ?};
::          Utworzenie zapisów robocizny w rozbiciu na wyroby
            {? VAR1.REJ_WYR='T'
            || exec('zl_wyrgd_from_tab','zl_wyr')
            |? VAR1.KN3='N' & exec('zgp_czy_wyr','zl_wyr',ZLGD.ZGP)
            ||
::             Rejestracja wykonań od strony partii - tworzony 1 zapis zl_wyrgd na całą ilość na produkt główny zlec.
               exec('zl_wyrgd_add_main','zl_wyr')
            ?};
            _res:=1
         ?}
      ?}
   ?}
?};

:: Sprawdzam czy wymagany jest podział partii (par 500771)
{?  exec('get','#params',500771)='T' & VPRODREJ.AUTO='T' & _args.ZPARN<>null() & VAR1.REJ_WYR<>'T'
    & exec('FindAndGet','#table',ZL,ZLGD.ZL,,"ZL.RP='T'",0)
||
:: Wydzielenie nowej partii
   _new_ref:=exec('zparn_split','zl_wyk',ZLGD.ref(),_args.ZPARN,_args.ZGP,{? ZGP.BRYG='T' || ZLGD.B || ZLGD.P ?});
:: Przypisanie nowej partii
   {? _new_ref<>null() & _new_ref<>ZLGD.ZPARN
   ||  ZLGD.ZPARN:=_new_ref;
       ZLGD.put()
   ?}
?};

:: Zapisanie rozpiski rozliczenia surowców
{? var_pres('__ENV_REJ')>100 & __ENV_REJ.TYPE=0
|| __ENV_REJ.ZLGD:=ZLGD.ref();
   _tab:=__ENV_REJ.TAB;
   _tab.prefix();
   {? _tab.first()
   || {!
      |?
         exec('rej_mat_update','ekioski',1);
         _tab.next()
      !}
   ?};
   VAR_DEL.delete('__ENV_REJ')
?};

:: Sprawdzam czy korzystano z kontroli jakości w locie i jest to ostatnia rejestracja wykonania do danej operacji
{? _res=1 &  VAR1.KN1='T' & ( PROD_REJ.OK='T' | VPRODREJ.OK='T' | ZGP.STATUS=exec('status_end','zl_guide'))
||
:: Usuwam powiązany BADO, wiąże ZLGD z BADH
   BADH.cntx_psh();
   BADO.index('ZGP');
   BADO.prefix(VPRODREJ.PROD_REJ().ZGP);
   _first:=1;
   {? BADO.last()
   || {!
      |? {? BADVAR.BADH().AUTO<>'T'
         || {? _first=1
            || ZLGD.BADH:=BADO.BADH;
               ZLGD.KJ_NEED:='T';
               ZLGD.put();
              _first:=0
            ?}
         ?};
         {? BADO.BADH<>null()
         || BADH.cntx_psh();
            BADO.BADH();
            BADH.ZLGD:=ZLGD.ref();
            BADH.IL:=ZLGD.IL;
            BADH.IL_BRAK:=ZLGD.IL_BRAK;
            BADH.PREV_IL:=ZLGD.IL;
            BADH.PREV_BR:=ZLGD.IL_BRAK;
            BADH.put();
            BADH.cntx_pop()
         ?};
         BADO.del()
      !}
   ?};
   BADH.cntx_pop()
?};

:: Sprawdzam czy operacja wymaga przeprowadzenia badań w trakcie wykonywania operacji
{? _add
||
   '-*-e-kioski-*-';
   {? VEK.TERM='T'
   ||
::     Jak e-kiosk to tworzę badanie podczas staru operacji
      _bad_op:=exec('FindAndGet','#table',ZGP,ZLGD.ZGP,,"ZGP.BAD_OP",null());
      {? _bad_op<>null()
      ||
::       Tworzę badanie
         _badh:=exec('BADH_add_new','statexam',null(),_bad_op,0,,,,ZLGD.ZGP,1);
         {? _badh<>null()
         || ZLGD.BAD_OP:=_badh;
            ZLGD.put();
            BADH.cntx_psh();
            ZLGD.BAD_OP();
            BADH.ZLGD:=ZLGD.ref();
            BADH.TYP:='C';
            BADH.AUTO:='N';
            {? VEK.TERM<>'T'
            || BADH.STAN:='W'
            ?};
            BADH.put();
            BADH.cntx_pop()
         ?}
      ?}
   ||
      {? var_pres('__ENV_BAD')>100
      ||
::       Wyniki badania zarejestrowane podczas rejestracji wykonania produkcji w ERP
         _env:=__ENV_BAD;
         _tmp:=_env.TAB;
         BADSEH.cntx_psh();
         BADSEH.clear();
         {? BADSEH.seek(_env.BADSEH)
         ||
::          Tworzę badanie
            _badh:=exec('BADH_add_new','statexam',null(),BADSEH.ref(),0,,,,ZLGD.ZGP,1);
            {? _badh<>null()
            || BADP.cntx_psh();
               BADP.index('BADHBPAR');
               BADP.prefix(_badh);
::             Usuwam nadmiarowe parametry
               {? BADP.first() & VAR1.KN3<>'N'
               || {!
                  |?
                     {? ~_tmp.find_tab(,'PARREF',,'=',$BADP.BADPAR)
                     || _loop:=BADP.del(,1)=2
                     || _loop:=BADP.next()
                     ?};
                     _loop
                  !}
               ?};
::             Uzupełniam wartości parametrów
               _tmp.cntx_psh();
               _tmp.clear();
               {? _tmp.first() & VAR1.KN3<>'N'
               ||
                  {!
                  |?
                     _badpar:=exec('FindAndGet','#table',BADPAR,_tmp.PARREF,,,null());
                     {? _badpar<>null()
                     || _add:=1;
                        BADP.blank();
                        {? BADP.find_tab(,'BADPAR',,'=',_badpar)
                        || _add:=0
                        ?};
                        BADP.BADH:=_badh;
                        BADP.BADMSEP:=null();
                        BADP.BADPAR:=_badpar;
                        BADP.WAR:=_tmp.WAR;
                        BADP.VALUE:=_tmp.VALUE;
                        BADP.MAD_DT:=date();
                        BADP.MAD_TM:=time();
                        BADP.MAD_USER:=OPERATOR.USER;
                        {? _add>0
                        || BADP.add(1)
                        || BADP.put(1)
                        ?}
                     ?};
                     _tmp.next()
                  !}
               ?};
               _tmp.cntx_pop();
               BADP.cntx_pop();
::             Przypinam badanie(BADH) do robocizny(ZLGD), i zapis robocziny do badania
               ZLGD.BAD_OP:=_badh;
               ZLGD.put();
               BADH.cntx_psh();
               ZLGD.BAD_OP();
               BADH.ZLGD:=ZLGD.ref();
               BADH.TYP:='C';
               BADH.AUTO:='N';
               BADH.STAN:='W';
               BADH.MAD_DT:=date();
               BADH.MAD_TM:=time();
               BADH.MAD_USER:=OPERATOR.USER;
               BADH.put();
               BADH.cntx_pop()
            ?}
         ?};
         VAR_DEL.delete('__ENV_BAD');
         BADSEH.cntx_pop()
      ?}
   ?}
||
   '-*-e-kioski-*-';
:: Sprawdzam czy było utworzone badanie przy starcie operacji i aktualizuje je
   BADH.cntx_psh();
   BADH.index('TZLGD');
   BADH.prefix('C',ZLGD.ref(),ref_name(ZLGD.ref()));
   {? BADH.first()
   || BADH.STAN:='W';
      BADH.MAD_DT:=date();
      BADH.MAD_TM:=time();
      BADH.MAD_USER:=OPERATOR.USER;
      BADH.put()
   ?};
   BADH.cntx_pop()
?};
_cntx_pop();
_zl_ref:=exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"ZL",null());
_zl_uid:=exec('FindAndGet','#table',ZL,_zl_ref,,"uidref()",'');

:: Obsługa procesowości (tylko gdy nie ma transakcji/triggera, nie jest to grupa operacji,
:: i jest uprawnienie do TTE_WYK_DWZL) może powodować popchnięcie/wzbudzenie procesów zawierających tę czynność
{? _res=1
   & _args.GROP=null()
   & do_state()=0
   & exec('chk_role','#b__box',OPERATOR.USER,'TTE_WYK_DWZL')
||
:: Nie jest to start operacji
   {? exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"ZAK='T'",0)
   || _arg:=exec('mp_run_a','#b__box');
      _arg.ACT_UID:='TTE_WYK_DWZL';
      _arg.UIDREF:=_zl_uid;
      _arg.AKCJA:='ZAKOŃCZ';
      _arg.PORTS_IN:=exec('portsIn','#b__box',_arg.ACT_UID);
      _arg.PROC_START:='T';
      _arg.CONTEXT:=obj_new('ZLGD','ZGP','ILOSC','BRAKI');
         _arg.CONTEXT.ZLGD:=_args.ZLGD;
         _arg.CONTEXT.ZGP:=exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"ZGP",null());
         _arg.CONTEXT.ILOSC:=exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"IL",0);
         _arg.CONTEXT.BRAKI:=exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"IL_BRAK",0);
      exec('portsInSet','#b__box',_arg.PORTS_IN,_arg.ACT_UID,'ZL',_zl_ref);

      exec('mp_run','#b__box',_arg)

:: Start operacji
   || _arg:=exec('mp_run_a','#b__box');
      _arg.ACT_UID:='TTE_WYK_DWZL';
      _arg.UIDREF:=_zl_uid;
      _arg.AKCJA:='ROZPOCZNIJ';
      _arg.PORTS_IN:=exec('portsIn','#b__box',_arg.ACT_UID);
      _arg.PROC_START:='T';
      _arg.CONTEXT:=obj_new('ZLGD','ZGP');
         _arg.CONTEXT.ZLGD:=_args.ZLGD;
         _arg.CONTEXT.ZGP:=exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"ZGP",null());

      exec('portsInSet','#b__box',_arg.PORTS_IN,_arg.ACT_UID,'ZL',_zl_ref);

      exec('mp_run','#b__box',_arg)
   ?}
?};

{? _res=1 & VAR1.IL_BRAK>0
|| exec('desc_update','#b__box',_zl_uid,'TTE_PZL_DGBR')
?};

_res


\zparn_split
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Wydziela nową partię po zarejestrowaniu wykonania produkcji (funkcjonalność dla parametru 500771)
::       _a - ZLGD.ref() - utworzony zapis robocizny
::       _b - ZPARN.ref() - dzielona partia
::       _c - ZGP.ref()
::       _d - ZLBR.ref()/P.ref() - pracownik/brygada rejestrujący wykonanie
::   WY: ZPARN.ref() lub null(), gdy partia nie powstała
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;
_zparn:=_b;
_zgp:=_c;
_pb:=_d;
_new_ref:=null();
_result:=1;
_il:=0;
ZGP.cntx_psh();
{? VAR1.REJ_WYR<>'T'
|| ZLGD.cntx_psh();
   ZLGD.index('ZPARN');
   ZLGD.prefix(_zparn,_zgp);
   {? ZLGD.first()
   || {!
      |?
::       Jeżeli do tej samej partii inna osoba zarejestrowała wykonanie to trzeba podzielić partię
         {? ZLGD.ZGP().BRYG='T'
         || {? ZLGD.B<>_pb || _result:=0 ?}
         || {? ZLGD.P<>_pb || _result:=0 ?}
         ?};
         {? ZLGD.ref()<>_ref || _il+=ZLGD.IL+ZLGD.DEK_IL+ZLGD.IL_BRAK+ZLGD.DEK_BR ?};
         ZLGD.next()
      !}
   ?};
   ZLGD.cntx_pop()
|| ZLGD.cntx_psh();
   ZL_WYRGD.cntx_psh();
   ZL_WYRGD.index('ZPARN');
   ZL_WYRGD.prefix(_zparn,_zgp);
   {? ZL_WYRGD.first()
   || {!
      |?
         ZL_WYRGD.ZLGD();
::       Jeżeli do tej samej partii inna osoba zarejestrowała wykonanie to trzeba podzielić partię
         {? ZLGD.ZGP().BRYG='T'
         || {? ZLGD.B<>_pb || _result:=0 ?}
         || {? ZLGD.P<>_pb || _result:=0 ?}
         ?};
         {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T'
         || _il+=ZL_WYRGD.IL+ZL_WYRGD.IL_BRAK
         || _il+=ZL_WYRGD.DEK_IL+ZL_WYRGD.DEK_BR
         ?};
         ZL_WYRGD.next()
      !}
   ?};
   ZL_WYRGD.cntx_pop();
   ZLGD.cntx_pop()
?};

:: NUCO - zmiana
:: Wydzielenie partii podczas rejestracji wykonania produkcji wg parametru wdrożeniowego - jeśli '' to działanie std
{? OPERATOR.EKIOSK<>null()
|| _czy_dzielic:=exec('get_w','#params',9980,2,OPERATOR.EKIOSK)
|| _czy_dzielic:=''
?};
:: Zapamiętanie ilości zarejestrowanej na partii
_il_zarej:=_il;
{? _czy_dzielic<>'' & (VAR1.IL-_il)>0
|| {? _czy_dzielic='P'
   || {? FUN.ask('Czy po rejestracji wykonania wydzielić nową partię na ilość pozostałą do wykonania ?')
      || _result:=0
      || _result:=1
      ?}
   |? _czy_dzielic='N'
   || _result:=1
   |? _czy_dzielic='T'
   || _result:=0
   ?}
?};

:: Wydzielam nową partię na ilość pozostałą
{? _result=0 & _czy_dzielic=''
||
   _zparn_il:=exec('FindAndGet','#table',ZPARN,_zparn,,"IL",0);
   _zparn_ilw:=exec('get_ilosc_rp','zl_partie',_zparn);
   _il_dorej:=_zparn_il-_zparn_ilw;
   {? _il_dorej<_il || _il:=_il_dorej ?};
   {? _il>0
   || {? exec('split','zl_partie',_zparn,_il,0)
      ||
::       znalezienie refa nowo utworzonej partii
         ZPARN.cntx_psh();
         _srcid:=exec('FindAndGet','#table',ZPARN,_zparn,,"IDADD",0);
         ZPARN.index('IDSRC_ID');
         ZPARN.prefix(_srcid);
         {? ZPARN.last() || _new_ref:=ZPARN.ref() ?};
         ZPARN.cntx_pop()
      ?}
   ?}
:: NUCO - podział wg zasad NUCO (dodajemy do istniejącej poartii i dopiero wydzielamy
|? _result=0 & (_czy_dzielic='T'|_czy_dzielic='P')
|| _zparn_il:=exec('FindAndGet','#table',ZPARN,_zparn,,"IL",0);
   {? _zparn_il>VAR1.IL+_il_zarej
   || _il:=VAR1.IL+_il_zarej;
      exec('split','zl_partie',_zparn,_il,0)
   ?}
?};
:: Koniec zmian

ZGP.cntx_pop();

_new_ref

