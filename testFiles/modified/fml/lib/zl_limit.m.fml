:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: zl_limit.fml
:: Utworzony: 25.06.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Obsługa zapotrzebowań do zlecenia - limity, odpady i surowce nielimitowane.
::            Funkcje wspólne z wyłączeniem dedykowanych TYLKO dla odpadów i surowców nielimitowanych
::            Plik biblioteczny - wspólna obsługa dla czynności obszaru roboczego TTE_PZL
::            UWAGA !!! PLIK ZAPEŁNIONY, NIE DODAWAĆ NOWYCH FORMUŁ !!!
::======================================================================================================================


\__ZLIMp_prepare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [2011]
:: OPIS: Generuje tabelę pomocniczą, która służy do podglądu limitów
::   WY: _tab - wskaźnik na tabelę pomocniczą
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(3
             ,'PARENT'  ,'TREE_REF'   ,'Zapis nadrzędny'
             ,'KTM'     ,'STRING[50]' ,'Kod materiału/zlecenie'
             ,'NR'      ,'INTEGER'    ,'Numer kolejny'
             ,'M_REF'   ,'INTEGER'    ,'#M.ref()'
             ,'N'       ,'STRING[100]','Nazwa materiału'
             ,'J'       ,'STRING[10]' ,'Jednostka miary'
             ,'LIL'     ,'REAL'       ,'Ilość limitowana'
             ,'ALIL'    ,'REAL'       ,'Po korektach'
             ,'PFAZ'    ,'STRING[10]' ,'Faza produkcji'
             ,'SO'      ,'STRING[1]'  ,'Odpad/Surowiec'
             ,'M_R'     ,'STRING[1]'  ,'Rodzaj surowca'
             ,'AKC'     ,'STRING[1]'  ,'Akceptacja'
             ,'REF'     ,'STRING[16]' ,'$ZLIM.ref()'
             ,'REF_NR'  ,'INTEGER'    ,'#ZLIM.ref()'
             ,'KOR'     ,'INTEGER'    ,'Zapis korygowany'
             ,'AUTO'    ,'STRING[1]'  ,'Zapis automatyczny'
             ,'ZLEC'    ,'STRING[20]' ,'Symbol zlecenia'
             ,'ZL_REF'  ,'INTEGER'    ,'#ZL.ref() zlecenia'
             ,'ZLECDOD' ,'STRING[20]' ,'Dodatkowe zlecenie'
             ,'ZLD_REF' ,'INTEGER'    ,'#ZL.ref() zlecenia dodatkowego'
             ,'WYD'     ,'STRING[8]'  ,'Wydział'
             ,'WYD_REF' ,'INTEGER'    ,'#SLO.ref()'
             ,'PARTIA'  ,'STRING[1]'  ,'Czy partiowany?'
             ,'DT'      ,'DATE'       ,'Data akceptacji'
             ,'AKCU'    ,'STRING[30]' ,'Kto akceptował?'
             ,'S'       ,'REAL'       ,'S - stan'
             ,'SD'      ,'REAL'       ,'SD - stan dostępny'
             ,'SRT'     ,'REAL'       ,'SRT - rezerwacje tymczasowe'
             ,'SRR'     ,'REAL'       ,'SRR - rezerwacje do zamówień'
             ,'SSZ'     ,'REAL'       ,'SSZ - zamówienia'
             ,'WDR'     ,'REAL'       ,'WDR - w drodze'
             ,'ZLIM_POB','REAL'       ,'Pobrano'
             ,'ZK_P_ZRE','REAL'       ,'Zrealizowano'
             ,'SR'      ,'REAL'       ,'Zarezerwowano'
             ,'SRC'     ,'REAL'       ,'Rezerwacje oczekujace'
             ,'ZM'      ,'STRING[1]'  ,'Znacznik: [Z]lecenie czy [M]ateriał'
             ,'X_KIND'  ,'STRING[1]'  ,'Rodzaj rekordu'
             ,'LIMIT'   ,'STRING[1]'  ,'Limit?'
             ,'ZK_P_NAM','STRING[10]' ,'ZK_P.name()'
             ,'ZK_P_REF','INTEGER'    ,'#ZK_P.ref()'
             ,'ZK_P_QRF','STRING[16]' ,'$ZK_P.ref()'
             ,'MAG'     ,'STRING[8]'  ,'Magazyn'
             ,'MAG_REF' ,'INTEGER'    ,'#MG.ref()'
             ,'STARTD'  ,'DATE'       ,'Data zapotrzebowania'
             ,'STARTT'  ,'TIME'       ,'Godzina zapotrzebowania'
             ,'NRPRZ'   ,'STRING[20]' ,'Numer przewodnika'
             ,'ZGH_REF' ,'INTEGER'    ,'#ZGH.ref()'
             ,'NRP'     ,'INTEGER'    ,'Numer pozycji przewodnika'
             ,'ZGP_REF' ,'INTEGER'    ,'#ZGP.ref()'
             ,'X_COLOR' ,'STRING[20]' ,'Kolor'
             ,'X_ICON'  ,'STRING[30]' ,'Ikona'
             ,'PREF'    ,'INTEGER'    ,'#__zlim.ref()'
             ,'CRC'     ,'INTEGER'    ,'ZLIM.crc()'
             ,'OLD'     ,'STRING[1]'  ,'ZLIM.OLD'
             ,'RW_ZW'   ,'STRING[1]'  ,'Są pobrania zwroty'
             ,'ZKP_REA' ,'STRING[1]'  ,'Są realizacje zam. wew.'
             ,'ZKP_ZL'  ,'STRING[1]'  ,'Są zlec. do zam. wew.'
             ,'RTMAT'   ,'STRING[16]' ,'$TMAT.ref()'
             ,'ROZ'     ,'STRING[1]'  ,'Rozliczany z operacją'
             ,'IL'      ,'REAL'       ,'Ilość do rozliczenia (tylko gdy ROZ=T)'
             ,'ZPARN'   ,'STRING[16]' ,'$ZPARN.ref'
             ,'PARSYM'  ,'STRING[25]' ,'Symbol partii'
             ,'ZL4MAG'  ,'STRING[20]' ,'Zlecenie półfabr.'
             ,'TMAT_MAG','STRING[1]'  ,'Półfabr. z magazynu?'
             ,'RSC'     ,'STRING[16]' ,'Ref dostawy ($SC.ref)'
             ,'SCEAN'   ,'STRING[30]' ,'Kod identyfikujący dostawę'
             ,'EANL'    ,'STRING[16]' ,'Lokalizacja ($EANL.ref)'
             ,'REJ_MAT' ,'STRING[1]'  ,'Czy pozycja utworzona na podstawie rozpiski REJ_MAT'
             ,'CZY_REZ' ,'INTEGER'    ,'Czy pozycja posiada dedykowane rezerwacje (nielimity)'
             ,'GROP_REF','INTEGER'    ,'#GROP.ref() grupy operacji'
             ,'KODPAL'  ,'STRING[30]' ,'Kod palety'
             );

:: użytkownik specjalny może dołączać kolumny, bo może chce wiedzieć co tam jest.
{? sec_superuser()>0 || _tab.fld_attr(,2) ?};

_tab.fld_attr('PARTIA',3);
_tab.fld_attr('S',3);
_tab.fld_attr('SD',3);
_tab.fld_attr('SRT',3);
_tab.fld_attr('SRR',3);
_tab.fld_attr('SSZ',3);
_tab.fld_attr('WDR',3);
_tab.fld_attr('DT',3);
_tab.fld_attr('AKCU',3);
_tab.fld_attr('ZLECDOD',3);
_tab.fld_attr('MAG',3);
_tab.fld_attr('PFAZ',3);
_tab.fld_attr('STARTD',3);
_tab.fld_attr('STARTT',3);
_tab.fld_attr('ZL4MAG',3);

::@@@@@tmp
_tab.fld_attr('X_ICON',3);
_tab.fld_attr('X_KIND',3);
_tab.fld_attr('SO',3);
_tab.fld_attr('M_R',3);
_tab.fld_attr('ZM',3);
::@@@@@tmp

:: NUCO - możliwość sumowania kolumny ZLIM_POB
_tab.fld_attr('ZLIM_POB',0,3);

:: jak zera w kolumnach, to czyścimy, żeby ładniej wyglądało
_tab.fld_fml('LIL',     'DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
_tab.fld_fml('ALIL',    'DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
_tab.fld_fml('S',       'DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
_tab.fld_fml('SD',      'DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
_tab.fld_fml('SRT',     'DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
_tab.fld_fml('SRR',     'DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
_tab.fld_fml('SSZ',     'DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
_tab.fld_fml('WDR',     'DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
_tab.fld_fml('ZLIM_POB','DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
_tab.fld_fml('ZK_P_ZRE','DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
_tab.fld_fml('SR',      'DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
_tab.fld_fml('SRC',     'DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");

_tab.fld_fml('STARTD',  'DISPLAY_FORMAT',"{? fld()=date(0,0,0) || 'empty=1' || 'empty=0' ?}");
_tab.fld_fml('STARTT',  'DISPLAY_FORMAT',"{? cur_tab(1,1).STARTD=date(0,0,0) || 'empty=1' || 'empty=0' ?}");

:: kolorowanie pól
_tab.fld_fml('STARTD',  'BEFORE_DISPLAY',"exec('zlim_fld_bd','zl_limit')");
_tab.fld_fml('STARTT',  'BEFORE_DISPLAY',"exec('zlim_fld_bd','zl_limit')");

:: teraz tablica pomocnicza (docelowo zastapi __ZLIM, bedzie __ZLIMp.ZLIM
:: dawniej: _tabp:=obj_new(15);
_tabp:=obj_new(
   'ZLIM','ZL','View','actE','actN',
   'hidE','hidN','WERP','WERW','F_poz','F_del',
   'defE','defN','Limit','A_edit','F_root',
   'ZGH','ZGP','GRPP','GRPW','WP','REJ_MAT','GROP'
);

:: [1] Wskazanie na tabele tymczasowa __ZLIM
_tabp.ZLIM:=_tab;

:: [2] ref zlecenia, z ktorego spogladamy na limity (ZL.ref())
_tabp.ZL:=null();

:: [3] tylko podglad? 1/0
_tabp.View:=0;

:: [4] dolaczone akcje dla pustej dziedziny
_tabp.actE:='';

:: [5] dolaczone akcje dla niepustej dziedziny
_tabp.actN:='';

:: np. gdy tylko widok, akceptacja i inne beda niedostepne (zamiast __zlim_hid)
:: [6] domyslnie wylaczone akcje dla pustej dziedziny
_tabp.hidE:='';

:: [7] domyslnie wylaczone akcje niepuste
_tabp.hidN:='';

:: [8a] zeby nie szukac, to akronim okienka prostego (wstawiane do okna grupowego albo zakładek) dla produkcyjnych
_tabp.WERP:='';

:: [8a] zeby nie szukac, to akronim okienka prostego (wstawiane do okna grupowego albo zakładek) dla warsztatowych
_tabp.WERW:='';

:: [9] FORMULA okreslajaca pozycje (np. przy usuwaniu)
_tabp.F_poz:="'('+ZLIM.KTM().KTM+') '+ZLIM.KTM().N";

:: [10] FORMULA do usuniecia pozycji z potomnymi
_tabp.F_del:="
   _tab:=.ZLIM;
   _tab_del:=.F_del;
   _tab_ref:=#_tab.ref();
   _tab.cntx_psh();
   _tab.clear();
   _tab.prefix(_tab_ref);
   {? _tab.first()
   || {!
      |? _tab_del();
         _tab.first()
      !}
   ?};
   _tab.cntx_pop();
   _ref:=_tab.PARENT;
   _kor:=_tab.KOR;
   {? _tab.del(,1)
   ||
      _tab.cntx_psh();
      _tab.clear();
      {? _tab.seek(_ref,)
      || _ref:=#_tab.ref();
         _tab.cntx_psh();
         _tab.prefix(_ref);
         _ok:=~_tab.first() & _tab.PARENT=0 & _kor=0;
         _tab.cntx_pop();
         {? _ok || _tab.del() ?}
      ?};
      _tab.cntx_pop();
      ~~
   ?};
   ~~
";

:: [11] dostepne domyslne akcje okienka dla pustej dziedziny - kolejnosc MA znaczenie
_tabp.defE:='';

:: [12] dostepne domyslne akcje okienka dla niepustej dziedziny - kolejnosc MA znaczenie
_tabp.defN:='';

:: [13] Limity, NieLimity, Wszystko?
_tabp.Limit:='T';

:: [14] Dostepne akcje redakcyjne (Dołącz Popraw Usuń kOrekta Akceptuj wYcofaj
_tabp.A_edit:='N';

:: [15] Formula na dodanie korzenia do _tabp[1]
_tabp.F_root:="0";

:: [16] ref przewodnika, z ktorego spogladamy na limity (ZGH.ref())
_tabp.ZGH:=null();

:: [17] ref pozycji przewodnika, z ktorej spogladamy na limity (ZGP.ref())
_tabp.ZGP:=null();

:: [18a] żeby nie szukać, to akronim okienka grupowego dla produkcyjnych
_tabp.GRPP:='';

:: [18b] żeby nie szukać, to akronim okienka grupowego dla warsztatowych
_tabp.GRPW:='';

:: [19] żeby nie szukać, to czy widok zleceń produkcyjnych, czy warsztatowych
_tabp.WP:='P';

:: [20] Uwzględniać rozpiskę rozliczeń surowców do operacji (tabela REJ_MAT)
_tabp.REJ_MAT:='N';

:: [21] ref grupy operacji, z ktorej spogladamy na limity (GROP.ref())
_tabp.GROP:=null();

:: a teraz przekazujemy wynik
_tabp


\GetChildVals
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [2011]
:: OPIS: sumuje wartości z poziomów potomnych
::   WE: _a - wskazanie na __ZLIM, gdy nie ma, to __ZLIMp
::       _b - __ZLIM.ref() rodzica lub aktualny __ZLIM
::      [_c] - wykonuj obliczenia
::      [_d] - INTEGER - 0/[1] - odświeżaj ilość pobraną
::   WY: STRING   - treść błędu
::       wynik[1] - ilość zarezerwowana
::       wynik[2] - ilość oczekująca
::       wynik[3] - ilość zrealizowana
::       wynik[4] - ilość pobrana
::       wynik[5] - symbole zamówień
::----------------------------------------------------------------------------------------------------------------------
{? _>0 & type_of(_a)=type_of(SYSLOG) || _tab:=_a
|? var_pres('__ZLIMp')>0             || _tab:=__ZLIMp.ZLIM
|? var_pres('__ZLIM')>0              || _tab:=__ZLIM
                                     || return('Nie zdefiniowano tabeli __ZLIM')
?};

_calc:={? _>2 & type_of(_c)=1 || _c || 1 ?};
_rfr_pob:=1;
{? var_pres('_d')=type_of(0)
|| _rfr_pob:=_d
?};

:: przygotowanie tablicy wynikowej
_result:=obj_new(5);
{! _ii:=1..4 |! _result[_ii]:=0!};
_result[5]:='';

:: jeśli podano ref, to ustawiamy na nim
_tab.cntx_psh();
{? _>1 & type_of(_b)=type_of(_tab.ref()) || _tab.seek(_b) ?};

_ref:=_tab.ref();

:: teraz idziemy po wszystkich podrzędnych do aktualnego
_tab.cntx_psh();
_tab.prefix(#_ref);
{? _tab.first()
|| _val:=obj_new(5);

   {!
   |? obj_del(_val);
:: NUCO - błąd STD - do zgłoszenia
      _val:=exec('GetChildVals','zl_limit',_tab,,0);
      _result[1]+=_val[1];
      _result[2]+=_val[2];
      _result[3]+=_val[3];
      _result[4]+=_val[4];
      {? _val[5]<>''
       & (_result[5]*_val[5])=0
      || _result[5]:=_result[5]+_val[5]
      ?};
      _tab.next()
   !};
   ~~
?};
_tab.cntx_pop();
M.cntx_psh();    M.clear();
SLO.cntx_psh();  SLO.clear();
ZL.cntx_psh();   ZL.clear();
ZK_P.cntx_psh(); ZK_P.clear();
ZK_N.cntx_psh(); ZK_N.clear();
REZ.cntx_psh();  REZ.clear();

:: wracamy do nadrzednego
_tab.SR:=_tab.SRC:=_tab.ZK_P_ZRE:=0;

{? _rfr_pob>0
|| _tab.ZLIM_POB:=0
?};

:: jeśli nie jest to korekta a pozycja zbiorcza, to...
{? _tab.KOR=0
 & _tab.X_KIND='P'
||
   _zkp_sym:='';
   {? _calc
   || {? _tab.ZK_P_REF
       & ZK_P.seek(_tab.ZK_P_REF,_tab.ZK_P_NAM)
       & ZK_N.seek(ZK_P.N)
      ||
         REZ.index('ZK_P');
         REZ.prefix(ZK_P.ref());
         {? REZ.first()
         || {!
            |? {? REZ.RODZ='B'
               || _tab.SR+=REZ.ILR
               |? REZ.RODZ='W'
               || _tab.SRC+=REZ.ILR
               ?};
               REZ.next()
            !}
         ?};
         _tab.ZK_P_ZRE:=ZK_P.ILZ-ZK_P.ILP;
         _zkp_sym:='`'+ZK_P.N().SYM+'@'+form(ZK_P.POZ,,,'99')+'`';
         ~~
      ?};

      {? _rfr_pob>0
      || _tmp:=exec('zlim_pob_il','zl_limit',_tab.REF);
         _tab.ZLIM_POB:=_tmp.IL;
         _tab.RW_ZW:='N';
         {? _tmp.RW<>0 | _tmp.ZW<>0
         || _tab.RW_ZW:='T'
         ?};
         obj_del(_tmp)
      ?};
      _tab.put()
   ?};
:: teraz pora na zwrócenie wyniku
   _result[1]:=_tab.SR;
   _result[2]:=_tab.SRC;
   _result[3]:=_tab.ZK_P_ZRE;
   _result[4]:=_tab.ZLIM_POB;
   _result[5]:=_zkp_sym;
   ~~

|? _tab.X_KIND='G'
 & _tab.ZM='M'
||
   _tab.SR:=_result[1];
   _tab.SRC:=_result[2];
   _tab.ZK_P_ZRE:=_result[3];
   _tab.ZLIM_POB:=_result[4];
   _tab.put()
?};

REZ.cntx_pop();
ZK_N.cntx_pop();
ZK_P.cntx_pop();
ZL.cntx_pop();
SLO.cntx_pop();
M.cntx_pop();
_tab.cntx_pop();
_result


\genlim_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Jądro funkcji dodającej limit
::       KONTEKST - Rekord TMAT, zainicjowany obiekt tpar
::   WE:  _a - ZGP.ref - lub bieżący rekord
::        _b - ZL.ref - zlecenie, do ktorego generowane sa limity
::        _c - ZL.ref - zlecenie dodatkowe na limicie
::        _d - identyfikator sekcji w KOMM
::        [_e] - REAL - współczynnik do generowania normy na limicie (domyślnie 1)
::        [_f] - INTEGER - 0/[1] - czy po dodaniu limitu automatycznie go zatwierdzić
::        [_g] - INTEGER - 0/[1] - czy po dodaniu limitu automatycznie go zarezerwować
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('genlim_args','zl_limit')
?};

_result:=0;
_can_continue:=1;
ZGP.cntx_psh();
ZLIM.cntx_psh();
ZLIM.index('ZGP_M');
_ktm:=null();
{? TMAT.GRKTM='G' || _ktm:=TMAT.TGDFLT().PT || _ktm:=TMAT.PT ?};
ZLIM.prefix(_args.ZGP,_ktm);

:: Podczytanie materiału
{? TMAT.GRKTM='G' || TMAT.TGDFLT().PT() || TMAT.PT() ?};

_tech_guid:=exec('FindAndGet','#table',ZGP,_args.ZGP,,"NRZLP().KIND='T'",0);
_rodzaj:=exec('top_rodzaj','zl_link',_args.ZL);
_is_pod:=0;
{? _rodzaj='Z'
|| ZL.cntx_psh();
   ZL.index('TREEMTU');
   ZL.prefix(#_args.ZL,_ktm);
   {? ZL.first() & exec('is_podzlec4mag','zl_link')=0
   || _is_pod:=1
   ?};
   ZL.cntx_pop()
?};

:: jak podrzędne montażowe i półfabrykatowe, technologia bez operacji (przewodnik techniczny), półfabrykat,
:: jest podzlecenie na to samo, to nie generujemy do pozycji limitów
{? _rodzaj='Z' & _tech_guid & (TMAT.KTL<>null() | TMAT.DFLT_KTL='T') & _is_pod>0
|| _can_continue:=1

|? ZLIM.size()=0
||
   _kommdel:=0;
::   _sekcja2:=KOMM.sect_beg(
::      '('+M.KTM+') '+M.N+
::      ' — '+{? M.R='P'|| 'półprodukt'@
::            |? M.R='S'|| 'surowiec'@
::                      || ''
::            ?}+
::      ' '+{? TMAT.LIMIT<>'T'|| 'nielimitowany'@ || 'limitowany'@ ?}
::   );

:: nie znalezniony?, to szybko zakladamy i blokujemy do swoich potrzeb
   ZLIM.blank(1);
   ZLIM.OLD:='N';
   ZLIM.ZLEC:=_args.ZL;
   ZLIM.LIMIT:=TMAT.LIMIT;
   ZLIM.KTM:=_ktm;
   ZLIM.ZGP:=_args.ZGP;
   ZLIM.NR:=exec('ZLIM_NR_blank','zl_limit',_args.ZL,ZLIM.LIMIT);
   ZLIM.BORNSTAT:=ZLIM.ZLEC().STAN;
   DK_C.cntx_psh();
   _dkc:=exec('create_dkc','zl_common',ZL.DK_C,TMAT.DK_C,TMAT.ATR_MASK,_ktm);
   _name:=ref_name(TMAT.DK_C);
   {? _name<>'' & _name<>DK_C.name() || DK_C.use(_name) ?};
   ZLIM.DK_C:=_dkc;
   _can_continue:=ZLIM.add(1);
   {? _can_continue>0
   ||
      {? _can_continue>0
      || {? ZLIM.LIMIT='N'
         || exec('zlim_split_fill','po_split',_args.ZGP,ZLIM.ref())
         ?}
      ?};

      ZLIM.r_lock(1,1,1);
      ZLIM.AKC:='N';
      ZLIM.AUTO:='T';
      ZLIM.ZLDOD:=_args.ZLDOD;

      ZLIM.TMAT:=TMAT.ref();
      ZLIM.PFAZ:=TMAT.PFAZ;
      ZLIM.MODE_DST:=TMAT.MODE_DST;
      ZLIM.ROZ:=TMAT.ROZ;

      ZLIM.WYD:=exec('GetZLIM_WYD','zl_limit');

      ZLIM.SO:=TMAT.SO;
::    Ustalenie magazynu
      exec('zlim_set_mg','zl_limit1',1);

      _dt:=exec('datetime','zl_limit',_args.ZGP);
      ZLIM.STARTD:=_dt.DATE;
      ZLIM.STARTT:=_dt.TIME;
      obj_del(_dt);

      ZLIM.KTM();
      _ilezl:=0;

      {? TMAT.MAG<>'P' & (TMAT.KTL<>null | TMAT.DFLT_KTL='T' | TMAT.RKTL<>'')
      || _ilezl:=exec('ilezl','zl_common',TMAT.ref(),ZLIM.ZLEC().UNRZL)
      ?};

      _dokl:=exec('jaka_dok_m','jm',ZLIM.KTM);
      {? _dokl>0
      || _rm:=roundmet();
         roundmet(2);
         {? TMAT.FORMB<>''
         || _il_raw:=tpar.calc(TMAT.FORMB)*_args.COEF;
            ZLIM.LIL:=_il_raw$_dokl-_ilezl;
            ZLIM.IL_RAW:=_il_raw-_ilezl
         || _il_raw:=TMAT.WARB*_args.COEF;
            ZLIM.LIL:=_il_raw$_dokl-_ilezl;
            ZLIM.IL_RAW:=_il_raw-_ilezl
         ?};
         roundmet(_rm)
      || {? TMAT.FORMB<>''
         || _il_raw:=tpar.calc(TMAT.FORMB)*_args.COEF;
            ZLIM.LIL:=exec('ceil','#math',_il_raw)-_ilezl;
            ZLIM.IL_RAW:=_il_raw-_ilezl
         || _il_raw:=TMAT.WARB*_args.COEF;
            ZLIM.LIL:=exec('ceil','#math',_il_raw)-_ilezl;
            ZLIM.IL_RAW:=_il_raw-_ilezl
         ?}
      ?};

:: NUCO - Dodanie zaokrąglenia jednostek typu szt. do pełnych (zawsze w górę)
      _q_lista_jm:=exec('get_w','#params',999006,type_of(''));
      {? _q_lista_jm<>''
      || {? _q_lista_jm*(','+ZLIM.KTM().J().KOD+',')>0
         || ZLIM.LIL:=ceil(ZLIM.LIL)
         ?}
      ?};

      ZLIM.PARTIA:=TMAT.PARTIA;
      _il_zero:=exec('zlim_chk4il','zl_nlimit');
      _ok:={? _il_zero>0 || 1 || ZLIM.LIL>0 ?};
      {? _ok>0
      || _can_continue:=ZLIM.put();
         {? _can_continue>0
         || {? _args.AUTO_AKC>0 & ZLIM.LIMIT='T'
            || '-*- 12.46 -*- uproszczona edycja zleceń';
               _can_continue:=exec('ZLIM_akc','zl_limit',_args.DIALOG,ZLIM.ref(),_args.ERROR,_args.CHK_LIM,_args.CHK_SPR,_args.AUTO_REZ,{? _args.TMAT || 1 || 0 ?})
            ?};
::          Jeżeli zlecenie zostało wygenerowane na podstawie stanów magazynowych to sprawdzam, czy nie było
::          robionej rezerwacji na surowiec (obsługa dedykowanych rezerwacji dla nielimitów)
            {? ZLIM.LIMIT='N' & exec('zl_from_sm','zl_head',ZLIM.ZLEC)>0
            || _tmat_src:=exec('FindAndGet','#table',TMAT,ZLIM.TMAT,,"{? SRC<>'' || SRC || $ref() ?}",'');
               REZ.cntx_psh();
               REZ.use((REZ.name()-2)+'__');
               REZ.index('ZLMREZ');
               REZ.prefix(ZLIM.ZLEC,'S','B',ZLIM.KTM,'T',_tmat_src);
               {? REZ.first()
               || _dorozp:=ZLIM.LIL;
                  {!
                  |?
                     {? REZ.ILR<=_dorozp
                     ||
::                      Cała rezerwacja zmienia się na dedykowaną rezerwację na nielimity
                        _ilr:=REZ.ILR;
                        REZ.ZL_REZ:='P';
                        REZ.REFREA:='';
                        REZ.REFSQL:=REZ.ZLIM:=$ZLIM.ref();
                        REZ.ZGP:=$ZLIM.ZGP;
::                        REZ.DODT:=date()+365;
                        REZ.DODT:=date(0,0,0);
                        REZ.BTERM:='T';
                        REZ.cntx_psh();
                        REZ.prefix();
                        {? REZ.put()
                        || _dorozp-=_ilr
                        ?};
                        REZ.cntx_pop()
                     ||
::                      Wydzielenie części z rezerwacji
::                      Zmniejszenie ilości z rezerwacji źródłowej
                        _ilr:=_dorozp;
                        REZ.ILR-=_ilr;
                        {? REZ.put()
                        ||
::                         Dodanie nowej rezerwacji dedykowanej na nielimity
                           REZ.ZL_REZ:='P';
                           REZ.REFREA:='';
                           REZ.REFSQL:=REZ.ZLIM:=$ZLIM.ref();
                           REZ.ZGP:=$ZLIM.ZGP;
::                           REZ.DODT:=date()+365;
                           REZ.DODT:=date(0,0,0);
                           REZ.BTERM:='T';
                           REZ.ILR:=_ilr;
                           REZ.cntx_psh();
                           REZ.prefix();
                           {? REZ.add()
                           || _dorozp-=_ilr
                           ?};
                           REZ.cntx_pop()
                        ?}
                     ?};
                     _dorozp>0 & REZ.first()
                  !}
               ?};
               REZ.cntx_pop()
            ?};
::            KOMM.update(_sekcja2,,38,'0:200:0');
            _args.KOMMEMPT:=0;
            ZLIM.r_unlock();
            '-*- 12.46 -*- uproszczona edycja zleceń';
            {? _args.TMAT
            || exec('add__zlim','zl_limit')
            ?}
         || ZLIM.r_unlock();
::            KOMM.update(_sekcja2,,81,'200:0:0');
            _what:=exec('M','#to_string',_ktm);
            _msg:='Podczas tworzenia limitu na: %1 wystąpił błąd - limit nie został wygenerowany.'@[_what];
            {? _args.DIALOG=1
            || FUN.emsg(_msg)
            |? _args.DIALOG=2
            || exec('komm_genlim','zl_limit',_msg)
            ?};
::            KOMM.info('podczas tworzenia limitu wystąpił błąd — limit nie został wygenerowany',0);
            _args.KOMMEMPT:=0;
            _can_continue:=ZLIM.del(,1);
            {? _can_continue>0
            || _can_continue:=0
            ?}
         ?}
      || ZLIM.r_unlock();
         _kommdel:=1;
         _can_continue:=ZLIM.del(,1)
      ?}
   ||
::      KOMM.update(_sekcja2,,14,'200:0:0');
::      KOMM.info('podczas tworzenia limitu wystąpił błąd — limit nie został wygenerowany',0);
      _what:=exec('M','#to_string',_ktm);
      _msg:='Podczas tworzenia limitu na: %1 wystąpił błąd - limit nie został wygenerowany.'@[_what];
      {? _args.DIALOG=1
      || FUN.emsg(_msg)
      |? _args.DIALOG=2
      || exec('komm_genlim','zl_limit',_msg)
      ?};
      _can_continue:=0;
      _args.KOMMEMPT:=0
   ?};
::   KOMM.sect_end();
::   {? _kommdel>0
::   || KOMM.del(_sekcja2)
::   ?};
   DK_C.cntx_pop();
   ~~
?};
ZGP.cntx_pop();
ZLIM.cntx_pop();
ZLIM.get();
{? _can_continue>0
|| _result:=1
?};
_result




\bd_zlimt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Przed rekord dla pozycji ZLIM (w oknie drzewa _ZLIM)
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_tab:=cur_tab(1,1);
::{? var_pres('__ZLIMp')>0 || _tab:=__ZLIMp.ZLIM
::|? var_pres('__ZLIM')>0  || _tab:=__ZLIM
::                         || return()
::?};

:: co się da robimy bez szukania ZLIMa
M.clear();
{? _tab.M_REF>0 & M.seek(_tab.M_REF,)
||
::   exec('obl_stan','magazyn_stan',M.ref(),6);
   exec('zwr_stan','magazyn_stan',M.ref(),6,null(),0);
   _tab.S:=BEER.S;
   _tab.SD:=BEER.SD;
   _tab.SRT:=BEER.SRT;
   _tab.SRR:=BEER.SRR;
   _tab.SSZ:=BEER.SSZ;
   _tab.WDR:=BEER.WDR;
   _tab.put();
   ~~
?};

:: NUCO - brak odświerzania w oknie - zmiana do zgłoszenia w STD
{? _tab.PARENT=0
|| exec('GetChildVals','zl_limit',_tab,,,1)
?};

:: gdy zmieniła sie zawartość ZLIMa, trzeba odświeżyć
exec('zlim_refresh','zl_limit',_tab);

:: odebranie akcji
::exec('__ZLIM_actions','zl_limit');

VAR.ZLIM_KOR:=_tab.ALIL;
VAR.ZLIM_POB:=_tab.ZLIM_POB;
VAR.SR:=_tab.SR;
VAR.SRC:=_tab.SRC;

{? _tab.X_KIND='G'
|| ZLIM.blank(1);
   return(_tab.X_COLOR)
?};

ZLIM.clear();
:: aktualizuje pola stanów
{? ~ZLIM.seek(_tab.REF_NR,)
|| ZLIM.blank(1)
?};

_tab.X_COLOR


\kontr_lim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.62]
:: OPIS: kontrola limitów (powyżej i poniżej) dla zlecenia lub grupy operacji
::       Sumujemy limity dla każdego surowca, nie rozbijamy
::        według faz, bo chodzi tu o ujęcie globalne.
::       Nie analizujemy zleceń podrzędnych,
::        gdy limity generowane do nadrzędnego
::   WE: ustawione VAR.A_ZLEC = ZL.ref() / VAR.A_GROP = GROP.ref()
::       _a - T: analizować, N: nic nie robić
::       [_b] - [0]: kontrola zamknięcia, 1: wyświetlac wszystko (analiza drill-down zlecenia)
::       [_c] - parametr wywołania 'A','R',['S']
::       [_d] - tabela z niezgodnościami w limitach, jeżeli podana to aktualizowane dane
::       [_e] - co dołączać do __ZLIM4LIM: [1] - wszystkie rekordy, 0 - wyłącznie rekordy do ZLIMów niezbilansowanych
::       [_f] - tabela z listą surowców, które brać pod uwagę
::       [_g] - INTEGER - tabela, dla której uruchamiana: [0] - zlecenia (ZL), 1 - grupy operacji (GROP)
::   WY: 0: ok, _tab: są limity z przekroczeniami (zawsze dla _b=1)
::  OLD: \kontr_lim/zlec2.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')=type_of(0) || _all:=_b || _all:=0 ?};
{? var_pres('_c')=type_of('') || _param:=_c || _param:='S' ?};
{? var_pres('_d')>100 || _aktu:=1; _tab_rob:=_d || _aktu:=0; _tab_rob:=~~ ?};
{? var_pres('_e')=type_of(0) || _all_zlim:=_e || _all_zlim:=1 ?};
{? var_pres('_f')>100 & _f.size()>0 || _chk_zlim:=1; _zlim_tab:=_f || _chk_zlim:=0; _zlim_tab:=~~ ?};
{? var_pres('_g')=type_of(0) || _where:=_g || _where:=0 ?};
_go:={? _where=0 || ~(VAR.A_ZLEC().RODZAJ='P' & ZL.NRNZL<>0 & ZL.GENLIM='N') || 1 ?};

{? _a='T' & _go
|| _usluga:=0;
   {? _where=0
   || _zl:=VAR.A_ZLEC;
      _grop:=null();
   _wp:=ZL.TYP().WP;
::   _usluga:={? ZL.KTM().RODZ='U' || 1 || 0 ?};

   _rodzaj:=ZL.RODZAJ;
   {? _wp='P' & _rodzaj<>'N'
   || _xjm:=ZL.KTLZ().XJM;
      _il:=ZL.IL
   || _xjm:=_il:=1
   ?};
::   _ilwyk:=ZL.ILWYK;
      _ilwyk:=ZL.ILDOK

   || _zl:=null();
      _grop:=VAR.A_GROP;
      _wp:='P';
      _xjm:=_il:=GROP.IL;
      _ilwyk:=GROP.ILW
   ?};

   _tab:=tab_tmp(2,
      'T','INTEGER','Surowiec',
      'WYD','INTEGER','Wydział',
      'ILL0','REAL','Ilość limitowana',
      'ILL','REAL','Ilość limitowana',
      'ILP','REAL','Ilość pobrana',
      'ILRW','REAL','Ilość pobrana (łącznie)',
      'ILZW','REAL','Ilość zwrócona (łącznie)',
      'WARP','REAL','Wartość pobrań',
      'MX','STRING[1]','M?',
      'DX','STRING[1]','D?',
      'SX','STRING[1]','Status',
      'OX','STRING[30]','Status opisowo',
      'KOD','STRING[50]','Kod surowca',
      'NAZ','STRING[100]','Nazwa surowca');
   _tab.fld_attr('T',2);
   _tab.fld_attr('WYD',2);

   {? type_of(_tab)>100
   || _ndx1:=_tab.ndx_tmp(,,'T',,,'WYD',,);
      _ndx2:=_tab.ndx_tmp(,,'KOD',,);
      exec('openmask','zl_common',_zl,_grop);
      _tab.index(_ndx1);
      {? _where=0
      || {? (VAR.A_ZLEC().RODZAJ='P' & VAR.A_ZLEC().NRNZL=0) |
         (VAR.A_ZLEC().TYP().WP='W') |
         (VAR.A_ZLEC().RODZAJ<>'P' & VAR.A_ZLEC().GENLIM='N' & VAR.A_ZLEC().NRNZL=0) |
         (VAR.A_ZLEC().RODZAJ='P' & VAR.A_ZLEC().GENLIM='P' & VAR.A_ZLEC().NRNZL<>0)
      || ZLIM.index('ZN');
         ZLIM.prefix(VAR.A_ZLEC,'T')
      || ZLIM.index('ZPN');
         ZLIM.prefix(VAR.A_ZLEC,'T')
         ?}
      || ZLIM.index('GROPNM');
         ZLIM.prefix(VAR.A_GROP,'T')
      ?};
      {? var_pres('__ZLIM4LIM')>100 || obj_del(__ZLIM4LIM) ?};
::    Tabela z ropzisaniem materiału wg ZLIM
      __ZLIM4LIM:=tab_tmp(,
         'ZL_REF','INTEGER','#ZL.ref()',
         'GROP_REF','INTEGER','#GROP.ref()',
         'TAB_REF','STRING[16]','$_tab.ref()',
         'REF','STRING[16]','$ZLIM.ref()',
         'M_REF','INTEGER','#M.ref()',
         'AKC','STRING[1]','ZLIM.AKC',
         'SO','STRING[1]','ZLIM.SO',
         'WYD_REF','INTEGER','#ZLIM.WYD',
         'ZK_P_QRF','STRING[16]','$ZK_P.ref() powiązanego ZLIMa',
         'ZL_SQL','STRING[16]','$ZL.ref()',
         'GROP_SQL','STRING[16]','$GROP.ref()'
      );
      {? ZLIM.first()
      || {!
         |?
            {? ZLIM.AKC='T' & ZLIM.SO='S' & (_chk_zlim=0 | _zlim_tab.find_tab(,'MREF',,'=',#ZLIM.KTM))
            || _tab.prefix(#ZLIM.KTM);
               {? _tab.first()
               || _tab.ILL0+=ZLIM.LIL;
                  _tab.ILP+=(ZLIM.IL_RW-ZLIM.IL_ZW);
                  _tab.ILRW+=ZLIM.IL_RW;
                  _tab.ILZW+=ZLIM.IL_ZW;
                  _tab.WARP+=(ZLIM.WAR_RW-ZLIM.WAR_ZW);
                  {? _tab.put() & (_all_zlim=1 | ZLIM.IL_RW-ZLIM.IL_ZW>0)
                     & (_chk_zlim=0 | _zlim_tab.find_tab(,'REF',,'=',$ZLIM.ref()))
                  || __ZLIM4LIM.TAB_REF:=$_tab.ref();
                     __ZLIM4LIM.ZL_REF:=#ZLIM.ZLEC;
                     __ZLIM4LIM.GROP_REF:=#ZLIM.GROP;
                     __ZLIM4LIM.ZL_SQL:=$ZLIM.ZLEC;
                     __ZLIM4LIM.GROP_SQL:=$ZLIM.GROP;
                     __ZLIM4LIM.REF:=$ZLIM.ref();
                     __ZLIM4LIM.M_REF:=#ZLIM.KTM;
                     __ZLIM4LIM.AKC:={? exec('GetAlLil4ZLIM','zl_limit',1,ZLIM.ref())>0 || ZLIM.AKC || 'I' ?};
                     __ZLIM4LIM.SO:=ZLIM.SO;
                     __ZLIM4LIM.WYD_REF:=#ZLIM.WYD;
                     _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
                     __ZLIM4LIM.ZK_P_QRF:=$_zk_p;
                     __ZLIM4LIM.add()
                  ?}
               || _tab.blank();
                  _tab.T:=#ZLIM.KTM;
                  _tab.KOD:=ZLIM.KTM().KTM;
                  _tab.NAZ:=ZLIM.KTM().N;
                  _tab.ILL0:=ZLIM.LIL;
                  _tab.WYD:=#ZLIM.WYD;
                  _tab.ILP:=(ZLIM.IL_RW-ZLIM.IL_ZW);
                  _tab.ILRW:=ZLIM.IL_RW;
                  _tab.ILZW:=ZLIM.IL_ZW;
                  _tab.WARP:=(ZLIM.WAR_RW-ZLIM.WAR_ZW);
                  {? _tab.add() & (_all_zlim=1 | ZLIM.IL_RW-ZLIM.IL_ZW>0)
                     & (_chk_zlim=0 | _zlim_tab.find_tab(,'REF',,'=',$ZLIM.ref()))
                  || __ZLIM4LIM.TAB_REF:=$_tab.ref();
                     __ZLIM4LIM.ZL_REF:=#ZLIM.ZLEC;
                     __ZLIM4LIM.GROP_REF:=#ZLIM.GROP;
                     __ZLIM4LIM.ZL_SQL:=$ZLIM.ZLEC;
                     __ZLIM4LIM.GROP_SQL:=$ZLIM.GROP;
                     __ZLIM4LIM.REF:=$ZLIM.ref();
                     __ZLIM4LIM.M_REF:=#ZLIM.KTM;
                     __ZLIM4LIM.AKC:={? exec('GetAlLil4ZLIM','zl_limit',1,ZLIM.ref())>0 || ZLIM.AKC || 'I' ?};
                     __ZLIM4LIM.SO:=ZLIM.SO;
                     __ZLIM4LIM.WYD_REF:=#ZLIM.WYD;
                     _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
                     __ZLIM4LIM.ZK_P_QRF:=$_zk_p;
                     __ZLIM4LIM.add()
                  ?}
               ?}
            ?};
            ZLIM.next()
         !}
      ?};
::----------------------------------------------------------------------------------------------------------------------
:: Naniesienie znaczników, zgodne rekordy kasujemy
::----------------------------------------------------------------------------------------------------------------------
      _tab.prefix();
      {? _tab.first()
      || {!
         |?
:: Uwzględnienie w wyliczeniach wyskalowania do faktycznie
:: zarejestrowanej (zaraportowanej) ilości produktu.
:: (tylko dla zleceń produkcyjnych)
            {? _wp='P' & _usluga=0
            || _tab.ILL:=_tab.ILL0*_ilwyk/_il
            || _tab.ILL:=_tab.ILL0
            ?};
            {? _tab.ILP > _tab.ILL
            || _tab.DX:='X';
               _tab.SX:='D';
               _tab.OX:='Przekroczenie limitu'@;
               _tab.put();
               _tab.next()
            |? _tab.ILP < _tab.ILL
            || _tab.MX:='X';
               _tab.SX:='M';
               _tab.OX:='Poniżej limitu'@;
               _tab.put();
               _tab.next()
            || {? _all
               || _tab.SX:='N';
                  _tab.OX:='Według normy'@;
                  _tab.put();
                  _tab.next()
               || _tab.del()
               ?}
            ?}
         !}
      ?};
::    Przepisanie danych do tabeli docelowej w przypadku aktualizacji danych
      {? _aktu>0
      ||
::       Zapamiętanie refa, do którego materiału wrócić
         _mat:=_tab_rob.T;
         exec('tab2tab','#table',_tab,_tab_rob,0,1);
         _tab_rob.find_tab(,'T',,'=',_mat);
::       Aktualizacja tabeli __ZLIM4LIM (po zmianie refów tabeli głównej)
         __ZLIM4LIM.cntx_psh();
         {? _where=0
         || _ndx:=__ZLIM4LIM.ndx_tmp(,,'ZL_REF',,,'REF',,)
         || _ndx:=__ZLIM4LIM.ndx_tmp(,,'GROP_REF',,,'REF',,)
         ?};
         __ZLIM4LIM.index(_ndx);
         __ZLIM4LIM.prefix();
         {? __ZLIM4LIM.first()
         || _tab_rob.cntx_psh();
            _tab_rob.prefix();
            {!
            |?
               {? _tab_rob.find_tab(,'T',,'=',__ZLIM4LIM.M_REF)
               || __ZLIM4LIM.TAB_REF:=$_tab_rob.ref();
                  __ZLIM4LIM.put()
               ?};
               __ZLIM4LIM.next()
            !};
            _tab_rob.cntx_pop()
         ?};
         __ZLIM4LIM.ndx_drop(_ndx);
         __ZLIM4LIM.cntx_pop()
      ?};
::----------------------------------------------------------------------------------------------------------------------
:: Wyświetlenie raportu
::----------------------------------------------------------------------------------------------------------------------
      {? _tab.first() & _aktu=0
      || _ident:={? _where=0 || 'zlec' || 'grop' ?}+'2_lim_sel';
         _wer:=_tab.mk_sel('Niezgodność limitów i pobrań'@,'N',0,_ident,,,,,'U');
         _tab.win_fld(_wer,,'KOD',,,20,,,'Indeks'@);
:: NUCO - dodanie nazwy indeksu na stałe w okienku         
         _tab.win_fld(_wer,,'NAZ',,,60,,,'Nazwa'@);
         _tab.win_fld(_wer,,'ILL',,,15,4);
         _tab.win_fld(_wer,,'ILP',,,15,4);
::         _tab.win_fld(_wer,,'ILB',,,15,4);
::         _tab.win_fld(_wer,,'MX',,,,,,,,'Pobrania poniżej limitu'@,2,,"'X'","''");
::         _tab.win_fld(_wer,,'DX',,,,,,,,'Przekroczenie limitu'@,2,,"'X'","''");
         _tab.win_fld(_wer,,'OX',,,20,,,'Status'@);
         {? _all || _tab.win_fld(_wer,,'WARP',,,15,2) ?};
         {? _param='R'
         || {? _where=0
         || _tab.win_act(_wer,,'Formuła','Zamknij zlecenie'@@,,'Zamknij zlecenie mimo niezgodności'@,
               "sel_exit()",,1,,,,'Z',,'target=window')
            || _tab.win_act(_wer,,'Formuła','Zamknij grupę'@@,,'Zamknij grupę mimo niezgodności'@,
                  "sel_exit()",,1,,,,'Z',,'target=window')
            ?}
         ?};

         _tab.win_act(_wer,,'Formuła','&Wydanie'@@,'','Generacja wydania surowców dla limitu'@
         ,"params_exec('lim_wyd','zl_limit1',1)",,,1,"params_exec('lim_wyd_gb','zl_limit1',1)",,'W');
         task_attach('LMG_ZAM_IPRZ');

         _tab.win_act(_wer,,'Formuła','Zw&rot'@@,'','Generacja zwrotu surowców dla limitu'@
            ,"exec('zlim_zwr','zl_limit1',1)",,,1,"exec('zlim_zwr_gb','zl_limit1',1)",,'R');
         task_attach('TTE_WYK_DGZW');

         _formula:="
            exec('pozrap','magdok_prod',0,1,0,,1);
            exec('kontr_lim','zl_limit','T',0,,cur_tab(1,1),,,{? VAR.A_GROP<>null() || 1 || 0 ?});
            VAR.RFR_DOK:=1;
            ~~
         ";
         _tab.win_act(_wer,,'Formuła','&Dokumenty magazynowe'@@,'','Podgląd i rejestracja dokumentów magazynowych'@
            ,_formula,,,,,,'D');

         _formula:="
            M.cntx_psh();
            M.clear();
            {? M.seek(cur_tab(1,1).T)
            || exec('info_zam','magazyn_stan',3)
            ?};
            M.cntx_pop();
            ~~
         ";
         _tab.win_act(_wer,,'Formuła','Sz&czegóły'@@,'','Szczegółowe informacje dot. indeksu materiałowego'@
            ,_formula,,,,,,'C');
         {? _where=0
         || _formula:="params_set(params_get()); rep_exec('tte_rapzmkzl',,1)"
         || _formula:="params_set(params_get()); rep_exec('tte_rapzmkgr',,1)"
         ?};
         _tab.win_act(_wer,,'Formuła','Druku&j'@@,,,_formula
            ,,{? _param='R' || 0 || 1 ?},,,,'J',,'target=window,icon=print');
         _tab.win_sel(_wer);
         _tab.win_act(_wer,,'Formuła','Legenda'@@,,,"exec('legenda','color','__TABX#01#01')",,,,,,'L',,'target=window');
         _tab.win_act(_wer,0,'Rekord',,,,"{? cur_tab(1,1).ILP=0 || Color.rekprzed('__TABX#01#01') || '' ?}");
         _tab.win_btn(_wer,'text=%1,panel=bottom,align=begin'['Druku&j'@],'menu:J');
         {? _param='R'
         || {? _where=0
            || _tab.win_btn(_wer,'text=%1,panel=bottom,align=end'['Zamknij zlecenie'@],'menu:Z')
            || _tab.win_btn(_wer,'text=%1,panel=bottom,align=end'['Zamknij grupę'@],'menu:Z')
            ?}
         ?};
         _red:=_tab.mk_edit('Limity i pobrania'@,0,'zlec2_lim_edit');
         _tab.win_esep(_red,'Materiał'@);
         _tab.win_efld(_red,,'KOD',,,50,,,'Indeks'@);
         _tab.win_efld(_red,,'NAZ',,,50,,,'Nazwa'@);
         _tab.win_esep(_red,'Rozliczenie'@);
         _tab.win_efld(_red,,'ILL',,,15,4);
         _tab.win_efld(_red,,'ILP',,,15,4);
::         _tab.win_efld(_red,,'ILB',,,15,4);
::         _tab.win_efld(_red,,'MX',,,2,,,'Poniżej limitu'@,,,
::            'check-box','check_label="%1"'['Pobrania są mniejsze niż limit'@],"'X'","''"
::         );
::         _tab.win_efld(_red,,'DX',,,2,,,'Przekroczenie limitu'@,,,
::            'check-box','check_label="%1"'['Pobrania są większe niż limit'@],"'X'","''"
::         );
         _tab.win_efld(_red,,'SX',,,,,,'Status'@,,,'radio-buttons',,
            'Przekroczenie limitu'@,"'D'",
            'Zgodnie z normą'@,"'N'",
            'Poniżej limitu'@,"'M'"
         );
         _tab.win_edit(_red);
         _tab.index(_ndx2);
::----------------------------------------------------------------------------------------------------------------------
:: Wynik - jeśli są jakieś rekordy, to niedobrze
::----------------------------------------------------------------------------------------------------------------------
         _res:=obj_new('TAB','WER');
         _res.TAB:=_tab;
         _res.WER:=_wer;
         _res
      || 0
      ?}
   || exec('err_sql','#sql');
      0
   ?}
|| 0
?}
