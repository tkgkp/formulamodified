:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku:  px_logix.fml [12.10]
:: Utworzony: 2011-07-19
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Logika wielowymiarowego planu pojemnosciowego
::======================================================================================================================


\plan_add_kont
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Planuje biezacy rekord paczki technologicznej na dany kontener
::   WE: _a - _args
::   WY: exec('interval','#interval') - interwal czasu zawierajacy od kiedy sie zaczyna i kiedy sie konczy utworzony plan
::----------------------------------------------------------------------------------------------------------------------
_args:={?_>=1 || _a || exec('plan_add_kont_a','px_logix') ?};

_result:=exec('plan_add_kont_result','px_logix');
_paczka:=_args.PACZKA;
PX_KONT.cntx_psh();
PX_KONT.index('ACT');
PX_KONT.clear();
PX_GRP.cntx_psh();
PX_GRP.clear();
PX_STAGE.cntx_psh();
PX_STAGE.clear();

_overmode:=_args.overmode;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

_msg:='plan_add_kont\px_logix - Planowanie na kontenerze';
pxkomm.sect_beg(_msg);

{? PX_GRP.seek(_args.PX_GRP)
|| {? PX_STAGE.seek(_paczka.PX_STAGE)
   ||
::    ustawiam sie na kontenerze w planie glownym ktory jest podany jako docelowy do zaplanowania w paczce
      {? PX_KONT.seek(_paczka.REF_KONT)
      ||
::       szukam takiego kontenera rzeczywistego i aktywnego w wersji na ktora planuje, ktory ma taki sam symbol i nazwe
         PX_KONT.prefix('T',_args.PX_VER,PX_KONT.SYMBOL,);
         {? PX_KONT.first()
         ||
            _start_found:=0;
            _tm_start:=_args.TM_START;
::          Obsluga kooperacji - sprawdzam czy operacja jest kooperacyjna - jesli tak to start
::          jest ustawiony na podstawie kooperacji
            {? _paczka.COOP>0
            ||
               {? _args.DIR>0
               ||
::                Planowanie w przod
                  _tm_start:=_paczka.TM_START;

::                Jesli poczatek wynikajacy z kooperacji wczesniej niz wynikajacy z PX_GRP
::                lub nastepstwa operacji to powstaje konflikt kooperacyjny
                  {? _paczka.TM_START<_args.TM_START
                  ||
                     PX_GRP.PROBLEMS:=exec('problem_coop','px_grp');
                     PX_GRP.put();

::                   Dodawanie komunikatu o problemie z kooperacja
                     {? var_pres('_komm_args')>100
                     || obj_del(_komm_args)
                     ?};
                     _komm_args:=exec('add_komm_a','px_komm');
                     _komm_args.PX_VER:=_args.PX_VER;
                     _komm_args.PX_GRP:=PX_GRP.ref();
                     _komm_args.TYP:=exec('type_error','px_komm');
                     _komm_args.SRC_KIND:=exec('src_plan_coop','px_komm');
                     _msg:='Plan grupy: %1 narusza ustalony początek kooperacji'[PX_GRP.SYMBOL];
                     _msg+=' (należy ustalić inne granice czasowe kooperacji, lub grupy)';
                     _komm_args.MESSAGE:=_msg;
                     exec('add_komm','px_komm',_komm_args)
                  ?}
               ||
::                Planowanie w tyl
                  _tm_start:=_paczka.TM_END;

::                Jesli koniec wynikajacy z kooperacji pozniej niz wynikajacy z PX_GRP
::                lub nastepstwa operacji to powstaje konflikt kooperacyjny
                  {? _paczka.TM_END>_args.TM_START
                  ||
                     PX_GRP.PROBLEMS:=exec('problem_coop','px_grp');
                     PX_GRP.put();

::                   Dodawanie komunikatu o problemie z kooperacja
                     {? var_pres('_komm_args')>100
                     || obj_del(_komm_args)
                     ?};
                     _komm_args:=exec('add_komm_a','px_komm');
                     _komm_args.PX_VER:=_args.PX_VER;
                     _komm_args.PX_GRP:=PX_GRP.ref();
                     _komm_args.TYP:=exec('type_error','px_komm');
                     _komm_args.SRC_KIND:=exec('src_plan_coop','px_komm');
                     _msg:='Plan grupy: %1 narusza ustalony koniec kooperacji'[PX_GRP.SYMBOL];
                     _msg+=' (należy ustalić inne granice czasowe kooperacji, lub grupy)';
                     _komm_args.MESSAGE:=_msg;
                     exec('add_komm','px_komm',_komm_args)
                  ?}
               ?}
            ||
::             Operacje niekooperacyjną może mieć przesunięty start/koniec ze względu
::             na czas nakładkowania albo transportu
:: NUCO:       Czas nakładkowania i transportu uwzględniany również przy braku proporcji
               {?  PX_VAR.NAST_ALG=2 | PX_VAR.NAST_ALG=0
               || _tm_start:=exec('oper_offset','px_logix',_args.PXPACK,_tm_start,_args.DIR)
               ?}
            ?};

            _mainver:=exec('get_mainversion','px_ver');
::          KOREKTA ILOSCI WYKONYWANYCH
            _kor:=obj_new(1);
            {? _args.KOR_WYK1>0
            ||
               obj_del(_kor);
               {? _args.PX_VER=_mainver
               || _kor:=exec('count_status','px_poz', PX_GRP.UID,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID,
                                                      exec('status_wyk1','px_poz'))
               || _kor:=exec('count_status','px_poz', PX_GRP.UID_SRC,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID_SRC,
                                                      exec('status_wyk1','px_poz'))
               ?};

               exec('paczka_korekta','px_tex',_paczka,_kor,-1)
            ?};

::          KOREKTA ILOSCI WYKONANYCH
            {? _args.KOR_WYK2>0
            ||
               obj_del(_kor);
               {? _args.PX_VER=_mainver
               || _kor:=exec('count_status','px_poz', PX_GRP.UID,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID,
                                                      exec('status_wyk2','px_poz'))
               || _kor:=exec('count_status','px_poz', PX_GRP.UID_SRC,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID_SRC,
                                                      exec('status_wyk2','px_poz'))
               ?};
               exec('paczka_korekta','px_tex',_paczka,_kor,-1)
            ?};

::          KOREKTA ILOSCI OPÓŹNIONYCH
            {? _args.KOR_DLAY>0
            ||
               obj_del(_kor);
               {? _args.PX_VER=_mainver
               || _kor:=exec('count_status','px_poz', PX_GRP.UID,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID,
                                                      exec('status_delay','px_poz'))
               || _kor:=exec('count_status','px_poz', PX_GRP.UID_SRC,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID_SRC,
                                                      exec('status_delay','px_poz'))
               ?};
               exec('paczka_korekta','px_tex',_paczka,_kor,-1)
            ?};

::          KOREKTA ILOSCI ZABLOKOWANYCH
            {? _args.KOR_BLK>0
            ||
               obj_del(_kor);
               {? _args.PX_VER=_mainver
               || _kor:=exec('count_blk','px_poz',    PX_GRP.UID,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID)
               || _kor:=exec('count_blk','px_poz',    PX_GRP.UID_SRC,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID_SRC)
               ?};
               exec('paczka_korekta','px_tex',_paczka,_kor,-1)
            ?};

::          KOREKTA ILOSCI PORZUCONYCH
            {? _args.KOR_SKIP>0
            ||
               obj_del(_kor);
               {? _args.PX_VER=_mainver
               || _kor:=exec('count_status','px_poz', PX_GRP.UID,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID,
                                                      exec('status_skipped','px_poz'))
               || _kor:=exec('count_status','px_poz', PX_GRP.UID_SRC,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID_SRC,
                                                      exec('status_skipped','px_poz'))
               ?};
               exec('paczka_korekta','px_tex',_paczka,_kor,-1)
            ?};

::          Jesli po korektach cos zostalo to planuje, jesli nie to jako wynik zwracam moment startu wejsciowy
            {? exec('pck_oper_empty','px_tex',_paczka)>0
            ||
               _paczka.EMPTY:='N';
               _paczka.put();
               _tab:=~~;
               _lane:=~~;
               {? PX_VAR.NAST_ALG=2
               ||
::                Algorytm nakładkowania metodą proporcji czasowej działa w oparciu o PX_CAL
                  _tab:=PX_CAL;
                  {? _paczka.WEW='N'
                  || _lane:=_paczka.LANE
                  ?}
               ||
::                Standardowe planowanie działa w oparciu o PX_CUP
                  _tab:=PX_CUP
               ?};
::             szukam pierwszego niezablokowanego pojemnika w kontenerze od granicy planowania podanej na PX_GRP
::             zgodnie ze zwrotem planowania
               {? exec('first_cup','px_logix',_tm_start,_args.DIR,_args.PXPACK,PX_GRP.TM_START,PX_GRP.TM_END,_tab,_lane)>0
               || _start_found:=1
               ||
::                jesli parametr 500357 mowi ze w razie przekroczen zawsze planuje to odwracam
::                zwrot planowania i szukam najblizszego pojemnika wzgledem punktu czasowego docelowego
                  {? _overmode=exec('overfill_cont','px_param')
                  || _dir_negative:=-1*_args.DIR;
                     {? exec('cup_closest','px_plan',PX_KONT.ref(),_args.TM_START,_dir_negative)>0
                     || _start_found:=1;

::                      Raportuje problem na PX_GRP - przepełnienie
                        {? _args.DIR>0
                        || PX_GRP.PROBLEMS:=exec('problem_termR','px_grp');
                           PX_GRP.put();

::                         Dodawanie komunikatu o problemie
                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=_args.PX_VER;
                           _komm_args.PX_GRP:=PX_GRP.ref();
                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.PX_CUP:=PX_CUP.ref();
                           _komm_args.SRC_KIND:=exec('src_plan_termR','px_komm');
                           _msg:='Nie znaleziono żądanego pojemnika początkowego podczas planowania grupy: %1'[PX_GRP.SYMBOL];
                           _msg+=' (nowym pojemnikiem początkowym jest: %1, ale spowodowało to zazębienie się planu).'[PX_CUP.SYMBOL];
                           _msg+=' Zasób: %1.'[PX_KONT.SYMBOL];
                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args)

                        || PX_GRP.PROBLEMS:=exec('problem_termL','px_grp');
                           PX_GRP.put();

::                         Dodawanie komunikatu o problemie
                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=_args.PX_VER;
                           _komm_args.PX_GRP:=PX_GRP.ref();
                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.PX_CUP:=PX_CUP.ref();
                           _komm_args.SRC_KIND:=exec('src_plan_termL','px_komm');
                           _msg:='Nie znaleziono żądanego pojemnika początkowego podczas planowania grupy: %1'[PX_GRP.SYMBOL];
                           _msg+=' (nowym pojemnikiem początkowym jest: %1, ale spowodowało to zazębienie się planu).'[PX_CUP.SYMBOL];
                           _msg+=' Zasób: %1.'[PX_KONT.SYMBOL];
                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args)
                        ?}
                     ?}
                  ?}
               ?};
               {? _start_found>0
               ||
::                tutaj mam juz kontekst ustawiony na odpowiedniego PX_CUP lub PX_CAL
::                tabela PX_CUP/PX_CAL ma tez odpowiedni indeks ustawiony zgodny ze zwrotem planowania
::                GLOWNA PETLA PLANUJACA NA KONTENERZE
::                wrzucam na kolejne pojemniki az wykorzystam cala ilosc z wymiaru podstawowego
                  _left:=1;
                  _last_il:=_paczka.CAP_DIM1;
                  _last_start:=0;
                  _last_end:=0;
                  _first_cup:=PX_CUP.ref();

                  _can_continue:=1;

                  _argscup:=exec('plan_add_cup_a','px_logix');
                  _argscup.PACZKA:=_args.PACZKA;
                  _argscup.PXPACK:=_args.PXPACK;
                  _argscup.PX_GRP:=PX_GRP.ref();
                  _argscup.PX_STAGE:=PX_STAGE.ref();
                  _argscup.DIR:=_args.DIR;
                  _argscup.TM_END:=_args.TMGEND;
                  _argscup.RENUMERATE:=_args.RENUMERATE;
                  _argscup.STATUS:=_args.STATUS;
                  _argscup.OPER_START:=_tm_start;

::                Kontrola czy pierwszy pojemnik nie przekracza terminu
                  _first_chk:=exec('termin_chk','px_logix',_args.TMGSTART,_args.TMGEND,_args.DIR,_paczka,_tab);
                  {? _first_chk<=0
                  || _can_continue:=0
                  ?};
                  _il_wym:=exec('il_wym','px_param');
                  _added:=obj_new(_il_wym);
                  {! _it:=1.._il_wym
                  |! _added[_it]:=0
                  !};
::                PETLA PO KOLEJNYCH POJEMNIKACH
                  {? _first_chk>0
                  || _last_start:=_tab.TM_START;
                     _last_end:=_tab.TM_END;
                     {!
                     |?
::                      zapamietuje ostatni pojemnik do ktorego moge cos wsypac w razie brutalizacji
                        _next:=0;
                        _ref_nxt:=null();
                        _tab.cntx_psh();
                        {? _args.DIR>0
                        ||
                           {? _tab.next()
                           || _ref_nxt:=_tab.ref()
                           ?}
                        || {? _tab.prev()
                           || _ref_nxt:=_tab.ref()
                           ?}
                        ?};
                        _tab.cntx_pop();

                        _can_plan:=1;

                        {? PX_VAR.NAST_ALG=2 & _paczka.LANE>-1
                        ||
::                         Jeżeli operacja w paczce ma określony poziom kalendarza
::                         to żeby zaplanować, muszę być na PX_CAL o tym poziomie
                           {? PX_CAL.LEVEL<>_paczka.LANE
                           || _can_plan:=0
                           ?}
                        ?};

::                      !!! Właściwe planowanie !!!
                        {? _can_plan>0
                        ||
                           {? PX_CUP.STATUS=exec('status_normal','px_cup')
                           || _last_start:=PX_CUP.TM_START;
                              _last_end:=PX_CUP.TM_END
                           ?};

                           {? var_pres('_added')>0
                           || obj_del(_added)
                           ?};
                           _added:=exec('plan_add_cup','px_logix',_argscup);

                           {? exec('array_sum','#array',_added)>0
                           ||
                              {? PX_VAR.NAST_ALG=2 & _argscup.LANE>-1
                              || _paczka.LANE:=_argscup.LANE;
                                 _paczka.put()
                              ?};
::                            Jesli cos zaplanowalem to ustawiam punkt poczatkowy planu
                              {? _result.START=0
                              || {? _tab=PX_CAL
                                 ||
                                    {? _args.DIR>0
                                    || _result.START:=_argscup.POZSTART
                                    || _result.START:=_argscup.POZEND
                                    ?}
                                 ||
                                    {? _args.DIR>0
                                    || _result.START:=_tab.TM_START
                                    || _result.START:=_tab.TM_END
                                    ?}
                                 ?}
                              ?}
                           || _msg:='Nie udało się nic zaplanować w pojemniku: '+PX_CUP.SYMBOL;
                              pxkomm.error(_msg)
                           ?}
                        ?};
::                      !!! Właściwe planowanie !!!

::                      przeskakuje na nastepny pojemnik zgodnie z kierunkiem
                        {? _ref_nxt<>null()
                        || _can_continue:=_tab.seek(_ref_nxt)
                        || _can_continue:=0
                        ?};
                        {? _can_continue>0 & _tab=PX_CAL
                        ||
::                         Podczytanie PX_CUP
                           _tab.PX_CUP();
                           _last_start:=_argscup.POZSTART;
                           _last_end:=_argscup.POZEND
                        ?};
                        {? _first_cup<>PX_CUP.ref()
                        || _argscup.OPER_START:=0
                        ?};

                        _left:=exec('czyplanowaczka','px_logix',_paczka,_args.DIR);

::                      jesli jest nastepny pojemnik w dziedzinie to sprawdzam czy nie przekroczylem granic planowania
                        {? _can_continue>0 & _left>0
                        || _can_continue:=exec('termin_chk','px_logix',_args.TMGSTART,_args.TMGEND,_args.DIR,_paczka,_tab)
                        ?};
                        _left>0 & _can_continue>0
                     !}
                  || _last_start:=_args.TMGSTART;
                     _last_end:=_args.TMGEND
                  ?};

                  obj_del(_added);

::                jesli cos zostalo to znaczy ze albo przekroczylem termin, albo nie ma juz wiecej pojemnikow
::                w dziedzinie. W tym przypadku odwracam kierunek i znajduje pierwszy kafelek niezablokowany
::                na ktorego zrzuce cala pozostala ilosc - jak to jerry mowi, zrobie na nim fure
                  {? _left>0
                  ||
                     _argscup.OPER_START:=0;
                     _msg:='Planowane są resztki...';
                     pxkomm.error(_msg);
                     _new_dir:=_args.DIR*(-1);
                     {? _new_dir>0
                     || _new_start:=_last_start
                     || _new_start:=_last_end
                     ?};
                     {? exec('first_cup','px_logix',_new_start,_new_dir,,PX_GRP.TM_START,PX_GRP.TM_END,PX_CUP)>0
                     ||
::                      Sprawdzam czy nowo znaleziony pojemnik dla resztek miesci sie w terminie okreslonym dla obiektu
                        _first_chk:=exec('termin_chk','px_logix',_args.TMGSTART,_args.TMGEND,_new_dir,_paczka,_tab);

                        {? _first_chk>0
                        ||
                           _argscup.BRUTAL:=1;
                           {? var_pres('_added')>0
                           || obj_del(_added)
                           ?};
                           _added:=exec('plan_add_cup','px_logix',_argscup);

                           {? exec('array_sum','#array',_added)=0
                           || _msg:='Nie udało się zaplanować resztek';
                              pxkomm.error(_msg);
::                            Raportuje problem na PX_GRP - niepelny plan
                              PX_GRP.PROBLEMS:=exec('problem_half','px_grp');
                              PX_GRP.put();

::                            Dodawanie komunikatu o problemie
                              {? var_pres('_komm_args')>100
                              || obj_del(_komm_args)
                              ?};
                              _komm_args:=exec('add_komm_a','px_komm');
                              _komm_args.PX_VER:=_args.PX_VER;
                              _komm_args.PX_GRP:=PX_GRP.ref();
                              _komm_args.TYP:=exec('type_error','px_komm');
                              _komm_args.PX_CUP:=PX_CUP.ref();
                              _komm_args.SRC_KIND:=exec('src_plan_half','px_komm');
                              _msg:='Niepełny plan grupy: %1'[PX_GRP.SYMBOL];
                              _msg+=' (nie udało się zaplanować na pojemniku: %1 pozostałych pojemności - być może przekroczono max. dla operacji w przepisie planistycznym)'[PX_CUP.SYMBOL];
                              _komm_args.MESSAGE:=_msg;
                              exec('add_komm','px_komm',_komm_args)
                           ||
::                            Jesli cos zaplanowalem to ustawiam punkt poczatkowy planu
                              {? _result.START=0
                              || {? _args.DIR>0
                                 || _result.START:=_tab.TM_START
                                 || _result.START:=_tab.TM_END
                                 ?}
                              ?};
::                            Raportuje problem na PX_GRP - przepełnienie
                              {? _args.DIR>0
                              || PX_GRP.PROBLEMS:=exec('problem_termR','px_grp');
                                 PX_GRP.put();

::                               Dodawanie komunikatu o problemie
                                 {? var_pres('_komm_args')>100
                                 || obj_del(_komm_args)
                                 ?};
                                 _komm_args:=exec('add_komm_a','px_komm');
                                 _komm_args.PX_VER:=_args.PX_VER;
                                 _komm_args.PX_GRP:=PX_GRP.ref();
:: NUCO - zmiana błędu przepełnienia na ostrzeżenie o przepełnieniu
                                 _komm_args.TYP:=exec('type_warning','px_komm');
::                                 _komm_args.TYP:=exec('type_error','px_komm');
                                 _komm_args.PX_CUP:=PX_CUP.ref();
                                 _komm_args.SRC_KIND:=exec('src_plan_termR','px_komm');
                                 _msg:='Przekroczenie mocy podczas planowania grupy: %1'[PX_GRP.SYMBOL];
                                 _msg+=' (pojemnik, na którym przekroczono moce: %1. Zasób: %2)'[PX_CUP.SYMBOL,PX_KONT.SYMBOL];
                                 _komm_args.MESSAGE:=_msg;
                                 exec('add_komm','px_komm',_komm_args)

                              || PX_GRP.PROBLEMS:=exec('problem_termL','px_grp');
                                 PX_GRP.put();

::                               Dodawanie komunikatu o problemie
                                 {? var_pres('_komm_args')>100
                                 || obj_del(_komm_args)
                                 ?};
                                 _komm_args:=exec('add_komm_a','px_komm');
                                 _komm_args.PX_VER:=_args.PX_VER;
                                 _komm_args.PX_GRP:=PX_GRP.ref();
:: NUCO - zmiana błędu przepełnienia na ostrzeżenie o przepełnieniu
                                 _komm_args.TYP:=exec('type_warning','px_komm');
::                                 _komm_args.TYP:=exec('type_error','px_komm');
                                 _komm_args.PX_CUP:=PX_CUP.ref();
                                 _komm_args.SRC_KIND:=exec('src_plan_termL','px_komm');
                                 _msg:='Przekroczenie mocy podczas planowania grupy: %1'[PX_GRP.SYMBOL];
                                 _msg+=' (pojemnik, na którym przekroczono moce: %1. Zasób: %2)'[PX_CUP.SYMBOL,PX_KONT.SYMBOL];
                                 _komm_args.MESSAGE:=_msg;
                                 exec('add_komm','px_komm',_komm_args)
                              ?}
                           ?};
::                         Jesli nastapilo przekroczenie, jako wynik zwracam poczatek pojemnika w ktorym nastapilo
::                         przekroczenie, po to by kolejne planowane etapy zaczynaly tez od tego pojemnika, a nie
::                         przekraczaly jeszcze bardziej ustawiona granice
                           {? _args.DIR>0
                           || _last_start:=_tab.TM_START;
                              _last_end:=_tab.TM_START
                           ||
                              _last_start:=_tab.TM_END;
                              _last_end:=_tab.TM_END
                           ?}
                        ||
::                         Dodawanie komunikatu o problemie
                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=_args.PX_VER;
                           _komm_args.PX_GRP:=PX_GRP.ref();
:: NUCO - zmiana błędu przepełnienia na ostrzeżenie o przepełnieniu
                           _komm_args.TYP:=exec('type_warning','px_komm');
::                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.PX_CUP:=PX_CUP.ref();
                           _komm_args.SRC_KIND:=exec('src_plan_half','px_komm');
                           _msg:='Niepełny plan grupy: %1'[PX_GRP.SYMBOL];
                           _msg+=' (nie udało się zaplanować na pojemniku: %1 pozostałych pojemności - przekroczono granice czasowe elementu kolejki)'[PX_CUP.SYMBOL];
                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args)
                        ?}
                     || _msg:='Nie znaleziono pojemnika dla resztek (czas: '+(19+tm_form(_last_start))+')';
                        pxkomm.error(_msg);
                        _last_start:=0;
                        _last_end:=0;

                        _msg:='Nie znaleziono pojemnika, od którego miał się zacząć plan pozostałych pojemności.'
                              ' (być może termin realizacji obiektu w przeszłości).';
                              ' Zasób: %1. '[PX_KONT.SYMBOL];
                        {? _new_dir>0
                        || _msg+='Zwrot: W przód';
                           _msg+='Szukany start pojemnika: %1'[(19+tm_form(_new_start))]
                        || _msg+='Zwrot: W tył';
                           _msg+='Szukany koniec pojemnika: %1'[(19+tm_form(_new_start))]
                        ?};

::                      Dodawanie komunikatu o problemie do tabeli komunikatow
                        {? var_pres('_komm_args')>100
                        || obj_del(_komm_args)
                        ?};
                        _komm_args:=exec('add_komm_a','px_komm');
                        _komm_args.PX_VER:=_args.PX_VER;
                        _komm_args.PX_GRP:=PX_GRP.ref();
                        _komm_args.TYP:=exec('type_error','px_komm');
                        _komm_args.SRC_KIND:=exec('src_plan_nocup','px_komm');
                        _komm_args.MESSAGE:=_msg;
                        exec('add_komm','px_komm',_komm_args);

                        pxkomm.error(_komm_args.MESSAGE);

::                      Ustawiam problem na PX_GRP ze nie wszystko zaplanowane
                        PX_GRP.PROBLEMS:=exec('problem_half','px_grp');
                        PX_GRP.put()

                     ?}
                  ?};
::                USTAWIAM WYNIK - punkt czasu w ktorym sie skonczylo planowanie
                  {? _args.DIR>0
                  || _result.END:=_last_end
                  || _result.END:=_last_start
                  ?};

                  _paczka.LSTSTART:=_last_start;
                  _paczka.LSTEND:=_last_end;
::                rekordowi paczki ustawiam ref kontenera rzeczywistego na ktorym zostalo zaplanowane
                  _paczka.KONTREAL:=$PX_KONT.ref();
                  _paczka.put()

               || _msg:='Nie znaleziono pojemnika, od którego miał się zacząć plan.'
                        ' (być może termin realizacji obiektu w przeszłości).';
                        ' Zasób: %1. '[PX_KONT.SYMBOL];
                  {? _args.DIR>0
                  || _msg+='Zwrot: W przód';
                     _msg+='Szukany start pojemnika: %1'[(19+tm_form(_tm_start))]
                  || _msg+='Zwrot: W tył';
                     _msg+='Szukany koniec pojemnika: %1'[(19+tm_form(_tm_start))]
                  ?};

::                Dodawanie komunikatu o problemie do tabeli komunikatow
                  {? var_pres('_komm_args')>100
                  || obj_del(_komm_args)
                  ?};
                  _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=_args.PX_VER;
                  _komm_args.PX_GRP:=PX_GRP.ref();
                  _komm_args.TYP:=exec('type_error','px_komm');
                  _komm_args.SRC_KIND:=exec('src_plan_nocup','px_komm');
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args);

                  pxkomm.error(_komm_args.MESSAGE);

::                Ustawiam problem na PX_GRP ze nie wszystko zaplanowane
                  PX_GRP.PROBLEMS:=exec('problem_half','px_grp');
                  PX_GRP.put()
               ?}
            ||
               _msg:='Operacja paczki po korektach nie zawierała żadnych ilości do zaplanowania: '+_paczka.SYMBOL;
               pxkomm.error(_msg);

               _has_pozy:=0;
               PX_POZ.cntx_psh();
               PX_POZ.index('BLK2');
               PX_POZ.prefix(PX_GRP.ref(),PX_KONT.ref(),PX_STAGE.ref());
               PX_POZ.prefix(PX_GRP.ref(),PX_KONT.ref(),PX_STAGE.ref());
               {? PX_POZ.first()
               || _has_pozy:=1;
                  _result.START:=PX_POZ.TM_START;
                  {? PX_POZ.last()
                  || _result.END:=PX_POZ.TM_END
                  ?}
               ?};
               PX_POZ.index('STATUS2');
               PX_POZ.prefix(PX_GRP.ref(),PX_KONT.ref(),PX_STAGE.ref(),exec('status_wyk1','px_poz'));
               {? PX_POZ.first()
               || _has_pozy:=1;
                  {? _result.START=0 | PX_POZ.TM_START<_result.START
                  || _result.START:=PX_POZ.TM_START
                  ?};
                  {? PX_POZ.last()
                  || {? _result.END=0 | PX_POZ.TM_END>_result.END
                     || _result.END:=PX_POZ.TM_END
                     ?}
                  ?}
               ?};
               PX_POZ.cntx_pop();
               {? _has_pozy=0
               || _result.START:=_args.TM_START;
                  _result.END:=_args.TM_START
               ?};
               _paczka.EMPTY:='T';
               _paczka.put()
            ?}
         || _msg:='Nie znaleziono aktywnego zasobu rzeczywistego: '+PX_KONT.SYMBOL+' '+PX_KONT.NAZWA;

::          Dodawanie komunikatu o problemie do tabeli komunikatow
            {? var_pres('_komm_args')>100
            || obj_del(_komm_args)
            ?};
            _komm_args:=exec('add_komm_a','px_komm');
            _komm_args.PX_VER:=_args.PX_VER;
            _komm_args.PX_GRP:=PX_GRP.ref();
            _komm_args.TYP:=exec('type_error','px_komm');
            _komm_args.SRC_KIND:=exec('src_plan_nozas','px_komm');
            _komm_args.MESSAGE:=_msg;
            exec('add_komm','px_komm',_komm_args);

            pxkomm.error(_komm_args.MESSAGE)
         ?}
      || _msg:='Nie znaleziono zasobu technologicznego: '+_paczka.REF_KONT;
         pxkomm.error(_msg)
      ?}
   || _msg:='Nie znaleziono etapu w przepisie: '+_paczka.PX_STAGE;
      pxkomm.error(_msg)
   ?}
|| _msg:='Nie znaleziono obiektu grupujacego: '+$_args.PX_GRP;
   pxkomm.error(_msg)
?};
:: Paczce ustawiam daty poczatku i konca planu
_paczka.PL_START:=exec('min','#math',_result.START,_result.END);
_paczka.PL_END:=exec('max','#math',_result.START,_result.END);
_paczka.put();

{? PX_VAR.PD>0
||
:: Sprawdzam czy na podany początek operacji mam surowce wg planu dostaw
   _pd_result:=exec('plan','px_pd',_args.PD_OBJ,_args.PXPACK);
   {? type_of(_pd_result)>0
   ||
      _start_oper:=exec('tm_stamp2date','#tm_stamp',_paczka.PL_START);
      {? _pd_result.STATUS=0
      ||
::       Nie ma i nie będzie
         _msg:='Brak surowca potrzebnego do wykonania operacji: %1 na termin: %2'@[_paczka.NAZWA,exec('to_string','#tm_stamp',_paczka.PL_START)];
         {? var_pres('_komm_args')>100
         || obj_del(_komm_args)
         ?};
         _komm_args:=exec('add_komm_a','px_komm');
         _komm_args.PX_VER:=_args.PX_VER;
         _komm_args.PX_GRP:=PX_GRP.ref();
         _komm_args.TYP:=exec('type_error','px_komm');
         _komm_args.SRC_KIND:=exec('src_plan_nosur','px_komm');
         _komm_args.MESSAGE:=_msg;
         exec('add_komm','px_komm',_komm_args)
      |? _pd_result.STATUS>0 & _pd_result.DATA<>date(0,0,0) & _pd_result.DATA<>_start_oper
      ||
::       Mogą być na podany przez plan dostaw termin
         _result.REPLAN:=1;
         _paczka.TM_MIN:=exec('create','#tm_stamp',_pd_result.DATA,time(0,0,0));
         _paczka.REASON:=exec('reason_sur','px_param');
         _paczka.put();
         _args.PXPACK.HASPOINT:=1;
         ~~
      ?}
   ?};
   ~~
?};

pxkomm.sect_end();
PX_GRP.cntx_pop();
PX_GRP.get();
PX_KONT.cntx_pop();
PX_STAGE.cntx_pop();
_result


\plan_add_cup
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Dodaje do pojemnika pozycje planu
::       Kontekst pracy - PX_CUP, rekord paczki
::   WE: _a - _args - moje argumenty
::   WY: DICT - tablica - ile pojemnosci zostalo dodane w poszczegolnych wymiarach
::----------------------------------------------------------------------------------------------------------------------
_args:=~~;
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('plan_add_cup_a','px_logix')
?};

_il_wym:=PX_CUP.PX_KONT().IL_WYM;
_prec:=exec('precision_array','px_kont',PX_CUP.PX_KONT);

:: inicjalizacja wyniku
_result:=obj_new(_il_wym);
{! _it:=1.._il_wym
|! _result[_it]:=0
!};

_can_continue:=1;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};
_msg:='plan_add_cup\px_logix - Planowanie na pojemniku: '+PX_CUP.SYMBOL;
pxkomm.sect_beg(_msg);

_paczka:=_args.PACZKA;

_planuj:=exec('cup_ready','px_logix',_paczka);
{? _planuj=0
|| _msg:='Pojemnik nie gotowy: '+PX_CUP.SYMBOL;
   pxkomm.info(_msg)
?};

{? _planuj>0 | _args.BRUTAL>0
||
   _tab:=~~;
   {? PX_VAR.NAST_ALG=2
   || _tab:=PX_CAL
   || _tab:=PX_CUP
   ?};
   _argspoz:=exec('blank_a','px_poz');
   {? type_of(_paczka)>100
   || _argspoz.REASON:=_paczka.REASON
   || {? _args.REASON<>''
      || _argspoz.REASON:=_args.REASON
      ?}
   ?};

:: biegne po wymiarach i znajduje najmniejsza proporcje ktora pozwoli okreslic ile moge maksymalnie
:: wlac do pojemnika we wszystkich wymiarach wzgledem tego co bylo wymagane
   _proporcja:=1;
   _planuj:=0;
   _max_pck:=obj_new(_il_wym);
   _max_kor:=obj_new(_il_wym);
   _alg_nast:=obj_new(_il_wym);
   _cal_lvl:=obj_new(_il_wym);
   {! _it:=1.._il_wym
   |! {? type_of(_paczka)>100
      || _max_pck[_it]:=($('_paczka:=_a;_paczka.CAP_MAX'+$_it))(_paczka)
      || _max_pck[_it]:=0
      ?};
      _max_kor[_it]:=0;
      _alg_nast[_it]:=-1;
      _cal_lvl[_it]:=-1;
      ~~
   !};

:: Wyznaczanie czasów rozpoczęcia i zakończenia dla pozycji planu
   _argspoz.STARTD:=PX_CUP.STARTD;
   _argspoz.ENDD:=PX_CUP.ENDD;

   {? _args.PL_OPER<>null()
   || PL_OPER.cntx_psh(); PL_OPER.prefix();
      {? PL_OPER.seek(_args.PL_OPER)
      ||
         {? _args.DIR>0
         || _args.OPER_START:=PL_OPER.TM_START
         || _args.OPER_START:=PL_OPER.TM_END
         ?};
         _argspoz.TM_END:=PL_OPER.TM_END
      ?};
      PL_OPER.cntx_pop()
   ?};
   {? _args.PL_OGR<>null()
   || PL_OGR.cntx_psh(); PL_OGR.prefix();
      {? PL_OGR.seek(_args.PL_OGR)
      || {? _args.DIR>0
         || _args.OPER_START:=PL_OGR.TM_START
         || _args.OPER_START:=PL_OGR.TM_END
         ?};
         _argspoz.TM_END:=PL_OGR.TM_END
      ?};
      PL_OGR.cntx_pop()
   ?};
   {? _args.REM_PLAN<>null()
   || REM_ZGL.cntx_psh();
      REM_PLAN.cntx_psh(); REM_PLAN.prefix();
      {? REM_PLAN.seek(_args.REM_PLAN)
      ||
         REM_PLAN.REM_ZGL();

         _tm1:=exec('create','#tm_stamp',REM_ZGL.DT_PST,REM_ZGL.TM_PST);
         _tm2:=exec('create','#tm_stamp',REM_ZGL.DT_PUA,REM_ZGL.TM_PUA);

         _cup_dur:=PX_CUP.TM_END-PX_CUP.TM_START;
         _poz_dur:=_cup_dur*_args.PROP;

         _int_cup:=exec('interval','#interval');
         _int_cup.START:=PX_CUP.TM_START;
         _int_cup.END:=PX_CUP.TM_END;

         _int_chk:=exec('interval','#interval');
         _int_chk.START:=_tm2;
         _int_chk.END:=_tm2;

         {? exec('intervals_chk','#interval',_int_cup,_int_chk)=2
         ||
::          Jeżeli jestem w ostatnim pojemniku kończącym remont to planuję pozycję od
::          końca terminu usunięcia awarii, żeby godziny się zgadzały
            _args.DIR:=-1;
            _args.OPER_START:=_tm2;
            _tm_start:=_tm2-_poz_dur;

            _argspoz.TM_START:=exec('max','#math',_tm_start,PX_CUP.TM_START)
         ||
            _args.OPER_START:=_tm1;
            _tm_end:=exec('max','#math',PX_CUP.TM_START,_args.OPER_START)+_poz_dur;
            _argspoz.TM_END:=exec('min','#math',_tm_end,_tm2)
         ?}
      ?};
      REM_ZGL.cntx_pop();
      REM_PLAN.cntx_pop()
   ?};

   _argspoz.LANE:=1;
   _coop_with_times:=0;
   {? PX_VAR.NAST_ALG=2 & type_of(_paczka)>100 & _paczka.COOP>0 & _paczka.TM_START>0 & _paczka.TM_END>0
   || _coop_with_times:=1;
::    Obsługa kooperacji z podanymi granicami kooperacji
      {? _args.DIR>0
      || _args.OPER_START:=_paczka.TM_START
      || _args.OPER_START:=_paczka.TM_END
      ?};
      _argspoz.TM_END:=_paczka.TM_END
   ?};

   {? (PX_VAR.NAST_ALG=2 | PX_VAR.NAST_ALG=3) & _args.BRUTAL=0
   ||
::    Algorytm nakładkowania metodą proporcji czasowej wyznaczam począki i końce operacji

      {? _args.PL_OPER<>null() | _args.PL_OGR<>null() | _args.REM_PLAN<>null()
      ||
::       jeżeli PX_POZ na podstawie planu operacyjnego to do wyznaczenia granic czaowych
::       używam zawsze pojemnika, bo plan operacyjny ignoruje kalendarze na pojemniki
         {? var_pres('_tab')>100
         || obj_del(_tab)
         ?};
         _tab:=PX_CUP
      ?};

      {? _args.DIR>0
      || {? _args.OPER_START>0
         || _argspoz.TM_START:=exec('max','#math',_args.OPER_START,_tab.TM_START)
         || _argspoz.TM_START:=_tab.TM_START
         ?};
         {? _argspoz.TM_END>0
         || _argspoz.TM_END:=exec('min','#math',_argspoz.TM_END,_tab.TM_END)
         || _argspoz.TM_END:=_tab.TM_END
         ?}
      ||
         {? _args.OPER_START>0
         || _argspoz.TM_END:=exec('min','#math',_args.OPER_START,_tab.TM_END)
         || _argspoz.TM_END:=_tab.TM_END
         ?};
         {? _argspoz.TM_START>0
         || _argspoz.TM_START:=exec('max','#math',_argspoz.TM_START,_tab.TM_START)
         || _argspoz.TM_START:=_tab.TM_START
         ?}
      ?};

      {? _args.PL_OPER<>null() | _args.PL_OGR<>null() | _args.REM_PLAN<>null()
      ||
::       Przywracam nadpisaną tabelę
         {? var_pres('_tab')>100
         || obj_del(_tab)
         ?};
         {? PX_VAR.NAST_ALG=2
         || _tab:=PX_CAL
         || _tab:=PX_CUP
         ?}
      ?};
      {? PX_VAR.NAST_ALG=2
      || _argspoz.LANE:=PX_CAL.LEVEL;
         _args.LANE:=PX_CAL.LEVEL
      ?}
   || _argspoz.TM_START:=PX_CUP.TM_START;
      _argspoz.TM_END:=PX_CUP.TM_END
   ?};

   {? _coop_with_times>0
   || _dur_poz:=_argspoz.TM_END-_argspoz.TM_START;
      _max_kor[1]:=(_dur_poz/exec('hour','#tm_stamp'))$PX_KONT.PREC1
   ?};

:: Jesli proporcja jest podana w argumentach wejsciowych to nie wyliczam jej tylko uzywam
   {? _args.PROP<>0
   || _proporcja:=_args.PROP;
      _planuj:=1
   ||
::    Koryguje maksymalne zuzycie okreslone w przepisie - chocby nie wiem co nie moge wrzucic do pojemnika
::    pozycji planu ktora spowoduje przekroczenie zuzycia maksymalnego podanego w przepisie
::    dlatego podane maksimum koryguje, uwzgledniajac pozycje planu ktore juz sa w pojemniku
      {? _coop_with_times=0 & exec('array_sum','#array',_max_pck)>0
      || obj_del(_max_kor);
         _max_kor:=exec('cap_max_correct','px_poz',_args.PX_GRP,_args.PX_STAGE,_max_pck)
      ?};

      {? PX_VAR.NAST_ALG=1 & _args.OPER_START>0 & _paczka.TM_MIN=0 & _paczka.TM_MAX=0
      ||
::       Następstwo operacji - proporcja ilościowa. Tylko dla pierwszej pozycji planu
::       i tylko jeżeli nie ma punktu czasowego
         {? exec('cup_structure_chk','px_logix',_args.PXPACK,_args.DIR)>0
         ||
::          Jeśli ostatnia operacja skończyła się na pojemniku zgodnym pod względem
::          czasu z pierwszym pojemnikiem kolejnej operacji to robię proporcję ilościową
            _last_coef:=exec('last_coef_use','px_logix',_args.PXPACK,_args.DIR);

            {! _it:=1.._il_wym
            |! _alg_nast[_it]:=_last_coef[_it]
            !}
         ||
::          Tu powinno wejść tylko w przypadku gdy struktura pojemników na zasobach się różni
::          zwracam proporcję ilościową 0, co spowoduje że ten pojemnik zostanie pominięty i plan
::          przeskoczy dalej, czyli nie wykona nakładkowania z proporcją ilościową
            _can_continue:=0;
            {! _it:=1.._il_wym
            |! _alg_nast[_it]:=0
            !}
         ?}
      ?};
      {? PX_VAR.NAST_ALG=2 & PX_CUP.CAL_LVL>1
      || {! _it:=1.._il_wym
         |! _cal_lvl[_it]:=1/PX_CUP.CAL_LVL
         !}
      ?};
      _infinity:=exec('infinity_array','px_kont',PX_CUP.PX_KONT);
::    Wyliczanie proporcji ktora wyznaczy ilosci dla pozycji planu we wszystkich wymiarach
      {! _it:=1.._il_wym
      |? _can_continue>0
      |!
         {? type_of(_paczka)>100
         || _il_left:=($('_paczka:=_a;_paczka.CAP_DIM'+$_it+'-_paczka.DID_DIM'+$_it))(_paczka)
         || _il_left:=0
         ?};
         _cup_left:=($('PX_CUP.CAP_MAX'+$_it+'-PX_CUP.CAP_USE'+$_it))();

         _max:=_max_kor[_it];

         {? _alg_nast[_it]>-1 & _max>-1
         || {? _max>0
            || _max:=exec('min','#math',_max,_alg_nast[_it])
            || _max:=_alg_nast[_it]
            ?};
            {? _max=0
            ||
::             Jeżeli tutaj _max jest zerem to znaczy że z nakładkowania wynikło
::             że już w tym pojemniku nie można nic zaplanować i trzeba iść dalej
::             Zadziała to tak jeżeli ustawimy tą zmienną na -1
               _max:=-1
            ?}
         ?};
         _wym_endless:=_infinity[_it];
         {? _cal_lvl[_it]>-1 & _max>-1 & _wym_endless=0
         || _cup_max:=($('PX_CUP.CAP_MAX'+$_it))();
            _lvl_max:=(_cup_max*_cal_lvl[_it]);
            {? _max>0
            || _max:=exec('min','#math',_max,_lvl_max)
            || _max:=_lvl_max
            ?}
         ?};

::       Jesli z korekty maksimow wynika ze jakies maksimum jest mniejsze od zera
::       oznacza to ze przekroczono maksimum technologiczne na pojemniku, co z kolei oznacza
::       ze nie mozna zaplanowac tego etapu na ten pojemnik, wiec musze przerwac planowanie
         {? _max<0
         || _can_continue:=0;
            _planuj:=0
         ?};

         {? _il_left>0 & _can_continue>0
         ||
            _planuj:=1;
            _rule:=$('
                        _il_left:=_a;
                        _cup_left:=_b;
                        _max:=_c;
                        _wym_endless:=_d;
                        _result:=1;

                        {? PX_CUP.PX_KONT().ENDLESS=0 & _wym_endless=0
                        ||
                           {? _cup_left>0
                           || {? _max<>0 & _cup_left>_max
                              || _cup_left:=_max
                              ?};
                              {? _il_left>_cup_left
                              || _result:=_cup_left/_il_left
                              ?}
                           || _result:=0
                           ?}
                        || {? _max<>0
                           || {? _il_left>_max
                              || _result:=_max/_il_left
                              ?}
                           ?}
                        ?};
                        _result
                     ');

::          formula oblicza proporcje wyznaczajaca ilosc w pojemniku w danym wymiarze
            _pr:=_rule(_il_left,_cup_left,_max,_infinity[_it]);
            {? _pr>=0 & _pr<_proporcja
            || _proporcja:=_pr
            ?}
         ?}
      !}
   ?};

:: jeśli planowanie brutalne, to nieważna wyliczona proporcja - i tak wrzucam całość
   {? _args.BRUTAL>0
   || _proporcja:=1;
      _planuj:=1;
       _msg:='Brutalizacja planu na pojemniku: '+PX_CUP.SYMBOL+' na kontenerze: '+PX_CUP.PX_KONT().SYMBOL;
      pxkomm.info(_msg)
   ?};

   _msg:='Proporcja dla pozycji planu we wszystkich wymiarach: '+$_proporcja;
   pxkomm.info(_msg);

   {? _proporcja>0 & _planuj>0
   ||

::    przypisuje argumenty dla funkcji tworzacej pozycje planu
      _argspoz.PX_VER:=PX_CUP.PX_VER;
      _argspoz.PX_GRP:=_args.PX_GRP;

::    przypisuje pozycji planu PX_OBJ tylko jesli w paczce byl okreslony PX_OBJ
::    paczka mogla zostac przygotowana w taki sposob aby powstalych pozycji planu z rekordu paczki
::    nie musiec szatkowac (przypadek planowania opoznien)
::    jesli paczka nie ma podanego PX_OBJ to po zaplanowaniu pozycjom planu PX_OBJ zostanie
::    przypisany przez szatkownice (patrz exec('poz_conn_obj','px_logix'))
      _pxobj:=null();
      {? type_of(_paczka)>100 & _paczka.PX_OBJ<>''
      || PX_OBJ.cntx_psh();
         PX_OBJ.clear();
         {? PX_OBJ.seek(_paczka.PX_OBJ,8+_paczka.PX_OBJ)
         || _pxobj:=PX_OBJ.ref()
         ?};
         PX_OBJ.cntx_pop()
      ?};
      _argspoz.PX_OBJ:=_pxobj;
      _argspoz.PX_CUP:=PX_CUP.ref();
      _argspoz.PX_KONT:=PX_CUP.PX_KONT;
      _argspoz.PX_SET:=PX_CUP.PX_KONT().PX_SET;
      _argspoz.PX_STAGE:=_args.PX_STAGE;
      _argspoz.DIR:=_args.DIR;
      _argspoz.PL_OPER:=_args.PL_OPER;
      _argspoz.PL_OGR:=_args.PL_OGR;
      _argspoz.PX_OBJ:=_args.PX_OBJ;
      _argspoz.BLK:=_args.BLK;
      {? _args.STATUS<>''
      || _can_stat:=1;
         {? _args.STATUS=exec('status_delay','px_poz') & _args.BLK='T'
         || _can_stat:=0
         ?};
         {? _can_stat>0
         || _argspoz.STATUS:=_args.STATUS
         ?}
      ?};

::    Obsluga kooperacji - pozycjom planu zaznaczam ze powstaly na podstawie kooperacji
      {? type_of(_paczka)>100
      || {? _paczka.WEW='N'
         || _argspoz.KOOP:='T'
         ?}
      ?};

      {? _args.PL_OPER<>null() | _args.PL_OGR<>null()
      || _argspoz.SRC_OPER:='T'
      ?};

::    przypisuje ilosci w kolejnych wymiarach - ZAOKRAGLONE DO DOKLADNOSCI KONTENERA
      {! _it:=1.._il_wym
      |! _rule:=$('
                     _argspoz:=_a;
                     _paczka:=_b;
                     _proporcja:=_c;
                     _precision:=_d;
                     _caps:=_e;

                     {? type_of(_caps)>100
                     ||
::                      Jesli zuzycia podane to ich nie wyliczam tylko przepisuje
                        _argspoz.CAP_EAT'+$_it+':=_caps['+$_it+']$_precision
                     ||
::                      Wyliczam pojemnosci
                        {? type_of(_paczka)>100
                        || _il_left:=_paczka.CAP_DIM'+$_it+'-_paczka.DID_DIM'+$_it+';
                           _argspoz.CAP_EAT'+$_it+':=_il_left*_proporcja$_precision
                        ?}
                     ?};

                     {? type_of(_paczka)>100
                     || _argspoz.CAP_MIN'+$_it+':=_paczka.CAP_MIN'+$_it+'$_precision;
                        _argspoz.CAP_MAX'+$_it+':=_paczka.CAP_MAX'+$_it+'$_precision
                     ?};
                     ~~
                  ');
         _rule(_argspoz,_paczka,_proporcja,_prec[_it],_args.CAPS)
      !};

      _cal_eat:=0;
      _cal_correct:=0;
      {? PX_VAR.NAST_ALG=2 & _args.PL_OPER=null() & _args.PL_OGR=null() & _args.REM_PLAN=null() & _args.BRUTAL=0
      || _pr_time:=1;

::       Algorytm nakładkowania metodą proporcji czasowej
         _dur_poz:=0;
         {? type_of(_paczka)>100 & _paczka.COOP>0 & _paczka.TM_START>0 & _paczka.TM_END>0
         ||
::          Obsługa kooperacji z podanymi granicami kooperacji
            _dur_poz:=_argspoz.TM_END-_argspoz.TM_START
         ||
            _time_value:=0;
            _time_wym:=0;
            {! _it:=1.._il_wym
            |! _jm:=($('PX_KONT.JM'+$_it+'().KOD'))();
               {? _jm=PX_VAR.P500380 | _jm=PX_VAR.P500381
               || _time_wym:=($('_argspoz:=_a;_argspoz.CAP_EAT'+$_it))(_argspoz);
                  {? _time_value=0 | (_time_value<_time_wym)
                  ||
::                   Wyznaczam maksymalny czas trwania
                     _time_value:=_time_wym
                  ?}
               ?}
            !};

::          Obliczam czas trwania pozycji
            _dur_poz:=(_time_value*exec('hour','#tm_stamp'))
         ?};
         _cal_fit:=0;

         {? _args.DIR>0
         ||
::          Planowanie do przodu
            _tm_end:=_argspoz.TM_START+_dur_poz;

            {? _tm_end<_tab.TM_END
            ||
::             Mieszczę się w kalendarzu
               _argspoz.TM_END:=_tm_end

            |? _tm_end>_tab.TM_END
            || _argspoz.TM_END:=_tab.TM_END;
               _cal_fit:=1
            ?}
         ||
::          Planowanie do tyłu
            _tm_start:=_argspoz.TM_END-_dur_poz;

            {? _tm_start>_tab.TM_START
            ||
::              Mieszczę się w kalendarzu
               _argspoz.TM_START:=_tm_start

            |? _tm_start<_tab.TM_START
            || _argspoz.TM_START:=_tab.TM_START;
               _cal_fit:=1
            ?}
         ?};
         {? _cal_fit>0
         ||
::          Przekroczyłem dostępny kalendarz, więc robię dopasowanie do czasu kalendarza
            _dur_poz_new:=_argspoz.TM_END-_argspoz.TM_START;
            _prop_corr:=_dur_poz_new/_dur_poz;
            {! _it:=1.._il_wym
            |! _rule:=$('
                           _argspoz:=_a;
                           _proporcja:=_b;
                           _precision:=_c;
                           _argspoz.CAP_EAT'+$_it+':=_argspoz.CAP_EAT'+$_it+'*_proporcja$_precision;
                           ~~
                        ');
               _rule(_argspoz,_prop_corr,_prec[_it])
            !}
         ?};

         {? _argspoz.TM_START<=PX_CAL.TM_START & _argspoz.TM_END>=PX_CAL.TM_END
         ||
::          Pozycja planu zje cały dostępny kalendarz
            _cal_eat:=1
         ||
::          Pozycja planu nie zje całego dostępnego kalendarza
            _cal_correct:=1
         ?}
      ?};
      _argspoz.DATE_MIN:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_START);
      _argspoz.TIME_MIN:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_START);
      _argspoz.DATE_MAX:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_END);
      _argspoz.TIME_MAX:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_END);

      {? _args.PL_OPER<>null()
      ||
         _rem_plan:=exec('FindAndGet','#table',PL_OPER,_args.PL_OPER,,"REM_PLAN",null());
         {? _rem_plan<>null()
         ||
            REM_PLAN.cntx_psh(); REM_PLAN.prefix();
            REM_ZGL.cntx_psh();
            {? REM_PLAN.seek(_rem_plan)
            ||
               {? REM_PLAN.REM_ZGL().PL_TRYB<>'R'
               ||
::                Planowanie operacyjne remontów. Przed utworzeniem pozycji planu z operacyjnego
::                usuwam z pojemnika pozycje planu strategicznego, żeby się ten sam remont nie
::                zdublował w pojemniku
                  _rem_obj:=exec('get_rem_object','px_obj',REM_PLAN.REM_ZGL);
                  {? _rem_obj<>null()
                  || _args_del:=exec('plan_del_cup_a','px_logix');
                     _args_del.PX_OBJ:=_rem_obj;
                     exec('plan_del_cup','px_logix',_args_del)
                  ?}
               ?}
            ?};
            REM_PLAN.cntx_pop();
            REM_ZGL.cntx_pop()
         ?}
      ?};

      _merge:=0;
      _add:=0;
      _skip:=0;

::    Badam jaka operacje wykonac w biezacym pojemniku. Mozliwe sa nastepujace opcje
::       * _add=1
::             W pojemniku jest tworzona nowa pozycja planu. Jako wynik zwracane sa ilosci
::             utworzonej pozycji planu
::       * _merge=1
::             W pojemniku znajduje sie juz pozycja planu odpowiadajaca kryteriom grupowania
::             wiec ilosci ktore mialy powstac na nowej pozycji planu sa dopisywane do istniejacej
::             Jako wynik zwracane sa ilosci ktore zostaly scalone
::       * _skip=1
::             W pojemniku znajduje sie juz pozycja planu odpowiadajaca kryteriom grupowania
::             ale ilosci nie sa scalane. W praktyce nic nie jest robione, ale jako wynik
::             zwracane sa ilosci ktore mialy powstac na nowej pozycji planu.
::             W praktyce ta sciezka jest uzywana tylko podczas tworzenia planu na podstawie
::             planu operacyjnego. Wykorzystywane jest to po to by nie zwielokratniac ilosci
::             gdy jeden PL_OPER w planie zasobow jest zaplanowany na kilku PL_OZach i te kilka
::             plozow jest powiazane z PL_RESami ktore w planie WPP spotykaja sie na jednym PX_KONT
      {? _args.REM_PLAN<>null & _args.PL_OPER=null()
      || _add:=1;
         _argspoz.BLK:='T';
::       Planowanie remontów - sprawdzam, czy w pojemniku ten remont nie jest już zaplanowany
::       operacyjnie. Jeżeli jest, to nie planuję go strategicznie
         PL_OPER.cntx_psh();
         PL_OPER.index('REM_PLAN');
         PL_OPER.prefix(_args.REM_PLAN);
         {? PL_OPER.first()
         || {!
            |? {? exec('ploper_in_cup','px_logix',_args.PL_OPER)>0
               || _add:=0;
                  _skip:=1
               ?};
               PL_OPER.next()
            !}
         ?};
         PL_OPER.cntx_pop()
      |? _args.PL_OPER<>null()
      || {? exec('ploper_in_cup','px_logix',_args.PL_OPER)>0
         || {? _args.SKIP_PLO=1
            || _skip:=1
            |? _args.SKIP_PLO=2
            || _merge:=1
            ?}
         || _add:=1
         ?}
      |? _args.PL_OGR<>null()
      || {? exec('plogr_in_cup','px_logix',_args.PL_OGR)>0
         || _merge:=1
         || _add:=1
         ?}
      || {? type_of(_paczka)>100
         ||
            {? PX_VAR.NAST_ALG=2 & _args.BRUTAL=0
            ||
::             Algorytm nakładkowania metodą proporcji czasowej
               PX_POZ.index('PX_STAGE');
               PX_POZ.prefix(PX_CUP.ref());
               _add:=1
            ||
               {? exec('pxstage_in_cup','px_logix',_args.PX_GRP,_args.PX_STAGE,_paczka)>0
               || _merge:=1
               || _add:=1
               ?}
            ?}
         || _add:=1
         ?}
      ?};
      {? _add>0
      ||
         _msg:='Tworzenie pozycji planu';
         pxkomm.sect_beg(_msg);
::       !!!TWORZE POZYCJE PLANU!!!
::       zaokraglanie ilosci PX_POZa do prezycji PX_KONTa jest robione przed samym addem rekordu
::       w formulce exec('args2record','px_poz')
         {? exec('add','px_poz',_argspoz)>0
         ||
            _args.POZSTART:=PX_POZ.TM_START;
            _args.POZEND:=PX_POZ.TM_END;
::          Jesli utworzona pozycja planu przekracza dozwolona granice czasowa, to dodaje
::          komunikat dla niej
            {? _args.TM_END>0 & PX_POZ.TM_START>_args.TM_END
            ||
               PX_GRP.cntx_psh();
               PX_OBJ.cntx_psh();
               _argskom:=exec('add_komm_a','px_komm');
:: NUCO - zmiana błędu przepełnienia na ostrzeżenie o przepełnieniu
               _argskom.TYP:=exec('type_warning','px_komm');
::               _argskom.TYP:=exec('type_error','px_komm');
               _argskom.SRC_KIND:=exec('src_plan_termR','px_komm');
               _argskom.PX_VER:=PX_POZ.PX_VER;
               _argskom.PX_GRP:=PX_POZ.PX_GRP;
               _argskom.PX_CUP:=PX_CUP.ref();
               _argskom.PX_POZ:=PX_POZ.ref();

               _tm_str:=19+tm_form(_args.TM_END);
               _src:='';
               {? PX_POZ.PX_GRP<>null()
               || _src:=PX_POZ.PX_GRP().SYMBOL
               |? PX_POZ.PX_OBJ<>null()
               || _src:=PX_POZ.PX_OBJ().SYMBOL
               || _src:='<brak źródła>'
               ?};
               _msg:='Pozycja planu dla: '+_src;
               _msg+=' na pojemniku: '+PX_CUP.SYMBOL;
               _msg+=' przekracza dozwoloną w kolejce granicę czasową ('+_tm_str+')';
               _argskom.MESSAGE:=_msg;
               exec('add_komm','px_komm',_argskom);
               PX_GRP.cntx_pop();
               PX_OBJ.cntx_pop()
            ?};

            {! _it:=1.._il_wym
            |!
::             przypisuje wynik
               _rule:=$('_result:=_a;_result['+$_it+']:=PX_POZ.CAP_EAT'+$_it);
               _res:=_rule(_result);
               _msg:='Wynik formuly w wymiarze: '+$_it+'='+$_result[_it];
               pxkomm.info(_msg);

::             aktualizuje rekord w paczce
               {? type_of(_paczka)>100
               ||
                  _rule:=$('_paczka:=_a;_paczka.DID_DIM'+$_it+'+=PX_POZ.CAP_EAT'+$_it);
                  _rule(_paczka)
               ?}
            !};
::          uruchamiam formule po wlaniu
            exec('po_wlaniu','px_logix',PX_CUP.ref(),_argspoz,_args.RENUMERATE);

::          Modyfikacja kalendarzy w pojemniku po utworzeniu pozycji planu
            {? (PX_VAR.NAST_ALG=2 | PX_VAR.NAST_ALG=3) & (_argspoz.PL_OPER<>null() | _argspoz.PL_OGR<>null())
            ||
::             Jeżeli plan na podstawie operacyjnego to zawsze odtwarzam kalendarze w pojemniku
               exec('rebuild4cup','px_cal',,0)
            |? PX_VAR.NAST_ALG=2
            ||
               {? _cal_correct=0 & _cal_eat=0
               ||
::                Jeżeli do tej pory nie było decyzji co zrobić z kalendarzem to ją podejmuję
                  _cal_correct:=1;

                  {? _args.BRUTAL>0
                  || _cal_correct:=0;

                     _new_start:=0;
                     {? _args.DIR>0
                     || _new_start:=_argspoz.TM_START
                     || _new_start:=_argspoz.TM_END
                     ?};

                     {? exec('first_cup','px_logix',_new_start,_args.DIR,,PX_GRP.TM_START,PX_GRP.TM_END,PX_CAL)>0
                     || _cal_eat:=1
                     ?}
                  ?}
               ?};

::             Algorytm nakładkowania metodą proporcji czasowej
               {? PX_CUP.PX_KONT().PARALLEL<>'1'
               ||
                  {? _cal_correct>0
                  ||
::                   Modyfikuję kalendarz
                     _interval_poz:=exec('interval','#interval');
                     _interval_poz.START:=_argspoz.TM_START;
                     _interval_poz.END:=_argspoz.TM_END;

                     exec('split','px_cal',_interval_poz,_argspoz.LANE)
                  ?};
                  {? _cal_eat>0
                  ||
::                   Usuwam rekord kalendarza
                     exec('delete','px_cal',PX_CAL.ref())
                  ?}
               ?}
            ?}

         || _msg:='Utworzenie pozycji planu zakończone niepowodzeniem.';
            pxkomm.error(_msg)
         ?};
         pxkomm.sect_end()
      |? _merge>0
      ||
         _msg:='Scalanie pozycji planu, podczas planowania';
         pxkomm.sect_beg(_msg);
::       !!!SCALANIE POZYCJI PLANU!!!
         _control:=1;
         {? _args.BRUTAL=1
         || _control:=0
         ?};
         _res_m:=exec('merge_core','px_poz',PX_POZ.ref(),_argspoz,_control,_paczka);
         _sum_m:=exec('array_sum','#array',_res_m);
         {? _sum_m>0
         || obj_del(_result);
            {? _args.BLK='T'
            || exec('block','px_poz',PX_POZ.ref())
            ?};
            _result:=_res_m
         || _msg:='Scalenie pozycji planu zakonczone niepowodzeniem';
            pxkomm.error(_msg)
         ?};
         pxkomm.sect_end()
      |? _skip>0
      ||
::       NIE DODAJE ANI NIE SCALAM - OSZUKUJE ZE COS ZROBILEM
         {! _it:=1.._il_wym
         |!
::          przypisuje wynik
            _rule:=$('_result:=_a;_argspoz:=_b;_result['+$_it+']:=_argspoz.CAP_EAT'+$_it);
            _res:=_rule(_result,_argspoz)
         !}
      ?}
   ?}
?};
{? PX_VAR.NAST_ALG=1
|| exec('last_coef_save','px_logix',_result,_paczka)
?};

pxkomm.sect_end();
_result


\grp_fast_replan
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Przeplanowuje 'na szybko' podanego w argumencie PX_GRP
::   WE: _args - argumenty funkcji szybkiego przeplanowania - wynik dzialania exec('fast_replan_a','px_logix')
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mainver:=exec('get_replan_version','px_ver');

PX_CUP.cntx_psh();
PX_POZ.cntx_psh();
PX_POZ.index('TM_GRP');
PX_GRP.cntx_psh(); PX_GRP.clear();
{? PX_GRP.seek(_args.PX_GRP)
||
::----------------------------------------------------------------------------------------------------------------------
:: Merit_2325_test - modyfikacja:  2024 Sty 19 14:30
:: TP, opis : Dodanie warunku, jeśli planowanie jest do przodu i data rozpoczęcia jest ustalona na terminn późniejszy niż
::            dzisiaj to jej nie zmieniam
::----------------------------------------------------------------------------------------------------------------------
{? PX_GRP.DIR=1 & PX_GRP.STARTD().DATA>date()
|| _args.MOD_START:=0
?};
:: KONIEC ZMIANY

:: Na czas przeliczania grupy blokuje ja, ale jesli blokada sie nie udala
:: to i tak kontynuuje
   exec('lock','px_grp',,0);

   {? exec('is_blocked','px_grp')>0
   ||
::    Jesli grupa byla zablokowana to musze odblokowac te pozycje planu ktore
::    byly przesuwane w wyniku nadwykonan
      PX_POZ.prefix(PX_GRP.ref());
      {? PX_POZ.first()
      || {!
         |? {? exec('nadwykon_moved','px_poz')>0
            || {? PX_POZ.BLK='T'
               || PX_POZ.BLK:='N';
                  _can_continue:=PX_POZ.put()
               ?}
            ?};
            PX_POZ.next() & _can_continue>0
         !}
      ?}
   ?};
   {? _args.CLEAN>0
   ||
::    usuwam PX_GRP z planu - robie dziury po to by od nowa zaplanowac
      _can_continue:=exec('clean_from_plan','px_grp',PX_GRP.ref(),0)
   ?};

   {? _can_continue>0
   ||
::    sprawdzam czy psotek powolany, jesli nie to powoluje
      exec('PXoTEX_chk','px_tex');

::    pobieram paczke technologiczna
      {? PX_GRP.GROPS<>null()
      || _pxpack:=exec('trzepaczka_grop','px_tex',PX_GRP.GROPS,PX_GRP.ILOSC,PX_GRP.ref())
      || _pxpack:=exec('trzepaczka','px_tex',PX_GRP.PX_TEX,PX_GRP.ILOSC,PX_GRP.ref())
      ?};

      _argsgrp:=exec('plan_grp_a','px_logix');
      _argsgrp.VER_DST:=PX_GRP.PX_VER;
      _argsgrp.PX_GRP:=PX_GRP.ref();
      _argsgrp.RENUMERATE:=_args.RENUMERATE;
      obj_del(_argsgrp.PxPack);
      _argsgrp.PxPack:=_pxpack;
      {? type_of(_args.TM_RANGE)>0
      || _argsgrp.TM_RANGE:=_args.TM_RANGE
      ?};
      _argsgrp.PD_OBJ:=_args.PD_OBJ;

      _tm_start:=exec('round_start_pck','px_tex',_pxpack.Paczka);
      {? _args.MOD_START>0
      || {? _tm_start>0
         ||
            PX_GRP.STARTD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',_tm_start));
            PX_GRP.STARTT:=exec('tm_stamp2time','#tm_stamp',_tm_start);
            _can_continue:=PX_GRP.put()
         || _can_continue:=0
         ?}
      ?};

      {? _args.TM_ZERO>0
      ||
::       Jesli poczatek planu podany w argumencie to go wykorzystuje
         _argsgrp.TM_ZERO:=_args.TM_ZERO
      |? _args.ZERO_CREATE>0
      ||  _argsgrp.TM_ZERO:=_tm_start
      ?};

::    uruchamiam algorytm planujacy
      _can_continue:=exec('plan_grp','px_logix',_argsgrp).RESULT;

::    jesli sie udalo zaplanowac, to odwiezam termin i ilosc zaplanowana
::    na obiektach nalezacych do grupy
      {? _can_continue>0
      || {? PX_GRP.PX_VER=_mainver
         || PX_CONN.cntx_psh();
            PX_CONN.index('PX_GRP');
            PX_CONN.prefix(PX_GRP.ref());
            {? PX_CONN.first()
            || {!
               |? exec('il_plan_refresh','px_obj',PX_CONN.PX_OBJ);
                  exec('planend_refresh','px_obj',PX_CONN.PX_OBJ);
                  PX_CONN.next()
               !}
            ?};
            PX_CONN.cntx_pop()
         ?}
      ?};

      {? _can_continue>0 & _args.MOD_QUEUE>0
      ||
::       Stempluje kolejke czasem i userem modyfikacji - przeplanowanie obiektu moze wymagac
::       przeliczenia kolejki
         exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER)
      ?};

      {? exec('is_blocked','px_grp')>0
      ||
::       Jesli grupa byla zablokowana to musze zablokowac te pozycje planu ktore
::       byc moze powstaly w wyniku przeplanowania i nie sa jeszcze zablokowane
         PX_POZ.prefix(PX_GRP.ref());
         {? PX_POZ.first()
         || {!
            |? {? PX_POZ.BLK='N'
               || PX_POZ.BLK:='T';
                  _can_continue:=PX_POZ.put();

                  {? _can_continue>0
                  ||
::                   Jezeli zmienilem stan blokady to byc moze musze scalic te pozycje z inna pozycja
::                   ktora pasuje do kryteriow scalania - wykorzystuje do tego celu funkcje
::                   przesuwania - przesuwam do tego samego pojemnika
                     exec('move','px_poz',PX_POZ.ref(),PX_POZ.PX_CUP)
                  ?}
               ?};
               PX_POZ.next() & _can_continue>0
            !}
         ?}
      ?};

::    Generuje zapisy do planu dostaw
      {? _can_continue>0 & _args.SUR_UPD>0
      || exec('generuj_grp','px_sur',PX_GRP.PX_VER,PX_GRP.ref())
      ?}

   ?};
:: Zdejmuje blokade z grupy
   exec('unlock','px_grp',_args.PX_GRP)
?};
{? _can_continue>0
|| _result:=1
?};
PX_GRP.cntx_pop();
PX_POZ.cntx_pop();
PX_CUP.cntx_pop();
_result


\termin_chk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy aktualny pojemnik nie przekracza nieprzekraczalnych granic planowania
::       Kontekst pracy - PX_CUP, rekord paczki planistycznej
::   WE: _a - REAL - TM_START - nieprzekraczalna granica lewa
::       _b - REAL - TM_END - nieprzekraczalna granica prawa
::       _c - INTEGER - zwrot planowania
::       _d - tab_tmp - paczka planistyczna
::       [_e] - TABLE - tabela w której będzie poszukiwany rekord (domyślnie PX_CUP)
::   WY: 1 - pojemnik nie przekracza terminu
::       0 - pojemnik przekracza termin
::----------------------------------------------------------------------------------------------------------------------
_tm_start:=_a;
_tm_end:=_b;
_dir:=_c;
_paczka:=_d;

_tab:=~~;
{? var_pres('_e')>0
|| _tab:=_e
|| _tab:=PX_CUP
?};

_result:=1;


{? _dir<0
||
   {? _tm_start>0
   || {? _tab.TM_START<=_tm_start
      ||
         _what:=exec('PX_GRP','#to_string');
         _result:=0;
::       jesli cos zostalo do zaplanowania, ale przerywam plan z powodu przekroczenia
::       granic na obiekcie grupujacym to wyswietlam komunikat
         _msg:='Podczas planowania elementu kolejki: %1'
               ' nastąpiło przekroczenie dozwolonego terminu: %2 (początkowa granica czasowa elementu kolejki).'
               ' Spowodowało to przepełnienie na pojemniku przed dozwolonym terminem.'[_what,(19+tm_form(_tm_start))];

::       Dodawanie komunikatu o problemie do tabeli komunikatow
         {? var_pres('_komm_args')>100
         || obj_del(_komm_args)
         ?};
         _komm_args:=exec('add_komm_a','px_komm');
         _komm_args.PX_VER:=PX_VER.ref();
         _komm_args.PX_GRP:=PX_GRP.ref();
         _komm_args.PX_CUP:=PX_CUP.ref();
:: NUCO - zmiana błędu przepełnienia na ostrzeżenie o przepełnieniu
         _komm_args.TYP:=exec('type_warning','px_komm');
::         _komm_args.TYP:=exec('type_error','px_komm');
         _komm_args.SRC_KIND:=exec('src_plan_cupter','px_komm');
         _komm_args.MESSAGE:=_msg;
         exec('add_komm','px_komm',_komm_args);

         pxkomm.error(_komm_args.MESSAGE)
      ?}
   ?}
?};
{? _dir>0
||
   {? _tm_end>0
   || {? _tab.TM_END>_tm_end
      ||
         {? _paczka.PL_FORCE='T'
         ||
            _what:=exec('PX_GRP','#to_string');
::          Umozliwiam planowanie poza termin, nie przerywam, tylko dodaje odpowiedni komunikat
            _msg:='Podczas planowania elementu kolejki: %1'
                  ' nastąpiło przekroczenie dozwolonego terminu: %2 (końcowa granica czasowa elementu kolejki).'
                  ' Plan jest kontynuowany mimo przekroczenia na pojemniku: %3.'[_what,(19+tm_form(_tm_end)),PX_CUP.SYMBOL];
            {? var_pres('_komm_args')>100
            || obj_del(_komm_args)
            ?};
            _komm_args:=exec('add_komm_a','px_komm');
            _komm_args.PX_VER:=PX_VER.ref();
            _komm_args.PX_GRP:=PX_GRP.ref();
            _komm_args.PX_CUP:=PX_CUP.ref();
:: NUCO - zmiana błędu przepełnienia na ostrzeżenie o przepełnieniu
            _komm_args.TYP:=exec('type_warning','px_komm');
::            _komm_args.TYP:=exec('type_error','px_komm');
            _komm_args.SRC_KIND:=exec('src_plan_force','px_komm');
            _komm_args.MESSAGE:=_msg;
            exec('add_komm','px_komm',_komm_args);

            pxkomm.error(_komm_args.MESSAGE)
         ||
            _what:=exec('PX_GRP','#to_string');
            _result:=0;
::          jesli cos zostalo do zaplanowania, ale przerywam plan z powodu przekroczenia
::          granic na obiekcie grupujacym to wyswietlam komunikat
            _msg:='Podczas planowania elementu kolejki: %1'
                  ' nastąpiło przekroczenie dozwolonego terminu: %2 (końcowa granica czasowa elementu kolejki).'
                  ' Spowodowało to przepełnienie na pojemniku przed dozwolonym terminem.'[_what,(19+tm_form(_tm_end))];

::          Dodawanie komunikatu o problemie do tabeli komunikatow
            {? var_pres('_komm_args')>100
            || obj_del(_komm_args)
            ?};
            _komm_args:=exec('add_komm_a','px_komm');
            _komm_args.PX_VER:=PX_VER.ref();
            _komm_args.PX_GRP:=PX_GRP.ref();
            _komm_args.PX_CUP:=PX_CUP.ref();
:: NUCO - zmiana błędu przepełnienia na ostrzeżenie o przepełnieniu
            _komm_args.TYP:=exec('type_warning','px_komm');
::            _komm_args.TYP:=exec('type_error','px_komm');
            _komm_args.SRC_KIND:=exec('src_plan_cupter','px_komm');
            _komm_args.MESSAGE:=_msg;
            exec('add_komm','px_komm',_komm_args);

            pxkomm.error(_komm_args.MESSAGE)
         ?}
      ?}
   ?}
?};
_result


\queue_update
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Przed przeliczeniem planu dokonuje niezbednych aktualizacji elementow w kolejce
::   WE: [_a] - PX_VER.ref()
::       [_b] - _args - argumenty dla funkcji raportujacej progress
::                      wynik dzialania exec('plan_progress_a','px_logix')
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};
_progress:=0;
_argsprog:=~~;
{? var_pres('_b')>100
|| _argsprog:=_b;
   _progress:=1
?};

_result:=0;
_can_continue:=1;

PX_VER.cntx_psh();
{? _ref<>null()
|| PX_VER.clear();
   {? PX_VER.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_GRP.cntx_psh();
   {? exec('is_whatif','px_ver')>0
   || PX_GRP.index('PLAN_S');
      PX_GRP.prefix(PX_VER.ref(),'N','N','N')
   || PX_GRP.index('PLAN');
      PX_GRP.prefix(PX_VER.ref(),'N','N');
:: NUCO - przed aktualizacjami kolejki usówam pozycje opóźnione z planu strategicznego
      exec('usun_px_opoznione','qtpp');
:: NUCO - przed aktualizacją kolejki sortujemy kolejkę terminem realizacji
      exec('que_organize','qtpp',PX_VER.ref())
   ?};
   _lp_coop:=0;
   {? PX_GRP.first()
   || {? _progress>0
      || _argsprog.SIZELOC:=PX_GRP.size()
      ?};
      {!
      |?
         _can_continue:=exec('queue_update_core','px_logix',,0);

::       raportuje progress
         {? _can_continue>0 & _progress>0
         || _argsprog.PROGLOC+=1;
            _can_continue:=exec('plan_progress','px_logix',_argsprog,1)
         ?};

         {? PX_GRP.COOP='T'
         || _lp_coop+=1;
            PX_GRP.COOP_LP:=_lp_coop;
            _can_continue:=PX_GRP.put()
         ?};
         PX_GRP.next() & _can_continue>0
      !}
   ?};

   {? _argsprog.MODE=2 & _progress>0
   || {? _can_continue>0
      || _argsprog.MULTI.ph_sname(,'Aktualizacja kolejki zakończona powodzeniem.'@)
      || _argsprog.MULTI.ph_sname(,'Aktualizacja kolejki zakończona niepowodzeniem.'@)
      ?}
   ?};
   PX_GRP.cntx_pop()
?};
PX_VER.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\queue_update_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przed przeliczeniem planu dokonuje niezbednych aktualizacji podanego elementu w kolejce
::   WE: [_a] - PX_GRP.ref() - lub bieżący rekord
::       [_b] - INTEGER - 0/[1] - czy wykonywać aktualizację pola COOP_LP dla wszystkich elementów kolejki
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};
_coop_lp:=1;
{? var_pres('_b')=type_of(0)
|| _coop_lp:=_b
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: 1. Usuwam automatyczne punkty czasowe jesli praca na zestawach wylaczona
   {? exec('is_px_set','px_param')=0
   || _can_continue:=exec('auto_point_del','px_point')
   ?};

:: 2. Aktualizuje czas startu w oparciu o biezacy czas
   {? _can_continue>0
   || _can_continue:=exec('update_tm_start','px_grp')
   ?};

:: 3. Aktualizuje informację czy grupa posiada kooperację
   {? _can_continue>0
   || _can_continue:=exec('update_coop','px_grp',,_coop_lp)
   ?};

:: 4. NUCO Wykonuje operacje na pozycji kolejki jeśli jest taka potrzeba, zgodnie z założeniami klienta
   {? _can_continue>0
   || _can_continue:=exec('px_update','qtpp')
   ?}
?};
PX_GRP.cntx_pop();
PX_GRP.get();
{? _can_continue>0
|| _result:=1
?};
_result

