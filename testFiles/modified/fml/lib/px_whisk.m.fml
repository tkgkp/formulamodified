:!UTF-8
::(c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: px_whisk.fml [12.10]
:: Utworzony: 2011/09/05
:: Autor: jerry
::======================================================================================================================
:: Zawartosc: Formuly dla 'trzepaczki'
::======================================================================================================================


\Stages2PxPack
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Generuje paczke na podstawie aktualnej dziedziny PX_STAGE
::   WE: _eggs - wynik formuly exec('pck_params','px_whisk')
::   WY: ~~
::UWAGA: PRACA NA AKTUALNYM KONTEKSCIE PX_STAGE - Przed wywolaniem musi zostac wykonane PX_STAGE.first()!!!
::       albo PX_STAGE.seek(_eggs.PX_STAGE) - WTEDY PRZETWARZANY TYLKO TEN JEDEN ETAP!
::----------------------------------------------------------------------------------------------------------------------
_eggs:=_a;

PX_OPER.cntx_psh();
PX_OPER.clear();
PX_OPER.index('UNIQALL');
PX_KONT.cntx_psh();

{? var_pres('PxTabPar')<100 || exec('PxTabPar','px_init') ?};
_packp:=_eggs.PxPack.tabpar;
_packS:=_eggs.PxPack.add_a();
_packB:=_eggs.PxPack.add_a();
_packO:=_eggs.PxPack.add_a();
_packM:=_eggs.PxPack.add_a();
_packN:=_eggs.PxPack.add_a();
_packP:=_eggs.PxPack.add_a();

_stage:=exec('stage','px_nast');
exec('start_xpar','tech_param',_eggs.PX_TEX);
{!
|?
   _planned:='N';
   _grop_member:='N';
   _packS.PARENT:=0;
   _packS.REASON:=exec('reason_plan','px_param');
   _size:=PX_STAGE.size();
   _form_dokl:=+($_size);
   _form_dokl:=-1*_form_dokl;

   _packS.SYMBOL:='Etap '+form(PX_STAGE.NR,_form_dokl);

   _packS.NAZWA:=PX_STAGE.NAZWA;
   _packS.BRANCH:='T';
   _packS.TYP:='O';
   _packS.LEVEL:=0;
   _packS.ILOSC:=_eggs.Quantity;
   _packS.NUM:=PX_STAGE.NR;
   _packS.NUM_STAG:=PX_STAGE.NR;
   _packS.DIR:=_eggs.Directio;
   _packS.PX_STAGE:=$PX_STAGE.ref();
   _packS.PX_STAGM:=PX_STAGE.name();
   _packS.PX_STAGR:=#PX_STAGE.ref();
   _packS.ALIGNMEN:=PX_STAGE.ALIGNMEN;
   _wew:=exec('is_wew','px_stage',PX_STAGE.ref());
   _packS.WEW:=_wew;
   _packS.PL_FORCE:=_eggs.PL_FORCE;
   {? PX_VAR.NAST_ALG=2 & _wew='N'
   ||
::    Jeżeli kooperacja to operacja zajmuje dla siebie poziom
::    kalendarza unikalny w ramach całej kolejki na każdym zasobie
::    kooperacyjnym
      _packS.LANE:=exec('FindAndGet','#table',PX_GRP,_eggs.PX_GRP,,"COOP_LP",-1)
   || _packS.LANE:=-1
   ?};

   _tm_min:=0;
   _tm_max:=0;
   {? _eggs.PX_GRP<>null()
   ||
::    Obsługa operacji grupowych
      PX_GRP.cntx_psh(); PX_GRP.prefix();
      {? PX_GRP.seek(_eggs.PX_GRP)
      || {? PX_VAR.PL_GROP>0 & exec('is_grop_member','px_grop',_eggs.PX_GRP)>0
         ||
            {? exec('stage_planned_in_grop','px_grop',,PX_GRP.PX_VER)
            || _planned:='T';
               _grop_member:='T'
            ||
               {? _eggs.Directio>0
               || _tm_min:=exec('get_time_zl','px_grop',_eggs.PX_GRP,PX_STAGE.ref())
               || _tm_max:=exec('get_time_zl','px_grop',_eggs.PX_GRP,PX_STAGE.ref())
               ?};
               {? _tm_min>0 | _tm_max>0
               || _eggs.PxPack.HASPOINT:=1;
                  _packS.REASON:=exec('reason_grop','px_param')
               ?}
            ?}
         ?}
      ?};
      PX_GRP.cntx_pop();

      {? _tm_min=0 & _tm_max=0
      ||
::    Sprawdzam czy dany etap dla danej grupy ma punkty czasowe
      PX_POINT.cntx_psh();
      PX_POINT.index('PX_GRP');
      PX_POINT.prefix(_eggs.PX_GRP,PX_STAGE.ref());
      {? PX_POINT.first()
      || _eggs.PxPack.HASPOINT:=1;
         _tm_min:=PX_POINT.TM_MIN;
            _tm_max:=PX_POINT.TM_MAX;
            _packS.REASON:=exec('reason_point','px_param')
         ?};
         PX_POINT.cntx_pop()
      ?};
      ~~
   ?};
   _packS.PLANNED:=_planned;
   _packS.GROPED:=_grop_member;
   _packS.TM_MIN:=_tm_min;
   _packS.TM_MAX:=_tm_max;

   _parentS:=_eggs.PxPack.add(_packS);

   {? _parentS<>null()
   ||
::    Galaz zasobow etaptu
      {? _eggs.PxOPER
      ||
         _packB.PARENT:=#_parentS;
         _packB.SYMBOL:='Zasoby';
         _packB.NAZWA:='Zasoby etapu '+form(PX_STAGE.NR,_form_dokl);
         _packB.BRANCH:='T';
         _packB.TYP:='B';
         _packB.LEVEL:=1;
         _packB.PL_FORCE:=_eggs.PL_FORCE;
         _packB.NUM_STAG:=PX_STAGE.NR;

         _packB.ILOSC:=_eggs.Quantity;

         _packB.PX_STAGE:=$PX_STAGE.ref();
         _packB.PX_STAGM:=PX_STAGE.name();
         _packB.PX_STAGR:=#PX_STAGE.ref();

         _parentB:=_eggs.PxPack.add(_packB);

         {? _parentB<>null()
         ||
::          Operacje dla etapu
            PX_OPER.prefix(PX_STAGE.ref());
            {? PX_OPER.first()
            || {!
               |?
                  _packO.PARENT:=#_parentB;
                  _packO.SYMBOL:='('+PX_OPER.PX_KONT().SYMBOL+') '+PX_OPER.PX_KONT().NAZWA;
                  _packO.NAZWA:=PX_OPER.COMMENT;
                  _packO.BRANCH:='N';
                  _packO.TYP:='K';
                  _packO.LEVEL:=2;
                  _packO.ILOSC:=_eggs.Quantity;
                  _packO.NUM:=_packS.NUM;
                  _packO.NUM_STAG:=_packS.NUM_STAG;

                  _packO.DIR:=_eggs.Directio;
                  _packO.PX_STAGE:=$PX_STAGE.ref();
                  _packO.PX_STAGM:=PX_STAGE.name();
                  _packO.PX_STAGR:=#PX_STAGE.ref();

                  _packO.PLANNED:=_planned;
                  _packO.GROPED:=_grop_member;
                  _packO.TM_MIN:=_tm_min;
                  _packO.TM_MAX:=_tm_max;
                  _packO.REASON:=_packS.REASON;

                  _coop:=exec('coop_zgp','px_stage',PX_STAGE.ref());
                  _grop_pr:=exec('planned_grop_pr','px_stage',PX_STAGE.ref());

                  _packO.WEW:=_wew;
                  {? PX_VAR.NAST_ALG=2 & _wew='N'
                  ||
::                   Jeżeli kooperacja to operacja zajmuje dla siebie poziom
::                   kalendarza unikalny w ramach całej kolejki na każdym zasobie
::                   kooperacyjnym
                     _packO.LANE:=exec('FindAndGet','#table',PX_GRP,_eggs.PX_GRP,,"COOP_LP",-1)
                  || _packO.LANE:=-1
                  ?};

                  _packO.PL_FORCE:=_eggs.PL_FORCE;

                  _coop_start:=0;
                  _coop_end:=0;
                  _coop_akc:=exec('coop_zgp_akc','px_stage',PX_STAGE.ref());
                  {? _coop>0
                  ||
::                   specjalna obsluga kooperacji na zleceniu ktore ma przewodniki
                     _coop_start:=exec('coop_zgp_start','px_stage',PX_STAGE.ref());
                     _coop_end:=exec('coop_zgp_end','px_stage',PX_STAGE.ref());
                     {? _coop_start>0 & _coop_end>0 & _coop_akc>0
                     || _packO.COOP:=1;
                        _packO.TM_START:=_coop_start;
                        _packO.TM_END:=_coop_end;
                        _packO.STARTD:=exec('tm_stamp2date','#tm_stamp',_coop_start);
                        _packO.STARTT:=exec('tm_stamp2time','#tm_stamp',_coop_start);
                        _packO.ENDD:=exec('tm_stamp2date','#tm_stamp',_coop_end);
                        _packO.ENDT:=exec('tm_stamp2time','#tm_stamp',_coop_end)
                     ?}
                  |? _grop_pr<1
                  ||
::                   obsluga grup operacji na zleceniu ktore ma przewodniki
::                   pobieram proporcje ktora sluzyc ma do skorygowania ilosci ktora jest zaplanowana
                     _packO.COOP:=0;
                     _grop_start:=exec('planned_grop_s','px_stage',PX_STAGE.ref());
                     _grop_end:=exec('planned_grop_e','px_stage',PX_STAGE.ref());
                     _packO.TM_START:=_grop_start;
                     _packO.TM_END:=_grop_end;
                     _packO.STARTD:=exec('tm_stamp2date','#tm_stamp',_grop_start);
                     _packO.STARTT:=exec('tm_stamp2time','#tm_stamp',_grop_start);
                     _packO.ENDD:=exec('tm_stamp2date','#tm_stamp',_grop_end);
                     _packO.ENDT:=exec('tm_stamp2time','#tm_stamp',_grop_end)
                  || _packO.COOP:=0;
                     _packO.TM_START=0;
                     _packO.TM_END:=0;
                     _packO.STARTD:=date(0,0,0);
                     _packO.STARTT:=time(0,0,0);
                     _packO.ENDD:=date(0,0,0);
                     _packO.ENDT:=time(0,0,0)
                  ?};


                  _packO.REF_KONT:=$PX_OPER.PX_KONT;
                  _packO.REF_KONM:=ref_name(PX_OPER.PX_KONT);
                  _packO.REF_KONR:=#PX_OPER.PX_KONT;

                  _packO.ALIGNMEN:=PX_STAGE.ALIGNMEN;
                  _packO.NAKL_PRC:=PX_STAGE.NAKL_PRC;
                  _packO.NKO:=PX_STAGE.NKO*exec('hour','#tm_stamp');
                  _packO.TTM:=PX_STAGE.TTM*exec('hour','#tm_stamp');

::                Wspolczynnik dla zuzyc wyznaczony na podstawie XJM
                  _coef:=_eggs.Qcoef;
                  {? PX_OPER.CONST='T'
                  ||
::                   Zuzycia zawsze stale - niezalezne od XJM
                     _coef:=1
                  ?};

                  {! _dim:=0..PX_OPER.PX_KONT().IL_WYM-1
                  |! PX_OPER.PX_KONT();
                     _prec:=PX_KONT[PxTabPar.PX_KONT.PREC+_dim];
:: NUCO - obsługa czasu wg. ukrętu i parametrów operacji                     
                     {? var_press('q_px')<0 || exec('q_init','qtpp') ?};
                     q_px.zeruj();
                     q_px.PROP:=_eggs.Qcoef;
                     q_px.ILOSC:=_packO[_packp.CAP_DIM];
                     _packO[_packp.CAP_DIM+_dim]:=({? PX_OPER[PxTabPar.PX_OPER.CAPFUSE+_dim]<>''
                                                   || xpar.calc(PX_OPER[PxTabPar.PX_OPER.CAPFUSE+_dim])
                                                   || PX_OPER[PxTabPar.PX_OPER.CAP_USE+_dim]
                                                   ?}*_coef*_grop_pr
                                                  )$_prec;

                     _packO[_packp.CAP_MIN+_dim]:=({? PX_OPER[PxTabPar.PX_OPER.CAPFMIN+_dim]<>''
                                                   || xpar.calc(PX_OPER[PxTabPar.PX_OPER.CAPFMIN+_dim])
                                                   || PX_OPER[PxTabPar.PX_OPER.CAP_MIN+_dim]
                                                   ?}
                                                  )$_prec;

                     _packO[_packp.CAP_MAX+_dim]:=({? PX_OPER[PxTabPar.PX_OPER.CAPFMAX+_dim]<>''
                                                   || xpar.calc(PX_OPER[PxTabPar.PX_OPER.CAPFMAX+_dim])
                                                   || PX_OPER[PxTabPar.PX_OPER.CAP_MAX+_dim]
                                                   ?}
                                                  )$_prec;
::                   NUCO - Dosumowuje czas TPZ * ilość ukrętów/przewodników - czas dosumowywyany jest do jednostki
::                          czasu maszynowego.
                     {? ($('PX_KONT.JM'+$(_dim+1)+'().KOD'))()=exec('get','#params',500381,2)
                     || _packO[_packp.CAP_DIM+_dim]:=(_packO[_packp.CAP_DIM+_dim]+(PX_STAGE.TPZ*q_px.TPZ))$_prec
                     ?};
                     q_px.zeruj();
                     ~~
                  !};

                  {? _coop_start>0 & _coop_end>0 & PX_VAR.NAST_ALG=2 & exec('is_koop','px_kont',PX_OPER.PX_KONT)
                  || _duration:=_coop_end-_coop_start;
                     _packO[_packp.CAP_DIM]:=_duration/exec('hour','#tm_stamp');
                     _packO[_packp.CAP_MAX]:=0
                  ?};

::                teraz wyczyscimy pozostale wymiary
                  {! _dim:=PX_OPER.PX_KONT().IL_WYM..PxTabPar.il_wym-1
                  |! _packO[_packp.CAP_DIM+_dim]:=0;
                     _packO[_packp.CAP_MIN+_dim]:=0;
                     _packO[_packp.CAP_MAX+_dim]:=0;
                     ~~
                  !};

                  _refpackO:=_eggs.PxPack.add(_packO);
                  _stage.add(_packS.PX_STAGE
                            ,$_refpackO
                            ,#_parentS
                            ,_packS.SYMBOL
                            ,_packS.NUM
                            ,_eggs.PxPack.Paczka.UID
                            ,_packO.SYMBOL);
                  PX_OPER.next()
               !}

            |? _eggs.PxPack.Paczka.seek(_parentB)
            || _eggs.PxPack.Paczka.del()
            ?}
         ?}
      ?};

      {? _eggs.PxMAT
      ||
         _packB.PARENT:=#_parentS;
         _packB.SYMBOL:='Surowce';
         _packB.NAZWA:='Surowce etapu '+form(PX_STAGE.NR,_form_dokl);
         _packB.BRANCH:='T';
         _packB.TYP:='B';
         _packB.LEVEL:=1;
         _packB.PL_FORCE:=_eggs.PL_FORCE;
         _packB.ILOSC:=_eggs.Quantity;
         _packB.NUM_STAG:=PX_STAGE.NR;

         _packB.PX_STAGE:=$PX_STAGE.ref();
         _packB.PX_STAGM:=PX_STAGE.name();
         _packB.PX_STAGR:=#PX_STAGE.ref();

         _parentB:=_eggs.PxPack.add(_packB);

         {? _parentB<>null()
         ||
::          --- Surowce dla etapu
            PX_MAT.prefix(PX_STAGE.ref());
            {? PX_MAT.first()
            || {!
               |?
                  _packM.PARENT:=#_parentB;
                  _packM.SYMBOL:=PX_MAT.M().KTM;
                  _packM.NAZWA:=M.N;
                  _packM.BRANCH:='N';
                  _packM.TYP:='M';
                  _packM.LEVEL:=2;
                  _packM.ILOSC:=_eggs.Quantity;
                  _packM.PL_FORCE:=_eggs.PL_FORCE;
                  _packM.NUM:=_packS.NUM;
                  _packM.NUM_STAG:=_packS.NUM_STAG;

                  _packM.DIR:=_eggs.Directio;
                  _packM.PX_STAGE:=$PX_STAGE.ref();
                  _packM.PX_STAGM:=PX_STAGE.name();
                  _packM.PX_STAGR:=#PX_STAGE.ref();

                  _packM.MATERIAL:=$PX_MAT.M;
                  _il:=PX_MAT.IL*_eggs.Qcoef;
                  _packM.NORMA:={? M.DOKL=0 || ceil(_il) || _il$M.DOKL ?};

                  _eggs.PxPack.add(_packM);

                  PX_MAT.next()
               !}
            |? _eggs.PxPack.Paczka.seek(_parentB)
            || _eggs.PxPack.Paczka.del()
            ?}
         ?}
      ?}

   ?};
   _eggs.PX_STAGE=null() & PX_STAGE.next()
!};

{? _stage.tab.first()
||
   {!
   |? _px_stage:=exec('FindAndGet','#table',PX_STAGE,_stage.tab.REF,,,null());
      _ref:=_stage.tab.ref();
      _uid:=_stage.tab.UID;
      _parent:=_stage.tab.PARENT;
      _etap:=_stage.tab.ETAP;
      _num:=_stage.tab.NUM;
      _zasob:=_stage.tab.ZASOB;
      Cntx.psh(_stage.tab,PX_NAST,PX_STAGE);
      PX_NAST.index('PX');
      PX_NAST.prefix(_px_stage);
      {? PX_NAST.first()
      ||
::       są nastepniki, ale trzeba sprawdzic czy nie pochodzi z innego podzlecenia
         _stage.tab.prefix($PX_NAST.PX_NEXT);
         {? _stage.tab.first()
         ||
::          jest w analizowanej dziedzinie
            _packB.PARENT:=_parent;
            _packB.SYMBOL:='Następnik';
            _packB.NAZWA:='Następnik etapu '+form(_num,_form_dokl);
            _packB.BRANCH:='T';
            _packB.TYP:='B';
            _packB.LEVEL:=1;
            _packB.PL_FORCE:=_eggs.PL_FORCE;
            _packB.ILOSC:=_eggs.Quantity;

            _packB.PX_STAGE:=$_px_stage;
            _packB.PX_STAGM:=8+$_px_stage;
            _packB.PX_STAGR:=#_px_stage;

            _packB.UID:=0;
            _packB.NUM_STAG:=_num;

            _parentB:=_eggs.PxPack.add(_packB);
            {? _parentB<>null()
            ||
               _stage.tab.cntx_psh();
               _stage.tab.prefix();
               {? _stage.tab.seek(_ref)
               ||
                  _eggs.PxPack.Paczka.cntx_psh();
                  _eggs.PxPack.Paczka.prefix();
::                Aktualizuje rekord zasobu, mówiąc mu że ma następniki
                  {? _eggs.PxPack.Paczka.seek(_stage.tab.REFZ)
                  || _eggs.PxPack.Paczka.HAS_NEXT:='T';
                     _eggs.PxPack.Paczka.put()
                  ?};

::                Aktualizuje rekord etapu mówiąc mu że ma następniki
                  {? _eggs.PxPack.Paczka.seek(_parent)
                  || _eggs.PxPack.Paczka.HAS_NEXT:='T';
                     _eggs.PxPack.Paczka.put()
                  ?};
                  _eggs.PxPack.Paczka.cntx_pop()
               ?};
               _stage.tab.cntx_pop();

               {!
               |? _stage.tab.prefix($PX_NAST.PX_NEXT);
                  _stage.tab.first();
                  _packN.PARENT:=_parentB;
                  _packN.SYMBOL:=_stage.tab.ETAP;
                  _packN.NAZWA:=_stage.tab.ZASOB;
                  _packN.TYP:='N';
                  _packN.LEVEL:=2;
                  _packN.PL_FORCE:=_eggs.PL_FORCE;
                  _packN.ILOSC:=_eggs.Quantity;

                  _packN.PX_STAGE:=$PX_NAST.PX_NEXT;
                  _packN.PX_STAGM:=8+$PX_NAST.PX_NEXT;
                  _packN.PX_STAGR:=#PX_NAST.PX_NEXT;
                  _packN.NUM_STAG:=PX_NAST.PX_NEXT().NR;

                  _packN.NUM:=_num;
                  _packN.UID:=_stage.tab.UID;

                  _eggs.PxPack.add(_packN);
                  PX_NAST.next()
               !}
            ?}
         ?}
      ?};
      PX_NAST.index('NEXT');
      PX_NAST.prefix(_px_stage);
      {? PX_NAST.first()
      ||
::       są poprzedniki, ale trzeba sprawdzic czy nie pochodzi z innego podzlecenia
         _stage.tab.prefix($PX_NAST.PX_STAGE);
         {? _stage.tab.first()
         ||
::          jest w analizowanej dziedzinie
            _packB.PARENT:=_parent;
            _packB.SYMBOL:='Poprzednik';
            _packB.NAZWA:='Poprzednik etapu '+form(_num,_form_dokl);
            _packB.BRANCH:='T';
            _packB.TYP:='B';
            _packB.LEVEL:=1;
            _packB.PL_FORCE:=_eggs.PL_FORCE;
            _packB.ILOSC:=_eggs.Quantity;

            _packB.PX_STAGE:=$_px_stage;
            _packB.PX_STAGM:=8+$_px_stage;
            _packB.PX_STAGR:=#_px_stage;
            _packB.NUM_STAG:=_num;

            _packB.UID:=0;

            _parentB:=_eggs.PxPack.add(_packB);
            {? _parentB<>null()
            ||
               _stage.tab.cntx_psh();
               _stage.tab.prefix();
               {? _stage.tab.seek(_ref)
               ||
                  _eggs.PxPack.Paczka.cntx_psh();
                  _eggs.PxPack.Paczka.prefix();
::                Aktualizuje rekord zasobu, mówiąc mu że ma poprzedniki
                  {? _eggs.PxPack.Paczka.seek(_stage.tab.REFZ)
                  || _eggs.PxPack.Paczka.HAS_PREV:='T';
                     _eggs.PxPack.Paczka.put()
                  ?};

::                Aktualizuje rekord etapu mówiąc mu że ma poprzedniki
                  {? _eggs.PxPack.Paczka.seek(_parent)
                  || _eggs.PxPack.Paczka.HAS_PREV:='T';
                     _eggs.PxPack.Paczka.put()
                  ?};
                  _eggs.PxPack.Paczka.cntx_pop()
               ?};
               _stage.tab.cntx_pop();

               {!
               |? _stage.tab.prefix($PX_NAST.PX_STAGE);
                  _stage.tab.first();
                  _packP.PARENT:=_parentB;
                  _packP.SYMBOL:=_stage.tab.ETAP;
                  _packP.NAZWA:=_stage.tab.ZASOB;
                  _packP.TYP:='P';
                  _packP.LEVEL:=2;
                  _packP.PL_FORCE:=_eggs.PL_FORCE;
                  _packP.ILOSC:=_eggs.Quantity;

                  _packP.PX_STAGE:=$PX_NAST.PX_STAGE;
                  _packP.PX_STAGM:=8+$PX_NAST.PX_STAGE;
                  _packP.PX_STAGR:=#PX_NAST.PX_STAGE;
                  _packP.NUM_STAG:=PX_NAST.PX_STAGE().NR;

                  _packP.NUM:=_num;
                  _packP.UID:=_stage.tab.UID;

                  _eggs.PxPack.add(_packP);
                  PX_NAST.next()
               !}
            ?}
         ?}
      ?};

      Cntx.pop(_stage.tab,PX_NAST,PX_STAGE);
      _stage.tab.next()
  !}
?};

PX_OPER.cntx_pop();
PX_KONT.cntx_pop();
_eggs.PxPack.ErrCode:=0;
~~

