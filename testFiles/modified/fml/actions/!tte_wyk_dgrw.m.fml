:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: !tte_wyk_dgrw.fml
:: Utworzony: 01.04.2016
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły czynności TTE_WYK_DGRW - Rozliczenie surowców nielimit.
::                                             (Generowanie rozliczenia dla surowców nielimitowanych)
::            UWAGA: w przypadku modyfikacji uwzględniać też czynności: TTE_WYK_DGRO, TTE_WYK_DGZW.
::======================================================================================================================

\main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Główna formuła czynności generowania rozliczenia dla surowców nielimitowanych (TTE_WYK_DGRW)
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_int:=params_get().int;
_out:=params_get().out;
_mp:=params_get().mp;
_context:=params_get().context;

::# permissions=ODDZ,LMG
::# parses=exec('parses','!tte_wyk_dgrw')
::# properties=SERVICE,LOOP
::# condition=Rejestracja dokumentu wydania, act_uid=LMG_MAG_DWYD, auto=T, formula=_a.ND<>~~ & _a.ND<>null()

:: PARAMETRY WE:
::# kind=WE, symbol=ZL, type=_ZL, name=Zlecenie, required=N, keyref=T
::# kind=WE, symbol=ZGP, type=_ZGP, name=Pozycja przewodnika zlecenia, required=N, keyref=T
::# kind=WE, symbol=ILOSC, type=NUMBER, name=Ilość produktu, required=N, keyref=N
::# kind=WE, symbol=ND, type=_ND, name=Dokument raportujący, required=N, keyref=T
::# kind=WE, symbol=TYPYDOK, type=_TYPYDOK, name=Typ dokumentu rozchodowego, required=N, keyref=N, fml_val="exec('typ_dok','!tte_wyk_dgrw')", fml_exp="exec('typydok_export','magdok_nag',_a)"
::# kind=WE, symbol=GEN_DOK, type=STRING, name=Generacja dokumentów, required=N
::# kind=WE, symbol=TYPROZ, type=NUMBER, name=Sposób rozliczenia surowców, required=N
::# kind=WE, symbol=GROP, type=_GROP, name=Grupa operacji, required=N, keyref=T
{? var_pres('ZL',_in)<>type_of(~~) & var_pres('ZL',_in)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRW','ZL']);
   return()
|? _in.ZL=~~
|| _in.ZL:=null()
?};
{? var_pres('ZGP',_in)<>type_of(~~) & var_pres('ZGP',_in)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRW','ZGP']);
   return()
|? _in.ZGP=~~
|| _in.ZGP:=null()
?};
{? var_pres('ILOSC',_in)<>type_of(~~) & var_pres('ILOSC',_in)<>type_of(0)
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRW','ILOSC']);
   return()
|? _in.ILOSC=~~
|| _in.ILOSC:=0
?};
{? var_pres('ND',_in)<>type_of(~~) & var_pres('ND',_in)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRW','ND']);
   return()
|? _in.ND=~~
|| {? _mp.akcja()='GENERUJ'
   || _in.ND:=_context.ND
   || _in.ND:=null()
   ?}
?};
{? var_pres('TYPYDOK',_in)<>type_of(~~) & var_pres('TYPYDOK',_in)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRW','TYPYDOK']);
   return()
|? _in.TYPYDOK=~~
|| _in.TYPYDOK:=null()
?};
{? var_pres('GEN_DOK',_in)<>type_of(~~) & var_pres('GEN_DOK',_in)<>type_of('')
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejsciowego %2).'@['TTE_WYK_DGRW','GEN_DOK']);
   return()
|? _in.GEN_DOK=~~
|| _in.GEN_DOK:=''
?};
{? var_pres('TYPROZ',_in)<>type_of(~~) & var_pres('TYPROZ',_in)<>type_of(0)
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRW','TYPROZ']);
   return()
|? _in.TYPROZ=~~
|| _in.TYPROZ:=0
?};
{? var_pres('GROP',_in)<>type_of(~~) & var_pres('GROP',_in)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wejściowego %2).'@['TTE_WYK_DGRW','GROP']);
   return()
|? _in.GROP=~~
|| _in.GROP:=null()
?};

:: PARAMETRY WEW:
::# kind=WEW, symbol=ND, type=_ND, name=Dokument rozchodowy, required=N
{? var_pres('ND',_int)<>type_of(~~) & var_pres('ND',_int)<>type_of(null())
|| FUN.emsg('Nieprawidłowa definicja czynności %1 (brak parametru wewnętrznego %2).'@['TTE_WYK_DGRW','ND']);
   return()
|? _int.ND=~~
|| _int.ND:=null()
?};

:: PARAMETRY WY:
::# kind=WY, symbol=ZL, type=_ZL, name=Zlecenie, required=N
::# kind=WY, symbol=ND, type=_ND, name=Dokument rozchodowy, required=N
::# kind=WY, symbol=GEN_DOK, type=STRING, name=Generacja dokumentów, required=N
::# kind=WY, symbol=RESULT, type=STRING, name="Wynik czynności (OK, BŁĄD)", required=N

:: Ustawiam wartość domyślną argumentu LOOP żeby brama się nie zawiesiła
_mp.save(exec('kind_out','#b_port'),'LOOP','N');

:: Czy komunikaty walidacji na ekran
_display:={? _mp.isService() || 0 || 1 ?};

:: WSTĘPNE WALIDACJE
_clean_result:=params_exec('clean','!tte_wyk_dgrw',_mp,_in);
_can_continue:=_clean_result.RESULT;
_zl:=_clean_result.ZL;
{? _can_continue=0
|| return()
?};

:: Zlecenie musi być produkcyjne
{? _in.ZL<>null() & exec('FindAndGet','#table',ZL,_in.ZL,,"TYP().WP='W'",1)
|| _msg:='Błędna konfiguracja procesu — zlecenie nie może być warsztatowe.'@@;
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
?};
:: Musi być conajmniej jeden parametr przekazany (chyba, że jest już coś wygenerowane, czyli _int.ND<>null())
:: (chyba, że uruchomienie jako czynność startowa z pulpitu)
{? _in.ND=null() & _in.ZGP=null() & _in.ZL=null() & _in.GROP=null() & _in.GEN_DOK='' & _int.ND=null() & ~_mp.pathProc()
|| _msg:='Błędna konfiguracja procesu — brak parametru wejściowego (musi być określony %1, %2, %3 albo %4).'@@
         ['ND','ZGP','GROP','GEN_DOK'];
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
?};
:: Nie może być jednocześnie pozycja przewodnika i dokument
{? _in.ND<>null() & _in.ZGP<>null()
|| _msg:='Błędna konfiguracja procesu — nie może być przekazany jednocześnie dokument raportujący i pozycja przewodnika.'@@;
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
?};
:: Nie może być jednocześnie grupa operacji i dokument
{? _in.ND<>null() & _in.GROP<>null()
|| _msg:='Błędna konfiguracja procesu — nie może być przekazany jednocześnie dokument raportujący i grupa operacji.'@@;
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
?};

:: Walidacja typu dokumentu
{? _in.TYPYDOK
|| _in_typ:=exec('FindAndGet','#table',TYPYDOK,_in.TYPYDOK,,"T",'');
   {? (' '+exec('get','#params',500707,2))*(' '+_in_typ+' ')=0
   || _msg:='Błędna konfiguracja procesu — przekazany typ dokumentu %1 nie jest wskazany w parametrze %2.'@@
            [_in_typ,'500707'];
      {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
      _mp.error(_msg);
      return()
   ?}
?};
:: Walidacja dokumentu
_nd_zl:=exec('FindAndGet','#table',ND,_in.ND,,"ZL",null());
{? _in.ND
|| {? _nd_zl=null()
   || _msg:='Błędna konfiguracja procesu — przekazany dokument nie jest powiązany ze zleceniem.'@@;
      {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
      _mp.error(_msg);
      return()
   ?}
?};
:: Zgodność dokumentu ze zleceniem
{? _in.ZL<>null() & _in.ND<>null() & _in.ZL<>_nd_zl
|| _msg:='Błędna konfiguracja procesu — przekazany dokument dotyczy innego zlecenia niż przekazane.'@@;
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
|? _in.ZL=null()
|| _in.ZL:=_nd_zl
?};
:: Zgodność pozycji przewodnika ze zleceniem
_zgp_zl:=exec('FindAndGet','#table',ZGP,_in.ZGP,,"ZL",null());
{? _in.ZL<>null() & _in.ZGP<>null() & _in.ZL<>_zgp_zl
|| _msg:='Błędna konfiguracja procesu — przekazana pozycja przewodnika dotyczy innego zlecenia niż przekazane.'@@;
   {? _display || {? _mp.isGroup() || KOMM.add(_msg) || FUN.emsg(_msg) ?} ?};
   _mp.error(_msg);
   return()
|? _in.ZL=null()
|| _in.ZL:=_zgp_zl
?};
:: Czynność w trybie usługi musi dotyczyć konkretnego dokumentu raportującego albo przewodnika
{? _mp.isService() & ~_in.ND & ~_in.ZGP & _in.GEN_DOK=''
|| _msg:='Błędna konfiguracja procesu — nie przekazano dokumentu ani przewodnika.'@@;
   _mp.error(_msg);
   return()
?};

_mp.keyRef(exec('FindAndGet','#table',ZL,_in.ZL,,"uidref()",''));

_zl_sym:=exec('FindAndGet','#table',ZL,_in.ZL,,"SYM",'');

:: Przekazany parametr _int.ND, czyli powstały już dokumenty raportujące, ale czynność się nie zakończyła
:: (np. zamknięcie programu "krzyzykiem")
{? _mp.loop()=0 & _int.ND
|| _gen_dok:=exec('FindAndGet','#table',ND,_int.ND,,"GRP_KEY",'');
:: Zapisanie parametru wyjściowego ND, wykluczenie kolejnej realizacji z pętli, zakończenie czynności
   {? _gen_dok<>''
   ||
      ND.cntx_psh();
      ND.prefix();
      _grp_key:=_gen_dok-1;
      _grp_key_on:=_grp_key+'1';
      _grp_key_off:=_grp_key+'0';
      {? _grp_key<>''
      || ND.index('GRP_KEY');
         ND.prefix(_grp_key_on);
         {? ND.first()
         || ND.cntx_psh();
            ND.prefix();
            ND.GRP_KEY:=_grp_key_off;
            do();
            ND.put();
            _mp.save(exec('kind_out','#b_port'),'ND',ND.ref());
            _mp.save(exec('kind_out','#b_port'),'GEN_DOK',_gen_dok);
            _mp.save(exec('kind_out','#b_port'),'RESULT','OK');
            end();
            ND.cntx_pop();
::          kontynuacja pętli
            {? ND.first()
            || _mp.loop_continue()
            ?}
         ?}
      ?};
      ND.cntx_pop();
      _mp.done()
   ?}

:: Przekazany tylko parametr _in.ZL, wejście z ToDo, czyli wyświetlenie panela do rozliczania
|? _in.ZL & ~_in.ND & ~_in.ZGP & ~_in.GROP & _mp.pathTodo()
|| ZL.cntx_psh();
   ZL.prefix();
   {? ZL.seek(_in.ZL)
   || __ENV_GEN:=exec('env_gen','zl_limit','NLI');
      {? ZL.STAN<>'O'
      || FUN.emsg('Zlecenie do rozliczenia musi być otwarte.'@)
      || KOMM.init(,,'Rozliczenie surowców'@);
         exec('find_nd','zl_nlimit');
         exec('select_gen','zl_limit')
      ?};
      VAR_DEL.delete('__ENV_GEN')
   ?};
   ZL.cntx_pop()

:: Przekazany tylko parametr _in.GROP, wejście z ToDo, czyli wyświetlenie panela do rozliczania
|? ~_in.ZL & ~_in.ND & ~_in.ZGP & _in.GROP & _mp.pathTodo()
|| GROP.cntx_psh();
   GROP.prefix();
   {? GROP.seek(_in.GROP)
   || __ENV_GEN:=exec('env_gen','zl_limit','NLI_GROP');
      {? GROP.AKC<>'T' | GROP.STATUS<>'O'
      || FUN.emsg('Grupa operacji do rozliczenia musi być zaakceptowana i otwarta.'@)
      || KOMM.init(,,'Rozliczenie surowców'@);
         exec('find_zlgd','zl_grop');
         exec('select_gen_zlgd','zl_limit')
      ?};
      VAR_DEL.delete('__ENV_GEN')
   ?};
   GROP.cntx_pop()

:: Przekazany parametr _in.ND, czyli generowanie dokumentów rozliczających do dokumentu raportującego
:: Przekazany parametr _in.ZGP, czyli generowanie dokumentów rozliczających do pozycji przewodnika
:: Przekazany parametr _in.GROP, czyli generowanie dokumentów rozliczających do grupy operacji
:: Kolejny obrót pętli generatora, czyli wypychanie wygenerowanych dokumentów
|? _in.ND | _in.ZGP | _in.GROP | _in.ZL | _mp.loop()>0
||
:: Wyzwalacz, który po dodaniu/aktualizacji/usunięciu nagłówka dokumentu rozliczającego
:: dodaje/usuwa/aktualizuje parametr wewnętrzny _int.ND (aktualizacja nie dotyczy dokumentu źródłowego)
   _nd_uid:=exec('FindAndGet','#table',ND,_in.ND,,"uidref()",'');
   _mp.trigRef('ND',,1,,exec('kind_internal','#b_port'),'ND',,$('ND.uidref()<>\''+_nd_uid+'\''));

   _continue:=0;
   _gen_dok:='';
   _typydok:={? var_pres('TYPYDOK',_in)=type_of(null()) || _in.TYPYDOK || null() ?};

:: pierwsze wywołanie dla dokumentu raportującego
   {? _mp.loop()=0 & _in.ND
   ||
      ND.cntx_psh();
      _jest:=ND.seek(_in.ND);
      {? ~_jest || ND.prefix(); _jest:=ND.seek(_in.ND) ?};
      {? ~_jest
      || _mp.error('Nie znaleziono dokumentu raportującego.')
      |? _jest & ND.STAT_REJ<>'T'
      || _msg:='Dokument raportujący %1 nie został zaakceptowany'@[ND.SYM];
         {? _mp.isGroup() || KOMM.add(_msg) || FUN.info(_msg) ?};
         _continue:=-1
      |? _jest & exec('rozliczone','zl_limit',ND.ref(),'N')
      || _msg:='Do dokumentu raportującego %1 zostały już wystawione dokumenty rozliczające.'@[ND.SYM];
         {? _mp.isGroup() || KOMM.add(_msg) || FUN.info(_msg) ?};
         _continue:=-2
      ||
         {? _mp.akcja()='GENERUJ'
         || params_set('env_gen',_mp.context.ENV_GEN);
            _tm_stamp:=exec('gen_ra','zl_nlimit',_in.TYPYDOK);

            {? _tm_stamp='y'
            || _continue:=-3
            || _internal:=_mp.load(exec('kind_internal','#b_port'));
               _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
               {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
            ?}

         |? _mp.isAutoRun()
            | _mp.isService()
            | _mp.pathTodo()
         ||
            KOMM.init(250,,'Generowanie rozliczenia surowców'@);

            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            ||
::              Jeżeli jest typ domyślny lub tylko 1 typ dokumentu RW to go pobiera, w innym przypadku wyświetla listę
               _in.TYPYDOK:=exec('Get_TYPYDOK','magdok_wspolne','NLI');
               {? _in.TYPYDOK=null
               || _in.TYPYDOK:=exec('typ_dok','!tte_wyk_dgrw')
               ?}
            ?};

            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            || _continue:=-1
            ||
               do();
               DK.cntx_psh();
               _tm_stamp:=exec('utwdok','zl_nlimit',_in.TYPYDOK,'NLI',_in.TYPROZ);
               {? _tm_stamp='' || undo() ?};
               DK.cntx_pop();
               end();

               {? _tm_stamp='y'
               || _continue:=-3
               || _internal:=_mp.load(exec('kind_internal','#b_port'));
                  _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
                  {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
               ?}
            ?};

            {? _mp.isAutoRun() || {? _continue<>1 || KOMM.select() ?}
            |? _mp.pathTodo() || KOMM.select()
            ?}

         || _mp.error('Nieobsługiwana ścieżka wywołania czynności %1.'@@['TTE_WYK_DGRW/ND'])
         ?}
      ?};
      ND.cntx_pop()

:: pierwsze wywołanie dla pozycji przewodnika
   |? _mp.loop()=0 & _in.ZGP
   ||
      ZGP.cntx_psh();
      _jest:=ZGP.seek(_in.ZGP);
      {? ~_jest || ZGP.prefix(); _jest:=ZGP.seek(_in.ZGP) ?};
      {? ~_jest
      || _mp.error('Nie znaleziono pozycji przewodnika.'@@)
      ||
::----------------------------------------------------------------------------------------------------------------------
:: NUCO - Merit_2325_test - modyfikacja:  2024 Lut 09 14:55
:: TP, opis : uzupełnienie VAR.A_ZLEC
::----------------------------------------------------------------------------------------------------------------------
         VAR.A_ZLEC:=ZGP.ZL;
::----------------------------------------------------------------------------------------------------------------------
         {? _mp.akcja()='GENERUJ'
         || params_set('env_gen',_mp.context.ENV_GEN);
            _tm_stamp:=exec('gen_ra','zl_nlimit',_in.TYPYDOK);

            {? _tm_stamp='y'
            || _continue:=-3
            || _internal:=_mp.load(exec('kind_internal','#b_port'));
               _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
               {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
            ?}
         |? _mp.isAutoRun()
            | _mp.isService()
            | _mp.pathTodo()
         ||
            KOMM.init(250,,'Generowanie rozliczenia surowców'@);

::            {? _in.ILOSC=0
::            ||
::             Czynność się kończy mimo braku ilości - żaden dokument nie jest generowany
::               KOMM.add('Nie podano ilości. Dokumenty nie zostały utworzone.'@,4,,1);
::               _mp.done()
::            ||
            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            ||
::             Jeżeli jest typ domyślny lub tylko 1 typ dokumentu RW to go pobiera, w innym przypadku wyświetla listę
               _in.TYPYDOK:=exec('Get_TYPYDOK','magdok_wspolne','NLI');
               {? _in.TYPYDOK=null
               || _in.TYPYDOK:=exec('typ_dok','!tte_wyk_dgrw')
               ?}
            ?};

            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            || _continue:=-1
            ||
               _ZLIM:='';
               _ok:=1;
               {? ~_mp.isAutoRun() & ~_mp.isService()
               || _ZLIM:=exec('kart_lim','zl_limit',9,ZGP.ZL,'N',,ZGP.ref(),,'T');
                  {? _in.TYPROZ
                  || _ndx:=_ZLIM.ndx_tmp(,,'ROZ',,);
                     _ZLIM.index(_ndx);
                     _ZLIM.prefix('T')
                  || _ZLIM.prefix()
                  ?};
                  {? _ZLIM.size()>0
                  ||
                     _form:="
                        _tab:=cur_tab(1,1);
                        _res:=_tab.MAG;
                        MG.cntx_psh();
                        MG.win_sel('SLO');
                        MG.index('MAG');
                        MG.prefix();
                        {? MG.first()
                        ||
                           {? MG.select(,,10)
                           ||
                              _tab.MAG_REF:=#MG.ref;
                              _res:=_tab.MAG:=MG.SYM;
                              _tab.put()
                           ?}
                        ||
                           FUN.info('Nie odnaleziono żadnych magazynów.'@)
                        ?};
                        MG.cntx_pop();
                        _res
                     ";

                     _bf:=_ZLIM.fld_fml('MAG','F3',_form);
                     _wer:=exec('__ZLIM_wer','!tte_wyk_dgrw',_ZLIM);
                     _ZLIM.win_sel(_wer);
                     {? ~_ZLIM.select()
                     || _ok:=0;
                        _continue:=-1
                     ?};
                     _ZLIM.fld_fml('MAG','F3',_bf)
                  ?}
               ?};
               {? _ok
               ||
                  do();
                  DK.cntx_psh();
                  _tm_stamp:='';
                  _tm_stamp:=exec('utwdok_zgp','!tte_wyk_dgrw',_in.TYPYDOK,ZGP.ref(),_in.ILOSC,_in.TYPROZ,_ZLIM);
                  {? _tm_stamp='' || undo() ?};
                  DK.cntx_pop();
                  end();

                  {? _tm_stamp='y'
                  || _continue:=-3
                  || _internal:=_mp.load(exec('kind_internal','#b_port'));
                     _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
                     {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
                  ?};
::            ?};

                  {? _mp.pathTodo() | _mp.isAutoRun() & _continue<>1 || KOMM.select() ?};
::                Czynność zawsze się kończy, bez względu na ilość/jakość wygenerowanych dokumentów
                  _mp.done()
               ?}
            ?}

         || _mp.error('Nieobsługiwana ścieżka wywołania czynności %1.'@@['TTE_WYK_DGRW/ZGP'])
         ?}
      ?};
      ZGP.cntx_pop()

:: pierwsze wywołanie dla grupy operacji
   |? _mp.loop()=0 & _in.GROP
   ||
      GROP.cntx_psh();
      _jest:=GROP.seek(_in.GROP);
      {? ~_jest || GROP.prefix(); _jest:=GROP.seek(_in.GROP) ?};
      {? ~_jest
      || _mp.error('Nie znaleziono grupy operacji.'@@)
      ||
         {? _mp.akcja()='GENERUJ'
         || params_set('env_gen',_mp.context.ENV_GEN);
            _tm_stamp:=exec('gen_ra','zl_nlimit',_in.TYPYDOK);

            {? _tm_stamp='y'
            || _continue:=-3
            || _internal:=_mp.load(exec('kind_internal','#b_port'));
               _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
               {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
            ?}
         |? 0
::            _mp.isAutoRun()
::            | _mp.isService()
::            | _mp.pathTodo()
         ||
            KOMM.init(250,,'Generowanie rozliczenia surowców'@);

::            {? _in.ILOSC=0
::            ||
::             Czynność się kończy mimo braku ilości - żaden dokument nie jest generowany
::               KOMM.add('Nie podano ilości. Dokumenty nie zostały utworzone.'@,4,,1);
::               _mp.done()
::            ||
            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            ||
::             Jeżeli jest typ domyślny lub tylko 1 typ dokumentu RW to go pobiera, w innym przypadku wyświetla listę
               _in.TYPYDOK:=exec('Get_TYPYDOK','magdok_wspolne','NLI');
               {? _in.TYPYDOK=null
               || _in.TYPYDOK:=exec('typ_dok','!tte_wyk_dgrw')
               ?}
            ?};

            {? ~_in.TYPYDOK & _mp.pathTodo() & ~_mp.isService() & ~_mp.isAutoRun()
            || _continue:=-1
            ||
               _ZLIM:='';
               _ok:=1;
               {? ~_mp.isAutoRun() & ~_mp.isService()
               || _ZLIM:=exec('kart_lim','zl_limit',9,,'N',,null(),,'T',,GROP.ref());
                  {? _in.TYPROZ
                  || _ndx:=_ZLIM.ndx_tmp(,,'ROZ',,);
                     _ZLIM.index(_ndx);
                     _ZLIM.prefix('T')
                  || _ZLIM.prefix()
                  ?};
                  {? _ZLIM.size()>0
                  ||
                     _form:="
                        _tab:=cur_tab(1,1);
                        _res:=_tab.MAG;
                        MG.cntx_psh();
                        MG.win_sel('SLO');
                        MG.index('MAG');
                        MG.prefix();
                        {? MG.first()
                        ||
                           {? MG.select(,,10)
                           ||
                              _tab.MAG_REF:=#MG.ref;
                              _res:=_tab.MAG:=MG.SYM;
                              _tab.put()
                           ?}
                        ||
                           FUN.info('Nie odnaleziono żadnych magazynów.'@)
                        ?};
                        MG.cntx_pop();
                        _res
                     ";

                     _bf:=_ZLIM.fld_fml('MAG','F3',_form);
                     _wer:=exec('__ZLIM_wer','!tte_wyk_dgrw',_ZLIM);
                     _ZLIM.win_sel(_wer);
                     {? ~_ZLIM.select()
                     || _ok:=0;
                        _continue:=-1
                     ?};
                     _ZLIM.fld_fml('MAG','F3',_bf)
                  ?}
               ?};
               {? _ok
               ||
                  do();
                  DK.cntx_psh();
                  _tm_stamp:='';
                  _tm_stamp:=exec('utwdok_zgp','!tte_wyk_dgrw',_in.TYPYDOK,ZGP.ref(),_in.ILOSC,_in.TYPROZ,_ZLIM);
                  {? _tm_stamp='' || undo() ?};
                  DK.cntx_pop();
                  end();

                  {? _tm_stamp='y'
                  || _continue:=-3
                  || _internal:=_mp.load(exec('kind_internal','#b_port'));
                     _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
                     {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
                  ?};
::            ?};

                  {? _mp.pathTodo() | _mp.isAutoRun() & _continue<>1 || KOMM.select() ?};
::                Czynność zawsze się kończy, bez względu na ilość/jakość wygenerowanych dokumentów
                  _mp.done()
               ?}
            ?}

         || _mp.error('Nieobsługiwana ścieżka wywołania czynności %1.'@@['TTE_WYK_DGRW/GROP'])
         ?}
      ?};
      GROP.cntx_pop()

:: pierwsze wywołanie dla zlecenia
   |? _mp.loop()=0 & _in.ZL
   ||
      ZL.cntx_psh();
      _jest:=ZL.seek(_in.ZL);
      {? ~_jest || ZL.prefix(); _jest:=ZL.seek(_in.ZL) ?};
      {? ~_jest
      || _mp.error('Nie znaleziono zlecenia.'@@)
      ||
         {? _mp.akcja()='GENERUJ'
         || params_set('env_gen',_mp.context.ENV_GEN);
            _tm_stamp:=exec('gen_ra','zl_nlimit',_in.TYPYDOK);

            {? _tm_stamp='y'
            || _continue:=-3
            || _internal:=_mp.load(exec('kind_internal','#b_port'));
               _continue:={? var_pres('ND',_internal)=type_of(null()) & _internal.ND || 1 || -1 ?};
               {? _continue=1 || _gen_dok:=exec('FindAndGet','#table',ND,_internal.ND,,"GRP_KEY",'') ?}
            ?}
         || _mp.error('Nieobsługiwana ścieżka wywołania czynności %1.'@@['TTE_WYK_DGRW/ZL'])
         ?}
      ?};
      ZL.cntx_pop()

:: wywołanie w pętli
   || _continue:=_in.GEN_DOK<>'';
      {? _continue || _gen_dok:=_in.GEN_DOK ?}
   ?};

:: Wycofano się z wystawiania dokumentów
   {? _continue=-1
   || {? _mp.isService()
      || _mp.save(exec('kind_out','#b_port'),'RESULT','BŁĄD');
         _mp.done()
      || _mp.cancel()
      ?}

:: Dokumenty rozliczające już wcześniej wystawione
   |? _continue=-2
   || {? _mp.isService()
      || _mp.save(exec('kind_out','#b_port'),'RESULT','OK');
         _mp.done()
      || _mp.done()
      ?}

:: Nie potrzeba generować dokumentów (brak surowców nielimitowanych w definicji zlecenia / grupy operacji)
   |? _continue=-3
   || {? _mp.isService()
      || _mp.save(exec('kind_out','#b_port'),'RESULT','OK');
         _mp.done()
      || _mp.done()
      ?}

:: Zapisanie parametru wyjściowego ND, wykluczenie kolejnej realizacji z pętli, zakończenie czynności
   |? _continue=1 & _gen_dok<>''
   ||
      ND.cntx_psh();
      ND.prefix();
      _grp_key:=_gen_dok-1;
      _grp_key_on:=_grp_key+'1';
      _grp_key_off:=_grp_key+'0';
      {? _grp_key<>''
      || ND.index('GRP_KEY');
         ND.prefix(_grp_key_on);
         {? ND.first()
         || ND.cntx_psh();
            ND.prefix();
            ND.GRP_KEY:=_grp_key_off;
            do();
            ND.put();
            _mp.save(exec('kind_out','#b_port'),'ND',ND.ref());
            _mp.save(exec('kind_out','#b_port'),'GEN_DOK',_gen_dok);
            _mp.save(exec('kind_out','#b_port'),'RESULT','OK');
            end();
            ND.cntx_pop();
::          kontynuacja pętli
            {? ND.first()
            || _mp.loop_continue()
            ?}
         ?}
      ?};
      ND.cntx_pop();
      _mp.done()

   || _mp.error('Brak oczekiwanego parametru %1.'@@['GEN_DOK'])
   ?}

:: Uruchomienie ze startu procesów - tylko dla zleceń
|? _mp.pathProc()
|| ZL.cntx_psh();
   ZL.clear();
   _join:='join ZTP left join ZL as ZLNAD using(ZL.NRNZL,ZLNAD.UNRZL)';
   _where:=
      'ZL.STAN=''O'' and '
      'ZTP.WP=''P'' and '
      'ZL.RODZAJ=''P'' and '
      '(ZL.LEVEL=0 or ZL.LEVEL=1) and '
      '(ZL.NRNZL=0 or ZL.NR=1 or ZLNAD.RODZAJ=''N'') and '
      'ZL.ILDOK>0';
   ZL.f_set('SYM',_join,_where);
   exec('icons_slo_sl','zl_head');
   ZL.win_sel('SLO_SL');
   ZL.actions('SLO_SL','XY','W');
   {? ZL.select()
   || exec('action_rw_generate','!tte_wyk_dgrw')
   ?};
   ZL.cntx_pop()

|| _mp.error('Nieobsługiwana ścieżka wywołania czynności %1.'@@['TTE_WYK_DGRW'])
?};
~~
