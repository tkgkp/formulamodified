:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: qbilans_sur.fml
:: Utworzony: 22.12.2020
:: Autor: TP
:: Systemy:
::======================================================================================================================
:: Zawartość: Formuły do bilansowania surowców dla produkcji.
::======================================================================================================================

\bilans
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS: Funkcja przygotowuje analizyę bilansu surowca dla przekazanego wydziału w zakresie przekazanych dat.
::   WE: _a - args (tabliza zmiennych) wynik funkcji bilans_a
::   WY:
::----------------------------------------------------------------------------------------------------------------------
::debug();
_argp:={? var_press('_a')<0
       || exec('bilans_a','qbilans_sur')
       || _a
       ?};

_loop:=exec('analiza','qbilans_sur',_argp);
{? ~_loop
|| FUN.info('Brak surowców do zbilansowania w zadanym okresie')
?};

{!
|? _loop
|! _loop:=__ENV_AN.TAB.select();
   VAR_DEL.delete('__ENV_AN');
   {? _loop
   || _loop:=exec('analiza','qbilans_sur',_argp)
   ?}
!};
VAR_DEL.delete('__ENV_AN');
~~


\analiza
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS: Funkcja wykonuje analizę na podstawie danych _args
::   WE: _a    - args - parametry analizy
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_argp:={? var_press('_a')<0
       || exec('bilans_a','qbilans_sur')
       || _a
       ?};

_magazyn_do:=_argp.WYD;
_magazyny_z:=_argp.MAG_Z;
_data_od:=_argp.DOD;
_data_do:=_argp.DDO;
_formuly:=_argp.FORM;
_czy_zasoby:=_argp.CZY_ZAS;
_czy_zmiany:=_argp.CZY_ZM;
_czy_zlecenie:=_argp.CZY_ZL;
_czy_bilans:=_argp.CZY_BIL;

:: jeżeli zaznaczono analizę zlecenia i więcej niż jedno zlecenie utworzenie tabeli zleceń do analizy
_zlec:=sql('select ZL.REFERENCE as REF from ZL where 1=0');
{? _czy_zlecenie='T'
|| {? ZL.sel_size()>0
   || _tmp:=ZL.sel_aget();
      ZL.cntx_psh();
      {? _tmp.first()
      || {!
         |? {? ZL.seek(_tmp.REF,_tmp.DBMASK)
            || _zlec.REF:=$ZL.ref();
               _zlec.add()
            ?};
            _tmp.next()
         !}
      ?};
      ZL.cntx_pop()
   || _zlec.REF:=$ZL.ref();
      _zlec.add
   ?};
   _where_zl:={? _zlec.size()>1
              || 'ZL.REFERENCE in (select REF from :_a)'
              || 'ZL.REFERENCE=\''+_zlec.REF+'\''
              ?};
   _surowce:=sql('select ZLIM.REFERENCE as ZLIM_REF,
                      ZLIM.REFERENCE as ZK_P_REF,
                      ZLIM.NR,
                      ZLIM.LIMIT,
                      ZLIM.ZLEC,
                      ZLIM.KOR,
                      ZLIM.KOR2,
                      ZLIM.ZGP,
                      ZLIM.KTM,
                      ZLIM.LIL,
                      to_date(:_b) as STARTD,
                      to_time(\'06:00:00\') as STARTT,
                      to_date(:_b) as PL_DATA,
                      to_time(\'06:00:00\') as PL_TIME,
                      ZLIM.STARTD as STD,
                      ZLIM.STARTT as STT,
                      ZL.SYM as ZL_SYM,
                      MG.SYM as MAG_SYM,
                      ZGH.NRPRZ,
                      TWRKPLC.KOD as ZASOB,
                      TWRKPLC.NA as NZASOB,
                      SPACE(20) as ZMIANA
                 from @ZLIM
                 join MG using(ZLIM.MG, MG.REFERENCE)
                 join M using(ZLIM.KTM, M.REFERENCE)
                 join @ZL using(ZLIM.ZLEC, ZL.REFERENCE)
                 join @ZGP using(ZLIM.ZGP, ZGP.REFERENCE)
                 join @ZGH using(ZGP.NRPRZ, ZGH.REFERENCE)
                 join @TWRKPLC using(ZGP.PLACE, TWRKPLC.REFERENCE)
                where '+_where_zl+
                      ' and (ZLIM.AKC=\'T\' or ZLIM.LIMIT=\'N\') and ZLIM.KOR=0
                       and ZLIM.SO=\'S\'
             order by KTM, STARTD, STARTT
                       ',
                _zlec, _data_od)
||
:: tabela z materiałami do analizy wg zakresu dat
   _surowce:=sql('select ZLIM.REFERENCE as ZLIM_REF,
                      ZLIM.REFERENCE as ZK_P_REF,
                      ZLIM.NR,
                      ZLIM.LIMIT,
                      ZLIM.ZLEC,
                      ZLIM.KOR,
                      ZLIM.KOR2,
                      ZLIM.ZGP,
                      ZLIM.KTM,
                      ZLIM.LIL,
                      ZLIM.STARTD,
                      ZLIM.STARTT,
                      ZL.PL_DATA,
                      ZL.PL_TIME,
                      ZLIM.STARTD as STD,
                      ZLIM.STARTT as STT,
                      ZL.SYM as ZL_SYM,
                      MG.SYM as MAG_SYM,
                      ZGH.NRPRZ,
                      TWRKPLC.KOD as ZASOB,
                      TWRKPLC.NA as NZASOB,
                      SPACE(20) as ZMIANA
                 from @ZLIM
                 join MG using(ZLIM.MG, MG.REFERENCE)
                 join M using(ZLIM.KTM, M.REFERENCE)
                 join @ZL using(ZLIM.ZLEC, ZL.REFERENCE)
                 join @ZGP using(ZLIM.ZGP, ZGP.REFERENCE)
                 join @ZGH using(ZGP.NRPRZ, ZGH.REFERENCE)
                 join @TWRKPLC using(ZGP.PLACE, TWRKPLC.REFERENCE)
                where  (ZLIM.AKC=\'T\' or ZLIM.LIMIT=\'N\') and ZLIM.KOR=0 and MG.SYM=\':_a\'
                       and ZLIM.SO=\'S\' and ZL.ST_O=\'T\' and ZL.PLAN_PO=\'T\'
                       and ZLIM.STARTD between to_date(:_b) and to_date(:_c)
                       and ZGH.STARTD is not null
                order by KTM, STARTD, STARTT',
                _magazyn_do, _data_od, _data_do+1)
?};

:: Weryfikacja czy w planie operacyjnym - jak niepotrzebna usunąć z zapytania
::  and ZL.PLAN_PO=\'T\'

:: Uwzględnienie korekt
_loop:=_surowce.first();
{!
|? _loop
|! _ilosc:=sql('select sum(ZLIM.LIL) as LIL
                  from @ZLIM
                 where ZLIM.ZGP=\':_a\' and ZLIM.LIMIT=\':_b\'
                       and (ZLIM.NR=:_c or ZLIM.KOR=:_c)
                       and (ZLIM.AKC=\'T\' or ZLIM.LIMIT=\'N\')',
                 _surowce.ZGP, _surowce.LIMIT, _surowce.NR
                 ).LIL;
   _surowce.LIL:=_ilosc;
:: Dodanie informacji o numerze zmiany na podstawie startt
   {? _surowce.STARTT>=time(6,0,0) & _surowce.STARTT<time(14,0,0)
   || _surowce.ZMIANA:='Zmiana 1'
   |? _surowce.STARTT>=time(14,0,0) & _surowce.STARTT<time(22,0,0)
   || _surowce.ZMIANA:='Zmiana 2'
   || _surowce.ZMIANA:='Zmiana 3'
   ?};
   _surowce.put();
:: Określenie zapotrzebowań zgodnie ze zmianami (dzień od 06:00 do 06:00 następnego dnia)
   _zakres_zmianowy:=1;
   {? _surowce.STARTD=_data_od & _surowce.STARTT<time(6,0,0)
   || _zakres_zmianowy:=0
   |? _surowce.STARTD=_data_do+1 & _surowce.STARTT>=time(6,0,0)
   || _zakres_zmianowy:=0
   ?};
   {? _ilosc>0 & _zakres_zmianowy & {? _czy_zlecenie='T'
                                    || {? _zlec.size()>0
                                       || sql('select REF from :_a where :_a.REF=\':_b\'',_zlec,_surowce.ZLEC).first()
                                       || 0
                                       ?}
                                    || 1
                                    ?}
   || _zlim:=exec('FindAndGet','#table',ZLIM,_surowce.ZLIM_REF);
      _zk_p:=exec('zlim_zk_p','qbilans_sur',_zlim);
      _zarezerwowano:=exec('FindAndGet','#table',ZK_P,_zk_p,,"ZK_P.SR",0);
      _surowce.LIL:=_ilosc-_zarezerwowano;
::      ref ZK_P do pominięcia przy analizie limitu
      {? _surowce.LIMIT='T' & _zk_p<>null()
      || _surowce.ZK_P_REF:=$_zk_p
      ?};
      {? _czy_zasoby='N'
      || _surowce.ZASOB:=_magazyn_do;
         _surowce.NZASOB:='zapotrzebowanie wydziału'
      ?};
      {? _czy_zmiany='N'
      || _surowce.ZMIANA:='Zmiany 1,2,3'
      ?};
::      Jeśli trzecia zmiana po 24:00 to przestawiamy date wymagalności o jeden dzień wcześniej
::      {? _surowce.STARTT>=time(0,0,0) & _surowce.STARTT<time(6,0,0)
::      || _surowce.STARTD:=_surowce.STARTD-1;
::         _surowce.STARTT:=time(23,59,59)
::      ?};
      _surowce.put();
      _loop:=_surowce.next()
   || _loop:=_surowce.del()
   ?}
!};

:: Tworzy analizę
{? exec('is_pdbuf','plan_dostaw')
||
:: Środowisko analizy
   exec('env_create','qplan_dostaw');
:: Dokładność na oknie wertowania analizy:
   ST.DOKL:=4;
   _loop:=_surowce.first;
   _argse:=exec('an_add_a','qplan_dostaw');
   _args:=exec('pda_a','qplan_dostaw');

:: Wykluczamy rekordy aby analiza była po koleii
   {!
   |? _args.skip_add({?_surowce.LIMIT='T'||_surowce.ZK_P_REF || _surowce.ZLIM_REF ?});
      _argse.skip_add({?_surowce.LIMIT='T'||_surowce.ZK_P_REF || _surowce.ZLIM_REF ?});
      _surowce.next()
   !};
   _surowce.first();
   _ktm:='';
   _il:=0;

   {!
   |? _loop
   |!
      {? _czy_zlecenie='T' & _surowce.STD>_data_do+1
      || {? _ktm<>_surowce.KTM
         || _il:=0;
            _ktm:=_surowce.KTM
         || _il+=_args.IL
         ?}
      ?};

      _args.M:=exec('FindAndGet','#table',M,_surowce.KTM,,"M.ref()", null());
      _args.TM_STAMP:=SYSLOG.tm_stamp();
      _args.DK:=_data_do+1;
      _args.TK:=time(6,0,0);
      _args.IL:=_surowce.LIL-exec('zlim_pob_il','zl_limit',_surowce.ZLIM_REF).IL;

      {? _args.IL>0
      || _args.DW:=_surowce.STARTD;
         _args.TW:=_surowce.STARTT;
         _args.DISP:=0;
         _args.PD_D_ZN:=_formuly;
         _args.MAG_Z:=_magazyn_do;
         _res:=exec('pda','qplan_dostaw',_args);

         _args.MAG_Z:=4-_magazyny_z;
         _res_all:=exec('pda','qplan_dostaw',_args);
         _ref:={?_surowce.LIMIT='T'||_surowce.ZK_P_REF || _surowce.ZLIM_REF ?};
         _args.skip_del({?_surowce.LIMIT='T'||_surowce.ZK_P_REF || _surowce.ZLIM_REF ?});

         _argse.M:=_args.M;
         _argse.IL:=_args.IL;
         _argse.DW:=_args.DW;
         _argse.TW:=_args.TW;

         _argse.DOSTEPNY:={? _czy_bilans='T' || _res.DOSTEPNY || 0 ?};
         _argse.IL_DOST:={? _czy_bilans='T' || _res.IL_DOST-_il || 0 ?};
         _argse.DM:=_res.NA_KIEDY;
         _argse.PD_D_ZN:=_args.PD_D_ZN;
         _argse.MAG_Z:=_magazyny_z;
         _argse.OPIS:='Surowiec do przewodnika: '+_surowce.NRPRZ;
         _argse.ZASOB:=_surowce.ZASOB+' - '+_surowce.NZASOB;
         _argse.ZMIANA:=_surowce.ZMIANA;
         _argse.IL_ALL:=_res_all.IL_DOST;
         exec('an_add','qplan_dostaw',_argse);

         &_res;
         &_res_all
      ?};
::      &_args;
      _loop:=_surowce.next()
   !}
::   Oblicza stany dla pozycji analizy
::   exec('wylicz_stan','qbilans_sur')
?};

_surowce.size()>0


\bilans_s
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS:  Bilansowanie na podstawie tabeli __ENV_AN.TAB
::   WE:  _a 1- z agregacją, 0 - bez agregacji
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: parametry domyslne
_a:={? _<1 || 0 || _a ?};

:: Całość danych z analizy
_tab:=__ENV_AN.TAB;
_tab.first();

:: Magazyn do zbilanosowania
_mag_sym_do:=((_tab.MAG_Z*',')-1)+_tab.MAG_Z;
:: Magazyn priorytetowy do zamawiania (jak nie ma stanów na innych magazynach)
_mag_sym_z:=((_tab.MAG_Z*','))-_tab.MAG_Z;
_mag_sym_z:=((_mag_sym_z*',')-1)+_mag_sym_z;

:: tabela zagregowana bądź nie - w zależności od parametru _a
VAR_DEL.delete('qtab_a');
qtab_a:=exec('do_uzupelnienia','qbilans_sur', _tab, _a);

:: przygotowanie tabeli z analizą magazynów z których można uzupełnić stan
VAR_DEL.delete('qtab_mag');
qtab_mag:=exec('stan_mag_z','qbilans_sur', qtab_a);
_mag_ndx:=qtab_mag.ndx_tmp('',1,'M',,,'DW',,,'MG',,);
qtab_mag.index(_mag_ndx);

:: przygotowanie tabeli z pozycjami zamówień - zbudowanie tabeli
VAR_DEL.delete('qtab_zam');
qtab_zam:=exec('tab_zam_a','qbilans_sur');

:: napełnia qtab_zam danymi z przekazanej tabeli
exec('tab_zam','qbilans_sur',qtab_a);

:: Dokładność na okienkach
ST.DOKL:=4;

:: Okno wertowania dla pozycji zamówień
_wer:=qtab_zam.mk_sel('Pozycje do zamówień wewnętrznych'@,,,'#bilanswer',1,1,,,'U');
qtab_zam.win_fld(_wer,,'KTM',,,20,,,'Indeks'@);
qtab_zam.win_fld(_wer,,'N',,,30,,,'Nazwa'@);
qtab_zam.win_fld(_wer,,'IL_W',,,-15,ST.DOKL,,'Ilość wym.'@);
qtab_zam.win_fld(_wer,,'IL_Z',,,-15,ST.DOKL,,'Ilość zam.'@);
qtab_zam.win_fld(_wer,,'JM',,,5,,,'jm'@);
qtab_zam.win_fld(_wer,,'DW',,,-10,,,'Data wymagana'@,,'Data wymagalności materiału'@);
qtab_zam.win_fld(_wer,,'MAG_Z',,,10,,,'Magazyn z'@);
qtab_zam.win_fld(_wer,,'ZASOB',,,30,,,'Zasób produkcyjny'@);
qtab_zam.win_fld(_wer,,'ZMIANA',,,20,,,'Zmian produkcyjna'@);
:: qtab_zam.win_fld( _wer,,'STAN',,,-15,ST.DOKL,,'Dostępne na wymagany termin'@,,'Ilość dostępna na wymagany termin'@);

:: akcje
_fb:="{? (qtab_zam.sel_aget()).size()=0
      || {? FUN.ask('Czy chcesz utworzyć zamóienia dla wszystkich pozycji bilansu ?')
         || exec('gen_zam_wew','qbilans_sur')
         ?}
      ?}";
_fgb:="VAR_DEL.delete('sel_tab_zam');
       sel_tab_zam:=qtab_zam.sel_aget();
       1";
_fga:="{? FUN.ask('Czy chcesz utworzyć zamóienia dla zaznaczonych pozycji bilansu ?')
       || qtab_zam.sel_adel();
          exec('gen_zam_wew','qbilans_sur',sel_tab_zam)
       ?};
       VAR_DEL.delete('sel_tab_zam');
       1";
qtab_zam.win_act(_wer,,'Formuła','&Zamów'@@,,,_fb,,,1,_fgb,_fga,'Z');

_fb:="M.cntx_psh();
      M.win_sel('SEL');
      {? M.select()
      || qtab_zam.add();
         qtab_zam.M:=#M.ref();
         qtab_zam.KTM:=M.KTM;
         qtab_zam.N:=M.N;
         qtab_zam.IL_W:=0;
         qtab_zam.IL_Z:=0;
         qtab_zam.JM:=M.J().KOD;
         qtab_zam.put();
         {? qtab_zam.edit()
         || qtab_zam.put()
         || qtab_zam.del()
         ?}
      ?};
      M.cntx_pop()";
qtab_zam.win_act(_wer,,'Formuła','&Dołącz'@@,,,_fb,,,,,,'D');

_fb:="{? qtab_zam.edit()
      || qtab_zam.put()
      ?}";
qtab_zam.win_act(_wer,,'Formuła','&Popraw'@@,,,_fb,,,,,,'P');

qtab_zam.win_act(_wer,0,'Usuń',,,,,,,1);

_fb:="_ref_m:=exec('FindInSet','#table','M','MATKTM',cur_tab().KTM,cur_tab().KTM);
      exec('info_zam','magazyn_stan','wszystkie magazyny';5,_ref_m)
      ";

qtab_zam.win_act(_wer,,'Formuła','Szczegóły &materiału'@@,,,_fb,,,,,,'M');

:: Kolory - krytyczny jak nie ma stanu bąć ilość zamawiana jest większa od stanu,
::          ostrzeżenie jek ilość wymagana jest większa od stanu
_fb:="{? cur_tab(1,1).SM_SD=0
      || {? var_pres('Color')>0 || Color.fnd_kol('PD_AP#01#03') || '' ?}
      |? cur_tab(1,1).IL_Z>cur_tab(1,1).SM_SD
      || {? var_pres('Color')>0 || Color.fnd_kol('PD_AP#01#03') || '' ?}
      |? cur_tab(1,1).IL_W>cur_tab(1,1).IL_Z
      || {? var_pres('Color')>0 || Color.fnd_kol('PD_AP#01#02') || '' ?}
      || ~~
      ?}";
qtab_zam.win_act(_wer,,'Rekord',,,,_fb);
:: przyciski
_fb:="exec('legenda','color','PD_AP#01')";
qtab_zam.win_act(_wer,,'Formuła','&Legenda'@@,,,_fb,,,,,,'L');

_btn:=qtab_zam.win_btn(_wer,'text='+'&Dołącz'@,'menu:D',,,,,,'noempty');
qtab_zam.btn_sopt(_wer,_btn,'tooltip='+'Dołącz - umożliwa dodanie nowego indeksu do listy zapotrzebowań'@);

_btn:=qtab_zam.win_btn(_wer,'text='+'&Popraw'@,'menu:P',,,,,,'noempty');
qtab_zam.btn_sopt(_wer,_btn,'tooltip='+'Popraw - umożliwa zmiana ilości zamawianej i/lub magazynu z którego chcemy zamawiać'@);

_btn:=qtab_zam.win_btn(_wer,'text='+'&Usuń'@,'menu:U',,,,,,'noempty');
qtab_zam.btn_sopt(_wer,_btn,'tooltip='+'Usuń - umożliwa pozycji z listy zapotrzebowań'@);

_btn:=qtab_zam.win_btn(_wer,'text='+'&Zamów'@,'menu:Z',,,,,,'noempty');
qtab_zam.btn_sopt(_wer,_btn,'tooltip='+'Generowanie zamóienia wewnętrznego do bilansu surowcó produkcji'@);

_btn4:=qtab_zam.win_btn(_wer,'text='+'Szczegóły &materiału'@,'menu:M',,,,,,'noempty');
qtab_zam.btn_sopt(_wer,_btn4,'tooltip='+'Szczegółowe informacje o materiale'@);


_fb:="params_exec('f3_mag','magdok_nag'); qtab_zam.MAG_Z:=ST.MAG_SYM ";
qtab_zam.fld_fml('MAG_Z','F3',_fb);

_fb:="ST.MAG_SYM:=qtab_zam.MAG_Z; exec('ae_mag','magdok_nag')";
qtab_zam.fld_fml('MAG_Z','AFTER_EDIT',_fb);



:: Okno redakcyjne dla pozycji zamówienia
_red:=qtab_zam.mk_edit('Pozycja do zamóienia'@,,'#bilansdosred');
qtab_zam.win_esep(_red,'Materiał'@);
qtab_zam.win_efld(_red,,'KTM',,,,,1,'Indeks'@);
qtab_zam.win_efld(_red,,'N',,,,,1,'Nazwa'@);
qtab_zam.win_esep(_red,'Do zamówienia'@);
qtab_zam.win_efld(_red,,'DW',,,,,1);
qtab_zam.win_efld(_red,,'ZASOB',,,60,,1);
qtab_zam.win_efld(_red,,'ZMIANA',,,20,,1);
qtab_zam.win_efld(_red,,'IL_W',,,10,ST.DOKL,1,'Ilość wymagana'@);
qtab_zam.win_esep(_red,'Zamawiam'@);
qtab_zam.win_efld(_red,,'MAG_Z',,,,,0,'Magazyn z'@);
qtab_zam.win_efld(_red,,'IL_Z',,,10,ST.DOKL,0,'Ilość zamawiana'@);
::qtab_zam.win_efld(_red,,'STAN',,,13,,1);
_btn:=qtab_zam.win_ebtn(_red,'text=&OK, icon=xwin16.png:13',"'key:F2'");
qtab_zam.win_ebtn(_red,'text=&Anuluj, icon=xwin16.png:14',"'key:Esc'");
qtab_zam.btn_opt(_btn, 'default=1');

qtab_zam.win_sel(_wer);
qtab_zam.win_edit(_red);

:: Scalanie pozycji DnD dla pozycji zamówień
_fdnd:="_dest_rec:=dnd_info('dest_record');
        _mask:=dnd_info('table_name');
        _dropped_rec:=dnd_info('dropped_records');
        _y:={? _dropped_rec.size>1 || 'y' || '' ?};
        _loop:=_dropped_rec.first();
        {? _dest_rec=null()
        || {? FUN.ask('Czy usunąć rekord'+_y+' z listy do zamówienia ?')
           || _loop:=_dropped_rec.first();
              {!|? _loop |!
                  {? qtab_zam.seek(_dropped_rec.REF, _mask)
                  || qtab_zam.del()
                  ?};
                  _loop:=_dropped_rec.next()
              !}
           ?}
        || {? FUN.ask('Czy scalić możliwe do połączenia rekordy')
           || {? qtab_zam.seek(_dest_rec)
              || _mat:=qtab_zam.KTM;
                 _mag:=qtab_zam.MAG_Z;
                 _data_w:=qtab_zam.DW;
                 _zasob:=qtab_zam.ZASOB;
                 _zmiana:=qtab_zam.ZMIANA;
                 _il_zam:=qtab_zam.IL_Z;
                 _il_wym:=qtab_zam.IL_W;
                 _put:=0;
                 _loop:=_dropped_rec.first();
                 {!|? _loop |!
                   {? qtab_zam.seek(_dropped_rec.REF, _mask)
                   || {? _mat=qtab_zam.KTM & _mag=qtab_zam.MAG_Z & _zasob=qtab_zam.ZASOB & _zmiana=qtab_zam.ZMIANA
                      || {? _data_w>qtab_zam.DW || _data_w:=qtab_zam.DW ?};
                         _il_zam+=qtab_zam.IL_Z;
                         _il_wym+=qtab_zam.IL_W;
                         _put:=1;
                         qtab_zam.del()
                      ?}
                   ?};
                   _loop:=_dropped_rec.next()
                 !};
                 {? _put
                 || qtab_zam.seek(_dest_rec);
                    qtab_zam.DW:=_data_w;
                    qtab_zam.IL_Z:=_il_zam;
                    qtab_zam.IL_W:=_il_wym;
                    qtab_zam.put()
                 ?}
              ?}
           ?}
        ?};
       1
       ";
qtab_zam.dnd_sel(_wer,,'records.#bilanswer',_fdnd);


:: Okno wertowania dla stanu magazynowego
VAR_DEL.delete('wer_mag');
wer_mag:=qtab_mag.mk_sel('Stan materiału wg. magazynów'@,,,'#stannsadostep',1,1,,,'U');
qtab_mag.win_fld(wer_mag,,'KTM',,,20,,,'Indeks'@);
qtab_mag.win_fld(wer_mag,,'ORDER',,,5,,,'Priorytet'@);
qtab_mag.win_fld(wer_mag,,'MG',,,10,,,'Magazyn z'@);
qtab_mag.win_fld(wer_mag,,'SM_S',,,-15,ST.DOKL,,'Stan aktualny'@);
qtab_mag.win_fld(wer_mag,,'SM_SD',,,-15,ST.DOKL,,'Stan dostępny'@);
qtab_mag.win_fld(wer_mag,,'SM_D',,,-15,ST.DOKL,,'Ilość w drodze'@);
qtab_mag.win_fld(wer_mag,,'SM_SP',,,-15,ST.DOKL,,'Ilość w produkcji'@);
qtab_mag.win_fld(wer_mag,,'SM_W',,,-15,ST.DOKL,,'Ilość w wydaniu'@);
qtab_mag.win_fld(wer_mag,,'STAN',,,-15,ST.DOKL,,'Stan wg. analizy'@);
qtab_mag.win_sel(wer_mag);


_poz_zam:=qtab_zam.grp_make(,,'#grpbilanswer');
qtab_zam.grp_sel(_poz_zam,,_wer,,"qtab_mag.prefix();
                                  qtab_mag.prefix(qtab_zam.M,qtab_zam.DW);
                                  qtab_mag.first();
                                  grp_disp(qtab_mag,wer_mag)",,,,,,,,'maximized_with_title','gbilans');
qtab_zam.grp_splt(_poz_zam,'panel0','horizontal','dolny',25);
qtab_zam.grp_sel(_poz_zam,qtab_mag,wer_mag,,,,,,,,,,'maximized_with_title');

qtab_zam.win_sel(_poz_zam);
qtab_zam.select();


::q_sel(qtab_zam);
::
::q_sel(qtab_mag);
::
::q_sel(qtab_a);

qtab_mag.ndx_drop();
qtab_zam.ndx_drop();
VAR_DEL.delete('qtab_mag','qtab_zam','wer_mag','qtab_a');
1


\bilans_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS:  Tablica parametrów dla bilansowania magazynó produkcyjnych
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('WYD','DOD','DDO','MAG_Z','Z_MG', 'FORM','CZY_ZAS','CZY_ZM','CZY_ZL','CZY_BIL');
:: Wydział do zbilansowania
_args.WYD:=ST.WYD().SYMBOL;
:: Data od analizy
_args.DOD:=date()+2;
:: Data do analizy
_args.DDO:=date()+2;
:: Lista magazynów bilansujących wydział, na liście jako pierwszy musi być magazyn do zbilansowania (wydziałowy)
_args.MAG_Z:='';
:: Zestaw formuł do analizy stanów
_args.FORM:='BILANS PRODUKCJI';
:: Czy dzielić zamówienia na ZASOBY - domyślnie 'N' - nie
_args.CZY_ZAS:='N';
:: Czy dzielić zamówienia na ZMIANY - domyślne 'T'
_args.CZY_ZM:='T';
:: Czy dla pojedynczego zlecenia
{? ZL.sel_size()>0
   ;0
|| _args.CZY_ZL:='T';
   _tab:=ZL.sel_aget();
   _tabw:=sql('select min(ZGH.STARTD) as START, max(ZGH.ENDD) as STOP from ZGH where REFERENCE_NUM(ZGH.ZLEC) in (select REF from :_a)',_tab);
   {? _tabw.START>=date() & _tabw.STOP<> date(0,0,0)
   || _args.DOD:=_tabw.START-1;
      _args.DDO:=_tabw.STOP+1
   ?}
|| _args.CZY_ZL:='N';
   _tabw:=sql('select min(ZGH.STARTD) as START, max(ZGH.ENDD) as STOP from ZGH where ZGH.ZLEC=:_a',ZL.ref);
   {? _tabw.START>=date() & _tabw.STOP<> date(0,0,0)
   || _args.DOD:=_tabw.START-1;
    _args.DDO:=_tabw.STOP+1
   ?}
?};
:: Czy bilansować surowce, czy zamówienie na podstawie limitów zleceń
_args.CZY_BIL:='T';

_args


\bilans_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS: Pobranie danych od użytkowika dla potrzeb analizy bilansowania surowców i uruchomienie analizy
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: Dane domyślne
_args:=exec('bilans_a','qbilans_sur');

:: Definicje magazynów do bilansowania zapisane są w strukturze o nazwie PROD_SUR w polu opis dla każdego elementu
:: Element musi mieć symbol zgodny z wydziałem
:: debug();
_ud_skl:=exec('szukaj_ud_skl','schemat','PROD_SUR',_args.WYD);
{? _ud_skl<>null()
|| _args.MAG_Z:=sql('select UD_SKL.OPIS from @UD_SKL where UD_SKL.REFERENCE=:_a',_ud_skl).OPIS
?};
{? _args.MAG_Z=''
|| _args.MAG_Z:=_args.WYD
?};

_wybrane:={? ZL.sel_size()>0
          || 'wybranych zleceń'
          || 'wybranego zlecenia'
          ?};

_PAR:=tab_tmp(,'WYD','STRING[20]','Symbol wydziału',
                'DOD','DATE','Data od',
                'DDO','DATE','Data do',
                'MAG_Z','STRING[60]','Magazyny bilansująsce stan wydziału',
                'FORM','STRING[60]','Zestaw formuł do analizy stanów',
                'CZY_ZM','STRING[1]','Czy podział zapotrzebowań na zmiany produkcyjne',
                'CZY_ZAS','STRING[1]','Czy podział zapotrzebowań na stanowiska produkcyjne',
                'CZY_ZL','STRING[1]','Analiza aktualnie %1'@[_wybrane],
                'CZY_BIL','STRING[1]','Uwzględniać stany (analizę) magazynu produkcyjnego'
                );
_PAR.blank();
_PAR.WYD:=_args.WYD;
_PAR.DOD:=_args.DOD;
_PAR.DDO:=_args.DDO;
_PAR.MAG_Z:=_args.MAG_Z;
_PAR.FORM:=_args.FORM;
_PAR.CZY_ZAS:=_args.CZY_ZAS;
_PAR.CZY_ZM:=_args.CZY_ZM;
_PAR.CZY_ZL:=_args.CZY_ZL;
_PAR.CZY_BIL:=_args.CZY_BIL;

_ed:=_PAR.mk_edit('Parametry do bilansowania');
_PAR.win_efld(_ed,,'WYD',,,,,1);
_PAR.win_efld(_ed,,'MAG_Z',,,,,1);
_PAR.win_efld(_ed,,'FORM',,,,,1);
_PAR.win_efld(_ed,,'DOD',,,,,0);
_PAR.win_efld(_ed,,'DDO',,,,,0);
_PAR.win_efld(_ed,,'CZY_ZM',,,,,0,,,,'check-box','check_label="tak, podziel zapotrzebowania"',"'T'","'N'");
_PAR.win_efld(_ed,,'CZY_ZAS',,,,,0,,,,'check-box','check_label="tak, podziel zapotrzebowania"',"'T'","'N'");
_PAR.win_efld(_ed,,'CZY_ZL',,,,,0,,,,'check-box','check_label="tak, analiza %1"'@[_wybrane],"'T'","'N'");
_PAR.win_efld(_ed,,'CZY_BIL',,,,,0,,,,'check-box','check_label="tak, uwzględnić analizę stanu"',"'T'","'N'");
_btn:=_PAR.win_ebtn(_ed,'text=&OK, icon=xwin16.png:13',"'key:F2'");
_PAR.win_ebtn(_ed,'text=&Anuluj, icon=xwin16.png:14',"'key:Esc'");
_PAR.btn_opt(_btn, 'default=1');
_PAR.win_edit(_ed);
:: formuła walidacyjna
wf:="{? cur_tab().DOD>cur_tab().DDO
     || FUN.error('Data końca analizy nie może być wcześniejsza niż data jej początku !');
        'DDO'
     || ''
     ?}";

{? _PAR.edit(wf)
|| _PAR.add();
   _args.DOD:=_PAR.DOD;
   _args.DDO:=_PAR.DDO;
   _args.CZY_ZAS:=_PAR.CZY_ZAS;
   _args.CZY_ZM:=_PAR.CZY_ZM;
   _args.CZY_ZL:=_PAR.CZY_ZL;
   _args.CZY_BIL:=_PAR.CZY_BIL;
   exec('bilans','qbilans_sur',_args)
?};
1


\zam_wew_nag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS: Tworzy nagłówka zamówienie  wewnętrzne na podstawie przekazanych danych
::   WE: _a - typ zamówienia
::       _b - magazyn zamówienia (domyślny magazyn dla MP) ZK_N.MD().SYM
::       _c - magazyn do zamawiania (domyślny magazyn MW) ZK_N.MG().SYM
::       _d - data zamówienia (data utworzenia zamówienia) ZK_N.DP
::       _e - termin realizacji ZK_N.DT
::       _f - uwagi dla nagłówka
::   WY: ZK_N.ref (jeśli udało się dodać nagłówek) i null jeśli nie
::----------------------------------------------------------------------------------------------------------------------
_params1:=exec('zk_n_add_a','qbilans_sur');

:: Typ zamówienia
_typzam_ref:=exec('FindInSet','#table','TYPYZAM','TYP',_a,'W');
_mag_ref:=exec('FindInSet','#table','MG','MAGAZYNY',_b,_b);
_mag_z_ref:=exec('FindInSet','#table','MG','MAGAZYNY',_c,_c);

:: Weryfikacja dat zamówienia narazie zablokowane
::{? _d<date() | _e<date()
::|| FUN.error('Próba utworzenia zamówienia w przeszłości !!! \n Tworzenie zamówienia przerwane.');
::   return(0)
::?};

{? _typzam_ref<>null() & _mag_ref<>null & _mag_z_ref<>null
|| _params1.TYPYZAM:=_typzam_ref;
   _params1.DD:=_e;
   _params1.DZ:=_d;
   _params1.MG:=_mag_ref;
   _params1.Z_MG:=_mag_z_ref;
   _params1.U:=_f
|| FUN.error('Błąd w parametrach tworzenia nagłówka zamówienia !!!');
   return(0)
?};

{? exec('zk_n_add','qbilans_sur',_params1)
|| 1
|| 0
?}


\zam_wew_poz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.30]
:: OPIS: dodanie pozycji zamowienia wewnetrznego
::   WE: _a - $ZK_N.ref
::       _b - M.ref
::       _c - Ilość zamawiana
::       _d - Uwagi (obecnie symbol zasobu produkcyjnego)
::  OLD: \zk_p_add/pd_zam.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('zk_p_add_a','qbilans_sur');
_args.ZAM_REF:=_a;
_args.M:=_b;
_args.WS2=1;
_args.JM:=_args.J2:=exec('FindAndGet','#table',M,_args.M,,"M.J",null());
_args.U:=_d;

_q_lista_jm:=exec('get_w','#params',999006,type_of(''));
_jm:=exec('FindAndGet','#table',JM,_args.JM,,"JM.KOD",'');

{? _jm<>'' & _q_lista_jm*(','+_jm+',')>0
|| _args.ILZ:=_args.IL2:=ceil(_c)
|| _args.ILZ:=_args.IL2:=_c
?};

exec('zk_p_add','qbilans_sur', _args, 2);
1


\stan_mag_z
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [merit 20xx]
:: OPIS: Funkcja wylicza stany magazynów dla potrzeb uzupełnienia stanów na produkcji
::   WE: _a - tabela ze stanami do uzupełnienia - exec('do_uzupelnienia','qbilans_sur')
::   WY: tabela ze stanami magazynów uzupełniających braki analizy lub null jak poszło coś nie tak
::----------------------------------------------------------------------------------------------------------------------
_tab_uzup:=_a;

:: Tabela stanów dla kodów materiałów na podany termin.
_tab_stan:=tab_tmp( 3, 'DW','DATE','Data wymagalności stanu',
                       'KTM','STRING[50]','Kod towaru',
                       'M','INTEGER','#M.ref',
                       'MG','STRING[10]','Symbol magazynu',
                       'ORDER','INTEGER','Priorytet magazynu',
                       'STAN','REAL','Stan na magazynie wg. analizy',
                       'SM_S','REAL','Stan aktualny',
                       'SM_SD','REAL','Stan dostępny',
                       'SM_D','REAL','Stan w drodze',
                       'SM_SP','REAL','Stan w produkcji',
                       'SM_S_N','REAL','Stan niezgodny',
                       'SM_S_O','REAL','Stan nieokre slony',
                       'SM_W','REAL','Stan w wydaniu',
                       'ZASOB','STRING[100]','Zasób produkcyjny',
                       'ZMIANA','STRING[20]','Zmiana produkcyjna'
                  );

:: Jeśli nie ma co uzupełniać zwracam null()
{? ~_tab_uzup.first()
|| return(_tab_stan)
?};

:: w polu MAG_Z znajdują się magazyny wg zasady : 1 (do przecinka) - magazyn który należy uzupwłnić stan,
:: kolejne po przecinku to magazyny z których należy uzupełnić stan

_mag_sym_do:=((_tab_uzup.MAG_Z*',')-1)+_tab_uzup.MAG_Z;
{? _mag_sym_do=''
|| FUN.error('Błędnie zdefiniowane magazyny do analizy !!!');
   return()
?};

:: Magazyn do uzupełnienia (ref) - ustalany na podstawie zapisu z pierwszego rekordu analizy !!!
_mag_ref_do:=exec('FindInSet','#table','MG','MAGAZYNY',_mag_sym_do,,,1);

{? _mag_ref_do=null()
|| FUN.error('Błędny symbol magazynu do uzupełnienia w parametrach analizy !!!');
   return()
?};

:: !!! lista ustalana na podstawie pierwszego rekordu w bazie - rekordy analizy mają zawsze te same parametry i magazyny !!!
:: Lista magazynów uzupełniających z pola tabeli bez pierwszego, który jest do uzupełnienia
_mag_z:=_mag_sym_z:=(_tab_uzup.MAG_Z*',')-_tab_uzup.MAG_Z;
:: Magazyny uzupełniające z priorytetami.
_tab_mag_z:=tab_tmp( 1,
                    'ORDER','INTEGER','Priorytet',
                    'SYM','STRING[10]','Symbol magazynu'
                    );
_loop:=(+_mag_z>1);
_order:=1;

{!
|? _loop
|! _tmp_mg_sym:={? (_mag_z*',')>0
                || ((_mag_z*',')-1)+_mag_z
                || _mag_z
                ?};
   _mag_z:=(_mag_z*',')-_mag_z;
   {? _tmp_mg_sym<>''
   || _tab_mag_z.ORDER:=_order;
      _tab_mag_z.SYM:=_tmp_mg_sym;
      _tab_mag_z.add();
      _order+=1
   ?};
   _loop:=(_tmp_mg_sym<>_mag_z)
!};

:: Zestaw formuł z pola tabeli
_formuly:=_tab_uzup.PD_D_ZN;

:: Główna pentla - uzupełnienie stanów dostępnych na magazynach uzupełniających na datę wymagania
_tab_uzup.first();
{!
|? _tab_stan.prefix();
   _tab_stan.prefix(_tab_uzup.DW,_tab_uzup.KTM,_tab_uzup.M);
   {? ~_tab_stan.first()
   || _tab_stan.blank();
      _tab_stan.DW:=_tab_uzup.DW;
      _tab_stan.KTM:=_tab_uzup.KTM;
      _tab_stan.M:=_tab_uzup.M;
      _tab_stan.ZASOB:=_tab_uzup.ZASOB;
      _tab_stan.ZMIANA:=_tab_uzup.ZMIANA;
      _ref_m:=exec('FindInSet','#table','M','MATKTM',_tab_uzup.KTM,_tab_uzup.KTM,,1,,null());
      _res:=exec('stan_m_z_mag','qbilans_sur',_mag_sym_z,_formuly, _tab_stan.DW,_tab_uzup.M);
      {? _res.first()
      || {!
         |? {? _res.STAN>0
            || _tab_stan.MG:=_res.MG;
               _tab_stan.STAN:=_res.STAN;
               _tab_stan.ORDER:=sql('select :_a.ORDER from :_a where SYM=\':_b\'',_tab_mag_z,_res.MG).ORDER;
               _ref_mag:=exec('FindInSet','#table','MG','MAGAZYNY',_res.MG,_res.MG,,1,,null());
               _sm:=sql('select * from SM where SM.MAG=:_a and SM.M=:_b',_ref_mag,_ref_m);
               {?_sm.first()
               || _tab_stan.SM_S:=_sm.S;
                  _tab_stan.SM_SD:=_sm.SD;
                  _tab_stan.SM_D:=_sm.D;
                  _tab_stan.SM_SP:=_sm.SP;
                  _tab_stan.SM_S_N:=_sm.S_N;
                  _tab_stan.SM_S_O:=_sm.S_O;
                  _tab_stan.SM_W:=_sm.W
               ?};
               _tab_stan.add();
               &_sm
            ?};
            _res.next()
         !}
      ?};
      &_res
   ?};
   _tab_uzup.next()
!};
_tab_stan.prefix();

_tab_stan


\do_uzupelnienia
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [merit 20xx]
:: OPIS: Tworzy tabelę z rekordami do zbilansowania stanu na podstawie
::   WE: _a - tabela zgodna z __ENV_AN.TAB - exec('env_create','qplan_dostaw')
::       _b - agregacja danych 1, bez agregacji 0
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_tab:=null();

_tab_tym:=sql('select * from :_a',_a);
{? _tab_tym.first()
|| {!
   |? {? _tab_tym.TW<time(6,0,0) || _tab_tym.DW:=_tab_tym.DW-1; _tab_tym.put() ?}; _tab_tym.next()
   !}
?};


_sql:='select M, KTM, N, JM, DW, MAG_Z, PD_D_ZN, ZMIANA, ZASOB, ';

{? _b
|| _sql+=' sum(IL) as IL_W, sum(IL_DOST) as IL_DOST, sum(IL_ZAM) as IL_ZAM from :_a where :_a.DOSTEPNY=0
           group by M, KTM, N, JM, DW, MAG_Z, PD_D_ZN, ZMIANA, ZASOB
           order by DW, ZMIANA, ZASOB'
|| _sql+=' IL as IL_W, IL_DOST, IL_ZAM from :_a where :_a.DOSTEPNY=0 order by DW, ZMIANA'
?};

_tab:=sql(_sql,_tab_tym);

_tab


\stan_m_z_mag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [merit 20xx]
:: OPIS: Funkcja wulicza sna wg magazynów dla jednego materiału
::   WE: _a - lista symboli magazynów dla obliczenia stanu 'SUR1,SUR2, POL1'
::       _b - zestaw formuł do analizy stanu
::       _c - data wymagalność stanu
::       _d - #M.ref
::   WY: tabela z listą stanów magazynów zgodną z priorytetami
::----------------------------------------------------------------------------------------------------------------------

_params:=exec('pda_a','qplan_dostaw');

_params.MAG_Z:=_a;
_params.PD_D_ZN:=_b;
_params.DK:=_c;

_params.PAR:='';

:: Materiał do analizy
M.seek(_d);
_params.M:=M.ref();
_params.TM_STAMP:=SYSLOG.tm_stamp();
_params.TK:=time(0,0,0);
_params.DISP:=1;
_params.PD_P:=null;
_params.PD_P_ODS:=0;
_params.ODSW:=1;

VAR_DEL.delete('__pda');

__pda:=exec('pda_env','plan_dostaw',_params);
__pda.MAG_Z:=_params.MAG_Z;

_Tab1:=__pda.TAB1:=obj_new('TAB','NDX1','NDX2','WER1','WER2','WER3','D');
_Tab2:=__pda.TAB2:=obj_new('TAB','NDX1','NDX2','NDX3','NDX4','NDX5','WER1','WER2','WER3','GOTO_PROBLEM');
_Tab3:=__pda.TAB3:=obj_new('TAB','NDX1','NDX2','WER1');

__pda.STANY:=exec('stany_env','plan_dostaw');

_Tab1t:=_Tab1.TAB:=exec('tab1','plan_dostaw');
_Tab1.NDX1:=_Tab1t.index('?'); 'kolejnosc: T, TREE, D, DK_C';
_Tab1.NDX2:=_Tab1t.ndx_tmp(,,'T',,,'TREE',,,'D',,,'MG',,);
_Tab2t:=_Tab2.TAB:=exec('tab2','plan_dostaw');
_Tab2.NDX1:=_Tab2t.index('?'); 'kolejnosc: MG, D, T, PRZY_ROZ';
_Tab2.NDX2:=_Tab2t.ndx_tmp(,,'D',,,'T',,,'PRZY_ROZ',,);
_Tab2.NDX3:=_Tab2t.ndx_tmp(,,'PROBLEM',,,'D',,,'T',,);
_Tab2.NDX4:=_Tab2t.ndx_tmp(,,'DKC_SYM',,,'D',,,'T',,,'PRZY_ROZ',,);
_Tab2.NDX5:=_Tab2t.ndx_tmp(,,'D',,,'T',,,'PRZY_ROZ',,,'STAN_D',,);
_Tab3t:=_Tab3.TAB:=exec('tab3','plan_dostaw');
_Tab3.NDX1:=_Tab3t.index('?'); 'kolejnosc: REF,TYPSTAN,KOD,SORT';
_Tab3.NDX2:=_Tab3t.ndx_tmp(,,'REF',,,'TYPSTAN',,,'SORT',,);

exec('stan','plan_dostaw',_params);
exec('tab2_insert','plan_dostaw',_params);
exec('tab2_stan','plan_dostaw',1);
:: exec('tab2_stan','plan_dostaw',2);
exec('tab1_stan','plan_dostaw',_params);
exec('stany_oblicz','plan_dostaw',_params);

:: _res:=sql('select MG, sum(STAN) as STAN from :_a where D<=to_date(:_b) and MG<>\'\'',@.__pda.TAB1.TAB,_params.DK);
_res:=sql('select MG, sum(STAN) as STAN from :_a  where D<=to_date(:_b) and MG<>\'\' group by MG',@.__pda.TAB1.TAB,_params.DK);

:: Wyświetl co wyszło :)
::q_sel(_res);

VAR_DEL.delete('__pda');
_res


\tab_zam_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [merit 20xx]
:: OPIS: Utworzenie tabeli tymczasowej z pozycjami zamówień (dla potrzeb bilansowania surowców)
::   WE:
::   WY: tabela tymczasowa - pozycji zamówień wewnętrznych.
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp( 1,
      'KTM','STRING[50]','Kod materiału',
      'M','INTEGER','#M.ref materiału',
      'N','STRING[100]','Nazwa materiału',
      'IL_W','REAL','Ilość wymagana',
      'DW','DATE','Data wymagalności',
      'DZ','DATE','Data zamówienia',
      'IL_Z','REAL','Ilość zamówienia',
      'IL_DOST','REAL','Ilość dostępna na magazynie',
      'MAG','STRING[10]','Magazyn do zbilansowania',
      'MAG_Z','STRING[10]','Z magazynu',
      'JM','STRING[10]','J.M.',
      'STAN','REAL','Stan analizy',
      'SM_SD','REAL','Stan dostępny',
      'SYM_ZAM','STRING[25]','Symbol zamówienia',
      'ZASOB','STRING[100]','Zasób produkcyjny',
      'ZMIANA','STRING[20]','Zmiana produkcyjna'
      );
_tab


\tab_zam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [merit 20xx]
:: OPIS: Napełnia danymi tabelę z pozycjami do zamówienia wewnętrznego uwzględniając magazyny i proiorytety
::       Do poprawnego działania potrzebuje informacji o magazynach któe są pobierane z rekordu analizy
::       potrzebna jest więc baza __ENV_AN.TAB
::   WE: _tab - tabela z danymi do zbilansowwania
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: Całość danych z analizy
_tab:=__ENV_AN.TAB;
_tab.first();

:: Magazyn do zbilanosowania
_mag_sym_do:=((_tab.MAG_Z*',')-1)+_tab.MAG_Z;
:: Magazyn priorytetowy do zamawiania (jak nie ma stanów na innych magazynach)
_mag_sym_z:=((_tab.MAG_Z*','))-_tab.MAG_Z;
_mag_sym_z:=((_mag_sym_z*',')-1)+_mag_sym_z;

_tab_a:=_a;


{? _tab_a.first()
|| {!
   |? qtab_zam.blank();
      qtab_zam.M:=_tab_a.M;
      qtab_zam.KTM:=_tab_a.KTM;
      qtab_zam.N:=_tab_a.N;
      qtab_zam.JM:=_tab_a.JM;
      qtab_zam.DW:=_tab_a.DW;
      qtab_zam.DZ:=_tab_a.DW;
::      _il:=_tab_a.IL_W-_tab_a.IL_DOST;
::      _il:={? _il<0 || 0 || _il ?};
::      qtab_zam.IL_W:={? _il<0 || 0 || _il ?};
      qtab_zam.IL_W:=_tab_a.IL_ZAM;
      _il:=_tab_a.IL_ZAM;
      qtab_zam.ZASOB:=_tab_a.ZASOB;
      qtab_zam.ZMIANA:=_tab_a.ZMIANA;
      qtab_zam.IL_DOST:=_tab_a.IL_DOST;
      qtab_zam.IL_Z:=0;
      qtab_zam.MAG:=_mag_sym_do;
      qtab_zam.MAG_Z:='';
      qtab_zam.STAN:=0;
      qtab_mag.prefix();
:: Dodatkowe ustalenie magazynu na podstawie kodu KTM
      _grupa:=2+qtab_zam.KTM;
      _mag:='';
      {? ',03,04,05,07,'*(_grupa+',')>0
      || {? _grupa='03'
         || _mag:='ZAO'
         |? _grupa='04'
         || _mag:='MAT'
         |? _grupa='05'
         || _mag:='MAP'
         |? _grupa='07'
         || _mag:='SUR'
         ?}
      ?};
      qtab_mag.prefix(_tab_a.M,_tab_a.DW,_mag);
      _loop:=qtab_mag.first();
      {? _loop
      || 'jeśli jest jakiś stan na magazynach przekazanych prametrami to przypisuje ilości do tych magazynów';
         {!
         |? _loop
         |! {? _il<=qtab_mag.STAN
            || qtab_zam.IL_Z:=_il;
               _il:=0
            || qtab_zam.IL_Z:=qtab_mag.STAN;
               _il:=_il-qtab_mag.STAN
            ?};
            qtab_zam.MAG_Z:=qtab_mag.MG;
            qtab_zam.STAN:=qtab_mag.STAN;
            qtab_zam.SM_SD:=qtab_mag.SM_SD;
            {? _il>0 & qtab_mag.next()
            || qtab_zam.add();
               _loop:=1
            || qtab_zam.IL_Z+=_il;
               qtab_zam.add();
               _loop:=0
            ?}
         !}
      || 'jeśli nigdzie na magazynach nie ma stanu tego materiału wybierma pierwszy magazyn priorytetowy';
:: Dodatkowe ustalenie magazynu na podstawie kodu KTM
         {? _mag<>''
         || qtab_zam.MAG_Z:=_mag
:: Jeśli nie pasuje do grupy - to magazyn domyślny
         || qtab_zam.MAG_Z:=_mag_sym_z
         ?};
         qtab_zam.IL_Z:=_il;
         qtab_zam.add()
      ?};
      _tab_a.next()
   !}
?};
1


\gen_zam_wew
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS: Formuła uruchamiana z przycisku/menu - bilansowania surowców,  bazuje na tabeli qtab_zam i na jej podstawie
::       tworzy zamówienia
::   WE: [_a] - tabela z listą pozycji  zaznaczonych do zamówienia - sel_aget na bazie
::
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_tab_temp:=sql('select :_a.*, REFERENCE_NUM(:_a.REFERENCE) as REF from :_a',qtab_zam);

:: Jeżeli przekazano listę zaznaczonych pozycji to ograniczam tabele zamówień do wybranych pozycji jeśli nie to cała
{? _<1
|| _tab_zam:=sql('select :_a.* from :_a where :_a.SYM_ZAM=\'\'',_tab_temp)
|| _tab_zam:=sql('select :_a.* from :_a join :_b using(:_a.REF,:_b.REF) where :_a.SYM_ZAM=\'\' ',_tab_temp,_a)
?};


:: tabela listy zamówień - lista rekordów dla daty wymagalności i magazynu
_zam_nag:=sql('select distinct :_a.DW, :_a.MAG, :_a.MAG_Z, ZMIANA, SPACE(25) as SYM_ZAM from :_a',_tab_zam);

:: Tworzenie zamówień
_loop:=_zam_nag.first();
_par:=obj_new(1);
_par[1]:=obj_new('PARAMETR','VALUE');
_par[1].PARAMETR:='ZK_N';

{!
|? _loop
|! {? exec('zam_wew_nag','qbilans_sur','ZWM', _zam_nag.MAG, _zam_nag.MAG_Z, date(), _zam_nag.DW, 'Zapotrzebowanie wydziału: '+_zam_nag.MAG+' - '+_zam_nag.ZMIANA)
   || _zam_nag.SYM_ZAM:=ZK_N.SYM; _zam_nag.put();
      _zam_poz:=sql('select * from :_a where :_a.DW=to_date(:_b) and :_a.MAG=\':_c\' and :_a.MAG_Z=\':_d\' and :_a.ZMIANA=\':_e\'',
                    _tab_zam, _zam_nag.DW, _zam_nag.MAG, _zam_nag.MAG_Z, _zam_nag.ZMIANA);
      _loop2:=_zam_poz.first();
      {!
      |? _loop2
      |! _m_ref:=exec('FindInSet','#table','M','MATKTM',_zam_poz.KTM,_zam_poz.KTM);
         exec('zam_wew_poz','qbilans_sur', $ZK_N.ref(),_m_ref, _zam_poz.IL_Z, _zam_poz.ZASOB);
::         Wprowadzenie symbolu zamówienia do pozycji tabeli qtab_zam
         exec('FindAndGet','#table',qtab_zam,_zam_poz.REF,qtab_zam.name(),"qtab_zam.SYM_ZAM:=ZK_N.SYM;qtab_zam.put()",0);
         _loop2:=_zam_poz.next()
      !};
::      Uruchomienie procesu akceptacji i realizacji zamówienia wewnętrznego.
      _par[1].VALUE:=ZK_N.ref();
      exec('force_signal','#b__box','NUCO_ZKM_BIL_RPO',,_par);
      &_zam_poz;
      _loop:=_zam_nag.next()
   || _loop:=0
   ?}
!};

:: Utworzone zamówienia
{? _zam_nag.size()=0
|| FUN.emsg('Nie udało się utworzyć zamówień.\n'+
            'Prawdopodobnie pozycjie, które zaznaczyłeś zostały już zamówione.\n'+
            'Odśwież analizę.')
|| _zam:=sql('select SYM_ZAM, DW, MAG, MAG_Z from :_a where :_a.SYM_ZAM<>SPACE(25)', _zam_nag);
  _lista_zam:='';
  {?_zam.first()
  || {!
     |? _lista_zam+='%1.'@[_zam.SYM_ZAM];
        _zam.next()
     !};
     _lista_zam:=_lista_zam-1
  ?};
  {? _zam.size()>1
  || _ae:='a'
  || _ae:='e'
  ?};
   FUN.info('Utworzono zamóieni%1 %2.\nDane z zamówień zostaną ujęte w bilansie surowców po ich akceptacji.'@[_ae,_lista_zam])
?};
1


\wylicz_stan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS:  Dla tabeli bilansowania surowców na produkcji wylicza stany na magazynach z których możlie są przesunięcia
::        działanie przeprowadzane jest na tabeli __ENV_AN.TAB
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

 _tab:=__ENV_AN.TAB;
 _loop:=_tab.first();
 _poprzedni_ktm:='';
 _ilosc:=0;
 _ilosc_all:=0;

{!
|? _loop
|! {? _poprzedni_ktm<>_tab.KTM
   || _args:=exec('pda_a','qplan_dostaw');
      _args.M:=exec('FindInSet','#table','M','MATKTM',_tab.KTM,_tab.KTM,"M.ref()");
      _args.TM_STAMP:=SYSLOG.tm_stamp();
      _args.DK:=_tab.DW;
      _args.TK:=_tab.TW;
      _args.IL:=_tab.IL;
      _args.DW:=_tab.DW;
      _args.TW:=_tab.TW;
      _args.DISP:=0;
      _args.PD_D_ZN:=_tab.PD_D_ZN;
      _args.MAG_Z:=(4-_tab.MAG_Z);
      _res:=exec('pda','qplan_dostaw',_args);
      _tab.IL_ALL:=({? _res.IL_DOST<0 || 0 || _res.IL_DOST ?});
      _tab.put();
      _ilosc:=_tab.IL;
      _ilosc_all:=_tab.IL_ALL;
      &_args;&_res
   || _tab.IL_ALL:=_ilosc_all-_ilosc;
      _tab.IL_ALL:=({? _tab.IL_ALL<0 || 0 || _tab.IL_ALL ?});
     _tab.put();
     _ilosc+=_tab.IL
   ?};
   _poprzedni_ktm:=_tab.KTM;
   _loop:=_tab.next()
!};
1


\zlim_zk_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [merit 20xx]
:: OPIS: Zwraca ref ZK_P dla podanefo ZLIM lub null jeśli nie znaleziono
::   WE: _a - ZLIM.ref()
::   WY:
::----------------------------------------------------------------------------------------------------------------------
ZK_P.cntx_psh();
_wyn:=null();
_zlim_ref:=_a;

{? _zlim_ref<>null()
|| ZK_P.clear();
   ZK_P.index('ZLIM');
   ZK_P.prefix(ref_name(_zlim_ref),_zlim_ref);
   {? ZK_P.first()
   || _wyn:=ZK_P.ref()
   ?}
?};

ZK_P.cntx_pop();
_wyn


\zk_n_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.30] - NUCO - zmiana w sposobie dodawania rekordu
:: OPIS: dodanie naglowka zamowienia wewnetrznego (ZK_N)
::   WE: tablica zwraca przez exec('zk_n_add_a','zamowienia')
::  OLD: \zk_n_add/pd_zam.fml
::----------------------------------------------------------------------------------------------------------------------
_params:=_a;

BEER.TYPYZAM:=null();
POM.TAB:='ZK_N';
POM.TYPDOK:='';
TYPYZAM.cntx_psh();
TYPYZAM.prefix();
{? TYPYZAM.seek(_params.TYPYZAM)
||
   POM.TYPDOK:=TYPYZAM.KOD;
   BEER.TYPYZAM:=TYPYZAM.ref()
?};
TYPYZAM.cntx_pop();
{? POM.TAB='' | POM.TYPDOK='' || return(0) ?};

do();
ZK_N.blank();
ZK_N.T:=_params.TYPYZAM;
ZK_N.DP:=_params.DZ;
ZK_N.DT:=_params.DD;
ZK_N.MG:=_params.Z_MG;
ZK_N.MD:=_params.MG;
ZK_N.PL_FORCE:=ZK_N.T().PL_FORCE;
ZK_N.PL_DIR:=ZK_N.T().PL_DIR;
ZK_N.PL_DATA:=ZK_N.DT;
ZK_N.PL_TIME:=time(0,0,0);
ZK_N.OP:=_params.U;
ZK_N.prefix();
_ok:=ZK_N.add();
exec('wol_nr','numery',POM.TAB);
{? _ok
|| exec('znak','numery',POM.TAB)
?};
end();
_ok


\zk_n_add_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.30]
:: OPIS: argument funkcji exec('zk_n_add','zamowienia')
::  OLD: \zk_n_add_a/pd_zam.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('KH','TYPYZAM','DD','DZ','MG','Z_MG','U');
_args.KH:=null();
_args.TYPYZAM:=null();
_args.DD:=date(0,0,0);
_args.DZ:=date(0,0,0);
_args.MG:=null();
_args.Z_MG:=null;
_args.U:='';
_args


\zk_p_add_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.30]
:: OPIS: parametr funkcji zk_p_add
::  OLD: \zk_p_add_a/pd_zam.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('ZAM_REF','M','JM','J2','WS2','T2','ILZ','IL2','CENA','DK_C','U');
_args.ZAM_REF:='';
_args.M:=null();
_args.JM:=null();
_args.J2:=null();
_args.WS2:=1;
_args.T2:='';
_args.ILZ:=0;
_args.IL2:=0;
_args.CENA:=0;
_args.DK_C:=null();
_args.U:='';
_args


\zk_p_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.30]
:: OPIS: dodanie pozycji zamowienia wewnetrznego
::   WE: _a - tabela zwracana przez exec('zk_p_add_a','zamowienia')
::       _b - 1-grupowac pozycje, 2-bez grupowania
::  OLD: \zk_p_add/pd_zam.fml
::----------------------------------------------------------------------------------------------------------------------
_paramsa:=_a;
_wartiant:=_b;

_wyn:=obj_new('REF','POZ','IL');

_zkn:=null();
ZK_N.cntx_psh(); ZK_P.cntx_psh();
ZK_N.use(8+_paramsa.ZAM_REF);
ZK_N.prefix();
{? ZK_N.seek(BB.sqlint(_paramsa.ZAM_REF),)
|| _put:=0;
   _zkn:=ZK_N.ref();
   BEER.RMAG:=ZK_N.MG;
   ZK_P.use('zkpoz'+(8+_paramsa.ZAM_REF+3));
   ZK_P.index('MATN');
   ZK_P.prefix('A','Z',_zkn,1,_paramsa.M);
   _loop:=ZK_P.first();
   {!
   |? _loop
   |!
      _put:=
         {? _wartiant=1
         || ZK_P.JM=_paramsa.JM
            & ZK_P.J2=_paramsa.J2
            & ZK_P.WS2=_paramsa.WS2
            & ZK_P.T2=_paramsa.T2
            & ZK_P.CENA=_paramsa.CENA
            & ZK_P.DK_C=_paramsa.DK_C
         || _wartiant
         ?};
      _loop:=_put=0 & ZK_P.next()
   !};
   _continue:=0;
   {? _put=1
   || ZK_P.ILZ+=_paramsa.ILZ;
      ZK_P.ILP:=ZK_P.ILZ;
      _mjs:=ATR.MJS;
      ATR.MJS:='ZK_P';
      exec('aktzil2','zamsiw_poz');
      ATR.MJS:=_mjs;
      exec('war_pozz','zamsiw_poz');
      {? ZK_P.put()
      || {? ZK_P.REZ || exec('rez_pozy','rezerwacje',5) ?};
         _wyn.REF:=ZK_P.ref();
         _wyn.POZ:=ZK_P.POZ
      ?}
   || ZK_P.index('TYPN');
   ZK_P.prefix('A','Z',_zkn,1);
   BEER.ZK_N:=_zkn;
   BEER.TYP:='Z';
   ZK_P.blank();
   ZK_P.N:=_zkn;
   ZK_P.M:=_paramsa.M;
   ZK_P.JM:=_paramsa.JM;
   ZK_P.J2:=_paramsa.J2;
   ZK_P.WS2:=_paramsa.WS2;
   ZK_P.T2:=_paramsa.T2;
   ZK_P.ILZ:=_paramsa.ILZ;
   ZK_P.IL2:=_paramsa.IL2;
   ZK_P.CENA:=_paramsa.CENA;
   ZK_P.ILP:=ZK_P.ILZ;
   ZK_P.SV:=ZK_P.M().VAT;
   ZK_N.use(ref_name(ZK_P.N));
   ZK_P.TRN:=ZK_P.N().TRN;
   ZK_P.RR:=ZK_N.RR;
   ZK_P.RM:=ZK_N.RM;
   ZK_P.RT:=ZK_N.RT;
   ZK_P.U:=_paramsa.U;
   ZK_P.REZ:=exec('bl_zkpre','zamsiw_poz');
   {? ZK_P.REZ || ZK_P.DOR:=ZK_P.ILZ ?};
   ZK_P.DK_C:=_paramsa.DK_C;
   exec('war_pozz','zamsiw_poz');
   ZK_P.KH:=ZK_P.N().KH;
   ZK_P.KH_ODB:=ZK_P.N().ODB;
   {? ZK_P.add()
      || exec('inf_dod','fakso',0,'zkpoz');
      _rez:=ZK_P.REZ;
         {? ZK_P.NR=0 || ZK_P.NR:=exec('blnr_kol','zamsiw_poz',ZK_P.M) ?};
      {? ZK_P.REZ
      || ZK_P.ILR:=ZK_P.ILP:=ZK_P.ILZ
      || ZK_P.ILP:=ZK_P.ILZ; ZK_P.ILR:=0
      ?};
      ZK_P.put(1);
      exec('rozp_rez','rezerwacje');
      ZK_P.REZ:=_rez;
      ZK_P.DOST:=0;
      ZK_P.put(1);
      {? ZK_P.REZ
      || exec('aktznzkp','zamsiw_poz',ZK_P.ref(),1);
         exec('aktu_stu','zamsiw_wspolne',ZK_P.M,1,1)
      || _zkp:=tab_tmp(1,'MAT','STRING[16]','','ZKP','STRING[16]','');
         _zkp.blank(); _zkp.MAT:=$ZK_P.M; _zkp.ZKP:=$ZK_P.ref(); _zkp.add(1);
         exec('aktu_rez','rezerwacje',ZK_P.M,ZK_P.NR,ZK_P.ILZ,$ZK_P.N,_zkp);
         obj_del(_zkp)
      ?};
      _wyn.REF:=ZK_P.ref();
      _wyn.POZ:=ZK_P.POZ;
      _wyn.IL:=_paramsa.ILZ
      ?}
   ?}
?};
ZK_N.cntx_pop(); ZK_P.cntx_pop();
_wyn


\bilans_zlecenia_old
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS: Bilans surowca pojedyńczego zlecenia
::   WE: _a - ZL.ref
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: Dane domyślne
_args:=exec('bilans_a','qbilans_sur');

:: Aktualne zlecenie
VAR.A_ZLEC:=_a;

:: Data analizy OD, DO (pierwsza i ostatnia data zpalanowanej operacji dla zlecenia, ale nie wcześniej niż dzisiaj)
_tmp:=sql('select min(PROD_REJ.STARTD) as OD, max(PROD_REJ.STARTD) as DO  from PROD_REJ where PROD_REJ.ZL=:_a',VAR.A_ZLEC);
{? _tmp.first()
|| _od:={? _tmp.OD<date() | _tmp.OD=date(0,0,0)
         || date()
         || _tmp.OD
         ?};
   _do:={? _tmp.DO=date(0,0,0)
        || date()
        || _tmp.DO
        ?}
|| _od:=_do:=date()
?};

:: Wydział
_args.WYD:=VAR.A_ZLEC().JORG().KOD;
:: Data od analizy
_args.DOD:=_od;
:: Data do analizy
_args.DDO:=_do;
:: Lista magazynów bilansujących wydział, na liście jako pierwszy musi być magazyn do zbilansowania (wydziałowy)
_args.MAG_Z:=VAR.A_ZLEC().MG().SYM;
:: Zestaw formuł do analizy stanów
_args.FORM:='BILANS ZLECENIA';
:: Czy dzielić zamówienia na ZASOBY - domyślnie 'N' - nie
_args.CZY_ZAS:='T';
:: Czy dzielić zamówienia na ZMIANY - domyślne 'T'
_args.CZY_ZM:='T';
:: Czy dla pojedynczego zlecenia
_args.CZY_ZL:='T';
:: Czy bilansować surowce, czy zamówienie na podstawie limitów zleceń
_args.CZY_BIL:='T';


:: Definicje magazynów do bilansowania zapisane są w strukturze o nazwie PROD_SUR w polu opis dla każdego elementu
:: Element musi mieć symbol zgodny z wydziałem
:: debug();
::_ud_skl:=exec('szukaj_ud_skl','schemat','PROD_SUR',_args.WYD);
::{? _ud_skl<>null()
::|| _args.MAG_Z:=sql('select UD_SKL.OPIS from @UD_SKL where UD_SKL.REFERENCE=:_a',_ud_skl).OPIS
::?};
::{? _args.MAG_Z=''
::|| _args.MAG_Z:=_args.WYD
::?};

_PAR:=tab_tmp(,'WYD','STRING[20]','Symbol wydziału',
                'DOD','DATE','Data od',
                'DDO','DATE','Data do',
                'MAG_Z','STRING[60]','Magazyny bilansująsce stan wydziału',
                'FORM','STRING[60]','Zestaw formuł do analizy stanów',
                'CZY_ZM','STRING[1]','Czy podział zapotrzebowań na zmiany produkcyjne',
                'CZY_ZAS','STRING[1]','Czy podział zapotrzebowań na stanowiska produkcyjne',
                'CZY_ZL','STRING[1]','Analiza aktualnie wybranego zlecenia',
                'CZY_BIL','STRING[1]','Uwzględniać stany (analizę) magazynu produkcyjnego'
                );
_PAR.blank();
_PAR.WYD:=_args.WYD;
_PAR.DOD:=_args.DOD;
_PAR.DDO:=_args.DDO;
_PAR.MAG_Z:=_args.MAG_Z;
_PAR.FORM:=_args.FORM;
_PAR.CZY_ZAS:=_args.CZY_ZAS;
_PAR.CZY_ZM:=_args.CZY_ZM;
_PAR.CZY_ZL:=_args.CZY_ZL;
_PAR.CZY_BIL:=_args.CZY_BIL;

::_ed:=_PAR.mk_edit('Parametry do bilansowania');
::_PAR.win_efld(_ed,,'WYD',,,,,1);
::_PAR.win_efld(_ed,,'MAG_Z',,,,,1);
::_PAR.win_efld(_ed,,'FORM',,,,,1);
::_PAR.win_efld(_ed,,'DOD',,,,,0);
::_PAR.win_efld(_ed,,'DDO',,,,,0);
::_PAR.win_efld(_ed,,'CZY_ZM',,,,,0,,,,'check-box','check_label="tak, podziel zapotrzebowania"',"'T'","'N'");
::_PAR.win_efld(_ed,,'CZY_ZAS',,,,,0,,,,'check-box','check_label="tak, podziel zapotrzebowania"',"'T'","'N'");
::_PAR.win_efld(_ed,,'CZY_ZL',,,,,0,,,,'check-box','check_label="tak, analiza wybranego zlecenia"',"'T'","'N'");
::_PAR.win_efld(_ed,,'CZY_BIL',,,,,0,,,,'check-box','check_label="tak, uwzględnić analizę stanu"',"'T'","'N'");
::_btn:=_PAR.win_ebtn(_ed,'text=&OK, icon=xwin16.png:13',"'key:F2'");
::_PAR.win_ebtn(_ed,'text=&Anuluj, icon=xwin16.png:14',"'key:Esc'");
::_PAR.btn_opt(_btn, 'default=1');
::_PAR.win_edit(_ed);
:: formuła walidacyjna
::wf:="{? cur_tab().DOD>cur_tab().DDO
::     || FUN.error('Data końca analizy nie może być wcześniejsza niż data jej początku !');
::        'DDO'
::     || ''
::     ?}";

::{? _PAR.edit(wf)
::|| _PAR.add();
::   _args.DOD:=_PAR.DOD;
::   _args.DDO:=_PAR.DDO;
::   _args.CZY_ZAS:=_PAR.CZY_ZAS;
::   _args.CZY_ZM:=_PAR.CZY_ZM;
::   _args.CZY_ZL:=_PAR.CZY_ZL;
::   _args.CZY_BIL:=_PAR.CZY_BIL;
   exec('bilans','qbilans_sur',_args);
::?};
1


\zest_sur_wym
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [21.14]
:: OPIS: Zestawienie surowców wymaganych na wydziału podlegającego analizie
::   WE: _a - tabela zgodna z __ENV_AN.TAB
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: analiza danych
_tab:=sql('select :_a.DW,
            :_a.ZASOB,
            :_a.KTM,
            :_a.N,
            :_a.JM,
                sum(case when :_a.ZMIANA=\'Zmiana 1\' then :_a.IL else 0 end) as ZMIAN1,
                sum(case when :_a.ZMIANA=\'Zmiana 2\' then :_a.IL else 0 end) as ZMIAN2,
                sum(case when :_a.ZMIANA=\'Zmiana 3\' then :_a.IL else 0 end) as ZMIAN3,
                sum(:_a.IL) as SUMA
      from :_a group by :_a.DW,:_a.ZASOB,:_a.KTM,:_a.N,:_a.JM'
     ,_a);

:: Okienko do select tabeli z surowcami.
_wer:=_tab.mk_sel('Surowce wymagane na wydziale'@,'T',,'#analizadwyd',1,1,,,'U');
_tab.win_fld(_wer,,'DW',,,-10,,,'Data wymagana'@,,'Wymagana dostępność — data'@);
_tab.win_fld(_wer,,'ZASOB',,,20,,,'Zasób'@);
_tab.win_fld(_wer,,'KTM',,,20,,,'Indeks'@);
_tab.win_fld(_wer,,'N',,,30,,,'Nazwa'@);
_tab.win_fld(_wer,,'ZMIAN1',,,-15,ST.DOKL,,'Ilość ZM1'@);
_tab.win_fld(_wer,,'ZMIAN2',,,-15,ST.DOKL,,'Ilość ZM2'@);
_tab.win_fld(_wer,,'ZMIAN3',,,-15,ST.DOKL,,'Ilość ZM3'@);
_tab.win_fld(_wer,,'SUMA',,,-15,ST.DOKL,,'Ilość SUMA'@);
_tab.win_fld(_wer,,'JM',,,5,,,'jm'@);

:: Wyświetlenie zestawienia surowców
_tab.win_sel(_wer);
_tab.select();
0


\zest_sur_wyd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [21.14]
:: OPIS: Zestawienie surowców znajdujących się na stanie wydziału podlegającego analizie
::   WE: _a - tabela zgodna z __ENV_AN.TAB
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: analiza danych
_tab:=sql('select :_a.DW,
            :_a.ZASOB,
            :_a.KTM,
            :_a.N,
            :_a.JM,
                sum(case when :_a.ZMIANA=\'Zmiana 1\' then :_a.IL else 0 end) as ZMIAN1,
                sum(case when :_a.ZMIANA=\'Zmiana 2\' then :_a.IL else 0 end) as ZMIAN2,
                sum(case when :_a.ZMIANA=\'Zmiana 3\' then :_a.IL else 0 end) as ZMIAN3,
                sum(:_a.IL) as SUMA
      from :_a
      where :_a.DOSTEPNY=1
      group by :_a.DW,:_a.ZASOB,:_a.KTM,:_a.N,:_a.JM'
     ,_a);

:: Okienko do select tabeli z surowcami.
_wer:=_tab.mk_sel('Surowce dostępne na wydziale'@,'T',,'#analizadwym',1,1,,,'U');
_tab.win_fld(_wer,,'DW',,,-10,,,'Data wymagana'@,,'Wymagana dostępność — data'@);
_tab.win_fld(_wer,,'ZASOB',,,20,,,'Zasób'@);
_tab.win_fld(_wer,,'KTM',,,20,,,'Indeks'@);
_tab.win_fld(_wer,,'N',,,30,,,'Nazwa'@);
_tab.win_fld(_wer,,'ZMIAN1',,,-15,ST.DOKL,,'Ilość ZM1'@);
_tab.win_fld(_wer,,'ZMIAN2',,,-15,ST.DOKL,,'Ilość ZM2'@);
_tab.win_fld(_wer,,'ZMIAN3',,,-15,ST.DOKL,,'Ilość ZM3'@);
_tab.win_fld(_wer,,'SUMA',,,-15,ST.DOKL,,'Ilość SUMA'@);
_tab.win_fld(_wer,,'JM',,,5,,,'jm'@);

:: Wyświetlenie zestawienia surowców
_tab.win_sel(_wer);
_tab.select();
0


\bilans_zlecenia
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS: Bilans surowca pojedyńczego zlecenia, z możliwością wybrania daty na kiedy chcemy produkować
::   WE: _a - ZL.ref
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: Dane domyślne
_args:=exec('bilans_a','qbilans_sur');

:: Aktualne zlecenie
VAR.A_ZLEC:=_a;

:: Zmienna sterująca analizą tylko zleceń o statusie otwarte
:: brak zmiennej lub 0 - wszystkie zlim,
:: 1 - tylko zlecenia zaakceptowane w planie operacyjnym
q_analiza_zlec:=1;


:: Data analizy OD, DO (pierwsza i ostatnia data zpalanowanej operacji dla zlecenia, ale nie wcześniej niż dzisiaj)
_tmp:=sql('select min(PROD_REJ.STARTD) as OD, max(PROD_REJ.STARTD) as DO  from PROD_REJ where PROD_REJ.ZL=:_a',VAR.A_ZLEC);
{? _tmp.first()
|| _od:={? _tmp.OD<date() | _tmp.OD=date(0,0,0)
         || date()
         || _tmp.OD
         ?};
   _do:={? _tmp.DO=date(0,0,0)
        || date()
        || _tmp.DO
        ?}
|| _od:=_do:=date()
?};

:: Wydział
_args.WYD:=VAR.A_ZLEC().JORG().KOD;
:: Data od analizy
_args.DOD:=_od;
:: Data do analizy
_args.DDO:=_do;
:: Lista magazynów bilansujących wydział, na liście jako pierwszy musi być magazyn do zbilansowania (wydziałowy)
_ud_skl:=exec('szukaj_ud_skl','schemat','PROD_SUR',_args.WYD);

{? _ud_skl<>null()
|| _args.MAG_Z:=sql('select UD_SKL.OPIS from @UD_SKL where UD_SKL.REFERENCE=:_a',_ud_skl).OPIS
|| _args.MAG_Z:=VAR.A_ZLEC().MG().SYM
?};
:: Zestaw formuł do analizy stanów
_args.FORM:='BILANS ZLECENIA';
:: Czy dzielić zamówienia na ZASOBY - domyślnie 'N' - nie
_args.CZY_ZAS:='T';
:: Czy dzielić zamówienia na ZMIANY - domyślne 'T'
_args.CZY_ZM:='T';
:: Czy dla pojedynczego zlecenia
_args.CZY_ZL:='T';
:: Czy bilansować surowce, czy zamówienie na podstawie limitów zleceń
_args.CZY_BIL:='T';


:: Definicje magazynów do bilansowania zapisane są w strukturze o nazwie PROD_SUR w polu opis dla każdego elementu
:: Element musi mieć symbol zgodny z wydziałem
:: debug();
::_ud_skl:=exec('szukaj_ud_skl','schemat','PROD_SUR',_args.WYD);
::{? _ud_skl<>null()
::|| _args.MAG_Z:=sql('select UD_SKL.OPIS from @UD_SKL where UD_SKL.REFERENCE=:_a',_ud_skl).OPIS
::?};
::{? _args.MAG_Z=''
::|| _args.MAG_Z:=_args.WYD
::?};

_PAR:=tab_tmp(,'WYD','STRING[20]','Symbol wydziału',
                'DOD','DATE','Produkcja w dniu',
                'DDO','DATE','Data do',
                'MAG_Z','STRING[60]','Magazyny bilansująsce stan wydziału',
                'FORM','STRING[60]','Zestaw formuł do analizy stanów',
                'CZY_ZM','STRING[1]','Czy podział zapotrzebowań na zmiany produkcyjne',
                'CZY_ZAS','STRING[1]','Czy podział zapotrzebowań na stanowiska produkcyjne',
                'CZY_ZL','STRING[1]','Analiza aktualnie wybranego zlecenia',
                'CZY_BIL','STRING[1]','Uwzględniać stany (analizę) magazynu produkcyjnego'
                );
_PAR.blank();
_PAR.WYD:=_args.WYD;
_PAR.DOD:=_args.DOD;
_PAR.DDO:=_args.DDO;
_PAR.MAG_Z:=_args.MAG_Z;
_PAR.FORM:=_args.FORM;
_PAR.CZY_ZAS:=_args.CZY_ZAS;
_PAR.CZY_ZM:=_args.CZY_ZM;
_PAR.CZY_ZL:=_args.CZY_ZL;
_PAR.CZY_BIL:=_args.CZY_BIL;

_ed:=_PAR.mk_edit('Parametry do bilansowania');
_PAR.win_efld(_ed,,'WYD',,,,,1);
_PAR.win_efld(_ed,,'MAG_Z',,,,,1);
_PAR.win_efld(_ed,,'FORM',,,,,1);
_PAR.win_efld(_ed,,'DOD',,,,,0);
::_PAR.win_efld(_ed,,'DDO',,,,,0);
::_PAR.win_efld(_ed,,'CZY_ZM',,,,,0,,,,'check-box','check_label="tak, podziel zapotrzebowania"',"'T'","'N'");
::_PAR.win_efld(_ed,,'CZY_ZAS',,,,,0,,,,'check-box','check_label="tak, podziel zapotrzebowania"',"'T'","'N'");
_PAR.win_efld(_ed,,'CZY_ZL',,,,,1,,,,'check-box','check_label="tak, analiza wybranego zlecenia"',"'T'","'N'");
_PAR.win_efld(_ed,,'CZY_BIL',,,,,0,,,,'check-box','check_label="tak, uwzględnić analizę stanu"',"'T'","'N'");
_btn:=_PAR.win_ebtn(_ed,'text=&OK, icon=xwin16.png:13',"'key:F2'");
_PAR.win_ebtn(_ed,'text=&Anuluj, icon=xwin16.png:14',"'key:Esc'");
_PAR.btn_opt(_btn, 'default=1');
_PAR.win_edit(_ed);
:: formuła walidacyjna
::wf:="{? cur_tab().DOD>cur_tab().DDO
::     || FUN.error('Data końca analizy nie może być wcześniejsza niż data jej początku !');
::        'DDO'
::     || ''
::     ?}";

{? _PAR.edit()
|| _PAR.add();
   _args.DOD:=_PAR.DOD;
   _args.DDO:=_PAR.DOD;
   _args.CZY_ZAS:=_PAR.CZY_ZAS;
   _args.CZY_ZM:=_PAR.CZY_ZM;
   _args.CZY_ZL:=_PAR.CZY_ZL;
   _args.CZY_BIL:=_PAR.CZY_BIL;
   exec('bilans','qbilans_sur',_args)
?};
VAR_DEL.delete('q_analiza_zlec');

1
