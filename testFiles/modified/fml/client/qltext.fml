:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: q#text.fml
:: Utworzony: 2016
:: Autor: jerry
:: Systemy:
::======================================================================================================================
:: Zawartość: biblioteka funkcji tekstowych
::======================================================================================================================


\split_lines --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry []
:: OPIS: Dzieli tekst na linie o podanej długości
::   WE: _tekst
::       _dl_lini
::   WY: _tab - tabela z kolejnymi wierszami
::              pierwsza kolumna kluczowa LP
::----------------------------------------------------------------------------------------------------------------------
_txt:=_a;
_size:=_b;

_tab:=tab_tmp(1,'LP','INTEGER','Lp','TXT','STRING[255]','Tekst');

_words:=obj_new(1);
_akapit:=spli_str(_txt,'\n');
{! _aa:=1..obj_len(_akapit)
|! _txt:=_akapit[_aa];
   {? +_txt<=_size
   || _tab.LP+=1;
      _tab.TXT:=_txt;
      _tab.add()
   ||
      obj_del(_words);
      _words:=spli_str(exec('trim_right','qltext',_txt),' ');

      _tab.LP+=1;
      _tab.TXT:=_words[1];
      {! _ww:=2..obj_len(_words)
      |!

         {? form(_words[_ww])=''
         || ~~
         |? +(_tab.TXT+' '+_words[_ww])<=_size
         || _tab.TXT+=' '+_words[_ww]
         || _tab.add();
            _tab.LP+=1;
            _tab.TXT:=_words[_ww]
         ?}
      !};
      _tab.add()
   ?}
!};
_tab.first();
_tab


\split_memo --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry []
:: OPIS: dzieli podany tekst na wiersze i kolumny
::   WE: _a [STRING] - memo_txt
::       _b [STRING]- separtator np ';'
::       _c [STRING] - system podzialu - liczba znaków w kolumnie np.: '10;10;20;10;10;200'
::   WY: tab - tabela z kolejnymi wierszami
::             pierwsza kolumna kluczowa LP
::----------------------------------------------------------------------------------------------------------------------
_txt:=_a;
_sep:=_b;
_def:=_c;
_fml:="tab_tmp(1,'LP','INTEGER','Lp','LN','INTEGER','Ln'";
_dl:=spli_str(_def,_sep);

{! _cc:=1..obj_len(_dl)
|! {? #_dl[_cc]<=0 | #_dl[_cc]>255 || _dl[_cc]:='255' ?};
   _fml+=",'COL"+form(_cc,-5,,'99')+"','STRING["+_dl[_cc]+"]','Kolumna "+form(_cc)+"'";
   _dl[_cc]:=#_dl[_cc]
!};
_fml+=')';
_tab:=($_fml)();

_lines:=spli_str(_txt,'\n');
_sl:=obj_new(1);

_max_dl:=obj_len(_dl);
_max_sl:=obj_len(_sl);

_lp:=0;
{! _ll:=1..obj_len(_lines)
|!
   obj_del(_sl);
   _sl:=spli_str(_lines[_ll],_sep);
   _max_sl:=obj_len(_sl);
   _max:={? _max_sl>_max_dl || _max_dl || _max_sl ?};
:: najpierw podzielim tekst na odpowiednie dlugosci i pozawijam linijki
   _max_row:=0;
   {! _mm:=1.._max
   |! _sl[_mm]:=exec('split_lines','qltext',_sl[_mm],_dl[_mm]);
      _sl[_mm].first();
      {? _sl[_mm].size()>_max_row || _max_row:=_sl[_mm].size() ?}
   !};
   {! _rr:=1.._max_row
   |! _tab.blank(1);
      {? _rr=1 || _tab.LN:=_ll ?};
      _tab.LP:=(_lp+=1);
      {! _mm:=1.._max
      |! {? _sl[_mm].LP=_rr
         || _tab[_mm+2]:=_sl[_mm].TXT;
            _sl[_mm].next()
         ?}
      !};
      _tab.add()
   !}
!};

_tab


\test4split_memo --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry []
:: OPIS: Tekst do testów split_memo
::   WE: _a - separator
::       _b - system
::       _c - liczba wierszy
::       _d - znak
::   WY: tekst
::----------------------------------------------------------------------------------------------------------------------
_sep:=_a;
_def:=_b;
_rnum:=_c;
_char:=_d;

_dl:=spli_str(_def,_sep);
{! _cc:=1..obj_len(_dl)
|! {? #_dl[_cc]<=0 | #_dl[_cc]>255 || _dl[_cc]:='255' ?};
   _dl[_cc]:=#_dl[_cc]
!};
_result:='';
{! _rr:=1.._rnum
|! _line:='';
   {! _cc:=1..obj_len(_dl)
   |! _line+=(_char*_dl[_cc])+_sep
   !};
   _result+=(_line-(+_sep))+'\n'
!};
form(_result)


\trim_right --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry []
:: OPIS: Kasuje białe znaki z końca tekstu.
::   WE: STRING: _a
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
_src:=_a; _dst:=''; _len:=+_src; {! _cc:=1.._len |! _dst+=_src+1; _src:=_src-1 !}; _src:=|_dst; _dst:=''; _len:=+_src; {! _cc:=1.._len |! _dst+=_src+1; _src:=_src-1 !}; _dst


\column2memo --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry []
:: OPIS:
::   WE:  _a  [TABLE] - wskazanie na tabelę
::       [_b] [STRING] - separator kolumny ['\t']
::       [_c] [STRING] - separator wiersza ['\n']
::       [_d] [STRING] - akronim kolejnych pól
::       [_e] [STRING] - ....
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: EXEC: exec('column2memo','q#libfml')
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_sep_col:="+'"+{? var_pres('_b')=2 || _b || '\t' ?}+"'+";
_sep_line:="+'"+{? var_pres('_c')=2 || _c || '\n' ?}+"'";

_fml:='';
{! _pp:=4.._ |! _fml+=''+_[_pp]+''+_sep_col !};
_fml:=_fml-(+_sep_col);

_fml:="
   _tab:=_a;
   _result:='';
   {| _tab
   |!
   {? first()
   ||
      {!
      |?
         _result+="+_fml+_sep_line+";
         next()
      !}
   ?}
   |};
   _result
";
($_fml)(_tab)


\hform --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry []
:: OPIS: Zwraca tekst sformatowany do odpowiedniej strony
::   WE:  _a  [STRING] - tekst do sformatowania
::        _b  [NUMBER] - szerokość na jakiej formatujemy
::       [_c] [STRING] - sposób formatowania - [L]eft, Right, Center
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
:: EXEC: exec('hform','q#text')
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_text:=_a;
_size:=_b;
_form:=~-(1+{? var_pres('_c')=2 || _c || 'L' ?});

{? 'L'*_form
|| _size+(_text+(_size*' '))

|? 'PR'*_form
|| ((_size*' ')+_text)+_size

|? 'C'*_form
|| _tsize:=+_text;
   {? _size<=_tsize
   || _size+_text
   || _size:=_size-_tsize;
      _lsize:=int(_size/2);
      _rsize:=_size-_lsize;
      (_lsize*' ')+_text+(_rsize*' ')
   ?}
|| ''
?}


\pform --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [ERG]
:: OPIS: Wyrównuje akapit podany w parametrze
::   WE:  _a  [STRING] - tekst do sformatowania
::       [_b] [STRING] - sposób formatowania - [L]eft, Right, Center
::   WY: Tekst
::----------------------------------------------------------------------------------------------------------------------
:: EXEC: exec('pform','q#text')
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_txt:={? var_pres('_a')=2 || _a || ~~ ?};
_form:=~-(1+{? var_pres('_b')=2 || _b || 'L' ?});

_result:='';
{? _txt<>~~
|| _lines:=spli_str(_txt,'\n');
   _size:=0;
   {! _ll:=1..obj_len(_lines)
   |! {? +_lines[_ll]>_size || _size:=+_lines[_ll] ?}
   !};

   {! _ll:=1..obj_len(_lines)
   |!
      _text:=_lines[_ll];
      _result+={? 'L'*_form
      || _size+(_text+(_size*' '))

      |? 'PR'*_form
      || ((_size*' ')+_text)+_size

      |? 'C'*_form
      || _tsize:=+_text;
         {? _size<=_tsize
         || _size+_text
         || _size:=_size-_tsize;
            _lsize:=int(_size/2);
            _rsize:=_size-_lsize;
            (_lsize*' ')+_text+(_rsize*' ')
         ?}
      || _size*' '
      ?}+'\n'
   !};
   {? _result+1='\n' || _result:=_result-1 ?}
?};
_result


\diff_text_lines --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [1241jf]
:: OPIS: Zwraca liczbę różnic w liniach dwóch tekstach
::   WE:  _a [TEXT] -
::        _b [TEXT] -
::   WY: [NUMBER] liczba różniących się linijek
::----------------------------------------------------------------------------------------------------------------------
:: EXEC: exec('diff_text_lines','q#fun')
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_lline:=spli_str(_a,'\n');
_rline:=spli_str(_b,'\n');

_lsize:=obj_len(_lline);
_rsize:=obj_len(_rline);

_d_line:=0;
_max:={? _rsize=_lsize || _rsize
      |? _rsize<_lsize || _d_line:=_lsize-_rsize; _rsize
                       || _d_line:=_rsize-_lsize; _lsize
      ?};
::
::_lpos:=1;
::_rpos:=1;
::
::{!
::|?
::   {? _lline[_lpos]=_rline[_rpos]
::   || _lpos+=1;
::      _rpos+=1;
::      _lpos<_lsize
::      _rpos<_rsize
:: :: szukam czy znajdę lewą linię w dalszej części prawego pliku
::   || _crpos:=_rpos;
::      {!
::      |?
::
::      !}
::   ?}
::!}


{! _ll:=1.._max
|! _d_line+=_lline[_ll]<>_rline[_ll]
!};

_d_line


\memo2rep --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  -- memo2rep
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry []
:: OPIS: Zwraca kod dla wydruku
::   WE:  _a  [STRING] - tekst do sformatowania
::       [_b] [NUMBER] - maksymalna liczba znaków w wierszu
::   WY: STRING tekst do wklejenia w {REP: ....}
::----------------------------------------------------------------------------------------------------------------------
_sMemo:=_a;
_nWidth:=_b;

_nStart:=2;

_oMemo:=spli_str(_sMemo,'\n');
_sPack:='';

_sRep:=''+"{'';~~}";

_lRows:=obj_new(1);
_nMemo:=obj_len(_oMemo);
_sPack:='';
{! _no:=1.._nMemo
|! _sLine:=_oMemo[_no];

   {? (_sLine*'\t'=0 | _no=_nMemo)
    & +_sPack
   || obj_del(_lRows);
      _lRows:=exec('pack2table','qltext',_sPack-1,'\t');
      {? _lRows.first()
      ||
         {!
         |?
            _nSpoz:=_nStart;
            _sRow:='';
            {! _nfld:=2.._lRows.fld_num()
            |! _sRow+="{<"+form(_nSpoz,,,'99')+"}"+_lRows[_nfld];
               _nSpoz+=(#_lRows.fld_name(_nfld))+4;
               ~~
            !};
            _sRep+="\n"+_sRow;
            _lRows.next()
         !}
      ?};
      _sRep+="\n"+{? +_sLine || "{<"+form(_nStart,,,'99')+"}"+_sLine || ' ' ?};
      _sPack:='';
      ~~

   |? _sLine*'\t'=0 | _no=_nMemo
   || _sRep+="\n"+{? +_sLine || "{<"+form(_nStart,,,'99')+"}"+_sLine || ' ' ?};
      ~~
   || _sPack+=_sLine+'\n'
   ?}
!};

_sRep


\pack2table --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  -- -- pack2table
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [Ekoinstal]
:: OPIS: Zwraca tabelę na podstawie akapitu z tabulatorami
::   WE:  _a  [STRING] - tekst akapitu
::       [_b] [STRING] - separator
::       [_c] [] -
::       [_d] [] -
::       [_e] [] -
::   WY: tabela
::----------------------------------------------------------------------------------------------------------------------
_sMemo:=_a;
_sSep:=_b;
_oMax:=obj_new(250);
_nMax:=obj_len(_oMax);
{! _om:=1.._nMax |! _oMax[_om]:=0 !};

_oMemo:=spli_str(_sMemo,'\n');
{! _no:=1 .. obj_len(_oMemo)
|! "
    _oLine:=_a;
    _oMax:=_b;
    _nMax:=obj_len(_oMax);
    {? obj_len(_oLine)<_nMax || _nMax:=obj_len(_oLine) ?};
    {! _nm:=1.._nMax
    |! {? _oMax[_nm]<+_oLine[_nm] || _oMax[_nm]:=+_oLine[_nm] ?}
    !}
   "(spli_str(_oMemo[_no],_sSep), _oMax)
!};

_fTab:="
   tab_tmp(1
          ,'LP'      ,'REAL',''";
{! _no:=1.._nMax
|? {? _oMax[_no]>0
   || _fTab+="
          ,'COL"+form(_no,-3,,'99')+"',  'STRING["+form(_oMax[_no],,,'99')+"]' ,'"+form(_oMax[_no],,,'99')+"'";
      1
   || 0
   ?}
!};

_lTab:=($(_fTab+')'))();

{! _no:=1 .. obj_len(_oMemo)
|! "
    _oLine:=_a;
    _lTab:=_b;
    _nPoz:=_lTab.LP+1;

    _nMax:=obj_len(_lTab)-1;
    {? obj_len(_oLine)<_nMax || _nMax:=obj_len(_oLine) ?};
    _lTab.blank();
    _lTab.LP:=_nPoz;
    {! _nm:=1.._nMax
    |! _lTab[_nm+1]:={? +_oLine[_nm] || _oLine[_nm] || ' ' ?}
    !};
    _lTab.add()
   "(spli_str(_oMemo[_no],_sSep), _lTab)
!};

_lTab


\text2array --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --   text2array
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [MBToolBox]
:: OPIS: Przekształca tekst w tablice znaków (alias str2array)
::   WE: _a [STRING] - tekst do podziału
::   WY: ARRAY - tablica znaków tekstu
::----------------------------------------------------------------------------------------------------------------------
exec('str2array','qltext',_a)


\str2array --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  - str2array
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [MBToolBox]
:: OPIS: Przekształca tekst w tablicę znaków
::   WE: _a [STRING] - tekst do podziału
::   WY: ARRAY - tablica znaków tekstu
::----------------------------------------------------------------------------------------------------------------------
{? +_a<65536
 & +_a>0
|| _aResult:=obj_new(+_a);
   {! _nc:=1..+_a
   |! _aResult[_nc]:=1+_a;
      _a:=1-_a
   !}
|| _aResult:=obj_new('error'); _aResult.error:=+_a
?};
_aResult


\cTag --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  -- -- cTag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [MBToolBox]
:: OPIS: Klasa do obsługi tag'ów
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_cTag:=obj_new('ąćę'
              ,'sPrefix'
              ,'sBPrefix'
              ,'sEPrefix'

              ,'sSufix'
              ,'sBSufix'
              ,'sESufix'

              ,'sTagStart'
              ,'sTagEnd'
              ,'sParams'
              ,'sValue'

              ,'fDecode'
              );

_cTag.sPrefix:='<';
_cTag.sBPrefix:='<';
_cTag.sEPrefix:='</';

_cTag.sSufix:='>';
_cTag.sBSufix:='>';
_cTag.sESufix:='>';

_cTag.fDecode:="
   _sTxt:=_a;
   .sTagStart:='';
   .sTagEnd:='';
   .sParams:='';
   .sValue:='';

   {? _a*.sPrefix=0
    & _a*.sSufix=0
   || .sValue:=_sTxt
   || _oTxt:=exec('str2array','qltext',_a);
      {? var_press('error',_oTxt)=1
      || debug(); /'zonk'
      || ~~
      ?}
   ?}
";
_cTag


\f3_insert --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  -- -- f3_insert
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry []
:: OPIS: obsługa wstawiania tekstu w polu np. na F3 - UWAGA: praca w polu edycyjnym!!!
::   WE: _a [STRING] tekst do wstawienia
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_nPos:=get_cpos()-1;
_sFld:=fld();
_sKey:=_a;
fld((_nPos+_sFld)+_sKey+(_nPos-_sFld));
set_cpos(_nPos+(+_sKey)+1)