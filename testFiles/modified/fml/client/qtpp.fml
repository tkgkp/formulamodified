:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: qtpp.fml
:: Utworzony: 13.08.2020
:: Autor: TP
:: Systemy:
::======================================================================================================================
:: Zawartość: Formuły do obslugi dziedziny planowania produkcji
::======================================================================================================================

\czas_wg_serii
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [meri 2014]
:: OPIS: Ustawia zawartość formuły czas_wg_serii dla potrzeb wyliczania czasów wg serii - ukrety
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

czas_wg_serii:=" {? PX_OPER.PX_STAGE().TOPER<>null()
                 || _ref_toper:=PX_OPER.PX_STAGE().TOPER
                 || _ref_toper:=exec('FindAndGet','#table',TOPER,PX_OPER.PX_STAGE().RTOPER,,,null())
                 ?};
                 _ilosc_max:=#(sql(\'select UAT.WAR
                      from UAT join TAT
                      where UAT.TAB=\\'TOPER*\\' and UAT.ACT=\\'T\\' and UAT.REF=:_a and UAT.MSK=\\':_b\\' and TAT.NR=:_c\'
                     ,ref_num(_ref_toper) ,ref_name(_ref_toper), q_parametry.par_max).WAR);

                 _toper_sql:=PX_OPER.PX_STAGE().RTOPER;
                 _toper:=sql(\'select TOPER.MTIME, TKTL.XJM, TOPER.NTIME
                                   from TOPER join TKTL using(TOPER.NRK,TKTL.REFERENCE)
                                  where TOPER.REFERENCE=\\':_a\\'\',
                                 _toper_sql);
                 {? _toper.first()
                 || q_px.XJM:=_toper.XJM;
                    q_px.CZAS_OP:={? _toper.MTIME=0
                                  || _toper.NTIME
                                  || _toper.MTIME
                                  ?}
                 ?};
                 {? q_px.CZAS_OP<=0
                 || q_px.CZAS_OP:=1
                 ?};
                 {? q_px.PROP<=0
                 || q_px.PROP:=1
                 ?};
                 {? q_px.XJM<=0
                 || q_px.XJM:=1
                 ?};
                 {? q_px.ILOSC<=0
                 || {? _ilosc_max>0
                    || q_px.ILOSC:=_ilosc_max
                    || q_px.ILOSC:=q_px.XJM
                    ?}
                 ?};
                 {? _ilosc_max>0
                 || _ilosc:=ceil(q_px.ILOSC/_ilosc_max)
                 |? q_px.XJM>0
                 || _ilosc:=ceil(q_px.ILOSC/q_px.XJM)
                 || _ilosc:=1
                 ?};
                 \'Ilosc tpz-ów\';
                 _tpz:=_ilosc;
                 _czas_op:=q_px.CZAS_OP;
                 _prop:=q_px.PROP;
                 q_px.zeruj();
                 q_px.TPZ:=_tpz;
                (_ilosc*_czas_op)/_prop
               ";
1


\q_parametry
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [meri 2014]
:: OPIS: Parametry dla potrzeb wtyczki podziału na przewodniki - odczyt ze parametrów wdrożeniowych
::   par_czy - czy dzielić przewodnik na części automatycznie
::   par_min - minimum jakie powinno być umieszczone w przewodniku
::   par_max - maximum jakie powinno być umieszczone w przewodniku
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

q_parametry:=obj_new('par_czy','par_min','par_max','ustaw');

q_parametry.ustaw:=$' q_parametry.par_czy:=exec(\'get_w\',\'#params\',999001,type_of(0));
                     q_parametry.par_min:=exec(\'get_w\',\'#params\',999003,type_of(0));
                     q_parametry.par_max:=exec(\'get_w\',\'#params\',999002,type_of(0));
                     1';
q_parametry.ustaw();
1


\obj_pieca
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS: Ustawia formułę do obliczana zajętość objętości pica wg. ilości maksymalnej - potrzebne do planowania strateg.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------


obj_pieca:=" _obj:=0;

             _ilosc_max:=#(sql(\'select UAT.WAR
                      from UAT join TAT
                      where UAT.TAB=\\'TOPER*\\' and UAT.ACT=\\'T\\' and UAT.REF=:_a and UAT.MSK=\\':_b\\' and TAT.NR=:_c\'
                     ,ref_num(PX_OPER.PX_STAGE().TOPER) ,ref_name(PX_OPER.PX_STAGE().TOPER), q_parametry.par_max).WAR);

             {? _ilosc_max>0
             || _toper_sql:=PX_OPER.PX_STAGE().RTOPER;
                _toper:=sql(\'select TOPER.NTIME, TKTL.XJM, TOPER.MTIME
                                  from TOPER join TKTL using(TOPER.NRK,TKTL.REFERENCE)
                                  where TOPER.REFERENCE=\\':_a\\'\',
                                 _toper_sql);
                {? _toper.first()
                || q_px.XJM:=_toper.XJM
                ?};
                {? q_px.CZAS_OP<=0
                || q_px.CZAS_OP:={? _toper.MTIME=0
                                 || _toper.NTIME
                                 || _toper.MTIME
                                 ?}
                ?};
                _obj:=(q_px.XJM/_ilosc_max*100)*(q_px.CZAS_OP/24)$0
             ?};
             q_px.zeruj();
             _obj
           ";

czas_wg_pieca:=" {? PX_OPER.PX_STAGE().TOPER<>null()
                 || _ref_toper:=PX_OPER.PX_STAGE().TOPER
                 || _ref_toper:=exec('FindAndGet','#table',TOPER,PX_OPER.PX_STAGE().RTOPER,,,null())
                 ?};

                 _ilosc_max:=#(sql(\'select UAT.WAR
                      from UAT join TAT
                      where UAT.TAB=\\'TOPER*\\' and UAT.ACT=\\'T\\' and UAT.REF=:_a and UAT.MSK=\\':_b\\' and TAT.NR=:_c\'
                     ,ref_num(PX_OPER.PX_STAGE().TOPER) ,ref_name(_ref_toper), q_parametry.par_max).WAR);
                 _toper_sql:=PX_OPER.PX_STAGE().RTOPER;
                 _toper:=sql(\'select TOPER.NTIME, TKTL.XJM, TOPER.MTIME
                                  from TOPER join TKTL using(TOPER.NRK,TKTL.REFERENCE)
                                  where TOPER.REFERENCE=\\':_a\\'\',
                                 _toper_sql);
                 _toper.first();
                 {? q_px.XJM<=0 || q_px.XJM:=_toper.XJM ?};
                 {? q_px.CZAS_OP<=0
                 || q_px.CZAS_OP:={? _toper.MTIME=0
                                  || _toper.NTIME
                                  || _toper.MTIME
                                  ?}
                 ?};
                 {? q_px.PROP<=0 || q_px.PROP:=1 ?};
                 {? q_px.XJM<=0 || q_px.XJM:=1 ?};
                 {? q_px.ILOSC<=0
                 || q_px.ILOSC:=_ilosc_max
                 || {? q_px.ILOSC<_ilosc_max
                    || q_px.ILOSC:=_ilosc_max
                    ?}
                 ?};
                 {? _ilosc_max>0
                 || _ilosc:=ceil(q_px.ILOSC/_ilosc_max)
                 || \'Jeśli brakuje parametru max to przyjmuje 48 godz.\';
                    _ilosc:=1;
                    q_px.CZAS_OP:=48
                 ?};
                 \'Ilosc tpz-ów\';
                 _tpz:=_ilosc;
                 _czas_op:=q_px.CZAS_OP;
                 _prop:=q_px.PROP;
                 q_px.zeruj();
                 q_px.TPZ:=_tpz;
                (_ilosc*_czas_op)/_prop
               ";
1


\q_px_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [merit 20xx]
:: OPIS: Zmienna do obliczeń związanych z pojemnościami stałymi dla planu strategicznego
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

::    Zmienne do obsługi przepisu planistycznego
::    jeśli wartoś <0 zmienna nie została ustawiona
::                 >0 zmienna ustawiona można pobrać
::    Po pobraniu i użyciu ustawić wartość na -1 = q_px.zeruj()
:: XJM - serja optymalna z technologii
:: ILOSC - ilosć kalkulowana
:: PROP - współczynnik proporcji ILOSC do XJM
:: CZAS_OP - czas wykonywania operacji z technologii
:: TPZ - ilość TPZ
:: CZAS_M - czas maszynowy z technologii
:: zeruj() - ustawienie wartości "zerowych"

q_px:=obj_new('XJM','ILOSC','PROP','CZAS_OP','TPZ','CZAS_M','zeruj');
q_px.zeruj:=$' q_px.XJM:=-1;
                     q_px.ILOSC:=-1;
                     q_px.PROP:=-1;
                     q_px.CZAS_OP:=-1;
                     q_px.TPZ:=1;
                     q_px.CZAS_M:=-1;
                     1';
q_px.zeruj();
1


\q_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_CPD]
:: OPIS: Formuła inicjuje zmienne wdrożeniowe dla potrzeb przeliczania planu strategicznego i przepisu planistycznego
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_press('q_px')>0 || &q_px ?};
{? var_press('q_parametry')>0 || &q_parametry ?};
{? var_press('czas_wg_serii')>0 || &czas_wg_serii ?};
{? var_press('obj_pieca')>0 || &obj_pieca ?};
{? var_press('czas_wg_pieca')>0 || &czas_wg_pieca ?};
{? var_press('q_lista_jm')>0 || &q_lista_jm ?};


:: Zmienna pobiera i przechowuje listę jednostek do zaokrąglenia do pełnych liczb mimo innych ustawień w kartotece
q_lista_jm:=exec('get_w','#params',999006,type_of(''));

:: Zmienne q_px
exec('q_px_init','qtpp');
:: Formuła czas_wg_serii
exec('czas_wg_serii','qtpp');
:: Formuły na objętość pieca
exec('obj_pieca','qtpp');
:: Parametry dla dzielenia przewodników
exec('q_parametry','qtpp');
1


\cap_kalend
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ustala pojemnosc zgodna z kalendarzem zasobu - zalozenie, ze pojemniki sa dzienne (przeniesione z px_gen)
::   WE: _a - PX_CUP.ref()
::   WY: pojemnosc w godzinach
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
PX_CUP.cntx_psh();
PX_CUP.clear();
{? PX_CUP.seek(_a)
||
   {? var_pres('KAL')<100
   || exec('declare','kalendarz');
      KAL:=obj_new(@.CLASS.KALEND)
   ?};
   _startd:=PX_CUP.STARTD().DATA;
   _starty:=DATY.ROK;
   _kstart:=PX_CUP.TM_START;
   _kend:=PX_CUP.TM_END;
   _kal_def:=KAL.get_day(_startd);
   {? _kal_def<>null()
   || KAL_DEF.cntx_psh();
      KAL_DEF.clear();
      {? KAL_DEF.seek(_kal_def)
      || _kstart:=KAL_DEF.TM_START;
         _kend:=KAL_DEF.TM_END
      ?};
      KAL_DEF.cntx_pop()
   ?};

   {? PX_KONT.PL_RES().FROM_GNI<>null() & exec('is_koop','px_kont')=0
   ||
::    Specjalna obsługa dla gniazd
      TWRKZBR.cntx_psh();
      TWRKZPO.cntx_psh();
      TWRKPLC.cntx_psh();
      PX_KONT.PL_RES().FROM_GNI();

      TWRKZPO.index('GRUPA');
      TWRKZPO.prefix(PX_KONT.PL_RES().FROM_GNI);
      {? TWRKZPO.first()
      || {!
         |?
            {? TWRKZPO.ELEMENT<>null()
            ||
               {? TWRKZPO.ELEMENT().KAL<>null()
               ||
                  {? KAL.set_cal(TWRKZPO.ELEMENT().KAL,_starty)>0
                  || _kstart:=PX_CUP.TM_START;
                     _kend:=PX_CUP.TM_END;
                     _kal_def:=KAL.get_day(_startd);
                     {? _kal_def<>null()
                     || KAL_DEF.cntx_psh();
                        KAL_DEF.clear();
                        {? KAL_DEF.seek(_kal_def)
                        || _kstart:=KAL_DEF.TM_START;
                           _kend:=KAL_DEF.TM_END
                        ?};
                        KAL_DEF.cntx_pop()
                     ?};
                     _work_hours:=KAL.w_hours(_startd,_startd);
                      {? _work_hours>0 & (_kstart<>PX_CUP.TM_START|_kend<>PX_CUP.TM_END)
                      || _start:={? _kstart>PX_CUP.TM_START || _kstart || PX_CUP.TM_START ?};
                         _end:={? _kend<PX_CUP.TM_END || _kend || PX_CUP.TM_END ?};
                         _work_hours:=(_end-_start)/exec('hour','#tm_stamp')
                       ?};
                     _res+=_work_hours
                  || KOMM.add('Brak kalendarza na rok: %1, pojemność nie została zainicjowana.'@[$_starty],2,,1)
                  ?}
               || _res+=((PX_CUP.TM_END-PX_CUP.TM_START)/exec('hour','#tm_stamp'))
               ?}
            ?};
            TWRKZPO.next()
         !}
      ?};
      TWRKPLC.cntx_pop();
      TWRKZPO.cntx_pop();
      TWRKZBR.cntx_pop();
      ~~

   || {? PX_CUP.PX_KONT().KAL<>null()
      || {? KAL.set_cal(PX_CUP.PX_KONT().KAL,_starty)>0
         || _res:=KAL.w_hours(_startd,_startd);
            {? _res>0 & (_kstart<>PX_CUP.TM_START|_kend<>PX_CUP.TM_END)
            || _start:={? _kstart>PX_CUP.TM_START || _kstart || PX_CUP.TM_START ?};
               _end:={? _kend<PX_CUP.TM_END || _kend || PX_CUP.TM_END ?};
               _res:=(_end-_start)/exec('hour','#tm_stamp')
            ?}
         || KOMM.add('Brak kalendarza na rok: %1, pojemność nie została zainicjowana.'@[$_starty],2,,1)
         ?}
      || _res:=24
      ?}
   ?}
?};

PX_CUP.cntx_pop();
PX_CUP.get();
_res


\czy_tex_ok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [21.14]
:: OPIS: Funkcja sprawdza kompletność karty
::   WE: TKTL.ref()
::   WY: 1 - wszystko ok, 0 - karta technologiczna niekompletna np. brak domyślnej karty na półprodukt
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
TKTL.cntx_psh();
TKTL.prefix();
TMAT.cntx_psh();
TMAT.index('NL');
{? TKTL.seek(_a)
|| TMAT.prefix();
   TMAT.prefix(_a);
   {? TMAT.first()
   || {!
      |? {? TMAT.DFLT_KTL='T' & TMAT.MAG='P'
         || _dtktl_s:=exec('dflt_ktl','tech_prod',TMAT.PT);
            {? _dtktl_s=null()
            || _result:=0
            || _result:=exec('czy_tex_ok','qtpp',_dtktl_s)
            ?}
         ?};
         _result & TMAT.next()
      !}
   ?}
|| _result:=0
?};
TKTL.cntx_pop();
TMAT.cntx_pop();
_result


\usun_px_poz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [21.14]
:: OPIS: Usówa dla wskazanego PX_STAGE powiązane rekordy podczas aktualizacji przepisu planistycznego.
::       PX_POZ, PX_POINT, PX_NAST
::   WE: PX_STAGE.ref
::   WY: 1 - wszystko ok, 0 - nie ok
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:=1;



:: Punkty czasowe
exec('usun_px_point','qtpp',_a);

:: Następniki pozycji
PX_NAST.cntx_psh();
PX_NAST.index('PX');
PX_NAST.prefix(_px_stage);
{? PX_NAST.first()
|| {!
   |? PX_NAST.del()
   !}
?};
PX_NAST.cntx_pop();

:: Pozycje planu strategicznego
PX_POZ.cntx_psh();
PX_POZ.index('PX_STAG2');
PX_POZ.prefix(_px_stage);
{? PX_POZ.first()
|| {!
   |? exec('delete','px_poz',PX_POZ.ref());
      PX_POZ.first()
   !}
?};
PX_POZ.cntx_pop();

_result


\akt_px
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [21.14]
:: OPIS: Funkcja uruchamia proces aktualizacji planu strategicznego po zmianie w karcie technologicznej PRJ lub PRD
::   WE: _a - TKTL.ref
::       _b - rodzaj powstałej zmiany 'TMAT', 'TOPER'
::       _c - ref SQL zmienianego rekordu (TMAT lub TOPER)
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------

VAR.A_KTL:=_a;
_rodzaj:=_b;
_rekord:=_c;

:: weryfikacja czy karta technologiczna jest kartą zlecenia  - jeśli tak, nic nie aktualizujemy
{? VAR.A_KTL().ZL<>null()
|| return(~~)
?};

:: Uruchomienie procesu aktualizującego plan strategiczny dla wybranej karty technologicznej
_par:=obj_new(3);
_par[1]:=obj_new('PARAMETR','VALUE');
_par[2]:=obj_new('PARAMETR','VALUE');
_par[3]:=obj_new('PARAMETR','VALUE');
_par[1].PARAMETR:='TKTL';
_par[1].VALUE:=VAR.A_KTL;
_par[2].PARAMETR:='RODZAJ';
_par[2].VALUE:=_rodzaj;
_par[3].PARAMETR:='REKORD';
_par[3].VALUE:=_rekord;
exec('force_signal','#b__box','NUCO_RPO_PRJ_ZM',,_par);
~~


\czy_pp_prj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Funkcja sprawdza czy podana w argumencie _a karta technologiczna jest użyta jako półprodukt,
::       lub czy jest użyta jako domyślna karta jeśli jest kartą domyślną (sprawdzamy najpierw czy jest domyślna
::       funkcja tylko dla typu kart projektowych PRJ)
::       UWAGA karta PRJ musi mieć produkt przypisany w nagłówku karty i tylko ten jest weryfikowany
::   WE: _a - TKTL.ref()
::   WY: 1 - karta jest użyta jako półfabrykat, 0 nie jest użyta jako półfabrykat
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
{? 8+$_a='txktl___'
||

   VAR_DEL.delete('__who_t');
   VAR.A_KTL:=_a;
   HELP.REFMAT:=VAR.A_KTL().KTM;


   _result:=exec('whohasme','tech_mater',6,1);
:: Czy są jakiekolwiek powiązania ?
   {? _result & __who_t.first()
   ||
:: sprawdzamy czy w liście powiązań karty projektowe
::            czy są karty z zaznaczonym znacznikiem domyślności
::            czy wskazane karty (nie domyślne) są tą którą badamy
      _tab_prj:=sql('select *
                       from :_a
                      where :_a.TYP=\'PRJ\' and :_a.TORW=\'T\' and :_a.KTL_STAN=\'T\' and :_a.KTL_ARCH=\'N\' and :_a.SU=\'Surowiec\'
                            and  (:_a.DFLT_KTL=\'T\' or (:_a.P_NRK=\':_b\' and :_a.P_WER=\':_c\'))',
                    __who_t, VAR.A_KTL().NRK, VAR.A_KTL().WER);
      {? _tab_prj.first()
      || _result:=1
      ?}
   ?};
   VAR_DEL.delete('__who_t')
?};
_result


\key_TKTL
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Formuła przygotowuje listę gryp_key TKTL powiązanych z parametrem do aktualizacjia przepisu planistycznego i PS
::   WE: [_a] - ref SQL-owy TKTL (tktl półproduktu i trzeba zaktualizować produkty)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_ar:='';

{? var_pres('_a')=type_of('')
|| _ar:=_a
?};

_mp:=params_get().mp;
_in:=params_get().in;

{? _in.ITEM<>''
|| _ar:=_in.ITEM
?};

_mp.grpkey();

{? 8+_ar='txktl___'
|| VAR_DEL.delete('__who_t');
   VAR.A_KTL:=exec('FindAndGet','#table',TKTL,_ar,,,null());
   HELP.REFMAT:=VAR.A_KTL().KTM;

   exec('whohasme','tech_mater',6,1);

   {? __who_t.first()
   || _tab_prj:=sql('select *
                       from :_a
                      where :_a.TORW=\'T\' and :_a.KTL_STAN=\'T\' and :_a.KTL_ARCH=\'N\' and :_a.SU=\'Surowiec\'
                            and  (:_a.DFLT_KTL=\'T\' or (:_a.P_NRK=\':_b\' and :_a.P_WER=\':_c\'))',
                    __who_t, VAR.A_KTL().NRK, VAR.A_KTL().WER);
      {? _tab_prj.first()
      || {!
         |? _ref:=exec('FindAndGet','#table',TMAT,_tab_prj.TMAT,,"$(@.TMAT.NRK)",'');
            {? _ref<>''
            || _mp.grpkeyAdd(_ref)
            ?};
            _tab_prj.next()
         !}
      ?}
   ?}
?};

_mp.done();
~~


\czy_tktl_ps
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Formułą sprawdza czy podany w parametrze TKTL znajduje się w planie strategicznym
::   WE: _a - TKTL.ref
::   WY: 1 - jest w planie, 0 - nie jest w planie
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
_result:=0;

_tab:=sql('select PX_TEX.REFERENCE as REF from PX_TEX where PX_TEX.TKTL=:_a',_a);
_tab2:=sql('select PX_GRP.SYMBOL, PX_GRP.NAZWA from PX_GRP where PX_GRP.PX_TEX in (select REF from :_a)',_tab);
{? _tab2.size()>0
|| _result:=1
?};

_result


\akt_pp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: funkcja aktualizuje/generuje przepis planistyczny dla podanego tktl (p01 - procesu)
::       funkcja może być używana jako serwisowa lub manualna (z komunikatami)
::   WE:
::   WY: 'OK' jeśli wszystko ok, 'BŁĄD' - jeśli jakiś problem
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_tktl:=null();
_can_continue:=1;

_in:=params_get().in;
_mp:=params_get().mp;

{? var_pres('p01',_in)<>type_of(~~)
|| _tktl:=_in.p01
?};

exec('tktl_cntx_psh','tech_common');

{? _tktl<>null()
|| exec('tktl_use','tech_common',ref_name(_tktl)+3);
   TKTL.clear();
   _can_continue:=TKTL.seek(_tktl);
   {? _can_continue>0
   || _what:=exec('record','#to_string',TKTL.ref());
::    Sprawdzam czy karta technologiczna nie jest w archiwum
      {? TKTL.ARCH='T'
      || _msg:='Karta technologiczna: %1 jest w archiwum, generowanie przepisu planistycznego niedostępne.'@@[_what];
         {? _mp.isService()=0
         || FUN.info(_msg)
         ?};
         _can_continue:=0;
         _mp.error(_msg)
      ?};
::    Sprawdzam czy karta technologiczna jest aktualna
      {? ~exec('tktl_act','tech_head',0)
      || _msg:='Karta technologiczna: %1 jest nieaktualna, generowanie przepisu planistycznego niedostępne.'@@[_what];
         {? _mp.isService()=0
         || FUN.info(_msg)
         ?};
         _can_continue:=0;
         _mp.error(_msg)
      ?};
::    Sprawdzam czy karta nie jest prototypowa
      {? _can_continue>0 & TKTL.KTM=null()
      || _msg:='Karta technologiczna: %1 jest prototypowa, generowanie przepisu planistycznego niedostępne.'@@[_what];
         {? _mp.isService()=0
         || FUN.info(_msg)
         ?};
         _can_continue:=0;
         _mp.error(_msg)
      ?};
::    Sprawdzam czy przypadkiem karta nie jest zleceniowa
      {? _can_continue>0 & TKTL.TORW='Z'
      || _msg:='Karta technologiczna: %1 to technologia zlecenia, generowanie przepisu planistycznego niedostępne.'@@[_what];
         {? _mp.isService()=0
         || FUN.info(_msg)
         ?};
         _can_continue:=0;
         _mp.error(_msg)
      ?};
::    Sprawdzam czy typ karty umożliwia tworzenie przepisów planistycznych
      {? _can_continue>0 & TKTL.TYP().CZAPLA<>'T'
      || _msg:='Typ karty technologicznej: %1 nie umożliwia tworzenia przepisów planistycznych.'@@[_what];
         {? _mp.isService()=0
         || FUN.info(_msg)
         ?};
         _can_continue:=0;
         _mp.save(exec('kind_out','#b_port'),'OUT','BŁĄD');
         _mp.done()
      ?}
::    Sprawdzam czy karta technologiczna jest projektowa - zablokowane
::      {? TKTL.TYP().TYP<>'PRJ'
::      || _msg:='Karta technologiczna: %1 nie jest kartą projektową, generowanie przepisu planistycznego niedostępne.'@@[_what];
::         {? _mp.isService()=0
::         || FUN.info(_msg)
::         ?};
::         _can_continue:=0;
::         _mp.error(_msg)
::      ?}
   ?};

   {? _can_continue>0
   || _generate:=1;

      _dialog:=1;
      {? _mp.isAutoRun() | _mp.isService()
      || _dialog:=0;
         {? KOMM.is_inited()=0 ||  KOMM.init(250,,'Generowanie przepisu planistycznego') ?}
      ?};
      {? _dialog>0
      ||
::       Wyświetlam pytanie
         {? _tktl<>null()
         || _generate:=FUN.ask('Generować przepis planistyczny dla karty: %1?'@[_what])
         ?}
      ?};

      {? _generate>0
      || _complex:=-1;
         _par:=exec('get','#params',500367);
         {? _par='T'
         || _complex:=1
         |? _par='N'
         || _complex:=0
         ?};

         _warn:=0;
         _result:=exec('tktl_tex_update','px_tex',_tktl,_warn,_dialog,_complex,,1);

::          Jeżeli się udało wygenerować i czynność wykonana akcją w oknie to pokazuję wygenerowany przepis (zablokowane)
         {? 0 & _result>0
         || exec('Select_A_KTL','px_tex','VIEW!')
         ?}
      ?}
   ?};

   {? _result>0
   || _mp.save(exec('kind_out','#b_port'),'OUT','OK')
   || _mp.save(exec('kind_out','#b_port'),'OUT','BŁĄD')
   ?};

::    Obsługa na done
   {? _mp.isService()
   || _mp.done()
   || {? _result>0
      || _mp.done()
      ?}
   ?}
|| _mp.save(exec('kind_out','#b_port'),'OUT','BŁĄD')
?};

exec('tktl_cntx_pop','tech_common');
_result


\key_PS
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Formuła zbiera pozycje planu strategicznego do odtworzenia
::   WE: [_a] - Ref SQL TKTL
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_ar:='';

{? var_pres('_a')=type_of('')
|| _ar:=_a
?};

_mp:=params_get().mp;
_in:=params_get().in;

{? _in.ITEM<>''
|| _ar:=_in.ITEM
?};

_mp.grpkey();

VAR_DEL.delete('__who_t');
VAR.A_KTL:=exec('FindAndGet','#table',TKTL,_ar,,,null());
_mainver:=exec('get_mainversion','px_ver');

PX_TEX.cntx_psh();
PX_TEX.index('TKTLMSYM');
PX_TEX.prefix(_ar);
{? PX_TEX.first()
|| {!
   |? PX_POZ.cntx_psh();
      PX_POZ.index('PX_STAG3');
      PX_GRP.cntx_psh();
      PX_GRP.index('PX_TEX2');
      PX_GRP.prefix(_mainver,PX_TEX.ref());
      {? PX_GRP.first()
      || {!
         |? PX_POZ.prefix(_mainver,PX_GRP.ref());
            {? ~PX_POZ.first()
            ||  _mp.grpkeyAdd($PX_GRP.ref())
            ?};
            PX_GRP.next()
         !}
      ?};
      PX_GRP.cntx_pop();
      PX_POZ.cntx_pop();
      PX_TEX.next()
   !}
?};
PX_TEX.cntx_pop();

_mp.done();
~~


\akt_ps
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Formuła aktualizuje pojedynczą pozycję plan na podstawie przekazanego parametru (dla potrzeb procesu NUCO_RPO_PRJ_ZM i NUCO_RPO_ZM_Q)
::   WE: wykorzystywana w serwisie parametry p01
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_in:=params_get().in;
_mp:=params_get().mp;

_result:=1;
_px_grp:='';
_ref_px_grp:=null();

{? var_pres('p01',_in)<>type_of(~~)
|| _px_grp:=_in.p01
?};

{? _px_grp<>''
|| _ref_px_grp:=exec('FindAndGet','#table',PX_GRP,_px_grp,,,null)
|| _msg:='Błędny parametr parametru - pozycja planu strategicznego';
         {? _mp.isService()=0
         || FUN.info(_msg)
         ?};
         _result:=0;
         _mp.error(_msg)
?};
{? _ref_px_grp<>null()
|| _args_fast:=exec('fast_replan_a','px_logix');
   _args_fast.PX_GRP:=_ref_px_grp;
   {? exec('grp_fast_replan','px_logix',_args_fast)
   || exec('akt_px_point','qtpp', _ref_px_grp)
   || _msg:='Nie udało się zaktualizować pozycji planu strategicznego';
         {? _mp.isService()=0
         || FUN.info(_msg)
         ?};
         _result:=0;
         _mp.error(_msg)
   ?}
|| _msg:='Nie odnaleziono - pozycja planu strategicznego';
         {? _mp.isService()=0
         || FUN.info(_msg)
         ?};
         _result:=0;
         _mp.error(_msg)
?};

{? _result>0
   || _mp.save(exec('kind_out','#b_port'),'OUT','OK')
   || _mp.save(exec('kind_out','#b_port'),'OUT','BŁĄD')
?};

::    Obsługa na done
{? _mp.isService()
|| _mp.done()
|| {? _result>0
   || _mp.done()
   ?}
?};

_result


\usun_px_point
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [21.14]
:: OPIS: Usunięcie (zapamiętanie) punktów czasowych dla procesu NUCO_RPO_PRJ_ZM i NUCO_RPO_ZM_Q
::   WE: _a - PX_STAGE.ref()
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_px_stage:=_a;
PX_STAGE.cntx_psh();
PX_GRP.cntx_psh();
PX_POINT.cntx_psh();
PX_POINT.index('PX_STAGE');
PX_POINT.prefix(_px_stage);
{? PX_POINT.first()
|| {!
   |? _toper:=PX_POINT.PX_STAGE().TOPER;
      _px_grp:=PX_POINT.PX_GRP;
:: zapamiętanie zpaisów do otworzenia po przeliczeniu planu
      {? _toper<>null() & _px_grp<>null()
      || exec('add','#bulk',PX_POINT,'AKT_PRJ',$_px_grp+$_toper+$PX_POINT.ref())
      ?};
      PX_POINT.next()
   !};
   PX_POINT.prefix();
:: wyczyszczenie przypisania do PX_STAGE - dla potrzeb aktualizacji PRJ
   BULK.clear();
   BULK.index('UNIQUE');
   BULK.prefix('PX_POINT','AKT_PRJ',$_px_grp+$_toper);
   {? BULK.first()
   || {!
      |? exec('FindAndGet','#table',PX_POINT,(BULK.WARTOSC+16),,"PX_STAGE:=null();put()",0);
         BULK.next()
      !}
   ?}
?};
PX_POINT.cntx_pop();
PX_STAGE.cntx_pop();
PX_GRP.cntx_pop();

~~


\akt_px_point
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [21.14]
:: OPIS: Przywraca PX_POINT po aktualizacji zapisów w planie strategicznym dla potrzeb procesu NUCO_RPO_PRJ_ZM NUCO_RPO_ZM_Q
::   WE: _a - PX_GRP.ref()
::   WY:  1 - wszystko OK, 0 - coś poszło nie tak
::----------------------------------------------------------------------------------------------------------------------

_result:=1;
_px_grp:=_a;
PX_STAGE.cntx_psh();
PX_POINT.cntx_psh();
PX_GRP.cntx_psh();
PX_GRP.clear();
:: Aktualizacja PX_POINT - przypięcie do PX_STAGE
{? PX_GRP.seek(_px_grp)
|| PX_STAGE.clear();
   PX_STAGE.index('TKTL_NR');
   PX_STAGE.prefix($PX_GRP.PX_TEX().TKTL);
   {? PX_STAGE.first()
   || BULK.clear();
      BULK.index('UNIQUE');
      {!
      |? _toper:=PX_STAGE.TOPER;
         BULK.prefix('PX_POINT','AKT_PRJ',$_px_grp+$_toper);
         {? BULK.first()
         || {!
            |? exec('FindAndGet','#table',PX_POINT,(BULK.WARTOSC+16),,"PX_STAGE:=@.PX_STAGE.ref();put()",0);
               BULK.del()
            !}
         ?};
         PX_STAGE.next()
      !};
::     Usunięcie zbędnych zapisów w BULK i px_point jeśli jakaś operacja została usunięta z przepisu planistycznego
      BULK.prefix('PX_POINT','AKT_PRJ',$_px_grp);
      {? BULK.first()
      || {!
         |? exec('FindAndGet','#table',PX_POINT,(BULK.WARTOSC+16),,"{?PX_STAGE=null()||del()||0?}",0);
            BULK.del()
         !}
      ?}
   ?}

|| _result:=0
?};

PX_POINT.cntx_pop();
PX_STAGE.cntx_pop();
PX_GRP.cntx_pop();

_result


\filter_zam_sp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Ustawienie filtra programowego dla PX_OBJ - aktywne obiekty dotyczace zamowien
::----------------------------------------------------------------------------------------------------------------------
PX_VAR.FILTER_O:='nieplan';
{? PX_VAR.PX_SET=null()
|| _head:='';
   PX_OBJ.f_set(
      'ENDD(DATA),SYMBOL','join @ZK_P using(PX_OBJ.ZK_P,ZK_P.REFERENCE)',
      'PX_OBJ.A=''T'' and PX_OBJ.ZK_P<>'''' and PX_OBJ.IL_PLAN<PX_OBJ.IL and ZK_P.RODZ=''Z'' and ZK_P.ILP>0 and ZK_P.A=''A'''
   );
   KOMM.init(250,,'Dodawanie obiektów do planu'@);
   PX_OBJ.f_each("
      {? ~exec('can_plan','px_obj',PX_OBJ.ref(),0)
      || PX_OBJ.f_del()
      ?}
   ")
|| _head:='[Zestaw: '+PX_VAR.PX_SET().SYMBOL+'] ';
   PX_OBJ.f_set(
      'ENDD(DATA),SYMBOL',,
      'PX_SET=:_a and PX_OBJ.A=''T'' and PX_OBJ.ZK_P<>''''',
      PX_VAR.PX_SET
   )
?};
{? ~PX_OBJ.f_seek(PX_VAR.FLTR_OBJ) || PX_OBJ.f_first() ?};
PX_VAR.OBJFILTR:=_head+'Aktywne obiekty dotyczące zamówień sprzedaży';
~~


\czy_pp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Funkcja sprawdza czy podana w argumencie _a karta technologiczna jest użyta jako półprodukt,
::       lub czy jest użyta jako domyślna karta jeśli jest kartą domyślną
::       UWAGA karta musi mieć produkt przypisany w nagłówku karty i tylko ten jest weryfikowany
::   WE: _a - TKTL.ref()
::   WY: 1 - karta jest użyta jako półfabrykat, 0 nie jest użyta jako półfabrykat
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
{? 8+$_a='txktl___'
||
   VAR_DEL.delete('__who_t');
   VAR.A_KTL:=_a;
   HELP.REFMAT:=VAR.A_KTL().KTM;

   _result:=exec('whohasme','tech_mater',6,1);
:: Czy są jakiekolwiek powiązania ?
   {? _result & __who_t.first()
   ||
:: sprawdzamy czy w liście powiązań karty projektowe
::            czy są karty z zaznaczonym znacznikiem domyślności
::            czy wskazane karty (nie domyślne) są tą którą badamy
      _tab_prj:=sql('select *
                       from :_a
                      where :_a.TORW=\'T\' and :_a.KTL_STAN=\'T\' and :_a.KTL_ARCH=\'N\' and :_a.SU=\'Surowiec\'
                            and  (:_a.DFLT_KTL=\'T\' or (:_a.P_NRK=\':_b\' and :_a.P_WER=\':_c\'))',
                    __who_t, VAR.A_KTL().NRK, VAR.A_KTL().WER);
      {? _tab_prj.first()
      || _result:=1
      ?}
   ?};
   VAR_DEL.delete('__who_t')
?};

_result


\wyb_ktm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Wyświetla okno bazy M z możliwościa wyboru indeksu (wykorzystana w procesie zmiany surowca w kartach),
::       UWAGA - jeśli nie zostanie wybrany indeks proces jest kasowany
::   WE: [_a] - Dodatkowy tytuł
::   WY: M.ref/null
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;

{? _<1 || _opis:='' || _opis:=_a ?};
_result:=null();



exec('slo_m_ok','material','T',1,'P','ICEUDPORN(S)','W');
exec('wpm_opis','material',,_opis);

_loop:=1;
{!
|? _loop
|! {? M.select(,1,10)
   || _result:=M.ref();
      _loop:=0;
      _mp.done()
   || {? FUN.ask('Nie wybrałeś indeksu, czy chcesz zrezygnować z dalszego działania procesu?')
      || _mp.cancel();
         _loop:=0
      ?}
   ?}
!};

_result


\key_M_TKTL
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Formuła przygotowuje listę gryp_key TKTL powiązanych z parametrami do aktualizacjia przepisu planistycznego i PS
::   WE: p01 - _z_m, p02 - _na_m
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_z_m:=null();
_na_m:=null();

_mp:=params_get().mp;
_in:=params_get().in;

_z_m:=_in.p01;
_na_m:=_in.p02;

_mp.grpkey();




VAR_DEL.delete('__who_t');

HELP.REFMAT:=_z_m;
exec('whohasme','tech_mater',6,1);
{? __who_t.first()
|| _tab_tktl:=sql('select *
                    from :_a
                   where :_a.TORW=\'T\' and :_a.KTL_STAN=\'T\' and :_a.KTL_ARCH=\'N\' and :_a.SU=\'Surowiec\'
                         and  :_a.TORW_SYM=\'Technologia\'',
                 __who_t);
   {? _tab_tktl.first()
   || {!
      |? _ref:=exec('FindAndGet','#table',TMAT,_tab_tktl.TMAT,,"$(@.TMAT.NRK)",'');
:: Sprawdzam czy zmiana surowca nie spowoduje zdublowania surowców na liście
         {? ~sql('select TMAT.REFERENCE as REF from @TMAT where TMAT.NRK=\':_a\' and TMAT.PT=:_b',_ref,_na_m).first()
         || {? _ref<>''
            || _mp.grpkeyAdd(_ref)
            ?}
         ?};
         _tab_tktl.next()
      !}
   ?}
?};
_mp.done();
~~


\akt_tmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: funkcja aktualizuje tabelę tmat (p01 - procesu) zmieniają indeks z p02 na p03
::       funkcja może być używana jako serwisowa lub manualna
::   WE: p01 - TKTL do podmiany, p02 - z M, p03 - na M
::   WY: 1 - ok, 0 - nie ok
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_tmat:='';
_z_m:=null();
_na_m:=null();

_in:=params_get().in;
_mp:=params_get().mp;
_tktl:=_in.p01;
_z_m:=_in.p02;
_na_m:=_in.p03;

TMAT.cntx_psh();
TMAT.use('txmat'+(ref_name(_tktl)+3));
TMAT.index('NL');
TMAT.prefix(_in.p01);
{? TMAT.first()
|| {!
   |? {? TMAT.PT=_z_m
      || TMAT.PT:=_na_m;
         _result:=TMAT.put()
      ?};
      _result & TMAT.next()
   !};
   {? _result=0
   || _mp.error('Nie udało zapisać zmiany materiału')
   ?}
|| _mp.error('Nie odnaleziono materiału do podmiany');
   _result:=0
?};
TMAT.cntx_pop();
_result


\czy_fantom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [21.14]
:: OPIS: Funkcja sprawdza karcie podanej parametrem i jej skłądowych występuje surowiec z grupy fantomy
::   WE: TKTL.ref()
::   WY: 1 - wszystko ok, 0 - karta technologiczna niekompletna np. brak domyślnej karty na półprodukt
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
TKTL.cntx_psh();
TKTL.prefix();
TMAT.cntx_psh();
TMAT.index('NL');
{? TKTL.seek(_a)
|| TMAT.prefix();
   TMAT.prefix(_a);
   {? TMAT.first()
   || {!
      |? {? TMAT.DFLT_KTL='T' & TMAT.MAG='P'
         || _dtktl_s:=exec('dflt_ktl','tech_prod',TMAT.PT);
            {? _dtktl_s=null()
            || FUN.error('Brak domyślnej karty technologicznel dla półproduktu: %1.\n(Surowce karty technologicznej: %2)'@[TMAT.PT().KTM, TMAT.NRK().NRK]
                        );
               _result:=0
            || _result:=exec('czy_tex_ok','qtpp',_dtktl_s)
            ?}
         ?};
         {? _result & (7+TMAT.PT().KTM)='F0-0001'
         || FUN.error('W liście surowców karty technologicznej: %1 znajdują się fantomy.'@[TMAT.NRK().NRK]
                     );
            _result:=0
         ?};
         _result & TMAT.next()
      !}
   ?}
|| FUN.error('Nie odnaleziono wskazanej katy technologicznej do weryfikacji');
   _result:=0
?};
{? _result=0
|| FUN.error('Weryfikacja kart zakończona niepowodzeniem, dalsze działanie procesu nie jest możliwe.')
?};

TKTL.cntx_pop();
TMAT.cntx_pop();
_result


\fantom_zk_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Dla przekazanego ZK_P.ref sprawdza czy domyślna karta technologiczna jest kompletna
::   WE: _a - ZK_P.ref
::   WY: 1 - wszystko ok, 0 - nie ok
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_zk_p:=_a;
_ktm:=exec('FindAndGet','#table',ZK_P,_zk_p,,"M",null());

{? _ktm<>null()
|| _dtktl:=exec('dflt_ktl','tech_prod',_ktm);
   {? _dtktl<>null()
   || _result:=exec('czy_fantom','qtpp',_dtktl)
   || FUN.error('Brak technologii domyślnej dla weryfikowanej pozycji zamówienia');
      _result:=0
   ?}
|| FUN.error('Błędnie podany parametr pozycji zamówienia, nie odnaleziono materiału do produkcji');
   _result:=0
?};

_result


\get_zktl4TMAT
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Na podstawie struktury zlecenia zlozonego odszukanie karty polfabrykatowej obowiazujacej dla danego TMAT
::       TP - zmiana dla potrzeb generowania przepisów łącznie z mikronizacją - tylko dla technologii nie dotyczącej
::            zleceń
::   WE: _a - TMAT.ref()
::   WY: TKTL.ref() - technologii odpowiedniej dla danego TMAT
::----------------------------------------------------------------------------------------------------------------------
{? (_<1) | (_a=~~) | (type_of(_a)<>type_of(null())) | (_a=null()) | (ref_name(_a)<>TMAT.name()) || return(null()) ?};

_odp:=null();

Cntx.psh(TKTL,TMAT,ZL,M); Cntx.clr(TKTL,ZL,M);
{? TMAT.seek(_a)
|| _mm:={? TMAT.GRKTM='G'
        || _czy_polp:={? TMAT.TGDFLT().PT().R<>'P' || 0 || 1 ?};
           TMAT.TGDFLT().PT
        || _czy_polp:={? TMAT.PT().R<>'P' || 0 || 1 ?};
           TMAT.PT
        ?};
::   Czy półprodukt i nie jest to technologia zlecenia
   {? _czy_polp & ~(TKTL.seek(TMAT.NRK) & TKTL.TORW='Z' & TKTL.ZL<>null())
   ||
::    Czy półprodukt nie ma technologii bądź technologii domyślnej - wtedy standardowa ścieżka
      {? TMAT.KTL=null() | TMAT.DFLT_KTL='T'
      || _odp:=exec('dflt_ktl','tech_prod',_mm,1)
      ?}
   ?}
?};
Cntx.pop(TKTL,TMAT,ZL,M);
_odp


\czy_zmiana_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO]
:: OPIS: Pytanie w procesie zmiany surowców + weryfikacja możliwości zmiany (porównanie jednostek miary)
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_in:=params_get().in;
_mp:=params_get().mp;

_result:=0;
_m_z:=null();
_m_do:=null();

{? var_pres('p01',_in)=type_of(null()) & _in.p01<>null()
|| _m_z:=_in.p01
|| FUN.emsg('Błędny indeks materiałowy - zmieniany')
?};
{? var_pres('p02',_in)=type_of(null()) & _in.p02<>null()
|| _m_do:=_in.p02
|| FUN.emsg('Błędny indeks materiałowy - docelowy')
?};

{? _m_z<>null() & _m_do<>null()
|| _jm_z:=exec('FindAndGet','#table',M,_m_z,,"M.J",null());
   _jm_do:=exec('FindAndGet','#table',M,_m_z,,"M.J",null());
   {? _jm_z<>null() & _jm_z=_jm_do
   ||

      {? exec('czy_blok_akt_sur','qtpp')
      || {? FUN.ask('UWAGA !!! Aktualnie wykonywany jest inny proces aktualizaji surowców,\n'+
                           'zmiana surowców może nastąpić dopiero po wykonaniu poprzedniego procesu.\n'+
                          'Czy chcesz umieścić w kolejce proces zmiany surowców ?')
         || _result:=2
         ?}
      || _result:=FUN.ask('Czy chcesz rozpocząć proces zamiany surowców we wszystkich kartach technologicznych ?')
      ?}
   || FUN.emsg('Błędne jednostki miary w aktualizowanych surowcach.\n'+
               'Aktualizacja nie jest możliwa')
   ?}
?};

_result


\ustal_tktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO]
:: OPIS: Funkcja wybiera jeden z parametrów przekazany w procesie i ustala jako parametr wyjściowy TKTL
::   WE:
::   WY: TKTL.ref
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_mp:=params_get().mp;

_result:=null();

{? var_pres('p01',_in)=type_of(null()) & _in.p01<>null()
|| _result:=_in.p01
|? var_pres('p02',_in)=type_of(null()) & _in.p02<>null()
|| _result:=_in.p02
|? var_pres('p03',_in)=type_of(null()) & _in.p03<>null()
|| _result:=_in.p03
|| _mp.error('Nie udało się ustalić TKTL do dalszego działania procesu')
?};

_result


\archiwum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO]
:: OPIS: Archiwizacja karty technologicznej wskazanej parametrem procesu p01 (ref() lub $ref())
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_mp:=params_get().mp;

_tktl:=null();
_result:=1;
_res:=null();

{? var_pres('p01',_in)=type_of(null()) & _in.p01<>null()
|| _tktl:=_in.p01
|?  var_pres('p01',_in)=type_of('') & _in.p01<>''
|| _tktl:=exec('FindAndGet','#table',TKTL,_in.p01,,,null())
?};

{? _tktl<>null()
|| exec('tktl_cntx_psh','tech_common');
   exec('tktl_use','tech_common',ref_name(_tktl)+3);
   {? var_pres('DocLib')<=0 || exec('declare','tech_doc') ?};
   {? TKTL.seek(_tktl, 8+($_tktl))
   ||  VAR.A_KTL:=_tktl;
       _uidref:=TKTL.uidref();
       {? exec('tktl_lock','tech_common',#_tktl,'N',0) &
          exec('tktl_lock','tech_common',#_tktl,'O',0) &
          exec('tktl_lock','tech_common',#_tktl,'S',0) &
          exec('tktl_lock','tech_common',#_tktl,'P',0)
       || _res:=exec('tktl_arch_act','tech_arch',TKTL.ref(),'ARCHIWUM',0);
          {? _res<>null()
          || exec('uidref_update','#b__box',_uidref,exec('FindAndGet','#table',TKTL,_res,,"uidref()",''))
          || _mp.error('Nie udało się zarchiwizować karty technologicznej');
            _result:=0
          ?}
       || _mp.error('Nie udało się zablokować karty technologicznej');
          _result:=0
       ?};
       exec('tktl_unlock','tech_common',#_tktl,'N');
       exec('tktl_unlock','tech_common',#_tktl,'O');
       exec('tktl_unlock','tech_common',#_tktl,'S');
       exec('tktl_unlock','tech_common',#_tktl,'P')
   || _mp.error('Nie odnaleziono karty technologicznej do archiwizacji');
      _result:=0
   ?};
   exec('tktl_cntx_pop','tech_common')
|| _mp.error('Błędny parametr wywołania czynności');
   _result:=0
?};

_result


\px_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [22.26 NUCO]
:: OPIS: Aktualizuje rekord w kolejce planu strategicznego (lub go usuwa) formuła przed przeliczeniem planu strategicznego
::   WE:
::   WY: 1 - wszystko ok - przeliczenie jest możliwe
::       0 - błąd - przeliczenie zatrzymane
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_przeplanuj:=0;
_usuniety:=0;

:: Usunięcie zleceń z przeterminowanym terminem realizacji z kolejki planu
PX_CONN.cntx_psh();
PX_GRP.cntx_psh();
ZL.cntx_psh();

PX_CONN.index('PX_GRP');
PX_CONN.clear();
PX_CONN.prefix(PX_GRP.ref());


:: Dla zleceń
{? PX_CONN.first() &  PX_CONN.PX_OBJ().KIND='ZL_PROD'
||
:: Aktualizacja terminów rozpoczęcia planowania dla zleceń
:: Weryfikacja dat początku i końca planowania zleceń w przygotowaniau
   {? PX_CONN.PX_OBJ().ZL<>null & PX_CONN.PX_OBJ().ZL().STAN='N'
   || _akt_px_obj:=0;
      _dni:=0;
::      Jeżeli ilość na zleceniu zmieniła się i nie zgadza się z ilościa w planie strategiczny - poprawiam na ilość ze zlecenia
      {? PX_CONN.PX_OBJ().ZL().IL<>PX_CONN.ILOSC
      || PX_CONN.ILOSC:=PX_CONN.PX_OBJ().ZL().IL;
         PX_CONN.put();
         PX_GRP.ILOSC:=PX_CONN.PX_OBJ().ZL().IL;
         PX_GRP.put()
      ?};
:: Debug()
::      {? PX_CONN.PX_OBJ().ZL().SYM='2023/P/08598/KMO'|| debug() ?};

      {? PX_CONN.PX_OBJ().ZL().DTR<=date()
      || exec('FindAndGet','#table',ZL,PX_CONN.PX_OBJ().ZL,,"ZL.DTR:=date()+1;ZL.PL_DIR:=1;ZL.put()");
         _akt_px_obj:=1
      ?};
      {? PX_CONN.PX_OBJ().ZL().PL_DIR<=0
      || exec('FindAndGet','#table',ZL,PX_CONN.PX_OBJ().ZL,,"ZL.PL_DIR:=1;ZL.PL_DIR:=1;ZL.put()");
         _akt_px_obj:=1
      ?};
      {? PX_CONN.PX_OBJ().ZL().PL_DATA<=date()
      || exec('FindAndGet','#table',ZL,PX_CONN.PX_OBJ().ZL,,"ZL.PL_DATA:=date()+1;ZL.PL_TIME:=time(23,0,0);ZL.PL_DIR:=1;ZL.put()");
         PX_OBJ.STARTD:=exec('get','daty',PX_CONN.PX_OBJ().ZL().DTR);
         PX_OBJ.STARTT:=time(23,0,0);
         PX_OBJ.DIR:=1;
         PX_OBJ.TM_START:=tm_stamp(PX_OBJ.STARTD().DATA~1,PX_OBJ.STARTD().DATA~2,PX_OBJ.STARTD().DATA~3,23,0,0,0);
         PX_OBJ.put();
         _akt_px_obj:=1
      ?};
      {? PX_CONN.PX_OBJ().ZL().DTR<PX_CONN.PX_OBJ().ZL().PL_DATA
      || exec('FindAndGet','#table',ZL,PX_CONN.PX_OBJ().ZL,,"ZL.PL_DATA:=ZL.DTR;ZL.PL_DIR:=1;ZL.put()");
         _akt_px_obj:=1
      ?};

      {? PX_CONN.PX_OBJ().ZL<>null & PX_CONN.PX_OBJ().ZL().STAN='N' & PX_CONN.PX_OBJ().ZL().PL_DATA>date() & PX_CONN.PX_OBJ().ZL().PL_DIR=1
      || _time:=sql('select sum(ZGP.MTIME) as SMT from ZGP where ZGP.ZL=:_a and ZGP.TPZ=\'N\'',PX_OBJ.ZL).SMT +
                sql('select sum(ZGP.NTIME) as STPZ from ZGP where ZGP.ZL=:_a and ZGP.TPZ=\'T\'',PX_OBJ.ZL).STPZ;
         {? _time>0
         || _dni:=(_time/24)+1
         ?}
      ?};
:: Weryfikacja czy data końcowa planowania i data początkowa planowania dla grupy nie jest poza zakresem planowanych dat na zleceniu
      {? PX_CONN.PX_GRP().ENDD().DATA>PX_OBJ.ZL().PL_DATA | PX_CONN.PX_GRP().ENDD().DATA<date() | PX_CONN.PX_GRP().STARTD().DATA>PX_OBJ.ZL().PL_DATA
      || PX_GRP.ENDD:=exec('get','daty',PX_OBJ.ZL().PL_DATA);
         PX_GRP.ENDT:=time(22,0,0);
         PX_GRP.TM_END:=tm_stamp(PX_GRP.ENDD().DATA~1,PX_GRP.ENDD().DATA~2,PX_GRP.ENDD().DATA~3,22,0,0,0);
         PX_GRP.STARTD:=exec('get','daty',PX_OBJ.ZL().PL_DATA);
         PX_GRP.STARTT:=time(6,0,0);
         PX_GRP.TM_START:=tm_stamp(PX_GRP.STARTD().DATA~1,PX_GRP.STARTD().DATA~2,PX_GRP.STARTD().DATA~3,6,0,0,0);
         PX_GRP.put();
         _akt_px_obj:=1
      ?};

      _startd:=PX_CONN.PX_GRP().ENDD().DATA-_dni;
      _startd:=exec('dzienRob','kalendarz',_startd,1,1,1,-1);
      {? _startd<date() || _startd:=date() ?};
      {? PX_CONN.PX_GRP().STARTD().DATA<>_startd
      || PX_GRP.STARTD:=exec('get','daty',_startd);
         PX_GRP.STARTT:=time(6,0,0);
         PX_GRP.TM_START:=tm_stamp(_startd~1,_startd~2,_startd~3,6,0,0,0);
         PX_GRP.put();
         _akt_px_obj:=1
      ?};

:: Aktualizacja PX_OBJ
      {? _akt_px_obj | PX_OBJ.STARTD().DATA<=date()
      || PX_OBJ.STARTD:=PX_CONN.PX_GRP().STARTD;
         PX_OBJ.STARTT:=PX_CONN.PX_GRP().STARTT;
         PX_OBJ.TM_START:=PX_CONN.PX_GRP().TM_START;
         PX_OBJ.ENDD:=PX_CONN.PX_GRP().ENDD;
         PX_OBJ.ENDT:=PX_CONN.PX_GRP().ENDT;
         PX_OBJ.TM_REA:=PX_CONN.PX_GRP().TM_END;
         PX_OBJ.put()
      ?}
   |? PX_CONN.PX_OBJ().ZL<>null
:: Jeśli zlecenie jest  innym statusie niż w przygotowaniu - usuwam go z planu strategicznego
   || exec('del_direct','px_grp',PX_GRP.ref());
      _usuniety:=1
   ?}
?};

:: Jeżeli przepis zlecenia z jakiegokolwiek powodu jest wadliwy
{? ~_usuniety & PX_CONN.first() &  PX_CONN.PX_OBJ().KIND='ZL_PROD' & exec('verify','px_tex',PX_CONN.PX_GRP().PX_TEX,PX_CONN.ILOSC)<>''
|| exec('del_direct','px_grp',PX_GRP.ref());
      _usuniety:=1
?};

:: Jeśli przepis technologiczny z jakichkolwiek powodów jest niekompletny lub brak
{? ~_usuniety & 1+PX_GRP.SYMBOL='<'
|| exec('del_direct','px_grp',PX_GRP.ref());
      _usuniety:=1
?};



:: Dla pozycji zamówień - ustalenie nowej daty (jeśli jest w przeszłości lub krótsza niż dwa tygodnie),
:: obszar planowania operacyjnego - planujemy wszystko do przodu) realizacji - tylko obiekt planowny
:: zamówienie zostaje bez zmian. Dodatkowo zmiana kierunku planowania na "do przodu". Naniesienie zmian również
:: na kolejkę planu.
{? ~_usuniety & PX_CONN.first() & PX_CONN.PX_OBJ().KIND='ZAM_POZ'
|| {? PX_OBJ.ENDD().DATA<(PX_CONN.PX_GRP().STARTD().DATA+1) & PX_CONN.PX_OBJ().A='T'
   || PX_GRP.STARTD:=exec('get','daty',PX_GRP.STARTD().DATA+2);
      PX_GRP.ENDD:=exec('get','daty',PX_GRP.STARTD().DATA+32);
      PX_GRP.put();
      PX_OBJ.STARTD:=PX_CONN.PX_GRP().STARTD;
      PX_OBJ.ENDD:=PX_CONN.PX_GRP().ENDD;
      PX_GRP.ENDT:=PX_OBJ.ENDT:=PX_OBJ.STARTT:=PX_CONN.PX_GRP().STARTT;
      PX_OBJ.TM_START:=PX_CONN.PX_GRP().TM_START;
      PX_GRP.TM_END:=tm_stamp(PX_GRP.ENDD().DATA~1,
                     DATY.DATA~2,
                     DATY.DATA~3,
                     PX_GRP.ENDT~1,
                     PX_GRP.ENDT~2,
                     PX_GRP.ENDT~3,
                     0);
      PX_OBJ.TM_REA:=PX_OBJ.TM_PLEND:=PX_GRP.TM_END;
      PX_GRP.DIR:=PX_OBJ.DIR:=1;
      PX_GRP.PL_FORCE:=PX_OBJ.PL_FORCE:='T';
      PX_OBJ.put();
      PX_GRP.put();
      _przeplanuj:=1
   ?};

:: Jeśli zlecenie w archiwum i/lub usunięte albo odakceptowane, a obiekt nadal w kolejce
   {? (PX_CONN.PX_OBJ().ZK_P<>null() & PX_CONN.PX_OBJ().A<>'T') | PX_CONN.PX_OBJ().IL=0
   || exec('del_direct','px_grp',PX_GRP.ref());
      _usniety:=1
:: Jeśli z jakiegoś powodu w planie jest więcejniż w obiekcie do zaplanowania
   |? PX_CONN.PX_OBJ().IL<PX_CONN.ILOSC
   || PX_CONN.ILOSC:=PX_CONN.PX_OBJ().IL;
      PX_CONN.put();
      PX_GRP.ILOSC:=PX_CONN.PX_OBJ().IL;
      PX_GRP.put();
      _przeplanuj:=1
   ?};

:: Jeśli przepis planownaia został zdezaktywowany, a nadal jest w kolejce planu - ustawiamy najnowszy domyślny przepis
   {? ~_usuniety & PX_GRP.ref()<>null() & PX_GRP.PX_TEX<>null() & PX_GRP.PX_TEX().AKT<>'T'
   || PX_GRP.PX_TEX:=exec('get_default_tex','px_tex',PX_CONN.PX_OBJ);
      PX_GRP.put();
      _przeplanuj:=1
   ?};

:: Szybkie przeplanowanie obiektu - zablokowane !!!
   {? 0 & ~_usuniety & _przeplanuj
   || _argsfast:=exec('fast_replan_a','px_logix');
      _argsfast.PX_GRP:=PX_CONN.PX_GRP;
      exec('grp_fast_replan','px_logix',_argsfast)
   ?}
?};
ZL.cntx_pop();
PX_GRP.cntx_pop();
PX_CONN.cntx_pop();

_result


\usun_px_opoznione
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [21.14]
:: OPIS:Usunięcie pozycji planu strategicznego ze znacznikiem opózniony
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
PX_POZ.cntx_psh();
PX_POZ.f_clear();
PX_POZ.index('VSTATUS');
PX_POZ.prefix();

{? PX_POZ.first()
|| {!
   |? _dalej:=0;
      {? PX_POZ.STATUS='OPÓŹNIONE'
     || _dalej:=exec('delete','px_poz',PX_POZ.ref,0,0)
      ?};
      _dalej>0 | PX_POZ.next()
   !}
?};
PX_POZ.cntx_pop();
1


\ust_tr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [22.26 NUCO]
:: OPIS: Ustala pierwotny termin realizacji dla pozycji kolejki planu strategicznego
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
PX_CONN.cntx_psh();
PX_OBJ.cntx_psh();
PX_GRP.cntx_psh();
PX_CONN.index('PX_GRP');
PX_CONN.clear();
PX_CONN.prefix(PX_GRP.ref());
:: Dla zleceń
{? PX_CONN.first()
|| {? PX_CONN.PX_OBJ().KIND='ZL_PROD'
   || PX_VAR.ENDD:=PX_CONN.PX_OBJ().ZL().PL_DATA
   |? PX_CONN.PX_OBJ().KIND='ZAM_POZ'
   ||  _zk_p:=ref_name(PX_CONN.PX_OBJ().ZK_P);
       {? _zk_p<>ZK_P.name()
       || ZK_P.cntx_psh();
          ZK_P.use(_zk_p);
          PX_VAR.ENDD:=PX_CONN.PX_OBJ().ZK_P().DT;
          ZK_P.cntx_pop()
       || PX_VAR.ENDD:=PX_CONN.PX_OBJ().ZK_P().DT
       ?}
   || PX_VAR.ENDD:=PX_CONN.PX_OBJ().ENDD().DATA
   ?}
|| PX_VAR.ENDD:=PX_GRP.ENDD().DATA
?};
PX_CONN.cntx_pop();
PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();

:: Kolor przy przekroczeniu pierwotnego terminu
{? PX_VAR.ENDD<date()
|| '188:26:34,'
|| ''
?}


\que_organize
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: wstepna organizacja planu
::   WE: _a - wskazanie na wersje planu
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_ok:=1;

:: Sprawdzam czy mozna zablokowac cala kolejke
{? exec('lock_queue','px_ver',_px_ver)>0
||
   _organize:=tab_tmp(2,'REF','INTEGER','REF',
                        'PXTEX','STRING[50]','Przepis planistyczny'@,
                        'TM','REAL','TM',
                        'JM','STRING[10]','jm'@,
                        'DIR','INTEGER','Zwrot'@);
   PX_GRP.cntx_psh();
   PX_CONN.cntx_psh();
   ZL.cntx_psh();
   PX_GRP.index('LP');
   PX_GRP.prefix(_px_ver);
   {? PX_GRP.first()
   || {!
      |? _organize.REF:=#PX_GRP.ref();
         _organize.PXTEX:=PX_GRP.PX_TEX().SYMBOL;
         _organize.TM:={? PX_CONN.index('PX_GRP');
                          PX_CONN.prefix(PX_GRP.ref());
                          PX_CONN.first()
                       || {? PX_CONN.PX_OBJ().ZK_P<>null()
                          || _termin:=exec('FindAndGet','#table',ZK_P,PX_CONN.PX_OBJ().ZK_P,,
                             "DT",date(0,0,0));
                             {? _termin<>date(0,0,0)
                             || tm_stamp(_termin~1,
                                         _termin~2,
                                         _termin~3,
                                         time()~1,
                                         time()~2,
                                         time()~3,
                                         0)
                             || PX_CONN.PX_OBJ().TM_REA
                             ?}
                          |? PX_CONN.PX_OBJ().ZL<>null()
                          || {? PX_CONN.PX_OBJ().ZL().ENDD<>date(0,0,0)
                             || _termin:=ZL.ENDD();
                                tm_stamp(_termin~1,
                                         _termin~2,
                                         _termin~3,
                                         ZL.ENDT~1,
                                         ZL.ENDT~2,
                                         ZL.ENDT~3,
                                         0)
                             || PX_CONN.PX_OBJ().TM_REA
                            ?}
                          || PX_CONN.PX_OBJ().TM_REA
                          ?}
                       || 0
                       ?};
         _organize.JM:={? PX_CONN.index('PX_GRP');
                          PX_CONN.prefix(PX_GRP.ref());
                          PX_CONN.first()
                       || PX_CONN.PX_OBJ().JM().KOD
                       || '<BRAK>'
                       ?};
         _organize.DIR:=PX_GRP.DIR;
         _organize.add();
         PX_GRP.next()
      !}
   ?};
   PX_CONN.cntx_pop();
   PX_GRP.cntx_pop();
   ZL.cntx_pop();
   _ndx:=_organize.ndx_tmp(,1,'TM',,);
   PX_GRP.clear();
   _organize.index(_ndx);
   {? _organize.first()
   || _lpq:=0;
      {!
      |? _lpq+=1;
         {? PX_GRP.seek(_organize.REF,)
         || PX_GRP.LP_Q:=_lpq;
            PX_GRP.put()
         ?};
         _organize.next()
      !}
   ?};
   _organize.ndx_drop(_ndx);

:: Stempluje kolejke jako zmodyfikowana
   exec('mod_stamp_queue','px_ver',_px_ver);

:: Odblokowuje cala kolejke
   exec('unlock_queue','px_ver',_px_ver)
?};
1


\usun_zk_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Usunięcie ZK_P z planu strategicznego - funkcja dla potrzeb usunięcia pozycji zamówienia.
::   WE: ZK_P.ref()
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_zk_p:=_a;
_px_obj:=null();
_result:=1;

ZLZAM.cntx_psh();
_px_obj:=exec('get_zkp_object','px_obj',_zk_p);
{? _px_obj<>null()
|| ZLZAM.index('ZMZL');
   ZLZAM.prefix($_zk_p);
   {? ZLZAM.first()
   || FUN.info('Do pozycji są już wystawione zlecenia.'@+'\n\n'+
               'Usunięcie pozycji z planu strategicznego nie jest możliwe.'@);
      _result:=0
   || {? exec('czy_rola','qprocesy','Usunięcie pozycji zamówienia z Pl.Str.')
      || {? FUN.ask('Pozycja zamówienia umieszczona jest w planie strategicznym.'@+'\n\n'+
                    'Czy jesteś pewien, że chcesz ją z niego usunąć?'@)
         || exec('delete','px_obj',_px_obj);
            FUN.info('Pozucje usunięto z planu strategicznego.'@+'\n\n'+
                  'Usunięcie pozycji zamówienia zostało odblokowane.'@)
         || _result:=0
         ?}
      || FUN.info('Brak uprawnień do usunięcia pozycji z planu strategicznego.'@);
         _result:=0
      ?}
   ?}
|| FUN.info('Pozycja zamówienia nie znajduje się w planie strategicznym.'@);
   _result:=0
?};
ZLZAM.cntx_pop();

_result


\czy_plan_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Formuła zwraca informacje czy można nadal planować strategicznie zleceni - zdarzenie oczekujące
::   WE: _a - ZL.ref - zlecenie do weryfikacji
::   WY: 1 - planować, 0 nie planować (bądź nie odnaleziono ma zlecenia
::----------------------------------------------------------------------------------------------------------------------
_zl:=null();
_result:=0;
_ver:=exec('get_mainversion','px_ver');

{? var_pres('_a')=type_of(null())
|| _zl:=_a
?};

{? _zl<>null()
|| _result:=exec('FindAndGet','#table',ZL,_zl,,"@.ZL.PLAN_PO<>'T' & @.ZL.PLAN_PX<>'T' & @.ZL.STAN<>'Z'",0);
   {? ~_result & exec('zl_planned','px_obj',_zl,_ver)<>exec('FindAndGet','#table',ZL,_zl,,"@.ZL.IL",0)
   || _result:=1
   ?}
?};

_result

\key_TKTL_2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST] v02
:: OPIS: Formuła przygotowuje listę gryp_key TKTL powiązanych z parametrem do aktualizacjia przepisu planistycznego i PS
::   WE: [_a] - ref SQL-owy TKTL (tktl półproduktu i trzeba zaktualizować produkty)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_ar:='';

{? var_pres('_a')=type_of('')
|| _ar:=_a
?};

_mp:=params_get().mp;
_in:=params_get().in;

{? _in.ITEM<>''
|| _ar:=_in.ITEM
?};

_mp.grpkey();

{? 8+_ar='txktl___'
|| _ktm:=exec('FindAndGet','#table',TKTL,_ar,,"@.TKTL.KTM",null());
   {? _ktm<>null()
   || _tab:=sql('select TKTL.REFERENCE as REF_TKTL, TKTL.NRK
                   from @TMAT join @TKTL using(TMAT.NRK,TKTL.REFERENCE)
                  where TKTL.ARCH=\'N\' and TKTL.ZL is null and TMAT.PT=:_a
                ',_ktm);
      {? _tab.first()
      || {!
         |? {? _tab.REF_TKTL<>''
            || _mp.grpkeyAdd(_tab.REF_TKTL)
            ?};
            _tab.next()
         !}
      ?}
   ?}
?};

_mp.done();
~~


\all_tktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Zbiera wszystkie technologie, które majaą w skłądze dany surowiec (rekurencyjnie)
::   WE: TKTL.ref() | $TKTL.ref()
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_ar:=_a;

_res_tab:=sql('select TKTL.REFERENCE as REF, TKTL.NRK from TKTL where 1=0');

_ktm:=exec('FindAndGet','#table',TKTL,_ar,,"@.TKTL.KTM",null());
{? _ktm<>null()
|| _tab:=sql('select TKTL.REFERENCE as REF_TKTL, TKTL.NRK, TKTL.KTM as KTM_S
                from @TMAT join @TKTL using(TMAT.NRK,TKTL.REFERENCE)
                           join TPKTL using(TKTL.TYP,TPKTL.REFERENCE)
               where TKTL.TORW=\'T\' and TKTL.ARCH=\'N\' and TKTL.ZL is null and TMAT.PT=:_a
                     and TPKTL.CZAPLA=\'T\'
             ',_ktm);
   {? _tab.first()
   || {!
      |? _tabs:=exec('all_tktl','qtpp',_tab.REF_TKTL);
         {? _tabs.first()
         || {!
            |? _res_tab.REF:=_tabs.REF;
               _res_tab.NRK:=_tabs.NRK;
               _res_tab.add();
               _tabs.next()
            !}
         ?};
         _res_tab.REF:=_tab.REF_TKTL;
         _res_tab.NRK:=_tab.NRK;
         _res_tab.add();
         &_tabs;
         _tab.next()
      !}
   ?}
?};

{? _res_tab.first()
|| sql('select DISTINCT :_a.REF, :_a.NRK from :_a', _res_tab)
|| _res_tab
?}


\key_TKTL_3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST] v02
:: OPIS: Formuła przygotowuje listę gryp_key TKTL powiązanych z parametrem do aktualizacjia przepisu planistycznego i PS
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_mp:=params_get().mp;
_in:=params_get().in;

{? var_pres('ITEM',_in)=type_of('') & _in.ITEM<>''
|| _tktl:=_in.ITEM
|| _tktl:=''
?};

_mp.ggrpkey(_in.GGRPKEY);

{? 8+_tktl='txktl___'
|| _tab:=exec('all_tktl','qtpp',_tktl);
   {? _tab.first()
   || {!
      |? {? _tab.REF<>''
         || _mp.ggrpkeyAdd(_tab.REF)
         ?};
         _tab.next()
      !}
   ?}
?};

_mp.done();
~~


\czy_add_komm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [22.26 NUCO]
:: OPIS: Weryfikacja czy dodawać komunikat do planu strategicznego
::   WE: _args - argumenty dodania komunikatu
::   WY: 1 - istnieje zapis dla przekazanego obiektu 0 - nie istnieje
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('PX_OBJ',_a)=type_of(null())
|| {? sql('select PX_KOMM.PX_OBJ from PX_KOMM where PX_KOMM.PX_GRP=:_a',_a.PX_GRP).first()
   || 1
   || 0
   ?}
|| 0
?}


\has_instances
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Sprawdza, czy dany proces ma czynne instancje inne niż aktualnie wykonywana
::   WE: _a - B_PROC.ref()
::       _b - BI_PROC.ref - instancja którą należy pominąć w weryfikacji
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_b_proc:=_a;
_bi_proc:=_b;

_result:=0;

_o_ile:=72;

_tm:=exec('create','#tm_stamp')-(_o_ile*exec('hour','#tm_stamp'));

BI_PROC.cntx_psh(); {? BI_PROC.name()='' || BI_PROC.use('bi_p____') ?};
BI_PROC.index('PROSTAN');
BI_PROC.prefix(_b_proc,__Status.URUCHOMIONY);
{? BI_PROC.first()
|| {!
   |? _result:=(_bi_proc<>BI_PROC.ref() & exec('create','#tm_stamp',BI_PROC.BORN_D,BI_PROC.BORN_T)>_tm) ;
      ~_result & BI_PROC.next()
   !}
?};
BI_PROC.cntx_pop();

_result


\has_inst_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Sprawdzenie, czy dany proces ma czynne instancje - formuła dla zdarzenia pośredniego
::       z wyłączeniem oczekiwania w kolejce - czyli tego zdarzenia pośredniego
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_mp:=params_get().mp;

_b_proc:=_mp.b_proc;
_bi_proc:=_mp.bi_proc;
_b_prel:=_mp.b_prel;

_result:=0;

_o_ile:=72;

_tm:=exec('create','#tm_stamp')-(_o_ile*exec('hour','#tm_stamp'));

_tab:=sql('select BI_PREL.UID,
                  BI_PROC.BORN_D,
                  BI_PROC.BORN_T
             from BI_PREL join BI_PROC
            where BI_PREL.BI_PROC<>:_a and BI_PREL.B_PREL<>:_b and BI_PROC.B_PROC=:_c and BI_PROC.BI_STAT=:_d
          ',_bi_proc,_b_prel,_b_proc,__Status.URUCHOMIONY);
{? _tab.first()
|| {!
   |? _result:=exec('create','#tm_stamp',_tab.BORN_D,_tab.BORN_T)>_tm;
      ~_result & _tab.next()
   !}
?};

_result


\add_blok_akt_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Dodaje blokadę uruchamiania procesu aktualizacji surowców
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_tab:='AKT_SUR';
_msk:='BLOKADA';
_ref:=1;
_ses_id:=SYSLOG.ses_id();

BLK.index('AMR');
BLK.prefix(_tab,_msk,_ref);

{? BPMN.BLK_USER=''
|| BPMN.BLK_USER:=SYSLOG.ses_info(_ses_id,'log_name')
?};
{? BPMN.BLK_TERM=''
|| BPMN.BLK_TERM:=SYSLOG.ses_info(_ses_id,'log_tty')
?};

{? ~BLK.first()
|| BLK.ACR:=_tab;
   BLK.MSK:=_msk;
   BLK.REF:=_ref;
   BLK.TM_STAMP:=SYSLOG.tm_stamp();
   BLK.MESSAGE:='przez użytkownika \'%1\' na terminalu: \'%2\' od: %3'@@[BPMN.BLK_USER,BPMN.BLK_TERM,19+tm_form(BLK.TM_STAMP)];
   BLK.SES_ID:=_ses_id;
   BLK.add(1)
?};
~~


\del_blok_akt_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Usuwa blokadę uruchamiana procesu aktualizacji surowców
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
BLK.cntx_psh();
BLK.index('AMR');
BLK.prefix('AKT_SUR','BLOKADA',1);
{? BLK.first()
|| BLK.del()
?};
BLK.cntx_pop();
~~


\czy_blok_akt_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Sprawdza czy aktualnie jest nałożona blokada uruchamiania procesu aktualizacji surowców
::   WE:
::   WY: 1 - jest blokada, 0 - brak blokady
::----------------------------------------------------------------------------------------------------------------------
sql('select BLK.REF from BLK where BLK.ACR=\'AKT_SUR\' and BLK.MSK=\'BLOKADA\' and BLK.REF=1').first()


\akt_px_pro
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [21.14]
:: OPIS: Funkcja uruchamia proces aktualizacji planu strategicznego po zmianie w karcie technologicznej PRO
::   WE: _a - TKTL.ref
::       _b - rodzaj powstałej zmiany 'TMAT', 'TOPER'
::       _c - ref SQL zmienianego rekordu (TMAT lub TOPER)
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------

VAR.A_KTL:=_a;
_rodzaj:=_b;
_rekord:=_c;

:: weryfikacja czy karta technologiczna jest typu PRJ - jeśli nie nic nie aktualizujemy
{? VAR.A_KTL().TYP().TYP<>'PRD' | VAR.A_KTL().ZL<>null() | exec('is_default_tech','tech_common',VAR.A_KTL,VAR.A_KTL().KTM)<>1
|| return(~~)
?};

:: Uruchomienie procesu aktualizującego plan strategiczny dla wybranej karty technologicznej
_par:=obj_new(3);
_par[1]:=obj_new('PARAMETR','VALUE');
_par[2]:=obj_new('PARAMETR','VALUE');
_par[3]:=obj_new('PARAMETR','VALUE');
_par[1].PARAMETR:='TKTL';
_par[1].VALUE:=VAR.A_KTL;
_par[2].PARAMETR:='RODZAJ';
_par[2].VALUE:=_rodzaj;
_par[3].PARAMETR:='REKORD';
_par[3].VALUE:=_rekord;
exec('force_signal','#b__box','NUCO_RPO_PRO_ZM',,_par);
~~


\key_TMAT
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: tworzy klucz do aktualizacji kart w których nastąpi zmiana uzysku
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_mp:=params_get().mp;
_in:=params_get().in;

_mp.grpkey();

_tab:=sql('select TMAT.REFERENCE as REF from @TMAT
             join @TKTL using(TMAT.NRK,TKTL.REFERENCE)
            where TMAT.ACT=\'T\' and TKTL.ARCH=\'N\' and TKTL.STAN=\'T\'
                  and TMAT.UNB>0 and TMAT.UNB<1
         ');
{? _tab.first()
|| {!
   |? _mp.grpkeyAdd(_tab.REF);
      _tab.next()
   !}
?};

_mp.done();
~~


\key_TMAT_TKTL
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST] v02
:: OPIS: Formuła przygotowuje listę gryp_key TKTL powiązanych z parametrem do aktualizacjia przepisu planistycznego i PS
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_mp:=params_get().mp;
_in:=params_get().in;

_mp.grpkey();


_tab:=sql('select distinct TMAT.NRK as REF from @TMAT
             join @TKTL using(TMAT.NRK,TKTL.REFERENCE)
            where TMAT.ACT=\'T\'
                  and TKTL.ARCH=\'N\' and TKTL.STAN=\'T\' and TKTL.IMPROVE=\'N\' and TKTL.ZL is null
                  and TMAT.UNB>0 and TMAT.UNB<1
         ');
{? _tab.first()
|| {!
   |? {? _tab.REF<>''
      || _mp.grpkeyAdd(_tab.REF)
      ?};
      _tab.next()
   !};
   _tab.first();
   {!
   |? _tab_all:=exec('all_tktl','qtpp',_tab.REF);
      {? _tab_all.first()
      || {!
         |? {? _tab_all.REF<>''
            || _mp.grpkeyAdd(_tab_all.REF)
            ?};
            _tab_all.next()
         !}
      ?};
      &_tab_all;
      _tab.next()
   !}
?};

_mp.done();
~~


\przelicz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Przeliczenie pozycji planu strategiczne
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_grp:=PX_GRPS.PX_GRP;
{? _grp=null()
|| FUN.info('Pozcyja zamówienia nie jest umieszczona w kolejce.\nPrzeliczenie nie będzie możliwe.')
|| _args:=exec('fast_replan_a','px_logix');
   _args.PX_GRP:=_grp;
   _can_replan:=exec('queue_update_core','px_logix',PX_GRP.ref());
   {? _can_replan
   || exec('grp_fast_replan','px_logix',_args)
   ?}
?}


\ustal_startd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [23.25 NUCO]
:: OPIS: Na podstawie przekazanego obiektu planistycznego prubuje określić datę rozpoczęcia planowania produkcji
::       Analiza tylko dla zleceń. Jeśli daty nie da się określić zwracana jest data dzisiejsza
::   WE: _a - PX_OBJ.ref
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_px_obj:=_a;
_dni:=0;
_akt_px_obj:=0;

ZL.cntx_psh();
PX_OBJ.cntx_psh();

_startd:=date();

{? _px_obj<>null() & PX_VAR.GRN_DATA=date()
|| PX_OBJ.clear();
   ZL.clear();
   {? PX_OBJ.seek(_px_obj) & PX_OBJ.KIND='ZL_PROD' & PX_OBJ.ZL<>null() & PX_OBJ.ZL().PL_DIR=1
   || _time:=sql('select sum(ZGP.MTIME) as SMT from ZGP where ZGP.ZL=:_a and ZGP.TPZ=\'N\'',PX_OBJ.ZL).SMT +
               sql('select sum(ZGP.NTIME) as STPZ from ZGP where ZGP.ZL=:_a and ZGP.TPZ=\'T\'',PX_OBJ.ZL).STPZ;
      {? _time>0
      || _dni:=(_time/24)+1
      ?};
      {?  PX_OBJ.ZL().PL_DATA>date() & _dni>0
      || _startd:=PX_OBJ.ZL().PL_DATA-_dni;
         _startd:=exec('dzienRob','kalendarz',_startd,1,1,1,-1);
         {? _startd<date() || _startd:=date() ?};
         PX_VAR.GRN_DATA:=_startd
      ?}
   ?}
?};
ZL.cntx_pop();
PX_OBJ.cntx_pop();
1

\ustal_px_grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: tp [23.25]
:: OPIS: Funkcja określa czy dla podanego p01 (ZL.ref) jest utworzny zapis w kolejce planu strategicznego
::   WE:
::   WY: PX_GRP.ref - pierwszy obiekt w kolejce planu strategicznego dla danego zlecenia
::----------------------------------------------------------------------------------------------------------------------

_in:=params_get().in;
_mp:=params_get().mp;

_zlec:=null();
_result:=null();


{? var_pres('p01',_in)=type_of(null()) & _in.p01<>null()
|| _zlec:=_in.p01
?};

{? _zlec<>null
|| _px_obj:=exec('get_zl_object','px_obj',_zlec);
   _ver:=exec('get_mainversion','px_ver');
   PX_CONN.cntx_psh();
   PX_CONN.index('VER');
   PX_CONN.prefix(_ver,_px_obj);
   {? PX_CONN.first()
   || _result:=PX_CONN.PX_GRP
   ?};
   PX_CONN.cntx_pop()
?};

_result