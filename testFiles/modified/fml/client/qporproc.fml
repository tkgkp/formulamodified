:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: qporproc.fml
:: Utworzony: 11.07.2022
:: Autor: Waldemar Werbiński
:: Systemy: MERIT
::======================================================================================================================
:: Zawartość: Porównywarka procesów - przeznaczona do wersji 21.37 i wyższych
::======================================================================================================================
:: URUCHAMIANIE:
:: exec('start','qporproc')
::======================================================================================================================

::======================================================================================================================
:: glowna funkcja sterujaca porownywaniem procesow
::======================================================================================================================


\start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Funkcja porównania procesów
::   WE: [_a] - wyswietlic wynik ['T'] lub 'N' - nie wyswietlac wyniku, 'R' - wyswietlic wynik tylko gdy sa roznice
::       [_b] - $ref() lub ref() procesu nr 1 ['']
::       [_c] - $ref() lub ref() procesu nr 2 ['']
::            jeżeli _b lub _c nie podane, lub nieprawidłowe to wyświetla okno wertowania do wyboru procesów
::   WY: objekt z infomacją o:
::       - BSYM - symbol procesu bazowego
::       - BWER - wersja procesu bazowego
::       - BFIR - firma z której pochodzi proces bazowy
::       - BNAZ - nazwa procesu bazowego
::       - anlogiczne CSYM, CWER, CFIR, CNAZ - dla procesu porównywanego
::       - ROZNICE - liczba wykrytych różnic pomiędzy procesami
::----------------------------------------------------------------------------------------------------------------------
::przetworzenie parametrow wejsciowych
{? (_<1) | (_a=~~) | (type_of(_a)<>type_of('')) || _a:='T' ?};
_disp:=_a;
{? (_<3) | (_b=~~) | (_c=~~)
|| _pb:=_pc:=''
|| _pb:={? type_of(_b)=type_of(null()) || $_b |? type_of(_b)=type_of('') || form(_b) || '' ?};
   _pc:={? type_of(_c)=type_of(null()) || $_c |? type_of(_c)=type_of('') || form(_c) || '' ?};
   {? (type_of(_pb)<>type_of('')) | (type_of(_pc)<>type_of('')) | (_pb='') | (_pc='')
   || _pb:=_pc:=''
   || {? ((+_pb)<>16) | ((+_pc)<>16) | ((8+_pb)<>(8+_pc)) | (form(8+_pb)<>B_PROC.name()) || _pb:=_pc:='' ?}
   ?}
?};

::obiekt wynikowy - utworzenie i nadanie wartości zerowych
_odp:=obj_new('BSYM','BWER','BFIR','BNAZ','CSYM','CWER','CFIR','CNAZ','ROZNICE');
_odp.BSYM:=_odp.CSYM:=_odp.BWER:=_odp.CWER:=_odp.BFIR:=_odp.CFIR:=_odp.BNAZ:=_odp.CNAZ:='';
_odp.ROZNICE:=0;

::pobranie danych procesow
_obj:=exec('wyb_proc','qporproc',_pb,_pc);
{? (_obj.BPROC.REF<>'') & (_obj.CPROC.REF<>'')
||
:: porownanie procesow
   exec('compar_elem','qporproc',_obj);
:: usuwanie niepotrzebnych rekordow z wynikow
   exec('del_emty_branch','qporproc',_obj);
:: wypelnienie obiektu wynikowego
   {? _obj.RAPORT.first()
   || _odp.BSYM:=_obj.BPROC.SYMBOL; _odp.BWER:=_obj.BPROC.VER; _odp.BFIR:=_obj.BPROC.FIRMA; _odp.BNAZ:=_obj.BPROC.NAME;
      _odp.CSYM:=_obj.CPROC.SYMBOL; _odp.CWER:=_obj.CPROC.VER; _odp.CFIR:=_obj.CPROC.FIRMA; _odp.CNAZ:=_obj.CPROC.NAME;
      _odp.ROZNICE:=_obj.RAPORT.ROZNIC
   ?};
   {? (_disp='T') | ((_odp.ROZNICE>0) & (_disp='R'))  || _obj.display() ?}
?};
&_obj;
_odp


::======================================================================================================================
:: Pobieranie danych
::======================================================================================================================


\brak
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [MZZDIOS]
:: OPIS: Napis informujacy o braku
::   WY: napis
::----------------------------------------------------------------------------------------------------------------------
'--brak--'


\cre_obi
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Utworzenie obiektu pomocniczego do przekazywania danych w ramach funkcji
::   WY: objekt
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new(
:: tabela z komentarzami wynikowymi
   'RAPORT'
:: tablica z polami nazwanymi konarow na drzewie tabeli RAPORT
   ,'ROOTS'
:: tabele dane odczytane z bazy danych
:: dane procesu bazowego i porownywanego
   ,'BPROC'
   ,'CPROC'
:: tabele elementow
   ,'BPREL'
   ,'CPREL'
:: indeksy oparte na polu REF w tabelach BPREL i CPREL
   ,'IREFBP'
   ,'IREFCP'
:: tabele powiązań
   ,'BCONN'
   ,'CCONN'
:: tabele warynkow na bramach
   ,'BCHOICE'
   ,'CCHOICE'
:: tabele wartosci parametrow czynnosci
   ,'BPORTS'
   ,'CPORTS'
:: tabele wartosci edi czynnosci
   ,'BEDI'
   ,'CEDI'
:: tabele wartosci komunikatow
   ,'BMSG'
   ,'CMSG'
:: tabele na powiazania portow
   ,'BPOCONN'
   ,'CPOCONN'
:: tabele z danymi pierwszych czynnosci
   ,'BACTSTA'
   ,'CACTSTA'
:: uprawnienia do czynnosci zwiazane z RUNMICRO i TAKEOVER
   ,'BACTRROP'
   ,'CACTRROP'
:: tabele pomocnicze
:: tabela z informacjami o otoczeniu najblizszym elementow oraz tabela wspolczynnikow podobienstwa otoczenia
   ,'BOTOCZ'
   ,'COTOCZ'
   ,'OTOCZ'
:: indeksy podstawowe BOTOCZ i COTOCZ
   ,'IBOTOCZ'
   ,'ICOTOCZ'
   ,'IOTOCZ'
:: tabela warunkow pod jakimi wykonywane sa poszczegolne elementy, oraaz tabela do szybliego porownania podobienstwa
   ,'BGTOUTEL'
   ,'CGTOUTEL'
   ,'GTOUTEL'
:: indeks tabeli wynikowej
   ,'IGTOUTEL'
:: tabela przechowujaca informacje o refach rekordow RAPORT reprezentujacych sparowane laczniki
   ,'RPARCON'
:: ostatni numer uzyty w tabeli raportowania
   ,'RAPREC'
:: pola sterujace
:: informacja czy dokonano jakiejs zmiany
   ,'ZMIANA'
:: ---------metody------------
:: dodanie wiersza do raportu
   ,'add2rap'
:: funkcja zwracajaca wspolczynnik zgodnosci otoczenia _a - tabela elementow procesu 1 _b - tabela elementow procesu 2
   ,'wsp_otocz'
:: usuwanie biezacej pozycji z drzewka
   ,'delpoz'
:: wyswietlenie raportu
   ,'display'
);
_obj.BGTOUTEL:=tab_tmp(2
   ,'ELEMREF','STRING[16]','xPREL.REF'
   ,'WAR','STRING[100]','Tresc warunku'
   );
_obj.CGTOUTEL:=tab_tmp(2
   ,'ELEMREF','STRING[16]','xPREL.REF'
   ,'WAR','STRING[100]','Tresc warunku'
   );
_obj.RPARCON:=tab_tmp(2
   ,'BCONE','STRING[16]','Ref lacznika w procesie 1'
   ,'CCONE','STRING[16]','Ref lacznika w procesie 2'
   ,'RAPORT','INTEGER','#Ref do galezi raportu'
   );
_obj.RAPORT:=tab_tmp(2
   ,'NODE','TREE_REF','Węzeł'
   ,'NR','INTEGER','Numer wiersza'
   ,'ASPECT','STRING[50]','Aspekt'
   ,'BASED','STRING[255]','Proces źródłowy'
   ,'COMPARED','STRING[255]','Proces porównywany'
   ,'ROZNIC','INTEGER','Różnic'
   ,'ROZGET','INTEGER','Liczaba różnic podana'
   ,'ROZLOCK','INTEGER','Ignoruj różnice podległych'
   ,'ELEMENT','STRING[3]','Rodzaj elementu'
   ,'DELLOCK','INTEGER','Zabronione usuniecie'
   ,'ILPODL','INTEGER','Liczba elementow podleglych'
   );
:: jezeli RAPORT.ROZGET<>0 to znaczy, ze nie mozna w tym elemencie sumowac roznic z poziomow nizszych
:: jezeli RAPORT.ROZLOK<>0 to znaczy, ze od tego elementu nie oznaczamy roznic w elementach podrzednych
:: RAPORT.ELEMENT: 'C' -czynnosc, 'B' -brama, 'Z' -zdarzenie, 'T' -tor, 'L' -lacznik poczatek 'l' -lacznik koniec

_obj.RAPREC:=0;
_obj.ZMIANA:=0;
_win:=_obj.RAPORT.mk_sel('Raport porównania procesów','N',,'qporporcrap01',,,,1);
_obj.RAPORT.win_fld(_win,,'ASPECT',,,25,,1);
_obj.RAPORT.win_fld(_win,,'ROZNIC',,,3,,1);
_obj.RAPORT.win_fld(_win,,'BASED',,,60,,1);
_obj.RAPORT.win_fld(_win,,'COMPARED',,,60,,1);
_fml:="{? cur_tab().ROZNIC>0 || {? cur_tab().ROZGET || ',255:150:100' || ',255:255:100' ?} || '' ?}";
_obj.RAPORT.fld_fml('ROZNIC','BEFORE_DISPLAY',_fml);
_fml:="
   _wart:=cur_tab().BASED;
   {? _wart<>exec('brak','qporproc')
   ||
      {? cur_tab().ELEMENT*'C' || ',200:225:255'
      |? cur_tab().ELEMENT*'B' || ',255:200:150'
      |? cur_tab().ELEMENT*'Z'
      || _ev:=1+cur_tab().ELEMENT;
         {? _ev='S' || ',200:255:200'
         |? _ev='P' || ',255:255:200'
         |? _ev='K' || ',255:200:200'
         || ''
         ?}
      |? cur_tab().ELEMENT*'T' || ',200:200:200'
      |? cur_tab().ELEMENT*'L' || ',220:245:220'
      |? cur_tab().ELEMENT*'l' || ',245:220:220'
      || ''
      ?}
   || ''
   ?}
   ";
_obj.RAPORT.fld_fml('BASED','BEFORE_DISPLAY',_fml);
_fml:="
   _wart:=cur_tab().COMPARED;
   {? _wart<>exec('brak','qporproc')
   ||
      {? cur_tab().ELEMENT*'C' || ',200:225:255'
      |? cur_tab().ELEMENT*'B' || ',255:200:150'
      |? cur_tab().ELEMENT*'Z'
      || _ev:=cur_tab().ELEMENT+1;
         {? _ev='S' || ',200:255:200'
         |? _ev='P' || ',255:255:200'
         |? _ev='K' || ',255:200:200'
         || ''
         ?}
      |? cur_tab().ELEMENT*'T' || ',200:200:200'
      |? cur_tab().ELEMENT*'L' || ',220:245:220'
      |? cur_tab().ELEMENT*'l' || ',245:220:220'
      || ''
      ?}
   || ''
   ?}
   ";
_obj.RAPORT.fld_fml('COMPARED','BEFORE_DISPLAY',_fml);
_obj.RAPORT.win_sel(_win);
_obj.RAPORT.win_act(_win,,'Formuła','Rozwiń',,,"cur_tab().tr_set(1)",,1);
_obj.RAPORT.win_act(_win,,'Formuła','Zwiń',,,"cur_tab().tr_set(0)");
::wykaz pol galezi drzewka
_obj.ROOTS:=obj_new('ROOT','ELEMENTY','LANE','ACTION','EVENT','GATE'
   ,'ACTSTD','ACTUNI','ACTUSUAL','ACTLOOP','ACTEDI'
   ,'EVTHROW','EVCAPTUR','EVCAPWAR','EVCAPSYG','EVCAPLA','EVTHSYG','EVTHPLA','EVTHTIM','EVTHTIS','EVTHTIP','EVTHEM'
   ,'GATEVST','GATEVPO','GATECOMP','GATEMULT','GATEJOIN','FLOW');
::dodanie wiersza do raportu:
:: _a - nr nadrzędnego,
:: [_b] - tekst dla aspekt,
:: [_c] - tekst dla based [--brak--],
:: [_d] - tekst dla compared  [--brak--],
:: [_e] - liczba roznic [0],
:: [_f] - jaki rodzaj elementu reprezentuje rekord [''] 'C'-czynnosc, 'Z' -zdarzenie, 'B' -brama, 'T' -tor
:: [_g] - czy blokada usuniecia [0] - nie 1 - tak
:: wynik: numer węzła dodanego rekordu
_obj.add2rap:="
   _node:=_a;
   .RAPORT.cntx_psh(); .RAPORT.prefix();
   _ignore:=(_node>0) & .RAPORT.seek(_node) & .RAPORT.ROZLOCK;
   .RAPORT.cntx_pop();
   .RAPORT.blank();
   .RAPORT.NODE:=_node;
   .RAPREC+=1;
   .RAPORT.NR:=.RAPREC;
   .RAPORT.ROZLOCK:=_ignore;
   .RAPORT.ASPECT:={? (_<2) | (_b=~~) | (type_of(_b)<>type_of('')) || '-' || _b ?};
   .RAPORT.BASED:={? (_<3) | (_c=~~) | (type_of(_c)<>type_of('')) || exec('brak','qporproc') || _c ?};
   .RAPORT.COMPARED:={? (_<4) | (_d=~~) | (type_of(_d)<>type_of('')) || exec('brak','qporproc') || _d ?};
   .RAPORT.ROZNIC:={? (.RAPORT.ROZLOCK<>0) | (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) || 0 || _e ?};
   .RAPORT.ELEMENT:={? (_<6) | (_f=~~) | (type_of(_f)<>type_of('')) || '' || _f ?};
   .RAPORT.DELLOCK:={? (_<7) | (_g=~~) | (type_of(_g)<>type_of(0)) || 0 || _g ?};
:: ewentualne zarejestrowanie, ze liczbe roznic podano w parametrze
   {? .RAPORT.ROZNIC>0 || .RAPORT.ROZLOCK:=.RAPORT.ROZGET:=1 ?};
   .RAPORT.add();
   .ZMIANA+=1;
   _odp:=#.RAPORT.ref();
   _ilr:=.RAPORT.ROZNIC;
   .RAPORT.cntx_psh(); .RAPORT.prefix();
:: sumowanie roznic w elementach wyzej w strukturze az do natrafieniu na element, ktory ma to wartosc nadana parametrem
   {!
   |? (_ilr>0) & (.RAPORT.NODE>0) & .RAPORT.seek(.RAPORT.NODE) & (.RAPORT.ROZGET=0)
   |! .RAPORT.ROZNIC+=_ilr; .RAPORT.put()
   !};
   .RAPORT.cntx_pop();
   .RAPORT.cntx_psh(); .RAPORT.prefix();
   {! |? (.RAPORT.NODE>0) & .RAPORT.seek(.RAPORT.NODE) |! .RAPORT.ILPODL+=1; .RAPORT.put() !};
   .RAPORT.cntx_pop();
   _odp
   ";
::zwrocenie wspolczynnika zgodnosci otoczenia dla wskazanych elementow obu procesow
:: _a - tabela elementow procesu 1 ustawiona na elemencie, ktory nalezy zbadac
:: _b - tabela elementow procesu 2 ustawiona na elemencie, ktory nalezy zbadac
:: _c - zakres porownywanego otoczenia: W -calosc, P-poprzedniki, N-nastepniki
:: WYNIK: 0 - gdy nie ma wspolczynnika, lub wartosc wspolczynnika podobienstwa otoczenia
_obj.wsp_otocz:="
   _t1:=_a; _t2:=_b; _zakres:={? (_<3) | (_c=~~) || 'W' || _c ?};
   .OTOCZ.index(.IOTOCZ); .OTOCZ.prefix();
   {? .OTOCZ.find_key(_t1.REF,_t2.REF,)
   || {? _zakres='P' || .OTOCZ.WSPOLCZP |? _zakres='N' || .OTOCZ.WSPOLCZN || .OTOCZ.WSPOLCZ ?}
   || 0
   ?}
   ";
::usuniecie biezacej pozycji z drzewa
::odpowiedź 1 -usunieto, 0 -nie usunieto
_obj.delpoz:="
   _odp:=0;
   {? (.RAPORT.ILPODL=0) & (.RAPORT.ROZNIC=0) & ((.RAPORT.ELEMENT='') | (.RAPORT.ELEMENT='L') | (.RAPORT.ELEMENT='l'))
      & (.RAPORT.DELLOCK=0)
   ||
::    >>>>>>>>>>>>>>>>>>>>>
      do();
      .RAPORT.cntx_psh(); .RAPORT.prefix();
      {! |? (.RAPORT.NODE>0) & .RAPORT.seek(.RAPORT.NODE) |! .RAPORT.ILPODL-=1; .RAPORT.put() !};
      .RAPORT.cntx_pop();
      _odp:={? .RAPORT.del(1,1) || 1 || 0 ?};
      end()
::    <<<<<<<<<<<<<<<<<<<<
   ?};
   _odp
   ";
_obj.display:=".RAPORT.first(); .RAPORT.tr_set(1); .RAPORT.select()";
_obj


\wyb_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Wybór procesów do porównania
::   WE: _a - $ref() procesu nr 1 lub ''
::       _b - $ref() procesu nr 2 lub ''
::   WY: obiekt z $ref do porownywanych procesow
::----------------------------------------------------------------------------------------------------------------------
_pb:=_a; _pc:=_b;

_sql:='select B_PROC.REFERENCE REF, FF.REFERENCE FIREF, B_PROC.SYMBOL SYMBOL, VER, NAME, FF.SYMBOL FIRMA, '
   +' ACTIVE, ACCEPTED, CRUCIAL, TM_PLAN, TR_MODE, MODIFIED, ARCHDEL, MAX_INS MAXINS '
   +' from B_PROC '
   +' join FIRMA as FF using(B_PROC.FIRMA,FF.REFERENCE)'
   +{? _pb<>'' || ' where (B_PROC.REFERENCE=\':_a\') or (B_PROC.REFERENCE=\':_b\') ' || '' ?}
   +' order by SYMBOL, VER, FIRMA';
_proclist:=sql(_sql,_pb,_pc);
_win:=_proclist.mk_sel('Wybierz proces ','P',,'qporporc1p01',,,,,'U','T');
_proclist.win_fld(_win,,'SYMBOL',,,30,,1,'Symbol');
_proclist.win_fld(_win,,'NAME',,,50,,1,'Nazwa');
_proclist.win_fld(_win,,'VER',,,,,1,'Wersja');
_proclist.win_fld(_win,,'FIRMA',,,,,1,'Firma');
_proclist.win_fld(_win,,'ACTIVE',,,,,1,'Aktywny',,,2,,"'T'","'N'");
_proclist.win_fld(_win,,'ACCEPTED',,,,,1,'Zakceptowany',,,2,,"'T'","'N'");
_proclist.win_fld(_win,,'CRUCIAL',,,,,1,'Wymagany',,,2,,"'T'","'N'");
_proclist.win_act(_win,,'Formuła','Wybierz',,,,"{? cur_tab().f_active() || cur_tab().f_get() ?}; sel_exit()",1);
_proclist.win_act(_win,,'Szukaj');
_proclist.win_act(_win,,'Kolejność');
_proclist.win_act(_win,,'Rekord',,,,"REF.FIRMA().SYMBOL=cur_tab().FIRMA");
_proclist.win_sel(_win);
_proclist.hdr_sel('bazowy');
_wyn:=exec('cre_obi','qporproc');
_load:="
   _info:=obj_new('REF','SYMBOL','VER','NAME','FIRMA','FREF','ACTIVE','ACCEPTED','CRUCIAL','ARCHDEL'
            ,'TM_PLAN','TR_MODE','MODIFIED','MAXINS','INFO');
   _proclist:=_a;
   _info.REF:=_proclist.REF; _info.SYMBOL:=_proclist.SYMBOL; _info.VER:=_proclist.VER; _info.NAME:=_proclist.NAME;
   _info.FIRMA:=_proclist.FIRMA; _info.FREF:=_proclist.FIREF; _info.ACTIVE:=_proclist.ACTIVE;
   _info.ACCEPTED:=_proclist.ACCEPTED;  _info.CRUCIAL:=_proclist.CRUCIAL; _info.ARCHDEL:=_proclist.ARCHDEL;
   _info.TM_PLAN:=form(_proclist.TM_PLAN/1000000,,0,'99');  _info.TR_MODE:=_proclist.TR_MODE;
   _info.MAXINS:=form(_proclist.MAXINS,,0,'99');
   _info.INFO:=_proclist.SYMBOL+' ('+_proclist.VER+') [FIRMA'+_proclist.FIRMA+'] - '+_proclist.NAME;
   _info
   ";
{? (_pb<>'') & (_proclist.size()<>0)
||
   _proclist.first();
   _wyn.BPROC:=_load(_proclist);
   {? _proclist.last() || _wyn.CPROC:=_load(_proclist) ?}
|? (_pb='') & _proclist.select()
||
   _wyn.BPROC:=_load(_proclist);
   _proclist.hdr_sel();
   _proclist.hdr_sel('do porównania');
   _sym:=_proclist.SYMBOL;
   _proclist.del();
   _proclist.find_key(_sym,);
   {? _proclist.select(,1) || _wyn.CPROC:=_load(_proclist) ?}
|| _info:=obj_new('REF','INFO'); _info.REF:=''; _info.INFO:='BLAD_NIE_WSKAZAL';
   _wyn.BPROC:=_wyn.CPROC:=_info
?};
_wyn.ROOTS.ROOT:=_wyn.add2rap(0,'Porównanie procesów',_wyn.BPROC.INFO,_wyn.CPROC.INFO);
&_proclist;
{? (5+_wyn.BPROC.INFO)<>'BLAD_'
||
   {? (_wyn.BPROC.FIRMA<>_wyn.CPROC.FIRMA) | (_wyn.BPROC.ACTIVE<>_wyn.CPROC.ACTIVE)
      | (_wyn.BPROC.ACCEPTED<>_wyn.CPROC.ACCEPTED) | (_wyn.BPROC.CRUCIAL<>_wyn.CPROC.CRUCIAL)
      | (_wyn.BPROC.TM_PLAN<>_wyn.CPROC.TM_PLAN) | (_wyn.BPROC.TR_MODE<>_wyn.CPROC.TR_MODE)
      | (_wyn.BPROC.MAXINS<>_wyn.CPROC.MAXINS) | (_wyn.BPROC.TR_MODE<>_wyn.CPROC.TR_MODE)
      | (_wyn.BPROC.ARCHDEL<>_wyn.CPROC.ARCHDEL)
   ||
      _wp:=_wyn.add2rap(_wyn.ROOTS.ROOT,'Parametry procesów','','');
      {? _wyn.BPROC.FIRMA<>_wyn.CPROC.FIRMA || _wyn.add2rap(_wp,'Firma',_wyn.BPROC.FIRMA,_wyn.CPROC.FIRMA,1) ?};
      {? _wyn.BPROC.ACTIVE<>_wyn.CPROC.ACTIVE || _wyn.add2rap(_wp,'Aktywny',_wyn.BPROC.ACTIVE,_wyn.CPROC.ACTIVE,1) ?};
      {? _wyn.BPROC.ACCEPTED<>_wyn.CPROC.ACCEPTED
      || _wyn.add2rap(_wp,'Zaakceptowany',_wyn.BPROC.ACCEPTED,_wyn.CPROC.ACCEPTED,1)
      ?};
      {? _wyn.BPROC.CRUCIAL<>_wyn.CPROC.CRUCIAL || _wyn.add2rap(_wp,'Wymagany',_wyn.BPROC.CRUCIAL,_wyn.CPROC.CRUCIAL,1) ?};
      {? _wyn.BPROC.ARCHDEL<>_wyn.CPROC.ARCHDEL
      || _wyn.add2rap(_wp,'Instancje usuwane',_wyn.BPROC.ARCHDEL,_wyn.CPROC.ARCHDEL,1)
      ?};
      {? _wyn.BPROC.TR_MODE<>_wyn.CPROC.TR_MODE
      || _wyn.add2rap(_wp,'Wyliczanie terminu realizacji',_wyn.BPROC.TR_MODE,_wyn.CPROC.TR_MODE,1)
      ?};
      {? _wyn.BPROC.TM_PLAN<>_wyn.CPROC.TM_PLAN
      || _wyn.add2rap(_wp,'Planowany czas trwania [s]',_wyn.BPROC.TM_PLAN,_wyn.CPROC.TM_PLAN,1)
      ?};
      {? _wyn.BPROC.MAXINS<>_wyn.CPROC.MAXINS
      || _wyn.add2rap(_wp,'Maks instancji',_wyn.BPROC.MAXINS,_wyn.CPROC.MAXINS,1)
      ?}
   ?}
?};
_wyn


\load_elem
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Pobranie danych o elementach
::   WE: _a - $ref procesu
::       _b - $ref FIRMA
::       _c - $ref FIRMA drugiego procesu
::   WY: Tabela tymczasowa z danymi elementów
::----------------------------------------------------------------------------------------------------------------------
_proc:=_a;
_firma:=_b;
_fir2:=_c;
_sql:='select B_PREL.REFERENCE REF, B_PREL.CLASS RODZAJ, B_PREL.TYPE TYP, '
   +' B_EVENT.CATEGORY EVKATEG, B_EVENT.KIND EVKIND, B_EVENT.TYPE EVTYPE, B_EVENT.SYMBOL EVSYM, B_ROLE.NAME ROLA, '
   +' B_PREL.AUTOMAT AUTO, B_PREL.LOOP LOOP, B_WORKER.KOD KOLEJKA, B_SIGNAL.SYMBOL SYGNAL, B_PREL.B_SIGNAL SIGREF, '
   +' START, GATEKIND, GATETYPE, '
   +' B_ELE.SYMBOL SYMBOL, B_PREL.B_ELE ELEREF, B_PREL.SYMBOL NAZWA, FMANMAIN, FMANOUT, FCOND, FMANDESC, FMANVIEW, '
   +' B_PREL.FMACCESS FACCES, G_CANCEL, ASSIGNTD, DESKTOP, B_DOMAIN.SYMBOL DOMAIN, TR_MODE, B_PREL.TM_PLAN TM_PLAN, '
   +' COND_CHK, B_PREL.ENABLED ENABLED, IVD.KIND IVKIND, IVD.TM_STAMP IVTMS, IVD.TIME IVTIME, IVD.VALUE1 IV1, '
   +' IVD.VALUE2 IV2, IVD.VALUE3 IV3, IV1.NAME IVNAME1,  IV2.NAME IVNAME2, B_PREL.IVAL_DEF IVAL_DEF, '
   +' B_TIMER.TRYB TTRYB, B_TIMER.T TT, B_TIMER.M TM, B_TIMER.D TD, B_TIMER.DT TDT, B_TIMER.TM TTM, '
   +' B_TIMER.EXPIRES EXPIRES, B_TIMER.DTE TDTE, B_TIMER.TME TTME, B_TIMER.REPLY REPLY, B_TIMER.REPEAT REPEAT, '
   +' B_TIMER.INTERVAL INTERVAL, B_TIMER.DURATION TDURATION, B_TIMER.SINGLE SINGLE, B_TIMER.TM_PLAN TTM_PLAN, '
   +' B_PREL.ISTDEF_T ISTT, B_PREL.ISTDEF ISTREF, B_PREL.ISTDEF_T ISTT, I.SYSTEM ISTSY, I.IST_ISTK ISTK, '
   +' I.RODZAJ ISTR, I.DATA ISTDT, I.VER ISTVE, '
   +' B_ACTION.REFERENCE ACTREF, \' \' as RUNMICRO, \' \' as TAKEOVER, \' \' as RELEASE, '
   +' 0 as DURATION, \''+(100*' ')+'\' as WARTOSC, \''+(255*' ')+'\' as MSGTR, '
   +' \'          \' as OUTTYP, 0 as USED, '
   +' \''+(60*' ')+'\' UZUPELN, '
   +{? (#(2+user(10)))>=22
    || ' B_PREL.NOTIFY_1 EMAIL, B_PREL.NOTIFY_2 SMS, B_PREL.PERSONAL PERSONAL, B_PREL.RELEASE RELEASE, '
    || ''
    ?}
   +' \'T\' as STANDARD, 0 as BRIDGE, \'NULLNULLNULLNULL\' as BRREF, \'[XXXXXXX]\' as TRYB  '
   +' from B_PREL '
   +' join B_ELE using(B_PREL.B_ELE,B_ELE.REFERENCE) '
   +' left join B_ACTION using(B_PREL.B_ELE,B_ACTION.B_ELE) '
   +' left join B_EVENT using(B_PREL.B_ELE,B_EVENT.B_ELE) '
   +' left join B_ROLE using(B_PREL.B_ROLE,B_ROLE.REFERENCE) '
   +' left join B_WORKER using(B_PREL.B_WORKER,B_WORKER.REFERENCE) '
   +' left join B_SIGNAL using(B_PREL.B_SIGNAL,B_SIGNAL.REFERENCE) '
   +' left join B_DOMAIN using(B_PREL.B_DOMAIN,B_DOMAIN.REFERENCE) '
   +' left join IVAL_DEF as IVD using(B_PREL.IVAL_DEF,IVD.REFERENCE) '
   +' left join IVAL_NAM as IV1 using(IVD.TYPE1,IV1.REFERENCE) '
   +' left join IVAL_NAM as IV2 using(IVD.TYPE2,IV2.REFERENCE) '
   +' left join B_TIMER using(B_PREL.REFERENCE,B_TIMER.B_PREL) '
   +' left join ISTDEF as I using(B_PREL.ISTDEF,I.REFERENCE) '
   +' where B_PROC=\':_a\' '
   +' order by RODZAJ, REF ';
_wyn:=sql(_sql,_proc);
::niewyjasniony blad sql - powielanie krotek - proteza
_refs:=tab_tmp(2,'REF','STRING[16]','B_PREL.ref()','REK','STRING[16]','_wyn.ref()');
{? _wyn.first()
|| {!
   |? {? _refs.find_key(_wyn.REF,)=0 || _refs.REF:=_wyn.REF; _refs.REK:=$_wyn.ref(); _refs.add()
      |? _refs.find_key(_wyn.REF,) & (_refs.REK<>($_wyn.ref())) || _wyn.del()
      || _wyn.next()
      ?}
   !}
?};
&_refs;
::pobranie wartosci parametru PARAM dla czynnosci typu petla
_sql:='select B_VALPRT.B_PREL REF, B_VALPRT.FORMULA WARTOSC '
   +' from B_VALPRT '
   +' join :_a as PREL using(B_VALPRT.B_PREL,PREL.REF) '
   +' join B_PORT using(B_VALPRT.B_PORT,B_PORT.REFERENCE) '
   +' where (B_PORT.SYMBOL=\'PARAM\') and (B_VALPRT.B_PREL in (select REF from :_a where :_a.SYMBOL=\'ZWS_GGR_PKEY\')) '
   +' order by REF ';
_var:=sql(_sql,_wyn);
::pobranie typow dynamicznych parametrow wyjsciowych
_sql:='select B_PORT.B_PREL PREL, B_TYPE.SYMBOL OUTTYP from B_PORT join B_TYPE using(B_PORT.B_TYPE,B_TYPE.REFERENCE) '
   +' where (B_ELE is null) and (KIND=\'OUT\') and (B_PREL in (select REF from :_a where RODZAJ=\'B_ACTION\' order by 1)) '
   +' order by PREL ';
_parout:=sql(_sql,_wyn);
::usuniecie wartosci technicznych
{? _wyn.first() || {! |? _wyn.BRREF:=''; _wyn.OUTTYP:=''; _wyn.put(); _wyn.next() !} ?};
_wyn.prefix('B_ACTION');
{? _wyn.first()
|| {!
   |?
      {? (_wyn.SYMBOL='ZWS_MAN_UALL') | (_wyn.SYMBOL='ZWS_SER_VICE') || _wyn.STANDARD:='N' ?};
      {? _wyn.SYMBOL='ZWS_SER_VICE' || _wyn.TYP:='Z'; _wyn.AUTO:='S'
      |? _wyn.SYMBOL='ZWS_GGR_PKEY' || {? _wyn.TYP='S' || _wyn.AUTO:='S' ?}; _wyn.TYP:='L'; _wyn.STANDARD:='N'
      |? _wyn.SYMBOL='ZWS_EDI_UNIW' || {? _wyn.TYP='S' || _wyn.AUTO:='S' ?}; _wyn.TYP:='E'; _wyn.STANDARD:='N'
      || {? _wyn.TYP='S' || _wyn.AUTO:='S' ?}
      ?};
      {? _wyn.AUTO='S' || _wyn.TRYB:='[SERVICE]'
      |? _wyn.AUTO='M' || _wyn.TRYB:='[USER]'
      || _wyn.TRYB:='[AUTO]'
      ?};
      {? _wyn.SYMBOL='ZWS_GGR_PKEY' & _var.find_key(_wyn.REF,)
      || _wyn.WARTOSC:=_var.WARTOSC
      || _wyn.WARTOSC:=''
      ?};
      {? _wyn.IVAL_DEF<>'' || _wyn.DURATION:=1 ?};
      {? (_wyn.STANDARD='N') & (_wyn.TYP<>'L')  & (_wyn.TYP<>'E') & _parout.find_key(_wyn.REF,)
      || _wyn.OUTTYP:=_parout.OUTTYP
      ?};
      _wyn.put();
      _wyn.next()
   !}
?};
obj_del(_parout); &_parout;
obj_del(_var);
::dynamiczne parametry wyjsciowe zdarzen warunkowych
_sql:='select B_PORT.B_PREL PREL, B_TYPE.SYMBOL OUTTYP from B_PORT join B_TYPE using(B_PORT.B_TYPE,B_TYPE.REFERENCE) '
   +' where (B_ELE is null) and (KIND=\'OUT\') '
      +' and (B_PREL in (select REF from :_a where (RODZAJ=\'B_EVENT\') and (EVKIND=\'warunkowe\') order by 1)) '
   +' order by PREL ';
_parout:=sql(_sql,_wyn);
_wyn.prefix('B_EVENT');
{? _wyn.first()
|| {!
   |?
      {? (_wyn.EVKIND='warunkowe') & _parout.find_key(_wyn.REF,) || _wyn.OUTTYP:=_parout.OUTTYP ?};
      _wyn.TRYB:={? _wyn.AUTO='T' || '[AUTO]' || '[TODO]' ?};
      _wyn.put();
      _wyn.next()
   !}
?};
obj_del(_parout);
::jezeli firmy w obu procesach rozne, to pobieramy dodatkowo konfiguracje globalna
{? _firma<>_fir2
||
   _sql:='select B_ACTION, TAKEOVER, RUNMICRO, RELEASE from B_ACTPRO '
      +' where (FIRMA=\':_b\') and B_ACTION in (select distinct ACTREF from :_a where B_ACTION<>\'\' order by 1) '
      +' order by B_ACTION';
   _prop:=sql(_sql,_wyn,_firma);
   _wyn.prefix();
   {? _wyn.first()
   || {!
      |?
         {? (_wyn.ACTREF<>'') & _prop.find_key(_wyn.ACTREF)
         || _wyn.RUNMICRO:=_prop.RUNMICRO; _wyn.TAKEOVER:=_prop.TAKEOVER;  _wyn.RELEASE:=_prop.RELEASE;
            _wyn.put()
         ?};
         _wyn.next()
      !}
   ?}
?};
_wyn.prefix(); _wyn.first();
_wyn.index(_wyn.ndx_tmp(,,'RODZAJ',,,'TYP',,,'GATEKIND',,,'GATETYPE',,));
_wyn


\load_edi
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zaladowanie informacji EDI
::   WE: _a - tabela elementow
::   WY: tabela danych na temat parametrow EDI
::----------------------------------------------------------------------------------------------------------------------
_elem:=_a;

::pobranie listy refow ISTDEF
_ist:=sql('select distinct ISTREF from :_a where ISTREF<>\'\' order by 1',_elem);
_sql:='select I.REFERENCE ISTREF, I.SYSTEM ISTSY, I.IST_ISTK ISTK, I.RODZAJ ISTR, I.DATA ISTDT, I.VER ISTVE, '
   +' V.SYSTEM VSYS, V.NAZWA VNAZ, V.OD VOD, V.NR ISTN '
   +' from ISTDEF as I '
   +' left join VAT_VER as V using(I.NR,V.REFERENCE) '
   +' where I.REFERENCE in (select ISTREF from :_a) '
   +' order by ISTREF';
_wyn:=sql(_sql,_ist);
obj_del(_ist);
_wyn


\load_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zaladowanie informacji o parametrach MSG
::   WE: _a - tabela elementow
::       _b - indeks tabeli elementow
::   WY: tabela danych na temat parametrow MSG
::----------------------------------------------------------------------------------------------------------------------
_elem:=_a;
_ind:=_b;

_elem.cntx_psh(); _elem.index(_ind); _elem.prefix();
::pobranie listy refow B_PREL
_prel:=sql('select distinct REF from :_a order by 1',_elem);
_refs:=sql('select REFERENCE REF, B_PREL from B_MSG where B_PREL in (select REF from :_a) order by REF',_prel);
obj_del(_prel);
_wyn:=tab_tmp(1
   ,'B_PREL','STRING[16]','$B_PREL.ref()'
   ,'ON','STRING[1]','ON'
   ,'SUB','STRING[200]','Temat'
   ,'BODYT','STRING[255]','Treść txt'
   ,'BODYH','STRING[255]','Treść html'
   ,'SENDER','STRING[100]','Ndawca'
   ,'FROM','STRING[100]','Autor'
   ,'REPLYTO','STRING[100]','Odpowiedź do'
   ,'RCV','STRING[100]','Odbiorca'
   ,'RETURN','STRING[1]','Potwierdzenie odbioru'
   ,'SCHEMAT','STRING[1]','Wg schematu'
   ,'TO','STRING[255]','Do'
   ,'DW','STRING[255]','Do wiadomosci'
   ,'UDW','STRING[255]','Ukryte do wiadomosci'
   ,'BI_BLOBA','STRING[255]','Zał. dołączone'
   ,'BI_BLOBE','STRING[255]','Zał. osadzone'
   ,'HEADTAGS','STRING[255]','Tagi dla nagłówka wiadomości'
   ,'TEMPLATE','STRING[50]','Wzorzec'
   );
_fml:="
   _bi_blob:=_a;
   BI_BLOP.prefix(_bi_blob);
   _odp:='';
   {? BI_BLOP.first()
   ||
      _tab:=tab_tmp(1,'ID','STRING[40]','ID');
      {!
      |? _tab.blank();
         _tab.ID:=BI_BLOP.BLOB().ID;
         _tab.add();
         BI_BLOP.next()
      !};
      {? _tab.first() || {! |? _odp+=_tab.ID+';'; _tab.next() !} ?};
      obj_del(_tab)
   ?};
   _odp
   ";
{? _refs.first()
|| Cntx.psh(B_MSG,BI_BLOB,BI_BLOP);
   B_MSG.prefix(); BI_BLOP.index('BI_BLOB');
   {!
   |?
      {? B_MSG.seek(_refs.REF)
      ||
         _wyn.blank();
         _wyn.B_PREL:=$B_MSG.B_PREL;
         _wyn.ON:=B_MSG.ON;
         _wyn.SUB:=B_MSG.SUB;
         _wyn.SENDER:=B_MSG.SENDER;
         _wyn.FROM:=B_MSG.FROM;
         _wyn.REPLYTO:=B_MSG.REPLYTO;
         _wyn.RCV:=B_MSG.RCV;
         _wyn.RETURN:=B_MSG.RETURN;
         _wyn.SCHEMAT:=B_MSG.SCHEMAT;
         _wyn.TEMPLATE:=B_MSG.TEMPLATE;
         _wyn.BI_BLOBA:=_fml(B_MSG.BI_BLOBA);
         _wyn.BI_BLOBE:=_fml(B_MSG.BI_BLOBE);
         {? B_MSG.memo_get(,'BODYT',0) || _wyn.BODYT:=B_MSG.memo_txt(,1,'BODYT') ?};
         {? B_MSG.memo_get(,'BODYH',0) || _wyn.BODYH:=B_MSG.memo_txt(,1,'BODYH') ?};
         {? B_MSG.memo_get(,'TO',0) || _wyn.TO:=B_MSG.memo_txt(,1,'TO') ?};
         {? B_MSG.memo_get(,'CC',0) || _wyn.DW:=B_MSG.memo_txt(,1,'CC') ?};
         {? B_MSG.memo_get(,'BCC',0) || _wyn.UDW:=B_MSG.memo_txt(,1,'BCC') ?};
         {? B_MSG.memo_get(,'HEADTAGS',0) || _wyn.HEADTAGS:=B_MSG.memo_txt(,1,'HEADTAGS') ?};
         _wyn.add();
         {? _elem.find_key(_wyn.B_PREL,)
         || _elem.MSGTR:=_wyn.SUB+_wyn.BODYT+_wyn.BODYH+_wyn.TO+_wyn.DW+_wyn.HEADTAGS+_wyn.TEMPLATE;
            _elem.put()
         ?}
      ?};
      _refs.next()
   !};
   Cntx.pop(B_MSG,BI_BLOB,BI_BLOP)
?};
obj_del(_refs);
_elem.cntx_pop();
_wyn


\load_actrop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zaladowanie informacji o gropach dla RUNMICRO i TAKEOVER
::   WE: _a - tabela elementow
::   WY: tabela tymczasowa
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;

_sql:='select distinct ACTREF from :_a where RUNMICRO=\'T\' or TAKEOVER=\'T\' order by ACTREF';
_act:=sql(_sql,_tt);
{? _act.size()
|| _sql:='select B_ACTROP.FIRMA FIRMA, B_ACTROP.B_ACTION ACTION, B_ACTROP.TYP TYP, B_ROLE.NAME ROLA from B_ACTROP '
      +' join B_ROLE '
      +' where B_ACTION in (select ACTREF from :_a) '
      +' order by 1,2,3';
   _wyn:=sql(_sql,_tt)
|| _wyn:=sql('select FIRMA, B_ACTION ACTION, TYP, B_ROLE ROLA from B_ACTROP where 0=1 order by 1,2,3')
?};
_wyn


\load_actsta
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Rejestr pierwszych czynnosci
::   WE: _a - tabela z danymi elementow
::   WY: tabela tymczasowa z danymi pierwszych czynnosci
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;

::_sql:='select '
::   +' B_ACTSTA.PREL_EVE EVE, B_ACTSTA.PREL_ACT ACT, CZYN.BRIDGE BRIDGE, CZYN.BRREF BRREF, CZYN.RODZAJ RODZAJ, '
::   +' CZYN.TYP TYP, CZYN.ROLA ROLA, CZYN.STANDARD STANDARD, CZYN.NAZWA NAZWA, CZYN.FMANMAIN FMANMAIN, '
::   +' CZYN.WARTOSC WARTOSC, CZYN.FMANOUT FMANOUT, CZYN.DOMAIN DOMAIN, CZYN.AUTO AUTO, CZYN.TRYB TRYB, '
::   +' CZYN.SYMBOL SYMBOL, CZYN.USED USED '
::   +' from B_ACTSTA '
::   +' join :_a as CZYN using(B_ACTSTA.PREL_ACT,CZYN.REF) '
::   +' where PREL_EVE in (select REF from :_a DANE where DANE.RODZAJ=\'B_EVENT\' order by REF) '
::   +' order by EVE';
_sql:='select '
   +' B_ACTSTA.PREL_EVE EVE, B_ACTSTA.PREL_ACT ACT '
   +' from B_ACTSTA '
   +' where PREL_EVE in (select REF from :_a DANE where DANE.RODZAJ=\'B_EVENT\' order by REF) '
   +' order by EVE ';
sql(_sql,_tt)


\load_flow
::----------------------------------------------------------------------------------------------------------------------
::  UTW [Macrologic]
:: OPIS: Pobranie danych o łącznikach z uwzglednieniem warunkow na bramach
::   WE: _a - $ref procesu
::       _b - tabela elementow
::   WY: tabela tymxczasowa z danymi o łącznikach
::----------------------------------------------------------------------------------------------------------------------
_proc:=_a;
_tt:=_b;

::ladowanie danych o przeplywach (lacznikach)
_sql:='select '
      +' B_CONN.FROM OD, B_CONN.TO DO, NAME, B_CONN.DEFAULT DEFAULT, B_CONN.ORDER KOLEJ, '
      +' B_CONN.NAME_MOD NAME_MOD, B_ELE.SYMBOL SYMBOL, '
      +' B_CONN.REFERENCE REF, 0 as USED '
      +' from B_CONN '
      +' join B_ELE using(B_CONN.B_ELE,B_ELE.REFERENCE) '
      +' where B_PROC=\':_a\' '
      +' order by OD, DO ';
_flow:=sql(_sql,_proc);

::dodanie pol na most i dene z mostow elementow laczonych
_sql:='select '
      +' A.OD OD, A.DO DO, A.NAME NAME, A.KOLEJ KOLEJ, A.DEFAULT DEFAULT, A.NAME_MOD NAME_MOD, A.SYMBOL SYMBOL,'
      +' A.REF REF, \'NULLNULLNULLNULL\' as BRREF, 0 as BRIDGE, A.USED USED, '
      +' B.BRREF ODBRREF, C.BRREF DOBRREF, B.BRIDGE ODBRIDGE, C.BRIDGE DOBRIDGE, '
      +' C.RODZAJ DORODZAJ, C.GATEKIND DOKIND '
      +' from :_a as A '
      +' join :_b as B using(A.OD,B.REF) '
      +' join :_b as C using(A.DO,C.REF) '
      +' order by OD, DO ';
_wyn:=sql(_sql,_flow,_tt);
obj_del(_flow);
{? _wyn.first() || {! |? _wyn.BRREF:=''; _wyn.put();  _wyn.next() !} ?};
_wyn


\load_gate_cond
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zaladowanie danych warunkow na bramach
::   WE: _a - tabela powiazan
::   WY: tabela z informacjami o warunkach
::----------------------------------------------------------------------------------------------------------------------
_flow:=_a;

::pobierane sa tylko warunki na bramach typu OR lub XOR zwiazanych z lacznikami podanymi w tabeli
_sql:='select '
      +' A.OD OD, A.DO DO, A.NAME NAME, A.KOLEJ KOLEJ, E.NAME ROLA, B.B_CONN CONREF, '
      +' B.REFERENCE REF, B.B_PREL BRAMA, B.PREL_SRC WAROD, B.NAME WARNAME, B.VALUE VALUE, B.FORMULA FORMULA, '
      +' B.OPERATOR OPERATOR, B.KIND KIND, B.CASE_SEN CASE_SEN, B.ORDER WARORDER, C.SYMBOL WARPARAM '
      +' from B_CHOICE as B '
      +' left join :_a as A using(B.B_CONN,A.REF) '
      +' left join B_PORT as C using(B.B_PORT,C.REFERENCE) '
      +' join B_PREL as D using(B.B_PREL,D.REFERENCE) '
      +' left join B_ROLE as E using(D.B_ROLE,E.REFERENCE) '
      +' where ((D.GATETYPE=\'OR\') or (D.GATETYPE=\'XOR\')) and (D.GATEKIND=\'<\') '
      +'    and (B.B_CONN in (select distinct REF from :_a where DEFAULT=\'N\' order by REF)) '
      +' order by BRAMA, WARORDER ';
_war:=sql(_sql,_flow);
::zapisanie do tabeli ze zmniejszanymi dlugosciami pol, aby moc tworzyc indeks zawierajacy wszystkie potrzebne pola
_out:=tab_tmp(6
   ,'CONREF','STRING[16]','CONREF'
   ,'KIND','STRING[1]','KIND'
   ,'CASE_SEN','STRING[1]','CASE_SEN'
   ,'WARNAME','STRING[80]','WARNAME'
   ,'NAME','STRING[50]','NAME'
   ,'FORMULA','STRING[200]','FORMULA'
   ,'BRAMA','STRING[16]','BRAMA'
   ,'WARORDER','INTEGER','WARORDER'
   ,'OD','STRING[16]','OD'
   ,'DO','STRING[16]','OD'
   ,'KOLEJ','INTEGER','KOLEJ'
   ,'ROLA','STRING[30]','ROLA'
   ,'REF','STRING[16]','REF'
   ,'WAROD','STRING[16]','WAROD'
   ,'VALUE','STRING[60]','VALUE'
   ,'OPERATOR','STRING[20]','OPERATOR'
   ,'WARPARAM','STRING[30]','WARPRAM'
   ,'BRREF','STRING[16]','BRREF'
   ,'BRIDGE','INTEGER','BRIDGE'
   ,'USED','INTEGER','USED'
   );
::jednoczesna eleminacja zdublowanych identycznych warunkow na tych samych lacznikach
{? _war.first()
|| {!
   |?
      {? ~_out.find_key(_war.CONREF,_war.KIND,_war.CASE_SEN,_war.WARNAME,_war.NAME,_war.FORMULA,)
      ||
         _out.blank();
         _out.BRAMA:=_war.BRAMA;
         _out.WARORDER:=_war.WARORDER;
         _out.OD:=_war.OD;
         _out.DO:=_war.DO;
         _out.NAME:=_war.NAME;
         _out.KOLEJ:=_war.KOLEJ;
         _out.ROLA:=_war.ROLA;
         _out.CONREF:=_war.CONREF;
         _out.REF:=_war.REF;
         _out.WAROD:=_war.WAROD;
         _out.WARNAME:=_war.WARNAME;
         _out.VALUE:=_war.VALUE;
         _out.FORMULA:=_war.FORMULA;
         _out.OPERATOR:=_war.OPERATOR;
         _out.KIND:=_war.KIND;
         _out.CASE_SEN:=_war.CASE_SEN;
         _out.WARPARAM:=_war.WARPARAM;
         _out.add()
      ?};
      _war.next()
   !}
?};
obj_del(_war);
_out


\load_ports
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zaladowanie informacji o portach czynnosci
::   WE: _a - tabela elementow
::   WY: tabela danych na temat portow
::----------------------------------------------------------------------------------------------------------------------
_elem:=_a;

::pobranie listy refow elementow
_sql:='select REF, ELEREF, SIGREF from :_a '
   +' where (RODZAJ=\'B_ACTION\') or (RODZAJ=\'B_EVENT\') or (RODZAJ=\'B_GATE\') '
   +' order by ELEREF, REF ';
_tu:=sql(_sql,_elem);

::pobranie wszystkich portow pasujacych do podanych elementow
_sql:='select B_PORT.B_PREL ELEMREF, B_PORT.B_ELE ELE, B_PORT.B_ACTELE AELE, B_PORT.KIND KIND, '
   +' B_PORT.SYMBOL SYMBOL, B_PORT.NAME NAZWA, '
   +{? (#(2+user(10)))>=22 || ' B_PORT.C_EVENT C_EVENT, ' || ' \'\' as C_EVENT, ' ?}
   +' B_PORT.KEYREF KEY, B_PORT.REQUIRED REQ, B_TYPE.TYPE TYP, B_PORT.REFERENCE PORTREF '
   +' from B_PORT '
   +' left join B_TYPE using(B_PORT.B_TYPE,B_TYPE.REFERENCE) '
   +' where (B_PORT.B_PREL in (select distinct REF from :_a where not REF is null order by REF)) '
      +' or (B_PORT.B_ELE in (select distinct ELEREF from :_a where not ELEREF is null order by ELEREF)) '
   +' order by ELE, ELEMREF, KIND, SYMBOL, NAZWA, PORTREF ';
_allports:=sql(_sql,_tu);

::pobranie akronimow portow standardowych sygnalow
_sql:='select B_SIGNAL, PARAMETR, TYPE, B_SIGTYP.REFERENCE SPREF from B_SIGTYP '
   +' join B_TYPE '
   +' where B_SIGNAL in (select distinct SIGREF from :_a where not SIGREF is null order by SIGREF) '
   +' order by SPREF ';
_sigports:=sql(_sql,_tu);

::pobranie powiazan portow sygnalu z parametrami wejsciowymi
_sql:='select B_PREL, B_PORT, B_SIGTYP from B_SIGPRT '
   +' where B_PORT in (select distinct PORTREF from :_a order by 1) '
   +' order by 1,2,3 ';
_powport:=sql(_sql,_allports);

::tabela wynikowa
_ports:=tab_tmp(4
   ,'B_PREL','STRING[16]','B_PREL'
   ,'B_PORT','STRING[16]','B_PORT'
   ,'KIND','STRING[4]','Kind'
   ,'SYMBOL','STRING[31]','Symbol'
   ,'NAZWA','STRING[250]','Nazwa'
   ,'KEY','STRING[1]','Kluczowy'
   ,'REQ','STRING[1]','Wymagany'
   ,'TYP','STRING[10]','Typ'
   ,'C_EVENT','STRING[1]','Kontroluj'
   ,'VALUE','STRING[255]','Wartość'
   ,'FORMULA','STRING[255]','Formula'
   ,'SIGPOW','STRING[31]','Powiazany z'
   );
::przepisywanie portow i uzupelnianie wartosci pol B_PREL
{? _tu.first() & _allports.first()
||
   {!
   |?
      _allports.prefix(_tu.ELEREF,);
      {? _allports.first()
      || {!
         |?
            _ports.blank();
            _ports.B_PREL:=_tu.REF;
            _ports.B_PORT:=_allports.PORTREF;
            _ports.KIND:=_allports.KIND;
            _ports.SYMBOL:=_allports.SYMBOL;
            _ports.NAZWA:=_allports.NAZWA;
            _ports.KEY:=_allports.KEY;
            _ports.REQ:=_allports.REQ;
            _ports.TYP:=_allports.TYP;
            _ports.C_EVENT:=_allports.C_EVENT;
            {? _powport.find_key(_ports.B_PREL,_ports.B_PORT) & _sigports.find_key(_powport.B_SIGTYP,)
            || _ports.SIGPOW:=_sigports.PARAMETR
            ?};
            _ports.add();
            _allports.next()
         !}
      ?};
      _allports.prefix('',_tu.REF,);
      {? _allports.first()
      || {!
         |?
            _ports.blank();
            _ports.B_PREL:=_tu.REF;
            _ports.B_PORT:=_allports.PORTREF;
            _ports.KIND:=_allports.KIND;
            _ports.SYMBOL:=_allports.SYMBOL;
            _ports.NAZWA:=_allports.NAZWA;
            _ports.KEY:=_allports.KEY;
            _ports.REQ:=_allports.REQ;
            _ports.TYP:=_allports.TYP;
            _ports.C_EVENT:=_allports.C_EVENT;
            {? _powport.find_key(_ports.B_PREL,_ports.B_PORT) & _sigports.find_key(_powport.B_SIGTYP,)
            || _ports.SIGPOW:=_sigports.PARAMETR
            ?};
            _ports.add();
            _allports.next()
         !}
      ?};
      _tu.next()
   !}
?};
obj_del(_allports); obj_del(_tu); obj_del(_sigports); obj_del(_powport);
::pobranie wartosci nadanych portom
{? _ports.first()
||
   Cntx.psh(B_VALPRT,B_PREL,B_PORT);
   B_VALPRT.index('UNIK'); B_VALPRT.prefix();
   B_PREL.prefix(); B_PORT.prefix();
   {!
   |?
      {? B_PREL.seek(_ports.B_PREL) & B_PORT.seek(_ports.B_PORT) & B_VALPRT.find_key(B_PREL.ref(),B_PORT.ref())
      ||
         _ports.FORMULA:=B_VALPRT.FORMULA;
         _val:=($_ports.FORMULA)();
         _ports.VALUE:={? type_of(_val)=type_of('') || _val
                       |? type_of(_val)=type_of(null()) || $_val
                       |? type_of(_val)=type_of(0) || $_val
                       || ''
                       ?};
         {? (_ports.VALUE='') & (B_VALPRT.VALUE<>'') || _ports.VALUE:=B_VALPRT.VALUE ?};
         {? (_ports.VALUE='') & (B_VALPRT.BI_BLOB().LIST<>'') || _ports.VALUE:=B_VALPRT.VALUE ?};
         _ports.put()
      ?};
      _ports.next()
   !};
   Cntx.pop(B_VALPRT,B_PREL,B_PORT)
?};
_ports.index(_ports.ndx_tmp(,,'KIND',,,'B_PREL',,,'SYMBOL',,,'TYP',,,'B_PORT',,));
_ports


\load_poconn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Załadowanie powiacan parametrow miedzy elementami procesu
::   WE: _a - tabela portow
::       _b - tabela elementow
::       _c - tabela pierwszych czynnosci
::   WY: tabela z powiazaniami
::----------------------------------------------------------------------------------------------------------------------
_ports:=_a;
_elem:=_b;
_actsta:=_c;

_sql:='select distinct B_PORT from :_a where KIND=\'IN\' order by B_PORT';
_list:=sql(_sql,_ports);
_sql:='select B_CONN, B_POCONN.FROM PORT_SRC, B_POCONN.TO PORT_DST, PREL_SRC, PREL_DST, '
   +' SRC.SYMBOL PRSRCSYM, DST.SYMBOL PRDSTSYM, SRC.NAZWA PRSRCNAZ, DST.NAZWA PRDSTNAZ, '
   +' ESRC.NAZWA ESRCN, EDST.NAZWA EDSTN, 0 as USED '
   +' from B_POCONN '
   +' join :_b as SRC using(B_POCONN.FROM,SRC.B_PORT) '
   +' join :_b as DST using(B_POCONN.TO,DST.B_PORT) '
   +' join :_c as ESRC using(B_POCONN.PREL_SRC,ESRC.REF) '
   +' join :_c as EDST using(B_POCONN.PREL_DST,EDST.REF) '
   +' where (B_POCONN.TO in (select B_PORT from :_a)) and (B_POCONN.PREL_SRC not in (select EVE from :_d order by EVE)) '
   +' order by PREL_DST, PORT_DST, B_CONN';
_wyn:=sql(_sql,_list,_ports,_elem,_actsta);
obj_del(_list);
_wyn


\load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Ladowanie danych do obiektu
::   WE: _a - obiekt
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_obj.BPREL:=exec('load_elem','qporproc',_obj.BPROC.REF,_obj.BPROC.FREF,_obj.CPROC.FREF);
_obj.CPREL:=exec('load_elem','qporproc',_obj.CPROC.REF,_obj.CPROC.FREF,_obj.BPROC.FREF);
_obj.IREFBP:=_obj.BPREL.ndx_tmp(,,'REF',,);
_obj.IREFCP:=_obj.CPREL.ndx_tmp(,,'REF',,);
_obj.BEDI:=exec('load_edi','qporproc',_obj.BPREL);
_obj.CEDI:=exec('load_edi','qporproc',_obj.CPREL);
_obj.BMSG:=exec('load_msg','qporproc',_obj.BPREL,_obj.IREFBP);
_obj.CMSG:=exec('load_msg','qporproc',_obj.CPREL,_obj.IREFCP);
_obj.BACTRROP:=exec('load_actrop','qporproc',_obj.BPREL);
_obj.CACTRROP:=exec('load_actrop','qporproc',_obj.CPREL);
_obj.BACTSTA:=exec('load_actsta','qporproc',_obj.BPREL);
_obj.CACTSTA:=exec('load_actsta','qporproc',_obj.CPREL);
_obj.BCONN:=exec('load_flow','qporproc',_obj.BPROC.REF,_obj.BPREL);
_obj.CCONN:=exec('load_flow','qporproc',_obj.CPROC.REF,_obj.CPREL);
_obj.BCHOICE:=exec('load_gate_cond','qporproc',_obj.BCONN);
_obj.CCHOICE:=exec('load_gate_cond','qporproc',_obj.CCONN);
_obj.BPORTS:=exec('load_ports','qporproc',_obj.BPREL);
_obj.CPORTS:=exec('load_ports','qporproc',_obj.CPREL);
_obj.BPOCONN:=exec('load_poconn','qporproc',_obj.BPORTS,_obj.BPREL,_obj.BACTSTA);
_obj.CPOCONN:=exec('load_poconn','qporproc',_obj.CPORTS,_obj.CPREL,_obj.CACTSTA);
~~


::======================================================================================================================
:: Funkcje uniwersalne
::======================================================================================================================


\mk_bridge
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Utworzenie powiązania pomiędzy biezacymi rekortami tabel
::   WE: _a, _b - tabele z polami BRIDGE
::       [_c] - [1] - znak przy refie 1 dodatni -1 ujemny (ref niejednoznaczny)
::----------------------------------------------------------------------------------------------------------------------
{? (_<3) | (_c=~~) | (type_of(_c)<>type_of(0)) || _c:=1 ?};
_c:={? _c>0 || 1 || -1 ?};
::BRIDGE - numer galezi na drzewie i informacja czy to powiązanie jest jednoznaczne (>0), BRREF - ref do B_PREL
_a.cntx_psh(); _b.cntx_psh(); _a.prefix(); _b.prefix();
_a.get(); _a.BRIDGE:=_c*(#_b.ref()); _a.BRREF:=_b.REF; _a.put();
_b.get(); _b.BRIDGE:=_c*(#_a.ref()); _b.BRREF:=_a.REF; _b.put();
_a.cntx_pop(); _b.cntx_pop();
~~


\set_used
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Ustawienie wartosci USED dla podanych elementow
::   WE: _a - element w B
::   WE: _b - element w C
::----------------------------------------------------------------------------------------------------------------------
_t1:={? (_>0) & (type_of(_a)>0) || _a || _t1:=~~ ?};
_t2:={? (_>1) & (type_of(_b)>0) || _b || _t2:=~~ ?};

{? type_of(_t1)>0 || _t1.cntx_psh(); _t1.prefix(); _t1.get(); _t1.USED:=1; _t1.put(); _t1.cntx_pop() ?};
{? type_of(_t2)>0 || _t2.cntx_psh(); _t2.prefix(); _t2.get(); _t2.USED:=1; _t2.put(); _t2.cntx_pop() ?};
~~


\comp_elem
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie zgrubne 2 elementow wg biezacych rekordow w tabelach
::   WE: _a - tabela elementow procesu bazowego
::       _b - tabela elementow procesu porownywanego
::   WY: 1 - podpbne, 0 - niepodobne, -1 - wczesniej wyznaczono odpowiednik przynajmniej dla jednego
::----------------------------------------------------------------------------------------------------------------------
_t1:=_a;
_t2:=_b;

_odp:=0;
_t1.cntx_psh(); _t2.cntx_psh();
_t1.prefix(); _t2.prefix();
_t1.get(); _t2.get();
{? _t1.BRREF='' & _t2.BRREF=''
||
:: porownanie czynnosci
   {? (_t1.RODZAJ='B_ACTION') & (_t1.RODZAJ=_t2.RODZAJ)
   || {? (_t1.STANDARD='T') & (_t2.STANDARD='T')
      || {? _t1.STANDARD=_t2.STANDARD || _odp:=_t1.SYMBOL=_t2.SYMBOL ?}
      || {? (_t1.STANDARD='N') & (_t2.STANDARD='N')
         || {? _t1.TYP='E'
            || {? _t1.TYP=_t2.TYP
               || _odp:=(_t1.ISTREF=_t2.ISTREF) & (_t1.ISTT=_t2.ISTT)
               ?}
            || {? _t1.LOOP='N'
               || {? _t1.LOOP=_t2.LOOP || _odp:=(_t1.FMANOUT=_t2.FMANOUT) & (_t1.FMANMAIN=_t2.FMANMAIN) ?}
               || _odp:=_t1.WARTOSC=_t2.WARTOSC
               ?}
            ?}
         ?}
      ?}
:: porownanie zdarzen
   |? (_t1.RODZAJ='B_EVENT') & (_t1.EVKATEG=_t2.EVKATEG) & (_t1.EVKIND=_t2.EVKIND)
   || {? _t1.EVKIND='sygnał' || _odp:=_t1.SYGNAL=_t2.SYGNAL
      |? _t1.EVKIND='warunkowe' || _odp:=_t1.FCOND=_t2.FCOND
      |? _t1.EVKIND='czasowe' || _odp:=_t1.EVTYPE=_t2.EVTYPE
      |? _t1.EVKIND='komunikat' || _odp:=(_t1.NAZWA=_t2.NAZWA) & (_t1.MSGTR=_t2.MSGTR)
      || _odp:=_t1.EVTYPE=_t2.EVTYPE
      ?}
:: porownanie bram
   |? _t1.RODZAJ='B_GATE'
   || {? _t1.GATEKIND=_t2.GATEKIND
      || {? _t1.GATETYPE='COMPLEX' || _odp:=_t1.GATETYPE=_t2.GATETYPE
         |? _t1.GATETYPE='XOR_EVENT' || _odp:=_t1.GATETYPE=_t2.GATETYPE
         |? _t1.GATETYPE='EVENT' || _odp:=_t1.GATETYPE=_t2.GATETYPE
         || _odp:=1
         ?}
      ?}
   ?}
|| _odp:=-1
?};
_t1.cntx_pop(); _t2.cntx_pop();
_odp


\czy_join_oxa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Czy wskazany element jest brama laczoca zwykla
::   WE: _a - tabela elementow
::   WY: 'OR','XOR','AND' gdy tak, '' gdy nie
::----------------------------------------------------------------------------------------------------------------------
_t1:=_a;

_odp:='';
{? (_t1.RODZAJ='B_GATE') & (_t1.GATEKIND='>') & (_t1.GATETYPE<>'COMPLEX') & (_t1.GATETYPE<>'XOR_EVENT')
|| _odp:=_t1.GATETYPE
?};
_odp


\next_el
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Szuka REF nastepnego elementu wg pierwszego znalezionego lacznika wychdzacego z elementu o REF=_a
::   WE: _a - BPREL.REF elementu poczatkowego
::       _b - tabela lacznikow
::   WY: BPREL.REF nastepnego elementu lub ''
::----------------------------------------------------------------------------------------------------------------------
::na _fl musi byc indeks z pierwszym pole OD
_elref:=_a;
_fl:=_b;

_odp:='';
_fl.cntx_psh();
_fl.prefix(_elref,);
{? _fl.first() || _odp:=_fl.DO ?};
_fl.cntx_pop();
_odp


::----------------------------------------------------------------------------------------------------------------------
:: tworzenie tekstów dla pól na drzewie
::----------------------------------------------------------------------------------------------------------------------


\symnaz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Tekst do tabeli wynikowej z warunkowym drukowaniem nazwy
::   WE: _tt - tabela
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;
_tt.SYMBOL+' '+{? _tt.NAZWA<>_tt.SYMBOL || _tt.NAZWA || '' ?}


\action_st_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Tekst do tabeli wynikowej na podstawie danych podanego rekordu tabeli
::   WE: _tt - tabela
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;
exec('symnaz','qporproc',_tt)+' {'+_tt.ROLA+'} '+_tt.TRYB


\action_un_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Tekst do tabeli wynikowej na podstawie danych podanego rekordu tabeli
::   WE: _tt - tabela
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;
_tt.NAZWA+' OUT'+{? _tt.OUTTYP<>'' || ' {'+_tt.OUTTYP+'}' || '' ?}+':'+_tt.FMANOUT+' MAIN:'+_tt.FMANMAIN+' '+_tt.TRYB
+' {'+_tt.ROLA+'}'


\action_lo_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Tekst do tabeli wynikowej na podstawie danych podanego rekordu tabeli
::   WE: _tt - tabela
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;
_tt.NAZWA+' PARAM:'+_tt.WARTOSC+' {'+_tt.ROLA+'} '+_tt.TRYB


\action_ed_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Tekst do tabeli wynikowej na podstawie danych podanego rekordu tabeli
::   WE: _tt - tabela
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;
_tt.NAZWA+' TYP:'+_tt.ISTT+' SYSTEM: '+_tt.ISTSY+' KOD: '+_tt.ISTK+' RODZAJ: '+_tt.ISTR+' WERSJA: '+_tt.ISTVE
   +' {'+_tt.ROLA+'} '+_tt.TRYB


\event_w_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Tekst do tabeli wynikowej na podstawie danych podanego rekordu tabeli
::   WE: _tt - tabela
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;
exec('symnaz','qporproc',_tt)+': WARUNEK:'+_tt.FCOND+' '+{? _tt.OUTTYP<>'' || '{'+_tt.OUTTYP+'}' || '' ?}
+' KOLEJKA:'+_tt.KOLEJKA+' {'+_tt.ROLA+'}'


\event_s_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Tekst do tabeli wynikowej na podstawie danych podanego rekordu tabeli
::   WE: _tt - tabela
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;
exec('symnaz','qporproc',_tt)+': SYGNAŁ:'+_tt.SYGNAL+' ('+_tt.EVTYPE+') '+' {'+_tt.ROLA+'}'


\event_no_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Tekst do tabeli wynikowej na podstawie danych podanego rekordu tabeli
::   WE: _tt - tabela
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;
exec('symnaz','qporproc',_tt)+': '+{? _tt.EVKATEG='przechwytujące' || ' DZIEDZINA:'+_tt.DOMAIN || '' ?}
+' {'+_tt.ROLA+'}'


\event_ti_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Tekst do tabeli wynikowej na podstawie danych podanego rekordu tabeli
::   WE: _tt - tabela
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;
exec('symnaz','qporproc',_tt)+' ('+_tt.EVTYPE+') '+' {'+_tt.ROLA+'}'


\event_ko_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Tekst do tabeli wynikowej na podstawie danych podanego rekordu tabeli
::   WE: _tt - tabela
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;
exec('symnaz','qporproc',_tt)+' ('+_tt.EVTYPE+') '+' {'+_tt.ROLA+'}'


\gate_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Tekst do tabeli wynikowej na podstawie danych podanego rekordu tabeli
::   WE: _tt - tabela
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;
exec('symnaz','qporproc',_tt)+' {'+_tt.ROLA+'}'


\event_xor_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Tekst do tabeli wynikowej na podstawie danych podanego rekordu tabeli
::   WE: _tt - tabela
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;
exec('symnaz','qporproc',_tt)+' {'+_tt.ROLA+'}'


\complex_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Tekst do tabeli wynikowej na podstawie danych podanego rekordu tabeli
::   WE: _tt - tabela
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;
exec('symnaz','qporproc',_tt)+' WARUNEK: '+_tt.FMANMAIN+' (KASOWAĆ: '+_tt.G_CANCEL+') '+' {'+_tt.ROLA+'}'


\write_elem_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapisanie opisu dowolnego elementu wskazanego w parametrze
::   WE: _a - tabela, ktorej beizacy rekord opisac
::   WY: tekst opisu
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;

{? _tt.RODZAJ='B_ACTION'
|| {? _tt.STANDARD='T' || exec('action_st_txt','qporproc',_tt)
   |? _tt.LOOP='N' || {? _tt.TYP='E' || exec('action_ed_txt','qporproc',_tt) || exec('action_un_txt','qporproc',_tt) ?}
   |? _tt.LOOP='T'  || exec('action_lo_txt','qporproc',_tt)
   ?}
|? _tt.RODZAJ='B_EVENT'
|| {? _tt.EVKATEG='przechwytujące'
   || {? _tt.EVKIND='warunkowe' || exec('event_w_txt','qporproc',_tt)
      |? _tt.EVKIND='sygnał' || exec('event_s_txt','qporproc',_tt)
      |? _tt.EVKIND='nieokreślone' || exec('event_no_txt','qporproc',_tt)
      |? _tt.EVKIND='czasowe' || exec('event_ti_txt','qporproc',_tt)
      ?}
   |? _tt.EVKATEG='rzucające'
   ||
      {? _tt.EVKIND='komunikat' || exec('event_ko_txt','qporproc',_tt)
      |? _tt.EVKIND='sygnał' || exec('event_s_txt','qporproc',_tt)
      |? _tt.EVKIND='nieokreślone' || exec('event_no_txt','qporproc',_tt)
      ?}
   ?}
|? _tt.RODZAJ='B_GATE'
|| {? _tt.GATETYPE='XOR_EVENT' ||  exec('event_xor_txt','qporproc',_tt)
   |? _tt.GATETYPE='EVENT' || exec('event_xor_txt','qporproc',_tt)
   |? _tt.GATETYPE='COMPLEX' || exec('complex_txt','qporproc',_tt)
   || exec('gate_txt','qporproc',_tt)
   ?}
?}


\write_choice_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapisanie opisu dowolnego warunku na bramie podanego w polaczeniu w biezacym rekordzie _a
::   WE: _a - tabela, ktorej beizacy rekord opisac
::   WY: tekst opisu
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;

_tt.WARNAME+' KOLEJNOŚĆ: '+$_tt.WARORDER+' '+
{? _tt.KIND='F'
|| 'FORMUŁA: '+_tt.FORMULA
|? _tt.KIND='S'
|| 'PARAMETR: '+_tt.WARPARAM+' '+_tt.OPERATOR+' '+_tt.VALUE+{? _tt.CASE_SEN='T'  || ' (istotna wielkość znaków) ' || '' ?}
|? _tt.KIND='N'
|| 'PARAMETR: '+_tt.WARPARAM+' '+_tt.OPERATOR+' '+_tt.VALUE
|? _tt.KIND='J'
|| 'PARAMETR: '+_tt.WARPARAM+' '+_tt.OPERATOR
|| '???'
?}


::======================================================================================================================
:: ladowanie dodatkowych tabel do wspomagania funkcji porownania
::======================================================================================================================


\preppn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Utworzenie tabeli informacji i najblizszym otoczeniu elementu
::   WE: _a - tabela elementow
::       _b - tabela lacznikow
::   WY: tabela tymczasowa z informacjami o otoczeniu
::----------------------------------------------------------------------------------------------------------------------
_elem:=_a;
_fl:=_b;

_fl.cntx_psh();
_od:=_fl.ndx_tmp(,,'OD',,,'DO',,);
_do:=_fl.ndx_tmp(,,'DO',,,'OD',,);
_elem.cntx_psh(); _elem.index(_elem.ndx_tmp(,,'REF',,));
_tab:=tab_tmp(7
   ,'B_PREL','STRING[16]','$B_PREL.ref()'
   ,'PN','STRING[1]','Poprzednik/nastepnik'
   ,'RODZAJ','STRING[10]','Rodzaj'
   ,'CECHA1','STRING[100]','Cecha 1'
   ,'CECHA2','STRING[100]','Cecha 2'
   ,'CECHA3','STRING[100]','Cecha 3'
   ,'CECHA4','STRING[20]','Cecha 4'
   ,'ELREF','STRING[16]','$ref sasiada'
   ,'FLREF','STRING[16]','$ref lacznika'
   ,'USED','INTEGER','Czy już wykorzystany'
   );
_write:="
   _prel:=_a; _tab:=_b; _elem:=_c; _pn:=_d; _fl:=_e;
   _tab.blank();
   _tab.B_PREL:=_prel;
   _tab.PN:=_pn;
   _tab.RODZAJ:=_elem.RODZAJ;
   _tab.ELREF:=_elem.REF;
   _tab.FLREF:=_fl;
:: czynnosc
   {? _elem.RODZAJ='B_ACTION'
   || {? _elem.STANDARD='T'
      || _tab.CECHA1:=_elem.SYMBOL
      |? _elem.TYP='E'
      || _tab.CECHA1:=_elem.ISTREF; _tab.CECHA2:=_elem.ISTT
      || {? _elem.LOOP='N'
         || _tab.CECHA1:=_elem.FMANOUT; _tab.CECHA2:=_elem.FMANMAIN
         || _tab.CECHA1:=_elem.WARTOSC
         ?}
      ?};
      _tab.CECHA3:=_elem.NAZWA
:: zdarzenie
   |? _elem.RODZAJ='B_EVENT'
   || _tab.CECHA1:=_elem.EVKIND;
      _tab.CECHA2:=_elem.EVKATEG;
      _tab.CECHA4:=_elem.EVTYPE;
      {? _elem.EVKIND='sygnał' || _tab.CECHA3:=_elem.SYGNAL
      |? _elem.EVKIND='warunkowe' || _tab.CECHA3:=_elem.FCOND
      |? _elem.EVKIND='czasowe' || _tab.CECHA3:=_elem.EVTYPE
      |? _elem.EVKIND='komunikat' || _tab.CECHA3:=_elem.NAZWA
      || {? _elem.EVTYPE='startowe' || _tab.CECHA3:=_elem.DOMAIN ?}
      ?}
:: brama
   || _tab.CECHA1:=_elem.GATEKIND;
      _tab.CECHA2:=_elem.GATETYPE;
      {? _elem.GATETYPE='COMPLEX' || _tab.CECHA3:=_elem.FMANMAIN ?};
      _tab.CECHA4:=_elem.NAZWA
   ?};
   _tab.add()
   ";
_elem.prefix();
{? _elem.first()
|| {!
   |?
      _prel:=_elem.REF;
      _elem.cntx_psh(); _elem.prefix();
      _fl.index(_do); _fl.prefix(_prel);
      {? _fl.first() || {! |? {? _elem.find_key(_fl.OD,) || _write(_prel,_tab,_elem,'P',_fl.REF) ?}; _fl.next() !} ?};
      _fl.index(_od); _fl.prefix(_prel);
      {? _fl.first() || {! |? {? _elem.find_key(_fl.DO,) || _write(_prel,_tab,_elem,'N',_fl.REF) ?}; _fl.next() !} ?};
      _elem.cntx_pop();
      _elem.next()
   !}
?};
_elem.cntx_pop();
_fl.cntx_pop();
_tab


\crewynppn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Utworzenie zapisow ze współczynnikami podobienstwa otoczenia dla par element,element
::   WE: _a - objekt danych
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_obj.OTOCZ:=tab_tmp(2
   ,'BELEM','STRING[16]','BPREL.REF'
   ,'CELEM','STRING[16]','CPREL.REF'
   ,'WSPOLCZ','REAL','Współczynnik podobieństwa otoczenia'
   ,'WSPOLCZP','REAL','Współczynnik podobieństwa poprzednikow'
   ,'WSPOLCZN','REAL','Współczynnik podobieństwa nastepnikow'
   );
_obj.IOTOCZ:=_obj.OTOCZ.index('?');
_t1:=_obj.BPREL; _t2:=_obj.CPREL;
_t1.cntx_psh(); _t2.cntx_psh();
_t1.prefix(); _t2.prefix();
_ot1:=_obj.BOTOCZ; _ot2:=_obj.COTOCZ;
_ot1.cntx_psh(); _ot2.cntx_psh();
_ind02:=_ot2.index('?');
_ind12:=_ot2.ndx_tmp(,,'USED',,,'B_PREL',,,'PN',,,'RODZAJ',,,'CECHA1',,,'CECHA2',,,'CECHA3',,,'CECHA4',,);
{? _t1.first()
|| {!
   |?
      {? _t2.first()
      || {!
         |?
::          analiza otoczenia ma sens tylko wtedy, gdy porownywane elementy sa podobne
            {? exec('comp_elem','qporproc',_t1,_t2)
            || _ot2.index(_ind02);
               _ot1.prefix(_t1.REF,); _ot2.prefix(_t2.REF,);
               _suma:=_ot1.size()+_ot2.size();
               _obj.OTOCZ.blank();
               _obj.OTOCZ.BELEM:=_t1.REF; _obj.OTOCZ.CELEM:=_t2.REF;
               {? _ot1.first()
               || _ot2.index(_ind12);
                  {!
                  |?
                     _ot2.prefix(0,_t2.REF,_ot1.PN,_ot1.RODZAJ,_ot1.CECHA1,_ot1.CECHA2,_ot1.CECHA3,_ot1.CECHA4,);
                     {? _ot2.first()
                     || _obj.OTOCZ.WSPOLCZ+=2; {? _ot1.PN='P' || _obj.OTOCZ.WSPOLCZP+=2 || _obj.OTOCZ.WSPOLCZN+=2 ?};
                        _ot2.prefix(); _ot2.USED:=1; _ot2.put()
                     ?};
                     _ot1.next()
                  !}
               ?};
               {? (_suma>0) & (_obj.OTOCZ.WSPOLCZ>0)
               || _obj.OTOCZ.WSPOLCZ/=_suma; _obj.OTOCZ.WSPOLCZP/=_suma; _obj.OTOCZ.WSPOLCZN/=_suma;
                  _obj.OTOCZ.add()
               ?};
::             zerowanie znacznika uzycia
               _ot2.index(_ind12); _ot2.prefix(1);
               {! |? _ot2.first() |! _ot2.cntx_psh(); _ot2.prefix(); _ot2.USED:=0; _ot2.put(); _ot2.cntx_pop() !}
            ?};
            _t2.next()
         !}
      ?};
      _t1.next()
   !}
?};
_ot2.ndx_drop(_ind12);
_ot1.cntx_pop(); _ot2.cntx_pop();
_t1.cntx_pop(); _t2.cntx_pop();
~~


\prepare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Przygotowanie dnych pomocniczych
::   WE: _a - obj
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_obj.BOTOCZ:=exec('preppn','qporproc',_obj.BPREL,_obj.BCONN); _obj.IBOTOCZ:=_obj.BOTOCZ.index('?');
_obj.COTOCZ:=exec('preppn','qporproc',_obj.CPREL,_obj.CCONN); _obj.ICOTOCZ:=_obj.COTOCZ.index('?');
exec('crewynppn','qporproc',_obj);
~~


\mk_trek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Utworzenie sciezki warunkow dla kolejnych elementow
::   WE: _a - xGTOUTEL
::       _b - xCONN
::       _c - xPREL
::----------------------------------------------------------------------------------------------------------------------
_GTOUTEL:=_a;
_CONN:=_b;
_PREL:=_c;

::tabela z rekordami juz wykorzystanymi - nie mozna ich wykorzystac po raz drugi
_tab:=tab_tmp(1,'REF','STRING[16]','BGTOUTEL.ref()');
::przeglada tabele warunkow pod jakimi wykonywane sa poszczegolne elementy po bramie rozdzielajacej
::kopiuje liste warunkow pod jakimi element jest wykonywany do nastepnego elementu w kazdej sciezce wychodzacej
::pod warunkiem ze taki warunek nie znajduje sie juz na liscie danego elementu
::petla chodzi tak dlugo, dopoki w iteracji zapisany bedzie chociaz jeden nowy rekord do _GTOUTEL
_GTOUTEL.prefix();
_go:=1;
{!
|? _go
|! _go:=0;
   {? _GTOUTEL.first()
   || {!
      |? {? ~_tab.find_key($_GTOUTEL.ref())
         || _tab.REF:=$_GTOUTEL.ref(); _tab.add();
            _CONN.prefix(_GTOUTEL.ELEMREF);
            {? _CONN.first()
            || {!
               |? {? _PREL.find_key(_CONN.DO,)
                  || _GTOUTEL.cntx_psh();
                     {? ~_GTOUTEL.find_key(_CONN.DO,_GTOUTEL.WAR,)
                     || _GTOUTEL.ELEMREF:=_PREL.REF;
                        _go+=_GTOUTEL.add()
                     ?};
                     _GTOUTEL.cntx_pop()
                  ?};
                  _CONN.next()
               !}
            ?}
         ?};
         _GTOUTEL.next()
      !}
   ?}
!};
&_tab;
~~


\crewyntrek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Przygotowanie tabeli do szybkiego porownania zgodnosci warunkow
::   WE: _a - objekt danych
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_obj.GTOUTEL:=tab_tmp(2
   ,'BELEM','STRING[16]','BPREL.REF'
   ,'CELEM','STRING[16]','CPREL.REF'
   ,'WSPOLCZ','REAL','Współczynnik podobieństwa warunkow'
   );
_obj.IGTOUTEL:=_obj.GTOUTEL.index('?');
_t1:=_obj.BPREL; _t2:=_obj.CPREL;
_t1.cntx_psh(); _t2.cntx_psh();
_t1.index(_obj.IREFBP); _t2.index(_obj.IREFCP);
_t1.prefix(); _t2.prefix();
_sql:='select ELEMREF, WAR from :_a order by 1,2';
_war1:=sql(_sql,_obj.BGTOUTEL); _war2:=sql(_sql,_obj.CGTOUTEL);
_sql:='select distinct ELEMREF from :_a order by 1';
_refs1:=sql(_sql,_war1); _refs2:=sql(_sql,_war2);
{? _refs1.first()
|| {!
   |?
      {? _refs2.first()
      || {!
         |?
::          analiza ma sens tylko wtedy, gdy porownywane elementy sa podobne
            {? _t1.find_key(_refs1.ELEMREF) & _t2.find_key(_refs2.ELEMREF) & exec('comp_elem','qporproc',_t1,_t2)
            || _war1.prefix(_t1.REF,); _war2.prefix(_t2.REF,);
               _suma:=_war1.size()+_war2.size();
               _obj.GTOUTEL.blank();
               _obj.GTOUTEL.BELEM:=_t1.REF; _obj.GTOUTEL.CELEM:=_t2.REF;
               {? _war1.first()
               ||
                  {!
                  |?
                     _war2.prefix(_t2.REF,_war1.WAR,);
                     {? _war2.first() || _obj.GTOUTEL.WSPOLCZ+=2; _war2.del() ?};
                     _war1.del()
                  !}
               ?};
               {? (_suma>0) & (_obj.GTOUTEL.WSPOLCZ>0) || _obj.GTOUTEL.WSPOLCZ/=_suma; _obj.GTOUTEL.add() ?}
            ?};
            _refs2.next()
         !}
      ?};
      _refs1.del()
   !}
?};
&_war1; &_war2; &_refs1; &_refs2;
_t1.cntx_pop(); _t2.cntx_pop();
~~


\prepare_trek_ch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Przygotowanie dnych pomocniczych po funkcji porownania warunkow
::   WE: _a - obj
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_obj.BPREL.index(_obj.IREFBP); _obj.BPREL.prefix();
_obj.CPREL.index(_obj.IREFCP); _obj.CPREL.prefix();
exec('mk_trek','qporproc',_obj.BGTOUTEL,_obj.BCONN,_obj.BPREL);
exec('mk_trek','qporproc',_obj.CGTOUTEL,_obj.CCONN,_obj.CPREL);
exec('crewyntrek','qporproc',_obj);
~~


::======================================================================================================================
:: Budowa podstawowej struktury drzewa porownan elementow
::======================================================================================================================


\tree_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Budowa drzewa dla akcji
::   WE: _a - obiekt
::       _b - konar drzewa, do którego należy łączyć komunikaty
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_root:=_b;

_t1:=_obj.BPREL; _t2:=_obj.CPREL;
_t1ind0:=_t1.index('?'); _t2ind0:=_t2.index('?');
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'STANDARD',,,'SYMBOL',,,'NAZWA',,,'ROLA',,,'TRYB',,);
_ind2:=_t2.ndx_tmp(,,'RODZAJ',,,'STANDARD',,,'SYMBOL',,,'NAZWA',,,'ROLA',,,'TRYB',,);
_t1.index(_ind1);  _t2.index(_ind2);
_t1.prefix('B_ACTION','T'); _t2.prefix('B_ACTION','T');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.ACTSTD:=_obj.add2rap(_root,'Standardowych',$_ilb,$_ilc);
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'STANDARD',,,'LOOP',,,'FMANOUT',,,'FMANMAIN',,,'NAZWA',,,'TRYB',,,'ROLA',,);
_ind2:=_t2.ndx_tmp(,,'RODZAJ',,,'STANDARD',,,'LOOP',,,'FMANOUT',,,'FMANMAIN',,,'NAZWA',,,'TRYB',,,'ROLA',,);
_t1.index(_ind1);  _t2.index(_ind2);
_t1.prefix('B_ACTION','N'); _t2.prefix('B_ACTION','N');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.ACTUNI:=_obj.add2rap(_root,'Uniwersalnych',$_ilb,$_ilc);
_t1.prefix('B_ACTION','N','N'); _t2.prefix('B_ACTION','N','N');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.ACTUSUAL:=_obj.add2rap(_obj.ROOTS.ACTUNI,'Zwykłych',$_ilb,$_ilc);
::analiza podobienstwa czynnosci uniwersalnych
_t1.prefix('B_ACTION','N','T'); _t2.prefix('B_ACTION','N','T');
_ilb:=_t1.size(); _ilc:=_t2.size();
::analiza czynnosci typu ZWS_GGR_PKEY
_obj.ROOTS.ACTLOOP:=_obj.add2rap(_obj.ROOTS.ACTUNI,'ZWS_GGR_PKEY',$_ilb,$_ilc);
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);
::analiza czynnosci ZWS_EDI_UNIW
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'STANDARD',,,'TYP',,,'NAZWA',,,'TRYB',,,'ROLA',,);
_ind2:=_t2.ndx_tmp(,,'RODZAJ',,,'STANDARD',,,'TYP',,,'NAZWA',,,'TRYB',,,'ROLA',,);
_t1.index(_ind1);  _t2.index(_ind2);
_t1.prefix('B_ACTION','N','E'); _t2.prefix('B_ACTION','N','E');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.ACTEDI:=_obj.add2rap(_obj.ROOTS.ACTUNI,'ZWS_EDI_UNIW',$_ilb,$_ilc);
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);
_t1.index(_t1ind0); _t2.index(_t2ind0);
~~


\tree_event
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Budowa drzewa dla zdarzeń
::   WE: _a - obiekt
::       _b - konar drzewa, do którego należy łączyć komunikaty
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_root:=_b;

_t1:=_obj.BPREL; _t2:=_obj.CPREL;
_t1ind0:=_t1.index('?'); _t2ind0:=_t2.index('?');
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'SYGNAL',,,'FCOND',,,'NAZWA',,,'EVTYPE',,);
_ind2:=_t2.ndx_tmp(,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'SYGNAL',,,'FCOND',,,'NAZWA',,,'EVTYPE',,);
_t1.index(_ind1);  _t2.index(_ind2);
::przechwytujace
_t1.prefix('B_EVENT','przechwytujące'); _t2.prefix('B_EVENT','przechwytujące');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.EVCAPTUR:=_obj.add2rap(_root,'Przechwytujących',$_ilb,$_ilc);
_t1.prefix('B_EVENT','przechwytujące','warunkowe'); _t2.prefix('B_EVENT','przechwytujące','warunkowe');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.EVCAPWAR:=_obj.add2rap(_obj.ROOTS.EVCAPTUR,'Warunkowe',$_ilb,$_ilc);
_t1.prefix('B_EVENT','przechwytujące','sygnał'); _t2.prefix('B_EVENT','przechwytujące','sygnał');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.EVCAPSYG:=_obj.add2rap(_obj.ROOTS.EVCAPTUR,'Sygnał',$_ilb,$_ilc);
_t1.prefix('B_EVENT','przechwytujące','nieokreślone'); _t2.prefix('B_EVENT','przechwytujące','nieokreślone');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.EVCAPLA:=_obj.add2rap(_obj.ROOTS.EVCAPTUR,'Nieokreślone',$_ilb,$_ilc);
::rzucajaca
_t1.prefix('B_EVENT','rzucające'); _t2.prefix('B_EVENT','rzucające');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.EVTHROW:=_obj.add2rap(_root,'Rzucających',$_ilb,$_ilc);
_t1.prefix('B_EVENT','rzucające','komunikat'); _t2.prefix('B_EVENT','rzucające','komunikat');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.EVTHEM:=_obj.add2rap(_obj.ROOTS.EVTHROW,'Komunikat',$_ilb,$_ilc);
_t1.prefix('B_EVENT','rzucające','sygnał'); _t2.prefix('B_EVENT','rzucające','sygnał');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.EVTHSYG:=_obj.add2rap(_obj.ROOTS.EVTHROW,'Sygnał',$_ilb,$_ilc);
_t1.prefix('B_EVENT','rzucające','nieokreślone'); _t2.prefix('B_EVENT','rzucające','nieokreślone');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.EVTHPLA:=_obj.add2rap(_obj.ROOTS.EVTHROW,'Nieokreślone',$_ilb,$_ilc);
::dla zdarzen czasowych zmiana indeksow
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'EVTYPE',,,'NAZWA',,);
_ind2:=_t2.ndx_tmp(,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'EVTYPE',,,'NAZWA',,);
_t1.index(_ind1);  _t2.index(_ind2);
_t1.prefix('B_EVENT','przechwytujące','czasowe'); _t2.prefix('B_EVENT','przechwytujące','czasowe');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.EVTHTIM:=_obj.add2rap(_obj.ROOTS.EVCAPTUR,'Czasowe',$_ilb,$_ilc);
_t1.prefix('B_EVENT','przechwytujące','czasowe','startowe');
_t2.prefix('B_EVENT','przechwytujące','czasowe','startowe');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.EVTHTIS:=_obj.add2rap(_obj.ROOTS.EVTHTIM,'Startowe',$_ilb,$_ilc);
_t1.prefix('B_EVENT','przechwytujące','czasowe','pośrednie');
_t2.prefix('B_EVENT','przechwytujące','czasowe','pośrednie');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.EVTHTIP:=_obj.add2rap(_obj.ROOTS.EVTHTIM,'Pośrednie',$_ilb,$_ilc);
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);
_t1.index(_t1ind0); _t2.index(_t2ind0);
~~


\tree_gate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Budowa drzewa bram
::   WE: _a - obiekt
::       _b - konar drzewa, do którego należy łączyć komunikaty
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_root:=_b;

_t1:=_obj.BPREL; _t2:=_obj.CPREL;
_t1ind0:=_t1.index('?'); _t2ind0:=_t2.index('?');
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'GATEKIND',,,'GATETYPE',,,'NAZWA',,,'ROLA',,);
_ind2:=_t2.ndx_tmp(,,'RODZAJ',,,'GATEKIND',,,'GATETYPE',,,'NAZWA',,,'ROLA',,);
_t1.index(_ind1);  _t2.index(_ind2);
::starowane zdarzeniami startowymi
_t1.prefix('B_GATE','>','XOR_EVENT'); _t2.prefix('B_GATE','>','XOR_EVENT');
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.GATEVST:=_obj.add2rap(_root,'Sterowanych zdarzeniami startowymi',$_ilb,$_ilc);
_t1.prefix('B_GATE','<','EVENT',); _t2.prefix('B_GATE','<','EVENT',);
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.GATEVPO:=_obj.add2rap(_root,'Sterowane zdarzeniami pośrednimi',$_ilb,$_ilc);
_t1.prefix('B_GATE','>','COMPLEX',); _t2.prefix('B_GATE','>','COMPLEX',);
_ilb:=_t1.size(); _ilc:=_t2.size();
_obj.ROOTS.GATECOMP:=_obj.add2rap(_root,'Złożone',$_ilb,$_ilc);
_t1.prefix('B_GATE','<','AND',); _t2.prefix('B_GATE','<','AND',);
_ilb:=_t1.size(); _ilc:=_t2.size();
_t1.prefix('B_GATE','<','OR',); _t2.prefix('B_GATE','<','OR',);
_ilb+=_t1.size(); _ilc+=_t2.size();
_t1.prefix('B_GATE','<','XOR',); _t2.prefix('B_GATE','<','XOR',);
_ilb+=_t1.size(); _ilc+=_t2.size();
_obj.ROOTS.GATEMULT:=_obj.add2rap(_root,'Rodzielające',$_ilb,$_ilc,);
_t1.prefix('B_GATE','>','AND',); _t2.prefix('B_GATE','>','AND',);
_ilb:=_t1.size(); _ilc:=_t2.size();
_t1.prefix('B_GATE','>','OR',); _t2.prefix('B_GATE','>','OR',);
_ilb+=_t1.size(); _ilc+=_t2.size();
_t1.prefix('B_GATE','>','XOR',); _t2.prefix('B_GATE','>','XOR',);
_ilb+=_t1.size(); _ilc+=_t2.size();
_obj.ROOTS.GATEJOIN:=_obj.add2rap(_root,'Łączące',$_ilb,$_ilc,);
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);
_t1.index(_t1ind0); _t2.index(_t2ind0);
~~


::======================================================================================================================
:: Budowa wykazu elementow i jednoczesne szukanie elementow podobnych
::======================================================================================================================


\port_in_cmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie parametrow wejsciowych elementu
::   WE:
::       _a - rekord z opisem elementu
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - [1] - tryb zapisu, 0 - tryb liczenia
::   WY: liczba roznic
::----------------------------------------------------------------------------------------------------------------------
_wyn:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
_zap:=(_<5) | (_e=~~) | (_e=1);

_rez:=0;
_cports:=tab_tmp(2
   ,'SYM1','STRING[31]','Symb1'
   ,'SYM2','STRING[31]','Symb2'
   ,'NAZ1','STRING[250]','Naz1'
   ,'NAZ2','STRING[250]','Naz2'
   ,'VAL1','STRING[250]','Val1'
   ,'VAL2','STRING[250]','Val2'
   ,'FOR1','STRING[250]','Val1'
   ,'FOR2','STRING[250]','Val2'
   ,'REQ1','STRING[250]','Val1'
   ,'REQ2','STRING[250]','Val2'
   ,'TYP1','STRING[10]','Typ1'
   ,'TYP2','STRING[10]','Typ2'
   ,'KEY1','STRING[1]','Key1'
   ,'KEY2','STRING[1]','Key2'
   ,'REF1','STRING[16]','Ref1'
   ,'REF2','STRING[16]','Ref2'
   ,'CEV1','STRING[1]','Cwv1'
   ,'CEV2','STRING[1]','Cev2'
   ,'NUM1','INTEGER','Liczba powiazan 1'
   ,'NUM2','INTEGER','Liczba powiazan 2'
   ,'SIG1','STRING[31]','Powiązanie portu 1'
   ,'SIG2','STRING[31]','Powiązanie portu 2'
   );
_p1:=_obj.BPORTS; _p2:=_obj.CPORTS;
_c1:=_obj.BPOCONN; _c2:=_obj.CPOCONN;
_p1.prefix('IN',_t1.REF);
{? _p1.first()
|| {!
   |?
      _cports.blank();
      _cports.SYM1:=_p1.SYMBOL;
      _cports.NAZ1:=_p1.NAZWA;
      _cports.VAL1:=_p1.VALUE;
      _cports.FOR1:=_p1.FORMULA;
      _cports.REQ1:=_p1.REQ;
      _cports.TYP1:=_p1.TYP;
      _cports.KEY1:=_p1.KEY;
      _cports.REF1:=_p1.B_PORT;
      _cports.CEV1:=_p1.C_EVENT;
      _cports.SIG1:=_p1.SIGPOW;
      _c1.prefix(_t1.REF,_p1.B_PORT,);
      _cports.NUM1:=_c1.size();
      _cports.add();
      _p1.next()
   !};
:: najpierw poszukanie parametrow odpowiadajacych
   {? _cports.first()
   ||
      {!
      |?
         _p2.prefix('IN',_t2.REF,_cports.SYM1,);
         {? _p2.first()
         || _cports.SYM2:=_p2.SYMBOL;
            _cports.NAZ2:=_p2.NAZWA;
            _cports.VAL2:=_p2.VALUE;
            _cports.TYP2:=_p2.TYP;
            _cports.FOR2:=_p2.FORMULA;
            _cports.REQ2:=_p2.REQ;
            _cports.KEY2:=_p2.KEY;
            _cports.REF2:=_p2.B_PORT;
            _cports.CEV2:=_p2.C_EVENT;
            _cports.SIG2:=_p2.SIGPOW;
            _c2.prefix(_t2.REF,_p2.B_PORT,);
            _cports.NUM2:=_c2.size();
            _cports.put()
         ?};
         _cports.next()
      !}
   ?}
?};
::uzupelnienie o elementy 2, ktore nie wystapily w 1
_p2.prefix('IN',_t2.REF,);
{? _p2.first()
|| _cports.cntx_psh(); _ndx:=_cports.ndx_tmp(,,'REF2',,); _cports.index(_ndx);
   {!
   |? {? _cports.find_key(_p2.B_PORT,)=0
      ||
         _cports.blank();
         _cports.SYM2:=_p2.SYMBOL;
         _cports.NAZ2:=_p2.NAZWA;
         _cports.VAL2:=_p2.VALUE;
         _cports.TYP2:=_p2.TYP;
         _cports.FOR2:=_p2.FORMULA;
         _cports.REQ2:=_p2.REQ;
         _cports.KEY2:=_p2.KEY;
         _cports.REF2:=_p2.B_PORT;
         _cports.CEV2:=_p2.C_EVENT;
         _cports.SIG2:=_p2.SIGPOW;
         _c2.prefix(_t2.REF,_p2.B_PORT,);
         _cports.NUM2:=_c2.size();
         _cports.add()
      ?};
      _p2.next()
   !};
   _cports.cntx_pop()
?};
_p1.prefix(); _p2.prefix();
::sprawdzenie, czy sa roznice w danych portow
_rez:=0;
_cports.prefix();
{? _zap || _konar:=_obj.add2rap(_wyn,'Różnice wartości param. wejściowych','','') ?};
{? _cports.first()
||
   {!
   |?
      {? _cports.SYM1=_cports.SYM2
      ||  {? _zap || _par:=_obj.add2rap(_konar,_cports.SYM1,_cports.NAZ1,_cports.NAZ2) ?};
         {? _cports.TYP1<>_cports.TYP2
         || _rez+=1; {? _zap || _obj.add2rap(_par,'Typ',_cports.TYP1,_cports.TYP2,1) ?}
         ?};
         {? _cports.VAL1<>_cports.VAL2
         || _rez+=1; {? _zap || _obj.add2rap(_par,'Wartość',_cports.VAL1,_cports.VAL2,1) ?}
         ?};
         {? (_t1.RODZAJ='B_ACTION') & (_cports.KEY1<>_cports.KEY2)
         || _rez+=1; {? _zap || _obj.add2rap(_par,'Kluczowy',_cports.KEY1,_cports.KEY2,1) ?}
         ?};
         {? ((#(2+user(10)))>=22) & (_t1.RODZAJ='B_EVENT') & (_t1.EVKIND='warunkowe') & (_cports.CEV1<>_cports.CEV2)
         || _rez+=1; {? _zap || _obj.add2rap(_par,'Śledzony',_cports.CEV1,_cports.CEV2,1) ?}
         ?};
         {? _cports.NUM1<>_cports.NUM2
         || _rez+=1; {? _zap || _obj.add2rap(_par,'Powiązań',$_cports.NUM1,$_cports.NUM2,1) ?}
         ?};
         {? _cports.SIG1<>_cports.SIG2
         || _rez+=1; {? _zap || _obj.add2rap(_par,'Powiązany z',_cports.SIG1,_cports.SIG2,1) ?}
         ?};
         {? _zap & _obj.RAPORT.seek(_par,) & _obj.RAPORT.ROZNIC=0 || _obj.RAPORT.del() ?}
      |? _cports.SYM1<>''
      || _rez+=1; {? _zap || _obj.add2rap(_konar,_cports.SYM1,_cports.NAZ1,,1) ?}
      |? _cports.SYM2<>''
      || _rez+=1; {? _zap || _obj.add2rap(_konar,_cports.SYM2,,_cports.NAZ2,1) ?}
      ?};
      _cports.next()
   !}
?};
obj_del(_cports);
{? _zap & _obj.RAPORT.seek(_konar,) & _obj.RAPORT.ROZNIC=0 || _obj.RAPORT.del() ?};
_rez


\odpowiedniki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Wyszukanie refow wszystkich elementow w podanej tabeli, ktore maja BRIDGE>0
::   WE: _a - tabela z danymi
::   WY: tabela tymczasowa
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;
sql('select REF, BRREF from :_a where BRIDGE>0 order by REF',_tt)


\dal_otocz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Pobranie dalszego otoczenia podanego elementu
::   WE: _a - tabela otoczen
::       _b - rekord elementow z procesu
::       [_c] - czy otoczenie najdalsze (sąsiedzi sąsiadów): [0] -nie, 1 - tak
::   WY: tabela tymczasowa z wykazem elementow dalszego otoczenia
::----------------------------------------------------------------------------------------------------------------------
{? (_<3) | (_c=~~) || _c:=0 ?};
_oto:=_a;
_elref:=_b;
_max:=_c;

::pobranie refow elementow sasiednich dla elementu _elref
_elem:=sql('select distinct ELREF from :_a where B_PREL=\':_b\' order by ELREF',_oto,_elref);
::pobranie charakterystyki elementow sasiadujacych z sasiadami elementu _elref
:: z wylaczeniem wskazywania na element _elref
_sql:='select PN, RODZAJ, CECHA1, CECHA2, CECHA3, CECHA4, ELREF from :_a '
   +' where (B_PREL in (select ELREF from :_b)) and (ELREF<>\':_c\') '
   +' order by 1,2,3,4,5,6';
_tab:=sql(_sql,_oto,_elem,_elref);
::uzupelnienie listy elementow zakazanych o element startowy
_elem.ELREF:=_elref; _elem.add();
{? _max
||
:: pobranie refow elementow sasiednich z sasiadami sasiadow _elref
   _sql1:='select distinct ELREF from :_a '
      +' where (B_PREL in (select distinct ELREF from :_b)) '
         +' and (B_PREL not in (select distinct ELREF from :_c)) '
      +' order by ELREF';
   _elem1:=sql(_sql1,_oto,_tab,_elem);
   &_tab;
   _sql2:='select distinct PN, RODZAJ, CECHA1, CECHA2, CECHA3, CECHA4, ELREF from :_a '
      +' where (B_PREL in (select ELREF from :_b)) '
      +' order by 1,2,3,4,5,6';
   _tab:=sql(_sql2,_oto,_elem1);
:: dodanie do elementow zakazanych listy elementow uzytych przed chwila
   _dodaj:="
      _elem1:=_a; _elem:=_b;
      {? _elem1.first()
      || {! |? {? ~_elem.find_key(_elem1.ELREF) || _elem.ELREF:=_elem1.ELREF; _elem.add() ?}; _elem1.next() !}
      ?}
      ";
   _dodaj(_elem1,_elem);
   &_elem1;
:: i zebranie informacji z jeszcze dalszego otoczenia - do 2 stopni dalej
   {? _max>1
   || _elem1:=sql(_sql,_oto,_tab,_elem);
      &_tab;
      _tab:=sql(_sql2,_oto,_elem1);
      _dodaj(_elem1,_elem);
      &_elem1;
      {? _max>2
      || _elem1:=sql(_sql,_oto,_tab,_elem);
         &_tab;
         _tab:=sql(_sql2,_oto,_elem1);
         &_elem1;
         _wyn:=_tab
      || _wyn:=_tab
      ?}
   || _wyn:=_tab
   ?}
|| _wyn:=_tab
?};
&_elem;
_wyn


\max_dop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Szukanie najlepiej dopasowanego elementu na podstawie analizy podobienstwa i otoczenia
::   WE: _a - korzen do ktorego laczyc wpisy
::       _b - obiekt z danymi
::       _c - tabela elementow t1
::       _d - tabela elementow t2
::       _e - formula do wykonania podczas porownywania roznic
::       [_f] - jakie otoczenie najblizsze porpwnac: [W] - calosc, P - poprzednikow, N - nastepnikow
::       [_g] - rodzaj zwrcanego wyniku:
::             [0] - $_t2.ref jednego z najlepiej dopasowanych elementow
::             1   - tabela _tab z informacjami o dopasowaniu elementow
::   WY: $_t2.ref() jednego z najlepiej dpoasowanych elementow
::----------------------------------------------------------------------------------------------------------------------
{? (_<6) | (_f=~~) || _f:='W' ?};
{? (_<7) | (_g=~~) || _g:=0 ?};
_root:=_a;
_obj:=_b;
{? (_<8) | (_h=~~) || _h:=_obj.IREFCP ?};
_t1:=_c;
_t2:=_d;
_fml:=_e;
_zakres:=_f;
_wynik:=_g;

_tab:=tab_tmp(8
   ,'ROZNICE','INTEGER','liczba roznic'
   ,'OTOCZ','REAL','Podob. otoczenia'
   ,'DOTOCZ','REAL','Podob. dalszego otocz.'
   ,'DOTOCZ1','REAL','Podob. jeszcze dalsz. otocz.'
   ,'DOTOCZ2','REAL','Podob. jeszcze dalsz. otocz.'
   ,'DOTOCZ3','REAL','Podob. jeszcze dalsz. otocz.'
   ,'PATH','REAL','Podobieństwo spełniania warunków'
   ,'ELEM','STRING[16]','elem.REF'
   ,'T2','STRING[16]','$elem.ref()'
   ,'NRPROC','INTEGER','Numer stosowanej procedury'
   );
_tmin:='';

::ladowanie tabeli do porownania elementow
_load:="
   _root:=_a; _tab:=_b; _obj:=_c; _t1:=_d; _t2:=_e; _zakres:=_f; _fml:=_g;
   _t2.first();
   _tab.cntx_psh(); _tab.prefix();
   {!
   |? _mi:=_fml(_root,_obj,_t1,_t2);
      _tab.blank();
      _tab.ROZNICE:=_mi;
      _tab.OTOCZ:=_obj.wsp_otocz(_t1,_t2,_zakres);
      _tab.ELEM:=_t2.REF;
      _tab.T2:=$_t2.ref();
      _tab.NRPROC:=1;
      _tab.add();
      _t2.next()
   !};
   _tab.cntx_pop()
   ";
::pobranie danych do porownania dalszego otoczenia
_dalot:="
   _tab:=_a; _obj:=_b; _t1:=_c; _max:=_d;

   _otot1:=exec('dal_otocz','qporproc',_obj.BOTOCZ,_t1.REF,_max);
   _tabref:=sql('select REFERENCE from :_a order by 1',_tab);
   _tabref.first();
   _suma:=0;
   {!
   |? _tab.seek(_tabref.REFERENCE);
      _otot2:=exec('dal_otocz','qporproc',_obj.COTOCZ,_tab.ELEM,_max);
      {? _otot1.first()
      ||
         _suma:=_otot1.size()+_otot2.size();
         {? _max=1 || _tab.DOTOCZ1:=0
         |? _max=2 || _tab.DOTOCZ2:=0
         |? _max=3 || _tab.DOTOCZ3:=0
         || _tab.DOTOCZ:=0
         ?};
         _tab.NRPROC:=2+_max;
         {!
         |?
            _otot2.prefix(_otot1.PN,_otot1.RODZAJ,_otot1.CECHA1,_otot1.CECHA2,_otot1.CECHA3,_otot1.CECHA4,);
            {? _otot2.first()
            || {? _max=1 || _tab.DOTOCZ1+=2
               |? _max=2 || _tab.DOTOCZ2+=2
               |? _max=3 || _tab.DOTOCZ3+=2
               || _tab.DOTOCZ+=2
               ?};
               _otot2.del()
            ?};
            _otot1.next()
         !}
      ?};
      &_otot2;
      {? _max=1 || {? (_suma>0) & (_tab.DOTOCZ1>0)  || _tab.DOTOCZ1/=_suma; _tab.put() ?}
      |? _max=2 || {? (_suma>0) & (_tab.DOTOCZ2>0)  || _tab.DOTOCZ2/=_suma; _tab.put() ?}
      |? _max=3 || {? (_suma>0) & (_tab.DOTOCZ3>0)  || _tab.DOTOCZ3/=_suma; _tab.put() ?}
      || {? (_suma>0) & (_tab.DOTOCZ>0)  || _tab.DOTOCZ/=_suma; _tab.put() ?}
      ?};
      _tabref.next()
   !};
   &_tabref;
   &_otot1;
   ~~
";
::najpierw pobranie otoczenia zgodnie z zadanym ogrznieczeniem zakresu
_load(_root,_tab,_obj,_t1,_t2,_zakres,_fml);
::najpierw podobienstwo elementow (najmnijsza liczba roznic)
_tab.first(); _tab.prefix(_tab.ROZNICE);
::jak to nie wystarczy to najlepsze dopasowaniw otoczenia
{? _tab.size()>1
|| _tab.last(); _tab.prefix(_tab.ROZNICE,_tab.OTOCZ,);
   {? _tab.size>1
   ||
      _find:="
         _dalot:=_a; _tab:=_b; _obj:=_c; _t1:=_d;

         _dalot(_tab,_obj,_t1,0);
         _tab.last(); _tab.prefix(_tab.ROZNICE,_tab.OTOCZ,_tab.DOTOCZ);
         {? _tab.size>1
         || _dalot(_tab,_obj,_t1,1);
            _tab.last();
            _tab.prefix(_tab.ROZNICE,_tab.OTOCZ,_tab.DOTOCZ,_tab.DOTOCZ1);
            {? _tab.size()>1
            ||
               _dalot(_tab,_obj,_t1,2);
               _tab.last();
               _tab.prefix(_tab.ROZNICE,_tab.OTOCZ,_tab.DOTOCZ,_tab.DOTOCZ1,_tab.DOTOCZ2);
               {? _tab.size()>1
               || _dalot(_tab,_obj,_t1,3);
                  _tab.last();
                  _tab.prefix(_tab.ROZNICE,_tab.OTOCZ,_tab.DOTOCZ,_tab.DOTOCZ1,_tab.DOTOCZ2,_tab.DOTOCZ3);
                  {? _tab.size()>1
                  || {? _tab.first()
                     || _max:=0; _rmax:='';
                        {!
                        |?
                           {? _obj.GTOUTEL.find_key(_t1.REF,_tab.ELEM) & (_obj.GTOUTEL.WSPOLCZ>_max)
                           || _max:=_obj.GTOUTEL.WSPOLCZ; _rmax:=$_tab.ref()
                           ?};
                           _tab.next()
                        !}
                     ?};
                     {? _rmax<>'' & _tab.seek(_rmax) || _tab.PATH:=_max; _tab.put() ?}
                  ?}
               ?}
            ?}
         ?}
         ";
      {? _zakres<>'W'
      ||
::       jezeli zakres nie obejmowal calego otoczenia to sprawdzenie calego
         _tab.erase(); _load(_root,_tab,_obj,_t1,_t2,'W',_fml);
         _tab.last(); _tab.prefix(_tab.ROZNICE,_tab.OTOCZ,);
::       jak to nie wystarczylo to dodanie sprawdzenia dalszego otoczenia
         {? _tab.size>1 || _find(_dalot,_tab,_obj,_t1) ?}
      || _find(_dalot,_tab,_obj,_t1)
      ?};
      _tab.last()
   ?}
?};
_tmin:=_tab.T2;
::zwrocenie wyniku
{? _wynik=0 || &_tab; _tmin || _tab ?}


\mk_otocz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Utworzenie tabeli podobienstwa otoczenia elementow wyselekcjonowanych sposrod wszystkich
::   WE: _a - korzen do ktorego laczyc wpisy
::       _b - obiekt z danymi
::       _c - formula do wykonania podczas porownywania roznic
::       _d - zapytanie SQL w formie stringu - selekcja elementow z BPROEL i CPREL do porownania otoczen
::   WY: tabela tymczasowa z wynikami porownania otoczen kazdego z kazdym sposrod wyselekcjonowanych elementow
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_fml:=_c;
_sql:=_d;

::przygotowanie dodatkowej tabeli ze wspolczynnikami dopasowania otoczenia bram
_otocz:=tab_tmp(2
   ,'BR1REF','STRING[16]','$ref Bramy 1'
   ,'BR2REF','STRING[16]','$ref Bramy 2'
   ,'OTO','REAL','Podob otoczenia'
   );
_gatesb:=sql(_sql,_obj.BPREL); _gatesc:=sql(_sql,_obj.CPREL);
{? _gatesb.first()
|| {!
   |?
      _wyn:=exec('max_dop','qporproc',_root,_obj,_gatesb,_gatesc,_fml,,1);
      _wyn.prefix();
      {? _wyn.first()
      || {!
         |?
            _otocz.blank();
            _otocz.BR1REF:=_gatesb.REF;
            _otocz.BR2REF:=_wyn.ELEM;
            {? _wyn.NRPROC>0
            || _otocz.OTO:=(_wyn.OTOCZ+_wyn.DOTOCZ+_wyn.DOTOCZ1+_wyn.DOTOCZ2+_wyn.DOTOCZ3+_wyn.PATH)/_wyn.NRPROC
            ?};
            _otocz.add();
            _wyn.next()
         !}
      ?};
      &_wyn;
      _gatesb.next()
   !}
?};
&_gatesb; &_gatesc;
_otocz


::----------------------------------------------------------------------------------------------------------------------
:: tory
::----------------------------------------------------------------------------------------------------------------------


\comp_lane
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porównanie torów
::   WE: _a - obiekt
::       _b - konar drzewa, do którego należy łączyć komunikaty
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_lane:=_b;

_t1:=_obj.BPREL; _t2:=_obj.CPREL;
_t1ind0:=_t1.index('?'); _t2ind0:=_t2.index('?');
::tory
_ind:=_t2.ndx_tmp(,,'USED',,,'RODZAJ',,,'ROLA',,); _t2.index(_ind);
_t1.prefix('B_LANE');
{? _t1.first()
|| {!
   |?
      {? _t1.USED=0
      ||
         _t2.prefix(0,_t1.RODZAJ,_t1.ROLA);
         {? _t2.first()
         || exec('mk_bridge','qporproc',_t1,_t2);
            _obj.add2rap(_lane,'Tor',_t1.ROLA,_t2.ROLA,,'T'); exec('set_used','qporproc',_t1,_t2)
         || _obj.add2rap(_lane,'Tor',_t1.ROLA,,1,'T'); exec('set_used','qporproc',_t1)
         ?}
      ?};
      _t1.next()
   !}
?};
_t2.ndx_drop(_ind); &_ind;
_ind:=_t2.ndx_tmp(,,'USED',,,'RODZAJ',,,'BRIDGE',,); _t2.index(_ind);
_t2.prefix(0,'B_LANE');
{? _t2.first() || {! |? _obj.add2rap(_lane,'Tor',,_t2.ROLA,1,'T'); exec('set_used','qporproc',,_t2); _t2.first() !} ?};
_t2.ndx_drop(_ind); &_ind;
_t1.index(_t1ind0); _t2.index(_t2ind0);
~~


::----------------------------------------------------------------------------------------------------------------------
:: Czynności
::----------------------------------------------------------------------------------------------------------------------


\get_act_root
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Podanie roota galezi dla elementu typu czynnosc
::   WE: _a -objekt danych
::       _b - tablica elementow
::   WY: root
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_tt:=_b;

{? _tt.STANDARD='T' || _obj.ROOTS.ACTSTD
|? _tt.TYP='E' || _obj.ROOTS.ACTEDI
|? _tt.LOOP='N' || _obj.ROOTS.ACTUSUAL
|| _obj.ROOTS.ACTLOOP
?}


\act_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [MIR]
:: OPIS: Utworzenie zapisu w wynikach dla 2 sparowanych akcji
::   WE: _a - obiekt danych
::       _b- tabela elementow B
::       _c - tabela elementow C
::   WY: ref galezi na drzewie wynikow
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_t1:=_b;
_t2:=_c;

_root:=exec('get_act_root','qporproc',_obj,_t1);
{? _t1.STANDARD='T' || exec('action_st_12write','qporproc',_root,_obj,_t1,_t2)
|? _t1.TYP='E' || exec('action_ed_12write','qporproc',_root,_obj,_t1,_t2)
|? _t1.LOOP='N' || exec('action_un_12write','qporproc',_root,_obj,_t1,_t2)
|| exec('action_lo_12write','qporproc',_root,_obj,_t1,_t2)
?}


\list_rol4act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie list rol dla 2 czynoosci w 2 firmach
::   WE: _a - obiekt
::       _b - root
::       _c - typ listy
::       _d - tabela elementow procesu B
::       _e - tabela elementow procesu c
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_root:=_b;
_typ:=_c;
_t1:=_d;
_t2:=_e;

_sql:='select ROLA from :_a where (FIRMA=\':_b\') and (ACTION=\':_c\') and (TYP=\':_d\') order by 1';
_ro1:=sql(_sql,_obj.BACTRROP,_obj.BPROC.FREF,_t1.ACTREF,_typ);
_ro2:=sql(_sql,_obj.CACTRROP,_obj.CPROC.FREF,_t2.ACTREF,_typ);
::usuniecie powtarzajacych sie rol
{? _ro1.first() || {! |? {? _ro2.find_key(_ro1.ROLA,) || _ro2.del(); _ro1.del() || _ro1.next() ?} !} ?};
{? _ro1.first() | _ro2.first()
|| _wyn:=_obj.add2rap(_root,{? _typ='RUNMICRO' || 'Uruchamia bez zadania' || 'Przejmuje zadanie' ?},'','');
   {? _ro1.first() || {! |? _obj.add2rap(_wyn,'Rola',_ro1.ROLA,,1); _ro1.next() !} ?};
   {? _ro2.first() || {! |? _obj.add2rap(_wyn,'Rola',,_ro2.ROLA,1); _ro2.next() !} ?}
?};
&_ro1; &_ro2;
~~


\action_c_g
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Różnice ustawień parametrow glonalnych czynności
::   WE:
::       _a - rekord z opisem czynnosci
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

{? _obj.BPROC.FREF<>_obj.CPROC.FREF
||
   _wyn:=_obj.add2rap(_root,'Różnice w konfiguracji globalnej','w firmie FIRMA'
   +_obj.BPROC.FIRMA,'w firmie FIRMA'+_obj.CPROC.FIRMA);
   {? _t1.RUNMICRO<>_t2.RUNMICRO || _obj.add2rap(_wyn,'Uruchomienie bez zadania',_t1.RUNMICRO,_t2.RUNMICRO,1) ?};
   {? _t1.RUNMICRO='T' & _t2.RUNMICRO='T' || exec('list_rol4act','qporproc',_obj,_wyn,'RUNMICRO',_t1,_t2) ?};
   {? _t1.TAKEOVER<>_t2.TAKEOVER || _obj.add2rap(_wyn,'Możliwe przejęcie zadania',_t1.TAKEOVER,_t2.TAKEOVER,1) ?};
   {? _t1.TAKEOVER='T' & _t2.TAKEOVER='T' || exec('list_rol4act','qporproc',_obj,_wyn,'TAKEOVER',_t1,_t2) ?};
   {? _t1.RELEASE<>_t2.RELEASE || _obj.add2rap(_wyn,'Możliwe zwolnienie zadania',_t1.RELEASE,_t2.RELEASE,1) ?};
   {? _obj.RAPORT.seek(_wyn,) & _obj.RAPORT.ROZNIC=0 || _obj.RAPORT.del() ?}
?};
~~

\action_c_c
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie konfiguracji czynnosci
::   WE:
::       _a - rekord z opisem czynnosci
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - [1] - tryb zapisu, 0 - tryb liczenia
::   WY: liczba roznic
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
_zap:=(_<5) | (_e=~~) | (_e=1);

_wyn:=0;
{? _zap || _wynroot:=_obj.add2rap(_root,'Różnice w konfiguracji na diagramie','','') ?};
{? _t1.NAZWA<>_t2.NAZWA || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Nazwa',_t1.NAZWA,_t2.NAZWA,1) ?} ?};
{? _t1.TRYB<>_t2.TRYB || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Tryb pracy',_t1.TRYB,_t2.TRYB,1) ?} ?};
{? _t1.FACCES<>_t2.FACCES
|| _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Formuła uprawnień',_t1.FACCES,_t2.FACCES,1) ?}
?};
{? (_t1.STANDARD='N') & (_t1.TYP<>'L') & (_t1.TYP<>'E')
||
   {? _t1.OUTTYP<>_t2.OUTTYP
   || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Typ parametru wyjściowego',_t1.OUTTYP,_t2.OUTTYP,1) ?}
   ?};
   {? _t1.FMANOUT<>_t2.FMANOUT
   || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Formuła parametru wyjściowego.',_t1.FMANOUT,_t2.FMANOUT,1) ?}
   ?};
   {? _t1.FMANMAIN<>_t2.FMANMAIN
   || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Formuła główna',_t1.FMANMAIN,_t2.FMANMAIN,1) ?}
   ?};
   {? _t1.FMANDESC<>_t2.FMANDESC
   || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Formuła opisu ToDo',_t1.FMANDESC,_t2.FMANDESC,1) ?}
   ?};
   {? _t1.FMANVIEW<>_t2.FMANVIEW
   || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Formuła wyświetl w ToDo',_t1.FMANVIEW,_t2.FMANVIEW,1) ?}
   ?}
?};
{? _t1.TYP='E'
||
   _b1:=_obj.BEDI; _b2:=_obj.CEDI; _b1.prefix(); _b2.prefix(); _b1.blank(); _b2.blank();
   _b1.find_key(_t1.ISTREF,); _b2.find_key(_t2.ISTREF,);
   {? _t1.ISTT<>_t2.ISTT || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Typ komunikaru EDI',_t1.ISTT,_t2.ISTT,1) ?} ?};
   {? _b1.ISTSY<>_b2.ISTSY || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'System',_b1.ISTSY,_b2.ISTSY,1) ?} ?};
   {? _b1.ISTK<>_b2.ISTK || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Kod',_b1.ISTK,_b2.ISTK,1) ?} ?};
   {? _b1.ISTR<>_b2.ISTR || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Rodzaj',_b1.ISTR,_b2.ISTR,1) ?} ?};
   {? _b1.ISTN<>_b2.ISTN || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Nr wersji',$_b1.ISTN,$_b2.ISTN,1) ?} ?};
   {? _b1.ISTDT<>_b2.ISTDT || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Od kiedy',$_b1.VOD,$_b2.VOD,1) ?} ?};
   {? _b1.ISTVE<>_b2.ISTVE || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Wersja',_b1.ISTVE,_b2.ISTVE,1) ?} ?};
   {? _b1.VNAZ<>_b2.VNAZ || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Nazwa',_b1.VNAZ,_b2.VNAZ,1) ?} ?}
?};
{? (_t1.TRYB=_t2.TRYB) & (_t1.AUTO='S')
|| {? _t1.KOLEJKA<>_t2.KOLEJKA || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Kolejka',_t1.KOLEJKA,_t2.KOLEJKA,1) ?} ?}
|| {? _t1.ROLA<>_t2.ROLA || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Tor',_t1.ROLA,_t2.ROLA,1) ?} ?};
   {? _t1.ASSIGNTD<>_t2.ASSIGNTD
   || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Przydzielane autom.',_t1.ASSIGNTD,_t2.ASSIGNTD,1) ?}
   ?};
   {? (_t1.TYP='E') & (_t1.DESKTOP<>_t2.DESKTOP)
   || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Widoczne na ToDo',_t1.DESKTOP,_t2.DESKTOP,1) ?}
   ?};
   {? (#(2+user(10)))>=22
   || {? (_t1.EMAIL<>'') & (_t2.EMAIL<>'') & (_t1.EMAIL<>_t2.EMAIL)
      || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Powiadomienie e_mail',_t1.EMAIL,_t2.EMAIL,1) ?}
      ?};
      {? (_t1.SMS<>'') & (_t2.SMS<>'') & (_t1.SMS<>_t2.SMS)
      || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Powiadomienie SMS',_t1.SMS,_t2.SMS,1) ?}
      ?};
      {? (_t1.PERSONAL<>'') & (_t2.PERSONAL<>'') & (_t1.PERSONAL<>_t2.PERSONAL)
      || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Możliwa personalizacja',_t1.PERSONAL,_t2.PERSONAL,1) ?}
      ?};
      {? _t1.STANDARD='T'
      || {? _t1.RELEASE<>_t2.RELEASE
         || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Możliwe zwolnienie zadania',_t1.RELEASE,_t2.RELEASE,1) ?}
         ?}
      ?}
   ?};
   {? _t1.DURATION | _t2.DURATION
   ||
      {? _t1.IV3<>_t2.IV3
      || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Planowany czas trwania',_t1.IV3 $ 3,_t2.IV3 $ 3,1) ?}
      ?};
      {? _t1.TR_MODE<>_t2.TR_MODE
      || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Termin realizacji',_t1.TR_MODE,_t2.TR_MODE,1) ?}
      ?};
      {? _t1.IVTIME<>_t2.IVTIME
      || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Czas trwania',_t1.IVTIME $ 3,_t2.IVTIME $ 3,1) ?}
      ?};
      {? _t1.IVKIND<>_t2.IVKIND
      || _wyn+=1; {? _zap || _obj.add2rap(_wynroot,'Rodzaj interwału',_t1.IVKIND,_t2.IVKIND,1) ?}
      ?};
      {? _t1.IV1<>_t2.IV1 | _t1.IVNAME1<>_t2.IVNAME1
      || _wyn+=1;
         {? _zap
         || _obj.add2rap(_wynroot,'Czas trwania',form(_t1.IV1,,0,'99')+' '+_t1.IVNAME1,form(_t2.IV1,,0,'99')+' '
            +_t2.IVNAME1,1)
         ?}
      ?};
      {? _t1.IV2<>_t2.IV2 | _t1.IVNAME2<>_t2.IVNAME2
      || _wyn+=1;
         {? _zap
         || _obj.add2rap(_wynroot,'Czas trwania',form(_t1.IV2,,0,'99')+' '+_t1.IVNAME2,form(_t2.IV2,,0,'99')+' '
            +_t2.IVNAME2,1)
         ?}
      ?}
   ?}
?};
{? _zap & _obj.RAPORT.seek(_wynroot,) & _obj.RAPORT.ROZNIC=0 || _obj.RAPORT.del() ?};
_wyn


\act_max_dop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Szukanie najlepiej dopasowanego elementu z t2 typu ACTION do t1
::   WE: _a - korzen do ktorego laczyc wpisy
::       _b - obiekt z danymi
::       _c - tabela elementow t1
::       _d - tabela elementow t2
::       _e - zapytanie sql na selekcje elementow w przypadku analizy dalekiego otoczenia
::   WY: $_t2.ref() jednego z najlepiej dpoasowanych elementow
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
_sql:=_e;

_tab:=exec('max_dop','qporproc',_root,_obj,_t1,_t2
   ,"exec('action_c_c','qporproc',_a,_b,_c,_d,0)+exec('port_in_cmp','qporproc',_a,_b,_c,_d,0)",,1);
_tab.prefix(); _tab.first(); _tab.prefix(_tab.ROZNICE);
_wyn:={? _tab.size=1
      || _tab.T2
      || _tab.last(); _tab.prefix(_tab.ROZNICE,_tab.OTOCZ,_tab.DOTOCZ,_tab.DOTOCZ1,_tab.DOTOCZ2,_tab.DOTOCZ3);
         _tab.T2
      ?};
&_tab;
_wyn


\check_fact
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Znalezienie zdarzen startowych na podstawie rejestru pierwszych akcji
::   WE: _a - objekt
::       _b - tabela elementow 1 procesu
::       _c - tabela elementow 2 procesu
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_t1:=_b;
_t2:=_c;

::indeksy dla rejestru pierwszych akcji oparte na polu ACT
_fa1:=_obj.BACTSTA;
_fa2:=_obj.CACTSTA;
::jezeli jest tylko po jedno zdarzenie startowe wowiazane z kazda czynnoscia to sparowanie
_t1.cntx_psh(); _t2.cntx_psh();
_t1.index(_obj.IREFBP); _t2.index(_obj.IREFCP);
_t1.prefix(); _t2.prefix();
_fa1.prefix(_t1.REF,); _fa2.prefix(_t2.REF,);
{? _fa1.size()=1 & (_fa1.first()) & (_fa2.size()=1) & _fa2.first()
   & _t1.find_key(_fa1.EVE) & _t2.find_key(_fa2.EVE)
   & (_t1.USED=0) & (_t2.USED=0)
|| exec('event_no_12write','qporproc',_obj.ROOTS.EVTHPLA,_obj,_t1,_t2)
?};
_t1.cntx_pop(); _t2.cntx_pop();
~~


::......................................................................................................................
:: Czynności standardowe
::......................................................................................................................


\action_st_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary czynnosci standardowych
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_wyn:=_obj.add2rap(_root,'Czynność',exec('action_st_txt','qporproc',_t1),exec('action_st_txt','qporproc',_t2),,'C');
exec('mk_bridge','qporproc',_t1,_t2,_pewny);
exec('set_used','qporproc',_t1,_t2);
::porownanie konfiguracji czynnosci
exec('action_c_g','qporproc',_wyn,_obj,_t1,_t2);
exec('action_c_c','qporproc',_wyn,_obj,_t1,_t2);
exec('port_in_cmp','qporproc',_wyn,_obj,_t1,_t2);
exec('check_fact','qporproc',_obj,_t1,_t2);
_wyn


\odp_action_st1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.STANDARD,_t1.SYMBOL,_t1.NAZWA,_t1.ROLA,_t1.TRYB);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_st_12write','qporproc',_root,_obj,_t1,_t2)
   || _sql:='select * from :_a '
         +' where (USED=0) and (BRIDGE=0) and (RODZAJ=\''+_t1.RODZAJ+'\') and (STANDARD=\''+_t1.STANDARD+'\')'
            +' and (SYMBOL=\''+_t1.SYMBOL+'\') and (NAZWA=\''+_t1.NAZWA+'\') and (ROLA=\''+_t1.ROLA+'\')'
            +' and (TRYB=\''+_t1.TRYB+'\')'
         +' order by REF';
      _tmin:=exec('act_max_dop','qporproc',_root,_obj,_t1,_t2,_sql);
      {? (_tmin<>'') & _t2.seek(_tmin)
      || exec('action_st_12write','qporproc',_root,_obj,_t1,_t2,1)
      || _obj.add2rap(_root,'Czynność',exec('action_st_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
      ?}
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_st_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_st2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.STANDARD,_t1.SYMBOL,_t1.NAZWA,_t1.ROLA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_st_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_action_st1','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_st_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_st3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.STANDARD,_t1.SYMBOL,_t1.NAZWA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_st_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_action_st2','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_st_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_st
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Poszukiwanie odpowiednikow czynnosci standardowych
::   WE:
::       _a - root
::       _b - objekt
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_obj.BPREL;
_t2:=_obj.CPREL;
_ind1:=_obj.BPREL.index('?');
_ind2:=_obj.CPREL.index('?');

_t1.cntx_psh(); _t2.cntx_psh();
_t1.index(_ind1); _t2.index(_ind2);
_t1.prefix('B_ACTION','T'); _t2.prefix(0,0,'B_ACTION','T');
{? _t1.first()
|| {!
   |?
      {? _t1.BRIDGE=0 & _t1.USED=0
      ||
         _t1.cntx_psh();
::       najpierw podobienstwo symbolu
         _t1.prefix(_t1.RODZAJ,_t1.STANDARD,_t1.SYMBOL,);
         {? _t1.size()=1
         || _t2.prefix(0,0,_t1.RODZAJ,_t1.STANDARD,_t1.SYMBOL,);
            {? _t2.first()
            ||
               {? _t2.size()=1
               || exec('action_st_12write','qporproc',_root,_obj,_t1,_t2)
               || exec('odp_action_st3','qporproc',_root,_obj,_t1,_t2)
               ?}
            || _obj.add2rap(_root,'Czynność',_t1.SYMBOL+' '+_t1.NAZWA,,1,'C')
            ?}
         || _t1.prefix(_t1.RODZAJ,_t1.STANDARD,_t1.SYMBOL,_t1.NAZWA,);
            {? _t1.size()=1
            || exec('odp_action_st3','qporproc',_root,_obj,_t1,_t2)
            || _t1.prefix(_t1.RODZAJ,_t1.STANDARD,_t1.SYMBOL,_t1.NAZWA,_t1.ROLA,);
               {? _t1.size()=1
               || exec('odp_action_st2','qporproc',_root,_obj,_t1,_t2)
               || _t1.prefix(_t1.RODZAJ,_t1.STANDARD,_t1.SYMBOL,_t1.NAZWA,_t1.ROLA,_t1.TRYB);
                  exec('odp_action_st1','qporproc',_root,_obj,_t1,_t2)
::                  {? _t1.size()=1
::                  || exec('odp_action_st1','qporproc',_root,_obj,_t1,_t2)
::                  || {? _t1.BRIDGE=0 & _t1.USED=0 || exec('odp_action_st1','qporproc',_root,_obj,_t1,_t2) ?}
::                  ?}
               ?}
            ?}
         ?};
         _t1.cntx_pop()
      ?};
      _t1.next()
   !}
?};
::czynnosci 2 procesu, ktore nie maja odpowiednikow
_t2.prefix(0,0,'B_ACTION','T');
{!
|? _t2.first()
|! _obj.add2rap(_root,'Czynność',,exec('action_st_txt','qporproc',_t2),1,'C'); exec('set_used','qporproc',,_t2)
!};
_t1.cntx_pop(); _t2.cntx_pop();
~~


::......................................................................................................................
:: czynności uniwersalne
::......................................................................................................................


\action_un_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary czynnosci uniwersalnych
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_wyn:=_obj.add2rap(_root,'Czynność',exec('action_un_txt','qporproc',_t1),exec('action_un_txt','qporproc',_t2),,'C');
exec('mk_bridge','qporproc',_t1,_t2,_pewny);
exec('set_used','qporproc',_t1,_t2);
::porownanie konfiguracji czynnosci
exec('action_c_g','qporproc',_wyn,_obj,_t1,_t2);
exec('action_c_c','qporproc',_wyn,_obj,_t1,_t2);
exec('port_in_cmp','qporproc',_wyn,_obj,_t1,_t2);
exec('check_fact','qporproc',_obj,_t1,_t2);
_wyn


\odp_action_un1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,_t1.FMANOUT,_t1.FMANMAIN,_t1.OUTTYP,_t1.NAZWA,_t1.TRYB,_t1.ROLA,);
{? _t2.first()
||
   {? _t2.size()=1
   || exec('action_un_12write','qporproc',_root,_obj,_t1,_t2,1)
   || _sql:='select * from :_a '
         +' where (USED=0) and (BRIDGE=0) and (RODZAJ=\''+_t1.RODZAJ+'\') and (STANDARD=\''+_t1.STANDARD+'\')'
            +' and (LOOP=\''+_t1.LOOP+'\') and (FMANOUT=\''+_t1.FMANOUT+'\') and (FMANMAIN=\''+_t1.FMANMAIN+'\')'
            +' and (OUTTYP=\''+_t1.OUTTYP+'\') and (NAZWA=\''+_t1.NAZWA+'\') and (TRYB=\''+_t1.TRYB+'\')'
            +' and (ROLA=\''+_t1.ROLA+'\')'
         +' order by REF';
      _tmin:=exec('act_max_dop','qporproc',_root,_obj,_t1,_t2,_sql);
      {? (_tmin<>'') & _t2.seek(_tmin)
      || exec('action_un_12write','qporproc',_root,_obj,_t1,_t2,1)
      || _obj.add2rap(_root,'Czynność',exec('action_un_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
      ?}
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_un_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_un2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,_t1.FMANOUT,_t1.FMANMAIN,_t1.OUTTYP,_t1.NAZWA,_t1.TRYB);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_un_12write','qporproc',_root,_obj,_t1,_t2)
   || _t2.prefix(0,0,_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,_t1.FMANOUT,_t1.FMANMAIN,_t1.OUTTYP,_t1.NAZWA,_t1.TRYB,_t1.ROLA,);
      {? _t2.first()
      || {? _t2.size()=1
         || exec('action_un_12write','qporproc',_root,_obj,_t1,_t2)
         || exec('odp_action_un1','qporproc',_root,_obj,_t1,_t2)
         ?}
      || _obj.add2rap(_root,'Czynność',exec('action_un_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
      ?}
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_un_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_un3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,_t1.FMANOUT,_t1.FMANMAIN,_t1.OUTTYP,_t1.NAZWA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_un_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_action_un2','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_un_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_un4
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,_t1.FMANOUT,_t1.FMANMAIN,_t1.OUTTYP,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_un_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_action_un3','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_un_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_un5
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,_t1.FMANOUT,_t1.FMANMAIN,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_un_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_action_un4','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_un_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_un6
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,_t1.FMANOUT,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_un_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_action_un5','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_un_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_un
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Poszukiwanie odpowiednikow czynnosci uniwersalnych
::   WE:
::       _a - root
::       _b - objekt
::       _c - dodatkowy indeks dla tabeli t2
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_obj.BPREL;
_t2:=_obj.CPREL;
_ind1:=_obj.BPREL.index('?');
_ind2:=_obj.CPREL.index('?');
_ind21:=_c;

_t1.cntx_psh(); _t2.cntx_psh();
_t1.index(_ind1); _t2.index(_ind2);
_t1.prefix('B_ACTION','N','N'); _t2.prefix(0,0,'B_ACTION','N','N');
{? _t1.first()
|| {!
   |?
      {? _t1.BRIDGE=0 & _t1.USED=0
      ||
         _t1.cntx_psh();
::       najpierw podobienstwo symbolu
         _t1.prefix(_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,);
         {? _t1.size()=1
         || _t2.prefix(0,0,_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,);
            {? _t2.first()
            ||
               {? _t2.size()=1
               || exec('action_un_12write','qporproc',_root,_obj,_t1,_t2)
               || exec('odp_action_un6','qporproc',_root,_obj,_t1,_t2)
               ?}
            || _obj.add2rap(_root,'Czynność',exec('action_un_txt','qporproc',_t1),,1,'C')
            ?}
         || _t1.prefix(_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,_t1.FMANOUT,);
            {? _t1.size()=1
            || exec('odp_action_un6','qporproc',_root,_obj,_t1,_t2)
            || _t1.prefix(_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,_t1.FMANOUT,_t1.FMANMAIN,);
               {? _t1.size()=1
               || exec('odp_action_un5','qporproc',_root,_obj,_t1,_t2)
               || _t1.prefix(_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,_t1.FMANOUT,_t1.FMANMAIN,_t1.OUTTYP,);
                  {? _t1.size()=1
                  || exec('odp_action_un4','qporproc',_root,_obj,_t1,_t2)
                  || _t1.prefix(_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,_t1.FMANOUT,_t1.FMANMAIN,_t1.OUTTYP,_t1.NAZWA,);
                     {? _t1.size()=1
                     || exec('odp_action_un3','qporproc',_root,_obj,_t1,_t2)
                     || _t1.prefix(_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,_t1.FMANOUT,_t1.FMANMAIN,_t1.OUTTYP,_t1.NAZWA,_t1.TRYB);
                        {? _t1.size=1
                        || exec('odp_action_un2','qporproc',_root,_obj,_t1,_t2)
                        || _t1.prefix(_t1.RODZAJ,_t1.STANDARD,_t1.LOOP,_t1.FMANOUT,_t1.FMANMAIN,_t1.OUTTYP,_t1.NAZWA,_t1.TRYB,_t1.ROLA,);
                           exec('odp_action_un1','qporproc',_root,_obj,_t1,_t2)
::                           {? _t1.size=1
::                           || exec('odp_action_un1','qporproc',_root,_obj,_t1,_t2)
::                           || {? _t1.BRIDGE=0 & _t1.USED=0 || exec('odp_action_un1','qporproc',_root,_obj,_t1,_t2) ?}
::                           ?}
                        ?}
                     ?}
                  ?}
               ?}
            ?}
         ?};
         _t1.cntx_pop()
      ?};
      _t1.next()
   !}
?};
::czynnosci 2 procesu, ktore nie maja odpowiednikow
_t2.prefix(0,0,'B_ACTION','N','N');
{!
|? _t2.first()
|! _obj.add2rap(_root,'Czynność',,exec('action_un_txt','qporproc',_t2),1,'C'); exec('set_used','qporproc',,_t2)
!};
_t1.cntx_pop(); _t2.cntx_pop();
~~


::......................................................................................................................
:: czynności ZWS_GGR_PKEY
::......................................................................................................................


\action_lo_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary czynnosci typu ZWS_GGR_PKEY
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_wyn:=_obj.add2rap(_root,'Czynność',exec('action_lo_txt','qporproc',_t1),exec('action_lo_txt','qporproc',_t2),,'C');
exec('mk_bridge','qporproc',_t1,_t2);
exec('set_used','qporproc',_t1,_t2);
exec('action_c_g','qporproc',_wyn,_obj,_t1,_t2);
exec('port_in_cmp','qporproc',_wyn,_obj,_t1,_t2);
exec('check_fact','qporproc',_obj,_t1,_t2);
_wyn


\odp_action_lo1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.SYMBOL,_t1.WARTOSC,_t1.NAZWA,_t1.TRYB,_t1.ROLA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_lo_12write','qporproc',_root,_obj,_t1,_t2)
   || _sql:='select * from :_a '
         +' where (USED=0) and (BRIDGE=0) and (RODZAJ=\''+_t1.RODZAJ+'\') and (SYMBOL=\''+_t1.SYMBOL+'\')'
            +' and (WARTOSC=\''+_t1.WARTOSC+'\') and (NAZWA=\''+_t1.NAZWA+'\') and (ROLA=\''+_t1.ROLA+'\')'
            +' and (TRYB=\''+_t1.TRYB+'\')'
         +' order by REF';
      _tmin:=exec('act_max_dop','qporproc',_root,_obj,_t1,_t2,_sql);
      {? (_tmin<>'') & _t2.seek(_tmin)
      || exec('action_lo_12write','qporproc',_root,_obj,_t1,_t2,1)
      || _obj.add2rap(_root,'Czynność',exec('action_lo_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
      ?}
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_lo_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_lo2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.SYMBOL,_t1.WARTOSC,_t1.NAZWA,_t1.TRYB);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_lo_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_action_lo1','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_lo_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_lo3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.SYMBOL,_t1.WARTOSC,_t1.NAZWA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_lo_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_action_lo2','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_lo_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_lo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Poszukiwanie odpowiednikow czynnosci uniwersalnych
::   WE:
::       _a - root
::       _b - objekt
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_obj.BPREL;
_t2:=_obj.CPREL;
_ind1:=_obj.BPREL.index('?');
_ind2:=_obj.CPREL.index('?');
_t1.cntx_psh(); _t2.cntx_psh();
_t1.index(_ind1); _t2.index(_ind2);
_t1.prefix('B_ACTION','ZWS_GGR_PKEY'); _t2.prefix(0,0,'B_ACTION','ZWS_GGR_PKEY');
{? _t1.first()
|| {!
   |?
      {? _t1.BRIDGE=0 & _t1.USED=0
      ||
         _t1.cntx_psh();
::       najpierw podobienstwo symbolu
         _t1.prefix(_t1.RODZAJ,_t1.SYMBOL,_t1.WARTOSC,);
         {? _t1.size()=1
         || _t2.prefix(0,0,_t1.RODZAJ,_t1.SYMBOL,_t1.WARTOSC,);
            {? _t2.first()
            || {? _t2.size()=1
               || exec('action_lo_12write','qporproc',_root,_obj,_t1,_t2)
               || exec('odp_action_lo3','qporproc',_root,_obj,_t1,_t2)
               ?}
            || _obj.add2rap(_root,'Czynność',exec('action_lo_txt','qporproc',_t1),,1,'C')
            ?}
         || _t1.prefix(_t1.RODZAJ,_t1.SYMBOL,_t1.WARTOSC,_t1.NAZWA,);
            {? _t1.size()=1
            || exec('odp_action_lo3','qporproc',_root,_obj,_t1,_t2)
            || _t1.prefix(_t1.RODZAJ,_t1.SYMBOL,_t1.WARTOSC,_t1.NAZWA,_t1.TRYB);
               {? _t1.size()=1
               || exec('odp_action_lo2','qporproc',_root,_obj,_t1,_t2)
               || _t1.prefix(_t1.RODZAJ,_t1.SYMBOL,_t1.WARTOSC,_t1.NAZWA,_t1.TRYB,_t1.ROLA,);
                  exec('odp_action_lo1','qporproc',_root,_obj,_t1,_t2)
::                  {? _t1.size()=1
::                  || exec('odp_action_lo1','qporproc',_root,_obj,_t1,_t2)
::                  || {? _t1.BRIDGE=0 & _t1.USED=0 || exec('odp_action_lo1','qporproc',_root,_obj,_t1,_t2) ?}
::                  ?}
               ?}
            ?}
         ?};
         _t1.cntx_pop()
      ?};
      _t1.next()
   !}
?};
::czynnosci 2 procesu, ktore nie maja odpowiednikow
_t2.prefix(0,0,'B_ACTION','ZWS_GGR_PKEY');
{!
|? _t2.first()
|! _obj.add2rap(_root,'Czynność',,exec('action_lo_txt','qporproc',_t2),1,'C'); exec('set_used','qporproc',,_t2)
!};
_t1.cntx_pop(); _t2.cntx_pop();
~~


::......................................................................................................................
:: czynności ZWS_EDI_UNIW
::......................................................................................................................


\action_ed_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary czynnosci typu ZWS_EDI_UNIW
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_wyn:=_obj.add2rap(_root,'Czynność',exec('action_lo_txt','qporproc',_t1),exec('action_lo_txt','qporproc',_t2),,'C');
exec('mk_bridge','qporproc',_t1,_t2);
exec('set_used','qporproc',_t1,_t2);
exec('action_c_g','qporproc',_wyn,_obj,_t1,_t2);
exec('action_c_c','qporproc',_wyn,_obj,_t1,_t2);
exec('port_in_cmp','qporproc',_wyn,_obj,_t1,_t2);
exec('check_fact','qporproc',_obj,_t1,_t2);
_wyn


\odp_action_ed1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.SYMBOL,_t1.ISTT,_t1.ISTREF,_t1.NAZWA,_t1.TRYB,_t1.ROLA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_ed_12write','qporproc',_root,_obj,_t1,_t2)
   || _sql:='select * from :_a '
         +' where (USED=0) and (BRIDGE=0) and (RODZAJ=\''+_t1.RODZAJ+'\') and (SYMBOL=\''+_t1.SYMBOL+'\')'
            +' and (ISTT=\''+_t1.ISTT+'\') and (ISTREF=\''+_t1.ISTREF+'\') and (NAZWA=\''+_t1.NAZWA+'\')'
            +' and (ROLA=\''+_t1.ROLA+'\') and (TRYB=\''+_t1.TRYB+'\')'
         +' order by REF';
      _tmin:=exec('act_max_dop','qporproc',_root,_obj,_t1,_t2,_sql);
      {? (_tmin<>'') & _t2.seek(_tmin)
      || exec('action_ed_12write','qporproc',_root,_obj,_t1,_t2,1)
      || _obj.add2rap(_root,'Czynność',exec('action_ed_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
      ?}
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_ed_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_ed2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.SYMBOL,_t1.ISTT,_t1.ISTREF,_t1.NAZWA,_t1.TRYB);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_ed_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_action_ed1','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_ed_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_ed3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.SYMBOL,_t1.ISTT,_t1.ISTREF,_t1.NAZWA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_ed_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_action_ed2','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_ed_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_ed4
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.SYMBOL,_t1.ISTT,_t1.ISTREF,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('action_ed_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_action_ed3','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Czynność',exec('action_ed_txt','qporproc',_t1),,1,'C'); exec('set_used','qporproc',_t1)
?}


\odp_action_ed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Poszukiwanie odpowiednikow czynnosci uniwersalnych
::   WE:
::       _a - root
::       _b - objekt
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_obj.BPREL;
_t2:=_obj.CPREL;
_ind1:=_obj.BPREL.index('?');
_ind2:=_obj.CPREL.index('?');
_t1.cntx_psh(); _t2.cntx_psh();
_t1.index(_ind1); _t2.index(_ind2);
_t1.prefix('B_ACTION','ZWS_EDI_UNIW'); _t2.prefix(0,0,'B_ACTION','ZWS_EDI_UNIW');
{? _t1.first()
|| {!
   |?
      {? _t1.BRIDGE=0 & _t1.USED=0
      ||
         _t1.cntx_psh();
::       najpierw podobienstwo symbolu
         _t1.prefix(_t1.RODZAJ,_t1.SYMBOL,_t1.ISTT,);
         {? _t1.size()=1
         || _t2.prefix(0,0,_t1.RODZAJ,_t1.SYMBOL,_t1.ISTT,);
            {? _t2.first()
            || {? _t2.size()=1
               || exec('action_ed_12write','qporproc',_root,_obj,_t1,_t2)
               || exec('odp_action_ed4','qporproc',_root,_obj,_t1,_t2)
               ?}
            || _obj.add2rap(_root,'Czynność',exec('action_ed_txt','qporproc',_t1),,1,'C')
            ?}
         || _t1.prefix(_t1.RODZAJ,_t1.SYMBOL,_t1.ISTT,_t1.ISTREF);
            {? _t1.size()=1
            || exec('odp_action_ed4','qporproc',_root,_obj,_t1,_t2)
            || _t1.prefix(_t1.RODZAJ,_t1.SYMBOL,_t1.ISTT,_t1.ISTREF,_t1.NAZWA,);
               {? _t1.size()=1
               || exec('odp_action_ed3','qporproc',_root,_obj,_t1,_t2)
               || _t1.prefix(_t1.RODZAJ,_t1.SYMBOL,_t1.ISTT,_t1.ISTREF,_t1.NAZWA,_t1.TRYB);
                  {? _t1.size()=1
                  || exec('odp_action_ed2','qporproc',_root,_obj,_t1,_t2)
                  || _t1.prefix(_t1.RODZAJ,_t1.SYMBOL,_t1.ISTT,_t1.ISTREF,_t1.NAZWA,_t1.TRYB,_t1.ROLA,);
                     exec('odp_action_ed1','qporproc',_root,_obj,_t1,_t2)
::                     {? _t1.size()=1
::                     || exec('odp_action_ed1','qporproc',_root,_obj,_t1,_t2)
::                     || {? _t1.BRIDGE=0 & _t1.USED=0 || exec('odp_action_ed1','qporproc',_root,_obj,_t1,_t2) ?}
::                     ?}
                  ?}
               ?}
            ?}
         ?};
         _t1.cntx_pop()
      ?};
      _t1.next()
   !}
?};
::czynnosci 2 procesu, ktore nie maja odpowiednikow
_t2.prefix(0,0,'B_ACTION','ZWS_EDI_UNIW');
{!
|? _t2.first()
|! _obj.add2rap(_root,'Czynność',,exec('action_ed_txt','qporproc',_t2),1,'C'); exec('set_used','qporproc',,_t2)
!};
_t1.cntx_pop(); _t2.cntx_pop();
~~


::......................................................................................................................
:: starowanie porownaniem akcji
::......................................................................................................................


\comp_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porównanie czynnosci
::   WE: _a - obiekt
::       _b - konar drzewa, do którego należy łączyć komunikaty
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_root:=_b;

::specjalny indeks dla wykazu pierwszych akcji
_obj.BACTSTA.index(_obj.BACTSTA.ndx_tmp(,,'ACT',,,'EVE',,));
_obj.CACTSTA.index(_obj.CACTSTA.ndx_tmp(,,'ACT',,,'EVE',,));
::tabele elementow
_t1:=_obj.BPREL; _t2:=_obj.CPREL;
_t1ind0:=_t1.index('?'); _t2ind0:=_t2.index('?');

::analiza podobienstwa czynnosci standardowych
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'STANDARD',,,'SYMBOL',,,'NAZWA',,,'ROLA',,,'TRYB',,);
_ind2:=_t2.ndx_tmp(,,'BRIDGE',,,'USED',,,'RODZAJ',,,'STANDARD',,,'SYMBOL',,,'NAZWA',,,'ROLA',,,'TRYB',,);
_t1.index(_ind1);  _t2.index(_ind2);
_t1.prefix('B_ACTION','T'); _t2.prefix(0,0,'B_ACTION','T');
exec('odp_action_st','qporproc',_obj.ROOTS.ACTSTD,_obj);
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);

::analiza podobienstwa czynnosci uniwersalnych zwyklych
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'STANDARD',,,'LOOP',,,'FMANOUT',,,'FMANMAIN',,,'OUTTYP',,,'NAZWA',,,'TRYB',,,'ROLA',,);
_ind2:=_t2.ndx_tmp(,,'BRIDGE',,,'USED',,,'RODZAJ',,,'STANDARD',,,'LOOP',,,'FMANOUT',,,'FMANMAIN',,,'OUTTYP',,,'NAZWA',,,'TRYB',,,'ROLA',,);
_ind21:=_t2.ndx_tmp(,,'BRIDGE',,,'USED',,,'RODZAJ',,,'STANDARD',,,'LOOP',,,'FMANOUT',,,'FMANMAIN',,,'OUTTYP',,,'NAZWA',,,'ROLA',,,'TRYB',,);
_t1.index(_ind1);  _t2.index(_ind2);
_t1.prefix('B_ACTION','N'); _t2.prefix(0,0,'B_ACTION','N');
exec('odp_action_un','qporproc',_obj.ROOTS.ACTUSUAL,_obj,_ind21);
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2); _t2.ndx_drop(_ind21);

::analiza podobienstwa czynnosci ZWS_GGR_PKEY
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'SYMBOL',,,'WARTOSC',,,'NAZWA',,,'TRYB',,,'ROLA',,);
_ind2:=_t2.ndx_tmp(,,'BRIDGE',,,'USED',,,'RODZAJ',,,'SYMBOL',,,'WARTOSC',,,'NAZWA',,,'TRYB',,,'ROLA',,);
_t1.index(_ind1);  _t2.index(_ind2);
_t1.prefix('B_ACTION','ZWS_GGR_PKEY'); _t2.prefix(0,0,'B_ACTION','ZWS_GGR_PKEY');
exec('odp_action_lo','qporproc',_obj.ROOTS.ACTLOOP,_obj);
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);

::analiza podobienstwa czynnosci ZWS_EDI_UNIW
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'SYMBOL',,,'ISTT',,,'ISTREF',,,'NAZWA',,,'TRYB',,,'ROLA',,);
_ind2:=_t2.ndx_tmp(,,'BRIDGE',,,'USED',,,'RODZAJ',,,'SYMBOL',,,'ISTT',,,'ISTREF',,,'NAZWA',,,'TRYB',,,'ROLA',,);
_t1.index(_ind1);  _t2.index(_ind2);
_t1.prefix('B_ACTION','ZWS_EDI_UNIW'); _t2.prefix(0,0,'B_ACTION','ZWS_EDI_UNIW');
exec('odp_action_ed','qporproc',_obj.ROOTS.ACTLOOP,_obj);
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);

_t1.index(_t1ind0); _t2.index(_t2ind0);
~~


::----------------------------------------------------------------------------------------------------------------------
:: zdarzenia
::----------------------------------------------------------------------------------------------------------------------


\etype
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zwraca oznaczenie typu zdarzenia
::   WE: _a - tlemenet tabeli
::   WY: oznaczenie
::----------------------------------------------------------------------------------------------------------------------
_tt:=_a;

{? _tt.EVTYPE='startowe' || 'S' |? _tt.EVTYPE='pośrednie' || 'P' || 'K' ?}


\emax_dop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zwraca ref dorekordu _t2, ktory najlepiej jest dopasowany do badanego _t1
::   WE: _a - _tab - tablica dopasowan
::   WY: $_t2.ref() lub ''
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_tab.prefix(); _tab.first(); _tab.prefix(_tab.ROZNICE);
_wyn:={? _tab.size=1
      || _tab.T2
      || _tab.last(); _tab.prefix(_tab.ROZNICE,_tab.OTOCZ,_tab.DOTOCZ,_tab.DOTOCZ1,_tab.DOTOCZ2,_tab.DOTOCZ3,_tab.PATH);
         _tab.T2
      ?};
_wyn

::......................................................................................................................
:: zdarzenia warunkowe
::......................................................................................................................


\event_w_c
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie konfiguracji zdarzen warunkowych
::   WE:
::       _a - rekord z opisem czynnosci
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - [1] - tryb zapisu, 0 - tryb liczenia
::   WY: liczba roznic
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
_zap:=(_<5) | (_e=~~) | (_e=1);

_rez:=0;
{? _t1.EVTYPE<>_t2.EVTYPE || _rez+=1; {? _zap || _obj.add2rap(_root,'Typ',_t1.EVTYPE,_t2.EVTYPE,1) ?} ?};
{? _zap || _wyn:=_obj.add2rap(_root,'Różnice w konfiguracji na diagramie','','') ?};
{? _t1.NAZWA<>_t2.NAZWA || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Nazwa',_t1.NAZWA,_t2.NAZWA,1) ?} ?};
{? _t1.FCOND<>_t2.FCOND || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Formuła warunku',_t1.FCOND,_t2.FCOND,1) ?} ?};
{? (#(2+user(10)))>=22
|| {? (_t1.COND_CHK<>'') & (_t2.COND_CHK<>'') & (_t1.COND_CHK<>_t2.COND_CHK)
   || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Kontrola parametrów wejściowych',_t1.COND_CHK,_t2.COND_CHK,1) ?}
   ?};
   {? _t1.OUTTYP<>_t2.OUTTYP
   || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Typ parametru wyjściowego',_t1.OUTTYP,_t2.OUTTYP,1) ?}
   ?}
?};
{? _t1.KOLEJKA<>_t2.KOLEJKA || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Kolejka',_t1.KOLEJKA,_t2.KOLEJKA,1) ?} ?};
{? _zap & _obj.RAPORT.seek(_wyn,) & _obj.RAPORT.ROZNIC=0 || _obj.RAPORT.del() ?};
_rez


\event_w_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary czynnosci standardowych
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_fore:=exec('etype','qporproc',_t1); _aft:=exec('etype','qporproc',_t2);
_wyn:=_obj.add2rap(_root,'Zdarzenie',exec('event_w_txt','qporproc',_t1),exec('event_w_txt','qporproc',_t2),,_fore+'Z'+_aft);
exec('mk_bridge','qporproc',_t1,_t2,_pewny);
exec('set_used','qporproc',_t1,_t2);
exec('event_w_c','qporproc',_wyn,_obj,_t1,_t2);
exec('port_in_cmp','qporproc',_wyn,_obj,_t1,_t2);
_wyn


\odp_event_w1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,_t1.FCOND,_t1.OUTTYP,_t1.NAZWA,_t1.EVTYPE,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_w_12write','qporproc',_root,_obj,_t1,_t2)
   || _tab:=exec('max_dop','qporproc',_root,_obj,_t1,_t2
         ,"exec('event_w_c','qporproc',_a,_b,_c,_d,0)+exec('port_in_cmp','qporproc',_a,_b,_c,_d,0)",,1);
      _tmin:=exec('emax_dop','qporproc',_tab);
      &_tab;
      {? (_tmin<>'') & _t2.seek(_tmin)
      || exec('event_w_12write','qporproc',_root,_obj,_t1,_t2,1)
      || _obj.add2rap(_root,'Zdarzenie',exec('event_w_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
         exec('set_used','qporproc',_t1)
      ?}
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_w_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_w2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,_t1.FCOND,_t1.OUTTYP,_t1.NAZWA,_t1.EVTYPE,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_w_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_event_w1','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_w_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_w3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,_t1.FCOND,_t1.OUTTYP,_t1.NAZWA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_w_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_event_w2','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_w_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_w4
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,_t1.FCOND,_t1.OUTTYP,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_w_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_event_w3','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_w_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_war
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Poszukiwanie odpowiednikow zdarzen
::   WE:
::       _a - root
::       _b - objekt
::       _c - kategoria
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_kateg:=_c;
_t1:=_obj.BPREL;
_t2:=_obj.CPREL;

_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'SYGNAL',,,'FCOND',,,'OUTTYP',,,'NAZWA',,,'EVTYPE',,);
_ind2:=_t2.ndx_tmp(,,'BRIDGE',,,'USED',,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'SYGNAL',,,'FCOND',,,'OUTTYP',,,'NAZWA',,,'EVTYPE',,);
_t1.cntx_psh(); _t2.cntx_psh();
_t1.index(_ind1); _t2.index(_ind2);
_t1.prefix('B_EVENT',_kateg,'warunkowe','',);
_t2.prefix(0,0,'B_EVENT',_kateg,'warunkowe','',);
{? _t1.first()
|| {!
   |?
      {? _t1.BRIDGE=0 & _t1.USED=0
      ||
         _t1.cntx_psh();
::       najpierw podobienstwo warunku
         _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,_t1.FCOND,);
         {? _t1.size()=1
         || _t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,_t1.FCOND,);
            {? _t2.first()
            ||
               {? _t2.size()=1
               || exec('event_w_12write','qporproc',_root,_obj,_t1,_t2)
               || exec('odp_event_w4','qporproc',_root,_obj,_t1,_t2)
               ?}
            || _obj.add2rap(_root,'Zdarzenie',exec('event_w_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z')
            ?}
         || _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,_t1.FCOND,_t1.OUTTYP,);
            {? _t1.size()=1
            || exec('odp_event_w4','qporproc',_root,_obj,_t1,_t2)
            || _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,_t1.FCOND,_t1.OUTTYP,_t1.NAZWA,);
               {? _t1.size()=1
               || exec('odp_event_w3','qporproc',_root,_obj,_t1,_t2)
               || _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,_t1.FCOND,_t1.OUTTYP,_t1.NAZWA,_t1.EVTYPE);
                  {? _t1.size()=1
                  || exec('odp_event_w2','qporproc',_root,_obj,_t1,_t2)
                  || {!
                     |? {? _t1.BRIDGE=0 || exec('odp_event_w1','qporproc',_root,_obj,_t1,_t2) ?};
                        _t1.next()
                     !}
                  ?}
               ?}
            ?}
         ?};
         _t1.cntx_pop()
      ?};
      _t1.next()
   !}
?};
::zdarzenia 2 procesu, ktore nie maja odpowiednikow
_t2.prefix(0,0,'B_EVENT',_kateg,'warunkowe','',);
{!
|? _t2.first()
|! _obj.add2rap(_root,'Zdarzenie',,exec('event_w_txt','qporproc',_t2),1,'Z'+exec('etype','qporproc',_t2));
   exec('set_used','qporproc',,_t2)
!};
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);
_t1.cntx_pop(); _t2.cntx_pop();
~~


::......................................................................................................................
:: zdarzenia typu sygnal
::......................................................................................................................


\event_s_c
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie konfiguracji zdarzen typu sygnal
::   WE:
::       _a - rekord z opisem czynnosci
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - [1] - tryb zapisu, 0 - tryb liczenia
::   WY: liczba roznic
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
_zap:=(_<5) | (_e=~~) | (_e=1);

_rez:=0;
{? _t1.EVTYPE<>_t2.EVTYPE || _rez+=1; {? _zap || _obj.add2rap(_root,'Typ',_t1.EVTYPE,_t2.EVTYPE,1) ?} ?};
{? _zap ||_wyn:=_obj.add2rap(_root,'Różnice w konfiguracji na diagramie','','') ?};
{? _t1.ENABLED<>_t2.ENABLED || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Aktywny',_t1.ENABLED,_t2.ENABLED,1) ?} ?};
{? _t1.NAZWA<>_t2.NAZWA || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Nazwa',_t1.NAZWA,_t2.NAZWA,1) ?} ?};
{? (#(2+user(10)))>=22
|| {? _t1.TRYB<>_t2.TRYB || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Tryb pracy',_t1.TRYB,_t2.TRYB,1) ?} ?}
?};
{? _zap & _obj.RAPORT.seek(_wyn,) & _obj.RAPORT.ROZNIC=0 || _obj.RAPORT.del() ?};
_rez


\event_s_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary sdarzeń typu sygnał
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_fore:=exec('etype','qporproc',_t1); _aft:=exec('etype','qporproc',_t2);
_wyn:=_obj.add2rap(_root,'Zdarzenie',exec('event_s_txt','qporproc',_t1),exec('event_s_txt','qporproc',_t2),,_fore+'Z'+_aft);
exec('set_used','qporproc',_t1,_t2);
exec('mk_bridge','qporproc',_t1,_t2,_pewny);
exec('event_s_c','qporproc',_wyn,_obj,_t1,_t2);
exec('port_in_cmp','qporproc',_wyn,_obj,_t1,_t2);
_wyn


\odp_event_s1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,_t1.NAZWA,_t1.EVTYPE);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_s_12write','qporproc',_root,_obj,_t1,_t2)
   || _tab:=exec('max_dop','qporproc',_root,_obj,_t1,_t2
            ,"exec('event_s_c','qporproc',_a,_b,_c,_d,0)+exec('port_in_cmp','qporproc',_a,_b,_c,_d,0)",,1);
      _tmin:=exec('emax_dop','qporproc',_tab);
      &_tab;
      {? (_tmin<>'') & _t2.seek(_tmin)
      || exec('event_s_12write','qporproc',_root,_obj,_t1,_t2,1)
      || _obj.add2rap(_root,'Zdarzenie',exec('event_s_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
         exec('set_used','qporproc',_t1)
      ?}
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_s_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_s2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,_t1.NAZWA,_t1.EVTYPE,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_s_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_event_s1','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_s_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_s3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,_t1.NAZWA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_s_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_event_s2','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_s_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_syg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Poszukiwanie odpowiednikow zdarzen
::   WE:
::       _a - root
::       _b - objekt
::       _c - kategoria
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_kateg:=_c;
_t1:=_obj.BPREL;
_t2:=_obj.CPREL;

_t1.cntx_psh(); _t2.cntx_psh();
_in1:=_t1.ndx_tmp(,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'SYGNAL',,,'NAZWA',,,'EVTYPE',,); _t1.index(_in1);
_in2:=_t2.ndx_tmp(,,'BRIDGE',,,'USED',,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'SYGNAL',,,'NAZWA',,,'EVTYPE',,); _t2.index(_in2);
_t1.prefix('B_EVENT',_kateg,'sygnał',);
_t2.prefix(0,0,'B_EVENT',_kateg,'sygnał',);
{? _t1.first()
|| {!
   |?
      {? _t1.BRIDGE=0 & _t1.USED=0
      ||
         _t1.cntx_psh();
::       najpierw podobienstwo symbolu
         _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,);
         {? _t1.size()=1
         || _t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,);
            {? _t2.first()
            ||
               {? _t2.size()=1
               || exec('event_s_12write','qporproc',_root,_obj,_t1,_t2)
               || exec('odp_event_s3','qporproc',_root,_obj,_t1,_t2)
               ?}
            || _obj.add2rap(_root,'Zdarzenie',exec('event_s_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z')
            ?}
         || _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,_t1.NAZWA,);
            {? _t1.size()=1
            || exec('odp_event_s3','qporproc',_root,_obj,_t1,_t2)
            || _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.SYGNAL,_t1.NAZWA,_t1.EVTYPE);
               {? _t1.size()=1
               || exec('odp_event_s2','qporproc',_root,_obj,_t1,_t2)
               || exec('odp_event_s1','qporproc',_root,_obj,_t1,_t2)
               ?}
            ?}
         ?};
         _t1.cntx_pop()
      ?};
      _t1.next()
   !}
?};
::zdarzenia 2 procesu, ktore nie maja odpowiednikow
_t2.prefix(0,0,'B_EVENT',_kateg,'sygnał',);
{!
|? _t2.first()
|! _obj.add2rap(_root,'Zdarzenie',,exec('event_s_txt','qporproc',_t2),1,'Z'+exec('etype','qporproc',_t2));
   exec('set_used','qporproc',,_t2)
!};
_t1.ndx_drop(_in1); _t2.ndx_drop(_in2);
_t1.cntx_pop(); _t2.cntx_pop();
~~


::......................................................................................................................
:: zdarzenia nieokreslone
::......................................................................................................................


\event_n_c
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie konfiguracji zdarzen typu nieokreslone
::   WE:
::       _a - rekord z opisem czynnosci
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - [1] - tryb zapisu, 0 - tryb liczenia
::   WY: liczba roznic
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
_zap:=(_<5) | (_e=~~) | (_e=1);

_rez:=0;
{? _t1.EVTYPE<>_t2.EVTYPE || _rez+=1; {? _zap || _obj.add2rap(_root,'Typ',_t1.EVTYPE,_t2.EVTYPE,1) ?} ?};
{? _zap || _wyn:=_obj.add2rap(_root,'Różnice w konfiguracji na diagramie','','') ?};
{? _t1.NAZWA<>_t2.NAZWA || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Nazwa',_t1.NAZWA,_t2.NAZWA,1) ?} ?};
{? _t1.EVTYPE='stertowe'
|| {? _t1.DOMAIN<>_t2.DOMAIN || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Dziedzina',_t1.DOMAIN,_t2.DOMAIN,1) ?} ?};
   {? _t1.DESKTOP<>_t2.DESKTOP || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Start procesów',_t1.DESKTOP,_t2.DESKTOP,1) ?}?}
?};
{? _zap & _obj.RAPORT.seek(_wyn,) & _obj.RAPORT.ROZNIC=0 || _obj.RAPORT.del() ?};
_rez


\event_no_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary zdarzeń nieokreślonych
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_fore:=exec('etype','qporproc',_t1); _aft:=exec('etype','qporproc',_t2);
_wyn:=_obj.add2rap(_root,'Zdarzenie',exec('event_no_txt','qporproc',_t1),exec('event_no_txt','qporproc',_t2),,_fore+'Z'+_aft);
exec('set_used','qporproc',_t1,_t2);
exec('mk_bridge','qporproc',_t1,_t2,_pewny);
exec('event_n_c','qporproc',_wyn,_obj,_t1,_t2);
_wyn


\odp_event_no1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.NAZWA,_t1.DOMAIN,_t1.ROLA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_no_12write','qporproc',_root,_obj,_t1,_t2)
   || _tab:=exec('max_dop','qporproc',_root,_obj,_t1,_t2,"exec('event_n_c','qporproc',_a,_b,_c,_d,0)",,1);
      _tmin:=exec('emax_dop','qporproc',_tab);
      &_tab;
      {? (_tmin<>'') & _t2.seek(_tmin)
      || exec('event_no_12write','qporproc',_root,_obj,_t1,_t2,1)
      || _obj.add2rap(_root,'Zdarzenie',exec('event_no_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
         exec('set_used','qporproc',_t1)
      ?}
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_no_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_no2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.NAZWA,_t1.DOMAIN,_t1.ROLA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_no_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_event_no1','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_no_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_no3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.NAZWA,_t1.DOMAIN,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_no_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_event_no2','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_no_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_no4
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.NAZWA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_no_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_event_no3','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_no_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_nieo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Poszukiwanie odpowiednikow zdarzen
::   WE:
::       _a - root
::       _b - objekt
::       _c - kategoria
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_kateg:=_c;

_ind1:=_obj.BPREL.index('?');
_ind2:=_obj.CPREL.index('?');
_obj.BPREL.cntx_psh(); _obj.CPREL.cntx_psh();
_t1:=_obj.BPREL;
_t2:=_obj.CPREL;
:: zmienic indeksy
_t1.cntx_psh(); _t2.cntx_psh();
_in1:=_t1.ndx_tmp(,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'NAZWA',,,'DOMAIN',,,'ROLA',,);
_in2:=_t2.ndx_tmp(,,'BRIDGE',,,'USED',,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'NAZWA',,,'DOMAIN',,,'ROLA',,);
_t1.index(_in1); _t2.index(_in2);
_t1.prefix('B_EVENT',_kateg,'nieokreślone',);
_t2.prefix(0,0,'B_EVENT',_kateg,'nieokreślone',);
{? _t1.first()
|| {!
   |?
      {? _t1.BRIDGE=0 & _t1.USED=0
      ||
         _t1.cntx_psh();
::       najpierw podobienstwo symbolu
         _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,);
         {? _t1.size()=1
         || _t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,);
            {? _t2.first()
            ||
               {? _t2.size()=1
               || exec('event_no_12write','qporproc',_root,_obj,_t1,_t2)
               || exec('odp_event_no4','qporproc',_root,_obj,_t1,_t2)
               ?}
            || _obj.add2rap(_root,'Zdarzenie',exec('event_no_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z')
            ?}
         || _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.NAZWA,);
            {? _t1.size()=1
            || exec('odp_event_no4','qporproc',_root,_obj,_t1,_t2)
            || _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.NAZWA,_t1.DOMAIN);
               {? _t1.size()=1
               || exec('odp_event_no3','qporproc',_root,_obj,_t1,_t2)
               || _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.NAZWA,_t1.DOMAIN,_t1.ROLA,);
                  {? _t1.size()=1
                  || exec('odp_event_no2','qporproc',_root,_obj,_t1,_t2)
                  || {!
                     |? {? _t1.BRIDGE=0 & _t1.USED=0 || exec('odp_event_no1','qporproc',_root,_obj,_t1,_t2) ?};
                        _t1.next()
                     !}
                  ?}
               ?}
            ?}
         ?};
         _t1.cntx_pop()
      ?};
      _t1.next()
   !}
?};
::zdarzenia 2 procesu, ktore nie maja odpowiednikow
_t2.prefix(0,0,'B_EVENT',_kateg,'nieokreślone',);
{!
|? _t2.first()
|! _obj.add2rap(_root,'Zdarzenie',,exec('event_no_txt','qporproc',_t2),1,'Z'+exec('etype','qporproc',_t2));
   exec('set_used','qporproc',,_t2)
!};
_t1.cntx_pop(); _t2.cntx_pop();
_obj.BPREL.cntx_pop(); _obj.CPREL.cntx_pop();
~~


::......................................................................................................................
:: zdarzenia czasowe
::......................................................................................................................


\event_t_c
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie konfiguracji zdarzen czasowych
::   WE:
::       _a - rekord z opisem czynnosci
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - [1] - tryb zapisu, 0 - tryb liczenia
::   WY: liczba roznic
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
_zap:=(_<5) | (_e=~~) | (_e=1);

_rez:=0;
{? _t1.EVTYPE<>_t2.EVTYPE || _rez+=1; {? _zap || _obj.add2rap(_root,'Typ',_t1.EVTYPE,_t2.EVTYPE,1) ?} ?};
{? _zap || _wyn:=_obj.add2rap(_root,'Różnice w konfiguracji na diagramie','','') ?};
{? _t1.NAZWA<>_t2.NAZWA || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Nazwa',_t1.NAZWA,_t2.NAZWA,1) ?} ?};
{? _t1.ENABLED<>_t2.ENABLED || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Aktywny',_t1.ENABLED,_t2.ENABLED,1) ?} ?};
{? _t1.TTRYB<>_t2.TTRYB || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Harmonogram',_t1.TTRYB,_t2.TTRYB,1) ?} ?};
{? _t1.TT<>_t2.TT || _rez+=1; {? _zap || _obj.add2rap(_wyn,'TT',_t1.TT,_t2.TT,1) ?} ?};
{? _t1.TM<>_t2.TM || _rez+=1; {? _zap || _obj.add2rap(_wyn,'TM',_t1.TM,_t2.TM,1) ?} ?};
{? _t1.TD<>_t2.TD || _rez+=1; {? _zap || _obj.add2rap(_wyn,'TD',_t1.TM,_t2.TD,1) ?} ?};
{? _t1.TDT<>_t2.TDT || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Data rozpoczęcia',$_t1.TDT,$_t2.TDT,1) ?} ?};
{? _t1.TTM<>_t2.TTM || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Godzina rozpoczęcia',_t1.TTM $ 3,_t2.TTM $ 3,1) ?} ?};
{? _t1.EXPIRES<>_t2.EXPIRES || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Wygasa',_t1.EXPIRES,_t2.EXPIRES,1) ?} ?};
{? _t1.TDTE<>_t2.TDTE || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Data wygaśnięcia',$_t1.TDTE,$_t2.TDTE,1) ?} ?};
{? _t1.TTME<>_t2.TTME || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Godzina wygaśnięcia',_t1.TTME $ 3,_t2.TTME $ 3,1) ?} ?};
{? _t1.REPLY<>_t2.REPLY || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Powtórz co',$_t1.REPLY,$_t2.REPLY,1) ?} ?};
{? _t1.REPEAT<>_t2.REPEAT || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Powtarzać',_t1.REPEAT,_t2.REPEAT,1) ?} ?};
{? _t1.INTERVAL<>_t2.INTERVAL
|| _rez+=1; {? _zap || _obj.add2rap(_wyn,'Powtarzać co [s]',$_t1.INTERVAL,$_t2.INTERVAL,1) ?}
?};
{? _t1.TDURATION<>_t2.TDURATION
|| _rez+=1; {? _zap || _obj.add2rap(_wyn,'Powtarzać przez [s]',$_t1.TDURATION,$_t2.TDURATION,1) ?}
?};
{? _t1.TTM_PLAN<>_t2.TTM_PLAN
|| _rez+=1;
   {? _zap
   || _obj.add2rap(_wyn,'Czas trwania [s]',form(_t1.TTM_PLAN/1000000,,0,'99'),form(_t2.TTM_PLAN/1000000,,0,'99'),1)
   ?}
?};
{? _t1.SINGLE<>_t2.SINGLE || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Jedna instancja',_t1.SINGLE,_t2.SINGLE,1) ?} ?};
{? _t1.KOLEJKA<>_t2.KOLEJKA || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Kolejka',_t1.KOLEJKA,_t2.KOLEJKA,1) ?} ?};
{? _zap & _obj.RAPORT.seek(_wyn,) & _obj.RAPORT.ROZNIC=0 || _obj.RAPORT.del() ?};
_rez


\event_ti_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary zdarzeń typu timer
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_fore:=exec('etype','qporproc',_t1); _aft:=exec('etype','qporproc',_t2);
_wyn:=_obj.add2rap(_root,'Zdarzenie',exec('event_ti_txt','qporproc',_t1),exec('event_ti_txt','qporproc',_t2),,_fore+'Z'+_aft);
exec('set_used','qporproc',_t1,_t2);
exec('mk_bridge','qporproc',_t1,_t2,_pewny);
exec('event_t_c','qporproc',_wyn,_obj,_t1,_t2);
_wyn


\odp_event_tim1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.EVTYPE,_t1.NAZWA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_ti_12write','qporproc',_root,_obj,_t1,_t2)
   || _tab:=exec('max_dop','qporproc',_root,_obj,_t1,_t2,"exec('event_t_c','qporproc',_a,_b,_c,_d,0)",,1);
      _tmin:=exec('emax_dop','qporproc',_tab);
      &_tab;
      {? (_tmin<>'') & _t2.seek(_tmin)
      || exec('event_ti_12write','qporproc',_root,_obj,_t1,_t2,1)
      || _obj.add2rap(_root,'Zdarzenie',exec('event_ti_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
         exec('set_used','qporproc',_t1)
      ?}
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_ti_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_tim2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.EVTYPE,_t1.NAZWA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_ti_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_event_tim1','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_ti_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_tim3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.EVTYPE,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_ti_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_event_tim2','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_ti_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_time
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Poszukiwanie odpowiednikow zdarzen
::   WE:
::       _a - root
::       _b - objekt
::       _c - kategoria
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_typ:=_c;

_ind1:=_obj.BPREL.index('?');
_ind2:=_obj.CPREL.index('?');
_obj.BPREL.cntx_psh(); _obj.CPREL.cntx_psh();
_t1:=_obj.BPREL;
_t2:=_obj.CPREL;
_t1.prefix('B_EVENT','przechwytujące','czasowe',_typ);
_t2.prefix(0,0,'B_EVENT','przechwytujące','czasowe',_typ);
{? _t1.first()
|| {!
   |?
      {? _t1.BRIDGE=0 & _t1.USED=0
      ||
         _t1.cntx_psh();
::       najpierw podobienstwo symbolu
         _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.EVTYPE,);
         {? _t1.size()=1
         || _t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.EVTYPE,);
            {? _t2.first()
            ||
               {? _t2.size()=1
               || exec('event_ti_12write','qporproc',_root,_obj,_t1,_t2)
               || exec('odp_event_tim3','qporproc',_root,_obj,_t1,_t2)
               ?}
            || _obj.add2rap(_root,'Zdarzenie',exec('event_ti_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z')
            ?}
         || _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.EVTYPE,_t1.NAZWA,);
            {? _t1.size()=1
            || exec('odp_event_tim3','qporproc',_root,_obj,_t1,_t2)
            ||
               {? _t1.size()=1
               || exec('odp_event_tim2','qporproc',_root,_obj,_t1,_t2)
               || {!
                  |? {? _t1.BRIDGE=0 & _t1.USED=0 || exec('odp_event_tim1','qporproc',_root,_obj,_t1,_t2) ?};
                     _t1.next()
                  !}
               ?}
            ?}
         ?};
         _t1.cntx_pop()
      ?};
      _t1.next()
   !}
?};
::zdarzenia 2 procesu, ktore nie maja odpowiednikow
_t2.prefix(0,0,'B_EVENT','przechwytujące','czasowe',_typ);
{!
|? _t2.first()
|! _obj.add2rap(_root,'Zdarzenie',,exec('event_ti_txt','qporproc',_t2),1,'Z'+exec('etype','qporproc',_t2));
   exec('set_used','qporproc',,_t2)
!};
_obj.BPREL.cntx_pop(); _obj.CPREL.cntx_pop();
~~


::......................................................................................................................
:: zdarzenia komunikat
::......................................................................................................................


\event_k_c
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie konfiguracji zdarzen wysylki komunikatu
::   WE:
::       _a - rekord z opisem czynnosci
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - [1] - tryb zapisu, 0 - tryb liczenia
::   WY: liczba roznic
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
_zap:=(_<5) | (_e=~~) | (_e=1);

_rez:=0;
_e1:=_obj.BMSG; _e2:=_obj.CMSG;
{? _t1.EVTYPE<>_t2.EVTYPE || _rez+=1; {? _zap || _obj.add2rap(_root,'Typ',_t1.EVTYPE,_t2.EVTYPE,1) ?} ?};
{? _zap || _wyn:=_obj.add2rap(_root,'Różnice w konfiguracji na diagramie','','') ?};
{? _t1.NAZWA<>_t2.NAZWA || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Nazwa',_t1.NAZWA,_t2.NAZWA,1) ?} ?};
{? _e1.find_key(_t1.REF,) & _e2.find_key(_t2.REF,)
||
   {? _e1.SUB<>_e2.SUB || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Temat',_e1.SUB,_e2.SUB,1) ?} ?};
   {? _e1.BODYT<>_e2.BODYT || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Treść txt',_e1.BODYT,_e2.BODYT,1) ?} ?};
   {? _e1.BODYH<>_e2.BODYH || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Treść html',_e1.BODYH,_e2.BODYH,1) ?} ?};
   {? _e1.SENDER<>_e2.SENDER || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Nadawca',_e1.SENDER,_e2.SENDER,1) ?} ?};
   {? _e1.FROM<>_e2.FROM || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Autor',_e1.FROM,_e2.FROM,1) ?} ?};
   {? _e1.REPLYTO<>_e2.REPLYTO || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Odpowiedź do',_e1.REPLYTO,_e2.REPLYTO,1) ?} ?};
   {? _e1.RCV<>_e2.RCV || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Odbiorca',_e1.RCV,_e2.RCV,1) ?} ?};
::{? _e1.RETURN<>_e2.RETURN || _obj.add2rap(_wyn,'Potwierdzenie odbioru',_e1.RETURN,_e2.RETURN,1) ?};
::{? _e1.SCHEMAT<>_e2.SCHEMAT || _obj.add2rap(_wyn,'Wg schematu',_e1.SCHEMAT,_e2.SCHEMAT,1) ?};
   {? _e1.TO<>_e2.TO || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Do',_e1.TO,_e2.TO,1) ?} ?};
   {? _e1.DW<>_e2.DW || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Do wiadomości',_e1.DW,_e2.DW,1) ?} ?};
   {? _e1.UDW<>_e2.UDW || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Ukryte do wiadomości',_e1.UDW,_e2.UDW,1) ?} ?};
   {? _e1.BI_BLOBA<>_e2.BI_BLOBA
   || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Załączniki dołączone',_e1.BI_BLOBA,_e2.BI_BLOBA,1) ?}
   ?};
   {? _e1.BI_BLOBE<>_e2.BI_BLOBE
   || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Załączniki osadzone',_e1.BI_BLOBE,_e2.BI_BLOBE,1) ?}
   ?};
   {? _e1.HEADTAGS<>_e2.HEADTAGS
   || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Tagi dla nagłówka wiadomości',_e1.HEADTAGS,_e2.HEADTAGS,1) ?}
   ?};
   {? _e1.TEMPLATE<>_e2.TEMPLATE || _rez+=1; {? _zap || _obj.add2rap(_wyn,'Wzorzec',_e1.TEMPLATE,_e2.TEMPLATE,1) ?} ?}
?};
{? _zap & _obj.RAPORT.seek(_wyn,) & _obj.RAPORT.ROZNIC=0 || _obj.RAPORT.del() ?};
_rez


\event_ko_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary zdarzeń typu timer
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_fore:=exec('etype','qporproc',_t1); _aft:=exec('etype','qporproc',_t2);
_wyn:=_obj.add2rap(_root,'Zdarzenie',exec('event_ko_txt','qporproc',_t1),exec('event_ko_txt','qporproc',_t2),,_fore+'Z'+_aft);
exec('set_used','qporproc',_t1,_t2);
exec('mk_bridge','qporproc',_t1,_t2,_pewny);
exec('event_k_c','qporproc',_wyn,_obj,_t1,_t2);
exec('port_in_cmp','qporproc',_wyn,_obj,_t1,_t2);
_wyn


\odp_event_kom1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.NAZWA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('event_ko_12write','qporproc',_root,_obj,_t1,_t2)
   || _tab:=exec('max_dop','qporproc',_root,_obj,_t1,_t2
            ,"exec('event_k_c','qporproc',_a,_b,_c,_d,0)+exec('port_in_cmp','qporproc',_a,_b,_c,_d,0)",,1);
      _tmin:=exec('emax_dop','qporproc',_tab);
      &_tab;
      {? (_tmin<>'') & _t2.seek(_tmin)
      || exec('event_ko_12write','qporproc',_root,_obj,_t1,_t2,1)
      || _obj.add2rap(_root,'Zdarzenie',exec('event_ko_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
         exec('set_used','qporproc',_t1)
      ?}
   ?}
|| _obj.add2rap(_root,'Zdarzenie',exec('event_ko_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z');
   exec('set_used','qporproc',_t1)
?}


\odp_event_kom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Poszukiwanie odpowiednikow zdarzen
::   WE:
::       _a - root
::       _b - objekt
::       _c - kategoria
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;

_ind1:=_obj.BPREL.index('?');
_ind2:=_obj.CPREL.index('?');
_obj.BPREL.cntx_psh(); _obj.CPREL.cntx_psh();
_t1:=_obj.BPREL;
_t2:=_obj.CPREL;
_t1.prefix('B_EVENT','rzucające','komunikat');
_t2.prefix(0,0,'B_EVENT','rzucające','komunikat');
{? _t1.first()
|| {!
   |?
      {? _t1.BRIDGE=0 & _t1.USED=0
      ||
         _t1.cntx_psh();
::       najpierw podobienstwo symbolu
         _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,);
         {? _t1.size()=1
         || _t2.prefix(0,0,_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,);
            {? _t2.first()
            ||
               {? _t2.size()=1
               || exec('event_ko_12write','qporproc',_root,_obj,_t1,_t2)
               || exec('odp_event_kom1','qporproc',_root,_obj,_t1,_t2)
               ?}
            || _obj.add2rap(_root,'Zdarzenie',,exec('event_ko_txt','qporproc',_t1),,1,exec('etype','qporproc',_t1)+'Z')
            ?}
         || _t1.prefix(_t1.RODZAJ,_t1.EVKATEG,_t1.EVKIND,_t1.NAZWA,);
            {? _t1.size()=1
            || exec('odp_event_kom1','qporproc',_root,_obj,_t1,_t2)
            || {!
               |? {? _t1.BRIDGE=0 & _t1.USED=0 || exec('odp_event_kom1','qporproc',_root,_obj,_t1,_t2) ?};
                  _t1.next()
               !}
            ?}
         ?};
         _t1.cntx_pop()
      ?};
      _t1.next()
   !}
?};
::zdarzenia 2 procesu, ktore nie maja odpowiednikow
_t2.prefix(0,0,'B_EVENT','rzucające','komunikat');
{!
|? _t2.first()
|! _obj.add2rap(_root,'Zdarzenie',,exec('event_ko_txt','qporproc',_t2),1,'Z'+exec('etype','qporproc',_t2));
   exec('set_used','qporproc',,_t2)
!};
_obj.BPREL.cntx_pop(); _obj.CPREL.cntx_pop();
~~


::......................................................................................................................
:: sterowanie porownaniem zdarzen
::......................................................................................................................


\comp_event
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porównanie torów
::   WE: _a - obiekt
::       _b - konar drzewa, do którego należy łączyć komunikaty
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_root:=_b;

_t1:=_obj.BPREL; _t2:=_obj.CPREL;
_t1ind0:=_t1.index('?'); _t2ind0:=_t2.index('?');

::porownywanie zdarzen
::warunkowe
exec('odp_event_war','qporproc',_obj.ROOTS.EVCAPWAR,_obj,'przechwytujące');

::sygnal i nieokreslone
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'SYGNAL',,,'FCOND',,,'NAZWA',,,'EVTYPE',,);
_ind2:=_t2.ndx_tmp(,,'BRIDGE',,,'USED',,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'SYGNAL',,,'FCOND',,,'NAZWA',,,'EVTYPE',,);
_t1.index(_ind1);  _t2.index(_ind2);
exec('odp_event_syg','qporproc',_obj.ROOTS.EVCAPSYG,_obj,'przechwytujące');
exec('odp_event_nieo','qporproc',_obj.ROOTS.EVCAPLA,_obj,'przechwytujące');
exec('odp_event_syg','qporproc',_obj.ROOTS.EVTHSYG,_obj,'rzucające');
exec('odp_event_nieo','qporproc',_obj.ROOTS.EVTHPLA,_obj,'rzucające');
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);

::czasowe
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'EVTYPE',,,'NAZWA',,);
_ind2:=_t2.ndx_tmp(,,'BRIDGE',,,'USED',,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'EVTYPE',,,'NAZWA',,);
_t1.index(_ind1);  _t2.index(_ind2);
exec('odp_event_time','qporproc',_obj.ROOTS.EVTHTIS,_obj,'startowe');
exec('odp_event_time','qporproc',_obj.ROOTS.EVTHTIP,_obj,'pośrednie');
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);

::komunikat
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'NAZWA',,);
_ind2:=_t2.ndx_tmp(,,'BRIDGE',,,'USED',,,'RODZAJ',,,'EVKATEG',,,'EVKIND',,,'NAZWA',,);
_t1.index(_ind1);  _t2.index(_ind2);
exec('odp_event_kom','qporproc',_obj.ROOTS.EVTHEM,_obj);
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);
_t1.index(_t1ind0); _t2.index(_t2ind0);
~~


::......................................................................................................................
:: porownywanie bram sterowanych zdarzeniami
::......................................................................................................................


\evgate_xor_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary bram XOR_EVENT
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_fa1:=_obj.BACTSTA; _fa2:=_obj.CACTSTA;
_fa1.prefix(); _fa2.prefix();
_wyn:=_obj.add2rap(_root,'Brama',exec('event_xor_txt','qporproc',_t1),exec('event_xor_txt','qporproc',_t2),,'B');
exec('set_used','qporproc',_t1,_t2);
exec('mk_bridge','qporproc',_t1,_t2,_pewny);
{? _t1.NAZWA<>_t2.NAZWA || _obj.add2rap(_wyn,'Nazwa',_t1.NAZWA,_t2.NAZWA,1) ?};
::jezeli brama rozdzielajaca, to kolejnosc wyjsc ma znaczenie
{? _t1.GATEKIND='<'
|| _sql:='select AA.KOLEJ KOLEJ, BB.EVKIND KIND, BB.SYGNAL SIG, BB.FCOND FCOND, BB.TM_PLAN TM, BB.DOMAIN DOMAIN, AA.DO DO from :_a AA '
      +' left join :_c as BB using(AA.DO,BB.REF) '
      +' where AA.OD=\':_b\' '
      +' order by KOLEJ'
|| _sql:='select AA.KOLEJ KOLEJ, BB.EVKIND KIND, BB.SYGNAL SIG, BB.FCOND FCOND, BB.TM_PLAN TM, BB.DOMAIN DOMAIN, AA.OD OD from :_a AA '
      +' left join :_c as BB using(AA.OD,BB.REF) '
      +' where AA.DO=\':_b\' '
      +' order by KOLEJ'
?};
_wy1:=sql(_sql,_obj.BCONN,_t1.REF,_obj.BPREL);
_wy2:=sql(_sql,_obj.CCONN,_t2.REF,_obj.CPREL);
_w2i:=_wy2.index('?');
_wy2.index(_wy2.ndx_tmp(,,'KIND',,,'SIG',,,'FCOND',,,'TM',,));
{? _t1.GATEKIND='<' || _ro:=_obj.add2rap(_wyn,'Kolejność sprawdzania','','') ?};
{? _wy1.first()
|| {!
   |?
      {? _wy2.find_key(_wy1.KIND,_wy1.SIG,_wy1.FCOND,_wy1.TM)
      ||
::       jezeli brama rozdzielajaca, to kolejnosc wyjsc ma znaczenie
         {? (_t1.GATEKIND='<') & (_wy1.KOLEJ<>_wy2.KOLEJ)
         || _obj.add2rap(_ro,'Podobne zdarzenia na wyjściu',$_wy1.KOLEJ,$_wy2.KOLEJ,1)
         ?};
         _t1.cntx_psh(); _t2.cntx_psh();
         _t1.index(_obj.IREFBP); _t2.index(_obj.IREFCP);
         _t1.prefix(); _t2.prefix();
::       jezeli 2 zdarzenia sa podobne to mozna je przyjac jako odpowiadajace sobie w procesie
         {? _t1.GATEKIND='<'
         ||
            {? _t1.find_key(_wy1.DO,) & _t2.find_key(_wy2.DO,)
            ||
               {? _t1.EVKIND='czasowe' || exec('event_ti_12write','qporproc',_obj.ROOTS.EVTHTIP,_obj,_t1,_t2)
               |? _t1.EVKIND='sygnał' || exec('event_s_12write','qporproc',_obj.ROOTS.EVTHSYG,_obj,_t1,_t2)
               |? _t1.EVKIND='warunkowe' || exec('event_w_12write','qporproc',_obj.ROOTS.EVCAPWAR,_obj,_t1,_t2)
               ?}
            ?}
         ||
            {? _t1.find_key(_wy1.OD,) & _t2.find_key(_wy2.OD,)
            ||
               {? _t1.EVKIND='czasowe' || exec('event_ti_12write','qporproc',_obj.ROOTS.EVTHTIS,_obj,_t1,_t2)
               |? _t1.EVKIND='sygnał' || exec('event_s_12write','qporproc',_obj.ROOTS.EVCAPSYG,_obj,_t1,_t2)
               |? _t1.EVKIND='warunkowe' || exec('event_w_12write','qporproc',_obj.ROOTS.EVCAPWAR,_obj,_t1,_t2)
               ||
                  exec('event_no_12write','qporproc',_obj.ROOTS.EVCAPLA,_obj,_t1,_t2);
::                jezeli jest tylko po jednej czynnosci zwiazanej z kazdym z obu zdarzen to
::                jezeli czynnosci sa zgodne, to sparowanie
                  _t1.cntx_psh(); _t2.cntx_psh();
                  _fa1.prefix(_t1.REF,); _fa2.prefix(_t2.REF,);
                  {? _fa1.size()=1 & (_fa1.first()) & (_fa2.size()=1) & _fa2.first()
                     & _t1.find_key(_fa1.ACT) & _t2.find_key(_fa2.ACT)
                     & (_t1.USED=0) & (_t2.USED=0) & (exec('comp_elem','qporproc',_t1,_t2)>0)
                  || exec('act_12write','qporproc',_obj,_t1,_t2)
                  ?};
                  _t1.cntx_pop(); _t2.cntx_pop()
               ?}
            ?}
         ?};
         _t1.cntx_pop(); _t2.cntx_pop()
      || {? _t1.GATEKIND='<' || _obj.add2rap(_ro,'Inne zdarzenie na wyjściu',$_wy1.KOLEJ,,1) ?}
      ?};
      _wy1.next()
   !}
?};
{? _t1.GATEKIND='<'
||
   _wy1.index(_wy1.ndx_tmp(,,'KIND',,,'SIG',,,'FCOND',,,'TM',,));
   _wy2.index(_w2i);
   {? _wy2.first()
   || {!
      |?
         {? ~_wy1.find_key(_wy2.KIND,_wy2.SIG,_wy2.FCOND,_wy2.TM)
         || _obj.add2rap(_ro,'Inne zdarzenie na wyjścu',,$_wy2.KOLEJ,1)
         ?};
         _wy2.next()
      !}
   ?};
   obj_del(_wy1); obj_del(_wy2);
   {? _obj.RAPORT.seek(_ro,) & _obj.RAPORT.ROZNIC=0 || _obj.RAPORT.del() ?}
?};
_wyn


\odp_evgate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Poszukiwanie odpowiednikow bram XOR_EVENT
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela elementow procesu 1
::       _d - tabela elementow procesu 2
::       _e - rodzaj bramy
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
_rodz:=_e;

_kind:={? _rodz='XOR_EVENT' || '>' || '<' ?};
_obj.BPREL.cntx_psh(); _obj.CPREL.cntx_psh();
_t1.prefix('B_GATE',_kind,_rodz);
_t2.prefix(0,_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,);
::utworzenie tabeli podobienstwa otoczenia wszystkich elementow zadanego typu
_sql:='select * from :_a '
   +' where (USED=0) and (BRIDGE=0) and (RODZAJ=\'B_GATE\') and (GATEKIND=\''+_kind+'\') and (GATETYPE=\''+_rodz+'\') '
   +' order by REF ';
_otocz:=exec('mk_otocz','qporproc',_root,_obj,"0",_sql);
{? _t1.first()
|| {!
   |?
      {? _t1.BRIDGE=0
      ||
         _t1.cntx_psh();
::       najpierw podobienstwo symbolu
         _t2.prefix(0,_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,);
         {? _t2.first()
         ||
            {? _t2.size()=1
            || exec('evgate_xor_12write','qporproc',_root,_obj,_t1,_t2)
            || _tab:=exec('max_dop','qporproc',_root,_obj,_t1,_t2,"0",{? _kind='>' || 'P' || 'N' ?},1);
               _tab.prefix(); _tab.last();
               _tab.prefix(_tab.ROZNICE,_tab.OTOCZ,_tab.DOTOCZ);
               {? _tab.size()=1
               || _t2.prefix(); _t2.seek(_tab.T2);
                  exec('evgate_xor_12write','qporproc',_root,_obj,_t1,_t2)
               || _max:=0; _t2max:='';
                  {!
                  |?
                     {? _otocz.find_key(_t1.REF,_t2.REF)
                     || {? _otocz.OTO>_max || _max:=_otocz.OTO; _t2max:=$_t2.ref() ?}
                     ?};
                     _t2.next()
                  !};
                  {? (_t2max<>'') & _t2.seek(_t2max)
                  || exec('evgate_xor_12write','qporproc',_root,_obj,_t1,_t2)
                  || _obj.add2rap(_root,'Brama',exec('event_xor_txt','qporproc',_t1),,1,'B');
                     exec('set_used','qporproc',_t1)
                  ?}
               ?};
               &_tab
            ?}
         || _obj.add2rap(_root,'Brama',exec('event_xor_txt','qporproc',_t1),,1,'B'); exec('set_used','qporproc',_t1)
         ?};
         _t1.cntx_pop()
      ?};
      _t1.next()
   !}
?};
&_otocz;
::elementy 2 procesu, ktore nie maja odpowiednikow
_t2.prefix(0,'B_GATE',_kind,_rodz);
{!
|? _t2.first()
|! _obj.add2rap(_root,'Brama',,exec('event_xor_txt','qporproc',_t2),1,'B'); exec('set_used','qporproc',,_t2)
!};
_obj.BPREL.cntx_pop(); _obj.CPREL.cntx_pop();
~~


\comp_evgate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie bram sterowanych zdarzeniami
::   WE: _a - obiekt danych
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_t1:=_obj.BPREL; _t2:=_obj.CPREL;
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'GATEKIND',,,'GATETYPE',,,'NAZWA',,);
_ind2:=_t2.ndx_tmp(,,'USED',,,'RODZAJ',,,'GATEKIND',,,'GATETYPE',,,'NAZWA',,);
_t1.index(_ind1);  _t2.index(_ind2);
::starowane zdarzeniami startowymi
exec('odp_evgate','qporproc',_obj.ROOTS.GATEVST,_obj,_t1,_t2,'XOR_EVENT');
::starowane zdarzeniami posrednimi
exec('odp_evgate','qporproc',_obj.ROOTS.GATEVPO,_obj,_t1,_t2,'EVENT');
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);
~~


::----------------------------------------------------------------------------------------------------------------------
:: porownywanie bram rozdzielajacych OR i XOR na podstawie warunkow
::----------------------------------------------------------------------------------------------------------------------


\gate_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary bram
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_wyn:=_obj.add2rap(_root,'Brama',exec('gate_txt','qporproc',_t1),exec('gate_txt','qporproc',_t2),,'B');
exec('set_used','qporproc',_t1,_t2);
exec('mk_bridge','qporproc',_t1,_t2);
{? _t1.GATETYPE<>_t2.GATETYPE || _obj.add2rap(_wyn,'Typ',_t1.GATETYPE,_t2.GATETYPE,1) ?};
{? _t1.NAZWA<>_t2.NAZWA || _obj.add2rap(_wyn,'Nazwa',_t1.NAZWA,_t2.NAZWA,1) ?};
_wyn


\gate_1write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych bramy z 1 procesu
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;

_wyn:=_obj.add2rap(_root,'Brama',exec('gate_txt','qporproc',_t1),,1,'B'); exec('set_used','qporproc',_t1);
_wyn


\gate_2write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych bramy z 2 procesu
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t2:=_c;

_wyn:=_obj.add2rap(_root,'Brama',,exec('gate_txt','qporproc',_t2),1,'B'); exec('set_used','qporproc',,_t2);
_wyn


\elem_write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Sparowanie i umieszczenie w raporcie elementow, jezeli sa podobne
::   WE: _a - obiekt danych
::       _b - tabela elementow procesu bazowego
::       _c - tabela elementow procesu porownywanego
::   WY: #ref do galezi dodanego elementu
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_t1:=_b;
_t2:=_c;

_odp:=0;
{? exec('comp_elem','qporproc',_t1,_t2)=1
|| {? (_t1.BRREF='') & (_t2.BRREF='') & (_t1.USED=0) & (_t2.USED=0)
   ||
      {? _t1.RODZAJ='B_ACTION'
      || _odp:=exec('act_12write','qporproc',_obj,_t1,_t2)
      |? (_t1.RODZAJ='B_EVENT') & (_t1.EVKATEG='przechwytujące') & (_t1.EVKIND='sygnał')
      || _odp:=exec('event_s_12write','qporproc',_obj.ROOTS.EVCAPSYG,_obj,_t1,_t2)
      |? (_t1.RODZAJ='B_EVENT') & (_t1.EVKATEG='rzucające') & (_t1.EVKIND='sygnał')
      || _odp:=exec('event_s_12write','qporproc',_obj.ROOTS.EVTHSYG,_obj,_t1,_t2)
      |? (_t1.RODZAJ='B_EVENT') & (_t1.EVKATEG='rzucające') & (_t1.EVKIND='komunikat')
      || _odp:=exec('event_s_12write','qporproc',_obj.ROOTS.EVTHEM,_obj,_t1,_t2)
      |? (_t1.RODZAJ='B_EVENT') & (_t1.EVKATEG='przechwytujące') & (_t1.EVKIND='warunkowe')
      || _odp:=exec('event_w_12write','qporproc',_obj.ROOTS.EVCAPWAR,_obj,_t1,_t2)
      |? (_t1.RODZAJ='B_EVENT') & (_t1.EVKATEG='przechwytujące') & (_t1.EVKIND='czasowe')
      || _odp:=exec('event_ti_12write','qporproc',_obj.ROOTS.EVTHTIP,_obj,_t1,_t2)
      ?}
   || _odp:=-1
   ?}
?};
_odp


\gate_out_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary wyjść z bramy
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi lacznika procesu bazowego
::       _d - tabela z danymi lacznika procesu porownywanego
::       [_g] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_fl1:=_c;
_fl2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_fl1.cntx_psh(); _fl2.cntx_psh();
_t1:=_obj.BPREL; _t2:=_obj.CPREL;
_t1.cntx_psh(); _t2.cntx_psh();
_t1.index(_obj.IREFBP);  _t2.index(_obj.IREFCP);
_t1.prefix(); _t2.prefix();
_t1.find_key(_fl1.DO,); _t2.find_key(_fl2.DO,);
_wyn:=_obj.add2rap(_root,'Wyjscie do'
   ,{? _fl1.DEFAULT='T' || '{domyślnie} ' || ' {nr:'+$_fl1.KOLEJ+'} ' ?}+exec('write_elem_txt','qporproc',_t1)
   ,{? _fl2.DEFAULT='T' || '{domyślnie} ' || ' {nr:'+$_fl2.KOLEJ+'} ' ?}+exec('write_elem_txt','qporproc',_t2));
{? _fl1.DEFAULT='T' || _obj.BGTOUTEL.ELEMREF:=_t1.REF; _obj.BGTOUTEL.WAR:='{domyślnie}'; _obj.BGTOUTEL.add() ?};
{? _fl2.DEFAULT='T' || _obj.CGTOUTEL.ELEMREF:=_t2.REF; _obj.CGTOUTEL.WAR:='{domyślnie}'; _obj.CGTOUTEL.add() ?};
::jezeli elementy na koncach identyczne (ale nie sa bramami) to umieszczenie na diagramie
exec('elem_write','qporproc',_obj,_t1,_t2);
_t1.cntx_pop(); _t2.cntx_pop();
exec('mk_bridge','qporproc',_fl1,_fl2);
::zaznaczenie ze wyjscie uzyte
_fl1.prefix(); _fl2.prefix();
_fl1.USED:=_fl2.USED:=_wyn; _fl1.put(); _fl2.put();
_fl1.cntx_pop(); _fl2.cntx_pop();
_fl1.get(); _fl2.get();
_wyn


\gate_out_1write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych wyjścia z bramy procesu bazowego
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi lacznika procesu bazowego
::       [_d] - czy zglaszac roznice [1]
::----------------------------------------------------------------------------------------------------------------------
{? (_<4) | (_d=~~) || _d:=1 ?};
_root:=_a;
_obj:=_b;
_fl1:=_c;
_zglos:=_d;

_t1:=_obj.BPREL;
_t1.cntx_psh();
_t1.index(_obj.IREFBP);
_t1.prefix();
_t1.find_key(_fl1.DO,);
_wyn:=_obj.add2rap(_root,'Wyjscie do'
   ,{? _fl1.DEFAULT='T' || '{domyślnie} ' || ' {nr:'+$_fl1.KOLEJ+'} ' ?}+exec('write_elem_txt','qporproc',_t1),,_zglos);
{? _fl1.DEFAULT='T' || _obj.BGTOUTEL.ELEMREF:=_t1.REF; _obj.BGTOUTEL.WAR:='{domyślnie}'; _obj.BGTOUTEL.add() ?};
::zaznaczenie ze wyjscie uzyte
_fl1.cntx_psh(); _fl1.prefix();
_fl1.USED:=_wyn; _fl1.put();
_fl1.cntx_pop();
_t1.cntx_pop();
_wyn


\gate_out_2write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych wyjścia z bramy procesu porównywanego
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi lacznika procesu porownywanego
::       [_d] - czy zglaszac roznice [1]
::----------------------------------------------------------------------------------------------------------------------
{? (_<4) | (_d=~~) || _d:=1 ?};
_root:=_a;
_obj:=_b;
_fl2:=_c;
_zglos:=_d;

_t2:=_obj.CPREL;
_t2.cntx_psh();
_t2.index(_obj.IREFCP);
_t2.prefix();
_t2.find_key(_fl2.DO,);
_wyn:=_obj.add2rap(_root
   ,'Wyjście do'
   ,,{? _fl2.DEFAULT='T' || '{domyślnie} ' || ' {nr:'+$_fl2.KOLEJ+'} ' ?}+exec('write_elem_txt','qporproc',_t2),_zglos);
{? _fl2.DEFAULT='T' || _obj.CGTOUTEL.ELEMREF:=_t2.REF; _obj.CGTOUTEL.WAR:='{domyślnie}'; _obj.CGTOUTEL.add() ?};
::zaznaczenie ze wyjscie uzyte
_fl2.cntx_psh(); _fl2.prefix();
_fl2.USED:=_wyn; _fl2.put();
_fl2.cntx_pop();
_t2.cntx_pop();
_wyn


\com_elem4choice
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Wstepne sparowanie warunkow
::       Dodatkowo sprawdzenie, czy elementy, na ktorych w obu procesach oparte sa warunki sa podobne
::       Jezeli tak i nie są sparowane, to sparowanie i dodanie do odpowiedniej galezi drzewa
::   WE: _a - tebela z warunkiem z procesu bazowego
::       _b - tebela z warunkiem z procesu porownywanego
::       _c - obiekt danych
::   WY: #ref do galezi dodanego elementu
::----------------------------------------------------------------------------------------------------------------------
_war1:=_a;
_war2:=_b;
_obj:=_c;

_odp:=0;
_t1:=_obj.BPREL;
_t2:=_obj.CPREL;
_t1.cntx_psh(); _t2.cntx_psh();
_t1.index(_obj.IREFBP); _t1.prefix();
_t2.index(_obj.IREFCP); _t2.prefix();
exec('mk_bridge','qporproc',_war1,_war2);
_obj.ZMIANA+=1;
{? (_war1.WAROD<>'') & _t1.find_key(_war1.WAROD,) & (_war2.WAROD<>'') & _t2.find_key(_war2.WAROD,)
|| _odp:=exec('elem_write','qporproc',_obj,_t1,_t2)
?};
_t1.cntx_pop(); _t2.cntx_pop();
_odp


\comp_choice6
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie warunkow na bramach rozdzielajacych
::   WE: _a - tabela pierwsza
::       _b - tabela 2
::       _c - obiekt danych
::       _d - tabela porownan otoczenia
::----------------------------------------------------------------------------------------------------------------------
_t1:=_a;
_t2:=_b;
_obj:=_c;
_otocz:=_d;

_t2.prefix(0,0,_t1.FORMULA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('com_elem4choice','qporproc',_t1,_t2,_obj,_otocz)
   || exec('comp_choice5','qporproc',_t1,_t2,_obj,_otocz)
   ?}
?}


\comp_choice5
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie warunkow na bramach rozdzielajacych
::   WE: _a - tabela pierwsza
::       _b - tabela 2
::       _c - obiekt danych
::       _d - tabela porownan otoczenia
::----------------------------------------------------------------------------------------------------------------------
_t1:=_a;
_t2:=_b;
_obj:=_c;
_otocz:=_d;

_t2.prefix(0,0,_t1.FORMULA,_t1.KIND,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('com_elem4choice','qporproc',_t1,_t2,_obj,_otocz)
   || exec('comp_choice4','qporproc',_t1,_t2,_obj,_otocz)
   ?}
?}


\comp_choice4
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie warunkow na bramach rozdzielajacych
::   WE: _a - tabela pierwsza
::       _b - tabela 2
::       _c - obiekt danych
::       _d - tabela porownan otoczenia
::----------------------------------------------------------------------------------------------------------------------
_t1:=_a;
_t2:=_b;
_obj:=_c;
_otocz:=_d;

_t2.prefix(0,0,_t1.FORMULA,_t1.KIND,_t1.CASE_SEN,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('com_elem4choice','qporproc',_t1,_t2,_obj,_otocz)
   || exec('comp_choice3','qporproc',_t1,_t2,_obj,_otocz)
   ?}
?}


\comp_choice3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie warunkow na bramach rozdzielajacych
::   WE: _a - tabela pierwsza
::       _b - tabela 2
::       _c - obiekt danych
::       _d - tabela porownan otoczenia
::----------------------------------------------------------------------------------------------------------------------
_t1:=_a;
_t2:=_b;
_obj:=_c;
_otocz:=_d;

_t2.prefix(0,0,_t1.FORMULA,_t1.KIND,_t1.CASE_SEN,_t1.WARNAME,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('com_elem4choice','qporproc',_t1,_t2,_obj,_otocz)
   || exec('comp_choice2','qporproc',_t1,_t2,_obj,_otocz)
   ?}
?}


\comp_choice2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie warunkow na bramach rozdzielajacych
::   WE: _a - tabela pierwsza
::       _b - tabela 2
::       _c - obiekt danych
::       _d - tabela porownan otoczenia
::----------------------------------------------------------------------------------------------------------------------
_t1:=_a;
_t2:=_b;
_obj:=_c;
_otocz:=_d;

_t2.prefix(0,0,_t1.FORMULA,_t1.KIND,_t1.CASE_SEN,_t1.WARNAME,_t1.NAME,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('com_elem4choice','qporproc',_t1,_t2,_obj,_otocz)
   || exec('comp_choice1','qporproc',_t1,_t2,_obj,_otocz)
   ?}
?}


\comp_choice1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie warunkow na bramach rozdzielajacych
::   WE: _a - tabela warunkow procesu bazowego
::       _b - tabela warunkow procesu porownywanego
::       _c - obiekt danych
::       _d - tabela porownan otoczenia
::----------------------------------------------------------------------------------------------------------------------
_war1:=_a;
_war2:=_b;
_obj:=_c;
_otocz:=_d;

_e1:=_obj.BPREL;
_e2:=_obj.CPREL;
_e1.cntx_psh(); _e2.cntx_psh();
_e1.index(_obj.IREFBP); _e1.prefix();
_e2.index(_obj.IREFCP); _e2.prefix();
::poszukanie warunku najbardziej zbiozonego pod względem:
::-podobienstwa elementu z ktorego bieze dane do warunku
::-podobienstwa elementu do ktorego prowadzi lacznik
::-podobieństwo bezposredniego otoczenia bramy
_war2.prefix(0,0,_war1.FORMULA,_war1.KIND,_war1.CASE_SEN,_war1.WARNAME,_war1.NAME,);
_tab:=tab_tmp(4
   ,'WAROD','INTEGER','Czy taki sam element od ktorego pochodzi warunek'
   ,'DO','INTEGER','Czy taki sam element od ktorego idzie lacznik'
   ,'OTOCZ','REAL','Podobienstwo otoczenia bramy'
   ,'ROLA','INTEGER','Czy taka sama rola bram'
   ,'WAR2','STRING[16]','_war2.ref()'
   );
{? _war2.first()
|| {!
   |?
      _tab.blank();
      _tab.WAR2:=$_war2.ref();
      _tab.WAROD:=(_war1.WAROD<>'') & _e1.find_key(_war1.WAROD,) & (_war2.WAROD<>'') & _e2.find_key(_war2.WAROD,)
         & (exec('comp_elem','qporproc',_e1,_e2)=1);
      _tab.DO:=(_war1.DO<>'') & _e1.find_key(_war1.DO,) & (_war2.DO<>'') & _e2.find_key(_war2.DO,)
         & (exec('comp_elem','qporproc',_e1,_e2)=1);
      {? (_war1.OD<>'') & _e1.find_key(_war1.OD,) & (_war2.OD<>'') & _e2.find_key(_war2.OD,)
      || _tab.OTOCZ:={? _otocz.find_key(_e1.REF,_e2.REF) || _otocz.OTO || 0 ?};
         _tab.ROLA:=_e1.ROLA=_e2.ROLA
      ?};
      _tab.add();
      _war2.next()
   !};
   _tab.last();
   _wyn:='';
   _tab.prefix(_tab.WAROD);
   {? _tab.size()=1
   || _wyn:=_tab.WAR2
   || _tab.prefix(_tab.WAROD,_tab.DO);
      {? _tab.size()=1
      || _wyn:=_tab.WAR2
      || _tab.prefix(_tab.WAROD,_tab.DO,_tab.OTOCZ);
         {? _tab.size()=1
         || _wyn:=_tab.WAR2
         || _tab.prefix(_tab.WAROD,_tab.DO,_tab.OTOCZ,_tab.ROLA);
            {? _tab.size()=1 || _wyn:=_tab.WAR2 ?}
         ?}
      ?}
   ?};
   {? (_wyn<>'') & _war2.seek(_wyn,) || exec('com_elem4choice','qporproc',_war1,_war2,_obj) ?}
?};
&_tab;
_e1.cntx_pop(); _e2.cntx_pop();
~~


\choice_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych warunku
::       Zapisywana jest tez galaz z elementami na ktorych budowany jest warunek
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi warunku procesu bazowego
::       _d - tabela z danymi warunku procesu porownywanego
::       [_g] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi warunku drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_cho1:=_c;
_cho2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_cho1.cntx_psh(); _cho2.cntx_psh();
_t1:=_obj.BPREL; _t2:=_obj.CPREL;
_t1.cntx_psh(); _t2.cntx_psh();
_t1.index(_obj.IREFBP); _t2.index(_obj.IREFCP);
_wyn:=_obj.add2rap(_root
   ,'Warunek na wyjściu',exec('write_choice_txt','qporproc',_cho1),exec('write_choice_txt','qporproc',_cho2));
exec('mk_bridge','qporproc',_cho1,_cho2);
::zaznaczenie ze wyjscie uzyte
_cho1.prefix(); _cho2.prefix();
_cho1.USED:=_cho2.USED:=_wyn; _cho1.put(); _cho2.put();
_t1.prefix(); _t2.prefix();
_t1.find_key(_cho1.WAROD,); _t2.find_key(_cho2.WAROD,);
_obj.add2rap(_wyn,'Na podstawie elementu',exec('write_elem_txt','qporproc',_t1),exec('write_elem_txt','qporproc',_t2));
::sprawdzenie podobienctwa elementow, na ktoryh oparty jest warunek i ewentualne dopisanie do odpowiedniej galezi drzewa
exec('com_elem4choice','qporproc',_cho1,_cho2,_obj);
_t1.cntx_pop(); _t2.cntx_pop();
_cho1.cntx_pop(); _cho2.cntx_pop();
_cho1.get(); _cho2.get();
_wyn


\choice_1write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych warunku
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi warunku procesu bazowego
::       [_d] - czy zglaszac roznice [1]
::   WY: ref gałęzi warunku drzewie
::----------------------------------------------------------------------------------------------------------------------
{? (_<4) | (_d=~~) || _d:=1 ?};
_root:=_a;
_obj:=_b;
_cho1:=_c;
_zglos:=_d;

_cho1.cntx_psh();
_t1:=_obj.BPREL;
_t1.cntx_psh();
_t1.index(_obj.IREFBP);
_wyn:=_obj.add2rap(_root,'Warunek na wyjściu',exec('write_choice_txt','qporproc',_cho1),,_zglos);
::zaznaczenie ze wyjscie uzyte
_cho1.prefix();
_cho1.USED:=_wyn; _cho1.put();
_t1.prefix();
_t1.find_key(_cho1.WAROD,);
_obj.add2rap(_wyn,'Na podstawie elementu',exec('write_elem_txt','qporproc',_t1));
_t1.cntx_pop();
_cho1.cntx_pop();
_cho1.get();
_wyn


\choice_2write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych warunku
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi warunku procesu porownywanego
::       [_d] - czy zglaszac roznice [1]
::   WY: ref gałęzi warunku drzewie
::----------------------------------------------------------------------------------------------------------------------
{? (_<4) | (_d=~~) || _d:=1 ?};
_root:=_a;
_obj:=_b;
_cho2:=_c;
_zglos:=_d;

_cho2.cntx_psh();
_t2:=_obj.CPREL;
_t2.cntx_psh();
_t2.index(_obj.IREFCP);
_wyn:=_obj.add2rap(_root,'Warunek na wyjściu',,exec('write_choice_txt','qporproc',_cho2),_zglos);
::zaznaczenie ze wyjscie uzyte
_cho2.prefix();
_cho2.USED:=_wyn; _cho2.put();
_t2.prefix();
_t2.find_key(_cho2.WAROD,);
_obj.add2rap(_wyn,'Na podstawie elementu',,exec('write_elem_txt','qporproc',_t2));
_t2.cntx_pop();
_cho2.cntx_pop();
_cho2.get();
_wyn


::......................................................................................................................
:: porownywanie warunkow na bramach
::......................................................................................................................


\comp_one2one
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie warunkow na pewniaka - tylko wtedy, gdy w obu procesach jest tylko po jednym warunku
::       o identycznej formule
::   WE: _a - obiekt
::       _b - tabela warunkow procesu bazowego
::       _c - tabela warunkow procesu porownywanego
::       _d - tabela porownan otoczenia
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_t1:=_b;
_t2:=_c;
_otocz:=_d;

_t1.prefix(0,0); _t2.prefix(0,0);
{? _t1.first()
|| {!
   |?
      _t1.cntx_psh();
      _pzm:=_obj.ZMIANA;
      _t1.prefix(0,0,_t1.FORMULA,); _t1.first();
      {? _t1.size()=1
      || exec('comp_choice6','qporproc',_t1,_t2,_obj,_otocz)
      || _t1.prefix(0,0,_t1.FORMULA,_t1.KIND,);
         {? _t1.size()=1
         || exec('comp_choice5','qporproc',_t1,_t2,_obj,_otocz)
         || _t1.prefix(0,0,_t1.FORMULA,_t1.KIND,_t1.CASE_SEN,);
            {? _t1.size()=1
            || exec('comp_choice4','qporproc',_t1,_t2,_obj,_otocz)
            || _t1.prefix(0,0,_t1.FORMULA,_t1.KIND,_t1.CASE_SEN,_t1.WARNAME,);
               {? _t1.size()=1
               || exec('comp_choice3','qporproc',_t1,_t2,_obj,_otocz)
               || _t1.prefix(0,0,_t1.FORMULA,_t1.KIND,_t1.CASE_SEN,_t1.WARNAME,_t1.NAME,);
                  {? _t1.size()=1
                  || exec('comp_choice2','qporproc',_t1,_t2,_obj,_otocz)
                  || exec('comp_choice1','qporproc',_t1,_t2,_obj,_otocz)
                  ?}
               ?}
            ?}
         ?}
      ?};
      _t1.cntx_pop();
      {? _pzm=_obj.ZMIANA || _t1.next() || _t1.prefix(0,0); _t1.first() ?}
   !}
?};
~~


\find_gate2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: wyszukanie bramy w 2 procesie, ktora ma najwiecej warunkow powiazanych z biezaca _gates1
::   WE: _a - REF elementu bramy w procesie bazowym, dla ktorej poszukiwana jest brama w porownywanym
::       _b - obiekt danych
::       _c - tabela z warunkami procesie bazowym
::       _d - tabela z warunkami procesie porownywanym
::       _e - indeks do tabeli t1
::       _f - indeks do tabeli t2
::       _g - tabela z informacjami o otoczeniu
::   WY: #ref elementu w procesie porownywanym, ktory odpowiada bramie w procesie bazowym
::----------------------------------------------------------------------------------------------------------------------
_gate1:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
_ind21:=_e;
_ind22:=_f;
_otocz:=_g;

::pobranie danych powiazanych warunkow, ktore nie sa jeszcze w wynikach
_sql:='select T1.CONREF BCON, T1.REF BWAR, T2.BRAMA CBRAMA, T2.CONREF CCON, T2.REF CWAR from :_a as T1 '
      +' join :_b as T2 using(T1.BRREF,T2.REF) '
      +' where (T1.BRAMA=\':_c\') and (T1.BRREF<>\'\') and (T2.USED=0) '
      +' order by CBRAMA, CCON, CWAR ';
_wars:=sql(_sql,_t1,_t2,_gate1);
_warssiz:=_wars.size();
::lista bram na ktorych sa znalezione warunki odpowiadajace
_gates2:=sql('select distinct CBRAMA from :_a order by CBRAMA',_wars);
::znalezienie w _gates2 rekordu, na ktorym jest najwiecej zgodnych warunkow z _gates1
_podwar:=tab_tmp(2
   ,'WSPWAR','REAL','Współczynnik podobieństwa warunkow'
   ,'WSPOLCZ','REAL','Współczynnik podobieństwa otoczenia'
   ,'CELEM','INTEGER','#CPREL.ref'
   );
_maxref:=null();
{? _gates2.first()
|| {!
   |? _wars.prefix(_gates2.CBRAMA,);
      _podwar.WSPWAR:=2*_wars.size()/(_warssiz+_wars.size());
      {? _otocz.find_key(_gate1,_gates2.CBRAMA) || _podwar.WSPOLCZ:=_otocz.OTO ?};
      _podwar.CELEM:=#_gates2.ref();
      _podwar.add();
      _gates2.next()
   !}
?};
{? _podwar.last() || _maxref:=_podwar.CELEM ?};
&_podwar;
_wars.prefix();
{? (_maxref<>0) & _gates2.seek(_maxref,)
||
   _odp:=_gates2.CBRAMA;
:: po wybraniu bramy _gates2 odpowiadajacej _gates1
:: na ewentualnych innych polaczeniach powiazaneych z _gates1 zerowanie mostu, bo tylko prawdziwe sa te
:: z wybranej gates2
   _t1.cntx_psh(); _t1.index(_ind21); _t1.prefix();
   _t2.cntx_psh(); _t2.index(_ind22); _t2.prefix();
   {? _wars.first()
   || {!
      |?
         {? (_wars.CBRAMA<>_gates2.CBRAMA) & _t1.find_key(_wars.BWAR,) & _t2.find_key(_wars.CWAR,)
         || _t1.BRREF:=_t2.BRREF:=''; _t1.BRIDGE:=_t2.BRIDGE:=0; _t1.put(); _t2.put();
            _wars.del()
         || _wars.next()
         ?}
      !}
   ?};
:: ewentualne zerowanie mostow na innych polaczeniach z bramy 2, jezeli nie dotycza bramy 1
   _sql:='select T2.BRAMA CBRAMA, T2.CONREF CCON, T2.REF CWAR, T1.REF BWAR from :_a as T2 '
      +' join :_b as T1 using(T2.BRREF,T1.REF) '
      +' where (T2.BRAMA=\':_c\') and (T2.BRREF<>\'\') and (T2.USED=0) and (T1.USED=0) and (T1.BRAMA<>\':_d\') '
      +' order by CBRAMA, CCON, CWAR ';
   _warc:=sql(_sql,_t2,_t1,_odp,_gate1);
   {? _warc.first()
   || {!
      |? {? _t1.find_key(_warc.BWAR,) & _t2.find_key(_warc.CWAR,)
         || _t1.BRREF:=_t2.BRREF:=''; _t1.BRIDGE:=_t2.BRIDGE:=0; _t1.put(); _t2.put()
         ?};
         _warc.next()
      !}
   ?};
   obj_del(_warc);
   _t1.cntx_pop(); _t2.cntx_pop()
|| _odp:=''
?};
obj_del(_gates2);
obj_del(_wars);
_odp


\comp_default_flow
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Powiazanie wyjsc domyslnych na obu bramach
::   WE: _a - obiekt
::       _b - tabela polaczen z tej bramy w procesie bazowym
::       _c - tabela polaczen z tej bramy w procesie porownywanym
::       _d - galaz, do ktorej nalezy polaczyc
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_fl1:=_b;
_fl2:=_c;
_brroot:=_d;

{? _fl1.first() & _fl2.first() || exec('gate_out_12write','qporproc',_brroot,_obj,_fl1,_fl2)
|? _fl1.first() || exec('gate_out_1write','qporproc',_brroot,_obj,_fl1)
|? _fl2.first() || exec('gate_out_2write','qporproc',_brroot,_obj,_fl2)
?}


\out_1write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Jednostronny zapis danych wyjscia i wszystkich warunkow na tym wyjsciu
::   WE: _a - konar z danymi bramy
::       _b - obiekt danych
::       _c - tabela wyjsc
::       _d - tabela warunkow
::       _e - indeks tabeli warunkow
::       [_f] - czy zglaszac roznice [1]
::----------------------------------------------------------------------------------------------------------------------
{? (_<6) | (_f=~~) || _f:=1 ?};
_brroot:=_a;
_obj:=_b;
_fl1:=_c;
_t1:=_d;
_ind:=_e;
_zglos:=_f;

_cone:=_fl1.REF;
::zapisanie jesdnstronne wyjscia
_flroot:=exec('gate_out_1write','qporproc',_brroot,_obj,_fl1,_zglos);
::zapisanie jednostronne wszystkich warunkow
_t1.index(_ind); _t1.prefix(_cone,0);
{! |? _t1.first() |! exec('choice_1write','qporproc',_flroot,_obj,_t1,_zglos) !};
~~


\out_2write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Jednostronny zapis danych wyjscia i wszystkich warunkow na tym wyjsciu
::   WE: _a - konar z danymi bramy
::       _b - obiekt danych
::       _c - tabela wyjsc
::       _d - tabela warunkow
::       _e - indeks tabeli warunkow
::       [_f] - czy zglaszac roznice [1]
::----------------------------------------------------------------------------------------------------------------------
{? (_<6) | (_f=~~) || _f:=1 ?};
_brroot:=_a;
_obj:=_b;
_fl2:=_c;
_t2:=_d;
_ind:=_e;
_zglos:=_f;

_cone:=_fl2.REF;
::zapisanie jesdnstronne wyjscia
_flroot:=exec('gate_out_2write','qporproc',_brroot,_obj,_fl2,_zglos);
::zapisanie jednostronne wszystkich warunkow
_t2.index(_ind); _t2.prefix(_cone,0);
{! |? _t2.first() |! exec('choice_2write','qporproc',_flroot,_obj,_t2,_zglos) !};
~~


\comp_gate3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie bram rozdzielajacych
::   WE: _a - tabela bram 1
::       _b - tabela bram 2
::       _c - obiekt danych
::       _d - tabela elementow 1
::       _e - tabela elementow 2
::       _f - tabela otoczenia
::   WY: obiekt z 2 polami
::       ROOT - #ref do elementu drzewa, na ktorym powstal zapis o bramach, gdy nie bedzie sparowania to 0
::       REF - $ref bramy sparowanej z 2 procesu
::----------------------------------------------------------------------------------------------------------------------
_t1:=_a;
_t2:=_b;
_obj:=_c;
_el1:=_d;
_el2:=_e;
_otocz:=_f;

_root:=_obj.ROOTS.GATEMULT;
_t2.prefix();
{? _t2.first()
|| {? _t2.size()=1
   || _el2.find_key(_t2.REF,);
      _wy:=obj_new('ROOT','REF');
      _wy.ROOT:=exec('gate_12write','qporproc',_root,_obj,_el1,_el2); _t2.del();
      _wy.REF:=_el2.REF
   || _wy:=exec('comp_gate2','qporproc',_t1,_t2,_obj,_el1,_el2,_otocz)
   ?}
|| exec('gate_1write','qporproc',_root,_obj,_el1);
   _wy:=obj_new('ROOT','REF'); _wy.ROOT:=0
?};
_wy


\comp_gate2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie bram rozdzielajacych
::   WE: _a - tabela bram 1
::       _b - tabela bram 2
::       _c - obiekt danych
::       _d - tabela elementow 1
::       _e - tabela elementow 2
::       _f - tabela otoczenia
::   WY: obiekt z 2 polami
::       ROOT - #ref do elementu drzewa, na ktorym powstal zapis o bramach, gdy nie bedzie sparowania to 0
::       REF - $ref bramy sparowanej z 2 procesu
::----------------------------------------------------------------------------------------------------------------------
_t1:=_a;
_t2:=_b;
_obj:=_c;
_el1:=_d;
_el2:=_e;
_otocz:=_f;

_root:=_obj.ROOTS.GATEMULT;
_t2.prefix(_t1.GATETYPE,);
{? _t2.first()
|| {? _t2.size()=1
   || _el2.find_key(_t2.REF,);
      _wy:=obj_new('ROOT','REF');
      _wy.ROOT:=exec('gate_12write','qporproc',_root,_obj,_el1,_el2); _t2.del();
      _wy.REF:=_el2.REF
   || _wy:=exec('comp_gate1','qporproc',_t1,_t2,_obj,_el1,_el2,_otocz)
   ?}
|| exec('gate_1write','qporproc',_root,_obj,_el1);
   _wy:=obj_new('ROOT','REF'); _wy.ROOT:=0
?};
_wy


\comp_gate_oto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie najblizszego otoczenia bram
::   WE: _a - obiekt danych
::       _b - korzeń
::       _c - tabela bram 1
::       _d - tabela bram 2
::       _e - tabela elementow 1
::       _f - tabela elementow 2
::       _g - tabela ze wspolczynnikami odobienstwa otoczenia
::   WY: obiekt z 2 polami
::       ROOT - #ref do elementu drzewa, na ktorym powstal zapis o bramach, gdy nie bedzie sparowania to 0
::       REF - $ref bramy sparowanej z 2 procesu
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_root:=_b;
_gates1:=_c;
_gates2:=_d;
_el1:=_e;
_el2:=_f;
_otocz:=_g;

_wy:=obj_new('ROOT','REF'); _wy.ROOT:=0;
_gates2.prefix(_gates1.GATETYPE,_gates1.NAZWA,);
{? _gates2.first()
|| _oto:=tab_tmp(2
      ,'OTOCZ','REAL','Współczynnik otoczenia'
      ,'REF2','STRING[16]','$ref elementu w 2 procesie'
      ,'GAT2','STRING[16]','$_gates2.ref()'
      );
   {!
   |?
      {? _el2.find_key(_gates2.REF,)
      || {? _otocz.find_key(_gates1.REF,_el2.REF) || _oto.OTOCZ:=_otocz.OTO ?};
         _oto.REF2:=_gates2.REF;
         _oto.GAT2:=$_gates2.ref;
         _oto.add()
      ?};
      _gates2.next()
   !};
   {? _oto.last()
   || _oto.prefix(_oto.OTOCZ);
      {? _oto.size()=1
      || _el2.find_key(_oto.REF2,); _gates2.seek(_oto.GAT2);
         _wy.ROOT:=exec('gate_12write','qporproc',_root,_obj,_el1,_el2);
         _wy.REF:=_el2.REF;
         _gates2.del()
      || exec('gate_1write','qporproc',_root,_obj,_el1)
      ?}
   || exec('gate_1write','qporproc',_root,_obj,_el1)
   ?};
   &_oto
|| exec('gate_1write','qporproc',_root,_obj,_el1)
?};
_wy


\comp_gate1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie bram rozdzielajacych
::   WE: _a - tabela bram 1
::       _b - tabela bram 2
::       _c - obiekt danych
::       _d - tabela elementow 1
::       _e - tabela elementow 2
::       _f - tabela otoczenia
::   WY: obiekt z 2 polami
::       ROOT - #ref do elementu drzewa, na ktorym powstal zapis o bramach, gdy nie bedzie sparowania to 0
::       REF - $ref bramy sparowanej z 2 procesu
::----------------------------------------------------------------------------------------------------------------------
_t1:=_a;
_t2:=_b;
_obj:=_c;
_el1:=_d;
_el2:=_e;
_otocz:=_f;

_root:=_obj.ROOTS.GATEMULT;
_t2.prefix(_t1.GATETYPE,_t1.NAZWA,);
{? _t2.first()
|| {? _t2.size()=1
   || _el2.find_key(_t2.REF,);
      _wy:=obj_new('ROOT','REF');
      _wy.ROOT:=exec('gate_12write','qporproc',_root,_obj,_el1,_el2); _t2.del();
      _wy.REF:=_el2.REF
   || _wy:=exec('comp_gate_oto','qporproc',_obj,_root,_t1,_t2,_el1,_el2,_otocz)
   ?}
|| _wy:=obj_new('ROOT','REF'); _wy.ROOT:=0;
   exec('gate_1write','qporproc',_root,_obj,_el1)
?};
_wy


\comp_dflt4gate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie wyjsc domyslnych z bram
::   WE: _a - objekt
::       _b - korzen bram
::       _c - $ref bramy 1 procesu
::       _d - $ref bramy 2 procesu
::       _e - wyjscia procesu 1
::       _f - wyjscia procesu 2
::       _g - indeks dla wyjsc z bramy 1
::       _h - indeks dla wyjsc z bramy 2
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_brroot:=_b;
_bbrama:=_c;
_cbrama:=_d;
_fl1:=_e;
_fl2:=_f;
_lndf1:=_g;
_lndf2:=_h;

_fl1.index(_lndf1); _fl1.prefix(_bbrama,'T',0);
_fl2.index(_lndf2); _fl2.prefix(_cbrama,'T',0);
exec('comp_default_flow','qporproc',_obj,_fl1,_fl2,_brroot);
~~


\find_podob_out
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Poszukanie podobnego wyjscia z bramy w 2 procesie
::   WE:
::       _a - $ref bramy 2 procesu
::       _b - wyjscia procesu 1
::       _c - wyjscia procesu 2
::       _d - indeks dla wyjsc z bramy 2 nr 12
::       _e - indeks dla wyjsc z bramy 2 nr 2
::       _f - tabela elementow procesu 1
::       _g - tabela elementow procesu 2
::       _h - tabela warunkow na wyjsciu z 2
::       _i - indeks tabeli warunkow na wyjsciu z 2
::   WY: $ref wyjscia pasujacego lub ''
::----------------------------------------------------------------------------------------------------------------------
_cbrama:=_a;
_fl1:=_b;
_fl2:=_c;
_lndf12:=_d;
_lndf2:=_e;
_el1:=_f;
_el2:=_g;
_t2:=_h;
_ind32:=_i;

_fl2.index(_lndf2); _fl2.prefix(_cbrama,'N',0);
_el1.prefix(); _el1.find_key(_fl1.DO,);
_el2.prefix();
_t2.index(_ind32);
::wyzszy priorytet ma to, czy wyjscie prowadzi do podobnego elementu
_podobf2:=tab_tmp(2
   ,'DO','INTEGER','Podobny docelowy'
   ,'LWAR','INTEGER','Liczba warunkow'
   ,'REF','STRING[16]','FL2.ref'
   );
{? _fl2.first()
|| {!
   |?
      _el2.find_key(_fl2.DO,);
      _podobf2.REF:=_fl2.REF;
      {? (_el1.BRREF<>'') & (_el1.BRREF=_el2.REF)
      || _podobf2.DO:=2
      ||
::       w przypadku, gdy wyjscie prowadzi do bramy zbierajacej zwyklej
::       to sprawdzenie jaki element jest bezpozrednio za nia
         _rb:=exec('czy_join_oxa','qporproc',_el1);
         {? (_rb<>'') & (_rb=exec('czy_join_oxa','qporproc',_el2))
         || _rel1:=exec('next_el','qporproc',_el1.REF,_fl1); _rel2:=exec('next_el','qporproc',_el2.REF,_fl2);
            {? (_rel1<>'') & (_rel2<>'') || _el1.find_key(_rel1) & _el2.find_key(_rel2) ?}
         ?};
         _wyn:=exec('comp_elem','qporproc',_el1,_el2);
         _podobf2.DO:=_wyn;
         _t2.prefix(_fl2.REF,0); _podobf2.LWAR:=_t2.size()
      ?};
      _podobf2.add();
      (_podobf2.DO<>2) & _fl2.next()
   !}
?};
_fl2.index(_lndf12); _fl2.prefix();
_podobf2.last();
_ref:={? _podobf2.size=1
      || _podobf2.REF
      |? (_podobf2.size()>0) & (_podobf2.DO<>-1)
      || _podobf2.prefix(_podobf2.DO);
         {? _podobf2.size()=1
         || _podobf2.REF
         || _podobf2.prefix(_podobf2.DO,_podobf2.LWAR);
            {? _podobf2.size()=1
            || _podobf2.REF
            || ''
            ?}
         ?}
      || ''
      ?};
&_podobf2;
_ref


\comp_choice
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie warunkow na bramach rozdzielajacych
::       tworzenie powiazan wylacznie wtedy, gdy na podstawie warunkow da sie to zrobic
::   WE: _a - objekt
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_t1:=_obj.BCHOICE; _t2:=_obj.CCHOICE;
_el1:=_obj.BPREL; _el2:=_obj.CPREL;
_fl1:=_obj.BCONN; _fl2:=_obj.CCONN;
_t1.cntx_psh(); _t2.cntx_psh();
_el1.cntx_psh(); _el2.cntx_psh();
_el1.index(_obj.IREFBP); _el2.index(_obj.IREFCP);
_el1.prefix(); _el2.prefix();
_fl1.cntx_psh(); _fl2.cntx_psh();
::indeksy robocze na tabeli warunkow
_ind1:=_t1.ndx_tmp(,,'USED',,,'BRIDGE',,,'FORMULA',,,'KIND',,,'CASE_SEN',,,'WARNAME',,,'NAME',,,'ROLA',,,'WARORDER',,);
_ind2:=_t2.ndx_tmp(,,'USED',,,'BRIDGE',,,'FORMULA',,,'KIND',,,'CASE_SEN',,,'WARNAME',,,'NAME',,,'ROLA',,,'WARORDER',,);
_ind11:=_t1.ndx_tmp(,,'USED',,,'BRAMA',,,'FORMULA',,,'KOLEJ',,);
_ind12:=_t2.ndx_tmp(,,'USED',,,'BRAMA',,,'FORMULA',,,'KOLEJ',,);
_ind21:=_t1.ndx_tmp(,,'REF',,,'BRAMA',,,'KOLEJ',,);
_ind22:=_t2.ndx_tmp(,,'REF',,,'BRAMA',,,'KOLEJ',,);
_ind31:=_t1.ndx_tmp(,,'CONREF',,,'USED',,,'KOLEJ',,,'FORMULA',,);
_ind32:=_t2.ndx_tmp(,,'CONREF',,,'USED',,,'KOLEJ',,,'FORMULA',,);
::indeksy robocze na polaczeniach
_lndf1:=_fl1.ndx_tmp(,,'OD',,,'DEFAULT',,,'USED',,,'KOLEJ',,);
_lndf2:=_fl2.ndx_tmp(,,'OD',,,'DEFAULT',,,'USED',,,'KOLEJ',,);
_lndf11:=_fl1.ndx_tmp(,,'REF',,);
_lndf12:=_fl2.ndx_tmp(,,'REF',,);
::przygotowanie dodatkowej tabeli ze wspolczynnikami dopasowania otoczenia bram
_sql:='select * from :_a '
   +' where (USED=0) and (BRIDGE=0) and (RODZAJ=\'B_GATE\') and (GATEKIND=\'<\') '
   +' and ((GATETYPE=\'OR\') or (GATETYPE=\'XOR\')) '
   +' order by REF ';
_otocz:=exec('mk_otocz','qporproc',_obj.ROOTS.GATEMULT,_obj,"0",_sql);
::porownywanie warunkow na bramach i dopasowywanie bram n podstawie podobienstwa warunkow
::petla chodzi tak dlugo, jak dlugo podczas pojedynczej iteracji dojdzie do chociaz jednego powiazania
{!
|?
   _obj.ZMIANA:=0;
   _t1.index(_ind1); _t2.index(_ind2);
   _t1.prefix(0,0); _t2.prefix(0,0);
:: zestawianie podobnych warunkow formulowych tylko na pewniaka - jezeli sa po jednym w kazdym procesie
   exec('comp_one2one','qporproc',_obj,_t1,_t2,_otocz);
:: ustalenie bram, dla ktorych udalo sie zestawic przynajmniej jeden warunek
   _gates1:=sql('select distinct BRAMA from :_a where (BRIDGE>0) and (USED=0) order by 1',_t1);
   _root:=_obj.ROOTS.GATEMULT;
:: przeglad bram ze sparowanymi warunkami i wiązanie z bramami odpowiadajcymi w 2 procesie
   {? _gates1.first()
   ||
      {!
      |?
         _bbrama:=_gates1.BRAMA;
         _cbrama:=exec('find_gate2','qporproc',_bbrama,_obj,_t1,_t2,_ind21,_ind22,_otocz);
         {? (_cbrama<>'') & _el1.find_key(_bbrama,) & _el2.find_key(_cbrama,)
         ||
::          utworzenie zapisu w wynikach dla bramm jako odpowiadajacych sobie
            _brroot:=exec('gate_12write','qporproc',_root,_obj,_el1,_el2);
            {? _brroot>0
            ||
::             sparowanie wyjsc domyslnych na porownywanych bramach
               exec('comp_dflt4gate','qporproc',_obj,_brroot,_bbrama,_cbrama,_fl1,_fl2,_lndf1,_lndf2);
::             przeglad i rejestracja pozostalych wyjsc z obu bram
               _fl1.index(_lndf1); _fl1.prefix(_bbrama,'N',0);
               _fl2.index(_lndf2); _fl2.prefix(_cbrama,'N',0);
::             petla po wyjsciach z bramy _bbrama
               {!
               |? _fl1.first()
               |!
::                ustalenie wyjscia odpowiadajacego, na podstawie pasujacego warunku
                  _bcone:=_fl1.REF;
                  _fl1.cntx_psh(); _fl2.cntx_psh();
                  _t1.cntx_psh(); _t2.cntx_psh();
                  _t2.index(_ind12);
                  _t1.index(_ind31); _t1.prefix(_bcone,0);
                  {? _t1.first()
                  ||
::                   ustalenie wyjscia na bramie 2 procesu, na ktorym jest najbardziej zblizony zestaw warunkow
                     _ccone:=''; _t2.index(_ind12);
::                   tabela na poszczegolne warunki _bcone
                     _tabw1:=tab_tmp(1
                        ,'ILCWAR','INTEGER','Liczba pasuj war w tabw'
                        ,'BWAR','STRING[16]','BWAR'
                        );
::                   tabela na pasujace warunki na bramie _cbrama do warunkow na badanym wyjsciu _bcone
                     _tabcw:=tab_tmp(3
                        ,'BWAR','STRING[16]','BWAR'
                        ,'CCONE','STRING[16]','CCONE'
                        ,'CWAR','STRING[16]','CWAR'
                        ,'FORMULA','STRING[255]','FORMULA'
                        ,'KOLEJ','INTEGER','KOLEJ'
                        );
::                   dla kazdego warunku na _bcone szukanie na bramie _cbrama wyjsc, na ktorych sa takie same warunki
::                   nie mozna wykluczyc, ze na kilku wyjsciach beda identyczne warunki
::                   zapamietanie liczby warunkow na _bcone
                     _t1size:=_t1.size();
                     {!
                     |?
                        _tabw1.blank(); _tabw1.BWAR:=_t1.REF; _tabw1.add();
                        _t2.prefix(0,_cbrama,_t1.FORMULA,);
::                      jezeli bedzie wiecej warunkow pasujacych do dziedziny do sprawdzenie, czy zawezenie o kolejnosc
::                      nie spowoduje dziedziny pustej, jezeli nie to ten prefix
                        {? _t2.size()>1
                        || _t2.prefix(0,_cbrama,_t1.FORMULA,_t1.KOLEJ);
                           {? _t2.size()=0 || _t2.prefix(0,_cbrama,_t1.FORMULA,) ?}
                        ?};
                        {? _t2.first()
                        ||
                           {!
                           |?
                              _tabcw.blank();
                              _tabcw.BWAR:=_t1.REF; _tabcw.CCONE:=_t2.CONREF; _tabcw.CWAR:=_t2.REF;
                              _tabcw.FORMULA:=_t2.FORMULA;
                              _tabcw.KOLEJ:=_t2.KOLEJ;
                              _tabcw.add();
                              _tabw1.ILCWAR+=1; _tabw1.put();
                              _t2.next()
                           !}
                        ?};
                        _t1.next()
                     !};
::                   lista wyjsc z cbrama zapisanych w _tabcw
                     _ccn:=sql('select distinct CCONE, 0 as LOK, CAST(0 as REAL_TYPE) as SUMA from :_a order by 1',_tabcw);
::                   tabela na dane wszystkich warunkow na wyjsciach z cbrama zapisanych _ccn (czyli branych pod uwage w porownaniu)
                     _tabw2:=tab_tmp(3
                        ,'CCONE','STRING[16]','CCONE'
                        ,'CWAR','STRING[16]','CWAR'
                        ,'FORMULA','STRING[255]','FORMULA'
                        ,'KOLEJ','INTEGER','KOLEJ'
                        );
                     _t2.index(_ind32);
                     {? _ccn.first()
                     || {!
                        |?
                           _t2.prefix(_ccn.CCONE,0);
                           _ccn.SUMA:=_t2.size()+_t1size;
                           _ccn.put();
                           {? _t2.first()
                           || {!
                              |?
                                 _tabw2.CCONE:=_t2.CONREF; _tabw2.CWAR:=_t2.REF;
                                 _tabw2.FORMULA:=_t2.FORMULA; _tabw2.KOLEJ:=_t2.KOLEJ;
                                 _tabw2.add();
                                 _t2.next()
                              !}
                           ?};
                           _ccn.next()
                        !}
                     ?};
::                   typowanie najlepiej pasujacego wyjscia ze wzgledu na warunki
::                   punktacja wyjsc na _cbrama jest wpisywana do _ccn.LOK
::                   jednoczesnie warunek pasujacy jest usuwany z _tabw2
::                   przy idealnym dopasowaniu _tabw2 po ponizszej petli powinna byc pusta
                     _tabw1.prefix(); _tabw1.last();
                     {!
                     |?
                        _tabcw.prefix(_tabw1.BWAR);
                        {? _tabcw.first()
                        || {!
                           |?
                              {? _ccn.find_key(_tabcw.CCONE)
                              || {? _tabw2.find_key(_tabcw.CCONE,_tabcw.CWAR,)
                                 || _ccn.LOK+=2; _ccn.put(); _tabw2.del()
                                 ?}
                              ?};
                              _tabcw.next()
                           !}
                        ?};
                        _tabw1.prev()
                     !};
                     {? _ccn.first() || {! |? _ccn.SUMA:=_ccn.LOK/_ccn.SUMA; _ccn.put(); _ccn.next() !} ?};
::                   najlepiej dopasowane jest wyjscie, ktore ma najwieksza SUMA, w drugiej kolejnosci LOK
                     _ccn.index(_ccn.ndx_tmp(,,'SUMA',,,'LOK',,,'CCONE',,)); _ccn.prefix();
                     {? _ccn.last() || _ccone:=_ccn.CCONE ?};
                     obj_del(_ccn); &_ccn;
::                   teraz rejestracja pary wyjsc i ponowne porownanie warunkow
                     _fl2.index(_lndf12); _fl2.prefix();
                     {? (_ccone<>'') & _fl2.find_key(_ccone,)
                     ||
::                      jest zidentyfikowane wyjscie odpowiadajace
                        _flroot:=exec('gate_out_12write','qporproc',_brroot,_obj,_fl1,_fl2);
                        {? (_el1.GATETYPE=_el2.GATETYPE) & (_el1.GATETYPE='XOR')  & (_fl1.KOLEJ<>_fl2.KOLEJ)
                        || _obj.add2rap(_flroot,'Numer wyjścia',$_fl1.KOLEJ,$_fl2.KOLEJ,1)
                        ?};
::                      usuniecie z _tabcw wszystkich pozycji niezwizanych z _ccone
                        _tabcw.prefix();
                        {? _tabcw.first() || {! |? {? _tabcw.CCONE<>_ccone || _tabcw.del() || _tabcw.next() ?} !} ?};
                        _tabw2.prefix();
                        {? _tabw2.first() || {! |? {? _tabw2.CCONE<>_ccone || _tabw2.del() || _tabw2.next() ?} !} ?};
::                      na podstawie pozostalych zapisow dopisanie informacji o warunkach
                        _t1.index(_ind21); _t2.index(_ind22); _t1.prefix(); _t2.prefix();
                        _tabw1.index(_tabw1.ndx_tmp(,,'BWAR',,)); _tabw1.prefix();
                        {? _tabcw.first()
                        || {!
                           |?
                              _t1.find_key(_tabcw.BWAR); _t2.find_key(_tabcw.CWAR);
::                            zapisanie znalezionego warunku wspolnego i usuniecie fo z _tabw1 jako obsluzonego
                              exec('choice_12write','qporproc',_flroot,_obj,_t1,_t2);
                              _obj.BGTOUTEL.ELEMREF:=_t1.DO; _obj.BGTOUTEL.WAR:=_t1.FORMULA; _obj.BGTOUTEL.add();
                              _obj.CGTOUTEL.ELEMREF:=_t2.DO; _obj.CGTOUTEL.WAR:=_t2.FORMULA; _obj.CGTOUTEL.add();
                              {? _tabw1.find_key(_tabcw.BWAR,) || _tabw1.del() ?};
                              _tabcw.next()
                           !}
                        ?};
::                      teraz te warunki, co sa na _bcone a brak na _ccone
                        {? _tabw1.first()
                        || {!
                           |?
                              _t1.find_key(_tabw1.BWAR);
                              exec('choice_1write','qporproc',_flroot,_obj,_t1);
                              _obj.BGTOUTEL.ELEMREF:=_t1.DO; _obj.BGTOUTEL.WAR:=_t1.FORMULA; _obj.BGTOUTEL.add();
                              _tabw1.next()
                           !}
                        ?};
::                      teraz te warunki, co sa na _ccone a brak na _bcone
                        {? _tabw2.first()
                        || {!
                           |?
                              _t2.find_key(_tabw2.CWAR);
                              exec('choice_2write','qporproc',_flroot,_obj,_t2);
                              _obj.CGTOUTEL.ELEMREF:=_t2.DO; _obj.CGTOUTEL.WAR:=_t2.FORMULA; _obj.CGTOUTEL.add();
                              _tabw2.next()
                           !}
                        ?}
                     ||
::                      niezidentyfikowano odpowiadajacego wyjscia na 2 procesie - zapis jednostronny
                        exec('out_1write','qporproc',_brroot,_obj,_fl1,_t1,_ind31)
                     ?};
                     obj_del(_tabw1); &_tabw1;
                     obj_del(_tabw2); &_tabw2;
                     obj_del(_tabcw); &_tabcw
                  ||
::                   brak warunku na wyjsciu - poszukac wyjscia na cbrama, ktore najlepiej odpowiada
                     _ref:=exec('find_podob_out','qporproc',_cbrama,_fl1,_fl2,_lndf12,_lndf2,_el1,_el2,_t2,_ind32);
                     {? _ref<>''
                     || _fl2.prefix(); _fl2.find_key(_ref,);
                        _flroot:=exec('gate_out_12write','qporproc',_brroot,_obj,_fl1,_fl2);
                        _t2.index(_ind32); _t2.prefix(_fl2.REF,0);
                        {? _t2.first()
                        || {!
                           |?
                              exec('choice_2write','qporproc',_flroot,_obj,_t2);
                              _obj.CGTOUTEL.ELEMREF:=_t2.DO; _obj.CGTOUTEL.WAR:=_t2.FORMULA; _obj.CGTOUTEL.add();
                              _t2.first()
                           !}
                        ?}
                     || exec('gate_out_1write','qporproc',_brroot,_obj,_fl1,1)
                     ?}
                  ?};
                  _fl1.cntx_pop(); _fl2.cntx_pop();
                  _t1.cntx_pop(); _t2.cntx_pop()
               !};
::             odszukanie niesprawdzonych wyjsc na bramie w 2 procesie, ktore nie znalazly odpowiednikow w pierwszym
               _fl2.index(_lndf2); _fl2.prefix(_cbrama,'N',0);
               {! |? _fl2.first() |! exec('out_2write','qporproc',_brroot,_obj,_fl2,_t2,_ind32) !}
            ?}
         ?};
         _gates1.next()
      !}
   ?};
   obj_del(_gates1); &_gates1;
   _obj.ZMIANA>0
!};
::wyszukanie bram rozdzielajacych, ktore nie byly wogole uwzgledniane ze wzgledu na brak warunkow (proces niedokonczony)
_sql:='select GATETYPE, NAZWA, REF from :_a '
   +' where (USED=0) and ((GATETYPE=\'OR\') or (GATETYPE=\'XOR\')) and (GATEKIND=\'<\') '
   +' order by GATETYPE, NAZWA, REF ';
_gates1:=sql(_sql,_el1); _gates2:=sql(_sql,_el2);
_el1.index(_obj.IREFBP); _el2.index(_obj.IREFCP);
_el1.prefix(); _el2.prefix();
::szukanie bram podobnych
{!
|? _gates1.first()
|!
   _el1.find_key(_gates1.REF,);
   _wyn:={? _gates1.size()=1
         || exec('comp_gate3','qporproc',_gates1,_gates2,_obj,_el1,_el2,_otocz)
         || _gates1.prefix(_gates1.GATETYPE,);
            {? _gates1.size()=1
            || exec('comp_gate2','qporproc',_gates1,_gates2,_obj,_el1,_el2,_otocz)
            || _gates1.prefix(_gates1.GATETYPE,_gates1.NAZWA,);
               {? _gates1.size()=1
               || exec('comp_gate1','qporproc',_gates1,_gates2,_obj,_el1,_el2,_otocz)
               || exec('comp_gate_oto','qporproc',_obj,_root,_gates1,_gates2,_el1,_el2,_otocz)
               ?}
            ?}
         ?};
:: jezeli sparowano bramy to porownanie wyjsc i warunkow na wyjsciach
   {? _wyn.ROOT>0
   ||
::    sparowanie wyjsc domyslnych na porownywanych bramach
      exec('comp_dflt4gate','qporproc',_obj,_wyn.ROOT,_gates1.REF,_wyn.REF,_fl1,_fl2,_lndf1,_lndf2);
::    przeglad i rejestracja pozostalych wyjsc z obu bram
      _fl1.index(_lndf1); _fl1.prefix(_gates1.REF,'N',0);
      _fl2.index(_lndf2); _fl2.prefix(_wyn.REF,'N',0);
      {!
      |? _fl1.first()
      |!
         _fl1.cntx_psh(); _fl2.cntx_psh();
         _ref:=exec('find_podob_out','qporproc',_wyn.REF,_fl1,_fl2,_lndf12,_lndf2,_el1,_el2,_t2,_ind32);
         {? _ref<>''
         || _fl2.prefix(); _fl2.find_key(_ref,);
            _flroot:=exec('gate_out_12write','qporproc',_wyn.ROOT,_obj,_fl1,_fl2);
            _t1.index(_ind31); _t1.prefix(_fl1.REF,0);
            {? _t1.first()
            || {!
               |?
                  exec('choice_1write','qporproc',_flroot,_obj,_t1);
                  _obj.BGTOUTEL.ELEMREF:=_t1.DO; _obj.BGTOUTEL.WAR:=_t1.FORMULA; _obj.BGTOUTEL.add();
                  _t1.first()
               !}
            ?};
            _t2.index(_ind32); _t2.prefix(_fl2.REF,0);
            {? _t2.first()
            || {!
               |?
                  exec('choice_2write','qporproc',_flroot,_obj,_t2);
                  _obj.CGTOUTEL.ELEMREF:=_t2.DO; _obj.CGTOUTEL.WAR:=_t2.FORMULA; _obj.CGTOUTEL.add();
                  _t2.first()
               !}
            ?}
         || exec('gate_out_1write','qporproc',_wyn.ROOT,_obj,_fl1,1)
         ?};
         _fl1.cntx_pop(); _fl2.cntx_pop()
      !};
::    jezeli zostaly jakies wyjscia na bramie 2 to umieszczenie w wynikach
      _fl2.index(_lndf2); _fl2.prefix(_wyn.REF,'N',0);
      {!
      |? _fl2.first()
      |!
         _fl2.cntx_psh();
         exec('gate_out_2write','qporproc',_wyn.ROOT,_obj,_fl2,1);
         _fl2.cntx_pop()
      !}
   ?};
   &_wyn;
   _gates1.del(); _gates1.prefix()
!};
&_gates1;
&_otocz;
_gates2.prefix();
::jezeli w _gates2 cos zostalo, to znaczy ze nie ma odpowiednikow w 1
{! |? _gates2.first() |! _el2.find_key(_gates2.REF,); exec('gate_2write','qporproc',_root,_obj,_el2); _gates2.del() !};
&_gates2;
_t1.ndx_drop(_ind1); _t1.ndx_drop(_ind11); _t1.ndx_drop(_ind21); _t1.ndx_drop(_ind31);
_t2.ndx_drop(_ind2); _t2.ndx_drop(_ind12); _t2.ndx_drop(_ind22); _t2.ndx_drop(_ind32);
_fl1.ndx_drop(_lndf1); _fl1.ndx_drop(_lndf11);
_fl2.ndx_drop(_lndf2); _fl2.ndx_drop(_lndf12);
_fl1.cntx_pop(); _fl2.cntx_pop();
_el1.cntx_pop(); _el2.cntx_pop();
_t1.cntx_pop(); _t2.cntx_pop();
~~


::......................................................................................................................
:: porownywanie bram zlozonych
::......................................................................................................................


\complex_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary bram zlozonych
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_wyn:=_obj.add2rap(_root,'Brama',exec('complex_txt','qporproc',_t1),exec('complex_txt','qporproc',_t2),,'B');
exec('set_used','qporproc',_t1,_t2);
exec('mk_bridge','qporproc',_t1,_t2,_pewny);
{? _t1.NAZWA<>_t2.NAZWA || _obj.add2rap(_wyn,'Nazwa',_t1.NAZWA,_t2.NAZWA,1) ?};
{? _t1.FMANMAIN<>_t2.FMANMAIN || _obj.add2rap(_wyn,'Warunek',_t1.FMANMAIN,_t2.FMANMAIN,1) ?};
{? _t1.G_CANCEL<>_t2.G_CANCEL || _obj.add2rap(_wyn,'Kasować',_t1.G_CANCEL,_t2.G_CANCEL,1) ?};
exec('port_in_cmp','qporproc',_wyn,_obj,_t1,_t2);
_wyn


\odp_complex1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,_t1.FMANMAIN,_t1.G_CANCEL,_t1.UZUPELN,_t1.NAZWA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('complex_12write','qporproc',_root,_obj,_t1,_t2)
   || _tmin:=exec('max_dop','qporproc',_root,_obj,_t1,_t2
            ,"exec('port_in_cmp','qporproc',_a,_b,_c,_d,0)");
      {? (_tmin<>'') & _t2.seek(_tmin)
      || exec('complex_12write','qporproc',_root,_obj,_t1,_t2)
      || _obj.add2rap(_root,'Brama',exec('complex_txt','qporproc',_t1),,1,'B'); exec('set_used','qporproc',_t1)
      ?}
   ?}
|| _obj.add2rap(_root,'Brama',exec('complex_txt','qporproc',_t1),,1,'B'); exec('set_used','qporproc',_t1)
?}


\odp_complex2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,_t1.FMANMAIN,_t1.G_CANCEL,_t1.UZUPELN,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('complex_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_complex1','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Brama',exec('complex_txt','qporproc',_t1),,1,'B'); exec('set_used','qporproc',_t1)
?}


\odp_complex3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,_t1.FMANMAIN,_t1.G_CANCEL,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('complex_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_complex2','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Brama',exec('complex_txt','qporproc',_t1),,1,'B'); exec('set_used','qporproc',_t1)
?}


\odp_complex4
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Proba ustalenia odpowiadajacych elementow dla aktualnej dziedziny i prefiksu t1
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,_t1.FMANMAIN,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('complex_12write','qporproc',_root,_obj,_t1,_t2)
   || exec('odp_complex3','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Brama',exec('complex_txt','qporproc',_t1),,1,'B'); exec('set_used','qporproc',_t1)
?}


\odp_complex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Poszukiwanie odpowiednikow bram zlozonych
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela elementow procesu 1
::       _d - tabela elementow procesu 2
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_obj.BPREL.cntx_psh(); _obj.CPREL.cntx_psh();
_t1.prefix('B_GATE','>','COMPLEX');
{? _t1.first()
|| {!
   |?
      {? _t1.BRIDGE=0
      ||
         _t1.cntx_psh();
         _t1.prefix(_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,);
         {? _t1.size()=1
         || _t2.prefix(0,_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,);
            {? _t2.first()
            ||
               {? _t2.size()=1
               || exec('complex_12write','qporproc',_root,_obj,_t1,_t2)
               || exec('odp_complex4','qporproc',_root,_obj,_t1,_t2)
               ?}
            || _obj.add2rap(_root,'Brama',exec('complex_txt','qporproc',_t1),,1,'B')
            ?}
         || _t1.prefix(_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,_t1.FMANMAIN,);
            {? _t1.size()=1
            || exec('odp_complex4','qporproc',_root,_obj,_t1,_t2)
            || _t1.prefix(_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,_t1.FMANMAIN,_t1.G_CANCEL,);
               {? _t1.size()=1
               || exec('odp_complex3','qporproc',_root,_obj,_t1,_t2)
               || _t1.prefix(_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,_t1.FMANMAIN,_t1.G_CANCEL,_t1.UZUPELN,);
                  {? _t1.size()=1
                  || exec('odp_complex2','qporproc',_root,_obj,_t1,_t2)
                  || _t1.prefix(_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,_t1.FMANMAIN,_t1.G_CANCEL,_t1.UZUPELN,_t1.NAZWA,);
                     _t1.first();
                     {! |? {?_t1.BRIDGE=0 || exec('odp_complex1','qporproc',_root,_obj,_t1,_t2) ?}; _t1.next() !}
                  ?}
               ?}
            ?}
         ?};
         _t1.cntx_pop()
      ?};
      _t1.next()
   !}
?};
::elementy 2 procesu, ktore nie maja odpowiednikow
_t2.prefix(0,'B_GATE','>','COMPLEX');
{!
|? _t2.first()
|! _obj.add2rap(_root,'Brama',,exec('complex_txt','qporproc',_t2),1,'B'); exec('set_used','qporproc',,_t2)
!};
_obj.BPREL.cntx_pop(); _obj.CPREL.cntx_pop();
~~


\comp_cogate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie bram zlozonych
::   WE: _a - obiekt danych
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_t1:=_obj.BPREL; _t2:=_obj.CPREL;
::ustalenie elementow ktore sa bezpozrednio za brama - moze juz sa sparowane
::wtedy w polu UZUPELN obu elementow wpisanie takiej samej wartosci
_sql:='select REF from :_a where GATETYPE=\'COMPLEX\' order by REF';
_gat1:=sql(_sql,_t1); _gat2:=sql(_sql,_t2);
_sql:='select AA.OD BRAMA, BB.REF REF, BB.BRREF BRREF from :_a as AA '
      +' join :_b as BB using(AA.DO,BB.REF) '
      +' where (AA.OD in (select REF from :_c)) and (BB.BRREF is not null) '
      +' order by 1,2';
_el1:=sql(_sql,_obj.BCONN,_t1,_gat1);
_sql:='select AA.OD BRAMA, BB.REF REF, BB.BRREF BRREF from :_a as AA '
      +' join :_b as BB using(AA.DO,BB.REF) '
      +' where (AA.OD in (select REF from :_c)) and (BB.BRREF is not null) '
      +' order by REF, BRAMA';
_el2:=sql(_sql,_obj.CCONN,_t2,_gat2);
_t1.index(_obj.IREFBP); _t2.index(_obj.IREFCP);
{? _gat1.first()
|| {!
   |?
      {? _el1.find_key(_gat1.REF,) & _t1.find_key(_gat1.REF,) & _el2.find_key(_el1.BRREF,) & _t2.find_key(_el2.BRAMA,)
      || _t1.UZUPELN:=_t2.REF; _t1.put(); _t2.UZUPELN:=_t2.REF; _t2.put()
      ?};
      _gat1.next()
   !}
?};
&_gat1; &_gat2; &_el1; &_el2;
_ind1:=_t1.ndx_tmp(,,'RODZAJ',,,'GATEKIND',,,'GATETYPE',,,'FMANMAIN',,,'G_CANCEL',,,'UZUPELN',,,'NAZWA',,,'ROLA',,);
_ind2:=_t2.ndx_tmp(,,'USED',,,'RODZAJ',,,'GATEKIND',,,'GATETYPE',,,'FMANMAIN',,,'G_CANCEL',,,'UZUPELN',,,'NAZWA',,,'ROLA',,);
_t1.index(_ind1);  _t2.index(_ind2);
exec('odp_complex','qporproc',_obj.ROOTS.GATECOMP,_obj,_t1,_t2);
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);
~~


::......................................................................................................................
:: porownywanie bram and rozdzielajacych
::......................................................................................................................


\gate_ra_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary bram rozdzielajacych and
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_wyn:=_obj.add2rap(_root,'Brama',exec('gate_txt','qporproc',_t1),exec('gate_txt','qporproc',_t2),,'B');
exec('set_used','qporproc',_t1,_t2);
exec('mk_bridge','qporproc',_t1,_t2,_pewny);
{? _t1.NAZWA<>_t2.NAZWA || _obj.add2rap(_wyn,'Nazwa',_t1.NAZWA,_t2.NAZWA,1) ?};
_wyn


\comp_r_and_2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: porownanie bram and 2 poziom
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,_t1.NAZWA,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('gate_ra_12write','qporproc',_obj.ROOTS.GATEMULT,_obj,_t1,_t2,1)
   || _tmin:=exec('max_dop','qporproc',_root,_obj,_t1,_t2,"1");
      {? (_tmin<>'') & _t2.seek(_tmin)
      || exec('gate_ra_12write','qporproc',_obj.ROOTS.GATEMULT,_obj,_t1,_t2,1)
      || _obj.add2rap(_root,'Brama',exec('gate_txt','qporproc',_t1),,1,'B'); exec('set_used','qporproc',_t1)
      ?}
   ?}
|| _obj.add2rap(_root,'Brama',exec('gate_txt','qporproc',_t1),,1,'B'); exec('set_used','qporproc',_t1)
?}


\comp_r_and_1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: porownanie bram and 1 poziom
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;

_t2.prefix(0,_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,);
{? _t2.first()
|| {? _t2.size()=1
   || exec('gate_ra_12write','qporproc',_obj.ROOTS.GATEMULT,_obj,_t1,_t2,1)
   || exec('comp_r_and_2','qporproc',_root,_obj,_t1,_t2)
   ?}
|| _obj.add2rap(_root,'Brama',exec('gate_txt','qporproc',_t1),,1,'B'); exec('set_used','qporproc',_t1)
?}


\comp_r_and
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: porownanie bram rozdzielajacych typu and
::   WE: _a - obiekt
::----------------------------------------------------------------------------------------------------------------------
::zalozenie wczesniej wykonana jest proba powiazania odpowiednikow czego sie da
::czyli teraz mozna wykorzystac te porownania do ustalenia odpowiednikow bramek
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_root:=_obj.ROOTS.GATEMULT;
_t1:=_obj.BPREL; _t2:=_obj.CPREL;
_ind1:=_obj.IREFBP;
_ind2:=_obj.IREFCP;
_t1.index(_ind1); _t2.index(_ind2); _t1.prefix(); _t2.prefix();
_faza2:=0;
::najpierw szukanie bramy z takim samym elementem poprzedzajacym, który ma juz odpowiednik
{!
|?
   _zmiana:=0;
:: wykaz odpowiednikow juz odgadnietych (tylko pewne)
   _odp:=exec('odpowiedniki','qporproc',_t1);
:: ustalenie jakie sa elementy poprzedzajace niesparowane bramy < and
   _sql:='select CONE.DO BRAMA, CONE.OD ELEMENT from :_a as CONE '
         +' join :_b as EL using(CONE.DO,EL.REF) '
         +' where (EL.BRIDGE=0) and (EL.RODZAJ=\'B_GATE\') and (EL.GATEKIND=\'<\') and (EL.GATETYPE=\'AND\') '
         +' order by 1,2';
   _el1:=sql(_sql,_obj.BCONN,_t1); _el2:=sql(_sql,_obj.CCONN,_t2);
   _el2.index(_el2.ndx_tmp(,,'ELEMENT',,,'BRAMA',,));
   {? _el1.first()
   || {!
      |?
         {? _odp.find_key(_el1.ELEMENT,) & _t1.find_key(_el1.BRAMA) & (_t1.BRIDGE=0)
            & _el2.find_key(_odp.BRREF) & _t2.find_key(_el2.BRAMA) & (_t2.BRIDGE=0)
         || exec('gate_ra_12write','qporproc',_root,_obj,_t1,_t2,1);
            _zmiana+=1
         ?};
         _el1.next()
      !}
   ?};
   obj_del(_odp); &_odp;
   {? _zmiana=0 || _faza2:=_el1.size() & _el2.size() ?};
   obj_del(_el1); &_el1;
   obj_del(_el2); &_el2;
   _zmiana
!};
{? _faza2
||
:: jezeli nie udalo sie powiazac wszystkich bram to poszukiwanie oparte na elementach na wyjsciach
:: im wiecej pasujacych elementow na wyjsciach tym lepiej
   _faza2:=0;
   {!
   |?
      _zmiana:=0;
::    wykaz odpowiednikow juz odgadnietych (tylko pewne)
      _odp:=exec('odpowiedniki','qporproc',_t1);
::    ustalenie jakie sa elementy na wyjsciach w bramach < and, ktore nie maja odpowiednikow
      _sql:='select CONE.OD BRAMA, CONE.DO ELEMENT from :_a as CONE '
            +' join :_b as EL using(CONE.OD,EL.REF) '
            +' where (EL.BRIDGE=0) and (EL.RODZAJ=\'B_GATE\') and (EL.GATEKIND=\'<\') and (EL.GATETYPE=\'AND\') '
            +' order by 1,2';
      _el1:=sql(_sql,_obj.BCONN,_t1); _el2:=sql(_sql,_obj.CCONN,_t2);
      _el2.index(_el2.ndx_tmp(,,'ELEMENT',,,'BRAMA',,));
      {? _el1.first()
      || _gates:=tab_tmp(2,'BRAMA1','STRING[16]','Brama1','BRAMA2','STRING[16]','Brama2','DOP','INTEGER','Liczba dopasowań');
         {!
         |?
            {? _odp.find_key(_el1.ELEMENT,) & _t1.find_key(_el1.BRAMA) & (_t1.BRIDGE=0)
               & _el2.find_key(_odp.BRREF) & _t2.find_key(_el2.BRAMA) & (_t2.BRIDGE=0)
            || {? _gates.find_key(_t1.REF,_t2.REF,)
               || _gates.DOP+=1; _gates.put()
               || _gates.blank(); _gates.BRAMA1:=_t1.REF; _gates.BRAMA2:=_t2.REF; _gates.DOP:=1; _gates.add()
               ?}
            ?};
            _el1.next()
         !};
         _gates.index(_gates.ndx_tmp(,,'DOP',,,'BRAMA1',,,'BRAMA2',,));
::       wiazemy te, ktore wykazuja najwieksza zgodnosc elementow na wyjsciach
         {? _gates.last()
         || {!
            |?
               {? _t1.find_key(_gates.BRAMA1) & (_t1.BRIDGE=0) & _t2.find_key(_gates.BRAMA2) & (_t2.BRIDGE=0)
               || exec('gate_ra_12write','qporproc',_root,_obj,_t1,_t2,1);
                  _zmiana+=1
               ?};
               _gates.prev()
            !}
         ?};
         &_gates
      ?};
      obj_del(_odp); &_odp;
      {? _zmiana=0 || _faza2:=_el1.size() & _el2.size() ?};
      obj_del(_el1); &_el1;
      obj_del(_el2); &_el2;
      _zmiana
   !};
:: jezeli jeszcze cos zostanie to proba porownania po nazwach
   {? _faza2
   ||
      _ind11:=_t1.ndx_tmp(,,'RODZAJ',,,'GATEKIND',,,'GATETYPE',,,'NAZWA',,,'ROLA',,);
      _t1.index(_ind11);
      _ind12:=_t2.ndx_tmp(,,'BRIDGE',,,'RODZAJ',,,'GATEKIND',,,'GATETYPE',,,'NAZWA',,,'ROLA',,);
      _t2.index(_ind12);
      _t1.prefix('B_GATE','<','AND');
      {? _t1.first()
      || {!
         |?
            {? _t1.BRIDGE=0
            ||
               {? _t1.size()=1
               || exec('comp_r_and_1','qporproc',_root,_obj,_t1,_t2)
               || _t1.prefix('B_GATE','<','AND',_t1.NAZWA,);
                  {? _t1.size()=1
                  || exec('comp_r_and_2','qporproc',_root,_obj,_t1,_t2)
                  || {!
                     |? {? _t1.BRIDGE=0 || exec('comp_r_and_2','qporproc',_root,_obj,_t1,_t2) ?};
                        _t1.next()
                     !}
                  ?}
               ?}
            ?};
            _t1.next()
         !}
      ?};
      _t2.prefix(0);
      {? _t2.first()
      || {!
         |?
            _obj.add2rap(_root,'Brama',,exec('gate_txt','qporproc',_t2),1,'B'); exec('set_used','qporproc',,_t2);
            _t2.next()
         !}
      ?}
   ?}
?};
~~


::......................................................................................................................
:: porownywanie bram laczacych zwyklych
::......................................................................................................................


\gate_j_12write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis do tabeli wynikowej danych pary bram laczacych and, or, xor
::   WE:
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       [_e] - rodzaj powiązania: [1] - pewne, -1 - niepewne
::   WY: ref gałęzi na drzewie
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
{? (_<5) | (_e=~~) | (type_of(_e)<>type_of(0)) | (_e=0) || _e:=1 ?};
_pewny:=_e;

_wyn:=_obj.add2rap(_root,'Brama',exec('gate_txt','qporproc',_t1),exec('gate_txt','qporproc',_t2),,'B');
exec('set_used','qporproc',_t1,_t2);
exec('mk_bridge','qporproc',_t1,_t2,_pewny);
{? _t1.GATETYPE<>_t2.GATETYPE || _obj.add2rap(_wyn,'Typ',_t1.GATETYPE,_t2.GATETYPE,1) ?};
{? _t1.NAZWA<>_t2.NAZWA || _obj.add2rap(_wyn,'Nazwa',_t1.NAZWA,_t2.NAZWA,1) ?};
_wyn


\comp_join_4
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: porownanie bram and 1 poziom
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       _e - tabela z bramami laczacymi zwyklumi procesu bazowego
::       _f - tabela z bramami laczacymi zwyklumi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
_tt1:=_e;
_tt2:=_f;

_tt2.prefix(0,_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,_t1.NAZWA,_t1.ROLA,);
_t1.find_key(_tt1.REF);
{? _tt2.first()
|| {? _tt2.size()=1
   || _t2.find_key(_tt2.REF); exec('gate_j_12write','qporproc',_root,_obj,_t1,_t2,1)
   || _t2.find_key(_tt2.REF); exec('gate_j_12write','qporproc',_root,_obj,_t1,_t2,-1)
   ?}
|| _obj.add2rap(_root,'Brama',exec('gate_txt','qporproc',_t1),,1,'B'); exec('set_used','qporproc',_t1)
?}


\comp_join_3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: porownanie bram and 1 poziom
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       _e - tabela z bramami laczacymi zwyklumi procesu bazowego
::       _f - tabela z bramami laczacymi zwyklumi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
_tt1:=_e;
_tt2:=_f;

_tt2.prefix(0,_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,_t1.NAZWA,);
_t1.find_key(_tt1.REF);
{? _tt2.first()
|| {? _tt2.size()=1
   || _t2.find_key(_tt2.REF); exec('gate_j_12write','qporproc',_root,_obj,_t1,_t2,1)
   || exec('comp_join_4','qporproc',_root,_obj,_t1,_t2,_tt1,_tt2)
   ?}
|| _obj.add2rap(_root,'Brama',exec('gate_txt','qporproc',_t1),,1,'B'); exec('set_used','qporproc',_t1)
?}


\comp_join_2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: porownanie bram and 1 poziom
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       _e - tabela z bramami laczacymi zwyklumi procesu bazowego
::       _f - tabela z bramami laczacymi zwyklumi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
_tt1:=_e;
_tt2:=_f;

_tt2.prefix(0,_t1.RODZAJ,_t1.GATEKIND,_t1.GATETYPE,);
_t1.find_key(_tt1.REF);
{? _tt2.first()
|| {? _tt2.size()=1
   || _t2.find_key(_tt2.REF); exec('gate_j_12write','qporproc',_root,_obj,_t1,_t2,1)
   || exec('comp_join_3','qporproc',_root,_obj,_t1,_t2,_tt1,_tt2)
   ?}
|| _obj.add2rap(_root,'Brama',exec('gate_txt','qporproc',_t1),,1,'B'); exec('set_used','qporproc',_t1)
?}


\comp_join_1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: porownanie bram and 1 poziom
::       _a - root
::       _b - objekt
::       _c - tabela z danymi procesu bazowego
::       _d - tabela z danymi procesu porownywanego
::       _e - tabela z bramami laczacymi zwyklumi procesu bazowego
::       _f - tabela z bramami laczacymi zwyklumi procesu porownywanego
::----------------------------------------------------------------------------------------------------------------------
_root:=_a;
_obj:=_b;
_t1:=_c;
_t2:=_d;
_tt1:=_e;
_tt2:=_f;

_tt2.prefix(0,_tt1.RODZAJ,_tt1.GATEKIND,);
_t1.find_key(_tt1.REF);
{? _tt2.first()
|| {? _tt2.size()=1
   || _t2.find_key(_tt2.REF); exec('gate_j_12write','qporproc',_root,_obj,_t1,_t2,1)
   || exec('comp_join_2','qporproc',_root,_obj,_t1,_t2,_tt1,_tt2)
   ?}
|| _obj.add2rap(_root,'Brama',exec('gate_txt','qporproc',_t1),,1,'B'); exec('set_used','qporproc',_t1)
?}


\comp_gate_join
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: porownanie bram laczacych
::   WE: _a - obiekt
::----------------------------------------------------------------------------------------------------------------------
::zalozenie wczesniej wykonana jest proba powiazania odpowiednikow czego sie da
::czyli teraz mozna wykorzystac te porownania do ustalenia odpowiednikow bramek
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_root:=_obj.ROOTS.GATEJOIN;
_t1:=_obj.BPREL; _t2:=_obj.CPREL;
_ind1:=_obj.IREFBP;
_ind2:=_obj.IREFCP;
_t1.index(_ind1); _t2.index(_ind2); _t1.prefix(); _t2.prefix();
_faza2:=0;
_where:=' where (EL.BRIDGE=0) and (EL.USED=0) and (EL.RODZAJ=\'B_GATE\') and (EL.GATEKIND=\'>\') '
   +' and ((EL.GATETYPE=\'OR\') or (EL.GATETYPE=\'XOR\') or (EL.GATETYPE=\'AND\')) ';
::najpierw szukanie bramy z takim samym elementem za
{!
|?
   _zmiana:=0;
:: wykaz odpowiednikow juz odgadnietych (tylko pewne)
   _odp:=exec('odpowiedniki','qporproc',_t1);
:: ustalenie jakie sa elementy po niesparowanych bramach >
   _sql:='select CONE.OD BRAMA, CONE.DO ELEMENT from :_a as CONE '
         +' join :_b as EL using(CONE.OD,EL.REF) '
         +_where
         +' order by 1,2';
   _el1:=sql(_sql,_obj.BCONN,_t1); _el2:=sql(_sql,_obj.CCONN,_t2);
   _el2.index(_el2.ndx_tmp(,,'ELEMENT',,,'BRAMA',,));
   {? _el1.first()
   || {!
      |?
         {? _odp.find_key(_el1.ELEMENT,) & _t1.find_key(_el1.BRAMA) & (_t1.BRIDGE=0)
            & _el2.find_key(_odp.BRREF) & _t2.find_key(_el2.BRAMA) & (_t2.BRIDGE=0)
         || exec('gate_j_12write','qporproc',_root,_obj,_t1,_t2,1);
            _zmiana+=1
         ?};
         _el1.next()
      !}
   ?};
   obj_del(_odp); &_odp;
   {? _zmiana=0 || _faza2:=_el1.size() & _el2.size() ?};
   obj_del(_el1); &_el1;
   obj_del(_el2); &_el2;
   _zmiana
!};
{? _faza2
||
:: jezeli nie udalo sie powiazac wszystkich bram to poszukiwanie oparte na elementach na wejsciach
:: im wiecej pasujacych elementow na wyjsciach tym lepiej
   _faza2:=0;
   {!
   |?
      _zmiana:=0;
::    wykaz odpowiednikow juz odgadnietych (tylko pewne)
      _odp:=exec('odpowiedniki','qporproc',_t1);
::    ustalenie jakie sa elementy na wyjsciach w bramach < and procesow, ktore nie maja odpowiednikow
      _sql:='select CONE.DO BRAMA, CONE.OD ELEMENT from :_a as CONE '
            +' join :_b as EL using(CONE.DO,EL.REF) '
            +_where
            +' order by 1,2';
      _el1:=sql(_sql,_obj.BCONN,_t1); _el2:=sql(_sql,_obj.CCONN,_t2);
      _el2.index(_el2.ndx_tmp(,,'ELEMENT',,,'BRAMA',,));
      {? _el1.first()
      || _gates:=tab_tmp(2,'BRAMA1','STRING[16]','Brama1','BRAMA2','STRING[16]','Brama2','DOP','INTEGER','Liczba dopasowań');
         {!
         |?
            {? _odp.find_key(_el1.ELEMENT,) & _t1.find_key(_el1.BRAMA) & (_t1.BRIDGE=0)
               & _el2.find_key(_odp.BRREF) & _t2.find_key(_el2.BRAMA) & (_t2.BRIDGE=0)
            || {? _gates.find_key(_t1.REF,_t2.REF,)
               || _gates.DOP+=1; _gates.put()
               || _gates.blank(); _gates.BRAMA1:=_t1.REF; _gates.BRAMA2:=_t2.REF; _gates.DOP:=1; _gates.add()
               ?}
            ?};
            _el1.next()
         !};
         _gates.index(_gates.ndx_tmp(,,'DOP',,,'BRAMA1',,,'BRAMA2',,));
::       wiazemy te, ktore wykazuja najwieksza zgodnosc elementow na wyjsciach
         {? _gates.last()
         || {!
            |?
               {? _t1.find_key(_gates.BRAMA1) & (_t1.BRIDGE=0) & _t2.find_key(_gates.BRAMA2) & (_t2.BRIDGE=0)
               || exec('gate_j_12write','qporproc',_root,_obj,_t1,_t2,1);
                  _zmiana+=1
               ?};
               _gates.prev()
            !}
         ?};
         &_gates
      ?};
      obj_del(_odp); &_odp;
      {? _zmiana=0 || _faza2:=_el1.size() & _el2.size() ?};
      obj_del(_el1); &_el1;
      obj_del(_el2); &_el2;
      _zmiana
   !};
:: jezeli jeszcze cos zostanie to proba porownania po nazwach
   {? _faza2
   ||
      _sql:='select * from :_a as EL '+_where+' order by ';
      _tt1:=sql(_sql+'RODZAJ, GATEKIND, GATETYPE, NAZWA, ROLA',_t1);
      _tt2:=sql(_sql+'BRIDGE, RODZAJ, GATEKIND, GATETYPE, NAZWA, ROLA',_t2);
      _t1.index(_ind1); _t2.index(_ind2);
      _t1.prefix(); _t2.prefix();
      _tt1.prefix('B_GATE','>',);
      {? _tt1.first()
      || {!
         |?
            {? _tt1.BRIDGE=0
            ||
               {? _tt1.size()=1
               || exec('comp_join_1','qporproc',_root,_obj,_t1,_t2,_tt1,_tt2)
               || _tt1.prefix(_tt1.RODZAJ,_tt1.GATEKIND,_tt1.GATETYPE,);
                  {? _tt1.size()=1
                  || exec('comp_join_2','qporproc',_root,_obj,_t1,_t2,_tt1,_tt2)
                  || _tt1.prefix(_tt1.RODZAJ,_tt1.GATEKIND,_tt1.GATETYPE,_tt1.NAZWA,);
                     {? _tt1.size()=1
                     || exec('comp_join_3','qporproc',_root,_obj,_t1,_t2,_tt1,_tt2)
                     || _tt1.prefix(_tt1.RODZAJ,_tt1.GATEKIND,_tt1.GATETYPE,_tt1.NAZWA,_tt1.ROLA,);
                        {? _tt1.size()=1
                        || exec('comp_join_4','qporproc',_root,_obj,_t1,_t2,_tt1,_tt2)
                        || _obj.add2rap(_root,'Brama',exec('gate_txt','qporproc',_t1),,1,'B');
                           exec('set_used','qporproc',_t1)
                        ?}
                     ?}
                  ?}
               ?}
            ?};
            _tt1.next()
         !}
      ?};
      _tt2.prefix(0);
      {? _tt2.first()
      || {!
         |? _t2.find_key(_tt2.REF,);
            _obj.add2rap(_root,'Brama',,exec('gate_txt','qporproc',_t2),1,'B'); exec('set_used','qporproc',,_t2);
            _tt2.next()
         !}
      ?}
   ?}
|| _sql:='select REF from :_a as EL '
         +_where
         +' order by 1';
   _el1:=sql(_sql,_t1); _el2:=sql(_sql,_t2);
   {? _el1.first()
   || {!
      |? {? _t1.find_key(_el1.REF)
         || _obj.add2rap(_root,'Brama',exec('gate_txt','qporproc',_t1),,1,'B');
            exec('set_used','qporproc',_t1)
         ?};
         _el1.next()
      !}
   ?};
   {? _el2.first()
   || {!
      |? {? _t2.find_key(_el2.REF)
         || _obj.add2rap(_root,'Brama',,exec('gate_txt','qporproc',_t2),1,'B');
            exec('set_used','qporproc',,_t2)
         ?};
         _el2.next()
      !}
   ?};
   &_el1; &_el2
?};
~~


::----------------------------------------------------------------------------------------------------------------------
:: porownywaniem lacznikow
::----------------------------------------------------------------------------------------------------------------------


\write_conn12
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis na drzewie informacji o laczniku
::   WE: _a - obiekt danych
::       _b - tabela z lacznikami z procedu 1
::       _c - tabela z lacznikami z procedu 2
::       _d - tabela z elementami procedu 1
::       _e - tabela z elementami procedu 2
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_l1:=_b;
_l2:=_c;
_e1:=_d;
_e2:=_e;

{? _e1.find_key(_l1.OD,) & _e2.find_key(_l2.OD,)
||
   _root:=_obj.add2rap(_obj.ROOTS.FLOW,'Od',exec('write_elem_txt','qporproc',_e1),exec('write_elem_txt','qporproc',_e2),,'L');
   {? _e1.find_key(_l1.DO,) & _e2.find_key(_l2.DO,)
   || _roz:=_l1.NAME<>_l2.NAME;
      _doroot:=_obj.add2rap(_root,'Do',exec('write_elem_txt','qporproc',_e1),exec('write_elem_txt','qporproc',_e2),,'l');
      {? _l1.NAME<>_l2.NAME || _obj.add2rap(_doroot,'Nazwa',_l1.NAME,_l2.NAME,1) ?};
::    zapamietanie polozenia rekordu z para lacznikow na drzewie raportu
::    potrzebne dla funkcji porownania powiazan parametrow na laczniku gdy element na koncu moze miec parametry
      _obj.BPOCONN.prefix(_l1.REF,_l1.DO,); _obj.CPOCONN.prefix(0,_l2.REF,_l2.DO,);
      {? (_obj.BPOCONN.size()+_obj.CPOCONN.size())
         & (((_l1.DORODZAJ<>'B_GATE') | (_l1.DOKIND='COMPLEX')) | ((_l2.DORODZAJ<>'B_GATE') | (_l2.DOKIND='COMPLEX')))
      || _obj.RPARCON.BCONE:=_l1.REF; _obj.RPARCON.CCONE:=_l2.REF; _obj.RPARCON.RAPORT:=_doroot; _obj.RPARCON.add()
      ?}
   || _obj.add2rap(_obj.ROOTS.FLOW,'Do','Błąd','Błąd',1)
   ?}
|| _obj.add2rap(_obj.ROOTS.FLOW,'Od','Błąd','Błąd',1)
?}


\write_conn1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis na drzewie informacji o laczniku
::   WE: _a - obiekt danych
::       _b - tabela z lacznikami z procedu 1
::       _c - tabela z elementami procedu 1
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_l1:=_b;
_e1:=_c;

{? _e1.find_key(_l1.OD,)
||
   _root:=_obj.add2rap(_obj.ROOTS.FLOW,'Od',exec('write_elem_txt','qporproc',_e1),,1,'L');
   {? _e1.find_key(_l1.DO,)
   || _obj.add2rap(_root,'Do',exec('write_elem_txt','qporproc',_e1),' ',,'l',1)
   || _obj.add2rap(_obj.ROOTS.FLOW,'Do','Błąd',' ',1)
   ?}
|| _obj.add2rap(_obj.ROOTS.FLOW,'Od','Błąd',' ',1)
?}


\write_conn2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Zapis na drzewie informacji o laczniku
::   WE: _a - obiekt danych
::       _b - tabela z lacznikami z procedu 1
::       _c - tabela z elementami procedu 1
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_l1:=_b;
_e1:=_c;

{? _e1.find_key(_l1.OD,)
||
   _root:=_obj.add2rap(_obj.ROOTS.FLOW,'Od',,exec('write_elem_txt','qporproc',_e1),1,'L');
   {? _e1.find_key(_l1.DO,)
   || _obj.add2rap(_root,'Do',' ',exec('write_elem_txt','qporproc',_e1),,'l',1)
   || _obj.add2rap(_obj.ROOTS.FLOW,'Do',' ','Błąd',1)
   ?}
|| _obj.add2rap(_obj.ROOTS.FLOW,'Od',' ','Błąd',1)
?}


\comp_conn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: porownianie lacznikow
::   WE: _a - objekt
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_obj.BPOCONN.cntx_psh(); _obj.CPOCONN.cntx_psh();
_c1ind:=_obj.BPOCONN.ndx_tmp(,,'B_CONN',,,'PREL_DST',,,'PRDSTSYM',,); _obj.BPOCONN.index(_c1ind);
_c2ind:=_obj.CPOCONN.ndx_tmp(,,'USED',,,'B_CONN',,,'PREL_DST',,,'PRDSTSYM',,); _obj.CPOCONN.index(_c2ind);
::laczniki sa uznawane z takie same, jezeli element na wejsciu i na wyjciu ma odpowiednik w drugim procesie
_t1:=_obj.BCONN; _t2:=_obj.CCONN;
_ind1:=_t1.ndx_tmp(,,'OD',,,'DO',,); _t1.index(_ind1);
_ind2:=_t2.ndx_tmp(,,'OD',,,'DO',,); _t2.index(_ind2);
_e1:=_obj.BPREL; _e2:=_obj.CPREL;
_inde1:=_obj.IREFBP; _e1.index(_inde1); _e1.prefix();
_inde2:=_obj.IREFCP; _e2.index(_inde2); _e2.prefix();
::uzupelnienie wpisow BRREF i BRIDGE wszystkich lacznikow
_fml:="
   _e1:=_a; _tt:=_b;
   _tt.prefix();
   {? _tt.first()
   || {!
      |?
         {? _e1.find_key(_tt.OD,) || _tt.ODBRREF:=_e1.BRREF; _tt.ODBRIDGE:=_e1.BRIDGE ?};
         {? _e1.find_key(_tt.DO,) || _tt.DOBRREF:=_e1.BRREF; _tt.DOBRIDGE:=_e1.BRIDGE ?};
         _tt.put();
         _tt.next()
      !}
   ?}
   ";
_fml(_e1,_t1); _fml(_e2,_t2);
::teraz oznaczanie zgodnosci przez porownywanie zgodnosci wskazywanych elementow na obu wejsciach
_t1.prefix(); _t2.prefix();
{? _t1.first()
|| {!
   |?
      {? (_t1.BRIDGE=0) & (_t1.ODBRREF<>'') &  (_t1.DOBRREF<>'')
      ||
::       uwzglednienie tego, ze ktos mogl poprowadzic podwojne polaczenie tych samych elementow
         _t2.prefix(_t1.ODBRREF,_t1.DOBRREF,);
         {? _t2.first() || {! |? {? _t2.BRIDGE=0 || exec('mk_bridge','qporproc',_t1,_t2,1);0 || _t2.next() ?} !} ?}
      ?};
      _t1.next()
   !}
?};
::umieszczanie na drzewku
_e1.prefix(); _e2.prefix();
_ind12:=_t2.ndx_tmp(,,'REF',,); _t2.index(_ind12); _t2.prefix();
{? _t1.first()
|| {!
   |?
      {? (_t1.BRIDGE>0) & _t2.find_key(_t1.BRREF,)
      || exec('write_conn12','qporproc',_obj,_t1,_t2,_e1,_e2)
      || exec('write_conn1','qporproc',_obj,_t1,_e1)
      ?};
      _t1.next()
   !}
?};
_ind11:=_t1.ndx_tmp(,,'REF',,); _t1.index(_ind11); _t1.prefix();
_t2.index(_ind2); _t2.prefix();
{? _t2.first()
|| {!
   |?
      {? (_t2.BRIDGE=0) || exec('write_conn2','qporproc',_obj,_t2,_e2) ?};
      _t2.next()
   !}
?};
::koniec umieszczania lacznikow w wynikach
_t1.ndx_drop(_ind1); _t2.ndx_drop(_ind2);
::uzupelnienie informacji o powiazaniach parametrow na lacznikach wymienionych w _obj.RPARCON
_t1.index(_ind11); _t2.index(_ind12); _t1.prefix(); _t2.prefix();
_obj.BPOCONN.prefix(); _obj.CPOCONN.prefix();
_obj.RPARCON.prefix(); _e1.index(_inde1);  _e2.index(_inde2); _e1.prefix(); _e2.prefix();
_obj.BPORTS.index(_obj.BPORTS.ndx_tmp(,,'B_PORT',,)); _obj.BPORTS.prefix();
_obj.CPORTS.index(_obj.CPORTS.ndx_tmp(,,'B_PORT',,)); _obj.CPORTS.prefix();
{? _obj.RPARCON.first()
|| {!
   |?
      _t1.find_key(_obj.RPARCON.BCONE); _t2.find_key(_obj.RPARCON.CCONE);
      _obj.BPOCONN.prefix(_t1.REF,_t1.DO,);
      {? _obj.BPOCONN.first()
      || {!
         |? _e1.find_key(_obj.BPOCONN.PREL_SRC,);
            _obj.CPOCONN.prefix();
            {? _obj.CPOCONN.find_key(0,_t2.REF,_t2.DO,_obj.BPOCONN.PRDSTSYM)
            || _e2.find_key(_obj.CPOCONN.PREL_SRC,);
               {? (_e1.BRREF<>'') & (_e1.BRREF=_e2.REF)
               ||
::                kontrolnie umieszcza tez poprawnie sparowane, ale w wynikach te rekordy potem sa usuwane
                  _obj.add2rap(_obj.RPARCON.RAPORT
                  ,'Parametr '+_obj.BPOCONN.PRDSTSYM+' powiązany z prametrem:'
                  ,'['+_obj.BPOCONN.PRSRCSYM+'] '+exec('write_elem_txt','qporproc',_e1)
                  ,'['+_obj.CPOCONN.PRSRCSYM+'] '+exec('write_elem_txt','qporproc',_e2)
                  );
                  _obj.CPOCONN.USED:=1; _obj.CPOCONN.put()
               || _obj.add2rap(_obj.RPARCON.RAPORT
                  ,'Parametr '+_obj.BPOCONN.PRDSTSYM+' powiązany z prametrem:'
                  ,'['+_obj.BPOCONN.PRSRCSYM+'] '+exec('write_elem_txt','qporproc',_e1)
                  ,'['+_obj.CPOCONN.PRSRCSYM+'] '+exec('write_elem_txt','qporproc',_e2)
                  ,1);
                  _obj.CPOCONN.USED:=1; _obj.CPOCONN.put()
               ?}
            || _obj.add2rap(_obj.RPARCON.RAPORT
                  ,'Parametr '+_obj.BPOCONN.PRDSTSYM+' powiązany z prametrem:'
                  ,'['+_obj.BPOCONN.PRSRCSYM+'] '+exec('write_elem_txt','qporproc',_e1)
                  ,'Niepowiązany'
                  ,1)
            ?};
            _obj.BPOCONN.next()
         !}
      ?};
      _obj.CPOCONN.prefix(0,_t2.REF,_t2.DO,);
      {? _obj.CPOCONN.first()
      || {!
         |?
            _obj.add2rap(_obj.RPARCON.RAPORT
               ,'Parametr '+_obj.CPOCONN.PRDSTSYM+' powiązany z prametrem:'
               ,'Niepowiązany'
               ,'['+_obj.CPOCONN.PRSRCSYM+'] '+exec('write_elem_txt','qporproc',_e2)
               ,1);
            _obj.CPOCONN.next()
         !}
      ?};
      _obj.RPARCON.next()
   !}
?};
_t1.ndx_drop(_ind11);  _t2.ndx_drop(_ind12);
_obj.BPOCONN.ndx_drop(_c1ind); _obj.CPOCONN.ndx_drop(_c2ind);
_obj.BPOCONN.cntx_pop(); _obj.CPOCONN.cntx_pop();
~~


::----------------------------------------------------------------------------------------------------------------------
:: sterowanie porownywaniem elementow
::----------------------------------------------------------------------------------------------------------------------


\compar_elem
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Funkcja porównania elementow
::   WE: _a - obiekt
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

exec('load','qporproc',_obj);
exec('prepare','qporproc',_obj);
_ilb:=_obj.BPREL.size(); _ilc:=_obj.CPREL.size();
_obj.ROOTS.ELEMENTY:=_obj.add2rap(1,'Liczba elementów',$_ilb,$_ilc,,,1);
::porownanie liczby posczegolnych rodzajow elementow
::tory
_obj.BPREL.prefix('B_LANE'); _obj.CPREL.prefix('B_LANE');
_ilb:=_obj.BPREL.size(); _ilc:=_obj.CPREL.size();
_obj.ROOTS.LANE:=_obj.add2rap(_obj.ROOTS.ELEMENTY,'Liczba torów',$_ilb,$_ilc,,,1);
::czynności
_obj.BPREL.prefix('B_ACTION'); _obj.CPREL.prefix('B_ACTION');
_ilb:=_obj.BPREL.size(); _ilc:=_obj.CPREL.size();
_obj.ROOTS.ACTION:=_obj.add2rap(_obj.ROOTS.ELEMENTY,'Liczba czynności',$_ilb,$_ilc,,,1);
::zdarzenia
_obj.BPREL.prefix('B_EVENT'); _obj.CPREL.prefix('B_EVENT');
_ilb:=_obj.BPREL.size(); _ilc:=_obj.CPREL.size();
_obj.ROOTS.EVENT:=_obj.add2rap(_obj.ROOTS.ELEMENTY,'Liczba zdarzeń',$_ilb,$_ilc,,,1);
::bramki
_obj.BPREL.prefix('B_GATE'); _obj.CPREL.prefix('B_GATE');
_ilb:=_obj.BPREL.size(); _ilc:=_obj.CPREL.size();
_obj.ROOTS.GATE:=_obj.add2rap(_obj.ROOTS.ELEMENTY,'Liczba bram',$_ilb,$_ilc);

_obj.BCONN.prefix(); _obj.CCONN.prefix();
_ilb:=_obj.BCONN.size(); _ilc:=_obj.CCONN.size();
_obj.ROOTS.FLOW:=_obj.add2rap(1,'Liczba połączeń',$_ilb,$_ilc,,,1);

::UWAGA - kolejnosc wywolania podprogramow istotna - optymalizacja ze wzgledu na skutecznosc szukania odpowiednikow
::utworenie struktur pod zdarzenia i akcje
exec('tree_event','qporproc',_obj,_obj.ROOTS.EVENT);
exec('tree_action','qporproc',_obj,_obj.ROOTS.ACTION);
exec('tree_gate','qporproc',_obj,_obj.ROOTS.GATE);

::POROWNANIE ELEMENTOW - UWAGA NIE ZMIENIAC KOLEJNOSCI WYWOLAN
::porownanie torow
exec('comp_lane','qporproc',_obj,_obj.ROOTS.LANE);
::uzupelnienie informacji pod jakimi warunkami wykonywane sa elementy
exec('prepare_trek_ch','qporproc',_obj);
::porownanie bram sterowanych zdarzenia
exec('comp_evgate','qporproc',_obj);
::utworzenie wpisow na podstawie warunkow na bramach rozdzielajacych OR i XOR
exec('comp_choice','qporproc',_obj);
::uzupelniajace porownywanie elementow
exec('comp_action','qporproc',_obj,_obj.ROOTS.ACTION);
exec('comp_event','qporproc',_obj,_obj.ROOTS.ACTION);
::porownanie bram zlozonych
exec('comp_cogate','qporproc',_obj);
::po porownaniu elementow mozna sprobowac poszukac odpowiadajace bramy bez warunkow
::poronanie na podstawie elementow z ktorymi brama sie laczy
exec('comp_r_and','qporproc',_obj);
::wszystkie bramy laczace zwykle porownywane sa jednoczesnie
exec('comp_gate_join','qporproc',_obj);
::porownanie lacznikow
exec('comp_conn','qporproc',_obj);
~~


\del_emty_branch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Usuniecie elementow niepotrzebnych
::   WE: _a - obiekt
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

_obj.RAPORT.last();
{! |? _ilus:=0; {! |? _ilus+=_obj.delpoz(); _obj.RAPORT.prev() !}; _ilus & _obj.RAPORT.last() !};
_obj.RAPORT.first();
~~


::======================================================================================================================
:: funkcje testujace
::======================================================================================================================


\test_self
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie wszystkich procesow ze soba
::       Test zaliczony, gdy na koniec liczba roznic=0
::----------------------------------------------------------------------------------------------------------------------
B_PROC.prefix();
_lr:=0;
{? B_PROC.first()
|| {!
   |?
      {? B_PROC.FIRMA<>null()
      ||
         _wyn:=exec('start','qporproc','R',B_PROC.ref(),B_PROC.ref());
         _lr+=_wyn.ROZNICE;
         echo(_wyn.BSYM+'('+_wyn.BWER+') ['+_wyn.BFIR+']');
         &_wyn
      ?};
      B_PROC.next()
   !}
?};
{? _lr=0
|| FUN.info('Nie wykryto różnić.\nTest zaliczony.')
|| FUN.error('Wykryto różnice tam gdzie ich nie ma.\nTest oblany')
?}


\test_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [Macrologic]
:: OPIS: Porownanie wszystkich procesow kazdy z kazdym
::       Test zaliczony jezeli w trakcie nie pojawią się błędy (nie na trafi na sytuację, z którą sobie nie poradzi)
::----------------------------------------------------------------------------------------------------------------------
{? (_=0) | (_a=~~) | type_of(_a)<>type_of('') || _a:='' ?};
{? (_<1) | (_b=~~) | type_of(_b)<>type_of('') || _b:='' ?};
{? (_<2) | (_c=~~) | type_of(_c)<>type_of('') || _c:='' ?};
{? _a='' | _b='' | _c='' || _a:=_b:=_c:='' ?};
_firma:=form(_a);
_symbol:=form(_b);
_wer:=form(_c);


_wyn:=tab_tmp(6
   ,'BSYM','STRING[100]','Symbol 1'
   ,'BWER','STRING[10]','Wersja 1'
   ,'BFIR','STRING[10]','Firma 1'
   ,'CSYM','STRING[100]','Symbol 2'
   ,'CWER','STRING[10]','Wersja 2'
   ,'CFIR','STRING[10]','Firma 2'
   ,'BNAZ','STRING[100]','Nazwa 1'
   ,'CNAZ','STRING[100]','Nazwa 2'
   ,'ROZNICE','INTEGER','LR'
   );
_sql:='select FIRMA, SYMBOL, VER, REFERENCE REF from B_PROC where FIRMA is not null order by 1,2,3';
_proc1:=sql(_sql);
{? (_a<>'') & _proc1.find_key(_firma,_symbol,_wer,) & _proc1.first()
|| {! |? (_proc1.BSYM<>_symbol) | (_proc1.BFIR<>_firma) | (_proc1.WER<>_wer) |! _proc1.del(); _proc1.first() !};
   {? (_proc1.BSYM=_symbol) & (_proc1.BFIR=_firma) & (_proc1.WER=_wer) |! _proc1.del() !}
?};
_proc2:=sql('select * from :_a where 0=1 order by 1,2,3',_proc1);
{? _proc1.first()
|| _proc.next();
   {!
   |? _proc2.FIRMA:=_proc1.FIRMA; _proc2.SYMBOL:=_proc1.SYMBOL; _proc2.WER:=_proc1.WER;
      _proc2.add(); _proc1.next()
   !}
?};
{? _proc1.first()
|| {!
   |?
      {? _proc2.first()
      || {!
         |?
            _rez:=exec('start','qporproc','N',_proc1.REF,_proc2.REF);
            _wyn.blank();
            _wyn.BSYM:=_rez.BSYM;
            _wyn.BWER:=_rez.BWER;
            _wyn.BFIR:=_rez.BFIR;
            _wyn.BNAZ:=_rez.BNAZ;
            _wyn.CSYM:=_rez.CSYM;
            _wyn.CWER:=_rez.CWER;
            _wyn.CFIR:=_rez.CFIR;
            _wyn.CNAZ:=_rez.CNAZ;
            _wyn.ROZNICE:=_rez.ROZNICE;
            _wyn.add();
            echo(_wyn.BSYM+'('+_wyn.BWER+') ['+_wyn.BFIR+']    <=>    '+_wyn.CSYM+'('+_wyn.CWER+') ['+_wyn.CFIR+']');
            &_rez;
            _proc2.next()
         !}
      ?};
      _proc1.first(); _proc2.first();
      _proc1.del() & _proc2.del() & _proc1.first()
   !}
?};
_win:=_wyn.mk_sel('Porównanie wszystkich procesów','T','qporprocwynt2',,,,,'U','T');
_wyn.win_fld(_win,,'BSYM',,,20);
_wyn.win_fld(_win,,'BWER',,,7);
_wyn.win_fld(_win,,'BFIR',,,5);
_wyn.win_fld(_win,,'BNAZ',,,30);
_wyn.win_fld(_win,,'CSYM',,,20);
_wyn.win_fld(_win,,'CWER',,,7);
_wyn.win_fld(_win,,'CFIR',,,5);
_wyn.win_fld(_win,,'CNAZ',,,30);
_wyn.win_fld(_win,,'ROZNICE',,,3);
_wyn.win_sel(_win);
_wyn.select();
&_wyn;
~~