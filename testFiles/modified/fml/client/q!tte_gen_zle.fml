:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: q!tte_gen_zle.fml
:: Utworzony: 28.08.2020
:: Autor: TP
:: Systemy:
::======================================================================================================================
:: Zawartość: Czynność ręczna - dla zlecenia niezależnego generowanie podzlecenia prostego jeśli są półfabrykaty
::======================================================================================================================

\key_zkp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Wystawia klucz grupujący z pozycjami zamówień dla których należy wygenerować zlecenia niezależne
::   WE: [_a] - STRING - Ref SQL - ZL (zlecenie dla którego wygenerowano limity i do nich trzeba wygenerować zlecenia)
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ar:='';
{? var_pres('_a')=type_of('')
|| _ar:=_a
?};

_mp:=params_get().mp;
_in:=params_get().in;

::  ZLECENIE - może też przyjść w parametrze wejściowym ITEM
{? _in.ITEM<>''
|| _ar:=_in.ITEM
?};

_mp.grpkey();

_tab_1:=sql('select ZLIM.REFERENCE as REF from @ZLIM join TMAT
               where ZLIM.ZLEC=\':_a\' and (TMAT.KTL<>\'\' or TMAT.DFLT_KTL=\'T\')',_ar);
{? _tab_1.first()
|| {!
   |? _tab_2:=sql('select ZK_P.REFERENCE as REF from @ZK_P
                     where ZK_P.M_ZLIM=\':_a\' and ZK_P.ZLIM=\':_b\'',8+_tab_1.REF,_tab_1.REF);
      {? _tab_2.first()
      || {!
         |? _mp.grpkeyAdd(_tab_2.REF);
            _tab_2.next()
         !}
      ?};
      &_tab_2;
      _tab_1.next()
   !}
?};

_mp.done();
~~


\zlisty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Generowanie zleceń z pozycji zamówień/zamówienia - formuła dla potrzeb kontynuacji procesu zleceń niezależnych
::       Kopia z pliku !tte_pzl_dzwe - wywołanie zawsze z parametrem 2 i _b - zlecenie nadrzędne lub w trybie 1
::   WE: [_a] - tryb pracy: 1 - (domyślnie) lista zleceń,
::       [_b] - ZL.ref() - zlecenie nadrzędne (wymagane dla trybu 2)
::       [_c] - ZK_N.ref() - zamówienie (wymagane dla trybu 3)
::   WY: wynik ZK_P.ref() - wskazanej pozycji zamówienia, bądź null()
::  OLD: \zlisty/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
KOMM.init(,,'Wybór zamówień do wygenerowania zleceń'@,'');
:: Narazie na sztywno otustawiony oddział - coś mi go wycieła :(
ST.ODDZ:='w';
VAR_DEL.delete('zkp_ref');
zkp_ref:='';

{? var_pres('_a')=type_of(0) || _tryb:=_a || _tryb:=1 ?};
{? var_pres('_b')=type_of(null()) || _zl_nad:=_b || _zl_nad:=null() ?};
{? var_pres('_c')=type_of(null()) || _zk_n:=_c || _zk_n:=null() ?};


_result:=null();

{? ~exec('sprdt','zl_head') || return(_result) ?};

VAR.A_ZLNAD:=null();

set_help(exec('set_help','#help','TTE_PZL_DZWE'));

ZL.cntx_psh(); ZGH.cntx_psh(); ZGP.cntx_psh(); ZLIM.cntx_psh();
exec('tktl_cntx_psh','tech_common');
_zam:=exec('get','#params',500213,2)+exec('get','#params',500215,2);
{? _zam=''
|| FUN.info(
      'Brak wskazanych typów zamówień w parametrach systemu.\n'
      'Należy uzupełnić parametr aplikacyjny %1 lub %2.'@['500213','500215']
   )
|| _zam:=gsub(_zam,' ',',');
   _msk:=ST.ODDZ+'__';
   exec('openz','open_tab',_msk);
   _tab:=sql('
      select
         ZK_P.REFERENCE as REF,
         ZK_P.POZ,
         M.KTM as KOD,
         M.N as NAZ,
         M.REFERENCE as M_REF,
         ZK_P.ILRB as IL_REZ,
         ZK_P.ILZ as IL_ZAM,
         ZK_P.ILP as IL_POZ,
         (ZK_P.ILP-ZK_P.ILRB) as IL_WYTW,
         sum(ZLZAM.ILZL) as IL_ZL,
         ZK_N.SYM,
         ZK_P.DT as DTR,
         ZK_P.PL_DATA as PL_DATA,
         ZK_P.PL_TIME as PL_TIME,
         ZK_N.KH as KH,
         KH.KOD as KH_K,
         KH.SKR as KH_S,
         KH.NAZ as KH_N,
         KH.REFERENCE as KH_REF,
         HAN.KOD as HAN_K,
         HAN.NAZ as HAN_N,
         PROJEKTY.SYM as PROJEKT,
         M.REFERENCE as T,
         JM.KOD as JM,
         DK_C.M_ATR as ATR,
         DK_C.REFERENCE as DK_C,
         SPACE(20) as WAR01,
         SPACE(20) as WAR02,
         SPACE(20) as WAR03,
         SPACE(20) as WAR04,
         SPACE(20) as WAR05,
         SPACE(20) as WAR06,
         SPACE(20) as WAR07,
         SPACE(20) as WAR08,
         SPACE(20) as WAR09,
         SPACE(20) as WAR10,
         SPACE(1) as POTW_T,
         SPACE(1) as PLAN_OP,
         SPACE(1) as PLAN_ST,
::       Rodzaj zamówienia
         TYPYZAM.R as ZAM_R,
::       Limit źródłowy pozycji zamówienia
         ZK_P.ZLIM as ZLIM,
::       Zlecenie źródłowe
         SPACE(20) as ZL,
::       Znacznik, czy zlecenie źródłowe powstało jako kopia albo na skutek podziału innego zlecenia
         SPACE(1) as ZL_COPY,
::       Przewodnik źródłowy
         SPACE(30) as ZGH,
::       Pozycja przewodnika źródłowego
         0 as ZGP,
::       data pozpoczecia zlecenia, aby zdazyc na planowany termin realizacji
         ZK_P.PL_DATA as QPDP
      from ZK_P
         join M using(ZK_P.M,M.REFERENCE)
         join ZK_N using(ZK_P.N,ZK_N.REFERENCE)
         left join HAN using(ZK_N.HAN,HAN.REFERENCE)
         join TYPYZAM using(ZK_N.T,TYPYZAM.REFERENCE)
         join JM using(M.J,JM.REFERENCE)
         left join KH using(ZK_N.KH,KH.REFERENCE)
         left join ZLZAM using(ZK_P.REFERENCE,ZLZAM.ZAMPOZ)
         left join DK_C using(ZK_P.DK_C,DK_C.REFERENCE)
         left join PROJEKTY using(ZK_P.PROJEKTY,PROJEKTY.REFERENCE)
      where '+{? _zk_n=null() | _tryb<>3 || '' || 'ZK_N.REFERENCE=:_b and ' ?}+
            '(M.R=\'W\' or M.R=\'P\') and ZK_N.AKC=\'T\' and ZK_N.A=\'A\' and ZK_P.TOP=1 and ZK_N.STAN<>\'ZRE\'
            and '':_a'' LIKE ''%''||TYPYZAM.T||''%''
      group by ZK_P.REFERENCE, ZK_P.POZ, M.KTM, M.N, ZK_P.ILZ, ZK_P.ILP, ZK_P.ILRB, ZK_N.SYM, ZK_P.PL_DATA, ZK_P.PL_TIME,
            ZK_P.DT, ZK_N.KH, KH.KOD, KH.SKR, KH.NAZ, KH.REFERENCE, HAN.KOD, HAN.NAZ, PROJEKTY.SYM,
            M.REFERENCE, JM.KOD, DK_C.M_ATR, DK_C.REFERENCE, TYPYZAM.R, ZK_P.ZLIM
      order by KOD, PL_DATA, PL_TIME',_zam,_zk_n
   );

   {? type_of(_tab)=type_of(~~) || exec('err_sql','#sql'); return() ?};

   _korlim:=exec('get','#params',500221,2);

:: Ustalenie wartości dodatkowych pól
   {? _tab.first()
   || {!
      |? ZLZAM.index('ZMZL');
         ZLZAM.prefix(_tab.REF);
         {? ZLZAM.first()
         || {!
            |? REZ.index('ZLZAM');
               REZ.prefix(ZLZAM.ref(),'B');
               {? REZ.first()
               || {!
                  |? _tab.IL_REZ-=REZ.ILR;
                     _tab.IL_WYTW+=REZ.ILR;
                     REZ.next()
                  !}
               ?};
               ZLZAM.next()
            !}
         ?};

::       Ustawianie wartości atrybutów
         {? _tab.DK_C<>''
         ||
            {? var_pres('_buffer')>100
            || obj_del(_buffer)
            ?};
            DK_C.cntx_psh();
            DK_C.use(8+_tab.DK_C);
            DK_C.clear();
            {? DK_C.seek(BIT.sqlint(_tab.DK_C),)
            || _buffer:=exec('buffer','mat_atr');
               _buffer.get_dkc();
               _buffer.set_tab(_tab)
            ?};
            DK_C.cntx_pop()
         ?};

::       Ustawianie danych źródłowych: zlecenie, przewodnik, pozycja (dla zamówień wewnętrznych limitowych)
         {? _tab.ZAM_R='W' & _tab.ZLIM<>''
         || _args:=obj_new('ZL','ZL_COPY','ZGH','ZGP');
            exec('FindAndGet','#table',ZLIM,_tab.ZLIM,,"
                  _args:=_b;
                  _args.ZL:=ZGP().ZL().SYM;
                  _args.ZL_COPY:={? ZL.IDSRC='' || 'N' || 'T' ?};
                  _args.ZGH:=ZGP().NRZLP().NRPRZ;
                  _args.ZGP:=ZGP().NRP;
                  ~~
               ",,_args
            );
            _tab.ZL:=_args.ZL;
            _tab.ZL_COPY:=_args.ZL_COPY;
            _tab.ZGH:=_args.ZGH;
            _tab.ZGP:=_args.ZGP;
            obj_del(_args)
         || _tab.ZL:='';
            _tab.ZL_COPY:='N';
            _tab.ZGH:='';
            _tab.ZGP:=0
         ?};

::       Zmniejszenie ilości do wytworzenia o korekty limitów
         {? _korlim='N' & _tab.ZAM_R='W' & _tab.ZLIM<>''
         || ZLIM.use(ref_name(_tab.ZLIM));
            ZLIM.prefix();
            {? ZLIM.seek(_tab.ZLIM)
            || ZLIM.index('ZKK');
               ZLIM.prefix(ZLIM.ZLEC,ZLIM.LIMIT,ZLIM.NR);
               {? ZLIM.first()
               || {!
                  |? {? ZLIM.AKC='T'
                     || _tab.IL_WYTW-=ZLIM.LIL
                     ?};
                     ZLIM.next()
                  !}
               ?}
            ?}
         ?};

::       Ustawianie znacznika planowania operacyjnego
         {? exec('zam_planned','po_plan',_tab.REF)>0
         || _tab.PLAN_OP:='T'
         || _tab.PLAN_OP:='N'
         ?};

::       Ustawianie znacznika planowania strategicznego
         {? exec('zkp_pxed_sql','px_tie',_tab.REF)>0
         || _tab.PLAN_ST:='T'
         || _tab.PLAN_ST:='N'
         ?};
::       Ustawianie daty rozpoczecia zlecenia, aby zdazyc na termin realizacji zamowienia
         _tab.QPDP:=exec('qpdp','qprodukcja',_tab.REF);
::       Ustawianie znacznika dostępności technologii
         _potw:=exec('potw_t','!tte_pzl_dzwe',_tab.M_REF);
         {? _potw=1
         || _tab.POTW_T:='T'
         |? _potw=0
         || _tab.POTW_T:='P'
         || _tab.POTW_T:='N'
         ?};

::         _tab.IL_ZL-=_ujil;
         _tab.put();
         {? _tab.IL_ZL>=_tab.IL_WYTW
         || _tab.del()
         || _tab.next()
         ?}
      !}
   ?};

   _tab.fld_attr('REF',2);
   _tab.fld_attr('T',2);
   _tab.fld_attr('KH',2);

:: Okno
   _wer:=_tab.mk_sel(
      {? _zk_n=null()
      || 'Pozycje zamówień do wytworzenia'
      || 'Pozycje zamówienia %1 do wytworzenia'[exec('record','#to_string',_zk_n)]
      ?},
      'P',,'#zlisty'+$(_zk_n=null()),1,2,,,'U'
   );

:: Pola
   _tab.win_fld(_wer,,'KOD',,,20,,,'Kod produktu'@,,'Indeks materiałowy'@);
   _tab.win_fld(_wer,,'NAZ',,,25,,,'Nazwa produktu'@,,'Nazwa materiału'@);
   _tab.win_fld(_wer,,'IL_ZAM',,,12,4,,'Zamówione'@,,'Zamówiona ilość'@);
   _tab.win_fld(_wer,,'IL_POZ',,,12,4,,'Do realizacji'@,,'Ilość do realizacji'@);
   _tab.win_fld(_wer,,'IL_REZ',,,12,4,,'Rezerwacje'@,,'Ilość zarezerwowana'@);
   _tab.win_fld(_wer,,'IL_WYTW',,,12,4,,'Do wytworzenia'@,,'Ilość do wytworzenia'@);
   _tab.win_fld(_wer,,'IL_ZL',,,12,4,,'Zlecone'@,,'Ilość zlecona'@);
   _tab.win_fld(_wer,,'JM',,,6,,,'jm'@,,'Jednostka miary'@);
   {? _zk_n=null() || _tab.win_fld(_wer,,'SYM',,,,,,'Zamówienie'@,,'Symbol zamówienia'@) ?};
   _tab.win_fld(_wer,,'POZ',,,4,,,'Poz.'@,,'Numer pozycji na zamówieniu'@);
   _tab.win_fld(_wer,,'QPDP',,,-10,,,'Start produkcji'@,,'Planowany termin rozpoczęcia produkcji'@);
   _tab.win_fld(_wer,,'PL_DATA',,,-10,,,'Termin realizacji'@,,'Planowany termin realizacji'@);
   _tab.win_fld(_wer,,'PLAN_ST',,,-6,,,'Plan strategiczny'@,,'Czy zamówienie znajduje się w planie strategicznym? (T/N)'@,2,,"\'T\'","\'N\'");
   _tab.win_fld(_wer,,'PLAN_OP',,,-6,,,'Plan operacyjny'@,,'Czy zamówienie znajduje się w planie operacyjnym? (T/N)'@,2,,"\'T\'","\'N\'");
   _tab.win_fld(_wer,,'POTW_T',,,-6,,,'Technologia'@,,'Czy technologia jest dostępna?(T-tak, N-brak, P-niezatwierdzona lub archiwalna)'@,2,,"\'T\'","\'N\'","\'P\'");

:: Akcje
   _tab.win_act(_wer,0,'Formuła','Wybierz'@@,,'Nowe zlecenie'@,
      "{? ~cur_tab().sel_size()
       || {? exec('FindAndGet','#table',ZK_P,cur_tab().REF,,\"ZK_P.M();exec('wyb_ktl','zl_gen',0)=null\",1)
          || FUN.error('Pozycja nie posiada technologii, generowanie zleceń nie jest możliwe.');
            0
          || sel_exit()
          ?}
       || 1
       ?}",,1,1,
      " 'obsługa zaznaczenia kilku rekordów - wtedy uzupełniana jest tabela BULK - sprawdzane w czynności generującej zlecenie';
       _result:=1;
       _tab_sel:=cur_tab().sel_aget();
       {? _tab_sel.first()
       || cur_tab().seek(_tab_sel.REF);
          zkp_ref:=cur_tab().REF;
          'sprawdzenie czy jest technologia na zaznaczone rekordy';
          {? exec('FindAndGet','#table',ZK_P,zkp_ref,,\"ZK_P.M();exec('wyb_ktl','zl_gen',0)=null\",1)
          || FUN.error('Zaznaczone pozycje nie posiadają technologii, generowanie zlecenia nie jest możliwe.');
             zkp_ref:='';
             _result:=0
          ?};
          'sprawdzenie czy wszystkie zaznaczone pozycjie są zgodne co do KTM oraz czy data realizacji jest wcześniejsza od daty generowania';
          {? _result
          || _m:=cur_tab().KOD;
             {!
             |? cur_tab().seek(_tab_sel.REF);
                {? _m<>cur_tab().KOD
                || FUN.error('Zaznaczono pozycje z różnymi indeksami materiałowymi, generowanie zlecenia nie jest możliwe.');
                   zkp_ref:='';
                   _result:=0
                |? cur_tab().PL_DATA<date()
                || FUN.error('Termin realizacji jednej z zaznaczonych pozycji jest wcześniejszy od daty generowania zlecenia.\n'+
                             'Generowanie zlecenia nie jest możliwe.');
                   zkp_ref:='';
                   _result:=0
                ?};
                _result & _tab_sel.next()
             !}
          ?};
          'sprawdzam czy zaznaczone pozycje mają technologie złożoną';
          {? _result & exec('FindAndGet','#table',ZK_P,zkp_ref,,\"exec('czy_polfabrykaty','q%gate',ZK_P.ref())=0\",1)
          ||  FUN.error('Zaznaczone pozycje nie posiadają półfabrykatów.\n'+
                        'Dodaj zlecenie prosete z poziomu obszaru roboczego produkcji.');
              zkp_ref:='';
              _result:=0
          ?};
          {? _result
          || _tab_sel.first();
             {!
             |? cur_tab().seek(_tab_sel.REF);
                exec('add','#bulk',ZK_P,'GEN_ZLEC',zkp_ref+cur_tab.REF);
                _tab_sel.next()
             !}
          ?}
       ?};
       _result",
       "sel_exit()",'T'
   );
   _tab.win_act(_wer,0,'Formuła','Lista zle&ceń'@@,,'Lista zleceń wygenerowanych do pozycji zamówienia'@,
      "params_exec('zl_do_zmp','!tte_pzl_dzwe')",,,,,,'C');
   _tab.win_act(_wer,0,'Formuła','Su&ma'@@,,'Podsumowanie ilości z zaznaczonych pozycji'@,
      "params_exec('zmp_sum','!tte_pzl_dzwe')",,,1,
      "params_exec('zmp_sum_bg','!tte_pzl_dzwe')","params_exec('zmp_sum_ag','!tte_pzl_dzwe')",'M');
   _tab.win_act(_wer,,'Menu','Fu&nkcje'@@,,'Funkcje dodatkowe'@,,,,,,,'N');
   _tab.win_act(_wer,,'Formuła','Analiza'@@,'#N','Analiza dostępności materiału w czasie'@,
      "params_exec('zmp_analiza_b','!tte_pzl_dzwe')","params_exec('zmp_analiza_a','!tte_pzl_dzwe')",,1,
      "params_exec('zmp_analiza_bg','!tte_pzl_dzwe')","params_exec('zmp_analiza_ag','!tte_pzl_dzwe')",'A');
   _tab.win_act(_wer,0,'Szukaj');
   _tab.win_act(_wer,0,'Kolejność');
   _tab.win_act(_wer,0,'Formuła','Legenda'@@,,,"exec('legenda','color','ZAMPOZ#01')",,,,,,'L');
   _tab.win_act(_wer,,'Rekord',,,,"Color.rekprzed('ZAMPOZ#01#01')");
   _formula:="
      ZK_P.cntx_psh();
      ZK_P.clear();
      {? ZK_P.seek(BIT.sqlint(cur_tab(1,1).REF),)
      || exec('wys_pozy','zamsiw_poz',1)
      ?};
      ZK_P.cntx_pop();
      ~~
   ";
   _tab.win_act(_wer,,'Wyświetl',,,,_formula);

:: Przyciski
   {? _zk_n<>null() || _tab.win_btn(_wer,'text=%1,icon=xwin16.png:23,panel=bottom,align=begin'['Zakończ'@],'menu:Z') ?};

   _formula:="
      {? cur_tab(1,1).ATR<>''
      || 'xwin16.png:50'
      || exec('pusta','#icon')
      ?}
   ";
   _tab.win_fml(_wer,,'POZ',,'ICON_BEFORE',_formula);

   _tab.win_sel(_wer);

   _filter:=exec('get','#params',500220,2);
   {? _tab.f_set(,,'IL_ZAM<>IL_ZL'+{? _filter<>'' || ' and '+_filter || '' ?})
   ||
::    Otwieram bieżącą maskę technologii
      exec('tktl_use','tech_common');

::    Środowisko generatora z pozycji zamówień
      _env_zlisty:=exec('env_zlisty','!tte_pzl_dzwe',_tab);
      params_set('env_zlisty',_env_zlisty);

      {? _tab.select()
      || {? zkp_ref<>''
         || _result:=exec('FindAndGet','#table',ZK_P, zkp_ref,,"ZK_P.ref",null())
         || _result:=exec('FindAndGet','#table',ZK_P, _tab.REF,,"ZK_P.ref",null())
         ?}
      || _result:=null()
      ?}
   ?}
?};
VAR_DEL.delete('zkp_ref');
ZL.cntx_pop(); ZGH.cntx_pop(); ZGP.cntx_pop(); ZLIM.cntx_pop();
exec('tktl_cntx_pop','tech_common');

_result


\przypisz_zlecenie_nadrzedne
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Formuła dla czynności recznej - ptrzypisania zlecenia do zlecenia nadrzędnego.
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_out:=params_get().out;
_mp:=params_get().mp;


:: Parametr typu _ZL - wskazanie na zlecenie do powiązania
_zlecenie:=_in.p01;
:: Parametr typu _ZL - wskazanie na zlecenie nadrzędne
_nadrzedne:=_in.p02;

_result:=0;

{? _zlecenie<>null() & _nadrzedne<>null()
|| ZL.cntx_psh();
   ZL.clear();
   {? ZL.seek(_zlecenie)
   || ZL.NRNZL:=exec('FindAndGet','#table',ZL,_nadrzedne,,"UNRZL",0);
      ZL.NRPZL:=ZL.NRNZL;
      ZL.LEVEL:=1;
      ZL.TREE:=#exec('FindAndGet','#table',ZL,_nadrzedne);
      ZL.NODE:=$_nadrzedne;
      ZL.put();
      _result:=1
   || _msg:='Niezgodność wywołania czynności.\nNie odnaleziono zlecenia do powiązania.'@@;
      FUN.emsg(_msg);
      _mp.error(_msg);
      _result:=0
   ?};
   ZL.cntx_pop()
|| _msg:='Niezgodność wywołania czynności.\nBłędne parametry wywołania.'@@;
   FUN.emsg(_msg);
   _mp.error(_msg);
   _result:=0
?};

_result


\zlec_niezalezne
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS: Generowanie zlecenia niezależnego bez pytań dla czynności ręcznej w procesie
::   WE:  [p01] - _ZK_P - pozycja zamówienia do utworzenia zlecenia
::   WY: _ZL - wskazanie na utwożony nagłowek zlecenia
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_out:=params_get().out;
_mp:=params_get().mp;

_typ_zl:='P';
{? _>0 & type_of(_a)=type_of('')
|| _typ_zl:=_a
?};


_result:=0;
_zk_p:=null();

:: Weryfikacja czy są parametry a jeśli są to czy pierwszy jest typu ZK_P
{? var_press('_in')<>0
|| {? var_press('p01',_in)=type_of(null())
   || _zk_p:=_in.p01
   ?}
?};

:: Zmienne dla potrzeb generowania zlecenia
_args_gen:=exec('gen_zlec_a','zl_gen');

:: Typ zlecenia - narazie na sztywno 'P'
ZTP.cntx_psh();
ZTP.index('TP');
ZTP.clear();
ZTP.prefix(_typ_zl, _typ_zl);
{? ZTP.first()
|| _args_gen.ZTP:=ZTP.ref()
?};
ZTP.cntx_pop();

::      Termin i data realizacji na rok do przodu - tak aby nie przeszkadzało w generowaniu zleceń połączonych
_args_gen.PL_DIR:=-1;
_args_gen.DTR:=_args_gen.PL_DATA:=date()+365;
_args_gen.OPIS:='Zlecenie zbiorcze niezależne';
_args_gen.ILOSC:=0;
_args_gen.COMPLEX:='N';
_args_gen.RODZAJ:='N';
_args_gen.DIALOG_WOL_NR:=0;
_zl:=exec('zl_dolacz_n','qprodukcja','P',_args_gen.ZTP,_args_gen);

{? _zl<>null()
|| 'Akceptacja zlecenia zbiorczego - zawsze zaakceptowane';
   exec('zl_akceptuj','!tte_pzl_eakc',_zl,0,0,,0);
   _mp.save(exec('kind_out','#b_port'),'OUT',_zl);
   _result:=1
|| _result:=0
?};

_result


\aktualizuj_zlecenie_nadrzedne
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Formuła dla czynności recznej - aktualizacja zlecenia nadrzędnego o wartości ze zlecenia podrzednego
::       UWAGA: do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_out:=params_get().out;
_mp:=params_get().mp;


:: Parametr typu _ZL - wskazanie na zlecenie do podrzędne
_zlecenie:=_in.p01;
:: Parametr typu _ZL - wskazanie na zlecenie do aktualizacji
_nadrzedne:=_in.p02;

_result:=0;

{? _zlecenie<>null() & _nadrzedne<>null()
|| ZL.cntx_psh();
   ZL.clear();
   {? ZL.seek(_zlecenie)
   || _ktm:=ZL.KTM;
      _kh:=ZL.KH;
      _projekt:=ZL.PROJEKTY;
      _opis:=ZL.OPIS;
      _uwagi:=ZL.UWAGI;
      _dtr:=ZL.DTR;
      _pl_data:=ZL.PL_DATA;
      _pl_dir:=ZL.PL_DIR;
::      _px_obj:=exec('get_zkp_object','px_obj',ZK_P.ref()); Dodać wskazanie na termin realizacji z planu strategicznego
      {? ZL.seek(_nadrzedne)
      || ZL.KTM:=_ktm;
         ZL.KH:=_kh;
         ZL.PROJEKTY:=_projekt;
         ZL.OPIS:='ZL.ZB. - '+_opis;
         ZL.UWAGI:=_uwagi;
         ZL.DTR:=_dtr;
         ZL.PL_DATA:=_pl_data;
         ZL.PL_DIR:=_pl_dir;
         _result:=ZL.put()
      || _msg:='Niezgodność wywołania czynności.\nNie odnaleziono zlecenia do aktualizacji.'@@;
         FUN.emsg(_msg);
         _mp.error(_msg);
         _result:=0
      ?}
   || _msg:='Niezgodność wywołania czynności.\nNie odnaleziono zlecenia podrzędnego.'@@;
      FUN.emsg(_msg);
      _mp.error(_msg);
      _result:=0
   ?};
   ZL.cntx_pop()
|| _msg:='Niezgodność wywołania czynności.\nBłędne parametry wywołania.'@@;
   FUN.emsg(_msg);
   _mp.error(_msg);
   _result:=0
?};

_result


\ustal_PL_DATA
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS:  Funkcja dla czynności manualne - ustala wewnętrzny termin realizacji zlecenia na podstawie
::        palnu strategicznego
::        Zlecenie
::   WE:  wykonanie w kontekście czynności potrzebne parametry p1 - ZL.ref, p2 - ZL.TKTL, p3 - ZGH.ref, p4 - ZK_P
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_mp:=params_get().mp;

_result:=1;

{? var_press('p01',_in)<>type_of(null())
|| _msg:='Niezgodność wywołania czynności.\nBłędne parametry wywołania P01 - ZL.'@@;
   FUN.emsg(_msg);
   _mp.error(_msg);
   _result:=0
|| _zlec:=_in.p01
?};

{? var_press('p02',_in)<>type_of(null())
|| _tktl_z:=null()
|| _tktl_z:=_in.p02
?};

{? var_press('p03',_in)<>type_of(null())
|| _zgh:=null()
|| _zgh:=_in.p03
?};

{? var_press('p04',_in)<>type_of(null())
|| _msg:='Niezgodność wywołania czynności.\nBłędne parametry wywołania P04 - ZK_P.'@@;
   FUN.emsg(_msg);
   _mp.error(_msg);
   _result:=0
|| _zk_p:=_in.p04
?};


{? _result
|| _zk_p_pl_data:=exec('FindAndGet','#table',ZK_P,_zk_p,,"ZK_P.PL_DATA",date(0,0,0));
:: wewnętrzny termin realizacji
   _pl_data:=_zk_p_pl_data;
:: planowana data startu - dla potrzeb zlim
   _st_data:=_zk_p_pl_data;

   _px_obj:=sql('select PX_OBJ.REFERENCE as REF from PX_OBJ where PX_OBJ.ZK_P=:_a',_zk_p).REF;

:: Tabela z pozycjami planu strategicznego
   {? _px_obj<>''
   || _tab_px_poz:=sql('
                     select PX_POZ.DATE_MIN,
                            PX_POZ.DATE_MAX,
                            PX_STAGE.RTOPER,
                            PX_STAGE.RTKTL,
                            TOPER.NROP,
                            TOPER.OPER,
                            TKTL.KTM
                       from @PX_POZ
                       join PX_STAGE
                       join @PX_VER
                       join @TOPER using(PX_STAGE.TOPER,TOPER.REFERENCE)
                       join @TKTL using(TOPER.NRK,TKTL.REFERENCE)
                      where PX_VER.PRIMARY=1 and PX_POZ.PX_OBJ=\':_a\'
                    ',_px_obj
                      );
      {? _tab_px_poz.first()
      ||
:: Tabela z pozycjami przewodnika
        {? _zgh<>null()
        || _tab_zgp:=sql('select ZGP.NRP as NRPPP,
                               TOPER.SRC as TOPER,
                               ZL.TKTL,
                               TOPER.NROP,
                               TOPER.OPER,
                               ZL.KTM
                          from ZGP
                          join ZL join @TOPER using(ZGP.TOPER,TOPER.REFERENCE)
                         where ZGP.NRPRZ=:_a and ZGP.TPZ=\'N\'
                         order by NRPPP
                       ',_zgh
                      )
        || _tab_zgp:=sql('select ZGP.NRP as NRPPP,
                               TOPER.SRC as TOPER,
                               ZL.TKTL,
                               TOPER.NROP,
                               TOPER.OPER,
                               ZL.KTM
                          from ZGP
                          join ZL join @TOPER using(ZGP.TOPER,TOPER.REFERENCE)
                         where ZGP.ZL=:_a and ZGP.TPZ=\'N\'
                         order by NRPPP
                       ',_zlec
                      )
        ?};
:: Jeśli są operacje - odszukuję ostatnią
         {? _tab_zgp.last()
         || _pl_data:=sql('
                            select :_a.NROP,
                                   :_a.OPER,
                                   :_a.KTM,
                                   max(:_a.DATE_MAX) as PL_DATA
                              from :_a
                             where :_a.NROP=\':_b\' and :_a.OPER=\':_c\' and :_a.KTM=\':_d\'
                          group by :_a.NROP, :_a.OPER, :_a.KTM
                          ', _tab_px_poz, _tab_zgp.NROP, _tab_zgp.OPER, _tab_zgp.KTM
                         ).PL_DATA
         ?};
         {? _tab_zgp.first()
         || _st_data:=sql('
                            select :_a.NROP,
                                   :_a.OPER,
                                   :_a.KTM,
                                   max(:_a.DATE_MIN) as ST_DATA
                              from :_a
                             where :_a.NROP=\':_b\' and :_a.OPER=\':_c\' and :_a.KTM=\':_d\'
                          group by :_a.NROP, :_a.OPER, :_a.KTM
                          ', _tab_px_poz, _tab_zgp.NROP, _tab_zgp.OPER, _tab_zgp.KTM
                         ).ST_DATA
         ?};
:: Weryfikacja czy daty planowane nie są w przeszłości
         {? _pl_data<date() || _pl_data:=date()+1 ?};
         {? _st_data<date() || _st_data:=date()+1 ?};

         {? (_zk_p_pl_data<>_st_data | _zk_p_pl_data<>_pl_data) & _pl_data>date(0,0,0)
::      {? (_zk_p_pl_data<>_st_data | _zk_p_pl_data<>_pl_data) & _pl_data>date(0,0,0) & _pl_data<=_zk_p_pl_data
         ||
:: odczytanie danych dla potrzeb zmiany w zleceniu
            ZL.cntx_psh();
            ZL.clear();
            {? ZL.seek(_zlec)
            || {? ZL.PL_DATA<>_pl_data | ZL.STARTD<>_st_data
               || exec('openmask','zl_common',ZL.ref());
                  ZL.PL_DATA:=_pl_data;
                  ZL.STARTD:=_st_data;
                  ZL.put();
                  ZLIM.index('ZKN');
                  ZLIM.prefix(ZL.ref());
                  {? ZLIM.first()
                  || {!
                     |? ZLIM.STARTD:=ZL.STARTD;
                        ZLIM.STARTT:=ZL.PL_TIME;
                        {? ZLIM.put()
                        || exec('zkp_date_upd','zamsiw_limit',ZLIM.ref())
                        ?};
                        ZLIM.next()
                     !}
                  ?}
               ?}
            ?};
            ZL.cntx_pop()
         ?}
      ?}
   ?};

:: Dodatkowo - odakceptowanie zlecenia (powstają zlecenia w przygotowaniu)
   ZL.cntx_psh();
   ZL.clear();
   {? ZL.seek(_zlec)
   ||ZL.STAN:='N';
     ZL.HIDDEN:='T';
     exec('ust_znac','zl_head');
     ZL.put();
     exec('obl_prod','magazyn_stan',ZL.KTM,ZL.MG,2);
     exec('add_zwar_pos','zl_common','on',0,,ZL.ref());
::             Zmiana statusu zamówień wewnętrznych
     exec('ZK_N_4_ZL_aKC','zamsiw_nag',ZL.ref(),'N')
   ?};
   ZL.cntx_pop()
?};

_result


\popraw_nag_podzlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS: Czynność manualna w procesie podzleceń prostych niezależnych
::   WE:  p01 - ZL.ref - zlecenie do poprawy p02 - ZK_P.ref - pozycja zamówienia z której generowane są podzlecenia.
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_wynik:=1;
_in:=params_get().in;

{? var_press('p01',_in)<>type_of(null()) || return(-1) ?};
{? var_press('p02',_in)<>type_of(null()) || return(-1) ?};

_zl:=_in.p01;
_zk_p:=_in.p02;

VAR_DEL.delete('qkh','qsym_zam');
qkh:=null();
qsym_zam:='';

:: Symbol zamówienia na podstawie ZK_P oraz KH.ref
{? _zk_p<>null & _zl<>null()
|| qkh:=exec('FindAndGet','#table',ZK_P,_zk_p,,"ZK_P.KH",null());
:: weryfikacja czy zlecenie na podstawie kilku zamówień i czy jest potrzeba coś dopisywać (do zamówień na wyrób nie trzeba)
   _zl0:=sql('select ZLZAM.ZL from ZLZAM where ZLZAM.ZAMPOZ=\':_a\'',$_zk_p).ZL;
   _tab:=sql('select ZLZAM.ZAMPOZ from ZLZAM where ZLZAM.ZL=\':_a\'',_zl0);
   {? _tab.first()
   || _zk_n:=exec('FindAndGet','#table',ZK_P,_tab.ZAMPOZ,,"ZK_P.N",null());
      _sym_zam:=exec('FindAndGet','#table',ZK_N,_zk_n,,"ZK_N.SYM",'');
      _poz_zam:=exec('FindAndGet','#table',ZK_P,_tab.ZAMPOZ,,"' p. '+$ZK_P.POZ",'');
      qsym_zam:='('+_sym_zam+_poz_zam;
      _loop:=_tab.next();
      {!
      |? _loop
      |! _zk_n:=exec('FindAndGet','#table',ZK_P,_tab.ZAMPOZ,,"ZK_P.N",null());
         _sym_zam:=exec('FindAndGet','#table',ZK_N,_zk_n,,"ZK_N.SYM",'');
         _poz_zam:=exec('FindAndGet','#table',ZK_P,_tab.ZAMPOZ,,"' p. '+$ZK_P.POZ",'');
         qsym_zam+=','+_sym_zam+_poz_zam;
         _loop:=_tab.next()
      !};
      qsym_zam+=') '
   || _zk_n:=exec('FindAndGet','#table',ZK_P,_zk_p,,"ZK_P.N",null());
      qsym_zam:=exec('FindAndGet','#table',ZK_N,_zk_n,,"' ('+ZK_N.SYM+')'",'')
               +exec('FindAndGet','#table',ZK_P,_zk_p,,"' p. '+$ZK_P.POZ",'')
   ?};
:: Jeśli udało się coś ustalić to zmiany na zleceniu
   exec('FindAndGet','#table',ZL,_zl,,"
                                       {? ZL.KH=null()
                                       || ZL.KH:=qkh
                                       ?};
                                       ZL.OPIS:=qsym_zam+ZL.OPIS;
                                       ZL.put()
                                      ",0)
?};

VAR_DEL.delete('qkh','qsym_zam');

_wynik


\wyznacz_zk_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_CPD]
:: OPIS: Dla czynności manualnej ZK_P - proces NUCO_RPO_ZLN wyznacza ZK_P.ref na podstsawie przekazanych parametrów
::   WE: p01 - ZK_P.ref - przekazany z procesu
::       p02 - ZK_P.ref - przekazany z syganłu z pozycji zamówień
::       p03 - PX_CONN.ref - przekazany z sygnału z pozycji planu strategicznego
::       p04 - PX_CONN.ref - przekazany z sygnału z pozycji planu strategicznego
::   WY: ZK_P.ref lub null jeśli coś nie tak
::----------------------------------------------------------------------------------------------------------------------
_zk_p:=null();

_mp:=params_get().mp;
_in:=_mp.load(exec('kind_in','#b_port'));

{? var_pres('p03',_in)<>type_of(~~)
|| _px_conn:=$_in.p03
|| _px_conn:=''
?};

{? var_pres('p01',_in)<>type_of(~~)
|| _zk_p:=_in.p01
|? var_pres('p02',_in)<>type_of(~~)
|| _zk_p:=_in.p02
|? var_pres('p04',_in)<>type_of(~~)
|| _zk_p:=_in.p04
|? _px_conn<>''
||
   _px_grp:=sql('select PX_CONN.PX_GRP from @PX_CONN where PX_CONN.REFERENCE=\':_a\'',_px_conn).PX_GRP;
   _tab:=sql('select PX_OBJ.ZK_P
                from @PX_CONN join PX_OBJ using (PX_CONN.PX_OBJ,PX_OBJ.REFERENCE)
               where PX_CONN.PX_GRP=\':_a\' and PX_CONN.PX_OBJ is not null
            order by ZK_P',_px_grp);
   {? _tab.size()=1
   || {? _tab.ZK_P<>''
      || _zk_p:=exec('FindAndGet','#table',ZK_P,_tab.ZK_P)
      ?}
   |? _tab.size()>1
   || _tab.first();
      _zkp_ref:=_tab.ZK_P;
      {!
      |? exec('add','#bulk',ZK_P,'GEN_ZLEC',_zkp_ref+_tab.ZK_P);
         _tab.next()
      !};
      _zk_p:=exec('FindAndGet','#table',ZK_P,_zkp_ref)
   ?}
?};

_mp.save(exec('kind_out','#b_port'),'OUT',_zk_p);

{? _zk_p<>null()
|| _result:=1
|| _result:=0
?};

_result


\usun_zk_p2zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Usunięcie z bazy BULK rekordóe związanych z przekazanym ZK_P
::   WE: _in.p01 ZK_P.ref
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: Obiekt z komentażami
:: Środowisko czynności manualnej tworzenia zleceń na podstawie listy zamówień
_in:=params_get().in;
_out:=params_get().out;
_mp:=params_get().mp;

_result:=1;
_zk_p:=_in.p01;

{? exec('get','#bulk',ZK_P,'GEN_ZLEC',$_zk_p + $_zk_p)
|| BULK.clear();
   BULK.index('UNIQUE');
   BULK.prefix('ZK_P','GEN_ZLEC',$_zk_p);
   {? BULK.first()
   || {!
      |?
         BULK.del()
      !}
   ?}
?};

_result


\akt_prop_ceny
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Aktywacja propozycji ceny (kalkulacja wstępna zlecenia) w procesie tworzenia zleceń niezależnych
::   WE: in.p01 - ZL.ref
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=1;

:: Środowisko czynności manualnej
_in:=params_get().in;
_out:=params_get().out;
_mp:=params_get().mp;

VAR.A01:='0';
VAR.A_ZLEC:=_in.p01;
VAR.A_WARZ:=VAR.A_ZLEC().DEF_OPCK;
ANZH.cntx_psh();
ANZH.index('ZN');
ANZH.prefix(VAR.A01,VAR.A_ZLEC);
{? ANZH.last()
|| params_exec('anal2cena','material_prod',0,1)
|| _msg:='Nie odnaleziono kalkulacji wstępnej dla zlecenie %1, nie udało się aktywować ceny.'@[VAR.A_ZLEC().SYM];
   _mp.error(_msg);
   _result:=0
?};

_result


\gen_grp_zkp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Zlecenie dla grupy pozycji zamówień - uruchamiane w procesie NUCO zlecenia niezależne
::   WE: _in.p01 - ZK_P.ref - pozycja zamówienia do utworzenia zlecenia (podstawowa - pozostałe mogą znajdować się w tabeli BULK)
::       [_in.p02] - ZL.ref - zlecenie nadrzędn
::   WY:
::----------------------------------------------------------------------------------------------------------------------
KOMM.init(,,'Generowanie zleceń'@,'');

:: Środowisko czynności manualnej tworzenia zleceń na podstawie listy zamówień
_in:=params_get().in;
_out:=params_get().out;
_mp:=params_get().mp;

ST.ODDZ:='w';
ST.AR:=date()~1;
ST.AM:=date()~2;

_zlecenie:=null();
_zlec_nad:={? var_press('p01',_in)<>type_of(null())|| null || _in.p02 ?} ;
_zk_p:=_in.p01;
_result:=1;

:: Typ zlecenia - narazie na sztywno 'P'
ZTP.cntx_psh();
ZTP.index('TP');
ZTP.clear();
ZTP.prefix('P','P');
{? ZTP.first()
|| VAR.A_TPZL:=ZTP.ref()
|| VAR.A_TPZL:=null()
?};
ZTP.cntx_pop();

:: Środowisko generowania zleceń z pozycji zamówień
_env_gen:=exec('env_gen','zl_gen');
:: redagowanie typu zlecenia
_env_gen.edit_ZTP:=0;
:: redagowanie ilości
_env_gen.edit_IL:=0;
:: redagowanie karty technologicznej
_env_gen.edit_TKTL:=0;
:: redagowanie znacznika, czy zlecenie złożone
_env_gen.edit_COMPLEX:=0;
:: redagowanie zlecenia do którego się łaczymy
_env_gen.edit_MERGE:=0;
params_set('env_gen',_env_gen);


:: Otwarcei odpowiedniego REZ (później funkcja aktualizująca wzoruje się na REZ.name - więc jak nie ma otwartej to
:: źle otwiera maski przy tworzeniu rezerwacji
REZ.cntx_psh();
REZ.use((REZ.name()-3)+'w__');

ZK_P.cntx_psh();
ZK_P.use(8+$_zk_p);
ZK_P.prefix();
{? ZK_P.seek(_zk_p)
|| ZK_N.cntx_psh();
   ZK_N.use(8+($ZK_P.N));
   ZK_N.prefix();
   {? ZK_N.seek(ZK_P.N)
   || ZLZAM.cntx_psh();
      ZLZAM.index('ZMZL');
      ZLZAM.prefix($ZK_P.ref());
      _il_zlec:=0;
      {? ZLZAM.first()
      || {!
         |? _il_zlec+=ZLZAM.ILZL;
            ZLZAM.next()
         !}
      ?};
      ZLZAM.cntx_pop();
      _args_zl:=exec('zkp2args','zl_gen');
      _args_zl.GRUPA:=1;
      _args_zl.DIALOG:=0;
      _args_zl.ZTP:=VAR.A_TPZL;
      _args_zl.ZL_NAD:=_zlec_nad;
      _args_zl.COMPLEX:='N';
      _args_zl.MERGE:=0;
      _args_zl.TKTL:=(ZK_P.M();exec('wyb_ktl','zl_gen',0));
      _args_zl.ILOSC:=ZK_P.ILZ-_il_zlec;
      _args_zl.GRP_KEY:='';
      _args_zl.OPIS:='(%1 p. %2) Zlecenie na podstawie zam.'[ZK_P.N().SYM,$ZK_P.POZ];
:: Generowanie zlecenia podstawowego
      params_exec('auto_zkp','!tte_pzl_dzwe',_args_zl);
      _zlecenie:={? _args_zl.RESULT.tab.first()
                 || exec('FindAndGet','#table',ZL,_args_zl.RESULT.tab.SQL,,"ref()",null())
                 || _result:=0;
                    null()
                 ?};
      {? _zlecenie<>null() & exec('get','#bulk',ZK_P,'GEN_ZLEC',$_zk_p + $_zk_p)
      || BULK.clear();
         BULK.index('UNIQUE');
         BULK.prefix('ZK_P','GEN_ZLEC',$_zk_p);
         _i:=0;
         {!
         |? {? $_zk_p<>(BULK.WARTOSC+16)
            || ZK_P.use(8+(BULK.WARTOSC+16));
               ZK_P.prefix();
               {? ZK_P.seek((BULK.WARTOSC+16))
               || ZK_N.use(8+($ZK_P.N));
                  ZK_N.prefix();
                  {? ZK_N.seek(ZK_P.N)
                  || ZLZAM.cntx_psh();
                     ZLZAM.index('ZMZL');
                     ZLZAM.prefix($ZK_P.ref());
                     _il_zlec:=0;
                     {? ZLZAM.first()
                     || {!
                        |? _il_zlec+=ZLZAM.ILZL;
                           ZLZAM.next()
                        !}
                     ?};
                     ZLZAM.cntx_pop();
                     _args_zl2:=exec('zkp2args','zl_gen');
                     _args_zl2.GRUPA:=1;
                     _args_zl2.DIALOG:=0;
                     _args_zl2.ZTP:=VAR.A_TPZL;
                     _args_zl2.ZL_NAD:=_zlec_nad;
                     _args_zl2.COMPLEX:='N';
                     _args_zl2.MERGE:=1;
                     _args_zl2.ZL_MERGE:=_zlecenie;
                     _args_zl2.ILOSC:=ZK_P.ILZ-_il_zlec;
:: Generowanie zleceń dodatkowych
                     params_exec('auto_zkp','!tte_pzl_dzwe',_args_zl2);
                     &_args_zl2
                  ?}
               ?}
            ?};
            BULK.del()
         !}
      ?}
   ?};
   ZK_N.cntx_pop()
?};
ZK_P.cntx_pop();
REZ.cntx_pop();


{? _zlecenie<>null()
|| _mp.save(exec('kind_out','#b_port'),'OUT',_zlecenie);
   _result:=1
|| _result:=0
?};

_result


\wer_daty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_CPD]
:: OPIS: Weryfikacja czy pozycja zamówieni ma poprawną datę i czy ewentualnie ją zmienić ?
::   WE: p01 - ZK_P.ref - przekazany z procesu
::
::   WY: 1 - jeśli ok, 0 - jeśli nie ok
::----------------------------------------------------------------------------------------------------------------------
_zk_p:=null();
_result:=0;
_out:=0;

_mp:=params_get().mp;
_in:=_mp.load(exec('kind_in','#b_port'));

{? var_pres('p01',_in)<>type_of(~~)
|| _zk_p:=_in.p01
?};

{? _zk_p<>null()
|| _ok:=exec('FindAndGet','#table',ZK_P,_zk_p,,"PL_DATA>=date()",-1);
   {? _ok=1
   || _out:=1;
      _result:=1
   |? _ok=0
   || _wyb:=FUN.choice('Termin realizacji zamówienia minął, czy chesz go skorygować?',,'Tak','Nie',,,,' - Weryfikacja terminu realizacji zamówienia');
      {? _wyb=0
      || FUN.info('Zrezygnowano z wykonania zadania.\nZadanie zostanie umieszczone na liście TODO');
         _out:=0;
         _result=0
      |? _wyb=1
      || PX_OBJ.cntx_psh();
         ZK_P.cntx_psh();
         ZK_N.cntx_psh();
         ZK_P.use(ref_name(_zk_p));
         ZK_P.seek(_zk_p);
         ZK_N.use(ref_name(ZK_P.N));
         PX_OBJ.index('ZK_P');
         PX_OBJ.prefix(ref_name(_zk_p),_zk_p);
         {? PX_OBJ.first()
         || PX_OBJ.ZK_P().POZ;
            params_exec('pop_pozy','qprocesy',1);
            {? exec('FindAndGet','#table',ZK_P,_zk_p,,"PL_DATA>=date()",0)
            || _out:=1;
               _result:=1
            || FUN.info('Zmieniona data realizacji jest w przeszłości.\nZadanie zostało ponownie wpisane na listę TODO');
               _out:=0;
               _result:=0
            ?}
         || FUN.error('Nie udało się odnaleźć obiektu do planowania - zk_p');
            _out:=0;
            _result:=1
         ?};
         ZK_P.cntx_pop();
         ZK_N.cntx_pop();
         PX_OBJ.cntx_pop()
      |? _wyb=2
      ||  FUN.info('Zrezygnowano ze zmiany daty realizacji zamówienia.\nProces generowania zleceń został anulowany.');
          _out:=0;
         _result:=1
      ?}
   || FUN.error('Nie odnaleziono pozycji zamóienia, kontynuacja procesu niemożliwa');
      _out:=0;
      _result:=1
   ?}
|| FUN.error('Nie odnaleziono pozycji zamóienia, kontynuacja procesu niemożliwa');
   _out:=0;
   _result:=1
?};

_mp.save(exec('kind_out','#b_port'),'OUT',_out);
_result


\zlec_podrzedne
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS: Generowanie zlecenia niezależnego bez pytań dla czynności ręcznej w procesie
::   WE:  [p01] - _ZK_P - pozycja zamówienia do utworzenia zlecenia
::        [p02] - _ZL - zlecenie nadrzędne
::   WY: _ZL - wskazanie na utwożony nagłowek zlecenia
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_out:=params_get().out;
_mp:=params_get().mp;

_result:=0;
_zk_p:=null();
_zl_nad:=null();

:: Weryfikacja czy są parametry a jeśli są to czy pierwszy jest typu ZK_P
{? var_press('_in')<>0
|| {? var_press('p01',_in)=type_of(null())
   || _zk_p:=_in.p01
   ?};
   {? var_press('p02',_in)=type_of(null())
   || _zl_nad:=_in.p02
   ?}
?};

:: Zmienne dla potrzeb generowania zlecenia
_args_gen:=exec('gen_zlec_a','zl_gen');

:: Typ zlecenia - narazie na sztywno 'P'
ZTP.cntx_psh();
ZTP.index('TP');
ZTP.clear();
ZTP.prefix('P','P');
{? ZTP.first()
|| _args_gen.ZTP:=ZTP.ref()
?};
ZTP.cntx_pop();

:: Jeśli podano w p01 ZK_P to odczytujemy co się da z pozycji zamówienia
{? _zk_p<>null() & _zl_nad<>null()
|| _zamowienie:=sql('select M.KTM,
                            ZK_P.POZ as POZ_ZAM,
                            ZK_N.SYM as ZAM,
                            ZK_P.DT as DTR,
                            ZK_P.KH,
                            ZK_P.ILP as ILOSC,
                            ZK_P.PL_DATA,
                            ZK_P.PL_TIME,
                            ZK_P.PL_DIR,
                            ZK_P.PL_FORCE,
                            ZK_P.PROJEKTY,
                            ZK_P.U as UWAGI,
                            ZK_P.M as M
                       from @ZK_P join @ZK_N using(ZK_P.N,ZK_N.REFERENCE)
                                  join M using(ZK_P.M,M.REFERENCE)
                      where ZK_P.REFERENCE=:_a',
                      _zk_p);
   {? _zamowienie.first()
   || _args_gen.KTM:=_zamowienie.KTM;
      {? _zamowienie.DTR<date()+1
      || _args_gen.DTR:=date()+2
      || _args_gen.DTR:=_zamowienie.DTR
      ?};
      _args_gen.ILOSC:=_zamowienie.ILOSC;
      _args_gen.KH:=_zamowienie.KH;
:: Weryfikacja czy data generowania nie jest w przeszłości
      {? _zamowienie.PL_DATA<date()+1
      || _args_gen.PL_DATA:=date()+2
      || _args_gen.PL_DATA:=_zamowienie.PL_DATA
      ?};
      _args_gen.PL_TIME:=time(6,0,0);
      _args_gen.PL_DIR:=1;
      _args_gen.PL_FORCE:='T';
      {? _zamowienie.PROJEKTY<>''
      || _args_gen.PROJEKTY:=exec('FindAndGet','#table',PROJEKTY,_zamowienie.PROJEKTY,,"PROJEKTY.ref()",null)
      ?};
      _args_gen.OPIS:='Zlecenie do zam. wew.(%1 p. %2)'[_zamowienie.ZAM,$_zamowienie.POZ_ZAM];
      _args_gen.UWAGI:=_zamowienie.UWAGI;
      _args_gen.OPIS_DOD:=' Podstawa zam.: '+_zamowienie.ZAM
                          +', poz.: '+ $_zamowienie.POZ_ZAM+', KTM: '+_zamowienie.KTM
                          +', Ilość z zamowienia: '+ $_zamowienie.ILOSC;
      _args_gen.COMPLEX:='N';
      _args_gen.RODZAJ:='P';
      _args_gen.DIALOG_WOL_NR:=0;
      _m_ref:=exec('FindAndGet','#table',M,_zamowienie.M,,"M.ref()",null);
::                   Ustalenie karty technologicznej
      M.cntx_psh();
      M.clear();
      {? exec('enabled','zl_uslugi')
      || M.index('MATKTM');
         M.prefix(_args_gen.KTM,)
      || M.index('RODZ');
         M.prefix('T',_args_gen.KTM,)
      ?};
      {? exec('get_w','#params',9986,2,OPERATOR.USER)='T' &  M.first()
      || _args_gen.TKTL:=exec('wyb_ktl','zl_gen',1,0)
      ?};
      M.cntx_pop();

      {? _args_gen.TKTL=null()
      || _args_gen.TKTL:=exec('getdefaulttech','tech_common',_m_ref,1)
      ?};

      _zl:=exec('gen_zlec','zl_gen', _args_gen);

      {? _zl<>null()
      || _mp.save(exec('kind_out','#b_port'),'OUT',_zl);
         _result:=1
      ?}
   || _mp.error('Nieodnaleziono rekordu pozycji zamówienia - kontynuacja niemożliwa')
   ?}
|| _mp.error('Błędne parametry wywołania - ZK_P bądź ZL (nadrzędne)')
?};

_result


\key_zlim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Wystawia klucz grupujący z pozycjami Limitów dla których należy wygenerować zlecenia niezależne
::   WE: [_a] - STRING - Ref SQL - ZL (zlecenie dla którego wygenerowano limity i do nich trzeba wygenerować zlecenia)
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ar:='';
{? var_pres('_a')=type_of('')
|| _ar:=_a
?};

_mp:=params_get().mp;
_in:=params_get().in;

::  ZLECENIE - może też przyjść w parametrze wejściowym ITEM
{? _in.ITEM<>''
|| _ar:=_in.ITEM
?};

_mp.grpkey();

_tab_1:=sql('select ZLIM.KTM, ZLIM.REFERENCE as REF from @ZLIM join TMAT
               where ZLIM.ZLEC=\':_a\' and (TMAT.KTL<>\'\' or TMAT.DFLT_KTL=\'T\')',_ar);
{? _tab_1.first()
|| {!
   |? _tab_2:=sql('select ZK_P.REFERENCE as REF from @ZK_P
                     where ZK_P.M_ZLIM=\':_a\' and ZK_P.ZLIM=\':_b\'',8+_tab_1.REF,_tab_1.REF);
      {? _tab_2.first()
      || {!
         |? _mp.grpkeyAdd(_tab_2.REF);
            _tab_2.next()
         !}
      ?};
      &_tab_2;
      _tab_1.next()
   !}
?};

_mp.done();
~~


\auto_PL_DATA
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_DEV]
:: OPIS:  Funkcja dla czynności manualne servisowej - ustala wewnętrzny termin realizacji zlecenia na podstawie
::        danych z zamówienia klienta
::   WE:  wykonanie w kontekście czynności potrzebne parametry p1 - ZL.ref, p2 - ZK_P
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_mp:=params_get().mp;

_result:=1;

{? var_press('p01',_in)<>type_of(null())
|| _msg:='Niezgodność wywołania czynności.\nBłędne parametry wywołania P01 - ZL.'@@;
   FUN.emsg(_msg);
   _mp.error(_msg);
   _result:=0
|| _zlec:=_in.p01
?};

{? var_press('p02',_in)<>type_of(null())
|| _msg:='Niezgodność wywołania czynności.\nBłędne parametry wywołania P02 - ZK_P.'@@;
   FUN.emsg(_msg);
   _mp.error(_msg);
   _result:=0
|| _zk_p:=_in.p02
?};


{? _result
|| _zk_p_pl_data:=exec('FindAndGet','#table', ZK_P ,_zk_p,,"@.ZK_P.PL_DATA",date(0,0,0));
   _zk_p_dt:=exec('FindAndGet','#table',ZK_P,_zk_p,,"@.ZK_P.DT",date(0,0,0));
   _m:=exec('FindAndGet','#table',ZK_P,_zk_p,,"@.ZK_P.M",null());
   _pl_data:=_zk_p_pl_data;
:: odczytanie danych dla potrzeb zmiany w zleceniu
   ZL.cntx_psh();
   ZL.clear();
   {? ZL.seek(_zlec)& _pl_data>=date() & _zk_p_dt>=date & _pl_data<=_zk_p_dt
   ||
:: Planowana data na zasadzie +7 +14
      {? (ZL.JORG().KOD='KSU'|ZL.JORG().KOD='KMO'|ZL.JORG().KOD='FSU') & _m<>ZL.KTM
      || _pl_data:=_pl_data-7
      |? (ZL.JORG().KOD='MSU'|ZL.JORG().KOD='MMO') & _m<>ZL.KTM
      || _pl_data:=_pl_data-14
      ?};
      {? _pl_data<=date()
      || _pl_data:=date()+1
      ?};
      {? ZL.PL_DATA<>_pl_data | ZL.DTR<>_zk_p_dt
      || exec('openmask','zl_common',ZL.ref());
:: Zmiana planowanej daty realizacji tylko dla zleceń na wyrób gotowy
         ZL.PL_DATA:=_pl_data;
         ZL.DTR:=_zk_p_dt;
         ZL.put()
      ?}
   ?};
   ZL.cntx_pop()
?};

_result