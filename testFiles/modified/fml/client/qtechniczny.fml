:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: qtest.fml
:: Utworzony:
:: Autor:
:: Systemy:
::======================================================================================================================
:: Zawartość:
::======================================================================================================================


\gdzie_jest_zlaczenie_do_tabeli
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [RR.xx]
:: OPIS: Wyszukiwanie tabel ze złączeniem do podanej w parametrze
::   WE: _a - akronim tabeli w relacji
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('')
|| return(~~)
?};

{? var_pres('_b')<>type_of(0)
|| _szczegoly:=0
|| _szczegoly:=_b
?};


_POM:=tab_tmp(,
   'TAB','STRING[8]','Tabela',
   'FLD','STRING[8]','Pole tabeli'
);
_TAB:=tab_tmp(,
   'TAB','STRING[8]','Tabela',
   'MASK','STRING[8]','Maska tabeli',
   'LICZ','INTEGER','Liczba wierszy powiązanych',
   'ACR','STRING[10]','Akronim tabeli tymczasowej z wskazaniem na rekordy'
);

:: Ustalenie listy tabel powiązanych.
{! _ii:=1 .. tab_num()
|! {? tab_real(_ii)
   || _alias:=tab_alias(_ii);
      _acr:=tab_acr(_ii);
      echo(_acr);
      {! _ij:=1 .. _alias.fld_num()
      |! _fld:=_alias.fld_join(_ij);
         {? _fld=_a
         || _POM.TAB:=_acr;
            _POM.FLD:=_alias.fld_acr(_ij);
            _POM.add()
         ?}
      !};
      &_alias
   ?}
!};
echo();

{? ~_szczegoly
|| exec('select','#table', _POM)
?};

:: Ustalienie liczby powiązań z podaną tabelą.
{? _szczegoly & _POM.first()
|| {!
   |? _tab:=($(_POM.TAB))();
      _names:=_tab.names();
      {? _names.first()
      || {!
         |? echo(_POM.TAB+' '+_names.NAME);
            {? _names.SIZE
            || _tab.use(_names.NAME);
               {? _names.SIZE<0
               || _tab.sort()
               ?};
               {? _tab.first()
               || _TAB.TAB:=_POM.TAB;
                  _TAB.MASK:=_names.NAME;
                  _TAB.LICZ:=0;
                  _TAB.ACR:='__'+_TAB.MASK;
                  {!
                  |? {? ($(_POM.TAB+'.'+_POM.FLD))()
                     || {? _TAB.LICZ=0
                        || ($(_TAB.ACR+':=tab_tmp(,\'SQL\',\'STRING[16]\',\'Wskazanie na rekord\')'
))()
                        ?};
                        _TAB.LICZ+=1;
                        ($(_TAB.ACR))().SQL:=$(($(_POM.TAB+'.'+_POM.FLD))());
                        ($(_TAB.ACR))().add()
                     ?};
                     _tab.next()
                  !};
                  {? _TAB.LICZ
                  || _TAB.add()
                  ?}
               ?}
            ?};
            _names.next()
         !}
      ?};
      &_tab;
      &_names;
      _POM.next()
   !}
?};
echo();

:: Wyświetlenie wyników
{? _TAB.first()
|| _wer:=_TAB.mk_sel(,,1,,,,,,'U');
   _TAB.win_act(_wer,,'Formuła','Wyświetl',,'Wyświetlenie powiązań',
      "  _tab:=($(cur_tab().ACR))();
         _tab.win_sel(_tab.mk_sel(,,1));
         _tab.select()
      ",,1
   );
   _TAB.win_act(_wer,,'Kolejność');
   _TAB.win_sel(_wer);
   _TAB.select();
   _TAB.first();
   {!
   |? obj_del(($(_TAB.ACR))());
      ($('&'+_TAB.ACR))();
      _TAB.next()
   !}
|| FUN.emsg('Brak danych do wyświetlenia')
?};
~~


\glass_load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30] - PeKa - jar nakladajacy napis na merita
:: OPIS: Laduje glassterm.jar
::----------------------------------------------------------------------------------------------------------------------
::laduje biblioteke
_glass:=obj_new(  'LIB_ID'
                  ,'CALL_START'
                  ,'CALL_UPD'
                  ,'CALL_CTEXT'
                  ,'CALL_CBCG'
                  ,'CALL_TRANS'
                  ,'CALL_MARG'
                  ,'CALL_BOR'
                  ,'CALL_BCOL'
                  ,'CALL_BWDT'
                  ,'CALL_WIDTH'
                  ,'CALL_HEIGHT'
                  ,'CALL_POS'
                  ,'start'
                  ,'setInfo'
                  ,'colorText'
                  ,'colorBackground'
                  ,'transparency'
                  ,'margins'
                  ,'borderVisible'
                  ,'borderColor'
                  ,'borderWidth'
                  ,'getWidth'
                  ,'getHeight'
                  ,'setPosition');
_glass.LIB_ID:=lib_load('glassterm.jar',1,0);
VAR_DEL.delete('__GLASS');
{? _glass.LIB_ID=0
|| FUN.emsg('Błąd załadowania biblioteki glassterm.jar')
||
:: arg 1 - info ktore wyswietlac
:: arg 2 - kolor tekstu
   _glass.CALL_START:=lib_decl(_glass.LIB_ID,,'int','start','char *');
   _glass.CALL_UPD:=lib_decl(_glass.LIB_ID,,'int','setInfo','char *');
   _glass.CALL_CTEXT:=lib_decl(_glass.LIB_ID,,'int','colorText','char *');
   _glass.CALL_CBCG:=lib_decl(_glass.LIB_ID,,'int','colorBackground','char *');
   _glass.CALL_TRANS:=lib_decl(_glass.LIB_ID,,'int','transparency','char *');
   _glass.CALL_MARG:=lib_decl(_glass.LIB_ID,,'int','setMargins','int','int','int','int');
   _glass.CALL_BOR:=lib_decl(_glass.LIB_ID,,'int','setBorderVisible','int');
   _glass.CALL_BCOL:=lib_decl(_glass.LIB_ID,,'int','setBorderColor','char *');
   _glass.CALL_BWDT:=lib_decl(_glass.LIB_ID,,'int','setBorderWidth','int');
   _glass.CALL_WIDTH:=lib_decl(_glass.LIB_ID,,'int','getGlassWidth');
   _glass.CALL_HEIGHT:=lib_decl(_glass.LIB_ID,,'int','getGlassHeight');
   _glass.CALL_POS:=lib_decl(_glass.LIB_ID,,'int','setPosition','char *');

   _glass.start:="lib_call(.CALL_START,_a)";
   _glass.setInfo:="lib_call(.CALL_UPD,_a)";
   _glass.colorText:="lib_call(.CALL_CTEXT,_a)";
   _glass.colorBackground:="lib_call(.CALL_CBCG,_a)";
   _glass.transparency:="lib_call(.CALL_TRANS,_a)";
   _glass.margins:="lib_call(.CALL_MARG,_a,_b,_c,_d)";
   _glass.borderVisible:="lib_call(.CALL_BOR,_a)";
   _glass.borderColor:="lib_call(.CALL_BCOL,_a)";
   _glass.borderWidth:="lib_call(.CALL_BWDT,_a)";

   _glass.getWidth:="lib_call(.CALL_WIDTH)";
   _glass.getHeight:="lib_call(.CALL_HEIGHT)";
   _glass.setPosition:="lib_call(.CALL_POS,_a)";
   __GLASS:=_glass;
   ~~
?};
~~


\glass_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30] - PeKa - jar nakladajacy napis na merita
:: OPIS: Uruchamiam glassTerm
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__GLASS')<100 || exec('glass_load','qtechniczny') ?};
{? var_pres('__GLASS')>100
||
:: arg 1 - info ktore wyswietlac
:: arg 2 - kolor tekstu
::----------------------------------------------------------------------------------------------------------------------
::  MOD: POLAN_1251 [22.02.2018 - 22:03]
::  UTW: PeKa
:: OPIS: Zmiany w standardowej obsludze
::----------------------------------------------------------------------------------------------------------------------
   {? OPERATOR.USER().KOD='szef'
   ||
      _span:="'<span '+_a+'>'+_b+'</span>'";
      _server_name:='NUCO';
      _serwer:=pth_dir();
      _serwer:={? _serwer*'kopia' | _serwer*'test' || ' TESTOWY ' || ' PRODUKCYJNY ' ?};
      _info:='<html><div style="font-size:14px;font-style:bold;">';
::   _info+='<img src="http://y.wpimg.pl/i/ivar/N/201209/1347627287.png" alt="tutaj obrazek"/><br>';
      _info+='Serwer: '+_span('style="font-style:bold;"',_serwer);
::      _info+='<br>';
::      _info+='Użytkownik: '+_span('style="font-style:bold;"',OPERATOR.USER().KOD);
      {? envget('@MacroGLASS')<>''
      || _info+=envget('@MacroGLASS')+'\n'
      ?};
      _info+='</div></html>';
      {? _info<>''
      ||
         __GLASS.transparency('0.9');
::      __GLASS.colorText('0:0:0');
        {? _info*'TESTOWY'
        || __GLASS.colorBackground('100:200:200')
        || __GLASS.colorBackground('255:155:0')
        ?};
         __GLASS.borderVisible(1);
         __GLASS.borderColor('0:0:0');
         __GLASS.borderWidth(1);
         __GLASS.setPosition('NORTHEAST');
         __GLASS.margins(40,5,0,10);
         __GLASS.start(_info);
         ~~
      ?}
   ||
      _span:="'<span '+_a+'>'+_b+'</span>'";
      _info:='<html><div style="font-size:14px;font-style:bold;">';
      _info+=_span('style="font-style:bold;"',_a);
      {? envget('@MacroGLASS')<>''
      || _info+=envget('@MacroGLASS')+'\n'
      ?};
      _info+='</div></html>';
      {? _info<>''
      ||
         __GLASS.transparency('0.9');
::      __GLASS.colorText('0:0:0');
        __GLASS.colorBackground('255:155:0');
         __GLASS.borderVisible(1);
         __GLASS.borderColor('0:0:0');
         __GLASS.borderWidth(1);
         __GLASS.setPosition('NORTHEAST');
         __GLASS.margins(5,10,0,130);
         __GLASS.start(_info);
         ~~
      ?}
   ?};
   lib_free(__GLASS.LIB_ID);
   VAR_DEL.delete('__GLASS');
   ~~
?};
~~


\napraw_mkodk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Funkcja naprawia zapisy dla bazy MKODK po transferze - brak zapisów o dostawie, partii itp.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_mkodk:=sql('select MKODK.REFERENCE as REF
               from @SLD join MKODK using (SLD.SCEAN, MKODK.KODK)
              where SLD.IL>0 and MKODK.IDMOB=\'N\'');
q_sel(_mkodk);
MKODK.cntx_psh();
MKODK.clear();
MKODK.index('UNIK');
MKODK.cntx_pop();
{? _mkodk.first()
|| {!
   |? {? MKODK.seek(_mkodk.REF)
      || _sc:=sql('select SC.D, SC.M, M.N, M.KTM, SC.PRDK from @SC join M where SC.SCEAN=\':_a\'',MKODK.KODK);
         {? _sc.last()
         || MKODK.M:=exec('FindAndGet','#table',M,_sc.M,,"M.ref()",null);
            MKODK.N:=_sc.N;
            MKODK.KTM:=_sc.KTM;
            MKODK.RSQL:=_sc.PRDK;
            MKODK.IDMOB:='D';
            MKODK.OPMOB:='Dostawa naprawiona';
            MKODK.put()
         || FUN.error('Nieudało się odnaleźć dostawy dla kodu: %1'@[_mkodk.SCEAN])
         ?};
         &_sc
      ?};
      _mkodk.next()
   !}
?};
MKODK.cntx_pop();
~~


\odtw_sl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [2010]
:: OPIS: odtworzenie tabeli SL
::   WE: _a- magazyn na ktorym odtwarzamy SL-a
::       _b - materiał
::  OLD: \odtw_sl/mag_fun.fml
::----------------------------------------------------------------------------------------------------------------------
_msk:=ND.name()+3;
_mag:='';
_mat:='';
SC.cntx_psh();
DK.cntx_psh();
ND.cntx_psh();
SL.cntx_psh();
SLD.cntx_psh();
DK_L.cntx_psh();

:: brak przekazanych parametrów
{? _=0
|| {? cur_tab()=DK
   || _a:=DK.N().MAG;
      _b:=DK.M;
      _mag:=DK.N().MAG().SYM;
      _mat:=DK.M().KTM
   |? cur_tab()=SC
   || _a:=SC.MAG;
      _b:=SC.M;
      _mag:=SC.MAG().SYM;
      _mat:=SC.M().KTM
   |? cur_tab()=SM
   || _a:=SM.MAG;
      _b:=SM.M;
      _mag:=SM.MAG().SYM;
      _mat:=SM.M().KTM
   |? cur_tab()=SL
   || _a:=SL.MG;
      _b:=SL.M;
      _mag:=SL.MG().SYM;
      _mat:=SL.M().KTM
   |? cur_tab()=SLD
   || _a:=SLD.SL().MG;
      _b:=SLD.SL().M;
      _mag:=SLD.SL().MG().SYM;
      _mat:=SLD.SL().M().KTM

   || FUN.error('Nie można ustalić domyślnych parametrów w tym miejscu systemu');
      return(0)
   ?};
   {? ~FUN.ask('Czy odtworzyć stany wymiarów %1 w magazynie %2'[_mat,_mag])
   || return(0)
   ?}
|| {? var_pres('_a')<>type_of(MG.ref())
   || return(0)
   || _mag:=exec('FindAndGet','#table',MG,_a,,"MG.SYM",'');
      {?_mag=''
      || FUN.error('Błędny parametr MAGAZYN');
         return(0)
      ?}
   ?};
   {?_>1
   || {? var_pres('_b')<>type_of(M.ref())
      || FUN.error('Błędny parametr MATERIAŁ');
         return(0)
      || _mat:=exec('FindAndGet','#table',M,_b,,"M.KTM",'')
      ?}
   || _mat:=''
   ?}
?};


:: ustalenie czy aktualizacja stanów dla jednego czy wielu indeksów
{? _mat='' || _all:=1 || _all:=0 ?};

:: usuniecie danych w SL-u na danym magazynie
SL.index('MG');
{? _all
|| SL.prefix(_a)
|| SL.prefix(_a,_b)
?};
{? SL.first()
|| {!
   |? SLD.index('SL');
      SLD.prefix(SL.ref());
      {? SLD.first() || {! |? SLD.del() !} ?};
      SL.del()
   !}
?};

_maski:=tab_tmp(1,'NAME','STRING[3]','');

OKR.cntx_psh();
OKR.index('MC');
OKR.prefix(REF.FIRMA,1);
{? OKR.first
|| {!
   |? _maski.blank();
      _maski.NAME:=(1+_msk)+($OKR.ROK+2);
      _maski.add(1);
      OKR.next()
   !}
?};
OKR.cntx_pop();

_maski.clear();
{? _maski.first()
|| {!
   |?
      exec('mag_open','open_tab',1+(_maski.NAME+3),_maski.NAME+2);
::    dogenerowanie danych do DK_L dla wszystkich zaakceptowanych dokumentow
      echo('Odtwarzanie wymiarów rok: '@+'20'+(_maski.NAME+2));

::    ustalanie danych do progressu
      DK_LN.index('MG');
      DK_LN.prefix(_a);
      ND.index('NAGDT');
      ND.prefix(_a,'T');
      _mi:=DK_LN.size()+ND.size; _tp:=time(); _li:=0;
      ND.first();
      ND.clear();
      {? _all
      || DK.index('DOKSAM');
         DK.prefix('T',_a)
      || DK.index('DK_SM');
         DK.prefix(_a,_b,'T')
      ?};
      {? DK.first()
      || _czypal:=ND.MAG().PAL='T';
::         {!
::         |?
::          aktualizacja tabeli SL
            _li+=1;
            progress(_li/_mi*100,'Rok: 20%1\nProszę czekać.'@[(_maski.NAME+2)],'Odtwarzanie wymiarów'@);
::            DK.index('DOKMAG');
::            DK.prefix(ND.ref());
::            {? DK.first() & ~( ND.TYP().DK='T' & ND.TYP().Z='T')
::            ||
               {!
               |?
                 {? ~( DK.N().TYP().DK='T' & DK.N().TYP().Z='T')
                 ||  DK_L.index('DK');
                     DK_L.prefix(DK.ref);
                     _warunek:={? DK.N().TYP().P='T' & ~DK_L.first()
                               || 1
                               |? DK.N().TYP().P='N' & DK.ZP=0 & ~DK_L.first()
                               || 1
                               || 0
                               ?};
                     _il_dk:={? DK.N().TYP().P='T'
                             || DK.IL
                             || _w:=DK.IL; _nd:=DK.N; _zpo:=#DK.ref;
                                DK.cntx_psh();
                                DK.index('DOKZP');
                                DK.prefix(_nd,_zpo);
                                {? DK.first() || {!|? _w+=DK.IL; DK.next !} ?};
                                DK.cntx_pop();
                                _w
                             ?};
                     {? _warunek & DK.M().RODZ='T' || exec('rebuild_dle','magazyn_stan',DK.ref,_il_dk) ?};
                     DK_L.prefix();
                     exec('dk_l2sl','magazyn_stan',DK.ref(),,1,,_czypal)
                 ?};
                 DK.next()
               !}
::            ?};
::            ND.next()
::         !}
      ?};

::    tabela SL na podstawie reorganizacji
      DK_LN.index('MG');
      DK_LN.prefix(_a);
      {? DK_LN.first()
      || {!
         |?
            _li+=1;
            progress(_li/_mi*100,'Rok: 20%1\nProszę czekać.'@[(_maski.NAME+2)],'Odtwarzanie wymiarów'@);
            {? DK_LN.AKC='T'
            || DK_L.index('DK_LN');
               DK_L.prefix('Z',DK_LN.ref());
               {? _all
               || DK_L.prefix('Z',DK_LN.ref())
               || DK_L.prefix('Z',DK_LN.ref(),_b)
               ?};
               {? DK_L.first()
               || {!
                  |? exec('adddelsl','magazyn_stan'
                          ,DK_L.MG,DK_L.M,DK_L.LOK,DK_L.TW,DK_L.IL,1,DK_L.PAL,DK_L.SCEAN,DK_L.IL2);
                     exec('adddelsl','magazyn_stan'
                          ,DK_L.MG,DK_L.M,DK_L.LOKDO,DK_L.TWDO,DK_L.IL,-1
                          ,{? DK_L.PALDO().STAN='I' || null() || DK_L.PALDO ?},DK_L.SCEAN,DK_L.IL2);
                     DK_L.next()
                  !}
               ?}
            ?};
            DK_LN.next()
         !}
      ?};
      _maski.next()
   !}
?};
exec('mag_open','open_tab',1+(_msk+3),_msk+2);

SC.cntx_pop();
DK.cntx_pop();
ND.cntx_pop();
SL.cntx_pop();
SLD.cntx_pop();
DK_L.cntx_pop();


echo();prgs_clr();
''


\przelic_TEMP
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS:  Przelicza ilośći do ilości wykonaniej na zleceniu - funkcja do uruchomienia na pozycjach dokumentu RWZL
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
::_ilosc:=DK.size();
::{? FUN.ask('Czy przliczyć dokument zgodnie z ilościami wykonanymi na zleceniu (ilość pozycji %1)'[$_ilosc])
::|| DK.first();
::   {!
::   |? _ilosc_planowana:=exec('FindAndGet','#table',ZL,DK.ZL,,"ZL.IL",0);
::      _ilosc_wykonana:=exec('FindAndGet','#table',ZL,DK.ZL,,"ZL.ILDOK",0);
::      {? _ilosc_planowana<>_ilosc_wykonana & _ilosc_planowana<>0 & _ilosc_wykonana<>0
::      || _przelicznik:=_ilosc_wykonana/_ilosc_planowana;
::         _ilosc_limitu:=exec('FindAndGet','#table',ZLIM,DK.ZLIM,,"ZLIM.LIL";0)
::         {? _ilosc_limitu>0
::         || _ilosc_przeliczona:=(_ilosc_limitu*_przelicznik)$DK.M().DOKL;
::            {? _ilosc_przeliczona<DK.IL
::            || DK.IL:=_ilosc_przeliczona;
::               DK.put();
::               params_exec('po_il','magdok_poz',,0,0,,'VALID');
::            |? _ilosc_przeliczona>DK.IL
::            || _ilosc_dostawy:=
::   ?};
1


\dk_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: O.R. [1241_junior]
:: OPIS: import dokumentow magazynowych WZ
::   WE: _a - nazwa pliku z pozycjami
::   WY: -
::----------------------------------------------------------------------------------------------------------------------
{? ND.Z='T' || FUN.info('Dokument zaakceptowany.'); return(0) ?};

:: O.R. 15.02.2016 otwarcie możlwości importu pozycji dla pozostałych
::{? ~(ND.TYP().T=exec('ekocer_ndtyp','a_or') | ND.TYP().T=exec('ekocer_2ndtyp','a_or') | ND.TYP().T='BO')
::|| FUN.info('Funkcja dotyczy jedynie dokumentów WZ_KOM i PZ_KOM (PZ_KOM bez ceny magazynowej).');
::   return(0)
::?};

:: czy przyjecie
_przy:=ND.TYP().P='T';

:: czy rozchodowy zewnętrzny
_roz_zew:=ND.TYP().P='N' & ND.TYP().Z='T';

_nd:=ND.ref();

VAR_DEL.delete('__p','__brak','__ile','IMPORT');
_plik:=_wyn:='';
_lp:=0;

__p:=tab_tmp(1
             ,'KTM'  ,'STRING[30]'  ,'KTM'
             ,'IL'   ,'REAL'        ,'ILOŚĆ DO UJAWNIENIA'
             ,'CENA'   ,'REAL'        ,'CENA'
             ,'SCEAN'  ,'STRING[30]'  ,'SCEAN'
             ,'DK_C'  ,'STRING[16]'  ,'DK_C'
             ,'TW'  ,'DATE'  ,'TERMIN WAŻNOŚCI'
             ,'DOST'  ,'DATE'  ,'DOSTAWA'
            );
__brak:=tab_tmp(1
                ,'KTM'  ,'STRING[30]'  ,'EAN'
                ,'OPI'  ,'STRING[240]' ,'OPIS BŁĘDU');

_win:=__brak.mk_sel('Pozycje niezaimportowane','P',1);
__brak.win_sel(_win);

DK.prefix();
DK.prefix(_nd);

_odp:={? DK.first()
      || {? FUN.ask('Dokument posiada pozycje.\nCzy usunąć i rozpocząć import?')
         || {!
            |?
               _delr:=DK.del(,1);
               {? _delr=1 || 0 |? _delr=0 || 0 || 1 ?}
            !}
         ?}
      || FUN.ask('Czy rozpocząć import?')
      ?};
exec('myDIALOG','object');
{? _odp
|| _plik:=myDIALOG.OpenFile('Plik importu (*.csv)|*.csv|Wszystkie pliki (*.*)|*.*','','')
?};

{? _plik<>''
||
   __ile:=0;
   IMPORT:=obj_new(@.CLASS.IMPORT);
   _file:=IMPORT.open('@'+_plik, ';', 0);
   {? _file
   ||
      {! |?
         _jest:=IMPORT.get();
         _ktm:=(STR.gsub(IMPORT.fld(1),' ',''));
         _tw:=(STR.gsub(IMPORT.fld(2),'.',''));
         {? _ktm=''
         || _jest:=0
         |? _jest
         ||
            __p.KTM:=_ktm;
            __p.TW:=date(#(_tw+4),#((_tw-4)+2),#(2+_tw));
            __p.IL:=#(STR.gsub(STR.gsub(IMPORT.fld(3),',','.'),' ',''));
            __p.SCEAN:=(STR.gsub(IMPORT.fld(4),' ',''));
            {? __p.add()
            || __ile+=1
            ?}
         ?};
         _jest<>0
      !}
   ?};
   obj_del(IMPORT);
::   msg('Zaimportowano '+$__ile+' pozycji');
   _ile_wcz:=__ile;
   __ile:=0;
   {? __p.first()
   || {!
      |? {? __p.TW=date(0,0,0)
         || __p.TW:=sql('select max(SC.TW) as TW from @SC join M where M.KTM=\':_a\' and SC.SCEAN=\':_b\''
                    , __p.KTM, __p.SCEAN).TW
         ?};
         _sc:=sql('select SC.D as DOST, SC.DK_C as DK_C, SC.C as CENA from @SC join M join MG
                    where M.KTM=\':_a\' and SC.SCEAN=\':_b\' and MG.SYM not like \'%PLA%\'
                 order by DOST, CENA'
                    , __p.KTM, __p.SCEAN);
::                    Dodatkowe zabezpieczeni
::                    and SC.PRDK=SC.SRDK'
         {? _sc.last()
         || __p.DK_C:=_sc.DK_C;
            __p.DOST:=_sc.DOST;
            __p.CENA:=_sc.CENA
         ?};
         __p.put();
         &_sc;
         __p.next()
      !}
   ?};
   q_sel(__p);



   __p.prefix();
   {? __p.first() & FUN.ask('Czy rozpocząć import?')
   || {!
      |?
         _m:=exec('FindInSet','#table','M','MATKTM',__p.KTM,__p.KTM,,1,,null());
         _ref_dkc:=exec('FindAndGet','#table',DK_C,__p.DK_C,,,null());
         {? _m<>null() & __p.IL>0 & _ref_dkc<>null
         || _ref:=exec('adddk','magdok_poz',ND.ref(),_m,__p.IL,__p.CENA,__p.DOST,,,,
               ,,,,0,,,_ref_dkc,,,,,,,,,__p.SCEAN,__p.TW)
         |? _ref_dkc=null();0
         || FUN.error('Nie odnaleziono cech %1 dla indekus %2'[__p.DK_C,__p.KTM]);
            _ref:=exec('adddk','magdok_poz',ND.ref(),_m,__p.IL,__p.CENA,__p.DOST,,,,
               ,,,,0,,,_ref_dkc,,,,,,,,,__p.SCEAN,__p.TW)
         ?};
         __p.next()
      !}
   || _wyn:='Brak pozycji do importu.'
   ?};
   __p.ndx_drop();
   VAR_DEL.delete(__p);
   {? _wyn<>'' || FUN.emsg(_wyn) ?}
?};
1


\napraw_rwz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Funkcja naprawia RWZ - zaokrąglenie dla magazynów wydziałowych - 2 miejsca poprzecinku
::   WE: Praca na masce ND i DK aktualnej.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
ND.cntx_psh();
DK.cntx_psh();
ND.index('CONTROL');
DK.index('DOKMAG');
DK.clear();
DK.first();
ND.clear();
ND.first();
{!
|? {? ND.TYP().T='RWZ' & ND.MAG().W='T' & ND.AR=2021 & ND.AM>=8
   || DK.prefix();
      DK.prefix(ND.ref());
      _suma:=0;
      {? DK.first()
      || {!
         |? DK.WAR:=DK.WAR$2;
            _suma+=DK.WAR$2;
            DK.put();
            DK.next()
         !};
         {? ND.WAR<>_suma & _suma<>0
         || ND.WAR:=_suma;
            ND.put()
         ?}
      ?}
   ?};
   echo('Dokument: '+ND.SYM);
   ND.next()
!};
ND.cntx_pop();
DK.cntx_pop();
1


\zaznacz_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS:  Zaznacza zlecenie dla których operacjezostały zaplanowane na datę wcześniejszą niż podana w parametrze
::       _a-data, oraz _b-wydział
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_a:=date(2021,10,01);
_b:='MSU';

{? ZL.first()
|| {!
   |?
      {? ZL.JORG().KOD=_b
      || {? sql('select ZGH.NRPRZ from @ZGH where ZGH.ZLEC=:_a and ZGH.ENDD<to_date(:_b)',ZL.ref(),_a).first()
         || sel_add()
         ?}
      ?};
      ZL.next()
   !}
?};
1


\import_cnm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PeKa
:: OPIS: Import kodow celnych
::----------------------------------------------------------------------------------------------------------------------

{? FUN.ask('Czy zaimportować dane z pliku?')
|| exec('myDIALOG','object');
   _file:=myDIALOG.OpenFile('','');
   _ile:=0;
   {? var_pres('IMPORT')>0 || obj_del(IMPORT) ?};
   IMPORT:=obj_new(@.CLASS.IMPORT,30);
   {? _file<>''
   || _plik:=IMPORT.open('@'+_file,';',0,1,1,'Trwa import...');
      {? _plik
      ||
         {!
         |?
            _jest:=IMPORT.get();
            {? _jest
            ||
               CNM.blank();
               CNM.M:={? IMPORT.fld(1)<>'' || exec('FindInSet','#table','M','MATKTM',IMPORT.fld(1),IMPORT.fld(1)) || null ?};
               CNM.CN:={? IMPORT.fld(4)<>'' || exec('FindInSet','#table','CN','KOD',IMPORT.fld(4),IMPORT.fld(4)) || null ?};
               CNM.DATA_OD:=date(2021,10,1);
               {? CNM.CN<>null & CNM.M<>null & CNM.add(1)
               ||
                  _ile+=1
               ?}
            ?};
            _jest<>0
         !}
      ?}
   ?};
   obj_del(IMPORT)
?};
FUN.info('Zaimportowano '+$_ile+' kodów celnych')


\popraw_dokl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PeKa [20.42]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? M.sel_size()=0
||
   M.cntx_psh();
   _sEdt:=M.mk_edit('',,'#m_swin');
   M.win_edit(_sEdt);
   M.win_efld(_sEdt,,'DOKL',,,5,,,'Dokładność ilości',,'Dokładność ilości',,);
   M.win_efld(_sEdt,,'DOKL_C',,,5,,,'Dokładność ceny magazynowej',,'Dokładność ceny magazynowej',,);
   M.win_efld(_sEdt,,'DOKL_S',,,5,,,'Dokładność ceny sprzedaży',,'Dokładność ceny sprzedaży',,);
   M.win_efld(_sEdt,,'DOKL_Z',,,5,,,'Dokładność ceny zakupu',,'Dokładność ceny zakupu',,);
   M.hdr_edit('Poprawianie dokładności dla pozycji'@);
   M.edit()
?};
~~


\poprawg_dokl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PeKa [20.42]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_tab:=M.sel_aget();
{? _tab.size() || BEER.blank() ?};
_sEdt:=M.mk_edit('',,'#m_swin');
M.win_edit(_sEdt);
M.win_efld(_sEdt,BEER,'Z',,,5,,,'Do zmiany',,'Dokładność ilości','check-box','left_label=1',"'T'","'N'");
M.win_efld(_sEdt,BEER,'TYP',,,5,,,'Do zmiany',,'Dokładność ceny magazynowej','check-box','left_label=1',"'T'","'N'");
M.win_efld(_sEdt,BEER,'ALL',,,5,,,'Do zmiany',,'Dokładność ceny sprzedaży','check-box','left_label=1',"'T'","'N'");
M.win_efld(_sEdt,BEER,'LW',,,5,,,'Do zmiany',,'Dokładność ceny zakupu','check-box','left_label=1',"'T'","'N'");
M.win_ecol(_sEdt);
M.win_efld(_sEdt,BEER,'DEMO',,,5,,,'Dokładność ilości',,'Dokładność ilości',,);
M.win_efld(_sEdt,BEER,'DISP',,,5,,,'Dokładność ceny magazynowej',,'Dokładność ceny magazynowej',,);
M.win_efld(_sEdt,BEER,'DOL',,,5,,,'Dokładność ceny sprzedaży',,'Dokładność ceny sprzedaży',,);
M.win_efld(_sEdt,BEER,'DOST',,,5,,,'Dokładność ceny zakupu',,'Dokładność ceny zakupu',,);
M.hdr_edit('Grupowe poprawianie dokładności'@);
BEER.fld_fml('DEMO','BEFORE_EDIT',"{? BEER.Z='T' || 1 || 0 ?}");
BEER.fld_fml('DISP','BEFORE_EDIT',"{? BEER.TYP='T' || 1 || 0 ?}");
BEER.fld_fml('DOL','BEFORE_EDIT',"{? BEER.ALL='T' || 1 || 0 ?}");
BEER.fld_fml('DOST','BEFORE_EDIT',"{? BEER.LW='T' || 1 || 0 ?}");
_edit:=M.edit();

{? _edit & (BEER.Z='T' | BEER.TYP='T' | BEER.ALL='T' | BEER.LW='T') & _tab.first
|| {!
   |? {? M.seek(_tab.REF,)
      || {? BEER.Z='T' || M.DOKL:=BEER.DEMO ?};
         {? BEER.TYP='T' || M.DOKL_C:=BEER.DISP ?};
         {? BEER.ALL='T' || M.DOKL_S:=BEER.DOL ?};
         {? BEER.LW='T' || M.DOKL_Z:=BEER.DOST ?};
         M.put();
         sel_nchk()
      ?};
      _tab.next()
   !}
?};
~~


\zmiana_dokladnosci
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PeKa [20.42]
:: OPIS: Funkcja do zmiana dokladnosci dla indeskow
::----------------------------------------------------------------------------------------------------------------------
M.cntx_psh();
:: budowa okienk tymczasowych
_sWin:=M.mk_sel('','P',,'#m_swin',,,,,'U','T');
M.win_sel(_sWin);
M.win_fld(_sWin,,'MGR'     ,'KOD'     ,          , 30,  ,1 ,'Grupa materiałowa',,'Grupa materiałowa',,1);
M.win_fld(_sWin,,'KTM'     ,          ,          , 50,  ,1 ,'Indeks',,'Indeks materiałowy',,1);
M.win_fld(_sWin,,'N'       ,          ,          ,50,  ,1 ,'Nazwa',,'Nazwa indeksu materiałowego',,1);
M.win_fld(_sWin,,'DOKL'    ,          ,          ,  4,  , ,'Dokładność ilości',,'Dokładność ilości',,1);
M.win_fld(_sWin,,'DOKL_C'  ,          ,          ,  4,  , ,'Dokładność ceny magazynowej',,'Dokładność ceny magazynowej',,1);
M.win_fld(_sWin,,'DOKL_S'  ,          ,          ,  4,  , ,'Dokładność ceny sprzedaży',,'Dokładność ceny sprzedaży',,1);
M.win_fld(_sWin,,'DOKL_Z'  ,          ,          ,  4,  , ,'Dokładność ceny zakupu',,'Dokładność ceny zakupu',,1);
M.win_act(_sWin, ,'Formuła','Popraw',,,"exec('popraw_dokl','qtechniczny')",,1,1,"exec('poprawg_dokl','qtechniczny')");
M.win_act(_sWin, ,'Kolejność' );
M.win_act(_sWin, ,'Szukaj');
M.select();
M.cntx_pop();
~~


\aktualizacja_m
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PeKa [21.37]
:: OPIS: Aktualizacja kartoteki materialowej
::----------------------------------------------------------------------------------------------------------------------
_odp:=FUN.ask('Czy rozpocząć import?');
{? _odp
|| exec('myDIALOG','object');
   _plik:=myDIALOG.OpenFile('Plik importu (*.csv)|*.csv|Wszystkie pliki (*.*)|*.*','','')
?};

{? _plik<>''
||
   IMPORT:=obj_new(@.CLASS.IMPORT);
   _file:=IMPORT.open('@'+_plik, ';', 0);
   {? _file
   || M.index('MATKTM');
      {!
      |?
         _jest:=IMPORT.get();
         {? _jest
         || M.cntx_psh();
            M.prefix(IMPORT.fld(1),);
            {? M.first()
            || {? IMPORT.fld(2)<>''
               || M.GRP5:=exec('FindInSet','#table','QGRP5','GRP5',IMPORT.fld(2),,,1,,null());
                  M.put()
               ?}
            ?};
            M.cntx_pop()
         ?};
         _jest<>0
      !}
   ?};
   obj_del(IMPORT)
?};
1


\import_zalacznikow
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PeKa [21.37]
:: OPIS: Importuje zalczniki pdf z katalogow na serwerze do tabeli zalcznikow materialow
::----------------------------------------------------------------------------------------------------------------------
:: tabelka, ktora zostanie napelniona sciezkami do plikow do dalszej obrobki
VAR_DEL.delete('__import');
__import:=tab_tmp(1
::      REF
       ,'REFM' ,'STRING[16]','Ref materiału'
::      Indeks materiałowy
       ,'KTM'     ,'STRING[50]' ,'Indeks'
::      Nazwa indeksu materiałowego
       ,'N'       ,'STRING[100]','Nazwa'
::      Nie wykorzystywane
       ,'PATH'   ,'STRING[255]','Sciezka do pliku'
::      DATA
       ,'DATA' ,'DATE','Data pliku'
::      UWAGI
       ,'UWAGI' ,'STRING[255]','Uwagi'
::      JEZYK
       ,'JEZYK' ,'STRING[2]','Wersja jezykowa'
::      Nazwa pliku
       ,'NAZWA' ,'STRING[255]','Nazwa pliku'
       );
:: buduje tabele materialow z grupy 07 do wyszukiwania nazwa katalogow zgodnych z nazwa indeksu
_mat:=sql('select M.REFERENCE as MREF, M.KTM, M.N, M.OPIST from M join MGR where M.A=\'T\' and  MGR.KOD like \'07-%\'');

{? _mat.first
|| {!
   |?
      _katalog:='/data/temp/IMPORT/SUROWCE/'+_mat.N;
      {? fexists(_katalog,0)
      || _DIR:=fdir(_katalog,1,0);
         {? _DIR.first()
         ||
:: wariant kiedy istnieje plik MSDS, ale bez opisu wersji jezykowej
            _pdf:=sql('select * from :_a
                           where UPPER(NAME) like \'MSDS%\'
                                 and (UPPER(NAME) not like \'MSDS%$_PL$_%\' ESCAPE \'$\' and UPPER(NAME) not like \'MSDS%$_EN$_%\' ESCAPE \'$\')
                                 and TYPE=\'f\'
                           order by NAME,MOD_DATE'
                     ,_DIR);
            {? _pdf.last()
            || _uwagi:='Plik został zaimportowany, jednak nie rozpoznano w nazwie wersji językowej';
               exec('log_importu','qtechniczny',_mat.KTM,_mat.N,_mat.MREF,_pdf.DIR+'/'+_pdf.NAME,_pdf.MOD_DATE,_uwagi,'',_pdf.NAME)
            ?};
            &_pdf;
:: odszukanie wersji jezykowej EN wedlug ostatniej daty pliku
            _pdf:=sql('select * from :_a where UPPER(NAME) like \'MSDS$_%$_EN$_%\' ESCAPE \'$\' and TYPE=\'f\' order by NAME,MOD_DATE',_DIR);
            {? _pdf.last()
            || exec('log_importu','qtechniczny',_mat.KTM,_mat.N,_mat.MREF,_pdf.DIR+'/'+_pdf.NAME,_pdf.MOD_DATE,'','EN',_pdf.NAME)
            || _uwagi:='Odnaleziono katalog z nazwą indeksu, jednak nie zawiera plików MSDS do importu w wersji jezykowej EN';
               exec('log_importu','qtechniczny',_mat.KTM,_mat.N,_mat.MREF,'',date(0,0,0),_uwagi,'','')
            ?};
            &_pdf;
:: odszukanie wersji jezykowej PL wedlug ostatniej daty pliku
            _pdf:=sql('select * from :_a where UPPER(NAME) like \'MSDS$_%$_PL$_%\' ESCAPE \'$\' and TYPE=\'f\' order by NAME,MOD_DATE',_DIR);
            {? _pdf.last()
            || exec('log_importu','qtechniczny',_mat.KTM,_mat.N,_mat.MREF,_pdf.DIR+'/'+_pdf.NAME,_pdf.MOD_DATE,'','PL',_pdf.NAME)
            || _uwagi:='Odnaleziono katalog z nazwą indeksu, jednak nie zawiera plików MSDS do importu w wersji jezykowej PL';
               exec('log_importu','qtechniczny',_mat.KTM,_mat.N,_mat.MREF,'',date(0,0,0),_uwagi,'','')
            ?};
            &_pdf
         || _uwagi:='Odnaleziono katalog z nazwą indeksu, jednak ścieżka do pliku jest zbyt długa. Pliki należy dodać ręcznie';
            exec('log_importu','qtechniczny',_mat.KTM,_mat.N,_mat.MREF,'',date(0,0,0),_uwagi,'','')
         ?};
         &_DIR
      || _uwagi:='Nie dopasowano nazwy katalogu do nazwy indeksu materialowego';
         exec('log_importu','qtechniczny',_mat.KTM,_mat.N,_mat.MREF,'',date(0,0,0),_uwagi,'','')
      ?};
      _mat.next()
   !}
?};
__import


\log_importu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PeKa [21.37]
:: OPIS: Napelniam tabele logow importu (nie są kontrolowane przekazywane paretry - podane w wywolaniu)
::   WE: _a - ktm
::       _b - nazwa
::       _c - ref materialu
::       _d - sciezka pliku lub opis
::       _e - data pliku lub pusta
::       _f - uwagi do importu
::       _g - wersja jezykowa
::       _h - nazwa pliku
::   WY:
::----------------------------------------------------------------------------------------------------------------------
__import.blank();
__import.KTM:=_a;
__import.N:=_b;
__import.REFM:=_c;
__import.PATH:=_d;
__import.DATA:=_e;
__import.UWAGI:=_f;
__import.JEZYK:=_g;
__import.NAZWA:=_h;
__import.add()


\import_dokum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PeKa [21.37]
:: OPIS: Tworzenie zapisow DOKUM z podpieciem zalacznika pod odszukany indeks
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('import_zalacznikow','qtechniczny');
{? __import.first
|| {? __import.NAZWA<>''
   || _plik:=fopen(__import.PATH,'br',0,1,1);
      DOKUM.cntx_psh();
      DOKUM.clear();
      DOKUM.blank();
      exec('znak','numery','DOKUM');
      DOKUM.REFSQL:=__import.REFM;
      DOKUM.NAZWA:=__import.NAZWA;
      {? __import.JEZYK<>''
      || _jezyk:={? __import.JEZYK='EN' || 'ANG' || 'POL' ?};
         _slu:=exec('FindInSet','#table','SLU','NAZ','Języki obce',,,1);
         DOKUM.JEZYK:=exec('FindInSet','#table','SLO','SL',_jezyk,_slu,,1)
      ?};
      DOKUM.add();
      DOKUM.bl_put('DOKUM',_plik,,,__import.NAZWA);
      DOKUM.cntx_pop()
   ?}
?}


\popraw_etapy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Funkcja generuje powiązania pomiędzy operacjami w karcie technologicznej (dla wszystkich kart)
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

{? FUN.ask('Czy odtworzyć powiązania operacji dla wszystkich technologii ?')
|| TKTL.cntx_psh();
   TKTL.use('txktl___');
   TKTL.index('NRK');
   TKTL.prefix();
   TKTL.first();
   {!
   |? {? TKTL.STAN='T'
      || exec('er_tab','tech_oper',TKTL.ref());
         exec('gen_pow','tech_oper',TKTL.ref())
      ?};
      TKTL.next()
   !};
   TKTL.cntx_pop()
?};
~~


\popraw_default
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Funkcja ustawia kartę jako domyślną jeśli brak karty domyślnej  i jest tylko jedna, lub jest ostatnia dodana.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

{? FUN.ask('Czy ustawić domyślność dla kart technologicznych ?')
|| TKTL.cntx_psh();
   TKTL.use('txktl___');
   TKTL.index('NRK');
   TKTL.prefix();
   TKTL.first();
   {!
   |? {? TKTL.DEFAULT='N' & ~(sql('select TKTLW.DEFAULT from TKTLW where TKTLW.KTM=:_a and TKTLW.DEFAULT=\'T\'', TKTL.KTM).first())
      || _tktl:=sql('select TKTL.IDADD,
                            TKTL.REFERENCE as REF
                       from TKTL
                      where TKTL.TORW=\'T\' and TKTL.KTM=:_a and TKTL.STAN=\'T\'
                   order by 1', TKTL.KTM);
         _ktm:=TKTL.KTM;
         {? _tktl.last()
         || TKTLW.cntx_psh();
            TKTLW.index('PT');
            TKTLW.prefix(_ktm);
            {? TKTLW.first()
            || {!
               |? {? TKTL.IDADD=_tktl.IDADD
                  || TKTLW.DEFAULT:='T'
                  || TKTLW.DEFAULT:='N'
                  ?};
                  TKTLW.put();
                  TKTLW.next()
               !}
            ?};
            TKTL.cntx_psh();
            TKTL.clear();
            TKTL.index('KSN');
            TKTLW.index('REF');
            TKTL.prefix('T',_ktm,'T');
            {? TKTL.first()
            || {!
               |? TKTLW.prefix(TKTL.ref());
                  _t:=0; _n:=0;
                  {? TKTLW.first()
                  || {!
                     |? {? TKTLW.DEFAULT='T'
                        || _t+=1
                        || _n+=1
                        ?};
                        TKTLW.next()
                     !}
                  ?};
                  {? _t>0 & _n=0
                  || TKTL.DEFAULT:='T'
                  |? _t=0 & _n>0
                  || TKTL.DEFAULT:='N'
                  || TKTL.DEFAULT:='P'
                  ?};
                  TKTL.put();
                  TKTL.next()
               !}
            ?};
            TKTL.cntx_pop();
            TKTLW.cntx_pop()
         ?};
         &_tktl
      ?};
      echo('Karta: '+TKTL.NRK);
      TKTL.next()
   !};
   TKTL.cntx_pop()
?};

echo();
~~


\popraw_gniazda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Zmiana gniazda mono i wielo na G-13PPA z uwzględnieniem stanowiska domyślnego
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
TOPER.use('txope___');
TOPER.prefix();
TOPER.f_clear();
TOPER.index('DOK');
TOPER.first();

:: Pozycje gniazda
TWRKZPO.index('GRUPA');
TWRKZPO.prefix();
:: Gnizdo do zamiany
TWRKZBR.index('SYM');
TWRKZBR.prefix('G-13PPA');
{? TWRKZBR.first()
|| _gniazdo:=TWRKZBR.ref();
   {!
   |? {? TOPER.GRUPA().SYMBOL='WIELO' | TOPER.GRUPA().SYMBOL='MONO' | TOPER.GRUPA().SYMBOL='ECO'
      || _st:=TOPER.TWRKPLG().ELEMENT;
         _st_do:=null();
         {? _st<>null()
         || TWRKZPO.prefix(_gniazdo,_st);
            {? TWRKZPO.first()
            || _st_do:=TWRKZPO.ref()
            ?}
         ?};
         {? _st_do<>null()
         || TOPER.GRUPA:=_gniazdo;
            TOPER.TWRKPLG:=_st_do;
            TOPER.put()
         ?}
      ?};
      echo('Operacja - '+TOPER.IDADD);
      TOPER.next()
   !}
|| FUN.error('Nie odnaleziono gniazda G-13PPA'); return(0)
?}


\dodaj_gniazda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Zmienia przydział operacji do stanowiska jeśli możliwe jest przypisanie do gniazda
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
TOPER.use('txope___');
TOPER.prefix();
TOPER.f_clear();
TOPER.index('DOK');
TOPER.first();

:: Pozycje gniazda
TWRKZPO.index('S1');
TWRKZPO.prefix();

{!
|? {? TOPER.GRPOJ='S' & TOPER.PLACE<>null()
   || TWRKZPO.prefix(TOPER.PLACE);
      {? TWRKZPO.first() & 1+TWRKZPO.GRUPA().SYMBOL<>'X'
      || TOPER.GRPOJ:='G';
         TOPER.GRUPA:=TWRKZPO.GRUPA;
         TOPER.TWRKPLG:=TWRKZPO.ref();
         TOPER.PLACE:=null();
         TOPER.put()
      ?};
      TWRKZPO.prefix()
   ?};
   echo('Operacja - '+TOPER.IDADD);
   TOPER.next()
!}


\ask4date --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [Home]
:: OPIS: Pyta o podanie daty
::   WE:  _a  [STRING] - Nazwa pola
::       [_b] [DATE] - domyślna wartość
::       [_c] [ANY] - wartość dla rezygnacji z edycji - domyślnie date(0,0,0)
::       [_d] [DATE] - minimalna data
::       [_e] [DATE] - maksymalna data
::       [_f] [FORMULA] - formuła kontroli dla podanej daty
::   WY: data lub _c gdy rezygnacja
::----------------------------------------------------------------------------------------------------------------------
:: EXEC: exec('ask4date','q#fun')
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(1,'DT','DATE',{? var_pres('_a')=2 || _a || '' ?});
_tab.DT:={? var_pres('_b')=4 || _b || date(0,0,0) ?};
_tab.win_edit(_tab.mk_edit('|--|Proszę podać...',1));
_fDate:="{? 1=0 || ~~";

{? var_press('_d')=4 || _fDate+=" |? fld()<#"+form(#_d,,,'99')+" || FUN.emsg('Proszę podać datę większą od '+form(#"+form(#_d-1,,,'99')+")+'.') " ?};
{? var_press('_e')=4 || _fDate+=" |? fld()>#"+form(#_e,,,'99')+" || FUN.emsg('Proszę podać datę mniejszą od '+form(#"+form(#_e+1,,,'99')+")+'.') " ?};

{? var_press('_f')=3
 | var_press('_f')=2 || _fDate+=" |? "+_f+" || 0 "?};

_fDate+=" || 1 ?}";
_tab.fld_fml('DT','AFTER_EDIT',$_fDate);

{? _tab.edit()
|| _tab.DT
|| {? var_pres('_c')>0 || _c || date(0,0,0) ?}
?}


\uzup_st_norm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Uzupełnia znacznik stałej normy czasowej dla operacji w karcie technologicznej (dla suszenia w piecach)
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
TOPER.use('txope___');
TOPER.prefix();
TOPER.f_clear();
TOPER.index('DOK');
TOPER.first();
{!
|? {? TOPER.OPER().KOD='msuszeniep'
   || TOPER.FIX_NORM:='T';
      TOPER.put()
   ?};
   TOPER.next()
!};
1


\czy_zlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Import danych do tworzenia zleceń - analiza czy dodawać czy nie zlecenie
::   WE:
::   WY: tabela z pozycjami zamówień do uruchomienia
::----------------------------------------------------------------------------------------------------------------------
_odp:=FUN.ask('Czy rozpocząć import zamówień do utworzenia');
_tab:=sql('select USERS.APP_IDEN as ZAM, USERS.ZZZ as POZ, USERS.APP_IDEN as REF_POZ  from USERS where 1=0');
_plik:='';

{? _odp
|| exec('myDIALOG','object');
   _plik:=myDIALOG.OpenFile('Plik importu (*.csv)|*.csv|Wszystkie pliki (*.*)|*.*','','')
?};


{? _plik<>''
||
   IMPORT:=obj_new(@.CLASS.IMPORT);
   _file:=IMPORT.open('@'+_plik, ';', 0);
  {? _file
  ||{!
      |?
         _jest:=IMPORT.get();
         {? _jest
         || _tab.ZAM:=IMPORT.fld(1);
            _tab.POZ:=#IMPORT.fld(2);
            _tab.REF_POZ:=sql('select ZK_P.REFERENCE as REF from @ZK_P join @ZK_N where ZK_N.SYM=\':_a\' and ZK_P.POZ=:_b'
                              , IMPORT.fld(1), #IMPORT.fld(2)).REF;
            _tab.add()
         ?};
         _jest<>0
      !}
   ?};
   obj_del(IMPORT)
?};
:: wyświetlenie tabeli - jak trzeba będzie to może ręczna edycja
q_sel(_tab);

_tab

\usun_px_poz_opuznione
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Funkcja usówa z tabeli PX_POZ pozycje planu dla zleceń produkcyjnych o statusie zamknięte.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

PX_POZ.f_clear();
PX_POZ.index('VSTATUS');
PX_POZ.prefix();

{? PX_POZ.first()
|| {!
   |? _dalej:=0;
      PX_POZ.cntx_psh();
      {? PX_POZ.STATUS='OPÓŹNIONE' & PX_POZ.PX_OBJ().ZL<>null & PX_POZ.PX_OBJ().ZL().ST_Z='T'
      || _dalej:=exec('clean_from_plan','px_grp',PX_POZ.PX_GRP,1,1,1,0)
      ?};
      PX_POZ.cntx_pop();
      PX_POZ.next
   !}
?}


\popraw_startd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Funkcja naprawia daty na przewodnikach i pozycjach przewodnikó na podstawie danych z PL_OPER
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

tab_z:=sql('select ZGH.REFERENCE as ZGH_REF,
                   ZGH.NRPRZ,
                   ZGP.REFERENCE as ZGP_REF,
                   ZGP.STARTD as ZGP_STD,
                   PL_OPER.STARTD as PLO_STD,
                   ZGP.ENDD as ZGP_END,
                   PL_OPER.ENDD as PLO_END
             from ZGP join PL_OPER
                      join ZGH using (ZGP.NRPRZ, ZGH.REFERENCE)
            where ZGP.STARTD<>PL_OPER.STARTD');
{? tab_z.first()
|| {!
   |? exec('FindAndGet','#table',ZGH,tab_z.ZGH_REF,,
           "STARTD:=tab_z.PLO_STD;
            ENDD:=tab_z.PLO_END;
            ZGH.put()");
      exec('FindAndGet','#table',ZGP,tab_z.ZGP_REF,,
           "STARTD:=tab_z.PLO_STD;
            ENDD:=tab_z.PLO_END;
            ZGP.put();
            exec('zlim_dates_upd','zl_limit',ZGP.ref())");
      tab_z.next()
   !}
?};
1


\tmat_all_tktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Struktura TKTL
::   WE: _a - TKTL.ref
::       _b - poziom rekurencji
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_tktl:=_a;
_poziom:=_b;
TKTL.cntx_psh();

_tabela:=sql('select :_b as LP,
                     SPACE(20) as POZ,
                     M.KTM as M_KTM,
                     M.N as M_N,
                     TKTL.NRK as TL_NRK,
                     TKTL.WER,
                     TMAT.KTM,
                     TMAT.NRK as TM_NRK,
                     TKTL_M.KTM as TP_KTM,
                     TKTL_M.N as TP_N,
                     TMAT.DFLT_KTL,
                     TMAT.GRKTM,
                     TMAT.TGDFLT,
                     TMAT.PT,
                     TMAT.RKTL,
                     SPACE(20) as NRK_KTL,
                     SPACE(20) as WER_KTL
                from @TMAT join M using(TMAT.KTM,M.REFERENCE)
                           join TKTL using(TMAT.NRK, TKTL.REFERENCE)
                           join M as TKTL_M using(TKTL.KTM, TKTL_M.REFERENCE)
                where TMAT.NRK=:_a',TKTL.ref(),_poziom);

_result:=sql('select 0 as LP,
                     SPACE(20) as POZ,
                     M.KTM as M_KTM,
                     M.N as M_N,
                     TKTL.NRK as TL_NRK,
                     TKTL.WER,
                     TMAT.KTM,
                     TMAT.NRK as TM_NRK,
                     TKTL_M.KTM as TP_KTM,
                     TKTL_M.N as TP_N,
                     TMAT.DFLT_KTL,
                     TMAT.GRKTM,
                     TMAT.TGDFLT,
                     TMAT.PT,
                     TMAT.RKTL,
                     SPACE(20) as NRK_KTL,
                     SPACE(20) as WER_KTL
                from @TMAT join M using(TMAT.KTM,M.REFERENCE)
                           join TKTL using(TMAT.NRK, TKTL.REFERENCE)
                           join M as TKTL_M using(TKTL.KTM, TKTL_M.REFERENCE)
                where 1=0');
_n:=obj_new(6);
{! _i:=1..6
|! _n[_i]:=0
!};
_m:=obj_new(6);
{! _i:=1..6
|! _m[_i]:=0
!};
{? _tabela.first()
|| {!
   |? _mref:=exec('FindAndGet','#table',M,_tabela.KTM,,,null());
      _tktlref:=exec('getdefaulttech','tech_common',_mref,1);
      {? _tktlref<>null()
      || _tab_r:=exec('tmat_all_tktl','qtechniczny', _tktlref, _poziom+1);
         {? _tab_r.first()
         || {!
            |?
            _result.LP:=_tab_r.LP;
            _result.POZ:=exec('tree_level','qtechniczny',_m,_n,_result.LP);
            _result.KTM:=_tab_r.KTM;
            _result.M_KTM:=_tab_r.M_KTM;
            _result.M_N:=_tab_r.M_N;
            _result.TP_KTM:=_tab_r.TP_KTM;
            _result.TP_N:=_tab_r.TP_N;
            _result.TM_NRK:=_tab_r.TM_NRK;
            _result.TL_NRK:=_tab_r.TL_NRK;
            _result.WER:=_tab_r.WER;
            _result.DFLT_KTL:=_tab_r.DFLT_KTL;
            _result.GRKTM:=_tab_r.GRKTM;
            _result.TGDFLT:=_tab_r.TGDFLT;
            _result.PT:=_tab_r.PT;
            _result.RKTL:=_tab_r.RKTL;
            {? _result.DFLT_KTL='T'
            || _refm:=exec('FindAndGet','#table',M,_tab_r.PT,,"ref","null");
               _result.NRK_KTL:=$exec('dflt_ktl','tech_prod',{? _tab_r.GRKTM='G' || null || _refm ?})
            || _result.NRK_KTL:=$exec('FindAndGet','#table',TKTL,_tab_r.RKTL,,,null())
            ?};
            _result.add();
            _tab_r.next()
            !};
            _result.LP:=_tabela.LP;
            _result.POZ:=exec('tree_level','qtechniczny',_m,_n,_result.LP);
            _result.KTM:=_tabela.KTM;
            _result.M_KTM:=_tabela.M_KTM;
            _result.M_N:=_tabela.M_N;
            _result.TP_KTM:=_tabela.TP_KTM;
            _result.TP_N:=_tabela.TP_N;
            _result.TL_NRK:=_tabela.TL_NRK;
            _result.WER:=_tabela.WER;
            _result.TM_NRK:=_tabela.TM_NRK;
            _result.DFLT_KTL:=_tabela.DFLT_KTL;
            _result.GRKTM:=_tabela.GRKTM;
            _result.TGDFLT:=_tabela.TGDFLT;
            _result.PT:=_tabela.PT;
            _result.RKTL:=_tabela.RKTL;
            {? _result.DFLT_KTL='T'
            || _refm:=exec('FindAndGet','#table',M,_tabela.PT,,"ref","null");
               _result.NRK_KTL:=$exec('dflt_ktl','tech_prod',{? _tabela.GRKTM='G' || null || _refm ?})
            || _result.NRK_KTL:=$exec('FindAndGet','#table',TKTL,_tabela.RKTL,,,null())
            ?};
            _result.add()
         || _result.LP:=_tabela.LP;
            _result.KTM:=_tabela.KTM;
            _result.POZ:=exec('tree_level','qtechniczny',_m,_n,_result.LP);
            _result.M_KTM:=_tabela.M_KTM;
            _result.M_N:=_tabela.M_N;
            _result.TP_KTM:=_tabela.TP_KTM;
            _result.TP_N:=_tabela.TP_N;
            _result.TL_NRK:=_tabela.TL_NRK;
            _result.WER:=_tabela.WER;
            _result.TM_NRK:=_tabela.TM_NRK;
            _result.DFLT_KTL:=_tabela.DFLT_KTL;
            _result.GRKTM:=_tabela.GRKTM;
            _result.TGDFLT:=_tabela.TGDFLT;
            _result.PT:=_tabela.PT;
            _result.RKTL:=_tabela.RKTL;
            {? _result.DFLT_KTL='T'
            || _refm:=exec('FindAndGet','#table',M,_tabela.PT,,"ref","null");
               _result.NRK_KTL:=$exec('dflt_ktl','tech_prod',{? _tabela.GRKTM='G' || null || _refm ?})
            || _result.NRK_KTL:=$exec('FindAndGet','#table',TKTL,_tabela.RKTL,,,null())
            ?};
            _result.add()
         ?};
         &_tab_r
      || _result.LP:=_tabela.LP;
         _result.POZ:=exec('tree_level','qtechniczny',_m,_n,_result.LP);
         _result.KTM:=_tabela.KTM;
         _result.M_KTM:=_tabela.M_KTM;
         _result.M_N:=_tabela.M_N;
         _result.TP_KTM:=_tabela.TP_KTM;
         _result.TP_N:=_tabela.TP_N;
         _result.TL_NRK:=_tabela.TL_NRK;
         _result.WER:=_tabela.WER;
         _result.TM_NRK:=_tabela.TM_NRK;
         _result.DFLT_KTL:=_tabela.DFLT_KTL;
         _result.GRKTM:=_tabela.GRKTM;
         _result.TGDFLT:=_tabela.TGDFLT;
         _result.PT:=_tabela.PT;
         _result.RKTL:=_tabela.RKTL;
         {? _result.DFLT_KTL='T'
         || _refm:=exec('FindAndGet','#table',M,_tabela.PT,,"ref","null");
            _result.NRK_KTL:=$exec('dflt_ktl','tech_prod',{? _tabela.GRKTM='G' || null || _refm ?})
         || _result.NRK_KTL:=$exec('FindAndGet','#table',TKTL,_tabela.RKTL,,,null())
         ?};
         _result.add()
      ?};
      _tabela.next()
   !}
?};
TKTL.cntx_pop();

_result

\tree_level
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [22.26]
:: OPIS: Funkcja umożliwia sortowanie funkcji rekurencyjnych '01.00.00.00.00.00' - poziom 1
::   WE: [_a] - tablica 6-elementowa '_a[1]1._a[2]0._a[3].0...' itd... 1 el
::       [_b] - tablica 6-elementowa '0_b[1].0_b[2].0_b[3]...' itd 2 el
::       [_c] - poziom 1,2,3,4,5,6 INTEGER
::   WY: pozycja docelowa STRING np. 1 el='01.00.00.00.00.00'
::----------------------------------------------------------------------------------------------------------------------
_lp:='';
{? _c=0
|| {? _b[1]=9
   || _b[1]:=0;
      _a[1]+=1
   || _b[1]+=1
   ?};
   _a[2]:=0;
   _a[3]:=0;
   _a[4]:=0;
   _a[5]:=0;
   _a[6]:=0;
   _b[2]:=0;
   _b[3]:=0;
   _b[4]:=0;
   _b[5]:=0;
   _b[6]:=0;
   {? _b[1]<10 & _a[1]<10
   || {! _i:=1..6
      |! {? _i<6
         || _lp+=$_a[_i]+$_b[_i]+'.'
         || _lp+=$_a[_i]+$_b[_i]
         ?}
      !}
   ?}
|? _c=1
|| {? _b[2]=9
   || _b[2]:=0;
      _a[2]+=1
   || _b[2]+=1
   ?};
   _a[3]:=0;
   _a[4]:=0;
   _a[5]:=0;
   _a[6]:=0;
   _b[3]:=0;
   _b[4]:=0;
   _b[5]:=0;
   _b[6]:=0;
   {? _b[2]<10 & _a[2]<10
   || {! _i:=1..6
      |! {? _i<6
         || _lp+=$_a[_i]+$_b[_i]+'.'
         || _lp+=$_a[_i]+$_b[_i]
         ?}
      !}
   ?}
|? _c=2
|| {? _b[3]=9
   || _b[3]:=0;
      _a[3]+=1
   || _b[3]+=1
   ?};
   _a[4]:=0;
   _a[5]:=0;
   _a[6]:=0;
   _b[4]:=0;
   _b[5]:=0;
   _b[6]:=0;
   {? _b[3]<10 & _a[3]<10
   || {! _i:=1..6
      |! {? _i<6
         || _lp+=$_a[_i]+$_b[_i]+'.'
         || _lp+=$_a[_i]+$_b[_i]
         ?}
      !}
   ?}
|? _c=3
|| {? _b[4]=9
   || _b[4]:=0;
      _a[4]+=1
   || _b[4]+=1
   ?};
   _a[5]:=0;
   _a[6]:=0;
   _b[5]:=0;
   _b[6]:=0;
   {? _b[4]<10 & _a[4]<10
   || {! _i:=1..6
      |! {? _i<6
         || _lp+=$_a[_i]+$_b[_i]+'.'
         || _lp+=$_a[_i]+$_b[_i]
         ?}
      !}
   ?}
|? _c=4
|| {? _b[5]=9
   || _b[5]:=0;
      _a[5]+=1
   || _b[5]+=1
   ?};
   _a[6]:=0;
   _b[6]:=0;
   {? _b[5]<10 & _a[5]<10
   || {! _i:=1..6
      |! {? _i<6
         || _lp+=$_a[_i]+$_b[_i]+'.'
         || _lp+=$_a[_i]+$_b[_i]
         ?}
      !}
   ?}
|? _c=5
|| {? _b[6]=9
   || _b[6]:=0;
      _a[6]+=1
   || _b[6]+=1
   ?};
   {? _b[6]<10 & _a[6]<10
   || {! _i:=1..6
      |! {? _i<6
         || _lp+=$_a[_i]+$_b[_i]+'.'
         || _lp+=$_a[_i]+$_b[_i]
         ?}
      !}
   ?}
?};
_lp


\zmiana_uzysku
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Funkcja pozwala na zmianę uzysku na wartość 1 na pozycjach TMAT
::       przeliczenie ilości brutto na pdstawie ilości netto
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

exec('Tpar_decl','tech_param');


_tab:=sql('select TMAT.REFERENCE as REF from @TMAT
             join @TKTL using(TMAT.NRK,TKTL.REFERENCE)
            where TMAT.ACT=\'T\' and TKTL.ARCH=\'N\' and TKTL.STAN=\'T\'
                  and TMAT.UNB>0 and TMAT.UNB<1 and TKTL.ZL is null
         ');

{? _tab.first()
|| {!
   |? {? _tab.REF<>''
      || exec('FindAndGet','#table', TMAT,_tab.REF,
              ,"{? TMAT.UNB>0 & TMAT.UNB<1
                || TMAT.UNB:=1;
                   TMAT.WARB:=TMAT.WARN;
                   TMAT.put()
                ?}
               ")
      ?};
      _tab.next()
   !}
?};
1


\czy_rp_prod_rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Funkcja naprawiające zapisy w prod_rej - znacznik czy można raportować
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

PROD_REJ.cntx_psh();
PROD_REJ.prefix();
{? PROD_REJ.first()
|| {!
   |? {? PROD_REJ.ZGP().DOK<>null()
      || {? PROD_REJ.RP<>'T' || PROD_REJ.RP:='T'; PROD_REJ.put() ?}
      || {? PROD_REJ.RP<>'N' || PROD_REJ.RP:='N'; PROD_REJ.put() ?}
      ?};
      PROD_REJ.next()
   !}
?};
PROD_REJ.cntx_pop();
1