:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: qprocesy.fml
:: Utworzony: 23.09.2020
:: Autor: WH JacekTe
::======================================================================================================================
:: Zawartość: Formuły obsługujące procesy
::======================================================================================================================

\tktl_mail
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [RR.xx] / JacekT
:: OPIS: Przygotowanie treści maila - analiza kart technologicznych
::   WY: STRING - treść maila
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('') || _a:='' ?};
VAR_DEL.delete('__maxstr','__can_continue');
_result:='';
:__maxstr:=524172;
__maxstr:=345000;
__can_continue:=1;
_TKTL:=sql('
   select
      /*+MASK_FILTER(TKTL,\'txktl___\') */
      TKTL.REFERENCE,JORG,M.KTM,TKTL.OPIS,TKTL.NRK,\':\'||TKTL.IDADD||TKTL.REFERENCE as IDADD, QGRP5.GRP5 as PROD, M.R as RODZ
   from
      @TKTL left join M left join QGRP5 using (M.GRP5,QGRP5.reference)
    where
      JORG is null
      and TKTL.ZL is null'
);
_TKTL2:=sql('
      select distinct
         /*+MASK_FILTER(TKTL,\'txktl___\') */
         TKTL.REFERENCE,JORG,M.KTM,TKTL.OPIS,TKTL.NRK,\':\'||TKTL.IDADD||TKTL.REFERENCE as IDADD, QGRP5.GRP5 as PROD, M.R as RODZ
      from
         @TKTL join M left join QGRP5 using (M.GRP5,QGRP5.reference)
      where
         TKTL.REFERENCE in (select  /*+MASK_FILTER(TKTL,\'txktl___\') */ TOPER.NRK from TOPER join TYPYDOK where TYPYDOK.T=\'PW\')
         and TKTL.ZL is null'
);
_TKTL3:=sql('
   select
      /*+MASK_FILTER(TKTL,\'txktl___\') */
      TKTL.REFERENCE,JORG,M.KTM,TKTL.OPIS,TKTL.NRK,\':''||TKTL.IDADD||TKTL.REFERENCE as IDADD, QGRP5.GRP5 as PROD, M.R as RODZ
   from
      @TKTL left join M left join QGRP5 using (M.GRP5,QGRP5.reference)
   where
      TKTL.REFERENCE not in (select distinct TMAT.NRK from @TMAT)
      and TKTL.ZL is null'
);
_TKTL4:=sql('
   select distinct
      M.KTM,
      TKTL.NRK,
      QGRP5.GRP5 as PROD,
      M.R as RODZ,
      \'operacja: \'||TTOPER.KOD as OPIS,
      \':\'||TKTL.IDADD||TKTL.REFERENCE as IDADD
   from
      @TOPER
      left join TTOPER using (TOPER.OPER,TTOPER.reference)
      left join @TKTL using (TOPER.NRK,TKTL.reference)
      left join M using (TKTL.KTM, M.reference)
      left join QGRP5 using (M.GRP5,QGRP5.reference)
   where
      TKTL.ARCH=\'N\'
      and TTOPER.KOD in (\'mmiesz\',\'smiesz\',\'mnawazanie_OFF\')
      and TOPER.FIX_NORM=\'N\'
      and TKTL.ZL is null'
);
_TKTL5:=sql('
   select distinct
      M2.KTM,
      TKTL.NRK,
      QGRP5.GRP5 as PROD,
      M2.R as RODZ,
      \'surowiec nr: \'||TMAT.LP||\', Indeks: \'||M1.KTM||\' do operacji: \'||TTOPER.KOD as OPIS,
      \':\'||TKTL.IDADD||TKTL.REFERENCE as IDADD
   from
      @TMAT
      left join M as M1 using (TMAT.PT,M1.reference)
      left join @TOPER using (TMAT.NROP,TOPER.reference)
      left join TTOPER using (TOPER.OPER,TTOPER.reference)
      left join @TKTL using (TMAT.NRK,TKTL.reference)
      left join M as M2 using (TKTL.KTM,M2.reference)
      left join QGRP5 using (M2.GRP5,QGRP5.reference)
   where
      TKTL.ARCH=\'N\'
      and TTOPER.KOD in (\'mmiesz\',\'smiesz\',\'mnawazanie\')
      and TMAT.ROZ=\'N\'
      and TKTL.ZL is null'
);

_result+=exec('run_gen_tab','qprocesy',_TKTL,
              '<h3>I. Karty bez uzupełnionego WYDZIAŁU: %1</h3><br>'@[$_TKTL.size()],
              '',_a);
_result+=exec('run_gen_tab','qprocesy',_TKTL2,
              '<br><br><br><br><h3>II. Karty z niepoprawnie uzupełnionym polem typ dokumentu: %1</h3><br>'@[$_TKTL2.size()],
              '<h4>UWAGA: Pole "Typ dokumentu" należy uzupełnić wyłącznie na ostatniej operacji. Poprawny typ dokumentu to: "RP" </h4><br><br>',_a);
_result+=exec('run_gen_tab','qprocesy',_TKTL3,
              '<br><br><br><br><h3>III. Karty bez przypisanych surowców technologicznych: %1</h3><br>'@[$_TKTL3.size()],
              '',_a);
_result+=exec('run_gen_tab','qprocesy',_TKTL4,
              '<h3>IV. Karty z operacjami wymagającymi stałej normy czasowej: %1</h3><br>'@[$_TKTL4.size()],
              '',_a);
_result+=exec('run_gen_tab','qprocesy',_TKTL5,
              '<h3>V. Karty z surowcami wymagającymi rozliczenia z operacją: %1</h3><br>'@[$_TKTL5.size()],
              '',_a);
VAR_DEL.delete('__maxstr','__can_continue');
_result


\run_gen_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JacekT [20.42]
:: OPIS: Utworzenie tabelki wiadomości
::   WE: _a - tabela do analizy
::       _b - treść 1
::       _c - treść 2
::   WY: Treść wiadomości
::----------------------------------------------------------------------------------------------------------------------

_result:='';
{? +_d
|| _a.index(_a.ndx_tmp(,1,'RODZ',,));
   _a.prefix('P')
?};
{? _a.first()
||
:: Przygotowanie tabelki
   _result:=_b;
   _result+=_c;
   {? +_d
   || _result+='
         <table [[STYLE_TABLE]]>
         <tr [[STYLE_TABLE_TR]]>
            <th [[STYLE_TABLE_TH]]>%1 &nbsp;&nbsp;&nbsp;</th>
            <th [[STYLE_TABLE_TH]]>%2 &nbsp;&nbsp;&nbsp;</th>
            <th [[STYLE_TABLE_TH]]>%3 &nbsp;&nbsp;&nbsp;</th>
            <th [[STYLE_TABLE_TH]]>%4 &nbsp;&nbsp;&nbsp;</th>
            <th [[STYLE_TABLE_TH]]>%5 &nbsp;&nbsp;&nbsp;</th>
            <th [[STYLE_TABLE_TH]]>%6 &nbsp;&nbsp;&nbsp;</th>
         </tr>
      '
      ['Lp.','Rodzaj konfekcji','Kod produktu','Opis','Numer karty','Link']
   || _result+='
         <table [[STYLE_TABLE]]>
         <tr [[STYLE_TABLE_TR]]>
            <th [[STYLE_TABLE_TH]]>%1 &nbsp;&nbsp;&nbsp;</th>
            <th [[STYLE_TABLE_TH]]>%2 &nbsp;&nbsp;&nbsp;</th>
            <th [[STYLE_TABLE_TH]]>%3 &nbsp;&nbsp;&nbsp;</th>
            <th [[STYLE_TABLE_TH]]>%4 &nbsp;&nbsp;&nbsp;</th>
            <th [[STYLE_TABLE_TH]]>%5 &nbsp;&nbsp;&nbsp;</th>
         </tr>
      '
      ['Lp.','Kod produktu','Opis','Numer karty','Link']
   ?};
   _lp:=0;
   _size_end:=exec('get_str_size','#string','</table>');

   {!
   |?
::    Dodawanie wierszy do tabelki
      _lp+=1;

      _uri:=exec('link_uri','#system',exec('obj_ntab_set','#array',,'LINK',_a.IDADD()));
      _link:='<a href="%1" title="link">link</a>'[_uri];

      {? +_d
      || _row:='
            <tr [[STYLE_TABLE_TR]]>
               <td [[STYLE_TABLE_TD]] align="right">%1</td>
               <td [[STYLE_TABLE_TD]] >%2</td>
               <td [[STYLE_TABLE_TD]] >%3</td>
               <td [[STYLE_TABLE_TD]] >%4</td>
               <td [[STYLE_TABLE_TD]] >%5</td>
               <td [[STYLE_TABLE_TD]] >%6</td>
            </tr>
         '
         [$_lp,_a.PROD,_a.KTM,_a.OPIS,_a.NRK,_link]
      || _row:='
            <tr [[STYLE_TABLE_TR]]>
               <td [[STYLE_TABLE_TD]] align="right">%1</td>
               <td [[STYLE_TABLE_TD]] >%2</td>
               <td [[STYLE_TABLE_TD]] >%3</td>
               <td [[STYLE_TABLE_TD]] >%4</td>
               <td [[STYLE_TABLE_TD]] >%5</td>
            </tr>
         '
         [$_lp,_a.KTM,_a.OPIS,_a.NRK,_link]
      ?};


      _size_row:=exec('get_str_size','#string',_row);

      {? _size_row+exec('get_str_size','#string',_result)+_size_end>__maxstr
      || __can_continue:=0
      ||
         _result+=_row
      ?};
      _a.next & __can_continue>0
   !};
   __maxstr-=exec('get_str_size','#string',_result);
   _result+='</table>'
?};
_result


\xp_zam_spr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JacekT [20.42]
:: OPIS: Analiza nowych zamówień sprzedaży zarejestrowanych w Xpertis pod kontem istniejacych kart technologicznych w Merit
::   WE:
::   WY: Treść wiadomości
::----------------------------------------------------------------------------------------------------------------------
VAR_DEL.delete('sbuf');
_result:='';
_cur:=sql('
         select distinct
            /*+MASK_FILTER(ZK_P,\'zkpozw__\') */
            ZK_N.SYM SYM_ZAM,ZK_P.DT TERMIN,M.KTM,M.N,\'\' IDADD, QGRP5.GRP5 as RODZ
         from
            @ZK_P join @ZK_N join M using (ZK_P.M,M.reference) left join QGRP5 using (M.GRP5,QGRP5.reference)
            join  TYPYZAM using (ZK_N.T,TYPYZAM.reference) left join MGR using(M.MGR,MGR.reference)
         where
             (MGR.KOD like \'02-%\' or MGR.KOD like \'01-%\')
             and ZK_N.DP<=to_date(:_a)
             and TYPYZAM.R=\'Z\'
             and ZK_N.A=\'A\' order by 6,2',date()-14
         );
{? ~_cur.first()
|| return('ERROR02')
?};
__maxstr:=524172;
__can_continue:=1;
_TKTL:=sql('select *
            from :_a
            where
               :_a.KTM not in (select distinct KTM from :_b
            order by 2)
            ',_cur,sql('select /*+MASK_FILTER(TKTL,\'txktl___\') */ M.KTM from @TKTL left join M where TKTL.ZL is null and TKTL.STAN=\'T\'')
            );
_TKTL.index(_TKTL.ndx_tmp(,1,'TERMIN',,,'SYM_ZAM',,,'KTM',,));
_result:=exec('run_gen_tab2','qprocesy',_TKTL,
              '<br><br><br><br><h3>Lista pozycji zamówień sprzedaży zarejestrowanych do dnia %1 dla których nie odnalezionio kart technologicznych: %2</h3><br>'@[$(date-14),$_TKTL.size()],
              '');
_TKTL.ndx_drop();
VAR_DEL.delete('sbuf','__maxstr','__can_continue','_TKTL');
_result


\run_gen_tab2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JacekT [20.42]
:: OPIS: Utworzenie tabelki wiadomości
::   WE: _a - tabela do analizy
::       _b - treść 1
::       _c - treść 2
::   WY: Treść wiadomości
::----------------------------------------------------------------------------------------------------------------------

_result:='';
{? _a.first()
||
:: Przygotowanie tabelki
   _result:=_b;
   _result+=_c;
   _result+='
      <table [[STYLE_TABLE]]>
      <tr [[STYLE_TABLE_TR]]>
         <th [[STYLE_TABLE_TH]]>%1 &nbsp;&nbsp;&nbsp;</th>
         <th [[STYLE_TABLE_TH]]>%2 &nbsp;&nbsp;&nbsp;</th>
         <th [[STYLE_TABLE_TH]]>%3 &nbsp;&nbsp;&nbsp;</th>
         <th [[STYLE_TABLE_TH]]>%4 &nbsp;&nbsp;&nbsp;</th>
         <th [[STYLE_TABLE_TH]]>%5 &nbsp;&nbsp;&nbsp;</th>
         <th [[STYLE_TABLE_TH]]>%6 &nbsp;&nbsp;&nbsp;</th>
      </tr>
   '
   ['Lp.','Rodzaj konfekcji','Indeks materiałowy','Nazwa materiału','Numer zamówienia','Termin realizacji'];
   _lp:=0;
   _size_end:=exec('get_str_size','#string','</table>');

   {!
   |?
::    Dodawanie wierszy do tabelki
      _lp+=1;
      _size_txt:=0;

      _uri:=exec('link_uri','#system',exec('obj_ntab_set','#array',,'LINK',_a.IDADD()));
      _link:='<a href="%1" title="link">link</a>'[_uri];

      _row:='
         <tr [[STYLE_TABLE_TR]]>
            <td [[STYLE_TABLE_TD]] align="right">%1</td>
            <td [[STYLE_TABLE_TD]] >%2</td>
            <td [[STYLE_TABLE_TD]] >%3</td>
            <td [[STYLE_TABLE_TD]] >%4</td>
            <td [[STYLE_TABLE_TD]] >%5</td>
            <td [[STYLE_TABLE_TD]] >%6</td>
         </tr>
      '
      [$_lp,_a.RODZ,_a.KTM,_a.N,_a.SYM_ZAM,$_a.TERMIN];

      _size_row:=exec('get_str_size','#string',_row);

      {? _size_row+_size_txt+_size_end>__maxstr
      || __can_continue:=0
      ||
         _result+=_row;
         _size_txt:=exec('get_str_size','#string',_result)
      ?};
      _a.next & __can_continue>0
   !};
   _result+='</table>'
?};
_result


\mat_xpertis_analiza
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [RR.xx]
:: OPIS:
::   WE: _a - nazwa połączenia ODBC na serwerze
::   WY: Treść wiadomości
::----------------------------------------------------------------------------------------------------------------------
M.cntx_psh();
JM.cntx_psh();
M.cntx_psh();
MGR.cntx_psh();
SLO.cntx_psh();
SLU.cntx_psh();

::aktualizacja grup materiałowych
_WSQL:=odbc_con(_a);
_mgr:=_WSQL.exec_tab('select * from MGR ');
_mgradd:=sql('select * from :_a where :_a.KOD not in (select KOD from MGR)',_mgr);
{? _mgradd.first
|| {! |?
         MGR.prefix;
         MGR.blank();
         MGR.RODZ:=_mgradd.RODZ;
         MGR.KOD:=_mgradd.KOD;
         MGR.NAZ:='(#*)'+_mgradd.NAZ;
         MGR.DOKL:=_mgradd.DOKL;
         MGR.DOKL_S:=2;
         MGR.DOKL_Z:={? MGR.RODZ='T' || MGR.DOKL_C || 2 ?};
         MGR.add;
         _mgradd.next
   !}
?};
_WSQL.clos_cur;
VAR_DEL.delete('_WSQL');
::Lista indeksów z Xpertis dodanych w roku 2021
_mktm:=_WSQL.exec_tab('select  SLO.KOD VAT,JM.KOD JM, MGR.KOD MGR_KOD,MGR.NAZ MGR_NAZ, MGR.DOKL MGR_DOKL,M.* from M join MGR join JM  join SLO using (M.VAT,SLO.reference) where IDADD like \'2021%\' ');
::Indeksy brakujące w Merit
_mktmadd:=sql('select * from :_a where :_a.KTM not in (select KTM from M)',_mktm);
{? _mktmadd.first()
||
   {! |?
         JM.prefix;
         M.prefix;
         M.blank();
         M.KTM:=_mktmadd.KTM;
         M.N:="(*#*)"+_mktmadd.N;
         {? _mktmadd.JM<>'' & JM.find_key(gsub(_mktmadd.JM,'.','')) || M.J:=JM.ref() ?};
         SLO.prefix();
         SLU.index('NAZ');
         SLU.prefix('~STAWKI VAT PL');
         {? SLU.first()
         || SLO.index('SL');
            SLO.prefix(SLU.ref())
         ?};
         {? _mktmadd.VAT<>'' & SLO.find_key(_mktmadd.VAT)|| M.VAT:=SLO.ref() ?};

         M.IDMOB:=_mktmadd.IDMOB;
         M.SETW:=_mktmadd.SETW;
         M.RODZ:=_mktmadd.RODZ;
         MGR.prefix();
         {? MGR.find_key(M.RODZ,_mktmadd.MGR_KOD)
         || M.MGR:=MGR.ref();
            M.DOKL_S:=MGR.DOKL_S;
            M.DOKL_Z:=MGR.DOKL_Z
          ?};

         M.R:=_mktmadd.R;
         M.CZY_TW:=_mktmadd.CZY_TW;
         M.KODK:=_mktmadd.KODK;
         M.WN:=_mktmadd.WN;
         M.WB:=_mktmadd.WB;

         M.DOKL:=_mktmadd.DOKL;
         M.DOKL_C:=_mktmadd.DOKL_C;

         M.OPIST:=_mktmadd.OPIST;
         M.KODT:=_mktmadd.KODT;
         M.KP:=_mktmadd.KP;
         M.OPAKOW:=_mktmadd.OPAKOW;
         M.WYS:=_mktmadd.WYS;
         M.SZER:=_mktmadd.SZER;
         M.WAR01:='1';
         M.add();
         _mktmadd.next()
   !}
?};
_WSQL.clos_cur;
M.cntx_pop();
JM.cntx_pop();
M.cntx_pop();
MGR.cntx_pop();
SLO.cntx_pop();
SLU.cntx_pop();
~~


\material_mail
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [RR.xx]
:: OPIS: Przygotowanie treści maila
::   WY: STRING - treść maila
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_maxstr:=524172;

_result:='';
_can_continue:=1;

M.cntx_psh();
_ndx:=M.ndx_tmp(,,'IDADD',,);
M.index(_ndx);
_idtime:=time_ident(date(),time(0,0,0));
{? M.find_ge(_idtime)
||

:: Przygotowanie tabelki
   _result:='<h3>Lista indeksów dodanych w dniu '+date()$1+'</h3><br><br>';
   _result+='
      <table [[STYLE_TABLE]]>
      <tr [[STYLE_TABLE_TR]]>
         <th [[STYLE_TABLE_TH]]>%1 &nbsp;&nbsp;&nbsp;</th>
         <th [[STYLE_TABLE_TH]]>%2 &nbsp;&nbsp;&nbsp;</th>
         <th [[STYLE_TABLE_TH]]>%3 &nbsp;&nbsp;&nbsp;</th>
         <th [[STYLE_TABLE_TH]]>%4 &nbsp;&nbsp;&nbsp;</th>
         <th [[STYLE_TABLE_TH]]>%5 &nbsp;&nbsp;&nbsp;</th>
      </tr>
   '
   ['Lp.','Indeks materiałowy','Nazwa indeksu','Grupa','Link'];
   _lp:=0;
   _size_end:=exec('get_str_size','#string','</table>');

   {!
   |? _next:=0;
      _ref_nxt:=null();
      M.cntx_psh();
      {? M.next()
      || _ref_nxt:=M.ref()
      ?};
      M.cntx_pop();

::    Dodawanie wierszy do tabelki
      _lp+=1;
      _size_txt:=0;

      _uri:=exec('link_uri','#system',exec('obj_ntab_set','#array',,'LINK',M.uidref()));
      _link:='<a href="%1" title="link">link</a>'[_uri];

      _row:='
         <tr [[STYLE_TABLE_TR]]>
            <td [[STYLE_TABLE_TD]] align="right">%1</td>
            <td [[STYLE_TABLE_TD]] >%2</td>
            <td [[STYLE_TABLE_TD]] >%3</td>
            <td [[STYLE_TABLE_TD]] >%4</td>
            <td [[STYLE_TABLE_TD]] >%5</td>
         </tr>
      '
      [$_lp,M.KTM,M.N,M.MGR().KOD,_link];

      _size_row:=exec('get_str_size','#string',_row);

      {? _size_row+_size_txt+_size_end>_maxstr
      || _can_continue:=0
      ||
         _result+=_row;
         _size_txt:=exec('get_str_size','#string',_result)
      ?};
      {? _ref_nxt<>null()
      || _next:=M.seek(_ref_nxt)
      ?};
      _next>0 & _can_continue>0
   !};
   _result+='</table>'
?};

M.ndx_drop(_ndx);
M.cntx_pop();
_result


\akcept_pz_mail
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO]
:: OPIS: Przygotowanie treści mail z informacją o dokumencie przychodowym do weryfikacji przez KJ
::   WE: _a - ND.ref - ref dokumentu do wysłania informacji
::   WY: treść wiadomości
::----------------------------------------------------------------------------------------------------------------------
''


\key_zkn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Wystawia klucz grupujący z nagłówkami zamówień dla których należy wygenerować zadanie todo bądź należy
::       je zarchiwizować
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;
_in:=params_get().in;

_zakres_dni:=exec('get_w','#params',999201,type_of(0));
_data_od:=date();
_data_do:=date()+_zakres_dni;

_mp.grpkey();

_tab_1:=sql('select ZK_N.REFERENCE as REF from @ZK_N join TYPYZAM
               where ZK_N.PL_DATA between to_date(:_a) and to_date(:_b)
                     and ZK_N.STAT_REJ<>\'A\'
                     and TYPYZAM.R=\'W\'',
             _data_od,_data_do);
{? _tab_1.first()
|| {!
   |?
::    weryfikacja czy ZK_N nie jest w masce archiwalnej
      {? ((8+_tab_1.REF)+2)='__'
      ||
::    weryfikacja czy nie ma już procesu realizacji dla tego zamówienia
          _uidref:=exec('FindAndGet','#table',ZK_N,_tab_1.REF,,"ZK_N.uidref()",null());
         {? ~exec('record_keyrefed','#b__box',_uidref,'LMG_ZAM_IPRZ')
         || _mp.grpkeyAdd(_tab_1.REF)
         ?}
      ?};
       _tab_1.next()
   !}
?};

_mp.done();
~~


\key_dk_ln
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Wystawia klucz grupujący z nagłówkami reorganizacji do zatwierdzenia
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;
_in:=params_get().in;

_ar:='';

::  klucz do odnalezienia zestawu DK_LN do akceptacji automatycznej

{? _in.ITEM<>''
|| _ar:=_in.ITEM
?};


_mp.grpkey();


_dkln:=sql('select DK_LN.REFERENCE REF
              from @DK_LN
             where DK_LN.GRP_KEY=\':_a\'',_ar);

_dkln.clear();
{? _dkln.first()
|| {!
   |? _mp.grpkeyAdd(_dkln.REF);
      _dkln.next()
   !}
?};

_mp.done();
~~


\proj2dok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [NUCO]
:: OPIS: Uzupełnienie informacji o projektach na dokumentach które powstają od pozycji zamówienia do pozycji faktury.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
ZK_P.cntx_psh();
ZK_P.use('zkpozw__');
ZK_P.index('PROJEKTY');
ZK_P.prefix('A','Z');
_TAB:=sql('
   select ZK_P.REFERENCE as REF, ZK_P.PROJEKTY as PROJEKTY
   from ZK_P
   where ZK_P.PROJEKTY is not null'
);
ZK_P.cntx_pop();

exec('select','#table',_TAB);
~~


\key_eann
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [JOBON]
:: OPIS: Wystawia klucz grupujący z pozycjiami EANN do automatycznej realizcaji reorganizacji dla wszystkich magazynów
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;
_in:=params_get().in;

_mp.grpkey();

_eann:=sql('select EANN.REFERENCE REF, EANN.DATA DATA
              from @EANN
             where EANN.REFERENCE like \'eannw___%\'
                   and EANN.AKT=\'T\'
                   and EANN.TYP=\'R\'
                   and EANN.STAN=\'Z\'
                   and EANN.ZLEC=\'N\'');
_eann.clear();
{? _eann.first()
|| {!
   |? _mp.grpkeyAdd(_eann.REF);
      _eann.next()
   !}
?};

_mp.done();
~~


\zam_edokum_status
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JacekTe [21.14]
:: OPIS: Formuła na bramę oczukującą do weryfikacji statusu wniosku w obiegu; zmiana standardowej exec('FindAndGet','#table',EDOKUM,_a.p01,,"STATUS<>''",0)
::       Formuła odnajduje aktualny wniosek z nagłówka zamówienia - OBI_POW - zamiast weryfikacji refa wygenerowanego za 1 razem przez czynność serwisową
::       Procesy: NUCO_ZKM_DOS_ZD_NAG,...
::   WE: _a - _p01 - ref zamówienia
::       _b - warunek (formuła)
::   WY: 0/1 czekamy na zmianę statusu / idziemy dalej
::----------------------------------------------------------------------------------------------------------------------
::Standard - exec('FindAndGet','#table',EDOKUM,_a.p01,,"STATUS<>''",0)

{? var_pres('_a')=type_of(null())
|| _zd_nag:=_a
||
:: Jeżeli w _a przekazane ~~ to znak że zamówienie usunięto i można puścić te zdarzenia dalej
:: bo one prowadzą do zakończenia procesów
   return(1)
?};

_wynik:=0;

_edokum:=exec('FindAndGet','#table',ZD_NAG,_zd_nag,,"ZD_NAG.OBI_POW",'');
{? _edokum<>''
|| _wynik:=exec('FindAndGet','#table',EDOKUM,_edokum,,_b,0)
?};
_wynik


\zam_spr_mail
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [RR.xx] / JacekTe
:: OPIS: Przygotowanie treści maila - wysyłanie informacji o nowo dodanych zamówieniach sprzedaży
::   WY: STRING - treść maila
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_maxstr:=524172;

_result:='';
_can_continue:=1;

ZK_N.cntx_psh();
TYPYZAM.cntx_psh();
ZK_N.use('zknagw__');
_ndx:=ZK_N.ndx_tmp(,,'T','R',,'IDADD',,);
ZK_N.index(_ndx);
ZK_N.prefix('Z');
_idtime:=time_ident(date(),time(0,0,0));
{? ZK_N.find_ge(_idtime)
||

:: Przygotowanie tabelki
   _result:='<h3>Nowe zamówienia sprzedaży z dnia '+date()$1+'</h3><br><br>';
   _result+='
      <table [[STYLE_TABLE]]>
      <tr [[STYLE_TABLE_TR]]>
         <th [[STYLE_TABLE_TH]]>%1 &nbsp;&nbsp;&nbsp;</th>
         <th [[STYLE_TABLE_TH]]>%2 &nbsp;&nbsp;&nbsp;</th>
         <th [[STYLE_TABLE_TH]]>%3 &nbsp;&nbsp;&nbsp;</th>
         <th [[STYLE_TABLE_TH]]>%4 &nbsp;&nbsp;&nbsp;</th>
         <th [[STYLE_TABLE_TH]]>%5 &nbsp;&nbsp;&nbsp;</th>
      </tr>
   '
   ['Lp.','Symbol zamówienia','Nazwa kontrahenta','Wew.termin rea.','Link'];
   _lp:=0;
   _size_end:=exec('get_str_size','#string','</table>');

   {!
   |?
      _next:=0;
      _ref_nxt:=null();
      ZK_N.cntx_psh();
      {? ZK_N.next()
      || _ref_nxt:=ZK_N.ref()
      ?};
      ZK_N.cntx_pop();
::    Dodawanie wierszy do tabelki
      _lp+=1;
      _size_txt:=0;

      _uri:=exec('link_uri','#system',exec('obj_ntab_set','#array',,'LINK',ZK_N.uidref()));
      _link:='<a href="%1" title="link">link</a>'[_uri];

      _row:='
         <tr [[STYLE_TABLE_TR]]>
            <td [[STYLE_TABLE_TD]] align="right">%1</td>
            <td [[STYLE_TABLE_TD]] >%2</td>
            <td [[STYLE_TABLE_TD]] >%3</td>
            <td [[STYLE_TABLE_TD]] >%4</td>
            <td [[STYLE_TABLE_TD]] >%5</td>
         </tr>
      '
      [$_lp,ZK_N.SYM,ZK_N.KH().NAZ,ZK_N.PL_DATA$1,_link];

      _size_row:=exec('get_str_size','#string',_row);

      {? _size_row+_size_txt+_size_end>_maxstr
      || _can_continue:=0
      ||
         _result+=_row;
         _size_txt:=exec('get_str_size','#string',_result)
      ?};
      {? _ref_nxt<>null()
      || _next:=ZK_N.seek(_ref_nxt)
      ?};
      _next>0 & _can_continue>0
   !};
   _result+='</table>'
?};

ZK_N.ndx_drop(_ndx);
ZK_N.cntx_pop();
TYPYZAM.cntx_pop();
_result


\czy_rola
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Funkcja sprawdza czy użytkownik posiada rolę podana w argumencie
::   WE: _a - B_ROLE.NAME,
::       [_b]- USERS.ref()
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_rola:='';

_user:=OPERATOR.USER;
_firma:=REF.FIRMA;

{? var_pres('_a')=type_of('') || _rola:=_a ?};
{? var_pres('_b')=type_of(null) || _user:=_b ?};

{? _rola<>'' & _user<>null()
|| _sql_ref_rola:=sql('select B_ROLE.REFERENCE as SQL_REF
                     from B_ROLE
                    where B_ROLE.FIRMA=:_a and B_ROLE.NAME=\':_b\''
                    , _firma, _rola).SQL_REF;
   {? _sql_ref_rola<>''
   || _b_role:=exec('FindAndGet','#table',B_ROLE,_sql_ref_rola,,,null());
      {? _b_role<>null()
      || B_USRROL.cntx_psh();
         B_USRROL.index('UNIK');
         B_USRROL.prefix(_firma,_b_role,_user);
         {? B_USRROL.size()>0
         || _result:=1
         || _result:=0
         ?}
      ?}
   ?}
?};

_result


\uprawnienia_akcept_ZK_N
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Weryfikacja użytkownika do akceptacji zamówienia - dodanie zadania tylko dla osoby będącej twórcą ZK_N
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_result:=0;

_mp:=params_get().mp;
_user:=params_get().user;
_in:=params_get().in;

ZK_N.cntx_psh();
{? var_pres('ZK_N',_in)>0 & _in.ZK_N & ZK_N.seek(_in.ZK_N,ref_name(_in.ZK_N),1)
|| {? _user=ZK_N.US
   || _result:=1
   ?}
|| _result:=1
?};
ZK_N.cntx_pop();

_result


\czy_oferta
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [TEST]
:: OPIS: Weryfikacja czy oferta nie została usunięta oraz czy nie została czy nie zostało do niej wystawione zamówienie
::       oraz czy oferta nie jest przeterminowana
::   WE: _a - OFERTA.uidref
::   WY:  0 - oferta jest i nie ma zamówienia, 1 - oferty nie ma lub zostało wygenerowane do niej zamówienie poza proc.
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_ref_ofe:=exec('FindAndGet','#table',OFE,_a,,"ref()",null);

:: czy jest oferta
{? _ref_ofe=null()
|| 'brak oferty w bazie - rekord usunięty';
   _result:=1
|? exec('FindAndGet','#table',OFE,_a,,"TW",date()-1)<date()
|| 'oferta przeterminowana';
   _result:=1
|| 'sprawdzenie czy nie wystawiono zamówienia do oferty poza procesem';
   _tab:=sql('select ZK_N.REFERENCE from @ZK_N where ZK_N.OFE=:_a',_ref_ofe);
   _result:=_tab.first()
?};

_result


\key_px_conn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Wystawia klucz grupujący z pozycjami planu strategicznego dla których należy utwożyć polecenia utworzenia zleceń
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------

_czy_tab_zam:='N';

_mp:=params_get().mp;

_mp.grpkey();
_data_startu:=date(2022,07,01);
_data_konca:=date();

_data_konca:=exec('ask4date','qtechniczny','Uruchomienie produkcji do: ',_data_konca,,_data_startu);

:: tablica zamówień do weryfikacji
{? FUN.ask('Czy dodatkowa tablica do weryfikacji pozycji zamówień?')
|| _tab_zam:=exec('czy_zlec','qtechniczny');
   {? _tab_zam.first()
   || _czy_tab_zam:='T'
   ?}
?};

{? _data_konca<>date(0,0,0)
|| _tab_1:=sql(' select PX_CONN.REFERENCE as REF_PX,
                      PX_OBJ.ZK_P as REF_ZK_P,
                      PX_OBJ.QPDP as START
                 from @PX_CONN join @PX_VER join @PX_OBJ join @ZK_P
                where PX_VER.PRIMARY=1
                      and PX_OBJ.ZL is null
                      and PX_OBJ.REM_ZGL is null
                      and PX_OBJ.ZK_P is not null
                      and PX_OBJ.QPDP is not null
             order by START');
   {? _tab_1.first()
   || {!
      |? {? _tab_1.START>=_data_startu & _tab_1.START<=_data_konca
         ||
:: Sprawdzenie czy zamówienie ma już wygenerowane zlecenia i czy można jeszcze coś wygenerować
            ZLZAM.cntx_psh();
            ZLZAM.index('ZMZL');
            ZLZAM.prefix(_tab_1.REF_ZK_P);
            _IL_ZL:=0;
            _IL_WYTW:=exec('FindAndGet','#table',ZK_P,_tab_1.REF_ZK_P,,"ZK_P.ILP-ZK_P.ILRB",0);
            {? ZLZAM.first()
            || {!
               |? _IL_ZL+=ZLZAM.ILZL;
                  _ilr:=0;
                  _ilr:=sql('select sum(REZ.ILR) as S_ILR
                               from @REZ
                              where REZ.ZLZAM=\':_a\' and REZ.RODZ=\'B\''
                              , $ZLZAM.ref()).S_ILR;
                  _IL_WYTW+=_ilr;
                  ZLZAM.next()
               !}
            ?};
            ZLZAM.cntx_pop();
            {? _IL_WYTW-_IL_ZL>0
            ||
:: Sprawdzenie czy nie uruchomiono już zadania TODO dla tej pozycji zamówienia
                _uid_ref:=exec('FindAndGet','#table',PX_CONN,_tab_1.REF_PX,,"PX_CONN.uidref()",'');
               {? _uid_ref<>'' & exec('record_keyrefed','#b__box',_uid_ref,'ZWS_MAN_UALL')=0
               ||
:: Sprawdzenie czy jest w tablicy zamówień
                  {? _czy_tab_zam='T'
                  || {? sql('select :_a.ZAM from :_a where :_a.REF_POZ=\':_b\'', _tab_zam, _tab_1.REF_ZK_P).first()
                     || _mp.grpkeyAdd(_tab_1.REF_PX)
                     ?}
                  || _mp.grpkeyAdd(_tab_1.REF_PX)
                  ?}
               ?}
            ?}
         ?};
         _tab_1.next()
      !}
   ?}
?};

_mp.done();
~~


\pop_pozy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [2008]
:: OPIS: poprawia pozycje na zamowieniu
::   WE: [_a] - INTEGER - 0/1 - czy okno wywołane od strony planu strategicznego
::       Zmiana dotyczy popraiania tylko w zakresie dat.
::   WY: 0 / 1
::  OLD: \pop_pozy/zk.fml
::----------------------------------------------------------------------------------------------------------------------
_px_plan:=0;
{? var_pres('_a')=type_of(0)
|| _px_plan:=_a
?};

POMOC.RODZ:='T';
BEER.OKZKP:=1;
ATR.MJS:='ZK_P';
_oldmg:=ZK_P.RMAG;

{? ZK_P.ZD_POZ<>''
||
   exec('zdp_info','zamsiw_poz');
   FUN.info('Pozycja powiązana z dostawą dedykowaną %1.'@[ZK_Z.ZDP_INFO])
?};

BEER.MENU_PTH+='P';
_wyn:=1;

:: _pop_rea - poprawa realizowanej pozycji =0-niedostępna, =1-dostępna
_pop_rea:=0;

{? ZK_N.T().R='Z' & exec('get','#params',3010,2,OPERATOR.USER)='T'
||
:: ile na powiazanych zleceniach
   _ilzl:=0;
   ZLZAM.index('ZMZL');
   ZLZAM.prefix($ZK_P.ref());
   {? ZLZAM.first()
   ||
      {!
      |?
         _ilzl+=ZLZAM.ILZL;
         ZLZAM.next()
      !}
   ?};

:: ile w powiazanym planie
   _ilpx:=0;
   PX_OBJ.index('ZK_P');
   PX_OBJ.prefix(ZK_P.name(),ZK_P.ref());
   {? PX_OBJ.first()
   || _ilpx+=PX_OBJ.IL_PLAN
   ?};

:: ile zarezerwowano
   _ilr:=ZK_P.ILRB+ZK_P.ILRW+ZK_P.ILRD;

   _pop_rea:=(_ilzl+_ilpx+_ilr)=0
?};

:: ile zrealizowano
VAR_DEL.delete('__ZKP_ILR');
__ZKP_ILR:=ZK_P.ILZ-ZK_P.ILP;

D_HELP.M_ZKP:={? ZK_P.M<>null || ZK_P.M().KTM || '' ?};

{? (ZK_P.M().RODZ='T' | ZK_P.M=null()) & (ZK_P.ILZ=ZK_P.ILP & ZK_P.ILP<>0 | _pop_rea)
||_prrez:=ZK_P.REZ;
   BEER.ZAMUPR:=exec('jakieupr','zamsiw_wspolne',ZK_P.RODZ='W');
   exec('oneuprzk','zamsiw_wspolne',BEER.ZK_N,BEER.ZAMUPR);
   {? ZK_P.N().MG<>null
   || ZK_P.RMAG:=ZK_P.N().MG;
      ZK_P.put(1)
   ?};
   BEER.DOL:=0;
   BEER.ILZ:=ZK_P.ILZ;
   BEER.REZ:=ZK_P.REZ;
   BEER.DOST:=ZK_P.DOST;
   BEER.JM:=ZK_P.M().J;
   BEER.IL22:=ZK_P.IL2;
:: przeliczniki jednostek
:: exec('ustazprz','zamsiw_poz',ZK_P.M,ZK_P.M().J);

   ZK_P.get();
   _term:=ZK_P.DT;
   _dan:=obj_new(8);
   _dan[1]:=ZK_P.ref();  _dan[2]:=ZK_P.ILP;  _dan[3]:=ZK_P.ILZ;    _dan[4]:=ZK_P.SR;
   _dan[5]:=ZK_P.CENA; _dan[6]:=ZK_P.CWAL; _dan[7]:=ZK_P.M().VAT().KOD; _dan[8]:=ZK_P.M;
   _rmag:=ZK_P.RMAG; _ilewgd:=0;
   {? (_ilewgd:=exec('sprwgdst','zamsiw_poz',ZK_P.N,ZK_P.POZ))>0 || ZK_P.REZ:=1; ZK_P.DOST:=1; ZK_P.put(1) ?};
   ATR.M_ATR:=ZK_P.M().M_ATR;
   ATR.UZUP:='';
   BEER.RDOST:=_ilewgd>0;
   BEER.RDST:=_ilewgd;
   BEER.RAUT:=ZK_P.SR-BEER.RDST;
   _bylrez:=ZK_P.REZ;
   ZK_P.cntx_psh();
   {? var_pres('PxSelect')>100 | _px_plan>0
   ||
      _px_plan:=1;
::    W planie strategicznym dostepna tylko mozliwosc poprawiania daty
      ZK_P.win_edit('REDDT')
   |? __ZKP_ILR
   ||
      ZK_P.win_edit('POPREA1')
   ||
      ZK_P.win_edit('RED'+ZK_P.RODZ);
      ZK_P.btn_eopt('RED'+ZK_P.RODZ,'REZER','state=grayed');
      {? ~exec('samgdost','mat_atr')
      || ZK_P.btn_eopt('RED'+ZK_P.RODZ,'ATRYB','state=grayed')
      || ZK_P.btn_eopt('RED'+ZK_P.RODZ,'ATRYB','state=normal')
      ?}
   ?};
   _magdst:={? ZK_P.RMAG<>null() || (1+ZK_P.RMAG().TYP)='D' || exec('samgdost','mat_atr') ?};
   {? _magdst
   || ATR.MJS:='ZK_P';
      ATR.M_ATR:=ZK_P.M().M_ATR
   || ATR.MJS:='M_ATR';
      M_ATR.blank(0);
      ATR.M_ATR:=null()
   ?};
   ATR.FLAG_ED:=_magdst & ATR.CZY_ATR & ATR.M_ATR().EDIT & ~exec('czysarez','rezerwacje');
   ATR.FLAG:={? ATR.FLAG_ED & ZK_P.M().M_ATR<>null() || 2 || 0 ?};
   {? ATR.FLAG_ED || {? ZK_P.M().M_ATR<>null() || ATR.FLAG_ED:=2 ?} ?};
   {? ZK_P.DK_C<>null() & ZK_P.DK_C().M_ATR<>null()
   || ZK_P.DK_C().M_ATR().SYM;
      {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=($('ZK_P.DK_C().WAR'+form(_i,-2,,'99')))() !}
   || {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !}
   ?};
   exec('set_efld_opt','mat_atr','ZK_P');
   exec('set_efld_opt','zamsiw_poz');
   POMOC.MGRZ:=ZK_P.M().MGR;
   POMOC.MGR:=ZK_P.M().MGR;
   {? POMOC.MGR<>null()
   || MGR.seek(POMOC.MGR)
   ?};
   {? ZK_P.edit("exec('chk_pozy','zamsiw_poz')")
   || _mat:=ZK_P.M;
      _rez:=ZK_P.REZ; _prrez:=ZK_P.REZ;
      {? ZK_P.RMAG=null & ZK_P.ILR=0 & ~ZK_P.ONLY || ZK_P.MG:=null ?};
      {? ZK_P.M().RODZ='T'
      || _zmien:=ZK_P.DT<>_term;
         {? _zmien || ZK_P.DODT:=ZK_P.DT ?};
         ZK_P.put(1);
         {? _zmien
         || REZ.index('ZK_P');
            REZ.prefix(ZK_P.ref());
            {? REZ.first()
            || {!
               |? {? (REZ.RODZ='B' | REZ.AUTO) & REZ.DODT=_term
                  || REZ.DODT:=REZ.ZK_P().DT;
                     REZ.put(1)
                  ?};
                  REZ.next()
               !}
            ?}
         ?};
         _zkp:=tab_tmp(1,'MAT','STRING[16]','','ZKP','STRING[16]','');
         _zkp.blank(); _zkp.MAT:=$ZK_P.M; _zkp.ZKP:=$ZK_P.ref(); _zkp.add(1);
         {? ZK_P.REZ
         || {? ~_bylrez
            || exec('pop_rezy','rezerwacje',ZK_P.ref(),ZK_P.ILZ);
               exec('aktu_rez','rezerwacje',ZK_P.M,ZK_P.NR,ZK_P.ILZ,$ZK_P.N,_zkp)
            || exec('aktu_rez','rezerwacje',ZK_P.M,ZK_P.NR,fabs(ZK_P.ILZ-BEER.ILZ),$ZK_P.N,_zkp)
            ?}
         || exec('update','rezerwacje','ZK_P',ZK_P.ref(),ZK_P.RMAG,ZK_P.M,0);
            exec('aktu_rez','rezerwacje',ZK_P.M,ZK_P.NR,BEER.ILZ,$ZK_P.N,_zkp);
            {? _dan[8]<>_mat
            || exec('aktu_zam_sm','magazyn_stan',_dan[8]);
               exec('aktu_zam_sm','magazyn_stan',_mat,ZK_P.RMAG)
            ?}
         ?};
         obj_del(_zkp)
      || {? ZK_P.RMAG<>null & ZK_P.RMAG().U='T' & ZK_P.ILP>0 || 'T' || 'N' ?};
         ZK_P.put(1)
      ?};
      exec('war_zam','zamsiw_nag',ZK_P.N,_dan);
      exec('aktu_stu','zamsiw_wspolne',_mat,1,1);
      {? ZK_N.MG<>null & ZK_N.MG().PAL='T' || exec('ctrl_pal','zamsiw_palety') ?};

::    Produkcja - jesli dostepny modul planow strategicznych to po udanej
::    edycji pozycji zamowienia aktualizuje obiekt planowania
      {? exec('tpp_lic','tpp')='T'
      || exec('zkp2obj','px_obj')
      ?};
      {? ZK_P.RMAG<>_oldmg || exec('aktu_zam_sm','magazyn_stan',ZK_P.M,ZK_P.RMAG) ?}
   ||
      {? _px_plan
      || _wyn:=0
      ?};
::    nacisnieto klawisz ESC przywracamy poprzedniego RMAG-a
      {? _rmag<>ZK_P.RMAG
      || _nag:=ZK_P.N;
         _poz:=ZK_P.POZ;
         ZK_P.cntx_psh();
         ZK_P.index('NAG');
         ZK_P.prefix(_nag,_poz);
         {? ZK_P.first()
         || {!
            |? ZK_P.RMAG:=_rmag;
               ZK_P.MG:=_rmag;
               {? ~(ZK_P.MG().TYP*'DOST') || ZK_P.DOST:=0 ?};
               ZK_P.ONLY:=_rmag<>null;
               ZK_P.put(1);
               ZK_P.next()
            !}
         ?};
         ZK_P.cntx_pop()
      ?};
      {? ZK_P.DOST || ZK_P.get(); ZK_P.DOST:=0; ZK_P.REZ:=_prrez; ZK_P.put(1) ?}
   ?};
   ZK_P.cntx_pop();
   obj_del(_dan);
   {? BEER.MENU_PTH='ZZYDP' | BEER.MENU_PTH='ZZTYDP'
   || grp_disp(M,'WER_ZAM');
      grp_disp(__smmag,__okn)
   ?};
   MG.f_clear();
   JM.f_clear();
   JM.win_dict('WER')
|? ZK_P.M().RODZ='U' & ZK_P.ILZ=ZK_P.ILP
||
   BEER.ILZ:=ZK_P.ILZ;
   POMOC.RODZ:='U';
   ZK_P.get();
   _dan:=obj_new(8);
   _dan[1]:=ZK_P.ref();  _dan[2]:=ZK_P.ILP;  _dan[3]:=ZK_P.ILZ;    _dan[4]:=ZK_P.SR;
   _dan[5]:=ZK_P.CENA; _dan[6]:=ZK_P.CWAL; _dan[7]:=ZK_P.M().VAT().KOD; _dan[8]:=ZK_P.M;
   {? BEER.TYPYZAM().R='W'
   || ZK_P.win_edit('REDUW')
   || ZK_P.win_edit('REDU');
      ZK_P.efld_opt('REDU','mark=1',BEER,'SMG')
   ?};
   {? ZK_P.edit("exec('chk_pozy_usl','zamsiw_poz')")
   || {? ZK_P.MG<>null || ZK_P.RMAG:=ZK_P.MG ?};
      ZK_P.put(1);
      exec('war_zam','zamsiw_nag',ZK_P.N,_dan);
      exec('aktznzkp','zamsiw_poz',ZK_P.ref(),1);
      exec('aktznzkn','zamsiw_nag',ZK_P.N,1)
   ?};
   obj_del(_dan);
   ZK_P.efld_opt('REDU','mark=0',BEER,'SMG');
   POMOC.RODZ:='T'
|? ZK_P.M().RODZ='T' & ZK_P.ILP>0
||
   ZK_P.win_edit('POPREA');
   {? ZK_P.edit("exec('chk_pozy','zamsiw_poz')")
   || ZK_P.put(1);
      _wyn:=1
   || _wyn:=0
   ?}
|? ZK_P.M().RODZ='U' & ZK_P.ILP>0
||
   FUN.info('Pozycja już realizowana, modyfikacja niemożliwa.'@);
   _wyn:=0
|? ZK_P.ILP=0
||
   FUN.info('Pozycja została zrealizowana.\nPoprawianie pozycji niemożliwe.'@);
   _wyn:=0
||
   _wyn:=0
?};
BEER.MENU_PTH-=1;
VAR_DEL.delete('__ZKP_ILR');
_wyn


\zl_w_pl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Weryfikacja czy zlecenie znajduje się w planie strategicznym i nie znajduje się w planie operacyjnym
::   WE: _a - ZL.ref
::   WY: 1 - jest w planie, 0 - nie jest w planie
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
exec('FindAndGet','#table',ZL, _zl,,"@.ZL.PLAN_PX='T'",0)


\zl_ps_us
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Usunięcie zlecenia z planu strategicznego - zostanie ponownie zaplanowane w dlaszej częściprocesu.
::   WE: [_a] - ZL.ref(),  lub dla potrzeb procesu modyfikacji zlecenia (tylko w procesie) _in.p01 - ZL.ref
::       [_b] - 1/0        dla potrzeb procesu możliwość usówania całkowitego bądź tylko zapisów o pozycjach
::                         _in.p02
::   WY: 1 - udało się usunąć zlecenie, 0 - coś poszło nie tak - zadanie na listę zadań
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_zl:=null();
_us_z_kolejki:=0;

{? _>0
|| {? var_press('_a')=type_of(null()) || _zl:=_a ?};
   {? _>1 & var_press('_b')=type_of(0) || _us_z_kolejki:=_b ?}
|| _mp:=params_get().mp;
   _in:=params_get().in;
   {? var_pres('p01',_in)<>type_of(~~)
   || _zl:=_in.p01
   ?};
   {? var_pres('p02',_in)<>type_of(~~)
   || _us_z_kolejki:=_in.p02
   ?}
?};

{? _zl<>null()
|| _px_obj:=exec('get_zl_object','px_obj', _zl);
   {? _px_obj<>null()
   ||
      _mainver:=exec('get_mainversion','px_ver');
      PX_CONN.cntx_psh();
      PX_CONN.index('VER');
      PX_CONN.prefix(_mainver,_px_obj);
      _ref_table:=exec('ref_table','#table');
      {? PX_CONN.first()
      || {!
         |? _ref_table.add(PX_CONN.PX_GRP);
            PX_CONN.next()
         !}
      ?};
      _can_continue:=1;
      _tab:=_ref_table.tab;
      _px:=0;
      {? _tab.first()
      || _px:=1;
         {!
         |? _next:=0;
            _ref_nxt:=null();
            _tab.cntx_psh();
            {? _tab.next()
            || _ref_nxt:=_tab.ref()
            ?};
            _tab.cntx_pop();

            _can_continue:=exec('clean_from_plan','px_grp',_tab.SQL,1,1,1,0);

            {? _ref_nxt<>null()
            || _next:=_tab.seek(_ref_nxt)
            ?};
            _next>0 & _can_continue>0
         !}
      ?};
      {? _can_continue>0 & _us_z_kolejki
      || {? _tab.first()
         || {!
            |? _can_continue:=exec('delete','px_grp',_tab.SQL);
               _tab.next() & _can_continue>0
            !}
         ?}
      ?};
      {? _px>0
      || {? _can_continue>0
         || exec('add_zwar_pos','zl_common','pl',0,'Usunięto zlecenie z planu strateg.'@)
         || exec('komm_add','zl_common','Nie udało się usunąć zlecenia z planu strategicznego.'@,2,1)
         ?}
      ?};
      exec('il_plan_refresh','px_obj',_px_obj);
      exec('planend_refresh','px_obj',_px_obj);
      PX_CONN.cntx_pop()
   ?};
   _result:=1
|| FUN.error('Nie odnaleziono zlecenia, zlecenie nie może być usunięte z planu strategiczneo'
             '\nWymagana ręczna korekta zapisów dotycząca planu strategicznego.');
   {? var_press('_mp')>0
   || _mp.cancel()
   ?}
?};

_result


\zgh_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Uzunięcie przewodników zlecenia
::   WE: dlapotrzeb procesu modyfikacji zlecenia (tylko w procesie) _in.p01 - ZL.ref
::   WY: 1 - udało się usunąć, 0 coś poszło nie tak
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_zl:=null();

_mp:=params_get().mp;
_in:=params_get().in;

{? var_pres('p01',_in)<>type_of(~~)
|| _zl:=_in.p01;
   VAR.A_ZLEC:=_zl;
   ST.ODDZ:=VAR.A_ZLEC().ODDZ
?};

{? _zl<>null()
|| _result:=exec('zgh_usun','qtte',_zl)
?};

_mp.done();

_result


\czy_zgh_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Rejestracja przewodnika - akcja 'Usuń' weryfikacja możliwości usunięcia przewodników zlecenia
::   WE: dlapotrzeb procesu modyfikacji zlecenia (tylko w procesie) _in.p01 - ZL.ref
::   WY: 1 - można usunąć zgh, 0 - nie da się usunąć - nie prubuje :)
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_zl:=null();

_mp:=params_get().mp;
_in:=params_get().in;

{? var_pres('p01',_in)<>type_of(~~)
|| _zl:=_in.p01;
   VAR.A_ZLEC:=_zl;
   ST.ODDZ:=VAR.A_ZLEC().ODDZ
?};

{? _zl<>null()
|| _result:=exec('czy_zgh_usun','qtte',_zl)
?};

_mp.done();

_result


\zk_p_ps_us
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_TEST]
:: OPIS: Usunięcie ZK_P z planu strategicznego - zostanie ponownie zaplanowane w dlaszej częściprocesu.
::   WE: [_a] - ZK_P.ref(),  lub dla potrzeb procesu modyfikacji zlecenia (tylko w procesie) _in.p01 - ZK_P.ref
::   WY: 1 - udało się usunąć pozycje zamówienia, 0 - coś poszło nie tak - zadanie na listę zadań
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_zk_p:=null();

{? _>0
|| {? var_press('_a')=type_of(null()) || _zk_p:=_a ?}
|| _mp:=params_get().mp;
   _in:=params_get().in;
   {? var_pres('p01',_in)<>type_of(~~)
   || _zk_p:=_in.p01
   ?}
?};

{? _zk_p<>null()
|| _px_obj:=exec('get_zkp_object','px_obj', _zkp);
   {? _px_obj<>null()
   ||
      _mainver:=exec('get_mainversion','px_ver');
      PX_CONN.cntx_psh();
      PX_CONN.index('VER');
      PX_CONN.prefix(_mainver,_px_obj);
      _ref_table:=exec('ref_table','#table');
      {? PX_CONN.first()
      || {!
         |? _ref_table.add(PX_CONN.PX_GRP);
            PX_CONN.next()
         !}
      ?};
      _can_continue:=1;
      _tab:=_ref_table.tab;
      _px:=0;
      {? _tab.first()
      || _px:=1;
         {!
         |? _next:=0;
            _ref_nxt:=null();
            _tab.cntx_psh();
            {? _tab.next()
            || _ref_nxt:=_tab.ref()
            ?};
            _tab.cntx_pop();

            _can_continue:=exec('clean_from_plan','px_grp',_tab.SQL,1,1,1,0);

            {? _ref_nxt<>null()
            || _next:=_tab.seek(_ref_nxt)
            ?};
            _next>0 & _can_continue>0
         !}
      ?};
      {? _can_continue>0
      || {? _tab.first()
         || {!
            |? _can_continue:=exec('delete','px_grp',_tab.SQL);
               _tab.next() & _can_continue>0
            !}
         ?}
      ?};
      {? _px>0
      || {? _can_continue>0
         || exec('add_zwar_pos','zl_common','pl',0,'Podczas zamykania usunięto automatycznie zlecenie z planu strateg.'@)
         || exec('komm_add','zl_common','Nie udało się usunąć zlecenia z planu strategicznego.'@,2,1)
         ?}
      ?};
      exec('il_plan_refresh','px_obj',_px_obj);
      exec('planend_refresh','px_obj',_px_obj);
      PX_CONN.cntx_pop()
   ?};
   _result:=1
|| FUN.error('Nie odnaleziono pozycji zamówienia, pozycja nie może być usunięte z planu strategiczneo'
             '\nWymagana ręczna korekta zapisów dotycząca planu strategicznego.');
   {? var_press('_mp')>0
   || _mp.cancel()
   ?}
?};

_result


\key_zk_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Wystawia klucz grupujący z pozycjami zamówienia dla którego należy wygenerować zlecenia produkcyjne
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;
_in:=params_get().in;

{? var_pres('p01',_in)=type_of(null()) & _in.p01<>null()
|| _zk_n:=_in.p01
|| _zk_n:=null()
?};

_mp.grpkey();

{? _zk_n<>null()
|| _tab_1:=sql('select ZK_P.REFERENCE as REF from @ZK_P
               where ZK_P.N=:_a',_zk_n);
   {? _tab_1.first()
   || {!
      |? _mp.grpkeyAdd(_tab_1.REF);
         _tab_1.next()
      !}
   ?}
?};

_mp.done();
~~


\dalej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO]
:: OPIS: Zadanie pytania czy kontynować proces czy usunąć proces, czy rezygnacja z odpowiedzi
::   WE: [_a] - tytuł z pytaniem do zadania
::   WY: 0 - pozostaw zadania, 1 koniec zadania
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;
_out:=0;
_pytanie:='';
_result:=1;

{? _>0 & type_of('') || _pytanie:=_a || _pytanie:='Czy kontynuować proces?' ?};

_wyb:=FUN.choice(_pytanie,1,'Tak','Anuluj zadanie',,,'Nie');

{? _wyb=1 || _out:=1
|? _wyb=2 || _out:=0
|| _out:=0;
   _result:=0
?};
_mp.save(exec('kind_out','#b_port'),'OUT',_out);

_result


\zamiana_mag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO]
:: OPIS: Zmiana wydziału wykonującego zlecenie poprzez podmiane magazynu (wykorzystane w procesie poprawiania zlecenia
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;
_in:=params_get().in;
_result:=1;

_zl:=_in.p01;
VAR.A_ZLEC:=_zl;

_mg:=VAR.A_ZLEC().MG;
_wyd:=exec('FindInSet','#table','SLO','SL',VAR.A_ZLEC().MG().SYM,VAR.A_ZLEC().JORG().SLU,,1,,null());

{? _wyd<>null()
|| {? ZL.JORG<>_wyd
   || ZL.JORG:=_wyd;
      ZL.put()
   ?};
   ZL.cntx_psh();
   ZLIM.cntx_psh();
   ZLIM.index('ZN');
   ZLIM.prefix();
   ZLIM.f_clear();
   ZLIM.prefix(VAR.A_ZLEC);
   {? ZLIM.first()
   || _zk_n:=null();
      {!
      |? {? ZLIM.AKC='T' & exec('zlim_pob_il','zl_limit',$ZLIM.ref()).IL=0
         || _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
            ZLIM.MG:=ZLIM.ZLEC().MG;
            ZLIM.WYD:=ZLIM.ZLEC().JORG;
            ZLIM.put();
            {? _zk_p<>null()
            || _zk_n:=exec('FindAndGet','#table',ZK_P,_zk_p,,"RMAG:=MG:=ZL().MG;
                                                               WYD:=ZL().JORG;
                                                               {? put() || N || null() ?}",null())
            ?}
         ?};
         ZLIM.next()
      !};
      {? _zk_n<>null()
      || exec('FindAndGet','#table',ZK_N,_zk_n,,"WYD:=ZL().JORG; put()",0)
      ?}
   ?};
   ZL.cntx_pop();
   ZLIM.cntx_pop()
?};
_result


\czy_zk_p_plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Formuła ma za zadanie (po cichu) ustalić czy da się zaplanować strategicznie pozycje zamówienia,
::   WE: _a - ZK_P.ref
::      [_b]- 0/1 czy wyświetlać komunikaty - domyślnie 0 - nie wyświetlać
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_zk_p:=_a;
_can_continue:=1;
_msg:='';

_dialog:=0;
{? _>1 & var_pres('_b')=type_of(1) || _dialog:=_b ?};

_ver:=exec('get_mainversion','px_ver');

ZK_P.cntx_psh();
{? _zk_p<>null()
|| ZK_P.use(ref_name(_zk_p))
|| _can_continue:=0
?};

{? _can_continue & ZK_P.seek(_zk_p)
|| ZK_N.use(ref_name(ZK_P.N));
:: Sekcja sprawdzania

   _planned:=exec('zkp_planned','px_obj',_zk_p,_ver);
   _what:=exec('record','#to_string',_zk_p);
   _dir:=ZK_P.PL_DIR;
   _pl_data:=ZK_P.PL_DATA;

   {? ZK_P.N().STAT_REJ='N' |  ZK_P.N().STAT_REJ='A'
   || _can_continue:=0;
      _msg:='Nie można zaplanować obiektu: %1 ponieważ zamówienie nie jest zakończone.'@[_what]
   ?};

   {? _dir=0 & _can_continue>0
   ||
      _can_continue:=0;
      _msg:='Nie można zaplanować obiektu: %1, ponieważ na zamówieniu nie określono zwrotu planowania.'@[_what]
   ?};

   {? _pl_data=date(0,0,0) & _can_continue>0
   || _can_continue:=0;
      _msg:='Nie można zaplanować obiektu: %1, ponieważ na zamówieniu nie określono wewnętrznego teminu realizacji.'@[_what]
   ?};

   {? _can_continue>0
   ||
      {? 'PW'*ZK_P.M().R & M.RODZ='T'
      || _can_continue:=1
      || _can_continue:=0;
         _msg:='Nie można zaplanować obiektu: %1, ponieważ jego indeks materiałowy nie jest wyrobem gotowym lub półfabrykatem.'@[_what]
      ?}
   ?};

   {? _can_continue>0
   ||
      {? ZK_P.N().A='Z'
      || _can_continue:=0;
         _msg:='Nie można zaplanować obiektu: %1, ponieważ znajduje się w archiwum.'@[_what]
      ?}
   ?};

   {? _can_continue>0
   || {? _planned>=ZK_P.ILP-ZK_P.ILRB
      ||
::       Jeżeli wszystko już w kolejce to komunikat
         _can_continue:=0;
         _msg:='Nie można zaplanować obiektu: %1, ponieważ cała ilość znajduje się już w kolejce.'@[_what]
      ?}
   ?};

::   Dla pozycji zamowienia szukamy powiazanych zlecen
   {? _can_continue>0
   || ZLZAM.index('ZMZL');
      ZLZAM.prefix($_zk_p);
      {? ZLZAM.first()
      || {!
         |?
::   Sprawdzenie czy ZK_P ma juz utworzone zlecenie, jesli tak, to nalezy planowac zlecenie
            {? ZLZAM.ZL<>null()
            || _can_continue:=0;
               _msg:='Nie można zaplanować obiektu: %1, ponieważ ma już utworzone zlecenia.\n Zaplanuj zlecenia.'@[_what]
            ?};
            ZLZAM.next()
         !}
      ?}
   ?}
?};

{? _dialog & _msg<>'' || FUN.emsg(_msg) ?};

ZK_P.cntx_pop();
_can_continue


\otw_zlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [22.26 NUCO]
:: OPIS: Otwarcie zlecenia nadrzędnego niezależnego jeśli jest taka potrzeba
::   WE: [_a] - ZL.ref() / bieżące zlecenie
::       [_b] - INTEGER - 0/[1] - czy wyświetlać pytania
::       [_c] - INTEGER - 0/[1] - czy inicjować i wyświetlać KOMMa
::       [_d] - STRING - przyczyna otwarcia zlecenia
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null()) || _zl:=_a || _zl:=ZL.ref() ?};
{? var_pres('_b')=type_of(0) || _ask:=_b || _ask:=1 ?};
{? var_pres('_c')=type_of(0) || _komm:=_c || _komm:=1 ?};
{? var_pres('_d')=type_of('') || _cause:=_d || _cause:='' ?};

ZL.cntx_psh();
ZL.clear();

_symbol:=exec('FindAndGet','#table',ZL,_zl,,"@.ZL.SYM",'');
_cause:='Z powodu otwarcia zlecenia %1'@[_symbol];
_zl_nad:=exec('top_level','zl_link',_zl);
_rodzaj:=exec('FindAndGet','#table',ZL,_zl_nad,,"@.ZL.RODZAJ",'X');
_stan:=exec('FindAndGet','#table',ZL,_zl_nad,,"@.ZL.STAN",'X');

{? _zl<>_zl_nad & _rodzaj='N' & _stan='Z'
|| exec('zl_otworz','!tte_pzl_eotw',_zl_nad,0,0,_cause)
?};

ZL.cntx_pop();
1


\gen_pow_oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Wygenerowanie domyślnej struktury powiązań pomiędzy operacjami dla karty technologicznej w procesie tworzenia karty.
::   WE:
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
_tktl:=null();

_mp:=params_get().mp;
_in:=_mp.load(exec('kind_in','#b_port'));

{? var_pres('p01',_in)<>type_of(~~)
|| _tktl:=_in.p01
?};

{? _tktl<>null()
|| exec('er_tab','tech_oper',_tktl);
   exec('gen_pow','tech_oper',_tktl)
?};
1


\del_zgp_limity_zkpz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: Usunięcie powiązania limitu z zamówieniami wewnętrznymi
::       z której utworzono zlecenie
::   WE: _a - ZGP.ref()
::       Nie jest sprawdzana obecność ani typ przekazanego argumentu
::  OLD: \zgp_limity_zkpz/zl_lim01.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
ZLIM.cntx_psh();
ZLIM.clear();
ZLIM.f_clear();
ZLIM.index('ZGP_M');
ZLIM.prefix(_a);
_loop:=ZLIM.first();
{!
|? _loop
|!
   _wyn:=exec('DelZlim2ZkZl','qprocesy');
   _loop:=_wyn=0 & ZLIM.next()
!};
ZLIM.cntx_pop();
_wyn


\DelZlim2ZkZl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: Usunięcie powiązań z pozycją zamówienia wewnętrznego z której utworzono zlecenie
::   WY: 0-nie 1-tak
::  OLD: \jestZlim2ZkZl/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
_zk_n:=exec('ZK_N_4_ZLiWYD','zamsiw_limit',ZLIM.ZLEC,exec('GetZLIM_WYD','zl_limit'),0
        ,,,{? ZLIM.MG().PAL='T' || ZLIM.MG || null() ?});
_zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',_zk_n,0);
{? _zk_p
|| ZLZAM.cntx_psh();
   ZLZAM.index('ZMZL');
   ZLZAM.prefix($_zk_p);
   {? ZLZAM.first()
   ||_wyn:=ZLZAM.del(1,1)>0
   ?};
   ZLZAM.cntx_pop()
?};
_wyn


\del_zgh_limity_zkpz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_2226]
:: OPIS: Usunięcie ewentualnych powiązań z innymi zleceniami wygenerowanymi na podstawie limitów do przewodnika
::   WE: _a - ZGH.ref
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_zgh:=null();

{? var_pres('_a')=type_of(null())
|| _zgh:=_a
?};

{? _zgh<>null
|| ZGP.cntx_psh();
   ZGP.index('NRPRZ');
   ZGP.prefix(_zgh);
   {? ZGP.first()
   || {!
      |? exec('del_zgp_limity_zkpz','qprocesy',ZGP.ref());
         ZGP.next()
      !}
   ?}
?};
ZGP.cntx_pop();
1

\key_zk_p_60
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Wystawia klucz grupujący z pozycjami zamówień dla którego należy wygenerować zlecenia produkcyjne
::       brane pod uwagę są zamówienia dla których nie ma jeszcze wygenerowanych zleceń terminem realizacji klienta
::       od date() do date+60, weryfikowana jest kompletność karty technologicznej i termin realizacji (co najmniej dzisiaj),
::       zamówienie musi być w planie strategicznym
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;
_in:=params_get().in;

_mp.grpkey();
_data_od:=date();
_data_do:=date()+60;

_tab_1:=sql('select ZK_P.REFERENCE as REF, ZK_P.PL_DATA, ZK_P.DT, ZK_N.SYM, PX_OBJ.REFERENCE as PX_OBJ_R
               from @ZK_P join @ZK_N using(ZK_P.N,ZK_N.REFERENCE)
                          join M using(ZK_P.M,M.REFERENCE)
                          join PX_OBJ using(PX_OBJ.ZK_P, ZK_P.REFERENCE)
              where ZK_N.AKC=\'T\' and ZK_P.RODZ=\'Z\' and ZK_P.A=\'A\' and ZK_P.ILP>0
                          and (M.R=\'P\' or M.R=\'W\')
                          and ZK_P.DT>to_date(:_a) and ZK_P.DT<=to_date(:_b)
                          and (select count(*) from ZLZAM where ZLZAM.ZAMPOZ=ZK_P.REFERENCE)=0
                          and (select count(*) from PX_CONN where PX_CONN.PX_OBJ=PX_OBJ.REFERENCE)>0
              ',_data_od,_data_do);
{? _tab_1.first()
|| {!
   |? _mat:=exec('FindAndGet','#table',ZK_P,_tab_1.REF,,"M" ,null());
      _dtktl_s:=exec('dflt_ktl','tech_prod',_mat);
      {? _dtktl_s<>null() & exec('czy_tex_ok','qtpp',_dtktl_s)
      || _mp.grpkeyAdd(_tab_1.REF)
      ?};
      _tab_1.next()
   !}
?};
_mp.done();
~~


\wyznacz_zk_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO_CPD]
:: OPIS: Dla czynności manualnej ZK_P - proces NUCO_RPO_ZLN wyznacza ZK_P.ref na podstsawie przekazanych parametrów
::   WE: p01 - ZK_P.ref | $ZK_P.ref - przekazany z procesu
::       p02 - ZK_P.ref | $ZK_P.ref - przekazany z syganłu z pozycji zamówień
::   WY: ZK_P.ref lub null jeśli coś nie tak
::----------------------------------------------------------------------------------------------------------------------
_zk_p:=null();

_mp:=params_get().mp;
_in:=_mp.load(exec('kind_in','#b_port'));

{? var_pres('p01',_in)<>type_of(~~)
|| _zk_p:=exec('FindAndGet','#table',ZK_P,_in.p01,,,null())
|? var_pres('p02',_in)<>type_of(~~)
|| _zk_p:=exec('FindAndGet','#table',ZK_P,_in.p02,,,null())
?};

_mp.save(exec('kind_out','#b_port'),'OUT',_zk_p);

{? _zk_p<>null()
|| _result:=1
|| _result:=0
?};

_result

\key_zk_p_akt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Wystawia klucz grupujący z pozycjami zamówienia których należy zaktualizować zlecenia (daty realizacji oraz wewn.)
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;
_in:=params_get().in;

_mp.grpkey();

_tab_1:=sql('select ZK_P.REFERENCE as REF
                from @ZK_P
               where ZK_P.A=\'A\' and ZK_P.ILP>0 and ZK_P.RODZ=\'Z\'');
{? _tab_1.first()
|| {!
   |? _mp.grpkeyAdd(_tab_1.REF);
      _tab_1.next()
   !}
?};

_mp.done();
~~


\key_zkn_arch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.22]
:: OPIS: Wystawia klucz grupujący z nagłówkami zamówień wewnętrznych do archiwizacji (tylko typ ZWM)
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;
_in:=params_get().in;

_zakres_dni:=14;
_data_do:=date()-_zakres_dni;

_mp.grpkey();

_tab_1:=sql('select ZK_N.REFERENCE as REF from @ZK_N join TYPYZAM
               where ZK_N.DT <= to_date(:_a)
                     and ZK_N.STAT_REJ<>\'A\'
                     and ZK_N.A=\'A\'
                     and TYPYZAM.R=\'W\'
                     and TYPYZAM.T=\'ZWM\'',
             _data_do);
{? _tab_1.first()
|| {!
   |?
::    weryfikacja czy ZK_N nie jest w masce archiwalnej
      {? ((8+_tab_1.REF)+2)='__'
      || _mp.grpkeyAdd(_tab_1.REF)
      ?};
       _tab_1.next()
   !}
?};

_mp.done();
~~


\usun_zlim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TP [NUCO]
:: OPIS: Usunięcie limitów zlecenia
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_mp:=params_get().mp;
_in:=params_get().in;
_result:=1;

_zl:=_in.p01;
VAR.A_ZLEC:=_zl;
ZL.cntx_psh();
ZLIM.cntx_psh();

ZLIM.use('zlim'+VAR.A_ZLEC().MASKA);

{? _zl<>null()
|| exec('usunlim','zl_limit', _zl, 1)
?};

_mp.done();

1

