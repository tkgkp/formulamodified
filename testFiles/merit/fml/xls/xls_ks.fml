:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: xls_odd.fml
:: Utworzony: 23.07.2018
:: Autor: MB
:: Systemy:
::======================================================================================================================
:: Zawartość: Formuły do obsługi eksportu/importu jednostek księgowych
::======================================================================================================================


\filename
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Nazwa pliku do eksportu struktur księgowych
::----------------------------------------------------------------------------------------------------------------------
'struktury_księgowe.xlsx'


\KS_ZEST
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='KS_ZEST';
_def.DOMAIN:=exec('name','#b_domain','ZWS');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.FILE:=exec('filename','xls_ks');
_def.SHEET:='Zespół kont=1,1';
_def.NAME:='Zespół kont'@;
_def.DESC:='Zespół kont';
_def.MULTIFIR:='T';

_def.PREFIX:="KS_ZEST.index('KOD'); KS_ZEST.prefix()";
_def.TABLE:="KS_ZEST";
_def.FIELDS:="exec('KS_ZEST_fld','xls_ks',_a)";

_def.BEFORE:="KS_ZEST.cntx_psh()";
_def.AFTER:="KS_ZEST.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('KS_ZEST_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('KS_ZEST_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('KS_ZEST_imp','xls_ks',_a,_b,_c)";
_def.SELECT:="exec('KS_ZEST_select','xls_ks',_a)";
~~


\KS_ZEST_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [18.42]
:: OPIS: Umożliwia wybór rekordów do eksportu
::   WE: _a - tab_tmp - tabela tymczasowa z polem REF którą należy zasilić
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik potwierdził wybór
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_selected:=_a;

_result:=0;

_tab:=tab_tmp(1,'KOD','STRING[20]','Skrót'
   ,'REF','STRING[16]','SQL ref'
   ,'SELECTED','STRING[1]','Czy wybrano'
   ,'OPIS','STRING[255]','Nazwa');

_ndx:=_tab.ndx_tmp(,,'SELECTED',,,'KOD',,);

KS_ZEST.cntx_psh();
KS_ZEST.index('KOD');
KS_ZEST.prefix();
{? KS_ZEST.first()
|| {!
   |?
      _tab.blank();
      _tab.REF:=$KS_ZEST.ref();
      _selected.prefix($KS_ZEST.ref());
      {? _selected.first()
      || _tab.SELECTED:='T'
      || _tab.SELECTED:='N'
      ?};
      _tab.KOD:=KS_ZEST.KOD;
      _tab.OPIS:=KS_ZEST.OPIS;
      _tab.add();
      KS_ZEST.next()
   !}
?};
_result:=exec('select_action','#table',_tab
 ,'KOD,OPIS',20,'Wybór zespołu kont do eksportu'@,1);
{? _result>0
||
   _selected.erase();

   _tab.index(_ndx);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |?
         _selected.prefix(_tab.REF);
         {? _selected.first()=0
         || _selected.blank();
            _selected.REF:=_tab.REF;
            _selected.add()
         ?};
         _tab.next()
      !}
   ?}
?};
KS_ZEST.cntx_pop();

_result


\KS_ZEST_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('KOD','Skrót',1,,'20 znakowy skrót');
_def.define('OPIS','Nazwa',1,,'255 znakowa nazwa');
~~


\KS_ZEST_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;

_result:=1;
_table.KOD.VALUE:=KS_ZEST.KOD;
_table.OPIS.VALUE:=KS_ZEST.OPIS;
_result


\KS_ZEST_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=1;
KS_ZEST.index('KOD');
KS_ZEST.prefix(_obj.KOD,);
{? KS_ZEST.first()
|| {? _mode=0
   || _result.RESULT:=0
   || _result.ACTION:='put'
   ?}
|| _result.ACTION:='add'
?};
{? _result.RESULT=1
|| {? _result.ACTION='add' || KS_ZEST.blank() ?};
   KS_ZEST.KOD:=_obj.KOD;
   KS_ZEST.OPIS:=_obj.OPIS;
   {? exec('chk_ks_zest','konto',_result.ACTION='add')<>''
   || _result.RESULT:=0
   ?}
?};
~~


\KS_ZEST_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=KS_ZEST.add(1)
   |? _validate.ACTION='put'
   || _result:=KS_ZEST.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie zespołu kont %1 nie powiodło się.'@[_obj.KOD]
   || _validate.MSG:='Poprawa zespołu kont %1 nie powiodła się.'@[_obj.KOD]
   ?}
?};
_result


\KS_KAT
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='KS_KAT';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Kategoria zespołu kont=1,1';
_def.NAME:='Kategoria zespołu kont';
_def.DESC:='Kategoria zespołu kont';
_def.MULTIFIR:='T';

_def.PREFIX:="KS_KAT.index('KOD'); KS_KAT.prefix()";
_def.TABLE:="KS_KAT";
_def.FIELDS:="exec('KS_KAT_fld','xls_ks',_a)";

_def.BEFORE:="KS_KAT.cntx_psh()";
_def.AFTER:="KS_KAT.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('KS_KAT_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('KS_KAT_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('KS_KAT_imp','xls_ks',_a,_b,_c)";
_def.SELECT:="exec('KS_KAT_select','xls_ks',_a)";
~~


\KS_KAT_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [18.42]
:: OPIS: Umożliwia wybór rekordów do eksportu
::   WE: _a - tab_tmp - tabela tymczasowa z polem REF którą należy zasilić
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik potwierdził wybór
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_selected:=_a;

_result:=0;

_tab:=tab_tmp(1,'KOD','STRING[20]','Kod'
   ,'REF','STRING[16]','SQL ref'
   ,'SELECTED','STRING[1]','Czy wybrano'
   ,'KS_ZEST','STRING[20]','Kod zespołu'
   ,'OPIS','STRING[255]','Opis');

_ndx:=_tab.ndx_tmp(,,'SELECTED',,,'KS_ZEST',,);

KS_KAT.cntx_psh();
KS_KAT.index('KOD');
KS_KAT.prefix();
{? KS_KAT.first()
|| {!
   |?
      _tab.blank();
      _tab.REF:=$KS_KAT.ref();
      _selected.prefix($KS_KAT.ref());
      {? _selected.first()
      || _tab.SELECTED:='T'
      || _tab.SELECTED:='N'
      ?};
      _tab.KS_ZEST:=KS_KAT.KS_ZEST().KOD;
      _tab.KOD:=KS_KAT.KOD;
      _tab.OPIS:=KS_KAT.OPIS;
      _tab.add();
      KS_KAT.next()
   !}
?};
_result:=exec('select_action','#table',_tab
 ,'KS_ZEST,KOD,OPIS',20,'Wybór kategorii zespołu kont do eksportu'@,1);
{? _result>0
||
   _selected.erase();

   _tab.index(_ndx);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |?
         _selected.prefix(_tab.REF);
         {? _selected.first()=0
         || _selected.blank();
            _selected.REF:=_tab.REF;
            _selected.add()
         ?};
         _tab.next()
      !}
   ?}
?};
KS_KAT.cntx_pop();

_result


\KS_KAT_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('KS_ZEST','Kod zespołu',1,,'20 znakowy kod');
_def.define('KOD','Kod',1,,'20 znakowy kod');
_def.define('OPIS','Opis',1,,'255 znakowy opis');
~~


\KS_KAT_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;

_result:=1;
_table.KS_ZEST.VALUE:=KS_KAT.KS_ZEST().KOD; _excel.write_async('KS_ZEST',KS_KAT.KS_ZEST);
_table.KOD.VALUE:=KS_KAT.KOD;
_table.OPIS.VALUE:=KS_KAT.OPIS;
_result


\KS_KAT_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=1;
_ks_zest:=exec('FindInSet','#table','KS_ZEST','KOD',_obj.KS_ZEST,,,1);
{? _ks_zest=null
|| _result.MSG:='Nie znaleziono zespołu kont: %1.'@[_obj.KS_ZEST];
   _result.RESULT:=0
|| KS_KAT.index('KOD');
   KS_KAT.prefix(_ks_zest,_obj.KOD,);
   {? KS_KAT.first()
   || {? _mode=0
      || _result.RESULT:=0
      || _result.ACTION:='put'
      ?}
   || _result.ACTION:='add'
   ?};
   {? _result.RESULT=1
   || {? _result.ACTION='add' || KS_KAT.blank() ?};
      KS_KAT.KS_ZEST:=_ks_zest;
      KS_KAT.KOD:=_obj.KOD;
      KS_KAT.OPIS:=_obj.OPIS;
      {? exec('chk_ks_kat','konto',_result.ACTION='add')<>''
      || _result.RESULT:=0
      ?}
   ?}
?};
~~


\KS_KAT_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=KS_KAT.add(1)
   |? _validate.ACTION='put'
   || _result:=KS_KAT.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie KS_KAT %1 nie powiodło się.'@[_obj.OD]
   || _validate.MSG:='Poprawa KS_KAT %1 nie powiodła się.'@[_obj.OD]
   ?}
?};
_result


\KS
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='KS';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.FILE:=exec('filename','xls_ks');
_def.SHEET:='Konta syntetyczne=1,1';
_def.NAME:='Konta syntetyczne';
_def.DESC:='Konta syntetyczne';

_def.PREFIX:="KS.index('SYM'); KS.prefix()";
_def.TABLE:="exec('KS_tab','xls_ks',_a)";
_def.TAB_IMP:="KS";
_def.FIELDS:="exec('KS_fld','xls_ks',_a)";

_def.BEFORE:="KS.cntx_psh()";
_def.AFTER:="KS.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('KS_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('KS_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('KS_imp','xls_ks',_a,_b,_c)";
_def.SELECT:="exec('KS_select','xls_ks',_a)";
~~


\KS_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [18.42]
:: OPIS: Umożliwia wybór rekordów do eksportu
::   WE: _a - tab_tmp - tabela tymczasowa z polem REF którą należy zasilić
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik potwierdził wybór
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_selected:=_a;

_result:=0;

_tab:=tab_tmp(2,
   'ROK','STRING[60]','Rok',
   'SYM','STRING[6]','Symbol',
   'NAZ','STRING[60]','Nazwa',
   'REF','STRING[16]','SQL ref',
   'SELECTED','STRING[1]','Czy wybrano'
);

_ndx:=_tab.ndx_tmp(,,'SELECTED',,,'SYM',,);

KS.cntx_psh();
KS.index('SYM');
KS.prefix();
{? KS.first()
|| {!
   |? {? KS.ROK().FIRMA=REF.FIRMA
      || _tab.blank();
         _tab.REF:=$KS.ref();
         _selected.prefix($KS.ref());
         {? _selected.first()
         || _tab.SELECTED:='T'
         || _tab.SELECTED:='N'
         ?};
         _tab.SYM:=KS.SYM;
         _tab.NAZ:=KS.NAZ;
         _tab.ROK:=KS.ROK().NAZ;
         _tab.add()
      ?};
      KS.next()
   !}
?};
_result:=exec('select_action','#table',_tab
 ,'ROK[5],SYM[6],NAZ[60]',20,'Wybór kont syntetycznych do eksportu'@,1);
{? _result>0
||
   _selected.erase();

   _tab.index(_ndx);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |?
         _selected.prefix(_tab.REF);
         {? _selected.first()=0
         || _selected.blank();
            _selected.REF:=_tab.REF;
            _selected.add()
         ?};
         _tab.next()
      !}
   ?}
?};
KS.cntx_pop();

_result


\KS_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu konta syntetycznych bieżącej firmy
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select KS.REFERENCE as REF, ROK_F.NAZ, KS.SYM, (\':\' || KS.IDADD || KS.REFERENCE) as UIDREF '
      'from KS join ROK_F where ROK_F.FIRMA=:_a order by NAZ,SYM',
      REF.FIRMA
   )
|| KS
?}


\KS_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowa nazwa roku');
_def.define('SYM','Symbol',1,,'6 znakowy symbol');
_def.define('NAZ','Nazwa',1,,'60 znakowa nazwa');
_def.define('WIELO','Wielowalutowe',1,,'1 znakowy T lub N');
_def.define('TYP','Typ konta',1,,'40 znakowa nazwa typu konta');
_def.define('SALDO','Charakter salda',1,,'40 znakowa nazwa charakteru salda');
_def.define('KS_ZEST','Zespół kont',1,,'20 znakowy kod zespołu');
_def.define('KS_KAT','Kategoria zespółu',1,,'20 znakowy kod kategorii zespołu');
_def.define('ROZR','Identyfikator rozrachunku',1,,'1 znakowy identyfikatior:\nR - obowiązkowy\nP - nieobowiązkowy\nZ - zabroniony');
_def.define('T_ROZ','Typ rozrachunku',1,,'3 znakowy typ');
_def.define('OBTYPROZ','Stały typ rozrachunku',1,,'1 znakowy T lub N\nCzy dopuszczalna jest zmiana typu rozrachunku',type_of(''));
_def.define('KRAG','Kontrola kręgu kosztowego',1,,'40 znakowa typu kontroli');
_def.define('SP','Split payment',1,,'1 znakowa T lub N');
_def.define('PROJEKT','Projekt',1,,'1 znakowa T lub N');
_def.define('MW','Magazyn walut',1,,'1 znakowa T lub N');
~~


\KS_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

_result:=1;
KS.prefix();
{? _tab=KS |  KS.seek(_tab.REF)
|| _table.ROK.VALUE:=KS.ROK().NAZ; _excel.write_async('ROK_F',KS.ROK);
   _table.SYM.VALUE:=KS.SYM;
   _table.NAZ.VALUE:=KS.NAZ;
   _table.WIELO.VALUE:=KS.WIELO;
   _table.TYP.VALUE:=exec('FindInSet','#table','WSK','RODZ',KS.TYP,'T',"WSK.TRESC",1);
   _table.SALDO.VALUE:=exec('FindInSet','#table','WSK','RODZ',KS.SALDO,'S',"WSK.TRESC",1);
   _table.KS_ZEST.VALUE:=KS.KS_ZEST().KOD; _excel.write_async('KS_ZEST',KS.KS_ZEST);
   _table.KS_KAT.VALUE:=KS.KS_KAT().KOD; _excel.write_async('KS_KAT',KS.KS_KAT);
   _table.ROZR.VALUE:=KS.ROZR;
   _table.T_ROZ.VALUE:=KS.T_ROZ;
   _table.OBTYPROZ.VALUE:={? KS.OBTYPROZ || 'T' || 'N' ?};
   _table.KRAG.VALUE:=exec('FindInSet','#table','WSK','RODZ',KS.KRAG,'G',"WSK.TRESC",1);
   _table.SP.VALUE:=KS.SP;
   _table.PROJEKT.VALUE:=KS.PROJEKT;
   _table.MW.VALUE:=KS.MW;

   BUD.cntx_psh();
   BUD.index('KS'); BUD.prefix(KS.ref());
   {? BUD.first()
   || {!
      |? _excel.write_async('BUD',BUD.ref());
         BUD.next()
      !}
   ?};
   BUD.cntx_pop();
   KS_W.cntx_psh();
   KS_W.index('LP'); KS_W.prefix(KS.ref());
   {? KS_W.first()
   || {!
      |? _excel.write_async('KS_W',KS_W.ref());
         KS_W.next()
      !}
   ?};
   KS_W.cntx_pop()
?};
_result


\KS_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_result:=_c;
_result.RESULT:=0;
{? _obj.ROK='' || _fld:='ROK'
|? _obj.SYM='' || _fld:='SYM'
|? _obj.NAZ='' || _fld:='NAZ'
|? _obj.WIELO='' || _fld:='WIELO'
|? _obj.TYP='' || _fld:='TYP'
|? _obj.SALDO='' || _fld:='SALDO'
|? _obj.ROZR='' || _fld:='ROZR'
|? _obj.OBTYPROZ='' || _fld:='OBTYPROZ'
|? _obj.ROZR='R' & _obj.T_ROZ='' & _obj.OBTYPROZ='T' || _fld:='T_ROZ'
|? _obj.SP='' || _fld:='SP'
|| _fld:=''
?};
{? _fld<>''
|| _result.msg_empty(_fld); return()
?};
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_obj.ROK,REF.FIRMA,,1))=null
|| _result.msg_empty('ROK');
   return()
|? KS.ROK:=_rok; KS.ROK().PLAN_GR='T'
|| _result.MSG:='Rok: %1 ma plan kont jak dla grupy kapitałowej.'@[_obj.ROK];
   return()
|? ROK_F.SYNT<>+_obj.SYM
|| _result.MSG:='Wymagana liczba znaków konta w roku: %1 wynosi: %2.'@[_obj.ROK,$ROK_F.SYNT];
   return()
|? 'TN'*_obj.WIELO=0
|| _result.msg_inset('WIELO','T','N');
   return()
|? 'RPZ'*_obj.ROZR=0
|| _result.msg_inset('ROZR','R','P','Z');
   return()
|? _obj.T_ROZ<>'' & ',NAL,NOD,ZOB,ZOD,RMK,RMP,INN,'*(','+_obj.T_ROZ+',')=0
|| _result.msg_inset('T_ROZ','NAL','NOD','ZOB','ZOD','RMK','RMP','INN');
   return()
|? 'TN'*_obj.OBTYPROZ=0
|| _result.msg_inset('OBTYPROZ','T','N');
   return()
|? 'TN'*_obj.SP=0
|| _result.msg_inset('SP','T','N');
   return()
?};
KS.index('SYM');
KS.prefix(_rok,_obj.SYM,);
{? KS.first()
|| {? _mode=0
   || return()
   || _result.ACTION:='put'
   ?}
|| _result.ACTION:='add'
?};
{? _result.ACTION='add' || KS.blank(1) ?};
KS.ROK:=_rok;
KS.SYM:=_obj.SYM;
KS.NAZ:=_obj.NAZ;
KS.WIELO:=_obj.WIELO;
KS.TYP:=exec('FindInSet','#table','WSK','TR',_obj.TYP,'T',"WSK.WART",1);
{? KS.TYP=''
|| _result.msg_norec('TYP'); return()
?};
KS.SALDO:=exec('FindInSet','#table','WSK','TR',_obj.SALDO,'S',"WSK.WART",1);
{? KS.SALDO=''
|| _result.msg_norec('SALDO'); return()
?};
KS.KS_ZEST:=exec('FindInSet','#table','KS_ZEST','KOD',_obj.KS_ZEST,,,1);
KS.KS_KAT:=exec('FindInSet','#table','KS_KAT','KOD',_obj.KS_KAT,KS.KS_ZEST,,1);
KS.ROZR:=_obj.ROZR;
KS.T_ROZ:=_obj.T_ROZ;
KS.OBTYPROZ:={? var_press('OBTYPROZ',_obj)=type_of('') & _obj.OBTYPROZ='T' || 1 ?};
KS.KRAG:=exec('FindInSet','#table','WSK','TR',_obj.KRAG,'G',"WSK.WART",1);
KS.SP:=_obj.SP;
KS.PROJEKT:=_obj.PROJEKT;
KS.MW:=_obj.MW;
_result.RESULT:=1;
{? exec('chk_ks','konto',_result.ACTION='add')<>''
|| _result.RESULT:=0
?};
~~


\KS_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=KS.add(1)
   |? _validate.ACTION='put'
   || _result:=KS.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie konta syntetycznego %1 do roku %2 nie powiodło się.'@[_obj.SYM,_obj.ROK]
   || _validate.MSG:='Poprawa konta syntetycznego %1 w roku %2 nie powiodła się.'@[_obj.OD,_obj.ROK]
   ?}
|? _validate.ACTION='add'
|| exec('dolkskom','!zws_par_fask')
?};
_result


\BUD
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='BUD';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Struktura kont analitycznych=1,1';
_def.NAME:='Struktura kont analitycznych';
_def.DESC:='Struktura kont analitycznych';

_def.PREFIX:="BUD.index('KS'); BUD.prefix()";
_def.TABLE:="exec('BUD_tab','xls_ks',_a)";
_def.TAB_IMP:="BUD";
_def.FIELDS:="exec('BUD_fld','xls_ks',_a)";

_def.BEFORE:="BUD.cntx_psh()";
_def.AFTER:="BUD.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('BUD_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('BUD_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('BUD_imp','xls_ks',_a,_b,_c)";
_def.SELECT:="exec('BUD_select','xls_ks',_a)";
~~


\BUD_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [18.42]
:: OPIS: Umożliwia wybór rekordów do eksportu
::   WE: _a - tab_tmp - tabela tymczasowa z polem REF którą należy zasilić
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik potwierdził wybór
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_selected:=_a;

_result:=0;

_tab:=tab_tmp(1,'ROK','STRING[20]','Rok'
   ,'REF','STRING[16]','SQL ref'
   ,'SELECTED','STRING[1]','Czy wybrano'
   ,'KS','STRING[6]','Konto'
   ,'POZ','INTEGER','Poziom analityki');

_ndx:=_tab.ndx_tmp(,,'SELECTED',,,'ROK',,);

BUD.cntx_psh();
BUD.index('KS');
BUD.prefix();
{? BUD.first()
|| {!
   |?
      _tab.blank();
      _tab.REF:=$BUD.ref();
      _selected.prefix($BUD.ref());
      {? _selected.first()
      || _tab.SELECTED:='T'
      || _tab.SELECTED:='N'
      ?};
      _tab.ROK:=BUD.KS().ROK().NAZ;
      _tab.KS:=BUD.KS().SYM;
      _tab.POZ:=BUD.POZ;
      _tab.add();
      BUD.next()
   !}
?};
_result:=exec('select_action','#table',_tab
 ,'ROK,KS,POZ',20,'Wybór definicja Intrastat do eksportu'@,1);
{? _result>0
||
   _selected.erase();

   _tab.index(_ndx);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |?
         _selected.prefix(_tab.REF);
         {? _selected.first()=0
         || _selected.blank();
            _selected.REF:=_tab.REF;
            _selected.add()
         ?};
         _tab.next()
      !}
   ?}
?};
BUD.cntx_pop();

_result


\BUD_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu struktury kont analitycznych bieżącej firmy
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select BUD.REFERENCE as REF, ROK_F.NAZ, KS.SYM, BUD.POZ, (\':\' || BUD.IDADD || BUD.REFERENCE) as UIDREF '
      'from BUD join KS join ROK_F '
      'where ROK_F.FIRMA=:_a '
      'order by NAZ,SYM,POZ',REF.FIRMA
   )
|| BUD
?}


\BUD_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowa nazwa roku');
_def.define('KS','Konto',1,,'6 znakowy symbol konta');
_def.define('POZ','Poziom analityki',1,,'Dodatni poziom analityki');
_def.define('SLU','Słownik',1,,'20 znakowy symbol słownika');
~~


\BUD_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

_result:=1;
BUD.prefix();
{? _tab=BUD | BUD.seek(_tab.REF)
|| _table.ROK.VALUE:=BUD.KS().ROK().NAZ; _excel.write_async('ROK_F',ROK_F.ref());
   _table.KS.VALUE:=BUD.KS().SYM;
   _table.POZ.VALUE:=BUD.POZ;
   _table.SLU.VALUE:=BUD.SLU().SLU().NAZ;
   _excel.write_async('SLU',SLU.ref())
?};
_result


\BUD_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=0;
_obj.POZ:=_obj.POZ$0;
{? _obj.ROK='' || _fld:='ROK'
|? _obj.KS='' || _fld:='KS'
|| _fld:=''
?};
{? _fld<>''
|| _result.msg_empty(_fld); return()
?};
{? _obj.POZ<=0
|| _result.MSG:='Poziom analityki powinien być większy od 0.'@;
   return()
|? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_obj.ROK,REF.FIRMA,,1))=null
|| _result.msg_norec('ROK');
   return()
|? (_ks:=exec('FindInSet','#table','KS','SYM',_obj.KS,_rok,,1))=null
|| _result.MSG:='Nie znaleziono konta %1 w roku: %2.'@[_obj.KS,_obj.ROK];
   return()
|? (_slu:=exec('FindInSet','#table','SLUAPPL','NAZ',_obj.SLU,'F',,1))=null
|| _result.msg_norec('SLU');
   return()
?};
BUD.index('KS');
{? _obj.POZ>1
|| BUD.prefix(_ks,_obj.POZ-1);
   {? ~BUD.first()
   || _result.MSG:='Brak analityki konta %1 w roku %2 na poziomie: %3.'@[_obj.KS,_obj.ROK,$(_obj.POZ-1)];
      return()
   ?}
?};
BUD.prefix(_ks,_obj.POZ);
{? BUD.first()
|| {? _mode=0
   || return()
   || _result.ACTION:='put'
   ?}
|| _result.ACTION:='add'
?};
_result.RESULT:=1;
{? _result.ACTION='add' || BUD.blank(1) ?};
BUD.KS:=_ks;
BUD.POZ:=_obj.POZ;
BUD.SLU:=_slu;
~~


\BUD_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| BUD.KS();
   {? KS.r_lock(1,1,1)
   || BUD.index('KS');
      {? _validate.ACTION='add'
      || BUD.prefix(BUD.KS);
         {? BUD.size()=10
         || _validate.MSG:='Może być zdefiniowane 10 poziomów analityki.'@;
            _validate.RESULT:=0
         ?}
      ?};
      {? _validate.RESULT=1
      || _dl:=exec('dl_analit','konto',BUD.KS,{? _validate.ACTION='put' || BUD.POZ || ~~ ?});
         _dl+=BUD.SLU().SLU().DL;
         {? _dl>35
         || _validate.MSG:='Długość konta: %1. Dozwolona długość to 35 znaków.'@[$_dl];
            _validate.RESULT:=0
         ?}
      ?};
      {? _validate.RESULT=1 & _validate.ACTION='put' & (_txt:=exec('spr_bud','konto',1))<>''
      || _validate.MSG:=_txt;
         _validate.RESULT:=0
      ?};
      {? _validate.RESULT=1
      || {? _validate.ACTION='add'
         || _result:=BUD.add(1)
         |? _validate.ACTION='put'
         || _result:=BUD.put(1)
         ?}
      ?};
      KS.r_unlock()
   ?}
?};
{? _validate.RESULT=1 & _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie analityki konta: %1 nie powiodło się.'@[_obj.KS]
   || _validate.MSG:='Poprawa analityki konta: %1 nie powiodła się.'@[_obj.KS]
   ?}
?};
_result


\KS_W
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='KS_W';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Wyróżniki konta=1,1';
_def.NAME:='Wyróżniki konta';
_def.DESC:='Wyróżniki konta';

_def.PREFIX:="KS_W.index('LP'); KS_W.prefix()";
_def.TABLE:="exec('KS_W_tab','xls_ks',_a)";
_def.TAB_IMP:="KS_W";
_def.FIELDS:="exec('KS_W_fld','xls_ks',_a)";

_def.BEFORE:="KS_W.cntx_psh()";
_def.AFTER:="KS_W.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('KS_W_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('KS_W_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('KS_W_imp','xls_ks',_a,_b,_c)";
~~


\KS_W_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowa nazwa roku');
_def.define('S','Konto syntetyczne',1,,'6 znakowe konto syntetyczne');
_def.define('LP','Lp.',1,,'Liczba porządkowa w obrębie konta syntetycznego');
_def.define('SLU','Słownik',1,,'20 znakowa nazwa słownik wyróżnika');
_def.define('AN','Sposób wypełnienia',1,,
   '1 znakowy znacznik sposobu wypełnienia:\n'
   'S - wypełnienie wartością domyślną\n'
   'T - z analityki konta\n'
   'N - przez użytkownika'
);
_def.define('ST','Wartość stała',1,,'8 znakowy kod pozycji słownika wyróznika (wartość stałą)');
_def.define('WYM','Wymagany',1,,'1 znakowy znacznik czy wymagane wypełnienie wyróżnika przy deklaracji: T-tak, N-nie');
_def.define('ROZDZ','Rozdzielnik',1,,'1 znakowy znacznik czy stosować rozdzielnik dla wyróżnika: T-tak, N-nie');
_def.define('DO_BO','Na następny rok',1,,'1 znakowy znacznik, czy przenieść wyróżnik na następny rok: T-tak, N-nie');
~~

\KS_W_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu struktury kont analitycznych bieżącej firmy
::   WE: _a - tryb pracy: 1-eksport wszystkiego, 2-eksport jednego rekordu
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select KS_W.REFERENCE as REF, ROK_F.NAZ as ROK, KS.SYM as KS, KS_W.LP, (\':\' || KS_W.IDADD || KS_W.REFERENCE) as UIDREF '
      'from KS_W join KS join ROK_F '
      'where ROK_F.FIRMA=:_a '
      'order by ROK,KS,LP',
      REF.FIRMA
   )
|| KS_W
?}


\KS_W_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

_result:=0;
{? _tab=KS_W | KS_W.seek(_tab.REF)
|| _table.ROK.VALUE:=KS_W.S().ROK().NAZ;
   _table.S.VALUE:=KS_W.S().SYM;
   _table.LP.VALUE:=KS_W.LP;
   _table.SLU.VALUE:=KS_W.SLU().SLU().NAZ; _excel.write_async('SLU',SLU.ref());
   _table.AN.VALUE:=KS_W.AN;
   _table.ST.VALUE:=KS_W.ST().KOD;         {? KS_W.ST || _excel.write_async('SLO',SLO.ref()) ?};
   _table.WYM.VALUE:=KS_W.WYM;
   _table.ROZDZ.VALUE:=KS_W.ROZDZ;
   _table.DO_BO.VALUE:=KS_W.DO_BO;
   _result:=1
?};
_result


\KS_W_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=0;
{? _table.ROK='' || _fld:='ROK'
|? _table.S='' || _fld:='S'
|? _table.SLU='' || _fld:='SLU'
|? _table.AN='' || _fld:='AN'
|? _table.WYM='' || _fld:='WYM'
|? _table.AN='S' & _table.ST='' || _fld:='ST'
|| _fld:=''
?};
{? _fld<>'' || _result.msg_empty(_fld); return() ?};
{? _table.ROZDZ='' || _table.ROZDZ:='N' ?};
{? _table.DO_BO='' || _table.DO_BO:='N' ?};
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_table.ROK,REF.FIRMA,,1))=null
|| _result.msg_empty('ROK'); return()
|? ROK_F.SYNT<>+_table.S
|| _result.MSG:='Wymagana liczba znaków konta w roku: %1 wynosi: %2.'@[_table.ROK,$ROK_F.SYNT]; return()
|? (_ks:=exec('FindInSet','#table','KS','SYM',_table.S,_rok,,1))=null
|| _result.msg_norec('S'); return()
?};
KS_W.index('LP');
KS_W.prefix(_ks,_table.LP);
{? KS_W.first()
|| {? _mode=0
   || return()
   || _result.ACTION:='put'
   ?}
|| _result.ACTION:='add'
?};
{? _table.LP>1
|| KS_W.cntx_psh();
   KS_W.prefix(_ks,_table.LP-1);
   _brak:=~KS_W.first();
   KS_W.cntx_pop();
   {? _brak
   || _result.MSG:='Brak poprzedniego wyróżnika o numerze: %1'@[$(_table.LP-1)]; return()
   ?}
?};
{? KS.ROK:=_rok; KS.ROK().PLAN_GR='T'
|| _result.MSG:='Rok: %1 ma plan kont jak dla grupy kapitałowej.'@[_table.ROK]; return()
|? (_slu:=exec('FindInSet','#table','SLU','NAZ',_table.SLU,,,1))=null
|| _result.msg_norec('SLU'); return()
|? (_sluappl:=exec('FindInSet','#table','SLUAPPL','NAZ',_table.SLU,'F',,1))=null
|| _result.msg_norec('SLU'); return()
|? _table.ST<>'' & (_slo:=exec('find_slo_slu','slo_slu',_slu,_table.ST))=null
|| _result.msg_norec('ST'); return()
|? 'STN'*_table.AN=0
|| _result.msg_inset('AN','S','T','N'); return()
|? 'TN'*_table.WYM=0
|| _result.msg_inset('WYM','T','N'); return()
|? 'TN'*_table.ROZDZ=0
|| _result.msg_inset('ROZDZ','T','N'); return()
|? 'TN'*_table.DO_BO=0
|| _result.msg_inset('DO_BO','T','N'); return()
?};
{? _result.ACTION='add' || KS_W.blank() ?};
KS_W.S:=_ks;
KS_W.LP:=_table.LP;
KS_W.SLU:=_sluappl;
KS_W.AN:=_table.AN;
KS_W.WYM:=_table.WYM;
KS_W.ST:={? _table.ST<>'' || _slo || null ?};
KS_W.ROZDZ:=_table.ROZDZ;
KS_W.DO_BO:=_table.DO_BO;
SLOSLU.SLU_WYR:=_table.SLU;
KS_W.S();
{? exec('chk_ksw','wyrozniki')=''
|| _result.RESULT:=1
?};
~~


\KS_W_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=KS_W.add(1)
   |? _validate.ACTION='put'
   || _result:=KS_W.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie KS_W %1 nie powiodło się.'[_table.OD]
   || _validate.MSG:='Poprawa KS_W %1 nie powiodła się.'[_table.OD]
   ?}
?};
_result


\AN_BO
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='AN_BO';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.FILE:=exec('filename','xls_ks');
_def.SHEET:='Reguły przekształcenia kont=1,1';
_def.NAME:='Reguły przekształcenia kont';
_def.DESC:='Reguły przekształcenia kont';

_def.PREFIX:="";
_def.TABLE:="exec('AN_BO_tab','xls_ks',_a)";
_def.TAB_IMP:="AN_BO";
_def.FIELDS:="exec('AN_BO_fld','xls_ks',_a)";

_def.BEFORE:="AN_BO.cntx_psh()";
_def.AFTER:="AN_BO.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('AN_BO_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('AN_BO_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('AN_BO_imp','xls_ks',_a,_b,_c)";
_def.SELECT:="exec('AN_BO_select','xls_ks',_a)";
~~


\AN_BO_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [18.42]
:: OPIS: Umożliwia wybór rekordów do eksportu
::   WE: _a - tab_tmp - tabela tymczasowa z polem REF którą należy zasilić
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik potwierdził wybór
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_selected:=_a;

_result:=0;
_tab:=tab_tmp(3,
   'ROK','STRING[20]','Rok',
   'PKON','STRING[35]','Konto "stare"',
   'KON','STRING[35]','Konto "nowe"',
   'REF','STRING[16]','SQL ref',
   'SELECTED','STRING[1]','Czy wybrano'
);

_ndx:=_tab.ndx_tmp(,,'SELECTED',,,'ROK',,);

AN_BO.cntx_psh();
AN_BO.index('ROK');
AN_BO.prefix();
{? AN_BO.first()
|| {!
   |? _tab.blank();
      _tab.REF:=$AN_BO.ref();
      _selected.prefix($AN_BO.ref());
      {? _selected.first()
      || _tab.SELECTED:='T'
      || _tab.SELECTED:='N'
      ?};
      _tab.ROK:=AN_BO.ROK().NAZ;
      _tab.PKON:=AN_BO.PKON;
      _tab.KON:=AN_BO.KON;
      _tab.add();
      AN_BO.next()
   !}
?};
_result:=exec('select_action','#table',_tab
 ,'ROK[5],PKON[35],KON[35]',20,'Wybór reguł przekształcenia kont do eksportu'@,1);
{? _result>0
||
   _selected.erase();

   _tab.index(_ndx);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |?
         _selected.prefix(_tab.REF);
         {? _selected.first()=0
         || _selected.blank();
            _selected.REF:=_tab.REF;
            _selected.add()
         ?};
         _tab.next()
      !}
   ?}
?};
AN_BO.cntx_pop();

_result


\AN_BO_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu reguł przekształceń kont analitycznych bieżącej firmy
::----------------------------------------------------------------------------------------------------------------------
sql(
   'select ROK_F.NAZ as ROK, AN_BO.PKON,AN_BO.KON, AN_BO.REFERENCE as REF, '
   '(\':\' || AN_BO.IDADD || AN_BO.REFERENCE) as UIDREF '
   'from AN_BO join ROK_F where ROK_F.FIRMA=:_a',
   REF.FIRMA
)


\AN_BO_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowa nazwa roku');
_def.define('PKON','Konto "stare"',1,,'35 znakowa maska konta starego');
_def.define('KON','Konto "nowe"',1,,'35 znakowa maska konta nowego');
~~


\AN_BO_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

_result:=1;
_table.ROK.VALUE:=_tab.ROK;
_table.PKON.VALUE:=_tab.PKON;
_table.KON.VALUE:=_tab.KON;
_result


\AN_BO_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=1;
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_obj.ROK,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono roku o nazwie: %1.'@[_obj.ROK];
   _result.RESULT:=0
|| AN_BO.index('ROK');
   AN_BO.prefix(_rok,_obj.PKON,);
   {? AN_BO.first()
   || {? _mode=0
      || _result.RESULT:=0
      || _result.ACTION:='put'
      ?}
   || _result.ACTION:='add'
   ?};
   {? _result.RESULT=1
   || {? _result.ACTION='add' || AN_BO.blank(1) ?};
      AN_BO.ROK:=_rok;
      AN_BO.PKON:=_obj.PKON;
      AN_BO.KON:=_obj.KON;
      {? exec('chk_anbo','konto',_result.ACTION='put')=0
      || _result.RESULT:=0
      ?}
   ?}
?};
~~


\AN_BO_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=AN_BO.add(1)
   |? _validate.ACTION='put'
   || _result:=AN_BO.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie reguły przekształcenia kont z %1 na %2 w roku %3 nie powiodło się.'@[_obj.PKON,_obj.KON,_obj.ROK]
   || _validate.MSG:='Poprawa reguły przekształcenia kont nie powiodła się.'
   ?}
?};
_result


\REJ
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='REJ';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.FILE:=exec('filename','xls_ks');
_def.SHEET:='Rejestry księgowe=1,1';
_def.NAME:='Rejestry księgowe';
_def.DESC:='Rejestry księgowe';

::_def.PREFIX:="REJ.index('FIRMA'); REJ.prefix(REF.FIRMA)";
_def.PREFIX:="REJ.index('KOD'); REJ.prefix()";
_def.TABLE:="exec('REJ_tab','xls_ks',_a)";
_def.TAB_IMP:="REJ";
_def.FIELDS:="exec('REJ_fld','xls_ks',_a)";

_def.BEFORE:="REJ.cntx_psh()";
_def.AFTER:="REJ.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('REJ_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('REJ_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('REJ_imp','xls_ks',_a,_b,_c)";
_def.SELECT:="exec('REJ_select','xls_ks',_a)";
~~


\REJ_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [18.42]
:: OPIS: Umożliwia wybór rekordów do eksportu
::   WE: _a - tab_tmp - tabela tymczasowa z polem REF którą należy zasilić
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik potwierdził wybór
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_selected:=_a;

_result:=0;

_tab:=tab_tmp(1,
   'ROK','STRING[20]','Rok',
   'ODD','STRING[8]','Jednostka księgowa',
   'KOD','STRING[8]','Symbol',
   'REF','STRING[16]','SQL ref',
   'SELECTED','STRING[1]','Czy wybrano',
   'NAZ','STRING[60]','Nazwa'
);

_ndx:=_tab.ndx_tmp(,,'SELECTED',,,'KOD',,);

REJ.cntx_psh();
REJ.index('KOD');
REJ.prefix();
{? REJ.first()
|| {!
   |? {? 1+REJ.KOD<>'~' & REJ.ROK().FIRMA=REF.FIRMA
      || _tab.blank();
         _tab.REF:=$REJ.ref();
         _selected.prefix($REJ.ref());
         {? _selected.first()
         || _tab.SELECTED:='T'
         || _tab.SELECTED:='N'
         ?};
         _tab.ROK:=REJ.ROK().NAZ;
         _tab.ODD:=REJ.ODD().OD;
         _tab.KOD:=REJ.KOD;
         _tab.NAZ:=REJ.NAZ;
         _tab.add()
      ?};
      REJ.next()
   !}
?};
_result:=exec('select_action','#table',_tab,
   'ROK[4],ODD[8],KOD[8],NAZ[60]',20,'Wybór rejestrów księgowych do eksportu'@,1
);
{? _result>0
||
   _selected.erase();

   _tab.index(_ndx);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |?
         _selected.prefix(_tab.REF);
         {? _selected.first()=0
         || _selected.blank();
            _selected.REF:=_tab.REF;
            _selected.add()
         ?};
         _tab.next()
      !}
   ?}
?};
REJ.cntx_pop();

_result


\REJ_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu struktury rejestrów dokumentów źródłowych bieżącej firmy
::   WE: _a - tryb pracy: 1-eksport wszystkiego, 2-eksport jednego rekordu
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select REJ.REFERENCE as REF, ROK_F.NAZ as ROK, ODD.OD as ODD, (\':\' || REJ.IDADD || REJ.REFERENCE) as UIDREF '
      'from REJ join ROK_F join ODD '
      'where ROK_F.FIRMA=:_a'
      'order by ROK, ODD',
      REF.FIRMA
   )
|| REJ
?}


\REJ_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','ROK',1,,'20 znakowa nazwa roku');
_def.define('ODD','Jednostka księgowa',1,,'8 znakowy symbol jednostki księgowej');
_def.define('KOD','Symbol',1,,'8 znakowy symbol rejestru');
_def.define('NAZ','Nazwa',1,,'60 znakowa nazwa rejestru');
_def.define('WAL','Walutowy',1,,'1 znakowy T lub N');
_def.define('DZ','Dokument zbiorczy',1,,'1 znakowy T lub N');
~~


\REJ_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

{? (_tab=REJ | REJ.seek(_tab.REF)) & 1+REJ.KOD<>'~'
|| _table.ROK.VALUE:=REJ.ROK().NAZ; _excel.write_async('ROK_F',ROK_F.ref());
   _table.ODD.VALUE:=REJ.ODD().OD; _excel.write_async('ODD',REJ.ODD);
   _table.KOD.VALUE:=REJ.KOD;
   _table.NAZ.VALUE:=REJ.NAZ;
   _table.WAL.VALUE:=REJ.WAL;
   _table.DZ.VALUE:=REJ.CZY_DZ;

   DOK_REJ.cntx_psh();
   DOK_REJ.index('NAZ'); DOK_REJ.prefix(REJ.ref());
   {? DOK_REJ.first()
   || {!
      |? _excel.write_async('DOK_REJ',DOK_REJ.ref());
         DOK_REJ.next()
      !}
   ?};
   DOK_REJ.cntx_pop();
   VAT_REJ.cntx_psh();
   VAT_REJ.index('REJ_SYM'); VAT_REJ.prefix(REJ.ref());
   {? VAT_REJ.first()
   || {!
      |? _excel.write_async('VAT_REJ',VAT_REJ.ref());
         VAT_REJ.next()
      !}
   ?};
   VAT_REJ.cntx_pop();
   GR_VAT.cntx_psh();
   GR_VAT.index('REJ_KOD'); GR_VAT.prefix(REJ.ref());
   {? GR_VAT.first()
   || {!
      |? _excel.write_async('GR_VAT',GR_VAT.ref());
         GR_VAT.next()
      !}
   ?};
   GR_VAT.cntx_pop();
   P_AUTOKS.cntx_psh();
   P_AUTOKS.index('RDA'); P_AUTOKS.prefix(REJ.ref());
   {? P_AUTOKS.first()
   || {!
      |? _excel.write_async('P_AUTOKS',P_AUTOKS.ref());
         P_AUTOKS.next()
      !}
   ?};
   P_AUTOKS.cntx_pop();
   FOR_AKC.cntx_psh();
   FOR_AKC.index('NAZ'); FOR_AKC.prefix(REJ.ref());
   {? FOR_AKC.first()
   || {!
      |? _excel.write_async('FOR_AKC',FOR_AKC.ref());
         FOR_AKC.next()
      !}
   ?};
   FOR_AKC.cntx_pop();
   _result:=1
|| _result:=0
?};
_result


\REJ_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=0;
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_obj.ROK,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono roku o nazwie: %1.'@[_obj.ROK]
|? (_odd:=exec('FindInSet','#table','ODD','ODDZIALY',_obj.ODD,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono jednostki księgowej o skrócie: %1.'@[_obj.ODD]
|| _result.RESULT:=1;
   REJ.index('KOD');
   REJ.prefix(_rok,_odd,_obj.KOD,);
   {? REJ.first()
   || {? _mode=0
      || _result.RESULT:=0
      || _result.ACTION:='put'
      ?}
   || _result.ACTION:='add'
   ?};
   {? _result.RESULT=1
   || {? _result.ACTION='add' || REJ.blank(1) ?};
      REJ.ROK:=_rok;
      REJ.ODD:=_odd;
      REJ.KOD:=_obj.KOD;
      REJ.NAZ:=_obj.NAZ;
      REJ.WAL:=_obj.WAL;
      REJ.CZY_DZ:=_obj.DZ;
      {? exec('chk_rej','rejestry',_result.ACTION='put')<>''
      || _result.RESULT:=0
      ?}
   ?}
?};
~~


\REJ_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=REJ.add(1)
   |? _validate.ACTION='put'
   || _result:=REJ.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie rejestru księgowego: %1 do roku: %2 i jednostki księgoerj: %3 nie powiodło się.'@[_obj.KOD,_obj.ROK,_obj.ODD]
   || _validate.MSG:='Poprawa rejestru księgowego %1 nie powiodła się.'@[_obj.KOD]
   ?}
?};
_result


\AV
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='AV';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.FILE:=exec('filename','xls_ks');
_def.SHEET:='Schematy VAT=1,1';
_def.NAME:='Schematy VAT';
_def.DESC:='Schematy VAT';

_def.PREFIX:="";
_def.TABLE:="exec('AV_tab','xls_ks',_a)";
_def.TAB_IMP:="AV";
_def.FIELDS:="exec('AV_fld','xls_ks',_a)";

_def.BEFORE:="AV.cntx_psh()";
_def.AFTER:="AV.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('AV_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('AV_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('AV_imp','xls_ks',_a,_b,_c)";
_def.SELECT:="exec('AV_select','xls_ks',_a)";
~~


\AV_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [18.42]
:: OPIS: Umożliwia wybór rekordów do eksportu
::   WE: _a - tab_tmp - tabela tymczasowa z polem REF którą należy zasilić
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik potwierdził wybór
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_selected:=_a;

_result:=0;

_tab:=tab_tmp(2,
   'ROK','STRING[20]','Rok',
   'KOD','STRING[3]','Kod',
   'OP','STRING[40]','Opis',
   'REF','STRING[16]','SQL ref',
   'SELECTED','STRING[1]','Czy wybrano'
);

_ndx:=_tab.ndx_tmp(,,'SELECTED',,,'ROK',,,'KOD',,);

AV.cntx_psh();
AV.index('AV');
AV.prefix();
{? AV.first()
|| {!
   |?
      _tab.blank();
      _tab.REF:=$AV.ref();
      _selected.prefix($AV.ref());
      {? _selected.first()
      || _tab.SELECTED:='T'
      || _tab.SELECTED:='N'
      ?};
      _tab.ROK:=AV.ROK_F().NAZ;
      _tab.KOD:=AV.KOD;
      _tab.OP:=AV.OP;
      _tab.add();
      AV.next()
   !}
?};
_result:=exec('select_action','#table',_tab
 ,'ROK[5],KOD[4],OP[40]',20,'Wybór schematów VAT do eksportu'@,1);
{? _result>0
||
   _selected.erase();

   _tab.index(_ndx);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |?
         _selected.prefix(_tab.REF);
         {? _selected.first()=0
         || _selected.blank();
            _selected.REF:=_tab.REF;
            _selected.add()
         ?};
         _tab.next()
      !}
   ?}
?};
AV.cntx_pop();

_result


\AV_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu struktury kont analitycznych bieżącej firmy
::   WE: _a - tryb pracy: 1-eksport wszystkiego, 2-eksport jednego rekordu
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select AV.REFERENCE as REF, ROK_F.NAZ as ROK, (\':\' || AV.IDADD || AV.REFERENCE) as UIDREF '
      'from AV join ROK_F '
      'where ROK_F.FIRMA=:_a'
      'order by ROK',
      REF.FIRMA
   )
|| AV
?}


\AV_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowa nazwa roku');
_def.define('KOD','Kod',1,,'3 znakowy kod schematu VAT');
_def.define('OP','Opis',1,,'40 znakowy opis schematu VAT');
~~


\AV_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

_result:=0;
AV.prefix();
{? _tab=AV | AV.seek(_tab.REF)
|| _table.ROK.VALUE:=AV.ROK_F().NAZ; _excel.write_async('ROK_F',ROK_F.ref());
   _table.KOD.VALUE:=AV.KOD;
   _table.OP.VALUE:=AV.OP;

   DEK.cntx_psh();
   DEK.index('DEK'); DEK.prefix(AV.ref());
   {? DEK.first()
   || {!
      |? _excel.write_async('DEK',DEK.ref());
         DEK.next()
      !}
   ?};
   DEK.cntx_pop();
   _result:=1
?};
_result


\AV_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=0;
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_obj.ROK,REF.FIRMA,,1))=null
|| _result.msg_empty('ROK');
   return()
?};
AV.index('AV');
AV.prefix(_rok,_obj.KOD,);
{? AV.first()
|| {? _mode=0
   || return()
   || _result.ACTION:='put'
   ?}
|| _result.ACTION:='add'
?};
_result.RESULT:=1;
{? _result.ACTION='add'
|| AV.blank(1);
   AV.A:='N'
?};
AV.ROK_F:=_rok;
AV.KOD:=_obj.KOD;
AV.OP:=_obj.OP;
{? exec('chk_av','rejestry',_result.ACTION='put')<>''
|| _result.RESULT:=0
?};
~~


\AV_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=AV.add(1)
   |? _validate.ACTION='put'
   || _result:=AV.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie schematu VAT: %1 do roku %2 nie powiodło się.'@[_obj.KOD,_obj.ROK]
   || _validate.MSG:='Poprawa schematu VAT: %1 w roku: %2 nie powiodła się.'@[_obj.KOD,_obj.ROK]
   ?}
?};
_result


\DEK
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='DEK';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Pozycje schematu VAT=1,1';
_def.NAME:='Pozycje schematu VAT';
_def.DESC:='Pozycje schematu VAT';

_def.PREFIX:="";
_def.TABLE:="exec('DEK_tab','xls_ks',_a)";
_def.TAB_IMP:="DEK";
_def.FIELDS:="exec('DEK_fld','xls_ks',_a)";

_def.BEFORE:="DEK.cntx_psh()";
_def.AFTER:="DEK.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('DEK_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('DEK_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('DEK_imp','xls_ks',_a,_b,_c)";
_def.SELECT:="exec('DEK_select','xls_ks',_a)";
~~


\DEK_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [18.42]
:: OPIS: Umożliwia wybór rekordów do eksportu
::   WE: _a - tab_tmp - tabela tymczasowa z polem REF którą należy zasilić
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik potwierdził wybór
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_selected:=_a;

_result:=0;

_tab:=tab_tmp(1,'LP','INTEGER','Lp'
   ,'REF','STRING[16]','SQL ref'
   ,'SELECTED','STRING[1]','Czy wybrano'
   ,'RODZK','STRING[8]','Rodzaj kwoty'
   ,'AV','STRING[3]','Schemat VAT');

_ndx:=_tab.ndx_tmp(,,'SELECTED',,,'LP',,);

DEK.cntx_psh();
DEK.index('DEK');
DEK.prefix();
{? DEK.first()
|| {!
   |?
      _tab.blank();
      _tab.REF:=$DEK.ref();
      _selected.prefix($DEK.ref());
      {? _selected.first()
      || _tab.SELECTED:='T'
      || _tab.SELECTED:='N'
      ?};
      _tab.LP:=DEK.LP;
      _tab.RODZK:=DEK.RODZK().KOD;
      _tab.AV:=DEK.AV().KOD;
      _tab.add();
      DEK.next()
   !}
?};
_result:=exec('select_action','#table',_tab
 ,'LP,RODZK,AV',20,'Wybór pozycji schematu VAT do eksportu'@,1);
{? _result>0
||
   _selected.erase();

   _tab.index(_ndx);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |?
         _selected.prefix(_tab.REF);
         {? _selected.first()=0
         || _selected.blank();
            _selected.REF:=_tab.REF;
            _selected.add()
         ?};
         _tab.next()
      !}
   ?}
?};
DEK.cntx_pop();

_result


\DEK_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu struktury kont analitycznych bieżącej firmy
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select DEK.REFERENCE as REF, ROK_F.NAZ as ROK, AV.KOD as AV, DEK.LP, (\':\' || DEK.IDADD || DEK.REFERENCE) as UIDREF '
      'from DEK join AV join ROK_F '
      'where ROK_F.FIRMA=:_a'
      'order by ROK, AV, LP',
      REF.FIRMA
   )
|| DEK
?}


\DEK_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowa nazwa roku');
_def.define('AV','Schemat VAT',1,,'3 znakowy kod schematu VAT');
_def.define('LP','Lp',1,,'Liczba porządkowa');
_def.define('RODZK','Rodzaj kwoty',1,,'8 znakowy rodzaj kwoty');
_def.define('KONTO','Konto',1,,'35 znakowy symbol konta');
_def.define('STR','Strona',1,,'2 znakowa strona konta');
_def.define('WSP','Współczynnik',1,,'Współczynnik');
_def.define('OP','Opis',1,,'30 znakowy opis');
_def.define('OPTYM','Optymalizacja',1,,'1 znakowy T lub N');
_def.define('ID','Identyfikator rozrachunku',1,,'20 znakowy identyfikator rozrachunku');
_def.define('TID','Typ rozrachunku',1,,'80 znakowa formuła na typ rozrachunku');
_def.define('DO','Data otwarcia',1,,'80 znakowa formuła na datę otwarcia');
_def.define('TP','Termin płatności',1,,'80 znakowa formuła na termin płatności');
_def.define('ODD','Jednostka księgowa',1,,'80 znakowa formuła na jednostkę księgową');
_def.define('PROJEKT','Projekt',1,,'80 znakowa formuła na projekt');
_def.define('PR','Płatność ratalna',1,,'1 znakowy T lub N');

~~


\DEK_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();
_result:=0;
DEK.prefix();
{? _tab=DEK | DEK.seek(_tab.REF)
|| _table.ROK.VALUE:=DEK.AV().ROK_F().NAZ; _excel.write_async('ROK_F',ROK_F.ref());
   _table.AV.VALUE:=AV.KOD;
   _table.LP.VALUE:=DEK.LP;
   _table.RODZK.VALUE:=DEK.RODZK().KOD;
   _table.KONTO.VALUE:=DEK.KONTO;
   _table.STR.VALUE:=DEK.STR;
   _table.WSP.VALUE:=DEK.WSP;
   _table.OP.VALUE:=DEK.OP;
   _table.OPTYM.VALUE:=DEK.OPTYM;
   _table.ID.VALUE:=DEK.ID;
   _table.TID.VALUE:=DEK.TID;
   _table.DO.VALUE:=DEK.DO;
   _table.TP.VALUE:=DEK.TP;
   _table.ODD.VALUE:=DEK.ODD_ROZR;
   _table.PROJEKT.VALUE:=DEK.PROJEKT;
   _table.PR.VALUE:=DEK.PR;

   exec('SKID_WYR_exp_pom','xls_ks',_excel,'DEK',DEK.ref());
   _result:=1
?};
_result


\DEK_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_result:=_c;
_result.RESULT:=0;
_lp:=_obj.LP;
{? _obj.RODZK='' || _fld:='RODZK'
|| _fld:=''
?};
{? _fld<>''
|| _result.msg_empty(_fld); return()
?};
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_obj.ROK,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono roku: %1.'@[_obj.ROK]
|? (_av:=exec('FindInSet','#table','AV','AV',_obj.AV,_rok,,1))=null
|| _result.MSG:='Nie znaleziono schematu VAT: %1 w roku o nazwie: %2.'@[_obj.AV,_obj.ROK]
|? DEK.AV:=_av; DEK.AV().A='T'
|| _result.MSG:='Schematu VAT: %1 w roku: %2 jest zaakceptowany.'@[_obj.AV,_obj.ROK]
|? (_slo:=exec('find_slo_slu','slo_slu','~RODZAJE KWOT',_obj.RODZK))=null
|| _result.msg_norec('RODZK')
|| _result.RESULT:=1;
   DEK.index('DEK');
   DEK.prefix(_av,_lp);
   {? DEK.first()
   || {? _mode=0
      || _result.RESULT:=0
      || _result.ACTION:='put'
      ?}
   || _result.ACTION:='add'
   ?};
   {? _result.RESULT=1 & _result.ACTION='add' & _lp>1
   || DEK.cntx_psh();
      DEK.prefix(_av,_lp-1);
      {? ~DEK.first()
      || _result.MSG:='Brak pozycji schematu VAT: %1 w roku: %2 o numerze: %3.'@[_obj.AV,_obj.ROK,$(_lp-1)];
         _result.RESULT:=0
      ?};
      DEK.cntx_pop()
   ?};
   {? _result.RESULT=1
   || {? _result.ACTION='add' || DEK.blank(1) ?};
      DEK.AV:=_av;
      DEK.LP:=_lp;
      DEK.RODZK:=_slo;
      DEK.KONTO:=_obj.KONTO;
      DEK.STR:=_obj.STR;
      DEK.WSP:=_obj.WSP;
      DEK.OP:=_obj.OP;
      DEK.OPTYM:=_obj.OPTYM;
      DEK.ID:=_obj.ID;
      DEK.TID:=_obj.TID;
      DEK.DO:=_obj.DO;
      DEK.TP:=_obj.TP;
      DEK.ODD_ROZR:=_obj.ODD;
      DEK.PROJEKT:=_obj.PROJEKT;
      DEK.PR:=_obj.PR;
      {? exec('chk_dek','rejestry')<>''
      || _result.RESULT:=0
      ?}
   ?}
?};
~~


\DEK_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=DEK.add(1)
   |? _validate.ACTION='put'
   || _result:=DEK.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie pozycji schematu VAT %1 nie powiodło się.'@[$_obj.LP]
   || _validate.MSG:='Poprawa pozycji schematu VAT %1 nie powiodła się.'@[$_obj.LP]
   ?}
?};
_result


\DOK_REJ
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='DOK_REJ';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Rodzaje dokumentów księgowych=1,1';
_def.NAME:='Rodzaje dokumentów księgowych';
_def.DESC:='Rodzaje dokumentów księgowych';

_def.PREFIX:="";
_def.TABLE:="exec('DOK_REJ_tab','xls_ks',_a)";
_def.TAB_IMP:="DOK_REJ";
_def.FIELDS:="exec('DOK_REJ_fld','xls_ks',_a)";

_def.BEFORE:="DOK_REJ.cntx_psh()";
_def.AFTER:="DOK_REJ.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('DOK_REJ_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('DOK_REJ_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('DOK_REJ_imp','xls_ks',_a,_b,_c)";
_def.SELECT:="exec('DOK_REJ_select','xls_ks',_a)";
~~


\DOK_REJ_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [18.42]
:: OPIS: Umożliwia wybór rekordów do eksportu
::   WE: _a - tab_tmp - tabela tymczasowa z polem REF którą należy zasilić
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik potwierdził wybór
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_selected:=_a;

_result:=0;

_tab:=tab_tmp(1,'REJ','STRING[8]','Rejestr'
   ,'REF','STRING[16]','SQL ref'
   ,'SELECTED','STRING[1]','Czy wybrano'
   ,'NAZ','STRING[60]','Nazwa'
   ,'SLO','STRING[8]','Rodzaj dokumentu');

_ndx:=_tab.ndx_tmp(,,'SELECTED',,,'REJ',,);

DOK_REJ.cntx_psh();
DOK_REJ.index('NAZ');
DOK_REJ.prefix();
{? DOK_REJ.first()
|| {!
   |?
      _tab.blank();
      _tab.REF:=$DOK_REJ.ref();
      _selected.prefix($DOK_REJ.ref());
      {? _selected.first()
      || _tab.SELECTED:='T'
      || _tab.SELECTED:='N'
      ?};
      _tab.REJ:=DOK_REJ.REJ().KOD;
      _tab.NAZ:=DOK_REJ.NAZ;
      _tab.SLO:=DOK_REJ.SLO().KOD;
      _tab.add();
      DOK_REJ.next()
   !}
?};
_result:=exec('select_action','#table',_tab
 ,'REJ,NAZ,SLO',20,'Wybór rodzajów dokumentów księgowych do eksportu'@,1);
{? _result>0
||
   _selected.erase();

   _tab.index(_ndx);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |?
         _selected.prefix(_tab.REF);
         {? _selected.first()=0
         || _selected.blank();
            _selected.REF:=_tab.REF;
            _selected.add()
         ?};
         _tab.next()
      !}
   ?}
?};
DOK_REJ.cntx_pop();

_result


\DOK_REJ_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu struktury kont analitycznych bieżącej firmy
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select DOK_REJ.REFERENCE as REF, DOK_REJ.NAZ, ROK_F.NAZ as ROK, ODD.OD as ODD, REJ.KOD as REJ, '
      '(\':\' || DOK_REJ.IDADD || DOK_REJ.REFERENCE) as UIDREF '
      'from DOK_REJ join REJ join ODD join ROK_F '
      'where ROK_F.FIRMA=:_a '
      'order by ROK,ODD,REJ',
      REF.FIRMA
   )
|| DOK_REJ
?}


\DOK_REJ_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowa nazwa roku');
_def.define('ODD','Jednostka księgowa',1,,'8 znakowy symbol jednostki');
_def.define('REJ','Rejestr',1,,'8 znakowy symbol rejestru');
_def.define('NAZ','Nazwa',1,,'60 znakowa nazwa dokumentu');
_def.define('SLO','Rodzaj dokumentu',1,,'8 znakowy rodzaj dokumentu');
_def.define('AV','Schemat VAT',1,,'3 znakowy schemat VAT');
_def.define('DODSLU','Dodatkowy słownik',1,,'20 znakowa nazwa słownika');
_def.define('FORM_SYM','Formuła na symbol',1,,'255 znakowa formuła na symbol');
_def.define('AN','Konto',1,,'35 znakowy symbol konta');
_def.define('POCH','Źródło pochodzenia',1,,'20 znakowa nazwa słownika');
_def.define('ZM_POCH','Zmieniać źródło',1,,'1 znakowy T lub N');
_def.define('DM','Domyślny rodzaj',1,,'1 znakowy T lub N');
_def.define('POW','Dokumenty powiązane',1,,'1 znakowy T lub N');
_def.define('KOR','Korekta',1,,'1 znakowy T lub N');
_def.define('ODD_ROZR','Wybór jednostki dla rozrachunku',1,,'1 znakowy T lub N');
_def.define('PR','Płatność ratalna',1,,'1 znakowy T lub N');
_def.define('CZY_ROZL','Dostępna data rozliczenia rozrachunku',1,,'1 znakowy T lub N');
_def.define('ZAPL','Zapłata (przelew)',1,,'1 znakowy T lub N');
_def.define('M_ODD','Dla wielu jednostek księgowych',1,,'1 znakowy T lub N');
_def.define('CZY_RRB','Redakcja rachunku bankowego na dokumencie prostym',1,,'1 znakowy T lub N');
_def.define('CZY_DKB','Dostępna kwota brutto na dokumencie prostym',1,,'1 znakowy T lub N');
_def.define('EDSYMZEW','Redakcja symbolu zewnętrznego na dokumencie prostym',1,,'1 znakowy T lub N');
_def.define('ZAK_SR','Zakup środków trwałych',1,,'1 znakowy T lub N');
_def.define('SP_PRZEL','Split payment - wyciąg',1,,'1 znakowy T lub N');
_def.define('SKID_MB','Domyślny model',1,,'8 znakowy kod modelu');
_def.define('JPK_TYP','Typ JPK',1,,'1 znakowy W-JPK_WB, F-JPK_FA, M-JPK_MAG, \'\'-brak');
_def.define('JPK_RB','Rachunek bankowy JPK_WB',1,,'50 znakowy rachunek bankwy');
_def.define('JPK_AN','konto księgowe związane z JPK_WB',1,,'35 znakowy symbol konta');
_def.define('TYP_CENY','Typ ceny',1,,'1 znakowy N-Netto, B-Brutto');
_def.define('JPK_FA_T','Rodzaj JPK_FA',1,,'1 znakowy S-sprzedaż, Z-Zakup');
_def.define('JPK_FA_R','Typ JPK_FA',1,,'1 znakowy W-VAT, K-Korekta, Z-Zaliczka, P-Pozostałe');
_def.define('TYP_MAG','Typ JPK_MAG',1,,'2 znakowy PZ, RW, WZ, MM');
_def.define('JPK_FA_P','Rejestrowanie pozycji faktury',1,,'1 znakowy T lub N');
_def.define('KOR_NAG','Korekta nagłowkowa',1,,'1 znakowy T lub N');
_def.define('RK','Różnice kursowe',1,,'1 znakowy T lub N');
_def.define('CZY_DP','Termin płatności dla dokumentu prostego',1,,'1 znakowy T-Wymagany, O-Opcjonalny, N-Brak');
_def.define('VPOZ_D','Redakcja daty sprzedaży w pozycjach VAT',1,,'1 znakowy T lub N');
_def.define('PUDEK','Pusty dekret',1,,'1 znakowy T-Wymagany, O-Opcjonalny, N-Brak');
_def.define('WEW','Operacja wewnątrz grupy VAT',1,,'1 znakowy T lub N');
_def.define('JPK_EGTU','Czy edytować GTU w pozycjach dokumentu księgowego',1,,'1 znakowy T lub N');
_def.define('JPK_EPRO','Edycja szczególnych procedur transakcji',1,,'1 znakowy T lub N');
_def.define('JPK_V_T','Typ dokumentu VAT',1,,'Maksymalnie 20 znakowy kod typu dokumentu VAT');
_def.define('WARWKR','Wartość walutowa w obrocie krajowym',1,,'Liczbowy 0 - Brutto, 1 - Netto',type_of(1),0);
_def.define('SP_WYM','Split payment - wymagany',1,,'1 znakowy T lub N');
_def.define('JPK_ETYP','Edycja typu dokumentu',1,,'1 znakowy T lub N');
_def.define('KSRF','Rodzaj faktury KSeF',1,,'Liczbowy 0 - Nie dotyczy, 1 - Faktura podstawowa, 2 - Korygująca, 3 - Zaliczkowa, 4 - Rozliczenie zaliczki, 5 - Uproszczona, 6 - Korekta zaliczki, 7 - Korekta rozliczenia',type_of(1),0);
_def.define('KSEF','Dokument KSeF',1,,'1 znakowy T lub N');
{? var_pres('KSEF_BC',DOK_REJ)>0
|| _def.define('KSEF_BC','Zakres kontroli Businesscheck',1,,'Liczbowy 0 - Brak, 1 - Kontrola, przy braku błędów wysyłka do KSeF, 2 - Kontrola, bez wysyłki do KSeF',type_of(1),0)
?};
~~


\DOK_REJ_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

_result:=0;
DOK_REJ.prefix();
{? _tab=DOK_REJ | DOK_REJ.seek(_tab.REF)
|| _table.ROK.VALUE:=DOK_REJ.REJ().ROK().NAZ; _excel.write_async('ROK_F',ROK_F.ref());
   _table.ODD.VALUE:=DOK_REJ.REJ().ODD().OD; _excel.write_async('ODD',ODD.ref());
   _table.REJ.VALUE:=DOK_REJ.REJ().KOD;
   _table.NAZ.VALUE:=DOK_REJ.NAZ;
   _table.SLO.VALUE:=DOK_REJ.SLO().KOD; _excel.write_async('SLO',SLO.ref());
   _table.AV.VALUE:=DOK_REJ.AV().KOD; {? DOK_REJ.AV || _excel.write_async('AV',DOK_REJ.AV) ?};
   _table.DODSLU.VALUE:=DOK_REJ.DODSLU().NAZ; {? DOK_REJ.DODSLU || _excel.write_async('SLU',DOK_REJ.DODSLU) ?};
   _table.FORM_SYM.VALUE:=DOK_REJ.FORM_SYM;
   _table.AN.VALUE:=DOK_REJ.AN;
   _table.POCH.VALUE:=DOK_REJ.POCH().SLU().NAZ; {? DOK_REJ.POCH || _excel.write_async('SLU',DOK_REJ.POCH().SLU) ?};
   _table.ZM_POCH.VALUE:=DOK_REJ.ZM_POCH;
   _table.DM.VALUE:=DOK_REJ.DM;
   _table.POW.VALUE:=DOK_REJ.POW;
   _table.KOR.VALUE:=DOK_REJ.KOR;
   _table.ODD_ROZR.VALUE:=DOK_REJ.ODD_ROZR;
   _table.PR.VALUE:=DOK_REJ.CZY_ROZL;
   _table.ZAPL.VALUE:=DOK_REJ.ZAPL;
   _table.M_ODD.VALUE:=DOK_REJ.M_ODD;
   _table.CZY_RRB.VALUE:=DOK_REJ.CZY_DKB;
   _table.EDSYMZEW.VALUE:=DOK_REJ.EDSYMZEW;
   _table.ZAK_SR.VALUE:=DOK_REJ.ZAK_SR;
   _table.SP_PRZEL.VALUE:=DOK_REJ.SP_PRZEL;
   _table.SKID_MB.VALUE:=DOK_REJ.SKID_MB().KOD; {? DOK_REJ.SKID_MB || _excel.write_async('SKID_MBN',DOK_REJ.SKID_MB) ?};
   _table.JPK_TYP.VALUE:=DOK_REJ.JPK_TYP;
   _table.JPK_RB.VALUE:=DOK_REJ.JPK_RB;
   _table.JPK_AN.VALUE:=DOK_REJ.JPK_AN;
   _table.TYP_CENY.VALUE:=DOK_REJ.TYP_CENY;
   _table.JPK_FA_T.VALUE:=DOK_REJ.JPK_FA_T;
   _table.JPK_FA_R.VALUE:=DOK_REJ.JPK_FA_R;
   _table.TYP_MAG.VALUE:=DOK_REJ.TYP_MAG;
   _table.JPK_FA_P.VALUE:=DOK_REJ.JPK_FA_P;
   _table.KOR_NAG.VALUE:=DOK_REJ.KOR_NAG;
   _table.RK.VALUE:=DOK_REJ.RK;
   _table.CZY_DP.VALUE:={? DOK_REJ.CZY_DP='' || 'N' || DOK_REJ.CZY_DP ?};
   _table.VPOZ_D.VALUE:={? DOK_REJ.VPOZ_D='' || 'N' || DOK_REJ.VPOZ_D ?};
   _table.PUDEK.VALUE:={? DOK_REJ.PUDEK='' || 'N' || DOK_REJ.PUDEK ?};
   _table.WEW.VALUE:={? DOK_REJ.WEW='' || 'N' || DOK_REJ.WEW ?};
   _table.JPK_EGTU.VALUE:={? DOK_REJ.JPK_EGTU='' || 'N' || DOK_REJ.JPK_EGTU ?};
   _table.JPK_EPRO.VALUE:={? DOK_REJ.JPK_EPRO='' || 'N' || DOK_REJ.JPK_EPRO ?};
   _table.JPK_V_T.VALUE:=DOK_REJ.JPK_V_T;
   _table.WARWKR.VALUE:=DOK_REJ.WARWKR;
   _table.SP_WYM.VALUE:={? DOK_REJ.SP_WYM='' || 'N' || DOK_REJ.SP_WYM ?};
   _table.JPK_ETYP.VALUE:={? DOK_REJ.JPK_ETYP='' || 'N' || DOK_REJ.JPK_ETYP ?};
   _table.KSEF.VALUE:={? DOK_REJ.KSEF='' || 'N' || DOK_REJ.KSEF ?};
   _table.KSRF.VALUE:=DOK_REJ.KSRF;
   {? var_pres('KSEF_BC',DOK_REJ)>0
   || _table.KSEF_BC.VALUE:=DOK_REJ.KSEF_BC
   ?};

   P_AUTOKS.cntx_psh();
   P_AUTOKS.index('RDA'); P_AUTOKS.prefix(null,DOK_REJ.ref());
   {? P_AUTOKS.first()
   || {!
      |? _excel.write_async('P_AUTOKS',P_AUTOKS.ref());
         P_AUTOKS.next()
      !}
   ?};
   P_AUTOKS.cntx_pop();
   _result:=1
?};
_result


\DOK_REJ_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=0;
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_obj.ROK,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono roku: %1.'@[_obj.ROK]
|? (_odd:=exec('FindInSet','#table','ODD','ODDZIALY',_obj.ODD,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono jednostki księgowej: %1.'@[_obj.ODD]
|? (_rej:=exec('FindInSet','#table','REJ','KOD',_obj.REJ,_rok,,1,_odd))=null
|| _result.MSG:='Nie znaleziono rejestru: %1 dla jednostki księgowej: %2 w roku: %3.'@[_obj.REJ,_obj.ODD,_obj.ROK]
|| _result.RESULT:=1;
   DOK_REJ.index('NAZ');
   DOK_REJ.prefix(_rej,_obj.NAZ,);
   {? DOK_REJ.first()
   || {? _mode=0
      || _result.RESULT:=0
      || _result.ACTION:='put'
      ?}
   || _result.ACTION:='add'
   ?};
   {? _result.RESULT=1
   || {? _result.ACTION='add'
      || DOK_REJ.blank(1)
      || exec('dok_rej_mod','rejestry',0)
      ?};
      DOK_REJ.REJ:=_rej;
      DOK_REJ.NAZ:=_obj.NAZ;
      DOK_REJ.SLO:=exec('find_slo_slu','slo_slu','~RODZAJE DOKUMENTÓW',_obj.SLO);
      DOK_REJ.AV:=exec('FindInSet','#table','AV','AV',_obj.AV,_rok,,1);
      DOK_REJ.DODSLU:=exec('FindInSet','#table','SLU','NAZ',_obj.DODSLU,,,1);
      DOK_REJ.FORM_SYM:=_obj.FORM_SYM;
      DOK_REJ.AN:=_obj.AN;
      DOK_REJ.POCH:=exec('FindInSet','#table','SLUAPPL','NAZ',_obj.POCH,'F',,1);
      DOK_REJ.ZM_POCH:=_obj.ZM_POCH;
      DOK_REJ.DM:=_obj.DM;
      DOK_REJ.POW:=_obj.POW;
      DOK_REJ.KOR:=_obj.KOR;
      DOK_REJ.ODD_ROZR:=_obj.ODD_ROZR;
      DOK_REJ.PR:=_obj.PR;
      DOK_REJ.ZAPL:=_obj.ZAPL;
      DOK_REJ.M_ODD:=_obj.M_ODD;
      DOK_REJ.CZY_RRB:=_obj.CZY_RRB;
      DOK_REJ.EDSYMZEW:=_obj.EDSYMZEW;
      DOK_REJ.ZAK_SR:=_obj.ZAK_SR;
      DOK_REJ.SP_PRZEL:=_obj.SP_PRZEL;
      DOK_REJ.SKID_MB:=exec('FindInSet','#table','SKID_MBN','KOD',_obj.SKID_MB,,,1);
      DOK_REJ.JPK_TYP:=_obj.JPK_TYP;
      DOK_REJ.JPK_RB:=_obj.JPK_RB;
      DOK_REJ.JPK_AN:=_obj.JPK_AN;
      DOK_REJ.TYP_CENY:=_obj.TYP_CENY;
      DOK_REJ.JPK_FA_T:=_obj.JPK_FA_T;
      DOK_REJ.JPK_FA_R:=_obj.JPK_FA_R;
      DOK_REJ.TYP_MAG:=_obj.TYP_MAG;
      DOK_REJ.JPK_FA_P:=_obj.JPK_FA_P;
      DOK_REJ.KOR_NAG:=_obj.KOR_NAG;
      DOK_REJ.RK:=_obj.RK;
      DOK_REJ.CZY_DP:=_obj.CZY_DP;
      DOK_REJ.VPOZ_D:=_obj.VPOZ_D;
      DOK_REJ.PUDEK:=_obj.PUDEK;
      DOK_REJ.WEW:=_obj.WEW;
      DOK_REJ.JPK_EGTU:=_obj.JPK_EGTU;
      DOK_REJ.JPK_EPRO:=_obj.JPK_EPRO;
      DOK_REJ.JPK_V_T:=_obj.JPK_V_T;
      DOK_REJ.WARWKR:=_obj.WARWKR;
      DOK_REJ.SP_WYM:=_obj.SP_WYM;
      DOK_REJ.JPK_ETYP:=_obj.JPK_ETYP;
      DOK_REJ.KSEF:=_obj.KSEF;
      DOK_REJ.KSRF:=_obj.KSRF;
      {? var_pres('KSEF_BC',DOK_REJ)>0
      || DOK_REJ.KSEF_BC:=_obj.KSEF_BC
      ?};

      {? exec('chk_dok_rej','rejestry',_result.ACTION='put')<>''
      || _result.RESULT:=0
      ?};
      {? _result.ACTION='put'
      || exec('dok_rej_mod','rejestry',1)
      ?}
   ?}
?};
~~


\DOK_REJ_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=DOK_REJ.add(1)
   |? _validate.ACTION='put'
   || _result:=DOK_REJ.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie rodzajów dokumentów %1 nie powiodło się.'@[_obj.NAZ]
   || _validate.MSG:='Poprawa rodzajów dokumentów %1 nie powiodła się.'@[_obj.NAZ]
   ?}
?};
_result


\DEK_NAG
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='DEK_NAG';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.FILE:=exec('filename','xls_ks');
_def.SHEET:='Schematy dziedzinowe=1,1';
_def.NAME:='Schematy dziedzinowe';
_def.DESC:='Schematy dziedzinowe';

_def.PREFIX:="";
_def.TABLE:="exec('DEK_NAG_tab','xls_ks',_a)";
_def.TAB_IMP:="DEK_NAG";
_def.FIELDS:="exec('DEK_NAG_fld','xls_ks',_a)";

_def.BEFORE:="WL_exp:=0;DEK_NAG.cntx_psh()";
_def.AFTER:="VAR_DEL.delete('WL_exp'); DEK_NAG.cntx_pop()";
_def.SELECT:="exec('DEK_NAG_select','xls_ks',_a)";

_def.EXPORT:="exec('DEK_NAG_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('DEK_NAG_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('DEK_NAG_imp','xls_ks',_a,_b,_c)";
~~


\DEK_NAG_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu struktury kont analitycznych bieżącej firmy
::   WE: _a - tryb pracy: 1-eksport wszystkiego, 2-eksport jednego rekordu
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select DEK_NAG.REFERENCE as REF, ROK_F.NAZ as ROK, DEK_NAG.SYSTEM, DEK_NAG.RODZ, (\':\' || DEK_NAG.IDADD || DEK_NAG.REFERENCE) as UIDREF '
      'from DEK_NAG join ROK_F '
      'where ROK_F.FIRMA=:_a '
      'order by ROK,SYSTEM, RODZ',
      REF.FIRMA
   )
|| DEK_NAG
?}


\DEK_NAG_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowa nazwa roku');
_def.define('SYSTEM','Obszar',1,,'10 znakowy obszar');
_def.define('RODZ',
   'Rodzaj',1,,'2 znakowy rodzaj:\n'
   'SV - Kasa - dokumenty VAT\n'
   'SN - Kasa - raporty kasowe bez VAT\n'
   'LM - Magazyny - dokumenty magazynowe\n'
   'KL - Płace - listy płac\n'
   'KU - Płace - umowy zlecenia\n'
   'Kl - Płace - umowy zlecenia z listy\n'
   'LS - Sprzedaż - dokumenty sprzedaży\n'
   'LK - Sprzedaż - korekty zbiorcze\n'
   'LP - Sprzedaż - paragony zbiorczo\n'
   'EF - Środki trwałe - amortyzacja bilansowa\n'
   'ED - Środki trwałe - amortyzacja dodatkowa\n'
   'EP - Środki trwałe - amortyzacja podatkowa\n'
   'ET - Środki trwałe - dokumenty OT\n'
   'EW - Środki trwałe - dokumenty wartościowe\n'
   'LZ - Zakupy - dokumenty zakupu'

);
_def.define('TYP','Typ',1,,'16 znakowy typ');
_def.define('NAZ','Nazwa',1,,'50 znakowa nazwa');
_def.define('F_DATA','Formuła na date dokumentu',1,,'8 znakowy skrót');
_def.define('S_DATA','Rejestracja wg daty',1,,'1 znakowy typ daty: W-wystawienia S-sprzedaży');
_def.define('SPR','Rodzaj kontroli',1,,
   '1 znakowy rodzaj kontroli:\n'
   'T - Pełna\n'
   'A - bez dokumentów niezakceptowanych\n'
   'D - z niepełnym dekretem\n'
   'E - z niepełnym dekretem (bez dokumentów niezaakceptowanych)\n'
   'B - Brak'
);
_def.define('RVAT','Rejestr VAT',1,,'8 znakowy symbol rejestru VAT');
_def.define('GR_VAT','Grupa podatkowa',1,,'8 znakowy symbol grupy');
_def.define('F_REJ','Rejestr - formuła',1,,'8 znakowy skrót');
_def.define('F_DOK_RJ','Rodzaj dokumentu - formuła',1,,'8 znakowy skrót');
_def.define('F_RVAT','Rejestr VAT - formuła',1,,'8 znakowy skrót');
_def.define('F_GR_VAT','Grupa podatkowa - formuła',1,,'8 znakowy skrót');
_def.define('F_SLKH','Słownik kontrahetów - formuła',1,,'8 znakowy skrót');
_def.define('F_OK_VAT','Okres VAT - formuła',1,,'8 znakowy skrót');
_def.define('SDREJ','Czy stały rodzaj dokumentu',1,,'1 znakowy S-stała F-Formuła');
_def.define('SREJ','Czy stały rejestr',1,,'1 znakowy S-stała F-Formuła');
_def.define('WARLOG','Warunek logiczny',1,,'255 znakowy warunek logiczny');
_def.define('VPOZ_STD','Sposób tworzenia pozycji VAT',1,,'1 znakowy P-podstawowy R-rozszerzony');
_def.define('F_TRESC','Formuła na treść dokumentu',1,,'8 znakowy skrót');
_def.define('FO_DATA','Formuła na datę operacji gospodarczej',1,,'8 znakowy skrót');
_def.define('F_SYMBOL','Formuła na symbol dokumentu',1,,'8 znakowy skrót');
_def.define('F_SYMZEW','Formuła na symbol zewnetrzny dokumentu',1,,'8 znakowy skrót');
{? var_pres('T_GTU',DEK_NAG)>0
|| _def.define('T_GTU','Sposób tworzenia GTU',1,,'1 znakowy P-z pozycji F-Formuła');
   _def.define('F_GTU','GTU - formuła',1,,'8 znakowy skrót');
   _def.define('F_PROC','Szczególna procedura - formuła',1,,'8 znakowy skrót')
?};
~~


\DEK_NAG_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Umożliwia wybór rekordów do eksportu
::   WE: _a - tab_tmp - tabela tymczasowa z polem REF którą należy zasilić
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik potwierdził wybór
::----------------------------------------------------------------------------------------------------------------------
_selected:=_a;

_result:=0;

_tab:=tab_tmp(2,
   'ROK','STRING[20]','Rok',
   'RODZ','STRING[30]','Schemat',
   'NAZ','STRING[60]','Nazwa',
   'REF','STRING[16]','SQL ref',
   'SELECTED','STRING[1]','Czy wybrano'
);

_ndx:=_tab.ndx_tmp(,,'SELECTED',,);
ROK_F.cntx_psh();
ROK_F.index('ROKPOCZ'); ROK_F.prefix(REF.FIRMA);
{? ROK_F.first()
|| DEK_NAG.cntx_psh();
   DEK_NAG.index('UNIK');
   {!
   |? DEK_NAG.prefix(ROK_F.ref());
      {? DEK_NAG.first()
      || {!
         |? _tab.blank();
            _tab.REF:=$DEK_NAG.ref();
            _selected.prefix($DEK_NAG.ref());
            _tab.SELECTED:={? _selected.first() || 'T' || 'N' ?};
            _tab.ROK:=ROK_F.NAZ;
            _tab.RODZ:=exec('opis','dok_fks_aut_dok',DEK_NAG.RODZ,DEK_NAG.SYSTEM);
            _tab.NAZ:=DEK_NAG.NAZ;
            _tab.add();
            DEK_NAG.next()
         !}
      ?};
      ROK_F.next()
   !};
   DEK_NAG.cntx_pop()
?};
ROK_F.cntx_pop();

_result:=exec('select_action','#table',_tab
 ,'ROK[5],RODZ[30],NAZ[60]',20,'Wybór schematów dziedzinowych do eksportu'@,1);
{? _result>0
||
   _selected.erase();

   _tab.index(_ndx);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |?
         _selected.prefix(_tab.REF);
         {? _selected.first()=0
         || _selected.blank();
            _selected.REF:=_tab.REF;
            _selected.add()
         ?};
         _tab.next()
      !}
   ?}
?};

_result


\DEK_NAG_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

_result:=0;

DEK_NAG.prefix();
{? _tab=DEK_NAG | DEK_NAG.seek(_tab.REF)
|| _table.ROK.VALUE:=DEK_NAG.ROK().NAZ; _excel.write_async('ROK_F',ROK_F.ref());
   _table.SYSTEM.VALUE:=DEK_NAG.SYSTEM;
   _table.RODZ.VALUE:=DEK_NAG.RODZ;
   _table.TYP.VALUE:=exec('dek_nag_typ','dok_fks_aut_dok',0,DEK_NAG.TYP);
   {? DEK_NAG.TYP<>'' || exec('DEK_NAG_typ_exp','xls_ks',_excel) ?};
   _table.NAZ.VALUE:=DEK_NAG.NAZ;
   _table.F_DATA.VALUE:=DEK_NAG.F_DATA().SKROT; {? DEK_NAG.F_DATA || _excel.write_async('FORMULA',DEK_NAG.F_DATA) ?};
   _table.S_DATA.VALUE:=DEK_NAG.S_DATA;
   _table.SPR.VALUE:=DEK_NAG.SPR;
   _table.RVAT.VALUE:=DEK_NAG.RVAT().SYM;       {? DEK_NAG.RVAT || _excel.write_async('RVAT',DEK_NAG.RVAT) ?};
   _table.GR_VAT.VALUE:=DEK_NAG.GR_VAT().KOD;   {? DEK_NAG.GR_VAT || _excel.write_async('SLO',DEK_NAG.GR_VAT) ?};
   _table.F_REJ.VALUE:=DEK_NAG.F_REJ().SKROT;   {? DEK_NAG.F_REJ || _excel.write_async('FORMULA',DEK_NAG.F_REJ) ?};
   _table.F_DOK_RJ.VALUE:=DEK_NAG.F_DOK_RJ().SKROT; {? DEK_NAG.F_DOK_RJ || _excel.write_async('FORMULA',DEK_NAG.F_DOK_RJ) ?};
   _table.F_RVAT.VALUE:=DEK_NAG.F_RVAT().SKROT; {? DEK_NAG.F_RVAT || _excel.write_async('FORMULA',DEK_NAG.F_RVAT) ?};
   _table.F_GR_VAT.VALUE:=DEK_NAG.F_GR_VAT().SKROT; {? DEK_NAG.F_GR_VAT || _excel.write_async('FORMULA',DEK_NAG.F_GR_VAT) ?};
   _table.F_SLKH.VALUE:=DEK_NAG.F_SLKH().SKROT; {? DEK_NAG.F_SLKH || _excel.write_async('FORMULA',DEK_NAG.F_SLKH) ?};
   _table.F_OK_VAT.VALUE:=DEK_NAG.F_OK_VAT().SKROT; {? DEK_NAG.F_OK_VAT || _excel.write_async('FORMULA',DEK_NAG.F_OK_VAT) ?};
   _table.SDREJ.VALUE:=DEK_NAG.SDREJ;
   _table.SREJ.VALUE:=DEK_NAG.SREJ;
   _table.WARLOG.VALUE:=DEK_NAG.WARLOG;
   _table.VPOZ_STD.VALUE:=DEK_NAG.VPOZ_STD;
   _table.F_TRESC.VALUE:=DEK_NAG.F_TRESC().SKROT; {? DEK_NAG.F_TRESC || _excel.write_async('FORMULA',DEK_NAG.F_TRESC) ?};
   _table.FO_DATA.VALUE:=DEK_NAG.FO_DATA().SKROT; {? DEK_NAG.FO_DATA || _excel.write_async('FORMULA',DEK_NAG.FO_DATA) ?};
   _table.F_SYMBOL.VALUE:=DEK_NAG.F_SYMBOL().SKROT; {? DEK_NAG.F_SYMBOL || _excel.write_async('FORMULA',DEK_NAG.F_SYMBOL) ?};
   _table.F_SYMZEW.VALUE:=DEK_NAG.F_SYMZEW().SKROT; {? DEK_NAG.F_SYMZEW || _excel.write_async('FORMULA',DEK_NAG.F_SYMZEW) ?};
   {? var_pres('T_GTU',DEK_NAG)>0
   || _table.T_GTU.VALUE:=DEK_NAG.T_GTU;
      _table.F_GTU.VALUE:=DEK_NAG.F_GTU().SKROT; {? DEK_NAG.F_GTU || _excel.write_async('FORMULA',DEK_NAG.F_GTU) ?};
      _table.F_PROC.VALUE:=DEK_NAG.F_PROC().SKROT; {? DEK_NAG.F_PROC || _excel.write_async('FORMULA',DEK_NAG.F_PROC) ?}
   ?};
   DEK_STAL.cntx_psh();
   DEK_STAL.index('ODD_REJ'); DEK_STAL.prefix(DEK_NAG.ref());
   {? DEK_STAL.first()
   || {!
      |? _excel.write_async('DEK_STAL',DEK_STAL.ref());
         DEK_STAL.next()
      !}
   ?};
   DEK_STAL.cntx_pop();

   DEK_POZ.cntx_psh();
   DEK_POZ.index('LP'); DEK_POZ.prefix(DEK_NAG.ref());
   {? DEK_POZ.first()
   || {!
      |? _excel.write_async('DEK_POZ',DEK_POZ.ref());
         DEK_POZ.next()
      !}
   ?};
   DEK_POZ.cntx_pop();

   {? var_press('WL_exp')>0 & WL_exp=0
   || WL_exp:=1;
      WARLOG.cntx_psh();
      WARLOG.index('KKOD'); WARLOG.prefix();
      {? WARLOG.first()
      || {!
         |? _excel.write_async('WARLOG',WARLOG.ref());
            WARLOG.next()
         !}
      ?};
      WARLOG.cntx_pop()
   ?};

   _result:=1
?};
_result


\DEK_NAG_typ_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Eksportuje typy schematów dziedzinowych
::   WE: _a - silnik eksportujący
::----------------------------------------------------------------------------------------------------------------------
{? ~-DEK_NAG.RODZ='KL' & 8+DEK_NAG.TYP='kryteria'
|| ~~
:: TODO: [MB] - nie zrealizowany jeszcze eksport
:: _a.write_async('KT',DEK_NAG.TYP)
|? ~-DEK_NAG.RODZ='KU' & 6+DEK_NAG.TYP='rodzum'
|| _a.write_async('RU_Z',DEK_NAG.TYP)
|? ~-DEK_NAG.RODZ='SV' & 8+DEK_NAG.TYP='koperpoz'
|| POZOPER.cntx_psh();
   POZOPER.prefix();
   {? POZOPER.seek(DEK_NAG.TYP)
   || _a.write_async('POZOPER',POZOPER.ref());
      _a.write_async('OPER',POZOPER.OPER)
   ?};
   POZOPER.cntx_pop()
|? ~-DEK_NAG.RODZ='EW' & 4+DEK_NAG.TYP='srdt'
|| SRDT.cntx_psh();
   SRDT.use(8+DEK_NAG.TYP);
   SRDT.prefix();
   {? SRDT.seek(DEK_NAG.TYP)
   || _a.write_async('SRDT',SRDT.ref())
   ?};
   SRDT.cntx_pop()
|? ~-DEK_NAG.RODZ='LM' & 7+DEK_NAG.TYP='typydok'
|| TYPYDOK.cntx_psh();
   TYPYDOK.prefix();
   {? TYPYDOK.seek(DEK_NAG.TYP)
   || _a.write_async('TYPYDOK',TYPYDOK.ref())
   ?};
   TYPYDOK.cntx_pop()
|? 1+(~-DEK_NAG.RODZ)='L' & 7+DEK_NAG.TYP='typydsp'
|| TYPYSP.cntx_psh();
   TYPYSP.prefix();
   {? TYPYSP.seek(DEK_NAG.TYP)
   || _a.write_async('TYPYSP',TYPYSP.ref())
   ?};
   TYPYSP.cntx_pop()
?}


\DEK_NAG_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=0;
{? _table.ROK='' || _fld:='ROK'
|? _table.RODZ='' || _fld:='RODZ'
|? _table.NAZ='' || _fld:='NAZ'
|? _table.SPR='' || _fld:='SPR'
|? _table.SREJ='' & _table.RODZ<>'SV' || _fld:='SREJ'
|? _table.SDREJ='' & _table.RODZ<>'SV' || _fld:='SDREJ'
|| _fld:=''
?};
{? _fld<>''
|| _result.msg_empty(_fld); return()
?};
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_table.ROK,REF.FIRMA,,1))=null
|| _result.msg_norec('ROK'); return()
|? ',SV,SN,LM,KL,KU,Kl,LS,LK,LP,EF,ED,EP,ET,EW,LZ,'*(','+_table.RODZ+',')=0
|| _result.msg_inset('RODZ','SV','SN','LM','KL','KU','Kl','LS','LK','LP','EF','ED','EP','ET','EW','LZ');
   return()
?};
DEK_NAG.index('UNIK');
DEK_NAG.prefix(_rok,_table.RODZ,_table.NAZ,);
{? DEK_NAG.first()
|| {? _mode=0
   || return()
   || _result.ACTION:='put'
   ?}
|| _result.ACTION:='add'
?};
_s_data:={? _table.RODZ='LZ' || 'W,S,O,'
         |? 1+_table.RODZ='K' | 'EF,ED,EP,'*(_table.RODZ+',')>0 || 'K,P,'
         |? 'LS,LK,LP,'*(_table.RODZ+',')>0 || 'W,S,'
         || ''
         ?};
{? _s_data='' & _table.S_DATA<>''
|| _result.msg_inset('S_DATA','');
   return()
|? _s_data<>'' & _s_data*(_table.S_DATA+',')=0
|| _result.msg_inset('S_DATA',_s_data-1);
   return()
|? _table.SPR<>'' & 'TADEB'*_table.SPR=0
|| _result.msg_inset('SPR','T','A','D','E','B');
   return()
|? 'SF'*_table.SREJ=0
|| _result.msg_inset('SREJ','S','F');
   return()
|? 'SF'*_table.SDREJ=0
|| _result.msg_inset('SDREJ','S','F');
   return()
|? _table.VPOZ_STD<>'' & 1+_table.RODZ='L' & 'PR'*_table.VPOZ_STD=0
|| _result.msg_inset('VPOZ_STD','P','R');
   return()
?};
{? _result.ACTION='add' || DEK_NAG.blank(1) ?};
DEK_NAG.ROK:=_rok;
DEK_NAG.SYSTEM:=_table.SYSTEM;
DEK_NAG.RODZ:=_table.RODZ;
DEK_NAG.TYP:=exec('dek_nag_typ','dok_fks_aut_dok',1,_table.TYP);
DEK_NAG.NAZ:=_table.NAZ;
{? _table.F_DATA<>''
|| DEK_NAG.F_DATA:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_DATA,'S',,1);
   {? DEK_NAG.F_DATA=null
   || _result.msg_norec('F_DATA'); return()
   ?}
?};
DEK_NAG.S_DATA:=_table.S_DATA;
DEK_NAG.SPR:=_table.SPR;
{? _table.RVAT<>''
|| DEK_NAG.RVAT:=exec('FindInSet','#table','RVAT','SYM',_table.RVAT,REF.FIRMA,,1);
   {? DEK_NAG.RVAT=null
   || _result.msg_norec('RVAT'); return()
   ?}
?};
{? _table.GR_VAT<>''
|| DEK_NAG.GR_VAT:=exec('find_slo_slu','slo_slu','~GRUPY PODATKOWE',_table.GR_VAT);
   {? DEK_NAG.GR_VAT=null
   || _result.msg_norec('GR_VAT'); return()
   ?}
?};
{? _table.F_REJ<>''
|| DEK_NAG.F_REJ:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_REJ,'S',,1);
   {? DEK_NAG.F_REJ=null
   || _result.msg_norec('F_REJ'); return()
   ?}
?};
{? _table.F_DOK_RJ<>''
|| DEK_NAG.F_DOK_RJ:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_DOK_RJ,'S',,1);
   {? DEK_NAG.F_DOK_RJ=null
   || _result.msg_norec('F_DOK_RJ'); return()
   ?}
?};
{? _table.F_RVAT<>''
|| DEK_NAG.F_RVAT:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_RVAT,'S',,1);
   {? DEK_NAG.F_RVAT=null
   || _result.msg_norec('F_RVAT'); return()
   ?}
?};
{? _table.F_GR_VAT<>''
|| DEK_NAG.F_GR_VAT:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_GR_VAT,'S',,1);
   {? DEK_NAG.F_GR_VAT=null
   || _result.msg_norec('F_GR_VAT'); return()
   ?}
?};
{? _table.F_SLKH<>''
|| DEK_NAG.F_SLKH:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_SLKH,'S',,1);
   {? DEK_NAG.F_SLKH=null
   || _result.msg_norec('F_SLKH'); return()
   ?}
?};
{? _table.F_OK_VAT<>''
|| DEK_NAG.F_OK_VAT:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_OK_VAT,'S',,1);
   {? DEK_NAG.F_OK_VAT=null
   || _result.msg_norec('F_OK_VAT'); return()
   ?}
?};
DEK_NAG.SDREJ:=_table.SDREJ;
DEK_NAG.SREJ:=_table.SREJ;
DEK_NAG.WARLOG:=_table.WARLOG;
DEK_NAG.VPOZ_STD:=_table.VPOZ_STD;
{? _table.F_TRESC<>''
|| DEK_NAG.F_TRESC:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_TRESC,'S',,1);
   {? DEK_NAG.F_TRESC=null
   || _result.msg_norec('F_TRESC'); return()
   ?}
?};
{? _table.FO_DATA<>''
|| DEK_NAG.FO_DATA:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.FO_DATA,'S',,1);
   {? DEK_NAG.FO_DATA=null
   || _result.msg_norec('FO_DATA'); return()
   ?}
?};
{? _table.F_SYMBOL<>''
|| DEK_NAG.F_SYMBOL:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_SYMBOL,'S',,1);
   {? DEK_NAG.F_SYMBOL=null
   || _result.msg_norec('F_SYMBOL'); return()
   ?}
?};
{? _table.F_SYMZEW<>''
|| DEK_NAG.F_SYMZEW:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_SYMZEW,'S',,1);
   {? DEK_NAG.F_SYMZEW=null
   || _result.msg_norec('F_SYMZEW'); return()
   ?}
?};
{? var_pres('T_GTU',DEK_NAG)>0
|| {? _table.T_GTU<>''
   || {? 'PF'*_table.T_GTU=0
      || _result.msg_inset('T_GTU','P','F'); return()
      |? _table.T_GTU='F' & _table.F_GTU=''
      || _result.msg_norec('F_GTU'); return()
      ?};
      DEK_NAG.T_GTU:=_table.T_GTU
   ?};
   {? _table.F_GTU<>''
   || DEK_NAG.F_GTU:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_GTU,'S',,1);
      {? DEK_NAG.F_GTU=null
      || _result.msg_norec('F_GTU'); return()
      ?}
   ?};
   {? _table.F_PROC<>''
   || DEK_NAG.F_PROC:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_PROC,'S',,1);
      {? DEK_NAG.F_PROC=null
      || _result.msg_norec('F_PROC'); return()
      ?}
   ?}
?};
{? exec('chk_dek_nag','dok_fks_aut_dok',_result.ACTION='put')<>''
|| _result.RESULT:=0
|| _result.RESULT:=1
?};
~~


\DEK_NAG_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=DEK_NAG.add(1)
   |? _validate.ACTION='put'
   || _result:=DEK_NAG.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie schematu dziedzinowego: %1 nie powiodło się.'@[_otable.NAZ]
   || _validate.MSG:='Poprawa schematu dziedzinowego nie powiodła się.'
   ?}
?};
_result


\DEK_STAL
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='DEK_STAL';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Stałe schematów dziedzinowych=1,1';
_def.NAME:='Stałe schematów dziedzinowych';
_def.DESC:='Stałe schemantów dziedzinowych';

_def.PREFIX:="";
_def.TABLE:="exec('DEK_STAL_tab','xls_ks',_a)";
_def.TAB_IMP:="DEK_STAL";
_def.FIELDS:="exec('DEK_STAL_fld','xls_ks',_a)";

_def.BEFORE:="DEK_STAL.cntx_psh()";
_def.AFTER:="DEK_STAL.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('DEK_STAL_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('DEK_STAL_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('DEK_STAL_imp','xls_ks',_a,_b,_c)";
~~


\DEK_STAL_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu stałych dla schematów danych bieżącej firmy
::   WE: _a - tryb pracy: 1-eksport wszystkiego, 2-eksport jednego rekordu
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select DEK_STAL.REFERENCE as REF, ROK_F.NAZ as ROK, DEK_NAG.RODZ, DEK_NAG.NAZ, (\':\' || DEK_STAL.IDADD || DEK_STAL.REFERENCE) as UIDREF '
      'from DEK_STAL join DEK_NAG join ROK_F '
      'where ROK_F.FIRMA=:_a '
      'order by ROK,RODZ,NAZ',
      REF.FIRMA
   )
|| DEK_STAL
?}


\DEK_STAL_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowy rok');
_def.define('RODZ','Rodzaj schematu',1,,'2 znakowy rodzaj schematu');
_def.define('DEK_NAG','Nazwa schematu dziedzinowego',1,,'50 znakowa nazwa schematu');
_def.define('ODD','Jednostka księgowa',1,,'8 znakowa jednostka księgowa');
_def.define('REJ','Rejestr księgowy',1,,'8 znakowy rejestr księgowy');
_def.define('DOK_REJ','Rodzaj dokumentu',1,,'60 znakowy rodzaj dokumentu');
~~


\DEK_STAL_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

DEK_STAL.prefix();
_result:=0;
{? _tab=DEK_STAL | DEK_STAL.seek(_tab.REF)
|| _table.ROK.VALUE:=DEK_STAL.DEK_NAG().ROK().NAZ;
   _table.RODZ.VALUE:=DEK_NAG.RODZ;
   _table.DEK_NAG.VALUE:=DEK_NAG.NAZ;
   _table.ODD.VALUE:=DEK_STAL.ODD().OD;
   _excel.write_async('ODD',DEK_STAL.ODD);
   _table.REJ.VALUE:=DEK_STAL.REJ().KOD;
   _excel.write_async('REJ',DEK_STAL.REJ);
   _table.DOK_REJ.VALUE:=DEK_STAL.DOK_REJ().NAZ;
   {? DEK_STAL.DOK_REJ
   || _excel.write_async('DOK_REJ',DEK_STAL.DOK_REJ)
   ?};
   _result:=1
?};
_result


\DEK_STAL_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=0;
_rej:=_dok_rej:=null;
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_table.ROK,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono roku: %1.'@[_table.ROK]
|? (_dek_nag:=exec('FindInSet','#table','DEK_NAG','UNIK',_table.DEK_NAG,_rok,,1,_table.RODZ))=null
|| _result.MSG:='Nie znaleziono schematu dziedzinowego:%1 w roku: %2.'@[_table.DEK_NAG,_table.ROK]
|? _table.ODD=''
|| _result.MSG:='Nie podano jednostki księgowej.'@
|? (_odd:=exec('FindInSet','#table','ODD','ODDZIALY',_table.ODD,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono jednostki księgowej o skrócie: %1.'@[_table.ODD]
|? _table.REJ=''
|| _result.MSG:='Nie podano rejestru księgowego.'@
|? (_rej:=exec('FindInSet','#table','REJ','KOD',_table.REJ,_rok,,1,_odd))=null
|| _result.MSG:='Nie znaleziono rejestru: %1 dla jednostki księgowej: %2 w roku: %3.'@[_table.REJ,_table.ODD,_table.ROK]
|? _table.DOK_REJ<>'' & (_dok_rej:=exec('FindInSet','#table','DOK_REJ','NAZ',_table.DOK_REJ,_rej,,1))=null
|| _result.MSG:='Nie znaleziono rodzaju dokumentu: %1 w roku: %2 dla jednostki księgowej: %3 i rejestru: %4.'@[_table.DOK_REJ,_table.ROK,_table.ODD,_table.REJ]
|| _result.RESULT:=1;
   DEK_STAL.index('DEK_STAL');
   DEK_STAL.prefix(_dek_nag,_odd);
   {? DEK_STAL.first()
   || {? _mode=0
      || _result.RESULT:=0
      || _result.ACTION:='put'
      ?}
   || _result.ACTION:='add'
   ?};
   {? _result.RESULT=1
   || {? _result.ACTION='add' || DEK_STAL.blank(1) ?};
      DEK_STAL.DEK_NAG:=_dek_nag;
      DEK_STAL.ODD:=_odd;
      DEK_STAL.REJ:=_rej;
      DEK_STAL.DOK_REJ:=_dok_rej;
      {? DEK_STAL.DOK_REJ & DEK_STAL.REJ<>DEK_STAL.DOK_REJ().REJ
      || DEK_STAL.DOK_REJ:=null
      ?};
      DEK_NAG.cntx_psh();
      DEK_NAG.prefix(); DEK_NAG.seek(_dek_nag);
      {? exec('chk_dek_stal','dok_fks_aut_dok')<>''
      || _result.RESULT:=0
      ?};
      DEK_NAG.cntx_pop()
   ?}
?};
~~


\DEK_STAL_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=DEK_STAL.add(1)
   |? _validate.ACTION='put'
   || _result:=DEK_STAL.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie stałej dla schematu dziedzinowego nie powiodło się.'
   || _validate.MSG:='Poprawa stałej dla schematu dziedzinowego nie powiodła się.'
   ?}
?};
_result


\DEKRET
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='DEKRET';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Dekrety schematów dziedzinowych=1,1';
_def.NAME:='Dekrety schematów dziedzinowych';
_def.DESC:='Dekrety schematów dziedzinowych';

_def.PREFIX:="DEKRET.index('RODZ_ID'); DEKRET.prefix(REF.FIRMA)";
_def.TABLE:="DEKRET";
_def.FIELDS:="exec('DEKRET_fld','xls_ks',_a)";

_def.BEFORE:="DEKRET.cntx_psh()";
_def.AFTER:="DEKRET.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('DEKRET_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('DEKRET_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('DEKRET_imp','xls_ks',_a,_b,_c)";
~~


\DEKRET_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('RODZAJ','Rodzaj dekretu',1,,'1 znakowy rodzaj');
_def.define('ID','Identyfikator',1,,'40 znakowy identyfikator');
_def.define('KONTOTXT','Konto tekst',1,,'35 znakowy symbol konta');
_def.define('KW_PLN','Kwota PLN',1,,'8 znakowy skrót formuły');
_def.define('KW_WAL','Kwota wal',1,,'8 znakowy skrót formuły');
_def.define('WALUTA','Waluta',1,,'8 znakowy skrót formuły');
_def.define('KURS_WAL','Kurs',1,,'8 znakowy skrót formuły');
_def.define('KONTO','Konto',1,,'8 znakowy skrót formuły');
_def.define('OPERACJA','Formuła na rozrachunek',1,,'8 znakowy skrót formuły');
_def.define('DATA','Formuła na datę',1,,'8 znakowy skrót');
_def.define('N_Z','Rodzaj rozrachunku',1,,'8 znakowy skrót formuły');
_def.define('TRESC','Treść dekretu',1,,'8 znakowy skrót formuły');
_def.define('PROLOG','Prolog',1,,'8 znakowy skrót formuły');
_def.define('EPILOG','Epilog',1,,'8 znakowy skrót formuły');
_def.define('MASKA','Maska',1,,'8 znakowa maska');
_def.define('REF','Ref',1,,'Nr rekordu');
~~


\DEKRET_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;

_result:=1;
_table.KONTOTXT.VALUE:=DEKRET.KONTOTXT;
_table.RODZAJ.VALUE:=DEKRET.RODZAJ;
_table.KW_PLN.VALUE:=DEKRET.KW_PLN().SKROT; {? DEKRET.KW_PLN || _excel.write_async('FORMULA',DEKRET.KW_PLN) ?};
_table.KW_WAL.VALUE:=DEKRET.KW_WAL().SKROT; {? DEKRET.KW_WAL || _excel.write_async('FORMULA',DEKRET.KW_WAL) ?};
_table.WALUTA.VALUE:=DEKRET.WALUTA().SKROT; {? DEKRET.WALUTA || _excel.write_async('FORMULA',DEKRET.WALUTA) ?};
_table.KURS_WAL.VALUE:=DEKRET.KURS_WAL().SKROT; {? DEKRET.KURS_WAL || _excel.write_async('FORMULA',DEKRET.KURS_WAL) ?};
_table.KONTO.VALUE:=DEKRET.KONTO().SKROT; {? DEKRET.KONTO || _excel.write_async('FORMULA',DEKRET.KONTO) ?};
_table.OPERACJA.VALUE:=DEKRET.OPERACJA().SKROT; {? DEKRET.OPERACJA || _excel.write_async('FORMULA',DEKRET.OPERACJA) ?};
_table.DATA.VALUE:=DEKRET.DATA().SKROT; {? DEKRET.DATA || _excel.write_async('FORMULA',DEKRET.DATA) ?};
_table.N_Z.VALUE:=DEKRET.N_Z().SKROT; {? DEKRET.N_Z || _excel.write_async('FORMULA',DEKRET.N_Z) ?};
_table.TRESC.VALUE:=DEKRET.TRESC().SKROT; {? DEKRET.TRESC || _excel.write_async('FORMULA',DEKRET.TRESC) ?};
_table.PROLOG.VALUE:=DEKRET.PROLOG().SKROT; {? DEKRET.PROLOG || _excel.write_async('FORMULA',DEKRET.PROLOG) ?};
_table.EPILOG.VALUE:=DEKRET.EPILOG().SKROT; {? DEKRET.EPILOG || _excel.write_async('FORMULA',DEKRET.EPILOG) ?};
_table.MASKA.VALUE:=DEKRET.MASKA;
_table.REF.VALUE:=DEKRET.REF;
_table.ID.VALUE:=DEKRET.ID;
_result


\DEKRET_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=0;
{? _table.RODZAJ='' || _fld:='RODZAJ'
|? _table.ID='' || _fld:='ID'
|| _fld:=''
?};
{? _fld<>''
|| _result.msg_empty(_fld); return()
?};
DEKRET.index('RODZ_ID');
DEKRET.prefix(REF.FIRMA,_table.RODZAJ,_table.ID,);
{? DEKRET.first()
|| {? _mode=0
   || return()
   || _result.ACTION:='put'
   ?}
|| _result.ACTION:='add'
?};
{? _table.KONTOTXT='' || _fld:='KONTOTXT'
|? _table.KONTO='' || _fld:='KONTO'
|? _table.KW_PLN='' || _fld:='KW_PLN'
|| _fld:=''
?};
{? _fld<>''
|| _result.msg_empty(_fld); return()
?};
{? _result.ACTION='add' || DEKRET.blank(1) ?};
DEKRET.FIRMA:=REF.FIRMA;
DEKRET.RODZAJ:=_table.RODZAJ;
DEKRET.ID:=_table.ID;
DEKRET.KONTOTXT:=_table.KONTOTXT;
DEKRET.KW_PLN:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.KW_PLN,'R',,1);
{? DEKRET.KW_PLN=null
|| _result.msg_norec('KW_PLN'); return()
?};
DEKRET.KW_WAL:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.KW_WAL,'R',,1);
{? _table.KW_WAL<>'' & DEKRET.KW_WAL=null
|| _result.msg_norec('KW_WAL'); return()
?};
DEKRET.WALUTA:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.WALUTA,'W',,1);
{? _table.WALUTA<>'' & DEKRET.WALUTA=null
|| _result.msg_norec('WALUTA'); return()
?};
DEKRET.KURS_WAL:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.KURS_WAL,'T',,1);
{? _table.KURS_WAL<>'' & DEKRET.KURS_WAL=null
|| _result.msg_norec('KURS_WAL'); return()
?};
DEKRET.KONTO:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.KONTO,'K',,1);
{? DEKRET.KONTO=null
|| _result.msg_norec('KONTO'); return()
?};
DEKRET.OPERACJA:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.OPERACJA,'I',,1);
{? _table.OPERACJA<>'' & DEKRET.OPERACJA=null
|| _result.msg_norec('OPERACJA'); return()
?};
DEKRET.DATA:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.DATA,'D',,1);
{? _table.DATA<>'' & DEKRET.DATA=null
|| _result.msg_norec('DATA'); return()
?};
DEKRET.N_Z:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.N_Z,'S',,1);
{? _table.N_Z<>'' & DEKRET.N_Z=null
|| _result.msg_norec('N_Z'); return()
?};
DEKRET.TRESC:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.TRESC,'S',,1);
{? _table.TRESC<>'' & DEKRET.TRESC=null
|| _result.msg_norec('TRESC'); return()
?};
DEKRET.PROLOG:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.PROLOG,'R',,1);
{? _table.PROLOG<>'' & DEKRET.PROLOG=null
|| _result.msg_norec('PROLOG'); return()
?};
DEKRET.EPILOG:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.EPILOG,'R',,1);
{? _table.EPILOG<>'' & DEKRET.EPILOG=null
|| _result.msg_norec('EPILOG'); return()
?};
DEKRET.MASKA:=_table.MASKA;
DEKRET.REF:=_table.REF;
{? exec('chk_dekret','dok_fks_aut_dok',_result.ACTION='put')=''
|| _result.RESULT:=1
?};
~~


\DEKRET_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=DEKRET.add(1)
   |? _validate.ACTION='put'
   || _result:=DEKRET.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie dekretu schematu dziedzinowego nie powiodło się.'
   || _validate.MSG:='Poprawa dekretu schematu dziedzinowego nie powiodła się.'
   ?}
?};
_result


\DEK_POZ
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='DEK_POZ';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Pozycje schematu dziedzinowego=1,1';
_def.NAME:='Pozycje schematu dziedzinowego';
_def.DESC:='Pozycje schematu dziedzinowego';

_def.PREFIX:="DEK_POZ.index('DEK_POZ'); DEK_POZ.prefix()";
_def.TABLE:="exec('DEK_POZ_tab','xls_ks',_a)";
_def.TAB_IMP:="DEK_POZ";
_def.FIELDS:="exec('DEK_POZ_fld','xls_ks',_a)";

_def.BEFORE:="DEK_POZ.cntx_psh()";
_def.AFTER:="DEK_POZ.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('DEK_POZ_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('DEK_POZ_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('DEK_POZ_imp','xls_ks',_a,_b,_c)";
~~


\DEK_POZ_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu danych bieżącej firmy
::   WE: _a - tryb pracy: 1-eksport wszystkiego, 2-eksport jednego rekordu
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select DEK_POZ.REFERENCE as REF, ROK_F.NAZ as ROK, DEK_NAG.RODZ, DEK_NAG.NAZ, DEK_POZ.LP, '
      '(\':\' || DEK_NAG.IDADD || DEK_NAG.REFERENCE) as UIDREF '
      'from DEK_POZ join DEK_NAG join ROK_F '
      'where ROK_F.FIRMA=:_a '
      'order by ROK,RODZ,NAZ,LP',
      REF.FIRMA
   )
|| DEK_POZ
?}


\DEK_POZ_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowy rok');
_def.define('RODZ','Rodzaj schematu',1,,'2 znakowy rodzaj schematu');
_def.define('DEK_NAG','Schemat dziedzinowy',1,,'50 znakowy schemat dziedzinowy');
_def.define('LP','Lp',1,,'Liczba porządkowa');
_def.define('WARLOG','Warunek logiczny',1,,'10 znakowy symbol');
_def.define('WSP','Współczynnik',1,,'10 znakowy symbol');
_def.define('IDENT','Rubryka/Transakcja',1,,'10 znakowy symbol');
_def.define('DEKRET_W','Dekret Wn',1,,'40 znakowy dekret');
_def.define('DEKRET_M','Dekret Ma',1,,'40 znakowy dekret');
_def.define('OPT','Optymalizacja',1,,'1 znakowy T lub N');
_def.define('ZAL','Dotyczy zaliczki',1,,'1 znakowy T lub N');
_def.define('GR','Grupa VAT',1,,'8 znakowa grupa VAT');
_def.define('F_GR','Fromuła na grupę podatkową',1,,'8 znakowy skrót formuły');
_def.define('F_VAT','Formuła na okres VAT',1,,'8 znakowy skrót fotmuły');
_def.define('RVAT','Rejestr VAT',1,,'8 znakowy rejestr VAT');
_def.define('F_RVAT','Formuła na rejestr VAT',1,,'8 znakowy skrót formuły');
_def.define('KN','Pomijać dla korekt nagłówkowych',1,,'1 znakowy T lub N');
~~


\DEK_POZ_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

DEK_POZ.prefix();
_result:=0;
{? _tab=DEK_POZ | DEK_POZ.seek(_tab.REF)
|| _table.ROK.VALUE:=DEK_POZ.DEK_NAG().ROK().NAZ;
   _table.RODZ.VALUE:=DEK_NAG.RODZ;
   _table.DEK_NAG.VALUE:=DEK_NAG.NAZ;
   _table.LP.VALUE:=DEK_POZ.LP;
   _table.WARLOG.VALUE:=DEK_POZ.WARLOG;
   _table.WSP.VALUE:=DEK_POZ.WSP;
   _table.IDENT.VALUE:=exec('DEK_POZ_ident','xls_ks',0,DEK_POZ.IDENT);
   _table.DEKRET_W.VALUE:=DEK_POZ.DEKRET_W().ID; {? DEK_POZ.DEKRET_W || _excel.write_async('DEKRET',DEK_POZ.DEKRET_W) ?};
   _table.DEKRET_M.VALUE:=DEK_POZ.DEKRET_M().ID; {? DEK_POZ.DEKRET_M || _excel.write_async('DEKRET',DEK_POZ.DEKRET_M) ?};
   _table.OPT.VALUE:=DEK_POZ.OPT;
   _table.ZAL.VALUE:=DEK_POZ.ZAL;
   _table.GR.VALUE:=DEK_POZ.GR().KOD;            {? DEK_POZ.GR || _excel.write_async('SLO',DEK_POZ.GR) ?};
   _table.F_GR.VALUE:=DEK_POZ.F_GR().SKROT;      {? DEK_POZ.F_GR || _excel.write_async('FORMULA',DEK_POZ.F_GR) ?};
   _table.F_VAT.VALUE:=DEK_POZ.F_VAT().SKROT;    {? DEK_POZ.F_VAT || _excel.write_async('FORMULA',DEK_POZ.F_VAT) ?};
   _table.RVAT.VALUE:=DEK_POZ.RVAT().SYM;        {? DEK_POZ.RVAT || _excel.write_async('RVAT',DEK_POZ.RVAT) ?};
   _table.F_RVAT.VALUE:=DEK_POZ.F_RVAT().SKROT;  {? DEK_POZ.F_RVAT || _excel.write_async('FORMULA',DEK_POZ.F_RVAT) ?};
   _table.KN.VALUE:=DEK_POZ.KN;

   exec('SKID_WYR_exp_pom','xls_ks',_excel,'DEK_POZ',DEK_POZ.ref());
   _result:=1
?};
_result


\DEK_POZ_ident
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca/ustawia wartośc pola DEK_POZ.IDENT
::   WE: _a - tryb: 0-zwraca, 1-ustawia
::       _b - wartość
::----------------------------------------------------------------------------------------------------------------------
{? _b='' || return('') ?};
{? _a=0
|| {? 8+_b='koperpoz'
   || _ret:=_b;
      POZOPER.cntx_psh();
      POZOPER.prefix();
      {? POZOPER.seek(_b)
      || _ret:=POZOPER.OPER().KOD+'|'+POZOPER.KOD
      ?};
      POZOPER.cntx_pop();
      _ret
   || _b
   ?}
|| {? 1+DEK_POZ.DEK_NAG().RODZ='S' & _b*'|'>0
   || _tab:=spli_str(_b,'|');
      _ret:=$exec('FindInSet','#table','POZOPER','KSIEG',_tab[2],_tab[1],,1)
   || _b
   ?}
?}


\DEK_POZ_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_result:=_c;
_result.RESULT:=0;
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_table.ROK,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono roku: %1.'@[_table.ROK]
|? (_dek_nag:=exec('FindInSet','#table','DEK_NAG','UNIK',_table.DEK_NAG,_rok,,1,_table.RODZ))=null
|| _result.MSG:='Nie znaleziono schematu dziedzinowego: %1 w roku: %2.'@[_table.DEK_NAG,_table.ROK]
|| _result.RESULT:=1;
   _lp:=_table.LP;
   DEK_POZ.index('LP');
   {? _lp>1
   || DEK_POZ.prefix(_dek_nag,_lp-1);
      {? ~DEK_POZ.first()
      || _result.RESULT:=0;
         _result.MSG:='Brak pozycji schematu: %1 w roku: %2 dla schematu: %3.'@[$_lp,_table.ROK,_table.DEK_NAG]
      ?}
   ?};
   {? _result.RESULT=1
   || DEK_POZ.prefix(_dek_nag,_lp);
      {? DEK_POZ.first()
      || {? _mode=0
         || _result.RESULT:=0
         || _result.ACTION:='put'
         ?}
      || _result.ACTION:='add'
      ?}
   ?};
   {? _result.RESULT=1
   || {? _result.ACTION='add' || DEK_POZ.blank(1) ?};
      DEK_POZ.DEK_NAG:=_dek_nag;
      DEK_POZ.LP:=_lp;
      DEK_POZ.WARLOG:=_table.WARLOG;
      DEK_POZ.WSP:=_table.WSP;
      DEK_POZ.IDENT:=exec('DEK_POZ_ident','xls_ks',1,_table.IDENT);
      DEK_POZ.DEK_NAG();
      _rodz:=exec('bl_dekr','dok_fks_aut_dok');
      DEK_POZ.DEKRET_W:=exec('FindInSet','#table','DEKRET','RODZ_ID',_table.DEKRET_W,REF.FIRMA,,1,_rodz);
      DEK_POZ.DEKRET_M:=exec('FindInSet','#table','DEKRET','RODZ_ID',_table.DEKRET_M,REF.FIRMA,,1,_rodz);
      DEK_POZ.OPT:=_table.OPT;
      DEK_POZ.ZAL:=_table.ZAL;
      DEK_POZ.GR:=exec('find_slo_slu','slo_slu','~GRUPY PODATKOWE',_table.GR);
      DEK_POZ.F_GR:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_GR,'S',,1);
      DEK_POZ.F_VAT:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_VAT,'S',,1);
      DEK_POZ.RVAT:=exec('FindInSet','#table','RVAT','SYM',_table.RVAT,REF.FIRMA,,1);
      DEK_POZ.F_RVAT:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.F_RVAT,'S',,1);
      DEK_POZ.KN:={? 'TN'*_table.KN || _table.KN || 'N' ?};
      {? exec('chk_dek_poz','dok_fks_aut_dok')<>''
      || _result.RESULT:=0
      || {? DEK_POZ.find_rec()
         || _result.MSG:='Istnieje pozycja dla schematu: %1 w roku: %2.'@[_table.DEK_NAG,_table.ROK];
            _result.RESULT:=0
         ?}

      ?}
   ?}
?};
~~


\DEK_POZ_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=DEK_POZ.add(1)
   |? _validate.ACTION='put'
   || _result:=DEK_POZ.put(1)
   ?}
?};
{? _result=0
|| _validate.MSG:='Dodanie pozycji schematu dziedzinowego nie powiodło się.'
?};
_result


\WARLOG
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='WARLOG';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Zmienne schematów dziedzinowych=1,1';
_def.NAME:='Zmienne schematów dziedzinowych';
_def.DESC:='Zmienne schematów dziedzinowych';

_def.PREFIX:="WARLOG.index('KKOD'); WARLOG.prefix()";
_def.TABLE:="WARLOG";
_def.FIELDS:="exec('WARLOG_fld','xls_ks',_a)";

_def.BEFORE:="WARLOG.cntx_psh()";
_def.AFTER:="WARLOG.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('WARLOG_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('WARLOG_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('WARLOG_imp','xls_ks',_a,_b,_c)";
~~


\WARLOG_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('RODZ','Rodzaj dekretacji',1,,'1 znakowy rodzaj');
_def.define('KOD','Kod',1,,'8 znakowy kod');
_def.define('OPIS','Opis',1,,'50 znakowy opis');
_def.define('FO','Formuła',1,,'255 znakowa formuła');
_def.define('TD','Typ danej',1,,'1 znakowy typ danych:\n'
   'S - tekstowa\n'
   'D - data\n'
   'R - liczbowa'
);
_def.define('SO','Sposób obliczenia',1,,'1 znakowy sposób obliczania:\n'
   'O - ogólny\n'
   'N - nagłówek\n'
   'P - pozycja\n'
   'D - dekret'
);
_def.define('DV','Dotyczy VAT',1,,'1 znakowy T lub N');
_def.define('RKW','Rodzaj kwoty',1,,'1 znakowy rodzaj kwoty:\n'
   'D - nie dotyczy\n'
   'N - netto\n'
   'V - podatek VAT\n'
   'B - brutto\n'
   'W - wartość w walucie'
);
~~


\WARLOG_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;

_result:=1;
_table.KOD.VALUE:=WARLOG.KOD;
_table.OPIS.VALUE:=WARLOG.OPIS;
_table.FO.VALUE:=WARLOG.FO;
_table.DV.VALUE:=WARLOG.DV;
_table.RKW.VALUE:=WARLOG.RKW;
_table.TD.VALUE:=WARLOG.TD;
_table.SO.VALUE:=WARLOG.SO;
_table.RODZ.VALUE:=WARLOG.RODZ;
_result


\WARLOG_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=1;
WARLOG.index('KKOD');
WARLOG.prefix(_table.RODZ,_table.KOD,);
{? WARLOG.first()
|| {? _mode=0
   || _result.RESULT:=0
   || _result.ACTION:='put'
   ?}
|| _result.ACTION:='add'
?};
{? _result.RESULT=1
|| {? _result.ACTION='add' || WARLOG.blank(1) ?};
   WARLOG.KOD:=_table.KOD;
   WARLOG.OPIS:=_table.OPIS;
   WARLOG.FO:=_table.FO;
   WARLOG.DV:=_table.DV;
   WARLOG.RKW:=_table.RKW;
   WARLOG.TD:=_table.TD;
   WARLOG.SO:=_table.SO;
   WARLOG.RODZ:=_table.RODZ;
   {? exec('chk_warlog0','dok_fks_aut_dok')<>'' |
      exec('chk_warlog','dok_fks_aut_dok',_result.ACTION='put')<>''
   || _result.RESULT:=0
   ?}
?};
~~


\WARLOG_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=WARLOG.add(1)
   |? _validate.ACTION='put'
   || _result:=WARLOG.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie zmiennej dla schematu dziedzinowego nie powiodło się.'
   || _validate.MSG:='Poprawa zmiennej dla schematu dziedzinowego nie powiodła się.'
   ?}
?};
_result


\SKID_WYR
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='SKID_WYR';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Wyróżniki dla schematów=1,1';
_def.NAME:='Wyróżniki dla schematów';
_def.DESC:='Wyróżniki dla schematów';

_def.PREFIX:="SKID_WYR.index('SKID_WYR'); SKID_WYR.prefix(REF.FIRMA)";
_def.TABLE:="SKID_WYR";
_def.FIELDS:="exec('SKID_WYR_fld','xls_ks',_a)";

_def.BEFORE:="SKID_WYR.cntx_psh()";
_def.AFTER:="SKID_WYR.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('SKID_WYR_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('SKID_WYR_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('SKID_WYR_imp','xls_ks',_a,_b,_c)";
~~


\SKID_WYR_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('RODZ','Rodzaj schematu',1,,'Rodzaj definicji');
_def.define('ROK','Rok',1,,'20 znakowy rok');
_def.define('NAG','Nagłówek pozycji',1,,'Nagłówek pozycji');
_def.define('NR','Lp pozycji',1,,'Liczba porządkowa pozycji',type_of(1));
_def.define('STR','Wn/ma',1,,'1 znakowy Znacznik strony: W-inien, M-a');
_def.define('LP','Lp wyróżnika',1,,'Liczba porządkowa wyróżnia');
_def.define('SLU','Słownik wyróżnika',1,,'20 znakowy słownik wyróżników');
_def.define('KOD','Kod',1,,'8 znakowa pozycja w słowniku wyróżników');
_def.define('FORMULA','Formuła - wyróznika',1,,'8 znakowy skrót formuły zwracającą kod wyróżnika');
_def.define('KWOTA','Formuła - kwota',1,,'8 znakowy skrót formuły zwracającą kwotę wyróżnika');
_def.define('PROC','Procent',1,,'Procent dekretowanej kwoty');
~~


\SKID_WYR_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;

_result:=1;
{? SKID_WYR.TAB='DEK_POZ'
|| DEK_POZ.prefix();
   {? DEK_POZ.seek(SKID_WYR.REF,)
   || _table.RODZ.VALUE:='Dziedzinowy';
      _table.ROK.VALUE:=DEK_POZ.DEK_NAG().ROK().NAZ;
      _table.NAG.VALUE:=DEK_NAG.RODZ+'|'+DEK_NAG.NAZ;
      _table.NR.VALUE:=DEK_POZ.LP
   ?}
|? SKID_WYR.TAB='DEK'
|| DEK.prefix();
   {? DEK.seek(SKID_WYR.REF,)
   || _table.RODZ.VALUE:='VAT';
      _table.ROK.VALUE:=DEK.AV().ROK_F().NAZ;
      _table.NAG.VALUE:=AV.KOD;
      _table.NR.VALUE:=DEK.LP
   ?}
|? SKID_WYR.TAB='FORM'
|| FORM.prefix();
   {? FORM.seek(SKID_WYR.REF,)
   || _table.RODZ.VALUE:='Dokumentów';
      _table.ROK.VALUE:=FORM.AUTOKSIE().ROK_F().NAZ;
      _table.NAG.VALUE:=AUTOKSIE.NAZ;
      _table.NR.VALUE:=FORM.POZ
   ?}
|| _result:=0
?};
{? _result=1
|| _table.STR.VALUE:=SKID_WYR.STR;
   _table.LP.VALUE:=SKID_WYR.LP;
   _table.SLU.VALUE:=SKID_WYR.SLU().SLU().NAZ;
   _table.KOD.VALUE:=SKID_WYR.KOD().KOD;
   _table.FORMULA.VALUE:=SKID_WYR.FORMULA().SKROT;
   _table.KWOTA.VALUE:=SKID_WYR.KWOTA().SKROT;
   _table.PROC.VALUE:=SKID_WYR.PROC
?};
_result


\SKID_WYR_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=1;
{? _table.RODZ='Dziedzinowy'
|| _tab:='DEK_POZ';
   _tabname:='dek_poz'
|? _table.RODZ='VAT'
|| _tab:='DEK';
   _tabname:='auto_dek'
|? _table.RODZ='Dokumentów'
|| _tab:='FORM';
   _tabname:='autoform'
|| _result.RESULT:=0;
   _result.MSG:='Nieprawidłowa wartość rodzaju schematu: %1. Dozwolone: VAT, Dokumentów oraz Dziedzinowy'@[_table.RODZ]
?};
{? _result.RESULT=1
|| {? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_table.ROK,REF.FIRMA,,1))=null
   || _result.MSG:='Nie znaleziono roku: %1.'@[_table.ROK];
      _result.RESULT:=0
   |? _table.NAG=''
   || _result.MSG:='Nie podano nagłówka definicji.'@;
      _result.RESULT:=0
   ?}
?};
{? _result.RESULT=1
|| _ref:=0;
   {? _tab='DEK_POZ'
   || DEK_NAG.index('UNIK');
      _str:=spli_str(_table.NAG,'|');
      {? obj_len(_str)=2
      || DEK_NAG.prefix(_rok,_str[1],_str[2],);
         {? DEK_NAG.first()
         || DEK_POZ.index('LP'); DEK_POZ.prefix(DEK_NAG.ref(),_table.NR);
            {? DEK_POZ.first()
            || _ref:=#DEK_POZ.ref()
            || _result.MSG:='Nie znaleziono pozycji: %1 schematu dziedzinowego: %2 w roku: %3.'@[$_table.NR,_table.NAG,_table.ROK];
               _result.RESULT:=0
            ?}
         || _result.MSG:='Nie znaleziono nagłówka schematu dziedzinowego: %1 w roku: %2.'@[_table.NAG,_table.ROK];
            _result.RESULT:=0
         ?}
      || _result.MSG:='Nieprawidłowa definicja nagłówka schematu dziedzinowego: %1 w roku: %2.'@[_table.NAG,_table.ROK];
         _result.RESULT:=0
      ?}
   |? _tab='DEK'
   || AV.index('AV'); AV.prefix(_rok,_table.NAG,);
      {? AV.first()
      || DEK.index('DEK'); DEK.prefix(AV.ref(),_table.NR);
         {? DEK.first()
         || _ref:=#DEK.ref()
         || _result.MSG:='Nie znaleziono pozycji: %1 schematu VAT: %2 w roku: %3.'@[$_table.NR,_table.NAG,_table.ROK];
            _result.RESULT:=0
         ?}
      || _result.MSG:='Nie znaleziono nagłówka schematu VAT: %1 w roku: %2.'@[_table.NAG,_table.ROK];
         _result.RESULT:=0
      ?}
   |? _tab='FORM'
   || AUTOKSIE.index('NAZ'); AUTOKSIE.prefix(_rok,_table.NAG,);
      {? AUTOKSIE.first()
      || FORM.index('AUTOKSIE'); FORM.prefix(AUTOKSIE.ref(),_table.NR);
         {? FORM.first()
         || _ref:=#FORM.ref()
         || _result.MSG:='Nie znaleziono pozycji: %1 schematu dokumentu: %2 w roku: %3.'@[$_table.NR,_table.NAG,_table.ROK];
            _result.RESULT:=0
         ?}
      || _result.MSG:='Nie znaleziono nagłówka schematu dokumentu: %1 w roku: %2.'@[_table.NAG,_table.ROK];
         _result.RESULT:=0
      ?}
   ?};
   {? _result.RESULT=1
   || SKID_WYR.index('SKID_WYR');
      SKID_WYR.prefix(REF.FIRMA,_tab,_tabname,_ref,_table.STR,_table.LP);
      {? SKID_WYR.first()
      || {? _mode=0
         || _result.RESULT:=0
         || _result.ACTION:='put'
         ?}
      || _result.ACTION:='add'
      ?};
      {? _result.RESULT=1
      || _sluappl:=_slu:=_slo:=_f_kod:=_f_kw:=null;
         {? _table.SLU<>'' & (
               (_slu:=exec('FindInSet','#table','SLU','NAZ',_table.SLU,,,1))=null |
               (_sluappl:=exec('FindInSet','#table','SLUAPPL','NAZ',_table.SLU,'F',,1))=null
            )
         || _result.MSG:='Nie znaleziono słownika użytkownika: %1.'@[_table.SLU];
            _result.RESULT:=0
         |? _slu & _table.KOD<>'' & (_slo:=exec('FindInSet','#table','SLO','SL',_table.KOD,_slu,,1))=null
         || _result.MSG:='Nie znaleziono pozycji: %1 słownika użytkownika: %2.'@[_table.KOD,_table.SLU];
            _result.RESULT:=0
         |? _table.FORMULA<>'' & (_f_kod:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.FORMULA,'S',,1))=null
         || _result.MSG:='Nie znaleziono formuły: %1 na kod wyróżnika.'@[_table.FORMULA];
            _result.RESULT:=0
         |? _table.KWOTA<>'' &  (_f_kw:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.KWOTA,'N',,1))=null()
         || _result.MSG:='Nie znaleziono formuły: %1 na kwotę wyróżnika.'@[_table.KWOTA];
            _result.RESULT:=0
         ?}
      ?};
      {? _result.RESULT=1
      || {? _result.ACTION='add' || SKID_WYR.blank(1) ?};
         SKID_WYR.FIRMA:=REF.FIRMA;
         SKID_WYR.TAB:=_tab;
         SKID_WYR.TABNAME:=_tabname;
         SKID_WYR.REF:=_ref;
         SKID_WYR.STR:=_table.STR;
         SKID_WYR.LP:=_table.LP;
         SKID_WYR.SLU:=_sluappl;
         SLOSLU.SLU_DEK:=SKID_WYR.SLU().SLU().NAZ;
         SKID_WYR.KOD:=_slo;
         SKID_WYR.FORMULA:=_f_kod;
         SKID_WYR.KWOTA:=_f_kw;
         SKID_WYR.PROC:=_table.PROC;
         KA.JAK:={? SKID_WYR.KOD || 'T' |? SKID_WYR.FORMULA || 'N' || 'R' ?};
         {? exec('chk_wyr','wyrozniki')<>''
         || _result.RESULT:=0
         ?}
      ?}
   ?}
?};
~~


\SKID_WYR_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=SKID_WYR.add(1)
   |? _validate.ACTION='put'
   || _result:=SKID_WYR.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie definicji wyróżnika dla schematu nie powiodło się.'@
   || _validate.MSG:='Poprawa definicji wyróżnika dla schematu nie powiodła się.'@
   ?}
?};
_result


\RVAT
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='RVAT';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.FILE:=exec('filename','xls_ks');
_def.SHEET:='Rejestry VAT=1,1';
_def.NAME:='Rejestry VAT';
_def.DESC:='Rejestry VAT';

_def.PREFIX:="RVAT.index('SYM'); RVAT.prefix(REF.FIRMA)";
_def.TABLE:="RVAT";
_def.FIELDS:="exec('RVAT_fld','xls_ks',_a)";

_def.BEFORE:="RVAT.cntx_psh()";
_def.AFTER:="RVAT.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('RVAT_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('RVAT_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('RVAT_imp','xls_ks',_a,_b,_c)";
_def.SELECT:="exec('RVAT_select','xls_ks',_a)";
~~


\RVAT_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [18.42]
:: OPIS: Umożliwia wybór rekordów do eksportu
::   WE: _a - tab_tmp - tabela tymczasowa z polem REF którą należy zasilić
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik potwierdził wybór
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_selected:=_a;

_result:=0;

_tab:=tab_tmp(1,
   'SYM','STRING[8]','Symbol rejestru VAT',
   'NAZ','STRING[60]','Nazwa rejestru VAT',
   'REF','STRING[16]','SQL ref',
   'SELECTED','STRING[1]','Czy wybrano'
);

_ndx:=_tab.ndx_tmp(,,'SELECTED',,,'SYM',,);

RVAT.cntx_psh();
RVAT.index('SYM');
RVAT.prefix(REF.FIRMA);
{? RVAT.first()
|| {!
   |? _tab.blank();
      _tab.REF:=$RVAT.ref();
      _selected.prefix($RVAT.ref());
      {? _selected.first()
      || _tab.SELECTED:='T'
      || _tab.SELECTED:='N'
      ?};
      _tab.SYM:=RVAT.SYM;
      _tab.NAZ:=RVAT.NAZ;
      _tab.add();
      RVAT.next()
   !}
?};
_result:=exec('select_action','#table',_tab
 ,'SYM[8],NAZ[60]',20,'Wybór rejestrów VAT do eksportu'@,1);
{? _result>0
||
   _selected.erase();

   _tab.index(_ndx);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |?
         _selected.prefix(_tab.REF);
         {? _selected.first()=0
         || _selected.blank();
            _selected.REF:=_tab.REF;
            _selected.add()
         ?};
         _tab.next()
      !}
   ?}
?};
RVAT.cntx_pop();

_result


\RVAT_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('SYM','Symbol rejestru VAT',1,,'8 znakowy skrót');
_def.define('NAZ','Nazwa rejestru VAT',1,,'60 znakowa nazwa');
_def.define('KVAT','Klasa ewidencji VAT',1,,'10 znakowy symbol');
_def.define('EWID','Rodzaj ewidencji',1,,'8 znakowy rodzaj ewidencji');
_def.define('STVAT','Stawka podatkowa',1,,'8 znakowa stawka podatku');
_def.define('GRVAT','Grupa podatkowa',1,,'8 znakowa grupa podatkowa');
_def.define('KRAJ','Kraj opodatkowania',1,,'8 znakowy kraj');
_def.define('CZY_ZM','Czy zmieniać kraj?',1,,'1 znakowy T lub N');
_def.define('RT','Rodzaj transakcji',1,,'1 znakowy rodzaj transakcji:\n'
   'S - Dostawa na terytorium kraju\n'
   'Z - Nabycie towarów i usług\n'
   'E - Eksport towarów\n'
   'I - Import towarów\n'
   'W - Operacja wewnątrzwspólnotowa'
);
~~


\RVAT_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;

_result:=1;
_table.SYM.VALUE:=RVAT.SYM;
_table.NAZ.VALUE:=RVAT.NAZ;
_table.KVAT.VALUE:=RVAT.KVAT().SYM;
_table.EWID.VALUE:=RVAT.EWID().KOD;
_table.STVAT.VALUE:=RVAT.STVAT().KOD;
_table.GRVAT.VALUE:=RVAT.GRVAT().KOD;
_table.KRAJ.VALUE:=RVAT.KRAJ().KOD;
_table.CZY_ZM.VALUE:=RVAT.CZY_ZM;
_table.RT.VALUE:=RVAT.RT;
_result


\RVAT_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=1;
RVAT.index('SYM');
RVAT.prefix(REF.FIRMA,_table.SYM,);
{? RVAT.first()
|| {? _mode=0
   || _result.RESULT:=0
   || _result.ACTION:='put'
   ?}
|| _result.ACTION:='add'
?};
{? _result.RESULT=1
|| {? _result.ACTION='add' || RVAT.blank(1) ?};
   RVAT.FIRMA:=REF.FIRMA;
   RVAT.SYM:=_table.SYM;
   RVAT.NAZ:=_table.NAZ;
   RVAT.KVAT:=exec('FindInSet','#table','KVAT','SYM',_table.KVAT,,,1);
   RVAT.EWID:=exec('find_slo_slu','slo_slu','~RODZAJE EWIDENCJI',_table.EWID);
   RVAT.KRAJ:=exec('find_slo_slu','slo_slu','~KRAJE UE',_table.KRAJ);
   RVAT.STVAT:=exec('find_slo_slu','slo_slu','~STAWKI VAT '+RVAT.KRAJ().KOD,_table.STVAT);
   RVAT.GRVAT:=exec('find_slo_slu','slo_slu','~GRUPY PODATKOWE',_table.GRVAT);
   RVAT.CZY_ZM:=_table.CZY_ZM;
   RVAT.RT:=_table.RT;
   {? exec('chk_rej_vat','rejestry',_result.ACTION='put')<>''
   || _result.RESULT:=0
   |? 'SZEIW'*RVAT.RT=0
   || _result.MSG:='Nieprawidłowa wartość rodzaju transakcji: %1. Dopuszczalne: SZEIW.'@[_table.RT];
      _result.RESULT:=0
   ?}
?};
~~


\RVAT_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=RVAT.add(1)
   |? _validate.ACTION='put'
   || _result:=RVAT.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie rejestru VAT: %1 nie powiodło się.'@[_table.SYM]
   || _validate.MSG:='Poprawa rejstru VAT: %1 nie powiodła się.'@[_table.SYM]
   ?}
?};
_result


\VAT_REJ
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='VAT_REJ';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Rejestry VAT rejestru=1,1';
_def.NAME:='Rejestry VAT rejestru księgowego';
_def.DESC:='Rejestry VAT rejestru księgowego';

_def.PREFIX:="";
_def.TABLE:="exec('VAT_REJ_tab','xls_ks',_a)";
_def.TAB_IMP:="VAT_REJ";
_def.FIELDS:="exec('VAT_REJ_fld','xls_ks',_a)";

_def.BEFORE:="VAT_REJ.cntx_psh()";
_def.AFTER:="VAT_REJ.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('VAT_REJ_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('VAT_REJ_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('VAT_REJ_imp','xls_ks',_a,_b,_c)";
_def.SELECT:="exec('VAT_REJ_select','xls_ks',_a)";
~~


\VAT_REJ_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [18.42]
:: OPIS: Umożliwia wybór rekordów do eksportu
::   WE: _a - tab_tmp - tabela tymczasowa z polem REF którą należy zasilić
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik potwierdził wybór
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_selected:=_a;

_result:=0;

_tab:=tab_tmp(4,
   'ROK','STRING[20]','Rok',
   'ODD','STRING[8]','Jednostka księgowa',
   'REJ','STRING[8]','Rejestr źródłowy',
   'RVAT','STRING[8]','Rejestr VAT',
   'REF','STRING[16]','SQL ref',
   'SELECTED','STRING[1]','Czy wybrano'
);

_ndx:=_tab.ndx_tmp(,,'SELECTED',,,'ROK',,);

VAT_REJ.cntx_psh();
VAT_REJ.index('REJ_VREF');
VAT_REJ.prefix();
{? VAT_REJ.first()
|| {!
   |? {? VAT_REJ.REJ().ROK().FIRMA=REF.FIRMA
      || _tab.blank();
         _tab.REF:=$VAT_REJ.ref();
         _selected.prefix($VAT_REJ.ref());
         {? _selected.first()
         || _tab.SELECTED:='T'
         || _tab.SELECTED:='N'
         ?};
         _tab.ROK:=VAT_REJ.REJ().ROK().NAZ;
         _tab.ODD:=VAT_REJ.REJ().ODD().OD;
         _tab.REJ:=VAT_REJ.REJ().KOD;
         _tab.RVAT:=VAT_REJ.RVAT().SYM;
         _tab.add()
      ?};
      VAT_REJ.next()
   !}
?};
_result:=exec('select_action','#table',_tab
 ,'ROK[5],ODD[8],REJ[8],RVAT',20,'Wybór rejestrów VAT rejestru księgowego do eksportu'@,1);
{? _result>0
||
   _selected.erase();

   _tab.index(_ndx);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |?
         _selected.prefix(_tab.REF);
         {? _selected.first()=0
         || _selected.blank();
            _selected.REF:=_tab.REF;
            _selected.add()
         ?};
         _tab.next()
      !}
   ?}
?};
VAT_REJ.cntx_pop();

_result


\VAT_REJ_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu struktury kont analitycznych bieżącej firmy
::   WE: _a - tryb pracy: 1-eksport wszystkiego, 2-eksport jednego rekordu
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_a')<=0 | _a=1
|| sql(
      'select VAT_REJ.REFERENCE as REF, ROK_F.NAZ as ROK, ODD.OD as ODD, REJ.KOD as REJ, '
      '(\':\' || VAT_REJ.IDADD || VAT_REJ.REFERENCE) as UIDREF '
      'from VAT_REJ join REJ join ODD join ROK_F '
      'where ROK_F.FIRMA=:_a '
      'order by ROK,ODD,REJ',
      REF.FIRMA
   )
|| VAT_REJ
?}


\VAT_REJ_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowy rok');
_def.define('ODD','Jednostka księgowa',1,,'8 znakowy symbol');
_def.define('REJ','Rejestr źródłowy',1,,'8 znakowy symbol rejestru księgowego');
_def.define('RVAT','Rejestr VAT',1,,'8 znakowy symbol rejestru VAT');
_def.define('DM','Domyślna pozycja',1,,'1 znakowy T lub N');
~~


\VAT_REJ_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

_result:=0;
VAT_REJ.prefix();
{? _tab=VAT_REJ | VAT_REJ.seek(_tab.REF)
|| _table.ROK.VALUE:=VAT_REJ.REJ().ROK().NAZ; _excel.write_async('ROK_F',ROK_F.ref());
   _table.ODD.VALUE:=VAT_REJ.REJ().ODD().OD; _excel.write_async('ODD',ODD.ref());
   _table.REJ.VALUE:=VAT_REJ.REJ().KOD;
   _table.RVAT.VALUE:=VAT_REJ.RVAT().SYM;    _excel.write_async('RVAT',RVAT.ref());
   _table.DM.VALUE:=VAT_REJ.DM;
   _result:=1
?};
_result


\VAT_REJ_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=0;
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_table.ROK,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono roku: %1.'@[_table.ROK]
|? (_odd:=exec('FindInSet','#table','ODD','ODDZIALY',_table.ODD,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono jednostki księgowej: %1.'@[_table.ODD]
|? (_rej:=exec('FindInSet','#table','REJ','KOD',_table.REJ,_rok,,1,_odd))=null
|| _result.MSG:='Nie znaleziono rejestru: %1 dla jednostki księgowej: %2 w roku: %3.'@[_table.REJ,_table.ODD,_table.ROK]
|? (_rvat:=exec('FindInSet','#table','RVAT','SYM',_table.RVAT,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono rejestru VAT: %1.'@[_table.RVAT]
|| _result.RESULT:=1;
   VAT_REJ.index('REJ_VREF');
   VAT_REJ.prefix(_rej,_rvat);
   {? VAT_REJ.first()
   || {? _mode=0
      || _result.RESULT:=0
      || _result.ACTION:='put'
      ?}
   || _result.ACTION:='add'
   ?};
   {? _result.RESULT=1
   || {? _result.ACTION='add' || VAT_REJ.blank(1) ?};
      VAT_REJ.REJ:=_rej;
      VAT_REJ.RVAT:=_rvat;
      VAT_REJ.SYM:=VAT_REJ.RVAT().SYM;
      VAT_REJ.DM:=_table.DM;
      {? exec('chk_vat_rej','rejestry',_result.ACTION='put')<>''
      || _result.RESULT:=0
      ?}
   ?}
?};
~~


\VAT_REJ_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=VAT_REJ.add(1)
   |? _validate.ACTION='put'
   || _result:=VAT_REJ.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie rejestru VAT %1 do rejestru %2 nie powiodło się.'@[_table.RVAT,_table.REJ]
   || _validate.MSG:='Poprawa rejestru VAT nie powiodła się.'
   ?}
?};
_result


\GR_VAT
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='GR_VAT';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Grupy VAT rejestru=1,1';
_def.NAME:='Grupy VAT rejestru';
_def.DESC:='Grupy VAT rejestru';

_def.PREFIX:="";
_def.TABLE:="exec('GR_VAT_tab','xls_ks',_a)";
_def.TAB_IMP:="GR_VAT";
_def.FIELDS:="exec('GR_VAT_fld','xls_ks',_a)";

_def.BEFORE:="GR_VAT.cntx_psh()";
_def.AFTER:="GR_VAT.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('GR_VAT_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('GR_VAT_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('GR_VAT_imp','xls_ks',_a,_b,_c)";
_def.SELECT:="exec('GR_VAT_select','xls_ks',_a)";
~~


\GR_VAT_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [18.42]
:: OPIS: Umożliwia wybór rekordów do eksportu
::   WE: _a - tab_tmp - tabela tymczasowa z polem REF którą należy zasilić
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik potwierdził wybór
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_selected:=_a;

_result:=0;

_tab:=tab_tmp(1,'ODD','STRING[8]','Jednostka księgowa'
   ,'REF','STRING[16]','SQL ref'
   ,'SELECTED','STRING[1]','Czy wybrano'
   ,'REJ','STRING[8]','Rejestr źródłowy'
   ,'GR_VAT','STRING[8]','Grupa VAT');

_ndx:=_tab.ndx_tmp(,,'SELECTED',,,'ODD',,);

GR_VAT.cntx_psh();
GR_VAT.index('REJ_GR');
GR_VAT.prefix();
{? GR_VAT.first()
|| {!
   |?
      _tab.blank();
      _tab.REF:=$GR_VAT.ref();
      _selected.prefix($GR_VAT.ref());
      {? _selected.first()
      || _tab.SELECTED:='T'
      || _tab.SELECTED:='N'
      ?};
      _tab.ODD:=GR_VAT.REJ().ODD().OD;
      _tab.REJ:=GR_VAT.REJ().KOD;
      _tab.GR_VAT:=GR_VAT.GRVAT().KOD;
      _tab.add();
      GR_VAT.next()
   !}
?};
_result:=exec('select_action','#table',_tab
 ,'ODD,REJ,GR_VAT',20,'Wybór grup VAT rejestru do eksportu'@,1);
{? _result>0
||
   _selected.erase();

   _tab.index(_ndx);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |?
         _selected.prefix(_tab.REF);
         {? _selected.first()=0
         || _selected.blank();
            _selected.REF:=_tab.REF;
            _selected.add()
         ?};
         _tab.next()
      !}
   ?}
?};
GR_VAT.cntx_pop();

_result


\GR_VAT_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu struktury kont analitycznych bieżącej firmy
::   WE: _a - tryb pracy: 1-eksport wszystkiego, 2-eksport jednego rekordu
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select GR_VAT.REFERENCE as REF, ROK_F.NAZ as ROK, ODD.OD as ODD, REJ.KOD as REJ, (\':\' || GR_VAT.IDADD || GR_VAT.REFERENCE) as UIDREF '
      'from GR_VAT join REJ join ODD join ROK_F '
      'where ROK_F.FIRMA=:_a '
      'order by ROK,ODD,REJ',
      REF.FIRMA
   )
|| GR_VAT
?}


\GR_VAT_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowy rok');
_def.define('ODD','Jednostka księgowa',1,,'8 znakowy symbol');
_def.define('REJ','Rejestr źródłowy',1,,'8 znakowy symbol rejestru księgowego');
_def.define('GR_VAT','Grupa VAT',1,,'8 znakowa grupa VAT');
~~


\GR_VAT_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

_result:=0;
GR_VAT.prefix();
{? _tab=GR_VAT | GR_VAT.seek(_tab.REF)
|| _table.ROK.VALUE:=GR_VAT.REJ().ROK().NAZ; _excel.write_async('ROK_F',ROK_F.ref());
   _table.ODD.VALUE:=GR_VAT.REJ().ODD().OD; _excel.write_async('ODD',ODD.ref());
   _table.REJ.VALUE:=GR_VAT.REJ().KOD;
   _table.GR_VAT.VALUE:=GR_VAT.GRVAT().KOD;
   _result:=1
?};
_result


\GR_VAT_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=0;
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_table.ROK,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono roku: %1.'@[_table.ROK]
|? (_odd:=exec('FindInSet','#table','ODD','ODDZIALY',_table.ODD,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono jednostki księgowej: %1.'@[_table.ODD]
|? (_rej:=exec('FindInSet','#table','REJ','KOD',_table.REJ,_rok,,1,_odd))=null
|| _result.MSG:='Nie znaleziono rejestru: %1 dla jednostki księgowej: %2 w roku: %3.'@[_table.REJ,_table.ODD,_table.ROK]
|? (_grvat:=exec('find_slo_slu','slo_slu','~GRUPY PODATKOWE',_table.GR_VAT))=null
|| _result.MSG:='Nie znaleziono grupy podatkowej VAT: %1.'@[_table.GR_VAT]
|| _result.RESULT:=1;
   GR_VAT.index('REJ_GR');
   GR_VAT.prefix(_rej,_grvat);
   {? GR_VAT.first()
   || _result.RESULT:=0
   || _result.ACTION:='add'
   ?};
   {? _result.RESULT=1
   || {? _result.ACTION='add' || GR_VAT.blank(1) ?};
      GR_VAT.REJ:=_rej;
      GR_VAT.GRVAT:=_grvat;
      GR_VAT.KOD:=GR_VAT.GRVAT().KOD
   ?}
?};
~~


\GR_VAT_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=GR_VAT.add(1)
   |? _validate.ACTION='put'
   || _result:=GR_VAT.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie grupy podatkowej VAT: %1 do rejestru %2 nie powiodło się.'@[_table.GR_VAT,_table.REJ]
   || _validate.MSG:='Poprawa grupy podatkowej VAT nie powiodła się.'
   ?}
?};
_result


\AUTOKSIE
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='AUTOKSIE';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.FILE:=exec('filename','xls_ks');
_def.SHEET:='Schematy dokumentów=1,1';
_def.NAME:='Schematy dokumentów';
_def.DESC:='Schematy dokumentów';

_def.PREFIX:="";
_def.TABLE:="exec('AUTOKSIE_tab','xls_ks',_a)";
_def.TAB_IMP:="AUTOKSIE";
_def.FIELDS:="exec('AUTOKSIE_fld','xls_ks',_a)";

_def.BEFORE:="AUTOKSIE.cntx_psh()";
_def.AFTER:="AUTOKSIE.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('AUTOKSIE_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('AUTOKSIE_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('AUTOKSIE_imp','xls_ks',_a,_b,_c)";
_def.SELECT:="exec('AUTOKSIE_select','xls_ks',_a)";
~~


\AUTOKSIE_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [18.42]
:: OPIS: Umożliwia wybór rekordów do eksportu
::   WE: _a - tab_tmp - tabela tymczasowa z polem REF którą należy zasilić
::   WY: 0 - użytkownik zrezygnował z wyboru
::       1 - użytkownik potwierdził wybór
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_selected:=_a;

_result:=0;

_tab:=tab_tmp(2,
   'ROK','STRING[20]','Rok',
   'NAZ','STRING[8]','Nazwa',
   'OP','STRING[40]','Opis',
   'REF','STRING[16]','SQL ref',
   'SELECTED','STRING[1]','Czy wybrano'
);
_ndx:=_tab.ndx_tmp(,,'SELECTED',,,'ROK',,,'NAZ',,);

AUTOKSIE.cntx_psh();
AUTOKSIE.index('NAZ');
AUTOKSIE.prefix();
{? AUTOKSIE.first()
|| {!
   |? _tab.blank();
      _tab.REF:=$AUTOKSIE.ref();
      _selected.prefix($AUTOKSIE.ref());
      {? _selected.first()
      || _tab.SELECTED:='T'
      || _tab.SELECTED:='N'
      ?};
      _tab.ROK:=AUTOKSIE.ROK_F().NAZ;
      _tab.NAZ:=AUTOKSIE.NAZ;
      _tab.OP:=AUTOKSIE.OP;
      _tab.add();
      AUTOKSIE.next()
   !}
?};
_result:=exec('select_action','#table',_tab
 ,'ROK[5],NAZ[8],OP[40]',20,'Wybór schematu dokumentów do eksportu'@,1);
{? _result>0
||
   _selected.erase();

   _tab.index(_ndx);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |?
         _selected.prefix(_tab.REF);
         {? _selected.first()=0
         || _selected.blank();
            _selected.REF:=_tab.REF;
            _selected.add()
         ?};
         _tab.next()
      !}
   ?}
?};
AUTOKSIE.cntx_pop();

_result


\AUTOKSIE_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu struktury kont analitycznych bieżącej firmy
::   WE: _a - tryb pracy: 1-eksport wszystkiego, 2-eksport jednego rekordu
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select AUTOKSIE.REFERENCE as REF, ROK_F.NAZ as ROK, (\':\' ||  AUTOKSIE.IDADD ||  AUTOKSIE.REFERENCE) as UIDREF '
      'from AUTOKSIE join ROK_F '
      'where ROK_F.FIRMA=:_a '
      'order by ROK',
      REF.FIRMA
   )
|| AUTOKSIE
?}


\AUTOKSIE_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok bilansowy',1,,'20 znakowy rok');
_def.define('NAZ','Nazwa',1,,'8 znakowa nazwa');
_def.define('OP','Opis',1,,'40 znakowy opis');
_def.define('FORMPOCZ','Formuła początkowa',1,,'255 znakowa formuła');
_def.define('TYP','Miejsce wywołania schematu',1,,
   '1 znakowe miejsce:\n'
   'N - dokument\n'
   'P - pozycje\n'
   'D - pozycje z podziałów\n'
   'K - podziały z pozycji\n'
   'L - dekretacja delegacji'
);
_def.define('WYR','Wyróżniki',1,,'1 znakowy T lub N');
~~


\AUTOKSIE_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

_result:=0;
AUTOKSIE.prefix();
{? _tab=AUTOKSIE | AUTOKSIE.seek(_tab.REF)
|| _table.ROK.VALUE:=AUTOKSIE.ROK_F().NAZ; _excel.write_async('ROK_F',ROK_F.ref());
   _table.NAZ.VALUE:=AUTOKSIE.NAZ;
   _table.OP.VALUE:=AUTOKSIE.OP;
   _table.FORMPOCZ.VALUE:=AUTOKSIE.FORMPOCZ;
   _table.TYP.VALUE:=AUTOKSIE.TYP;
   _table.WYR.VALUE:=AUTOKSIE.WYR;

   FORM.cntx_psh();
   FORM.index('AUTOKSIE'); FORM.prefix(AUTOKSIE.ref());
   {? FORM.first()
   || {!
      |? _excel.write_async('FORM',FORM.ref());
         FORM.next()
      !}
   ?};
   FORM.cntx_pop();
   _result:=1
?};
_result


\AUTOKSIE_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=0;
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_table.ROK,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono roku: %1.'@[_table.ROK]
|| _result.RESULT:=1;
   AUTOKSIE.index('NAZ');
   AUTOKSIE.prefix(_rok,_table.NAZ,);
   {? AUTOKSIE.first()
   || {? _mode=0
      || _result.RESULT:=0
      |? AUTOKSIE.A='T'
      || _result.RESULT:=0;
         _result.MSG:='Schemat dokumentu: %1 z roku: %2 jest zaakceptowany.'@[_table.NAZ,_table.ROK]
      || _result.ACTION:='put'
      ?}
   || _result.ACTION:='add'
   ?};
   {? _result.RESULT=1
   || {? _result.ACTION='add' || AUTOKSIE.blank(1) ?};
      AUTOKSIE.ROK_F:=_rok;
      AUTOKSIE.NAZ:=_table.NAZ;
      AUTOKSIE.OP:=_table.OP;
      AUTOKSIE.FORMPOCZ:=_table.FORMPOCZ;
      AUTOKSIE.TYP:=_table.TYP;
      AUTOKSIE.WYR:=_table.WYR;
      {? exec('chk_autoksie','rejestry',_result.ACTION='put')<>''
      || _result.RESULT:=0
      ?}
   ?}
?};
~~


\AUTOKSIE_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=AUTOKSIE.add(1)
   |? _validate.ACTION='put'
   || _result:=AUTOKSIE.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie schematu dokumentu: %1 do roku: %2 nie powiodło się.'@[_table.NAZ,_table.ROK]
   || _validate.MSG:='Poprawa schematu dokumentu nie powiodła się.'
   ?}
?};
_result


\FORM
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='FORM';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Pozycje schematu dokumentów=1,1';
_def.NAME:='Pozycje schematu dokumentów';
_def.DESC:='Pozycje schematu dokumentów';

_def.PREFIX:="";
_def.TABLE:="exec('FORM_tab','xls_ks',_a)";
_def.TAB_IMP:="FORM";
_def.FIELDS:="exec('FORM_fld','xls_ks',_a)";

_def.BEFORE:="FORM.cntx_psh()";
_def.AFTER:="FORM.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('FORM_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('FORM_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('FORM_imp','xls_ks',_a,_b,_c)";
~~


\FORM_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu struktury kont analitycznych bieżącej firmy
::   WE: _a - tryb pracy: 1-eksport wszystkiego, 2-eksport jednego rekordu
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select FORM.REFERENCE as REF, ROK_F.NAZ as ROK, AUTOKSIE.NAZ as AUTOKSIE, (\':\' || FORM.IDADD || FORM.REFERENCE) as UIDREF '
      'from FORM join AUTOKSIE join ROK_F '
      'where ROK_F.FIRMA=:_a '
      'order by ROK,AUTOKSIE',
      REF.FIRMA
   )
|| FORM
?}


\FORM_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowa nazwa  roku');
_def.define('AUTOKSIE','Schemat dokumentu',1,,'8 znakowa nazwa schematu dokumentu');
_def.define('POZ','Lp',1,,'Liczba porządkowa');
_def.define('KARTOTEK','Kartoteka źródłowa',1,,'8 znakowy symbol');
_def.define('INDEKS','Indeks',1,,'8 znakowy indeks');
_def.define('MASKA','Maska',1,,'60 znakowa maska');
_def.define('FML','Formuła',1,,'Formuła');
_def.define('KWN','Konto Winien',1,,'60 znakowa formuła');
_def.define('KMA','Konto Ma',1,,'60 znakowa formuła');
_def.define('SKID_MB','Model',1,,'8 znakowy kod modelu');
_def.define('PBUD','Pozycja budżetowa',1,,'16 znakowy symbol pozycji budżetowej');
_def.define('JORG_SF','Jednostka organizacyjna - stała/formuła',1,,'1 znakowy S-Stałą, F-Formuła');
_def.define('JORG_S','Jednostka organizacyjna',1,,'16 znakowy symbol jednostki organizacyjnej');
_def.define('JORG_F','Jednostka organizacyjna - formuła',1,,'60 znakowa formuła na jednostkę organizacyjną');
_def.define('OKOSZ_SF','Obiekt kosztów - stała/formuła',1,,'1 znakowy S-Stałą, F-Formuła');
_def.define('OKOSZ_S','Obiekt kosztów',1,,'16 znakowy symbol obiektu kosztów');
_def.define('OKOSZ_F','Obiekt kosztów - formuła',1,,'60 znakowa formuła na obiekt kosztów');
_def.define('PBUD_SF','Pozycja budżetowa - stała/formuła',1,,'1 znakowy S-Stałą, F-Formuła');
_def.define('PBUD_S','Pozycja budżetowa',1,,'16 znakowy symbol pozycji budżetowej');
_def.define('PBUD_F','Pozycja budżetowa - formuła',1,,'60 znakowa formuła na pozycję budżetową');
_def.define('WYM4_SF','Wymiar 4 - stała/formuła',1,,'1 znakowy S-Stałą, F-Formuła');
_def.define('WYM4_S','Wymiar 4',1,,'16 znakowy symbol wymiaru 4');
_def.define('WYM4_F','Wymiar 4 - formuła',1,,'60 znakowa formuła na wymiar 4');
_def.define('WYM5_SF','Wymiar 5 - stała/formuła',1,,'1 znakowy S-Stałą, F-Formuła');
_def.define('WYM5_S','Wymiar 5',1,,'16 znakowy symbol wymiaru 5');
_def.define('WYM5_F','Wymiar 5 - formuła',1,,'60 znakowa formuła na wymiar 5');
_def.define('RKWOTDEL','Dekretacja delegacji - rodzaj kwoty',1,,'8 znakowy rodzaj kwoty');
_def.define('ETYPWYD','Typ wydatku',1,,'50 znakowy typ wydatku');
_def.define('OP','Opis',1,,'60 znakowy symbol');
_def.define('ID','Identyfikator',1,,'60 znakowa formuła');
_def.define('TID','Typ rozrachunku',1,,'60 znakowa formuła');
_def.define('TP','Termin płatności',1,,'60 znakowa formuła');
_def.define('DO','Data otwarcia',1,,'60 znakowa formuła');
_def.define('ODD_ROZR','Jednostka księgowa rozrachunku',1,,'60 znakowa formuła');
_def.define('PROJEKT','Projekt',1,,'60 znakowa formuła');
_def.define('PROCENT','Procent',1,,'Procent');
_def.define('SW1','Sposób określenia wyróżnika 1',1,,'1 znakowy S-Stały, F-Formuła');
_def.define('W1','Wyróżnik 1',1,,'8 znakowy kod pozycji słownika z wyróżnikiem');
_def.define('FW1','Formuła na wyróżnik 1',1,,'255 znakowa formuła');
_def.define('SW2','Sposób określenia wyróżnika 2',1,,'1 znakowy S-Stały, F-Formuła');
_def.define('W2','Wyróżnik 2',1,,'8 znakowy kod pozycji słownika z wyróżnikiem');
_def.define('FW2','Formuła na wyróżnik 2',1,,'255 znakowa formuła');
_def.define('SW3','Sposób określenia wyróżnika 3',1,,'1 znakowy S-Stały, F-Formuła');
_def.define('W3','Wyróżnik 3',1,,'8 znakowy kod pozycji słownika z wyróżnikiem');
_def.define('FW3','Formuła na wyróżnik 3',1,,'255 znakowa formuła');
_def.define('SW4','Sposób określenia wyróżnika 4',1,,'1 znakowy S-Stały, F-Formuła');
_def.define('W4','Wyróżnik 4',1,,'8 znakowy kod pozycji słownika z wyróżnikiem');
_def.define('FW4','Formuła na wyróżnik 4',1,,'255 znakowa formuła');
_def.define('SW5','Sposób określenia wyróżnika 5',1,,'1 znakowy S-Stały, F-Formuła');
_def.define('W5','Wyróżnik 5',1,,'8 znakowy kod pozycji słownika z wyróżnikiem');
_def.define('FW5','Formuła na wyróżnik 5',1,,'255 znakowa formuła');
_def.define('SW6','Sposób określenia wyróżnika 6',1,,'1 znakowy S-Stały, F-Formuła');
_def.define('W6','Wyróżnik 6',1,,'8 znakowy kod pozycji słownika z wyróżnikiem');
_def.define('FW6','Formuła na wyróżnik 6',1,,'255 znakowa formuła');
~~


\FORM_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

_result:=0;
FORM.prefix();
{? _tab=FORM | FORM.seek(_tab.REF)
|| _table.ROK.VALUE:=FORM.AUTOKSIE().ROK_F().NAZ; _excel.write_async('ROK_F',ROK_F.ref());
   _table.AUTOKSIE.VALUE:=FORM.AUTOKSIE().NAZ;
   _table.POZ.VALUE:=FORM.POZ;
   _table.KARTOTEK.VALUE:=FORM.KARTOTEK;
   _table.INDEKS.VALUE:=FORM.INDEKS;
   _table.MASKA.VALUE:=FORM.MASKA;
   _table.FML.VALUE:=FORM.memo_txt(,1,'FML');
   _table.KWN.VALUE:=FORM.KWN;
   _table.KMA.VALUE:=FORM.KMA;
   _table.SKID_MB.VALUE:=FORM.SKID_MB().KOD; {? FORM.SKID_MB || _excel.write_async('SKID_MBN',FORM.SKID_MB) ?};
   _table.PBUD.VALUE:=FORM.PBUD().SYMBOL;    {? FORM.PBUD || _excel.write_async('UD_SKL',FORM.PBUD) ?};
   _table.JORG_SF.VALUE:=FORM.JORG_SF;
   _table.JORG_S.VALUE:=FORM.JORG_S;
   _table.JORG_F.VALUE:=FORM.JORG_F;
   _table.OKOSZ_SF.VALUE:=FORM.OKOSZ_SF;
   _table.OKOSZ_S.VALUE:=FORM.OKOSZ_S;
   _table.OKOSZ_F.VALUE:=FORM.OKOSZ_F;
   _table.PBUD_SF.VALUE:=FORM.PBUD_SF;
   _table.PBUD_S.VALUE:=FORM.PBUD_S;
   _table.PBUD_F.VALUE:=FORM.PBUD_F;
   _table.WYM4_SF.VALUE:=FORM.WYM4_SF;
   _table.WYM4_S.VALUE:=FORM.WYM4_S;
   _table.WYM4_F.VALUE:=FORM.WYM4_F;
   _table.WYM5_SF.VALUE:=FORM.WYM5_SF;
   _table.WYM5_S.VALUE:=FORM.WYM5_S;
   _table.WYM5_F.VALUE:=FORM.WYM5_F;
   _table.RKWOTDEL.VALUE:=FORM.RKWOTDEL().KOD; {? FORM.RKWOTDEL || _excel.write_async('SLO',SLO.ref()) ?};
   _table.ETYPWYD.VALUE:=FORM.ETYPWYD().NAZWA;
   _table.OP.VALUE:=FORM.OP;
   _table.ID.VALUE:=FORM.ID;
   _table.TID.VALUE:=FORM.TID;
   _table.TP.VALUE:=FORM.TP;
   _table.DO.VALUE:=FORM.DO;
   _table.ODD_ROZR.VALUE:=FORM.ODD_ROZR;
   _table.PROJEKT.VALUE:=FORM.PROJEKT;
   _table.PROCENT.VALUE:=FORM.PROCENT;
   _table.SW1.VALUE:=FORM.SW1;
   _table.SW2.VALUE:=FORM.SW2;
   _table.SW3.VALUE:=FORM.SW3;
   _table.SW4.VALUE:=FORM.SW4;
   _table.SW5.VALUE:=FORM.SW5;
   _table.SW6.VALUE:=FORM.SW6;
   _table.W1.VALUE:=FORM.W1().KOD; {? FORM.W1 || _excel.write_async('SLO',SLO.ref()) ?};
   _table.W2.VALUE:=FORM.W2().KOD; {? FORM.W2 || _excel.write_async('SLO',SLO.ref()) ?};
   _table.W3.VALUE:=FORM.W3().KOD; {? FORM.W3 || _excel.write_async('SLO',SLO.ref()) ?};
   _table.W4.VALUE:=FORM.W4().KOD; {? FORM.W4 || _excel.write_async('SLO',SLO.ref()) ?};
   _table.W5.VALUE:=FORM.W5().KOD; {? FORM.W5 || _excel.write_async('SLO',SLO.ref()) ?};
   _table.W6.VALUE:=FORM.W6().KOD; {? FORM.W6 || _excel.write_async('SLO',SLO.ref()) ?};
   _table.FW1.VALUE:=FORM.FW1;
   _table.FW2.VALUE:=FORM.FW2;
   _table.FW3.VALUE:=FORM.FW3;
   _table.FW4.VALUE:=FORM.FW4;
   _table.FW5.VALUE:=FORM.FW5;
   _table.FW6.VALUE:=FORM.FW6;

   exec('SKID_WYR_exp_pom','xls_ks',_excel,'FORM',FORM.ref());
   _result:=1
?};
_result


\FORM_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=0;
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_table.ROK,REF.FIRMA,,1))=null
|| _result.msg_norec('ROK'); return()
|? (_autoksie:=exec('FindInSet','#table','AUTOKSIE','NAZ',_table.AUTOKSIE,_rok,,1))=null
|| _result.msg_norec('AUTOKSIE'); return()
?};
FORM.index('AUTOKSIE');
FORM.prefix(_autoksie,_table.POZ);
{? FORM.first()
|| {? _mode=0
   || return()
   || _result.ACTION:='put'
   ?}
|| _result.ACTION:='add'
?};
{? _result.ACTION='add' || FORM.blank(1) ?};
FORM.AUTOKSIE:=_autoksie;
FORM.POZ:=_table.POZ;
FORM.KARTOTEK:=_table.KARTOTEK;
FORM.INDEKS:=_table.INDEKS;
FORM.MASKA:=KONTO.K1:=_table.MASKA;
FORM.KWN:=_table.KWN;
FORM.KMA:=_table.KMA;
{? _table.SKID_MB<>''
|| FORM.SKID_MB:=exec('FindInSet','#table','SKID_MBN','KOD',_table.SKID_MB,,,1);
   {? FORM.SKID_MB=null
   || _result.msg_norec('SKID_MB'); return()
   ?}
?};
{? _table.SKID_MB<>'' & _table.PBUD<>''
|| UD_TYP.index('SYMBOL'); UD_TYP.prefix('POZ_BUD',);
   {? UD_TYP.first()
   || FORM.PBUD:=exec('szukaj_ud_skl','schemat','POZ_BUD',_table.PBUD);
      {? FORM.PBUD=null
      || _result.msg_norec('PBUD'); return()
      ?}
   || _result.MSG:='Nie znaleziono typu schematu: %1.'@['POZ_BUD']; return()
   ?}
?};
FORM.JORG_SF:=_table.JORG_SF;
FORM.JORG_S:=_table.JORG_S;
FORM.JORG_F:=_table.JORG_F;
FORM.OKOSZ_SF:=_table.OKOSZ_SF;
FORM.OKOSZ_S:=_table.OKOSZ_S;
FORM.OKOSZ_F:=_table.OKOSZ_F;
FORM.PBUD_SF:=_table.PBUD_SF;
FORM.PBUD_S:=_table.PBUD_S;
FORM.PBUD_F:=_table.PBUD_F;
FORM.WYM4_SF:=_table.WYM4_SF;
FORM.WYM4_S:=_table.WYM4_S;
FORM.WYM4_F:=_table.WYM4_F;
FORM.WYM5_SF:=_table.WYM5_SF;
FORM.WYM5_S:=_table.WYM5_S;
FORM.WYM5_F:=_table.WYM5_F;
FORM.RKWOTDEL:={? _table.RKWOTDEL<>'' || exec('find_slo_slu','slo_slu','~KWOTY W DELEGACJACH',_table.RKWOTDEL) ?};
FORM.ETYPWYD:={? _table.ETYPWYD<>'' || exec('FindInSet','#table','ETYPWYD','UNIK',_table.ETYPWYD,,,1) ?};
FORM.OP:=_table.OP;
FORM.ID:=_table.ID;
FORM.TID:=_table.TID;
FORM.TP:=_table.TP;
FORM.DO:=_table.DO;
FORM.ODD_ROZR:=_table.ODD_ROZR;
FORM.PROJEKT:=_table.PROJEKT;
FORM.PROCENT:=_table.PROCENT;
FORM.SW1:=_table.SW1;
FORM.SW2:=_table.SW2;
FORM.SW3:=_table.SW3;
FORM.SW4:=_table.SW4;
FORM.SW5:=_table.SW5;
FORM.SW6:=_table.SW6;
FORM.W1:={? FORM.SW1='S' & _table.W1<>'' & (_slu:=exec('slu_wyr','wyrozniki',_rok,FORM.MASKA,1))<>null
         || exec('find_slo_slu','slo_slu',_slu,_table.W1)
         ?};
FORM.W2:={? FORM.SW2='S' & _table.W2<>'' & (_slu:=exec('slu_wyr','wyrozniki',_rok,FORM.MASKA,2))<>null
         || exec('find_slo_slu','slo_slu',_slu,_table.W2)
         ?};
FORM.W3:={? FORM.SW3='S' & _table.W3<>'' & (_slu:=exec('slu_wyr','wyrozniki',_rok,FORM.MASKA,3))<>null
         || exec('find_slo_slu','slo_slu',_slu,_table.W3)
         ?};
FORM.W4:={? FORM.SW4='S' & _table.W4<>'' & (_slu:=exec('slu_wyr','wyrozniki',_rok,FORM.MASKA,4))<>null
         || exec('find_slo_slu','slo_slu',_slu,_table.W4)
         ?};
FORM.W5:={? FORM.SW5='S' & _table.W5<>'' & (_slu:=exec('slu_wyr','wyrozniki',_rok,FORM.MASKA,5))<>null
         || exec('find_slo_slu','slo_slu',_slu,_table.W5)
         ?};
FORM.W6:={? FORM.SW6='S' & _table.W6<>'' & (_slu:=exec('slu_wyr','wyrozniki',_rok,FORM.MASKA,6))<>null
         || exec('find_slo_slu','slo_slu',_slu,_table.W6)
         ?};
FORM.FW1:=_table.FW1;
FORM.FW2:=_table.FW2;
FORM.FW3:=_table.FW3;
FORM.FW4:=_table.FW4;
FORM.FW5:=_table.FW5;
FORM.FW6:=_table.FW6;
FORM.memo_set(_table.FML);
AUTOKSIE.cntx_psh();
AUTOKSIE.prefix();
AUTOKSIE.seek(FORM.AUTOKSIE);
{? exec('chk_form','rejestry')<>''
|| _result.RESULT:=0
|| _result.RESULT:=1
?};
AUTOKSIE.cntx_pop();
~~


\FORM_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=FORM.add(1)
   |? _validate.ACTION='put'
   || _result:=FORM.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie pozycji schematu dokumentów nie powiodło się.'@
   || _validate.MSG:='Poprawa Pozycji schematu dokumentów nie powiodła się.'@
   ?}
|| FORM.memo_put(,'FML');
   FORM.put()
?};
_result


\P_AUTOKS
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='P_AUTOKS';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Schematy dokumentów rejestru=1,1';
_def.NAME:='Schematy dokumentów rejestru';
_def.DESC:='Schematy dokumentów rejestru';

_def.PREFIX:="";
_def.TABLE:="exec('P_AUTOKS_tab','xls_ks',_a)";
_def.TAB_IMP:="P_AUTOKS";
_def.FIELDS:="exec('P_AUTOKS_fld','xls_ks',_a)";

_def.BEFORE:="P_AUTOKS.cntx_psh()";
_def.AFTER:="P_AUTOKS.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('P_AUTOKS_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('P_AUTOKS_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('P_AUTOKS_imp','xls_ks',_a,_b,_c)";
~~


\P_AUTOKS_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu struktury kont analitycznych bieżącej firmy
::   WE: _a - tryb pracy: 1-eksport wszystkiego, 2-eksport jednego rekordu
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select P_AUTOKS.REFERENCE as REF, ROK_F.NAZ as ROK, ODD.OD as ODD, REJ.KOD as REJ, '
      '(\':\' || P_AUTOKS.IDADD || P_AUTOKS.REFERENCE) as UIDREF '
      'from P_AUTOKS join REJ join ODD join ROK_F '
      'where ROK_F.FIRMA=:_a '
      'order by ROK,ODD,REJ',
      REF.FIRMA
   )
|| P_AUTOKS
?}


\P_AUTOKS_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowy rok');
_def.define('ODD','Jednostka księgowa',1,,'8 znakowa jednostka księgowa');
_def.define('REJ','Rejestr',1,,'8 znakowy rejestr');
_def.define('DOK_REJ','Rodzaj dokumentu',1,,'60 znakowy rodzaj dokumentu');
_def.define('AUTOKSIE','Schemat dokumentu',1,,'8 znakowy schemat dokumentu');
~~


\P_AUTOKS_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

_result:=0;
P_AUTOKS.prefix();
{? _tab=P_AUTOKS | P_AUTOKS.seek(_tab.REF)
|| _table.ROK.VALUE:=P_AUTOKS.REJ().ROK().NAZ; _excel.write_async('ROK_F',ROK_F.ref());
   _table.ODD.VALUE:=REJ.ODD().OD;
   _excel.write_async('ODD',REJ.ODD);
   _table.REJ.VALUE:=REJ.KOD;
   _excel.write_async('REJ',P_AUTOKS.REJ);
   _table.DOK_REJ.VALUE:=P_AUTOKS.DOK_REJ().NAZ;
   {? P_AUTOKS.DOK_REJ || _excel.write_async('DOK_REJ',P_AUTOKS.DOK_REJ) ?};
   _table.AUTOKSIE.VALUE:=P_AUTOKS.AUTOKSIE().NAZ;
   _excel.write_async('AUTOKSIE',P_AUTOKS.AUTOKSIE);
   _result:=1
?};
_result


\P_AUTOKS_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=0;
_dok_rej:=null;
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_table.ROK,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono roku: %1.'@[_table.ROK]
|? (_odd:=exec('FindInSet','#table','ODD','ODDZIALY',_table.ODD,REF.FIRMA,,1))=null
|| _result.MSG:='Nie znaleziono jednostki księgowej: %1.'@[_table.ODD]
|? (_rej:=exec('FindInSet','#table','REJ','KOD',_table.REJ,_rok,,1,_odd))=null
|| _result.MSG:='Nie znaleziono rejestru: %1 dla jednostki księgowej: %2 w roku: %3.'@[_table.REJ,_table.ODD,_table.ROK]
|? _table.DOK_REJ<>'' & (_dok_rej:=exec('FindInSet','#table','DOK_REJ','NAZ',_table.DOK_REJ,_rej,,1))=null
|| _result.MSG:='Nie znaleziono rodzaju dokumentu: %1 w roku: %2 dla jednostki księgowej: %3 i rejestru: %4.'@[_table.DOK_REJ,_table.ROK,_table.ODD,_table.REJ]
|? (_autoksie:=exec('FindInSet','#table','AUTOKSIE','NAZ',_table.AUTOKSIE,_rok,,1))=null
|| _result.MSG:='Nie znaleziono schematu dokumentu: %1 dla w roku: %2.'@[_table.AUTOKSIE,_table.ROK]
|| _result.RESULT:=1;
   P_AUTOKS.index('UNIK');
   P_AUTOKS.prefix(_rej,_autoksie,_dok_rej);
   {? P_AUTOKS.first()
   || _result.RESULT:=0
   || _result.ACTION:='add'
   ?};
   {? _result.RESULT=1
   || {? _result.ACTION='add' || P_AUTOKS.blank(1) ?};
      P_AUTOKS.REJ:=_rej;
      P_AUTOKS.DOK_REJ:=_dok_rej;
      P_AUTOKS.AUTOKSIE:=_autoksie
   ?}
?};
~~


\P_AUTOKS_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| _result:=P_AUTOKS.add(1)
?};
{? _result=0
|| _validate.MSG:='Dodanie schematu dokumentu %1 do rejestru nie powiodło się.'@[_table.AUTOKSIE]
?};
_result


\FOR_AKC
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Inicjalizuje mechanizm importu/eksportu do Excel
::   WE: _a - obj_new - środowisko mechanizmu
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.ID:='FOR_AKC';
_def.DOMAIN:=exec('name','#b_domain','FKS');
_def.FILE:=exec('filename','xls_ks');
_def.FUNPAR:='ZWS_PAR_FASK';
_def.HIDDEN:='T';
_def.SHEET:='Formuły kontrolne rejestru=1,1';
_def.NAME:='Formuły kontrolne rejestru';
_def.DESC:='Formuły kontrolne rejestru';

_def.PREFIX:="";
_def.TABLE:="exec('FOR_AKC_tab','xls_ks',_a)";
_def.TAB_IMP:="FOR_AKC";
_def.FIELDS:="exec('FOR_AKC_fld','xls_ks',_a)";

_def.BEFORE:="FOR_AKC.cntx_psh()";
_def.AFTER:="FOR_AKC.cntx_pop()";
_def.SELECT:="";

_def.EXPORT:="exec('FOR_AKC_exp','xls_ks',_a,_b)";
_def.VALIDATE:="exec('FOR_AKC_valid','xls_ks',_a,_b,_c)";
_def.IMPORT:="exec('FOR_AKC_imp','xls_ks',_a,_b,_c)";
~~


\FOR_AKC_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Zwraca tabelę do eksportu struktury kont analitycznych bieżącej firmy
::   WE: _a - tryb pracy: 1-eksport wszystkiego, 2-eksport jednego rekordu
::----------------------------------------------------------------------------------------------------------------------
{? _a=1
|| sql(
      'select FOR_AKC.REFERENCE as REF, ROK_F.NAZ as ROK, ODD.OD as ODD, REJ.KOD as REJ, (\':\' || FOR_AKC.IDADD || FOR_AKC.REFERENCE) as UIDREF '
      'from FOR_AKC join REJ join ODD join ROK_F '
      'where ROK_F.FIRMA=:_a '
      'order by ROK,ODD,REJ',
      REF.FIRMA
   )
|| FOR_AKC
?}


\FOR_AKC_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Określa pola tabeli
::   WE: _a - obiekt z definicją pól który należy zasilić
::----------------------------------------------------------------------------------------------------------------------
_def:=_a;
_def.define('ROK','Rok',1,,'20 znakowy rok');
_def.define('ODD','Jednostka księgowa',1,,'8 znakowa jednostka księgowa');
_def.define('REJ','Rejestr',1,,'10 znakowy symbol');
_def.define('NAZ','Nazwa',1,,'40 znakowa nazwa');
_def.define('POCZ','Formuła początkowa',1,,'8 znakowy skrót formuły');
_def.define('POZ','Formuła dla pozycji',1,,'8 znakowy skrót formuły');
_def.define('KON','Sprawdzenie warunku',1,,'8 znakowy skrót formuły');
_def.define('AKCJA','Akcja',1,,'20 znakowa nazwa akcji: akceptacja lub wycofywanie');
~~


\FOR_AKC_exp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Wypełnia obiekt który zapisze w Excel wiersz danymi z rekordu
::       Użycie: export
::   WE: _a - obj_new - środowisko mechanizmu
::       _b - obj_new - obiekt który zasilić wartościami z pól
::   WY: ANY - dowolny wynik (zwracany przez _excel.write_async())
::----------------------------------------------------------------------------------------------------------------------
_excel:=_a;
_table:=_b;
_tab:=_excel.table();

_result:=0;
FOR_AKC.prefix();
{? _tab=FOR_AKC | FOR_AKC.seek(_tab.REF)
|| _table.ROK.VALUE:=FOR_AKC.REJ().ROK().NAZ; _excel.write_async('ROK_F',ROK_F.ref());
   _table.ODD.VALUE:=FOR_AKC.REJ().ODD().OD;
   _table.REJ.VALUE:=REJ.KOD;
   _table.NAZ.VALUE:=FOR_AKC.NAZ;
   _table.POCZ.VALUE:=FOR_AKC.POCZ().SKROT;   {? FOR_AKC.POCZ || _excel.write_async('FORMULA',FORMULA.ref()) ?};
   _table.POZ.VALUE:=FOR_AKC.POZ().SKROT;     {? FOR_AKC.POZ || _excel.write_async('FORMULA',FORMULA.ref()) ?};
   _table.KON.VALUE:=FOR_AKC.KON().SKROT;     {? FOR_AKC.KON || _excel.write_async('FORMULA',FORMULA.ref()) ?};
   _table.AKCJA.VALUE:=FOR_AKC.AKCJA;
   _result:=1
?};
_result


\FOR_AKC_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Waliduje czy można poprawić/dodać rekord
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów do przekazania dla import)
::  OLD: \KS_ZEST_valid/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_result:=_c;

_result.RESULT:=0;
_dok_rej:=null;
{? (_rok:=exec('FindInSet','#table','ROK_F','NAZWA',_table.ROK,REF.FIRMA,,1))=null
|| _result.msg_norec('ROK'); return()
|? (_odd:=exec('FindInSet','#table','ODD','ODDZIALY',_table.ODD,REF.FIRMA,,1))=null
|| _result.msg_norec('ODD'); return()
|? (_rej:=exec('FindInSet','#table','REJ','KOD',_table.REJ,_rok,,1,_odd))=null
|| _result.MSG:='Nie znaleziono rejestru: %1 dla jednostki księgowej: %2 w roku: %3.'@[_table.REJ,_table.ODD,_table.ROK];
   return()
?};
FOR_AKC.index('NAZ');
FOR_AKC.prefix(_rej,_table.NAZ);
{? FOR_AKC.first()
|| {? _mode=0
   || return()
   || _result.ACTION:='put'
   ?}
|| _result.ACTION:='add'
?};
{? _result.ACTION='add' || FOR_AKC.blank(1) ?};
FOR_AKC.REJ:=_rej;
FOR_AKC.NAZ:=_table.NAZ;
{? _table.POCZ<>''
|| FOR_AKC.POCZ:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.POCZ,'G',,1);
   {? FOR_AKC.POCZ=null
   || _result.msg_norec('POCZ'); return()
   ?}
|| FOR_AKC.POCZ:=null
?};
{? _table.POZ<>''
|| FOR_AKC.POZ:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.POZ,'G',,1);
   {? FOR_AKC.POZ=null
   || _result.msg_norec('POZ'); return()
   ?}
|| FOR_AKC.POZ:=null
?};
{? _table.KON<>''
|| FOR_AKC.KON:=exec('FindInSet','#table','FORMULA','FORMULA4',_table.KON,'G',,1);
   {? FOR_AKC.KON=null
   || _result.msg_norec('KON'); return()
   ?}
|| FOR_AKC.KON:=null
?};
{? _table.AKCJA=''
|| _result.MSG:='Brak wartości w polu: Akcja.';
   return()
|? 'akceptacja,wycofywanie'*_table.AKCJA<>0
|| POMOC.AKCJA:=_table.AKCJA='akceptacja'
|| _result.MSG:='Nieprawidłowa wartość w polu: Akcja. Dozwolone: akceptacja i wycofywanie';
   return()
?};
{? exec('chk_for_akc','rejestry')=''
|| _result.RESULT:=1
?};
~~


\FOR_AKC_imp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Tworzy lub modyfikuje rekord na podstawie wartości odczytanych z Excel
::       Użycie: import
::   WE: _a - obj_new() - tablica nazwana z polami odczytanymi z excel
::       _b - INTEGER - tryb pracy: 0 - nie zastępować istniejących wartości, 1 - zastępować istniejące
::       _c - obiekt Result, zawiera .RESULT, .ACTION, .OBJ (własna tablica parametrów)
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \KS_ZEST_import/xls_ks.fml
::----------------------------------------------------------------------------------------------------------------------
_table:=_a;
_mode:=_b;
_validate:=_c;
_result:=0;
{? _validate.RESULT=1
|| {? _validate.ACTION='add'
   || _result:=FOR_AKC.add(1)
   |? _validate.ACTION='put'
   || _result:=FOR_AKC.put(1)
   ?}
?};
{? _result=0
|| {? _validate.ACTION='add'
   || _validate.MSG:='Dodanie formuły kontrolnej %1 nie powiodło się.'@[_table.NAZ]
   || _validate.MSG:='Poprawa formuły kontrolnej %1 nie powiodła się.'@[_table.NAZ]
   ?}
?};
_result


\SKID_WYR_exp_pom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [18.42]
:: OPIS: Eksportuje definicje wyróżników dla wskazanej tabeli
::   WE: _a - środowisko eksportu
::       _b - akronim tabeli
::       _c - ref rekordu złączeniowego
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
SKID_WYR.cntx_psh();
SKID_WYR.index('SKID_WYR'); SKID_WYR.prefix(REF.FIRMA,_b,ref_name(_c),#_c);
{? SKID_WYR.first()
|| {!
   |? _env.write_async('SKID_WYR',SKID_WYR.ref());
      SKID_WYR.next()
   !}
?};
SKID_WYR.cntx_pop();
~~

:Sign Version 2.0 jowisz:1045 2024/01/10 15:30:18 710e9a20b11df47990f3f8b185ebac0544c68d534ba8eedec047ab8a9de373a0a051817b0ea312eb9b4ee48b4a0436e742d7c06808442d569e049afcc8502c18efc66ca906fca6c6551041f92c30ba999543f00fa7fd88731172140f972b3d35248dd1497ac5048fe214c14369abc13bf3ef46d3bd722d96fc43f301785507b7
