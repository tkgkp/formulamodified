:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: portal_zaslu.fml
:: Utworzony: 18.08.2021
:: Autor: achol
::======================================================================================================================
:: Zawartość: Formuły pomocnicze dla zastępstw służbowych w ramach funkcjonalności powiązanej z Portal HR.
::======================================================================================================================


\tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Tworzy tabelę do przechowywania informacji o zastępcach służbowych (z domyślnego kodu zależności) pracownika.
::   WE:
::   WY: Tabela do przechowywania informacji o zastępcach służbowych pracownika
::----------------------------------------------------------------------------------------------------------------------
tab_tmp(,
   'LP',       'INTEGER'                                       ,'Lp.'@,
   'OSOBA',    'STRING[16]'                                    ,'Wskazanie na osobę zastępowaną'@,
   'P',        'STRING[16]'                                    ,'Wskazanie na pracownika zastępowanego'@,
   'OSOBAZ',   'STRING[16]'                                    ,'Wskazanie na osobę zastępującą'@,
   'PZ',       'STRING[16]'                                    ,'Wskazanie na pracownika zastępującego'@,
   'OD',       'DATE'                                          ,'Data rozpoczęcia zastępstwa'@,
   'DO',       'DATE'                                          ,'Data zakończenia zastępstwa'@,
   'LVL',      'INTEGER'                                       ,'Stopień bezpośredniości zastępstwa'@,
   'TYPE',     'STRING[1]'                                     ,'Typ zastępstwa'@,
   'REF',      'STRING[16]'   ,'Ref. zapisu P_PZ'@
)


\tab_track
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Tworzy tabelę do przechowywania informacji o wzajemnych zastępstwach służbowych.
::   WE:
::   WY: Tabela do przechowywania informacji o zastępcach służbowych pracownika
::----------------------------------------------------------------------------------------------------------------------
tab_tmp(,
   'LP',          'INTEGER'                                       ,'Lp.'@,
   'OSOBA',       'STRING[16]'                                    ,'Wskazanie na osobę zastępowaną'@,
   'P',           'STRING[16]'                                    ,'Wskazanie na pracownika zastępowanego'@,
   'OSOBAZ',      'STRING[16]'                                    ,'Wskazanie na osobę zastępującą'@,
   'PZ',          'STRING[16]'                                    ,'Wskazanie na pracownika zastępującego'@,
   'OD',          'DATE'                                          ,'Data rozpoczęcia zastępstwa'@,
   'DO',          'DATE'                                          ,'Data zakończenia zastępstwa'@,
   'LVL',         'INTEGER'                                       ,'Stopień bezpośredniości zastępstwa'@,
   'LPZ',         'INTEGER'                                       ,'Lp. tech'@,
   'P_NAZW',      'STRING[%1]'[$MS.fld_len('OSOBA','NAZWISKO')]   ,'Nazwisko prac.'@,
   'P_IMIE',      'STRING[%1]'[$MS.fld_len('OSOBA','PIERWSZE')]   ,'Imię prac.'@,
   'P_T',         'STRING[%1]'[$MS.fld_len('P','T')]              ,'Nr teczki prac.'@,
   'P_WYDZ',      'STRING[%1]'[$MS.fld_len('UD_SKL','SYMBOL')]    ,'Jedn. org. prac.'@,
   'PZ_NAZW',     'STRING[%1]'[$MS.fld_len('OSOBA','NAZWISKO')]   ,'Nazwisko prac. zast.'@,
   'PZ_IMIE',     'STRING[%1]'[$MS.fld_len('OSOBA','PIERWSZE')]   ,'Imię prac. zast.'@,
   'PZ_T',        'STRING[%1]'[$MS.fld_len('P','T')]              ,'Nr teczki prac. zast.'@,
   'PZ_WYDZ',     'STRING[%1]'[$MS.fld_len('UD_SKL','SYMBOL')]    ,'Jedn. org. prac. zast.'@
)


\zaslu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Tworzy tabelę tymczasową zawierajacą listę zastępców dla wskazanej osoby na podstawie przekazanego typu.
::       Formuła uruchamiana dla ustawionego kontekstu P_PZ.
::   WE:  _a  [REFERENCE] - wskazanie osoby, dla której mają być wyszukani zastępcy
::        _b  [STRING]    - kod zależności
::       [_c] [DATE]      - data, dla której szukać zastępców urzędowych (domyślnie bieżąca data)
::       [_d] [INTEGER]   - przeszukaj zastępstwa bez względu na obecność poszczególnych zastępców (domyślnie 0 - bierze
::                          pod uwagę nieobecności zastępców, nieobecnych nie dodaje)
::       [_e] [INTEGER]   - maksymalny poziom, do którego ma nastąpić wyszukiwanie (domyślnie 0 - wszystkie)
::       [_f] [SYSLOG]    - tabela z aktualnie zapisanymi zastępcami
::       [_g] [INTEGER]   - przekazywany kolejny "stopień bezpośredniości zastępstwa" (domyślnie 0)
::       [_h] [REFERENCE] - dla kogo wyszukiwano domyślnie
::       [_i] [INTEGER]   - czy na podstawie początkowego zapisu podmieniana będzie data z _c jeśli przedział otwarty
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: czy pierwsze wywołanie
_ftm:=0;
_TAB:={? var_pres('_f')=type_of(SYSLOG)
      || _f
      || _ftm:=1;
         exec('tab','portal_zaslu')
      ?};

_absence:=obj_new('skip','during');
_lvl:=obj_new('current','max');

       _osoba:={? var_pres('_a')=type_of(null) & _a<>null & ref_name(_a)=OSOBA.name()   || _a || return(_TAB) ?};
        _type:={? var_pres('_b')=type_of(null) & _b<>null & ref_name(_b)=SLO_KOD.name() || _b || return(_TAB) ?};
        _date:={? var_pres('_c')=type_of(date)                                          || _c || date()       ?};
_absence.skip:={? var_pres('_d')=type_of(0)                                             || _d || 0            ?};
     _lvl.max:={? var_pres('_e')=type_of(0)                                             || _e || 0            ?};
 _lvl.current:={? var_pres('_g')=type_of(0)                                             || _g || 0            ?};
        _main:={? var_pres('_h')=type_of(null) & _h<>null & ref_name(_h)=OSOBA.name()   || _h || _a           ?};

_substitutionTypes:=exec('substitution_types','portal_zaslu');

:: ustalenie maksymalnego poziomu wyszukiwania
{? _lvl.max<>0 & _lvl.max<=_lvl.current
|| return(_TAB)
|| _lvl.current+=1
?};
:: konfiguracja dla pierwszego wywołania
{? _ftm
||
   {? var_pres('lp')>0 || &lp ?};
   lp:=1;
   _TAB.blank();
   _TAB.LP:=lp;
   lp+=1;
   _TAB.OSOBA:=$P_PZ.P_OSO;
   _TAB.P:=$P_PZ.P;
   _TAB.OSOBAZ:=$P_PZ.PZ_OSO;
   _TAB.PZ:=$P_PZ.PZ;
   _TAB.OD:=P_PZ.OD;
   _TAB.DO:=P_PZ.DO;
   _TAB.TYPE:={? P_PZ.NB='T' || _substitutionTypes.temporary.value || _substitutionTypes.permanent.value ?};
   _TAB.LVL:=_lvl.current;
   _TAB.REF:=$P_PZ.ref();
   _TAB.add()
?};

OSOBA.cntx_psh(); OSOBA.prefix();
{? OSOBA.seek(_osoba,,1)
|| P_PZ.cntx_psh();
   P_PZ.index('P_PZO2');
   P_PZ.prefix('Z',_type,_osoba);
   _loop:=P_PZ.first();
   {!
   |? _loop
   |!
      _TAB.cntx_psh();
      {? var_pres('_pz')>100 || obj_del(_pz) ?};
      _pz:=obj_new('od','do');
      _pz.od:=_pz.do:=date(0,0,0);
      {? _TAB.first()
      || _pz.od:=_TAB.OD;
         _pz.do:=_TAB.DO
      ?};
      _TAB.cntx_pop();
      _add:=exec('is','overlap',P_PZ,_pz.od,_pz.do);
      _absence.during:=(P_PZ.NB='T');
      {? _absence.during
      || _add*={? _absence.skip || 1 || exec('czy_jest','nieobecnosc',P_PZ.P,_date) ?}
      || _add*=1
      ?};
      {? _add>0
      || _add*={? _absence.during || 1 || ~exec('czy_jest','nieobecnosc',P_PZ.PZ,_date) ?};
         {? _add
         || _TAB.cntx_psh();
            _ndxt:=_TAB.ndx_tmp(,,'OSOBA',,,'P',,,'OSOBAZ',,,'PZ',,,'OD',,,'DO',,);
            _TAB.index(_ndxt);
            _TAB.prefix($P_PZ.P_OSO,$P_PZ.P,$P_PZ.PZ_OSO,$P_PZ.PZ,P_PZ.OD,P_PZ.DO);
            _existed:=_TAB.first();
            _TAB.ndx_drop(_ndxt);
            _TAB.cntx_pop();
            {? ~_existed
            || _TAB.blank();
               _TAB.LP:=lp;
               lp+=1;
               _TAB.OSOBA:=$P_PZ.P_OSO;
               _TAB.P:=$P_PZ.P;
               _TAB.OSOBAZ:=$P_PZ.PZ_OSO;
               _TAB.PZ:=$P_PZ.PZ;
               _TAB.OD:=P_PZ.OD;
               _TAB.DO:=P_PZ.DO;
               _TAB.TYPE:={? P_PZ.NB='T' || _substitutionTypes.temporary.value || _substitutionTypes.permanent.value ?};
               _TAB.LVL:=_lvl.current;
               _TAB.REF:=$P_PZ.ref();
               _TAB.add()
            ?};
            {? ~_existed | _ftm
            || exec('zaslu','portal_zaslu',P_PZ.PZ_OSO,_type,_date,_absence.skip,_lvl.max,_TAB,_lvl.current,_main)
            ?}
         || exec('zaslu','portal_zaslu',P_PZ.PZ_OSO,_type,_date,_absence.skip,_lvl.max,_TAB,_lvl.current,_main)
         ?}
      ?};
      _loop:=P_PZ.next()
   !};
   P_PZ.cntx_pop()
?};
OSOBA.cntx_pop();
_TAB


\looped
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Sprawdza czy nie nastąpiło zapętlenie w zastępstwach służbowych. Przepuszcza zastępstwa czasowe (na czas
::       nieobecności).
::   WE: _a  [SYSLOG]    - bufor z pobranymi zastępcami
::       _b  [REFERENCE] - wskazanie osoby, dla której mają być wyszukani zastępcy
::      [_c] [INTEGER]   - wykonanie dla zapisu kartoteki P_PZ - czy akcja popraw [domyślnie 0 - nie]
::      [_d] [INTEGER]   - czy sprawdzenie dla zastępstwa stałego? [domyślnie 1 - tak, pełne sprawdzenie]
::   WY: Obiekt, który zwraca informacje:
::       - 0/1 - zapętlenie w zastępstwach nie nastąpiło / nastąpiło zapętlenie
::       - Ref rekordu P_PZ w postaci łańcucha znaków, dla którego wystąpiło zapętlenie
::----------------------------------------------------------------------------------------------------------------------
_result:=obj_new('looped','ref');
_result.looped:=0;
_result.ref:='';

   _TAB:={? var_pres('_a')=type_of(SYSLOG) & var_pres('LVL',_a)                 || _a || exec('tab','portal_zaslu') ?};
 _osoba:={? var_pres('_b')=type_of(null) & _b<>null & ref_name(_b)=OSOBA.name() || _b || return(_result)            ?};
_popraw:={? var_pres('_c')=type_of(0)                                           || _c || 0                          ?};
   _mod:={? var_pres('_d')=type_of(0)                                           || _d || 1                          ?};

{? ~_TAB.size() || return(_result) ?};

_substitutionTypes:=exec('substitution_types','portal_zaslu');

_check:=obj_new(
:: Czy pierwszy zapis dotyczy zastępstwa stałego?
   'firstPermanent',
:: Formuła sprawdzająca czy pierwszy zapis dotyczy zastępstwa stałego
   'isFirstPermanent',
:: Obiekt z dostępnymi typami
   'types',
:: Formuła decydująca czy dany zapis kwalifikuje się do zwrócenia informacji o cyklu (zapętleniu)
   'do'
);
_check.isFirstPermanent:=
   "_type:={? var_pres('_a')=type_of('') & +_a=1 || _a || return(0) ?};
    .firstPermanent:=.types.permanent.is(_type)
   ";
_check.do:=
   "_type:={? var_pres('_a')=type_of('') & +_a=1 || _a || return(0) ?};

    .types.permanent.is(_type) | (.firstPermanent & .types.temporary.is(_a))
   ";
_check.types:=exec('substitution_types','portal_zaslu');

_TAB.cntx_psh();
_TAB.first();
_check.isFirstPermanent(_TAB.TYPE);
_ndx:=_TAB.ndx_tmp(,,'OSOBAZ',,);
_TAB.index(_ndx);
_TAB.prefix($_osoba,);
{? _TAB.first()
|| {? _check.do(_TAB.TYPE) | _mod
   || _result.looped:=1;
      _result.ref:=_TAB.REF
   ?};
   {? _loop:=_popraw
   || _isNext:=obj_new('different','permanent');
      _isNext.different:=0;
      _isNext.permanent:=0;
      {!
      |? _loop
      |!
         {? $P_PZ.ref()<>_TAB.REF
         || _isNext.different:=1;
            {?  _check.do(_TAB.TYPE) | _mod
            || _isNext.permanent:=1;
               _result.ref:=_TAB.REF
            ?}
         ?};
         _loop:=(_result.ref='' & _TAB.next())
      !};
      _result.looped*=(_isNext.different & _isNext.permanent)
   ?}
?};
_TAB.ndx_drop(_ndx);
_TAB.cntx_pop();

_result


\looped_kom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Komunikat zwracany w przypadku, gdy wystąpiło zapętlenie w zastępstwach służbowych.
::   WE: [_a] [INTEGER] - komunikat dla cyklu dot. wybranego zastępowanego [0 - domyślnie],
::                        komunikat dla całości (firmy) [1]
::       [_b] [INTEGER] - czy formuła wykonywana dla akcji "popraw" (domyślnie 0 - nie dla popraw), dla >0 popraw
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_compLoop:={? var_pres('_a')=type_of(0) || _a || 0 ?};
  _popraw:={? var_pres('_b')=type_of(0) || _b || 0 ?};

_info:='Zastępstwo nie może zostać zapisane z powodu wystąpienia cyklu zastępstw dla wybranego typu.'@;

{? ~_compLoop
|| '%1\n%2'@[_info,'Należy wyznaczyć innego pracownika jako zastępcę.'@]
|| {? _popraw
   || '%1\n\n%2\n%3. %4 %5\n%6.'@
      [_info,
       'W celu weryfikacji występujących cyklów w strukturze zastępstw służbowych należy wywołać raport'@,
       'kontrolny'@,
       'Raport jest dostępny w obszarze "Zdarzenia kadrowe" w:'@,
       '(Zestawienia i raporty ->'@,
       'Raporty kontrolne -> Zastępstwa wzajemne)'@
      ]
   || _info
   ?}
?}


\changeable
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Formuła sprawdza czy jest możliwość zmiany domyślnej struktury zależności w kontekście dostępu do Portal HR.
::   WE: _a [REFERENCE] - wskazanie typu zależności służbowych, który miałby stać się domyślnym
::   WY: 1 - zmiana domyślnego typu zależności możliwa, 0 - zmiana niemożliwa
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
{? ~exec('lic','#b_domain','POR') || return(_result) ?};

_code:=obj_new('ref','code');

_code.ref:={? var_pres('_a')=type_of(null) & _a<>null & ref_name(_a)=SLO_KOD.name() || _a || return(0) ?};

SLO_KOD.cntx_psh();
SLO_KOD.prefix();
_code.code:={? SLO_KOD.seek(_code.ref,,1) || SLO_KOD.KOD || '' ?};
SLO_KOD.cntx_pop();

{? _code.code='' || return(0) ?};

_PZ:=sql(
   'select P_PZ.REFERENCE as REF '
   'from P_PZ '
   'join SLO_KOD using (P_PZ.TYP,SLO_KOD.REFERENCE) '
   'where SLO_KOD.KOD=\':_a\'',
   _code.code
);

{? _loop:=_PZ.first()
|| {!
   |? _loop
   |!
      P_PZ.cntx_psh();
      P_PZ.prefix();
      {? P_PZ.seek(_PZ.REF,,1)
      || {? var_pres('_ZASLU')>100 || obj_del(_ZASLU) ?};
         _ZASLU:=exec('zaslu','portal_zaslu',P_PZ.PZ_OSO,P_PZ.TYP,,1);
         _result*=~(exec('looped','portal_zaslu',_ZASLU,P_PZ.P_OSO).looped)
      ?};
      P_PZ.cntx_pop();
      _loop:={? _result || _PZ.next() ?}
   !}
?};
_result


\changeable_kom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Komunikat zwracany w przypadku, gdy nie ma możliwości zmiany domyślnej struktury zależności w kontekście
::       dostępu do Portal HR.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
'%1\n%2\n%3\n\n%4'[
   'Zmiana domyślnego typu struktury zależności na wybrany nie jest możliwa.'@,
   'W systemie dla redagowanego typu istnieją zapisy dotyczące zastępstw, dla których wykryto wystąpienie zapętlenia.'@,
   'Należy zmodyfikować przypisane pracownikom zastępstwa, aby zmienić domyślny typ zależności na wybrany.'@,
   'Czy wyświetlić raport prezentujący zastępstwa wzajemne (zapętlone) dla wskazanego typu?'@
]


\uniq
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Formuła sprawdza czy możliwa jest zmiana parametru XINFO.POR0ZASU/XINFO.POR_ZASU (w zależności od konfiguracji)
::       na wartość 1 włączającą sprawdzanie unikalności zastępstw w ramach roli oraz okresu
::   WE:
::   WY: 0/1 - zmiana nie jest możliwa / zmiana jest możliwa
::----------------------------------------------------------------------------------------------------------------------
_klasa:='Z';
_CODES:=sql(
   'select distinct SLO_KOD.REFERENCE as REF, SLO_KOD.KOD '
   'from SLO_KOD '
   'join SLO_TYP using(SLO_KOD.SLO_TYP,SLO_TYP.REFERENCE) '
   'where SLO_TYP.SYMBOL=\'TYPPOZ\''
);

_counter:=0;
_d0:=date(0,0,0);
_disjoint:=obj_new('left','right');
_loop:=obj_new('main','side','inner','date');

_size:=_CODES.size();
_p_count:=0;

{? _loop.main:=_CODES.first()
||
   {? _counter || _p_count:=_size || _p_count+=1 ?};
   progress(int((_p_count/_size)*100),'Trwa sprawdzanie...'@);
   {!
   |? _loop.main
   |!
      {? var_pres('_PZ')>100 || obj_del(_PZ) ?};
      _PZ:=sql(
         'select distinct P.REFERENCE as REF '
         'from P '
         'join P_PZ using(P_PZ.P,P.REFERENCE) '
         'join SLO_KOD using(P_PZ.TYP,SLO_KOD.REFERENCE) '
         'where SLO_KOD.KOD=\':_a\'',
         _CODES.KOD
      );
      P_PZ.cntx_psh();
      P_PZ.index('P_PZ2');
      {? _loop.side:=_PZ.first()
      ||
         {!
         |? _loop.side
         |!
            SLO_KOD.cntx_psh();
            SLO_KOD.prefix();
            _code:={? SLO_KOD.seek(_CODES.REF,,1) || SLO_KOD.ref() || null ?};
            SLO_KOD.cntx_pop();
            P.cntx_psh();
            P.prefix();
            _prac:={? P.seek(_PZ.REF,,1) || P.ref() || null ?};
            P.cntx_pop();
            {? _prac
            || P_PZ.prefix(_klasa,_code,_prac);
               _loop.inner:=P_PZ.first();
               {!
               |? _loop.inner
               |!
                  _od:=P_PZ.OD;
                  _do:=P_PZ.DO;
                  P_PZ.cntx_psh();
                  _loop.date:=P_PZ.next();
                  {!
                  |? _loop.date
                  |!
                     _disjoint.left:=(P_PZ.OD<=_od & P_PZ.DO<=_do & P_PZ.DO<=_od & P_PZ.DO<>_d0);
                     _disjoint.right:=(P_PZ.OD>=_od & P_PZ.DO>=_do & P_PZ.OD>=_do & _do<>_d0);
                     {? ~(_disjoint.left | _disjoint.right)
                     || _counter+=1
                     ?};
                     _loop.date:={? ~_counter || P_PZ.next() ?}
                  !};
                  P_PZ.cntx_pop();
                  _loop.inner:={? ~_counter || P_PZ.next() ?}
               !}
            ?};
            _loop.side:={? ~_counter || _PZ.next() ?}
         !}
      ?};
      P_PZ.cntx_pop();
      _loop.main:={? ~_counter || _CODES.next() ?}
   !}
?};
prgs_clr();

~_counter


\uniq_kom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Komunikat zwracany w przypadku, gdy nastąpiła próba włączenia unikalności zastępstw służbowych, a stan
::       zapisów znajdujących się w systemie nie pozwala na taką próbę.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
'%1\n%2\n\n%3'[
   'Zmiana wybranego parametru nie jest możliwa.'@,
   'W systemie istnieją pracownicy, dla których wykazano wielu zastępców.'@,
   'Wybrane ustawienie jest dostępne, gdy dla każdego pracownika zdefiniowano maksymalnie jednego zastępcę.'@
]


\set_code
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Ustawia wartość parametru ReplacementRoleForProfDependency na podstawie przekazanego kodu typu zależności.
::   WE: _a [STRING] - kod typu zależności
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_code:={? var_pres('_a')=type_of('') & _a<>'' || _a || return() ?};

_id:='ReplacementRoleForProfDependency';
exec('czytaj','#stalesys',,XINFO,'POR_CONF');
_conf:=(XINFO.POR_CONF='W');
_firma:={? _conf || null || exec('ref_firma','ustawienia') ?};

PORPAR.cntx_psh();
PORPAR.index('SYMBOL');
PORPAR.prefix(_firma,_id);
{? PORPAR.first()
|| PORPAR.WARTOSC:=_code;
   PORPAR.put(1)
?};
PORPAR.cntx_pop();
~~


\track_all_looped
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Na podstawie przekazanego bufora danych o zastępstwach dla danego pracownika o ile są zapętlone, tworzy listę
::       podzbiorów, gdzie każdy podzbiór prezentuje oddzielną gałąź zapętleń jaką można uzyskać badając przekazany
::       bufor z danymi.
::       Zakładamy, że kontekst P_PZ jest ustawiony.
::   WE:
::   WY: Lista z podzbiorami zapętlonych zastępstw
::----------------------------------------------------------------------------------------------------------------------
exec('list_decl','#list');
_tracks:=obj_new(@.CLASS.List);
_skipAbsences:=(P_PZ.NB='N');
_substitution_types:=exec('substitution_types','portal_zaslu');

_BUF:=exec('zaslu','portal_zaslu',P_PZ.P_OSO,P_PZ.TYP,,_skipAbsences);

{? _BUF.first()
|| {? exec('looped','portal_zaslu',_BUF,P_PZ.P_OSO).looped
   || _find:=obj_new('skip_absences','level');
      _find.skip_absences:=_skipAbsences;
      _find.level:=1;
      {? var_pres('_BUF1P')>100 || obj_del(_BUF1P) ?};
::    Bufor z danymi o zastępcach 1 poziomu (bezpośredni zastępcy) - od tych zastępstw zostaną zbudowane gałęzie
      _BUF1P:=exec('zaslu','portal_zaslu',P_PZ.P_OSO,P_PZ.TYP,,_find.skip_absences,_find.level);
      _build:=_BUF1P.first();
      {? _build
      || {!
         |? _build
         |!
            {? _BUF1P.TYPE=_substitution_types.permanent.value
            || {? var_pres('_TRACK')>100 || obj_del(_TRACK) ?};
               _TRACK:=exec('track','portal_zaslu',_BUF1P,_BUF);
               {? _TRACK.size()>0
               || _tracks.add(_TRACK)
               ?}
            ?};
            _build:=_BUF1P.next()
         !}
      ?}
   ?}
?};
_tracks


\track
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Buduje gałąź zastępstw zapętlonych dla zastępcy z ustawionego bufora (arg. _a) na podstawie danych z
::       przekazanego bufora ogólnego (arg. _b). Gałąź rozpoczynać będzie się od zastępstwa wykazanego w buforze _a
::       kończąc się w momencie otrzymania końcowego zapętlenia na rozpatrywanej ścieżce (gdy osobą zastępującą ponownie
::       będzie osoba, dla której budowana jest gałąź - osoba zastępowana z arg. _a).
::   WE: _a [REFERENCE] - wskazanie OSOBA
::       _b [SYSLOG]    - bufor z danymi o zastępstwach
::   WY: Tabela ze zbudowaną gałęzią
::----------------------------------------------------------------------------------------------------------------------
_TRACK:=exec('tab_track','portal_zaslu');
_BUF1P:={? var_pres('_a')=type_of(SYSLOG) & _a.size || _a || return(_TRACK) ?};
  _BUF:={? var_pres('_b')=type_of(SYSLOG) & _b.size || _b || return(_TRACK) ?};

{? var_pres('lp')>100 || obj_del(lp) ?};
lp:=1;
:: akcje w pętli:
:: - znalezione zakończenie gałęzi z osobą "główną"
:: - konieczność powtórzenia z pominięciem "ślepego zakończenia"
:: - pominięcie danego zapisu
:: - czy jest następny
:: - zaspiy powiązane tzn. zastępujący z poprzedniego to zastępowany z kolejnego
_act:=obj_new('main_found','must_repeat','skip','is_next','connected');
_act.main_found:=_act.must_repeat:=_act.skip:=_act.is_next:=_act.connected:=0;

:: kopia pierwszego zapisu w gałęzi
_start:=exec('copy_to_track','portal_zaslu',_TRACK,_BUF1P);

{? _start
||
   exec('list_decl','#list');
   _SKIP:=obj_new(@.CLASS.List);

   _BUF.cntx_psh();

   _ndx:=_BUF.ndx_tmp(,,'OSOBA',,,'P',,,'OSOBAZ',,,'PZ',,,'OD',,,'DO',,);
   _BUF.index(_ndx);
   _BUF.prefix(_BUF1P.OSOBA,_BUF1P.P,_BUF1P.OSOBAZ,_BUF1P.PZ,_BUF1P.OD,_BUF1P.DO);
:: pominięcie w budowanej gałęzi zapisu z _BUF1P
   {? _BUF.first()
   || _SKIP.add(_BUF.LP)
   ?};
   _BUF.ndx_drop(_ndx);

   _ndx:=_BUF.ndx_tmp(,,'OSOBA',,,'P',,);
   _BUF.index(_ndx);
   _BUF.prefix(_BUF1P.OSOBAZ,_BUF1P.PZ);
   _continue:=(_BUF.first());
   {? _continue
   || {!|?
         _act.must_repeat:=0;
         {!
         |? _continue
         |!
            _act.skip:=exec('to_skip','portal_zaslu',_SKIP,_BUF.LP);
            _copied:={? _act.skip || 1 || exec('copy_to_track','portal_zaslu',_TRACK,_BUF) ?};
::          Jeżeli nie skopiowano bieżącego rekordu - przy kolejnym obrocie brak przejścia tą ścieżką
::          Pomijany będzie poprzedni zapis co do obecnego
            {? ~_copied
            || _lpz:=_TRACK.LPZ;
               _BUF.cntx_psh();
               _ndxt:=_BUF.ndx_tmp(,,'LP',,);
               _BUF.index(_ndxt);
               _BUF.prefix(_lpz);
               {? _BUF.first()
               || _SKIP.add(_BUF.LP);
                  _act.must_repeat:=1
               ?};
               _BUF.ndx_drop(_ndxt);
               _BUF.cntx_pop()
            ?};
            _act.main_found:=(_BUF.OSOBAZ=_BUF1P.OSOBA & _BUF.PZ=_BUF1P.P);
            _osobaz:=_BUF.OSOBAZ;
            _lp:=_BUF.LP;
            {? _TRACK.size()=1 & _BUF.LP=2 & exec('to_skip','portal_zaslu',_SKIP,_BUF.LP)
            || _BUF.prefix(_BUF.OSOBA,_BUF.P)
            || _BUF.prefix(_BUF.OSOBAZ,_BUF.PZ)
            ?};
            _act.is_next:=
            {? _BUF.first()
            || _nok:=exec('to_skip','portal_zaslu',_SKIP,_BUF.LP);
               _size:=_BUF.size();
               _count:=0;
               _next:=~_nok;
               {!
               |? _nok
               |!
                  _next:=_BUF.next();
                  _count+=1;
                  _nok:={? _count<=_size || {? _next || exec('to_skip','portal_zaslu',_SKIP,_BUF.LP) ?} ?}
               !};
               _size<>0 & _count<=_size & _next
            ?};
            {? ~_act.is_next || _SKIP.add(_lp) ?};
            _act.connected:={? _act.main_found || 1 || {? _act.is_next || _BUF.OSOBA=_osobaz ?} ?};
            {? ~_act.must_repeat
            || _act.must_repeat:=(
                  (~_act.is_next & ~_act.main_found & _act.connected) | (~_act.connected & _TRACK.size()>1)
               )
            ?};
            _continue:=(~_act.main_found & ~_act.must_repeat & _copied & _act.is_next)
         !};
         {? _act.must_repeat
         || {? var_pres('_TRACK')>100 || obj_del(_TRACK) ?};
            _TRACK:=exec('tab_track','portal_zaslu');
            exec('copy_to_track','portal_zaslu',_TRACK,_BUF1P);
            _BUF.prefix(_BUF1P.OSOBAZ,_BUF1P.PZ)
         ?};
         _continue:={? _act.must_repeat || _BUF.first() ?}
      !}
   ?};
   _BUF.ndx_drop(_ndx);

   _BUF.cntx_pop()
?};

:: Jeżeli ostatecznie dodany został tylko rekord z bufora _BUF1P, nie wystąpiło zapętlenie
:: w takim wypadku czyścimy bufor zbierający _TRACK
{? _TRACK.size()=1 || _TRACK.erase() ?};

_TRACK


\copy_to_track
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Kopiuje dane z bufora przekazanego w arg. _b do bufora przekazanego w arg. _a (o określonej strukturze).
::   WE: _a [SYSLOG] - bufor, do którego kopiowane dane
::       _b [SYSLOG] - bufor, z którego kopiowane dane
::   WY: 1/0 - udało się / nie udało się skopiować zawartości bufora _b do bufora _a
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_BUF1:={? var_pres('_a')=type_of(SYSLOG) || _a || return() ?};
_BUF2:={? var_pres('_b')=type_of(SYSLOG) || _b || return() ?};

_BUF1.cntx_psh();
_ndx:=_BUF1.ndx_tmp(,,'OSOBA',,,'P',,,'OSOBAZ',,,'PZ',,,'OD',,,'DO',,,'LPZ',,);
_BUF1.index(_ndx);
_BUF1.prefix(_BUF2.OSOBA,_BUF2.P,_BUF2.OSOBAZ,_BUF2.PZ,_BUF2.OD,_BUF2.DO,_BUF2.LP);
_add:=~_BUF1.first();
_BUF1.cntx_pop();

{? _add
|| _BUF1.blank(1);
   _BUF1.LP:=lp;
   lp+=1;
   _BUF1.OSOBA:=_BUF2.OSOBA;
   _BUF1.P:=_BUF2.P;
   _BUF1.OSOBAZ:=_BUF2.OSOBAZ;
   _BUF1.PZ:=_BUF2.PZ;
   _BUF1.OD:=_BUF2.OD;
   _BUF1.DO:=_BUF2.DO;
   _BUF1.LVL:=_BUF2.LVL;
   _BUF1.LPZ:=_BUF2.LP;
   P.cntx_psh(); OSOBA.cntx_psh(); UD_SKL.cntx_psh();
   P.prefix(); OSOBA.prefix(); UD_SKL.prefix();
   {? P.seek(_BUF1.P,,1)
   || _BUF1.P_NAZW:=P.OSOBA().NAZWISKO;
      _BUF1.P_IMIE:=OSOBA.PIERWSZE;
      _BUF1.P_T:=P.T;
      _BUF1.P_WYDZ:=P.WYDZIAL().SYMBOL
   ?};
   {? P.seek(_BUF1.PZ,,1)
   || _BUF1.PZ_NAZW:=P.OSOBA().NAZWISKO;
      _BUF1.PZ_IMIE:=OSOBA.PIERWSZE;
      _BUF1.PZ_T:=P.T;
      _BUF1.PZ_WYDZ:=P.WYDZIAL().SYMBOL
   ?};
   UD_SKL.cntx_pop(); OSOBA.cntx_pop(); P.cntx_pop();
   _result:=_BUF1.add(1)
?};
_result


\to_skip
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Sprawdza, czy przekazany argumentem numer znajduje się wśród zbioru numerów, które należy pominąć.
::   WE: _a [OBJECT]    - lista numerów do pominięcia
::       _b [INTEGER]   - sprawdzany numer
::   WY: 1/0 - numer do pominięcia / numer nie do pominięcia
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_SKIP:={? var_pres('_a')>100        || _a || return(_result) ?};
  _nr:={? var_pres('_b')=type_of(0) || _b || return(_result) ?};

{? _loop:=_SKIP.first()
|| {!
   |? _loop
   |!
      {? _nr=_SKIP.get() || _result:=1 ?};
      _loop:={? ~_result || _SKIP.next() ?}
   !}
?};
_result


\substitution_types
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Definiuje obiekt informujący o możliwych typach zastępstw dla rekordów dodawanych do tabeli tymczasowej
::       zdefiniowanej poprzez \tab/portal_zaslu oraz udostępnia pewne formuły sprawdzające.
::   WE:
::   WY: obiekt z możliwymi typami zastępstw oraz formułami ich dotyczącymi
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new(
:: Zastępstwa czasowe (podczas nieobecności)
   'temporary',
:: Zastępstwa stałe (niezależnie od nieobecności)
   'permanent'
);

_obj.temporary:=obj_new('value','is');
_obj.permanent:=obj_new('value','is');

_is:="var_pres('_a')=type_of('') & +_a=1 & _a=.value";

_obj.temporary.value:='C';
_obj.temporary.is:=_is;
_obj.permanent.value:='S';
_obj.permanent.is:=_is;

_obj


\test_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [22.26]
:: OPIS: Formuła sprawdza siatkę zastępstw służbowych, aby zweryfikować czy nowo dodane zastępstwo nie powoduje
::       wystąpienia cyklu. Formuła jest wywoływana jako jedna z formuł weryfikujących "po edycji" rekordu tabeli P_PZ
::       dla przypadku, gdy sprawdzenia dla zastępowanego oraz zastępującego nie zwróciły informacji o wystąpieniu
::       cyklu. Formuła pomija już sprawdzone zastępstwa o ile zostały przekazane w argumentach wywołania.
::   WE:  _a  [STRING]    - typ zastępstwa
::       [_b] [REFERENCE] - złączenie do rekordu tabeli P dotyczącego pracownika zastępowanego
::       [_c] [REFERENCE] - złączenie do rekordu tabeli P dotyczącego pracownika zastępującego
::   WY: 0/1 - zapętlenie w zastępstwach nie nastąpiło / nastąpiło zapętlenie
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_employee:=obj_new('replaced','replacing','argsCorrect','wasTested');

              _type:={? var_pres('_a')=type_of(null) & _a<>null & ref_tab(_a)=SLO_KOD || _a || return(_result) ?};
 _employee.replaced:={? var_pres('_b')=type_of(null) & _b<>null & ref_tab(_b)=P       || _b || null            ?};
_employee.replacing:={? var_pres('_c')=type_of(null) & _c<>null & ref_tab(_c)=P       || _c || null            ?};

_employee.argsCorrect:="(.replaced=null & .replacing=null) | (.replaced<>null & .replacing<>null)";

{? ~_employee.argsCorrect() || return(_result) ?};

_employee.wasTested:=
   "_asReplaced:={? var_pres('_a')=type_of(0)                               || _a || return(0) ?};
          _prac:={? var_pres('_b')=type_of(null) & _b<>null & ref_tab(_b)=P || _b || return(0) ?};
    {? _asReplaced || _prac=.replaced || _prac=.replacing ?}
   ";

_clear:="{? var_pres('p',.)>100 || obj_del(.p) ?}; {? var_pres('pz',.)>100 || obj_del(.pz) ?}";

_zaslu:=obj_new('p','pz','clear');
_zaslu.clear:=_clear;

_track:=obj_new('p','pz','clear');
_track.clear:=_clear;

_list:=obj_new('content','clear');
_list.clear:="{? var_pres('content',.)>100 || obj_del(.content) ?}";

P_PZ.cntx_psh();
P_PZ.index('P_PZ2');
P_PZ.prefix('Z',_type);
P.cntx_psh();
P.prefix();
_size:=P_PZ.size();
{? _loop:=P_PZ.first()
|| _counter:=1;
   _prgsTitle:='Weryfikowanie struktury zastępstw...'@;
   progress(int(_counter*100/_size),_prgsTitle);
   {!
   |? _loop
   |!
      _asReplaced:=1;
      {? ~(_employee.wasTested(_asReplaced,P_PZ.P().ref) & _employee.wasTested(~_asReplaced,P_PZ.PZ().ref))
      ||
         _skipAbsences:=(P_PZ.NB='N');
         P.cntx_psh(); OSOBA.cntx_psh();
         P.prefix(); OSOBA.prefix();
         _pz_oso:=P_PZ.PZ().OSOBA().ref;
         _p_oso:=P_PZ.P().OSOBA().ref;
         OSOBA.cntx_pop(); P.cntx_pop();
         _zaslu.clear();
         _zaslu.p:=exec('zaslu','portal_zaslu',_p_oso,P_PZ.TYP,P_PZ.OD,_skipAbsences);
         _zaslu.pz:=exec('zaslu','portal_zaslu',_pz_oso,P_PZ.TYP,P_PZ.OD,_skipAbsences);
         _track.clear();
         _track.p:=exec('looped','portal_zaslu',_zaslu.p,_pz_oso,,_skipAbsences);
         _track.pz:=exec('looped','portal_zaslu',_zaslu.pz,_p_oso,,_skipAbsences);
         {? _track.p.looped | _track.pz.looped
         || P_PZ.cntx_psh();
            P_PZ.prefix();
            {? {? _track.p.looped || P_PZ.seek(_track.p.ref,,1) || P_PZ.seek(_track.pz.ref,,1) ?}
            || _list.clear();
               _list.content:=exec('track_all_looped','portal_zaslu');
               _result:=(_list.content.SIZE>0)
            ?};
            P_PZ.cntx_pop()
         ?}
      ?};
      _counter+=1;
      progress(int(_counter*100/_size),_prgsTitle);
      _loop:={? ~_result || P_PZ.next() ?}
   !};
   prgs_clr()
?};
P.cntx_pop();
P_PZ.cntx_pop();

_result

:Sign Version 2.0 jowisz:1045 2022/06/30 14:23:21 0c4e49fe025069ce9327e38ed86846a39b6245e034d706900e20638f7b93011d50ad0f0f2b45580113db438af44e826cd0184e854e3dac4e71f7a0b9d08ddacd059478e741679a6119225716ae99bb043d346209663a9199f64935983c87586486f56812ce2d8eededa11b2b4062031907a38024b8cc5f52d172beffc5e1023f
