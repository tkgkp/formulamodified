:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: px_gprs.fml []
:: Utworzony: 23.06.2014 []
:: Autor: AWI
::======================================================================================================================
:: Zawartosc: Obsluga kolejki planu strategicznego - wg zestawow
::======================================================================================================================


\add_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: Parametry exec('add','px_grps')
::   WY: obj_new - tablica nazwana
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PX_VER'
               ,'PX_GRP'
               ,'PX_SET'
               ,'GRN_DATA'
               ,'GRN_TIME'
               ,'DIR');
_args.PX_VER:=null();
_args.PX_GRP:=null();
_args.PX_SET:=null();
_args.GRN_DATA:=date(0,0,0);
_args.GRN_TIME:=time(0,0,0);
_args.DIR:=0;
_args


\add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: PX_GRPS.add
::   WE: [_a] - wynik exec('add_a','px_grps')
::   WY: 0-ok, 1-nok
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;

PX_GRPS.cntx_psh();
PX_GRPS.clear();
PX_GRPS.blank();
PX_GRPS.PX_VER:=_args.PX_VER;
PX_GRPS.PX_GRP:=_args.PX_GRP;
PX_GRPS.PX_SET:=_args.PX_SET;
PX_GRPS.GRN_DATA:=_args.GRN_DATA;
PX_GRPS.GRN_TIME:=_args.GRN_TIME;
PX_GRPS.DIR:=_args.DIR;
_result:=PX_GRPS.add();
PX_GRPS.cntx_pop();
_result


\del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: Usuwa biezacy PX_GRPS lub PX_GRPS'y dotyczace _a
::   WE: [_a] - PX_GRP.ref
::   WY: 0 - porazka
::       >0 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_grp:={? var_pres('_a')<>type_of(null()) || null() || _a ?};

_result:=0;
_can_continue:=1;

{? _px_grp
|| PX_GRPS.cntx_psh();
   PX_GRPS.index('PX_GRP');
   PX_GRPS.prefix(_px_grp);
   {? PX_GRPS.first()
   || {!
      |? _can_continue:=PX_GRPS.del(,1);
         PX_GRPS.first() & _can_continue>0
      !}
   ?};
   PX_GRPS.cntx_pop()
|| _can_continue:=PX_GRPS.del(,1)
?};
{? _can_continue>0
|| _result:=1
?};
_result


\del_all
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Usuwa wszyskie PX_GRPS'y
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_can_continue:=1;
PX_GRPS.cntx_psh();
PX_GRPS.index('LP');
PX_GRPS.clear();
{? PX_GRPS.first()
|| {!
   |? _can_continue:=exec('del','px_grps');
      PX_GRPS.first() & _can_continue>0
   !}
?};
PX_GRPS.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\refresh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: Odtworzenie PX_GRPS biezacego PX_GRP
::   WE: [_a] - INTEGER - [1]/0 - czy wycinac wszystko i nawijac od nowa
::                                czy aktualizowac i usuwac tylko te niepotrzebne
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_clean:=1;
{? var_pres('_a')=type_of(0)
|| _clean:=_a
?};

_result:=0;
_can_continue:=1;

_confirm_rfr:=0;

PX_GRPS.cntx_psh();
PX_GRPS.index('PX_GRP');

{? _clean>0
||
:: 1. Usuwanie wszystkich PX_GRPSow skojarzonych z biezacym PX_GRP
   _can_continue:=exec('del','px_grps',PX_GRP.ref())
?};

{? _can_continue>0
||
   _size_bef:=0;
   PX_GRPS.prefix(PX_GRP.ref());
   _size_bef:=PX_GRPS.size();

:: 2. Tworzenie nowych PX_GRPsow na podstawie zestawow w przepisie
   _can_continue:=exec('grp_triga_add','px_grp',1);

   _size_aft:=0;
   PX_GRPS.prefix(PX_GRP.ref());
   _size_aft:=PX_GRPS.size();

   {? _size_bef<>_size_aft
   ||
::    Doszly jakies nowe PX_GRPSy wiec trzeba odswiezyc status potwierdzen na PX_GRP
      _confirm_rfr:=1
   ?}
?};

{? _clean=0
||
:: Usuwam nadmiarowe PX_GRPSy ktore juz nie sa potrzebne
   PX_GRPS.prefix(PX_GRP.ref());
   {? PX_GRPS.first()
   || {!
      |?
         _next:=0;
         _nxt_ref:=null();
         PX_GRPS.cntx_psh();
         {? PX_GRPS.next()
         || _nxt_ref:=PX_GRPS.ref()
         ?};
         PX_GRPS.cntx_pop();

         {? PX_GRPS.PX_SET<>null()
         ||
::          Sprawdzam czy zestaw wystepuje w biezacym przepisie
            {? exec('has_set','px_tex',PX_GRP.PX_TEX,PX_GRPS.PX_SET)=0
            ||
               _confirm_rfr:=1;
::             Nie wystepuje wiec usuwam
               _can_continue:=exec('del','px_grps')
            ?}
         ?};

         {? _nxt_ref<>null()
         || _next:=PX_GRPS.seek(_nxt_ref)
         ?};
         _next>0 & _can_continue>0
      !}
   ?};

   ~~
?};
{? _confirm_rfr>0
||
:: Odswiezam status potwierdzen na PX_GRP
   exec('confirm_rfrsh','px_grp',PX_GRP.ref())
?};
PX_GRPS.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result


\panel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: Definicja panelu kolejki
::   WE: [_a] - 0 (domyslnie) podstawowa kolejka, 1 - kopia kolejki
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _kopia:=_a || _kopia:=0 ?};

PxSelect.mask:=PX_GRP.name();
:: Przypisanie obiektu kolejki, tworzenie okien itp
:: PxSelect.Pxgrp:=x - zostawić ten komentarz dla ułatwienia szukania

($('PxSelect.Pxgrp'+{? _kopia || '1' || '' ?}))():=obj_new('TAB'
                                                           ,'WERT'
                                                           ,'WERT_G'
                                                           ,'BTN'
                                                           ,'load'
                                                           ,'update'
                                                           ,'NDX_UP'
                                                           ,'curr_WERT'
                                                           ,'curr_WERT_PREV'
                                                           ,'curr_WERT_G'
                                                           ,'curr_WERT_G_PREV');
_obiekt:={? _kopia || PxSelect.Pxgrp1 || PxSelect.Pxgrp ?};

_obiekt.TAB:=PX_GRPS;
_obiekt.WERT:=exec('wer','px_grps','Kolejka'@,0);
_obiekt.WERT_G:=exec('wer','px_grps','Kolejka dla grup'@,1);

_obiekt.curr_WERT:=null();
_obiekt.curr_WERT_G:=null();

_obiekt.curr_WERT_PREV:=null();
_obiekt.curr_WERT_G_PREV:=null();

:: Przeciazenie metod i niektorych pol starego obiektu z kolejka, po to by moglo dzialac
:: na stalej tabeli PX_GRPS
_obiekt.load:="";
_obiekt.update:="
   {? PxSelect.Context<>'' & PxSelect.Context*'|MENU'=0
   || {? PX_VAR.GROPS=null()
      || grp_disp(PX_GRPS,.WERT)
      || grp_disp(PxSelect.Pxgrp.TAB,.WERT_G)
      ?};
      ~~
   || PX_GRPS.index('LP1');
      PX_GRPS.prefix('T',PX_VAR.VIE_VER,PX_VAR.PX_SET,'Z');
      {? var_pres('curr_WERT',PxSelect.Pxgrp)>0 & PxSelect.Pxgrp.curr_WERT<>null()
      || {? PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT)=0
         || PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT_PREV)
         ?}
      ?}
   ?};
   ~~
";
_obiekt.NDX_UP:='LP';

_ff:="
   {? ~-cur_nfld()='SYMBOL'
   || _tab:=obj_new('CMP','KOM_ERR','KOM_WARN','KOM_INFO');
      _tab.CMP:='';

::    Analiza pol o komunikatach
      PX_GRP.cntx_psh();
      _child_kom:=exec('kom_child_chk','px_grp',PX_GRP.ref());
      _kom_err:=PX_GRPS.PX_GRP().KOM_ERR;
      _kom_warn:=PX_GRP.KOM_WARN;
      _kom_info:=PX_GRP.KOM_INFO;
      PX_GRP.cntx_pop();

::    Jesli PX_GRP nie mial swojego komunikatu to byc moze maja go jego skadniki czyli PX_CONN
      {? _kom_err='N'
      || {? _child_kom*'E'>0
         || _kom_err:='T'
         ?}
      ?};
      {? _kom_warn='N'
      || {? _child_kom*'W'>0
         || _kom_warn:='T'
         ?}
      ?};
      {? _kom_info='N'
      || {? _child_kom*'I'>0
         || _kom_info:='T'
         ?}
      ?};

      _tab.KOM_ERR:=_kom_err;
      _tab.KOM_WARN:=_kom_warn;
      _tab.KOM_INFO:=_kom_info;

      exec('txt_bd','px_grp',_tab)
   || ''
   ?}";
PX_GRPS.fld_fml('PX_GRP','BEFORE_DISPLAY',_ff);

_ff:="exec('t_real_bd','px_grp')";
PX_VAR1.fld_fml('T_REAL','BEFORE_DISPLAY',_ff);

_ff:="
   {? cur_tab(1,1)=PX_CONN
   || PX_OBJ.cntx_psh();
      _kol:='0:0:0,'+PX_CONN.PX_OBJ().KOLOR;
      PX_OBJ.cntx_pop();
      _kol
   || ''
   ?}";
PX_VAR1.fld_fml('ZNACZNIK','BEFORE_DISPLAY',_ff);

PX_GRP.fld_fml('DIR','DISPLAY_FORMAT',"'empty=1'");

~~


\wer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: Okno wertowania wer tabeli PX_GRPS
::   WE: [_a] - STRING - tytuł okienka
::       [_b] - INTEGER - czy okienko dla grup operacji
::   WY: Akronim okna
::----------------------------------------------------------------------------------------------------------------------
_is_px_set:=exec('is_px_set','px_param')>0;
_title:='Kolejka'@;
{? var_pres('_a')=type_of('')
|| _title:=_a
?};
_grop:=0;
{? var_pres('_b')=type_of(0)
|| _grop:=_b
?};

_wer:=PX_GRPS.mk_sel(_title,,,'bsdfeanvasdeae'+$_is_px_set,,,,,'U');
PX_GRPS.win_fld(_wer,,'PX_GRP','LP_Q',,2,,,'Lp.'@);
{? _grop>0
|| PX_GRPS.win_fld(_wer,,'PX_GRP','SYMBOL',,16,,,'Symbol'@)
|| PX_GRPS.win_fld(_wer,,'PX_GRP','SYMBOL',,20,,,'Symbol'@)
?};
{? _grop>0
|| PX_GRPS.win_fld(_wer,PX_VAR1,'C_ILOSC',,,6,0,,'Il. uruchomień'@)
|| PX_GRPS.win_fld(_wer,PX_VAR1,'C_ILOSC',,,6,ST.DOKL,,'Ilość'@);
   PX_GRPS.win_fld(_wer,PX_VAR1,'JM',,,3,,,'jm'@)
?};
PX_GRPS.win_fld(_wer,PX_VAR1,'T_REAL',,,-11,,,'Termin realizacji'@,,'Termin realizacji'@);
PX_GRPS.win_fld(_wer,,'PX_GRP','STREND',,-11,,,'Planowana realizacja'@,,'Planowana realizacja'@);
{? _is_px_set
|| PX_GRPS.win_fld(_wer,PX_VAR1,'CZY_SETS',,,-4,,,'Zestaw źródłowy'@,,'Zestaw źródłowy'@,2,,"'T'","'N'");
   PX_GRPS.win_fld(_wer,PX_VAR1,'DIR_SET',,,-7,,,'Zwrot zestawu'@,,'Zwrot w bieżacym zestawie'@);
   PX_GRPS.win_fld(_wer,,'CONFIRM',,,-4,,,'√ zestawu'@,,'Potwierdzony bieżący zestaw'@,2,,"'T'","'N'");
   PX_GRPS.win_fld(_wer,PX_VAR1,'ZNACZNIK',,,-7,,,'Zwrot całości'@,,'Zwrot ogólny całej grupy'@);
   PX_GRPS.win_fld(_wer,PX_GRP,'CONFIRM',,,-4,,,'√ całkowite'@,,'Potwierdzone wszystkie zestawy'@,2,,"'T'","'N'","'P'")
|| PX_GRPS.win_fld(_wer,PX_VAR1,'ZNACZNIK',,,5,,,'Zwrot'@)
?};

:: Akcje
_whatif:=exec('is_whatif','px_ver',PxSelect.VER_QUE);
{? _whatif>0
|| _gfb:="exec('copy_from_whatif_gr1','px_grp')";
   _gfa:="exec('copy_from_whatif_gr2','px_grp')";
   _fb:="exec('copy_from_whatif','px_grp')";
   PX_GRPS.win_act(_wer,,'Formuła','Nanieś&'@@,,,_fb,,1,1,_gfb,_gfa,'Ś');
   task_attach('TPP_PPS_DPLA')
?};

_gfb:="exec('px_grp_corr_bg','px_grp',!PxSelect.Pxgrp)";
_gfa:="VAR.GRUPA:='N'";
_fb:="exec('px_grp_correct','px_grp',!PxSelect.Pxgrp)";
PX_GRPS.win_act(_wer,,'Formuła','Popraw'@@,,,_fb,,,1,_gfb,_gfa,'P');
task_attach('TPP_PPS_DPLA');

_fgb:="exec('usu_gb','px_grp')";
_fga:="exec('usu_ga','px_grp')";
_fb:="
   exec('usu','px_grp');
   ~~
";
PX_GRPS.win_act(_wer,,'Formuła','Usuń'@@,,,_fb,,,1,_fgb,_fga,'U');
task_attach('TPP_PPS_DPLA');

{? PX_VAR.EDIT=1
|| _fb:="exec('px_que_organize','px_grp',PxSelect.VER_QUE)";
   PX_GRPS.win_act(_wer,0,'Formuła','P&orządkuj'@@,,,_fb,,0,,,,'O');
   task_attach('TPP_PPS_DPLA')
?};

_fb:="exec('go_obj_date','px_grp')";
PX_GRPS.win_act(_wer,,'Formuła','Do da&ty'@@,,,_fb,,,,,,'T');

{? _whatif=0
||
   _gfb:="exec('block_actionb','px_grp')";
   _gfa:="exec('block_actiona','px_grp')";
   _fb:="exec('block_action','px_grp')";
   PX_GRPS.win_act(_wer,,'Formuła','Blokuj'@@,,,_fb,,,1,_gfb,_gfa,'B');
   task_attach('TPP_PPS_DPLA');

   _gfb:="exec('unblock_actionb','px_grp')";
   _gfa:="exec('unblock_actiona','px_grp')";
   _fb:="exec('unblock_action','px_grp')";
   PX_GRPS.win_act(_wer,,'Formuła','Odblo&kuj'@@,,,_fb,,,1,_gfb,_gfa,'K');
   task_attach('TPP_PPS_DPLA')
?};

_fb:="exec('select_action','px_point',PX_GRPS.PX_GRP,PX_VAR.PX_SET)";
PX_GRPS.win_act(_wer,,'Formuła','Punkty &czasowe'@@,,,_fb,,0,,,,'C');

_fb:="exec('select_komm','px_grps')";
PX_GRPS.win_act(_wer,0,'Formuła','Komu&nikaty'@@,,,_fb,,0,,,,'N');

:: Menu Przesuń
PX_GRPS.win_act(_wer,0,'Menu','P&rzesuń'@@,,,,,,,,,'R');
_fb:="exec('move_grp_up','px_grp',0)";
PX_GRPS.win_act(_wer,0,'Formuła','(n) w gó&rę'@@,'#R',,_fb,,,,,,'R');
task_attach('TPP_PPS_DPLA');
PX_GRPS.act_icn(_wer,0,'RR','xwin16.png:103');
_fb:="exec('move_grp_up','px_grp',1)";
PX_GRPS.win_act(_wer,0,'Formuła','(1) w &górę'@@,'#R',,_fb,,,,,,'G');
task_attach('TPP_PPS_DPLA');
PX_GRPS.act_icn(_wer,0,'RG','xwin16.png:104');
_fb:="exec('move_grp_down','px_grp',1)";
PX_GRPS.win_act(_wer,0,'Formuła','(1) w &dół'@@,'#R',,_fb,,,,,,'D');
task_attach('TPP_PPS_DPLA');
PX_GRPS.act_icn(_wer,0,'RD','xwin16.png:105');
_fb:="exec('move_grp_down','px_grp',0)";
PX_GRPS.win_act(_wer,0,'Formuła','(n) &w dół'@@,'#R',,_fb,,,,,,'W');
task_attach('TPP_PPS_DPLA');
PX_GRPS.act_icn(_wer,0,'RW','xwin16.png:106');
PX_GRPS.win_act(_wer,0,'Formuła','--X','#R');
task_attach('TPP_PPS_DPLA');
_fb:="exec('move_grp_to','px_grp')";
_gfb:="exec('move_grp_to_bg','px_grp')";
PX_GRPS.win_act(_wer,0,'Formuła','Do &numeru'@@,'#R',,_fb,,,1,_gfb,,'N');
task_attach('TPP_PPS_DPLA');
PX_GRPS.act_icn(_wer,0,'RN','xwin16.png:107');

{? _is_px_set
|| _fb:="exec('confirm','px_grps')";
   _gfb:="exec('confirm_bg','px_grps')";
   _gfa:="exec('confirm_ag','px_grps')";
   PX_GRPS.win_act(_wer,0,'Formuła','Potwi&erdź'@@,,,_fb,,,1,_gfb,_gfa,'E');
   task_attach('TPP_PPS_DPLA');
   _fb:="exec('confirm','px_grps',0)";
   _gfb:="exec('confirm_del_bg','px_grps')";
   _gfa:="exec('confirm_ag','px_grps')";
   PX_GRPS.win_act(_wer,0,'Formuła','Wycofa&j'@@,,,_fb,,,1,_gfb,_gfa,'J');
   task_attach('TPP_PPS_DPLA');

   _fb:="exec('confirmations','px_grps',PX_GRPS.PX_GRP)";
   PX_GRPS.win_act(_wer,0,'Formuła','Pot&wierdzenia'@@,,,_fb,,,,,,'W')
?};

:: Menu Funkcje
PX_GRPS.win_act(_wer,0,'Menu','Funkcje'@,,,,,,,,,'F');
_fb:="exec('sel_sur_pxver','px_sur',PX_VAR.VIE_VER)";
PX_GRPS.win_act(_wer,0,'Formuła','Zapotrzebowania'@@,'#F',,_fb,,,,,,'Z');
_fb:="exec('diagram','px_con_g',PX_VAR.VER_QUE)";
PX_GRPS.win_act(_wer,0,'Formuła','Diagram'@@,'#F',,_fb,,,,,,'F');
{? PX_VAR.EDIT=1 & _whatif=0
||
   PX_GRPS.win_act(_wer,0,'Formuła','--Q','#F');
   _fb:="exec('action_generuj','!tte_pzl_dzpx')";
   _gr1:="exec('action_generuj_gr1','!tte_pzl_dzpx')";
   _gr2:="exec('action_generuj_gr2','!tte_pzl_dzpx')";
   PX_GRPS.win_act(_wer,0,'Formuła','Generuj zlecenia'@@,'#F',,_fb,,,1,_gr1,_gr2,'G');
   task_attach('TTE_PZL_DZPX')
?};
_fb:="exec('zlecenia','px_grp')";
PX_GRPS.win_act(_wer,0,'Formuła','Z&lecenia'@@,'#F',,_fb,,,,,,'L');

{? _whatif=0
|| _fb:="exec('one_ver_simulate','px_plan')";
   PX_GRPS.win_act(_wer,0,'Formuła','Symulacja &what-if'@@,'#F',,_fb,,,,,,'W')
?};

:: Menu Podgląd
PX_GRPS.win_act(_wer,0,'Menu','Pod&gląd'@,,,,,,,,,'G');
_fb:="exec('select_grp','px_poz')";
PX_GRPS.win_act(_wer,0,'Formuła','Pozycje planu dla grupy'@@,'#G',,_fb,,,,,,'P');
PX_GRPS.win_act(_wer,0,'Formuła','--Z','#G');
_fb:="exec('wer_px_txt_v','px_grps')";
PX_GRPS.win_act(_wer,0,'Formuła','Podgląd prz&episu'@@,'#G',,_fb,,0,,,,'E');
task_attach('TPP_PPS_DPPL');
task_attach('TPP_PPS_PPPL');
_fb:="exec('select_paczka','px_grp')";
PX_GRPS.win_act(_wer,0,'Formuła','Przep&is źródłowy'@@,'#G',,_fb,,0,,,,'I');
PX_GRPS.win_act(_wer,0,'Formuła','--X','#G');
_fb:="exec('view_act_queue','px_plan')";
PX_GRPS.win_act(_wer,0,'Formuła','Kolejka'@@,'#G',,_fb,,,,,,'K');
_fb:="exec('view_act_obj','px_plan')";
PX_GRPS.win_act(_wer,0,'Formuła','Obiekty'@@,'#G',,_fb,,,,,,'O');
_fb:="exec('view_act_queue_obj','px_plan')";
PX_GRPS.win_act(_wer,0,'Formuła','Ko&lejka+obiekty'@@,'#G',,_fb,,,,,,'L');

{? PX_VAR.PL_GROP>0
||
:: Menu Grupy operacji
   PX_GRPS.win_act(_wer,0,'Menu','Grup&y operacji'@,,,,,,,,,'Y');
   {? _grop>0
   ||
      _fb:="params_exec('grop_set_termin','!tpp_gop_dred',PX_GRP.GROPS().GROP)";
      PX_GRPS.win_act(_wer,0,'Formuła','Pozycje &grupy'@@,'#Y',,_fb,,0,,,,'G');
      PX_GRPS.win_act(_wer,0,'Formuła','--X','#Y');
      _fb:="exec('direction_set','px_grop')";
      PX_GRPS.win_act(_wer,0,'Formuła','Uzgodnij &zwrot'@@,'#Y',,_fb,,0,,,,'Z')
   ?};
   _fb:="exec('select_grops4grp','px_plan')";
   PX_GRPS.win_act(_wer,0,'Formuła','&Podgląd planu'@@,'#Y',,_fb,,0,,,,'P')
?};
_fb:="exec('px_grp_display','px_grp')";
PX_GRPS.win_act(_wer,,'Wyświetl',,,,_fb);

{? _grop=0
||
   _fb:="
      !PxSelect.Pxgrp.curr_WERT:=PX_GRPS.ref();
      PX_GRPS.cntx_psh();
      {? PX_GRPS.prev()
      || !PxSelect.Pxgrp.curr_WERT_PREV:=PX_GRPS.ref()
      ?};
      PX_GRPS.cntx_pop();
      exec('px_grp_rkprz','px_grp')
   "
|| _fb:="
      !PxSelect.Pxgrp.curr_WERT_G:=PX_GRPS.ref();
      PX_GRPS.cntx_psh();
      {? PX_GRPS.prev()
      || !PxSelect.Pxgrp.curr_WERT_G_PREV:=PX_GRPS.ref()
      ?};
      PX_GRPS.cntx_pop();
      exec('px_grp_rkprz','px_grp')
   "
?};
PX_GRPS.win_act(_wer,,'Rekord',,,,_fb);

_fb:="exec('px_grp_legenda','px_grp')";
PX_GRPS.win_act(_wer,,'Formuła','Legenda'@@,,,_fb,,,,,,'L');

:: Przyciski (tylko jak redagowanie)
{? PX_VAR.EDIT=1
||
   _all_btns:=1;

   {? exec('is_grop','px_param')>0 & exec('queue_in_tabs','px_param')=0
   || _all_btns:=0
   ?};

   _obiekt:=PxSelect.Pxgrp;
   _btn:=_obiekt.TAB.win_btn(_wer,'icon=xwin16.png:103,panel=right,align=begin','menu:RR');
   _obiekt.TAB.btn_sopt(_wer,_btn,'tooltip='+'Przesunięcie w górę o N pozycji'@);
   {? _all_btns
   || _btn:=_obiekt.TAB.win_btn(_wer,'icon=xwin16.png:104,panel=right,align=begin','menu:RG');
      _obiekt.TAB.btn_sopt(_wer,_btn,'tooltip='+'Przesunięcie w górę o 1 pozycję'@);
      _btn:=_obiekt.TAB.win_btn(_wer,'icon=xwin16.png:105,panel=right,align=begin','menu:RD');
      _obiekt.TAB.btn_sopt(_wer,_btn,'tooltip='+'Przesunięcie w dół o 1 pozycję'@)
   ?};

   _btn:=_obiekt.TAB.win_btn(_wer,'icon=xwin16.png:106,panel=right,align=begin','menu:RW');
   _obiekt.TAB.btn_sopt(_wer,_btn,'tooltip='+'Przesunięcie w dół o N pozycji'@);
   {? _all_btns
   || _btn:=_obiekt.TAB.win_btn(_wer,'icon=xwin16.png:107,panel=right,align=begin','menu:RN');
      _obiekt.TAB.btn_sopt(_wer,_btn,'tooltip='+'Przesunięcie na N-tą pozycję'@)
   ?};
   ~~
?};

_ff:="
   {? cur_afld()='SYMBOL'
   || _ok:=0;
      PX_CONN.cntx_psh();
      PX_GRP.cntx_psh();
      PX_GRP.clear();
      {? PX_GRP.seek(PX_GRPS.PX_GRP)
      || _ref:=PX_GRP.ref();
         PX_CONN.index('PX_GRP');
         PX_CONN.prefix(_ref);
         _ok:=PX_CONN.first()
      ?};
      _wyn:=
         {? _ok
         || {? PX_GRP.PLAN_OPR='T'
            || exec('pl_plan','icon')
            |? exec('is_blocked','px_grp')>0
            || 'xwin16.png:157'
            |? PX_GRP.PROBLEMS<>exec('problem_none','px_obj')
            || 'xwin16.png:4'
            || 'xwin16.png:110'
            ?}
         || 'xwin16.png:110'
         ?};
      PX_CONN.cntx_pop();
      PX_GRP.cntx_pop();
      _wyn
   |? cur_afld()='DIR'
   || PX_GRP.cntx_psh();
      PX_GRP.clear();
      _wyn:=
         {? PX_GRP.seek(PX_GRPS.PX_GRP)
         || {? PX_GRP.DIR=1
            || 'xwin16.png:22'
            |? PX_GRP.DIR=-1
            || 'xwin16.png:85'
            || ''
            ?}
         || ''
         ?};
      PX_GRP.cntx_pop();
      _wyn
   |? cur_afld()='STREND'
   || _wyn:='xwin16.png:110';
      {? exec('has_point','px_point',PX_GRPS.PX_GRP,'A',,PX_VAR.PX_SET)>0
      || _wyn:='xwin16.png:134'
      ?};
      {? exec('has_point','px_point',PX_GRPS.PX_GRP,'RP',,PX_VAR.PX_SET)>0
      || _wyn:='xwin16.png:133'
      ?};
      _wyn
   |? cur_afld()='C_ILOSC'
   || PX_GRP.cntx_psh();
      _wyn:=
         {? PX_GRPS.PX_GRP().STATUS=exec('status_wyk1','px_grp')
         || 'xwin16.png:72'
         |? PX_GRPS.PX_GRP().STATUS=exec('status_wyk2','px_grp')
         || 'xwin16.png:38'
         || ''
         ?};
      PX_GRP.cntx_pop();
      _wyn
   || ''
   ?}
";
PX_GRPS.win_fml(_wer,,'PX_GRP','SYMBOL','ICON_BEFORE',_ff);
PX_GRPS.win_fml(_wer,,'PX_GRP','DIR','ICON_BEFORE',_ff,2);
PX_GRPS.win_fml(_wer,,'PX_GRP','STREND','ICON_BEFORE',_ff,2);
PX_GRPS.win_fml(_wer,PX_VAR1,'C_ILOSC',,'ICON_BEFORE',_ff,2);

_wer


\select_komm
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Akcja 'komunikaty' w oknie wertowania tabeli PX_GRPS
::----------------------------------------------------------------------------------------------------------------------
{? PX_GRPS.PX_GRP<>null()
|| PX_GRPS.PX_GRP();
   exec('select_grp','px_komm')
|| FUN.error('Brak złączenia do obiektu grupującego w kolejce.')
?};
~~


\refresh_all
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Usuwa wszystkie PX_GRPsy i buduje je od nowa
::   WE: [_a] - PX_VER.ref - wersja ktorej odtwarzac PX_GRPsy, jesli nie podane to wersja
::                           glowna planu
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=null();
{? var_pres('_a')=type_of(PX_VER.ref())
|| _px_ver:=_a
|| _px_ver:=exec('get_mainversion','px_ver')
?};

_result:=0;
_can_continue:=1;

PX_SET.cntx_psh();
PX_SET.index('SYMBOL');
PX_SET.clear();
{? PX_SET.size()>0
||
:: Istnieje co najmniej jeden zestaw - tworze PX_GRPSy

:: Najpierw usuwam calosc
   _can_continue:=exec('del_all','px_grps');

   {? _can_continue>0
   ||
      PX_GRP.cntx_psh();
      PX_GRP.index('LP');
      PX_GRP.prefix(_px_ver);
      {? PX_GRP.first()
      || {!
         |? _can_continue:=exec('refresh','px_grps');

            {? _can_continue>0
            ||
::             Resetuje znacznik potwierdzenia na grupie
               PX_GRP.CONFIRM:='N';
               _can_continue:=PX_GRP.put()
            ?};
            PX_GRP.next() & _can_continue>0
         !}
      ?};
      PX_GRP.cntx_pop()
   ?}
||
:: Nie ma zadnego zestawu - usuwam wszystkie PX_GRPSy
   _can_continue:=exec('del_all','px_grps');
   ~~
?};

PX_SET.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\refresh_all_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MENU KONTEKSTOWE
::  UTW: WH [12.41]
:: OPIS: Akcja 'Odswiez kolejki' wywolywana z menu kontekstowego (funkcje techniczne)
::----------------------------------------------------------------------------------------------------------------------
_msg:='Odtworzenie kolejek przypisanych do zestawów planistycznych spowoduje utratę\n'
      'informacji o potwierdzeniach w kolejkach.\n\n'
      'Czy na pewno kontynuować?'@;
{? FUN.ask(_msg)>0
|| exec('refresh_all','px_grps')
?};
~~


\confirm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Potwierdzenie pozycji w kolejce
::   WE: [_a] - INTEGER - 0/[1] - odtwierdzać, czy potwierdzać
::----------------------------------------------------------------------------------------------------------------------
_confirm:=1;
{? var_pres('_a')=type_of(0)
|| _confirm:=_a
?};
{? VAR.GRUPA='D'
|| PX_GRPS.CONFIRM:='T';
   {? PX_GRPS.put()
   || exec('confirm_rfrsh','px_grp',PX_GRPS.PX_GRP)
   ?}
|? VAR.GRUPA='U'
|| PX_GRPS.CONFIRM:='N';
   {? PX_GRPS.put()
   || exec('confirm_rfrsh','px_grp',PX_GRPS.PX_GRP)
   ?}
||
:: Kontrola czy wybrany zestaw, jesli zestawy dostepne
   {? exec('is_px_set','px_param')>0 & PX_VAR.PX_SET=null()
   || FUN.info('Aby potwierdzić pozycję kolejki należy pracować w kontekście zestawu planistycznego.'@)
   || {? _confirm>0
      || {? FUN.ask('Czy potwierdzić pozycję w kolejce planu?'@)
         || {? PX_GRPS.CONFIRM<>'T'
            ||
               PX_GRPS.CONFIRM:='T';
               {? PX_GRPS.put()
               || exec('confirm_rfrsh','px_grp',PX_GRPS.PX_GRP)
               ?}
            || FUN.info('Pozycja jest już potwierdzona.'@)
            ?}
         ?}
      || {? FUN.ask('Czy usunąć potwierdzenie pozycji w kolejce planu?'@)
         ||
            {? PX_GRPS.CONFIRM<>'N'
            || PX_GRPS.CONFIRM:='N';
               {? PX_GRPS.put()
               || exec('confirm_rfrsh','px_grp',PX_GRPS.PX_GRP)
               ?}
            || FUN.info('Pozycja jest już odtwierdzona.'@)
            ?}
         ?}
      ?}
   ?}
?};
~~


\confirm_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Potwierdzenie pozycji w kolejce - akcja przed grupa rekordow
::----------------------------------------------------------------------------------------------------------------------
:: Kontrola czy wybrany zestaw, jesli zestawy dostepne
{? exec('is_px_set','px_param')>0 & PX_VAR.PX_SET=null()
|| FUN.info('Aby potwierdzić pozycję kolejki należy pracować w kontekście zestawu planistycznego.'@);
   _result:=0
|| _choice:=FUN.ask('Czy dodać potwierdzenia dla zaznaczonych pozycji?'@);
   {? _choice=1 || _result:=1; VAR.GRUPA:='D'
   || _result:=0
   ?}
?};
_result


\confirm_del_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Wycofanie potwierdzenia pozycji w kolejce - akcja przed grupa rekordow
::----------------------------------------------------------------------------------------------------------------------
:: Kontrola czy wybrany zestaw, jesli zestawy dostepne
{? exec('is_px_set','px_param')>0 & PX_VAR.PX_SET=null()
|| FUN.info('Aby usunąć potwierdzenie pozycji kolejki należy pracować w kontekście zestawu planistycznego.'@);
   _result:=0
|| _choice:=FUN.ask('Czy usunąć potwierdzenia dla zaznaczonych pozycji?'@);
   {? _choice=1 || _result:=1; VAR.GRUPA:='U'
   || _result:=0
   ?}
?};
_result


\confirm_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Potwierdzenie pozycji w kolejce - akcja przed grupa rekordow
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
~~


\confirmations
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Wyswietla potwierdzenia dla pozycji w kolejce
::   WE: _a - PX_GRP.ref()
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

PX_GRPS.cntx_psh();

_tab:=tab_tmp(1,
   'SET_SYM','STRING[100]','Zestaw planistyczny'@,
   'PX_SET','STRING[16]','$PX_SET.ref()',
   'CONFIRM','STRING[1]','Potwierdzenie'
);

_grp:=_tab.grp_make('Potwierdzenia dla zestawów planistycznych'@,,'confirm_grp',10,10,,,'normal');
_wer:=_tab.mk_sel(,,0,'confirmations',10,10,10);
_tab.win_fld(_wer,,'SET_SYM',,,45);
_tab.win_fld(_wer,,'CONFIRM',,,,,,'√',,,2,,"'T'","'N'");
_af:="
   PX_SETU.index('PX_SET');
   PX_SETU.prefix(exec('FindAndGet','#table',PX_SET,cur_tab(1,1).PX_SET,,,null()));
   grp_disp(PX_SETU,'WER_Z');
   ~~
";
_tab.grp_sel(_grp,,_wer,,_af,,,5,,,,,'maximized');
_tab.grp_splt(_grp,,'horizontal','usery',10);
_tab.grp_sel(_grp,PX_SETU,'WER_Z',,,,,5,,,,,'maximized_with_title');
_tab.win_sel(_grp);

PX_GRPS.index('PX_GRP');
PX_GRPS.prefix(_px_grp);
{? PX_GRPS.first()
|| {!
   |? {? PX_GRPS.PX_SET<>null()
      || _tab.PX_SET:=$PX_GRPS.PX_SET;
         _tab.SET_SYM:=PX_GRPS.PX_SET().SYMBOL;
         _tab.CONFIRM:=PX_GRPS.CONFIRM;
         _tab.add()
      ?};
      PX_GRPS.next()
   !}
?};

PX_SETU.actions('WER_Z','DUM:D');
_tab.select();
PX_SETU.actions('WER_Z','');

PX_GRPS.cntx_pop();
~~


\fld_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Przed wyswietleniem pol w tabeli PX_GRPS
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_fld:=cur_afld();
{? _fld='CONFIRM' | _fld='DIR_SET'
|| {? PX_GRPS.PX_SET=null()
   || _result:=0
   ?}
?};
_result


\update
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Wyszukuje i aktualizuje PX_GRPS'a na podstawie przekazanych danych
::   WE: _a - PX_GRP.ref()
::       _b - PX_SET.ref()
::       _c - _args - bufor reprezentujacy rekord - wynik exec('add_a','px_grps')
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_px_set:=_b;
_args:=_c;

_result:=0;

PX_GRPS.cntx_psh();
PX_GRPS.index('PX_GRP');
PX_GRPS.prefix(_px_grp,_px_set);
{? PX_GRPS.first()
|| PX_GRPS.PX_GRP:=_args.PX_GRP;
   PX_GRPS.PX_SET:=_args.PX_SET;
   PX_GRPS.GRN_DATA:=_args.GRN_DATA;
   PX_GRPS.GRN_TIME:=_args.GRN_TIME;
   PX_GRPS.DIR:=_args.DIR;
   PX_GRPS.cntx_psh();
   PX_GRPS.prefix();
   _result:=PX_GRPS.put();
   PX_GRPS.cntx_pop()
?};
PX_GRPS.cntx_pop();
PX_GRPS.get();
_result


\tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: Atrapa PxSelect.Pxgrp.TAB
::----------------------------------------------------------------------------------------------------------------------
_tab:=obj_new('PX_GRPI','PX_OBJ','PX_CONN','PX_SET');
_tab.PX_GRPI:=$PX_GRPS.PX_GRP;
_tab.PX_OBJ:={? cur_tab(1,1)=PX_CONN | PxSelect.Context*'|PX_CONN' || $PX_CONN.PX_OBJ || '' ?};
_tab.PX_CONN:={? cur_tab(1,1)=PX_CONN | PxSelect.Context*'|PX_CONN' || $PX_CONN.ref() || '' ?};
_tab.PX_SET:=$PX_GRPS.PX_SET;
_tab


\px_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: $PX_OBJ.ref()
::----------------------------------------------------------------------------------------------------------------------
exec('tab','px_grps').PX_OBJ


\px_grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: $PX_GRP.ref()
::----------------------------------------------------------------------------------------------------------------------
exec('tab','px_grps').PX_GRPI


\actions_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Ustawia akcje w oknie PX_GRPS
::----------------------------------------------------------------------------------------------------------------------
_wer:=PxSelect.Pxgrp.WERT;
_is_px_set:=exec('is_px_set','px_param');

:: Zadna akcja nie zabrana
_hid_none:='';

:: Wszystkie akcje zabrane
_hid_all:='PUBKROE';

:: Zabrane tylko Popraw
_hid_popraw:='P';

{? PxSelect.Context='ZAM' | PxSelect.Context='ZL'
||
:: Jesli symulacja zamowienia lub zlecenia to zabieram akcje 'punkty Czasowe' i 'potWierdzenia'
   _hid_none+='CWJ';
   _hid_all+='CWJ';
   _hid_popraw+='CWJ'
?};

_can_continue:=1;

{? PX_VAR.EDIT=0
||
:: Jesli widok do podgladu to zabieram wszystkie akcje
   PX_GRPS.actions(_wer,_hid_all,,1);
   _can_continue:=0
?};

{? _can_continue>0
||
   {? _is_px_set=0
   ||
::    Jesli brak pracy na zestawach to nie zabieram nic
      PX_GRPS.actions(_wer,_hid_none,,1);
      _can_continue:=0
   ||
::    Praca na zestawach
      {? PX_VAR.PX_SET<>null()
      ||
::       Zestaw wybrany - nic nie zabieram
         PX_GRPS.actions(_wer,_hid_none,,1);
         _can_continue:=0
      ||
::       Zestaw niewybrany
         {? exec('get','#params',8062,2,OPERATOR.USER)='T'
         ||
::          Administrator kolejki - zabieram tylko popraw
            PX_GRPS.actions(_wer,_hid_popraw,,1);
            _can_continue:=0
         ||
::          Kazdy inny szary czlowiek - zabieram wszystko
            PX_GRPS.actions(_wer,_hid_all,,1);
            _can_continue:=0
         ?}
      ?}
   ?}
?};
~~


\dnd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Ustawia d'n'd w oknie PX_GRPS
::----------------------------------------------------------------------------------------------------------------------
_wer:=PxSelect.Pxgrp.WERT;
_is_px_set:=exec('is_px_set','px_param');
{? PX_VAR.EDIT &
   (   ~_is_px_set |
       ( _is_px_set & (PX_VAR.PX_SET<>null() | exec('get','#params',8062,2,OPERATOR.USER)='T'))
   )
|| PX_GRPS.dnd_sel(_wer,,'records.PX_GRPS',"exec('dnd_renum','px_grps')");
   PX_GRPS.dnd_sel(_wer,,'records.PX_CONN',"exec('dnd_conns','px_grps')")
|| PX_GRPS.dnd_sel(_wer,,'records.PX_GRPS',"");
   PX_GRPS.dnd_sel(_wer,,'records.PX_CONN',"")
?};
~~


\dnd_renum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Akcja renumerujaca drzewa (dnd albo akcja w oknie wertowania PX_GRPS->PX_GRPS)
::   WE: [_a] - 1 (domyslnie - dnd), 0 (akcja w oknie)
::       [_b] - przesuwane rekordy (jak wynik dnd_info('dropped_records') ) - interpretowane gdy _a=0
::       [_c] - miejsce przeznaczenia (jak wynik dnd_info('dest_record') ) - interpretowane gdy _a=0
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _dnd:=_a || _dnd:=1 ?};

{? _dnd
|| _pos:=dnd_info('src_pos_in_window')
|| _pos:=0
?};

:: co przeciagamy
{? _dnd
|| _records:=dnd_info('dropped_records')
|| _records:=_b
?};
{? ~exec('dnd_block','px_grp',_records)
|| {? _dnd || win_set('cur_row_pos='+$_pos) ?};
   return()
?};

:: na co upuszczamy
{? _dnd
|| _dest_rec:=dnd_info('dest_record')
|| _dest_rec:=_c
?};

:: Obsluga blokowania - blokuje wszystko co zlapalem i na co upuszczam
_can_continue:=1;

PX_GRPS.cntx_psh(); PX_GRP.cntx_psh();
PX_GRPS.clear(); PX_GRP.clear();

:: 1. Blokowanie grupy na ktora upuszczam
{? _dest_rec<>null()
|| {? PX_GRPS.seek(_dest_rec)
   || _dest_grp:=PX_GRPS.PX_GRP;
      {? exec('lock','px_grp',_dest_grp)=0
      || _can_continue:=0
      ?}
   ?}
?};
_kind:='Z';
:: 2. Blokowanie grup ktore przemieszczam
{? _can_continue>0
|| {? _records.first()
   ||
      _grupowa:=1;
      {? _records.size()>1
      || _grupowa:=2
      ?};

      {!
      |? {? PX_GRPS.seek(_records.REF,)
         || _kind:=PX_GRPS.PX_GRP().KIND;
            _moved_grp:=PX_GRPS.PX_GRP;
            {? exec('lock','px_grp',_moved_grp,_grupowa)=0
            || _can_continue:=0
            ?}
         ?};
         _records.next()
      !}
   ?}
?};

{? _can_continue>0
||
   {? _dest_rec=null()
   ||
::    Obsluga upuszczania na pusty obszar okna (za wszystkimi rekordami)
::    chcemy przeniesc cala galaz na pusty obszar
      PX_GRPS.cntx_pop();
      PX_GRP.cntx_pop();
      win_set('cur_row_pos='+$_pos);
::    konczymy niepowodzeniem
      return()
   ||
::    Obsluga upuszczania na konkretny rekord (czyli przejmujemy jego numer)
      {? PX_GRPS.seek(_dest_rec)
      || PX_GRP.index('LP');
         PX_GRP.prefix(PX_GRPS.PX_VER,_kind);
         {? PX_GRP.seek(PX_GRPS.PX_GRP)
         || _kind:=PX_GRP.KIND;
::          _records z PX_GRPS przepisywane na analogiczne dla PX_GRP
            _px_grp:=tab_tmp(1,'POS','INTEGER','POS','REF','INTEGER','REF','CRC','INTEGER','CRC');
            {? _records.first()
            || {!
               |? _px_grp.POS:=_records.POS;
                  _px_grp.REF:=exec('FindAndGet','#table',PX_GRPS,_records.REF,PX_GRPS.name(),"#PX_GRP",0);
                  _px_grp.CRC:=_records.CRC;
                  _px_grp.add();
                  _records.next()
               !}
            ?};

            exec('zmien_lp','#dragdrop','LP_Q','LP',_px_grp,PX_GRP);

::          Stempluje kolejke czasem i userem modyfikacji
            exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER);

            PX_GRPS.sel_del()
         ?}
      ?}
   ?}
?};

:: Obsluga blokowania - odblokowuje wszystko co wczesniej probowalem zablokowac
_can_continue:=1;

:: 1. Odblokowanie grupy na ktora upuszczam
{? _dest_rec<>null()
|| {? PX_GRPS.seek(_dest_rec)
   || _dest_grp:=PX_GRPS.PX_GRP;
      exec('unlock','px_grp',_dest_grp);
      exec('set_sim_mod','px_grp',_dest_grp,'T')
   ?}
?};
:: 2. Odblokowanie grup ktore przemieszczam
{? _can_continue>0
|| {? _records.first()
   || {!
      |? {? PX_GRPS.seek(_records.REF,)
         || _moved_grp:=PX_GRPS.PX_GRP;
            exec('unlock','px_grp',_moved_grp);
            exec('set_sim_mod','px_grp',_moved_grp,'T')
         ?};
         _records.next()
      !}
   ?}
?};

PX_GRPS.cntx_pop(); PX_GRP.cntx_pop();

:: Aktualizuje przyciski dot przeliczania jednej wersji planu
{? exec('is_one_version','px_param')>0
|| exec('przelicz_btn','px_plan')
?};
~~


\dnd_conns
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Obsluga przeciagania rekordow z okna PX_CONN na okno PX_GRPS
::----------------------------------------------------------------------------------------------------------------------
_pos:=dnd_info('src_pos_in_window');

{? PX_CONN.sel_size()>1
|| FUN.emsg('Przesunięcie dostępne tylko dla pojedynczego rekordu.'@);
   win_set('cur_row_pos='+$_pos);
   return()
?};

:: co przeciagamy (jeden rekord)
_records:=dnd_info('dropped_records');
_records.first();

:: na co upuszczamy
_dest_rec:=dnd_info('dest_record');

:: Obsluga blokowania - blokuje wszystko co zlapalem i na co upuszczam
_can_continue:=1;

:: 1. Blokowanie grupy na ktora upuszczam
{? _dest_rec<>null()
|| {? PX_GRPS.seek(_dest_rec)
   || _dest_grp:=exec('FindAndGet','#table',PX_GRP,$PX_GRPS.PX_GRP,,,null());
      {? exec('lock','px_grp',_dest_grp)=0
      || _can_continue:=0
      ?}
   || _can_continue:=0
   ?}
?};
:: 2. Blokowanie grupy z ktorej przemieszczam
{? _can_continue>0
|| {? _records.first()
   || {? PX_CONN.seek(_records.REF,)
      || _moved_grp:=exec('FindAndGet','#table',PX_GRP,$PX_CONN.PX_GRP,,,null());
         {? exec('lock','px_grp',_moved_grp)=0
         || _can_continue:=0
         ?}
      || _can_continue:=0
      ?}
   ?}
?};
{? _can_continue>0
|| {? _dest_rec<>null() & PX_GRPS.PX_GRP=PX_CONN.PX_GRP
   ||
::    Upuscilem na ta sama grupe wiec nic sie nie dzieje
      _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? _dest_rec<>null() & exec('px_grp_oper','px_tie',PX_GRPS.PX_GRP)>0
   || FUN.emsg('Element zaplanowany na podstawie planu operacyjnego, rekonfiguracja niedozwolona.'@);
      _can_continue:=0
   ?}
?};
{? _can_continue>0
|| {? exec('px_grp_oper','px_tie',PX_CONN.PX_GRP)>0
   || FUN.emsg('Element zaplanowany na podstawie planu operacyjnego, rekonfiguracja niedozwolona.'@);
      _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? _dest_rec<>null()
   || KOMM.init(250,,'Kontrola przesuwania elementów w kolejce'@);
      _can_continue:=exec('can_add_obj','px_grp',PX_GRPS.PX_GRP,PX_CONN.PX_OBJ,1);
      KOMM.select()
   ?}
?};

PX_CONN.cntx_psh();
PX_GRPS.cntx_psh();
PX_GRP.clear();

{? _can_continue>0
||
:: Przeciagniecie na pusty obszar, czyli zalozenie nowego PX_GRP
   {? _dest_rec=null()
   || {? PX_CONN.seek(_records.REF,)
      || _grp:=PX_CONN.PX_GRP;
         _tech:=PX_CONN.PX_GRP().PX_TEX;
         _ver:=PX_CONN.PX_GRP().PX_VER;
         _sym:=PX_CONN.PX_GRP().SYMBOL;
         _opis:=PX_CONN.PX_GRP().NAZWA;
         _zwrot:=PX_CONN.PX_GRP().DIR;
         _ilosc:=PX_CONN.ILOSC;
         _startd:=PX_CONN.PX_GRP().STARTD;
         _startt:=PX_CONN.PX_GRP().STARTT;
         _tm_start:=PX_CONN.PX_GRP().TM_START;
         _endd:=PX_CONN.PX_GRP().ENDD;
         _endt:=PX_CONN.PX_GRP().ENDT;
         _tm_end:=PX_CONN.PX_GRP().TM_END;
         _set_src:=PX_CONN.PX_GRP().SET_SRC;
         _ref:=PX_CONN.ref()
      || PX_CONN.cntx_pop();
         PX_GRPS.cntx_pop();
::       konczymy niepowodzeniem
         win_set('cur_row_pos='+$_pos);
         return()
      ?};

      PX_GRP.blank();
      PX_GRP.NAZWA:=_opis;
      PX_GRP.PX_TEX:=_tech;
      PX_GRP.PX_VER:=_ver;
      PX_GRP.SYMBOL:=_sym;
      PX_GRP.DIR:=_zwrot;
      PX_GRP.ILOSC:=_ilosc;
      PX_GRP.cntx_psh();
      PX_GRP.index('LP');
      PX_GRP.prefix(_ver,'Z');
      _nr:=PX_GRP.size();
      PX_GRP.cntx_pop();
      PX_GRP.LP_Q:=_nr+1;
      PX_GRP.STARTD:=_startd;
      PX_GRP.STARTT:=_startt;
      PX_GRP.TM_START:=_tm_start;
      PX_GRP.ENDD:=_endd;
      PX_GRP.ENDT:=_endt;
      PX_GRP.TM_END:=_tm_end;
      PX_GRP.SET_SRC:=_set_src;
      {? PX_GRP.add()
      || _ref:=PX_GRP.ref();
         PX_CONN.clear();
         PX_CONN.LP_GRP:=1;
         PX_CONN.PX_GRP:=_ref;
         PX_CONN.put();

::       aktualizuje pole materiału
         exec('update_m','px_grp',PX_CONN.PX_GRP);

::       Stempluje kolejke czasem i userem modyfikacji
         exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER);

::       Aktualizuje date graniczna nowej grupy na podstawie terminow realizacji obiektow
::       wchodzacych w jej sklad
         exec('upd_termin','px_grp',_ref);

         {? exec('is_one_version','px_param')>0
         ||
::          Jesli praca na jednej wersji planu to wyciagniecie czegos z grupy
::          powinno spowodowac ze ta grupa z ktorej wyciagamy zostaje usunieta z planu
            exec('clean_from_plan','px_grp',_grp)
         ?}
      ?};
::    Aktualizuje date graniczna grupy zrodlowej na podstawie terminow realizacji obiektow
::    wchodzacych w jej sklad
      exec('upd_termin','px_grp',_grp)


:: Przeciagniecie na PX_GRPS, czyli wrzucenie PX_CONN do nowej PX_GRP
   ||
::    szukamy na co upuszczamy
      _poz:=0;
      {? PX_GRPS.seek(_dest_rec)
      || {? PX_CONN.seek(_records.REF,)
         || _grp:=PX_CONN.PX_GRP;
            _tech:=PX_CONN.PX_GRP().PX_TEX;
            _jm:=PX_CONN.PX_GRP().JM
         || PX_CONN.cntx_pop();
            PX_GRPS.cntx_pop();
::          konczymy niepowodzeniem
            win_set('cur_row_pos='+$_pos);
            return()
         ?};

         {? PX_GRP.seek(PX_GRPS.PX_GRP)
         ||
            {? PX_GRP.PX_TEX<>_tech
            || FUN.emsg('Technologia obiektu różna od technologii grupującej, przeniesienie zostaje przerwane.'@);
               PX_GRPS.cntx_pop();
               PX_CONN.cntx_pop();
               win_set('cur_row_pos='+$_pos);
::             konczymy niepowodzeniem
               return()
            |? PX_GRP.JM<>_jm; 0
            || FUN.emsg('Jednostka miary obiektu różna od jednostki miary obiektów zgrupowanych, przeniesienie zostaje przerwane.'@);
               PX_GRPS.cntx_pop();
               PX_CONN.cntx_pop();
               win_set('cur_row_pos='+$_pos);
::             konczymy niepowodzeniem
               return()
            |? exec('is_blocked','px_grp')>0
            || FUN.emsg('Element na który upuszczamy jest zablokowany, operacja przesunięcia zostaje wycofana.'@);
               PX_GRPS.cntx_pop();
               PX_CONN.cntx_pop();
               win_set('cur_row_pos='+$_pos);
::             konczymy niepowodzeniem
               return()
            |? PX_GRP.STATUS=exec('status_wyk1','px_grp')
            || FUN.emsg('Element na który upuszczamy jest wykonywany, operacja przesunięcia zostaje wycofana.'@);
               PX_GRPS.cntx_pop();
               PX_CONN.cntx_pop();
               win_set('cur_row_pos='+$_pos);
::             konczymy niepowodzeniem
               return()
            |? PX_GRP.STATUS=exec('status_wyk2','px_grp')
            || FUN.emsg('Element na który upuszczamy jest wykonany w całości, operacja przesunięcia zostaje wycofana.'@);
               PX_GRPS.cntx_pop();
               PX_CONN.cntx_pop();
               win_set('cur_row_pos='+$_pos);
::             konczymy niepowodzeniem
               return()
            || PX_CONN.cntx_psh();
               PX_CONN.index('PX_GRP');
               PX_CONN.prefix(PX_GRP.ref());
               {? PX_CONN.last()
               || _poz:=PX_CONN.LP_GRP+1
               ?};
               PX_CONN.cntx_pop();

               {? PX_CONN.seek(_records.REF,)
               || PX_CONN.LP_GRP:=_poz;
                  PX_CONN.PX_GRP:=PX_GRP.ref();
                  PX_CONN.prefix();
                  PX_CONN.put();

::                aktualizuje pole materiału
                  exec('update_m','px_grp',PX_CONN.PX_GRP);

::                Stempluje kolejke czasem i userem modyfikacji
                  exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER);

                  {? exec('is_one_version','px_param')>0
                  ||
::                   Jesli praca na jednej wersji planu to wyciagniecie czegos z grupy
::                   powinno spowodowac ze ta grupa z ktorej wyciagamy zostaje usunieta z planu
                     exec('clean_from_plan','px_grp',_grp)
                  ?}
               ?};
::             Aktualizuje date graniczna grupy docelowej na podstawie terminow realizacji obiektow
::             wchodzacych w jej sklad
               exec('upd_termin','px_grp',PX_GRP.ref())
            ?}
         ?}
      ?}
   ?};
   exec('prenumber','px_grp')
?};

:: Obsluga blokowania - odblokowuje wszystko co wczesniej probowalem zablokowac
_can_continue:=1;

:: 1. Odblokowanie grupy na ktora upuszczam
{? _dest_rec<>null()
|| {? PX_GRPS.seek(_dest_rec)
   || _dest_grp:=exec('FindAndGet','#table',PX_GRP,$PX_GRPS.PX_GRP,,,null());
      {? exec('unlock','px_grp',_dest_grp)=0
      || _can_continue:=0
      ?}
   ?}
?};
:: 2. Odblokowanie grupy z ktorej przemieszczam
{? _can_continue>0
|| {? _records.first()
   || {? PX_CONN.seek(_records.REF,)
      || _moved_grp:=exec('FindAndGet','#table',PX_GRP,$PX_CONN.PX_GRP,,,null());
         {? exec('unlock','px_grp',_moved_grp)=0
         || _can_continue:=0
         ?}
      ?}
   ?}
?};

PX_GRPS.cntx_pop();
PX_CONN.cntx_pop();

:: Aktualizuje przyciski dot przeliczania jednej wersji planu
{? exec('is_one_version','px_param')>0
|| exec('przelicz_btn','px_plan')
?};
~~


\wer_px_txt_v
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: Okno wertowania wer tabeli PX_GRPS - Przepis podglad
::----------------------------------------------------------------------------------------------------------------------
_px_grp:={? exec('is_one_version','px_param') || $PX_GRPS.PX_GRP || PxSelect.Pxgrp.TAB.PX_GRPI ?};

PX_GRP.cntx_psh();
PX_TEX.cntx_psh();
PX_GRP.clear();
{? PX_GRP.seek(_px_grp,8+_px_grp)
|| {? PX_GRP.PX_TEX<>null()
   || PX_GRP.PX_TEX();
      exec('PX_TEXWER4GRPbG','px_tex');
      ~~
   || FUN.emsg('Element kolejki nie posiada przepisu planistycznego.'@)
   ?}
?};
PX_TEX.cntx_pop();
PX_GRP.cntx_pop();
~~


\czy_sets_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Przed wyswietleniem PX_VAR1.CZY_SETS
::----------------------------------------------------------------------------------------------------------------------
PX_VAR.PX_SET<>null

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:37 bfd128cd6ea80730a55804dc92fcc254b910f7394b3762f5fe91306cb7293e5ac6b385d488783a234b46b626586c5c44b8a5751d5c3884e34cdc9e25734a6dd8634d45a8280af5219317fcf4cdf99b9807a2a0195ef0a70272b5fec7c72fdbb236c8d8dd83bdb90961aa6792bab3ee13e264cd474e1f294b9ebaeb363a1690b4
