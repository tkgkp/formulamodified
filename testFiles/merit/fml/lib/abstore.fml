:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: abstore.fml
:: Utworzony: 05.10.2018
:: Autor: trocek
:: Systemy:
::======================================================================================================================
:: Zawartość:   Integracja  z ABSTORE
:: executeSync - metoda używa SYNCHRO do wysyłania danych
:: executeNoSync - wysyłanie początkowe zawartości kartotek i słowników bez SYNCHRO
::
:: metody wysyłające poszczególne elementy:
:: send_stock, send_prices, send_categories ...   - opcjonalny parametr uzywajSynchro 1/0 - domyślnie 1
::
::
:: metody send_products, send_productpictures - powinny być wywoływane w tej kolejności, kasowanie zapisów w synchro
::        następuje na końcu metody send_productpictures
:: send_products wysyła również ceny produktu (jeśli nie jest jeszcze określony cennik to towar jest wysyłany jako nieaktywny,
::        ale aby został założony cena musi być wysłana więc jest to 1.00 )
::
:: po wyczyszczeniu danych w sklepie należy ponownie wysłać start-conversation z nowym id
::
::800100    Nazwa konfiguracji do logowania
::800101    ID konta
::800102    Id połączenia
::800103    Użytkownik do api
::800104    Hasło do api
::800105    Adres do api
::800107    Nazwa w synchro
::800108    Kod oddziału    c
::800109    Kody obsługiwanych magazynów    MWG
::800110    Czy wysyłać store    1
::800115    limit ilosci produktu na zamówieniu 0
::800116    maks domyślna ilości dni przekroczenia terminu płatności dla kontrahenta
::======================================================================================================================

\create_confobj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_abstore:=obj_new('accId',
'convId',
'user',
'pass',
'url',
'cennik',
'magazyn',
'oddz',
'useStore',
'storeId',
'useDivisionPriceList',
'synchro',
'configName',
'configOk',
'useDivision',
'usePersonalOffer',
'defaultOffer',
'createDivisionMain',
'productLimit',
'contDayLimit',
'daysLimit',
'limitStrategy',
'eFak',
'sendBasePrice',
::tabela ze zmodyfikowanymi produktami z synchro
'tabRef',
::odwrocone oferty - cennik ogólny = oferta dedykowana, cennik kontrahenta(P1)=oferta standardowa
'reverseOffer',
::łączenie wszystkich cenników kontrahenta w jedną ofertę dedykowaną
'mergeOffer',
::kody cennikow tworzacych oferte domyslna
'tabCen',
::kody magazynow
'tabMG',
::łączenie rabatów (N - dla KŚ)
'sumRab',
::generowanie rozrachunków do zamówień
'settlementOrder',
:: strategia ofert
'strOfe',
::cenniki dla modyfikacji pojedyńczego materiału
'mCen'
);
_abstore.tabCen:=tab_tmp(1,'KOD','STRING[20]','KOD');
_abstore.tabRef:=tab_tmp(1,'REF','STRING[16]','REF','IDADD','STRING[24]','IDADD');
_abstore.tabMG:=tab_tmp(1,'SYM','STRING[20]','SYM');
_abstore.settlementOrder:=0;
_abstore


\setup_common
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: wypelnia tabele __AbStore.tabCen listą cenników oraz __AbStore.tabMG listą magazynów
::----------------------------------------------------------------------------------------------------------------------
:__AbStore.cennik:='cSC-000';
::__KUCHNIESWIATA:=0;
_listaCennikow:=spli_str(__AbStore.cennik,',');
_idx:=1;
{! |?
   __AbStore.tabCen.KOD:=_listaCennikow[_idx];
   __AbStore.tabCen.add();
   _idx+=1;
   _idx<=obj_len(_listaCennikow)
!};
_magazyny:=exec('magazyny','abs_conf');
_idx:=1;
{! |?
   __AbStore.tabMG.SYM:=_magazyny[_idx];
   __AbStore.tabMG.add();
   _idx+=1;
   _idx<=obj_len(_magazyny)
!}


\setupAbstoreb2b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: odczyt konfiguracji dla B2B
::----------------------------------------------------------------------------------------------------------------------
{? var_press('__AbStore')>=0 || &__AbStore ?};
__AbStore:=exec('create_confobj','abstore');
__AbStore.accId:=exec('param_get','abs_conf', 800101, 2);
__AbStore.convId:=exec('param_get','abs_conf', 800102, 2);
__AbStore.user:=exec('param_get','abs_conf', 800103, 2);
__AbStore.pass:=exec('param_get','abs_conf', 800104, 2);
__AbStore.url:=exec('param_get','abs_conf', 800105, 2);
:lista cennikow do oferty standardowej wszystkich klientow
__AbStore.cennik:=gsub(exec('param_get','abs_conf', 800106, 2),' ,',',');
::nazwa w synchro
__AbStore.synchro:=exec('param_get','abs_conf', 800107, 2);
::oddzial
__AbStore.oddz:=exec('param_get','abs_conf', 800108, 2);
::ujednolicenie zapisu w merit/xpertis
__AbStore.magazyn:=exec('param_get','abs_conf', 800109, 2);
__AbStore.magazyn:=gsub(__AbStore.magazyn,' ,',',');
{? __AbStore.magazyn+1=',' ||  __AbStore.magazyn:=__AbStore.magazyn-1 ?};
::czy wysyłać store i product-store
__AbStore.useStore:=1;
__AbStore.storeId:='';
::odwrocone oferty
:__AbStore.reverseOffer:={? exec('param_get','abs_conf', 800113, 2)='T' || 1 || 0 ?};
__AbStore.reverseOffer:=0;
__AbStore.createDivisionMain:=0;
__AbStore.useDivisionPriceList:=0;
::oferta domyslna dla wszystkich kontrahentow (tylko te produkty beda widoczne dla wszystkich)
_limit:=exec('param_get','abs_conf', 800115, 1);
{? _limit=0 || __AbStore.productLimit:=0 || __AbStore.productLimit:=_limit ?};
__AbStore.contDayLimit:=exec('param_get','abs_conf', 800116, 1);
__AbStore.mergeOffer:={? exec('param_get','abs_conf', 800117, 2)='T' || 1 || 0 ?};
__AbStore.useDivision:=1;
::wysylanie ofert dla oddzialow kontrahentow (albo cennika indywidualnego)
__AbStore.configName:='ABSTOREB2B';
{? __AbStore.convId='' || __AbStore.convId:=exec('send_startconv','abstore',800102, 800119) ?};
::czy wysylac ceny z cennika bazowego podlaczonego do cennika kontrahenta
__AbStore.sendBasePrice:=1;
exec('setup_common','abstore');
__AbStore.sumRab:=(exec('param_get','abs_conf', 800118)='T');
__AbStore.daysLimit:=exec('param_get','abs_conf', 800120, 1);
_lim:=exec('param_get','abs_conf', 800121, 2);
__AbStore.limitStrategy:=
{? _lim='Blokuj' || 'BLOCK'
|? _lim='Nie blokuj' || 'NO_BLOCK'
|? _lim='Blokuj dla przeterminowanych należności' || 'BLOCK_EXCEEDED_DAYS'
|? _lim='Blokuj dla wszystkich należności powyżej limitu' || 'BLOCK_EXCEEDED_DUE'
|? _lim='Blokuj dla przeterminowanych należności powyżej limitu' || 'BLOCK_EXCEEDED_DAYS_AND_DUE'
|| 'BLOCK_EXCEEDED_DAYS_OR_DUE' ?};
__AbStore.eFak:=exec('param_get','abs_conf', 800128, 2);
__AbStore.strOfe:=exec('param_get','abs_conf', 800130, 2);
__AbStore.mCen:=exec('param_get','abs_conf', 800133, 2)='T';
::[KUCHNIE ŚWIATA] wyłącza sumowanie rabatu z kartoteki kontrahenta gdy dany produkt jest w jego cenniku indywidualnym
::{? __KUCHNIESWIATA || __AbStore.sumRab:=0 ?};
__AbStore.configOk:=(__AbStore.accId<>'')&(__AbStore.convId<>'')&(__AbStore.user<>'')&(__AbStore.pass<>'')&
                     (__AbStore.url<>'')&(__AbStore.synchro<>'');
proc_exe('kompresuj@synchro', __AbStore.synchro, 0);
''


\setupAbstoreb2c
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: odczyt konfiguracji dla B2C
::          B2C nie obsługuje wysyłania kontrahentów, grup kontrahentów i cenników indywidualnych
::----------------------------------------------------------------------------------------------------------------------
{? var_press('__AbStore')>=0 || &__AbStore ?};
__AbStore:=exec('create_confobj','abstore');
__AbStore.reverseOffer:=0;
__AbStore.accId:=exec('param_get','abs_conf', 800201, 2);
::UWAGA: convId powinno się zmieniać po wyczyszczeniu danych konta w sklepie
__AbStore.convId:=exec('param_get','abs_conf', 800202, 2);
__AbStore.user:=exec('param_get','abs_conf', 800203, 2);
__AbStore.pass:=exec('param_get','abs_conf', 800204, 2);
__AbStore.url:=exec('param_get','abs_conf', 800205, 2);
::kod cennika
__AbStore.cennik:=gsub(exec('param_get','abs_conf', 800206, 2),' ,',',');
::nazwa w synchro
__AbStore.synchro:=exec('param_get','abs_conf', 800207, 2);

_limit:=exec('param_get','abs_conf', 800215, 1);
{? _limit=0 || __AbStore.productLimit:=0 || __AbStore.productLimit:=_limit ?};
::oddzial
__AbStore.oddz:=exec('param_get','abs_conf', 800208, 2);
::ujednolicenie zapisu w merit/xpertis
__AbStore.magazyn:=gsub(exec('param_get','abs_conf', 800209, 2),' ,',',');
{? __AbStore.magazyn+1=',' ||  __AbStore.magazyn:=__AbStore.magazyn-1 ?};
::useStore nie jest obsługiwane w B2C i jest zawsze = 0
__AbStore.useStore:=0;
__AbStore.storeId:='';
__AbStore.configName:='ABSTOREB2C';
__AbStore.mCen:=0;
{? __AbStore.convId='' || __AbStore.convId:=exec('send_startconv','abstore',800202, 800219) ?};
exec('setup_common','abstore');
__AbStore.configOk:=(__AbStore.accId<>'')&(__AbStore.convId<>'')&(__AbStore.user<>'')&(__AbStore.pass<>'')&
                     (__AbStore.url<>'')&(__AbStore.synchro<>'');
proc_exe('kompresuj@synchro', __AbStore.synchro, 0);
''


\xml_messageheader
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: nagłówek message
::   WY: string xml
::----------------------------------------------------------------------------------------------------------------------
_dt:=gsub($date(),'/','-')+'T'+$time()+':00';
_tm_stamp:=9+(1-$tm_stamp(date~1, date~2, date~3, time~1, time~2, time~3));
_xml:='<?xml version="1.0" encoding="UTF-8"?>
        <message account-id="%1" conversation-id="%2"
        create-date="%3" create-seq="%4"
        xmlns="http://assecobs.com/ns/a4b" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://assecobs.com/ns/a4b http://docs.abs.assecobs.pl/schema/a4b/a4b.xsd">'
        [__AbStore.accId, __AbStore.convId, _dt, _tm_stamp];
_xml


\xml_messagefooter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: zamknięcie taga message
::   WY: string
::----------------------------------------------------------------------------------------------------------------------
_xml:='</message>';
_xml


\xml_store
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: <store> - magazyn w ABSTORE. MG ustawione na kontekst magazynu do wysłania
::   WY: string xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<store eid="%1">
            <name>%2</name>
            <location>%3</location>
            <description>%4</description>
         </store>
         <store-activity store-eid="%1" activity="true" />
         '[MG.SYM,MG.NAZ,MG.ODDZ,MG.SYM];
_xml


\xml_category
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: grupa towarów <category-store>
::   WE: _a - obiekt kategoria (REF,NAZ,KOD)
::   WY: string xml
::----------------------------------------------------------------------------------------------------------------------
_catStore:='';
{? __AbStore.useStore & __AbStore.tabMG.first()
||
   {! |?
      _catStore+=%13+%10+'<category-store category-eid="%1" store-eid="%2"/>'[_a.REF, __AbStore.tabMG.SYM];
      __AbStore.tabMG.next()
   !}
?};
_naz:=exec('konwersja_xml','xml',_a.NAZ);
_xml:='<category eid="%1" order="1"/>
   <category-i18n lang="pl" category-eid="%1"><name>%2</name></category-i18n>
   %3' [_a.REF, _naz, _catStore];
_xml+='<category-visibility category-eid="%1" visible="%2"/>'
[_a.REF,{? exec('mgr_abstore_a','abstore')|| 'true' || 'false' ?}];
_xml


\subxml_category
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: podgrupa towarów <category-store>
::   WE: _a - obiekt kategoria (REF,NAZ,KOD)
::   WY: string xml
::----------------------------------------------------------------------------------------------------------------------
_catStore:='';
{? __AbStore.useStore & __AbStore.tabMG.first()
||
   {! |?
      _catStore+=%13+%10+'<category-store category-eid="%1" store-eid="%2"/>'[ exec('tostring','abstore',_a.ref), __AbStore.tabMG.SYM];
      __AbStore.tabMG.next()
   !}
?};
_xml:='<category eid="%1" parent-eid="%4"  order="1"/>
   <category-i18n lang="pl" category-eid="%1"><name>%2</name></category-i18n>
   %3' [ exec('tostring','abstore',_a.ref), _a.NAZ, _catStore, exec('tostring','abstore', _a.MGR)];
_xml


\xml_unit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: jednostki miary
::   WE: _a - tabela JM
::   WY: string xml
::----------------------------------------------------------------------------------------------------------------------
_div:='true';
_step:='0.0001';

{? _a=JM
||
   _ref:=$_a.ref()
||
   _ref:=_a.REF
?};

{? _a.NAZ<>''
||
_xml:='<unit eid="%1" divisable="%2" step="%3" full-value="1" />
         <unit-i18n lang="pl" unit-eid="%1">
           <name>%4</name>
           <shortcut>%5</shortcut>
         </unit-i18n>'[_ref, _div, _step, _a.NAZ, _a.KOD]
||
   _xml:=''
?};
_xml


\xml_productactivity
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: komunikat aktywnosci produktu
::   WE: _a - id produktu ($ref)
::       _b - true/false
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<product-activity product-eid="%1" activity="%2" />'[_a, _b];
_xml


\xml_product
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: generuje fragment XML z towarem. M ustawione na materiał do wysłania
::   WY: string
::----------------------------------------------------------------------------------------------------------------------
TAP.cntx_psh();
SLO.cntx_psh();
_m_sv:=exec('vat_hist','abstore');
_wart:=spli_str(|_m_sv,' ')[1];
_vat:=gsub(gsub(_wart,'%',''),',','.');
TAP.index('RODZM');
::cennik ogolny sprzedaz
TAP.prefix(__AbStore.oddz,'S',M.ref,'C');
_opis:=M.memo_txt(,1,'OPIS');
_price:=obj_new('REF','M','CEN','CENB','WAL','OD','DO');
_xml:=%13+%10+ '<product eid="%1" index-catalogue="%2" ref-unit-eid="%3" sale-unit-eid="%4"
         ref-qty="1" vat="%5" vat-profit-margin="false" />
    <product-i18n product-eid="%1" lang="pl">
        <name>%6</name>
        <additional-name></additional-name>
        <short-desc>%7</short-desc>
        <long-desc>%8</long-desc>
    </product-i18n>'[$M.ref(), xml_valu(M.KTM), $M.J, $M.J, _vat, xml_valu(M.N), xml_valu(M.OSL), xml_valu(_opis)];
_xml2:=exec('xml_productactivity','abstore', $M.ref(), {? M.A='T' & exec('m_abstore_a','abstore') || 'true' || 'false' ?});
_xml3:=%13+%10+'<product-category product-eid="%1" category-eid="%2" main="1" overwrite-current="1" order="%3"/>'
[$M.ref(),
{? M.MGRP=null
| (__AbStore.useStore=1 & exec('param_get','abs_conf', 800124, 2)='N')
| (__AbStore.useStore=0 & exec('param_get','abs_conf', 800224, 2)='N')
||  $M.MGR || $M.MGRP ?},
{? var_press('_a')=type_of(1) || $_a || '1' ?}
];

{? __AbStore.reverseOffer || _pri:=' and TAR.P=1' || _pri:='' ?};
_m_ref:=' and M.REFERENCE=\''+$M.ref()+'\'';
_xml4:='';

:: Cennik EUR
_sql:='select top 1 TAR.P, TAP.REFERENCE as REF, TAP.*, SLO.KOD from M
   join TAP using(TAP.M,M.REFERENCE)
   join TAR using(TAR.REFERENCE,TAP.TAR)
   join :_a C using(C.KOD,TAR.KOD)
   join SLO using(TAP.WAL,SLO.REFERENCE)
   where '+ exec('m_abstore_sql','abstore') +'
   and TAP.RODZ=''C'' %1 %2 and TAP.CEN<>0
   and TAR.SD=''S''
   and SLO.KOD=:_b
   and NVL(TAP.OD,CURRENT_DATE)<=CURRENT_DATE
   and NVL(TAP.DO,CURRENT_DATE)>=CURRENT_DATE
   order by TAR.P desc'[_pri, _m_ref];
_tabEur:=sql(_sql, __AbStore.tabCen, '\'EUR\'');

_cur:=exec('currency','abstore');

{? _tabEur.first()
||
   _prc:=1-_tabEur.PRC/100;
   _price.M:=_tabEur.M;
   _price.REF:=_tabEur.REF;
   _price.CEN:=form(_tabEur.CEN*_prc,,2,'9.');
   _price.CENB:=form(_tabEur.CENB*_prc,,2,'9.');
   _price.WAL:=_tabEur.KOD;
   _price.OD:='0000/00/00';
   _price.DO:=$_tabEur.DO;
   _xml4+=exec('xml_productprice','abstore',_price);

   _price.CEN:=form(_tabEur.CEN*_cur.PEUR*_prc,,2,'9.');
   _price.CENB:=form(_tabEur.CENB*_cur.PEUR*_prc,,2,'9.');
   _price.WAL:='PLN';
   _xml4+=exec('xml_productprice','abstore',_price)
?};

:: Cennik USD
_tabUsd:=sql(_sql, __AbStore.tabCen, '\'USD\'');

{? _tabUsd.first()
||
   _prc:=1-_tabUsd.PRC/100;
   _price.M:=_tabUsd.M;
   _price.REF:=_tabUsd.REF;
   _price.CEN:=form(_tabUsd.CEN*_prc,,2,'9.');
   _price.CENB:=form(_tabUsd.CENB*_prc,,2,'9.');
   _price.WAL:=_tabUsd.KOD;
   _price.OD:='0000/00/00';
   _price.DO:=$_tabUsd.DO;
   _xml4+=exec('xml_productprice','abstore',_price);

   _price.CEN:=form(_tabUsd.CEN*_cur.PUSD*_prc,,2,'9.');
   _price.CENB:=form(_tabUsd.CENB*_cur.PUSD*_prc,,2,'9.');
   _price.WAL:='USD';
   _xml4+=exec('xml_productprice','abstore',_price)
?};

:: Cennik PLN
_tabM:=sql(_sql, __AbStore.tabCen, '\'PLN\'');

{? _tabM.first()
||
   _prc:=1-_tabM.PRC/100;
   _price.M:=_tabM.M;
   _price.REF:=_tabM.REF;
   _price.CEN:=form(_tabM.CEN*_prc,,2,'9.');
   _price.CENB:=form(_tabM.CENB*_prc,,2,'9.');
   _price.WAL:=_tabM.KOD;
   _price.OD:='0000/00/00';
   _price.DO:=$_tabM.DO;
   _xml4+=exec('xml_productprice','abstore',_price)
?};

{? _xml4=''
||
   _xml4:=%13 + %10 + exec('xml_productprice0','abstore')
?};
TAP.cntx_pop();
SLO.cntx_pop();
_xml5:=exec('xml_productstore','abstore',$M.ref());
_xml6:=exec('xml_labelproductall','abstore',M.ref());
_xml7:=exec('xml_productsaleunitparams','abstore');
:: Przypisanie wartości zerowych stanów magazynowych w celu wykorzystania "Sprzedaż poniżej stanu"
_xml8:=exec('send_Z_stock','abstore');
:: Przypisanie ceny minimalnej
_xml9:=exec('p_min_price','abstore');
_xml + %13 + %10  + _xml3 + _xml4 + _xml5 + _xml6 + _xml7 + _xml8 + _xml9 + %13+%10 + _xml2


\vat_hist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.42]
:: OPIS: pobiera informację o stawace VAT z M_SV
::   WY:
::----------------------------------------------------------------------------------------------------------------------
SLO.cntx_psh;
_wyn:=M.VAT().KOD;
_slo:=exec('m_vat','material',M.ref(),null());

{? type_of(_slo)=type_of(null()) & SLO.seek(_slo)
||
   _wyn:=SLO.KOD
?};

SLO.cntx_pop;
_wyn


\checkProduct
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: sprawdza czy towar spelnia warunki przeslania do abstora
::   WE: _a - ref albo kod towaru
::       [_b] - B2B i B2C (domyślnie) lub B2B lub B2C
::       [_c] - czy select
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_type_abstore:={? var_pres('_b')=type_of('') & _b='B2C' || 'B2C'
               |? var_pres('_b')=type_of('') & _b='B2B' || 'B2B'
                                                        || 'B2B&B2C' ?};
{? var_pres('_c')=type_of(1)|| _c || _c:=1 ?};
M.cntx_psh();
M.prefix();
MGRP.cntx_psh();
MGRP.prefix();
{? _type_abstore='B2C' || exec('setupAbstoreb2c','abstore') || exec('setupAbstoreb2b','abstore') ?};
_wynik:='';
_sql:='select M.REFERENCE as REF, M.* from M where M.REFERENCE=''%1'' or M.KTM=''%1'''[_a];
_tab:=sql(_sql);
{? ~_tab.first()
|| _wynik:='Nie znaleziono materiału.'
||
   M.seek(_tab.REF);
   {? _c || KOMM.init(250,100,'Kontrola materiału ABSTORE: %1'[M.N]) ?};
   {? M.A<>'T' || _wynik2:='Materiał nieaktywny.'; {? _c || KOMM.add(_wynik2,4)?}; _wynik+=_wynik2 ?};
   {? _type_abstore='B2C'
   ||
      {? M.MGR().ABSTOREC<>'T'
      || _wynik2:='Grupa mat. "%1" wyłączony znacznik ABSTORE B2C.'[M.MGR().NAZ];
         {? _c || KOMM.add(_wynik2,4)?}; _wynik+=_wynik2
      ?}
   |? _type_abstore='B2B'
   ||
      {? M.MGR().ABSTORE<>'T'
      || _wynik2:='Grupa mat. "%1" wyłączony znacznik ABSTORE B2B.'[M.MGR().NAZ];
         {? _c || KOMM.add(_wynik2,4)?}; _wynik+=_wynik2
      ?}
   ||
      {? var_pres('ABSTOREC',M.MGR())>=0 & M.MGR().ABSTOREC<>'T'
      || _wynik2:='Grupa mat. "%1" wyłączony znacznik ABSTORE B2C.'[M.MGR().NAZ];
         {? _c || KOMM.add(_wynik2,4)?}; _wynik+=_wynik2
      ?};
      {? M.MGR().ABSTORE<>'T'
      || _wynik2:='Grupa mat. "%1" wyłączony znacznik ABSTORE B2B.'[M.MGR().NAZ];
         {? _c || KOMM.add(_wynik2,4)?}; _wynik+=_wynik2
      ?}
   ?};
:: czy jest przypisana podgrupa (jesli grupa ma podgrupy)
   MGRP.index('MGR');
   MGRP.prefix(M.MGR);
   {? MGRP.first() & M.MGRP=null
   ||
      {? _type_abstore<>'B2C' & exec('get','#params', 800124, 2)='T'
      || _wynik2:='Mat. nie jest przypisany do podgrupy wymaganej dla znacznika ABSTORE B2B.';
         {? _c || KOMM.add(_wynik2,3)?}; _wynik+=_wynik2
      ?};
      {? _type_abstore<>'B2B' & exec('get','#params', 800224, 2)='T'
      || _wynik2:='Mat. nie jest przypisany do podgrupy wymaganej dla znacznika ABSTORE B2C.';
         {? _c || KOMM.add(_wynik2,3)?}; _wynik+=_wynik2
      ?}
   ?};
::czy istnieje cena na towar w cenniku ogolnym
   {? __AbStore.reverseOffer || _pri:=' and TAR.P=1' || _pri:='' ?};
::dla ofert odwroconych sprawdzany jest tylko cennik o priorytecie=1
   _sql:='select  top 1 TAR.P, TAP.REFERENCE as REF, TAP.* from M
      join TAP using(TAP.M,M.REFERENCE)
      join TAR using(TAR.REFERENCE,TAP.TAR)
      where TAP.RODZ=''C'' %2
      and M.REFERENCE=''%1'' and TAP.CEN<>0
      and TAR.SD=''S''
      and TAR.ODDZ=''%3''
      and NVL(TAP.OD,CURRENT_DATE)<=CURRENT_DATE
      and NVL(TAP.DO,CURRENT_DATE)>=CURRENT_DATE
      order by TAR.P'[$M.ref, _pri, __AbStore.oddz];
   _tap:=sql(_sql);
   {? ~_tap.first()
   || _wynik2:='Brak cennika ogólnego lub cena netto = 0.'; {? _c || KOMM.add(_wynik2,4)?}; _wynik+=_wynik2
   ?}
?};
MGRP.cntx_pop();
M.cntx_pop();
{? ~KOMM.empty() || {? _c || KOMM.select() ?} ?};
_wynik


\checkClient
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:
::   WE: sprawdza dane kontrahenta i powiazane z nim (odbiorcy, kontakty, powiazania z magazynami)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
::sprawdzenie czy jest odbiorca , z abstore<>'', adres wypelniony e-mail unikalny
::sprawdzenie czy odbiorcy maja przypisane aktywne magazyny
::sprawdzenie czy kazdy odbiorca ma przypisana osobe kontaktowa
::sprawdzenie czy osoby kontaktowe maja przypisane magazyny n]
{? var_pres('_b')=type_of(1)|| _b || _b:=1 ?};
KH.cntx_psh();
KH_ODB.cntx_psh();
KH_OSOB.cntx_psh();
KH_ODBMG.cntx_psh();
KH_ODBMG.index('KO');
KH_OSOBO.cntx_psh();
KH_OSOBO.index('OSOBA');
KH_DOD.cntx_psh();
KH_DOD.index('KH');
exec('setupAbstoreb2b','abstore');
_sql:='select KH.REFERENCE REF, KH.* from KH where KH.REFERENCE=''%1'' or KH.KOD=''%1'''[_a];
_kh:=sql(_sql);
_wynik:='';
_wynik2:='';
{? ~_kh.first()
|| _wynik:='Nie znaleziono kontrahenta.';
   KH.cntx_pop();
   KH_DOD.cntx_pop();
   KH_ODB.cntx_pop();
   KH_OSOB.cntx_pop();
   KH_OSOBO.cntx_pop();
   KH_ODBMG.cntx_pop();
   return(_wynik)
?};
{? _b || KOMM.init(250,100,'Kontrola kontrahenta ABSTORE: %1'[KH.NAZ]) ?};

KH_OSOB.index('KH');
KH_OSOB.prefix(KH.ref);
_jestOsoba:=0;
_jestOdb:=0;
{? KH_OSOB.first()
||
   {! |?
      {? KH_OSOB.ABSTORE='T'
      ||
         _jestOsoba:=1;
         KH_OSOBO.prefix(KH_OSOB.ref);
         {? KH_OSOBO.first
         ||
            {! |?
               {? KH_OSOBO.ODB().ABSTORE='T' || _jestOdb:=1 ?};
               KH_OSOBO.next()
            !}
         ||
            _wynik2:='Osoba kontaktowa: "%1" nie ma przypisanych odbiorców.'[KH_OSOB.NAZWISKO];
            {? _b || KOMM.add(_wynik2,4) ?};
            _wynik+=_wynik2
         ?}
      ?};
      KH_OSOB.next()
   !}
?};
{? _jestOsoba=0
||
   _wynik2:='Brak przypisanych osób kontaktowych dostępnych dla Abstore. ';
   {? _b || KOMM.add(_wynik2,4) ?};
   _wynik+=_wynik2
?};

KH_DOD.prefix(KH.ref);
KH.cntx_pop();
KH_DOD.cntx_pop();
KH_ODB.cntx_pop();
KH_OSOB.cntx_pop();
KH_OSOBO.cntx_pop();
KH_ODBMG.cntx_pop();
{? ~KOMM.empty() || {? _b || KOMM.select() ?} ?};
_wynik


\show_file
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:  na potrzeby debugowania i testowania
::   WE: _a - uchwyt do pliku
::   WY: plik jako string
::----------------------------------------------------------------------------------------------------------------------
fclose(_a)


\xml_productstore
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: product-store -> przypisanie towaru do magazynu
::   WE: _a - $ref towaru
::   WY: string xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='';
{? __AbStore.useStore & __AbStore.tabMG.first()
||
   _message:=exec('xml_messageheader','abstore');
   {! |?
      _xml+=%13+%10+'<product-store product-eid="%1" store-eid="%2"  />'[_a,__AbStore.tabMG.SYM];
      __AbStore.tabMG.next()
   !}
?};
_xml


\xml_productcategory
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: przypisanie towaru do kategorii. M ustawione na rekord do wysłania
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:=%13+%10+'<product-category product-eid="%1" category-eid="%2" main="1" overwrite-current="1" />'[$M.ref, $M.MGR];
_xml


\xml_productsaleunitparams
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: limity jm sprzedazy towaru
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
:{? __AbStore.productLimit=0 & M.MAXILZAM=0 || return('') ?};
_limit:={? M.MAXILZAM>0 || M.MAXILZAM || __AbStore.productLimit ?};
_dokl:=M.DOKL;
{? M.DOKL>4 || _dokl:=4 ?};
_step:=gsub( $({? M.KZ>0 || M.KZ || pow(10, - _dokl) ?}) ,',','.');
_salemax:='';
{? _limit>0 || _salemax:='sale-max="%1"'[gsub( $_limit,',','.')] ?};
_xml:='<product-sale-unit-params product-eid="%1" sale-unit-eid="%2"
      sale-min="%4" %3 sale-default-qty="%4" step="%4"  />'[$M.ref, $M.J, _salemax, _step];
_xml


\xml_productprice
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: TAP ustawione na rekord do wysłania
::   WE: _a - obiekt ( 'REF', 'M', 'CEN', 'CENB', 'WAL', 'OD', 'DO')
::   WY: string xml
::----------------------------------------------------------------------------------------------------------------------
{? _a.OD<>'0000/00/00' || _from:='date-from="%1T00:00:01"'[ gsub(_a.OD,'/','-')] || _from:='' ?};
{? _a.DO<>'0000/00/00' || _to:='date-to="%1T23:59:59"'[gsub(_a.DO,'/','-')] || _to:='' ?};
_xml:='<product-price eid="%1"  product-eid="%2" base-net="%3" base-gross="%4"
         final-net="%3" final-gross="%4" currency="%5" %6 %7 />'[_a.REF, _a.M, gsub(_a.CEN,',','.'),
         gsub(_a.CENB,',','.'), _a.WAL, _from, _to];
_xml


\xml_pricedel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: usunięcie ceny produktu <product-price-del>
::   WE: _a - id ceny (id towaru)
::       _b - id towaru
::       _c - waluta
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<product-price-del eid="%1" product-eid="%2" currency="%3" />'[_a, _b, _c];
_xml


\xml_productrelated
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: produkty powiazane
::   WE: _a    - obiekt ('M', 'MZ')
::   WY: string xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<product-related product-eid="%1"
product-related-eid="%2" related-type="UPSELLING" bidirectional="true" />'[_a.M, _a.MZ];
_xml


\xml_productattribute
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: atrybut produktu
::   WE: _a    - id atrybutu
::       _b    - nazwa
::       _c    - id wartości atrybutu
::       _d    - wartość
::       _e    - id produktu
::   WY:  xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<attribute eid="%1" type="TEXT" dictionary="true" order="1" monovalent="true" />
            <attribute-i18n lang="pl" attribute-eid="%1">
               <name><![CDATA[%2]]></name>
            </attribute-i18n>
            <attribute-val-text-i18n eid="%3" attribute-eid="%1" lang="pl">
               <value><![CDATA[%4]]></value>
            </attribute-val-text-i18n>
            <attribute-prod-attr-val product-eid="%5" attribute-val-eid="%3" />'
            [_a, _b, exec('string_clean','abstore',_c), _d, _e];
_xml


\xml_attributeval
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wartość atrybutu produktu
::   WE: _a - id wartości atrybutu
::       _b - id atrybutu
::       _c - wartość
::       _d - id produktu
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<attribute-val-text-i18n eid="%1" attribute-eid="%2" lang="pl">
           <value><![CDATA[%3]]></value>
         </attribute-val-text-i18n>
         <attribute-prod-attr-val product-eid="%4" attribute-val-eid="%1" />'
         [ exec('string_clean','abstore',_a), _b, _c, _d];
_xml


\xml_sysattributeval
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: wartość atrybutu produktu
::   WE: _a - id wartości atrybutu
::       _b - nazwa systemowa
::       _c - wartość
::       _d - id produktu
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<attribute-system-val eid="%1" system-name="%2" value="%3" />
       <attribute-prod-attr-val product-eid="%4" attribute-val-eid="%1" />'
         [ exec('string_clean','abstore',_a), _b, _c, _d];
_xml


\xml_sysattributevaltxt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: wartość atrybutu produktu
::   WE: _a - id wartości atrybutu
::       _b - id atrybutu
::       _c - wartość
::       _d - id produktu
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_xml:='<attribute-system-val-text-i18n eid="%1" system-name="%2" lang="pl"/>
        <value><![CDATA[%3]]></value>
       </attribute-system-val-text-i18n>
       <attribute-prod-attr-val product-eid="%4" attribute-val-eid="%1" />'
         [ exec('string_clean','abstore',_a), _b, _c, _d];
_xml


\xml_label
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:  utworzenie nowej etykiety <label>
::   WE:  _a - obiekt (REF, N) moze tez byc tabela LABEL
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<label eid="%1"/><label-i18n lang="pl" label-eid="%1">
    <name>%2</name>
  </label-i18n>'[exec('tostring','abstore',_a.ref), xml_valu(_a.N)];
_xml


\xml_labelprod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: powiązanie etykiety z produktem <label-prod-lab>
::   WE: _a - obiekt ('M', 'L')
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<label-prod-lab product-eid="%1" label-eid="%2" />'[
          exec('tostring','abstore',_a.M), exec('tostring','abstore',_a.L)];
_xml


\xml_labelproductall
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: tworzy xmla ze wszystkimi etykietami produktu
::   WE:  _a - M.ref
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
M_LABEL.cntx_psh();
M_LABEL.index('NL');
M_LABEL.prefix(_a);
_result:='';
_mlab:=obj_new('M','L');
_mlab.M:=$_a;
{? M_LABEL.first() ||
   {! |?
      _mlab.L:=$M_LABEL.L;
      _xml:=exec('xml_labelprod','abstore',_mlab);
      _result+=_xml +%13+%10;
      M_LABEL.next()
   !}
?};
M_LABEL.cntx_pop();
_result


\xml_labelprodlabdel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: Odłączenie etykiety od towaru
::   WE: _a - ref usuniętego M_LABEL
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<label-prod-lab-del product-eid="%1" label-eid="%2"/>'[
          exec('tostring','abstore',_a.M), exec('tostring','abstore',_a.L)];
_xml


\xml_labeldel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: usuwanie etykiety (nie będzie działać bo brakuje info z triggera w synchro)
::   WE: _a - id etykiety
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<label-del label-eid="%1"/>'[_a.ref];
_xml


\kh_terminplat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: pobiera domyslny termin platnosci z KH
::   WE: _a - $KH.REF
::   WY: ilosc dni
::----------------------------------------------------------------------------------------------------------------------
KH.cntx_psh();
ZR_SLO.cntx_psh();
KH.prefix();
KH.seek(_a);
ZR_SLO.index('SLO_NR');
ZR_SLO.prefix(KH.PLATNOSC);
_dni:='';
{? ZR_SLO.find_key(2) || _dni:=ZR_SLO.WAR ?};
{? _dni='' || _dni:=$__AbStore.contDayLimit ?};
KH.cntx_pop();
ZR_SLO.cntx_pop();
_dni


\xml_companylimit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS:  limit kredytowy kontrahenta - KH - ustawione na rekord do wysłania
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
SLO.cntx_psh;
KH_DOD.cntx_psh;
KH_DOD.index('KH');
KH_DOD.prefix(KH.ref);
_xml:='';
_str:={? KH.STR_LIM=''
      || __AbStore.limitStrategy
      || _lim:=KH.STR_LIM;
         {? _lim='Blokuj' || 'BLOCK'
         |? _lim='Nie blokuj' || 'NO_BLOCK'
         |? _lim='Blokuj dla przeterminowanych należności' || 'BLOCK_EXCEEDED_DAYS'
         |? _lim='Blokuj dla wszystkich należności powyżej limitu' || 'BLOCK_EXCEEDED_DUE'
         |? _lim='Blokuj dla przeterminowanych należności powyżej limitu' || 'BLOCK_EXCEEDED_DAYS_AND_DUE'
         || 'BLOCK_EXCEEDED_DAYS_OR_DUE' ?}
      ?};
_dni:=${? KH.DAYS_LIM=0 || __AbStore.daysLimit || KH.DAYS_LIM ?};
{? KH_DOD.first
||
   {? KH_DOD.LK=0 & KH.DAYS_LIM=0 & KH.STR_LIM=''
   || _xml:=''
   ||
      _xml:='<merchant-limit %1 due-limit="%2"
         due-limit-currency="PLN" days-limit="%3" block-strategy="%4" />
         '[
         {? KH.ABSTOREC<>'' & KH.LOTUSUID<>''
         || 'company-iid="%1"'[KH.LOTUSUID]
         || 'company-eid="%1"'[$KH.ref]
         ?},
         gsub($KH_DOD.LK,',','.'), _dni, _str]
   ?}
?};
KH_DOD.cntx_pop;
SLO.cntx_pop;
_xml


\xml_client
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:  rejestracja użytkownika
::   WE:  _a - obiekt (ref,EMAIL,IMIE,NAZWISKO,TEL) lub KH_OSOB
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_activit:=
{? _a.ABSTORE='T'
|| 'true'
|| 'false'
?};

_xml:='<client eid="%1">
    <email>%2</email>
    <firstname>%3</firstname>
    <lastname>%4</lastname>
    <phone>%5</phone>
</client>
<client-activity eid="%1" activity="%6" />'
[_a.REF, xml_valu(_a.EMAIL), xml_valu(_a.IMIE), xml_valu(_a.NAZWISKO), xml_valu(_a.TEL), _activit];
_xml


\xml_clientdivision
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: przypisanie użytkownika do oddziału
::   WE: _a - KH_OSOBO
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<client-division main="false" client-eid="%1" division-eid="%2" />'[_a.OSOBA, _a.ODB];
_xml


\xml_company
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: xml z danymi firmy do utworzenia/aktualizacji w abstore. KH - ustawione na kontekst firmy do wysłania
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<company eid="%1">
    <email><![CDATA[%2]]></email>
    <name><![CDATA[%3]]></name>
    <nip>%4</nip>
    <regon>%5</regon>
    <full-name><![CDATA[%6]]></full-name>
</company>'[$KH.ref, KH.EM, KH.NAZ, KH.NIP, KH.REG, KH.NAZ_P];
_xml1:='<address eid="%1">
    <phone>%2</phone>
    <street>%3></street>
    <zip-code>%4</zip-code>
    <city><![CDATA[%5]]></city>
    <iso2-country-code>%6</iso2-country-code>
</address>'[$KH.ref, KH.TEL, exec('address','abstore',KH.UL,KH.DOM,KH.LOKAL), KH.KPOCZ, KH.MIASTO, {? KH.KRAJISO=null || 'pl' || KH.KRAJISO().KODISO ?}];
_adr:=exec('xml_addressinvoice','abstore');
_grp:='company';
_xml2:='';
_xml4:=exec('xml_companylimit','abstore');
{? __AbStore.useDivision
||
   {? __AbStore.createDivisionMain
   ||
      _xml2:=exec('xml_divisionmain','abstore')
   ?};
   KH_ODB.cntx_psh();
   KH_ODB.index('KH_ODB1');
   KH_ODB.prefix(KH.ref);
   {? KH_ODB.first()
   ||
      {! |?
         {? KH_ODB.ABSTORE<>''
         ||
:: przypisanie atrybutu dni dostawy
            _xml5:='
            <attribute-contractor-val
            eid="lfp_%1_%2"
            attribute-contractor-eid="LIMIT_FOR_PAYMENT_IN_DAYS"
            value="%3"/>
            <attribute-contr-contr-attr-val
            contractor-eid="%2"
            attribute-val-eid="lfp_%1_%2"
            />'[
            $KH.ref(),
            $KH_ODB.ref(),
            exec('kh_terminplat','abstore',$KH.ref())
            ];

            _xml2:=_xml2 + exec('xml_division','abstore') + _xml5
         ?};
         KH_ODB.next()
      !}
   ?};
   KH_ODB.cntx_pop();
   _grp:='division'
?};
_xml3:='';
::przypisanie kontrahenta/oddziału do grupy
{? KH.GRKH<>null
||
   _xml3:='<contractor-group-company-company contractor-group-eid="%1" contractor-eid="%2" />'[$KH.GRKH().ref, $KH.ref];
:: dodaje cennik grupowy gdyby nie istniał
   _xml3+=exec('xml_contractorpricegroup','abstore', GRKH.KOD, 'cennik gr. ' + GRKH.KOD);
:: przypisuje kontrahenta do cennika grupowego
   _xml3+=exec('xml_pricegroupcontractor','abstore', GRKH.KOD, $KH.ref())
?};
_xml + %13+%10 + _xml1 + %13+%10 + _xml2 + %13+%10 + _xml3 + _xml4


\xml_addressinvoice
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: xml - adres do faktur - KH ustawiony na kontekst kontrahenta
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<address-invoice eid="%1">
    <firm-name>%2</firm-name>
    <id-number>%3</id-number>
    <id-number-type>NIP</id-number-type>
    <street>%4</street>
    <zip-code>%5</zip-code>
    <city>%6</city>
    <iso2-country-code>%7</iso2-country-code>
</address-invoice>'[$KH.ref, xml_valu(KH.NAZ), KH.NIP, exec('address','abstore',KH.UL,KH.DOM,KH.LOKAL),
xml_valu(KH.KPOCZ), xml_valu(KH.MIASTO),{? KH.KRAJISO=null || 'pl' || KH.KRAJISO().KODISO ?}];
_xml


\xml_divisionmain
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: generuja xml oddziału kontrahenta. KH ustawione na rekord do wysłania
::   WY: xml <division>
::----------------------------------------------------------------------------------------------------------------------
_activity:=
{? KH_ODB.ABSTORE='T'
|| 'true'
|| 'false'
?};

_xml:='<division eid="div-%1" company-eid="%1" address-eid="%1" main="%2">
    <email>%3</email>
    <name>%4</name>
</division>
<division-activity division-eid="div-%1" activity="%5" />
'[$KH.ref, 'true', xml_valu(KH.EM), xml_valu(KH.SKR), _activity];
_xml


\divisionMSCXml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: generuja xml oddziału kontrahenta
::   WY: xml <address>
::----------------------------------------------------------------------------------------------------------------------
KH_MSC.index('KH_NAZ');
KH_MSC.prefix(KH.ref);
_xml:='';
{? KH_MSC.first()
||
   {! |?
   _xml1:='<address eid="%1">
       <phone>%2</phone>
       <street>%3</street>
       <zip-code>%4</zip-code>
       <city>%5</city>
       <iso2-country-code>%6</iso2-country-code>
   </address>'[$KH_MSC.ref, KH_MSC.TEL, exec('address','abstore',KH_MSC.UL,KH_MSC.DOM,KH_MSC.LOKAL), KH_MSC.KPOCZ, KH_MSC.MIASTO, 'pl'];
   _xml2:='<division eid="%1" company-eid="%5" address-eid="%1" main="%2">
       <email>%3</email>
       <name>%4</name>
   </division>
   <division-activity division-eid="%1" activity="true" />
   '[$KH_MSC.ref, 'false', KH_MSC.EMAIL, KH_MSC.NAZ, $KH.ref];
   _xml:=_xml + %13+%10 + _xml1 + %13+%10 + _xml2;
   KH_MSC.next()
   !};
   _xml3:='';
   _grp:='division';
   {? KH.GRKH<>null
   ||
      _xml3:='<contractor-group-%3-%3
               contractor-group-eid="%1" contractor-eid="%2" />'[$KH.GRKH().ref, $KH_MSC.ref, _grp]
   ?};
   _xml:=_xml + _xml3
?};
_xml


\xml_divisionaddr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: adres oddzialu kontrahenta. KH_ODB na rekordzie do wysłania
::   WY: xml <address>
::----------------------------------------------------------------------------------------------------------------------
_xml:='<address eid="%1">
    <phone>%2</phone>
    <street>%3</street>
    <zip-code>%4</zip-code>
    <city>%5</city>
    <iso2-country-code>%6</iso2-country-code>
    </address>'[$KH_ODB.ref(), '',exec('address','abstore',KH_ODB.UL,KH_ODB.DOM,KH_ODB.LOKAL), xml_valu(KH_ODB.KPOCZ), xml_valu(KH_ODB.MIASTO), 'pl'];
_xml


\xml_division
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: generuja xml oddziału kontrahenta (address, division, division-activity,  contractor-group -> przypisanie oddzialu
::             do grupy kontrahenta głównego. KH_ODB ustawione na rekord do wysłania
::   WY: xml <division>
::----------------------------------------------------------------------------------------------------------------------
_xml:='';
_naz:=exec('konwersja_xml','xml',KH_ODB.NAZ);
_adrXml:=exec('xml_divisionaddr','abstore');
_activity:=
{? KH_ODB.ABSTORE='T'
|| 'true'
|| 'false'
?};
_xml2:='<division eid="%1" company-eid="%5" address-eid="%1" main="%2">
   <email>%3</email>
   <name>%4</name>
   </division>
  <division-activity division-eid="%1" activity="%6" />'
  [$KH_ODB.ref, {? KH_ODB.MAIN='T' || 'true' || 'false' ?}, xml_valu(KH_ODB.EM), _naz, $KH_ODB.KH,_activity];
_xml:=_xml + %13+%10 + _adrXml + %13+%10 + _xml2;
::_xml3:='';
::   _grp:='division';
::   {? KH.GRKH<>null ||
::      _xml3:='<contractor-group-%3-%3
::               contractor-group-eid="%1" contractor-eid="%2" />'[$KH.GRKH().ref, $KH_ODB.ref, _grp]
::   ?};
::_xml:=_xml + _xml3;
_xml


\xml_divisionstore
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: przypisanie oddzialu kontrahenta (KH_ODBMG) do magazynu
::   WE: _a - KH_ODBMG
::   WY: xml <division-store-synchronize>
::----------------------------------------------------------------------------------------------------------------------
_xml:='<division-store-synchronize division-eid="%1">
            <sync-element store-eid="%2" main="false"/>
       </division-store-synchronize>'[exec('tostring','abstore',_a.ODB), _a.MG];
_xml


\xml_contractorgroup
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: xml grupa kontrahentów. GRKH Jeśli włączona obsługa oddziałów to tworzy oddział i przypisuje go do grupy
::          GRKH ustawione na rekord do wysłania
::   WY: xml <contractor-group-division>
::----------------------------------------------------------------------------------------------------------------------
{? __AbStore.useDivision || _group:='division' || _group:='company' ?};
_group:='company';
_xml:='<contractor-group-%3 eid="%1" />
<contractor-group-%3-i18n contractor-group-eid="%1" lang="pl">
    <name>%2</name>
</contractor-group-%3-i18n>'[$GRKH.ref, xml_valu(GRKH.NAZ), _group];
_xml


\send_company
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS:  rejestracja firm w abstore oznaczonych ABSTORE<>''.
::       Kontrahent do ABSTORA musi mieć wypełnione pola: nip, regon, email
::   WY: kod błędu (200= ok)
::----------------------------------------------------------------------------------------------------------------------
_cnt:=0;
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_tabname:='KH';
_il_rec:=100;
_firma:='';
_repl:=0;
_cnt:=0;
_kon:=obj_new('REF','NAZ','SKR','ABSTORE');
KH.cntx_psh();
KH.prefix();
{? _useSynchro
||
    exec('clear_tabref','abstore');
    _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
    _rodz:='';
   {? _tab.first()
   ||
     {! |?
         {? _cnt=0 || _file:=exec('create_msgfile','abstore','company') ?};
         _cnt:=_cnt + 1;
         _rodz:=_tab.RODZ;
         _tr:={? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?};
         exec('extract_tr','abstore',_tr,_kon);
         {? _rodz = 'del'
         ||
            _ref:=_tab.REF;

            _cnt:=_cnt + 1;
            _mpart:=exec('xml_companydel', 'abstore', _ref);
            fwrite(_file, maz_utf8(_mpart))
         ||
            _ref:=_tab.REF;
            _kon.REF:=_ref;
            {? KH.seek(_ref)
            ||
               {? KH.ABSTORE<>''
               ||
                  exec('add_tabref','abstore',_ref);
                  _cnt:=_cnt + 1;
                  _mpart:=exec('xml_company', 'abstore', _kon);
                  fwrite(_file, maz_utf8(_mpart))
               |? KH.ABSTOREC<>''
               ||
                  exec('add_tabref','abstore',_ref);
                  _cnt:=_cnt + 1;
                  _mpart:=exec('xml_companylimit','abstore');
                  fwrite(_file, maz_utf8(_mpart))
               ?}
            ||
               exec('log_write','abstore','','brak kontrahenta: ' +_ref,-1)
            ?}
         ?};
         _tab.next()
     !};
     exec('clear_sync','abstore', _tab.ID, _tabname)
   ?}
||
::bez synchro pełny eksport
   KH.prefix();
   {? KH.first()
   ||
      {! |?
         {? KH.ABSTORE<>''
         ||
            {? _cnt=0 || _file:=exec('create_msgfile','abstore','company') ?};
            _cnt:=_cnt + 1;
            _xmlpart:=exec('xml_company','abstore');
            fwrite(_file, maz_utf8(_xmlpart))
         |? KH.ABSTOREC<>''
         ||
            {? _cnt=0 || _file:=exec('create_msgfile','abstore','company') ?};
            _cnt:=_cnt + 1;
            _xmlpart:=exec('xml_companylimit','abstore');
            fwrite(_file, maz_utf8(_xmlpart))
         ?};
         KH.next()
      !}
   ?}
?};
KH.cntx_pop();
_result:=200;
{? _cnt >0
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'company')
?};
::wyslanie wszystkich osob kontaktowych kontrahenta
{? _result=200 & __AbStore.tabRef.size()>0
||
   {? __AbStore.tabRef.first()
   ||
      {! |?
         _result:=exec('send_client','abstore',0,__AbStore.tabRef.REF);
         __AbStore.tabRef.next()
      !}
   ?}
?};
_result


\add_tabref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
__AbStore.tabRef.REF:=_a;
{? var_press('_b')>0 || __AbStore.tabRef.IDADD:=_b ?};
__AbStore.tabRef.add


\send_companygroup
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wysyła grupy kontrahentów z oznaczeniem ABSTORE<>''
::   WY: kod błędu (200 = ok)
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
GRKH.cntx_psh();
GRKH.prefix();
_tabname:='GRKH';
_il_rec:=100;
_firma:='';
_repl:=0;
_file:=exec('create_msgfile','abstore','companyGroup');
_cnt:=0;
_gr:=obj_new('REF','NAZ','KOD','ABSTORE');
{? _useSynchro
||
    _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
    _rodz:='';
   {? _tab.first()
   ||
     {! |?
         _cnt:=_cnt + 1;
         _rodz:=_tab.RODZ;
         _tr:={? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?};
         exec('extract_tr','abstore',_tr,_gr);
         {? _rodz = 'del'
            ||
               _cnt:=_cnt + 1
            ||
               _ref:=_tab.REF;
               {?  GRKH.seek(_ref)
               ||
                  _gr.REF:=_ref;
                  _cnt:=_cnt + 1;
                  _mpart:=exec('xml_contractorgroup', 'abstore', _gr);
                  fwrite(_file, maz_utf8(_mpart))
               ?}
         ?};
         _tab.next()
     !};
     exec('clear_sync','abstore', _tab.ID, _tabname)
   ?}
||
   {? GRKH.first()
   ||
      {! |?
         {? GRKH.ABSTORE<>''
         ||
            _cnt:=_cnt + 1;
            _xmlpart:=exec('xml_contractorgroup','abstore');
            fwrite(_file, maz_utf8(_xmlpart))
         ?};
         GRKH.next
      !}
   ?}
?};
{? _cnt>0
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'pricelist');
   {? _result=200 & _useSynchro || exec('clear_sync','abstore',_tab.ID, _tabname) ?};
   fclose(_file);
   &_file
||
    _result:=200
?};
GRKH.cntx_pop();
_result


\add_charl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS:  uzupełnia stringa określonym znakiem od lewej
::   WE: _a - string do uzupełnienia
::       _b - znak uzupełnienia
::       _c - długość docelowa
::   WY: string uzupełniony znakiem _b od lewej strony
::----------------------------------------------------------------------------------------------------------------------
_len:=+_a;
_res:='';
{? _len >= _c || return(_a) ?};
_res:=(_c - _len) * _b + _a;
_res


\xml_productattributesall
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: zwraca xmla ze wszystkimi atrybutami aktualnego produktu. M - ustawione na rekord do wysłania
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_result:='';
SLO.cntx_psh();
SLO.index('SL');
{! _xx:=1..10
|!
   _nr:=exec('add_charl','abstore',$_xx,'0',2);
   _attrname:=($('M.M_ATR_B().SL_%1().NA'[_nr]))();
   {? _attrname<>''
   ||
      _attrval:=($('M.WAR%1'[_nr]))();
      _attrdesc:=_attrval;
      _attrid:=($('$M.M_ATR_B().SL_%1().ref()'[_nr]))();
      {? _attrval<>''
      ||
         _sl:=($('M.M_ATR_B().SL_%1().TYP'[_nr]))();
         {? _sl='S'
         ||
           _slu:=($('M.M_ATR_B().SL_%1().SLU'[_nr]))();
           SLO.prefix(_slu,_attrval);
           {? SLO.first() || _attrdesc:=SLO.TR ?}
         ?};
         _attrval+=_attrid;
         _result:=_result + exec('xml_productattribute','abstore', _attrid, _attrname, _attrval, _attrdesc, $M.ref())
      ||
         _result:=_result + exec('xml_attributeprodattrdel','abstore',_attrid, $M.ref())
      ?}
   ?}
!};
SLO.cntx_pop();
::atrybuty systemowe EAN_CODE, ...
::UWAGA - sprawdzic czy dla atrybutow jest powlaczana integracja bo inaczej komunikaty nie trafią nawet do bufora
{? M.KODK<>''
||
   _result:=_result + exec('xml_attributeval','abstore','EAN_CODE'+M.KODK,'EAN_CODE',M.KODK,$M.ref())
?};
{? M.WB<>0
||
   _val:=gsub($M.WB,',','.');
   _result:=_result+exec('xml_sysattributeval','abstore','WEIGHT_PACKAGE'+_val,'WEIGHT_PACKAGE',_val,$M.ref())
?};
exec('ustawJMwym','jm');
{? M.SZER<>0
||
   _val:=gsub($(M.SZER*VAR.JMPRZ*100$3),',','.');
   _result:=_result+exec('xml_sysattributeval','abstore','WIDTH_PACKAGE'+_val,'WIDTH_PACKAGE',_val,$M.ref())
?};
{? M.DLUG<>0
||
   _val:=gsub($(M.DLUG*VAR.JMPRZ*100$3),',','.');
   _result:=_result+exec('xml_sysattributeval','abstore','DEPTH_PACKAGE'+_val,'DEPTH_PACKAGE',_val,$M.ref())
?};
{? M.WYS<>0
||
   _val:=gsub($(M.WYS*VAR.JMPRZ*100$3),',','.');
   _result:=_result+exec('xml_sysattributeval','abstore','HEIGHT_PACKAGE'+_val,'HEIGHT_PACKAGE',_val,$M.ref())
?};
_result


\xml_productprice0
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wysyła cenę maksymalną towaru, który nie występuje w wysyłanych cennikach. M ustawione na rekord do wysłania
::   WY: xml <product-price>
::----------------------------------------------------------------------------------------------------------------------
SLO.cntx_psh();
SLO.prefix();
_wal:='PLN';
_sql:='select max(TAP.CEN) as CEN, max(TAP.CENB) as CENB from TAP
   join SLO using(TAP.WAL,SLO.REFERENCE)
   join TAR using(TAR.REFERENCE,TAP.TAR)
   where TAP.CENB<>0
   and TAP.M=''%1''
   and TAR.SD=''S''
   and SLO.KOD=\'PLN\''[$M.ref()];
_tbCena:=sql(_sql);
_cena:='999999'; _cenab:='999999';
{? _tbCena.first() & _tbCena.CEN>0
|| _cena:=gsub(form(_tbCena.CEN,,2,'9.'),',','.'); _cenab:=gsub(form(_tbCena.CENB,,2,'9.'),',','.')
?};
_xml:='<product-price eid="%1"  product-eid="%2" base-net="%3" base-gross="%4"
         final-net="%3" final-gross="%4" currency="%5" />'[$M.ref(), $M.ref(), _cena, _cenab, _wal];
SLO.cntx_pop();
_xml


\xml_productavailability
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: informacja o stanie magazynowym produktu
::   WE: _a - tablica ['REF','M','SD','MAG']
::       _b - zerowy stan magazynowy
::   WY: xml <product-availability>
::----------------------------------------------------------------------------------------------------------------------
_zero:={? var_press('_b')=1 || _b || 0 ?};
_store:='';
{? __AbStore.useStore || _store:='store-eid="%1"'[_a.MAG] || _store:='' ?};
_xml:='<product-availability product-eid="%1" availability="%2" %3/>'[_a.M, gsub(
{? _zero
|| '0'
|? type_of(_a.SD)=2
||
   _wyn:='0';
   MG.cntx_psh();
   MG.index('MAG');
   MG.prefix(__AbStore.oddz,_a.MAG,);
   {? MG.first()
   ||
      M.cntx_psh();
      M.prefix();
      {? M.seek(_a.M)
      ||
         SM.cntx_psh();
         SM.use('stm__'+__AbStore.oddz+'zb');
         SM.index('SM');
         SM.prefix(MG.ref(), M.ref());
         {? SM.first() || _wyn:={? SM.SD<0 || '0' || form(SM.SD,,4,'9.') ?} ?};
         SM.cntx_pop()
      ?};
      M.cntx_pop()
   ?};
   MG.cntx_pop();
   _wyn
||
   {? _a.SD<0
   || '0'
   || form(_a.SD,,4,'9.')
   ?}
?},',','.'), _store];
_xml


\xml_productimg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: obrazek produktu (podłączenie pliku) jpg
::   WE:  _a - id obrazka
::        _b - id produktu
::        _c - id pliku
::        _d - [true]  czy główny obrazek ( true / false )
::   WY: xml <product-img...
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_d')<0 || _d:='true' ?};
_xml:='<product-img eid="pimg-%1" product-eid="%2" file-img-eid="px-%3" main="%4" />'[_a, _b, _c, _d];
_xml


\xml_productresource
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: załącznik dokument (pdf) do towaru
::   WE: _a - id załącznika ($DOKUM.ref)
::       _b - id produktu
::       _c - nazwa pliku
::       _d - id wysłanego pliku
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<product-resource eid="%1" product-eid="%2" file-name="%3" file-eid="%4" />'[_a,_b,xml_valu(_c),_d];
_xml


\xml_productresourcedel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: usunięcie załącznika
::   WE: _a - id załącznika (DOKUM.REF)
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<product-resource-del eid="%1" />'[_a];
_xml


\xml_productimgdel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: usunięcie obrazka
::   WE: _a - ref produktu do usunięcia obrazków
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<product-img-del eid="pimg-%1" />'[_a];
_xml


\xml_productdel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: usunięcie towaru
::   WE: _a - id produktu do usunięcia
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<product-del product-eid="%1"/>'[_a];
_xml


\xml_file
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: zapisuje do pliku xml BLOBA
::   WE:  _a - uchwyt do pliku
::        _b - BLOB
::        _c - id pliku
::        _d - rozszerzenie pliku (jedno z obsługiwanych: JPG, PNG, PDF, MP3, MP4, DOC, TXT)
::   WY: xml <file>
::----------------------------------------------------------------------------------------------------------------------
fwrite(_a,'<file eid="%1" file-extension="%2"><data>'[_c,_d]);
base64('encode',fopen(_b,'br',,,1),_a);
fwrite(_a,'</data></file>');
''


\xml_fileimg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: zapisuje do pliku xml BLOBA z obrazkiem
::   WE:  _a - uchwyt do pliku
::        _b - BLOB (M.RYS, MG_IMG.IMG)
::        _c - id obrazka ($M.ref $M_IMG.ref)
::   WY:  xml <file-img...
::----------------------------------------------------------------------------------------------------------------------
_fh:=fopen(_b,'br',,,1);
{? fread(_fh,1)=137 & fread(_fh,1)=80 & fread(_fh,1)=78 & fread(_fh,1)=71
|| _ext:='PNG'
|| _ext:='JPG'
?};
fclose(_fh);
fwrite(_a,'<file-img eid="px-%1" file-img-extension="%2"><data>'[_c,_ext]);
base64('encode',fopen(_b,'br',,,1),_a);
fwrite(_a,'</data></file-img>');
''


\xml_filepdf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: zapisuje do pliku xml BLOBA z plikiem PDF
::   WE:  _a - uchwyt do pliku
::        _b - BLOB z PDF-em
::        _c - id pliku ($M.ref $M_IMG.ref)
::----------------------------------------------------------------------------------------------------------------------
fwrite(_a,'<file-pdf eid="pdf-%1"><data>'[_c]);
base64('encode',fopen(_b,'br',,,1),_a);
fwrite(_a,'</data></file-pdf>');
''


\xml_categorydel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: usuwanie kategorii
::   WE: _a - id kategorii do usunięcia
::   WY: xml <category-del...
::----------------------------------------------------------------------------------------------------------------------
_xml:='<category-del category-eid="%1" />'[_a];
_xml


\clear_sync
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: czysci wpisy w synchro
::   WE: _a - id do usunięcia i wszystkie poprzednie
::       _b - akronim tabeli
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_repl:='1';
_id:={? var_press('_a')>=0 || _a || '0' ?};
_tab:={? var_press('_b')=2 || _b || '' ?};
{? _id='0' ||
   _sql:='select max(ID) as MAXID from @SYNC join SYNC_PD where SYNC_PD.SYM=''%1'''[__AbStore.synchro];
   _tb:=sql(_sql);
   _tb.first();
   {? _tb.MAXID<>'' ||  _id:=_tb.MAXID ?}
?};
_res:=proc_exe('sync_id_del@synchro', _id, __AbStore.synchro, 0, 0, _tab);
_res


\send_startconv
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: Wysyła start-conversation i zapisuje w parametr 800102 wygenerowaną wartość, należy wysyłać wyłącznie po resecie sklepu.
::   WE: _a - numer parametru do zapisania conversation-id
::       _b - numer parametru z wersją webserwisów
::   WY: ConversationId - do kolejnych komunikatów
::----------------------------------------------------------------------------------------------------------------------
_convId:=exec('gen_guid','abstore_fun');
exec('param_set','abs_conf', _a, _convId);
_version_id:=exec('param_get','abs_conf', _b);
_xml:='<?xml version="1.0" encoding="UTF-8"?>
<start-conversation xmlns="http://assecobs.com/ns/a4b" account-id="%1"
conversation-id="%2"
version-id="%3"/>'[__AbStore.accId,_convId,_version_id];
_result:=exec('http_send','abstore', _xml,'start-conversation');
__AbStore.convId:=_convId;
_convId


\send_store
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: Wysyła informacje o magazynach
::   WY: kod błędu (200 = ok)
::----------------------------------------------------------------------------------------------------------------------
{? __AbStore.useStore=0 || return('111') ?};
MG.cntx_psh();
MG.index('MAGAZYNY');
_idx:=1;
_message:=exec('xml_messageheader','abstore');
{? __AbStore.tabMG.first()
||
   {! |?
      _mag:=__AbStore.tabMG.SYM;
      MG.prefix(_mag);
      {? MG.first()
      ||
         __AbStore.storeId:=$MG.SYM;
         _message:=_message + exec('xml_store','abstore')
      ||
         exec('log_write','abstore','','brak magazynu o podanym kodzie: %1'[_mag],0);
         MG.cntx_pop();
         return(-1)
      ?};
      __AbStore.tabMG.next()
   !}
?};
_message:=_message + exec('xml_messagefooter','abstore');
_result:=exec('http_send','abstore',_message,'store');
MG.cntx_pop();
_result


\send_categories
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wysyła grupy towarowe do AbStore z ustawionym znacznikiem ABSTORE<>''
::   WE: _a (opcjonalny) = 0  -> wszystkie kategorie bez używania synchro
::   WY: 0 albo numer błędu
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_tabname:='MGR';
_il_rec:=100;
_firma:='';
_repl:=0;
_message:=exec('xml_messageheader','abstore');
_kat:=obj_new('REF','NAZ','KOD','ABSTORE','ABSTOREC');
_cnt:=0;
_file:=exec('create_msgfile','abstore','category');
MGR.cntx_psh();
MGR.prefix;
{? _useSynchro
||
   _tab:=exec('synchro_get','abs_conf',__AbStore.synchro, _tabname, _il_rec,_firma,_repl);
::   exec('select','#table',_tab);
   {? _tab.first()
   ||
      {! |?
         _rodz:=_tab.RODZ;
         _ref:=_tab.REF;
         _tr1:={? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?};
         {? _rodz ='del'
            ||
               _mpart:=exec('xml_categorydel', 'abstore', _ref);
               fwrite(_file, maz_utf8(_mpart));
               _message:=_message +  %13 + %10 + _mpart
            ||
::               ABSTOREB2C      put   admin   2019-11-04   14:03:43   SKOD:CZEK;SABSTOREC:T;SNAZ:Czekolady;
                exec('extract_tr','abstore', _tr1, _kat);
               _kat.REF:=_ref;
               {? ( __AbStore.useStore=1 & _kat.ABSTORE<>'' ) | ( __AbStore.useStore=0 & _kat.ABSTOREC<>'' )
               ||
                  {? MGR.seek(_kat.REF)
                  ||
                     _mpart:=exec('xml_category', 'abstore', _kat);
                     {? (__AbStore.useStore=1 & exec('param_get','abs_conf', 800124, 2)='T')
                     | (__AbStore.useStore=0 & exec('param_get','abs_conf', 800224, 2)='T')
                     ||
                        _mpart+=exec('create_subcategoriesall','abstore')
                     ?};
                     fwrite(_file, maz_utf8(_mpart));
                     _cnt+=1;
                     _message:=_message +  %13 + %10 + _mpart
                  ?}
               ?}
         ?};
        _tab.next()
      !};
      exec('write_filefooter','abstore',_file);
      _message:=_message + exec('xml_messagefooter','abstore')
   ?}
||
   MGR.first;
   {! |?
      {? MGR.RODZ='T' & exec('mgr_abstore','abstore')
      ||
          _cnt:=_cnt + 1;
          _kat.NAZ:=MGR.NAZ;
          _kat.REF:=$MGR.ref;
          _kat.KOD:=MGR.KOD;
          _mpart:=exec('xml_category','abstore',_kat);
          {? (__AbStore.useStore=1 & exec('param_get','abs_conf', 800124, 2)='T')
          | (__AbStore.useStore=0 & exec('param_get','abs_conf', 800224, 2)='T')
          ||
          _mpart+=exec('create_subcategoriesall','abstore')
          ?};
          fwrite(_file, maz_utf8(_mpart));
          _message:=_message + _mpart + %13 + %10
      ?};
      MGR.next
   !};
   exec('write_filefooter','abstore',_file);
   _message:=_message + exec('xml_messagefooter','abstore')
?};
{? _cnt>0 ||
   _result:=exec('http_send','abstore',_file,'category');
   {? _result=200 & _useSynchro || exec('clear_sync','abstore',_tab.ID, _tabname) ?};
   &_file
||
   _result:=201
?};
MGR.cntx_pop();
_result


\send_subcategories
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: wysyla podkategorie przez synchro, bez synchro wysylane sa razem z kategoriami przez send_categories
::----------------------------------------------------------------------------------------------------------------------
exec('send_unisync','abstore','MGRP',_obj,'subxml_category','',1,,,,'
MGR.cntx_psh();
_wyn:=MGRP.MGR().ABSTORE<>'''';
MGR.cntx_pop();
_wyn
')


\create_subcategoriesall
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:  tworzy xmla ze wszystkimi podgrupami dla wybranej grupy
::----------------------------------------------------------------------------------------------------------------------
MGRP.cntx_psh();
MGRP.index('MGR');
MGRP.prefix(MGR.ref());
_xml:='';
{? MGRP.first() ||
   {! |?
      _obj:=exec('rec2obj','abstore',MGRP);
      _xml+=exec('subxml_category','abstore',_obj);
      &_obj;
      MGRP.next()
   !}
?};
MGRP.cntx_pop();
_xml


\create_msgfile
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: tworzy nagłówek pliku z message'm
::   WE: _a - nazwa pliku
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_file:=fopen(null,'bw',,,1);
_message:=exec('xml_messageheader','abstore');
fwrite(_file,_message);
_file


\write_filefooter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: zapis zakończenia pliku
::   WE: _a  - obiekt FILE
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_message:=exec('xml_messagefooter','abstore');
fwrite(_a,_message);
_a


\xml_personaloffer2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS:
::   WE: _a - naglowek cennika
::       _b - symbol magazynu
::       _c - tabela oddzialow kontrahenta uzywana gdy _a.KH_ODB=''
::   WY:
::----------------------------------------------------------------------------------------------------------------------
::jesli oferta nie ma przypisanego odbiorcy to dotyczy wszystkich odbiorcow kontrahenta
::_od:=exec('tostring','abstore',_a.OD);
::_do:=exec('tostring','abstore',_a.DO);
_from:='';
_to:='';
::{? _od<>'0000/00/00' || _from:='date-from="%1T00:00:01"'[ gsub(_od,'/','-')] || _from:='' ?};
::{? _do<>'0000/00/00' || _to:='date-to="%1T23:59:59"'[gsub(_do,'/','-')] || _to:='' ?};
_allDiv:='';
_con:='';
{? $_a.KH_ODB='' ||
::   _con:=_a.KH_REF;
   {? var_press('_c')>0 ||
      {? _c.first ||
         {! |?
            _con+='<offer-contractor contractor-eid="%1"/>'[_c.KH_ODB] + %13 + %10;
::            _c.next
0
         !}
      ?}
   ?}
||
   _con:='<offer-contractor contractor-eid="%1"/>'[_a.KH_ODB]
?};
_xml:='<personal-offer eid="D-%1" divisible="true" %3 store-eid="%5" tag="D-%1">
%4
</personal-offer>
   <personal-offer-i18n offer-eid="D-%1" lang="pl">
       <name>%2</name>
   </personal-offer-i18n>'[_a.TAR_KOD, _a.NAZ, _allDiv,  _con, _b];
_xml


\xml_personaloffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: naglowek oferty dedykowanej dla konkretnego oddziału
::   WE: _a - id oferty
::       _b - nazwa
::       _c - magazyn
::       _d - kontrahent/oddzial
::       _e - tag
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<personal-offer eid="%1" divisible="true" store-eid="%3" tag="%5">
<offer-contractor contractor-eid="%4"/>
</personal-offer>
   <personal-offer-i18n offer-eid="%1" lang="pl">
       <name>%2</name>
   </personal-offer-i18n>'[_a,_b,_c,_d,_e];
_xml


\xml_contractorsetdoffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: przypisuje oferte do ODB
::   WE: _a - id oferty
::       _b - id KH_ODB
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<contractor-set-default-offer offer-eid="%1" contractor-eid="%2"/>'[_a,_b];
_xml


\xml_defaultofferex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS:  nagłówek oferty domyślnej
::   WE: _a - tabela z naglowkiem cennika
::       _b - magazyn (jesli pusta wartosc to nie jest wysylany)
::       _c - oferta dla wszystkich kontrahentow (domyslnie 0)
::       _d - [0] - cała oferta, 1 - aktualizacja/dodawanie pozycji
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_d')<0 || _d:=0 ?};
_syncStrategy:='';
{? _d=1 || _syncStrategy:='sync-strategy="SKIP_ABSENT"' ?};
{? var_press('_c')<0 || _c:=0 ?};
{? _b<>'' || _store:='store-eid="%1"'[_b] || _store:='' ?};
_from:='';
_to:='';
::_od:=exec('tostring','abstore',_a.OD);
::_do:=exec('tostring','abstore',_a.DO);
::{? _od<>'0000/00/00' || _from:='date-from="%1T00:00:01"'[ gsub(_od,'/','-')] || _from:='' ?};
::{? _do<>'0000/00/00' || _to:='date-to="%1T23:59:59"'[gsub(_do,'/','-')] || _to:='' ?};
_allDiv:='default-for-new-contractor="false"';
{? _c=1 ||
   _allDiv:='default-for-new-contractor="true"'
?};
{? _b<>'' || _b:='-'+_b ?};
_xml:='<default-offer eid="%1" %3 %4 %5 %6 default-for-new-product="false" tag="%1" %7/>
   <default-offer-i18n offer-eid="%1" lang="pl">
       <name>%2</name>
   </default-offer-i18n>'[_a.TAR_KOD + _b, _a.TAR_KOD + _b, _from, _to, _store, _allDiv, _syncStrategy];
_xml


\xml_defaultoffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:
::   WE: _a - id oferty
::       _b - nazwa
::       _c - magazyn
::       _d - domyslna dla nowych kontrahentow (0/1)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_allDiv:='default-for-new-contractor="false"';
{? _c<>'' || _store:='store-eid="%1"'[_c] || _store:='' ?};
{? _d=1 ||
   _allDiv:='default-for-new-contractor="true"'
?};
::{? _b<>'' || _b:='-'+_b ?};
_xml:='<default-offer eid="%1" %3 %4 default-for-new-product="false" tag="%1"/>
   <default-offer-i18n offer-eid="%1" lang="pl">
       <name>%2</name>
   </default-offer-i18n>'[_a, xml_valu(_b), _store, _allDiv];
_xml


\xml_personalofferall
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: naglowek oferty dedykowanej (dostępnej dla wszystkich oddziałów obsługiwanych przez magazyn)
::   WE: _a - id oferty
::       _b - nazwa
::       _c - magazyn
::       _d - tag
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<personal-offer eid="%1" divisible="true" store-eid="%3" tag="%4"
   available-for-all-contractors-divisions="true"/>
   <personal-offer-i18n offer-eid="%1" lang="pl">
       <name>%2</name>
   </personal-offer-i18n>'[_a,xml_valu(_b),_c,_d];
_xml


\xml_pofferproduct
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: pozycja oferty dedykowanej - jesli wyslana bez cen to ceny pochodza z cennika, a oferta tylko ogranicza asortyment
::   WE: _a - id oddziału (nieuzywane)
::       _b - id produktu
::       _c - id oferty
::       _d - cena netto (jesli 0 to nie jest wysylana)
::       _e - cena brutto
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<offer-contractor-synchronize-position-visible product-eid="%1" offer-eid="%2" available="true">'[exec('tostring','abstore',_b),exec('tostring','abstore',_c)];
{? _d>0 ||
    _xml+='<price base-net="%1" base-gross="%2" final-net="%1" final-gross="%2" currency="PLN" />'[ gsub($_d,',','.'), gsub($_e,',','.')]
?};
_xml+='</offer-contractor-synchronize-position-visible>';
_xml


\xml_dofferproduct
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS:
::   WE: _a - id produktu
::       _b - id oferty
::       _c - cena netto  - opcjonalny (cena 0 nie jest wysylana)
::       _d - cena brutto - opcjonalny razem z _c
::   WY: string xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<offer-synchronize-position-visible product-eid="%1" offer-eid="%2" available="true">'[_a,_b];
::{? var_press('_c')=1 & _c>0 ||
::    _xml+='<price base-net="%1" base-gross="%2" final-net="%1" final-gross="%2" currency="PLN" />'[gsub($_c,',','.'), gsub($_d,',','.')]
::?};
_xml+='</offer-synchronize-position-visible>';
_xml


\xml_pofferproductlimited
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:
::   WE: _a - id oddziału
::       _b - id produktu
::       _c - id oferty
::       _d - cena netto
::       _e - cena brutto
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<offer-contractor-synchronize-position-limited product-eid="%1" offer-eid="D-%2" availability="100">
    <price base-net="%3" base-gross="%4" final-net="%3" final-gross="%4" currency="PLN" />
  </offer-contractor-synchronize-position-limited>'[$_b, _c, _d, _e];
_xml


\xml_contractorcleardoffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: Odłączenie kontrahentowi domyślnej oferty
::   WE: _a - $KH.REF
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<contractor-clear-default-offer contractor-eid="%1" />'[_a];
_xml


\send_labels
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: Wysyła utworzone etykiety
::   WE: _a - czy uzywac synchro (1)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_fields:=obj_new('ref','N');
{? _useSynchro ||
   _result:=exec('send_unisync','abstore','LABEL',_fields,'xml_label','xml_labeldel',1,1,0,1,'_a.N<>''''')
||
::wszystkie labele bez synchro
  LABEL.cntx_psh();
  _result:=exec('send_uni','abstore',LABEL,'xml_label',0,'_a.N<>''''');
  LABEL.cntx_pop()
?};
_result


\send_khdod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [20.14]
:: OPIS: Wysyła zmiany z KH_DOD - tylko przez synchro
::       - generuje zapis w KH i zmiany poleca  podczas wysylania KH
::   WE: _a - czy uzywac synchro (1)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
SYNC_PD.cntx_psh();
SYNC_PD.index('SYM');
SYNC_PD.prefix(__AbStore.synchro);
SYNC_PD.first();
_syncpd:=SYNC_PD.ref;
SYNC_PD.cntx_pop();
_tbTemp:=tab_tmp(1,'REF','STRING[16]','REF');
_tabname:='KH_DOD';
_il_rec:=100;
_repl:=0;
_firma:='';
_obj:=obj_new('ref','KH');
_tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
_rodz:='';
{? _tab.first()
||
  {! |?
      {? _tab.RODZ='put'
      ||
         _tr:={? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?};
         exec('extract_tr','abstore',_tr,_obj);
         _tbTemp.REF:=_obj.KH;
         _tbTemp.add();
         exec('clear_sync','abstore', _tab.ID, _tabname)
      ?};
      _tab.next()
  !}
?};
:generowanie zapisow w synchro dla tabeli KH
exec('wysl_tab_ref','synchro','KH',_tbTemp,_syncpd);
1


\send_productlabels
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: Wysyła powiązania materiał-etykieta
::   WE: _a - czy uzywac synchro (1)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_fields:=obj_new('ref','M','L');
{? _useSynchro ||
   _result:=exec('send_unisync','abstore','M_LABEL',_fields,'xml_labelprod','xml_labelprodlabdel',1,1,0,1,'_a.L<>''''')
||
::wszystkie labele bez synchro
  M_LABEL.cntx_psh();
  _result:=exec('send_uni','abstore',M_LABEL,'xml_labelprod',0,'_a.L<>null');
  M_LABEL.cntx_pop()
?};
_result


\clear_tabref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: czyszczenie tabeli ze zmianami
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
__AbStore.tabRef.erase()
::{? __AbStore.tabRef.first()
::||
::   {! |? __AbStore.tabRef.del() !}
::?}


\send_products
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wysyła towary do ABStore
::   WE: _a (opcjonalny) = 0  -> wszystkie produkty bez używania synchro
::   WY: status requesta (200 = OK)
::----------------------------------------------------------------------------------------------------------------------
::exec('setupAbstoreb2b','abstore');
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_tabname:='M';
_il_rec:=100;
_firma:='';
_repl:=0;
_result:=200;
_cnt:=0;
_product:=obj_new('REF','N','KTM','RYS','OPIST','J','MGR','VAT','RODZ','A');
M.cntx_psh();
M.prefix();

exec('clear_tabref','abstore');

{? _useSynchro ||
   _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
    _rodz:='';
   {? _tab.first() ||
     {! |?
         {? _cnt=0 || {? var_press('_file')>0 || &_file ?}; _file:=exec('create_msgfile','abstore','products') ?};
         _rodz:=_tab.RODZ;
         {? _rodz = 'del'
            ||
               _cnt:=_cnt + 1;
               _mpart:=exec('xml_productdel','abstore',_tab.REF);
               fwrite(_file, maz_utf8(_mpart))
            ||
               _ref:=_tab.REF;
               _tr:={? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?};
               exec('extract_tr','abstore',_tr,_product);
               _product.REF:=_ref;
               {?  M.seek(_ref)
               ||
::zapamietanie zmienionych produktow (ref)
                  {? exec('m_abstore','abstore') & M.A='T'
                  ||  exec('add_tabref','abstore',_ref);
                     _mpart:=exec('xml_product','abstore');
                     {? _mpart<>''
                     || _mpart:=_mpart + exec('xml_productattributesall','abstore');
                        fwrite(_file, maz_utf8(_mpart));
                        _cnt:=_cnt + 1;
::wysyłanie cenników indywidulanych i grupowych dla których zmodyfikowano wartości
                        {? __AbStore.useStore & __AbStore.mCen
                        ||
::sprawdzenie dla metriałow dla kontrahentów
                           _result:=exec('s_product_pl','abstore','M','KH',M.ref());
                           {? _result<>200 & _result<>201 || M.cntx_pop();return(_result) ?};
::sprawdzenie dla grup materiałowych dla kontrahentów
                           _result:=exec('s_product_pl','abstore','MGR','KH',M.MGR);
                           {? _result<>200 & _result<>201 || M.cntx_pop();return(_result) ?};
::sprawdzenie dla metriałow dla grup kontrahentów
                           _result:=exec('s_product_pl','abstore','M','GRKH',M.ref());
                           {? _result<>200 & _result<>201 || M.cntx_pop();return(_result) ?};
::sprawdzenie dla metriałow dla grup kontrahentów
                           _result:=exec('s_product_pl','abstore','MGR','GRKH',M.MGR);
                           {? _result<>200 & _result<>201 || M.cntx_pop();return(_result) ?}
                        ?};
::wysyłanie załączników
                        exec('send_productresources','abstore', 0, M.ref())
                     ?}
                  ?}
               ?}
         ?};
         _next:=_tab.next();
         {? (_next=0 | _cnt=50) & _cnt>0 ||
::    wyslanie pliku
            exec('write_filefooter','abstore',_file);
            _result:=exec('http_send','abstore',_file,'products');
            fclose(_file);
            &_file;
            {? _result<>200 || M.cntx_pop();return ?};
            _cnt:=0
         ?};
         _next
     !}
::     clear_sync jest wywoływane po wysłaniu zdjęć
::      exec('clear_sync','abstore', _tab.ID, _tabname)
   ?}
||
   _ndx_fld:={? exec('param_get','abs_conf', 800127, 2)<>'' || exec('param_get','abs_conf', 800127, 2) || 'KTM' ?};
   _ndx:=M.ndx_tmp(,,'A',,,_ndx_fld,,,'KTM',,);
   M.index(_ndx);
   M.prefix('T',);
   M.first();
   _cnt:=0;
   _order:=0;
   {! |?
      {? exec('m_abstore','abstore')
      ||
          {? _cnt=0 || {? var_press('_file')>0 || &_file ?}; _file:=exec('create_msgfile','abstore','products') ?};
          _order+=1;
          _mpart:=exec('xml_product','abstore',_order);
          {? _mpart<>'' ||
            _mpart:=_mpart + exec('xml_productattributesall','abstore');
            fwrite(_file, maz_utf8(_mpart));
            _cnt:=_cnt + 1
          ?}
      ?};
      _next:=M.next();
      {? (_next=0 | _cnt=50) & _cnt>0 ||
::    wyslanie pliku
         exec('write_filefooter','abstore',_file);
         _result:=exec('http_send','abstore',_file,'products');
         fclose(_file);
         &_file;
         {? _result<>200 || M.cntx_pop();return ?};
         _cnt:=0
      ?};
      _next
   !};
   M.ndx_drop(_ndx)
?};
M.cntx_pop();
_result


\s_product_pl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [23.25]
:: OPIS: Aktualizuje cenniki indywidualne i grupowe
::   WE: _a - 'M' / 'MGR' - czy dla matreiału czy dla grupy materiałowej
::       _b - 'KH' / 'GRKH' - czy dla kontrahenta czu grupy kontrahentów
::       _c - M.ref()/MGR.ref()
::----------------------------------------------------------------------------------------------------------------------
TAP.cntx_psh();
TAR.cntx_psh();
KH.cntx_psh();
{? _a='M'
|| {? _b='KH'
   || _ndx_tap:=TAP.ndx_tmp(,,'M',,,'TAR','SD',,'TAR','ODDZ',,'TAR','KH',1)
   || _ndx_tap:=TAP.ndx_tmp(,,'M',,,'TAR','SD',,'TAR','ODDZ',,'TAR','GRKH',1)
   ?}
|| {? _b='KH'
   || _ndx_tap:=TAP.ndx_tmp(,,'MGR',,,'TAR','SD',,'TAR','ODDZ',,'TAR','KH',1)
   || _ndx_tap:=TAP.ndx_tmp(,,'MGR',,,'TAR','SD',,'TAR','ODDZ',,'TAR','GRKH',1)
   ?}
?};
TAP.index(_ndx_tap);
TAP.prefix(_c,'S',__AbStore.oddz,);
_tar_kh:=null();
_tar_grkh:=null();
_result:=200;
{? TAP.first()
||
   {!|?
      {? _b='KH'
      ||
         {? TAP.TAR().KH<>null & TAP.TAR().KH().ABSTORE<>'' & _tar_kh<>TAP.TAR().KH
         & TAP.OD<=date() & (TAP.DO=date(0,0,0) | date()<=TAP.DO)
         || _result:=exec('send_cpricelist2','abstore',0,TAP.TAR().KH);
            _tar_kh:=TAP.TAR().KH
         ?};
         {? _result<>200 & _result<>201
         || TAP.cntx_pop();
            TAR.cntx_pop();
            KH.cntx_pop();
            TAP.ndx_drop(_ndx_tap);
            return(_result)
         ?};
         TAP.next() & TAP.TAR().KH<>null
      ||
         {? TAP.TAR().GRKH<>null & TAP.TAR().GRKH().ABSTORE<>'' & _tar_grkh<>TAP.TAR().GRKH
         & TAP.OD<=date() & (TAP.DO=date(0,0,0) | date()<=TAP.DO)
         || _result:=exec('send_grouppricelist','abstore',0,TAP.TAR().GRKH);
            _tar_grkh:=TAP.TAR().GRKH
         ?};
         {? _result<>200 & _result<>201
         || TAP.cntx_pop();
            TAR.cntx_pop();
            KH.cntx_pop();
            TAP.ndx_drop(_ndx_tap);
            return(_result)
         ?};
         TAP.next() & TAP.TAR().GRKH<>null
      ?}
   !}
?};
TAP.cntx_pop();
TAR.cntx_pop();
KH.cntx_pop();
TAP.ndx_drop(_ndx_tap);
_result


\send_productresources
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wysyła załączniki do produktu
::   WE: _a - czy uzywac synchro (1)
::       _b - M.ref()
::   WY:
::----------------------------------------------------------------------------------------------------------------------
::exec('setupAbstoreb2b','abstore');
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
{? _>1 || _m_ref:='and M.REFERENCE=\'%1\''[$_b] || _m_ref:='' ?};
_tabname:='DOKUM';
_il_rec:=100;
_firma:='';
_repl:=0;
_result:=200;
_obslugiwaneRoz:='JPG, PNG, PDF, MP3, MP4, DOC, TXT';
M.cntx_psh();
M.prefix();
DOKUM.cntx_psh();
DOKUM.prefix();
_tabRef:=tab_tmp(1,'REF','STRING[16]','REF','IDADD','STRING[24]','IDADD');
{? _useSynchro ||
   _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
    _rodz:='';
    _cnt:=0;
   {? _tab.first()
   ||
     {! |?
         {? _cnt=0 ||{? var_press('_file')>0 || &_file ?};_file:=exec('create_msgfile','abstore','product-resource')?};
         {? _tab.RODZ <> 'del'
         ||
            _tr:={? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?};
            _ref:=_tab.REF;
            {? DOKUM.seek(_ref) & (DOKUM.REFSQL * 'mat'=1)
            ||
::rozszerzenie nazwy pliku
              _ext:=~-DOKUM.bl_info('DOKUM','EXTENSION');
              {? (_obslugiwaneRoz * _ext)>0 & (+_ext=3)
              ||
                  exec('xml_file', 'abstore', _file, DOKUM.DOKUM, 'file-'+$DOKUM.ref, _ext);
                  _mpart:=%13 + %10 + exec('xml_productresource','abstore', $DOKUM.ref , DOKUM.REFSQL,
                  DOKUM.bl_info('DOKUM','NAME'), 'file-'+$DOKUM.ref) + %13 + %10;
                  fwrite(_file,maz_utf8(_mpart));
                  _tabRef.REF:=_tab.ID;
                  _tabRef.add();
                  _cnt:=_cnt + 1
              ?}
            ?}
         ||
:: odłączenie załącznika od produktu
               _mpart:=%13 + %10 + exec('xml_productresourcedel', 'abstore', _tab.REF);
               fwrite(_file,_mpart);
               _cnt:=_cnt + 1
         ?};
         _next:=_tab.next;
         {? (_next=0 | _cnt=5) & _cnt>0
         ||
::    wyslanie pliku
            exec('write_filefooter','abstore',_file);
            _result:=exec('http_send','abstore',_file,'product-resource',0);
            fclose(_file);
            &_file;
            _cnt:=0;
            {? _result<>200 || M.cntx_pop();DOKUM.cntx_pop();return ?}
         ?};
         _next
     !}
   ?};
   {? _tabRef.first()
   ||
      {! |?
         exec('sync_delid','abstore', _tabRef.REF);
         _tabRef.del()
      !}
   ?}
::   exec('clear_sync', 'abstore', _tab.ID, _tabname)
||
   _cnt:=0;
   _tab:=sql('select D.REFERENCE as REF, M.REFERENCE as M_REF, D.NAZWA, D.KR_OP
               from M,DOKUM D
               where M.REFERENCE=D.REFSQL and '+ exec('m_abstore_sql','abstore')+_m_ref);
   M.prefix();
   {? _tab.first() & _tab.size()>0
   ||
      {! |?
         {? DOKUM.seek(_tab.REF)
         ||
::rozszerzenie nazwy pliku
           _ext:=~-DOKUM.bl_info('DOKUM','EXTENSION');
           {? (_obslugiwaneRoz * _ext)>0 & (+_ext=3)
           ||
              {? _cnt=0 || _file:=exec('create_msgfile','abstore','product-resource') ?};
              exec('xml_file','abstore', _file, DOKUM.DOKUM, 'file-'+$DOKUM.ref, _ext);
              _mpart:=%13 + %10 +  exec('xml_productresource','abstore', $DOKUM.ref, DOKUM.REFSQL,
              DOKUM.bl_info('DOKUM','NAME'),'file-'+$DOKUM.ref) + %13 + %10;
              fwrite(_file,maz_utf8(_mpart));
              _cnt:=_cnt + 1
           ?}
         ?};
         _next:=_tab.next;
         {? (_next=0 | _cnt=5) & _cnt>0
         ||
::    wyslanie pliku i utworzenie kolejnego
            exec('write_filefooter','abstore',_file);
            _result:=exec('http_send','abstore',_file,'product-resource',0);
            fclose(_file);
            &_file;
            _cnt:=0
         ?};
         _next
      !}
   ?}
?};
M.cntx_pop();
DOKUM.cntx_pop();
_result


\send_productpictures
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wysyła zdjęcia towarów do ABSTORE. Korzysta również z tabeli M_IMG
::   WE: _a - czy uzywac synchro (1)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
::exec('setupAbstoreb2b','abstore');
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_tabname:='M';
_il_rec:=100;
_firma:='';
_repl:=0;
_result:=200;
M.cntx_psh();
M_IMG.cntx_psh();
M.prefix();
{? _useSynchro ||
   _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
    _rodz:='';
    _cnt:=0;
    _tab_id:='0';
   {? _tab.first()
   ||
     {! |?
         {? _cnt=0
         || {? var_pres('_file')>=0 || obj_del(_file) ?};
            _file:=exec('create_msgfile','abstore','product-img')
         ?};
         {? _tab.RODZ <> 'del'
         ||
            _tr:={? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?};
            _ref:=_tab.REF;
            _jestRys:=_tr * 'RYS:1';
            {? M.seek(_ref) & exec('prod_tabRef','abstore',_ref)
            ||
               _tab_id:=_tab.ID;
               {? _jestRys
               ||
                  {? M.RYS<>null
                  ||
                     exec('xml_fileimg', 'abstore', _file, M.RYS, $M.ref);
                     _mpart:=%13 + %10 + exec('xml_productimg','abstore', _ref, _ref, _ref) + %13 + %10;
                     fwrite(_file,_mpart);
                     _cnt:=_cnt + 1
                  ?}
               ?};
               M_IMG.cntx_psh();
               M_IMG.index('M');
               M_IMG.prefix(M.ref());
               {? M_IMG.first()
               ||
                  {!|?
                     {? M_IMG.IMG<>null
                     ||
                        exec('xml_fileimg', 'abstore', _file, M_IMG.IMG, _ref, );
                        _mpart:=%13 + %10 + exec('xml_productimg','abstore', _ref, $M_IMG.M, _ref, 'false') + %13 + %10;
                        fwrite(_file,_mpart);
                        _cnt:=_cnt + 1
                     ?};
                     M_IMG.next()
                  !}
               ?};
               M_IMG.cntx_pop()
            ?}
         ?};
         _next:=_tab.next();
         {? (_next=0 | _cnt=5) & _cnt>0
         ||
::    wyslanie pliku i utworzenie kolejnego
            exec('write_filefooter','abstore',_file);
            _result:=exec('http_send','abstore',_file,'product-img',0);
            fclose(_file);
            &_file;
            {? _result<>200 || M.cntx_pop();M_IMG.cntx_pop();return ?};
            _cnt:=0
         ?};
         _next
     !};
     {? _tab_id<>'0' ||  exec('clear_sync', 'abstore', _tab_id, _tabname) ?}
   ?};
:: obrazki dodatkowe
   {? var_press('_tab')>=0 || &_tab ?};
   _tabname:='M_IMG';
   _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
    _rodz:='';
    _cnt:=0;
   {? _tab.first()
   ||
     {! |?
         {? _cnt=0
         || {? var_pres('_file')>=0 || obj_del(_file) ?};
            _file:=exec('create_msgfile','abstore','product-img2')
         ?};
         {? _tab.RODZ <> 'del'
         ||
           _tr:={? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?};
           _ref:=_tab.REF;
            {? M_IMG.seek(_ref)
            ||
               {? M_IMG.IMG<>null
               ||
                  exec('xml_fileimg', 'abstore', _file, M_IMG.IMG, _ref, );
                  _mpart:=%13 + %10 + exec('xml_productimg','abstore', _ref, $M_IMG.M, _ref, 'false') + %13 + %10;
                  fwrite(_file,_mpart);
                  _cnt:=_cnt + 1
               ?}
            ?}
         ||
:: odłączenie obrazka od produktu
               _mpart:=%13 + %10 + exec('xml_productimgdel','abstore', _tab.REF);
               fwrite(_file,_mpart);
               _cnt:=_cnt + 1
         ?};
         _next:=_tab.next();
         {? (_next=0 | _cnt=5) & _cnt>0
         ||
::    wyslanie pliku i utworzenie kolejnego
            exec('write_filefooter','abstore',_file);
            _result:=exec('http_send','abstore',_file,'product-img2',0);
            fclose(_file);
            &_file;
            {? _result<>200 || M.cntx_pop();M_IMG.cntx_pop();return ?};
            _cnt:=0
         ?};
         _next
     !};
     exec('clear_sync', 'abstore', _tab.ID, _tabname)
   ?}
||
   _cnt:=0;
   _tab:=sql('select M.REFERENCE as REF from M where '+ exec('m_abstore_sql','abstore') +' and M.RYS is not null');
   M.prefix;
   {?  _tab.first() & _tab.REF<>''
   ||
      {! |?
         {? M.seek( _tab.REF )
         ||
           {? _cnt=0 || _file:=exec('create_msgfile','abstore','product-img') ?};
           exec('xml_fileimg','abstore',_file, M.RYS, $M.ref);
           _mpart:=%13 + %10 +  exec('xml_productimg','abstore', $M.ref, $M.ref, $M.ref) + %13 + %10;
           fwrite(_file,_mpart);
           _cnt:=_cnt + 1
         ?};
         _next:=_tab.next;
         {? (_next=0 | _cnt=5) & _cnt>0
         ||
::    wyslanie pliku i utworzenie kolejnego
            exec('write_filefooter','abstore',_file);
            _result:=exec('http_send','abstore',_file,'obrazki',0);
            fclose(_file);
            &_file;
            {? _result<>200 || M.cntx_pop();M_IMG.cntx_pop();return ?};
            _cnt:=0
         ?};
         _next
      !}
   ?};
:: obrazki dodatkowe z M_IMG
   _cnt:=0;
   {? var_press('_tab')>=0 || &_tab ?};
   _tab:=sql('select M_IMG.REFERENCE as REF,  M_IMG.M
               from M_IMG
               join M using (M_IMG.M, M.REFERENCE)
               where '+ exec('m_abstore_sql','abstore'));
   M_IMG.prefix;
   {? _tab.first() & _tab.size()>0
   ||
      {! |?
         {? _tab.REF<>'' & M_IMG.seek(_tab.REF)
         ||
           {? _cnt=0 || _file:=exec('create_msgfile','abstore','product-img2') ?};
           exec('xml_fileimg','abstore', _file, M_IMG.IMG, _tab.REF);
           _mpart:=%13 + %10 +  exec('xml_productimg','abstore', _tab.REF, $M_IMG.M, _tab.REF, 'false') + %13 + %10;
           fwrite(_file,_mpart);
           _cnt:=_cnt + 1
         ?};
         _next:=_tab.next;
         {? (_next=0 | _cnt=5) & _cnt>0
         ||
::    wyslanie pliku i utworzenie kolejnego
            exec('write_filefooter','abstore',_file);
            _result:=exec('http_send','abstore',_file,'obrazki',0);
            fclose(_file);
            &_file;
            {? _result<>200 || M.cntx_pop();M_IMG.cntx_pop();return ?};
            _cnt:=0
         ?};
         _next
      !}
   ?}
?};
M.cntx_pop();
M_IMG.cntx_pop();
_result


\send_prices
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS:  Wysyła cennik ogólny do ABSTORE
::   WE: _a - czy uzywac synchro (1  domyślnie)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_tabname:='TAP';
_il_rec:=100;
_firma:='';
_repl:=0;
_file:=exec('create_msgfile','abstore','prices');
_cnt:=0;
_price:=obj_new('REF','M','OD','DO','CEN','CENB','WAL');
TAR.cntx_psh();
TAP.cntx_psh();
M.cntx_psh();
M.prefix();
::tabela do zapisania przetworzonych pozycji z synchro
_tbsync:=tab_tmp(1,'ID','STRING[20]','ID');
{? _useSynchro
||
    _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
    _rodz:='';
    _sql_r:='';
   {? _tab.first()
   ||
     {! |?
         TAP.use(_tab.REF-8);
         {? _tab.RODZ<>'del' & TAP.seek(_tab.REF)
         ||
            {? TAP.RODZ='C' & (__AbStore.cennik * TAP.TAR().KOD)>0 & (TAP.TAR().SD='S')
            ||
               _sql_r+='OR TAP.M=\''+$TAP.M+'\'';
               _tbsync.ID:=_tab.ID;
               _tbsync.add
            ||
               {? ~__AbStore.useStore
               ||
                  _tbsync.ID:=_tab.ID;
                  _tbsync.add
               ?}
            ?}
         ?};
         _tab.next()
     !}
   ?};
   {? _sql_r<>''
   ||
      _sql_r:='AND ('+(3-_sql_r)+')';
::dla odwroconych ofert cennik ogólny musi mieć priorytet = 1
      {? __AbStore.reverseOffer || _pri:=' and TAR.P=1' || _pri:='' ?};
:: Cennik EUR
      _sql:='select TAR.P, TAP.REFERENCE as REF, TAP.*, SLO.KOD from M
         join TAP using(TAP.M,M.REFERENCE)
         join TAR using(TAR.REFERENCE,TAP.TAR)
         join :_a C using(C.KOD,TAR.KOD)
         join SLO using(TAP.WAL,SLO.REFERENCE)
         where '+ exec('m_abstore_sql','abstore') +'
         and TAP.RODZ=''C'' %1 %2 and TAP.CEN<>0
         and TAR.SD=''S''
         and SLO.KOD=:_b
         and NVL(TAP.OD,CURRENT_DATE)<=CURRENT_DATE
         and NVL(TAP.DO,CURRENT_DATE)>=CURRENT_DATE
         order by TAR.P asc'[_pri, _sql_r];
      _tabEur:=sql(_sql, __AbStore.tabCen, '\'EUR\'');

      _cur:=exec('currency','abstore');

      {? _tabEur.first()
      ||
         {! |?
            _prc:=1-_tabEur.PRC/100;
            _price.M:=_tabEur.M;
            _price.REF:=_tabEur.REF;
            _price.CEN:=form(_tabEur.CEN*_prc,,2,'9.');
            _price.CENB:=form(_tabEur.CENB*_prc,,2,'9.');
            _price.WAL:=_tabEur.KOD;
            _price.OD:='0000/00/00';
            _price.DO:=$_tabEur.DO;
            _mpart:=exec('xml_productprice','abstore',_price);
            _cnt:=_cnt + 1;
            fwrite(_file,_mpart);

            _price.CEN:=form(_tabEur.CEN*_cur.PEUR*_prc,,2,'9.');
            _price.CENB:=form(_tabEur.CENB*_cur.PEUR*_prc,,2,'9.');
            _price.WAL:='PLN';
            _mpart:=exec('xml_productprice','abstore',_price);

            _cnt:=_cnt + 1;
            fwrite(_file,_mpart);
            _tabEur.next()
         !}
      ?};

:: Cennik USD
      _tabUsd:=sql(_sql, __AbStore.tabCen, '\'USD\'');

      {? _tabUsd.first()
      ||
         {! |?
            _prc:=1-_tabUsd.PRC/100;
            _price.M:=_tabUsd.M;
            _price.REF:=_tabUsd.REF;
            _price.CEN:=form(_tabUsd.CEN*_prc,,2,'9.');
            _price.CENB:=form(_tabUsd.CENB*_prc,,2,'9.');
            _price.WAL:=_tabUsd.KOD;
            _price.OD:='0000/00/00';
            _price.DO:=$_tabUsd.DO;
            _mpart:=exec('xml_productprice','abstore',_price);
            _cnt:=_cnt + 1;
            fwrite(_file,_mpart);

            _price.CEN:=form(_tabUsd.CEN*_cur.PUSD*_prc,,2,'9.');
            _price.CENB:=form(_tabUsd.CENB*_cur.PUSD*_prc,,2,'9.');
            _price.WAL:='PLN';
            _mpart:=exec('xml_productprice','abstore',_price);

            _cnt:=_cnt + 1;
            fwrite(_file,_mpart);
            _tabUsd.next()
         !}
      ?};

:: Cennik PLN
      _tabM:=sql(_sql, __AbStore.tabCen, '\'PLN\'');

      {? _tabM.first()
      ||
         {! |?
            _prc:=1-_tabM.PRC/100;
            _price.M:=_tabM.M;
            _price.REF:=_tabM.REF;
            _price.CEN:=form(_tabM.CEN*_prc,,2,'9.');
            _price.CENB:=form(_tabM.CENB*_prc,,2,'9.');
            _price.WAL:=_tabM.KOD;
            _price.OD:='0000/00/00';
            _price.DO:=$_tabM.DO;
            _mpart:=exec('xml_productprice','abstore',_price);
            _cnt:=_cnt + 1;
            fwrite(_file,_mpart);
            _tabM.next()
         !}
      ?}
   ?}
||
::dla odwroconych ofert cennik ogólny musi mieć priorytet = 1
   {? __AbStore.reverseOffer || _pri:=' and TAR.P=1' || _pri:='' ?};
:: Cennik EUR
   _sql:='select TAR.P, TAP.REFERENCE as REF, TAP.*, SLO.KOD from M
      join TAP using(TAP.M,M.REFERENCE)
      join TAR using(TAR.REFERENCE,TAP.TAR)
      join :_a C using(C.KOD,TAR.KOD)
      join SLO using(TAP.WAL,SLO.REFERENCE)
      where '+ exec('m_abstore_sql','abstore') +'
      and TAP.RODZ=''C'' %1 and TAP.CEN<>0
      and TAR.SD=''S''
      and SLO.KOD=:_b
      and NVL(TAP.OD,CURRENT_DATE)<=CURRENT_DATE
      and NVL(TAP.DO,CURRENT_DATE)>=CURRENT_DATE
      order by TAR.P asc'[_pri];
   _tabEur:=sql(_sql, __AbStore.tabCen, '\'EUR\'');

   _cur:=exec('currency','abstore');

   {? _tabEur.first()
   ||
      {! |?
         _prc:=1-_tabEur.PRC/100;
         _price.M:=_tabEur.M;
         _price.REF:=_tabEur.REF;
         _price.CEN:=form(_tabEur.CEN*_prc,,2,'9.');
         _price.CENB:=form(_tabEur.CENB*_prc,,2,'9.');
         _price.WAL:=_tabEur.KOD;
         _price.OD:='0000/00/00';
         _price.DO:=$_tabEur.DO;
         _mpart:=exec('xml_productprice','abstore',_price);
         _cnt:=_cnt + 1;
         fwrite(_file,_mpart);

         _price.CEN:=form(_tabEur.CEN*_cur.PEUR*_prc,,2,'9.');
         _price.CENB:=form(_tabEur.CENB*_cur.PEUR*_prc,,2,'9.');
         _price.WAL:='PLN';
         _mpart:=exec('xml_productprice','abstore',_price);

         _cnt:=_cnt + 1;
         fwrite(_file,_mpart);
         _tabEur.next()
      !}
   ?};

:: Cennik USD
   _tabUsd:=sql(_sql, __AbStore.tabCen, '\'USD\'');

   {? _tabUsd.first()
   ||
      {! |?
         _prc:=1-_tabUsd.PRC/100;
         _price.M:=_tabUsd.M;
         _price.REF:=_tabUsd.REF;
         _price.CEN:=form(_tabUsd.CEN*_prc,,2,'9.');
         _price.CENB:=form(_tabUsd.CENB*_prc,,2,'9.');
         _price.WAL:=_tabUsd.KOD;
         _price.OD:='0000/00/00';
         _price.DO:=$_tabUsd.DO;
         _mpart:=exec('xml_productprice','abstore',_price);
         _cnt:=_cnt + 1;
         fwrite(_file,_mpart);

         _price.CEN:=form(_tabUsd.CEN*_cur.PUSD*_prc,,2,'9.');
         _price.CENB:=form(_tabUsd.CENB*_cur.PUSD*_prc,,2,'9.');
         _price.WAL:='PLN';
         _mpart:=exec('xml_productprice','abstore',_price);

         _cnt:=_cnt + 1;
         fwrite(_file,_mpart);
         _tabUsd.next()
      !}
   ?};

:: Cennik PLN
   _tabM:=sql(_sql, __AbStore.tabCen, '\'PLN\'');

   {? _tabM.first()
   ||
      {! |?
         _prc:=1-_tabM.PRC/100;
         _price.M:=_tabM.M;
         _price.REF:=_tabM.REF;
         _price.CEN:=form(_tabM.CEN*_prc,,2,'9.');
         _price.CENB:=form(_tabM.CENB*_prc,,2,'9.');
         _price.WAL:=_tabM.KOD;
         _price.OD:='0000/00/00';
         _price.DO:=$_tabM.DO;
         _mpart:=exec('xml_productprice','abstore',_price);
         _cnt:=_cnt + 1;
         fwrite(_file,_mpart);
         _tabM.next()
      !}
   ?}
?};
{? _cnt>0 ||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'pricelist');
   fclose(_file);
   &_file
||
    _result:=201
?};
TAR.cntx_pop();
TAP.cntx_pop();
M.cntx_pop();
{? _result=200 | _result=201 || exec('sync_deltab','abstore',_tbsync); &_tbsync ?};
_result


\sendOfferSync
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: Wysyła pojedyncze pozycje oferty domyslnej lub dedykowanej (gdy __AbStore.reverseOffer=1)
::       Uwaga: Nagłówki ofert muszą zostać wysłane wcześniej przez executeSendOffer
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_tabname:='TAP';
_il_rec:=100;
_firma:='';
_repl:=0;
_file:=exec('create_msgfile','abstore','offer-sync');
_cnt:=0;
_price:=obj_new('REF','M','OD','DO','CEN','CENB','WAL');
_price.WAL:='PLN';
TAR.cntx_psh();
TAP.cntx_psh();
M.cntx_psh();
M.prefix();
::tabela do zapisania przetworzonych pozycji z synchro
_tbsync:=tab_tmp(1,'ID','STRING[20]','ID');
{? _useSynchro
||
    _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
    _rodz:='';
   {? _tab.first()
   ||
     {! |?
         TAP.use(_tab.REF-8);
         {? _tab.RODZ<>'del' & TAP.seek(_tab.REF)
         ||
::odfiltrowujemy pozycje dotyczace tylko wybranego cennika
::usuwanie pozycji nie bedzie dzialac bo nie mamy info z triggera o usunietym M i WAL

::dla ofert odwroconych sprawdzamy czy cennik ogolny ma priorytet=1
            _priOk:=1;
            {? __AbStore.reverseOffer || _priOk:=TAP.TAR().P=1 ?};
            {? TAP.RODZ='C'  & (TAP.TAR().SD='S')
            ||
::przy zmianie wysylaniu pozycji z cennika ogolnego trzeba sprawdzic
::czy nie istnieje aktywna cena na ten towar z wyzszym priorytetem
::- w takim przypadku cena z synchro nie jest wysylana
               _flagOk:=1;
               {? __AbStore.reverseOffer
               ||
                  _sql:='select TAR.P, TAP.REFERENCE as REF, TAP.* from M
                  join TAP using(TAP.M,M.REFERENCE)
                  join TAR using(TAR.REFERENCE,TAP.TAR)
                  where '+ exec('m_abstore_sql','abstore') +' and TAR.SD=''S''
                  and TAP.RODZ=''C'' and TAP.CEN<>0
                  and TAP.M=''%1'' and TAR.P<%2
                  and NVL(TAP.OD,CURRENT_DATE)<=CURRENT_DATE
                  and NVL(TAP.DO,CURRENT_DATE)>=CURRENT_DATE
                  order by TAR.P desc'[$TAP.M,$TAP.TAR().P];
                  _query:=sql(_sql);
                  _flagOk:=~_query.first();
                  obj_del(_query)
               ?};
               {? _flagOk
               ||
                  _cnt:=_cnt + 1;
                  _tr:={? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?};
                  exec('extract_tr','abstore',_tr,_price);
                  _ref:=_tab.REF;
                  _price.REF:=_ref;
                  _cnt:=_cnt + 1;
                  _mpart:=exec('xml_productprice','abstore',_price);
                  fwrite(_file,_mpart)
               ?}
            ?}
         ?};
         _tbsync.ID:=_tab.ID;
         _tbsync.add;
         _tab.next()
     !}
   ?}
||
::dla odwroconych ofert cennik ogólny musi mieć priorytet = 1
   {? __AbStore.reverseOffer || _pri:=' and TAR.P=1' || _pri:='' ?};
   _sql:='select TAR.P, TAP.REFERENCE as REF, TAP.* from M
   join TAP using(TAP.M,M.REFERENCE)
   join TAR using(TAR.REFERENCE,TAP.TAR)
   where '+ exec('m_abstore_sql','abstore') +' %1
   and TAP.RODZ=''C'' and TAP.CEN<>0 and TAR.SD=''S''
   and NVL(TAP.OD,CURRENT_DATE)<=CURRENT_DATE
   and NVL(TAP.DO,CURRENT_DATE)>=CURRENT_DATE
   order by TAR.P desc'[_pri];
   _tabM:=sql(_sql);
::exec('select','#table',_tab)
::   _tabM:=M;
   {? _tabM.first()
   ||
      {! |?
         _price.M:=_tabM.M;
         _price.REF:=_tabM.REF;
         _price.CEN:=$_tabM.CEN;
         _price.CENB:=$_tabM.CENB;
         _price.WAL:='PLN';
::                  {? TAP.WAL<>null || TAP.WAL().KOD || 'PLN' ?};
:: caly cennik jest wysylany tylko aktualnie aktywny wiec data OD nie jest potrzebna
::         _price.OD:=$_tabM.OD;
         _price.OD:='0000/00/00';
         _price.DO:=$_tabM.DO;
         _mpart:=exec('xml_productprice','abstore',_price);
         _cnt:=_cnt + 1;
         fwrite(_file,_mpart);
         _tabM.next()
      !}
   ?}
?};
{? _cnt>0 ||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'pricelist');
   fclose(_file);
   &_file
||
    _result:=201
?};
TAR.cntx_pop();
TAP.cntx_pop();
M.cntx_pop();
{? _result=200 | _result=201 || exec('sync_deltab','abstore',_tbsync); &_tbsync ?};
_result


\send_stock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: eksport stanów magazynowych do ABSTORE
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
::TODO  obsługa wysyłania stanu z wielu magazynów (B2B)
_tabname:='SM';
_il_rec:=100;
_firma:='';
_repl:=0;
::_message:=exec('xml_messageheader','abstore');
_file:=exec('create_msgfile','abstore','stock');
_cnt:=0;
_stan:=obj_new('M','SD','MAG');
{? _useSynchro
||
   _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
   _rodz:='';
   {? _tab.first
   ||
     {! |?
         _cnt:=_cnt + 1;
         _rodz:=_tab.RODZ;
         _tr:={? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?};
         exec('extract_tr','abstore',_tr,_stan);
::tu mozna zmienic wartosc _stan.S na true/false jesli taka potrzeba
         _mpart:=exec('xml_productavailability','abstore',_stan);
         fwrite(_file,_mpart);
         _tab.next
     !}
   ?}
||
   MG.cntx_psh();
   SM.cntx_psh();
   M.cntx_psh();
   MG.index('MAGAZYNY');
   MG.prefix();
   _idx:=1;
   {? __AbStore.tabMG.first()
   ||
      {! |?
         _magazyn:=__AbStore.tabMG.SYM;
         MG.find_key(_magazyn);
         _mg:=$MG.ref();
         M.prefix();
         SM.use('stm__'+__AbStore.oddz+'zb');
         SM.index('SM');
         SM.prefix(MG.ref);
         {? SM.first
         ||
            {! |?
                {? M.seek(SM.M) & exec('m_abstore','abstore')
                ||
                   _stan.SD:=gsub($SM.SD, ',','.');
                   _stan.M:=$SM.M;
                   _stan.MAG:=SM.MAG().SYM;
                   _mpart:=exec('xml_productavailability','abstore', _stan);
                   _cnt:=_cnt + 1;
                   fwrite(_file, _mpart)
                ?};
::          _message:=_message + _mpart + %13 + %10
                SM.next
            !}
         ?};
         __AbStore.tabMG.next()
      !}
   ?};
   MG.cntx_pop();
   SM.cntx_pop();
   M.cntx_pop()
?};
{? _cnt>0
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'stock');
   {? _result=200 & _useSynchro || exec('clear_sync','abstore',_tab.ID, _tabname) ?};
   fclose(_file);
   &_file
||
    _result:=201
?};
_result


\send_stock_v2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: eksport stanów magazynowych do ABSTORE - wersja WIELOMAGAZYNOWA
::   WE: _a - czy uzywac synchro (1)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_tabname:='SM';
_il_rec:=100;
_firma:='';
_repl:=0;
::_message:=exec('xml_messageheader','abstore');
_file:=exec('create_msgfile','abstore','stock');
_cnt:=0;
_stan:=obj_new('M','SD','MAG');
{? _useSynchro
||
   _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
   _rodz:='';
   {? _tab.first
   ||
     {! |?
         _cnt+=1;
         _rodz:=_tab.RODZ;
         _tr:={? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?};
         exec('extract_tr','abstore',_tr,_stan);
::wysyłamy jeśli zmiana stanu dotyczy obsługiwanego w AbStore magazynu
         _mpart:='';
         {? __AbStore.magazyn * _stan.MAG
         ||
::tu mozna zmienic wartosc _stan.S na true/false jesli taka potrzeba
            _mpart:=exec('xml_productavailability', 'abstore', _stan)
         ?};
         fwrite(_file,_mpart);
         _tab.next
     !}
   ?};
   {? _cnt>0
   ||
      exec('write_filefooter','abstore',_file);
      _result:=exec('http_send','abstore',_file,'stock');
      {? _result=200 & _useSynchro || exec('clear_sync','abstore',_tab.ID, _tabname) ?};
      fclose(_file);
      &_file
   ||
       _result:=201
   ?};
   _result
||
::wszystkie stany towarów
::jesli useStore=1 to wysyłamy stany wg magazynów, gdy 0 to zsumowane z podanych magazynów
   {? __AbStore.useStore=1 || _mag:=',MG.SYM as MAG'; _grp:=',MG.SYM' || _mag:=',''MAG'' as MAG'; _grp:='' ?};
   _sql:='select SM.M, sum(SM.SD) as SD %1
   from @SM, M, MG
   where M.REFERENCE=SM.M
   and MG.REFERENCE=SM.MAG
   and '[_mag]+ exec('m_abstore_sql','abstore') +'
   and POSITION(MG.SYM in ''%1'')>0
   group by SM.M %2
   order by SM.M'[__AbStore.magazyn, _grp];
   _tab:=sql(_sql);
   exec('send_uni','abstore',_tab,'xml_productavailability')
?}


\send_stockProductUpd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: wysyła stan magazynowy towarow zmodyfikowanych
::       potrzebne gdy np. został zmieniony znacznik dostępności towaru w sklepie a nie było zmian w magazynie
::       wykorzystuje tabele __AbStore.tabRef do stworzenia komunikatu
::   WE: _a - ref towaru do wysłania
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? __AbStore.useStore=1 || _mag:=',MG.SYM as MAG'; _grp:=',MG.SYM' || _mag:=',''MAG'' as MAG'; _grp:='' ?};
{? __AbStore.tabRef.size()=0 || return(201) ?};
_sql:='select SM.M, sum(SM.SD) as SD %1
from @SM, M, MG, :_a A
where M.REFERENCE=A.REF
and  M.REFERENCE=SM.M
and MG.REFERENCE=SM.MAG
and '[_mag]+ exec('m_abstore_sql','abstore') +'
and POSITION(MG.SYM in ''%1'')>0
group by SM.M %2
order by SM.M'[__AbStore.magazyn, _grp];
_tab:=sql(_sql, __AbStore.tabRef);
exec('send_uni','abstore',_tab,'xml_productavailability')


\send_productActivityUpd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: Oddzielny komunikat aktywacji produktu - NIE DZIAŁA - kolejka i tak jest przetwarzana z
::       komunikatami oczekującymi na końcu, więc jeśli będzie komunikat oczekujący activity="false"
::       to produkt stanie się nieaktywny.
::----------------------------------------------------------------------------------------------------------------------
{? __AbStore.tabRef.size()=0 || return(201) ?};
M.cntx_psh();
M.prefix();
{? __AbStore.tabRef.first()
||
   {! |?
      {? __AbStore.tabRef.REF*'material' & M.seek(__AbStore.tabRef.REF) & exec('m_abstore','abstore')
      ||
         _xml:=exec('xml_messageheader','abstore');
         _xml+=exec('xml_productactivity','abstore', $M.ref(),
         {? M.A='T' & exec('m_abstore_a','abstore') || 'true' || 'false' ?});
         _xml+=exec('xml_messagefooter','abstore');
         exec('http_send','abstore',_xml,'product activity '+$M.ref(),1);
         __AbStore.tabRef.next()
      ?}
   !}
?};
M.cntx_pop();
200


\send_cpricelist_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: wysyła cenniki zmodyfikowanych kontrahentów (refy sa w tabeli __AbStore.tabRef)
::----------------------------------------------------------------------------------------------------------------------
{? __AbStore.tabRef.size()=0 || return(201) ?};
_result:=201;
{? __AbStore.tabRef.first()
||
   {! |?
      _result:=exec('send_cpricelist2','abstore',0,__AbStore.tabRef.REF);
      __AbStore.tabRef.del()
   !}
?};
_result


\xml_contractorpricegroup
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: tworzy cennik grupowy
::   WE: _a - id cennika - nazwa grupy
::       _b - nazwa cennika
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<contractor-price-group eid="cpg-%1" />
<contractor-price-group-i18n contractor-price-eid="cpg-%1" lang="pl">
    <name>%2</name>
</contractor-price-group-i18n>'[xml_valu(_a),xml_valu(_b)];
_xml


\xml_contpricegroupproduct
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: przypisuje produkt do cennika grupowego
::   WE: _a - id cennika
::       _b - M.ref
::       _c - netto
::       _d - brutto
::       _e - waluta
::       _f - zniżka
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<cont-price-prod-rawxml contractor-price-eid="%1" product-eid="%2" currency="%3" '[_a,_b,_e];

{? var_press('_f')<0 || _f:=0 ?};
{? _f<>0 & _c<>0 ||
   _c:=(_c*(1-(_f/100)))$ 2;
   _d:=(_d*(1-(_f/100)))$ 2;
   _f:=0
?};
::jesli ceny sa 0 i rabat 0 to wysylam z rabatem 0
{? _f=0 & _c=0 & _d=0
|| _xml+=' percent-discount-rate="%1" />'[gsub($_f,',','.')];
   return(_xml)
?};
{? _f=0 ||
::tylko ceny jesli rabat=0
   _xml+=' base-net="%1" base-gross="%2" />'[gsub($_c,',','.'), gsub($_d,',','.')]
||
::tylko rabat jesli <>0
  _xml+=' percent-discount-rate="%1" />'[gsub($_f,',','.')]
?};
_xml


\xml_pricegroupcontractor
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: przypisanie kontrahenta/oddziału do cennika grupowego
::   WE: _a - id cennika grupowego (TAR.ref albo TAR.kod)
::       _b - id kontrahenta/oddziału
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<contractor-price-group-contractor contractor-price-eid="cpg-%1" contractor-eid="%2" />'
[xml_valu(_a),xml_valu(_b)];
_xml


\xml_contractorpricegroupdel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: usunięcie cennika grupowego
::   WE: _a - id cennika (TAR.ref / TAR.KOD)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
'<contractor-price-group-del contractor-price-eid="%1" />'[_a]


\xml_contractorprice
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS:  nagłówek cennika indywidualnego
::   WE:  _a - id cennika
::        _b - id kontrahenta
::        _c - nazwa cennika
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<contractor-price-individual eid="cprice-%1" contractor-eid="%2" />
         <contractor-price-individual-i18n contractor-price-eid="cprice-%1" lang="pl">
            <name>%3</name>
         </contractor-price-individual-i18n>'[_a,{? __AbStore.useDivisionPriceList || 'div-' || '' ?} + _b,xml_valu(_c)];
_xml


\xml_contractorpriceproduct
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: pozycja cennika indywidualnego kontrahenta
::   WE: _a - id cennika
::       _b - id produktu
::       _c - cena netto
::       _d - cena brutto
::       _e - waluta
::       _f - rabat
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _b='' || return('') ?};

_xml:='<cont-price-prod-rawxml contractor-price-eid="cprice-%1" product-eid="%2" currency="%3" '[_a,_b,_e];
{? var_press('_f')<0 || _f:=0 ?};
{? _f<>0 & _c<>0 ||
   _c:=(_c*(1-(_f/100)))$ 2;
   _d:=(_d*(1-(_f/100)))$ 2;
   _f:=0
?};
::jesli ceny sa 0 i rabat 0 to wysylam z rabatem 0
{? _f=0 & _c=0 & _d=0
|| _xml+=' percent-discount-rate="%1" />'[gsub($_f,',','.')];
   return(_xml)
?};
{? _f=0 ||
::tylko ceny jesli rabat=0
   _xml+=' base-net="%1" base-gross="%2" />'[gsub($_c,',','.'), gsub($_d,',','.')]
||
::tylko rabat jesli <>0
  _xml+=' percent-discount-rate="%1" />'[gsub($_f,',','.')]
?};
_xml


\sync_deltab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: usuwa z synchro rekordy zapisane w tabeli
::   WE: _a - tabela z ID do usuniecia z sync
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_a.first;
{! |?
   proc_exe('sync_del@synchro', _a.ID, __AbStore.synchro);
   _a.next
!}


\sync_delid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: usuwa pojedynczy wpis z synchro
::   WE: _a - id wpisu w synchro do usunięcia
::   WY:
::----------------------------------------------------------------------------------------------------------------------
proc_exe('sync_del@synchro', _a, __AbStore.synchro)


\sendContractorPriceList
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wysyła cennik indywidualny kontrahentów o podanym kodzie, tylko dla kontrahentów oznaczonych ABSTORE<>''
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_tabname:='TAP';
_il_rec:=100;
_firma:='';
_repl:=0;
_cnt:=0;
_price:=obj_new('REF','M','OD','DO','CEN','CENB','WAL','KH','GRKH','ABSTORE','PRC');
_price.WAL:='PLN';
::tabela do zapisania przetworzonych pozycji z synchro
_tbsync:=tab_tmp(1,'ID','STRING[20]','ID');
{? _useSynchro
||
   TAR.cntx_psh();
   TAR.prefix();
   TAP.cntx_psh();
   TAP.prefix();
   KH.cntx_psh();
   KH.prefix();
    _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
   _kid:='';
   {? _tab.first
   ||

     {! |?
::interesuja nas pozycje cennika kontrahentow oznaczonych ABSTORE<>''
         exec('extract_tr','abstore', {? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?}, _price);
        {?  _tab.RODZ<>'del' & _price.KH<>'' & _price.ABSTORE<>''
        ||
::zapis nagłówka pliku
           {? _cnt=0 || _file:=exec('create_msgfile','abstore','cennik_kh') ?};
           {? _price.KH<>_kid
           ||
              TAP.use(_tab.REF-8);
              {? TAP.seek(_tab.REF)
              ||
                 {? KH.seek(_price.KH)
                 ||
                   _xml:=exec('xml_contractorprice','abstore', TAP.TAR().KOD, TAP.TAR().NAZ, 'cennik ' + KH.KOD);
                   _kid:=_price.KH;
                   fwrite(_file, maz_utf8(_xml))
                 ?}
              ?}
           ?};
           _xml:=exec('xml_contractorpriceproduct','abstore', TAR.KOD, _price.M, #_price.CEN, #_price.CENB,
                  {? _price.WAL='' || 'PLN' || _price.WAL ?}, #_price.PRC);
           fwrite(_file, _xml);
           _cnt:=_cnt + 1;
           _tbsync.ID:=_tab.ID;
           _tbsync.add
        ?};
        _next:=_tab.next
     !}
   ?};
   TAR.cntx_pop();
   TAP.cntx_pop();
   KH.cntx_pop()
||
::pelny cennik bez synchro
   _tabCen:=sql('select TAP.REFERENCE as REF, TAP.CEN, TAP.CENB, WAL.KOD as WAL, TAP.M, TAR.KOD as TAR_KOD,
   KH.REFERENCE as KH_REF, KH.KOD as KH_KOD, KH.SKR as KH_SKR
   from TAR, TAP, M, KH, SLO as WAL
   where TAR.REFERENCE=TAP.TAR
        and TAP.M=M.REFERENCE
        and TAR.KH=KH.REFERENCE
        and WAL.REFERENCE=TAP.WAL
        and '+ exec('m_abstore_sql','abstore') +'
        and (NVL(TAP.DO,CURRENT_DATE)>=CURRENT_DATE )
        order by KH_REF');
   _cnt:=0;
   {? _tabCen.first
   ||
      _file:=exec('create_msgfile','abstore', 'cennik_kh');
      _kid:='';
      {! |?
        {? _tabCen.KH_REF<>_kid
        ||
            _xml:=exec('xml_contractorprice','abstore', _tabCen.TAR_KOD, _tabCen.KH_REF, 'cennik ' + _tabCen.KH_SKR);
            _kid:=_tabCen.KH_REF;
            fwrite(_file, maz_utf8(_xml))
        ?};
        {? _tabCen.WAL='' || _tabCen.WAL:='PLN' ?};

        _xml:=exec('xml_contractorpriceproduct','abstore', _tabCen.TAR_KOD, _tabCen.M, gsub($_tabCen.CEN,',','.'), gsub($_tabCen.CENB,',','.'), _tabCen.WAL);
        fwrite(_file, _xml);
        _cnt:=_cnt + 1;
        _tabCen.next
      !}
   ?}
?};
{? _cnt>0
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'contractor-price');
   fclose(_file);
   &_file;
::czyszczenie SYNC
   {? _result=200 || exec('sync_deltab','abstore',_tbsync); &_tbsync ?}
||
    _result:=201
?};
_result


\send_contractorpricelist_new
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wysyła cennik indywidualny kontrahentów o podanym kodzie, tylko dla kontrahentów oznaczonych ABSTORE<>''
::   WE: _a - czy uzywac synchro (opcjonalny 1)
::       _b - KH.ref -> wysyla cennik podanego kontrahenta (gdy parametr _a=0)
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_tabname:='TAP';
_il_rec:=100;
_firma:='';
_repl:=0;
_cnt:=0;
_price:=obj_new('REF','M','OD','DO','CEN','CENB','WAL','KH','GRKH','ABSTORE','PRC','PROMO','RODZ','MGR');
_price.WAL:='PLN';
::tabela do zapisania przetworzonych pozycji z synchro
_tbsync:=tab_tmp(1,'ID','STRING[20]','ID');
_jeden:=0;
{? _useSynchro
||
   TAR.cntx_psh();
   TAR.prefix();
   TAP.cntx_psh();
   TAP.prefix();
   KH.cntx_psh();
   KH.prefix();
    _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
   _kid:='';
   {? _tab.first
   ||
     {! |?
::interesuja nas pozycje cennika kontrahentow oznaczonych ABSTORE<>''
         exec('extract_tr','abstore', {? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?}, _price);
        {?  _tab.RODZ<>'del' & _price.KH<>'' & ((_price.ABSTORE<>'') | (_price.MGR<>''))
        ||
::zapis nagłówka pliku
:: jesli zmiana w cenniku ogolnym _price.RODZ='C' to wysylamy zmiane ceny na produkcie
:: zmiana w grupowym

::            {? _price.RODZ='K' & _price. ||
::sprawdzic czy dla jednego kontrahenta mamy put/add (caly cennik trzeba wyslac) czy tylko put (aktualizacja)
           {? _cnt=0 || _file:=exec('create_msgfile','abstore','cennik_kh') ?};
           {? _price.KH<>_kid
           ||
              {? _cnt>0
              ||
::zakonczenie poprzedniego cennika
                 _xml:='</contractor-price-individual-product-copy>';
                 fwrite(_file, _xml);
                 _cnt:=0
              ?};
                 TAP.use(_tab.REF-8);
                 {? TAP.seek(_tab.REF)
                 ||
                   {? KH.seek(_price.KH)
                   ||
                     _rabatKon:=0.0;
                     {? __AbStore.sumRab || _rabatKon:=exec('get_rabat','abstore',KH.ref) ?};
::_rabatKon:=0.0;
::nie wysylamy przez synchro naglowkow cennikow bo to powoduje usuniecie wszystkich pozycji
::                   _xml:=exec('xml_contractorprice','abstore', 'CK-'+KH.KOD, $KH.ref, 'cennik ' + KH.SKR);
                   _kid:=_price.KH;
::                   fwrite(_file, _xml);
                   _xml:='<contractor-price-individual-product-copy>';
                   fwrite(_file, _xml)
                   ?}
                 ?}
           ?};
           {? KH.seek(_price.KH)
           ||
              TAP.use(_tab.REF-8);
              TAP.seek(_tab.REF);
              {? TAP.MGR<>null
              ||
::wszystkie pozycje z podanej grupy materiałowej
                  _sql:='select M.REFERENCE as REF from M where M.MGR=:_a and '+ exec('m_abstore_sql','abstore');
                  _tabM:=sql(_sql,TAP.MGR);
                  {? _tabM.first
                  ||
                    {! |?
                       _xml:=exec('xml_contractorpriceproduct','abstore', 'CK-'+KH.KOD, _tabM.REF, 0, 0,  {? _price.WAL='' || 'PLN' || _price.WAL ?}, TAP.PRC + _rabatKon);
                      fwrite(_file,maz_utf8(_xml));
                      _tabM.next
                    !}
                  ?};
                  &_tabM
              ||
::pozycje cennika
                 _xml:=exec('xml_contractorpriceproduct','abstore', 'CK-'+KH.KOD, $TAP.M, #gsub(_price.CEN,',','.'),
                       #gsub(_price.CENB,',','.'), {? _price.WAL='' || 'PLN' || _price.WAL ?}, TAP.PRC + _rabatKon);
                 fwrite(_file,maz_utf8(_xml))
              ?}
           ?};
           _cnt:=_cnt + 1;
           _tbsync.ID:=_tab.ID;
           _tbsync.add
        ?};
        _next:=_tab.next
     !}
   ?};
   {? _cnt>0
   ||
::zakonczenie poprzedniego cennika
     _xml:='</contractor-price-individual-product-copy>';
     fwrite(_file, _xml)
   ?};
   TAR.cntx_pop();
   TAP.cntx_pop();
   KH.cntx_pop()
||
::pelny cennik bez synchro
_result:=200;
   TAR.cntx_psh();
   KH.cntx_psh();
   TAR.index('KH');
   TAR.prefix(__AbStore.oddz,'S');
   _jeden:=0;
   {? var_press('_b')<0
   ||
      KH.index('NAZ');
      KH.prefix;
      KH.first
   ||
      KH.prefix;
      KH.seek(_b);
      _jeden:=1
   ?};
   _cnt:=0;
   _file:=exec('create_msgfile','abstore', 'cennik_kh_');
   {! |?
      _oldKH:='';
      {? KH.ABSTORE<>''
      ||
::cennik kontrahenta
         TAR.prefix(__AbStore.oddz, 'S', KH.ref);
         {?   TAR.first
         ||
::jest cennik kontrahenta
::_rabatKon:=0.0;
::petla po wszystkich cennikach kontrahenta
:utworzyc cennik kontrahenta z cenników ogólnych (wpisać rabat kontrahenta)
:na to nałożyć cenniki kontrahenta (nadpisać rabat ceną lub rabatem z nagłówka cennika)

            {! |?
               _rabatKon:=0.0;
               {? __AbStore.sumRab || _rabatKon:=exec('get_rabat','abstore',KH.ref) ?};
::             zapis naglowka cennika jesli zmienil sie kontrahent (cenniki sa grupowane w jeden po kont
               {? KH.KOD<>_oldKH
               ||
::                czy zapisac zakonczenie listy towarow w cenniku
                  {? _oldKH<>''
                  ||
                      _xml:='</contractor-price-individual-product-copy>';
                     fwrite(_file, _xml)
                  ?};
                  _xml:=exec('xml_contractorprice','abstore', 'CK-'+KH.KOD, $KH.ref, 'cennik ' + KH.SKR);
                  fwrite(_file, maz_utf8(_xml));
                  _xml:='<contractor-price-individual-product-copy>';
                  fwrite(_file, _xml);
                  _oldKH:=KH.KOD
               ?};
               _tabCen:=exec('create_tmpzkp','abstore');
               {? TAR.TARB<>''
               ||
::pozycje z cennika bazowego przypisanego do pozycji cennika
                  exec('get_productsfrompricelist','abstore',_tabCen, TAR.TARB, '', '', _rabatKon)
               ?};
::            exec('select','#table',_tabCen);
               exec('get_productsfrompricelist','abstore',_tabCen, $TAR.ref, '', '', _rabatKon);
::            exec('select','#table',_tabCen);
               {? _tabCen.first ||
                  {! |?
                    _xml:=exec('xml_contractorpriceproduct','abstore', 'CK-'+KH.KOD,
                    _tabCen.M, _tabCen.CEN, _tabCen.CENB, 'PLN' , _tabCen.PRC);
                    fwrite(_file, _xml);
                    _cnt:=_cnt + 1;
                    _tabCen.next
                  !}
               ?};
               obj_del(_tabCen);
               TAR.next
            !};
            {? _oldKH<>'' ||
                _xml:='</contractor-price-individual-product-copy>';
               fwrite(_file, _xml)
            ?}
         ||
::kontrahent nie ma cennika indywidualnego ale moze miec rabat w kartotecek
::            _rabatKon:=exec('get_rabat','abstore',KH.ref);
            0
         ?}
      ?};
::petla gdy _b nie jest podany
      {? _jeden || 0 ||  KH.next ?}
   !};
   TAR.cntx_pop();
   KH.cntx_pop()
?};
{? _cnt>0
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'contractor-price-list');
   fclose(_file);
   &_file;
::czyszczenie SYNC
   {? _result=200 & ~_jeden ||
      exec('sync_deltab','abstore',_tbsync); &_tbsync ?}
   ||
      _result:=201
?};
_result


\send_cpricelist2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wysyła cennik indywidualny kontrahentów o podanym kodzie, tylko dla kontrahentów oznaczonych ABSTORE<>''
::   WE: _a - czy uzywac synchro (opcjonalny 1)
::       _b - KH.ref -> wysyla cennik podanego kontrahenta (gdy parametr _a=0)
::       _c - 1 bez sprawdzenia hashy
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_a')=1 || _useSync:=_a || _useSync:=1 ?};
{? var_press('_c')=1 || _hash:=_c || _hash:=0 ?};
_tabname:='TAP';
_il_rec:=100;
_firma:='';
_repl:=0;
_cnt:=0;
_price:=obj_new('REF','M','OD','DO','CEN','CENB','WAL','KH','GRKH','ABSTORE','PRC','PROMO','RODZ','MGR','MGRP','TARB');
::tabela do zapisania przetworzonych pozycji z synchro
_tbsync:=tab_tmp(1,'ID','STRING[20]','ID');
_jeden:=0;
_cur:=exec('currency','abstore');
{? _useSync
||
   TAR.cntx_psh();
   TAR.prefix();
   TAP.cntx_psh();
   TAP.prefix();
   KH.cntx_psh();
   KH.prefix();
    _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
   {? _tab.first
   ||
      {! |?
::interesuja nas pozycje cennika kontrahentow oznaczonych ABSTORE<>''
         exec('extract_tr','abstore', {? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?}, _price);
         {? _cnt=0||{? var_press('_file')>100||obj_del(_file)?};_file:=exec('create_msgfile','abstore','cennik_kh')?};
         {?  _tab.RODZ<>'del' & _price.KH<>'' & ((_price.ABSTORE<>'') | (_price.MGR<>'')) & ('PLN,EUR,USD'*_price.WAL)
         ||
           TAP.use(_tab.REF-8);
           {? TAP.seek(_tab.REF)
           ||
              {? KH.seek(_price.KH)
              ||
                 _rabKon:=0.0;
                 {? __AbStore.sumRab || _rabKon:=exec('get_rabat','abstore',KH.ref) ?};
                 _xml:='<contractor-price-individual-product-copy>';
                 fwrite(_file, _xml);

                 {? TAP.MGR<>null
                 ||
::wszystkie pozycje z podanej grupy materiałowej
                     _sql:='select M.REFERENCE as REF from M %1where M.MGR=''%2'' and '[
                     {? TAP.TARB<>'' || 'join TAP using(M.REFERENCE,TAP.M) ' || '' ?},
                     $TAP.MGR]
                     + exec('m_abstore_sql','abstore');
                     {? TAP.MGRP<>null || _sql+='and M.MGRP=''%1'''[$TAP.MGRP] ?};
                     {? TAP.TARB<>'' || _sql+='and TAP.TAR=''%1'''[TAP.TARB] ?};
                     {? var_press('_tabM')>100 || obj_del(_tabM) ?};
                     _tabM:=sql(_sql);
                     {? _tabM.first
                     ||
                       {! |?
:: sprawdzam czy żadna z pozycji nie nadpisze niczego
                          _sql:='select TAP.M as M, TAP.REFERENCE, TAP.CEN, TAP.CENB, TAP.PRC, SLO.KOD as WAL
                              from TAP join TAR join SLO using(TAP.WAL,SLO.REFERENCE)
                              where TAP.M=''%1''
                              and TAR.KH=''%2''
                              and TAR.SD=''S''
                              and (SLO.KOD=''PLN'' or SLO.KOD=''USD'' or SLO.KOD=''EUR'')
                              and TAR.ODDZ=''%3''
                              and NVL(TAP.OD,CURRENT_DATE)<=CURRENT_DATE
                              and NVL(TAP.DO,CURRENT_DATE)>=CURRENT_DATE'[_tabM.REF, $TAP.TAR().KH, __AbStore.oddz];
                          {? var_press('_testsql')>100 || obj_del(_testsql) ?};
                          _testsql:=sql(_sql);
::sprawdzanie wartości walut
                          {? ~_testsql.first()
                          ||
                             _xml:=exec('xml_contractorpriceproduct','abstore', 'CK-'+KH.KOD, _tabM.REF,
                             #gsub(_price.CEN,',','.'), #gsub(_price.CENB,',','.'),
                             {? _price.WAL=''|(('PLN,EUR,USD'*_price.WAL)=0) || 'PLN' || _price.WAL ?},
                              #gsub(_price.PRC,',','.') + _rabKon);
                             fwrite(_file,maz_utf8(_xml))
                          ?};
                          {? var_press('_testsql')>100 || obj_del(_testsql) ?};
                         _tabM.next
                       !}
                     ?};
                     {? var_press('_tabM')>100 || obj_del(_tabM) ?}
                 ||
::pozycje cennika
                    _sql:='select TAP.M as M, TAP.REFERENCE, TAP.CEN, TAP.CENB, TAP.PRC, SLO.KOD as WAL
                              from TAP join TAR join SLO using(TAP.WAL,SLO.REFERENCE)
                              where TAP.M=''%1''
                              and TAR.P>=''%2''
                              and TAR.KH=''%3''
                              and TAP.CEN<>0
                              and TAR.SD=''S''
                              and (SLO.KOD=''PLN'' or SLO.KOD=''USD'' or SLO.KOD=''EUR'')
                              and TAR.ODDZ=''%4''
                              and NVL(TAP.OD,CURRENT_DATE)<=CURRENT_DATE
                              and NVL(TAP.DO,CURRENT_DATE)>=CURRENT_DATE'
                              [$TAP.M, $TAP.TAR().P, $TAP.TAR().KH, __AbStore.oddz];
                    {? var_press('_testsql')>100 || obj_del(_testsql) ?};
                    _testsql:=sql(_sql);
::sprawdzanie wartości walut
                    {? _testsql.first()
                    ||
                       _war_sql:=0;

                       {!|?
                          {? _testsql.WAL='EUR'
                          || _war_sql:=_testsql.CEN*_cur.PEUR
                          |? _testsql.WAL='USD'
                          || _war_sql:=_testsql.CEN*_cur.PUSD
                          || _war_sql:=_testsql.CEN
                          ?};
                          {? _price.WAL='EUR'
                          || _war_tap:=(#_price.CEN)*_cur.PEUR
                          |? _price.WAL='USD'
                          || _war_tap:=(#_price.CEN)*_cur.PUSD
                          || _war_tap:=(#_price.CEN)
                          ?};
                          {? _war_sql<_war_tap
                          || _price.CEN:=$_testsql.CEN;
                             _price.CENB:=$_testsql.CENB;
                             _price.WAL:=_testsql.WAL;
                             _price.PRC:=$_testsql.PRC
                          ?};
                          _testsql.next()
                       !}
                    ?};
                    _xml:=exec('xml_contractorpriceproduct','abstore', 'CK-'+KH.KOD, $TAP.M, #gsub(_price.CEN,',','.'),
                          #gsub(_price.CENB,',','.'),
                          {? _price.WAL=''|(('PLN,EUR,USD'*_price.WAL)=0)||'PLN'||_price.WAL ?},
                          #gsub(_price.PRC,',','.') + _rabKon);
                    fwrite(_file,maz_utf8(_xml));
                    {? var_press('_testsql')>100 || obj_del(_testsql) ?}
                 ?};
                 _xml:='</contractor-price-individual-product-copy>';
                 fwrite(_file, _xml);
                 _cnt:=_cnt + 1;
                 _tbsync.ID:=_tab.ID;
                 _tbsync.add()
              ?}
           ?}
         |? _tab.RODZ='del' & _price.KH<>'' & ((_price.ABSTORE<>'') | (_price.MGR<>'')) & ('PLN,EUR,USD'*_price.WAL)
         ||
            {? _price.MGR<>''
            ||
::wszystkie pozycje z podanej grupy materiałowej
               _sql:='select M.REFERENCE as REF from M %1where M.MGR=''%2'' and '[
               {? TAP.TARB<>'' || 'join TAP using(M.REFERENCE,TAP.M) ' || '' ?},
               $TAP.MGR]
               + exec('m_abstore_sql','abstore');
               {? _price.MGRP<>'' || _sql+='and M.MGRP=''%1'''[_price.MGRP] ?};
               {? _price.TARB<>'' || _sql+='and TAP.TAR=''%1'''[_price.TARB] ?};
               {? var_press('_tabM')>100 || obj_del(_tabM) ?};
               _tabM:=sql(_sql);
               {? KH.seek(_price.KH) & _tabM.first
               ||
                  {!|?
:: sprawdzam czy żadna z pozycji nie nadpisze niczego
                     _sql:='select TAP.M as M, TAP.REFERENCE, TAP.CEN, TAP.CENB, TAP.PRC, SLO.KOD as WAL
                           from TAP join TAR join SLO using(TAP.WAL,SLO.REFERENCE)
                           where TAP.M=''%1''
                           and TAR.KH=''%2''
                           and TAR.SD=''S''
                           and (SLO.KOD=''PLN'' or SLO.KOD=''USD'' or SLO.KOD=''EUR'')
                           and TAR.ODDZ=''%3''
                           and NVL(TAP.OD,CURRENT_DATE)<=CURRENT_DATE
                           and NVL(TAP.DO,CURRENT_DATE)>=CURRENT_DATE'[_tabM.REF, _price.KH, __AbStore.oddz];
                     {? var_press('_testsql')>100 || obj_del(_testsql) ?};
                     _testsql:=sql(_sql);
::sprawdzanie wartości walut
                     {? ~_testsql.first()
                     ||
                        _cnt:=_cnt + 1;
                        _tbsync.ID:=_tab.ID;
                        _tbsync.add;
                        _xml:=exec('xml_contractorpriceindPdel','abstore', 'CK-'+KH.KOD, _tabM.REF, _price.WAL);
                        fwrite(_file,maz_utf8(_xml))
                     ?};
                     {? var_press('_testsql')>100 || obj_del(_testsql) ?};
                     _tabM.next
                  !}
               ?};
               {? var_press('_tabM')>100 || obj_del(_tabM) ?}
            ||
               {? KH.seek(_price.KH)
               ||
                  _cnt:=_cnt + 1;
                  _tbsync.ID:=_tab.ID;
                  _tbsync.add;
                  _xml:=exec('xml_contractorpriceindPdel','abstore', 'CK-'+KH.KOD, _price.M, _price.WAL);
                  fwrite(_file,maz_utf8(_xml))
               ?}
            ?}
         ?};
         {? _cnt=0 || {? var_press('_file')>100 || {? _file.is_open() || _file.fclose() ?}; obj_del(_file) ?} ?};
         _tab.next
      !}
   ?};
   TAR.cntx_pop();
   TAP.cntx_pop();
   KH.cntx_pop()
||
::pelny cennik bez synchro
_result:=200;
   TAR.cntx_psh();
   KH.cntx_psh();
   TAR.index('KH');
   TAR.prefix(__AbStore.oddz,'S');

   {? ~( var_press('_b')>0 & (KH.prefix;KH.seek(_b)))
   ||
      KH.index('NAZ');
      KH.prefix;
      KH.first
   ||
      _jeden:=1
   ?};
   {! |?
      {? KH.ABSTORE<>''
      ||
         _cnt:=0;
         {? var_press('_file')>100 || obj_del(_file) ?};
         {? var_press('_file_h')>100 || obj_del(_file_h) ?};
         _file:=exec('create_msgfile','abstore', 'cennik_kh_');
::plik bez nagłówka do shashowania
         _file_h:=fopen(null,'bw',,,1);

         _rabatKon:=exec('get_rabat','abstore',KH.ref);
::tworze cennik wirtualny ze wszystkimi towarami ze znacznikiem ABSTORE z cena=0 i rabatem z kartoteki
         _tabCen:=exec('get_virtpricelist','abstore',_rabatKon);
::cennik kontrahenta
         TAR.prefix(__AbStore.oddz, 'S', KH.ref);
         {?   TAR.first()
         ||
::jest cennik kontrahenta
            {? ~__AbStore.sumRab || _rabatKon:=0.0 ?};
::petla po wszystkich cennikach kontrahenta
:utworzyc cennik kontrahenta z cenników ogólnych (wpisać rabat kontrahenta)
:na to nałożyć cenniki kontrahenta (nadpisać rabat ceną lub rabatem z nagłówka cennika)
            {! |?
::             zapis naglowka cennika jesli zmienil sie kontrahent (cenniki sa grupowane w jeden po kont
:               _tabCen:=exec('create_tmpzkp','abstore');
               {? TAR.TARB<>''
               ||
::pozycje z cennika bazowego przypisanego do pozycji cennika
                  exec('get_productsfrompricelist','abstore',_tabCen, TAR.TARB, '', '', _rabatKon)
               ?};
               exec('get_productsfrompricelist','abstore',_tabCen, $TAR.ref, '', '', _rabatKon);
               TAR.next
            !}
::kontrahent nie ma cennika indywidualnego ale moze miec rabat w kartotecek
         ?};
         _xml:=exec('xml_contractorprice','abstore', 'CK-'+KH.KOD, $KH.ref, 'cennik ' + KH.SKR);
         fwrite(_file, maz_utf8(_xml));
         fwrite(_file_h, maz_utf8(_xml));
         _xml:='<contractor-price-individual-product-copy clear-before="true">';
         fwrite(_file, _xml);
         fwrite(_file_h, _xml);
:pozycje cennika
         {? _tabCen.first ||
            {! |?
               SLO.cntx_psh();
               SLO.prefix();
               _wal:={? type_of(_tabCen.WAL)=2 & _tabCen.WAL<>''
                     || {? SLO.seek(_tabCen.WAL) & 'PLN,EUR,USD'*SLO.KOD || SLO.KOD || 'PLN' ?}
                     || 'PLN'
                     ?};
               SLO.cntx_pop();

              {? _tabCen.CEN<>0 | _tabCen.CENB<>0 | _tabCen.PRC<>0
              ||
                 _xml:=exec('xml_contractorpriceproduct','abstore', 'CK-'+KH.KOD,
                 _tabCen.M, _tabCen.CEN, _tabCen.CENB, _wal, _tabCen.PRC);
                 fwrite(_file,maz_utf8(_xml));
                 fwrite(_file_h,maz_utf8(_xml));
                 _cnt:=_cnt + 1
              ?};
              _tabCen.next
            !}
         ?};
         obj_del(_tabCen);
          _xml:='</contractor-price-individual-product-copy>';
         fwrite(_file, _xml);
         fwrite(_file_h, _xml);
         {? _cnt=0
         || _xml:= '<contractor-price-individual-del contractor-price-eid="%1" />'['cprice-CK-'+KH.KOD];
            fwrite(_file, _xml);
            fwrite(_file_h, _xml)
         ?};
         exec('write_filefooter','abstore',_file);
         exec('write_filefooter','abstore',_file_h);
:: sprawdzenie czy komunikat został już wysłany
         {? (exec('kh_hash','abstore','CPL',_file_h) | _hash)
         ||
            _result:=exec('http_send','abstore',_file,'contractor-price-list '+'CK-'+KH.KOD);
            {? _result=200 || exec('kh_hash_put','abstore','CPL',_file_h) ?}
         ?};
         {? _file.is_open() || _file.fclose() ?};
         {? _file_h.is_open() || _file_h.fclose() ?};
         {? var_press('_file')>100 || obj_del(_file) ?};
         {? var_press('_file_h')>100 || obj_del(_file_h) ?}
      ?};
::petla gdy _b nie jest podany
      {? _jeden || 0 ||  KH.next ?}
   !};
   TAR.cntx_pop();
   KH.cntx_pop()
?};
{? _cnt>0 & _useSync
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'contractor-price-list');
   {? _file.is_open() || _file.fclose() ?};
   {? var_press('_file')>100 || obj_del(_file) ?};
::czyszczenie SYNC
   {? _result=200 & ~_jeden ||
      exec('sync_deltab','abstore',_tbsync); &_tbsync ?}
   ||
      _result:=201
?};
_result


\send_defaultoffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: Oferta domyślna dla wszystkich tworzona z listy cenników __AbStore.cennik
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? ~__AbStore.tabMG.first() || return('199') ?};
_result:=200;
_cnt:=0;
_file:=exec('create_msgfile','abstore', 'defaultOffer');
_cnt:=1;
_tbPoz:=exec('get_defaultofferproducts','abstore');
::zapis naglowkow ofert na magazynach
_xml:='';
{! |?
   _magazyn:=__AbStore.tabMG.SYM;
   _kod:='OFERTA-'+_magazyn;
   _xml:=exec('xml_defaultoffer','abstore', _kod, _kod, _magazyn, 1);
   fwrite(_file,maz_utf8(_xml));
   __AbStore.tabMG.next()
!};
::zapis pozycji ofert dla wszystkich magazynow
__AbStore.tabMG.first();
{! |?
   _magazyn:=__AbStore.tabMG.SYM;
   _kod:='OFERTA-'+_magazyn;
   {? _tbPoz.first ||
      _xml:=exec('xml_doffersyncbegin','abstore',_kod);
      fwrite(_file,_xml);
      {! |?
         _xml:=exec('xml_dofferproduct','abstore', _tbPoz.M, _kod, _tbPoz.CEN, _tbPoz.CENB);
         fwrite(_file,maz_utf8(_xml));
         _tbPoz.next
      !};
      _xml:=exec('xml_doffersyncend','abstore');
      fwrite(_file,_xml)
   ?};
   __AbStore.tabMG.next()
!};
&_tbPoz;
{? _cnt>0
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'default-offer');
   fclose(_file);
   &_file
||
    _result:=201
?};
_result


\send_defaultofferall
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: OFERTY DOMYSLNE DLA WSZYSTKICH KONTRAHENTOW/ODDZIALOW
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=200;
_cnt:=0;
_file:=exec('create_msgfile','abstore', 'defaultOffer');
::lista odbiorcow z ustawionym ABSTORE<>''
_sql:='select KH_ODB.REFERENCE as REF, KH_ODB.*, KH.KOD as KH_KOD from KH_ODB
   join KH using(KH.REFERENCE,KH_ODB.KH)
   where KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>''''';
_KH_ODB:=sql(_sql);
::_tbop:=tab_tmp(1,'M','STRING[16]','M','OFFER','STRING[32]','OFFER');
::exec('select','#table',_KH_ODB);
{? _KH_ODB.first ||
   {! |?
         _cnt:=1;
::oferta dla odbiorcy
         _tbPoz:=exec('get_divisionofferproducts','abstore',_KH_ODB.REF,_KH_ODB.KH,0);
::generowanie oferty dla wszystkich magazynow przypisanych do odbiorcy
         _sql:='select KH_ODBMG.ODB as KH_ODB, MG.SYM as MG from KH_ODB
                         join KH_ODBMG using(KH_ODBMG.ODB,KH_ODB.REFERENCE)
                         join MG using(MG.REFERENCE,KH_ODBMG.MG)
                         where KH_ODB.REFERENCE=''%1'' and KH_ODB.ABSTORE<>'''''[_KH_ODB.REF];
         _tabMG:=sql(_sql);
::      exec('select','#table',_tbPoz);
::      exec('select','#table',_tabMG);

::zapis naglowkow ofert na magazynach
         _xml:='';
         {? _tabMG.first ||
            {! |?
               _kod:='DO-'+_KH_ODB.KH_KOD +'-'+_tabMG.MG;
               _xml:=exec('xml_defaultoffer','abstore', _kod, _kod, _tabMG.MG, 0);
               _xml+=exec('xml_contractorsetdoffer','abstore', _kod, _KH_ODB.REF);
               fwrite(_file,maz_utf8(_xml));
               _tabMG.next
            !}
         ?};
::zapis pozycji ofert dla wszystkich magazynow odbiorcy
         {? _tabMG.first ||
            {! |?
               _kod:='DO-'+_KH_ODB.KH_KOD +'-'+_tabMG.MG;
               {? _tbPoz.first ||
                  _xml:=exec('xml_doffersyncbegin','abstore',_kod);
                  fwrite(_file,_xml);
                  {! |?
                     _xml:=exec('xml_dofferproduct','abstore', _tbPoz.M, _kod, _tbPoz.CEN, _tbPoz.CENB);
                     fwrite(_file,maz_utf8(_xml));
                     _tbPoz.next
                  !};
                  _xml:=exec('xml_doffersyncend','abstore');
                  fwrite(_file,_xml)
               ?};
               _tabMG.next
            !}
         ?};
         &_tbPoz;
         &_tabMG;
      _KH_ODB.next
   !}
?};
{? _cnt>0
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'default-offer');
   fclose(_file);
   &_file
::czyszczenie SYNC
::   {? _result=200 || exec('sync_deltab','abstore',_tbsync); &_tbsync ?}
||
    _result:=201
?};
_result


\send_pofferreverse
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: OFERTY DEDYKOWANE DLA WSZYSTKICH KONTRAHENTOW/ODDZIALOW
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=200;
PROMO.prefix;
_cnt:=0;
_file:=exec('create_msgfile','abstore', 'personalOffer');
::lista odbiorcow z ustawionym ABSTORE<>''
_sql:='select KH_ODB.REFERENCE as REF, KH_ODB.*, KH.KOD as KH_KOD from KH_ODB
   join KH using(KH.REFERENCE,KH_ODB.KH)
   where KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>''''';
_KH_ODB:=sql(_sql);
::_tbop:=tab_tmp(1,'M','STRING[16]','M','OFFER','STRING[32]','OFFER');
::exec('select','#table',_KH_ODB);
{? _KH_ODB.first ||
   {! |?
         _tag:='PO-'+_KH_ODB.REF;
         _cnt:=1;
::oferta dla odbiorcy
         _tbPoz:=exec('get_divisionofferproducts','abstore',_KH_ODB.REF,_KH_ODB.KH,1);
::generowanie oferty dla wszystkich magazynow przypisanych do odbiorcy
         _sql:='select KH_ODBMG.ODB as KH_ODB, MG.SYM as MG from KH_ODB
                         join KH_ODBMG using(KH_ODBMG.ODB,KH_ODB.REFERENCE)
                         join MG using(MG.REFERENCE,KH_ODBMG.MG)
                         where KH_ODB.REFERENCE=''%1'' and KH_ODB.ABSTORE<>'''''[_KH_ODB.REF];
         _tabMG:=sql(_sql);
::      exec('select','#table',_tbPoz);
::      exec('select','#table',_tabMG);

        _tbO:=sql('select distinct A.PROMO from :_a A order by 1',_tbPoz);
::zapis naglowkow ofert na magazynach
         _xml:='';
         {? _tbO.first ||
            {! |?
               {? _tabMG.first ||
                  {! |?
                     PROMO.seek(_tbO.PROMO);
                     _nazwa:=PROMO.O;
                     _kod:='PO-'+ PROMO.KOD +'-'+_KH_ODB.KH_KOD +'-'+_tabMG.MG;
                     _xml:=exec('xml_personaloffer','abstore', _kod,_nazwa,_tabMG.MG, _KH_ODB.REF,_tag);
                     fwrite(_file,maz_utf8(_xml));
                     _tabMG.next
                  !}
               ?};
               _tbO.next
            !}
         ?};
         _tbPoz1:=sql('select * from :_a A order by PROMO',_tbPoz);
::         exec('select','#table',_tbPoz1);
::zapis pozycji ofert dla wszystkich magazynow odbiorcy
         {? _tabMG.first ||
            _xml:=exec('xml_poffersyncbegin','abstore',_KH_ODB.REF,_tag);
            fwrite(_file,_xml);
            {! |?
               _pkod:='';

               {? _tbPoz1.first ||
                  {! |?
                     {? _pkod<>_kod ||
                        PROMO.seek(_tbPoz1.PROMO);
                        _kod:='PO-'+ PROMO.KOD +'-'+_KH_ODB.KH_KOD +'-'+_tabMG.MG
                     ?};

                     _xml:=exec('xml_pofferproduct','abstore',_KH_ODB.REF, _tbPoz1.M, _kod, 0, _tbPoz1.CENB);
::                     _xml:=exec('xml_pofferproduct','abstore',_KH_ODB.KH_KOD, _tbPoz1.M, _kod, _tbPoz1.CEN, _tbPoz1.CENB);
                     fwrite(_file,maz_utf8(_xml));
                     _tbPoz1.next
                  !}
               ?};
               _tabMG.next
            !};
            _xml:=exec('xml_poffersyncend','abstore');
            fwrite(_file,_xml)
         ?};
         &_tbPoz;
         &_tabMG;
         &_tbPoz1;
         &_tbO;
      _KH_ODB.next
   !}
?};
{? _cnt>0
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'default-offer');
   fclose(_file);
   &_file
::czyszczenie SYNC
::   {? _result=200 || exec('sync_deltab','abstore',_tbsync); &_tbsync ?}
||
    _result:=201
?};
_result


\send_poffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: OFERTY DEDYKOWANE DLA WSZYSTKICH KONTRAHENTOW/ODDZIAŁÓW na podstawie cenników indywidualnych
::   WE: _b - 1 bez sprawdzenia hashy
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_b')=1 || _hash:=_b || _hash:=0 ?};
TAR.cntx_psh();
_result:=200;
::lista odbiorcow z ustawionym ABSTORE<>''
_sql:='select KH_ODB.REFERENCE as REF, KH_ODB.*, KH.KOD as KH_KOD, KH.REFERENCE as KH_REF, KH.STR_OFE as OFE from KH_ODB
   join KH using(KH.REFERENCE,KH_ODB.KH)
   where KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>''''
   and ((KH.STR_OFE='''' and (\':_a\'='''' or \':_a\'=''PMAG_PIND_BKLI''
   or \':_a\'=''PMAG_OIND_BKLI'')) or KH.STR_OFE=''PMAG_PIND_BKLI'' or KH.STR_OFE=''PMAG_OIND_BKLI'')';
_KH_ODB:=sql(_sql,__AbStore.strOfe);
{? _KH_ODB.first()
||
   {! |?
         _cnt:=0;
         {? var_press('_file')>0 || &_file ?};
         {? var_press('_file_h')>0 || &_file_h ?};
         _file:=exec('create_msgfile','abstore', 'personalOffer');
::plik bez nagłówka do shashowania
         _file_h:=fopen(null,'bw',,,1);

         _tag:=_KH_ODB.KH_KOD;
::generowanie oferty dla wszystkich magazynow przypisanych do odbiorcy
         _sql:='select KH_ODBMG.ODB as KH_ODB, MG.SYM as MG from KH_ODB
                         join KH_ODBMG using(KH_ODBMG.ODB,KH_ODB.REFERENCE)
                         join MG using(MG.REFERENCE,KH_ODBMG.MG)
                         join :_a X using(X.SYM,MG.SYM)
                         where KH_ODB.REFERENCE=''%1'' and KH_ODB.ABSTORE<>'''''[_KH_ODB.REF];
         _tabMG:=sql(_sql,__AbStore.tabMG);
         _tbO:=exec('get_divisionofferlist','abstore',_KH_ODB.REF,_KH_ODB.KH);

:         exec('select','#table',_tbPoz);
::      exec('select','#table',_tabMG);
::zapis naglowkow ofert na magazynach
         _xml:='';
         {? _tbO.first() & _tabMG.size()>0
         ||
            {! |?
               _tabMG.first();
               {! |?
                  _nazwa:=_tbO.NAZ;
                  _kod:='PO-'+_tbO.KOD+'-'+_KH_ODB.KH_KOD+'-'+_KH_ODB.KOD+'-'+_tabMG.MG;
                  {? exec('delspace','abstore',_nazwa)='' || _nazwa:=_kod ?};
                  _xml:=exec('xml_personaloffer','abstore', _kod,_nazwa,_tabMG.MG, _KH_ODB.REF,_tag);
                  fwrite(_file,maz_utf8(_xml));
                  fwrite(_file_h,maz_utf8(_xml));
                  _tabMG.next()
               !};
               _tbO.next()
            !}
         ?};
::         _tbPoz1:=exec('get_productsfrompricelist','abstore', ,,,,,,)  sql('select * from :_a A order by KOD',_tbPoz);
::         exec('select','#table',_tbPoz1);
::zapis pozycji ofert dla wszystkich magazynow odbiorcy
         TAR.prefix();
         {? _tbO.first() & _tabMG.size()>0
         ||
            _xml:=exec('xml_poffersyncbegin','abstore',_KH_ODB.REF,_tag);
            fwrite(_file,_xml);
            fwrite(_file_h,_xml);
            {! |?
               {? var_press('_tbPoz')>0 || &_tbPoz ?};
               _tbPoz:=exec('create_tmpzkp','abstore');
               TAR.seek(_tbO.REF);
               {? TAR.TARB<>''
               ||
                  exec('get_productsfrompricelist','abstore',_tbPoz, TAR.TARB, '', '', 0, 0, '', _KH_ODB.OFE)
               ?};
               exec('get_productsfrompricelist','abstore',_tbPoz, $TAR.ref, '', '', 0, 0, _KH_ODB.OFE);
               {? _tabMG.first()
               ||
                  {! |?
                     {? _tbPoz.first()
                     ||
                        _cnt:=_cnt+1;
                        {! |?
                           _kod:='PO-'+_tbO.KOD+'-'+_KH_ODB.KH_KOD+'-'+_KH_ODB.KOD+'-'+_tabMG.MG;
                           _xml:=exec('xml_pofferproduct','abstore',_KH_ODB.REF, _tbPoz.M, _kod, 0, _tbPoz.CENB);
::                     _xml:=exec('xml_pofferproduct','abstore',_KH_ODB.KH_KOD, _tbPoz1.M, _kod, _tbPoz1.CEN, _tbPoz1.CENB);
                           fwrite(_file,maz_utf8(_xml));
                           fwrite(_file_h,maz_utf8(_xml));
                           _tbPoz.next()
                        !}
                     ?};
                     _tabMG.next()
                  !}
               ?};
               _tbO.next()
            !};
            _xml:=exec('xml_poffersyncend','abstore');
            fwrite(_file,_xml);
            fwrite(_file_h,_xml)
         ?};
         &_tbO;
         &_tabMG;
         exec('write_filefooter','abstore',_file);
         exec('write_filefooter','abstore',_file_h);
:: sprawdzenie czy komunikat został już wysłany
         KH.cntx_psh();
         KH.index('KOD');
         KH.prefix(2,_KH_ODB.KH_KOD,);
         {? KH.first() & _cnt>0 & (exec('kh_hash','abstore',_KH_ODB.REF,_file_h) | _hash)
         ||
            _result:=exec('http_send','abstore',_file,'default-offer '+_kod);
            {? _result=200 || exec('kh_hash_put','abstore',_KH_ODB.REF,_file_h) ?}
         ?};
         KH.cntx_pop();
         fclose(_file);
         fclose(_file_h);
         &_file;
         &_file_h;
         _KH_ODB.next()
   !}
?};
TAR.cntx_pop();
_result


\send_poffermerge
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: jedna oferta dedykowana dla kazdego kontrahenta utworzona ze wszystkich jego cennikow
::   _a - ref kontrahenta (opcjonalny)
::   _b - 1 bez sprawdzenia hashy
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_b')=1 || _hash:=_b || _hash:=0 ?};
_result:=200;
::lista odbiorcow z ustawionym ABSTORE<>''
_sql:='select KH_ODB.REFERENCE as REF, KH_ODB.*, KH.KOD as KH_KOD from KH_ODB
   join KH using(KH.REFERENCE,KH_ODB.KH)
   where KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>''''
   and ((KH.STR_OFE='''' and (\':_a\'='''' or \':_a\'=''PMAG_PIND_BKLI'' or
   \':_a\'=''PMAG_OIND_BKLI'')) or KH.STR_OFE=''PMAG_PIND_BKLI'' or KH.STR_OFE=''PMAG_OIND_BKLI'')';
{? var_press('_a')=2 || _sql+=' and KH.REFERENCE=\'%1\' '[_a] ?};
_KH_ODB:=sql(_sql,__AbStore.strOfe);
{? _KH_ODB.first() ||
   {!|?
         _cnt:=0;
         {? var_press('_file')>0 || &_file ?};
         {? var_press('_file_h')>0 || &_file_h ?};
         _file:=exec('create_msgfile','abstore', 'personalOffer');
::plik bez nagłówka do shashowania
         _file_h:=fopen(null,'bw',,,1);
::oferta dla odbiorcy
         _tbPoz:=exec('get_divisionofferproducts','abstore',_KH_ODB.REF,_KH_ODB.KH,0,1);
::generowanie oferty dla wszystkich magazynow przypisanych do odbiorcy
         _sql:='select KH_ODBMG.ODB as KH_ODB, MG.SYM as MG from KH_ODB
                         join KH_ODBMG using(KH_ODBMG.ODB,KH_ODB.REFERENCE)
                         join MG using(MG.REFERENCE,KH_ODBMG.MG)
                         join :_a X using(X.SYM,MG.SYM)
                         where KH_ODB.REFERENCE=''%1'' and KH_ODB.ABSTORE<>'''''[_KH_ODB.REF];
         _tabMG:=sql(_sql,__AbStore.tabMG);
::      exec('select','#table',_tbPoz);
::zapis naglowkow ofert na magazynach
         _xml:='';
         {? _tabMG.first
         ||
            {! |?
               _nazwa:='OFERTA DEDYKOWANA';
               _kod:='PO-'+_KH_ODB.KH_KOD+'-'+_KH_ODB.KOD+'-'+_tabMG.MG;
               _xml:=exec('xml_personaloffer','abstore', _kod,_nazwa,_tabMG.MG, _KH_ODB.REF,_kod);
               fwrite(_file,maz_utf8(_xml));
               fwrite(_file_h,maz_utf8(_xml));
               _tabMG.next()
            !}
         ?};
::zapis pozycji ofert dla wszystkich magazynow odbiorcy
         {? _tabMG.first()
         ||
            {! |?
               _kod:='PO-'+_KH_ODB.KH_KOD+'-'+_KH_ODB.KOD+'-'+_tabMG.MG;
               _xml:=exec('xml_poffersyncbegin','abstore',_KH_ODB.REF,_kod);
               fwrite(_file,maz_utf8(_xml));
               fwrite(_file_h,maz_utf8(_xml));
               _pkod:='';
               {? _tbPoz.first() ||
                  {! |?
                     _cnt+=1;
                     _xml:=exec('xml_pofferproduct','abstore',_KH_ODB.REF, _tbPoz.M, _kod, 0, _tbPoz.CENB);
                     fwrite(_file,maz_utf8(_xml));
                     fwrite(_file_h,maz_utf8(_xml));
                     _tbPoz.next()
                  !}
               ?};
               _xml:=exec('xml_poffersyncend','abstore');
               fwrite(_file,_xml);
               fwrite(_file_h,_xml);
               _tabMG.next()
            !}
         ?};
         &_tbPoz;
         &_tabMG;
         exec('write_filefooter','abstore',_file);
         exec('write_filefooter','abstore',_file_h);
:: sprawdzenie czy komunikat został już wysłany
         KH.cntx_psh();
         KH.index('KOD');
         KH.prefix(2,_KH_ODB.KH_KOD,);
         {? KH.first() & _cnt>0 & (exec('kh_hash','abstore',_KH_ODB.REF,_file_h) | _hash)
         ||
            _result:=exec('http_send','abstore',_file,'default-offer '+_kod);
            {? _result=200 || exec('kh_hash_put','abstore',_KH_ODB.REF,_file_h) ?}
         ?};
         KH.cntx_pop();
         fclose(_file);
         fclose(_file_h);
         &_file;
         &_file_h;
        _KH_ODB.next()
   !}
?};
_result


\get_divisionofferproducts
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: oferta domyslna oddzialu kontrahenta poskladana ze wszystkich cennikow indywidualnych kontrahenta/oddzialu
::   WE: _a - $KH_ODB.ref
::       _b - $KH.ref
::       _c - tylko promocyjne pozycje (0)
::       _d - strategia oferty
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_c')<0 || _c:=0 ?};
{? var_press('_d')<0 || _d:=0 ?};
_tar:=exec('get_divisionofferlist','abstore',_a,_b);
_tabCen:=exec('create_tmpzkp','abstore');
KH.cntx_psh();
KH.prefix();
_wyn:={? KH.seek(_b) || KH.STR_OFE || '' ?};
KH.cntx_pop();
{? _tar.first ||
   {! |?
      {? _tar.TARB<>'' ||
::pozycje z cennika bazowego przypisanego do pozycji cennika
         exec('get_productsfrompricelist','abstore',_tabCen, _tar.TARB, '', '', _tar.PRC, _c,'',_wyn)
      ?};
      exec('get_productsfrompricelist','abstore',_tabCen, _tar.REF, '', '', _tar.PRC, _c,'',_wyn);
      _tar.next
   !}
?};
{? _wyn='BMAG_BIND_PKLI' | (_wyn='' & __AbStore.strOfe='BMAG_BIND_PKLI')
||
   {? ~__AbStore.tabCen.first() || return('199') ?};
   _sql:='select TAR.REFERENCE as REF, TAR.* from TAR
          join :_a C using(C.KOD,TAR.KOD)
          where TAR.KH is null and TAR.GRKH is null
          order by TAR.P';
   _tar_d:=sql(_sql,__AbStore.tabCen);
   {? _tar_d.first ||
      {! |?
         {? _tar_d.TARB<>'' ||
::pozycje z cennika bazowego przypisanego do pozycji cennika
            exec('get_productsfrompricelist','abstore',_tabCen, _tar_d.TARB, '', '', _tar_d.PRC, _c,'',_wyn)
         ?};
         exec('get_productsfrompricelist','abstore',_tabCen, _tar_d.REF, '', '', _tar_d.PRC, _c,'',_wyn);
         _tar_d.next
      !}
   ?}
?};
_tabCen


\get_divisionofferlist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: lista ofert dedykowanych oddziału/kontrahent na podst. cenników indywidualnych
::   WE: _a - KH_ODB.ref
::       _b - KH.ref
::   WY: -tabela tymczasowa
::----------------------------------------------------------------------------------------------------------------------
_sql:='select TAR.REFERENCE as REF, TAR.* from TAR
       where NVL(TAR.KH_ODB,'':_a'')='':_a''
       and TAR.KH='':_b''
       and TAR.ODDZ='':_c''
       order by TAR.P';
_tab:=sql(_sql,_a,_b,__AbStore.oddz);
_tab


\get_defaultofferproducts
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: lista pozycji oferty domyślnej budowanej z cenników ogólnych o podanych symbolach __AbStore.cennik
::   WY: tabela tymczasowa
::----------------------------------------------------------------------------------------------------------------------
{? ~__AbStore.tabCen.first() || return('199') ?};
{? var_press('_c')<0 || _c:=0 ?};
_sql:='select TAR.REFERENCE as REF, TAR.* from TAR
       join :_a C using(C.KOD,TAR.KOD)
       where TAR.KH is null and TAR.GRKH is null
       order by TAR.P';
_tar:=sql(_sql,__AbStore.tabCen);
::exec('select','#table',_tar);
_tabCen:=exec('create_tmpzkp','abstore');
{? _tar.first ||
   {! |?
      {? _tar.TARB<>'' ||
::pozycje z cennika bazowego przypisanego do pozycji cennika
         exec('get_productsfrompricelist','abstore',_tabCen, _tar.TARB, '', '', _tar.PRC, _c)
      ?};
      exec('get_productsfrompricelist','abstore',_tabCen, _tar.REF, '', '', _tar.PRC, _c);
      _tar.next
   !}
?};
_tabCen


\rec2obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: zamienia rekord na obiekt i doklada pole REF
::   WE: _a - akronim tabeli
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_str:='_obj:=obj_new(';
{! _idx:=1..obj_len(_a) |!
   {? _idx>1 || _str:=_str+',' ?};
   _str:=_str+''''+_a.fld_acr(_idx)+''''
!};
_str:=_str+', ''ref''); _obj';
_obj:=($(_str))();
{! _idx:=1..obj_len(_a) |!
    ($('_a.%1:=_b'[_a.fld_acr(_idx)]))(_obj,($('_a.%1'[_a.fld_acr(_idx)]))(_a))
!};
($('_a.ref:=_b.ref()'))(_obj,_a);
_obj


\tostring
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: zamienia podaną wartość na stringa
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? type_of(_a)<>2 || $_a || _a ?}


\xml_poffersyncbegin
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: początek komunikatu
::   WE: _a - id oddziału kontrahenta
::       _b - tag
::       _c - [0] - sync-strategy DEFAULT, 1 - SKIP-ABSENT
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_c')<0 || _c:=0 ?};
_syncStrategy:=exec('get_syncstrategy','abstore',_c);
_xml:='<personal-offer-contractor-synchronize contractor-eid="%1" tag="%2" %3>'[exec('tostring','abstore',_a),_b,_syncStrategy];
_xml


\xml_poffersyncend
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: koniec komunikatu
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='</personal-offer-contractor-synchronize>';
_xml


\xml_doffersyncbegin
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: początek komunikatu synchronizacji pozycji ofert (jesli tag jest podany to mozna oferty pojedynczo przesylac)
::   WE: _a - tag (opcjonalny)
::       _b - [0] - sync-strategy DEFAULT, 1 - SKIP-ABSENT
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_b')<0 || _b:=0 ?};
_syncStrategy:=exec('get_syncstrategy','abstore',_b);
{? var_press('_a')>=0 || _tag:='tag="%1"'[_a] || _tag:='' ?};
_xml:='<default-offer-synchronize %1 %2>'[_tag, _syncStrategy];
_xml


\get_syncstrategy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_a')<0 || _a:=0 ?};
_syncStrategy:='';
{? _a=1 || _syncStrategy:='sync-strategy="SKIP-ABSENT"' ?};
_syncStrategy


\xml_doffersyncend
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: koniec komunikatu
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='</default-offer-synchronize>';
_xml


\sendContractorPriceListV2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:  wysyła cenniki kontrahenta/oddzialu
::----------------------------------------------------------------------------------------------------------------------
_tabN:=sql('select TAR.KOD as TAR_KOD, TAR.OD, TAR.DO, TAR.KH_ODB, TAR.KH, TAR.KH_ODB, MG.SYM as MG, TAR.REFERENCE as REF
               from TAR
join KH using (KH.REFERENCE, TAR.KH)
left join KH_ODB using(TAR.KH_ODB, KH_ODB.REFERENCE)
left join KH_ODBMG using(KH_ODBMG.ODB, KH_ODB.REFERENCE)
left join MG using (MG.REFERENCE, KH_ODBMG.MG)
where KH_ODB is null  or KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>''''');
::exec('select','#table',_tabN);
::naglowki ofert
_tab:=tab_tmp(1,'KOD','STRING[30]', 'KOD', 'ODB','STRING[30]','ODB', 'MG','STRING[10]','MG', 'REF','STRING[30]','REF');
_idx:=_tab.ndx_tmp('',0,'KOD',,0);
_file:=exec('create_msgfile','abstore','dOffer');
::exec('select','#table',_tabN);
{? _tabN.first() ||
   {! |?
       {? _tabN.KH_ODB='' ||
::wypelnic tabtmp oddzialami kontrahenta
         {? var_press('_tabOdb')>=0 || &_tabOdb ?};
         _sql:='select KH_ODBMG.ODB as KH_ODB, MG.SYM as MG from KH_ODB
                         join KH_ODBMG using(KH_ODBMG.ODB,KH_ODB.REFERENCE)
                         join MG using(MG.REFERENCE,KH_ODBMG.MG)
                         where KH_ODB.KH=''%1'' and KH_ODB.ABSTORE<>'''''[_tabN.KH];
         _tabOdb:=sql(_sql);
         {? _tabOdb.first() ||
            {! |?
                _tab.blank();
                _tab.KOD:=_tabN.TAR_KOD;
                _tab.MG:=_tabOdb.MG;
                _tab.ODB:=_tabOdb.KH_ODB;
                _tab.REF:=_tabN.REF;
                _tab.add;
                _tabOdb.next()
            !}
         ?}
       ||
          _tab.blank();
          _tab.KOD:=_tabN.TAR_KOD;
          _tab.MG:=_tabN.MG;
          _tab.ODB:=_tabN.KH_ODB;
          _tab.REF:=_tabN.REF;
          _tab.add
       ?};
       _tabN.next()
   !}
?};
::exec('select','#table',_tab);
::_tab zawiera liste cennik, oddzial, magazyn - dla kazdej pozycji trzeba zalozyc naglowki i wyslac towary
_tabN.first();
::zakladamy naglowki cennikow
::_tab.index('KOD');
_xml:='';
_tab.index(_idx);
{! |?
   {? _tabN.KH_ODB='' ||
::trzeba utworzyc oferty we wszystkich magazynach, w ktorych wystepuja odbiorcy kontrahenta
      _tab.prefix(_tabN.TAR_KOD);
      _tab.first();
::      exec('select','#table',_tab,,,'_tab');
      _popMG:='';
      {? _tab.first() ||
         {! |?
::jesli kilku odbiorcow korzysta z tego samego magazynu to oferte tworzymy tylko raz
            {? _popMG<>_tab.MG ||
               _xml+=exec('xml_defaultoffer','abstore',_tabN, _tab.MG, 0);
               _popMG:=_tab.MG
            ?};
            _xml+=exec('xml_contractorsetdoffer','abstore',_tabN.TAR_KOD+'-'+_tab.MG,_tab.ODB);
            _tab.next()
         !}
      ?}
   ||
::oferta powiazana z jednym konkretnym odbiorca
      _xml+=exec('xml_defaultoffer','abstore',_tabN, _tabN.MG, 0);
      _xml+=exec('xml_contractorsetdoffer','abstore',_tabN.TAR_KOD+'-'+_tabN.MG,_tabN.KH_ODB)
   ?};
   _tabN.next()
!};
fwrite(_file,maz_utf8(_xml));
::TODO: oferty dedykowane dla kontrahentow

::oferta domyslna dla wszystkich odbiorcow
_xml:=exec('xml_defaultofferheader','abstore');
fwrite(_file,maz_utf8(_xml));
_xml:='';
_xml+=exec('xml_doffersyncbegin','abstore');
fwrite(_file,_xml);
   _magazyny:=exec('magazyny','abs_conf');
   _idx:=1;
   {! |?
      _magazyn:=_magazyny[_idx];
      exec('xml_dofferproducts','abstore',_file, __AbStore.defaultOffer +'-'+ _magazyn);
      _idx+=1;
      _idx<=obj_len(_magazyny)
   !};
_xml:='';
_cnt:=0;
TAP.index('TM');
_tab.prefix;
_tab.first();
{? _tab.first() ||
   {! |?
      TAR.prefix;
      TAR.seek(_tab.REF);
      _tarRef:=TAR.ref();
      TAP.prefix(_tarRef);
::      TAP.prefix(_tab.REF);
      {? TAP.first() ||
         {! |?
             {? (__AbStore.useStore=1 & TAP.M().ABSTORE<>'') | (__AbStore.useStore=0 & TAP.M().ABSTOREC<>'') ||
               {? TAP.WAL=null || _wal:='PLN' || _wal:=TAP.WAL().KOD ?};
               _xml:=exec('xml_dofferproduct','abstore', '', TAP.M, _tab.KOD+'-'+_tab.MG, gsub($TAP.CEN,',','.'), gsub($TAP.CENB,',','.'), _wal);
::        _xml:=_xml+%13+%10 + exec(_b+'OfferSyncEnd','abstore');
               _xml+=%13+%10;
               fwrite(_file,maz_utf8(_xml));
              _cnt:=_cnt + 1
             ?};
             TAP.next()
         !}
      ?};
::dolaczamy oferte standardowa (cennik ogolny)
      _xml:=exec('xml_dofferproducts','abstore',_file, _tab.KOD+'-'+_tab.MG);
      _tab.next()
   !};
   _xml:=exec('xml_doffersyncend','abstore');
   fwrite(_file,_xml)
?};
{? _cnt>0
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'personal_offer');
   fclose(_file);
   &_file
::czyszczenie SYNC
::   {? _result=200 || exec('sync_deltab','abstore',_tbsync); &_tbsync ?}
||
    _result:=201
?};
_result


\sendOfferV2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:  wysyła cenniki indywidualne jako oferty (default-offer)
::----------------------------------------------------------------------------------------------------------------------
_tabN:=sql('select TAR.KOD as TAR_KOD, TAR.OD, TAR.DO, TAR.KH_ODB, TAR.KH, MG.SYM as MG, TAR.REFERENCE as REF
               from TAR
join KH using (KH.REFERENCE, TAR.KH)
left join KH_ODB using(TAR.KH_ODB, KH_ODB.REFERENCE)
left join KH_ODBMG using(KH_ODBMG.ODB, KH_ODB.REFERENCE)
left join MG using (MG.REFERENCE, KH_ODBMG.MG)
where (KH_ODB is null  or (KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>''''))
and TAR.NAZ=''''');
::exec('select','#table',_tabN);
::naglowki ofert
_tab:=tab_tmp(1,'KOD','STRING[30]', 'KOD', 'ODB','STRING[30]','ODB', 'MG','STRING[10]','MG', 'REF','STRING[30]','REF');
_idx:=_tab.ndx_tmp('',0,'KOD',,0);
_file:=exec('create_msgfile','abstore','dOffer');
::exec('select','#table',_tabN);
{? _tabN.first() ||
{! |?
    {? _tabN.KH_ODB='' ||
::wypelnic tabtmp oddzialami kontrahenta
      {? var_press('_tabOdb')>=0 || &_tabOdb ?};
      _sql:='select KH_ODBMG.ODB as KH_ODB, MG.SYM as MG from KH_ODB
          oł0             join KH_ODBMG using(KH_ODBMG.ODB,KH_ODB.REFERENCE)
             /         join MG using(MG.REFERENCE,KH_ODBMG.MG)
                      where KH_ODB.KH=''%1'' and KH_ODB.ABSTORE<>'''''[_tabN.KH];
      _tabOdb:=sql(_sql);
      {? _tabOdb.first() ||
         {! |?
             _tab.blank();
             _tab.KOD:=_tabN.TAR_KOD;
             _tab.MG:=_tabOdb.MG;
             _tab.ODB:=_tabOdb.KH_ODB;
             _tab.REF:=_tabN.REF;
             _tab.add;
             _tabOdb.next()
         !}
      ?}
    ||
       _tab.blank();
       _tab.KOD:=_tabN.TAR_KOD;
       _tab.MG:=_tabN.MG;
       _tab.ODB:=_tabN.KH_ODB;
       _tab.REF:=_tabN.REF;
       _tab.add
    ?};
    _tabN.next()
!}
?};
::exec('select','#table',_tab);
::_tab zawiera liste cennik, oddzial, magazyn - dla kazdej pozycji trzeba zalozyc naglowki i wyslac towary
_tabN.first();
::zakladamy naglowki cennikow
::_tab.index('KOD');
_xml:='';
_tab.index(_idx);
{! |?
   {? _tabN.KH_ODB='' ||
::trzeba utworzyc oferty we wszystkich magazynach, w ktorych wystepuja odbiorcy kontrahenta
      _tab.prefix(_tabN.TAR_KOD);
      _tab.first();
::      exec('select','#table',_tab,,,'_tab');
      _popMG:='';
      {? _tab.first() ||
         {! |?
::jesli kilku odbiorcow korzysta z tego samego magazynu to oferte tworzymy tylko raz
            {? _popMG<>_tab.MG ||
               _xml+=exec('xml_defaultoffer','abstore',_tabN, _tab.MG, 0);
               _popMG:=_tab.MG
            ?};
            _xml+=exec('xml_contractorsetdoffer','abstore',_tabN.TAR_KOD+'-'+_tab.MG,_tab.ODB);
            _tab.next()
         !}
      ?}
   ||
::oferta powiazana z jednym konkretnym odbiorca
      _xml+=exec('xml_defaultoffer','abstore',_tabN, _tabN.MG, 0);
      _xml+=exec('xml_contractorsetdoffer','abstore',_tabN.TAR_KOD+'-'+_tabN.MG,_tabN.KH_ODB)
   ?};
   _tabN.next()
!};
fwrite(_file,maz_utf8(_xml));

::oferta domyslna dla wszystkich odbiorcow
_xml:=exec('xml_defaultofferheader','abstore');
fwrite(_file,maz_utf8(_xml));
_xml:='';
_xml+=exec('xml_doffersyncbegin','abstore');
fwrite(_file,_xml);
_magazyny:=exec('magazyny','abs_conf');
_idx:=1;
{! |?
   _magazyn:=_magazyny[_idx];
   exec('xml_dofferproducts','abstore',_file, __AbStore.defaultOffer +'-'+ _magazyn);
   _idx+=1;
   _idx<=obj_len(_magazyny)
!};
_xml:='';
_cnt:=0;
TAP.index('TM');
_tab.prefix;
_tab.first();
{? var_press('_tabCennik')>=0 || &_tabCennik; &_idxCennik ?};
_tabCennik:=tab_tmp(1,'M','STRING[32]','M');
_idxCennik:=_tabCennik.ndx_tmp('',0,'M',,0);
_tabCennik.index(_idxCennik);
{? _tab.first() ||
{! |?
   TAR.prefix;
   TAR.seek(_tab.REF);
   _tarRef:=TAR.ref();
   TAP.prefix(_tarRef);
::      TAP.prefix(_tab.REF);
   {? TAP.first() ||
      {! |?
          {? (__AbStore.useStore=1 & TAP.M().ABSTORE<>'') | (__AbStore.useStore=0 & TAP.M().ABSTOREC<>'') ||
            {? TAP.WAL=null || _wal:='PLN' || _wal:=TAP.WAL().KOD ?};
            _xml:=exec('xml_dofferproduct','abstore', '', TAP.M, _tab.KOD+'-'+_tab.MG, gsub($TAP.CEN,',','.'), gsub($TAP.CENB,',','.'), _wal);
::        _xml:=_xml+%13+%10 + exec(_b+'OfferSyncEnd','abstore');
            _xml+=%13+%10;
            _tabCennik.blank();
            _tabCennik.M:=$TAP.M;
            _tabCennik.add(1);
            fwrite(_file,maz_utf8(_xml));
           _cnt:=_cnt + 1
          ?};
          TAP.next()
      !}
   ?};
::dolaczamy oferte standardowa (cennik ogolny)
   _xml:=exec('xml_dofferproducts','abstore',_file, _tab.KOD+'-'+_tab.MG, _tabCennik);
   _tab.next()
!};
_xml:=exec('xml_doffersyncend','abstore');
fwrite(_file,_xml)
?};
{? _cnt>0
||
exec('write_filefooter','abstore',_file);
_result:=exec('http_send','abstore',_file,'personal_offer');
fclose(_file);
&_file
::czyszczenie SYNC
::   {? _result=200 || exec('sync_deltab','abstore',_tbsync); &_tbsync ?}
||
 _result:=201
?};
_result


\sendOfferV3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:  wysyła cenniki indywidualne jako oferty (default-offer)
::----------------------------------------------------------------------------------------------------------------------
_tabN:=sql('select TAR.KOD as TAR_KOD, TAR.OD, TAR.DO, TAR.KH_ODB, TAR.KH, MG.SYM as MG, TAR.TARB, TAR.REFERENCE as REF
            from TAR
join KH using (KH.REFERENCE, TAR.KH)
left join KH_ODB using(TAR.KH_ODB, KH_ODB.REFERENCE)
left join KH_ODBMG using(KH_ODBMG.ODB, KH_ODB.REFERENCE)
left join MG using (MG.REFERENCE, KH_ODBMG.MG)
where (KH_ODB is null  or (KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>''''))
and NVL(TAR.TARB,'''')<>''''');
::exec('select','#table',_tabN);
::naglowki ofert
_tab:=tab_tmp(1,'KOD','STRING[30]', 'KOD',
             'ODB','STRING[30]','ODB',
             'MG','STRING[10]','MG',
             'REF','STRING[30]','REF',
             'TARB','STRING[16]','TARB',
             'KH', 'STRING[16]', 'KH');
_idx:=_tab.ndx_tmp('',0,'KOD',,0);
_file:=exec('create_msgfile','abstore','dOffer');
::exec('select','#table',_tabN);
{? _tabN.first() ||
{! |?
    {? _tabN.KH_ODB='' ||
::wypelnic tabtmp oddzialami kontrahenta
      {? var_press('_tabOdb')>=0 || &_tabOdb ?};
      _sql:='select KH_ODBMG.ODB as KH_ODB, MG.SYM as MG from KH_ODB
                      join KH_ODBMG using(KH_ODBMG.ODB,KH_ODB.REFERENCE)
                      join MG using(MG.REFERENCE,KH_ODBMG.MG)
                      where KH_ODB.KH=''%1'' and KH_ODB.ABSTORE<>'''''[_tabN.KH];
      _tabOdb:=sql(_sql);
      {? _tabOdb.first() ||
         {! |?
             _tab.blank();
             _tab.KOD:=_tabN.TAR_KOD;
             _tab.MG:=_tabOdb.MG;
             _tab.ODB:=_tabOdb.KH_ODB;
             _tab.REF:=_tabN.REF;
             _tab.TARB:=_tabN.TARB;
             _tab.KH:=_tabN.KH;
             _tab.add;
             _tabOdb.next()
         !}
      ?}
    ||
       _tab.blank();
       _tab.KOD:=_tabN.TAR_KOD;
       _tab.MG:=_tabN.MG;
       _tab.ODB:=_tabN.KH_ODB;
       _tab.REF:=_tabN.REF;
       _tab.TARB:=_tabN.TARB;
       _tab.KH:=_tabN.KH;
       _tab.add
    ?};
    _tabN.next()
!}
?};
::exec('select','#table',_tab);
::_tab zawiera liste cennik, oddzial, magazyn - dla kazdej pozycji trzeba zalozyc naglowki i wyslac towary
_tabN.first();
::zakladamy naglowki cennikow
::_tab.index('KOD');
_xml:='';
_tab.index(_idx);
::KH_ODB.index('KH_ODB')
{! |?
{? _tabN.KH_ODB='' ||
::trzeba utworzyc oferty we wszystkich magazynach, w ktorych wystepuja odbiorcy kontrahenta
   _tab.prefix(_tabN.TAR_KOD);
   _tab.first();
::      exec('select','#table',_tab,,,'_tab');
   _popMG:='';
   {? _tab.first() ||
      {! |?
::jesli kilku odbiorcow korzysta z tego samego magazynu to oferte tworzymy tylko raz
         {? _popMG<>_tab.MG ||
            _xml+=exec('xml_defaultoffer','abstore',_tabN, _tab.MG, 0);
            _popMG:=_tab.MG
         ?};
         _xml+=exec('xml_contractorsetdoffer','abstore',_tabN.TAR_KOD+'-'+_tab.MG,_tab.ODB);
         _tab.next()
      !}
   ?}
||
::oferta powiazana z jednym konkretnym odbiorca
   _xml+=exec('xml_defaultoffer','abstore',_tabN, _tabN.MG, 0);
   _xml+=exec('xml_contractorsetdoffer','abstore',_tabN.TAR_KOD+'-'+_tabN.MG,_tabN.KH_ODB)
?};
_tabN.next()
!};
fwrite(_file,maz_utf8(_xml));

::oferta domyslna dla wszystkich odbiorcow
_xml:=exec('xml_defaultofferheader','abstore');
fwrite(_file,maz_utf8(_xml));
_xml:='';
_xml+=exec('xml_doffersyncbegin','abstore');
fwrite(_file,_xml);
_magazyny:=exec('magazyny','abs_conf');
_idx:=1;
{! |?
   _magazyn:=_magazyny[_idx];
   exec('xml_dofferproducts','abstore',_file,  __AbStore.defaultOffer +'-'+ _magazyn);
   _idx+=1;
   _idx<=obj_len(_magazyny)
!};
_xml:='';
_cnt:=0;
TAP.index('TM');
_tab.prefix;
_tab.first();
{? var_press('_tabCennik')>=0 || &_tabCennik; &_idxCennik ?};
_tabCennik:=tab_tmp(1,'M','STRING[32]','M');
_idxCennik:=_tabCennik.ndx_tmp('',0,'M',,0);
_tabCennik.index(_idxCennik);
{? _tab.first() ||
{! |?
   TAR.prefix;
   TAR.seek(_tab.REF);
   _tarRef:=TAR.ref();
   TAP.prefix(_tarRef);
::      TAP.prefix(_tab.REF);
   {? TAP.first() ||
      {! |?
          {? (__AbStore.useStore=1 & TAP.M().ABSTORE<>'') | (__AbStore.useStore=0 & TAP.M().ABSTOREC<>'') ||
            {? TAP.WAL=null || _wal:='PLN' || _wal:=TAP.WAL().KOD ?};
            _xml:=exec('xml_dofferproduct','abstore', '', TAP.M, _tab.KOD+'-'+_tab.MG, gsub($TAP.CEN,',','.'), gsub($TAP.CENB,',','.'), _wal);
::        _xml:=_xml+%13+%10 + exec(_b+'OfferSyncEnd','abstore');
            _xml+=%13+%10;
            _tabCennik.blank();
            _tabCennik.M:=$TAP.M;
            _tabCennik.add(1);
            fwrite(_file,maz_utf8(_xml));
           _cnt:=_cnt + 1
          ?};
          TAP.next()
      !}
   ?};
::dolaczamy oferte standardowa (cennik ogolny)
::petla do testowania wydajnosci
{! x:=1 .. 1 |!
   _xml:=exec('baseOfferProducts','abstore',_file, _tab.TARB, _tabCennik, _tab.KOD+'-'+_tab.MG)
!};
::dolaczamy pozycje ze wszystkich ofert dedykowanych oddzialu lub kontrahenta
::   _sql:='select TAP.M, TAP.OD, TAP.DO, TAP.CEN, TAP.CENB  from TAP
::   join TAR using(TAR.REFERENCE,TAP.TAR)
::   join M using (M.REFERENCE,TAP.M)
::   where TAR.TARB='''' and '+ exec('m_abstore_sql','abstore') +'
::   and ((TAR.KH_ODB is null and TAR.KH=:_a) or (TAR.KH_ODB=:_b))';
::   _tabDed:=sql(_sql,_tab.KH, _tab.KH_ODB);
::   exec('select','#table',_tabDed);
   _tab.next()
!};
_xml:=exec('xml_doffersyncend','abstore');
fwrite(_file,_xml)
?};
{? _cnt>0
||
exec('write_filefooter','abstore',_file);
_result:=exec('http_send','abstore',_file,'personal_offer');
fclose(_file);
&_file
::czyszczenie SYNC
::   {? _result=200 || exec('sync_deltab','abstore',_tbsync); &_tbsync ?}
||
 _result:=201
?};
_result


\xml_defaultofferheader
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:
::   WE:
::   WY: xml naglowek oferty domyslnej
::----------------------------------------------------------------------------------------------------------------------
_tabN:=sql('select TAR.KOD as TAR_KOD, TAR.REFERENCE as REF
         from TAR where TAR.KOD='':_a''',__AbStore.defaultOffer);
::exec('select','#table',_tabN);
::naglowki ofert
_tab:=tab_tmp(1,'KOD','STRING[30]', 'KOD', 'ODB','STRING[30]','ODB', 'MG','STRING[10]','MG', 'REF','STRING[30]','REF');
_xml:='';
_magazyny:=exec('magazyny','abs_conf');
_idx:=1;
{! |?
   _magazyn:=_magazyny[_idx];
   _xml+=%13+%10+ exec('xml_defaultoffer','abstore', _tabN, _magazyn,1);
   _idx+=1;
   _idx<=obj_len(_magazyny)
!};
::_xml+=exec('xml_defaultoffer','abstore',_tabN, '',1);
::{? _tabN.first() ||
::_magazyny:=exec('magazyny','abs_conf');
::_idx:=1;
::   {! |?
::      _magazyn:=_magazyny[_idx];
::      _xml+=exec('xml_defaultoffer','abstore',_tabN, _tab.MG,1);
::      _idx+=1;
::      _idx<=obj_len(_magazyny)
::   !}
::?};
_xml


\xml_dofferproducts
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
::   WE: _a - uchwyt do pliku do zapisu pozycji oferty
::       _b - kod cennika (opcjonalny, jesli nie podany to wysylany jest kod __AbStore.defaultOffer)
::       _c - tabela z towarami do pominiecia ( pola: M string[20]) opcjonalna
:: OPIS: wysyla oferte domyslna dla wszystkich kontrahentow na wszystkie magazyny z konfiguracji
::----------------------------------------------------------------------------------------------------------------------
::_xml+=exec('xml_doffersyncbegin','abstore');
TAP.cntx_psh();
TAR.cntx_psh();
TAR.prefix;
TAR.index('KOD');
TAR.prefix(__AbStore.oddz,'S',__AbStore.defaultOffer);
TAR.first();
_file:=_a;
_xml:='';
_cnt:=0;
::{? var_press('_c')>=0 ||
::   exec('select','#table',_c)
::?};
TAP.index('TM');
TAP.prefix(TAR.ref);
{? TAP.first() ||
{! |?
    {? (__AbStore.useStore=1 & TAP.M().ABSTORE<>'') | (__AbStore.useStore=0 & TAP.M().ABSTOREC<>'') ||
      {? TAP.WAL=null || _wal:='PLN' || _wal:=TAP.WAL().KOD ?};
      _flag:=1;
      {? var_press('_c')>=0 ||
        {? _c.find_key($TAP.M) || _flag:=0 ?}
::            _c.prefix($TAP.M);
::            {? _c.first || _flag:=0 ?}
      ?};
      {? _flag=1 ||
         {? var_press('_b')<0 ||
            _xml:=exec('xml_dofferproduct','abstore', '', TAP.M, TAR.KOD, gsub($TAP.CEN,',','.'), gsub($TAP.CENB,',','.'), _wal)
         ||
            _xml:=exec('xml_dofferproduct','abstore', '', TAP.M, _b, gsub($TAP.CEN,',','.'), gsub($TAP.CENB,',','.'), _wal)
         ?}
      ?};
      _xml+=%13+%10;
      fwrite(_file,maz_utf8(_xml));
     _cnt:=_cnt + 1
    ?};
    TAP.next()
!}
?};
TAP.cntx_pop();
TAR.cntx_pop()


\baseOfferProducts
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
::   WE: _a - uchwyt do pliku do zapisu pozycji oferty
::       _b - kod cennika bazowego
::       _c - tabela z towarami do pominiecia ( pola: M string[20]) opcjonalna
::       _d - kod cennika kontrahenta
:: OPIS: wysyla oferte domyslna dla wszystkich kontrahentow na wszystkie magazyny z konfiguracji
::----------------------------------------------------------------------------------------------------------------------
::_xml+=exec('xml_doffersyncbegin','abstore');
TAP.cntx_psh();
TAR.cntx_psh();
TAR.prefix;
TAR.seek(_b);
::exec('','#table')
::TAR.index('KOD');
::TAR.prefix(__AbStore.oddz,'S',_b);
::TAR.first();
_file:=_a;
_xml:='';
_cnt:=0;
TAP.index('TM');
TAP.prefix(TAR.ref);
{? TAP.first()
||
   {! |?
       {? (__AbStore.useStore=1 & TAP.M().ABSTORE<>'') | (__AbStore.useStore=0 & TAP.M().ABSTOREC<>'') ||
         {? TAP.WAL=null || _wal:='PLN' || _wal:=TAP.WAL().KOD ?};
         _flag:=1;
         {? var_press('_c')>=0 ||
           {? _c.find_key($TAP.M) || _flag:=0 ?}
         ?};
         {? _flag=1 ||
               _xml:=exec('xml_dofferproduct','abstore', '', TAP.M, _d, gsub($TAP.CEN,',','.'), gsub($TAP.CENB,',','.'), _wal)
         ?};
         _xml+=%13+%10;
         fwrite(_file, _xml);
        _cnt:=_cnt + 1
       ?};
       TAP.next()
   !}
?};
TAP.cntx_pop();
TAR.cntx_pop()


\send_grouppricelist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wysyła cennik grupowy, tylko dla grup kontrahentów i towarów oznaczonych ABSTORE<>''
::   WE: _a - czy uzywac synchro (1)
::       _b - GRKH.ref -> wysyla cennik podanego kontrahenta (gdy parametr _a=0)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_a')=1 || _useSync:=_a || _useSync:=1 ?};
_tabname:='TAP';
_il_rec:=100;
_firma:='';
_repl:=0;
_cnt:=0;
_jeden:=0;
_cur:=exec('currency','abstore');
_price:=obj_new('REF','M','OD','DO','CEN','CENB','WAL','KH','GRKH','ABSTORE','PRC','PROMO','RODZ','MGR','MGRP','TARB');
::tabela do zapisania przetworzonych pozycji z synchro
_tbsync:=tab_tmp(1,'ID','STRING[20]','ID');
{? _useSync
||
   TAR.cntx_psh();
   TAR.prefix();
   TAP.cntx_psh();
   TAP.prefix();
   GRKH.cntx_psh();
   GRKH.prefix();
    _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
   {? _tab.first
   ||
      {!|?
::zapis nagłówka pliku
         {? _cnt=0 || {? var_press('_file')>0 || &_file ?};_file:=exec('create_msgfile','abstore','cennik_grkh') ?};
         exec('extract_tr','abstore', {? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?}, _price);
         {? _tab.RODZ<>'del' & _price.GRKH<>'' & _price.ABSTORE<>'' & ('PLN,EUR,USD'*_price.WAL)
         ||
            TAP.use(_tab.REF-8);
            {? TAP.seek(_tab.REF) & GRKH.seek(_price.GRKH)
            ||
               _xml:='<contractor-price-group-product-copy>';
               fwrite(_file,maz_utf8(_xml));

               {? TAP.MGR<>null
               ||
::wszystkie pozycje z podanej grupy materiałowej
                  _sql:='select M.REFERENCE as REF from M %1where M.MGR=''%2'' and '[
                  {? TAP.TARB<>'' || 'join TAP using(M.REFERENCE,TAP.M)' || '' ?},
                  $TAP.MGR]
                  + exec('m_abstore_sql','abstore');
                  {? TAP.MGRP<>null || _sql+='and M.MGRP=''%1'''[$TAP.MGRP] ?};
                  {? TAP.TARB<>'' || _sql+='and TAP.TAR=''%1'''[TAP.TARB] ?};
                  {? var_press('_tabM')>100 || obj_del(_tabM) ?};
                  _tabM:=sql(_sql);
                  {? _tabM.first
                  ||
                     {!|?
:: sprawdzam czy żadna z pozycji nie nadpisze niczego
                        _sql:='select TAP.M as M, TAP.REFERENCE, TAP.CEN, TAP.CENB, TAP.PRC, SLO.KOD as WAL
                              from TAP join TAR join SLO using(TAP.WAL,SLO.REFERENCE)
                              where TAP.M=''%1''
                              and TAR.GRKH=''%2''
                              and TAR.SD=''S''
                              and (SLO.KOD=''PLN'' or SLO.KOD=''USD'' or SLO.KOD=''EUR'')
                              and NVL(TAP.OD,CURRENT_DATE)<=CURRENT_DATE
                              and NVL(TAP.DO,CURRENT_DATE)>=CURRENT_DATE'[_tabM.REF, $TAP.TAR().GRKH];
                        {? var_press('_testsql')>100 || obj_del(_testsql) ?};
                        _testsql:=sql(_sql);
::sprawdzanie wartości walut
                        {? ~_testsql.first()
                        ||
                           _gr_d:=exec('group_discount','abstore');
                           _xml:=exec('xml_contpricegroupproduct','abstore','cpg-'+GRKH.KOD, _tabM.REF,
                           #gsub(_price.CEN,',','.'), #gsub(_price.CENB,',','.'),
                           {?_price.WAL=''|(('PLN,EUR,USD'*_price.WAL)=0) || 'PLN' || _price.WAL ?},
                           #gsub(_price.PRC,',','.')+_gr_d);
                           fwrite(_file,maz_utf8(_xml))
                        ?};
                        {? var_press('_testsql')>100 || obj_del(_testsql) ?};
                        _tabM.next
                     !}
                  ?};
                  {? var_press('_tabM')>100 || obj_del(_tabM) ?}
               ||
                  _sql:='select TAP.REFERENCE, TAP.CEN, TAP.CENB, TAP.PRC, SLO.KOD as WAL
                                  from TAP join TAR join SLO using(TAP.WAL,SLO.REFERENCE)
                                  where TAP.M=''%1''
                                  and TAR.P>=''%2''
                                  and TAR.GRKH=''%3''
                                  and TAP.CEN<>0
                                  and TAR.SD=''S''
                                  and (SLO.KOD=''PLN'' or SLO.KOD=''USD'' or SLO.KOD=''EUR'')
                                  and NVL(TAP.OD,CURRENT_DATE)<=CURRENT_DATE
                                  and NVL(TAP.DO,CURRENT_DATE)>=CURRENT_DATE'[$TAP.M, $TAP.TAR().P, $TAP.TAR().GRKH];
                  {? var_press('_testsql')>100 || obj_del(_testsql) ?};
                  _testsql:=sql(_sql);
                  {? _testsql.first()
                  ||
                     _war_sql:=0;
                     {!|?
                        {? _testsql.WAL='EUR'
                        || _war_sql:=_testsql.CEN*_cur.PEUR
                        |? _testsql.WAL='USD'
                        || _war_sql:=_testsql.CEN*_cur.PUSD
                        || _war_sql:=_testsql.CEN
                        ?};
                        {? _price.WAL='EUR'
                        || _war_tap:=(#_price.CEN)*_cur.PEUR
                        |? _price.WAL='USD'
                        || _war_tap:=(#_price.CEN)*_cur.PUSD
                        || _war_tap:=(#_price.CEN)
                        ?};
                        {? _war_sql<_war_tap
                        || _price.CEN:=$_testsql.CEN;
                           _price.CENB:=$_testsql.CENB;
                           _price.WAL:=_testsql.WAL;
                           _price.PRC:=$_testsql.PRC
                        ?};
                        _testsql.next()
                     !}
                  ?};
                  {? var_press('_testsql')>100 || obj_del(_testsql) ?};
                  _gr_d:=exec('group_discount','abstore');
                  _xml:=exec('xml_contpricegroupproduct','abstore','cpg-'+GRKH.KOD, _price.M, #gsub(_price.CEN,',','.'),
                  #gsub(_price.CENB,',','.'),
                  {?_price.WAL=''|(('PLN,EUR,USD'*_price.WAL)=0) || 'PLN' || _price.WAL ?},
                  #gsub(_price.PRC,',','.') + _gr_d);
                  fwrite(_file,maz_utf8(_xml))
               ?};
               _xml:='</contractor-price-group-product-copy>';
               fwrite(_file, maz_utf8(_xml));
               _cnt:=_cnt + 1;
               _tbsync.ID:=_tab.ID;
               _tbsync.add
            ?}
         |? _tab.RODZ='del' & _price.GRKH<>'' & _price.ABSTORE<>'' & ('PLN,EUR,USD'*_price.WAL)
         ||
            {? _price.MGR<>''
            ||
::wszystkie pozycje z podanej grupy materiałowej
               _sql:='select M.REFERENCE as REF from M %1where M.MGR=''%2'' and '[
               {? _price.TARB<>'' || 'join TAP using(M.REFERENCE,TAP.M)' || '' ?},
               _price.MGR]
               + exec('m_abstore_sql','abstore');
               {? _price.MGRP<>'' || _sql+='and M.MGRP=''%1'''[_price.MGRP] ?};
               {? _price.TARB<>'' || _sql+='and TAP.TAR=''%1'''[_price.TARB] ?};
               {? var_press('_tabM')>100 || obj_del(_tabM) ?};
               _tabM:=sql(_sql);
               {? GRKH.seek(_price.GRKH) & _tabM.first
               ||
                  {!|?
:: sprawdzam czy żadna z pozycji nie nadpisze niczego
                     _sql:='select TAP.M as M, TAP.REFERENCE, TAP.CEN, TAP.CENB, TAP.PRC, SLO.KOD as WAL
                           from TAP join TAR join SLO using(TAP.WAL,SLO.REFERENCE)
                           where TAP.M=''%1''
                           and TAR.GRKH=''%2''
                           and TAR.SD=''S''
                           and (SLO.KOD=''PLN'' or SLO.KOD=''USD'' or SLO.KOD=''EUR'')
                           and NVL(TAP.OD,CURRENT_DATE)<=CURRENT_DATE
                           and NVL(TAP.DO,CURRENT_DATE)>=CURRENT_DATE'[_tabM.REF, _price.GRKH];
                     {? var_press('_testsql')>100 || obj_del(_testsql) ?};
                     _testsql:=sql(_sql);
::sprawdzanie wartości walut
                     {? ~_testsql.first()
                     ||
                        _cnt:=_cnt + 1;
                        _tbsync.ID:=_tab.ID;
                        _tbsync.add;
                        _xml:=exec('xml_contractorpriceGPdel','abstore', 'cpg-'+GRKH.KOD, _tabM.REF, _price.WAL);
                        fwrite(_file,maz_utf8(_xml))
                     ?};
                     {? var_press('_testsql')>100 || obj_del(_testsql) ?};
                     _tabM.next
                  !}
               ?};
               {? var_press('_tabM')>100 || obj_del(_tabM) ?}
            ||
               {? GRKH.seek(_price.GRKH)
               ||
                  _cnt:=_cnt + 1;
                  _tbsync.ID:=_tab.ID;
                  _tbsync.add;
                  _xml:=exec('xml_contractorpriceGPdel','abstore', 'cpg-'+GRKH.KOD, _price.M, _price.WAL);
                  fwrite(_file,maz_utf8(_xml))
               ?}
            ?}
         ?};
         _next:=_tab.next
      !}
   ?};
   TAR.cntx_pop();
   TAP.cntx_pop();
   GRKH.cntx_pop()
||
::bez synchro pełne dane
:pelny cennik bez synchro
_result:=200;
   TAR.cntx_psh();
   GRKH.cntx_psh();
   TAR.index('GRKH');
   TAR.prefix(__AbStore.oddz,'S');

   {? ~( var_press('_b')>0 & (GRKH.prefix;GRKH.seek(_b)))
   ||
      GRKH.index('NAZ');
      GRKH.prefix;
      GRKH.first()
   ||
      _jeden:=1
   ?};
   {! |?
      {? GRKH.ABSTORE<>''
      ||
         _cnt:=0;
         {? var_press('_file')>100 || obj_del(_file) ?};
         _file:=exec('create_msgfile','abstore', 'cennik_grkh');
::tworze cennik wirtualny ze wszystkimi towarami ze znacznikiem ABSTORE z cena=0 i rabatem z kartoteki
         _gr_d:=exec('group_discount','abstore');
         {? var_press('_tabCen')>100 || obj_del(_tabCen) ?};
         _tabCen:=exec('get_virtpricelist','abstore',_gr_d);
::cennik grup kontrahenta
         TAR.prefix(__AbStore.oddz, 'S', GRKH.ref);
         {?   TAR.first()
         ||
::petla po wszystkich cennikach kontrahenta, utworzyc cennik grup kontrahenta z cenników ogólnych
:na to nałożyć cenniki grup kontrahenta (nadpisać rabat ceną lub rabatem z nagłówka cennika)
            {! |?
               {? TAR.TARB<>''
               ||
::pozycje z cennika bazowego przypisanego do pozycji cennika
                  exec('get_productsfrompricelist','abstore',_tabCen, TAR.TARB, '', '', _gr_d)
               ?};
               exec('get_productsfrompricelist','abstore',_tabCen, $TAR.ref, '', '', _gr_d);
               TAR.next
            !}
::kontrahent nie ma cennika indywidualnego ale moze miec rabat w kartotecek
         ?};
         _xml:=exec('xml_contractorpricegroup','abstore', GRKH.KOD, 'cennik gr. ' + GRKH.KOD);
         fwrite(_file, maz_utf8(_xml));
         _xml:='<contractor-price-group-product-copy clear-before="true">';
         fwrite(_file, _xml);
:pozycje cennika
         {? _tabCen.first()
         ||
            {! |?
               SLO.cntx_psh();
               SLO.prefix();
               _wal:={? type_of(_tabCen.WAL)=2 & _tabCen.WAL<>''
                     || {? SLO.seek(_tabCen.WAL) & 'PLN,EUR,USD'*SLO.KOD || SLO.KOD || 'PLN' ?}
                     || 'PLN'
                     ?};
               SLO.cntx_pop();

               {? _tabCen.CEN<>0 | _tabCen.CENB<>0 | _tabCen.PRC<>0
               ||
                 _xml:=exec('xml_contpricegroupproduct','abstore','cpg-'+GRKH.KOD, _tabCen.M,
                      _tabCen.CEN, _tabCen.CENB, _wal, _tabCen.PRC );
                 fwrite(_file,maz_utf8(_xml));
                 _cnt:=_cnt + 1
              ?};
              _tabCen.next
            !}
         ?};
         {? var_press('_tabCen')>100 || obj_del(_tabCen) ?};
         _xml:='</contractor-price-group-product-copy>';
         fwrite(_file, _xml);
         {? _cnt=0
         || _xml:= '<contractor-price-group-del contractor-price-eid="%1" />'['cpg-'+GRKH.KOD];
            fwrite(_file, _xml)
         ?};
         exec('write_filefooter','abstore',_file);
         _result:=exec('http_send','abstore',_file,'CG-'+GRKH.KOD);
         {? _file.is_open() || _file.fclose() ?};
         {? var_press('_file')>100 || obj_del(_file) ?}
      ?};
::petla gdy _b nie jest podany
      {? _jeden || 0 ||  GRKH.next ?}
   !};
   TAR.cntx_pop();
   GRKH.cntx_pop()
?};
{? _cnt>0 & _useSync
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'contractor-plg');
   {? _file.is_open() || _file.fclose() ?};
   {? var_press('_file')>100 || obj_del(_file) ?};
::czyszczenie SYNC
   {? _result=200 & ~_jeden
   ||
      exec('sync_deltab','abstore',_tbsync); &_tbsync
   ?}
||
   _result:=201
?};
_result


\send_units
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wysyla jednostki miary. poniewaz w merit precyzja jest ustawiana na kartotece
::       to przy jednostce musi być wysłana max. używana w kartotekach precyzja
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_tabname:='JM';
_il_rec:=100;
_firma:='';
_repl:=0;
_message:=exec('xml_messageheader','abstore');
_cnt:=0;
{? _useSynchro ||
   _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
   {? _tab.first()
   ||
     _rodz:=_tab.RODZ;
     JM.cntx_psh();
     JM.prefix();
     {! |?
         {? JM.seek(_tab.REF)
         ||
           _mpart:=exec('xml_unit','abstore', JM);
           _message:=_message + _mpart + %13 + %10;
           _cnt:=_cnt + 1
         ?};
        _tab.next()
     !};
     JM.cntx_pop()
   ?};
   _message:=_message + exec('xml_messagefooter','abstore')
||
::bez synchro
   _TMPJM:=sql('select JM.REFERENCE REF, JM.NAZ, JM.KOD from JM');
   {? _TMPJM.first()
   ||
      {! |?
          _cnt:=_cnt + 1;
          _mpart:=exec('xml_unit','abstore', _TMPJM);
          _message:=_message + _mpart + %13 + %10;
          _TMPJM.next()
      !}
   ?};
   _message:=_message + exec('xml_messagefooter','abstore')
?};
{? _cnt>0
||
   _result:=exec('http_send','abstore',_message,'units');
   {? _result=200 & _useSynchro || exec('clear_sync','abstore',_tab.ID, _tabname) ?}
||
    _result:=201
?};
_result


\http_send
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wysyła plik lub stringa postem i zapisuje w logu (jeśli podane parametry _b / _c)
::   WE: _a - plik lub string do wysłania (lub '' bez zapisu pliku w blobie)
::       _b - opis do logu
::       _c - czy zapisywać plik w logu - domyślnie 1
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:return(200);
{? __AbStore.configOk=0
||
   exec('log_write','abstore','','Nieprawidłowa konfiguracja',0);
   return(-1)
?};
::return(200);
{? _<3 || _c:=1 ?};
_proxy:='';
:: Tryb cichy poza transakcją
{? do_state()=0 || _do:=0; _no_msg:=no_msg(1) || _do:=1 ?};
_http:=inet_get(__AbStore.url);
{? _do=0 || no_msg(_no_msg) ?};

{? type_of(_http)<100
||
   exec('log_write','abstore','','Błąd wywołania funkcji %1.'['inet_get()'],0);
   return(-1)
?};

:: ścieżka do pliku z certyfikatem
{? sys_name(1)='U_LINUX'
|| _pem:='ssl_abs.pem';
   _cert:=pth_dir(_pem)+'/'+_pem
|| _cert:=''
?};
::    ścieżka do pliku z certyfikatami
{? _cert<>'' || _http.set_cert_path(_cert) ?};
_http.set_authentication(__AbStore.user,__AbStore.pass);
_http.append_header('Content-Type: text/html');
_utc_start:=utc_get();
_http.http_post(,_a);
_utc_stop:=utc_get();
_res:=_http.get_status();
exec('log_write_new','abstore', {? _c=1 || _a || '' ?} , _b, $_res, _http, _utc_start, _utc_stop );
_res


\log_write_new
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.37]
:: OPIS:  zapis pliku / zawartości zmiennej w logu
::   WE: _a - plik (obiekt) / string ( może być '' )
::       _b - opis do logu
::       _c - status
::       _d - obiekt INET
::       _e - _utc_start
::       _f - _utc_stop
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_mwac_log_ref:=exec('mwac_log','zui',
   _b,
   __AbStore.url,
   'SOAP',
   _d.get_status(),
   _e,
   _f,
   _a,
   '',
   _d.get_header(1),
   ''
);

{? _mwac_log_ref<>''
|| exec('mwac_log_app','zui',_mwac_log_ref,'|%1|'[__AbStore.configName],'')
?};
~~


\log_write
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS:  zapis pliku / zawartości zmiennej w logu
::   WE: _a - plik (obiekt) / string ( może być '' )
::       _b - opis do logu
::       _c - status
::   WY:
::----------------------------------------------------------------------------------------------------------------------
WSLOG.blank();
WSLOG.DATA:=date();
WSLOG.CZAS:=time();
WSLOG.OPIS:=_b;
WSLOG.STATUS:={? type_of(_c)=2 || _c || $_c ?};
WSLOG.KONFIG:=__AbStore.configName;
{? type_of(_a)=type_of('')
||
   {? _a<>''
   ||
:: zapis stringa do pliku
      _plik:='request.xml';
      _file:=fopen(_plik,'bw',1,,1);
      {? ~_file.is_open || exec('log_write','abstore','', 'błąd otwarcia pliku',-1); return ?};
      fwrite(_file,_a)
   ?}
||
   _file:=_a
?};
WSLOG.add;
{? var_press('_file')>0 || WSLOG.bl_put('LOG',_file,,,'request.xml') ?};
~~


\send_uni
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS:  Uniwersalna funkcja do wysyłania danych z tabeli
::   WE:
::       _a - funkcja generujaca xml (np. contractorGroupXml)
::       _b - tabela  (np. GRKH)
::       _c - [0] = wszystkie rekordy,  1= tylko aktualny rekord
::       _d - warunek na wiersz
::   WY: generuje plik o nazwie _a i wysyła do abstora z logowaniem w WSLOG
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_c')<0 | type_of(_c)=0 || _c:=0 ?};
{? var_press('_d')<0 || _fn:='1' || _fn:=_d ?};
_result:=($('_cnt:=0;
_a.cntx_psh();
{? _a.first
||
   {! |?
      {? _cnt=0 || _file:=exec(''create_msgfile'',''abstore'',''%1'') ?};
      _cnt+=1;
      {? ($(_b))(_a) ||
         _xmlpart:=exec(''%1'',''abstore'', _a);
         fwrite(_file, maz_utf8(_xmlpart))
      ?};
      {? %2 || 0 || _a.next() ?}
   !};
   {? _cnt >0 ||
      exec(''write_filefooter'',''abstore'',_file);
      _result:=exec(''http_send'',''abstore'',_file,''%1'');
      fclose(_file);
      &_file
   ?}
||
   _result:=201
?};
_a.cntx_pop();
_result
'[_b,$_c]))(_a,_fn);
_result


\send_division
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: tworzy oddzialy kontrahenta wg KH_ODB
::   WE: KH ustawiony na kontekst kontrahenta
::   WY: 200/201 - lub kod błędu
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
{? _useSynchro ||
   _fields:=obj_new('ref','NAZ');
   _genXml:='xml_division';
   _delXml:='';
   _result:=exec('send_unisync','abstore','KH_ODB',_fields,_genXml,_delXml,1,1,0,1);
   {? _result=200 & __AbStore.tabRef.size()>0
   ||
      {? __AbStore.tabRef.first()
      ||
         {! |?
            exec('send_divisionstore','abstore',0,__AbStore.tabRef.REF);
            __AbStore.tabRef.del()
         !}
      ?}
   ?}

||
   _sql:='select KH_OSOBO.REFERENCE as REF, KH_OSOBO.* from KH_ODB
              join KH using(KH.REFERENCE,KH_OSOBO.KH)
              where KH.ABSTORE<>'''' and KH_ODB.ABSTORE<>''''';
   _tab:=sql(_sql);
   _result:=exec('send_uni','abstore', _tab, 'xml_division')
?};
_result


\SDiviSto_sync
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.37]
:: OPIS: wysyła powiązania odbiorcy(oddziału) z magazynem
::   WE: _a - czy uzywac synchro (1)
::       _b - (opcjonalnie) KH_ODB.ref - oddziału dla którego powiązania mają zostać wysłane
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSync:=_a || _useSync:=1 ?};
_result:=200;
{? _useSync
||
   _il_rec:=100;
   _firma:='';
   _repl:=0;
   _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, 'KH_ODBMG', _il_rec, _firma, _repl);
   _fields:=obj_new('ref','ODB','MG');
   {? _tab.first
   ||
      {!|?
         _tr:={? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?};
         exec('extract_tr','abstore',_tr,_fields);
         {? var_press('ODB',_fields)=type_of('') & _fields.ODB<>''
         ||
            _result:=exec('send_divisionstore','abstore',0,_fields.ODB);
            {? _result<>200 & _result<>200 || return(_result) ?}
         ?};
         _tab.next()
      !};
      exec('clear_sync','abstore', _tab.ID, 'KH_ODBMG')
   ?}
||
   _result:=exec('send_divisionstore','abstore',0)
?};
_result


\send_divisionstore
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: wysyła powiązania odbiorcy(oddziału) z magazynem
::   WE: _a - czy uzywac synchro (1)
::       _b - (opcjonalnie) KH_ODB.ref - oddziału dla którego powiązania mają zostać wysłane
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_result:=200;

{? ~_useSynchro
||
   {? var_press('_b')>0 || _odb:=' and KH_ODB.REFERENCE=''%1'''[_b] || _odb:='' ?};
   _sql:='select ODBMG.REFERENCE as REF, ODBMG.ODB, MG.SYM as MG, KH.STR_OFE as STR from KH_ODBMG ODBMG
              join KH_ODB using(KH_ODB.REFERENCE,ODBMG.ODB)
              join MG using(MG.REFERENCE, ODBMG.MG)
              join KH using(KH.REFERENCE,KH_ODB.KH)
              where KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>''''
              %1
              order by ODBMG.ODB'[_odb];
   _tab:=sql(_sql);
::   exec('select','#table',_tab);
   _odb:='';
   _cnt:=0;
   _xml:='';
   _xml2:='';
   {? _tab.first ||
      {! |?
         {? _odb<>_tab.ODB ||
            _odb:=_tab.ODB;
            {? _cnt>0 || _xml+='</division-store-synchronize>' ?};
            _xml+='<division-store-synchronize division-eid="%1">'[_tab.ODB];
            _cnt:=0
         ?};
         _xml+='<sync-element store-eid="%1" main="%2"/>'[_tab.MG, {? _cnt=0 || 'true' || 'false' ?}];
         _xml2+=%13+%10;
         {? _tab.STR='PMAG_OIND_BKLI' | _tab.STR='PMAG_PIND_BKLI'
         | (_tab.STR='' & (__AbStore.strOfe='PMAG_OIND_BKLI' | __AbStore.strOfe='PMAG_PIND_BKLI' | __AbStore.strOfe='' ))
         ||
            _xml2+=exec('xml_contractorsetdoffer','abstore','OFERTA-'+_tab.MG, _tab.ODB)
         ?};
         _cnt+=1;
         _tab.next
      !};
      {? _cnt>0 || _xml+='</division-store-synchronize>' ?}
   ?};
   _file:=exec('create_msgfile','abstore','divisionstore.xml');
   fwrite(_file,maz_utf8(_xml));
::przypisanie oferty domyslnej
   fwrite(_file,maz_utf8(_xml2));
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'division-store');
   {? _result=200 & _useSynchro || exec('clear_sync','abstore',_tab.ID, _tabname) ?};
   fclose(_file);
   &_file
?};
_result


\send_unisync
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS:
::   WE: _a - nazwa tabeli
::       _b - tablica z polami z SYNC.TR obj_new('REF','NAZ','KOD');
::       _c - funkcja gen. xml dla put/add
::       _d - funkcja gen. xml dla del
::       _e - czy uzywac seek dla tabeli _a (opcjonalny 0)
::       _f - czy kasować zapisy w synchro (opcjonalny 1)
::       _g - ilość elementów w jednym pliku (opcjonalny 50) 0 - bez dzielenia
::       _h - zapis pliku do WSLOG
::       _i - warunek dla wiersza (opcjonalny)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_e')<0 || _e:=0 ?};
{? var_press('_f')<0 || _f:=1 ?};
{? var_press('_g')<0 || _g:=50 ?};
{? var_press('_h')<0 || _h:=1 ?};
{? var_press('_i')<0 || _fn:='1' || _fn:=_i ?};
{? _e || ($('%1.cntx_psh()'[_a]))() ?};
_result:=($('
_il_rec:=100;
_firma:='''';
_repl:=0;
_cnt:=0;
_f_head:=0;
_tab:=exec(''synchro_get'',''abs_conf'', __AbStore.synchro, _a, _il_rec, _firma, _repl);
_rodz:='''';
_result:=0;
{? _tab.first
||
   {? _e ||  ($(''%1.cntx_psh''))() ?};
   {! |?
::zapis nagłówka pliku
      {? _f_head=0 || _file:=exec(''create_msgfile'',''abstore'',''%2'');_f_head:=1 ?};
      _rodz:=_tab.RODZ;
      _tr:={? var_press(''TR1'',_tab)>0 || _tab.TR1 || _tab.TR ?};
::wyciągnięcie wartości pól
      exec(''extract_tr'',''abstore'',_tr,_b);
      {? _rodz = ''del''
      ||
::usuwanie elementów
         {? _d<>''''
         ||
            _ref:=_tab.REF;
            exec(''add_tabref'',''abstore'',_ref);
            {? var_press(''REF'',_b)>=0 || _b.REF:=_ref ?};
            {? var_press(''ref'',_b)>=0 || _b.ref:=_ref ?};
            _mpart:=exec(''%3'',''abstore'',_b);
            _cnt:=_cnt + 1;
            fwrite(_file, maz_utf8(_mpart))
         ?}
      ||
::dodawanie / modyfikacja elementów
         {? _c<>''''
         ||
            {? _e || ($(''%1.use(ref_name(_a)); %1.seek(_a)''))(_tab.REF) ?};
            _ref:=_tab.REF;
            exec(''add_tabref'',''abstore'',_ref);
            {? var_press(''REF'',_b)>=0 || _b.REF:=_ref ?};
            {? var_press(''ref'',_b)>=0 || _b.ref:=_ref ?};
            {? ($(_i))(_b) ||
               _cnt:=_cnt + 1;
               _mpart:=exec(''%2'',''abstore'',_b);
               fwrite(_file, maz_utf8(_mpart))
            ?}
         ?}
      ?};
      _next:=_tab.next;
      {? (_next=0 | (_cnt=_g & _g>0)) ||
::zakończenie pliku i wysyłka
         exec(''write_filefooter'',''abstore'',_file);
         {? ''%2''<>'''' & _cnt>0
         ||
            _result:=exec(''http_send'',''abstore'',_file,''%2'',_h)
         |? ''%3''<>'''' & _cnt>0
         ||
            _result:=exec(''http_send'',''abstore'',_file,''%3'',_h)
         ||
            _result:=201
         ?};
         fclose(_file);
         &_file;
         {? _result<>200 & _result<>201
         || {? _e ||  ($(''%1.cntx_pop'')) ?};
            return(_result)
         ?};
         _f_head:=0;
         _cnt:=0
      ?};
      _next
  !};
  {? _e ||  ($(''%1.cntx_pop'')) ?};
::kasowanie zapisów w synchro
  {? _f || exec(''clear_sync'',''abstore'', _tab.ID, _a) ?}
||
:: brak danych do wysłania
  _result:=201
?};
_result
'[_a,_c,_d]))(_a,_b,_c,_d,_e,_f,_g,_h,_fn);
{? _e || ($('%1.cntx_pop()'[_a]))() ?};
_result


\extract_tr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wyciaga dane ze stringa o formacie 'NS:3;SM:material00000010;SX:11' do obiektu
::   WE: _a - pole TR1 z synchro
::       _b - obiekt z polami do wypełnienia
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_fields:=spli_str(_a,';');
_cnt:=obj_len(_fields);
{! _xx:=1 .. _cnt |!
{? _fields[_xx]<>''
||
   _arr:=spli_str(_fields[_xx],':');
   ($('{? var_press(''%1'',_a)>=0 || _a.%1:=_b ?}'[(1 - _arr[1])]))(_b,_arr[2]);
   obj_del(_arr)
?}
!};
_b


\executeSync
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wykonuje przyrostową wymianę z AbStore przy użyciu synchro
::   WE: _a - nazwa konfiguracji Abstoreb2b lub Abstoreb2c
::       _b - opcjonalny czy uzywac sync domyslnie 1
::   WY:
::----------------------------------------------------------------------------------------------------------------------
($('exec(''setup%1'',''abstore'')'[_a]))();
::{? __AbStore.useStore || exec('send_store','abstore') ?};
{? var_press('_b')=1 || _useSync:=_b || _useSync:=1 ?};
_res:=exec('send_units','abstore', _useSync);
{? _res<>200 & _res<>201 || return(301) ?};
_res:=exec('send_categories','abstore', _useSync);
{? _res<>200 & _res<>201 || return(302) ?};
_res:=exec('send_labels','abstore', _useSync);
{? _res<>200 & _res<>201 || return(303) ?};
_res:=exec('send_products','abstore', _useSync);
{? _res<>200 & _res<>201 || return(304) ?};
_res:=exec('send_productlabels','abstore', _useSync);
{? _res<>200 & _res<>201 || return(305) ?};
_res:=exec('send_productpictures','abstore', _useSync);
{? _res<>200 & _res<>201 || return(306) ?};
_res:=exec('send_productresources','abstore', _useSync);
{? _res<>200 & _res<>201 || return(307) ?};
_res:=exec('send_prices','abstore', _useSync);
{? _res<>200 & _res<>201 || return(308) ?};
_res:=exec('send_stock_v2','abstore', _useSync);
{? _res<>200 & _res<>201 || return(309) ?};
{? _useSync || _res:=exec('send_stockProductUpd','abstore') ?};
{? _res<>200 & _res<>201 || return(310) ?};
{? _useSync || _res:=exec('send_productActivityUpd','abstore') ?};
{? _res<>200 & _res<>201 || return(311) ?};
:sztuczne rozrachunki do zamowien
{? __AbStore.useStore & __AbStore.settlementOrder ||
   _res:=exec('send_settlementorder','abstore', _useSync, 1, 0)
?};
{? _res<>200 & _res<>201 || return(312) ?};
_res:=exec('send_orderstatus','abstore', _useSync);
{? _res<>200 & _res<>201 || return(313) ?};
{? __AbStore.useStore
||
   {? _useSync ||
      _res:=exec('send_khdod','abstore')
   ?};
   _res:=exec('send_companygroup','abstore', _useSync);
   {? _res<>200 & _res<>201 || return(316) ?};
   _res:=exec('send_company','abstore', _useSync);
   {? _res<>200 & _res<>201 || return(317) ?};
   {? _useSync
   ||
      _res:=exec('send_cpricelist_update','abstore')
   ?};
   {? _res<>200 & _res<>201 || return(318) ?};
::przez synchro oddzialy nalezy wyslac oddzielnie bo sa oddzielne zapisy
   {? _useSync
   ||
      _res:=exec('send_division','abstore', _useSync)
   ?};
   {? _res<>200 & _res<>201 || return(319) ?};
   _res:=exec('SDiviSto_sync','abstore', _useSync);
   {? _res<>200 & _res<>201 || return(320) ?};
   _res:=exec('send_client','abstore', _useSync);
   {? _res<>200 & _res<>201 || return(321) ?};
   _res:=exec('send_clientdivision','abstore', _useSync);
:: {? ~__AbStore.usePersonalOffer ||  exec('send_contractorpricelist_new','abstore', _useSync) ?};
   {? _res<>200 & _res<>201 || return(322) ?};
   _res:=exec('send_grouppricelist','abstore', _useSync);
   {? _res<>200 & _res<>201 || return(323) ?};
   _res:=exec('send_cpricelist2','abstore',_useSync);
   {? _res<>200 & _res<>201 || return(324) ?};
   _res:=exec('sync_min_price','abstore',_useSync);
   {? _res<>200 & _res<>201 || return(308) ?}
?};
_res


\executeSendOffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: Wysłanie ofert do B2B ( nie działa przez synchro, bo oferty muszą być wysłane wszystkie w jednym pliku )
::   WE:  _a - nazwa konfiguracji np. Abstoreb2b
::        _b - 1 bez sprawdzenia hashy
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_b')=1 || _hash:=_b || _hash:=0 ?};
($('exec(''setup%1'',''abstore'')'[_a]))();

_res:=exec('send_defaultofferrev','abstore');
{? _res=200 | _res=201 || _res:=exec('send_defaultoffer','abstore') ?};
{? _res=200 | _res=201 || _res:=exec('send_divisionstore','abstore',0) ?};

{? _res=200 | _res=201
||
   {? __AbStore.mergeOffer
   ||
      _res:=exec('send_poffermerge','abstore',,_hash)
   ||
      _res:=exec('send_poffer','abstore',,_hash)
   ?}
?};
{? _res=200 | _res=201 || _res:=exec('send_prices','abstore',0) ?};
{? _res=200 | _res=201 || _res:=exec('send_cpricelist2','abstore',0,,_hash) ?};
{? _res=200 | _res=201 || _res:=exec('send_grouppricelist','abstore',0) ?};
{? _res=200 | _res=201 || _res:=exec('send_settlement','abstore',0) ?};
_id:=exec('sync_id','abstore');
{? _res=200 | _res=201 || _res:=exec('executeSync','abstore',_a) ?};
{? _res=200 | _res=201 || _res:=exec('execSendInv','abstore') ?};
{? _res=200 | _res=201 || exec('clear_sync','abstore',_id) ?};
_res


\execSendInv
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [22.26]
:: OPIS: Zasilenie faktur i rozrachunków z synchro, tylko dla B2B
::----------------------------------------------------------------------------------------------------------------------
exec('setupAbstoreb2b','abstore');
_res:=exec('send_invoicessync','abstore');
{? _res<>200 & _res<>201 || return(314) ?};
_res:=exec('send_dokumsync','abstore');
{? _res<>200 & _res<>201 || return(315) ?};
_res:=exec('FinSet','abstore');
{? _res<>200 & _res<>201 || return(312) ?};
_res


\executeSendOfferPersonal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: Wysłanie ofert do B2B ( nie działa przez synchro, bo oferty muszą być wysłane wszystkie w jednym pliku )
::   WE:  _a - nazwa konfiguracji np. Abstoreb2b
::   WY:
::----------------------------------------------------------------------------------------------------------------------
($('exec(''setup%1'',''abstore'')'[_a]))();
{? __AbStore.reverseOffer
||
    exec('send_pofferreverse','abstore')
||
   {? __AbStore.mergeOffer
   ||
      exec('send_poffermerge','abstore')
   ||
      exec('send_poffer','abstore')
   ?}
?};
~~


\executeSendOfferDefault
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: Wysłanie ofert do B2B ( nie działa przez synchro, bo oferty muszą być wysłane wszystkie w jednym pliku )
::   WE:  _a - nazwa konfiguracji np. Abstoreb2b
::   WY:
::----------------------------------------------------------------------------------------------------------------------
($('exec(''setup%1'',''abstore'')'[_a]))();
{? __AbStore.reverseOffer
||
   _res:=exec('send_defaultofferrev','abstore')
||
   _res:=exec('send_defaultoffer','abstore')
?};
~~


\executeNoSync
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wykonuje pełną wymianę z AbStore
::   WE: _a - nazwa konfiguracji Abstoreb2b lub Abstoreb2c
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_res:=exec('executeSync','abstore', _a, 0);
_res


\xml_orderstatus
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: xml do aktualizacji statusu zamówienia
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_press('IDABSTOR',_a)<=0 || return('') ?};
exec('log_write','abstore','','IDABSTOR=%1, status=%2'[_a.ABS_STA,_a.IDABSTOR],0);
_xml:='<order-status
order-iid="%4"
order-eid="%1"
tracking-number="%2"
code="%3"
>
<comment>
%5
</comment>
</order-status>'[
_a.REF,
_a.TRACKING,
_a.ABS_STA,
_a.IDABSTOR,
xml_valu(9000+gsub(ZK_N.memo_txt(,1,'UW'),'\n','<br>'))
];
_xml


\xml_ordersdel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.42]
:: OPIS: ustawia status zamówienia na CANCELED
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_press('IDABSTOR',_a)<=0 || return('') ?};
exec('log_write','abstore','','IDABSTOR=%1, status=%2'[_a.ABS_STA,_a.IDABSTOR],0);
_xml:='<order-status order-iid="%4" order-eid="%1" tracking-number="%2" code="%3"></order-status>'
[_a.REF,
_a.TRACKING,
{? _a.ABS_STA='WAITING_FOR_COMPLETION'
|| 'FINISHED_WITH_CHANGES'
|? _a.ABS_STA='FINISHED'
|| 'FINISHED'
|| 'CANCELED' ?},
_a.IDABSTOR];
_xml


\xml_orderset
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.42]
:: OPIS: xml do aktualizacji statusu zamówienia
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_press('IDABSTOR',_a)<>2 | var_press('SYM',_a)<>2  || return('') ?};
{? _a.IDABSTOR='' | _a.SYM='' || return('') ?};
_xml:='<order-set-eid order-iid="%1" order-eid="%2" />'[_a.IDABSTOR,_a.SYM];
_xml


\translate_orderstatus
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: zamienia status Meritowy na abstorowy
::   WE: _a - status w Merit
::   WY: status zamowienia w ABSTORE
::----------------------------------------------------------------------------------------------------------------------
{? _a='ZAM' || return('RECEIVED') ?};
{? _a='REA' || return('ACCEPTED') ?};
{? _a='ZRE' || return('FINISHED') ?};
{? _a='WYS' || return('SENT') ?};
{? _a='ZRE-ZAM' || return('FINISHED') ?};
{? _a='REA-ZAM' || return('ACCEPTED') ?};
{? _a='REA-ZRE' || return('WAITING_FOR_COMPLETION') ?};
{? _a='ANULOWANE' || return('CANCELED') ?};
{? _a='ARCHIWALNE' & _c='FINISHED'|| return('FINISHED') ?};
{? _a='ARCHIWALNE' & _c='WAITING_FOR_COMPLETION'|| return('FINISHED_WITH_CHANGES') ?};
{? _a='ARCHIWALNE'|| return('CANCELED') ?};
return('RECEIVED')


\send_orderstatus
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: aktualizacja statusu zamówienia, tylko przez synchro (uwaga! nie usuwa zapisow z synchro)
::   WY:  kod błędu (200 = ok)
::----------------------------------------------------------------------------------------------------------------------
_order:=obj_new('REF','IDABSTOR','SYM','TRACKING','STAN','ABS_STA');
_order.TRACKING:='';
_order.SYM:='';
exec('send_unisync','abstore','ZK_N',_order,'xml_orderset','xml_orderset',0,0,0,1);
{? __AbStore.useStore=1 & exec('param_get','abs_conf', 800126, 2)='T'
| __AbStore.useStore=0 & exec('param_get','abs_conf', 800226, 2)='T'
||
   exec('send_unisync','abstore','ZK_N',_order,'xml_order_sync','xml_ordersdel',0,1,0,1)
||
   exec('send_unisync','abstore','ZK_N',_order,'xml_orderstatus','xml_ordersdel',1,1,0,1)
?}


\send_usunrozzkn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: usuwa rozrachunek o podanym refie
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:=exec('xml_settlementdel','abstore',_a)


\send_settlementorder
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: generuje sztuczne rozrachunki na podstawie zamowien klienta do abstora w celu korekty limitu
::       parametr C moze byc przydatny przy np usuwaniu rozrachunkow wiszacych (ANULOWANE i BRT=0 wysyłają
::          komunikat settlement-del
::   WE: _a - synchro (1) / 0
::       _b - czy wysylac rozrach do zamowien z abstore (1) / 0
::       _c - czy wysylac rozrach do zamowien zrealizowanych/anulowanych (synchro=0) (0) / 1
::   WY:  kod błędu (200 = ok)
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
{? var_press('_b')=-1 || _b:=1 ?};
{? var_press('_c')=-1 | _useSynchro || _c:=0 ?};
{? _useSynchro
||
   _order:=obj_new('REF','IDABSTOR','SYM','TRACKING','STAN');
   _order.TRACKING:='';
   _order.SYM:='';
   _tabname:='ZK_N';
   _il_rec:=100;
   _firma:='';
   _repl:=0;
   _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
   _result:=200;
   {? _tab.first()
   ||
      {! |?
         _result:=exec('send_settlementorderid','abstore',_tab.REF);
         _tab.next() & _result=200
      !}
   ?};
   return(_result)
||
   _sql:='select ZK_N.REFERENCE as REF, ZK_N.STAN, ZK_N.A from @ZK_N join KH where KH.ABSTORE<>''''';
   {? _b || _sql+=' and ZK_N.IDABSTOR<>0 ' ?};
   {? _c=0 || _sql+=' and ZK_N.BRT>0 and ZK_N.STAN<>\'ANULOWANE\'' ?};
   _tab:=sql(_sql);
   _result:=200;
   {? _tab.first() & _tab.size()>0
   ||
      {! |?
         _result:=exec('send_settlementorderid','abstore',_tab.REF);
         _tab.next() & _result=200
      !}
   ?};
   return(_result)
?}


\send_settlementorderid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: wysyła rozrachunek do zamówienia o podanym REF
::   WE: _a - REF zamowienia
::   WY: status wysyłki 200 = ok
::----------------------------------------------------------------------------------------------------------------------
ZK_N.cntx_psh();
ZK_N.use(_a-8);
ZK_N.prefix();
_result:=201;
_seek:=ZK_N.seek(_a);
{? ~_seek | ZK_N.STAN='ANULOWANE'
||
   _xml:=exec('xml_settlementdel','abstore',_a)
||
   _xml:=exec('xml_settlementzkn','abstore',_a,1)
?};
{? _xml<>''
||
   _xml:=exec('xml_messageheader','abstore') + _xml + exec('xml_messagefooter','abstore');
   _result:=exec('http_send','abstore', _xml,'settlement-zkn:'+_a)
?};
ZK_N.cntx_pop();
_result


\send_client
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: Wysyła użytkowników z merita KH_OSOB do abstore
::   WE: _a - synchro (1) / 0
::       _b - KH.ref
::   WY:  kod błędu (200 = ok)
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
{? _useSynchro
||
   _fields:=obj_new('REF','IMIE','NAZWISKO','TEL','EMAIL','ABSTORE');
   _genXml:='xml_client';
   _delXml:='';
   exec('clear_tabref','abstore');
   _result:=exec('send_unisync','abstore','KH_OSOB', _fields, _genXml, _delXml,1,1,0,1,'
   KH.cntx_psh();
   _wyn:=KH_OSOB.KH().ABSTORE<>'''';
   KH.cntx_pop();
   _wyn');
:dodatkowo trzeba wyslac powiazania uzytkownika z oddzialami - moga zostac utworzone wczesniej
   {? _result=200 & __AbStore.tabRef.size()>0
   ||
      {? __AbStore.tabRef.first()
      ||
         {! |?
            exec('send_clientdivision','abstore', 0, __AbStore.tabRef.REF);
            __AbStore.tabRef.del()
         !}
      ?}
   ?}
||
   {? var_press('_b')>0 || _kh:=' and KH.REFERENCE=''%1'''[exec('tostring','abstore',_b)] || _kh:='' ?};
   _tab:=sql('select KH_OSOB.REFERENCE as REF, KH_OSOB.IMIE, KH_OSOB.NAZWISKO, KH_OSOB.TEL, KH_OSOB.EMAIL, KH_OSOB.KH,
         KH_OSOB.ABSTORE
         from KH_OSOB
         join KH using(KH_OSOB.KH, KH.REFERENCE)
         where KH_OSOB.ABSTORE<>'''' and KH.ABSTORE<>'''' %1'[_kh]);
   _result:=exec('send_uni','abstore',_tab,'xml_client');
   {? _tab.first()
   ||
      {! |?
         _result:=exec('send_clientdivision','abstore',0, _tab.REF);
         _tab.next()
      !}
   ?}
?};
_result


\send_clientdivision
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: wysyła powiązania klienta(użytkownika) z oddziałami
::   WE:  _a - uzywac synchro (domyslnie 1)
::        _b - ref osoby (opcjonalny) do wyslania tylko powiazan wybranego uzytkownika  z oddzialami
::   WY:  kod błędu (200 = ok)
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
{? _useSynchro
||
   _fields:=obj_new('REF','ODB','OSOBA','KH');
   _genXml:='xml_clientdivision';
   _delXml:='xml_clientdivisiondel';
   _result:=exec('send_unisync','abstore','KH_OSOBO', _fields, _genXml, _delXml, 1, 1,0,1, '
   KH_ODB.cntx_psh();KH.cntx_psh();
   _wyn:=KH_OSOBO.ODB().ABSTORE<>'''' & KH_OSOBO.ODB().KH().ABSTORE<>'''';
   KH_ODB.cntx_pop();KH.cntx_pop();
   _wyn')
||
   _sql:='select KH_OSOBO.REFERENCE as REF, KH_OSOBO.ODB, KH_OSOBO.OSOBA, KH_OSOBO.KH
            from KH_OSOBO
            join KH_ODB using(KH_OSOBO.ODB, KH_ODB.REFERENCE)
            join KH using(KH.REFERENCE, KH_ODB.KH)
            where KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>''''';
   {? var_press('_b')>0
   ||
      _sql+=' and KH_OSOBO.OSOBA=''%1'''[exec('tostring','abstore',_b)]
   ?};
   _tab:=sql(_sql);
   _result:=exec('send_uni','abstore',_tab,'xml_clientdivision');
   {? _tab.first()
   ||
      {! |?
         _result:=exec('send_divisionstore','abstore',0,_tab.ODB);
         _tab.next()
      !}
   ?}
?};
_result


\send_invoicessync
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:  wysyla nowo-dodane faktury
::   WY:  kod błędu (200 = ok)
::----------------------------------------------------------------------------------------------------------------------
OP.cntx_psh();
DOKUM.cntx_psh();DOKUM.index('DOKUM');
FAKS.cntx_psh();FAKS.prefix();
KH.cntx_psh();
KH_ODB.cntx_psh();
ROK_F.cntx_psh();
KH_DOD.cntx_psh();

_tabname:='FAKS';
_il_rec:=100;
_firma:='';
_repl:=0;
_result:=200;
_cnt:=0;
_tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
_rodz:='';
_Names:=DOKUM.names();

SKID.ROK_F:=exec('zwrrok_f','okresy',date());
{? SKID.ROK_F<>null || OP.use('operac'+SKID.ROK_F().KOD) ?};

{? _tab.first()
||
   {! |?
      {? _tab.RODZ='del' ||
:usuwanie faktur
         _xml:=exec('xml_messageheader','abstore');
         _xml+=exec('xml_invoicedel','abstore',_tab.REF);
         _xml+=exec('xml_messagefooter','abstore');
         _result:=exec('http_send','abstore',_xml,'invoice-del:'+_tab.REF,1);
         {? _result=200 || exec('sync_delid','abstore', _tab.ID) ?}
      ||
::add/put
         {? FAKS.seek(_tab.REF,ref_name(_tab.REF))
         & FAKS.KH<>null & FAKS.KH().ABSTORE<>''
         & FAKS.KH_ODB<>null & FAKS.KH_ODB().ABSTORE<>''
:: sprawdzenie czy jest zezwolenie na wysłanie e-faktury
         & (KH_DOD.index('KH_DOD'); KH_DOD.prefix(REF.FIRMA,FAKS.KH); KH_DOD.first())
         & (   __AbStore.eFak='W' |
              (__AbStore.eFak='E' & KH_DOD.EFAKTURA='T') |
              (__AbStore.eFak='B' & KH_DOD.EFAKTURA='B') |
              (__AbStore.eFak='EB' & (KH_DOD.EFAKTURA='T' | KH_DOD.EFAKTURA='B')))
:: sprawdzenie czy dla klientów B2C (dla hybrydy)
         |
         FAKS.seek(_tab.REF,ref_name(_tab.REF))
         & FAKS.KH<>null & FAKS.KH().ABSTOREC<>''
         & FAKS.KH().LOTUSUID<>''
:: sprawdzenie czy jest zezwolenie na wysłanie e-faktury
         & (KH_DOD.index('KH_DOD'); KH_DOD.prefix(REF.FIRMA,FAKS.KH); KH_DOD.first())
         & (   __AbStore.eFak='W' |
              (__AbStore.eFak='E' & KH_DOD.EFAKTURA='T') |
              (__AbStore.eFak='B' & KH_DOD.EFAKTURA='B') |
              (__AbStore.eFak='EB' & (KH_DOD.EFAKTURA='T' | KH_DOD.EFAKTURA='B')))
         ||
            {? OP.index('SYM');OP.prefix(FAKS.NWAL,FAKS.SYM,);OP.first()
               & ( _loop:=_Names.first();
                  {? _loop
                  ||
                     {!|?
                        DOKUM.use(_Names.NAME);
                        DOKUM.prefix(REF.FIRMA,$FAKS.ref(),);
                        _wyn:=DOKUM.first();
                        ~_wyn & _Names.next()
                     !}
                  ?};
                  _wyn)
            ||
               _result:=exec('send_invoice','abstore');
               {? _result=200
               || exec('sync_delid','abstore', _tab.ID);
                  exec('log_write','abstore','','send_invoices: ' + _tab.REF,_result)
               || exec('log_write','abstore','','send_inv_error: ' + _tab.REF,_result)
               ?}
            ?}
         ||
            exec('sync_delid','abstore', _tab.ID)
         ?}
      ?};
      _result=200 & _tab.next
   !}
?};

ROK_F.cntx_pop();
OP.cntx_pop();
DOKUM.cntx_pop();
FAKS.cntx_pop();
KH.cntx_pop();
KH_ODB.cntx_pop();
KH_DOD.cntx_pop();
_result


\send_dokumsync
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:  wysyla nowo-dodane faktury
::   WY:  kod błędu (200 = ok)
::----------------------------------------------------------------------------------------------------------------------
OP.cntx_psh();
DOKUM.cntx_psh();DOKUM.prefix();
FAKS.cntx_psh();FAKS.prefix();
KH.cntx_psh();
KH_ODB.cntx_psh();
ROK_F.cntx_psh();
KH_DOD.cntx_psh();

_tabname:='DOKUM';
_il_rec:=100;
_firma:='';
_repl:=0;
_result:=200;
_cnt:=0;
_tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
_rodz:='';

SKID.ROK_F:=exec('zwrrok_f','okresy',date());
{? SKID.ROK_F<>null || OP.use('operac'+SKID.ROK_F().KOD) ?};

{? _tab.first()
||
   {! |?
      {? _tab.RODZ='del' ||
:usuwanie samego załącznika nie
::         _xml:=exec('xml_messageheader','abstore');
::         _xml+=exec('xml_invoicedel','abstore',_tab.REF);
::         _xml+=exec('xml_messagefooter','abstore');
::         _result:=exec('http_send','abstore',_xml,'invoice-del:'+_tab.REF,1);
::         {? _result=200 || exec('sync_delid','abstore', _tab.ID) ?}
0
      ||
::add/put
:uwaga!! ABSTORE wymaga aby faktura była przypisana do oddziału kontrahenta - nie ma tego wymogu przy samym rozrachunku
         {? DOKUM.seek(_tab.REF,ref_name(_tab.REF))
         & (5+DOKUM.REFSQL)='faktu'
         & FAKS.seek(DOKUM.REFSQL,ref_name(DOKUM.REFSQL))
         & FAKS.KH<>null & FAKS.KH().ABSTORE<>''
         & FAKS.KH_ODB<>null & FAKS.KH_ODB().ABSTORE<>''
:: sprawdzenie czy jest zezwolenie na wysłanie e-faktury
         & (KH_DOD.index('KH_DOD'); KH_DOD.prefix(REF.FIRMA,FAKS.KH); KH_DOD.first())
         & (   __AbStore.eFak='W' |
              (__AbStore.eFak='E' & KH_DOD.EFAKTURA='T') |
              (__AbStore.eFak='B' & KH_DOD.EFAKTURA='B') |
              (__AbStore.eFak='EB' & (KH_DOD.EFAKTURA='T' | KH_DOD.EFAKTURA='B')))
:: sprawdzenie czy dla klientów B2C (dla hybrydy)
         |
         DOKUM.seek(_tab.REF)
         & (5+DOKUM.REFSQL)='faktu'
         & FAKS.seek(DOKUM.REFSQL,ref_name(DOKUM.REFSQL))
         & FAKS.KH<>null & FAKS.KH().ABSTOREC<>''
         & FAKS.KH().LOTUSUID<>''
:: sprawdzenie czy jest zezwolenie na wysłanie e-faktury
         & (KH_DOD.index('KH_DOD'); KH_DOD.prefix(REF.FIRMA,FAKS.KH); KH_DOD.first())
         & (   __AbStore.eFak='W' |
              (__AbStore.eFak='E' & KH_DOD.EFAKTURA='T') |
              (__AbStore.eFak='B' & KH_DOD.EFAKTURA='B') |
              (__AbStore.eFak='EB' & (KH_DOD.EFAKTURA='T' | KH_DOD.EFAKTURA='B')))
         ||
            {? OP.index('SYM');OP.prefix(FAKS.NWAL,FAKS.SYM,);OP.first()
            ||
               _result:=exec('send_invoice','abstore');
               {? _result=200
               || exec('sync_delid','abstore', _tab.ID);
                  exec('log_write','abstore','','send_invoices: ' + DOKUM.REFSQL,_result)
               || exec('log_write','abstore','','send_inv_error: ' + DOKUM.REFSQL,_result)
               ?}
            ?}
         ?}
      ?};
      _result=200 & _tab.next
   !}
?};

ROK_F.cntx_pop();
OP.cntx_pop();
DOKUM.cntx_pop();
FAKS.cntx_pop();
KH.cntx_pop();
KH_ODB.cntx_pop();
KH_DOD.cntx_pop();
_result


\sync_delref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
SYNC.cntx_psh();
SYNC.index('REF');
SYNC.prefix(_a);
{? SYNC.first() || {! |? SYNC.del() !} ?};
SYNC.cntx_pop()


\send_invoiceref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: wysyła pojedynczą fakturę do abstora
::   WE: _a - $ref do faktury do wysłania
::----------------------------------------------------------------------------------------------------------------------
_sql:='select F.REFERENCE as FAKS_REF, F.*, OP.WN, OP.MA, OP.REFERENCE as OP_REF from @FAKS F
   join KH using(KH.REFERENCE,F.KH)
   join KH_ODB using(KH_ODB.REFERENCE,F.KH_ODB)
   join @OP using(OP.SYM,F.SYM)
   where KH.ABSTORE<>'''' and KH_ODB.ABSTORE<>'''' and F.REFERENCE='':_a''';
_tabF:=sql(_sql,_a);
{? _tabF.first()
||
   exec('log_write','abstore','','wysylanie faktury: '+_a,0);
   _result:=exec('send_invoice','abstore',_tabF);
   _result
?}


\send_invoice
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: wysyla fakture i wydruk PDF
::   WE: _a - tabela zawierająca FAKS_REF (patrz: send_invoicessync)
::   WY: kod błędu (200 = ok)
::----------------------------------------------------------------------------------------------------------------------
_useSynchro:=0;
_file:=exec('create_msgfile','abstore', 'invoice');
_xml:='';

exec('xml_filepdf','abstore', _file, DOKUM.DOKUM, $FAKS.ref());
_xml+=exec('xml_invoicepdf','abstore',$FAKS.ref());
_xml+=exec('xml_invoicesettlement','abstore');
_xml+=exec('xml_settlement','abstore');

fwrite(_file,maz_utf8(_xml));
exec('write_filefooter','abstore',_file);
_result:=exec('http_send','abstore',_file,'invoice');
:usuwam z synchro zapis DOKUM zeby nie wysylal 2x (FAKS i DOKUM)
{? _result=200
||
   exec('sync_delref','abstore', $DOKUM.ref);
   exec('sync_delref','abstore', $OP.ref)
?};
fclose(_file);
&_file;
_result


\xml_valprice
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:
::   WE:
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<value-price base-gross="%1" currency="PLN"/>
   <left-to-pay-price base-gross="%2" currency="PLN" />'[ gsub($_a.BRUTTO,',','.'), gsub($_a.BRUTTO,',','.')];
_xml


\xml_taxvalprice
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:
::   WE:
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<tax-value-price base-net="%1" base-gross="%2" currency="PLN" vat="NP"/>
   <left-to-pay-price base-gross="%3" currency="PLN" />'
   [ gsub($FAKS.NETTO,',','.'), gsub($FAKS.BRUTTO,',','.'), gsub($FAKS.BRUTTO,',','.')];
_xml


\xml_invoicesettlement
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: faktura
::   WE:
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_roz:=OP.SYM_ROK;
_data:='%1T00:00:01'[ gsub($FAKS.D,'/','-')];
_dataW:='%1T00:00:01'[ gsub($FAKS.DW,'/','-')];
_xml:='<invoice-settlement eid="%1" number="%2"
    %3 financial-settlement-eid="%4" issue-date="%5"
    sale-date="%6" settlement-currency="PLN">'[$FAKS.ref(), xml_valu(FAKS.SYM),
    KH.cntx_psh();
    _wyn:=
    {? FAKS.KH().ABSTOREC<>'' & FAKS.KH().LOTUSUID<>''
    || 'company-iid="%1"'[FAKS.KH().LOTUSUID]
    || 'company-eid="%1" division-eid="%2"'[$FAKS.KH, $FAKS.KH_ODB]
    ?};
    KH.cntx_pop();
    _wyn,
    _roz, _dataW, _data];
_xml + exec('xml_taxvalprice','abstore') + '</invoice-settlement>'


\xml_invoicedel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: usuwanie faktury
::   WE: _a - ref faktury do usuniecia
::----------------------------------------------------------------------------------------------------------------------
_xml:='';
{? var_press('_a') > 100 & var_press('SYM',_a)=2
||
   _sql:='select FAKS.REFERENCE, FAKS.SYM from @FAKS join KH using(FAKS.KH, KH.REFERENCE)
   where KH.ABSTORE<>\'\' and FAKS.SYM=\'%1\''[_a.SYM];
   _sql_del:=sql(_sql);
   {? _sql_del.first()
   ||
      _xml:='<invoice-settlement-del invoice-eid="%1" />'[_sql_del.REFERENCE]
   ?}
|? var_press('_a')=2
||
   _xml:='<invoice-settlement-del invoice-eid="%1" />'[_a]
?};
_xml


\xml_invoicepdf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<invoice-settlement-pdf eid="%1" invoice-eid="%1" file-pdf-eid="pdf-%1" />'[_a];
_xml


\create_tmpzkp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(1
       ,'REF', 'STRING[16]','ref'
       ,'IDADD', 'STRING[32]', 'IDADD'
       ,'KOD','STRING[10]','KOD'
::      Nagłówek cennika (oryginalny typ: _TAR)
       ,'TAR'     ,'STRING[16]' ,'Cennik ref'
       ,'NAZ'     ,'STRING[30]','Nazwa cennika'
       ,'P'       ,'INTEGER', 'Priorytet'
::      Początkowa data obowiązywania ceny
       ,'OD'      ,'DATE'       ,'Od daty'
::      Końcowa data obowiązywania ceny
       ,'DO'      ,'DATE'       ,'Do daty'
::      Indeks materiałowy (oryginalny typ: _M)
       ,'M'       ,'STRING[16]' ,'Indeks materiałowy'
       ,'M_IDADD' ,'STRING[32]', 'IDADD M'
::      Cena netto
       ,'CEN'     ,'REAL'       ,'Cena netto'
::      Cena brutto
       ,'CENB'    ,'REAL'       ,'Cena brutto'
::      Waluta (oryginalny typ: _SLO)
       ,'WAL'     ,'STRING[16]' ,'Waluta'
::      Rabat %
       ,'PRC'     ,'REAL'       ,'Rabat %'
::      Grupa materiałowa (oryginalny typ: _MGR)
       ,'MGR'     ,'STRING[16]' ,'Grupa materiałowa'
::      Kod materiału lub kod grupy materiałowej
       ,'OP'      ,'STRING[50]' ,'Opis pozycji cennika'
::      Czy pozycja jest aktywna (wg daty serwera)
       ,'A'       ,'STRING[1]'  ,'Aktywna'
::      C - cennik std. ,K -cennik kontrah., G -cennik grupy kh.
       ,'RODZ'    ,'STRING[1]'  ,'Rodzaj pozycji cennika'
::      Przechowywanie stawki VAT do obliczenia ceny brutto (oryginalny typ: _SLO)
       ,'SV'      ,'STRING[16]' ,'Stawka VAT'
::      Jednostka miary = cena dla danej jednostki (oryginalny typ: _JM)
       ,'JM'      ,'STRING[16]' ,'Jednostka miary'
::      Cennik bazowy
       ,'TARB'    ,'STRING[16]' ,'Cennik bazowy'
::      Promocja (oryginalny typ: _PROMO)
       ,'PROMO'   ,'STRING[16]' ,'Promocja'
::      Kwota rabatu netto
       ,'RABNET'  ,'REAL'       ,'Kwota rabatu netto'
::      Kwota rabatu brutto
       ,'RABBRT'  ,'REAL'       ,'Kwota rabatu brutto'
::      Podgrupa materiałowa (oryginalny typ: _MGRP)
       ,'MGRP'    ,'STRING[16]' ,'Podgrupa materiałowa'
::      Zakres cenowy
       ,'CEN_ZAKR','STRING[1]'  ,'Zakres cenowy'
::      Cena od netto
       ,'CEN_OD'  ,'REAL'       ,'Cena od netto'
::      Cena od brutto
       ,'CENB_OD' ,'REAL'       ,'Cena od brutto'
::      Ilość
       ,'IL'      ,'REAL'       ,'Ilość'
::      Ilość do (przedział otwarty prawostronnie)
       ,'IL_DO'   ,'REAL'       ,'Ilość do');
_idx:=_tab.ndx_tmp('',0,'M',,0);
_tab.index(_idx);
_tab


\get_productsfrompricelist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: tworzy tabele tymczasowa z materialami z cennika z uwzględnieniem cenników bazowych i grup/podgrup  w pozycjach
::   WE:  _a - tabela wyjsciowa
::        _b - $ref cennika
::        _c - grupa
::        _d - podgrupa
::        _e - rabat procentowy
::        _f - (0) 0/1 - czy tylko pozycje promocyjne
::        _g - $PROMO do przepisania z pozycji do grupy/podgrupy
::        _h - strategia oferty
::   WY: tabela tymczasowa TAP ze wszystkimi towarami kontrahenta
::----------------------------------------------------------------------------------------------------------------------
_sendBasePrice:=0;
{? var_press('__AbStore')>-1  ||  _sendBasePrice:=__AbStore.sendBasePrice ?};
{? var_press('_g')<0 || _g:='' ?};
{? var_press('_a')>100 ||
   _tmp:=_a
||
   _tmp:=exec('create_tmpzkp','abstore')
?};
::sprawdzanie wartości walut
_cur:=exec('currency','abstore');

_sql:='select TAP.REFERENCE as REF, TAP.*, M.IDADD as M_IDADD, TAR.P, TAR.NAZ, TAR.KOD from @TAP
        join TAR using (TAR.REFERENCE,TAP.TAR)
        join SLO using(TAP.WAL,SLO.REFERENCE)
        left join M using (M.REFERENCE,TAP.M)
        left join MGR using (MGR.REFERENCE,M.MGR)
        left join MGRP using (MGRP.REFERENCE,M.MGRP)
        where ((TAP.M is not null and '+ exec('m_abstore_sql','abstore') +') or TAP.M is null)
        and (SLO.KOD=''PLN'' or SLO.KOD=''EUR'' or SLO.KOD=''USD'')
        and NVL(TAP.OD,CURRENT_DATE)<=CURRENT_DATE
        and NVL(TAP.DO,CURRENT_DATE)>=CURRENT_DATE
        and TAP.REFERENCE not like ''______hs\%''
        and TAP.TAR=''%1'' '[_b];
{? _c<>'' || _sql+=' and MGR.REFERENCE=''%1'''[_c] ?};
{? _d<>'' || _sql+=' and MGRP.REFERENCE=''%1'''[_d] ?};
{? var_press('_f')=type_of(0) & _f=1 || _sql+=' and TAP.PROMO is not null' ?};
{? var_press('_h')=type_of('') & (_h='PMAG_OIND_BKLI' | (_h='' & __AbStore.strOfe='PMAG_OIND_BKLI'))
||
   _sql+=' and TAP.M not in (select TAP.M from @TAP join TAR using (TAR.REFERENCE,TAP.TAR) where POSITION(TAR.KOD IN ''%1'')>0)'[__AbStore.cennik]
?};
_tap:=sql(_sql);
{? _tap.first
||
   {!|?
::zwracamy kolejne pozycje z cennika i po natrafieniu na M=null wywolujemy rekurencyjnie dla podanego bazowego i kategorii/podkategorii
      {? _tap.M<>''
      ||
         _flagcheckpri:=0;
         {? _tmp.find_key(_tap.M) ||
::jest juz pozycja mat. w cenniku z pochodzaca z cennika ogolnego (bazowego) wiec usuwam
            {? _tmp.RODZ='C' || _tmp.del() || _flagcheckpri:=1 ?}
         ?};
         {? ~_flagcheckpri | (_flagcheckpri & (_tap.P>=_tmp.P))
         ||
::kopiuje pozycje do cennika
            {? _flagcheckpri & (_tap.P>_tmp.P)
            ||
               _tmp.del();
               exec('cp_rec','abstore',_tap,_tmp);
               _tmp.PRC:=_e + _tap.PRC
            ?};
            {? ~_flagcheckpri
            ||
               exec('cp_rec','abstore',_tap,_tmp);
               _tmp.PRC:=_e + _tap.PRC
            ?};
            {? ((_g<>'') | (_c<>'') | (_tmp.RODZ='C' & ~_sendBasePrice)) || _tmp.CEN:=0; _tmp.CENB:=0 ?};
            {? _tmp.PROMO='' || _tmp.PROMO:=_g ?};
:ten sam priorytet cennikow - wybieramy niższą cenę - nie sprawdzam czy cena=0
            _war_tap:=0;
            _war_tmp:=0;
            {? _flagcheckpri & _tap.P=_tmp.P & {? _tmp.CEN<>0 & _tap.CEN=0 || 0 || 1 ?}
            & ({? _tap.WAL=$_cur.WEUR
               || _war_tap:=_tap.CEN*_cur.PEUR
               |? _tap.WAL=$_cur.WUSD
               || _war_tap:=_tap.CEN*_cur.PUSD
               || _war_tap:=_tap.CEN
               ?};
               {? _tmp.WAL=$_cur.WEUR
               || _war_tmp:=_tmp.CEN*_cur.PEUR
               |? _tmp.WAL=$_cur.WUSD
               || _war_tmp:=_tmp.CEN*_cur.PUSD
               || _war_tmp:=_tmp.CEN
               ?};
               (_war_tap<_war_tmp | (_war_tap<>0 & _war_tmp=0)))
            || _tmp.CEN:=_tap.CEN;
               _tmp.CENB:=_tap.CENB;
               _tmp.WAL:=_tap.WAL;
               _tmp.PRC:=_e + _tap.PRC
            ?};
            _tmp.put()
         ?}
      ||
         {? _tap.MGR<>''
         ||
            _sql:='select M.REFERENCE as REF from M %1where M.MGR=''%2'' and '[
            {? _tap.TARB<>'' || 'join TAP using(M.REFERENCE,TAP.M)' || '' ?},
            _tap.MGR]
            +exec('m_abstore_sql','abstore');
            {? _tap.MGRP<>'' || _sql+='and M.MGRP=''%1'''[_tap.MGRP] ?};
            {? _tap.TARB<>'' || _sql+='and TAP.TAR=''%1'''[_tap.TARB] ?};
            _sql_g:=sql(_sql);
            {? _sql_g.first()
            ||
               {!|?
                  {? _tmp.find_key(_sql_g.REF) & _tmp.CEN=0 & _tmp.CENB=0 & _tmp.PRC=_e
                  ||
                     _tmp.CEN:=_tap.CEN;
                     _tmp.CENB:=_tap.CENB;
                     _tmp.WAL:=_tap.WAL;
                     _tmp.PRC:=_e + _tap.PRC;
                     _tmp.put()
                  ?};
                  _sql_g.next()
               !}
            ?};
            {? var_press('_sql_g')>100 || obj_del(_sql_g) ?}
         ?}
      ?};
      _tap.next
   !}
?};
_tmp


\cp_rec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: kopiowanie rekordu z jednej tabeli do drugiej
::   WE: _a - tabela zrodlowa
::       _b - tabela docelowa
::----------------------------------------------------------------------------------------------------------------------
_b.blank;
{! x:=1 .. _b.fld_num  |!
    _fld:=_b.fld_acr(x);
    {? _fld='REF' ||
       _b.REF:={? var_press('REF',_a)>=0 || _a.REF || $_a.ref ?}
    ||
       {? var_press(_fld,_a)>=0 ||
         ($('_b.%1:={? type_of(_a.%1)=7 || exec(''tostring'',''abstore'',_a.%1)
                 || {? type_of(_a.%1)=0 || null || _a.%1 ?} ?}'[_fld]))(_a,_b)
       ?}
    ?}
!};
_b.add(1)


\get_rabat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Mario [2008]
:: OPIS: zwaca sposób płatności lub rabat dla kontrahenta (dla bieżącej daty)
::   WE:  _a  - kontrahent KH.ref
::       [_b] - czy szukać sposobu płatności (0) / czy rabatu (1) [domyślnie (0) sposób płatności]
::       [_c] - oddzial - jesli nie ma __AbStore
::   WY: ref sposobu płatności lub rabat
::  OLD: \sp_plat/ceny.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_c')>-1 || _oddz:=_c || _oddz:=__AbStore.oddz ?};
_wyn:=0.0;
GRKH.cntx_psh();
KH.cntx_psh();
KH_DOD.cntx_psh();
TAR.cntx_psh();
KH.prefix();
_kh:=_grkh:=null;
{? KH.seek(_a)
|| _kh:=KH.ref();
   _grkh:=KH.GRKH
?};
:: sprawdzanie informacji kontrahenta
{? _kh<>null
||
   KH_DOD.index('KH');
   KH_DOD.prefix(_kh);
   {? KH_DOD.first ||
      _wyn:=KH_DOD.RAB
   ?}
?};
_wyn1:=null;
:: sprawdzanie informacji w cennikach dla kontrahenta
{? _kh<>null
|| TAR.index('KH');
   TAR.prefix(_oddz,'S',_kh);
   {? TAR.first()
   || _wyn1:=null;
      {!
      |?
         {? TAR.OD<=date() & (TAR.DO>=date() | TAR.DO=date(0,0,0)) & TAR.PRC>0
         ||
            _wyn1:=TAR.PRC
         ?};
         TAR.next() & _wyn1=null
      !}
   ?}
?};

:: sprawdzanie informacji w cennikach dla grup kontrahentów
{? _grkh<>null & _wyn1=null
|| TAR.index('GRKH');
   TAR.prefix(ST.ODDZ,TAZ.SD,_grkh);
   {? TAR.first()
   || _wyn1:=null;
      {!
      |?
         {? TAR.OD<=date() & (TAR.DO>=date() | TAR.DO=date(0,0,0)) &  TAR.PRC>0
         ||
            _wyn1:=TAR.PRC
         ?};
         TAR.next() & _wyn1=null
      !}
   ?}
?};
{? _wyn1<>null || _wyn:=_wyn1 ?};
KH_DOD.cntx_pop();
KH.cntx_pop();
GRKH.cntx_pop();
TAR.cntx_pop();
_wyn



::odwrocone oferty


\send_pofferreverse2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: OFERTY dedykowane dla oddziałów tworzone z cennika ogólnego. Oferta wysyłana odddzielnie dla każdego oddziału
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=200;
_cnt:=0;
_file:=exec('create_msgfile','abstore', 'personalOffer');
::lista odbiorcow z ustawionym ABSTORE<>''
_sql:='select KH_ODB.REFERENCE as REF, KH_ODB.*, KH.KOD || ''-'' || KH_ODB.KOD as KH_KOD from KH_ODB
   join KH using(KH.REFERENCE,KH_ODB.KH)
   where KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>''''';
_KH_ODB:=sql(_sql);
::exec('select','#table',_KH_ODB);
::oferta dedykowana = pozostale pozycje z cennika o priorytecie=1
_sql:='select distinct TAP.M from TAP
   join TAR using (TAP.TAR, TAR.REFERENCE)
   join M using (TAP.M,M.REFERENCE)
   where TAR.P=1 and '+ exec('m_abstore_sql','abstore');
_tbPoz:=sql(_sql);
::      exec('select','#table',_tbPoz);
{? _KH_ODB.first
||
   {! |?
         _cnt:=1;
::generowanie oferty dla wszystkich magazynow przypisanych do odbiorcy
         _sql:='select KH_ODBMG.ODB as KH_ODB, MG.SYM as MG from KH_ODB
                         join KH_ODBMG using(KH_ODBMG.ODB,KH_ODB.REFERENCE)
                         join MG using(MG.REFERENCE,KH_ODBMG.MG)
                         where KH_ODB.REFERENCE=''%1'' and KH_ODB.ABSTORE<>'''''[_KH_ODB.REF];
         _tabMG:=sql(_sql);
::      exec('select','#table',_tabMG);
::zapis naglowkow ofert na magazynach
         _xml:='';
         {? _tabMG.first
         ||
            {! |?
               _kod:='PO-'+_KH_ODB.KH_KOD +'-'+_tabMG.MG;
               _xml:=exec('xml_personaloffer','abstore', _kod, _kod, _tabMG.MG, _KH_ODB.REF, _kod);
               fwrite(_file,maz_utf8(_xml));
               _tabMG.next
            !}
         ?};
::zapis pozycji ofert dla wszystkich magazynow odbiorcy
         {? _tabMG.first
         ||
            {! |?
               _kod:='PO-'+_KH_ODB.KH_KOD +'-'+_tabMG.MG;
               {? _tbPoz.first
               ||
                  _xml:=exec('xml_poffersyncbegin','abstore', _KH_ODB.REF, _kod,0);
                  fwrite(_file,maz_utf8(_xml));
                  {! |?
                     _xml:=exec('xml_pofferproduct','abstore', _KH_ODB.REF, _tbPoz.M, _kod, 0);
                     fwrite(_file,maz_utf8(_xml));
                     _tbPoz.next
                  !};
                  _xml:=exec('xml_poffersyncend','abstore');
                  fwrite(_file,_xml)
               ?};
               _tabMG.next
            !}
         ?};
         &_tabMG;
      _KH_ODB.next
   !}
?};
{? _cnt>0
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'personal-offer');
   fclose(_file);
   &_file
::czyszczenie SYNC
||
    _result:=201
?};
_result


\send_pofferreverse3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: OFERTA dedykowana dla oddziałów tworzona z cennika ogólnego. Oferta wysyłana dla pierwszego kontrahenta
::      i udostepniana dla wszystkich
::       UWAGA: NIE DZIAŁA - BRAKUJE ODPOWIEDNIEGO KOMUNIKATU PO STRONIE ABSTORE
::----------------------------------------------------------------------------------------------------------------------
_result:=200;
_cnt:=0;
_file:=exec('create_msgfile','abstore', 'personalOffer');
::lista odbiorcow z ustawionym ABSTORE<>''
_sql:='select top 1 KH_ODB.REFERENCE as REF, KH_ODB.*, KH.KOD, KH.KOD || ''-'' || KH_ODB.KOD as KH_KOD from KH_ODB
   join KH using(KH.REFERENCE,KH_ODB.KH)
   where KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>'''' order by KH.KOD';
_KH_ODB:=sql(_sql);
::exec('select','#table',_KH_ODB);
::oferta dedykowana = pozostale pozycje z cennika o priorytecie=1
_sql:='select distinct TAP.M from TAP
   join TAR using (TAP.TAR, TAR.REFERENCE)
   join M using (TAP.M,M.REFERENCE)
   where TAR.P=1 and '+ exec('m_abstore_sql','abstore');
_tbPoz:=sql(_sql);
::      exec('select','#table',_tbPoz);
{? _KH_ODB.first
||
   {! |?
         _cnt:=1;
::generowanie oferty dla wszystkich magazynow przypisanych do odbiorcy
         _tabMG:=exec('magazyny','abs_conf');
::      exec('select','#table',_tabMG);
::zapis naglowkow ofert na magazynach
         _xml:='';
         _cnt:=obj_len(_tabMG);
         _idx:=1;
         {! |?
            _kod:='OFERTA OG-'+_tabMG[_idx];
            _xml:=exec('xml_personalofferall','abstore', _kod, _kod, _tabMG[_idx], _KH_ODB.REF, _kod);
            fwrite(_file,maz_utf8(_xml));
            _idx+=1;
            _idx<=_cnt
         !};
::zapis pozycji ofert dla wszystkich magazynow odbiorcy
         _idx:=1;
         {! |?
            _kod:='OFERTA OG-'+_tabMG[_idx];
            {? _tbPoz.first
            ||
               _xml:=exec('xml_poffersyncbegin','abstore', _KH_ODB.REF, _kod,0);
               fwrite(_file,maz_utf8(_xml));
               {! |?
                  _xml:=exec('xml_pofferproduct','abstore', _KH_ODB.REF, _tbPoz.M, _kod, 0);
                  fwrite(_file,maz_utf8(_xml));
                  _tbPoz.next
               !};
               _xml:=exec('xml_poffersyncend','abstore');
               fwrite(_file,_xml)
            ?};
            _idx+=1;
            _idx<=_cnt
         !};
         &_tabMG;
      _KH_ODB.next
   !}
?};
{? _cnt>0
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'personal-offer');
   fclose(_file);
   &_file
::czyszczenie SYNC
||
    _result:=201
?};
_result


\send_defaultofferrev
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: Oferty domyslne budowane na podst cennnikow kontrahentow/oddzialow (__AbStore.reverseOffer=1)
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=200;
_cnt:=0;
_file:=exec('create_msgfile','abstore', 'defaultOffer');
::lista odbiorcow z ustawionym ABSTORE<>''
_sql:='select KH_ODB.REFERENCE as REF, KH_ODB.*, KH.KOD as KH_KOD, KH.REFERENCE as KH_REF from KH_ODB
   join KH using(KH.REFERENCE,KH_ODB.KH)
   where KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>'''' and
   (KH.STR_OFE=''BMAG_BIND_PKLI'' or KH.STR_OFE=''BMAG_BIND_OKLI'' or
   (KH.STR_OFE='''' and (\':_a\'=''BMAG_BIND_PKLI'' or \':_a\'=''BMAG_BIND_OKLI'')))';
_KH_ODB:=sql(_sql,__AbStore.strOfe);
{? _KH_ODB.first ||
   {! |?
         _cnt:=1;
::oferta dla odbiorcy
         _tbPoz:=exec('get_divisionofferproducts','abstore',_KH_ODB.REF,_KH_ODB.KH,0,1);
::generowanie oferty dla wszystkich magazynow przypisanych do odbiorcy
         _sql:='select KH_ODBMG.ODB as KH_ODB, MG.SYM as MG from KH_ODB
                         join KH_ODBMG using(KH_ODBMG.ODB,KH_ODB.REFERENCE)
                         join MG using(MG.REFERENCE,KH_ODBMG.MG)
                         where KH_ODB.REFERENCE=''%1'' and KH_ODB.ABSTORE<>'''''[_KH_ODB.REF];
         _tabMG:=sql(_sql);
::zapis naglowkow ofert na magazynach
         _xml:='';
         {? _tabMG.first
         ||
            {! |?
               _kod:='DO-'+_KH_ODB.KH_KOD +'-'+_tabMG.MG;
               _nazwa:=_kod;

               _xml:=exec('xml_defaultoffer','abstore', _kod, _nazwa, _tabMG.MG, 0);
               _xml+=%10+exec('xml_contractorsetdoffer','abstore', _kod, _KH_ODB.REF);
               fwrite(_file,maz_utf8(_xml));
               _tabMG.next
            !}
         ?};
::zapis pozycji ofert dla wszystkich magazynow odbiorcy
         {? _tabMG.first
         ||
            {!|?
               _kod:='DO-'+_KH_ODB.KH_KOD +'-'+_tabMG.MG;
               _xml:=exec('xml_doffersyncbegin','abstore',_kod,0);
               fwrite(_file,maz_utf8(_xml));
               {? _tbPoz.first
               ||
                  {! |?
                     _xml:=exec('xml_dofferproduct','abstore', _tbPoz.M, _kod, 0, _tbPoz.CENB);
                     fwrite(_file,maz_utf8(_xml));
                     _tbPoz.next
                  !}
               ?};
               _xml:=exec('xml_doffersyncend','abstore');
               fwrite(_file,_xml);
               _tabMG.next
            !}
         ?};
         &_tbPoz;
         &_tabMG;
      _KH_ODB.next
   !}
?};
{? _cnt>0
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'default-offer');
   fclose(_file);
   &_file
::czyszczenie SYNC
::   {? _result=200 || exec('sync_deltab','abstore',_tbsync); &_tbsync ?}
||
    _result:=201
?};
_result


\sendOfferSynchro
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: Oferty domyslne budowane na podst cennnikow kontrahentow/oddzialow (__AbStore.reverseOffer=1)
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
: lista produktow z synchro
: TAP.TAR().KH<>null -> put/add , dosylamy produkt do oferty domyslnej (sync-strategy="SKIP-ABSENT")
: TAP.RODZ='C' & TAP.TAR().P=1 -> dosylamy produkt do ofert dedykowanych wszystkim kontrahentom

_result:=200;
_cnt:=0;
_file:=exec('create_msgfile','abstore', 'defaultOffer');
::lista odbiorcow z ustawionym ABSTORE<>''
_sql:='select KH_ODB.REFERENCE as REF, KH_ODB.*, KH.KOD as KH_KOD from KH_ODB
   join KH using(KH.REFERENCE,KH_ODB.KH)
   where KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>''''';
_KH_ODB:=sql(_sql);
{? _KH_ODB.first
||
   {! |?
         _cnt:=1;
::oferta dla odbiorcy
         _tbPoz:=exec('get_divisionofferproducts','abstore',_KH_ODB.REF,_KH_ODB.KH,0);
::generowanie oferty dla wszystkich magazynow przypisanych do odbiorcy
         _sql:='select KH_ODBMG.ODB as KH_ODB, MG.SYM as MG from KH_ODB
                         join KH_ODBMG using(KH_ODBMG.ODB,KH_ODB.REFERENCE)
                         join MG using(MG.REFERENCE,KH_ODBMG.MG)
                         where KH_ODB.REFERENCE=''%1'' and KH_ODB.ABSTORE<>'''''[_KH_ODB.REF];
         _tabMG:=sql(_sql);
::zapis naglowkow ofert na magazynach
         _xml:='';
         {? _tabMG.first
          ||
            {! |?
               _kod:='DO-'+_KH_ODB.KH_KOD +'-'+_tabMG.MG;
               _nazwa:=_kod;

               _xml:=exec('xml_defaultoffer','abstore', _kod, _nazwa, _tabMG.MG, 0);
               _xml+=%10+exec('xml_contractorsetdoffer','abstore', _kod, _KH_ODB.REF);
               fwrite(_file,maz_utf8(_xml));
               _tabMG.next
            !}
         ?};
::zapis pozycji ofert dla wszystkich magazynow odbiorcy
         {? _tabMG.first ||
            _kod:='DO-'+_KH_ODB.KH_KOD +'-'+_tabMG.MG;
            _xml:=exec('xml_doffersyncbegin','abstore',_kod,0);
            fwrite(_file,maz_utf8(_xml));
            {? _tbPoz.first ||
               {! |?
                  _xml:=exec('xml_dofferproduct','abstore', _tbPoz.M, _kod, 0, _tbPoz.CENB);
                  fwrite(_file,maz_utf8(_xml));
                  _tbPoz.next
               !}
            ?};
            _tabMG.next;
            _xml:=exec('xml_doffersyncend','abstore');
            fwrite(_file,_xml)
         ?};
         &_tbPoz;
         &_tabMG;
      _KH_ODB.next
   !}
?};
{? _cnt>0
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'default-offer');
   fclose(_file);
   &_file
::czyszczenie SYNC
::   {? _result=200 || exec('sync_deltab','abstore',_tbsync); &_tbsync ?}
||
    _result:=201
?};
_result


\string_clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Oczyszcza przekazany string z niedozwolonych znaków, po to żeby się struktura pliku XML nie rozwaliła
::   WE: _a - STRING - napis który oczyścić
::   WY: STRING
::   funkcja skopiowana z #xml bo brakuje jej w xpertis
::----------------------------------------------------------------------------------------------------------------------
_string:=_a;
_string:=gsub(_string,'&','&amp;');
_string:=gsub(_string,'>','&gt;');
_string:=gsub(_string,'<','&lt;');
_string:=gsub(_string,'\'','&apos;');
_string:=gsub(_string,'\"','&quot;');
_string


\send_divisionpricelist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.02]
:: OPIS: wysyła cennik indywidualny kontrahentów o podanym kodzie, tylko dla kontrahentów oznaczonych ABSTORE<>''
::   WE: _a - czy uzywac synchro (opcjonalny 1)
::       _b - KH.ref -> wysyla cennik podanego kontrahenta (gdy parametr _a=0)
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_tabname:='TAP';
_il_rec:=100;
_firma:='';
_repl:=0;
_cnt:=0;
_price:=obj_new('REF','M','OD','DO','CEN','CENB','WAL','KH','GRKH','ABSTORE','PRC','PROMO','RODZ','MGR');
_price.WAL:='PLN';
::tabela do zapisania przetworzonych pozycji z synchro
_tbsync:=tab_tmp(1,'ID','STRING[20]','ID');
_jeden:=0;
{? _useSynchro
||
   TAR.cntx_psh();
   TAR.prefix();
   TAP.cntx_psh();
   TAP.prefix();
   KH.cntx_psh();
   KH.prefix();
    _tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
   _kid:='';
   {? _tab.first
   ||
     {! |?
::interesuja nas pozycje cennika kontrahentow oznaczonych ABSTORE<>''
         exec('extract_tr','abstore', {? var_press('TR1',_tab)>0 || _tab.TR1 || _tab.TR ?}, _price);
        {?  _tab.RODZ<>'del' & _price.KH<>'' & ((_price.ABSTORE<>'') | (_price.MGR<>''))
        ||
::zapis nagłówka pliku
:: jesli zmiana w cenniku ogolnym _price.RODZ='C' to wysylamy zmiane ceny na produkcie
:: zmiana w grupowym

::            {? _price.RODZ='K' & _price. ||
::sprawdzic czy dla jednego kontrahenta mamy put/add (caly cennik trzeba wyslac) czy tylko put (aktualizacja)
           {? _cnt=0 || _file:=exec('create_msgfile','abstore','cennik_khodb') ?};
           {? _price.KH<>_kid ||
              {? _cnt>0 ||
::zakonczenie poprzedniego cennika
                 _xml:='</contractor-price-individual-product-copy>';
                 fwrite(_file, _xml);
                 _cnt:=0
              ?};
                 TAP.use(_tab.REF-8);
                 {? TAP.seek(_tab.REF) ||
                 {? KH.seek(_price.KH) ||
                   _rabatKon:=exec('get_rabat','abstore',KH.ref);
::_rabatKon:=0.0;
::nie wysylamy przez synchro naglowkow cennikow bo to powoduje usuniecie wszystkich pozycji
::                   _xml:=exec('xml_contractorprice','abstore', 'CK-'+KH.KOD, $KH.ref, 'cennik ' + KH.SKR);
                   _kid:=_price.KH;
::                   fwrite(_file, _xml);
                   _xml:='<contractor-price-individual-product-copy>';
                   fwrite(_file, _xml)
                 ?}
              ?}
           ?};
           {? KH.seek(_price.KH)
           ||
::lista odbiorcow kontrahenta z ustawionym abstore<>''
              _sql:='select * from KH_ODB where KH_ODB.ABSTORE<>'''' and KH_ODB.KH=''%1'''[_price.KH];
              _tabOdb:=sql(_sql);
              exec('select','#table',_tabOdb);
              {? _tabOdb.first()
              ||
                 TAP.use(_tab.REF-8);
                 TAP.seek(_tab.REF);
                 {? TAP.MGR<>null
                 ||
::wszystkie pozycje z podanej grupy materiałowej
                     _sql:='select M.REFERENCE as REF from M where M.MGR=:_a and '+ exec('m_abstore_sql','abstore');
                     _tabM:=sql(_sql,TAP.MGR);
                     {? _tabM.first ||
                       {! |?
                          {! |?
                             _xml:=exec('xml_contractorpriceproduct','abstore', 'CK-'+KH.KOD, _tabM.REF, 0, 0,  {? _price.WAL='' || 'PLN' || _price.WAL ?}, TAP.PRC + _rabatKon);
                             fwrite(_file,maz_utf8(_xml));
                             _tabM.next
                          !};
                          _tabOdb.next
                       !}
                     ?};
                     &_tabM
                 ||
::pozycje cennika
                    _xml:=exec('xml_contractorpriceproduct','abstore', 'CK-'+KH.KOD+'-'+_tabOdb.KOD, $TAP.M, #gsub(_price.CEN,',','.'),
                          #gsub(_price.CENB,',','.'), {? _price.WAL='' || 'PLN' || _price.WAL ?}, TAP.PRC + _rabatKon);
                    fwrite(_file,maz_utf8(_xml))
                 ?}
              ?}
           ?};
           _cnt:=_cnt + 1;
           _tbsync.ID:=_tab.ID;
           _tbsync.add
        ?};
        _next:=_tab.next
     !}
   ?};
   {? _cnt>0 ||
::zakonczenie poprzedniego cennika
     _xml:='</contractor-price-individual-product-copy>';
     fwrite(_file, _xml)
   ?};
   TAR.cntx_pop();
   TAP.cntx_pop();
   KH.cntx_pop()
||
::pelny cennik bez synchro
_result:=200;
   TAR.cntx_psh();
   KH.cntx_psh();
   TAR.index('KH');
   TAR.prefix(__AbStore.oddz,'S');
   _jeden:=0;
   {? var_press('_b')<0 ||
      KH.index('NAZ');
      KH.prefix;
      KH.first
   ||
      KH.prefix;
      KH.seek(_b);
      _jeden:=1
   ?};
   _cnt:=0;
   _file:=exec('create_msgfile','abstore', 'cennik_kh_');
   {! |?
      _oldKH:='';
      {? KH.ABSTORE<>''
      ||
::cennik kontrahenta
         TAR.prefix(__AbStore.oddz, 'S', KH.ref);
         {?   TAR.first
         ||
::jest cennik kontrahenta
::_rabatKon:=0.0;
::petla po wszystkich cennikach kontrahenta
            {! |?
               _rabatKon:=exec('get_rabat','abstore',KH.ref);
::             zapis naglowka cennika jesli zmienil sie kontrahent (cenniki sa grupowane w jeden po kont
               {? KH.KOD<>_oldKH
               ||
::                czy zapisac zakonczenie listy towarow w cenniku
                  {? _oldKH<>''
                  ||
                      _xml:='</contractor-price-individual-product-copy>';
                     fwrite(_file, _xml)
                  ?};
                  _xml:=exec('xml_contractorprice','abstore', 'CK-'+KH.KOD, $KH.ref, 'cennik ' + KH.SKR);
                  fwrite(_file,maz_utf8(_xml));
                  _xml:='<contractor-price-individual-product-copy>';
                  fwrite(_file, _xml);
                  _oldKH:=KH.KOD
               ?};
               _tabCen:=exec('create_tmpzkp','abstore');
               {? TAR.TARB<>''
               ||
::pozycje z cennika bazowego przypisanego do pozycji cennika
                  exec('get_productsfrompricelist','abstore',_tabCen, TAR.TARB, '', '', _rabatKon)
               ?};
::            exec('select','#table',_tabCen);
               exec('get_productsfrompricelist','abstore',_tabCen, $TAR.ref, '', '', _rabatKon);
::            exec('select','#table',_tabCen);
               {? _tabCen.first
               ||
                  {! |?
                    _xml:=exec('xml_contractorpriceproduct','abstore', 'CK-'+KH.KOD,
                    _tabCen.M, _tabCen.CEN, _tabCen.CENB, 'PLN' , _tabCen.PRC);
                    fwrite(_file,maz_utf8(_xml));
                    _cnt:=_cnt + 1;
                    _tabCen.next
                  !}
               ?};
               obj_del(_tabCen);
               TAR.next
            !};
            {? _oldKH<>''
            ||
                _xml:='</contractor-price-individual-product-copy>';
               fwrite(_file, _xml)
            ?}
         ||
::kontrahent nie ma cennika indywidualnego ale moze miec rabat w kartotecek
::            _rabatKon:=exec('get_rabat','abstore',KH.ref);
            0
         ?}
      ?};
::petla gdy _b nie jest podany
      {? _jeden || 0 ||  KH.next ?}
   !};
   TAR.cntx_pop();
   KH.cntx_pop()
?};
{? _cnt>0
||
   exec('write_filefooter','abstore',_file);
   _result:=exec('http_send','abstore',_file,'contractor-price-list');
   fclose(_file);
   &_file;
::czyszczenie SYNC
   {? _result=200 & ~_jeden
   ||
      exec('sync_deltab','abstore',_tbsync); &_tbsync ?}
   ||
      _result:=201
?};
_result


\get_system
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_system:=app_info();
:{? _system='merit' || _fname:='funkcje' || _fname:='okresy' ?};
_system


\send_rozrach
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: Wysyła pojedynczy rekord z OP
::   WE: _a - ref do OP lub tabela z REF
::----------------------------------------------------------------------------------------------------------------------
OP.cntx_psh();
{? type_of(_a)=118 & var_press('REF',_a)>0
||
   _ref:=_a.REF
||
   _ref:=_a
?};
OP.use(_ref-8);
{? OP.seek(_ref)
||
  _result:=exec('xml_settlement','abstore')
||
  _result:=''
?};
OP.cntx_pop();
_result


\xml_settlement
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: komunikat dla pojedynczego rozrachunku
::   WE: OP - ustawione na rekord do wysłania
::   WY:
::----------------------------------------------------------------------------------------------------------------------
FAKS.cntx_psh();
_rodz:={? 1+OP.TYP='N' || 'CHARGE' || 'COMMITMENT' ?};
{? (OP.MA>OP.WN)
||
   _left:=-(OP.MA-OP.WN);
   _total:=-OP.MA
||
   _left:=OP.WN-OP.MA;
   _total:=OP.WN
?};
_xml:='';
:{? _faks.first() || _xml+=exec('xml_settlementdel','abstore', _faks.REF) + %13+%10 ?};
_xml+='<financial-settlement eid="%1" number="%2" settlement-currency="PLN" currency-rate="1" %3
      issue-date="%4" payment-date="%5" financial-settlement-type="%9">
    <value-price base-gross="%6" currency="PLN" />
    <left-to-pay-price base-gross="%7" currency="PLN" />
    <description>%8</description>
</financial-settlement>'[OP.SYM_ROK, OP.SYM,
KH.cntx_psh();
_wyn:=
{? KH.ABSTOREC<>'' & KH.LOTUSUID<>''
|| 'company-iid="%1"'[OP.KH().LOTUSUID]
|| 'company-eid="%1"'[$OP.KH().ref]
?};
KH.cntx_pop();
_wyn,
'%1T00:00:00'[gsub($OP.DO,'/','-')],
'%1T00:00:00'[gsub($OP.TZ,'/','-')],
gsub($_total,',','.'),
gsub($_left,',','.'),
xml_valu(OP.OP),
_rodz];
FAKS.cntx_pop();
_xml


\xml_settlementzkn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: sztuczny rozrachunek na podstawie zapisu w ZK_N
::   WE: _a - $REF do ZK_N
::       _b - 0/1 - czy wysyłać rozrachunki do zamówień z abstore
::   WY: xml string
::----------------------------------------------------------------------------------------------------------------------
_sql:='select ZK_N.IDABSTOR, ZK_N.REFERENCE REF, ZK_N.KH, ZK_N.DP, ZK_N.DT, ZK_N.BRUTTO,
       ZK_N.BRT, ZK_N.SYM, ZK_N.STAN, ZK_N.A
       from @ZK_N
       join KH where KH.ABSTORE<>\'\' and ZK_N.REFERENCE=\'%1\' and ZK_N.AKC=\'T\''[_a];
_zkn:=sql(_sql);
_xml:='';
{? _zkn.first() & _zkn.size()=1
||
:anulowanie lub przeniesienie do archiwum bez realizacji powoduje usuniecie rozrachunku
   {? (_zkn.STAN='ANULOWANE')
   ||
      _xml:=exec('xml_settlementdel','abstore',_zkn.REF)
   ||
      {? _zkn.IDABSTOR=0 | _b
      ||
         _pozostalo:=_zkn.BRT;
         {? _zkn.BRT<>_zkn.BRUTTO
         ||
:zamowienie zrealizowane w całości lub częściowo
:rozrachunek tworzony na podstawie ZK_N.BRUTTO - wartosc_zaksiegowanych_faktur
            _pozostalo:=exec('suma_zaksfak','abstore',_zkn.REF,_zkn.A='Z',_zkn.BRUTTO)
         ?};
         {? (_pozostalo=0)
         ||
            _xml:=exec('xml_settlementdel','abstore',_zkn.REF)
         ||
            _dni:=exec('kh_terminplat','abstore',_zkn.KH);
            _termin:=_zkn.DT + #_dni;
            _rodz:='CHARGE';
            _xml:='<financial-settlement eid="%1" number="%2" settlement-currency="PLN" currency-rate="1" company-eid="%3"
                  issue-date="%4" payment-date="%5" financial-settlement-type="%9">
                <value-price base-gross="%6" currency="PLN" />
                <left-to-pay-price base-gross="%7" currency="PLN" />
                <description>%8</description>
            </financial-settlement>'[_zkn.REF, _zkn.SYM, _zkn.KH,
            '%1T00:00:00'[gsub($_zkn.DP,'/','-')],
            '%1T00:00:00'[gsub($_termin,'/','-')],
            gsub($_zkn.BRUTTO,',','.'),
            gsub($_pozostalo,',','.'),
            'zamówienie:'+$_zkn.SYM,
            _rodz]
         ?}
      ?}
   ?}
?};
_xml


\suma_zaksfak
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: oblicza wartość obciążenia limitu kontrahenta zamówieniem
::   WE: _a - REF zamowienia
::       _b - czy zamowienie archiwalne
::       _c - wartość zamówienia ZK_N.BRUTTO
::   WY: double
::----------------------------------------------------------------------------------------------------------------------
ZK_RN.cntx_psh();
FAKS.cntx_psh();
_ZK_RN:=sql('select * from @ZK_RN where ZK_RN.N=\':_a\'',_a);
FAKS.index('FAK_SYM1');
_res:=0;
_sumareal:=0.0;
_sumaks:=0.0;
:jesli ZK_N.A='Z' =>  WARTOSC_ZREALIZOWANA - SUMA_ZAKSIEGOWANYCH)
:jesli ZK_N.A='A' => (WARTOSC_ZAMOWIENIA - SUMA_ZAKSIEGOWANYCH)
_sql:='select REFERENCE as REF from @OP where OP.SYM_ZEW=\':_a\'';
_lastfa:='';
{? (_ZK_RN.first() & _ZK_RN.size()>0)
||
   {! |?
      {? (_ZK_RN.FAKS<>'' & _lastfa<>_ZK_RN.FAKS)
      ||
         _lastfa:=_ZK_RN.FAKS;
         FAKS.use(_ZK_RN.FAKS-8);
         {? FAKS.seek(_ZK_RN.FAKS)
         ||
            _op:=sql(_sql, _ZK_RN.SFK);
            {? (_op.first() & _op.size()>0)
            ||
                _sumaks+=FAKS.BRUTTO
            ||
                _sumareal+=FAKS.BRUTTO
            ?};
            obj_del(_op)
         ?}
      ||
::realizacja na dokument magazynowy
         _sqldk:='select sum(DK.WB) as WB from DK where DK.N='':_a''';
         _dk:=sql(_sqldk,_ZK_RN.ND);
         _dk.first();
         _sumareal+=_dk.WB;
         obj_del(_dk)
      ?};
      _ZK_RN.next()
   !}
?};
ZK_RN.cntx_pop();
FAKS.cntx_pop();
{? _b || _sumareal - _sumaks || _c - _sumaks ?}


\xml_settlementfaks
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: "sztuczny" rozrachunek do faktury niezaksięgowanej
::   WE: _a - tabela tymczasowa
::----------------------------------------------------------------------------------------------------------------------
_rodz:='CHARGE';
_left:=_a.BRUTTO;
_total:=_a.BRUTTO;
_xml:='<financial-settlement eid="%1" number="%2" settlement-currency="PLN" currency-rate="1" company-eid="%3"
      issue-date="%4" payment-date="%5" financial-settlement-type="%9">
    <value-price base-gross="%6" currency="PLN" />
    <left-to-pay-price base-gross="%7" currency="PLN" />
    <description>%8</description>
</financial-settlement>'[_a.FAKS_REF, _a.SYM, _a.KH,
'%1T00:00:00'[gsub($_a.DW,'/','-')],
'%1T00:00:00'[gsub($_a.TZ,'/','-')],
gsub($_total,',','.'),
gsub($_left,',','.'),
_a.SYM,
_rodz];
_xml


\xml_settlementdel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: usunięcie rozrachunku
::   WE: _a - $ref rozrachunku do usunięcia
::----------------------------------------------------------------------------------------------------------------------
_xml:='<financial-settlement-del financial-settlement-eid="%1" />'[_a.SYM_ROK];
_xml


\send_settlement
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: wysyła nierozliczone rozrachunki do abstore
::   WE: _a - czy uzywac synchro [1] / 0
::       _b - KH.ref - rozrachunki wybranego kontrahenta (opcjonalny)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || _useSynchro:=_a || _useSynchro:=1 ?};
_result:=201;
{? _useSynchro
||

::    _fields:=obj_new('REF');
::   _genXml:='xml_settlement';
::   _delXml:='';
::   _result:=exec('send_unisync','abstore','OP', _fields, _genXml, _delXml, 1, 1,0,1, 'OP.KH().ABSTORE=''T''')
_result:=201
||
:   exec('log_write','abstore','','send_settlement nosync',0);
   OP.cntx_psh();ROK_F.cntx_psh();
   OP.prefix();
   _system:=app_info();
   {? _system='merit' || _fname:='okresy' || _fname:='funkcje' ?};
   SKID.ROK_F:=exec('zwrrok_f',_fname,date(),1);
   _maska:='';
   {? SKID.ROK_F<>null || _maska:='/* +MASK_FILTER(OP,''operac'+SKID.ROK_F().KOD +''') */' ?};
   _sql:='select '+_maska+' OP.REFERENCE as REF, KH.NAZ, OP.*
            from OP
            join KH using(KH.REFERENCE, OP.KH)
            where KH.ABSTORE<>'''' or KH.ABSTOREC<>''''';
   {? var_press('_b')>0
   || _sql+=' and KH.REFERENCE=''%1'''[exec('tostring','abstore',_b)]
   ?};
   _tab:=sql(_sql);
::   exec('select','#table',_tab);
   {? _tab.first() & _tab.size()>0
   ||
     _result:=exec('send_uni','abstore',_tab,'send_rozrach')
   ?};
   OP.cntx_pop();ROK_F.cntx_pop()
?};
_result
::oddzielna funkcja do usuwania wszystkich rozrachunkow ze wszystkich masek op
::wysylanie rozrachunkow na podst aktualnej daty raz dziennie z ofertami
::


\log_clear
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: czyszczenie tabeli WSLOG
::----------------------------------------------------------------------------------------------------------------------
WSLOG.first();
{! |?
  WSLOG.del
!}


\get_virtpricelist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: lista towarow ze znacznikiem ABSTORE<>'' z cena=0 i PRC = rabat ogolny
::   WE: _a - rabat ogolny kontrahenta
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_sql:='select M.REFERENCE as M,''C'' as RODZ, M.IDADD, 0 as CEN, 0 as CENB, %1 as PRC from M where '[gsub($_a,',','.')];
_sql+=exec('m_abstore_sql','abstore');
_tabM:=sql(_sql);
_tabCen:=exec('create_tmpzkp','abstore');
{? _tabM.first()
||
   {! |?
      exec('cp_rec','abstore',_tabM,_tabCen);
      _tabM.next()
   !}
?};
_tabCen


\delspace
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: usuwanie spacji ze stringa wersja dla merit/xpertis
::   WE: _a - string
::   WY: string
::----------------------------------------------------------------------------------------------------------------------
{? exec('get_system','abstore')='merit' || _plik:='#string' || _plik:='podstawy' ?};
exec('delspace',_plik,_a)


\m_abstore
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [20.14]
:: OPIS: czy materiał jest dostępny w integracji w zależności od konfiguracji b2b / b2c
::   WY: string
::----------------------------------------------------------------------------------------------------------------------
{? __AbStore.useStore=1
||
   {? M.ABSTORE<>'' || 1 || 0 ?}
||
   {? M.ABSTOREC<>'' || 1 || 0 ?}
?}


\m_abstore_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.14]
:: OPIS: czy materiał jest aktywny w integracji w zależności od konfiguracji b2b / b2c
::   WY: string
::----------------------------------------------------------------------------------------------------------------------
{? __AbStore.useStore=1
||
   {? M.ABSTORE='T' || 1 || 0 ?}
||
   {? M.ABSTOREC='T' || 1 || 0 ?}
?}


\m_abstore_sql
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [20.14]
:: OPIS: czy materiał jest dostępny w integracji w zależności od konfiguracji b2b / b2c w zapytaniach sql
::   WY: string
::----------------------------------------------------------------------------------------------------------------------
{? __AbStore.useStore=1 || 'M.ABSTORE<>'''' ' || 'M.ABSTOREC<>'''' ' ?}


\mgr_abstore
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Markus [20.14]
:: OPIS: czy grupa materiałowa jest dostępna w integracji w zależności od konfiguracji b2b / b2c
::   WY: string
::----------------------------------------------------------------------------------------------------------------------
{? __AbStore.useStore=1
||
   {? MGR.ABSTORE<>'' || 1 || 0 ?}
||
   {? MGR.ABSTOREC<>'' || 1 || 0 ?}
?}


\mgr_abstore_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.42]
:: OPIS: czy materiał jest aktywny w integracji w zależności od konfiguracji b2b / b2c
::   WY: string
::----------------------------------------------------------------------------------------------------------------------
{? __AbStore.useStore=1
||
   {? MGR.ABSTORE='T' || 1 || 0 ?}
||
   {? MGR.ABSTOREC='T' || 1 || 0 ?}
?}


\log_reader
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.14]
:: OPIS: Wyświetla tabele z logami pochodzącymi z wysyłanych danych z synchro do abstora
::----------------------------------------------------------------------------------------------------------------------
VAR_DEL.delete('TAB_LR');
TAB_LR:=sql('select * from @WSLOG where konfig=\''+_a+'\'');
_sel:=TAB_LR.mk_sel('LOG',,1,,,,,,'U','T');
TAB_LR.win_sel(_sel);
TAB_LR.index(TAB_LR.ndx_tmp(,,'DATA',,1,'CZAS',,1));
TAB_LR.win_act(_sel,0,'Formuła','XML',,,,"exec('xml_reader','abstore')");
TAB_LR.select()


\xml_reader
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.14]
:: OPIS: Wyswietla komunikat xml utworzony przy wysyłaniu danych z synchro do abstora
::----------------------------------------------------------------------------------------------------------------------
{? TAB_LR.LOG=null()
||
   FUN.info('Brak pliku XML'@)
|| exec('bl_view','#blob',TAB_LR,'LOG')
?}


\test_atr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [20.14]
:: OPIS: test odczytu atrybutow
::----------------------------------------------------------------------------------------------------------------------
M.prefix();
M.seek('material000000c8');
exec('xml_productattributesall','abstore')


\xml_clientdivisiondel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.14]
:: OPIS: Obsługa usunięcia związania klienta z oddziałem
::   WE: _a - obiekt ('OSOBA', 'ODB')
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<client-division-del client-eid="%1" division-eid="%2" />'[_a.OSOBA, _a.ODB];
_xml


\xml_companydel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.14]
:: OPIS: usunięcie kontrahenta
::   WE: _a - id produktu do usunięcia
::   WY: xml
::----------------------------------------------------------------------------------------------------------------------
_xml:='<company-del company-eid="%1"/>'[_a];
_xml


\xml_attributeprodattrdel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.14]
:: OPIS: wartość atrybutu produktu
::   WE: _a - id atrybutu
::       _b - id produktu
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<attribute-prod-attr-del attribute-eid="%1" product-eid="%2"/>'
      [_a, _b];
_xml


\xml_contractorpriceinddel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.14]
:: OPIS: usuwanie cennika kontrahenta
::   WE: _a - id cennika
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<contractor-price-individual-del contractor-price-eid="cprice-%1" />'
      [_a];
_xml


\xml_contractorpriceindPdel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.14]
:: OPIS: usuwanie pozycji cennika kontrahenta
::   WE: _a - id cennika
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<contractor-price-individual-product-del contractor-price-eid="cprice-%1" product-eid="%2" currency="%3" />'
      [_a, _b, _c];
_xml


\xml_contractorpriceGPdel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.14]
:: OPIS: usuwanie pozycji cennika grupowego
::   WE: _a - id cennika
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_xml:='<contractor-price-group-product-del contractor-price-eid="%1" product-eid="%2" currency="%3" />'
      [_a, _b, _c];
_xml


\checkRecipient
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DG [20.14]
:: OPIS: sprawdza dane odbiorcy i powiazane z nim magazyny
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
::sprawdzenie czy odbiorcy maja przypisane aktywne magazyny

KH_ODB.cntx_psh();
KH_ODBMG.cntx_psh();
KH_ODBMG.index('KO');
exec('setupAbstoreb2b','abstore');
_wynik:='';

_sql:='select KH_ODB.NAZ from KH_ODB where KH_ODB.REFERENCE=''%1'''[_a];
_khodb:=sql(_sql);

_sql:='select KH_ODB.NAZ NAZ, MG.SYM SYM, KH_ODBMG.* from KH_ODBMG left join KH_ODB left join MG where KH_ODBMG.ODB=''%1'''[_a];
_odbmg:=sql(_sql);

_jestMag:=0;
{? _odbmg.first()
||
   {! |?
      {? __AbStore.magazyn * _odbmg.SYM>0
      || _jestMag:=1
:      || _msg:='Magazyn: "%1" odbiorcy "%2" nie jest obsługiwany przez ABSTORE.\n\n'[_odbmg.SYM, [_a]]
      ?};
      _odbmg.next()
   !}
||
   _wynik+='Odbiorca: "%1" nie ma przypisanego żadnego magazynu.\n'[_khodb.NAZ]
?};
{? _jestMag=0 ||
   _wynik+='Odbiorca: "%1" nie ma żadnego magazynu obsługiwanego przez ABSTORE.\n'[_khodb.NAZ]
?};

KH_ODB.cntx_pop();
KH_ODBMG.cntx_pop();
_wynik


\checkContactPerson
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DG [20.14]
:: OPIS: sprawdza dane osoby kontaktowej i powiazanych z nim odbiorców
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
::sprawdzenie czy jest odbiorca , z abstore<>'', adres wypelniony e-mail unikalny
KH_ODB.cntx_psh();
KH_OSOB.cntx_psh();
KH_OSOBO.cntx_psh();
KH_OSOBO.index('OSOBA');

exec('setupAbstoreb2b','abstore');

_wynik:='';

_sql:='select KH_OSOB.NAZWISKO,KH_OSOB.REFERENCE from KH_OSOB where KH_OSOB.REFERENCE=''%1'''[_a];
_khosob:=sql(_sql);

_sql:='select KH_ODB.ABSTORE ABSTORE from KH_OSOBO left join KH_ODB where KH_OSOBO.OSOBA=''%1'''[_a];
_khosobo:=sql(_sql);

_jestOdb:=0;
{? _khosobo.first()
||
   {! |?
      {? _khosobo.ABSTORE='T' || _jestOdb:=1 ?};
      _khosobo.next()
   !}
||
   _wynik+='Osoba kontaktowa: "%1" nie ma przypisanych odbiorców.\n'[_khosob.NAZWISKO]
?};
{? _jestOdb=0 ||
   _wynik+='Osoba kontaktowa: "%1" nie ma żadnego odbiorcy dostępnego dla ABSTORE.\n'[_khosob.NAZWISKO]
?};

KH_ODB.cntx_pop();
KH_OSOB.cntx_pop();
KH_OSOBO.cntx_pop();
_wynik


\check_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.42]
:: OPIS: sprawdza główne dane pod  kątem integracji z abstore
::   WE: 'B2B' | 'B2C'
::   WY:
::----------------------------------------------------------------------------------------------------------------------
KOMM.init(500,500,'Kontrola ABSTORE'@);
{? _a='B2B' || _abs:='M.ABSTORE<>\'\'' ||  _abs:='M.ABSTOREC<>\'\'' ?};
:: sprawdznienia materiałów
_sql:='select M.KTM as KTM, M.REFERENCE as REF from M where %1'[_abs];
_sql_tab:=sql(_sql);
{? _sql_tab.first()
||
   {! |?
      _kom:=exec('checkProduct','abstore',_sql_tab.REF,_a,0);
      {? _kom<>''
      || _wynik:=_sql_tab.KTM +': ' + _kom;
         KOMM.add(_wynik,4)
      ?};
      _sql_tab.next()
   !}
?};
{? var_press('_sql_tab')>100 || obj_del(_sql_tab) ?};
:: sprawdznienia kontrahentów
{? _a='B2B'
||
   _sql:='select KH.NAZ as NAZ, KH.REFERENCE as REF from KH where KH.ABSTORE<>\'\'';
   _sql_tab:=sql(_sql);
   {? _sql_tab.first()
   ||
      {! |?
         KH.cntx_psh();
         KH.prefix();
         KH.seek(_sql_tab.REF);
         _kom:=exec('checkClient','abstore',_sql_tab.REF,0);
:: sprawdzenie odbiorców
         _sql:='select KH_ODB.NAZ as NAZ, KH_ODB.REFERENCE as REF from KH_ODB where KH_ODB.ABSTORE<>\'\'';
         _sql_odb:=sql(_sql);
         {? _sql_odb.first()
         ||
            {! |?
            KH_ODB.cntx_psh();
            KH_ODB.prefix();
            KH_ODB.seek(_sql_odb.REF);
            _kom+=exec('checkRecipient','abstore',_sql_odb.REF);
            KH_ODB.cntx_pop();
            _sql_odb.next()
            !}
         ||
            _kom+='Brak przypisanych odbiorców dostępnych dla Abstore.'
         ?};
         {? var_press('_sql_odb')>100 || obj_del(_sql_odb) ?};

         {? _kom<>''
         || _wynik:=_sql_tab.NAZ +': ' + _kom;
            KOMM.add(_wynik,4)
         ?};
         KH.cntx_pop();
         _sql_tab.next()
      !}
   ?};
   {? var_press('_sql_tab')>100 || obj_del(_sql_tab) ?}
?};
{? ~KOMM.empty() ||KOMM.select() || FUN.info('Brak nieprawidłowości'@) ?};
''


\currency
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.42]
:: OPIS: Zwraca obiekt z wartościami walut
::----------------------------------------------------------------------------------------------------------------------
_wal_pln:=exec('FindInSet','#table','SLO','KOD','PLN',,,1);
_wal_eur:=exec('FindInSet','#table','SLO','KOD','EUR',,,1);
_wal_usd:=exec('FindInSet','#table','SLO','KOD','USD',,,1);
{? __AbStore.useStore=1
|| _bank_k:=exec('param_get','abs_conf', 800125, 2)
|| _bank_k:=exec('param_get','abs_conf', 800225, 2)
?};
_bank:=exec('FindInSet','#table','SLO','KOD',_bank_k,,,1);
TKRS.cntx_psh();
TKRS.index('TKRS_DT');
TKRS.prefix(_bank,_wal_pln);
TKRS.last();
_tkrs:=TKRS.ref();
TKRS.cntx_pop();
_p_eur:=exec('FindInSet','#table','KRS','KRS_WAL',_wal_eur,_tkrs,"KRS.SR");
_p_usd:=exec('FindInSet','#table','KRS','KRS_WAL',_wal_usd,_tkrs,"KRS.SR");

_cur:=obj_new('WPLN','WEUR','WUSD','PEUR','PUSD');
_cur.WPLN:=_wal_pln;
_cur.WEUR:=_wal_eur;
_cur.WUSD:=_wal_usd;
_cur.PEUR:=_p_eur;
_cur.PUSD:=_p_usd;
_cur


\group_discount
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.42]
:: OPIS: Zwraca procent zniżki dla cennika grup kontrahentów
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
TAR.cntx_psh();
TAR.index('GRKH');
TAR.prefix(__AbStore.oddz,'S',GRKH.ref());
{? TAR.first()
||
   {!|?
      {? TAR.OD<=date() & (TAR.DO>=date() | TAR.DO=date(0,0,0)) &  TAR.PRC>_wyn
      ||
         _wyn:=TAR.PRC
      ?};
      TAR.next()
   !}
?};
TAR.cntx_pop();
_wyn


\kh_hash
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.14]
:: OPIS: Zwraca informację czy komunikat o tej treści był już wysłany
::   WE: _a - nazwa pola
::       _b - hashowany plik
::----------------------------------------------------------------------------------------------------------------------
_wyn:=1;
KH_DOD.cntx_psh();
KH_DOD.index('KH_DOD');
KH_DOD.prefix(REF.FIRMA,KH.ref());
{? KH_DOD.first()
||
   _json:=KH_DOD.memo_txt(0,1,'ABS_HASH');
   {? _json='' || KH_DOD.cntx_pop(); return(1) ?};
   {? var_press('__tab_h')>100 || obj_del(__tab_h) ?};
   __tab_h:=json_parse(_json);
   {? type_of(__tab_h)=117 & var_pres(_a, __tab_h)>0
   ||
      {? ($('__tab_h.'+_a))()=hash(_b,'sha256') || _wyn:=0 ?}
   ?}
?};
{? var_press('__tab_h')>100 || obj_del(__tab_h) ?};
KH_DOD.cntx_pop();
_wyn


\kh_hash_put
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.14]
:: OPIS: Zapisuje informację o wysłanym komunikacie
::   WE: _a - nazwa pola
::       _b - hashowany plik
::----------------------------------------------------------------------------------------------------------------------
KH_DOD.cntx_psh();
KH_DOD.index('KH_DOD');
KH_DOD.prefix(REF.FIRMA,KH.ref());
{? KH_DOD.first()
||
   _json:=KH_DOD.memo_txt(0,1,'ABS_HASH');
   {? var_press('__tab_h')>100 || obj_del(__tab_h) ?};
   {? _json<>'' || __tab_h:=json_parse(_json) ?};
   {? ~(var_press('__tab_h')=117 & var_pres(_a, __tab_h)>0)
   ||
      {? var_press('__tab_h')>100 || obj_del(__tab_h) ?};
      _json:='{"CPL":""';
      KH_ODB.cntx_psh();
      KH_ODB.index('KH_ODB');
      KH_ODB.prefix(KH.ref());
      {? KH_ODB.first()
      ||
         {!|?
            _json+=',"%1":""'[$KH_ODB.ref()];
            KH_ODB.next()
         !}
      ?};
      KH_ODB.cntx_pop();
      _json+='}';
      __tab_h:=json_parse(_json)
   ?};
   {? var_press('__tab_h')=117 & var_pres(_a, __tab_h)>0
   ||
      ($('__tab_h.'+_a))():=hash(_b,'sha256');
      KH_DOD.memo_set(json_obj(__tab_h),'ABS_HASH');
      KH_DOD.memo_put(,'ABS_HASH')
   ?}
?};
{? var_press('__tab_h')>100 || obj_del(__tab_h) ?};
KH_DOD.cntx_pop()


\xml_order_sync
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [20.42]
:: OPIS: xml do aktualizacji statusu zamówienia
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_press('IDABSTOR',_a)<0 || return('') ?};

ZK_N.cntx_psh();
ZK_N.prefix();
{? ~ZK_N.seek(_a.REF, ref_name(_a.REF)) || ZK_N.cntx_pop();return('') ?};
{? ZK_N.IDABSTOR=0 || ZK_N.cntx_pop();return('') ?};
ZK_P.cntx_psh();
ZK_P.use('zkpoz' + (5-ZK_N.name()));
ZK_P.index('NAG');
ZK_P.prefix(ZK_N.ref());
{? ~ZK_P.first() || ZK_N.cntx_pop();ZK_P.cntx_pop();return('') ?};
SLO.cntx_psh();
SLO.prefix();
M.cntx_psh();

_dt:=xml_valu(date())+'T'+xml_valu(time());
_xml:='
<order-synchronize
order-iid="%1"
order-response-number="res"
order-response-date="%2"
base-currency="PLN"
count-direction="%3"
status-code="%4"
order-base-net-sum="%5"
order-base-gross-sum="%6">
<attribute value="%7" eid="delivery-date"/>
<comment>"%8"</comment>

%9

</order-synchronize>'[
$ZK_N.IDABSTOR,
_dt,
{? __AbStore.useStore=1 || 'net' || 'gross' ?},
ABS_STA.cntx_psh();
_sta:=ZK_N.ABS_STA().STATUS;
ABS_STA.cntx_pop();
_sta,
form(ZK_N.NETTO,,2,'9.'),
form(ZK_N.BRUTTO,,2,'9.'),
gsub($ZK_N.DT,'/','-'),
xml_valu(9000+gsub(ZK_N.memo_txt(,1,'UW'),'\n','<br>')),
(_zk_p:='';
:: możliwe wysłanie tylko jednej sekcji payment-delivery-position
_transp:=1;

{!|?
   {? ZK_P.M().RODZ='U'
   & (__AbStore.useStore=1 & ZK_P.M().KTM=exec('param_get','abs_conf', 800122, 2)
   | __AbStore.useStore=0 & ZK_P.M().KTM=exec('param_get','abs_conf', 800222, 2))
   ||
      _zk_p+='
      <payment-delivery-position
      base-price-net="%1"
      base-price-gross="%2"
      vat="%3"
      vat-value="%3"
      />'
      [
      form(ZK_P.CN,,2,'9.'),
      form(ZK_P.CB,,2,'9.'),
      gsub(ZK_P.SV().KOD-1,' ','')
      ];
      _transp:=0
   ?};
   ZK_P.next() & _transp
!};

ZK_P.first();
{!|?
   {? ZK_P.M().RODZ='T'
   & (__AbStore.useStore=1 & ZK_P.M().ABSTORE='T'
   | __AbStore.useStore=0 & ZK_P.M().ABSTOREC='T')
   ||
      _zk_p+='
      <product-position-offer
      %1
      type="DEFAULT"
      product-eid="%2"
      base-price-net="%3"
      base-price-gross="%4"
      total-base-price-net="%5"
      total-base-price-gross="%6"
      vat="%7"
      vat-value="%7"
      quantity="%8"
      />'
      [_wyn:=
      {? ZK_P.LOTUSID<>''
      || 'product-position-iid="%1"'[ZK_P.LOTUSID]
      || 'product-position-eid="%1"'[ZK_P.uidref()]
      ?};_wyn,
      $ZK_P.M,
      form(ZK_P.CN,,2,'9.'),
      form(ZK_P.CB,,2,'9.'),
      form(ZK_P.NETTO,,2,'9.'),
      form(ZK_P.BRUTTO,,2,'9.'),
      gsub(ZK_P.SV().KOD-1,' ',''),
      gsub($ZK_P.ILZ,',','.')
      ]
   ?};
   ZK_P.next()
!};

_zk_p)
];

ZK_N.cntx_pop();
ZK_P.cntx_pop();
SLO.cntx_pop();
M.cntx_pop();
_xml


\send_Z_stock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.14]
:: OPIS: komunikat przesyłający zerowy stan magazynowy produktu
::----------------------------------------------------------------------------------------------------------------------
{? __AbStore.useStore=0 || return('') ?};

_stan:=obj_new('M','SD','MAG');
_mag:=spli_str(__AbStore.magazyn,',');
_max:=obj_len(_mag);
{? _max=0 || return('') ?};
_int:=1;
_xml:='';

{! |?
   _stan.M:=$M.ref();
   _stan.SD:='0';
   _stan.MAG:=_mag[_int];
   _xml+=exec('xml_productavailability', 'abstore', _stan, 1);
   _int+=1;
   _max>=_int
!};
_xml


\FinSet
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.14]
:: OPIS: Wysłanie faktury i usunięcie pojedyńczego rozrachunku
::   WY:  kod błędu (200 = ok)
::----------------------------------------------------------------------------------------------------------------------
_settl:=obj_new('REF','SYM_ROK','SYM');
exec('SinvoiceByOP','abstore');
exec('send_unisync','abstore','OP',_settl,'','xml_invoicedel',0,0,0,1);
exec('send_unisync','abstore','OP',_settl,'','Xsettlementdel',0,1,0,1)


\xml_p_min_price
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.14]
:: OPIS: Treść komunikatu z ceną mimalną
::----------------------------------------------------------------------------------------------------------------------
_m:=$M.ref();
_m_sv:=exec('vat_hist','abstore');
_wart:=spli_str(|_m_sv,' ')[1];
_vat:=#gsub(gsub(_wart,'%',''),',','.');
_cmin_n:={? var_press('_a')=type_of(1) & _a=0 || '0' || form(MDOST.CMIN,,2,'9.')  ?};
_cmin_b:={? var_press('_a')=type_of(1) & _a=0 || '0' || form((MDOST.CMIN+(_vat*MDOST.CMIN)/100),,2,'9.') ?};
_xml:='<product-minimal-price product-eid="%1" base-net="%2" base-gross="%3"/>'
[
_m,
_cmin_n,
_cmin_b
];
_xml


\p_min_price
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.14]
:: OPIS: Komunikat z ceną mimalną
::   WE: _a - referencja M
::----------------------------------------------------------------------------------------------------------------------
_wyn:='';
M.cntx_psh();
MDOST.cntx_psh();
SLO.cntx_psh();
{? var_press('_a') > 100 & var_press('M',_a)=2
||
   {? ~M.seek(_a.M)
   ||
      MDOST.cntx_pop();
      SLO.cntx_pop();
      M.cntx_pop();
      return(_wyn)
   ?}
?};
MDOST.index('M');
MDOST.prefix('S',M.ref());
{? MDOST.first
||
   {!|?
      {? MDOST.WAL().KOD='PLN'
      ||
         _wyn:=exec('xml_p_min_price','abstore');
         MDOST.cntx_pop();
         SLO.cntx_pop();
         M.cntx_pop();
         return(_wyn)
      ?};
      MDOST.next()
   !}
?};
{? _wyn='' & ((var_press('_b')=type_of(1) & _b=1) | (var_press('_a') > 100 & var_press('M',_a)=2))
||

   _wyn:=exec('xml_p_min_price','abstore',0)

?};
MDOST.cntx_pop();
SLO.cntx_pop();
M.cntx_pop();

_wyn


\p_min_p_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.14]
:: OPIS: Komunikat z ceną mimalną
::   WE: _a - referencja M
::----------------------------------------------------------------------------------------------------------------------
exec('p_min_price','abstore',_a,1)


\sync_min_price
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.14]
:: OPIS: obsługa ceny minimalnej przez synchro
::   WY:  kod błędu (200 = ok)
::----------------------------------------------------------------------------------------------------------------------
_product:=obj_new('REF','M');
exec('send_unisync','abstore','MDOST',_product,'p_min_price','p_min_p_del',0,1,0,1)


\po_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.37]
:: OPIS: Dezaktywacja ofert indywidualnych
::----------------------------------------------------------------------------------------------------------------------
exec('setupAbstoreb2b','abstore');
_act:={? _b || 'true' || 'false' ?};
_result:=200;
{? __AbStore.mergeOffer
||
::lista odbiorcow z ustawionym ABSTORE<>''
   _sql:='select KH_ODB.REFERENCE as REF, KH_ODB.*, KH.KOD as KH_KOD from KH_ODB
      join KH using(KH.REFERENCE,KH_ODB.KH)
      where KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>''''
      and KH.REFERENCE=\'%1\''[$_a];
   _KH_ODB:=sql(_sql);
   {? _KH_ODB.first()
   ||
      {!|?
            {? var_press('_file')>0 || &_file ?};
            _file:=exec('create_msgfile','abstore', 'personalOffer');
::generowanie oferty dla wszystkich magazynow przypisanych do odbiorcy
            _sql:='select KH_ODBMG.ODB as KH_ODB, MG.SYM as MG from KH_ODB
                            join KH_ODBMG using(KH_ODBMG.ODB,KH_ODB.REFERENCE)
                            join MG using(MG.REFERENCE,KH_ODBMG.MG)
                            join :_a X using(X.SYM,MG.SYM)
                            where KH_ODB.REFERENCE=''%1'' and KH_ODB.ABSTORE<>'''''[_KH_ODB.REF];
            _tabMG:=sql(_sql,__AbStore.tabMG);
::zapis naglowkow ofert na magazynach
            _xml:='';
            {? _tabMG.first ||
               {! |?
                  _nazwa:='OFERTA DEDYKOWANA';
                  _kod:='PO-'+_KH_ODB.KH_KOD+'-'+_KH_ODB.KOD+'-'+_tabMG.MG;
                  _xml:=exec('xml_po_act','abstore', _kod, _act);
                  fwrite(_file,maz_utf8(_xml));
                  _tabMG.next()
               !}
            ?};
            &_tabMG;
            exec('write_filefooter','abstore',_file);
            _result:=exec('http_send','abstore',_file,'PO_ACT_'+_KH_ODB.KOD);
            {? _file.is_open() || _file.fclose() ?};
            {? var_press('_file')>100 || obj_del(_file) ?};
           _KH_ODB.next() & (_result=200 | _result=201)
      !}
   ?}
||
::lista odbiorcow z ustawionym ABSTORE<>''
   _sql:='select KH_ODB.REFERENCE as REF, KH_ODB.*, KH.KOD as KH_KOD, KH.REFERENCE as KH_REF, KH.STR_OFE as OFE from KH_ODB
      join KH using(KH.REFERENCE,KH_ODB.KH)
      where KH_ODB.ABSTORE<>'''' and KH.ABSTORE<>''''
      and KH.REFERENCE=\'%1\''[$_a];
   _KH_ODB:=sql(_sql);
   {? _KH_ODB.first()
   ||
      {! |?
            {? var_press('_file')>0 || &_file ?};
            _file:=exec('create_msgfile','abstore', 'personalOffer');

::generowanie oferty dla wszystkich magazynow przypisanych do odbiorcy
            _sql:='select KH_ODBMG.ODB as KH_ODB, MG.SYM as MG from KH_ODB
                            join KH_ODBMG using(KH_ODBMG.ODB,KH_ODB.REFERENCE)
                            join MG using(MG.REFERENCE,KH_ODBMG.MG)
                            join :_a X using(X.SYM,MG.SYM)
                            where KH_ODB.REFERENCE=''%1'' and KH_ODB.ABSTORE<>'''''[_KH_ODB.REF];
            _tabMG:=sql(_sql,__AbStore.tabMG);
            _tbO:=exec('get_divisionofferlist','abstore',_KH_ODB.REF,_KH_ODB.KH);

::zapis naglowkow ofert na magazynach
            _xml:='';
            {? _tbO.first() & _tabMG.size()>0
            ||
               {! |?
                  _tabMG.first();
                  {! |?
                     _nazwa:=_tbO.NAZ;
                     _kod:='PO-'+_tbO.KOD+'-'+_KH_ODB.KH_KOD+'-'+_KH_ODB.KOD+'-'+_tabMG.MG;
                     _kod:=gsub(_kod,' ','');
                     _xml:=exec('xml_po_act','abstore', _kod, _act);
                     fwrite(_file,maz_utf8(_xml));
                     _tabMG.next()
                  !};
                  _tbO.next()
               !}
            ?};
            &_tbO;
            &_tabMG;
            exec('write_filefooter','abstore',_file);
:: sprawdzenie czy komunikat został już wysłany
            _result:=exec('http_send','abstore',_file,'PO_ACT_'+_KH_ODB.KOD);
            {? _file.is_open() || _file.fclose() ?};
            {? var_press('_file')>100 || obj_del(_file) ?};
            _KH_ODB.next() & (_result=200 | _result=201)
      !}
   ?}
?};
_result


\xml_po_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.37]
:: OPIS: Dezaktywacja ofert indywidualnych
::----------------------------------------------------------------------------------------------------------------------
_xml:='<personal-offer-activity offer-eid="%1" activity="%2" />'[_a, _b];
_xml


\send_ver_id
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.37]
:: OPIS: Aktualizacja wersji webserwisów
::   WE: Abstoreb2b / Abstoreb2c
::----------------------------------------------------------------------------------------------------------------------
($('exec(''setup%1'',''abstore'')'[_a]))();
_par_v:={? _a='Abstoreb2b' || 800119 || 800219 ?};
_version_id:=exec('param_get','abs_conf', _par_v, 2);
_xml:='<?xml version="1.0" encoding="UTF-8"?>
<start-conversation xmlns="http://assecobs.com/ns/a4b" account-id="%1"
conversation-id="%2"
version-id="%3"/>'[__AbStore.accId,__AbStore.convId,_version_id];
_result:=exec('http_send','abstore', _xml,'start-conversation')


\prod_tabRef
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.37]
:: OPIS: Sprawdza czy dany rekord w synchro był wysłany
::----------------------------------------------------------------------------------------------------------------------
{? __AbStore.tabRef.size()=0 | var_press('_a')<>2 || return(0) ?};
_sql:='select * from  :_a A where A.REF=\':_b\'';
_tab:=sql(_sql, __AbStore.tabRef, _a);
_tab.size()


\sync_id
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [21.37]
:: OPIS: id ostatnie wpisu z synchro
::----------------------------------------------------------------------------------------------------------------------
_id:={? var_press('_a')>=0 || _a || '0' ?};
{? _id='0' ||
   _sql:='select max(ID) as MAXID from @SYNC join SYNC_PD where SYNC_PD.SYM=''%1'''[__AbStore.synchro];
   _tb:=sql(_sql);
   _tb.first();
   {? _tb.MAXID<>'' ||  _id:=_tb.MAXID ?}
?};
_id


\address
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [22.26]
:: OPIS: formatuje adres
::   WE: _a - ulica
::       _b - dom
::       _c - lokal
::----------------------------------------------------------------------------------------------------------------------
_address:='';
_address+=_a;
_address+=' '+_b;
_address+={? _b='' || _c || {? _c='' || '' || '\\'+_c ?} ?};
xml_valu(_address)


\SinvoiceByOP
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [RR.xx]
:: OPIS:  wysyla nowo zaksięgowane faktury
::   WY:  kod błędu (200 = ok)
::----------------------------------------------------------------------------------------------------------------------
OP.cntx_psh();
DOKUM.cntx_psh();DOKUM.index('DOKUM');
FAKS.cntx_psh();
KH.cntx_psh();
KH_ODB.cntx_psh();
ROK_F.cntx_psh();
KH_DOD.cntx_psh();

_tabname:='OP';
_il_rec:=0;
_firma:='';
_repl:=0;
_result:=200;
_cnt:=0;
_tab:=exec('synchro_get','abs_conf', __AbStore.synchro, _tabname, _il_rec, _firma, _repl);
_rodz:='';
_result:=200;
_faks_ref:=null();

SKID.ROK_F:=exec('zwrrok_f','okresy',date());
{? SKID.ROK_F<>null || OP.use('operac'+SKID.ROK_F().KOD); OP.prefix() ?};

{? _tab.first()
||
   {! |?
      _faks_ref:=null();
      {? _tab.RODZ='del' ||
:usuwanie faktur
         ~~
      ||
::add/put
         {? OP.name()=ref_name(_tab.REF) & OP.seek(_tab.REF) &
         (
            _names:= FAKS.names;
            {? _names.first
            ||
               {!|?
                  FAKS.use(_names.NAME);
                  FAKS.index('FAK_SYM');
                  FAKS.prefix('S',OP.SYM,);
                  {? FAKS.first() || _faks_ref:=FAKS.ref() ?};
                  _faks_ref=null() & _names.next
               !}
            ?};
            VAR_DEL.delete(_names);
            &_names;
            _faks_ref<>null()
         )
         & FAKS.KH<>null & FAKS.KH().ABSTORE<>''
         & FAKS.KH_ODB<>null & FAKS.KH_ODB().ABSTORE<>''
:: sprawdzenie czy jest zezwolenie na wysłanie e-faktury
         & (KH_DOD.index('KH_DOD'); KH_DOD.prefix(REF.FIRMA,FAKS.KH); KH_DOD.first())
         & (   __AStore.eFak='W' |
              (__AStore.eFak='E' & KH_DOD.EFAKTURA='T') |
              (__AStore.eFak='B' & KH_DOD.EFAKTURA='B') |
              (__AStore.eFak='EB' & (KH_DOD.EFAKTURA='T' | KH_DOD.EFAKTURA='B')))
:: sprawdzenie czy dla klientów B2C (dla hybrydy)
         |
         _faks_ref<>null()
         & FAKS.KH<>null & FAKS.KH().ABSTOREC<>''
         & FAKS.KH().LOTUSUID<>''
:: sprawdzenie czy jest zezwolenie na wysłanie e-faktury
         & (KH_DOD.index('KH_DOD'); KH_DOD.prefix(REF.FIRMA,FAKS.KH); KH_DOD.first())
         & (   __AStore.eFak='W' |
              (__AStore.eFak='E' & KH_DOD.EFAKTURA='T') |
              (__AStore.eFak='B' & KH_DOD.EFAKTURA='B') |
              (__AStore.eFak='EB' & (KH_DOD.EFAKTURA='T' | KH_DOD.EFAKTURA='B')))
         ||
            {? (DOKUM.prefix(REF.FIRMA,$FAKS.ref(),);DOKUM.first())
            ||
               _result:=exec('send_invoice','abstore');
               {? _result=200
               || exec('sync_delid','abstore', _tab.ID);
                  exec('log_write','abstore','','send_invoices: ' + $FAKS.ref(),_result)
               || exec('log_write','abstore','','send_inv_error: ' + $FAKS.ref(),_result)
               ?}
            ?}
         ||
            exec('sync_delid','abstore', _tab.ID)
         ?}
      ?};
      _result=200 & _tab.next
   !}
?};

ROK_F.cntx_pop();
OP.cntx_pop();
DOKUM.cntx_pop();
FAKS.cntx_pop();
KH.cntx_pop();
KH_ODB.cntx_pop();
KH_DOD.cntx_pop();
_result

:Sign Version 2.0 jowisz:1045 2023/09/06 12:34:10 36eede1b3482cc8133d22b0d18565dc2894569807d007aeaa2015caef804ec53007829a965940cef0e802f9bf07abe8aee9c73af00ba66535e2c5633602842ce23f3bef19c9384e48727db03ede7d080d7ecf1508a487afad427060cc9f1bee49ce91b608c2af290a02230af1473f6d6a157f3e7c0908fc2d66c93b45722a58a
