:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: lista_plac.fml
:: Utworzony: 1998/06/08
:: Autor:
::======================================================================================================================
:: Zawartość: Definicje funkcji i deklaracje obiektów wykorzystywanych do obsługi list płac.
::======================================================================================================================


\czy_prac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Sprawdza przynależność pracownika do listy płac. Weryfikacja odbywa się dla bieżących rekordów tabel P i O.
::   WE: _a - Czy w sprawdzeniu pomijać charakter pracy?
::          0 - Nie [domyślnie]
::          1 - Tak, pomijać.
::   WY: 1 - wynagrodzenie pracownika można naliczyć na liście,
::       0 - pracownik nie powinien być uwzględniony na liście
::  OLD: \czy_prac/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
{? P.F_ZATR<>O.F_ZATR
|| return(0)
?};
_stop:=date(O.R,O.M,0);
{? P.DZA>_stop | (P.DZ<>date(0,0,0) & P.DZ<date(O.R,O.M,1))
|| return(0)
?};

_test:=0;
H.cntx_psh();
H.index('_HISTDAT');
H.prefix(P.ref());

_TAB:={? H.find_le(_stop) || H || P ?};
{? {? P.F_ZATR().KOD='P' & {? var_pres('_a')=type_of(0) || ~_a || 1 ?}
   || (1+_TAB.CP().S)=(1+O.T().T)
   || 1
   ?}
|| _test:=(_TAB.WYDZIAL().SCIEZKA*O.WYDZIAL().SCIEZKA)
?};
H.cntx_pop();

_test


\czy_zlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.30]
:: OPIS: Sprawdza przynaleznosc pracownika do listy plac. Weryfikacja odbywa sie dla biezacych rekordow tabel P i O.
::   WY: 1 - wynagrodzenie pracownika mozna naliczyc na liscie, 0 - pracownik nie powinien byc uwzgledniony na liscie
::  OLD: \czy_zlec/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
P.F_ZATR().KOD='Z'


\wybierz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Ustawia kontekst pracy dla wskazanej listy.
::   WE: _a [_O] - wskazanie nagłówka listy płac
::       [_b] [int] opcjonalnie - 1 - z weryfikacją listy płac
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_verify:=var_pres('_b')=type_of(0) & _b;
SEEK.O:=_a;
SEEK.O();

F_ZATR.cntx_psh();
_f_zatr:=O.F_ZATR().KOD;
F_ZATR.cntx_pop();

exec('dekl','lista_plac');
exec('ustaw','lista_plac',FUNKCJE,_f_zatr);

{? VAR.JESTLIST<>0
|| FUNKCJE.ZAMKLIST();
   FUNKCJE.NUM_DATE(0)
?};

FUNKCJE.OTWOLIST();
__FOLP.fill(O.F);

RAPLS.ustaw();

LICZ.Build();
LICZRHS.Build();

FUNKCJE.NUM_DATE(1);
:: Polski ład zmiana od 1.07.2022
{? O.RP>2022
|| FUNKCJE.PL_NEW:=1
|| _par334:=exec('get_par_date','parametr',334);
   FUNKCJE.PL_NEW:=_par334>date(0,0,0) & _par334<=O.D
?};

{? _f_zatr='P'
|| _param:=exec('get_par','#parametr',266);
   {? type_of(_param)=type_of('')
   || {? +_param=10 & #(4+_param)>0 & #(2+(5-_param))>0
      || _param:=date(#(4+_param),#(2+(5-_param)),1)
      || _param:=date(0,0,0)
      ?};
      {? _param>date(0,0,0) & _param<=date(O.RP,O.MP,1)
      || FUNKCJE.PODATEK:=1;
         _param:=exec('get_par','#parametr',267);
         {? type_of(_param)=type_of('') & _param='T' & _verify
         || exec('weryfikuj_lp_O','lista_plac')
         ?}
      || FUNKCJE.PODATEK:=0
      ?}
   || FUNKCJE.PODATEK:=0
   ?}
|| FUNKCJE.PODATEK:=0
?};

exec('__KAL','object');
__KAL.set_cal(O.T().KA);

exec('ustaw_maski','godziny',O.R,O.M);

exec('dla_listy','stalesys',O.ref());
~~


\czy_mod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Sprawdza, czy i w jakim zakresie lista składników wynagrodzenia współpracownika może być modyfikowana.
::   WE: _a [_P lub _LS lub _RH] - wskazanie współpracownika, składnika listy płac lub rachunku do umowy
::       _b [_O] - wskazanie nagłówka listy płac (ignorowany jeśli _a jest składnikiem listy płac lub rachunkiem)
::       _c [NUMBER] - Przetwarzanie wsadowe (bez komunikatów / dialogów) [0*/1].
::   WY: tablica zawierająca informacje o dostępności akcji
::  OLD: \rh_nie_aktywny/zlec_rh.fml
::  OLD: \nie_zasilek/os_nieob.fml
::  OLD: \ls_popraw/listplac.fml
::  OLD: \ls_usun/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
_akc:=obj_new(
   'status',
:: stan akcji dla wybranego składnika
   'dolacz','popraw','usun','zablokuj','wycofaj',
:: stan akcji dla całej listy płac
   'oblicz','przelicz','usun_skl'
);
{? var_pres('_b')<>type_of(null)
|| _b:=null
?};
_batch:=var_pres('_c')=type_of(0) & _c;

_ok:=1;
{? var_pres('_a')<>type_of(null) | _a=null()
|| _ok:=0

|? ref_tab(_a)=LS
|| SEEK.LS:=_a;
   SEEK.LS();
   SEEK.P:=LS.P;
   SEEK.O:=LS.O;
   SEEK.R:=LS.RB;
   SEEK.RH:=LS.RH

|? ref_tab(_a)=RH
|| SEEK.RH:=_a;
   SEEK.RH();
   SEEK.P:=RH.ZLE().P;
   SEEK.O:=RH.O;
   SEEK.R:=null;
   SEEK.LS:=null

|? ref_tab(_a)=P & _b<>null & ref_tab(_b)=O
|| SEEK.P:=_a;
   SEEK.O:=_b;
   SEEK.R:=null;
   SEEK.LS:=null;
   SEEK.RH:=null

|| _ok:=0
?};

{! _ndx:=1..obj_len(_akc)
|! _akc[_ndx]:=_ok
!};
{? ~_ok
|| return(_akc)
?};

_off:="
   _a.status:=_b;
   {! _ndx:=2..obj_len(_a)
   |! _a[_ndx]:=0
   !}
";

SEEK.P();
SEEK.O();
SEEK.R();
SEEK.LS();
SEEK.RH();

{? O.Z='T' & SEEK.RH=null()
|| _off(_akc,-2)

|? O.F_ZATR<>P.F_ZATR
|| _off(_akc,-1)

|? O.F_ZATR().KOD='P' & exec('czy_lista_z_nkor','nieobecnosc',1)
|| _off(_akc,-4)

|? exec('jest_storno_p','lista_pow',O.ref(),P.ref())
|| _off(_akc,-8)

|? exec('czy_storno_o','lista_pow',O.ref())
|| _off(_akc,-9)

|? SEEK.RH & (RH.BL='T' | RH.ZAS='T' | RH.DOK<>'')
|| _off(_akc,{? RH.BL='T' || -5 |? RH.ZAS='T' || -6 |? RH.DOK<>'' || -7 ?})

|? O.Z='T' & SEEK.RH<>null() & ~exec('rh_mod_258','zlec_rh',_batch)
|| _off(_akc,-2)

|? O.F_ZATR().KOD='P' & exec('blokada','oddelegowanie',O.ref(),P.ref())
|| _off(_akc,-10)

|| {? SEEK.LS<>null
   || _bl:=exec('jest_bl','lista_plac',O.ref(),P.ref());
      {? _bl<>0
      || _akc.oblicz:=0
      ?};
      {? LS.BL=0
      || {? LS.sel_size()>0 & _bl<>0
         || _akc.wycofaj:=1
         || _akc.wycofaj:=0
         ?}
      ?}
   |? _TAB:=cur_tab(1,1);
      {? type_of(_TAB)=type_of(SYSLOG) & _TAB=P
      || SEEK.O<>null & SEEK.P<>null & _TAB.sel_size()=0
      ?}
   || {? exec('jest_bl','lista_plac',O.ref(),P.ref())
      || _akc.oblicz:=0
      ?}
   ?};
   {? SEEK.R
   || {? 'T#'*R.RK
      || _akc.status:=-3;
         _akc.popraw:=0;
         _akc.usun:=0

      || {? __RUB.sys_attr(R.ref(),311,date(O.R,O.M,1))
         || _akc.status:=-3;
            _akc.popraw:=0
         ?};
         {? __RUB.sys_attr(R.ref(),312,date(O.R,O.M,1))
         || _akc.status:=-3;
            _akc.usun:=0
         ?}
      ?}
   ?}
?};

_akc


\czy_mod_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca tekst komunikatu o błędzie.
::   WE: _a [INTEGER] - kod błędu
::   WY: tekst właściwy dla kodu błędu przekazanego argumentem
::----------------------------------------------------------------------------------------------------------------------
{? _a= 1 || ''
|? _a= 0 || 'Nieokreślona lista płac lub pracownik.'@
|? _a=-1 || 'Niezgodne formy współpracy listy i współpracownika.'@
|? _a=-2 || 'Lista płac została zamknięta.'@
|? _a=-3 || 'Składnik z atrybutem uniemożliwiającym edycję.'@
|? _a=-4 || 'Lista zawiera rozliczenie korygowanych lub wycofanych nieobecności.'@
|? _a=-5 || 'Rachunek został zablokowany.'@
|? _a=-6 || 'Rachunek jest wypłatą zasiłku.'@
|? _a=-7 || 'Rachunek został zaksięgowany.'@
|? _a=-8 || 'Utworzono storno listy płac.'@
|? _a=-9 || 'Lista płac jest stornem innej listy.'@
|? _a=-10 || 'Kwota (płaca oddelegowanie) w niewłaściwej sekcji.'@
|| 'Operacja nie może być wykonana.'@
?}


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wybór nagłówka listy płac.
::   WE:  _a  [STRING] - kod dziedziny produktowej
::        _b  [STRING] - kod formy współpracy
::       [_c] [STRING] - status nagłówka (wartość pola Z):
::            '' lub '*' - wszystkie
::            'T' - zamknięte
::            'N' - otwarte
::       [_d] [STRING] - znacznik listy płac (lub jego pierwsze znaki)
::       [_e] [STRING] - lista akcji do wykluczenia w oknie WER tabeli O (domyślnie: '')
::       [_f] [INTEGER] - wymuś filtrowanie do firmy podczas pracy z grupą kapitałową, domyślnie 0
::       [_g] [STRING] - dodatkowe ograniczenie zakresu danych
::   WY: wskazanie na tablicę zawierającą:
::       OK - 1 - wybrano nagłówek, 0 - zrezygnowano
::       REF - wskazanie wybranego nagłówka, null - jeśli zrezygnowano
::       ... - wartości pól tabeli O jeśli wybrano, wartości puste zgodne co do typu
::  OLD: \rek_prz/listplac.fml
:: UWAGA! Poprawność argumentów wywołania nie jest weryfikowana.
::----------------------------------------------------------------------------------------------------------------------
_status:={? var_pres('_c')=type_of('') || _c || '' ?};
_ha:={? var_pres('_e')=type_of('') || _e || '' ?};
_wf:={? REF.FIRMA=REF.GRUPA || var_pres('_f')=type_of(0) & _f<>0 ?};
_xc:={? var_pres('_g')=type_of('') || _g || '' ?};

: parametry działania
_cntx:=obj_new('O','zmmc');
params_set('cntx',_cntx);
: wskazywana lista płac
_cntx.O:=null;
: parametry wtyczki zamknięcia listy
_cntx.zmmc:=exec('ppl_pll_zmmc_001_arg','ppl');

O.cntx_psh();
O.clear();
{? var_pres('_d')=type_of('') & _d<>''
:  ustal zgodnie ze znacznikiem
|| O.index('FFZLT');
   O.prefix(exec('ref_firma','ustawienia'),_b,);
   {? O.find_ge(-_d)
   || _cntx.O:=O.ref();
      {? _status<>'' & _status<>'*'
      || {? O.Z<>_status
         || _cntx.O:=null
         ?}
      ?}
   ?}
?};
{? _cntx.O=null & VAR.JESTLIST<>0
:  znajdź aktualnie wybraną
|| {? O.seek(VAR.LISTA,) & O.F_ZATR().KOD=_b
   || _cntx.O:=O.ref()
   ?}
?};
{? _cntx.O=null
|| O.index('LISTYPLA');
   O.prefix(exec('ref_firma','ustawienia'),_b,);
:  znajdź pierwszą w miesiącu lub ostatnią
   {? O.find_key(date~1,date~2) | O.last()
   || _cntx.O:=O.ref()
   ?}
?};
O.cntx_pop();

_def:="'OK','REF'";
{! _ni:=1..O.fld_num()
|! _def+=',\''+O.fld_acr(_ni)+'\''
!};
: bufor zwracanych wartości
_ret:=($('obj_new('+_def+')'))();
_ret.REF:=null;
_ret.OK:=0;
O.blank(1);
{! _ni:=1..O.fld_num()
|! _fld:=O.fld_acr(_ni);
   ($('_a.'+_fld+':=_b.'+_fld))(_ret,O)
!};
O.get();

: zapamiętaj aktualne onko
_org:=UD_DEF.win_sel('?');
: ustawienia dla budowy
_mode:='maximized';
_side:='NAW_MIN';
_main:='WER';

: zbuduj okno wyboru
_wnd:=UD_DEF.grp_make('Listy płac',
:  po wyświetleniu
   "  params_set(params_get());
      _typ:='PODZORG';
      _sch:=exec('domyslny','schemat',_typ);
      _skl:=exec('ud_skl_firma','schemat',_typ);
      UD_DEF.cntx_psh();
      UD_DEF.index('SYMBOL');
      UD_DEF.prefix(_sch);
      {? REF.FIRMA<>REF.GRUPA
      || exec('ud_def_root','schemat','NAW_MIN',_sch,_skl)
      ?};
      grp_disp(UD_DEF,'NAW_MIN',1,1);
      1
   ",
:  identyfikator
   'o_grp_wer',
:  położenie
   ,,
:  zamknięcie
   "UD_DEF.cntx_pop()"
);

: drzewko struktury organizacyjnej
UD_DEF.grp_sel(_wnd,UD_DEF,_side,,
:  po odświeżeniu
   $("params_set(params_get());grp_disp(O,'"+_main+"',1,1)"),
:  położenie i wysokość
   ,,18,
:  przed obsługą
   "",
:  po obsłudze
   "",
:  utrwalenie, aktywacja, wypełnienie
   0,0,_mode,
:  identyfikator
   _side,
);

: lista nagłówków przypisanych wskazanej jednostce
UD_DEF.grp_splt(_wnd,,'vertical','right',',25%');
UD_DEF.grp_sel(_wnd,O,_main,,
:  po odświeżeniu
   "  {? ~O.sel_size()
      || _lm:=exec('last_mod_get','#table',O);
         {? EDIT_VAR.O_LM=0
         || EDIT_VAR.O_LM:=_lm
         |? EDIT_VAR.O_LM<>_lm
         || EDIT_VAR.O_LM:=_lm;
            O.f_rfresh();
            win_disp()
         ?}
      ?};
      _hide:='';
      {? O.sel_size()=0
      || _hide:=
            {? REF.FIRMA<>O.FIRMA
            || 'PUZMO'
            |? O.DOK<>'' | O.T().T='SUM' & O.Z='N'
            || 'ZO'
            |? O.Z='T' | O.T().T='SUM'
            || 'Z'
            || 'O'
            ?}
      || O.cntx_psh();
         _O:=O.sel_aget();
         _loop:=_O.first();
         {!
         |? _loop & +_hide<>2
         |! {? O.seek(_O.REF,)
            || {? O.Z='T' & _hide*'Z'=0 | O.T().T='SUM' & O.Z='T' & _hide*'Z'=0 || _hide+='Z'
               |? O.Z='N' & _hide*'O'=0 | O.T().T='SUM' & O.Z='N' & _hide*'O'=0|| _hide+='O'
               |? (O.DOK<>'' | REF.FIRMA<>O.FIRMA) & (_hide*'Z'=0 | _hide*'O') || _hide+='OZ'
               ?}
            ?};
            _loop:=_O.next()
         !};
         O.cntx_pop()
      ?};
      O.actions_grayed('WER',_hide);
      grp_edisp(O,'NFO',,1)
   ",
:  położenie i wysokość
   ,,18,
:  przed obsługą
   $('exec(\'filtruj_o\',\'schemat\',\'%1\',UD_DEF.ref(),\'%2\',\'%3\',%4,\'%5\');'
     'O.f_seek(params_get().cntx.O)'
     [_a,_b,_status,$_wf,_xc]
   ),
:  po obsłudze
   "params_get().cntx.O:=O.ref()",
:  utrwalenie, aktywacja, wypełnienie
   0,0,_mode,
:  identyfikator
   _main,
:  główne
   1
);

: dodatkowe informacje o wskazywanym nagłówku
UD_DEF.grp_splt(_wnd,'right','horizontal','bottom',',66%');
UD_DEF.grp_edit(_wnd,O,'NFO',,,,,,_mode);

_kod:=__F_ZATR.O;
__F_ZATR.mod(_b,'O');

: wybór
O.cntx_psh();
O.win_edit('RED');
O.win_patt('WZO');
UD_DEF.win_sel(_wnd);
O.actions('WER',_ha);
ODD.cntx_psh();
ODD.f_clear();
ODD.prefix();
KT.cntx_psh();
KT.f_clear();
KT.prefix();
_lm:=0;
EDIT_VAR.O_LM==_lm;
{? UD_DEF.select()
|| _ret.OK:=1;
   _ret.REF:=O.ref();
   {! _ni:=1..O.fld_num()
   |! _fld:=O.fld_acr(_ni);
      ($('_a.'+_fld+':=_b.'+_fld))(_ret,O)
   !}
?};
EDIT_VAR.O_LM:=_lm;
KT.cntx_pop();
ODD.cntx_pop();
O.actions('WER',':');
O.cntx_pop();
__F_ZATR.mod(_kod,'O');

: porządki
UD_DEF.win_sel(_org);
UD_DEF.win_del(_wnd);

: zwróć wynik działania
{? _ret.OK
|| SEEK.O:=_ret.REF;
   SEEK.O()
?};
_ret


\x_lt_pt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Wzorzec symbolu listy płac
::  OLD: \LISTA/kart_pla.fml
::----------------------------------------------------------------------------------------------------------------------
'\\L9919Uuu&'


\x_lt_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
::       RWR [17.00]
::       jaws [17.00]
:: OPIS: Obsługa akcji "Wybór F3" dla pól wymagających symbolu listy płac.
::   WE: [_a] [STRING] - status nagłówków:
::            'T' - zamknięte
::            'N' - otwarte
::            wpp - wszystkie
::   WY: Symbol wybranej listy płac lub ~~ jeżeli wyboru nie dokonano.
::  OLD: \nazwlist/kart_pla.fml
::----------------------------------------------------------------------------------------------------------------------
:: dodatkowy warunek ukrywający storna
_ext:=
   'O.REFERENCE not in ( '
   '  select O_O.POD '
   '  from O_O '
   '  where O_O.FIRMA=:_a and O_O.SLO_KOD=\\\'%1\\\''
   ')'[$exec('ref_storno','ext_slo')];

O.cntx_psh();
_ret:=exec('select','lista_plac','PPL',__F_ZATR.O,{? var_pres('_a')=type_of('') || _a || '' ?},,'R',,_ext);
O.cntx_pop();

{? _ret.OK
|| _ret.LT
|| ~~
?}


\x_lt_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła po redagowaniu pola z symbolem listy płac - weryfikuje poprawność.
::   WE:
::   WY: '' - jeżeli nie podano wszystkich 8 znaków;
::       0  - jeżeli symbol nie jest poprawny lub lista jest zamknięta;
::       1  - jeżeli symbol jest poprawny i lista jest otwarta.
::  OLD: \spr_list/kart_pla.fml
::----------------------------------------------------------------------------------------------------------------------
_fld:=fld();
{? +_fld<>8
|| fld('')
|| exec('o_writable','lista_plac',_fld)
?}


\edit_var_lista_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: pkoso [2010]
:: OPIS:
::  OLD: \edit_var_lista/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
EDIT_VAR.LISTA:='Lista'


\o_writable
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Formuła sprawdza czy lista o nazwie przekazanej obowiązkowym argumentem jest otwarta.
::       Formuła wykorzystywana w kartotekach zawierających informacje o rozliczeniu zapisów na listach płac.
::   WE:  _a  [STRING]  - Symbol listy płac.
::       [_b] [INTEGER] - Wyświetlać komunikat o ewentualnym braku dostępu?
::          0 - Nie.
::          1 - Tak [domyslnie].
::   WY: 1 - Lista dostępna i otwarta lub podano znak listy różny niż 8 znaków.
::       0 - Lista nie jest dostępna (nie może być wskazana).
::  OLD: \czy_mod/kart_pla.fml
::----------------------------------------------------------------------------------------------------------------------
_message:={? var_pres('_b')=type_of(0) || _b || 1 ?};

_RetVal:='';
{? var_pres('_a')<>type_of('')
|| _RetVal:='Nieprawidłowa wartość argumentu wywołania!\nFunkcja "o_writable", biblioteka "listplac.fml".'@

|? +_a<>8
|| ~~

|? _msc:=#((_a-3)+2);
   _rok:=#((_a-5)+2);
   _typ:=_a+3;
   _rok+={? _rok>=80 || 1900 || 2000 ?};
   _msc<1 | _msc>12
|| _RetVal:='Nieprawidłowe oznaczenie listy płac (rok/miesiąc).'@

|| O.cntx_psh();
   O.index('LISTYMIE');
   O.prefix(exec('ref_firma','ustawienia'),_rok,_msc,_typ,);
   {? O.first()
   || {? O.Z='T' || _RetVal:='Lista płac "%1" jest zamknięta.'@[_a] ?}
   || _RetVal:='Nieprawidłowe oznaczenie listy płac (listy nie znaleziono).'@
   ?};
   O.cntx_pop()

?};

{? _RetVal<>'' & _message
|| FUN.info(_RetVal)
?};
_RetVal=''


\jest_ls
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Sprawdza, czy dla nagłówka istnieją jakiekolwiek składniki listy.
::   WE: _a [_O] - wskazanie nagłówka listy płac
::   WY: 1 - istnieją składniki
::       0 - brak składników
::  OLD: \CzyPusta/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
_msg:=(var_pres('_a')=type_of(0) & _a=1);
_jest:=0;

_o:=SEEK.O;
SEEK.O:=_a;

LS.cntx_psh();
LS.use(SEEK.O().LT);
LS.index('NAZWRUBR');
LS.prefix(O.FIRMA);
_jest:=LS.first();
LS.cntx_pop();

_jest


\jest_zb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.10]
:: OPIS: Sprawdza, czy lista jest uwzględniana w zestawieniach zbiorczych.
::   WE: _a [_O] - wskazanie nagłówka listy płac
::   WY: 1 - istnieją składniki
::       0 - brak składników
::   WY: 1 - jesli istnieja zestawienia zbiorcze dla listy i zawieraja jakies skladniki, 0 - w przeciwnym przypadku
::  OLD: \CzyZbiorowk/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
_TMP:=sql(
   'select O.LT as MASK, ZB_DEF.REFERENCE as DEF_REF '
   'from ZB_LISTY join '
   '     ZB_OPIS using(ZB_LISTY.OPIS,ZB_OPIS.REFERENCE) join '
   '     O using(ZB_OPIS.LISTA,O.REFERENCE), '
   '     @ZB_DEF '
   'where ZB_LISTY.LISTA=:_a and ZB_LISTY.OPIS=ZB_DEF.OPIS',
   _a
);

{? type_of(_TMP)<>type_of(SYSLOG)
|| return(1)
?};

ZB_DEF.cntx_psh();
ZB_WART.cntx_psh();

_loop:=_TMP.first();
{!
|? _loop
|! ZB_DEF.use(8+_TMP.DEF_REF);
   ZB_DEF.clear();
   {? ZB_DEF.seek(_TMP.DEF_REF)
   || ZB_WART.use('q'+(1-_TMP.MASK));
      ZB_WART.index('SKLADNIK');
      ZB_WART.prefix(ZB_DEF.ref());
      {? ZB_WART.first()
      || ZB_WART.cntx_pop();
         ZB_DEF.cntx_pop();
         return(1)
      ?}
   ?};
   _loop:=_TMP.next()
!};

ZB_WART.cntx_pop();
ZB_DEF.cntx_pop();

0


\jest_rn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.10]
:: OPIS: Sprawdza, czy lista jest wykorzystywana w rozliczeniu nieobecności.
::   WE:  _a  [_O] - wskazanie nagłówka listy płac
::       [_b] [INTEGER] - rożny od 0 - wyświetla informacje o wykorzystaniu w rozliczeniu nieobecności
::   WY: 1 - istnieją rozliczenia
::       0 - brak rozliczeń
::  OLD: \CzyRozlNie/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
_dialog:=(var_pres('_a')=type_of(0) & _a);

_test:=sql('
   select
      OSOBA.NAZWISKO as NAZWISKO,
      OSOBA.PIERWSZE as IMIE,
      UD_SKL.SYMBOL as WYDZIAL,
      R.RN as RN,
      R.RT as RT,
      N.OD as OD,
      N.DO as DO
   from
      N join
      P using (N.P,P.REFERENCE) join
      UD_SKL using (P.WYDZIAL,UD_SKL.REFERENCE) join
      OSOBA using (P.OSOBA,OSOBA.REFERENCE) join
      R using (N.NB,R.REFERENCE)
   where
      N.O=:_a
   order by
      NAZWISKO,IMIE,WYDZIAL,OD
',O.ref);

_result:=_test.size();

{? _dialog & _result & FUN.ask(
      'Lista płac jest wykorzystywana jako wycofująca nieobecności.\n'
      'Czy wyświetlić szczegółowe informacje?'@
   )
|| _wnd:=_test.mk_sel('Nieobecności'@,'T',0);
   _test.win_fld(_wnd,,'NAZWISKO',,,-30,,,'Nazwisko'@,,'Aktualne nazwisko'@);
   _test.win_fld(_wnd,,'IMIE',,,-20,,,'Imię'@,,'Pierwsze imię'@);
   _test.win_fld(_wnd,,'WYDZIAL',,,-16,,,'Jednostka organizacyjna'@,,'Jednostka organizacyjna'@);
   _test.win_fld(_wnd,,'RN',,,-5,,,'Kod'@,,'Kod nieobecności'@);
   _test.win_fld(_wnd,,'RT',,,-20,,,'Nazwa'@,,'Nazwa nieobecności'@);
   _test.win_fld(_wnd,,'OD',,,-10,,,'Od dnia'@,,'Data rozpoczęcia'@);
   _test.win_fld(_wnd,,'DO',,,-10,,,'Do dnia'@,,'Data zakończenia'@);
   _test.win_sel(_wnd);
   _test.select()
?};

_result


\get_stat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.41]
:: OPIS: Zwraca status listy.
::   WE: _a [_O] - wskazanie nagłówka listy płac
::       _b [STRING] - kod statusu
::   WY: 0 - nie udało się znaleźć rekordu właściwego dla statusu, 1 - rekord statusu został znaleziony
::  OLD: \get_stat/listplac.fml
:: UWAGA: poprawnosc argumentow wywolania nie jest weryfikowana
::----------------------------------------------------------------------------------------------------------------------
O_STAT.index('KOD');
O_STAT.prefix(_a);
O_STAT.find_key(_b,_b)


\add_stat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.41]
:: OPIS: Dodaje status listy.
::   WE: _a [_O] - wskazanie nagłówka listy płac
::       _b [STRING] - kod statusu
::       _c [REAL] - wartość statusu
::       [_d] - krotki opis
::  OLD: \add_stat/listplac.fml
:: UWAGA: poprawność argumentów wywołania nie jest weryfikowana
::----------------------------------------------------------------------------------------------------------------------
O_STAT.prefix(_a);
O_STAT.blank(1);
O_STAT.O:=_a;
O_STAT.SLO_KOD:=exec('kod','ext_slo','LISTAT',_b);
O_STAT.WARTOSC:=_c;
O_STAT.DATA:=date();
O_STAT.GODZ:=time();
O_STAT.KTO:=OPERATOR.USER;
O_STAT.OPIS:={? var_pres('_d')=type_of('') || _d || '' ?};
O_STAT.add()


\put_stat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.41]
:: OPIS: Aktualizuje status listy.
::   WE:  _a  [_O] - wskazanie na nagłówek listy płac
::        _b  [STRING] - kod statusu
::        _c  [REAL] - wartość statusu
::       [_d] [STRING] - krotki opis
::  OLD: \put_stat/listplac.fml
:: UWAGA: poprawność argumentów wywołania nie jest weryfikowana
::----------------------------------------------------------------------------------------------------------------------
_opis:={? var_pres('_d')=type_of('') || _d || '' ?};

{? exec('get_stat','lista_plac',_a,_b)
|| O_STAT.WARTOSC:=_c;
   O_STAT.OPIS:=_opis;
   O_STAT.DATA:=date();
   O_STAT.GODZ:=time();
   O_STAT.KTO:=OPERATOR.USER;
   O_STAT.put()
|| exec('add_stat','lista_plac',_a,_b,_c,_opis)
?}


\del_stat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [12.41]
:: OPIS: Usuwa status listy
::   WE: _a - wskazanie na naglowek listy plac
::       _b - kod statusu
:: UWAGA: poprawnosc argumentow wywolania nie jest weryfikowana
::  OLD: \del_stat/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('get_stat','lista_plac',_a,_b)
|| O_STAT.del
?}


\dekl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wywołuje deklaracje wszystkich klas i tworzy obiekty potrzebne podczas naliczania listy płac.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('__RUB','object');
exec('__FOLP','object');

exec('LISTA','object');
exec('ZB_DRUK','object');

exec('dekl_licz_ls','lista_plac');
exec('dekl_licz_rh','lista_plac');

exec('dekl_dolist','lista_plac');
{? var_pres('DoList')<>type_of(@.CLASS.DoList)
|| DoList:=obj_new(@.CLASS.DoList)
?};

{? var_pres('LICZ')<>type_of(@.CLASS.LICZ)
|| LICZ:=obj_new(@.CLASS.LICZ)
?};

{? var_pres('LICZRHS')<>type_of(@.CLASS.LICZRHS)
|| LICZRHS:=obj_new(@.CLASS.LICZRHS)
?};

exec('FUNKCJE','object');
~~


\dekl_folp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Deklaracja klasy FOLP - bufora formuł obliczeniowych list płac.
::  OLD: \formobj/rubobj.fml
::----------------------------------------------------------------------------------------------------------------------
: zakończ, jeśli klasa została zadeklarowana
{? var_pres('FOLP',@.CLASS)>=100
|| return()
?};

obj_decl('FOLP',
:  obiekt wspomagający
   obj_fld('BUFF',~~),
:  typ formuł płacowych
   obj_fld('type',''),
:  treści formuł
   obj_fld('body',~~),
:  klasy rubryk formuł
   obj_fld('cls',~~),

   obj_meth('__init',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Tworzy obiekt klasy __FOLP.
::----------------------------------------------------------------------------------------------------------------------
      exec('__RUB','object');
      _a.BUFF:=exec('folp_std_buf','lista_plac');
      _a.alloc()
   "),

   obj_meth('alloc',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Rezerwuje pamięć na tablice pomocnicze.
::----------------------------------------------------------------------------------------------------------------------
      .clear();
      {? (_len:=__RUB.max())>0
      || .body:=obj_new(_len);
         .cls:=obj_new(_len);
         {! _n:=1.._len
         |! .body[_n]:=.cls[_n]:=''
         !}
      ?}
   ",-1),

   obj_meth('clear',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwalnia pamięć przydzieloną na tablice pomocnicze.
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('body',.)<>type_of(~~)
      || obj_del(.body);
         .body:=~~
      ?};
      {? var_pres('cls',.)<>type_of(~~)
      || obj_del(.cls);
         .cls:=~~
      ?};
      .type:=''
   ",-1),

   obj_meth('fill',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Wypełnia tablice pomocnicze treściami formuł i klasami składników.
::   WE: _a - typ formuł płacowych
::----------------------------------------------------------------------------------------------------------------------
      echo('Trwa wczytywanie treści formuł obliczeniowych...'@);
      .alloc();
      .type:=_a;
      {? ~(var_pres('_b')=type_of(0) & _b=1)
      || .BUFF.init();
         .BUFF.read_fml(.type);
         .BUFF.fill_buf(.type);
         _BUF:=.BUFF.BUF;
         _BUF.cntx_psh();
         _BUF.index(.BUFF.KEY.LP);
         _BUF.prefix(.type);
         _loop:=_BUF.first();
         {!
         |? _loop
         |! .body[_BUF.LP]:=_BUF.memo_txt(,1,'F');
            .cls[_BUF.LP]:=_BUF.RK;
            _loop:=_BUF.next()
         !};
         _BUF.cntx_pop();
         echo();
         .BUFF.release()
      ?}
   ",type_of('')),

   obj_meth('calc',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Wykonuje formułę płacową dla składnika o podanym kodzie.
::   WE: _a - kod składnika
::   WY: wynik formuły
:: UWAGA poprawność argumentu nie jest weryfikowana, nalezy zadbać o to, aby nie odwołać się poza dopuszczalny zakres.
::----------------------------------------------------------------------------------------------------------------------
   "($(.body[_a]))()",type_of(0))
)


\folp_std_lib
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Obsługa plików sandardowych bibliotek formuł płacowych.
::   WE:
::   WY: referencja tablicy nazwanej
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new('get_name','get_file','strip');

:: Zwraca nazwę pliku FML danego typu.
:: WE: _a [STRING] - typ formuł
:: WY: nazwa pliku bez rozszerzenia
_obj.get_name:="
   'ppl_formuly%1'[{? _a=%255 || '' || -_a ?}]
";

:: Zwraca pełną nazwę pliku FML danego typu.
:: WE: _a [STRING] - typ formuł
:: WY: nazwa pliku z rozszerzeniem
_obj.get_file:="
   .get_name(_a)+'.fml'
";

:: Usuwa wszystkie białe znaki z tekstu.
:: WE: _a [STRING] - tekst do przetworzenia
:: WY: tekst z usuniętymi białymi znakami
_obj.strip:="
   _a:=gsub(_a,'\\t','');
   _a:=gsub(_a,%10,'');
   _a:=gsub(_a,%13,'');
   gsub(_a,' ','')
";

_obj


\folp_std_buf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Tworzy pseudoobiekt do obsługi standardowych formuł obliczeniowych list płac.
::   WE:
::   WY: referencja tablicy nazwanej
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new(
:: tabela zawartości plików
   'LIB',
:: wykaz formuł standardowych
   'FML',
:: formuły obliczeniowe
   'BUF',
:: indeksy tabeli BUF
   'KEY',
:: cykl życia obiektu
   'dev','init','release',
:: odczyt zawartości plików FML
   'SRC',
   'lib_text','find_lib','read_lib',
   'add_fml','find_fml','read_fml','clear_fml',
:: obsługa pełnego zestawu formuł
   'mod_buf','fill_buf','clear_buf'
);

:: stan początkowy
_len:=obj_len(_obj);
{! _ii:=1.._len
|! _obj[_ii]:=~~
!};

:: Powiadomienie o błędzie w cyklu życia.
_obj.dev:="FUN.emsg('Obiekt jest w stanie pasywnym.'@); _a";

:: Przydzielenie wymaganych zasobów.
_obj.init:="exec('folp_std_ini','lista_plac',.)";

:: Zwolnienie przydzielonych zasobów.
_obj.release:="exec('folp_std_cls','lista_plac',.)";

:: Wsparcie ujednoliconej obsługi nazewnictwa.
_obj.SRC:=exec('folp_std_lib','lista_plac');

_obj.release();

_obj


\folp_std_cls
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Zwalnia przydzielone zasoby, wprowadza obiekt w stan pasywny.
::   WE: _a [ARRAY] - referencja pseudoobiektu (patrz folp_std_buf)
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_obj:=_a;

_table_type:=type_of(SYSLOG);

{? type_of(_obj.LIB)=_table_type
:: usuń tabelę zawartości plików
|| obj_del(_obj.LIB);
   _obj.LIB:=~~
?};

{? type_of(_obj.FML)=_table_type
:: usuń indeks standardowych formuł
|| obj_del(_obj.FML);
   _obj.FML:=~~
?};

{? type_of(_obj.BUF)=_table_type
:: usuń bufor treści formuł
|| obj_del(_obj.BUF);
   _obj.BUF:=~~
?};
{? type_of(_obj.KEY)>=100
:: usuń indeksy bufora
|| obj_del(_obj.KEY);
   _obj.KEY:=~~
?};

_obj.KEY:='';

_obj.lib_text:=".dev('')";
_obj.find_lib:=".dev(0)";
_obj.read_lib:=".dev(0)";

_obj.add_fml:=".dev(0)";
_obj.find_fml:=".dev(0)";
_obj.read_fml:=".dev(0)";
_obj.clear_fml:=".dev(~~)";

_obj.mod_buf:=".dev(0)";
_obj.fill_buf:=".dev(~~)";
_obj.clear_buf:=".dev(~~)";

~~


\folp_std_ini
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Przydziela niezbędne zasoby, wprowadza obiekt w stan aktywny.
::   WE: _a [ARRAY] - referencja pseudoobiektu (patrz folp_std_buf)
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_obj:=_a;

_table_type:=type_of(SYSLOG);
_fm_type:='STRING[%1]'[$MS.fld_len(FM,'TP')];

{? type_of(_obj.LIB)<>_table_type
:: tabela zawartości plików
|| _obj.LIB:=tab_tmp(1,
      'TP',_fm_type,,
      'FC','SYS_MEMO',
   )
?};

{? type_of(_obj.FML)<>_table_type
:: indeks formuł standardowych
|| _obj.FML:=tab_tmp(2,
      'TP',_fm_type,,
      'RN','INTEGER',,
      'F','STRING[32]',
   )
?};

{? type_of(_obj.BUF)<>_table_type
:: formuły obliczeniowe
|| _obj.BUF:=tab_tmp(2,
      'TP',_fm_type,MS.name(FM,'TP'),
      'LP','INTEGER',MS.name(R,'LP'),
      'RN','INTEGER',MS.name(R,'RN'),
      'RK','STRING[%1]'[$MS.fld_len(R,'RK')],MS.name(R,'RK'),
      'RT','STRING[%1]'[$MS.fld_len(R,'RT')],MS.name(R,'RT'),
      'ST','STRING[1]','Standardowa'@,
      'F','SYS_MEMO',MS.name(FM,'F')
   );
   {? type_of(_obj.KEY)<100
::    indeksy tabeli BUF
   || _obj.KEY:=obj_new('LP','RN');
      _obj.KEY.LP:=_obj.BUF.index('?');
      _obj.KEY.RN:=_obj.BUF.ndx_tmp('Kod'@,0,'TP',,,'RN',,)
   ?}
?};

:: Zwraca treść biblioteki formuł.
:: Należy zadbać o wczytanie treści.
:: WE: _a [STRING] - typ formuł
:: WY: odczytany tekst
_obj.lib_text:="
   {? .find_lib(_a)
   || .LIB.memo_txt(,1,'FC')
   || ''
   ?}
";

:: Wyszukuje wiersz w tabeli LIB,
:: jeśli brak zapisu, to dodaje.
:: WE: _a [STRING] - typ formuł
:: WY: 0/1 - porażka/sukces
_obj.find_lib:="
   {? ~.LIB.find_key(_a)
   || .LIB.blank();
      .LIB.TP:=_a;
      .LIB.add()
   || 1
   ?}
";

:: Odczytuje zawartość biblioteki formuł.
:: WE: _a [STRING] - typ formuł
:: WY: 0/1 - porażka/sukces
_obj.read_lib:="
   {? ~.find_lib(_a)
   || return(0)
   ?};
   _lib:=.SRC.get_file(_a);
   _obj:=fopen(_lib,'ur',1,0,1,1);
   {? ~_obj.is_open()
   || return(0)
   ?};
   _ret:=.LIB.memo_put(_obj,'FC');
   _obj.fclose();
   _ret
";

:: Dodaje wiersz w indeksie formuł.
:: WE: _a [STRING] - typ formuł
::     _b [INTEGER] - numer rubryki
:: WY: 0/1/-1 - porażka/sukces/istnieje
_obj.add_fml:="
   {? ~.find_fml(_a,_b)
   || .FML.TP:=_a;
      .FML.RN:=_b;
      .FML.F:='exec(\\'_%1\\',\\'%2\\')'[form(_b,,,'99'),.SRC.get_name(_a)];
      .FML.add()
   || -1
   ?}
";

:: Wyszukuje wiersz w indeksie formuł.
:: WE: _a [STRING] - typ formuł
::     _b [INTEGER] - numer rubryki
:: WY: 0/1 - porażka/sukces
_obj.find_fml:="
   .FML.find_key(_a,_b)
";

:: Tworzy indeks formuł biblioteki.
:: WE: _a [STRING] - typ formuł
:: WY: 0/1 - porażka/sukces
_obj.read_fml:="
   {? ~.read_lib(_a) | (_txt:=.lib_text(_a))=''
::    błąd odczytu zawartości biblioteki
   || return(0)
   ?};
   .clear_fml(_a);
:: wyrażenie oznaczające początek formuły składnika
   _pat:='\\\\r\\\\n\\\\\\\\_(\\\\d*)\\\\r\\\\n';
   _pos:=0;
   {!
   |? _rex:=regex_match(_txt,_pat,_pos);
      {? (_pos:=_rex.pos)>0 & type_of(_rex.groups)>100
      || .add_fml(_a,#form(_rex.groups[1]));
         _pos+=_rex.len
      ?};
      obj_del(_rex);
      _pos>0
   !};
   1
";

:: Usuwa indeks formuł biblioteki
:: WE: _a [STRING] - typ formuł
:: WY: ~~
_obj.clear_fml:="
   .FML.prefix(_a,);
   {? .FML.first()
   || {!
      |? .FML.del()
      !}
   ?};
   .FML.prefix()
";

:: Dodaje lub aktualizuje wiersz do bufora zestawu formuł
:: informacje o rubryce uzpełniane są dla bieżącego R.
:: Metoda "wewnętrzna", wymaga odpowiedniego kontekstu.
:: WE: _a [STRING] - typ formuł
::     _b [STRING] - standard (T/N)
::     _c [STRING] - treść formuły
:: WY: 0/1/-1 - porażka/sukces/istnieje
_obj.mod_buf:="
   {? ~.BUF.find_key(_a,R.RN)
   || .BUF.blank();
      .BUF.TP:=_a;
      .BUF.LP:=R.LP;
      .BUF.RN:=R.RN;
      .BUF.RK:=R.RK;
      .BUF.RT:=R.RT;
      .BUF.ST:=_b;
      .BUF.memo_set(_c,'F');
      .BUF.add() & .BUF.memo_put(,'F')
   || .BUF.ST:=_b;
      .BUF.memo_set(_c,'F');
      {? .BUF.put() & .BUF.memo_put(,'F')
      || -1
      ?}
   ?}
";

:: Aktualizuje bufor zestawu formuł.
:: WE: _a [STRING] - typ formuł
:: WY: ~~
_obj.fill_buf:="
   .clear_buf(_a);
   .BUF.cntx_psh();
   .BUF.index(.KEY.RN);
   R.cntx_psh();
   R.index('RUBKOD');
   R.prefix();
:: formuły standardowe
   .FML.prefix(_a,);
   _loop:=.FML.first();
   {!
   |? _loop
   |! {? R.find_key(.FML.RN)
      || .mod_buf(_a,'T',.FML.F)
      ?};
      _loop:=.FML.next()
   !};
:: formuły klienta
   FM.cntx_psh();
   FM.index('FORMNAZ');
   FM.prefix(exec('ref_firma','ustawienia'),_a,);
   _loop:=FM.first();
   {!
   |? _loop
   |! FM.R();
      .mod_buf(_a,'N',FM.memo_txt(,1,'F'));
      _loop:=FM.next()
   !};
   FM.cntx_pop();
   R.cntx_pop();
   .BUF.cntx_pop();
   ~~
";

:: Czyści bufor zestawu formuł.
:: WE: _a [STRING] - typ formuł
:: WY: ~~
_obj.clear_buf:="
   .BUF.prefix(_a,);
   {? .BUF.first()
   || {!
      |? .BUF.del()
      !}
   ?};
   .BUF.prefix()
";
~~


\folp_std_wnd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Tworzy i ustawia okienka dla tabeli BUF pseudoobiektu obsługującego formuły naliczania list płac.
::   WE: _a [TABLE] - alias tabeli
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_TAB:=_a;

_tip:='Formuła standardowa [T/N]'@;
:: domyślne okienko wertowania
_acr:=_TAB.mk_sel('Formuły płacowe'@,'P',0,'#folp_wer',,,,,'U',,,,,,,'disabled');
_TAB.win_fld(_acr,,'ST',,,-3,,,,,_tip,2,,"'T'","'N'");
_TAB.win_fld(_acr,,'LP',,,-6,,,,,MS.comment(R,'LP'));
_TAB.win_fld(_acr,,'RN',,,-6,,,,,MS.comment(R,'RN'));
_TAB.win_fld(_acr,,'RT',,,20,,,,,MS.comment(R,'RT'));
_TAB.win_fld(_acr,,'F',,,43,,,,,MS.comment(FM,'F'));
:: obsługa
_TAB.win_act(_acr,,'Formuła','S&tandaryzuj'@@,,,"
   exec('folp_std_run','lista_plac',SLO_KOD.KOD);
   grp_disp(cur_tab(1,1),cur_win(1,1))
",,,,,,'T');
_TAB.win_act(_acr,,'Szukaj');
_TAB.win_act(_acr,,'Kolejność');
_TAB.win_act(_acr,,'Wyświetl',,,,"
   _BUF:=__FOLP.BUFF.BUF;
   {? _BUF.memo_get(,'F')
   || exec('edit_memo_fld','#edit',_BUF,'F',-1,FM.comment(),,,,80,20)
   ?}
");
_TAB.win_sel(_acr);

:: domyślne okienko redakcji na potrzeby wyszukiwania
_acr:=_TAB.mk_edit('Formuła płacowa'@,0,'#folp_red',10,20);
_TAB.win_esep(_acr,'Dane podstawowe'@);
_TAB.win_efld(_acr,,'RN',,,35,,,,,MS.comment(R,'RN'));
_TAB.win_efld(_acr,,'RT',,,35,,,,,MS.comment(R,'RT'));
_TAB.win_efld(_acr,,'ST',,,,,,,,_tip,'check-box',
   'left_label=1,check_label=%1'['Formuła dostarczona z programem'@],
   "'T'","'N'","''"
);
exec('ok_esc','#window',_TAB,_acr);
_TAB.win_edit(_acr);

~~


\folp_std_fml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Zapisuje treść formuł do plików *.fml.
::   WE:
::   WY: ~~
::UWAGA: Formuła wyłącznie dla jednorazowego użytku wewnętrznego DRO na etapie tworzenia plików standardowych formuł.
::       Użycie u klienta skutkować będzie zablokowaniem działania programu spowodowanym nieautoryzowaną zmianą plików.
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new(
:: obsługa plików
   'OUT','SRC','eol',
   'write','close',
:: generowanie treści
   'get_fh','get_rn','get_rt',
   'get_lib_hdr','get_fml_hdr'
);

:: uchwyty plików
_obj.OUT:=tab_tmp(1,
   'TP','STRING[1]',,
   'FH','INTEGER',
);

:: Wsparcie ujednoliconej obsługi nazewnictwa.
_obj.SRC:=exec('folp_std_lib','lista_plac');

:: Zwraca znacznik końca lini.
:: WE:
:: WY: CRLF
_obj.eol:='%1%2'[%13,%10];

_obj.write:="
   {? (_lib:=.get_fh())=0
   || return()
   ?};
   fwrite(_lib,.get_fml_hdr());
   _exe:=FM.memo_txt(,1,'F');
   {? FM.TP=%255
   || fwrite(_lib,gsub(form(_exe),'\n',.eol));
      fwrite(_lib,.eol)
   || _com:='';
      FM.cntx_psh();
      FM.index('FORMULYR');
      FM.prefix(FM.FIRMA,%255,);
      {? FM.find_key(FM.R)
      || _com:=FM.memo_txt(,1,'F');
         {? .SRC.strip(_exe)=.SRC.strip(_com)
         || _exe:='exec(\\'_%1\\',\\'%2\\')'[.get_rn(),.SRC.get_name(FM.TP)]
         ?}
      ?};
      FM.cntx_pop();
      fwrite(_lib,gsub(form(_exe),'\n',.eol));
      fwrite(_lib,.eol)
   ?}
";

:: Zamyka wszystkie otwarte pliki.
_obj.close:="
   _loop:=.OUT.first();
   {!
   |? _loop
   |! fclose(.OUT.FH);
      _loop:=.OUT.next()
   !};
   obj_del(.OUT);
   .OUT:=~~
";

:: Zwraca uchwyt pliku formuł właściwego dla bieżącej formuły.
:: Jeśli uchwyt nie został znaleziony, to plik jest otwierany.
:: WE:
:: WY: 0/<>0 - porażka/uchwyt pliku *.fml
_obj.get_fh:="
   _lib:=0;
   {? .OUT.find_key(FM.TP,)
   || _lib:=.OUT.FH
   || {? (_lib:=fopen(.SRC.get_file(FM.TP),'uw!',1))<>0
      || .OUT.blank();
         .OUT.TP:=FM.TP;
         .OUT.FH:=_lib;
         .OUT.add();
         fwrite(_lib,.get_lib_hdr())
      ?}
   ?};
   _lib
";

:: Zwraca kod składnika bieżącej formuły.
:: WE:
:: WY: kod składnika jako tekst
_obj.get_rn:="
   form(FM.R().RN,,,'99')
";

:: Zwraca nazwę składnika bieżącej formuły.
:: WE:
:: WY: nazwa składnika
_obj.get_rt:="
   form(FM.R().RT)
";

:: Zwraca nagłówek pliku.
_obj.get_lib_hdr:="
   ':!UTF-8%4'
   ':: (c) Asseco Business Solutions S.A. Wszelkie prawa zastrzeżone%4'
   '::%3%4'
   ':: Nazwa pliku: %1 [23.25]%4'
   ':: Utworzony: %2%4'
   ':: Autor: DRO%4'
   '::%3%4'
   ':: Zawartość: Formuły obliczeniowe list płac.%4'
   ':: Wymagania:%4'
   '::    - format pliku UTF-8 BOM%4'
   '::    - znak końca linii CRLF%4'
   '::    - nazwa formuły składnika w formacie \_rn, gdzie rn to R.RN%4'
   '::%3%4'[.SRC.get_file(FM.TP),date()$4,'='*118,.eol]
";

:: Zwraca nagłówek formuły.
_obj.get_fml_hdr:="
   '%4%4\\\\_%1%4'
   '::%3%4'
   '::  UTW: DRO [23.25]%4'
   ':: OPIS: Wyliczenie składnika %1 - \"%2\".%4'
   '::   WE:%4'
   '::   WY: kwota składnika listy płac%4'
   '::%3%4'[.get_rn(),.get_rt(),'-'*118,.eol]
";

FM.cntx_psh();
FM.index('FORMNAZ');
FM.prefix(exec('ref_firma','ustawienia'));
_loop:=FM.first();
{!
|? _loop
|! _obj.write();
   _loop:=FM.next()
!};
FM.cntx_pop();

_obj.close();
~~


\folp_std_mdb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Standaryzuje formuły podanego typu. Standaryzacja polega na usunięciu tych wierszy z tabeli FM, których treść
::       formuły jest identyczna z formułami zapisanymi w odpowiednim pliku ppl_formuly?.fml.
::   WE:
::   WY: referencja pseudoobiektu ułatwiającego standaryzację
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new(
:: Bufor formuł
   'BUF',
:: Obsługa plików
   'SRC','handle',
   'open','close',
:: Odczyt treści formuł
   'load','read','parse',
:: Zapis bufora
   'write','remove',
:: Standaryzacja
   'run'
);

:: Bufor formuł
_BUF:=tab_tmp(1,
   'RN','INTEGER',MS.name(R,'RN'),
   'RT','STRING[%1]'[$MS.fld_len(R,'RT')],MS.name(R,'RT'),
   'TP','STRING[%1]'[$MS.fld_len(FM,'TP')],MS.name(FM,'TP'),
   'F','SYS_MEMO',MS.name(FM,'F'),
   'ST','STRING[1]','Standaryzacja'@,
   'ZF','INTEGER','Zgodność formuł'@,
   'PT','STRING[1]','Plik dla typu'@,
   'DP','STRING[20]','Dopasowany plik'@,
   'FM','STRING[16]','Wskazanie formuły'@
);
_obj.BUF:=_BUF;

:: Wsparcie ujednoliconej obsługi nazewnictwa.
_obj.SRC:=exec('folp_std_lib','lista_plac');

:: Otwiera plik formuł właściwy dla podanego typu.
:: WE: _a [STRING] - typ formuł
:: WY: 0/1 - porażka/sukces
_obj.open:="
   (.handle:=fopen(.SRC.get_file(_a),'ur',1))<>0
";

:: Zamyka aktualinie otwarty plik.
_obj.close:="
   {? type_of(.handle)=type_of(0) & .handle>0
   || fclose(.handle);
      .handle:=0
   ?}
";

:: Wczytuje z pliku formuły podanego typu.
:: Wczytuje z pliku formuły wspólne.
:: Porównuje zawartość plików z zawartością tabeli formuł.
:: WE: _a [STRING] - typ formuł
:: WY: ~~
_obj.load:="
   _kod:=_a;
   .read(_kod);
:: dopasuj formuły
   R.cntx_psh();
   FM.cntx_psh();
   FM.index('FORMNAZ');
   FM.prefix(exec('ref_firma','ustawienia'),_kod);
   _loop:=FM.first();
   {!
   |? _loop
   |! _fml:=FM.memo_txt(,1,'F');
      _cmp:=.SRC.strip(_fml);
      .BUF.prefix(FM.R().RN);
      _loop:=.BUF.first();
      {!
      |? _loop
      |! {? .BUF.memo_txt(,1,'F')=_cmp
         || .BUF.FM:=$FM.ref();
            .BUF.RT:=R.RT;
            .BUF.ZF:=1;
            .BUF.PT:={? .BUF.TP=_kod || 'T' || 'N' ?};
            .BUF.DP:=.SRC.get_file(.BUF.TP);
            .BUF.memo_set(_fml,'F');
            .BUF.put() & .BUF.memo_put(,'F')
         ?};
         _loop:=.BUF.next()
      !};
      _loop:=FM.next()
   !};
   FM.cntx_pop();
   R.cntx_pop();

   .BUF.prefix();
   .BUF.f_set(,,'ZF=0');
   _loop:=.BUF.f_first();
   {!
   |? _loop
   |! .BUF.del();
      _loop:=.BUF.f_next()
   !};
   .BUF.f_clear();
   ~~
";

:: Odczytuje z pliku formuły podanego typu.
:: Wynik umieszczany jest w buforze formuł.
:: WE: _a [STRING] - typ formuł
:: WY: ~~
_obj.read:="
   {? ~.open(_a)
   || return()
   ?};
   .remove(_a);
   .parse(_a);
   .close();
   ~~
";

:: Wyłuskuje z pliku pierwszą formułę dla składnika.
:: Odczyt jest kontynuowany od ostatnio znalezionej.
:: WE: _a [STRING] - typ formuł
:: WY: ~~
_obj.parse:="
   _cur:=0;
   _new:=0;
   _fml:='';
   {!
   |? (_txt:=fread(.handle))<>'\\n'
   |! {? 1+_txt<>':' & form(_txt)<>''
      || {? 2+_txt='\\\\_'
         || {? _cur<>0 & _fml<>''
            || .write(_a,_cur,_fml)
            ?};
            _cur:=#(2-_txt);
            _fml:='';
            _new:=1
         |? 1+_txt='\\\\'
         || _cur:=0
         ?};
         {? _cur<>0
         || {? _new=0
            || _fml+=_txt
            ?};
            _new:=0
         ?}
      ?}
   !};
   {? _cur<>0 & _fml<>''
   || .write(_a,_cur,_fml)
   ?};
   ~~
";

:: Dodaje zapis do bufora.
:: WE: _a [STRING] - typ formuł
::     _b [INTEGER] - numer rubryki
::     _c [STRING] - treść formuły
:: WY: 0/1 - porażka/sukces
_obj.write:="
   .BUF.blank();
   .BUF.TP:=_a;
   .BUF.RN:=_b;
   .BUF.memo_set(.SRC.strip(_c),'F');
   .BUF.add() & .BUF.memo_put(,'F')
";

:: Usuwa dane dla podanego typu formuł.
:: WE: _a [STRING] - typ formuł
:: WY: ~~
_obj.remove:="
   .BUF.cntx_psh();
   .BUF.clear();
   .BUF.f_set(,,'TP=\\'_a\\'',_a);
   _loop:=.BUF.f_first();
   {!
   |? _loop
   |! .BUF.del();
      _loop:=.BUF.f_next()
   !};
   .BUF.f_clear();
   .BUF.cntx_pop();
   ~~
";

:: Rozpoczyna standaryzację formuł.
:: WE: _a [STRING] - typ formuł
_obj.run:="
   _tpw:=%255;
   {? _a<>_tpw
   || .read(_tpw)
   ?};
   .load(_a);
   _src:=.SRC.get_file(_a);
   _com:=.SRC.get_name(_tpw);
   _lib:=fexists(_src,1);
   .BUF.hdr_sel(' %1'[_a]);
   {? .BUF.select()
   || FM.cntx_psh();
      FM.prefix();
      .BUF.prefix();
      .BUF.f_clear();
      {!
      |? .BUF.find_tab(,'ST',,'=','T')
      |! _del:=1;
         {? ~_lib & .BUF.TP=_tpw
         || _del:=0
         ?};
         {? FM.seek(.BUF.FM)
         || {? _del
            || FM.del()
            || _new:='exec(\\'_%1\\',\\'%2\\')'[form(.BUF.RN,,,'99'),_com];
               FM.memo_set(_new,'F');
               FM.memo_put(,'F')
            ?}
         ?};
         .BUF.del()
      !};
      FM.cntx_pop()
   ?};
   .BUF.hdr_sel()
";

:: okienko wertowania standaryzacji formuł
_tip:='Formuła z pliku właściwego dla typu formuł [T/N]'@;
_acr:=_BUF.mk_sel('Standaryzacja formuł płacowych'@,'P',0,'#folp_std_wer',,,,,'U',,,,,,,'disabled');
_BUF.win_fld(_acr,,'ST',,,-3,,,,,'Standaryzacja formuły [T/N]'@,2,,"'T'","'N'");
_BUF.win_fld(_acr,,'RN',,,-6,,,,,MS.comment(R,'RN'));
_BUF.win_fld(_acr,,'RT',,,,,,,,MS.comment(R,'RT'));
_BUF.win_fld(_acr,,'F',,,,,,,,MS.comment(FM,'F'));
_BUF.win_fld(_acr,,'PT',,,-3,,,,,_tip,2,,"'T'","'N'");
_BUF.win_fld(_acr,,'DP');
_BUF.win_act(_acr,,'Formuła','Wybierz'@@,,,
   "  _BUF:=cur_tab(1,1);
      _BUF.ST:='T';
      _BUF.put()
   ",,,1
);
_BUF.win_act(_acr,,'Formuła','Pomiń'@@,,,
   "  _BUF:=cur_tab(1,1);
      _BUF.ST:='N';
      _BUF.put()
   ",,,1
);
_BUF.win_act(_acr,,'Formuła','Dalej'@@,,,
   "  FUN.ask(
         'Czy na pewno standaryzować wybrane formuły płacowe?\n\n'
         'Standaryzacja polega na usunięciu danych z tabeli FM dla formuł dostarczonych z aplikacją.\n'
         'Formuły dodane na potrzeby klienta o treści zgodnej z formułami wspólnymi zostaną zmienione\n'
         'na wywołanie odpowiedniej formuły wspólnej.'@
      )
   ","
      sel_exit()
   "
);
_BUF.win_act(_acr,,'Szukaj');
_BUF.win_act(_acr,,'Kolejność');
_BUF.win_act(_acr,,'Rekord',,,,"
   {? _a=0 || return() ?};
   _BUF:=cur_tab(1,1);
   _wnd:=cur_win(1,1);
   _BUF.cntx_psh();
   _def:='?';
   _aid:='';
   {? _BUF.sel_size()=0
   || {? _BUF.ST='T'
      || _def:='P';
         _aid+='W'
      || _def:='W';
         _aid+='P'
      ?}
   ?};
   {? ~_BUF.find_tab(,'ST',,'=','T')
   || _aid+='D'
   ?};
   _BUF.cntx_pop();
   _BUF.actions(_wnd,,_def,1);
   _BUF.actions_grayed(_wnd,_aid)
");
_BUF.win_act(_acr,,'Wyświetl',,,,"
   _BUF:=cur_tab(1,1);
   {? _BUF.memo_get(,'F')
   || exec('edit_memo_fld','#edit',_BUF,'F',-1,FM.comment(),,,,80,20)
   ?}
");
_BUF.win_btn(_acr,'text=%1'['Wybierz'@],'menu:W');
_BUF.win_btn(_acr,'text=%1'['Pomiń'@],'menu:P');
_BUF.win_btn(_acr,'text=%1,align=end'['Anuluj'@],'key:Esc');
_BUF.win_btn(_acr,'text=%1,panel=bottom'['Dalej'@],'menu:D');
_BUF.win_sel(_acr);

:: okienko redakcji wyłącznie na potrzeby wyszukiwania
_acr:=_BUF.mk_edit('Formuła płacowa'@,0,'#folp_std_red');
_BUF.win_esep(_acr,'Dane podstawowe'@);
_BUF.win_efld(_acr,,'RN',,,40,,,,,MS.comment(R,'RN'));
_BUF.win_efld(_acr,,'RT',,,40,,,,,MS.comment(R,'RT'));
_BUF.win_efld(_acr,,'PT',,,,,,,,_tip,'check-box',
   'left_label=1,check_label=%1'['Formuła w pliku zgodnym z jej typem'@],
   "'T'","'N'","''"
);
exec('ok_esc','#window',_BUF,_acr);
_BUF.win_edit(_acr);

_obj


\folp_std_run
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Uruchamia standaryzację wybranych formuł płacowych.
::   WE: _a [STRING] - typ formuł płacowych
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
exec('folp_std_mdb','lista_plac').run(_a);
~~


\folp_std_upd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Uruchamia standaryzację formuł płacowych.
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_kod:='TYP_FORM';
{? (_typ:=exec('slo_typ','ext_slo',_kod))=null
|| FUN.emsg('Nie znaleziono typu słownika "%1".'@[_kod]);
   return()
?};

:: analiza pod kątem wyłączenia naliczania składników
:: polegająca na usunięciu formuły a nie zmianie treści
_obj:=exec('folp_std_buf','lista_plac');
_obj.init();
_FML:=_obj.FML;

SLO_KOD.cntx_psh();
SLO_KOD.index('KOD');
SLO_KOD.prefix(_typ);
_loop:=SLO_KOD.first();
{!
|? _loop
:: stwórz indeks formuł standardowych
|! _obj.read_fml(SLO_KOD.KOD);
   _loop:=SLO_KOD.next()
!};

_FML.clear();
FM.cntx_psh();
FM.index('FORMNAZ');
FM.prefix(exec('ref_firma','ustawienia'));
_loop:=FM.first();
{!
|? _loop
|! {? _FML.find_tab(,
         'TP',,'=',FM.TP,
         'RN',,'=',FM.R().RN
      )
   || _FML.del()
   ?};
   _loop:=FM.next()
!};
FM.cntx_pop();

{? _FML.first()
|| FUN.info(
      'Znaleziono w plikach formuły, dla których nie istnieją zapisy w tabeli formuł płacowych.\n'
      'Dla rubryk wykazanych w zakładce "Brakujące formuły" będą naliczane składniki list płac.'@
   );
   _NFO:=sql(
      'select SLO_KOD.KOD, SLO_KOD.NAZWA, R.* '
      'from :_a join
         R using(:_a.RN,R.RN) join
         SLO_KOD using(:_a.TP,SLO_KOD.KOD) '
      'where SLO_KOD.SLO_TYP=:_b '
      'order by SLO_KOD.KOD, R.RN',
      _FML,_typ
   );
   _wnd:=_NFO.mk_sel(,'P',0,,,,,,'U',,,,,,,'disabled');
   _NFO.win_fld(_wnd,,'KOD',,,-3,,,MS.name(FM,'TP'),,MS.comment(FM,'TP'));
   _NFO.win_fld(_wnd,,'NAZWA',,,20,,,MS.name(SLO_KOD,'NAZWA'),,MS.comment(SLO_KOD,'NAZWA'));
   _NFO.win_fld(_wnd,,'RN',,,-6,,,MS.name(R,'RN'),,MS.comment(R,'RN'));
   _NFO.win_fld(_wnd,,'RT',,,20,,,MS.name(R,'RT'),,MS.comment(R,'RT'));
   _NFO.win_fld(_wnd,,'RK',,,-3,,,MS.name(R,'RK'),,MS.comment(R,'RK'));
   _NFO.win_act(_wnd,,'Szukaj');
   _NFO.win_act(_wnd,,'Kolejność');
   _NFO.win_sel(_wnd);
   _len:=20;
   _acr:=_NFO.mk_edit('Formuła płacowa'@);
   _NFO.win_esep(_acr,'Dane podstawowe'@);
   _NFO.win_efld(_acr,,'KOD',,,_len,,,MS.name(FM,'TP'),,MS.comment(FM,'TP'));
   _NFO.win_efld(_acr,,'RN',,,_len,,,MS.name(R,'RN'),,MS.comment(R,'RN'));
   exec('ok_esc','#window',_NFO,_acr);
   _NFO.win_patt(_acr)
?};
_obj.release();
obj_del(_obj);

_typ:=exec('slo_typ','ext_slo','TYP_FORM');
_acr:=SLO_KOD.mk_sel(,'P',0,'#folp_std_upd',1,1,20,,'U');
SLO_KOD.win_fld(_acr,,'KOD',,,-3,,,,,MS.comment(SLO_KOD,'KOD'));
SLO_KOD.win_fld(_acr,,'NAZWA',,,47,,,,,MS.comment(SLO_KOD,'NAZWA'));
SLO_KOD.win_fld(_acr,,'SYSTEM',,,-3,,,,,MS.comment(SLO_KOD,'SYSTEM'),2,,"'T'","'N'");
SLO_KOD.win_act(_acr,,'Formuła','Wybierz'@@,,'Wybór bieżącego zapisu'@,
   "exec('folp_std_run','lista_plac',SLO_KOD.KOD)",,1,,,,'W'
);
SLO_KOD.win_act(_acr,,'Szukaj');
SLO_KOD.win_act(_acr,,'Kolejność');

_grp:=SLO_KOD.grp_make('Typy formuł płacowych'@,,,,,,,'normal');
_mod:='maximized';
{? var_pres('_NFO')=type_of(SYSLOG)
|| SLO_KOD.grp_sel(_grp,,_acr,'Standaryzacja formuł'@,,,,,,,,,_mod);
   SLO_KOD.grp_sel(_grp,_NFO,_wnd,'Brakujące formuły'@,,,,,,,,,_mod)
|| SLO_KOD.grp_sel(_grp,,_acr,,,,,,,,,,_mod)
?};

SLO_KOD.win_sel(_grp);
SLO_KOD.select();

SLO_KOD.cntx_pop();
SLO_KOD.win_del(_grp);
SLO_KOD.win_del(_acr);
~~


\dekl_cbuff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Deklaracja klasy bufora danych dla wyliczenia składników list płac i rachunków.
::  OLD: \define/skladnik.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('CBUFF',@.CLASS)>=100
:: deklaracja już istnieje
|| return()
?};

obj_decl('CBUFF',
   obj_fld('error',0),
   obj_fld('calc',0),
   obj_fld('name',''),

   obj_fld('LOG',~~),

:: rozmiar tablic
   obj_fld('max',0),
:: rubryki na liście
   obj_fld('list',''),
:: następna pozycja
   obj_fld('tail',0),
:: sumy składników
   obj_fld('sum',~~),
:: bufor danych listy
   obj_fld('data',~~),

   obj_fld('lk_mod',0),
   obj_fld('lp_mod',0),

   obj_fld('ValF',""),
   obj_fld('Context',''),

   obj_meth('__init',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Definiuje obiekt klasy CBUFF.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      exec('__FOLP','object');
      _a.Alloc(__RUB.max());

::    Definicja tabeli wykorzystywanej do prezentacji ewentualnych błędów podczas naliczania listy.
      .LOG:=tab_tmp(1,
         'ID','IDADD','Id'@,
         'T','STRING[%1]'[$MS.fld_len('P','T')],'Numer teczki'@,
         'NAZWISKO','STRING[%1]'[$MS.fld_len('OSOBA','NAZWISKO')],'Nazwisko'@,
         'PIERWSZE','STRING[%1]'[$MS.fld_len('OSOBA','PIERWSZE')],'Imię'@,
         'SYMBOL','STRING[%1]'[$MS.fld_len('UD_SKL','SYMBOL')],'Jednostka organizacyjna'@,
         'ST','STRING[%1]'[$MS.fld_len('STN','ST')],'Stanowisko'@
      );
      {? app_info('web_sesid')=''
::       Ponieważ pod webTerm-em nie są przeprowadzane obliczenia to możemy zrezygnować z budowania intefejsu,
::       zwłaszcza, że wykorzystywane są tu metody niedostępne pod webTerm-em.

      || _key:=.LOG.index('?');
         .LOG.index(.LOG.ndx_tmp('Numer teczki'@,0,'T',,));
         .LOG.index(.LOG.ndx_tmp('Osoba'@,0,'NAZWISKO',,,'PIERWSZE',,));
         .LOG.index(_key);
         .LOG.fld_fml('T','DISPLAY_FORMAT',exec('alignment_right_cnd','#field'));
         _wnd:=.LOG.mk_sel('Pominięci współpracownicy'@,'P',0,'#cbuff_log');
         .LOG.win_fld(_wnd,,'T',,,-10);
         .LOG.win_fld(_wnd,,'NAZWISKO',,,-20);
         .LOG.win_fld(_wnd,,'PIERWSZE',,,-20);
         .LOG.win_fld(_wnd,,'SYMBOL',,,-16);
         .LOG.win_fld(_wnd,,'ST',,,-30);
         .LOG.win_sel(_wnd)
      ?}
   "),

   obj_meth('Alloc',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.14]
:: OPIS: Przydziela i inicjuje dane bufora składników.
::   WE: _a INTEGER - rozmiar bufora wyrażony jako maksymalny numer rubryki
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
      {? _a<=0 || return() ?};

      .max:=_a;

      _init:=\"
         {! _m:=1..obj_len(_a)
         |! _a[_m]:=obj_new(_b);
            {! _n:=1.._b
            |! _a[_m][_n]:=0
            !}
         !}
      \";

      .sum:=obj_new('val','ndx');
      _init(.sum,.max);

      .data:=obj_new('val','acc','mod','old','ndx');
      _init(.data,.max*5);

      .Empty();
      ~~
   ",type_of(0),-1),

   obj_meth('IsEmpty',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.14]
:: OPIS: Sprawdza, czy w buforze zapisano jakieś dane.
::   WE:
::   WY: 0/1 - bufor zawiera dane/brak danych
::----------------------------------------------------------------------------------------------------------------------
      .list=','
   ",-1),

   obj_meth('Empty',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Opróżnienie buforów.
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
      _clean:=\"
         {! _m:=1..obj_len(_a)
         |! _len:=obj_len(_a[_m]);
            {! _n:=1.._len
            |! _a[_m][_n]:=0
            !}
         !}
      \";
      _clean(.sum);
      _clean(.data);

      .list:=',';
      .tail:=1;
      ~~
   ",-1),

   obj_meth('EmpHD',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Wyzerowanie sumy składnika.
::   WE: _a INTEGER - numer rubryki
::   WY: ~~
::UWAGA: po zmianie metody Empty nie wykorzystywana w standardzie.
::----------------------------------------------------------------------------------------------------------------------
      .sum.val[_a]:=0;
      {? .sum.ndx[_a]<>0
::       "usuń" szczegółowe dane
      || .EmpIN(.sum.ndx[_a]);
         .sum.ndx[_a]:=0
      ?};
      ~~
   ",type_of(0),-1),

   obj_meth('EmpIN',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Wyzerowanie danych składnika.
::   WE: _a INTEGER - indeks komórki
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
      {? .data.ndx[_a]<>0
::       "usuń" kolejne dane
      || .EmpIN(.data.ndx[_a]);
         .data.ndx[_a]:=0
      ?};
      .data.val[_a]:=0;
      .data.acc[_a]:=0;
      .data.mod[_a]:=0;
      .data.old[_a]:=0;
      ~~
   ",type_of(0),-1),

   obj_meth('Add',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Wstawienie składnika do bufora
::   WE: _a INTEGER - numer składnika (LP)
::       _b REAL - kwota składnika
::       _c _KK - wskazanie konta kosztów
::       _d INTEGER - korekta składnika
::       _e REAL - poprzednia kwota
::   WY: pozycja dodanego składnika w buforze danych
::----------------------------------------------------------------------------------------------------------------------
      {? .list*(','+$_a+',')=0
::       uwzględnij składnik
      || .list+=$_a+','
      ?};

::    zwiększ sumę składnika
      .sum.val[_a]+=_b;

::    zapamiętaj szczegóły
      .data.val[.tail]:=_b$2;
      .data.acc[.tail]:=_c;
      .data.mod[.tail]:=_d;
      .data.old[.tail]:=_e;

      {? .sum.ndx[_a]=0
      || .sum.ndx[_a]:=.tail
      || _tmp:=.sum.ndx[_a];
         {!
         |? {? .data.ndx[_tmp]<>0
            || _tmp:=.data.ndx[_tmp]
            ?}
         !};
         .data.ndx[_tmp]:=.tail
      ?};

      .tail+=1
   ",type_of(0),type_of(0),type_of(null),type_of(0),type_of(0),-1),

   obj_meth('Find',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Wyszukanie w buforze pozycji, pod którą zapisana jest kwota składnika o kodzie podanym argumentem.
::   WE: _a INTEGER - numer składnika
::   WY: 0/pozycja w buforze
::----------------------------------------------------------------------------------------------------------------------
      {? .list*(','+$_a+',')
      || .sum.ndx[_a]
      ?}
   ",type_of(0),-1),

   obj_meth('Prepare',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.14]
:: OPIS: Przygotowuje obiekt do naliczania składników list płac.
::   WE: _a STRING - nazwa dyskowa zbioru tabeli LS
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
      .name:=_a;

      .error:=0;
      .calc:=0;
      .lk_mod:=0;
      .lp_mod:=0;

      .Empty();
      ~~
   ",type_of(''),-1),

   obj_meth('Compute',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Przeliczenie składników listy płac lub rachunku, wykonanie formuł obliczeniowych, zapis do bufora.
::   WE: _a [INETEGER] - tryb obliczania składników: 0*(brak)/>0/<0 - pełne obliczenie/obliczenie T i #/ przeliczenie
::   WY: 0/1 - brak zmian/składniki uległy zmianie
::----------------------------------------------------------------------------------------------------------------------
::    ustal tryb naliczania
      _mod:=0;
      {? var_pres('_a')=1
      || {? _a<0 || _mod:=-1
         |? _a>0 || _mod:=1
         ?}
      ?};

      {? _mod<>-1 &
         {? .Context='Z'
         || exec('jest_bl','lista_plac',RH.ref())
         || exec('jest_bl','lista_plac',O.ref(),P.ref())
         ?}
::       nie obliczaj listy zawierającej zablokowane składniki,
::       taka lista może być jedynie "przeliczona"
      || return(0)
      ?};

::    spróbuj zapewnić niezmienność rubryk na czas obliczania
::    i nie zezwalaj na w pełni współbieżne naliczanie listy
      {? ~R.lock(0,1,1)
::       nie obliczaj
      || .LOG.blank();
         .LOG.T:=P.T;
         .LOG.NAZWISKO:=P.OSOBA().NAZWISKO;
         .LOG.PIERWSZE:=OSOBA.PIERWSZE;
         .LOG.SYMBOL:=P.WYDZIAL().SYMBOL;
         .LOG.ST:=P.ST().ST;
         .LOG.add();
         return(0)
      ?};

      {? __RUB.is_mod()
::       odśwież bufory
      || __RUB.fill();
         __FOLP.fill(__FOLP.type)
      ?};

::    wykonuj formuły obliczeniowe z komunikatami o błędach
::    ale bez przerywania działania głównej formuły liczącej
      on_error(2);

::    naliczanie:
::    - wczytaj składniki listy
::    - wykonuj formuły obliczeniowe
::    - utrwal zawartość buforów w tabeli
      _real:=type_of(0);
      _test:=.Load();
      .calc:=1;
      _size:=obj_len(__FOLP.body);
      {! _ii:=1.._size
      |? ~.error
      |! {? (_cls:=__FOLP.cls[_ii])=''
         || _cls:='?'
         ?};
         {? {? _mod=1 || 'T#B'*_cls || 1 ?}
::          oblicz kwotę składnika
         || _val:=__FOLP.calc(_ii);

            {? in_error()
::             katastrofa!
            || .error:=1;
               _val:=~~

            |? type_of(_val)=_real
::             uzyskano liczbę
            || _val:=_val$2;
               {? _ndx:=.Find(_ii)
::                aktualizuj składnik
               || {? .data.mod[_ndx]=0
::                   składnik nie jest zablokowany
                  || _test+=(.data.val[_ndx]<>_val);
                     .sum.val[_ii]+=(_val-.data.val[_ndx]);
                     .data.val[_ndx]:=_val
                  ?}
               |? _val<>0
::                dodaj składnik z niezerową kwotą
               || .Add(_ii,_val,.DefAccnt(),0,0);
                  _test+=1
               ?}
            ?}
         ?}
      !};
::    standardowa obsługa błędów
      on_error(0);

      _ret:=1;
      {? (_test | .lk_mod | .lp_mod) & ~.error
::       utrwal zawartość bufora składników
      || .Save()
      || .calc:=0;
         _ret:=0
      ?};

      R.unlock();
      _ret
   ",type_of(0),-1),

   obj_meth('show_log',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Wyświetla raport o pominiętych współpracownikach.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
   "  _size:=.LOG.size();
      {? _size>0
      || {? _size=1
         || FUN.emsg(
               'Podczas kalkulacji składników wynagrodzenia z przyczyn technicznych pominięto współpracownika.\n'
               'Dla współpracownika wykazanego na raporcie należy powtórzyć naliczenie wynagrodzenia.'@
            )
         || FUN.emsg(
               'Podczas kalkulacji składników wynagrodzenia z przyczyn technicznych pominięto %1 współpracowników.\n'
               'Dla współpracowników wykazanych na raporcie należy powtórzyć naliczenie wynagrodzenia.'@
               [$_size]
            )
         ?};
         .LOG.select();
         .LOG.erase()
      ?}
   ",-1),

:  Metody wirtualne definiowane zależnie od kontekstu wywołania

   obj_virt('DefAccnt',"null"),
   obj_virt('Cntx',"SYSLOG"),

   obj_virt('Load',"",-1),
   obj_virt('Save',"",-1),
   obj_virt('Drop',"",type_of(0),type_of(null))
)


\dekl_ls_druk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Deklaracja klasy LS_DRUK.
::   WE:
::   WY:
::  OLD: \dekl_lista/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
: zakończ, jeśli klasa została zadeklarowana
{? var_pres('LS_DRUK',@.CLASS)>0
|| return()
?};

obj_decl('LS_DRUK',
:  ogólny porównywacz danych
   obj_fld('Compare',"{? _a<_b || -1 |? _a=_b || 0 || 1 ?}"),

   obj_fld('Info',0),
   obj_fld('Prac',0),
   obj_fld('Wydz',0),
   obj_fld('Zakl',0),
   obj_fld('__PracR',0),
   obj_fld('__WydzR',0),
   obj_fld('__ZaklR',0),
   obj_fld('__Fatal',0),

   obj_fld('SPrac',0),
   obj_fld('SWydz',0),
   obj_fld('SZakl',0),

   obj_meth('__init',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: "Konstruktor" - tworzy obiekt.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      exec('dekl_sarray','#array');
      exec('dekl_zb_rub','rubobj');
      exec('__RUB','object');
      _a.Info:=obj_new(@.CLASS.SARRAY,_a.Compare);
      {? _a.SizeCnt()
      || _a.Create()
      ?}
   "),

   obj_meth('Czytaj',"exec('czytaj_ls','lista_plac',.,_a)",type_of('')),

   obj_meth('Czytaj',"exec('czytaj_rh','lista_plac',.,_a)",type_of(''),type_of(1)),

   obj_meth('Kolumny',".Info.Size()"),

   obj_meth('Wiersze',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca liczbę wierszy.
::   WE: _a [STRING] - rodzaj zestawienia:
::          Prac - pracownik
::          Wydz - jednostaka organizacyjna
::          Zakl - przedsiębiorstwo
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      (${? _a='Prac' | _a='Wydz' | _a='Zakl' || '_a.__'+_a+'R' || '0' ?})(.)
   ",type_of('')),

   obj_meth('Set_Rows',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Ustawia liczbę wierszy zestawienia:
::   WE: _a [STRING] - rodzaj zestawienia:
::          Prac - pracownik
::          Wydz - jednostaka organizacyjna
::          Zakl - przedsiębiorstwo
::       _b [INTEGER] - liczba wierszy
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      _rows:='~~';
      {? _a='Prac' | _a='Wydz' | _a='Zakl'
      || {? _b>=1
         || _rows:='{? _a.__'+_a+'R<=_b '+
                   '|| _a.__'+_a+'R:=_b'+
                   '?}'
         || _rows:='_a.__'+_a+'R:=0'
         ?}
      ?};
      ($(_rows))(.,_b)
   ",type_of(''),type_of(0),-1),

   obj_meth('Create',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przydziela pamięć na składniki zestawień.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      _TabSize:=__RUB.max();
      {? _TabSize<=0
      || return()
      ?};
      .SPrac:=obj_new(_TabSize);
      .SWydz:=obj_new(_TabSize);
      .SZakl:=obj_new(_TabSize);
      {! _i:=1 .._TabSize
      |! .SPrac[_i]:=.SWydz[_i]:=.SZakl[_i]:=0
      !};
      _TabSize:=.Kolumny();
      .Prac:=obj_new(_TabSize);
      .Wydz:=obj_new(_TabSize);
      .Zakl:=obj_new(_TabSize);
      {! _i:=1.._TabSize
      |! .Prac[_i]:=obj_new(@.CLASS.SARRAY,.Compare);
         .Wydz[_i]:=obj_new(@.CLASS.SARRAY,.Compare);
         .Zakl[_i]:=obj_new(@.CLASS.SARRAY,.Compare)
      !};
      .Copy('Prac');
      .Copy('Wydz');
      .Copy('Zakl')
   ",-1),

   obj_meth('Copy',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      _CMeth:='{! _i:=1.. .Kolumny() '+
              '|! .'+_a+'[_i].Clear();'+
              '   .'+_a+'[_i]<=.Info.Array[_i]'+
              '!}';
      .Set_Rows(_a,0);
      set_virt(.,'DeepCpy',$_CMeth);
      .DeepCpy()
   ",type_of(''),-1),

   obj_virt('DeepCpy',""),

   obj_meth('Update',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwalnia i ponownie przydziela pamięć.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? .SizeCnt()
      || _TabSize:=.Kolumny();
         {! _i:=1.._TabSize
         |! .Prac[_i].Clear();
            obj_del(.Prac[_i]);
            .Wydz[_i].Clear();
            obj_del(.Wydz[_i]);
            .Zakl[_i].Clear();
            obj_del(.Zakl[_i])
         !};
         obj_del(.Prac);
         obj_del(.Wydz);
         obj_del(.Zakl);
         obj_del(.SPrac);
         obj_del(.SWydz);
         obj_del(.SZakl);
         .Create()
      ?}
   ",-1),

   obj_meth('SizeCnt',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      .Info.Clear();
      .__Fatal:=0;
      R.cntx_psh();
      R.index('RUBLP');
      R.prefix();
      {? R.first() & R.LP=0
      || .__Fatal:=1
      |? R.last() & (R.RK='T' | R.RK='G')
      || {!
         |? {? R.RK='T' | R.RK='G'
            || .Info<=R.LP
            ?};
            R.prev()
         !}
      || .__Fatal:=1
      ?};
      R.cntx_pop();
      ~.__Fatal
   ",-1)
)


\czytaj_ls
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::  OLD: \Czytaj/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
_a.Copy('Prac');

LS.use(_b);
LS.index('PRACLPRU');
LS.prefix(P.ref());
{? obj_len(_a.Prac)=_a.Kolumny() &
   obj_len(_a.Wydz)=_a.Kolumny() &
   obj_len(_a.Zakl)=_a.Kolumny() &
   LS.first()
|| {! _i:=1..obj_len(LISTA.SPrac)
   |! LISTA.SPrac[_i]:=0
   !};
   {!
   |? LS.RB();
      {? (R.KDL='T' | R.KDZ='T') & LS.KW<>0
      || _loop:=1;
         _Kod:=R.LP;
         LISTA.SPrac[_Kod]+=LS.KW;
         LISTA.SWydz[_Kod]+=LS.KW;
         LISTA.SZakl[_Kod]+=LS.KW;
         {! _i:=1.._a.Kolumny()
         |? _loop
         |! {? R.LP<=_a.Info.Array[_i]
            || {? R.KDL='T' & ~_a.Prac[_i].Find(_Kod)
               || _a.Prac[_i]<=_Kod
               ?};
               {? R.KDZ='T'
               || {? ~_a.Wydz[_i].Find(_Kod)
                  || _a.Wydz[_i]<=_Kod
                  ?};
                  {? ~_a.Zakl[_i].Find(_Kod)
                  || _a.Zakl[_i]<=_Kod
                  ?}
               ?};
               _loop:=0
            ?}
         !}
      ?};
      LS.next()
   !};
   {! _i:=1.._a.Kolumny()
   |! _a.Set_Rows('Prac',_a.Prac[_i].Size());
      _a.Set_Rows('Wydz',_a.Wydz[_i].Size());
      _a.Set_Rows('Zakl',_a.Zakl[_i].Size())
   !}
?}


\czytaj_rh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::  OLD: \Czytaj1/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
_a.Copy('Prac');

LS.use(_b);
LS.index('ZLEC');
{? obj_len(_a.Prac)=_a.Kolumny() &
   obj_len(_a.Wydz)=_a.Kolumny() &
   obj_len(_a.Zakl)=_a.Kolumny()
|| {! _i:=1 ..obj_len(LISTA.SPrac)
   |! LISTA.SPrac[_i]:=0
   !};
   LS.prefix(RH.ref());
   {? LS.first()
   || {!
      |? LS.RB();
         _lista:=R.KDL;
         _zbior:=R.KDZ;
         {? _lista='T' | _zbior='T'
         || _loop:=1;
            _Kod:=R.LP;
            LISTA.SPrac[_Kod]+=LS.KW;
            LISTA.SWydz[_Kod]+=LS.KW;
            LISTA.SZakl[_Kod]+=LS.KW;
            {! _i:=1.._a.Kolumny()
            |? _loop
            |! {? R.LP<=_a.Info.Array[_i]
               || {? _lista='T' & ~_a.Prac[_i].Find(_Kod)
                  || _a.Prac[_i]<=_Kod
                  ?};
                  {? _zbior='T'
                  || {? ~_a.Wydz[_i].Find(_Kod)
                     || _a.Wydz[_i]<=_Kod
                     ?};
                     {? ~_a.Zakl[_i].Find(_Kod)
                     || _a.Zakl[_i]<=_Kod
                     ?}
                  ?};
                  _loop:=0
               ?}
            !}
         ?};
         LS.next()
      !}
   ?};
   {! _i:=1.._a.Kolumny()
   |! _a.Set_Rows('Prac',_a.Prac[_i].Size());
      _a.Set_Rows('Wydz',_a.Wydz[_i].Size());
      _a.Set_Rows('Zakl',_a.Zakl[_i].Size())
   !}
?}


\dekl_zb_druk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Deklaracja klasy ZB_DRUK.
::   WE:
::   WY: \zb_druk/rubobj.fml
::----------------------------------------------------------------------------------------------------------------------
: zakończ, jeśli klasa została zadeklarowana
{? var_pres('ZB_DRUK',@.CLASS)>0
|| return()
?};

obj_decl('ZB_DRUK',

   obj_fld('Wzorzec', 0),
   obj_fld('Rubryka', 0),
   obj_fld('LKolumn', 1),
   obj_fld('LWierszy',1),
   obj_fld('DrLinia', 0),
   obj_fld('Wiersz', 0),
   obj_fld('ZB_NDX', ''),

   obj_meth('__init',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: "Konstruktor" - tworzenie obiektu.
::----------------------------------------------------------------------------------------------------------------------
      exec('dekl_zb_rub','rubobj');
      exec('__RUB','object');
      _a.build(__RUB.max());
:     do identyfikacji używany jest numer (R.LP) a nie kodu (R.RN) rubryki
      .ZB_NDX:=ZB_WART.ndx_tmp(,,'KLUCZ',,,'R','LP',)
   "),

   obj_meth('__done',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: "Destruktor" - usuwanie obiektu.
::----------------------------------------------------------------------------------------------------------------------
      ZB_WART.ndx_drop(.ZB_NDX)
   "),

   obj_meth('build',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przygotowanie buforów zawierających wskazania na obiekty klasy ZB_RUB.
::   WE: _a - rozmiar tablic pomocniczych
::----------------------------------------------------------------------------------------------------------------------
      {? _a<=0
      || return()
      ?};
      .DrLinia:=obj_new(1);
      .Wzorzec:=obj_new(_a);
      .Rubryka:=obj_new(obj_len(.Wzorzec));
      {! _n:=1..obj_len(.Rubryka)
      |! .Wzorzec[_n]:=.Rubryka[_n]:=obj_new(@.CLASS.ZB_RUB)
      !}
   ",type_of(0),-1),

   obj_meth('del',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwolnienie przydzielonej pamięcie. Pracowite usuwanie obiektów zapisanych w komórkach tablic.
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('DrLinia',.)>=100
      || obj_del(.DrLinia)
      ?};
      {? var_pres('Wzorzec',.)>=100
      || {! _n:=1..obj_len(.Wzorzec)
         |! obj_del(.Wzorzec[_n])
         !};
         obj_del(.Wzorzec)
      ?};
      {? var_pres('Rubryka',.)>=100
      || {! _n:=1..obj_len(.Rubryka)
         |! obj_del(.Rubryka[_n])
         !};
         obj_del(.Rubryka)
      ?}
   ",-1),

   obj_meth('Clear',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwalnia pamięć, na nowo konfiguruje obiekt.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      .del();
      .LKolumn:=.LWierszy:=0;
      .build(__RUB.max());
      {! _n:=1..obj_len(.Rubryka)
      |! .Rubryka[_n].Clear()
      !};
:     Zgodnie z założeniami R.LP (numer) przyjmuje kolejne wartości, zatem zawsze prawdziwe jest R.LP<=R.RN.
:     W tablicach Wzorzec i Rubryka rezerwowane jest miejsce zgodnie z największym kodem rubryki, ale do identyfikacji
:     używany będzie numer.
      R.cntx_psh();
      R.index('RUBLP');
      R.clear();
      {? R.first()
      || {!
         |? {? R.LP<=obj_len(.Wzorzec)
            || {? 'GT'*R.RK
               || .Wzorzec[R.LP].Set(R.LP,R.RT,R.RK,,.LKolumn+1);
                  .LKolumn+=1
               || .Wzorzec[R.LP].Set(R.LP,R.RT,R.RK,,.LKolumn+1)
               ?}
            || FUN.error('Wykryto modyfikację słownika rubryk.'@);
               0
            ?} & R.next()
         !}
      ?};
      R.cntx_pop()
   ",-1),

   obj_meth('Load',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wczytuje wartości składników zestawienia zbiorczego.
::----------------------------------------------------------------------------------------------------------------------
      .Clear();
      obj_del(.DrLinia);
      ZB_WART.index(.ZB_NDX);
      ZB_WART.prefix(ZB_DEF.ref());
      {! _n:=1..obj_len(.Wzorzec)
      |! {? ZB_WART.find_key(.Wzorzec[_n].Kod)
         || .Rubryka[_n].Set(_n,.Wzorzec[_n].Nazwa,.Wzorzec[_n].Klasa,ZB_WART.KWOTA,.Wzorzec[_n].Kolumna);
            .Rubryka[_n].Out(ZB_WART.R().KDL,ZB_WART.R().KDZ)
         || .Rubryka[_n].Set(_n,.Wzorzec[_n].Nazwa,.Wzorzec[_n].Klasa,,.Wzorzec[_n].Kolumna)
         ?}
      !}
   ",-1),

   obj_meth('Czytaj',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wczytuje wartości składników zestawienia zbiorczego.
::----------------------------------------------------------------------------------------------------------------------
      echo('Trwa wczytywanie danych...'@);
      .Load();
      .LWierszy:=_NWierszy:=0;
      {! _n:=1..obj_len(.Rubryka)
      |! {? 'GT'*.Rubryka[_n].Klasa
         || .LWierszy+=1;
            .Rubryka[_n].Wiersz:=.LWierszy;
            _NWierszy:={? _NWierszy<=.LWierszy || .LWierszy || _NWierszy ?};
            .LWierszy:=0
         || {? .Rubryka[_n].Kwota
            || .LWierszy+=1;
               .Rubryka[_n].Wiersz:=.LWierszy
            ?}
         ?}
      !};
      .LWierszy:=_NWierszy;
      .WriteBuff();
      echo()
   ",-1),

   obj_meth('Sort',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Porządkuje zestawienie.
::----------------------------------------------------------------------------------------------------------------------
      _NWiersz:=0;
      {! _n:=obj_len(.Rubryka) // (-1)..1
      |! {? 'GT'*.Rubryka[_n].Klasa
         || _NWiersz:=.LWierszy
         ?};
         {? 'LH'*.Rubryka[_n].Wydruk
         || .Rubryka[_n].Wiersz:=0
         ?};
         {? .Rubryka[_n].Wiersz
         || .Rubryka[_n].Wiersz:=_NWiersz;
            _NWiersz-=1
         ?}
      !}
   ",-1),

   obj_meth('WriteBuff',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przygotowuje do wydruku bufory zawierające dane.
::----------------------------------------------------------------------------------------------------------------------
      .Sort();
      .DrLinia:=obj_new(.LWierszy+1);
      {! _n:=1..obj_len(.DrLinia)
      |! .DrLinia[_n]:=''
      !};
      {! _n:=1..obj_len(.Rubryka)
      |! {? .Rubryka[_n].Wiersz
         || _NKolumn:=.Rubryka[_n].Kolumna-(+.DrLinia[.Rubryka[_n].Wiersz])/40;
            .DrLinia[.Rubryka[_n].Wiersz]+=40*(_NKolumn-1)*' ';
            .DrLinia[.Rubryka[_n].Wiersz]+='  '+form(.Rubryka[_n].Nazwa,20);
            _Kwota:={? .Rubryka[_n].Kwota | +(|.Rubryka[_n].Nazwa)
                    || form(.Rubryka[_n].Kwota,17,2)
                    || 17*' '
                    ?};
            .DrLinia[.Rubryka[_n].Wiersz]+=' '+_Kwota
         ?}
      !};
      .DrLinia[.LWierszy+1]:=.DrLinia[.LWierszy];
      .DrLinia[.LWierszy]:=.LKolumn*('  '+(38*'─'));
      .Wiersz:=.LWierszy+1
   ",-1),

   obj_meth('Linia',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca linię danych dla wydruku.
::----------------------------------------------------------------------------------------------------------------------
      .Wiersz-=1;
      {? +(|.DrLinia[obj_len(.DrLinia)-.Wiersz])
      || .DrLinia[obj_len(.DrLinia)-.Wiersz]
      || ~~
      ?}
   "),

   obj_meth('LiniaSep',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca linię separatora dla wydruku.
::----------------------------------------------------------------------------------------------------------------------
      .LKolumn*('  '+(38*'═'))
   ")
)


\dekl_rapls
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GL [8.70]
:: OPIS: Deklaracja klasy wspomagającego obsługę komunikatów przy naliczaniu listy płac.
::  OLD: \rapls/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('RAPLS',@.CLASS)>=0
|| return()
?};

obj_decl('RAPLS',

   obj_fld('RAP',0),
   obj_fld('CON',0),
   obj_fld('TAB',0),

   obj_fld('webTerm',0),

   obj_meth('__init',"
      _a.TAB:=tab_tmp(3,
         'NAZWISKO','STRING[30]','Nazwisko'@,
         'IMIE','STRING[20]','Imię'@,
         'T','STRING[11]','Nr teczki/PESEL'@,
         'KOM','STRING[255]','Treść komunikatu'@,
         'LS','STRING[8]','Lista płac'@
      );
      _a.webTerm:=+app_info('web_sesid');
      {? ~_a.webTerm
      || _wnd:=_a.TAB.mk_sel('Komunikaty powstałe podczas '@,'T',0,'trapls',,,,,'U');
         _a.TAB.win_fld(_wnd,,'T',,,12,,,,,'Numer w aktach'@);
         _a.TAB.win_fld(_wnd,,'NAZWISKO',,,30,,,,,'Aktualne nazwisko'@);
         _a.TAB.win_fld(_wnd,,'IMIE',,,20,,,,,'Pierwsze imię'@);
         _a.TAB.win_fld(_wnd,,'KOM',,,50,,,,,'Treść komunikatu'@);
         _a.TAB.win_sel(_wnd);
         _a.TAB.win_act(_wnd,0,'Formuła','Drukuj'@@,,,,\"rep_exec('p_rapls')\",1,,,,,,'icon=print');
         _a.TAB.win_act(_wnd,0,'Formuła','Zamknij'@@,,,,\"sel_exit()\",1);
         _a.TAB.win_btn(_wnd,'text='+exec('text_red_zakoncz','#window','PKD_A')+',panel=bottom','menu:Z');
         _a.TAB.win_act(_wnd,0,'Kolejność')
      ?}
   "),

   obj_virt('msg',"0"),

   obj_meth('ustaw',"
      .RAP:={? var_pres('_a')=type_of(1) || _a || PAR_SKID.get(191)='N' ?};
      {? .RAP
      || .TAB.erase();
         .TAB.clear();
         set_virt(.,'msg',\"
            .TAB.T:=|_a;
            .TAB.NAZWISKO:=_b;
            .TAB.IMIE:=_c;
            _kom:='';
            {! _arg:=4.._
            |! _kom+=_[_arg]+' '
            !};
            .TAB.LS:=~(-O.LT);
            .TAB.KOM:=gsub(_kom,'\n',' ');
            {? _a<>'' | _b<>'' | _c<>''
            || .TAB.add()
            |? ~.TAB.find_rec()
            || .TAB.add()
            ?}
         \")
      || set_virt(.,'msg',\"
            _kom:='';
            {! _arg:=4.._
            |! _kom+=_[_arg]+'\n'
            !};
            _txt:=
               {? _b<>''
               || _b+' '+_c+{? _a<>'' || ' ('+(|_a)+')' || '' ?}+'\n'
               || ''
               ?}+_kom;
            {? .webTerm
            || web_msg(_txt)
            || FUN.info(_txt)
            ?}
         \")
      ?}
   "),

   obj_meth('raport',"
      _a:={? var_pres('_a')=type_of(1) || _a || 0 ?};
      {? .RAP & .TAB.first()
      || _txt:=
            {? _a=1 || 'wyliczenia danych do controllingu'@
            |? _a=2 || 'wprowadzania zapisów automatycznych'@
            |? _a=3 || 'grupowego tworzenia deklaracji podatkowych Pit-11 dla pracowników'@
            |? _a=4 || 'grupowego tworzenia deklaracji podatkowych Pit-11 dla zleceniobiorców'@
            |? _a=5 || 'tworzenia sprawozdania GUS Z-05'@
            |? _a=6 || 'tworzenia sprawozdania GUS Z-12'@
            |? _a=7 || 'grupowego tworzenia deklaracji podatkowych PIT-8C dla pracowników'@
            |? _a=8 || 'grupowego tworzenia deklaracji podatkowych PIT-8C dla zleceniobiorców'@
            |? _a=9 || 'wykonywania akcji grupowej związanej z e-ZLA'@
            || 'wyliczenia listy płac'@
            ?};
         .CON:=_a;
         {? ~.webTerm
         || .TAB.hdr_sel();
            .TAB.hdr_sel(_txt);
            .TAB.select()
         ?}
      ?}
   ")
)


\dekl_trace
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Deklaracja klasy wykorzystywanej do zapisu składnikow podstawy wynagrodzenia.
::   WE:
::   WY: ~~
::  OLD: \trace/kaliobi.fml
::----------------------------------------------------------------------------------------------------------------------
: zakończ, jeśli klasa została zadeklarowana
{? var_pres('Trace',@.CLASS)>0
|| return()
?};

obj_decl('Trace',
:  TAB - tabela tymczasowa, wzorowana na SK_CHO przechowująca dane wyłącznie dla jednego m-ca. Istotne informacje:
:     O - rodzaj informacji:
:        E - dane z etatu;
:        Z - dane z umów cywilnoprawnych;
:        % - zastosowany wspłóczynnik odbruttowienia (rekord techniczny, nie zapisywany w SK_CHO).
   obj_fld('TAB',~~),

:  NDX - tablica indeksów
   obj_fld('NDX',~~),

:  MNOZNIK - pole odpowiedzialne za znak z jakim zapisywane będą kwoty w metodzie add
   obj_fld('MNOZNIK',1),

   obj_meth('__init',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: "Konstruktor". Może być wywołany z innym obiektem klasy Trace, wówczas poza inicjacją ma miejsce kopiowanie
::       rekordow z drugiego obiektu.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      exec('__RUB','object');
      _a.TAB:=tab_tmp(4,
         'SK_NR','INTEGER','Nr składnika',
         'SKLADNIK','STRING[20]','Nazwa składnika',
         'O','STRING[1]','Rodzaj informacji',
         'LT','STRING[8]','Lista (źródło danych)',
         'KW','REAL','Kwota brutto',
         'KW_N','REAL','Kwota netto',
         'PRC','REAL','% odbruttowienia',
         'OPIS','STRING[150]','Opis'
      );
      _a.NDX:=obj_new(2);
      _a.NDX[1]:=_a.TAB.index('?');
      _a.NDX[2]:=_a.TAB.ndx_tmp(,,'O',,,'SK_NR',,,'SKLADNIK',,,'LT',,,'PRC',,,'OPIS',,);
      _a.TAB.win_sel(_a.TAB.mk_sel('Składniki'@,,1,'#skmwer_debug'));
      _a.TAB.win_edit(_a.TAB.mk_edit('Składnik'@,1,'#skmred_debug'));
      {? var_pres('_b')=var_pres('_a') || _a.add(_b) ?};
      ~~
   "),

   obj_meth('select',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Prezentuje bieżącą zawartosc tabeli tymczasowej.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      ".select('')",-1),

   obj_meth('select',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Prezentuje bieżącą zawartosc tabeli tymczasowej.
::   WE: _a - tytul okienka
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      .TAB.cntx_psh();
      .TAB.prefix();
      .TAB.hdr_sel();
      .TAB.hdr_sel(_a);
      .TAB.select();
      .TAB.cntx_pop();
      ~~
   ",type_of(''),-1),

   obj_meth('plus',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Zmiana znak kwoty zapisywanej w metodzie add na dodatni
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      ".MNOZNIK:=1; ~~",-1),

   obj_meth('minus',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Zmiana znak kwoty zapisywanej w metodzie add na ujemny
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      ".MNOZNIK:=-1; ~~",-1),

   obj_meth('erase',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Usuwa zgoromadzone dane.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      .TAB.clear();
      .TAB.erase()
   ",-1),

   obj_meth('add',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Dodaje przekazane parametrami informacje do tabeli śladów obliczeń. Jeżeli informacje są unikalne, to tworzony
::       jest nowy rekord, jeżeli informacje różnią się jedynie kwotami (w tabeli istnieje rekord o identycznych polach)
::       w znalezionym rekordzie modyfikowane są jedynie kwoty.
::   WE: _a - nr składnika (może być 0 dla informacji niebędącej składnikiem płacowym)
::       _b - nazwa składnika lub informacja [domyślnie zgodna z nazwa rubryki _a, niezbędny jeżeli _a=0]
::       _c - kwota brutto, jeżeli 0 - rekord nie będzie dodany
::       _d - lista (źródło danych)
::       _e - rodzaj informacji [domyślnie 'E']
::       _f - kwota netto [domyślnie 0]
::       _g - procent odbruttowienia [domyślnie 0]
::       _h - dodatkowy opis [domyślnie '']
::   WY: zapisana kwota brutto (_c)
::----------------------------------------------------------------------------------------------------------------------
      {? _a>=0 & _a<=__RUB.max()
      || _sk_nr:=_a
      || return(0)
      ?};
      {? var_pres('_b')<=0
      || _skladnik:=__RUB.RT[_sk_nr]
      |? var_pres('_b')=type_of('')
      || _skladnik:=_b
      || return(0)
      ?};
      {? var_pres('_c')=type_of(0) & _c<>0
      || _kw:=_c
      || return(0)
      ?};
      {? var_pres('_d')=type_of('')
      || _lt:=_d
      || return(0)
      ?};
      {? var_pres('_e')<=0
      || _okr:='E'
      |? var_pres('_e')=type_of('') & +_e=1 & 'EZW%'*_e
      || _okr:=_e
      || return(0)
      ?};
      {? var_pres('_f')<=0
      || _kw_n:=0
      |? var_pres('_f')=type_of(0)
      || _kw_n:=_f
      || return(0)
      ?};
      {? var_pres('_g')<=0
      || _prc:=0
      |? var_pres('_g')=type_of(0)
      || _prc:=_g
      || return(0)
      ?};
      {? var_pres('_h')<=0
      || _opis:=''
      |? var_pres('_h')=type_of('')
      || _opis:=_h
      || return(0)
      ?};

      .TAB.cntx_psh();
      .TAB.index(.NDX[2]);
      .TAB.prefix();
      {? .TAB.find_key(_okr,_sk_nr,_skladnik,_lt,_prc,_opis,)
      || _new:=0
      || _new:=1;
         .TAB.blank();
         .TAB.SK_NR:=_sk_nr;
         .TAB.LT:=_lt;
         .TAB.SKLADNIK:=_skladnik;
         .TAB.O:=_okr;
         .TAB.PRC:=_prc;
         .TAB.OPIS:=_opis
      ?};
      .TAB.KW+=.MNOZNIK*_kw;
      .TAB.KW_N+=.MNOZNIK*_kw_n;
:     Jeżeli jest to nowy rekord, to kwota nie jest zerowa - zostało to sprawdzone w chwili weryfikacji parametrów.
:     Jeżeli po aktualizacji rekordu kwota jest zerowa - rekord usuwamy, jeżeli nie jest zerowa zrzucamy bufor na dysk.
      _odp:=
         {? {? _new
            || .TAB.add()
            |? .TAB.KW=0
            || .TAB.del(,1)
            || .TAB.put()
            ?}
            || _kw
         ?};
:     Informacja o współczynniku odbruttowienia jest dodawana zawsze jako ostatnia w miesiącu. Jeżeli bieżący rekord
:     był właśnie informacją o współczynniku odbruttowienia - uzupełnijmy ją na wszystkich dotychczasowych rekordach
:     z rodzajem 'E' a bez współczynnika.
      {? _okr='%'
      || _dn:=.TAB.first();
         {!
         |? _dn
         |! {? .TAB.O='E' & .TAB.PRC=0
            || .TAB.PRC:=_kw;
               .TAB.put()
            ?};
            _dn:=.TAB.next()
         !}
      ?};
      .TAB.cntx_pop();
      _odp
   ",type_of(0)),

   obj_meth('add',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Dodaje to tymczasowej tabeli TAB (bieżącego obiektu) rekordy z tabeli TAB wskazanego obiektu. Wczesniej, jeśli
::       jest to możliwe, uzupełniany współczynnik odbruttowienia (tylko dla rekordow rodzaju 'E').
::   WE: _a - wskazanie obiektu klasy Trace z rekordami do skopiowania
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      _a.TAB.index(_a.NDX[1]);
      _src:=_a.TAB;
      _dn:=_src.first();
      {!
      |? _dn
      |! .add(_src.SK_NR,_src.SKLADNIK,_src.KW,_src.LT,_src.O,_src.KW_N,_src.PRC,_src.OPIS);
         _dn:=_src.next()
      !};
      ~~
   ",THIS,-1),

   obj_meth('save',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Zapisuje zawartość tabeli tymczasowej TAB na dysku - tworzy rekordy tabeli SK_CHO.
::   WE: _a - wskazanie nieobecności
::       _b - miesiąc do podstawy (data)
::   WY: wynik operacji 1/0
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('__KORZ')>0 & __KORZ || return(1) ?};
      _nref:=_a;
      _mc:=_b;
      .TAB.index(.NDX[1]);
      {? .TAB.first()
      || _err:=0;
         N.cntx_psh();
         N.clear();
         {? ~N.seek(_nref)
         || _err+=1
         || SK_CHO.cntx_psh();
            SK_CHO.use('s_ch'+form(N.OD~1,-4,0,'9.'));
            SK_CHO.index('SK_CHO');
            SK_CHO.prefix(N.ref(),_mc);
            {!
            |? {? .TAB.O<>'%'
               || {? SK_CHO.find_key('M',.TAB.O,.TAB.SK_NR,.TAB.SKLADNIK,.TAB.LT,)
                  || SK_CHO.KW+=.TAB.KW;
                     SK_CHO.KW_N+=.TAB.KW_N;
                     {? SK_CHO.O='E' & SK_CHO.PRC=0
                     || SK_CHO.PRC:=.TAB.PRC
                     ?};
                     SK_CHO.OPIS+={? +SK_CHO.OPIS || ', ' || '' ?}+.TAB.OPIS;
                     {? ~SK_CHO.put()
                     || _err+=1
                     ?}
                  || SK_CHO.blank();
                     SK_CHO.NB:=N.ref();
                     SK_CHO.R:='M';
                     SK_CHO.O:=.TAB.O;
                     SK_CHO.SK_NR:=.TAB.SK_NR;
                     SK_CHO.SKLADNIK:=.TAB.SKLADNIK;
                     SK_CHO.MC:=_mc;
                     SK_CHO.OD:=date(_mc~1,_mc~2,1);
                     SK_CHO.DO:=date(_mc~1,_mc~2,0);
                     SK_CHO.LT:=.TAB.LT;
                     SK_CHO.KW:=.TAB.KW;
                     SK_CHO.KW_N:=.TAB.KW_N;
                     SK_CHO.PRC:=.TAB.PRC;
                     SK_CHO.OPIS:=.TAB.OPIS;
                     {? ~SK_CHO.add()
                     || _err+=1
                     ?}
                  ?}
               ?};
               .TAB.next()
            !};
            SK_CHO.cntx_pop()
         ?};
         N.cntx_pop();
         ~_err
      || 1
      ?}
   ",type_of(null),type_of(date),-1)
)


\otworz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
VAR.RH:=null;
VAR.JESTRH:=0;
{? O.ref()
|| VAR.O:=O.ref();
   VAR.LISTA:=O.ref();
   VAR.JESTLIST:=1;
   VAR.NAZWALIS:=~-O.LT;
   LS.use(-O.LT);
   ZB_WART.use('q'+(-O.LT+7))

|| exec('zamknij','lista_plac')
?}


\zamknij
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
VAR.O:=null;
VAR.LISTA:=0;
VAR.JESTLIST:=0;
VAR.NAZWALIS:='';
VAR.RH:=null;
VAR.JESTRH:=0;
~~


\dekl_licz_ls
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
::       RWR [12.30]
:: OPIS: Formula zawiera deklaracje obiektu, do pol ktorego zapisywana jest formula wykorzystywana podczas wyliczen
::       podatku, zasilkow chorobowych, wynagrodzenia za urlop i podstawy skladek na fundusz emerytalny i rentowy.
::       Deklaracja klasy:       exec('licz','kaliobi')
::       Powolanie obiektu:      LICZ:=obj_new(@.CLASS.LICZ)
::       Pola w klasie:          odpowiadaja, co do nazwy, zmiennym uzywanym przy obliczaniu formul
::   WE:
::   WY:
::  OLD: \licz/kaliobi.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('LICZ',@.CLASS)>=100
|| return()
?};

exec('__RUB','object');

obj_decl('LICZ',
   obj_fld('POD',''),
   obj_fld('POD_P',''),
   obj_fld('ZUS',''),
   obj_fld('CHO',''),
   obj_fld('CHOL',''),
   obj_fld('URL',''),
   obj_fld('EKW',''),
   obj_fld('UBZ',''),
   obj_fld('start',''),
   obj_fld('stop',''),
   obj_fld('poj','100,120,121,122,123'),
:  W związku z odwoływaniem się do atrybutów,
:  wartości pola pominCHO, pominURL są tworzone dynamicznie w metodzie Build().

   obj_fld('pominCHO',''),
   obj_fld('pominURL',''),
   obj_fld('RUB_CHO',~~),
   obj_fld('dane',~~),
   obj_fld('fun',~~),


   obj_meth('__init',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Konstruktor - tworzy wykorzystywane tabele tymczasowe i wypełnia tablicę fun.
::       Elementy tablicy fun są wykorzystywane w dwóch miejscach:
:        - do budowy formuł zapisywanych w polach obiektu (metoda .End());
:        - do pominięcia wybranych składników z wyliczeń (metoda .Wylicz()).
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      exec('__RUB','object');
      _a.RUB_CHO:=tab_tmp(1,
         'RN','INTEGER','Numer'
      );
      _a.dane:=tab_tmp(3,
         'GR','STRING[4]','Grupa',
         'TYP','STRING[1]','Typ',
         'ODLP','INTEGER','Od - L.p.',
         'DOLP','INTEGER','Do - L.p.',
         'POJ','INTEGER','Poj?',
         'ODRN','INTEGER','Od - R.RN',
         'DORN','INTEGER','Do - R.RN'
      );
      _a.fun:=obj_new('L','Lt','S','LP','LPt','LPzp');
      _a.fun.L:=$'\\'L(\\'+$_a+\\',\\'+$_b+\\',_a)\\'';
      _a.fun.Lt:=$'\\'L(\\'+$_a+\\',\\'+$_b+\\',_a,,_d)\\'';
      _a.fun.S:=$'\\'S(\\'+$_a+\\',,,,_a)\\'';
      _a.fun.LP:=$'\\'LP(\\'+$_a+\\',\\'+$_b+\\',_a,,1,,_k)\\'';
      _a.fun.LPzp:=$'\\'LP(\\'+$_a+\\',\\'+$_b+\\',_a,,,,_k)\\'';
      _a.fun.LPt:=$'\\'LP(\\'+$_a+\\',\\'+$_b+\\',_a,,1,_d,_k)\\'';
      ~~
   "),

   obj_meth('InList',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda wewnętrzna, sprawdza, czy element wystepuje na liście.
::   WE: _a - sprawdzany element (numer).
::       _b - łańcuch znakowy z elementami oddzielonymi przecinkami.
::   WY: 0 - element nie występuje na liście.
::       n - element występuje na liście, poczynajac od n-tego znaku.
::----------------------------------------------------------------------------------------------------------------------
      (','+_b+',')*(','+$_a+',')
   ",type_of(0),type_of(''),-1),

   obj_meth('InList',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda wewnętrzna, sprawdza, czy element wystepuje na liście.
::   WE: _a - sprawdzany element (napis).
::       _b - łańcuch znakowy z elementami oddzielonymi przecinkami.
::   WY: 0 - element nie występuje na liście.
::       n - element występuje na liście, poczynajac od n-tego znaku.
::----------------------------------------------------------------------------------------------------------------------
      (','+_b+',')*(','+_a+',')
   ",type_of(''),type_of(''),-1),

   obj_meth('Build',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda odpowiedzialna za konstrukcję formuł wyliczających:
::       CHO   - wynagrodzenie chorobowe
::       CHOL  - wynagrodzenie chorobowe (z bieżącego miesiąca)
::       POD   - podatek
::       POD_P   - podatek z FUNKCJE.LP
::       UBZ   - podstawę ubezpieczenia zdrowotnego (kasa chorych)
::       URL   - wynagrodzenie za urlop
::       EKW   - ekwiwalent za urlop
::       ZUS   - podstawę składek na ubezpieczenie emerytalne i rentowe
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      .Clear();
      .pominCHO:='100,101,102,103,110,111,7158,'+__RUB.sys_sql(46)+','+__RUB.sys_sql(422)+','+__RUB.sys_sql(4211);
      .pominCHO+=','+__RUB.sys_sql(423)+','+__RUB.sys_sql(424)+','+__RUB.sys_sql(425)+','+__RUB.sys_sql(427);
      _pom_URL:=__RUB.sys_sql(101122);
      {? +_pom_URL
      || .pominURL:=_pom_URL
      || _przestoj:=__RUB.sys_sql(453);
         {? +_przestoj || _przestoj:=','+_przestoj ?};
         .pominURL:='100,101,102,103,110,120,121,122,123,125,126,7050,7040,7052,7054,7058,7158'+_przestoj
      ?};
      R.cntx_psh();
      R.index('RUBKOD');
      R.prefix();
      {? R.first()
      || _lp:=0;
         {!
         |? echo('Uaktualnianie obiektu'@,'Rubryka: %1'@[$R.RN]);
            _lp+=1;
            .Fill('CHO',R.CHO,_lp);
            .Fill('CHOL',R.CHO,_lp);
            .Fill('POD',R.POD,_lp);
            .Fill('POD_P',R.POD,_lp);
            .Fill('UBZ',R.UBZ,_lp);
            .Fill('URL',R.URL,_lp);
            .Fill('EKW',R.EKW,_lp);
            .Fill('ZUS',R.ZUS,_lp);
            {? R.CHO<>'N' & ~.InList(R.RN,.pominCHO)
            || .RUB_CHO.RN:=R.RN;
               .RUB_CHO.add()
            ?};
            R.next()
         !};
         &_lp;
         .End('CHO');
         .End('CHOL');
         .End('POD');
         .End('POD_P');
         .End('UBZ');
         .End('URL');
         .End('EKW');
         .End('ZUS');
         echo()
      ?};
      R.cntx_pop();
      ~~
   "),

   obj_meth('Fill',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda pomocnicza (wewnętrzna) wykorzystywana do optymalizacji tworzonych formuł. Buduje tabele tymczasową z
::       przedziałami rubryk, które można połączyć w jednym wywołaniu.
::   WE: _a - grupa składnikowa (CHO,CHOL,POD,POD_P,UBZ,URL,EKW,ZUS)
::       _b - typ wartości; rubryki są łączone w ramach grupy i typu;
::       _c - lp rubryki; wartość wirtualna, umożliwiająca łączenie rubryk o niekolejnych numerach. Dokladniej:
::            jeżeli po rubryce nr 111 następuje od razu rubryka 120, to zapis L(111,120) tak na prawdę uwzględnia
::            wyłącznie rubryki 111 i 120. Takie połączenie będzie możliwe, poniewaą lp dla rubryki 120 będzie tylko
::            o 1 większe niż lp dla rubryki 111.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      _gr:=_a;
      _typ:=_b;
      _lp:=_c;

      {? _typ='N'
      || return()
      ?};

      {? (_gr='URL' | _gr='EKW') & .InList(R.RN,.pominURL)
      || return()
      ?};
      {? _gr='CHO' & .InList(R.RN,.pominCHO)
      || return()
      ?};
      {? _gr='CHOL' &
         (__RUB.sys_attr(R.RN,422) | __RUB.sys_attr(R.RN,4211) | __RUB.sys_attr(R.RN,46) | __RUB.sys_attr(R.RN,423) |
            __RUB.sys_attr(R.RN,424) | __RUB.sys_attr(R.RN,425) | __RUB.sys_attr(R.RN,452) | __RUB.sys_attr(R.RN,427))
      || return()
      ?};

:     Czy analizowana rubryka musi występować indywidualnie (pojedyńczo) - nie może być łączona z innymi?
:     Do rubryk takich należą:
:        - rubryki wymienione w polu .poj;
:        - wszystkie rubryki CHOrobowe Uzupelniane lub brane w Stałej wysokości (nominalnej) - typy: P i S;
:        - wszystkie rubryki URLopowe lub  EKWiwalentowe brane nie w kwocie,
:          ale zależne do H.S1 lub H.S2 lub H.S3 - typy: 1, 2 i 3.
      _czypoj:=.InList(R.RN,.poj) | (3+_gr='CHO' & (_typ='P' | _typ='S')) | ((_gr='URL' | _gr='EKW') & _typ<>'T');

      .dane.prefix(_gr,_typ);
:     Jeżeli bieżąca rubryka może być zaklasyfikowana jako kontynuacja poprzedniej - aktualizujemy rekord z przedziałem.
      {? .dane.last() & .dane.DOLP+1=_lp & ~.dane.POJ & ~_czypoj
      || .dane.DOLP:=_lp;
         .dane.DORN:=R.RN;
         .dane.put()
:     Nowy przedzial.
      || .dane.blank();
         .dane.GR:=_gr;
         .dane.TYP:=_typ;
         .dane.ODLP:=.dane.DOLP:=_lp;
         .dane.POJ:=_czypoj;
         .dane.ODRN:=.dane.DORN:=R.RN;
         .dane.add()
      ?};
      .dane.prefix();
      ~~
   "),

   obj_meth('End',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda pomocnicza (wewnętrzna) odpowiedzialna za faktyczną budowę formuł obliczających na podstawie danych
::       (przedziałów) zebranych w tabeli tymczasowej .dane.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      _gr:=_a;

      _str:=obj_new('L','UT','UL','BU');
      {? _gr='URL' | _gr='EKW'
      || _str.UT:=obj_new(3);
         _str.UL:=obj_new(3);
         _str.BU:=obj_new(3);
:        Budowa tablica baza:
:                1     2
:           1  s1s   s1n
:           2  s2s   s2n
:           3  s3s   s3n
         _baza:=obj_new(3);
         {! _nr:=1 .. 3 |! _baza[_nr]:=obj_new(2) !}; &_nr;
         _baza[1][1] := '_e'; _baza[1][2] := '_f';
         _baza[2][1] := '_g'; _baza[2][2] := '_h';
         _baza[3][1] := '_i'; _baza[3][2] := '_j'
      ?};
:     UT - uzupelnianie z Trace'em
:     UL - uzupelnianie bez Trace'a
:     L - bez uzupelniania
      {! _nri:=1 .. obj_len(_str)
      |! {? var_pres('['+$_nri+']',_str)>100
         || {! _nrj:=1 .. obj_len(_str[_nri]) |! _str[_nri][_nrj]:='' !}; &_nrj
         || _str[_nri]:=''
         ?}
      !};
      &_nri;

      .dane.prefix(_gr,);
      {? .dane.first()
      || {!
         |? {? 3+_gr='CHO' & (.dane.TYP='P' | .dane.TYP='S')
            || {? .dane.TYP='P'
               || _kws:=.fun.L(.dane.ODRN,.dane.DORN)+'/_e*(_f-_g)$2';
                  _str.UT+=';'
                     '{?'+.fun.L(.dane.ODRN,.dane.DORN)+
                     '||_odp+=_d.add('+$.dane.ODRN+',,'+_kws+',_lt,,,,\\'UzupP|\\'+_opis)'+
                     '?}';
                  _str.UL+={? _str.UL='' || '' || '; ' ?}+'_odp+='+_kws;
                  &_kws
               |? .dane.TYP='S'
               || _kws:=.fun.S(.dane.ODRN);
                  _str.UT+=';'+
                     '{?'+.fun.L(.dane.ODRN,.dane.DORN)+
                     '||_odp+=_d.add('+$.dane.ODRN+',,'+_kws+',_lt,,,,\\'UzupS|\\'+_opis)'+
                     '?}';
                  _str.UL+={? _str.UL='' || '' || '; ' ?}+'_odp+='+_kws;
                  &_kws
               ?};
               _str.BU+={? _str.BU='' || '' || '; ' ?}+'_odp+='+.fun.Lt(.dane.ODRN,.dane.DORN)

            |? _gr='URL' | _gr='EKW'
            || _kws:='{? _a=~~ | _l || '+.fun.Lt(.dane.ODRN,.dane.DORN)+' || '+.fun.LPt(.dane.ODRN,.dane.DORN)+' ?}';
               {? .dane.TYP='T'
               || _str.L+={? _str.L='' || '' || '+' ?}+_kws
               || _nr:=#.dane.TYP;
                  _kwp:='{? _a=~~ | _l || '+.fun.L(.dane.ODRN,.dane.DORN)+' || '+.fun.LP(.dane.ODRN,.dane.DORN)+' ?}'+
                     '*'+_baza[_nr][2]+'/'+_baza[_nr][1]+'$2';
                  _str.UT[_nr]+='; _odp+=_d.add('+$.dane.ODRN+',,'+_kwp+',_lt,,,,_opis)';
                  _str.UL[_nr]+={? _str.UL[_nr]='' || '' || '; ' ?}+'_odp+='+_kwp;
                  _str.BU[_nr]+={? _str.BU[_nr]='' || '' || '; ' ?}+'_odp+='+_kws;
                  &_kwp;
                  &_nr
               ?}
            |? _gr='POD_P'
            || _str.L+={? _str.L='' || '' || '+' ?}+.fun.LPzp(.dane.ODRN,.dane.DORN)
            || _str.L+={? _str.L='' || '' || '+' ?}+.fun.Lt(.dane.ODRN,.dane.DORN)
            ?};
            .dane.next()
         !};

         {? 3+_gr='CHO'
         || _odp:='{| FUNKCJE |! '+_str.L+
               {? _str.UT=''
               || ''
               || {? _str.L='' || '' || '+' ?}+
                  '( _odp:=0; '+
                  '{? _f-_g<>_e & _e>0 '+
                  '|| {? var_pres(\\'_d\\')=var_pres(\\'Trace\\',@.CLASS) '+
                     '|| _opis:=\\'Norma:\\'+$_f+\\'|Praca:\\'+$_e+\\'|NN:\\'+$_g; '+
                        '_lt:=\\'L\\'+(4+(2-date(O.R,O.M-{? _a<>~~ || _a ?},1)$0))+\\'???\\''+
                         _str.UT+' '+
                     '|| '+_str.UL+' '+
                     '?} '+
                  '|| '+_str.BU+' '+
                  '?}; _odp )'
               ?}+' |}'

         |? _gr='URL' | _gr='EKW'
         || _odp:=_str.L;
            {! _nr:=1 .. 3
            |! {? _str.UT[_nr]<>''
               || _odp+={? _odp='' || '' || '+' ?}+
                  '( _odp:=0; '+
                  '{? '+_baza[_nr][2]+'<>'+_baza[_nr][1]+' & '+_baza[_nr][1]+'>0 '+
                  '|| {? _jT '+
                     '|| _opis:=\\'Przeliczono po zmianie S'+$_nr+' (\\'+'+
                           'form('+_baza[_nr][1]+',,2,\\'9.\\')+\\'->\\'+'+
                           'form('+_baza[_nr][2]+',,2,\\'9.\\')+\\')\\''+
                         _str.UT[_nr]+' '+
                     '|| '+_str.UL[_nr]+' '+
                     '?} '+
                  '|| '+_str.BU[_nr]+' '+
                  '?}; _odp )'
               ?}
            !};
            _odp:=
               {? _str.UT[1]<>'' | _str.UT[2]<>'' | _str.UT[3]<>''
               || '_jT:=var_pres(\\'_d\\')=var_pres(\\'Trace\\',@.CLASS); '+
                  '_lt:=\\'L\\'+(4+(2-date(O.R,O.M-{? _a<>~~ || _a?},1)$0))+\\'???\\'; '
               || ''
               ?}+
               '{| FUNKCJE |! '+_odp+' |}'

         || _odp:='{| FUNKCJE |! '+_str.L+' |}'
         ?}
      || _odp:=''
      ?};
      .dane.prefix();
      {? _gr='URL' | _gr='EKW' || obj_del(_baza); &_baza ?};
      obj_del(_str); &_str;
      ($('.'+_gr+':=_a'))(_odp);
      ~~
   "),

   obj_meth('Clear',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda przygotowująca środowisko pracy - zmienne mają nadawane wartości początkowe, a tabele czyszczone.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      .RUB_CHO.erase();
      .dane.erase();
      .POD:=.POD_P:=.ZUS:=.CHO:=.URL:=.EKW:=.CHOL:=.UBZ:=''
   "),

   obj_meth('Wylicz',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda odpowiedzialna za właściwe wyliczenia dokonywane na podstawie przygotowanych wczesniej (.Build()) formuł
::       zapisanych w odpowiednich polach obiektu.
::   WE: _a - okres wstecz, względem bieżącego miesiąca, pominięcie parametru powoduje odwoływanie się do bieżącego
::            miesiaca
::       _b - grupa składnikowa poprzedzona kropką (.CHO,.CHOL,.POD,.POD_P.UBZ,.URL,.EKW,.ZUS)
::       _c - lista składników do pominięcia (np.'100,101,121'). Pomijać można wyłącznie składniki "pojedyncze" (patrz
::            opis zmiennej .poj w metodzie .Fill()). Funkcjonalność może być wykorzystywana np. do obsługi sytuacji, w
::            których dany składnik (dana rubryka) dla pracowników fizycznych jest wliczany, a dla pracownikow umysło-
::            wych - nie jest. Zamierzony efekt uzyskamy poprzez:
::            - zaznaczenie w rubrykach danego składnika, jako wchodzącego do wyliczeń;
::            - umieszczenie numeru rubryki w polu .poj;
::            - wywołania metody Wylicz
::              -- bez parametru _c (składnik będzie wliczony)
::              -- z parametrem _c równym numerowi składnika (w postaci łańcucha znakowego)
::       _d - obiekt klasy Trace (opcjonalnie).
::       Pozostale parametry zależą od aktualnie obsługiwanej grupy.
::       CHO/CHOL
::          _e - liczba dni przepracowanych przez pracownika
::          _f - liczba dni, które pracownik zobowiązany był przepracować
::          _g - liczba dni nieobecności nieusprawiedliwionych
::       URL/EKW
::          _e - H.S1 "stare" - w miesiącu, w którym był wypłacany składnik
::          _f - H.S1 "nowe" - aktualne
::          _g - H.S2 "stare"
::          _h - H.S2 "nowe"
::          _i - H.S3 "stare"
::          _j - H.S3 "nowe"
::          _k - miesiące wstecz liczone względem miesiąca kosztowego dla LP
::          _l - wymuszenie wyliczenia przez metodę L obiektu FUNKCJE
::
::       UWAGA: Do formuły zapisanej w polu obiektu przekazywanych jest zawsze 10 argumentow, zgodnych z tymi, z którymi
::       wywołano metodę .Wylicz(), mimo, że nie wszystkie są w niej wykorzystywane.
::   WY: kwota obliczona przez formule z odpowiedniego pola obiektu
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_a')<>type_of(0)
      || _a:=~~
      ?};
      {? ~(var_pres('_b')=type_of('') & .InList(_b,'.CHO,.CHOL,.POD,.POD_P,.UBZ,.URL,.EKW,.ZUS'))
      || return(0)
      ?};
      {? var_pres('_c')<>type_of('')
      || _c:=~~
      ?};
      {? var_pres('_d')<>var_pres('Trace',@.CLASS)
      || _d:=~~
      ?};
      {? 4+_b='.CHO'
      || _e:={? var_pres('_e')=type_of(0) || _e || 0 ?};
         _f:={? var_pres('_f')=type_of(0) || _f || 0 ?};
         _g:={? var_pres('_g')=type_of(0) || _g || 0 ?};
         _h:=_i:=_j:=_k:=_l:=~~
      |? _b='.URL' | _b='.EKW'
      || _e:={? var_pres('_e')=type_of(0) || _e || 0 ?};
         _f:={? var_pres('_f')=type_of(0) || _f || 0 ?};
         _g:={? var_pres('_g')=type_of(0) || _g || 0 ?};
         _h:={? var_pres('_h')=type_of(0) || _h || 0 ?};
         _i:={? var_pres('_i')=type_of(0) || _i || 0 ?};
         _j:={? var_pres('_j')=type_of(0) || _j || 0 ?};
         _k:={? var_pres('_k')=type_of(0) || _k || 0 ?};
         _l:={? var_pres('_l')=type_of(0) || _l || 0 ?}
      || _e:=_f:=_g:=_h:=_i:=_j:=_k:=_l:=~~
      ?};
      _formula:=($_b)();
      {? _formula<>''
      || {? _c<>~~
         || _skl:=spli_str(_c,',');
            {! _nrs:=1..obj_len(_skl)
            |! {? _skl[_nrs]<>''
               || {! _nrf:=1..obj_len(.fun)
                  |! _formula:=gsub(_formula,.fun[_nrf]($_skl[_nrs],$_skl[_nrs]),'0')
                  !};
                  &_nrf
               ?}
            !};
            &_nrs;
            obj_del(_skl);
            &_skl
         ?};
         ($(_formula))(_a,_b,_c,_d,_e,_f,_g,_h,_i,_j,_k,_l)
      ?}
   ")
)


\dekl_licz_rh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DAROKR [8.70]
:: OPIS: Formuła zawiera deklarację klasy, do pól którego zapisywana jest formuła wykorzystywana podczas wyliczeń
::       podatku, zasiłków chorobowych, wynagrodzenia za urlop i podstawy składek na fundusz emerytalny i rentowy.
::   WE:
::   WY:
::  OLD: \liczrhs/kaliobi.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('LICZRHS',@.CLASS)>=100
|| return()
?};

obj_decl('LICZRHS',
   obj_fld('POD',''),
   obj_fld('ZUS',''),
   obj_fld('CHO',''),
   obj_fld('CHOL',''),
   obj_fld('URL',''),
   obj_fld('UBZ',''),
   obj_fld('start',''),
   obj_fld('stop',''),
   obj_fld('poj','100,120,121,122,123'),
   obj_fld('pominCHO','100,101,102,103,110,111'),
   obj_fld('pominURL','100,101,102,103,110,120,121,122,123,125,126'),

   obj_meth('__init',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      _a.start:=obj_new(5);
      _a.stop:=obj_new(5);
      {! _i:=1..5
      |! _a.start[_i]:=_a.stop[_i]:=0
      !}
   "),

   obj_meth('InList',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda wewnętrzna, sprawdza, czy rubryka występuje na liście lista.
::   WE: _a - numer rubryki.
::       _b - lista rubryk, łańcuch znakowy z numerami rubryk oddzielonymi przecinkami.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      (','+_b+',')*(','+$_a+',')
   ",type_of(0),type_of(''),-1),

   obj_meth('Build',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      .Clear();
      R.cntx_psh();
      R.index('RUBKOD');
      R.clear();
      {? R.first()
      || {!
         |? echo('Uaktualnianie obiektu','Rubryka: '+$R.RN);
            .Fill(R.POD,'.POD',1);
            .Fill(R.ZUS,'.ZUS',2);
            .Fill(R.URL,'.URL',3);
            .Fill(R.CHO,'.CHOL',4);
            .Fill(R.UBZ,'.UBZ',5);
            R.next()
         !};
         .End('.POD',1);
         .End('.ZUS',2);
         .End('.URL',3);
         .End('.CHOL',4);
         .End('.UBZ',5);
         .With()
      ?};
      R.cntx_pop();
      echo()
   "),

   obj_meth('Fill',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      _url:={? _b='.URL' || ~.InList(R.RN,.pominURL) || 1 ?};
      {? _a='T' & ~.InList(R.RN,.poj) & _url
      || {? .start[_c]=0
         || .start[_c]:=R.RN
         ?};
         .stop[_c]:=R.RN
      || {? _a='T' & .InList(R.RN,.poj) & _url
         || {? .start[_c]
            || _f:=$('LICZRHS'+_b);
               {? _f()<>''
               || _f:=$('LICZRHS'+_b+'+=''+''');
                  _f()
               ?};
               _f:=$('LICZRHS'+_b+'+=''Z('+$.start[_c]+','+$.stop[_c]+',_a,,,_b)''');
               _f();
               .start[_c]:=.stop[_c]:=0
            ?};
            .start[_c]:=.stop[_c]:=R.RN
         ?};
         {? .start[_c]
         || _f:=$('LICZRHS'+_b);
            {? _f()<>''
            || _f:=$('LICZRHS'+_b+'+=''+''');
               _f()
            ?};
            _f:=$('LICZRHS'+_b+'+=''Z('+$.start[_c]+','+$.stop[_c]+',_a,,,_b)''');
            _f();
            .start[_c]:=.stop[_c]:=0
         ?}
      ?}
   "),

   obj_meth('End',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? .start[_b]>0
      || _f:=$('LICZRHS'+_a);
         {? _f()<>''
         || _f:=$('LICZRHS'+_a+'+=''+''');
            _f()
         ?};
         _f:=$('LICZRHS'+_a+'+=''Z('+$.start[_b]+','+$.stop[_b]+',_a,,,_b)''');
         _f();
         .start[_b]:=.stop[_b]:=0
      ?}
   "),

   obj_meth('Clear',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {! _i:=1..3
      |! .start[_i]:=.stop[_i]:=0
      !};
      .POD:=.ZUS:=.CHO:=.URL:=.CHOL:=.UBZ:=''
   "),

   obj_meth('With',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? .POD<>''
      || .POD:='{| FUNKCJE |! '+.POD+' |}'
      ?};
      {? .ZUS<>''
      || .ZUS:='{| FUNKCJE |! '+.ZUS+' |}'
      ?};
      {? .CHOL<>''
      || .CHOL:='{| FUNKCJE |! '+.CHOL+' |}'
      ?};
      {? .URL<>''
      || .URL:='{| FUNKCJE |! '+.URL+' |}'
      ?};
      {? .UBZ<>''
      || .UBZ:='{| FUNKCJE |! '+.UBZ+' |}'
      ?}
   "),

   obj_meth('Wylicz',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_a')=1
      || {? _a=0 || _a:=~~ ?}
      ?};
      {? var_pres('_c')<>2
      || _c:=~~
      ?};
      {? var_pres('_d')<>var_pres('Trace',@.CLASS)
      || _d:=~~
      ?};
      {? ($_b)()=''
      || 0
      || {? _c=~~
         || _f:=($_b)();
            ($_f)(_a,_d)
         || _g:=($_b)();
            STR.split(_c,',');
            {!
            |? {? _s:=STR.get_word();
                  _g*_s & _s<>''
               || _w:='+Z('+_s+','+_s+',_a)';
                  _g:=STR.gsub(_g,_w,'');
                  _w:=(1-_w)+'+';
                  _g:=STR.gsub(_g,_w,'');
                  _w:=_w-1;
                  _g:=STR.gsub(_g,_w,'')
               ?};
               STR.next()
            !};
            {? _g*'Z('
            || ($_g)(_a,_d)
            ?}
          ?}
      ?}
   "),
)


\dekl_dolist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Deklaracja zmiennych używanych do obliczeń formuł listy płac. Pola obiektu reprezentują te zmienne.
::   WE:
::   WY:
::  OLD: \dolist/kaliobi.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('DoList',@.CLASS)>=100
|| return()
?};

obj_decl('DoList',
    obj_fld('d',date),
    obj_fld('p',0),
    obj_fld('q',0),
    obj_fld('o',0),
    obj_fld('r',0),
    obj_fld('z',0),
    obj_fld('zm',0),
    obj_fld('a',0),
    obj_fld('b',0),
    obj_fld('c',0),
    obj_fld('u',0),
    obj_fld('s',0),
    obj_fld('m',0),
    obj_fld('n',0),
    obj_fld('l',0),
    obj_fld('k',0),
    obj_fld('f',0),
    obj_fld('e',0),
    obj_fld('x',date),

    obj_meth('__init',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Konstruktor.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
       _a.d:=obj_new(14);
       _a.p:=obj_new(19);
       {! _i:=1..obj_len(_a.p)
       |! _a.p[_i]:=0
       !};
       _a.q:=obj_new(1);
       _a.r:=obj_new(4);
       _a.o:=obj_new(4);
       _a.u:=obj_new(3);
       _a.c:=obj_new(14);
       {! _i:=1..obj_len(_a.c)
       |! _a.c[_i]:=0
       !};
       _a.b:=obj_new(3);
       _a.s:=obj_new(11);
       _a.m:=obj_new(15);
       _a.k:=obj_new(73);
       {! _ii:=1..obj_len(_a.k)
       |! _a.k[_ii]:=0
       !};
       _a.l:=obj_new(14);
       _a.n:=obj_new(14);
       _a.z:=obj_new(25)
   ")
)


\dekl_funkcje
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Deklaracja klasy FUNKCJE
::   WE:
::   WY:
::  OLD: \funkcje/kaliobi.fml
::  OLD: \l/funkcje.fml
::  OLD: \z/funkcje.fml
::  OLD: \sz/funkcje.fml
::  OLD: \kr/funkcje.fml
::  OLD: \ks/funkcje.fml
::  OLD: \oblicz/wyrskl.fml
::  OLD: \liczgodz/godziny.fml
:: UWAGA! Obiekt funkcje bazuje na aktualnie wskazywanych rekordach tabel: P, O, RH. W przypadku wykorzystania obiektu
::        należy zadbać o ustalenie odpowiednich pozycji kursorów.
::----------------------------------------------------------------------------------------------------------------------
: zakończ, jeśli klasa została zadeklarowana
{? var_pres('FUNKCJE',@.CLASS)>100
|| return()
?};

obj_decl('FUNKCJE',
:  bufor składników
   obj_fld('buff',0),
   obj_fld('TraceType',~~),
:: Pole obiektu dla ustalenia sposobu pracy z listami.
:: Uwzględnia parametr: "266"  na liście parametrów. Obowiązuje od pierwszego dnia miesiąca dla wprowadzonej daty.
   obj_fld('PODATEK',0),
   obj_fld('PL_NEW',0),
   obj_fld('NUMER',0),
   obj_fld('DATA',date(0,0,0)),
   obj_fld('LICZ_POD',0),

   obj_meth('__init',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: "Konstruktor". Dodatkowo tworzy wymagane podczas działania obiekty.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      exec('__RUB','object');
      exec('LISTA','object');
      exec('RAPLS','object');

      exec('dekl_cbuff','lista_plac');
      exec('dekl_trace','lista_plac');

      _a.buff:=obj_new(@.CLASS.CBUFF);
      _a.TraceType:=var_pres('Trace',@.CLASS)
   "),

   obj_meth('CZY_POD',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: pk [19.42]
:: OPIS: Weryfikacja sposobu rozliczenia zaliczki na podatek.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? .LICZ_POD & O.F_ZATR().KOD='P'
      || _wyn:=0;
         {? O.F='S'
         || _wyn:=1
         |? .DATA>O.D
         || _wyn:=1
         |? .DATA=O.D & .NUMER>=O.N
         || _wyn:=1
         ?};
         _wyn
      || 1
      ?}"),


   obj_meth('USTAW',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przygotowuje metody wirtualne do pracy w określonym kontekście.
::   WE: _a - kontekst pracy:
::          'E' - pracownicy
::          'Z' - zleceniobiorcy
::          wpp - nieokreślony
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      exec('ustaw','lista_plac',.,_a)
   ",type_of(''),-1),

   obj_meth('OTWOLIST',"
      exec('otworz','lista_plac')
   ",-1),

   obj_meth('OTWOLTRH',"
      VAR.O:=RH.O;
      VAR.LISTA:=RH.O;
      VAR.JESTLIST:=1;
      VAR.NAZWALIS:=~-RH.O().LT;
      VAR.RH:=RH.ref();
      VAR.JESTRH:=1;
      LS.use(-O.LT);
      LS.index('ZLECLPRU');
      ~~
   ",-1),

   obj_meth('USTAW_RH',"
      VAR.RH:=RH.ref();
      VAR.JESTRH:=1
   ",-1),

   obj_meth('ZAMKLIST',"
      .LICZ_POD:=0;
      exec('zamknij','lista_plac')
   ",-1),

   obj_meth('NUM_DATE',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: pk [19.42]
:: OPIS: Przypisanie informacji o dacie wypłaty i numerze listy z wybranego nagłówka listy do pól obiektu.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_a')=type_of(0) & _a=1
      || .NUMER:=O.N;
         .DATA:=O.D
      || .NUMER:=0;
         .DATA:=date(0,0,0)
      ?}"),

   obj_meth('ZNLISTY',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca oznaczenie listy płac.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      ~-(1-VAR.O().LT)
   ",-1),

   obj_meth('SPRLIST',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? VAR.JESTLIST
      || {? LS.name()<>-VAR.O().LT
         || FUN.error(
               'Wykryto niezgodność nagłówka z listą płac.\n'
               'Działanie programu zostanie przerwane.'@
            );
            break()
         || 1
         ?}
      ?}"),

   obj_meth('JESTLIST',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      (VAR.O<>null & .SPRLIST())
   ",-1),

   obj_meth('OBLICZ',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przelicza wszystkie składniki listy płac lub rachunku do umowy cywilnoprawnej.
::   WE:
::   WY: 0 - składniki uległy zmianie
::       1 - składniki pozostały bez zmian
::----------------------------------------------------------------------------------------------------------------------
      .OBLICZ(0)
   ",-1),

   obj_virt('OBLICZ',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przelicza składniki listy płac lub rachunku do umowy cywilnoprawnej.
::   WE: _a - składniki do obliczenia
::          0 - wszystkie składniki
::          1 - tylko składniki klasy T i #
::   WY: 0 - składniki uległy zmianie
::       1 - składniki pozostały bez zmian
::----------------------------------------------------------------------------------------------------------------------
      0
   ",type_of(0),-1),

   obj_virt('IS_BUFF',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Sprawdza, czy obliczenia mogą być realizowane "w pamięci".
::   WE:
::   WY: 0 - nie
::       1 - tak
::----------------------------------------------------------------------------------------------------------------------
      0
   ",type_of(SYSLOG)),

   obj_meth('RD_BUFF',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Odczytuje z bufora sumę składników o kodzie w podanym zakresie.
::   WE: _a - dolny kres przedziału
::       _b - górny kres przedziału
::       _c - obiekt klasy Trace
::   WY: suma składników
::----------------------------------------------------------------------------------------------------------------------
      _ret:=0;
      {? _a=_b
      || _no:=__RUB.MAP[_a];
         {? _no<>0
         || _val:=.buff.sum.val[_no];
            {? _val<>0
            || _ret+=
                  {? var_pres('_c')=.TraceType
                  || _c.add(_a,,_val,~.buff.name,.buff.Context)
                  || _val
                  ?}
            ?}
         ?}
      || {? _b<_a
         || _a==_b
         ?};
         {? var_pres('_c')<>.TraceType
         || _c:=~~
         ?};
         {! _ndx:=_a.._b
         |! _ret+=.RD_BUFF(_ndx,_ndx,_c)
         !}
      ?};
      _ret
   ",type_of(0),type_of(0)),

   obj_meth('SUM_TAB',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Ogólny sumator wartości.
::   WE: _a - alias tabeli
::       _b - nazwa zbioru
::       _c - akronim indeksu
::       _d - ograniczenie dziedziny
::       _e - dolny kres przedziału
::       _f - górny kres przedziału
::       _g - wskazanie obiektu klasy Trace
::   WY: suma wartości
::----------------------------------------------------------------------------------------------------------------------
      _ret_val:=0;
      _rodz:={? _c='ZLEC' || 'Z' || 'E' ?};
      _a.cntx_psh();
      _a.use(_b);
      _a.index(_c);
      {! _n:=_e.._f
      |! _a.prefix(_d,_n);
         _loop:=_a.first();
         {!
         |? _loop
         |! _ret_val+={? var_pres('_g')=.TraceType || _g.add(_n,,_a.KW,~_b,_rodz,,,_h) || _a.KW ?};
            _loop:=_a.next()
         !}
      !};
      _a.cntx_pop();
      _ret_val
   ",type_of(SYSLOG),type_of(''),type_of(''),type_of(null),type_of(0),type_of(0)),

   obj_meth('SUM_LS',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Sumator kwoty w tabeli LS.
::   WE: _a - ograniczenie dziedziny
::       _b - nazwa zbioru
::       _c - dolny kres przedziału
::       _d - górny kres przedziału
::       _e - wskazanie obiektu klasy Trace
::   WY: suma wartości
::----------------------------------------------------------------------------------------------------------------------
      {? _b=''
      || return(0)
      ?};
      {? var_pres('_e')<>.TraceType
      || _e:=~~
      ?};
      _f:={? var_pres('_f')=type_of(null) || _f || null ?};
      {? _f
      || LS.cntx_psh();
         LS.use(_b);
         LS.index('OSOBAKOD');
         _ret_val:=0;
         {! _ndx:=_c.._d
         |! LS.prefix(exec('ref_firma','ustawienia'),_a,_ndx);
            _loop:=LS.first();
            {!
            |? _loop
            |! {? LS.P<>_f | _g
               || _ret_val+={? var_pres('_e')=.TraceType || _e.add(_ndx,,LS.KW,~_b,'E',,,'') || LS.KW ?}
               ?};
               _loop:=LS.next()
            !}
         !};
         LS.cntx_pop();
         _ret_val
      || .SUM_TAB(LS,_b,'PRACNRRU',_a,_c,_d,_e,'')
      ?}
   ",type_of(null),type_of(''),type_of(0),type_of(0)),

   obj_meth('SUM_RH',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Sumator kwoty dla tabeli RH.
::   WE: _a - wskazanie rachunku
::       _b - dolny kres przedziału
::       _c - górny kres przedziału
::       _d - wskazanie obiektu klasy Trace
::   WY: suma wartości
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_d')<>.TraceType
      || _d:=~~
      ?};
      ZC.cntx_psh();
      RH.cntx_psh();
      RH.prefix();
      _opis:={? RH.seek(_a) || '['+form(RH.ZLE().NU)+'|'+ZC.DZ$2+'|'+RH.DWY$2+']' || '???' ?};
      RH.cntx_pop();
      ZC.cntx_pop();
      O.cntx_psh();
      _wyn:=.SUM_TAB(LS,RH.O().LT,'ZLEC',_a,_b,_c,_d,_opis);
      O.cntx_pop();
      _wyn
   ",type_of(null),type_of(0),type_of(0)),

   obj_meth('WR_BUFF',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zapis danych do bufora.
::   WE: _a - numer rubryki
::       _b - konto kosztow
::       _c - kwota
::       _d - zeruj składnik
::       _e - wskazanie obiektu klasy Trace
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      _rn:=_a;
      {? (_no:=__RUB.MAP[_a])=0
      || return(0)
      ?};
      _acc:=
         {? var_pres('_b')<>7
         || .buff.DefAccnt()
         || _b
         ?};
      {? var_pres('_e')=.TraceType
      || _e.add(_rn,,_c,~.buff.name,.buff.Context)
      ?};

      _ret:=0;
      _org:=.buff.sum.val[_no];
      {? _i:=.buff.Find(_no)
      || {? _d
         || .buff.EmpIN(_i);
            .buff.sum.val[_no]:=0;
            .buff.sum.ndx[_no]:=0;
            .buff.list:=gsub(.buff.list,','+$_no+',',',')

         |? _b=~~ & _c=~~
         || _ret:=.buff.sum.val[_no]

         |? _b=~~ & _c<>~~
         || {? .buff.data.mod[_i]=0
            || .buff.sum.val[_no]+=(_c-.buff.data.val[_i]);
               .buff.data.val[_i]:=_c;
               _ret:=_c
            ?};
            _ret:=.buff.data.val[_i]

         || _fnd:=0;
            {!
            |? _i
            |! {? .buff.data.acc[_i]=_b
               || {? _c<>~~ & .buff.data.mod[_i]=0
                  || .buff.sum.val[_no]+=(_c-.buff.data.val[_i]);
                     .buff.data.val[_i]:=_c
                  ?};
                  _fnd+=1;
                  _ret+=.buff.data.val[_i]
               ?};
               _i:=.buff.data.ndx[_i]
            !};
            {? ~_fnd & _c<>~~
            || .buff.Add(_no,_c,_acc,0,0);
               _ret+=_c
            ?}
         ?}

      |? _c<>~~
      || _ret:=_c;
         .buff.Add(_no,_c,_acc,0,0)
      ?};

      {? _org<>.buff.sum.val[_no]
      || .buff.lk_mod+=1
      ?};

      _ret
   "),

   obj_meth('L',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::       [_f] [integer] - 1 - analizuje wszystkie listy bez względu na kolejność naliczania
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_b')<>1
      || _b:=_a
      |? _b<_a
      || _b==_a
      ?};
      {? _a<=0 | _a>__RUB.max() | _b<=0 | _b>__RUB.max()
      || return(.errmsg(1,'L'))
      ?};
      {? var_pres('_c')<>1
      || _c:=~~
      ?};
      {? var_pres('_d')<>1
      || _d:=~~
      ?};
      {? var_pres('_e')<>.TraceType
      || _e:=~~
      ?};
      _all:={? var_pres('_f')=type_of(0) || _f ?};
      {? _c=~~ & _d=~~
      || {? .IS_BUFF(LS)
         || .RD_BUFF(_a,_b,_e)
         || .SUM_LS(P.ref(),-VAR.NAZWALIS,_a,_b,_e)
         ?}
      || {? _c=~~
         || _c:=0
         ?};
         {? _d=~~ | _d<_c
         || _d:=_c
         ?};
         {? _c<0 | _d<0
         || return(.errmsg(1,'L'))
         ?};
         _ret_val:=0;
         _lista:=O.ref();
         _typ_lis:=O.T().T;
         _obl_lis:=O.T().L;
         _start:=date(O.R,O.M,1);
         O.cntx_psh();
         O_P.cntx_psh();
         O_P.index('P_RMK');
         {! _m:=_c.._d
         |! _msc:=date(_start~1,(_start~2)-_m,1);
            O_P.prefix('T',P.ref(),_msc~1,_msc~2,P.F_ZATR);
            _loop:=O_P.first();
            {!
            |? _loop
            |! {? {? _c=0 || O_P.O<>_lista || 1 ?}
               || O_P.O();
                  {? FUNKCJE.CZY_POD() | _all
                  || {? {? _obl_lis*'*' || 1
                        |? _obl_lis=''  || _typ_lis=O.T().T
                        || _obl_lis*(O.T().T)
                        ?}
                     || _ret_val+=.SUM_LS(P.ref(),O.LT,_a,_b,_e)
                     ?}
                  ?}
               ?};
               _loop:=O_P.next()
            !}
         !};
         O_P.cntx_pop();
         O.cntx_pop();
         _ret_val
      ?}
   ",type_of(0)),

   obj_meth('L_SYS',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE: [_f] [integer] - 1 - analizuje wszystkie listy bez względu na kolejność naliczania
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? _a<=0
      || return(.errmsg(1,'L_SYS'))
      ?};
      {? var_pres('_b')<>1
      || _b:=~~
      ?};
      {? var_pres('_c')<>1
      || _c:=~~
      ?};
      {? var_pres('_d')<>.TraceType
      || _d:=~~
      ?};
      {? var_pres('_e')<>type_of(null)
      || _e:=null
      ?};
      _f:={? var_pres('_f')=type_of(0) || _f ?};
      .L_EXT(_a,_b,_c,$'_a.sys_rub(_b,_c)',_d,_e,_f)
   ",type_of(0)),

   obj_meth('L_USR',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE: [_f] [integer] - 1 - analizuje wszystkie listy bez względu na kolejność naliczania
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? _a<=0
      || return(.errmsg(1,'L_USR'))
      ?};
      {? var_pres('_b')<>1
      || _b:=~~
      ?};
      {? var_pres('_c')<>1
      || _c:=~~
      ?};
      {? var_pres('_d')<>.TraceType
      || _d:=~~
      ?};
      {? var_pres('_e')<>type_of(null)
      || _e:=null
      ?};
      _f:={? var_pres('_f')=type_of(0) || _f ?};
      .L_EXT(_a,_b,_c,$'_a.usr_rub(_b,_c)',_d,_e,_f)
   ",type_of(0)),

   obj_meth('L_EXT',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE: _g [integer] - 1 - analizuje wszystkie listy bez względu na kolejność naliczania
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      _val:=0;
      {? var_pres('_e')<>.TraceType
      || _e:=~~
      ?};
      {? var_pres('_f')<>type_of(null)
      || _f:=null
      ?};
      _g:={? var_pres('_g')=type_of(0) || _g ?};
      _start:=date(O.R,O.M,0);

      {? _b=~~ & _c=~~
      || _R:=_d(__RUB,_a,O.D);
         _loop:=_R.first();
         {!
         |? _loop
         |! _val+=.L(_R.RN,,,,_e);
            _loop:=_R.next()
         !};
         obj_del(_R)
      || {? _b=~~
         || _b:=0
         ?};
         {? _c=~~ | _c<_b
         || _c:=_b
         ?};
         {? _b<0 | _c<0
         || return(.errmsg(1,'L_EXT'))
         ?};
         O.cntx_psh();
         O.index('LISTYPLA');
         _lista:=O.ref();
         _typ_lis:=O.T().T;
         _obl_lis:=O.T().L;
         {! _m:=_b.._c
         |! _msc:=date(_start~1,(_start~2)-_m,0);
            O.prefix(exec('ref_firma','ustawienia'),__F_ZATR.O,_msc~1,_msc~2);
            _R:=_d(__RUB,_a,_msc);
            {? _R.first() & O.first()
            || {!
               |? {? .CZY_POD() | _g
                  || {? {? _b=0 || O.ref()<>_lista | _f || 1 ?}
                        &
                        {? _obl_lis=''  || _typ_lis=O.T().T
                        |? _obl_lis*'*' || 1
                        || _obl_lis*(O.T().T)
                        ?}
                     || {!
                        |? {? _f
                           || _val+=.SUM_LS(P.OSOBA,O.LT,_R.RN,_R.RN,_e,_f,O.ref()<>_lista)
                           || _val+=.SUM_LS(P.ref(),O.LT,_R.RN,_R.RN,_e)
                           ?};
                           _R.next()
                        !}
                     ?}
                  ?};
                  O.next() & _R.first()
               !}
            ?};
            obj_del(_R)
         !};
         O.cntx_pop()
      ?};
      _val
   ",type_of(0)),

   obj_meth('Z',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Funkcja zwraca wartość składnika lub sumę składników rachunków z określonego okresu.
::   WE: _a - kod rubryki (obowiązkowy)
::       _b - kod rubryki (dodatkowy)
::       _c - okres od wstecz, względem miesiąca bieżącego rachunku (dodatkowy)
::       _d - okres do wstecz, względem miesiąca bieżącego rachunku (dodatkowy)
::       _e - czy sumowanie dotyczy rachunków z tytułem ubezpieczenia zgodnym z bieżącą umową [1-tak, 0-nie]]
::       _f - obiekt klasy Trace (dodatkowy)
::   WY: wartosc skladnika lub sume skladnikow list(y) plac.
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_b')<>1
      || _b:=_a
      |? _b<_a
      || _b==_a
      ?};
      {? _a<=0 | _a>__RUB.max() | _b<=0 | _b>__RUB.max()
      || return(.errmsg(1,'Z'))
      ?};
      {? var_pres('_c')<>1
      || _c:=~~
      ?};
      {? var_pres('_d')<>1
      || _d:=~~
      ?};
      {? var_pres('_e')=1
      || _e:=_e<>0
      || _e:=0
      ?};
      {? var_pres('_f')<>.TraceType
      || _f:=~~
      ?};

      {? _c=~~ & _d=~~
      || {? .IS_BUFF(LS) & .buff.Context='Z'
         || .RD_BUFF(_a,_b,_f)
         || .SUM_RH(RH.ref(),_a,_b,_f)
         ?}
      || {? _c=~~
         || _c:=0
         ?};
         {? _d=~~ | _d<_c
         || _d:=_c
         ?};
         {?  _c<0 | _d<0
         || return(.errmsg(1,'Z'))
         ?};
         _ret_val:=0;
         RH.cntx_psh();
         RH.index('RACHDATA');
         _rh:=RH.ref();
         _osoba:=RH.ZLE().OSOBA;
         _ttub:=
            {? _e
            || exec('rhttub','lista_plac',_osoba,RH.DWY,RH.ZC_INFO().TTUB().KOD,RH.ZC_INFO().DW)
            || RH.ZC_INFO().TTUB().KOD
            ?};

         _start:=date(RH.R,RH.M,1);
         {! _m:=_c.._d
         |! _mies:=date(_start~1,_start~2-_m,1);
            RH.prefix(exec('ref_firma','ustawienia'),_osoba,_mies~1,_mies~2);
            _loop:=RH.first();
            {!
            |? _loop
            |! {? ~_e | _ttub=exec('rhttub','lista_plac',_osoba,RH.DWY,RH.ZC_INFO().TTUB().KOD,RH.ZC_INFO().DW)
               || {? {? _c=0 || RH.ref()<>_rh || 1 ?}
                  || _ret_val+=.SUM_RH(RH.ref(),_a,_b,_f)
                  ?}
               ?};
               _loop:=RH.next()
            !}
         !};
         RH.cntx_pop();
         _ret_val
      ?}
   ",type_of(0)),

   obj_meth('Z_SYS',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda bliźniacza dla Z() ale operująca na atrybucie systemowym, a nie rubrykach.
::   WE: _a - symbol atrybutu systemowego
:        _b - okres od sumowania (wstecz, względem b.m.)
:        _c - okres do sumowania (wstecz, względem b.m.)
:        _d - czy sumować tylko rachunki ze zgodnym tytułem ubezpieczenia?
:        _e - obiekt klasy Trace
::   WY: suma
::----------------------------------------------------------------------------------------------------------------------
      _od:={? _>1 || _b || ~~ ?};
      _do:={? _>2 || _c || ~~ ?};
      _ub:={? _>3 || _d || ~~ ?};
      _tt:={? _>4 || _e || ~~ ?};

      _sum:=0;
      _R:=__RUB.sys_zakres(_a,date(RH.R,RH.M,0));
      _loop:=_R.first();
      {!
      |? _loop
      |! _sum+=.Z(_R.RN_P,_R.RN_K,_od,_do,_ub,_tt);
         _loop:=_R.next()
      !};
      _sum
   ",type_of(0)),

   obj_meth('Z_USR',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda bliźniacza dla Z() ale operująca na atrybucie użytkownika, a nie rubrykach.
::   WE: _a - symbol atrybutu systemowego
:        _b - okres od sumowania (wstecz, względem b.m.)
:        _c - okres do sumowania (wstecz, względem b.m.)
:        _d - czy sumować tylko rachunki ze zgodnym tytułem ubezpieczenia?
:        _e - obiekt klasy Trace
::   WY: suma
::----------------------------------------------------------------------------------------------------------------------
      _od:={? _>1 || _b || ~~ ?};
      _do:={? _>2 || _c || ~~ ?};
      _ub:={? _>3 || _d || ~~ ?};
      _tt:={? _>4 || _e || ~~ ?};

      _sum:=0;
      _R:=__RUB.usr_zakres(_a,date(RH.R,RH.M,0));
      _loop:=_R.first();
      {!
      |? _loop
      |! _sum+=.Z(_R.RN_P,_R.RN_K,_od,_do,_ub,_tt);
         _loop:=_R.next()
      !};
      _sum
   ",type_of(0)),

   obj_meth('LU',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
::       RWR [12.30]
:: OPIS: Metoda zwraca sumę składnika (skladników) z list płac o miesiącach ubezpieczeniowych zgodnych z miesiącem
::       ubezpieczeniowym bieżącej listy płac. Dodatkowo funkcja może przy agregowaniu uwzględniać również poprzednie
::       miesiące. Sumowanie odbywa się dla OSOBY, więc uwzględnione zostaną wszystkie etaty.
::   WE: _a - kod rubryki (obowiązkowy)
::       _b - kod rubryki (dodatkowy)
::       _c - lista dla _c miesiąca wstecz, względem aktualnie wybranej listy płac (dodatkowy)
::       _d - lista dla _d miesiąca wstecz, względem aktualnie wybranej listy płac (dodatkowy)
::       _e - obiekt klasy Trace
::      [_f] [integer] - 1 - analizuje wszystkie listy bez względu na kolejność naliczania
::   WY: suma skladnikow
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_b')<>1
      || _b:=_a
      |? _b<_a
      || _b==_a
      ?};
      {? _a<=0 | _a>__RUB.max() | _b<=0 | _b>__RUB.max()
      || return(.errmsg(1,'LU'))
      ?};
      {? var_pres('_c')<>1
      || _c:=~~
      |? _c<0
      || return(.errmsg(1,'LU'))
      ?};
      {? var_pres('_d')<>1
      || _d:=~~
      |? _d<0
      || return(.errmsg(1,'LU'))
      ?};
      {? var_pres('_e')<>.TraceType
      || _e:=~~
      ?};
      _f:={? var_pres('_f')=type_of(0) || _f ?};
      exec('lu','lista_plac',_a,_b,_c,_d,.,_e,_f)
   ",type_of(0)),

   obj_meth('LU_SYS',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda bliźniacza dla LU() ale operująca na atrybucie systemowym, a nie rubrykach.
::   WE: _a - symbol atrybutu systemowego
::       _b - okres od sumowania (wstecz, względem b.m.)
::       _c - okres do sumowania (wstecz, względem b.m.)
::       _d - obiekt klasy Trace
::       [_e] - [integer] = 1 - analizuje wszystkie listy bez względu na kolejność naliczania
::   WY: suma
::----------------------------------------------------------------------------------------------------------------------
      _od:={? _>1 || _b || ~~ ?};
      _do:={? _>2 || _c || ~~ ?};
      _tt:={? _>3 || _d || ~~ ?};
      _all:={? var_pres('_e')=type_of(0) || _e ?};
      _sum:=0;
      _R:=__RUB.sys_zakres(_a,date(O.RU,O.MU,0));
      _loop:=_R.first();
      {!
      |? _loop
      |! _sum+=.LU(_R.RN_P,_R.RN_K,_od,_do,_tt,_all);
         _loop:=_R.next()
      !};
      _sum
   ",type_of(0)),

   obj_meth('LU_USR',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda bliźniacza dla LU() ale operująca na atrybucie użytkownika, a nie rubrykach.
::   WE: _a - symbol atrybutu systemowego
::       _b - okres od sumowania (wstecz, względem b.m.)
::       _c - okres do sumowania (wstecz, względem b.m.)
::       _d - obiekt klasy Trace
::       [_e] - [integer] = 1 - analizuje wszystkie listy bez względu na kolejność naliczania
::   WY: suma
::----------------------------------------------------------------------------------------------------------------------
      _od:={? _>1 || _b || ~~ ?};
      _do:={? _>2 || _c || ~~ ?};
      _tt:={? _>3 || _d || ~~ ?};
      _all:={? var_pres('_e')=type_of(0) || _e ?};
      _sum:=0;
      _R:=__RUB.usr_zakres(_a,date(O.RU,O.MU,0));
      _loop:=_R.first();
      {!
      |? _loop
      |! _sum+=.LU(_R.RN_P,_R.RN_K,_od,_do,_tt,_all);
         _loop:=_R.next()
      !};
      _sum
   ",type_of(0)),

   obj_meth('LP',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
::       RWR [12.30]
:: OPIS: Funkcja zwraca sumę składnika (składników) z list płac o miesiącach podatkowych zgodnych z miesiącem
::       podatkowym bieżącej listy płac. Dodatkowo funkcja może przy agregowaniu uwzględniać również poprzednie
:        miesiące. Sumowanie odbywa sie dla OSOBY lub PRACOWNIKA (patrz parametr _e).
::   WE: _a - kod rubryki (obowiązkowy)
::       _b - kod rubryki (dodatkowy)
::       _c - lista dla _c miesiąca wstecz, względem aktualnie wybranej listy płac (dodatkowy)
::       _d - lista dla _d miesiąca wstecz, względem aktualnie wybranej listy płac (dodatkowy)
::       _e - sumowanie wg pracownika [0-nie, 1-tak]
::       _f - obiekt klasy Trace
::       _g - miesiące wstecz liczone względem miesiąca kosztowego listy
::       [_h] [integer] - 1 - analizuje wszystkie listy bez względu na kolejność naliczania
::   WY: suma składnikow
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_b')<>1
      || _b:=_a
      |? _b<0
      || _b==_a
      ?};
      {? _a<0 | _a>__RUB.max() | _b<0 | _b>__RUB.max()
      || return(.errmsg(1,'LP'))
      ?};
      {? var_pres('_c')<>1
      || _c:=~~
      |? _c<0
      || return(.errmsg(1,'LP'))
      ?};
      {? var_pres('_d')<>1
      || _d:=~~
      |? _d<0
      || return(.errmsg(1,'LP'))
      ?};
      {? var_pres('_e')<>1
      || _e:=0
      ?};
      {? var_pres('_f')<>.TraceType
      || _f:=~~
      ?};
      {? var_pres('_g')<>1
      || _g:=0
      ?};
      _h:={? var_pres('_h')=type_of(0) || _h ?};
      exec('lp','lista_plac',_a,_b,_c,_d,_e,.,_f,_g,_h)
   ",type_of(0)),

   obj_meth('LP_SYS',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda bliźniacza dla LP() ale operująca na atrybucie systemowym, a nie rubrykach.
::   WE: _a - symbol atrybutu systemowego
::       _b - okres od sumowania (wstecz, względem b.m.)
::       _c - okres do sumowania (wstecz, względem b.m.)
::       _d - sumowanie wg pracownika 0/1 - nie/tak
::       _e - wskazanie obiektu klasy Trace
::       _f - [integer] = 1 - analizuje wszystkie listy bez względu na kolejność naliczania
::       _g - miesiące wstecz liczone względem miesiąca kosztowego listy
::   WY: suma
::----------------------------------------------------------------------------------------------------------------------
      _od:={? _>1 || _b || ~~ ?};
      _do:={? _>2 || _c || ~~ ?};
      _pr:={? _>3 || _d || ~~ ?};
      _tt:={? _>4 || _e || ~~ ?};
      _all:={? var_pres('_f')=type_of(0) || _f ?};
      _koszt:={? var_pres('_g')=type_of(0) || _g ?};
      _sum:=0;
      _R:=__RUB.sys_zakres(_a,date(O.RP,O.MP,0));
      _loop:=_R.first();
      {!
      |? _loop
      |! _sum+=.LP(_R.RN_P,_R.RN_K,_od,_do,_pr,_tt,_koszt,_all);
         _loop:=_R.next()
      !};
      _sum
   ",type_of(0)),

   obj_meth('LP_USR',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda bliźniacza dla LP() ale operująca na atrybucie użytkownika, a nie rubrykach.
::   WE: _a - symbol atrybutu systemowego
::       _b - okres od sumowania (wstecz, względem b.m.)
::       _c - okres do sumowania (wstecz, względem b.m.)
::       _d - sumowanie wg pracownika 0/1 - nie/tak
::       _e - wskazanie obiektu klasy Trace
::       _f - [integer] = 1 - analizuje wszystkie listy bez względu na kolejność naliczania
::       _g - miesiące wstecz liczone względem miesiąca kosztowego listy
::   WY: suma
::----------------------------------------------------------------------------------------------------------------------
      _od:={? _>1 || _b || ~~ ?};
      _do:={? _>2 || _c || ~~ ?};
      _pr:={? _>3 || _d || ~~ ?};
      _tt:={? _>4 || _e || ~~ ?};
      _all:={? var_pres('_f')=type_of(0) || _f ?};
      _koszt:={? var_pres('_g')=type_of(0) || _g ?};
      _sum:=0;
      _R:=__RUB.usr_zakres(_a,date(O.RP,O.MP,0));
      _loop:=_R.first();
      {!
      |? _loop
      |! _sum+=.LP(_R.RN_P,_R.RN_K,_od,_do,_pr,_tt,_koszt,_all);
         _loop:=_R.next()
      !};
      _sum
   ",type_of(0)),

   obj_meth('LZ',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_b')<>1
      || _b:=_a
      |? _b<_a
      || _a==_b
      ?};
      {? var_pres('_c')<>1
      || _c:=0
      ?};
      {? var_pres('_d')<>1
      || _d:=_c
      |? _d<_c
      || _c==_d
      ?};
      {? _a<=0 | _a>=__RUB.max() | _b<=0 | _b>=__RUB.max() | _c<=0 | _d<=0
      || return(.errmsg(1,'LZ'))
      ?};
      {? var_pres('_e')<>2
      || _e:='u'
      || _e:=-_e;
         {? _e=''
         || _e:='u'
         ?}
      ?};
      {? ~('kup'*_e)
      || return(.errmsg(1,'LZ'))
      ?};
      {? var_pres('_f')=1
      || _f:=(_f<>0)
      || _f:=0
      ?};
      {? var_pres('_g')<>.TraceType
      || _g:=~~
      ?};

      exec('lz','lista_plac',_a,_b,_c,_d,_e,_f,.,_g)
   ",type_of(0)),

   obj_meth('LK',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? _a<=0 | _a>__RUB.max()
      || return(.errmsg(1,'LK'))
      ?};
      {? var_pres('_b')=1
      || {? _b<=0
         || return(.errmsg(1,'LK'))
         |? KK.seek(_b,KK.name())
         || _b:=KK.ref()
         ?}
      |? var_pres('_b')<>7
      || _b:=~~
      ?};
      {? var_pres('_c')<>1
      || _c:=~~
      ?};
      _d:=(var_pres('_d')=1 & _d);
      {? var_pres('_e')<>.TraceType
      || _e:=~~
      ?};

      .buff.Cntx();
      {? .buff.Context='E'
      || {? ~VAR.JESTLIST
         || return(.errmsg(3,'LK'))
         |? O.Z='T' & var_pres('_c')=type_of(0)
         || return(.errmsg(4,'LK'))
         ?};
         {? .IS_BUFF(LS)
         || return(.WR_BUFF(_a,_b,_c,_d,_e))
         ?}
      || return(0)
      ?};
      {? _b=~~ & _c=~~
      || return(.SUM_LS(P.ref(),-VAR.NAZWALIS,_a,_a,_e))
      ?};

      exec('lk','lista_plac',_a,_b,_c,_d,.,_e)
   ",type_of(0)),

   obj_meth('LK_SYS',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda bliźniacza dla LK() ale operująca na atrybucie systemowym, a nie rubryce.
::   WE: _a - symbol atrybutu systemowego
::       _b - konto kosztow
::       _c - kwota do zapisu
::       _d - czy usunac zapis
::       _e - obiekt klasy Trace
::   WY: suma, jeśli składniki nie będą usuwane
::----------------------------------------------------------------------------------------------------------------------
      _kk:={? _>1 || _b || ~~ ?};
      _kw:={? _>2 || _c || ~~ ?};
      _rm:={? _>3 || _d || ~~ ?};
      _tt:={? _>4 || _e || ~~ ?};

      _dt:=date(O.R,O.M,0);
      {? _kw<>~~ | _rm<>~~
      || .LK(__RUB.sys_kod(_a,_dt),_kk,_kw,_rm,_tt)
      || _ret:=0;
         _R:=__RUB.sys_rub(_a,_dt);
         _loop:=_R.first();
         {!
         |? _loop
         |! _ret+=.LK(_R.RN,_kk,_kw,_rm,_tt);
            _loop:=_R.next()
         !};
         _ret
      ?}
   ",type_of(0)),

   obj_meth('LK_USR',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda bliźniacza dla LK() ale operująca na atrybucie użytkownika, a nie rubryce.
::   WE: _a - symbol atrybutu systemowego
::       _b - konto kosztow
::       _c - kwota do zapisu
::       _d - czy usunac zapis
::       _e - obiekt klasy Trace
::   WY: suma, jeśli składniki nie będą usuwane
::----------------------------------------------------------------------------------------------------------------------
      _kk:={? _>1 || _b || ~~ ?};
      _kw:={? _>2 || _c || ~~ ?};
      _rm:={? _>3 || _d || ~~ ?};
      _tt:={? _>4 || _e || ~~ ?};

      _dt:=date(O.R,O.M,0);
      {? _kw<>~~ | _rm<>~~
      || .LK(__RUB.usr_kod(_a,_dt),_kk,_kw,_rm,_tt)
      || _ret:=0;
         _R:=__RUB.usr_rub(_a,_dt);
         _loop:=_R.first();
         {!
         |? _loop
         |! _ret+=.LK(_R.RN,_kk,_kw,_rm,_tt);
            _loop:=_R.next()
         !};
         _ret
      ?}
   ",type_of(0)),

   obj_meth('ZK',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? _a<=0 | _a>__RUB.max()
      || return(.errmsg(1,'ZK'))
      ?};
      {? var_pres('_b')=1
      || {? _b<=0
         || return(.errmsg(1,'ZK'))
         |? KK.seek(_b,KK.name())
         || _b:=KK.ref()
         ?}
      |? var_pres('_b')<>7
      || _b:=~~
      ?};
      {? var_pres('_c')<>1
      || _c:=~~
      ?};
      _d:=(var_pres('_d')=1 & _d);
      {? var_pres('_e')<>.TraceType
      || _e:=~~
      ?};

      .buff.Cntx();
      {? .buff.Context='Z'
      || {? .IS_BUFF(LS)
         || return(.WR_BUFF(_a,_b,_c,_d,_e))
         ?}
      || return(0)
      ?};
      {? _b=~~ & _c=~~
      || return(.SUM_RH(RH.ref,_a,_a,_e))
      ?};

      exec('lk','lista_plac',_a,_b,_c,_d,.,_e)
   ",type_of(0)),

   obj_meth('LUK',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda dla potrzeb funkcji lu i lp - sumowanie składnikow wynagrodzenia dla OSOBY. Ze względu na wydajność kodu
::       NIE JEST ZACHOWYWANY KONTEKST TABELI LS a zmieniany jest klucz porządkujący i zakres danych. Należy o tym pa-
::       miętać podczas ewentualnego wykorzystania metody do innych celów. Do metody muszą być przekazane TRZY argumenty
::       czwarty argument oznacza sumowania w ramach pracownika. Jeśli ma być zwrócona suma składników o wybranym (jed-
::       nym) kodzie, to musi być on podwojony, np: FUNKCJE.LUK(100,100,1) przy czym argument _c oznacza uwzglednianie
::       składników "bieżącego" pracownika.
::   WE: _a - rubryka od
::       _b - rubryka do
::       _c - uwzględniać składniki "bieżącego" pracownika?
::       _d - zakres sumowania:
::          1 - w ramach pracownika
::          0 - w ramach osoby
::       _e - wskazanie obiektu klasy Trace
::   WY: suma składników
::----------------------------------------------------------------------------------------------------------------------
      _p:=P.ref();
      _ret:=0;
      {? var_pres('_d')<>1
      || _d:=0
      ?};
      {? var_pres('_e')=.TraceType
      || _val:=$'_b.add(_a,,LS.KW,VAR.NAZWALIS)'
      || _val:=$'LS.KW';
         _e:=~~
      ?};
      LS.index({? _d || 'PRACNRRU' || 'OSOBAKOD' ?});
      {? _a=_b
      || {? _d
         || LS.prefix(P.ref(),_a)
         || LS.prefix(exec('ref_firma','ustawienia'),P.OSOBA,_a)
         ?};
         {? LS.first()
         || {!
            |? {? _c | LS.P<>_p
               || _ret+=_val(_a,_e)
               ?};
               LS.next
            !}
         ?}
      || {? _d
         || LS.prefix(P.ref())
         || LS.prefix(exec('ref_firma','ustawienia'),P.OSOBA)
         ?};
         {? LS.find_ge(_a)
         || {!
            |? {? LS.RB().RN<=_b
               || {? _c | LS.P<>_p
                  || _ret+=_val(R.RN,_e)
                  ?};
                  LS.next
               ?}
            !}
         ?}
      ?};
      _ret
   ",type_of(0),type_of(0),type_of(0)),

   obj_meth('KR',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda zwraca kwotę raty/składki kredytu o podanym kodzie.
::   WE:
::   WY: kwota raty/składki
::----------------------------------------------------------------------------------------------------------------------
      {? _a<=0 | _a>__RUB.max()
      || return(.errmsg(1,'KR'))
      ?};
      {? var_pres('_b')=1
      || {? _b<0 | _b>__RUB.max()
         || return(.errmsg(1,'KR'))
         |? _b<_a
         || _b:=_a
         ?}
      || _b:=_a
      ?};
      {? ~VAR.JESTLIST
      || return(.errmsg(3,'KR'))
      ?};

      _ret:=0;
      K.cntx_psh();
      K.index('PRACPOZ');
      K.prefix(P.ref());
      {? K.first()
      || {!
         |? _c:=K.PO().RN;
            {? (_a<=_c & _c<=_b) & K.DR<=date(O.R,O.M,0)
            || {? (K.KP<0 & K.KS<0) | (K.KP>=0 & K.KS>=0)
               || _ret+=K.KR
               ?}
            ?};
            K.next()
         !}
      ?};
      K.cntx_pop();
      _ret
   ",type_of(0)),

   obj_meth('KS',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda zwraca saldo kredytu o podanym kodzie.
::   WE:
::   WY: saldo kredytu
::----------------------------------------------------------------------------------------------------------------------
      {? _a<=0 | _a>__RUB.max()
      || return(.errmsg(1,'KS'))
      ?};
      {? var_pres('_b')=1
      || {? _b<0 | _b>__RUB.max()
         || return(.errmsg(1,'KS'))
         |? _b<_a
         || _b:=_a
         ?}
      || _b:=_a
      ?};
      {? ~VAR.JESTLIST
      || return(.errmsg(3,'KS'))
      ?};

      _ret:=0;
      K.cntx_psh;
      K.index('PRACPOZ');
      K.prefix(P.ref());
      {? K.first()
      || {!
         |? _c:=K.PO().RN;
            {? (_a<=_c & _c<=_b) & K.DR<=date(O.R,O.M,0)
            || {? K.KR<>0 & ((K.KP<0 & K.KS<0) | (K.KP>=0 & K.KS>=0))
               || _ret+=K.KS
               ?}
            ?};
            K.next()
         !}
      ?};
      K.cntx_pop();
      _ret
   ",type_of(0)),

   obj_meth('S',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda realizuje dostęp do stałych składników list płac.
::   WE: _a - numer rubryki
::       _b - symbol konta kosztów (opcjonalnie)
::       _c - tryb pracy, w przypadku zmiany wartości w trakcie miesiąca:
::          0 - suma wszystkich wartości [domyślnie]
::          1 - średna kalendarzowa (miesiąc ma 30 dni)
::       _d - precyzja wyniku [domyślnie 2]
::       _e - okres wstecz, względem bieżącego miesiąca [domyślnie 0]
::       _f - względem miesiąca podatkowego listy płac
::   WY: kwota stałego składnika list płac
::----------------------------------------------------------------------------------------------------------------------
      {? _a<=0 | _a>__RUB.max()
      || return(.errmsg(1,'S'))
      ?};
      {? var_pres('_b')=2
      || {? _b=''
         || return(.errmsg(5,'S'))
         ?}
      || _b:=~~
      ?};
      _c:={? var_pres('_c')=type_of(0) || _c<>0 ?};
      _d:={? var_pres('_d')=type_of(0) & _d>0 || _d || 2 ?};
      _e:={? var_pres('_e')=type_of(0) || {? _e<0 || return(.errmsg(1,'S')) || _e ?} || 0 ?};
      _f:={? var_pres('_f')=type_of(0) || _f<>0 ?};
      exec('s','lista_plac',_a,_b,_c,_d,_e,_f)
   ",type_of(0)),

   obj_meth('SZ',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK 2006
:: OPIS: Metoda pobiera wartość ze stałych składnikow umow cywilnoprawnych
::   WE:  _a - numer składnika
::       [_b] - zaokrąglenie
::   WY: kwota wprowadzona w stałych składnikach umow cywilnoprawnych
::----------------------------------------------------------------------------------------------------------------------
      {? RH.KOR='T' || return(0) ?};
      {? _a<=0 | _a>__RUB.max()
      || return(.errmsg(1,'SZ'))
      ?};
      {? var_pres('_b')<>type_of(0)
      || _b:=2
      ?};

      _ret:=0;
      _zdate:=date(0,0,0);
      LSS.cntx_psh();
      LSS.index('PROPOZYC');
      LSS.prefix(P.ref(),_a);
      _loop:=LSS.first();
      {!
      |? _loop
      |! {? (LSS.OD<=RH.DWY | LSS.OD=_zdate) & (RH.DWY<=LSS.DO | LSS.DO=_zdate)
         || _ret+=LSS.KW$_b
         ?};
         _loop:=LSS.next()
      !};
      LSS.cntx_pop();
      _ret
   ",type_of(0)),

   obj_meth('W',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca kwotę wyrównań składnika dla bieżącej listy płac.
::   WE: _a - kod składnika
::   WY: kwota wyrównań
::----------------------------------------------------------------------------------------------------------------------
      {? _a<=0 | _a>__RUB.max()
      || return(.errmsg(1,'W'))
      ?};
      _ret:=0;
      LSW.cntx_psh();
      LSW.index('R');
      LSW.prefix(P.ref(),_a,VAR.NAZWALIS);
      {? LSW.first()
      || {!
         |? _ret+=LSW.KW$2;
            LSW.next()
         !}
      ?};
      LSW.prefix(P.ref(),_a);
      {? LSW.first() & LSW.LT=''
      || {!
         |? {? LSW.OD<=date(O.R,O.M,0)
            || LSW.LT:=VAR.NAZWALIS;
               _ret+=LSW.KW$2;
               {? LSW.put()
               || LSW.first()
               ?}
            || LSW.next()
            ?} & LSW.LT=''
         !}
      ?};
      LSW.cntx_pop();
      &_ret
   ",type_of(0)),

   obj_meth('G',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
:: OPIS: Metoda dostępu dla tabeli przepracowanych godzin.
::   WE: _a - kod rubryki początkowej
::       _b - kod rubryki końcowej
::       _c - zakres miesięcy dolny kraniec przedziału
::       _d - zakres miesięcy górny kraniec przedziału
::       _e - konto kosztów (symbol, numer lub wskazanie)
::       _f - rodzaj zapisów G - godziny
::   WY: suma wartości z tabeli G
::----------------------------------------------------------------------------------------------------------------------
      {? _a<=0 | _a>__RUB.max()
      || return(.errmsg(1,'G'))
      ?};
      {? var_pres('_b')<>1
      || _b:=_a
      |? _b<=0 | _b>__RUB.max()
      || return(.errmsg(1,'G'))
      ?};
      {? var_pres('_c')=1 || {? _c<0 || return(.errmsg(1,'G')) ?} || _c:=0 ?};
      {? var_pres('_d')=1 || {? _d<0 || return(.errmsg(1,'G')) ?} || _d:=0 ?};
      {? var_pres('_e')<>1 & var_pres('_e')<>2 & var_pres('_e')<>7
      || _e:=~~
      ?};
      {? var_pres('_f')<>2
      || _f:='G'
      ?};

      {? _c>_d || _c==_d ?};

      _RetVal:=0;
      G.cntx_psh();
      {! _Cnt:=_c.._d
      |! _DataLis:=date(O.R,O.M-_Cnt,1);
         _Rok:=_DataLis~1;
         _Msc:=_DataLis~2;
         _Mask:='godz'+(('0000'+$_Rok)+4);
         {? G.name<>_Mask
         || G.use(_Mask)
         ?};
         G.index('MSCKW_KK');
         {! _Rub:=_a.._b
         |! G.prefix(P.ref(),_Msc,_f,_Rub);
            {? G.first() & G.K().RK='R'
            || {!
               |? {? |G.LT=''
                  || G.LT:=VAR.NAZWALIS;
                     G.put()
                  ?};
                  {? G.LT=VAR.NAZWALIS
                  || _RetVal+={? type_of(_e)=0 || G.G
                              |? type_of(_e)=2 & G.KK().SYM=_e || G.G
                              |? (type_of(_e)=1 | type_of(_e)=7) & G.KK=_e || G.G
                              || 0
                              ?}
                  ?};
                  G.next
               !}
            ?}
         !}
      !};
      G.cntx_pop();
      _RetVal
   ",type_of(0)),

   obj_meth('NK',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? _a<=0 | _a>__RUB.max()
      || return(.errmsg(1,'NK'))
      ?};
      {? var_pres('_b')<>1
      || _b:=_a
      |? _b<=0 | _b>__RUB.max()
      || return(.errmsg(1,'NK'))
      ?};
      {? var_pres('_c')=1  || {? _c<0 || return(.errmsg(1,'NK')) ?}
      |? var_pres('_c')<>4 || _c:=~~
      ?};
      {? var_pres('_d')=1  || {? _d<0 || return(.errmsg(1,'NK')) ?}
      |? var_pres('_d')<>4 || _d:=~~
      ?};
      {? var_pres('_e')<>1 || _e:=0 ?};

      exec('fn','lista_plac',_a,_b,_c,_d,'K',_e,.)
   ",type_of(0)),

   obj_meth('NK_SYS',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda bliźniacza dla NK ale operująca na atrybucie systemowym, a nie kodzie rubryki.
::   WE: _a - symbol atrybutu systemowego
::       _b - miesiąc wstecz (LICZBA) względem miesiąca aktualnej listy płac, od którego rozpoczyna się sumowanie, lub
::            dzień, od którego rozpocznie się sumowanie (dla typu DATA)
::       _c - miesięc wstecz (LICZBA) względem miesiąca aktualnej listy płac, na którym zakończy się sumowanie, lub
::            dzień, na którym zakończy się sumowanie (dla typu DATA)
::       _d - czy pomijać wstawianie znaku listy płac w nieobecnościach:
::            0 - znak bedzie wstawiany [domyślnie]
::            1 - znak nie będzie wstawiany
::   WY: Liczba dni kalendarzowych dla nieobecności i okresu przekazanych parametrami wywołania
::----------------------------------------------------------------------------------------------------------------------
      _od:={? _>1 || _b || ~~ ?};
      _do:={? _>2 || _c || ~~ ?};
      _tr:={? _>3 || _d || ~~ ?};
      _odp:=0;
      _tab:=__RUB.sys_zakres(_a,date(O.R,O.M,0));
      {? _tab.first()
      || {!
         |? _odp+=.NK(_tab.RN_P,_tab.RN_K,_od,_do,_tr);
            _tab.next()
         !}
      ?};
      _odp
   ",type_of(0)),

   obj_meth('NR',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? _a<=0 | _a>__RUB.max()
      || return(.errmsg(1,'NR'))
      ?};
      {? var_pres('_b')<>1
      || _b:=_a
      |? _b<=0 | _b>__RUB.max()
      || return(.errmsg(1,'NR'))
      ?};
      {? var_pres('_c')=1  || {? _c<0 || return(.errmsg(1,'NR')) ?}
      |? var_pres('_c')<>4 || _c:=~~
      ?};
      {? var_pres('_d')=1  || {? _d<0 || return(.errmsg(1,'NR')) ?}
      |? var_pres('_d')<>4 || _d:=~~
      ?};
      {? var_pres('_e')<>1  || _e:=0 ?};

      exec('fn','lista_plac',_a,_b,_c,_d,'R',_e,.)
   ",type_of(0)),

   obj_meth('NR_SYS',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda bliźniacza dla NR ale operująca na atrybucie systemowym, a nie kodzie rubryki.
::   WE: _a - symbol atrybutu systemowego
::       _b - miesiąc wstecz (LICZBA) względem miesiąca aktualnej listy płac, od którego rozpoczyna się sumowanie, lub
::            dzień, od którego rozpocznie się sumowanie (dla typu DATA)
::       _c - miesiąc wstecz (LICZBA) względem miesiąca aktualnej listy płac, na którym kończy się sumowanie, lub dzien,
::            na którym zakończy się sumowanie (dla typu DATA)
::       _d - czy pomijać wstawianie znaku listy płac w nieobecnościach:
::          0 - znak będzie wstawiany [domyślnie]
::          1 - znak nie będzie wstawiany
::   WY: Liczba dni roboczych dla nieobecności i okresu przekazanych parametrami wywołania
::----------------------------------------------------------------------------------------------------------------------
      _od:={? _>1 || _b || ~~ ?};
      _do:={? _>2 || _c || ~~ ?};
      _tr:={? _>3 || _d || ~~ ?};
      _odp:=0;
      _tab:=__RUB.sys_zakres(_a,date(O.R,O.M,0));
      {? _tab.first()
      || {!
         |? _odp+=.NR(_tab.RN_P,_tab.RN_K,_od,_do,_tr);
            _tab.next()
         !}
      ?};
      _odp
   ",type_of(0)),

   obj_meth('NG',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? _a<=0 | _a>__RUB.max()
      || return(.errmsg(1,'NG'))
      ?};
      {? var_pres('_b')<>1
      || _b:=_a
      |? _b<=0 | _b>__RUB.max()
      || return(.errmsg(1,'NG'))
      ?};
      {? var_pres('_c')=1  || {? _c<0 || return(.errmsg(1,'NG')) ?}
      |? var_pres('_c')<>4 || _c:=~~
      ?};
      {? var_pres('_d')=1  || {? _d<0 || return(.errmsg(1,'NG')) ?}
      |? var_pres('_d')<>4 || _d:=~~
      ?};
      {? var_pres('_e')<>1  || _e:=0 ?};

      exec('fn','lista_plac',_a,_b,_c,_d,'G',_e)
   ",type_of(0)),

   obj_meth('NG_SYS',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Metoda bliźniacza dla NG ale operująca na atrybucie systemowym, a nie kodzie rubryki.
::   WE: _a - symbol atrybutu systemowego
::       _b - miesiąc wstecz (LICZBA) względem miesiąca aktualnej listy płac, od którego rozpoczyna się sumowanie, lub
::            dzień, od którego rozpocznie się sumowanie (dla typu DATA)
::       _c - miesiąc wstecz (LICZBA) względem miesiąca aktualnej listy płac, na którym kończy się sumowanie, lub dzien,
::            na którym zakończy się sumowanie (dla typu DATA)
::       _d - czy pomijać wstawianie znaku listy płac w nieobecnościach:
::          0 - znak będzie wstawiany [domyślnie]
::          1 - znak nie będzie wstawiany
::   WY: Liczba godzin roboczych dla nieobecności i okresu przekazanych parametrami wywołania
::----------------------------------------------------------------------------------------------------------------------
      _od:={? _>1 || _b || ~~ ?};
      _do:={? _>2 || _c || ~~ ?};
      _tr:={? _>3 || _d || ~~ ?};
      _odp:=0;
      _tab:=__RUB.sys_zakres(_a,date(O.R,O.M,0));
      {? _tab.first()
      || {!
         |? _odp+=.NG(_tab.RN_P,_tab.RN_K,_od,_do,_tr);
            _tab.next()
         !}
      ?};
      _odp
   ",type_of(0)),

   obj_meth('OKRG',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      _fld_val:=$('O.'+_c);
      {? _a>_b
      || {? _b=0
         || _b:=_a
         || _a==_b
         ?}
      ?};
      {? _a=0 & _b=0
      || return(_fld_val())
      ?};
      _ret:=0;
      O.cntx_psh();
      O.index('LISTYPLA');
      O.prefix(exec('ref_firma','ustawienia'),__F_ZATR.O);
      _start:=date(O.R,O.M,1);
      _type:=O.T().T;
      {! _m:=_a.._b |!
         _month:=date(_start~1,(_start~2)-_m,1);
         {? O.find_key(_month~1,_month~2,_type)
         || _ret+=_fld_val()
         ?}
      !};
      O.cntx_pop();
      _ret
   ",type_of(0),type_of(0),type_of('')),

   obj_meth('OK',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_a')=1
      || {? _a<0 | _a>__RUB.max()
         || return(.errmsg(1,'OK'))
         ?}
      || _a:=0
      ?};
      {? var_pres('_b')=1
      || {? _b<0 | __RUB.max()
         || return(.errmsg(1,'OK'))
         ?}
      || _b:=0
      ?};
      {? ~VAR.JESTLIST
      || return(0)
      ?};

      .OKRG(_a,_b,'DK')
   "),

   obj_meth('OR',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_a')=1
      || {? _a<0 | _a>__RUB.max()
         || return(.errmsg(1,'OR'))
         ?}
      || _a:=0
      ?};
      {? var_pres('_b')=1
      || {? _b<0 | __RUB.max()
         || return(.errmsg(1,'OR'))
         ?}
      || _b:=0
      ?};
      {? ~VAR.JESTLIST
      || return(0)
      ?};

      .OKRG(_a,_b,'DR')
   "),

   obj_meth('OG',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_a')=1
      || {? _a<0 | _a>__RUB.max()
         || return(.errmsg(1,'OG'))
         ?}
      || _a:=0
      ?};
      {? var_pres('_b')=1
      || {? _b<0 | __RUB.max()
         || return(.errmsg(1,'OG'))
         ?}
      || _b:=0
      ?};
      {? ~VAR.JESTLIST
      || return(0)
      ?};

      .OKRG(_a,_b,'GR')
   "),

   obj_meth('USUNZLIS',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE: _a - działanie w trybie wsadowym (nie jest zadawane pytanie o usuwanie składników)
::          1 - tak
::          wpp - nie
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      _bulk:=(var_pres('_a')=type_of(0) & _a=1);
      {? .SPRLIST() & {? ~_bulk || FUN.ask('Czy na pewno usunąć składniki listy płac?'@) || 1 ?}
      || exec('usun_dane','lista_plac')
      ?}
   "),

   obj_meth('TESTKRYT',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_a')<>1
      || _a:=0
      |? _a<0
      || return(.errmsg(1,'TESTKRYT'))
      ?};
      on_error(2);
      _test:=($(O.T().K))();
      {? in_error()
      || on_error(0);
         return(0)
      ?};
      _ret:=0;
      {? _test=~~ | _test<>0
      || _ret:=1
      |? _a
      || _ret:=FUN.ask(
            '%1 %2 nie spełnia kryterium listy płac.\n'
            'Czy na pewno redagować składniki?'@
            [P.OSOBA().NAZWISKO,OSOBA.PIERWSZE]
         )
      ?};
      on_error(0);
      _ret
   "),

   obj_meth('OBLICZDS',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      exec('oblicz_ds','lista_plac',{? var_pres('_a')=type_of(0) || _a || ~~ ?})
   "),

   obj_meth('NOMINAL',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_a')=1
      || exec('t_nominals','lista_plac',_a)
      || exec('t_nominals','lista_plac')
      ?}
   "),

   obj_meth('TBANK',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_a')=1
      || exec('t_banks','lista_plac', _a)
      || exec('t_banks','lista_plac')
      ?}
   "),

   obj_meth('TPRAC',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? ~VAR.JESTLIST
      || return(.errmsg(3,'TPRAC'))
      ?};
      {? var_pres('_a')<=(-1)
      || LISTA.Czytaj(LS.name());
         LS.index('PRACORUB');
         1
      |? var_pres('_a')=type_of('')
      || LISTA.Czytaj(_a);
         LS.index('PRACORUB');
         1
      || {? ~(var_pres('_a')=var_pres('_b')=var_pres('_c')=type_of(0))
         || .errmsg(0,'TPRAC')
         || exec('t_prac','lista_plac',_a,_b,_c)
         ?}
      ?}
   "),

   obj_meth('TZLEC',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? var_pres('_a')<=(-1)
      || LISTA.Czytaj(LS.name,1);
         1
      |? var_pres('_a')=type_of('')
      || LISTA.Czytaj(_a,1);
         1
      || {? ~(var_pres('_a')=var_pres('_b')=var_pres('_c')=type_of(0))
         || .errmsg(0,'TZLEC')
         || exec('t_prac','lista_plac',_a,_b,_c)
         ?}
      ?}
   "),

   obj_meth('TWYDZ',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? ~VAR.JESTLIST
      || return(.errmsg(3,'TWYDZ'))
      ?};
      {? var_pres('_a')<=(-1)
      || LISTA.Copy('Wydz');
         {! _i:=1..obj_len(LISTA.SWydz)
         |! LISTA.SWydz[_i]:=0
         !}
      || {? ~(var_pres('_a')=var_pres('_b')=var_pres('_c')=type_of(0))
         || .errmsg(0,'TWYDZ')
         || exec('t_wydz','lista_plac',_a,_b,_c)
         ?}
      ?}
   "),

   obj_meth('TZAKL',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      {? ~VAR.JESTLIST
      || return(.errmsg(3,'TZAKL'))
      ?};
      {? var_pres('_a')<=(-1)
      || LISTA.Copy('Zakl');
         {! _i:=1..obj_len(LISTA.SZakl)
         |! LISTA.SZakl[_i]:=0
         !}
      || {? ~(var_pres('_a')=var_pres('_b')=var_pres('_c')=type_of(0))
         || .errmsg(0,'TZAKL')
         || exec('t_zakl','lista_plac',_a,_b,_c)
         ?}
      ?}
   "),

   obj_meth('TROWS',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      _rows:=LISTA.Wiersze(_a)-1;
      {? _rows>0
      || _rows
      || 0
      ?}
   ",type_of('')),

   obj_meth('TCOLUMNS',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      LISTA.Kolumny()
   ",-1),

   obj_meth('TFREE',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      LISTA.Update()
   ",-1),

   obj_meth('TBEGIN',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      P.cntx_psh();
      LS.cntx_psh();
      R.cntx_psh();
      R.index('RUBLP');
      R.prefix()
   ",-1),

   obj_meth('TEND',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      P.cntx_pop();
      R.cntx_pop();
      LS.cntx_pop()
   ",-1),

   obj_meth('errmsg',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
      RAPLS.msg('','','','Funkcja %1'@[_b],'Nieprawidłowe wywołanie%1.'@[
          {? _a=0 || ': błędny typ argumentu'@
          |? _a=1 || ': błędna wartość parametru'@
          |? _a=2 || ': brak kodu rubryki'@
          |? _a=3 || ': lista płac nie została wybrana'@
          |? _a=4 || ': wybrana lista płac jest zamknięta'@
          |? _a=5 || ': brak symbolu konta kosztów'@
          |? _a=6 || ': lista płac w międzyczasie została zamknięta przez innego użytkownika'@
          |? _a=7 || ': rachunek jest zablokowany do edycji'@
          |? _a=8 || ': brak wymaganych parametrów listy płac'@
          || ''
          ?}
      ]);
      0
   ",type_of(0),type_of(''))
)


\ustaw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [8.70]
:: OPIS: Ustawia metody wirtualne obiektu klasy FUNKCJE.
::   WE: _a - wskazanie na obiekt, którego metody mają być zmienione
::       _b - 'E' - etat, 'Z' - zlecenia
::  OLD: \ustaw/kaliobi.fml
::----------------------------------------------------------------------------------------------------------------------
{? _b='P' || exec('ustaw_p','lista_plac',_a)
|? _b='Z' || exec('ustaw_z','lista_plac',_a)
|| set_virt(_a,'IS_BUFF',"0",type_of(SYSLOG));
   set_virt(_a,'OBLICZ',"0",type_of(0),-1);
   set_virt(_a.buff,'DefAccnt',"null");
   set_virt(_a.buff,'Load',"",-1);
   set_virt(_a.buff,'Save',"",-1);
   set_virt(_a.buff,'Drop',"",type_of(0),type_of(null))
?};
~~


\ustaw_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Ustawia metody obiektu dla obsługi list płac.
::   WE: _a - wskazanie na obiekt, którego metody mają być zmienione
::  OLD: \io/skladnik.fml
::----------------------------------------------------------------------------------------------------------------------
set_virt(_a,'IS_BUFF',"
   .buff.Cntx()=LS &
   .buff.Context='E' &
   .buff.name=-VAR.NAZWALIS &
   .buff.calc
",type_of(SYSLOG));

: Naliczanie składników
set_virt(_a,'OBLICZ',"
:: tryb naliczania
   _mod:=0;
   {? var_pres('_a')=1
   || {? _a<0 || _mod:=-1
      |? _a>0 || _mod:=1
      ?}
   ?};
   {? ~exec('test_wym','lista_par',O.ref())
::    brak wymaganych parametrów
   || return(.errmsg(8,'OBLICZ'))
   ?};

   _zamk:=O.Z;
   O.get();
   {? O.Z='T' | ~.SPRLIST()
   || {? O.Z<>_zamk
      || .errmsg(6,'OBLICZ')
      ?};
      return(1)
   ?};

   {? _mod<0
   || LS.cntx_psh;
      LS.index('PRACLPRU');
      LS.prefix(P.ref);
      {? ~LS.first()
      || LS.cntx_pop();
         return(1)
      ?};
      LS.cntx_pop()
   ?};

   {? exec('czy_storno_o','lista_pow',O.ref()) |
      exec('jest_storno_p','lista_pow',O.ref(),P.ref())
   || return(1)
   ?};

   .LICZ_POD:=.PODATEK;
   O.cntx_psh();
   KK.index('KONTAKOD');
   KK.prefix(exec('ref_firma','ustawienia'));
   LS.cntx_psh();
   LS.index('PRACNRRU');
   LS.clear();
   R.cntx_psh();
   R.index('RUBKOD');
   R.clear();
   R.first();

:: oblicz/przelicz składniki listy płac bieżącego współpracownika
   echo('Lista płac dla: '+P.OSOBA().NAZWISKO+' '+OSOBA.PIERWSZE);
   _test:=.buff.Compute(_mod);

   LS.index('BLNRRU');
   LS.prefix(O.ref(),P.ref());
   _jest:=LS.first();

   O.cntx_pop();
   R.cntx_pop();
   LS.cntx_pop();
   .LICZ_POD:=0;
   echo();

   {? _jest=0
   || exec('del_P_STAT','pracownik',P.ref,'LIST_MOD',O.ref())

   |? _test=0
   || _nfo:=
         {? _mod=0
         || 'Uruchomiono procedurę naliczającą składniki listy płac.'
         || 'Uruchomiono procedurę przeliczającą wybrane składniki listy płac.'
         ?};
      exec('put_P_STAT','pracownik',P.ref,'LIST_MOD',,,O.ref(),_nfo)

   || _nfo:=
         {? _mod=0 || 'Naliczono składniki listy płac.'
         |? _mod<0 || 'Przeliczono składniki listy płac.'
         |? _mod>0 || 'Obliczono wybrane składniki listy płac.'
         ?};
      {? _mod<>-1
      || exec('put_stat','lista_plac',O.ref,'OBLICZ',1,_nfo)
      ?};
      exec('put_P_STAT','pracownik',P.ref,'LIST_MOD',,,O.ref(),_nfo)
   ?};
   ~_test
",type_of(0),-1);

: Domyślne konto kosztów dla składnika
set_virt(_a.buff,'DefAccnt',"exec('kk_hist','pracownik',P.ref(),date(O.R,O.M,0))");

: Aktualny kontekst pracy
set_virt(_a.buff,'Cntx',".Context:='E'; LS");

: Odczyt składników bieżącej listy płac do bufora.
: Pierwsza transakcja procesu naliczania składników.
set_virt(_a.buff,'Load',"
   _test:=0;

   LS.cntx_psh();
   LS.use(-VAR.NAZWALIS);
   LS.index('PRACLPRU');
   LS.prefix(P.ref());

   .Prepare(LS.name());

   _mydo:=(do_state()=0);
   {? _mydo
   || do()
   ?};
   _loop:=LS.first();
   {!
   |? _loop
   |! _test+=(LS.KW=0);
      .Add(LS.RB().LP,LS.KW,LS.KK,LS.BL,LS.PK);
      .lp_mod+=(LS.LP<>R.LP);
      _loop:=LS.next()
   !};
   {? _mydo
   || end()
   ?};

   LS.cntx_pop();
   _test
",-1);

: Zapis całej zawartości bufora danych do tabeli.
: Druga transakcja procesu naliczania składników.
set_virt(_a.buff,'Save',"
   LS.cntx_psh();
   LS.use(.name);
   LS.index('PRACLPRU');
   LS.prefix(P.ref());

   _drop:=0;
   _mydo:=(do_state()=0);
   {? _mydo
   || do()
   ?};
   {? LS.first()
   || LS.trig_off('del po','');
      {! |? LS.del() !};
      LS.trig_on('del po','')
   ?};
   {? .IsEmpty()=0
   || LS.trig_off('add po','');
      exec('konto','lista_plac',.,LSS);
      _list:=1-.list;
      {!
      |? _list<>''
      |! _pos:=_list*',';
         {? (_no:=#(_pos-1+_list))<>0
         || _drop+=.Drop(.sum.ndx[_no],__RUB.RLP[_no])
         ?};
         _list:=_pos-_list
      !};
      LS.trig_on('add po','')
   ?};
   {? _mydo
   || end()
   ?};

   _ls:={? _drop<>0 || 'T' || 'N' ?};
   {? exec('o_p_jest','ppl',O.ref(),P.ref())
   || {? O_P.LS<>_ls
      || O_P.LS:=_ls;
         O_P.put()
      ?}
   |? _ls='T'
   || exec('o_p_add','ppl',O.ref(),P.ref(),,_ls)
   ?};

   LS.cntx_pop();
   .error:=0;
   .calc:=0;
   echo()
",-1);

set_virt(_a.buff,'Drop',"
   {? _a=0 | _b=null
   || return(0)
   ?};
   _cnt:=0;
   {? .data.val[_a]<>0 | .data.mod[_a]<>0
::    utrwal składnik
   || LS.blank();
      LS.RB:=_b;
      LS.KW:=.data.val[_a];
      LS.KK:=.data.acc[_a];
      LS.BL:=.data.mod[_a];
      LS.PK:=.data.old[_a];
      _cnt+=LS.add()
   ?};
   {? .data.ndx[_a]<>0
::    oszczędne wywołania
   || _cnt+=.Drop(.data.ndx[_a],_b)
   ?};
   _cnt
",type_of(0),type_of(null));

~~


\ustaw_z
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Ustawia metody obiektu dla obsługi umów cywilno prawnych.
::   WE: _a - wskazanie na obiekt, którego metody mają być zmienione
::  OLD: \io/skladnik.fml
::----------------------------------------------------------------------------------------------------------------------
set_virt(_a,'IS_BUFF',"
   .buff.Cntx()=LS &
   .buff.Context='Z' &
   .buff.name=-VAR.NAZWALIS &
   .buff.calc
",type_of(SYSLOG));

: Naliczanie składników
set_virt(_a,'OBLICZ',"
:: tryb naliczania
   _mod:=0;
   {? var_pres('_a')=1
   || {? _a<0 || _mod:=-1
      |? _a>0 || _mod:=1
      ?}
   ?};
   _p258T:=PAR_SKID.get(258)='T';
   {? RH.BL='T' || return(.errmsg(7,'OBLICZ'))
   |? _p258T & O.Z='T' || return(.errmsg(4,'OBLICZ'))
   ?};
   {? ~exec('test_wym','lista_par',O.ref())
::    brak wymaganych parametrów
   || return(.errmsg(8,'OBLICZ'))
   ?};

   _zamk:=O.Z;
   O.get();
   {? _p258T & O.Z='T'
   || {? O.Z<>_zamk
      || .errmsg(6,'OBLICZ')
      ?};
      return(1)
   ?};
   ~.buff.Compute(_a)
",type_of(0),-1);

: Domyślne konto kosztów dla składnika
set_virt(_a.buff,'DefAccnt',"RH.KK");

: Aktualny kontekst pracy
set_virt(_a.buff,'Cntx',".Context:='Z'; LS");

: Odczyt składników bieżącego rachunku do bufora.
: Pierwsza transakcja procesu naliczania rachunku.
set_virt(_a.buff,'Load',"
   _test:=0;

   LS.cntx_psh();
   LS.use(-VAR.NAZWALIS);
   LS.index('ZLECLPRU');
   LS.prefix(RH.ref());

   .Prepare(LS.name());

   _mydo:=(do_state()=0);
   {? _mydo
   || do()
   ?};
   _loop:=LS.first();
   {!
   |? _loop
   |! _test+=(LS.KW=0);
      .Add(LS.RB().LP,LS.KW$2,LS.KK,LS.BL,LS.PK);
      .lp_mod+=(LS.LP<>R.LP);
      _loop:=LS.next()
   !};
   {? _mydo
   || end()
   ?};

   LS.cntx_pop();
   _test
",-1);

: Zapis całej zawartości bufora danych do tabeli.
: Druga transakcja procesu naliczania składników.
set_virt(_a.buff,'Save',"
   LS.cntx_psh();
   LS.use(.name);
   LS.index('ZLECLPRU');
   LS.prefix(RH.ref());

   _mydo:=(do_state()=0);
   {? _mydo
   || do()
   ?};
   {? LS.first()
   || LS.trig_off('del po','');
      {! |? LS.del() !};
      LS.trig_on('del po','')
   ?};
   {? .IsEmpty()=0
   || LS.trig_off('add po','');
      exec('konto','lista_plac',.,LSS);
      _list:=1-.list;
      {!
      |? _list<>''
      |! _pos:=_list*',';
         {? (_no:=#(_pos-1+_list))<>0
         || .Drop(.sum.ndx[_no],__RUB.RLP[_no])
         ?};
         _list:=_pos-_list
      !};
      LS.trig_on('add po','')
   ?};
   {? _mydo
   || end()
   ?};

   LS.cntx_pop();
   .error:=0;
   .calc:=0;
   echo()
",-1);

set_virt(_a.buff,'Drop',"
   {? _a=0 | _b=null
   || return(0)
   ?};
   _cnt:=0;
   {? .data.val[_a]<>0 | .data.mod[_a]<>0
::    utrwal składnik
   || LS.blank();
      LS.RB:=_b;
      LS.RH:=RH.ref();
      LS.KW:=.data.val[_a];
      LS.KK:=.data.acc[_a];
      LS.BL:=.data.mod[_a];
      LS.PK:=.data.old[_a];
      _cnt+=LS.add()
   ?};
   {? .data.ndx[_a]<>0
::    oszczędne wywołania
   || _cnt+=.Drop(.data.ndx[_a],_b)
   ?};
   _cnt
",type_of(0),type_of(null));

~~


\konto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: pobranie danych ze stalych skladnikow na liste plac (place oraz zlecenia)
::   WE: _a - alias obiektu CBUFF
::       _b - alias tabeli LSS lub STZC
::  OLD: \konto/skladnik.fml
::----------------------------------------------------------------------------------------------------------------------
_d1:=date(O.R,O.M,1);
_d2:=date(O.R,O.M,0);
_warunek:="
   _d1:=_c;
   _d2:=_d;
   _od:={? _a<_d1 || _d1 || _a ?};
   _do:={? _b=date(0,0,0) || _d2 || _b ?};
   _od<=_d2 & _d1<=_do
";
_nv:=',';
_mr:=',';
LSS.cntx_psh();
LSS.index('PROPOZYC');
LSS.prefix(P.ref());
{? LSS.first()
|| {!
   |? {? _i:=_a.sum.ndx[LSS.S().LP]
      || _stop:=0;
         {!
         |? _stop=0 & _i<>0 & _warunek(LSS.OD,LSS.DO,_d1,_d2)
         |! _mr+=$#LSS.ref()+',';
            _kk:=_a.data.acc[_i+1];
            {? type_of(_kk)<>type_of(null) | _kk=null |
               ((_kk=P.KK | _kk=exec('kk_hist','pracownik',P.ref(),_d2)) & _kk<>LSS.KK)
            || {? _a.data.val[_i]=LSS.KW | _a.data.val[_i]=FUNKCJE.S(LSS.S().RN,,1)
               || _a.data.acc[_i]:=LSS.KK;
                  _stop:=1
               || {? _nv*(','+$_i+',')=0
                  || _nv+=$_i+','
                  ?}
               ?}
            ?};
            _i:=_a.data.ndx[_i]
         !}
      ?};
      LSS.next()
   !}
?};
_nv:=1-_nv-1;
_mr:=1-_mr-1;
{? _nv<>'' & _mr<>''
|| _nv:=spli_str(_nv,',');
   _mr:=spli_str(_mr,',');
:: oryginalne działanie, ale tylko dla składników,
:: którym dotychczas nie przypisano konta księgowego
   {! _ni:=1..obj_len(_mr)
   |! {? LSS.seek(#_mr[_ni],)
      || {! _mi:=1..obj_len(_nv)
         |! _a.data.acc[#_nv[_mi]]:=LSS.KK
         !}
      ?}
   !}
?};
LSS.cntx_pop()


\lu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
::       RWR [12.30]
:: OPIS: Formuła zwraca sumę składnika (skladników) z list płac o miesiącach ubezpieczeniowych zgodnych z miesiącem
::       ubezpieczeniowym bieżącej listy płac. Dodatkowo funkcja może przy agregowaniu uwzględniać również poprzednie
::       miesiące. Sumowanie odbywa się dla OSOBY, więc uwzględnione zostaną wszystkie etaty.
::   WE: _a - kod rubryki (obowiązkowy)
::       _b - kod rubryki (dodatkowy)
::       _c - lista dla _c miesiąca wstecz, względem aktualnie wybranej listy płac (dodatkowy)
::       _d - lista dla _d miesiąca wstecz, względem aktualnie wybranej listy płac (dodatkowy)
::       _e - uchwyt do obiektu FUNKCJE
::       _f - obiekt klasy Trace
::       [_g] [integer] - 1 - analizuje wszystkie listy bez względu na kolejność naliczania
::   WY: suma skladnikow
::  OLD: \lu/funkcje.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_f')<>_e.TraceType
|| _f:=~~
?};
_all:={? var_pres('_g')=type_of(0) || _g ?};
_ret_val:=0;
O.cntx_psh();
O.index('LISTYPLU');
LS.cntx_psh();
_akt_lista:=O.ref();
{? (_c=~~ | _c=0) & _d=~~
|| O.prefix(exec('ref_firma','ustawienia'),__F_ZATR.O,O.RU,O.MU);
   _loop:=O.first();
   {!
   |? _loop
   |! {? FUNKCJE.CZY_POD() | _all
      || _e.OTWOLIST();
         _ret_val+=_e.LUK(_a,_b,_akt_lista<>O.ref(),,_f)
      ?};
      _loop:=O.next()
   !}
|| {? _c=~~ | _c=0
   || _ret_val+=exec('lu','lista_plac',_a,_b,,,_e,_f);
      _c:=1
   || _d:={? _d=~~ || _c || {? _c>_d || _c || _d ?} ?}
   ?};
   _rok:=O.RU;
   _msc:=O.MU;
   {! _n:=_c.._d
   |! _dlisty:=date(_rok,_msc-_n,0);
      O.prefix(exec('ref_firma','ustawienia'),__F_ZATR.O,_dlisty~1,_dlisty~2);
      _loop:=O.first();
      {!
      |? _loop
      |! {? FUNKCJE.CZY_POD() | _all
         || _e.OTWOLIST();
            _ret_val+=_e.LUK(_a,_b,_akt_lista<>O.ref(),,_f)
         ?};
         _loop:=O.next()
      !}
   !}
?};
O.cntx_pop();
LS.cntx_pop();
_e.OTWOLIST();
_ret_val


\lp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
::       RWR [12.30]
:: OPIS: Funkcja zwraca sumę składnika (składników) z list płac o miesiącach podatkowych zgodnych z miesiącem
::       podatkowym bieżącej listy płac. Dodatkowo funkcja może przy agregowaniu uwzględniać również poprzednie
:        miesiące. Sumowanie odbywa sie dla OSOBY lub PRACOWNIKA (patrz parametr _e).
::   WE: _a - kod rubryki (obowiązkowy)
::       _b - kod rubryki (dodatkowy)
::       _c - lista dla _c miesiąca wstecz, względem aktualnie wybranej listy płac (dodatkowy)
::       _d - lista dla _d miesiąca wstecz, względem aktualnie wybranej listy płac (dodatkowy)
::       _e - sumowanie wg pracownika [0-nie, 1-tak]
::       _f - wskazanie obiektu FUNKCJE
::       _g - obiekt klasy Trace
::       _h - miesiące wstecz liczone względem miesiąca kosztowego listy
::       [_i] [integer] - 1 - analizuje wszystkie listy bez względu na kolejność naliczania
::   WY: suma składnikow
::  OLD: \lp/funkcje.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_g')<>_f.TraceType
|| _g:=~~
?};
{? var_pres('_h')<>type_of(0)
|| _h:=0
?};
_all:={? var_pres('_i')=type_of(0) || _i ?};
:: Zmiana związana z funkcjonalnością ZP korekta
{? var_pres('__LP_kor')>0 & __LP_kor
|| _lp_kor:="exec('czy_ulga_U26','lista_licz',O.D)"
|| _lp_kor:="1"
?};

_ret_val:=0;
O.cntx_psh();
O.index('LISTYPLP');
LS.cntx_psh();
_akt_lista:=O.ref();
{? (_c=~~ | _c=0) & _d=~~
|| O.prefix(exec('ref_firma','ustawienia'),__F_ZATR.O,O.RP,O.MP);
   _loop:=O.first();
   {!
   |? _loop
   |! {? (FUNKCJE.CZY_POD() | _all) & _lp_kor()
      || _f.OTWOLIST();
         _ret_val+=_f.LUK(_a,_b,_akt_lista<>O.ref(),_e,_g)
      ?};
      _loop:=O.next()
   !}
|| {? _c=~~ | _c=0
   || _ret_val+=exec('lp','lista_plac',_a,_b,,,_e,_f,_g);
      _c:=1
   || _d:={? _d=~~ || _c || {? _c>_d || _c || _d ?} ?}
   ?};
   {? _h
   || _rok:=O.R;
      _msc:=O.M
   || _msc:=O.MP;
      _rok:=O.RP
   ?};
   {! _n:=_c.._d
   |! _dlisty:=date(_rok,_msc-_n,0);
      O.prefix(exec('ref_firma','ustawienia'),__F_ZATR.O,_dlisty~1,_dlisty~2);
      _loop:=O.first();
      {!
      |? _loop
      |! {? (FUNKCJE.CZY_POD() | _all) & _lp_kor()
         || _f.OTWOLIST();
            _ret_val+=_f.LUK(_a,_b,_akt_lista<>O.ref(),_e,_g)
         ?};
         _loop:=O.next()
      !}
   !}
?};
O.cntx_pop();
LS.cntx_pop();
_f.OTWOLIST();
_ret_val


\lz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [8.70]
::       RWR [12.30]
:: OPIS: Funkcja pozwala na pobranie sumy wskazanych składników, przy czym dla wywołania z list płac sumowane są
::       rachunki wystawione do umów cywilnoprawnych, a dla wywołania z rachunku - sumowane są listy płac.
::       Sumowanie uwzględnia tytuł ubezpieczenia.
::       Przy wywołaniu z list płac 'bieżącym miesiącem' jest odpowiedni miesiąc bieżącej listy, zgodnie z parametrem _e
::       (kosztowy, ubezpieczeniowy lub podatkowy).
::       Przy wywołaniu rachunku 'bieżącym miesiacem' jest miesiąc rachunku (RH.R,RH.M).
::   WE: _a - początkowy kod składnika (obowiązkowy)
::       _b - końcowy kod składnika (opcjonalny)
::       _c - okres od wstecz, względem bieżącego miesiąca (dodatkowy)
::       _d - okres do wstecz, względem bieżącego miesiąca (dodatkowy)
::       _e - sposób ustalenia miesiąca przy pobieraniu kwot składników, dozwolone wartości:
::          'k' - kosztowo,
::          'u' - ubezpieczeniowo,
::          'p' - podatkowo
::       _f - jeśli równe zero, to kontrolowana jest zgodność podstaw tytułów ubezpieczenia
::       _g - alias do obiektu klasy FUNKCJE
::       _h - obiekt klasy Trace (dodatkowy)
::   WY: kwota skladnikow spelniajacych kryteria
::  OLD: \lz/funkcje.fml
::----------------------------------------------------------------------------------------------------------------------
_ret_val:=0;
{? var_pres('_h')<>_g.TraceType
|| _h:=~~
?};

_g.buff.Cntx();
{? _g.buff.Context='E'
|| {? _e='k' || _r:=O.R;  _m:=O.M
   |? _e='u' || _r:=O.RU; _m:=O.MU
   |? _e='p' || _r:=O.RP; _m:=O.MP
   || return(0)
   ?};
   RH.cntx_psh();
   RH.index('RACHDATA');
   {! _n:=_c.._d
   |! _o:=date(_r,_m-_n,0);
      RH.prefix(exec('ref_firma','ustawienia'),P.OSOBA,_o~1,_o~2);
      {? RH.first()
      || {!
         |? {? {? ~_f || (2+RH.ZC_INFO().TTUB().KOD)='01' || 1 ?}
            || _ret_val+=_g.SUM_RH(RH.ref(),_a,_b,_h)
            ?};
            RH.next()
         !}
      ?}
   !};
   RH.cntx_pop()

|? _g.buff.Context='Z'
|| {? ~_f || {? 2+RH.ZC_INFO().TTUB().KOD<>'01' || return(0) ?} ?};
   _firma:=exec('ref_firma','ustawienia');
   RH.ZLE();
   LS.cntx_psh;
   O.cntx_psh;
   {? _e='u' || O.index('LISTYUBZ')
   |? _e='p' || O.index('LISTYPOD')
   || O.index('LISTYMIE')
   ?};
   _r:=RH.R;
   _m:=RH.M;
   {! _n:=_c.._d
   |! _o:=date(_r,_m-_n,0);
      O.prefix(_firma,_o~1,_o~2);
      {? O.first()
      || {!
         |? {? O.F_ZATR().KOD<>'Z'
            || LS.use(O.LT);
               LS.index('OSOBAKOD');
               {! _rub:=_a.._b
               |! LS.prefix(exec('ref_firma','ustawienia'),ZC.OSOBA,_rub);
                  {? LS.first()
                  || {!
                     |? _ret_val+={? var_pres('_h')=_g.TraceType || _h.add(_rub,,LS.KW,-O.LT) || LS.KW ?};
                        LS.next()
                     !}
                  ?}
               !}
            ?};
            O.next()
         !}
      ?}
   !};
   LS.cntx_pop();
   O.cntx_pop()
?};
_ret_val


\lk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
::       RWR [12.30]
:: OPIS: Funkcja wykorzystywana do pobierania kwoty składnika listy z uwzględnieniem konta kosztów, do którego został on
::       przypisany. Dla wywołania z trzecim parametrem typu liczbowego funkcja dopisze do listy płac nową pozycję o
::       kodzie przekazanym pierwszym argumentem i koncie kosztów określonym w drugim. Jeśli taki składnik już istnieje,
::       to zmieniona zostanie jedynie jego kwota. Gdy pominięty zostanie drugi argument (konto kosztów), przyjmowane
::       jest konto okreslone w kartotece osobowej.
::   WE: _a - numer rubryki
::       _b - konto kosztów
::       _c - kwota
::       _d - parametr przekazywany dla zgodności z metodą wywolująca, gdzie powoduje usunięcie składnika z bufora
::            listy, w procedurze niewykorzystywany.
::       _e - uchwyt do obiektu FUNKCJE
::       _f - wskazanie obiektu Trace
::   WY: suma skladników o podanym kodzie i koncie kosztow wystepujących na danej liście płac.
::  OLD: \lk/funkcje.fml
::----------------------------------------------------------------------------------------------------------------------
_val:=0;
_tab:=_e.buff.Cntx();
_tab.cntx_psh();
{? _e.buff.Context='E'
|| LS.use(-VAR.NAZWALIS);
   LS.index('PRACNRRU');
   LS.prefix(P.ref(),_a);
   _rodz:='E'
|| LS.use(-VAR.NAZWALIS);
   LS.index('ZLEC');
   LS.prefix(RH.ref(),_a);
   _rodz:='Z'
?};
{? var_pres('_f')= _e.TraceType
|| _f.add(_a,,_c,-_tab.name(),_rodz)
?};

{? _tab.first()
|| {!
   |? {? _b=~~ & _c<>~~
      || _tab.KW:=_c;
         _tab.put();
         _val+=_tab.KW
      |? _b<>~~ & _c=~~
      || {? _tab.KK=_b
         || _val+=_tab.KW
         ?}
      || {!
         |? {? _tab.KK=_b
            || _val+=(_tab.KW:=_c);
               _tab.put();
               _tab.cntx_pop();
               return(_val)
            ?};
            _tab.next()
         !};
         _val+=(_tab.KW:=_c);
         _tab.KK:=_b;
         _tab.add();
         _tab.cntx_pop();
         return(_val)
      ?};
      _tab.next()
   !}
|| {? _c<>~~ & __RUB.REF[_a]
   || _tab.blank();
      _tab.RB:=__RUB.REF[_a];
      _tab.KK:={? _b=~~ || _e.buff.DefAccnt() || _b ?};
      {? _rodz='Z'
      || _tab.RH:=RH.ref()
      ?};
      _tab.KW:=_val:=_c;
      _tab.add()
   ?}
?};
_tab.cntx_pop();
_val


\s
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws
::       RWR [12.30]
:: OPIS: Funkcja realizuje dostęp do stałych składnikow list płac.
::   WE: _a - numer rubryki
::       _b - symbol konta kosztow (opcjonalnie)
::       _c - tryb pracy, w przypadku zmiany wartości w trakcie miesiąca:
::          0 - suma wszystkich wartości [domyślnie]
::          1 - średna kalendarzowa (miesiąc ma 30 dni)
::       _d - precyzja wyniku [domyślnie 2]
::       _e - okres wstecz, względem bieżącego miesiąca [domyślnie 0]
::       _f - względem miesiąca podatkowego listy płac
::   WY: wartość stałego składnika
::  OLD: \s/funkcje.fml
::----------------------------------------------------------------------------------------------------------------------
_ret:=0;
_ok:=0;
KK.cntx_psh();
LSS.cntx_psh();
{? type_of(_b)
|| KK.index('KONTAKOD');
   KK.prefix(exec('ref_firma','ustawienia'));
   {? KK.find_key(_b)
   || LSS.index('PROPOZYC');
      LSS.prefix(P.ref(),_a,KK.ref());
      _ok:=LSS.first()
   ?}
|| LSS.index('PROPOZYC');
   LSS.prefix(P.ref(),_a);
   _ok:=LSS.first()
?};
{? _ok
|| {? _f
   || _d1:=date(O.RP,O.MP-_e,1);
      _d2:=date(O.RP,O.MP-_e,0)
   || _d1:=date(O.R,O.M-_e,1);
      _d2:=date(O.R,O.M-_e,0)
   ?};
   _zdate:=date(0,0,0);
   {!
   |? _od:={? LSS.OD<_d1 || _d1 || LSS.OD ?};
      _do:={? LSS.DO=_zdate || _d2 || LSS.DO ?};
      {? _od<=_d2 & _d1<=_do
      || _val:=
            {? ~_c
            || 1
            || _nom:=_d2-_d1+1;
               _kal:={? _d2<_do || _d2 || _do ?}-
                     {? _od<_d1 || _d1 || _od ?}+
                     1;
               {? _kal=_nom || 30 || _kal ?}/30
            ?}*LSS.KW;
         _ret+={? _d || _val$_d || _val ?}
      ?};
      LSS.next()
   !}
?};
LSS.cntx_pop();
KK.cntx_pop();
_ret


\fn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Funkcja zwraca sumę dni kalendarzowych, roboczych lub godzin roboczych nieobecności. Suma jest liczona dla
::       wszystkich typów nieobecności, o kodach podanych argumentami pierwszym i drugim.
::       Trzeci i czwarty parametr określają zakres sumowania, dla typów liczbowych sumowanie odbywa się od miesiąca do
::       miesiąca wstecz względem miesiąca aktualnie wybranej listy płac, dla typu data sumowanie odbywa się w podanym
::       zakresie dat.
::   WE: _a - kod rubryki, od której rozpoczyna się sumowanie
::       _b - kod rubryki, do której będą sumoane nieobecności
::       _d - miesiąc wstecz (LICZBA), od którego rozpoczyna się sumowanie (względem aktualnej listy płac lub dzień, od
::            którego rozpocznie się sumowanie dla typu DATA
::       _d - miesiąc wstecz względem miesiąca listy płac, do którego przeprowadzone będzie sumowanie (typ LICZBA), dla
::            typu DATA określa datę końcową przedziału sumowania
::       _e - określenie rodzaju wartości zwracanej
::          K - dni kalendarzowe
::          R - dni robocze
::          G - godziny robocze
::       _f - 1 - nie jest wstawiany znak listy do nieobecności
::   WY: Liczba dni kalendarzowych, roboczych lub godzin nieobecności o kodach z zakresu od _a do _b i mieszczących się
::       w przedziale czasu od _c do _d. (Nierozliczone na żadnej liście płac lub rozliczane na bieżącej liście płac).
::  OLD: \fn/funkcje.fml
::  OLD: \fn_chk/funkcje.fml
::----------------------------------------------------------------------------------------------------------------------
_i:=1;
_r:=O.R;
_m:=O.M;
_p:=_s:=_v:=0;
{? type_of(_c)=0 & type_of(_d)=0 || _c:=_d:=0
|? type_of(_c)=0 & type_of(_d)=1 || _c:=0
|? type_of(_c)=0 & type_of(_d)=4 || _c:=date(0,0,0)
|? type_of(_c)=1 & type_of(_d)=0 || _d:=0
|? type_of(_c)=4 & type_of(_d)=0 || _d:=date(0,0,0)
?};
{? var_pres('_f')<>type_of(0)
|| _f:=0
?};
{? VAR.JESTLIST=0
|| return(_e.errmsg(3,'N'+_e))
|? type_of(_c)<>type_of(_d)
|| return(_e.errmsg(1,'N'+_e))
?};

N.cntx_psh();
N.index('NIEOBECL');
{? ~_f
|| N.prefix('N',P.ref());
   {? N.first()
   || {!
      |? {? N.LT=''
         || {? N.OD<=date(_r,_m,0)
            || N.LT:=VAR.NAZWALIS;
               {? N.put()
               || N.first()
               ?}
            || N.next()
            ?}
         ?}
      !}
   ?}
?};
N.prefix('N',P.ref(),VAR.NAZWALIS);
{? N.first()
|| _zdate:=date(0,0,0);
   {? type_of(_c)=1
   || {? ~_c & ~_d
      || _i:=1
      |? _c & ~_d
      || _x:=date(_r,_m-_c,1);
         _y:=date(_r,_m-_c,0);
         _i:=2
      |? _c & _d
      || {? _c>_d || _c==_d ?};
          _x:=date(_r,_m-_d,1);
          _y:=date(_r,_m-_c,0);
          _i:=2
      || _v:=_i:=0
      ?}
   |? type_of(_c)=4
   || {? _c<>_zdate & _d<>_zdate
      || {? _c<_d || _c==_d ?};
         _x:=_d;
         _y:=_c;
         _i:=2
      |? _c<>_zdate & _d=_zdate
      || _x:=_c;
         _y:=_zdate;
         _i:=2
      |? _c=_zdate & _d<>_zdate
      || _x:=_zdate;
         _y:=_d;
         _i:=2
      || _v:=0;
         _i:=0
      ?}
   ?};
   {!
   |? _s:=N.NB().RN;
      {? _s>=_a & _s<=_b
      || _t:=N.OD;
         _u:=N.DO;
         _v+={? _i=1
             || {? _e='K' || N.NK
                |? _e='R' || N.NR
                |? _e='G' || N.NG
                ?}
             |? _i=2
             || {? _x<=_t & (_u<=_y | _y=_zdate)
                || {? _e='K' || N.NK
                   |? _e='R' || N.NR
                   |? _e='G' || N.NG
                   ?}
                |? _t<=_x & _x<=_u
                || {? _e='K' || _u-_x+1
                   |? _e='R' || __KAL.w_days(_x,_u)
                   |? _e='G' || __KAL.w_hours(_x,_u)
                   ?}
                |? _t<=_y & _y<=_u
                || {? _e='K' || _y-_t+1
                   |? _e='R' || __KAL.w_days(_t,_y)
                   |? _e='G' || __KAL.w_hours(_t,_y)
                   ?}
                |? _t<=_x & _y<=_u & _y<>_zdate
                || {? _e='K' || _y-_x+1
                   |? _e='R' || __KAL.w_days(_x,_y)
                   |? _e='G' || __KAL.w_hours(_x,_y)
                   ?}
                ?}
             ?}
      ?};
      N.next()
   !}
?};
N.cntx_pop();
_v


\usun_dane
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Funkcja usuwa składniki aktualnej listy płac pracownika i informacje o rozliczeniu w kartotekach powiązanych.
::   WE: _a [INTEGER] - jeśli różny od 0, to na liście pozostaną składniki
::   WY:
::  OLD: \usunzlis/funkcje.fml
::  OLD: \usu_lsg/roz_godz.fml
::  OLD: \usu_prok/skl_okr.fml
::  OLD: \usun/licz_del.fml
::----------------------------------------------------------------------------------------------------------------------
_mod:=(var_pres('_a')=type_of(0) & _a<>0);

H_UM.cntx_psh();
exec('otworz_h_um','pracownik','h_um');
H_UM.index('LISTA');
H_UM.prefix(P.ref(),VAR.NAZWALIS,);
{!
|? H_UM.first()
|! H_UM.cntx_psh();
   H_UM.prefix(P.ref());
   H_UM.LT:='';
   {? H_UM.EKW_LICZ='T'
   || H_UM.EKW:=0;
      H_UM.EKW_NSP:=0
   ?};
   {? H_UM.put()
   || exec('del_ndx','#table',H_UM_EKW,'UNIQUE',H_UM.ref());
      exec('del_ndx','#table',H_UM_ESK,'UNIQUE',H_UM.ref())
   ?};
   H_UM.cntx_pop()
!};
H_UM.cntx_pop();
exec('otworz_h_um','pracownik');

NW.cntx_psh();
NW.index('CHW');
N.cntx_psh();
N.index('NIEOBECL');
N.prefix('N',P.ref(),VAR.NAZWALIS,);
{!
|? N.first()
|! NW.prefix(N.ref());
   {? NW.first & NW.KWMIN
   || NW.KWMIN:=0;
      NW.put()
   ?};
   N.cntx_psh();
   N.prefix('N',P.ref());
   N.POD:=N.POZ:=N.STD:=N.WART:=N.POTR1:=N.POTR2:=N.POTR3:=N.POTR4:=0;
   N.LT:='';
   N.put();
   exec('tz_usun','nieobecnosc',1);
   _nsk:='s_ch'+$(N.OD~1);
   {? SK_CHO.name<>_nsk
   || SK_CHO.use(_nsk)
   ?};
   SK_CHO.index('SK_CHO');
   SK_CHO.prefix(N.ref());
   {? SK_CHO.first()
   || {!
      |? SK_CHO.del()
      !}
   ?};
   N.cntx_pop()
!};
N.cntx_pop;
NW.cntx_pop;

: usuń informację o rozliczeniu wyrównań na liście płac
{? O.T().T='OTK'
|| LSW.cntx_psh();
   LSW.index('LT');
   LSW.prefix(P.ref,VAR.NAZWALIS,);
   {? LSW.first()
   || {!
      |? LSW.del()
      !}
   ?};
   LSW.cntx_pop()
|| LSW.cntx_psh();
   LSW.index('LT');
   LSW.prefix(P.ref(),VAR.NAZWALIS,);
   {!
   |? LSW.first()
   |! LSW.cntx_psh();
      LSW.prefix(P.ref());
      {? LSW.N | LSW.Z='R'
      || LSW.del()
      || LSW.LT:='';
         LSW.put()
      ?};
      LSW.cntx_pop()
   !};
   LSW.cntx_pop()
?};

: usuń informację o ratach/składkach w rozliczeniu
K.cntx_psh();
K.index('PRACPOZ');
K.prefix(P.ref());
{? K.first()
|| KRE_HIS.index('KRE_HIS');
   {!
   |? KRE_HIS.prefix(K.ref(),date(O.R,O.M,0),VAR.NAZWALIS,);
      {? KRE_HIS.first()
      || K.KS-=KRE_HIS.KWOTA;
         KRE_HIS.del();
         K.put()
      ?};
      K.next()
   !}
?};
K.cntx_pop();

: usuń informacje dotyczące podziału kosztów
ATRUSE_L.use('kak'+'l'+($O.R+2)+form(O.M,-2));
ATRUSE_L.index('PRRBLS');
ATR_WYRL.use('kwk'+'l'+($O.R+2)+form(O.M,-2));
ATR_WYRL.index('LP');
LS.cntx_psh();
LS.index('PRACORUB');
LS.prefix(P.ref());
{? LS.first()
|| _act:={? _mod<>0 || "LS.next()" || "LS.del()" ?};
   {!
   |? ATRUSE_L.prefix(P.ref(),LS.RB().RN,'L'+FUNKCJE.ZNLISTY(),);
      {? ATRUSE_L.first
      || {!
         |? ATR_WYRL.prefix(ATRUSE_L.ref());
            {? ATR_WYRL.first()
            || {!
               |? ATR_WYRL.del
               !}
            ?};
            ATRUSE_L.del()
         !}
      ?};
      _act()
   !}
?};
LS.cntx_pop();

: usuń informacje o wypłaconych świadczeniach
IS_WYPL.cntx_psh();
IS_WYPL.index('LISTA');
{!
|? IS_WYPL.prefix(P.OSOBA,VAR.NAZWALIS,);
   IS_WYPL.first()
|! IS_WYPL.prefix();
   IS_WYPL.LT:='';
   IS_WYPL.POD_U:=0;
   IS_WYPL.POD_P:=0;
   IS_WYPL.put()
!};
: usuń informacje o rozliczonych świadczeniach
IS_ROZL.cntx_psh();
IS_ROZL.index('LISTA');
IS_WYPL.prefix(P.OSOBA);
_loop:=IS_WYPL.first();
{!
|? _loop
|! IS_ROZL.prefix(IS_WYPL.ref(),P.ref(),VAR.NAZWALIS,);
   {? IS_ROZL.first()
   || {!
      |? IS_ROZL.del()
      !}
   ?};
   IS_ROZL.prefix(IS_WYPL.ref(),null,VAR.NAZWALIS,);
   {? IS_ROZL.first()
   || {!
      |? IS_ROZL.del()
      !}
   ?};
   _loop:=IS_WYPL.next()
!};
IS_ROZL.cntx_pop();
IS_WYPL.cntx_pop();

: usunięcie zapisów z tabeli korekt
exec('usun_kor','korekty_zus',1);

: usunięcie zapisów z tabeli potrąceń
exec('usun_rozl','komornik',1,1);

: usuniecie znacznika listy w godzinach
_gdn:=sql(
   'select G.REFERENCE as REF from G where G.P=:_a and G.R=\'G\' and G.LT = \':_b\'',
   P.ref(),VAR.NAZWALIS
);
{? _gdn.first()
|| G.cntx_psh();
   G.prefix();
   {!
   |? {? G.seek(BIT.sqlint(_gdn.REF),) & G.LT=VAR.NAZWALIS
      || G.LT:='';
         G.put()
      ?};
      _gdn.next()
   !};
   G.cntx_pop()
?};

: usunięcie rozliczenia godzin w tabeli R_GODZ
R_GODZ.cntx_psh();
R_GODZ.use('rzg_'+$O.R);
R_GODZ.index('RZL_GODZ');
R_GODZ.prefix(P.ref(),VAR.NAZWALIS,);
{? R_GODZ.first()
|| {!
   |? {? R_GODZ.R<>'R'
      || R_GODZ.del()
      || R_GODZ.next()
      ?}
   !}
?};
R_GODZ.cntx_pop();

: usunięcie znacznika listy w tabeli premii okresowych
PREM_OKR.cntx_psh();
PREM_OKR.index('PREM_LST');
{!
|? PREM_OKR.prefix(P.ref(),VAR.NAZWALIS,);
   PREM_OKR.first()
|! {? PREM_OKR.RP='S'
   || PREM_OKR.del()
   || PREM_OKR.prefix();
      PREM_OKR.LT:='';
      PREM_OKR.TT:='Z';
      PREM_OKR.KW_W:=0;
      PREM_OKR.put()
   ?}
!};
PREM_OKR.cntx_pop();

: usunięcie znacznika listy w tabeli delegacji
EDOKUM.cntx_psh();
TYPOBIEG.cntx_psh();
TYPOBIEG.index('UNIK');
TYPOBIEG.prefix('Obieg delegacji',);
{? TYPOBIEG.first()
|| _refsql:=$P.ref();
   {! _i:=0..1
   |! {? exec('szuk_okr','okresy',date(O.R-_i,O.M,1))
      || _r:=($(ROZNE.UT_OKROD().ROK().POCZ_ROK~1))+2;
         EDOKUM.use('skid_v'+_r);
         EDOKUM.index('PRAC');
         EDOKUM.prefix(_refsql,TYPOBIEG.ref(),'T',);
         {? EDOKUM.first()
         || {!
            |? {? EDOKUM.REFLISTA=$O.ref()
               || EDOKUM.REFLISTA:='';
                  EDOKUM.put()
               ?};
               EDOKUM.next()
            !}
         ?}
      ?}
   !}
?};
TYPOBIEG.cntx_pop();
EDOKUM.cntx_pop();

: usunięcie rocznego rozliczenia podatku
exec('pit12_set','osoba',P.OSOBA,O.RP-1,'UR',P.ref(),VAR.NAZWALIS);

: usunięcie premii miesięcznych (uznaniowych)
exec('pm_usun','pm_wspolne');

:: Usunięcie rozliczenia oddelegowania do pracy za granicą.
{? PAR_SKID.get(261)='T'
|| exec('usun_LT','oddelegowanie')
?};

:: Usunięcie złączenia listy z korektami PPK
exec('del_O_RH','ppk_kwn',P.ref,O.ref);
:: Usunięcie zmodyfikowanych zapisów procentu wpłat jeżeli uczestnik złożył wniosek o obniżenie wpłaty podstawowej
:: a wysokość wpłaty została skorygowana do maksymalnej ze względu na osiągnięty dochód.
exec('gdel_ls','ppk_pwp',P.OSOBA,date(O.RU,O.MU,0),null(),O.ref());
:: Aktualizacja informacji o zwiększeniu przychodu
exec('usunzlis','ppk_pod',P.ref(),O.ref());

:: Usuniecie statusu pracownika
exec('del_P_STAT','pracownik',P.ref,'LIST_MOD',O.ref);

:: Usunięcie rozliczenia zwolnienia przychodu
{? var_pres('__ZW_PRZ')>0
|| exec('rozlicz_del_pozycja','lista_licz',O.RP,O.MP,O.ref(),null())
?};

:: Usunięcie nadwyżki zaliczki na podatek
{? var_pres('P_NPOD')=type_of(SYSLOG)
|| exec('p_npod_del','lista_licz','P',P.ref,O.ref)
?};

: usunięcie znacznika listy w tabeli potrąceń z premii
POTRPREM.cntx_psh();
POTRPREM.index('PRACLT');
POTRPREM.prefix(P.ref(),VAR.NAZWALIS,);
{!
|? POTRPREM.first()
|! POTRPREM.cntx_psh();
   POTRPREM.prefix(P.ref());
   POTRPREM.LT:='';
   POTRPREM.put();
   POTRPREM.cntx_pop()
!};
POTRPREM.cntx_pop();

1


\oblicz_ds
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Funkcja oblicza liczbę dni nieobecnosci w roku podanym argumentem. Jeśli argument został pominięty to w roku
::       aktualnie wybranej listy płac (jeżeli lista płac jest wybrana) lub w roku bieżącym (z daty systemowej).
::       Przeglądana jest tabela dyscyplin (DS). Dla każdej wartości pola DS.NR przegląda tabelę nieobecności (NB)
::       i sumuje wszytskie nieobecności o kodzie jak wartości pola DS.NR i tak obliczona sumę wpisuje w pole DS.NW.
::       UWAGA! nie dodaje nowych rekordów w tabeli dyscyplin tylko uzupełnia rekordy już istniejące.
::   WE:
::   WY:
::  OLD: \obliczds/funkcje.fml
::----------------------------------------------------------------------------------------------------------------------
_a:=
{? var_pres('_a')<>type_of(0)
|| {? VAR.JESTLIST || O.R || date~1 ?}
|| {? _a>0 || _a || date~1 ?}
?};

N.cntx_psh();
DS.cntx_psh();
DS.index('DYSCYPLI');
DS.prefix(P.ref(),_a);
{? DS.first()
|| {!
   |? {? DS.r_lock(1,1,1)
      || DS.NW:=0;
         _kod:=DS.NB().RN;
         N.index('NIPRACNB');
         N.prefix('N',P.ref,_kod);
         {? N.find_ge(date(_a,1,1)) & N.OD~1=_a
         || {!
            |? _b:=$('N.N'+DS.NR);
::             Zaokrąglenie dla opieki Art 188 oraz dla nieobecności "siła wyższa"
               _ceil:=(__RUB.sys_attr(_kod,1162,N.OD) | __RUB.sys_attr(_kod,1181,N.OD));
               _val:=_b();
               _val:={? _ceil || ceil(_val) || _val ?};
               DS.NW+=_val;
               N.next() & N.OD<=date(_a,12,0)
            !}
         ?};
:: dla dyscypliny urlopu rehabilitacyjnego uwzględniamy nieobecności z urlopu dodatkowego
         _rehabil:=__RUB.sys_attr(DS.NB,1171);
         {? _rehabil
         || _rn:=__RUB.sys_kod(1113,,1);
            {? _rn<>0
            || N.prefix('N',P.ref,_rn);
               {? N.find_ge(date(_a,1,1)) & N.OD~1=_a
               || {!
                  |? _b:=$('N.N'+DS.NR);
                     _val:=_b();
                     DS.NW+=_val;
                     N.next() & N.OD<=date(_a,12,0)
                  !}
               ?}
            ?}
         ?};
         DS.NP:=DS.NN+DS.NZ;
         DS.NP-=DS.NW;
         DS.put();
         DS.r_unlock()
      ?};
      DS.next()
   !}
?};
N.cntx_pop();
DS.cntx_pop()


\t_nominals
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Procedura rozdziela podaną jako parametr kwotę na poszczególne nominały. Dodaje ilość nominałów do już
::       istniejących. Ilość nominałów w tablicy Tbank. Parametr wejściowy określa kwotę do rozłożenia na nominały.
::       Wywołanie bez parametrów zeruje istniejącą kwotę.
::   WE:
::   WY:
::  OLD: \Nominals/funkcje.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0 | _a=0
|| {? VAR.NOMINAŁY<>0
   || obj_del(Nominal);
      obj_del(Tbank);
      VAR.NOMINAŁY:=0
   ?}
|| _b:=0.01;
   _i:=0;
   {!
   |? {? _a>=_b   || _i+=1 || 0 ?} &
      {? _a>=2*_b || _i+=1 || 0 ?} &
      {? _a>=5*_b || _i+=1 || 0 ?}
   |! _b*=10
   !};
   {? VAR.NOMINAŁY<>0
   || obj_del(Nominal);
      obj_del(Tbank)
   ?};
   Nominal:=obj_new(_i);
   Tbank:=obj_new(_i);
   _b:=0.01;
   {! _c:=1.._i
   |! {? _c%*3=1
      || Nominal[_c]:=_b
      |? _c%*3=2
      || Nominal[_c]:=2*_b
      || Nominal[_c]:=5*_b;
         _b*=10
      ?};
      Tbank[_c]:=0
   !};
   VAR.NOMINAŁY:=_i
?}


\t_banks
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Procedura rozdziela podaną jako parametr kwotę na poszczególne nominały. Dodaje ilość poszczególnych nominałów
::       do już istniejących. Ilość nominałów w tablicy Tbank. Parametr wejściowy określa kwotę do rozłożenia na nomi-
::       nały. Wywołanie bez parametrów zeruje istniejącą kwotę.
::   WE:
::   WY:
::  OLD: \Tbanks/funkcje.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| {! _i:=1..VAR.NOMINAŁY
   |! Tbank [_i]:=0
   !}
|| _a:=_a$2;
   _a*=100;
   {! _i:=VAR.NOMINAŁY // (-1)..1
   |! {? Nominal[_i]<>0
      || _b:=_a%(100*Nominal[_i]);
         Tbank[_i]+=_b;
         _a-=_b*100*Nominal[_i]
      ?}
   !}
?}


\t_prac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::  OLD: \tprac/tfunkcje.fml
::----------------------------------------------------------------------------------------------------------------------
_IsValid:=(_a>=1 & _a<=LISTA.Kolumny());

{? _IsValid & (_b>=0 & _b<=LISTA.__PracR)
|| _IsValid:=1
?};

{? _IsValid
|| {? {? _b=0
      || _Skl:=LISTA.Prac[_a].Last()
      |? _b-=LISTA.Wiersze('Prac')-LISTA.Prac[_a].Size();
         _b>=1 & _b<=LISTA.Prac[_a].Size()
      || _Skl:=LISTA.Prac[_a].Array[_b]
      || _Skl:=0
      ?}
   || {? R.find_key(_Skl)
      || {? _c=1 || _Skl
         |? _c=2 || R.RT
         |? _c=3 || LISTA.SPrac[_Skl]
         || R.RK
         ?}
      || {? _c=2 | _c=4 || ''
         |? _c=1 | _c=3 || 0
         ?}
      ?}
   || {? _c=2 | _c=4 || ''
      |? _c=1 | _c=3 || 0
      ?}
   ?}
?}


\t_wydz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::  OLD: \twydz/tfunkcje.fml
::----------------------------------------------------------------------------------------------------------------------
_IsValid:=(_a>=1 & _a<=LISTA.Kolumny());

{? _IsValid & (_b>=0 & _b<=LISTA.__WydzR)
|| _IsValid:=1
?};

{? _IsValid
|| {? {? _b=0
      || _Skl:=LISTA.Wydz[_a].Last()
      |? _b-=LISTA.Wiersze('Wydz')-LISTA.Wydz[_a].Size();
         _b>=1 & _b<=LISTA.Wydz[_a].Size()
      || _Skl:=LISTA.Wydz[_a].Array[_b]
      || _Skl:=0
      ?}
   || {? R.find_key(_Skl)
      || {? _c=1 || _Skl
         |? _c=2 || R.RT
         |? _c=3 || LISTA.SWydz[_Skl]
         || R.RK
         ?}
      || {? _c=2 | _c=4 || ''
         |? _c=1 | _c=3 || 0
         ?}
      ?}
   || {? _c=2 | _c=4 || ''
      |? _c=1 | _c=3 || 0
      ?}
   ?}
?}


\t_zakl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS:
::   WE:
::   WY:
::  OLD: \tzakl/tfunkcje.fml
::----------------------------------------------------------------------------------------------------------------------
_IsValid:=(_a>=1 & _a<=LISTA.Kolumny());

{? _IsValid & (_b>=0 & _b<=LISTA.__ZaklR)
|| _IsValid:=1
?};

{? _IsValid
|| {? {? _b=0
      || _Skl:=LISTA.Zakl[_a].Last()
      |? _b-=LISTA.Wiersze('Zakl')-LISTA.Zakl[_a].Size();
         _b>=1 & _b<=LISTA.Zakl[_a].Size()
      || _Skl:=LISTA.Zakl[_a].Array[_b]
      || _Skl:=0
      ?}
   || {? R.find_key(_Skl)
      || {? _c=1 || _Skl
         |? _c=2 || R.RT
         |? _c=3 || LISTA.SZakl[_Skl]
         || R.RK
         ?}
      || {? _c=2 | _c=4 || ''
         |? _c=1 | _c=3 || 0
         ?}
      ?}
   || {? _c=2 | _c=4 || ''
      |? _c=1 | _c=3 || 0
      ?}
   ?}
?}


\br_o
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [17.00]
:: OPIS: Rekord przed okien tabeli O
::   WE: _a [NUMBER] - Rekord bieżący? [0 - nie / 1 - tak]
::----------------------------------------------------------------------------------------------------------------------
{? O.DOK<>''
|| Color.fnd_kol('O#01#01')
|| ''
?}


\dod_zxx
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [11.22]
:: OPIS: Utworzenie naglowka listy typu ZXX.
::   WE: _a [_O] - wskazanie listy płac
::  OLD: \dod_zxx/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
O.cntx_psh();
SEEK.O:=_a;
SEEK.O();
{? -O.T().T='sum'
|| KT.index('KRYTERIA');
   KT.prefix(exec('ref_firma','ustawienia'));
   {? ~KT.find_key('ZXX')
   || FUN.emsg('Brak typu \'ZXX\' list płac (rozliczenie z ZUS).'@);
      O.cntx_pop();
      return()
   ?};

   O.T:=KT.ref();
   O.F:=O.T().F;
   O.M:=O.MP:=O.MU;
   O.R:=O.RP:=O.RU;
   O.LT:=-('L'+($O.R+2)+('0'+$O.M+2)+KT.T);
   O.F_ZATR:=KT.F_ZATR;
   {? O.add(1)
   || exec('put_stat','lista_plac',O.ref,'LSLP_AKT',1);
      exec('put_stat','lista_plac',O.ref,'ZBLP_AKT',1)
   ?}
?};
O.cntx_pop()


\otwarte_ubezp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Sprawdza, czy wszystkie listy płac z miesiąca ubezpieczeniowego są zamknięte.
::   WE: _a - rok ubezpieczeniowy (domyślnie roku bieżącej listy płac)
::   WY: _b - miesiąc ubezpieczeniowy (domyślnie miesiąc bieżącej listy płac)
::  OLD: \testlist/rap_zus.fml
::----------------------------------------------------------------------------------------------------------------------
sql(
   'select O.T '
   'from O '
   'where O.FIRMA=:_a and O.Z=\'N\' and O.RU=:_b and O.MU=:_c',
   exec('ref_firma','ustawienia'),
   {? var_pres('_a')=type_of(0) || _a || O.RU ?},
   {? var_pres('_b')=type_of(0) || _b || O.MU ?}
).first()


\rhttub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.51]
:: OPIS: Tytuł ubezpieczenia dla rachunku.
::   WE: _a [REFERENCE] - Wskazanie rekordu tabeli OSOBA.
::       _b [DATE]      - Data wypłaty rachunku (RH.DWY).
::       _c [STRING]    - Tytuł ubezpieczenia (ZC_INFO.TTUB().KOD).
::       _d [DATE]      - Data końcowa obowiązywania tytułu ubezpieczenia (ZC_INFO.DW).
::   WY: Kod tytułu ubezpieczenia.
::  OLD: \rhttub/funkcje.fml
::----------------------------------------------------------------------------------------------------------------------
_osoba:=_a;
_rhdwy:=_b;
_ttub:=_c;
_zcidw:=_d;

_ru:=_rhdwy~1;
_mu:=_rhdwy~2;

_d0:=date(0,0,0);
_start:=date(_ru,_mu,1);

_zm:='3000';

{? _ttub=''
|| return(_zm)
?};

{? _start<=_zcidw | _zcidw=_d0
|| return(_ttub)
?};

_ret:=_ttub;
{? 2+_ttub='01'
|| OSOBA.cntx_psh();
   OSOBA.prefix();
   P.cntx_psh;
   _dz:={? OSOBA.seek(_osoba) || exec('ustal_dz','rap_zus',_ru,_mu) || _d0 ?};
   P.cntx_pop();
   OSOBA.cntx_pop();
   {? _dz<>_d0 & _dz<_rhdwy
   || _ret:=_zm
   ?}
|| ZC_INFO.cntx_psh();
   ZC_INFO.index('ZLECDW');
   ZC_INFO.prefix(exec('ref_firma','ustawienia'),_osoba);

:: Korekta daty końca obowiązywania tytułu ubezpieczenia.
   {? ZC_INFO.find_le(_zcidw)
   || S_ZUS.cntx_psh();
      S_ZUS.prefix();
      {!
      |? {? ZC_INFO.TTUB().KOD=_ttub & ZC_INFO.DU<=(_zcidw+1) & _zcidw<=ZC_INFO.DW
            & (ZC_INFO.ZUS+ZC_INFO.FC+ZC_INFO.FW+ZC_INFO.FP+ZC_INFO.FG)*'T'
         || _zcidw:=ZC_INFO.DW
         ?};
         _zcidw<_start & ZC_INFO.next()
      !};
      S_ZUS.cntx_pop()
   ?};

   {? _zcidw<_start & ZC_INFO.last()
   || _ldni:=_rhdwy-_zcidw;
      {? _ldni<=65535
::       Maksymalny rozmiar tablicy.
      || _info:=obj_new(_ldni);
         {! _lp:=1 .. _ldni
         |! _info[_lp]:=0
         !};
         _info_od:=date(9999,1,1);
         _info_do:=_d0;
         {!
         |? {? ZC_INFO.DU<=_rhdwy & ZC_INFO.DW>_zcidw & (ZC_INFO.ZUS+ZC_INFO.FC+ZC_INFO.FW+ZC_INFO.FP+ZC_INFO.FG)*'T'
            || {? ZC_INFO.DU<=_zcidw+1
               || _info_od:=_zcidw+1
               || _info_od:=ZC_INFO.DU
               ?};
               {? ZC_INFO.DW>=_rhdwy
               || _info_do:=_rhdwy
               || _info_do:=ZC_INFO.DW
               ?};
               {! _lp:=_info_od-_zcidw .. _info_do-_zcidw
               |! _info[_lp]:=1
               !}
            ?};
            ZC_INFO.prev() & ZC_INFO.DW>=_zcidw
         !};
         _trwa:=1;
         {! _lp:=1 .. _ldni
         |? _trwa:=_info[_lp]
         !};
         {? ~_trwa
         || _ret:=_zm
         ?}
      ?}
   ?};

   ZC_INFO.cntx_pop()
?};
_ret


\o_czyzamk_mies
::----------------------------------------------------------------------------------------------------------------------
::  UTW: wsos [19.02]
:: OPIS: Informacja czy wszystkie listy w zadanym miesiącu są zamknięte i czy istnieje lista SUM
::       zakładamy że to oznacza że miesiąc został zamknięty
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
O.cntx_psh();
O.index('LISTYMIE');
O.prefix(O.FIRMA,O.R,O.M,);
_zamk:=1;
_sum:=O.find_key('SUM');
{? _sum & O.first()
|| {!
   |? {? O.Z='N' || _zamk:=0 ?};
      _zamk & O.next()
   !}
?};
O.cntx_pop();
return(_zamk=1 & _sum=1)


\weryfikuj_lp_O
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [19.42]
:: OPIS: Zadaniem procedury jest wyświetlenie okienka z listami, które powinny byc ponownie przeliczone ze względu
::       na kolejność naliczania list płac związaną ze zmianami progów podatkowych 2020.
::       Procedura uruchamiana w kontekście listy płac, podczas wybrania listy.
::   WE:
::   WY:
::  OLD: \weryfikuj_lp_O/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('FUNKCJE')<0 || exec('FUNKCJE','object') ?};
{? ~FUNKCJE.PODATEK || return(0) ?};
O.cntx_psh();
KT.cntx_psh();
O_STAT.cntx_psh();
UD_SKL.cntx_psh();
LS.cntx_psh();
P.cntx_psh();
OSOBA.cntx_psh();
USERS.cntx_psh();

_cnt_pop:="
   O.cntx_pop();
   KT.cntx_pop();
   O_STAT.cntx_pop();
   UD_SKL.cntx_pop();
   LS.cntx_pop();
   P.cntx_pop();
   OSOBA.cntx_pop();
   USERS.cntx_pop()
";
VAR_DEL.delete('__Tab_LS');

__Tab_LS:=tab_tmp(2,
   'LISTA','STRING[8]','Lista płac',
   'DATA','DATE','Data wypłaty',
   'D_MOD','DATE','Data modyfikcji',
   'WYD','STRING[16]','Wydział',
   'USER','STRING[30]','Użytkownik',
   'USER_N','STRING[30]','Użytkownik',
   'B_LISTA','STRING[10]','Lista przeliczona później',
   'DANE','STRING[150]','Dane listy wymuszającej weryfikacje',
   'D_NAST','DATE','Data listy późniejszej',
   'D_MOD_N','DATE','Data modyfikcji listy późniejszej',
   'STATUS','STRING[3]','Status weryfikacji',
   'G_MOD','TIME','Godzina modyfikacji',
   'G_MOD_N','TIME','Godzina modyfikacji',
   'REF_L','STRING[16]','REF listy płac',
   'REF_B_L','STRING[16]','REF listy płac'
   );
_test:="_a<>'ZXX' & _b<>'S'";
O_STAT.index('KOD');
_wyn:=1;
O.index('LISTYPLP');
O.prefix(exec('ref_firma','ustawienia'),'P',O.RP,O.MP);

_P_STkod:=exec('kod','ext_slo','P_STAT','LIST_MOD');
P_STAT.index('LISTA');
_T_PRAC:=tab_tmp(2,
   'P','STRING[16]','Pracownik',
   'WYD','STRING[16]','WYDZIAL',
   'P_REF','INTEGER','Ref pracownika jako int',
   'NAZWISKO','STRING[30]','Nazwisko',
   'IMIE','STRING[20]','Imię',
   'TECZKA','STRING[9]','Numer teczki'
   );
_T_USR:=tab_tmp(1,
   'SQL','STRING[16]','Ref sql',
   'DANE','STRING[30]','USER'
   );
{? O.first
|| {!
   |? {? _test(O.T().T,KT.F) & O.Z='N'
      || O_STAT.prefix(O.ref,'OBLICZ',);
         {? O_STAT.first()
         || _data:=O_STAT.DATA;
            _godz:=O_STAT.GODZ;
            _USER:=O_STAT.KTO().DANE;
            _opis:=(13+O_STAT.OPIS)='Zweryfikowano';
            _ok:=1
         || _ok:=0
         ?};
         {? _ok
         || _lista:=O.LT;
            _ref_l:=$O.ref();
            _d_lista:=O.D;
            _numer:=O.N;
            _WYD:=O.WYDZIAL().SYMBOL;

            O.cntx_psh();
            _P_ST_OK:=_P_STAT1:=0;
            P_STAT.prefix(O.ref(),_P_STkod);
            {? P_STAT.first()
            || _P_STAT1:=1;
               _P_ST_D:=P_STAT.DATA;
               _P_ST_G:=P_STAT.GODZ
            || _P_STAT1:=0
            ?};
            O.first();
            {!
            |? {? _test(O.T().T,KT.F)
               || {? O.D<_d_lista | (O.D=_d_lista & O.N<_numer)
                  || O_STAT.prefix(O.ref,'OBLICZ',);
                     {? O_STAT.first()
                     || {? ~((13+O_STAT.OPIS)='Zweryfikowano' & _opis)
                        || {? (_opis &  O_STAT.DATA>_data | (O_STAT.DATA=_data & O_STAT.GODZ>_godz)) |
                              ~_opis
                           || {? _P_STAT1
                              || P_STAT.prefix(O.ref(),_P_STkod);
                                 _P_ST_OK:=0;
                                 {? P_STAT.last()
                                 || {? P_STAT.DATA>_P_ST_D | (P_STAT.DATA=_P_ST_D & P_STAT.GODZ>_P_ST_G)
                                    || _P_ST_OK:=1
                                    ?}
                                 ?}
                              || _P_ST_OK:=1
                              ?};
                              {? _P_ST_OK
                              || __Tab_LS.blank(1);
                                 __Tab_LS.STATUS:='NIE';
                                 __Tab_LS.D_MOD:=_data;
                                 __Tab_LS.G_MOD:=_godz;
                                 __Tab_LS.LISTA:=~_lista;
                                 __Tab_LS.REF_L:=_ref_l;
                                 __Tab_LS.DATA:=_d_lista;
                                 __Tab_LS.WYD:=_WYD;
                                 __Tab_LS.USER:=_USER;
                                 __Tab_LS.B_LISTA:=~O.LT;
                                 __Tab_LS.REF_B_L:=$O.ref();
                                 __Tab_LS.D_NAST:=O.D;
                                 __Tab_LS.D_MOD_N:=O_STAT.DATA;
                                 __Tab_LS.G_MOD_N:=O_STAT.GODZ;
                                 __Tab_LS.USER_N:=O_STAT.KTO().DANE;
                                 __Tab_LS.add()
                              ?}
                           ?}
                        ?}
                     ?}
                  ?}
               ?};
               O.next()
            !};
            O.cntx_pop()
         ?}
      ?};
      O.next()
   !};

   {? __Tab_LS.first()
   || VAR_DEL.delete('__t_wyn');
      USERS.prefix();
      P.prefix();

      __t_wyn:=tab_tmp(2,
         'NAZWISKO','STRING[30]','Nazwisko',
         'IMIE','STRING[20]','Imię',
         'TECZKA','STRING[9]','Numer teczki',
         'WYD','STRING[16]','Wydział',
         'USER','STRING[30]','Operator obliczający',
         'DATA','DATE','Data ostatniego naliczenia',
         'TIME','TIME','Godzina ostatniego naliczenia',
         'LISTA','STRING[8]','Lista płac',
         'B_LISTA','STRING[10]','Lista przeliczona później'
         );

      {!
      |? exec('spr_P_O_LS','lista_plac',__Tab_LS, __t_wyn, _T_PRAC,_T_USR, _P_STkod);
         {? __Tab_LS.STATUS='TAK'
         || __Tab_LS.del(,1)=2
         || __Tab_LS.next()
         ?}
      !};

      {? __Tab_LS.first()
      || VAR_DEL.delete('__Tab_w','__t_w','__tab_LT','__tab_w');
         _wyn:=0;
         __t_wyn.index(__t_wyn.ndx_tmp(,,'LISTA',,,'B_LISTA',,));

         __t_w:=__t_wyn.mk_sel('Pracownicy do weryfikacji lub ponownego przeliczenia na liście'@,'T',0,'__t_w',,,,,'U');
         __t_wyn.win_fld(__t_w,,'NAZWISKO',,,20,,1,'Nazwisko');
         __t_wyn.win_fld(__t_w,,'IMIE',,,15,,1,'Imię');
         __t_wyn.win_fld(__t_w,,'TECZKA',,,10,,1,'Nr teczki');
         __t_wyn.win_fld(__t_w,,'WYD',,,16,,1,'Jednostka org.');
         __t_wyn.win_fld(__t_w,,'USER',,,10,,1,'Operator obliczający');
         __t_wyn.win_fld(__t_w,,'DATA',,,10,,1,'Data ostatniego naliczenia');
         __t_wyn.win_fld(__t_w,,'TIME',,,10,,1,'Godzina ostatniego naliczenia');
         __t_wyn.win_sel(__t_w);

         __Tab_w:=__Tab_LS.mk_sel('Listy płac, które spowodowały konieczność weryfikacji:'@,'T',0,'__tab_w',,,,,'U');
         __Tab_LS.win_fld(__Tab_w,,'B_LISTA',,,10,,1,'Symbol listy');
         __Tab_LS.win_fld(__Tab_w,,'D_MOD_N',,,10,,1,'Data modyfikacji');
         __Tab_LS.win_fld(__Tab_w,,'G_MOD_N',,,10,,1,'Czas modyfikacji');
         __Tab_LS.win_fld(__Tab_w,,'D_NAST',,,10,,1,'Data wypłaty');
         __Tab_LS.win_fld(__Tab_w,,'USER_N',,,30,,1,'Operator obliczający');

         __tab_LT:=sql('select distinct tab.LISTA, tab.DATA, tab.WYD, tab.D_MOD, tab.G_MOD, tab.STATUS, tab.USER '
                       'from :_a as tab order by 1,2',__Tab_LS);

         _tytul:='Listy płac, na których potencjalnie należy ponownie przeliczyć wybranych pracowników:'@;
         __tab_w:=__tab_LT.mk_sel(_tytul,'T',0,'tab_wyn_prog',,,,,'U');
         __tab_LT.win_fld(__tab_w,,'STATUS',,,3,,1,'Weryfikacja',,,2,,"'TAK'","'NIE'");
         __tab_LT.win_fld(__tab_w,,'LISTA',,,10,,1,'Symbol listy');
         __tab_LT.win_fld(__tab_w,,'D_MOD',,,10,,1,'Data modyfikacji');
         __tab_LT.win_fld(__tab_w,,'G_MOD',,,10,,1,'Czas modyfikacji');
         __tab_LT.win_fld(__tab_w,,'DATA',,,10,,1,'Data wypłaty');
         __tab_LT.win_fld(__tab_w,,'WYD',,,16,,1,'Jednostka org.');
         __tab_LT.win_fld(__tab_w,,'USER',,,30,,1,'Operator obliczający');
         __tab_LT.win_act(__tab_w,0,'Formuła','Weryfikacja',,,"
            {? __tab_LT.STATUS='NIE'
            || {? FUN.ask('Czy oznaczyć wybraną listę jako pozytywnie zweryfikowaną?\n'@+
                     'Po oznaczeniu pozytywnej weryfikacji wszystkie zapisy dla tej listy nie będą już wyświetlane.'@)
               || __tab_LT.STATUS:='TAK';
                  __tab_LT.put();
                  grp_disp(__Tab_LS,__Tab_w)
               ?}
            || {? FUN.ask('Czy zmienić status weryfikacji na: (NIEZWERYFIKOWANY)?'@)
               || __tab_LT.STATUS:='NIE';
                  __tab_LT.put();
                  grp_disp(__Tab_LS,__Tab_w)
               ?}
            ?}",,1);
         __tab_LT.win_sel(__tab_w);
         __Tab_LS.win_sel(__Tab_w);

         _win_acr:=__tab_LT.grp_make('Listy płac, na których należy zweryfikować wyliczenia wybranych pracowników:'@,
            "grp_disp(__Tab_LS,__Tab_w,1)",'tab_wyn_prog');
         __tab_LT.grp_sel(_win_acr, __tab_LT, __tab_w,,"
            {? __tab_LT.size()
            || {?  __tab_LT.f_active() & __tab_LT.f_size()=0
               || __Tab_LS.prefix('????????')
               || __Tab_LS.prefix(__tab_LT.LISTA)
               ?}
            || __Tab_LS.prefix('????????')
            ?};
            __Tab_LS.first;
            grp_disp(__Tab_LS,__Tab_w,1); grp_disp(__t_wyn,__t_w)
            ");
         __tab_LT.grp_splt(_win_acr,,'horizontal','bot',10);
         __tab_LT.grp_sel(_win_acr, __Tab_LS, __Tab_w,,"
            {? __Tab_LS.size()
            || {? __Tab_LS.f_active() & __Tab_LS.f_size()=0
               || __t_wyn.prefix('????????')
               || __t_wyn.prefix(__Tab_LS.LISTA,__Tab_LS.B_LISTA)
               ?}
            || __t_wyn.prefix('????????')
            ?};
            __t_wyn.first;
            __t_wyn.hdr_sel(); __t_wyn.hdr_sel(': '+__t_wyn.LISTA);
            grp_disp(__t_wyn,__t_w)
            ");
         __tab_LT.grp_splt(_win_acr,,'horizontal','bot1',20);
         __tab_LT.grp_sel(_win_acr, __t_wyn, __t_w,,"grp_disp(__Tab_LS,__Tab_w)");
         __tab_LT.win_sel(_win_acr);
         __tab_LT.select();

         {? __tab_LT.first()
         || O.cntx_psh();
            O.index('LISTYPZN');
            {!
            |? {? __tab_LT.STATUS='TAK'
               || O.prefix(exec('ref_firma','ustawienia'),-__tab_LT.LISTA);
                  {? O.first()
                  || exec('put_stat','lista_plac',O.ref,'OBLICZ',1,'Zweryfikowano kolejność naliczania listy płac.')
                  || FUN.emsg('Nie znaleziono listy płac: %1\nAkcja została anulowana.'@[__tab_LT.LISTA])
                  ?}
               ?};
               __tab_LT.next()
            !};
            O.cntx_pop()
         ?};

         VAR_DEL.delete('__Tab_w','__t_w','__tab_LT','__tab_w')
      ?};
      VAR_DEL.delete('__t_wyn')
   ?}
?};
VAR_DEL.delete('__Tab_LS');
_cnt_pop();
_wyn


\spr_P_O_LS
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.50]
:: OPIS: Zadaniem procedury jest zweryfikowanie pracowników na liście płac pod względem kolejności naliczania
::   WE: _a [TABELA] - alias tabeli do analizy
::       _b [TABELA] - alias tabeli wynikowej
::       _c [TABELA] - alias tabeli wydziałów
::       _d [TABELA] - alias tabeli userów
::       _e - kod LIST_MOD
::   WY: Wynik weryfkacji:
::       1 - weryfikacja prawidłowa, 0 - istnieją pracownicy, którym należy przeliczyć listę
::  OLD: \spr_P_O_LS/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_tab_wyn:=_b;
_tab_wyd:=_c;
_tab_usr:=_d;
_kod:=_e;

_firma:=exec('ref_firma','ustawienia');

:: wykasowanie pozycji tabeli wg wskazanego statusu
_del:="
   {? _a.first()
   || {! |? {? _a.STATUS=_b || _a.del(,1)=2 || _a.next() ?} !}
   ?}";

_sql:="sql('
      select distinct P_STAT.P P, P_STAT.DATA D, P_STAT.GODZ T, P_STAT.KTO KTO, 0 STATUS
      from P_STAT join O using(P_STAT.O,O.REFERENCE)
      where P_STAT.SLO_KOD=:_a and O.REFERENCE=\'':_b\''
      order by 1,2,3',
      _a,_b
   )";
_tab_1:=_sql(_kod,_tab.REF_L);
_tab_2:=_sql(_kod,_tab.REF_B_L);

:: dla każdego rekordu _tab_1 do weryfikacji
{? _tab_1.first()
|| {!
   |?
:: Sprawdzenie czy konkretny pracownik z tab_1 występuje w tabeli badanej i data ostatniego naliczenia jest późniejsza
      {? _tab_2.find_key(_tab_1.P) & (_tab_2.D>_tab_1.D | (_tab_2.D=_tab_1.D &  _tab_2.T>_tab_1.T))
:: jeżeli tak jest status jest ustawiany rekord nie będzie usunięty - znaleziono przypadek badany
      || _tab_1.STATUS:=2;
         _tab_1.D:=_tab_2.D;
         _tab_1.T:=_tab_2.T;
         _tab_1.KTO:=_tab_2.KTO;
         _tab_1.put()
      ?};
      _tab_1.next()
   !}
?};
_del(_tab_1,0);
_del(_tab_2,0);
_P_UPR:=exec('dostepne_p','schemat','PPL','P');
_P_UPR.index(_P_UPR.ndx_tmp(,,'OSOBA',,));
{? _tab_1.first()
|| USERS.prefix();
   P.prefix();

   {!
   |? _ok:=0;
      {? ~_tab_wyd.find_key(_tab_1.P)
      || _tab_wyd.P:=_tab_1.P;
         _tab_wyd.P_REF:=BIT.sqlint(_tab_1.P);
         {? P.seek(_tab_wyd.P_REF,)
         || P.OSOBA();
            _tab_wyd.WYD:=exec('ustal_wydzial','pracownik',P.ref,,1);
            _P_UPR.prefix($OSOBA.ref);
            {? _P_UPR.first()
            || _tab_wyd.NAZWISKO:=OSOBA.NAZWISKO;
               _tab_wyd.IMIE:=OSOBA.PIERWSZE
            || _tab_wyd.NAZWISKO:='Brak uprawnień';
               _tab_wyd.IMIE:='Brak uprawnień'
            ?};
            _tab_wyd.TECZKA:=P.T;
            _ok:=_tab_wyd.add()
         ?}
      || _ok:=1
      ?};
      {? _ok
      || _tab_wyn.blank(1);
         _tab_wyn.NAZWISKO:=_tab_wyd.NAZWISKO;
         _tab_wyn.IMIE:=_tab_wyd.IMIE;
         _tab_wyn.LISTA:=_tab.LISTA;
         _tab_wyn.B_LISTA:=_tab.B_LISTA;
         _tab_wyn.TECZKA:=_tab_wyd.TECZKA;
         _tab_wyn.WYD:=_tab_wyd.WYD;
         {? ~_tab_usr.find_key(_tab_1.KTO)
         || {? USERS.seek(_tab_1.KTO,)
            || _tab_usr.SQL:=_tab_1.KTO;
               _tab_wyn.USER:=_tab_usr.DANE:=USERS.DANE;
               _tab_usr.add()
            ?}
         || _tab_wyn.USER:=_tab_usr.DANE
         ?};
         _tab_wyn.DATA:=_tab_1.D;
         _tab_wyn.TIME:=_tab_1.T;
         _tab_wyn.add(1)
      ?};
      _tab_1.next()
   !};

   {? ~_tab_wyn.first
   || _tab.STATUS:='TAK';
      _tab.put
   ?}
|| _tab.STATUS:='TAK';
   _tab.put()
?};
obj_del(_P_UPR);
&_P_UPR;
1


\spr_num_listy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [19.42]
:: OPIS: Procedura do weryfikacji wprowadzonego numeru listy gdy data wypłaty listy się powiela
::   WE: _a [INT] Rok podatkowy
::       _b [INT] Miesiąc podatkowy
::       _c [INT] Numer listy
::       _d [DATE] Data wypłaty listy
::       _e [STRING] akcja menu
::       _f [STRING] - typ listy
::       _g [STRING] - typ formuł
::   WY: znak listy - dla istniejącej listy (dla daty i numeru)
::       '' - jeżeli nie ma identycznej listy (dla daty i numeru)
::  OLD: \spr_num_listy/listplac.fml
::----------------------------------------------------------------------------------------------------------------------
_test:="_a<>'ZXX' & _b<>'S'";
{? ~_test(_f,_g) || return('') ?};
_rok:=_a;
_mc:=_b;
_numer:=_c;
_d_listy:=_d;
_akcja:=_e;
_wyn:='';
{? _akcja='popraw' || _ref:=O.ref() || _ref:=null ?};

O.cntx_psh();
KT.cntx_psh();
O.index('LISTYPLP');
O.prefix(exec('ref_firma','ustawienia'),'P',_rok,_mc);
{? O.first()
|| {!
   |? {? _test(O.T().T,KT.F) & O.ref<>_ref & O.D=_d_listy & O.N=_numer
      || _wyn:=O.LT
      ?};
      _wyn='' & O.next
   !}
?};
O.cntx_pop();
KT.cntx_pop();
_wyn


\jest_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.14]
:: OPIS: Sprawdza, czy na liście/rachunku jest jakiś zablokowany składnik.
::   WE: _a _O/_RH - wskazanie nagłówka listy płac lub rachunku
::       _b [_P] - wskazanie współpracownika
::   WY: 0/1/~~ - brak blokad/jest zablokowany składnik/błąd
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null) | _a=null | (ref_tab(_a)<>O & ref_tab(_a)<>RH)
:: _a typu innego niż wskazanie O lub RH
|| return()

|? ref_tab(_a)=O & (var_pres('_b')<>type_of(null) | _b=null | ref_tab(_b)<>P)
:: _b typu innego niż wskazanie P gdy _a jest wskazaniem O
|| return()
?};

_ret:=0;

{? ref_tab(_a)=O
|| _o_ref:=_a;
   _p_ref:=_b;

   O.cntx_psh();
   LS.cntx_psh();
   SEEK.O:=_o_ref;
   {? LS.name()<>SEEK.O().LT
   || LS.use(O.LT)
   ?};

   LS.index('BLNRRU');
   LS.prefix(_o_ref,_p_ref,1);
   _ret:=LS.first();

   LS.cntx_pop();
   O.cntx_pop()

|? ref_tab(_a)=RH
|| _rh_ref:=_a;

   O.cntx_psh();
   RH.cntx_psh();
   LS.cntx_psh();
   SEEK.RH:=_rh_ref;
   {? LS.name()<>SEEK.RH().O().LT
   || LS.use(O.LT)
   ?};

   LS.index('RHBLNRRU');
   LS.prefix(_rh_ref,1);
   _ret:=LS.first();

   LS.cntx_pop();
   RH.cntx_pop();
   O.cntx_pop()
?};

_ret


\obj_decl_ZW_PRZ
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [21.37]
:: OPIS: Definicja struktury i metod obiektu __ZW_PRZ.
::       Obiekt do obsługi zwolnienia z przychodu.
::  OLD: \obj_decl_ZW_PRZ/kaliobi.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__ZW_PRZ',@.CLASS)>0 || return ?};

obj_decl('__ZW_PRZ',
:: Czy jest w systemie zwolnienie od przychodu - Polski Ład
 obj_fld('JEST_PL',0),
:: Kod zwolnienia
   obj_fld('KOD',''),
:: ref typu zwolnienia
   obj_fld('OS_ZWSLO',null),
:: Kontekst pracy
   obj_fld('ROK',0),
   obj_fld('MC',0),
:: Czy oświadczenie o rezygnacji
   obj_fld('STOP',0),
   obj_fld('LISTA',null),
   obj_fld('RH',null),
:: Limit nominalny dla danego typu ze stałych systemu
   obj_fld('NOM_LIM',0),
:: Limit wykorzystany
   obj_fld('WYK_LIM',0),
:: Limit dostepny
   obj_fld('WIEK',0),
:: Czy składka zdrowotna
   obj_fld('ZDR',0),
:: Zwolniony przychód ze stosunku pracy i pokrewnych
   obj_fld('PRACA',0),
:: Zwolniony przychód z zasiłku macierzyńskiego
   obj_fld('MAC',0),
:: Rodzaj płatnika
   obj_fld('PLATNIK',''),

:: metody:
:: konstruktor
   obj_meth('__init',".check()"),
   obj_meth('check',"
      .JEST_PL:=0;
      {? var_pres('ZWPODW',KST)>0 & var_pres('ZWPOD',KST)>0
         & var_pres('ZWPODE',KST)>0 & var_pres('ZWPODP',KST)>0 &  var_pres('ZWPODD',KST)>0
      || .JEST_PL:=1
      ?}
   "),

:: ustalenie typu dla polskiego ładu
   obj_meth('create',"
      {? ~.JEST_PL || return(~~) ?};
      .blank();
      {? P.F_ZATR().KOD='Z'
      || .RH:=RH.ref;
         .LISTA:=null;
         _data:=RH.DWY;
         .ROK:=RH.DWY~1;
         .MC:=RH.DWY~2;
         OS_GRRU.index('RU');
         OS_GRRU.prefix(RH.ZLE().RU);
         {? OS_GRRU.first()
         || {!
            |? {? OS_GRRU.SLO_KOD().SYSTEM='T'
               || .PLATNIK:=OS_GRRU.SLO_KOD().KOD
               ?};
               .PLATNIK='' & OS_GRRU.next()
            !}
         ?};
         {? .PLATNIK='' || .PLATNIK:='UM_ZLEC' ?}
      || .RH:=null;
         .LISTA:=O.ref;
         _data:=O.D;
         .ROK:=O.RP;
         .MC:=O.MP;
         .PLATNIK:='UM_PRAC'
      ?};
      .MAC:=.PRACA:=0;
      .del_pozycja();

      OS_ZWPOZ.index('OS_RWR');
      OS_ZWPOZ.prefix(exec('ref_firma','ustawienia'),OSOBA.ref,.ROK);
      .WYK_LIM:=0;
      {? OS_ZWPOZ.first
      || .WYK_LIM:=exec('rozlicz_suma','lista_licz',9022,OSOBA.ref(),.ROK,,,,,.MC,1).WART
      ?};
      exec('czytaj','#stalesys',_data,KST,'ZWPODW','ZWPOD');
      .WIEK:=KST.ZWPODW;
      {? exec('czy_ulga_U26','lista_licz',_data,.PLATNIK)
      || .OS_ZWSLO:=.ref_typ('ZWPOD');
         {? .OS_ZWSLO
         || .KOD:='ZWPOD';
            .NOM_LIM:=KST.ZWPOD;
            .ZDR:=1
         ?}
      || .KOD:=.find_kod(_data);
         {? .KOD<>''
         || .OS_ZWSLO:=.ref_typ(.KOD);
            {? OS_ZWSLO.seek(.OS_ZWSLO)
            || .ZDR:=OS_ZWSLO.ZDR='T'
            ?};
             exec('czytaj','#stalesys',_data,KST,.KOD);
            .NOM_LIM:=($('KST.'+.KOD))()
         ?}
      ?};
      ~~
   "),

:: zerowanie wartości
   obj_meth('blank',"
      .KOD:='';
      .WIEK:=0;
      .ROK:=0;
      .NOM_LIM:=0;
      .WYK_LIM:=0;
      .LISTA:=null;
      .RH:=null"),

:: wyszukanie wskazania typu zwolnienia (wg kodu)
   obj_meth('ref_typ',"
      _ret:=null;
      {? ~.JEST_PL || return(_ret) ?};
      _ret:=exec('rozlicz_ref_typ','lista_licz',_a);
      _ret
   ",
   type_of('')),

:: wyszukanie wskazania typu zwolnienia (wg daty)
   obj_meth('find_kod',"
      _ret:='';
      {? ~.JEST_PL || return(_ret) ?};
      _dod:=_a;
      _ret:=exec('os_zwpod_find','overlap',_dod,,.PLATNIK);
      _ret
   ",
   type_of(date())),

:: dodanie pozycji dla zwolnienia
   obj_meth('add_pozycja',"
      {? ~.JEST_PL || return(0) ?};
      _ret:=exec('rozlicz_add_pozycja','lista_licz',.OS_ZWSLO,.ROK,.MC,.LISTA,.RH);
      _ret
   "),

:: dodanie wartości dla pozycji zwolnienia
   obj_meth('add_wartosc',"
::    _a – [REFERENCE] wskazanie na pozycję zwolnienia
::    _b – [INTEGER] numer sładnika płacowego
::    _c – [REAL]  wartość
      {? ~.JEST_PL || return(0) ?};
      _poz:={? var_pres('_a')=type_of(null) || _a || null ?};
      _rub:={? var_pres('_b')=type_of(0) || _b || 0 ?};
      _war:={? var_pres('_c')=type_of(0) || _c || 0 ?};
      {? _poz=null | ~_rub | ~_war || return(0) ?};
      exec('rozlicz_add_wartosc','lista_licz',_poz,_rub,_war)
   "),

:: usuwanie pozycji
   obj_meth('del_pozycja',"
      {? ~.JEST_PL || return(0) ?};
      _ret:=exec('rozlicz_del_pozycja','lista_licz',.ROK,.MC,.LISTA,.RH);
      _ret
   "),

:: dodanie wartości z listy płac
  obj_meth('add',"
      exec('rozlicz_add','lista_licz',__ZW_PRZ.KOD,.RH)
   ")
)


\czy_prac_kraj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Sprawdza przynależność pracownika do listy płac z uwzględnieniem kraju (oddelegowania).
::       Weryfikacja odbywa się dla bieżących rekordów tabel P i O.
::   WE: _a - Czy w sprawdzeniu pomijać charakter pracy?
::          0 - Nie [domyślnie]
::          1 - Tak, pomijać.
::   WY: 1 - wynagrodzenie pracownika można naliczyć na liście,
::       0 - pracownik nie powinien być uwzględniony na liście
::----------------------------------------------------------------------------------------------------------------------
_pomCp:={? var_pres('_a')=type_of(0) || _a || ~~ ?};
_test:=exec('czy_prac','lista_plac',_pomCp);
_start:=date(O.R,O.M,1);
_stop:=date(O.R,O.M,0);
_krajO:=O.KRAJE;

{? _test & _krajO<>null() & PAR_SKID.get(261)='T'
|| _test:=0;
   H.cntx_psh();
   H.index('_HISTDAT');
   H.prefix(P.ref());
   {? H.find_le(_stop) & (H.DO>=_start | H.DO=date(0,0,0))
   || H_ODDE.cntx_psh();
      H_ODDE.use('h_odde'+(H.name()+1));
      H_ODDE.index('HOD');
::    Idziemy po przebiegach wstecz:
      {!
      |? {? H.ODDEL='T'
         || H_ODDE.prefix(H.ref());
::          Teoretycznie oddelegowania powinny "wypełniać" przebieg, ale dla pewności sprawdzamy czy ostatnie
::          oddelegowanie trwa w miesiącu listy:
            {? H_ODDE.last() & H_ODDE.O_DO>=_start
::             Idziemy po oddelegowaniach wstecz:
            || {!
               |? _test:=(H_ODDE.KRAJ=_krajO);

                  ~_test & H_ODDE.prev() & H_ODDE.O_DO>=_start
               !}
            ?}
         ?};

         ~_test & H.prev() & H.DO>=_start
      !};
      H_ODDE.cntx_pop()
   ?};
   H.cntx_pop()
?};

_test


\jest_korn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RN [23.25]
:: OPIS: Sprawdza, czy lista jest uwzględniana w korektach ZUS.
::   WE: _a [STRING] - wskazanie symbolu listy płac
::   WY: 1 - tak
::       0 - nie
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_lista:=~_a;
_firma:=exec('firma','ustawienia');
_TMP:=sql('select KORN.LT from KORN join P using (KORN.P,P.REFERENCE) '
          'where KORN.LT=\':_a\' and P.FIRMA=:_b',
          _lista,_firma
         );
{? type_of(_TMP)<>type_of(SYSLOG)
|| _result:=1
?};
{? _TMP.first()
|| _result:=1
?};
_result

:Sign Version 2.0 jowisz:1045 2024/02/07 10:15:00 21d3d5da81ad348faadeaeca6fd8ca9552392ddcb945519e9ba1957fca41bc8f43f08138b7b4aac9ff0e3c4537251d74653f7f6eb5c3a11435ddc5a3410d20d9920c2f0f100ec3deace75bbc78b3d7b3f438b0f84228f6008ba364a1a898677545baa880e995398fb52fbfbcb4ff251b37f7515ddc90ab0e14bfd768a42ba867
