:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: podpis.fml
:: Utworzony: 2017/02/16
:: Autor: TMR
:: Systemy: KALI
::======================================================================================================================
:: Zawartosc: obsługa podpisów odręcznych użytkownika
::======================================================================================================================


\decl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Funkcja definiująca klasę PODPIS
::   WE:
::   WY:
:: ~OST: INFEXISTS, INFILECHOOSER
::----------------------------------------------------------------------------------------------------------------------
:: definiuje klasę PODPIS dla obsługi wyboru pliku z odręcznym podpisem użytkownika
_cl_name:='PODPIS';
:: wymagany inDevice do złożenia podpisu
{? var_pres(_cl_name,@.CLASS)<=0
||
   obj_decl(_cl_name,
:: - - - - - - - - - - - - - P O L A - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:: login użytkownika
      obj_fld('login',OPERATOR.USER().KOD),

:: nazwa pliku z podpisem ogólnym
      obj_fld('fName','podpis'),

:: drugi człon nazwy pliku z podpisem - rodzaj - wykorzystywany np. w imirze
:: jeżli podamy rodzaj 'imir' to będzie wyszukiwany plik 'podpis_imir.png'
      obj_fld('fKind',''),

:: tabela z możliwymi nazwami plików jakie będą uwzględniane podczas wyszukiwania podpisu
      obj_fld('tabFiles',null()),

:: rozszerzenia pliku z podpisem (.bmp, .png)
      obj_fld('fExt','png,bmp'),

:: wybrana ścieżka do pliku z podpisem
      obj_fld('currFile',''),

:: obiekt związany z katalogiem tymczasowym dla pliku z podpisem (inTerm)
      obj_fld('destObj',''),

:: wybrana ścieżka do pliku z podpisem (inTerm)
      obj_fld('dest',''),

:: separator katalogów na serwerze
      obj_fld('dirSep'    ,'\\' ),

:: separator katalogów na końcówce
      obj_fld('dirSepK'   ,'\\' ),

::    nazwa w profilu użytkownika potrzebna do określenia katalogu
      obj_fld('PNGnameD','lokalny katalog z plikiem podpisu odręcznego - png'),

::    nazwa w profilu użytkownika potrzebna do określenia pliku
      obj_fld('PNGnameF','lokalny plik z podpisem odręcznym - png'),

::    nazwa w profilu użytkownika potrzebna do określenia katalogu
      obj_fld('BMPnameD','lokalny katalog z plikiem podpisu odręcznego - bmp'),

::    nazwa w profilu użytkownika potrzebna do określenia pliku
      obj_fld('BMPnameF','lokalny plik z podpisem odręcznym - bmp'),

:: - - - - - - - - - - - - - M E T O D Y - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      obj_meth('__init',"
         .tabIni();
         {? exec('interm','#system')
         || .destObj:=fmk_tmp_dir(0);
            .dest:=.destObj.get_path()
         ?};
         {? sys_name(1)<>'WINDOWS'
         || .dirSep:='/'
         ?};
         {? sys_name(0)<>'WINDOWS'
         || .dirSepK:='/'
         ?}
      "),

      obj_meth('tabIni',"
         .tabFiles:=tab_tmp(,'NAME','STRING[20]','Nazwa pliku');
         .addFKind('')
      "),

      obj_meth('addFKind',"
         .fKind:=_a;
         _kind:={? +.fKind || '_'+.fKind || '' ?};
         _ext:=spli_str(.fExt,',');
         {! _ind:=1..obj_len(_ext)
         |! .tabFiles.NAME:=.fName+_kind+'.'+_ext[_ind];
            {? ~(.tabFiles.find_rec())
            || .tabFiles.add()
            ?}
         !}
      ",type_of('')),

:: zwraca nazwę pliku z podpisem użytkownika na serwerze
      obj_meth('getFServ',"
         _ext:=_a;
         _file:='';
         _exist:=0;
::       najpierw sprawdzamy czy istnieje plik z określonym typem
         {? .tabFiles.first()
         || {!
            |? {? (_ext='' | ((.tabFiles.NAME+3)=_ext)) &
                  (.fKind='' | (.tabFiles.NAME*.fKind))
               || _exist:=fexists(.tabFiles.NAME,1)
               ?};
               ~_exist & .tabFiles.next()
            !};
            {? _exist
            || _file:=.tabFiles.NAME
            ?}
         ?};
::       jeżeli nie ma pliku dla określonego typu to sprawdzamy czy istnieje plik ogólny 'podpis.'
         {? .fKind<>'' & (~_exist) & .tabFiles.first()
         || {!
            |? {? (_ext='' | ((.tabFiles.NAME+3)=_ext)) & ~(.tabFiles.NAME*'_')
               || _exist:=fexists(.tabFiles.NAME,1)
               ?};
               ~_exist & .tabFiles.next()
            !};
            {? _exist
            || _file:=.tabFiles.NAME
            ?}
         ?};
         _file
      ",type_of('')),


:: sprawdza czy wskazano plik użytkownika na końcówce
      obj_meth('isOnLoc',"
         _ext:=_a;
         _name:={? _ext='png' || .PNGnameD |? _ext='bmp' || .BMPnameD || '' ?};
         _dir:=exec('get','#profile',,.login,_name);
         _name:={? _ext='png' || .PNGnameF |? _ext='bmp' || .BMPnameF || '' ?};
         _file:=exec('get','#profile',,.login,_name);
         {? _file=''
         || _kind:={? +.fKind || '_'+.fKind || '' ?};
            _file:='podpis'+_kind+'.'+{? +_ext || _ext || 'png' ?}
         || _file:={? (_file+3)=_ext || _file || '' ?}
         ?};

         {? ~exec('interm','#system') || fexists('@'+_dir+.dirSepK+_file,0) ?}


      ",type_of('')),

:: sprawdza czy istnieje plik z podpisem wogóle, czyli albo na serwerze, albo zostało wskazane miejsce na końcówce
      obj_meth('exist',"
         .exist('')
      "),

      obj_meth('exist',"
         _ext:=_a;
         .getFServ(_ext)<>'' | .isOnLoc(_ext)
      ",type_of('')),

:: wyświetla okno z wyborem pliku na końcówce. Zwraca napis będący ścieżką do pliku
      obj_meth('openFile',"
         _ext:=_a;
         _name:={? _ext='png' || .PNGnameD |? _ext='bmp' || .BMPnameD || '' ?};
         _dir:=exec('get','#profile',,.login,_name);
         _name:={? _ext='png' || .PNGnameF |? _ext='bmp' || .BMPnameF || '' ?};
         _file:=exec('get','#profile',,.login,_name);
         {? _file=''
         || _file:='podpis.'+{? +_ext || _ext || 'png' ?}
         || _file:={? -(_file+3)=_ext || _file || '' ?}
         ?};

         _png:='Pliki PNG (*.png)|*.png';
         _bmp:='Pliki BMP (*.bmp)|*.bmp';
         _mask:={? _ext='png'
                || _png
                |? _ext='bmp'
                || _bmp
                || _png+'|'+_bmp
                ?};
         _path:='';
         _inTerm:=exec('interm','#system');
         {? _inTerm
         || _plik:=dlg_upload(.dest+.dirSep,0,);
            {? _plik<>''
            || _pth:=_path:=.dest+.dirSep+_plik
            ?}
         || ctr_set('!application', 'filechooser','reset');
            ctr_set('!application', 'filechooser','setAcceptAllFileFilterUsed',0);
            ctr_set('!application','filechooser','setDialogTitle','Otwórz'@);
            ctr_set('!application','filechooser','addDefaultFilter',_mask,_ext);
            ctr_set('!application', 'filechooser','setMultiSelectionEnabled',0);
            ctr_set('!application', 'filechooser','setFileSelectionMode','FILES_ONLY');
            ctr_set('!application', 'filechooser','setCurrentDirectory',_dir);
            ctr_set('!application', 'filechooser','setSelectedFile',_file);
            {? ctr_call('!application', 'filechooser', 'showOpenDialog')
            || _path:=ctr_call('!application', 'filechooser','getSelectedFile');
               _pth:='@'+_path
            ?}
         ?};
         {? _path='' | (~fexists(_pth,0))
         || return('')
         || {? ~_inTerm
            || _dir:='';
               _tokens:=spli_str(_path,.dirSepK);
               _len:=obj_len(_tokens);
               {! _ind:=1..(_len-1)
               |! _dir+=_tokens[_ind]+.dirSepK
               !};
               _name:={? _ext='png' || .PNGnameD |? _ext='bmp' || .BMPnameD || '' ?};
               exec('set','#profile',,.login,_name,_dir);
               _name:={? _ext='png' || .PNGnameF |? _ext='bmp' || .BMPnameF || '' ?};
               exec('set','#profile',,.login,_name,_tokens[_len])
            ?};
            _path
         ?}

      "),

:: wyświetla pytanie z prośbą o wskazanie pliku
      obj_meth('ask4File',"
         .ask4File('',1,1,'')
      "),

      obj_meth('ask4File',"
         .ask4File(_a,1,1,'')
      ",type_of('')),

      obj_meth('ask4File',"
         _ext:=_a;
         _openDialog:=_b;
         _fullPath:=_c;
         .addFKind(_d);

::       zerujemy poprzedni wybór
         .currFile:='';
         _result:='';

::       sprawdzamy ustawienie parametru 331 odpowiedzialnego za określenie sposobu pposzukiwania pliku
         _par331:=exec('get_par','#parametr',331,2);
::       jeżeli funkcja działa bez wyświetlania dialogu a parametr 331 jest ustawiony na '?' to domyślnie pobieramy
::       plik z serwera (bez dioalogu z użytkownikiem)
         _answer:=1;
         {? _par331='?' & _openDialog
         || _answer:=FUN.choice('Którego pliku podpisu użyć?'@,1,'z Serwera'@,'plik Lokalny'@)
         |? _par331='L'
         || _answer:=2
         ?};

         {? _answer=1
::          pobieramy z serwera
         || _file:=.getFServ(_ext);
            {? _file<>''
            || {? (~_fullPath)
               || .currFile:=_file
               || .currFile:=pth_dir(_file)+.dirSep+_file
               ?};
               _result:=.currFile
            ?}
         |? _answer=2
::          pobieramy z komputera lokalnego
         || {? ~.isOnLoc(_ext) | _openDialog
            || _file:=.openFile(_ext);
               {? _file<>''
               || {? (~_fullPath) & fcopy({? exec('interm','#system') || '' ||'@'?}+._file,'podpisTmp.'+(_file+3),0,1,1)
                  || .currFile:='podpisTmp.'+(_file+3)
                  || .currFile:='@'+_file
                  ?};
                  _result:=.currFile
               ?}
            ?}
         ?};
         {? _result=''
         || FUN.info('Nie wskazano pliku lub brak pliku we wskazanej lokalizacji.\nPodpis nie zostanie dołączony.'@)
         ?};
         _result
      ",type_of(''),type_of(0),type_of(0),type_of(''))
   )
?};
~~


\exist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Sprawdza czy istnieje plik podpisu
::   WE: _a [STRING] - sprawdzane rozszerzenie pliku
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_ext:={? var_pres('_a')=type_of('') || _a || '' ?};

PODPIS.exist(_ext)


\ask4File
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Formuła do obsługi wyświetlania pytania z prośbą o wskazanie pliku z odręcznym podpisem
::   WE: _a [STRING]  - rozszerzenie pliku (domyślnie '')
::       _b [INTEGER] - czy wyświetlać okno z wyborem pliku, czy też spróbować po cichu wyszukać plik na serwerze
::       _c [INTEGER] - czy w polu currFile ustawiać samą nazwę pliku czy pełną jego ścieżkę
::                      (dla pełnej ścieżki dla pliku lokalnego doklejany jest znak @)
::   WY: ścieżka do pliku lub napis pusty
::----------------------------------------------------------------------------------------------------------------------
       _ext:={? var_pres('_a')=type_of('') || _a || '' ?};
_openDialog:={? var_pres('_b')=type_of(0)  || _b || 1  ?};
  _fullPath:={? var_pres('_c')=type_of(0)  || _c || 1  ?};
      _kind:={? var_pres('_d')=type_of('') || _d || '' ?};

PODPIS.ask4File(_ext,_openDialog,_fullPath,_kind)


\getFile
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Funckja zwraca napis określający aktualnie wybrany plik funkcją ask4File
::   WE:
::   WY: Napis lub ''
::----------------------------------------------------------------------------------------------------------------------
PODPIS.currFile


\example
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Przykład użycia klasy PODPIS
::   WE: _a [STRING]  - rozszerzenie pliku (domyślnie '')
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_ext:={? var_pres('_a')=type_of('') || _a || '' ?};

{? _ext<>'' & _ext<>'bmp' & _ext<>'png'
|| FUN.info('Błędne rozszerzenie pliku z podpisem: %1\nDopuszczale to: bmp, png'@[_ext])
||
:: wyświetlamy okno z pytaniem o podpis
   _file:=exec('ask4File','podpis',_ext,1);
:: po wyborze formuła zwraca pełną ścieżkę do pliku lub nazwę pliku (zgodnie z parametrami wywołania)
   _file;
:: wybrana pełna ścieżka do pliku lub nazwa zapamiętywana jest w obiekcie i może być odczytana przez wywołanie formuły:
   exec('getFile','podpis');
:: lub bezpośrednie sięgnięcie do pola obiektu
   PODPIS.currFile
?}


:Sign Version 2.0 jowisz:1045 2022/06/30 14:23:21 3eec9c50433f87dffa107a7cff21904167b1943e9db49ab3f01b8eedd41aa69dc973cf68e41b2d310361a1ad153bbc96f8c2093b3526d646b4cdc0caf98c3cd0fc16c099c8fd56075bc9c94f779b507c813162a6ae122e550f0016a29d5f25dc65ee433e4a89051af033cfdbecc6e6b1700eca69ada52eae618bf458a09de553
