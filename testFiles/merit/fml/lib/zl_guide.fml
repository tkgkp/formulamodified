:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: zl_guide.fml
:: Utworzony: 25.06.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Obsługa przewodników zleceń
::            Plik biblioteczny - wspólna obsługa dla czynności obszaru roboczego TTE_PZL
::======================================================================================================================


\env_guide
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca zmienną środowiskową do obsługi przewodników
::----------------------------------------------------------------------------------------------------------------------
_env:=obj_new('used','ilosc','zapisane','limit_end','DOC_REJ','zgh_actions','zgp_actions','WP');
_env.used:=0;
:: Do obsługi w oknie redakcji
_env.ilosc:=0;
_env.zapisane:=0;
_env.limit_end:=0;
:: Do sterowania redakcją pola ZGP.DOC_REJ
_env.DOC_REJ:='';
:: Akcje do usunięcia (wyszarzenia) w nagłówku przewodnika
_env.zgh_actions:=':';
:: Akcje do usunięcia (wyszarzenia) na pozycjach przewodnika
_env.zgp_actions:=':';
:: Zlecenie produkcyjne/warsztatowe
_env.WP:='P';
_env


\przewodniki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Selekcja nagłówków przewodników zlecenia
::       Kontekst wywołania - środowisko selektora zleceń
::   WE: [_a] - INTEGER - 0/[1] - podgląd czy redagowanie
::  OLD: \przewodn/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

set_help(exec('set_help','#help','TTE_PZL_DPRZ'));

_edit:=1;
{? var_pres('_a')=type_of(0)
|| _edit:=_a
?};

ZL.cntx_psh(); ZGH.cntx_psh();
ZL.prefix();
{? ZL.seek(_env.ZL)
||
   _wp:=ZL.TYP().WP;
   _rodzaj:=ZL.RODZAJ;

   {? ZL.STAT_T='N' & ZL.TYP().TECH='T' & _wp='P'
   || FUN.emsg('Niezatwierdzona technologia zlecenia, nie można redagować przewodników.'@)
   ||
      ZGH.clear();

      PFAZ.clear();
      PFAZ.f_set('KOD');
      FILTER.PFAZ:=0;
      exec('twrkplc_filter_all','zasoby');

      ZGH.win_edit('RED'+_wp);

      _sufix:='';
      {? _edit=0
      || _sufix:=' — '+'PODGLĄD'@
      ?};

::    Jedno okno wertowania nagłówków przewodników
      _grp:=ZGH.grp_make('Przewodniki zlecenia %1'@[VAR.A_ZLEC().SYM]+_sufix,,'#zghselect'+(-_wp),,,,,'html_maximized');
      _f_rfrsh:="
         _grayed:=params_exec('zgh_grayed','zl_guide');
         ZGH.actions_grayed('WER'+params_get().env.WP,_grayed);
         ~~
      ";
      ZGH.grp_sel(_grp,,'WER'+_wp,,_f_rfrsh,,,20,,,,,'maximized');
      exec('zgh_icons','zl_guide','WER'+_wp);
      ZGH.win_sel(_grp);

::    Zabieranie akcji dla ZGH
      _klawisze:=exec('zgh_actions','zl_guide',_edit);

      ZGH.fld_attr('ILWYK',2);

      {? _env.BUF_ZL.RODZAJ='Z'
      || ZGH.index('UID_VIEW');
         ZGH.prefix(_env.UID_ZL)
      || ZGH.index('ZLNR');
         ZGH.prefix(_env.ZL)
      ?};

      ZGH.actions('WER'+_wp,_klawisze.hide,_klawisze.default);
      ZGH.select();

      ZGH.f_clear();
      PFAZ.f_clear();
      TWRKPLC.f_clear()
   ?}
?};
ZL.cntx_pop(); ZGH.cntx_pop();
~~


\bl_nrprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: przed redakcją numeru przewodnika
::   WE: _a: 0 - podczas redakcji pola, 1 - wywoływane w innych przypadkach
::  OLD: \bl_nrprz/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0 || _a:=0 ?};
{? (ZGH.NRPRZ='')|(-menu_txt()='dołącz')
|| ZGH.cntx_psh();
   _sym:=ZGH.ZLEC().SYM+ZGH.ZLEC().TYP().SEP_PRZ;
   ZGH.clear();
   ZGH.index('NRPRZ');
   ZGH.prefix(_sym);
   _ile_prz:=ZGH.ZLEC().TYP().ILE_PRZ;
   {? ZGH.last()
   || _sym+=form((#(ZGH.NRPRZ+_ile_prz))+1,-_ile_prz,0,'9')
   || _sym+=form(1,-_ile_prz,0,'9')
   ?};
   ZGH.cntx_pop();
   {? _a=0
   || fld(_sym);
      win_disp();
      0
  || _sym
  ?}
|| {? _a=0
   || 0
   || ''
   ?}
?}


\zgh_zlim_nact
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Sprawdza, czy do przewodnika są wystawione, ale niezaakceptowane limity (zlecenie otwarte)
::       albo główne limity są zaakceptowane (zlecenie w przygotowaniu)
::       Użyte w formule przed redagowaniem pola ZGH.ILNPRZ
::   WE: _a - ZGH.ref()
::   WY: 0 / 1 - są jakiekolwiek limity spełniające ww kryterium
::  OLD: \zgh_zlim_nact/zl_lim01.fml
::----------------------------------------------------------------------------------------------------------------------
_zgh:=_a;

Cntx.psh(ZGH,ZLIM,ZL);
Cntx.clr(ZGH        );

_res:=0;
{? ZGH.seek(_zgh)
|| {? ZGH.ZLEC().STAN='O'
   || ZLIM.index('ZGH_KM');
      ZLIM.prefix(_zgh,'T');
      {? ZLIM.first()
      || {!
         |? {? ZLIM.AKC='N'
            || Cntx.pop(ZGH,ZLIM,ZL);
               return(1)
            ?};
            ZLIM.next()
         !}
      ?}
   |? ZGH.ZLEC().STAN='N'
   || ZLIM.index('ZGH_KM');
      ZLIM.prefix(_zgh,'T');
      {? ZLIM.first()
      || {!
         |? {? ZLIM.AKC='T'
            || Cntx.pop(ZGH,ZLIM,ZL);
               return(1)
            ?};
            ZLIM.next()
         !}
      ?}
   ?}
||
   _res:=1
?};

Cntx.pop(ZGH,ZLIM,ZL);
_res


\zgh_can_mod
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy można zmienić ilość na przewodniku
::   WE: _a - ZGH.ref();
::       _b - REAL - współczynnik zmniejszenia ilości na przewodniku
::   WY: 0 - nie można zmniejszyć ilości na przewodniku
::       1 - można zmniejszyć ilość na przewodniku
::  OLD: \zgh_can_mod/zparn.fml
::----------------------------------------------------------------------------------------------------------------------
_zgh:=_a;
_coef:=_b;

_result:=1;
_can_continue:=1;

ZL.cntx_psh();
ZGH.cntx_psh(); ZGH.clear();

{? ZGH.seek(_zgh)
||
   ZGP.cntx_psh();
   {? ZGH.ZLEC().GENPRZEW='N'
   || ZGP.index('NRPP')
   || ZGP.index('PNRPP')
   ?};
   ZGP.prefix(ZGH.ref(),'N');
   {? ZGP.first()
   || {!
      |?
         _il_przew:=ZGP.NRZLP().ILNPRZ;
         _il_new:=_il_przew*_coef;
         _il_part:=exec('zgh_ile_part','zl_partie',ZGP.NRZLP);
         {? _il_part>_il_new
         || _can_continue:=0;
            _result:=0
         ?};
         _can_continue>0 & ZGP.next()
     !}
   ?};
   ZGP.cntx_pop()
?};
ZGH.cntx_pop();
ZL.cntx_pop();
_result


\pprz_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Lista przewodników zleceń podrzędnych powiązanych z danym przewodnikiem nadrzędnym
::   WE: _a - ZGH.ref()
::   WY: tabela o schemacie REF,NRPRZ
::  OLD: \pprz_tab/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_zgh:=_a;

_zghp:=sql('
   select distinct
   ZGH.REFERENCE as REF,
   ZGH.NRPRZ
   from ZGP join ZGH using(ZGP.NRZLP,ZGH.REFERENCE)
   where ZGP.NRPRZ=:_a
',_zgh);

::exec('select','libfml',_zghp);
_zghp


\zgh_actions
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ustala usuwane akcje w oknach ZGH
::       Kontekst wywołania - rekord ZGH i zlecenie ustawione w środowisku _env.ZL
::       [_a] - INTEGER - 0/[1] - 1 - akcje dostępne z normalnymi ograniczeniami
::                                0 - wszystkie akcje niedostępne
:: UWAGA: zmodyfikować jeszcze exec('zg_actions','zl_guid') - wyczyścić ustawienia dla ZGH
::  OLD: \zghx_actions/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
:: Dostępne akcje: Dołącz, Popraw, Usuń, pozyCje, parTie, Generuj, Oddany, Harmonogram,
::                 diagRam, limitY, nielimitoWane, rEjestracja, Zakończ,
::                 Funkcje|Wykorzystanie zasobów, Funkcje|Numeruj, drukuJ, Legenda
{? VAR.ZGH_ALL>0
|| _zl:=ZL.ref()
|| _env:=params_get().env;
   _zl:=_env.ZL
?};

_edit:=1;
{? var_pres('_a')=type_of(0)
|| _edit:=_a
?};
_hide:=':';
_default:='C:G';

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
||
   _wp:=ZL.TYP().WP;
   {? _edit>0
   ||
::    Zlecenia warsztatowe zawsze bez generowania i bez surowców nielimitowanych
      {? _wp='W' || _hide:='GWB'+_hide+'G'; _default:='C:D' ?};

::    Złożone i niezależne - bez dołączania
      {? ZL.RODZAJ<>'P' || _hide:='dD'+_hide+'dD' ?};

::    Jeżeli zlecenie złożone to dopuszczam akcję Generuj
:     {? ZL.RODZAJ='Z' || _hide:=gsub(_hide,'G','') ?};
      ~~
   || _hide:='DPUTGOÓYWBZF:DG'
   ?};
   ~~
?};
ZL.cntx_pop();

_res:=obj_new('hide','default');
_res.hide:=_hide;
_res.default:=_default;
_res


\ile
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2006]
:: OPIS: Propozycja na ile generowany powinien być przewodnik
::   WE: _a: ZL.ref()
::       _b: REAL - ilość na zleceniu
::  OLD: \ile/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_wynik:=0;
ZL.cntx_psh();
ZGH.cntx_psh();
ZGH.index('ZLNR');
ZGH.prefix(_a);
{? ZGH.first()
|| {!
   |? _wynik+=ZGH.ILNPRZ;
      ZGH.next()
   !}
?};
ZGH.cntx_pop();
ZL.cntx_pop();
{? _b>=_wynik
|| _wynik:=_b-_wynik
|| _wynik:=0
?};
_wynik


\seria
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca serię optymalną dla podanej karty technologicznej, o ile parametr
::   WE: _a - TKTL.ref() - karta technologiczna
::       _b - REAL - ilość oryginalna
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
_ile:=_b;

_result:=_ile;

_par:=exec('get','#params',500104);

_seria:=exec('FindAndGet','#table',TKTL,_tktl,,"SERIA",0);

{? _par='S' & _seria>0
|| _result:=_seria
?};
_result


\seria_koop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2009+]
:: OPIS: wyliczenie proponowanej serii produkcyjnej - do kontroli ilości na przewodniku, gdy zawiera operacje zewnętrzne
::   WE: _a: Ile do wygenerowania
::   WY: wyliczona seria
::  OLD: \seria/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
exec('tktl_cntx_psh','tech_common');
_ndx:=TOPER.ndx_tmp(,1,'WEW',,,'NRK',,);
TOPER.index(_ndx);
TOPER.prefix('N',VAR.A_KTL);
{? TOPER.first()
|| {!
   |? {? TOPER.DAYS_K=0
      || TOPER.next()
      || _result:=VAR.A_KTL().XJM;
         {? _result>_a
         || _result:=_a
         ?};
         0
      ?}
   !}
?};
TOPER.ndx_drop(_ndx);
exec('tktl_cntx_pop','tech_common');
_result


\wolne_numery
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Sprawdza, czy dla wskazanego zlecenia są jeszcze wolne numery dla przewodników
::       Wolne numery muszą być za ostatnim przewodnikiem wg numeracji ograniczone ilością znaków na numerację
::   WE: _a - ZL.ref()
::   WY: 0 albo ilość wolnych numerów
::  OLD: \wolne_numery/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(ZL,ZGH);

ZL.clear();
{? ZL.seek(_a)
||
   ZGH.index('NRPRZ');
   ZGH.prefix(ZL.SYM+ZL.TYP().SEP_PRZ);
   _ile_prz:=ZL.TYP().ILE_PRZ;
   _pula:=pow(10,_ile_prz);
   {? ZGH.last()
   || _nr:=(#(ZGH.NRPRZ+_ile_prz))+1;
      _wolne:={? _nr<_pula || _pula-_nr || 0 ?}
   || _wolne:=_pula-1
   ?}
||
   _wolne:=0
?};

Cntx.pop(ZL,ZGH);
_wolne


\zgh_pxed
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy przewodnik znajduje się w planie strategicznym tzn czy jakakolwiek jego pozycja
::       znajduje się w planie strategicznym (w jakiejkolwiek wersji)
::   WE: _a - ZGH.ref()
::   WY: 0 - przewodnik nie znajduje się w planie
::       1 - znajduje się
::  OLD: \zgh_pxed/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
_zgh:=_a;

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
ZGH.cntx_psh(); ZGH.clear();
ZGP.cntx_psh();

{? ZGH.seek(_zgh)
||
:: Podczytuje zlecenie
   ZGH.ZLEC();
   {? ZL.NRNZL<>0 | ZL.RODZAJ='P'
   || ZGP.index('PNRPP');
      ZGP.prefix(ZGH.ref());
      {? ZGP.first()
      || {!
         |? {? ZGP.PX_STAGE<>null()
            ||
               {? exec('used_in_plan','px_stage',ZGP.PX_STAGE)>0
               || _result:=1;
                  _can_continue:=0
               ?}
            ?};
            ZGP.next() & _can_continue>0
         !}
      ?}
   || ZGP.index('NRPP');
      ZGP.prefix(ZGH.ref());
      {? ZGP.first()
      || {!
         |? {? ZGP.PX_STAGE<>null()
            ||
               {? exec('used_in_plan','px_stage',ZGP.PX_STAGE)>0
               || _result:=1;
                  _can_continue:=0
               ?}
            ?};
            ZGP.next() & _can_continue>0
         !}
      ?}
   ?}
?};

ZGH.cntx_pop();
ZGP.cntx_pop();
ZL.cntx_pop();
_result


\gray_renumber
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Warunek wyszarzenia pozycji 'przenumeruj' w menu przewodnika
::       Kontekst wywołania - aktualny rekord ZGH
::  OLD: \gray_renumber/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
_res:=1;
{? ZGH.ref()<>null()
|| _res:=~(ZGH.ZLEC().NRNZL=0 & ZL.RODZAJ='P')
?};
ZL.cntx_pop();
_res


\graph_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Wyswietla graf operacji przewodnika
::  OLD: \graph_zgp/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('dia_zgp','zl_guide',1);
~~


\dia_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Tworzy graf (diagram) operacji przewodnika
::   WE: [_a] - 0 / 1 - czy wyświetlać diagram (domyślnie = 1)
::  OLD: \dia_zgp/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? _<1 || _display:=1 || _display:=_a ?};

:: Zakładamy że ZL jest we właściwym kontekście
ZGP.cntx_psh();
ZGH.cntx_psh();
ZL.cntx_psh();
TKTL.cntx_psh();
NASZGP.cntx_psh();

:: to jeśli nie w rekurencji
_name:='dot1';
_name_dot:=_name+'.dot';
_pth_dot:=pth_dir(_name_dot);
_handle:=fopen(_pth_dot+{? sys_name(1)='WINDOWS'||'\\'||'/'?}+_name_dot,'w');

{? _handle>0
||
:: to jeśli nie w rekurencji
   fwrite(_handle,'digraph zgp {');
   fwrite(_handle,' size="40,40";');
   fwrite(_handle,' rankdir=TB;');
   fwrite(_handle,' node [shape=Mrecord, style=filled, fillcolor="#F5F5F5"];');


:: odtąd w rekurencji
   VAR_DEL.delete('__nodes');
   __nodes:=tab_tmp(1,'NAME','STRING[255]','Numer węzła','NR','INTEGER','Nr');
   _chains:=tab_tmp(1,'NAME','STRING[255]','Powiązanie','OPER','INTEGER','Oper','NRNAST','INTEGER','Nast');
::   _ind:=TAB.ndx_tmp(,1,'TAB',,);
   __ndind:=__nodes.ndx_tmp(,1,'NR',,);
   _chsind:=_chains.ndx_tmp(,1,'OPER',,,'NRNAST',,);
   __nodes.index(__ndind);
   _chains.index(_chsind);

::   __nodes:=tab_tmp(1,'NAME','STRING[255]','Numer węzła');
::   _chains:=tab_tmp(1,'NAME','STRING[255]','Powiązanie');

   ZGP.cntx_psh();
   ZGP.clear();
   {? ZL.NRNZL<>0
   || _pod:=1;ZGP.index('PNRPP')
   || _pod:=0;ZGP.index('NRPP')
   ?};
   ZGP.prefix(ZGH.ref(),'N');

   {? ZGP.first()
   || VAR.A_NRPRZ:=ZGP.NRPRZ;
      {? ZL.NRNZL<>0
      || VAR.A_NRZLP:=ZGH.ref()
      ?}
   || VAR.A_ZGP:=null();
      {? ZL.NRNZL<>0
      || ZGH.cntx_psh();
         ZGH.index('ZLNR');
         ZGH.prefix(VAR.A_ZLNAD);
         {? ZGH.first() || _zgh:=ZGH.ref() || _zgh:=null() ?};
         ZGH.cntx_pop();
         VAR.A_NRPRZ:=_zgh;
         VAR.A_NRZLP:=ZGH.ref()
      || VAR.A_NRPRZ:=ZGH.ref()
      ?}
   ?};

::   ZGH.clear();
   {? ZGP.first()
   ||
      _wp:=ZL.TYP().WP;
      fwrite(_handle,maz_utf8('00000 [shape=box style=filled fillcolor=white '
      +'label='
      +'<\n<TABLE CELLPADDING="10" CELLSPACING="0" BORDER="1">'
      +exec('gen_tabline4','#graph','Zlecenie '+{? _wp='P' || 'produkcyjne' || 'warsztatowe' ?},'c','#EAEAEA',2)
      +{? _wp='P' || exec('gen_tabline','#graph','Symbol wyrobu:','r','#EAEAEA',ZL.KTM().KTM,'l','') || '' ?}
      +{? _wp='P' || exec('gen_tabline','#graph','Nazwa wyrobu:','r','#EAEAEA',ZL.KTM().N,'l','') || '' ?}
      +exec('gen_tabline','#graph','Nr zlecenia:','r','#EAEAEA',ZL.SYM,'l','')
      +'</TABLE>\n>'
      +' ]; '));
:: rysujemy ramkę technologii tylko dla zleceń które mogą mieć technologie
      {? (ZL.TYP().WP='P') & (ZL.RKTL<>'')
      ||
         _nrk:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,"NRK",'');
         _opis:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,"OPIS",'');
         _wer:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,"WER",'');
         fwrite(_handle,maz_utf8('proto00000 [shape=box style=filled fillcolor=white '
         +'label='
         +'<\n<TABLE CELLPADDING="3" CELLSPACING="0" BORDER="1">'
         +exec('gen_tabline4','#graph','Technologia źródłowa','c','#EAEAEA',2)
         +exec('gen_tabline','#graph','Symbol:','r','#EAEAEA',_nrk,'l','')
         +exec('gen_tabline','#graph','Nazwa:','r','#EAEAEA',_opis,'l','')
         +exec('gen_tabline','#graph','Wersja:','r','#EAEAEA',_wer,'l','')
         +'</TABLE>\n>'
         +' ]; '));
         fwrite(_handle,'proto00000 -> 00000 [color="#58585A", arrowsize=0.6];')
      ?};
      {! |?
         ZGH.cntx_psh();
         NASZGP.clear();
:: Powiązania do następników
         NASZGP.index('OPNAST');
         NASZGP.prefix(ZGP.ref());
         {? NASZGP.first()
         || {! |?
               exec('add_node','zl_guide',NASZGP.OPER);
               exec('add_node','zl_guide',NASZGP.NRNAST);
               _myname:=$#NASZGP.OPER+'->'+$#NASZGP.NRNAST;
::               _chains.prefix(_myname);
               _chains.clear();
               _chains.prefix(#NASZGP.OPER,#NASZGP.NRNAST);
               {? ~_chains.first()
               ||
                  _chains.OPER:=#NASZGP.OPER;
                  _chains.NRNAST:=#NASZGP.NRNAST;
                  _chains.NAME:=_myname;
                  _chains.add()
               ?};
               NASZGP.next()
            !}
         ?};
:: Powiązania do poprzedników
         NASZGP.clear();
         NASZGP.index('NASTOP');
         NASZGP.prefix(ZGP.ref());
         {? NASZGP.first()
         || {! |?
               exec('add_node','zl_guide',NASZGP.OPER);
               exec('add_node','zl_guide',NASZGP.NRNAST);
::               msg($NASZGP.OPER().NRP);
               _te:=sql('select * from NASZGP where NASZGP.NRNAST=:_a',NASZGP.OPER);
               {? (_te.first()=0)
               ||
                  fwrite(_handle,'00000 -> '+$#NASZGP.OPER+' [color="#58585A", arrowsize=0.6];')
               ?};
               obj_del(_te);
               _myname:=$#NASZGP.OPER+'->'+$#NASZGP.NRNAST;
::               _chains.prefix(_myname);
               _chains.clear();
               _chains.prefix(#NASZGP.OPER,#NASZGP.NRNAST);
               {? ~_chains.first()
               ||
                  _chains.OPER:=#NASZGP.OPER;
                  _chains.NRNAST:=#NASZGP.NRNAST;
                  _chains.NAME:=_myname;
                  _chains.add()
               ?};
               NASZGP.next()
            !}
         ?};
         ZGH.cntx_pop();
         ZGP.next()
      !}
   ?};

   ZGP.cntx_pop();

   __nodes.clear();
   {? __nodes.first()
   || {! |?
         fwrite(_handle,maz_utf8(__nodes.NAME));
         __nodes.next()
      !}
   ?};

   __nodes.ndx_drop();
   _chains.ndx_drop();

   obj_del(__nodes);

   _chains.clear();
   {? _chains.first()
   || {! |?
         fwrite(_handle,maz_utf8(_chains.NAME)+' [color="#58585A", arrowsize=0.6];');
         _chains.next()
      !}
   ?};
:: tutaj wychodzić z rekurencji
   fwrite(_handle,'}');
   fclose(_handle);

   _zgh_sym:=gsub(ZGH.NRPRZ,'/','_');
   _zgh_sym:=gsub(_zgh_sym,'\\','_');
   _file_download:='diagram_%1.png'[_zgh_sym];
   {? exec('run','#graph',_file_download,_name,1,'png')
   || ZGH.bl_put('DIAG_OP',_name+'.png',1)
   ?}
?};
NASZGP.cntx_pop();
ZGP.cntx_pop();
ZGH.cntx_pop();
ZL.cntx_pop();
TKTL.cntx_pop();
~~


\add_node
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Dodaje wpis do tabeli z węzłami grafu przewodnika
::   WE: _a - ZGP.ref()
::  OLD: \add_node/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
ZGP.cntx_psh(); ZGH.cntx_psh();
ZGP.clear();
{? ZGP.seek(_a)
||
   _myname:=
      $#ZGP.ref()+' [label="'+
      $ZGP.NRP+'|'+ZGP.NRZLP().NRPRZ+
      '\\n'+exec('txt_just','#graph',ZGP.OPIS,20,1)+
      {? ZGP.STARTD<>date(0,0,0)
      ||
         '\\n'+
         $ZGP.STARTD+' '+$ZGP.STARTT+
         '\\n'+$ZGP.ENDD+' '+$ZGP.ENDT
      ||
         ''
      ?}+
      '"];';
:   __nodes.prefix(_myname);
   __nodes.clear();
   __nodes.prefix(#ZGP.ref());
   {? ~__nodes.first()
   || __nodes.NAME:=_myname;
      __nodes.NR:=#ZGP.ref();
      __nodes.add()
   ?};
   __nodes.add()
?};
ZGP.cntx_pop(); ZGH.cntx_pop();
~~


\drukzgp
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: wydruk przewodnika
::  OLD: \drukzgp/drukujp.fml
::----------------------------------------------------------------------------------------------------------------------
exec('rep_exec','#b_report','TTE_PZL_XXXX','tte_zgp*','Wydruki przewodników',1);
1


\legenda_h
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Legenda w oknie ZGH
::  OLD: \legenda_h/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.ZGH_ALL>0
|| exec('legenda','color','ZGH#01#','@ZGH#START','@ZGH#END','#ZGH#01','#ZGH#02','#ZGH#03','#ZL#03','#ZL#05')
|| exec('legenda','color','ZGH#01#','@ZGH#START','@ZGH#END','#ZGH#01','#ZGH#02')
?}


\rkprz_zgh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2010]
:: OPIS: 'Rekord przed' w oknach wertowania tabeli ZGH
::  OLD: \rkprz_zgh/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('rekprzed','color','ZGH#01#01')


\zgh_rkprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.40] kolorowanie
:: OPIS: przed rekord w oknach nagłówków przewodników
::  OLD: \zgh_rkprz/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZGH.STAN='T'
|| 'ZGH#01#01'
|? ZGH.STAN='K'
|| 'ZGH#01#02'
|| ''
?}


\porec_zgh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Po redakcji przewodnika dla zlecenia -
::       sprawdza możliwość zastosowania zmian,
::       wpisuje odpowiednie notatki do dziennika zlecenia
::   WY: '' / akronim pola, do którego należy powrócić
::  OLD: \porec_zgh/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env_guide:=params_get().env_guide;

_start:=exec('create','#tm_stamp',ZGH.STARTD,ZGH.STARTT);
_end:=exec('create','#tm_stamp',ZGH.ENDD,ZGH.ENDT);

{? _start>_end
|| FUN.emsg('Koniec operacji nie może być wcześniejszy niż początek.'@);
   return('ENDD')
?};

:: Przy dołączaniu nic więcej nie jest sprawdzane
{? menu_txt()='Dołącz' || return('') ?};

_res:='';
{? ZL.STAN='O' | ZL.STAN='N'
||
   KOMM.init(,,'Modyfikacja przewodnika'@);
   _update:=0;
   ZL.cntx_psh();
   _update:=(ZL.NRNZL<>0 & ((ZL.NR=1 & VAR.A_ZLNAD().RODZAJ='Z') | VAR.A_ZLNAD().RODZAJ='N'));
   ZL.cntx_pop();
   {? _env_guide.ilosc>ZGH.ILNPRZ
   ||
::    Sprawdzam czy można zmienić ilość ze względu na partie
      {? _res=''
      || _part_allow:=exec('zgh_can_mod','zl_guide',ZGH.ref(),ZGH.ILNPRZ/_env_guide.ilosc);
         {? _part_allow=0
         || FUN.emsg('Ilość na przewodnikach nie może być mniejsza niż na powiązanych z nim partiach.'@);
            _res:='ILNPRZ'
         ?}
      ?};

      {? _res=''
      ||
         _il:=exec('max_akord','zl_guide',ZGH.ref());
         {? _il>ZGH.ILNPRZ
         || FUN.info(
               'Zmniejszenie ilości do podanej wartości nie jest możliwe.\n'
               'Minimalna ilość jaką można wpisać: %1.'@[form(_il)]
            );
            _res:='ILNPRZ'
         ||
::            {? ZL.STAN='O'
::            || exec('add_mod_pos','zl_common','mr','Modyfikacja ilości na przewodniku z: '+form(_env_guide.ilosc)+ ' na ' +form(ZGH.ILNPRZ))
::            ?};
::            {? _update | ZGH.ZLEC().TYP().RODZAJ='O'
::            || exec('nprz_upd','zl_guide')
::            ?};
::            exec('mod_poz','zl_guide',ZGH.ILNPRZ/_env_guide.ilosc,ZGH.ILNPRZ)
            ~~
         ?}
      ?};

:: TODO:
::    Teraz muszę poprawić jeszcze przewodniki dla zleceń podrzędnych, o ile dostępne
::      {? _res=''
::      || {? ZGH.ZLEC().GENPRZEW='N'
::         || exec('pprz_upd','zl_guide',ZGH.ref(),ZGH.ILNPRZ/_env_guide.ilosc)
::         ?}
::      ?}
      ~~

   |? _env_guide.ilosc<>ZGH.ILNPRZ
   || {? var_pres('zghn') > 0
      || _il_zgh:=ZGH.ILNPRZ;
         _zgh:=ZGH.ref();
         ZGH.cntx_psh();
         ZGH.index('ZLNR');
         ZGH.prefix(VAR.A_ZLEC);
         {? ZGH.first()
         || {!
            |? {? ZGH.ref()<>_zgh
               || _il_zgh+=ZGH.ILNPRZ
               ?};
               ZGH.next()
            !}
         ?};
         ZGH.cntx_pop();
        {? _il_zgh>ZL.IL
        || FUN.emsg('Ilość na przewodnikach nie może być większa niż na zleceniu.'@);
           _res:='ILNPRZ'
        ?}
      ?}
   ?};

:: Aktualizacja limitów w zakładce, gdy jest wyświetlana
   {? _res=''
   || {? var_pres('__ZLIMp')>100
      || exec('__ZLIM_datapump','zl_limit',__ZLIMp)
      ?}
   ?};
   KOMM.select()
?};
_res


\max_akord
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MK [7.62]
:: OPIS: sprawdza ile max. akordu (ilości w kooperacji, braków) zostało zarejestrowane dla danego przewodnika
::   WE: _a - ZGH.ref()
::       [_b] - rodzaj zwracanej wartości: 0 (dla akordu - domyślnie), 1 (dla kooperacji), 2 (braki)
::   WY: maksymalna ilość produktu na pozycjach przewodnika
::  OLD: \max_akord/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')=type_of(0) || _kind:=_b || _kind:=0 ?};

_wynik:=0;

:: 1. agregacja wg UID operacji
_zgp:=tab_tmp(1,
   'UID','STRING[15]','Unikalny identyfikator operacji',
   'IL','REAL','Ilość zarejestrowana',
   'IL_KOOP','REAL','Ilość w kooperacji',
   'IL_BRAK','REAL','Ilość braków'
);
_args:=exec('find_uid_a','zl_guide');
ZGP.cntx_psh();
ZGP.index('NRPP');
ZGP.prefix(_a);
{? ZGP.first()
|| {!
   |? _args.ZGP:=ZGP.ref();
      _args.BRAKIUID:=ZGP.BRAKIUID;
      _uid:=exec('find_uid','zl_guide',_args);
      _zgp.prefix(_uid);
      {? _zgp.first()
      || _zgp.IL_KOOP+=ZGP.IL_KOOP;
         _zgp.IL+=ZGP.IL;
         _zgp.IL_BRAK+=ZGP.IL_BRAK;
         _zgp.put()
      || _zgp.UID:=_uid;
         _zgp.IL_KOOP:=ZGP.IL_KOOP;
         _zgp.IL:=ZGP.IL;
         _zgp.IL_BRAK:=ZGP.IL_BRAK;
         _zgp.add()
      ?};
      ZGP.next()
   !}
?};
ZGP.cntx_pop();

:: 2. ustalenie maksimów
_zgp.prefix();
{? _zgp.first()
|| {!
   |? {? _kind=2
      || {? _zgp.IL_BRAK>_wynik || _wynik:=_zgp.IL_BRAK ?}
      |? _kind=1
      || {? _zgp.IL_KOOP>_wynik || _wynik:=_zgp.IL_KOOP ?}
      || {? _zgp.IL>_wynik || _wynik:=_zgp.IL ?}
      ?};
      _zgp.next()
   !}
?};

_wynik


\nprz_upd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2009]
:: OPIS: Zmienia ilość na przewodniku Zlecenia nadrzędnego po zmianie ilości
::       na zleceniu podrzędnym. Odwołuje się do akt. bufora tabel ZL i ZGH
::       Wywoływane od strony zl. podrz.
::   WE: _a - ref do obecnie modyfikowanego przewodnika (ważne gdy generacja od nadrzędnych)
::  OLD: \nprz_upd/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(ZL,ZGH,ZGP);

_zmien:=0;
ZL.cntx_psh();
_zmien:=(exec('top_rodzaj','zl_link',ZL.ref())='N');
ZL.cntx_pop();

:: ustawiamy bufor na pierwszym zl podrzednym
{? ~_zmien
|| {? ZL.NR<>1
   || ZL.index('NRNZL');
      ZL.prefix(ZL.NRNZL);
      ZL.first()
   ?}
?};
_ilnprz:=ZL.IL;

{? _ilnprz>-1 & exec('is_main_podzlec','zl_link',ZGH.ZLEC)>0
||
:: Ilość na przewodniku zlecenia nadrzędnego powinna być zaktualizowana tylko jeżeli
:: zlecenie na którym jest aktualizowana ilość jest zleceniem montażowym, w przeciwnym
:: wypadku to nie ma sensu ponieważ ilość na zleceniu podrzędnym na którym została poprawiona
:: ilość to jest zupełnie inna ilość niż na zleceniu montażowym

:: odnajdz odp. przewodnik zl. nadrz. i przypisz zliczona ilosc z podrzednych
   ZGP.index('PNRPP');
   ZGP.prefix(ZGH.ref());
   {? ZGP.first()
   ||
      ZGH.clear();
      {? ZGH.seek(ZGP.NRPRZ)
      || ZGH.ILNPRZ:=_ilnprz;
         ZGH.put()
      ?}
   ?}
?};
Cntx.pop(ZL,ZGH,ZGP);
~~


\pprz_upd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Naniesienie zmian ilości na przewodniki podrzędne powiązane z nadrzędnym zlecenia
::   WE: _a - ZGH.ref() - przewodnik zlecenia nadrzędnego
::       _b - współczynnik korekty
::  OLD: \pprz_upd/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_zgh:=_a;
_coef:=_b;

Cntx.psh(ZGH,ZGP);
Cntx.clr(ZGH,ZGP);

_zghp:=exec('pprz_tab','zl_guide',_zgh);
{? _zghp.first()
|| {!
   |? {? ZGH.seek(_zghp.REF)
      || ZGH.ILNPRZ:=ZGH.ILNPRZ*_coef;
         ZGH.put()
      ?};
      _zghp.next()
   !}
?};

Cntx.pop(ZGH,ZGP);
~~


\a_nrprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2010]
:: OPIS: Zwraca VAR.A_NRPRZ
::  OLD: \a_nrprz/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_NRPRZ


\tpz_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca ref operacji Tpz dla wskazanej operacji głównej na przewodniku
::   WE: _a - ZGP.ref()
::   WY: ZGP.ref()
::  OLD: \tpz_ref/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
ZGP.cntx_psh();
ZGP.clear();
{? ZGP.seek(_a)
|| ZGP.index('TPZ');
   ZGP.prefix('T',ZGP.UID);
   {? ZGP.first() || _ref:=ZGP.ref() ?}
?};
ZGP.cntx_pop();
_ref


\spr_akord
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: sprawdza czy dla danej pozycji przewodnika zostało cokolwiek zarejestrowane
::   WE: [_a] - ZGP.ref() albo bieżący rekord ZGP
::       [_b] - czy pomijać wykonania wygenerowane z operacji grupowej: [0] - nie, 1 - tak
::   WY: 1 - nie ma rejestracji, 0 - są rejestracje
::  OLD: \spr_akord/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
_skip_grop:={? var_press('_b')=type_of(0) || _b || 0 ?};
ZGP.cntx_psh();
ZGP.clear();
_dalej:={? var_pres('_a')=type_of(null()) || ZGP.seek(_a) || 1 ?};
{? _dalej
|| _zlgd:=exec('zlgd_zgp','zl_guide',ZGP.ref(),_skip_grop);
   _wynik:=~_zlgd.first();
   _zlgdtpz:=exec('zlgd_zgp','zl_guide',exec('tpz_ref','zl_guide',ZGP.ref()),_skip_grop);
   _wynik:=_wynik & ~_zlgdtpz.first()
|| _wynik:=1
?};
ZGP.cntx_pop();
_wynik


\zlgd_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Pobiera ZLGD powiązane z pozycją przewodnika
::   WE: _a - ZGP.ref()
::       [_b] - czy pomijać wykonania wygenerowane z operacji grupowej: [0] - nie, 1 - tak
::  OLD: \zlgd_zgp/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_skip_grop:={? var_press('_b')=type_of(0) || _b || 0 ?};
_zlgd:=sql('
   select ZLGD.REFERENCE as REF
   from @ZLGD
   where ZLGD.ZGP=:_a '+
   {? _skip_grop || ' and ZLGD.ZLGD_SRC=\'\' ' || ' ' ?}+
   'order by 1
',_a);

_zlgd


\zlgd_zgh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Pobiera ZLGD powiązane z przewodnikiem
::        posortowane wg pozycji, dla każdej najpierw operacja główna, potem Tpz
::   WE: _a - $ZGH.ref()
::  OLD: \zlgd_zgh/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_zlgd:=sql('
   select ZLGD.REFERENCE as REF, ZGP.NRP, ZGP.TPZ
   from @ZLGD left join ZGP using (ZLGD.ZGP, ZGP.REFERENCE)
   where ZLGD.ZGH=\':_a\'
   order by ZGP.NRP, ZGP.TPZ desc, 1
',_a);

_zlgd


\spr_kap
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: sprawdza czy dla danej pozycji przewodnika została wystawiona karta pracy
::   WE: [_a] - ZGP.ref() albo bieżący rekord ZGP
::   WY: 1 - nie ma karty pracy, 0 - są karty pracy
::  OLD: \spr_kap/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
ZGP.cntx_psh();
ZGP.clear();
_dalej:={? var_pres('_a')=type_of(null()) || ZGP.seek(_a) || 1 ?};
{? _dalej
|| _kap:=exec('kap_zgp','zl_guide',ZGP.ref());
   _wynik:=~_kap.first()
|| _wynik:=1
?};
ZGP.cntx_pop();
_wynik


\kap_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Pobiera KAP powiązane z pozycją przewodnika
::   WE: _a - ZGP.ref()
::  OLD: \kap_zgp/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_kap:=sql('
   select KAP.REFERENCE as REF
   from @KAP
   where KAP.ZGP=:_a
   order by 1
',_a);

_kap


\a_nrzlp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2010]
:: OPIS: Zwraca VAR.A_NRZLP
::   WY: VAR.A_NRZLP
::  OLD: \a_nrzlp/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_NRZLP


\status_new
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Status - nowa operacja, niedostępna do rejestracji - czerwona kłódka
::  OLD: \status_new/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
'N'


\status_pending
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Status - operacja wykonywana - zielona kłódka
::  OLD: \status_pending/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
'O'


\status_waiting
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Status - operacja czekajaca na wykonanie poprzedniej - zegarek
::  OLD: \status_waiting/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
'C'


\status_end
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Status - operacja wykonana - ptaszek
::  OLD: \status_end/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
'W'


\zgp_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MW [12.41]
:: OPIS: Zwraca VAR.A_NRPRZ().ZLEC
::  OLD: \zgp_zl/varget.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh(); ZGH.cntx_psh();
_res:=VAR.A_NRZLP().ZLEC;
ZL.cntx_pop(); ZGH.cntx_pop();
_res


\zgp_m
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MW [12.41]
:: OPIS: Zwraca VAR.A_NRPRZ().ZLEC().KTM
::  OLD: \zgp_m/varget.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh(); ZGH.cntx_psh();
_res:=VAR.A_NRZLP().ZLEC().KTM;
ZL.cntx_pop(); ZGH.cntx_pop();
_res


\mod_poz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2009]
:: OPIS: Skaluje pozycje przewodnika o zadaną wielkość.
::   WE: _a - współczynnik jakim skalowane są czasy na pozycjach przewodnika (nie skaluje operacji Tpz)
::       _b - docelowa ilość na przewodniku (do wyliczania norm limitów, gdy z TMAT)
::  OLD: \mod_poz/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
_coef:=_a;
_ilnprz:=_b;

_timedok:=exec('get','#params',500604,1);

ZGH.cntx_psh(); ZGP.cntx_psh();

ZGP.index('PNRPP');
ZGP.prefix(ZGH.ref());
{? ZGP.first()
|| {!
   |? {? ZGP.NAPRAW<>'T'
      || {? ZGP.TPZ='N' & ZGP.FIX_NORM<>'T'
         || ZGP.NTIME:=(ZGP.NTIME*_coef)$_timedok;
            ZGP.MTIME:=(ZGP.MTIME*_coef)$_timedok;
            ZGP.CENA:=(ZGP.CENA*_coef)$2;
            ZGP.PLNX:=(ZGP.PLNX*_coef)$2
         ?};
         ZGP.ILOSC:=_ilnprz;
         {? ZGP.put() & ZGP.TPZ='N'
         || exec('lim_kor_zgp','zl_limit',ZGP.ref(),_coef,_ilnprz*ZGP.NRZLP().ILNPRZ/ZGP.NRPRZ().ILNPRZ,,1)
         ?}
      ?};
      ZGP.next()
  !}
?};

ZGH.cntx_pop(); ZGP.cntx_pop();
~~


\przh_poz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: wyświetlanie pozycji przewodnika
::   WE: _a - 0, 1, 2 - wariant wyświetlania
::       [_b] - ZGP.ref() pozycji, na której ma się ustawić widok (dla kooperacji, operacji kontroli jakości)
::  OLD: \przh_poz/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

:: Sprawdzam czy przewodnik jeszcze żyje
{? ZGH.get()=0
|| FUN.info('Przewodnik został usunięty.'@);
   return('')
?};

set_help(exec('set_help','#help','TTE_PZL_DPRZ'));

{? _>=2 || {? type_of(_b)<>7 || _b:=null() ?} || _b:=null() ?};

_locked:=exec('blk_lock','#table','ZGH',ZGH.ref(),,1,'Przewodnik %1 jest redagowany'[ZGH.NRPRZ]);
{? _locked
||
   ZGH.cntx_psh();

   __Poz1:=__Poz2:=null();

:: okno wertowania pozycji przewodnika
   _sel:=exec('sel_poz','zl_guide',_a);
   {? ZGH.ZLEC().TYP().WP='W'
   || _sel:='WERZ'
   ?};

   exec('zgp_icons','zl_guide',_sel);

   _grp:=ZGP.grp_make('Pozycje przewodnika %1'@[ZGH.NRPRZ],,'#zgpwer'+(-_sel),,3,,,'html_maximized');
   _f_rfrsh:="
      _grayed:=':';
      {? ZGP.WEW='T' || _grayed:='O'+_grayed || _grayed:='F(P)'+_grayed ?};
      {? ~exec('zgp_utilization','po_plan',1,ZGP.ref()) || _grayed:='F(W)'+_grayed ?};
      ZGP.actions_grayed(cur_win(1,1),_grayed);
      ZGP.cntx_psh();
      grp_disp(NASZGP,'WER');
      grp_disp(NASZGP,'SLOPOP');
      ZGP.cntx_pop();
      ~~
   ";
   ZGP.grp_sel(_grp,,_sel,,_f_rfrsh,,0,15+{? _sel='SLO' | _sel='WER' || 3 || 0 ?},,,,,'maximized');
   ZGP.grp_splt(_grp,,'horizontal','poprzedniki',,'panel0');
   ZGP.grp_sel(_grp,NASZGP,'SLOPOP',,,,,5,"
      NASZGP.index('NASTOP');
      NASZGP.prefix(VAR.A_ZGP);
      NASZGP.seek(__Poz2);
      ZGP.cntx_psh();
      ~~
    ","
      __Poz2:=NASZGP.ref();
      ZGP.cntx_pop();
      ~~
    ",,,'maximized_with_title');
   ZGP.grp_splt(_grp,'poprzedniki','vertical','nastepniki',,'panel0');
   ZGP.grp_sel(_grp,NASZGP,'WER',,"
      {? params_get().env_guide.used || NASZGP.actions('WER','dpuDPUI:dDI',,1) ?}
   ",,,5,"
      NASZGP.index('OPNAST');
      NASZGP.prefix(VAR.A_ZGP);
      NASZGP.seek(__Poz1);
      ZGP.cntx_psh();
      ~~
    ","
      __Poz1:=NASZGP.ref();
      ZGP.cntx_pop();
      ~~
    ",,,'maximized_with_title');
   ZGP.win_sel(_grp);

   ZGP.actions(_sel,exec('zgp_actions','zl_guide'));

   {? ZGH.STAN='T' | exec('FindAndGet','#table',ZL,ZGH.ZLEC,,"STAN='Z'",0) | params_get().env_guide.used
   || NASZGP.actions('WER','dpuDPUI:dDI')
   |? exec('is_main_podzlec','zl_link',ZGH.ZLEC)
   || NASZGP.actions('WER','I:I')
   || NASZGP.actions('WER','')
   ?};

:: Renumeracja rekordow za pomoca d'n'd
   {? ZGH.STAN='T' | VAR.A_ZLEC().STAN='Z'
   || ZGP.dnd_sel(_sel,,'records.ZGP',"")
   || ZGP.dnd_sel(_sel,,'records.ZGP',"exec('dnd_renum','zl_guide')")
   ?};

   _widoki:=KHVZ.WIDOKI;
   KHVZ.WIDOKI:=0;

   {? _b<>null()
   || ZGP.seek(_b);
      ZGP.select(,1,-1)
   || ZGP.select(,)
   ?};

   KHVZ.WIDOKI:=_widoki;

:: Wyłączenie d'n'd
   ZGP.dnd_sel(_sel,,'records.ZGP',"");

   {? __Pod=1 || ZGP.NRZLP().ZLEC() || ZGP.NRPRZ().ZLEC() ?};
   ZGH.cntx_pop();
   ZGP.win_sel(_sel);
   &__Poz1; &__Poz2; &__Pod;

   exec('blk_unlock','#table','ZGH',ZGH.ref())
?};
''


\renum_args
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Argumenty dla funkcji renum
::   WY: obj_new - tablica nazwana
::  TAG: <PUBLICZNA>
::  OLD: \renum_args/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
:: Tryb numeracji:
::                'DND' - obsługa po drag'n'drop
::                'SPLIT' - obsługa po podziale przewodnika - nowy numer wymyślany na podstawie
::                          rekordu źródłowego (pole ZGP.UID_SRC)
::                'MERGE' - obsługa po scaleniu przewodnika, nowy numer wymyślany na podstawie starego
   'MODE'
:: Kierunek przesuwania dla akcji Przesuń
   ,'MOVE_DIR'
:: Tablica zawierająca pozycje przewodnika, stare i nowe numery, powiązania TPZ
   ,'TAB_ZGP'
:: Tablica zawierająca refy odwiedzonychc ZGPów (dla wywołań rekurencyjnych)
   ,'VISITED'
:: Czy wywołanie rekurencyjne
   ,'REC'
:: Pozycja przewodnika której nadawać numer
   ,'ZGP'
:: Zlecenie które było ostatnio obrabiane
   ,'ZLLAST'
:: Numer jaki nadać pozycji przewodnika w obrębie zlecenia
   ,'NRP_TAB'
:: Dla wywołań rekurencyjnym w trybie BRAKI - czy można zmieniać numer ZGPa
   ,'CAN_NRP'
:: Dla wywołań rekurencyjnym w trybie BRAKI - czy można uruchamiać rekurencyjnie dla poprzedników
   ,'CAN_REC'
:: Dla wywołań rekurencyjnych - połączenie (NASZGP) z którego przyszedłem
   ,'NAS_FROM'
:: Tablica zawierająca refy wszystkich połączeń którymi przeszedłem rekurencyjnie
   ,'NAS_TAB'
:: Metoda czyszcząca NRP_TAB i VISITED
   ,'clean'
);
_args.MODE:='DND';
_args.MOVE_DIR:='';
_args.TAB_ZGP:=tab_tmp(1,
   'REF','STRING[16]','$ZGP.ref()',
   'REF_TPZ','STRING[16]','$ZGP.ref() operacji Tpz',
   'NRP_OLD','INTEGER','stary ZGP.NRP',
   'NRP_NEW','INTEGER','nowy ZGP.NRP',
   'OPIS','STRING[100]','Nazwa operacji',
   'ZGH','STRING[16]','$ZGP.NRZLP'
);
_args.VISITED:=exec('ref_table','#table');
_args.REC:=0;
_args.ZGP:=null();
_args.NRP_TAB:=tab_tmp(1,
   'ZL','STRING[16]','$ZL.ref()',
   'NRP','INTEGER','Numer jaki nadać pozycji');
_args.CAN_NRP:=1;
_args.CAN_REC:=1;
_args.NAS_FROM:=null();
_args.NAS_TAB:=tab_tmp(2
   ,'ZGP_SRC','STRING[16]','$ZGP.ref()'
   ,'NASZGP','STRING[16]','$NASZGP.ref()'
);
_args.clean:="
   .VISITED.clean();
   .NRP_TAB.clear();
   {? .NRP_TAB.first()
   || {!
      |? _can_continue:=.NRP_TAB.del(,1);
         .NRP_TAB.first() & _can_continue>0
      !}
   ?};
   ~~
";
_args


\renum_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Funkcja wywoływana przed rozpoczęciem renumeracji pozycji przewodnika:
::       1. Zapamiętuje dotychczasowe numery
::       2. Przenumerowuje pozycje z bieżącej dziedziny w obszar wolnych numerów
::       3. Zmienia i zapamiętuje odnośniki dla TPZ
::
::       KONTEKST PRACY - zaprefiksowana dziedzina ZGP
::   WE: _a - obj_new() - argumenty funkcji przenumerowującej exec('renum_args','zl_guide')
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::  OLD: \renum_before/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_size:=ZGP.size();

_result:=0;
_can_continue:=1;

_zgp:=_args.TAB_ZGP;

ZGP.cntx_psh();
{? ZGP.first()
||
   _visited:=exec('ref_table','#table');
   _last_nr:=0;
   {? _args.MODE='SPLIT'
   || _last_nr:=ZGP.size()
   |? _args.MODE='BRAKI'
   || _last_nr:=ZGP.size()+1
   || ZGP.cntx_psh();
      {? ZGP.last()
      || _last_nr:=ZGP.NRP
      ?};
      ZGP.cntx_pop()
   ?};
   _last_nr+=1;
   {!
   |? _ref_nxt:=null();
      _next:=0;

      ZGP.cntx_psh();
      {? ZGP.next()
      || _ref_nxt:=ZGP.ref()
      ?};
      ZGP.cntx_pop();

      {? _visited.r_find(ZGP.ref())=0
      || _visited.add(ZGP.ref());

         _zgp.blank();
         _zgp.ZGH:=$ZGP.NRZLP;
         _zgp.REF:=$ZGP.ref();
         _zgp.NRP_OLD:=ZGP.NRP;
         _zgp.OPIS:=ZGP.OPIS;

         ZGP.cntx_psh();
         ZGP.index('TPZ');
         ZGP.prefix('T',ZGP.UID);
         {? ZGP.first()
         || _zgp.REF_TPZ:=$ZGP.ref();
::          ZGP.TPZREF:=_last_nr;
            ZGP.NRP:=_last_nr;
            ZGP.prefix();
            _can_continue:=ZGP.put()
         ?};
         ZGP.cntx_pop();

         {? _args.MODE='BRAKI'
         || ZGP.NRP:=_last_nr;
            _can_continue:=ZGP.put()
         ?};

         _last_nr+=1;

         _zgp.add();

         {? _ref_nxt<>null()
         || _next:=ZGP.seek(_ref_nxt)
         ?}
      || _next:=0
      ?};
      _next>0 & _can_continue>0
   !}
?};
ZGP.cntx_pop();
ZGP.get();
{? _can_continue>0
|| _result:=1
?};
_result


\renum_after
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Funkcja wywoływana po renumeracji pozycji przewodnika:
::       1. Poprawia NASZGP.SCIEZKA
::       2. Naprawia powiązania dla TPZ
::
::       KONTEKST PRACY - zaprefiksowana dziedzina ZGP
::   WE: _a - obj_new() - argumenty funkcji przenumerowującej exec('renum_args','zl_guide')
::       [_b] - ZGH.ref() - przewodnik którego pozycje aktualizować, jeśli nie podane to
::                          aktualizowana będzie cała dziedzina tabeli _args.TAB_ZGP
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::  OLD: \renum_after/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_zgh:=null();
{? var_pres('_b')=type_of(ZGH.ref())
|| _zgh:=ZGH.ref()
?};

_size:=ZGP.size();

_result:=0;
_can_continue:=1;

_zgp:=_args.TAB_ZGP;

ZGP.cntx_psh();
NASZGP.cntx_psh();

:: "poprawienie" NASZGP.SCIEZKA
{? ZGP.first()
|| {!
   |? NASZGP.index('OPNAST');
      NASZGP.prefix(ZGP.ref());
      {? NASZGP.first()
      || {!
         |? ZGP.cntx_psh();
            NASZGP.SCIEZKA:=$NASZGP.NRNAST().NRP;
            ZGP.cntx_pop();
            _can_continue:=NASZGP.put();
            NASZGP.next() & _can_continue>0
         !}
      ?};
      ZGP.next()
   !}
?};

:: Dodanie "nowych" numerow pozycji przewodnika - obsluga powiazanych Tpz
{? _can_continue>0 & ZGP.first()
|| {!
   |? _zgp.prefix($ZGP.ref());
      {? _zgp.first()
      || _zgp.NRP_NEW:=ZGP.NRP;
         _can_continue:=_zgp.put()
      ?};
      ZGP.next() & _can_continue>0
   !}
?};

:: Naniesienie "nowych" numerow - obsluga powiazanych Tpz
{? _can_continue>0
||
   ZGP.prefix();
   {? _zgh<>null()
   || _ndx:=_zgp.ndx_tmp(,,'ZGH',,);
      _zgp.index(_ndx);
      _zgp.prefix($_zgh)
   || _zgp.prefix()
   ?};
   {? _zgp.first()
   || {!
      |? {? _zgp.REF_TPZ<>''
         || {? ZGP.seek(_zgp.REF_TPZ)
            ||
::             ZGP.TPZREF:=_zgp.NRP_NEW;
               ZGP.NRP:=_zgp.NRP_NEW;
               _can_continue:=ZGP.put()
            ?}
         ?};
         _zgp.next() & _can_continue>0
      !}
   ?}
?};
ZGP.cntx_pop();
ZGP.get();
NASZGP.cntx_pop();
NASZGP.get();
{? _can_continue>0
|| _result:=1
?};
_result


\renum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Obsluga renumeracji pozycji przewodnika.
::       lub zmiana numeracji aktualnego rekordu jesli argument _a ma wartosc SRC
::   WE: _a - obj_new() - argumenty funkcji przenumerowującej exec('renum_args','zl_guide')
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::  OLD: \renum/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
{? _can_continue>0
||
:: Wlasciwa renumeracja
   {? _args.MODE='DND'
   || _ref:=dnd_info('dest_record');
      {? ZGP.seek(_ref)
      || exec('zmien_lp','#dragdrop','NRP',ZGP.index('?'),,ZGP)
      ?}
   |? _args.MODE='MOVE'
   ||
::    Akcja przesuń
      {? ZGP.seek(_args.ZGP)
      || exec('zmien_lpa','#dragdrop','NRP',ZGP.index('?'),,ZGP,_args.MOVE_DIR)
      ?}
   |? _args.MODE='SPLIT'
   ||
      _size:=ZGP.size();
      _mydo:=do_state()=0;
      {? _mydo || do() ?};

      {? ZGP.UID_SRC<>''
      || _ref_src:=null();
         _new_num:=-1;
         ZGP.cntx_psh();
         ZGP.index('UID');
         ZGP.prefix(ZGP.UID_SRC);
         {? ZGP.first()
         || _ref_src:=ZGP.ref()
         ?};
         ZGP.cntx_pop();

         ZGP.cntx_psh();
         {? ZGP.seek(_ref_src)
         || _new_num:=ZGP.NRP+1;
::          Stoje na rekordzie pod ktorym mam wpisac rekord przenumerowywany, wiec wszystko za nim
::          wpisuje w obszar wolnych numerow
            _lp:=_size+1;
            {? ZGP.next()
            || {? var_pres('_visited')>100
               || obj_del(_visited)
               ?};
               _visited:=exec('ref_table','#table');
               {!
               |?
                  _visited.add(ZGP.ref());
                  _ref_nxt:=null();
                  _next:=0;
                  ZGP.cntx_psh();
                  {? ZGP.next()
                  || _ref_nxt:=ZGP.ref()
                  ?};
                  ZGP.cntx_pop();

                  ZGP.NRP:=_lp;
                  _can_continue:=ZGP.put();
                  _lp+=1;

                  {? _ref_nxt<>null()
                  || {? ZGP.seek(_ref_nxt)
                     || {? _visited.r_find(ZGP.ref())=0
                        || _next:=1
                        ?}
                     ?}
                  ?};
                  _next>0 & _can_continue>0
               !}
            ?}
         ?};
         ZGP.cntx_pop();

         {? _can_continue>0 & _new_num>-1
         ||
::          Wpisuje rekordowi przenumerowywanemu nowy numer
            ZGP.NRP:=_new_num;
            _can_continue:=ZGP.put();

            {? _can_continue>0
            ||
               _lp:=_new_num+1;

::             Wszystkim rekordom dalej, które powinny być w strefie wolnej od konfliktu przypisuję ponownie numery następne
               {? ZGP.next()
               || {? var_pres('_visited')>100
                  || obj_del(_visited)
                  ?};
                  _visited:=exec('ref_table','#table');

                  {!
                  |?
                     _visited.add(ZGP.ref());
                     _ref_nxt:=null();
                     _next:=0;
                     ZGP.cntx_psh();
                     {? ZGP.next()
                     || _ref_nxt:=ZGP.ref()
                     ?};
                     ZGP.cntx_pop();

                     ZGP.NRP:=_lp;
                     _can_continue:=ZGP.put();
                     _lp+=1;

                     {? _ref_nxt<>null()
                     || {? ZGP.seek(_ref_nxt)
                        || {? _visited.r_find(ZGP.ref())=0
                           || _next:=1
                           ?}
                        ?}
                     ?};
                     _next>0 & _can_continue>0
                  !}
               ?}
            ?}
         ?};
         {? _can_continue<=0
         || undo()
         ?};
         {? _mydo || end() ?}
      ?}
   |? _args.MODE='MERGE'
   ||
      _new_nr:=0;
      ZGP.cntx_psh();
      {? ZGP.prev()
      ||  _new_nr:=ZGP.NRP+1
      ?};
      ZGP.cntx_pop();
      {? ZGP.NRP>_new_nr
      || ZGP.NRP:=_new_nr;
         _can_continue:=ZGP.put()
      ?}
   |? _args.MODE='BRAKI'
   ||
      {? _args.REC=0
      ||
::       Wywołanie nie rekurencyjne - zbieram ostatnie operacje (tzn takie bez następników ) i zaczynam
::       renumerować całe ścieżki w tył od najnowszej
         _args.NRP_TAB.prefix();
         _args.NRP_TAB.blank();
         _args.NRP_TAB.ZL:=$ZGP.ZL;
         _args.NRP_TAB.NRP:=ZGP.size();
         _args.NRP_TAB.add();

         _tab_last:=tab_tmp(1,
            'UID','STRING[15]','Identyfikator',
            'ZGP','STRING[16]','Ref SQL ZGPa'
         );
         NASZGP.cntx_psh();
         NASZGP.index('OPNAST');
         {? ZGP.first()
         || {!
            |? NASZGP.prefix(ZGP.ref());
               {? NASZGP.size()=0
               || _tab_last.blank();
                  _tab_last.UID:=ZGP.UID;
                  _tab_last.ZGP:=$ZGP.ref();
                  _tab_last.add()
               ||
::                Przypadek zlecenia podrzędnego, ostatnią operacją jest też taka
::                która łączy się z innym zleceniem
                  {? NASZGP.first()
                  || {!
                     |? {? NASZGP.ZLNAST<>null() & NASZGP.ZLNAST<>ZGP.ZL
                        ||
                           _tab_last.blank();
                           _tab_last.UID:=ZGP.UID;
                           _tab_last.ZGP:=$ZGP.ref();
                           _tab_last.add()

                        ?};
                        NASZGP.next()
                     !}
                  ?}
               ?};
               ZGP.next()
            !}
         ?};
         NASZGP.cntx_pop();

         ZGP.cntx_psh();
         ZGP.clear();
         _tab_last.clear();
         {? _tab_last.last()
         ||
            {!
            |? {? ZGP.seek(_tab_last.ZGP)
               ||
                  _old_zgp:=_args.ZGP;
                  _old_rec:=_args.REC;

                  _args.REC:=1;
                  _args.ZGP:=ZGP.ref();
                  _can_continue:=exec('renum','zl_guide',_args);

                  _args.ZGP:=_old_zgp;
                  _args.REC:=_old_rec
               ?};
               _tab_last.prev() & _can_continue>0
            !}
         ?};
         ZGP.cntx_pop()
      ||
::       Wywołanie rekurencyjne - nadaję pozycji przewodnika nowy numer i uruchamiam
::       rekurencję dla poprzedników

         ZGP.cntx_psh();
         ZGP.clear();
         {? ZGP.seek(_args.ZGP)
         ||
            {? _args.CAN_NRP>0
            ||
               _can_renum:=1;
               {? _args.NAS_FROM<>null()
               || _args.NAS_TAB.prefix($ZGP.ref(),$_args.NAS_FROM);
                  {? _args.NAS_TAB.size()=0
                  || _args.NAS_TAB.blank();
                     _args.NAS_TAB.ZGP_SRC:=$ZGP.ref();
                     _args.NAS_TAB.NASZGP:=$_args.NAS_FROM;
                     _args.NAS_TAB.add()
                  ?};

::                Mogę rekurencyjnie przenumerować dopiero jak wlazłem tutaj ostatnim przepływem
                  NASZGP.cntx_psh();
                  NASZGP.index('BRAKINAS');
                  NASZGP.prefix(ZGP.ref());
                  {? NASZGP.first()
                  || {!
                     |?
                        _args.NAS_TAB.prefix($ZGP.ref(),$NASZGP.ref());
                        {? _args.NAS_TAB.size()=0
                        || _can_renum:=0
                        ?};
                        NASZGP.next() & _can_renum>0
                     !}
                  ?};
                  NASZGP.cntx_pop()
               ?};
               {? _can_renum>0 & _args.VISITED.r_find(_args.ZGP)=0
               ||
                  _args.VISITED.add(_args.ZGP);
                  _nrp:=0;
                  _args.NRP_TAB.cntx_psh();
                  _args.NRP_TAB.prefix($ZGP.ZL);
                  {? _args.NRP_TAB.first()
                  ||
::                   Pobieram numer przewodnika dla tego zlecenia
                     _nrp:=_args.NRP_TAB.NRP
                  ||
::                   Nastąpiło przejście na zlecenie, które jeszcze nie było numerowane więc resetuję bieżący numer operacji
                     ZGP.cntx_psh();
                     ZGP.index('PNRPP');
                     ZGP.prefix(ZGP.NRZLP,'N');
                     _args.NRP_TAB.blank();
                     _args.NRP_TAB.NRP:=ZGP.size();
                     _nrp:=ZGP.size();
                     _args.NRP_TAB.ZL:=$ZGP.ZL;
                     _can_continue:=_args.NRP_TAB.add();
                     ZGP.cntx_pop()
                  ?};

                  {? _can_continue>0
                  || ZGP.NRP:=_nrp;
                     _can_continue:=ZGP.put()
                  ?};

::                Zmniejszam o 1 numer przewodnika dla aktualnego zlecenia
                  {? _can_continue>0
                  || _args.NRP_TAB.NRP:=_nrp-1;
                     _can_continue:=_args.NRP_TAB.put()
                  ?};
                  _args.NRP_TAB.cntx_pop()
               ?}
            ?};

            {? _can_continue>0 & _args.CAN_REC>0
            ||
               NASZGP.cntx_psh();
               NASZGP.index('BRAKIPOP');
               NASZGP.prefix(ZGP.ref());

::             Pierwsza pętla po poprzednikach - ustalam im nowe numery
               {? NASZGP.last()
               || {!
                  |?
                     _old_zgp:=_args.ZGP;
                     _old_rec:=_args.REC;
                     _old_cnrp:=_args.CAN_NRP;
                     _old_crec:=_args.CAN_REC;

                     _args.REC:=1;
                     _args.CAN_NRP:=1;
                     _args.CAN_REC:=0;
                     _args.ZGP:=NASZGP.OPER;
                     _args.NAS_FROM:=NASZGP.ref();
                     _can_continue:=exec('renum','zl_guide',_args);

                     _args.ZGP:=_old_zgp;
                     _args.REC:=_old_rec;
                     _args.CAN_NRP:=_old_cnrp;
                     _args.CAN_REC:=_old_crec;
                     NASZGP.prev()
                  !}
               ?};

::             Druga pętla po poprzedikach - wywołuję dla nich rekurencyjnie kolejne numerowanie
::             dla ich poprzedników
               {? NASZGP.last()
               || {!
                  |?
                     _old_zgp:=_args.ZGP;
                     _old_rec:=_args.REC;
                     _old_cnrp:=_args.CAN_NRP;
                     _old_crec:=_args.CAN_REC;

                     _args.REC:=1;
                     _args.CAN_NRP:=0;
                     _args.CAN_REC:=1;
                     _args.ZGP:=NASZGP.OPER;
                     _args.NAS_FROM:=NASZGP.ref();
                     _can_continue:=exec('renum','zl_guide',_args);

                     _args.ZGP:=_old_zgp;
                     _args.REC:=_old_rec;
                     _args.CAN_NRP:=_old_cnrp;
                     _args.CAN_REC:=_old_crec;
                     NASZGP.prev()
                  !}
               ?};
               NASZGP.cntx_pop()
            ?};
            ~~
         ?};
         ZGP.cntx_pop();
         ~~
      ?}
   ?}
?};
ZGP.cntx_pop();
ZGP.get();
{? _can_continue>0
|| _result:=1
?};
_result


\dnd_renum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Obsluga renumeracji pozycji przewodnika za pomoca drag-and-drop
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \dnd_renum/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('renum_args','zl_guide');
_args.MODE:='DND';

_result:=0;
_can_continue:=1;

_can_continue:=exec('renum_before','zl_guide',_args);
{? _can_continue>0
|| _can_continue:=exec('renum','zl_guide',_args)
?};
{? _can_continue>0
|| _can_continue:=exec('renum_after','zl_guide',_args)
?};
{? _can_continue>0
|| _result:=1
?};
_result



\move
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Obsluga renumeracji pozycji przewodnika za pomoca akcji Przesuń
::   WE: _a - STRING - kierunek przesuwania: 'U','D','N'
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_dir:='N';
{? var_pres('_a')=type_of('')
|| _dir:=_a
?};
_args:=exec('renum_args','zl_guide');
_args.MODE:='MOVE';
_args.MOVE_DIR:=_dir;
_args.ZGP:=ZGP.ref();

_result:=0;
_can_continue:=1;

_can_continue:=exec('renum_before','zl_guide',_args);
{? _can_continue>0
|| _can_continue:=exec('renum','zl_guide',_args)
?};
{? _can_continue>0
|| _can_continue:=exec('renum_after','zl_guide',_args)
?};
{? _can_continue>0
|| _result:=1
?};
_result



\sel_poz
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: ustala podstawowe parametry do wyświetlania pozycji przewodnika
::   WE: _a - 0, 1, 2 - wariant wyświetlania
::  OLD: \sel_poz/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

{? _a<>0
|| _sel:='WER'
|| _sel:=ZGP.win_sel('?')
?};
ZGP.clear();

_actzgp:=exec('zgp_actions','zl_guide');
ZGP.actions(_sel,_actzgp,,1);

{? ZGH.ZLEC().NRNZL<>0
|| __Pod:=1; ZGP.index('PNRPP')
|| __Pod:=0; ZGP.index('NRPP')
?};
ZGP.prefix(ZGH.ref(),'N');

ZGP.win_edit('RED');
{? ZGP.first()
|| VAR.A_NRPRZ:=ZGP.NRPRZ;
   VAR.A_NRZLP:=ZGP.NRZLP
|| VAR.A_ZGP:=null();
   VAR.A_NRPRZ:=ZGH.ref();
   VAR.A_NRZLP:=ZGH.ref()
?};
_sel


\icon_status
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ikona symbolizująca status pozycji przewodnika
::   WE: _a - status (ZGP.STATUS, VAR1.ZGP_STAT)
::  OLD: \icon_status/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a=exec('status_new','zl_guide') || 'xwin16.png:157'
|? _a=exec('status_pending','zl_guide') || 'xwin16.png:156'
|? _a=exec('status_waiting','zl_guide') || 'xwin16.png:134'
|? _a=exec('status_end','zl_guide') || 'xwin16.png:38'
|| ''
?}


\icon_problem
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ikona symbolizująca problem pozycji przewodnika
::   WE: _a - status operacji głównej (ZGP.PROBLEM)
::       _b - klasa problemu operacji głównej (ZGP.PROBKLAS)
::       _c - status operacji Tpz (VAR1.PROBLEM)
::       _d - klasa problemu operacji Tpz (VAR1.PROBLKAS)
::  OLD: \icon_problem/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? (_a='T' | _c='T') & _b=exec('prob_class_blocking','zl_wkj') | _d=exec('prob_class_blocking','zl_wkj')
|| exec('problem_blocking','icon')
|? (_a='T' | _c='T') & _b=exec('prob_class_suspensing','zl_wkj') | _d=exec('prob_class_suspensing','zl_wkj')
|| exec('problem_suspensing','icon')
|? (_a='T' | _c='T') & _b=exec('prob_class_information','zl_wkj') | _d=exec('prob_class_information','zl_wkj')
|| exec('problem_information','icon')
|| exec('pusta','#icon')
?}


\icon_kontrol
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Ikona symbolizujaca operację typu kontrola jakości
::   WE: _a - STRING - 'B'/'P'/'N' - czy operacja ma kontrole jakości przez moduł badań (ZGP.KJ_BAD)
::       _a - STRING - 'T'/'N' - czy operacja typu kontrola jakości (ZGP.KONTROLA)
::  OLD: \icon_kontrol/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a='B'
|| 'xwin16.png:93'
|? _a='P'
|| 'xwin16.png:94'
|? _b='T'
|| 'xwin16.png:95'
|| 'xwin16.png:110'
?}


\icon_napraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [12.46]
:: OPIS: Ikona symbolizujaca operację typu naprawcza
::   WE: _a - czy naprawcza (ZGP.NAPRAW)
::  OLD: \icon_napraw/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a='T'
|| 'xwin16.png:118'
|| ''
?}


\icon_dok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Ikona symbolizujaca operację z przypisanym dokumentem
::   WE: _a - przypisany dokument (ZGP.DOK)
::  OLD: \icon_napraw/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a<>null()
|| 'xwin16.png:190'
|| exec('pusta','#icon')
?}


\zgp_actions
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ustala akcje dla okna tabeli ZGP (Dołącz, v-dołącz za, Popraw, Usuń, rEjestracja, kArty pracy, Godziny,
::       limitY, nielimitoWane, dokumenty Magazynowe, dane do planOwania,
::       Funkcje|Wykorzystanie zasobów, Funkcje|Zmiana statusu, Funkcje|Odtworzenie statusów)
::       Kontekst pracy - rekordy tabel ZL i ZGH
::   WY: tekst dla funkcji actions()
::  OLD: \zgp_actions/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_used:=
   {? VAR.ZGH_ALL>0
   || exec('blk_lock','#table','ZGH',ZGH.ref(),,2)<>SYSLOG.ses_id()
   || params_get().env_guide.used
   ?};
_actions:={? VAR.ZGH_ALL>0 || '' || params_get().env_guide.zgp_actions ?};

{? _used || _actions:='DvpUF(ZORP)'+_actions+'D' ?};
{? ZL.STAN='Z' | ZGH.STAN='T' || _actions:='DvpUAF'+_actions+'D' ?};
{? ZL.STAN='Z' || _actions:='F(ZO)'+_actions ?};
{? ZL.STAN='N' || _actions:='EAGMF(WZO)'+_actions ?};
{? sec_superuser()=0 || _actions:='F(ZO)'+_actions ?};
{? ZL.RODZAJ='Z' || _actions:='DvpUF(PR)'+_actions+'D' ?};

_tktl:={? ZL.RTKTL<>'' || ZL.RTKTL || ZL.RKTL ?};
{? exec('FindAndGet','#table',TKTL,_tktl,,"TYP().OPER",'T')='N' || _actions:='DvpUEOF(PR)'+_actions+'D' ?};

{? ZL.TYP().WP='W' || _actions:='WB'+_actions ?};

{? exec('chk_role','#b__box',OPERATOR.USER,'TTE_WYK_DWZL')=0 | exec('get','#params',500611,2)='N'
|| _actions:='E'+_actions
?};

_actions


\zgp_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Sprawdza możliwość usunięcia pozycji przewodnika zlecenia
::       Kontekst: ZGP.ref()
::   WE: _a - jeżeli jest, to 1 - nie pytać o usuwanie, 0 - pytać
::       [_b] - INTEGER -  0 - po usunięciu nie aktualizować przepisu planistycznego zlecenia
::                        [1] - po usunięciu aktualizować przepis planistyczny zlecenia
::   WY: 0, albo wynik ZGP.del(,1)
::  OLD: \zgp_del/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
{? _<1 || _no_ask:=0 || _no_ask:=_a ?};

{? _no_ask=0 &  & VAR.GRUPA='T' || _no_ask:=1 ?};

_tex_update:=1;
{? var_pres('_b')=type_of(1)
|| _tex_update:=_b
?};

_can_continue:=1;

:: sprawdzenie powiązanych zapotrzebowań, czy wogóle jakieś są (nie blokuje usuwania)
exec('openmask','zl_common',ZGP.ZL);
ZLIM.index('ZGP_M');
ZLIM.prefix(ZGP.ref());
_limity:=ZLIM.first();

:: sprawdzenie czy zapotrzebowania są redagowane
:: (tylko gdy transakcja nie była rozpoczęta - w przeciwnym wypadku sprawdzenie dokonywane jest wcześniej)
{? _limity & do_state()=0
|| _limity_locked:=exec('zl_lock','zl_common',ZGP.ZL,'L',1);
   {? _limity_locked=0
   || _msg:='Usunięcie pozycji: \'%1\' niemożliwe.\n'
            'Z pozycją powiązane są zapotrzebowania, które są redagowane przez innego operatora.'@[ZGP.OPIS];
      {? VAR.GRUPA='T' | do_state()>0
      || KOMM.add(gsub(_msg,'\n',' '),'xwin16.png:81',,1)
      || FUN.emsg(_msg)
      ?};
      return(0)
   || exec('zl_unlock','zl_common',ZGP.ZL,'L')
   ?}
?};

:: sprawdzenie powiązanych limitów czy były pobrania, zwroty
_limity_dk:=exec('zgp_limity_chk','zl_limit',ZGP.ref());
{? _limity_dk>0
|| _msg:='Usunięcie pozycji: \'%1\' niemożliwe.\n'
         'Pozycja ma limity lub surowce nielimitowane,\n'
         'na które były pobrania lub zwroty.'@[ZGP.OPIS];
   {? VAR.GRUPA='T' | do_state()>0
   || KOMM.add(gsub(_msg,'\n',' '),'xwin16.png:81',,1)
   || FUN.emsg(_msg)
   ?};
   return(0)
?};

:: sprawdzenie powiązanych zamówień wewnętrznych pośrednio przez limmity
_limity_zkp:=exec('zgp_limity_zkp','zl_limit',ZGP.ref());
{? _limity_zkp>0
||
   _msg:='Usunięcie pozycji: \'%1\' niemożliwe.\n'
         'Pozycja ma limity lub surowce nielimitowane,\n'
         'powiązane z zamówieniami wewnętrznymi.'@[ZGP.OPIS];
   {? VAR.GRUPA='T' | do_state()>0
   || KOMM.add(gsub(_msg,'\n',' '),'xwin16.png:81',,1)
   || FUN.emsg(_msg)
   ?};
   return(0)
?};

:: sprawdzenie powiązanych dokumentów kooperacyjnych
_koop:=exec('zgp_koop_dk','zl_koop',ZGP.ref());
{? _koop>0
|| _msg:='Usunięcie pozycji: \'%1\' niemożliwe.\n'
         'Pozycja występuje na dokumentach magazynowych.'@[ZGP.OPIS];
   {? VAR.GRUPA='T' | do_state()>0
   || KOMM.add(gsub(_msg,'\n',' '),'xwin16.png:81',,1)
   || FUN.emsg(_msg)
   ?};
   return(0)
?};

:: sprawdzenie powiązanych zamówień wewnętrznych pośrednio przez limity
_limity_zkpz:=exec('zgp_limity_zkpz','zl_limit',ZGP.ref());
{? _limity_zkpz>0
|| _msg:='Usunięcie pozycji: \'%1\' niemożliwe.\n'
         'Pozycja ma limity lub surowce nielimitowane\n'
         'powiązane z zamówieniami wewnętrznymi, z których utworzono zlecenie.'@[ZGP.OPIS];
   {? VAR.GRUPA='T' | do_state()>0
   || KOMM.add(gsub(_msg,'\n',' '),'xwin16.png:81',,1)
   || FUN.emsg(_msg)
   ?};
   return(0)
?};

:: sprawdzenie wykorzystania w planie operacyjnym jako element grupy operacji
_grop:=exec('zgp_utilization','po_ogr',1,ZGP.ref());
{? _grop>0
|| _msg:='Usunięcie pozycji \'%1\' niemożliwe.\n'
         'Pozycja przypisana do grupy operacji.'@[ZGP.OPIS];
   {? VAR.GRUPA='T' | do_state()>0
   || KOMM.add(_msg,'xwin16.png:81',,1)
   || FUN.emsg(_msg)
   ?};
   return(0)
?};

:: sprawdzenie wykorzystania w planie operacyjnym
_resplan:=exec('zgp_utilization','po_plan',1,ZGP.ref());
{? _resplan>0
|| _msg:='Usunięcie pozycji: \'%1\' niemożliwe.\n'
         'Pozycja znajduje się w planie operacyjnym.'@[ZGP.OPIS];
   {? VAR.GRUPA='T' | do_state()>0
   || KOMM.add(_msg,'xwin16.png:81',,1)
   || FUN.emsg(_msg)
   ?};
   return(0)
?};

:: sprawdzenie czy przewodnik ma zakończoną rejestrację
_done:=ZGP.NRZLP().STAT_REJ='T';
{? _done>0 & ZGP.sel_size()>0
|| _msg:='Usunięcie pozycji: \'%1\' niemożliwe.\n'
         'Zakończono rejestrowanie przewodnika.'@[ZGP.OPIS];
   KOMM.add(_msg,'xwin16.png:81',,1);
   return(0)
?};

:: Sprawdzam czy przewodnik ma wariantowe operacje i użytkownik może je usuwać
_has_wariant:=exec('zgh_has_wariant','zl_guide',ZGP.NRZLP,'');
{? _has_wariant>0 & (exec('get','#params',8904,2,OPERATOR.USER)='N')
|| _msg:='Usunięcie pozycji: \'%1\' przewodnika \'%2\' niemożliwe.\n'
         'Pozycja dotyczy operacji wariantowej pierwszego/ostatniego przewodnika.'@[ZGP.OPIS,ZGP.NRZLP().NRPRZ];
   {? VAR.GRUPA='T' | do_state()>0
   || KOMM.add(_msg,'xwin16.png:81',,1)
   || FUN.emsg(_msg)
   ?};
   return(0)
?};

:: sprawdzenie wykorzystania w planie strategicznym
_pxplan:=0;
{? ZGP.PX_STAGE<>null()
|| _pxplan:=exec('used_in_plan','px_stage',ZGP.PX_STAGE)
?};

{? ZGP.NRPRZ().STAN<>'T' & ZGP.NRZLP().STAN<>'T'
|| _spr_akord:=exec('spr_akord','zl_guide');
   _tpz_ref:=exec('tpz_ref','zl_guide',ZGP.ref());
   _spr_tpz:=exec('spr_akord','zl_guide',_tpz_ref);
   {? _spr_akord=1 & _spr_tpz=1
   || KAP.index('REF');
      KAP.prefix(ZGP.ref()); _kap:=KAP.first();
      KAP.prefix(_tpz_ref); _kap_tpz:=KAP.first();
      _problem:=exec('has_problem','zl_guide',ZGP.ref());
      {? _no_ask=0
      ||
         {? (_kap | _kap_tpz) & _limity & _problem
         || _msg1:='Czy usunąć pozycję przewodnika razem z kartami pracy, problemami i zapotrzebowaniami?'@
         |? (_kap | _kap_tpz) & _limity
         || _msg1:='Czy usunąć pozycję przewodnika razem z kartami pracy i zapotrzebowaniami?'@
         |? (_kap | _kap_tpz) & _problem
         || _msg1:='Czy usunąć pozycję przewodnika razem z kartami pracy i problemami?'@
         |? (_kap & _kap_tpz)
         || _msg1:='Czy usunąć pozycję przewodnika razem z kartami pracy?'@
         |? _limity & _problem
         || _msg1:='Czy usunąć pozycję przewodnika razem z zapotrzebowaniami i problemami?'@
         |? _limity
         || _msg1:='Czy usunąć pozycję przewodnika razem z zapotrzebowaniami?'@
         |? _problem
         || _msg1:='Czy usunąć pozycję przewodnika razem z problemami?'@
         || _msg1:='Czy usunąć pozycję przewodnika?'@
         ?};

         {? _pxplan>0
         || _msg:='Pozycja przewodnika: \'%1. %2\' znajduje się w Planie strategicznym.\n\n'
                  'Jej usunięcie spowoduje usunięcie pozycji planu z nią powiązanych we wszystkich wersjach planu\n'
                  'oraz wygenerowanie nowego przepisu planistycznego dla zlecenia.\n\n'
                  'Po usunięciu pozycji przewodnika zalecane jest przeliczenie głównej wersji planu.'@
                  [$ZGP.NRP,ZGP.OPIS]
         |? _done>0
         || _msg:='Zakończno już rejestrację przewodnika %1.'@[ZGP.NRZLP().NRPRZ]+'\n\n'+_msg1
         || _msg:=_msg1
         ?};
         _can_continue:=FUN.ask(_msg)
      ?};
      {? _can_continue>0
      ||
         exec('zgp_limity_del','zl_limit',ZGP.ref());
         exec('del_naszgp','zl_guide',ZGP.ref());
         exec('recover_sta_zgh','zl_guide',ZGP.NRZLP);
         exec('del_kap','zl_guide',ZGP.ref());
         exec('del_kap','zl_guide',_tpz_ref);
         exec('del_problem','zl_guide',ZGP.ref());
         DocLib.del('ZGP',ZGP.ref());
         {? ZGP.TPZ<>'T'
         ||
            ZGP.cntx_psh();
            ZGP.index('TPZ');
            ZGP.prefix('T',ZGP.UID);
            {? ZGP.first()
            || ZGP.del()
            ?};
            ZGP.cntx_pop()
         ?};
         nr:=ZGP.NRPRZ().NRPRZ+' - '+$ZGP.NRP;
         _nr:=ZGP.NRP;
         _nrp:=ZGP.NRZLP().NRPRZ;
         _px_stage:=ZGP.PX_STAGE;
         _zl:=ZGP.NRZLP().ZLEC;
         _where:=ZGP.WHERE;
         _zgh:=ZGP.NRZLP;
         _usunal:=ZGP.del(,1);
         {? _usunal<>0
         || exec('zgp_licz','zl_guide',_nr,_nrp);

::          Usuwam pozycje planu przewodnika z planu strategicznego i aktualizuje przepis zlecenias
            {? _px_stage<>null()
            || _can_continue:=exec('clean_from_plan','px_stage',_px_stage);
               {? _can_continue>0 & _tex_update>0
               || exec('zl_tex_update','px_tex',_zl)
               ?}
            ?};
::          Aktualizacja pól ZGH.W_FIRST, ZGH.W_LAST
            {? _where<>'W'
            || ZGH.cntx_psh();
               ZGH.clear();
               {? ZGH.seek(_zgh)
               || {? _where='P' & ~exec('zgh_has_wariant','zl_guide',ZGH.ref(),'FIRST')
                  || ZGH.W_FIRST:='N';
                     ZGH.put()
                  |? _where='O' & ~exec('zgh_has_wariant','zl_guide',ZGH.ref(),'LAST')
                  || ZGH.W_LAST:='N';
                     ZGH.put()
                  ?}
               ?};
               ZGH.cntx_pop()
            ?}
         ?};
         _usunal
      ?}
   || _msg:='Usunięcie pozycji: \'%1\' niemożliwe.\n'
            'Zostało już zarejestrowane wykonanie.'@[ZGP.OPIS];
      {? VAR.GRUPA='T' | do_state()>0
      || KOMM.add(_msg,'xwin16.png:81',,1)
      || FUN.info(_msg)
      ?};
      0
   ?}
|| _msg:='Przewodnik już został oddany. Modyfikacje nie są możliwe.'@;
   {? VAR.GRUPA='T' | do_state()>0
   || KOMM.add(_msg,'xwin16.png:81',,1)
   || FUN.info(_msg)
   ?};
   0
?}


\del_kap
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Usuwa karty pracy dla zadanego przewodnika
::   WE: _a: ZGP.ref()
::  OLD: \del_kap/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
KAP.index('REF');
KAP.prefix(_a);
{? KAP.first() || {! |? KAP.del() !} ?};
KAP.prefix();
~~


\del_naszgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Usuwa elementy z tabeli następników i odpowiednio wiąże pozostałe rekordy.
::   WE: _a: ZGP.ref()
::  OLD: \del_nast/tkasuj.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

NASZGP.index('NASTOP');
NASZGP.prefix(_zgp);
{? NASZGP.first()
|| {!
   |? _oper:=NASZGP.OPER;
      NASZGP.cntx_psh();
      NASZGP.index('OPNAST');
      NASZGP.prefix(_zgp);
      {? NASZGP.first()
      || {!
         |? NASZGP.cntx_psh();
            NASZGP.OPER:=_oper;
            NASZGP.prefix();
            NASZGP.add(1);
            NASZGP.cntx_pop();
            NASZGP.next()
         !}
      ?};
      NASZGP.cntx_pop();
      _zl:=NASZGP.KTL;
      _zl_nast:=NASZGP.ZLNAST;
      NASZGP.del();
      {? _zl<>_zl_nast
      || _zl_top:=exec('top_level','zl_link',_zl);
         _interzlec:=exec('interzlec','zl_guide',_zl_top);
         {? _interzlec.first()
         || exec('FindAndGet','#table',ZL,_zl_top,,"INTERZL:='T'; put()")
         || exec('FindAndGet','#table',ZL,_zl_top,,"INTERZL:='N'; put()")
         ?};
         obj_del(_interzlec)
      ?};
      NASZGP.first()
   !}
?};
NASZGP.index('OPNAST');
NASZGP.prefix(_zgp);
{? NASZGP.first()
|| {!
   |? _zl:=NASZGP.KTL;
      _zl_nast:=NASZGP.ZLNAST;
      _del:=NASZGP.del();
      {? _zl<>_zl_nast
      || _zl_top:=exec('top_level','zl_link',_zl);
         _interzlec:=exec('interzlec','zl_guide',_zl_top);
         {? _interzlec.first()
         || exec('FindAndGet','#table',ZL,_zl_top,,"INTERZL:='T'; put()")
         || exec('FindAndGet','#table',ZL,_zl_top,,"INTERZL:='N'; put()")
         ?};
         obj_del(_interzlec)
      ?};
      _del
   !}
?};
NASZGP.clear();
~~


\zgp_licz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2009]
:: OPIS: Po usunięciu pozycji przewodnika przenumerowuje resztę
::   WE: _a - nr usuniętego rekordu
::       _b - nr przewodnika zlecenia podrzędnego
::  OLD: \zgp_licz/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
ZGP.cntx_psh();
ZGP.index('NRPP');
ZGP.prefix(VAR.A_NRPRZ,'N',_b);
NASZGP.cntx_psh();
NASZGP.index('NASTOP');
{? ZGP.first()
|| _nost:=_nr:=1;
:: przeleć te, co nie trzeba przenumerowywać
   {!
   |? _nr:=ZGP.NRP < _a;
      {? _nr || _nost:=ZGP.next() ?};
      _nr & _nost
   !};
:: przenumerowanie pozycji i scieżek
:: jak na ostatniej pozycji, to nie ma co przenumerowywać
   {? _nost
   || {!
      |? ZGP.cntx_psh();
         ZGP.clear();
         {? ZGP.seek(exec('tpz_ref','zl_guide',ZGP.ref()))
         ||
::          ZGP.TPZREF:=ZGP.TPZREF-1;
            ZGP.NRP:=ZGP.NRP-1;
            ZGP.put()
         ?};
         ZGP.cntx_pop();
         ZGP.NRP:=ZGP.NRP-1;
         ZGP.put();
         NASZGP.prefix(ZGP.ref());
         {? NASZGP.first()
         || {!
            |? _sciezka:=#NASZGP.SCIEZKA;
               _sciezka-=1;
               NASZGP.SCIEZKA:=$_sciezka;
               NASZGP.put();
               NASZGP.next()
            !}
         ?};
         ZGP.next()
      !}
   ?}
?};
NASZGP.cntx_pop();
ZGP.cntx_pop();
~~


\akt_zgp_plany
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Aktualizuje terminy początku i końca realizacji pozycji przewodników na podstawie przewodnika
::   WE: _a - ZGH.ref()
::  OLD: \akt_zgp_plany/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_zgh:=_a;

Cntx.psh(ZGH,ZGP);
Cntx.clr(ZGH    );
{? ZGH.seek(_zgh)
|| ZGP.index('PNRPP');
   ZGP.prefix(ZGH.ref());
   {? ZGP.first()
   || {!
      |? ZGP.STARTD:=ZGH.STARTD;
         ZGP.STARTT:=ZGH.STARTT;
         ZGP.ENDD:=ZGH.ENDD;
         ZGP.ENDT:=ZGH.ENDT;
         {? ZGP.put() || exec('zlim_dates_upd','zl_limit',ZGP.ref()) ?};
         ZGP.next()
      !}
   ?}
?};

Cntx.pop(ZGH,ZGP);
~~


\usuprze
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Usunięcie przewodników zlecenia
::   WE: _a - ZL.ref()
::   WY: 0 / 1 - czy udało się usunąć przewodniki
::  OLD: \usuprze/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=0;
_can_continue:=0;

ZL.cntx_psh();
ZL.prefix();

{? ZL.seek(_zl)
|| ZGH.cntx_psh();
   ZGH.index('ZLNR');
   ZGH.prefix(ZL.ref());
   _can_continue:=0;
   {? ZGH.first()
   || {!
      |? ZGH.cntx_psh();
         exec('clean4zgh','zl_partie',ZGH.ref());
         _can_continue:=exec('przp_us','zl_guide',1);
         ZGH.cntx_pop();
         ZGH.first() & _can_continue>0
      !}
   || _can_continue:=1
   ?};
   ZGH.cntx_pop()
?};

{? _can_continue>0
|| _result:=1
?};

ZL.cntx_pop();
_result


\przp_us
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Usunięcie przewodnika
::   WE: [_a] - INTEGER - 1 = brak komunikatów
::       [_b] - INTEGER - 0/[1] - czy dla zlecenia montażowego usuwać przewodniki potomne
::   WY: 0 / 1
::  OLD: \przp_us/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
_do_state:=do_state();
_ok:=0;

_no_ask:=0;
{? var_pres('_a')=type_of(1)
|| _no_ask:=_a
?};
_childen_del:=1;
{? var_pres('_b')=type_of(0)
|| _childen_del:=_b
?};

_can_continue:=1;

:: Sprawdzam czy zapotrzebowania są redagowane
{? do_state()=0
||
   {? exec('zl_lock','zl_common',ZGH.ZLEC,'L',1)
   || exec('zl_unlock','zl_common',ZGH.ZLEC,'L')
   || _msg:='Zapotrzebowania do przewodnika: %1 są redagowane przez innego operatora. Usunięcie niemożliwe.'@[ZGH.NRPRZ];
         {? VAR.GRUPA='T'
         || KOMM.add(_msg,'xwin16.png:81')
         || FUN.emsg(_msg)
         ?};
      _can_continue:=0
   ?}
?};

:: Sprawdzam użycie w planie strategicznym
_pxplan:=exec('zgh_pxed','zl_guide',ZGH.ref());

:: Sprawdzam czy przewodnik ma potomków
_inherited:=exec('zgh_inherited','zl_guide');

:: sprawdzenie powiązanych zapotrzebowań, czy wogóle jakieś są (nie blokuje usuwania)
exec('openmask','zl_common',ZGH.ZLEC);
ZLIM.cntx_psh();
ZLIM.index('ZGH_KM');
ZLIM.prefix(ZGH.ref());
_limity:=ZLIM.first();
ZLIM.cntx_pop();

{? _can_continue>0 & _no_ask=0 &  VAR.GRUPA<>'T'
||
:: W zależnosci od tego czy przewodnik jest w planie strategicznym czy nie, komunikaty są różne
   {? _pxplan>0
   || _msg:='Przewodnik: %1 znajduje się w Planie strategicznym.\n\n'
            'Jego usunięcie spowoduje usunięcie pozycji planu z nim powiązanych we wszystkich wersjach planu.\n'
            'Po usunięciu przewodnika zalecane jest przeliczenie głównej wersji planu.\n\n'
            'Kontynuować?'@[ZGH.NRPRZ];
      _can_continue:=FUN.ask(_msg)

:: Przewodnik ma potomków - wyświetlam dodatkowe ostrzeżenie
   |? _inherited>0
   ||
      _msg:='Na podstawie przewodnika: %1 zostały utworzone inne przewodniki na podzleceniach.\n\n'
            'Jego usunięcie spowoduje usunięcie wszystkich potomnych przewodników.\n\n'
            'Kontynuować?'@[ZGH.NRPRZ];
      _can_continue:=FUN.ask(_msg)

:: Dla zakończonego przewodnika dodatkowa treść komunikatu
   |? ZGH.STAT_REJ='T'
   || _can_continue:=FUN.ask(
         'Zakończno rejestrowanie przewodnika.'@+'\n\n'+
         {? _limity
         || 'Czy na pewno usunąć przewodnik %1 razem z zapotrzebowaniami?'@[ZGH.NRPRZ]
         || 'Czy na pewno usunąć przewodnik %1?'@[ZGH.NRPRZ]
         ?}
      )
   || _can_continue:=FUN.ask(
         {? _limity
         || 'Czy na pewno usunąć przewodnik %1 razem z zapotrzebowaniami?'@[ZGH.NRPRZ]
         || 'Czy na pewno usunąć przewodnik %1?'@[ZGH.NRPRZ]
         ?}
      )
   ?}
?};

{? _can_continue>0
||
   {? VAR.GRUPA<>'T' & _do_state=0
   || KOMM.init(255,,'Usuwanie przewodnika zlecenia'@)
   ?};
:: sprawdzenie czy przewodnik jest zaplanowany w planie operacyjnym
   _resplan:=exec('zgh_utilization','po_plan',1,ZGH.ref());
   {? _resplan>0
   || _ok:=0;
      _msg:='Przewodnik: %1 znajduje się w planie operacyjnym. Usunięcie niemożliwe.'@[ZGH.NRPRZ];
      {? VAR.GRUPA='T'
      || KOMM.add(_msg,'xwin16.png:81')
      || FUN.emsg(_msg)
      ?}
   || _ok:=1
   ?};

:: Sprawdzenie możliwości usunięcia przewodnika w powiązaniu z partiami
   {? exec('delete4zgh','zl_partie',ZGH.ref(),'T','T')=0
   || _ok:=0
   ?};

   {? _ok>0 & _inherited>0 & _childen_del>0
   ||
      {? ZGH.UID<>''
      ||
::       Usuwam potomne przewodniki
         _old_grupa:=VAR.GRUPA;
         VAR.GRUPA:='T';
         {? _do_state=0 || do() ?};
         ZGH.cntx_psh();
         ZGH.index('UID_SRC');
         ZGH.prefix(ZGH.UID);
         {? ZGH.first()
         || {!
            |? _next:=0;
               _ref_nxt:=null();
               ZGH.cntx_psh();
               {? ZGH.next()
               || _ref_nxt:=ZGH.ref()
               ?};
               ZGH.cntx_pop();

::             !!! REKURENCJA !!!
               _ok:=exec('przp_us','zl_guide',1);

               {? _ref_nxt<>null()
               || _next:=ZGH.seek(_ref_nxt)
               ?};
               _next>0 & _ok>0
            !}
         ?};
         ZGH.cntx_pop();
         {? _do_state=0 || end() ?};
         VAR.GRUPA:=_old_grupa
      ?}
   ?};

   {? _ok>0
   ||
      VAR.A_ZLEC();
::    ZLECENIE PROSTE
      {? ZL.NRNZL<>0 | ZL.RODZAJ='P'
      || ZGP.index('PNRPP');
         ZGP.prefix(ZGH.ref());
         ZGH.cntx_psh();
         _can_continue:=1;

::       Usuwanie pozycji w TRANSAKCJI
         {? _do_state=0 || do() ?};

::       usuniecie partii powiązanych z przewodnikiem, o ile się da
         _can_continue:=exec('delete4zgh','zl_partie',ZGH.ref(),'T');

         {? ZGP.first() & _can_continue>0
         || {? ZL.NRNZL<>0 || _refzgh:=ZGP.NRPRZ ?};
            {!
            |? _can_continue:=exec('zgp_del','zl_guide',1,0);
               _can_continue>1 & ZGP.first()
            !}
         ?};
         {? _can_continue=0 || undo() ?};

::       KONIEC TRANSAKCJI
         {? _do_state=0 || end() ?};

         ZGH.cntx_pop();
         {? _can_continue>0
         ||
            _zgh_ref:=ZGH.ref();
            _ok:=ZGH.del(,1);

            {? ~_ok & ZL.NRNZL<>0
            || ZGH.cntx_psh();
               ZGH.clear();
               {? ZGH.seek(_refzgh) & ZGH.KIND='N'
               ||
                  _zgh_ref:=ZGH.ref();
                  {? ZGH.count()=0
                  ||
::                   usuniecie partii powiaząnych z przewodnikiem, o ile się da
                     _ok:=exec('delete4zgh','zl_partie',ZGH.ref(),'T');
                     {? _ok>0
                     || _ok:=ZGH.del(,1)
                     ?}
                  || exec('nprz_upd','zl_guide')
                  ?}
               ?};
               ZGH.cntx_pop()
            ?}
         || _ok:=0
         ?}

::    ZLECENIE ZLOZONE
      || ZGP.index('NRPP');
         ZGP.prefix(ZGH.ref());
         {? ZGP.first()
         ||
            _zgh:=ZGH.ref();
            _refzgh:=ZGP.NRZLP;
            {!
            |?
               {? ZGP.NRZLP<>_refzgh
               || _new:=ZGP.NRZLP;
                  _ok:=exec('zgp_del','zl_guide',1,0);
                  ZGH.cntx_psh();
                  ZGH.clear();
                  {? ZGH.seek(_refzgh) & ZGH.KIND='N'
                  ||
                     _zgh_ref:=ZGH.ref();
::                   usunięcie partii powiązanych z przewodnikiem, o ile się da
                     _ok:=exec('delete4zgh','zl_partie',ZGH.ref(),VAR.GRUPA);
                     {? _ok>0 & ZGH.count()=0
                     || _ok_h:=ZGH.del(,1)
                     ?}
                  ?};
                  ZGH.cntx_pop();
                  _refzgh:=_new
               || _ok:=exec('zgp_del','zl_guide',1,0)
               ?};
               _ok>0 & ZGP.first()
            !};
            {? _ok=1
            || ZGH.cntx_psh();
               ZGH.clear();
               {? ZGH.seek(_refzgh)
               || _zgh_ref:=ZGH.ref();

::                usunięcie partii powiązanych z przewodnikiem, o ile się da
                  _ok:=exec('delete4zgh','zl_partie',ZGH.ref(),VAR.GRUPA);
                  {? _ok>0 & ZGH.count()=0
                  || _ok:=ZGH.del(,1)
                  ?}
               ?};
               ZGH.clear();
               {? ZGH.seek(_zgh)
               || _zgh_ref:=ZGH.ref();

::                usunięcie partii powiązanych z przewodnikiem, o ile się da
                  _ok:=exec('delete4zgh','zl_partie',ZGH.ref(),VAR.GRUPA);
                  {? _ok>0 & ZGH.count()=0
                  || _ok:=ZGH.del(,1)
                  ?}
               ?};
               ZGH.cntx_pop()
            ?}
         ||
::          usunięcie partii powiązanych z przewodnikiem, o ile się da
            _ok:=exec('delete4zgh','zl_partie',ZGH.ref(),VAR.GRUPA);
            {? _ok>0 & ZGH.count()=0
            || _zgh_ref:=ZGH.ref();
               _ok:=ZGH.del(,1)
            ?}
         ?}
      ?}
   ?};
   {? VAR.GRUPA<>'T' & _do_state=0
   || KOMM.select()
   ?}
?};
_ok


\is_first_op
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Sprawdza, czy jest to pierwsza operacja procesu, czyli nie ma poprzedników
::   WE: _a - ZGP.ref()
::  OLD: \first_op/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_res:=1;
NASZGP.cntx_psh();

NASZGP.index('NASTOP');
NASZGP.prefix(_zgp);
_res:=(NASZGP.size()=0);

NASZGP.cntx_pop();
_res


\is_last_op
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza, czy jest to ostatnia operacja procesu, czyli nie ma następników
::   WE: _a - ZGP.ref()
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_res:=1;
NASZGP.cntx_psh();

NASZGP.index('OPNAST');
NASZGP.prefix(_zgp);
_res:=(NASZGP.size()=0);

NASZGP.cntx_pop();
_res


\get_first_op
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca pierwszą operację procesu, w którym występuje wskazana operacja (tę, która nie ma poprzedników)
::   WE: _a - ZGP.ref()
::----------------------------------------------------------------------------------------------------------------------
_zgp_in:=_a;

NASZGP.cntx_psh();
NASZGP.index('NASTOP');
NASZGP.prefix(_zgp_in);
{? NASZGP.first()
|| _zgp_out:=exec('get_first_op','zl_guide',NASZGP.OPER)
|| _zgp_out:=_zgp_in
?};
NASZGP.cntx_pop();

_zgp_out


\il_pop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca minimalna ilosc zarejestrowana na poprzednikach operacji
::   WE: _a - ZGP.ref()
::   WY: IL_POP - ilosc
::       MAX - znacznik, czy pilnowac maksimum
::       FIRST - znacznik, że operacja nie ma poprzedników
::  OLD: \il_pop/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_res:=obj_new('IL_POP','MAX','FIRST');
_res.IL_POP:=0;
_res.MAX:=0;
_res.FIRST:=0;

Cntx.psh(ZGH,ZGP);
ZGP.clear();

{? ZGP.seek(_zgp)
||
   _prev:=exec('tab_zgp_prev','zl_guide',_zgp);
   {? _prev.first()
   ||
      {? _prev.TPZ='T'
      ||
         ZGP.clear();
         {? ZGP.seek(_prev.REF,)
         ||
            _prev1:=exec('sum_zgp_prev','zl_guide',ZGP.ref());
            {? _prev1.first()
            ||
               _ilw:=_prev1.IL/_prev1.COEF;
               _res.IL_POP:=_ilw;
               {!
               |?
                  _ilw:=_prev1.IL/_prev1.COEF;
                  {? _ilw<_res.IL_POP
                  || _res.IL_POP:=_ilw
                  ?};
                  _prev1.next()
               !};
               _res.IL_POP:=_res.IL_POP*{? ZGP.NRPRZ().ILNPRZ=0 || 1 || ZGP.NRZLP().ILNPRZ/ZGP.NRPRZ().ILNPRZ ?};
               _res.MAX:=1
            || _res.FIRST:=1;
               _res.MAX:=0
            ?}
         ?}
      ||
         _prev1:=exec('sum_zgp_prev','zl_guide',_zgp,_prev);
         {? _prev1.first()
         ||
            _ilw:=_prev1.IL/_prev1.COEF;
            _res.IL_POP:=_ilw;
            {!
            |?
               _ilw:=_prev1.IL/_prev1.COEF;
               {? _ilw<_res.IL_POP
               || _res.IL_POP:=_ilw
               ?};
               _prev1.next()
            !}
         ?};
         _res.IL_POP:=_res.IL_POP*{? ZGP.NRPRZ().ILNPRZ=0 || 1 || ZGP.NRZLP().ILNPRZ/ZGP.NRPRZ().ILNPRZ ?};
         _res.MAX:=1
      ?}
   || _res.FIRST:=1
   ?}
?};

Cntx.pop(ZGH,ZGP);
_res


\tab_zgp_prev
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca zestaw rekordow bedacych faktycznymi poprzednikami podanej operacji
::   WE: _a - ZGP.ref()
::   WY: tab_tmp
::  OLD: \tab_zgp_prev/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(,
   'REF','INTEGER','#ZGP.ref()',
   'SQLREF','STRING[16]','$ZGP.ref()',
   'IL','REAL','Ilość',
   'IL_BRAK','REAL','Ilość braków',
   'STATUS','STRING[1]','Status pozycji przewodnika',
   'TPZ','STRING[1]','Operacja Tpz',
   'NRP','INTEGER','Pozycja',
   'OPIS','STRING[60]','Opis',
   'COEF','REAL','Współczynnik: il.na przewodniku/il.na przewodniku głównym',
   'ZGH','STRING[16]','$ZGH.ref()',
   'WEW','STRING[1]','Operacja wewnętrzna',
   'IL_KOOP','REAL','Ilość w kooperacji',
   'ILOSC','REAL','Ilość na pozycji przewodnika',
   'NAPRAW','STRING[1]','Operacja naprawcza',
   'BRAKI_K','STRING[16]','Kwalifikacja braków',
   'UID','STRING[15]','Unikalny identyfikator operacji'
);
Cntx.psh(ZGH,ZGP,NASZGP);
ZGP.clear();

{? ZGP.seek(_a)
|| _my_zgh:=ZGP.NRZLP;
   _my_il:=ZGP.NRZLP().ILNPRZ;
   _args:=exec('find_uid_a','zl_guide');
   _args.BRAKIUID:=ZGP.BRAKIUID;
   {? ZGP.TPZ='T'
   ||
::    Jezeli operacja jest Tpz, to poprzednikami sa poprzedniki operacji glownej (NASZGP)
      ZGP.index('UID');
      ZGP.prefix(ZGP.UID_TPZ);
      {? ZGP.first()
      || NASZGP.index('NASTOP');
         NASZGP.prefix(ZGP.ref());
         {? NASZGP.first()
         || {!
            |? NASZGP.OPER();
               _tab.REF:=#NASZGP.OPER;
               _tab.SQLREF:=$NASZGP.OPER;
               _tab.IL:=ZGP.IL;
               _tab.IL_BRAK:=ZGP.IL_BRAK;
               _tab.STATUS:=ZGP.STATUS;
               _tab.TPZ:=ZGP.TPZ;
               _tab.NRP:=ZGP.NRP;
               _tab.OPIS:=ZGP.OPIS;
               _ilnprz:={? ZGP.NRZLP=_my_zgh || ZGP.NRZLP().ILNPRZ || _my_il ?};
               _tab.COEF:={? _ilnprz=0 || 1 || ZGP.NRZLP().ILNPRZ/_ilnprz ?};
               {? _tab.COEF=0 || _tab.COEF:=1 ?};
               _tab.ZGH:=$NASZGP.OPER().NRZLP;
               _tab.WEW:=ZGP.WEW;
               _tab.IL_KOOP:=ZGP.IL_KOOP;
               _tab.ILOSC:=ZGP.ILOSC;
               _tab.NAPRAW:=ZGP.NAPRAW;
               _tab.BRAKI_K:=$ZGP.BRAKI_K;
               _args.ZGP:=ZGP.ref();
               _tab.UID:=exec('find_uid','zl_guide',_args);
               _tab.add();
               NASZGP.next()
            !}
         ?}
      ?}
   ||
::    Jezeli operacja glowna ma Tpz, to jest on jej poprzednikiem
      ZGP.cntx_psh();
      ZGP.index('TPZ');
      ZGP.prefix('T',ZGP.UID);
      {? ZGP.first()
      || _tab.REF:=#ZGP.ref();
         _tab.SQLREF:=$ZGP.ref();
         _tab.IL:=ZGP.IL;
         _tab.IL_BRAK:=ZGP.IL_BRAK;
         _tab.STATUS:=ZGP.STATUS;
         _tab.TPZ:=ZGP.TPZ;
         _tab.NRP:=ZGP.NRP;
         _tab.OPIS:=ZGP.OPIS;
         _ilnprz:={? ZGP.NRZLP=_my_zgh || ZGP.NRZLP().ILNPRZ || _my_il ?};
         _tab.COEF:={? _ilnprz=0 || 1 || ZGP.NRZLP().ILNPRZ/_ilnprz ?};
         {? _tab.COEF=0 || _tab.COEF:=1 ?};
         _tab.ZGH:=$ZGP.NRZLP;
         _tab.WEW:=ZGP.WEW;
         _tab.IL_KOOP:=ZGP.IL_KOOP;
         _tab.ILOSC:=ZGP.ILOSC;
         _tab.NAPRAW:=ZGP.NAPRAW;
         _tab.BRAKI_K:=$ZGP.BRAKI_K;
         _args.ZGP:=ZGP.ref();
         _tab.UID:=exec('find_uid','zl_guide',_args);
         _tab.add();
         _tpz:=1
      || _tpz:=0
      ?};
      ZGP.cntx_pop();
::    Poprzedniki operacji glownej (NASZGP)
      {? ~_tpz
      || NASZGP.index('NASTOP');
         NASZGP.prefix(ZGP.ref());
         {? NASZGP.first()
         || {!
            |? NASZGP.OPER();
               _tab.REF:=#NASZGP.OPER;
               _tab.SQLREF:=$NASZGP.OPER;
               _tab.IL:=ZGP.IL;
               _tab.IL_BRAK:=ZGP.IL_BRAK;
               _tab.STATUS:=ZGP.STATUS;
               _tab.TPZ:=ZGP.TPZ;
               _tab.NRP:=ZGP.NRP;
               _tab.OPIS:=ZGP.OPIS;
               _ilnprz:={? ZGP.NRZLP=_my_zgh || ZGP.NRZLP().ILNPRZ || _my_il ?};
               _tab.COEF:={? _ilnprz=0 || 1 || ZGP.NRZLP().ILNPRZ/_ilnprz ?};
               {? _tab.COEF=0 || _tab.COEF:=1 ?};
               _tab.ZGH:=$NASZGP.OPER().NRZLP;
               _tab.WEW:=ZGP.WEW;
               _tab.IL_KOOP:=ZGP.IL_KOOP;
               _tab.ILOSC:=ZGP.ILOSC;
               _tab.NAPRAW:=ZGP.NAPRAW;
               _tab.BRAKI_K:=$ZGP.BRAKI_K;
               _args.ZGP:=ZGP.ref();
               _tab.UID:=exec('find_uid','zl_guide',_args);
               _tab.add();
               NASZGP.next()
            !}
         ?}
      ?}
   ?}
?};
Cntx.pop(ZGH,ZGP,NASZGP);
_tab


\tab_zgp_next
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca zestaw rekordow bedacych faktycznymi nastepnikami podanej operacji
::   WE: _a - ZGP.ref()
::   WY: tab_tmp
::  OLD: \tab_zgp_next/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(,
   'REF','INTEGER','#ZGP.ref()',
   'SQLREF','STRING[16]','$ZGP.ref()',
   'IL','REAL','Ilość',
   'IL_BRAK','REAL','Ilość braków',
   'STATUS','STRING[1]','Status pozycji przewodnika',
   'TPZ','STRING[1]','Operacja Tpz',
   'NRP','INTEGER','Pozycja',
   'OPIS','STRING[60]','Opis',
   'COEF','REAL','Współczynnik: il.na przewodniku/il.na przewodniku głównym',
   'ZGH','STRING[16]','$ZGH.ref()',
   'WEW','STRING[1]','Operacja wewnętrzna',
   'IL_KOOP','REAL','Ilość w kooperacji',
   'ILOSC','REAL','Ilość na pozycji przewodnika',
   'NAPRAW','STRING[1]','Operacja naprawcza',
   'BRAKI_K','STRING[16]','Kwalifikacja braków',
   'UID','STRING[15]','Unikalny identyfikator operacji'
);
Cntx.psh(ZGH,ZGP,NASZGP);
ZGP.clear();

{? ZGP.seek(_a)
|| _my_zgh:=ZGP.NRZLP;
   _my_il:=ZGP.NRZLP().ILNPRZ;
   _args:=exec('find_uid_a','zl_guide');
   _args.BRAKIUID:=ZGP.BRAKIUID;
   {? ZGP.TPZ='T'
   ||
::    Jezeli operacja jest Tpz, to nastepnikiem jest operacja glowna
      ZGP.cntx_psh();
      ZGP.index('UID');
      ZGP.prefix(ZGP.UID_TPZ);
      {? ZGP.first()
      || _tab.REF:=#ZGP.ref();
         _tab.SQLREF:=$ZGP.ref();
         _tab.IL:=ZGP.IL;
         _tab.IL_BRAK:=ZGP.IL_BRAK;
         _tab.STATUS:=ZGP.STATUS;
         _tab.TPZ:=ZGP.TPZ;
         _tab.NRP:=ZGP.NRP;
         _tab.OPIS:=ZGP.OPIS;
         _ilnprz:={? ZGP.NRZLP=_my_zgh || ZGP.NRZLP().ILNPRZ || _my_il ?};
         _tab.COEF:={? _ilnprz=0 || 1 || ZGP.NRZLP().ILNPRZ/_ilnprz ?};
         {? _tab.COEF=0 || _tab.COEF:=1 ?};
         _tab.ZGH:=$ZGP.NRZLP;
         _tab.WEW:=ZGP.WEW;
         _tab.IL_KOOP:=ZGP.IL_KOOP;
         _tab.ILOSC:=ZGP.ILOSC;
         _tab.NAPRAW:=ZGP.NAPRAW;
         _tab.BRAKI_K:=$ZGP.BRAKI_K;
         _args.ZGP:=ZGP.ref();
         _tab.UID:=exec('find_uid','zl_guide',_args);
         _tab.add()
      ?};
      ZGP.cntx_pop()
   ||
::    Jezeli operacja glowna, to przetwarzam nastepniki (NASZGP)
      NASZGP.index('OPNAST');
      NASZGP.prefix(ZGP.ref());
      {? NASZGP.first()
      || {!
         |?
            NASZGP.NRNAST();
::          Jezeli nastepnik ma Tpz, to on jest nastepnikiem
            ZGP.cntx_psh();
            ZGP.index('TPZ');
            ZGP.prefix('T',ZGP.UID);
            {? ZGP.first()
            || _tab.REF:=#ZGP.ref();
               _tab.SQLREF:=$ZGP.ref();
               _tab.IL:=ZGP.IL;
               _tab.IL_BRAK:=ZGP.IL_BRAK;
               _tab.STATUS:=ZGP.STATUS;
               _tab.TPZ:=ZGP.TPZ;
               _tab.NRP:=ZGP.NRP;
               _tab.OPIS:=ZGP.OPIS;
               _ilnprz:={? ZGP.NRZLP=_my_zgh || ZGP.NRZLP().ILNPRZ || _my_il ?};
               _tab.COEF:={? _ilnprz=0 || 1 || ZGP.NRZLP().ILNPRZ/_ilnprz ?};
               {? _tab.COEF=0 || _tab.COEF:=1 ?};
               _tab.ZGH:=$ZGP.NRZLP;
               _tab.WEW:=ZGP.WEW;
               _tab.IL_KOOP:=ZGP.IL_KOOP;
               _tab.ILOSC:=ZGP.ILOSC;
               _tab.NAPRAW:=ZGP.NAPRAW;
               _tab.BRAKI_K:=$ZGP.BRAKI_K;
               _args.ZGP:=ZGP.ref();
               _tab.UID:=exec('find_uid','zl_guide',_args);
               _tab.add();
               _tpz:=1
            || _tpz:=0
            ?};
            ZGP.cntx_pop();
            {? ~_tpz
            || _tab.REF:=#ZGP.ref();
               _tab.SQLREF:=$ZGP.ref();
               _tab.IL:=ZGP.IL;
               _tab.IL_BRAK:=ZGP.IL_BRAK;
               _tab.STATUS:=ZGP.STATUS;
               _tab.TPZ:=ZGP.TPZ;
               _tab.NRP:=ZGP.NRP;
               _tab.OPIS:=ZGP.OPIS;
               _ilnprz:={? ZGP.NRZLP=_my_zgh || ZGP.NRZLP().ILNPRZ || _my_il ?};
               _tab.COEF:={? _ilnprz=0 || 1 || ZGP.NRZLP().ILNPRZ/_ilnprz ?};
               {? _tab.COEF=0 || _tab.COEF:=1 ?};
               _tab.ZGH:=$ZGP.NRZLP;
               _tab.WEW:=ZGP.WEW;
               _tab.IL_KOOP:=ZGP.IL_KOOP;
               _tab.ILOSC:=ZGP.ILOSC;
               _tab.NAPRAW:=ZGP.NAPRAW;
               _tab.BRAKI_K:=$ZGP.BRAKI_K;
               _args.ZGP:=ZGP.ref();
               _tab.UID:=exec('find_uid','zl_guide',_args);
               _tab.add()
            ?};
            NASZGP.next()
         !}
      ?}
   ?}
?};
Cntx.pop(ZGH,ZGP,NASZGP);
_tab


\il_na_poprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MW [12.41]
:: OPIS: zwraca ilość z poprzednika
::   WE: _a - ZGP.ref() - ref pozycji przewodnika
::  OLD: \il_na_poprz/zl_koop.fml
::----------------------------------------------------------------------------------------------------------------------
_il:=exec('il_pop','zl_guide',_a);
_il.IL_POP


\sprdk2zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MW [12.41]
:: OPIS: sprawdz czy pozycje dokumentu sa powiazane z pozycjami przewodnika i czy jest wykonanie do nastepnika
::   WE: _a - ND.ref
::   WY: 1 - blokada wycofania, 0 brak blokady
::  OLD: \sprdk2zgp/zl_koop.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
{? exec('get','#params',500631,2)='T'
|| ND.cntx_psh();
   DK.cntx_psh();
   DK.index('DOKMAG');
   DK.prefix(ND.ref());
   {? DK.first()
   || {!
      |? {? DK.ZGP<>null
         || ZGP.cntx_psh();
            ZGP.prefix();
            {? ZGP.seek(DK.ZGP)
            || _wyn:=exec('obl_ilw','zl_guide')>0
            ?};
            ZGP.cntx_pop()
         ?};
         ~_wyn & DK.next()
      !}
   ?};
   ND.cntx_pop();
   DK.cntx_pop()
?};
_wyn


\obl_ilw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Oblicza ilosc wykonana dla nastepnej operacji. Dziala w konktekscie aktywnego ZGP
::  OLD: \obl_ilw/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_next:=exec('tab_zgp_next','zl_guide',ZGP.ref());
_ilwyk:=0;
_napraw:=ZGP.NAPRAW;
_braki_k:=$ZGP.BRAKI_K;
{? _next.first()
|| {!
   |? {? _next.TPZ='T'
      ||
         ZGP.cntx_psh();
         ZGP.clear();
         {? ZGP.seek(_next.REF,)
         || _next1:=exec('tab_zgp_next','zl_guide',ZGP.ref());
            {? _napraw=_next1.NAPRAW & (_napraw='N' | (_napraw='T' & _braki_k=_next1.BRAKI_K))
            ||
::             Obliczam wykonania dla następnej operacji tylko z tych samych operacji pod względem
::             rodzaju naprawcza/zwykła lub z tej samej ścieżki naprawczej. Pozwala to usunąć wykonanie na operacji naprawczej, której
::             następnikiem jest operacja zwykła która ma już wykonania ale utworzone wcześniej i pochodzące
::             ze zwykłej a nie naprawczej ścieżki, lub z zupełnie innej ścieżki naprawczej która mogła już zostać zakończona
               {? _next1.IL>_ilwyk
               || _ilwyk:=_next1.IL
               ?}
            ?};
            obj_del(_next1)
         ?};
         ZGP.cntx_pop()
      ||
         {? ZGP.NAPRAW=_next.NAPRAW & (ZGP.NAPRAW='N' | (ZGP.NAPRAW='T' & $ZGP.BRAKI_K=_next.BRAKI_K))
         ||
::          Obliczam wykonania dla następnej operacji tylko z tych samych operacji pod względem
::          rodzaju naprawcza/zwykła lub z tej samej ścieżki naprawczej. Pozwala to usunąć wykonanie na operacji naprawczej, której
::          następnikiem jest operacja zwykła która ma już wykonania ale utworzone wcześniej i pochodzące
::          ze zwykłej a nie naprawczej ścieżki, lub z zupełnie innej ścieżki naprawczej która mogła już zostać zakończona
            {? _next.IL>_ilwyk
            || _ilwyk:=_next.IL
            ?}
         ?}
      ?};
      _next.next()
   !}
?};
_ilwyk


\zgp_dolp
::----------------------------------------------------------------------------------------------------------------------
:: UTW: GZ [2009]
:: OPIS: sprawdza możliwość dodania nowej pozycji do przewodnika zlecenia
::  OLD: \zgp_dolp/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

{? exec('przp_pd','zl_guide')
|| {? exec('edit_prz','zl_guide')
   || exec('po_dol','zl_guide')
   ?}
?};
0


\po_dol
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Po dołączenu pozycji przewodnika
::  OLD: \po_dol/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
exec('add_mod_pos','zl_common','mp','Dołączenie nowej pozycji przewodnika o numerze '+form(ZGP.NRP))


\przp_pd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.53] OWwPR007/5.2
:: OPIS: przed dołączeniem pozycji przewodnika
::  OLD: \przp_pd/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
:: TODO: sprawdzac zakończenie przewodnika
:: sprawdzenie akceptacji zlecenia
::{? exec('czy_zatw_zgh','zlec5',VAR.A_NRPRZ().ZLEC,1)
::|| FUN.emsg(
::      'Dołączenie pozycji niemożliwe. Zlecenie '+
::      exec('FindAndGet','#table',ZL,#ZGP.NRPRZ().ZLEC,ZL.name(),"SYM",'')+
::      ' zatwierdzone pod względem przewodników.'
::   );
::   return(0)
::|? exec('czy_zatw_zgh','zlec5',VAR.A_NRZLP().ZLEC,1)
::|| FUN.emsg(
::      'Dołączenie pozycji niemożliwe. Zlecenie '+
::      exec('FindAndGet','#table',ZL,#ZGP.NRZLP().ZLEC,ZL.name(),"SYM",'')+
::      ' zatwierdzone pod względem przewodników.'
::   );
::   return(0)
::?};

{? ZGH.STAT_REJ='T'
|| {? ~FUN.ask('Zakończono już rejestrację przewodnika %1.'@[ZGH.NRPRZ]+'\n\n'+'Czy dołączyć nową pozycję?'@)
   || return(0)
   ?}
?};

{? ZL.RODZAJ='Z' & ZL.GENPRZEW='N' & ZL.STAN='N'
|| FUN.info(
      'Nie można dodawać ręcznie pozycji.\n\n'
      'Akcja możliwa tylko dla przewodników generowanych dla zleceń podrzędnych.'@
   );
   0
|| VAR1.TPZ:='N';
   VAR1.ZAW:=null();
   VAR1.COEF1:=0;
   VAR1.FCOEF1:='';
   VAR1.NTIME1:=0;
   VAR1.FNTIME1:='';
   VAR1.STAWKA1:=0;
   VAR1.PLNH1:=0;
   VAR1.PLNX:=0;
   VAR1.CIAGLA:='T';
   VAR1.HARM:='N';
   VAR.IL_PLAN:=0;
   _ask:=choice('Dodawana pozycja jest:'@,FUN.TYT,'ASK',1,0,,'Wewnętrzna'@,'Zewnętrzna'@,'Anuluj'@);
   {? _ask=2
   || 0
   |? _ask=0
   || VAR.A_WEW:='T';
      ZGP.win_edit('RED');
      {? ZL.RODZAJ='P'
      || VAR.A_NRZLP:=ZGH.ref()
      ?};
      1
   |? _ask=1
   || VAR.A_WEW:='N';
      VAR.A_NRZLP:=ZGH.ref();
      ZGP.win_edit('RED_OUT');
      1
   ?}
?}


\edit_prz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: redagowanie pozycji przewodnika (dołączanie)
::   WE: [_a] - REAL - ilośc na pozycji przewodnika, jeśli nie podana to ilość pochodzi z aktualnego ZGPa
::       [_b] - STRING - 'T'/'N' - czy operacja naprawcza czy nie, domyślnie 'N'
::       [_c] - STRING - typ operacji naprawczej
::       [_d] - BRAKI_K.ref - kwalifikacja braków do której podłączyć operację naprawczą
::       [_e] - INTEGER - numer operacji naprawczej
::  OLD: \edit_prz/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_ilosc:=0;
{? var_pres('_a')=type_of(0)
|| _ilosc:=_a
?};
_napraw:='';
{? var_pres('_b')=type_of('')
|| _napraw:=_b
?};
_napr_type:='';
{? var_pres('_c')=type_of('')
|| _napr_type:=_c
?};
_braki_k:=null();
{? var_pres('_d')=type_of(BRAKI_K.ref())
|| _braki_k:=_d
?};
_zgp_nr:=-1;
{? var_pres('_e')=type_of(0)
|| _zgp_nr:=_e
?};

{? ZGP.NRP=0 || ZGP.NRP:=1 ?};
_nr:=ZGP.NRP;
_nrp:=VAR.A_NRZLP().NRPRZ;
ZGP.blank();
ZGP.memo_set('','OPISMEMO');

{? _napraw<>''
|| ZGP.NAPRAW:=_napraw
?};
{? _napr_type<>''
|| ZGP.NAPR_TYP:=_napr_type
?};
{? _braki_k<>null()
|| ZGP.BRAKI_K:=_braki_k
?};
{? _zgp_nr>=0
|| ZGP.NRP:=_zgp_nr
|| {? -menu_txt()<>'dołącz'
   || ZGP.NRP:=_nr+1
   || ZGP.NRP:=_nr
   ?}
?};
{? _ilosc>0
|| ZGP.ILOSC:=_ilosc
|| ZGP.ILOSC:=ZGP.NRZLP().ILNPRZ
?};
PFAZ.clear();
PFAZ.f_set('KOD');
FILTER.PFAZ:=0;
exec('zgp_efld_opt','zl_guide');
{? ZGP.edit("exec('przpo','zl_guide')")
|| _nr:=ZGP.NRP;
   ZGP.cntx_psh();
   ZGP.index('NRPP');
   ZGP.prefix(VAR.A_NRPRZ,'N',_nrp);
   NASZGP.cntx_psh();
   NASZGP.index('NASTOP');
   _ok:=1;
   {? ZGP.last()
   || {!
      |?
         {? ZGP.NRP<_nr
         || _ok:=0
         || ZGP.NRP+=1;
            {? ZGP.put()
            || ZGP.cntx_psh();
               ZGP.prefix(VAR.A_NRPRZ,'T',_nrp,ZGP.NRP-1);
               {? ZGP.first()
               || ZGP.NRP+=1;
::                ZGP.TPZREF:=ZGP.NRP;
                  ZGP.clear();
                  ZGP.put()
               ?};
               ZGP.cntx_pop()
            ?};
            NASZGP.prefix(ZGP.ref());
            {? NASZGP.first()
            || {!
               |? _sciezka:=#NASZGP.SCIEZKA;
                  _sciezka+=1;
                  NASZGP.SCIEZKA:=$_sciezka;
                  NASZGP.put();
                  NASZGP.next()
               !}
            ?}
         ?};
         _ok & ZGP.prev()
      !}
   ?};
   ZGP.cntx_pop();
   NASZGP.cntx_pop();
   {? -menu_txt()='pozycje'
   || _add:=ZGP.add();
      {? _add || ZGP.memo_put(,'OPISMEMO') ?};
      _res:=0
   || _add:=ZGP.add();
      {? _add || ZGP.memo_put(,'OPISMEMO') ?};
      _res:=_add
   ?};
   {? _add
   || exec('przp_aft','zl_guide')
   ?};
   _res
|| 0
?}


\przpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: 'Po rekord' ZGP (formuła wykorzystywana również w formułach walidujących)
::   WY: wynik zgodny z chk_rec()
::  OLD: \przpo/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
:: Podczytanie odpowiedniego ZGH
{? ZL.NRNZL<>0
|| ZGP.NRZLP().NRPRZ
|| ZGP.NRPRZ().NRPRZ
?};

_start:=exec('create','#tm_stamp',ZGP.STARTD,ZGP.STARTT);
_end:=exec('create','#tm_stamp',ZGP.ENDD,ZGP.ENDT);
_start_tpz:=exec('create','#tm_stamp',VAR1.STARTD,VAR1.STARTT);
_end_tpz:=exec('create','#tm_stamp',VAR1.ENDD,VAR1.ENDT);

{? ZGP.WEW='N'
|| _res:=__CHK.record(ZGP,,'OPIS')
|| _res:=__CHK.record(ZGP,,'OPIS','PLACE')
?};

{? _res=''
|| {? ZGP.NTIME=0 & ZGP.MTIME=0 & ZGP.WEW='T'
   || FUN.emsg('Czas maszynowy lub norma czasowa musi być różna od zera.'@);
      return('NTIME')
   |? VAR1.NTIME1=0 & VAR1.TPZ='T'
   || FUN.emsg('Norma czasowa operacji TPZ musi być różna od zera.'@);
      return('NTIME1')
::   |? VAR1.PLNH1=0 & VAR1.TPZ='T'
::   || FUN.emsg('Stawka godzinowa operacji TPZ musi być różna od zera.'@);
::      return('PLNH1')
   |? _start>_end
   || FUN.emsg('Koniec operacji nie może być wcześniejszy niż początek.'@);
      return('ENDD')
   |? VAR1.TPZ='T' & _start_tpz>_end_tpz
   || FUN.emsg('Koniec operacji TPZ nie może być wcześniejszy niż początek.'@);
      return('TPZ')
   ?}
?};

{? _res=''
|| {? ZGP.NTIME=0 & ZGP.BRYG='T'
   || FUN.info('Dla operacji z samym czasem maszynowym nie można ustawić rozliczenia brygadowego.'@);
      return('NTIME')
   ?}
?};

{? exec('tpp_lic','tpp')='T' & ZGP.WEW='N' & _res='' & ZGP.PLANUJ='T'
|| _msg:='';
   {? ZGP.DAYS_K=0                              || _msg:='• '+'Szacunkowa ilość dni na kooperację'@+'\n' ?};
   {? ZGP.PX_KONT=null()
      & exec('get','#params',500361,1,null())=0 || _msg+='• '+'Zasób kooperacyjny lub parametr %1'@['500361']+'\n' ?};
   {? _msg<>''
   || _msg:='Wskazane jest uzupełnienie danych, o ile będą wykorzystywane moduły planowania:'@+'\n\n'+_msg;
      {? FUN.choice(_msg,,'Powrót do redagowania'@,,,,'Kontynuuj')=1
      || _res:='DAYS_K'
      ?}
   ?}
?};

{? _res='' & ZGP.WEW='N' & ZGP.SRW='M' & ZGP.KONTRAH=null()
|| FUN.info(
     'Dla operacji zewnętrznych, rejestrowanych przez moduł magazynowy,\nwskazane jest uzupełnienie kontrahenta.'@
   )
?};
{? _res='' & ZGP.KJ_BAD='B' & ZGP.BADSEH=null()
|| FUN.emsg('Należy wybrać zestaw badań, używany podczas kontroli jakości.'@);
   _res:='BADSEH'
?};
{? _res='' & ZGP.WYK_FAST='T'
|| {? ZGP.KJ_BAD<>'N'
   || _res:='WYK_FAST';
      FUN.emsg('Operacja ze sposobem potwierdzania nie może być rejestrowana w szybki sposób.'@)
   |? ZGP.BRYG='T'
   || _res:='WYK_FAST';
      FUN.emsg('Operacja wykonywana przez brygadę nie może być rejestrowana w szybki sposób.'@)
   |? ZGP.PL_GRP='T'
   || _res:='WYK_FAST';
      FUN.emsg('Operacja planowana grupowo nie może być rejestrowana w szybki sposób.'@)
   ?}
?};
_res


\plan_out_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Formuła walidacyjna dla danych dodatkowych do planowania dla pozycji przewodnika
::   WY: jak dla chk_rec()
::  OLD: \plan_out_chk/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.GRP_MOD<>'P' & ZGP.WEW='N' & ZGP.STARTDK<>date(0,0,0) & ZGP.STARTDK<ZL.OD
|| _msg:='Początek kooperacji nie może być wcześniejszy niż data powołania zlecenia (%1).'@[$ZL.OD];
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','zl_guide')+_msg)
   || FUN.emsg(_msg)
   ?};
   return('STARTDK')
|? VAR.GRP_MOD<>'P' & ZGP.WEW='N' & ZL.PL_DATA<>date(0,0,0) &
   (
      _end:=exec('create','#tm_stamp',ZGP.ENDDK,ZGP.ENDTK);
      _termin:=exec('create','#tm_stamp',ZL.PL_DATA,ZL.PL_TIME);
      _end>_termin
   )
|| _msg:='Koniec kooperacji nie może być późniejszy niż wewnętrzny termin realizacji zlecenia (%1).'@
         [$ZL.PL_DATA+{? ZL.PL_TIME=time(0,0,0) || '' || ' '+$ZL.PL_TIME ?}];
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','zl_guide')+_msg)
   || FUN.emsg(_msg)
   ?};
   return('ENDDK')
|? ZGP.WEW='N' &
   (
      _start:=exec('create','#tm_stamp',ZGP.STARTDK,ZGP.STARTTK);
      _end:=exec('create','#tm_stamp',ZGP.ENDDK,ZGP.ENDTK);
      _start<>0 & _end<>0 & _start=_end
   )
|| _msg:='Koniec kooperacji nie może być taki sam jak początek.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','zl_guide')+_msg)
   || FUN.emsg(_msg)
   ?};
   return('ENDDK')
|? ZGP.WEW='N' &
   (
      _start:=exec('create','#tm_stamp',ZGP.STARTDK,ZGP.STARTTK);
      _end:=exec('create','#tm_stamp',ZGP.ENDDK,ZGP.ENDTK);
      _start<>0 & _end<>0 & _start>_end
   )
|| _msg:='Koniec kooperacji nie może być wcześniejszy niż początek.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','zl_guide')+_msg)
   || FUN.emsg(_msg)
   ?};
   return('ENDDK')
|? VAR.GRP_MOD<>'P' & ZGP.WEW='N' & ZGP.STARTDK=date(0,0,0)
|| _msg:='Początek kooperacji musi być określony.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','zl_guide')+_msg)
   || FUN.emsg(_msg)
   ?};
   return('STARTDK')
|? VAR.GRP_MOD<>'P' & ZGP.WEW='N' & ZGP.ENDDK=date(0,0,0)
|| _msg:='Koniec kooperacji musi być określony.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','zl_guide')+_msg)
   || FUN.emsg(_msg)
   ?};
   return('ENDDK')
|? VAR.GRP_MOD<>'P' & ZGP.WEW='N' & ZGP.PX_KONT=null()
|| _msg:='Zasób kooperacyjny musi być określony.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','zl_guide')+_msg)
   || FUN.emsg(_msg)
   ?};
   return('PX_KONT')
?};
''


\przp_aft
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Akcja po dołącz, popraw na pozycji przewodnika.
::   WE: [_a] - rodzaj akcji: [1] - dołącz, 0 - popraw
::  OLD: \przp_aft/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_add:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_nrp:=ZGP.NRP;
_nrprz:=ZGP.NRPRZ;
_nrzlp:=ZGP.NRZLP;
_place:=ZGP.PLACE;
_bryg:=ZGP.BRYG;
_opis:=ZGP.OPIS;
_po:=ZGP.PO;
_kontrola:=ZGP.KONTROLA;
_kj_bad:=ZGP.KJ_BAD;
_badseh:=ZGP.BADSEH;
_ilosc:=ZGP.ILOSC;
_pfaz:=ZGP.PFAZ;
_uid:=ZGP.UID;

{? VAR1.TPZ='N'
||
:: znajdujemy czy była przypisana operacja tpz - jeżeli nie, to usuwamy
   ZGP.cntx_psh();
   ZGP.index('TPZ');
   ZGP.prefix('T',_uid);
   {? ZGP.first()
   || ZGP.del()
   ?};
   ZGP.cntx_pop()
|| ZGP.cntx_psh();
   ZGP.index('TPZ');
   ZGP.prefix('T',_uid);
   {? ZGP.first()
   || ZGP.ZAW:=VAR1.ZAW;
      ZGP.NTIME:=VAR1.NTIME1;
      ZGP.CIAGLA:=VAR1.CIAGLA;
      ZGP.BRYG:=_bryg;
      ZGP.PLNH:=VAR1.PLNH1;
      ZGP.PLNX:=VAR1.PLNX;
      ZGP.OPIS:='TPZ - '+_opis;
      ZGP.PO:=_po;
      ZGP.PLACE:=_place;
      ZGP.NRPRZ:=_nrprz;
      ZGP.NRZLP:=_nrzlp;
      ZGP.STARTD:=VAR1.STARTD;
      ZGP.STARTT:=VAR1.STARTT;
      ZGP.ENDD:=VAR1.ENDD;
      ZGP.ENDT:=VAR1.ENDT;
      ZGP.PFAZ:=_pfaz;
      ZGP.ILOSC:=_ilosc;
      ZGP.KONTROLA:=_kontrola;
      ZGP.KJ_BAD:='N';
      ZGP.BADSEH:=null();
      ZGP.prefix();
      ZGP.put()
   || ZGP.blank();
      ZGP.WEW:='T';
      ZGP.NRP:=_nrp;
      ZGP.TPZ:='T';
      ZGP.ZAW:=VAR1.ZAW;
      ZGP.NTIME:=VAR1.NTIME1;
      ZGP.CIAGLA:=VAR1.CIAGLA;
      ZGP.PLNH:=VAR1.PLNH1;
      ZGP.PLNX:=VAR1.PLNX;
      ZGP.OPIS:='TPZ - '+_opis;
      ZGP.PO:=_po;
      ZGP.BRYG:=_bryg;
::      ZGP.TPZREF:=_nrp;
      ZGP.UID_TPZ:=_uid;
      ZGP.PLACE:=_place;
      ZGP.NRPRZ:=_nrprz;
      ZGP.NRZLP:=_nrzlp;
      ZGP.STARTD:=VAR1.STARTD;
      ZGP.STARTT:=VAR1.STARTT;
      ZGP.ENDD:=VAR1.ENDD;
      ZGP.ENDT:=VAR1.ENDT;
      ZGP.PFAZ:=_pfaz;
      ZGP.ILOSC:=_ilosc;
      ZGP.KONTROLA:=_kontrola;
      ZGP.prefix();
      ZGP.add()
   ?};
   ZGP.cntx_pop()
?};
:: Aktualizacja statusów pozycji przewodników
exec('recover_sta_zgh','zl_guide',ZGP.NRZLP);

:: Aktualizacja przepisu planistycznego zlecenia (jeżeli istnieje)
_p500369:=exec('get','#params',500369,type_of(''));
{?  _p500369='T' & ZGP.ZL<>null() & exec('get_tex_zl','px_tex',ZGP.ZL)
|| exec('zl_tex_update','px_tex',ZGP.ZL,1)
?};

:: Aktualizacja terminów na limitach
exec('zlim_dates_upd','zl_limit',ZGP.ref());

:: Aktualizacja granic czasowych w planie strategicznym
{? ZGP.WEW='N'
|| exec('bounds_update','po_plan',ZGP.ref())
?};
~~


\recover_sta_zgh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Odtwarza statusy pozycji przewodników dla wskazanego przewodnika
::   WE: _a - ZGH.ref() (nie jest sprawdzana obecność ani typ parametru)
::  OLD: \recover_sta_zgh/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(ZL,ZGH,ZGP);

_sta_new:=exec('status_new','zl_guide');
_sta_pen:=exec('status_pending','zl_guide');
_sta_end:=exec('status_end','zl_guide');

:: Robocza tabela ZGH
_zgh:=tab_tmp(1,'REF','STRING[16]','$ZGH.ref()');

:: Wstępne wyzerowanie statusów dla pozycji przewodnika
ZGP.index('PNRPP');
ZGP.prefix(_a);
{? ZGP.first()
||
   _zgh.prefix($ZGP.NRZLP);
   {? ~_zgh.first()
   || _zgh.REF:=$ZGP.NRZLP;
      _zgh.add()
   ?};
   {!
   |?
::    Ustalenie statusu początkowego
      {? ZGP.NRPRZ().ZLEC().STAN='N'
      || ZGP.STATUS:=_sta_new
      |? ZGP.NRPRZ().STAN='T'
      || ZGP.STATUS:=_sta_end
      ||
::       Jeżeli nie ma poprzedników, to możliwa do rejestracji
         _prev:=exec('tab_zgp_prev','zl_guide',ZGP.ref());
         {? _prev.first()
         || ZGP.STATUS:=_sta_new;
            {!
            |? _zgh.prefix(_prev.ZGH);
               {? ~_zgh.first()
               || _zgh.REF:=_prev.ZGH;
                  _zgh.add()
               ?};
               _prev.next()
            !}
         || ZGP.STATUS:=_sta_pen
         ?};
         obj_del(_prev)
      ?};
      ZGP.put();
      ZGP.next()
   !}
?};

:: Pobieramy ZLGD powiązane z obrabianymi przewodnikami
_zgh.prefix();
{? _zgh.first()
||
   {!
   |? _zlgd:=exec('zlgd_zgh','zl_guide',_zgh.REF);
::    Naniesienie wykonań na statusy (wyzwalane triggery dla pobranych ZLGD)
      {? _zlgd.first()
      || {!
         |? exec('FindAndGet','#table',ZLGD,_zlgd.REF,,"put()");
            _zlgd.next()
         !}
      ?};
      obj_del(_zlgd);
      _zgh.next()
   !}
?};

Cntx.pop(ZL,ZGH,ZGP);
~~


\ppopr_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Przed popraw pozycji przewodnika
::  OLD: \ppopr_zgp/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~exec('zgp_popp','zl_guide') || return(0) ?};
{? ZGP.NRPRZ().STAN='N' & ZGP.NRZLP().STAN='N'
|| {? VAR.ZM_ROPER='T'
   ||
::    Akcja Zmiana rodzaju operacji - ustalenie wartości pól dla ZGP
      _res:=exec('wew_change','zl_guide')
   || _res:=1
   ?};
   exec('przp_dsp','zl_guide');
   lp:=ZGP.NRP;
   stan:=ZGP.PLACE;
   mtime:=ZGP.MTIME;
   _res
|| FUN.info('Nie można modyfikować pozycji już oddanego przewodnika.'@);
   0
?}


\zgp_popp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Po 'Popraw' pozycji przewodnika
::   WY: 0 / 1
::  OLD: \zgp_popp/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=1;

{? VAR.ZM_ROPER<>'T' & ZGH.STAT_REJ='T'
|| {? ~FUN.ask('Zakończono już rejestrację przewodnika %1.'@[ZGH.NRPRZ]+'\n\n'+'Czy poprawić pozycję?'@)
   || _result:=0
   ?}
?};

:: Sprawdzam czy pozycja przewodnika znajduje się w planie operacyjnym
{? _result>0 & exec('zgp_utilization','po_plan',1,ZGP.ref())>0
|| FUN.emsg('Pozycja przewodnika została zaplanowana w Planie operacyjnym i nie może być modyfikowana.'@);
   _result:=0
?};

{? _result>0
|| {? exec('spr_akord','zl_guide')
   || {? VAR.ZM_ROPER<>'T' & ZGP.TOPER<>null()
      || FUN.info('Pozycja powiązana z technologią nie powinna być modyfikowana.'@)
      ?};
      _result:=1
   || FUN.info('Pozycja z zarejestrowanymi wykonaniami nie może być modyfikowana.'@);
      _result:=0
   ?}
?};

{? _result
|| PFAZ.clear();
   PFAZ.f_set('KOD');
   FILTER.PFAZ:=0
?};
_result


\zgp_popopr
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Po popraw pozycji przewodnika
::  OLD: \zgp_popopr/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
exec('przp_aft','zl_guide',0);
&lp;
&stan;
&mtime


\przp_dsp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.53] OWwPR007/5.2
:: OPIS: Ustawienie okna i kolorowanie pozycji przewodnika
::       oraz wylicza ilość wykonaną do VAR.IL
::  OLD: \przp_dsp/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
{? ZGP.WEW='T'
|| VAR.A_WEW:='T';
   ZGP.win_edit({? VEK.TERM='T' || 'EK' || 'RED' ?});
   _wyn:=0
|| VAR.A_WEW:='N';
   ZGP.win_edit({? VEK.TERM='T' || 'EK_OUT' || 'RED_OUT' ?});
   _wyn:=1
?};
ZGP.NRZLP();

VAR.IL:=ZGP.IL;
VAR.REAL:={? ZGP.ILOSC=0 || 0 || VAR.IL/ZGP.ILOSC*100 ?};
VAR.STRING:='';
VAR.G_STARTD:={? ZGP.WEW='T' || ZGP.STARTD || ZGP.STARTDK ?};
VAR.G_STARTT:={? ZGP.WEW='T' || ZGP.STARTT || ZGP.STARTTK ?};
VAR.G_ENDD:={? ZGP.WEW='T' || ZGP.ENDD || ZGP.ENDDK ?};
VAR.G_ENDT:={? ZGP.WEW='T' || ZGP.ENDT || ZGP.ENDTK ?};

TOPER.cntx_psh();
_nrop:=exec('FindAndGet','#table',TOPER,#ZGP.TOPER,ref_name(ZGP.TOPER),"NRNOP",0);
{? _nrop<>0
||
   _mask:=TOPER.name();
   _mask_needed:=ref_name(ZGP.TOPER);
   {? _mask<>_mask_needed
   || TOPER.use(_mask_needed)
   ?};
   TOPER.index('UNROP');
   {!
   |? TOPER.prefix(_nrop);
      {? TOPER.first()
      || VAR.STRING:=form(TOPER.NROP)+'.'+TOPER.NA+'/'+VAR.STRING;
         _nrop:=TOPER.NRNOP;
         TOPER.NRNOP<>0
      || 0
      ?}
   !}
?};

VAR.STRING:=VAR.STRING-1;
{? +VAR.STRING>39 & VAR.STRING*'/'>0
|| {!
   |? _str:=VAR.STRING;
      _nr:=0;
      {!
      |? _nr+=_str*'/';
         _str:=_str*'/'-_str;
         _str*'/'>0
      !};
      VAR.STRING:=_nr+VAR.STRING;
      VAR.STRING:=VAR.STRING-1;
      _str:=VAR.STRING;
      +VAR.STRING>39 & VAR.STRING*'/'>0
   !};
   VAR.STRING+='/...'
?};
TOPER.cntx_pop();
VAR.A_ZGP:=ZGP.ref();
ZL.cntx_pop();

VAR.IL_PLAN:=exec('zgp_planned','po_plan');
exec('prepzch','zl_guide');
exec('zgp_efld_opt','zl_guide');
{? _wyn
|| 'ZGP#01#01'
|? VAR1.TPZ='T'
|| 'ZGP#01#02'
|| ''
?}


\prepzch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Przygotowanie zmiennych dla okna ZGP.
::  OLD: \prepzch/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
ZGP.cntx_psh();
VAR_DEL.delete('__ZGPTPZ');
ZGP.index('TPZ');
ZGP.prefix('T',ZGP.UID);
{? ZGP.first() & VAR.ZM_ROPER<>'T'
|| VAR1.TPZ:='T';
   __ZGPTPZ:=ZGP.ref();
   VAR1.ZAW:=ZGP.ZAW;
   VAR1.NTIME1:=ZGP.NTIME;
   VAR1.PLNH1:=ZGP.PLNH;
   VAR1.PLNX:=ZGP.PLNX;
   VAR1.COEF1:=exec('FindAndGet','#table',TOPER,ZGP.TOPER,,"COEF",0);
   VAR1.STAWKA1:={? VAR1.COEF1<>0 || (VAR1.PLNH1/{? VAR1.COEF1=0 || 1 || VAR1.COEF1 ?})$2 || 0 ?};
   VAR1.CIAGLA:=ZGP.CIAGLA;
   VAR1.HARM:=ZGP.HARM;
   VAR1.ZGP_STAT:=ZGP.STATUS;
   VAR1.PROBLEM:=ZGP.PROBLEM;
   VAR1.PROBKLAS:=ZGP.PROBKLAS;
   VAR1.STARTD:=ZGP.STARTD;
   VAR1.STARTT:=ZGP.STARTT;
   VAR1.ENDD:=ZGP.ENDD;
   VAR1.ENDT:=ZGP.ENDT
|| VAR1.TPZ:='N';
   VAR1.ZAW:=null();
   __ZGPTPZ:=null();
   VAR1.STAWKA1:=0;
   VAR1.NTIME1:=0;
   VAR1.PLNH1:=0;
   VAR1.PLNX:=0;
   VAR1.COEF1:=0;
   VAR1.CIAGLA:='T';
   VAR1.HARM:='N';
   VAR1.ZGP_STAT:=exec('status_new','zl_guide');
   VAR1.PROBLEM:='N';
   VAR1.PROBKLAS:='';
   VAR1.STARTD:=date(0,0,0);
   VAR1.STARTT:=time(0,0,0);
   VAR1.ENDD:=date(0,0,0);
   VAR1.ENDT:=time(0,0,0)
?};
ZGP.cntx_pop();
~~


\zgp_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Usuwa pozycje przewodnika
::  OLD: \zgp_usun/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.GRUPA='N' || exec('zlim2zmian_zgp','zl_limit') ?};
{? exec('zgp_del','zl_guide',0) & type_of(params_get())>100 & var_pres('env',params_get())>0
|| params_get().env.ZLIM_reload:=1
?};
~~


\zgp_usun_gp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Przed grupa - dla usuwania pozycji przewodnika
::   WY: 1
::  OLD: \zgp_usun_gp/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask(
      'Ilość zaznaczonych pozycji przewodnika: %1.\n'
      'Czy usunąć wszystkie zaznaczone pozycje?'@[$ZGP.sel_size()]
   )
|| VAR.GRUPA:='T';
   sel_nchk();
   exec('zlim2zmian_zgp','zl_limit');
   KOMM.init(255,,'Usuwanie pozycji przewodników zlecenia'@);
   1
|| 0
?}


\zgp_usun_go
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Po grupie - dla usuwania pozycji przewodnika
::  OLD: \zgp_usun_go/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
{? KOMM.get_size()>0
|| KOMM.select()
?};
~~


\plan_out_red
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Redagowanie danych do planowania dla pozycji przewodnika
::  OLD: \plan_out_red/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_can_continue:=1;
{? ZGP.WEW='T'
|| _msg:='Dla operacji wewnętrznej nie są dostępne dane do planowania.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','zl_guide')+_msg)
   || FUN.info(_msg)
   ?};
   _can_continue:=0
|? ZGH.STAN='T'
|| _msg:='Przewodnik oddany — nie można redagować danych do planowania.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','zl_guide')+_msg)
   || FUN.info(_msg)
   ?};
   _can_continue:=0
|? VAR.A_ZLEC().STAN='Z'
|| _msg:='Zlecenie zamknięte — nie można redagować danych do planowania.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','zl_guide')+_msg)
   || FUN.info(_msg)
   ?};
   _can_continue:=0
?};
{? _can_continue>0
|| {? exec('zgp_utilization','po_plan',1,ZGP.ref())
   || _msg:='Zlecenie znajduje się w planie operacyjnym — nie można redagować danych do planowania.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','zl_guide')+_msg)
      || FUN.info(_msg)
      ?};
      _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: Musi być get() na wypadek gdy ktoś stał na rekordzie w oknie, a w planie w innym oknie dorzucił
:: to zlecenie, wtedy plan zaktualizuje ZGPa i jeśli się go nie podczyta to wybuchnie
   ZGP.get();
   _start_before:=ZGP.TMSTARTK;
   _end_before:=ZGP.TMENDK;
   ZGP.win_edit('PLAN_OUT');
   {? VAR.GRUPA<>'T'
   ||
::    Zapisanie aktualnego bufora, w celu późniejszego sprawdzenia, które pola zostały zmienione
      _buffer:=exec('obj_new','#buf','ZGP',);
      _buffer.get();
      params_set('buffer',_buffer)
   ?};
   exec('zgpo_efld_opt','zl_guide');
   _valid:="
      _res:='';
      _chk_plan:=1;
      {? type_of(params_get())>0 & var_pres('buffer',params_get())>100
      || _buffer_old:=params_get().buffer;
         _buffer_new:=exec('obj_new','#buf','ZGP',);
         _buffer_new.get();
         {? ~exec('compare','#table',_buffer_old,_buffer_new,0,'KONTRAH')
            & exec('compare','#table',_buffer_old,_buffer_new,1,'KONTRAH')
         ||
::          Zmodyfikowano tylko kontrahenta, nie są sprawdzane dane dot. planowania
            _chk_plan:=0
         ?}
      ?};
      {? _chk_plan>0
      || _res:=exec('plan_out_chk','zl_guide')
      ?};
      _res
   ";
   {? VAR.GRP_MOD='T' | ZGP.edit(_valid)
   || {? VAR.GRP_MOD='T'
      || _can_continue:=exec('zgpo_modify_frombfr','zl_guide',__BUFF_GRP)
      ?};
      {? _can_continue>0
      || ZGP.KOOP_AKC:='T';
         _can_continue:=ZGP.put()
      ?}
   ?};
   {? _can_continue>0
   ||
      {? _start_before<>ZGP.TMSTARTK | _end_before<>ZGP.TMENDK
      ||
::       Aktualizacja granic czasowych w planie operacyjnym
         exec('bounds_update','po_plan',ZGP.ref())
      ?}
   ?}
?};
~~


\plan_out_wyc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Wycofuje akceptację danych do planowania dla kooperacji
::   WY: STRING - wynik dla przycisku
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_can_continue:=1;
_result:='';

_choice:=FUN.choice('Wycofać akceptację danych do planowania?'@,,'Wycofaj'@,'Wycofaj i usuń dane'@);

{? _choice>0
|| ZGP.KOOP_AKC:='N';
   {? _choice=2
   ||
      ZGP.TMSTARTK:=0;
      ZGP.TMENDK:=0;
      ZGP.STARTDK:=date(0,0,0);
      ZGP.ENDDK:=date(0,0,0);
      ZGP.STARTTK:=time(0,0,0);
      ZGP.ENDTK:=time(0,0,0)
   ?};
   _can_continue:=ZGP.put()
|| _can_continue:=0
?};

{? _can_continue>0
|| _result:='key:Esc'
?};
_result


\legenda_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Legenda w oknie ZGP
::  OLD: \legenda_p/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','ZGP#01#','@ZGP#START','@ZGP#END','#ZGP#01','#ZGP#02','#ZGP#04','#ZGP#05')


\update_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Aktualizacja tabeli ZGP (pola ZGP.STATUS) na podstawie zapisów w tabelach ZL, ZGH, ZLGD (obsluga triggerów)
::   WE: _a - rodzaj triggera: 'add', 'put', 'del'
::       _b - tabela: ZL, ZGH, ZLGD
::   WY: wynik sterujący dla triggera, czyli ~~ albo 0/1
::  OLD: \update_zgp/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? _b=ZL
||
   {? _a='put'
   ||
::    - Przy uruchamianu przejście na status "wykonywana" dla operacji bez poprzedników,
::      ewentualnie jak mają Tpz, to dla nich.
::    - Przy cofaniu do uruchomionych odtworzenie statusów
::    - Przy zamykaniu przejście na status "zakończona" dla wszystkich operacji
      _before:=bfld('STAN'); _after:=ZL.STAN;
      {? _before='N' & _after='O'
      || _status:=exec('status_pending','zl_guide');
         ZGH.cntx_psh(); ZGP.cntx_psh();
         ZGH.index('ZLNR');
         ZGH.prefix(ZL.ref());
         {? ZGH.first()
         || {!
            |?
               ZGP.index('NRPP');
               ZGP.prefix(ZGH.ref());
               {? ZGP.first()
               || {!
                  |?
::                   Jezeli brak poprzednika, to operacja otwarta do rejestracji
                     _prev:=exec('tab_zgp_prev','zl_guide',ZGP.ref());
                     {? ~_prev.first()
                     || ZGP.STATUS:=_status;
                        ZGP.put()
                     ?};
                     obj_del(_prev);
                     ZGP.next()
                  !}
               ?};
               ZGH.next()
            !}
         ?};
         ZGH.cntx_pop(); ZGP.cntx_pop()
      |? _before='O' & _after='N'
      || _status:=exec('status_new','zl_guide');
         ZGP.cntx_psh();
         ZGP.index('ZLEC');
         ZGP.prefix(ZL.ref());
         {? ZGP.first()
         || {!
            |?
               ZGP.STATUS:=_status;
               ZGP.put();
               ZGP.next()
            !}
         ?};
         ZGP.cntx_pop()
      |? _before='O' & _after='Z'
      || _status:=exec('status_end','zl_guide');
         ZGP.cntx_psh();
         ZGP.index('ZLEC');
         ZGP.prefix(ZL.ref());
         {? ZGP.first()
         || {!
            |?
               ZGP.STATUS:=_status;
               ZGP.put();
               ZGP.next()
            !}
         ?};
         ZGP.cntx_pop()
      |? _before='Z' & _after='O'
      || ZGH.cntx_psh();
         ZGH.index('ZLNR');
         ZGH.prefix(ZL.ref());
         {? ZGH.first()
         || {!
            |? exec('recover_sta_zgh','zl_guide',ZGH.ref());
               ZGH.next()
            !}
         ?};
         ZGH.cntx_pop()
      ?};
      ~~
   ||
      ~~
   ?}
|? _b=ZGH
||
   {? _a='put'
   ||
      _before:=bfld('STAN'); _after:=ZGH.STAN;
      _bef_il:=bfld('ILNPRZ'); _aft_il:=ZGH.ILNPRZ;

      {? _before='N' & _after='T'
      ||
::       - Przy oznaczaniu przewodnika jako 'wykonany', analogicznie stemplowane wszystkie pozycje
::         (przy cofaniu przewodnika - pozycje pozostają zrealizowane)
         _status:=exec('status_end','zl_guide');
         ZGP.cntx_psh();
         ZGP.index('NRPP');
         ZGP.prefix(ZGH.ref());
         {? ZGP.first()
         || {!
            |?
               ZGP.STATUS:=_status;
               ZGP.put();
               ZGP.next()
            !}
         ?};
         ZGP.cntx_pop()
      |? _bef_il<>_aft_il
      ||
::       - Gdy zmiana ilości na przewodniku - ponowne ustalenie statusów
         exec('recover_sta_zgh','zl_guide',ZGH.ref())
      ?};
      ~~
   ||
      ~~
   ?}
|? _b=ZLGD
||
   {? _a='add' | _a='put' | _a='del'
   ||
::    Trigger po 'add', 'put' i 'del'

::    Ilosci zatwierdzone i deklarowane, ktore beda dodane po tej operacji do ZGP
      {? _a='add'
      || _il_plus:=ZLGD.IL;
         _ilbplus:=ZLGD.IL_BRAK;
         _id_plus:=ZLGD.DEK_IL;
         _idbplus:=ZLGD.DEK_BR
      |? _a='put'
      || _il_plus:=ZLGD.IL-bfld('IL');
         _ilbplus:=ZLGD.IL_BRAK-bfld('IL_BRAK');
         {? bfld('KJ_DONE')=ZLGD.KJ_DONE & ZLGD.KJ_DONE<>'T'
         || _id_plus:=ZLGD.DEK_IL-bfld('DEK_IL');
            _idbplus:=ZLGD.DEK_BR-bfld('DEK_BR')
         |? bfld('KJ_DONE')='P' & ZLGD.KJ_DONE='T'
         || _id_plus:=-bfld('DEK_IL');
            _idbplus:=-bfld('DEK_BR')
         |? bfld('KJ_DONE')='T' & ZLGD.KJ_DONE='P'
         || _id_plus:=ZLGD.DEK_IL;
            _idbplus:=ZLGD.DEK_BR
         || _id_plus:=0;
            _idbplus:=0
         ?}
      || _il_plus:=-bfld('IL');
         _ilbplus:=-bfld('IL_BRAK');
         _id_plus:={? bfld('KJ_DONE')='T' || 0 || -bfld('DEK_IL') ?};
         _idbplus:={? bfld('KJ_DONE')='T' || 0 || -bfld('DEK_BR') ?}
      ?};

::    Pozycja przewodnika
      {? _a='add' | _a='put'
      || _zgp:=ZLGD.ZGP
      || _zgp:=bfld('ZGP')
      ?};

::    Ustawienie zakończenia operacji
      {? _a='add' | _a='put'
      || _ok:=ZLGD.OK
      || _ok:='N'
      ?};

      Cntx.psh(ZGP,ZGH,ZL);
      ZGP.clear();
      {? ZGP.seek(_zgp)
      ||
         _sta_new:=exec('status_new','zl_guide');
         _sta_pen:=exec('status_pending','zl_guide');
         _sta_wai:=exec('status_waiting','zl_guide');
         _sta_end:=exec('status_end','zl_guide');

         {? ZGP.NRZLP().ZLEC().TYP().WP='P'
         ||
::          ZLECENIA PRODUKCYJNE
            _dokl:=ZGP.NRZLP().ZLEC().KTM().DOKL;

::          Ilość, jaka będzie za chwilę na tej operacji (po add, put, del)
            _il:=ZGP.IL+_il_plus;
            _ilb:=ZGP.IL_BRAK+_ilbplus;
            _id:=ZGP.DEK_IL+_id_plus;
            _idb:=ZGP.DEK_BR+_idbplus;
            _czy_napr:=ZGP.NAPRAW='T';
            _naprawcze:=exec('count_napr4zgp','braki');

            _ilpop:=exec('il_pop','zl_guide',ZGP.ref()).IL_POP;
            _ilmax:={? _ilpop>ZGP.ILOSC || _ilpop || ZGP.ILOSC ?};

            {? _ok='T' | (_il>=_ilmax & _il>0) | (_il>0 & _naprawcze>0 & _il+_naprawcze>=_ilmax)
            ||
::             Jeżeli ok (dla Tpz nie da się inaczej przejść na kolejny etap) lub ilość rozliczona,
::             to operacja zakończona
               ZGP.STATUS:=_sta_end;

               ZGP.IL:=_il;
               ZGP.IL_BRAK:=_ilb;
               ZGP.DEK_IL:=_id;
               ZGP.DEK_BR:=_idb
            ||
::             Status bieżącej operacji zależy od tego ile wykonano w stosunku do poprzedzającej
::             (najmniejsza przekazana ilość, dla Tpz ilość z przewodnika)
               _coef:={? ZGP.NRPRZ().ILNPRZ=0 || 1 || ZGP.NRZLP().ILNPRZ/ZGP.NRPRZ().ILNPRZ ?};
::               _ilp:=ZGP.ILOSC;
               _ilp:=_ilmax;
               ZGP.cntx_psh();
               _prev:=exec('tab_zgp_prev','zl_guide',ZGP.ref());
               _is_prev:=0;
               {? _prev.first()
               || _is_prev:=1;
                  {? _prev.TPZ='T'
                  ||
::                   Jezeli poprzednikiem jest TPZ, to pobieramy kolejne poprzedniki
                     {? ZGP.seek(_prev.REF,)
                     ||
                        _prev1:=exec('sum_zgp_prev','zl_guide',ZGP.ref());
                        {? _prev1.first()
                        || {!
                           |?
                              {? _prev1.TPZ='N' & _prev1.IL/_prev1.COEF*_coef<_ilp
                              || _round:=roundmet(); roundmet(1);
                                 _ilp:=(_prev1.IL/_prev1.COEF*_coef)$_dokl;
                                 roundmet(_round)
                              ?};
                              _prev1.next()
                           !}
                        ?};
                        obj_del(_prev1)
                     ?}
                  ||
                     _prev1:=exec('sum_zgp_prev','zl_guide',ZGP.ref());
                     {? _prev1.first()
                     || {!
                        |? {? _prev1.IL/_prev1.COEF*_coef<_ilp
                           || _round:=roundmet(); roundmet(1);
                              _ilp:=(_prev1.IL/_prev1.COEF*_coef)$_dokl;
                              roundmet(_round)
                           ?};
                           _prev1.next()
                        !}
                     ?};
                     obj_del(_prev1)
                  ?}
               ?};
               obj_del(_prev);
               ZGP.cntx_pop();

               ZGP.IL:=_il;
               ZGP.IL_BRAK:=_ilb;
               ZGP.DEK_IL:=_id;
               ZGP.DEK_BR:=_idb;

               {? _ilp<=0
               || ZGP.STATUS:=_sta_new
               |? _il+_ilb+_id+_idb<_ilp | _is_prev=0
               || ZGP.STATUS:=_sta_pen
               || ZGP.STATUS:=_sta_wai
               ?}
            ?};

::          Kolejna operacja ma status 'wykonywana' albo 'oczekująca' albo 'zakończona'
::          w zależnosci od ilości, z tym że zakończonej nie cofamy
            {? ZGP.put()
            ||
               _zgp_ref:=ZGP.ref();
               _args:=exec('find_uid_a','zl_guide');
               _args.ZGP:=ZGP.ref();
               _args.BRAKIUID:=ZGP.BRAKIUID;
               _zgp_uid:=exec('find_uid','zl_guide',_args);
               _zgp_tpz:=ZGP.TPZ;
               _zgp_stat:=ZGP.STATUS;
               _zgp_il:=ZGP.IL;
               _zgp_ilb:=ZGP.IL_BRAK;
               _upcoef:={? ZGP.NRPRZ().ILNPRZ=0 || 0 || ZGP.NRZLP().ILNPRZ/ZGP.NRPRZ().ILNPRZ ?};

               _next:=exec('tab_zgp_next','zl_guide',ZGP.ref());
               {? _next.first()
               || {!
                  |?
                     {? ZGP.seek(_next.REF,)
                     ||
                        {? _zgp_tpz='T'
                        ||
                           {? ZGP.STATUS<>_sta_end
                           ||
::                            Jeżeli bieżąca operacja jest Tpz, to następna jest tylko jedna i dostaje odpowiedni status
::                            czyli tylko po zakończeniu Tpz kolejna jest trwająca
::                            (mozna zmienić, że także dla trwającago Tpz kolejna operacja jest trwająca)
                              {? _zgp_stat=_sta_new || ZGP.STATUS:=_sta_new
                              |? _zgp_stat=_sta_pen || ZGP.STATUS:=_sta_new
                              |? _zgp_stat=_sta_wai || ZGP.STATUS:=_sta_new
                              |? _zgp_stat=_sta_end || ZGP.STATUS:=_sta_pen
                              ?};
::                            W przypadku trwającej sprawdzenie ilości na operacjach poprzedzających operację Tpz
::                            i ew. korekta na oczekującą
                              {? ZGP.STATUS=_sta_pen
                              ||
::                               Najmniejsza ilość z poprzednich operacji
                                 _jest_prev:=0;
                                 _ilx:=0;
                                 _prev:=exec('sum_zgp_prev','zl_guide',_zgp_ref);
                                 {? _prev.first()
                                 || _ilx:=_prev.IL/_prev.COEF;
                                    _jest_prev:=1;
                                    {!
                                    |?
                                       {? _prev.IL/_prev.COEF<_ilx || _ilx:=_prev.IL/_prev.COEF ?};
                                       _prev.next()
                                    !}
                                 ?};
                                 obj_del(_prev);

                                 {? _jest_prev
                                 ||
::                                  Ilosc skaluję spowrotem do mojej operacji
                                    _il:={? ZGP.NRPRZ().ILNPRZ<>0 || _ilx*ZGP.NRZLP().ILNPRZ/ZGP.NRPRZ().ILNPRZ || 0 ?};

                                    {? _il<=0
                                    || ZGP.STATUS:=_sta_new
                                    |? ZGP.IL>=_il & ZGP.IL<>0
                                    || ZGP.STATUS:=_sta_wai
                                    || ZGP.STATUS:=_sta_pen
                                    ?}
                                 ?}
                              ?};
                              ZGP.put()
                           ?}
                        ||
                           {? ZGP.STATUS<>_sta_end
                           ||
::                            Trzeba wyznaczyć najmniejszą ilość z operacji poprzedzających operację następną
::                            wyskalowane do ilości z przewodnika "głównego"
::                              _ilx:={? ZGP.NRZLP().ILNPRZ<>0 || _il*ZGP.NRPRZ().ILNPRZ/ZGP.NRZLP().ILNPRZ || 0 ?};
::                              _ilx:=0;
                              _ilx:={? _upcoef<>0 || _zgp_il/_upcoef || 0 ?};

                              _prev:=exec('sum_zgp_prev','zl_guide',ZGP.ref());
::                            ...z wykluczeniem tej obrabianej
                              {? _prev.first()
                              ||
::                               Jeżeli poprawiana operacja jest operacją naprawczą to ilość wyznaczana wg poprzedników
                                 {? _czy_napr>0 || _ilx:=_prev.IL/_prev.COEF ?};
                                 {!
                                 |?
                                    {? _prev.UID<>_zgp_uid & _prev.IL/_prev.COEF<_ilx || _ilx:=_prev.IL/_prev.COEF ?};
                                    _prev.next()
                                 !}
                              ?};
                              obj_del(_prev);

::                            Ilość skaluję spowrotem do mojej operacji
                              _il:={? ZGP.NRPRZ().ILNPRZ<>0 || _ilx*ZGP.NRZLP().ILNPRZ/ZGP.NRPRZ().ILNPRZ || 0 ?};
                              _round:=roundmet(); roundmet(1);
                              _il:=_il$ZGP.NRZLP().ZLEC().KTM().DOKL;
                              roundmet(_round);
                              {? _il<=0
                              || ZGP.STATUS:=_sta_new
                              |? ZGP.IL>=_il & ZGP.IL<>0
                              || ZGP.STATUS:=_sta_wai
                              || ZGP.STATUS:=_sta_pen
                              ?};
                              ZGP.put()
                           ?};

::                         Jeżeli następna jest wykonaną operacją Tpz, to bierzemy jeszcze nastepną (operację główną)
::                         i ustalamy jej status na podstawie poprzedników do Tpz
                           {? ZGP.TPZ='T' & ZGP.STATUS=_sta_end
                           ||
                              _zgp_next:=ZGP.ref();
                              _next1:=exec('tab_zgp_next','zl_guide',_zgp_next);
                              {? _next1.first()
                              || {? ZGP.seek(_next1.REF,)
                                 ||
                                    {? ZGP.STATUS<>_sta_end
                                    ||
::                                     Trzeba wyznaczyć najmniejszą ilość z operacji poprzedzających operację nastepną
::                                     wyskalowane do ilości z przewodnika "głównego"
                                       _ilx:={? ZGP.NRZLP().ILNPRZ<>0 || _zgp_il*ZGP.NRPRZ().ILNPRZ/ZGP.NRZLP().ILNPRZ || 0 ?};

                                       _prev:=exec('sum_zgp_prev','zl_guide',_zgp_next);
::                                     ...z wykluczeniem tej obrabianej
                                       {? _prev.first()
                                       ||
::                                        Jeżeli poprawiana operacja jest operacją naprawczą
::                                        to ilość wyznaczana wg poprzedników
                                          {? _czy_napr>0 || _ilx:=_prev.IL/_prev.COEF ?};
                                          {!
                                          |?
                                             {? _prev.UID<>_zgp_uid & _prev.IL/_prev.COEF<_ilx || _ilx:=_prev.IL/_prev.COEF ?};
                                             _prev.next()
                                          !}
                                       ?};
                                       obj_del(_prev);

::                                     Ilość skaluję spowrotem do mojej operacji
                                       _il:={? ZGP.NRPRZ().ILNPRZ<>0 || _ilx*ZGP.NRZLP().ILNPRZ/ZGP.NRPRZ().ILNPRZ || 0 ?};

                                       {? _il<=0
                                       || ZGP.STATUS:=_sta_new
                                       |? ZGP.IL>=_il & ZGP.IL<>0
                                       || ZGP.STATUS:=_sta_wai
                                       || ZGP.STATUS:=_sta_pen
                                       ?};
                                       ZGP.put()
                                    ?}
                                 ?}
                              ?};
                              obj_del(_next1)
                           ?}
                        ?}
                     ?};
                     _next.next()
                  !}
               ?}
            ?}
         ||
::          ZLECENIA WARSZTATOWE
            {? _ok='T'
            ||
::             Jezeli ok, to operacja zakończona
               ZGP.STATUS:=_sta_end
            ||
::             Status bieżącej operacji zależy od tego, czy wszystkie poprzednie są ok
               ZGP.cntx_psh();
               _prev_ok:=1;
               _prev:=exec('tab_zgp_prev','zl_guide',ZGP.ref());
               {? _prev.first()
               || {!
                  |? _prev_ok*=(_prev.STATUS=_sta_end);
                     _prev.next()
                  !}
               ?};
               obj_del(_prev);
               ZGP.cntx_pop();

               {? _prev_ok
               || ZGP.STATUS:=_sta_pen
               || ZGP.STATUS:=_sta_new
               ?}
            ?};

::          Kolejne operacje mają status 'wykonywana' albo 'zakończona', z tym że zakończonej nie cofamy
            {? ZGP.put()
            ||
               _zgp_ref:=ZGP.ref();
               _args:=exec('find_uid_a','zl_guide');
               _args.ZGP:=ZGP.ref();
               _args.BRAKIUID:=ZGP.BRAKIUID;
               _zgp_uid:=exec('find_uid','zl_guide',_args);
               _zgp_stat:=ZGP.STATUS;
               _next:=exec('tab_zgp_next','zl_guide',ZGP.ref());
               {? _next.first()
               || {!
                  |?
                     {? ZGP.seek(_next.REF,)
                     ||
                        {? ZGP.STATUS<>_sta_end
                        ||
                           _prev_ok:=1;
                           _prev:=exec('tab_zgp_prev','zl_guide',ZGP.ref());
::                         ...z wykluczeniem tej obrabianej
                           {? _prev.first()
                           || {!
                              |?
                                 {? _prev.UID<>_zgp_uid; 1 || _prev_ok*=(_prev.STATUS=_sta_end) ?};
                                 _prev.next()
                              !}
                           ?};
                           obj_del(_prev);

                           {? _prev_ok
                           || ZGP.STATUS:=_sta_pen
                           || ZGP.STATUS:=_sta_new
                           ?};

                           ZGP.put()
                        ?}
                     ?};
                     _next.next()
                  !}
               ?}
            ?}
         ?}
      ?};
      Cntx.pop(ZGP,ZGH,ZL);
      ~~
   ?}
||
   ~~
?}


\zgp_efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Ustawia opcje pól w oknach redagowania ZGP
::----------------------------------------------------------------------------------------------------------------------
_wp:=VAR.A_ZLEC().TYP().WP;
ZGP.efld_opt('RED',
         {? ZGP.NTIME<>0 & ZGP.MTIME=0 | ZGP.NTIME=0 & ZGP.MTIME=0 | ZGP.NTIME<>0 & ZGP.MTIME<>0
         || 'mark=1'
         || 'mark=0'
         ?},,'NTIME');
ZGP.efld_opt('RED',
         {? ZGP.NTIME=0 & ZGP.MTIME<>0 | ZGP.NTIME=0 & ZGP.MTIME=0 | ZGP.NTIME<>0 & ZGP.MTIME<>0
         || 'mark=1'
         || 'mark=0'
         ?},,'MTIME');
ZGP.efld_opt('RED',{? VAR1.TPZ='T' || 'enable=1' || 'enable=0' ?},VAR1,'ZAW');
ZGP.efld_opt('RED',{? VAR1.TPZ='T' || 'enable=1' || 'enable=0' ?},VAR1,'NTIME1');
ZGP.efld_opt('RED',{? VAR1.TPZ='T' || 'enable=1' || 'enable=0' ?},VAR1,'PLNH1');
ZGP.efld_opt('RED','mark=0',VAR1,'PLNH1');
ZGP.efld_opt('RED',{? VAR1.TPZ='T' || 'enable=1' || 'enable=0' ?},VAR1,'PLNX');
ZGP.efld_opt('RED',{? _wp='P' || 'enable=1' || 'enable=0' ?},ZGH,'ILNPRZ');
ZGP.efld_opt('RED_OUT',{? _wp='P' || 'enable=1' || 'enable=0' ?},ZGH,'ILNPRZ');
ZGP.efld_opt('RED',{? _wp='P' || 'enable=1' || 'enable=0' ?},ZGP,'ILOSC');
ZGP.efld_opt('RED_OUT',{? _wp='P' || 'enable=1' || 'enable=0' ?},ZGP,'ILOSC');
ZGP.efld_opt('RED',{? _wp='P' || 'enable=1' || 'enable=0' ?},VAR,'IL');
ZGP.efld_opt('RED_OUT',{? _wp='P' || 'enable=1' || 'enable=0' ?},VAR,'IL');
ZGP.efld_opt('RED',{? _wp='P' || 'enable=1' || 'enable=0' ?},VAR,'REAL');
ZGP.efld_opt('RED_OUT',{? _wp='P' || 'enable=1' || 'enable=0' ?},VAR,'REAL');
ZGP.efld_opt('RED',{? _wp='P' || 'enable=1' || 'enable=0' ?},,'DOK');
ZGP.efld_opt('RED',{? _wp='P' || 'enable=1' || 'enable=0' ?},TYPYDOK,'NAZ');
ZGP.efld_opt('RED_OUT',{? _wp='W' || 'enable=0' || 'enable=1' ?},,'SRW');
ZGP.efld_opt('RED_OUT',{? _wp='W' || 'enable=0' || 'enable=1' ?},,'DOK');
ZGP.efld_opt('RED_OUT',{? _wp='W' || 'enable=0' || 'enable=1' ?},TYPYDOK,'NAZ');
ZGP.efld_opt('RED',{? _wp='P' || 'enable=1' || 'enable=0' ?},ZGP,'KJ_BAD');
ZGP.efld_opt('RED',{? ZGP.KJ_BAD='B' || 'enable=1' || 'enable=0' ?},,'BADSEH');
ZGP.efld_opt('RED',{? VAR1.TPZ='T' || 'enable=1' || 'enable=0' ?},VAR1,'STARTD');
ZGP.efld_opt('RED',{? VAR1.TPZ='T' || 'enable=1' || 'enable=0' ?},VAR1,'STARTT');
ZGP.efld_opt('RED',{? VAR1.TPZ='T' || 'enable=1' || 'enable=0' ?},VAR1,'ENDD');
ZGP.efld_opt('RED',{? VAR1.TPZ='T' || 'enable=1' || 'enable=0' ?},VAR1,'ENDT');
~~


\zgh_grayed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Ustala wyszarzone akcje dla ZGH
::       Kontekst wywołania - rekord ZGH
::----------------------------------------------------------------------------------------------------------------------
:: Dostępne akcje: Dołącz, Popraw, Usuń, pozyCje, parTie, Generuj, Oddany, przywrÓć, Harmonogram,
::                 diagRam, Zlecenie, limitY, nielimitoWane, rEjestracja, Zakończ,
::                 Funkcje|Wykorzystanie zasobów, Funkcje|Numeruj, drukuJ, Legenda

:: Zabierane wg kontekstu wywołania:
_grayed:={? VAR.ZGH_ALL>0 || '' || params_get().env_guide.zgh_actions ?};
:: Wyróżnik akcji zakończ
_zak:={? VAR.ZGH_ALL>0 || '' || 'Z' ?};


ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(ZGH.ZLEC) | (VAR.ZGH_ALL=0 & ZL.seek(params_get().env.ZL))
||
:: Dla zamkniętych zleceń bez edycji
   {? ZL.STAN='Z' || _grayed:='dpuDPUGOÓF(N)'+_zak+_grayed+'dDG' ?};

:: Zlecenie ma produkt niepartiowany, akcja 'Partie' wyszarzona
   {? exec('material_party','material',ZL.KTM)=0 || _grayed:='T'+_grayed ?};

:: Dla zleceń w przygotowaniu bez wyświetlania harmonogramu, bez oddawania/przywracania, bez rejestrowania wykonań
   {? ZL.STAN='N' || _grayed:='EHOÓ'+_grayed ?};

:: Niezatwierdzony nagłówek i technologia (zlecenie produkcyjne), nagłówek (zlecenie warsztatowe)
:: - bez edycji (G:G nie jest usuwane)
   {? ZL.TYP().WP='W' | ZL.TYP().TECH='N'
   || {? ZL.STAT_N='N'                 || _grayed:='dpuDPUEF(N)'+_zak+_grayed+'dD' ?}
   || {? ZL.STAT_N='N' | ZL.STAT_T='N' || _grayed:='dpuDPUEF(N)'+_zak+_grayed+'dD' ?}
   ?};

:: Technologia bez operacji - bez edycji (G:G nie jest usuwane)
   _tktl:={? ZL.RTKTL<>'' || ZL.RTKTL || ZL.RKTL ?};
   {? exec('FindAndGet','#table',TKTL,_tktl,,"TYP().OPER",'T')='N' || _grayed:='dpuDPUREF(N)J'+_zak+_grayed+'dD' ?}

?};
ZL.cntx_pop();

{? ~exec('zgh_utilization','po_plan',1,ZGH.ref()) || _grayed:='F(W)'+_grayed ?};
{? exec('gray_renumber','zl_guide') || _grayed:='F(N)'+_grayed ?};
{? ZGH.STAT_REJ='T' || _grayed:=_zak+_grayed || _grayed:='OÓ'+_grayed ?};
{? ZGH.STAN='T' || _grayed:='dpuDPU'+_grayed+'dD' ?};

:: Oddawanie/przywracanie
{? ZGH.STAN='T' || _grayed:='O'+_grayed || _grayed:='Ó'+_grayed ?};

:: Rejestracja wykonań
{? exec('chk_role','#b__box',OPERATOR.USER,'TTE_WYK_DWZL')=0 | exec('get','#params',500611,2)='N'
|| _grayed:='E'+_grayed
?};

_grayed


\zgp_icons
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Ustala ikony w oknie wertowania ZGP
::   WE: _a - akronim okna wertowania
::----------------------------------------------------------------------------------------------------------------------
_sel:=_a;
_formikon:="exec('icon_status','zl_guide',ZGP.STATUS)";
ZGP.win_fml(_sel,,'STATUS',,'ICON_BEFORE',_formikon,2);
_formikon:="exec('icon_status','zl_guide',VAR1.ZGP_STAT)";
ZGP.win_fml(_sel,VAR1,'ZGP_STAT',,'ICON_BEFORE',_formikon,2);
_formikon:="exec('icon_problem','zl_guide',ZGP.PROBLEM,ZGP.PROBKLAS,VAR1.PROBLEM,VAR1.PROBKLAS)";
ZGP.win_fml(_sel,,'OPIS',,'ICON_BEFORE',_formikon,2);
_formikon:="exec('icon_kontrol','zl_guide',ZGP.KJ_BAD,ZGP.KONTROLA)";
ZGP.win_fml(_sel,,'NRP',,'ICON_BEFORE',_formikon,2);
_formikon:="exec('icon_napraw','zl_guide',ZGP.NAPRAW)";
ZGP.win_fml(_sel,,'PFAZ','KOD','ICON_BEFORE',_formikon,2);
_formikon:="exec('icon_dok','zl_guide',ZGP.DOK)";
ZGP.win_fml(_sel,,'ILOSC',,'ICON_BEFORE',_formikon,2);
_formikon:="exec('icon_tranZ','zl_guide',ZGP.DOK)";
ZGP.win_fml(_sel,,'STARTDK',,'ICON_BEFORE',_formikon,2);
_formikon:="exec('icon_tranR','zl_guide',ZGP.DOK)";
ZGP.win_fml(_sel,,'ENDDK',,'ICON_BEFORE',_formikon,2);
~~


\przeddol
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Przed dołącz na przewodnikach
::  OLD: \przeddol/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env_guide:=params_get().env_guide;

VAR.A_ZLEC();

:: Sprawdzenie numerów przewodników
{? _wolne:=exec('wolne_numery','zl_guide',VAR.A_ZLEC);
   _wolne=0
|| FUN.emsg('Dla tego typu zlecenia nie można założyć przewodnika o większym numerze.'@);
   0
|| _wp:=VAR.A_ZLEC().TYP().WP;
   {? _wp='W'
   || 1
   || _ile:=exec('ile','zl_guide',VAR.A_ZLEC,VAR.A_ZLEC().IL);
      {? _ile>0
      ||
         _env_guide.ilosc:=_ile;
         {? ZL.RODZAJ='P'
         || 1
         || FUN.info('Przewodniki można dołączać tylko do zlecenia prostego.'@);
            0
         ?}
::         {? ZL.NRNZL=0 & ZL.RODZAJ<>'P'
::         || _sprawdz:=~exec('sprawdz_podzlecenia','zl_link')
::         |? ZL.RODZAJ='P' & ZL.NRNZL=0
::         || _sprawdz:=1
::         || _sprawdz:=1
::         ?};
::         {? _sprawdz
::         || 1
::         || FUN.emsg('Brak utworzonych zleceń podrzędnych.'@);
::            0
::         ?}
      || FUN.emsg('Ilość na przewodnikach nie może być większa niż na zleceniu.'@);
         0
      ?}
   ?}
?}


\gen_tech_guid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wygenerowanie przewodnika 'technicznego' dla zlecenia z technologią bez operacji
::  WE: _a - ZL.ref()
::  WY: 0 - porażka
::      1 - sukces
::  OLD: \gen_tech_guid/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

Cntx.psh(ZL,ZGH,ZGP);
Cntx.clr(ZL,ZGH,ZGP);

_result:=0;
_can_continue:=1;

{? ZL.seek(_zl)
||
:: Sprawdzam, czy jest już przewodnik, żeby nie tworzyć powtórnie
   ZGH.index('ZLNR');
   ZGH.prefix(ZL.ref());
   {? ZGH.first()
   || _can_continue:=1

   || ZGH.blank();
      ZGH.NRPRZ:=exec('bl_nrprz','zl_guide',1);
      ZGH.ILNPRZ:=ZL.IL;
      ZGH.KIND:='T';
      ZGH.STAT_REJ:='T';
      ZGH.GKTL:=exec('gktl_from_zl','zl_common',ZGH.ZLEC);
      _can_continue:=ZGH.add();
      {? _can_continue>0
      ||
::         KOMM.sect_beg('Dodano przewodnik techniczny: '+ZGH.NRPRZ,7);
         VAR.A_NRPRZ:=VAR.A_NRZLP:=ZGH.ref();
         ZGP.blank();
         ZGP.NRP:=1;
         ZGP.WEW:='T';
         ZGP.TPZ:='N';
         ZGP.PO:='O';
         ZGP.OPIS:='< Wykonanie produktu: '+ZL.KTM().KTM+'>';
         ZGP.ILOSC:=VAR.A_ZLEC().IL;
         _can_continue:=ZGP.add();
::         {? _can_continue>0
::         || KOMM.add('Dodano pozycję przewodnika: '+$ZGP.NRP,7)
::         ?};
::         KOMM.sect_end();
         ~~
      ?}
   ?};

   {? _can_continue>0
   ||
      _zgh_sym:=ZGH.NRPRZ;
::    Sprawdzam czy zlecenie ma mieć partie
      {? exec('zlec_party','zl_common',ZL.ref())>0
      || _main_podzlec:={? ZL.RP='T'
                        || ZL.ref()
                        || exec('main_podzlec','zl_link',ZL.ref())
                        ?};
::       Sprawdzam ile jest popartiowane
         _il_part:=exec('zl_ile_part','zl_partie',_main_podzlec);

         _il_main:=exec('FindAndGet','#table',ZL,_main_podzlec,,"IL",0);
::       Obliczam czy coś brakuje na partiach, jeśli tak to je dogenerowuję
         _il_brak:=_il_main-_il_part;

::       Dogenerowuję partie na brakującą ilość
         {? _il_brak>0
         || _args:=exec('buffer','zl_partie');
            _args.ZL:=_main_podzlec;
            _args.ZGH:=ZGH.ref();
            _args.IL:=_il_brak;
            _can_continue:=exec('add','zl_partie',_args)
         ?};
::       Wiążę wszystkie partie z utworzonym przewodnikiem
         ZPARN.cntx_psh();
         ZPARN.index('ZL2');
         ZPARN.prefix(_main_podzlec);
         {? ZPARN.first()
         || {!
            |? _can_continue:=exec('tie2zgh','zl_partie',ZPARN.ref(),_zgh_sym);
               ZPARN.next() & _can_continue>0
            !}
         ?};
         ZPARN.cntx_pop();
         ~~
      ?}
   ?}
?};

{? _can_continue>0
|| _result:=1
?};
Cntx.pop(ZL,ZGH,ZGP);
_result


\zgh_inherited
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy na podstawie przewodnika zostały utworzone przewodniki potomne na podzleceniu
::   WE: [_a] - ZGH.ref lub bieżący rekord
::   WY: 0 - przewodnik nie ma potomków
::       1 - przewodnik ma potomków
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGH.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZGH.cntx_psh();
{? _ref<>null()
|| ZGH.clear();
   {? ZGH.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? ZGH.UID<>''
   ||
      ZGH.cntx_psh();
      ZGH.index('UID_SRC');
      ZGH.prefix(ZGH.UID);
      {? ZGH.first()
      || _result:=1
      ?};
      ZGH.cntx_pop()
   ?}
?};
ZGH.cntx_pop();
_result


\akt_zgh_plany
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Aktualizuje terminy początku i końca realizacji przewodników na podstawie zlecenia
::   WE: _a - ZL.ref()
::  OLD: \akt_zgh_plany/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

Cntx.psh(ZL,ZGH);
Cntx.clr(ZL    );

{? ZL.seek(_zl)
|| ZGH.index('ZLNR');
   ZGH.prefix(ZL.ref());
   {? ZGH.first()
   || {!
      |? ZGH.STARTD:=ZL.STARTD;
         ZGH.STARTT:=ZL.STARTT;
         ZGH.ENDD:=ZL.ENDD;
         ZGH.ENDT:=ZL.ENDT;
         {? ZGH.put() || exec('akt_zgp_plany','zl_guide',ZGH.ref()) ?};
         ZGH.next()
      !}
   ?}
?};

Cntx.pop(ZL,ZGH);
~~


\tpz_names
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Zwraca kod i nazwę operacji głównej dla Tpz, albo samej siebie, jeśli nie jest Tpz-em
::   WE: _a - $ZGP.ref()
::  OLD: \tpz_names/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_res:=obj_new('KOD','NA');
_res.KOD:='???';
_res.NA:='???';

ZGP.cntx_psh();
ZGP.clear();
{? ZGP.seek(_zgp)
|| {? ZGP.TPZ='N'
   || {? ZGP.TOPER<>null()
      || _res.KOD:=ZGP.TOPER().OPER().KOD;
         _res.NA:=ZGP.OPIS
      || _res.KOD:=$ZGP.NRP;
         _res.NA:=ZGP.OPIS
      ?}
   || ZGP.index('TPZ');
      ZGP.prefix('T',ZGP.UID);
      {? ZGP.first()
      || {? ZGP.TOPER<>null()
         || _res.KOD:=ZGP.TOPER().OPER().KOD;
            _res.NA:=ZGP.OPIS+' (Tpz)'
         || _res.KOD:='TPZ';
            _res.NA:=ZGP.OPIS
         ?}
      ?}
   ?}
?};
ZGP.cntx_pop();
_res


\var_akord
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Alokowanie zmiennej globalnej Akord
::  OLD: \var_akord/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
VAR_DEL.delete('Akord');
Akord:=obj_new('NTIME','MTIME','IL_N');
Akord.NTIME:=0;
Akord.MTIME:=0;
Akord.IL_N:=0;
~~


\wyd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Pobiera wydzial dla pozycji przewodnika
::       KONTEKST - biezacy rekord ZGP
::   WY: UD_SKL.ref() / null()
::  OLD: \wyd/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(ZGH,ZL);
_wydzial:=exec('szukaj_ud_skl','schemat','PODZORG',ZGP.PLACE().WYD().KOD);
{? _wydzial=null()
|| _wydzial:=exec('szukaj_ud_skl','schemat','PODZORG',ZGP.PFAZ().WYD().KOD)
?};
{? _wydzial=null()
|| _wydzial:=exec('szukaj_ud_skl','schemat','PODZORG',ZGP.NRPRZ().ZLEC().JORG().KOD)
?};
Cntx.pop(ZGH,ZL);
_wydzial


\doc_4zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Informacja o dokumentach wyświetlana z poziomu pozycji przewodnika
::       Kontekst pracy: ZGP
::  OLD: \doc_4zgp/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZGP.DOC_REJ='P'
|| exec('ZGP','tech_doc')
|? ZGP.DOC_REJ='T'
|| ZL.cntx_psh();
   exec('FindAndGet','#table',
      TKTL,
      ZGP.ZL(); {? ZL.RTKTL<>'' || ZL.RTKTL || ZL.RKTL ?},,
      "exec('TKTL','tech_doc',TKTL.ref(),1)",~~
   );
   ZL.cntx_pop()
|? ZGP.DOC_REJ='Z'
|| exec('ZL','tech_doc',ZGP.ZL,1)
?};
~~


\npu_4zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.14]
:: OPIS: Informacja o NPU wyświetlana z poziomu pozycji przewodnika
::       Kontekst pracy: ZGP
::----------------------------------------------------------------------------------------------------------------------
TOPER.clear();
{? TOPER.seek(ZGP.TOPER)
|| _tools2oper:=1;
::   _tools2oper:=(TOPER.NRK().TYP().UTIL='O');
   VAR.A_KTL:=TOPER.NRK;
   exec('tactlls_filtr','tech_tool',VAR.A_KTL,TOPER.ref(),1);
   exec('tools_main','tech_tool',TOPER.NRK,{? _tools2oper || TOPER.ref() || null() ?},'',0,1);
   TACTTLS.f_clear(1)
?};
~~


\set_oddany
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Zaznacza przewodnik jako oddany
::   WE: [_a] - ZGH.ref() lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGH.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZGH.cntx_psh();
ZGP.cntx_psh();
{? _ref<>null()
|| ZGH.prefix();
   {? ZGH.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _ilosc:=ZGH.ILNPRZ;
   ZGP.index('NRPP');
   ZGP.prefix(ZGH.ref(),'N');
   {? ZGH.ILGEN>=_ilosc
   ||
      {? ZGP.first()
      ||
         _dalej:=1;
         {!
         |?
            _il1:=ZGP.IL;
            {? _il1<_ilosc
            || _dalej:=0
            ?};
            ZGP.next() & _dalej
         !}
      ||
         _dalej:=0
      ?};
      {? _dalej=1
      || ZGH.STAN:='T';
         _can_continue:=ZGH.put();
::      ZL.cntx_psh();
::      {? ZGH.ZLEC().NRNZL<>0
::      || exec('rodz_odd','zl_guide')
::      ?};
::      ZL.cntx_pop();
         ~~
      ?}
   ?}
?};
ZGP.cntx_pop();
ZGH.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\main_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca ref operacji głównej dla wskazanej operacji Tpz na przewodniku zlecenia
::   WE: _a - ZGP.ref()
::   WY: ZGP.ref()
::  OLD: \main_ref/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
ZGP.cntx_psh();
ZGP.clear();
{? ZGP.seek(_a)
|| ZGP.index('UID');
   ZGP.prefix(ZGP.UID_TPZ);
   {? ZGP.first() || _ref:=ZGP.ref() ?}
?};
ZGP.cntx_pop();
_ref


\tpz_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Ustawia ZGPowi nowy czas TPZ lub usuwa go całkowicie
::   WE: [_a] - ZGP.ref lub aktualny rekord
::       _b - REAL - czas TP w minutach
::       _c - REAL - czas TZ w minutach
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \tpz_edit/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};
_tp:=_b;
_tz:=_c;

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
TOPER.cntx_psh();
TOPER.clear();
{? _ref<>null()
|| ZGP.clear();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: Przemieniam tm_stampa na czas technologiczny
   _tp_tech:=_tp/60;
   _tz_tech:=_tz/60;

   {? _tp>0 | _tz>0
   ||
::    Ma byc TPZ
      ZGP.index('TPZ');
      ZGP.prefix('T',ZGP.UID);
      {? ZGP.first()
      ||
::       Jest ZGP typu TPZ, modyfikuję go
         ZGP.NTIME:=_tp_tech+_tz_tech;
         _can_continue:=ZGP.put();
         {? _can_continue=0
         || KOMM.add('Nie udało się poprawienie czasu TPZ na pozycji przewodnika zlecenia.'@,2,,1)
         ?}
      ||
:;       Brak ZGPa typu TPZ, trzeba go założyć
         ZGP.WEW:='T';
         ZGP.NRP:=ZGP.NRP;
         ZGP.TPZ:='T';
         ZGP.ZAW:=ZGP.ZAW;
         ZGP.NTIME:=_tp_tech+_tz_tech;
         ZGP.CIAGLA:=ZGP.CIAGLA;
         _plnh:=0;
         _plnx:=0;
         {? ZGP.TOPER<>null()
         || ZGP.TOPER();
            TOPER.index('TPZ');
            TOPER.prefix('T',TOPER.UNROP);
            {? TOPER.first()
            || _plnh:=TOPER.PLNH;
               _plnx:=TOPER.PLNX
            ?}
         ?};
         ZGP.PLNH:=_plnh;
         ZGP.PLNX:=_plnx;
         ZGP.OPIS:='TPZ - '+ZGP.OPIS;
         ZGP.PO:=ZGP.PO;
         ZGP.BRYG:=ZGP.BRYG;
::         ZGP.TPZREF:=ZGP.NRP;
         ZGP.UID_TPZ:=ZGP.UID;
         ZGP.PLACE:=ZGP.PLACE;
         ZGP.NRPRZ:=ZGP.NRPRZ;
         ZGP.NRZLP:=ZGP.NRZLP;
         ZGP.STARTD:=ZGP.STARTD;
         ZGP.STARTT:=ZGP.STARTT;
         ZGP.ENDD:=ZGP.ENDD;
         ZGP.ENDT:=ZGP.ENDT;
         ZGP.ILOSC:=ZGP.ILOSC;
         _can_continue:=ZGP.add();
         {? _can_continue=0
         || KOMM.add('Nie udało się dodanie czasu TPZ do pozycji przewodnika zlecenia.'@,2,,1)
         ?}
      ?}
   ||
::    Ma nie być TPZta
      ZGP.index('TPZ');
      ZGP.prefix('T',ZGP.UID);
      {? ZGP.first()
      ||
::       Znaleziono TPZ więc go usuwam
         _can_continue:=ZGP.del(,1);
         {? _can_continue=0
         || KOMM.add('Nie udało się usunięcie czasu TPZ na pozycji przewodnika zlecenia.'@,2,,1)
         ?}
      ?}
   ?}
?};
ZGP.cntx_pop();
TOPER.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\update4ploz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Uaktualnia czas trwania operacji i stanowisko na pozycji przewodnika na podstawie
::       przekazanej pozycji planu operacyjnego
::   WE: [_a] - ZGP.ref lub bieżący rekord
::       _b - PL_OZ.ref() - pozycja planu na podstawie której uaktualnić
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \update4ploz/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};
_ploz:=_b;

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
{? _ref<>null()
|| ZGP.clear();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PL_OZ.cntx_psh(); PL_OZ.clear();
   {? PL_OZ.seek(_ploz)
   || _place:=PL_OZ.PL_RES().FROM_STA;
      _gniazdo:=PL_OZ.PL_RES().FROM_GNI;
      {? _place<>null() & ZGP.PLACE<>_place
      || ZGP.PLACE:=_place
      ?};
      {? _gniazdo<>null() & ZGP.GRUPA<>_gniazdo
      || ZGP.GRUPA:=_gniazdo
      ?};

::    Sprawdzam czy istnieje TPZ i jemu też przepinam stanowisko
      {? ZGP.TPZ<>'T'
      ||
         ZGP.cntx_psh();
         ZGP.index('TPZ');
         ZGP.prefix('T',ZGP.UID);
         {? ZGP.first()
         ||
::          !!! REKURENCJA !!!
            _can_continue:=exec('update4ploz','zl_guide',,_ploz)
         ?};
         ZGP.cntx_pop()
      ?};

::    Aktualizacja czasów
      {? _can_continue>0 & ZGP.TPZ<>'T'
      ||
         _time:=(PL_OZ.PL_OPER().DURATION/60)-(PL_OZ.PL_OPER().TP/60)-(PL_OZ.PL_OPER().TZ/60);

         {? ZGP.MTIME>0
         ||
            {? ZGP.MTIME<>_time
            || ZGP.MTIME:=_time
            ?}
         |? ZGP.NTIME>0
         || {? ZGP.NTIME<>_time
            || ZGP.NTIME:=_time
            ?}
         ?}
      ?};
      {? _can_continue>0
      || _can_continue:=ZGP.put()
      ?}
   ?};
   PL_OZ.cntx_pop();
   ~~
?};
ZGP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\is_zamiennik
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Sprawdza czy podany ZGP pokrywa się z jakimkolwiek zamiennikiem swojego TOPERa
::   WE: [_a] - ZGP.ref lub bieżący rekord
::   WY: 0 - nie jest zamieniony
::       1 - jest zamieniony
::  OLD: \is_zamiennik/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
{? _ref<>null()
|| ZGP.clear();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   TOPER.cntx_psh();
   {? ZGP.TOPER<>null()
   ||
      ZGP.TOPER();
      TECHZAMS.cntx_psh();
      TECHZAMS.index('ATL');
      TECHZAMS.prefix('T',TOPER.ref());
      {? TECHZAMS.first()
      || {!
         |? {? TECHZAMS.PLACE=ZGP.PLACE & TECHZAMS.GRUPA=ZGP.GRUPA
            || _result:=1;
               _can_continue:=0
            ?};
            TECHZAMS.next() & _can_continue>0
         !}
      ?};
      TECHZAMS.cntx_pop()
   ?};
   TOPER.cntx_pop();
   ~~
?};
ZGP.cntx_pop();
_result


\zamiennik_offset
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Zwracam offset oryginalny dla ZGPa który już ma zamienione stanowisko
::   WE: [_a] - ZGP.ref lub bieżący rekord
::   WY: REAL
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
{? _ref<>null()
|| ZGP.clear();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   TOPER.cntx_psh();
   {? ZGP.TOPER<>null()
   ||
      ZGP.TOPER();
      TECHZAMS.cntx_psh();
      TECHZAMS.index('ATL');
      TECHZAMS.prefix('T',TOPER.ref());
      {? TECHZAMS.first()
      || {!
         |? {? TECHZAMS.PLACE=ZGP.PLACE & TECHZAMS.GRUPA=ZGP.GRUPA
            || _result:=(TECHZAMS.TTM-TECHZAMS.NKO)*60;
               _can_continue:=0
            ?};
            TECHZAMS.next() & _can_continue>0
         !}
      ?};
      TECHZAMS.cntx_pop()
   ?};
   TOPER.cntx_pop();
   ~~
?};
ZGP.cntx_pop();
_result


\has_wyk_zgh
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy do danego przewodnika zostaly zarejestrowane jakies wykonania
::   WE: [_a] - ZGH.ref lub biezacy rekord
::   WY: 0 - brak wykonan
::       1 - sa jakies wykonania
::  OLD: \has_wyk_zgh/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
ZGH.cntx_psh();
{? _ref<>null()
|| ZGH.clear();
   {? ZGH.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? ZGH.ZLEC<>null()
   ||
::    Podczytanie zlecenia
      ZGH.ZLEC();

      _args_wyk:=obj_new('RESULT');
      _args_wyk.RESULT:=0;

      _rule:="
         _args:=_b;
         ZLGD.cntx_psh();
         ZLGD.index('ZLPP');
         ZLGD.prefix(ZL.ref(),ZGH.ref());
         {? ZLGD.size()>0
         || _args.RESULT:=1
         ?};
         ZLGD.cntx_pop();
         ~~
      ";

      _name:=5+ZLGD.name();
      _msk_start:=_name+ZL.ODDZ+(2-$(ZL.OD~1));
      _msk_end:=~~;
      {? ZL.STAN='Z'
      || _rok:=exec('max','#math',ZL.ROK_MAX,ZL.DO~1);
         _msk_end:=_name+ZL.ODDZ+(2-$(_rok))
      || _rok:=exec('max','#math',ZL.ROK_MAX,date()~1,ST.AR);
         _msk_end:=_name+ZL.ODDZ+(2-$(_rok))
      ?};
      exec('for_each_mask','#table',ZLGD,_rule,_msk_start,_msk_end,_args_wyk);
      _result:=_args_wyk.RESULT
   ?}
?};
ZGH.cntx_pop();
ZL.cntx_pop();
_result


\var_zgp_fld_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Przed wyswietleniem pol zmiennych w oknach tabeli ZGP: VAR.IL_PLAN
::  OLD: \var_zgp_fld_bd/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? cur_afld()='IL_PLAN'
|| {? fld()>0
   || 1
   || exec('findfnv','#color')
   ?}
|| 1
?}


\var_zgp_fld_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Format wyswietlania pol zmiennych w oknach tabeli ZGP: VAR.IL_PLAN
::  OLD: \var_zgp_fld_fd/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? cur_afld()='IL_PLAN'
|| ZGP.NRZLP().ZLEC();
   {? (ZL.TYP().WP='W' | ZL.RODZAJ='N' & ZL.NRNZL=0)
   || _format:='empty=1'
   || _format:='empty=0'
   ?};
   _format+',out_prec='+$ZL.KTM().DOKL
|| 'empty=0'
?}


\zgp_plgrp_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MagLak[12.46]
:: OPIS: Po redakcji pola ZGP.PLGRP
::   WY: 0 / 1
::  OLD: \zgp_plgrp_ae/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
{? fld()='T'
||
   {? VAR1.TPZ='T'
   || FUN.info('Nie można ustawić operacji jako grupowej, gdy przypisany jest do niej Tpz.'@);
      fld():='N';
      res:=0
   |? ZGP.KONTROLA='T'
   || FUN.info('Nie można ustawić operacji kontroli jakości jako grupowej.'@);
      fld():='N';
      res:=0
   |? ZGP.KJ_BAD<>'N'
   || FUN.info('Dla operacji grupowej nie można używać kontroli jakości przez moduł badań.'@);
      fld():='N';
      res:=0
   |? ZGP.BAD_OP<>null()
   || FUN.info('Dla operacji grupowej nie można używać badań przeprowadzanych w trakcie wykonywania operacji.'@);
      fld():='N';
      res:=0
   ?}
?};
_res


\zgp_kontrola_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MagLak[12.46]
:: OPIS: Przed redakcja pól ZGP.KONTROLA, ZGP.KJ_BAD, ZGP.BADSEH
::   WY: 0 / 1
::  OLD: \zgp_kontrola_be/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? cur_tab(1,1).PL_GRP='T'
|| 0
|| 1
?}


\sum_zgp_prev
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Zwraca zestaw rekordow bedacych faktycznymi nastepnikami podanej operacji - zsumowane wg UID
::   WE: _a - ZGP.ref()
::       [_b] - tab_tmp - tabela tymczasowa zawierająca poprzedniki
::   WY: tab_tmp
::  OLD: \sum_zgp_prev/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')>100
|| _prev:=_b
|| _prev:=exec('tab_zgp_prev','zl_guide',_a)
?};
_prev_sum:=sql('
   select
      :_a.UID,
      :_a.TPZ,
      sum(:_a.IL) as IL,
      sum(:_a.IL_BRAK) as IL_BRAK,
      :_a.COEF
   from :_a group by :_a.UID, :_a.TPZ, :_a.COEF
',_prev);
_prev_sum


\sum_zgp_next
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Zwraca zestaw rekordow bedacych faktycznymi nastepnikami podanej operacji - zsumowane wg UID
::   WE: _a - ZGP.ref()
::       [_b] - tab_tmp - tabela tymczasowa zawierająca następniki
::   WY: tab_tmp
::  OLD: \sum_zgp_next/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')>100
|| _next:=_b
|| _next:=exec('tab_zgp_next','zl_guide',_a)
?};
_next_sum:=sql('
   select
      :_a.UID,
      :_a.TPZ,
      sum(:_a.IL) as IL,
      sum(:_a.IL_BRAK) as IL_BRAK,
      :_a.COEF
   from :_a group by :_a.UID, :_a.TPZ, :_a.COEF
',_next);
_next_sum


\zgp_badseh_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Przed wyświetl pola ZGP.BADSEH
::   WY: 0/1
::  TAG: <MBUILDER>
::  OLD: \zgp_badseh_bd/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\zgp_badseh_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Przed redakcja pola ZGP.BADSEH
::   WY: 0/1
::  TAG: <MBUILDER>
::  OLD: \zgp_badseh_be/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
BADVAR.TYP_BAD:='O';
_result:=1;
{? cur_tab(1,1).PL_GRP='T'
|| _result:=0
|| _result:=1
?};
{? _result>0
||
: ponieważ redagowanie jest dla jednego typu operacji, to w oknie BADSEH.RED blokujemy pole TYP oraz AKT do redakcji
  BADSEH.efld_opt('RED','editable=grayed',,'TYP');
  BADSEH.efld_opt('RED','editable=grayed',,'AKT')
?};
_result


\zgp_badseh_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Po redakcji pola ZGP.BADSEH
::   WY: 0/1
::  TAG: <MBUILDER>
::  OLD: \zgp_badseh_ae/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
BADVAR.TYP_BAD:='M';
: przywracam stan zablokowanych pól
BADSEH.efld_opt('RED','editable=1',,'TYP');
BADSEH.efld_opt('RED','editable=1',,'AKT');
1


\zgp_kjbad_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Po redakcji pola ZGP.KJ_BAD
::   WY: 0/1
::  TAG: <MBUILDER>
::  OLD: \zgp_kjbad_ae/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('zgp_efld_opt','zl_guide');
win_disp();
1


\find_uid_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Argumenty dla funkcji find_uid
::   WY: obj_new()
::  TAG: <PUBLICZNA>
::  OLD: \find_uid_a/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('ZGP'
   ,'BRAKIUID'
   ,'FOUND'
   ,'VISITED'
   ,'REC'
);
_args.ZGP:=null();
_args.BRAKIUID:='';
_args.FOUND:=0;
_args.REC:=0;
_args.VISITED:=exec('ref_table','#table');
_args


\find_uid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Dla podanego ZGPa szuka UIDa po którym można zsumować ilości wykonane i ilości braków
::       do poprawnego wyliczania ilości które mogę wykonać na następnej, poprzedniej operacji
::   WE: _a - obj_new - argumenty funkcji
::   WY: STRING - uid
::  TAG: <PUBLICZNA>
::  OLD: \find_uid/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:='';

ZGP.cntx_psh();
ZGP.prefix();

{? _args.REC=0
|| obj_del(_args.VISITED);
   _args.VISITED:=exec('ref_table','#table')
?};

{? ZGP.seek(_args.ZGP) & _args.VISITED.r_find(_args.ZGP)=0
|| _args.VISITED.add(ZGP.ref());
   {? _args.BRAKIUID<>'' & _args.BRAKIUID=ZGP.BRAKIUID
   ||
::    Dotarłem do podanej ścieżki naprawczej na której się trzeba zatrzymać
::    więc zwracam UID operacji w tej ścieżce i nie idę dalej
      _result:=ZGP.UID
   ||
      {? ZGP.UID_SRC<>''
      ||
         ZGP.cntx_psh();
         ZGP.index('UID');
         ZGP.prefix(ZGP.UID_SRC);
         {? ZGP.first()
         ||
::          Stoję na rodzicu, uruchamiam rekurencję
            _old_zgp:=_args.ZGP;
            _old_rec:=_args.REC;

            _args.ZGP:=ZGP.ref();
            _args.REC:=1;
::          !!! REKURENCJA !!!
            _res_rec:=exec('find_uid','zl_guide',_args);
            {? _res_rec<>''
            || _result:=_res_rec
            ?};
            _args.ZGP:=_old_zgp;
            _args.REC:=_old_rec
         ?};
         ZGP.cntx_pop()
      || _result:=ZGP.UID
      ?}
   ?}
?};

ZGP.cntx_pop();
_result


\utw_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Tworzy tabelę tymczasową zawierająca możliwe następniki operacji przewodnika
::       Kontekst wywołania:  VAR.A_NRZLP, VAR.A_ZGP
::   WE:  _a - ZL.ref() - zlecenie
::       [_b] - STRING - tytuł okienka, domyślnie: Dostępne operacje
::  OLD: \utw_nast/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

NASZGP.cntx_psh();
VAR_DEL.delete('__NAST');
__NAST:=tab_tmp(1,
   'UIN','REAL','Uin.następnika',
   'REF','INTEGER','Ref.do nastoper',
   'NROP','INTEGER','Nr operacji',
   'NAZ','STRING[100]','Nazwa operacji',
   'KOD','STRING[10]','Kod operacji',
   'SCIEZKA','STRING[20]','Ścieżka',
   'WEW','STRING[1]','Wewnętrzna',
   'PL_GRP','STRING[1]','Grupowa',
   'KONTROLA','STRING[1]','Kontrola jakości',
   'ILOSC','REAL','Ilość na operacji',
   'SQLREF','STRING[16]','Ref SQL operacji',
   'NAPRAW','STRING[1]','Czy operacja naprawcza',
   'NAPR_TYP','STRING[20]','Typ operacji naprawczej'
);

_title:='Dostępne operacje'@;
{? var_pres('_b')=type_of('')
|| _title:=_b
?};

__NAST.fld_attr('UIN',2);
__NAST.fld_attr('REF',2);
__NAST.fld_attr('NROP',2);
__WER:=__NAST.mk_sel(_title,'N',0,'nastepniki',,5,,,'U');
__NAST.win_fld(__WER,,'SCIEZKA',,,10,,,'Nr operacji'@,,,,1);
__NAST.win_fld(__WER,,'NAZ',,,50,,,'Nazwa operacji'@);
__NAST.win_fld(__WER,,'KOD',,,10,,,'Kod'@);
__NAST.win_fld(__WER,,'WEW',,,-5,,,'Wewnętrzna'@,,'Operacja wewnętrzna'@,2,,"\'T\'","\'N\'");
__NAST.win_fld(__WER,,'KONTROLA',,,-5,,,'Kontrola jakości'@,,'Operacja typu kontrola jakości'@,2,,"\'T\'","\'N\'");
__NAST.win_fld(__WER,,'NAPRAW',,,-5,,,'Naprawcza'@,,'Operacja naprawcza'@,2,,"\'T\'","\'N\'");

__NAST.win_act(__WER,0,'Formuła','Wybierz'@@,,,"sel_exit()",,1);
__NAST.win_act(__WER,0,'Kolejność');
__NAST.win_sel(__WER);

_zgh:=VAR.A_NRZLP;

ZGP.cntx_psh();
ZGP.index('PNRPP');
ZGP.prefix(_zgh,'N');
{? ZGP.first()
|| {!
   |? {? ZGP.ref()<>VAR.A_ZGP
      || ZGH.cntx_psh();
         __NAST.UIN:=#ZGP.ref();
         __NAST.SQLREF:=$ZGP.ref();
         __NAST.NROP:=ZGP.NRP;
         __NAST.NAZ:='('+ZGP.NRZLP().NRPRZ+' - '+form(ZGP.NRP,-2)+') '+ZGP.OPIS;
         __NAST.KOD:={? ZGP.WEW='T'
                     || ZGP.TOPER().OPER().KOD
                     || ZGP.TOPER().TTOUT().KOD
                     ?};
         __NAST.WEW:=ZGP.WEW;
         __NAST.SCIEZKA:=$(ZGP.NRP);
         __NAST.PL_GRP:=ZGP.PL_GRP;
         __NAST.ILOSC:=ZGP.ILOSC;
         __NAST.KONTROLA:=ZGP.KONTROLA;
         __NAST.NAPRAW:=ZGP.NAPRAW;
         __NAST.add();
         ZGH.cntx_pop()
      ?};
      ZGP.next()
   !}
?};
ZGP.cntx_pop();

exec('del_nast','zl_guide',VAR.A_ZGP,_zl);
exec('del_exist','zl_guide',VAR.A_ZGP,_zl);
{? VAR.A_ZGP().PL_GRP='T' || exec('del_grop','zl_guide') ?};
NASZGP.cntx_pop();
~~


\del_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Usuwa z listy następników rekordy które nie mogą być następnikami
::   WE: _a: ZGP.ref()
::       _b: ZL.ref()
::  OLD: \del_nast/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_oper:=_a;
_zl:=_b;

NASZGP.cntx_psh();
NASZGP.index('UNROP');
NASZGP.prefix(_zl,_oper);
{? NASZGP.first()
|| {!
   |? exec('del_nast','zl_guide',NASZGP.OPER,_zl);
      __NAST.prefix(#NASZGP.OPER);
      {? __NAST.first()
      || __NAST.del()
      ?};
      NASZGP.next()
   !}
?};
NASZGP.cntx_pop();
~~


\del_exist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Usuwa niepotrzebne pozycje z listy możliwych następnikow
::   WE: _a: ZGP.ref()
::  OLD: \del_exist/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_oper:=_a;

_ndx:=NASZGP.ndx_tmp(,1,'OPER',,,'NRNAST',,);
__NAST.prefix();
__NAST.first();
NASZGP.index(_ndx);
{!
|? NASZGP.prefix(_oper,__NAST.UIN);
   {? NASZGP.first()
   || __NAST.del()
   || __NAST.next()
   ?}
!};
NASZGP.clear();
NASZGP.ndx_drop(_ndx);
&_ndx;
~~


\del_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Usuwa operacje grupowe z możliwych następników
::  OLD: \del_grop/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
__NAST.clear();
{? __NAST.first()
|| {!
   |? {? __NAST.PL_GRP='T' || __NAST.del() || __NAST.next() ?}
   !}
?};
~~


\interzlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca tabelę powiązań między operacjami przewodników zlecenia
::   WE: _a - ZL.ref()
::----------------------------------------------------------------------------------------------------------------------
_unrzl:=exec('FindAndGet','#table',ZL,_a,,"UNRZL",0);
_tab:=tab_tmp(,'SYM','STRING[20]','','REF','STRING[16]','');

ZL.cntx_psh();
NASZGP.cntx_psh();

ZL.index('NRNZL');
ZL.prefix(_unrzl);
{? ZL.first()
|| {!
   |? NASZGP.index('ZLPOPNA');
      NASZGP.prefix(ZL.ref());
      {? NASZGP.first()
      || {!
         |? {? NASZGP.KTL<>NASZGP.ZLNAST
            || _tab.SYM:=NASZGP.KTL().SYM;
               _tab.REF:=$NASZGP.ref();
               _tab.add()
            ?};
            NASZGP.next()
         !}
      ?};
      ZL.next()
   !}
?};
NASZGP.cntx_pop();
ZL.cntx_pop();

_tab


\zgh_deleted_in_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Obsługa sytuacji że jest czynność na liście todo ale przewodnik został usunięty
::   WE: _a - obj_new - obiekt Menadżera Procesów
::   WY: ~~
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=_a;
_msg:='Przewodnik nie został odnaleziony, prawdopodobnie został usunięty.'@;
{? _mp.isService()=0
|| FUN.emsg(_msg)
?};
_mp.error(_msg);
~~


\stat_rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca aktualną wartość statusu zakończenia rejestracji przewodników zlecenia (prostego)
::   WE: _a - ZL.ref()
::   WY: 'T' - wszystkie przewodniki mają ZGH.STAT_REJ='T' (lub brak przewodników), 'N' - nie wszystkie
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:='T';
ZGH.cntx_psh();
ZGH.index('ZLNR');
ZGH.prefix(_zl);
{? ZGH.first()
|| {!
   |? {? ZGH.STAT_REJ='N' || _result:='N' ?};
      ZGH.next()
   !}
?};
ZGH.cntx_pop();

_result


\cofaj_przewodniki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zmienia znacznik zakończenia na przewodnikach zlecenia
::       UWAGA: nie sprawdza powiązań
::   WE: _a - ZL.ref()
::   WY: 1 - udało się zmienić znacznik dla wszystkich przewodników (albo nie było przewodników),
::       0 - nie udało się zmienić znacznika dla conajmniej jednego przewodnika
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0
|| do();
   _tran_started:=1
?};

_result:=1;
ZGH.cntx_psh();
ZGH.index('ZLNR');
ZGH.prefix(_zl);
{? ZGH.first()
|| {!
   |? ZGH.STAT_REJ:='N';
      {? ~ZGH.put() || _result:=0 ?};
      _result>0 & ZGH.next()
   !}
?};
ZGH.cntx_pop();

{? _result=0
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\gen_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Tworzy tabele nastepnikow dla przewodnikow zlecenia.
::   WE: _a: ZGH.ref()
::  OLD: \gen_nast/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
ZGP.cntx_psh();
ZGP.index('TOPERPOD');
NASTOPER.cntx_psh();
NASTOPER.index('OPER_SOR');
NASTOPER.prefix('T',VAR.A_KTL);

{? NASTOPER.first()
|| {!
   |? ZGP.prefix(_a,$NASTOPER.OPER);
      {? ZGP.first()
      || _oper:=ZGP.ref();
         ZGP.prefix(_a,$NASTOPER.NRNAST);
         {? ZGP.first()
         || NASZGP.prefix();
            NASZGP.KTL:=VAR.A_ZLEC;
            NASZGP.OPER:=_oper;
            NASZGP.NRNAST:=ZGP.ref();
            NASZGP.SCIEZKA:=$(ZGP.NRP);
            NASZGP.ZLNAST:=VAR.A_ZLEC;
            _can_continue:=NASZGP.add(1);
            {? _can_continue>0
            || exec('pl_next_update','po_plan',NASZGP.OPER)
            ?}
         ||
::          Jeżeli nie znaleziono następnika operacji, to przypisywana jest kolejna dostępna operacja.
::          Działanie ma uzasadnienie w przypadku, gdy jedna z operacji "wyleci" ze zlecenia (poprzez parametry)
            {? $NASTOPER.NRNAST<>''
            ||
::              Zapisuję refa do którego wrócę po zakończeniu pętli
               _ref:= NASTOPER.ref;
::              Zapisuję refa do operacji, której poszukuje
               _ref_nast:=NASTOPER.NRNAST;
               _next:=1;
               {!
               |? NASTOPER.next() & _next
               |! {? NASTOPER.OPER=_ref_nast
                  || _ref_nast:=NASTOPER.NRNAST;
                     ZGP.prefix(_a,$NASTOPER.NRNAST);
                     {? ZGP.first()
                     || _next:=0;
                        NASZGP.prefix();
                        NASZGP.KTL:=VAR.A_ZLEC;
                        NASZGP.OPER:=_oper;
                        NASZGP.NRNAST:=ZGP.ref();
                        NASZGP.SCIEZKA:=$(ZGP.NRP);
                        NASZGP.ZLNAST:=VAR.A_ZLEC;
                        _can_continue:=NASZGP.add(1);
                        {? _can_continue>0
                        || exec('pl_next_update','po_plan',NASZGP.OPER)
                        ?}
                     ?}
                  ?}
               !};
               NASTOPER.seek(_ref)
            ?}
         ?}
      ?};
      NASTOPER.next()
   !}
?};
NASTOPER.cntx_pop();
ZGP.cntx_pop();
~~


\gen_nast_pl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Tworzy tabele nastepnikow dla przewodnikow zlecenia na podstawie powiązań w planie
::   WE: _a - ZGH.ref()
::       _b - PL_PART.ref()
::  OLD: \gen_nast_pl/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_zgh:=_a;
_plpart:=_b;
ZGP.cntx_psh();
NASZGP.cntx_psh();
PL_OPER.cntx_psh();
PL_OPER.index('PL_PART');
PL_NEXT.cntx_psh();
PL_NEXT.index('PL_OPER');
PL_OPER.prefix(_plpart);
{? PL_OPER.first()
||
   _buffer:=exec('ZGP','buffer');
   {!
   |?
      {? PL_OPER.ZGP<>null()
      ||
::       Iteruje po nastepnikach operacji w planie i na ich podstawie buduję następniki przewodnika
         PL_NEXT.prefix(PL_OPER.ref());
         _buffer.cntx_get(PL_OPER.ZGP);
         {? PL_NEXT.first()
         || {!
            |?
               {? PL_NEXT.NEXT<>null()
               ||
::                Następnik jest normalną operacją
                  PL_OPER.cntx_psh();
::                Podczytuję następną operację
                  PL_NEXT.NEXT();
                  {? PL_OPER.ZGP<>null()
                  ||
::                   Tworzę połączenie
                     NASZGP.prefix();
                     NASZGP.KTL:=VAR.A_ZLEC;
                     NASZGP.OPER:=_buffer.Ref;
                     NASZGP.NRNAST:=PL_OPER.ZGP;
                     NASZGP.SCIEZKA:=$(PL_OPER.ZGP().NRP);
                     NASZGP.ZLNAST:=VAR.A_ZLEC;
                     _can_continue:=NASZGP.add(1)
                  ?};
                  PL_OPER.cntx_pop()
               |? PL_NEXT.NEXT_OGR<>null()
               ||
::                Następnik jest grupą operacji
                  PL_OGR.cntx_psh();
                  PL_NEXT.PL_OGR();
                  GROPP.cntx_psh();
                  GROPP.index('GROP');
                  GROPP.prefix(PL_OGR.GROP);
                  {? GROPP.first()
                  || {!
                     |?
                        {? GROPP.ZGP<>null() & (GROPP.ZGP().NRPRZ=_zgh | GROPP.ZGP().NRZLP=_zgh)
                        ||
::                         Tworzę połączenie
                           NASZGP.prefix();
                           NASZGP.KTL:=VAR.A_ZLEC;
                           NASZGP.OPER:=_buffer.Ref;
                           NASZGP.NRNAST:=GROPP.ZGP;
                           NASZGP.SCIEZKA:=$(GROPP.ZGP().NRP);
                           NASZGP.ZLNAST:=VAR.A_ZLEC;
                           _can_continue:=NASZGP.add(1)
                        ?};
                        GROPP.next()
                     !}
                  ?};
                  GROPP.cntx_pop();
                  PL_OGR.cntx_pop()
               ?};
               PL_NEXT.next()
            !}
         ?}
      ?};
      PL_OPER.next()
   !}
?};
PL_NEXT.cntx_pop();
PL_OPER.cntx_pop();
NASZGP.cntx_pop();
ZGP.cntx_pop();
~~


\gendom_zgh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja odtworzenia domyślnych powiązań na przewodniku w oknie wertowania ZGH
::   WE: [_a] - ZGH.ref lub bieżący rekord
::       [_b] - INTEGER - 0/[1] - czy wyświetlać dialogi?
::   WY: 0  - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGH.ref())
|| _ref:=_a
?};

_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_grupa:=0;
{? ZGH.sel_size()>0
|| _grupa:=1;
   _dialog:=0
|| KOMM.init(250,,'Odtwarzanie powiązań przewodnika.'@)
?};

_result:=0;
_can_continue:=1;

ZGH.cntx_psh();
{? _ref<>null()
|| ZGH.prefix();
   {? ZGH.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? _dialog>0
   || _can_continue:=FUN.ask('Czy odtwarzać domyślne powiązania dla przewodnika: %1'@[exec('record','#to_string',ZGH.ref())])
   ?};

   {? _can_continue>0
   || {? ZGH.STAT_REJ='T'
      || _can_continue:=0;
         KOMM.add('Zakończono rejestrację przewodnika: %1.'@[exec('record','#to_string',ZGH.ref())]+' '+'Odtwarzanie powiązań niemożliwe.'@,2)
      ?}
   ?};

   {? _can_continue>0
   ||
      _old_zlec:=VAR.A_ZLEC;
      _old_tktl:=VAR.A_KTL;
      VAR.A_ZLEC:=ZGH.ZLEC;
      ZL.cntx_psh();
      PL_OPER.cntx_psh();
      PL_PART.cntx_psh();
      PL_PART.index('ZGH');
      NASZGP.cntx_psh();
      NASZGP.index('OPNAST');
      PL_OPER.index('ZGP');
      ZGP.cntx_psh();
      ZGP.index('PNRPP');
      ZGP.prefix(ZGH.ref(),'N');

::    1. Kasujemy te powiązania które można skasować
      {? ZGP.first()
      || {!
         |?
            _can_del:=0;
            PL_OPER.prefix(ZGP.ref());
            {? PL_OPER.size()>0
            || _can_del:=1
            |? ZGP.TOPER<>null()
            || _can_del:=1
            ?};
            {? _can_del>0
            || NASZGP.prefix(ZGP.ref());
               {? NASZGP.first()
               || {!
                  |? _next:=0;
                     _ref_nxt:=null();
                     NASZGP.cntx_psh();
                     {? NASZGP.next()
                     || _ref_nxt:=NASZGP.ref()
                     ?};
                     NASZGP.cntx_pop();

::                   Kasujemy tylko te w obrębie jednego zlecenia - nie ruszamy międzyzleceniowych
                     {? NASZGP.ZLNAST=NASZGP.KTL
                     || _can_continue:=NASZGP.del(,1)
                     ?};
                     {? _ref_nxt<>null()
                     || _next:=NASZGP.seek(_ref_nxt)
                     ?};
                     _next>0 & _can_continue>0
                  !}
               ?}
            || KOMM.add('Nie odtworzono powiązań dla pozycji przewodnika: %1 ponieważ nie ma ich skąd odtworzyć.'@[exec('record','#to_string',ZGP.ref())],2)
            ?};
            ZGP.next() & _can_continue
         !}
      ?};

      PL_PART.prefix(ZGH.ref());
      {? PL_PART.first()
      ||
::       Jest plan - generuję na podstawie planu
         {!
         |? exec('gen_nast_pl','zl_guide',ZGH.ref(),PL_PART.ref());
            PL_PART.next()
         !}
      ||
::       Nie ma planu, generuję na podstawie NASTOPERów
         {? ZGH.ZLEC().RTKTL<>''
         || VAR.A_KTL:=exec('FindAndGet','#table',TKTL,ZGH.ZLEC().RTKTL,,,null())
         |? ZGH.ZLEC().RKTL<>''
         || VAR.A_KTL:=exec('FindAndGet','#table',TKTL,ZGH.ZLEC().RKTL,,,null())
         ?};
         exec('gen_nast','zl_guide',ZGH.ref())
      ?};

      PL_PART.cntx_pop();
      NASZGP.cntx_pop();
      ZGP.cntx_pop();
      PL_OPER.cntx_pop();
      ZL.cntx_pop();

      VAR.A_ZLEC:=_old_zlec;
      VAR.A_KTL:=_old_tktl;
      ~~
   ?}
?};
{? _grupa=0
|| KOMM.select()
?};
ZGH.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\gendom_zgh_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja grupa przed odtworzeniem domyślnych powiązań na przewodniku w oknie wertowania ZGH
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_msg:='Zaznaczono: %1 przewodników. Czy wszystkim zaznaczonym odtwarzać domyślne powiązania?'@[$ZGH.sel_size()];
{? FUN.ask(_msg)
|| _result:=1;
   KOMM.init(250,,'Odtwarzanie powiązań przewodników.'@)
?};
_result


\gendom_zgh_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja grupa po odtworzeniem domyślnych powiązań na przewodniku w oknie wertowania ZGH
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
KOMM.select();
~~


\ilnprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca ilość na źródłowym przewodniku
::   WE: ZGH.UID
::   WY: ZGH.ILNPRZ
::----------------------------------------------------------------------------------------------------------------------
_uid:=_a;
_ilnprz:=0;

ZGH.cntx_psh();
ZGH.index('UID');
ZGH.prefix(_uid);
{? ZGH.first() || _ilnprz:=ZGH.ILNPRZ ?};
ZGH.cntx_pop();

_ilnprz


\zgh_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wyświetlenie nagłówka przewodnika
::----------------------------------------------------------------------------------------------------------------------
_wp:=exec('FindAndGet','#table',ZL,ZGH.ZLEC,,"TYP().WP",'W');
ZGH.win_edit('DISP'+_wp);
ZGH.display();
~~


\add_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Wypełnia podstawowe dane dotyczące nowego następnika
::   WE: _a - #ZGP.ref()
::       _b - ścieżka do następnika operacji.
::       _c - ZL.ref()
::       _d - ZL.ref() - ref do zlecenia następnika
::  OLD: \add_nast/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_nast:=exec('FindAndGet','#table',ZGP,_a,ZGP.name(),,null());
NASZGP.KTL:=_c;
NASZGP.OPER:=VAR.A_ZGP;
NASZGP.ZLNAST:=_d;
NASZGP.NRNAST:=_nast;
NASZGP.SCIEZKA:=_b;
~~


\spr_ilosc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MK - 2002/12/30 - modyfikacje [7.62]
:: OPIS: Sumuje ilosci zarejestrowane na wszystkich przewodnikach danego zlecenia.
::       Wylicza faktyczna wielkosc produkcji toku
::   WE: _a - Ilosc przed przeliczeniem
::       [_b] - 0 (dla akordu - domyslnie), 1 (dla kooperacji)
::   WY: Wyliczona ilosc
::  OLD: \spr_ilosc/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
:: TODO: Modyfikacja ilości na zleceniu otwartym
{? var_pres('_b')=type_of(0) || _koop:=_b || _koop:=0 ?};

_proc:=0;
_il:=0;
: Zlecenie nadrzedne w zlozonym z podrzednymi zaleznymi
{? VAR.A_ZLEC().NRNZL=0 & VAR.A_ZLEC().RODZAJ='Z'
|| ZL.cntx_psh();
   ZL.index('NRNZL');
   ZL.prefix(ZL.UNRZL);
   {? ZL.first
   || {!
      |? _il:=0;
         ZGH.cntx_psh();
         ZGH.index('ZLNR');
         ZGH.prefix(ZL.ref());
         {? ZGH.first
         || {!
            |? _il+=exec('max_akord','zl_guide',ZGH.ref(),_koop);
               ZGH.next
            !}
         ?};
         ZGH.cntx_pop();
         {? _a<>0
         || {? ZL.NR=1
            || _proc:=_il/ZL.IL
            || {? _proc<_il/ZL.IL
               || _proc:=_il/ZL.IL
               ?}
            ?}
         || {? proc<1 || proc:=1 ?}
         ?};
         ZL.next
      !}
   ?};
   ZL.cntx_pop();
   exec('zaokr','jm',_proc*_a,ZL.KTM)
: zlecenie pojedyncze
|? VAR.A_ZLEC().NRNZL=0 & VAR.A_ZLEC().RODZAJ='P'
|| ZGH.cntx_psh();
   ZGH.index('ZLNR');
   ZGH.prefix(VAR.A_ZLEC);
   {? ZGH.first
   || {!
      |? _il+=exec('max_akord','zl_guide',ZGH.ref(),_koop);
         ZGH.next
      !}
   ?};
   ZGH.cntx_pop();
   _il
: zlecenia podrzedne
|? VAR.A_ZLEC().NRNZL<>0
|| {? VAR.A_ZLEC().NR<>1
   || ZGH.cntx_psh();
      ZGH.index('ZLNR');
      ZGH.prefix(VAR.A_ZLEC);
      {? ZGH.first
      || {!
         |? _il+=exec('max_akord','zl_guide',ZGH.ref(),_koop);
            ZGH.next
         !}
      ?};
      ZGH.cntx_pop();
      _il
   || ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(ZL.NRNZL);
      {? ZL.first
      || {!
         |? _il:=0;
            ZGH.cntx_psh();
            ZGH.index('ZLNR');
            ZGH.prefix(ZL.ref());
            {? ZGH.first
            || {!
               |?
                  _il+=exec('max_akord','zl_guide',ZGH.ref(),_koop);
                  ZGH.next
               !}
            ?};
            ZGH.cntx_pop();
            {? ZL.IL<>0
            || {? ZL.NR=1
               || _proc:=_il/_a
               || {? _proc<_il/ZL.IL
                  || _proc:=_il/ZL.IL
                  ?}
               ?}
            || {? proc<1 || proc:=1 ?}
            ?};
            ZL.next
         !}
      ?};
      ZL.cntx_pop();
      exec('zaokr','jm',_proc*_a,ZL.KTM)
   ?}
?}


\spr_ilwyk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2009]
:: OPIS: Sumuje ilosci zarejestrowane na wszystkich przewodnikach danego zlecenia.
::       Wylicza faktyczna wielkosc produkcji toku.
::   WE: Ilosc przed przeliczeniem
::   WY: Wyliczona ilosc
::  OLD: \spr_ilwyk/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
:: TODO: Modyfikacja ilości na zleceniu otwartym
_proc:=1;
_il:=0;
: Zlecenie nadrzedne w zlozonym z podrzednymi zaleznymi
{? VAR.A_ZLEC().NRNZL=0 & VAR.A_ZLEC().RODZAJ='Z'
|| ZL.cntx_psh();
   ZL.index('NRNZL');
   ZL.prefix(ZL.UNRZL);
   {? ZL.first
   || {!
      |? _il:=ZL.ILWYK;
         {? ZL.IL<>0
         || {? ZL.NR=1
            || _proc:=_il/ZL.IL
            || {? _proc<_il/ZL.IL
               || _proc:=_il/ZL.IL
               ?}
            ?}
         || {? proc<1 || proc:=1 ?}
         ?};
         ZL.next
      !}
   ?};
   ZL.cntx_pop();
   exec('zaokr','jm',_proc*_a,ZL.KTM)
: zlecenie pojedyncze
|? VAR.A_ZLEC().NRNZL=0 & VAR.A_ZLEC().RODZAJ='P'
|| ZL.ILWYK
: zlecenia podrzedne
|? VAR.A_ZLEC().NRNZL<>0
|| {? VAR.A_ZLEC().NR<>1
   || ZL.ILWYK
   || ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(ZL.NRNZL);
      {? ZL.first
      || {!
         |? _il:=ZL.ILWYK;
            {? ZL.IL<>0
            || {? ZL.NR=1
               || _proc:=_il/_a
               || {? _proc<_il/ZL.IL
                  || _proc:=_il/ZL.IL
                  ?}
               ?}
            || {? proc<1 || proc:=1 ?}
            ?};
            ZL.next
         !}
      ?};
      ZL.cntx_pop();
      exec('zaokr','jm',_proc*_a,ZL.KTM)
   ?}
?}


\zl_il_increase
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Obsługa na przewodnikach po zmianie ilości na zleceniu (zwiększenie ilości)
::   WE: _a - REAL - Ilość o jaką zmieniamy
::       _b - REAL - Procent o jaki zmieniamy
::       [_c] - REAL - ilość ze zlecenia którą podzielić
::       [_d] - REAL - ilość na jednym przewodniku
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ilgen:=_a;
_proc:=_b;

_il_zl:=0;
{? var_pres('_c')=type_of(0)
|| _il_zl:=_c
?};
_il_zgh:=0;
{? var_pres('_d')=type_of(0)
|| _il_zgh:=_d
?};

_can_continue:=1;
_result:=0;

_uid:=exec('uid','#blank');
_oper:='';
_tktl:='';
{? ZL.RTKTL<>''
|| _tktl:=ZL.RTKTL
|? ZL.RKTL<>''
|| _tktl:=ZL.RKTL
?};
{? _tktl<>''
|| _oper:=exec('FindAndGet','#table',TKTL,_tktl,,"TYP().OPER",'N')
?};

{? _oper='N'
||
:: Technologia bez operacji - modyfikacja przewodnika technicznego
   exec('mod_tech_guid','zl_guide',ZL.ref(),_ilgen)
||
:: Technologia z operacjami, uruchamiam dogenerowanie przewodników
   _can_continue:=exec('generuj','zl_guide',0,0,0,_uid,,1,_il_zl,_il_zgh,1)
?};

{? _can_continue>0
|| _result:=1
?};
_result


\zl_il_decrease
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Zmniejsza (redukuje) ilosci na przewodniku, gdy przewodniki sa na 0 szt to kasuje (zamyka).
::       Wywolywane podczas modyfikacji ilosci dla zlecenia otwartego.
::   WE: _a - Ilosc o jaka nastepuje modyfikacja
::       _b - procent modyfikacji
::       [_c] - ref_table - tablica przewodników które były już korygowane
::   WY: 1
::  OLD: \red_zgh/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
_il:=_a;
_proc:=_b;
_zgh_corrected:=~~;
{? var_pres('_c')>100
|| _zgh_corrected:=_c
|| _zgh_corrected:=exec('ref_table','#table')
?};

_can_continue:=1;
_result:=1;
_old_grupa:=VAR.GRUPA;
VAR.GRUPA:='T';

{? ZL.NRNZL=0 & ZL.RODZAJ='Z'
||
:: Zlecenie złożone
::   ZL.cntx_psh();
::   ZL.index('NRNZL');
::   ZL.prefix(ZL.UNRZL);
::   {? ZL.first()
::   || _nad_upd:=0;
::      {!
::      |? _il:=exec('zaokr','jm',(ZL.IL-_proc*ZL.IL),ZL.KTM,1);
::
::         ZL.next() & _can_continue>0
::      !}
::   ?};
::   ZL.cntx_pop();

   ZGH.cntx_psh();
   ZGH.index('ZLNR');
   ZGH.prefix(ZL.ref());
:: Korekta ilości, usuwanie przewodników
   _can_continue:=exec('correction_decrease','zl_guide',_il,,_zgh_corrected);
   ZGH.cntx_pop();

:: Usuwanie zerowych przewodników
   ZGH.cntx_psh;
   ZGH.index('ZLNR');
   ZGH.prefix(ZL.ref());
   _can_continue:=exec('correction_del_empty','zl_guide');
   ZGH.cntx_pop()
|? ZL.NRNZL=0 & ZL.RODZAJ='P'
||
:: Zlecenie proste

   ZGH.cntx_psh();
   ZGH.index('ZLNR');
   ZGH.prefix(ZL.ref());

:: Korekta ilości, usuwanie przewodników
   _can_continue:=exec('correction_decrease','zl_guide',_il,,_zgh_corrected);

   ZGH.cntx_pop()

||
:: podrzedne niepierwsze i podrzedne pierwsze niezalezne
   ZL.cntx_psh();
   _rodz:=(exec('top_rodzaj','zl_link',VAR.A_ZLEC)='N');
   ZL.cntx_pop();
   {? ZL.NR<>1
   |  ZL.NR=1 & _rodz
   || ZGH.cntx_psh();
      ZGH.index('ZLNR');
      ZGH.prefix(VAR.A_ZLEC);

::    Korekta ilości, usuwanie przewodników
      _can_continue:=exec('correction_decrease','zl_guide',_il,,_zgh_corrected);
      ZGH.cntx_pop()

:: zlecenie podrzedne pierwsze w zlozonym z zaleznymi
   ||
      _var:=VAR.A_ZLEC;
::      ZL.cntx_psh();
::      ZL.index('NRNZL');
::      ZL.prefix(ZL.NRNZL);
::      {? ZL.first()
::      || {!
::         |? {? ZL.NR<>1
::            ||
::               _il:=exec('zaokr','jm',(ZL.IL-_proc*ZL.IL),ZL.KTM);
::               _il2:=exec('zaokr','jm',(_proc*ZL.IL),ZL.KTM);
::               VAR.A_ZLEC:=ZL.ref();
::               exec('add_korlim','zl_limit',_proc,_il2)
::            ?};
::            ZL.next() & _can_continue>0
::         !}
::      ?};
::      VAR.A_ZLEC:=_var;
::
::      ZL.cntx_pop();

      ZGH.cntx_psh();
      ZGH.index('ZLNR');
      ZGH.prefix(ZL.ref());
::    Korekta ilości, usuwanie przewodników
      _can_continue:=exec('correction_decrease','zl_guide',_il,,_zgh_corrected);
      ZGH.cntx_pop();


::    przelicz ilosci na przewodnikach w zl. nadrz. i wykasuj zerowe
::      {? ZL.NR=1
::      || ZL.index('UNRZL');
::         ZL.prefix(ZL.NRNZL);
::         {? ZL.first()
::         ||
::            ZGH.cntx_psh();
::            ZGH.index('ZLNR');
::            ZGH.prefix(ZL.ref());
::::          Korekta ilości, usuwanie przewodników
::            _can_continue:=exec('correction_decrease','zl_guide',_il);
::            ZGH.cntx_pop()
::         ?}
::      ?};
      VAR.A_ZLEC:=_var
   ?}
?};
VAR.GRUPA:=_old_grupa;
{? _can_continue=0
|| _result:=0
|| _result:=1
?};
ZGH.get();
_result


\correction_decrease
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Koryguje bieżącą dziedzinę przewodników, zmniejszając im ilości od końca, a te z zerową ilością usuwa
::       Kontekst pracy - zaprefiksowana dziedzina ZGH
::   WE: _a - REAL - ilość do korekty
::       [_b] - REAL - współczynnik zmniejszenia (1 - koryguje wszystko, 0 - nie koryguje nic)
::       [_c] - ref_table - tablica przewodników które były już korygowane
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_il_all:=_a;

_coef_in:=-1;
{? var_pres('_b')=type_of(0)
|| _coef_in:=_b
?};
_zgh_corrected:=~~;
{? var_pres('_c')>100
|| _zgh_corrected:=_c
|| _zgh_corrected:=exec('ref_table','#table')
?};

_result:=1;
_can_continue:=1;
{? ZGH.last()
|| {!
   |?
      _next:=0;
      _ref_nxt:=null();
      ZGH.cntx_psh();
      {? ZGH.prev()
      || _ref_nxt:=ZGH.ref()
      ?};
      ZGH.cntx_pop();

      {? ZGH.STAN='N'
      ||
         {? var_pres('_res_zgh')>100
         || obj_del(_res_zgh)
         ?};
::       Zmniejszam pojedynczy przewodnik
         _res_zgh:=exec('correction_decrease_core','zl_guide',_il_all,_coef_in,_zgh_corrected);
         _can_continue:=_res_zgh.RESULT;
         {? _can_continue>0
         || _il_all-=_res_zgh.IL_KOR
         || _result:=0
         ?};

         {? _il_all>0 & _can_continue>0
         || _can_continue:=1
         || _can_continue:=0
         ?}
      || _can_continue:=1
      ?};
      {? _ref_nxt<>null()
      || _next:=ZGH.seek(_ref_nxt)
      ?};
      _next>0 & _can_continue>0
   !}
?};

{? _result>0 & _il_all>0
||
:: Jeżeli nie cała ilość została zmniejszona do wymaganej to funkcja zwraca 0
   _result:=0
?};
_result


\correction_decrease_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Koryguje bieżący przewodnik
::       Kontekst pracy - rekord ZGH
::   WE:  _a - REAL - ilość do korekty
::       [_b] - REAL - współczynnik zmniejszenia (1 - koryguje wszystko, 0 - nie koryguje nic)
::       [_c] - ref_table - tablica przewodników które były już korygowane
::   WY: obj_new: 'RESULT' - 0/1 sukces czy porażka
::                'IL_KOR' - REAL - ilość jaka została skorygowana
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_il_all:=_a;

_coef_in:=-1;
{? var_pres('_b')=type_of(0)
|| _coef_in:=_b
?};
_zgh_corrected:=~~;
{? var_pres('_c')>100
|| _zgh_corrected:=_c
|| _zgh_corrected:=exec('ref_table','#table')
?};

_can_continue:=1;
_obj:=obj_new('RESULT','IL_KOR');
_obj.RESULT:=1;
_obj.IL_KOR:=0;

{? _zgh_corrected.r_find(ZGH.ref())=0
|| _zgh_corrected.add(ZGH.ref());
   _old_il:=ZGH.ILNPRZ;

   {? _coef_in>-1
   || _coef_on_zgh:=_coef_in
   || _coef_on_zgh:=_il_all/ZGH.ILNPRZ
   ?};
:: Normalizacja 0..1
   _coef_on_zgh:=exec('max','#math',_coef_on_zgh,0);
   _coef_on_zgh:=exec('min','#math',_coef_on_zgh,1);

:: Uruchamiam korektę współczynnika dla przewodnika w oparciu o robociznę, partie itp
   _coef_on_zgh:=exec('get_ilosc2decrease','zl_guide',,_coef_on_zgh);

:: Obliczam ilość jaka zostanie przewodnikowi odjęta
   _il4zgh:=ZGH.ILNPRZ*_coef_on_zgh;

   _top_rodzaj:=exec('top_rodzaj','zl_link',ZGH.ZLEC);
   _top_level:=exec('top_level','zl_link',ZGH.ZLEC);

   _deleted:=0;

   {? _il4zgh>0
   ||
::    Najpierw korygujemy partie
      ZPARN.cntx_psh();
      ZPARN.index('ZGH');
      ZPARN.prefix(ZGH.ref());
      _can_continue:=exec('correction_decrease','zl_partie',_il4zgh);
      ZPARN.cntx_pop();

      {? _can_continue>0
      ||
::       Zaokrąglanie
         ZL.cntx_psh();
         M.cntx_psh();
         {? ZGH.ZLEC().KTM().DOKL=0
         || _il4zgh:=exec('floor','#math',_il4zgh)
         || _il4zgh:=_il4zgh$ZGH.ZLEC().KTM().DOKL
         ?};
         ZL.cntx_pop();
         M.cntx_pop();
         _il:=exec('zgh_chng','zl_guide',_il4zgh);

         {? _il>0
         ||
::          Jeżeli z ilości o którą chciałem zmniejszyć coś zostało, to znaczy
::          że ilość dla tego przewodnika do zmniejszenia została błędnie wyliczona
            _can_continue:=0;
            _obj.RESULT:=0;
            KOMM.add('Nie powiodła się korekta przewodnika: %1 (błędnie wyliczona ilość do korekty)'@[ZGH.NRPRZ],2,,1)
         ||
            _obj.IL_KOR:=_il4zgh;
::                  _top_rodzaj:=exec('top_rodzaj','zl_link',ZGH.ZLEC);
::                  {? _top_rodzaj<>'' & _top_rodzaj<>'P'
::                  || exec('nprz_upd','zl_guide')
::                  ?};
            {? ZGH.ILNPRZ=0
            ||
               {? exec('przp_us','zl_guide',1,1)>0
               || _deleted:=1
               || ZGH.STAN:='K';
                  _can_continue:=ZGH.put();
                  {? _can_continue>0
                  || KOMM.add('Zamknięto przewodnik (zerowa ilość): %1'@[ZGH.NRPRZ],13,,1)
                  || _obj.RESULT:=0
                  ?}
               ?}
            ?}
         ?}
      || _obj.RESULT:=0;
         KOMM.add('Nie powiodła się korekta partii przewodnika: %1 (błędnie wyliczona ilość do korekty)'@[ZGH.NRPRZ],2,,1)
      ?}
   ?};

   {? _can_continue>0 & _deleted=0 & _il4zgh>0 & _top_rodzaj='Z'
   ||
::    Uruchamiam korektę dla przewodników potomnych
      _uid:=ZGH.UID;
      _uid_parent:=ZGH.UID_SRC;
      ZGH.cntx_psh();
      ZGH.index('UID_SRC');

      _coef_in:=1-(ZGH.ILNPRZ/_old_il);

      _can_rec:=1;
      {? _uid<>''
      || ZGH.prefix(_uid);
         {? ZGH.first()
         || _can_rec:=1
         || _can_rec:=0
         ?}
      || _can_rec:=0
      ?};

      {? _can_rec>0
      || {!
         |?
            {? var_pres('_res_rec')>100
            || obj_del(_res_rec)
            ?};
::          !!! REKURENCJA !!!
            _res_rec:=exec('correction_decrease_core','zl_guide',_il_all,_coef_in,_zgh_corrected);
            _can_continue:=_res_rec.RESULT;
            ZGH.next() & _can_continue>0
         !}
      |? exec('chk_zgh_tied','zl_guide',ZGH.ZLEC)>0
      ||
::       Nie ma potomnych, ale może to wynikać z faktu że jestem na podzleceniu na Ntym poziomie
::       (tylko przewodniki na zleceniu montażowym mają potomków)
         {? _uid_parent<>''
         ||
            ZL.cntx_psh();
            ZL.index('TREEMTU');
            ZL.prefix(ZGH.ZLEC);
            {? ZL.first()
            || {!
               |? ZGH.cntx_psh();
                  ZGH.index('UID_SRC');
                  ZGH.prefix(_uid_parent,ZL.ref());
                  {? ZGH.first()
                  || {!
                     |?
                        {? var_pres('_res_rec')>100
                        || obj_del(_res_rec)
                        ?};
::                      !!! REKURENCJA !!!
                        _res_rec:=exec('correction_decrease_core','zl_guide',_il_all,_coef_in,_zgh_corrected);
                        _can_continue:=_res_rec.RESULT;
                        ZGH.next() & _can_continue>0
                     !}
                  ?};
                  ZGH.cntx_pop();
                  ZL.next() & _can_continue>0
               !}
            ?};
            ZL.cntx_pop()
         ?}
      ?};
      ZGH.cntx_pop()
   ?}
?};

{? _can_continue=0
|| _obj.RESULT:=0
?};
_obj


\correction_del_empty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Próbuje pousuwać wszystkie przewodniki z zerową ilością, jeżeli się nie uda
::       to oznacza je jako zamknięte
::       Kontekst pracy - zaprefiksowana dziedzina ZGH
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_can_continue:=1;

{? ZGH.first()
|| {!
   |? _next:=0;
      _ref_nxt:=null();
      ZGH.cntx_psh();
      {? ZGH.next()
      || _ref_nxt:=ZGH.ref()
      ?};
      ZGH.cntx_pop();

      {? ZGH.ILNPRZ=0
      ||
         {? exec('przp_us','zl_guide',1)<=0
         || ZGH.STAN:='K';
            _can_continue:=ZGH.put();
            {? _can_continue>0
            || KOMM.add('Zamknięto przewodnik (zerowa ilość): %1'@[ZGH.NRPRZ],13,,1)
            || _result:=0
            ?}
         ?}
      ?};
      {? _ref_nxt<>null()
      || _next:=ZGH.seek(_ref_nxt)
      ?};
      _next>0 & _can_continue>0
   !}
?};
{? _can_continue>0
|| _result:=1
?};
_result


\mod_tech_guid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Modyfikacja przewodnika technicznego
::   WE: _a - ZL.ref()
::       _b - dodawana (odejmowana) ilosc
::  OLD: \mod_tech_guid/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
:: TODO: Modyfikacja ilości na zleceniu otwartym
_zl:=_a;
_ildod:=_b;

ZGH.cntx_psh();

ZGH.index('ZLNR');
ZGH.prefix(_zl);
{? ZGH.first()
||
   ZGH.ILNPRZ+=_ildod;
   ZGH.put();
:: Modyfikacja pozycji przewodnika, ew. korekty limitow
   exec('mod_poz','zl_guide',ZGH.ILNPRZ/(ZGH.ILNPRZ-_ildod),ZGH.ILNPRZ)
?};

ZGH.cntx_pop();
~~


\zgh_chng
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2009]
:: OPIS: Zmienia ilosc na przewodniku oraz norme czasowa i czas maszynowy
::       na pozycjach
::   WE: _a - ilosc do jeszcze do zmniejszenia
::   WY: ilosc jeszcze do zmniejszenia
::  OLD: \zgh_chng/zl_guid.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
M.cntx_psh();
_il:=_a;
_rej:=exec('max_akord','zl_guide',ZGH.ref());
_ilnprz:=ZGH.ILNPRZ;
{? ZGH.ILNPRZ-_rej>=_il
|| ZGH.ILNPRZ-=_il;

:: Zaokrąglanie
   {? ZGH.ZLEC().KTM().DOKL=0
   || ZGH.ILNPRZ:=ceil(ZGH.ILNPRZ)
   || ZGH.ILNPRZ:=ZGH.ILNPRZ$ZGH.ZLEC().KTM().DOKL
   ?};

   ZGH.put();
   ZGP.cntx_psh();
   ZGP.index('PNRPP');
   ZGP.prefix(ZGH.ref());
   {? ZGP.first() & ZGH.ILNPRZ<>0
   || _tmp_pr:=ZGH.ILNPRZ / _ilnprz;
      {!
      |?
         {? ZGP.TPZ='T'
         ||
::          Pozycjom typu TPZ poprawiamy tylko ilość, nie skalujemy czasu
            ZGP.ILOSC:=ZGH.ILNPRZ;
            ZGP.put()
         ||
::          Pomijam korygowanie ilości i norm dla pozycji naprawczych
            {? ZGP.NAPRAW='N'
            ||
::             Dla operacji ze stałą normą czasową nie przeliczam czasów
               {? ZGP.FIX_NORM<>'T'
               || ZGP.NTIME*=_tmp_pr;
                  ZGP.MTIME*=_tmp_pr;
                  ZGP.PLNX:=(ZGP.PLNX*_tmp_pr)$2;
                  ZGP.CENA:=(ZGP.CENA*_tmp_pr)$2
               ?};
               ZGP.ILOSC:=ZGH.ILNPRZ;
               {? ZGP.put()
               || exec('lim_kor_zgp','zl_limit',ZGP.ref(),_tmp_pr,ZGP.ILOSC,,1)
               ?}
            ?}
         ?};
         ZGP.next()
      !}
   ?};
   ZGP.cntx_pop();
   ~~
|| {? ZGH.ILNPRZ<>_rej
   ||
      ZGH.ILNPRZ:=_rej;

::    Zaokrąglanie
      {? ZGH.ZLEC().KTM().DOKL=0
      || ZGH.ILNPRZ:=ceil(ZGH.ILNPRZ)
      || ZGH.ILNPRZ:=ZGH.ILNPRZ$ZGH.ZLEC().KTM().DOKL
      ?};

      ZGH.put();
      ZGP.cntx_psh();
      ZGP.index('PNRPP');
      ZGP.prefix(ZGH.ref());
      {? ZGP.first() & ZGH.ILNPRZ<>0
      || _tmp_pr:=ZGH.ILNPRZ / _ilnprz;
         {!
         |?
            {? ZGP.TPZ='T'
            ||
::             Pozycjom typu TPZ poprawiamy tylko ilość, nie skalujemy czasu
               ZGP.ILOSC:=ZGH.ILNPRZ;
               ZGP.put()
            ||
::             Pomijam korygowanie ilości i norm dla pozycji naprawczych
               {? ZGP.NAPRAW='N'
               ||
                  ZGP.NTIME*=_tmp_pr;
                  ZGP.MTIME*=_tmp_pr;
                  ZGP.PLNX:=(ZGP.PLNX*_tmp_pr)$2;
                  ZGP.CENA:=(ZGP.CENA*_tmp_pr)$2;
                  ZGP.ILOSC:=ZGH.ILNPRZ;
                  {? ZGP.put()
                  || exec('lim_kor_zgp','zl_limit',ZGP.ref(),_tmp_pr,ZGP.ILOSC,,1)
                  ?}
               ?}
            ?};
            ZGP.next()
         !}
      ?};
      ZGP.cntx_pop()
   ?};
   ~~
?};
_il:=(_ilnprz-ZGH.ILNPRZ)-_il;
{? _il<0
|| _il*=-1
?};
ZL.cntx_pop();
M.cntx_pop();
_il


\get_ilosc2decrease
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Sprawdza o ile przewodnik można zmniejszyć z podanej proporcji biorąc pod uwagę:
::       -robociznę
::       -partie
::       -pobrania surowców
::   WE: [_a] - ZGH.ref
::       _b - REAL - żądana proporcja o jaką zmniejszyć (1 - zmniejszam o wszystko, 0 - zmniejzam o nic)
::   WY: REAL - proporcja o jaką można zmniejszyć dany przewodnik
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGH.ref())
|| _ref:=_a
?};
_coef_in:=_b;

_result:=0;
_can_continue:=1;

ZGH.cntx_psh();
{? _ref<>null()
|| ZGH.prefix();
   {? ZGH.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _il:=ZGH.ILNPRZ*_coef_in;

   _il_part:=0;
   _il_rob:=0;
   _il_sur:=0;
   _braki:=0;
   _tpz:=0;
   _top_rodzaj:=exec('top_rodzaj','zl_link',ZGH.ZLEC);
   _top_level:=exec('top_level','zl_link',ZGH.ZLEC);

:: Sprawdzamy rejestracje wykonań
   _rej:=exec('max_akord','zl_guide',ZGH.ref());
   {? _rej>ZGH.ILNPRZ
   || _rej:=ZGH.ILNPRZ
   ?};
   _koop:=exec('max_akord','zl_guide',ZGH.ref(),1);
   _rej:=exec('max','#math',_rej,_koop);

   {? ZGH.ILNPRZ-_rej>=_il
   ||
::    Jeżeli chodzi o robociznę to można zmniejszyć całą żądaną ilość
      _il_rob:=_il
   || _il_rob:=ZGH.ILNPRZ-_rej
   ?};

   {? _rej=0
   ||
::    Jeśli nic nie zarejtrowano ani nie wysłano do kooperacji to sprawdzam braki
      _braki:=exec('max_akord','zl_guide',ZGH.ref(),2);
      {? _braki>0
      ||
::       Nic nie zarejestrowano dobrych, są same braki wiec nie wiem do ilu mógłbym zmniejszyć
::       przewodnik, więc traktuję jako cały nie zmniejszalny
         _il_rob:=0
      ?}
   ?};
   {? _rej=0 & _il_rob>0
   ||
::    Jeśli żadna ilość nie została zarejestrowana to sprawdzam czy są jakieś rejestracje do TPZ
::    jeżeli są, to traktuję cały przewodnik jako nie zmniejszalny, bo nie wiadomo do ilu trzeba by zmniejszyć
      _tpz:=exec('spr_tpz','zl_guide',ZGH.ref());
      {? _tpz>0
      || _il_rob:=0
      ?}
   ?};

   _il_part:=_il;
   {? exec('zgh_ile_part','zl_partie',ZGH.ref())>0
   ||
::    Sprawdzamy partie
      _part_free:=exec('zgh_ile_part_free','zl_partie',ZGH.ref(),_il);
      {? _part_free>=_il
      ||
::       Jeżeli chodzi o partie to można zmniejszyć całą żądaną ilość
         _il_part:=_il
      || _il_part:=_part_free
      ?}
   ?};
:: Ze wszystkich wartości, ta minimalna jest wynikiem
   _il_res:=exec('min','#math',_il_part,_il_rob);
   {? ZGH.ILNPRZ>0
   || _result:=_il_res/ZGH.ILNPRZ
   ?};

   {? _can_continue>0 & _result>0 & _top_rodzaj='Z'
   ||
      _uid_parent:=ZGH.UID_SRC;
      ZGH.cntx_psh();
      ZGH.index('UID_SRC');
      {? ZGH.UID<>''
      ||
         ZGH.prefix(ZGH.UID);
         {? ZGH.first()
         || _can_continue:=1
         || _can_continue:=0
         ?}
      || _can_continue:=0
      ?};
      {? _can_continue>0
      || {!
         |?
::          !!! REKURENCJA !!!
            _il_rec:=exec('get_ilosc2decrease','zl_guide',,_coef_in);
            _result:=exec('min','#math',_il_rec,_result);
            ZGH.next()
         !}
      |? exec('chk_zgh_tied','zl_guide',ZGH.ZLEC)>0
      ||
::       Nie ma potomnych, ale może to wynikać z faktu że jestem na podzleceniu na Ntym poziomie
::       (tylko przewodniki na zleceniu montażowym mają potomków)
         {? _uid_parent<>''
         ||
            ZL.cntx_psh();
            ZL.index('TREEMTU');
            ZL.prefix(ZGH.ZLEC);
            {? ZL.first()
            || {!
               |? ZGH.cntx_psh();
                  ZGH.index('UID_SRC');
                  ZGH.prefix(_uid_parent,ZL.ref());
                  {? ZGH.first()
                  || {!
                     |?
::                      !!! REKURENCJA !!!
                        _il_rec:=exec('get_ilosc2decrease','zl_guide',,_coef_in);
                        _result:=exec('min','#math',_il_rec,_result);
                        ZGH.next()
                     !}
                  ?};
                  ZGH.cntx_pop();
                  ZL.next()
               !}
            ?};
            ZL.cntx_pop()
         ?}
      ?};
      ZGH.cntx_pop()
   ?}
?};
ZGH.cntx_pop();
_result


\gen_przh_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JM [7.22]
:: OPIS: Generuje obiekt przewodnika
::  OLD: \gen_przh_obj/tmp_obj.fml
::  OLD: \gen_przh_obj/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_pos:=0;
_size:=0;
{? var_pres('PRZEW',@)>0 || obj_del(PRZEW) ?}; PRZEW:=obj_new(@.CLASS.CUBE);
{? var_pres('PRZE_',@)>0 || obj_del(PRZE_) ?}; PRZE_:=obj_new(@.CLASS.CUBE);
{? VAR.A_ZLEC().TYP().TECH='T'
|| _ktl:=exec('FindAndGet','#table',TKTL,VAR.A_ZLEC().RTKTL,,"ref()",null())
|| _ktl:=exec('FindAndGet','#table',TKTL,VAR.A_ZLEC().RKTL,,"ref()",null())
?};

_msk:=(8+ref_name(_ktl))+3;
exec('tktl_cntx_psh','tech_common');
exec('tktl_use','tech_common',_msk);

exec('start_tpar','tech_param',VAR.A_ZLEC().KTM,_ktl);

TOPER.index('NNN');
TOPER.prefix(_ktl,0);
PRZE_.LEN:=0;

{? TOPER.first()
|| {!
   |? {? TOPER.ACT='T' & tpar.calc(TOPER.EXIST)
      || PRZE_.LEN+=1
      ?};
      TOPER.next()
   !}
?};

{? PRZE_.LEN>0 & TOPER.first()
|| exec('make_cube','zl_guide','PRZE_.TAB',PRZE_.LEN,exec('zgp_cube_size','zl_guide'));
   {!
   |? {? TOPER.ACT='T' & tpar.calc(TOPER.EXIST)
      || _pos+=1;
         _size+=exec('gen_obj_pos','zl_guide','PRZE_.TAB['+$_pos+']')
      ?};
      TOPER.next()
   !};
   PRZEW.LEN:=_size;
   POZYCJA_PRZEW:=0;
   exec('make_cube','zl_guide','PRZEW.TAB',PRZEW.LEN,exec('zgp_cube_size','zl_guide'));
   exec('set_przh_poz','zl_guide','PRZE_');
   &POZYCJA_PRZEW
?};

exec('tktl_cntx_pop','tech_common');
~~


\del_przh_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ?
:: OPIS: kasowanie obiektow do generowania przewodnikow
::  OLD: \del_przh_obj/tmp_obj.fml
::  OLD: \del_przh_obj/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
obj_del(PRZEW);
obj_del(PRZE_);
~~


\gen_przh_obj_pl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Generuje obiekt przewodnika na podstawie planu
::   WE: [_a] - PL_PART.ref() lub bieżący rekord
::  OLD: \gen_przh_obj_pl/tmp_obj.fml
::  OLD: \gen_przh_obj_pl/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PL_PART.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

_pos:=0;
_size:=0;

PL_PART.cntx_psh();
{? _ref<>null()
|| PL_PART.clear();
   {? PL_PART.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PL_OPER.cntx_psh();
   PL_OPER.index('NUM');
   {? var_pres('PRZEW',@)>0 || obj_del(PRZEW) ?}; PRZEW:=obj_new(@.CLASS.CUBE);
   {? var_pres('PRZE_',@)>0 || obj_del(PRZE_) ?}; PRZE_:=obj_new(@.CLASS.CUBE);
   _ktl:=PL_PART.TKTL;

   _msk:=(8+ref_name(_ktl))+3;
   exec('tktl_cntx_psh','tech_common');
   exec('tktl_use','tech_common',_msk);

   exec('start_tpar','tech_param',PL_PART.M,_ktl);

   PRZE_.LEN:=0;
   PL_OPER.prefix(PL_PART.ref());
   {? PL_OPER.first()
   || {!
      |? {? PL_OPER.TP>0 | PL_OPER.TZ>0
         ||
::          Jeśli operacja ma TPZ to robię miejsce na dwie pozycje przewodnika: właściwą i TPZ
            PRZE_.LEN+=2
         ||
::          Operacja nie ma TPZ
            PRZE_.LEN+=1
         ?};
         PL_OPER.next()
      !}
   ?};

   {? PRZE_.LEN>0 & PL_OPER.first()
   || exec('make_cube','zl_guide','PRZE_.TAB',PRZE_.LEN,exec('zgp_cube_size','zl_guide'));
      {!
      |? _pos+=1;
         {? PL_OPER.TP>0 | PL_OPER.TZ>0
         ||
::          Operacja z czasem TPZ
::          1. Dodaje wlasciwa operacje
            exec('gen_obj_pos_pl','zl_guide','PRZE_.TAB['+$_pos+']');
::          2. Dodaje TPZta
            _pos+=1;
            exec('gen_obj_pos_pl','zl_guide','PRZE_.TAB['+$_pos+']',PL_OPER.UID);
            _size+=2

         ||
::          Operacja bez czasu TPZ
            exec('gen_obj_pos_pl','zl_guide','PRZE_.TAB['+$_pos+']',0);
            _size+=1
         ?};
         PL_OPER.next()
      !};
      PRZEW.LEN:=_size;
      POZYCJA_PRZEW:=0;
      exec('make_cube','zl_guide','PRZEW.TAB',PRZEW.LEN,exec('zgp_cube_size','zl_guide'));
      exec('set_przh_poz','zl_guide','PRZE_');
      &POZYCJA_PRZEW
   ?};
   exec('tktl_cntx_pop','tech_common');
   PL_OPER.cntx_pop();
   ~~
?};
PL_PART.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\add_zgh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JM [7.22]
:: OPIS: Funkcja generujaca przewodniki
::   WE: _a - Ilosc na przewodniku
::       [_b] - ZL.ref() (podrzedne)
::       [_c] - ZL.ref() (nadrzedne)
::       [_d] - Nr przewodnika
::       [_e] - INTEGER - [0] - przewodniki generowane do nadrzednych
::                         1  - przewodniki generowane do podrzednych
::       [_f] - INTEGER -  0  - nie generowac automatycznie partii do przewodnika
::                        [1] - generowac automatycznie partie do przewodnika
::       [_g] - PL_PART.ref - przewodnik planistyczny, jeśli generowane na podstawie planu
::       [_h] - STRING - klucz grupujący którym stemplować przewodniki
::       [_i] - STRING - identyfikator którym spinać przewodniki dla widoku od strony zlecenia złożonego nadrzędnego
::       [_j] - STRING - unikalny identyfikator przewodnika zlecenia montażowego
::                       na podstawie którego została określona ilość
::       [_k] - INTEGER - [0]/1 - czy generować od razu zakończone przewodniki
::    WY: Symbol przewodnika
::  OLD: \gen_przewodnik/zl_guid.fml
::  OLD: \gen_przewodnik/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a=0 || return(~~) ?};
_result:='';

_ilosc:=_a;
_zl_pod:=null();

_zl_nad:=null();
_gen_part:=1;
_zgh_num:=1;
_gen_pod:=0;

{? var_pres('_b')=type_of(ZL.ref())
|| _zl_pod:=_b
?};
{? var_pres('_c')=type_of(ZL.ref())
|| _zl_nad:=_c
?};
{? var_pres('_d')=type_of(0)
|| _zgh_num:=_d
?};
{? var_pres('_e')=type_of(0)
|| _gen_pod:=_e
?};
{? var_pres('_f')=type_of(0)
|| _gen_part:=_f
?};
_plpart:=null();
{? var_pres('_g')=type_of(PL_PART.ref())
|| _plpart:=_g
?};
_grp_key:='';
{? var_pres('_h')=type_of('')
|| _grp_key:=_h
?};
_uid_view:='';
{? var_pres('_i')=type_of('')
|| _uid_view:=_i
?};
_uid_src:='';
{? var_pres('_j')=type_of('')
|| _uid_src:=_j
?};
_zakoncz:=0;
{? var_pres('_k')=type_of(0)
|| _zakoncz:=_k
?};

ZGH.cntx_psh();
ZGH.clear();
ZGH.blank();
_nrprz:=exec('gen_nrprz','zl_guide');
{? _nrprz=''
|| define('WYN','','',,20,20);
   {? def_edit(,'Podaj numer przewodnika'@)
   || _nrprz:=DEFINE.WYN
   || FUN.error('Nie został wprowadzony numer.'@);
      _nrprz:='Błędny numer przewodnika'@
   ?};
   undefine('WYN')
?};
:: Gdy generujemy przewodniki dla zlecenia podrzednego
ZGH.NRPRZ:=_nrprz;
ZGH.ZLEC:=VAR.A_ZLEC;
ZGH.STAN:='N';
ZGH.ILNPRZ:=_ilosc;
ZGH.GRP_KEY:=_grp_key;
ZGH.UID:=exec('uid','#blank');
ZGH.UID_VIEW:=_uid_view;
ZGH.UID_SRC:=_uid_src;
ZGH.GKTL:=exec('gktl_from_zl','zl_common',ZGH.ZLEC);
ZGH.KTM:=VAR.A_ZLEC().KTM;
ZGH.KH:=VAR.A_ZLEC().KH;
{? _zakoncz>0
|| ZGH.STAT_REJ:='T'
?};
{? ZGH.add()
|| _result:=ZGH.NRPRZ;
   VAR.A_NRPRZ:=ZGH.ref();

:: Stempluje przewodnik planistyczny utworzonym przewodnikiem
   {? _plpart<>null()
   || PL_PART.cntx_psh(); PL_PART.clear();
      {? PL_PART.seek(_plpart)
      || PL_PART.ZGH:=ZGH.ref();
         PL_PART.put()
      ?};
      PL_PART.cntx_pop()
   ?};

:: Jezeli wyrob zlecenia jest partiowany, to razem z przewodnikiem tworze partie
   {? _gen_part>0 & exec('zlec_party','zl_common',ZGH.ZLEC)>0
   || exec('add4zgh','zl_partie',ZGH.ref(),,0)
   ?};

   _zghpod:=ZGH.ref();
   _zghnad:=ZGH.ref();
   exec('gen_poz','zl_guide',_a,_zghnad,_zghpod);
   {? VAR.A_ZLEC().TYP().TECH='T'
   || VAR.A_KTL:=VAR.A_ZLEC().TKTL
   || VAR.A_KTL:=VAR.A_ZLEC().KTL
   ?};
:: Generowanie następników
   {? _plpart<>null()
   || exec('gen_nast_pl','zl_guide',_zghpod,_plpart);
::    Nawijam pozycjom przewodnika identyfikatory do podziału, jeśli plan był wcześniej dzielony
      exec('zgp_split_fill','po_split',_plpart)
   || exec('gen_nast','zl_guide',_zghpod)
   ?};
   exec('recover_sta_zgh','zl_guide',_zghpod)
|| FUN.info('Nie udało się wygenerowanie przewodników.'@);
   0
?};
ZGH.cntx_pop();
_result


\gen_nrprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ?
:: OPIS: Generowanie numeru przewodnika
::   WY: STRING - numer przewodnika
::  OLD: \gen_nrprz/zl_guid.fml
::  OLD: \gen_nrprz/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
ZGH.cntx_psh();
ZGH.clear();
ZGH.index('NRPRZ');
_sym:=VAR.A_ZLEC().SYM+VAR.A_ZLEC().TYP().SEP_PRZ;
ZGH.prefix(_sym);
_ile_prz:=VAR.A_ZLEC().TYP().ILE_PRZ;
{? ZGH.last & VAR.A_ZLEC().NRNZL<>0
|| _sym+=form((#(ZGH.NRPRZ+_ile_prz))+1,-_ile_prz,0,'9')
|? VAR.A_ZLEC().NRNZL=0
|| _dalej:=1;
   {? ZGH.last()
   || {!
      |? ZGH.NRPRZ-_ile_prz-1<>VAR.A_ZLEC().SYM & _dalej
      |! _dalej:=ZGH.prev()
      !};
      {? _dalej
      || _sym+=form((#(ZGH.NRPRZ+_ile_prz))+1,-_ile_prz,0,'9')
      || _sym+=form(1,-_ile_prz,0,'9')
      ?}
   || _sym+=form(1,-_ile_prz,0,'9')
   ?}
|| _sym+=form(1,-_ile_prz,0,'9')
?};
ZGH.cntx_pop();
_sym


\gen_obj_pos
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JM [7.22]
:: OPIS: generuje pozycje przewodnika
::   WE: _a - prefiks pozycji
::  OLD: \gen_obj_pos/tmp_obj.fml
::  OLD: \gen_obj_pos/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
TOPER.cntx_psh();
_zktl:=TOPER.NRK;
_wynik:=0;
{? TOPER.ACT='T'
||
   {? TOPER.PZ='P'
   || ($(
      '_coef:={? TOPER.FCOEF<>'''' & TOPER.NRK().TYP().PAR=''T'' || tpar.calc(TOPER.FCOEF) || TOPER.COEF ?};'+
      '_ntime:={? TOPER.FNTIME<>'''' || tpar.calc(TOPER.FNTIME) || TOPER.NTIME ?};'+
      '_mtime:={? TOPER.FMTIME<>'''' || tpar.calc(TOPER.FMTIME) || TOPER.MTIME ?};'+
      '_kj_bad:=TOPER.KJ_BAD; _badseh:=TOPER.BADSEH; _bad_op:=TOPER.BAD_OP;'+
      ' M.cntx_psh();_mgr:=TOPER.NRK().KTM().MGR;M.cntx_pop();'+
      '{? TOPER.BADSEH=null() & TOPER.PL_GRP<>''T''
       || _badseh:=exec(''get_badseh4oper'',''statexam'',TOPER.OPER,_mgr,''P'',''N'');
          {? _badseh<>null() || _kj_bad:=''B'' ?}
       ?};'+
       '{? TOPER.BAD_OP=null() & TOPER.PL_GRP<>''T''
        || _bad_op:=exec(''get_badseh4oper'',''statexam'',TOPER.OPER,_mgr,''P'',''T'')
        ?};'+
      _a+'[1]:={? TOPER.WEW=''T'' || TOPER.OPER().NA || TOPER.TTOUT().NA ?};'+
      _a+'[2]:=TOPER.ref();'+
::    PLNX
      _a+'[3]:=({? TOPER.TPZ=''T'' || {? _ntime=0 || 0 || TOPER.PLNX/_ntime ?} || TOPER.OPER().STAWKA ?}*_coef*_ntime)$4;'+
::    PLNH
      _a+'[4]:=({? TOPER.TPZ=''T'' || {? _ntime=0 || 0 || TOPER.PLNX/_ntime ?} || TOPER.OPER().STAWKA ?}*_coef)$4;'+
::    NTIME
      _a+'[5]:=_ntime;'+
      _a+'[6]:=TOPER.TPZ;'+
      _a+'[7]:=TOPER.BRYG;'+
      _a+'[8]:='''';'+
      _a+'[9]:=TOPER.OPER().PLATNE;'+
      _a+'[10]:=TOPER.WEW;'+
      _a+'[11]:=TOPER.CENA;'+
      _a+'[12]:=TOPER.PFAZ;'+
      _a+'[13]:=_mtime;'+
      _a+'[14]:={? TOPER.GRPOJ=''S'' || TOPER.PLACE || TOPER.TWRKPLG().ELEMENT ?};'+
      _a+'[15]:=TOPER.DOK;'+
      _a+'[16]:={? TOPER.FNKO<>'''' || tpar.calc(TOPER.FNKO) || TOPER.NKO ?};'+
      _a+'[17]:={? TOPER.FTTM<>'''' || tpar.calc(TOPER.FTTM) || TOPER.TTM ?};'+
      _a+'[18]:=TOPER.TPZREF;'+
      _a+'[19]:=TOPER.ZAW;'+
      _a+'[20]:=TOPER.CIAGLA;'+
      _a+'[21]:=TOPER.memo_txt(,1,\'OPISMEMO\');'+
      _a+'[22]:=TOPER.DAYS_K;'+
      _a+'[23]:=TOPER.PX_KONT;'+
      _a+'[24]:=TOPER.KONTRAH;'+
      _a+'[25]:=TOPER.PL_GRP;'+
      _a+'[26]:=TOPER.GRUPA;'+
      _a+'[27]:=TOPER.SRW;'+
      _a+'[28]:=\'TOPER\';'+
      _a+'[29]:=0;'+
      _a+'[30]:=null();'+
      _a+'[31]:=TOPER.KONTROLA;'+
      _a+'[32]:=_kj_bad;'+
      _a+'[33]:=_badseh;'+
      _a+'[34]:=TOPER.FIX_NORM;'+
      _a+'[35]:=_bad_op;'+
      _a+'[36]:=TOPER.WHERE;'+
      _a+'[37]:={? TOPER.WEW=''T'' || TOPER.OPER().NA || TOPER.TTOUT().NA ?};'+
      _a+'[38]:=TOPER.WYK_FAST;'+
      _a+'[39]:=TOPER.NO_START'
      ))();
      _wynik:=1
   || TOPER.clear();
      TOPER.index('NNN');
      TOPER.prefix(_zktl,TOPER.UNROP);
      {? TOPER.first()
      || _pos:=0;
         ($(_a+'[1]:=obj_new(@.CLASS.CUBE)'))();
         _size:=0;
         {!
         |? {? TOPER.ACT='T' & tpar.calc(TOPER.EXIST)
            || _size+=1
            ?};
            TOPER.next()
         !};
         TOPER.first();
         ($(_a+'[1].LEN:=_a'))(_size);
         exec('make_cube','zl_guide',_a+'[1].TAB',_size,exec('zgp_cube_size','zl_guide'));
         {!
         |? {? TOPER.ACT='T' & tpar.calc(TOPER.EXIST)
            || _pos+=1;
               _wynik+=exec('gen_obj_pos','zl_guide',_a+'[1].TAB['+$_pos+']')
            ?};
            TOPER.next()
         !}
      ?}
   ?}
?};
TOPER.cntx_pop();
_wynik


\gen_obj_pos_pl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Generuje pozycje przewodnika na podstawie planu
::   WE: _a - prefiks pozycji
::       [_b] - PL_OPER.UID - jeśli dotyczy TPZ to uid PL_OPERa do którego jest TPZ
::  OLD: \gen_obj_pos_pl/tmp_obj.fml
::  OLD: \gen_obj_pos_pl/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_prefix:=_a;

_tpz_src:='';
{? var_pres('_b')=type_of('')
|| _tpz_src:=_b
?};

PL_OPER.cntx_psh();
PL_OZ.cntx_psh();
PL_OZ.index('PL_OPER');
PL_OZ.prefix(PL_OPER.ref());
_wynik:=0;
_fml:='_coef:={? PL_OPER.TOPER().FCOEF<>'''' & PL_OPER.TOPER().NRK().TYP().PAR=''T'' || tpar.calc(PL_OPER.TOPER().FCOEF) || {? PL_OPER.TOPER<>null()|| TOPER.COEF || 1 ?} ?};\n';
{? _tpz_src<>''
|| _fml+='_ntime:=PL_OPER.TP/60+PL_OPER.TZ/60;\n';
   _fml+='_mtime:=0;\n'
||
   _fml+='_ntime:={? PL_OPER.TOPER().FNTIME<>'''' || tpar.calc(PL_OPER.TOPER().FNTIME) || {? PL_OPER.TOPER<>null() || TOPER.NTIME || PL_OPER.DURATION/60 ?} ?};\n';
   _fml+='_mtime:=PL_OPER.DURATION/60-PL_OPER.TP/60-PL_OPER.TZ/60;\n'
?};
_fml+=_prefix+'[1]:=PL_OPER.OPIS+{? PL_OPER.TOPER<>null() || PL_OPER.TOPER(); {? TOPER.WEW=''T'' || \' / \'+TOPER.OPER().NA || \' / \'+TOPER.TTOUT().NA ?} ?} ;\n';
_fml+=_prefix+'[2]:=PL_OPER.TOPER;\n';
_fml+=_prefix+'[3]:=(PL_OPER.TOPER().OPER().STAWKA*_coef*_ntime)$4;\n';
_fml+=_prefix+'[4]:=(PL_OPER.TOPER().OPER().STAWKA*_coef)$4;\n';
_fml+=_prefix+'[5]:=_ntime;\n';
{? _tpz_src<>''
|| _fml+=_prefix+'[6]:=\'T\';\n'
|| _fml+=_prefix+'[6]:=\'N\';\n'
?};
_fml+=_prefix+'[7]:=PL_OPER.TOPER().BRYG;\n';
_fml+=_prefix+'[8]:='''';\n';
_fml+=_prefix+'[9]:=PL_OPER.TOPER().OPER().PLATNE;\n';
_fml+=_prefix+'[10]:=\'T\';\n';
_fml+=_prefix+'[11]:=PL_OPER.TOPER().CENA;\n';
_fml+=_prefix+'[12]:=PL_OPER.TOPER().PFAZ;\n';
_fml+=_prefix+'[13]:=_mtime;\n';

_place:=null();
_gniazdo:=null;
{? PL_OZ.first()
|| {!
   |? {? PL_OZ.PL_RES().FROM_STA<>null()
      || _place:=PL_OZ.PL_RES().FROM_STA
      ?};
      PL_OZ.next() & _place=null()
   !}
?};
{? PL_OZ.first()
|| {!
   |? {? PL_OZ.PL_RES().FROM_GNI<>null()
      || _gniazdo:=PL_OZ.PL_RES().FROM_GNI
      ?};
      PL_OZ.next() & _gniazdo=null()
   !}
?};
{? _place<>null()
|| _fml+=_prefix+'[14]:=exec(\'FindAndGet\',\'#table\',TWRKPLC,\''+$_place+'\',,,null());\n'
|| _fml+=_prefix+'[14]:={? PL_OPER.TOPER().GRPOJ=''S'' || TOPER.PLACE || PL_OPER.TOPER().TWRKPLG().ELEMENT ?};\n'
?};
_fml+=_prefix+'[15]:=PL_OPER.TOPER().DOK;\n';
_fml+=_prefix+'[16]:={? PL_OPER.TOPER().FNKO<>'''' || tpar.calc(PL_OPER.TOPER().FNKO) || PL_OPER.TOPER().NKO ?};\n';
_fml+=_prefix+'[17]:={? PL_OPER.TOPER().FTTM<>'''' || tpar.calc(PL_OPER.TOPER().FTTM) || PL_OPER.TOPER().TTM ?};\n';
{? _tpz_src<>''
|| _tpz_src:=gsub(_tpz_src,'\'','\'\'');
   _tpz_src:=gsub(_tpz_src,'\\','\\\\');
   _fml+=_prefix+'[18]:=\''+_tpz_src+'\';\n'
|| _fml+=_prefix+'[18]:=null();\n'
?};
_fml+=_prefix+'[19]:=PL_OPER.TOPER().ZAW;\n';
_fml+=_prefix+'[20]:=PL_OPER.TOPER().CIAGLA;\n';
_fml+=_prefix+'[21]:={? PL_OPER.TOPER<>null() || PL_OPER.TOPER();TOPER.memo_txt(,1,\'OPISMEMO\') || \'\' ?};\n';
_fml+=_prefix+'[22]:=PL_OPER.TOPER().DAYS_K;\n';
_fml+=_prefix+'[23]:=PL_OPER.TOPER().PX_KONT;\n';
_fml+=_prefix+'[24]:=PL_OPER.TOPER().KONTRAH;\n';
_fml+=_prefix+'[25]:=PL_OPER.TOPER().PL_GRP;\n';
_fml+=_prefix+'[26]:=PL_OPER.TOPER().GRUPA;\n';
_fml+=_prefix+'[27]:=PL_OPER.TOPER().SRW;\n';
_fml+=_prefix+'[28]:=\'PL_OPER\';\n';
_fml+=_prefix+'[29]:=PL_OPER.ILOSC;\n';
{? _tpz_src<>''
|| _fml+=_prefix+'[30]:=null();\n'
|| _fml+=_prefix+'[30]:=PL_OPER.ref();\n'
?};
_fml+=_prefix+'[31]:=PL_OPER.TOPER().KONTROLA;\n';
_fml+=_prefix+'[32]:=PL_OPER.TOPER().KJ_BAD;\n';
_fml+=_prefix+'[33]:=PL_OPER.TOPER().BADSEH;\n';
_fml+=_prefix+'[34]:=PL_OPER.TOPER().FIX_NORM;\n';
_fml+=_prefix+'[35]:=PL_OPER.TOPER().BAD_OP;\n';
_fml+=_prefix+'[36]:=PL_OPER.TOPER().WHERE\n';
_fml+=_prefix+'[37]:={? PL_OPER.TOPER<>null() || PL_OPER.TOPER(); {? TOPER.WEW=''T'' || \' / \'+TOPER.OPER().NA || \' / \'+TOPER.TTOUT().NA ?} ?} ;\n';
:: Wykonuję utworzoną formułę
($_fml)();
_wynik:=1;
PL_OZ.cntx_pop();
PL_OPER.cntx_pop();
_wynik


\make_cube
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JM
:: OPIS: Tworzy strukture n wymiarowa
::       wywolanie _a='np. CU.TAB' czyli do czego ma przypiac
::       _[2].._[n+1] rozmiary kolejnych wymiarow
::       4Exp: exec('make_cube','plik','COS',10,20,30)
::             stworzy tablice 3-wymiarowa COS o wymiarach 10/20/30
::             czyli COS[10][20][30]:='98' zadziala
::  OLD: \make_cube/tmp_obj.fml
::  OLD: \make_cube/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
{? _>1
|| _fun:=_a+':=obj_new('+$_b+')'; ($_fun)();
   {! _nr:=1.._b
   |! _fun:='exec(''make_cube'',''zl_guide'',';
      _fun+=''''+_a+'['+$_nr+']''';
      {! _it:=1..(_-2) |! _fun+=','+$_[_it+2] !};
      _fun+=')';
      ($_fun)()
   !}
?}


\set_przh_poz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JM [7.22]
:: OPIS: splaszczenie PRZE_ do PRZEW
::   WE: _a - STRING nazwa obiektu 'przestrzennego' PRZE_ (?)
::  OLD: \set_przh_poz/tmp_obj.fml
::  OLD: \set_przh_poz/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_size:=($(_a+'.LEN'))();
{! _i:=1.._size
|! {? ($('type_of('+_a+'.TAB['+$_i+'][1])'))()=2
   || POZYCJA_PRZEW+=1;
      {! _j:=1..exec('zgp_cube_size','zl_guide')
      |! PRZEW.TAB[POZYCJA_PRZEW][_j]:=($(_a+'.TAB['+$_i+']['+$_j+']'))()
      !}
   || exec('set_przh_poz','zl_guide',_a+'.TAB['+$_i+'][1]')
   ?}
!};
0


\gen_poz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JM [7.22]
:: OPIS: [GZ: Formuła wydzielona z gen_przewodnik]. Generuje pozycje przewodnika.
::   WE: _a - Ilość na przewodniku
::       _b - nr przewodnika
::       _c - nr przewodnika zlecenia podrzędnego
::  OLD: \gen_poz/zl_guid.fml
::  OLD: \gen_poz/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_il_zgh:=_a;
_xjm:={? VAR.A_ZLEC().TYP().TECH='T'
      || exec('FindAndGet','#table',TKTL,VAR.A_ZLEC().RTKTL,,"XJM",1)
      || exec('FindAndGet','#table',TKTL,VAR.A_ZLEC().RKTL,,"XJM",1)
      ?};
_wsp:=_a/_xjm;
VAR.A_NRPRZ:=_b;
VAR.A_NRZLP:=_c;
_nr:=0;

{! _i:=1..PRZEW.LEN
|! _where:=PRZEW.TAB[_i][36];
:: Sprawdzenie warunków dodawania operacji tylko do pierwszego/ostatniego przewodnika
   {? _where='W' | (_where='P' & VAR.WAR_GEN<>'N' & exec('zgh_is_first','zl_guide',VAR.A_NRPRZ))
      | (_where='O' & VAR.WAR_GEN<>'N' & exec('zgh_is_last','zl_guide',VAR.A_NRPRZ))
   ||
      ZGP.clear();
      ZGP.blank();
      _nr+=1;

      _src:=PRZEW.TAB[_i][28];

      ZGP.NRPRZ:=_b;
      ZGP.NRP:=_nr;
      ZGP.NRZLP:=_c;
      ZGP.OPIS:=PRZEW.TAB[_i][1];
      ZGP.TOPER:=PRZEW.TAB[_i][2];
      ZGP.WEW:=PRZEW.TAB[_i][10];
      ZGP.FIX_NORM:=PRZEW.TAB[_i][34];
      ZGP.TPZ:=PRZEW.TAB[_i][6];
      ZGP.PLNX:=PRZEW.TAB[_i][3]*{? ZGP.TPZ='T' | ZGP.WEW='N' | ZGP.FIX_NORM='T' || 1 || _wsp ?};
      ZGP.PLNH:=PRZEW.TAB[_i][4];

      {? _src='PL_OPER'
      || ZGP.NTIME:=PRZEW.TAB[_i][5]
      || ZGP.NTIME:=PRZEW.TAB[_i][5]*{? ZGP.TPZ='T' | ZGP.WEW='N' | ZGP.FIX_NORM='T' || 1 || _wsp ?}
      ?};
      ZGP.BRYG:=PRZEW.TAB[_i][7];
      ZGP.PO:=PRZEW.TAB[_i][9];
      ZGP.CENA:=PRZEW.TAB[_i][11]*{? ZGP.TPZ='T' || 1 || _wsp ?};
      ZGP.PFAZ:=PRZEW.TAB[_i][12];

      {? _src='PL_OPER'
      || ZGP.MTIME:=PRZEW.TAB[_i][13]
      || ZGP.MTIME:=PRZEW.TAB[_i][13]*{? ZGP.TPZ='T' | ZGP.WEW='N' | ZGP.FIX_NORM='T' || 1 || _wsp ?}
      ?};
      ZGP.PLACE:=PRZEW.TAB[_i][14];
      {? VAR.A_ZLEC().RP='T'
      || ZGP.DOK:=PRZEW.TAB[_i][15]
      ?};
      ZGP.NKO:=PRZEW.TAB[_i][16];
      ZGP.TTM:=PRZEW.TAB[_i][17];
      ZGP.CIAGLA:=PRZEW.TAB[_i][20];
      ZGP.memo_set(PRZEW.TAB[_i][21],'OPISMEMO');
      ZGP.DAYS_K:=PRZEW.TAB[_i][22];
      ZGP.PX_KONT:=PRZEW.TAB[_i][23];
      ZGP.KONTRAH:=PRZEW.TAB[_i][24];
      ZGP.PL_GRP:=PRZEW.TAB[_i][25];
      ZGP.GRUPA:=PRZEW.TAB[_i][26];
      ZGP.SRW:=PRZEW.TAB[_i][27];
      _ilosc:=PRZEW.TAB[_i][29];
      ZGP.KONTROLA:=PRZEW.TAB[_i][31];
      {? ZGP.TPZ='N'
      || ZGP.KJ_BAD:=PRZEW.TAB[_i][32];
         ZGP.BADSEH:=PRZEW.TAB[_i][33];
         ZGP.BAD_OP:=PRZEW.TAB[_i][35]
      ?};
      ZGP.WHERE:=PRZEW.TAB[_i][36];
      ZGP.OPER_NAZ:=PRZEW.TAB[_i][37];
      ZGP.WYK_FAST:=PRZEW.TAB[_i][38];
      ZGP.NO_START:=PRZEW.TAB[_i][39];
      {? _ilosc>0
      || ZGP.ILOSC:=_ilosc
      || ZGP.ILOSC:=_il_zgh
      ?};
      {? ZGP.TPZ='T'
      || _nr-=1;

::       Wiązanie pozycji przewodnika TPZ z pozycją do której jest TPZ
         _nrp:=0;
         _uid:='';
         {? _src='TOPER'
         ||
            ZGP.cntx_psh();
            ZGP.index('PNRPP');
            ZGP.prefix(ZGP.NRZLP,'N');

            _po:='O';
            {? ZGP.first()
            || {!
               |? {? ZGP.TOPER().UNROP=PRZEW.TAB[_i][18]
                  || _nrp:=ZGP.NRP;
                     _po:=ZGP.PO;
                     _uid:=ZGP.UID
                  ?};
                  ZGP.next()
               !}
            ?};
            ZGP.cntx_pop()
         |? _src='PL_OPER'
         ||
            _uid:=PRZEW.TAB[_i][18];
            {? _uid<>''
            ||
               ZGP.cntx_psh();
               PL_OPER.cntx_psh();
               PL_OPER.index('UID');
               PL_OPER.prefix(_uid);
               {? PL_OPER.first()
               || {? PL_OPER.ZGP<>null()
                  || _nrp:=PL_OPER.ZGP().NRP;
                     _po:=ZGP.PO;
                     _uid:=ZGP.UID
                  ?}
               ?};
               PL_OPER.cntx_pop();
               ZGP.cntx_pop()
            ?}
         ?};
         ZGP.OPIS:={? ZGP.OPIS<>''
                   || 'TPZ - '+ZGP.OPIS
                   || 'TPZ - '+exec('zgpopis','zl_guide','TOPER',ZGP.TOPER().NRK,ZGP.TOPER().NRNOP,ZGP.TOPER().NROP)
                   ?};
::       ZGP.TPZREF:=_nrp;
         ZGP.UID_TPZ:=_uid;
         ZGP.ZAW:=PRZEW.TAB[_i][19];
         ZGP.CIAGLA:='T';
         ZGP.NRP:=_nrp;
         ZGP.PO:=_po
      ?};
      {? ZGP.add()
      || ZGP.memo_put(,'OPISMEMO');
         DocLib.copy('TOPER',ZGP.TOPER,'ZGP',ZGP.ref())
      ?};

::    Ploperowi źródłowemu nawijam ZGPa
      {? _src='PL_OPER'
      || _ploper:=PRZEW.TAB[_i][30];
         {? _ploper<>null()
         || PL_OPER.cntx_psh();
            PL_OPER.clear();
            {? PL_OPER.seek(_ploper)
            || PL_OPER.ZGP:=ZGP.ref();
               PL_OPER.put();
               exec('zgp_dates_upd','po_plan',PL_OPER.ref())
            ?};
            PL_OPER.cntx_pop()
         ?}
      ?}
   ?};
   ~~
!};
~~


\zgpopis
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JA [12.10]
:: OPIS: ustalenie opisu operacji TPZ
::   WE: _a wskazanie na operacje karty lub operacje zlecenia
::       _b wskazanie na technologie zlecenia lub karty
::       _c nr operacji nadrzednej
::       _d nr oeracji
::   WY: nazwa operacji
::  OLD: \zgpopis/zl_guid.fml
::  OLD: \zgpopis/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:='';
{| ($(_a))()
|! cntx_psh();
   index('NNN');
   prefix(_b,_c,'N',_d);
   {? first()
   || _wyn:=OPER().NA
   ?};
   cntx_pop()
|};
_wyn


\ask_ile
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wyświetla okno z pytaniem o ilość na jaką generować przewodniki zlecenia
::   WE: [_a] - ZL.ref() - ref zlecenia lub bieżący rekord
::       [_b] - REAL - ilość domyślna, jeśli nie podana to wymyślana
::       [_c] - INTEGER - czy podczas walidacji sprawdzać czy na podzleceniach nie zostaną
::                        wygenerowane przewodniki ze złą dokładnością
::   WY: obj_new().IL_ZGH - ilość na pojedynczym przewodniku
::       obj_new().IL_ZL - jaką ilość ze zlecenia dzielić
::       obj_new().OK - czy ok (0, 1, -1 - wycofanie z akcji)
::  TAG: <PRYWATNA>
::  OLD: \ask_ile/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};
_ile:=-1;
{? var_pres('_b')=type_of(0)
|| _ile:=_b
?};

_chk_podzlec:=1;
{? var_pres('_c')=type_of(0)
|| _chk_podzlec:=_c
?};

_result:=obj_new('IL_ZGH'
                ,'IL_ZL'
                ,'OK');
_result.IL_ZGH:=0;
_result.IL_ZL:=0;
_result.OK:=0;

_can_continue:=1;

ZL.cntx_psh();
M.cntx_psh();
JM.cntx_psh();
{? _ref<>null()
|| ZL.clear();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? _ile=-1
   || _ile:=exec('ile','zl_guide',ZL.ref(),ZL.IL)
   ?};

:: Podczytanie jednostki miary
   ZL.KTM().J();

   _tktl:=null();
   {? ZL.RTKTL<>''
   || _tktl:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,,null())
   |? ZL.RKTL<>''
   || _tktl:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,,null())
   ?};

   _seria:=exec('seria','zl_guide',_tktl,_ile);
   _seria_koop:=exec('seria_koop','zl_guide',_ile);

   ZLEC.IL_ZL:=_ile;
   ZLEC.IL_ZGH:=_seria;
   ZLEC.SERIA:=_seria;
   ZLEC.IL_GEN:=_ile;

   ZLEC.win_edit('ZGH_GEN');

::   undefine();
::   define('IL_ZL',_ile,'Ilość zlecenia do podziału',,,15,4);
::   define('IL_ZGH',{? _seria<>0 & _par='S'|| _seria || _ile ?},'Ilość na jednym przewodniku',,,15,4);
::   define('H2',~~,'(seria optymalna: '+$exec('FindAndGet','#table',TKTL,_tktl,,"SERIA",0)+')');
::   define('H3',~~,'(do wygenerowania: '+$_ile+')');
::   def_btn('text='+'Zapisz'@,'key:F2');
::   def_btn('text='+'Anuluj'@,'key:Esc');
   _validate:=$("exec('validate_ile','zl_guide',"+form(_ile,,,'9.')+","+form(_seria_koop,,,'9.')+","+form(_chk_podzlec,,,'9.')+")");

   {? ZLEC.edit(_validate)
   || _result.OK:=1;
      _result.IL_ZGH:=ZLEC.IL_ZGH;
      _result.IL_ZL:=ZLEC.IL_ZL
   || _result.OK:=-1
   ?}
?};
M.cntx_pop();
JM.cntx_pop();
ZL.cntx_pop();
_result


\validate_ile
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ?
:: OPIS: Sprawdza, czy wartości w oknie zmiennej ZLEC ZGH_GEN są w dobrym przedziale
::   WE: _a - gorne ograniczenie (0 - nie sprawdzane)
::       _b - xjm wg technologii (0 - nie sprawdzana)
::       [_c] - INTEGER - czy podczas walidacji sprawdzać czy na podzleceniach nie zostaną
::                        wygenerowane przewodniki ze złą dokładnością
::  OLD: \validate_ile/zl_guid.fml
::  OLD: \validate_ile/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_up:=_a;
_xjm:=_b;

_chk_podzlec:=1;
{? var_pres('_c')=type_of(0)
|| _chk_podzlec:=_c
?};

_result:='';

roundmet(2);
_dokl:=exec('jaka_dok_m','jm',ZL.KTM);
_wolne:=exec('wolne_numery','zl_guide',ZL.ref());
ZLEC.IL_ZGH:=ZLEC.IL_ZGH$_dokl;
ZLEC.IL_ZL:=ZLEC.IL_ZL$_dokl;
_parted:=exec('zl_ile_part','zl_partie',ZL.ref());
_to_part:=ZL.IL-_parted;

{? ZLEC.IL_ZGH<=0
|| FUN.info('Ilość na jednym przewodniku musi być większa od zera.'@);
   _result:='IL_ZGH'
|? ZLEC.IL_ZL<=0
|| FUN.info('Ilość do podziału musi być większa od zera.'@);
   _result:='IL_ZL'
|? _up=0
|| _result:=''
|? ZLEC.IL_ZGH>_up
|| FUN.info('Ilość na jednym przewodniku nie może być większa niż %1.'@[$_up]);
   ZLEC.IL_ZGH:=_up;
   _result:='IL_ZGH'
|? ZLEC.IL_ZL>_up
|| FUN.info('Ilość do podziału nie może być większa niż %1.'@[$_up]);
   ZLEC.IL_ZL:=_up;
   _result:='IL_ZL'
|? ZLEC.IL_ZGH>ZLEC.IL_ZL
|| _result:='IL_ZL';
   FUN.info('Ilość na jednym przewodniku nie może być większa niż ilość do podziału.'@)
|? _xjm<>0 & ZLEC.IL_ZGH<>_xjm
|| {? FUN.ask(
         'Przewodnik zawiera operacje zewnętrzne,\n'
         'czas realizacji takich operacji (ilość dni) został zdefiniowany dla serii: %1 %2.\n\n'
         'Wygenerowanie przewodnika dla innej serii może wymagać poprawienia pozycji przewodnika.\n\n'
         'Czy kontynuować?'@[form(_xjm),ZL.KTM().J().KOD]
      )
   || _result:=''
   || _res:='IL_ZGH'
   ?}
|? (ZLEC.IL_ZL/ZLEC.IL_ZGH)>_wolne
|| FUN.info(
      'Maksymalna liczba przewodników do wygenerowania: %1.\n'
      'Przy zadanej ilości będzie ich: %2.'@[form(_wolne),form(_up/ZLEC.IL_ZGH$0)]
   );
   _result:='IL_ZGH'
|? _parted>0 & ZLEC.IL_ZL>_to_part
|| FUN.info('Ilość do podziału nie może być większa niż ilość na partiach zlecenia.'@);
   _result:='IL_ZL'
|| _result:=''
?};
{? _result='' & _chk_podzlec>0
|| _result:=exec('czy_il_reg','zl_guide')
?};
_result


\generuj_get_ilosc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Wyznacza ilość na jaką generować przewodniki:
::       Albo wyświetla okno z pytaniem o ilość na jaką generować przewodniki zlecenia
::       Albo wyznacza automatem z tego co zostało do podzielenia na przewodniki uwzględniając serie itp
::   WE: [_a] - ZL.ref() - ref zlecenia lub bieżący rekord
::       [_b] - INTEGER - 0/[1] - czy wyświetlać dialogi
::       [_c] - INTEGER - [0]/1 - czy akcja grupowa
::       [_d] - INTEGER - 0/[1] - czy wyświetlać dodatkowe dialogi dla zlecenia złożonego?
::   WY: obj_new().IL_ZGH - ilość na pojedynczym przewodniku
::       obj_new().IL_ZL - jaką ilość ze zlecenia dzielić
::       obj_new().OK - czy ok (0, 1, -1 - wycofanie z akcji)
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};
_ask:=1;
{? var_pres('_b')=type_of(0)
|| _ask:=_b
?};
_grupa:=0;
{? var_pres('_c')=type_of(0)
|| _grupa:=_c
?};
_dialog_complex:=1;
{? var_pres('_d')=type_of(0)
|| _dialog_complex:=_d
?};

_result:=obj_new('IL_ZGH'
                  ,'IL_ZL'
                  ,'OK');
_result.IL_ZGH:=0;
_result.IL_ZL:=0;
_result.OK:=0;
_can_continue:=1;
ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
{? _can_continue>0
||
   _il_zl:=0;
   _il_zgh:=0;

   TOPER.cntx_psh();
   _top_level:=exec('top_level','zl_link',ZL.ref());
   _top_rodzaj:=exec('FindAndGet','#table',ZL,_top_level,,"RODZAJ",'');
   _top_uid:=exec('FindAndGet','#table',ZL,_top_level,,"uidref()",'');

   _main_podzlec:=exec('main_podzlec','zl_link',ZL.ref());
   _main_has_zgh:=exec('has_zgh','zl_common',_main_podzlec);
   _main_sym:=exec('FindAndGet','#table',ZL,_main_podzlec,,"SYM",'');

   _zgh_tied:=1;
   {? _main_podzlec<>ZL.ref()
   || _zgh_tied:=exec('chk_zgh_tied','zl_guide')
   ?};
   {? _zgh_tied>0 & _top_rodzaj='Z' & exec('kor_coef_equal','zl_head',_top_level)=0
   ||
::    Jeśli zlecenie złożone, przewodniki są równo ułożone, ale podzlecenia mają ilość niezgodną
::    z proporcją to traktuję je tak jakby miały nierówno ułożone przewodniki
      _zgh_tied:=0
   ?};

   _tktl:=null();
   {? ZL.RTKTL<>''
   || _tktl:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,,null())
   |? ZL.RKTL<>''
   || _tktl:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,,null())
   ?};

   {? _tktl=null()
   || _msg:='Nie znaleziono karty technologicznej, na podstawie której generować przewodniki.'@;
      {? _ask
      || FUN.emsg(_msg)
      || KOMM.add(_msg,2,,1)
      ?};
      _can_continue:=0
   ?};
::   {? _can_continue>0
::   ||
::      _arch:=exec('FindAndGet','#table',TKTL,_tktl,,"ARCH",'');
::      {? _arch='T'
::      || _msg:='Karta technologiczna w archiwum, nie można na jej podstawie generować przewodników'@;
::         {? _ask
::         || FUN.emsg(_msg)
::         || KOMM.add(_msg,2,,1)
::         ?};
::         _can_continue:=0
::      ?}
::   ?};

   {? _can_continue>0
   || TOPER.index('NNN');
      TOPER.prefix(_tktl,0,'N');
      {? TOPER.first()=0
      || _msg:='Proces technologiczny nie zawiera operacji, aby wygenerować przewodniki.'@;
         {? _ask
         || FUN.emsg(_msg)
         || KOMM.add(_msg,2,,1)
         ?};
         _can_continue:=0
      ?}
   ?};

   {? _can_continue>0
   ||
      {? ZL.RODZAJ='Z'
      || _ile:=exec('ile','zl_guide',_main_podzlec,ZL.IL)
      || _ile:=exec('ile','zl_guide',ZL.ref(),ZL.IL)
      ?};
      {? _ile>0
      ||
         _il_zl:=ZL.IL;
         _seria:=exec('seria','zl_guide',_tktl,_ile);
         _il_zgh:=_seria;
         _chk_podzlec:=1;

         {? _ask>0
         ||
            {? _top_rodzaj='Z'
            ||
::             Dodatkowe dialogi dla zlecenia złożonego
               {? _main_has_zgh=0 | _main_podzlec=ZL.ref()
               ||
                  {? _main_podzlec<>ZL.ref()
                  ||
                     {? _dialog_complex>0
                     || _zgh_tied:=0;
::                      Jeśli montażowe nie ma jeszcze przewodników a jestem na innym zleceniu
::                      niż montażowe to wyświetlam zapytanie czy na pewno podzielić
                        _msg:='Główne podzlecenie montażowe zlecenia złożonego: %1\n'
                              'nie posiada jeszcze przewodników.\n\n'
                              'Możliwe jest wygenerowanie przewodników na zleceniu: %2\n'
                              'ale nie będą one propocjonalne w stosunku do innych podzleceń.\n\n'@[_main_sym,ZL.SYM];
                              'Kontynuować?';
                        {? FUN.ask(_msg)
                        || _can_continue:=1
                        || _can_continue:=-1
                        ?}
                     ?}
                  ?};
                  {? _can_continue>0
                  || _chk_podzlec:=0
                  ?}
               |? _zgh_tied=0
               ||
                  {? _grupa=0
                  ||
                     {? _dialog_complex>0
                     ||
::                      Akcja nie grupowa
::                      Są przewodniki na montażowym, ale na moim zleceniu są jakieś niepowiązane przewodniki więc pytam
::                      czy na pewno i wyświetlam dialog z ilościami
                        _msg:='Zlecenie: %1 posiada niepowiązane ze zleceniem montażowym przewodniki.\n\n'
                              'Możliwe jest wygenerowanie przewodników na zleceniu: %2\n'
                              'ale nie będą one propocjonalne w stosunku do innych podzleceń.\n\n'@[ZL.SYM,ZL.SYM];
                              'Kontynuować?';
                        {? FUN.ask(_msg)
                        || _can_continue:=1
                        || _can_continue:=-1
                        ?}
                     ?}
                  ||
::                   Akcja grupowa, nie mogę zapytać więc nie generuję nic
                     _can_continue:=0;
                     KOMM.add('Zlecenie: %1 posiada niepowiązane ze zleceniem montażowym przewodniki. Generowanie niemożliwe.'@[ZL.SYM],2,,1)
                  ?}
               ?}
            ?};
            {? _can_continue>0 &
               (_top_rodzaj<>'Z' | (_zgh_tied=0 | ZL.RODZAJ='Z' | (_top_rodzaj='Z'&exec('is_main_podzlec','zl_link'))))
            ||
::             Wyświetlam zapytanie o ilość na przewodniku
               _res_ask:=exec('ask_ile','zl_guide',,_ile,_chk_podzlec);
               {? type_of(_res_ask)>100
               || _il_zl:=_res_ask.IL_ZL;
                  _il_zgh:=_res_ask.IL_ZGH;
                  _can_continue:=_res_ask.OK
               || _can_continue:=0
               ?}
            ?}
         ?}
      || _msg:='Ilość na przewodnikach nie może być większa niż na zleceniu.'@;
         {? _ask
         || FUN.emsg(_msg)
         || KOMM.add(_msg,2,,1)
         ?};
         _can_continue:=0;
         _il_zl:=0;
         _il_zgh:=0;
         _can_continue:=0
      ?}
   ?};
   TOPER.cntx_pop();

   _result.OK:=_can_continue;
   _result.IL_ZGH:=_il_zgh;
   _result.IL_ZL:=_il_zl;
   ~~
?};
ZL.cntx_pop();
_result


\czy_il_reg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2009+]
:: OPIS: Po wypelnieniu na ile ma byc generowany przewodnik, sprawdza czy w zleceniu polfabrykatowym
::       nie wygeneruje przewodnikow ze zla dokladnoscia. w kontekscie zlecenie nadrzedne
::  OLD: \czy_il_reg/zl_guid.fml
::  OLD: \czy_il_reg/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_top_level:=exec('top_level','zl_link',ZL.ref());
_result:='';

_ile:=exec('ile','zl_guide',ZL.ref(),ZL.IL);
_liczba:=_ile/ZLEC.IL_ZGH$0;

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_top_level)
||

   ZL.cntx_psh();
   ZL.index('STAN');
   ZL.prefix('T','N',ZL.UNRZL);
:: Lece po podrzednych i patrze, czy nie zostanie wygenerowany przewodnik na ulamkowe ilosci,
:: pomijam zlecenia z technologia bez operacji, bo do nich juz wczesniej przewodniki techniczne
   {? ZL.first()
   || {!
      |? {? (ZL.RKTL<>'' & exec('FindAndGet','#table',TKTL,ZL.RKTL,,"TYP().OPER",'')='T') |
            (ZL.RTKTL<>'' & exec('FindAndGet','#table',TKTL,ZL.RTKTL,,"TYP().OPER",'')='T')
         ||
            _dokl:=exec('jaka_dok_m','jm',ZL.KTM);
            _il:=exec('ile','zl_guide',ZL.ref(),ZL.IL);
            {? _liczba=0 || _il2:=1 ||  _il2:=_il/_liczba ?};
            {? _il2>0 & _il2<1 & _dokl=0
            || FUN.emsg('Wprowadzona ilość na przewodniku spowoduje\n'
                        'wygenerowanie przewodników zlecenia podrzędnego na ilość mniejszą niż 1.'@);
               _result:='IL_ZGH'
            || _new_il:=_il*ZLEC.IL_ZGH/_ile;
               _il2:=_il;
               {? _new_il>0
               || {!
                  |? _il2-=_new_il;
                     _il2>=_new_il
                  !}
               ?};
               {? _il2>0 & _il2<1 & _dokl=0
               || FUN.emsg('Wprowadzona ilość na przewodniku spowoduje\n'
                           'wygenerowanie przewodników zlecenia podrzędnego na ilość mniejszą niż 1.'@);
                  _result:='IL_ZGH'
               || {? _new_il$_dokl<>_new_il
                  || {? FUN.ask('Wprowadzona ilość na przewodniku spowoduje\n'
                                'wygenerowanie przewodników zlecenia podrzędnego na ilość niecałkowitą.\n'
                                'Spowoduje to problemy przy rejestracji akordu. Czy kontynuować?'@)
                     ||
                        _result:=''
                     || _result:='IL_ZGH'
                     ?}
                  ?}
               ?}
            ?}
         ?};
         ZL.next() & _result=''
      !}
   ?};
   ZL.cntx_pop()
?};
ZL.cntx_pop();
_result


\generuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JM [7.22]
:: OPIS: Generowanie jednego przewodnika do zlecenia na podstawie technologii
::   WE: [_a] - czy wyswietlac pytania o ilosc na przewodniku:
::                1 - tak domyslnie / 0 - nie / -1 - nie wyświetlać żadnych komunikatów
::       [_b] - czy sprawdzac plan zasobow i wg niego generowac przewodniki (1 - tak domyslnie / 0 - nie)
::       [_c] - czy generowac przewodniki wg partii, jezeli zlecenie partiowane (1 - tak domyslnie / 0 - nie)
::       [_d] - STRING - klucz grupujący którym stemplować utworzone przewodniki
::       [_e] - INTEGER - [0]/1 - czy akcja grupowa
::       [_f] - INTEGER - [0]/1 - czy generować od razu zakończone przewodniki
::       [_g] - REAL - ilość ze zlecenia którą podzielić
::       [_h] - REAL - ilość na jednym przewodniku
::       [_i] - czy generować przewodniki wg wtyczki, jeżeli dostępna (1 - tak domyślnie / 0 - nie)
::   WY: -1 - użytkownik zrezygnował w dialogu
::       0 - nie wygenerowano
::       1 - sukces
::  OLD: \generuj/zl_guid.fml
::  OLD: \generuj/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _ask:=_a     || _ask:=1     ?};
{? var_pres('_b')=type_of(0) || _planres:=_b || _planres:=1 ?};
{? var_pres('_c')=type_of(0) || _partie:=_c  || _partie:=1  ?};

_env_guide:=exec('env_guide','zl_guide');
params_set('env_guide',_env_guide);

_grp_key:='';
{? var_pres('_d')=type_of('')
|| _grp_key:=_d
?};

_grupa:=0;
{? var_pres('_e')=type_of(0)
|| _grupa:=_e
?};

_zakoncz:=0;
{? var_pres('_f')=type_of(0)
|| _zakoncz:=_f
?};

_par_il_zl:=-1;
{? var_pres('_g')=type_of(0)
|| _par_il_zl:=_g
?};

_par_il_zgh:=-1;
{? var_pres('_h')=type_of(0)
|| _par_il_zgh:=_h
?};

{? var_pres('_i')=type_of(0) || _plugin:=_i || _plugin:=1 ?};

_dialog:={? _ask>=0 || 1 || 0 ?};
{? _ask<0 || _ask:=0 ?};

ZL.cntx_psh();
TOPER.cntx_psh();

ZL.cntx_psh();
_par:=exec('get','#params',500104,2);
_zlil:=0;
ZL.cntx_pop();
_ok:=exec('przeddol','zl_guide');

{? ~(_ok & (VAR.A_ZLEC().TKTL<>null() | VAR.A_ZLEC().TYP().TECH='N' | VAR.A_ZLEC().NRNZL=0))
|| {? (VAR.A_ZLEC().NRNZL<>0 & _ok)
   || {? _dialog>0
      || FUN.info('Brak karty technologicznej, aby wygenerować przewodniki.'@)
      ?}
   ?};
   _ok:=0
|? ~(_ok & (VAR.A_ZLEC().TYP().TECH='T' | VAR.A_ZLEC().TYP().TECH='N' & VAR.A_ZLEC().KTL<>null()))
|| {? _dialog>0
   || FUN.info('Na podstawie archiwalnej karty technologicznej nie można generować przewodników.'@)
   ?};
   _ok:=0

|? ~(_ok & (VAR.A_ZLEC().TYP().TECH='T' | VAR.A_ZLEC().TYP().TECH='N' & exec('check_tktl_arch','zl_link',ZL.ref())=0))
|| {? _dialog>0
   || FUN.info('Co najmniej jedno podzlecenie ma archiwalną technologię — nie można generować przewodników.'@)
   ?};
   _ok:=0
|? ~(_ok & (VAR.A_ZLEC().TYP().TECH='T' | VAR.A_ZLEC().TYP().TECH='N' & exec('tktl_act','tech_head',3)))
|| {? _dialog>0 & FUN.ask(
         'Do zlecenia została przypisana nieaktualna karta technologiczna.\n'
         'Czy generować przewodniki zlecenia na jej podstawie?'@
      )
   || _ok:=1
   || _ok:=0
   ?}
|? ~(_ok & (VAR.A_ZLEC().TYP().TECH='T' | VAR.A_ZLEC().TYP().TECH='N' & exec('check_tktl_act','zl_link',ZL.ref())=0))
|| {? _dialog>0 & FUN.ask(
         'Co najmniej jedno podzlecenie ma przypisaną nieaktulną kartę technologiczną.\n'
         'Czy generować przewodniki zlecenia na ich podstawie?'@
      )
   || _ok:=1
   || _ok:=0
   ?}
?};
{? _ok
||
   VAR_DEL.delete('__matakt');
   __matakt:=tab_tmp(2
      ,'REF','STRING[16]',''
      ,'NRK','INTEGER',''
      ,'ILR','REAL',''
      ,'ZKP','STRING[16]',''
      ,'ZKN','STRING[16]',''
   );

   _top_level:=exec('top_level','zl_link',ZL.ref());
   _top_rodzaj:=exec('FindAndGet','#table',ZL,_top_level,,"RODZAJ",'');
   _top_uid:=exec('FindAndGet','#table',ZL,_top_level,,"uidref()",'');

   {? _top_rodzaj='Z'
   ||
::    Zlecenia zlozone

::    PLAN ZASOBOW
      {? _planres>0
      || {? exec('zlec_planned','po_plan',$VAR.A_ZLEC)>0
         || _return:=0;
            {? exec('plan2zgh_smpl2','zl_guide',VAR.A_ZLEC,_grp_key,_top_uid,_ask,_zakoncz)>0
            || _return:=1
            ?};
            ZL.cntx_pop();
            TOPER.cntx_pop();
            return(_return)
         ?}
      ?};

::    PARTIE
      {? _partie>0
      ||
         {? exec('zlec_party','zl_common',VAR.A_ZLEC)>0 & exec('zl_ile_part','zl_partie',VAR.A_ZLEC)>0
         || _return:=0;
            {? exec('part2zgh_smpl2','zl_guide',VAR.A_ZLEC,_grp_key,_top_uid,_ask,_zakoncz)>0
            || _return:=1
            ?};
            ZL.cntx_pop();
            TOPER.cntx_pop();
            return(_return)
         ?}
      ?};

::    WTYCZKA
      {? _plugin>0 & _par_il_zgh=-1 & _par_il_zl=-1 & ZL.TREE_TYP='M'
      || ZL.cntx_psh(); _var_zlec:=VAR.A_ZLEC;
         _json:=Plugin.run('ZGH_F_ILGEN_001',ZL.ref(),_ask,exec('ile','zl_guide',ZL.ref(),ZL.IL));
         ZL.cntx_pop(); VAR.A_ZLEC:=_var_zlec;
         _tab_plugin:=json_parse(_json);
         {? type_of(_tab_plugin)>100 & obj_len(_tab_plugin)>0
         || exec('array_force_numbers','#array',_tab_plugin);
            exec('array_round','#array',_tab_plugin,ZL.KTM().DOKL);
            exec('array_del_minus','#array',_tab_plugin);
            _return:=0;
            {? exec('plug2zgh_smpl2','zl_guide',VAR.A_ZLEC,_grp_key,_top_uid,_ask,_zakoncz,_tab_plugin)>0
            || _return:=1
            ?};
            ZL.cntx_pop();
            TOPER.cntx_pop();
            return(_return)
         ?}
      ?};

::    PYTANIE O ILOŚĆ
      {? _par_il_zgh=-1 & _par_il_zl=-1
      ||
::       Ilości nadrzędne nie zostały podane, więc pytam użytkownika albo wymyślam
         _res_ilosc:=exec('generuj_get_ilosc','zl_guide',,_ask,_grupa);
         _il_zl:=_res_ilosc.IL_ZL;
         _il_zgh:=_res_ilosc.IL_ZGH;
         _ok:=_res_ilosc.OK
      || _il_zl:=_par_il_zl;
         _il_zgh:=_par_il_zgh;
         _ok:=1
      ?};
      _main_podzlec:=exec('main_podzlec','zl_link',ZL.ref());
      _main_has_zgh:=exec('has_zgh','zl_common',_main_podzlec);
      _main_sym:=exec('FindAndGet','#table',ZL,_main_podzlec,,"SYM",'');
      _zgh_tied:=1;
      {? _main_podzlec<>ZL.ref()
      || _zgh_tied:=exec('chk_zgh_tied','zl_guide')
      ?};
      {? _zgh_tied>0 & _top_rodzaj='Z' & exec('kor_coef_equal','zl_head',_top_level)=0
      ||
::       Jeśli zlecenie złożone, przewodniki są równo ułożone, ale podzlecenia mają ilość niezgodną
::       z proporcją to traktuję je tak jakby miały nierówno ułożone przewodniki
         _zgh_tied:=0
      ?};

      {? _ok>0
      ||
         {? _il_zl>0
         ||
::          GENEROWANIE PRZEWODNIKÓW
            exec('gen_przh_obj','zl_guide');
            {? _main_podzlec<>ZL.ref() & _main_has_zgh>0 & _zgh_tied>0
            ||
::             Zlecenie inne niż montażowe, sprawdzam czy na montażowym są już jakieś przewodniki
::             i generuje przewodniki wg takich samych proporcji
               _tab_zgh:=exec('main_podzlec_zgh','zl_guide',ZL.ref());
               _tab_zgh.clear();
               {? _tab_zgh.first()
               ||
                  {!
                  |?
                     ZGH.cntx_psh();
                     ZGH.index('UID_SRC');

::                   Sprawdzam czy na tym zleceniu nie robiono jeszcze przewodnika na podstawie
::                   montażowego
                     ZGH.prefix(_tab_zgh.UID,ZL.ref());
                     {? ZGH.size()=0
                     ||
                        _il_zgh:=_tab_zgh.ILNPRZ;
::                      Obliczam proporcję
                        _prop:=ZL.IL/_tab_zgh.IL_ZL;

                        _il_zgh:=_il_zgh*_prop;

                        _il_zgh:={? _il_zl>_il_zgh || _il_zgh || _il_zl ?};
                        _ile_now:=exec('ile','zl_guide',ZL.ref,ZL.IL);
                        _il_zgh:=exec('min','#math',_ile_now,_il_zgh);
::                      Zaokrąglanie
                        {? ZL.KTM().DOKL=0
                        || _il_zgh:=ceil(_il_zgh)
                        || _il_zgh:=_il_zgh$ZL.KTM().DOKL
                        ?};
                        exec('add_zgh','zl_guide',_il_zgh,ZL.ref(),,,,,,_grp_key,_top_uid,_tab_zgh.UID,_zakoncz);
                        _il_zl-=_il_zgh
                     ?};
                     _ile_now:=exec('ile','zl_guide',ZL.ref(),ZL.IL);

                     ZGH.cntx_pop();
                     _tab_zgh.next() & _ile_now>0
                  !}
               ?}
            ||
               _ile_now:=exec('ile','zl_guide',ZL.ref,ZL.IL);
               _il_zl:=exec('min','#math',_ile_now,_il_zl);
               {!
               |?
                  _il_zgh:={? _il_zl>_il_zgh || _il_zgh || _il_zl ?};
                  {? _il_zgh>0
                  ||
                     exec('add_zgh','zl_guide',_il_zgh,ZL.ref(),,,,,,_grp_key,_top_uid,,_zakoncz);
                     _il_zl-=_il_zgh
                  ?};
                  _il_zl>0 & _il_zgh>0
               !}
            ?};
            exec('del_przh_obj','zl_guide')
         ?}
      ?}
   |? _top_rodzaj='P' | _top_rodzaj='N'
   ||
::    Zlecenia proste lub składniki zlecenia niezależnego

::    PLAN ZASOBOW
      {? _planres>0
      || {? exec('zlec_planned','po_plan',$VAR.A_ZLEC)>0
         || _return:=0;
            {? exec('plan2zgh_smpl','zl_guide',VAR.A_ZLEC,_grp_key,_ask,_zakoncz)>0
            || _return:=1
            ?};
            ZL.cntx_pop();
            TOPER.cntx_pop();
            return(_return)
         ?}
      ?};

::    PARTIE
      {? _partie>0
      ||
         {? exec('zlec_party','zl_common',VAR.A_ZLEC)>0 & exec('zl_ile_part','zl_partie',VAR.A_ZLEC)>0
         || _return:=0;
            {? exec('part2zgh_smpl','zl_guide',VAR.A_ZLEC,_grp_key,_ask,_zakoncz)>0
            || _return:=1
            ?};
            ZL.cntx_pop();
            TOPER.cntx_pop();
            return(_return)
         ?}
      ?};

::    WTYCZKA
      {? _plugin>0 & _par_il_zgh=-1 & _par_il_zl=-1
      || ZL.cntx_psh(); _var_zlec:=VAR.A_ZLEC;
         _json:=Plugin.run('ZGH_F_ILGEN_001',ZL.ref(),_ask,exec('ile','zl_guide',ZL.ref(),ZL.IL));
         ZL.cntx_pop(); VAR.A_ZLEC:=_var_zlec;
         _tab_plugin:=json_parse(_json);
         {? type_of(_tab_plugin)>100 & obj_len(_tab_plugin)>0
         || exec('array_force_numbers','#array',_tab_plugin);
            exec('array_round','#array',_tab_plugin,ZL.KTM().DOKL);
            exec('array_del_minus','#array',_tab_plugin);
            _return:=0;
            {? exec('plug2zgh_smpl','zl_guide',VAR.A_ZLEC,_grp_key,_ask,_zakoncz,_tab_plugin)>0
            || _return:=1
            ?};
            ZL.cntx_pop();
            TOPER.cntx_pop();
            return(_return)
         ?}
      ?};

::    PYTANIE O ILOŚĆ
      {? _par_il_zgh=-1 & _par_il_zl=-1
      ||
::       Ilości nadrzędne nie zostały podane, więc pytam użytkownika albo wymyślam
         _res_ilosc:=exec('generuj_get_ilosc','zl_guide',,_ask,_grupa);
         _il_zl:=_res_ilosc.IL_ZL;
         _il_zgh:=_res_ilosc.IL_ZGH;
         _ok:=_res_ilosc.OK
      || _il_zl:=_par_il_zl;
         _il_zgh:=_par_il_zgh;
         _ok:=1
      ?};

      {? _ok>0
      ||
::       GENEROWANIE PRZEWODNIKÓW
         exec('gen_przh_obj','zl_guide');

::       Ponownie obliczam ilość która została do rozgenerowania na zleceniu na wypadek
::       gdyby ktoś dodał lub wygenerował przewodniki podczas gdy ja się zastanawiałem
::       w oknie
         _ile_now:=exec('ile','zl_guide',VAR.A_ZLEC,VAR.A_ZLEC().IL);
         _il_zl:=exec('min','#math',_ile_now,_il_zl);
         {? _il_zl>0
         ||
            {!
            |? _il_zgh:={? _il_zl>_il_zgh || _il_zgh || _il_zl ?};
               exec('add_zgh','zl_guide',_il_zgh,,,,,,,_grp_key,,,_zakoncz);
               _il_zl-=_il_zgh;
               _il_zl>0
            !};
            exec('del_przh_obj','zl_guide')
         || _ok:=0;
            {? _dialog>0
            || FUN.info('Ilość na przewodnikach nie może być większa niż na zleceniu.'@)
            ?}
         ?}
      ?}
   ?};
   exec('openz','open_tab',ST.ODDZ+'__');
   exec('akt_rezy','rezerwacje');
   VAR_DEL.delete('__matakt')

?};

:: Aktualizacja limitow w zakladce, gdy jest wyswietlana
::{? _ok
::|| {? var_pres('__ZLIMp')>100
::   || exec('__ZLIM_datapump','zl_limit',__ZLIMp);
::      _zmask:=ZMASK.THEAD;
::      ZMASK.THEAD:='0';
::      {? cur_tab()=ZL & VAR.ZAKL_ALL*'L'>0 || exec('lim_hide','zlv',1) ?};
::      {? cur_tab()=ZL & VAR.ZAKL_ALL*'Z'>0 || exec('zam_hide','zlv',1) ?};
::      ZMASK.THEAD:=_zmask
::   ?}
::?};

ZL.cntx_pop();
TOPER.cntx_pop();
VAR.A_ZLEC:=ZL.ref();
_ok


\plan2zgh_smpl2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Generuje przewodniki z planu dla zlecenia podrzednego
::   WE: _a - ZL.ref() - zlecenie proste ktoremu tworze przewodniki
::       [_b] - STRING - klucz grupujący którym stemplować przewodniki
::       [_c] - STRING - identyfikator którym spinać przewodniki dla widoku od strony zlecenia złożonego nadrzędnego
::       [_d] - INTEGER - czy wyświetlać dialogi
::       [_e] - INTEGER - [0]/1 - czy generować od razu zakończone przewodniki
::   WY: REAL - ilosc na jaka zostaly wygenerowane przewodniki z planu
::  OLD: \plan2zgh_smpl2/pl_okr3.fml
::  OLD: \plan2zgh_smpl2/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_zlec:=null();
_result:=0;
{? _>0
|| _zlec:=_a
?};
_grp_key:='';
{? var_pres('_b')=type_of('')
|| _grp_key:=_b
?};
_uid_view:='';
{? var_pres('_c')=type_of('')
|| _uid_view:=_c
?};
_dialog:=1;
{? var_pres('_d')=type_of(0)
|| _dialog:=_d
?};
_zakoncz:=0;
{? var_pres('_e')=type_of(0)
|| _zakoncz:=_e
?};

ZL.cntx_psh();
PL_PART.cntx_psh();
ZGH.cntx_psh();
ZGH.index('ZLNR');

ZL.clear();
ZL.index('NRNZL');

PL_PART.clear();
PL_PART.index('ZL');

_ilosc:=0;
:: lece po zleceniach podrzednych i generuje przewodniki zgodnie z planem
{? _zlec<>null
|| {? ZL.seek(_zlec)
   ||
      _ilosc:=exec('guidgen_proste_pl','zl_guide',ZL.ref(),_grp_key,_uid_view,_zakoncz)
   ?};
   VAR.A_ZLEC:=_zlec;
   _dokl:=ZL.KTM().DOKL;
   _jm:=ZL.KTM().J().KOD;

:: jesli z planu wygenerowalem mniej przewodnikow niz ilosc na zleceniu (bo np nie zaplanowalem wszystkiego)
:: to trzeba dogenerowac reszte standardowa metoda
   _ile_brak:=exec('ile','zl_guide',VAR.A_ZLEC,VAR.A_ZLEC().IL);
   _ile_plan:=exec('zlec_planned','po_plan',$VAR.A_ZLEC);
   {? _ile_brak>0
   || {? _dialog>0
      ||
         _msg:='Utworzono z planu przewodniki na ilość: %1 %2.\n'
               'Brakuje przewodników na ilość: %3 %4.\n\n'
               'Wygenerować przewodniki na pozostałą ilość?'@
               [form(_ile_plan,,_dokl,'9,'),_jm,form(_ile_brak,,_dokl,'9,'),_jm];
         _ask:=FUN.ask(_msg)
      || _ask:=1
      ?};
      {? _ask>0
      || exec('generuj','zl_guide',_dialog,0,,_grp_key,_uid_view,,,,0)
      ?}
   ?}
?};

ZGH.cntx_pop();
PL_PART.cntx_pop();
ZL.cntx_pop();
_ilosc


\part2zgh_smpl2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Generuje przewodniki z partii dla zlecenia podrzednego
::   WE: _a - ZL.ref() - zlecenie proste ktoremu tworze przewodniki
::       [_b] - STRING - klucz grupujący którym stemplować przewodniki
::       [_c] - STRING - identyfikator którym spinać przewodniki dla widoku od strony zlecenia złożonego nadrzędnego
::       [_d] - INTEGER - czy wyświetlać dialogi
::       [_e] - INTEGER - [0]/1 - czy generować od razu zakończone przewodniki
::   WY: REAL - ilosc na jaka zostaly wygenerowane przewodniki z planu
::  OLD: \part2zgh_smpl2/zparn.fml
::  OLD: \part2zgh_smpl2/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_zlec:=null();
_result:=0;
{? _>0
|| _zlec:=_a
?};
_grp_key:='';
{? var_pres('_b')=type_of('')
|| _grp_key:=_b
?};
_uid_view:='';
{? var_pres('_c')=type_of('')
|| _uid_view:=_c
?};
_dialog:=1;
{? var_pres('_d')=type_of(0)
|| _dialog:=_d
?};
_zakoncz:=0;
{? var_pres('_e')=type_of(0)
|| _zakoncz:=_e
?};

ZL.cntx_psh();
ZPARN.cntx_psh();
ZGH.cntx_psh();
ZGH.index('ZLNR');

ZL.clear();
ZL.index('NRNZL');

ZPARN.clear();
ZPARN.index('ZL');

_ilosc:=0;
:: lece po zleceniach podrzednych i generuje przewodniki zgodnie z planem
{? _zlec<>null
|| {? ZL.seek(_zlec)
   ||
      _ilosc:=exec('guidgen_proste_part','zl_guide',ZL.ref(),_grp_key,_uid_view,_zakoncz)
   ?};
   VAR.A_ZLEC:=_zlec;
   _dokl:=ZL.KTM().DOKL;
   _jm:=ZL.KTM().J().KOD;

:: jesli z partii wygenerowalem mniej przewodnikow niz ilosc na zleceniu (bo np nie popartiowalem wszystkiego)
:: to trzeba dogenerowac reszte standardowa metoda
   _ile_brak:=exec('ile','zl_guide',ZL.ref(),ZL.IL);
   _ile_plan:=exec('zl_ile_part','zl_partie',ZL.ref());
   {? _ile_brak>0
   || {? _dialog>0
      || _msg:='Utworzono z partii przewodniki na ilość: %1 %2.\n'
               'Brakuje przewodników na ilość: %3 %4.\n\n'
               'Wygenerować przewodniki na pozostałą ilość?'@
               [form(_ile_plan,,_dokl,'9,'),_jm,form(_ile_brak,,_dokl,'9,'),_jm];
         _ask:=FUN.ask(_msg)
      || _ask:=1
      ?};
      {? _ask>0
      || exec('generuj','zl_guide',_dialog,0,0,_grp_key,_uid_view,,,,0)
      ?}
   ?}
?};

ZGH.cntx_pop();
ZPARN.cntx_pop();
ZL.cntx_pop();
_ilosc


\chk_zgh_tied
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy wszystkie przewodniki podzlecenia są powiązane z przewodnikami montażowego
::   WE: [_a] - ZL.ref() - zlecenie lub aktualny rekord
::   WY: 0 - są jakieś niepowiazane przewodniki
::       1 - brak niepowiązanych przewodników
::  TAG: <PUBLICZNA>
::  OLD: \chk_zgh_tied/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=1;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.clear();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   ZGH.cntx_psh();
   ZGH.index('ZLNR');
   ZGH.prefix(ZL.ref());
   {? ZGH.first()
   || {!
      |?
         {? ZGH.UID_SRC=''
         ||
::          Puste powiazanie
            _can_continue:=0
         ||
::          Powiązanie niepuste, sprawdzam czy na pewno jest taki przewodnik w bazie
            ZGH.cntx_psh();
            ZGH.index('UID');
            ZGH.prefix(ZGH.UID_SRC);
            {? ZGH.size()=0
            ||
::             Nie ma przewodnika, więc traktuję to tak samo jak puste powiązanie
               _can_continue:=0
            ?};
            ZGH.cntx_pop()
         ?};
         ZGH.next() & _can_continue>0
      !}
   ?};
   ZGH.cntx_pop();
   {? _can_continue=0
   || _result:=0
   ?}
?};
ZL.cntx_pop();
_result


\plan2zgh_smpl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Generuje przewodniki z planu dla zlecenia prostego
::   WE: _a - ZL.ref() - zlecenie proste ktoremu tworze przewodniki
::       [_b] - STRING - klucz grupujący którym stemplować przewodniki
::       [_c] - INTEGER - czy wyświetlać dialogi
::       [_d] - INTEGER - [0]/1 - czy generować od razu zakończone przewodniki
::   WY: REAL - ilosc na jaka zostaly wygenerowane przewodniki z planu
::  OLD: \plan2zgh_smpl/pl_okr3.fml
::  OLD: \plan2zgh_smpl/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_zlec:=null();
_result:=0;
{? _>0
|| _zlec:=_a
?};
_grp_key:='';
{? var_pres('_b')=type_of('')
|| _grp_key:=_b
?};
_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};
_zakoncz:=0;
{? var_pres('_d')=type_of(0)
|| _zakoncz:=_d
?};

ZL.cntx_psh();
PL_PART.cntx_psh();
ZGH.cntx_psh();
ZGH.index('ZLNR');

ZL.clear();
ZL.index('NRNZL');

PL_PART.clear();
PL_PART.index('ZL');

_ilosc:=0;
:: lece po zleceniach podrzednych i generuje przewodniki zgodnie z planem
{? _zlec<>null
|| {? ZL.seek(_zlec)
   || _ilosc:=exec('guidgen_proste_pl','zl_guide',ZL.ref(),_grp_key,,_zakoncz)
   ?};
   VAR.A_ZLEC:=_zlec;
   _dokl:=ZL.KTM().DOKL;
   _jm:=ZL.KTM().J().KOD;

:: jesli z planu wygenerowalem mniej przewodnikow niz ilosc na zleceniu (bo np nie zaplanowalem wszystkiego)
:: to trzeba dogenerowac reszte standardowa metoda
   _ile_brak:=exec('ile','zl_guide',VAR.A_ZLEC,VAR.A_ZLEC().IL);
   _ile_plan:=exec('zlec_planned','po_plan',$VAR.A_ZLEC);
   {? _ile_brak>0
   || {? _dialog>0
      || _msg:='Utworzono z planu przewodniki na ilość: %1 %2.\n'
               'Brakuje przewodników na ilość: %3 %4.\n\n'
               'Wygenerować przewodniki na pozostałą ilość?'@
               [form(_ile_plan,,_dokl,'9,'),_jm,form(_ile_brak,,_dokl,'9,'),_jm];
         _ask:=FUN.ask(_msg)
      || _ask:=1
      ?};
      {? _ask>0
      || exec('generuj','zl_guide',_dialog,0,,_grp_key,,,,,0)
      ?}
   ?}
?};

ZGH.cntx_pop();
PL_PART.cntx_pop();
ZL.cntx_pop();
_ilosc


\main_podzlec_zgh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca tabelke tymczasowa zawierającą ilości ze zlecenia montażowego
::   WE: _a - ZL.ref() - zlecenie podrzędne
::   WY: tab_tmp
::  TAG: <PRYWATNA>
::  OLD: \main_podzlec_zgh/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_tab:=tab_tmp(1,
:: 'POLE','TYP','Nazwa w oknie',
   'NRPRZ','STRING[30]','Symbol przewodnika',
   'ZGH_REF','STRING[16]','Ref przewodnika',
   'ILNPRZ','REAL','Ilość na przewodniku',
   'IL_ZL','REAL','Ilość na zleceniu',
   'UID','STRING[15]','Unikalny identyfikator przewodnika'
);
_main_podzlec:=exec('main_podzlec','zl_link',_zl);
{? _main_podzlec<>null()
|| ZL.cntx_psh();
   ZL.prefix();
   {? ZL.seek(_main_podzlec)
   || ZGH.cntx_psh();
      ZGH.index('ZLNR');
      ZGH.prefix(ZL.ref());
      {? ZGH.first()
      || {!
         |?
            _tab.blank();
            _tab.NRPRZ:=ZGH.NRPRZ;
            _tab.ZGH_REF:=$ZGH.ref();
            _tab.ILNPRZ:=ZGH.ILNPRZ;
            _tab.IL_ZL:=ZL.IL;
            _tab.UID:=ZGH.UID;
            _tab.add();
            ZGH.next()
         !}
      ?};
      ZGH.cntx_pop()
   ?};
   ZL.cntx_pop();
   ~~
?};
_tab


\zgh_gen_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła na format wyślwietlania pól zmiennej ZLEC: IL_ZL, IL_ZGH, IL_PART, IL_PART1, IL_PARTP
::   WY: STRING
::  TAG: <MBUILDER>
::  OLD: \zgh_gen_fd/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_dokl:=exec('jaka_dok_m','jm',ZL.KTM);
_result:='out_prec='+$_dokl;
_result


\zgh_gen_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła na format redagowania pól zmiennej ZLEC: IL_ZL, IL_ZGH, IL_PART, IL_PART1, IL_PARTP
::   WY: STRING
::  TAG: <MBUILDER>
::  OLD: \zgh_gen_fe/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_dokl:=exec('jaka_dok_m','jm',ZL.KTM);
_result:='in_prec='+$_dokl;
_result


\part2zgh_smpl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Generuje przewodniki z partii dla zlecenia prostego
::   WE: _a - ZL.ref() - zlecenie proste ktoremu tworze przewodniki
::       [_b] - STRING - klucz grupujący którym stemplować przewodniki
::       [_c] - INTEGER - czy wyświetlać dialogi
::       [_d] - INTEGER - [0]/1 - czy generować od razu zakończone przewodniki
::   WY: REAL - ilosc na jaka zostaly wygenerowane przewodniki z partii
::  TAG: <PUBLIC>
::  OLD: \part2zgh_smpl/zparn.fml
::  OLD: \part2zgh_smpl/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_zlec:=null();
_result:=0;
{? _>0
|| _zlec:=_a
?};
_grp_key:='';
{? var_pres('_b')=type_of('')
|| _grp_key:=_b
?};
_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};
_zakoncz:=0;
{? var_pres('_d')=type_of(0)
|| _zakoncz:=_d
?};

ZL.cntx_psh();
ZPARN.cntx_psh();
ZGH.cntx_psh();
ZGH.index('ZLNR');

ZL.clear();
ZL.index('NRNZL');

ZPARN.clear();
ZPARN.index('ZL');

_ilosc:=0;
:: lece po zleceniach podrzednych i generuje przewodniki zgodnie z partiami
{? _zlec<>null
|| {? ZL.seek(_zlec)
   || _ilosc:=exec('guidgen_proste_part','zl_guide',ZL.ref(),_grp_key,,_zakoncz)
   ?};
   VAR.A_ZLEC:=_zlec;
   _dokl:=ZL.KTM().DOKL;
   _jm:=ZL.KTM().J().KOD;

:: jesli z partii wygenerowalem mniej przewodnikow niz ilosc na zleceniu (bo np nie popartiowalem wszystkiego)
:: to trzeba dogenerowac reszte standardowa metoda
   _ile_brak:=exec('ile','zl_guide',ZL.ref(),ZL.IL);
   _ile_plan:=exec('zl_ile_part','zl_partie',ZL.ref());
   {? _ile_brak>0
   || {? _dialog>0
      || _msg:='Utworzono z partii przewodniki na ilość: %1 %2.\n'
               'Brakuje przewodników na ilość: %3 %4.\n\n'
               'Wygenerować przewodniki na pozostałą ilość?'@
               [form(_ile_plan,,_dokl,'9,'),_jm,form(_ile_brak,,_dokl,'9,'),_jm];
         _ask:=FUN.ask(_msg)
      || _ask:=1
      ?};
      {? _ask>0
      || exec('generuj','zl_guide',_dialog,0,0,_grp_key,,,,,0)
      ?}
   ?}
?};

ZGH.cntx_pop();
ZPARN.cntx_pop();
ZL.cntx_pop();
_ilosc


\guidgen_proste_pl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: [PRIVATE]
::       Tworzy przewodniki do zlecenia prostego
::   WE: _a    - ZL.ref() - zlecenie ktoremu tworze przewodniki
::       [_b] - STRING - klucz grupujący którym stemplować przewodniki
::       [_c] - STRING - identyfikator którym spinać przewodniki dla widoku od strony zlecenia złożonego nadrzędnego
::       [_d] - INTEGER - [0]/1 - czy generować od razu zakończone przewodniki
::   WY: REAL - ilosc na jaka utworzylem przewodniki
::  OLD: \guidgen_proste/pl_okr3.fml
::  OLD: \guidgen_proste_pl/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_zlec:=null();
_zgh:=null();
_result:=0;
{? _>0
|| _zlec:=_a
?};
_grp_key:='';
{? var_pres('_b')=type_of('')
|| _grp_key:=_b
?};
_uid_view:='';
{? var_pres('_c')=type_of('')
|| _uid_view:=_c
?};
_zakoncz:=0;
{? var_pres('_d')=type_of(0)
|| _zakoncz:=_d
?};

ZL.cntx_psh();
PL_PART.cntx_psh();
ZGH.cntx_psh();

ZL.clear();
PL_PART.clear();

PL_PART.index('ZL');

{? ZL.seek(_zlec)
|| PL_PART.prefix(ZL.ref());
   {? PL_PART.first()
   ||
      {!
      |?
::       sprawdzam czy przypadkiem nie ma juz przewodnika zlecenia powiazanego z tym plpartem
         {? PL_PART.ZGH=null()
         ||
            {? var_pres('zgh')>0
            || obj_del(zgh)
            ?};
            zgh:=obj_new(1);
            _sym_p:='';
::          ilosc na przewodniku, obcinam ulamki jakby co zeby na przewodnikach nie wyszlo wiecej niz na zleceniu
            _il_p:=PL_PART.ILOSC#0;
            VAR.A_ZLEC:=ZL.ref();
            exec('gen_przh_obj_pl','zl_guide');
            _sym_p:=exec('add_zgh','zl_guide',_il_p,,,,,,PL_PART.ref(),_grp_key,_uid_view,,_zakoncz);
            exec('del_przh_obj','zl_guide');
::          robie uaktualnienie dat na zleceniu, przewodniku i pozycjach przewodnika i lacze plparta z zgh i plopera z zgp
            exec('zl_dates_update','po_plan',_zlec);
            exec('zgh_dates_upd','po_plan',PL_PART.ref());
            _result+=_il_p
         ?};
         PL_PART.next()
      !};
::    Uaktualniam przepis planistyczny zlecenia
      {? _result>0
      || {? _zlec<>null()
         || exec('zl_tex_update','px_tex',_zlec)
         ?}
      ?}
   ?}
?};
{? var_pres('zgh')>0
|| obj_del(zgh)
?};
PL_PART.cntx_pop();
ZL.cntx_pop();
ZGH.cntx_pop();
_result


\guidgen_proste_part
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Tworzy przewodniki do zlecenia prostego na podstawie partii
::   WE: _a    - ZL.ref() - zlecenie ktoremu tworze przewodniki
::       [_b] - STRING - klucz grupujący którym stemplować przewodniki
::       [_c] - STRING - identyfikator którym spinać przewodniki dla widoku od strony zlecenia złożonego nadrzędnego
::       [_d] - INTEGER - [0]/1 - czy generować od razu zakończone przewodniki
::   WY: REAL - ilosc na jaka utworzylem przewodniki
::  TAG: <PRIVATE>
::  OLD: \guidgen_proste/zparn.fml
::  OLD: \guidgen_proste_part/!tte_pzl_dpzg.fml
::----------------------------------------------------------------------------------------------------------------------
_zlec:=_a;
_grp_key:='';
{? var_pres('_b')=type_of('')
|| _grp_key:=_b
?};
_uid_view:='';
{? var_pres('_c')=type_of('')
|| _uid_view:=_c
?};
_zakoncz:=0;
{? var_pres('_d')=type_of(0)
|| _zakoncz:=_d
?};

_result:=0;

ZL.cntx_psh();
ZPARN.cntx_psh();
ZGH.cntx_psh();

ZL.clear();
ZPARN.clear();

ZPARN.index('ZL');

{? ZL.seek(_zlec)
|| ZPARN.prefix(ZL.ref());
   {? ZPARN.first()
   ||
      {!
      |?
::       sprawdzam czy przypadkiem nie ma juz przewodnika zlecenia powiazanego z ta partia
         {? ZPARN.ZGH=null()
         ||
            {? var_pres('zgh')>0
            || obj_del(zgh)
            ?};
            zgh:=obj_new(1);
            _sym_p:='';
::          ilosc na przewodniku
            _il_p:=ZPARN.IL;
            VAR.A_ZLEC:=ZL.ref();
            exec('gen_przh_obj','zl_guide');
            _sym_p:=exec('add_zgh','zl_guide',_il_p,,,,,0,,_grp_key,_uid_view,,_zakoncz);
            exec('del_przh_obj','zl_guide');
::          lacze partie z przewodnikiem
            {? _sym_p<>''
            || exec('tie2zgh','zl_partie',ZPARN.ref(),_sym_p);
               _result+=_il_p
            ?}
         ?};
         ZPARN.next()
      !};
::    Uaktualniam przepis planistyczny zlecenia
      {? _result>0
      || {? _zlec<>null()
         || exec('zl_tex_update','px_tex',_zlec)
         ?}
      ?}
   ?}
?};
{? var_pres('zgh')>0
|| obj_del(zgh)
?};
ZPARN.cntx_pop();
ZL.cntx_pop();
ZGH.cntx_pop();
_result


\gendom_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2006]
:: OPIS: Generuje domyślną strukturę następników dla zlecenia.
::       Zakładamy, że generowanie domyślnej struktury rozpoczynamy od zlecenia nadrzędnego.
::       Wiązanie pozycji przewodników następuje tylko dla przewodników powiązanych podczas generowania
::       oraz gdy została zachowana proporcja współczynników korygujących zlecenia w strukturze
::       Kontekst wywołania - zmienna VAR.A_ZLEC
::   WE: [_a] - STRING - [T]/N - czy wyświetlać dialogi
::       [_b] - INTEGER 0/[1] - czy blokować przewodniki na czas działania
::   WY: Wynik generowania: 0 / 1
::  OLD: \gendom_zl/zl_guid.fml
::  OLD: \gendom_zl/!tte_pzl_dgnz.fml
::----------------------------------------------------------------------------------------------------------------------
_dialog:='T';
{? var_pres('_a')=type_of('')
|| _dialog:=_a
?};

_blk:=1;
{? var_pres('_b')=type_of(0)
|| _blk:=_b
?};

_result:=1;
_can_continue:=1;

:: struktury robocze
VAR_DEL.delete('__NAST','__SUR','__POP');
__NAST:=tab_tmp_out_tr(2,
   'ZGP','INTEGER','#ZGP.ref()',
   'ZL','INTEGER','#ZL.ref()',
   'ZGHZGP','STRING[50]','ZGH.NRPRZ+$ZGP.NRP',
   'ZL_SYM','STRING[50]','ZL.SYM'
);
__SUR:=tab_tmp_out_tr(2,
   'ZGP','INTEGER','#ZGP.ref()',
   'M','INTEGER','#M.ref()',
   'ZGHZGP','STRING[50]','ZGH.NRPRZ+$ZGP.NRP',
   'M_KTM','STRING[50]','M.KTM',
   'TOPER','REAL','TOPER.UNROP'
);
__POP:=tab_tmp_out_tr(2,
   'ZGP','INTEGER','#ZGP.ref()',
   'ZL','INTEGER','#ZL.ref()',
   'ZGHZGP','STRING[50]','ZGH.NRPRZ+$ZGP.NRP',
   'ZL_SYM','STRING[50]','ZL.SYM'
);

_zl_main:=exec('main_podzlec','zl_link',VAR.A_ZLEC);

{? _blk>0
||
:: Najpierw blokowanie wszystkich przewodników
   _locked:=exec('ref_table','#table');
   ZGH.index('ZLNR');
   ZGH.prefix(_zl_main);
   {? ZGH.first()
   || {!
      |? {? exec('blk_lock','#table','ZGH',ZGH.ref())>0
         || _locked.add(ZGH.ref())
         || _can_continue:=0;
            _msg:='Przewodnik %1 zablokowany, funkcji nie można kontynuować.'@[ZGH.NRPRZ];
            {? _dialog='T'
            || FUN.emsg(_msg)
            |? _dialog='N'
            || KOMM.add(_msg,2)
            ?}
         ?};
         ZGH.next() & _can_continue>0
      !}
   ?}
?};

{? _can_continue>0
||
   _mydo:=do_state()=0;
   {? _mydo || do() ?};

:: kasowanie powiązań - bieżący rekord ZL dotyczy zlecenia nadrzędnego
   exec('erase_str','zl_guide',VAR.A_ZLEC);

   Cntx.psh(ZL,ZGH);

:: produkt zlecenia
   _ktm:=VAR.A_ZLEC().KTM;

:: Sprawdzenie współczynnika korekty - jeżeli różny, to powiązania nie są odtwarzane
   {? exec('kor_coef_equal','zl_head',VAR.A_ZLEC)
   ||
::    przetwarzane są przewodniki zlecenia montażowego
      ZGH.index('ZLNR');
      ZGH.prefix(_zl_main);
      {? ZGH.first()
      || {!
         |?
::          czyszczenie struktur roboczych
::          __NAST.erase();
            __NAST.prefix(); {? __NAST.first() || {! |? __NAST.del() !} ?};
::          __SUR.erase();
            __SUR.prefix(); {? __SUR.first() || {! |? __SUR.del() !} ?};
::          __POP.erase();
            __POP.prefix(); {? __POP.first() || {! |? __POP.del() !} ?};

::          na początek pierwszy poziom
            _level:=1;
            ZL.index('NRNZL');
            ZL.prefix(VAR.A_ZLEC().UNRZL,_level);
            {? ZL.first()
            || {!
               |? {? ZL.KTM=_ktm
                  || exec('nast_tab','zl_guide',ZL.ref(),ZGH.UID)
                  || exec('prev_tab','zl_guide',ZL.ref(),ZGH.UID)
                  ?};
                  ZL.next()
               !};
               exec('join_tab','zl_guide');
               exec('next_lev','zl_guide',_level+1,ZGH.UID)
            ?};
            _result:={? do_state()=2 || 0 || 1 ?};
            ZGH.next() & _result>0
         !}
      ?}
   ?};

   {? _result>0
   ||
::    Odtworzenie statusów pozycji przewodników
      ZL.index('NRNZL');
      ZL.prefix(VAR.A_ZLEC().UNRZL);
      {? ZL.first()
      || {!
         |? ZGH.index('ZLNR');
            ZGH.prefix(ZL.ref());
            {? ZGH.first()
            || {!
               |? exec('recover_sta_zgh','zl_guide',ZGH.ref());
                  ZGH.next()
               !}
            ?};
            ZL.next()
         !}
      ?};

      exec('FindAndGet','#table',ZL,VAR.A_ZLEC,,"INTERZL:='T'; put()")
   ?};

   Cntx.pop(ZL,ZGH);
   {? _mydo || end() ?};
   ~~
?};

{? _blk>0
||
:: Odblokowuje wszystkie zablokowane
   _tab:=_locked.tab;
   _tab.prefix();
   {? _tab.first()
   || {!
      |? _zgh:=exec('FindAndGet','#table',ZGH,_tab.SQL,,,null());
          exec('blk_unlock','#table','ZGH',_zgh);
         _tab.next()
      !}
   ?}
?};

VAR_DEL.delete('__NAST','__SUR','__POP');
{? _can_continue=0
|| _result:=0
?};
_result


\erase_str
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2006]
:: OPIS: Kasuje strukturę następników łączącą pozycje przewodników różnych zleceń
::   WE: _a - ZL.ref()
::  OLD: \erase_str/zl_guid.fml
::  OLD: \erase_str/!tte_pzl_dgnz.fml
::----------------------------------------------------------------------------------------------------------------------
_strer:=exec('interzlec','zl_guide',_a);

{? type_of(_strer)=type_of(~~) || return() ?};

NASZGP.cntx_psh();
NASZGP.prefix();
{? _strer.first()
|| {!
   |? {? NASZGP.seek(_strer.REF)
      || NASZGP.del()
      ?};
      _strer.next()
   !}
?};
NASZGP.cntx_pop();
~~


\nast_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2006]
:: OPIS: Wypełnia tebelę nastepników
::   WE: _a - ZL.ref()
::       _b - ZGH.UID przewodnika zlecenia montażowego
::  OLD: \nast_tab/zl_guid.fml
::  OLD: \nast_tab/!tte_pzl_dgnz.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_uid:=_b;

Cntx.psh(ZL,ZGH,ZGP,NASZGP,TOPER);

ZGH.index('ZLNR');
ZGH.prefix(_zl);
{? ZGH.first()
|| {!
   |? ZGP.index('PNRPP');
      ZGP.prefix(ZGH.ref());
      {? ZGP.first()
      || {!
         |?
::          szukamy bez poprzednikow, tylko operacje główne wskazanego przewodnika nadrzędnego
            {? ZGP.TPZ='N'
                  &
               ((ZGP.NRZLP().UID_SRC='' & ~exec('is_main_podzlec','zl_link',ZGP.ZL))
                    |
                 ZGP.NRZLP().UID_SRC=_uid
                    |
                 ZGP.NRZLP().UID=_uid
               )
            ||

::             Dla operacji z surowcami wszystkie operacje (teraz zawsze ta ścieżka)
               _sur:='';
::               {? ZGP.RTOPER<>''
::               || _tktl:=exec('FindAndGet','#table',TOPER,ZGP.RTOPER,,"NRK",null());
::                  _sur:=exec('FindAndGet','#table',TKTL,$_tktl,,"TYP().SUR")
::               ?};
               {? 1
::                  _sur='O'
               || __NAST.ZGP:=#ZGP.ref();
                  __NAST.ZL:=#_zl;
                  __NAST.ZGHZGP:=ZGH.NRPRZ+' '+$ZGP.NRP;
                  __NAST.ZL_SYM:=ZGH.ZLEC().SYM;
                  __NAST.prefix();
                  {? __NAST.add()
                  || exec('add_sur_nast','zl_guide',ZGP.ref());
::                   Dodatkowe przetworzenie dla surowców bez operacji (z reguly tylko dla pierwszej)
                     NASZGP.index('UNROP');
                     NASZGP.prefix(_zl,ZGP.ref(),_zl);
                     {? ~NASZGP.first()
                     || __NAST.prefix();
                        exec('add_sur_all','zl_guide',_zl,ZGP.ref())
                     ?}
                  ?}
               ||
::                Dla operacji bez surowcow tylko ta bez powiazan (z reguly pierwsza)
                  NASZGP.index('UNROP');
                  NASZGP.prefix(_zl,ZGP.ref(),_zl);
                  {? ~NASZGP.first()
                  || __NAST.ZGP:=#ZGP.ref();
                     __NAST.ZL:=#_zl;
                     __NAST.ZGHZGP:=ZGH.NRPRZ+' '+$ZGP.NRP;
                     __NAST.ZL_SYM:=ZGH.ZLEC().SYM;
                     __NAST.prefix();
                     {? __NAST.add() || exec('add_sur_all','zl_guide',_zl,ZGP.ref()) ?}
                  ?}
               ?}
            ?};
            ZGP.next()
         !}
      ?};
      ZGH.next()
   !}
?};

Cntx.pop(ZL,ZGH,ZGP,NASZGP,TOPER);
~~


\prev_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2006]
:: OPIS: Wypełnia tebelę poprzedników
::   WE: _a - ZL.ref()
::       _b - ZGH.UID przewodnika zlecenia montażowego
::  OLD: \prev_tab/zl_guid.fml
::  OLD: \prev_tab/!tte_pzl_dgnz.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_uid:=_b;

Cntx.psh(ZL,ZGH,ZGP,NASZGP);

ZGH.index('ZLNR');
ZGH.prefix(_zl);
{? ZGH.first()
|| {!
   |? ZGP.index('PNRPP');
      ZGP.prefix(ZGH.ref());
      {? ZGP.last()
      || {!
         |?
::          szukamy bez następników, tylko operacje glowne wskazanego przewodnika nadrzednego
            {? ZGP.TPZ='N'
                  &
               (ZGP.NRZLP().UID_SRC=''
                   |
                ZGP.NRZLP().UID_SRC=_uid
                   |
                ZGP.NRZLP().UID=_uid
               )
            ||
               NASZGP.index('OPER');
               NASZGP.prefix(_zl,ZGP.ref(),_zl);
               {? ~NASZGP.first()
               || __POP.ZGP:=#ZGP.ref();
                  __POP.ZL:=#_zl;
                  __POP.ZGHZGP:=ZGH.NRPRZ+' '+$ZGP.NRP;
                  __POP.ZL_SYM:=ZGH.ZLEC().SYM;
                  __POP.prefix();
                  __POP.add()
               ?}
            ?};
            ZGP.prev()
         !}
      ?};
      ZGH.next()
   !}
?};

Cntx.pop(ZL,ZGH,ZGP,NASZGP);
~~


\add_sur_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wypelnia pomocnicza tabele __SUR surowcami (polfabrykatami) powiazanymi z pozycja przewodnika
::   WE: _a - ZGP.ref() (nie badamy wystapienia i typu agrumentu)
::  OLD: \add_sur_nast/zl_guid.fml
::  OLD: \add_sur_nast/!tte_pzl_dgnz.fml
::----------------------------------------------------------------------------------------------------------------------
ZGP.cntx_psh();
ZGP.clear();

{? ZGP.seek(_a)
|| __SUR.clear();
   {? ZGP.TOPER<>null()
   || TMAT.index('ANNL');
      _tktl:=exec('FindAndGet','#table',TOPER,ZGP.RTOPER,,"NRK",null());
      TMAT.prefix('T',_tktl,ZGP.TOPER);
      {? TMAT.first()
      || {!
         |? __SUR.ZGP:=#ZGP.ref();
            __SUR.M:={? TMAT.GRKTM='G' || #TMAT.TGDFLT().PT || #TMAT.PT ?};
            __SUR.ZGHZGP:=ZGP.NRZLP().NRPRZ+' '+$ZGP.NRP;
            __SUR.M_KTM:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT().KTM || TMAT.PT().KTM ?};
            __SUR.TOPER:=ZGP.TOPER().UNROP;
            __SUR.add();
            TMAT.next()
         !}
      ?}
   ?}
?};

ZGP.cntx_pop();
~~


\add_sur_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wypelnia pomocnicza tabele __SUR surowcami (polfabrykatami) powiazanymi ze zleceniem
::   WE: _a - ZL.ref()
::       _b - ZGP.ref(), do ktorego przypisac liste
::       (nie badamy wystapienia i typow agrumentow)
::  OLD: \add_sur_all/zl_guid.fml
::  OLD: \add_sur_all/!tte_pzl_dgnz.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
ZL.clear();

{? ZL.seek(_a)
|| __SUR.clear();
   {? ZL.TYP().TECH='T'
   || TMAT.index('ANNL');
      TMAT.prefix('T',ZL.TKTL,null());
      {? TMAT.first()
      || {!
         |? __SUR.ZGP:=#_b;
            __SUR.M:={? TMAT.GRKTM='G' || #TMAT.TGDFLT().PT || #TMAT.PT ?};
            __SUR.ZGHZGP:=ZGP.NRZLP().NRPRZ+' '+$ZGP.NRP;
            __SUR.M_KTM:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT().KTM || TMAT.PT().KTM ?};
            __SUR.TOPER:=0;
            __SUR.add();
            TMAT.next()
         !}
      ?}
   || TMAT.index('ANNL');
      TMAT.prefix('T',ZL.KTL,null());
      {? TMAT.first()
      || {!
         |? __SUR.ZGP:=#_b;
            __SUR.M:={? TMAT.GRKTM='G' || #TMAT.TGDFLT().PT || #TMAT.PT ?};
            __SUR.ZGHZGP:=ZGP.NRZLP().NRPRZ+' '+$ZGP.NRP;
            __SUR.M_KTM:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT().KTM || TMAT.PT().KTM ?};
            __SUR.TOPER:=0;
            __SUR.add();
            TMAT.next()
         !}
      ?}
   ?}
?};

ZL.cntx_pop();
~~


\join_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2006]
:: OPIS: Łączy odpowiednie dane z tabeli poprzedników z tabelą nastepników
::       Praca w kontekście wygenerowanych tabel __NAST, __SUR, __POP
::  OLD: \join_tab/zl_guid.fml
::  OLD: \join_tab/!tte_pzl_dgnz.fml
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(ZL,ZGH,ZGP,NASZGP);
Cntx.clr(ZL,ZGH,ZGP,NASZGP);

__NAST.clear();
::exec('select','#table',__NAST,,,'następniki');
__SUR.clear();
::exec('select','#table',__SUR,,,'surowce');
__POP.clear();
::exec('select','#table',__POP,,,'poprzedniki');

{? __NAST.first()
|| {!
   |? __POP.prefix();
      {? __POP.first()
      || {!
         |? _ok:=1;

            {? ZL.seek(__NAST.ZL,'zlec_akt')
            || _zlnas:=ZL.ref()
            || _ok:=0
            ?};
            {? _ok & ZL.seek(__POP.ZL,'zlec_akt')
            || _zlpop:=ZL.ref()
            || _ok:=0
            ?};
            {? _ok & ZGP.seek(__POP.ZGP,'zguidep')
            || _zgpop:=ZGP.ref()
            || _ok:=0
            ?};
            {? _ok & ZGP.seek(__NAST.ZGP,'zguidep')
            || _zgpnas:=ZGP.ref(); _sciezka:=$(ZGP.NRP)
            || _ok:=0
            ?};

            {? _ok
            || __SUR.prefix(_zgpnas);
               _ok:=0;
               {? __SUR.first()
               || {!
                  |?
                     {? __SUR.TOPER=0
                     || {? #ZL.KTM=__SUR.M || _ok:=1 ?};
                        __SUR.next()
                     || {? #ZL.KTM=__SUR.M & __SUR.TOPER=ZL.TMAT_SRC().NROP().UNROP
                        || _ok:=1
                        ?};
                        __SUR.next()
                     ?}
                  !}
               ?}
            ?};

            {? _ok
            || NASZGP.clear();
               NASZGP.KTL:=_zlpop;
               NASZGP.OPER:=_zgpop;
               NASZGP.ZLNAST:=_zlnas;
               NASZGP.NRNAST:=_zgpnas;
               NASZGP.SCIEZKA:=_sciezka;
               _can_continue:=NASZGP.add(1);
               {? _can_continue>0
               || exec('pl_next_update','po_plan',NASZGP.OPER)
               ?}
            ?};
            __POP.next()
         !}
      ?};
      __NAST.next()
   !}
?};

Cntx.pop(ZL,ZGH,ZGP,NASZGP);
~~


\next_lev
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2006]
:: OPIS: Generuje domyślną strukturę następników dla zleceń znajdujacych się poziom niżej.
::   WE: _a - numer poziomu
::       _b - ZGH.UID przewodnika zlecenia montażowego
::  OLD: \next_lev/zl_guid.fml
::  OLD: \next_lev/!tte_pzl_dgnz.fml
::----------------------------------------------------------------------------------------------------------------------
_level:=_a;
_uid:=_b;

ZL.index('NRNZL');
ZL.prefix(VAR.A_ZLEC().UNRZL,_level);
{? ZL.first()
|| {!
   |?
::    czyszczenie struktur roboczych
::      __NAST.erase();
      __NAST.prefix(); {? __NAST.first() || {! |? __NAST.del() !} ?};
::      __SUR.erase();
      __SUR.prefix(); {? __SUR.first() || {! |? __SUR.del() !} ?};
::      __POP.erase();
      __POP.prefix(); {? __POP.first() || {! |? __POP.del() !} ?};

      _nrpzl:=ZL.NRPZL;
      _zlp:=ZL.ref();
      ZL.cntx_psh();
      ZL.index('UNRZL');
      ZL.prefix(_nrpzl);
      {? ZL.first()
      || exec('nast_tab','zl_guide',ZL.ref(),_uid);
         exec('prev_tab','zl_guide',_zlp,_uid);
         exec('join_tab','zl_guide')
      ?};
      ZL.cntx_pop();
      ZL.next()
   !};
   exec('next_lev','zl_guide',_level+1,_uid)
?};
ZL.clear();
~~


\spr_tpz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.42]
:: OPIS: Sprawdza, czy są czasy Tpz zarejestrowane na jakiejkolwiek operacji przewodnika
::   WE: _a - ZGH.ref()
::   WY: 0 - brak rejestracji, 1 - są rejestracje
::----------------------------------------------------------------------------------------------------------------------
_zgh:=_a;

_result:=0;

ZL.cntx_psh();
ZGH.cntx_psh(); ZGH.prefix();
ZGP.cntx_psh(); ZGP.index('PNRPP');
ZLGD.cntx_psh();

{? ZGH.seek(_zgh)
||
   _name:=5+ZLGD.name();
   _msk_start:=_name+ZGH.ZLEC().ODDZ+(2-$(ZL.OD~1));
   _msk_end:=~~;

   _rule:="
      _args:=_b;
      ZLGD.index('S2');
      ZLGD.prefix(_args.ZGP);
      {? ZLGD.first() || _args.RESULT:=1 ?}
   ";
   _args:=obj_new('ZGP','RESULT');
   ZGP.prefix(_zgh,'T');
   {? ZGP.first()
   || {!
      |? _args.ZGP:=ZGP.ref(); _args.RESULT:=0;
         exec('for_each_mask','#table',ZLGD,_rule,_msk_start,_msk_end,_args);
         _result:=_args.RESULT;
         _result=0 & ZGP.next()
      !}
   ?}
?};

ZLGD.cntx_pop();
ZGP.cntx_pop();
ZGH.cntx_pop();
ZL.cntx_pop();

_result


\zgh_has_plgrp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Sprawdza, czy przewodnik ma operację z ustawionym grupowym planowaniem (ZGP.PL_GRP)
::   WE: _a - ZGH.ref()
::   WY: 1 - ma, 0 - nie ma operacji planowanych grupowo
::----------------------------------------------------------------------------------------------------------------------
_zgh:=_a;

_result:=0;

ZGP.cntx_psh();
ZGP.index('NRPRZ');
ZGP.prefix(_zgh);
{? ZGP.first()
|| {!
   |? {? ZGP.PL_GRP='T' || _result:=1 ?};
      _result=0 & ZGP.next()
   !}
?};
ZGP.cntx_pop();

_result


\get_tpz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Zwraca czas TPZ dla podanego ZGPa
::   WE: [_a] - ZGP.ref lub bieżący rekord
::   WY: REAL
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
{? _ref<>null()
|| ZGP.prefix();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| ZGP.cntx_psh();
   ZGP.index('TPZ');
   ZGP.prefix('T',ZGP.UID);
   {? ZGP.first()
   || _result:=ZGP.NTIME
   ?};
   ZGP.cntx_pop()
?};
ZGP.cntx_pop();
_result


\plug2zgh_smpl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.14]
:: OPIS: Generuje przewodniki na podstawie wtyczki dla zlecenia prostego
::   WE: _a - ZL.ref() - zlecenie proste ktoremu tworze przewodniki
::       [_b] - STRING - klucz grupujący którym stemplować przewodniki
::       [_c] - INTEGER - czy wyświetlać dialogi
::       [_d] - INTEGER - [0]/1 - czy generować od razu zakończone przewodniki
::       _e - tablica z podziałem przewodnika
::   WY: REAL - ilosc na jaka zostaly wygenerowane przewodniki z wtyczki
::----------------------------------------------------------------------------------------------------------------------
_zlec:=null();
_result:=0;
{? _>0
|| _zlec:=_a
?};
_grp_key:='';
{? var_pres('_b')=type_of('')
|| _grp_key:=_b
?};
_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};
_zakoncz:=0;
{? var_pres('_d')=type_of(0)
|| _zakoncz:=_d
?};
_tab:=_e;

ZL.cntx_psh();
ZGH.cntx_psh();
ZGH.index('ZLNR');

ZL.clear();
ZL.index('NRNZL');

_ilosc:=0;
:: lece po zleceniach podrzednych i generuje przewodniki zgodnie z partiami
{? _zlec<>null()
|| {? ZL.seek(_zlec)
   || _ilosc:=exec('guidgen_proste_plug','zl_guide',ZL.ref(),_grp_key,,_zakoncz,_tab)
   ?};
   VAR.A_ZLEC:=_zlec;
   _dokl:=ZL.KTM().DOKL;
   _jm:=ZL.KTM().J().KOD;

:: jesli z wtyczki wygenerowalem mniej przewodnikow niz ilosc na zleceniu (bo np nie rozpisano wszystkiego)
:: to trzeba dogenerowac reszte standardowa metoda
   _ile_brak:=exec('ile','zl_guide',ZL.ref(),ZL.IL);
   {? _ile_brak>0
   || {? _dialog>0
      || _msg:='Do zlecenia utworzono na podstawie wtyczki wdrożeniowej przewodniki na ilość: %1 %2.\n'
               'Brakuje przewodników na ilość: %3 %4.\n\n'
               'Wygenerować przewodniki na pozostałą ilość?'@
               [form(_ilosc,,_dokl,'9,'),_jm,form(_ile_brak,,_dokl,'9,'),_jm];
         _ask:=FUN.ask(_msg)
      || _ask:=1
      ?};
      {? _ask>0
      || exec('generuj','zl_guide',_dialog,0,0,_grp_key,,_zakoncz,,,0)
      ?}
   ?}
?};

ZGH.cntx_pop();
ZL.cntx_pop();
_ilosc


\plug2zgh_smpl2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.14]
:: OPIS: Generuje przewodniki na podstawie wtyczki dla zlecenia podrzednego
::   WE: _a - ZL.ref() - zlecenie proste ktoremu tworze przewodniki
::       [_b] - STRING - klucz grupujący którym stemplować przewodniki
::       [_c] - STRING - identyfikator którym spinać przewodniki dla widoku od strony zlecenia złożonego nadrzędnego
::       [_d] - INTEGER - czy wyświetlać dialogi
::       [_e] - INTEGER - [0]/1 - czy generować od razu zakończone przewodniki
::       _f - tablica z podziałem przewodnika
::   WY: REAL - ilosc na jaka zostaly wygenerowane przewodniki z wtyczki
::----------------------------------------------------------------------------------------------------------------------
_zlec:=null();
_result:=0;
{? _>0
|| _zlec:=_a
?};
_grp_key:='';
{? var_pres('_b')=type_of('')
|| _grp_key:=_b
?};
_uid_view:='';
{? var_pres('_c')=type_of('')
|| _uid_view:=_c
?};
_dialog:=1;
{? var_pres('_d')=type_of(0)
|| _dialog:=_d
?};
_zakoncz:=0;
{? var_pres('_e')=type_of(0)
|| _zakoncz:=_e
?};
_tab:=_f;

ZL.cntx_psh();
ZGH.cntx_psh();
ZGH.index('ZLNR');

ZL.clear();
ZL.index('NRNZL');

_ilosc:=0;
:: lece po zleceniach podrzednych i generuje przewodniki zgodnie z wtyczką
{? _zlec<>null()
|| {? ZL.seek(_zlec)
   || _ilosc:=exec('guidgen_proste_plug','zl_guide',ZL.ref(),_grp_key,_uid_view,_zakoncz,_tab)
   ?};
   VAR.A_ZLEC:=_zlec;
   _dokl:=ZL.KTM().DOKL;
   _jm:=ZL.KTM().J().KOD;

:: jesli z wtyczki wygenerowalem mniej przewodnikow niz ilosc na zleceniu (bo np nie rozpisano wszystkiego)
:: to trzeba dogenerowac reszte standardowa metoda
   _ile_brak:=exec('ile','zl_guide',ZL.ref(),ZL.IL);
   _il_sum:=exec('array_sum','#array',_tab);
   {? _ile_brak>0
   || {? _dialog>0
      || _msg:='Do zlecenia utworzono na podstawie wtyczki wdrożeniowej przewodniki na ilość: %1 %2.\n'
               'Brakuje przewodników na ilość: %3 %4.\n\n'
               'Wygenerować przewodniki na pozostałą ilość?'@
               [form(_il_sum,,_dokl,'9,'),_jm,form(_ile_brak,,_dokl,'9,'),_jm];
         _ask:=FUN.ask(_msg)
      || _ask:=1
      ?};
      {? _ask>0
      || exec('generuj','zl_guide',_dialog,0,0,_grp_key,_uid_view,,,,0)
      ?}
   ?}
?};

ZGH.cntx_pop();
ZL.cntx_pop();
_ilosc


\guidgen_proste_plug
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.14]
:: OPIS: Tworzy przewodniki do zlecenia prostego na podstawie wtyczki wdrożeniowej
::   WE: _a   - ZL.ref() - zlecenie ktoremu tworze przewodniki
::       [_b] - STRING - klucz grupujący którym stemplować przewodniki
::       [_c] - STRING - identyfikator którym spinać przewodniki dla widoku od strony zlecenia złożonego nadrzędnego
::       [_d] - INTEGER - [0]/1 - czy generować od razu zakończone przewodniki
::       _e - tablica z podziałem przewodnika
::   WY: REAL - ilosc na jaka utworzylem przewodniki
::----------------------------------------------------------------------------------------------------------------------
_zlec:=_a;
_grp_key:='';
{? var_pres('_b')=type_of('')
|| _grp_key:=_b
?};
_uid_view:='';
{? var_pres('_c')=type_of('')
|| _uid_view:=_c
?};
_zakoncz:=0;
{? var_pres('_d')=type_of(0)
|| _zakoncz:=_d
?};
{? var_pres('_e')>100
|| _tab:=_e
|| return(0)
?};

_result:=0;

ZL.cntx_psh();
ZGH.cntx_psh();

ZL.clear();

ZPARN.index('ZL');

{? ZL.seek(_zlec)
|| _ile_brak:=exec('ile','zl_guide',ZL.ref(),ZL.IL);
   _len:=obj_len(_tab);
   _wolne:=exec('wolne_numery','zl_guide',ZL.ref());
   _it:=0;
   {!
   |? _it+=1;
      _wolne-=1;
      {? var_pres('zgh')>0
      || obj_del(zgh)
      ?};
      zgh:=obj_new(1);
      _sym_p:='';
::    ilosc na przewodniku
      _il_p:={? _tab[_it]>_ile_brak || _ile_brak || _tab[_it] ?};
      _ile_brak-=_tab[_it];
      {? _il_p>0
      || _result+=_il_p;
         VAR.A_ZLEC:=ZL.ref();
         exec('gen_przh_obj','zl_guide');
         _sym_p:=exec('add_zgh','zl_guide',_il_p,,,,,0,,_grp_key,_uid_view,,_zakoncz);
         exec('del_przh_obj','zl_guide')
      ?};
      _it<_len & _ile_brak>0 & _wolne>0
   !};
:: Uaktualniam przepis planistyczny zlecenia
   {? _result>0
   || {? _zlec<>null()
      || exec('zl_tex_update','px_tex',_zlec)
      ?}
   ?}
?};
{? var_pres('zgh')>0
|| obj_del(zgh)
?};
ZL.cntx_pop();
ZGH.cntx_pop();
_result


\party_first_zgh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Zwraca pierwszy przewodnik wyższego lub bieżącego poziomu na którym powstają partie
::   WE: [_a] - ZGH.ref - przewodnik lub bieżący rekord
::   WY: ZGH.ref lub null
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGH.ref())
|| _ref:=_a
?};
_result:=null();
_can_continue:=1;

ZGH.cntx_psh();
{? _ref<>null()
|| ZGH.prefix();
   {? ZGH.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _top_src:=ZGH.UID_SRC;
   {? _top_src<>''
   ||
::    Jeżeli przekazany przewodnik jest potomny względem montażowego to prefiksuje przewodniki tym montażowym na zleceniu
::    z partiami
      _party_zl:=exec('party_first','zl_link',ZGH.ZLEC);
      {? _party_zl<>null()
      || ZGH.cntx_psh();
         ZGH.index('UID_SRC');
         ZGH.prefix(_top_src,_party_zl);
         {? ZGH.first()
         || _result:=ZGH.ref()
         ?};

         {? _result=null()
         ||
::          Jeśli nie znalazłem poziom wyżej, to zmieniam indeks tak żeby sprawdzić też na zleceniu montażowym
            ZGH.index('UID');
            ZGH.prefix(_top_src,_party_zl);
            {? ZGH.first()
            || _result:=ZGH.ref()
            ?}
         ?};

         ZGH.cntx_pop()
      ?}
   ||
::    Jeżeli przekazany przewodnik nie jest potomny to sprawdzam czy jego zlecenie jest partiowane
      _party_zl:=exec('zlec_party','zl_common',ZGH.ZLEC);
      {? _party_zl>0
      || _result:=ZGH.ref()
      ?}
   ?}
?};
ZGH.cntx_pop();
_result


\ilosc_left
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Zwraca ilość do zaraportowania na przewodniku
::   WE: [_a] - ZGP.ref lub bieżący rekord
::       _b - STRING - wartiant: 'M' - magazynowy, 'W' - robocizna
::   WY: REAL
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};
_wariant:=_b;

_result:=0;
_can_continue:=1;
ZGP.cntx_psh();
ZGH.cntx_psh();
{? _ref<>null()
|| ZGP.prefix();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? _wariant='M'
   ||
      ZGP.NRPRZ();
      _zgh_il:=ZGH.ILNPRZ;
      _args:=exec('ilosc_dk_a','zl_common');
      _args.ZGH:=ZGH.ref();
      _args.ZL:=ZGH.ZLEC;

      _args.RP:=1;
      _zgh_rp:=exec('get_ilosc_dk','zl_common',_args);

      _args.RP:=0;
      _args.ZP:=1;
      _zgh_zp:=exec('get_ilosc_dk','zl_common',_args);

      _bilans:=_zgh_rp;
      {? _zgh_rp>0
      || _bilans:=_zgh_rp-_zgh_zp;
         _bilans:=exec('max','#math',0,_bilans)
      ?};

      _result:=(_zgh_il-_bilans);
      _result:=exec('max','#math',0,_result)
   |? _wariant='W'
   || _result:=exec('ilegen','magdok_prod',null(),'ZGP').ilegen
   ?}
?};
ZGP.cntx_pop();
ZGH.cntx_pop();
_result


\first_not_completed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Zwraca pierwszy przewodnik na którym zostało coś jeszcze do wykonania
::   WE: _a - ZL.ref
::       _b - STRING - wartiant: 'M' - magazynowy, 'W' - robocizna
::       [_c] - ZGH.ref
::   WY: ZGP.ref lub null
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_wariant:=_b;
_zgh:=null();
{? var_pres('_c')=type_of(ZGH.ref())
|| _zgh:=_c
?};

_result:=null();

ZGP.cntx_psh();
{? _zgh<>null()
|| ZGP.index('NRPRZ');
   ZGP.prefix(_zgh)
|| ZGP.index('ZLEC');
   ZGP.prefix(_zl)
?};
{? ZGP.last()
|| {!
   |? {? ZGP.DOK<>null()
      || _zgp_left:=exec('ilosc_left','zl_guide',,_wariant);
         {? _zgp_left>0
         || _result:=ZGP.ref()
         ?}
      ?};
      ZGP.prev() & _result=null()
   !}
?};
{? _result=null()
|| {? ZGP.last()
   || _result:=ZGP.ref()
   ?}
?};

ZGP.cntx_pop();
_result


\first_with_dok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Zwraca pierwszy przewodnik na którym mają być raportowane dokumenty
::   WE: _a - ZL.ref
::       [_b] - ZGH.ref
::   WY: ZGP.ref lub null
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_zgh:=null();
{? var_pres('_b')=type_of(ZGH.ref())
|| _zgh:=_b
?};
_result:=null();

ZGP.cntx_psh();
{? _zgh<>null()
|| ZGP.index('NRPRZ');
   ZGP.prefix(_zgh)
|| ZGP.index('ZLEC');
   ZGP.prefix(_zl)
?};
{? ZGP.first()
|| {!
   |? {? ZGP.DOK<>null()
      || _result:=ZGP.ref()
      ?};
      ZGP.next() & _result=null()
   !}
?};
ZGP.cntx_pop();
_result


\last_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca ostatnią pozycję przewodnika do której będzie przypięty dokument RP
::       Funkcja używana awaryjnie w przypadkach gdy na żadnej pozycji przewodnika
::       nie określono typu dokumentu
::   WE: _a - ZL.ref
::       [_b] - ZGH.ref
::   WY: ZGP.ref lub null
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_zgh:=null();
{? var_pres('_b')=type_of(ZGH.ref())
|| _zgh:=_b
?};
_result:=null();

ZGP.cntx_psh();
{? _zgh<>null()
|| ZGP.index('NRPRZ');
   ZGP.prefix(_zgh)
|| ZGP.index('ZLEC');
   ZGP.prefix(_zl)
?};
{? ZGP.last()
|| _result:=ZGP.ref()
?};
ZGP.cntx_pop();
_result



\zgh_icons
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Ustala ikony w oknie wertowania ZGH
::   WE: _a - akronim okna wertowania
::----------------------------------------------------------------------------------------------------------------------
_sel:=_a;
_formikon:="
   {? ZGH.STAT_REJ='T'
   || exec('zarejestrowany','icon')
   || exec('pusta','#icon')
   ?}
";
ZGH.win_fml(_sel,,'NRPRZ',,'ICON_BEFORE',_formikon,2);
_formikon:="
   {? ZGH.PROBLEM='T'
   || exec('problem_blocking','icon')
   || exec('pusta','#icon')
   ?}
";
ZGH.win_fml(_sel,,'ILNPRZ',,'ICON_BEFORE',_formikon,2);
{? VAR.ZGH_ALL>0
|| _formikon:="params_exec('icon_stan','zl_head')";
   ZGH.win_fml('WER_ALL',VAR1,'STAN_ZL',,'ICON_BEFORE',_formikon);
   _formikon:="
      {? ZGH.ZLEC().STAN<>'Z' & (ZGH.ILWYK>0 | exec('has_wyk_zgh','zl_guide')>0)
      || 'xwin16.png:144'
      || exec('pusta','#icon')
      ?}
   ";
   ZGH.win_fml('WER_ALL',,'ILWYK',,'ICON_BEFORE',_formikon)
?};
~~


\zgp_bad_op_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Przed wyświetl pola ZGP.BAD_OP
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
~~


\zgp_bad_op_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Przed redakcja pola ZGP.BAD_OP
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
BADVAR.TYP_BAD:='O';
_result:=1;
{? cur_tab(1,1).PL_GRP='T'
|| _result:=0
?};

{? _result>0
||
:: ponieważ redagowanie jest dla jednego typu operacji, to w oknie BADSEH.RED blokujemy pola TYP, AKT oraz ATEST
   BADSEH.efld_opt('RED','editable=grayed',,'TYP');
   BADSEH.efld_opt('RED','editable=grayed',,'AKT');
   BADSEH.efld_opt('RED','editable=grayed',,'ATEST');
:: usuwam akcje aktywuj/dezaktywuj
   BADSEH.actions('WER','AE')
?};
_result


\zgp_bad_op_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Po redakcji pola ZGP.BAD_OP
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
BADVAR.TYP_BAD:='M';
: przywracam stan zablokowanych pól
BADSEH.efld_opt('RED','editable=1',,'TYP');
BADSEH.efld_opt('RED','editable=1',,'AKT');
BADSEH.efld_opt('RED','editable=1',,'ATEST');
:: przywracam akcje
BADSEH.actions('WER','');
1


\nastepniki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Wyświetla następniki/poprzedniki dla podanego ZGP
::   WE: [_a] - ZGP.ref - pozycja przewodnika
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
{? _ref<>null()
|| ZGP.prefix();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _old:=VAR.A_ZGP;
   VAR.A_ZGP:=ZGP.ref();
   _grpbefore:="
      grp_disp(NASZGP,'SLOPOP');
      grp_disp(NASZGP,'WER');
      ~~
   ";
   _grp:=NASZGP.grp_make('Następstwo operacji: %1'@[exec('ZGP','#to_string')],_grpbefore,'#zgp_nastepstwo',,,,,'normal');
   _ar:="";
   _fb:="
      _result:=~~;
      {? ZGP.size()=0
      || _result:='#disable'
      ?};
      NASZGP.index('NASTOP');
      NASZGP.prefix(VAR.A_ZGP);
      {? ~NASZGP.first() || VAR.STRING3:='' ?};
      ZGP.cntx_psh();
      _result
   ";
   _fa:="
      ZGP.cntx_pop();
      ~~
   ";
   NASZGP.grp_sel(_grp,NASZGP,'SLOPOP',,_ar,,,3,_fb,_fa,,,'maximized_with_title');
   NASZGP.grp_splt(_grp,,'horizontal','bottom');
   _ar:="";
   _fb:="
      _result:=~~;
      {? ZGP.size()=0
      || _result:='#disable'
      ?};
      {? VAR.A_ZLEC().STAN='Z'
      || NASZGP.actions('WER','dI:dI',,1)
      |? ZGP.size()=0
      || NASZGP.actions('WER','d:d',,1)
      || NASZGP.actions('WER','',,1)
      ?};
      NASZGP.index('OPNAST');
      NASZGP.prefix(VAR.A_ZGP);
      {? ~NASZGP.first() || VAR.STRING3:='' ?};
      ZGP.cntx_psh();
      _result
   ";
   _fa:="
      ZGP.cntx_pop();
      ~~
   ";
   NASZGP.grp_sel(_grp,NASZGP,'WER',,_ar,,,3,_fb,_fa,,,'maximized_with_title');
   NASZGP.win_sel(_grp);
   NASZGP.select();
   VAR.A_ZGP:=_old
?};
ZGP.cntx_pop();
~~


\zgh_is_first
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, czy podany w parametrze przewodnik jest pierwszym przewodnikiem zlecenia
::   WE: _a - ZGH.ref - nagłówek przewodnika
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_press('_a')=type_of(null()) || _a || null() ?};
_res:=0;
{? _ref<>null()
|| ZGH.cntx_psh();
   ZGH.clear();
   {? ZGH.seek(_ref)
   || ZGH.index('ZLNR');
      ZGH.prefix(ZGH.ZLEC,);
      {? ZGH.first()
      || _res:=ZGH.ref()=_ref
      ?}
   ?};
   ZGH.cntx_pop()
?};
_res


\zgh_is_last
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, czy podany w parametrze przewodnik jest ostatnim przewodnikiem zlecenia
::   WE: _a - ZGH.ref - nagłówek przewodnika
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_press('_a')=type_of(null()) || _a || null() ?};
_res:=0;
{? _ref<>null()
|| ZGH.cntx_psh();
   ZGH.clear();
   {? ZGH.seek(_ref)
   ||
::    Sprawdzenie czy do zlecenia wygenerowano przewodniki na całą ilość (wtedy można określić ostatni przewodnik)
      ZL.cntx_psh();
      _il_zl:=ZGH.ZLEC().IL;
      ZL.cntx_pop();
      _il_zgh:=exec('get_ilosc_zgh','zl_common',ZGH.ZLEC);
      {? _il_zgh>=_il_zl
      || ZGH.index('ZLNR');
         ZGH.prefix(ZGH.ZLEC,);
         {? ZGH.last()
         ||  _res:=ZGH.ref()=_ref
         ?}
      ?}
   ?};
   ZGH.cntx_pop()
?};
_res


\zgh_has_wariant
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, czy podany w parametrze przewodnik posiada wariantowe operacje
::       (dedykowane dla pierwszego lub ostatniego przewodnika)
::   WE: _a - ZGH.ref - nagłówek przewodnika
::       [_b] - STRING - jakie operacje sprawdzać: 'FIRST' - tylko operacje wariantowe pierwszego przewodnika,
::          'LAST' - tylko operacje wariantowe ostatniego przewodnika, '' - wartość domyślna, dowolne operacje wariant.
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_press('_a')=type_of(null()) || _a || null() ?};
_what:={? var_press('_b')=type_of('') || _b || '' ?};
_res:=0;
{? _ref<>null()
|| ZGH.cntx_psh();
   ZGH.clear();
   {? ZGH.seek(_ref)
   || ZGP.cntx_psh();
      ZGP.index('WHERE');
      {? _what<>'LAST'
      || ZGP.prefix(ZGH.ref(),'P');
         {? ZGP.first()
         || _res:=1
         ?}
      ?};
      {? _res=0 & _what<>'FIRST'
      || ZGP.prefix(ZGH.ref(),'O');
         {? ZGP.first()
         || _res:=1
         ?}
      ?};
      ZGP.cntx_pop()
   ?};
   ZGH.cntx_pop()
?};
_res


\zgh_gen_wariant
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Generuje operacje wariantowe dla danego (aktualnie zaznaczonego) przewodnika.
::       _a - STRING - jakie operacje generować:  'FIRST' - tylko operacje wariantowe pierwszego przewodnika,
::          'LAST' - tylko operacje wariantowe ostatniego przewodnika.
::----------------------------------------------------------------------------------------------------------------------
_what:={? var_press('_a')=type_of('') || _a || '' ?};
{? _what='FIRST' | _what='LAST'
|| _continue:=1;
:: Wstępne walidacje
   {? ZGH.STAT_REJ='T'
   || _continue:=0;
      FUN.info('Zakończono rejestrację przewodnika: %1.\nOperacja niemożliwa.'@[exec('record','#to_string',ZGH.ref())])
   |? _what='FIRST' & ZGH.W_FIRST='T'
   || _continue:=0;
      FUN.info('Przewodnik %1 posiada już zdefiniowane wariantowe operacje pierwszego przewodnika.'@[ZGH.NRPRZ])
   |? _what='LAST' & ZGH.W_LAST='T'
   || _continue:=0;
      FUN.info('Przewodnik %1 posiada już zdefiniowane wariantowe operacje ostatniego przewodnika.'@[ZGH.NRPRZ])
   ?};
   {? _continue
   || _msg:={? _what='FIRST'
         || 'Czy wygenerować operacje wariantowe pierwszego przewodnika dla przewodnika: %1?'@
            [exec('record','#to_string',ZGH.ref())]

         || 'Czy wygenerować operacje wariantowe ostatniego przewodnika dla przewodnika: %1?'@
            [exec('record','#to_string',ZGH.ref())]

         ?};
      _msg+='\nUwaga!\n'
            'Zostanie zmodyfikowana numeracja pozycji oraz zostaną odtworzone domyślne powiązania między operacjami.'@;
      _continue:=FUN.ask(_msg)
   ?};
   {? _continue>0
   || {? VAR.A_ZLEC().TYP().TECH='T'
      || _ktl:=exec('FindAndGet','#table',TKTL,VAR.A_ZLEC().RTKTL,,"ref()",null())
      || _ktl:=exec('FindAndGet','#table',TKTL,VAR.A_ZLEC().RKTL,,"ref()",null())
      ?};

      _msk:=(8+ref_name(_ktl))+3;
      exec('tktl_cntx_psh','tech_common');
      exec('tktl_use','tech_common',_msk);
      exec('start_tpar','tech_param',VAR.A_ZLEC().KTM,_ktl);

      _where:={? _what='FIRST' || 'P' || 'O' ?};
      TOPER.index('WHERE');
      TOPER.prefix(_ktl,_where,);
      {? TOPER.first()
      || {!
         |? {? TOPER.ACT='T' & tpar.calc(TOPER.EXIST)
            ||
::             Ustalenie nr dodawanej pozycji
                _nr:=exec('zgp_war_nr','zl_guide',TOPER.ref(),ZGH.ref());
::             Generowanie operacji
               exec('gen_zgp','zl_guide',TOPER.ref(),ZGH.ref(),_nr)
            ?};
            TOPER.next()
         !}
      || FUN.info('Technologia nie ma zdefiniowanych wskazanych operacji wariantowych'@)
      ?};
      exec('tktl_cntx_pop','tech_common');
::    Generuję zapotrzebowania (na razie nie potrzebne - przewodnik nie może być zakończony)
::      VAR_DEL.delete('__matakt');
::      __matakt:=tab_tmp(2
::      ,'REF','STRING[16]',''
::      ,'NRK','INTEGER',''
::      ,'ILR','REAL',''
::      ,'ZKP','STRING[16]',''
::      ,'ZKN','STRING[16]',''
::      );
::      _top_level:=exec('top_level','zl_link',ZGP.ZL);
::      ZLIM.cntx_psh();
::      exec('openmask','zl_common',VAR.A_ZLEC);
::      exec('zlim_gen_main','zl_limit','',_top_level,,0,0,1,0,0,1,1,ZGH.ref());
::      ZLIM.cntx_pop();
::      exec('openz','open_tab',ST.ODDZ+'__');
::      exec('akt_rezy','rezerwacje');
::      VAR_DEL.delete('__matakt');
::    Generuję domyślne powiązania
      exec('gendom_zgh','zl_guide',ZGH.ref(),0)
   ?}
?};
~~


\gen_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Generuje pozycje przewodnika (ZGP) na podstawie przekazanej operacji procesu technologicznego (TOPER)
::   WE: _a - TOPER.ref()
::       _b - ZGH.ref()
::       _c - nr pozycji dla dodawanej pozyji przewodnika
::----------------------------------------------------------------------------------------------------------------------
_toper:={? var_press('_a')=type_of(null()) || _a || null() ?};
_zgh:={? var_press('_b')=type_of(null()) || _b || null() ?};
_nr:={? var_press('_c')=type_of(0) || _c || 0 ?};

{? _toper<>null() & _zgh<>null()
||
   TOPER.cntx_psh();
   TOPER.use(ref_name(_toper));
   TOPER.clear();
   {? TOPER.seek(_toper)
   ||
      Cntx.psh(TTOPER,TTOUT,TWRKZPO);
      _coef:={? TOPER.FCOEF<>'' & TOPER.NRK().TYP().PAR='T' || tpar.calc(TOPER.FCOEF) || TOPER.COEF ?};
      _ntime:={? TOPER.FNTIME<>'' || tpar.calc(TOPER.FNTIME) || TOPER.NTIME ?};
      _mtime:={? TOPER.FMTIME<>'' || tpar.calc(TOPER.FMTIME) || TOPER.MTIME ?};
      _il_zgh:=exec('FindAndGet','#table',ZGH,_zgh,,"ZGH.ILNPRZ",0);
      _xjm:={? VAR.A_ZLEC().TYP().TECH='T'
      || exec('FindAndGet','#table',TKTL,VAR.A_ZLEC().RTKTL,,"XJM",1)
      || exec('FindAndGet','#table',TKTL,VAR.A_ZLEC().RKTL,,"XJM",1)
      ?};
      _wsp:=_il_zgh/_xjm;

      ZGP.clear();
      ZGP.blank();

      ZGP.NRPRZ:=_zgh;
      ZGP.NRP:=_nr;
      ZGP.NRZLP:=_zgh;
      ZGP.OPIS:={? TOPER.WEW='T' || TOPER.OPER().NA || TOPER.TTOUT().NA ?};
      ZGP.TOPER:=TOPER.ref();
      ZGP.WEW:=TOPER.WEW;
      ZGP.FIX_NORM:=TOPER.FIX_NORM;
      ZGP.TPZ:=TOPER.TPZ;
      ZGP.PLNX:=({? TOPER.TPZ='T' || {? _ntime=0 || 0 || TOPER.PLNX/_ntime ?} || TOPER.OPER().STAWKA ?}*_coef*_ntime)$4 *
         {? ZGP.TPZ='T' | ZGP.WEW='N' | ZGP.FIX_NORM='T' || 1 || _wsp ?};
      ZGP.PLNH:=({? TOPER.TPZ='T' || {? _ntime=0 || 0 || TOPER.PLNX/_ntime ?} || TOPER.OPER().STAWKA ?}*_coef)$4;
      ZGP.NTIME:=_ntime*{? ZGP.TPZ='T' | ZGP.WEW='N' | ZGP.FIX_NORM='T' || 1 || _wsp ?};
      ZGP.BRYG:=TOPER.BRYG;
      ZGP.PO:=TOPER.OPER().PLATNE;
      ZGP.CENA:=TOPER.CENA*{? ZGP.TPZ='T' || 1 || _wsp ?};
      ZGP.PFAZ:=TOPER.PFAZ;
      ZGP.MTIME:=_mtime*{? ZGP.TPZ='T' | ZGP.WEW='N' | ZGP.FIX_NORM='T' || 1 || _wsp ?};

      ZGP.PLACE:={? TOPER.GRPOJ='S' || TOPER.PLACE || TOPER.TWRKPLG().ELEMENT ?};
      {? VAR.A_ZLEC().RP='T'
      || ZGP.DOK:=TOPER.DOK
      ?};
      ZGP.NKO:={? TOPER.FNKO<>'' || tpar.calc(TOPER.FNKO) || TOPER.NKO ?};
      ZGP.TTM:={? TOPER.FTTM<>'' || tpar.calc(TOPER.FTTM) || TOPER.TTM ?};
      ZGP.CIAGLA:=TOPER.CIAGLA;
      ZGP.memo_set(TOPER.memo_txt(,1,'OPISMEMO'),'OPISMEMO');
      ZGP.DAYS_K:=TOPER.DAYS_K;
      ZGP.PX_KONT:=TOPER.PX_KONT;
      ZGP.KONTRAH:=TOPER.KONTRAH;
      ZGP.PL_GRP:=TOPER.PL_GRP;
      ZGP.GRUPA:=TOPER.GRUPA;
      ZGP.SRW:=TOPER.SRW;
      _ilosc:=0;
      ZGP.KONTROLA:=TOPER.KONTROLA;
      {? ZGP.TPZ='N'
      || ZGP.KJ_BAD:=TOPER.KJ_BAD;
         ZGP.BADSEH:=TOPER.BADSEH;
         ZGP.BAD_OP:=TOPER.BAD_OP
      ?};
      ZGP.WHERE:=TOPER.WHERE;
      ZGP.OPER_NAZ:={? TOPER.WEW='T' || TOPER.OPER().NA || TOPER.TTOUT().NA ?};
      ZGP.WYK_FAST:=TOPER.WYK_FAST;
      {? _ilosc>0
      || ZGP.ILOSC:=_ilosc
      || ZGP.ILOSC:=_il_zgh
      ?};
      {? ZGP.TPZ='T'
      ||
::       Wiązanie pozycji przewodnika TPZ z pozycją do której jest TPZ
         _nrp:=0;
         _uid:='';

         TOPER.cntx_psh();
         ZGP.cntx_psh();
         ZGP.index('PNRPP');
         ZGP.prefix(ZGP.NRZLP,'N');
         _po:='O';
         _tpzref:=TOPER.TPZREF;
         {? ZGP.first()
         || {!
            |? {? ZGP.TOPER().UNROP=_tpzref
               || _nrp:=ZGP.NRP;
                  _po:=ZGP.PO;
                  _uid:=ZGP.UID
               ?};
               ZGP.next()
            !}
         ?};
         ZGP.cntx_pop();
         TOPER.cntx_pop();
         ZGP.OPIS:={? ZGP.OPIS<>''
                   || 'TPZ - '+ZGP.OPIS
                   || 'TPZ - '+exec('zgpopis','zl_guide','TOPER',ZGP.TOPER().NRK,ZGP.TOPER().NRNOP,ZGP.TOPER().NROP)
                   ?};
::       ZGP.TPZREF:=_nrp;
         ZGP.UID_TPZ:=_uid;
         ZGP.ZAW:=TOPER.ZAW;
         ZGP.CIAGLA:='T';
         ZGP.NRP:=_nrp;
         ZGP.PO:=_po
      ?};
      {? ZGP.TPZ<>'T'
      ||
::       Przed dodaniem przenumerowuje pozycje (od bieżącej pozycji podwyższam numer następnych pozyji o 1)
         _nr:=ZGP.NRP;
         ZGP.cntx_psh();
         ZGP.index('NRPP');
         _nrp:=exec('FindAndGet','#table',ZGH,_zgh,,"ZGH.NRPRZ",'');
         ZGP.prefix(_zgh,'N',_nrp);
         NASZGP.cntx_psh();
         NASZGP.index('NASTOP');
         _ok:=1;
         {? ZGP.last()
         || {!
            |?
               {? ZGP.NRP<_nr
               || _ok:=0
               || ZGP.NRP+=1;
                  {? ZGP.put()
                  || ZGP.cntx_psh();
                     ZGP.prefix(_zgh,'T',_nrp,ZGP.NRP-1);
                     {? ZGP.first()
                     || ZGP.NRP+=1;
                        ZGP.clear();
                        ZGP.put()
                     ?};
                     ZGP.cntx_pop()
                  ?};
                  NASZGP.prefix(ZGP.ref());
                  {? NASZGP.first()
                  || {!
                     |? _sciezka:=#NASZGP.SCIEZKA;
                        _sciezka+=1;
                        NASZGP.SCIEZKA:=$_sciezka;
                        NASZGP.put();
                        NASZGP.next()
                     !}
                  ?}
               ?};
               _ok & ZGP.prev()
            !}
         ?};
         ZGP.cntx_pop();
         NASZGP.cntx_pop()
      ?};
      {? ZGP.add()
      || ZGP.memo_put(,'OPISMEMO');
         DocLib.copy('TOPER',ZGP.TOPER,'ZGP',ZGP.ref())
      ?};
      Cntx.pop(TTOPER,TTOUT,TWRKZPO)
   ?};
   TOPER.cntx_pop()
?};
~~


\zgp_war_nr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Wyznacza nowy numer pozycji ZGP podczas dodawania operacji wariantowej (występującej na pierwszym lub
::       ostatnim przewodniku). Nr ustalany wg następników/poprzedników technologii zlecenia.
::   WE: _a - TOPER.ref()
::       _b - ZGH.ref()
::   WY: INTEGER - nr pozycji
::----------------------------------------------------------------------------------------------------------------------
_nr:=0;
_toper:=_a;
_zgh:=_b;
NASTOPER.cntx_psh();
NASTOPER.index('NASTOP');
NASTOPER.prefix('T',_toper);
{? NASTOPER.first()
|| _toper:=NASTOPER.OPER;
:: Sprawdzenie czy operacja występuje na przewodniku
   ZGP.cntx_psh();
   ZGP.index('TOPERPOD');
   ZGP.prefix(_zgh,$_toper);
   {? ZGP.first()
   || _nr:=ZGP.NRP+1
   ||
::    Nie ma operacji na przewodniku (zapewne została usunięta) więc sprawdzam operację wcześniejszą
::    !!!REKURENCJA!!!
      _nr:=exec('zgp_war_nr','zl_guide',_toper,_zgh)
   ?};
   ZGP.cntx_pop()
||
:: Operacja nie posiada poprzednika wg technologii źródłowej - wtedy operacja dodawana na początek
   _nr:=1
::   ZGP.cntx_psh();
::   ZGP.index('NRPRZ');
::   ZGP.prefix(_zgh);
::   {? ZGP.last()
::   || _nr:=ZGP.NRP+1
::   ?};
::   ZGP.cntx_pop()
?};
NASTOPER.cntx_pop();
_nr


\has_problem
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [22.26]
:: OPIS: Sprawdza, czy do danej pozycji przewodnika są zarejestrowane problemy
::   WE: _a - ZGP.ref()
::   WY: 0/1 - nie ma problemów, są problemy
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_res:=0;

EK_PROB.cntx_psh();
EK_PROB.index('PROB1');
EK_PROB.prefix(_zgp);
_res:=EK_PROB.first();
EK_PROB.cntx_pop();

_res


\del_problem
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [22.26]
:: OPIS: Usuwa problemy zgłoszone do pozycji przewodnika
::   WE: _a - ZGP.ref()
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;
EK_PROB.cntx_psh();
EK_PROB.index('PROB1');
EK_PROB.prefix(_zgp);
{? EK_PROB.first() || {! |? EK_PROB.del() !} ?};
EK_PROB.cntx_pop();
~~


\zgp_cube_size
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Zwraca liczbę pól, jaka ma zostać utworzona dla obiektu generującego przewodniki (PRZE_, PRZEW)
::   WY: NUMBER - ilość pól
::----------------------------------------------------------------------------------------------------------------------
39


\zgh_word
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Wydruk przewodnika zlecenia produkcyjnego do WORD
::----------------------------------------------------------------------------------------------------------------------
exec('generuj','szablon_zws','TTE_PRZEWODNIK_ZLEC');
~~


\zgh_all_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Wyświetla widok wzystkich przewodników zleceń - obszar roboczy Przewodniki zleceń
::----------------------------------------------------------------------------------------------------------------------
:: Ustalenie treści linku
_params:=params_get();
{? type_of(_params)>0 & var_pres('LINK',_params)=type_of('')
|| _link:=_params.LINK
|| _link:=''
?};

Cntx.psh(ZL,ZGH,ZGP,NASZGP);
VAR.ZGH_ALL:=1;
VAR.LOCK:=1;
ZGH.win_sel(exec('zgh_all_wer','zl_guide'));

{? _link<>''
|| {? ref_tab(_link)=ZGH
   || {? ZGH.seek(_link)
      || ZGH.select(,1,5,,'ZGH',,1)
      || FUN.info('Przewodnik o identyfikatorze %1 nie został odnaleziony.'@[_link]);
         Cntx.pop(ZL,ZGH,ZGP,NASZGP);
         return()
      ?}
   || Cntx.pop(ZL,ZGH,ZGP,NASZGP);
      return()
   ?}
:: Obsługa standardowa
|| exec('ust_zakr','zl_guide');
   exec('set_filter','zl_guide');
   ZGH.select()
?};

VAR.ZGH_ALL:=0;
VAR.LOCK:=0;
ZGH.f_clear(1);
Cntx.pop(ZL,ZGH,ZGP,NASZGP);
~~


\zgh_all_wer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Tworzy okno grupowe do widoku wszystkich przewodników zleceń
::   WY: utworzone okno grupwe
::----------------------------------------------------------------------------------------------------------------------
_grp:=ZGH.grp_make('Przewodniki zleceń'@,,'zgh_all_wer',,,"exec('exit','zws',_a)");

::exec('twrkplc_filter_all','zasoby');
ZGP.win_sel('WERZ');
exec('zgp_icons','zl_guide','WERZ');
exec('zgh_icons','zl_guide','WER_ALL');

_fb:="";
_fa:="";
_ar:="
:   VAR.A_ZLEC();
   VAR.A_NRPRZ:=ZGH.ref();
   VAR.A_NRZLP:=ZGH.ref();
   ZGH.cntx_psh();
   ZGP.index('PNRPP');
   ZGP.prefix(ZGH.ref(),'N');
   VAR.LOCK:=0;
   grp_disp(ZGP,'WERZ',1);
   VAR.LOCK:=1;
   ZGH.cntx_pop();
   _keys:=exec('zgh_actions','zl_guide');
   ZGH.actions('WER_ALL',_keys.hide,_keys.default,1);
   _grayed:=exec('zgh_grayed','zl_guide');
   ZGH.actions_grayed('WER_ALL',_grayed);
   ~~
";
:: Zakładka z nagłówkami
ZGH.grp_sel(_grp,ZGH,'WER_ALL','Nagłówki przewodników'@,_ar,,,10,_fb,_fa,,,'maximized','ZGH');
:: Pozycje
ZGH.grp_splt(_grp,,'horizontal','tab2');
_ar:="
   ZGP.cntx_psh();
   VAR.LOCK:=0;
   grp_disp(NASZGP,'WER',0);
   grp_disp(NASZGP,'SLOPOP',0);
   VAR.LOCK:=1;
   ZGP.cntx_pop()
";
_fb:="
   {? grp_empty(ZGH,'WER_ALL')
   || '#disable'
   || {? VAR.LOCK>0
      || exec('blk_lock','#table','ZGH',ZGH.ref(),,1)
      ?};
      _actions:=exec('zgp_actions','zl_guide');
      ZGP.actions('WERZ',_actions,,1);
      {? ZGH.STAN='T' | ZL.STAN='Z' | ZL.RODZAJ='Z' | ZL.RODZAJ='N'
      || ZGP.dnd_sel('WERZ',,'records.ZGP',\"\")
      || ZGP.dnd_sel('WERZ',,'records.ZGP',\"exec('dnd_renum','zl_guide')\")
      ?};
      ''
   ?}
";
_fa:="
   ZGP.dnd_sel('WERZ',,'records.ZGP',\"\");
   {? VAR.LOCK>0
   || exec('blk_unlock','#table','ZGH',ZGH.ref())
   ?};
   ~~
";
ZGH.grp_sel(_grp,ZGP,'WERZ',,_ar,,,,_fb,_fa,,,'maximized_with_title','ZGP');

:: Następniki/poprzedniki
ZGH.grp_splt(_grp,'tab2','vertical','nast1',',66%');
_ar:="";
_fb:="
   ZL.cntx_psh();
   ZGP.cntx_psh();
   {? grp_empty(ZGP,'WERZ')
   || '#disable'
   || NASZGP.index('NASTOP');
      NASZGP.prefix(VAR.A_ZGP);
      {? ~NASZGP.first() || VAR.STRING3:='' ?};
      ''
   ?}
";
_fa:="
   ZGP.cntx_pop();
   ZL.cntx_pop();
   ~~
";
ZGH.grp_sel(_grp,NASZGP,'SLOPOP','Poprzedniki'@,_ar,,,,_fb,_fa,,,'maximized','POP');

_ar:="";
_fb:="
   ZL.cntx_psh();
   ZGP.cntx_psh();
   {? grp_empty(ZGP,'WERZ')
   || '#disable'
   || {? VAR.LOCK>0
      || exec('blk_lock','#table','ZGH',ZGH.ref(),,1)
      ?};
      {? ZL.STAN='Z'
      || NASZGP.actions('WER','dpuDPUI:dDI',,1)
      |? exec('is_main_podzlec','zl_link',ZGP.ZL)
      || NASZGP.actions('WER','I:I',,1)
      || NASZGP.actions('WER','',,1)
      ?};
      NASZGP.index('OPNAST');
      NASZGP.prefix(VAR.A_ZGP);
      {? ~NASZGP.first() || VAR.STRING3:='' ?};
      ''
   ?}
";
_fa:="
   {? VAR.LOCK>0
   || exec('blk_unlock','#table','ZGH',ZGH.ref())
   ?};
   ZGP.cntx_pop();
   ZL.cntx_pop();
   ~~
";
ZGH.grp_sel(_grp,NASZGP,'WER','Następniki'@,_ar,,,,_fb,_fa,,,'maximized','NAS');

_grp


\zgh_all_zakr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Akcja Zmień Zakres w oknie ALL tabeli ZGH (wszystkie przewodniki zleceń)
::----------------------------------------------------------------------------------------------------------------------
ZAKR.win_edit('ZAKR_ZGH');
ZAKR.win_efml('ZAKR_ZGH',,'IKONA_N',,'ICON_BEFORE',"'xwin16.png:18'");
ZAKR.win_efml('ZAKR_ZGH',,'IKONA_O',,'ICON_BEFORE',"'xwin16.png:156'");
ZAKR.win_efml('ZAKR_ZGH',,'IKONA_Z',,'ICON_BEFORE',"'xwin16.png:157'");
exec('ust_zakr','zl_guide');
{? ZAKR.edit()
|| exec('set','#params',8506,ZAKR.ZTP_WP+ZAKR.ZGH_ZLST+ZAKR.ZGH_STAN+ZAKR.ZGH_STAT+ZAKR.ZGH_PROB+ZAKR.ZGH_BRAK
      ,OPERATOR.USER);
   exec('set_filter','zl_guide')
?};
~~


\set_filter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Ustawia filtr programowy dla okna ALL tabeli ZGH (wszystkie przewodniki zleceń)
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_exit:="
   exec('err_psql','#sql');
   exec('empty_f_set','#table',ZGH)
";
ZGH.f_clear(1);
ZGH.clear();
ZGH.index('ZL_SYM');
ZGH.prefix();
_sort:='';
_from:='join ZL using (ZGH.ZLEC,ZL.REFERENCE) join ZTP using (ZL.TYP,ZTP.REFERENCE)';
_where:='ZL.ODDZ=\':_e\' ';
{? ZAKR.ZTP_WP<>'' & ZAKR.ZTP_WP<>'A'
|| _where+='and ZTP.WP=\':_a\' '
?};
{? ZAKR.ZGH_ZLST<>'' & ZAKR.ZGH_ZLST<>'A'
|| {? ZAKR.ZGH_ZLST='W'
   || _where+='and ZL.ST_W=\'T\'\ '
   |? ZAKR.ZGH_ZLST='O'
   || _where+='and ZL.ST_O=\'T\'\ '
   |? ZAKR.ZGH_ZLST='Z'
   || _where+='and ZL.ST_Z=\'T\'\ '
   |? ZAKR.ZGH_ZLST='N'
   || _where+='and ZL.ST_N=\'T\'\ '
   ?}
?};
{? ZAKR.ZGH_STAT<>'' & ZAKR.ZGH_STAT<>'A'
|| _where+='and ZGH.STAT_REJ=\':_b\' '
?};
{? ZAKR.ZGH_STAN<>'' & ZAKR.ZGH_STAN<>'A'
|| _where+='and ZGH.STAN=\':_c\' '
?};
{? ZAKR.ZGH_PROB<>'' & ZAKR.ZGH_PROB<>'A'
|| _where+='and ZGH.PROBLEM=\':_d\' '
?};
{? ZAKR.ZGH_BRAK<>'' & ZAKR.ZGH_BRAK<>'A'
|| _where+='and ZGH.BRAKI=\':_f\' '
?};

{? ~ZGH.f_set(_sort,_from,_where,ZAKR.ZTP_WP,ZAKR.ZGH_STAT,ZAKR.ZGH_STAN,ZAKR.ZGH_PROB,ST.ODDZ,ZAKR.ZGH_BRAK)
|| _exit()
?};
~~


\ust_zakr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Ustawia wartości pól ZAKR.ZTP_WP,ZAKR.ZGH_ZLST,ZAKR.ZGH_STAT,ZAKR.ZGH_STAN,ZAKR.ZGH_PROB, ZAKR.ZGH_BRAK
::       na podstawie parametru
::----------------------------------------------------------------------------------------------------------------------
_war:=exec('get','#params',8506,2,OPERATOR.USER);
ZAKR.ZTP_WP:=1+_war;
ZAKR.ZGH_ZLST:=1+(1-_war);
ZAKR.ZGH_STAN:=1+(2-_war);
ZAKR.ZGH_STAT:=1+(3-_war);
ZAKR.ZGH_PROB:=1+(4-_war);
ZAKR.ZGH_BRAK:=_war+1;
~~


\zgh_show_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Wyświetla okno podglądu nagłówka zlecenia przypisanego do przewodnika. Pracuje na bieżącym rekordzie ZGH.
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(ZGH.ZLEC)
|| exec('zl_display','zl_head',1);
:: Mógł się zmienić stan zlecenia, odświeżenie okna
   {? ZGH.f_active() || ZGH.f_rfresh() ?}
?};
ZL.cntx_pop();
~~


\parses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Ustawienie parametru sesji w obszarze roboczym TTE_PRZ (Przewodniki zleceń)
::----------------------------------------------------------------------------------------------------------------------
{? __PARSES.editPar('OddzialLogProd','OkresRok')
|| exec('set_filter','zl_guide')
?};
~~


\zgp_bryg_change
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Zmienia sposób rejestracji wykonania operacji: czy przez pracownika, czy prze brygadę.
::       (zmiana znacznika ZPG.BRYG).
::   WE: [_a] - ZGP.ref() - jak nie podany, to aktualny rekord
::   WY: Czy zmieniono sposób rejestracji operacji: 1 -tak, 0 - nie
::----------------------------------------------------------------------------------------------------------------------
_zgp:={? var_pres('_a')=type_of(null()) || _a || ZGP.ref() ?};
_res:=0;
ZGP.cntx_psh();
ZGP.prefix();
{? ZGP.seek(_zgp)
|| _ok:=1;
   _err:='';
   _bryg:=ZGP.BRYG;
   {? ZGP.TPZ='T'
   ||
::    Jeżeli funkcja uruchomiona na operacji TPZ to podczytuje główną operację
      ZGP.index('UID');
      ZGP.prefix(ZGP.UID_TPZ);
      {? ZGP.first()
      || _ok:=1
      || _ok:=0;
         _err:='Nie udało się odnaleźć operacji głównej dla TPZ.'@
      ?}
   ?};
   _tpz_ref:=exec('tpz_ref','zl_guide',ZGP.ref());
:: Wykluczenie operacji zewnętrznych (kooperacji)
   {? _ok>0 & ZGP.WEW<>'T'
   || _ok:=0;
      _err:='Operacja zewnętrzna (kooperacja). Modyfikacja niemożliwa.'@
   ?};
:: Sprawdzenie, czy jest zarejestrowana robocizna
   {? _ok>0 & ~(exec('spr_akord','zl_guide') & exec('spr_akord','zl_guide',_tpz_ref))
   || _ok:=0;
      _err:='Operacja z zarejestrowanymi wykonaniami. Modyfikacja niemożliwa.'@
   ?};
:: Sprawdzenie, czy są zarejestrowane karty pracy
   {? _ok>0 & ~(exec('spr_kap','zl_guide') & exec('spr_kap','zl_guide',_tpz_ref))
   || _ok:=0;
      _err:='Operacja z zarejestrowanymi kartami pracy. Modyfikacja niemożliwa.'@
   ?};
:: Sprawdzenie wykorzystania w grupach operacji
   {? _ok>0 & exec('FindInSet','#table','GROPP','ZGP',ZGP.ref())
   || _ok:=0;
      _err:='Operacja użyta w grupie operacji. Modyfikacja niemożliwa.'@
   ?};
   {? _ok>0
   ||
::    Wszystko ok, można zmieniać
      _txt_prac:='wykonywana przez pracownika'@;
      _txt_bryg:='wykonywana przez brygadę'@;
      _msg:='Aktualny sposób rejestracji operacji: %1.\n\nCzy zmienić sposób rejestracji na: %2?'@
         [{? _bryg='T' || _txt_bryg || _txt_prac ?},{? _bryg<>'T' || _txt_bryg || _txt_prac ?}];
      {? FUN.ask(_msg)
      || {? _bryg='T'
         || ZGP.BRYG:='N'
         || ZGP.BRYG:='T'
         ?};
::       Wywołanie formuły rekord po dla ZGP - dodatkowa walidacja danych
         exec('prepzch','zl_guide');
         {? exec('przpo','zl_guide')=''
         || {? ZGP.put()
            || _res:=1;
::             Formuła po popraw dla ZGP - aktualizacja danych na TPZ
               exec('przp_aft','zl_guide',0)
            ?}
         ?}
      ?}
   || {? _err<>''
      || FUN.info(_err)
      ?}
   ?}
?};
ZGP.cntx_pop();
_res


\zgp_wew_change
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Zmienia rodzaj operacji - wewnętrzna/zewnętrzna (zmiana znacznika ZPG.WEW).
::   WE: [_a] - ZGP.ref() - jak nie podany, to aktualny rekord
::   WY: Czy zmieniono rodzaj operacji: 1 - tak, 0 - nie
::----------------------------------------------------------------------------------------------------------------------
_zgp:={? var_pres('_a')=type_of(null()) || _a || ZGP.ref() ?};
_res:=0;
ZGP.cntx_psh();
ZGP.prefix();
{? ZGP.seek(_zgp)
|| _ok:=1;
   _err:='';
   _wew:=ZGP.WEW;
   _px_stage:=ZGP.PX_STAGE;
   _tpz_ref:={? _wew='T' || exec('tpz_ref','zl_guide',ZGP.ref()) || null() ?};
   {? ZGP.PROBLEM='T'
   || _ok:=0;
      _err:='Do operacji zgłoszono problem. Modyfikacja niemożliwa.'
   |? ZGP.NAPRAW='T'
   || _ok:=0;
      _err:='Operacja naprawcza do braków. Modyfikacja niemożliwa.'
   ?};
:: Sprawdzenie, czy jest zarejestrowana robocizna
   {? _ok>0 & ~(exec('spr_akord','zl_guide') & {? _tpz_ref<>null() || exec('spr_akord','zl_guide',_tpz_ref) || 1 ?})
   || _ok:=0;
      _err:='Operacja z zarejestrowanymi wykonaniami. Modyfikacja niemożliwa.'@
   ?};
:: Sprawdzenie, czy są zarejestrowane karty pracy (tylko dla wewnętrznych)
   {? _ok>0 & _wew='T' & ~(exec('spr_kap','zl_guide') & exec('spr_kap','zl_guide',_tpz_ref))
   || _ok:=0;
      _err:='Operacja z zarejestrowanymi kartami pracy. Modyfikacja niemożliwa.'@
   ?};
:: Sprawdzenie wykorzystania w grupach operacji (tylko dla wewnętrznych)
   {? _ok>0 & _wew='T' & exec('FindInSet','#table','GROPP','ZGP',ZGP.ref())
   || _ok:=0;
      _err:='Operacja użyta w grupie operacji. Modyfikacja niemożliwa.'@
   ?};
   {? _ok>0
   ||
::    Wszystko ok, można zmieniać
      VAR.ZM_ROPER:='T';
::    Wywołanie formuły rekord przed dla ZGP - dodatkowa walidacja danych
      {? exec('ppopr_zgp','zl_guide')
      || {? ZGP.edit("exec('przpo','zl_guide')")
         || {? ZGP.put()
            || _res:=1;
::             Jeżeli wcześniej była przypisana operacja TPZ, a zmieniono na kooperację, to usuwam TPZ
               {? _tpz_ref<>null() & ZGP.WEW='N'
               || ZGP.cntx_psh();
                  ZGP.prefix();
                  {? ZGP.seek(_tpz_ref)
                  || ZGP.del()
                  ?};
                  ZGP.cntx_pop()
               ?};
::             Formuła po popraw dla ZGP - aktualizacja danych na TPZ
               exec('przp_aft','zl_guide',0)
            ?}
         ?}
      ?};
      VAR.ZM_ROPER:=''
   || {? _err<>''
      || FUN.info(_err)
      ?}
   ?}
?};
ZGP.cntx_pop();
_res


\wew_change
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Ustalenie (wyczyszczenie) wartości dla ZGP, podczas zmiany rodzaju operacji.
::       Działa na aktualnym rekordzie tabeli ZGP
::   WY: 0/1 - wynik FUN.ask, czy zmieniać rodzaj operacji
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_wew:=ZGP.WEW;
_txt_wew:='wewnętrzna'@;
_txt_zew:='zewnętrzna (kooperacja)'@;
_msg:='Aktualny rodzaj operacji: %1.\n\nCzy zmienić rodzaj operacji na: %2?'@
   [{? _wew='T' || _txt_wew || _txt_zew ?},{? _wew<>'T' || _txt_wew || _txt_zew ?}];
_p500369:=exec('get','#params',500369,type_of(''));
{? ZGP.PX_STAGE<>null() & _p500369='T'
|| _msg+='\n\nUwaga. Po modyfikacji operacji zostanie zaktualizowany przepis planistyczny zlecenia.'@
?};
{? FUN.ask(_msg)
|| _res:=1;
   _buffer:=exec('obj_new','#buf','ZGP',);
   _buffer.get();
   {? _wew='T'
   || VAR.A_WEW:='N'
   || VAR.A_WEW:='T'
   ?};
:: Wyczyszczenie wartości pól
   ZGP.blank();
:: Przywrócenie wartości pól, które pozostają po zmianie rodzaju operacji
   ZGP.IDADD:=_buffer.IDADD;
   ZGP.NRPRZ:=_buffer.NRPRZ; ZGP.NRZLP:=_buffer.NRZLP;
   ZGP.NRP:=_buffer.NRP;
   ZGP.OPIS:=_buffer.OPIS;
   ZGP.PFAZ:=_buffer.PFAZ;
   ZGP.DOK:=_buffer.DOK;
   ZGP.STATUS:=_buffer.STATUS;
   ZGP.ZL:=_buffer.ZL; ZGP.M:=_buffer.M;
   ZGP.UID:=_buffer.UID;
   ZGP.PLANUJ:=_buffer.PLANUJ;
   ZGP.WHERE:=_buffer.WHERE;
   ZGP.ILOSC:=_buffer.ILOSC
?};
_res


\plan_out_red_gpr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Redagowanie danych do planowania dla pozycji przewodnika - Grupa przed
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_continue:=1;
ZGP.cntx_psh();
{? ZGP.sel_size()>1
|| {? _continue>0
   ||
      ZGP.seek(null(),,,1);
      ZGP.blank(1);
      ZGP.WEW:='N';
      VAR.GRP_MOD:='P';
      _buffer:=exec('obj_new','#buf','ZGP',);
      _buffer.get();
      params_set('buffer',_buffer);
      ZGP.win_edit('PLAN_GRP');
      _valid:="
         _res:=1;
         params_set(params_get());
         _buffer:=exec('obj_new','#buf','ZGP',);
         _buffer.get();
         {? exec('compare','#table',_buffer,params_get().buffer,0,'KONTRAH','DAYS_K','PX_KONT','STARTDK','ENDDK')
         || FUN.info('Przynajmniej jedno z pól musi zostać określone.'@);
            _res:=0
         ?};
         {? _res>0
         || _res:=exec('plan_out_chk','zl_guide')
         ?};
         _res
      ";
      _continue:=ZGP.edit(_valid);
      {? _continue>0
      || _buffer_grp:=exec('obj_new','#buf','ZGP',"'KH_ONLY'");
         _buffer_grp.get();
         {? var_pres('__BUFF_GRP')>100
         || obj_del(__BUFF_GRP)
         ?};
         __BUFF_GRP:=_buffer_grp;
::       Sprawdzeniem czy określono wyłącznie pole z kontrahentem - wtedy nie są walidowane pola dot. planowania
         _buffer_grp.KH_ONLY:=exec('compare','#table',_buffer,_buffer_grp,0,'DAYS_K','PX_KONT','STARTDK','ENDDK');
         sel_nchk();
         KOMM.init(255,,'Grupowe planowanie operacji'@);
         VAR.GRP_MOD:='T';
         VAR.GRUPA:='T'
      || VAR.GRP_MOD:='N';
         VAR.GRUPA:='N';
         VAR_DEL.delete('__BUFF_GRP')
      ?}
   ?}
?};
ZGP.cntx_pop();
_continue


\plan_out_red_gpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Redagowanie danych do planowania dla pozycji przewodnika - Grupa po
::----------------------------------------------------------------------------------------------------------------------
{? VAR.GRP_MOD='T'
|| VAR.GRUPA:='N';
   VAR.GRP_MOD:='N';
   VAR_DEL.delete('__BUFF_GRP');
   KOMM.select()
?};
~~


\grp_mod_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Zwraca informacje o zleceniu, operacji którego będzie dotyczył komunikat błędu.
::       Działa na aktualnym buforze tabeli ZGP
::   WY: STRING z informacją o zleceniu, operacji
::----------------------------------------------------------------------------------------------------------------------
_grp_msg:='';
_zgh:=exec('FindAndGet','#table',ZGH,ZGP.NRZLP,,"ZGH.NRPRZ",'');
_grp_msg:=
   'Przewodnik: %1'@[_zgh]+
   ', poz. %1'@[exec('ZGP','#to_string',1)]
   +' - ';
_grp_msg


\zgpo_modify_frombfr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Modyfikuje aktualny bufor tabeli ZGP na podstawie innego bufora (podczas grupowego planowania operacji)
::   WE: _a - bufor tabeli TOPER
::   WY: 0 - wystąpił błędy, rekord nie zostanie zmodfikowany / 1 - ok
::----------------------------------------------------------------------------------------------------------------------
_ok:=1;
_buffer_grp:={? var_pres('_a')>100 || _a || return(0) ?};

:: Czy zmodyfikowano wyłącznie pole z kontrahentem (pomijana walidacja pól dotyczących planowania)
_kh_only:={? var_pres('KH_ONLY',_buffer_grp)=type_of(0) || _buffer_grp.KH_ONLY || 0 ?};
::Kontrahent
{? _buffer_grp.KONTRAH<>null() & ZGP.KONTRAH<>_buffer_grp.KONTRAH
|| ZGP.KONTRAH:=_buffer_grp.KONTRAH
?};

{? _kh_only=0
||
:: Dni na kooperacje
   {? _buffer_grp.DAYS_K<>0 & ZGP.DAYS_K<>_buffer_grp.DAYS_K
   || ZGP.DAYS_K:=_buffer_grp.DAYS_K
   ?};
:: Zasób kooperacyjny
   {? _buffer_grp.PX_KONT<>null() & ZGP.PX_KONT<>_buffer_grp.PX_KONT
   || ZGP.PX_KONT:=_buffer_grp.PX_KONT;
      _ok:=exec('kooperacyjny','px_kont',ZGP.PX_KONT)
   ?};
   {? _ok>0
   ||
::    Data - początek
      {? _buffer_grp.STARTDK<>date(0,0,0) & ZGP.STARTDK<>_buffer_grp.STARTDK
      || ZGP.STARTDK:=_buffer_grp.STARTDK
      ?};
      {? _buffer_grp.STARTTK<>time(0,0,0) & ZGP.STARTTK<>_buffer_grp.STARTTK
      || ZGP.STARTTK:=_buffer_grp.STARTTK
      ?};
::    Data - koniec
      {? _buffer_grp.ENDDK<>date(0,0,0) & ZGP.ENDDK<>_buffer_grp.ENDDK
      || ZGP.ENDDK:=_buffer_grp.ENDDK
      ?};
      {? _buffer_grp.ENDTK<>time(0,0,0) & ZGP.ENDTK<>_buffer_grp.ENDTK
      || ZGP.ENDTK:=_buffer_grp.ENDTK
      ?}
   ?};
   {? _ok>0
   ||
::    Końcowa walidacja ZGP
      _res:=exec('plan_out_chk','zl_guide');
      {? (type_of(_res)=type_of(0) & _res=0) | (type_of(_res)=type_of('') & _res<>'')
      || _ok:=0
      ?}
   ?}
?};
_ok


\zgpo_efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Ustawia opcje pól w oknie redagowania PLAN_OUT tabeli ZGP - dane do planowania
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_red:='PLAN_OUT';
_mark:=1;
{? type_of(params_get())>0 & var_pres('buffer',params_get())>100
|| _buffer_old:=params_get().buffer;
   _buffer_new:=exec('obj_new','#buf','ZGP',);
   _buffer_new.get();
   {? ~exec('compare','#table',_buffer_old,_buffer_new,0,'KONTRAH')
      & ZGP.DAYS_K=0 & ZGP.PX_KONT=null() & ZGP.STARTDK=date(0,0,0) & ZGP.ENDDK=date(0,0,0)
   ||
::    Zmodyfikowano kontrahenta, a pola dot. planowania nie są wypełnione, nie wymagane ich wypełnienie
      _mark:=0
   ?}
?};
ZGP.efld_opt(_red,'mark=%1'[$_mark],,'PX_KONT');
ZGP.efld_opt(_red,'mark=%1'[$_mark],,'STARTDK');
ZGP.efld_opt(_red,'mark=%1'[$_mark],,'ENDDK');
~~


\icon_tranZ
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [23.25]
:: OPIS: Ikona symbolizujaca informację o dyspozycji transportowej
::----------------------------------------------------------------------------------------------------------------------
_tra:=exec('czyTRANSPORT','transport_wspolne',ZGP.uidref(),,'Z');
{? _tra
|| exec('transpZ','icon')
|| exec('pusta','#icon')
?}


\icon_tranR
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [23.25]
:: OPIS: Ikona symbolizujaca informację o dyspozycji transportowej
::----------------------------------------------------------------------------------------------------------------------
_tra:=exec('czyTRANSPORT','transport_wspolne',ZGP.uidref(),,'R');
{? _tra
|| exec('transpDO','icon')
|| exec('pusta','#icon')
?}

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:38 c51897fd19a8f55627d544ba623810a713448a2804c2775e26f4a35d14da4a961e5fd2315b86a2cf552960a719652bf7421099a576a3d871083539b9fa57b0143cc10961a9454d162f21cc6fb3ec6f8a6268e00c4bef08503bf9eb450aab229e568369da704b02a2647652f8e1c5d39ee45057bceeaea97a8f3d0fb3e16fbcfe
