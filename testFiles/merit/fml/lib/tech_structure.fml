:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: tech_structure.fml
:: Utworzony: 05.03.2018
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły do obsługi struktury produktów
::======================================================================================================================


\env_create
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Tworzy obiekt środowiska obsługującego strukturę produktu
::   WE: _a - dostępność przeliczania i pól z datami
::----------------------------------------------------------------------------------------------------------------------
exec('env_delete','tech_structure');
__ENV_STR:=_env:=obj_new('CFG','STRUCT','ELEMENT','CUMULATED','BUF','PARAMS','KOMM','SELECTED','CHECK');
_env.STRUCT:=obj_new('TAB','WERS','WERE','NDX');
_env.ELEMENT:=obj_new('TAB','WER','NDX');
_env.CUMULATED:=obj_new('TAB','WER','NDX','NDXW');
_env.BUF:=obj_new('TAB','NDX');
_env.PARAMS:=obj_new('IL','DW','DRILL');
_env.KOMM:=obj_new(@.CLASS.JCQ); _env.KOMM.init(,,'Analiza surowców'@);
_env.SELECTED:=obj_new('TAB','NDX');
_env.CHECK:=obj_new('TAB','TAB_ZAM','WERZ','WERA','REDA2','REDA3','REDZ2','REDZ3','NDX');

:: Zmienne konfiguracyjne
_env.CFG:=obj_new('EARLIER','T_PRIMARY','T_STRUCT','CALC_KIND','COUNT');
:: ile dni wcześniej zakończyć produkcję półfabrykatów (ujęcie uproszczone)
_env.CFG.EARLIER:=1;
:: czy pokazywać zakładkę surowców podstawowych
_env.CFG.T_PRIMARY:=1;
:: czy pokazywac zakładkę struktury produktów
_env.CFG.T_STRUCT:=1;
:: sposób przeliczania: 1 - prosty, 2 - wg czasu produkcji
_env.CFG.CALC_KIND:=1;
:: dostępność przeliczania i pól z datami
_env.CFG.COUNT:=_a;

:: tabela zawierająca elementy struktury produktów
_env.STRUCT.TAB:=tab_tmp(4
   ,'PARENT','TREE_REF',''
   ,'M_KTM','STRING[50]','Indeks'@
   ,'POW','STRING[1]','Powierzony'@
   ,'SO','STRING[1]','Odpad'@
   ,'M_N','STRING[100]','Nazwa'@
   ,'M','STRING[16]','$M.ref()'
   ,'IL','REAL','Ilość'@
   ,'JM','STRING[10]','jm'@
   ,'DW','DATE','Data wymagana'@
   ,'TW','TIME','Godzina wymagana'@
   ,'XW','REAL','Znacznik czasowy'@
   ,'T_NRK','STRING[50]','Numer karty'@
   ,'T_WER','STRING[6]','Wersja karty'@
   ,'TKTL','STRING[16]','$TKTL.ref()'
   ,'MG_SYM','STRING[8]','Magazyn'@
   ,'MG','STRING[16]','$MG.ref()'
   ,'SRC_REF','STRING[16]','$ZK_P.ref(), $ZL.ref(), $TKTL.ref(): ref() pozycji źródłowej'
   ,'SRC','STRING[255]','Pozycja źródłowa'@
   ,'NORM_REF','STRING[16]','$TMAT.ref(), $PX_SUR.ref() lub inny ref() źródła normy'
   ,'SD','REAL','Stan dostępny'
   ,'WDR','REAL','W drodze'
   ,'OMIT','STRING[1]','Pomijać przy analizie zapotrzebowania (element rozwinięty)'@
   ,'STRUCT','STRING[1]','Pole, na podstawie którego wiem, że jest to tabela STRUCT'
);

_env.CUMULATED.TAB:=tab_tmp(4
   ,'PARENT','TREE_REF',''
   ,'M_KTM','STRING[50]','Indeks'@
   ,'POW','STRING[1]','Powierzony'@
   ,'SO','STRING[1]','Odpad'@
   ,'M_N','STRING[100]','Nazwa'@
   ,'M','STRING[16]','$M.ref()'
   ,'IL','REAL','Ilość'@
   ,'JM','STRING[10]','jm'@
   ,'DW','DATE','Data wymagana'@
   ,'TW','TIME','Godzina wymagana'@
   ,'XW','REAL','Znacznik czasowy'@
   ,'T_NRK','STRING[50]','Numer karty'@
   ,'T_WER','STRING[6]','Wersja karty'@
   ,'TKTL','STRING[16]','$TKTL.ref()'
   ,'MG_SYM','STRING[8]','Magazyn'@
   ,'MG','STRING[16]','$MG.ref()'
   ,'SRC_REF','STRING[16]','$ZK_P.ref(), $ZL.ref(), $TKTL.ref(): ref() pozycji źródłowej'
   ,'SRC','STRING[255]','Pozycja źródłowa'@
   ,'NORM_REF','STRING[16]','$TMAT.ref(), $PX_SUR.ref() lub inny ref() źródła normy'
   ,'SD','REAL','Stan dostępny'
   ,'WDR','REAL','W drodze'
   ,'OMIT','STRING[1]','Pomijać przy analizie zapotrzebowania (element rozwinięty)'@
   ,'STRUCT','STRING[1]','Pole, na podstawie którego wiem, że jest to tabela STRUCT'
);

_env.STRUCT.TAB.fld_fml('POW','DISPLAY_FORMAT',"'empty=1'");
_env.STRUCT.TAB.fld_fml('SO','DISPLAY_FORMAT',"'empty=1'");

:: indeksy STRUCT.TAB
_env.STRUCT.NDX:=obj_new('TREE','OMIT');
_env.STRUCT.NDX.TREE:=_env.STRUCT.TAB.index('?');
_env.STRUCT.NDX.OMIT:=_env.STRUCT.TAB.ndx_tmp(,,'OMIT',,,'M_KTM',,);

:: okna STRUCT.TAB
_env.STRUCT.WERE:=exec('mk_sel_struct','tech_structure',1);
_env.STRUCT.WERS:=exec('mk_sel_struct','tech_structure',2);

_env.CUMULATED.NDX:=_env.CUMULATED.TAB.ndx_tmp(,,'M',,,'POW',,,'SO',,,'OMIT',,);
_env.CUMULATED.NDXW:=_env.CUMULATED.TAB.ndx_tmp(,,'OMIT',,,'M_KTM',,);
_env.CUMULATED.WER:=exec('mk_sel_struct','tech_structure',3);
_env.CUMULATED.TAB.fld_fml('POW','DISPLAY_FORMAT',"'empty=1'");
_env.CUMULATED.TAB.fld_fml('SO','DISPLAY_FORMAT',"'empty=1'");

:: tabela zawierająca pogrupowane Surowce wg zapotrzebowań
_env.ELEMENT.TAB:=tab_tmp(4
   ,'PARENT','TREE_REF',''
   ,'LABEL','STRING[255]','Indeks / pozycja źródłowa'@
   ,'POW','STRING[1]','Powierzony'@
   ,'SO','STRING[1]','Odpad'@
   ,'M_KTM','STRING[50]','Indeks'@
   ,'M_N','STRING[100]','Nazwa'@
   ,'M','STRING[16]','$M.ref()'
   ,'IL','REAL','Ilość'@
   ,'JM','STRING[10]','jm'@
   ,'DW','DATE','Data wymagana'@
   ,'TW','TIME','Godzina wymagana'@
   ,'XW','REAL','Znacznik czasowy'@
   ,'SRC_REF','STRING[16]','$ZK_P.ref(), $ZL.ref(), $TKTL.ref(): ref() pozycji źródłowej'
   ,'SRC','STRING[255]','Pozycja źródłowa'@
   ,'NORM_REF','STRING[16]','$TMAT.ref(), $PX_SUR.ref() lub inny ref() źródła normy'
   ,'SD','REAL','Stan dostępny'
   ,'WDR','REAL','W drodze'
   ,'OMIT','STRING[1]','Pomijać przy analizie zapotrzebowania (element źródłowy)'@
   ,'ELEMENT','STRING[1]','Pole, na podstawie którego wiem, że jest to tabela ELEMENT'
);
_env.ELEMENT.TAB.fld_fml('POW','DISPLAY_FORMAT',"'empty=1'");
_env.ELEMENT.TAB.fld_fml('SO','DISPLAY_FORMAT',"'empty=1'");
_env.ELEMENT.TAB.fld_fml('SD','DISPLAY_FORMAT',"{? cur_tab(1,1).SRC_REF<>'' || 'empty=1' || 'empty=0' ?}");
_env.ELEMENT.TAB.fld_fml('WDR','DISPLAY_FORMAT',"{? cur_tab(1,1).SRC_REF<>'' || 'empty=1' || 'empty=0' ?}");

:: indeksy ELEMENT.TAB
_env.ELEMENT.NDX:=obj_new('TREE','MOD');
_env.ELEMENT.NDX.TREE:=_env.ELEMENT.TAB.index('?');
_env.ELEMENT.NDX.MOD:=_env.ELEMENT.TAB.ndx_tmp(,,'M',,,'POW',,,'SO',,,'OMIT',,,'DW',,,'TW',,);

:: okna ELEMENT.TAB
_env.ELEMENT.WER:=exec('mk_sel_element','tech_structure');

:: tabela zawierająca zaznaczone rekordy do analizy - musi być jako element pośredni
:: (sortowana wg terminu zapotrzebowania)
_env.BUF.TAB:=tab_tmp(1,
   'XW','REAL','Znacznik czasowy'@,
   'REF','INTEGER','#ref() tabeli'
);

:: indeks tabeli BUF.TAB
_env.BUF.NDX:=_env.BUF.TAB.index('?');

:: parametry
_env.PARAMS.IL:=0;
_env.PARAMS.DW:=date(0,0,0);
_env.PARAMS.DRILL:=1;

:: pomocnicza tabela zawierająca zaznaczone rekordy źródłowe
:: (używana np. dla zleceń w celu eliminacji nadmiarowych elementów)
_env.SELECTED.TAB:=tab_tmp(1,
   'REF','INTEGER','#ZL.ref()',
   'OMIT','STRING[1]','Czy pomijać w przetwarzaniu'
);
_env.SELECTED.NDX:=_env.SELECTED.TAB.index('?');

::   Tabela z informajcą o napotkanych problemach
_env.CHECK.TAB:=tab_tmp(5,
   'NRK','STRING[30]','Numer karty',
   'WER','STRING[6]','Wersja',
   'TMAT','STRING[16]','REF TMAT',
   'KTLZ','STRING[16]','REF KTL',
   'KTM','STRING[16]','REF KTM',
   'POW','STRING[30]','Powód',
   'AKCJA','STRING[25]','Akcja',
   'A','STRING[1]','Znak akcji',
   'KTLW','STRING[16]','REF do wskazanego KTL',
   'KTLW_NRK','STRING[30]','Numer karty wskazanego KTL',
   'KTM_NAZ','STRING[50]','Nazwa materiału',
   'ARCH','STRING[1]','Czy archiwalana',
   'KTLW_WER','STRING[6]','Wersja karty wskazanej'
);

::   Tabela z informajcą o zamiennikach
_env.CHECK.TAB_ZAM:=tab_tmp(2,
   'TMAT','STRING[16]','REF TMAT',
   'KTLW','STRING[16]','REF do wskazanego KTL'
);

:: okna tabeli CHECK.TAB
_env.CHECK.WERA:=exec('tktl_chck_mk_sel','tech_structure',1);
_env.CHECK.WERZ:=exec('tktl_chck_mk_sel','tech_structure',0);
_env.CHECK.REDZ2:=exec('tktl_chck_mk_edit','tech_structure',0,0);
_env.CHECK.REDZ3:=exec('tktl_chck_mk_edit','tech_structure',0,1);
_env.CHECK.REDA2:=exec('tktl_chck_mk_edit','tech_structure',1,0);
_env.CHECK.REDA3:=exec('tktl_chck_mk_edit','tech_structure',1,1);

_env


\env_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Usuwa obiekt obsługujący strukturę produktu
::----------------------------------------------------------------------------------------------------------------------
VAR_DEL.delete('__ENV_STR');
~~


\add_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Argument formuły exec('add','tech_structure')
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PARENT','M','IL','DW','TW','TKTL','MG','SRC_REF','NORM_REF','ref');

:: gałąź drzewa struktury
_args.PARENT:=0;
:: Materiał (produkt)
_args.M:=null();
:: Ilość
_args.IL:=0;
:: Data wymagana
_args.DW:=date(0,0,0);
:: Godzina wymagana
_args.TW:=time(0,0,0);
:: Karta technologiczna
_args.TKTL:=null();
:: Magazyn
_args.MG:=null();
:: $ref() pozycji źródłowej
_args.SRC_REF:='';
:: $ref() źródła normy
_args.NORM_REF:='';
:: ref() dodanego rekordu
_args.ref:=null();

_args


\add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Dodaje element struktury
::   WE: _a - argumety wywołania exec('args','tech_structure')
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_tab:=__ENV_STR.STRUCT.TAB;
_tab.cntx_psh();

_tab.blank();
_tab.PARENT:=_args.PARENT;
_tab.M:=$_args.M;
_tab.M_KTM:=exec('FindAndGet','#table',M,_args.M,,"KTM",'');
_tab.M_N:=exec('FindAndGet','#table',M,_args.M,,"N",'');
_tab.DW:=_args.DW;
_tab.TW:=_args.TW;
_tab.XW:=exec('create','#tm_stamp',_tab.DW,_tab.TW);
_tab.TKTL:=$_args.TKTL;
{? _tab.TKTL<>''
|| _tab.T_NRK:=exec('FindAndGet','#table',TKTL,_tab.TKTL,,"NRK",'');
   _tab.T_WER:=exec('FindAndGet','#table',TKTL,_tab.TKTL,,"WER",'')
?};
_tab.MG:=$_args.MG;
{? _tab.MG<>''
|| _tab.MG_SYM:=exec('FindAndGet','#table',MG,_tab.MG,,"SYM",'')
?};
{? _args.SRC_REF<>''
|| _tab.SRC_REF:=_args.SRC_REF;
   _tab.SRC:=exec('record','#to_string',_args.SRC_REF,1)
?};
{? _args.NORM_REF<>''
|| _tab.NORM_REF:=_args.NORM_REF;
   {? ref_tab(_args.NORM_REF)=TMAT
   || _tab.POW:=exec('FindAndGet','#table',TMAT,_tab.NORM_REF,,"POW",'N');
      _tab.SO:=exec('FindAndGet','#table',TMAT,_tab.NORM_REF,,"SO",'S')
   || _tab.POW:='N';
      _tab.SO:='S'
   ?}
|| _tab.POW:='';
   _tab.SO:=''
?};
_tab.IL:={? _tab.SO='O' || -_args.IL || _args.IL ?};
_tab.JM:=exec('FindAndGet','#table',M,_args.M,,"M.J().KOD",'');
exec('zwr_stan','magazyn_stan',_args.M,5,null(),0);
_tab.SD:=BEER.SD;
_tab.WDR:=BEER.WDR;
_tab.OMIT:='N';
{? _tab.add() || _args.ref:=_tab.ref() ?};

_tab.cntx_pop();
~~


\mk_sel_struct
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Tworzy okno selekcji tabeli struktury produktu
::   WE: _a - opcja: 1 (surowce podstawowe - nie kumulowane), 2 (drzewo struktury), 3 (surowce podstawowe - kumulowane)
::----------------------------------------------------------------------------------------------------------------------
_choice:=_a;
_env:=__ENV_STR;
{? _choice=3
|| _tab:=_env.CUMULATED.TAB
|| _tab:=_env.STRUCT.TAB
?};
_count:=_env.CFG.COUNT;

_wer:=_tab.mk_sel(
   {? _choice=2 || 'Struktura produktów'@ |? _choice=1 || 'Szczegółowa lista surowców'@ |? _choice=3 || 'Lista surowców'@  ?},
   'N',,'tech_struct'+$_choice+$_count,,,,_choice=2,{? _choice=2 || 'N' || 'U' ?}
);

_tab.win_fld(_wer,,'M_KTM',,,30);
_tab.win_fld(_wer,,'IL',,,-15,ST.DOKL);
_tab.win_fld(_wer,,'JM',,,-6);
_tab.win_fld(_wer,,'POW',,,-3,,,,,'Surowiec powierzony (T - tak, N - nie)'@);
_formula:="{? fld()='T' || 'xwin16.png:179' |? fld()='N' || 'xwin16.png:180' || '' ?}";
_tab.win_fml(_wer,,'POW',,'ICON_BEFORE',_formula);
_tab.win_fld(_wer,,'SO',,,-3,,,,,'Znacznik odpadu (O - odpad/koprodukt, S - surowiec)'@);
_formula:="{? fld()='O' || 'xwin16.png:179' |? fld()='S' || 'xwin16.png:180' || '' ?}";
_tab.win_fml(_wer,,'SO',,'ICON_BEFORE',_formula);
{? _count || _tab.win_fld(_wer,,'DW') ?};
::_tab.win_fld(_wer,,'TW');
{? _choice=2
|| _tab.win_fld(_wer,,'SRC',,,35);
   _tab.win_fml(_wer,,'SRC',,'ICON_BEFORE',"params_exec('icon_src','tech_structure')");
   _tab.win_fld(_wer,,'T_NRK',,,25);
   _tab.win_fld(_wer,,'T_WER',,,-6)
?};
_tab.win_fld(_wer,,'SD',,,-15,ST.DOKL);
_tab.win_fld(_wer,,'WDR',,,-15,ST.DOKL);
::_tab.win_fld(_wer,,'MG_SYM');
::_tab.win_fld(_wer,,'SRC_REF');

{? _choice=2;0
|| _formula:="
      TKTLW.win_sel('WER_P');
      TKTLW.index('KSN');
      TKTLW.prefix('T',ZL.KTM,'T','N');
      {? TKTLW.first()
      ||
         TKTLW.find_key(VAR.ZRED_KTL,VAR.RED_WER);
         {? TKTLW.select(,1,10)
         ||
::            ZL.KTL:=TKTLW.TKTL;
::            ZL.RKTL:=$ZL.KTL;
::            VAR.ZRED_KTL:=TKTLW.TKTL().NRK;
::            VAR.RED_WER:=TKTL.WER
            ~~
         ?}
      ||
         FUN.info('Wskazany produkt nie ma technologii.'@)
      ?};
      ~~
   ";
   _tab.win_act(_wer,,'Formuła','Popraw'@@,,,_formula)
?};
{? _choice=2
|| _formula:="exec('zwin_rozwin','#tree')";
   _tab.win_act(_wer,,'Formuła','Zwiń/roz&wiń'@@,,'Zwiń/rozwiń wszystkie rekordy'@,_formula,,,,,,'W')
?};
{? _count
|| _tab.win_act(_wer,,'Formuła','Analiza'@@,,,
      "exec('analiza_b','tech_structure',cur_tab(1,1))","exec('analiza_a','tech_structure')",,1,
      "exec('analiza_bg','tech_structure')","exec('analiza_ag','tech_structure',cur_tab(1,1))",'A'
   )
?};
_formula:="exec('info_zam','magazyn_stan',5,exec('FindAndGet','#table',M,cur_tab(1,1).M))";
_tab.win_act(_wer,,'Formuła','Szcz&egóły'@@,,'Szczegóły indeksu'@,_formula,,,,,,'E');
_formula:="
   VAR.A_T:=exec('FindAndGet','#table',M,cur_tab(1,1).M);
   VAR.REAL:=VAR.REAL2:=0;
   exec('stan_x','magazyn_stan','M')
";
_tab.win_act(_wer,,'Formuła','S&tany'@@,,,_formula,,,,,,'T');
_formula:="exec('legenda','color','__T_STR#01#01','#__T_STR#01')";
_tab.win_act(_wer,,'Formuła','Legenda'@@,,,_formula,,,,,,'L');
_tab.win_act(_wer,,'Rekord',,,,"exec('record_before','tech_structure',_a)");
_tab.win_act(_wer,,'Wyświetl',,,,"exec('display','tech_structure')");

{? _count
|| _btn:=_tab.win_btn(_wer,'text='+'Analiza'@,'menu:A');
   _tab.btn_sopt(_wer,_btn,'tooltip='+'Analiza dostępności materiałów w czasie'@)
?};
_btn:=_tab.win_btn(_wer,'text='+'Szcz&egóły'@,'menu:E');
_tab.btn_sopt(_wer,_btn,'tooltip='+'Szczegóły indeksu'@);
_tab.win_btn(_wer,'text='+'S&tany'@,'menu:T');
{? _choice=2 || _tab.win_btn(_wer,'text='+'Zwiń/roz&wiń'@,'menu:W') ?};

_wer


\mk_sel_element
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Tworzy okno selekcji tabeli surowców elementarnych
::----------------------------------------------------------------------------------------------------------------------
_env:=__ENV_STR;
_tab:=_env.ELEMENT.TAB;
_count:=_env.CFG.COUNT;

_wer:=_tab.mk_sel('Surowce wg zapotrzebowań'@,'N',,'tech_structure'+$_count,,,,1);

_tab.win_fld(_wer,,'LABEL',,,30);
_tab.win_fml(_wer,,'LABEL',,'ICON_BEFORE',"params_exec('icon_src','tech_structure')");
_tab.win_fld(_wer,,'IL',,,-15,ST.DOKL);
_tab.win_fld(_wer,,'JM',,,-6);
_tab.win_fld(_wer,,'POW',,,-3,,,,,'Surowiec powierzony (T - tak, N - nie)'@);
_formula:="{? fld()='T' || 'xwin16.png:179' |? fld()='N' || 'xwin16.png:180' || '' ?}";
_tab.win_fml(_wer,,'POW',,'ICON_BEFORE',_formula);
_tab.win_fld(_wer,,'SO',,,-3,,,,,'Znacznik odpadu (O - odpad/koprodukt, S - surowiec)'@);
_formula:="{? fld()='O' || 'xwin16.png:179' |? fld()='S' || 'xwin16.png:180' || '' ?}";
_tab.win_fml(_wer,,'SO',,'ICON_BEFORE',_formula);
{? _count || _tab.win_fld(_wer,,'DW') ?};
_tab.win_fld(_wer,,'SD',,,-15,ST.DOKL);
_tab.win_fld(_wer,,'WDR',,,-15,ST.DOKL);
::_tab.win_fld(_wer,,'TW');
::_tab.win_fld(_wer,,'MG_SYM');

_formula:="exec('zwin_rozwin','#tree')";
_tab.win_act(_wer,,'Formuła','Zwiń/roz&wiń'@@,,'Zwiń/rozwiń wszystkie rekordy'@,_formula,,,,,,'W');
{? _count
|| _tab.win_act(_wer,,'Formuła','Analiza'@@,,,
      "exec('analiza_b','tech_structure',cur_tab(1,1))","exec('analiza_a','tech_structure')",,1,
      "exec('analiza_bg','tech_structure')","exec('analiza_ag','tech_structure',cur_tab(1,1))",'A'
   )
?};
_formula:="exec('info_zam','magazyn_stan',5,exec('FindAndGet','#table',M,cur_tab(1,1).M))";
_tab.win_act(_wer,,'Formuła','Szcz&egóły'@@,,'Szczegóły indeksu'@,_formula,,,,,,'E');
_formula:="
   VAR.A_T:=exec('FindAndGet','#table',M,cur_tab(1,1).M);
   VAR.REAL:=VAR.REAL2:=0;
   exec('stan_x','magazyn_stan','M')
";
_tab.win_act(_wer,,'Formuła','S&tany'@@,,,_formula,,,,,,'T');
_formula:="exec('legenda','color','__T_STR#01#01','#__T_STR#01')";
_tab.win_act(_wer,,'Formuła','Legenda'@@,,,_formula,,,,,,'L');
_tab.win_act(_wer,,'Rekord',,,,"exec('record_before','tech_structure',_a)");
_tab.win_act(_wer,,'Wyświetl',,,,"exec('display','tech_structure')");

{? _count
|| _btn:=_tab.win_btn(_wer,'text='+'Analiza'@,'menu:A');
   _tab.btn_sopt(_wer,_btn,'tooltip='+'Analiza dostępności materiałów w czasie'@)
?};
_btn:=_tab.win_btn(_wer,'text='+'Szcz&egóły'@,'menu:E');
_tab.btn_sopt(_wer,_btn,'tooltip='+'Szczegóły indeksu'@);
_tab.win_btn(_wer,'text='+'S&tany'@,'menu:T');
_tab.win_btn(_wer,'text='+'Zwiń/roz&wiń'@,'menu:W');

_wer


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Selekcja surowców elementarnych w różnych układach i struktury produktów w oknie grupowym z zakładkami
::----------------------------------------------------------------------------------------------------------------------
_env:=__ENV_STR;
params_set('env',_env);

_element:=_env.ELEMENT; _wer:=_env.ELEMENT.WER;
_struct:=_env.STRUCT; _wers:=_env.STRUCT.WERS; _were:=_env.STRUCT.WERE;
_cumulated:=_env.CUMULATED; _werc:=_env.CUMULATED.WER;

'Sposób przeliczania'@; 'prosty'@; 'wg czasu produkcji'@;
'Liczba dni na wykonanie półfabrykatu'@; 'Przelicz'@; 'Surowce podstawowe'@; 'Struktura produktów'@;
'Analiza wykonana dla surowców na wszystkich poziomach'@; 'Analiza wykonana tylko dla surowców pierwszego poziomu'@;

_before:="
   _env:=params_get().env;
   _tab:=exec('elements_table','#desktop');

   _tab.blank();
   _tab.ID_SYS:='label_kind@panel';
   _tab.VALUE:='Sposób przeliczania'@;
   _tab.VISIBLE:={? _env.CFG.COUNT || 'true' || 'false' ?};
   _tab.add();

   _tab.blank();
   _tab.ID_SYS:='rbt_analiza_simply@panel';
   _tab.NAME:='prosty'@;
   _tab.VALUE:={? _env.CFG.CALC_KIND=1 || 'true' || 'false' ?};
   _tab.VISIBLE:={? _env.CFG.COUNT || 'true' || 'false' ?};
   _tab.add();

   _tab.blank();
   _tab.ID_SYS:='rbt_analiza_timeprod@panel';
   _tab.NAME:='wg czasu produkcji'@;
   _tab.VALUE:={? _env.CFG.CALC_KIND=2 || 'true' || 'false' ?};
   _tab.VISIBLE:={? _env.CFG.COUNT || 'true' || 'false' ?};
   _tab.add();

   _tab.blank();
   _tab.ID_SYS:='days@panel';
   _tab.NAME:='Liczba dni na półfabrykat'@;
   _tab.TOOLTIP:='Liczba dni na wykonanie półfabrykatu'@;
   _tab.VALUE:=$_env.CFG.EARLIER;
   _tab.VISIBLE:={? _env.CFG.COUNT || 'true' || 'false' ?};
   _tab.add();

   _tab.blank();
   _tab.ID_SYS:='btn_count@panel';
   _tab.NAME:='Przelicz'@;
   _tab.VISIBLE:={? _env.CFG.COUNT || 'true' || 'false' ?};
   _tab.add();

   _tab.blank();
   _tab.ID_SYS:='label_drill@panel';
   _tab.NAME:=
      {? _env.PARAMS.DRILL
      || 'Analiza wykonana dla surowców na wszystkich poziomach'@
      || 'Analiza wykonana tylko dla surowców pierwszego poziomu'@
      ?};
   _tab.add();

   exec('load','#desktop','selektor','tte_tech_structure.dsk',,,,,_tab,1);
   {? _env.CFG.T_PRIMARY=0 || tab_hide(2,,'panel') || tab_show(2,'panel') ?};
   {? _env.CFG.T_STRUCT=0 || tab_hide(3,,'panel') || tab_show(3,'panel') ?};
   grp_disp(_env.ELEMENT.TAB,_env.ELEMENT.WER,1,1);
   ~~
";
_grp:=_element.TAB.grp_make('Analiza surowców'@,_before,'#grpstruct',,,,,'html_maximized');
exec('create','#desktop',_element.TAB,'selektor',_grp,2);
_element.TAB.grp_splt(_grp,,'horizontal','panel',',10%');
_element.TAB.grp_sel(_grp,,_wer,'Surowce wg zapotrzebowań'@,,,,,,,,,'maximized','WER');
_fb:="
   _env:=params_get().env;
   _tab:=_env.CUMULATED.TAB;
   _tab.index(_env.CUMULATED.NDXW);
   _tab.prefix('N');
   _tab.first;
   ~~
";
_element.TAB.grp_sel(_grp,_cumulated.TAB,_werc,'Lista surowców'@,,,,,_fb,,,,'maximized','CUMULATED');
_fb:="
   _env:=params_get().env;
   _tab:=_env.STRUCT.TAB;
   _tab.index(_env.STRUCT.NDX.OMIT);
   _tab.prefix('N');
   _tab.first;
   ~~
";
_element.TAB.grp_sel(_grp,_struct.TAB,_were,'Szczegółowa lista surowców'@,,,,,_fb,,,,'maximized','DETAILS');
_fb:="
   _env:=params_get().env;
   _tab:=_env.STRUCT.TAB;
   _tab.index(_env.STRUCT.NDX.TREE);
   _tab.prefix();
   _tab.first;
   ~~
";
_element.TAB.grp_sel(_grp,_struct.TAB,_wers,'Struktura produktów'@,,,,,_fb,,,,'maximized','STRUCTURE');
_element.TAB.win_sel(_grp);

_element.TAB.index(_env.ELEMENT.NDX.TREE);
_element.TAB.prefix();
{? _element.TAB.size()
|| _element.TAB.first();
   _element.TAB.select(,,,,'WER')
|| _choice:=FUN.choice('Brak surowców do wyświetlenia.'@,,'Szczegóły'@);
   {? _choice=1
   || _env.KOMM.select()
   ?}
?};
~~


\analiza_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'przed' dla tabeli ...
::   WE: _a - tabela tymczasowa z obowiązkowymi z polami: M, IL, DW, TW, XW, OMIT
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

{? exec('is_pdbuf','plan_dostaw')
|| {? _tab.sel_size()=0
   || exec('env_create','plan_dostaw');
      exec('analiza_one','tech_structure',_tab);
      exec('an_select','plan_dostaw');
      exec('env_delete','plan_dostaw')

:: Dla akcji grupowej dodanie wskazania na rekord do tabeli buforowej sortowanej wg terminu
   || _buf:=__ENV_STR.BUF.TAB;
      _buf.blank();
      _buf.XW:=_tab.XW;
      _buf.REF:=#_tab.ref();
      _buf.add()
   ?}
?};
~~


\analiza_one
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Analiza dostępności materiałów w czasie - element akcji po grupie rekordów i przed rekordem
::   WE: _a - tabela tymczasowa z obowiązkowymi z polami: M, IL, DW, TW, XW, OMIT
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

{? _tab.OMIT<>'T'
|| _args:=exec('pda_a','plan_dostaw');
   _args.M:=exec('FindAndGet','#table',M,_tab.M);
   _args.TM_STAMP:=SYSLOG.tm_stamp();
   _args.DK:=date(0,0,0);
   _args.TK:=time(0,0,0);
   _args.IL:=_tab.IL;
   _args.DW:=_tab.DW;
   _args.TW:=_tab.TW;
   _args.DISP:=0;
   _mainver:=exec('get_mainversion','px_ver');
:: Dla tabeli ELEMENT wyłączenie zapisów z gałęzi
   {? var_pres('ELEMENT',_tab)=27
   || _tab.cntx_psh();
      _tab.prefix(_tab.ref());
      {? _tab.first()
      || {!
         |? {? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=PX_OBJ
            || PX_POZ.index('TM_VOBJ');
               PX_POZ.prefix(_mainver,exec('FindAndGet','#table',PX_OBJ,_tab.SRC_REF));
               PX_SUR.prefix();
               PX_SUR.f_set('STARTD,STARTT,M(KTM)',,'PX_SUR.PX_POZ in (select REFERENCE from prefixed_table(:_a))',PX_POZ);
               {? PX_SUR.f_first()
               || {!
                  |? _args.skip_add($PX_SUR.ref());
                     {? PX_SUR.ZLIM<>null()
                     || ZLIM.cntx_psh();
                        exec('openmask','zl_common',PX_SUR.ZL);
                        ZLIM.prefix();
                        {? ZLIM.seek(PX_SUR.ZLIM)
                        || _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
                           {? _zk_p<>null()
                           || _args.skip_add($_zk_p);
                              REZ.index('ZK_P');
                              REZ.prefix(_zk_p);
                              {? REZ.first()
                              || {!
                                 |? _args.skip_add($REZ.ref());
                                    REZ.next()
                                 !}
                              ?}
                           ?};
                           _args.skip_add($PX_SUR.ZLIM)
                        ?};
                        ZLIM.cntx_pop()
                     ?};
                     PX_SUR.f_next()
                  !}
               ?}
            |? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=ZL
            || ZLIM.cntx_psh();
               _zl:=exec('FindAndGet','#table',ZL,_tab.SRC_REF);
               exec('openmask','zl_common',_zl);
               ZLIM.index('ZKN');
               ZLIM.prefix(_zl);
               {? ZLIM.first()
               || {!
                  |? _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
                     {? _zk_p<>null()
                     || _args.skip_add($_zk_p);
                        REZ.index('ZK_P');
                        REZ.prefix(_zk_p);
                        {? REZ.first()
                        || {!
                           |? _args.skip_add($REZ.ref());
                              REZ.next()
                           !}
                        ?}
                     ?};
                     _args.skip_add($PX_SUR.ZLIM);
                     ZLIM.next()
                  !}
               ?};
               ZLIM.cntx_pop()
            ?};
            _tab.next()
         !}
      ?};
      _tab.cntx_pop()
:: Dla tabeli STRUCT wyłączenie zapisów z korzenia
   |? var_pres('STRUCT',_tab)=27
   || _tab.cntx_psh();
      _tab.prefix();
      _root:=exec('tree_root','#tree',_tab.ref());
      {? _tab.seek(_root)
      || {? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=PX_OBJ
         || PX_POZ.index('TM_VOBJ');
            PX_POZ.prefix(_mainver,exec('FindAndGet','#table',PX_OBJ,_tab.SRC_REF));
            PX_SUR.prefix();
            PX_SUR.f_set('STARTD,STARTT,M(KTM)',,'PX_SUR.PX_POZ in (select REFERENCE from prefixed_table(:_a))',PX_POZ);
            {? PX_SUR.f_first()
            || {!
               |? _args.skip_add($PX_SUR.ref());
                  {? PX_SUR.ZLIM<>null()
                  || ZLIM.cntx_psh();
                     exec('openmask','zl_common',PX_SUR.ZL);
                     ZLIM.prefix();
                     {? ZLIM.seek(PX_SUR.ZLIM)
                     || _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
                        {? _zk_p<>null()
                        || _args.skip_add($_zk_p);
                           REZ.index('ZK_P');
                           REZ.prefix(_zk_p);
                           {? REZ.first()
                           || {!
                              |? _args.skip_add($REZ.ref());
                                 REZ.next()
                              !}
                           ?}
                        ?};
                        _args.skip_add($PX_SUR.ZLIM)
                     ?};
                     ZLIM.cntx_pop()
                  ?};
                  PX_SUR.f_next()
               !}
            ?}
         |? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=ZL
         || ZLIM.cntx_psh();
            _zl:=exec('FindAndGet','#table',ZL,_tab.SRC_REF);
            exec('openmask','zl_common',_zl);
            ZLIM.index('ZKN');
            ZLIM.prefix(_zl);
            {? ZLIM.first()
            || {!
               |? _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
                  {? _zk_p<>null()
                  || _args.skip_add($_zk_p);
                     REZ.index('ZK_P');
                     REZ.prefix(_zk_p);
                     {? REZ.first()
                     || {!
                        |? _args.skip_add($REZ.ref());
                           REZ.next()
                        !}
                     ?}
                  ?};
                  _args.skip_add($PX_SUR.ZLIM);
                  ZLIM.next()
               !}
            ?};
            ZLIM.cntx_pop()
         ?}
      ?};
      _tab.cntx_pop()
   ?};
   _used:=exec('env_used_sum','plan_dostaw',_args.M);
   {? _used>0 || _args.insert_add($_args.M,_args.DW,_args.TW,_used) ?};
   _res:=exec('pda','plan_dostaw',_args);

   _argse:=exec('an_add_a','plan_dostaw');
   _argse.M:=_args.M;
   _argse.IL:=_args.IL;
   _argse.DW:=_args.DW;
   _argse.TW:=_args.TW;
   _argse.DOSTEPNY:=_res.DOSTEPNY;
   _argse.IL_DOST:=_res.IL_DOST;
   _argse.DM:=_res.NA_KIEDY;
:: Dla tabeli ELEMENT wyłączenie zapisów z gałęzi
   {? var_pres('ELEMENT',_tab)=27
   || _tab.cntx_psh();
      _tab.prefix(_tab.ref());
      {? _tab.first()
      || {!
         |? {? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=PX_OBJ
            || PX_POZ.index('TM_VOBJ');
               PX_POZ.prefix(_mainver,exec('FindAndGet','#table',PX_OBJ,_tab.SRC_REF));
               PX_SUR.prefix();
               PX_SUR.f_set('STARTD,STARTT,M(KTM)',,'PX_SUR.PX_POZ in (select REFERENCE from prefixed_table(:_a))',PX_POZ);
               {? PX_SUR.f_first()
               || {!
                  |? _argse.skip_add($PX_SUR.ref());
                     {? PX_SUR.ZLIM<>null()
                     || ZLIM.cntx_psh();
                        exec('openmask','zl_common',PX_SUR.ZL);
                        ZLIM.prefix();
                        {? ZLIM.seek(PX_SUR.ZLIM)
                        || _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
                           {? _zk_p<>null()
                           || _argse.skip_add($_zk_p);
                              REZ.index('ZK_P');
                              REZ.prefix(_zk_p);
                              {? REZ.first()
                              || {!
                                 |? _argse.skip_add($REZ.ref());
                                    REZ.next()
                                 !}
                              ?}
                           ?};
                           _argse.skip_add($PX_SUR.ZLIM)
                        ?};
                        ZLIM.cntx_pop()
                     ?};
                     PX_SUR.f_next()
                  !}
               ?}
            |? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=ZL
            || ZLIM.cntx_psh();
               _zl:=exec('FindAndGet','#table',ZL,_tab.SRC_REF);
               exec('openmask','zl_common',_zl);
               ZLIM.index('ZKN');
               ZLIM.prefix(_zl);
               {? ZLIM.first()
               || {!
                  |? _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
                     {? _zk_p<>null()
                     || _argse.skip_add($_zk_p);
                        REZ.index('ZK_P');
                        REZ.prefix(_zk_p);
                        {? REZ.first()
                        || {!
                           |? _argse.skip_add($REZ.ref());
                              REZ.next()
                           !}
                        ?}
                     ?};
                     _argse.skip_add($ZLIM.ref());
                     ZLIM.next()
                  !}
               ?};
               ZLIM.cntx_pop()
            ?};
            _tab.next()
         !}
      ?};
      _tab.cntx_pop()
:: Dla tabeli STRUCT wyłączenie zapisów z korzenia
   |? var_pres('STRUCT',_tab)=27
   || _tab.cntx_psh();
      _tab.prefix();
      _root:=exec('tree_root','#tree',_tab.ref());
      {? _tab.seek(_root)
      || {? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=PX_OBJ
         || PX_POZ.index('TM_VOBJ');
            PX_POZ.prefix(_mainver,exec('FindAndGet','#table',PX_OBJ,_tab.SRC_REF));
            PX_SUR.prefix();
            PX_SUR.f_set('STARTD,STARTT,M(KTM)',,'PX_SUR.PX_POZ in (select REFERENCE from prefixed_table(:_a))',PX_POZ);
            {? PX_SUR.f_first()
            || {!
               |? _argse.skip_add($PX_SUR.ref());
                  {? PX_SUR.ZLIM<>null()
                  || ZLIM.cntx_psh();
                     exec('openmask','zl_common',PX_SUR.ZL);
                     ZLIM.prefix();
                     {? ZLIM.seek(PX_SUR.ZLIM)
                     || _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
                        {? _zk_p<>null()
                        || _argse.skip_add($_zk_p);
                           REZ.index('ZK_P');
                           REZ.prefix(_zk_p);
                           {? REZ.first()
                           || {!
                              |? _argse.skip_add($REZ.ref());
                                 REZ.next()
                              !}
                           ?}
                        ?};
                        _argse.skip_add($PX_SUR.ZLIM)
                     ?};
                     ZLIM.cntx_pop()
                  ?};
                  PX_SUR.f_next()
               !}
            ?}
         |? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=ZL
         || ZLIM.cntx_psh();
            _zl:=exec('FindAndGet','#table',ZL,_tab.SRC_REF);
            exec('openmask','zl_common',_zl);
            ZLIM.index('ZKN');
            ZLIM.prefix(_zl);
            {? ZLIM.first()
            || {!
               |? _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
                  {? _zk_p<>null()
                  || _argse.skip_add($_zk_p);
                     REZ.index('ZK_P');
                     REZ.prefix(_zk_p);
                     {? REZ.first()
                     || {!
                        |? _argse.skip_add($REZ.ref());
                           REZ.next()
                        !}
                     ?}
                  ?};
                  _argse.skip_add($ZLIM.ref());
                  ZLIM.next()
               !}
            ?};
            ZLIM.cntx_pop()
         ?}
      ?};
      _tab.cntx_pop()
   ?};
   {? _used>0 || exec('env_used2insert','plan_dostaw',_argse) ?};
   _argse.insert_add($_args.M,_args.DW,_args.TW,_args.IL);
   exec('an_add','plan_dostaw',_argse);
   exec('env_used_add','plan_dostaw',_args.M,_args.DW,_args.TW,_args.IL)
?};
~~


\analiza_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'po' dla tabeli ...
::----------------------------------------------------------------------------------------------------------------------
~~


\analiza_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'przed grupą' dla tabeli ...
::----------------------------------------------------------------------------------------------------------------------
{? exec('is_pdbuf','plan_dostaw')
|| __ENV_STR.BUF.TAB.erase();
   exec('env_create','plan_dostaw')
|| 0
?}


\analiza_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'po grupie' dla tabeli ...
::   WE: _a - tabela tymczasowa z obowiązkowymi z polami: M, IL, DW, TW, XW, OMIT
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_tab.cntx_psh();
_tab.prefix();
:: analiza w kolejności terminów
_buf:=__ENV_STR.BUF.TAB;
_buf.index(__ENV_STR.BUF.NDX);
_buf.prefix();
{? _buf.first()
|| {!
   |? {? _tab.seek(_buf.REF)
      || exec('analiza_one','tech_structure',_tab)
      ?};
      _buf.next()
   !}
?};
_tab.cntx_pop();
:: wyświetlenie analizy
exec('an_select','plan_dostaw');
exec('env_delete','plan_dostaw')


\expand
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Rozwija strukturę elementu o jeden poziom (dla węzła będącego pozycją zamówienia albo wynikającą z rozwinięcia)
::       Uwzględniane są tylko surowce (bez zamienników) wg domyślnych wartości parametrów technologii
::       Dla grup technologicznych zwracane są indeksty domyślne
::       Karta półfabrykatu domyślna albo jawnie wskazana (wg wpisu w TMAT)
::       Termin wyliczany jest w oparciu o zmienną konfiguracyjną __ENV_STR.CFG.EARLIER
::   WE: _a - __ENV_STR.STRUCT.TAB.ref()
::----------------------------------------------------------------------------------------------------------------------
_tab_ref:=_a;
_env:=__ENV_STR;
_tab:=_env.STRUCT.TAB;

_tab.cntx_psh();
_tab.prefix();
{? _tab.seek(_tab_ref)
||
:: Pozycja z planu strategicznego
   {? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=PX_OBJ
   ||
::      do();
      _tab.OMIT:='T'; _tab.put();

      _args:=exec('add_a','tech_structure');
      _args.PARENT:=#_tab.ref();
      _ver:=exec('get_mainversion','px_ver');
      PX_POZ.cntx_psh(); PX_SUR.cntx_psh();
      PX_POZ.index('TM_VOBJ');
      PX_POZ.prefix(_ver,exec('FindAndGet','#table',PX_OBJ,_tab.SRC_REF,,"ref()",null()));
      PX_SUR.prefix();
      PX_SUR.f_set('STARTD,STARTT,M(KTM)',,'PX_SUR.PX_POZ in (select REFERENCE from prefixed_table(:_a))',PX_POZ);
      {? PX_SUR.f_first()
      || {!
         |? _args.M:=PX_SUR.M;
            _args.IL:=PX_SUR.IL;
            _args.DW:=PX_SUR.STARTD;
            _args.TW:=PX_SUR.STARTT;
            _args.NORM_REF:=$PX_SUR.ref();
            exec('add','tech_structure',_args);
            PX_SUR.f_next()
         !}
      ?};
      PX_SUR.f_clear();
      PX_POZ.cntx_pop(); PX_SUR.cntx_pop();
::      end();
      ~~

:: Wg wpisanej technologii
   |? _tab.TKTL<>''
   ||
::      do();
      _tab.OMIT:='T'; _tab.put();

      _args:=exec('add_a','tech_structure');
      _args.PARENT:=#_tab.ref();
      _il:=_tab.IL;
      exec('tktl_cntx_psh','tech_common');
      exec('tktl_use','tech_common',ref_name(_tab.TKTL)+3);
::    Dla uproszczenia surowce wykazywane są w kolejności od najwyższego numeru operacji
::    (nie są analizowane następniki operacji)
      TMAT.index('ANNL');
      TMAT.prefix('T',exec('FindAndGet','#table',TKTL,_tab.TKTL));
      {? TMAT.last()
      || {!
         |? _args.M:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};
            _args.IL:=TMAT.WARB*_il/TMAT.NRK().XJM;
            _ktl:=null();
            _added:=0;
            _arch:='N';
            {? var_pres('__ENV_STR')>0 & (var_pres('TAB_ZAM',__ENV_STR.CHECK)) >0 & __ENV_STR.CHECK.TAB_ZAM.find_tab(,'TMAT',,'=',$TMAT.ref)
            || _ktl:=exec('FindAndGet','#table',TKTL,__ENV_STR.CHECK.TAB_ZAM.KTLW,,,null())
            ||
               {? TMAT.DFLT_KTL='T'
               || _ktl:=exec('dflt_ktl','tech_prod',_args.M,,1);
                  {? _ktl=null()
                  || _txt:='Brak karty domyślnej'@;
                     _added:=1
                  |? ~exec('tktl_act','tech_head',,$_ktl)
                  || _txt:='Karta domyślna nieaktualna'@;
                     _added:=1
                  ?}
               || _ktl:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,,null);
                  {? _ktl<> null
                  || _arch:=exec('FindAndGet','#table',TKTL,_ktl,,"ARCH",'N');
                     {? _arch<>'N'
                     || _txt:='Karta archiwalna'@;
                        _added:=1
                     |? ~exec('tktl_act','tech_head',4)
                     || _txt:='Karta nieaktualna'@;
                        _added:=1
                     ?}
                  ?}
               ?}
            ?};
            {? _added=1
            || exec('tktl_chck_add','tech_structure',$_ktl,$TMAT.ref,_txt,TMAT.PT().N,
                     exec('FindAndGet','#table',TKTL,_ktl,,'NRK',''),exec('FindAndGet','#table',TKTL,_ktl,,'WER',''),
                     $TMAT.PT,{? _arch<>'N' || 'T' || 'N' ?})
            ?};
            _args.TKTL:=_ktl;
            _args.DW:=_tab.DW;
            _args.TW:=_tab.TW;
            {? _env.CFG.CALC_KIND=1
            || _args.DW-=_env.CFG.EARLIER
            |? _env.CFG.CALC_KIND=2
            || _args.DW-=exec('tmat_time','tech_structure',TMAT.ref(),_il/TMAT.NRK().XJM).DAYS
            ?};
            _args.NORM_REF:=$TMAT.ref();
            exec('add','tech_structure',_args);
            {? _added=0 || {? _env.PARAMS.DRILL || exec('expand','tech_structure',_args.ref) ?} ?};
            TMAT.prev()
         !}
      ?};
      exec('tktl_cntx_pop','tech_common');
::      end();
      ~~
   ?}
?};

_tab.cntx_pop();
~~


\cumulate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Kumulowanie surowców wg indeksu i daty wymaganej (przepisanie ze STRUCT.TAB do ELEMENT.TAB)
::       Budowane jest drzewo, którego liściami są źródłowe pozycje zamówień
::----------------------------------------------------------------------------------------------------------------------
_env:=__ENV_STR;
_struct:=_env.STRUCT;
_element:=_env.ELEMENT;
_cumulated:=_env.CUMULATED;

_element.TAB.cntx_psh();
_element.TAB.erase();
_element.TAB.index(_element.NDX.MOD);
_element.TAB.prefix();

_cumulated.TAB.cntx_psh();
_cumulated.TAB.erase();
_cumulated.TAB.index(_cumulated.NDX);
_cumulated.TAB.prefix();

_struct.TAB.cntx_psh();
_struct.TAB.index(_env.STRUCT.NDX.OMIT);
_struct.TAB.prefix('N');

{? _struct.TAB.first()
|| {!
   |? _parent:=0;
      _element.TAB.prefix(_struct.TAB.M,_struct.TAB.POW,_struct.TAB.SO,'N',_struct.TAB.DW,_struct.TAB.TW);
      {? _element.TAB.first()
      || _element.TAB.IL+=_struct.TAB.IL;
         _element.TAB.SD:=_struct.TAB.SD;
         _element.TAB.WDR:=_struct.TAB.WDR;
         {? _element.TAB.put() || _parent:=_element.TAB.ref() ?}
      || _element.TAB.blank();
         _element.TAB.M:=_struct.TAB.M;
         _element.TAB.M_KTM:=_struct.TAB.M_KTM;
         _element.TAB.M_N:=_struct.TAB.M_N;
         _element.TAB.IL:=_struct.TAB.IL;
         _element.TAB.JM:=_struct.TAB.JM;
         _element.TAB.POW:=_struct.TAB.POW;
         _element.TAB.SO:=_struct.TAB.SO;
         _element.TAB.DW:=_struct.TAB.DW;
         _element.TAB.TW:=_struct.TAB.TW;
         _element.TAB.XW:=_struct.TAB.XW;
         _element.TAB.OMIT:='N';
         _element.TAB.LABEL:=_element.TAB.M_KTM;
         _element.TAB.SD:=_struct.TAB.SD;
         _element.TAB.WDR:=_struct.TAB.WDR;
         {? _element.TAB.add() || _parent:=_element.TAB.ref() ?}
      ?};

      _cumulated.TAB.prefix(_struct.TAB.M,_struct.TAB.POW,_struct.TAB.SO,'N');
      {? _cumulated.TAB.first()
      || _cumulated.TAB.IL+=_struct.TAB.IL;
         _cumulated.TAB.SD:=_struct.TAB.SD;
         _cumulated.TAB.WDR:=_struct.TAB.WDR;
         {? _struct.TAB.XW<_cumulated.TAB.XW
         || _cumulated.TAB.DW:=_struct.TAB.DW;
            _cumulated.TAB.TW:=_struct.TAB.TW;
            _cumulated.TAB.XW:=_struct.TAB.XW
         ?};
         _cumulated.TAB.put()
      || _cumulated.TAB.blank();
         _cumulated.TAB.M:=_struct.TAB.M;
         _cumulated.TAB.M_KTM:=_struct.TAB.M_KTM;
         _cumulated.TAB.M_N:=_struct.TAB.M_N;
         _cumulated.TAB.IL:=_struct.TAB.IL;
         _cumulated.TAB.JM:=_struct.TAB.JM;
         _cumulated.TAB.POW:=_struct.TAB.POW;
         _cumulated.TAB.SO:=_struct.TAB.SO;
         _cumulated.TAB.DW:=_struct.TAB.DW;
         _cumulated.TAB.TW:=_struct.TAB.TW;
         _cumulated.TAB.XW:=_struct.TAB.XW;
         _cumulated.TAB.OMIT:='N';
::         _cumulated.TAB.LABEL:=_cumulated.TAB.M_KTM;
         _cumulated.TAB.SD:=_struct.TAB.SD;
         _cumulated.TAB.WDR:=_struct.TAB.WDR;
         _cumulated.TAB.prefix();
         _cumulated.TAB.add()
      ?};

      {? _parent<>0
      || _element.TAB.blank();
         _root:=exec('tree_root','#tree',_struct.TAB.ref());
         _element.TAB.PARENT:=_parent;
         _element.TAB.M:=_struct.TAB.M;
         _element.TAB.M_KTM:=_struct.TAB.M_KTM;
         _element.TAB.M_N:=_struct.TAB.M_N;
         _element.TAB.IL:=_struct.TAB.IL;
         _element.TAB.DW:=exec('FindAndGet','#table',_struct.TAB,_root,,"DW",date(0,0,0));
         _element.TAB.TW:=exec('FindAndGet','#table',_struct.TAB,_root,,"TW",time(0,0,0));
         _element.TAB.XW:=exec('create','#tm_stamp',_element.TAB.DW,_element.TAB.TW);
         _element.TAB.SRC_REF:=exec('FindAndGet','#table',_struct.TAB,_root,,"SRC_REF",'');
         _element.TAB.SRC:=exec('record','#to_string',_element.TAB.SRC_REF,1);
         _element.TAB.OMIT:='T';
         _element.TAB.LABEL:=_element.TAB.SRC;
         _element.TAB.NORM_REF:=_struct.TAB.NORM_REF;
         _element.TAB.prefix();
         _element.TAB.add()
      ?};

      _struct.TAB.next()
   !}
?};
_struct.TAB.cntx_pop();
_element.TAB.cntx_pop();
_cumulated.TAB.cntx_pop();
~~


\regenerate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Regeneruje całą strukturę
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

_struct:=_env.STRUCT;
_struct.TAB.cntx_psh();
_struct.TAB.index(_env.STRUCT.NDX.TREE);
_struct.TAB.prefix(0);
{? _struct.TAB.first()
|| {!
   |? exec('tree_del','#tree',_struct.TAB,_struct.TAB.ref());
      exec('expand','tech_structure',_struct.TAB.ref());
      _struct.TAB.next()
   !}
?};
_struct.TAB.cntx_pop();
exec('cumulate','tech_structure');
~~


\count_days
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Obsługa elementu days@panel
::       Przeliczenie struktury po zmianie ilości dni na wykonanie półfabrykatów
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;
_max_days:=999;
_days:=#exec('get_value','#desktop','','selektor','days@panel');
{? _days>_max_days
|| FUN.info('Należy podać liczbę mniejszą niż %1.'@[$(_max_days+1)])
|| _before:=_env.CFG.EARLIER;
   _env.CFG.EARLIER:=_days;

   {? _before<>_env.CFG.EARLIER
   || exec('regenerate','tech_structure');
      grp_disp(_env.ELEMENT.TAB,_env.ELEMENT.WER,1,1);
      grp_disp(_env.CUMULATED.TAB,_env.CUMULATED.WER,1,1);
      grp_disp(_env.STRUCT.TAB,_env.STRUCT.WERE,1,1);
      grp_disp(_env.STRUCT.TAB,_env.STRUCT.WERS,1,1)
   ?}
?};
~~


\chk_primary
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Obsługa elementu chk_primary@panel
::----------------------------------------------------------------------------------------------------------------------
_val:=exec('get_value','#desktop','','selektor','chk_primary@panel');
{? _val='true'
|| tab_show(2,'panel')
|| tab_hide(2,1,'panel')
?};
~~


\chk_struct
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Obsługa elementu chk_struct@panel
::----------------------------------------------------------------------------------------------------------------------
_val:=exec('get_value','#desktop','','selektor','chk_struct@panel');
{? _val='true'
|| tab_show(3,'panel')
|| tab_hide(3,1,'panel')
?};
~~


\rbt_analiza
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Obsługa elementów rbt_analiza_*@panel
::       Przeliczenie struktury po zmianie sposobu przeliczania elementów
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;
_analiza_simply:=exec('get_value','#desktop','','selektor','rbt_analiza_simply@panel');
_analiza_timeprod:=exec('get_value','#desktop','','selektor','rbt_analiza_timeprod@panel');
_before:=_env.CFG.CALC_KIND;
{? _analiza_simply='true'
|| _env.CFG.CALC_KIND:=1
|? _analiza_timeprod='true'
|| _env.CFG.CALC_KIND:=2
|| _env.CFG.CALC_KIND:=0
?};

_analiza_simply_active:=_env.CFG.CALC_KIND=1;
exec('set_enabled','#desktop','','selektor','days@panel',_analiza_simply_active);
exec('set_enabled','#desktop','','selektor','btn_count@panel',_analiza_simply_active);

{? _before<>_env.CFG.CALC_KIND
|| exec('regenerate','tech_structure');
   grp_disp(_env.ELEMENT.TAB,_env.ELEMENT.WER,1,1);
   grp_disp(_env.CUMULATED.TAB,_env.CUMULATED.WER,1,1);
   grp_disp(_env.STRUCT.TAB,_env.STRUCT.WERE,1,1);
   grp_disp(_env.STRUCT.TAB,_env.STRUCT.WERS,1,1)
?};
~~


\tmat_time
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Zwraca czas operacji przypisanej do surowca (lub pierwszej w karcie) i kolejnych do końca procesu
::   WE: _a - TMAT.ref()
::       _b - współczynnik wymnożenia norm operacji (nie dla Tpz)
::   WY: _obj
::----------------------------------------------------------------------------------------------------------------------
_tmat:=_a;
_coef:=_b;

:: Uwaga: do wyliczeń przydadzą się zamówione u HR-owców dodatkowe funkcje kalendarza
_res:=obj_new('DAYS');
_res.DAYS:=0;

exec('tktl_cntx_psh','tech_common');
exec('tktl_use','tech_common',ref_name(_tmat)+3);
TMAT.prefix(); TOPER.prefix();
{? TMAT.seek(_tmat)
|| _can_continue:=0;

:: Ustalenie początku przetwarzania operacji (operacja związana z surowcem albo pierwsza w procesie)
   _processed:=exec('toper_processed','px_oper');
   {? TMAT.NROP<>null()
   || _can_continue:=TOPER.seek(TMAT.NROP)
   || _can_continue:=exec('toper_first','px_oper',TMAT.NRK,_processed)
   ?};

   {? _can_continue>0
   || exec('toper_time','tech_structure',TOPER.ref(),_coef,_processed,_res)
   ?}

?};
exec('tktl_cntx_pop','tech_common');

_res


\toper_time
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Zwraca czas operacji, jej Tpz oraz kolejnych operacji (rekurencyjnie)
::       Założenie - praca na bieżącej masce tabel technologicznych
::   WE: _a - TOPER.ref()
::       _b - współczynnik wymnożenia norm operacji (nie dla Tpz)
::       _c - tab_tmp() - tablica z przetworzonymi juz TOPERami
::       _d - tablica wynikowa
::----------------------------------------------------------------------------------------------------------------------
_toper:=_a;
_coef:=_b;
_processed:=_c;
_res:=_d;

_ntime:=_mtime:=0;

TOPER.cntx_psh(); NASTOPER.cntx_psh();
TOPER.prefix();
{? TOPER.seek(_toper)
|| _ntime+=TOPER.NTIME*_coef;
   _mtime+=TOPER.MTIME*_coef;
   TOPER.cntx_psh();
   TOPER.index('TPZ');
   TOPER.prefix('T',TOPER.UNROP);
   {? TOPER.first()
   || _ntime+=TOPER.NTIME;
      _mtime+=TOPER.MTIME
   ?};
:: dni kalendarzowe 8-godzinne - uproszczenie ze względu na brak funkcji do obsługi kalendarza
   _res.DAYS+={? _mtime>_ntime || _mtime || _ntime ?}/8;
   TOPER.cntx_pop();
   NASTOPER.index('OPNAST');
   NASTOPER.prefix('T',TOPER.ref());
   {? NASTOPER.first()
   || {!
      |? exec('toper_time','tech_structure',NASTOPER.NRNAST,_coef,_processed,_res);
         NASTOPER.next()
      !}
   ?}
?};
TOPER.cntx_pop(); NASTOPER.cntx_pop();
~~


\icon_src
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Ikona źródła pozycji
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
{? _tab.SRC_REF<>'' &
   (ref_tab(_tab.SRC_REF)=ZK_P | ref_tab(_tab.SRC_REF)=ZL | ref_tab(_tab.SRC_REF)=TKTL | ref_tab(_tab.SRC_REF)=TKTLW)
|| 'xwin16.png:185'
|? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=PX_OBJ
|| exec('px_plan','icon')
|| ''
?}


\display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Wyświetla dane rekordu struktury
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
{? _tab.NORM_REF<>'' & ref_tab(_tab.NORM_REF)=TMAT & _tab.SRC_REF<>''
   & (ref_tab(_tab.SRC_REF)=TKTL | ref_tab(_tab.SRC_REF)=TKTLW)
|| exec('tktl_cntx_psh','tech_common');
   exec('tktl_use','tech_common',(8+_tab.NORM_REF)+3);
   TMAT.prefix();
   {? TMAT.seek(_tab.NORM_REF)
   || exec('tmat_display','tech_mater',1)
   ?};
   exec('tktl_cntx_pop','tech_common')
|? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=ZK_P
|| exec('FindAndGet','#table',ZK_P,_tab.SRC_REF,,"exec('wys_pozy','zamsiw_poz',1)")
|? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=PX_OBJ
|| exec('FindAndGet','#table',PX_OBJ,_tab.SRC_REF,,"exec('px_obj_display','px_obj')")
|? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=ZL
|| exec('FindAndGet','#table',ZL,_tab.SRC_REF,,"exec('zl_display','zl_head')")
|? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=TKTL
|| exec('tktl_cntx_psh','tech_common');
   exec('tktl_use','tech_common',(8+_tab.SRC_REF)+3);
   TKTL.prefix();
   {? TKTL.seek(_tab.SRC_REF)
   || TKTL.win_edit('RED');
      TKTL.display()
   ?};
   exec('tktl_cntx_pop','tech_common')
|? _tab.SRC_REF<>'' & ref_tab(_tab.SRC_REF)=TKTLW
|| exec('tktl_cntx_psh','tech_common');
   exec('tktl_use','tech_common',(8+_tab.SRC_REF)+3);
   TKTLW.prefix();
   {? TKTLW.seek(_tab.SRC_REF)
   || TKTLW.win_edit('RED_K');
      TKTLW.display()
   ?};
   exec('tktl_cntx_pop','tech_common')
|? _tab.NORM_REF<>'' & ref_tab(_tab.NORM_REF)=PX_SUR
|| PX_SUR.cntx_psh();
   PX_SUR.prefix();
   {? PX_SUR.seek(_tab.NORM_REF)
   || PX_SUR.win_edit('RED');
      PX_SUR.display()
   ?};
   PX_SUR.cntx_pop()
|? _tab.M<>''
|| M.cntx_psh();
   M.prefix();
   {? M.seek(_tab.M)
   || {? M.M_ATR_B<>null()
      || {! _i..10 |! ($('POM.SYM'+form(_i,-2,0,'99')))():=($('M.M_ATR_B().SL_'+form(_i,-2,0,'99')+'().NA'))() !}
      || {! _i..10 |! ($('POM.SYM'+form(_i,-2,0,'99')))():='' !}
      ?};
      ZMIENNE.MGAT:=M.MGAT().KOD;
      ZMIENNE.MODM:=M.MODM().KOD;
      HELP.REFMAT:=M.ref();
      ZRODZO.WYPDOM:={? M.MGRP<>null() & M.MGRP().M=(#M.ref()) || 'T' || 'N' ?};
      POMOC.RODZ:=M.RODZ;
      exec('m_win_edit','material');
      M.display()
   ?};
   M.cntx_pop()
?};
~~


\record_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Akcja przed rekord w oknach wertowania struktury
::   WE: _a - parametr systemowy
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
{? _a
|| _grayed:={? _tab.OMIT='T' & _tab.sel_size()=0 || 'A' || '' ?};
   _tab.actions_grayed(cur_win(1,1),_grayed)
?};
{? _tab.XW<>0 & _tab.XW<exec('create','#tm_stamp')
|| Color.rekprzed('__T_STR#01#01')
|| ~~
?}


\edit_params
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Redagowanie parametrów
::   WE: _a - wariant redagowania: dostępna ilość
::       _b - wariant redagowania: dostępna data
::       _c - wariant redagowania: dostępny drill
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _v_il:=_a || _v_il:=0 ?};
{? var_pres('_b')=type_of(0) || _v_dw:=_b || _v_dw:=0 ?};
{? var_pres('_c')=type_of(0) || _v_drill:=_c || _v_drill:=0 ?};
params_set('v_il',_v_il,'v_dw',_v_dw,'v_drill',_v_drill);

_env:=__ENV_STR;

_tab:=tab_tmp(
   ,'IL','REAL','Ilość'@
   ,'DW','DATE','Termin wymagany'@
   ,'DRILL','INTEGER','Zakres analizy'@
);

_red:=_tab.mk_edit('Analiza surowców'@,,'#editparams'+$_v_il+$_v_dw+$_v_drill);
_tab.win_esep(_red,'Parametry analizy'@);
{? _v_il || _tab.win_efld(_red,,'IL',,,15,ST.DOKL); _tab.efld_opt(_red,'mark=1',,'IL') ?};
{? _v_dw || _tab.win_efld(_red,,'DW',,,12); _tab.efld_opt(_red,'mark=1',,'DW') ?};
{? _v_drill
|| _tab.win_efld(_red,,'DRILL',,,,,,,,,'radio-buttons',
      ,'Tylko surowce na pierwszym poziomie'@,"0"
      ,'Surowce na wszystkich poziomach'@,"1"
   )
?};
exec('ok_esc','#window',_tab,_red);
_tab.win_edit(_red);

_chk:="
   _tab:=cur_tab(1,1);
   _args:=params_get();
   _chk:={? _args.v_il || {? exec('itsPositive','#field',1,,_tab.IL) || '' || 'IL' ?} || '' ?};
   _chk:=
      {? _chk='' & _args.v_dw
      || {? _tab.DW<date() || FUN.info('Data nie może być wcześniejsza niż dzisiejsza.'@); _chk:='DW' || _chk ?}
      || _chk
      ?};
   _chk
";

_tab.IL:=_env.PARAMS.IL;
_tab.DW:=_env.PARAMS.DW;
_tab.DRILL:=_env.PARAMS.DRILL;
_edited:=_tab.edit(_chk);
{? _edited
|| {? _v_il || _env.PARAMS.IL:=_tab.IL || _env.PARAMS.IL:=0 ?};
   {? _v_dw || _env.PARAMS.DW:=_tab.DW || _env.PARAMS.DW:=date() ?};
   {? _v_drill || _env.PARAMS.DRILL:=_tab.DRILL || _env.PARAMS.DRILL:=1 ?}
?};
_edited


\tktl_chck_seek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Wyszukuje oraz podpowiada kartę technologiczną w oknie redagoawania dla tabeli napotkanych błędów
::  WE: _a $TKTL.ref() wyszukiwanej karty
::----------------------------------------------------------------------------------------------------------------------
{? _= 1 & _a<>''
||
   _tktl:=_a;
   _msk_tktl:=ref_name(_tktl);
   _msk_old:=TKTL.name();
   _msk_new:=form(_msk_tktl);
   {? _msk_new<>_msk_old
   || TKTL.use(_msk_new);
      TKTLW.use('txktw'+((_msk_new)+3))
   ?};
   TKTL.clear(); TKTLW.clear();
   {? TKTL.seek(_tktl)
   || {? TKTLW.find_tab(,'TKTL',,'=',TKTL.ref)
      || return(~~)
      ?}
   ?}
||
   TKTLW.blank(1)
?};
~~


\tktl_chck_pop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Formuła na akcję Popraw tworząca tymczasowe okienko redagowania.(dla tabeli napotkanych błędów)
::  WE: _a - NUMBER - kontekst wywolania:
::           0(domyślnie) -  generowanie zleceń
::           1 - analizy
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_a')=type_of(0) || _where:=_a || _where:=0 ?};
_env:=__ENV_STR;
_tab:=_env.CHECK.TAB;

TKTL.f_set('NRK',,'
         TORW=\'T\'
         and  KTM=\''+_tab.KTM+'\'
         and  STAN=\'T\'
         and  ARCH=\'N\'
         and (( TERM_OD<=to_date(:_b) and  TERM_OD IS NOT NULL)
         or  TERM_OD IS NULL)
         and (( TERM_DO>=to_date(:_b) and  TERM_DO IS NOT NULL)
         or  TERM_DO IS NULL)
         '
         ,'',date());

{? _where=0
|| {? _tab.KTLZ<>'' & _tab.ARCH<>'T'
   || _tab.win_edit(_env.CHECK.REDZ3)
   || _tab.win_edit(_env.CHECK.REDZ2)
   ?};
   _tab.fld_fml('A','AFTER_EDIT',$("
      _red:=cur_win();
      {? __ENV_STR.CHECK.TAB.A='N'
      || __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed,mark=0',TKTLW,'TKTL','NRK');
         __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed',TKTLW,'TKTL','WER');
         __ENV_STR.CHECK.TAB.AKCJA:='Nie generuj zlecenia'@;
         TKTLW.blank(1);
         TKTL.blank(1)
      |? __ENV_STR.CHECK.TAB.A='B'
      || __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed,mark=0',TKTLW,'TKTL','NRK');
         __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed',TKTLW,'TKTL','WER');
         __ENV_STR.CHECK.TAB.AKCJA:='Użyj karty bieżącej'@;
         TKTLW.blank(1);
         TKTL.blank(1)
      |? __ENV_STR.CHECK.TAB.A='W'
      || __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed,mark=0',TKTLW,'TKTL','NRK');
         __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed',TKTLW,'TKTL','WER');
         __ENV_STR.CHECK.TAB.A:='N';
         TKTLW.blank(1);
         TKTL.blank(1);
         {? TKTL.f_active()
         || {? TKTL.f_size()>0
            || __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=1,mark=1',TKTLW,'TKTL','NRK');
               __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=0',TKTLW,'TKTL','WER');
               __ENV_STR.CHECK.TAB.AKCJA:='Użyj karty wskazanej'@;
               __ENV_STR.CHECK.TAB.A:='W';
               {? __ENV_STR.CHECK.TAB.KTLW=''
               || TKTL.f_first();
                  exec('tktl_chck_seek','tech_structure',$TKTL.ref())
               || exec('tktl_chck_seek','tech_structure',__ENV_STR.CHECK.TAB.KTLW)
               ?}
            || FUN.info('"+'Brak aktywnych kart technologicznych dla danego materiału.'@+"');
               TKTLW.blank(1);
               TKTL.blank(1)
            ?}
         ?}
      || __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed,mark=0',TKTLW,'TKTL','NRK');
         __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed',TKTLW,'TKTL','WER')
      ?}
   "))
||
   {? _tab.KTLZ<>'' & _tab.ARCH<>'T'
   || _tab.win_edit(_env.CHECK.REDA3)
   || _tab.win_edit(_env.CHECK.REDA2)
   ?};
   _tab.fld_fml('A','AFTER_EDIT',$("
      _red:=cur_win();
      {? __ENV_STR.CHECK.TAB.A='N'
      || __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed,mark=0',TKTLW,'TKTL','NRK');
         __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed',TKTLW,'TKTL','WER');
         __ENV_STR.CHECK.TAB.AKCJA:='Nie analizuj'@;
         TKTLW.blank(1);
         TKTL.blank(1)
      |? __ENV_STR.CHECK.TAB.A='B'
      || __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed,mark=0',TKTLW,'TKTL','NRK');
         __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed',TKTLW,'TKTL','WER');
         __ENV_STR.CHECK.TAB.AKCJA:='Użyj karty bieżącej'@;
         TKTLW.blank(1);
         TKTL.blank(1)
      |? __ENV_STR.CHECK.TAB.A='W'
      || __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed,mark=0',TKTLW,'TKTL','NRK');
         __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed',TKTLW,'TKTL','WER');
         __ENV_STR.CHECK.TAB.A:='N';
         TKTLW.blank(1);
         TKTL.blank(1);
         {? TKTL.f_active()
         || {? TKTL.f_size()>0
            || __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=1,mark=1',TKTLW,'TKTL','NRK');
               __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=0',TKTLW,'TKTL','WER');
               __ENV_STR.CHECK.TAB.AKCJA:='Użyj karty wskazanej'@;
               __ENV_STR.CHECK.TAB.A:='W';
               {? __ENV_STR.CHECK.TAB.KTLW=''
               || TKTL.f_first();
                  exec('tktl_chck_seek','tech_structure',$TKTL.ref())
               || exec('tktl_chck_seek','tech_structure',__ENV_STR.CHECK.TAB.KTLW)
               ?}
            || FUN.info('"+'Brak aktywnych kart technologicznych dla danego materiału.'@+"');
               TKTLW.blank(1);
               TKTL.blank(1)
            ?}
         ?}
      || __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed,mark=0',TKTLW,'TKTL','NRK');
         __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed',TKTLW,'TKTL','WER')
      ?}
   "))
?};

_valid:="
_res:='';
{? TKTLW.TKTL().NRK='' & __ENV_STR.CHECK.TAB.A='W'
|| FUN.info('"+'Pole \"Karta technologiczna\" musi być wypełnione.'@+"');
   _res:=0
?};
_res
";

{? _tab.edit($(_valid))
|| {? __ENV_STR.CHECK.TAB.A='W'
   || __ENV_STR.CHECK.TAB.KTLW:=$TKTL.ref;
      __ENV_STR.CHECK.TAB.KTLW_NRK:=TKTL.NRK;
      __ENV_STR.CHECK.TAB.KTLW_WER:=TKTL.WER
   || __ENV_STR.CHECK.TAB.KTLW:='';
      __ENV_STR.CHECK.TAB.KTLW_NRK:='';
      __ENV_STR.CHECK.TAB.KTLW_WER:=''
   ?};
   __ENV_STR.CHECK.TAB.put()
?};
0


\tktl_chck_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Dodaje rekord do tabeli napotkanych błędów
::  WE: _a STRING $TKTL.ref()
::      _b STRING $TMAT.ref()
::      _c STRING Przyczyna błędu
::      _d STRING Nazwa materiału
::      _e STRING Nr karty technologicznej
::      _f STRING Wersja karty
::      _g STRING $KTM.ref
::      _h STRING Czy archiwalna
::----------------------------------------------------------------------------------------------------------------------
{? var_press('__ENV_STR') > 0
||
   _env:=__ENV_STR;
   _tab:=_env.CHECK.TAB;

   {? var_press('_a')=type_of('a') || _ktl:=_a || _ktl:='' ?};
   {? var_press('_b')=type_of('a') || _tmat:=_b || _tmat:='' ?};
   {? var_press('_c')=type_of('a') || _pow:=_c || _pow:='' ?};
   {? var_press('_d')=type_of('a') || _naz:=_d || _naz:='' ?};
   {? var_press('_e')=type_of('a') || _nrk:=_e || _nrk:='' ?};
   {? var_press('_f')=type_of('a') || _wer:=_f || _wer:='' ?};
   {? var_press('_g')=type_of('a') || _ktm:=_g || _ktm:='' ?};
   {? var_press('_h')=type_of('a') || _arch:=_h || _arch:='N' ?};

   {? ~_tab.find_tab(,'TMAT',,'=',_tmat,'KTLZ',,'=',_ktl)
   ||
      _tab.TMAT:=_tmat;
      _tab.KTM_NAZ:=_naz;
      _tab.KTLZ:=_ktl;
      _tab.KTLW:='';
      _tab.KTLW_NRK:='';
      _tab.POW:=_pow;
      _tab.AKCJA:='Nie analizuj'@;
      _tab.A:='N';
      _tab.NRK:=_nrk;
      _tab.WER:=_wer;
      _tab.KTM:=_ktm;
      _tab.ARCH:=_arch;
      _tab.add()
   ?}
?};
~~


\tktl_chck_mk_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Tworzy okno selekcji dla tabeli napotkanych błędów
::  WE: _a - NUMBER - kontekst wywolania:
::           0(domyślnie) -  generowanie zleceń
::           1 - analizy
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _choice:=_a || _choice:=0 ?};
_env:=__ENV_STR;
_tab:=_env.CHECK.TAB;

_sel:=_tab.mk_sel(,,,,,,,,'U','U',,,,);
_tab.win_fld(_sel,,'KTM_NAZ',,,-35,,1,'Nazwa materiału'@);
_tab.win_fld(_sel,,'NRK',,,-25,,1,'Numer karty technologicznej'@);
_tab.win_fld(_sel,,'WER',,,,,1,'Wersja'@);
_tab.win_fld(_sel,,'POW',,,-25,,1,'Powód'@);
_tab.win_fld(_sel,,'AKCJA',,,-25,,,'Akcja'@);
_tab.win_fld(_sel,,'KTLW_NRK',,,-20,,,'Wskazana karta technologiczna'@);
_tab.win_fld(_sel,,'KTLW_WER',,,-6,,,'Wersja karty wskazanej'@);

{? _choice=0
|| _tab.win_act(_sel,,'Popraw',,,,"exec('tktl_chck_pop','tech_structure',0)",,1);
   _close:="
      {? _a='sel_exit'
      || return(1)
      || {? FUN.ask('Czy chcesz przerwać generowanie technologii? Dane w oknie nie zostaną zapamiętane.'@)
         || return(1)
         || return(0)
         ?}
      ?}
   "
|| _tab.win_act(_sel,,'Popraw',,,,"exec('tktl_chck_pop','tech_structure',1)",,1);
   _close:="
      {? _a='sel_exit'
      || return(1)
      || {? FUN.ask('Czy chcesz przerwać analizę? Dane w oknie nie zostaną zapamiętane.'@)
         || return(1)
         || return(0)
         ?}
      ?}
   "
?};
_tab.win_act(_sel,,'Formuła','Akceptuj'@@,,,"sel_exit()",,,,,,'A');
_tab.win_btn(_sel,'text=%1,panel=bottom,align=begin'['Akceptuj'@@],'menu:A');

_tab.fld_attr(,2);

_grp:=_tab.grp_make('Lista napotkanych problemów'@,,'probgrp',,,_close,,'normal');
_tab.grp_sel(_grp,,_sel,,,,,,,,,,'maximized');

_grp


\tktl_chck_mk_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Tworzy okno readakcji dla tabeli napotkanych błędów
::  WE: _a - NUMBER - kontekst wywołania:
::           0 -  generowanie zleceń
::           1 -  analizy
::      _b - NUMBER - typ okna:
::           0 -  2 opcje (nie generuj, użyj wskazanej)
::           1 -  3 opcje (nie generuj, użyj bieżącej, użyj wskazanej)
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_a')=type_of(0) || _choice:=_a || _choice:=0 ?};
{? var_press('_b')=type_of(0) || _type:=_b || _type:=0 ?};
_env:=__ENV_STR;
_tab:=_env.CHECK.TAB;

_red:=_tab.mk_edit('Wybór akcji'@,,'edit');
{? _choice=0
||
   {? _type=1
   ||
      _tab.win_efld(_red,,'A',,,,,,'Akcja',,,'radio-buttons',,
            'Nie generuj zlecenia'@,"'N'",
            'Użyj karty bieżącej'@,"'B'",
            'Użyj karty wskazanej'@,"'W'"
      )
   ||
      _tab.win_efld(_red,,'A',,,,,,'Akcja',,,'radio-buttons',,
            'Nie generuj zlecenia'@,"'N'",
            'Użyj karty wskazanej'@,"'W'"
      )
   ?}
||
   {? _type=1
   ||
      _tab.win_efld(_red,,'A',,,,,,'Akcja',,,'radio-buttons',,
            'Nie analizuj'@,"'N'",
            'Użyj karty bieżącej'@,"'B'",
            'Użyj karty wskazanej'@,"'W'"
      )
   ||
      _tab.win_efld(_red,,'A',,,,,,'Akcja',,,'radio-buttons',,
            'Nie analizuj'@,"'N'",
            'Użyj karty wskazanej'@,"'W'"
      )
   ?}
?};
_tab.win_efld(_red,TKTLW,'TKTL','NRK','*',30,,0,'Karta technologiczna'@,,,);
_tab.win_efld(_red,TKTLW,'TKTL','WER','*',30,,0,'Wersja'@,,,);
_tab.efld_opt(_red,'mark=1',TKTLW,'TKTL','NRK');

_tab.fld_fml('A','BEFORE_DISPLAY',"
   _red:=cur_win();
   {? __ENV_STR.CHECK.TAB.A='W'
   || __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed,mark=0',TKTLW,'TKTL','NRK');
      __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed',TKTLW,'TKTL','WER');
      TKTLW.blank(1);
      TKTL.blank(1);
      {? TKTL.f_active()
      || {? TKTL.f_size()>0
         || __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=1,mark=1',TKTLW,'TKTL','NRK');
            __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=0',TKTLW,'TKTL','WER');
            {? __ENV_STR.CHECK.TAB.KTLW=''
            || TKTL.f_first();
               exec('tktl_chck_seek','tech_structure',$TKTL.ref())
            || exec('tktl_chck_seek','tech_structure',__ENV_STR.CHECK.TAB.KTLW)
            ?}

         || TKTLW.blank(1);
            TKTL.blank(1)
         ?}
      ?}
   |? __ENV_STR.CHECK.TAB.A='B'
   || __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed,mark=0',TKTLW,'TKTL','NRK');
      __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed',TKTLW,'TKTL','WER');
      TKTLW.blank(1);
      TKTL.blank(1)
   || __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed,mark=0',TKTLW,'TKTL','NRK');
      __ENV_STR.CHECK.TAB.efld_opt(_red,'editable=grayed',TKTLW,'TKTL','WER');
      TKTLW.blank(1);
      TKTL.blank(1)
   ?}
");
exec('ok_esc','#window',_tab,_red);

_red


\tktl_chck_zam_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Dodaje rekord do tabeli zamienników błędów
::----------------------------------------------------------------------------------------------------------------------
_env:=__ENV_STR;
_tab:=_env.CHECK.TAB;
_tab_zam:=_env.CHECK.TAB_ZAM;

{? _tab.A='N'
|| _tab_zam.KTLW:='';
   _tab_zam.TMAT:=_tab.TMAT
|? _tab.A='B'
|| _tab_zam.KTLW:=_tab.KTLZ;
   _tab_zam.TMAT:=_tab.TMAT
|? _tab.A='W'
|| _tab_zam.KTLW:=_tab.KTLW;
   _tab_zam.TMAT:=_tab.TMAT
?};
_tab_zam.add;
~~


\tktl_chck_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Wyświetla tabelę z napotkanymi problemami
::   WE: _a NUMBER obszar wywołania
::            2 - TKTLW,
::            1 - TKTL,
::            0(domyślnie) - inny
::   WY: 0 / 1
::       1 - zaakceptowanie okna przez użytkownika
::       0 - opuszczenie okna wertowania
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a') > 0 || _choice:=_a || _choice:=0 ?};
{? var_pres('__ENV_STR') > 0
|| _ok:=0;
   TKTL.cntx_psh();
   TKTLW.cntx_psh();
   {? TKTL.f_active() || TKTL.f_clear() ?};
   {? _choice=1 || _ref:=TKTL.ref()
   |? _choice=2 || _ref:=TKTLW.ref()
   ?};
   TKTL.index('KSN');
   TKTL.prefix();
   TKTL.win_sel('SLO');
   _default:=TKTL.actions('SLO','WJrSKL:r');

   {? __ENV_STR.CHECK.TAB.select()
   || _ok:=1
   ?};

   TKTL.actions('SLO',,_default);
   TKTL.f_clear();
   TKTL.cntx_pop();
   TKTLW.cntx_pop();

   {? _choice=1
   || grp_disp(TKTL,'WER',1,1);
      TKTL.f_seek(_ref);
      grp_disp(TKTL,'WER',1,1)
   |? _choice=2
   || grp_disp(TKTLW,'WER_K',1,1);
      TKTLW.f_seek(_ref);
      grp_disp(TKTLW,'WER_K',1,1)
   ?};

:: Wypełnienie tabeli zamienników
   {? _ok
   ||
      {? __ENV_STR.CHECK.TAB.first()
      || {!
         |? exec('tktl_chck_zam_add','tech_structure');
            __ENV_STR.CHECK.TAB.next()
         !}
      ?}
   ?}
?};
_ok


\tktl_check
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Sprawdza poprawność kart technologicznych produktów przypisanych do danego zlecenia i wyświetla listę
::       tych półfabrykatów do których przypisana jest archiwalna lub nieaktualna karta technologiczna).
::   WE: _a - ZL.ref() - Ref zlecenia, którego półfabrykaty będą sprawdzane (tylko na 1 poziomie)
::       [_b] - czy wyświetlać okno z napotkanymi problemami: [1] - tak, 0 - nie
::   WY: 1 / 0 - czy zatwierdzono(1) / anulowano(0) wprowadzone zmiany.
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_show:={? var_pres('_b')=type_of(0) || _b || 1 ?};
exec('env_create','tech_structure',1);
_tab:=__ENV_STR.CHECK.TAB;

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
||
   _ktl:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,"ref()",null());
   exec('tktl_cntx_psh','tech_common');
   _msk:=(8+ref_name(_ktl))+3;
   exec('tktl_use','tech_common',_msk);

   exec('stop_tpar','tech_param');
   tpar:=obj_new(@.CLASS.TPAr);
   tpar.TABLE:=TPAR;
   tpar.INDEX:='NN';
   tpar.PREFIX:=_ktl;
   tpar.KTM:=ZL.KTM;
   tpar.loadp();

   TMAT.index('NNL');
   TMAT.prefix(_ktl);
   {? TMAT.first()
   || {!
      |? {? TMAT.NROP().EXIST<>''
         || _exist:=tpar.calc(TMAT.NROP().EXIST)
         || _exist:=1
         ?};
         {? _exist
         || {? TMAT.EXIST<>''
            || _exist:=tpar.calc(TMAT.EXIST)
            || _exist:=1
            ?}
         ?};
         {? _exist
         || {? (TMAT.RKTL<>'' | TMAT.DFLT_KTL='T') & TMAT.LIMIT='T' & TMAT.MAG<>'T'
            || {? TMAT.GRKTM='G'
               || _ktm:=TMAT.TGDFLT().PT
               || _ktm:=TMAT.PT
               ?};

               {? TMAT.RKTL<>''
               || TKTL.cntx_psh();
                  _msk_old:=TKTL.name();
                  _msk_new:=form(8+TMAT.RKTL);
                  {? _msk_new<>_msk_old
                  || TKTL.use(_msk_new)
                  ?};
                  TKTL.clear()
               ?};

               {? TMAT.DFLT_KTL='T'
               || _ktlz:=exec('dflt_ktl','tech_prod',_ktm,,1)
               || {? TKTL.seek(TMAT.RKTL)
                  || _ktlz:=TKTL.ref()
                  || _ktlz:=null()
                  ?}
               ?};

::             Sprawdzam czy karta technologiczna zlecenia jest w archiwum
               _arch:=exec('FindAndGet','#table',TKTL,_ktlz,,"ARCH",'N');

::             Sprawdzam czy karta technologiczna zlecenia jest aktualna
               _akt:={? TKTL.seek(_ktlz)
                     || {? ~exec('tktl_act','tech_head',0)
                        || 'N'
                        || 'T'
                        ?}
                     ||
                        'N'
               ?};
               _akcja:='N';
               _akcja_txt:='Nie generuj zlecenia'@;

::               Jak archiwalna, nieaktualna lub brak karty domyślnej to dodaje do tabeli napotkanych błędów
               {? ~(_arch='N' & _akt='T' & _ktlz<>null())
               ||
                  _pow:='';
                 {? TMAT.DFLT_KTL='T' & _ktlz=null()
                 || _pow:='Brak karty domyślnej'@
                 |? TMAT.DFLT_KTL='T' & _akt<>'T'
                 || _pow:='Karta domyślna nieaktualna'@
                 |? _arch<>'N'
                 || _pow:='Karta archiwalna'@
                 |? _akt<>'T'
                 || _pow:='Karta nieaktualna'@
                 ?};

                 _tab.NRK:=exec('FindAndGet','#table',TKTL,_ktlz,,"NRK",'');
                 _tab.WER:=exec('FindAndGet','#table',TKTL,_ktlz,,"WER",'');
                 _tab.POW:=_pow;
                 _tab.AKCJA:=_akcja_txt;
                 _tab.A:=_akcja;
                 _tab.KTM:=$_ktm;
                 _tab.KTM_NAZ:=TMAT.PT().N;
                 _tab.KTLZ:=$_ktlz;
                 _tab.KTLW:='';
                 _tab.KTLW_NRK:='';
                 _tab.TMAT:=$TMAT.ref();
                 _tab.ARCH:=_arch;
                 _tab.add()
               ?};
               {? TMAT.RKTL<>''
               || TKTL.cntx_pop()
               ?}
            ?}
         ?};
      TMAT.next()
      !}
   ?};
   _ok:=1;
   {? _tab.size>0
   || {? _show>0
      ||
::       Wyświetlam tabelę z problemami
         _tab.win_sel(__ENV_STR.CHECK.WERZ);
         _ok:=exec('tktl_chck_sel','tech_structure');
         {? _ok
         ||
::          Wprowadzam zmiany w TMAT
            {? _tab.first()
            || {!
               |?
                  {? TMAT.seek(_tab.TMAT)
                  ||
::                   Zawsze usuwam znacznik karty domyślnej
                     TMAT.DFLT_KTL:='N';
                     {? _tab.A='N'
                     || TMAT.MAG:='T';
                        TMAT.KTL:=null;
                        TMAT.RKTL:=''
                     |? _tab.A='W'
                     || TMAT.KTL:=exec('FindAndGet','#table',TKTL,_tab.KTLW,,,null);
                        TMAT.RKTL:=_tab.KTLW
                     |? _tab.A='B'
                     || TMAT.KTL:=exec('FindAndGet','#table',TKTL,_tab.KTLZ,,,null);
                        TMAT.RKTL:=_tab.KTLZ
                     ?};
                     TMAT.put(1)
                  ?};
                  _tab.next()
               !}
            ?}
         ?}
      || _ok:=0
      ?}
   ?};
   exec('stop_tpar','tech_param');
   exec('tktl_cntx_pop','tech_common')
?};
ZL.cntx_pop();
_ok

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:39 9e266e3f5891a123b358796085579e6c4ec2a320bd8ad9f33a910ae328ec4ca8ae1ed04adb358940263ca229702a03486dea7644d138b392b11a94f865a95497c2473b94ec8b4ac9022f03e01e6205e010eee60305fedfded1d4c232cdda3330ccc50f5e13ddbe12f0e8b4c5b28610795faa7289a97703f1fb5286babef1f8a7
