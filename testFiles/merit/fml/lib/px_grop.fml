:!UTF-8::(c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: px_grop.fml [23.25]
:: Utworzony: 2022/08/25
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Obsługa grup operacji w planie strategicznym
::======================================================================================================================


\sequence4pxgrp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Ustawia kolejność dla algorytmu planowania
::   WE: [_a] - PX_GRP.ref lub bieżący rekord
::   WY: 'P' - początek procesu planowania, przed zleceniami/zamówieniami
::       'K' - koniec procesu planowania, po zleceniach/zamówieniach
::       'X' - nie można zaplanować, ponieważ operacja grupowa jest w środku procesu
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_result:='';
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _gropp_seq:=exec('chk_grop_oper','zl_grop',PX_GRP.GROPS().GROP);
   {? _gropp_seq='X'
   || _result:='X'
   |? _gropp_seq='Z'
   || _result:='Z'
   |? _gropp_seq='P' & PX_GRP.DIR>0
   || _result:='P'
   |? _gropp_seq='K' & PX_GRP.DIR<0
   || _result:='P'
   |? _gropp_seq='K' & PX_GRP.DIR>0
   || _result:='K'
   |? _gropp_seq='P' & PX_GRP.DIR<0
   || _result:='K'
   |? _gropp_seq='PK'
   || {? PX_GRP.DIR>0
      || _result:='P'
      |? PX_GRP.DIR<0
      || _result:='K'
      ?}
   ?};
   {? _result<>'' & _result<>'X' & _result<>'Z'
   || PX_GRP.GROP_SEQ:=_result;
      _can_continue:=PX_GRP.put()
   ?}
?};
PX_GRP.cntx_pop();
PX_GRP.get();
_result


\direction_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy grupa operacji i wszystkie zlecenia w kolejce mają ten sam zwrot
::   WE: [_a] - PX_GRP.ref lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_result:=1;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _dir:=PX_GRP.DIR;
   _px_ver:=PX_GRP.PX_VER;
   {? PX_GRP.GROPS<>null()
   ||
      PX_CONN.cntx_psh();
      PX_CONN.index('VER');
      GROPS.cntx_psh();
      GROPP.cntx_psh();
      GROPP.index('GROP');
      GROPP.prefix(PX_GRP.GROPS().GROP);
      {? GROPP.first()
      || {!
         |? {? GROPP.ZL<>null()
            || _px_obj:=exec('get_zl_object','px_obj',GROPP.ZL);
               {? _px_obj<>null()
               || PX_CONN.prefix(_px_ver,_px_obj);
                  {? PX_CONN.first()
                  || {!
                     |? {? PX_CONN.PX_GRP().DIR<>_dir
                        || _result:=0
                        ?};
                        PX_CONN.next() & _result>0
                     !}
                  ?}
               ?}
            ?};
            GROPP.next() & _result>0
         !}
      ?};
      GROPP.cntx_pop();
      GROPS.cntx_pop();
      PX_CONN.cntx_pop();
      ~~
   ?};
   ~~
?};
PX_GRP.cntx_pop();
_result


\sequence_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy zlecenie w kolejce planu jest w grupach operacji z tą samą sekwencją
::   WE: [_a] - PX_GRP.ref lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_result:=1;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_CONN.cntx_psh();
   PX_CONN.index('PX_GRP');
   ZL.cntx_psh();
   GROPP.cntx_psh();
   GROPP.index('ZL');
   GROPS.cntx_psh();
   GROPS.index('GROP');

   _seq:='';
   _px_ver:=PX_GRP.PX_VER;
   PX_CONN.prefix(PX_GRP.ref());
   {? PX_CONN.first()
   || PX_GRP.cntx_psh();
      PX_GRP.index('GROPS');
      {!
      |? _zl:=PX_CONN.PX_OBJ().ZL;
         {? _zl<>null()
         || GROPP.prefix(_zl);
            {? GROPP.first()
            || {!
               |? {? GROPP.GROP().AKC='T' & GROP.STATUS='O'
                  ||
::                   Badam tylko w zaakceptowanych grupach

                     GROPS.prefix(GROPP.GROP);
                     {? GROPS.first()
                     || {!
                        |? PX_GRP.prefix(_px_ver,GROPS.ref(),'N');
                           {? PX_GRP.first()
                           || {!
                              |? {? _seq=''
                                 || _seq:=PX_GRP.GROP_SEQ
                                 ?};

                                 {? _seq<>'' & _seq<>PX_GRP.GROP_SEQ
                                 || _result:=0;
                                    _can_continue:=0
                                 ?};
                                 PX_GRP.next() & _can_continue>0
                              !}
                           ?};
                           GROPS.next() & _can_continue>0
                        !}
                     ?}
                  ?};
                  GROPP.next() & _can_continue>0
               !}
            ?}
         ?};
         PX_CONN.next() & _can_continue>0
      !};
      PX_GRP.cntx_pop()
   ?};

   GROPS.cntx_pop();
   GROPP.cntx_pop();
   ZL.cntx_pop();
   PX_CONN.cntx_pop();
   ~~
?};
PX_GRP.cntx_pop();
_result


\direction_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Ustawia zwrot wszystkim zleceniom w kolejce na ten sam co ma ich grupa operacji
::   WE: [_a] - PX_GRP.ref lub bieżący rekord
::       [_b] - INTEGER - 0/[1] - czy wyświetlać dialogi
::       [_c] - ref_table - tablica odwiedzonych grup
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};
_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};
{? var_pres('_c')>100
|| _visited:=_c
|| _visited:=exec('ref_table','#table')
?};
_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0 & _dialog>0
|| _can_continue:=FUN.ask('Ustawić wszystkim zleceniom należącym do grupy: %1 ten sam zwrot?'@[exec('PX_GRP','#to_string')])
?};

_can_rec:=1;
{? _can_continue>0
|| {? _visited.r_find(PX_GRP.ref())=0
   || _visited.add(PX_GRP.ref())
   || _can_rec:=0
   ?}
?};

{? _can_continue>0 & _can_rec>0
|| _ref:=PX_GRP.ref();
   _dir:=PX_GRP.DIR;
   _px_ver:=PX_GRP.PX_VER;
   {? PX_GRP.GROPS<>null()
   ||
      PX_CONN.cntx_psh();
      PX_CONN.index('VER');
      GROPS.cntx_psh();
      GROPP.cntx_psh();
      GROPP.index('GROP');
      _grop:=PX_GRP.GROPS().GROP;
      GROPP.prefix(_grop);
      {? GROPP.first()
      || {!
         |? _gropp:=GROPP.ref();
            {? GROPP.ZL<>null()
            || _px_obj:=exec('get_zl_object','px_obj',GROPP.ZL);
               {? _px_obj<>null()
               || PX_CONN.prefix(_px_ver,_px_obj);
                  {? PX_CONN.first()
                  || {!
                     |? {? PX_CONN.PX_GRP().DIR<>_dir
                        || PX_GRP.cntx_psh();
                           PX_GRP.prefix();
                           PX_GRP.DIR:=_dir;
                           {? _dir<0
                           || PX_GRP.PL_FORCE:='N'
                           ?};
                           _can_continue:=PX_GRP.put();
                           PX_GRP.cntx_pop()
                        ?};
                        PX_CONN.next() & _can_continue>0
                     !}
                  ?}
               ?};
               PX_GRP.cntx_psh();
               PX_GRP.index('GROPS');
               GROPS.cntx_psh();
               GROPS.index('GROP');
               GROPP.cntx_psh();
               GROPP.index('ZL');
               GROPP.prefix(GROPP.ZL);
               {? GROPP.first()
               || {!
                  |? {? GROPP.ref()<>_gropp
                     || GROPS.prefix(GROPP.GROP);
                        {? GROPS.first()
                        || {!
                           |? PX_GRP.prefix(_px_ver,GROPS.ref(),'N');
                              {? PX_GRP.first()
                              || {!
                                 |? {? PX_GRP.ref()<>_ref
                                    ||
                                       PX_GRP.DIR:=_dir;
                                       {? _dir<0
                                       || PX_GRP.PL_FORCE:='N'
                                       ?};
                                       _can_continue:=PX_GRP.put();
                                       {? _can_continue>0
                                       || _can_continue:=exec('direction_set','px_grop',,0,_visited)
                                       ?}
                                    ?};
                                    PX_GRP.next() & _can_continue>0
                                 !}
                              ?};
                              GROPS.next() & _can_continue>0
                           !}
                        ?}
                     ?};
                     GROPP.next() & _can_continue>0
                  !}
               ?};
               GROPP.cntx_pop();
               GROPS.cntx_pop();
               PX_GRP.cntx_pop();
               ~~
            ?};
            GROPP.next() & _can_continue>0
         !}
      ?};
      exec('sequence4pxgrp','px_grop',_ref);
      GROPP.cntx_pop();
      GROPS.cntx_pop();
      PX_CONN.cntx_pop();
      ~~
   ?};
   ~~
?};
PX_GRP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\px_stage4grops
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Tworzy/aktualizuje PX_STAGE dla GROPS
::   WE: [_a] - GROPS.ref() lub bieżący rekord
::   WY: PX_STAGE.ref() lub null()
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(GROPS.ref())
|| _ref:=_a
?};

_result:=null();
_can_continue:=1;

GROPS.cntx_psh();
{? _ref<>null()
|| GROPS.prefix();
   {? GROPS.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_STAGE.cntx_psh();
   PX_STAGE.index('GROPS');
   PX_STAGE.prefix(GROPS.ref());
   _add:=0;
   _put:=0;
   {? PX_STAGE.first()=0
   || _add:=1;
      PX_STAGE.blank()
   || _put:=1
   ?};
   PX_STAGE.NR:=1;
   PX_STAGE.NAZWA:=GROPS.GROP().KOD+' - '+GROP.TTOPER().NA;
   PX_STAGE.GROPS:=GROPS.ref();
   {? exec('is_px_set','px_param')
   || PX_STAGE.PX_SET:=exec('default_set','px_set')
   ?};
   {? _add>0
   || {? PX_STAGE.add()
      || _result:=PX_STAGE.ref()
      ?}
   |? _put>0
   || {? PX_STAGE.put()>0
      || _result:=PX_STAGE.ref()
      ?}
   ?};
   PX_STAGE.cntx_pop()
?};
GROPS.cntx_pop();
_result


\is_grop_member
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy element kolejki jest członkiem grupy operacji
::   WE: [_a] - PX_GRP.ref() lub bieżący rekord
::   WY: 0 - element kolejki nie zawiera żadnych zgrupowanych elementów
::       1 - element kolejki jest w przynajmniej jednej grupie
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_CONN.cntx_psh();
   PX_CONN.index('PX_GRP');
   PX_CONN.prefix(PX_GRP.ref());
   {? PX_CONN.first()
   || {!
      |? {? PX_CONN.PX_OBJ().ZL<>null()
         || _result:=exec('is_grop_member','zl_grop',PX_CONN.PX_OBJ().ZL)
         ?};
         PX_CONN.next() & _result=0
      !}
   ?};
   PX_CONN.cntx_pop();
   ~~
?};
PX_GRP.cntx_pop();
_result


\is_grop_member_planned
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy element kolejki jest członkiem grupy operacji która jest w planie
::   WE: [_a] - PX_GRP.ref() lub bieżący rekord
::   WY: 0 - element kolejki nie zawiera żadnych zgrupowanych elementów
::       1 - element kolejki jest w przynajmniej jednej grupie
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_CONN.cntx_psh();
   PX_CONN.index('PX_GRP');
   PX_CONN.prefix(PX_GRP.ref());
   {? PX_CONN.first()
   || {!
      |? {? PX_CONN.PX_OBJ().ZL<>null()
         || _result:=exec('is_grop_member_planned','zl_grop',PX_CONN.PX_OBJ().ZL)
         ?};
         PX_CONN.next() & _result=0
      !}
   ?};
   PX_CONN.cntx_pop();
   ~~
?};
PX_GRP.cntx_pop();
_result



\get_time_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Dla etapu zlecenia, które jest w grupie operacji zwraca czas minimalnego startu lub
::       minimalnego końca w zależnosci od zwrotu
::   WE: [_a] - PX_GRP - element kolejki zlecenie
::       _b - PX_STAGE.ref() - etap
::       [_c] - INTEGER - kierunek planowania, jeżeli nie podany to z PX_GRP
::   WY: REAL - czas w formacie TM_STAMP
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};
_px_stage:=_b;
_dir:=0;
{? var_pres('_c')=type_of(0)
|| _dir:=_c
?};

_result:=0;
_times:=tab_tmp(1,
   'TM','REAL','Czas'
);
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? _dir=0
   || _dir:=PX_GRP.DIR
   ?};
   {? exec('is_grop_member','px_grop')
   ||
      _px_ver:=PX_GRP.PX_VER;
      PX_STAGE.cntx_psh();
      PX_NAST.cntx_psh();
      ZGP.cntx_psh();
      ZGP.index('PX_STAGE');
      {? _dir>0
      ||
::       Planowanie do przodu, zwracam czasy z poprzedników
         PX_NAST.index('NEXT');
         PX_NAST.prefix(_px_stage);
         {? PX_NAST.first()
         || {!
            |?
               ZGP.prefix(PX_NAST.PX_STAGE);
               {? ZGP.first()
               || exec('get_times_zgp','zl_grop',,1,_times,_px_ver)
               ?};
               PX_NAST.next()
            !}
         ?};
         _times.prefix();
         {? _times.last()
         ||
::          Jeżeli są czasy z poprzedników to biorę ten maksymalny, czyli ostatni
::          w tabeli posortowanej po czasach
            _result:=_times.TM
         ?};
         ~~
      ||
::       Planowanie do tyłu, zwracam czasy z następników
         PX_NAST.index('PX');
         PX_NAST.prefix(_px_stage);
         {? PX_NAST.first()
         || {!
            |?
               ZGP.prefix(PX_NAST.PX_NEXT);
               {? ZGP.first()
               || exec('get_times_zgp','zl_grop',,2,_times,_px_ver)
               ?};
               PX_NAST.next()
            !}
         ?};
         _times.prefix();
         {? _times.first()
         ||
::          Jeżeli są czasy z poprzedników to biorę ten minimalny, czyli pierwszy
::          w tabeli posortowanej po czasach
            _result:=_times.TM
         ?};
         ~~
      ?};
      PX_NAST.cntx_pop();
      PX_STAGE.cntx_pop();
      ZGP.cntx_pop();
      ~~
   ?}
?};
PX_GRP.cntx_pop();
_result


\get_time_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Dla grupy operacji, zwraca czas minimalnego startu lub
::       minimalnego końca w zależnosci od zwrotu w oparciu o plan poprzednich/następnych operacji zleceń
::   WE: [_a] - GROP.ref - grupa operacji
::       _b - INTEGER - kierunek planowania: 1 - zwracam max czas końca z poprzedników, 2 - zwracam min czas początku z następników
::       _c - PX_VER.ref - wersja planu
::   WY: REAL - czas w formacie TM_STAMP
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(GROP.ref())
|| _ref:=_a
?};
_dir:=_b;
_px_ver:=_c;

_result:=0;
_times:=tab_tmp(1,
   'TM','REAL','Czas'
);
_can_continue:=1;

GROP.cntx_psh();
{? _ref<>null()
|| GROP.prefix();
   {? GROP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| GROPP.cntx_psh();
   GROPP.index('GROP');
   PX_STAGE.cntx_psh();
   PX_NAST.cntx_psh();
   ZGP.cntx_psh();
   GROPP.prefix(GROP.ref());
   {? GROPP.first()
   || {!
      |? {? GROPP.ZGP<>null() & GROPP.ZGP().PX_STAGE<>null()
         || _px_obj:=exec('get_zl_object','px_obj',GROPP.ZL);
            GROPP.ZGP().PX_STAGE();
            {? _dir>0
            ||
::             Planowanie do przodu, zwracam czasy z poprzedników
               PX_NAST.index('NEXT');
               PX_NAST.prefix(PX_STAGE.ref());
               {? PX_NAST.first()
               || {!
                  |?
                     _px_stage:=PX_NAST.PX_STAGE;
                     {? _px_stage<>null()
                     ||
                        PX_POZ.index('PX_STAG6');
                        PX_POZ.prefix(_px_ver,_px_obj,_px_stage);
                        {? PX_POZ.last()
                        || _times.blank();
                           _times.TM:=PX_POZ.TM_END;
                           _times.add()
                        ?}
                     ?};
                     PX_NAST.next()
                  !}
               ?};
               ~~
            ||
::             Planowanie do tyłu, zwracam czasy z następników
               PX_NAST.index('PX');
               PX_NAST.prefix(PX_STAGE.ref());
               {? PX_NAST.first()
               || {!
                  |?
                     _px_stage:=PX_NAST.PX_NEXT;
                     {? _px_stage<>null()
                     ||
                        PX_POZ.index('PX_STAG5');
                        PX_POZ.prefix(_px_ver,_px_obj,_px_stage);
                        {? PX_POZ.first()
                        || _times.blank();
                           _times.TM:=PX_POZ.TM_START;
                           _times.add()
                        ?}
                     ?};
                     PX_NAST.next()
                  !}
               ?};
               ~~
            ?}
         ?};
         GROPP.next()
      !}
   ?};

   _times.prefix();
   {? _dir>0
   ||
      {? _times.last()
      ||
::       Jeżeli są czasy z poprzedników to biorę ten maksymalny, czyli ostatni
::       w tabeli posortowanej po czasach
         _result:=_times.TM
      ?}
   ||
      {? _times.first()
      ||
::       Jeżeli są czasy z poprzedników to biorę ten minimalny, czyli pierwszy
::       w tabeli posortowanej po czasach
         _result:=_times.TM
      ?}
   ?};
   ZGP.cntx_pop();
   PX_NAST.cntx_pop();
   PX_STAGE.cntx_pop();
   GROPP.cntx_pop();
   ~~
?};
GROP.cntx_pop();
_result


\stage_planned_in_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy PX_STAGE jest zaplanowany już wewnątrz grupy operacji
::   WE: [_a] - PX_STAGE.ref() lub bieżący rekord
::       _b - PX_VER.ref()
::   WY: 0 - nie jest
::       1 - jest
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_STAGE.ref())
|| _ref:=_a
?};
_px_ver:=_b;

_result:=0;
_can_continue:=1;

PX_STAGE.cntx_psh();
{? _ref<>null()
|| PX_STAGE.prefix();
   {? PX_STAGE.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _times:=tab_tmp(1,
      'TM','REAL','Czas'
   );
   ZGP.cntx_psh();
   ZGP.index('PX_STAGE');
   ZGP.prefix(PX_STAGE.ref());
   {? ZGP.first()
   || exec('get_times_zgp','zl_grop',,1,_times,_px_ver)
   ?};
   _times.prefix();
   {? _times.first()
   || _result:=1
   ||

::    Jeżeli nie ma zaplanowanego jeszcze to trzeba sprawdzić czy będzie za chwilę wplanowany
      GROPP.cntx_psh();
      GROPP.index('ZGP');
      GROPP.prefix(ZGP.ref());
      PX_GRP.cntx_psh();
      PX_GRP.index('GROPS');
      GROPS.cntx_psh();
      {? GROPP.first()
      || {!
         |?
            GROPS.prefix(GROPP.GROP);
            {? GROPS.first()
            || {!
               |? PX_GRP.prefix(_px_ver,GROPS.ref());
                  {? PX_GRP.first()
                  || _result:=1
                  ?};
                  GROPS.next()
               !}
            ?};
            GROPP.next()
         !}
      ?};
      GROPS.cntx_pop();

      PX_GRP.cntx_pop();
      GROPP.cntx_pop();
      ~~
   ?};
   ZGP.cntx_pop();
   ~~
?};
PX_STAGE.cntx_pop();
_result


\grop_plan_px_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Ustawia pole GROP.PLAN_PX
::   WE: [_a] - GROP.ref() lub bieżący rekord
::       [_b] - STRING - 'T'/'Q'/['N'] - wartość pola
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(GROP.ref())
|| _ref:=_a
?};
_value:='N';
{? var_pres('_b')=type_of('')
|| _value:=_b
?};

_result:=0;
_can_continue:=1;

GROP.cntx_psh();
{? _ref<>null()
|| GROP.prefix();
   {? GROP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? _value='N'
   || _px_obj:=exec('get_grop_object','px_obj',GROP.ref());
      {? _px_obj<>null()
      || {? exec('get_ilosc_que','px_obj',exec('get_mainversion','px_ver'),_px_obj)>0
         || _value:='Q'
         ?}
      ?}
   ?};
   GROP.PLAN_PX:=_value;
   _can_continue:=GROP.put()
?};
GROP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\delete_plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Usuwa grupę operacji z planu
::   WE: [_a] - GROP.ref() - grupa operacji
::       [_b] - INTEGER - 0/[1] - usuwać z planu strategicznego
::       [_c] - INTEGER - 0/[1] - usuwać z planu operacyjnego
::       [_d] - INTEGER - 0/[1] - czy inicjować i wyświetlać KOMM
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(GROP.ref())
|| _ref:=_a
?};
_del_px:=1;
{? var_pres('_b')=type_of(0)
|| _del_px:=_b
?};
_del_po:=1;
{? var_pres('_c')=type_of(0)
|| _del_po:=_c
?};
_komm:=1;
{? var_pres('_d')=type_of(0)
|| _komm:=_d
?};

_result:=0;
_can_continue:=1;
_plan_deleted:=0;

GROP.cntx_psh();
{? _ref<>null()
|| GROP.prefix();
   {? GROP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? _komm>0
   || KOMM.init(250,,'Usuwanie grupy operacji z planów produkcji.'@)
   ?};
   _can_del:=1;
   {? GROP.ILW>0 & exec('get','#params',500621)<>'Z'
   ||
::    Grupa ma wykonania i synchronizacja wykonań plan->zlecenie, nie można usuwać
::    bo znikną ZLGD i analiza zlecenia da koszt robocizny mniejszy niż powinien
      _can_del:=0
   ?};
   {? _can_del>0
   ||
::    1. Plan strategiczny
      {? _del_px>0
      ||
         _px_obj:=exec('get_grop_object','px_obj',GROP.ref());
         {? _px_obj<>null() & exec('can_del_px','px_grop')>0
         ||
            _mainver:=exec('get_mainversion','px_ver');
            PX_CONN.cntx_psh();
            PX_CONN.index('VER');
            PX_CONN.prefix(_mainver,_px_obj);
            _ref_table:=exec('ref_table','#table');
            {? PX_CONN.first()
            || {!
               |? _ref_table.add(PX_CONN.PX_GRP);
                  PX_CONN.next()
               !}
            ?};
            _can_continue:=1;
            _tab:=_ref_table.tab;
            _px:=0;
            {? _tab.first()
            || _px:=1;
               {!
               |? _next:=0;
                  _ref_nxt:=null();
                  _tab.cntx_psh();
                  {? _tab.next()
                  || _ref_nxt:=_tab.ref()
                  ?};
                  _tab.cntx_pop();

                  _can_continue:=exec('clean_from_plan','px_grp',_tab.SQL,1,1,1,0);

                  {? _ref_nxt<>null()
                  || _next:=_tab.seek(_ref_nxt)
                  ?};
                  _next>0 & _can_continue>0
               !}
            ?};
            {? _can_continue>0
            || {? _tab.first()
               || {!
                  |? _can_continue:=exec('delete','px_grp',_tab.SQL);
                     {? _can_continue>0 || _plan_deleted:=1 ?};
                     _tab.next() & _can_continue>0
                  !}
               ?}
            ?};
            {? _px>0
            || {? _can_continue=0
               || _msg:='Nie udało się usunąć grupy: %1 z planu strategicznego.'@[GROP.KOD];
                  KOMM.add(_msg,2)
               ?}
            ?};
            exec('il_plan_refresh','px_obj',_px_obj);
            exec('planend_refresh','px_obj',_px_obj);
            PX_CONN.cntx_pop()
         ?}
      ?};
      {? _del_po>0
      ||
::       2. Plan operacyjny
         PL_OGR.cntx_psh();
         PL_OGR.index('GROP');
         PL_OGR.prefix(GROP.ref());
         {? PL_OGR.first()
         || {!
            |? _can_continue:=exec('delete','po_ogr',PL_OGR.ref());
               {? _can_continue>0 || _plan_deleted:=1 ?};
               PL_OGR.first() & _can_continue>0
            !}
         ?};
         PL_OGR.cntx_pop()
      ?}
   || _can_continue:=0;
      _msg:='Nie udało się usunięcie z planu podczas zamykania grupy: %1 ze względu na parametr: %2.'@[GROP.KOD,'500621'];
      KOMM.add(_msg,2)
   ?};

:: "Naprawa" GROPS po usunięciu GROP z planu
   {? _can_continue>0 & _plan_deleted>0
   || exec('plan_restore_grop','zl_grop',GROP.ref())
   ?};

   {? _komm>0
   || KOMM.select()
   ?};
   ~~
?};
GROP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\can_del_px
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy można usunąć grupę operacji z planu strategicznego
::   WE: [_a] - GROP.ref() - grupa operacji lub bieżący rekord
::       [_b] - INTEGER 0/[1] - czy dodawać info do KOMM o niepowodzeniu
::   WY: 0 - nie można usuwać
::       1 - można usuwać
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(GROP.ref())
|| _ref:=_a
?};
_komm:=1;
{? var_pres('_b')=type_of(0)
|| _komm:=_b
?};

_result:=0;
_can_continue:=1;

GROP.cntx_psh();
{? _ref<>null()
|| GROP.prefix();
   {? GROP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| GROPP.cntx_psh();
   GROPP.index('GROP');
   GROPP.prefix(GROP.ref());
   {? GROPP.first()
   || {!
      |?
         {? GROPP.ZL<>null()
         || {? exec('zl_planned','px_obj',GROPP.ZL,exec('get_mainversion','px_ver'))>0
            || _can_continue:=0;
               {? _komm>0
               || KOMM.add('Nie można usunąć automatycznie grupy: %1 z planu ponieważ w planie są jeszcze powiązane zlecenia'@[exec('GROP','#to_string')])
               ?}
            ?}
         ?};
         GROPP.next() & _can_continue>0
      !}
   ?};
   GROPP.cntx_pop();
   ~~
?};
GROP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\predivision
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Pokazuje okno wertowania w którym należy rozpisać uruchomienia grup operacji
::       na zasoby
::   WE: _a - tab_tmp - tablica tymczasowa planowanych PX_OBJ będącymi GROPami
::   WY: tab_tmp - tablica z rozpisanymi ilościami lub ~~ jeżeli użytkownik zrezygnował
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_dropped:=_a;

_result:=~~;

_dropped.cntx_psh();
_dropped.prefix();
{? _dropped.size()>1
||
:: Rozpiska grupowa
   _result:=exec('predivision_group','px_grop',_dropped)
||
:: Rozpiska pojedyńcza
   _result:=exec('predivision_single','px_grop',_dropped)
?};
_dropped.cntx_pop();
_result


\predivision_single
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Pokazuje okno wertowania w którym należy rozpisać uruchomienia grup operacji
::       na zasoby
::   WE: _a - tab_tmp - tablica tymczasowa planowanych PX_OBJ będącymi GROPami
::   WY: tab_tmp lub ~~ jeśli user zrezygnował
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_dropped:=_a;
_tab:=exec('predivision_tab','px_grop');
_wer:=exec('predivision_win','px_grop',_tab);

_result:=~~;
exec('predivision_load','px_grop',_dropped,_tab);
_tab.win_sel(_wer);

{? _tab.size()=1 & _tab.first()
||
:: Jeżeli tylko jeden zasób to usuwam rekord w tabelce i dodaję go ponownie
:: z pełną ilością, żeby od razu podpowiedziała mi się pełna dostępna ilość
   _grops:=_tab.GROPS;
   GROPS.cntx_psh(); GROPS.prefix();
   {? GROPS.seek(_grops)
   || _tab.erase();
      exec('predivision_grops2tab','px_grop',_tab,1)
   ?};
   GROPS.cntx_pop()
?};
{? _tab.select()>0
|| _result:=_tab
?};
_result


\predivision_group
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Pokazuje okno wertowania w którym należy wybrać zasób wspólny ze wszystkich zasobów
::
::   WE: _a - tab_tmp - tablica tymczasowa planowanych PX_OBJ będącymi GROPami
::   WY: tab_tmp lub ~~ jeśli user zrezygnował
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_dropped:=_a;
_tab:=exec('predivision_tab','px_grop');
_wer:=exec('predivision_win_grp','px_grop',_tab);

_result:=~~;
exec('predivision_load','px_grop',_dropped,_tab);
_dropped.prefix();
_ndx:=_tab.ndx_tmp(,,'COUNT',,,'KOD',,);
_tab.index(_ndx);
_tab.prefix(_dropped.size());
_tab.win_sel(_wer);
{? _tab.select()>0
|| _result:=_tab
?};
_tab.ndx_drop(_ndx);
_result


\predivision_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca tabelkę tymczasową dla rozpiski
::   WY: tab_tmp
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(2
         ,'KOD','STRING[10]','Kod'@
         ,'GROPS','STRING[16]','$GROPS.ref()'
         ,'CZAS','TIME','Czas'
         ,'OPIS','STRING[60]','Opis'@
         ,'IL_PLAN','INTEGER','Ilość do planu'@
         ,'IL','INTEGER','Ilość pozostała'@
         ,'ILW','INTEGER','Ilość wykonana'@
         ,'PL_RES','STRING[16]','Ref SQL zasobu'@
         ,'RES_SYM','STRING[60]','Zasób'@
         ,'COUNT','REAL','Ilość wystąpień'@
         ,'SELECTED','STRING[1]','Dla akcji grupowej, czy wybrany'
         ,'DEFAULT','STRING[1]','Domyślny?'@
);
_tab


\predivision_win
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca okienko tymczasowe dla rozpiski
::   WE: _a - tab_tmp - tabela tymczasowa dla rozpiski
::   WY: STRING
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_wer:=_tab.mk_sel('Planowanie operacji grupowych'@,'P',,'#predivgrops',,,,,'U',,,,,,,'on');
_tab.win_fld(_wer,,'DEFAULT',,,-10,,,,,,2,,"\'T\'","\'N\'");
_tab.win_fld(_wer,,'KOD');
_tab.win_fld(_wer,,'RES_SYM',,,30,,,'Zasób'@);
_tab.win_fld(_wer,,'CZAS',,,12);
_tab.win_fld(_wer,,'IL',,,-11);
_tab.win_fld(_wer,,'ILW',,,-11);
_tab.win_fld(_wer,,'IL_PLAN',,,-11);

_formula:="
   _tab:=cur_tab(1,1);
   _valid:=\"1\";

   _grop:=exec('FindAndGet','#table',GROPS,_tab.GROPS,,\"GROPS.GROP\",null());
   _px_obj:=exec('get_grop_object','px_obj',_grop);
   _mainver:=exec('get_mainversion','px_ver');
   _sum_plan:=0;
   _sum_wyk:=0;
   _tab.cntx_psh();
   {? _tab.first()
   || {!
      |? _sum_plan+=_tab.IL_PLAN;
         _sum_wyk+=_tab.ILW;
         _tab.next()
      !}
   ?};
   _tab.cntx_pop();

   {? _tab.IL_PLAN>0
   || _left:=_tab.IL_PLAN
   || _left:=_tab.IL-_sum_plan;
      _left:=exec('max','#math',0,_left)
   ?};

   _value:=exec('edit_number','#edit',_left,'Ilość do planu'@,0,0,,_valid);
   {? type_of(_value)=type_of(0)
   || _tab.IL_PLAN:=_value;
      _tab.put()
   ?}
";
_tab.win_act(_wer,,'Formuła','Popraw'@@,,,_formula,,1,,,,'P');
_formula:="
   _suma:=0;
   _can_continue:=1;
   _tab:=cur_tab(1,1);
   _can_continue:=exec('predivision_verify','px_grop',_tab);

   {? _can_continue>0
   || sel_exit()
   ?};
   ~~
";
_tab.win_act(_wer,,'Formuła','Zatwierdź'@@,,,_formula,,,,,,'Z',,'target=window');
_tab.win_btn(_wer,'text=%1,panel=bottom,align=end'['Zatwierdź&'@],'menu:Z');
_tab.win_btn(_wer,'text=%1,panel=bottom,align=end'['Anuluj'@],'key:Esc');
_wer


\predivision_win_grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca okienko tymczasowe dla rozpiski
::   WE: _a - tab_tmp - tabela tymczasowa dla rozpiski
::   WY: STRING
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_wer:=_tab.mk_sel('Planowanie operacji grupowych'@,'P',,'#predivgrops2',,,,,'U',,,,,,,'on');
_tab.win_fld(_wer,,'KOD');
_tab.win_fld(_wer,,'RES_SYM',,,30,,,'Zasób'@);

_formula:="
   _can_continue:=1;
   _tab:=cur_tab(1,1);
::   _can_continue:=exec('predivision_verify','px_grop',_tab);
   _tab.SELECTED:='T';
   _can_continue:=_tab.put();
   {? _can_continue>0
   || sel_exit()
   ?};
   ~~
";
_tab.win_act(_wer,,'Formuła','Wybierz'@@,,,_formula,,1,,,,'W',,'target=record');
::_tab.win_btn(_wer,'text=%1,panel=bottom,align=end'['Zatwierdź'@],'menu:Z');
::_tab.win_btn(_wer,'text=%1,panel=bottom,align=end'['Anuluj'@],'key:Esc');
_wer



\predivision_load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Ładuje zawartość tabeli dla rozpiski
::   WE: _a - tab_tmp - tabela z obiektami do zaplanowania (PX_OBJ)
::       _b - tab_tmp - tabela z rozpiską
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_dropped:=_a;
_tab:=_b;

_dropped.cntx_psh();
_dropped.prefix();

{? _dropped.size()>1
||
   {? _dropped.first()
   || PX_OBJ.cntx_psh();
      PX_OBJ.prefix();
      {!
      |? {? PX_OBJ.seek(_dropped.REF,)
         || {? PX_OBJ.GROP<>null()
            || exec('predivision_add','px_grop',PX_OBJ.GROP,_tab)
            ?}
         ?};
         _dropped.next()
      !};
      PX_OBJ.cntx_pop()
   ?}
||
   {? _dropped.first()
   || PX_OBJ.cntx_psh(); PX_OBJ.prefix();
      {? PX_OBJ.seek(_dropped.REF,)
      || {? PX_OBJ.GROP<>null()
         || exec('predivision_add','px_grop',PX_OBJ.GROP,_tab)
         ?}
      ?};
      PX_OBJ.cntx_pop()
   ?}
?};
_dropped.cntx_pop();
~~


\predivision_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Dodaje rekordy do rozpiski
::   WE: [_a] - GROP.ref() - grupa operacji lub bieżący rekord
::       _b - tab_tmp - tabelka z rozpiska
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(GROP.ref())
|| _ref:=_a
?};
_tab:=_b;

_tab.cntx_psh();
_result:=0;
_can_continue:=1;

GROP.cntx_psh();
{? _ref<>null()
|| GROP.prefix();
   {? GROP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| GROPS.cntx_psh();
   GROPS.index('GROP');
   GROPS.prefix(GROP.ref());
   {? GROPS.first()
   || {!
      |? _can_continue:=exec('predivision_grops2tab','px_grop',_tab);
         GROPS.next() & _can_continue>0
      !}
   ?};
   GROPS.cntx_pop()
?};
GROP.cntx_pop();
_tab.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\predivision_grops2tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Dodaje jeden rekord GROPS do rozpiski
::       Kontekst pracy - rekord GROPS
::   WE: _a - tab_tmp - tabelka z rozpiska
::       [_b] - INTEGER - czy dodawać całą ilość dostępną
::   WY: 0 - porazka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_ilosc_all:=0;
{? var_pres('_b')=type_of(0)
|| _ilosc_all:=_b
?};

_result:=0;
_px_obj:=exec('get_grop_object','px_obj',GROPS.GROP);
_mainver:=exec('get_mainversion','px_ver');
_ndx:=_tab.ndx_tmp(,,'PL_RES',,);
_tab.index(_ndx);
_tab.prefix($GROPS.PL_RES,);
{? _tab.first()
|| _tab.COUNT+=1;
   _result:=_tab.put()
||
   _tab.KOD:=GROPS.KOD;
   _tab.GROPS:=$GROPS.ref();
   _tab.OPIS:=GROPS.OPIS;
   _tab.CZAS:=GROPS.CZAS;
   _tab.IL:=GROPS.GROP().IL-exec('get_ilosc_que','px_obj',_mainver,_px_obj);
   _tab.IL:=exec('max','#math',0,_tab.IL);
   {? _ilosc_all>0
   || _tab.IL_PLAN:=GROPS.GROP().IL-exec('get_ilosc_que','px_obj',_mainver,_px_obj)-GROPS.ILW
   || _tab.IL_PLAN:=0
   ?};
   _tab.ILW:=GROPS.ILW;
   _tab.RES_SYM:=GROPS.PL_RES().SYM;
   _tab.PL_RES:=$GROPS.PL_RES;
   _tab.COUNT:=1;
   _tab.DEFAULT:=GROPS.DEFAULT;
   _result:=_tab.add()
?};
_tab.ndx_drop(_ndx);
_result


\predivision_verify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Weryfikacja okienka z rozpiską
::   WE: _a - tab_tmp - tabela tymczasowa z rozpiską
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_can_continue:=1;
_result:=0;

_suma:=0;
_tab.cntx_psh();
{? _tab.first()
|| {!
   |? _suma+=_tab.IL_PLAN;
      _tab.next()
   !}
?};
{? _suma>GROP.IL
|| _can_continue:=0;
   FUN.emsg(
      'Suma ilości uruchomień na poszczególnych zasobach (%1)\n'
      'nie może być większa niż planowana dla grupy operacji (%2).'@
      [$_suma,$GROP.IL]
   )
?};
{? _suma=0
|| _can_continue:=0;
   FUN.emsg('Należy określić co najmniej jeden zasób z niezerową ilością uruchomień do planu.'@)
?};

{? _tab.first() & _can_continue>0
|| {!
   |? PL_RES.cntx_psh();
      GROPS.cntx_psh();
      GROPS.prefix();
      {? GROPS.seek(_tab.GROPS)
      ||
         {? var_pres('_konty')>100
         || obj_del(_konty)
         ?};
         _konty:=exec('plres2pxkont','px_tie',GROPS.PL_RES,PX_VAR.VER_QUE);
         {? type_of(_konty)>0 & _konty.first()
         || ~~
         || FUN.emsg('Nie znaleziono zasobu w planie odpowiadającemu zasobowi w grupie operacji: %1'@[GROPS.PL_RES().SYM]);
            _can_continue:=0
         ?};

         {? _can_continue>0 & _tab.IL_PLAN>0
         ||
            {? var_pres('_pxpack')>100
            || obj_del(_pxpack)
            ?};
            {? var_pres('_paczka')>100
            || obj_del(_paczka)
            ?};
            _pxpack:=exec('trzepaczka_grop','px_tex',GROPS.ref(),_tab.IL,,exec('get_grop_object','px_obj',GROPS.GROP));
            _paczka:=_pxpack.Paczka;
            _ndx_num:=_pxpack.Ndx_fwd;
::            exec('paczka_select','px_tex',_pxpack);
            _paczka.index(_ndx_num);
            _paczka.prefix('K');
            {? _paczka.first()
            || _jm1:=exec('get','#params',500380);
               _jm2:=exec('get','#params',500381);
               {? exec('pck_oper_empty','px_tex',_paczka)=0
               || _can_continue:=0;
                  FUN.emsg('Zasób: %1 jest nieprawidłowo skonfigurowany, prawdopodobnie nie posiada wymiarów w jm: %2 lub %3'@[_paczka.SYMBOL,_jm1,_jm2])
               ?}
            || FUN.emsg('Nie znaleziono zasobu w planie: %1'@[PX_VAR.GROPS().PL_RES().SYM])
            ?}
         ?}
      ?};
      GROPS.cntx_pop();
      PL_RES.cntx_pop();
      _tab.next() & _can_continue>0
   !}
?};
_tab.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result





:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:37 b0e6c9a61b395fe1c3ea0187492c96b2b7b9f846693aada5c33759d42aff6ff8cc033563d0dabfb99e205d243a3c77a334f7d4afc47098e70ff3f0ddf49448fae83d8c37903db8a6e3e607986954a76a017bda37c791a245f17cb1abd388cc3f26b21a35dbc1da50d58b9603256dc2d3d26146e48f31e899dfc89c526cb2d703
