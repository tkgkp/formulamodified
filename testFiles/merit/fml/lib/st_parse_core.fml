:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: st_parse_core.fml
:: Autor: WH
::======================================================================================================================
:: Zawartość: Formuły do parsowania plików .mstat - mechanizm parsujący
::======================================================================================================================


\parse
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Formuła rozpoczynająca parsowanie zapisów tabeli źródłowej
::   WE: _a - obj_new - obiekt środowiska, wynik działania exec('env_parse','st_common')
::   WY: -1 - wystąpił nieoczekiwany błąd
::       0..N - liczba komunikatów powstałych podczas parsowania
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_dialog:=_env.DIALOG;
_progress:=_dialog;

{? _dialog=2
|| KOMM.init(250,,'Parsowanie zapisów źródłowych'@)
?};

exec('init','st_common');

_result:=0;
_can_continue:=1;

_tab_uid:=tab_tmp(1,
:: 'POLE','TYP','Nazwa w oknie',
   'UID_GRP','STRING[16]','Nazwa pola 1'
);

:: Parsowanie odbywa się po wszystkich maskach aktywnych
ST_ARCH.cntx_psh();

ST_ARCH.index('ACTIVE');
ST_ARCH.prefix('T');

_prg_step:=1000;
:: Inicjalizuję progressy
{? _progress>0
||
   _size:=0;
   {? ST_ARCH.first()
   || {!
      |?
         exec('open','st_arch',ST_ARCH.MASK,0,2);
         exec('cntx_psh','st_arch');
         ST_SRC.index('PARSED');
         ST_SRC.prefix('N',);
         _size+=ST_SRC.size();
         exec('cntx_pop','st_arch');
         ST_ARCH.next()
      !}
   ?};

   _argsprog:=_env.PROGRESS;
   _argsprog.add_progress('Zbieranie identyfikatorów grupujących...'@,_size/_prg_step);
   exec('start','#progress',_argsprog)
?};

_env.ST_SRC:=null();
{? _can_continue>0 & ST_ARCH.first()
||
   _locked:=null();
   {? exec('blk_lock','#table','ST_ARCH',ST_ARCH.ref(),,,'Pliki są parsowane'@,,{? _dialog>0 || 1 || 2?})>0
   || _locked:=ST_ARCH.ref();
      {!
      |?
         _can_continue:=1;
         _break:=0;
         _tab_uid.erase();
         _lp:=0;
::       Otwarcie tabel maskowanych
         exec('cntx_psh','st_arch');
         exec('open','st_arch',ST_ARCH.MASK,0,2);

         {? _can_continue>0
         ||
::          W pierwszej pętli zbieram identyfikatory grupujące nieprzetworzonych zapisów
            ST_SRC.index('PARSED');
            ST_SRC.prefix('N',);
            {? ST_SRC.first()
            || {!
               |? _tab_uid.prefix(ST_SRC.UID_GRP,);
                  {? _tab_uid.first()=0
                  || _tab_uid.blank();
                     _tab_uid.UID_GRP:=ST_SRC.UID_GRP;
                     _can_continue:=_tab_uid.add()
                  ?};
                  ST_SRC.next() & _can_continue>0
               !}
            ?}
         ?};

         ST_SRC.index('UID_GRP');
         _tab_uid.prefix();
         {? _can_continue>0 & _tab_uid.first()
         ||
            {!
            |?
               _parse_ok:=1;
               ST_SRC.prefix(_tab_uid.UID_GRP,);
               {? ST_SRC.first()
               ||
                  _filename:='';
::                Rozpoczęcie transakcji - trasakcja dotyczy wszystkich rekordów które mają ten sam UID_GRP
                  _env.ERRORS:=0;
                  do();
                  {!
                  |?
                     _lp+=1;
                     {? _progress>0 & _lp%*_prg_step=0
                     || _parse_ok:=exec('next_step','#progress',_argsprog,1);
                        {? _parse_ok=0
                        || _break:=1
                        ?};
                        _argsprog.ph_sname(1,'Parsowanie pliku: %1'@[ST_SRC.FILENAME])
                     ?};
                     {? _parse_ok>0
                     ||
                        {? ST_SRC.r_lock(1)
                        ||
                           _line:=ST_SRC.memo_txt(,1,'LINE');
                           _filename:=ST_SRC.FILENAME;
                           _uid_grp:=ST_SRC.UID_GRP;
                           {? _line<>''
                           ||
                              _env.ST_SRC:=ST_SRC.ref();
::                            Parsowanie pojedynczej linii
                              {? var_pres('_res_obj')>100
                              || obj_del(_res_obj)
                              ?};
                              _res_obj:=exec('create_parse_obj','st_parse_core',_env,_line,_filename);

                              {? _res_obj.RESULT>0
                              ||
::                               Obiekt utworzony rozpoczynam uruchomienie formuły parsującej
                                 _parse_ok:=exec('parse_single','st_parse_core',_env,_line,_filename,_res_obj.OBJ,_uid_grp);

                                 {? _parse_ok>0
                                 || ST_SRC.PARSED:='T';
                                    _can_continue:=ST_SRC.put()
                                 ?}
                              || _parse_ok:=0
                              ?}
                           ?};
                           ST_SRC.r_unlock()
                        ||
                           _parse_ok:=0;
                           _msg:='Błąd parsowania. Nie udała się blokada rekordu ST_SRC: %1'@[$ST_SRC.ref()];
                           _env.message(_msg,,_filename,'error')
                        ?}
                     ?};
                     ST_SRC.next() & _can_continue>0 & _parse_ok>0
                  !};

                  {? _can_continue<=0 | _parse_ok<=0
                  || undo()
                  ?};

                  {? end()=0 & _env.ERRORS=0
                  || _can_continue:=0;
                     _msg:='Błąd parsowania. Plik %1 wycofał transakcję.'@[_filename];
                     _env.message(_msg,,_filename,'error')
                  ?};

::                Jeżeli transakcja została wycofana to oznaczam wszystkie rekordy
::                spięte jednym identyfikatorem grupującym jako błędnie sparsowane
                  {? _can_continue<=0 | _parse_ok<=0
                  || {? ST_SRC.first()
                     || {!
                        |? ST_SRC.PARSED:='X';
                           ST_SRC.put();
                           ST_SRC.next()
                        !}
                     ?}
                  ?};
                  ~~
               ?};
               _tab_uid.next() & _break=0 & _can_continue>0
            !}
         ?};
         exec('cntx_pop','st_arch');
         ST_ARCH.next() & _break=0 & _can_continue>0
      !};
      {? _locked<>null()
      || exec('blk_unlock','#table','ST_ARCH',_locked)
      ?}
   ?}
?};
:: Zatrzymanie progressa
{? _progress>0
|| _argsprog.ctr_stop()
?};

:: Przetwarzanie komunikatów o błędach
_komm_size:=0;
_tab:=_env.TAB_ERR;
_tab.cntx_psh();
_tab.index(_env.NDX_ERR1);
_tab.prefix();
{? _tab.first()
|| _komm_size:=_tab.size();
   {!
   |?
      _line:=form(_tab.LINE);
      {? _line<>''
      ||
         ST_SRC.cntx_psh();
         _name:=ST_SRC.name();
         _msk:=(8+_tab.ST_SRC)+4;
         _new_mask:=4+_name;
         _new_mask+=_msk;
         ST_SRC.use(_new_mask);
         ST_SRC.prefix();
         {? ST_SRC.seek(_tab.ST_SRC)
         ||
            ST_SRC.HAS_MSG:='T';
            _can_continue:=ST_SRC.put();
            {? _can_continue>0
            || _msg:=_tab.memo_txt(,1,'MESSAGE');

               _current:=ST_SRC.memo_txt(,1,'MESSAGE');
               {? _current<>''
               || _current+='\n'+_msg
               || _current:=_msg
               ?};
               ST_SRC.memo_set(_current,'MESSAGE');
               ST_SRC.memo_put(,'MESSAGE')
            ?}
         ?};

::       Teraz dodaję info do KOMMa
         {? _dialog=2
         || exec('parse_error','st_parse_core',_env,_line,_dialog,_tab.ICON,_tab.SECT)
         ?};
         ST_SRC.cntx_pop()
      ?};
      _tab.next()
   !}
?};
_tab.cntx_pop();
_env.ST_SRC:=null();

{? _can_continue>0
|| _result:=_komm_size
|| _result:=-1
?};

{? _dialog=2
|| KOMM.select()
?};
ST_ARCH.cntx_pop();
_result


\parse_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Akcja Parsuj w procesie
::   WY: STRING - '' wszystko ok
::                'ERROR' - błąd
::
::----------------------------------------------------------------------------------------------------------------------
_env:=exec('env_parse','st_common');
_env.DIALOG:=0;
_can_continue:=exec('parse','st_parse_core',_env);

_result:='';
{? _can_continue=-1
|| _result:='ERROR'
|? _can_continue>0
|| _result:=exec('parse','st_mail',_env)
?};
_result


\parse_gate_error
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Warunek na bramie - do komunikatów
::   WE: _a - STRING - treść do analizy
::   WY: 0/1
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_msg:=_a;

_result:=0;

{? _msg='ERROR'
|| _result:=1
?};
_result


\parse_gate_komm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Warunek na bramie - do komunikatów
::   WE: _a - STRING - treść do analizy
::   WY: 0/1
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_msg:=_a;

_result:=0;

{? _msg<>'' & _msg<>'ERROR'
|| _result:=1
?};
_result


\create_parse_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Tworzenie obiektu z wartosciami do sparsowania
::   WE: _a - obj_new - obiekt środowiska, wynik działania exec('env_parse','st_common')
::       _b - STRING - linia którą sparsować
::       _c - STRING - nazwa parsowanego pliku
::   WY: obj_new('RESULT','OBJ')
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_line:=_b;
_filename:=_c;

_dialog:=_env.DIALOG;

_result:=obj_new('RESULT','OBJ');
_result.RESULT:=0;
_result.OBJ:=~~;
_can_continue:=1;

{? _line<>'' & _line<>'\n'
||
:: Zamieniam \, na losowy ciąg znaków żeby móc ciąć string po przecinkach
   _comma:='__comma%1__'[$SYSLOG.tm_stamp()];
   _line:=gsub(_line,'\\%1'[_env.SEPARATOR],_comma);

:: Tnę wiersz na elementy
   _split:=spli_str(_line,_env.SEPARATOR);
   _len:=obj_len(_split);

:: W każdym pociętym elemencie przywracam normalny ,
   {! _it:=1.._len
   |! {? _split[_it]*_comma>0
      || _split[_it]:=gsub(_split[_it],_comma,',')
      ?};
::    Usuwam wiądące ""
      {? (1+_split[_it])='"' & (_split[_it]+1)='"'
      || _split[_it]:=1-_split[_it]-1
      ?}
   !};

   _what:='';
   _time:='';
   {? _len>1
   ||
      _what:=_split[1];
      _time:=_split[2]
   ||
      _can_continue:=0;
      _msg:='Błąd parsowania. Do parsowania są potrzebne min. 3 elementy oddzielone separatorem (%1)'@[_line];
      _env.message(_msg,,_filename,'error')
   ?};

   {? _can_continue>0 & _what=''
   ||
      _can_continue:=0;
      _msg:='Błąd parsowania. Nie określono rodzaju zapisu w linii: %1'@[_line];
      _env.message(_msg,,_filename,'error')
   ?};

   {? _can_continue>0 & _time=''
   ||
      _can_continue:=0;
      _msg:='Błąd parsowania. Nie określono czasu w linii: %1'@[_line];
      _env.message(_msg,,_filename,'error')
   ?};

   {? _can_continue>0
   ||
      ST_RODZ.cntx_psh();
      ST_RODZ.index('SYMBOL');
      ST_RODZ.prefix(_what,);
      {? ST_RODZ.first()=0
      || _can_continue:=0;
         _msg:='Błąd parsowania. Nieznany rodzaj elementu: %1'@[_what];
         _env.message(_msg,,_filename,'error')
      ?};
      ST_RODZ.cntx_pop()
   ?};


   {? _can_continue>0
   ||
::    Wywołuję formułkę tworzącą obiekt
      _rule:='exec(\'%1\',\'st_parse_obj\')'[_what];
      _obj:=($_rule)();

::    Najpierw nawijamy standardowe pola
      _obj.KIND:=_what;
      _tm_stamp:=#_time;
      _date:=utc_date(_tm_stamp);
      _time:=utc_time(_tm_stamp);
      _obj.DATE:=_date;
      _obj.TIME:=_time;
      _std_fields:=3;
      _len_obj:=obj_len(_obj);

::    Jeżeli wiersz ma coś powyżej standardowych pól to pętlimy
      {? _len>2
      ||
         _num:=0;
         {! _it:=3.._len
         |! _value:=_split[_it];
            _num+=1;
            {? _value<>'' & _value<>'\n'
            || _fld_num:=_std_fields+_num;
               {? _len_obj>=_fld_num
               ||
                  _rule_set:='_obj:=_a;_val:=_b;_obj[%1]:=_val'[$(_fld_num)];
                  ($_rule_set)(_obj,_value)
               ||
                  _can_continue:=0;
                  _msg:='Błąd parsowania pliku: %1. Niepoprawny wiersz niezgodny z legendą.'@[_filename];
                  _env.message(_msg,,_filename,'error')
               ?}
            ?}
         !}
      ?};
      _result.OBJ:=_obj
   ?}
?};

{? _can_continue>0
|| _result.RESULT:=1
?};
_result


\parse_obj_to_string
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Zamienia obiekt
::   WE: _a - obj_new - obiekt środowiska, wynik działania exec('env_parse','st_common')
::       _b - obj_new - obiekt do parsowania
::       [_c] - STRING - czas utc
::   WY: STRING - tekstowa reprezentacja obiektu
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_obj:=_b;
_utc:='';
{? var_pres('_c')=type_of('')
|| _utc:=_c
?};

_result:='';

_date:=_obj.DATE;
_time:=_obj.TIME;
_kind:=_obj.KIND;

{? _utc=''
|| _tm_stamp:=exec('create','#tm_stamp',_date,_time);
   _utc:=$exec('to_utc','#tm_stamp',_tm_stamp)
?};

_result:=_kind;
_result+=_env.SEPARATOR+_utc;

{? obj_len(_obj)>3
||
   {! _it:=4..obj_len(_obj)
   |! _value:=_obj[_it];

      {? _value*_env.SEPARATOR>0
      ||
::    Jeżeli wartość zawiera przecinek to całość należy obudować "" a przecinek zbackslashować
         _value:=gsub(_value,_env.SEPARATOR,'\\'+_env.SEPARATOR);
         _value:='"'+_value+'"'
      ?};
      _result+=_env.SEPARATOR+_value
   !}
?};
_result


\parse_error
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Obsługa komunikatów o błędach podczas parsowania
::   WE: _a - obj_new - obiekt środowiska, wynik działania exec('env_parse','st_common')
::       _b - STRING - treść komunikatu
::       _c - INTEGER - tryb wyświetlania dialogów
::       [_d] - INTEGER - nr ikony
::       [_e] - STRING - sekcja komunikatu
::       [_f] - STRING - rodzaj komunikatu, domyślnie 'error'
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_msg:=_b;
_dialog:=_c;

_icon:=2;
{? var_pres('_d')=type_of(0) | var_pres('_d')=type_of('')
|| _icon:=_d
?};

_sect:='';
{? var_pres('_e')=type_of('')
|| _sect:=_e
?};

_kind:='error';
{? var_pres('_f')=type_of('')
|| _kind:=_f
?};

_nr_root:=0;

_env.ERRORS:=1;

{? _dialog=2 & KOMM.is_inited()
||
   {? _sect<>''
   || _sect_nr:=KOMM.find_msg(_sect,_nr_root);
      {? _sect_nr
      || KOMM.set_root(_sect,_nr_root)
      || _sect_nr:=KOMM.sect_beg(_sect)
      ?}
   ?};

   {? _sect<>''
   || {? KOMM.find_msg(_msg,_sect_nr)=0
      || KOMM.add(_msg,_icon,,1)
      ?};
      KOMM.sect_end()
   || {? KOMM.find_msg(_msg)=0
      || KOMM.add(_msg,_icon,,1)
      ?}
   ?}
?};

{? _dialog=3 & _env.ST_SRC<>null()
|| _tab:=_env.TAB_ERR;
   _line:=255+_msg;
   _tab.cntx_psh();
   _tab.index(_env.NDX_ERR2);
   _tab.prefix($_env.ST_SRC,_line,);
   {? _tab.first()=0
   || _tab.blank();
      _tab.ST_SRC:=$_env.ST_SRC;
      _tab.LINE:=_msg;
      {? type_of(_icon)=type_of(0)
      || _tab.ICON:=$_icon
      || _tab.ICON:=_icon
      ?};
      _tab.TM_STAMP:=ST_SRC.tm_stamp();
      _tab.SECT:=_sect;
      _tab.KIND:=_kind;
      {? _kind='lic'
      || _tab.LICENCE:=1
      ?};
      _tab.FILEPATH:=exec('FindAndGet','#table',ST_SRC,$_env.ST_SRC,,"FILEPATH",'');
      _tab.FILENAME:=exec('FindAndGet','#table',ST_SRC,$_env.ST_SRC,,"FILENAME",'');
      {? _tab.add()
      || _tab.memo_set(_msg,'MESSAGE');
         _tab.memo_put(,'MESSAGE')
      ?}
   ?};
   _tab.cntx_pop()
?};
~~


\parse_single
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Uruchamia pojedyncza formule z interfejsu parsera
::   WE: _a - obj_new - obiekt środowiska, wynik działania exec('env_parse','st_common')
::       _b - STRING - linia którą sparsować
::       _c - STRING - nazwa parsowanego pliku
::       _d - obj_new - obiekt z wartościami
::       _e - STRING - identyfikator grupujący
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_line:=_b;
_filename:=_c;
_obj:=_d;
_uid_grp:=_e;

_dialog:=_env.DIALOG;

_result:=0;
_can_continue:=1;
_what:='';
{? var_pres('_obj')>100
|| _what:=_obj.KIND
||
   _can_continue:=0;
   _msg:='Błąd parsowania. Nie utworzono obiektu z wartościami na podstawie linii: %1'@[_line];
   _env.message(_msg,,_filename,'error')
?};

{? _can_continue>0
|| ST_RODZ.cntx_psh();
   ST_RODZ.index('SYMBOL');
   ST_RODZ.prefix(_what,);
   {? ST_RODZ.first()=0
   || _can_continue:=0;
      _msg:='Błąd parsowania. Nieznany rodzaj elementu: %1'@[_what];
      _env.message(_msg,,_filename,'error')
   ?};
   ST_RODZ.cntx_pop()
?};

{? _can_continue>0
|| _rule:='exec(\'%1\',\'st_parse\',_a,_b,_c,_d)'[_what];
   _can_continue:=($_rule)(_env,_obj,_uid_grp,_filename)
?};

{? _can_continue>0
|| _result:=1
?};
_result

:Sign Version 2.0 jowisz:1045 2022/06/30 14:23:24 95d04f74be08237755d4c81ca84dbafb21ffd8ee62321c0993a811951133730eae6bb418c3fc13f725678925a0ba60d40d4d27facf2bbff00758605bdf487a8288cdeb52ee50c2d4472671913fbca6c25eccaac4e35b2001e7c3e77a5bedd8f0299b9e140ccb3e3494b09c53319198fa0a0264c793bd1f8e4f7175b379a50786
