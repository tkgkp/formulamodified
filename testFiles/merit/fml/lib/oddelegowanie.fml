:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: oddelegowanie.fml
:: Utworzony: 11.07.2018
:: Autor: areKc
::======================================================================================================================
:: Zawartość: Plik zawiera formuły do ewidencji i rozliczenia oddelegowań do pracy za granicą.
::======================================================================================================================


\h_odde_edit_begin
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Ustawienie kontekstu pracy z oddelegowaniami do pracy za granicą.
::   WE: _a [NUMBER] - tryb modyfikacji rekordu
::          0 - dołączanie
::          1 - poprawiania
::       _b [TABLE] - Tabela dla której wywołano akcję.
::       _c [STRING] - Akronim okna redagowania.
::       [_d] [STRING] - Pola są do edycji (1/0).
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_editable:={? var_pres('_d')=type_of(0) || _d || 1 ?};
P.cntx_psh();
OSOBA.cntx_psh();
H.cntx_psh();
H_UM.cntx_psh();
H_ODDE.cntx_psh();
H_ODDP.cntx_psh();
H_ODDA.cntx_psh();
H_ODDR.cntx_psh();

H_ODDE.use('h_odde'+(H.name()+1));
H_ODDE.index('HOD');
{? _a
|| H_ODDE.prefix(H.ref());
   {? H_ODDE.first()
   || P.cntx_psh();
      OSOBA.cntx_psh();
      VAR_EDIT.T:=H_ODDE.P_ZAST().T;
      VAR_EDIT.NAZWISKO:=P.OSOBA().NAZWISKO;
      VAR_EDIT.PIERWSZE:=OSOBA.PIERWSZE;
      OSOBA.cntx_pop();
      P.cntx_pop()
   || exec('h_odde_blank','oddelegowanie')
   ?}
|| H_ODDE.prefix();
   H_ODDE.blank(1)
?};
exec('acces2fld_h_odde','oddelegowanie',_b,_c,H.ODDEL='T',,_editable);
~~


\h_odde_edit_end
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Ustawienie kontekstu pracy z oddelegowaniami do pracy za granicą.
::   WE: [_a] [STRING] - Tekst komunikatu
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_txt:={? var_pres('_a')=type_of('') || _a || '' ?};

{? +_txt
|| FUN.emsg(_txt)
?};
H_ODDR.cntx_pop();
H_ODDA.cntx_pop();
H_ODDP.cntx_pop();
H_ODDE.cntx_pop();
H.cntx_pop();
H_UM.cntx_pop();
OSOBA.cntx_pop();
P.cntx_pop();
~~


\h_oddel_editable
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Sprawdzenie czy można edytować pola oddelegowań
::   WE: [_a][INTEGER] - rozmiar, od którego większa liczba oddelegowań dyskwalifikuje edytowanie [domyślnie: 0]
::   WY: _result [INTEGER] - 0/1 czy można redagować
::----------------------------------------------------------------------------------------------------------------------
_rozmiar:={? var_pres('_a')=type_of(0) || _a || 0 ?};
{? +H.IDADD
   &
   H.ODDEL='T'
   &
   (sql('select * from H_ODDE join H using (H_ODDE.H,H.REFERENCE) where H.REFERENCE=\':_a\'',$H.ref()).size())>_rozmiar
|| _result:=0
|| _result:=1
?};
_result


\h_koddel_editable
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Sprawdzenie czy można edytować pole KODDEL w tabeli H
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? H.KODDEL='T'
   &
   sql('select distinct H_ODDE.KRAJ from H_ODDE join H using (H_ODDE.H,H.REFERENCE) where H.REFERENCE=\':_a\'',
      $H.ref()
   ).size()>1
|| _result:=0
|| _result:=1
?};
_result


\acces2fld_h_odde
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Ustawienie dostępu do edycji wszystkich pól w oknie RED tabeli H_ODDE.
::   WE: _a [TABLE] - uchwyt do tabeli w oknie, której należy zmienić dostępność edycji
::       _b [STRING] - Akronim okna redagowania
::       _c [INTEGER] - Czy pola w oknie RED tabeli H_ODDE dostępne do edycji (1-dostępne, 0-niedostępne).
::       [_d] [STRING] - Akronim pola.
::       [_e] [INTEGER] - Pola są do edycji (1/0).
::       [_f] [INTEGER] - uwzględnij również pole H.ODDEL? (1/0, domyślnie 0)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_enable:={? var_pres('_c')=type_of(0) || $_c || $0 ?};
_fld:={? var_pres('_d')=type_of('') || _d || '' ?};
_editable:={? var_pres('_e')=type_of(0) || {? ~_e || 'grayed' || $_e ?} || '1' ?};
_hOddel:={? var_pres('_f')=type_of(0) || _f || 0 ?};
{? _fld=''
|| _a.efld_opt(_b,'enable=%1,editable=%2'[_enable,_editable],H_ODDE,'O_OD');
   _a.efld_opt(_b,'enable=%1,editable=%2'[_enable,_editable],H_ODDE,'M_PRAC','NAZWA');
   _a.efld_opt(_b,'enable=%1,editable=grayed'[_enable],H_ODDE,'M_PRAC','MIASTO');
   _a.efld_opt(_b,'enable=%1,editable=%2'[_enable,_editable],H_ODDE,'M_ZAM','NAZWA');
   _a.efld_opt(_b,'enable=%1,editable=grayed'[_enable],H_ODDE,'M_ZAM','MIASTO');
   _a.efld_opt(_b,'enable=%1,editable=%2'[_enable,_editable],H_ODDE,'ZAKW');
   _a.efld_opt(_b,'enable=%1,editable=%2'[_enable,_editable],H_ODDE,'TKRS','KOD');
   _a.efld_opt(_b,'enable=%1,editable=grayed'[_enable],H_ODDE,'TKRS','TR');
   _a.efld_opt(_b,'enable=%1,editable=%2'[_enable,_editable],H_ODDE,'POD');
   _a.efld_opt(_b,'enable=%1,editable=%2'[_enable,_editable],H_ODDE,'POD_M');
   _a.efld_opt(_b,'enable=%1,editable=%2'[_enable,_editable],H_ODDE,'ZUS');
   _a.efld_opt(_b,'enable=%1,editable=%2'[_enable,_editable],H_ODDE,'ZAST');
   {? _hOddel
   || _a.efld_opt(_b,'enable=%1,editable=%2'[_enable,_editable],H,'ODDEL')
   ?}
?};
{? _fld='' | _fld='KRAJ'
|| _editableKraj:=_editable;
   {? _editableKraj='grayed'
   || _mark:=$0
   || _editableKraj:=_mark:=$0;
      {? #_enable
      || {? H.KODDEL='N'
            &
            H_ODDE.H<>null()
            &
            sql('
               select *
               from H_ODDE join H using (H_ODDE.H,H.REFERENCE)
               where H.REFERENCE=\':_a\' and H_ODDE.REFERENCE<>\':_b\'',
               $H.ref(),$H_ODDE.ref()
            ).size()
         || _editableKraj:='grayed'
         || _editableKraj:=_mark:=$1
         ?}
      ?}
   ?};
   _a.efld_opt(_b,'enable=%1,editable=%2,mark=%3'[_enable,_editableKraj,_mark],H_ODDE,'KRAJ','NAZ')
?};
{? _fld='' | _fld='ZAKW'
|| _a.efld_opt(_b,
      'enable=%1,editable=%2'[{? #_enable || $(H_ODDE.ZAKW='S') || _enable ?},_editable],H_ODDE,'ST_NOC'
   );
   _a.efld_opt(_b,
      'enable=%1,editable=%2'[{? #_enable || $(H_ODDE.ZAKW<>'N') || _enable ?},_editable],H_ODDE,'WAL_NOC','SYM'
   )

?};
{? _fld='' | _fld='ZAST'
|| {? #_enable
   || {? H_ODDE.ZAST='N'
      || _enableZast:=$0
      || _enableZast:=_enable
      ?}
   || _enableZast:=$0
   ?};
   _a.efld_opt(_b,'enable=%1,editable=%2'[_enableZast,_editable],VAR_EDIT,'T');
   _a.efld_opt(_b,'enable=%1,editable=%2'[_enableZast,'grayed'],VAR_EDIT,'NAZWISKO');
   _a.efld_opt(_b,'enable=%1,editable=%2'[_enableZast,'grayed'],VAR_EDIT,'PIERWSZE')
?};
{? _fld='' | _fld='POD'
|| _enablePodM:=_enable;
   {? #_enable & H_ODDE.POD<>'N'
   || _enablePodM:=$0
   ?};
   _editablePodM:=_editable;
   {? _editable<>'grayed' & H_ODDE.POD<>'N'
   || _editablePodM:='grayed'
   ?};
   _a.efld_opt(_b,'enable=%1,editable=%2'[_enablePodM,_editablePodM],H_ODDE,'POD_M')
?};
{? _fld='' | _fld='O_DO'
|| _a.efld_opt(_b,'enable=%1,editable=%2'[_enable,_editable],H_ODDE,'O_DO')
?}


\h_odde_blank
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Ustawienie wartości początkowych do oddelegowania.
::   WE: [_a] [NUMBER] - czy wykonywać formuły na blank dla tabeli H_ODDE?
::            0 - tak [domyślnie]
::            1 - nie
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_no_execute:={? var_pres('_a')=type_of(0) || _a || 0 ?};
H_ODDE.blank(_no_execute);
H_ODDE.H:=null();
H_ODDE.ZAST:=H_ODDE.ZAKW:='N';
H_ODDE.POD:=H_ODDE.ZUS:='T';
VAR_EDIT.NAZWISKO:=VAR_EDIT.PIERWSZE:=VAR_EDIT.T:=''


\h_odde_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po redakcji wiersza tabeli H_ODDE.
::   WE: [_a] [INTEGER] - (1/0) wykonanie funkcji z zakładki podczas edycji przebiegu zatrudnienia/z okna wertowania.
::       [_b] [STRING] - Funkcja została wywołana podczas redagownia umowy (H_UM), aneksu(H).
::       [_c] [INTEGER] - (1/0) Funkcja została wywołana podczas dodawania nowej umowy (H_UM), aneksu(H).
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_cntx:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_tab:={? var_pres('_b')=type_of('') || _b || 'H' ?};
_new:={? var_pres('_c')=type_of(0) || _c || 0 ?};

H_ODDE.cntx_psh();
H.cntx_psh();
{? _cntx
|| H.seek(H_ODDE.H,,1)
?};

:: Sprawdzenie uzupełnienia wymaganych pól.
_result:=__CHK.record2(H_ODDE,'O_OD','Data od'@,'O_DO','Data do'@,'KRAJ','Kraj oddelegowania'@,'TKRS','Tabela kursów'@);
:: Sprawdzenie poprawności wprowadzonych danych.
{? _result=''
|| H_ODDE.cntx_psh();
   H_ODDE.clear();
   _txt:='';
   _d0:=date(0,0,0);
   _curTab:=cur_tab(1,1);
   _editable:={? (_curTab=H_ODDE | exec('h_oddel_editable','oddelegowanie',1))
                 &
                 #H_ODDE.efld_opt(H_ODDE.win_edit('?'),'editable',,'O_OD')
              || 'O_'
              || ''
              ?};
   _result:=
      {? H_ODDE.O_OD>H_ODDE.O_DO
      || _txt:='Wartość w polu "Data od" oddelegowania nie może być większa od wartości w polu "Data do".'@;
         '%1OD'[_editable]
      |? _tab='H_UM' & H_ODDE.O_OD<H_UM.OD
      || _txt:='Wartość w polu "Data od" oddelegowania nie może być mniejsza niż "Data rozpoczęcia" z umowy.'@;
         '%1OD'[_editable]
      |? _tab='H_UM' & (H_UM.DO<>_d0 & H_ODDE.O_DO>H_UM.DO)
      || _txt:='Wartość w polu "Data do" oddelegowania nie może być większa niż "Data zakończenia" z umowy.'@;
         '%1DO'[_editable]
      |? +_editable & _tab='H' & H_ODDE.O_OD<H.OD
      || _txt:='Wartość w polu "Data od" pierwszego oddelegowania nie może być mniejsza niż "Data rozpoczęcia" '
               'z aneksu do umowy.'@;
         '%1OD'[_editable]
      |? +_editable & _tab='H' & (H.DO<>_d0 & H_ODDE.O_DO>H.DO)
      || _txt:='Wartość w polu "Data do" pierwszego oddelegowania nie może być większa niż "Data zakończenia" '
               'z aneksu do umowy.'@;
         '%1DO'[_editable]
      |? H.KODDEL='N'
         &
         (H_ODDE.H
         &
         H_ODDE.find_tab(1,'H',,'=',H.ref(),'KRAJ','NAZ','<>',H_ODDE.KRAJ().NAZ,'IDADD',,'<>',H_ODDE.IDADD))
      || _txt:='Wprowadzanie oddelegowań do pracy za granicą możliwe tylko do jednego państwa.'@;
         'KRAJ'
      |? _new & H_ODDE.O_OD<>H.OD
      || _txt:='Data w polu "Data od" oddelegowania jest różna od daty w polu "Data rozpoczęcia" z umowy.'@;
         '%1OD'[_editable]
      |? H.ODDEL='T' & (H.S4=0 | H.S1<>0) &
         ~FUN.ask('W celu poprawnego naliczania list płac wynagrodznie za okres oddelegowania\npowinno znajdować się w '
                  ' sekcji "Płaca oddelegowanie".\nWartość pola "%1" %2jest zerowa.\nCzy kontynuować?'@
                  [MS.name(H,{? H.S4=0 || 'S4' || 'S1' ?}),{? H.S4=0 || '' || '%1 '['nie'@] ?}])
      || {? H.S4=0 || 'S4' || 'S1' ?}

      || ''
      ?};
:: Nie można zatrudniać na czas nieokreślony z oddelegowaniem. Jeśli oddelegowanie, to data do musi być taka jak
:: data końca oddelegowania:
   {? ~+_result & _tab='H_UM' & H.ODDEL='T' & exec('h_oddel_editable','oddelegowanie',1) & H_ODDE.O_DO<>H_UM.DO
   || _txt:='Data w polu "%1" %2\nnie może być różna od daty w polu "%3" oddelegowania.'@
         [{? _tab='H_UM' || MS.name(H_UM,'DO') || MS.name(H,'DO') ?},{? _tab='H_UM' || 'umowy'@ || 'przebiegu'@ ?},
         MS.name(H_ODDE,'O_DO')];
      _result:='%1DO'[_editable]
   ?};

   {? ~+_result & H_ODDE.H
   || H_ODDE.cntx_psh();
      _od:=H_ODDE.O_OD;
      _idadd:=H_ODDE.IDADD;
      {? H_ODDE.O_DO<>H.DO &
         H_ODDE.find_tab(1,
            'H',,'=',H.ref(),
            'O_OD',,'<=',H_ODDE.O_DO,
            'O_DO',,'>=',H_ODDE.O_OD,
            'IDADD',,'<>',H_ODDE.IDADD
         )
      || _txt:='Okres oddelegowania do pracy za granicą nie może się pokrywać z już wprowadzonym.'@;
         _result:='%1OD'[_editable]
      |? H_ODDE.O_DO=H.DO &
         H_ODDE.find_tab(1,
            'H',,'=',H.ref(),
            'O_OD',,'>=',H_ODDE.O_OD,
            'IDADD',,'<>',H_ODDE.IDADD
         )
      || _txt:='Okres oddelegowania do pracy za granicą nie może pokrywać w całości już wprowadzonego.'@;
         _result:='%1OD'[_editable]
      ?};
      H_ODDE.cntx_pop()
   ?};
   {? _curTab=H_ODDE & ~+_result & H_ODDE.H & H_ODDE.O_OD<>H.OD
   || H_ODDE.cntx_psh();
      {? ~H_ODDE.find_tab(1,
            'H',,'=',H.ref(),
            'O_OD',,'=',H.OD,
            'IDADD',,'<>',H_ODDE.IDADD)
      || _txt:='%1\n%2 "%3" %4'['Oddelegowania muszą wypełniać okres przebiegu zatrudnienia.'@,
                                'Nie można edytować pola'@,MS.name(H_ODDE,'O_OD'),'pierwszego oddelegowania.'@];
         _result:='%1OD'[_editable]
      ?};
      H_ODDE.cntx_pop()
   ?};
   {? _curTab=H_ODDE & ~_new & ~+_result & H_ODDE.H & H_ODDE.O_DO<>H.DO
   || H_ODDE.cntx_psh();
      {? ~H_ODDE.find_tab(1,
            'H',,'=',H.ref(),
            'O_DO',,'=',H.DO,
            'IDADD',,'<>',H_ODDE.IDADD)
      || _txt:='%1\n%2 "%3" %4'['Oddelegowania muszą wypełniać okres przebiegu zatrudnienia.'@,
                                'Nie można edytować pola'@,MS.name(H_ODDE,'O_DO'),'ostatniego oddelegowania.'@];
         _result:='%1DO'[_editable]
      ?};
      H_ODDE.cntx_pop()
   ?};
   {? +_txt || FUN.emsg(_txt) ?};
   H_ODDE.cntx_pop()
?};
:: Ustalenie wartości w polach, które po akceptacji okna, powinny mieć właściwe wartości
:: i sprawdzenie uzupełnienia informacji dotyczącej zaświadczenia o ubezpieczeniu ZUS
{? _result=''
|| exec('spr_h_oddez','oddelegowanie');
   {? H_ODDE.ZAKW<>'S' || H_ODDE.ST_NOC:=0 ?};
   {? H_ODDE.ZAKW='N' || H_ODDE.WAL_NOC:=null() ?};
   {? H_ODDE.ZAST='N' || H_ODDE.P_ZAST:=null() ?}
?};
H.cntx_pop();
H_ODDE.cntx_pop();
_result


\spr_h2hodde
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła sprawdzająca konieczność wprowadzenia zmian w tabeli H_ODDE, po zmianach w tabeli H.
::   WE: _a [ARRAY] - tablica nazwana z danymi z tabeli H.
::       _b - wartości z bufora tabeli H_ODDE przed edycją.
::   WY: (1/0) - Należy wykonać aktualizację w tabel H_ODDE i H_ODDP (1).
::----------------------------------------------------------------------------------------------------------------------
_result:=(_a.OD<>H.OD | _a.DO<>H.DO);

{? _result
|| {? _a.OD<>H.OD || H_ODDE.O_OD:=H.OD ?};
   {? _a.DO<>H.DO || H_ODDE.O_DO:=H.DO ?}
|| _new:=exec('H_ODDE','buffer');
   _new.get(1);
   _result:=~exec('compare','#table',_b,_new,1)
?};

_result


\zmiany_h2hodde
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła do wprowadzenia zmian w tabeli H_ODDE, po zmianach w tabeli H.
::   WE: _a [STRING] - (prev/next) informacja czy zmiany dotyczą poprzedniego czy następnego zapisu w H.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=1;

H_ODDE.index('HOD');
H_ODDE.prefix(H.ref());
{? H_ODDE.size()
|| {? _a='prev'
   || {? H_ODDE.last() & H_ODDE.O_DO<>H.DO
      || {!
         |? {? H_ODDE.O_OD>H.DO
            || {? H_ODDE.name()='h_odde_' & +H_ODDE.IDLINK
               || _idlink:=H_ODDE.IDLINK;
                  H_ODDE.cntx_psh();
                  H_ODDE.use('h_oddet');
                  H_ODDE.prefix();
                  {? H_ODDE.seek(_idlink,)
                  || H_ODDE.del()
                  ?};
                  H_ODDE.cntx_pop()
               ?};
               H_ODDE.del()
            || 0
            ?}
         !};
         H_ODDE.O_DO:=H.DO;
         {? H_ODDE.put(1)
         || exec('aktualizacja_h2hodde','oddelegowanie')
         || _result:=0
         ?}
      ?}
   || {? H_ODDE.first() & H_ODDE.O_OD<>H.OD
      || H_ODDE.O_OD:=H.OD;
         {? H_ODDE.put(1)
         || exec('aktualizacja_h2hodde','oddelegowanie')
         || _result:=0
         ?}
      ?}
   ?}
?};
_result


\aktualizacja_h2hodde
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Aktualizacja oddelegowań po poprawieniu aneksu do umowy - uzupełnienie brakujących oddelegowań.
::   WE:
::   WY: Komunikat dotyczący oddelgowań, jeśli brak to wszystko udało się utworzyć.
::----------------------------------------------------------------------------------------------------------------------
_txt:='';
H_ODDE.cntx_psh();
H_ODDE.index('HOD');
H_ODDE.prefix(H.ref());

{? H_ODDE.first()
|| {!
   |? {? H_ODDE.name()='h_oddet'
      || {? (H_ODDE.O_OD>H.DO & H.DO<>date(0,0,0)) | H_ODDE.O_DO<H.OD
         || H_ODDE.del()
         || {? H_ODDE.O_OD<H.OD
            || H_ODDE.O_OD:=H.OD
            ?};
            {? H_ODDE.O_DO>H.DO
            || H_ODDE.O_DO:=H.DO
            ?};
            {? H_ODDE.put() & exec('del_h_oddp','oddelegowanie',H_ODDE.ref())
            || exec('h_odde_wer_ad','oddelegowanie')
            ?};
            H_ODDE.next()
         ?}
      || {? _txt='' || _txt:=exec('h_odde_wer_ap','oddelegowanie',0) ?};
         {? H_ODDE.name()='h_odde_' & _txt=''
         || _idlink:=H_ODDE.IDLINK;
            {? (H_ODDE.O_OD>H.DO & H.DO<>date(0,0,0)) | H_ODDE.O_DO<H.OD
            || _idlink:=H_ODDE.IDLINK;
               {? +_idlink
               || H_ODDE.cntx_psh();
                  H_ODDE.use('h_oddet');
                  H_ODDE.prefix();
                  {? H_ODDE.seek(_idlink,)
                  || H_ODDE.del()
                  ?};
                  H_ODDE.cntx_pop();
                  H_ODDE.del()
               || H_ODDE.del()
               ?}
            || {? H_ODDE.O_OD<H.OD
               || H_ODDE.O_OD:=H.OD
               ?};
               {? H_ODDE.O_DO>H.DO
               || H_ODDE.O_DO:=H.DO
               ?};
               H_ODDE.put();
               H_ODDE.next()
            ?}
         || H_ODDE.next()
         ?}
      ?}
   !}
?};
H_ODDE.cntx_pop();
_txt


\ewidencja
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Wyświetlenie okien do przeglądania i edycji oddelegowania do pracy za granicą.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(H,P,OSOBA,H_ODDE,H_ODDP,H_ODDA,H_ODDR);
H_ODDE.use('h_odde'+(H.name()+1));
H_ODDE.index('HOD');
H_ODDE.prefix(H.ref());
H_ODDE.win_edit('RED');
H_ODDE.win_sel('WER');
H_ODDE.actions('WER',':');
H_ODDE.select();
H_ODDE.fld_fml('O_OD','BEFORE_EDIT',"*");
H_ODDE.actions('WER','dpu:d');
Cntx.pop(H,P,OSOBA,H_ODDE,H_ODDP,H_ODDA,H_ODDR);
~~


\h_odde_h_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Wartość początkowa - wskazanie na aneks do umowy o pracę.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? 2-!cur_tab()='H_ODDE' & H_ODDE.name()+1=H.name()+1
|| H.ref()
|| null()
?}


\h_odde_o_od_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Wartość początkowa dla pola OD w tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? ',P,H_UM,'*',%1,'[2-!cur_tab()]
|| H_UM.OD
|| H.OD
?}


\h_odde_o_od_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed edycją pola OD w tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
::H_ODDE.O_OD:=
::   {? 2-!cur_tab()='P'
::   || H_UM.OD
::   || H.OD
::   ?}
~~


\h_odde_o_do_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Wartość początkowa dla pola DO w tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? ',P,H_UM,'*',%1,'[2-!cur_tab()]
|| H_UM.DO
|| H.DO
?}


\h_odde_kraj_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła na wartość początkową pola KRAJ w tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_kraj:=null();
Cntx.psh(H,H_ODDE);
H_ODDE.use('h_odde'+(H.name()+1));
H_ODDE.index('HOD');
H_ODDE.prefix(H.ref());
{? H_ODDE.first() & H_ODDE.H().KODDEL='N'
|| _kraj:=H_ODDE.KRAJ
?};
Cntx.pop(H,H_ODDE);
_kraj


\h_odde_kraj_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po edycji pola KRAJ w tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
DIETZAGR.cntx_psh();
DIETZAGR.index('KRAJ');
DIETZAGR.prefix();
H_ODDE.WAL_NOC:=
   {? +H_ODDE.KRAJ().SYM & DIETZAGR.find_key(H_ODDE.KRAJ().SYM)
   || DIETZAGR.WAL
   ?};
DIETZAGR.cntx_pop();
{? H_ODDE.KRAJ<>H_ODDE.M_PRAC().KRAJ
|| H_ODDE.M_PRAC:=null()
?};
H.MIEJSCE:=H_ODDE.KRAJ().NAZ+{? H_ODDE.M_PRAC || ', '+H_ODDE.M_PRAC().MIASTO || '' ?};
1


\h_odde_m_prac_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed redagowaniem pola M_PRAC w tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H_ODDA.fld_fml('RODZAJ','BLANK',"H_ODDA.RODZAJ:=\'P\'");
H_ODDA.fld_fml('KRAJ','BLANK',"H_ODDA.KRAJ:=H_ODDE.KRAJ");
1


\h_odde_m_prac_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po edycj pola M_PRAC w tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H.MIEJSCE:=H_ODDE.KRAJ().NAZ+{? H_ODDE.M_PRAC || ', '+H_ODDE.M_PRAC().MIASTO || '' ?};
1


\h_odde_m_zam_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed redagowaniem pola M_ZAM w tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H_ODDA.fld_fml('RODZAJ','BLANK',"H_ODDA.RODZAJ:=\'Z\'");
H_ODDA.fld_fml('KRAJ','BLANK',"H_ODDA.KRAJ:=null()");
1


\h_odde_zast_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po edycji pola ZAST w tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('acces2fld_h_odde','oddelegowanie',cur_tab(),cur_win(),1,'ZAST');
1


\h_odde_tkrs_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła na wartość początkową w polu TKRS tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H.ZWAL


\h_odde_p_zast_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed redagowaniem pola P_ZAST w tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? P.f_active()  || P.f_clear() ?};
P.index('FIRMA_ZA');
P.prefix(exec('firma','ustawienia'),'T');
P.win_sel('CTR')


\h_odde_p_zast_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po redakcji pola P_ZAST w tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
P.cntx_psh();
OSOBA.cntx_psh();
VAR_EDIT.T:=P.T;
VAR_EDIT.NAZWISKO:=P.OSOBA().NAZWISKO;
VAR_EDIT.PIERWSZE:=OSOBA.PIERWSZE;
OSOBA.cntx_pop();
P.cntx_pop();
P.seek(REF.P,);
1


\h_odde_zakw_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po redagowaniu pola ZAKW w tabeli H_ODDE
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? H_ODDE.ZAKW<>'N' & ~H_ODDE.WAL_NOC
|| exec('h_odde_kraj_ae','oddelegowanie')
?};
exec('acces2fld_h_odde','oddelegowanie',cur_tab(),cur_win(),1,'ZAKW');
1


\h_odde_wer_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed akcją "Dołącz" w oknie WER tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H_ODDE.blank();
VAR_EDIT.T:=VAR_EDIT.NAZWISKO:=VAR_EDIT.PIERWSZE:='';
exec('acces2fld_h_odde','oddelegowanie',H_ODDE,'RED',1);
:: Dodać można tylko dodawanie "na koniec" (jak w przebiegach):
exec('acces2fld_h_odde','oddelegowanie',H_ODDE,'RED',1,'O_DO',0);
1


\h_odde_wer_ad
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po akcji "Dołącz" w oknie WER tabeli H_ODDE
::       oraz po akceptacji aneksu do umowy jeśli z oddelegowaniem.
::       Utworzenie pozycji do oddelegowania jeżeli parametr 180 ma wartość 'N'
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
P.seek(REF.P,);

_poprPrev:=
  "_pozycje:={? var_pres('_a')=type_of(0) || _a || 0 ?};
   {? H_ODDE.O_DO=H.DO
   || _od:=H_ODDE.O_OD;
      H_ODDE.cntx_psh();
      {? H_ODDE.prev() & H_ODDE.O_DO=H.DO
      || H_ODDE.O_DO:=_od-1;
         {? H_ODDE.put(1) & _pozycje
         || exec('del_h_oddp','oddelegowanie',H_ODDE.ref(),1);
            exec('pozycje_odd','oddelegowanie')
         ?}
      ?};
      H_ODDE.cntx_pop()
   ?}
  ";
{? PAR_SKID.get(180)='N' & H_ODDE.name()+1='t'
|| exec('pozycje_odd','oddelegowanie');
   H.cntx_psh();
   H.MIEJSCE:=exec('h_miejsce','oddelegowanie');
   H.put(1);
:: Poprawa poprzedniego oddelegowania w przebiegu, w celu zachowania ciągłości:
   _poprPrev(1);
   H.cntx_pop()
||
:: Uzupełniemi miejsca pracy w przebiegu zatrudnienia.
   {? H_ODDE.name()='h_odde_'
   || H.MIEJSCE:=exec('h_miejsce','oddelegowanie');
      H.put(1);
::    Poprawa poprzedniego oddelegowania w przebiegu, w celu zachowania ciągłości:
      _poprPrev()
   ?}
?};
0


\h_odde_wer_bp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed akcją "Popraw" w oknie WER tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H.seek(H_ODDE.H,,1);
H_ODDE.fld_fml('O_OD','BEFORE_EDIT',"1");
P.cntx_psh();
OSOBA.cntx_psh();
VAR_EDIT.T:=H_ODDE.P_ZAST().T;
VAR_EDIT.NAZWISKO:=P.OSOBA().NAZWISKO;
VAR_EDIT.PIERWSZE:=OSOBA.PIERWSZE;
OSOBA.cntx_pop();
P.cntx_pop();
exec('acces2fld_h_odde','oddelegowanie',H_ODDE,'RED',1);
1


\h_odde_wer_ap
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po akcji "Popraw" w oknie WER tabeli H_ODDE.
::   WE: _a [INTEGER} - (0/1) Wyświetlanie komunikatów (1 lub brak).
::   WY: Komunikat dotyczący oddelgowań, brak jeżeli wszystko udało się utworzyć lub jeżeli wyświetlony _komm.
::----------------------------------------------------------------------------------------------------------------------
_txt:='';
_komm:={? var_pres('_a')=type_of(0) || _a || 1 ?};
{? _komm
|| exec('ini_kom','#message','Pozycje, których nie można poprawiać automatycznie'@,,255)
?};
_miejsce:=exec('h_miejsce','oddelegowanie');
P.seek(REF.P,);

H_ODDP.cntx_psh();
{? H_ODDE.name()='h_odde_'
||
:: Aktualizacja miejsca pracy w aneksie do umowy na podstawie miejsca pracy w oddelegowaniu
   {? H.MIEJSCE<>_miejsce
   || H.MIEJSCE:=_miejsce
   ?};

   {? +H_ODDE.IDLINK
   || _tmp:=exec('H_ODDE','buffer');
      _org:=exec('H_ODDE','buffer');
      _tmp.get();
      H_ODDE.cntx_psh();
      H_ODDE.use('h_oddet');
      {? H_ODDE.seek(_tmp.IDLINK,,1)
      || _org.get();
         {? ~exec('compare','#table',_tmp,_org,1,'Ref','IDADD','IDLINK','H')
         || {? sql('select * from H_ODDP where H_ODDP.H_ODDE=:_a and H_ODDP.ZAPIS=\'R\'',H_ODDE.ref()).size()
            || _txt:='%1\n%2'
               [  'Niektóre pozycje oddelegowania były już redagowane.'@,
                  'Proszę zweryfikować je po akceptacji aneksu.'@
               ]
            ?};
            {? sql('select * from H_ODDP where H_ODDP.H_ODDE=:_a and substr(H_ODDP.LT,1,1)=\'L\'',H_ODDE.ref()).size()
            || _txt:='%1\n%2'
               [  'Niektóre pozycje oddelegowania zostały rozliczone na liście płac.'@,
                  'Proszę zweryfikować je po akceptacji aneksu.'@
               ]
            ?};
            {? H.IDMOD='__'
            || H.IDMOD:='P_'
            ?}
         ?}
      ?};
      H_ODDE.cntx_pop()
   ?};
   H.put(1);
:: Poprawa sąsiadujących oddelegowań w przebiegu, w celu zachowania ciągłości:
   _cTxt:=exec('h_odde_ciagl','oddelegowanie',H_ODDE.ref(),_komm);
   {? ~+_txt & +_cTxt
   || _txt:=_cTxt
   ?};

   {? _komm & +_txt || FUN.emsg(_txt) ?}
|| H_ODDP.prefix(H_ODDE.ref());
   {? H_ODDP.first()
   || {!
      |?
:: Usunięcie pozycji, które można usunąć (bez znaku listy płac lub informacji o modyfikacji ręcznej).
         {? H_ODDP.LT='' & H_ODDP.ZAPIS<>'R'
         || _del:=H_ODDP.del(,1);
            {? _del
            || {? _del=1 || 0 || 1 ?}
            || {? _komm
               || exec('add_kom','#message',
                     'Pozycja %1 z okresu od %2 do %3 nie może być poprawiona.'@
                        [  H_ODDP.RODZ().RODZ,
                           H_ODDP.OD$1,
                           H_ODDP.DO$1
                        ],
                     6,'Modyfikacja niemożliwa'@
                  )
               || _txt:='%1\n%2'['Pozycja oddelegowania nie mogła być usunięta.'@,'Proszę zweryfikować dane.'@]
               ?};
               H_ODDP.next()
            ?}
         || H_ODDP.next()
         ?}
      !};
:: Przygotowanie informacji o wierszach, których nie można usunąć.
      {? H_ODDP.first()
      || {!
         |? {? H_ODDP.ZAPIS='R'
            || {? _komm
               || exec('add_kom','#message',
                     'Pozycja %1 z okresu od %2 do %3 nie może być poprawiona, ponieważ była redagowana.'@
                        [  H_ODDP.RODZ().RODZ,
                           H_ODDP.OD$1,
                           H_ODDP.DO$1
                        ],
                     6,'Modyfikacja niemożliwa'@
                  )
               || _txt:='%1\n%2'['Niektóre pozycje oddelegowania były już redagowane.'@,'Proszę zweryfikować dane.'@]
               ?};
               H_ODDP.next()
            |? +H_ODDP.LT
            || {? _komm
               || exec('add_kom','#message',
                     'Pozycja %1 z okresu od %2 do %3 nie może być poprawiona ponieważ jest powiązana z listą płac %4.'@
                        [  H_ODDP.RODZ().RODZ,
                           H_ODDP.OD$1,H_ODDP.DO$1,
                           H_ODDP.LT
                        ],
                     6,'Modyfikacja niemożliwa'@
                  )
               || _txt:='%1\n%2'
                     [  'Niektóre pozycje oddelegowania są rozliczone na liście płac.'@,
                        'Proszę zweryfikować dane.'@
                     ]
               ?};
               H_ODDP.next()
            ?}
         !}
      ?}
   ?};
:: Aktualizacja miejsca pracy w aneksie do umowy na podstawie miejsca pracy w oddelegowaniu
   {? H.MIEJSCE<>_miejsce
   || H.MIEJSCE:=_miejsce;
      H.put()
   ?};
:: Odtworzenie brakujących pozycji do oddelegowania.
   exec('h_odde_wer_ad','oddelegowanie');
:: Poprawa sąsiadujących oddelegowań w przebiegu, w celu zachowania ciągłości:
   _cTxt:=exec('h_odde_ciagl','oddelegowanie',H_ODDE.ref(),_komm);
   {? ~+_txt & +_cTxt
   || _txt:=_cTxt
   ?};

   {? _komm
   || exec('end_kom','#message')
   ?}
?};
H_ODDP.cntx_pop();
_txt


\h_odde_wer_bfu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed akcją "Usuń" w oknie WER tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_txt:='';
_del:=_size:=0;
_ref:=H_ODDE.ref();
_name:=H_ODDE.name();

H_ODDE.cntx_psh();
{? _name='h_odde_'
|| _idlink:=H_ODDE.IDLINK;
   H_ODDE.use('h_oddet');
   H_ODDE.prefix();
   _ref:={? H_ODDE.seek(_idlink,,1) || H_ODDE.ref() || null() ?}
?};
_size:=sql(
   'select distinct *
   from H_ODDP join H_ODDE
   where H_ODDE.REFERENCE=\':_a\' and (H_ODDP.ZAPIS=\'R\' or substr(H_ODDP.LT,1,1)=\'L\')',
   $_ref
).size();

:: Przedłużenie oddelegowania sąsiedniego w celu zachowania ciągłości:
_uzupel:=
   "_href:=_a;
    _od:=_b;
    _do:=_c;
    _pozycje:={? var_pres('_d')=type_of(0) || _d || 0 ?};
    H_ODDE.cntx_psh();
    H_ODDE.index('HOD');
    H_ODDE.prefix(_href);
    {? H_ODDE.find_le(_od)
    || H_ODDE.O_DO:=_do;
       {? H_ODDE.put(1) & _pozycje
       || exec('del_h_oddp','oddelegowanie',H_ODDE.ref(),1);
          exec('pozycje_odd','oddelegowanie')
       ?}
    |? H_ODDE.find_ge(_od)
    || H_ODDE.O_OD:=_od;
       {? H_ODDE.put(1) & _pozycje
       || exec('del_h_oddp','oddelegowanie',H_ODDE.ref(),1);
          exec('pozycje_odd','oddelegowanie')
       ?}
    ?};
    H_ODDE.cntx_pop()
    ";

{? _size
|| _txt:='Nie można usunąć oddelegowania, do którego istnieją pozycje modyfikowane lub powiązane z listą płac.'@
|| H_ODDP.cntx_psh();
   H_ODDP.index('H_ODDE');
   H_ODDP.prefix(_ref);
   {? H_ODDP.first()
   || {? FUN.ask('Czy usunąć oddelegowanie z pozycjami?'@)
      || {! |? H_ODDP.del() !};
         {? H_ODDP.size()
         || _txt:='%1\n%2'['Nie udało się usunąć pozycji oddelegowania.'@,'Usunięcie oddelegowania nie jest możliwe.'@]
         || _del:=1
         ?}
      ?}
   || _del:=FUN.ask('Czy usunąć oddelegowanie?'@)
   ?};
   H_ODDP.cntx_pop();
   {? _ref & _del
   ||  _href:=H_ODDE.H;
       _od:=H_ODDE.O_OD;
       _do:=H_ODDE.O_DO;
       _del:=H_ODDE.del(1,1);
      {? _del
      || {? _name='h_oddet'
         || H.cntx_psh();
            H.prefix();
           {? H.seek(_href,)
           || H.MIEJSCE:=exec('h_miejsce','oddelegowanie');
              H.put(1)
           ?};
           H.cntx_pop()
         ?};
::       Przedłużenie oddelegowania sąsiedniego w celu zachowania ciągłości:
         _uzupel(_href,_od,_do,1)

      || _txt:='Nie udało się usunąć oddelegowania.'@
      ?}
   ?}
?};
H_ODDE.cntx_pop();

{? _name='h_odde_' & _del
|| _href:=H_ODDE.H;
   _od:=H_ODDE.O_OD;
   _do:=H_ODDE.O_DO;
   {? H_ODDE.del(1,1)
   || H.cntx_psh();
      H.prefix();
      {? H.seek(_href,)
      || H.MIEJSCE:=exec('h_miejsce','oddelegowanie');
         H.put(1)
      ?};
      H.cntx_pop();
::    Przedłużenie oddelegowania sąsiedniego w celu zachowania ciągłości:
      _uzupel(_href,_od,_do)
   ?}
?};

{? +_txt || FUN.emsg(_txt) ?}


\h_odde_delb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Wyzwalacz "Usuń - przed" dla tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? ~exec('h_odde_can_del','oddelegowanie',H_ODDE.ref())
|| undo('Nie można usunąć oddelegowania, do którego istnieją pozycje modyfikowane lub powiązane z listą płac.'@);
   return(0)
?};

H_ODDP.cntx_psh();
H_ODDP.prefix();
H_ODDP.f_set(,,'H_ODDP.H_ODDE=:_a',H_ODDE.ref());
_ok:=1;
{? H_ODDP.f_first()
|| {!
   |? _ok:=H_ODDP.del(,1);

      _ok & H_ODDP.f_next()
   !}
?};
H_ODDP.f_clear();
H_ODDP.cntx_pop();
{? ~_ok
|| undo('Błąd usuwania pozycji oddelegowania.'@);
   return(0)
?};

_ok


\h_odde_can_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Sprawdzenie czy można skasować oddelegowanie, test dla tabeli H_ODDE.
::   WE: _a [REFERENCE] - Wskazanie rekodru oddelegowania.
::   WY: (1/0) - Można usunąć oddelegowanie (1).
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_ref:=_a;
_name:=ref_name(_ref);

H_ODDE.cntx_psh();
H_ODDE.use(_name);
H_ODDE.prefix();
{? H_ODDE.seek(_a,)
|| _ref:=
      {? _name='h_oddet'
      || H_ODDE.ref()
      || {? +H_ODDE.IDLINK
         || H_ODDE.use('h_oddet');
            H_ODDE.prefix();
            {? H_ODDE.seek(H_ODDE.IDLINK,)
            || H_ODDE.ref()
            || null()
            ?}
         || null()
         ?}
      ?};

    _result:=
      {? _ref
      || ~sql(
            'select H_ODDP.OD
            from H_ODDP join H_ODDE
            where H_ODDE.REFERENCE=\':_a\' and (H_ODDP.ZAPIS=\'R\' or substr(H_ODDP.LT,1,1)=\'L\')',
            $_ref
         ).size()
      || 1
      ?}
?};
H_ODDE.cntx_pop();
_result


\h_can_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Sprawdzenie czy można skasować oddelegowanie test dla tabeli H.
::   WE: _a [REFERENCE] - Wskazanie aneksu do umowy.
::   WY: (1/0) - Można usunąć aneks do umowy z powiązanymi oddelegowaniami (1).
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_ref:=_a;
_name:=ref_name(_ref);

Cntx.psh(H,H_ODDE);
H.use(_name);
H.prefix();
{? H.seek(_a,)
|| H_ODDE.use('h_odde'+(H.name()+1));
   H_ODDE.index('HOD');
   H_ODDE.prefix(H.ref());
   {? H_ODDE.first()
   || {!
      |? _result:=exec('h_odde_can_del','oddelegowanie',H_ODDE.ref());
         _result & H_ODDE.next()
      !}
   || _result:=1
   ?}
?};
Cntx.pop(H,H_ODDE);
_result


\h_um_can_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Sprawdzenie czy można skasować oddelegowanie test dla tabeli H_UM.
::   WE: _a [REFERENCE] - Wskazanie na umowę o pracę.
::   WY: (1/0) - Można usunąć umowę o pracę z aneksami do niej powiązanymi z oddelegowaniami (1).
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_ref:=_a;
_name:=ref_name(_ref);

Cntx.psh(H_UM,H);
exec('otworz_h_um','pracownik',_name);
H_UM.prefix();
{? H_UM.seek(_a,)
|| H.use('_his'+(H_UM.name()+1));
   H.index('HISTUM');
   H.prefix(H_UM.ref());
   {? H.first()
   || {!
      |? {? H.ODDEL='T'
         || _result:=exec('h_can_del','oddelegowanie',H.ref())
         || _result:=1
         ?};
         _result & H.next()
      !}
   || _result:=1
   ?}
?};
Cntx.pop(H_UM,H);
exec('otworz_h_um','pracownik');
_result


\h_odde_wer_bdisp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed wyświetleniem okna WER w tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
P.cntx_psh();
OSOBA.cntx_psh();
VAR_EDIT.T:=H_ODDE.P_ZAST().T;
VAR_EDIT.NAZWISKO:=P.OSOBA().NAZWISKO;
VAR_EDIT.PIERWSZE:=OSOBA.PIERWSZE;
OSOBA.cntx_pop();
P.cntx_pop();
exec('acces2fld_h_odde','oddelegowanie',H_ODDE,'RED',1);
H_ODDE.display();
P.seek(REF.P,)


\h_odda_wer_bu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed akcją "Usuń" w oknie WER tabeli H_ODDA.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? H_ODDA.count()
|| FUN.emsg('%1\n%2'['Rekord wykorzystywany w innych tabelach.','Rekord nie może być usunięty.']);
   0
|| 1
?}


\h_odda_wer_ar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po redagowaniu rekordu w oknie WER w tabeli H_ODDA.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
__CHK.record2(H_ODDA,'NAZWA','Nazwa','KRAJ','Kraj','MIASTO','Miejscowość')


\h_oddp_h_odde_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Wartość dla pola H_ODDE w tabeli H_ODDR.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H_ODDE.ref()


\h_oddp_kraj_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Wartość dla pola KRAJ w tabeli H_ODDR.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H_ODDE.KRAJ


\h_oddp_od_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po edycji pola OD w tabeli H_ODDP.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('h_oddp_oblicz_dni','oddelegowanie');
1


\h_oddp_do_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po edycji pola DO w tabeli H_ODDP.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('h_oddp_oblicz_dni','oddelegowanie');
1


\h_oddp_h_oddr_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Po redagowaniu pola RODZ w tabeli H_ODDP.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? H_ODDP.RODZ().DIETA='T'
|| DIETZAGR.cntx_psh();
   DIETZAGR.index('KRAJ');
   DIETZAGR.prefix(H_ODDP.H_ODDE().KRAJ().SYM);
   {? DIETZAGR.find_le(H_ODDP.DO)
   || H_ODDP.WAL:=DIETZAGR.WAL;
      H_ODDP.ST:=DIETZAGR.STAWKA;
      H_ODDP.KW:=H_ODDP.ST*H_ODDP.DNI$2
   ?};
   DIETZAGR.cntx_pop()
|| H_ODDP.WAL:=H_ODDP.H_ODDE().WAL_NOC;
   {? H_ODDE.ZAKW='S'
   || H_ODDP.ST:=H_ODDE.ST_NOC;
      H_ODDP.KW:=H_ODDP.ST*H_ODDP.DNI$2
   || H_ODDP.ST:=H_ODDP.KW:=0
   ?}
?};
1


\h_oddp_dni_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po redakcji pola DNI w tabeli H_ODDP.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('oblicz_H_ODDP_KW','oddelegowanie');
{? H_ODDP.DNI<0
|| FUN.emsg('Wartość w polu "Rozliczana liczba dni" nie może być mniejsza od 0.'@); 0
|| 1
?}


\h_oddp_st_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po redakcji pola ST w tabeli H_ODDP.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('oblicz_H_ODDP_KW','oddelegowanie');
{? H_ODDP.ST<0
|| FUN.emsg('Wartość w polu "Stawka" nie może być mniejsza od 0.'@); 0
|| 1
?}


\h_oddp_kw_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po redakcji pola KW w tabeli H_ODDP.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? H_ODDP.KW<0
|| FUN.emsg('Wartość w polu "Kwota" nie może być mniejsza od 0.'@); 0
|| 1
?}


\oblicz_H_ODDP_KW
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Obliczenie kwoty pozycji oddelegowania i zablokowanie edycji pola Kwota jeśli liczba dni lub stawka wynosi 0.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H_ODDP.KW:=H_ODDP.DNI*H_ODDP.ST$2;
H_ODDP.efld_opt(
   'RED',
   'enable=1,editable=%1,mark=%2'[{? H_ODDP.ST & H_ODDP.DNI || 'grayed' || '1' ?},$(~H_ODDP.DNI | ~H_ODDP.ST)],,
   'KW'
)


\h_oddp_wer_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed akcją "Dołącz" w oknie WER tabeli H_ODDP.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H_ODDP.efld_opt('RED','enable=1,editable=1',,'DNI');
H_ODDP.efld_opt('RED','enable=1,editable=1,mark=1',,'WAL','SYM');
H_ODDP.efld_opt('RED','enable=1,editable=1',,'ST');
H_ODDP.efld_opt('RED','enable=1,editable=1,mark=1',,'KW')


\h_oddp_wer_bp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed akcją "Popraw" w oknie WER tabeli H_ODDP.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_txt:='';

{? VAR.JESTLIST
|| {? +H_ODDP.LT & VAR.NAZWALIS<>H_ODDP.LT
   || _txt:='%1\n%2'
         [  'Lista płac %1 nie rozlicza oddelegowania.'@[VAR.NAZWALIS],
            'Należy wybrać listę płac uwzględnioną w rozliczeniu.'@
         ];
         _result:=0
   |? +H_ODDP.LT
   || _result:=exec('o_writable','lista_plac',H_ODDP.LT,1)
   ?}
|| {? +H_ODDP.LT
   || _txt:='%1\n%2'['Oddelegowanie zostało rozliczone.'@,'Należy wybrać odpowiednią listę płac.'@];
      _result:=0
   ?}
?};

{? _result
|| _mark:=$(+H_ODDP.LT=0);
   _editable:={? +H_ODDP.LT || 'grayed' || '1' ?};
   H_ODDP.efld_opt('RED','enable=1,editable=%1,mark=%2'[_editable,_mark],,'OD');
   H_ODDP.efld_opt('RED','enable=1,editable=%1,mark=%2'[_editable,_mark],,'DO');
   H_ODDP.efld_opt('RED','enable=1,editable=%1,mark=%2'[_editable,_mark],,'RODZ');
   H_ODDP.efld_opt('RED','enable=1,editable=%1'[_editable],,'DNI');
   H_ODDP.efld_opt('RED','enable=1,editable=%1,mark=%2'[_editable,_mark],,'WAL','SYM');
   H_ODDP.efld_opt('RED','enable=1,editable=%1'[_editable],,'ST');
   H_ODDP.efld_opt(
      'RED',
      'enable=1,editable=%1,mark=%2'
         [  {? +H_ODDP.LT | (H_ODDP.ST & H_ODDP.DNI) || 'grayed' || '1' ?},
            $(~(+H_ODDP.LT | (H_ODDP.ST & H_ODDP.DNI)))
         ],,
      'KW'
   );
   H_ODDP.ZAPIS:='R'
|| {? +_txt || FUN.emsg(_txt) ?}
?};
_result


\h_oddp_wer_bu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed akcją "Usuń" w oknie WER tabeli H_ODDP.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_del:=1;

{? H_ODDP.ZAPIS='R'
|| _del:=FUN.ask('%1\n%2'['Pozycja oddelegowania była modyfikowana.'@,'Czy napewno usunąć?'@])
|? +H_ODDP.LT
|| _del:=FUN.ask('%1\n%2'['Pozycja oddelegowania została rozliczona na liście płac.'@,'Czy napewno usunąć?'@])
?};
_del


\h_oddp_wer_bgu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed akcją grupową "Usuń" w oknie WER tabeli H_ODDP.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_txt:='';
_TAB:=H_ODDP.sel_aget();

H_ODDP.cntx_psh();
{? _TAB.first()
|| {!
   |? {? H_ODDP.seek(_TAB.REF,)
      || {? H_ODDP.ZAPIS='R'
         || _txt:='Wśród usuwanych pozycji znajdują się pozycje modyfikowane.'@
         |? +H_ODDP.LT
         || _txt:='Wśród usuwanych pozycji znajdują się pozycje rozliczone.'@
         ?}
      ?};
      _TAB.next()
   !}
?};
H_ODDP.cntx_pop();

{? +_txt
|| FUN.emsg('%1\n%2'[_txt,'Usuwanie grupowe niemożliwe.'@]); 0
|| 1
?}


\h_oddp_wer_bfa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed akcją "Aktualizuj" w oknie WER tabeli H_ODDP.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('del_h_oddp','oddelegowanie',H_ODDE.ref(),1);
exec('pozycje_odd','oddelegowanie');
~~


\h_oddp_wer_br
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła wykonywana przed rekordem w oknie WER tabeli H_ODDP.
::   WE: _a [NUMBER] - Rekord bieżący? [0 - nie / 1 - tak]
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _a
|| H_ODDP.actions_grayed('WER',{? +H_ODDP.LT || 'p' || '' ?})
?};
~~


\h_oddp_wer_ar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po redagowaniu rekordu w oknie WER w tabeli H_ODDP.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: Sprawdzenie uzupełnienia wymaganych pól.
_result:=__CHK.record2(H_ODDP,'OD','Data od','DO','Data do','RODZ','Rodzaj','WAL','Waluta','KW','Kwota');

:: Sprawdzenie poprawności wprowadzonych danych.
{? _result=''
|| H_ODDP.cntx_psh();
   _txt:='';
   _result:=
      {? H_ODDP.OD>H_ODDP.DO
      || _txt:='Wartość w polu "Data od" nie może być większa od wartości w polu "Data do".'@;
         'OD'
      |? H_ODDP.OD<H_ODDE.O_OD
      || _txt:='Wartość w polu "Data od" nie może być mniejsza niż "Data od" oddelegowania.'@;
         'OD'
      |? H_ODDP.OD~1<>H_ODDP.DO~1 | H_ODDP.OD~2<>H_ODDP.DO~2
      || _txt:='Wartości w polach "Data od" i "Data do" muszą być z tego samego roku i miesiąca.'@;
         'OD'
      |? H_ODDP.DO>H_ODDE.O_DO
      || _txt:='Wartość w polu "Data do" nie może być większa niż "Data do" oddelegowania.'@;
         'DO'
      |? H_ODDP.DNI>H_ODDP.NOM
      || _txt:='Wartość w polu "Rozliczana liczba dni" nie może być większa niż "Nominalna liczba dni".'@;
         'DNI'
      |? H_ODDP.find_tab(1,'RODZ',,'=',H_ODDP.RODZ,'OD',,'<=',H_ODDP.DO,'DO',,'>=',H_ODDP.OD,'IDADD',,'<>',H_ODDP.IDADD)
      || _txt:='Nie można wprowadzać tego samego rodzaju rozliczenia oddelegowania w tym samym czasie.'@;
         'OD'
      || ''
      ?};
   {? +_txt || FUN.emsg(_txt) ?};
   H_ODDP.cntx_pop()
?};

_result


\h_oddr_dieta_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po redakcji pola DIETA w tabeli H_ODDR.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? H_ODDR.DIETA='T' & H_ODDR.efld_opt('RED','editable',,'NOC')='1'
|| H_ODDR.NOC:='N';
   H_ODDR.efld_opt('RED','editable=grayed',,'NOC')
|? H_ODDR.DIETA='N' & H_ODDR.efld_opt('RED','editable',,'NOC')<>'1'
:: Sprawdzenie czy można odszarzyć (czy w systemie nie ma już noclegu):
|| H_ODDR.cntx_psh();
   H_ODDR.prefix();
   {? ~H_ODDR.find_tab(1,
            'FIRMA',,'=',exec('firma','ustawienia'),
            'DIETA',,'=','N',
            'NOC',,'=','T',
            'IDADD',,'<>',H_ODDR.IDADD)
   || H_ODDR.efld_opt('RED','editable=1',,'NOC')
   ?};
   H_ODDR.cntx_pop()
?};
1


\h_oddr_noc_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po redakcji pola NOC w tabeli H_ODDR.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? H_ODDR.NOC='T' & H_ODDR.efld_opt('RED','editable',,'DIETA')='1'
|| H_ODDR.DIETA:='N';
   H_ODDR.efld_opt('RED','editable=grayed',,'DIETA')
|? H_ODDR.NOC='N' & H_ODDR.efld_opt('RED','editable',,'DIETA')<>'1'
:: Sprawdzenie czy można odszarzyć (czy w systemie nie ma już diety):
|| H_ODDR.cntx_psh();
   H_ODDR.prefix();
   {? ~H_ODDR.find_tab(1,
            'FIRMA',,'=',exec('firma','ustawienia'),
            'DIETA',,'=','T',
            'NOC',,'=','N',
            'IDADD',,'<>',H_ODDR.IDADD)
   || H_ODDR.efld_opt('RED','editable=1',,'DIETA')
   ?};
   H_ODDR.cntx_pop()
?};
1


\h_oddr_wer_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed akcją "Dołącz" w oknie WER tabeli H_ODDR.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H_ODDR.cntx_psh();
H_ODDR.clear();
_dieta:=H_ODDR.find_tab(1,'FIRMA',,'=',exec('firma','ustawienia'),'DIETA',,'=','T','NOC',,'=','N');
_nocleg:=H_ODDR.find_tab(1,'FIRMA',,'=',exec('firma','ustawienia'),'DIETA',,'=','N','NOC',,'=','T');
H_ODDR.cntx_pop();

H_ODDR.efld_opt('RED','editable=%1'[{? ~_dieta || '1' || 'grayed' ?}],,'DIETA');
H_ODDR.efld_opt('RED','editable=%1'[{? ~_nocleg || '1' || 'grayed' ?}],,'NOC');
H_ODDR.efld_opt('RED','editable=1',,'R','RN')


\h_oddr_wer_bp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed akcją "Popraw" w oknie WER tabeli H_ODDR.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_dieta:=H_ODDR.DIETA='T';
_nocleg:=H_ODDR.NOC='T';

{? ~_dieta | ~_nocleg
|| _firma:=exec('firma','ustawienia');
   H_ODDR.cntx_psh();
   H_ODDR.clear();
   {? ~_nocleg
   || _jestDieta:=
         H_ODDR.find_tab(1,
            'FIRMA',,'=',_firma,
            'DIETA',,'=','T',
            'NOC',,'=','N',
            'IDADD',,'<>',H_ODDR.IDADD
         )
   ?};
   {? ~_dieta
   || _jestNocleg:=
         H_ODDR.find_tab(1,
            'FIRMA',,'=',_firma,
            'DIETA',,'=','N',
            'NOC',,'=','T',
            'IDADD',,'<>',H_ODDR.IDADD
         )
   ?};
   H_ODDR.cntx_pop()
?};

H_ODDR.efld_opt('RED','editable=%1'[{? ~_nocleg & ~_jestDieta  || '1' || 'grayed' ?}],,'DIETA');
H_ODDR.efld_opt('RED','editable=%1'[{? ~_dieta & ~_jestNocleg  || '1' || 'grayed' ?}],,'NOC')


\h_oddr_wer_bu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed akcją "Usuń" w oknie WER tabeli H_ODDR.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? H_ODDR.count()
|| FUN.emsg('%1\n%2'['Rekord wykorzystywany w innych tabelach.','Rekord nie może być usunięty.']);
   0
|| 1
?}


\h_oddr_wer_bdisp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed wyświetleniem okna WER w tabeli H_ODDR.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H_ODDR.efld_opt('RED','enable=1',,'DIETA');
H_ODDR.efld_opt('RED','enable=1',,'NOC');
H_ODDR.display()


\h_oddr_wer_ar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po redagowaniu rekordu w oknie WER w tabeli H_ODDR.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('h_oddr_chk','oddelegowanie',-menu_txt()='popraw')


\h_oddr_wer_br
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła przed reagowaniem rekordu w oknie WER w tabeli H_ODDR.
::   WE: _a [NUMBER] - Rekord bieżący? [0 - nie / 1 - tak]
::   WY:
::----------------------------------------------------------------------------------------------------------------------
~~


\h_oddr_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [23.25]
:: OPIS: Sprawdza poprawność wypełnienia pól w tabeli H_ODDR.
::   WE: [_a] [NUMBER] - Specyfikacja testu:
::             0 - Dołącz [domyślnie];
::             1 - Popraw.
::----------------------------------------------------------------------------------------------------------------------
_put:=var_pres('_a')=type_of(0) & _a;

__CHK.validate(H_ODDR,
:: Sprawdzenie uzupełnienia wymaganych pól.
   $("_a.table(H_ODDR,"+$_put+",,'RODZ')"),
:: Sprawdzenie poprawności wprowadzonych danych.
   "{? H_ODDR.DIETA='T' & H_ODDR.NOC='T'
    || _a.err_incorrect('NOC','Rozliczenie oddelegowania nie może być jednocześnie dietą i noclegiem.'@);
       'NOC'
    || ''
    ?}",
   "_result:='';
    {? H_ODDR.DIETA='T' | H_ODDR.NOC='T'
    || _firma:=exec('firma','ustawienia');
       H_ODDR.cntx_psh();
       H_ODDR.clear();
       {? H_ODDR.DIETA='T' &
          H_ODDR.find_tab(1,
             'FIRMA',,'=',_firma,
             'DIETA',,'=','T',
             'NOC',,'=','N',
             'IDADD',,'<>',H_ODDR.IDADD
          )
       || _a.err_incorrect('DIETA','Istnieje już rozliczenie typu ""Dieta"".'@);
          _result:='DIETA'
       ?};
       {? H_ODDR.NOC='T' &
          H_ODDR.find_tab(1,
             'FIRMA',,'=',_firma,
             'DIETA',,'=','N',
             'NOC',,'=','T',
             'IDADD',,'<>',H_ODDR.IDADD
          )
       || _a.err_incorrect('NOC','Istnieje już rozliczenie typu ""Nocleg"".'@);
          _result:='NOC'
       ?};
       H_ODDR.cntx_pop()
    ?};
    _result"
)


\h_oddsz_wer_ar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po redagowaniu rekordu w oknie WER w tabeli H_ODDSZ.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
__CHK.record(H_ODDSZ,,'SYMBOL','OPIS')


\h_oddz_kraje_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła na F3 w polu KRAJE z tabeli H_ODDZ.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_fld:=fld();

_TAB:=sql('select KRAJE.NAZ as KRAJ, \'N\' as WYBOR from KRAJE order by 1');
{? _TAB.first()
|| _wer:=_TAB.mk_sel('Kraje'@,,,'f3_kraje',,,,,'U',,,,,'maximized');

:: Kolumny w oknie
   _TAB.win_fld(_wer,,'KRAJ',,,25,,1,'Kraj'@,,'Nazwa kraju'@);
   _TAB.win_fld(_wer,,'WYBOR',,,3,,1,'Wybrany?'@,,'Wybrany (T/N)'@,2,,"'T'","'N'");
:: Akcje w oknie
   _TAB.win_act(_wer,,'Formuła','Zaznacz'@,,'Zaznaczenie wybranego kraju'@,
      "  {? cur_tab().WYBOR='N'
         || cur_tab().WYBOR:='T';
            cur_tab().put()
         ?}
      ",,1,1,,,'Z'
   );
   _TAB.win_act(_wer,,'Formuła','Pomiń'@,,'Wycofanie wyboru'@,
      "  {? cur_tab().WYBOR='T'
         || cur_tab().WYBOR:='N';
            cur_tab().put()
         ?}
      ",,,1,,,'P'
   );
   _TAB.win_act(_wer,,'Formuła','Dalej'@,,'Wyjście z okna z zaznaczonymi pozycjami'@,"sel_exit()",,,
      1,,,'D',,'target=window'
   );
   _TAB.win_act(_wer,,'Rekord',,,,
      "  _gray:={? cur_tab().WYBOR='N' || 'P' || 'Z' ?};
         _gray+={? sql('select WYBOR from :_a where :_a.WYBOR=\\\'T\\\'',cur_tab()).size() || '' || 'D' ?};
         cur_tab().actions_grayed(cur_win(),_gray)
      "
   );
:: Przyciski w oknie
   _TAB.win_btn(_wer,'text=%1,panel=right,align=begin'['Zaznacz'@],'menu:Z');
   _TAB.win_btn(_wer,'text=%1,panel=right,align=begin'['Pomiń'@],'menu:P');
   _TAB.win_btn(_wer,'text=%1,panel=bottom,align=end'['Dalej'@],'menu:D');
:: Uzupełnienie wartości w kolumnie WYBOR na podstawie zawartości pola KRAJE z tabeli H_ODDZ
   {!
   |? {? _fld*_TAB.KRAJ
      || _TAB.WYBOR:='T';
         _TAB.put()
      ?};
      _TAB.next()
   !};
   _TAB.first();
:: Wyświetlenie okna i zapisanie zmian w polu KRAJE
   _TAB.win_sel(_wer);
   {? _TAB.select()
   || _fld:='';
      _TAB.first();
      {!
      |? {? _TAB.WYBOR='T'
         || _fld+=_TAB.KRAJ+', '
         ?};
         _TAB.next()
      !}
   ?}
?};
_fld:=form(_fld);

{? _fld+1=',' || _fld-1 || _fld ?}


\h_oddz_kraje_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po redagowaniu wartości w polu KRAJE z tabeli H_ODDZ.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_fld:=H_ODDZ.KRAJE;

KRAJE.cntx_psh();
KRAJE.index('NAZ');
{!
|? _pozycja:=(_fld*',');
   {? _pozycja
   || _kraj:=(_pozycja-1)+_fld;
      _fld:=(_pozycja)-_fld
   || _kraj:=_fld;
      _fld:=''
   ?};
   {? KRAJE.find_key(|_kraj)
   || _result:=1
   || FUN.emsg('Nie znaleziono kraju o nazwie %1'@[_kraj]);
      _result:=0
   ?};
   _result & +_fld
!};
KRAJE.cntx_pop();

_result


\h_oddz_wer_ar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po redagowaniu rekordu w oknie WER w tabeli H_ODDZ.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=__CHK.record(H_ODDZ,,'SYMBOL','KRAJE','OD','DO');
{? _result=''
|| {? H_ODDZ.OD>H_ODDZ.DO
   || FUN.emsg('Wartość w polu "Data od" nie może być większa od wartości w polu "Data do".'@);
      _result:='OD'
   ?}
?};
_result


\p_info_wer_bfw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Wyświetlenie zaświadczeń dla pracownika o ubezpieczeniu podczas oddelegowania za granicę.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(H_ODDSZ,H_ODDZ);
H_ODDZ.win_edit('RED');
H_ODDZ.win_sel('WER');
H_ODDZ.index('SYMBOL');
H_ODDZ.prefix(P_INFO.FIRMA,P_INFO.OSOBA);
H_ODDZ.first();
H_ODDZ.select();
Cntx.pop(H_ODDSZ,H_ODDZ);
~~


\czy_jest_H_ODDE
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Sprawdzenie czy zostały wypełnione informacje o oddelegowaniu do pracy za granicą.
::   WE:
::   WY: 1 - oddelegowanie jest dodane, 0 - brak oddelegowania
::----------------------------------------------------------------------------------------------------------------------
H_ODDE.cntx_psh();
H_ODDE.use('h_odde'+(H.name()+1));
H_ODDE.index('HOD');
H_ODDE.prefix(H.ref());
_ok:=H_ODDE.first();
H_ODDE.cntx_pop();
_ok


\h_odde_fld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Opcje do wyświetlania okna redakcji w oddelegowaniach.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H_ODDE.efld_opt('RED','enable=%1'[$(H_ODDE.ZAKW='S')],,'ST_NOC');
H_ODDE.efld_opt('RED','enable=%1'[$(H_ODDE.ZAKW<>'N')],,'WAL_NOC');
H_ODDE.efld_opt('RED','enable=%1'[$(H_ODDE.ZAST='T')],,'P_ZAST','T');
H_ODDE.efld_opt('RED',{? H_ODDE.ZAST='T' || 'enable=1,editable=grayed' || 'enable=0' ?},OSOBA,'NAZWISKO');
H_ODDE.efld_opt('RED',{? H_ODDE.ZAST='T' || 'enable=1,editable=grayed' || 'enable=0' ?},OSOBA,'PIERWSZE')


\h_oddp_oblicz_dni
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Oblicza liczbę dni w pozycji oddelegowania na podstawie wprowadzonych dat.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? H_ODDP.DO<>date(0,0,0) & H_ODDP.OD<>date(0,0,0)
|| H_ODDP.NOM:=(H_ODDP.DO-H_ODDP.OD)+1;
   {? ~H_ODDP.DNI | H_ODDP.DNI>(H_ODDP.DO-H_ODDP.OD)+1
   || H_ODDP.DNI:=H_ODDP.NOM
   ?}
|| H_ODDP.NOM:=H_ODDP.DNI:=0
?};
H_ODDP.KW:=H_ODDP.ST*H_ODDP.DNI$2;
1


\h_odde_pull
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Tworzy kopię roboczą oddelegowań przy zmianie sposobu obsługi przebiegu zatrudnienia parametr 180 'N'->'T'.
::   WE:
::   WY: (0/1) - udało się odtowrzyć oddelegowanie do przebiegu zatrudnienia (1).
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_hidlnk:=H.IDLNK;
H.cntx_psh();
H.use('_his_');
_href:={? H.seek(_hidlnk,,1) || H.ref() || null() ?};
H.cntx_pop();

{? _href
|| H_ODDE.cntx_psh();
   H_ODDE.use('h_oddet');
   H_ODDE.index('HOD');
   H_ODDE.prefix(H.ref());
   {? H_ODDE.first()
   || {!
      |? _idlink:=H_ODDE.uidref();
         H_ODDE.cntx_psh();
         H_ODDE.use('h_odde_');
         H_ODDE.prefix();
         H_ODDE.H:=_href;
         H_ODDE.IDLINK:=_idlink;
         {? H_ODDE.add()
         || _idlink:=H_ODDE.uidref()
         || _result:=0
         ?};
         H_ODDE.cntx_pop();

         {? _result
         || H_ODDE.IDLINK:=_idlink;
            H_ODDE.put()
         || _result:=0
         ?};

         H_ODDE.next()
      !}
   ?};
   H_ODDE.cntx_pop();

   H.cntx_psh();
   H.use('_his_');
   {? H.seek(_hidlnk,,1)
   || H.IDMOD:='__';
      H.put(1)
   ?};
   H.cntx_pop()
|| _result:=0
?};

_result


\synchronizuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Funkcja synchronizująca zapis oddelegowania do wersji docelowej przebiegu zatrudnienia.
::   WE: _a - [UDIREF] - wersja docelowa przebiegu zatrudnienia
::   WY: 1 - Synchronizacja powiodła się.
::       0 - Synchronizacja nie powiodła się
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
Cntx.psh(H,H_ODDE,H_ODDP);

H_ODDE.use('h_odde_');
H_ODDE.index('HOD');
H_ODDE.prefix(H.ref());
{? H_ODDE.first()
|| _org:=exec('H_ODDE','buffer');
   _tmp:=exec('H_ODDE','buffer');
   _h_uid:=H.IDLNK;
   H.cntx_psh();
   H.use('_hist');
   _href:={? H.seek(_h_uid,,1) || H.ref() || null()?};
   H.cntx_pop();

   {!
   |? _tmp.get();
      _idlink:=H_ODDE.uidref();
      H_ODDE.cntx_psh();
      H_ODDE.use('h_oddet');
      H_ODDE.prefix();
      {? H_ODDE.seek(_tmp.IDLINK,,1)
      || _org.get();
         {? ~exec('compare','#table',_org,_tmp,1,'Ref','H','IDADD','IDLINK')
         || exec('del_h_oddp','oddelegowanie',H_ODDE.ref());
            _tmp.set();
            H_ODDE.H:=_href;
            H_ODDE.IDADD:=_org.IDADD;
            H_ODDE.IDLINK:=_org.IDLINK;
            {? H_ODDE.put(1)
            || exec('pozycje_odd','oddelegowanie');
               _idlink:=_tmp.IDLINK
            || _result:=0
            ?}
         || _idlink:=''
         ?}
      || H.cntx_psh();
         H.use('_hist');
         H_ODDE.prefix();
         H_ODDE.blank();
         _tmp.set();
         {? _href
         || H_ODDE.H:=_href;
            H_ODDE.IDLINK:=_idlink;
            {? H_ODDE.add(1)
            || exec('pozycje_odd','oddelegowanie');
               _idlink:=H_ODDE.uidref()
            || _result:=0
            ?}
         ?};
         H.cntx_pop()
      ?};
      H_ODDE.cntx_pop();
      {? +_idlink
      || H_ODDE.IDLINK:=_idlink;
         {? ~H_ODDE.put(1)
         || _result:=0
         ?}
      ?};
      H_ODDE.next()
   !}
?};
Cntx.pop(H,H_ODDE,H_ODDP);
_result


\h_odde_cancel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Wycofanie modyfikacji w oddelegowaniu
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
{? H.ODDEL='T'
|| H_ODDE.cntx_psh();
   H_ODDE.use('h_odde_');
   H_ODDE.index('HOD');
   H_ODDE.prefix(H.ref());
   {? H_ODDE.first()
   || _org:=exec('H_ODDE','buffer');
      _tmp:=exec('H_ODDE','buffer');
      {!
      |? _tmp.get();
         H_ODDE.cntx_psh();
         H_ODDE.use('h_oddet');
         H_ODDE.index('HOD');
         H_ODDE.prefix();
         {? H_ODDE.seek(_tmp.IDLINK,)
         || _org.get();
            H_ODDE.cntx_pop();
            _org.set();
            H_ODDE.IDADD:=_tmp.IDADD;
            H_ODDE.IDLINK:=_tmp.IDLINK;
            H_ODDE.H:=_tmp.H;
            _result:=H_ODDE.put(1)
         || H_ODDE.cntx_pop();
            _result:=0
         ?};
         H_ODDE.next()
      !}
   ?};
   H_ODDE.cntx_pop()
?};
_result


\del_h_oddp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Usunięcie pozycji oddelegowania.
::   WE: _a [REFERENCE] - wskazanie na oddelegowanie z którego usuwamy pozycje.
::      [_b][INTEGER] - Czy komunikować brak możliwości usunięcia? Domyślnie: 0 - nie komunikować
::   WY: 0/1 - wkasowane wszystkie wiersze z dziedziny (1)
::----------------------------------------------------------------------------------------------------------------------
_kom:={? var_pres('_b')=type_of(0) || _b || 0 ?};
H_ODDP.cntx_psh();
H_ODDP.index('H_ODDE');
H_ODDP.prefix(_a);
{? H_ODDP.first()
|| {!
   |? {? +H_ODDP.LT | H_ODDP.ZAPIS='R'
      || H_ODDP.next()
      || H_ODDP.del()
      ?}
   !}
?};
_result:=H_ODDP.size()=0;
H_ODDP.cntx_pop();
{? ~_result & _kom
|| FUN.emsg('%1\n%2'['Niektóre pozycje oddelegowania były już redagowane lub rozliczone na liście płac.'@,
                     'Proszę zweryfikować dane.'@])
?};
_result


\generuj_pozycje
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Funkcja do tworzenia pozycji do oddelegowania w tabeli H_ODDP.
::   WE: _a - [REFERENCE] - wskazanie na wiersz w słowniku rodzajów pozycji (diety lub noclegi).
::       [_b] - [REAL] - stawka do rozliczenia (jeżeli niewypełnione to ustalane jest dla diety zagranicznej).
::       [_c] - [REFERENCE] - waluta rozliczenia (jeżeli niewypełnione to ustalane jest dla diety zagranicznej).
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_rodzaj:={? var_pres('_a')=type_of(null()) || _a || return(~~) ?};
_stawka:=
   {? var_pres('_b')=type_of(0)
   || _b
   || {? DIETZAGR.find_le(H_ODDE.O_OD) || DIETZAGR.STAWKA || 0 ?}
   ?};
_dieta:=0;
{? var_pres('_c')=type_of(null())
|| _waluta:=_c
|| {? _stawka
   || _waluta:=DIETZAGR.WAL;
      _dieta:=(DIETZAGR.find_le(H_ODDE.O_DO) & DIETZAGR.STAWKA<>_stawka)
   || _waluta:=null();
      _dieta:=1
   ?}
?};
_od:=H_ODDE.O_OD;

_add:=
   "  {? _a
      || {? DIETZAGR.find_le(_b)
         || _d:=DIETZAGR.STAWKA;
            _e:=DIETZAGR.WAL
         ?};
         {? DIETZAGR.find_le(_c) & DIETZAGR.STAWKA<>_d
         || _c:=DIETZAGR.OD-1
         ?}
      ?};

      H_ODDP.blank();
      H_ODDP.ZAPIS:='A';
      H_ODDP.OD:=_b;
      H_ODDP.DO:=_c;
      H_ODDP.ST:=_d;
      H_ODDP.WAL:=_e;
      H_ODDP.RODZ:=_f;
      H_ODDP.NOM:=H_ODDP.DNI:=(H_ODDP.DO-H_ODDP.OD)+1;
      H_ODDP.KW:=H_ODDP.DNI*H_ODDP.ST$2;
      H_ODDP.add(1);
      _c
   ";

H_ODDP.cntx_psh();
H_ODDP.index('H_ODDE');
H_ODDP.prefix(H_ODDE.ref());
H_ODDP.first();
{!
|? _do:={? H_ODDE.O_DO<date(_od~1,_od~2,0) || H_ODDE.O_DO || date(_od~1,_od~2,0) ?};
   {? H_ODDP.find_tab('first','H_ODDE',,'=',H_ODDP.H_ODDE,'RODZ',,'=',_rodzaj,'OD',,'<=',_do,'DO',,'>=',_od)
   || {? _od>=H_ODDP.OD
      || _od:=H_ODDP.DO+1
      |? _od<H_ODDP.OD
      || _do:=H_ODDP.OD-1;
         _od:=_add(_dieta,_od,_do,_stawka,_waluta,_rodzaj)+1
      ?}
   || _od:=_add(_dieta,_od,_do,_stawka,_waluta,_rodzaj)+1
   ?};
   _od<=H_ODDE.O_DO
!};
H_ODDP.cntx_pop()


\zmianyodelegowania
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Sprawdzenie czy zostało zmienione oddelegowanie - tylko dla przebiegu z "brudnopisu".
::   WE: _a - Wskazanie na roboczy przebieg zatrudnienia.
::       _b - Wskazanie na docelowy przebieg zatrudnienia
::   WY: (0/1) - wystąpiły zmiany w zapisie oddelegowania (1)
::----------------------------------------------------------------------------------------------------------------------
_result:=_size:=0;
_tmp:=exec('H_ODDE','buffer');
_org:=exec('H_ODDE','buffer');

Cntx.psh(H,H_ODDE);
H.use('_his_');
{? H.seek(_a,,1)
|| H_ODDE.use('h_odde_');
   H_ODDE.index('HOD');
   H_ODDE.prefix(H.ref());
   _size:=H_ODDE.size()
?};
H_ODDE.cntx_psh();
H.use('_hist');
{? H.seek(_b,,1)
|| H_ODDE.use('h_oddet');
   H_ODDE.index('HOD');
   H_ODDE.prefix(H.ref());
   _result:=H_ODDE.size()<>_size
?};
H_ODDE.cntx_pop();

{? ~_result
|| {? H_ODDE.first()
   || {!
      |? _tmp.get();
         _idlink:=H_ODDE.IDLINK;
         H_ODDE.cntx_psh();
         H_ODDE.use('h_oddet');
         {? H_ODDE.seek(_idlink,,1)
         || _org.get();
            _result:=~exec('compare','#table',_org,_tmp,1,'Ref','H','IDADD','IDLINK')
         ?};
         H_ODDE.cntx_pop();
         H_ODDE.next() & ~_result
      !}
   ?}
?};

Cntx.pop(H,H_ODDE);
_result


\msg_grp_akceptuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Komunikat o braku wymaganych zapisów w tabeli oddelegowań podczas akceptacji umowy w wersji z "brudnopisem".
::   WE: _a - Wskazanie umowy dla której wykonywana jest funkcja.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_txt:='';
H_ODDE.cntx_psh();
H_ODDE.use('h_odde_');
{? sql('
      select *
      from H_ODDE
      where H_ODDE.H=(select H.REFERENCE from H where H.UMOWA=:_a and H.ODDEL=\'T\' and H.IDMOD<>\'__\')',
      _a
   ).size()=0
|| _txt:='\n%1'['Brak szczegółowych informacji o oddelegowaniu do pracy za granicą.'@]
?};
H_ODDE.cntx_pop();
_txt


\add_h4oddelegowanie
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Dodanie aneksu po oddelegowaniu jeżeli data początku oddelegowania pokrywa się z datą
::       rozpoczęci istniejącego aneksu do umowy.
::   WE: _a [REFERENCE] - Umowa, do której dodawany jest aneks.
::       _b [DATE] - Data zakończenia oddelegowania.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_txt:='';
_put:=0;
:: Data rozpoczęcia redagowanego aneksu do umowy.
_h_od:=H.OD;

:: Odszukanie zapisanego aneksu do umowy, którego data rozpoczęcia pokrywa się z datą aneksu redagowanego.
H.cntx_psh();
H.index('HISTUM');
H.prefix(_a);
{? H.find_key(_h_od)
|| {? H.DO=date(0,0,0) | H.DO>=_b
   || H.OD:=_b+1;
:: Poprawienie daty rozpoczęcia zapisanego aneksu do umowy w celu umożliwienia dodanie aneksu z oddelegowaniem.
      _put:=H.put(1);
      {? ~_put
      || _txt:='Nie udało się dodać anesku z oddelegowaniem.'@
      ?}
   || _txt:='%1\n%2'['Data zakończenia oddelegowania wykracza poza okres umowy'@,'Dodanie aneksu nie jest możliwe'@]
   ?}
?};
H.cntx_pop();
:: Jeżeli udałą się zmiana w aneksie to ustalenie daty końcowej dodawanego aneksu.
{? _put
|| H.DO:=_b
?};
_txt


\spr_h_oddez
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Sprawdzenie uzupełnienia informacji dotyczącej zaświadczenia o ubezpieczeniu ZUS.
::       Uwaga! Do poporawnego działania funkcji wymagane jest ustawienie właściwego wiersza z tabeli H_ODDE
::   WE: [_a] [INTEGER] - (0/1) Tryb pracy, 1 - wyświetlenie komunikatu.
::   WY: Informacja o błędzie.
::----------------------------------------------------------------------------------------------------------------------
_msg:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_txt:='';
P.cntx_psh();
OSOBA.cntx_psh();
H.cntx_psh();
H_ODDE.cntx_psh();
{? H_ODDE.ZUS='T'
|| H_ODDZ.cntx_psh();
   H_ODDZ.index('SYMBOL');
   H_ODDZ.prefix(H.P().FIRMA,P.OSOBA);
   {? H_ODDZ.find_le(H_ODDE.O_DO) & H_ODDZ.DO>=H_ODDE.O_OD
   || {!
      |? {? H_ODDZ.KRAJE*H_ODDE.KRAJ().NAZ
         || {? H_ODDZ.OD>H_ODDE.O_OD | H_ODDZ.DO<H_ODDE.O_DO
            || _txt:='Brak zaświadczenia o ubezpieczeniu na cały okres wprowadzonego oddelegowania.'@
            || _txt:=''
            ?}
         |? ~+_txt
         || _txt:='Brak zaświadczenia o ubezpieczeniu do kraju, do którego wprowadzone jest oddelegowanie.'@
         ?};

         +_txt & H_ODDZ.prev() & H_ODDZ.DO>=H_ODDE.O_OD
      !}

   || _txt:='Brak zaświadczenia o ubezpieczeniu na czas wprowadzonego oddelegowania.'@
   ?};
   {? +_txt
   || _txt+='\n%1'['Proszę uzupełnić brakujące informacje w danych ubezpieczeniowych.'@];
      {? _msg || FUN.emsg(_txt) ?}
   ?};
   H_ODDZ.cntx_pop()
|| {? H.P
   || _rapLast:=exec('rap_last','rap_zus',H.P().OSOBA,H_ODDE.O_OD,'ZUA,ZZA,ZWUA');
      {? _rapLast.typ<>'' & _rapLast.typ<>'ZWUA'
      || _txt:='Należy wyrejestrować współpracownika z ZUS\nna czas oddelegowania.'@;
         {? _msg || FUN.emsg(_txt) ?}
      ?};
      obj_del(_rapLast)
   ?}
?};
H_ODDE.cntx_pop();
H.cntx_pop();
OSOBA.cntx_pop();
P.cntx_pop();
_txt


\h_miejsce
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Aktualizacja miejsca pracy w aneksie do umowy na podstawie miejsca pracy w oddelegowaniu
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_kraj:=_miasto:=_pomoc:=_miejsce:='';
_TAB:=tab_tmp(2,
   'KRAJ','STRING[20]','Kraj',
   'MIASTO','STRING[30]','Miasto'
);

H_ODDE.cntx_psh();
H_ODDE.index('HOD');
H_ODDE.prefix(H.ref());
{? H_ODDE.first()
|| {!
   |? _TAB.KRAJ:=H_ODDE.KRAJ().NAZ;
      _TAB.MIASTO:=H_ODDE.M_PRAC().MIASTO;
      {? {? +_TAB.MIASTO
         || ~_TAB.find_key(_TAB.KRAJ,_TAB.MIASTO)
         || 1
         ?}
      || _TAB.add()
      ?};
      H_ODDE.next()
   !}
?};
H_ODDE.cntx_pop();

{? _TAB.first()
|| {!
   |? {? _kraj<>_TAB.KRAJ
      || _miejsce+={? +_miejsce || ', ' || '' ?}+_pomoc;
         _pomoc:='';
         _kraj:=_TAB.KRAJ;
         _miasto:=_TAB.MIASTO
      || {? +_miasto
         || _miasto:=_TAB.MIASTO
         ?}
      ?};
      {? +_miasto
      || _pomoc+={? +_pomoc || ', ' || '' ?}+_kraj+' '+_miasto
      || _pomoc:=_kraj
      ?};
      _next:=_TAB.next();
      {? ~_next
      || _miejsce+={? +_miejsce || ', ' || '' ?}+_pomoc;
         0
      || 1
      ?}
   !}
|| _miejsce:=''
?};

_miejsce


\test_ciaglosci_oddelegowan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Sprawdzenie czy w zakresie dat aneksu do umowy wprowadzono wszystkie oddelegowania.
::   WE: [_a] [STRING] - Funkcja została wywołana podczas redagownia umowy (H_UM), aneksu(H).
::       [_b] [INTEGER] - Wyświetlenie komunikatu w postaci:
::                         0 - informacji
::                         1 - pytania
::   WY: 0/1 Informacja czy należy przerwać akcję czy można ją kontynuować.
::----------------------------------------------------------------------------------------------------------------------
{? PAR_SKID.get(261)='N' || return(1) ?};

_result:=1;
H.get();
{? H.ODDEL='T'
|| _tab:={? var_pres('_a')=type_of('') || _a || 'H' ?};
   _komm:={? var_pres('_b')=type_of(0) || _b || 1 ?};_txt:='';
   _od:=($(_tab+'.OD'))();
   _do:=($(_tab+'.DO'))();
   {? _do=date(0,0,0)
   || {? _tab='H'
      || _txt:='Data w polu "Data zakończenia" aneksu na czas oddelegowania do pracy za granicą nie może być zerowa.'@
      || _txt:='Data w polu "Data zakończenia" umowy na czas oddelegowania do pracy za granicą nie może być zerowa.'@;
         _result:=_komm:=0
      ?}
   || H_ODDE.cntx_psh();
      H_ODDE.index('HOD');
      H_ODDE.prefix(H.ref());
      {? H_ODDE.last()
      || {? _do<>H_ODDE.O_DO
         || _txt:=
               {? _tab='H'
               || 'Data w polu "Data do" oddelegowania jest różna od daty w polu "Data zakończenia" aneksu do umowy.'@
               || 'Data w polu "Data do" oddelegowania jest różna od daty w polu "Data zakończenia" z umowy.'@
               ?}
         |? H_ODDE.first() & _od<>H_ODDE.O_OD
         || _txt:=
               {? _tab='H'
               || 'Data w polu "Data od" oddelegowania jest różna od daty w polu "Data rozpoczęcia" aneksu do umowy.'@
               || 'Data w polu "Data od" oddelegowania jest różna od daty w polu "Data rozpoczęcia" z umowy.'@
               ?}
         || _dt:=H_ODDE.O_DO;
            {!
            |? _next:=H_ODDE.next();
               {? _next & H_ODDE.O_OD<>_dt+1
               || _txt:='Brak ciągłości zapisów w tabeli z oddelegowaniami do pracy za granicą.'@;
                  0
               || _next
               ?}
            !}
         ?}
      || _txt:='Brak wprowadzonego oddelegowania.'@
      ?};
      H_ODDE.cntx_pop()
   ?};

   {? +_txt
   || {? _tab='H_UM'
      || {? _komm
         || _result:=FUN.ask('%1\n%2'[_txt,'Czy chcesz kontynuować?'@])
         || FUN.emsg('%1\n%2'[_txt,'Należy zweryfikować dane dotyczące umowy o pracę.'@])
         ?}
      || FUN.emsg('%1\n%2'[_txt,'Należy poprawić dane dotyczące aneksu lub oddelegowania.'@])
      ?}
   ?}
?};
_result


\zmiana_parametru_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Sprawdzenie czy można zmienić parametr 261 z 'T' na 'N'. Możliwe tylko gdy nie ma aktywnych oddelegowań.
::   WE: _a [STRING] - Wartość w polu "Treść parametru" przed zmianą.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
{? _a='T' & fld()='N'
|| _ODD:=sql(
      'select O_DO from @H_ODDE '
      'join @H using(H_ODDE.H, H.REFERENCE) '
      'join P using(H.P, P.REFERENCE) '
      'where O_DO>=to_date(:_a) and P.FIRMA=:_b',
      date(),exec('firma','ustawienia')
      );
   _result:=~(_ODD.size());
   obj_del(_ODD);
   {? ~_result
   || FUN.emsg('%1\n%2\n%3'
         [  'Zmiana parametru niemożliwa.'@,
            'Znaleziono oddelegowania do pracy za granicą kończące się po dacie %1.'@[date()$1],
            'Przed zmianą parametru należy zakończyć wszystkie umowy z oddelegowaniami.'@
         ]
      )
   ?}
?};
_parNum:=397;
{? _result & fld()='T' & exec('get_par_date','parametr',_parNum,1)=date(0,0,0)
|| FUN.info('%1 %2: "%3".\n(%4 -> %5 -> %6 -> %7 -> %8)\n%9\n%10'
      ['Należy uzupełnić wartość parametru'@,$_parNum,PAR_SKID.opis(_parNum),'Ustawienia i parametryzacja'@,
      'Parametryzacja'@,'Wspólne'@,'Ustawienia systemu'@,'Lista parametrów'@,
      'Parametr powoduje, że od wprowadzonej daty diety pomniejszające przychód wykorzystywane przy rozliczaniu '
      'oddelegowań oraz kierowców (pakiet mobilności) będą liczone na nowym składniku 7197. '
      'Składnik 780 - Podst. opodatkowania zostanie pomniejszony o wartość 30\% diet (7197 - OZ: Diety pomn. prz.).'@,
      'Zmianę daty parametru należy wykonać po zamknięciu wszystkich list z wybranego miesiąca.'@])
?};
_result


\var_edit_t_disp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [19.02]
:: OPIS: Przed wyświetleniem pola T zmiennej VAR_EDIT.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
P.cntx_psh();
OSOBA.cntx_psh();
P.prefix();
{? P.seek(H_ODDE.P_ZAST,)
|| VAR_EDIT.T:=P.T;
   VAR_EDIT.NAZWISKO:=P.OSOBA().NAZWISKO;
   VAR_EDIT.PIERWSZE:=OSOBA.PIERWSZE
|| VAR_EDIT.T:=VAR_EDIT.NAZWISKO:=VAR_EDIT.PIERWSZE:=''
?};
OSOBA.cntx_pop();
P.cntx_pop();
VAR_EDIT.T


\var_edit_t_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [19.02]
:: OPIS: Wyświetlenie słownika pracowników.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_fld:=fld();
P.cntx_psh();
OSOBA.cntx_psh();
{? H_ODDE.P_ZAST
|| _pref:=H_ODDE.P_ZAST().ref()
|| P.index('PRACOTEC');
   P.prefix(exec('ref_firma','ustawienia'),'P');
   P.find_key(_fld);
   _pref:=P.ref()
?};

UD_DEF.cntx_psh();
UD_DEF.index('PODTEC');
UD_DEF.prefix(UD_SCH.ref(),__PARSES.getVal('JednostkaOrganizacyjna').REF);
_ud_def:={? UD_DEF.first() || UD_DEF.ref() || null() ?};
UD_DEF.cntx_pop();

P.clear();
{? P.f_active() || P.f_clear() ?};
exec('filtruj_p','schemat','PKD',_ud_def,'P',,'*');
{? +_fld
|| P.f_seek(_pref,)
?};
P.win_sel('PKD_SLO');
{? P.select(,1)
|| H_ODDE.P_ZAST:=P.ref();
   VAR_EDIT.T:=P.T;
   VAR_EDIT.NAZWISKO:=P.OSOBA().NAZWISKO;
   VAR_EDIT.PIERWSZE:=OSOBA.PIERWSZE
|| {? _fld=''
   || VAR_EDIT.T:=VAR_EDIT.NAZWISKO:=VAR_EDIT.PIERWSZE:='';
      H_ODDE.P_ZAST:=null()
   ?}
?};

OSOBA.cntx_pop();
P.cntx_pop();
VAR_EDIT.T


\var_edit_t_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [19.02]
:: OPIS: Po edycji pola T zmiennej VAR_EDIT.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? fld()=''
|| H_ODDE.P_ZAST:=null();
   VAR_EDIT.T:=VAR_EDIT.NAZWISKO:=VAR_EDIT.PIERWSZE:=''
|| P.cntx_psh();
   P.clear();
   {? P.f_active() || P.f_clear() ?};
   exec('filtruj_p','schemat','PKD',UD_DEF.ref(),'P',,'*',,
      {? H_ODDE.P_ZAST  & H_ODDE.P_ZAST().T=fld()
      || 'P.REFERENCE=\''+$H_ODDE.P_ZAST+'\''
      || 'P.T=\''+fld()+'\''
      ?}
   );
   {? P.f_first()
   || H_ODDE.P_ZAST:=P.ref();
      VAR_EDIT.T:=P.T;
      VAR_EDIT.NAZWISKO:=P.OSOBA().NAZWISKO;
      VAR_EDIT.PIERWSZE:=OSOBA.PIERWSZE
   || H_ODDE.P_ZAST:=null();
      VAR_EDIT.T:=VAR_EDIT.NAZWISKO:=VAR_EDIT.PIERWSZE:=''
   ?};
   P.cntx_pop();
   {? P.f_active() || P.f_clear() ?}
?};
1


\oblicz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Obliczenie i zapisanie na liście płac kwoty dla pozycji oddelegowaia do pracy za granicą.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? PAR_SKID.get(261)='N' | O.B_ODD='T' || return(0) ?};

H_ODDR.cntx_psh();
H_ODDR.index('H_ODDRDN');
H_ODDR.prefix(exec('firma','ustawienia'));
{? H_ODDR.first()
|| _od:=date(O.R,O.M,1);
   _do:=date(O.R,O.M,0);
   _dni_oddel:=0;

   {!
   |? _kwota:=0;
      _kontrola:=H_ODDR.DIETA='T' | H_ODDR.NOC='T';

      H.cntx_psh();
      H.index('HISTODD');
      H.prefix(P.ref(),'T');
      {? H.find_le(_do) & (H.DO=date(0,0,0) | H.DO>=_od)
      || Cntx.psh(N,H_ODDE,H_ODDP);
:: Został znaleziony przebieg zatrudnienia z oddelegowaniem w okresie, za który obliczana jest lista płac.
         N.index('NIEOBECN');
         N.prefix('N',P.ref());
         H_ODDE.index('HOD');
         H_ODDP.index('RODZ');
:: Uwzględniamy wszystkie aneksy w okresie, za który obliczana jest lista płac.
         {!
         |? _h_od:={? H.OD<_od || _od || H.OD ?};
            _h_do:={? H.DO>_do | H.DO=date(0,0,0) || _do ||  H.DO ?};

            H_ODDE.prefix(H.ref());
            {? H_ODDE.find_le(_h_do) & (H_ODDE.O_DO=date(0,0,0) | H_ODDE.O_DO>=_h_od)
            || {? H_ODDR.DIETA='T'
               || _txt:=exec('spr_h_oddez','oddelegowanie',0);
                  {? +_txt
                  || RAPLS.msg(P.T,P.OSOBA().NAZWISKO,OSOBA.PIERWSZE,_txt)
                  ?}
               ?};
               {? H_ODDE.O_DO<>date(0,0,0) & H_ODDE.O_DO<_h_do
               || {? H_ODDR.DIETA='T'
                  || _txt:='Brak oddelegowania w okresie od %1 do %2.'@[(H_ODDE.O_DO+1)$1,_h_do$1];
                     RAPLS.msg(P.T,P.OSOBA().NAZWISKO,OSOBA.PIERWSZE,_txt,exec('retry_msg','lista_licz'))
                  ?}
               ?};
:: Uwzględniamy wszystkie oddelegowania w okresie, za który obliczana jest lista płac.
               {!
               |? _o_od:={? H_ODDE.O_OD<_h_od || _h_od || H_ODDE.O_OD?};
                  _o_do:={? H_ODDE.O_DO>_h_do | H_ODDE.O_DO=date(0,0,0) || _h_do || H_ODDE.O_DO ?};

                  {? (H_ODDR.NOC='N' | (H_ODDR.NOC='T' & H_ODDE.ZAKW<>'N')) &
                     (O.KRAJE=null() | H_ODDE.KRAJ=O.KRAJE)
                  || H_ODDP.prefix(H_ODDE.ref(),H_ODDR.RODZ);
                     {? H_ODDP.find_le(_o_do) & H_ODDP.DO>=_o_od
                     || {? _kontrola & H_ODDP.DO<_o_do
                        || _txt:='%1: brak danych do rozliczenia oddelegowania w okresie od %2 do %3'@
                              [  H_ODDR.RODZ,
                                 (H_ODDP.DO+1)$1,_o_do$1
                              ];
                           RAPLS.msg(P.T,P.OSOBA().NAZWISKO,OSOBA.PIERWSZE,_txt,exec('retry_msg','lista_licz'))
                        ?};
:: Uwzględniamy wszystkie pozycje oddelegowania do rozliczenia w okresie, za który obliczana jest lista płac.
                        {!
                        |? _p_od:=H_ODDP.OD;
                           _p_do:=H_ODDP.DO;

                           {? _kontrola
                           || {? H_ODDP.ZAPIS='A'
                              || _dni:=(H_ODDP.DO-H_ODDP.OD)+1;
:: Ustalenie liczby dni nieobecności obniżających liczbę dni pracy za granicą
:: jeśli zapis w pozycjach oddelegowania do pracy za granicą jest automatyczny.
                                 _ndk:=0;
                                 {? N.find_le(H_ODDP.DO) & N.DO>=H_ODDP.OD
                                 || {!
                                    |? _nod:={? H_ODDP.OD<N.OD || N.OD || H_ODDP.OD ?};
                                       _ndo:={? H_ODDP.DO>N.DO || N.DO || H_ODDP.DO ?};
                                       _ndk+=(_ndo-_nod)+1;
                                       N.prev() & N.DO>=H_ODDP.OD
                                    !}
                                 ?};
:: Przeliczenie wartości w polach wiersza tabeli pozycji oddelegowań
                                 H_ODDP.DNI:=_dni-_ndk;
                                 H_ODDP.KW:=H_ODDP.DNI*H_ODDP.ST$2
                              ?}
                           ?};
:: Zapisanie informacji o pobraniu danych do rozliczenia na liście płac
                           H_ODDP.LT:=~O.LT;
                           _kurs:=
                              {? H_ODDP.WAL().SYM=''
                              || _txt:='Pole "Waluta" w pozycji rozliczenia oddelegowania jest puste.'@;
                                 RAPLS.msg(P.T,P.OSOBA().NAZWISKO,OSOBA.PIERWSZE,_txt,exec('retry_msg','lista_licz'))
                              |? H_ODDP.WAL().SYM<>'PLN'
                              || exec('kurs_waluty','oddelegowanie',H_ODDP.WAL().SYM,H_ODDP.H_ODDE().TKRS)
                              || 1
                              ?};
                           H_ODDP.KW_PLN:=H_ODDP.KW*_kurs$2;
                           {? H_ODDP.put(1)
                           ||
::                            Kwotę zapisz tylko gdy podatek w polsce lub dla diet zus w polsce:
                              {? H_ODDE.POD='T' | (H_ODDE.ZUS='T' & H_ODDR.DIETA='T')
                              || _kwota+=H_ODDP.KW_PLN
                              ?};
                              {? H_ODDR.DIETA='T'
                              || _dni_oddel+=H_ODDP.DNI
                              ?}
                           ?};

                           _p_prev:=H_ODDP.prev() & H_ODDP.DO>=_o_od;
                           {? _kontrola & _p_prev & H_ODDP.DO<>_p_od-1
                           || _txt:='%1: brak danych do rozliczenia oddelegowania w okresie od %2 do %3'@
                                 [  H_ODDR.RODZ,
                                    (H_ODDP.DO+1)$1,
                                    (_p_od-1)$1
                                 ];
                              RAPLS.msg(P.T,P.OSOBA().NAZWISKO,OSOBA.PIERWSZE,_txt,exec('retry_msg','lista_licz'))
                           |? _kontrola & ~_p_prev & H_ODDP.OD>_o_od
                           || _txt:='%1: brak danych do rozliczenia oddelegowania w okresie od %2 do %3'@
                                 [  H_ODDR.RODZ,
                                    _o_od$1,
                                    (H_ODDP.OD-1)$1
                                 ];
                              RAPLS.msg(P.T,P.OSOBA().NAZWISKO,OSOBA.PIERWSZE,_txt,exec('retry_msg','lista_licz'))
                           ?};
                           _p_prev
                        !}
                     || {? _kontrola
                        || _txt:='%1: brak danych do rozliczenia oddelegowania w okresie od %2 do %3'
                              [  H_ODDR.RODZ,
                                 _o_od$1,
                                 _o_do$1
                              ];
                           RAPLS.msg(P.T,P.OSOBA().NAZWISKO,OSOBA.PIERWSZE,_txt,exec('retry_msg','lista_licz'))
                        ?}
                     ?}
                  ?};
                  _o_prev:=H_ODDE.prev() & H_ODDE.O_DO>=_h_od;
                  {? H_ODDE.O_DO<_o_od-1
                     &
                     {? _h_od>_o_od-1 || H_ODDE.O_DO>=_h_od || 1 ?}
                  || {? H_ODDR.DIETA='T'
                     || _txt:='Brak oddelegowania w okresie od %1 do %2.'@
                           [  {? (H_ODDE.O_DO+1)<_h_od || _h_od$1 || (H_ODDE.O_DO+1)$1 ?},
                              (_o_od-1)$1
                           ];
                        RAPLS.msg(P.T,P.OSOBA().NAZWISKO,OSOBA.PIERWSZE,_txt,exec('retry_msg','lista_licz'))
                     ?}
                  ?};
                  _o_prev
               !}
            || {? H_ODDR.DIETA='T'
               || _txt:='Brak oddelegowania w okresie od %1 do %2.'@[_h_od$1,_h_do$1];
                  RAPLS.msg(P.T,P.OSOBA().NAZWISKO,OSOBA.PIERWSZE,_txt,exec('retry_msg','lista_licz'))
               ?}
            ?};
            H.prev() & H.DO>=_od
         !};
         Cntx.pop(N,H_ODDE,H_ODDP)
      ?};
      H.cntx_pop();

      {? H_ODDR.R().RN
      || FUNKCJE.LK(H_ODDR.R().RN,,_kwota)
      ?};
      H_ODDR.next()
   !};
:: Informacja o liczbie dni pobytu za granicą
   FUNKCJE.LK(7080,,_dni_oddel)
?};
H_ODDR.cntx_pop();
~~


\kurs_waluty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Ustalenie kursu waluty do obliczenia oddelegowań.
::   WE: _a - [STRING] - waluta do rozliczenia składnika.
::       _b - [REFERENCE] - wskazanie na tabelę kursów w H.
::   WY: Cena waluty w dniu kursu z nagłówka listy płac.
::----------------------------------------------------------------------------------------------------------------------
_swal:={? var_pres('_a')=type_of('') || _a || return(0) ?};
_zrodlo:={? var_pres('_b')=type_of(null()) || _b || return(0) ?};
_kurs:=0;

:: Ustalenie daty kursu waluty.
_data_kursu:=O.DKURS;
{? _data_kursu=date(0,0,0)
|| RAPLS.msg('','','','Dla listy %1 nie podano daty ustalenia kursu walut.'@[~O.LT],exec('retry_msg','lista_licz'));
   return(0)
?};

:: Ustalenie waluty na podstawie słownika walut wskazanego w słownikach systemowych i jej kursu z tabeli kursów walut.
exec('czytaj','#stalesys',_data_kursu,XINFO,'SLWAL');
_slwal:=XINFO.SLWAL;
{? _slwal
|| SLO.cntx_psh();
   SLO.index('SL');
   SLO.prefix(_slwal,_swal);
   {? SLO.first()
   || _kurs:=exec('waluta_kurs','lista_licz',_zrodlo,_data_kursu,SLO.ref());
      {? _kurs
      || _kurs/=exec('waluta_miara','lista_licz',_swal)
      ?}
   || _txt:='W słowniku walut nie udało się odnaleźć waluty %1'@[_swal];
      RAPLS.msg('','','',_txt,exec('retry_msg','lista_licz'))
   ?};
   SLO.cntx_pop()
|| _txt:='W słownikach systemowych nie wprowadzono wartości w polu "Słownik walut"'@;
   RAPLS.msg('','','',_txt,exec('retry_msg','lista_licz'))
?};

_kurs


\usun_LT
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Usunięcie rozliczenia oddelegowania do pracy za granicą.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H_ODDP.cntx_psh();
{? H_ODDP.f_active() || H_ODDP.f_clear() ?};
H_ODDP.clear();
H_ODDP.f_set(,'left join H_ODDE left join H','H_ODDP.LT=\':_a\' and H.P=\':_b\'',VAR.NAZWALIS,$P.ref());
{? H_ODDP.f_first()
|| {!
   |? H_ODDP.LT:='';
      H_ODDP.KW_PLN:=0;
      H_ODDP.put();
      H_ODDP.f_next()
   !}
?};
{? H_ODDP.f_active() || H_ODDP.f_clear() ?};
H_ODDP.cntx_pop();
~~


\podstawa_par
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [22.26]
:: OPIS: Tablica nazwana opcjonalnych parametrów wywołania formuły podstawa_sk
::   WE:[_a][INTEGER] - 0/1 czy zwracać obiekt (brak wołania LK dla odliczonych diet)? [domyślnie 0]
::      [_b][INTEGER] - kod atrybutu składników zmieniających wysokość podstawy [domyślnie 0]
::      [_c][STRING] - T/N czy pomijać kartotekę oddelegowań [O.B_ODD]
::      [_d][INTEGER] - 0/1 czy pomniejszać podstawę o diety? [domyślnie 1]
::   WY: referencja tablicy nazwanej
::----------------------------------------------------------------------------------------------------------------------
_par:=obj_new(
:: czy zwracać obiekt
   'OBIEKT',
:: kod atrybutu składników zmieniających wysokość podstawy
   'POM_ATR',
:: czy pomijać kartotekę oddelegowań
   'B_ODD',
:: czy pomniejszać podstawę o diety
   'BEZ_DIET'
);

_par.OBIEKT:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_par.POM_ATR:={? var_pres('_b')=type_of(0) || _b ?};
_par.B_ODD:={? var_pres('_c')=type_of('') || _c || O.B_ODD ?};
_par.BEZ_DIET:={? var_pres('_d')=type_of(0) || _d || 1 ?};

_par


\podstawa_sk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Ustalenie podstawy składek ZUS jeśli wystąpiło oddelegowanie do pracy za granicą.
::   WE: _a [STRING]  - Wskazanie na metodę obliczenia symy podstawy składek.
::       _b [INTEGER] - Nr rubryki do obliczenia sumy podstaw składek ZUS z list płac miesiąca obliczanej listy.
::      [_c][INTEGER] - 0/1 Czy obliczenie dla rachunku? Domyślnie 0 - dla listy płac
::      [_d][OBJECT]  - referencja obiektu zawierającego parametry działania (patrz podstawa_par)
::   WY: [INTEGER/OBJ] Kwota podstawy składek ZUS.
::                     Dla wybranych rubryk (7087) zwracana jest tablica elementów nazwanych:
::                         * .podstawa [REAL] - kwota podstawy
::                         * .diety [REAL] - kwota diet odliczonych (do składnika powiązanego)
::----------------------------------------------------------------------------------------------------------------------
_podstawa:=0;
{? var_pres('_a')<>type_of('') | var_pres('_b')<>type_of(0)
|| FUN.error('Błąd parametrów wejściowych!'@);
   return(0)
?};
_metoda:=_a;
_rubryka:=_b;
_czyRH:={? var_pres('_c')=type_of(0) || _c || 0 ?};
_par:={? var_pres('_d')>100 || _d || exec('podstawa_par','oddelegowanie') ?};
_bOdd:=_par.B_ODD;
_retObj:=_par.OBIEKT;
_pomPdst:=_par.BEZ_DIET;
_d0:=date(0,0,0);
_zwrotyKierowcy:=0;
_pracownicze:=1;

{? _retObj
|| _ret:=obj_new('podstawa','diety','zwrotyDoDol');
   _ret.podstawa:=_ret.diety:=_ret.zwrotyDoDol:=0
|| _ret:=0
?};

{? _czyRH
|| _podstawa:=LICZRHS.Wylicz(,_metoda)$2;
:: Powołanie DoList tylko dla rachunków, bo dla list już jest. Wypełnienie tylko przy pierwszej podstawie (753).
:: Użyte zmienne globalne wypełniane na początku naliczania 753 (podst. em. rent)
:: w wywoływanej tam formule (\skl_zlec_podst_sk/zlec_rh.fml) :
   exec('dekl_dolist','lista_plac');
   {? var_pres('DoList')<=0
   || DoList:=obj_new(@.CLASS.DoList)
   ?};
   {? _rubryka=753
   || ZC.cntx_psh();
      P.cntx_psh();
      RH.ZLE().P();
      exec('skl_zlec_podst_sk','zlec_rh');
      P.cntx_pop();
      ZC.cntx_pop()
   ?};
:: 261 - Personel: ewidencja i rozliczanie oddelegowania do pracy za granicą
   {? PAR_SKID.get(261)<>'T'
   || {? _retObj
      || _ret.podstawa:=_podstawa$2
      || _ret:=_podstawa$2
      ?};
      return(_ret)
   ?};

   ZC_INFO.cntx_psh();
   S_ZUS.cntx_psh();
   _pracownicze:=(2+RH.ZC_INFO().TTUB().KOD='01');
   S_ZUS.cntx_pop();
   ZC_INFO.cntx_pop();

   {? _pracownicze
   || _diety:=DoList.k[37];
      _zwrotyKierowcy:=DoList.k[38];
      _SUMY:=exec('sum_atr_o','oddelegowanie','90108,90110');
::    90108 Kwota diet kierowcy (pakiet mobilności)
      {? _SUMY.find_key(90108)
      || _diety+=_SUMY.SUM
      ?};
::    90110 Zwroty kierowcy (pakiet mobilności)
      {? _SUMY.find_key(90110)
      || _zwrotyKierowcy+=_SUMY.SUM
      ?};
      obj_del(_SUMY)
   || _diety:=DoList.k[60];
      _zwrotyKierowcy:=DoList.k[61]
   ?};
   _funkcjeLZK:="{? _a<>0 || FUNKCJE.ZK(_a,,_b$2) ?}"

|| _podstawa:=LICZ.Wylicz(,_metoda)$2;
   _podstawa-={? _par.POM_ATR<>0 || FUNKCJE.L_SYS(_par.POM_ATR) ?};
   _podstawa-=FUNKCJE.L(7161,7162);
:: 261 - Personel: ewidencja i rozliczanie oddelegowania do pracy za granicą
   {? PAR_SKID.get(261)<>'T'
   || {? _retObj
      || _ret.podstawa:=_podstawa$2
      || _ret:=_podstawa$2
      ?};
      return(_ret)
   ?};
:: 90108 Kwota diet kierowcy (pakiet mobilności)
   _diety:=FUNKCJE.L_SYS(90108)+FUNKCJE.LU_SYS(90108)+DoList.k[37];
:: 90110 Zwroty kierowcy (pakiet mobilności)
   _zwrotyKierowcy:=FUNKCJE.L_SYS(90110)+FUNKCJE.LU_SYS(90110)+DoList.k[38];
   _funkcjeLZK:="{? _a<>0 || FUNKCJE.LK(_a,,_b$2) ?}"
?};
{? _bOdd<>'T'
|| _diety+=exec('zlicz_diety','oddelegowanie',,,,'W','W',,,1)
?};

{? _zwrotyKierowcy=0 & _podstawa<=0
|| {? _retObj
   || _ret.podstawa:=_podstawa$2
   || _ret:=_podstawa$2
   ?};
   return(_ret)
?};

:: Numery rubryk z odliczonymi dietami i doliczonymi zwrotami:
_rubPomPdst:=_rubPowPdst:=0;
:: 753 - Podst. emer. i rent.:
::  9016 Kwota diet pomniejszająca podstawę emeryt. i rent. --> 7191 - OZ: Pom. p. em.i re.
::  901111 Kwota zwrotów powiększająca podst. emeryt. i rent. --> 7245 - OZ: Pow. p. em.i re.
{? _rubryka=753
|| _rubPomPdst:=__RUB.sys_kod(9016);
   _rubPowPdst:=__RUB.sys_kod(901111)
:: 754 - Podst. chor. i wyp.
::  9017 Kwota diet pomniejszająca podstawę chor. i wyp. --> 7192 - OZ: Pom. p. ch.i wy.
::  901112 Kwota zwrotów powiększająca podst. chor. i wyp. --> 7246 - OZ: Pow. p. ch.i wy.
|? _rubryka=754
|| _rubPomPdst:=__RUB.sys_kod(9017);
   _rubPowPdst:=__RUB.sys_kod(901112)
:: 791 - Podst. ub. zdrow.
::  9018 Kwota diet pomniejszająca podstawę ubezp. zdrowot. --> 7193 - OZ: Pom. p. ub. zdr.
::  901113 Kwota zwrotów powiększająca podst. ubezp. zdrowot. --> 7247   OZ: Pow. p. ub. zdr.
|? _rubryka=791
|| _rubPomPdst:=__RUB.sys_kod(9018);
   _rubPowPdst:=__RUB.sys_kod(901113)
:: 981 - Podst. FP i FGŚP
::  9019 Kwota diet pomniejszająca podstawę FP i FGŚP --> 7194 - OZ: Pom. p. FP i FG.
::  901114 Kwota zwrotów powiększająca podst. FP i FGŚP --> 7248   OZ: Pow. p. FP i FG.
|? _rubryka=981
|| _rubPomPdst:=__RUB.sys_kod(9019);
   _rubPowPdst:=__RUB.sys_kod(901114)
:: 7087 - Podstawa PPK
::  90101 Kwota diet pomniejszająca podstawę PPK --> 7196 - OZ: Pom. podst. PPK (dla ppk FUNKCJE.LK wołane
::   w \licz_pod/ppk.fml)
::  901115 Kwota zwrotów powiększająca podst. PPK --> 7249   OZ: Pow. podst. PPK
|? _rubryka=7087
|| _rubPomPdst:=__RUB.sys_kod(90101);
   _rubPowPdst:=__RUB.sys_kod(901115)
?};
:: Zapamiętana podstawa przed pomniejszaniem/powiększaniem. Na koniec zgodnie z parametrem wejściowym formuły
:: zwracana jest podstawa po pomniejszeniu lub przed, ale pomniejszona o diety podstawa jest potrzebna
:: do wyliczeń powiększenia o koszty kierowcy.
_pdstPrzedPom:=_podstawa;

:: Czy w ogóle są jakieś diety:
{? _diety
|| {? var_pres('PRGWYN',KST)<0
   || RAPLS.msg('','','',
         'Brak pola "Prognozowane miesięczne" w definicji stałych obszaru "Płace".'@,
         'Kwota diet (składnik 7074) nie będzie uwzględniona w obliczeniach.'@);
      _funkcjeLZK(_rubPomPdst,0);
      {? _retObj
      || _ret.podstawa:=_podstawa$2
      || _ret:=_podstawa$2
      ?};
      return(_ret)
   ?};
   {? KST.PRGWYN=0
   || RAPLS.msg(
         '','','',
         'Nie wprowadzono wartości w polu "Prognozowane miesięczne" w stałych obszaru "Płace".'@,
         'Należy uzupełnić brakującą informację i powtórzyć obliczenia.'@)
::    Suma podstaw, diety już odliczone i zwroty, które już powiększyły (na innych listach płac):
   || _sumaPodst:=_dieOdli:=_zwrotyKierDoliczone:=0;
      {? _czyRH
      || {? _pracownicze
         || _SUMY:=exec('sum_rub_o','oddelegowanie','%1,%2,%3'[$_rubryka,$_rubPomPdst,$_rubPowPdst]);
            {? _SUMY.find_key(_rubryka)
            || _sumaPodst+=_SUMY.SUM
            ?};
            {? _SUMY.find_key(_rubPomPdst)
            || _dieOdli+=_SUMY.SUM
            ?};
            {? _SUMY.find_key(_rubPowPdst)
            || _zwrotyKierDoliczone+=_SUMY.SUM
            ?};
            obj_del(_SUMY);
            {? _rubryka=791
            || _SUMY:=exec('sum_rub_o','oddelegowanie','765,766,767');
               {! _ii:=765..767
               |! {? _SUMY.find_key(_ii)
                  || _sumaPodst+=_SUMY.SUM
                  ?}
               !};
               obj_del(_SUMY)
            ?}
         ?}

      || _sumaPodst:=FUNKCJE.LU(_rubryka);
         {? _rubryka=791
         || _sumaPodst+=FUNKCJE.LU(765,767)
         ?};
         _dieOdli:=FUNKCJE.LU(_rubPomPdst);
         _zwrotyKierDoliczone:=FUNKCJE.LU(_rubPowPdst)
      ?};

::    Doliczenie odpowiednich odliczonych diet oraz podstaw ze zleceń z tytułem 01.. (pracownik).
      {? _pracownicze
      || {? _rubryka=753
         || _sumaPodst+=DoList.k[1];
            _dieOdli+=DoList.k[25];
            _zwrotyKierDoliczone+=DoList.k[32]
         |? _rubryka=754
         || _sumaPodst+=DoList.k[3];
            _dieOdli+=DoList.k[26];
            _zwrotyKierDoliczone+=DoList.k[33]
         |? _rubryka=791
         || _sumaPodst+=DoList.k[20];
            _dieOdli+=DoList.k[27];
            _zwrotyKierDoliczone+=DoList.k[34]
         |? _rubryka=981
         || _sumaPodst+=DoList.k[24];
            _dieOdli+=DoList.k[28];
            _zwrotyKierDoliczone+=DoList.k[35]
         |? _rubryka=7087
         || _sumaPodst+=DoList.k[30];
            _dieOdli+=DoList.k[29];
            _zwrotyKierDoliczone+=DoList.k[36]
         ?}

::    Doliczenie odpowiednich odliczonych diet oraz podstaw ze zleceń z tytułem innym niż 01.
      || {? _rubryka=753
         || _sumaPodst+=DoList.k[47];
            _dieOdli+=DoList.k[49];
            _zwrotyKierDoliczone+=DoList.k[55]
         |? _rubryka=754
         || _sumaPodst+=DoList.k[70];
            _dieOdli+=DoList.k[50];
            _zwrotyKierDoliczone+=DoList.k[56]
         |? _rubryka=791
         || _sumaPodst+=DoList.k[72];
            _dieOdli+=DoList.k[51];
            _zwrotyKierDoliczone+=DoList.k[57]
         |? _rubryka=981
         || _sumaPodst+=DoList.k[73];
            _dieOdli+=DoList.k[52];
            _zwrotyKierDoliczone+=DoList.k[58]
         |? _rubryka=7087
         || _sumaPodst+=DoList.k[54];
            _dieOdli+=DoList.k[53];
            _zwrotyKierDoliczone+=DoList.k[59]
         ?}
      ?};
      {? _czyRH
::       Odjęcie wartości z aktualnie liczonego rachunku:
      || _swojPodst:=FUNKCJE.Z(_rubryka);
         _sumaPodst-=_swojPodst;
         {? _rubryka=791 & _swojPodst
         || _sumaPodst-=FUNKCJE.Z(765,767)
         ?};
         {? _rubPomPdst<>0
         || _dieOdli-=FUNKCJE.Z(_rubPomPdst)
         ?};
         {? _rubPowPdst<>0
         || _zwrotyKierDoliczone-=FUNKCJE.Z(_rubPowPdst)
         ?}
      ?};

::    Do porównań z przeciętnym wynagrodzeniem pomniejszamy podstawę o warunkowo wchodzące do niej zwroty,
::    ponieważ w przepisach jest mowa o porównywaniu przychodu, a do niego zwroty nigdy nie wchodzą:
      _sumaPodst-=_zwrotyKierDoliczone;

      _dieDoOdl:=0;
::    Są jeszcze jakieś diety do odliczenia:
      {? _diety>_dieOdli
:: Odliczenie równowartości diet można stosować gdy przychód jest wyższy niż przeciętne wynagrodzenie.
:: Ponadto ustalona podstawa wymiaru składek na ubezpieczenia społeczne po obniżeniu o równowartość diet
:: za każdy dzień pobytu poza granicami kraju nie może być niższa od kwoty przeciętnego wynagrodzenia.
      || {? _rubryka=791
::       Sczególna obsługa dla 791 Podst. ub. zdrow. wartość diet pomniejszających podstawę jest pobierana ze składnika
::       7192 OZ: Pom. p. ch.i wy. (ER/WRT/XP/12.51/2307/0020) - wynagrodzenie chorobowe nie powinno wchodzić w skład
::       podstawy, która będzie później pomniejszana o wysokość diet.
::       9017 Kwota diet pomniejszająca podstawę chor. i wyp. --> 7192 - OZ: Pom. p. ch.i wy.
         || _dieDoOdl:=
               {? _czyRH
               || FUNKCJE.Z_SYS(9017)
               || FUNKCJE.L_SYS(9017)
               ?}
         || _dieDoOdl:=_diety-_dieOdli
         ?};
         {? ~_pomPdst & _retObj
         || _ret.diety:=_dieDoOdl$2
         ?};

         {? (_sumaPodst+_podstawa)>KST.PRGWYN
         || {? _rubryka<>791 & (_sumaPodst+_podstawa-_dieDoOdl)<KST.PRGWYN
            || _podstawaNew:=KST.PRGWYN-_sumaPodst;
               _dieDoOdl:=_podstawa-_podstawaNew;
               _podstawa:=_podstawaNew
::          Można odjąć całe diety od podstawy, lub jest to podstawa 791 (odejmujemy już obliczone 7192):
            || _podstawa-=_dieDoOdl
            ?};
            {? ~_retObj
            || _funkcjeLZK(_rubPomPdst,_dieDoOdl)
            || _ret.diety:=_dieDoOdl$2
            ?}
         || _dieDoOdl:=0;
            {? ~_retObj
            || _funkcjeLZK(_rubPomPdst,0)
            ?}
         ?}

      || {? ~_retObj
         || _funkcjeLZK(_rubPomPdst,0)
         ?}
      ?};

:: Powiększenie podstawy o zwroty kierowcy (jeśli podstawa mniejsza niż prognozowane przeciętne):
      {? _rubryka=791
::       Sczególna obsługa dla 791 Podst. ub. zdrow. - analogicznie jak dla pomniejszeń (ER/WRT/XP/12.51/2307/0020)
::       901112 Kwota zwrotów powiększająca podst. chor. i wyp.
      || _zwrotyDoDol:=
            {? _czyRH
            || FUNKCJE.Z_SYS(901112)
            || FUNKCJE.L_SYS(901112)
            ?}
      || _zwrotyDoDol:=_zwrotyKierowcy-_zwrotyKierDoliczone
      ?};

      _par601:=exec('get_par','#parametr',601,,1);
:: 601 - Personel: Pakiet mobilności - sposób obliczania podstawy do porównania z przeciętnym wynagrodzeniem.
::    D - w pierwszej kolejności pomniejszaj o diety
::    G - liczenie od globalnej kwoty przychodu
      _porownanie:=
         {? _par601='D'
         || _sumaPodst+_podstawa
         || _sumaPodst+_dieOdli+_podstawa+_dieDoOdl
         ?};
      {? _porownanie<=KST.PRGWYN | _rubryka=791
      || {? ~_retObj
         || _funkcjeLZK(_rubPowPdst,_zwrotyDoDol)
         || _ret.zwrotyDoDol:=_zwrotyDoDol
         ?};
         _podstawa+=_zwrotyDoDol

::    Były poprzednio jakieś zwroty doliczone do podstawy, a podstawa w ujęciu miesiące jest już większa niż przeciętne
::    należy teraz je odjąć te doliczniea od podstawy na obecnej liście:
      |? _zwrotyKierDoliczone>0
      || {? ~_retObj
         || _funkcjeLZK(_rubPowPdst,_zwrotyKierDoliczone*(-1))
         || _ret.zwrotyDoDol:=_zwrotyKierDoliczone*(-1)
         ?};
         _podstawa-=_zwrotyKierDoliczone

      || {? ~_retObj
         || _funkcjeLZK(_rubPowPdst,0)
         ?}
      ?}
   ?}
|| {? ~_retObj
   || _funkcjeLZK(_rubPomPdst,0);
      _funkcjeLZK(_rubPowPdst,0)
   ?}
?};

{? _retObj
|| _ret.podstawa:={? _pomPdst || _podstawa$2 || _pdstPrzedPom$2 ?}
|| _ret:={? _pomPdst || _podstawa$2 || _pdstPrzedPom$2 ?}
?};

_ret


\nocleg2podatek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Ustalenie kwoty za noclegi obniżającej podstawę podatku jeśli wystąpiło oddelegowanie do pracy za granicą.
::   WE:
::   WY: Kwota za noclegi obniżająca podstawę podatku.
::----------------------------------------------------------------------------------------------------------------------
{? PAR_SKID.get(261)='N' || return(0) ?};

_noclegRn:=0;
H_ODDR.cntx_psh();
H_ODDR.index('H_ODDRDN');
H_ODDR.prefix(exec('firma','ustawienia'),'N','T',);
:: Powinien być tylko jeden rekord typu NOCLEG='T'
{? H_ODDR.first()
|| R.cntx_psh();
   _noclegRn:=H_ODDR.R().RN;
   R.cntx_pop()
?};
H_ODDR.cntx_pop();
{? ~_noclegRn
|| return(0)
?};

_nocleg:=FUNKCJE.L(_noclegRn);
_ulga:=0;
_data:=date(O.R,O.M,0);

P_IPOD.index('OD');
P_IPOD.prefix(P.ref());
:: Wartość z kosztów noclegów obniżająca podstawę opodatkowania jeśli podstawowe koszty uzyskania .
{? _nocleg
   &
   {? P_IPOD.find_le(_data) || P_IPOD.KU='N' || 1 ?}
|| {? KST.LKZ=0
   || RAPLS.msg(
         '','','',
         'Nie wprowadzono wartości w polu "Limit kosztów zakwaterowania" w stałych obszaru "Płace".'@,
         exec('retry_msg','lista_licz')
      )
   || _ulga:={? _nocleg>KST.LKZ || KST.LKZ || _nocleg ?}
   ?}
|| _nocleg:=0
?};
FUNKCJE.LK(7076,,_ulga);
_nocleg


\dieta2podatek_OLD
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Ustalenie wartości diety obniżającej podstawę podatku jeśli wystąpiło oddelegowanie do pracy za granicą.
::   WE: [_a][STRING] - rodzaj obliczanej diety:
::                         'K' - OZ: Diety pom. kraj (7077) [domyślnie]
::                         'Z' - OZ: Diety pom. zag. (7166)
::   WY: Kwota z diet obniżająca podstawę podatku.
::----------------------------------------------------------------------------------------------------------------------
{? PAR_SKID.get(261)='N' || return(0) ?};
_pod:={? var_pres('_a')=type_of('') & -_a='z'
      || 'N'
      || 'T'
      ?};

:: Jeśli na liście jest "Przych. opodat. zag." i nie ma przychodu...
{? FUNKCJE.L(7081) & ~FUNKCJE.L(780)
:: Wyzeruj "P.służb.bez podatku"
|| FUNKCJE.LK(7078,,0)
?};

_dieta:=exec('zlicz_diety','oddelegowanie',,,,,,'T,N',_pod);
:: Wartość z diet obniżająca podstawę opodatkowania.
{? _dieta
|| {? KST.PDBP=0
   || RAPLS.msg(
         '','','',
         'Nie wprowadzono wartości w polu "Procent diet bez podatku" w stałych obszaru "Płace".'@,
         exec('retry_msg','lista_licz')
      )
   || _dieta*=KST.PDBP/100
   ?}
?};
_dieta$2


\dieta2podatek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Ustalenie wartości diety obniżającej podstawę podatku jeśli wystąpiło oddelegowanie do pracy za granicą.
::   WE: _a [INTEGER] - numer atrybutu do zliczania już potrąconych diet
::      [_b][INTEGER] - odliczaj ZP 0/1. Domyślnie 0 - nie odliczaj
::      [_c][DATE]    - data porównania z parametrem XXX - [domyślnie O.D]
::      [_d][STRING]  - T/N czy pomijać kartotekę oddelegowań [O.B_ODD]
::      [_e][INTEGER] - czy obliczenia dla rachunku? [0*/1]
:: lub, dla obliczania "po staremu" (7077)
::   WE: [_a][STRING] - rodzaj obliczanej diety:
::                         'K' - OZ: Diety pom. kraj (7077) [domyślnie]
::                         'Z' - OZ: Diety pom. zag. (7166)
::   WY: Kwota z diet obniżająca podstawę podatku.
::----------------------------------------------------------------------------------------------------------------------
{? PAR_SKID.get(261)='N' || return(0) ?};
_d0:=date(0,0,0);
_dataPorow:={? var_pres('_c')=type_of(_d0) || _c || O.D ?};
_dataParam:=exec('get_par_date','parametr',397);
_rachunek:={? var_pres('_e')=type_of(0) || _e || 0 ?};
{? var_pres('_a')<>type_of(0)
|| _old:=
      {? _dataParam<>_d0 & _dataPorow>=_dataParam
      || 0
      |? var_pres('_a')=type_of('')
      || exec('dieta2podatek_OLD','oddelegowanie',_a)
      || exec('dieta2podatek_OLD','oddelegowanie')
      ?};
   return(_old)
?};
{? _dataParam=_d0 | _dataPorow<_dataParam
|| return(0)
?};
_atrDiet:=_a;
_odliczZp:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_bOdd:={? var_pres('_d')=type_of('') || _d || O.B_ODD ?};
_pracownicze:=1;

{? _rachunek
|| ZC_INFO.cntx_psh();
   S_ZUS.cntx_psh();
   _pracownicze:=(2+RH.ZC_INFO().TTUB().KOD='01');
   _fc:=(ZC_INFO.FC='T');
   S_ZUS.cntx_pop();
   ZC_INFO.cntx_pop()
?};

{? _rachunek & _pracownicze
|| _fakPrzychZlis:=_zList90102:=_zpZlis:=_zList90109:=_dietyPomPzList:=0;
   _SUMY:=exec('sum_rub_o','oddelegowanie','7200','P');
   {? _SUMY.find_key(7200)
   || _fakPrzychZlis+=_SUMY.SUM
   ?};
   obj_del(_SUMY);
   _SUMY:=exec('sum_atr_o','oddelegowanie','%1,90102,9022,90109'[$_atrDiet],'P');
:: 90103: Kwota diet obniżająca przychód (7197. OZ: Diety pomn. prz.)
:: lub 9068: 'Kwota diet pomniejszająca przychód (ZDR)
   {? _SUMY.find_key(_atrDiet)
   || _dietyPomPzList+=_SUMY.SUM
   ?};
:: 90102: Rubryki nie stanowiące przychodu (Oddelegowania do pracy za granicą)
   {? _SUMY.find_key(90102)
   || _zList90102+=_SUMY.SUM
   ?};
:: 9022 ZP: przychód podlegający zwolnieniu
   {? _SUMY.find_key(9022)
   || _zpZlis+=_SUMY.SUM
   ?};
:: 90109 Kwota diet kierowcy pomniej. przychód (pak. mob.) (7240   OZ: Diety m. p. prz.)
   {? _SUMY.find_key(90109)
   || _zList90109+=_SUMY.SUM
   ?};
   obj_del(_SUMY)
?};

{? _rachunek
|| {? _pracownicze
   || _przychod:=
::    7200: Przychód do wyliczeń
         exec('zlicz_z_rh','zlec_rh',7200,0,'01',0,,RH.ref(),'P')+FUNKCJE.Z(7200)+_fakPrzychZlis
::    90102: Rubryki nie stanowiące przychodu (Oddelegowania do pracy za granicą)
::    Pomniejszenie przychodu o zasiłki spowodowane jest zapisem w art. 21 pkt 20 Ustawa z dnia 26.07.1991 r.
::    o podatku dochodowym od osób fizycznych stan prawny na dzień: 1.07.2022 r.
         -exec('zlicz_z_rh','zlec_rh',90102,1,'01',0,,RH.ref(),'P')-FUNKCJE.Z_SYS(90102)-_zList90102;
      {? _odliczZp
      || _przychod+=
::    9022 ZP: przychód podlegający zwolnieniu
         -exec('zlicz_z_rh','zlec_rh',9022,1,'01',0,,RH.ref(),'P')-FUNKCJE.Z_SYS(9022)-_zpZlis
      ?}
   || _przychod:=
::    7200: Przychód do wyliczeń
         exec('zlicz_z_rh','zlec_rh',7200,0,'01',1,'1',RH.ref(),'P')+FUNKCJE.Z(7200)
::    90102: Rubryki nie stanowiące przychodu (Oddelegowania do pracy za granicą)
::    Pomniejszenie przychodu o zasiłki spowodowane jest zapisem w art. 21 pkt 20 Ustawa z dnia 26.07.1991 r.
::    o podatku dochodowym od osób fizycznych stan prawny na dzień: 1.07.2022 r.
         -exec('zlicz_z_rh','zlec_rh',90102,1,'01',1,'1',RH.ref(),'P')-FUNKCJE.Z_SYS(90102);
      {? _odliczZp
      || _przychod+=
::    9022 ZP: przychód podlegający zwolnieniu
         -exec('zlicz_z_rh','zlec_rh',9022,1,'01',1,'1',RH.ref(),'P')-FUNKCJE.Z_SYS(9022)
      ?}
   ?}
|| _przychod:=
::    7200: Przychód do wyliczeń
      FUNKCJE.L(7200)+FUNKCJE.LP(7200)+DoList.k[39]
::    90102: Rubryki nie stanowiące przychodu (Oddelegowania do pracy za granicą)
::    Pomniejszenie przychodu o zasiłki spowodowane jest zapisem w art. 21 pkt 20 Ustawa z dnia 26.07.1991 r.
::    o podatku dochodowym od osób fizycznych stan prawny na dzień: 1.07.2022 r.
      -FUNKCJE.L_SYS(90102)-FUNKCJE.LP_SYS(90102)-DoList.k[40];
   {? _odliczZp
   || _przychod+=
::    9022 ZP: przychód podlegający zwolnieniu
      -FUNKCJE.L_SYS(9022)-FUNKCJE.LP_SYS(9022)-DoList.k[23]
   ?}
?};
{? _przychod<=0 || return(0) ?};

:: Diety zliczamy i 30% diet odliczamy od przychodu tylko na listach płac.
_dietyDoPotr:=_diety:=_dietyMobilne:=0;

{? _atrDiet=90103 | _atrDiet=9068
:: 23.25_PMO01: Kierowcy nie mają już odliczanych 30% diet, a mają osobny składnik na diety pomniejszające przychód
:: (kwota ręcznie wprowadzana na listę płac) - 7240 OZ: Diety m. p. prz.
:: Ustawa z dnia 28 lipca 2023 r. o delegowaniu kierowców w transporcie drogowym
:: 90109 Kwota diet kierowcy pomniej. przychód (pak. mob.) (23.25_PMO01)
|| {? _rachunek
   || _dietyMobilne:=
         {? _pracownicze
         || exec('zlicz_z_rh','zlec_rh',90109,1,'01',0,,RH.ref(),'P')+FUNKCJE.Z_SYS(90109)+_zList90109
         || exec('zlicz_z_rh','zlec_rh',90109,1,'01',1,'1',RH.ref(),'P')+FUNKCJE.Z_SYS(90109)
         ?}
   || _dietyMobilne:=FUNKCJE.L_SYS(90109)+FUNKCJE.LP_SYS(90109)+DoList.k[41]
   ?};
   _pod:='T'
|| _pod:='N'
?};

{? _bOdd<>'T' & ~_rachunek
|| _diety+=exec('zlicz_diety','oddelegowanie',,,,{? O.KRAJE=null() || 'W' || ~~ ?},,'T,N',_pod,1)
:: ER/WRT/XP/22.26/2312/0007 - Błędnie naliczony składnik 7197 dla pracownika oddelegowanego,
:: który płaci podatki za granicą i jest to jego kolejna lista
:: Diety zliczami w kontekście kraju - również wykorzystane diety zostaną zliczone wg. kraju listy płac
::   {? _atrDiet=90103 | _atrDiet=9068
::   || _diety+=FUNKCJE.LP_SYS(90107)
::   ?}
?};

{? _diety | _dietyMobilne
|| {? var_pres('PDBP',KST)<0
   || RAPLS.msg('','','',
         'Brak pola "Procent diet bez podatku" w definicji stałych obszaru "Płace".'@,
         'Kwota diet (składnik 7074) nie będzie uwzględniona w obliczeniach.'@);
      return(0)
   ?};
   {? KST.PDBP=0
   || RAPLS.msg(
         '','','',
         'Nie wprowadzono wartości w polu "Procent diet bez podatku" w stałych obszaru "Płace".'@,
         'Należy uzupełnić brakującą informację i powtórzyć obliczenia.'@);
      return(0)
   ?};

:: Procent (30%) wszystkich diet z całego miesiąca:
   _prWszDiet:=(_diety*KST.PDBP/100)$2;
:: 90109 Kwota diet kierowcy pomniej. przychód (pak. mob.) (23.25_PMO01):
   _prWszDiet+=_dietyMobilne;

:: Diety, które zostały już potrącone w miesiącu
:: 90103: Kwota diet obniżająca przychód (7197. OZ: Diety pomn. prz.)
:: lub 9068: 'Kwota diet pomniejszająca przychód (ZDR)
   {? _rachunek
   || _potrDiety:=
         {? _pracownicze
         || exec('zlicz_z_rh','zlec_rh',_atrDiet,1,'01',0,,RH.ref(),'P')+_dietyPomPzList
         || exec('zlicz_z_rh','zlec_rh',_atrDiet,1,'01',1,'1',RH.ref(),'P')
         ?}
   || {? O.KRAJE=null()
      || _potrDiety:=FUNKCJE.LP_SYS(_atrDiet)+DoList.k[42]
      || _potrDiety:=exec('wartosci_listy','lista_licz',_atrDiet,O.RP,O.MP,'P',,,O.KRAJE)
      ?}
   ?};

:: Diety, które zostały do potrącenia:
   _zostaloDoPotr:=_prWszDiet-_potrDiety;

   {? _przychod>_zostaloDoPotr
   || _dietyDoPotr:=_zostaloDoPotr
   || _dietyDoPotr:=_przychod
   ?}
?};

_dietyDoPotr$2


\przychod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Zapisanie przychodu do właściwej rubryki ze względu na kraj opodatkowania podczas oddelegowania za granicę.
::   WE: _a [INTERER] - Kwota przychodu
::   WY: Kwota przychodu do rozliczenia podatku w Polsce
::----------------------------------------------------------------------------------------------------------------------
_przychod:=_a;

_przychod


\h_odde_b_zus
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Prezentacja oddelegowań bez ZUS pracownika
::   WE: [_a][_P] - wskazanie na pracownika, domyślnie P.ref
::       [_b][INTEGER] - czy prezentować zebrane dane? domyślnie: 1 -tak
::       [_c][INTEGER] - czy zbierać jedynie dane dot. oddelegowań bez ZUS? domyślnie: 1 - tak
::       [_d][DATE]    - dolne ograniczenie badanego okresu, domyślnie brak
::       [_e][DATE]    - górne ograniczenie badanego okresu, domyślnie brak
::       [_f][INTEGER] - czy zbierać dane w kontekście osoby w firmie? domyślnie: 0 - w kontekście pracownika
::   WY: _TAB - tabela z zebranymi danymi
::----------------------------------------------------------------------------------------------------------------------
_prac:=P.ref();
{? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=P
|| _prac:=_a
|? var_pres('_a')=type_of('')
|| P.cntx_psh();
   {? P.seek(_a,'pracowni',1)
   || _prac:=P.ref()
   ?};
   P.cntx_pop()
?};
_show:={? var_pres('_b')=type_of(0) || _b || 1 ?};
_bZus:={? var_pres('_c')=type_of(0) || _c || 1 ?};
_d0:=date(0,0,0);
_tOd:={? var_pres('_d')=type_of(_d0) || _d || _d0 ?};
_tDo:={? var_pres('_e')=type_of(_d0) || _e || _d0 ?};
_dlaOsoby:={? var_pres('_f')=type_of(0) || _f || 0 ?};
_osoba:=null();
{? _dlaOsoby
|| P.cntx_psh();
   {? P.seek(_prac,,1)
   || _osoba:=P.OSOBA
   ?};
   P.cntx_pop()
?};
_firma:=exec('firma','ustawienia');

H_ODDE.cntx_psh();
H_ODDE.use('h_oddet');
_TAB:=sql('
   select H_ODDE.O_OD, H_ODDE.O_DO, KRAJE.NAZ, H_ODDA.NAZWA, H_ODDA.MIASTO, H_ODDE.ZAST, H_ODDE.ZAKW, H_ODDE.POD,
          H_ODDE.ZUS, H_ODDE.POD_M, H_ODDE.REFERENCE as REF, H_ODDE.KRAJ as KRAJ
   from H_ODDE
   join H using(H_ODDE.H, H.REFERENCE)
   join P using(H.P, P.REFERENCE)
   join KRAJE using(H_ODDE.KRAJ, KRAJE.REFERENCE)
   left join H_ODDA using(H_ODDE.M_PRAC, H_ODDA.REFERENCE)
   where P.FIRMA=:_d '+
   {? _osoba || 'and P.OSOBA=:_e ' || 'and H.P=:_a ' ?}+
   {? _bZus || 'and H_ODDE.ZUS=\'N\' ' || '' ?}+
   {? _tOd<>_d0 || 'and H_ODDE.O_DO>=to_date(:_b) ' || '' ?}+
   {? _tDo<>_d0 || 'and H_ODDE.O_OD<=to_date(:_c) ' || '' ?}+'
   order by H_ODDE.O_OD, H_ODDE.O_DO
   '
   ,_prac,_tOd,_tDo,_firma,_osoba);
H_ODDE.cntx_pop();
{? _show
:: Jeśli zebrano dane, budowa okienka wertowania:
|| {? _TAB.first()
   || _wer:=_TAB.mk_sel('Oddelegowania do pracy za granicą%1'@[{? _bZus || ' bez obliczania składek ZUS'@ || '' ?}],,,
            '#h_odde_b_zus',,,,,'U');
      _TAB.win_fld(_wer,,'O_OD',,,10,,,'Data od'@,,'Data rozpoczęcia odddelegowania do pracy za granicą'@);
      _TAB.win_fld(_wer,,'O_DO',,,10,,,'Data do'@,,'Data zakończenia oddelegowania do pracy za granicą'@);
      _TAB.win_fld(_wer,,'NAZ',,,20,,,'Kraj oddelegowania'@,,'Kraj oddelegowania do pracy za granicą'@);
      _TAB.win_fld(_wer,,'NAZWA',,,25,,,'Nazwa firmy'@,,'Nazwa firmy oddelegowania do pracy za granicą'@);
      _TAB.win_fld(_wer,,'MIASTO',,,25,,,'Miejscowość'@,,'Miejscowość firmy oddelegowania do pracy za granicą'@);
      _TAB.win_fld(_wer,,'ZAST',,,10,,,'Zastępstwo'@,,'Oddelegowanie do pracy za granicą na zastępstwo [T/N]'@,2,,
         "'T'","'N'");
      _TAB.win_fld(_wer,,'ZAKW',,,10,,,'Noclegi'@,,'Rozliczenie noclegów: S-stawka,K-kwota,N-nie dotyczy'@);
      _TAB.win_fld(_wer,,'POD',,,10,,,'Podatek'@,,'Podatki rozliczane w Polsce [T/N]'@,2,,"'T'","'N'");
      {? ~_bZus
      || _TAB.win_fld(_wer,,'ZUS',,,10,,,'Składki ZUS'@,,'Składki ubezpieczeniowe rozliczane w Polsce [T/N]'@,2,,
            "'T'","'N'");
         _TAB.win_act(_wer,0,'Formuła','Legenda'@,,'Wyświetlenie okna legendy'@,
            "exec('legenda','color','H_ODDE#01')",,,,,,'L',,'target=window');
         _TAB.win_act(_wer,0,'Rekord'@,,,,"
            {? cur_tab().ZUS='N'
            || Color.fnd_kol('H_ODDE#01#02')
            || Color.fnd_kol('H_ODDE#01#01')
            ?}")
      ?};
      _TAB.win_sel(_wer);
      _red:=_TAB.mk_edit('Oddelegowanie do pracy za granicą%1'@[{? _bZus || ' bez obliczania składek ZUS'@ || '' ?}],
                         0,'#h_odde_b_zus_e',,,'html_maximized');
      _TAB.win_esep(_red,'Dane podstawowe'@);
      _TAB.win_efld(_red,,'O_OD',,,10,0,0,'Data od'@,0,'Data rozpoczęcia oddelegowania do pracy za granicą'@);
      _TAB.win_efld(_red,,'O_DO',,,10,0,0,'Data do'@,0,'Data zakończenia oddelegowania do pracy za granicą'@);
      _TAB.win_efld(_red,,'NAZ',,,30,0,0,'Kraj oddelegowania'@,0,'Kraj oddelegowania do pracy za granicą'@);
      _TAB.win_efld(_red,,'NAZWA',,,30,0,0,'Miejsce pracy'@,0,'Miejsce, do którego pracownik jest oddelegowany'@);
      _TAB.win_efld(_red,,'MIASTO',,,30,0,1,'Miejscowość'@,0,'Adres: miejscowość'@);
      _TAB.win_esep(_red,'Dane do rozliczenia'@);
      _TAB.win_efld(_red,,'POD',,,31,0,0,'Podatek'@,0,'Podatki rozliczane w Polsce [T/N]'@,'check-box',
         'left_label=1,check_label="%1"'['Podatek rozliczany w Polsce'@],"'T'","'N'");
      _TAB.win_efld(_red,,'POD_M',,,38,3,0,'Sposób rozliczenia'@,0,'Metoda obliczania opodatkowania'@,'radio-buttons',
         'left_label=1','Metoda wyłączenia z progresją'@,"'W'",'Metoda odliczenia proporcjonalnego'@,"'O'",
         'Ograniczony obowiązek podatkowy'@,"'B'");
      _TAB.win_efld(_red,,'ZUS',,,38,0,0,'Składki ZUS'@,0,'Składki ubezpieczeniowe rozliczane w Polsce [T/N]'@,
         'check-box','left_label=1,check_label="%1"'['Składki ubezpieczeniowe rozliczane w Polsce'@],"'T'","'N'");
      _TAB.win_efld(_red,,'ZAKW',,,22,3,0,'Koszty noclegów'@,0,'Rozliczenie noclegów: S-stawka,K-kwota,N-nie dotyczy'@,
         'radio-buttons','left_label=1','Nie dotyczy'@,"'N'",'Stawka'@,"'S'",'Kwota'@,"'K'");
      _TAB.win_esep(_red,'Zastępstwo'@);
      _TAB.win_efld(_red,,'ZAST',,,3,0,0,'Zastępstwo'@,0,'Oddelegowanie do pracy za granicą na zastępstwo'@,
         'check-box','left_label=1,check_label="%1"'['Oddelegowanie na zastępstwo'@],"'T'","'N'");
      _TAB.win_edit(_red);
      _TAB.select()
   || FUN.info('Brak oddelegowań%1.'@[{? _bZus || ' bez ZUS'@ || '' ?}])
   ?}
?};

_TAB


\czy_odd_bzus
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Sprawdza czy na podaną datę podany pracownik przebywa na oddelegowaniu bez zus
::   WE: [_a][_P]      - wskazanie na pracownika, domyślnie P.ref
::       [_b][DATE]    - data kontroli, domyślnie dzisiejsza data [date()]
::       [_c][INTEGER] - czy zbierać jedynie dane dot. oddelegowań bez ZUS? domyślnie: 1 - tak
::       [_d][INTEGER] - typ zwracanych danych:
::                         0 (domyślnie) - tablica elementów nazwanych:
::                                          * st [INTEGER] - status 0/1 - nie przebywa/przebywa
::                                          * od [DATE]    - data początku oddelegowania
::                                          * do [DATE]    - data końca oddelegowania
::                         1             - liczba - status 0/1 - nie przebywa/przebywa
::   WY: _ret [OBJ/INTEGER] - w zależności od parametru _d
::----------------------------------------------------------------------------------------------------------------------
_ret:=obj_new('st','od','do');
_ret.st:=0;
_ret.od:=_ret.do:=date(0,0,0);

_prac:={? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=P || _a || P.ref() ?};
_dzis:=date();
_dt:={? var_pres('_b')=type_of(_dzis) || _b || _dzis ?};
_bZus:={? var_pres('_c')=type_of(0) || _c || 1 ?};
_retInt:={? var_pres('_d')=type_of(0) || _d || 0 ?};
:: Pobranie tabeli oddelegowań bez zus dla danego pracownika:
_TAB:=exec('h_odde_b_zus','oddelegowanie',_prac,0,_bZus);
:: Połączenie przylegających okresów oddelegowania:
exec('norm_odd_tab','oddelegowanie',_TAB);
{? _TAB.find_le(_dt)
|| {? _TAB.O_DO>=_dt
   || _ret.od:=_TAB.O_OD;
      _ret.do:=_TAB.O_DO;
      _ret.st:=1
   ?}
?};

{? _retInt
|| _tmp:=_ret.st;
   obj_del(_ret);
   _ret:=_tmp
?};

_ret


\p_info_wer_oddbz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Obsługa akcji "Oddelegowania bez ZUS" w okienku WER tabeli P_INFO
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
exec('h_odde_b_zus','oddelegowanie');

~~


\okr_odd_bzus
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Sprawdza czy w podanym okresie pracownik przebywa na oddelegowaniu bez zus
::   WE: [_a][_P]   - wskazanie na pracownika, domyślnie P.ref
::       [_b][DATE] - data od kontroli, domyślnie początek miesiąca [date(,,1)]
::       [_c][DATE] - data do kontroli, domyślnie koniec miesiąca [date(,,0)]
::       [_d][INTEGER] - czy kontrola z przerwami? [domyślnie 0]
::                       0 - kontrola bez przerw (oddelegowania muszą pokrywać cały badany okres, aby zwrócona była 1)
::                       1 - kontrola z dopuszczalnymi przerwami (w podanym okresie wystarczy 1 dzień
::                           oddelegowania, aby zwrócona była 1)
::   WY: _ret [INTEGER] - status 0 - nie przebywa, 1 - przebywa bez przerw, 2 - przebywa z przerwami
::----------------------------------------------------------------------------------------------------------------------
_ret:=0;
_cont:=1;

_prac:={? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=P || _a || P.ref() ?};
_dtOd:={? var_pres('_b')=type_of(date()) || _b || date(,,1) ?};
_dtDo:={? var_pres('_c')=type_of(date()) || _c || date(,,0) ?};
_przer:={? var_pres('_d')=type_of(0) || _d || 0 ?};

:: Pobranie tabeli oddelegowań bez zus dla danego pracownika:
_TAB:=exec('h_odde_b_zus','oddelegowanie',_prac,0);
{? _TAB.find_le(_dtOd)
|| {!
   |? _thisDo:=_TAB.O_DO;
      {? _thisDo>=_dtDo
      || _ret:=1
      || {? ~_TAB.next() | _thisDo+1<_TAB.O_OD
         || _cont:=0
         ?}
      ?};

      _ret=0 & _cont
   !}
?};
:: Dodatkowa kontrola przebywania z przerwami:
{? _przer & ~_ret
|| {? _TAB.find_le(_dtDo) & _TAB.O_DO>=_dtOd
   || _ret:=2
   ?}
?};

_ret


\norm_odd_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Normalizacja (połączenie zachodzących na siebie) okresów oddelegowania w tabeli tymczasowej.
::       Poprawność struktury tabeli w parametrze wejściowym nie jest weryfikowana. Kluczowe jest aby miała
::       pola O_OD i DO, oraz była posortowana rosnąco po polu dacie O_OD.
::   WE: _a [TAB] - tabela z oddelegowaniami
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>118
|| FUN.error('Błąd parametrów wejściowych'@);
   return(0)
?};
_d0:=date(0,0,0);

_TMP:=_a;
{? _TMP.first()
|| {!
   |? _od:=_TMP.O_OD;
      _do:=_TMP.O_DO;
      _ref:=_TMP.ref();
      {? _TMP.next()
      || {? _do=_d0 | _TMP.O_OD<=(_do+1)
         || _do:=_TMP.O_DO;
            _TMP.del();
            _TMP.seek(_ref);
            {? _TMP.O_DO<>_d0 & (_do=_d0 | _TMP.O_DO<_do)
            || _TMP.O_DO:=_do;
               _TMP.put()
            ?};
            1
         || 1
         ?}
      ?}
   !}
?};

~~


\sum_skl_bodd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Obliczenie sumy podanych składników dla podanych pracowniów z ewentualnym proporcjonalnym odliczeniem
::       okresów oddelegowania.
::   WE: _a [TABLE]  - tabela tymczasowa z pracownikami, dla ktorych maja byc przeprowadzone obliczenia z polami:
::                       'REF' (STRING[16])
::                       'ROK' (INTEGER)
::                       'MIESIAC' (INTEGER)
::       _b [STRING] - lista składników do sumowania (oddzielonych przecinkami, np. '765,766,767').
::      [_c][INTEGER]- czy odliczać proporcjonalnie okresy oddelegowania? domyślnie: 0-nie odliczać
::      [_d][STRING] - lista składników do odjęcia od sumy (oddzielonych przecinkami, np. '765,766,767').
::      [_e][STRING] - lista atrybutów do odjęcia od sumy (oddzielonych przecinkami, np. '1024,1025').
::      [_f][INTEGER]- 0/1 [domyślnie 0] Czy pomniejszczenie proporcjonalne w proporcji:
::                     (OZ: wyn. ZUS i pod.+OZ: wynagr. ZUS-OZ: Diety pom. zag.-OZ: Diety pom. kraj):Chorobowo-Wypadkowa
::   WY: _suma [REAL]- obliczona suma
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(SYSLOG) | var_pres('_b')<>type_of('')
|| FUN.emsg('Błąd parametrów wejściowych'@);
   return(0)
?};
_PRAC:=_a;
_skladniki:=spli_str(_b,',');
_bezOdd:={? var_pres('_c')=type_of(0) || _c || 0 ?};
_minSkl:={? var_pres('_d')=type_of('') || spli_str(_d,',') || null() ?};
_minAtr:={? var_pres('_e')=type_of('') || spli_str(_e,',') || null() ?};
_propOdd:={? var_pres('_f')=type_of(0) || _f || 0 ?};
_suma:=0.0;

:: Idę po pracownikach:
{? _PRAC.first()
|| exec('__RUB','object');
   exec('FUNKCJE','object');
   exec('__F_ZATR','object');
   O_P.cntx_psh();
   O_P.index('P_RMK');
   O.cntx_psh();
   P.cntx_psh();
   P.use('pracowni');
   {!
   |? {? P.seek(_PRAC.REF,,1)
      || O_P.prefix('T',P.ref(),_PRAC.ROK,_PRAC.MIESIAC,P.F_ZATR);
         {? _bezOdd
         || _poczM:=date(_PRAC.ROK,_PRAC.MIESIAC,1);
            _koniM:=date(_PRAC.ROK,_PRAC.MIESIAC,0);
            _dnMies:={? P.DZ<>date(0,0,0) & P.DZ<_koniM || P.DZ || _koniM ?}-{? P.DZA>_poczM || P.DZA || _poczM ?}+1
         ?};
::       Idę po listach pracownika:
         {? O_P.first()
         || {!
            |? O_P.O();
               FUNKCJE.OTWOLIST();
::             Sumuję podane składniki:
               {! _ii:=1 .. obj_len(_skladniki)
               |! _skl:=FUNKCJE.L(#_skladniki[_ii]);
::                Jeśli odliczać oddelegowania:
                  {? _bezOdd
                  || _dnOdd:=FUNKCJE.L(7080);
::                   Proporcjonalnie (wg. dni kalendarzowych) odejmuję część przypadającą na dni oddelegowania:
                     _skl-=_skl*_dnOdd/_dnMies
                  ?};
                  {? _propOdd
::                   Pomniejszczenie proporcjonalne w proporcji:
::                   (OZ: wyn. ZUS i pod.+OZ: wynagr. ZUS-OZ: Diety pom. zag.-OZ: Diety pom. kraj):Chorobowo-Wypadkowa
                  || _pChor:=FUNKCJE.L_SYS(562);
                     {? _pChor
                     || _skl-=_skl*(FUNKCJE.L(7159,7160)-FUNKCJE.L(7077)-FUNKCJE.L(7166))/_pChor
                     ?}
                  ?};
                  _suma+=_skl
               !};
::             Odjęcie podanych składników:
               {? type_of(_minSkl)=117
               || {! _ii:=1 .. obj_len(_minSkl)
                  |! _suma-=FUNKCJE.L(#_minSkl[_ii])
                  !}
               ?};
::             Odjęcie podanych atrybutów:
               {? type_of(_minAtr)=117
               || {! _ii:=1 .. obj_len(_minAtr)
                  |! _suma-=FUNKCJE.L_SYS(#_minAtr[_ii])
                  !}
               ?};

               O_P.next()
            !}
         ?}
      ?};

      _PRAC.next()
   !};
   P.cntx_pop();
   O.cntx_pop();
   FUNKCJE.OTWOLIST();
   O_P.cntx_pop()
?};
obj_del(_skladniki);
{? type_of(_minSkl)=117 || obj_del(_minSkl) ?};
{? type_of(_minAtr)=117 || obj_del(_minAtr) ?};

_suma


\h_odde_pod_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Formuła po edycji pola POD w tabeli H_ODDE.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('acces2fld_h_odde','oddelegowanie',cur_tab(),cur_win(),1,'POD');
1


\czy_osoba_odd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Sprawdza czy na podaną datę podana osoba (wszyscy z jej pracowników) przebywa na oddelegowaniu
::   WE: [_a][_P]      - wskazanie na osobę, domyślnie OSOBA.ref
::       [_b][DATE]    - data kontroli, domyślnie dzisiejsza data [date()]
::       [_c][INTEGER] - czy zbierać jedynie dane dot. oddelegowań bez ZUS? domyślnie: 1 - tak
::   WY: _ret [INTEGER]- status 0/1 - nie przebywa/przebywa
::----------------------------------------------------------------------------------------------------------------------
_osoba:={? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=OSOBA || _a || OSOBA.ref() ?};
_dzis:=date();
_dt:={? var_pres('_b')=type_of(_dzis) || _b || _dzis ?};
_bZus:={? var_pres('_c')=type_of(0) || _c || 1 ?};
_ret:=0;

P.cntx_psh();
P.use('pracowni');
P.index('OSOZATR');
P.prefix(exec('firma','ustawienia'),_osoba,'T');
{? P.first()
|| {!
   |? _ret:=exec('czy_odd_bzus','oddelegowanie',P.ref(),_dt,1,1);

      _ret & P.next()
   !}
?};
P.cntx_pop();

_ret


\h_odde_prop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Przelicza proporcjonalnie podaną kwotę zgodnie z zapisami oddelegowań w H_ODDE
::   WE:  _a [REAL]    - kwota do proporcjonalnego przeliczenia
::       [_b][_P]      - wskazanie na pracownika [domyślnie P.ref()]
::       [_c][DATE]    - data od [domyślnie date(,,1)]
::       [_d][DATE]    - data do [domyślnie date(,,0)]
::       [_e][INTEGER] - rodzaj oddelegowania: [domyślnie 0]
::                          0 - ZUS i podatek w Polsce
::                          1 - ZUS w Polsce, podatek za granicą
::                          2 - podatek w Polsce, "ZUS" za granicą
::                          3 - bez Zus i bez podatku w Polsce
::                          4 - proporcja tylko dla kraju
::                          5 - ZUS bez podatku
::                          6 - bez ZUS i bez podatku
::                          7 - podatek bez ZUS
::       [_f][STRING]  - sposób naliczania: [domyślnie: 'R']
::                        'R' - dni robocze,
::                        'G' - godziny robocze,
::                        'K' - dni kalendarzowe.
::       [_g][_KRAJE]  - podział proporcjonalny dla kraju oddelegowania
::       [_h][STRING]- T/N czy pomijać kartotekę oddelegowań [O.B_ODD]
::   WY: _ret [REAL] - proporcjonalnie wyliczona kwota wg zapisów w H_ODDE
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(0)
|| FUN.error('Błąd parametru wejściowego.'@);
   return(0)
|| _kwota:=_a
?};
_pref:={? var_pres('_b')=type_of(null()) & _b<>null() & ref_tab(_b)=P || _b || P.ref() ?};
_d0:=date(0,0,0);
_start:={? var_pres('_c')=type_of(_d0) || _c || date(,,1) ?};
_stop:={? var_pres('_d')=type_of(_d0) || _d || date(,,0) ?};
_typs:={? var_pres('_e')=type_of(0) || _e || 0 ?};
_unit:={? var_pres('_f')=type_of('') & ',R,G,K,'*',%1,'[_f] || _f || 'R' ?};
_kraj:={? var_pres('_g')=type_of(null()) & _g<>null() & ref_tab(_g)=KRAJE || _g || O.KRAJE ?};
_bOdd:={? var_pres('_h')=type_of('') || _h || O.B_ODD ?};
_ret:=0;

:: 261 - Personel: ewidencja i rozliczanie oddelegowania do pracy za granicą
{? PAR_SKID.get(261)='T' & _bOdd<>'T'
|| H_ODDE.cntx_psh();
   H_ODDE.use('h_oddet');
   {? _kraj & _typs<>4
   || H_ODDE.index('PKOD');
      H_ODDE.prefix(_pref,_kraj)
   || H_ODDE.index('POD');
      H_ODDE.prefix(_pref)
   ?};
   _jest:=(H_ODDE.find_le(_start) & H_ODDE.O_DO>=_start) | (H_ODDE.find_ge(_start) & H_ODDE.O_OD<=_stop);
:: Czy w ogóle są jakieś oddelegowania:
   {? _jest
::    Zapamiętanie stanu kalendarza:
   || _kalSt:=obj_new('naz','rok');
      _kalSt.naz:=__KAL.nazwa;
      _kalSt.rok:=__KAL.rok;
::    Dla pracowników rozliczanych z godzin za pomocą Harmonogramów
::    kalendarz zamieniamy na standardowy (jak w \zasadnicza/!ppl_pll_nals.fml)
      {? (_start<P.DZA & P.DZA<=_stop & (__KAL.grafik(_stop)='T' | __KAL.p_kin(_stop)='T')) |
         (P.DZ<_stop & P.DZ>=_start & (__KAL.grafik(_start)='T' | __KAL.p_kin(_start)='T'))
      || __KAL.set_cal('standard',_start~1)
      |? P.KAL<>null
      || __KAL.set_cal(P.KAL,_start~1)
      || __KAL.set_cal('standard',_start~1)
      ?};
::    Liczba dni/godzin roboczych w oddelegowaniach z okresu:
      _rMc:=0;
::    Liczba dni/godzin roboczych oddelegowania:
      _rOdd:=0;
::    Warunek kwalifikacji oddelegowania do zliczania (wg parametru wejściowego):
      _cond:=
         {? _kraj
         || {? _typs=1
            || "H_ODDE.KRAJ=_a & H_ODDE.ZUS='T' & H_ODDE.POD<>'T'"
            |? _typs=2
            || "H_ODDE.KRAJ=_a & H_ODDE.ZUS<>'T' & H_ODDE.POD='T'"
            |? _typs=3
            || "H_ODDE.KRAJ=_a & H_ODDE.ZUS<>'T' & H_ODDE.POD<>'T'"
            |? _typs=0
            || "H_ODDE.KRAJ=_a & H_ODDE.ZUS='T' & H_ODDE.POD='T'"
            |? _typs=4
            || "H_ODDE.KRAJ=_a"
            |? _typs=5
            || "H_ODDE.KRAJ=_a & H_ODDE.ZUS='T'"
            |? _typs=6
            || "H_ODDE.KRAJ=_a & H_ODDE.ZUS='N'"
            |? _typs=7
            || "H_ODDE.KRAJ=_a & H_ODDE.POD='T'"
            ?}
         || {? _typs=1
            || "H_ODDE.ZUS='T' & H_ODDE.POD<>'T'"
            |? _typs=2
            || "H_ODDE.ZUS<>'T' & H_ODDE.POD='T'"
            |? _typs=3
            || "H_ODDE.ZUS<>'T' & H_ODDE.POD<>'T'"
            |? _typs=0
            || "H_ODDE.ZUS='T' & H_ODDE.POD='T'"
            |? _typs=4
            || "1"
            |? _typs=5
            || "H_ODDE.ZUS='T'"
            |? _typs=6
            || "H_ODDE.ZUS='N'"
            |? _typs=7
            || "H_ODDE.POD='T'"
            ?}
         ?};
::    Idę po oddelegowaniach i zliczam:
      {!
      |? _startOdd:={? H_ODDE.O_OD>_start || H_ODDE.O_OD || _start ?};
         _stopOdd:={? H_ODDE.O_DO<_stop || H_ODDE.O_DO || _stop ?};
         _wol:={? _unit='G'
               || __KAL.w_hours(_startOdd,_stopOdd)
               |? _unit='K'
               || _stopOdd-_startOdd+1
               || __KAL.w_days(_startOdd,_stopOdd)
               ?};
         _rMc+=_wol;
         {? _cond(_kraj) || _rOdd+=_wol ?};

         H_ODDE.next() & H_ODDE.O_OD<=_stop
      !};
::    Przywrócenie stanu kalendarza:
      __KAL.set_cal(_kalSt.naz,_kalSt.rok);
      obj_del(_kalSt);
::    Proporcjonalne pomniejszenie kwoty:
      {? _rMc>0
      || _ret:=_kwota/_rMc*_rOdd
      ?}
   ?};
   H_ODDE.cntx_pop()
?};

_ret$2


\h_odde_ciagl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Poprawa sąsiadujących oddelegowań w przebiegu (podczas poprawiania bieżącego), w celu zachowania ciągłości.
::   WE: [_a][_H_ODDE] - wskazanie na rekord oddelegowania [domyślnie: H_ODDE.ref()]
::       [_b][INTEGER} - (0/1) wyświetlanie komunikatów (1 lub brak) [domyślnie: 1]
::   WY: _txt [STRING] - komunikat dotyczący oddelgowań (brak jeżeli wszystko udało się utworzyć lub jeżeli _b=1).
::----------------------------------------------------------------------------------------------------------------------
_hodde:={? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=H_ODDE || _a || H_ODDE.ref() ?};
_komm:={? var_pres('_b')=type_of(0) || _b || 1 ?};
_txt:='';
H_ODDE.cntx_psh();
H_ODDE.index('HOD');
{? H_ODDE.seek(_hodde,,1)
|| H_ODDE.prefix(H_ODDE.H);
   _od:=H_ODDE.O_OD;
   _do:=H_ODDE.O_DO;
   {? H_ODDE.next()
   || {? H_ODDE.O_OD<>_do+1
      || H_ODDE.O_OD:=_do+1;
         {? H_ODDE.put(1)
         || _txt:=exec('h_odde_wer_ap','oddelegowanie',_komm)
         ?}
      ?};
      H_ODDE.prev()
   ?};
   {? H_ODDE.prev()
   || {? H_ODDE.O_DO<>_od-1
      || H_ODDE.O_DO:=_od-1;
         {? H_ODDE.put(1)
         || _txt:=exec('h_odde_wer_ap','oddelegowanie',_komm)
         ?}
      ?}
   ?}
?};
H_ODDE.cntx_pop();

_txt


\zus_prz_zag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Formuła płacowa dla składnika 7124 - OZ: ZUS od prz. zag.
::   WE: [_a][STRING]- T/N czy pomijać kartotekę oddelegowań [O.B_ODD]
::   WY: _ret [REAL] - kwota do składnika
::----------------------------------------------------------------------------------------------------------------------
_ret:=0;
_bOdd:={? var_pres('_a')=type_of('') || _a || O.B_ODD ?};
:: 261 - Personel: ewidencja i rozliczanie oddelegowania do pracy za granicą
{? PAR_SKID.get(261)='T' & _bOdd<>'T'
|| _pChor:=FUNKCJE.L_SYS(562)+FUNKCJE.L_SYS(9017);
   _wynZus:=FUNKCJE.L(7160);
   {? _pChor & _wynZus>0
   || _ret:=(FUNKCJE.L_SYS(512)+FUNKCJE.L_SYS(522)+FUNKCJE.L_SYS(532))*_wynZus/_pChor
   ?}
?};

_ret


\uzu_h_odde_tkrs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Uzupełnia pole Tabela kursów w oddelegowaniach, w których brakuje wypełnienia (np. po imporcie)
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_doPoprawy:=sql('select H_ODDE.REFERENCE from H_ODDE where H_ODDE.TKRS is null').size();
{? _doPoprawy
|| _zbiorczo:=FUN.ask('Czy wskazać jedną tabelę kursów dla wszystkich\noddelegowań (niezależnie od kraju)?'@);

   _TKRS:=tab_tmp(1,
:: Kraj oddelegowania (oryginalny typ: _KRAJE)
      'KRAJEREF','STRING[16]',,
      'KRAJENAZ','STRING[%1]'[$MS.fld_len(KRAJE,'NAZ')],'Kraj oddelegowania'@,
:: Wskazanie tabeli kursu walut (oryginalny typ: _SLO)
      'TKRS'    ,'STRING[16]' ,'Tabela kursów',
      'KOD','STRING[%1]'[$MS.fld_len(SLO,'KOD')],'Kod tabeli kursów'@,
      'TR','STRING[%1]'[$MS.fld_len(SLO,'TR')],'Nazwa tabeli kursów'@);

   {? _zbiorczo
   || _TKRS.KRAJENAZ:='Wszystkie kraje';
      _TKRS.add()
   || _KRAJE:=sql(
         'select distinct H_ODDE.KRAJ as REF, KRAJE.NAZ as NAZWA '
         'from H_ODDE join KRAJE using(H_ODDE.KRAJ, KRAJE.REFERENCE) '
         'where H_ODDE.TKRS is null');
      {? _KRAJE.first()
      || {!
         |? _TKRS.KRAJENAZ:=_KRAJE.NAZWA;
            _TKRS.KRAJEREF:=_KRAJE.REF;
            _TKRS.add();

            _KRAJE.next()
         !}
      ?};
      obj_del(_KRAJE)
   ?};

   _ws:=_TKRS.mk_sel('Ustal tabele kursów'@,,0,'#uzu_tkrs');
   _TKRS.win_fld(_ws,,'KRAJENAZ',,,,,1);
   _TKRS.win_fld(_ws,,'KOD');
   _TKRS.fld_fml('KOD','F3',
      "exec('wz_bank','wzorce');
       SLO.cntx_psh();
       SLO.win_sel('ONE_SEL');
       SLO.index('SL');
       SLO.prefix(SLU.ref);
       {? SLO.select()
       || _TKRS:=cur_tab();
          _TKRS.TKRS:=$SLO.ref();
          _TKRS.KOD:=SLO.KOD;
          _TKRS.TR:=SLO.TR;
          _TKRS.put()
       ?};
       SLO.cntx_pop()
      ");
   _TKRS.win_fld(_ws,,'TR',,,,,1);
   _TKRS.win_act(_ws,0,'Popraw');
   _TKRS.win_act(_ws,0,'Formuła','Uzupełnij oddelegowania'@,,,
      "_TKRS:=cur_tab();
       _ok:=1;
       {? _TKRS.find_tab(,'TKRS',,'=','')
       || {? ~FUN.ask('Nie wskazano tabeli kursów dla wszystkich wpisów.\nCzy kontynuować tylko dla wypełnionych?'@)
          || _ok:=0
          ?}
       ?};
       {? _ok
       || sel_exit()
       ?}
      ",,1);
   _TKRS.win_act(_ws,0,'Kolejność');
   _TKRS.win_sel(_ws);

   _poprawiono:=0;
   {? _TKRS.select()
   || SLO.cntx_psh();
      SLO.prefix();
      H_ODDE.cntx_psh();
      H_ODDE.prefix();
      H_ODDE.f_set(,,'H_ODDE.TKRS is null');
      {? H_ODDE.f_first()
      || {!
         |? {? {? _zbiorczo || _TKRS.first() || _TKRS.find_key($H_ODDE.KRAJ) ?} & SLO.seek(_TKRS.TKRS)
            || H_ODDE.TKRS:=SLO.ref();
               _poprawiono+=H_ODDE.put()
            ?};

            H_ODDE.f_next()
         !}
      ?};
      H_ODDE.f_clear();
      H_ODDE.cntx_pop();
      SLO.cntx_pop()
   ?};

   FUN.info('Rekordy poprawione: %1\nRekordy niepoprawione:%2'@[$_poprawiono,$(_doPoprawy-_poprawiono)])
|| FUN.info('Brak rekordów oddelegowań z niewypełnioną tabelą kursów.'@)
?}


\okr_odd_bzus_osoba
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Sprawdza czy w podanym okresie osoba (wszyscy zatrudnieni w podanym okresie praconicy osoby)
::       przebywa na oddelegowaniu bez zus bez przerw
::   WE: [_a][_OSOBA]   - wskazanie na osobę, domyślnie OSOBA.ref
::       [_b][DATE] - data od kontroli, domyślnie początek miesiąca [date(,,1)]
::       [_c][DATE] - data do kontroli, domyślnie koniec miesiąca [date(,,0)]
::   WY: _ret [INTEGER] - status 0/1 - nie przebywa/przebywa
::----------------------------------------------------------------------------------------------------------------------
_ret:=1;
_liczbaTestow:=0;

_osoba:={? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=OSOBA || _a || OSOBA.ref() ?};
_dtOd:={? var_pres('_b')=type_of(date()) || _b || date(,,1) ?};
_dtDo:={? var_pres('_c')=type_of(date()) || _c || date(,,0) ?};
_d0:=date(0,0,0);

P.cntx_psh();
P.index('OSOBA');
P.prefix(_osoba,exec('firma','ustawienia'));
{? P.first()
|| {!
   |? {? P.DZA<=_dtDo & (P.DZ=_d0 | P.DZ>=_dtOd)
      || _ret:=exec('okr_odd_bzus','oddelegowanie',P.ref(),
            {? P.DZA>_dtOd || P.DZA || _dtOd ?},{? P.DZ=_d0 | P.DZ>_dtDo || _dtDo || P.DZ ?});
         _liczbaTestow+=1
      ?};

      _ret=1 & P.next()
   !}
?};
P.cntx_pop();
:: ER/WRT/XP/22.26/2311/0040
:: Zabezpieczenie na wypadek gdyby pętla po pracownikach osoby nie weszła ani razu w pracownika.
:: Oznacza to wtedy, że pracownik nie jest zatrudniony w okresie w związku z czym nie przebywa na oddelegowaniu.
{? ~_liczbaTestow & _ret
|| _ret:=0
?};

_ret


\zlicz_diety
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Zlicza diety pracownika w okresie i kraju.
::   WE: [_a][_P]           - wskazanie na pracownika, domyślnie [P.ref]
::       [_b][DATE]         - data od kontroli, domyślnie z listy [date(O.R,O.M,1)]
::       [_c][DATE]         - data do kontroli, domyślnie z listy [date(O.R,O.M,0)]
::       [_d][_KRAJE/STRING]- wskazanie na kraj, domyślnie z listy [O.KRAJE] jeśli podano 'W' (wszystkie) to nie jest
::                            sprawdzana zgodność kraju listy (sumowane są wszystkie dostępne diety)
::       [_e][STRING]       - symbol listy, domyślnie bieżąca [O.LT], jeśli podano 'W' (wszystkie) to nie jest
::                            sprawdzana zgodność symbolu listy (sumowane są wszystkie dostępne diety)
::       [_f][STRING]       - dopuszczalne wartości H_ODDE.ZUS po przecinkach, domyślnie ['T'], pusty ciąg jest
::                            równoważny z zapisem 'T,N' czyli dopuszczalne będą obie wartości
::       [_g][STRING]       - dopuszczalne wartości H_ODDE.POD po przecinkach, domyślnie ['T,N'], pusty ciąg jest
::                            równoważny z zapisem 'T,N' czyli dopuszczalne będą obie wartości
::       [_h][INTEGER] - czy zbierać dane w kontekście osoby w firmie? domyślnie: 0 - w kontekście pracownika
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_prac:={? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=P || _a || P.ref() ?};
_start:={? var_pres('_b')=type_of(date()) || _b || date(O.R,O.M,1) ?};
_stop:={? var_pres('_c')=type_of(date()) || _c || date(O.R,O.M,0) ?};
_kraj:={? var_pres('_d')=type_of('') & _d='W'
       || null()
       |? var_pres('_d')=type_of(null()) & _d<>null() & ref_tab(_d)=KRAJE
       || _d
       || O.KRAJE
       ?};
_oLt:={? var_pres('_e')=type_of('') || _e || O.LT ?};
_zus:={? var_pres('_f')=type_of('')
      || {? ~+_f
         || 'T,N'
         || _f
         ?}
      || 'T'
      ?};
_pod:={? var_pres('_g')=type_of('')
      || {? ~+_g
         || 'T,N'
         || _g
         ?}
      || 'T,N'
      ?};
_dlaOsoby:={? var_pres('_h')=type_of(0) || _h || 0 ?};

_diety:=0;
H_ODDE.cntx_psh();
H_ODDE.use('h_oddet');
H_ODDE.index('POD');
{? _dlaOsoby
|| H_ODDE.prefix()
|| H_ODDE.prefix(_prac)
?};
:: Czy w ogóle są jakieś oddelegowania:
{? _dlaOsoby | (H_ODDE.find_le(_stop) & H_ODDE.O_DO>=_start)
:: Wszystkie oddelegowania pracownika w okresie:
|| _ODD:=exec('h_odde_b_zus','oddelegowanie',_prac,0,0,_start,_stop,_dlaOsoby);
:: Diety odliczamy kalendarzowo - oddelegowanie z ZUS może być w weekend - takie diety również odliczamy.
   H_ODDP.cntx_psh();
   H_ODDP.index('RODZ');
   WAL.cntx_psh();
:: Idę po znalezionych wcześniej oddelegowaniach pracownika (pomijam te bez ZUS):
   {? _ODD.first()
   || {!
      |? {? ',%1,'[-_zus]*',%1,'[-_ODD.ZUS] & ',%1,'[-_pod]*',%1,'[-_ODD.POD] & (_kraj=null() | _ODD.KRAJ=$_kraj)
         || {? H_ODDE.seek(_ODD.REF,,1)
            || H_ODDP.prefix(H_ODDE.ref,'Diety',);
::                Idę po rozliczeniach rodzaju "Diety" tego oddelegowania:
               {? H_ODDP.find_ge(_start)
               || {!
::                   Diety są już pomniejszane o nieobecności w momencie "stemplowania listą" (\oblicz/oddelegowanie)
::                   Bierzemy tylko diety z bieżącej listy:
                  |? {? -H_ODDP.LT=-_oLt | -_oLt='w'
                     || {? +H_ODDP.LT & H_ODDP.KW_PLN
                        || _diety+=H_ODDP.KW_PLN$2
                        || _kurs:=
                              {? H_ODDP.WAL().SYM<>'PLN'
                              || exec('kurs_waluty','oddelegowanie',WAL.SYM,H_ODDE.TKRS)
                              || 1
                              ?};
                           _diety+=H_ODDP.KW*_kurs$2
                        ?}
                     ?};

                     H_ODDP.next() & H_ODDP.OD<=_stop
                  !}
               ?}
            ?}
         ?};

         _ODD.next()
      !}
   ?};
   WAL.cntx_pop();
   H_ODDP.cntx_pop();
   obj_del(_ODD)
?};
H_ODDE.cntx_pop();

_diety


\zlicz_wynagrodzenie
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [22.26]
:: OPIS: Zlicza wynagrodzenia dla pracy za granicą.
::   WE: [_a][_P]    - wskazanie na pracownika, domyślnie [P.ref]
::       [_b][DATE]  - data od kontroli, domyślnie z listy [date(O.R,O.M,1)]
::       [_c][DATE]  - data do kontroli, domyślnie z listy [date(O.R,O.M,0)]
::       [_d][_KRAJE]- wskazanie na kraj, domyślnie z listy [O.KRAJE]
::       [_e][STRING]- T/N czy pomijać kartotekę oddelegowań [O.B_ODD]
::   WY: wartość dla 7162
::----------------------------------------------------------------------------------------------------------------------
_prac:={? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=P || _a || P.ref() ?};
_start:={? var_pres('_b')=type_of(date()) || _b || date(O.R,O.M,1) ?};
_stop:={? var_pres('_c')=type_of(date()) || _c || date(O.R,O.M,0) ?};
_kraj:={? var_pres('_d')=type_of(null()) & _d<>null() & ref_tab(_d)=KRAJE || _d || O.KRAJE ?};
_bOdd:={? var_pres('_e')=type_of('') || _e || O.B_ODD ?};
_wynagr:=0;

_wyn:=0;
{? PAR_SKID.get(261)='T'
|| FUNKCJE.LK(7159,,,1);
   FUNKCJE.LK(7160,,,1);
   FUNKCJE.LK(7161,,,1);
   FUNKCJE.LK(7164,,,1);
   FUNKCJE.LK(7165,,,1);
   FUNKCJE.LK(7168,,,1);
   {? _bOdd<>'T'
   || FUNKCJE.LK(7164,,FUNKCJE.L_SYS(1024));
:: Wynagrodzenia jednocześnie krajowe i zagraniczne w zależności od przebiegu zatrudnienia.
     _kwota:=obj_new('POD_ZUS','ZUS','POD','BEZ');
     _kwota.POD_ZUS:=_kwota.ZUS:=_kwota.POD:=_kwota.BEZ:=0;
     R.cntx_psh();
     R.prefix();
     _tab_rub:=__RUB.sys_rub(1025,_stop);
     {? _tab_rub.first()
     || {!
        |? {? R.seek(__RUB.ref(_tab_rub.RN))
           || {? R.ZUS='T' & (R.POD='T' | __RUB.sys_attr(R.RN,48,_stop))
              || _kwota.POD_ZUS+=FUNKCJE.L(R.RN)
              |? R.ZUS='T'
              || _kwota.ZUS+=FUNKCJE.L(R.RN)
              |? (R.POD='T' | __RUB.sys_attr(R.RN,48,_stop))
              || _kwota.POD+=FUNKCJE.L(R.RN)
              || _kwota.BEZ+=FUNKCJE.L(R.RN)
              ?}
           ?};
           _tab_rub.next()
        !};
        {? _kwota.POD_ZUS
        || _kwota.POD_ZUS:=exec('h_odde_prop','oddelegowanie',_kwota.POD_ZUS,,_start,_stop,4)
        ?};
        {? _kwota.POD
        || _kwota.POD:=exec('h_odde_prop','oddelegowanie',_kwota.POD,,_start,_stop,4)
        ?};
        {? _kwota.ZUS
        || _kwota.ZUS:=exec('h_odde_prop','oddelegowanie',_kwota.ZUS,,_start,_stop,4)
        ?};
        {? _kwota.BEZ
        || _kwota.BEZ:=exec('h_odde_prop','oddelegowanie',_kwota.BEZ,,_start,_stop,4)
        ?};
        FUNKCJE.LK(7168,,_kwota.POD_ZUS+_kwota.ZUS+_kwota.POD+_kwota.BEZ)
     ?};
     R.cntx_pop();

:: 7159 OZ: wyn. ZUS i pod.
      _wynagr:=FUNKCJE.L(7164);
      _war:=exec('h_odde_prop','oddelegowanie',_wynagr+_kwota.POD_ZUS,_prac,_start,_stop,0,,,_kraj);
      FUNKCJE.LK(7159,,_war);

:: 7160 OZ: wynagr. ZUS
      _war:=exec('h_odde_prop','oddelegowanie',_wynagr+_kwota.ZUS,_prac,_start,_stop,1,,,_kraj);
      _bez_pod:=FUNKCJE.L_SYS(10212);
      {? _bez_pod
      || FUNKCJE.LK(7165,,_bez_pod);
         _war+=exec('h_odde_prop','oddelegowanie',_bez_pod,_prac,_start,_stop,5,,,_kraj)
      ?};
      FUNKCJE.LK(7160,,_war);

:: 7161 OZ: wynagr. podatek.
      _war:=exec('h_odde_prop','oddelegowanie',_wynagr+_kwota.POD,_prac,_start,_stop,2,,,_kraj);
      _bez_ZUS:=FUNKCJE.L_SYS(10222);
      {? _bez_ZUS
      || FUNKCJE.LK(7167,,_bez_ZUS);
         _war+=exec('h_odde_prop','oddelegowanie',_bez_ZUS,_prac,_start,_stop,7,,,_kraj)
      ?};
      FUNKCJE.LK(7161,,_war);

:: 7162 OZ: wyn.b.ZUS b.pod.
      _war:=exec('h_odde_prop','oddelegowanie',_wynagr+_kwota.BEZ,_prac,_start,_stop,3,,,_kraj);
      _war+=exec('h_odde_prop','oddelegowanie',FUNKCJE.L(7165),,_start,_stop,6,,,_kraj);
      _wyn:=_war
   ?}
?};
_wyn


\h_odde_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Obsługa akcji "Rekord przed" tabeli H_ODDE
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H_ODDE.actions_grayed('WER',{? H_ODDE.size()>1 || '' || 'u' ?});

''


\h_odde_n_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Sprawdza zasadność odznaczenia pola H.ODDEL.
::   WE:  [_a] [NUMBER] - tryb modyfikacji zapisu: 0 - dodawanie [domyślnie], 1 - poprawianie
::   WY:  ''  lub akronim pola, do którego edycji należy powrócić
::----------------------------------------------------------------------------------------------------------------------
_popraw:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_result:='';

{? _popraw & H.ODDEL='N'
|| _ask:=0;
   H_ODDE.cntx_psh();
   H_ODDE.index('HOD');
   H_ODDE.prefix(H.ref());
   _ask:=H_ODDE.first();
   H_ODDE.cntx_pop();
   {? _ask &
      ~FUN.ask('Odznaczenie pola "Oddelegowanie" spowoduje usunięcie\n'
               'powiązanych oddelegowań po zatwierdzeniu redakcji.\n'
               'Czy kontynuować?'@)
   || H.ODDEL:='T';
      _result:='ODDEL'
   ?}
?};

_result


\sum_rub_o
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [12.51]
:: OPIS: Zlicza sumy składników z list w miesiącu rachunku. Używane podczas naliczania rachunku.
::       Kontekst RH musi być ustalony.
::   WE: _a [STRING] - oddzielona przecinkami lista składników do zsumowania, np. '7074,7197'
::      [_b][STRING] - U*/P/K - sposób zbierania danych - ubezpieczeniowo/podatkowo/kosztowo (domyślnie U)
::   WY: _TAB [TABLE] - tabela z kolumnami RN [INTEGER] - numer rubryki, SUM [REAL] - suma wartości z list
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('') | ~+_a
|| FUN.error('Błąd parametru wejściowego!'@);
   return(0)
?};
_rozl:={? var_pres('_b')=type_of('') & ',u,p,k,'*',%1,'[-_b] || -_b || 'u' ?};
_rubryki:=spli_str(_a,',');
_TAB:=tab_tmp(1,'RN','INTEGER','Numer rubryki'@,'SUM','REAL','Suma wartości'@);
{! _ii:=1..obj_len(_rubryki)
|! _TAB.RN:=#_rubryki[_ii];
   _TAB.SUM:=0;
   _TAB.add()
!};
obj_del(_rubryki);
_firma:=exec('firma','ustawienia');

ZC.cntx_psh();
LS.cntx_psh;
O.cntx_psh;
{? _rozl='p'
|| O.index('LISTYPOD')
|? _rozl='k'
|| O.index('LISTYMIE')
|| O.index('LISTYUBZ')
?};
O.prefix(_firma,RH.DWY~1,RH.DWY~2);
{? O.first()
|| RH.ZLE();
   {!
   |? {? O.F_ZATR().KOD<>'Z'
      || LS.use(-('L'+($O.R+2)+('00'+$O.M+2)+O.T().T));
         LS.index('OSOBAKOD');

         {? _TAB.first()
         || {!
            |? LS.prefix(_firma,ZC.OSOBA,_TAB.RN);
               {? LS.first
               || {!
                  |? _TAB.SUM+=LS.KW$2;
                     _TAB.put();

                     LS.next()
                  !}
               ?};

               _TAB.next()
            !}
         ?}
      ?};
      O.next
   !}
?};
O.cntx_pop;
LS.cntx_pop;
ZC.cntx_pop();
_TAB


\przych_op_zag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Formuła płacowa dla składnika 7081 OZ: przych. op. zag.
::   WE:
::   WY: _ret [REAL] - kwota do składnika
::----------------------------------------------------------------------------------------------------------------------
_ret:=FUNKCJE.L_SYS(1021);
:: 1021: Przychód opodatkowany zagraniczny, 1026: Wynagrodzenia opodatkowane w Polsce,
:: 7109: Przychód - wpł. PPK, 451: Płaca zasadnicza
:: Przychód PPK wędruje do przychodu zagranicznego jeśli przychodu opodat. w polsce i nie ma zasadniczej
{? _ret & FUNKCJE.L_SYS(1026)=0 & FUNKCJE.L_SYS(451)=0
|| _ret+=FUNKCJE.L(7109)
?};

_ret


\diety_pom_zag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Formuła płacowa dla składnika 7166 OZ: Diety pom. zag.
::   WE:
::   WY: _ret [REAL] - kwota do składnika
::----------------------------------------------------------------------------------------------------------------------
exec('dieta2podatek','oddelegowanie',90105)


\oz_urlop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Formuła płacowa dla składnika 7157 OZ: Urlop
::   WE:
::   WY: _ret [REAL] - kwota do składnika
::----------------------------------------------------------------------------------------------------------------------
FUNKCJE.NG(7157)


\oz_choroba
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Formuła płacowa dla składnika 7156 OZ: Choroba
::   WE:
::   WY: _ret [REAL] - kwota do składnika
::----------------------------------------------------------------------------------------------------------------------
FUNKCJE.NK(7156)


\blokada
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Sprawdza czy pracownik posiada przebieg zatrudnienia z oddelegowaniem i brakiem płacy oddelegowanie,
::       który powinien zablokować naliczanie listy płac
::   WE: [_a][_O] - wskazanie na nagłowek listy płac, domyślnie O.ref()
::       [_b][_P] - wskazanie na pracownika, domyślnie P.ref()
::   WY: 0/1 - czy naliczanie powinno być zablokowane
::----------------------------------------------------------------------------------------------------------------------
_ret:=0;
{? PAR_SKID.get(261)='N' || return(_ret) ?};
_lista:={? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=O || _a || O.ref() ?};
_prac:={? var_pres('_b')=type_of(null()) & _b<>null() & ref_tab(_b)=P || _b || P.ref() ?};

O.cntx_psh();
{? O.seek(_lista,,1)
:: Lista nie pomija oddelegowań:
|| {? O.B_ODD='N'
   || _od:=date(O.R,O.M,1);
      _do:=date(O.R,O.M,0);
      H.cntx_psh();
      H.use('_hist');
      H.index('HISTODD');
      H.prefix(_prac,'T');
      {? H.find_le(_do) & H.DO>=_od
      || {!
         |? {? H.S4=0
            || _ret:=1
            ?};

            ~_ret & H.prev() & H.DO>=_od
         !}
      ?};
      H.cntx_pop()
   ?}
?};
O.cntx_pop();

_ret


\pozycje_odd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Generuje pozycje oddelegowań (diety, noclegi).
::UWAGA: Wymagane ustalenie kontekstu H_ODDE
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
DIETZAGR.cntx_psh();
DIETZAGR.index('KRAJ');
DIETZAGR.prefix(H_ODDE.KRAJ().SYM);
H_ODDR.cntx_psh();
H_ODDR.index('H_ODDRDN');
H_ODDR.prefix(exec('firma','ustawienia'));
H_ODDP.cntx_psh();
H_ODDP.index('H_ODDE');
H_ODDP.prefix(H_ODDE.ref());
_diety:={? H_ODDR.find_key('T','N') || H_ODDR.ref() || null() ?};
_noclegi:={? H_ODDR.find_key('N','T') || H_ODDR.ref() || null() ?};
:: Tworzenie pozycji "Diety" do oddelegowań.
{? _diety
|| exec('generuj_pozycje','oddelegowanie',_diety)
?};
:: Tworzenie pozycji "Noclegi" do oddelegowań.
{? H_ODDE.ZAKW<>'N' & _noclegi
|| exec('generuj_pozycje','oddelegowanie',_noclegi,H_ODDE.ST_NOC,H_ODDE.WAL_NOC)
?};
H_ODDP.cntx_pop();
H_ODDR.cntx_pop();
DIETZAGR.cntx_pop();
~~


\sum_atr_o
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [12.51]
:: OPIS: Zlicza sumy atrybutów z list w miesiącu rachunku. Używane podczas naliczania rachunku.
::       Kontekst RH musi być ustalony.
::   WE: _a [STRING] - oddzielona przecinkami lista atrybutów do zsumowania, np. '92,90202'
::      [_b][STRING] - U*/P/K - sposób zbierania danych - ubezpieczeniowo/podatkowo/kosztowo (domyślnie U)
::   WY: _TAB [TABLE] - tabela z kolumnami SYMBOL [INTEGER] - numer atrybutu, SUM [REAL] - suma wartości z list
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('') | ~+_a
|| FUN.error('Błąd parametru wejściowego!'@);
   return(0)
?};
_rozl:={? var_pres('_b')=type_of('') & ',u,p,k,'*',%1,'[-_b] || -_b || 'u' ?};
_atrybuty:=spli_str(_a,',');
_TAB:=tab_tmp(1,'SYMBOL','INTEGER','Numer atrybutu','SUM','REAL','Suma wartości');
{! _ii:=1..obj_len(_atrybuty)
|! _TAB.SYMBOL:=#_atrybuty[_ii];
   _TAB.SUM:=0;
   _TAB.add()
!};
obj_del(_atrybuty);
_firma:=exec('firma','ustawienia');

ZC.cntx_psh();
LS.cntx_psh;
O.cntx_psh;
{? _rozl='p'
|| O.index('LISTYPOD')
|? _rozl='k'
|| O.index('LISTYMIE')
|| O.index('LISTYUBZ')
?};
O.prefix(_firma,RH.DWY~1,RH.DWY~2);
{? O.first()
|| RH.ZLE();
   {!
   |? {? O.F_ZATR().KOD<>'Z'
      || LS.use(-('L'+($O.R+2)+('00'+$O.M+2)+O.T().T));
         LS.index('OSOBAKOD');

         {? _TAB.first()
         || {!
            |? _ATR:=__RUB.sys_rub(_TAB.SYMBOL);
               {? _ATR.first()
               || {!
                  |? LS.prefix(_firma,ZC.OSOBA,_ATR.RN);
                     {? LS.first
                     || {!
                        |? _TAB.SUM+=LS.KW$2;
                           _TAB.put();

                           LS.next()
                        !}
                     ?};

                     _ATR.next()
                  !}
               ?};
               obj_del(_ATR);

               _TAB.next()
            !}
         ?}
      ?};
      O.next
   !}
?};
O.cntx_pop;
LS.cntx_pop;
ZC.cntx_pop();
_TAB


\osoba_odd_okr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Sprawdza czy w zadanym okresie OSOBA (którykolwiek z powiązanych pracowników) przebywa na oddelegowaniu
::       (czy występuje oddelegowanie w okresie)
::   WE: [_a][_OSOBA]   - wskazanie na osobę, domyślnie OSOBA.ref
::       [_b][DATE] - data od kontroli, domyślnie początek miesiąca [date(,,1)]
::       [_c][DATE] - data do kontroli, domyślnie koniec miesiąca [date(,,0)]
::   WY: _ret [INTEGER] - status 0 - nie występuje oddelegowanie, 1 - występuje oddelegowanie
::----------------------------------------------------------------------------------------------------------------------
_ret:=0;
_osoba:={? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=OSOBA || _a || OSOBA.ref() ?};
_dtOd:={? var_pres('_b')=type_of(date()) || _b || date(,,1) ?};
_dtDo:={? var_pres('_c')=type_of(date()) || _c || date(,,0) ?};
_ret:=sql('select H_ODDE.O_OD
           from H_ODDE
           join H using(H_ODDE.H, H.REFERENCE)
           join P using(H.P, P.REFERENCE)
           join OSOBA using(P.OSOBA, OSOBA.REFERENCE)
           where H_ODDE.O_OD<=to_date(:_c) and H_ODDE.O_DO>=to_date(:_b) and OSOBA.REFERENCE=:_a',
           _osoba,_dtOd,_dtDo).size();
_ret

:Sign Version 2.0 jowisz:1045 2023/12/19 13:55:32 5e32512b886cf931a56bd39f07ce19cc66a96a62ba852e1f040ca5a0e5dd7b0fdeb7a28707de371a90a77e874fd2616a315bd4aaff96395e460392fd12029d39e08d43e678bd16a91a6b4b0375d1b19ca9d3643f720cb77abd46b41303f3b2cab12eee98b6ab7d3b78eff27e2f6ae08f3f5be66be7f5b30952365c1a613a92ad
