:!UTF-8
::(c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: px_sur.fml [12.30]
:: Utworzony: 2012/11/19
:: Autor: TS
::======================================================================================================================
:: Zawartość: Obsługa surowców do przepisow planistycznych - plan strategiczny - dane do bufora planu zamówień dostaw
::======================================================================================================================


\erase
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Kasowanie zapisow PX_SUR z wersji planu
::   WE: _a - PX_VER.ref()
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_can_continue:=1;

PX_SUR.index('PXPOZMC');
PX_SUR.prefix(_px_ver);
{? PX_SUR.first()
||
   {!
   |?
      _can_continue:=PX_SUR.del(,1);
      _can_continue & PX_SUR.first()
   !}
?};
_can_continue


\generuj_ver
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Generuje PX_SUR do PX_POZ-ow z calej wersji planu - wariant dla pracy na wielu wersjach planu
::   WE: _a - PX_VER.ref()
::      [_b] - _args - argumenty dla funkcji raportujacej progress
::                     wynik dzialania exec('plan_progress_a','px_logix')
::----------------------------------------------------------------------------------------------------------------------
:: Odtwarzanie wszystkiego ze wskazanej wersji planu
_px_ver:=_a;
_argsprog:={? _>=2 || _b || exec('plan_progress_a','px_logix') ?};

{? exec('is_one_version','px_param')
|| exec('generuj_1ver','px_sur',_px_ver,_argsprog);
   return()
?};

Cntx.psh(PX_POZ,PX_GRP,PX_STAGE,PX_TEX,ZGP,ZLIM,ZL);

_can_continue:=1;

PX_POZ.index('PX_STAG4');
PX_POZ.prefix(_px_ver,'N');

::_argsprog.STRING:='Aktualizacja danych do planu zamówień dostaw';
::_argsprog.SIZELOC:=PX_POZ.size()*10;

_px_stage:=null();
_px_grp:=null();

_size:=PX_POZ.size();
_progress:=0;

:: Zapisy dodajemy tylko dla pierwszego PX_POZ w ramach PX_GRP i PX_STAGE
:: (pierwsze uzycie = cale zapotrzebowanie)
{? PX_POZ.first()
||
   _pxpoz_size:=exec('task_size_pxpoz','px_logix',_px_ver);
   {? _pxpoz_size>1
   || _argsprog.MULTI.ph_ssize(,_pxpoz_size)
   ?};
   {!
   |?
      _progress+=1;

      PX_GRP.cntx_psh();
      _ver_grp:=PX_POZ.PX_GRP().PX_VER;
      PX_GRP.cntx_pop();

::    Uwaga: pomijane sa PX_POZ przynalezne do PX_GRP z innej wersji (przypadek symulacji)
      {? _ver_grp=_px_ver & (PX_POZ.PX_STAGE<>_px_stage | PX_POZ.PX_GRP<>_px_grp)
      ||
         PX_POZ.PX_STAGE();

::       Jezeli sa limity powiazane z etapem planistycznym, to nie generowac PX_SUR
::         _add:=~exec('is_zlim_pxstag','zl_limit',PX_STAGE.ref());
         _add:=1;

         {? _add
         || _xjm:=
               {? PX_STAGE.TKTL<>null()
               || exec('FindAndGet','#table',TKTL,PX_STAGE.TKTL,,"XJM",1)
               || PX_STAGE.PX_TEX().XJM
               ?};
::          Wspolczynnik wykonania dla etapu - zawsze 1
            _cwyk:=1;
            _coef:={? _xjm=0 || 1 || PX_POZ.PX_GRP().ILOSC/_xjm*_cwyk ?};
            exec('add','px_sur',_coef)
         ?}
      ?};

      _px_stage:=PX_POZ.PX_STAGE;
      _px_grp:=PX_POZ.PX_GRP;

::    raportuje progress
      {? _can_continue>0 & _progress%*10=0
      || _argsprog.PROGLOC+=10;
         _can_continue:=exec('plan_progress','px_logix',_argsprog,10)
      ?};

::    Ostemplowanie przetworzonego PX_POZ
      PX_POZ.cntx_psh();
      PX_POZ.prefix();
      PX_POZ.UPD_SUR:='T';
      PX_POZ.put();
      PX_POZ.cntx_pop();

      _can_continue & PX_POZ.first()
   !}
?};

Cntx.pop(PX_POZ,PX_GRP,PX_STAGE,PX_TEX,ZGP,ZLIM,ZL);
~~


\generuj_grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Generuje PX_SUR do PX_POZ-ow dla grupy PX_GRP
::   WE: _a - PX_VER.ref()
::       _b - PX_GRP.ref()
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(PX_POZ,PX_GRP,PX_STAGE,PX_OBJ,PX_TEX);

:: Odtwarzanie wszystkiego ze wskazanej wersji planu i grupy
_px_ver:=_a;
_px_grp:=_b;

_can_continue:=1;

PX_POZ.index('PX_STAG3');
PX_POZ.prefix(_px_ver,_px_grp);

_px_stage:=null();

:: Zapisy dodajemy tylko dla pierwszego niewykonanego PX_POZ w ramach PX_GRP i PX_STAGE
:: (pierwsze uzycie = cale zapotrzebowanie)
{? PX_POZ.first()
|| {!
   |?
      {? PX_POZ.PX_STAGE<>_px_stage & PX_POZ.STATUS<>exec('status_wyk2','px_poz')
      ||
         PX_POZ.PX_STAGE();

::       Jezeli sa limity powiazane z etapem planistycznym, to nie generowac PX_SUR
::         _add:=~exec('is_zlim_pxstag','zl_limit',PX_STAGE.ref());
         _add:=1;

         {? _add
         || _xjm:=
               {? PX_STAGE.TKTL<>null()
               || exec('FindAndGet','#table',TKTL,PX_STAGE.TKTL,,"XJM",1)
               || PX_STAGE.PX_TEX().XJM
               ?};
::          Wspolczynnik wykonania dla etapu - zawsze 1
            _cwyk:=1;
            _coef:={? _xjm=0 || 1 || PX_POZ.PX_GRP().ILOSC/_xjm*_cwyk ?};
            exec('add','px_sur',_coef)
         ?};
         _px_stage:=PX_POZ.PX_STAGE
      ?};

      PX_POZ.next()
   !}
?};

Cntx.pop(PX_POZ,PX_GRP,PX_STAGE,PX_OBJ,PX_TEX);
~~


\delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Kasowanie zapisow PX_SUR do konkretnego PX_POZ
::       Wolane z exec('delete','px_poz'), exec('del_sur','px_poz')
::   WE: _a - PX_VER.ref()
::       _b - PX_POZ.ref()
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_px_poz:=_b;

_can_continue:=1;

PX_SUR.index('PXPOZMC');
PX_SUR.prefix(_px_ver,$_px_poz);
{? PX_SUR.first()
|| {!
   |? _can_continue:=PX_SUR.del(,1);
      _can_continue & PX_SUR.first()
   !}
?};
_can_continue


\add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Dodanie zapisow PX_SUR do konkretnego PX_POZ
::       Kontekst pracy: rekord PX_POZ
::   WE: _a - wspolczynnik przeliczania normy na faktyczna ilosc
::----------------------------------------------------------------------------------------------------------------------
_coef:=_a;

PX_SUR.clear();
PX_MAT.index('UNIQALL');
PX_MAT.prefix(PX_POZ.PX_STAGE);
{? PX_MAT.first()
|| {!
   |?
      PX_SUR.blank(1);
      PX_SUR.PX_VER:=PX_POZ.PX_VER;
      PX_SUR.PX_POZ:=$PX_POZ.ref();
      PX_SUR.PX_GRP:=$PX_POZ.PX_GRP;
      PX_SUR.M:=PX_MAT.M;
      _il:=PX_MAT.IL*_coef;
      _dokl:=PX_MAT.M().DOKL;
      PX_SUR.IL:={? _dokl=0 || ceil(_il) || _il$_dokl ?};
      PX_SUR.ODDZ:=ST.ODDZ;
      PX_SUR.MG:=exec('ustmag','zl_common',,PX_MAT.M);
      PX_SUR.STARTD:=PX_POZ.PX_CUP().STARTD().DATA;
      PX_SUR.STARTT:=PX_CUP.STARTT;
      PX_SUR.ZL:=PX_MAT.ZL;
      PX_SUR.ZLIM:=PX_MAT.ZLIM;
      PX_SUR.add();

      PX_MAT.next()
   !}
?};
~~


\is_sur_pxpoz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Sprawdza, czy sa zdefiniowane surowce do PX_POZ
::   WE: _a - PX_POZ.ref()
::       Nie jest sprawdzana obecnosc ani typ argumentow
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_px_poz:=_a;

PX_POZ.cntx_psh();
PX_POZ.clear();
{? PX_POZ.seek(_px_poz)
||
   PX_SUR.index('PXPOZKTM');
   PX_SUR.prefix(PX_POZ.PX_VER,$PX_POZ.ref());
   _res:=PX_SUR.first()
||
   _res:=0
?};
PX_POZ.cntx_pop();
_res


\is_sur_pxgrp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Sprawdza, czy sa zdefiniowane surowce do PX_GRP
::   WE: _a - PX_GRP.ref()
::       Nie jest sprawdzana obecnosc ani typ argumentow
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

PX_GRP.cntx_psh();
PX_GRP.clear();
{? PX_GRP.seek(_px_grp)
||
   PX_SUR.index('PXGRPKTM');
   PX_SUR.prefix(PX_POZ.PX_VER,$PX_GRP.ref());
   _res:=PX_SUR.first()
||
   _res:=0
?};
PX_GRP.cntx_pop();
_res


\sel_sur_pxpoz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Selekcja surowcow przypisanych do PX_POZ
::   WE: _a - PX_POZ.ref()
::       Nie jest sprawdzana obecnosc ani typ argumentow
::----------------------------------------------------------------------------------------------------------------------
_px_poz:=_a;

PX_POZ.cntx_psh();
PX_POZ.clear();
{? PX_POZ.seek(_px_poz)
||
   PX_SUR.index('PXPOZDT');
   PX_SUR.prefix(PX_POZ.PX_VER,$PX_POZ.ref());

   PX_SUR.win_sel(exec('win_sel','px_sur','PX_POZ'));
   PX_SUR.select()
?};

PX_POZ.cntx_pop();
~~


\sel_sur_pxgrp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Selekcja surowcow przypisanych do PX_GRP
::   WE: _a - PX_GRP.ref()
::       Nie jest sprawdzana obecnosc ani typ argumentow
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

PX_GRP.cntx_psh();
PX_GRP.clear();
{? PX_GRP.seek(_px_grp)
||
   PX_SUR.index('PXGRPDT');
   PX_SUR.prefix(PX_GRP.PX_VER,$PX_GRP.ref());

   PX_SUR.win_sel(exec('win_sel','px_sur','PX_GRP'));
   PX_SUR.win_edit(exec('win_edit','px_sur'));
   PX_SUR.select()
?};

PX_GRP.cntx_pop();
~~


\sel_sur_pxver
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Selekcja surowcow przypisanych do wersji glownej planu
::   WE: [_a] - PX_VER.ref() - domyslnie wersja glowna planu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _px_ver:=_a
|| _px_ver:=exec('get_mainversion','px_ver')
?};

PX_SUR.cntx_psh();

PX_SUR.index('PXVERDT');
PX_SUR.prefix(_px_ver);

PX_SUR.win_sel(exec('win_sel','px_sur','PX_VER'));
PX_SUR.win_edit(exec('win_edit','px_sur'));
PX_SUR.hdr_sel(' '+'(wersja: %1)'@[exec('FindAndGet','#table',PX_VER,#_px_ver,ref_name(_px_ver),"STATUS",'')]);
PX_SUR.select();

PX_SUR.cntx_pop();
~~


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Selekcja surowcow przypisanych do pozycji planu dla obiektu lub zasobu
::   WE: _a - #PX_OBJ.ref() (0 - bez obiektu)
::       _b - #PX_KONT.ref() (0 - bez zasobu)
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(PX_OBJ,PX_KONT,PX_SUR);
Cntx.clr(PX_OBJ,PX_KONT,PX_SUR);

{? _a=0
||
:: widok pozycji planu dla zasobu (rozne obiekty)
   {? PX_KONT.seek(_b,)
   ||
      PX_POZ.index('TM_KONT');
      PX_POZ.prefix(_b)
   ?}
|? _b=0
||
:: widok pozycji planu dla obiektu (rozne zasoby)
   PX_CUP.blank(1);
   {? PX_OBJ.seek(_a,)
   ||
      PX_POZ.index('TM_VOBJ');
      PX_POZ.prefix(PX_VAR.VIE_VER,_a)
   ?}
||
:: widok pozycji planu dla zasobu i obiektu
   {? PX_OBJ.seek(_a,) & PX_KONT.seek(_b,)
   ||
      PX_POZ.index('TM_VOBJK');
      PX_POZ.prefix(PX_VAR.VIE_VER,_a,_b)
   ?}
?};

{?
   PX_SUR.f_set('STARTD,STARTT,M(KTM)',,'PX_SUR.PX_POZ in (select REFERENCE from prefixed_table(:_a))',PX_POZ)
||
   PX_SUR.win_sel(exec('win_sel','px_sur',{? _a || 'PX_OBJ' || 'PX_KONT' ?}));
   PX_SUR.win_edit(exec('win_edit','px_sur'));
   PX_SUR.select();

   PX_SUR.f_clear()
?};

Cntx.pop(PX_OBJ,PX_KONT,PX_SUR);
~~


\win_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Okno wertowania tabeli PX_SUR
::   WE: _a - wariant okna: 'PX_POZ', 'PX_OBJ', 'PX_GRP', 'PX_KONT', 'PX_VER'
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('')
|| _wariant:=_a
|| FUN.wdrerror('Niepoprawne wywołanie formuły win_sel/px_sur.');
   return()
?};

{? _wariant='PX_VER'
|| _title:='Surowce do planu wg przepisów planistycznych'@
|| _title:='Surowce wg przepisu planistycznego'@
?};

_wer:=PX_SUR.mk_sel(_title,'P',,'#pxsurdo'+(-_wariant),1,15,20,,'U');
{? _wariant='PX_VER'
|| PX_SUR.win_fld(_wer,VAR,'STRING',,,20,,,'Grupa'@)
?};
PX_SUR.win_fld(_wer,,'M','KTM',,20,,,'Indeks'@,,'Indeks materiałowy'@);
PX_SUR.win_fld(_wer,,'M','N',,50,,,'Nazwa'@,,'Nazwa materiału'@);
PX_SUR.win_fld(_wer,,'IL',,,15,ST.DOKL,,'Ilość'@,,'Ilość materiału'@);
PX_SUR.win_fld(_wer,M,'J','KOD',,,,,'jm'@,,'Jednostka miary'@);
PX_SUR.win_fld(_wer,,'STARTD',,,,,,'Data'@,,'Data na kiedy materiał będzie potrzebny'@);
PX_SUR.win_fld(_wer,,'STARTT',,,,,,'Godzina'@,,'Godzina na kiedy materiał będzie potrzebny'@);
PX_SUR.win_act(_wer,,'Formuła','Szcz&egóły'@@,,'Szczegóły indeksu'@,
   "exec('info_zam','magazyn_stan',5,PX_SUR.M)",,,,,,'E'
);
PX_SUR.win_act(_wer,,'Formuła','Analiza'@@,,'Analiza dostępności materiałów w czasie'@,
   "exec('pxm_analiza_b','px_sur')","exec('pxm_analiza_a','px_sur')",,1,
   "exec('pxm_analiza_bg','px_sur')","exec('pxm_analiza_ag','px_sur')",'A'
);
PX_SUR.win_act(_wer,,'Szukaj',,,,"exec('slo_m_ok','material','T',0,,'W'); PX_SUR.win_patt('SZUKAJ');~~");
PX_SUR.win_act(_wer,,'Kolejność');
{? _wariant='PX_VER'
|| _fb:="
      PX_GRP.cntx_psh();
      PX_GRP.clear();
      {? PX_GRP.seek(PX_SUR.PX_GRP)
      || VAR.STRING:=PX_GRP.SYMBOL+' — '+PX_GRP.NAZWA
      || VAR.STRING:=''
      ?};
      PX_GRP.cntx_pop();
      ~~
   ";
   PX_SUR.win_act(_wer,,'Rekord',,,,_fb)
?};

_btn:=PX_SUR.win_btn(_wer,'text='+'Szcz&egóły'@,'menu:E',,,,,,'noempty');
PX_SUR.btn_sopt(_wer,_btn,'tooltip='+'Szczegóły indeksu'@);
_btn:=PX_SUR.win_btn(_wer,'text='+'Analiza'@,'menu:A',,,,,,'noempty');
PX_SUR.btn_sopt(_wer,_btn,'tooltip='+'Analiza dostępności materiałów w czasie'@);

_wer


\win_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Okno redagowania tabeli PX_SUR
::----------------------------------------------------------------------------------------------------------------------
_red:='RED';
_red


\pxm_analiza_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostepnosci materialow w czasie - akcja 'przed' dla tabeli PX_SUR
::----------------------------------------------------------------------------------------------------------------------
{? exec('is_pdbuf','plan_dostaw')
||
   {? PX_SUR.sel_size()=0
   ||
      exec('env_create','plan_dostaw')
   ?};

   _args:=exec('pda_a','plan_dostaw');
   _args.M:=PX_SUR.M;
   _args.TM_STAMP:=SYSLOG.tm_stamp();
::   _args.DK:=PX_SUR.STARTD+1;
::   _args.TK:=PX_SUR.STARTT;
   _args.IL:=PX_SUR.IL;
   _args.DW:=PX_SUR.STARTD;
   _args.TW:=PX_SUR.STARTT;
   _args.DISP:=0;
:: W przypadku symulacji wyrzucamy z obliczeń wszystkie zapisy dotyczące danego surowca w wersji głównej planu
   _mainver:=exec('get_mainversion','px_ver');
   {? PX_SUR.PX_VER<>_mainver
   || PX_SUR.cntx_psh(); ZLIM.cntx_psh();
      PX_SUR.index('M');
      PX_SUR.prefix(_mainver,PX_SUR.M);
      {? PX_SUR.first()
      || {!
         |? _args.skip_add($PX_SUR.ref());
            {? PX_SUR.ZLIM<>null()
            || exec('openmask','zl_common',PX_SUR.ZL);
               ZLIM.prefix();
               {? ZLIM.seek(PX_SUR.ZLIM)
               || _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
                  {? _zk_p<>null()
                  || _args.skip_add($_zk_p);
                     REZ.index('ZK_P');
                     REZ.prefix(_zk_p);
                     {? REZ.first()
                     || {!
                        |? _args.skip_add($REZ.ref());
                           REZ.next()
                        !}
                     ?}
                  ?};
                  _args.skip_add($PX_SUR.ZLIM)
               ?}
            ?};
            PX_SUR.next()
         !}
      ?};
      PX_SUR.cntx_pop(); ZLIM.cntx_pop()
   ?};
:: Z obliczeń zawsze wyrzucamy samego siebie (dotyczy zapotrzebowania do zlecenia)
   {? PX_SUR.ZLIM<>null()
   || ZLIM.cntx_psh();
      exec('openmask','zl_common',PX_SUR.ZL);
      ZLIM.prefix();
      {? ZLIM.seek(PX_SUR.ZLIM)
      || _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
         {? _zk_p<>null()
         || _args.skip_add($_zk_p);
            REZ.index('ZK_P');
            REZ.prefix(_zk_p);
            {? REZ.first()
            || {!
               |? _args.skip_add($REZ.ref());
                  REZ.next()
               !}
            ?}
         ?};
         _args.skip_add($PX_SUR.ZLIM)
      ?};
      ZLIM.cntx_pop()
   ?};
   _args.skip_add($PX_SUR.ref());

   _used:=exec('env_used_sum','plan_dostaw',_args.M);
   {? _used>0 || _args.insert_add($_args.M,_args.DW,_args.TW,_used) ?};
   _res:=exec('pda','plan_dostaw',_args);

:: exec('select','#table',_args.SKIP);

   _argse:=exec('an_add_a','plan_dostaw');
   _argse.M:=_args.M;
   _argse.IL:=_args.IL;
   _argse.DW:=_args.DW;
   _argse.TW:=_args.TW;
   _argse.DOSTEPNY:=_res.DOSTEPNY;
   _argse.IL_DOST:=_res.IL_DOST;
   _argse.DM:=_res.NA_KIEDY;
:: W przypadku symulacji z wyświetlania wyrzucamy stałe zapisy powiązane z symulowanym,
:: a wstawiamy w zamian zapis symulowany
   {? PX_SUR.PX_VER<>_mainver
   || PX_SUR.cntx_psh(); ZLIM.cntx_psh();
      PX_SUR.index('M');
      PX_SUR.prefix(PX_SUR.PX_VER,PX_SUR.M);
      {? PX_SUR.first()
      || {!
         |? _argse.skip_add($PX_SUR.ref());
            {? PX_SUR.ZLIM<>null()
            || exec('openmask','zl_common',PX_SUR.ZL);
               ZLIM.prefix();
               {? ZLIM.seek(PX_SUR.ZLIM)
               || _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
                  {? _zk_p<>null()
                  || _argse.skip_add($_zk_p);
                     REZ.index('ZK_P');
                     REZ.prefix(_zk_p);
                     {? REZ.first()
                     || {!
                        |? _argse.skip_add($REZ.ref());
                           REZ.next()
                        !}
                     ?}
                  ?};
                  _argse.skip_add($PX_SUR.ZLIM)
               ?}
            ?};
            PX_SUR.next()
         !}
      ?};
      PX_SUR.cntx_pop(); ZLIM.cntx_pop();
      _argse.insert_add($PX_SUR.ref(),PX_SUR.STARTD,PX_SUR.STARTT,PX_SUR.IL);
      ~~
   || {? PX_SUR.ZL=null()
      || _argse.skip_add($PX_SUR.ref());
         _argse.insert_add($PX_SUR.ref(),PX_SUR.STARTD,PX_SUR.STARTT,PX_SUR.IL)
      ?};
      ~~
   ?};
:: Dodanie wpisu do tabeli z analizą
   {? _used>0 & PX_SUR.PX_VER<>_mainver || exec('env_used2insert','plan_dostaw',_argse) ?};
   exec('an_add','plan_dostaw',_argse);
   {? PX_SUR.PX_VER<>_mainver || exec('env_used_add','plan_dostaw',_args.M,_args.DW,_args.TW,_args.IL) ?};

   {? PX_SUR.sel_size()=0
   ||
      exec('an_select','plan_dostaw');
      exec('env_delete','plan_dostaw')
   ?}
?};
~~


\pxm_analiza_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostepnosci materialow w czasie - akcja 'po' dla tabeli PX_SUR
::----------------------------------------------------------------------------------------------------------------------
~~


\pxm_analiza_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostepnosci materialow w czasie - akcja 'przed grupa' dla tabeli PX_SUR
::----------------------------------------------------------------------------------------------------------------------
{? exec('is_pdbuf','plan_dostaw')
||
   exec('env_create','plan_dostaw')
||
   0
?}


\pxm_analiza_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostepnosci materialow w czasie - akcja 'po grupie' dla tabeli PX_SUR
::----------------------------------------------------------------------------------------------------------------------
exec('an_select','plan_dostaw');
exec('env_delete','plan_dostaw')


\px_sur_fld_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Format wyswietlania pol w tabeli PX_SUR
::----------------------------------------------------------------------------------------------------------------------
{? cur_afld()='IL'
|| 'out_prec='+
   {? (2+cur_kwin())='e_'
   || {? PX_SUR.M || $PX_SUR.M().DOKL || $4 ?}
   || $ST.DOKL
   ?}
|| ''
?}


\generuj_1ver
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Generuje PX_SUR do PX_POZ-ow z calej wersji planu - wariant dla pracy na jednej wersji planu
::   WE: _a - PX_VER.ref()
::      [_b] - _args - argumenty dla funkcji raportujacej progress
::                     wynik dzialania exec('plan_progress_a','px_logix')
::----------------------------------------------------------------------------------------------------------------------
:: Odtwarzanie wszystkiego ze wskazanej wersji planu
_px_ver:=_a;
_argsprog:={? _>=2 || _b || exec('plan_progress_a','px_logix') ?};

_can_continue:=1;

_progress:=0;

PX_GRP.cntx_psh();
PX_GRP.index('STATWYK2');
PX_GRP.prefix(_px_ver,'N');
{? PX_GRP.first()
|| {!
   |? _progress+=1;
      exec('generuj_grp','px_sur',_px_ver,PX_GRP.ref());

::    raportuje progress
      {? _can_continue>0 & _progress%*10=0
      || _argsprog.PROGLOC+=10;
         _can_continue:=exec('plan_progress','px_logix',_argsprog,10)
      ?};

      _can_continue>0 & PX_GRP.next()
   !}
?};
PX_GRP.cntx_pop();
~~


\clone
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Klonowanie zapisow PX_SUR
::       Wolane z exec('delete','px_poz'), exec('del_sur','px_poz')
::   WE: _a - PX_VER.ref() - źródłowa wersja
::       _b - PX_POZ.ref() - źródłowa pozycja planu
::       _c - _args  - argumenty funkcji wynik dzialania exec('clone_a','px_poz')
::       _d - PX_POZ.ref() - docelowa pozycja planu
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_px_poz:=_b;
_args:=_c;
_dest:=_d;

_can_continue:=1;

PX_SUR.cntx_psh();
PX_SUR.index('PXPOZMC');
PX_SUR.prefix(_px_ver,$_px_poz);
{? PX_SUR.first()
|| {!
   |?
      PX_SUR.cntx_psh();
      PX_SUR.prefix();
      PX_SUR.PX_VER:=_args.PX_VER;
      PX_SUR.PX_GRP:=$_args.PX_GRP;
      PX_SUR.PX_POZ:=$_dest;
      _can_continue:=PX_SUR.add();
      PX_SUR.cntx_pop();
      PX_SUR.next() & _can_continue>0
   !}
?};
PX_SUR.cntx_pop();
_can_continue

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:36 81bf40dc8ff2660c32f3f3d9e483709eaf0767e65c13433d9d954bab76a07055a7c184c2371b4f2a514bff5959ce72d7900bbe773767fffb8dd5eaa7cd6da594ae82034dee674c907cff8bf047ccb90a1c3a7920332e984a4a9b50505f28a451cea1bb35cef1813225963cbe7feea29ef9bbaa6f1c429b5ffec50848bcb7b9f2
