:!UTF-8
:: (c) Asseco Business Solutions S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: zs_typ.fml [20.42]
:: Utworzony: 16.07.2019
:: Autor: jaws
::======================================================================================================================
:: Zawartość: Formuły obsługujące typy zależności służbowych.
::======================================================================================================================


\_modb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Przed dołączeniem lub poprawieniem wiersza tabeli ZS_TYP.
::   WE:
::   WY: 0/1 - wiersz błędny/poprawny
::----------------------------------------------------------------------------------------------------------------------
_zs_typ:=0;
{? ZS_TYP.KOD_NAD<>null
:: ustal typ nadrzędny
|| ZS_TYP.cntx_psh();
   ZS_TYP.index('UNIQUE');
   ZS_TYP.prefix(ZS_TYP.FIRMA);
   {? ZS_TYP.find_key(ZS_TYP.KOD_NAD)
   || _zs_typ:=#ZS_TYP.ref()
   ?};
   ZS_TYP.cntx_pop()
?};
ZS_TYP.ZS_TYP:=_zs_typ;

ZS_TYP.DOMYSLNY:=
   {? ZS_TYP.ZS_TYP=0
   || exec('_tdef','zs_typ')
   || 'N'
   ?};

1


\_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Sprawdza wypełnienie wymaganych pól. Wykorzystywana w wyzwalaczach przed dołącz i popraw.
::   WE: _a [INTEGER] - Tryb modyfikacji danych
::          0 - dołączanie (domyślnie)
::          1 - poprawianie
::   WY: wynik testu poprawności danych zależny od kontekstu wywołania:
::       - jako formuła "rekord po"
::          - akronim niewypełnionego pola
::          - akronim pola o błędnej wartości
::          - 0 w przypadku powielenia unikalnego klucza
::       - jako formuła sprawdzająca dla wyzwalaczy "dołącz przed" i "popraw przed"
::          - 1 wiersz poprawny
::          - 0 niewypełnione wymagane pole, błędna wartość pola, powielony unikalny klucz
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_mode:={? var_pres('_a')=type_of(0) || _a<>0 ?};

__CHK.validate(ZS_TYP,
   $("_a.table(_b,"+$_mode+",,'FIRMA','SLO_KOD','DOMYSLNY','OK')"),
   "_a.in_set(_b,'DOMYSLNY',,'T','N')",
   "_a.in_set(_b,'OK',,'T','N')"
)


\_addb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Wyzwalacz przed dołączeniem wiersza tabeli ZS_TYP.
::   WE:
::   WY: 0/1 - wiersz błędny/poprawny
::----------------------------------------------------------------------------------------------------------------------
exec('_modb','zs_typ') & exec('_chk','zs_typ',0)


\_adda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Wyzwalacz "po dołącz" tabeli ZS_TYP.
::   WE: _a INTEGER - zgodny ze specyfikacją narzędzi
::   WY: zgodny ze specyfikacją narzędzi
::----------------------------------------------------------------------------------------------------------------------
:: podstawowy warunek dalszego działania
{? ~_a | do_state()<>1 || return() ?};

{? ZS_TYP.DOMYSLNY='T'
:: zmień aktualny typ domyślny
|| exec('_sdef','zs_typ',ZS_TYP.ref())
?};
~~


\_putb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Wyzwalacz przed poprawieniem wiersza tabeli ZS_TYP.
::   WE:
::   WY: 0/1 - wiersz błędny/poprawny
::----------------------------------------------------------------------------------------------------------------------
:: ustal liczbę zależności do weryfikacji
ZS_DEF.cntx_psh();
ZS_DEF.index('OK');
ZS_DEF.prefix(ZS_TYP.ref(),'N');
_nok:=ZS_DEF.size();
ZS_DEF.cntx_pop();

ZS_TYP.LICZ_NOK:=_nok;
ZS_TYP.OK:={? _nok=0 || 'T' || 'N' ?};

exec('_modb','zs_typ') & exec('_chk','zs_typ',1)


\_puta
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Wyzwalacz "po popraw" tabeli ZS_TYP.
::   WE: _a INTEGER - zgodny ze specyfikacją narzędzi
::   WY: zgodny ze specyfikacją narzędzi
::----------------------------------------------------------------------------------------------------------------------
:: podstawowy warunek dalszego działania
{? ~_a | do_state()<>1 || return() ?};
_por:=exec('lic','#b_domain','POR');

{? ZS_TYP.ZS_TYP<>bfld('ZS_TYP')
:: wyczyść schemat zależności służbowych
|| {? exec('wyczysc','zs_typ',ZS_TYP.ref())<>0
   || {? ZS_TYP.ZS_TYP=0 & bfld('ZS_TYP')<>0
::       odłączono od typu nadrzędnego
      || _ref:=ZS_TYP.ref();
         ZS_TYP.cntx_psh();
         {? ZS_TYP.seek(bfld('ZS_TYP'),,1)
::          kopiuj zależności poprzedniego typu
         || exec('kopiuj','zs_typ',_ref,ZS_TYP.ref())
         ?};
         ZS_TYP.cntx_pop()
      ?}
   ?}
?};

{? ZS_TYP.DOMYSLNY<>bfld('DOMYSLNY')
:: zmiana domyślnego typu zależności
|| {? ZS_TYP.DOMYSLNY='T'
::    "wyłącz" aktualny typ domyślny
   || exec('_sdef','zs_typ',ZS_TYP.ref());
::    Portal HR - ustaw nowy typ domyślny jako typ dla zastępstw służbowych
      {? _por
      || SLO_KOD.cntx_psh();
         SLO_KOD.prefix();
         _kod:=ZS_TYP.SLO_KOD().KOD;
         SLO_KOD.cntx_pop();
         exec('set_code','portal_zaslu',_kod)
      ?}

   |? exec('domyslny','zs_typ')=null
::    brak typu domyślnego, ustal nowy
   || exec('_cdef','zs_typ',ZS_TYP.ref(),ZS_TYP.ZS_TYP)
   ?};
   {? _por
::    Aktualizujemy znacznik czasowy zapisów powiązanych z bieżącym ZS_DEF ...
::       ... Jeżeli ZS_DEF.DOMYSLNY zmieniło wartość z 'N' na 'T', to pozwoli to wysłać na portal informacje o nowej
::           domyślnej strukturze.
::       ... Jeżeli ZS_DEF.DOMYSLNY zmieniło wartość z 'T' na 'N', to pozwoli to (metodat typu Delete w ramach
::           'Wysyłanie') usunąć z portalu informacje o strukturze, która nie jesst już domyślna.
::    Warto zauważyć, że najpierw zmieniane są znaczniki czasowe na poprzedniej strukturze domyślnej.
      || exec('idput_ndx','#table',ZS_DEF,'UNIQUE',ZS_TYP.ref())
   ?}
?};

{? bfld('ZS_TYP')=0 & ZS_TYP.ZS_TYP<>0
:: usuń ewentualne zależności dodatkowe
|| exec('del_ndx','#table',ZS_DOD,'TYP_DOD',ZS_TYP.ref());
   exec('del_ndx','#table',ZS_DOD,'DOD_TYP',ZS_TYP.ref())
?};
~~


\_delb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Wyzwalacz przed usunięciem wiersza tabeli ZS_TYP.
::   WE:
::   WY: 0/1 - wiersz może/nie może być usunięty
::----------------------------------------------------------------------------------------------------------------------
_test:=1;
ZS_TYP.cntx_psh();
ZS_TYP.clear();
ZS_TYP.f_set('SLO_KOD',,'ZS_TYP.ZS_TYP=:_a',#ZS_TYP.ref());
_loop:=ZS_TYP.f_first();
{!
|? _loop & _test<>0
|! ZS_TYP.KOD_NAD:=null;
   _test:=ZS_TYP.put();
   _loop:=ZS_TYP.f_next()
!};
ZS_TYP.f_clear(1);
ZS_TYP.cntx_pop();

exec('del_ndx','#table',ZS_DOD,'TYP_DOD',ZS_TYP.ref()) &
exec('del_ndx','#table',ZS_DOD,'DOD_TYP',ZS_TYP.ref()) &
{? _test<>0
:: usuń zależności służbowe
|| exec('wyczysc','zs_typ',ZS_TYP.ref())
?}


\_dela
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Wyzwalacz "po popraw" tabeli ZS_TYP.
::   WE: _a INTEGER - zgodny ze specyfikacją narzędzi
::   WY: zgodny ze specyfikacją narzędzi
::----------------------------------------------------------------------------------------------------------------------
:: podstawowy warunek dalszego działania
{? ~_a | do_state()<>1 || return() ?};

{? bfld('DOMYSLNY')='T' & exec('domyslny','zs_typ')=null
:: brak typu domyślnego, ustal nowy
|| exec('_cdef','zs_typ',null,0)
?};
~~


\_tdef
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Ustala wartość pola DOMYSLNY w wierszu tabeli ZS_TYP.
::   WE:
::   WY: sugerowana wartość znacznika
::----------------------------------------------------------------------------------------------------------------------
_ret:=ZS_TYP.DOMYSLNY;
ZS_TYP.cntx_psh();
ZS_TYP.index('DOMYSLNY');
ZS_TYP.prefix(exec('ref_firma','ustawienia'));
{? ZS_TYP.size()<1 | ~ZS_TYP.find_key('T')
|| _ret:='T'
?};
ZS_TYP.cntx_pop();
_ret


\_sdef
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Zmienia dotychczas domyślny typ na "jeden z wielu".
::   WE: _a _ZS_TYP - wskazanie bieżącego wiersza w tabeli ZS_TYP
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_ref:=_a;

ZS_TYP.cntx_psh();
ZS_TYP.index('TREE');
ZS_TYP.prefix(ZS_TYP.FIRMA,0);
_loop:=ZS_TYP.first();
{!
|? _loop
|! {? ZS_TYP.DOMYSLNY='T' & ZS_TYP.ref()<>_ref
   || ZS_TYP.DOMYSLNY:='N';
      ZS_TYP.put()
   ?};
   _loop:=ZS_TYP.next()
!};
ZS_TYP.cntx_pop();
~~


\_cdef
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Wybiera nowy typ domyślny po zmianie/usunięciu aktualnego.
::   WE: _a _ZS_TYP - wskazanie wiersza w tabeli ZS_TYP
::       _b INTEGER - numer wiersza nadrzędnego
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_ref:=_a;
_num:=_b;

ZS_TYP.cntx_psh();
{? _num<>0
|| ZS_TYP.prefix();
   {? ZS_TYP.seek(_num)
   || ZS_TYP.DOMYSLNY:='T';
      ZS_TYP.put()
   ?}
|| ZS_TYP.index('TREE');
   ZS_TYP.prefix(exec('ref_firma','ustawienia'),0);
   _loop:=ZS_TYP.first();
   {!
   |? _loop
   |! {? ZS_TYP.ref()<>_ref
      || ZS_TYP.DOMYSLNY:='T';
         ZS_TYP.put();
         _loop:=0
      || _loop:=ZS_TYP.next()
      ?}
   !}
?};
ZS_TYP.cntx_pop();
~~


\slo_typ
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Zwraca wskazanie typu słownika kodów dla zależności służbowych.
::   WE:
::   WY: wskazanie typu o symbolu 'TYPPOZ'
::----------------------------------------------------------------------------------------------------------------------
exec('slo_typ','ext_slo','TYPPOZ')


\slo_kod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Zwraca wskazanie wiersza tabeli SLO_KOD właściwego dla typu zależności.
::   WE:
::   WY: wskazanie wiersza tabeli SLO_KOD
::----------------------------------------------------------------------------------------------------------------------
{? ZS_TYP.ZS_TYP=0
|| ZS_TYP.SLO_KOD
|| ZS_TYP.KOD_NAD
?}


\buf_utwórz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Tworzy i ustawia wartościami domyślnymi bufor danych dla wiersza tabeli ZS_TYP.
::   WE:
::   WY: wskazanie tablicy nazwanej o strukturze:
::          REF - wskazanie wiersza w tabeli ZS_TYP
::          REF_NAD - wskazanie wiersza nadrzędnego
::          ZS_TYP - numer wiersza nadrzędnego
::          SLO_KOD - wskazanie słownika kodów
::          KOD_KOD - kod z wiersza SLO_KOD
::          KOD_NAD - wskazanie słownika kodów
::          NAD_KOD - kod z wiersza KOD_NAD
::          OK - znacznik weryfikacji zależności
::          LICZ_NOK - licznik błędnych zależności
::----------------------------------------------------------------------------------------------------------------------
_ret:=obj_new(
   'REF','REF_NAD','ZS_TYP',
   'SLO_KOD','KOD_KOD','KOD_NAD','NAD_KOD',
   'OK','LICZ_NOK'
);

_ret.REF:=null;
_ret.REF_NAD:=null;
_ret.ZS_TYP:=0;
_ret.SLO_KOD:=null;
_ret.KOD_KOD:='';
_ret.KOD_NAD:=null;
_ret.NAD_KOD:='';
_ret.OK:='';
_ret.LICZ_NOK:=0;

_ret


\buf_ustaw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Wypełnia bufor danych wiersza tabeli ZS_TYP bieżącymi wartościami.
::   WE: _a OBJECT - wskazanie tablicy nazwanej bufora (patrz buf_utwórz)
::   WY: _a
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_ret:=_a;

SLO_KOD.cntx_psh();
_ret.REF:=ZS_TYP.ref();
_ret.ZS_TYP:=ZS_TYP.ZS_TYP;
{? _ret.ZS_TYP<>0
|| ZS_TYP.cntx_psh();
   {? ZS_TYP.seek(_ret.ZS_TYP,,1)
   || _ret.REF_NAD:=ZS_TYP.ref();
      _ret.KOD_NAD:=ZS_TYP.SLO_KOD;
      _ret.NAD_KOD:=ZS_TYP.SLO_KOD().KOD
   ?};
   ZS_TYP.cntx_pop()
?};
_ret.SLO_KOD:=ZS_TYP.SLO_KOD;
_ret.KOD_KOD:=ZS_TYP.SLO_KOD().KOD;
_ret.OK:=ZS_TYP.OK;
_ret.LICZ_NOK:=ZS_TYP.LICZ_NOK;
SLO_KOD.cntx_pop();

_ret


\ustal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Tworzy tablicę nazwaną i wypełnia ją wartościami wartościami właściwymi dla typu o podanym kodzie.
::   WE: _a STRING/_SLO_KOD - symbol lub wskazanie słownika kodów.
::       _b [INTEGER] - zachowanie kontekstu: różny od zera - pomiń zachowanie i odtworzenie konteksu, wpp zachowuj
::   WY: tablica nazwana z elementami dane i lisc typu zwracanego przez buf_utworz
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów i zmienne
_ret:=obj_new('dane','lisc');
_ctx:=(var_pres('_b')<>type_of(0) | _b=0);

_vpa:=var_pres('_a');
{? (_vpa<>type_of('') | _a='') & (_vpa<>type_of(null) | _a=null)
:: brak kodu lub wskazania - zwróć wartości dla typu domyślnego
|| _ret.lisc:=exec('domyslny','zs_typ',1,_ctx);
   _ret.dane:=_ret.lisc;
   return(_ret)
?};

{? _ctx<>0
|| ZS_TYP.cntx_psh()
?};
_ret.lisc:=exec('szukaj','zs_typ',_a,1,1);
_ret.dane:=
   {? _ret.lisc.REF_NAD<>null
   || exec('czytaj','zs_typ',_ret.lisc.ZS_TYP,1)
   || _ret.lisc
   ?};
{? _ctx<>0
|| ZS_TYP.cntx_pop()
?};

_ret


\czytaj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Tworzy tablicę nazwaną i wypełnia ją wartościami ze wskazanego wiersza.
::   WE: _a INTEGER/_ZS_TYP - numer/wskazanie wiersza tabeli ZS_TYP
::       _b [INTEGER] - zachowanie kontekstu: różny od zera - pomiń zachowanie i odtworzenie konteksu, wpp zachowuj
::   WY: wskazanie tablicy nazwanej (patrz buf_utworz)
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów i zmienne
_ret:=exec('buf_utwórz','zs_typ');
_ctx:=(var_pres('_b')<>type_of(0) | _b=0);

{? var_pres('_a')=type_of(0)
|| {? _a<=0
   || return(_ret)
   ?}
|? var_pres('_a')=type_of(null)
|| {? _a=null | ref_tab(_a)<>ZS_TYP
   || return(_ret)
   ?}
|| return(_ret)
?};

{? _ctx<>0
|| ZS_TYP.cntx_psh()
?};
{? ZS_TYP.seek(_a,,1)
|| exec('buf_ustaw','zs_typ',_ret)
?};
{? _ctx<>0
|| ZS_TYP.cntx_pop()
?};

_ret


\domyslny
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Ustala domyślny typ zależności służbowych.
::   WE: _a [INTEGER] - typ zwracanego wyniku: różny od zera - wskazanie tablicy nazwanej, wpp referencja
::       _b [INTEGER] - zachowanie kontekstu: różny od zera - pomiń zachowanie i odtworzenie konteksu, wpp zachowuj
::   WY: dla _a:
::       - różnego od zera wskazanie tablicy nazwanej (patrz buf_utworz)
::       - wpp wskazanie wiersza w tabeli ZS_TYP lub null
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_ext:=(var_pres('_a')=type_of(0) & _a<>0);
_ctx:=(var_pres('_b')<>type_of(0) | _b=0);

:: wartość zwracana
_ret:=null;
{? _ext<>0
:: rozszerzona
|| _ret:=exec('buf_utwórz','zs_typ')
?};

{? _ctx<>0
|| ZS_TYP.cntx_psh()
?};
:: szukaj domyślnego
ZS_TYP.index('DOMYSLNY');
ZS_TYP.prefix(exec('ref_firma','ustawienia'));
{? ZS_TYP.find_key('T')
:: znaleziono
|| {? _ext=0
   || _ret:=ZS_TYP.ref()
   || exec('buf_ustaw','zs_typ',_ret)
   ?}
?};
{? _ctx<>0
|| ZS_TYP.cntx_pop()
?};

_ret


\szukaj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Ustala typ zależności słuzbowych. Wyszukiwanie odbywa się zawsze w obrębie bieżącej firmmy.
::   WE: _a STRING/_SLO_KOD - symbol lub wskazanie słownika kodów
::       _b [INTEGER] - typ zwracanego wyniku: różny od zera - wskazanie tablicy nazwanej, wpp referencja
::       _c [INTEGER] - zachowanie kontekstu: różny od zera - pomiń zachowanie i odtworzenie konteksu, wpp zachowuj
::   WY: dla _a:
::       - różnego od zera wskazanie tablicy nazwanej (patrz buf_utworz)
::       - wpp wskazanie wiersza w tabeli ZS_TYP lub null
::       - ~~ w przypadku błędnego wywołania
::----------------------------------------------------------------------------------------------------------------------
:: kontrola wywołania
{? (var_pres('_a')<>type_of('') & var_pres('_a')<>type_of(null)) |
   (var_pres('_a')=type_of(null) & (_a=null | ref_tab(_a)<>SLO_KOD))
:: _a typu innego niż napis lub wskazanie wiersza w tabeli SLO_KOD
|| return()
?};
:: mapa argumentów
_slo:=_a;
_ext:=(var_pres('_b')=type_of(0) & _b<>0);
_ctx:=(var_pres('_c')<>type_of(0) | _c=0);
_pth:=(var_pres('_d')<>type_of(0) | _d=0);

:: wartość zwracana
_ret:=null;
{? _ext<>0
:: rozszerzona
|| _ret:=exec('buf_utwórz','zs_typ')
?};

{? _ctx<>0
|| ZS_TYP.cntx_psh()
?};
:: szukaj według symbolu lub wskazania
{? {? type_of(_slo)=type_of(null)
   || ZS_TYP.index('UNIQUE');
      ZS_TYP.prefix(exec('ref_firma','ustawienia'));
      ZS_TYP.find_key(_slo)
   || ZS_TYP.index('SYMBOL');
      ZS_TYP.prefix(exec('ref_firma','ustawienia'));
      ZS_TYP.find_key(_slo,)
   ?}
:: znaleziono
|| {? _ext=0
   || _ret:=ZS_TYP.ref()
   || exec('buf_ustaw','zs_typ',_ret)
   ?}
?};
{? _ctx<>0
|| ZS_TYP.cntx_pop()
?};

_ret


\slo_kod_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Przed edycją pola SLO_KOD tabeli ZS_TYP.
::   WE:
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
SLO_KOD.clear();
SLO_KOD.f_set(
   'KOD',,
   'SLO_KOD.SLO_TYP=:_a and (:_c is null or SLO_KOD.REFERENCE=:_c or SLO_KOD.REFERENCE not in ('
   '  select ZS_TYP.SLO_KOD from ZS_TYP where ZS_TYP.FIRMA=:_b'
   '))',
   exec('slo_typ','zs_typ'),exec('ref_firma','ustawienia'),ZS_TYP.SLO_KOD
);
1


\kod_nad_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Przed wyświetleniem pola KOD_NAD tabeli ZS_TYP.
::   WE:
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
ZS_TYP.efld_opt('RED','enable=%1'[$(ZS_TYP.KOD_NAD=0)],,'DOMYSLNY');
1


\kod_nad_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Przed edycją pola KOD_NAD tabeli ZS_TYP.
::   WE:
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
SLO_KOD.clear();
SLO_KOD.f_set(
   'KOD',,
   'SLO_KOD.SLO_TYP=:_a and (:_c is null or SLO_KOD.REFERENCE<>:_c) and SLO_KOD.REFERENCE in ('
   '  select ZS_TYP.SLO_KOD from ZS_TYP where ZS_TYP.FIRMA=:_b and ZS_TYP.ZS_TYP=0'
   ')',
   exec('slo_typ','zs_typ'),exec('ref_firma','ustawienia'),ZS_TYP.SLO_KOD
);
1


\domyslny_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Wartość początkowa pola DOMYSLNY tabeli ZS_TYP.
::   WE:
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
{? exec('domyslny','zs_typ')<>null || 'N' || 'T' ?}


\domyslny_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Przed wyświetleniem pola DOMYSLNY tabeli ZS_TYP.
::   WE:
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
ZS_TYP.efld_opt('RED','enable=%1'[$(ZS_TYP.DOMYSLNY<>'T')],,'KOD_NAD');
1


\domyslny_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Przed edycją pola DOMYSLNY tabeli ZS_TYP.
::   WE:
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
_acc:=1;
ZS_TYP.cntx_psh();
ZS_TYP.index('UNIQUE');
ZS_TYP.prefix(exec('ref_firma','ustawienia'));
_acc:=ZS_TYP.size();
ZS_TYP.cntx_pop();
_acc


\popraw_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Poprawienie zapisu w okienkach tabeli ZS_TYP.
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
ZS_TYP.get();
_dom:=ZS_TYP.DOMYSLNY;

ZS_DEF.cntx_psh();
ZS_DEF.index('UNIQUE');
ZS_DEF.prefix(ZS_TYP.ref());
_def:=ZS_DEF.size();
ZS_DEF.cntx_pop();

{? ZS_TYP.edit("exec('rekord_a','zs_typ')")
|| {? _def=0 | (ZS_TYP.KOD_NAD<>null & FUN.ask(
         'Dla typu "%1" zdefiniowano już zależności służbowe.\n'
         'Przypisanie typu nadrzędnego spowoduje ich usunięcie.\n\n'
         'Czy na pewno kontynuować działanie?'@
         [ZS_TYP.SLO_KOD().KOD]
      )) | (_dom='N' & ZS_TYP.DOMYSLNY='T')
   || ZS_TYP.put()
   ?}
?};
~~


\usun_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Przed usunięciem zapisu w okienkach tabeli ZS_TYP.
::   WE:
::   WY: decyzja użytkownika
::----------------------------------------------------------------------------------------------------------------------
exec('del_conf','#table',ZS_TYP)


\usun_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Usunięcie zapisu w okienkach tabeli ZS_TYP.
::   WE:
::   WY: 0
::----------------------------------------------------------------------------------------------------------------------
ZS_TYP.del();
0


\wyczysc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Usuwanie definicji zależności służbowych.
::   WE: _a ZS_TYP - wskazanie typu zależności służbowych
::   WY: 0/1 - wynik operacji: 0 - porażka, 1 - sukces
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_typ:=_a;

{? _typ=null
:: błąd wywołania
|| return(0)

|? ~ZS_DEF.lock(1)
:: błąd blokady
|| return(0)
?};

:: działanie w transakcji
_my_do:=0;
{? do_state()=0
:: brak transakcji
|| _my_do:=1;
   do()

|? do_state()<>1
:: undo lub błąd
|| return(0)
?};

_sem:=null;
:: Operacja masywna, wyłącz pielęgnację redundancji.
:: Jeśli nie uda się z jakiegoś powodu ustawić semafora,
:: to nie przerywaj - cała operacja będzie trwać dłużej.
{? exec('add','#bulk',ZS_TYP,'del',$ZS_TYP.ref())
:: udało się ustawić semafor
|| _sem:=BULK.ref()
?};

_del:="
   _test:=1;
   ZS_DEF.cntx_psh();
   ZS_DEF.index('TREE');
   ZS_DEF.prefix(_a,_b);
   _loop:=ZS_DEF.first();
   {!
   |? _loop & _test
   |! {? _c(_a,#ZS_DEF.ref(),_c)
      || _res:=ZS_DEF.del(,1);
         {? _res=0 || _test:=0
         |? _res=1 || _loop:=0
         ?}
      || _test:=0
      ?}
   !};
   ZS_DEF.cntx_pop();
   _test
";

:: kaskadowo usuwaj elementy
_test:=_del(_typ,0,_del);

:: wyłączono automatyczną aktualizację statystyk weryfikacji,
:: należy ją wykonać wprost (ZS_TYP.OK i ZS_TYP.LICZ_NOK)
{? _test<>0
|| ZS_TYP.cntx_psh();
   ZS_TYP.prefix();
   {? ZS_TYP.seek(_typ)
   || _test:=ZS_TYP.put()
   ?};
   ZS_TYP.cntx_pop()
?};

{? _sem<>null
:: Przywróć standardowe działanie
:: po udanym ustawieniu semafora.
|| exec('del_ref','#bulk',_sem)
?};

:: obsługa transakcji
{? _my_do<>0
|| {? _test=0
   || undo()
   ?};
   end()
?};
:: zwolnij blokadę
ZS_DEF.unlock();

_test


\wyczysc_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Formuła akcji "Wyczyść".
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: ostrzeż o usunięciu aktualnej definicji
{? ~FUN.ask('%1\n\n%2'[
      'Usunięta zostanie cała definicja zależności służbowych bieżącego typu.'@,
      'Czy na pewno kontynuować działanie?'@
   ])
|| return()
?};

:: operacja usunięcia kilkunastu/dziesięciu tysięcy zapisów może potrwać...
progress(,'Proszę czekać. Trwa usuwanie zależności służbowych...'@,FUN.TYT,1);
:: usuń wszystkie zależności bieżącego typu
exec('wyczysc','zs_typ',ZS_TYP.ref());
prgs_clr();
~~


\kopiuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Kopiowanie definicji zależności służbowych.
::   WE: _a ZS_TYP - wskazanie typu zależności docelowych
::       _b ZS_TYP - wskazanie typu zależności źródłowych
::   WY: 0/1 - wynik operacji: 0 - porażka, 1 - sukces
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_dst_typ:=_a;
_src_typ:=_b;

{? _dst_typ=null | _src_typ=null
:: błąd wywołania
|| return(0)

|? ~ZS_DEF.lock(1)
:: błąd blokady
|| return(0)
?};

_copy:=obj_new('DST_TYP','SRC_TYP','run');
_copy.DST_TYP:=_dst_typ;
_copy.SRC_TYP:=_src_typ;
_copy.run:="
   _ref:=null;
   ZS_DEF.ZS_TYP:=.DST_TYP;
   ZS_DEF.ZS_DEF:=_a;
   ZS_DEF.TOKEN:=exec('_tgen','zs_def');
   ZS_DEF.SCIEZKA:=_b;
   ZS_DEF.cntx_psh();
   ZS_DEF.clear();
   {? ZS_DEF.add(1)
   || _ref:=ZS_DEF.ref();
      _pth:=ZS_DEF.SCIEZKA+ZS_DEF.TOKEN
   ?};
   ZS_DEF.cntx_pop();
   {? _ref=null
::    przerwij
   || return(0)
   ?};
   _test:=1;
   {? ZS_DEF.LICZ_POD<>0
::    kopiuj podwładnych
   || ZS_DEF.cntx_psh();
      ZS_DEF.index('TREE');
      ZS_DEF.prefix(.SRC_TYP,#ZS_DEF.ref());
      _loop:=ZS_DEF.first();
      {!
      |? _loop
      |! _test:=.run(#_ref,_pth);
         _loop:=(_test & ZS_DEF.next())
      !};
      ZS_DEF.cntx_pop()
   ?};
   _test
";

:: działanie w transakcji
_my_do:=0;
{? do_state()=0
:: brak transakcji
|| _my_do:=1;
   do()

|? do_state()<>1
:: undo lub błąd
|| return(0)
?};

:: operacja masywna, wyłącz niepotrzebnie teraz obciążającą
:: kontrolę poprawności oraz pielęgnację redundancji i anomalji
ZS_DEF.trig_off('*','*');

:: iteracja po współpracownikach bez przełożonych
:: ich podwładni kopiowani będą rekurencyjnie
_test:=1;
ZS_DEF.cntx_psh();
ZS_DEF.index('TREE');
ZS_DEF.prefix(_src_typ,0);
_loop:=ZS_DEF.first();
{!
|? _loop
|! _test:=_copy.run(0,'');
   _loop:=(_test & ZS_DEF.next())
!};
ZS_DEF.cntx_pop();

:: wyłączono automatyczną aktualizację statystyk weryfikacji,
:: należy ją wykonać wprost (ZS_TYP.OK i ZS_TYP.LICZ_NOK)
{? _test<>0
|| ZS_TYP.cntx_psh();
   ZS_TYP.prefix();
   {? ZS_TYP.seek(_dst_typ)
   || _test:=ZS_TYP.put()
   ?};
   ZS_TYP.cntx_pop()
?};

:: przywróć standardowe działanie programu
ZS_DEF.trig_on('*','*');

:: obsługa transakcji
{? _my_do<>0
|| {? _test=0
   || undo()
   ?};
   end()
?};
:: zwolnij blokadę
ZS_DEF.unlock();

_test


\kopiuj_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Formuła akcji "Kopiuj".
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: ostrzeż o usunięciu bieżącej definicji
{? ~FUN.ask('%1\n\n%2'[
      'Kopiowanie zależności wybranego typu spowoduje usunięcie aktualnie zdefiniowanych.'@,
      'Czy na pewno kontynuować działanie?'@
   ])
|| return()
?};

:: wybierz typ zależności, który:
:: - został zdefiniowany w firmie,
:: - nie jest bieżącym typem,
:: - nie jest typem pochodnym
_slo_kod:=null;
SLO_KOD.cntx_psh();
SLO_KOD.clear();
SLO_KOD.f_set(
   'KOD',,
   'SLO_KOD.REFERENCE<>:_a and SLO_KOD.REFERENCE in ('
   '  select ZS_TYP.SLO_KOD as REF'
   '  from ZS_TYP'
   '  where ZS_TYP.FIRMA=:_b and ZS_TYP.ZS_TYP=0'
   ')',
   ZS_TYP.SLO_KOD,exec('ref_firma','ustawienia')
);
SLO_KOD.win_sel('WER');
{? SLO_KOD.select()
:: zapamiętaj wybrany kod
|| _slo_kod:=SLO_KOD.ref()
?};
SLO_KOD.f_clear();
SLO_KOD.cntx_pop();

{? _slo_kod=null
:: brak kodu
|| return()
?};

:: usunięcie i skopiowanie kilkunastu/dziesięciu tysięcy zapisów może potrwać...
progress(,'Proszę czekać. Trwa kopiowanie zależności służbowych...'@,FUN.TYT,1);
do();
_test:=0;
:: usuń istniejące zależności
{? exec('wyczysc','zs_typ',ZS_TYP.ref())
:: utwórz schemat dla bieżącego typu na podstawie typu właściwego dla kodu
|| {? exec('kopiuj','zs_typ',ZS_TYP.ref(),exec('szukaj','zs_typ',_slo_kod))
   || _test:=1
   ?}
?};
{? _test=0
|| undo()
?};
end();
prgs_clr();

~~


\weryfikuj_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Formuła akcji "Weryfikuj" - lista dostępnych testów zależności służbowych
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: utwórz zestaw formuł
_set:=exec('fun_set','object');

:: zachowaj stan filtra i tabel
_nfo:=exec('get','#filter',P);
OSOBA.cntx_psh();
P.cntx_psh();

exec('xxx_grp_act','personel',_set,'ZWS_PAR_PZSL','Zależności wymagające weryfikacji'@,
   'Zależności służbowe wymagające weryfikacji'@,,"params_exec('weryfikuj_zs','zs_typ');''",ZS_TYP.OK<>'T');
exec('xxx_grp_act','personel',_set,'ZWS_PAR_PZSL','Przełożeni niezatrudnieni na stanowisku kierowniczym'@,
   'Osoby posiadające podwładnych i niezatrudnione na stanowisku kierowniczym'@,,
   "params_exec('weryfikuj_stn_kier','zs_typ');''");
exec('xxx_grp_act','personel',_set,'ZWS_PAR_PZSL','Przełożeni nieprzypisani do roli "Przełożony"'@,
   'Osoby posiadające podwładnych i nieprzypisane do roli "Przełożony"'@,,
   "exec('weryfikuj_rola_przel','zs_typ');''");

_set.run('Weryfikacja zależności służbowych'@);

:: przywróć stan
OSOBA.cntx_pop();
P.cntx_pop();

exec('set','#filter',P,_nfo);

~~


\rekord_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Przed wyświetleniem wiersza ZS_TYP.
::   WE: _a INTEGER - zgodny ze specyfikacją narzędzi
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? _a=0 || return() ?};

_aid:='';
::{? ZS_TYP.OK='N'
::|| _aid+='W'
::?};
ZS_TYP.actions_grayed('WER',_aid);

ZS_TYP.efld_opt('RED','enable=1',,'KOD_NAD');
ZS_TYP.efld_opt('RED','enable=1',,'DOMYSLNY');

:: wyczyść filtr w polach
SLO_KOD.f_clear(1);
~~


\rekord_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Po edycji wiersza tabeli ZS_TYP.
::   WE:
::   WY: 1 w przypadku gdy rekord jest poprawny, akronim wymaganego pola lub 0 gdy doszło do powielenia klucza.
::----------------------------------------------------------------------------------------------------------------------
{? exec('_modb','zs_typ')
|| exec('_chk','zs_typ',-menu_txt()='popraw')
?}


\weryfikuj_zs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Formuła akcji "Weryfikuj".
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
ZS_DEF.cntx_psh();
ZS_DEF.index('OK');
ZS_DEF.prefix(ZS_TYP.ref(),'N');
ZS_DEF.first();

ZS_DEF.win_sel('LISTA');
ZS_DEF.hdr_sel('Zależności służbowe wymagające weryfikacji'@);
ZS_DEF.select();
ZS_DEF.hdr_sel();

ZS_DEF.cntx_pop();
~~


\weryfikuj_stn_kier
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DG [21.37]
:: OPIS: Weryfikacja zatrudnienia na stanowisku kierowniczym
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
ZS_DEF.cntx_psh();
ZS_DEF.prefix();
ZS_DEF.f_set(,
   'join ZS_TYP using(ZS_DEF.ZS_TYP,ZS_TYP.REFERENCE) '
   'join STN using(ZS_DEF.ST,STN.REFERENCE) '
   'join OSOBA using (ZS_DEF.OSOBA,OSOBA.REFERENCE) '
   'join P using (ZS_DEF.P,P.REFERENCE) ',
   'ZS_TYP.REFERENCE=:_a and ZS_DEF.LISC=\':_b\' and STN.K<>\':_c\'',
   ZS_TYP.ref(),'N','T'
);

{? ZS_DEF.f_first()
|| exec('zs_def_win_tmp','zs_typ','Przełożeni niezatrudnieni na stanowisku kierowniczym'@)
|| FUN.info('Wszystkie osoby posiadające podwładnych są zatrudnione na stanowisku kierowniczym.')
?};

ZS_DEF.f_clear();
ZS_DEF.cntx_pop();

1


\weryfikuj_rola_przel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DG [21.37]
:: OPIS: Weryfikacja przypisania do roli "Przełożony"
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
ZS_DEF.cntx_psh();
ZS_DEF.prefix();

_TMP:=sql(
   'select ZS_DEF.REFERENCE AS ZS_DEF, P.REFERENCE as P '
   'from ZS_DEF '
      'join ZS_TYP using(ZS_DEF.ZS_TYP, ZS_TYP.REFERENCE) '
      'join P using (ZS_DEF.P,P.REFERENCE) '
   'where ZS_TYP.REFERENCE=:_a and ZS_DEF.LISC=\':_b\'',
   ZS_TYP.ref(),'N'
);

{? _TMP.first()
|| P.cntx_psh();
   P.prefix();
   {!
   |? _err:=1;
      {? P.seek(_TMP.P,)
      || USERS.cntx_psh();
         USERS.index('OSOBA');
         USERS.prefix(P.OSOBA);
         {? USERS.first()
         || {!
            |? _err:=~exec('user_role_chk','zs_typ',USERS.KOD,'Przełożony');
               ~_err & USERS.next()
            !}
         ?};
         USERS.cntx_pop()
      ?};
      {? ~_err
      || _TMP.del()
      || _TMP.next()
      ?}
   !};
   P.cntx_pop()
?};

ZS_DEF.f_set(,
   'join ZS_TYP using(ZS_DEF.ZS_TYP,ZS_TYP.REFERENCE) ',
   'ZS_TYP.REFERENCE=:_a and ZS_DEF.LISC=\':_b\' and ZS_DEF.REFERENCE in (select :_c.ZS_DEF from :_c)',
   ZS_TYP.ref(),'N',_TMP
);

{? ZS_DEF.f_first()
|| exec('zs_def_win_tmp','zs_typ','Przełożeni nieprzypisani do roli "Przełożony"'@)
|| FUN.info('Wszystkie osoby posiadające podwładnych mają przypisaną rolę "Przełożony".')
?};

&_TMP;
ZS_DEF.f_clear();
ZS_DEF.cntx_pop();

1


\user_role_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DG [21.37]
:: OPIS: Weryfikacja przypisania użytkownika do roli
::   WE: _a - nazwa użytkownika
::       _b - nazwa roli
::   WY: 1 - rola przypisana użytkownikowi / 0 - brak przypisania roli do użytkownika
::----------------------------------------------------------------------------------------------------------------------
_user:={? var_pres('_a')=type_of('') || _a || return(0) ?};
_role:={? var_pres('_b')=type_of('') || _b || return(0) ?};

B_USRROL.cntx_psh();
B_USRROL.index('WER');
B_USRROL.prefix(exec('ref_firma','ustawienia'),_user,_role,);
_exist:={? B_USRROL.first() || 1 || 0 ?};
B_USRROL.cntx_pop();
_exist


\zs_def_win_tmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DG [21.37]
:: OPIS: Wyświetla tymczasowe okienko do selekcji
::   WE: _a - tytuł okienka tymczasowego
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_title:={? var_pres('_a')=type_of('') || _a || '' ?};

_fml:="
   ZS_DEF.cntx_psh();
   ZS_DEF.index('TREE');
   ZS_DEF.prefix(ZS_TYP.ref());
   ZS_DEF.win_sel('WER');
   ZS_DEF.select(,1);
   ZS_DEF.cntx_pop()
";
_win:=ZS_DEF.mk_sel(_title,'P',0,'zs_defqlista',1,11,22,0,'U','T',
                    0,0,0,'','','disabled','lumen');
ZS_DEF.win_fld(_win,ZS_DEF,'NAZWA','','',40,0,0,'',0,'Dane identyfikacyjne pracownika'@,,);
ZS_DEF.win_fld(_win,P,'WYDZIAL','SYMBOL','*','10,10,10',0,1,'Jednostka organizacyjna'@@,0,'Identyfikator'@,,);
ZS_DEF.win_fld(_win,P,'ST','ST','*','28,28,28',0,1,'Stanowisko'@@,0,'Krótki opis'@,,);
ZS_DEF.win_fld(_win,P,'F_ZATR','KOD','*','2,7,7',0,1,'Forma współpracy'@@,0,'Kod formy współpracy'@,,);
ZS_DEF.win_fld(_win,P,'ZA','','','3,7,7',0,0,'',0,'',2,,"mb_exec('''T''')","mb_exec('''N''')","");
ZS_DEF.win_act(_win,1,'Okienko','','','',"exec('okienko_b','zs_def')","exec('okienko_a','zs_def')",0,0,"","",'',0,
               'mobile=1,target=window');
ZS_DEF.win_act(_win,0,'Formuła','Idź do'@@,'','Przejście do wybranego rekordu'@,"",
               _fml,1,0,"","",'I',0,'mobile=1,target=record');
ZS_DEF.win_act(_win,0,'Formuła','Odśwież'@@,'','Odświeżenie listy rekordów'@,"",
               "{? ZS_DEF.f_active()>0 || ZS_DEF.f_rfresh() ?}",,0,"","",'O',0,'mobile=1,target=record');
task_attach('ZWS_PAR_PZSL');
ZS_DEF.win_act(_win,0,'#F3','','','',"exec('zs_def_ustaw','szukaj')","exec('zs_def_wnd','szukaj')",0,0,"","",'',0,
               'mobile=1,target=window');
ZS_DEF.win_act(_win,0,'Menu','Szukaj'@@,'','',"","",0,0,"","",'S',0,'mobile=1,target=record');
ZS_DEF.win_act(_win,0,'Formuła','Szukaj dokładnie'@@,'#S','',"exec('zs_def_ustaw','szukaj')",
               "exec('zs_def_d','szukaj')",0,0,"","",'S',0,'mobile=1');
ZS_DEF.win_act(_win,0,'Formuła','Szukaj &kontekstowo'@@,'#S','',"exec('zs_def_ustaw','szukaj')",
               "exec('zs_def_k','szukaj')",0,0,"","",'K',0,'mobile=1');
ZS_DEF.win_act(_win,0,'Kolejność','','','',"","",0,0,"","",'',0,'mobile=1,target=window');
ZS_DEF.win_act(_win,0,'Wyświetl','','','',"exec('wyswietl_b','zs_def')","",0,0,"","",'',0,'mobile=1,target=record');
ZS_DEF.win_act(_win,0,'Okienko','','','',"exec('okienko_b','zs_def')","exec('okienko_a','zs_def')",0,0,"","",'',0,
               'mobile=1,target=window');
ZS_DEF.win_act(_win,0,'Rekord','','','',"exec('rekord_b','zs_def',_a)","",0,0,"","",'',0,'mobile=1,target=window');
ZS_DEF.win_sel(_win);
ZS_DEF.select()

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:38 1cbcc20158032254dbbcb7fd3b6f2c38810dfa861db6403b6244211d27e57bee01abfdfb9d7029ac6c605d62f09411a6f29d7fc09c5775ea60383a45496cfd7ba5228b67036c1a057e09a0fa7ca6a50895f6c212eb8afcec478c41ab92cb7e9db77032aae3bd607d883e952d3d5c9f8616613ada7ccec7215ec4ccec03efc526
