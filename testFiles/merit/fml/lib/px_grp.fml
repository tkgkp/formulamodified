:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku:  px_grp.fml [12.10]
:: Utworzony: 2011-07-19
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Obiekty grupujace (elementy kolejki) w planie strategicznym (wielowymiarowym planie pojemnosciowym)
::======================================================================================================================


\clone_current
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Klonuje obiekt grupujacy i dodaje go do nowej wersji planu
::       Kontekst pracy - obiekt grupujacy ktory ma byc sklonowany
::   WE: _a - PX_VER.ref()
::       [_b] - [0] - nie przepinac pozycji planu ze zrodla do klonu
::               1 - przepinac pozycje planu ze zrodla do klonu
::       [_c] - REAL - tm_stamp czasu ktory jest granica okreslajaca ze tylko ponizej tej granicy przepinam pozycje planu
::       [_d] - INTEGER - 0  - nie klonowac komunikatow powiazanych z PX_GRP
::                       [1] - klonowac komunikaty powiazane z PX_GRP
::       [_e] - INTEGER - 0/[1] - czy wiązać ze sobą grupy
::   WY: 0 / 1 -
::----------------------------------------------------------------------------------------------------------------------
_dest_ver:=_a;
_result:=0;

_move_pxpoz:=0;
_time_border:=0;

{? var_pres('_b')>0
|| _move_pxpoz:=_b
?};
{? var_pres('_c')=type_of(0)
|| _time_border:=_c
?};
_komm_clone:=1;
{? var_pres('_d')=type_of(0)
|| _komm_clone:=_d
?};
_tie:=1;
{? var_pres('_e')=type_of(0)
|| _tie:=_e
?};

_current:=PX_GRP.ref();

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

_msg:='Duplikowanie obiektu grupującego: '+PX_GRP.SYMBOL;
pxkomm.sect_beg(_msg);

PX_GRP.cntx_psh();
PX_GRP.clear();
PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');
{? _tie>0
|| PX_GRP.UID_SRC:=PX_GRP.UID
?};

PX_GRP.UID:=exec('uid','#blank');
PX_GRP.PX_VER:=_dest_ver;

:: Kasuje informacje ze sa kumunikaty, bo komunikaty nie sa klonowane razem z grupa
PX_GRP.KOM_ERR:='N';
PX_GRP.KOM_INFO:='N';
PX_GRP.KOM_WARN:='N';

_result:=PX_GRP.add();

{? _result>0
|| _dest_grp:=PX_GRP.ref();

   {? _move_pxpoz=1
   ||
::    1. Zablokowane pozycje planu
      exec('px_poz_grp_move','px_poz',_current,_dest_grp,exec('status_blk','px_poz'),_time_border);
::    2. Wykonane pozycje planu
      exec('px_poz_grp_move','px_poz',_current,_dest_grp,exec('status_wyk2','px_poz'),_time_border);
::    3. Wykonywane pozycje planu
      exec('px_poz_grp_move','px_poz',_current,_dest_grp,exec('status_wyk1','px_poz'),_time_border);
::    4. Porzucone pozycje planu
      exec('px_poz_grp_move','px_poz',_current,_dest_grp,exec('status_skipped','px_poz'),_time_border)
   ?};

:: po sklonowaniu klonuje tez polaczenia grupujace
   PX_CONN.prefix(_current);
   {? PX_CONN.first()
   || {!
      |? exec('clone_current','px_conn',_dest_ver,_dest_grp);
         PX_CONN.next()
      !}
   ?};

:: klonowanie punktów czasowych
   PX_POINT.cntx_psh();
   PX_POINT.index('PX_GRP');
   PX_POINT.prefix(_current);
   {? PX_POINT.first()
   || {!
      |? exec('clone','px_point',_dest_grp);
         PX_POINT.next()
      !}
   ?};
   PX_POINT.cntx_pop();

:: klonowanie powiazań ze zleceniami
   PX_ZL.cntx_psh();
   PX_ZL.index('PX_GRP');
   PX_ZL.prefix(_current);
   {? PX_ZL.first()
   || {!
      |? exec('clone','px_zl',_dest_grp);
         PX_ZL.next()
      !}
   ?};
   PX_ZL.cntx_pop();

:: klonowanie komunikatow
   {? _komm_clone>0
   ||
      _argskom:=exec('clone_a','px_komm');
      _argskom.PX_GRP:=_dest_grp;
      _argskom.PX_VER:=_dest_ver;
      _argskom.PX_POZ:=null();
      _argskom.PX_CUP:=null();
      exec('clone_grp','px_komm',_current,_argskom)
   ?};

   {? _tie>0
   ||
::    Aktualizuje status grupy
      exec('status_rebuild','px_grp',PX_GRP.ref())
   ?}

|| _msg:='Nie udało się dodanie obiektu grupującego: '+PX_GRP.SYMBOL;
   pxkomm.error(_msg)
?};
pxkomm.sect_end();
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
_result


\clone_all
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Klonuje wszystkie obiekty grupujace danej wersji i przypinam je do nowej wersji
::   WE: _a - PX_VER.ref() - wersja zrodlowa
::       _b - PX_VER.ref() - wersja docelowa
::       [_c] - [0] - nie przepinac pozycji planu ze zrodla do klonu
::               1 - przepinac pozycje planu ze zrodla do klonu
::       [_d] - REAL - tm_stamp czasu ktory jest granica okreslajaca ze tylko ponizej tej granicy przepinam pozycje planu
::       [_e] - INTEGER - 0  - nie klonowac komunikatow powiazanych z PX_GRP
::                       [1] - klonowac komunikaty powiazane z PX_GRP
::       [_f] - INTEGER - 0/[1] - czy wiązać ze sobą grupy
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_source:=_a;
_dest:=_b;
_move_pxpoz:=0;
_time_border:=0;

{? var_pres('_c')>0
|| _move_pxpoz:=_c
?};
{? var_pres('_d')=type_of(0)
|| _time_border:=_d
?};
_komm_clone:=1;
{? var_pres('_e')=type_of(0)
|| _komm_clone:=_e
?};
_tie:=1;
{? var_pres('_f')=type_of(0)
|| _tie:=_f
?};

_ok:=1;
:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

PX_VER.cntx_psh();
PX_GRP.cntx_psh();
PX_GRP.index('LP');
_msg:='Duplikowanie obiektów grupujących z wersji: '+$_source+' do wersji: '+$_dest;
pxkomm.sect_beg(_msg);
:: najpierw usuwam wszystko co bylo w wersji docelowej
_msg:='Usuwanie obiektów grupujących w wersji docelowej.';
pxkomm.sect_beg(_msg);
PX_GRP.prefix(_dest);
{? PX_GRP.first()
|| {!
   |? _ok:=exec('delete','px_grp',PX_GRP.ref());
      PX_GRP.first() & _ok>0
   !}
?};
pxkomm.sect_end();
{? _ok>0
||
   PX_GRP.index('LP');
   PX_GRP.prefix(_source);
   {? PX_GRP.first()
   || {!
      |?
         _ok:=exec('clone_current','px_grp',_dest,_move_pxpoz,_time_border,_komm_clone,_tie);
         PX_GRP.next() & _ok>0
      !}
   ?}
?};

{? _ok>0
|| _result:=1
?};

:: Uzupelnia powiazania miedzy grupami obiektow
exec('UpdatePX_VER','px_con_g',_dest);

pxkomm.sect_end();
PX_GRP.cntx_pop();
PX_VER.cntx_pop();
_result


\add
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Dodaje do tabeli PX_GRP jeden rekord
::   WE: _a - _args - exec('blank_a','px_grp') - argumenty na blank
::       _b - PX_OBJ.ref() - obiekt planowany z ktorym powiazac obiekt grupujacy
::       [_c] - INTEGER - 0/[1] - czy podczas sprawdzania obiektu porownywac zestaw startowy z obecnym
::       [_d] - INTEGER - 0/[1] - czy podczas sprawdzania obiektu dokonywać sprawdzeń powiązań zamówienia i zlecenia
::   WY: 0 / 1 - sukces lub porazka
::----------------------------------------------------------------------------------------------------------------------
_args:={? _>=1 || _a || exec('blank_a','px_grp') ?};

_px_obj:=null();
{? _>1
|| _px_obj:=_b
?};

_set_chk:=1;
{? var_pres('_c')=type_of(0)
|| _set_chk:=_c
?};

_tie_chk:=1;
{? var_pres('_d')=type_of(0)
|| _tie_chk:=_d
?};

_result:=0;
_can_continue:=1;

_args_conn:=exec('buffer','px_conn');
_args_conn.blank();

:: Sprawdzam czy mozna dodac PX_CONNa jezeli bede go dodawal
{? _px_obj<>null()
|| _args_conn.PX_VER:=_args.PX_VER;
   _args_conn.PX_OBJ:=_px_obj;
   _args_conn.ILOSC:=_args.ILOSC;
   _args_conn.M:=exec('FindAndGet','#table',PX_OBJ,_px_obj,,"PX_OBJ.M",null);
   _args_conn.LP_GRP:=1;
   _can_continue:=exec('can_add','px_conn',_args_conn,2,_set_chk,_tie_chk)
?};

{? _can_continue>0
||
   PX_GRP.blank();
   exec('blank','px_grp',_args);
   _result:=PX_GRP.add();

:: jesli udalo sie dodac obiekt grupujacy to tworze tez polaczenie grupujace
   {? _result>0 & _px_obj<>null()
   || _args_conn.PX_GRP:=PX_GRP.ref();
      PX_CONN.cntx_psh();
      PX_CONN.clear();
      exec('add','px_conn',_args_conn);
      PX_CONN.cntx_pop();

::    Stempluje modyfikacje kolejki w wersji
      exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER)
   ?}
?};
_result


\blank_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Tablica parametrow dla blank
::   WE: --
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PX_VER',
               'SYMBOL',
               'NAZWA',
               'ILOSC',
               'JM',
               'DIR',
               'PX_TEX',
               'PL_FORCE',
               'STARTD',
               'STARTDr',
               'STARTT',
               'ENDD',
               'ENDDr',
               'ENDT',
               'LP_Q',
               'TM_START',
               'TM_END',
               'SET_SRC',
               'M'
               );
_args.PX_VER:=null();
_args.SYMBOL:='Domyślny symbol';
_args.NAZWA:='Domyślny opis';
_args.ILOSC:=-1;
_args.JM:=null();
_args.DIR:=1;
_args.PX_TEX:=null();
_args.PL_FORCE:='N';
_args.STARTD:=date(0,0,0);
_args.STARTDr:=null();
_args.STARTT:=time(0,0,0);
_args.ENDD:=date(0,0,0);
_args.ENDDr:=null();
_args.ENDT:=time(0,0,0);
_args.LP_Q:=-1.0;
_args.TM_START:=0;
_args.TM_END:=0;
_args.SET_SRC:=null();
_args.M:=null();
:: zwracamy deklaracje parametrow
_args


\blank
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Przypisuje wartosci poczatkowe dla rekordu PX_GRP
::   WE: _a - _args
::----------------------------------------------------------------------------------------------------------------------
_args:={?_=1 || _a || exec('blank_a','px_grp') ?};

PX_GRP.UID:=exec('uid','#blank');
PX_GRP.PX_VER:=_args.PX_VER;

_lp:=1;
{? _args.LP_Q<>-1
|| _lp:=_args.LP_Q
|| PX_GRP.cntx_psh();
   PX_GRP.index('LP');
   PX_GRP.prefix(_args.PX_VER,'Z');
   {? PX_GRP.last()
   || _lp:=PX_GRP.LP_Q+1
   ?};
   PX_GRP.cntx_pop()
?};

PX_GRP.LP_Q:=_lp;
PX_GRP.SYMBOL:=_args.SYMBOL;
PX_GRP.NAZWA:=_args.NAZWA;
PX_GRP.ILOSC:=_args.ILOSC;
PX_GRP.JM:=_args.JM;
PX_GRP.DIR:=_args.DIR;
PX_GRP.PX_TEX:=_args.PX_TEX;

PX_GRP.STARTD:=exec('get','daty',_args.STARTD);
PX_GRP.STARTT:=_args.STARTT;
PX_GRP.ENDD:=exec('get','daty',_args.ENDD);
PX_GRP.ENDT:=_args.ENDT;
PX_GRP.PL_FORCE:=_args.PL_FORCE;
PX_GRP.SET_SRC:=_args.SET_SRC;
PX_GRP.M:=_args.M;
~~


\can_add
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy mozna dodac danego PX_GRP do kolejki
::   WE: _a - _args - tablica nazwana - exec('blank_a','px_grp')
::       [_b] - INTEGER - tryb dialogowania:
::                                            -1 - bez dialogu, bez komunikatow
::                                            [0] - komunikaty do KOMM
::                                             1 - dialog na ekran
::   WY: 0 - nie mozna dodac takiego PX_GRP
::       1 - wszystko jest ok - mozna dodawac
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_dialog:=0;

{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_result:=0;
_can_continue:=0;
_msg:='Nie można dodać do kolejki grupy: %1.'@[_args.SYMBOL];

:: 1. Sprawdzam czy przepis jest poprawny
_can_continue:=exec('conns_ok','px_tex',_args.PX_TEX);
{? _can_continue=0
|| _msg+=' Powód: nieprawidłowe powiązania etapów w przepisie planistycznym'@;
   {? _dialog>0
   || FUN.emsg(_msg)
   |? _dialog=0
   || KOMM.add(_msg,2)
   ?}
?};

{? _can_continue>0
|| _result:=1
?};
_result


\grp_stmp_trig
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Trigger przed add() i przed put() w tabeli PX_GRP. Automatycznie nawija pola:
::       PX_GRP.TM_END
::----------------------------------------------------------------------------------------------------------------------
{? PX_GRP.STARTD<>null()
|| PX_GRP.TM_START:=tm_stamp( PX_GRP.STARTD().DATA~1,
                           DATY.DATA~2,
                           DATY.DATA~3,
                           PX_GRP.STARTT~1,
                           PX_GRP.STARTT~2,
                           PX_GRP.STARTT~3,
                           0)
|| PX_GRP.TM_START:=0
?};

{? PX_GRP.ENDD<>null()
|| PX_GRP.TM_END:=tm_stamp(PX_GRP.ENDD().DATA~1,
                           DATY.DATA~2,
                           DATY.DATA~3,
                           PX_GRP.ENDT~1,
                           PX_GRP.ENDT~2,
                           PX_GRP.ENDT~3,
                           0)
|| PX_GRP.TM_END:=0
?};
1


\dnd_init
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Definiuje mechanizm d'n'd dla tabeli PX_GRP (PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT)
::   WE: [_a] - 0=definiowanie (domyslnie), 1=usuwanie
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _delete:=_a || _delete:=0 ?};
{? var_pres('PxSelect')>0
|| {? var_pres('Pxgrp',PxSelect)>0
   ||
      {? PX_VAR.EDIT_QUE>0
      ||
         PxSelect.Pxgrp.TAB.dnd_sel(PxSelect.Pxgrp.WERT,,
                        'records.PX_OBJ',
                        "
                           exec(\'dnd_action\',\'px_grp\')
                        "
                        )
      || PxSelect.Pxgrp.TAB.dnd_sel(PxSelect.Pxgrp.WERT,,'records.PX_OBJ',"")
      ?}
   ?}
?};
~~


\dnd_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja na dnd
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=dnd_info('dropped_records');
_dest_rec:=dnd_info('dest_record');
{? type_of(_tab)=type_of(~~) || return(0) ?};

_result:=0;
_can_continue:=1;

_one_ver:=exec('is_one_version','px_param');
_drop_grp:=null();
{? _dest_rec<>null()
||
   PxSelect.Pxgrp.TAB.cntx_psh();
   PxSelect.Pxgrp.TAB.clear();
   {? PxSelect.Pxgrp.TAB.seek(_dest_rec)
   ||
      {? _one_ver>0
      || _drop_grp:=PX_GRPS.PX_GRP
      || {? PX_GRP.seek(PxSelect.Pxgrp.TAB.PX_GRPI,8+PxSelect.Pxgrp.TAB.PX_GRPI)
         || _drop_grp:=PX_GRP.ref()
         ?}
      ?}
   || FUN.emsg('Nie znaleziono gałęzi, przenoszenie zostaje przerwane.'@);
      _can_continue:=0
   ?};
   PxSelect.Pxgrp.TAB.cntx_pop();
   ~~
?};

_grupa:=0;
{? _tab.size()>1
|| KOMM.init(250,,'Dodawanie obiektów do planu strategicznego.'@);
   _grupa:=1;
   _can_continue:=exec('to_queue_act_gr1','px_obj',_tab,_drop_grp)
?};

{? _can_continue>0
||
   PX_OBJ.cntx_psh();
   PX_OBJ.clear();
   {? _tab.first()
   || {!
      |?
         {? PX_OBJ.seek(_tab.REF,)
         || exec('to_queue_act','px_obj',_dest_rec,_grupa)
         ?};
         _tab.next()
      !}
   ?};
    PX_OBJ.cntx_pop()
?};
{? _can_continue>0 & _grupa>0
|| exec('to_queue_act_gr2','px_obj');
   ~~
?};
grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT);
~~


\px_grp_rkprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed rekord w oknie PX_GRP.WER
::----------------------------------------------------------------------------------------------------------------------
PX_OBJ.cntx_psh();
_result:=exec('rekprzed','color','PX_GRP#01#');
PX_VAR.GROPS:=PX_GRP.GROPS;
PX_OBJ.cntx_pop();
_result


\px_grp_bre
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wlasciwa akcja przed rekord w oknie PX_GRP.WER
::   WE: [_a] - INTEGER - czy praca na jednej wersji?
::       [_b] - rekord PX_GRP, jeżeli nie podany to na podstawie kontekstu tabeli PX_GRPS
::       [_c] - uchwyt do tabeli której dotyczy, jeżeli nie podany to cur_tab
::----------------------------------------------------------------------------------------------------------------------
_one_ver:=exec('is_one_version','px_param');
{? var_pres('_a')=type_of(0)
|| _one_ver:=_a
?};
_tab:=cur_tab(1,1);
{? var_pres('_c')>100
|| obj_del(_tab);
   _tab:=_c
?};

_px_grp:=PX_GRPS.PX_GRP;
{? var_pres('_b')=type_of(PX_GRP.ref())
|| _px_grp:=_b
?};
_sim_mod:=0;
_sim_del:=0;
{? _one_ver>0
|| {? _tab=PX_CONN
   || PX_OBJ.cntx_psh();
      PX_VAR1.T_REAL:=$PX_CONN.PX_OBJ().ENDD().DATA;
      _sim_mod:={? PX_CONN.PX_GRP().SIM_MOD='T' || 1 ?};
      _sim_del:={? PX_GRP.SIM_DEL='T' || 1 ?};
      PX_OBJ.cntx_pop()
   || PX_GRP.cntx_psh();
      PX_GRP.prefix();
      {? PX_GRP.seek(_px_grp)
      || _sim_mod:={? PX_GRP.SIM_MOD='T' || 1 ?};
         _sim_del:={? PX_GRP.SIM_DEL='T' || 1 ?};
         PX_VAR1.C_ILOSC:=0;
         PX_CONN.cntx_psh();
         PX_CONN.index('PX_GRP');
         PX_CONN.prefix(_px_grp);
         _loop:=PX_CONN.first();
         {!
         |? _loop
         |!
            PX_VAR1.C_ILOSC+=PX_CONN.ILOSC;
            _loop:=PX_CONN.next()
         !};
         PX_CONN.cntx_pop();
         PX_VAR1.JM:=exec('pxgrpjm','px_grp',_px_grp);
         PX_VAR1.T_REAL:=exec('pxgrptreal','px_grp',_px_grp);
         _prefix_mode:=exec('poz_prefix_mode','px_grp',_px_grp);
         {? _prefix_mode='SOURCE'
         ||
            PX_GRP.cntx_psh();
            PX_GRP.index('UID');
            PX_GRP.prefix(PX_GRPS.PX_GRP().UID_SRC);
            PX_VAR1.T_PLAN:=
               {? PX_GRP.first()
               || PX_POZ.index('TM_GRP2');
                  PX_POZ.prefix(PX_GRP.ref());
                  {? PX_POZ.last()
                  || tm_form(PX_POZ.TM_END)
                  || '<brak poz>'
                  ?}
               || ''
               ?};
            PX_GRP.cntx_pop()
         || PX_POZ.index('TM_GRP2');
            PX_POZ.prefix(PX_GRPS.PX_GRP);
            PX_VAR1.T_PLAN:=
               {? PX_POZ.last()
               || tm_form(PX_POZ.TM_END)
               || ''
               ?}
         ?};
         PX_VAR1.ZNACZNIK:={? PX_GRPS.PX_GRP().DIR=-1 || exec('txt_plan_bck','px_param') || exec('txt_plan_fwd','px_param') ?};
         PX_VAR1.DIR_SET:={? PX_GRPS.DIR=-1 || exec('txt_plan_bck','px_param') || exec('txt_plan_fwd','px_param') ?};
         PX_VAR1.CZY_SETS:={? PX_GRPS.PX_SET=PX_GRPS.PX_GRP().SET_SRC || 'T' || 'N' ?}
      ?};
      PX_GRP.cntx_pop()
   ?}
?};
_grp_ref:=null();
{? _sim_del>0
|| 'PX_GRP#01#04'
|? _sim_mod>0
|| 'PX_GRP#01#03'
|? ~exec('mainversion_vie','px_ver')
|| 'PX_GRP#01#01'
|?
   _obiekt:=
      {? _one_ver>0
      || PxSelect.Pxgrp
      || {? var_pres('Pxgrp',PxSelect)>0 & _tab=PxSelect.Pxgrp.TAB || PxSelect.Pxgrp || PxSelect.Pxgrp1 ?}
      ?};

   _px_obj:={? _one_ver>0
            || ''
            || {? var_pres('_obiekt')>100
               || _obiekt.TAB.PX_OBJ
               || ''
               ?}
            ?};
   {? _px_obj<>''
   ||
:: Nie kolorujemy pozycji dla obiektu
      0
   ||
::    Czy jest co najmniej jedna pozycja w planie glownym dla grupy obiektow
      _ok:=0;

      PX_GRP.clear();
      _px_grp:={? _one_ver>0
               || $_px_grp
               || {? var_pres('_obiekt')>100
                  || _obiekt.TAB.PX_GRPI
                  || ''
                  ?}
               ?};
      {? _px_grp<>'' & PX_GRP.seek(_px_grp,8+_px_grp)
      || {? _one_ver=0
         || _obiekt.TAB.STATUS:=PX_GRP.STATUS;
            _obiekt.TAB.put()
         ?};
         _prefix_mode:=exec('poz_prefix_mode','px_grp');
         {? _prefix_mode='SOURCE'
         ||
            PX_GRP.index('UID');
            PX_GRP.prefix(PX_GRP.UID_SRC);
            {? PX_GRP.first()
            || _grp_ref:=PX_GRP.ref();
               PX_POZ.cntx_psh();
               PX_POZ.index('TM_GRP');
               PX_POZ.prefix(PX_GRP.ref());
               _ok:=PX_POZ.first();
               PX_POZ.cntx_pop();
               ~~
            ?}
         || _grp_ref:=PX_GRP.ref();
            PX_POZ.cntx_psh();
            PX_POZ.index('TM_GRP');
            PX_POZ.prefix(PX_GRP.ref());
            _ok:=PX_POZ.first();
            PX_POZ.cntx_pop();
            ~~
         ?}
      ?};
      _ok
   ?}
||
   'PX_GRP#01#02'
|? _grp_ref<>null() & exec('is_grop_member_planned','px_grop',_grp_ref)
|| 'PX_GRP#01#05'
|| ''
?}


\px_grp_legenda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Legenda w oknie PX_GRP.WER
::----------------------------------------------------------------------------------------------------------------------
{? exec('is_one_version','px_param')
|| _Tab:=exec('tab','px_grps');
   {? _Tab.PX_CONN<>''
   || exec('legenda','color'
         ,'@PX_GRP#T_REAL#WIN#01'
         ,'@PX_KOMM#01#'
         ,'@PX_GRP#01#'
      )
   || exec('legenda','color'
         ,'@PX_GRP#T_REAL#WIN#01'
         ,'@PX_GRP#01'
         ,'@PX_GRP#02'
         ,'@PX_KOMM#01#'
      )
   ?}
|| exec('legenda','color'
      ,'PX_GRP#01#'
      ,'@PX_GRP#T_REAL#WIN#01'
      ,'@PX_GRP#01'
      ,'@PX_GRP#02'
:      ,'@PX_GRP#TXT#WIN#'
      ,'@PX_KOMM#01#'
    )
?}


\px_que_accept
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC / MBUILDER
::  UTW: WH [12.10]
:: OPIS: Akceptuje kolejke nalezaca do danej wersji. Uruchamia automatyczny algorytm planowania
::   WE: _a - PX_VER.ref() - docelowa wersja planu ktorej kolejke akceptuje
::       _b - czy odswiezac po powrocie okno PX_KONT.PX_WER*
::----------------------------------------------------------------------------------------------------------------------
_dest:=_a;
_refresh:=_b;

{? ~exec('px_que_ctr','px_grp',_dest) || return() ?};

_alert:=exec('get','#params',500355,2);

_can_continue:=1;

:: Odswiezam kolejke, zeby pokazac czy sa komunikaty czy nie
exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp);
:: Odswiezam okno z kolejka
grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT);

{? _can_continue>0
||
   _txt1:='Czekaj na przeliczenie — wersja planu zostanie przeliczona\n'
              'w bieżącym procesie, następnie zostanie wyświetlona symulacja,\n'
              'którą będzie można obejrzeć i zaakceptować.'@;
   _txt2:='Przeliczaj w tle — wersja planu zostanie przeliczona\n'
              'w osobnym procesie, następnie będzie można ją obejrzeć\n'
              'i zaakceptować z poziomu obszaru \'ZWS_ADM Administracja\''@;
   {? _alert='T'
   || _choice:=FUN.choice('Wybierz tryb przeliczania planu:'@+'\n\n'+_txt1+'\n\n'+_txt2,,
                          'Czekaj na przeliczenie'@,'Przeliczaj w tle'@)
   || _choice:=FUN.ask('Czy uruchomić przeliczanie planu?'@+'\n\n'+_txt1)
   ?};
   {? _choice=1
   ||
::    biezaca sesja
      _argsplan:=exec('px_ver_plan_a','px_logix');
      _argsplan.DEST:=_dest;
      _argsplan.VIEW_MODE:=2;
      _argsplan.EDIT:=-1;
      _can_continue:=exec('px_ver_plan','px_logix',_argsplan);

::    jesli przeliczenie planu zakonczone niepowodzeniem to sprzatam na wszelki wypadek
::    pozostalosci po multiprogressie
      {? _can_continue=0
      || clr_sel()
      ?};

::    warunek, czy odswiezac zakladke glownego panelu planowania
      {? _refresh
      ||
         {? exec('tree_kont','px_param')
         || grp_disp(PX_KONT,'PX_WERT',1)
         || grp_disp(PX_KONT,'PX_WER',1)
         ?}
      ?};
::    warunek, czy odswiezac zawartosc zakladek 'Obiekty' i 'Zasoby'
      {? exec('get','#params',8059,,OPERATOR.USER)='T'
      ||
         PxSelect.Tab_OBJ.reload();
         PxSelect.Tab_KONT.reload()
      ?}
   |? _choice=2
   ||
::    watek w alercie
      PX_VER.cntx_psh();
      PX_VER.clear();
      {? PX_VER.seek(_dest)
      ||
::       Wykonuje aktualizacje i sprawdzenie kolejki
         _can_continue:=exec('queue_update','px_logix',PX_VER.ref());
         {? _can_continue>0
         ||
::          Inicjuję obiekt w którym będę przechowywał refy zablokowanych przepisów na czas przeliczania
            _locked_tex:=exec('ref_table','#table');

            _can_continue:=exec('queue_check','px_logix',PX_VER.ref(),,,_locked_tex);

::          Odblokowywuje wszystkie zablokowane przepisy
            _tab:=_locked_tex.tab;
            _tab.cntx_psh();
            _tab.clear();
            _unlock_res:=exec('lock_result','px_tex');
            {? _tab.first()
            || {!
               |?
                  {? var_pres('_alias')>100
                  || obj_del(_alias)
                  ?};
                  _alias:=ref_tab(_tab.SQL);
                  {? type_of(_alias)>100
                  || _unlock_res.TAB:=2-!_alias
                  || _unlock_res.TAB:=''
                  ?};
                  _unlock_res.NAME:=_tab.NAME;
                  _unlock_res.REF:=_tab.REF;
                  exec('unlock','px_tex',_unlock_res);
                  _tab.next()
               !}
            ?};
            _tab.cntx_pop()

         || FUN.emsg('Aktualizacja elementów kolejki zakończona niepowodzeniem.'@)
         ?};

         {? _can_continue>0
         ||
::          Od razu zmieniam status wersji na przeliczana, zeby mi jej nie wycielo
            PX_VER.STATUS:=exec('status_pending','px_ver');
            PX_VER.put();

::          Odblokowuje wersje dla alerta
            exec('unlock','px_ver',PX_VER.ref());

            PX_TASK.cntx_psh();
            PX_TASK.index('PX_VER');

            exec('add','px_task',_dest);
            PX_TASK.prefix(_dest);
            {? PX_TASK.first()
            || exec('task_go','px_task',PX_TASK.ref(),0)
            ?};
            PX_TASK.cntx_pop()
         ?}
      ?};
      PX_VER.cntx_pop();
      PX_VER.get()
   ?}
?};

:: Odswiezam kolejke, zeby pokazac czy sa komunikaty czy nie
exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp);
:: Odswiezam okno z kolejka
grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT);

~~


\px_grp_tmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: Utworzenie tabeli tymczasowej na podstawie PX_GRP
::       Kontekst wywolania: PxSelect.VER_QUE albo PxSelect.VER_QUE1 (w zaleznosci od parametru _a)
::   WE: [_a] - 0 (domyslnie) podstawowa kolejka, 1 - kopia kolejki
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _kopia:=_a || _kopia:=0 ?};

:: ukrywamy akcje - standardowe z okna obiektu jtree (Dolacz, Zmiany):
_hide:='DZ:DZ';

:: ukrywamy akcje, gdy wyłączone redagowanie (Popraw, pOrządkuj, Blokuj, odbloKuj, usuń z plAnu, pRzesuń)
:: oraz gdy kopia:
{? PX_VAR.EDIT<>1 | _kopia | ~exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPLA')
|| _hide:='POUBKAR'+_hide
?};

:: ukrywamy akcje dla widoku w zakladkach
{? exec('queue_in_tabs','px_param') || _hide:='T'+_hide ?};

{? _kopia || _hide:='M'+_hide+'M' ?};

:: UWAGA: w formułach dotyczących porównywania kolejek actions() jest wpisane jawnie, więc w razie modyfikacji
::        w tym miejscu, trzeba zmodyfikować również exec('queue_select','px_grp')

_debug:=0;
PxSelect.mask:=PX_GRP.name();

($('PxSelect.Pxgrp'+{? _kopia || '1' || '' ?}))():=obj_new(@.CLASS.TREEVIEW,_hide,_debug);
_obiekt:={? _kopia || PxSelect.Pxgrp1 || PxSelect.Pxgrp ?};
_obiekt.KOPIA:=_kopia;

_obiekt.fld('UID','STRING[20]','Unikalny symbol'@, 11,0,1,0);
_obiekt.fld('TYP','STRING[8]','Typ węzła'@, 11,0,1,0);
_obiekt.fld('PX_GRPI','STRING[16]','$PX_GRP', 11,0,1,0);
_obiekt.fld('PX_CONN','STRING[16]','$PX_CONN', 11,0,1,0);
_obiekt.fld('LP_Q','REAL','LP grupujące'@, 3,0,1,0);
_obiekt.fld('SYMBOL','STRING[60]','Symbol'@, 20,0,1,0);
_obiekt.fld('NAZWA','STRING[60]','Nazwa'@, 20,0,1,0);
_obiekt.fld('M','STRING[100]','Materiał'@, 20,0,1,0);
_obiekt.fld('ILOSC','REAL','Ilość'@, 10,ST.DOKL,1,0);
_obiekt.fld('DIR','STRING[2]','Zwrot'@, 3,0,1,0);
_obiekt.fld('BLK','STRING[1]','Blokada'@, 2,0,1,0);
_obiekt.fld('PLAN_OPR','STRING[1]','Plan operacyjny'@, 2,0,1,0);
_obiekt.fld('PX_TEX','REAL','Przepis planowania'@, 3,0,1,0);
_obiekt.fld('STARTD','REAL','Początek planu [data]'@, 11,0,1,0);
_obiekt.fld('STARTT','STRING[8]','Początek planu [godzina]'@, 8,0,1,0);
_obiekt.fld('TM_START','REAL','Początek planu [tm_stamp]'@, 24,0,1,0);
_obiekt.fld('ENDD','REAL','Koniec planu [data]'@, 11,0,1,0);
_obiekt.fld('ENDT','STRING[8]','Koniec planu [godzina]'@, 8,0,1,0);
_obiekt.fld('TM_END','REAL','Koniec planu [tm_stamp]'@, 24,0,1,0);
_obiekt.fld('C_ILOSC','REAL','Ilość'@, 10,ST.DOKL,0,1);
_obiekt.fld('LP_GRP','REAL','LP w grupie'@, 3,0,1,0);
_obiekt.fld('PX_OBJ','STRING[16]','wskazanie na PX_OBJ', 11,0,1,0);
_obiekt.fld('JM','STRING[10]','jm'@, 5,0,0,0);
_obiekt.fld('T_REAL','STRING[10]','Termin realizacji'@,-11,0,0,0);
_obiekt.fld('T_QUEUE','STRING[10]','Planowana realizacja'@,10,0,1,0);
_obiekt.fld('T_PLAN','STRING[19]','Planowana realizacja'@,-11,0,0,0);
_obiekt.fld('T_START','STRING[19]','Planowany początek prac'@,-11,0,1,0);
_obiekt.fld('KOLOR','STRING[23]','', 3,0,1,0);
_obiekt.fld('ZNACZNIK','STRING[1]','Zwrot'@,3,0,0,0);
_obiekt.fld('PROBLEMS','STRING[20]','Problemy'@,20,0,1,0);
_obiekt.fld('STATUS','STRING[20]','Status'@,20,0,1,0);
_obiekt.fld('CMP','STRING[2]','Status porównania wersji'@,1,0,1,0);
_obiekt.fld('KOM_ERR','STRING[1]','Komunikaty planu - błędy'@,1,0,1,0);
_obiekt.fld('KOM_WARN','STRING[1]','Komunikaty planu - ostrzeżenia'@,1,0,1,0);
_obiekt.fld('KOM_INFO','STRING[1]','Komunikaty planu - informacje'@,1,0,1,0);
_obiekt.fld('PX_POINT','STRING[1]','Czy są punkty czasowe [T/N]'@,1,0,1,0);
_obiekt.fld('PL_FORCE','STRING[1]','Kontynuować planowanie poza termin?'@,1,0,1,0);
_obiekt.fld_fml('TXT','BEFORE_DISPLAY','exec(\'txt_bd\',\'px_grp\')');
_obiekt.fld_fml('T_REAL','BEFORE_DISPLAY','exec(\'t_real_bd\',\'px_grp\')');
_obiekt.fld_fml('ZNACZNIK','BEFORE_DISPLAY','cur_tab(1,1).KOLOR');
_obiekt.fld_fml('DIR','DISPLAY_FORMAT','\'empty=1\'');
:: szerokosc wyswietlanego okienka
_obiekt.SZEROK:=60;

set_virt(_obiekt,'f_record',"
   exec('px_grp_rkprz','px_grp')
");

set_virt(_obiekt,'f_legend',"
   exec('px_grp_legenda','px_grp')
");
:: Takie czary żeby mechanizm tłumaczeń złapał
'Kolejka: %1'@[''];
set_virt(_obiekt,'title',"
   PX_VAR.VER_QUE:={? .KOPIA || PxSelect.VER_QUE1 || PxSelect.VER_QUE ?};
   'Kolejka: %1'@[PX_VAR.VER_QUE().SYMBOL]
");
:: Takie czary żeby mechanizm tłumaczeń złapał
'Lp.'@;
'Symbol'@;
set_virt(_obiekt,'hdr_1st',"
   '%1 | %2'@['Lp.'@,'Symbol'@]
");

set_virt(_obiekt,'f_displ',"
   exec('px_grp_display','px_grp')
");

set_virt(_obiekt,'load',"
   .TAB.erase();
   .TAB.cntx_psh();
   PX_GRP.cntx_psh();
   PX_GRP.index('VISIBLE');

:: Pokazujemy tylko niewykonane w calosci
   PX_GRP.prefix({? .KOPIA || PxSelect.VER_QUE1 || PxSelect.VER_QUE ?},'T','Z');
   {? PX_GRP.first()
   || {!
      |? exec('level1','px_grp',0,.);
         PX_GRP.next()
      !}
   ?};
   PX_GRP.cntx_pop();
   .TAB.cntx_pop();
   ~~
");

set_virt(_obiekt,'win_fml',"
  \"
   {? cur_afld()='TXT'
   || {? cur_tab(1,1).LEV=1
      || _ok:=0;
         PX_CONN.cntx_psh();
         PX_GRP.cntx_psh();
         PX_GRP.clear();
         {? PX_GRP.seek(cur_tab(1,1).PX_GRPI,8+cur_tab(1,1).PX_GRPI)
         || _ref:=PX_GRP.ref();
            PX_CONN.index('PX_GRP');
            PX_CONN.prefix(_ref);
            _ok:=PX_CONN.first()
         ?};
         PX_CONN.cntx_pop();
         PX_GRP.cntx_pop();
         {? _ok
         ||
            {? cur_tab(1,1).PLAN_OPR='T'
            || exec('pl_plan','icon')
            |? cur_tab(1,1).BLK='T' | cur_tab(1,1).BLK='Z'
            || 'xwin16.png:157'
            |? cur_tab(1,1).PROBLEMS<>exec('problem_none','px_obj')

            || 'xwin16.png:4'
            || {? cur_tab(1,1).tr_state()
               || 'xwin16.png:75'
               || 'xwin16.png:74'
               ?}
            ?}
         || 'xwin16.png:76'
         ?}
      || ''
      ?}
   |? cur_afld()='DIR'
   || {? cur_tab(1,1).DIR='1'
      || 'xwin16.png:22'
      |? cur_tab(1,1).DIR='-1'
      || 'xwin16.png:85'
      || ''
      ?}
   |? cur_afld()='T_PLAN'
   || {? cur_tab(1,1).PX_POINT='T'
      || 'xwin16.png:133'
      || 'xwin16.png:110'
      ?}
   |? cur_afld()='C_ILOSC' & cur_tab(1,1).PX_OBJ=''
   || {? cur_tab(1,1).STATUS=exec('status_wyk1','px_grp')
      || 'xwin16.png:72'
      |? cur_tab(1,1).STATUS=exec('status_wyk2','px_grp')
      || 'xwin16.png:13'
      || ''
      ?}
   || ''
   ?}
  \"
");

set_virt(_obiekt,'f_delete',"
:: tu usuwamy rekord lub rekordy powiazane
   exec('usu','px_grp',!.)
");

set_virt(_obiekt,'f_del_bg',"
   exec('usu_gb','px_grp',!.)
");

set_virt(_obiekt,'f_del_ag',"
   exec('usu_ga','px_grp',!.)
");

set_virt(_obiekt,'f_modify',"
   exec('px_grp_correct','px_grp',!.)
");

set_virt(_obiekt,'f_mod_bg',"
   exec('px_grp_corr_bg','px_grp',!.)
");

set_virt(_obiekt,'f_mod_ag',"
   VAR.GRUPA:='N';
   ~~
");
:: Takie czary żeby mechanizm tłumaczeń złapał tekst
'Usuń z pl&anu'@;
set_virt(_obiekt,'f_akcje',"
   .TAB.win_fml(.WERT,,'TXT',,'ICON_BEFORE',.win_fml());
   .TAB.win_fml(.WERT,,'DIR',,'ICON_BEFORE',.win_fml(),2);
   .TAB.win_fml(.WERT,,'T_PLAN',,'ICON_BEFORE',.win_fml(),2);
   .TAB.win_fml(.WERT,,'C_ILOSC',,'ICON_BEFORE',.win_fml());
   {? PX_VAR.EDIT=1
   || _akcja:=\"exec('px_que_organize','px_grp',PxSelect.VER_QUE)\";
      .TAB.win_act(.WERT,0,'Formuła','P&orządkuj'@@,,,_akcja,,0,,,,'O');
      task_attach('TPP_PPS_DPLA')
   ?};

   _akcja:=\"exec('go_obj_date','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Do da&ty'@@,,,_akcja,,0,,,,'T');

   _akcja:=\"exec('block_action','px_grp')\";
   _akcjabg:=\"exec('block_actionb','px_grp')\";
   _akcjaag:=\"exec('block_actiona','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','&Blokuj'@@,,,_akcja,,0,1,_akcjabg,_akcjaag,'B');
   task_attach('TPP_PPS_DPLA');

   _akcja:=\"exec('unblock_action','px_grp')\";
   _akcjabg:=\"exec('unblock_actionb','px_grp')\";
   _akcjaag:=\"exec('unblock_actiona','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Odblo&kuj'@@,,,_akcja,,0,1,_akcjabg,_akcjaag,'K');
   task_attach('TPP_PPS_DPLA');

   _akcja:=\"exec('select_komm','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Komu&nikaty'@@,,,_akcja,,0,,,,'N');

   _akcja:=\"exec('del_direct_act','px_grp')\";
   _akcjabg:=\"exec('del_direct_gr1','px_grp')\";
   _akcjaag:=\"exec('del_direct_gr2','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Usuń z pl&anu'@@,,,_akcja,,0,1,_akcjabg,_akcjaag,'A');
   task_attach('TPP_PPS_DPLA');

   {? PxSelect.Context<>'ZAM' & PxSelect.Context<>'ZL'
   ||
      _akcja:=\"exec('select_action','px_point')\";
      .TAB.win_act(.WERT,0,'Formuła','Punkty &czasowe'@@,,,_akcja,,0,,,,'C')
   ?};

:: Menu Przesuń
   .TAB.win_act(.WERT,0,'Menu','P&rzesuń'@,,,,,,,,,'R');
   _akcja:=\"exec('move_grp_up','px_grp',0)\";
   .TAB.win_act(.WERT,0,'Formuła','(n) w gó&rę'@@,'#R',,_akcja,,,,,,'R');
   task_attach('TPP_PPS_DPLA');
   .TAB.act_icn(.WERT,0,'RR','xwin16.png:103');
   _akcja:=\"exec('move_grp_up','px_grp',1)\";
   .TAB.win_act(.WERT,0,'Formuła','(1) w &górę'@@,'#R',,_akcja,,,,,,'G');
   task_attach('TPP_PPS_DPLA');
   .TAB.act_icn(.WERT,0,'RG','xwin16.png:104');
   _akcja:=\"exec('move_grp_down','px_grp',1)\";
   .TAB.win_act(.WERT,0,'Formuła','(1) w &dół'@@,'#R',,_akcja,,,,,,'D');
   task_attach('TPP_PPS_DPLA');
   .TAB.act_icn(.WERT,0,'RD','xwin16.png:105');
   _akcja:=\"exec('move_grp_down','px_grp',0)\";
   .TAB.win_act(.WERT,0,'Formuła','(n) &w dół'@@,'#R',,_akcja,,,,,,'W');
   task_attach('TPP_PPS_DPLA');
   .TAB.act_icn(.WERT,0,'RW','xwin16.png:106');
   .TAB.win_act(.WERT,0,'Formuła','--X','#R');
   task_attach('TPP_PPS_DPLA');
   _akcja:=\"exec('move_grp_to','px_grp')\";
   _akcja_bg:=\"exec('move_grp_to_bg','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Do &numeru'@@,'#R',,_akcja,,,1,_akcja_bg,,'N');
   task_attach('TPP_PPS_DPLA');
   .TAB.act_icn(.WERT,0,'RN','xwin16.png:107');

:: Menu Funkcje
   .TAB.win_act(.WERT,0,'Menu','Funkcje'@,,,,,,,,,'F');
   _fb:=\"exec('sel_sur_pxver','px_sur',PX_VAR.VIE_VER)\";
   .TAB.win_act(.WERT,0,'Formuła','&Zapotrzebowania'@@,'#F',,_fb,,,,,,'Z');
   _fb:=\"exec('select_grp','px_poz')\";
   .TAB.win_act(.WERT,0,'Formuła','&Pozycje planu dla grupy'@@,'#F',,_fb,,,,,,'P');
   _fb:=\"exec('diagram','px_con_g',PX_VAR.VER_QUE)\";
   .TAB.win_act(.WERT,0,'Formuła','&Diagram'@@,'#F',,_fb,,,,,,'D');
   {? PX_VAR.EDIT=1
   ||
      .TAB.win_act(.WERT,0,'Formuła','--Q','#F');
      _fb:=\"exec('action_generuj','!tte_pzl_dzpx')\";
      _gr1:=\"exec('action_generuj_gr1','!tte_pzl_dzpx',PxSelect.Pxgrp)\";
      _gr2:=\"exec('action_generuj_gr2','!tte_pzl_dzpx',PxSelect.Pxgrp)\";
      .TAB.win_act(.WERT,0,'Formuła','Generuj zlecenia'@@,'#F',,_fb,,,1,_gr1,_gr2,'G');
      task_attach('TTE_PZL_DZPX')
   ?};
   _fb:=\"exec('zlecenia','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Z&lecenia'@@,'#F',,_fb,,,,,,'L');

:: Menu kolejka
   .TAB.win_act(.WERT,0,'Menu','Kol&ejka'@,,,,,,,,,'E');
   _fb:=\"exec('scal_obj','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','&Scal obiekty'@@,'#E',,_fb,,,,,,'S');
   task_attach('TPP_PPS_DPLA');
   _fb:=\"exec('queue_copy','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','&Kopiuj kolejkę'@@,'#E',,_fb,,,,,,'K');
   task_attach('TPP_PPS_DPLA');
   _fb:=\"exec('queue_cmp','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Po&równaj kolejki'@@,'#E',,_fb,,,,,,'R');
   _fb:=\"exec('queue_merge','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Prz&ywróć kolejkę'@@,'#E',,_fb,,,,,,'Y');
   task_attach('TPP_PPS_DPLA');


:: Menu Podgląd
   .TAB.win_act(.WERT,0,'Menu','Pod&gląd'@,,,,,,,,,'G');
   _fb:=\"exec('wer_px_txt_v','px_grps')\";
   .TAB.win_act(.WERT,0,'Formuła','Podgląd prz&episu'@@,'#G',,_fb,,0,,,,'E');
   task_attach('TPP_PPS_DPPL');
   task_attach('TPP_PPS_PPPL');
   _fb:=\"exec('select_paczka','px_grp')\";
   .TAB.win_act(.WERT,0,'Formuła','Przep&is źródłowy'@@,'#G',,_fb,,0,,,,'I');
   .TAB.win_act(.WERT,0,'Formuła','--X','#G');
   _fb:=\"exec('view_act_queue','px_plan')\";
   .TAB.win_act(.WERT,0,'Formuła','&Kolejka'@@,'#G',,_fb,,,,,,'K');
   _fb:=\"exec('view_act_obj','px_plan')\";
   .TAB.win_act(.WERT,0,'Formuła','&Obiekty'@@,'#G',,_fb,,,,,,'O');
   _fb:=\"exec('view_act_queue_obj','px_plan')\";
   .TAB.win_act(.WERT,0,'Formuła','Ko&lejka+obiekty'@@,'#G',,_fb,,,,,,'L');
   _fb:=\"exec('view_act_queue_obj','px_plan')\";


::   _akcja:=\"exec('px_grp_sur','px_grp')\";
::   .TAB.win_act(.WERT,0,'Formuła','Surow&ce',,,_akcja,,0);

::   {? PX_VAR.VER_QUE().STATUS=exec('status_ready','px_ver')
::   || _akcja:=\"exec('accept','px_ver',PX_VAR.VIE_VER)\";
::      PxSelect.Pxgrp.TAB.win_act(PxSelect.Pxgrp.WERT,0,'Formuła','Akceptuj plan',,,_akcja,,1);
::      PxSelect.Pxgrp.TAB.win_act(PxSelect.Pxgrp.WERT,1,'Formuła','Akceptuj plan',,,_akcja,,1)
::   || _akcja:=\"exec('px_que_accept','px_grp',PX_VAR.VER_QUE)\";
::      PxSelect.Pxgrp.TAB.win_act(PxSelect.Pxgrp.WERT,0,'Formuła','Akceptuj kolejkę',,,_akcja,,1);
::      PxSelect.Pxgrp.TAB.win_act(PxSelect.Pxgrp.WERT,1,'Formuła','Akceptuj kolejkę',,,_akcja,,1)
::   ?};
   ~~
");

_obiekt.init();
_obiekt.NDX_UP;
_obiekt.TAB.index(_obiekt.NDX_UP);
_obiekt.TAB.prefix();
_obiekt.update();

:: Przyciski (tylko jak redagowanie)
{? PX_VAR.EDIT=1 & ~_kopia & exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPLA')
||
   _btn:=_obiekt.TAB.win_btn(_obiekt.WERT,'icon=xwin16.png:103,panel=right,align=begin','menu:RR');
   _obiekt.TAB.btn_sopt(_obiekt.WERT,_btn,'tooltip='+'Przesunięcie w górę o N pozycji'@);
   _btn:=_obiekt.TAB.win_btn(_obiekt.WERT,'icon=xwin16.png:104,panel=right,align=begin','menu:RG');
   _obiekt.TAB.btn_sopt(_obiekt.WERT,_btn,'tooltip='+'Przesunięcie w górę o 1 pozycję'@);
   _btn:=_obiekt.TAB.win_btn(_obiekt.WERT,'icon=xwin16.png:105,panel=right,align=begin','menu:RD');
   _obiekt.TAB.btn_sopt(_obiekt.WERT,_btn,'tooltip='+'Przesunięcie w dół o 1 pozycję'@);
   _btn:=_obiekt.TAB.win_btn(_obiekt.WERT,'icon=xwin16.png:106,panel=right,align=begin','menu:RW');
   _obiekt.TAB.btn_sopt(_obiekt.WERT,_btn,'tooltip='+'Przesunięcie w dół o N pozycji'@);
   _btn:=_obiekt.TAB.win_btn(_obiekt.WERT,'icon=xwin16.png:107,panel=right,align=begin','menu:RN');
   _obiekt.TAB.btn_sopt(_obiekt.WERT,_btn,'tooltip='+'Przesunięcie na N-tą pozycję'@);
   ~~
?};

:: tu zrobimy dnd w okienku zmiana kolejnosci
{? PX_VAR.EDIT=1 & ~_kopia & exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPLA')
|| _obiekt.TAB.dnd_sel(_obiekt.WERT,,'records.#tree_wert',"exec('dnd_renum','px_grp')")
?};
_obiekt.TAB.first();
~~


\px_grp_correct
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [1210]
:: OPIS: Akcja popraw na pozycji drzewa
::   WE: _a - nazwa obiektu, np. '@.PxSelect.Pxgrp'
::----------------------------------------------------------------------------------------------------------------------
{? VAR.GRUPA='T' || return() ?};

_one_ver:=exec('is_one_version','px_param');

_obiekt:=($_a)();
_Tab:={? _one_ver || exec('tab','px_grps') || _obiekt.TAB ?};
_ref:=_obiekt.TAB.ref();
PX_VAR.ILOSC:=0;
PX_VAR.TX_BEFOR:=null();
PX_VAR.AGR:='N';

PL_RES.cntx_psh();
GROP.cntx_psh();
GROPS.cntx_psh();
PX_OBJ.cntx_psh();
PX_GRP.cntx_psh(); PX_GRP.clear();
PX_CONN.cntx_psh(); PX_CONN.clear();
_can_continue:=1;

exec('px_tex_akt_bl','px_tex',1);

_locked:=null();
_il_before:=0;
_fast_replan:=null();

{? _Tab.PX_CONN<>''
||
:: Stoje na wezle reprezentujacym PX_CONN
   __blokada:=1;
   {? PX_CONN.seek(_Tab.PX_CONN,8+_Tab.PX_CONN)
   ||
      _il_before:=PX_CONN.ILOSC;
::    Podczytanie PX_OBJ
      PX_CONN.PX_OBJ();
::    Podczytanie PX_GRP
      PX_CONN.PX_GRP();

::    Blokuje grupe do edycji
      {? exec('lock','px_grp')>0
      || _locked:=PX_GRP.ref();
::       Sprawdzenie, czy sa obiekty powiazane - wtedy nie ma mozliwosci redagowania ilosci (czyli wogole)
         _np:=_pn:=0;
         PX_CON_G.index('NP_LP');
         PX_CON_G.prefix(PX_GRP.ref());
         {? PX_CON_G.first() || _np:=1 ?};
         PX_CON_G.index('PN_LP');
         PX_CON_G.prefix(PX_GRP.ref());
         {? PX_CON_G.first() || _pn:=1 ?};

         {? _np | _pn
         ||
            FUN.emsg('Obiekt powiązany — nie można modyfikować ilości.'@);
            _can_continue:=0
         ?};

         {? _can_continue>0
         || {? exec('is_blocked','px_grp')>0
            || FUN.emsg('Element zablokowany nie może być redagowany.'@);
               _can_continue:=0
            ?}
         ?};

         {? _can_continue>0
         ||
            PX_VAR.ADD_SYM:=PX_OBJ.SYMBOL;
            PX_VAR.ADD_OPIS:=PX_OBJ.NAZWA;
            PX_VAR.ILOSC:=PX_OBJ.IL-PX_OBJ.IL_PLAN;
            PX_VAR.ADD_DIR:=PX_GRP.DIR;
            PX_VAR.TM_END:=PX_OBJ.TM_REA;
            {? PX_GRP.DIR>0
            ||
::             Planowanie w przod
               PX_VAR.GRN_DATA:=PX_GRP.STARTD().DATA;
               PX_VAR.GRN_TIME:=PX_GRP.STARTT;
               PX_VAR.TM_GRN:=PX_GRP.TM_START
            ||
::             Planowanie wstecz
               PX_VAR.GRN_DATA:=PX_GRP.ENDD().DATA;
               PX_VAR.GRN_TIME:=PX_GRP.ENDT;
               PX_VAR.TM_GRN:=PX_GRP.TM_END
            ?};
            PX_VAR.ADD_TX:=PX_CONN.PX_GRP().PX_TEX;
            PX_VAR.ADD_IL:=PX_CONN.ILOSC;
            PX_VAR.TM_END:=PX_CONN.PX_OBJ().TM_REA
         ?};
         exec('px_var_win_edit','px_grp','ADD2','Redagowanie składowej elementu kolejki');

::       OKNO EDYCYJNE
         {? _can_continue>0 & PX_VAR.edit("exec('validate_conn','px_grp',1)")>0
         || exec('set_sim_mod','px_grp',,'T');
            _can_continue:=1
         || _can_continue:=0
         ?}
      || _can_continue:=0
      ?}
   ?}
||
   PX_TEX.win_dict('SEL');

:: Stroje na wezle reprezentujacym PX_GRP
   PX_GRP.cntx_psh();
   PX_GRP.clear();
   __blokada:=2;
   {? PX_GRP.seek(_Tab.PX_GRPI,8+_Tab.PX_GRPI)
   ||
      _il_before:=PX_GRP.ILOSC;
::    Blokuje grupe do edycji
      {? exec('lock','px_grp')>0
      || _locked:=PX_GRP.ref();

         {? _can_continue>0
         || {? exec('is_blocked','px_grp')>0
            || FUN.emsg('Element zablokowany nie może być redagowany.'@);
               _can_continue:=0
            ?}
         ?};
         {? _can_continue>0
         ||
            PX_VAR.ADD_SYM:=PX_GRP.SYMBOL;
            PX_VAR.ADD_OPIS:=PX_GRP.NAZWA;
            PX_VAR.ADD_DIR:=PX_GRP.DIR;
            PX_VAR.TM_END:=exec('min_termin','px_grp',PX_GRP.ref());
            {? PX_GRP.DIR>0
            ||
::             Planowanie w przód
               PX_VAR.GRN_DATA:=PX_GRP.STARTD().DATA;
               PX_VAR.GRN_TIME:=PX_GRP.STARTT;
               PX_VAR.TM_GRN:=PX_GRP.TM_START
            ||
::             Planowanie wstecz
               PX_VAR.GRN_DATA:=PX_GRP.ENDD().DATA;
               PX_VAR.GRN_TIME:=PX_GRP.ENDT;
               PX_VAR.TM_GRN:=PX_GRP.TM_END
            ?};
            {? exec('is_px_set','px_param')>0
            ||
::             Praca na zestawie - nadpisuje wartosci do okna, na podstawie rekordu w kolejce
::             zestawu
               {? PX_GRPS.DIR<>0
               || PX_VAR.ADD_DIR:=PX_GRPS.DIR
               ?};
               {? PX_GRPS.GRN_DATA<>date(0,0,0)
               || PX_VAR.GRN_DATA:=PX_GRPS.GRN_DATA;
                  PX_VAR.GRN_TIME:=PX_GRPS.GRN_TIME
               || PX_VAR.GRN_DATA:=date(0,0,0);
                  PX_VAR.GRN_TIME:=time(0,0,0)
               ?}
            ?};
::          Zapamietuje przepis przed redakcja
            PX_VAR.TX_BEFOR:=PX_GRP.PX_TEX;
            PX_VAR.ADD_TX:=PX_GRP.PX_TEX;
            PX_VAR.ILOSC:=PX_GRP.ILOSC;
            {? PX_GRP.GROPS<>null()
            || PX_VAR.ILOSC:=PX_GRP.GROPS().GROP().IL
            ?};

            PX_VAR.ADD_IL:=PX_GRP.ILOSC;
            PX_VAR.PL_FORCE:=PX_GRP.PL_FORCE;
            PX_VAR.GROP:=PX_GRP.GROPS().GROP;
            PX_VAR.GROPS:=PX_GRP.GROPS;
            {? PX_GRP.GROPS<>null()
            || PX_GRP.GROPS().GROP()
            ?};

::          zakladam filtr na przepisy planistyczne - filtruje przepisy aby wyswietlic tylko
::          te ktore moga wystapic na wszystkich PX_OBJ danego PX_GRP
            exec('tex_f_set2','px_tex',PX_GRP.ref());

            PX_CONN.cntx_psh();
            PX_CONN.index('PX_GRP');
            PX_CONN.prefix(PX_GRP.ref());
            {? PX_GRP.GROPS<>null()
            || PX_GRP.GROPS().PL_RES();
               GROPS.win_dict('SEL');
               exec('px_var_win_edit','px_grp','ADD_GROP','Redagowanie elementu kolejki'@)
            || {? PX_CONN.size()=1
               || exec('px_var_win_edit','px_grp','RED2')
               || exec('px_var_win_edit','px_grp','RED1')
               ?}
            ?};
            PX_CONN.cntx_pop();

            {? exec('is_px_set','px_param')>0
            ||
               _admin:=(exec('get','#params',8062,2,OPERATOR.USER)='T');

               {? _admin=0 & PX_VAR.PX_SET<>null() & PX_VAR.PX_SET<>PX_GRP.SET_SRC
               ||
::                Jesli praca na zestawie i zwykly user to ustawiam okno redagowania dla zestawu
                  exec('px_var_win_edit','px_grp','REDS')
               ?}
            ?};
            exec('px_tex_akt_bl','px_tex',0)
         ?};

::       OKNO EDYCYJNE
         {? _can_continue>0 & PX_VAR.edit("exec('validate_grp','px_grp',1)")>0
         || _can_continue:=1
         || _can_continue:=0
         ?}
      || _can_continue:=0
      ?}
   ?};
   PX_GRP.cntx_pop()
?};

{? _can_continue>0
|| {? _Tab.PX_CONN=''
   ||
::    Stoje na wezle reprezentujacym PX_GRP
      PX_GRP.clear();
      {? PX_GRP.seek(_Tab.PX_GRPI,8+_Tab.PX_GRPI)
      ||
         {? _one_ver=0 | (_one_ver>0 & PX_VAR.PX_SET=PX_GRP.SET_SRC)
         ||
::          Praca bez zestawow lub na zestawie zrodlowym - modyfikuje rekord zrodlowy
            PX_GRP.DIR:=PX_VAR.ADD_DIR;
            PX_GRP.put()
         ?};
         {? exec('is_px_set','px_param')=0
         ||
::          Ustawiam daty na PX_GRP
            exec('dates_set','px_grp',PX_GRP.ref(),PX_VAR.GRN_DATA,PX_VAR.GRN_TIME)
         ?};

         PX_GRP.PX_TEX:=PX_VAR.ADD_TX;

::       Aktualizuje symbol i nazwe na podstawie przepisu
         {? PX_VAR.ADD_TX<>null() & PX_GRP.PX_TAG=null()
         || PX_GRP.SYMBOL:=PX_VAR.ADD_TX().SYMBOL;
            PX_GRP.NAZWA:=PX_VAR.ADD_TX().SYMBOL
         ?};

         PX_GRP.PL_FORCE:=PX_VAR.PL_FORCE;
         {? PX_VAR.GROPS<>null()
         || _old_grops:=PX_GRP.GROPS;
            PX_GRP.GROPS:=PX_VAR.GROPS
         ?};
         {? PX_GRP.GROPS<>null() & PX_GRP.ILOSC<>PX_VAR.ADD_IL
         || PX_GRP.ILOSC:=PX_VAR.ADD_IL;
            PX_CONN.cntx_psh();
            PX_CONN.index('PX_GRP');
            PX_CONN.prefix(PX_GRP.ref());
            {? PX_CONN.first()
            || PX_CONN.ILOSC:=PX_VAR.ADD_IL;
               PX_CONN.put()
            ?};
            PX_CONN.cntx_pop();
            ~~
         ?};

         _can_continue:=PX_GRP.put();

         {? _can_continue>0
         || exec('set_sim_mod','px_grp',,'T')
         ?};
         {? _can_continue>0 & PX_GRP.GROPS<>null()
         || exec('sequence4pxgrp','px_grop')
         ?};

::       "Naprawa" GROPS przy zmianie zasobu
         {? _can_continue>0 & PX_VAR.GROPS<>null() & PX_GRP.GROPS<>_old_grops
         || exec('plan_restore_grop','zl_grop',PX_GRP.GROPS().GROP)
         ?};

         {? _can_continue>0
         ||
            {? _one_ver>0
            ||
               {? PX_VAR.PX_SET<>null()
               ||

::                Praca na zestawie - aktualizuje rekord w kolejce zestawu
                  _args_grps:=exec('add_a','px_grps');
                  _args_grps.PX_GRP:=PX_GRP.ref();
                  _args_grps.PX_SET:=PX_VAR.PX_SET;
                  _args_grps.GRN_DATA:=PX_VAR.GRN_DATA;
                  _args_grps.GRN_TIME:=PX_VAR.GRN_TIME;
                  _args_grps.DIR:=PX_VAR.ADD_DIR;

                  exec('update','px_grps',_args_grps.PX_GRP,_args_grps.PX_SET,_args_grps);

                  _tm_grn:=exec('create','#tm_stamp',PX_VAR.GRN_DATA,PX_VAR.GRN_TIME);
                  _args_poi:=exec('auto_args_grps','px_point',,_tm_grn);
                  _args_poi.DEL_MANUAL:=1;

                  {? PX_GRP.PX_TEX<>PX_VAR.TX_BEFOR
                  ||
::                   Usuwam wszystkie punkty
                     exec('delete4grp','px_point',PX_GRP.ref());

::                   Zmienil sie przepis wiec od nowa tworze PX_GRPSy
                     exec('refresh','px_grps',1);

::                   Poniewaz mogly powstac nowe PX_GRPSy ustawiam sie na nowo na PX_GRPsie
                     PX_GRPS.cntx_psh();
                     PX_GRPS.index('PX_GRP');
                     PX_GRPS.prefix(PX_GRP.ref(),PX_VAR.PX_SET);
                     {? PX_GRPS.first()
                     ||
::                      Aktualizuje nowo powstalego grpsa
                        exec('update','px_grps',_args_grps.PX_GRP,_args_grps.PX_SET,_args_grps);

::                      Ponownie tworze argumenty dla aktualizacji punktow czasowych
                        {? var_pres('_args_poi')>100
                        || obj_del(_args_poi)
                        ?};
                        _args_poi:=exec('auto_args_grps','px_point',,_tm_grn)
                     ?};
                     PX_GRPS.cntx_pop();
                     ~~
                  ?};
::                Aktualizacja punktow czasowych
                  exec('auto_point','px_point',_args_poi)
               ?}
            ?};

            {? _il_before>PX_GRP.ILOSC
            ||
::             W wyniku edycji zmniejszyla sie ilosc, wiec powinienem przeplanowac
::             grupe
               _fast_replan:=PX_GRP.ref()
            ?}
         ?}
      ?}
   |? _Tab.PX_CONN<>''
   ||
::    Stoje na wezle reprezentujacym PX_CONN
      PX_CONN.clear();
      {? PX_CONN.seek(_Tab.PX_CONN,8+_Tab.PX_CONN)
      || PX_CONN.ILOSC:=PX_VAR.ADD_IL;
         _can_continue:=PX_CONN.put();

         {? _can_continue>0
         ||
            {? _il_before>PX_CONN.ILOSC
            ||
::             W wyniku edycji zmniejszyla sie ilosc, wiec powinienem przeplanowac
::             grupe
               _fast_replan:=PX_CONN.PX_GRP
            ?}
         ?}
      ?}
   ?};
   {? _can_continue>0
   ||
::    Przenumerowanie kolejki
      exec('prenumber','px_grp',PxSelect.VER_QUE);

      {? _one_ver>0
      ||
::       Aktualizuje przyciski w panelu nawigacyjnym
         exec('przelicz_btn','px_plan');

         {? _fast_replan<>null()
         ||
::          W przypadku pracy na jednej wersji planu oraz wtedy kiedy zmniejszam
::          ilosc powinienem od razu przeplanowac grupe ktorej zmniejszylem ilosc
::          aby nie dopuscic do potencjalnie blednych sytuacji w ktorych
::          ktos np moglby zaczac rejestrowac wykonania do zbyt duzej ilosci
            _args_fast:=exec('fast_replan_a','px_logix');
            _args_fast.PX_GRP:=_fast_replan;
            exec('grp_fast_replan','px_logix',_args_fast)
         ?}
      ?};
      exec('Pxgrp_refresh','px_grp',_obiekt)
   ?}
?};
:: Odblokowuje zablokowana wczesniej grupe
{? _locked<>null()
|| exec('unlock','px_grp',_locked)
?};

::przywracam kursor na rekord na ktorym stalem przed poprawieniem
_obiekt.TAB.seek(_ref);

&__blokada;
:: zdejmuje filtr z PX_TEX
exec('tex_f_clear','px_tex');

VAR_DEL.delete('__dropped');

PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
PX_CONN.cntx_pop();
GROP.cntx_pop();
GROPS.cntx_pop();
PL_RES.cntx_pop();
~~


\dnd_block
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: sprawdzenie czy to co przenosimy jest zablokowane
::   WE: _a - co przenosimy
::   WY: 1/0 = 1 - mozemy, 0-nie mozemy
::----------------------------------------------------------------------------------------------------------------------
_wyn:=1;
_records:=_a;

{? PxSelect.Pxgrp.TAB.seek(_records.REF,)
|| _Tab:=
      {? exec('is_grps_static','px_param')
      || exec('tab','px_grps')
      || PxSelect.Pxgrp.TAB
      ?};
   {? PX_GRP.seek(_Tab.PX_GRPI,8+_Tab.PX_GRPI) & _Tab.PX_OBJ<>''
   || {? exec('is_blocked','px_grp')>0
      || FUN.emsg('Element który upuszczamy jest zablokowany, operacja przesunięcia zostaje wycofana.'@);
         _wyn:=0
      |? PX_GRP.STATUS=exec('status_wyk1','px_grp')
      || FUN.emsg('Element który upuszczamy jest wykonywany, operacja przesunięcia zostaje wycofana.'@);
         _wyn:=0
      |? PX_GRP.STATUS=exec('status_wyk2','px_grp')
      || FUN.emsg('Element który upuszczamy jest wykonany w całości, operacja przesunięcia zostaje wycofana.'@);
         _wyn:=0
      ?}
   ?}
|| 'nie znalezione';
   _wyn:=0
?};
_wyn


\dnd_renum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: Akcja renumerujaca drzewa (dnd albo akcja w oknie wertowania)
::   WE: [_a] - 1 (domyslnie - dnd), 0 (akcja w oknie)
::       [_b] - przesuwane rekordy (jak wynik dnd_info('dropped_records') ) - interpretowane gdy _a=0
::       [_c] - miejsce przeznaczenia (jak wynik dnd_info('dest_record') ) - interpretowane gdy _a=0
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _dnd:=_a || _dnd:=1 ?};
PX_GRP.clear();
PX_CONN.clear();
{? _dnd
|| _pos:=dnd_info('src_pos_in_window')
|| _pos:=0
?};

{? _dnd & cur_tab(1,1).sel_size()>1
|| FUN.emsg('Przesunięcie dostępne tylko dla pojedynczego rekordu.'@);
   win_set('cur_row_pos='+$_pos);
   return()
?};

:: co przeciagamy
{? _dnd
|| _records:=dnd_info('dropped_records')
|| _records:=_b
?};
{? ~exec('dnd_block','px_grp',_records)
|| {? _dnd || win_set('cur_row_pos='+$_pos) ?};
   return()
?};

:: na co upuszczamy
{? _dnd
|| _dest_rec:=dnd_info('dest_record')
|| _dest_rec:=_c
?};

PxSelect.Pxgrp.TAB.cntx_psh();
_reftab:=PxSelect.Pxgrp.TAB.REF;
_ref_old:=PxSelect.Pxgrp.TAB.PX_CONN;
_ref_tab:=#PxSelect.Pxgrp.TAB.ref();

_tab_nr:=tab_tmp(1,'REF','INTEGER','Reference'
                  ,'SREF','STRING[16]','$Reference'
                  ,'P','INTEGER','Pozycja'
                  ,'PXGRP','INTEGER','PXGRP'
                  ,'PNEW','INTEGER','Nowa pozycja'
                  ,'NUM','STRING[1]','Czy numerowano'
                 );

:: Obsluga blokowania - blokuje wszystko co zlapalem i na co upuszczam
_can_continue:=1;
PxSelect.Pxgrp.TAB.cntx_psh(); PxSelect.Pxgrp.TAB.clear();

:: 1. Blokowanie grupy na ktora upuszczam
{? _dest_rec<>null()
|| {? PxSelect.Pxgrp.TAB.seek(_dest_rec)
   || _dest_grp:=exec('FindAndGet','#table',PX_GRP,PxSelect.Pxgrp.TAB.PX_GRPI,,,null());
      {? exec('lock','px_grp',_dest_grp)=0
      || _can_continue:=0
      ?}
   ?}
?};
:: 2. Blokowanie grup ktore przemieszczam
{? _can_continue>0
|| {? _records.first()
   ||
      _grupowa:=1;
      {? _records.size()>1
      || _grupowa:=2
      ?};

      {!
      |? {? PxSelect.Pxgrp.TAB.seek(_records.REF,)
         || _moved_grp:=exec('FindAndGet','#table',PX_GRP,PxSelect.Pxgrp.TAB.PX_GRPI,,,null());
            {? exec('lock','px_grp',_moved_grp,_grupowa)=0
            || _can_continue:=0
            ?}
         ?};
         _records.next()
      !}
   ?}
?};
PxSelect.Pxgrp.TAB.cntx_pop();

{? _can_continue>0
||
   {? _dest_rec=null()
   ||
::    Obsluga upuszczania na pusty obszar okna (za wszystkimi rekordami)
      {? _ref_old=''
      ||
::       chcemy przeniesc cala galaz na pusty obszar
         PxSelect.Pxgrp.TAB.cntx_pop();
         win_set('cur_row_pos='+$_pos);
::       konczymy niepowodzeniem
         return()
      ||
::       teraz namierzamy wszystko co mam do zalozenia nowej galezi
         {? PX_CONN.seek(_ref_old,8+_ref_old)
         || _grp:=PX_CONN.PX_GRP;
            _tech:=PX_CONN.PX_GRP().PX_TEX;
            _ver:=PX_CONN.PX_GRP().PX_VER;
            _sym:=PX_CONN.PX_GRP().SYMBOL;
            _opis:=PX_CONN.PX_GRP().NAZWA;
            _zwrot:=PX_CONN.PX_GRP().DIR;
            _ilosc:=PX_CONN.ILOSC;
            _startd:=PX_CONN.PX_GRP().STARTD;
            _startt:=PX_CONN.PX_GRP().STARTT;
            _tm_start:=PX_CONN.PX_GRP().TM_START;
            _endd:=PX_CONN.PX_GRP().ENDD;
            _endt:=PX_CONN.PX_GRP().ENDT;
            _tm_end:=PX_CONN.PX_GRP().TM_END;
            _ref:=PX_CONN.ref()
         || PxSelect.Pxgrp.TAB.cntx_pop();
::          konczymy niepowodzeniem
            win_set('cur_row_pos='+$_pos);
            return()
         ?};

         PX_GRP.blank();
         PX_GRP.NAZWA:=_opis;
         PX_GRP.PX_TEX:=_tech;
         PX_GRP.PX_VER:=_ver;
         PX_GRP.SYMBOL:=_sym;
         PX_GRP.DIR:=_zwrot;
         PX_GRP.ILOSC:=_ilosc;
         PX_GRP.cntx_psh();
         PX_GRP.index('LP');
         PX_GRP.prefix(_ver,'Z');
         _nr:=PX_GRP.size();
         PX_GRP.cntx_pop();
         PX_GRP.LP_Q:=_nr+1;
         PX_GRP.STARTD:=_startd;
         PX_GRP.STARTT:=_startt;
         PX_GRP.TM_START:=_tm_start;
         PX_GRP.ENDD:=_endd;
         PX_GRP.ENDT:=_endt;
         PX_GRP.TM_END:=_tm_end;
         {? PX_GRP.add()
         || _ref:=PX_GRP.ref();
            PX_CONN.clear();
            PX_CONN.LP_GRP:=1;
            PX_CONN.PX_GRP:=_ref;
            PX_CONN.put();

::          Stempluje kolejke czasem i userem modyfikacji
            exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER);

            {? exec('is_one_version','px_param')>0
            ||
::             Jesli praca na jednej wersji planu to wyciagniecie czegos z grupy
::             powinno spowodowac ze ta grupa z ktorej wyciagamy zostaje usunieta z planu
               exec('clean_from_plan','px_grp',_grp)
            ?}
         ?}
      ?}
   ||
::    Obsluga upuszczania na konkretny rekord (czyli przejmujemy jego numer)
      {? PxSelect.Pxgrp.TAB.PX_CONN=''
      ||
::       chcemy przeniesc cala galaz z liscmi
::       szukamy na co upuszczamy
         {? PxSelect.Pxgrp.TAB.seek(_dest_rec)
         || _ref_drop:=PxSelect.Pxgrp.TAB.PX_GRPI;
            {? PX_GRP.seek(_ref_drop,8+_ref_drop)
            || _poz:=PX_GRP.LP_Q;
               _ref:=PX_GRP.ref()
            || _poz=0;
               _ref:=null()
            ?};
            _parent:=PxSelect.Pxgrp.TAB.UPNODE;
            {? PxSelect.Pxgrp.TAB.seek(_records.REF,)
            || {? PX_GRP.seek(PxSelect.Pxgrp.TAB.PX_GRPI,8+PxSelect.Pxgrp.TAB.PX_GRPI)
               || PX_GRP.index('LP');
                  PX_GRP.prefix(PxSelect.VER_QUE,'Z');
                  {? PX_GRP.first()
                  || {!
                     |? _tab_nr.blank();
                        _tab_nr.REF:=#PX_GRP.ref();
                        _tab_nr.SREF:=$PX_GRP.ref();
                        _tab_nr.P:=PX_GRP.LP_Q;
                        _tab_nr.PXGRP:=#PX_GRP.ref();
                        _tab_nr.NUM:='N';
                        _tab_nr.PNEW:=0;
                        _tab_nr.add();
                        PX_GRP.next()
                     !};
                     _ost_nr:=PX_GRP.LP_Q;
                     _ndx:=_tab_nr.ndx_tmp(,1,'SREF',,);
                     _tab_nr.index(_ndx);
                     {? _records.first()
                     || _lp:=0;
                        {!
                        |?
                           {? PxSelect.Pxgrp.TAB.seek(_records.REF,) &
                              _tab_nr.find_key(PxSelect.Pxgrp.TAB.PX_GRPI)
                           || {? _lp=0 || _pod:=_tab_nr.P ?};
                              {? _poz>=_pod
                              || _tab_nr.PNEW:=_poz+_lp-(_records.size()-1)
                              || _tab_nr.PNEW:=_poz+_lp
                              ?};
                              _tab_nr.put();
                              _lp+=1;
                              1
                           ?};
                           _records.next()
                        !};
::                      Ustawienie numeracji dla pozostalych rekordow
                        _num:=_tab_nr.ndx_tmp('',,'NUM',,,'P',,);
                        _pnew:=_tab_nr.ndx_tmp('',,'PNEW',,,'P',,);
                        _tab_nr.index(_num);
                        _tab_nr.prefix('N');
                        {? _tab_nr.first()
                        || {!
                           |?
                              _nr_new:=0;
                              _tab_nr.cntx_psh();
                              _tab_nr.index(_pnew);
                              _nfind:=0;
                              _nr:=_tab_nr.P;
                              {? ~_tab_nr.find_key(_nr)
                              || _nfind:=1;
                                 _nr_new:=_tab_nr.P
                              ?};
                              {? _nfind
                              || _tab_nr.prefix(0);
                                 {? _tab_nr.first()
                                 || _tab_nr.clear();
                                    _tab_nr.PNEW:=_nr_new;
                                    _tab_nr.put()
                                 ?}
                              ?};
                              _tab_nr.cntx_pop();
                              _tab_nr.cntx_psh();
                              _tab_nr.clear();
                              _tab_nr.get();
                              _tab_nr.NUM:='T';
                              _tab_nr.put();
                              _tab_nr.cntx_pop();
                              _tab_nr.first()
                           !}
                        ?};
                        _tab_nr.prefix();
::                      Przesuniecie numerow, jesli ujemne
                        _tab_nr.index(_pnew);
                        _tab_nr.prefix();
                        {? _tab_nr.first()
                        || _shift:=_tab_nr.PNEW-1
                        ?};
                        {? _shift<0 & _tab_nr.last()
                        || {!
                           |? _tab_nr.PNEW-=_shift;
                              _tab_nr.put();
                              _tab_nr.prev()
                           !}
                        ?};
::                      Ustawienie nowej numeracji
                        PX_GRP.prefix(PxSelect.VER_QUE);
                        {? PX_GRP.last()
                        ||
::                         Stempluje kolejke czasem i userem modyfikacji
                           exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER);
                           {!
                           |?
                              PX_GRP.LP_Q:=PX_GRP.LP_Q+_ost_nr;
                              PX_GRP.put();
                              PX_GRP.prev()
                           !}
                        ?};
                        {? _tab_nr.last()
                        || {!
                           |? {? _tab_nr.PNEW<>0
                              || {? PX_GRP.seek(_tab_nr.REF,)
                                 || PX_GRP.LP_Q:=_tab_nr.PNEW;
                                    PX_GRP.put();

::                                  Stempluje kolejke czasem i userem modyfikacji
                                    exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER)
                                 ?}
                              ?};
                              _tab_nr.prev()
                           !}
                        ?};
                        _tab_nr.ndx_drop(_ndx)
                     ?}
                  ?}
               ?}
            ?}
         ?};
         PxSelect.Pxgrp.TAB.sel_del()
      ||
::       szukamy na co upuszczamy
         {? PxSelect.Pxgrp.TAB.seek(_dest_rec)
         || _ref_drop:=PxSelect.Pxgrp.TAB.PX_CONN;
            {? PX_CONN.seek(_ref_drop,8+_ref_drop)
            || {? PX_CONN.PX_GRP().BLK='T'
               || FUN.emsg('Element na który upuszczamy jest zablokowany, operacja przesunięcia zostaje wycofana.'@);
                  PxSelect.Pxgrp.TAB.cntx_pop();
                  win_set('cur_row_pos='+$_pos);
::                konczymy niepowodzeniem
                  return()
               |? PX_CONN.PX_GRP().STATUS=exec('status_wyk1','px_grp')
               || FUN.emsg('Element na który upuszczamy jest wykonywany, operacja przesunięcia zostaje wycofana.'@);
                  PxSelect.Pxgrp.TAB.cntx_pop();
                  win_set('cur_row_pos='+$_pos);
::                konczymy niepowodzeniem
                  return()
               |? PX_CONN.PX_GRP().STATUS=exec('status_wyk2','px_grp')
               || FUN.emsg('Element na który upuszczamy jest wykonany w całości, operacja przesunięcia zostaje wycofana.'@);
                  PxSelect.Pxgrp.TAB.cntx_pop();
                  win_set('cur_row_pos='+$_pos);
::                konczymy niepowodzeniem
                  return()
               || _poz:=PX_CONN.LP_GRP;
                  _ref:=PX_CONN.ref();
                  _korz:=PX_CONN.PX_GRP().ref()
               ?}
            ||
::             chcemy przeniesc na zwinieta galaz
               _ref_drop:=PxSelect.Pxgrp.TAB.PX_GRPI;
               {? PX_GRP.seek(_ref_drop,8+_ref_drop)
               || {? exec('is_blocked','px_grp')>0
                  || FUN.emsg('Element na który upuszczamy jest zablokowany, operacja przesunięcia zostaje wycofana.'@);
                     PxSelect.Pxgrp.TAB.cntx_pop();
                     win_set('cur_row_pos='+$_pos);
::                   konczymy niepowodzeniem
                     return()
                  |? PX_GRP.STATUS=exec('status_wyk1','px_grp')
                  || FUN.emsg('Element na który upuszczamy jest wykonywany, operacja przesunięcia zostaje wycofana.'@);
                     PxSelect.Pxgrp.TAB.cntx_pop();
                     win_set('cur_row_pos='+$_pos);
::                   konczymy niepowodzeniem
                     return()
                  |? PX_GRP.STATUS=exec('status_wyk2','px_grp')
                  || FUN.emsg('Element na który upuszczamy jest wykonany w całości, operacja przesunięcia zostaje wycofana.'@);
                     PxSelect.Pxgrp.TAB.cntx_pop();
                     win_set('cur_row_pos='+$_pos);
::                   konczymy niepowodzeniem
                     return()
                  || PX_CONN.cntx_psh;
                     PX_CONN.index('PX_GRP');
                     PX_CONN.prefix(PX_GRP.ref());
                     {? PX_CONN.last()
                     || _poz:=PX_CONN.LP_GRP+1;
                        _ref:=PX_CONN.ref();
                        _korz:=PX_CONN.PX_GRP().ref()
                     ||  _poz:=0; _ref:=null(); _korz:=PX_GRP.ref()
                     ?};
                     PX_CONN.cntx_pop()
                  ?}
               || _poz:=0; _ref:=null(); _korz:=null()
               ?}
            ?};
::          Rekord nadrzedny w TREE.TAB

            _parent:=PxSelect.Pxgrp.TAB.UPNODE;
            _parentt:=PxSelect.Pxgrp.TAB.PX_TEX;
            _parentj:=PxSelect.Pxgrp.TAB.JM;

            {? PxSelect.Pxgrp.TAB.seek(_records.REF,)
            ||
::             Tutaj obsluga dla upuszczania na tej samej galezi drzewa
               {? _parent=PxSelect.Pxgrp.TAB.UPNODE
               ||
::                wewnatrz galezi
::                Te rekordy beda podlagac renumeracji - ladujemy do tabeli pomocniczej jak w formule zmien_lp/dragdrop
                  {? PX_CONN.seek(PxSelect.Pxgrp.TAB.PX_CONN,8+PxSelect.Pxgrp.TAB.PX_CONN)
                  || PX_CONN.index('PX_GRP');
                     PX_CONN.prefix(PX_CONN.PX_GRP,PX_CONN.LP_GRP);
                     {? PX_CONN.first()
                     ||
                        {!
                        |? _tab_nr.blank();
                           _tab_nr.REF:=#PX_CONN.ref();
                           _tab_nr.SREF:=$PX_CONN.ref();
                           _tab_nr.P:=PX_CONN.LP_GRP;
                           _tab_nr.PXGRP:=#PX_CONN.PX_GRP;
                           _tab_nr.NUM:='N';
                           _tab_nr.PNEW:=0;
                           _tab_nr.add();
                           PX_CONN.next()
                        !};
                        _ost_nr:=PX_CONN.LP_GRP;
                        _ndx:=_tab_nr.ndx_tmp(,1,'SREF',,);
                        _tab_nr.index(_ndx);
                        {? _records.first()
                        ||
                           _lp:=0;
                           {!
                           |?
                              {? PxSelect.Pxgrp.TAB.seek(_records.REF,) &
                                 _tab_nr.find_key(PxSelect.Pxgrp.TAB.PX_CONN)
                              || {? _lp=0 || _pod:=_tab_nr.P ?};
                                 {? _poz>=_pod
                                 || _tab_nr.PNEW:=_poz+_lp-(_records.size()-1)
                                 || _tab_nr.PNEW:=_poz+_lp
                                 ?};
                                 _tab_nr.put();
                                 _lp+=1;
                                 1
                              ?};
                              _records.next()
                           !};
::                         Ustawienie numeracji dla pozostalych rekordow
                           _num:=_tab_nr.ndx_tmp('',,'NUM',,,'P',,);
                           _pnew:=_tab_nr.ndx_tmp('',,'PNEW',,,'P',,);
                           _tab_nr.index(_num);
                           _tab_nr.prefix('N');
                           {? _tab_nr.first()
                           || {!
                              |?
                                 _nr_new:=0;
                                 _tab_nr.cntx_psh();
                                 _tab_nr.index(_pnew);
                                 _nfind:=0;
                                 _nr:=_tab_nr.P;
                                 {? ~_tab_nr.find_key(_nr)
                                 || _nfind:=1;
                                    _nr_new:=_tab_nr.P
                                 ?};

                                 {? _nfind
                                 || _tab_nr.prefix(0);
                                    {? _tab_nr.first
                                    || _tab_nr.clear();
                                       _tab_nr.PNEW:=_nr_new;
                                       _tab_nr.put()
                                    ?}
                                 ?};
                                 _tab_nr.cntx_pop();
                                 _tab_nr.cntx_psh();
                                 _tab_nr.clear();
                                 _tab_nr.get();
                                 _tab_nr.NUM:='T';
                                 _tab_nr.put();
                                 _tab_nr.cntx_pop();
                                 _tab_nr.first
                              !}
                           ?};
                           _tab_nr.prefix();
::                         Ustawienie nowej numeracji
                           PX_CONN.prefix(PX_CONN.PX_GRP);
                           {? PX_CONN.last()
                           ||
::                            Stempluje kolejke czasem i userem modyfikacji
                              exec('mod_stamp_queue','px_ver',PX_CONN.PX_VER);
                              {!
                              |? PX_CONN.LP_GRP:=PX_CONN.LP_GRP+_ost_nr;
                                 PX_CONN.put();
                                 PX_CONN.prev()
                              !}
                           ?};
                           {? _tab_nr.last()
                           || {!
                              |? {? _tab_nr.PNEW<>0
                                 || {? PX_CONN.seek(_tab_nr.REF,)
                                    || PX_CONN.LP_GRP:=_tab_nr.PNEW;
                                       PX_CONN.put();

::                                     Stempluje kolejke czasem i userem modyfikacji
                                       exec('mod_stamp_queue','px_ver',PX_CONN.PX_VER)
                                    ?}
                                 ?};
                                 _tab_nr.prev()
                              !}
                           ?};
                           _tab_nr.ndx_drop(_ndx)
                        ?}
                     ?}
                  ?};
                  PxSelect.Pxgrp.TAB.sel_del()
               ||
::                przeniesienie do innej galezi drzewa
                  {? _parentt=PxSelect.Pxgrp.TAB.PX_TEX & (_parentj=PxSelect.Pxgrp.TAB.JM | _parentj='')
                  ||
::                   technologie sie zgadzaja
                     PX_CONN.clear();
                     {? PX_CONN.seek(PxSelect.Pxgrp.TAB.PX_CONN,8+PxSelect.Pxgrp.TAB.PX_CONN)
                     || PX_CONN.PX_GRP:=_korz;
                        PX_CONN.put();

::                      Stempluje kolejke czasem i userem modyfikacji
                        exec('mod_stamp_queue','px_ver',PX_CONN.PX_VER);

                        {? exec('is_one_version','px_param')>0
                        ||
::                         Jesli praca na jednej wersji to przeniesienie jakiegos PX_CONNa
::                         do innnej grupy musi wyciac pozycje planu calej grupy
::                         po to aby ktos w tym czasie nie zaczal np rejestrowac wykonan
::                         do pozycji planu z grupy ktora zostala wlasnie przekonfigurowana
                           exec('clean_from_plan','px_grp',PX_CONN.PX_GRP)
                        ?};

                        PX_CONN.index('PX_GRP');
                        PX_CONN.prefix(PX_CONN.PX_GRP,PX_CONN.LP_GRP);
                        {? PX_CONN.first()
                        || {!
                           |? _tab_nr.blank();
                              _tab_nr.REF:=#PX_CONN.ref();
                              _tab_nr.SREF:=$PX_CONN.ref();
                              _tab_nr.P:=PX_CONN.LP_GRP;
                              _tab_nr.PXGRP:=#_korz;
                              _tab_nr.NUM:='N';
                              _tab_nr.PNEW:=0;
                              _tab_nr.add();
                              PX_CONN.next()
                           !};
                           _ost_nr:=PX_CONN.LP_GRP;

                           _ndx:=_tab_nr.ndx_tmp(,1,'SREF',,);
                           _tab_nr.index(_ndx);
                           {? _records.first()
                           || _lp:=0;
                              {!
                              |? {? PxSelect.Pxgrp.TAB.seek(_records.REF,) & _tab_nr.find_key(PxSelect.Pxgrp.TAB.PX_CONN)
                                 ||
                                    {? _lp=0 || _pod:=_tab_nr.P ?};
                                    {? _poz>=_pod
                                    || _tab_nr.PNEW:=_poz+_lp-(_records.size()-1)
                                    || _tab_nr.PNEW:=_poz+_lp
                                    ?};
                                    _tab_nr.put();
                                    _lp+=1;
                                    1
                                 ?};
                                 _records.next()
                              !};

::                            Ustawienie numeracji dla pozostalych rekordow
                              _num:=_tab_nr.ndx_tmp('',,'NUM',,,'P',,);
                              _pnew:=_tab_nr.ndx_tmp('',,'PNEW',,,'P',,);
                              _tab_nr.index(_num);
                              _tab_nr.prefix('N');
                              {? _tab_nr.first()
                              || {!
                                 |? _nr_new:=0;
                                    _tab_nr.cntx_psh();
                                    _tab_nr.index(_pnew);
                                    _nfind:=0;
                                    _nr:=_tab_nr.P;
                                    {? ~_tab_nr.find_key(_nr)
                                    || _nfind:=1;
                                       _nr_new:=_tab_nr.P
                                    ?};

                                    {? _nfind
                                    || _tab_nr.prefix(0);
                                       {? _tab_nr.first
                                       || _tab_nr.clear();
                                          _tab_nr.PNEW:=_nr_new;
                                          _tab_nr.put()
                                       ?}
                                    ?};
                                    _tab_nr.cntx_pop();
                                    _tab_nr.cntx_psh();
                                    _tab_nr.clear();
                                    _tab_nr.get();
                                    _tab_nr.NUM:='T';
                                    _tab_nr.put();
                                    _tab_nr.cntx_pop();
                                    _tab_nr.first
                                 !}
                              ?};
                              _tab_nr.prefix();

::                            Ustawienie nowej numeracji
                              PX_CONN.prefix(PX_CONN.PX_GRP);
                              {? PX_CONN.last()
                              ||
::                               Stempluje kolejke czasem i userem modyfikacji
                                 exec('mod_stamp_queue','px_ver',PX_CONN.PX_VER);
                                 {!
                                 |? PX_CONN.LP_GRP:=PX_CONN.LP_GRP+_ost_nr;
                                    PX_CONN.put();
                                    PX_CONN.prev()
                                 !}
                              ?};
                              {? _tab_nr.last()
                              || {!
                                 |? {? _tab_nr.PNEW<>0
                                    || {? PX_CONN.seek(_tab_nr.REF,)
                                       || PX_CONN.LP_GRP:=_tab_nr.PNEW;
                                          PX_CONN.put();

::                                        Stempluje kolejke czasem i userem modyfikacji
                                          exec('mod_stamp_queue','px_ver',PX_CONN.PX_VER)
                                       ?}
                                    ?};
                                    _tab_nr.prev()
                                 !}
                              ?};
                              _tab_nr.ndx_drop(_ndx)
                           ?}
                        ?}
                     ?};
                     PxSelect.Pxgrp.TAB.sel_del()
                  || {? _parentj<>PxSelect.Pxgrp.TAB.JM
                     || FUN.emsg('Jednostka miary obiektu różna od jednostki miary obiektów zgrupowanych.\n'
                                 'Przeniesienie zostaje przerwane.'@)
                     || FUN.emsg('Technologia obiektu różna od technologii grupującej.\n'
                                 'Przeniesienie zostaje przerwane.'@)
                     ?};
                     PxSelect.Pxgrp.TAB.cntx_pop();
                     win_set('cur_row_pos='+$_pos);
                     return()
                  ?}
               ?}
            ?}
         ?}
      ?}
   ?};
   exec('prenumber','px_grp');
   PxSelect.Pxgrp.replica();
   PxSelect.Pxgrp.load();
   PxSelect.Pxgrp.update();

   PxSelect.Pxgrp.TAB.clear();
   {? PxSelect.Pxgrp.TAB.first()
   || {!
      |?
         PxSelect.Pxgrp.TAB1.blank();
         PxSelect.Pxgrp.TAB1.REF:=PxSelect.Pxgrp.TAB.REF;
         {? PxSelect.Pxgrp.TAB1.find_rec()
         || PxSelect.Pxgrp.TAB.HIDDEN:=PxSelect.Pxgrp.TAB1.HIDDEN;
            PxSelect.Pxgrp.TAB.EXPANDED:=PxSelect.Pxgrp.TAB1.EXPANDED;
            PxSelect.Pxgrp.tab_txt();
            PxSelect.Pxgrp.TAB.put()
         || PxSelect.Pxgrp.TAB.HIDDEN:=0;
            PxSelect.Pxgrp.TAB.EXPANDED:=1;
            PxSelect.Pxgrp.tab_txt();
            PxSelect.Pxgrp.TAB.put()
         ?};
         PxSelect.Pxgrp.TAB.next()
      !}
   ?};
   PxSelect.Pxgrp.TAB.blank();
   PxSelect.Pxgrp.TAB.REF:=_reftab;
   PxSelect.Pxgrp.TAB.find_rec()
?};
PxSelect.Pxgrp.TAB.cntx_pop();

:: Obsluga blokowania - odblokowuje wszystko co wczesniej probowalem zablokowac
_can_continue:=1;
PxSelect.Pxgrp.TAB.cntx_psh(); PxSelect.Pxgrp.TAB.clear();

:: 1. Odblokowanie grupy na ktora upuszczam
{? _dest_rec<>null()
|| {? PxSelect.Pxgrp.TAB.seek(_dest_rec)
   || _dest_grp:=exec('FindAndGet','#table',PX_GRP,PxSelect.Pxgrp.TAB.PX_GRPI,,,null());
      exec('unlock','px_grp',_dest_grp)
   ?}
?};
:: 2. Odblokowanie grup ktore przemieszczam
{? _can_continue>0
|| {? _records.first()
   || {!
      |? {? PxSelect.Pxgrp.TAB.seek(_records.REF,)
         || _moved_grp:=exec('FindAndGet','#table',PX_GRP,PxSelect.Pxgrp.TAB.PX_GRPI,,,null());
            exec('unlock','px_grp',_moved_grp)
         ?};
         _records.next()
      !}
   ?}
?};
PxSelect.Pxgrp.TAB.cntx_pop();

:: Aktualizuje przyciski dot przeliczania jednej wersji planu
{? exec('is_one_version','px_param')>0
|| exec('przelicz_btn','px_plan')
?};
~~


\prenumber
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: przenumerowanie pol
::   WE: [_a] - wersja ktorej przenumerowac kolejke - domyslnie wartosc PxSelect.VER_QUE
::       [_b] - STRING - rodzaj kolejki do przenumerowania, domyślnie 'Z'
::----------------------------------------------------------------------------------------------------------------------
_ver:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ver:=_a
|| _ver:=PxSelect.VER_QUE
?};
_kind:='Z';
{? var_pres('_b')=type_of('')
|| _kind:=_b
?};

_pxgrp:=0;
PX_GRP.cntx_psh();
PX_CONN.cntx_psh();
PX_GRP.index('LP');
PX_CONN.index('PX_GRP');
PX_GRP.prefix(_ver,_kind);

_has_frac:=0;
:: Najpierw usuwany puste galezie
{? PX_GRP.first()
|| {!
   |?
      _next:=0;
      _ref_nxt:=null();
      PX_GRP.cntx_psh();
      {? PX_GRP.next()
      || _ref_nxt:=PX_GRP.ref()
      ?};
      PX_GRP.cntx_pop();

      PX_CONN.prefix(PX_GRP.ref());
      {? PX_CONN.first()
      || _can_del:=0
      || _can_del:=1
      ?};

      {? _can_del>0
      || exec('delete','px_grp',PX_GRP.ref())
      || {? frac(PX_GRP.LP_Q)>0
         || _has_frac:=1
         ?}
      ?};

      {? _ref_nxt<>null()
      || _next:=PX_GRP.seek(_ref_nxt)
      ?};
      _next>0
   !}
?};
_grp_max:=0;
:: Poniewaz bede modyfikowal pola ktore sa w kluczach indeksowych potrzebne sa dwie petle numerujace
{? PX_GRP.last()
|| _con_max:=0;
   {? _has_frac>0
   ||
::    Kolejka ma ułamki
::    Ostani numer to rozmiar kolejki +1
      _grp_max:=PX_GRP.size()+1
   ||
::    kolejka nie ma ułamków
::    poniewaz klucz indeksowy jest ponumerowany od najmniejszego to ostatni element ma najwyzszy numer
      _grp_max:=PX_GRP.LP_Q
   ?};

   {? PX_GRP.last()
   || {!
      |? _next:=0;
         _ref_nxt:=null();
         PX_GRP.cntx_psh();
         {? PX_GRP.prev()
         || _ref_nxt:=PX_GRP.ref()
         ?};
         PX_GRP.cntx_pop();

         PX_GRP.LP_Q:=_grp_max;
         _can_continue:=PX_GRP.put();

         PX_CONN.prefix(PX_GRP.ref());
         {? PX_CONN.last()
         || _con_max:=PX_CONN.LP_GRP+1;
            {!
            |? PX_CONN.LP_GRP:=_con_max;
               PX_CONN.put();
               _con_max-=1;
               PX_CONN.prev()
            !}
         ?};
         _grp_max-=1;

         {? _ref_nxt<>null()
         || _next:=PX_GRP.seek(_ref_nxt)
         ?};
         _next>0 & _can_continue>0
      !}
   ?}
?};

{? PX_GRP.first()
|| {!
   |? _pxcon:=0;
      _pxgrp+=1;
      _ilosc:=0;

      _lpq_bef:=PX_GRP.LP_Q;

      PX_CONN.prefix(PX_GRP.ref());
      {? PX_CONN.first()
      || {!
         |? _pxcon+=1;
            PX_CONN.LP_GRP:=_pxcon;
            _ilosc+=PX_CONN.ILOSC;
            PX_CONN.put();
            PX_CONN.next()
         !}
      ?};
      PX_GRP.LP_Q:=_pxgrp;
      _il0:=PX_GRP.ILOSC;
      PX_GRP.ILOSC:=_ilosc;
      PX_GRP.put();

::    Przy zmianie ilości "naprawa" GROPS
      {? _il0<>_ilosc
      || exec('plan_restore_grop','zl_grop',PX_GRP.GROPS().GROP)
      ?};

::    Stempluje kolejke czasem i userem modyfikacji
      exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER);

::    aktualizuje pole materiału
      exec('update_m','px_grp',PX_GRP.ref());

      PX_GRP.next()
   !}
?};
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();

{? exec('is_grop','px_param') & _kind='Z'
||
:: Po przenumerowaniu kolejki zleceń i zamówień przenumerowuję kolejkę dla grup
   exec('prenumber','px_grp',_ver,'G')
?};
1


\level_px_gen
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: Kolejny poziom drzewa
::   WE: _a - (0 jak korzen)
::       _b - up-node (w strukturze drzewa)
::       _c - Nazwa obiektu, np. '@.PxSelect.Pxgrp'
::----------------------------------------------------------------------------------------------------------------------
PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');
PX_CONN.prefix(_a);
{? PX_CONN.first()
|| {!
   |? exec('level','px_grp',_b,_c);
      PX_CONN.next()
   !}
?};
PX_CONN.cntx_pop();
~~


\level
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: biezacy poziom struktury operacji
::   WE: _a - up-node (w strukturze drzewa)
::       _b - nazwa obiektu, np. '@.PxSelect.Pxgrp'
::----------------------------------------------------------------------------------------------------------------------
:: Uwaga: w celu optymalizacji wywolan wazna jest kolejnosc podczytan pol zlaczeniowych
::        dotyczy PX_GRP i PX_OBJ
_upnode:=_a;
_obiekt:=_b;
_node:=_obiekt.add(#PX_CONN.PX_GRP,'exec(''gx_grp'',''px_grp'',!.)',_upnode);
:: Uwaga: podczytanie PX_GRP
_obiekt.value(_node,'UID',PX_CONN.PX_GRP().UID);
_obiekt.value(_node,'TYP','PX_CONN');
_obiekt.value(_node,'PX_GRPI',$PX_GRP.ref());
_obiekt.value(_node,'PX_CONN',$PX_CONN.ref());
_obiekt.value(_node,'LP_Q',PX_CONN.PX_GRP().LP_Q);
_obiekt.value(_node,'SYMBOL',PX_GRP.SYMBOL);
_obiekt.value(_node,'NAZWA',PX_GRP.NAZWA);
_obiekt.value(_node,'ILOSC',PX_GRP.ILOSC);
_obiekt.value(_node,'DIR',$PX_GRP.DIR);
_obiekt.value(_node,'PX_TEX',#PX_GRP.PX_TEX);
_obiekt.value(_node,'STARTD',#PX_GRP.STARTD);
_obiekt.value(_node,'STARTT',$PX_GRP.STARTT);
_obiekt.value(_node,'TM_START',PX_GRP.TM_START);
_obiekt.value(_node,'ENDD',#PX_GRP.ENDD);
_obiekt.value(_node,'ENDT',$PX_GRP.ENDT);
_obiekt.value(_node,'TM_END',PX_GRP.TM_END);
_obiekt.value(_node,'M',{? PX_CONN.M<>null || PX_CONN.M().N || '' ?});
{? _upnode<>0
|| _obiekt.value(_node,'C_ILOSC',PX_CONN.ILOSC);
   _obiekt.value(_node,'LP_GRP',PX_CONN.LP_GRP);
   _obiekt.value(_node,'PX_OBJ',$PX_CONN.PX_OBJ)
|| _obiekt.value(_node,'C_ILOSC',0);
   _obiekt.value(_node,'LP_GRP',0);
   _obiekt.value(_node,'PX_OBJ','')
?};
:: Uwaga: podczytanie PX_OBJ
_obiekt.value(_node,'JM',PX_CONN.PX_OBJ().JM().KOD);
_obiekt.value(_node,'T_REAL',$PX_OBJ.ENDD().DATA);
_obiekt.value(_node,'T_QUEUE','');
_obiekt.value(_node,'STATUS',PX_GRP.STATUS);
_obiekt.value(_node,'PL_FORCE',PX_GRP.PL_FORCE);
PX_POZ.cntx_psh();
_prefix_mode:=exec('poz_prefix_mode','px_grp');
{? _prefix_mode='SOURCE'
|| PX_GRP.cntx_psh();
   PX_GRP.index('UID');
   PX_GRP.prefix(PX_GRP.UID_SRC);
   {? PX_GRP.first()
   || PX_POZ.index('TM_VOBJ');
      PX_POZ.prefix(PX_GRP.PX_VER,PX_CONN.PX_OBJ);
      {? PX_POZ.first()
      || _obiekt.value(_node,'T_START',tm_form(PX_POZ.TM_START))
      || _obiekt.value(_node,'T_START','')
      ?};
      PX_POZ.index('TM_VOBJ2');
      PX_POZ.prefix(PX_GRP.PX_VER,PX_CONN.PX_OBJ);
      {? PX_POZ.last()
      || _obiekt.value(_node,'T_PLAN',tm_form(PX_POZ.TM_END))
      || _obiekt.value(_node,'T_PLAN','')
      ?}
   ?};
   PX_GRP.cntx_pop()
|| PX_POZ.index('TM_VOBJ');
   PX_POZ.prefix(PX_GRP.PX_VER,PX_CONN.PX_OBJ);
   {? PX_POZ.first()
   || _obiekt.value(_node,'T_START',tm_form(PX_POZ.TM_START))
   || _obiekt.value(_node,'T_START','')
   ?};
   PX_POZ.index('TM_VOBJ2');
   PX_POZ.prefix(PX_GRP.PX_VER,PX_CONN.PX_OBJ);
   {? PX_POZ.last()
   || _obiekt.value(_node,'T_PLAN',tm_form(PX_POZ.TM_END))
   || _obiekt.value(_node,'T_PLAN','')
   ?}
?};
PX_POZ.cntx_pop();
_obiekt.value(_node,'KOLOR','0:0:0,'+PX_OBJ.KOLOR);
_obiekt.value(_node,'ZNACZNIK',{? PX_GRP.DIR=-1 || exec('txt_plan_bck','px_param') || exec('txt_plan_fwd','px_param') ?});
_obiekt.value(_node,'PROBLEMS','');
_obiekt.value(_node,'KOM_ERR',PX_CONN.KOM_ERR);
_obiekt.value(_node,'KOM_WARN',PX_CONN.KOM_WARN);
_obiekt.value(_node,'KOM_INFO',PX_CONN.KOM_INFO);

~~


\level1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: to jest korzen struktury grupujacy
::   WE: _a - up-node (w strukturze drzewa)
::       _b - nazwa obiektu, np. '@.PxSelect.Pxgrp'
::----------------------------------------------------------------------------------------------------------------------
_upnode:=_a;
_obiekt:=_b;

_node:=_obiekt.add(#PX_GRP.ref(),'exec(''gx_grp'',''px_grp'',!.)',_upnode);
_obiekt.value(_node,'UID',PX_GRP.UID);
_obiekt.value(_node,'TYP','PX_GRP');
_obiekt.value(_node,'PX_GRPI',$PX_GRP.ref());
_obiekt.value(_node,'PX_CONN','');
_obiekt.value(_node,'LP_Q',PX_GRP.LP_Q);
_obiekt.value(_node,'SYMBOL',PX_GRP.SYMBOL);
_obiekt.value(_node,'NAZWA',PX_GRP.NAZWA);
_obiekt.value(_node,'ILOSC',PX_GRP.ILOSC);
_obiekt.value(_node,'BLK',PX_GRP.BLK);
_obiekt.value(_node,'PLAN_OPR',PX_GRP.PLAN_OPR);
_obiekt.value(_node,'DIR',$PX_GRP.DIR);
_obiekt.value(_node,'PX_TEX',#PX_GRP.PX_TEX);
_obiekt.value(_node,'STARTD',#PX_GRP.STARTD);
_obiekt.value(_node,'STARTT',$PX_GRP.STARTT);
_obiekt.value(_node,'TM_START',PX_GRP.TM_START);
_obiekt.value(_node,'ENDD',#PX_GRP.ENDD);
_obiekt.value(_node,'ENDT',$PX_GRP.ENDT);
_obiekt.value(_node,'TM_END',PX_GRP.TM_END);
_obiekt.value(_node,'C_ILOSC',0);
_obiekt.value(_node,'LP_GRP',0);
_obiekt.value(_node,'PX_OBJ','');
_obiekt.value(_node,'M',{? PX_GRP.M<>null || PX_GRP.M().N || '' ?});

_wyn:=exec('pxgrpjm','px_grp',PX_GRP.ref());
_obiekt.value(_node,'JM',_wyn);

_wyn:=exec('pxgrptreal','px_grp',PX_GRP.ref());
_obiekt.value(_node,'T_REAL',_wyn);

_obiekt.value(_node,'T_QUEUE',$PX_GRP.STARTD().DATA);
_obiekt.value(_node,'STATUS',PX_GRP.STATUS);
_obiekt.value(_node,'PL_FORCE',PX_GRP.PL_FORCE);
_prefix_mode:=exec('poz_prefix_mode','px_grp');
{? _prefix_mode='SOURCE'
||
   PX_GRP.cntx_psh();
   PX_GRP.index('UID');
   PX_GRP.prefix(PX_GRP.UID_SRC);
   {? PX_GRP.first()
   ||
      {? PX_GRP.STRSTART<>''
      || _obiekt.value(_node,'T_START',PX_GRP.STRSTART)
      || _obiekt.value(_node,'T_START','<brak poz>')
      ?};
      {? PX_GRP.STREND<>''
      || _obiekt.value(_node,'T_PLAN',PX_GRP.STREND)
      || _obiekt.value(_node,'T_PLAN','<brak poz>')
      ?}
   || _obiekt.value(_node,'T_PLAN','')
   ?};
   PX_GRP.cntx_pop()
|| {? PX_GRP.STRSTART<>''
   || _obiekt.value(_node,'T_START',PX_GRP.STRSTART)
   || _obiekt.value(_node,'T_START','<brak poz>')
   ?};
   {? PX_GRP.STREND<>''
   || _obiekt.value(_node,'T_PLAN',PX_GRP.STREND)
   || _obiekt.value(_node,'T_PLAN','<brak poz>')
   ?}
?};

PX_POINT.cntx_psh();
PX_POINT.index('PX_GRP');
PX_POINT.prefix(PX_GRP.ref());
{? PX_POINT.first()
|| _obiekt.value(_node,'PX_POINT','T')
?};
PX_POINT.cntx_pop();

_obiekt.value(_node,'KOLOR','');
_obiekt.value(_node,'ZNACZNIK',{? PX_GRP.DIR=-1 || exec('txt_plan_bck','px_param') || exec('txt_plan_fwd','px_param') ?});
_obiekt.value(_node,'PROBLEMS',PX_GRP.PROBLEMS);

:: Analiza pol o komunikatach
_child_kom:=exec('kom_child_chk','px_grp',PX_GRP.ref());
_kom_err:=PX_GRP.KOM_ERR;
_kom_warn:=PX_GRP.KOM_WARN;
_kom_info:=PX_GRP.KOM_INFO;

:: Jesli PX_GRP nie mial swojego komunikatu to byc moze maja go jego skadniki czyli PX_CONN
{? _kom_err='N'
|| {? _child_kom*'E'>0
   || _kom_err:='T'
   ?}
?};
{? _kom_warn='N'
|| {? _child_kom*'W'>0
   || _kom_warn:='T'
   ?}
?};
{? _kom_info='N'
|| {? _child_kom*'I'>0
   || _kom_info:='T'
   ?}
?};

_obiekt.value(_node,'KOM_ERR',_kom_err);
_obiekt.value(_node,'KOM_WARN',_kom_warn);
_obiekt.value(_node,'KOM_INFO',_kom_info);

exec('level_px_gen','px_grp',#PX_GRP.ref(),_node,_obiekt);
~~


\pxgrpjm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: ustalenie jm dla wezla
::   WE: _a - up-node (w strukturze drzewa)
::       _b - maska
::----------------------------------------------------------------------------------------------------------------------
_wyn:='';
PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');
PX_CONN.prefix(_a);
{? PX_CONN.first()
|| _wyn:=PX_CONN.PX_OBJ().JM().KOD
?};
PX_CONN.cntx_pop();
_wyn


\pxgrptreal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: ustalenie terminu realizacji dla wezla grupujacego
::   WE: _a - PX_GRP.ref()
::----------------------------------------------------------------------------------------------------------------------
_result:=date(0,0,0);

PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');
PX_CONN.prefix(_a);
{? PX_CONN.first()
|| {!
   |?
      _termin:=PX_CONN.PX_OBJ().ENDD().DATA;
      {? _result=date(0,0,0) | _termin<_result || _result:=_termin ?};
      PX_CONN.next()
   !}
?};
PX_CONN.cntx_pop();

$_result


\gx_grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: opis galezi drzewa
::   WE: _a - Obiekt, np. '@.PxSelect.Pxgrp'
::----------------------------------------------------------------------------------------------------------------------
_obiekt:=($(_a))();
{? _obiekt.TAB.PX_OBJ=''
|| PX_GRP.cntx_psh();
   PX_GRP.clear();
   _wyn:={? PX_GRP.seek(_obiekt.TAB.PX_GRPI,PxSelect.mask)
         || $PX_GRP.LP_Q+'. '+PX_GRP.SYMBOL
         || {? PX_GRP.NAZWA=''
            || '<BRAK - technologii>'
            || PX_GRP.NAZWA
            ?}
         ?};
   PX_GRP.cntx_pop()
|| PX_CONN.cntx_psh();
   PX_CONN.clear();
   _wyn:={? PX_CONN.seek(_obiekt.TAB.PX_CONN,'pxcon'+(PxSelect.mask+3))
         || $PX_CONN.LP_GRP +'. '+PX_CONN.PX_OBJ().SYMBOL
         || '1. '+'<NIE ZNALEZIONO OBIEKTU>'
         ?};
   PX_CONN.cntx_pop()
?};
_wyn


\to_group_env
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Tabela grupująca obiekty w elementy kolejki, na jej podstawie powstaną rekordy
::       PX_GRP i PX_CONN
::   WE: _a - PX_VER.ref() - wersja planu
::       _b - INTEGER      - tryb wyświetlania dialogów
::   WY: obj_new - tablica nazwana
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_dialog:=_b;

_obj:=obj_new('TAB'
               ,'NDX_GRP'
               ,'NDX_ADD'
               ,'NDX_TEX'
               ,'NDX_TREE'

               ,'PX_VER'
               ,'DIALOG');

_tab:=tab_tmp(2,'TREE','TREE_REF','Drzewo',
                'SYMBOL','STRING[50]','Symbol',
                'TYPE','STRING[1]','Typ rekordu: G - grupa, O - obiekt',
                'GRP_STR','STRING[50]','String grupujący',
                'JM', 'STRING[10]','jm',
                'Z','STRING[1]','T/N',
                'PX_OBJ','STRING[16]','Obiekt',
                'PX_TEX','STRING[16]','Technologia',
                'IL','REAL','Ilość',
                'DIR','INTEGER','Zwrot planowania',
                'TM_ADD','REAL','Tm stamp utworzenia rekordu',
                'TM_REA','REAL','Tm stamp najwcześniejszego terminu realizacji',
                'PX_SET','STRING[16]','Zestaw',
                'GROPS','STRING[16]','Zasób z grupy operacji'
               );
_obj.TAB:=_tab;
_obj.NDX_GRP:=_tab.ndx_tmp(,,'TYPE',,,'GRP_STR',,,'JM',,);
_obj.NDX_ADD:=_tab.ndx_tmp(,,'TYPE',,,'TM_ADD',,);
_obj.NDX_TEX:=_tab.ndx_tmp(,,'TYPE',,,'PX_TEX',,,'JM',,);
_obj.NDX_TREE:=_tab.ndx_tmp(,,'TREE',,,'TM_ADD',,);

_obj.PX_VER:=_px_ver;
_obj.DIALOG:=_dialog;

_obj


\to_group
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Grupuje planowany obiekt
::   WE:  _a - obj_new - środowisko grupowania, wynik exec('to_group_env','px_grp')
::        _b - PX_OBJ.ref() - obiekt do planu lub bieżący rekord
::        _c - STRING - sposób grupowania: 'GROUP_NONE'  - brak
::                                         'GROUP_TEX'   - technologia
::                                         'GROUP_TAG'   - grupa obiektów
::                                         'GROUP_GROPS' - grupa operacji
::       [_d] - REAL         - jeżeli brak grupowania to ilość jaką przypisać
::       [_e] - PX_TEX.ref() - jeżeli brak grupowania to technologia którą przypisać
::       [_f] - GROPS.ref()  - jeżeli brak grupowania to zasób z grupy operacji który przypisać
::       [_g] - INTEGER      - zwrot
::
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_ref:=null();
{? var_pres('_b')=type_of(PX_OBJ.ref())
|| _ref:=_b
?};
_mode:=_c;

_ilosc:=0;
{? var_pres('_d')=type_of(0)
|| _ilosc:=_d
?};

_px_tex:=null();
{? var_pres('_e')=type_of(PX_TEX.ref())
|| _px_tex:=_e
?};

_grops:=null();
{? var_pres('_f')=type_of(GROPS.ref())
|| _grops:=_f
?};

_dir:=0;
{? var_pres('_g')=type_of(0)
|| _dir:=_g
?};

_result:=0;
_can_continue:=1;

PX_OBJ.cntx_psh();
{? _ref<>null()
|| PX_OBJ.prefix();
   {? PX_OBJ.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _grouping_id:=exec('to_group_id','px_grp',_mode,_grops);

   {? _grouping_id='BŁĄD' | _grouping_id=''
   || _can_continue:=0
   ?};

   {? _can_continue>0
   ||
      _tab:=_env.TAB;
      _tab.index(_env.NDX_GRP);
      _tab.prefix('G',_grouping_id,PX_OBJ.JM().KOD,);
      {? _tab.first()
      || {? exec('to_group_add_conn','px_grp',_env,_tab.ref(),_ilosc)=null()
         || _can_continue:=0
         ?}
      || _tab.blank();
         _tab.TYPE:='G';
         _tab.GRP_STR:=_grouping_id;
         _tab.JM:=PX_OBJ.JM().KOD;
         {? _px_tex<>null()
         || _tab.PX_TEX:=$_px_tex
         |? PX_OBJ.PX_TAG<>null() & _mode='GROUP_TAG'
         || _tab.PX_TEX:=$exec('get_default_tex','px_tag',PX_OBJ.PX_TAG)
         || _tab.PX_TEX:=$exec('get_default_tex','px_tex',PX_OBJ.ref(),1)
         ?};
         _tab.Z:='T';
         _tab.TM_ADD:=SYSLOG.tm_stamp();
         _tab.PX_SET:=$PX_OBJ.PX_SET;
         _tab.GROPS:=$_grops;
         {? _dir<>0
         || _tab.DIR:=_dir
         || _tab.DIR:=PX_OBJ.DIR
         ?};
         {? _tab.add()
         || {? exec('to_group_add_conn','px_grp',_env,_tab.ref(),_ilosc)=null()
            || _can_continue:=0
            ?}
         || _can_continue:=0
         ?};
         ~~
      ?}
   ?}
?};
PX_OBJ.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\to_group_id
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca identyfikator po którym będą zgrupowane obiekty
::       Kontekst pracy: PX_OBJ
::   WE: _a - STRING - sposób grupowania: 'GROUP_NONE'  - brak
::                                        'GROUP_TEX'   - technologia
::                                        'GROUP_TAG'   - grupa obiektów
::                                        'GROUP_GROPS' - grupa operacji
::   WY: STRING - identyfikator grupujący lub 'BŁĄD' jeżeli nie znaleziono
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_mode:=_a;
_grops:=null();
{? var_pres('_b')=type_of(GROPS.ref())
|| _grops:=_b
?};
_result:='';
PX_TAG.cntx_psh();
{? _mode='GROUP_NONE'
|| _result:=PX_OBJ.uidref()
|? _mode='GROUP_TEX'
|| _px_tex:=exec('get_default_tex','px_tex',PX_OBJ.ref(),1);
   {? _px_tex<>null()
   || _result:=exec('FindAndGet','#table',PX_TEX,_px_tex,,"PX_TEX.uidref()",'')
   || _result:='BŁĄD'
   ?}
|? _mode='GROUP_TAG'
|| {? PX_OBJ.PX_TAG<>null()
   || _result:=PX_OBJ.PX_TAG().uidref()
   || _result:='BŁĄD'
   ?}
|? _mode='GROUP_GROPS'
|| {? _grops<>null()
   ||
::    Każda grupa operacji tworzy zawsze osobny element kolejki
      _result:='GROPSid: '+$SYSLOG.tm_stamp()
   || _result:='BŁĄD'
   ?}
?};
PX_TAG.cntx_pop();
_result


\to_group_add_conn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Dodaje do tabelki rekord który później stworzy PX_CONN
::       Kontekst pracy: PX_OBJ
::   WE: _a - obj_new    - środowisko grupowania, wynik exec('to_group_env','px_grp')
::       _b - .TAB.ref() - ref parenta
::       [_c] - REAL - ilość jaką przypisać, jeżeli nie podano to maksymalna jaka została do zaplanowania
::   WY: ref() dodanego rekordu lub null()
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_parent:=_b;
_ilosc:=0;
{? var_pres('_c')=type_of(0)
|| _ilosc:=_c
?};

_result:=null();
_can_continue:=1;

_tab:=_env.TAB;

_tab.cntx_psh();
_tab.prefix();
_tab.blank();
_tab.TYPE:='C';
_tab.TREE:=#_parent;
_tab.PX_OBJ:=$PX_OBJ.ref();
{? _ilosc>0
|| _tab.IL:=_ilosc
|| _tab.IL:=PX_OBJ.IL-exec('get_ilosc_que','px_obj',_env.PX_VER,PX_OBJ.ref())
?};
_tab.SYMBOL:=exec('PX_OBJ','#to_string');
_tab.Z:='T';
_tab.PX_SET:=$PX_OBJ.PX_SET;
_tab.TM_ADD:=SYSLOG.tm_stamp();
_tab.TM_REA:=PX_OBJ.TM_REA;

{? _tab.IL<0
|| _can_continue:=0;
   _msg:='Dla: %1 próba dodania ilości większej niż w obiekcie.'@[PX_OBJ.SYMBOL];
   {? _env.DIALOG=2
   || KOMM.add(_msg,2,,1)
   |? _env.DIALOG=3
   || _komm_args:=exec('add_komm_a','px_komm');
      _komm_args.PX_VER:=_px_ver;
      _komm_args.PX_OBJ:=PX_OBJ.ref();
      _komm_args.TYP:=exec('type_error','px_komm');
      _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
      _komm_args.MESSAGE:=_msg;
      exec('add_komm','px_komm',_komm_args);
      ~~
   ?};
      ~~
|? _tab.IL=0
|| _can_continue:=0;
   _msg:='Dla: %1 wszystko już zaplanowano albo obiekt bez ilości.'@[PX_OBJ.SYMBOL];
   {? _env.DIALOG=2
   || KOMM.add(_msg,2,,1)
   |? _env.DIALOG=3
   || _komm_args:=exec('add_komm_a','px_komm');
      _komm_args.PX_VER:=_px_ver;
      _komm_args.PX_OBJ:=PX_OBJ.ref();
      _komm_args.TYP:=exec('type_error','px_komm');
      _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
      _komm_args.MESSAGE:=_msg;
      exec('add_komm','px_komm',_komm_args);
      ~~
   ?};
   ~~
|? PX_OBJ.ENDD().DATA<date()
|| _can_continue:=0;
   _msg:='Dla: %1 próba dodania obiektu o dacie wcześniejszej niż bieżąca.'@[PX_OBJ.SYMBOL];
   {? _env.DIALOG=2
   || KOMM.add(_msg,2,,1)
   |? _env.DIALOG=3
   || _komm_args:=exec('add_komm_a','px_komm');
      _komm_args.PX_VER:=_px_ver;
      _komm_args.PX_OBJ:=PX_OBJ.ref();
      _komm_args.TYP:=exec('type_error','px_komm');
      _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
      _komm_args.MESSAGE:=_msg;
      exec('add_komm','px_komm',_komm_args);
      ~~
   ?};
   ~~
?};
{? _can_continue>0
||
   {? _tab.add()>0
   || _result:=_tab.ref()
   ?}
?};
_tab.cntx_pop();
_result


\to_group_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Aktualizuje ilości i terminy w tabeli z pogrupowanymi obiektami
::   WE: _a - obj_new    - środowisko grupowania, wynik exec('to_group_env','px_grp')
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;

_tab:=_env.TAB;

_can_continue:=1;
_result:=0;

_tab.cntx_psh();
_tab.index(_env.NDX_ADD);
_tab.prefix('G');

:: Najpierw usuwamy puste gałęzie
{? _tab.first()
|| {!
   |? _next:=0;
      _ref_nxt:=null();
      _tab.cntx_psh();
      {? _tab.next()
      || _ref_nxt:=_tab.ref()
      ?};
      _tab.cntx_pop();

      _delete:=0;

      _tab.cntx_psh();
      _tab.index(_env.NDX_TREE);
      _tab.prefix(#_tab.ref());
      {? _tab.size()=0
      || _delete:=1
      ?};
      _tab.cntx_pop();

      {? _delete>0
      || _can_continue:=_tab.del(,1)
      ?};

      {? _ref_nxt<>null()
      || _next:=_tab.seek(_ref_nxt)
      ?};
      _next>0 & _can_continue>0
   !}
?};

:: Normalna aktualizacja ilości, terminów itp
{? _can_continue>0 & _tab.first()
|| {!
   |? _tab.cntx_psh();
      _tab.index(_env.NDX_TREE);
      _tab.prefix(#_tab.ref());
      _tm_rea:=0;
      _ilosc:=0;
      {? _tab.first()
      || {!
         |? _ilosc+=_tab.IL;
            {? _tm_rea=0 | _tm_rea>_tab.TM_REA
            || _tm_rea:=_tab.TM_REA
            ?};
            _tab.next()
         !}
      ?};
      _tab.cntx_pop();

      _tab.IL:=_ilosc;
      _tab.TM_REA:=_tm_rea;
      _can_continue:=_tab.put();

      _tab.next() & _can_continue>0
   !}
?};

_tab.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\tab_ran_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Dodaje rekord do tabeli __ran_grp
::   WE: _a - STRING       - $PX_TEX.ref()
::       _b - REAL         - ilosc
::       _c - STRING       - kod jednostki miary
::       _d - STRING       - 'T/N' - czy agregowanie włączone
::       _e - STRING       - identyfikator po którym grupować (ref technologii, ref obiektu grupującego itp)
::       _f - REAL         - 1/-1 - zwrot planowania
::       _g - REAL         - termin realizacji (tm_stamp)
::       _h - PX_SET.ref() - zestaw planistyczny
::       _i - STRING       - $GROPS.ref() - zasób z grupy operacji
::       _j - STRING       - $PX_OBJ.ref()
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;
_ilosc:=_b;
_jm:=_c;
_agr:=_d;
_grp_str:=_e;
_dir:=_f;
_tm_rea:=_g;
_px_set:=_h;
_grops:=_i;
_px_obj:=_j;

_result:=0;
_can_continue:=1;

_add:=1;
{? _agr='T'
|| _ndx:=__ran_grp.ndx_tmp(,,'GRP_STR',,,'JM',,,'DIR',,);
   __ran_grp.index(_ndx);
   __ran_grp.prefix(_grp_str,_jm,_dir);
   {? __ran_grp.first()
   || _add:=0;
      __ran_grp.IL+=1;
      __ran_grp.ILO+=_ilosc;
      {? __ran_grp.TM_REA=0 | __ran_grp.TM_REA>_tm_rea
      || __ran_grp.TM_REA:=_tm_rea
      ?};
      _can_continue:=__ran_grp.put()
   ?};
   __ran_grp.ndx_drop(_ndx)
?};
{? _add>0
|| __ran_grp.clear();
   __ran_grp.PX_TEX:=_px_tex;
   __ran_grp.GRP_STR:=_grp_str;
   __ran_grp.JM:=_jm;
   __ran_grp.ILO:=_ilosc;
   __ran_grp.IL:=1;
   __ran_grp.DIR:=_dir;
   __ran_grp.TM_REA:=_tm_rea;
   __ran_grp.TM_ADD:=SYSLOG.tm_stamp();
   __ran_grp.PX_SET:=$_px_set;
   __ran_grp.GROPS:=_grops;
   __ran_grp.PX_OBJ:=_px_obj;
   _can_continue:=__ran_grp.add()
?};
{? _can_continue>0
|| _result
?};
_result


\grn_data
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: ustalenie daty granicznej na podstawie parametrow
::   WY: data i czas
::----------------------------------------------------------------------------------------------------------------------
{? __blokada=2
|| 1
|| {? ~__blokada
   || _tab:=__dropped;
      PX_OBJ.cntx_psh();
      {? PX_VAR.GRN_DATA<date()
      || PX_VAR.GRN_DATA:=date();
         PX_VAR.GRN_TIME:=time()
      ?};
      _ddtt:=form(PX_VAR.ENDD)+':'+form(PX_VAR.ENDT);
      {? _tab.first()
      || {!
         |? {? PX_OBJ.seek(_tab.REF,)
            || {? ~PX_VAR.ADD_DIR
               || {? _ddtt<form(PX_OBJ.ENDD().DATA)+':'+form(PX_OBJ.ENDT)
                  || PX_VAR.GRN_DATA:=PX_OBJ.ENDD().DATA;
                     PX_VAR.GRN_TIME:=PX_OBJ.ENDT;
                     _ddtt:=form(PX_VAR.GRN_DATA)+':'+form(PX_VAR.GRN_TIME)
                  ?}
               ?}
            ?};
            _tab.next()
         !}
      ?};
      PX_OBJ.cntx_pop();
      win_disp();
      ~~
   || 0
   ?}
?}


\grn_dataar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: po redakcji pola data
::   WY: data i czas
::----------------------------------------------------------------------------------------------------------------------
{? cur_afld()='GRN_DATA'
|| _ok:={? PX_VAR.ADD_DIR=-1
        || {? PX_VAR.GRN_DATA<date()
           || FUN.emsg('Nie można planować wstecz dla dat wcześniejszych od bieżącej.'@);
              0
           || 1
           ?}
        || 1
        ?};
   {? _ok & PX_VAR.ADD_DIR=-1 & PX_VAR.ENDD=date(0,0,0)
   || PX_VAR.ADD_DIR:=1;
      _ok:=1
   ?};
   {? _ok & PX_VAR.GRN_DATA>PX_VAR.ENDD & PX_VAR.ENDD<>date(0,0,0)
   || FUN.emsg('Wprowadzona data jest późniejsza od terminu realizacji obiektu.\nTermin realizacji jest na: %1'@[form(PX_VAR.ENDD)]);
         _ok:=0
   ?};
   {? _ok & PX_VAR.GRN_DATA<date()
   || FUN.emsg('Nie można planować w przód dla dat wcześniejszych od bieżącej.'@);
      PX_VAR.GRN_DATA:=date();
      _ok:=0
   ?};
   _ok
|| 1
?}


\pxvaraddilar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: po redakcji pola px_var.add_il
::   WY: zmiana dokladnosci
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__dropped')>0
|| __dropped.cntx_psh();
   PX_OBJ.cntx_psh();
   PX_OBJ.clear();
   {? __dropped.first()
   || {? PX_OBJ.seek(__dropped.REF,)
      || PX_VAR.ADD_IL:=PX_VAR.ADD_IL$PX_OBJ.M().DOKL
      ?}
   ?};
   __dropped.cntx_pop();
   PX_OBJ.cntx_pop()
?};
{? PX_VAR.ADD_IL <= 0
|| FUN.emsg('Planowana ilość nie może być ujemna bądź równa zero.'@);
   0
|| 1
?}


\to_queue
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: ranking
::   WE: _a - tabela przenoszonych rekordow
::       _b - na co upuszczamy
::       [_c] - czy uzyc win_disp() po reorganziacji kolejki (domyslnie 1 = tak)
::       [_d] - PX_VER.ref() - wersja planu
::       [_e] - INTEGER - 0/[1] - czy wyświetlać okno edycyjne, czy dodawać wg domyślnych wartości
::       [_f] - INTEGER - 0/[1] - czy sprawdzać poprawność dodawania
::       [_g] - INTEGER - [0]/1 - czy akcja grupowa czy pojedyncza, jeśli nie podane to określane
::                                na podstawie rozmiaru _a
::       [_h] - INTEGER  - [0]/1 - czy automatycznie ustalać zestaw, czy brać bieżący ustawiony
::       [_i]   - INTEGER - tryb dialogów:   0 - brak,
::                                           1 - komunikaty na ekran
::                                           2 - komunikaty do KOMMa,
::                                           3 - komunikaty do PX_KOMM i do _mp.error
::       [_j] - PX_TAG.ref - grupa obiektów
::       [_k] - GROP.ref - grupa operacji
::   WY: 0 - nie dodano do kolejki
::       1 - dodano
::  OLD: \grupowanie/px_grp.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
exec('dropped_update','px_grp',_a);

{? var_pres('_c')=type_of(0) || _win_disp:=_c || _win_disp:=1 ?};
__dropped:=_dropped:=_a;
_drop_dest:=_b;
{? var_pres('_c')=type_of(0) || _win_disp:=_c || _win_disp:=1 ?};

{? var_pres('_d')=type_of(PX_VER.ref())
|| _px_ver:=_d
|| _px_ver:=PxSelect.VER_QUE
?};
_edit:=1;
{? var_pres('_e')=type_of(0)
|| _edit:=_e
?};

_ctrl:=1;
{? var_pres('_f')=type_of(0)
|| _ctrl:=_f
?};

{? var_pres('_g')=type_of(0)
|| _grupa:=_g
|| _grupa:={? _dropped.size()>1 || 1 || 0 ?}
?};

_autoset:=0;
{? var_pres('_h')=type_of(0)
|| _autoset:=_h
?};
_dialog:=1;
{? var_pres('_i')=type_of(0)
|| _dialog:=_i
?};
_px_tag:=null();
{? var_pres('_j')=type_of(PX_TAG.ref())
|| _px_tag:=_j
?};
_grop:=null();
{? var_pres('_k')=type_of(PX_TAG.ref())
|| _grop:=_k
?};

_result:=0;
_can_continue:=1;

__blokada:=0;
PX_VAR.GROPS:=null();
PX_VAR.GROP:=_grop;
PL_RES.blank();

{? _grupa=0
||
   PX_VAR.TM_END:=0;
   PX_VAR.TM_GRN:=0;
   PX_VAR.GRN_DATA:=date();
   PX_VAR.GRN_TIME:=time(0,0,0);
   PX_VAR.AGR:='N';
   PX_VAR.PL_FORCE:='N';
   ~~
?};
_ok:=1;

PX_OBJ.cntx_psh(); PX_OBJ.clear();
PX_GRP.cntx_psh(); PX_GRP.clear();
PX_CONN.cntx_psh(); PX_CONN.clear();
PX_TEX.cntx_psh(); PX_TEX.clear();
PX_SET.cntx_psh();
GROPS.cntx_psh();

_one_ver:=exec('is_one_version','px_param');

_drop_grp:=null;

{? _drop_dest<>null()
|| {? ref_tab(_drop_dest)=PX_GRP
   || _drop_grp:=_drop_dest
   ||
      PxSelect.Pxgrp.TAB.cntx_psh();
      PxSelect.Pxgrp.TAB.clear();
      {? PxSelect.Pxgrp.TAB.seek(_drop_dest)
      ||
         {? _one_ver
         || _drop_grp:=PX_GRPS.PX_GRP
         || {? PX_GRP.seek(PxSelect.Pxgrp.TAB.PX_GRPI,8+PxSelect.Pxgrp.TAB.PX_GRPI)
            || _drop_grp:=PX_GRP.ref()
            ?}
         ?}
      || FUN.emsg('Nie znaleziono gałęzi, przenoszenie zostaje przerwane.'@);
         _can_continue:=0
      ?}
   ?}
?};
:: Kontrola czy wybrany zestaw, jesli zestawy dostepne
{? _edit>0 & _autoset=0 & exec('is_px_set','px_param')>0 & PX_VAR.PX_SET=null()
|| FUN.emsg('Aby umieścić coś w kolejce należy pracować w kontekście zestawu planistycznego.'@);
   _can_continue:=0
?};

VAR_DEL.delete('__dropped');

:: Po dodaniu rekordow ustawie sie na rekordzie o takim zrodlowym refie
_viewport:=null();

{? _edit>0
|| KOMM.init(250,,'Dodawanie pozycji do kolejki planu.'@,'')
?};

_ok:=0;

_agr:='N';
{? PX_VAR.AGR<>''
|| _agr:=PX_VAR.AGR
?};
_group:=0;
{? VAR.GRUPA='T'
|| _group:=1
?};
_locked:=null();

{? _px_tag<>null()
|| _drop_grp:=exec('find_match','px_tag',_px_ver,_px_tag)
?};

_dropped.cntx_psh();
{? _dropped.first() & _can_continue>0
||
   {? _drop_grp<>null()
   ||
::    DROP NA ISTNIEJACA GRUPE
      __blokada:=1;
      {? exec('lock','px_grp',_drop_grp)
      || _locked:=_drop_grp;
         _can_continue:=1
      || _can_continue:=0
      ?};
      ~~
   ?}
?};
_dropped.cntx_pop();

:: KONTROLA POPRAWNOŚCI
{? _can_continue>0 & _ctrl>0
|| _can_continue:=exec('to_queue_ctrl','px_grp',_dropped
                                                ,_px_ver
                                                ,_drop_grp
                                                ,0
                                                ,_grupa
                                                ,_dialog)
?};


:: EDYCJA
{? _can_continue>0
|| _can_continue:=exec('to_queue_edit','px_grp',_dropped
                                               ,_px_ver
                                               ,_drop_grp
                                               ,0
                                               ,_grupa
                                               ,_edit
                                               ,_px_tag)
?};

_env_grp:=exec('to_group_env','px_grp',_px_ver,_dialog);


{? _grop<>null() & _can_continue>0
||
:: BRAK GRUPOWANIA DLA GRUP OPERACJI
   {? _dropped.first()
   || {!
      |? {? PX_OBJ.seek(_dropped.REF,)
         || _mode:='GROUP_GROPS';
            _ilosc:=_dropped.ILOSC;
            _px_tex:=null();
            _dir:=PX_OBJ.DIR;
            {? PX_VAR.ADD_DIR<>0
            || _dir:=PX_VAR.ADD_DIR;
               ~~
            ?};

            _grops:=null();
            {? var_pres('GROPS',_dropped)>0
            || _grops:=exec('FindAndGet','#table',GROPS,_dropped.GROPS,,,null())
            ?};
            exec('to_group','px_grp',_env_grp,,_mode,_ilosc,_px_tex,_grops,_dir)
         ?};
         _dropped.next()
      !}
   ?}
|? _px_tag<>null() & _can_continue>0
|| _agr:='T';
:: GRUPOWANIE ZA POMOCĄ PX_TAG
   PX_OBJ.cntx_psh();
   PX_TAG.cntx_psh(); PX_TAG.prefix();
   {? PX_TAG.seek(_px_tag)
   || PX_VAR.ADD_TX:=exec('get_default_tex','px_tag',PX_TAG.ref(),1);

      {? PX_VAR.ADD_TX<>null()
      ||
::       Weryfikacja czy przepis ma poprawnie utworzone powiazania
         _can_continue:=exec('conns_ok','px_tex',PX_VAR.ADD_TX);
         {? _can_continue=0
         || _msg:='Dla: %1 domyślny przepis planistyczny posiada nieprawidłowe powiązania między etapami.'@[PX_OBJ.SYMBOL];
            {? _dialog=2
            || KOMM.add(_msg,2,,1)
            |? _dialog=3
            || _komm_args:=exec('add_komm_a','px_komm');
               _komm_args.PX_VER:=_px_ver;
               _komm_args.PX_OBJ:=PX_OBJ.ref();
               _komm_args.TYP:=exec('type_error','px_komm');
               _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args);
               ~~
            ?};
            ~~
         ?}
      || _msg:='Dla grupy obiektów: %1 nie znaleziono przepisu planistycznego.'@[exec('PX_TAG','#to_string')];
         {? _dialog=2
         || KOMM.add(_msg,2,,1)
         |? _dialog=3
         || _komm_args:=exec('add_komm_a','px_komm');
            _komm_args.PX_VER:=_px_ver;
            _komm_args.PX_OBJ:=PX_OBJ.ref();
            _komm_args.TYP:=exec('type_error','px_komm');
            _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
            _komm_args.MESSAGE:=_msg;
            exec('add_komm','px_komm',_komm_args);
            ~~
         ?};
         ~~
      ?};

      {? _can_continue>0
      ||
         PX_OBJ.index('PX_TAG');
         PX_OBJ.prefix(PX_TAG.ref());
         {? PX_OBJ.first()
         || {!
            |?
               _mode:='GROUP_TAG';
               _ilosc:=-1;
               _px_tex:=null();
               _dir:=0;
               {? PX_VAR.ADD_DIR<>0
               || _dir:=PX_VAR.ADD_DIR;
                  ~~
               ?};
               exec('to_group','px_grp',_env_grp,,_mode,_ilosc,_px_tex,,_dir);
               PX_OBJ.next()
            !}
         ?}
      ?}
   ?};
   PX_TAG.cntx_pop();
   PX_OBJ.cntx_pop();
   ~~
||
:: STARE GRUPOWANIE PO TECHNOLOGII
   {? _can_continue>0
   ||
::    ROZPOCZECIE GRUPOWANIA DO TABEL RANKINGOWYCH
      _dropped.first();
      {!
      |? {? PX_OBJ.seek(_dropped.REF,)
         ||
::          Uwaga: tymczasowe zalozenie, ze dla operacji grupowej musza byc technologie jedynie sluszne, nawet jak agregacja
            {? _grupa>0 | _edit=0
            || PX_VAR.ADD_TX:=exec('get_default_tex','px_tex',PX_OBJ.ref(),1)
            ?};
            {? PX_VAR.ADD_TX<>null()
            ||
::             Weryfikacja czy przepis ma poprawnie utworzone powiazania
               _can_continue:=exec('conns_ok','px_tex',PX_VAR.ADD_TX);
               {? _can_continue=0
               || _msg:='Dla: %1 domyślny przepis planistyczny posiada nieprawidłowe powiązania między etapami.'@[PX_OBJ.SYMBOL];
                  {? _dialog=2
                  || KOMM.add(_msg,2,,1)
                  |? _dialog=3
                  || _komm_args:=exec('add_komm_a','px_komm');
                     _komm_args.PX_VER:=_px_ver;
                     _komm_args.PX_OBJ:=PX_OBJ.ref();
                     _komm_args.TYP:=exec('type_error','px_komm');
                     _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
                     _komm_args.MESSAGE:=_msg;
                     exec('add_komm','px_komm',_komm_args);
                     ~~
                  ?};
                  ~~
               ||
                  _mode:='GROUP_NONE';
                  {? _agr='T'
                  || _mode:='GROUP_TEX'
                  ?};
                  _ilosc:=-1;
                  _px_tex:=null();
                  _dir:=0;

                  {? _edit>0 | _group>0
                  || _dir:=PX_VAR.ADD_DIR
                  ?};
                  {? _edit>0 & _group=0
                  || _ilosc:=PX_VAR.ADD_IL
                  ?};
                  {? _group=0
                  || _px_tex:=PX_VAR.ADD_TX
                  ?};
                  exec('to_group','px_grp',_env_grp,,_mode,_ilosc,_px_tex,,_dir)
               ?}
            ||
               _mode:='GROUP_NONE';
               {? _agr='T'
               || _mode:='GROUP_TEX'
               ?};
               _ilosc:=-1;
               _px_tex:=null();
               _dir:=0;

               {? _edit>0 | _group>0
               || _dir:=PX_VAR.ADD_DIR
               ?};
               {? _edit>0 & _group=0
               || _ilosc:=PX_VAR.ADD_IL
               ?};
               {? _group=0
               || _px_tex:=PX_VAR.ADD_TX
               ?};
               exec('to_group','px_grp',_env_grp,,_mode,_ilosc,_px_tex,,_dir)
            ?}
         ?};
         _dropped.next()
      !}
   ?}
?};

{? _can_continue>0
||
   _tab:=_env_grp.TAB;
   exec('to_group_update','px_grp',_env_grp);

:: Informacje diagnostyczne
::   _tab.index(_env_grp.NDX_TREE);
::   exec('select','#table',_tab,1);

:: PRZEKSZTALCENIE TABEL RANKINGOWYCH W PRAWDZIWE REKORDY

:: Zmieniamy kolejnosc w tabeli rankingowej - sa posortowane wg kolejnosci dodawania czyli tak
:: jak byly posortowane rekordy w tabeli _dropped

   _tab.index(_env_grp.NDX_ADD);
   _tab.prefix('G');
   {? _tab.first()
   || {!
      |?
         _reft:=null();
         {? _tab.PX_TEX<>'' & PX_TEX.seek(_tab.PX_TEX)
         || _reft:=PX_TEX.ref()
         ?};
         {? _drop_grp=null() & PX_VAR.AGR_UID<>'' & _px_tag=null()
         ||
::          Jeżeli włączone agregowanie to szukam grupy wśród utworzonych w tej akcji
::          grupowej do której mogę dokleić ten obiekt
            PX_GRP.cntx_psh();
            PX_GRP.index('AGR_UID');
            PX_GRP.prefix(_px_ver,_tab.GRP_STR,PX_VAR.AGR_UID,);
            {? PX_GRP.first()
            || _drop_grp:=PX_GRP.ref()
            ?};
            PX_GRP.cntx_pop()
         ?};

         {? _drop_grp=null()
         ||
::          Tworzenie PX_GRP
            PX_GRP.clear();
            PX_GRP.blank();
            PX_GRP.PX_VER:=_px_ver;
            PX_TEX.cntx_psh();
            PX_TEX.clear();

            _symbol:='<BRAK - technologii>'@;
            _nazwa:='<BRAK - technologii>'@;
            {? _px_tag<>null()
            || PX_TAG.cntx_psh(); PX_TAG.prefix();
               {? PX_TAG.seek(_px_tag)
               || _symbol:=PX_TAG.ID;
                  _nazwa:=PX_TAG.ID
               ?};
               PX_TAG.cntx_pop()
            |? PX_TEX.seek(_reft)
            || _symbol:=exec('get_symbol','px_grp',PX_TEX.ref());
               _nazwa:=exec('get_nazwa','px_grp',PX_TEX.ref())
            ?};
            PX_TEX.cntx_pop();
            PX_GRP.PX_TEX:=_reft;
            PX_GRP.SYMBOL:=_symbol;
            PX_GRP.NAZWA:=_nazwa;
            PX_GRP.DIR:=_tab.DIR;
            {? PX_GRP.DIR>0
            || PX_GRP.PL_FORCE:=PX_VAR.PL_FORCE
            || PX_GRP.PL_FORCE:='N'
            ?};
            PX_GRP.AGR_UID:=PX_VAR.AGR_UID;
            PX_GRP.AGR_SRC:=_tab.GRP_STR;
            {? _tab.GROPS<>''
            || PX_VAR.GROPS:=exec('FindAndGet','#table',GROPS,_tab.GROPS,,,null())
            ?};

            {? PX_VAR.GROPS<>null()
            || PX_VAR.GROP:=PX_VAR.GROPS().GROP;
               PX_GRP.KIND:='G';
               PX_GRP.SYMBOL:=PX_VAR.GROPS().GROP().KOD+' ('+PX_VAR.GROPS().PL_RES().SYM+')';
               PX_GRP.NAZWA:=PX_VAR.GROPS().GROP().OPIS;
               PX_GRP.GROPS:=PX_VAR.GROPS
            || PX_GRP.KIND:='Z'
            ?};
            PX_GRP.ILOSC:=_tab.IL;
            PX_GRP.cntx_psh();
            PX_GRP.index('LP');
            PX_GRP.prefix(_px_ver,PX_GRP.KIND,);
            _nr:={? PX_GRP.last()
                 || PX_GRP.LP_Q+1
                 || 1
                 ?};
            PX_GRP.cntx_pop();
            PX_GRP.LP_Q:=_nr;

            JM.cntx_psh();
            JM.index('KOD');
            JM.prefix(_tab.JM,_tab.JM);
            {? JM.first()
            || PX_GRP.JM:=JM.ref()
            ?};
            JM.cntx_pop();

            {? exec('is_whatif','px_ver',_px_ver)>0
            || PX_GRP.SIM_MOD:='T'
            ?};
            PX_GRP.PX_TAG:=_px_tag;
            _can_continue:=PX_GRP.add();

            {? _can_continue>0
            ||
::             Ustalanie granic czasowych dla grupy
               {? exec('is_px_set','px_param')>0
               ||
::                Praca na zestawie
                  {? _autoset>0
                  || PX_GRP.SET_SRC:=exec('FindAndGet','#table',PX_SET,_tab.PX_SET,,,null())
                  || PX_GRP.SET_SRC:=PX_VAR.PX_SET
                  ?};
::                Granicą od jest aktualny czas zaokraglony do pojemnikow na pierwszym zasobie
                  {? var_pres('_pxpack')>100
                  || obj_del(_pxpack)
                  ?};
                  _pxpack:=exec('trzepaczka','px_tex',PX_GRP.PX_TEX,PX_GRP.ILOSC,PX_GRP.ref());
::                Wyznaczam czas startowy jaki powinien byc na PX_GRP
                  _tm_start:=exec('round_start_pck','px_tex',_pxpack.Paczka);
                  PX_GRP.STARTD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',_tm_start));
                  PX_GRP.STARTT:=exec('tm_stamp2time','#tm_stamp',_tm_start);
::                Granicą do jest zawsze najmniejszy termin realizacji skladowych grupy
                  {? _tab.TM_REA>0
                  || PX_GRP.ENDD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',_tab.TM_REA));
                     PX_GRP.ENDT:=exec('tm_stamp2time','#tm_stamp',_tab.TM_REA)
                  ?}
               ||
::                Praca bez zestawów
                  {? PX_GRP.DIR>0
                  ||
::                   Planowanie w przod
                     _startd:=PX_VAR.GRN_DATA;
                     _startt:=PX_VAR.GRN_TIME;
                     {? _startd>date(0,0,0)
                     ||
                        PX_GRP.STARTD:=exec('get','daty',PX_VAR.GRN_DATA);
                        PX_GRP.STARTT:=PX_VAR.GRN_TIME
                     ||
                        PX_GRP.STARTD:=exec('get','daty',date());
                        PX_GRP.STARTT:=time()
                     ?};
                     {? _tab.TM_REA>0
                     || PX_GRP.ENDD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',_tab.TM_REA));
                        PX_GRP.ENDT:=exec('tm_stamp2time','#tm_stamp',_tab.TM_REA)
                     ?}
                  ||
::                   Planowanie w tyl
                     PX_GRP.STARTD:=exec('get','daty',date());
                     PX_GRP.STARTT:=time();

                     _endd:=PX_VAR.GRN_DATA;
                     _endt:=PX_VAR.GRN_TIME;
                     {? _endd>date(0,0,0)
                     ||
::                      Jesli w oknie data wypelniona to ja przypisuje do grupy
                        PX_GRP.ENDD:=exec('get','daty',PX_VAR.GRN_DATA);
                        PX_GRP.ENDT:=PX_VAR.GRN_TIME
                     ||
::                      Jesli w oknie data niewypelniona, to moze w polu _tab.TM_REA znajduje sie minimalny termin
::                      ze wszystkich skladowych grupy
                        {? _tab.TM_REA>0
                        || PX_GRP.ENDD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',_tab.TM_REA));
                           PX_GRP.ENDT:=exec('tm_stamp2time','#tm_stamp',_tab.TM_REA)
                        ?}
                     ?}
                  ?}
               ?};
               _can_continue:=PX_GRP.put()
            ?};

            {? _can_continue>0 & PX_GRP.GROPS<>null()
            || exec('sequence4pxgrp','px_grop');
               exec('grop_plan_px_set','px_grop',PX_GRP.GROPS().GROP,'Q');
::             "Naprawa" GROPS - nie zawsze udana, bo ilość niekoniecznie jest już dobra
               exec('plan_restore_grop','zl_grop',PX_GRP.GROPS().GROP)
            ?};

            {? _can_continue>0
            ||
               {? exec('is_px_set','px_param')>0 & PX_GRP.SET_SRC<>null()
               ||
::                Nanosze na PX_GRPS'a info o zwrocie i granicy czasowej jaka ustalilem
::                podczas wrzucania do swojej kolejki
                  {? var_pres('_args_grps')>100
                  || obj_del(_args_grps)
                  ?};
                  _args_grps:=exec('add_a','px_grps');
                  _args_grps.PX_GRP:=PX_GRP.ref();
                  _args_grps.PX_SET:=PX_GRP.SET_SRC;
                  _args_grps.GRN_DATA:=PX_VAR.GRN_DATA;
                  _args_grps.GRN_TIME:=PX_VAR.GRN_TIME;
                  _args_grps.DIR:=PX_GRP.DIR;
                  exec('update','px_grps',_args_grps.PX_GRP,_args_grps.PX_SET,_args_grps);

::                Tworze automatyczne punkty czasowe dla pracy na zestawie
                  {? PX_VAR.GRN_DATA<>date(0,0,0)
                  ||
                     {? var_pres('_args_poi')>100
                     || obj_del(_args_poi)
                     ?};
                     _tm_grn:=exec('create','#tm_stamp',PX_VAR.GRN_DATA,PX_VAR.GRN_TIME);
                     _args_poi:=exec('auto_args_grp','px_point',,_tm_grn);
                     exec('auto_point','px_point',_args_poi)
                  ?}
               ?};
::             Stempluje modyfikacje kolejki w wersji
               exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER)
            ?};
            _ref:=PX_GRP.ref()
         || _ref:=_drop_grp;
            {? _px_tag<>null()
            ||
::             Jeżeli dogrupowałem do już istniejącego PX_GRP to przepisuję na tego PX_GRP
::             termin realizacji z PX_TAGA bo mógł się zmienić w międzyczasie
               PX_GRP.ENDD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',PX_TAG.TM_REA));
               PX_GRP.ENDT:=exec('tm_stamp2time','#tm_stamp',PX_TAG.TM_REA);
               PX_GRP.put()
            ?}
         ?};
         _tab.cntx_psh();
         _tab.index(_env_grp.NDX_TREE);
         _tab.prefix(#_tab.ref());
         {? _tab.first() & _can_continue>0
         ||
            {!
            |? {? _tab.Z='T'
               ||
::                Tworzenie PX_CONN
                  PX_CONN.blank();
                  PX_CONN.PX_VER:=_px_ver;
                  PX_CONN.ILOSC:=_tab.IL;
                  PX_CONN.PX_GRP:=_ref;
                  PX_CONN.cntx_psh();
                  PX_CONN.index('PX_GRP');
                  PX_CONN.prefix(_ref);
                  _il:={? PX_CONN.first()
                       || PX_CONN.size()+1
                       || 1
                       ?};
                  PX_CONN.cntx_pop();
                  PX_CONN.LP_GRP:=_il;
                  PX_OBJ.cntx_psh();
                  PX_OBJ.clear();
                  _obj:={? PX_OBJ.seek(_tab.PX_OBJ,8+_tab.PX_OBJ)
                        || PX_OBJ.ref()
                        || null()
                        ?};
                  {? PX_CONN.ILOSC<=PX_OBJ.IL - exec('get_ilosc_que','px_obj',_px_ver,PX_OBJ.ref)
                  || _ok:=1
                  || {? _grupa=0
                     || PX_CONN.cntx_psh();
                        PX_CONN.index('PX_GRP');
                        PX_CONN.prefix(_ref);
                        {? ~PX_CONN.first()
                        || exec('delete','px_grp',_ref)
                        ?};
                        PX_CONN.cntx_pop()
                     ?};
                     _can_continue:=0
                  ?};
                  PX_OBJ.cntx_pop();
                  {? _can_continue>0
                  || {? _obj<>null()
                     || PX_CONN.PX_OBJ:=_obj;
                        PX_CONN.M:=exec('FindAndGet','#table',PX_OBJ,_obj,,"PX_OBJ.M",null);
                        {? PX_CONN.add()
                        ||
::                         aktualizuje pole materiału
                           exec('update_m','px_grp',PX_CONN.PX_GRP);

::                         Stempluje modyfikacje kolejki w wersji
                           exec('mod_stamp_queue','px_ver',PX_CONN.PX_VER);

::                         Ustawiam rekord na ktorym ustawie sie po zregenerowaniu widoku - pierwszy dodany PX_CONN
                           {? _viewport=null()
                           || _viewport:=PX_CONN.ref()
                           ?};

::                         Dla pozostalych technologii danego obiektu wylaczamy Z=N
                           {? _grupa>1
                           || KOMM.add('Dodanie pozycji: %1 do kolejki'@[PX_CONN.PX_OBJ().SYMBOL],13)
                           ?};
                           {? _agr='N'
                           || PX_GRP.NAZWA:=PX_CONN.PX_OBJ().SYMBOL;
                              PX_GRP.put()
                           ?};
::                           {? PX_CONN.PX_GRP().GROPS<>null()
::                           || exec('ran_off_grops','px_grp',_tab.PX_OBJ,$PX_GRP.GROPS)
::                           || exec('ran_off','px_grp',_tab.PX_OBJ,{? _agr='T'
::                                                                   || __ran_conn.PX_TEX
::                                                                   || PX_CONN.PX_OBJ().SYMBOL
::                                                                   ?})
::                           ?};
                           ~~
                        ?}
                     ?}
                  || PX_CONN.PX_OBJ:=_obj;
                     KOMM.add('Dla: %1 próba dodania ilości większej niż w obiekcie.'@[PX_CONN.PX_OBJ().SYMBOL],14);
                     {? _agr='N'
                     || {? PX_GRP.seek(#_ref,8+$_ref)
                        || PX_CONN.cntx_psh();
                           PX_CONN.index('PX_GRP');
                           PX_CONN.prefix(PX_GRP.ref());
                           {? ~PX_CONN.first()
                           || exec('delete','px_grp',PX_GRP.ref())
                           ?};
                           PX_CONN.cntx_pop()
                        ?}
                     ?}
                  ?}
               ?};
               _tab.next()
            !}
         ?};
         _tab.cntx_pop();
         _tab.next()
      !}
   ||
::    W tabelach rankingowych pusto wiec nie wykonuje dalej niepotrzebnych krokow
      _can_continue:=0
   ?};
:: Uzupelnia powiazania miedzy grupami obiektow
::   exec('UpdatePX_VER','px_con_g',PX_VAR.VER_QUE)
   ~~
?};

{? _grupa=0 & _can_continue>0
||
:: Odtwarzanie kolejności w kolejce
   exec('prenumber','px_grp',_px_ver)
?};

:: Ponowne załadowanie widoku kolejki
{? _grupa=0 & var_pres('PxSelect')>100
|| {? ~_one_ver || exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp) ?}
?};

:: Aktualizuje przyciski dot przeliczania jednej wersji planu
{? _grupa=0 & _one_ver>0 & var_pres('PxSelect')>100
|| exec('przelicz_btn','px_plan')
?};

:: Odblokowuje zablokowana wczesniej grupe
{? _locked<>null()
|| exec('unlock','px_grp',_locked)
?};

:: Ustawienie sie na pierwszym dodanym węźle w kolejce (PX_CONN)
{? _grupa=0 & var_pres('PxSelect')>100
|| {? ~_one_ver || exec('viewport_set','px_grp',PxSelect.Pxgrp,_viewport) ?}
?};

{? _win_disp
|| win_disp()
?};

{? _drop_dest<>null() & var_pres('PxSelect')>100
||
   {? ref_tab(_drop_dest)=PX_GRP
   || ~~
   || PxSelect.Pxgrp.TAB.cntx_pop();
      PxSelect.Pxgrp.TAB.seek(_drop_dest)
   ?}
?};

&__blokada;
VAR_DEL.delete('__dropped');
{? _edit>0
|| KOMM.select()
?};
PX_VAR.ADD_SYM:=''; PX_VAR.ADD_OPIS:='';

::zdejmuje filtr z tabeli PX_TEX
exec('tex_f_clear','px_tex');

GROPS.cntx_pop();
PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
PX_CONN.cntx_pop();
PX_TEX.cntx_pop();
PX_SET.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result


\to_queue_ctrl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Kontrola poprawności przed dodaniem do kolejki
::   WE: _a - tab_tmp - tabela zawierająca upuszczane rekordy
::       _b - PX_VER.ref() - wersja planu która jest planowana
::       [_c] - PX_GRP.ref() - grupa do której dodać upuszczane rekordu
::       [_d] - INTEGER - 0/[1] - czy blokować i odblokowywać grupę do której grupuję
::       [_e] - INTEGER - [0]/1 - czy akcja grupowa, jeśli nie podane to określane na podstawie
::                                rozmiaru tabeli _a
::       [_f]   - INTEGER - tryb dialogów:   0 - brak,
::                                           1 - komunikaty na ekran
::                                           2 - komunikaty do KOMMa,
::                                           3 - komunikaty do PX_KOMM i do _mp.error
::   WY: 0 - kontrola się nie powiodła, coś jest nie tak
::       1 - wszystko ok
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_dropped:=_a;
_px_ver:=_b;

_drop_grp:=null();
{? var_pres('_c')=type_of(PX_GRP.ref())
|| _drop_grp:=_c
?};
_can_lock:=1;
{? var_pres('_d')=type_of(0)
|| _can_lock:=_d
?};

{? var_pres('_e')=type_of(0)
|| _grupa:=_e
|| _grupa:={? _dropped.size()>1 || 1 || 0 ?}
?};

_dialog:=1;
{? var_pres('_f')=type_of(0)
|| _dialog:=_f
?};

_result:=1;
_can_continue:=1;

_locked:=null();

_dropped.cntx_psh();
_dropped.clear();

{? _can_continue>0 & _dropped.first()
||
   {? _drop_grp<>null()
   ||
::    DROP NA ISTNIEJACA GRUPE
      {? PX_GRP.seek(_drop_grp)
      ||
         _what:=exec('record','#to_string',PX_GRP.ref());

         {? _can_lock>0
         || _can_continue:=exec('lock','px_grp');
            {? _can_continue>0
            || _locked:=PX_GRP.ref()
            || _result:=0
            ?}
         ?};

         {? _can_continue>0
         || {? exec('is_blocked','px_grp')>0
            || _msg:='Element kolejki: %1 jest zablokowany.\n'
                     'Nie można dodawać nowych elementów.'@[_what];
               {? _dialog=1
               || FUN.emsg(_msg)
               |? _dialog=2
               || KOMM.add(_msg,2,,1)
               |? _dialog=3
               || _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=_px_ver;
                  _komm_args.PX_GRP:=PX_GRP.ref();
                  _komm_args.TYP:=exec('type_error','px_komm');
                  _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args);
                  ~~
               ?};
               _can_continue:=0;
               _result:=0
            |? PX_GRP.STATUS=exec('status_wyk1','px_grp')
            || _msg:='Element kolejki: %1 jest wykonywany.\n'
                     'Nie można dodawać nowych elementów.'@[_what];
               {? _dialog=1
               || FUN.emsg(_msg)
               |? _dialog=2
               || KOMM.add(_msg,2,,1)
               |? _dialog=3
               || _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=_px_ver;
                  _komm_args.PX_GRP:=PX_GRP.ref();
                  _komm_args.TYP:=exec('type_error','px_komm');
                  _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args);
                  ~~
               ?};
               _can_continue:=0;
               _result:=0
            |? PX_GRP.STATUS=exec('status_wyk2','px_grp')
            || _msg:='Element kolejki: %1 jest całkowicie wykonany.\n'
                     'Nie można dodawać nowych elementów.'@[_what];
               {? _dialog=1
               || FUN.emsg(_msg)
               |? _dialog=2
               || KOMM.add(_msg,2,,1)
               |? _dialog=3
               || _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=_px_ver;
                  _komm_args.PX_GRP:=PX_GRP.ref();
                  _komm_args.TYP:=exec('type_error','px_komm');
                  _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args);
                  ~~
               ?};
               _can_continue:=0;
               _result:=0
            ||
::             KONTROLA POPRAWNOSCI
::             Sprawdzenie czy zgadza sie przepis, jednostka miary i termin realizacji
               _can_continue:=1;
               {? _dropped.first()
               ||
                  {!
                  |? {? PX_OBJ.seek(_dropped.REF,)
                     ||
                        _msg_std:='\nNie można przenieść do grupy: %1, redagowanie zostaje przerwane.'@[_what];
::                      Sprawdzanie terminu
                        {? _can_continue>0
                        ||
                           {? PX_GRP.TM_END>PX_OBJ.TM_REA
                           || _msg:='Termin realizacji obiektu: %1\n'
                                    'jest wcześniejszy niż czas zakończenia grupy na którą upuszczono. %2'@[PX_OBJ.SYMBOL,_msg_std];
                              {? _dialog=1
                              || FUN.emsg(_msg)
                              |? _dialog=2
                              || KOMM.add(_msg,2,,1)
                              |? _dialog=3
                              || _komm_args:=exec('add_komm_a','px_komm');
                                 _komm_args.PX_VER:=_px_ver;
                                 _komm_args.PX_OBJ:=PX_OBJ.ref();
                                 _komm_args.TYP:=exec('type_error','px_komm');
                                 _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
                                 _komm_args.MESSAGE:=_msg;
                                 exec('add_komm','px_komm',_komm_args);
                                 ~~
                              ?};
                              _can_continue:=0;
                              _result:=0
                           ?}
                        ?};

::                      Sprawdzanie przepisu
                        {? _can_continue>0
                        ||
                           {? PX_GRP.PX_TAG=null()
                           ||
                              PX_TEX.cntx_psh();
                              {? PX_OBJ.ZL<>null()
                              ||
::                               Dla zlecenia przepisy powinny byc takie same
                                 PX_TEX.index('ZLASYM');
                                 PX_TEX.prefix(PX_OBJ.ZL,'T');
                                 {? PX_TEX.first()
                                 ||
                                    {? PX_GRP.PX_TEX<>PX_TEX.ref()
                                    || _msg:='Obiekt: %1 musi posiadać przepis: %2. %3'@[PX_OBJ.SYMBOL,PX_GRP.PX_TEX().SYMBOL,_msg_std];
                                       {? _dialog=1
                                       || FUN.emsg(_msg)
                                       |? _dialog=2
                                       || KOMM.add(_msg,2,,1)
                                       |? _dialog=3
                                       || _komm_args:=exec('add_komm_a','px_komm');
                                          _komm_args.PX_VER:=_px_ver;
                                          _komm_args.PX_OBJ:=PX_OBJ.ref();
                                          _komm_args.TYP:=exec('type_error','px_komm');
                                          _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
                                          _komm_args.MESSAGE:=_msg;
                                          exec('add_komm','px_komm',_komm_args);
                                          ~~
                                       ?};
                                       _can_continue:=0;
                                       _result:=0
                                    ?}
                                 ?}
                              ||
                                 PX_TEX.index('MASYM');
                                 PX_TEX.prefix(PX_OBJ.M,'T',PX_GRP.PX_TEX().SYMBOL);
                                 {? PX_TEX.size()=0
                                 || _msg:='Dla obiektu: %1 nie istnieje przepis: %2. %3'@[PX_OBJ.SYMBOL,PX_GRP.PX_TEX().SYMBOL,_msg_std];
                                    {? _dialog=1
                                    || FUN.emsg(_msg)
                                    |? _dialog=2
                                    || KOMM.add(_msg,2,,1)
                                    |? _dialog=3
                                    || _komm_args:=exec('add_komm_a','px_komm');
                                       _komm_args.PX_VER:=_px_ver;
                                       _komm_args.PX_OBJ:=PX_OBJ.ref();
                                       _komm_args.TYP:=exec('type_error','px_komm');
                                       _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
                                       _komm_args.MESSAGE:=_msg;
                                       exec('add_komm','px_komm',_komm_args);
                                       ~~
                                    ?};
                                    _can_continue:=0;
                                    _result:=0
                                 ?}
                              ?};
                              PX_TEX.cntx_pop()
                           ?}
                        ?};

::                      Sprawdzanie jednostki miary
                        {? _can_continue>0
                        ||
                           {? PX_OBJ.JM<>PX_GRP.JM
                           || _msg:='Różna jednostka miary dla obiektu: %1 i grupy na którą upuszczono. %2'@[PX_OBJ.SYMBOL,_msg_std];
                              {? _dialog=1
                              || FUN.emsg(_msg)
                              |? _dialog=2
                              || KOMM.add(_msg,2,,1)
                              |? _dialog=3
                              || _komm_args:=exec('add_komm_a','px_komm');
                                 _komm_args.PX_VER:=_px_ver;
                                 _komm_args.PX_OBJ:=PX_OBJ.ref();
                                 _komm_args.TYP:=exec('type_error','px_komm');
                                 _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
                                 _komm_args.MESSAGE:=_msg;
                                 exec('add_komm','px_komm',_komm_args);
                                 ~~
                              ?};
                              _can_continue:=0;
                              _result:=0
                           ?}
                        ?};

::                      Obsługa grup operacji - grupy operacji nie można przenieść na istniejącą grupę
                        {? _can_continue>0
                        || {? PX_OBJ.GROP<>null()
                           || _msg:='Grupy operacji: %1 nie można grupować z grupą w kolejce. %2'@[PX_OBJ.SYMBOL,_msg_std];
                              {? _dialog=1
                              || FUN.emsg(_msg)
                              |? _dialog=2
                              || KOMM.add(_msg,2,,1)
                              |? _dialog=3
                              || _komm_args:=exec('add_komm_a','px_komm');
                                 _komm_args.PX_VER:=_px_ver;
                                 _komm_args.PX_OBJ:=PX_OBJ.ref();
                                 _komm_args.TYP:=exec('type_error','px_komm');
                                 _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
                                 _komm_args.MESSAGE:=_msg;
                                 exec('add_komm','px_komm',_komm_args);
                                 ~~
                              ?};
                              _can_continue:=0;
                              _result:=0
                           ?}
                        ?}
                     ?};
                     _dropped.next() & _can_continue>0
                  !}
               ?}
            ?}
         ?}
      ?}
   ||
::    DROP NA PUSTY OBSZAR
      {? _grupa=0
      ||
::       PRZENOSZENIE JEDNEGO PX_OBJ
         {? PX_OBJ.seek(_dropped.REF,)
         ||
            {? exec('can_plan','px_obj',PX_OBJ.ref(),_dialog,,,0)=0
            || _can_continue:=0;
               _result:=0
            ?}
         || _can_continue:=0;
            _result:=0
         ?}
      ||
::       PRZENOSZENIE WIELU PX_OBJ

::       KONTROLA POPRAWNOSCI
         {? _dropped.first()
         || {!
            |? {? PX_OBJ.seek(_dropped.REF,)
               ||
                  _can_continue:=1;
::                Sprawdzenie powiazan
                  {? _can_continue>0
                  ||
                     {? exec('can_plan','px_obj',PX_OBJ.ref(),_dialog,,,0)=0
                     || _can_continue:=0;
                        _result:=0
                     ?}
                  ?};
                  {? _can_continue>0 & exec('is_px_set','px_param')>0 & PX_VAR.PX_SET<>null()
                  ||
::                   Sprawdzenie czy domylsna technologia zawiera wybrany w oknie zestaw
                     _tex:=exec('get_default_tex','px_tex',PX_OBJ.ref(),1);
                     {? _tex<>null()
                     ||
                        {? exec('has_set','px_tex',_tex,PX_VAR.PX_SET)=0
                        || _can_continue:=0;
                           _result:=0;
                           _msg:='Domyślny przepis obiektu: %1 nie zawiera etapów zestawu: %2'@[PX_OBJ.SYMBOL,PX_VAR.PX_SET().SYMBOL];
                           {? _dialog=1
                           || FUN.emsg(_msg)
                           |? _dialog=2
                           || KOMM.add(_msg,2,,1)
                           |? _dialog=3
                           || _komm_args:=exec('add_komm_a','px_komm');
                              _komm_args.PX_VER:=_px_ver;
                              _komm_args.PX_OBJ:=PX_OBJ.ref();
                              _komm_args.TYP:=exec('type_error','px_komm');
                              _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
                              _komm_args.MESSAGE:=_msg;
                              exec('add_komm','px_komm',_komm_args);
                              ~~
                           ?}
                        ?}
                     ?}
                  ?};
                  _grop:=PX_OBJ.GROP;
                  _grops:=null();
                  {? _can_continue>0
                  || {? _grop<>null
                     || PX_VAR.AGR:='N';
                        {? var_pres('GROPS',_dropped)>0 & _dropped.GROPS<>''
                        || _grops:=exec('FindAndGet','#table',GROPS,_dropped.GROPS,,,null())
                        ||
                           GROPS.cntx_psh();
                           GROPS.index('DEFAULT');
                           GROPS.prefix(_grop,'T');
                           {? GROPS.first()
                           || _grops:=GROPS.ref();
                              GROPS.PL_RES();
                              ~~
                           ?};
                           GROPS.cntx_pop()
                        ?}
                     ?}
                  ?};
                  {? _can_continue>0 & _grops<>null() & _grupa>0
                  || PL_RES.cntx_psh();
                     GROPS.cntx_psh();
                     GROPS.prefix();
                     {? GROPS.seek(_grops)
                     ||
                        {? var_pres('_konty')>100
                        || obj_del(_konty)
                        ?};
                        _konty:=exec('plres2pxkont','px_tie',GROPS.PL_RES,PX_VAR.VER_QUE);
                        {? type_of(_konty)>0 & _konty.first()
                        || ~~
                        || _can_continue:=0;
                           _result:=0;
                           _msg:='Domyślny zasób grupy operacji: %1 nie występuje jako zasób w planie (%2).'@[PX_OBJ.SYMBOL,GROPS.PL_RES().SYM];
                           {? _dialog=1
                           || FUN.emsg(_msg)
                           |? _dialog=2
                           || KOMM.add(_msg,2,,1)
                           |? _dialog=3
                           || _komm_args:=exec('add_komm_a','px_komm');
                              _komm_args.PX_VER:=_px_ver;
                              _komm_args.PX_OBJ:=PX_OBJ.ref();
                              _komm_args.TYP:=exec('type_error','px_komm');
                              _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
                              _komm_args.MESSAGE:=_msg;
                              exec('add_komm','px_komm',_komm_args);
                              ~~
                           ?}
                        ?};
                        {? _can_continue>0
                        ||
                           {? var_pres('_pxpack')>100
                           || obj_del(_pxpack)
                           ?};
                           {? var_pres('_paczka')>100
                           || obj_del(_paczka)
                           ?};

                           _pxpack:=exec('trzepaczka_grop','px_tex',GROPS.ref(),GROPS.GROP().IL,,exec('get_grop_object','px_obj',GROPS.GROP));
                           _paczka:=_pxpack.Paczka;
                           _ndx_num:=_pxpack.Ndx_fwd;
                           _paczka.index(_ndx_num);
                           _paczka.prefix('K');
                           {? _paczka.first()
                           || _jm1:=exec('get','#params',500380);
                              _jm2:=exec('get','#params',500381);
                              {? exec('pck_oper_empty','px_tex',_paczka)=0
                              || _msg:='Zasób domyślny grupy: %1 jest nieprawidłowo skonfigurowany, prawdopodobnie nie posiada wymiarów w jm: %2 lub %3'@[GROPS.GROP().KOD,_jm1,_jm2];
                                 {? _dialog=1
                                 || FUN.emsg(_msg)
                                 |? _dialog=2
                                 || KOMM.add(_msg,2,,1)
                                 |? _dialog=3
                                 || _komm_args:=exec('add_komm_a','px_komm');
                                    _komm_args.PX_VER:=_px_ver;
                                    _komm_args.PX_OBJ:=PX_OBJ.ref();
                                    _komm_args.TYP:=exec('type_error','px_komm');
                                    _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
                                    _komm_args.MESSAGE:=_msg;
                                    exec('add_komm','px_komm',_komm_args);
                                    ~~
                                 ?}
                              ?}
                           || _msg:='Nie znaleziono zasobu w planie: %1'@[GROPS.PL_RES().SYM];
                              {? _dialog=1
                              || FUN.emsg(_msg)
                              |? _dialog=2
                              || KOMM.add(_msg,2,,1)
                              |? _dialog=3
                              || _komm_args:=exec('add_komm_a','px_komm');
                                 _komm_args.PX_VER:=_px_ver;
                                 _komm_args.PX_OBJ:=PX_OBJ.ref();
                                 _komm_args.TYP:=exec('type_error','px_komm');
                                 _komm_args.SRC_KIND:=exec('src_act_que','px_komm');
                                 _komm_args.MESSAGE:=_msg;
                                 exec('add_komm','px_komm',_komm_args);
                                 ~~
                              ?}
                           ?}
                        ?}
                     ?};
                     GROPS.cntx_pop();
                     PL_RES.cntx_pop();
                     ~~
                  ?}
               ?};
               _dropped.next()
            !}
         ?}
      ?}
   ?}
?};
_dropped.cntx_pop();

:: Odblokowuje zablokowana wczesniej grupe
{? _locked<>null() & _can_lock>0
|| exec('unlock','px_grp',_locked)
?};
_result


\to_queue_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Edycja podczas wrzucania elementów do kolejki
::   WE: _a - tab_tmp - tabela zawierająca upuszczane rekordy
::       _b - PX_VER.ref() - wersja planu która jest planowana
::       [_c] - PX_GRP.ref() - grupa do której dodać upuszczane rekordu
::       [_d] - INTEGER - 0/[1] - czy blokować i odblokowywać grupę do której grupuję
::       [_e] - INTEGER - [0]/1 - czy akcja grupowa, jeśli nie podane to określane na podstawie
::                                rozmiaru tabeli _a
::       [_f] - INTEGER - 0/[1] - czy wyświetlać okno edycyjne, jeśli nie to zostaną wypełnione
::                                tylko wartości zmiennych na podstawie których się wrzuci do kolejki
::       [_g] - PX_TAG.ref - grupa obiektów
::   WY: 0 - edycja zerwana
::       1 - edycja zatwierdzona
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_dropped:=_a;
_px_ver:=_b;

_drop_grp:=null();
{? var_pres('_c')=type_of(PX_GRP.ref())
|| _drop_grp:=_c
?};
_can_lock:=1;
{? var_pres('_d')=type_of(0)
|| _can_lock:=_d
?};

{? var_pres('_e')=type_of(0)
|| _grupa:=_e
|| _grupa:={? _dropped.size()>1 || 1 || 0 ?}
?};

_edit:=1;
{? var_pres('_f')=type_of(0)
|| _edit:=_f
?};
_px_tag:=null();
{? var_pres('_g')=type_of(PX_TAG.ref())
|| _px_tag:=_g
?};

_result:=0;
_can_continue:=1;

_locked:=null();
_set_vars:=1;

_now:=SYSLOG.tm_stamp();

_dropped.cntx_psh();
_dropped.clear();

PX_OBJ.cntx_psh();
PX_OBJ.prefix();
PX_VAR.CAN_AGR:=1;
:: Jeżeli przeciągamy grupę operacji to wyłączamy agregowanie
{? _dropped.first()
|| {!
   |? {? PX_OBJ.seek(_dropped.REF,)
      || {? PX_OBJ.GROP<>null()
         || PX_VAR.AGR:='N';
            PX_VAR.CAN_AGR:=0
         ?}
      ?};
      _dropped.next()
   !}
?};
{? _dropped.size()=1 & _dropped.first()
||
:: Jeśli przeciągamy tylko jedną grupę operacji, to i tak traktuję to jako okienko grupowe
   {? PX_OBJ.seek(_dropped.REF,)
   || {? PX_OBJ.GROP<>null()
      || _grupa:=1;
         _set_vars:=0;
         PX_VAR.GROP:=PX_OBJ.GROP;
         PX_VAR.ADD_DIR:=PX_OBJ.DIR;
         PX_VAR.PL_FORCE:=PX_OBJ.PL_FORCE;
         PX_VAR.ILOSC:=0;
         {? PX_VAR.ADD_DIR>0
         ||
::             Planowanie w przod
               {? PX_OBJ.TM_START>_now
               ||
::                Jesli na PX_OBJ jest uwzgledniona najwczesniejszy czas od ktorego mozna planowac
                  PX_VAR.GRN_DATA:=PX_OBJ.STARTD().DATA;
                  PX_VAR.GRN_TIME:=PX_OBJ.STARTT;
                  PX_VAR.TM_GRN:=PX_OBJ.TM_START
               ||
::                Jesli najwczesniejsza data na PX_OBJ jest pozniejsza niz teraz to biore teraz
                  PX_VAR.GRN_DATA:=date();
                  {? PX_VAR.NAST_ALG=2
                  || PX_VAR.GRN_TIME:=time(0,0,0)
                  || PX_VAR.GRN_TIME:=time()
                  ?};
                  PX_VAR.TM_GRN:=_now
               ?}
         ||
::          Planowanie w tyl
            PX_VAR.GRN_DATA:=PX_OBJ.ENDD().DATA;
            PX_VAR.GRN_TIME:=PX_OBJ.ENDT;
            PX_VAR.TM_GRN:=PX_OBJ.TM_REA
         ?}
      ?}
   ?}
?};
PX_OBJ.cntx_pop();


{? _grupa>0
|| {? PX_VAR.CAN_AGR>0
   || PX_VAR.AGR:='T';
      exec('px_var_win_edit','px_grp','PX_GRP')
   || PX_VAR.AGR:='N';
      exec('px_var_win_edit','px_grp','ADDNOGRP')
   ?}
||
   {? PX_VAR.GROP<>null()
   || exec('px_var_win_edit','px_grp','ADD_GROP','Dodanie do planu'@)
   |? _drop_grp=null()
   || exec('px_var_win_edit','px_grp','ADD1','Dodanie do planu'@)
   || exec('px_var_win_edit','px_grp','ADD2','Dodanie do planu'@)
   ?}
?};
PX_TAG.cntx_psh();
PX_TAG.prefix();
{? _px_tag<>null()
|| exec('px_var_win_edit','px_grp','ADD_TAG');
   _can_continue:=PX_TAG.seek(_px_tag)
?};

PX_TEX.win_dict('SEL');

{? _can_continue>0 & _dropped.first()
||
   {? _drop_grp<>null()
   ||
::    DROP NA ISTNIEJACA GRUPE
      {? PX_GRP.seek(_drop_grp)
      ||
         _what:=exec('record','#to_string',PX_GRP.ref());

         {? _can_lock>0
         || _can_continue:=exec('lock','px_grp');
            {? _can_continue>0
            || _locked:=PX_GRP.ref()
            ?}
         ?};

         {? _can_continue>0
         ||
::          PODPOWIADANIE WARTOSCI W OKNIE REDAKCYJNYM
            PX_VAR.TM_END:=PX_GRP.TM_END;
            PX_VAR.ADD_TX:=PX_GRP.PX_TEX;
            PX_VAR.PL_FORCE:=PX_GRP.PL_FORCE;
            PX_VAR.ADD_TAG:=PX_GRP.PX_TAG;
            {? PX_GRP.DIR>0
            ||
::             Planowanie w przod
               PX_VAR.GRN_DATA:=PX_GRP.STARTD().DATA;
               PX_VAR.GRN_TIME:=PX_GRP.STARTT;
               PX_VAR.TM_GRN:=PX_GRP.TM_START
            ||
::             Planowanie w tyl
               PX_VAR.GRN_DATA:=PX_GRP.ENDD().DATA;
               PX_VAR.GRN_TIME:=PX_GRP.ENDT;
               PX_VAR.TM_GRN:=PX_GRP.TM_END
            ?};

            {? _grupa=0
            || {? PX_OBJ.seek(_dropped.REF,)
               || PX_VAR.ADD_SYM:=PX_OBJ.SYMBOL;
                  PX_VAR.ADD_OPIS:=PX_OBJ.NAZWA;
                  PX_VAR.ILOSC:=PX_OBJ.IL;
                  PX_VAR.ADD_IL:=PX_OBJ.IL-exec('get_ilosc_que','px_obj',_px_ver,PX_OBJ.ref())
               ?}
            || PX_VAR.ILOSC:=0
            ?}
         ?}
      ?};
      {? _can_continue>0 & _edit>0
      ||
::       Niestandardowa obsluga pola PX_TEX.AKT
         exec('px_tex_akt_bl','px_tex',1);
::       !!! OKNO REDAKCYJNE !!!
         {? PX_VAR.edit("exec('validate_conn','px_grp',0)")>0
         || {? _grupa=0
            || _agr:='N'
            || _agr:=PX_VAR.AGR
            ?}
         || FUN.emsg('Przerwano planowanie.'@);
            _can_continue:=0
         ?};
::       Niestandardowa obsluga pola PX_TEX.AKT
         exec('px_tex_akt_bl','px_tex',0)
      ?}
   ||
::    DROP NA PUSTY OBSZAR
      {? _grupa=0
      ||
::       PRZENOSZENIE JEDNEGO PX_OBJ
         {? PX_OBJ.seek(_dropped.REF,)
         ||
            PX_VAR.ADD_SYM:=PX_OBJ.SYMBOL;
            PX_VAR.ADD_OPIS:=PX_OBJ.NAZWA;
            PX_VAR.TM_END:=PX_OBJ.TM_REA;
            PX_VAR.ILOSC:=PX_OBJ.IL;
            PX_VAR.PL_FORCE:=PX_OBJ.PL_FORCE;
            PX_VAR.ADD_TAG:=PX_OBJ.PX_TAG;
            {? PX_OBJ.DIR<>0
            ||
::             Jesli na PX_OBJ podany jest domyslny zwrot planowania to go wykorzystuje
               PX_VAR.ADD_DIR:=PX_OBJ.DIR
            ||
::             Okreslam domyslny zwrot planowania na podstawie tego czy jest termin czy nie
               {? PX_OBJ.TM_REA>0
               || PX_VAR.ADD_DIR:=-1
               || PX_VAR.ADD_DIR:=1
               ?}
            ?};

::          Okreslam domyslna granice planowania na podstawie terminu obiektu, jesli jeszcze nie zostaly
::          okreslone na podstawie tego na co zrzucilem
            {? PX_VAR.ADD_DIR>0
            ||
::             Planowanie w przod
               {? PX_OBJ.TM_START>_now
               ||
::                Jesli na PX_OBJ jest uwzgledniona najwczesniejszy czas od ktorego mozna planowac
                  PX_VAR.GRN_DATA:=PX_OBJ.STARTD().DATA;
                  PX_VAR.GRN_TIME:=PX_OBJ.STARTT;
                  PX_VAR.TM_GRN:=PX_OBJ.TM_START
               ||
::                Jesli najwczesniejsza data na PX_OBJ jest pozniejsza niz teraz to biore teraz
                  PX_VAR.GRN_DATA:=date();
                  {? PX_VAR.NAST_ALG=2
                  || PX_VAR.GRN_TIME:=time(0,0,0)
                  || PX_VAR.GRN_TIME:=time()
                  ?};
                  PX_VAR.TM_GRN:=_now
               ?}
            ||
::             Planowanie w tyl
               PX_VAR.GRN_DATA:=PX_OBJ.ENDD().DATA;
               PX_VAR.GRN_TIME:=PX_OBJ.ENDT;
               PX_VAR.TM_GRN:=PX_OBJ.TM_REA
            ?};
            {? exec('is_px_set','px_param') & PX_OBJ.PX_SET<>null()
            ||
::             Praca na zestawie - nie podpowiadam granicy czasowej
               PX_VAR.GRN_DATA:=date(0,0,0);
               PX_VAR.GRN_TIME:=time(0,0,0)
            ?};


            {? _can_continue>0
            || PX_VAR.GROP:=PX_OBJ.GROP;
               {? PX_VAR.GROP<>null
               || PX_VAR.AGR:='N';
                  GROPS.cntx_psh();
                  GROPS.index('DEFAULT');
                  GROPS.prefix(PX_VAR.GROP,'T');
                  {? GROPS.first()
                  || PX_VAR.GROPS:=GROPS.ref();
                     GROPS.PL_RES();
                     ~~
                  ?};
                  GROPS.cntx_pop()
               ?}
            ?};

::          zakladam filtr na PX_TEX i podpowiadam pierwsza technologie
            {? exec('tex_f_set1','px_tex',PX_OBJ.ref())=2
            || PX_VAR.ADD_TX:=PX_TEX.ref()
            || PX_VAR.ADD_TX:=null()
            ?};
            PX_VAR.ADD_IL:=PX_OBJ.IL-exec('get_ilosc_que','px_obj',_px_ver,PX_OBJ.ref())
         || _can_continue:=0
         ?}
      ||
::       PRZENOSZENIE WIELU PX_OBJ

::       Ustalenie nieprzekraczalnej granicy czasu
         PX_VAR.TM_END:=exec('min_termin_drop','px_grp',_dropped);
         PX_VAR.ADD_TAG:=_px_tag;

         {? _edit>0 & _set_vars>0
         ||
::          Domysla granica od teraz, zwrot w przod
            PX_VAR.ADD_DIR:=1;

            {? exec('is_px_set','px_param') & PX_OBJ.PX_SET<>null()
            ||
::             Praca na zestawie - nie podpowiadam granicy czasowej
               PX_VAR.GRN_DATA:=date(0,0,0);
               PX_VAR.GRN_TIME:=time(0,0,0)
            ||
               PX_VAR.GRN_DATA:=date();
               {? PX_VAR.NAST_ALG=2
               || PX_VAR.GRN_TIME:=time(0,0,0)
               || PX_VAR.GRN_TIME:=time()
               ?}
            ?};
            PX_VAR.TM_GRN:=_now;
            PX_VAR.ILOSC:=0;
            PX_VAR.PL_FORCE:='N';
            ~~
         ?};

         {? PX_VAR.ADD_TAG<>null()
         || {? PX_VAR.ADD_TAG().DIR<>0
            || PX_VAR.ADD_DIR:=PX_VAR.ADD_TAG().DIR
            || PX_VAR.ADD_DIR:=1
            ?}
         ?}
      ?};
      {? _can_continue>0 & _edit>0
      ||
::       Niestandardowa obsluga pola PX_TEX.AKT
         exec('px_tex_akt_bl','px_tex',1);
::       !!! OKNO REDAKCYJNE !!!
         {? PX_VAR.edit("exec('validate_grp','px_grp',0)")>0
         || {? _grupa=0
            || _agr:='N'
            || _agr:=PX_VAR.AGR
            ?}
         || FUN.emsg('Przerwano planowanie.'@);
            _can_continue:=0
         ?};
::       Niestandardowa obsluga pola PX_TEX.AKT
         exec('px_tex_akt_bl','px_tex',0)
      ?}
   ?}
?};
_dropped.cntx_pop();
PX_TAG.cntx_pop();

:: Jesli w oknie agregowania wybrano opcje zwrotu wg obiektow zrodlowych to
:: usuwam wartosci z pol PX_VAR.GRN_DATA i PX_VAR.GRN_TIME zeby przypadkiem nie przeszly na
:: PX_GRPy
{? PX_VAR.ADD_DIR=0
|| PX_VAR.GRN_DATA:=date(0,0,0);
   PX_VAR.GRN_TIME:=time(0,0,0)
?};

:: Odblokowuje zablokowana wczesniej grupe
{? _locked<>null() & _can_lock>0
|| exec('unlock','px_grp',_locked)
?};
{? _can_continue>0
|| _result:=1
?};
_result


\data
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: ustalenie namiaru na date
::   WE: _a - data
::   WY:    - ref
::----------------------------------------------------------------------------------------------------------------------
_daty:=_a;
DATY.cntx_psh();
DATY.index('DATA');
DATY.prefix(_daty);
{? DATY.first()
|| _daty:=DATY.ref()
|| _daty:=null()
?};
DATY.cntx_pop();
_daty


\ran_off
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: wylaczenie elementow rankinku by nie byl ponownie brany pod uwage
::   WE: _a - wskazanie na obiekt
::       _b - wskazanie na technologie
::----------------------------------------------------------------------------------------------------------------------
__ran_conn.cntx_psh();
_ndx:=__ran_conn.ndx_tmp(,,'PX_OBJ',,,'PX_TEX',,);
__ran_conn.index(_ndx);
__ran_conn.prefix(_a);
{? __ran_conn.first()
|| {!
   |? {? __ran_conn.PX_TEX<>_b
      || __ran_conn.Z:='N';
         __ran_conn.put()
      ?};
      __ran_conn.next()
   !}
?};
__ran_conn.ndx_drop(_ndx);
__ran_conn.cntx_pop();
1


\ran_off_grops
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: wylaczenie elementow rankingu by nie byl ponownie brany pod uwage
::   WE: _a - wskazanie na obiekt
::       _b - wskazanie na GROPS
::----------------------------------------------------------------------------------------------------------------------
__ran_conn.cntx_psh();
_ndx:=__ran_conn.ndx_tmp(,,'PX_OBJ',,,'GROPS',,);
__ran_conn.index(_ndx);
__ran_conn.prefix(_a,_b,);
{? __ran_conn.first()
|| {!
   |? __ran_conn.Z:='N';
      __ran_conn.put();
      __ran_conn.next()
   !}
?};
__ran_conn.ndx_drop(_ndx);
__ran_conn.cntx_pop();
1


\px_que_organize
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: wstepna organizacja planu
::   WE: _a - wskazanie na wersje planu
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_ok:=FUN.choice('Sposób porządkowania planu.'@,,'Według terminu'@,'Według &technologii'@);
{? ~_ok || return() ?};

:: Sprawdzam czy mozna zablokowac cala kolejke
{? exec('lock_queue','px_ver',_px_ver)>0
||
   _organize:=tab_tmp(2,'REF','INTEGER','REF',
                        'PXTEX','STRING[50]','Przepis planistyczny'@,
                        'TM','REAL','TM',
                        'JM','STRING[10]','jm'@,
                        'DIR','INTEGER','Zwrot'@);
   _kind:='Z';
   {? PX_GRP.KIND<>''
   || _kind:=PX_GRP.KIND
   ?};
   PX_GRP.cntx_psh();
   PX_CONN.cntx_psh();
   PX_GRP.index('LP');
   PX_GRP.prefix(_px_ver,_kind);
   {? PX_GRP.first()
   || {!
      |? _organize.REF:=#PX_GRP.ref();
         _organize.PXTEX:=PX_GRP.PX_TEX().SYMBOL;
         _organize.TM:={? PX_CONN.index('PX_GRP');
                          PX_CONN.prefix(PX_GRP.ref());
                          PX_CONN.first()
                       || PX_CONN.PX_OBJ().TM_REA
                       || 0
                       ?};
         _organize.JM:={? PX_CONN.index('PX_GRP');
                          PX_CONN.prefix(PX_GRP.ref());
                          PX_CONN.first()
                       || PX_CONN.PX_OBJ().JM().KOD
                       || '<BRAK>'
                       ?};
         _organize.DIR:=PX_GRP.DIR;
         _organize.add();
         PX_GRP.next()
      !}
   ?};
   PX_CONN.cntx_pop();
   PX_GRP.cntx_pop();

   {? _ok=1
   || _ndx:=_organize.ndx_tmp(,1,'TM',,)
   |? _ok=2
   || _ndx:=_organize.ndx_tmp(,1,'PXTEX',,,
                                 'JM',,,
                                 'TM',,)
   ?};
   PX_GRP.clear();
   _organize.index(_ndx);
   {? _organize.first()
   || _lpq:=0;
      {!
      |? _lpq+=1;
         {? PX_GRP.seek(_organize.REF,)
         || PX_GRP.LP_Q:=_lpq;
            PX_GRP.put()
         ?};
         _organize.next()
      !}
   ?};
   _organize.ndx_drop(_ndx);

:: Stempluje kolejke jako zmodyfikowana
   exec('mod_stamp_queue','px_ver',_px_ver);

   exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp);
   win_disp();

:: Odblokowuje cala kolejke
   exec('unlock_queue','px_ver',_px_ver)
?};
1


\Pxgrp_refresh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: odswiezenie zawartosc okna kolejki
::   WE: _a - obiekt kolejki, np. @.PxSelect.Pxgrp
::----------------------------------------------------------------------------------------------------------------------
_a.load();
_a.TAB.index(_a.NDX_UP);
_a.TAB.prefix();
_a.update();
~~


\viewport_set
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Ustawia widok na podanym zrodlowym refie w oknie kolejki
::   WE: _a - obiekt kolejki, np. @.PxSelect.Pxgrp
::       _b - PX_CONN.ref lub PX_GRP.ref
::   WY: 0 - nie udalo sie ustawic widoku
::       1 - ustawniono widok
::----------------------------------------------------------------------------------------------------------------------
_queue:=_a;
_ref:=_b;

_result:=0;

_queue.TAB.blank(1);
_queue.TAB.REF:=_ref;
_result:=_queue.TAB.find_rec();
_result


\delete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Usuwa obiekt grupujacy
::   WE: _a - PX_GRP.ref() - obiekt grupujacy do usuniecia
::   WY: 0 - porazka
::      >0 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_px_grp:=_a;
_can_continue:=1;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};
_msg:='delete\px_grp.fml - usuwanie obiektu grupującego: '+PX_GRP.SYMBOL;
pxkomm.sect_beg(_msg,,1);

PX_GRP.cntx_psh();
PX_GRP.clear();

{? PX_GRP.seek(_px_grp)
||
:: Zbieram powiazane elementy kolejki
   _refs_next:=exec('ref_table','#table');
   _refs_prev:=exec('ref_table','#table');
   _has_conns:=exec('has_conns','px_con_g');
   _px_tag:=PX_GRP.PX_TAG;
   {? _has_conns>0
   || exec('collect','px_con_g',,_refs_next,_refs_prev)
   ?};

   _can_continue:=exec('clean','px_grp',PX_GRP.ref());
   {? _can_continue>0
   || _px_ver:=PX_GRP.PX_VER;
      _msg:='Rozpoczęcie usuwania obiektu grupującego: '+PX_GRP.SYMBOL;
      pxkomm.sect_beg(_msg,,1);
::    Usuwam obiekt grupujacy
      {? _can_continue>0
      ||
::       Usuwam blokade jesli byla zalozona
         exec('unlock','px_grp');

::       Usuwam rekord
         _result:=PX_GRP.del(,1);
         {? _result=0
         || _msg:='Nie udało się usunięcie obiektu grupującego: '+PX_GRP.SYMBOL;
            pxkomm.error(_msg,0)
         ?}
      ?};

      {? _result>0 & _px_tag<>null() & exec('get','#params',500394,type_of(''))='T'
      || _result:=exec('delete_auto','px_tag',_px_tag)
      ?};

      {? _result>0
      ||
::       Stempluje modyfikacje kolejki w wersji
         exec('mod_stamp_queue','px_ver',_px_ver);

         {? _has_conns>0
         ||
::          Usuwam powiazane elementy z tym ktory usunalem
            _result:=exec('del_connected','px_con_g',_refs_next,_refs_prev)
         ?}
      ?};
      pxkomm.sect_end()
   || _msg:='Usuniecie powiazań obiektu grupującego nieudane: '+PX_GRP.SYMBOL;
      pxkomm.error(_msg,0)
   ?}
|| _msg:='Nie znaleziono obiektu grupującego: '+$_px_grp;
   pxkomm.error(_msg,0)
?};
pxkomm.sect_end();
PX_GRP.cntx_pop();

_result


\clean
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Usuwa powiazania dla PX_GRP
::   WE: _a - PX_GRP.ref()
::       [_b] - INTEGER -  0 - nie usuwac PX_CONN
::                        [1] - usuwac PX_CONN [domyslnie]
::       [_c] - INTEGER -  0 - nie usuwac PX_POINT
::                        [1] - usuwac PX_POINT [domyslnie]
::       [_d] - INTEGER -  0 - nie usuwac PX_KOMM
::                        [1] - usuwac PX_KOMM [domyslnie]
::   WY: 0 - zguba
::       1 - zwyciestwo
::----------------------------------------------------------------------------------------------------------------------

_pxgrp:=_a;
_conn_del:=1;
{? var_pres('_b')=type_of(0)
|| _conn_del:=_b
?};
_point_del:=1;
{? var_pres('_c')=type_of(0)
|| _point_del:=_c
?};
_komm_del:=1;
{? var_pres('_d')=type_of(0)
|| _komm_del:=_d
?};

_result:=0;
_can_continue:=1;
:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};
_msg:='Usuwanie powiazan obiektu grupującego: '+PX_GRP.SYMBOL;
pxkomm.sect_beg(_msg,,1);
PX_GRP.cntx_psh();
PX_CONN.cntx_psh();
PX_POZ.cntx_psh();
PX_GRP.clear();
{? PX_GRP.seek(_pxgrp)
||
:: 1. Usuwam powiazania z pozycjami planu powstalymi na podstawie planu operacyjnego
   {? _can_continue>0 & PX_GRP.PLAN_OPR='T'
   || _can_continue:=exec('px_poz_oper_tie','px_tie',,0)
   ?};

:: 2. Usuwam polaczenia grupujace
   {? _conn_del>0
   ||
      PX_CONN.index('PX_GRP');
      PX_CONN.prefix(PX_GRP.ref());
      {? PX_CONN.first()
      || {!
         |? _can_continue:=exec('delete','px_conn',PX_CONN.ref());
            PX_CONN.first() & _can_continue>0
         !}
      ?}
   ?};
:: 3. Usuwam pozycje planu skojarzone z obiektem grupujacym
   PX_POZ.index('GRPFORW');
   PX_POZ.prefix(PX_GRP.ref());
   {? PX_POZ.first()
   || {!
      |? _can_continue:=exec('delete','px_poz',PX_POZ.ref());
         PX_POZ.first() & _can_continue>0
      !}
   ?};
:: 4. Usuwam komunikaty
   {? _can_continue>0 & _komm_del>0
   || _can_continue:=exec('del_grp','px_komm',PX_GRP.ref())
   ?};

:: 6. Usuwam powiazania pomiedzy grupami
   {? _can_continue>0
   || _can_continue:=exec('delete','px_con_g',PX_GRP.ref())
   ?};

:: 7. Usuwam punkty czasowe
   {? _can_continue>0 & _point_del>0
   || _can_continue:=exec('delete4grp','px_point',PX_GRP.ref())
   ?};

:: 8. Usuwam widoki grupy w zestawach
   {? _can_continue>0
   || _can_continue:=exec('del','px_grps',PX_GRP.ref())
   ?};

:: 9. Usuwam powiązania ze zleceniami
   {? _can_continue>0
   || PX_ZL.cntx_psh();
      PX_ZL.index('PX_GRP');
      PX_ZL.prefix(PX_GRP.ref());
      {? PX_ZL.first()
      || {!
         |? _can_continue:=exec('delete','px_zl',PX_ZL.ref());
            PX_ZL.first() & _can_continue>0
         !}
      ?};
      PX_ZL.cntx_pop();
      ~~
   ?};
   ~~
?};
pxkomm.sect_end();
{? _can_continue>0
|| _result:=1
?};
PX_GRP.cntx_pop();
PX_CONN.cntx_pop();
PX_POZ.cntx_pop();
_result


\delete_ifempty
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Usuwa PX_GRP o ile nie zawiera zadnych elementow (PX_CONN)
::   WE: _a - PX_GRP.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_result:=0;

PX_GRP.cntx_psh();
PX_CONN.cntx_psh();
PX_GRP.clear();
{? PX_GRP.seek(_px_grp)
|| PX_CONN.index('PX_GRP');
   PX_CONN.prefix(PX_GRP.ref());
   {? PX_CONN.first()=0
   || _result:=exec('delete','px_grp',PX_GRP.ref())
   ?}
?};
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
_result


\status_normal
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status normalny
::----------------------------------------------------------------------------------------------------------------------
'NORMALNY'


\status_wyk1
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status w trakcie wykonania
::----------------------------------------------------------------------------------------------------------------------
'WYKONYWANE'


\status_wyk2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status wykonane w calosci
::----------------------------------------------------------------------------------------------------------------------
'WYKONANO'


\status_delay
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status normalny
::----------------------------------------------------------------------------------------------------------------------
'OPÓŹNIONE'


\status_set
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Nadaje obiektowi grupujacemu status
::   WE: _a - PX_GRP.ref()
::       _b - STRING - status
::   WY: 0 - zguba
::       1 - zwyciestwo
::----------------------------------------------------------------------------------------------------------------------
_grp:=_a;
_status:=_b;
_result:=0;

_px_tag:=null();
PX_GRP.cntx_psh();
PX_GRP.clear();
{? PX_GRP.seek(_grp)
|| _px_tag:=PX_GRP.PX_TAG;
   PX_GRP.STATUS:=_status;

:: Nawijam status na pomocnicze pola sluzace do prefiksowania
   PX_GRP.STATWYK1:='N';
   PX_GRP.STATWYK2:='N'; PX_GRP.VISIBLE:='T';
   PX_GRP.STATDLAY:='N';
   {? _status=exec('status_wyk1','px_grp')
   || PX_GRP.STATWYK1:='T'
   |? _status=exec('status_wyk2','px_grp')
   || PX_GRP.STATWYK2:='T'; PX_GRP.VISIBLE:='N'
   |? _status=exec('status_delay','px_grp')
   || PX_GRP.STATDLAY:='T'
   ?};
   _result:=PX_GRP.put()
?};
PX_GRP.cntx_pop();
PX_GRP.get();

{? _result>0 & _px_tag<>null() & exec('get','#params',500394,type_of(''))='T'
|| _result:=exec('delete_auto','px_tag',_px_tag)
?};

_result


\t_real_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed wyswietl pola PxSelect.Pxgrp.TAB.T_REAL
::   WE: [_a] - tab - uchwyt do tabeli, jeżeli nie podane to wymyśla
::----------------------------------------------------------------------------------------------------------------------
_tab:=~~;
{? var_pres('_a')>100
|| _tab:=_a
?};
{? fld()<>''
||
   {? type_of(_tab)=0
   || _tab:={? exec('is_one_version','px_param') || PX_VAR1 || cur_tab(1,1) ?}
   ?};
   _t_real:=exec('string2stamp','#tm_stamp',_tab.T_REAL);
   _t_plan:=exec('string2stamp','#tm_stamp',_tab.T_PLAN);
   {? _t_real<_t_plan
   || exec('flddisp','color','PX_GRP#T_REAL#WIN#01')
   || ''
   ?}
||
   ''
?}


\problem_none
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Brak problemu
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'BRAK'


\problem_termL
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Problem - przekroczony termin z lewej strony - zrobila sie fura
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'PRZEPEŁNIENIE:START'


\problem_termR
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Problem - przekroczony termin z prawej strony - zrobila sie fura
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'PRZEPEŁNIENIE:KONIEC'


\problem_half
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Problem - nie udalo sie zaplanowac wszystkich etapow
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'NIEPEŁNY PLAN'


\problem_coop
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Problem - kooperacja zazebila sie z poprzednim etapem lub granicami calego PX_GRP
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'KONFLIKT KOOPERACJI'


\px_grp_ver
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: wyswietlenie kolejki dla wersji
::----------------------------------------------------------------------------------------------------------------------
_delete:="
   VAR_DEL.delete('PxSelect')
";
_delete();
_version:=PX_VER.ref();
PxSelect:=exec('pxselect','px_plan');
PxSelect.save();
PX_VAR.VIE_VER:=_version;
PX_VAR.VER_QUE:=_version;
PX_VAR.EDIT:=0;
PxSelect.VER_QUE:=_version;
PX_GRP.index('LP');
PX_GRP.prefix(_version,'Z');

exec('px_grp_tmp','px_grp',);
PxSelect.Pxgrp.TAB.select();

:: Przywracanie kontekstow
PxSelect.restore();

_delete();
~~


\validate_grp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Walidacja okien redakcyjnych zmiennej PX_VAR: ADD1 i ADD2
::   WE: _a - INTEGER - 0 - obsluga podczas 'Dolacz'
::                      1 - obsluga podczas 'Popraw'
::   WY: '' lub akronim pola
::----------------------------------------------------------------------------------------------------------------------
_mode:=_a;

:: Jezeli data koncowa (termin realizacji) nie jest okreslony, to domyslnie planowanie w przod
{? PX_VAR.TM_END=0
|| PX_VAR.ADD_DIR:=1
?};

:: Jezeli zwrot wg obiektow zrodlowych, to nie mozna agregowac (tutaj wyjatkowo wyjscie return-em)
{? PX_VAR.ADD_DIR=0 & PX_VAR.AGR='T'
|| FUN.emsg('Nie można agregować pozycji jeżeli zwrot planowania jest pobrany z obiektów źródłowych.'@);
   return('ADD_DIR')
?};

_result:='';

PX_VAR.TM_GRN:=exec('create','#tm_stamp',PX_VAR.GRN_DATA,PX_VAR.GRN_TIME);

:: Sprawdzamy ilosci
{? PX_VAR.ILOSC<>0
|| {? PX_VAR.ADD_IL>PX_VAR.ILOSC
   || FUN.emsg('Ilość nie może być większa od ilości w obiekcie.'@);
      _result:='ADD_IL'
   ?}
?};

_chk_grn:=1;
{? exec('is_px_set','px_param')>0
||
:: Jesli praca na zestawie to nie kontroluje czy granica czasowa jest podana, bo
:: ona sluzy tylko do tworzenia automatycznych punktow czasowych
   _chk_grn:=0
?};

{? _chk_grn=1 & PX_VAR.GRN_DATA=date(0,0,0)
|| _msg:={? PX_VAR.ADD_DIR=1
         || 'Data rozpoczęcia musi być podana.'@
         || 'Data zakończenia musi być podana.'@
         ?};
   FUN.emsg(_msg);
   {? PX_VAR.ADD_DIR<>0
   || _result:='GRN_DATA'
   || _result:='ADD_DIR'
   ?}
|? PX_VAR.GRN_DATA<>date(0,0,0) & PX_VAR.GRN_DATA<date()
|| {? PX_VAR.ADD_DIR=1
   || FUN.emsg('Nie można planować w przód z datą niższą od bieżącej.'@)
   || FUN.emsg('Nie można planować wstecz dla daty niższej od bieżącej.'@)
   ?};
   {? PX_VAR.ADD_DIR<>0
   || _result:='GRN_DATA'
   || _result:='ADD_DIR'
   ?}
|? PX_VAR.TM_END>0 & PX_VAR.TM_GRN>PX_VAR.TM_END
|| FUN.emsg('Granica czasowa jest późniejsza niż data realizacji planowanego obiektu: %1.\n'
            'Należy zmienić termin realizacji w obiekcie planowanym.'@[exec('to_string','#tm_stamp',PX_VAR.TM_END)]);
   {? PX_VAR.ADD_DIR<>0
   || _result:='GRN_DATA'
   || _result:='ADD_DIR'
   ?}
|? VAR.GRUPA<>'T' & PX_VAR.AGR='N' & PX_VAR.ADD_TX=null() & PX_VAR.GROP=null()
|| FUN.emsg('Przepis dla elementu w kolejce musi być podany.'@);
   _result:='ADD_TX'
|? PX_VAR.AGR='N' & PX_VAR.ADD_TX<>null() & exec('conns_ok','px_tex',PX_VAR.ADD_TX)=0
|| _msg:='Wybrany przepis planistyczny ma niepoprawne powiązania pomiędzy etapami\n'
         'i nie może być użyty w obecnej formie do planowania.\n\n'
         'Może to być spowodowane tym, że technologia z której pochodzi posiada rozgałęzienia operacji.\n\n'
         'Rozgałęzienia etapów w przepisie nie są możliwe, dlatego konieczna jest zmiana przepisu\n'
         'lub ręczna korekta wybranego tak, aby ustalić prawidłową ścieżkę powiązań pomiędzy etapami.'@;
   FUN.emsg(_msg);
   _result:='ADD_TX'
|? _mode=1 & exec('check_grn','px_grp',PX_VAR.TM_GRN,PX_VAR.ADD_DIR)=0
|| _msg:='Podana granica czasowa spowoduje, że grupa będzie miała taki sam czas początku i końca.\n\n'
         'Granice czasowe grupy przed redakcją:\n'
         'Start: %1\n'
         'Koniec: %2\n\n'
         'Wymagane jest jedno z następujących działań:\n'
         '● Zmiana zwrotu planowania\n'
         '● Zmiana granicy czasowej'@[(19+tm_form(PX_GRP.TM_START)),(19+tm_form(PX_GRP.TM_END))];
   _choice:=FUN.emsg(_msg);
   _result:='GRN_DATA'
?};

_chk_plforce:=1;
{? _result='' & _mode=1 & exec('is_px_set','px_param')>0
||
   _admin:=(exec('get','#params',8062,2,OPERATOR.USER)='T');
   {? _admin=0 & PX_VAR.PX_SET<>null() & PX_VAR.PX_SET<>PX_GRP.SET_SRC
   || _chk_plforce:=0
   ?}
?};

{? _result='' & PX_VAR.PL_FORCE='T' & _chk_plforce>0
|| _can_continue:=1;
   {? PX_VAR.ADD_DIR<0
   || _msg:='Nie można kontynuować planowania po przekroczeniu terminu w przypadku planowania wstecz.'@;
      _can_continue:=0
   |? PX_VAR.ADD_DIR=0
   || _msg:='Nie można kontynuować planowania po przekroczeniu terminu w przypadku gdy zwrot pochodzi z obiektów źródłowych.'@;
      _can_continue:=0
   ?};
   {? _can_continue=0
   || FUN.emsg(_msg);
      _result:='PL_FORCE'
   ?}
?};
{? _result='' & _mode=1 & PX_VAR.TX_BEFOR<>PX_VAR.ADD_TX
||
:: Jezeli zostal poprawiony przepis to sprawdzam czy nie bylo wykonan - jesli byly to uniemozliwiam poprawe
:: 1. Sprawdzam wykonania do przewodnikow zlecenia
   {? exec('has_wyk_zlgd','px_grp',PX_GRP.ref())>0
   || _msg:='Dla obiektu grupującego: %1\n'
            'istnieją rejestracje wykonań do przewodników zlecenia.\n\n'
            'Modyfikacja przepisu planistycznego niedozwolona.'@[PX_GRP.SYMBOL];
      FUN.emsg(_msg);
      _result:='ADD_TX'
   ?};
   {? _result=''
   ||
      {? exec('has_wyk_pl','px_grp',PX_GRP.ref())>0
      || _msg:='Dla obiektu grupującego: %1\n'
               'istnieją rejestracje wykonań do Planu operacyjnego.\n\n'
               'Modyfikacja przepisu planistycznego niedozwolona.'@[PX_GRP.SYMBOL];
         FUN.emsg(_msg);
         _result:='ADD_TX'
      ?}
   ?};
   {? _result=''
   ||
      _px_grp:=PX_GRP.ref();
      _prefix_mode:=exec('poz_prefix_mode','px_grp',,0);
      {? _prefix_mode='SOURCE'
      ||
::       Przechodze na PX_GRP w wersji glownej
         PX_GRP.cntx_psh();
         PX_GRP.index('UID');
         PX_GRP.prefix(PX_GRP.UID_SRC);
         {? PX_GRP.first()
         || _px_grp:=PX_GRP.ref()
         ?};
         PX_GRP.cntx_pop()
      ?};

      {? exec('has_wyk_px','px_grp',_px_grp)>0
      || _msg:='Dla obiektu grupującego: %1\n'
               'istnieją rejestracje wykonań do Planu strategicznego.\n\n'
               'Modyfikacja przepisu planistycznego niedozwolona.'@[PX_GRP.SYMBOL];
         FUN.emsg(_msg);
         _result:='ADD_TX'
      ?}
   ?}
?};
{? _result='' & PX_VAR.AGR<>'T' & PX_VAR.ADD_TX<>null() & exec('is_px_set','px_param')>0 & PX_VAR.PX_SET<>null()
||
   PX_SET.cntx_psh();
   PX_TEX.cntx_psh();
:: Sprawdzam czy wybrany zestaw znajduje sie w przepisie planowanej grupy
   {? exec('has_set','px_tex',PX_VAR.ADD_TX,PX_VAR.PX_SET)=0
   || _msg:='Wybrany przepis planistyczny nie zawiera żadnego etapu przypisanego do bieżącego zestawu planistycznego.\n\n'
            'Przepis: %1\n'
            'Zestaw: %2\n\n'
            'Aby zaplanować obiekt wg tego przepisu należy pracować w kontekście innego zestawu,\n'
            'lub wybrać inny przepis planistyczny dla obiektu.'@[exec('record','#to_string',PX_VAR.ADD_TX),PX_VAR.PX_SET().SYMBOL];
      FUN.emsg(_msg);
      _result:='ADD_TX'
   ?};
   PX_TEX.cntx_pop();
   PX_SET.cntx_pop();

   {? _result='' & _mode=1 & PX_VAR.TX_BEFOR<>PX_VAR.ADD_TX
   ||
::    Jesli praca na zestawach to pytam czy na pewno zmienic przepis bo spowoduje to
::    aktualizacje PX_GRPSow i punktow
      {? _result='' & exec('is_px_set','px_param')
      || _msg:='Zmiana przepisu na elemencie kolejki: %1\n'
               'spowoduje utratę wszystkich potwierdzeń i odtworzenie automatycznych punktów czasowych.\n'
               'Czy na pewno kontynuować?'@[PX_GRP.SYMBOL];
         {? FUN.ask(_msg)=0
         || _result:='ADD_TX'
         ?}
      ?}
   ?}
?};
{? _result='' & _mode=1 & PX_GRP.SET_SRC<>null()
||
:: Sprawdzam czy zestaw startowy znajduje sie w przepisie planowanej grupy
   {? exec('has_set','px_tex',PX_VAR.ADD_TX,PX_GRP.SET_SRC)=0
   || _msg:='Wybrany przepis planistyczny nie zawiera żadnego etapu przypisanego do zestawu startowego poprawianego elementu.'
            'Przepis: %1\n'
            'Zestaw: %2\n'
            'Aby zaplanować obiekt wg tego przepisu należy wybrać przepis planistyczny zawierający ww. zestaw.'@[exec('record','#to_string',PX_VAR.ADD_TX),PX_GRP.SET_SRC().SYMBOL];
      FUN.emsg(_msg);
      _result:='ADD_TX'
   ?}
?};
{? _result=''
||
:: Walidacja pod wzgledem punktow czasowych
   _result:=exec('validate_poi','px_grp',_mode)
?};
_result


\validate_poi
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Walidacja okien redakcyjnych elementow kolejki pod wzgledem zgodnosci z zestawami
::       i punktami czasowymi
::   WE: _a - INTEGER - 0 - obsluga podczas 'Dolacz'
::                      1 - obsluga podczas 'Popraw'
::   WY: '' lub akronim pola
::----------------------------------------------------------------------------------------------------------------------
_mode:=_a;

_result:='';

{? _result='' & _mode=1 & exec('is_px_set','px_param')>0 & PX_VAR.PX_SET<>null() & PX_VAR.GRN_DATA<>date(0,0,0)
||
:: Sprawdzam czy istnieja jakies reczne punkty czasowe, ktore moga mi sie skonfliktowac z tworzonymi automatycznie
   {? var_pres('_args_poi')>100
   || obj_del(_args_poi)
   ?};
   _args_poi:=exec('auto_point_a','px_point');
   _args_poi.PX_GRP:=PX_GRP.ref();
   _args_poi.PX_TEX:=PX_VAR.ADD_TX;
   _args_poi.PX_SET:=PX_VAR.PX_SET;
   _args_poi.DIR:=PX_VAR.ADD_DIR;
   _args_poi.GRN_DATA:=PX_VAR.GRN_DATA;
   _args_poi.GRN_TIME:=PX_VAR.GRN_TIME;
   _args_poi.MODE:='FORMULA';
   {? var_pres('_wew_args')>100
   || obj_del(_wew_args)
   ?};
   _wew_args:=obj_new('POI_HAND');
   _wew_args.POI_HAND:=0;
   _args_poi.ARGS:=_wew_args;
   _args_poi.FORMULA:="
      _args:=_a;
      _wew_args:=_b;
      PX_POINT.cntx_psh();
      PX_POINT.index('TYP');
      PX_POINT.prefix('R',_args.PX_GRP,PX_STAGE.ref());
      {? PX_POINT.size()>0
      || _wew_args.POI_HAND:=1
      ?};
      PX_POINT.cntx_pop();
      1
   ";
   exec('auto_point','px_point',_args_poi);
   {? _wew_args.POI_HAND>0
   || _msg:='Wskazany zwrot i granica czasowa dla elementu kolejki: %1\n'
            'spowodują utworzenie automatycznych punktów czasowych,\n'
            'ale skonfliktują się one z istniejącymi punktami ręcznymi.\n\n'
            'Czy zastąpić istniejace punkty czasowe automatycznymi?'@[PX_GRP.SYMBOL];
      _ask:=FUN.ask(_msg);
      {? _ask=0
      || _result:='GRN_DATA'
      ?}

   ?}
?};

{? _result='' & _mode=1 & exec('is_px_set','px_param')>0 & PX_VAR.PX_SET<>null() & PX_VAR.GRN_DATA<>date(0,0,0)
||
:: Sprawdzam czy wprowadzona granica czasowa nie spowoduje powstania automatycznych
:: punktow czasowych, ktore sie zazebia z innymi punktami
   {? var_pres('_args_poi')>100
   || obj_del(_args_poi)
   ?};
   _args_poi:=exec('auto_args_grps','px_point');
   _args_poi.DIR:=PX_VAR.ADD_DIR;
   _args_poi.GRN_DATA:=PX_VAR.GRN_DATA;
   _args_poi.GRN_TIME:=PX_VAR.GRN_TIME;
   _args_poi.MODE:='FORMULA';
   _args_poi.FORMULA:="exec('simulation_zaz','px_point',_a)";
   KOMM.init(250,,'Weryfikacja automatycznych punktów czasowych.'@);
   {? exec('auto_point','px_point',_args_poi)=0
   || _msg:='Wskazany zwrot i granica czasowa dla bieżącego zestawu planistycznego, spowodowałaby\n'
            'utworzenie automatycznych punktów czasowych, które zazębią się z istniejącymi już punktami.\n'
            'Należy wskazać inny zwrot lub granicę czasową, lub zmodyfikować kolidujące punkty czasowe\n\n'
            'Bieżący zestaw: %1\n\n'
            'Aby zobaczyć informację o kolizjach należy wybrać \'Szczegóły\'.\n'
            'Aby zobaczyć wszystkie istniejące punkty czasowe należy wybrać  \'Pokaż punkty czasowe\'.'@[PX_VAR.PX_SET().SYMBOL];
      _choice:=FUN.choice(_msg,,'Szczegóły'@,'Pokaż punkty czasowe'@);
      {? _choice=1
      || KOMM.select()
      |? _choice=2
      || exec('select_action','px_point',PX_GRP.ref(),,0,0)
      ?};
      _result:='GRN_DATA'
   ?}
?};
{? _result='' & exec('is_px_set','px_param')>0 & PX_VAR.PX_SET<>null() & PX_VAR.GRN_DATA<>date(0,0,0)
||
:: Sprawdzam czy wprowadzona granica czasowa nie spowoduje powstania automatycznych
:: punktow czasowych, ktore uniemozliwia zaplanowanie niektorych etapow
   {? var_pres('_args_poi')>100
   || obj_del(_args_poi)
   ?};
   _args_poi:=exec('auto_point_a','px_point');
   _args_poi.PX_TEX:=PX_VAR.ADD_TX;
   _args_poi.PX_SET:=PX_VAR.PX_SET;
   _args_poi.DIR:=PX_VAR.ADD_DIR;
   _args_poi.GRN_DATA:=PX_VAR.GRN_DATA;
   _args_poi.GRN_TIME:=PX_VAR.GRN_TIME;
   _args_poi.MODE:='FORMULA';
   _args_poi.FORMULA:="exec('chk_start_poi','px_point',_a,_b)";
   {? var_pres('_wew_args')>100
   || obj_del(_wew_args)
   ?};
   _wew_args:=obj_new('STG_NAME','STG_BEF');
   _wew_args.STG_NAME:='';
   _wew_args.STG_BEF:=0;
   _args_poi.ARGS:=_wew_args;
   {? exec('auto_point','px_point',_args_poi)=0
   || _msg:='Wskazany zwrot i granica czasowa mogą uniemożliwić zaplanowanie tego elementu.\n'
            'Startowy zestaw nie jest pierwszy w procesie, więc ustalona granica czasowa spowoduje,\n'
            'potencjalny problem z zaplanowaniem wcześniejszych etapów.\n\n'
            'Zestaw startowy: %1\n'
            'Etap startowy: %2\n'
            'Ilość wczesniejszych etapów: %3\n\n'
            'Aby zapewnić poprawne zaplanowanie należy przesunąć granicę czasową, lub wyzerować ją kompletnie.\n'
            'Czy na pewno kontynuować planowanie?'@[PX_VAR.PX_SET().SYMBOL,_args_poi.ARGS.STG_NAME,$_args_poi.ARGS.STG_BEF];
      _ask:=FUN.ask(_msg);
      {? _ask=0
      || _result:='GRN_DATA'
      ?}
   ?}
?};
_result


\check_grn
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Po edycji PX_GRP - sprawdza czy na PX_GRP beda takie same czasy poczatku i konca
::       Kontekst pracy - PX_GRP
::   WE: _a - REAL - wprowadzona przez usera granica czasowa
::       _b - INTEGER - wprowadzony przez usera zwrot
::   WY: 0 - daty niepoprawne - taki sam poczatek i koniec
::       1 - daty poprawne
::----------------------------------------------------------------------------------------------------------------------
_tm_grn:=_a;
_dir:=_b;

_result:=1;

{? _tm_grn>0
||
   {? _dir>0
   ||
::    Planowanie do przodu - to co user podal bedzie wpisane jako granica poczatku na PX_GRP
::    ktora nalezy porownac z granica koncowa
      {? _tm_grn=PX_GRP.TM_END
      || _result:=0
      ?}

   ?};
   {? _dir<0
   ||
::    Planowanie wstecz - to co user podal bedzie wpisane jako granica konca na PX_GRP
::    ktora nalezy porownac z granica poczatkowa
      {? _tm_grn=PX_GRP.TM_START
      || _result:=0
      ?}
   ?}
?};
_result


\validate_conn
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Walidacja okien redakcyjnych zmiennej PX_VAR: ADD1 i ADD2
::   WE: _a - INTEGER - 0 - obsluga podczas 'Dolacz'
::                      1 - obsluga podczas 'Popraw'
::   WY: '' lub akronim pola
::----------------------------------------------------------------------------------------------------------------------
_mode:=_a;
_result:='';

{? _mode=0
||
:: Obsluga na dolacz - nie ma jeszcze PX_CONN, dlatego opieram sie na wartosci zmiennej

:: Sprawdzamy ilosci
   {? PX_VAR.ILOSC<>0
   || {? PX_VAR.ADD_IL>PX_VAR.ILOSC
      || FUN.emsg('Ilość nie może być większa od ilości w obiekcie.'@);
         _result:='ADD_IL'
      ?}
   ?}
|? _mode=1
||
:: Obsluga na popraw - stoje na rekordzie PX_CONN

:: Sprawdzamy ilosci
   {? PX_CONN.ILOSC<>0
   ||
::    Podczytanie PX_OBJ
      PX_CONN.PX_OBJ();

      _ilosc:=PX_OBJ.IL-exec('get_ilosc_que','px_obj',PxSelect.VER_QUE,PX_OBJ.ref());

      {? PX_VAR.ADD_IL>_ilosc+PX_CONN.ILOSC
      || FUN.emsg('Ilość nie może być większa od ilości w obiekcie i ilości obiektu w kolejce.'@);
         _result:='ADD_IL'
      ?}
   ?}
?};
_result


\can_block
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Sprawdza czy mozna zablokowac obiekt grupujacy. Nie mozna blokowac w przypadkach gdy:
::          1. Obiekt grupujacy ma jakakolwiek pozycje opozniona - poniewaz planowanie opoznien
::                jest robione po planowaniu pozycji zablokowanych moze dojsc do sytuacji ze blokady i
::                opoznienia spowoduja ze kolejnosc etapow sie zupelnie zaburzy
::   WE: _a - PX_GRP.ref() - obiekt grupujacy ktory blokowac
::       [_b] - INTEGER - 1 / 0 pokazywac info w KOMM o niepowodzeniach czy nie [domyslnie: 0]
::       [_c] - STRING - tryb blokowania: 'T' - zwykły, 'Z' - z powodu wygenerowanych zleceń
::   WY: 0 - zguba
::       1 - zwyciestwo
::----------------------------------------------------------------------------------------------------------------------
_grp:=_a;
_info:=0;
{? var_pres('_b')=type_of(0)
|| _info:=_b
?};
_mode:='T';
{? var_pres('_c')=type_of('')
|| _mode:=_c
?};

_result:=0;
_can_continue:=1;

{? _info>0 & VAR.GRUPA<>'T'
|| KOMM.init(,,'Blokowanie pozycji kolejki')
?};

PX_OBJ.cntx_psh();
PX_POZ.cntx_psh();
PX_GRP.cntx_psh();
PX_GRP.clear();
{? PX_GRP.seek(_grp)
||
:: Sprawdzam czy mozna zablokowac grupe
   _display:=1;
   {? VAR.GRUPA='T'
   || _display:=2
   ?};
   {? exec('lock','px_grp',,_display)>0
   ||
      {? exec('is_blocked','px_grp')
      || {? PX_GRP.BLK<>_mode
         || _can_continue:=0;
            _msg:='Obiekt grupujący: %1 został już zablokowany silniejszym trybem podczas generowania zleceń.'@[exec('PX_GRP','#to_string')];
            KOMM.add(_msg,2,1)
         ?}
      ?};

      {? _can_continue>0
      ||
         PX_POZ.index('PX_GRP2');
         PX_POZ.prefix(_grp);
         {? PX_POZ.first()
         || {!
            |? {? PX_POZ.STATUS=exec('status_delay','px_poz')
                     |
                  PX_POZ.STATUS=exec('status_wyk1','px_poz')
                     |
                  PX_POZ.STATUS=exec('status_wyk2','px_poz')
               || _can_continue:=0;
                  {? _info>0
                  ||
                     KOMM.sect_beg('Pozycja kolejki: %1 %2'@[$PX_GRP.LP_Q,PX_GRP.SYMBOL]);
                     _cause:={? PX_POZ.STATUS=exec('status_delay','px_poz') || 'opóźniona'@
                             |? PX_POZ.STATUS=exec('status_wyk1','px_poz')  || 'wykonywana'@
                             |? PX_POZ.STATUS=exec('status_wyk2','px_poz')  || 'wykonana'@
                                                                            || ''
                             ?};
                     _msg:='Nie można zablokować obiektu w kolejce, ponieważ pozycja planu: %1 jest %2.'@[PX_POZ.PX_OBJ().SYMBOL,_cause];
                     KOMM.add(_msg,'xwin16.png:9');
                     KOMM.sect_end()
                  ?}
               ?};
               PX_POZ.next() & _can_continue>0
            !}
         ?}
      ?}
   || _can_continue:=0
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
{? _info>0 & VAR.GRUPA<>'T'
|| {? KOMM.get_size()>0
   || KOMM.select()
   ?}
?};
PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
PX_POZ.cntx_pop();
_result


\block
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Blokuje PX_GRP i wszystkie pozycje planu powiazane z nim
::   WE: _a - PX_GRP.ref() - obiekt grupujacy ktory blokowac
::       [_b] - STRING - tryb blokowania: 'T' - zwykły, 'Z' - z powodu wygenerowanych zleceń
::   WY: 0 - zguba
::       1 - zwyciestwo
::----------------------------------------------------------------------------------------------------------------------
_grp:=_a;
_mode:='T';
{? var_pres('_b')=type_of('')
|| _mode:=_b
?};

_result:=0;
_can_continue:=1;

PX_POZ.cntx_psh();
PX_GRP.cntx_psh();
PX_GRP.clear();
{? PX_GRP.seek(_grp)
||
   {? PX_GRP.BLK='N' | _mode='Z'
   ||
      PX_POZ.index('PX_GRP2');
      PX_POZ.prefix(_grp);
      {? PX_POZ.first()
      || {!
         |? _can_continue:=exec('block','px_poz',PX_POZ.ref());
            PX_POZ.next() & _can_continue>0
         !}
      ?};
      {? _can_continue>0
      || PX_GRP.BLK:=_mode;
         _can_continue:=PX_GRP.put()
      ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
PX_GRP.cntx_pop();
PX_POZ.cntx_pop();
_result


\unblock
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Odblokowuje PX_GRP i wszystkie pozycje planu powiazane z nim
::   WE: _a - PX_GRP.ref() - obiekt grupujacy ktory odblokowac
::       [_b] - STRING - tryb blokowania: 'T' - zwykły, 'Z' - z powodu wygenerowanych zleceń
::   WY: 0 - zguba
::       1 - zwyciestwo
::----------------------------------------------------------------------------------------------------------------------
_grp:=_a;
_mode:='T';
{? var_pres('_b')=type_of('')
|| _mode:=_b
?};
_result:=0;
_can_continue:=1;

PX_POZ.cntx_psh();
PX_GRP.cntx_psh();
PX_GRP.clear();
{? PX_GRP.seek(_grp)
|| {? PX_GRP.BLK=_mode | _mode='Z'
   ||
      PX_POZ.index('PX_GRP2');
      PX_POZ.prefix(_grp);
      {? PX_POZ.first()
      || {!
         |? _can_continue:=exec('unblock','px_poz',PX_POZ.ref());
            PX_POZ.next() & _can_continue>0
         !}
      ?};
      {? _can_continue>0
      ||
         PX_GRP.BLK:='N';
         _can_continue:=PX_GRP.put()
      ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
PX_GRP.cntx_pop();
PX_POZ.cntx_pop();
_result


\block_action
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Akcja blokowania PX_GRP
::   WY: 0 - zguba
::       1 - zwyciestwo
::----------------------------------------------------------------------------------------------------------------------

_result:=0;
PX_GRP.cntx_psh();
PX_GRP.clear();
_can_continue:=1;
_one_ver:=exec('is_one_version','px_param');
_px_grp:={? _one_ver || $PX_GRPS.PX_GRP || PxSelect.Pxgrp.TAB.PX_GRPI ?};

_ref:=exec('FindAndGet','#table',PX_GRP,_px_grp);
{? PX_GRP.seek(_ref)
|| _current_grp:=PX_GRP.ref();
:: szukam takiego samego obiektu grupujacego ale w wersji zrodlowej
   PX_GRP.index('UID');
   _uid:='';
   _prefix_mode:=exec('poz_prefix_mode','px_grp');
   {? _prefix_mode='SOURCE'
   || _uid:=PX_GRP.UID_SRC
   || _uid:=PX_GRP.UID
   ?};
   PX_GRP.prefix(_uid);
   {? PX_GRP.first()
   ||
::    sprawdzam czy obiekt grupujacy w wersji zrodlowej ma pozycje planu - jesli nie to nie moge blokowac
      PX_POZ.cntx_psh();
      PX_POZ.index('PX_GRP2');
      PX_POZ.prefix(PX_GRP.ref());
      {? PX_POZ.first()
      || _can_continue:=1
      || _can_continue:=0;
         {? VAR.GRUPA='T'
         || KOMM.add('Obiekt w kolejce nie posiada żadnych pozycji planu - %1'@[PX_GRP.SYMBOL])
         || FUN.emsg('Obiekt w kolejce nie posiada żadnych pozycji planu.\nBlokowanie niemożliwe.'@)
         ?}
      ?};
      PX_POZ.cntx_pop();
      {? _can_continue>0
      || {? VAR.GRUPA='T'
         || _choice:=1
         || _choice:=FUN.choice('Czy zablokować grupę obiektów?'@,,'Tak'@,'Nie'@)
         ?};
         {? _choice=1
         ||
::          Sprawdzam czy mozliwe jest zablokowanie
            _can_continue:=exec('can_block','px_grp',PX_GRP.ref(),1);
            {? _can_continue>0
            ||
               _result:=exec('block','px_grp',PX_GRP.ref());

::             jesli sie udalo zablokowac to nanosze tez ta zmiane na biezacy widok tymczasowy kolejki
               {? _result>0 & ~_one_ver
               || PxSelect.Pxgrp.TAB.BLK:='T';
                  PxSelect.Pxgrp.TAB.put();
                  PxSelect.Pxgrp.TAB.cntx_psh();
                  PxSelect.Pxgrp.TAB.index(PxSelect.Pxgrp.NDX_NOD);
                  PxSelect.Pxgrp.TAB.prefix(PxSelect.Pxgrp.TAB.UPNODE);
                  {? PxSelect.Pxgrp.TAB.first()
                  || PxSelect.Pxgrp.TAB.BLK:='T';
                     PxSelect.Pxgrp.TAB.put()
                  ?};
                  PxSelect.Pxgrp.TAB.cntx_pop()
               ?};

::             jesli sie udalo zablokowac to blokuje tez obiekt w biezacym widoku
               {? _result>0
               || exec('block','px_grp',_current_grp)
               ?}
            ?};
::          Odblokowuje grupe
            exec('unlock','px_grp',PX_GRP.ref())
         ?}
      ?}
   ?}
?};
exec('kafelki_reload','px_plan');
PX_GRP.cntx_pop();
_result


\block_actionb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Akcja blokowania PX_GRP (przed grupa rekordow)
::----------------------------------------------------------------------------------------------------------------------
KOMM.init(,,'Blokowanie obiektów'@);
{? FUN.ask('Czy zablokować zaznaczone grupy obiektów?'@)
|| VAR.GRUPA:='T'; 1
|| 0
?}


\block_actiona
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Akcja blokowania PX_GRP (po grupie rekordow)
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
exec('kafelki_reload','px_plan');
~~


\unblock_action
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Akcja odblokowania PX_GRP
::   WE: [_a] - STRING - tryb blokowania: 'T' - zwykły, 'Z' - z powodu wygenerowanych zleceń
::   WY: 0 - zguba
::       1 - zwyciestwo
::----------------------------------------------------------------------------------------------------------------------
_mode:='T';
{? var_pres('_a')=type_of('')
|| _mode:=_a
?};
_result:=0;
PX_GRP.cntx_psh();
PX_GRP.clear();
_can_continue:=1;
_one_ver:=exec('is_one_version','px_param');
_px_grp:={? _one_ver>0 || $PX_GRPS.PX_GRP || PxSelect.Pxgrp.TAB.PX_GRPI ?};

{? PX_GRP.seek(_px_grp,8+_px_grp)
|| _current_grp:=PX_GRP.ref();
:: szukam takiego samego obiektu grupujacego ale w wersji zrodlowej
   PX_GRP.index('UID');
   _uid:='';
   _prefix_mode:=exec('poz_prefix_mode','px_grp');
   {? _prefix_mode='SOURCE'
   || _uid:=PX_GRP.UID_SRC
   || _uid:=PX_GRP.UID
   ?};
   PX_GRP.prefix(_uid);
   {? PX_GRP.first()
   ||
::    sprawdzam czy obiekt grupujacy w wersji zrodlowej ma pozycje planu - jesli nie to nie moge odblokowac
      PX_POZ.cntx_psh();
      PX_POZ.index('PX_GRP2');
      PX_POZ.prefix(PX_GRP.ref());
      {? PX_POZ.first()
      || _can_continue:=1
      || _can_continue:=0;
         {? VAR.GRUPA='T'
         || KOMM.add('Obiekt w kolejce nie posiada żadnych pozycji planu - %1'@[PX_GRP.SYMBOL])
         || FUN.emsg('Obiekt w kolejce nie posiada żadnych pozycji planu.\nOdblokowanie niemożliwe.'@)
         ?}
      ?};
      PX_POZ.cntx_pop();

::    Sprawdzam czy mozna zablokowac grupe do edycji
      _display:=1;
      {? VAR.GRUPA='T'
      || _display:=2
      ?};

      {? _can_continue>0
      || {? PX_GRP.BLK<>_mode
         || _can_continue:=0;
            _msg:='Nie można odblokować grupy: %1, ponieważ została nałożona silniejsza blokada (wygenerowano zlecenia).'@[exec('PX_GRP','#to_string')];
            {? _display=1
            || FUN.emsg(_msg)
            |? _display=2
            || KOMM.add(_msg,2)
            ?}
         ?}
      ?};

      {? _can_continue>0
      ||
         {? VAR.GRUPA='T'
         || _choice:=1
         || _choice:=FUN.choice('Czy odblokować grupę obiektów?'@,,'Tak'@,'Nie'@)
         ?};
         {? _choice=1
         ||
            {? exec('lock','px_grp',,_display)
            ||
               _result:=exec('unblock','px_grp',PX_GRP.ref());

::             jesli sie udalo to nanosze tez ta zmiane na biezacy widok tymczasowy kolejki
               {? _result>0 & _one_ver=0
               || PxSelect.Pxgrp.TAB.BLK:='N';
                  PxSelect.Pxgrp.TAB.put();
                  PxSelect.Pxgrp.TAB.cntx_psh();
                  PxSelect.Pxgrp.TAB.index(PxSelect.Pxgrp.NDX_NOD);
                  PxSelect.Pxgrp.TAB.prefix(PxSelect.Pxgrp.TAB.UPNODE);
                  {? PxSelect.Pxgrp.TAB.first()
                  || PxSelect.Pxgrp.TAB.BLK:='N';
                     PxSelect.Pxgrp.TAB.put()
                  ?};
                  PxSelect.Pxgrp.TAB.cntx_pop()
               ?};

               {? _result>0
               ||
::                Stempluje kolejke jako zmodyfikowana
                  exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER);

                  {? _one_ver>0 & VAR.GRUPA<>'T'
                  ||
::                   Aktualizuje przyciski w panelu nawigacyjnym
                     exec('przelicz_btn','px_plan')
                  ?}
               ?};

::             jesli sie udalo to odblokowuje tez obiekt w biezacym widoku
               {? _result>0
               || exec('unblock','px_grp',_current_grp)
               ?};
               exec('unlock','px_grp')
            ?}
         ?}
      ?}
   ?}
?};
exec('kafelki_reload','px_plan');
PX_GRP.cntx_pop();
_result


\unblock_actionb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Akcja odblokowania PX_GRP (przed grupa rekordow)
::----------------------------------------------------------------------------------------------------------------------
KOMM.init(,,'Odbkowywanie obiektów'@);
{? FUN.ask('Czy odblokować zaznaczone grupy obiektów?'@)
|| VAR.GRUPA:='T'; 1
|| 0
?}


\unblock_actiona
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Akcja odblokowania PX_GRP (po grupie rekordow)
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
{? exec('is_one_version','px_param')>0
||
:: Aktualizuje przyciski w panelu nawigacyjnym
   exec('przelicz_btn','px_plan')
?};
exec('kafelki_reload','px_plan');
~~


\select_paczka
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Pokazuje paczke technologiczna dla aktualnej pozycji kolejki
::----------------------------------------------------------------------------------------------------------------------
_px_grp:={? exec('is_one_version','px_param') || $PX_GRPS.PX_GRP || PxSelect.Pxgrp.TAB.PX_GRPI ?};

PX_GRP.clear();
{? PX_GRP.seek(_px_grp,8+_px_grp)
|| _paczka:=exec('trzepaczka','px_tex',PX_GRP.PX_TEX,PX_GRP.ILOSC,PX_GRP.ref());
   exec('paczka_select','px_tex',_paczka)
?};
~~


\pxvaraddsymbr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: przed redakcja pola add_sym w px_var
::   WY: 0 - nie mozna redagowac
::       1 - mozna redagowac
::----------------------------------------------------------------------------------------------------------------------
0


\pxvaraddopisbr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: przed redakcja pola add_opis w px_var
::   WY: 0 - nie mozna redagowac
::       1 - mozna redagowac
::----------------------------------------------------------------------------------------------------------------------
0


\pxvaraddilbr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: przed redakcja pola add_il w px_var
::   WY: 0 - nie mozna redagowac
::       1 - mozna redagowac
::----------------------------------------------------------------------------------------------------------------------
_result:=1;

{? PX_VAR.win_edit('?')='RED1'
|| _result:=0
||
   PX_CON_O.cntx_psh();
   PX_CONN.cntx_psh();
   PX_GRP.cntx_psh();

   _np:=_pn:=0;

   {? menu_txt()*'Popraw'>0
   || {? PX_CONN.PX_GRP().PLAN_OPR='T'
      || _result:=0
      ?};
      {? PX_CONN.PX_GRP().STATUS=exec('status_wyk1','px_grp')
         |
         PX_CONN.PX_GRP().STATUS=exec('status_wyk2','px_grp')
      || _result:=0
      ?};
      {? _result>0
      || PX_OBJ.cntx_psh();
         ZL.cntx_psh();
         ZTP.cntx_psh();
         {? PX_CONN.PX_OBJ().ZL().TYP().WP='W'
         || _result:=0
         ?};
         ZL.cntx_pop();
         ZTP.cntx_pop();
         PX_OBJ.cntx_pop();
         ~~
      ?}
   || PX_OBJ.cntx_psh();
      ZL.cntx_psh();
      ZTP.cntx_psh();
      {? PX_OBJ.ZL().TYP().WP='W'
      || _result:=0
      ?};
      ZL.cntx_pop();
      ZTP.cntx_pop();
      PX_OBJ.cntx_pop();
      ~~
   ?};

   {? _result>0
   ||
      PX_CON_O.index('NP');
      PX_CON_O.prefix(PX_OBJ.ref());
      {? PX_CON_O.first() || _np:=1 ?};
      PX_CON_O.index('PN');
      PX_CON_O.prefix(PX_OBJ.ref());
      {? PX_CON_O.first() || _pn:=1 ?};

      {? _np | _pn
      ||
::       Obiekt powiazany - nie mozna modyfikowac ilosci
         _result:=0
      ?}
   ?};
   PX_CON_O.cntx_pop();
   PX_CONN.cntx_pop();
   PX_GRP.cntx_pop();
   ~~
?};
_result


\pxvaraddtxbr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: przed redakcja pola add_tx w px_var
::   WY: 0 - nie mozna redagowac
::       1 - mozna redagowac
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_admin:=(exec('get','#params',8062,2,OPERATOR.USER)='T');
{? menu_txt()*'Popraw'>0
|| {? ~_admin & exec('is_px_set','px_param')>0 & PX_GRP.SET_SRC<>PX_VAR.PX_SET
   || _result:=0
   ?};
   {? _result>0
   || {? PX_GRP.PX_TAG<>null()
      ||
::       Dla elementu utworzonego z PX_TAGa nie umożliwiamy poprawienia przepisu,
::       bo przepis jest podany na PX_TAG
         _result:=0
      ?}
   ?}
?};
_result


\pxvaraddtxar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: po redakcji pola add_tx w px_var
::----------------------------------------------------------------------------------------------------------------------
1


\px_var_win_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Ustawia okno redagowania PX_VAR
::   WE: _a - "akronim okna"
::       _b - header
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')<>type_of('txt') || _b:='' ?};

_win_acr:=_a;
:: czy uzywac okien stalych z defa czy tymczasowych tworzonych ponizej
:: 1 - okna stale z defa
:: 2 - okna tymczasowe
_mode:=1;


{? _mode=1
||
:: Przeciazenie - funkcjonalnie system nie jest jeszcze gotowy na okno PX_GRP dlatego
:: zamiast niego uzywamy PX_GRP2
   {? _a='PX_GRP'
   || _win_acr:='PX_GRP2'
   ?};
   PX_VAR.win_edit(_win_acr);
   PX_VAR.hdr_edit(); PX_VAR.hdr_edit(_b)
||
   {? _a='PX_GRP'
   ||
      {? 0
      ||
         PX_VAR.win_edit('PX_GRP')
      ||
::       W przypadku koniecznosci modyfikacji okna poza definicja systemu:
         _red:=PX_VAR.mk_edit('|--|'+'Grupowe kolejkowanie obiektów'@,,'px_var_'+(-_a));
         PX_VAR.win_efld(_red,AH,'H');
         PX_VAR.win_efld(_red,,'ADD_DIR',,,,,,'Zwrot planowania'@,,,'radio-buttons',,
            'Wszystkie w przód'@,"1",
            'Wszystkie w tył'@,"-1",
            'Z obiektów źródłowych'@,"0"
         );
         PX_VAR.win_efld(_red,AH,'H');
         PX_VAR.win_efld(_red,,'AGR',,,,,,'Agregowanie pozycji'@,,,'radio-buttons',,
            'Agregowanie'@,"'T'",
            'Osobno'@,"'N'"
         );
         PX_VAR.win_efld(_red,AH,'H');
         PX_VAR.win_efld(_red,,'GRN_DATA',,,10,,,'Granica czasowa:'@);
         PX_VAR.win_efld(_red,,'GRN_TIME',,,8,,,,1);
         PX_VAR.win_efld(_red,AH,'H');
         PX_VAR.win_edit(_red);
         PX_VAR.win_ebtn(_red,'text=%1'['&Zapisz'@],'key:F2');
         PX_VAR.win_ebtn(_red,'text=%1'['&Anuluj'@],'key:Esc')
      ?}
   |? _a='ADD1'
   ||
      _red:=PX_VAR.mk_edit('Ręczne powoływanie planu'@,,'px_var_'+(-_a));
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_SYM',,,20,,1,'Symbol'@);
      PX_VAR.win_efld(_red,,'ADD_OPIS',,,40,,1,'Opis'@);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_IL',,,10,4,,'Ilość'@);
      PX_VAR.win_efld(_red,,'ADD_TX','SYMBOL','*',20,,,'Technologia'@);
      PX_VAR.win_efld(_red,PX_TEX,'VER',,,20,,1,'Wersja'@);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_DIR',,,,,,'Zwrot planowania'@,,,'radio-buttons',,
         'W przód'@,"1",
         'W tył'@,"-1"
      );
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'GRN_DATA',,,10,,,'Granica czasowa:'@);
      PX_VAR.win_efld(_red,,'GRN_TIME',,,8,,,,1);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_edit(_red);
      PX_VAR.win_ebtn(_red,'text=%1'['&Zapisz'@],'key:F2');
      PX_VAR.win_ebtn(_red,'text=%1'['&Anuluj'@],'key:Esc')
   |? _a='ADD2'
   ||
      _red:=PX_VAR.mk_edit('Ręczne powoływanie planu'@,,'px_var_'+(-_a));
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_SYM',,,20,,1,'Symbol'@);
      PX_VAR.win_efld(_red,,'ADD_OPIS',,,40,,1,'Opis'@);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_IL',,,10,4,,'Ilość'@);
      PX_VAR.win_efld(_red,,'ADD_TX','SYMBOL','*',20,,1,'Technologia'@);
      PX_VAR.win_efld(_red,PX_TEX,'VER',,,20,,1,'Wersja'@);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_DIR',,,,,1,'Zwrot planowania'@,,,'radio-buttons',,
         'W przód'@,"1",
         'W tył'@,"-1"
      );
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'GRN_DATA',,,10,,1,'Granica czasowa:'@);
      PX_VAR.win_efld(_red,,'GRN_TIME',,,8,,1,,1);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_edit(_red);
      PX_VAR.win_ebtn(_red,'text=%1'['&Zapisz'@],'key:F2');
      PX_VAR.win_ebtn(_red,'text=%1'['&Anuluj'@],'key:Esc')
   |? _a='RED'
   ||
      _red:=PX_VAR.mk_edit('Redagowanie pozycji kolejki'@,,'px_var_'+(-_a));
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_SYM',,,20,,1,'Symbol'@);
      PX_VAR.win_efld(_red,,'ADD_OPIS',,,40,,1,'Opis'@);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_IL',,,10,4,,'Ilość'@);
      PX_VAR.win_efld(_red,,'ADD_TX','SYMBOL','*',20,,1,'Technologia'@);
      PX_VAR.win_efld(_red,PX_TEX,'VER',,,20,,1,'Wersja'@);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_DIR',,,,,1,'Zwrot planowania'@,,,'radio-buttons',,
         'W przód'@,"1",
         'W tył'@,"-1"
      );
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'GRN_DATA',,,10,,1,'Granica czasowa:'@);
      PX_VAR.win_efld(_red,,'GRN_TIME',,,8,,1,,1);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_edit(_red);
      PX_VAR.win_ebtn(_red,'text=%1'['&Zapisz'@],'key:F2');
      PX_VAR.win_ebtn(_red,'text=%1'['&Anuluj'@],'key:Esc')
   |? _a='RED1'
   ||
:: Okno do redagowania grupy z jedna pozycja
      _red:=PX_VAR.mk_edit('Redagowanie węzła grupującego'@,,'px_var_'+(-_a));
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_SYM',,,20,,1,'Symbol'@);
      PX_VAR.win_efld(_red,,'ADD_OPIS',,,40,,1,'Opis'@);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_IL',,,10,4,1,'Ilość'@);
      PX_VAR.win_efld(_red,,'ADD_TX','SYMBOL','*',20,,0,'Technologia'@);
      PX_VAR.win_efld(_red,PX_TEX,'VER',,,20,,1,'Wersja'@);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_DIR',,,,,0,'Zwrot planowania'@,,,'radio-buttons',,
         'W przód'@,"1",
         'W tył'@,"-1"
      );
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'GRN_DATA',,,10,,0,'Granica czasowa:'@);
      PX_VAR.win_efld(_red,,'GRN_TIME',,,8,,0,,1);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_edit(_red);
      PX_VAR.win_ebtn(_red,'text=%1'['&Zapisz'@],'key:F2');
      PX_VAR.win_ebtn(_red,'text=%1'['&Anuluj'@],'key:Esc')
   |? _a='RED2'
   ||
:: Okno do redagowania grupy z kilkoma pozycjami (na te chwile tozsame z RED1)
      _red:=PX_VAR.mk_edit('Redagowanie węzła grupującego'@,,'px_var_'+(-_a));
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_SYM',,,20,,1,'Symbol'@);
      PX_VAR.win_efld(_red,,'ADD_OPIS',,,40,,1,'Opis'@);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_IL',,,10,4,1,'Ilość'@);
      PX_VAR.win_efld(_red,,'ADD_TX','SYMBOL','*',20,,0,'Technologia'@);
      PX_VAR.win_efld(_red,PX_TEX,'VER',,,20,,1,'Wersja'@);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'ADD_DIR',,,,,0,'Zwrot planowania'@,,,'radio-buttons',,
         'W przód'@,"1",
         'W tył'@,"-1"
      );
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_efld(_red,,'GRN_DATA',,,10,,0,'Granica czasowa:'@);
      PX_VAR.win_efld(_red,,'GRN_TIME',,,8,,0,,1);
      PX_VAR.win_efld(_red,AH,'H');
      PX_VAR.win_edit(_red);
      PX_VAR.win_ebtn(_red,'text=%1'['&Zapisz'@],'key:F2');
      PX_VAR.win_ebtn(_red,'text=%1'['&Anuluj'@],'key:Esc')
   |? _a='REDG'
   ||
:: Okno redagowania dla grupy zaznaczonych grup - tylko w defie
      ~~
   ?}
?};
~~


\status_rebuild
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Odtwarza status PX_GRP na podstawie statusu pozycji planu ktore naleza do danego PX_GRP
::   WE: _a - PX_GRP.ref()
::   WY: 0 - zguba
::       1 - zwyciestwo
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_grp:=_a;
_can_continue:=0;

PX_GRP.cntx_psh();
PX_POZ.cntx_psh();
PX_POZ.index('STATUS3');

PX_GRP.clear();
{? PX_GRP.seek(_grp)
||
   _old_status:=PX_GRP.STATUS;

:: 1. Resetuje status na normalny
   _can_continue:=exec('status_set','px_grp',PX_GRP.ref(),exec('status_normal','px_grp'));
   {? _can_continue>0
   ||
::    1. Status wykonane
      {? PX_GRP.STATUS=exec('status_normal','px_grp')
      ||
::       Sprawdzam ile jest wszystkich pozycji planu dla danego PX_GRP
         PX_POZ.prefix(PX_GRP.ref());
         _size_all:=PX_POZ.size();

         {? _size_all>0
         ||
::          Sprawdzam ile jest pozycji planu wykonanych w calosci dla danego PX_GRP
            PX_POZ.prefix(PX_GRP.ref(),exec('status_wyk2','px_poz'));
            _size_wyk2:=PX_POZ.size();

::          Jesli rozmiar wszystkich pozycji i pozycji wykonanych jest taki sam to znak ze
::          wszystkie sa wykonane wiec PX_GRP moze otrzymac status wykonanego w calosci
            {? _size_all=_size_wyk2
            || _can_continue:=exec('status_set','px_grp',PX_GRP.ref(),exec('status_wyk2','px_grp'))
            ?}
         ?}
      ?};
::    2. Status opoznione
      {? PX_GRP.STATUS=exec('status_normal','px_grp')
      ||
::       Sprawdzam czy sa jakiekolwiek opoznione pozycje planu dla danego PX_GRP
         PX_POZ.prefix(PX_GRP.ref(),exec('status_delay','px_poz'));
         {? PX_POZ.first()
         || _can_continue:=exec('status_set','px_grp',PX_GRP.ref(),exec('status_delay','px_grp'))
         ?}
      ?};
::    3. Status wykonywane
      {? PX_GRP.STATUS=exec('status_normal','px_grp')
      ||
::       Sprawdzam czy sa pozycje wykonywane
         PX_POZ.prefix(PX_GRP.ref(),exec('status_wyk1','px_poz'));
         {? PX_POZ.first()
         || _can_continue:=exec('status_set','px_grp',PX_GRP.ref(),exec('status_wyk1','px_grp'))
         ?};
::       Sprawdzam czy sa pozycje wykonane
         {? PX_GRP.STATUS=exec('status_normal','px_grp')
         ||
            PX_POZ.prefix(PX_GRP.ref(),exec('status_wyk2','px_poz'));
            {? PX_POZ.first()
            || _can_continue:=exec('status_set','px_grp',PX_GRP.ref(),exec('status_wyk1','px_grp'))
            ?}
         ?}
      ?};
::    Wszystkim grupom ktore zostaly sklonowane na podstawie tej ktora uaktualniam
::    nanosze uaktualniony status. Jest to konieczne w przypadku gdy status grupy
::    w wersji glownej sie zmienil, a ktos mial odpalona u siebie wersje tymczasowa
::    ktora dopiero po pewnym czasie przeliczy - w takim przypadku moga nie zostac
::    zaplanowane opoznienia
      _new_status:=PX_GRP.STATUS;
      {? _new_status<>_old_status
      ||
         PX_VER.cntx_psh();
         PX_GRP.cntx_psh();
         PX_GRP.index('UID_SRC2');
         PX_GRP.prefix(PX_GRP.UID);
         {? PX_GRP.first()
         || {!
            |?
               _ver_stat:=PX_GRP.PX_VER().STATUS;
               {? _ver_stat=exec('status_temp','px_ver') |
                  _ver_stat=exec('status_ready','px_ver')
               ||
                  {? PX_GRP.STATUS<>_new_status
                  || PX_GRP.STATUS:=_new_status;
                     _can_continue:=PX_GRP.put()
                  ?}
               ?};
               PX_GRP.next() & _can_continue>0
            !}
         ?};
         PX_VER.cntx_pop();
         PX_GRP.cntx_pop()
      ?};
      {? _can_continue>0
      ||
::       Aktualizacja pola REASON
         PX_GRP.get();
         PX_GRP.REASON:=exec('reason_plan','px_param');
         PX_POZ.index('REASON');
         PX_POZ.prefix(exec('reason_point','px_param'),PX_GRP.ref());
         {? PX_POZ.first()
         || PX_GRP.REASON:=exec('reason_point','px_param')
         ?};
         PX_POZ.prefix(exec('reason_grop','px_param'),PX_GRP.ref());
         {? PX_POZ.first()
         || PX_GRP.REASON:=exec('reason_grop','px_param')
         ?};
         PX_POZ.prefix(exec('reason_sur','px_param'),PX_GRP.ref());
         {? PX_POZ.first()
         || PX_GRP.REASON:=exec('reason_sur','px_param')
         ?};
         _can_continue:=PX_GRP.put()
      ?};
      ~~
   ?};
   {? _can_continue>0
   || _result:=1
   ?}
?};
PX_POZ.cntx_pop();
PX_GRP.cntx_pop();
_result


\px_poz_move
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Przepina w danej wersji pozycje planu o danym statusie z jednego PX_GRP do drugiego
::   WE: _a - PX_VER.ref() - wersja zrodlowa
::       _b - PX_VER.ref() - wersja docelowa
::       [_c] - STRING - o jakim statusie przepinane beda pozycje planu
::       [_d] - REAL - tm_stamp czasu ktory jest granica okreslajaca ze tylko ponizej tej granicy przepinam pozycje planu
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

_source:=_a;
_dest:=_b;
_status:='';
_time_border:=0;

{? var_pres('_c')=type_of('')
|| _status:=_c
?};
{? var_pres('_d')=type_of(0)
|| _time_border:=_d
?};

_can_continue:=1;

PX_GRP.cntx_psh();
PX_GRP.index('LP');
PX_GRP.prefix(_source);
{? PX_GRP.first()
|| {!
   |? _sour_grp:=PX_GRP.ref();
::    Szukam w wersji docelowej PX_GRP ktory powstal na podstawie biezacego PX_GRP
      PX_GRP.cntx_psh();
      PX_GRP.index('UID_SRC');
      PX_GRP.prefix(_dest,PX_GRP.UID);
      {? PX_GRP.first()
      || _can_continue:=exec('px_poz_grp_move','px_poz',_sour_grp,PX_GRP.ref(),_status,_time_border)
      ?};
      PX_GRP.cntx_pop();
      PX_GRP.next() & _can_continue>0
   !}
?};
{? _can_continue>0
|| _result:=1
?};
PX_GRP.cntx_pop();
_result


\px_poz_today_mv
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Przepina w danej wersji pozycje planu na biezacym pojemniku z jednego PX_GRP do drugiego
::   WE: _a - PX_VER.ref() - wersja zrodlowa
::       _b - PX_VER.ref() - wersja docelowa
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

_source:=_a;
_dest:=_b;
_can_continue:=1;

PX_GRP.cntx_psh();
PX_GRP.index('LP');
PX_GRP.prefix(_source);
{? PX_GRP.first()
|| {!
   |? _sour_grp:=PX_GRP.ref();
::    Szukam w wersji docelowej PX_GRP ktory powstal na podstawie biezacego PX_GRP
      PX_GRP.cntx_psh();
      PX_GRP.index('UID_SRC');
      PX_GRP.prefix(_dest,PX_GRP.UID);
      {? PX_GRP.first()
      || _can_continue:=exec('today_move','px_poz',_sour_grp,PX_GRP.ref())
      ?};
      PX_GRP.cntx_pop();
      PX_GRP.next() & _can_continue>0
   !}
?};
{? _can_continue>0
|| _result:=1
?};
PX_GRP.cntx_pop();
_result


\px_grp_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wyswietlenie danych grupy lub obiektu planistycznego
::----------------------------------------------------------------------------------------------------------------------
_tab:=
   {? exec('is_one_version','px_param')
   || exec('tab','px_grps')
   || {? var_pres('Pxgrp1',PxSelect) || PxSelect.Pxgrp1.TAB || PxSelect.Pxgrp.TAB ?}
   ?};
PX_GRP.clear();
{? PX_GRP.seek(_tab.PX_GRPI,8+_tab.PX_GRPI)
|| {? _tab.PX_OBJ=''
   || {? PX_GRP.GROPS<>null()
      || PX_GRP.GROPS().PL_RES();
         PX_GRP.win_edit('RED_G')
      ||
         {? exec('is_one_version','px_param') & _tab.PX_SET<>''
         || PX_GRP.win_edit('RED1')
         || PX_GRP.win_edit('RED')
         ?}
      ?};
      PX_GRP.display()
   || PX_OBJ.cntx_psh();
      PX_OBJ.clear();
      {? PX_OBJ.seek(_tab.PX_OBJ,8+_tab.PX_OBJ)
      || D_HELP.M_ZKP:=PX_OBJ.M().KTM;
         {? PX_OBJ.ZK_N<>null() || ZK_N.use(ref_name(PX_OBJ.ZK_N)) ?};
         {? PX_OBJ.ZK_P<>null() || ZK_P.use(ref_name(PX_OBJ.ZK_P)) ?};
         PX_OBJ.win_edit('RED');
         PX_OBJ.display()
      ?};
      PX_OBJ.cntx_pop()
   ?}
?};
~~


\go_obj_date
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Przechodzi do pojemnika w kontenetrze widokowym zgodnego z data graniczna obiektu (do wyboru)
::----------------------------------------------------------------------------------------------------------------------
_start:=date(2999,0,0);
_stop:=date(0,0,0);
_ok:=0;

_dla:='';

_Tab:={? exec('is_one_version','px_param') || exec('tab','px_grps') || PxSelect.Pxgrp.TAB ?};

{? _Tab.PX_OBJ<>''
||
   _dla:='obiektu';
   PX_POZ.index('TM_VOBJ');
   PX_POZ.prefix(PX_VAR.VIE_VER,BIT.sqlint(_Tab.PX_OBJ));
   {? PX_POZ.first()
   || _start:=exec('str2date','#convert',10+tm_form(PX_POZ.TM_START));
      _ok:=1;
      {? PX_POZ.last()
      || _stop:=exec('str2date','#convert',10+tm_form(PX_POZ.TM_START))
      ?}
   ?}
||
   _dla:='grupy';
   Cntx.psh(PX_OBJ,PX_POZ);
   PX_GRP.clear();
   {? PX_GRP.seek(_Tab.PX_GRPI,8+_Tab.PX_GRPI)
   ||
      _prefix_mode:=exec('poz_prefix_mode','px_grp');
      {? _prefix_mode='SOURCE'
      || PX_GRP.index('UID');
         PX_GRP.prefix(PX_GRP.UID_SRC);
         {? PX_GRP.first()
         ||
            PX_POZ.index('TM_GRP');
            PX_POZ.prefix(PX_GRP.ref());
            {? PX_POZ.first()
            || _ok:=1;
               _tm_start:=exec('str2date','#convert',10+tm_form(PX_POZ.TM_START));
               {? _tm_start<_start || _start:=_tm_start ?};
               {? PX_POZ.last()
               || _tm_end:=exec('str2date','#convert',10+tm_form(PX_POZ.TM_START));
                  {? _tm_end>_stop || _stop:=_tm_end ?}
               ?}
            ?}
         ?}
      || PX_POZ.index('TM_GRP');
         PX_POZ.prefix(PX_GRP.ref());
         {? PX_POZ.first()
         || _ok:=1;
            _tm_start:=exec('str2date','#convert',10+tm_form(PX_POZ.TM_START));
            {? _tm_start<_start || _start:=_tm_start ?};
            {? PX_POZ.last()
            || _tm_end:=exec('str2date','#convert',10+tm_form(PX_POZ.TM_START));
               {? _tm_end>_stop || _stop:=_tm_end ?}
            ?}
         ?}
      ?}
   ?};
   Cntx.pop(PX_OBJ,PX_POZ)
?};
{? _ok
||
   _choice:=FUN.choice(
      'Przejście w planie do daty zgodnej z:\n\n'
      '• pierwszą pozycją planu dla %1 — %2 (początek)\n'
      '• ostatnią pozycją planu dla %1 — %3 (koniec)'@[_dla,$_start,$_stop]
      ,,'Początek'@,'Koniec'@
   )
||
   FUN.info('Brak pozycji planu.'@);
   _choice:=0
?};

{? _choice>0
||
   exec('go_cup_date','px_plan',{? _choice=1 || _start || _stop ?});
:: Komunikaty bledow wylaczone, aby uniknac zbednego sprawdzania, czy jest dostepne okno grupowe
   _msg:=no_msg(1);
   grp_disp(PX_KONT,{? exec('tree_kont','px_param') || 'PX_WERT' || 'PX_WER' ?},1);
   {? var_pres('PxSelect')>100
   || grp_disp(PxSelect.Tab_OBJ.TAB,PxSelect.Tab_OBJ.WER,1,1);
      grp_disp(PxSelect.Tab_KONT.TAB,PxSelect.Tab_KONT.WER,1,1)
   ?};
   no_msg(_msg)
?};
~~


\px_que_ctr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Sprawdza kolejke, czy nadaje sie do akceptacji (czy wszystkie grupy maja technologie)
::   WE: _a - PX_VER.ref()
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_ok:=1;
PX_GRP.cntx_psh();
PX_GRP.index('LP');
PX_GRP.prefix(_a,'Z');
{? PX_GRP.first()
|| {!
   |?
      {? PX_GRP.PX_TEX=null() || _ok:=0 ?};
      PX_GRP.next()
   !}
?};
PX_GRP.cntx_pop();
{? _ok=0
|| _choice:=FUN.choice(
      'Nie przypisano technologii do wszystkich elementów kolejki planu.\n'
      'Akceptacja kolejki niemożliwa.'@,,
      'Szczegóły'@,,,,'Ok'@
   );
   {? _choice=1
   || _tab:=tab_tmp(2,
         'SYMBOL','STRING[60]','Symbol'@,
         'NAZWA','STRING[100]','Nazwa'@,
         'ILOSC','REAL','Ilość'@
      );
      _wer:=_tab.mk_sel('Grupy bez technologii'@,,,'grupybeztech');
      _tab.win_fld(_wer,,'SYMBOL',,,20);
      _tab.win_fld(_wer,,'NAZWA',,,40);
      _tab.win_fld(_wer,,'ILOSC',,,15,4);
      _tab.win_sel(_wer);
      PX_GRP.cntx_psh();
      PX_GRP.index('LP');
      PX_GRP.prefix(_a);
      {? PX_GRP.first()
      || {!
         |?
            {? PX_GRP.PX_TEX=null()
            || _tab.SYMBOL:=PX_GRP.SYMBOL;
               _tab.NAZWA:=PX_GRP.NAZWA;
               _tab.ILOSC:=PX_GRP.ILOSC;
               _tab.add()
            ?};
            PX_GRP.next()
         !}
      ?};
      PX_GRP.cntx_pop();
      _tab.select()
   ?}
?};
_ok


\scal_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Scala PX_CONNy dla wskazanej w oknie grupy obiektow w kolejce
::   WY: STRING - string sterujacy menu uzytkownika lub ''
::----------------------------------------------------------------------------------------------------------------------
_result:='';

_one_ver:=exec('is_one_version','px_param');

_px_grp:={? _one_ver || $PX_GRPS.PX_GRP || PxSelect.Pxgrp.TAB.PX_GRPI ?};

PX_GRP.clear();
{? PX_GRP.seek(_px_grp,8+_px_grp)
|| {? exec('is_blocked','px_grp')>0
   || FUN.emsg('Nie można scalić wystąpień tych samych obiektów w bieżacej grupie — grupa jest zablokowana.'@)
   |? PX_GRP.STATUS=exec('status_wyk1','px_grp')
   || FUN.emsg('Nie można scalić wystąpień tych samych obiektów w bieżacej grupie — grupa jest wykonywana.'@)
   |? PX_GRP.STATUS=exec('status_wyk2','px_grp')
   || FUN.emsg('Nie można scalić wystąpień tych samych obiektów w bieżacej grupie — grupa jest wykonana w całości.'@)
   |? FUN.ask('Czy scalić wystąpienia tych samych obiektów w bieżącej grupie?'@)
   || _ref:=PxSelect.Pxgrp.TAB.ref();
      {? exec('scaltesameobj','px_grp',PX_GRP.ref())>0
      || {? ~_one_ver
         || exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp);
            PxSelect.Pxgrp.TAB.seek(_ref)
         ?};
         _result:='#CLOSE#'
      ?}
   ?}
?};
_result


\scaltesameobj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Scala PX_CONNy dla podanego PX_GRP, tak by dla jednego PX_OBJ byl tylko jeden PX_CONN
::       wykorzytywane przy planowaniu zadan projektowych w exec('pck_projecttask','px_whisk')
::   WE: _a - PX_GRP.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_PX_GRP:=_a;
PX_GRP.cntx_psh(); PX_GRP.clear();
PX_CONN.cntx_psh(); PX_CONN.clear();

_result:=0;
_can_continue:=1;

{? exec('lock','px_grp',_PX_GRP)>0
||
   _ndx:=PX_CONN.ndx_tmp(,
                        ,'PX_GRP',,
                        ,'PX_OBJ',,
                        ,'LP_GRP',,
                        );
   PX_CONN.index(_ndx);
   PX_CONN.prefix(_PX_GRP);
   {? PX_CONN.first()
   || _lastobj:=null();
      _lastconn:=null();
      _sumil:=0;
::    pomocnicza formulka (by jej nie kopujwklejac)
      _update:="
                  PX_CONN.cntx_psh(); PX_CONN.clear();
                  {? PX_CONN.seek(_a)
                  || PX_CONN.ILOSC+=_b;
                     PX_CONN.put()
                  ?};
                  PX_CONN.cntx_pop();
                  ~~
               ";
::    petelka po PX_CONNach
      {!
      |? {? _lastobj<>PX_CONN.PX_OBJ
         || {? _sumil>0 || _update(_lastconn,_sumil) ?};
            _lastconn:=PX_CONN.ref();
            _lastobj:=PX_CONN.PX_OBJ;
            _sumil:=0

         |? _lastobj=PX_CONN.PX_OBJ
         || _sumil+=PX_CONN.ILOSC;
            PX_CONN.ILOSC:=0;
            PX_CONN.put()
         ?};
         PX_CONN.next()
      !};
      {? _sumil>0 || _update(_lastconn,_sumil) ?};
::    teraz nastapi wycinka PX_CONNow, ktore maja ilosc=0 z jednoczesnym przenumerowaniem
      PX_CONN.index('PX_GRP');
      PX_CONN.prefix(_PX_GRP);
      {? PX_CONN.first()
      ||
         _lp:=0;
         _lista:='#';
         _can_continue:=1;
         {!
         |?
            _next:=0;
            _next_con:=null();

            PX_CONN.cntx_psh();
::          Zapamietuje ref nastepnego
            {? PX_CONN.next()
            || _next_con:=PX_CONN.ref()
            ?};
            PX_CONN.cntx_pop();

            {? PX_CONN.ILOSC>0
            || {? _lista*('#'+($#PX_CONN.ref())+'#')=0
               ||
                  _lista+=$#PX_CONN.ref()+'#';
                  _lp+=1;
                  PX_CONN.LP_GRP:=_lp;
                  _can_continue:=PX_CONN.put()
               ?};
               PX_CONN.next()
            || _can_continue:=exec('delete','px_conn',PX_CONN.ref())
            ?};

            {? _next_con<>null()
            || _next:=PX_CONN.seek(_next_con)
            ?};
            _next>0 & _can_continue>0
         !}
      ?}
   ?};
   exec('unlock','px_grp',_PX_GRP);
   PX_CONN.ndx_drop(_ndx)
|| _can_continue:=0
?};
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\queue_copy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Kopiuje kolejke tymczasowa
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy utworzyć kopię kolejki planu?'@)
||
:: Utworzenie wersji planu dla kopii kolejki
   PX_VAR.VER_QUE:=PxSelect.VER_QUE;
   PX_VER.cntx_psh();
   _ok:=exec('px_ver_add','px_ver', exec('symbol_copy','px_ver'),
                                    PX_VAR.VER_QUE().STARTD().DATA,
                                    PX_VAR.VER_QUE().STARTT,
                                    PX_VAR.VER_QUE().ENDD().DATA,
                                    PX_VAR.VER_QUE().ENDT,
                                    0,
                                    exec('status_que_copy','px_ver')
                                    );

:: Jezeli udalo sie powolac wersje, to klonuje kolejke z wersji tymczasowej do kopii kolejki
   {? _ok
   ||
      exec('clone_all','px_grp',PX_VAR.VER_QUE,PX_VER.ref(),,,,0);
      FUN.info('Utworzono kopię kolejki planu.\n\nIdentyfikator: %1'@[PX_VER.SYMBOL])
   ?};
   PX_VER.cntx_pop();
   ~~
?};
~~


\queue_cmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Porownuje kolejke tymczasowa z kopia kolejki
::----------------------------------------------------------------------------------------------------------------------
:: Wyswietlenie wersji planu dla kopii kolejek biezacego uzytkownika
PX_VER.cntx_psh();
PX_VER.index('USER_ADD');
PX_VER.prefix(OPERATOR.USER,exec('status_que_copy','px_ver'));
_wer:=PX_VER.mk_sel('Kopie kolejki'@,'P',0,'queue_copy',,,,,'U');
PX_VER.win_fld(_wer,,'SYMBOL',,,50,,,'Kolejka'@);
PX_VER.win_fld(_wer,,'ADD_DATE');
PX_VER.win_fld(_wer,,'ADD_TIME');
PX_VER.win_act(_wer,,'Formuła','&Usuń'@@,,,"exec('delete','px_ver',PX_VER.ref())",,,,,,'U');
task_attach('TPP_PPS_DPLA');
PX_VER.win_act(_wer,,'Formuła','K&olejka'@@,,'Wyświetla wybraną kolejkę'@,"exec('queue_select','px_grp')",,1,,,,'O');
PX_VER.win_act(_wer,,'Formuła','Po&równaj'@@,,'Porównanie kopii kolejki z wersją główną'@,"exec('queue_cmp_act','px_grp')",,,,,,'R');
PX_VER.win_sel(_wer);
PX_VER.select();
PX_VER.cntx_pop();
~~


\queue_merge
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Przywraca kopie kolejki
::----------------------------------------------------------------------------------------------------------------------
:: Wyswietlenie wersji planu dla kopii kolejek biezacego uzytkownika
_ok:=0;

PX_VAR.VER_QUE:=PxSelect.VER_QUE;

PX_VER.cntx_psh();
PX_VER.index('USER_ADD');
PX_VER.prefix(OPERATOR.USER,exec('status_que_copy','px_ver'));
_wer:=PX_VER.mk_sel('Kopie kolejki'@,'P',0,'queue_tomerge',,,,,'U');
PX_VER.win_fld(_wer,,'SYMBOL',,,50,,,'Kolejka'@);
PX_VER.win_fld(_wer,,'ADD_DATE');
PX_VER.win_fld(_wer,,'ADD_TIME');
_fb:="
   _can_continue:=0;
   {? exec('lock','px_ver',PX_VER.ref(),1)
   || _can_continue:=1;
      {? exec('is_one_version','px_param')
      ||
::       Jesli praca na jednej wersji to staram sie blokowac wszystkie elementy kolejki docelowej
::       na czas scalania
         _can_continue:=exec('lock_queue','px_ver',PX_VAR.VER_QUE)
      ?}
   ?};
   {? _can_continue>0
   || sel_exit()
   ?}
";
PX_VER.win_act(_wer,,'Formuła','Wybierz'@@,,,_fb,,1);
PX_VER.win_act(_wer,,'Formuła','K&olejka'@@,,'Wyświetla wybraną kolejkę'@,"exec('queue_select','px_grp')",,,,,,'O');
PX_VER.win_sel(_wer);
{? PX_VER.select()
||
   {? FUN.ask(
         'Czy zastąpić kolejkę roboczą wybraną kopią kolejki?\n\n'
         'Uwaga: kopia kolejki może nie zawierać wykonanych obiektów,\n'
         'wtedy po przeliczeniu planu wykonania te zostaną usunięte.'@
      )
   ||
::    Przeniesienie kopii do pustej kolejki roboczej, klonowanie kolejki z kopiii do wersji tymczasowej
      _ok:=exec('clone_all','px_grp',PX_VER.ref(),PX_VAR.VER_QUE)
   ?};
   exec('unlock','px_ver',PX_VER.ref());
   {? exec('is_one_version','px_param')
   ||
::    Jesli praca na jednej wersji to odblokowuje wszystkie elementy kolejki docelowej
      _can_continue:=exec('unlock_queue','px_ver',PX_VAR.VER_QUE)
   ?}
?};
PX_VER.cntx_pop();

{? _ok
||
:: Przeladowanie widoku
   PxSelect.Pxgrp.load();
   PxSelect.Pxgrp.update()
?};
~~


\queue_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Selekcja kopii kolejki
::----------------------------------------------------------------------------------------------------------------------
_ver_que:=PX_VAR.VER_QUE;
_delete:="
   {? var_pres('Pxgrp1',PxSelect)>0 || obj_del(PxSelect.Pxgrp1) ?}
";
_delete();

PxSelect.VER_QUE1:=PX_VER.ref();
exec('px_grp_tmp','px_grp',1);

:: Wylaczenie niepotrzebnych akcji
PxSelect.Pxgrp1.TAB.actions(PxSelect.Pxgrp1.WERT,'MDPUOTBKACZGRF:GFMDZ');

{? exec('lock','px_ver',PxSelect.VER_QUE1,1)
||
   PxSelect.Pxgrp1.TAB.select();
   exec('unlock','px_ver',PxSelect.VER_QUE1)
?};

_delete();
PX_VAR.VER_QUE:=_ver_que;
~~


\queue_cmp_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wlasciwa akcja wyswietlajaca porownanie dwoch kolejek
::----------------------------------------------------------------------------------------------------------------------
_edit:=PX_VAR.EDIT;
PX_VAR.EDIT:=0;
:: wylaczenie dnd w oknie glownej kolejki
PxSelect.Pxgrp.TAB.dnd_sel(PxSelect.Pxgrp.WERT,,'records.#tree_wert',"");

_delete:="
   {? var_pres('Pxgrp1',PxSelect)>0 || obj_del(PxSelect.Pxgrp1) ?};
   {? var_pres('QueCmp',PxSelect)>0 || obj_del(PxSelect.QueCmp) ?}
";
_delete();
exec('clear_diff_tab','px_grp',PxSelect.Pxgrp.TAB);

PxSelect.VER_QUE1:=PX_VER.ref();
exec('px_grp_tmp','px_grp',1);
exec('que_cmp_create','px_grp');
exec('gen_diff','px_grp');

_before:="
   grp_disp(PxSelect.Pxgrp1.TAB,PxSelect.Pxgrp1.WERT);
   grp_disp(PxSelect.QueCmp.TAB,PxSelect.QueCmp.WER)
";
_grp:=PxSelect.Pxgrp.TAB.grp_make('Porównanie kolejek planu'@,_before,'queue_cmp_act');
PxSelect.Pxgrp.TAB.grp_sel(_grp,,PxSelect.Pxgrp.WERT,,,,,,,,,,'maximized_with_title');
PxSelect.Pxgrp.TAB.win_sel(_grp);
PxSelect.Pxgrp.TAB.grp_splt(_grp,,'vertical','kopia');
PxSelect.Pxgrp.TAB.grp_sel(_grp,PxSelect.Pxgrp1.TAB,PxSelect.Pxgrp1.WERT,,,,,,,,,,'maximized_with_title');
PxSelect.Pxgrp.TAB.grp_splt(_grp,,'horizontal','cmp',20);
PxSelect.Pxgrp.TAB.grp_sel(_grp,PxSelect.QueCmp.TAB,PxSelect.QueCmp.WER,,,,,,,,,,'maximized_with_title');

:: Wylaczenie niepotrzebnych akcji
PxSelect.Pxgrp.TAB.actions(PxSelect.Pxgrp.WERT,'MDPUOTBKACZRGF:GFMDZ');
PxSelect.Pxgrp1.TAB.actions(PxSelect.Pxgrp1.WERT,'MDPUOTBKACZRGF:GFMDZ');

:: Selekcja okna z dwoma kolejkami
{? exec('lock','px_ver',PxSelect.VER_QUE1,1)
||
   PxSelect.Pxgrp.TAB.select();
   exec('unlock','px_ver',PxSelect.VER_QUE1)
?};

:: Przywrocenie akcji
PxSelect.Pxgrp.TAB.actions(PxSelect.Pxgrp.WERT,'DZ:DZ');

:: Przywrocenie standardowego okna selekcji kolejki
PxSelect.Pxgrp.TAB.win_sel(PxSelect.Pxgrp.WERT);

exec('clear_diff_tab','px_grp',PxSelect.Pxgrp.TAB);
PX_VAR.EDIT:=_edit;
{? PX_VAR.EDIT
||
:: ponowne wlaczenie dnd w oknie glownej kolejki
   PxSelect.Pxgrp.TAB.dnd_sel(PxSelect.Pxgrp.WERT,,'records.#tree_wert',"exec('dnd_renum','px_grp')")
?};
_delete();
~~


\que_cmp_create
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Tworzy strukture obslugujaca porownanie kolejek
:: ~OST: INWINBTN
::----------------------------------------------------------------------------------------------------------------------
PxSelect.QueCmp:=obj_new('TAB','WER','NDX_SYM','NDX_REF');
PxSelect.QueCmp.TAB:=tab_tmp(1,
   'OBJ_SYM','STRING[60]','Symbol obiektu'@,
   'OBJ_NAZ','STRING[255]','Nazwa obiektu'@,
   'PX_OBJ','STRING[16]','$PX_OBJ.ref()',
   'TEX_SYM','STRING[50]','Symbol przepisu'@,
   'TEX_REF','STRING[16]','$PX_TEX.ref()',
   'TEX1_SYM','STRING[50]','Symbol przepisu'@,
   'TEX1_REF','STRING[16]','$PX_TEX.ref()',
   'IL','REAL','Ilość w kolejce'@,
   'IL1','REAL','Ilość w kopii'@,
   'ROZNICA','REAL','Różnica'@,
   'STATUS','STRING[20]','Status w kolejce'@,
   'STATUS1','STRING[20]','Status w kopii'@,
   'CMP','STRING[1]','Znacznik porównania'@
);
PxSelect.QueCmp.NDX_SYM:=PxSelect.QueCmp.TAB.index('?');
PxSelect.QueCmp.NDX_REF:=PxSelect.QueCmp.TAB.ndx_tmp(,,'PX_OBJ',,);

PxSelect.QueCmp.TAB.fld_fml('IL','DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
PxSelect.QueCmp.TAB.fld_fml('IL','BEFORE_DISPLAY',"{? fld()=0 || exec('findfnv','#color') || ~~ ?}");
PxSelect.QueCmp.TAB.fld_fml('TEX_SYM','DISPLAY_FORMAT',"{? cur_tab(1,1).IL=0 || 'empty=1' || 'empty=0' ?}");
PxSelect.QueCmp.TAB.fld_fml('TEX_SYM','BEFORE_DISPLAY',"{? cur_tab(1,1).IL=0 || exec('findfnv','#color') || ~~ ?}");
PxSelect.QueCmp.TAB.fld_fml('CMP','DISPLAY_FORMAT',"'alignment=center'");
PxSelect.QueCmp.TAB.fld_fml('IL1','DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
PxSelect.QueCmp.TAB.fld_fml('IL1','BEFORE_DISPLAY',"{? fld()=0 || exec('findfnv','#color') || ~~ ?}");
PxSelect.QueCmp.TAB.fld_fml('TEX1_SYM','DISPLAY_FORMAT',"{? cur_tab(1,1).IL1=0 || 'empty=1' || 'empty=0' ?}");
PxSelect.QueCmp.TAB.fld_fml('TEX1_SYM','BEFORE_DISPLAY',"{? cur_tab(1,1).IL1=0 || exec('findfnv','#color') || ~~ ?}");
PxSelect.QueCmp.TAB.fld_fml('STATUS','DISPLAY_FORMAT',"{? cur_tab(1,1).IL1=0 || 'empty=1' || 'empty=0' ?}");
PxSelect.QueCmp.TAB.fld_fml('STATUS1','BEFORE_DISPLAY',"{? cur_tab(1,1).IL1=0 || exec('findfnv','#color') || ~~ ?}");
PxSelect.QueCmp.TAB.fld_fml('ROZNICA','DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");

PxSelect.QueCmp.WER:=PxSelect.QueCmp.TAB.mk_sel('Porównanie'@,,0,'quecmp_wer',1,,,,'P',,,,1);
PxSelect.QueCmp.TAB.win_fld(PxSelect.QueCmp.WER,,'OBJ_SYM',,,20,,,'Obiekt'@);
PxSelect.QueCmp.TAB.win_fld(PxSelect.QueCmp.WER,AH,'H',,,,,,,1);
PxSelect.QueCmp.TAB.win_fld(PxSelect.QueCmp.WER,,'IL',,,15,,,'Ilość'@);
PxSelect.QueCmp.TAB.win_fld(PxSelect.QueCmp.WER,,'TEX_SYM',,,20,,,'Przepis'@);
PxSelect.QueCmp.TAB.win_fld(PxSelect.QueCmp.WER,AH,'H',,,,,,,1);
PxSelect.QueCmp.TAB.win_fld(PxSelect.QueCmp.WER,,'CMP',,,2,,,'↔');
PxSelect.QueCmp.TAB.win_fld(PxSelect.QueCmp.WER,AH,'H',,,,,,,1);
PxSelect.QueCmp.TAB.win_fld(PxSelect.QueCmp.WER,,'IL1',,,15,,,'Ilość'@);
PxSelect.QueCmp.TAB.win_fld(PxSelect.QueCmp.WER,,'TEX1_SYM',,,20,,,'Przepis'@);
PxSelect.QueCmp.TAB.win_fld(PxSelect.QueCmp.WER,AH,'H',,,,,,,1);
PxSelect.QueCmp.TAB.win_fld(PxSelect.QueCmp.WER,,'ROZNICA',,,15,,,'Różnica'@);

:: Akcje
_formula:="exec('legenda','color','#PX_GRP#02','@PX_GRP#TXT#WIN#')";
PxSelect.QueCmp.TAB.win_act(PxSelect.QueCmp.WER,,'Formuła','&Legenda'@@,,,_formula,,,,,,'L');
PxSelect.QueCmp.TAB.win_act(PxSelect.QueCmp.WER,0,'Rekord',,,,"exec('que_cmp_rkprz','px_grp')");

:: Ikony
_formula:="
   _status:=cur_tab(1,1).STATUS;
   {? _status=exec('status_wyk1','px_grp')
   || 'xwin16.png:72'
   |? _status=exec('status_wyk2','px_grp')
   || 'xwin16.png:62'
   || ''
   ?}
";
PxSelect.QueCmp.TAB.win_fml(PxSelect.QueCmp.WER,,'IL',,'ICON_BEFORE',_formula);
_formula:="
   _status:=cur_tab(1,1).STATUS1;
   {? _status=exec('status_wyk1','px_grp')
   || 'xwin16.png:72'
   |? _status=exec('status_wyk2','px_grp')
   || 'xwin16.png:62'
   || ''
   ?}
";
PxSelect.QueCmp.TAB.win_fml(PxSelect.QueCmp.WER,,'IL1',,'ICON_BEFORE',_formula);

:: Przyciski

_btn_lft:=PxSelect.QueCmp.TAB.win_btn(
   PxSelect.QueCmp.WER,'btn_label_align=left,text=→ %1'['L&ewe'@],'Formuła',"exec('filter_diff','px_grp','→')"
);
PxSelect.QueCmp.TAB.btn_sopt(PxSelect.QueCmp.WER,_btn_lft,'tooltip=%1'['Filtr — obiekty występujące tylko w kolejce głównej'@]);

_btn_rgh:=PxSelect.QueCmp.TAB.win_btn(
   PxSelect.QueCmp.WER,'btn_label_align=left,text=← %1'['Prawe'@],'Formuła',"exec('filter_diff','px_grp','←')"
);
PxSelect.QueCmp.TAB.btn_sopt(PxSelect.QueCmp.WER,_btn_rgh,'tooltip=%1'['Filtr — obiekty występujące tylko w kopii kolejki'@]);

_btn_equ:=PxSelect.QueCmp.TAB.win_btn(
   PxSelect.QueCmp.WER,'btn_label_align=left,text== %1'['Równe'@],'Formuła',"exec('filter_diff','px_grp','=')"
);
PxSelect.QueCmp.TAB.btn_sopt(PxSelect.QueCmp.WER,_btn_equ,'tooltip=%1'['Filtr — obiekty zgodne w kolejce głównej i kopii'@]);

_btn_neq:=PxSelect.QueCmp.TAB.win_btn(
   PxSelect.QueCmp.WER,'btn_label_align=left,text=≠ %1'['Nierówne'@],'Formuła',"exec('filter_diff','px_grp','≠')"
);
PxSelect.QueCmp.TAB.btn_sopt(PxSelect.QueCmp.WER,_btn_neq,'tooltip=%1'['Filtr — obiekty niezgodne w kolejce głównej i kopii'@]);

_btn_all:=PxSelect.QueCmp.TAB.win_btn(
   PxSelect.QueCmp.WER,'btn_label_align=left,text=%1'['Wszystkie'@],'Formuła',"PxSelect.QueCmp.TAB.f_clear()"
);
PxSelect.QueCmp.TAB.btn_sopt(PxSelect.QueCmp.WER,_btn_all,'tooltip=%1'['Filtr — wszystkie obiekty'@]);
~~


\que_cmp_rkprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Rekord przed w oknie porownywania kolejek
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
{? _tab.CMP='='
|| exec('flddisp','color','PX_GRP#TXT#WIN#01')
|? _tab.CMP='≠'
|| exec('flddisp','color','PX_GRP#TXT#WIN#02')
|? _tab.CMP='←'
|| exec('flddisp','color','PX_GRP#TXT#WIN#03')
|? _tab.CMP='→'
|| exec('flddisp','color','PX_GRP#TXT#WIN#04')
|| ~~
?}


\que_cmp_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Dodaje (albo aktualizuje) rekord w tabeli z porownaniem kolejek
::   WE: _a - PX_OBJ.ref()
::       _b - PX_TEX.ref()
::       _c - dane oryginalu (0), czy kopii (1)
::       _d - ilosc
::       _e - status
::----------------------------------------------------------------------------------------------------------------------
_px_obj:=_a;
_px_tex:=_b;
_kopia:=_c;
_ilosc:=_d;
_status:=_e;

PxSelect.QueCmp.TAB.index(PxSelect.QueCmp.NDX_REF);
PxSelect.QueCmp.TAB.prefix($_px_obj);
{? PxSelect.QueCmp.TAB.first()
||
   {? _kopia
   || {? PxSelect.QueCmp.TAB.TEX1_REF<>'' & $_px_tex<>PxSelect.QueCmp.TAB.TEX1_REF
      || PxSelect.QueCmp.TAB.TEX1_REF:=''; PxSelect.QueCmp.TAB.TEX1_SYM:='< kilka przepisów >'
      |? PxSelect.QueCmp.TAB.TEX1_REF=''
      || PxSelect.QueCmp.TAB.TEX1_REF:=$_px_tex;
         PX_TEX.cntx_psh();
         PX_TEX.clear();
         {? PX_TEX.seek(_px_tex)
         || PxSelect.QueCmp.TAB.TEX1_SYM:=PX_TEX.SYMBOL
         ?};
         PX_TEX.cntx_pop()
      ?};
      {? PxSelect.QueCmp.TAB.STATUS1<>'' & _status=exec('status_wyk1','px_grp')
      || PxSelect.QueCmp.TAB.STATUS1=exec('status_wyk1','px_grp')
      |? PxSelect.QueCmp.TAB.STATUS1<>exec('status_wyk2','px_grp') & _status=exec('status_wyk2','px_grp')
      || PxSelect.QueCmp.TAB.STATUS1:=exec('status_wyk1','px_grp')
      || PxSelect.QueCmp.TAB.STATUS1:=_status
      ?}
   || {? PxSelect.QueCmp.TAB.TEX_REF<>'' & $_px_tex<>PxSelect.QueCmp.TAB.TEX_REF
      || PxSelect.QueCmp.TAB.TEX_REF:=''; PxSelect.QueCmp.TAB.TEX_SYM:='< kilka przepisów >'
      |? PxSelect.QueCmp.TAB.TEX_REF=''
      || PxSelect.QueCmp.TAB.TEX_REF:=$_px_tex;
         PX_TEX.cntx_psh();
         PX_TEX.clear();
         {? PX_TEX.seek(_px_tex)
         || PxSelect.QueCmp.TAB.TEX_SYM:=PX_TEX.SYMBOL
         ?};
         PX_TEX.cntx_pop()
      ?};
      {? PxSelect.QueCmp.TAB.STATUS<>'' & _status=exec('status_wyk1','px_grp')
      || PxSelect.QueCmp.TAB.STATUS=exec('status_wyk1','px_grp')
      |? PxSelect.QueCmp.TAB.STATUS<>exec('status_wyk2','px_grp') & _status=exec('status_wyk2','px_grp')
      || PxSelect.QueCmp.TAB.STATUS:=exec('status_wyk1','px_grp')
      || PxSelect.QueCmp.TAB.STATUS:=_status
      ?}
   ?};

   {? _kopia || PxSelect.QueCmp.TAB.IL1+=_ilosc || PxSelect.QueCmp.TAB.IL+=_ilosc ?};
   PxSelect.QueCmp.TAB.put()
||
   PxSelect.QueCmp.TAB.blank();

   PxSelect.QueCmp.TAB.PX_OBJ:=$_px_obj;
   PX_OBJ.cntx_psh();
   PX_OBJ.clear();
   {? PX_OBJ.seek(_px_obj)
   ||
      PxSelect.QueCmp.TAB.OBJ_SYM:=PX_OBJ.SYMBOL;
      PxSelect.QueCmp.TAB.OBJ_NAZ:=PX_OBJ.NAZWA
   ?};
   PX_OBJ.cntx_pop();

   {? _kopia || PxSelect.QueCmp.TAB.TEX1_REF:=$_px_tex || PxSelect.QueCmp.TAB.TEX_REF:=$_px_tex ?};
   PX_TEX.cntx_psh();
   PX_TEX.clear();
   {? PX_TEX.seek(_px_tex)
   ||
      {? _kopia || PxSelect.QueCmp.TAB.TEX1_SYM:=PX_TEX.SYMBOL || PxSelect.QueCmp.TAB.TEX_SYM:=PX_TEX.SYMBOL ?}
   ?};
   PX_TEX.cntx_pop();

   {? _kopia || PxSelect.QueCmp.TAB.IL1:=_ilosc || PxSelect.QueCmp.TAB.IL:=_ilosc ?};

   {? _kopia || PxSelect.QueCmp.TAB.STATUS1:=_status || PxSelect.QueCmp.TAB.STATUS:=_status ?};
   PxSelect.QueCmp.TAB.add()
?};
PxSelect.QueCmp.TAB.clear();
~~


\que_cmp_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Naniesienie znacznikow na tabele porownan kolejek
::----------------------------------------------------------------------------------------------------------------------
PxSelect.QueCmp.TAB.cntx_psh();
PxSelect.QueCmp.TAB.clear();
{? PxSelect.QueCmp.TAB.first()
|| {!
   |?
      {? PxSelect.QueCmp.TAB.IL=0
      || PxSelect.QueCmp.TAB.CMP:='←'
      |? PxSelect.QueCmp.TAB.IL1=0
      || PxSelect.QueCmp.TAB.CMP:='→'
      |? PxSelect.QueCmp.TAB.IL=PxSelect.QueCmp.TAB.IL1
      || PxSelect.QueCmp.TAB.CMP:='='
      || PxSelect.QueCmp.TAB.CMP:='≠'
      ?};
      PxSelect.QueCmp.TAB.ROZNICA:=PxSelect.QueCmp.TAB.IL1-PxSelect.QueCmp.TAB.IL;
      PxSelect.QueCmp.TAB.put();
      PxSelect.QueCmp.TAB.next()
   !}
?};
PxSelect.QueCmp.TAB.cntx_pop();
~~


\que_cmp_clear
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Czysci tabele roznic
::   WY: wynik erase()
::----------------------------------------------------------------------------------------------------------------------
PxSelect.QueCmp.TAB.erase()


\gen_diff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Generuje roznice miedzy kolejka podstawowa a kopia
::       Kontekst wywolania: PxSelect.VER_QUE, PxSelect.VER_QUE1, PxSelect.Pxgrp, PxSelect.Pxgrp1
::----------------------------------------------------------------------------------------------------------------------
exec('clear_diff','px_grp');
exec('que_cmp_clear','px_grp');
exec('gen_diff_tab','px_grp',PxSelect.VER_QUE,PxSelect.Pxgrp,PxSelect.VER_QUE1,PxSelect.Pxgrp1);
exec('gen_diff_tab','px_grp',PxSelect.VER_QUE1,PxSelect.Pxgrp1,PxSelect.VER_QUE,PxSelect.Pxgrp);
exec('que_cmp_update','px_grp');
PxSelect.QueCmp.TAB.first();
::grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT);
::grp_disp(PxSelect.Pxgrp1.TAB,PxSelect.Pxgrp1.WERT);
~~


\gen_diff_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Generuje roznice miedzy dwoma kolejkami
::   WE: _a - PX_VER - pierwsza wersja (parametr nie jest uzywany, ale dodany przyszlosciowo)
::       _b - TREEVIEW - pierwszy obiekt kolejki
::       _c - PX_VER - druga wersja
::       _d - TREEVIEW - drugi obiekt kolejki (parametr nie jest uzywany, ale dodany przyszlosciowo)
::----------------------------------------------------------------------------------------------------------------------
PX_CONN.cntx_psh();
PX_OBJ.cntx_psh(); PX_OBJ.clear();
PX_GRP.cntx_psh();

_b.TAB.cntx_psh();
{? _b.TAB.first()
|| {!
   |? {? _b.TAB.PX_CONN<>''
      || PX_CONN.clear();
         {? PX_CONN.seek(_b.TAB.PX_CONN)
         || _ilosc:=PX_CONN.ILOSC;
            _px_tex:=PX_CONN.PX_GRP().PX_TEX;
            {? PX_OBJ.seek(PX_CONN.PX_OBJ)
            || PX_CONN.index('VER');
               PX_CONN.prefix(_c,PX_OBJ.ref());
               {? PX_CONN.first()
               || {? PX_CONN.ILOSC=_ilosc & PX_CONN.PX_GRP().PX_TEX=_px_tex
                  || _b.TAB.CMP:='='
                  || _b.TAB.CMP:='≠'
                  ?}
               || {? _b.KOPIA || _b.TAB.CMP:='←' || _b.TAB.CMP:='→' ?}
               ?};
               exec('que_cmp_add','px_grp',PX_OBJ.ref(),_px_tex,_b.KOPIA,_ilosc,PX_CONN.PX_GRP().STATUS)
            || _b.TAB.CMP:='!'
            ?}
         || _b.TAB.CMP:='!'
         ?}
      ?};
      _b.TAB.put();
      _b.TAB.next()
   !}
?};
_b.TAB.cntx_pop();

PX_GRP.cntx_pop();
PX_OBJ.cntx_pop();
PX_CONN.cntx_pop();
~~


\clear_diff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Czysci znaczniki porownania miedzy kolejka glowna i kopia
::       Kontekst wywolania: PxSelect.Pxgrp, PxSelect.Pxgrp1
::----------------------------------------------------------------------------------------------------------------------
exec('clear_diff_tab','px_grp',PxSelect.Pxgrp.TAB);
exec('clear_diff_tab','px_grp',PxSelect.Pxgrp1.TAB);
~~


\clear_diff_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Czysci znaczniki porownania w kolejce
::   WE: _a - tabela kolejki (PxSelect.Pxgrp.TAB, PxSelect.Pxgrp1.TAB)
::----------------------------------------------------------------------------------------------------------------------
_a.cntx_psh();
_a.clear();
{? _a.first()
|| {!
   |? _a.CMP:='';
      _a.put();
      _a.next()
   !}
?};
_a.cntx_pop();
~~


\del_direct
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Funkcja szybkiego usuwania obiektu z planu
::       Usuwa PX_GRP ze swojej kolejki oraz usuwa skojarzony z nim PX_GRP z planu glownego (o ile istnieje).
::       Ponadto jesli istnieja pozycje planu w planie glownym to rowniez sa usuwane.
::   WE: _a - PX_GRP.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_result:=0;
_can_continue:=1;
PX_GRP.cntx_psh();
PX_GRP.clear();
{? PX_GRP.seek(_px_grp)
||
   _display:=1;
   {? VAR.GRUPA='T'
   || _display:=2
   ?};
   {? exec('lock','px_grp',,_display)>0
   ||
      {? PX_GRP.UID_SRC<>''
      ||
::       jesli PX_GRP powstal na podstawie innego PX_GRP to ten zrodlowy i jego pozycje planu sa
::       rowniez usuwane
         PX_GRP.cntx_psh();
         PX_GRP.index('UID');
         PX_GRP.prefix(PX_GRP.UID_SRC);
         {? PX_GRP.first()
         || _can_continue:=exec('delete','px_grp',PX_GRP.ref())
         ?};
         PX_GRP.cntx_pop()
      ?};
      {? _can_continue>0
      ||
::       Usuwam z kolejki wlasciwy PX_GRP
         _can_continue:=exec('delete','px_grp',PX_GRP.ref())
      ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
PX_GRP.cntx_pop();
_result


\del_direct_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE/MBUILDER
::  UTW: WH [12.30]
:: OPIS: Akcja 'usun z planu' w oknie kolejki (ustawiana w oknie w funkcji exec('px_grp_tmp','px_grp'))
::----------------------------------------------------------------------------------------------------------------------
_can_continue:=1;
_px_ver:=null();
PX_GRP.cntx_psh();
PX_GRP.clear();
_ref:=exec('FindAndGet','#table',PX_GRP,PxSelect.Pxgrp.TAB.PX_GRPI);
{? type_of(_ref)>0
||
   {? PX_GRP.seek(_ref)
   || _px_ver:=PX_GRP.PX_VER;
      {? VAR.GRUPA<>'T'
      || _can_continue:=FUN.ask('Czy na pewno usunąć z kolejki i z planu głównego obiekt: %1'@[PX_GRP.SYMBOL])
      ?};
      {? _can_continue>0
      || exec('del_direct','px_grp',PX_GRP.ref())
      ?}
   ?}
?};
PX_GRP.cntx_pop();

{? VAR.GRUPA<>'T' & _can_continue>0
||
:: Po usunieciu musze przenumerowac wyswietlana kolejke oraz kolejke z planu glownego
   exec('prenumber','px_grp',PX_VAR.VER_QUE);
   exec('prenumber','px_grp',exec('get_mainversion','px_ver'));

:: Odswiezam obiekt wyswietlajacy kolejke
   {? var_pres('PxSelect')>100
   || {? var_pres('Pxgrp',PxSelect)>100
      || exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp)
      ?}
   ?};

:: Odswiezam zawartosc zakladek 'Obiekty' i 'Zasoby'
   {? exec('get','#params',8059,2,OPERATOR.USER)='T'
   ||
      PxSelect.Tab_OBJ.reload();
      PxSelect.Tab_KONT.reload()
   ?};

:: Odswiezam zawartosc okien
   {? PxSelect.Context*'|MENU'=0
   ||
::    Jesli kontekst zawiera tekst menu to znak ze okno nie zawiera czesci okien
      grp_disp(PX_KONT,{? exec('tree_kont','px_param') || 'PX_WERT' || 'PX_WER' ?},1,1);
      grp_disp(PxSelect.Tab_OBJ.TAB,PxSelect.Tab_OBJ.WER,1,1);
      grp_disp(PxSelect.Tab_KONT.TAB,PxSelect.Tab_KONT.WER,1,1)
   ?};
   ~~
?};
~~


\del_direct_gr1
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE/MBUILDER
::  UTW: WH [12.30]
:: OPIS: Akcja 'usun z planu' w oknie kolejki (przed grupa rekordow)
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
KOMM.init(,,'Bezpośrednie usuwanie obiektów z planu'@);
{? FUN.ask('Usunąć z kolejki i z planu głównego zaznaczone elementy?'@)
|| VAR.GRUPA:='T';
   1
|| 0
?}


\del_direct_gr2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE/MBUILDER
::  UTW: WH [12.30]
:: OPIS: Akcja 'usun z planu' w oknie kolejki (po grupie rekordow)
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();

:: Po usunieciu musze przenumerowac wyswietlana kolejke oraz kolejke z planu glownego
exec('prenumber','px_grp',PX_VAR.VER_QUE);
exec('prenumber','px_grp',exec('get_mainversion','px_ver'));

:: Odswiezam obiekt wyswietlajacy kolejke
{? var_pres('PxSelect')>100
|| {? var_pres('Pxgrp',PxSelect)>100
   || exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp)
   ?}
?};

:: Odswiezam zawartosc zakladek 'Obiekty' i 'Zasoby'
{? exec('get','#params',8059,2,OPERATOR.USER)='T'
|| PxSelect.Tab_OBJ.reload();
   PxSelect.Tab_KONT.reload()
?};

:: Odswiezam zawartosc okien
{? PxSelect.Context*'|MENU'=0
||
:: Jesli kontekst zawiera tekst menu to znak ze okno nie zawiera czesci okien
   grp_disp(PX_KONT,{? exec('tree_kont','px_param') || 'PX_WERT' || 'PX_WER' ?},1,1);
   grp_disp(PxSelect.Tab_OBJ.TAB,PxSelect.Tab_OBJ.WER,1,1);
   grp_disp(PxSelect.Tab_KONT.TAB,PxSelect.Tab_KONT.WER,1,1)
?};
~~


\txt_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Przed wyswietleniem pola TXT w kolejce (kolumna ze struktura hierarchiczna)
::   WE: [_a] - obj_new('CMP','KOM_ERR','KOM_WARN','KOM_INFO')
::----------------------------------------------------------------------------------------------------------------------
_result:=~~;
_tab:={? var_pres('_a')>100 || _a || cur_tab(1,1) ?};
{? _tab.CMP='='
|| _result:=exec('flddisp','color','PX_GRP#TXT#WIN#01')
|? _tab.CMP='≠'
|| _result:=exec('flddisp','color','PX_GRP#TXT#WIN#02')
|? _tab.CMP='←'
|| _result:=exec('flddisp','color','PX_GRP#TXT#WIN#03')
|? _tab.CMP='→'
|| _result:=exec('flddisp','color','PX_GRP#TXT#WIN#04')
||
:: Kolorowanie na podstawie istniejacych komunikatow
   _result:={? _ || exec('komm_colorizer','px_komm',_a) || exec('komm_colorizer','px_komm') ?}
?};
_result


\aggr_tx_mat

'###'


\px_var_agr_blank
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Wartość początkowa dla pola PX_VAR.AGR
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
'N'


\px_var_agr_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Przed redagowaniem dla pola PX_VAR.AGR
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
PX_VAR.CAN_AGR


\select_komm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Pokazuje komunikaty dla aktualnej pozycji kolejki
::----------------------------------------------------------------------------------------------------------------------
PX_OBJ.cntx_psh(); PX_OBJ.clear();
PX_CONN.cntx_psh(); PX_CONN.clear();
PX_GRP.cntx_psh(); PX_GRP.clear();
{? cur_tab(1,1).TYP='PX_GRP'
|| {? PX_GRP.seek(cur_tab(1,1).PX_GRPI)
   || exec('select_grp','px_komm')
   ?}
|? cur_tab(1,1).TYP='PX_CONN'
|| {? PX_CONN.seek(cur_tab(1,1).PX_CONN)
   || PX_CONN.PX_OBJ();
      exec('select_obj','px_komm')
   ?}
?};
PX_OBJ.cntx_pop();
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
~~


\px_grp_lp_disp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Formuła na format wyświetlania pola tabeli PX_GRP.LP_Q
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'out_prec=0'


\verify_grp_tex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Sprawdza poprawnosc przepisow w kolejce
::   WE: _a - PX_VER.ref() - wersja kolejki do sprawdzenia
::       [_b] - obj_new - tablica refów z zablokowanymi przepisami, jeżeli nie podana, to blokowanie nie będzie robione
::   WY: tekst bledu
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_PX_VER:=_a;
_locked:=~~;
{? var_pres('_b')>100
|| _locked:=_b
?};

_result:='';

PX_GRP.cntx_psh(); PX_GRP.clear();
:: Przetwarzamy tylko niewykonane w calosci i niezablokowane - one i tak nie beda planowane
{? exec('is_whatif','px_ver',_PX_VER)>0
|| PX_GRP.index('PLAN_S');
   PX_GRP.prefix(_PX_VER,'N','N','N','Z')
||
   PX_GRP.index('PLAN');
   PX_GRP.prefix(_PX_VER,'N','N','Z')
?};
{? PX_GRP.first()
||
   _komm_args:=exec('add_komm_a','px_komm');
   _komm_args.PX_VER:=_PX_VER;
   {!
   |? _result+=exec('verify_grp_tex_core','px_grp',,_komm_args,_locked);
      PX_GRP.next()
   !}
?};
PX_GRP.cntx_pop();
_result


\verify_grp_tex_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza poprawnosc przepisu w kolejce
::   WE: [_a] - PX_GRP.ref - element w kolejce lub bieżący rekord
::       [_b] - obj_new - argumenty dla dodawania komunikatów
::       [_c] - obj_new - tablica refów z zablokowanymi przepisami, jeżeli nie podana, to blokowanie nie będzie robione
::   WY: STRING - tekst błędu lub ''
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

{? var_pres('_b')>100
|| _komm_args:=_b
|| _komm_args:=exec('add_komm_a','px_komm')
?};

_locked:=~~;
{? var_pres('_c')>100
|| _locked:=_c
?};

_result:='';
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _komm_args.PX_VER:=PX_GRP.PX_VER;

   {? _can_continue>0
   ||
::    Najpierw usuwam stare komunikaty
      _typ:=exec('type_error','px_komm');
      _src_kind:=exec('src_tex_verify','px_komm');
      exec('del_kommy','px_komm','PX_GRP',PX_GRP.ref(),_typ,_src_kind);

      _verify:='';
::    Jeżeli tablica do blokowania przekazana to próbuję zablokować przepis
      {? var_pres('_locked')>100
      || _lock_res:=exec('lock','px_tex',PX_GRP.PX_TEX,2);
         _can_continue:=_lock_res.LOCKED;
         {? _lock_res.PX_TEX<>null()
         || _locked.add(_lock_res.PX_TEX)
         ?};
         {? _lock_res.TKTL<>null()
         || _locked.add(_lock_res.TKTL)
         ?};
         {? _can_continue=0
         || _verify:=VAR.MESSAGE
         ?}
      ?};

      {? _can_continue>0
      || _verify:=exec('verify','px_tex',PX_GRP.PX_TEX,PX_GRP.ILOSC)
      ?};

      {? _verify<>''
      ||
         _result:=PX_GRP.SYMBOL+', ';
         _komm_args.PX_GRP:=PX_GRP.ref();
         _komm_args.MESSAGE:='Przepis grupy: %1. %2 %3.'[$PX_GRP.LP_Q,PX_GRP.SYMBOL,_verify];
         _komm_args.TYP:=exec('type_error','px_komm');
         _komm_args.SRC_KIND:=exec('src_tex_verify','px_komm');
         exec('add_komm','px_komm',_komm_args);
         _ok:=0
      ?}
   ?}
?};
PX_GRP.cntx_pop();
_result


\verify_grp_il
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza poprawnosc ilosci w kolejce
::   WE: _a - PX_VER.ref() - wersja kolejki do sprawdzenia
::   WY: 0 - kolejka zostala zweryfikowana negatywnie - zawiera bledy
::       1 - mozna planowac taka kolejke
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_result:=1;

PX_OBJ.cntx_psh();
PX_CONN.cntx_psh(); PX_CONN.clear();
PX_CONN.index('PX_GRP');
PX_GRP.cntx_psh(); PX_GRP.clear();
:: Przetwarzamy tylko niewykonane w calosci i niezablokowane - one i tak nie beda planowane
{? exec('is_whatif','px_ver',_px_ver)>0
|| PX_GRP.index('PLAN_S');
   PX_GRP.prefix(_px_ver,'N','N','N')
||
   PX_GRP.index('PLAN');
   PX_GRP.prefix(_px_ver,'N','N')
?};
{? PX_GRP.first()
|| _komm_args:=exec('add_komm_a','px_komm');
   _komm_args.PX_VER:=_px_ver;
   _komm_args.TYP:=exec('type_error','px_komm');
   _komm_args.SRC_KIND:=exec('src_il_verify','px_komm');
   {!
   |?
      {? exec('verify_grp_il_core','px_grp',,_komm_args)=0
      || _result:=0
      ?};
      PX_GRP.next()
   !}
?};
PX_OBJ.cntx_pop();
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
_result


\verify_grp_il_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza poprawnosc ilosci w kolejce dla podanego elementu
::   WE: [_a] - PX_GRP.ref - element w kolejce lub bieżący rekord
::       [_b] - obj_new - argumenty dla dodawania komunikatów
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

{? var_pres('_b')>100
|| _komm_args:=_b
|| _komm_args:=exec('add_komm_a','px_komm');
   _komm_args.TYP:=exec('type_error','px_komm');
   _komm_args.SRC_KIND:=exec('src_il_verify','px_komm');
   ~~
?};

_result:=1;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _komm_args.PX_VER:=PX_GRP.PX_VER;
   PX_CONN.cntx_psh();
   PX_CONN.index('PX_GRP');
   PX_CONN.prefix(PX_GRP.ref());
   {? PX_CONN.first()
   || {!
      |?
::       Najpierw usuwam stare komunikaty
         exec('del_kommy','px_komm','PX_OBJ',PX_CONN.PX_OBJ,_komm_args.TYP,_komm_args.SRC_KIND);

         _px_obj:=PX_CONN.PX_OBJ;
         PX_CONN.PX_OBJ();
         _il_queued:=exec('get_que_ilosc','px_obj',_px_obj,PX_GRP.PX_VER);

         {? _il_queued>PX_OBJ.IL
         ||
            _result:=0;
::          Dodaje komunikat, o ile jeszcze takiego nie ma
            {? exec('get_kom','px_komm','PX_OBJ',PX_CONN.PX_OBJ,_komm_args.TYP,_komm_args.SRC_KIND)=null()
            ||
               _komm_args.PX_OBJ:=PX_CONN.PX_OBJ;
::             _komm_args.PX_GRP:=PX_CONN.PX_GRP;
               _diff:=_il_queued-PX_OBJ.IL;
               _msg:='Ilość w kolejce dla obiektu: %1 przekracza o: %2 dozwoloną ilość.'[PX_OBJ.SYMBOL,form(_diff,,2,'9.')];
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args)
            ?}
         ?};
         PX_CONN.next()
      !}
   ?};
   PX_CONN.cntx_pop();
   ~~
?};
PX_GRP.cntx_pop();
_result


\verify_grp_poi
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza poprawnosc punktow czasowych w kolejce
::   WE: PX_VER.ref() _a - wersja kolejki do sprawdzenia
::   WY: 0 - poprazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_PX_VER:=_a;
_result:=1;

PX_GRP.cntx_psh(); PX_GRP.clear();
:: Przetwarzamy tylko niewykonane w calosci i niezablokowane - one i tak nie beda planowane
{? exec('is_whatif','px_ver',_PX_VER)>0
|| PX_GRP.index('PLAN_S');
   PX_GRP.prefix(_PX_VER,'N','N','N','Z')
||
   PX_GRP.index('PLAN');
   PX_GRP.prefix(_PX_VER,'N','N','Z')
?};
{? PX_GRP.first()
||
   {!
   |?
      _can_continue:=exec('verify','px_point',PX_GRP.ref());
      {? _can_continue=0
      || _result:=0
      ?};
      PX_GRP.next()
   !}
?};
PX_GRP.cntx_pop();
_result


\verify_grp_zwr
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza poprawnosc zwrotow i opcji 'Kontunuuj po przekroczeniu terminu'
::   WE: _a - PX_VER.ref() - wersja kolejki do sprawdzenia
::   WY: 0 - kolejka zostala zweryfikowana negatywnie - zawiera bledy
::       1 - mozna planowac taka kolejke
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_result:=1;

PX_OBJ.cntx_psh();
PX_GRP.cntx_psh(); PX_GRP.clear();
:: Przetwarzamy tylko niewykonane w calosci i niezablokowane - one i tak nie beda planowane
{? exec('is_whatif','px_ver',_px_ver)>0
|| PX_GRP.index('PLAN_S');
   PX_GRP.prefix(_px_ver,'N','N','N')
||
   PX_GRP.index('PLAN');
   PX_GRP.prefix(_px_ver,'N','N')
?};
{? PX_GRP.first()
|| _komm_args:=exec('add_komm_a','px_komm');
   _komm_args.PX_VER:=_px_ver;
   _komm_args.TYP:=exec('type_error','px_komm');
   _komm_args.SRC_KIND:=exec('src_zwr_verify','px_komm');
   {!
   |?
      {? exec('verify_grp_zwr_core','px_grp',,_komm_args)=0
      || _result:=0
      ?};
      PX_GRP.next()
   !}
?};
PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
_result


\verify_grp_zwr_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza poprawnosc zwrotow i opcji 'Kontunuuj po przekroczeniu terminu'
::   WE: [_a] - PX_GRP.ref - element w kolejce lub bieżący rekord
::       [_b] - obj_new - argumenty dla dodawania komunikatów
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

{? var_pres('_b')>100
|| _komm_args:=_b
|| _komm_args:=exec('add_komm_a','px_komm');
   _komm_args.TYP:=exec('type_error','px_komm');
   _komm_args.SRC_KIND:=exec('src_zwr_verify','px_komm')
?};

_result:=1;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _komm_args.PX_VER:=PX_GRP.PX_VER;
:: Najpierw usuwam stare komunikaty
   exec('del_kommy','px_komm','PX_GRP',PX_GRP.ref(),_komm_args.TYP,_komm_args.SRC_KIND);

:: 1. Sprawdzam spójność zwrotów i opcji kontynuacji planowania po przekroczeniu terminu
   {? PX_GRP.DIR<=0 & PX_GRP.PL_FORCE='T'
   || _komm_args.PX_GRP:=PX_GRP.ref();
      _msg:='Jeżeli zwrot planowania ma wartość \'Wstecz\' opcja \'Kontynuuj planowanie po przekroczeniu terminu\' ';
      _msg+='nie może być aktywna';
      _komm_args.MESSAGE:=_msg;
      exec('add_komm','px_komm',_komm_args);
      _result:=0
   ?}
?};
PX_GRP.cntx_pop();
_result


\verify_grp_conn
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza poprawnosc powiazan w kolejce pod katem rozchodzacych sie zwrotow
::   WE: _a - PX_VER.ref() - wersja kolejki do sprawdzenia
::   WY: 0 - kolejka zostala zweryfikowana negatywnie - zawiera bledy
::       1 - mozna planowac taka kolejke
::----------------------------------------------------------------------------------------------------------------------
_PX_VER:=_a;
_result:=1;

PX_GRP.cntx_psh(); PX_GRP.clear();
:: Przetwarzamy tylko niewykonane w calosci i niezablokowane - one i tak nie beda planowane
{? exec('is_whatif','px_ver',_PX_VER)>0
|| PX_GRP.index('PLAN_S');
   PX_GRP.prefix(_PX_VER,'N','N','N')
||
   PX_GRP.index('PLAN');
   PX_GRP.prefix(_PX_VER,'N','N')
?};
{? PX_GRP.first()
||
   {!
   |?
      _can_continue:=exec('verify','px_con_g');
      {? _can_continue=0
      || _result:=0
      ?};
      PX_GRP.next()
   !}
?};
PX_GRP.cntx_pop();
_result


\verify_grp_end
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza poprawnosc granic czasowych 'do' w kolejce
::   WE: PX_VER.ref() _a - wersja kolejki do sprawdzenia
::   WY: 0 - poprazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_result:=1;

PX_GRP.cntx_psh(); PX_GRP.clear();
:: Przetwarzamy tylko niewykonane w calosci i niezablokowane - one i tak nie beda planowane
{? exec('is_whatif','px_ver',_px_ver)>0
|| PX_GRP.index('PLAN_S');
   PX_GRP.prefix(_px_ver,'N','N','N')
||
   PX_GRP.index('PLAN');
   PX_GRP.prefix(_px_ver,'N','N')
?};

{? PX_GRP.first()
||
   _one_ver:=exec('is_one_version','px_param');

   _komm_args:=exec('add_komm_a','px_komm');
   _komm_args.PX_VER:=_px_ver;
   _komm_args.TYP:=exec('type_error','px_komm');
   _komm_args.SRC_KIND:=exec('src_end_verify','px_komm');
   {!
   |?
      {? exec('verify_grp_end_core','px_grp',,_komm_args)=0
      || _result:=0
      ?};
      PX_GRP.next()
   !}
?};
PX_GRP.cntx_pop();
_result


\verify_grp_end_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza poprawnosc granic czasowych 'do' elementu w kolejce
::   WE: [_a] - PX_GRP.ref - element w kolejce lub bieżący rekord
::       [_b] - obj_new - argumenty dla dodawania komunikatów
::   WY: 0 / 1
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

{? var_pres('_b')>100
|| _komm_args:=_b
|| _komm_args:=exec('add_komm_a','px_komm');
   _komm_args.TYP:=exec('type_error','px_komm');
   _komm_args.SRC_KIND:=exec('src_end_verify','px_komm')
?};

_result:=1;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _komm_args.PX_VER:=PX_GRP.PX_VER;

:: Najpierw czyszcze poprzednie komunikaty o ile jakies byly
   _typ:=exec('type_error','px_komm');
   _src_kind:=exec('src_end_verify','px_komm');
   exec('del_kommy','px_komm','PX_GRP',PX_GRP.ref(),_typ,_src_kind);

   {? PX_GRP.PL_FORCE<>'T'
   ||
::    sprawdzam czy psotek powolany, jesli nie to powoluje
      exec('PXoTEX_chk','px_tex');

::    pobieram paczke technologiczna
      {? var_pres('_pxpack')>100
      || obj_del(_pxpack)
      ?};
      {? PX_GRP.GROPS<>null()
      || _pxpack:=exec('trzepaczka_grop','px_tex',PX_GRP.GROPS,PX_GRP.ILOSC,PX_GRP.ref())
      || _pxpack:=exec('trzepaczka','px_tex',PX_GRP.PX_TEX,PX_GRP.ILOSC,PX_GRP.ref())
      ?};

::    KOREKTA ILOSCI KTORE ZOSTALY ZAPLANOWANE NA PODSTAWIE PLANU OPERACYJNEGO
      _paczka:=_pxpack.Paczka;
      _kor_prop:=exec('count_oper_kor','px_tie',PX_GRP.ref());
      exec('paczka_kor_prop','px_tex',_paczka,_kor_prop);
::    Jesli po korekcie paczka jest pusta, to znak ze cala grupa zostala zaplanowana
::    na podstawie planu operacyjnego i trzeba ja tak osteplowac
      {? exec('pck_not_empty','px_tex',_paczka)=0
      ||
         {? _kor_prop<1
         ||
::          Jesli paczka pusta i nastapila korekta na podstawie planu operacyjnego
::          to oznaczam grupe ze zostala zaplanowana na podstawie planu operacyjnego
            exec('set_plan_opr','px_grp',PX_GRP.ref(),'T')
         ?}
      || exec('set_plan_opr','px_grp',PX_GRP.ref(),'N')
      ?};

::    pobieram czas startu
      _tm_start:=exec('round_start_pck','px_tex',_paczka);

      {? PX_GRP.PLAN_OPR<>'T' & PX_GRP.TM_END<_tm_start
      ||
::       Granica czasowa elementu kolejki jest mniejsza niz punkt od ktorego mogloby sie
::       rozpoczac planowanie wiec na bank nie uda sie zaplanowac takiego elementu bez przekraczania
::       terminu
         _result:=0;
         _komm_args.PX_GRP:=PX_GRP.ref();
         _msg:='Granica czasowa \'Planuj do\' znajduje się w przeszłości: %1. Elementu na pewno nie uda się zaplanować.'@[(19+tm_form(PX_GRP.TM_END))];
         _msg+=' Prawdopodobnie wymagana będzie modyfikacja terminów realizacji składowych elementu.';
         _komm_args.MESSAGE:=_msg;
         exec('add_komm','px_komm',_komm_args)
      ?}
   ?}
?};
PX_GRP.cntx_pop();
_result


\clean_from_plan
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Usuwa z planu wszystkie pozycje planu powiazane z danym PX_GRP
::   WE: _a - PX_GRP.ref();
::       [_b] - INTEGER - tryb usuwania pozycji: [1] - usuwac wszystkie pozycje
::                                                0  - usuwac tylko:
::                                                                   - niewykonane
::                                                                   - niewykonywane
::                                                                   - niezablokowane
::                                                                   - nieporzucone
::                                                                   - nieopoznione
::                                                 2 - usuwać wszystko poza zrobionymi na podstawie planu oper
::       [_c] - INTEGER - tryb usuwania pozycji - [0] - nie usuwac tych znajdujacych sie na biezacym pojemniku
::                                                 1 - usuwac te znajdujace sie na biezacym pojemniku jesli
::                                                     start planu od nastepnego pojemnika
::       [_d] - INTEGER - 0/[1] - czy po usunieciu pozycji planu wykonywac renumeracje pozycji na pojemniku
::       [_e] - INTEGER - 0/[1] - czy po usunięciu odbudowywać kalendarze w pojemniku
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

_mode:=1;
{? var_pres('_b')=type_of(0)
|| _mode:=_b
?};
_kor_today:=0;
{? var_pres('_c')=type_of(0)
|| _kor_today:=_c
?};
_renumerate:=1;
{? var_pres('_d')=type_of(0)
|| _renumerate:=_d
?};

_rebuild_cal:=1;
{? var_pres('_e')=type_of(0)
|| _rebuild_cal:=_e
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh(); PX_GRP.clear();
PX_POZ.cntx_psh();

{? PX_GRP.seek(_px_grp)
||
   PX_POZ.index('PX_GRP2');
   PX_POZ.prefix(PX_GRP.ref());

   {? _mode=1
   ||
      {? PX_POZ.first()
      || {!
         |? _can_continue:=exec('delete','px_poz',PX_POZ.ref(),,_renumerate,_rebuild_cal);
            PX_POZ.first() & _can_continue>0
         !}
      ?}
   |? _mode=0
   ||
      {? PX_POZ.first()
      || {!
         |? _next:=0;
            _can_delete:=1;
            _can_surdel:=1;
            _deleted:=0;
            _ref_next:=null();

::          Zapamietuje ref kolejnego rekordu, na wypadek gdyby biezacy wyskoczyl z dziedziny
            PX_POZ.cntx_psh();
            {? PX_POZ.next()
            || _ref_next:=PX_POZ.ref()
            ?};
            PX_POZ.cntx_pop();

::          Sprawdzam czy rekord PX_POZ moze byc usuniety oraz czy PX_SUR moga by usuniete bez usuwania PX_POZ
            {? PX_POZ.STATUS=exec('status_wyk1','px_poz')
            || _can_delete:=0;
               _can_surdel:=1
            |? PX_POZ.STATUS=exec('status_wyk2','px_poz')
            || _can_delete:=0;
               _can_surdel:=1
            |? PX_POZ.STATUS=exec('status_skipped','px_poz')
            || _can_delete:=0;
               _can_surdel:=1
            |? PX_POZ.STATUS=exec('status_delay','px_poz')
            || _can_delete:=0;
               _can_surdel:=1
            |? PX_POZ.BLK='T'
            || _can_delete:=0;
               _can_surdel:=1
            |? PX_POZ.SRC_OPER='T'
            || _can_delete:=0;
               _can_surdel:=1
            ?};

            {? _can_delete>0
            || _deleted:=exec('delete','px_poz',PX_POZ.ref(),,_renumerate,_rebuild_cal);
               {? _deleted=0
               || _can_continue:=0
               ?}
            || {? _can_surdel>0
               || exec('del_sur','px_poz',PX_POZ.ref())
               ?}
            ?};

            {? _deleted>0
            || {? _ref_next<>null()
               || {? PX_POZ.seek(_ref_next)
                  || _next:=1
                  ?}
               || _next:=0
               ?}
            || _next:=PX_POZ.next()
            ?};
            _next>0
         !}
      ?}
   |? _mode=2
   ||
      {? PX_POZ.first()
      || {!
         |? _next:=0;
            _can_delete:=1;
            _deleted:=0;
            _ref_next:=null();

::          Zapamietuje ref kolejnego rekordu, na wypadek gdyby biezacy wyskoczyl z dziedziny
            PX_POZ.cntx_psh();
            {? PX_POZ.next()
            || _ref_next:=PX_POZ.ref()
            ?};
            PX_POZ.cntx_pop();

::          Sprawdzam czy rekord moze byc usuniety
            {? PX_POZ.SRC_OPER='T'
            || _can_delete:=0
            ?};

            {? _can_delete>0
            || _deleted:=exec('delete','px_poz',PX_POZ.ref(),,_renumerate,_rebuild_cal);
               {? _deleted=0
               || _can_continue:=0
               ?}
            ||
::             Dla nieusuwanej pozycji usuwane sa bezwarunkowo surowce
               exec('del_sur','px_poz',PX_POZ.ref())
            ?};

            {? _deleted>0
            || {? _ref_next<>null()
               || {? PX_POZ.seek(_ref_next)
                  || _next:=1
                  ?}
               || _next:=0
               ?}
            || _next:=PX_POZ.next()
            ?};
            _next>0
         !}
      ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
PX_POZ.cntx_pop();
PX_GRP.cntx_pop();
_result


\set_plan_opr
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Ustawia znacznik czy grupa zostala zaplanowana przez algorytm nanoszacy plan operacyjny do planu strategicznego
::   WE: _a - PX_GRP.ref()
::       _b - STRING - wartosc znacznika
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_status:=_b;

_result:=0;

PX_GRP.cntx_psh();
PX_GRP.clear();
{? PX_GRP.seek(_px_grp)
|| PX_GRP.PLAN_OPR:=_status;
   _result:=PX_GRP.put();

   {? PX_GRP.PLAN_OPR='T'
   ||
::    Wiaze pozycje planu powstale z operacyjnego z ta grupa
      exec('px_poz_oper_tie','px_tie')
   ?}
?};
PX_GRP.cntx_pop();
PX_GRP.get();
_result


\is_plan_opr
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy grupa zostala zaplanowana przez algorytm nanoszacy plan operacyjny do planu strategicznego
::   WE: _a - PX_GRP.ref()
::   WY: 0 - grupa nie zostala zaplanowana podczas nanoszenia planu oper.->plan strat.
::       1 - grupa zostala zaplanowana podczas nanoszenia planu oper.->plan strat.
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

_result:=0;

PX_GRP.cntx_psh();
PX_GRP.clear();
{? PX_GRP.seek(_px_grp)
|| {? PX_GRP.PLAN_OPR='T'
   || _result:=1
   ?}
?};
PX_GRP.cntx_pop();
_result


\dates_set
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Ustawia na PX_GRP daty graniczne na podstawie tego co podal uzytkownik
::   WE: _a - PX_GRP.ref() - grupa ktorej ustawic daty
::       _b - DATE - data graniczna podana przez usera
::       _c - TIME - czas graniczny podany przez usera
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_grn_date:=_b;
_grn_time:=_c;

_result:=0;

PX_GRP.cntx_psh();PX_GRP.clear();
{? PX_GRP.seek(_px_grp)
||
   {? PX_GRP.DIR>0
   ||
::    Planowanie w przod
      _min_tm:=exec('min_termin','px_grp',_px_grp);
      _min_date:=exec('tm_stamp2date','#tm_stamp',_min_tm);
      _min_time:=exec('tm_stamp2time','#tm_stamp',_min_tm);
      PX_GRP.STARTD:=exec('get','daty',_grn_date);
      PX_GRP.STARTT:=_grn_time;
      PX_GRP.ENDD:=exec('get','daty',_min_date);
      PX_GRP.ENDT:=_min_time
   ||
::    Planowanie w tyl
      PX_GRP.STARTD:=exec('get','daty',date());
      PX_GRP.STARTT:=time();
      PX_GRP.ENDD:=exec('get','daty',_grn_date);
      PX_GRP.ENDT:=_grn_time
   ?};
   _result:=PX_GRP.put()
?};
PX_GRP.cntx_pop();
PX_GRP.get();
_result


\min_termin
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca najwczesniejszy termin realizacji obiektow nalezacych do PX_GRP
::   WE: _a - PX_GRP.ref()
::   WY: REAL - tm_stamp()
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh(); PX_GRP.clear();
PX_OBJ.cntx_psh();
{? PX_GRP.seek(_px_grp)
|| PX_CONN.cntx_psh();
   PX_CONN.index('PX_GRP');
   PX_CONN.prefix(_px_grp);
   {? PX_CONN.first()
   || {!
      |? PX_CONN.PX_OBJ();
         {? _result=0 | (PX_OBJ.TM_REA>0 & PX_OBJ.TM_REA<_result)
         || _result:=PX_CONN.PX_OBJ().TM_REA
         ?};
         PX_CONN.next()
      !}
   ?};
   PX_CONN.cntx_pop()
?};
PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
{? _result<0
|| _result:=0
?};
_result


\min_termin_drop
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca najwczesniejszy termin realizacji przeciaganych obiektow
::   WE: _a - dnd_info('dropped_records')
::   WY: REAL - tm_stamp()
::----------------------------------------------------------------------------------------------------------------------
_dropped:=_a;

_result:=0;
_can_continue:=1;

PX_OBJ.cntx_psh();
_dropped.cntx_psh();
_dropped.clear();
{? _dropped.first()
|| {!
   |? {? PX_OBJ.seek(_a.REF,)
      || {? _result=0 | (PX_OBJ.TM_REA>0 & PX_OBJ.TM_REA<_result)
         || _result:=PX_OBJ.TM_REA
         ?}
      ?};
      _dropped.next()
   !}
?};
_dropped.cntx_pop();
PX_OBJ.cntx_pop();
{? _result<0
|| _result:=0
?};
_result


\dropped_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Przerabia tabele upuszczonych PX_OBJ w ten sposob, ze pozycje grupujace (np. dla zlecenia zlozonego
::       albo dla calego zamowienia) zamienia na ich pozycje.
::       Zmienia zawartosc tabeli przekazanej parametrem.
::   WE: _a - dnd_info('dropped_records') albo tabela z nia zgadna
::       [_b] - INTEGER 0/[1] - czy tabela ma pole POS
::----------------------------------------------------------------------------------------------------------------------
_ndx_pos:=_a.index('?');
_ndx_ref:=_a.ndx_tmp(,,'REF',,);

_has_pos:=1;
{? var_pres('_b')=type_of(0)
|| _has_pos:=_b
?};

PX_OBJ.cntx_psh();
PX_OBJ.clear();

:: przepisanie PX_OBJ grupujacych do tabeli _grupy
:: dodanie elementow grup do tabeli _elementy
_grupy:=tab_tmp(1,'REF','INTEGER','#PX_OBJ.ref()');
_elementy:=tab_tmp(1,'REF','INTEGER','#PX_OBJ.ref()','CRC','INTEGER','PX_OBJ.crc()');

_pos:=0;
_a.prefix();
{? _a.first()
|| {!
   |? {? PX_OBJ.seek(_a.REF,)
      || {? PX_OBJ.GRP='T'
         || _grupy.REF:=_a.REF;
            _grupy.add();
            PX_OBJ.index('TSYMBOL');
            PX_OBJ.prefix(PX_OBJ.A,#PX_OBJ.ref());
            {? PX_OBJ.first()
            || {!
               |? _elementy.blank(1);
                  _elementy.REF:=#PX_OBJ.ref();
                  _elementy.CRC:=PX_OBJ.crc();
                  _elementy.add();
                  PX_OBJ.next()
               !}
            ?};
            PX_OBJ.prefix()
         ?}
      ?};
      {? _has_pos>0
      || _pos:=_a.POS
      ?};
      _a.next()
   !}
?};

PX_OBJ.cntx_pop();

:: Usuniecie grup z tabeli dropped_records
_a.index(_ndx_ref);
{? _grupy.first()
|| {!
   |?
      _a.prefix(_grupy.REF);
      {? _a.first() || _a.del() ?};
      _grupy.next()
   !}
?};

:: Dodanie elementow grup do tabeli dropped_records
_a.index(_ndx_ref);
{? _elementy.first()
|| {!
   |?
      _a.prefix(_elementy.REF);
      {? ~_a.first()
      || _pos+=1;
         _a.blank(1);
         _a.REF:=_elementy.REF;
         _a.CRC:=_elementy.CRC;
         {? _has_pos>0
         || _a.POS:=_pos
         ?};
         _a.add()
      ?};
      _elementy.next()
   !}
?};

:: po obrobce
_a.index(_ndx_pos);
_a.prefix();
~~


\clean_queue
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dla podanej wersji czysci kolejke i usuwa pozycje z planu
::   WE: _a - PX_VER.ref()
::       [_b] - INTEGER - 0 - nie pytac czy na pewno, [1] - pytac
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_ask:=1;
{? var_pres('_b')=type_of(0)
|| _ask:=_b
?};

_result:=0;
_can_continue:=1;

PX_VER.cntx_psh();
PX_VER.clear();
{? PX_VER.seek(_px_ver)
||
   {? _ask
   || _can_continue:=FUN.ask('Czy wyczyścić kolejkę i plan wersji: %1'@[PX_VER.SYMBOL])
   ?};
   {? _can_continue>0
   ||
      {? exec('lock','px_ver',_px_ver)>0
      ||
         {? exec('lock_queue','px_ver',_px_ver)>0
         ||
            PX_GRP.cntx_psh();
            PX_GRP.index('LP');
            PX_GRP.prefix(_px_ver);
            {? PX_GRP.first()
            || {!
               |? _can_continue:=exec('delete','px_grp',PX_GRP.ref());
                  PX_GRP.first() & _can_continue>0
               !}
            ?};
            PX_GRP.cntx_pop();
            {? _can_continue>0
            || _result:=1
            ?};
            exec('unlock_queue','px_ver',_px_ver)
         ?};
         exec('unlock','px_ver',_px_ver)
      ?}
   ?}
?};
PX_VER.cntx_pop();
_result


\kom_child_chk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy dla danego PX_GRPa ktorykolwiek z jego PX_CONNow ma ustawiony podany status o komunikatach
::   WE: _a - PX_GRP.ref()
::   WY: STRING - jakie statusy sa na PX_CONNACH nalezacych do PX_GRP
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

_result:='';

PX_GRP.cntx_psh();
PX_GRP.clear();
{? PX_GRP.seek(_px_grp)
|| PX_CONN.cntx_psh();
   PX_CONN.index('PX_GRP');
   PX_CONN.prefix(PX_GRP.ref());
   {? PX_CONN.first()
   || {!
      |? {? PX_CONN.KOM_ERR='T'
         || _result+='E'
         ?};
         {? PX_CONN.KOM_WARN='T'
         || _result+='W'
         ?};
         {? PX_CONN.KOM_INFO='T'
         || _result+='I'
         ?};
         PX_CONN.next() & _result=''
      !}
   ?};
   PX_CONN.cntx_pop()
?};
PX_GRP.cntx_pop();
_result


\px_grp_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Selekcja kolejki w osobnym oknie
::----------------------------------------------------------------------------------------------------------------------
_context:=PxSelect.Context;
PxSelect.Context:=_context+'|MENU';
PxSelect.Pxgrp.TAB.win_sel(PxSelect.Pxgrp.WERT);
PxSelect.Pxgrp.TAB.select(,1,5);
PxSelect.Context:=_context;
~~


\verify_groper
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Weryfikuje kolejke pod wzgledem zawartosci operacji ktore zostaly zaplanowane w grupach
::       operacji w Planie operacyjnym. W przypadku gdy w grupie jest zlecenie, ktorego ZGP zostal zaplanowany
::       w grupie operacji, a caly PX_GRP nie znajduje sie w planie operacyjnym nie mozna pozwolic
::       na zaplanowanie takiej kolejki, poniewaz plan strategiczny rozjedzie sie z grupami operacji
::   WE: _a - PX_VER.ref() - wersja ktorej kolejke analizowac
::   WY: 0 - negatywny wynik weryfikacji
::       1 - pozytywny wynik weryfikacji - mozna planowac
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_result:=1;
_can_continue:=1;

_args_kom:=exec('add_komm_a','px_komm');
_args_kom.PX_VER:=_px_ver;
_args_kom.TYP:=exec('type_error','px_komm');
_args_kom.SRC_KIND:=exec('src_grop_verify','px_komm');
PX_GRP.cntx_psh();
:: Przetwarzamy tylko niewykonane w calosci i niezablokowane - one i tak nie beda planowane
{? exec('is_whatif','px_ver',_px_ver)>0
|| PX_GRP.index('PLAN_S');
   PX_GRP.prefix(_px_ver,'N','N','N','Z')
|| PX_GRP.index('PLAN');
   PX_GRP.prefix(_px_ver,'N','N','Z')
?};
{? PX_GRP.first()
|| {!
   |?
      {? PX_VAR.PL_GROP>0
      || {? exec('sequence_chk','px_grop')=0
         || _result:=0;
::          Dodaje komunikat do PX_KOMM
            _msg:='Obiekt: %1 jest zgrupowany w kilku grupach o różnej sekwencji planowania.'[PX_GRP.SYMBOL];
            _args_kom.PX_GRP:=PX_GRP.ref();
            _args_kom.MESSAGE:=_msg;
            exec('add_komm','px_komm',_args_kom)
         ?};

         {? _result>0
         || exec('del_kommy','px_komm','PX_GRP',
                                          PX_GRP.ref(),
                                          exec('type_error','px_komm'),
                                          exec('src_grop_verify','px_komm'))
         ?}
      ?};
      {? _result>0 & exec('verify_groper_core','px_grp')=0
      || _result:=0
      ?};
      PX_GRP.next()
   !}
?};
PX_GRP.prefix(_px_ver,'N','N','G');
{? _result>0 & PX_GRP.first()
|| {!
   |?
      {? PX_GRP.GROP_SEQ='' | PX_GRP.GROP_SEQ='X'
      ||  _result:=-1;

::       Dodaje komunikat do PX_KOMM
         _msg:='Grupa operacji: %1 ma nieprawidłową sekwencję.'[PX_GRP.SYMBOL];
         _args_kom.PX_GRP:=PX_GRP.ref();
         _args_kom.MESSAGE:=_msg;
         exec('add_komm','px_komm',_args_kom)
      ?};

      {? exec('direction_chk','px_grop')=0
      ||
         _result:=-1;

::       Dodaje komunikat do PX_KOMM
         _msg:='Zwrot grupy operacji: %1 nie jest zgodny ze zwrotem zleceń w kolelce planu. Należy użyć akcji Uzgodnij zwrot.'[PX_GRP.SYMBOL];
         _args_kom.PX_GRP:=PX_GRP.ref();
         _args_kom.MESSAGE:=_msg;
         exec('add_komm','px_komm',_args_kom)
      ?};
      {? _result>0
      || exec('del_kommy','px_komm','PX_GRP',
                                       PX_GRP.ref(),
                                       exec('type_error','px_komm'),
                                       exec('src_grop_verify','px_komm'))
      ?};
      PX_GRP.next()
   !}
?};


PX_GRP.cntx_pop();
_result


\verify_groper_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Weryfikuje element kolejki pod wzgledem zawartosci operacji ktore zostaly zaplanowane w grupach
::       operacji w Planie operacyjnym. W przypadku gdy w grupie jest zlecenie, ktorego ZGP zostal zaplanowany
::       w grupie operacji, a caly PX_GRP nie znajduje sie w planie operacyjnym nie mozna pozwolic
::       na zaplanowanie takiej kolejki, poniewaz plan strategiczny rozjedzie sie z grupami operacji
::   WE: [_a] - PX_GRP.ref - element w kolejce lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_result:=1;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_OBJ.cntx_psh();
   ZGH.cntx_psh();
   ZGH.index('ZLNR');
   ZGP.cntx_psh();
   ZGP.index('NRPP');
   PX_CONN.cntx_psh();
   PX_CONN.index('PX_GRP');
:: Zliczam ilosc w planie operacyjnym
   _il_oper:=exec('px_grp_oper','px_tie',PX_GRP.ref());
   _il_gr:=PX_GRP.ILOSC;

   PX_CONN.prefix(PX_GRP.ref());
   {? PX_CONN.first()
   || {!
      |?
         _can_continue:=1;

::       Podczytanie PX_OBJ
         PX_CONN.PX_OBJ();

         {? PX_OBJ.ZL<>null()
         ||
            ZGH.prefix(PX_OBJ.ZL);
            {? ZGH.first()
            || {!
               |? ZGP.prefix(ZGH.ref(),'N');
                  {? ZGP.first()
                  || {!
                     |?
::                      Obliczam ilosc dla ZGPa w planie operacyjnym w grupie
                        _il_zgp:=exec('zgp_planned_il','po_ogr',ZGP.ref());
                        {? _il_zgp>0
                        ||
                           {? _il_oper=0 | _il_oper<_il_gr
                           ||
::                            Jesli grupa jest w planie operacyjnym, ale nie w calosci tylko w czesci to
::                            jesli jakiekolwiek ZGP jest w planie grupy to weryfikacja konczy sie niepowodzeniem
                              _can_continue:=0;
                              _result:=0;
::                            Dodaje komunikat do PX_KOMM
                              _msg:='Obiekt: %1 ma operację w grupie operacji, ale nie jest zaplanowany w całości w Planie operacyjnym.'[PX_OBJ.SYMBOL];
                              _args_kom:=exec('add_komm_a','px_komm');
                              _args_kom.TYP:=exec('type_error','px_komm');
                              _args_kom.PX_GRP:=PX_GRP.ref();
                              _args_kom.PX_OBJ:=PX_OBJ.ref();
                              _args_kom.MESSAGE:=_msg;
                              _args_kom.PX_VER:=PX_GRP.PX_VER;
                              _args_kom.SRC_KIND:=exec('src_grop_verify','px_komm');

                              exec('add_komm','px_komm',_args_kom)
                           ?}
                        ?};
                        ZGP.next() & _can_continue>0
                     !}
                  ?};
                  ZGH.next() & _can_continue>0
               !}
            ?}
         ?};
         PX_CONN.next()
      !}
   ?};

:: jesli weryfikacja przebiegla prawidlowo to usuwam dotychczasowe komunikaty o tej weryfikacji
   {? _can_continue>0
   || exec('del_kommy','px_komm','PX_GRP',
                                 PX_GRP.ref(),
                                 exec('type_error','px_komm'),
                                 exec('src_grop_verify','px_komm'))
   ?};
   ZGH.cntx_pop();
   ZGP.cntx_pop();
   PX_OBJ.cntx_pop();
   PX_CONN.cntx_pop();
   ~~
?};
PX_GRP.cntx_pop();
_result


\pxvaraddilfd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Format wyswietlania dla pola PX_VAR.ADD_IL
::----------------------------------------------------------------------------------------------------------------------
{? PX_OBJ.M=null()
|| ''
|| 'out_prec='+$PX_OBJ.M().DOKL
?}


\pxvaraddilfe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Format redagowania dla pola PX_VAR.ADD_IL
::----------------------------------------------------------------------------------------------------------------------
{? PX_OBJ.M=null()
|| ''
|| 'in_prec='+$PX_OBJ.M().DOKL
?}


\filter_diff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Filtruje zapisy w panelu porownywania kolejek
::   WE: _a - rodzaj zapisu: → ← = ≠
::       Kontekst wywolania: PxSelect.QueCmp.TAB
::----------------------------------------------------------------------------------------------------------------------
PxSelect.QueCmp.TAB.f_set('OBJ_SYM',,'CMP=\':_a\'',_a)


\px_grp_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Selekcja surowcow do grupy planu strategicznego
::----------------------------------------------------------------------------------------------------------------------
_rule:="
   {? PX_VAR.VIE_VER=exec('get_mainversion','px_ver')
   || {? PX_GRP.UID_SRC<>''
      || PX_GRP.index('UID');
         PX_GRP.prefix(PX_GRP.UID_SRC);
         {? PX_GRP.first()
         ||
::            {? exec('is_zlim_ploper','zl_lim01',PX_POZ.PL_OPER)
::            || exec('sel_zlim_ploper','zl_lim01',PX_POZ.PL_OPER)
::            |? exec('is_zlim_pxstag','zl_lim01',PX_POZ.PX_STAGE)
::            || exec('sel_zlim_pxstag','zl_lim01',PX_POZ.PX_STAGE)
            {? exec('is_sur_pxgrp','px_sur',PX_GRP.ref())
            || exec('sel_sur_pxgrp','px_sur',PX_GRP.ref())
            || FUN.info('Do grupy planu nie przypisano surowców.'@)
            ?}
         ?}
      ?}
   ?}
";
exec('FindAndGet','#table',PX_GRP,cur_tab(1,1).PX_GRPI,,_rule,~~);
~~


\has_wyk_px
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy istnieja wykonania dla danego PX_GRP w planie strategicznym
::   WE: _a - PX_GRP.ref()
::       [_b] - PX_VER.ref() - wersja w ktorej zliczac lub wersja glowna jesli nie podana
::   WY: 0 - brak wykonan
::       1 - istnieja wykonania
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_px_ver:=exec('get_mainversion','px_ver');
{? var_pres('_b')=type_of(PX_VER.ref())
|| _px_ver:=_b
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh(); PX_GRP.clear();
PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');
PX_POZ.cntx_psh();
PX_POZ.index('PX_POZ');
{? PX_GRP.seek(_px_grp)
||
   PX_CONN.prefix(PX_GRP.ref());
   {? PX_CONN.first()
   || {!
      |? PX_POZ.prefix(_px_ver,PX_CONN.PX_OBJ);
         {? PX_POZ.first()
         || {!
            |? {? exec('has_wyki','px_poz',PX_POZ.ref())>0
               || _result:=1;
                  _can_continue:=0
               ?};
               PX_POZ.next() & _can_continue>0
            !}
         ?};
         PX_CONN.next()
      !}
   ?}
?};
PX_POZ.cntx_pop();
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
_result


\has_wyk_pl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy istnieja wykonania dla danego PX_GRP w planie operacyjnym
::   WE: _a - PX_GRP.ref()
::   WY: 0 - brak wykonan
::       1 - istnieja wykonania
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh(); PX_GRP.clear();
PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');
PX_OBJ.cntx_psh();
{? PX_GRP.seek(_px_grp)
||
   PX_CONN.prefix(PX_GRP.ref());
   {? PX_CONN.first()
   || {!
      |?
::       Podczytanie PX_OBJ
         PX_CONN.PX_OBJ();

         {? PX_OBJ.ZL<>null()
         ||
::          Poniewaz zlecenie moze miec PL_OGRY sprawdzam specjalna funkcja
            {? exec('has_wyk_zl','po_wyk',PX_OBJ.ZL)>0
            || _result:=1;
               _can_continue:=0
            ?}
         ||
::          Kazdy inny obiekt sprawdzam za pomoca PL_PARTow
            PL_PART.cntx_psh();
            PL_PART.index('PX_OBJ');
            PL_PART.prefix(PX_OBJ.ref());
            {? PL_PART.first()
            || {!
               |? {? exec('has_wyk_plpart','po_wyk',PL_PART.ref())>0
                  || _result:=1;
                     _can_continue:=0
                  ?};
                  PL_PART.next() & _can_continue>0
               !}
            ?};
            PL_PART.cntx_pop()
         ?};
         PX_CONN.next() & _can_continue>0
      !}
   ?}
?};
PX_OBJ.cntx_pop();
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
_result


\has_wyk_zlgd
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy istnieja wykonania dla danego PX_GRP na przewodnikach
::   WE: _a - PX_GRP.ref()
::   WY: 0 - brak wykonan
::       1 - istnieja wykonania
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh(); PX_GRP.clear();
PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');
PX_OBJ.cntx_psh();
{? PX_GRP.seek(_px_grp)
||
   PX_CONN.prefix(PX_GRP.ref());
   {? PX_CONN.first()
   || {!
      |?
::       Podczytanie PX_OBJ
         PX_CONN.PX_OBJ();

         {? PX_OBJ.ZL<>null()
         || {? exec('has_zlgd','zl_common',PX_OBJ.ZL)>0
            || _result:=1;
               _can_continue:=0
            ?}
         ?};
         PX_CONN.next() & _can_continue>0
      !}
   ?}
?};
PX_OBJ.cntx_pop();
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
_result


\get_symbol
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dla nowo tworzonych grup zwraca symbol
::   WE: _a - PX_TEX.ref() - ref przepisu
::   WY: STRING - symbol grupy
::----------------------------------------------------------------------------------------------------------------------
_tex:=_a;

_result:='<BRAK - technologii>';

PX_TEX.cntx_psh(); PX_TEX.clear();
{? PX_TEX.seek(_tex)
|| _result:=PX_TEX.SYMBOL
?};
PX_TEX.cntx_pop();
_result


\get_nazwa
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dla nowo tworzonych grup zwraca nazwe
::   WE: _a - PX_TEX.ref() - ref przepisu
::   WY: STRING - nazwa grupy
::----------------------------------------------------------------------------------------------------------------------
_tex:=_a;

_result:='<BRAK - technologii>';

PX_TEX.cntx_psh(); PX_TEX.clear();
{? PX_TEX.seek(_tex)
|| _result:='Wersja przepisu: %1'[PX_TEX.VER]
?};
PX_TEX.cntx_pop();
_result


\upd_termin
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Aktualizuje pole PX_GRP.TM_END na podstawie terminow realizacji obiektow
::   WE: _a - PX_GRP.ref()
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

_result:=1;

PX_GRP.cntx_psh(); PX_GRP.clear();
{? PX_GRP.seek(_px_grp)
||
   _before:=PX_GRP.TM_END;
   _term:=exec('min_termin','px_grp',PX_GRP.ref());

   {? _before<>_term
   || _endd:=exec('tm_stamp2date','#tm_stamp',_term);
      _endt:=exec('tm_stamp2time','#tm_stamp',_term);
      PX_GRP.TM_END:=_term;
      PX_GRP.ENDD:=exec('get','daty',_endd);
      PX_GRP.ENDT:=_endt;
      _result:=PX_GRP.put();

      {? _result>0
      ||
::       Uaktualniam automatyczne punkty czasowe na grupie
         _result:=exec('auto_point_upd','px_point',PX_GRP.ref())
      ?}
   ?}
|| _result:=0
?};
PX_GRP.cntx_pop();
_result


\mask_current
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca niearchiwalna maske dla tabeli PX_GRP
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
PX_GRP.name()


\get_inherited
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Na podstawie przekazanej grupy znajduje w podanej wersji grupe ktora powstala na jej podstawie
::   WE: _a - PX_GRP.ref() - grupa
::       _b - PX_VER.ref() - wersja
::   WY: PX_GRP.ref() lub null()
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_px_ver:=_b;

_result:=null();

PX_GRP.cntx_psh(); PX_GRP.clear();
{? PX_GRP.seek(_px_grp)
||
   PX_GRP.index('UID_SRC');
   PX_GRP.prefix(_px_ver,PX_GRP.UID);
   {? PX_GRP.first()
   || _result:=PX_GRP.ref()
   ?}
?};
PX_GRP.cntx_pop();
_result


\px_grp_corr_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Akcja popraw na pozycji drzewa (przed grupa rekordow)
::   WE: _a - nazwa obiektu, np. '@.PxSelect.Pxgrp'
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='T';
sel_nchk();

_one_ver:=exec('is_one_version','px_param');

_obiekt:=($_a)();

_ref:=_obiekt.TAB.ref();

_sel:=_obiekt.TAB.sel_aget();

_Tab:={? _one_ver=0 || _obiekt.TAB ?};

KOMM.init(250,,'Grupowe poprawianie elementów kolejki'@);

PX_OBJ.cntx_psh();
PX_GRP.cntx_psh(); PX_GRP.clear();
PX_CONN.cntx_psh(); PX_CONN.clear();

:: Wartosci poczatkowe redagowanych pol
PX_VAR.ADD_DIR:=0;
PX_VAR.GRN_DATA:=date(0,0,0);
PX_VAR.GRN_TIME:=time(0,0,0);
PX_VAR.PL_FORCE:='';

_can_continue:=1;

:: Wyznaczyc minimalny termin realizacji oraz sposob ustawienia znacznikow PL_FORCE i DIR:
:: PX_VAR.GR_FORCE: 'T' - wszystkie 'T', 'N' - wszystkie 'N', '' - rozne wartosci PX_GRP.PL_FORCE
:: PX_VAR.GR_DIR: 1 - wszystkie 1, -1 - wszystkie -1, 0 - rozne wartosci PX_GRP.DIR
PX_VAR.TM_END:=0;
PX_VAR.GR_FORCE:=''; _gr_forc:=obj_new(2); _gr_forc[1]:=_gr_forc[2]:=0;
PX_VAR.GR_DIR:=0; _gr_dir:=obj_new(2); _gr_dir[1]:=_gr_dir[2]:=0;
{? _sel.first()
|| {!
   |? {? _obiekt.TAB.seek(_sel.REF,)
      ||
         {? _one_ver>0
         ||
            {? var_pres('_Tab')>100
            || obj_del(_Tab)
            ?};
            _Tab:=exec('tab','px_grps')
         ?};
         {? _Tab.PX_CONN=''
         ||
::          Stoje na wezle reprezentujacym PX_GRP
            PX_GRP.clear();
            {? PX_GRP.seek(_Tab.PX_GRPI,8+_Tab.PX_GRPI)
            ||
               {? exec('lock','px_grp',,2)=0
               || _can_continue:=0
               ?};
               {? exec('is_blocked','px_grp')>0
               || _msg:='Element kolejki: %1 jest zablokowany. Redagowanie grupowe niedozwolone.'@[PX_GRP.SYMBOL];
                  KOMM.add(_msg,2);
                  _can_continue:=0
               ?};
               _tm:=exec('min_termin','px_grp',PX_GRP.ref());
               {? PX_VAR.TM_END=0 | _tm<PX_VAR.TM_END || PX_VAR.TM_END:=_tm ?};
               {? PX_GRP.PL_FORCE='N' || _gr_forc[1]+=1 || _gr_forc[2]+=1 ?};
               {? PX_GRP.DIR<0 || _gr_dir[1]+=1 || _gr_dir[2]+=1 ?}
            ?}
         || KOMM.add('Redagowanie grupowe niedozwolone, zaznaczono pozycję grupy: %1'@[_obiekt.TAB.TXT],2);
            _can_continue:=0
         ?}
      ?};
      _sel.next()
   !}
?};
{? _gr_forc[1]>0 & _gr_forc[2]=0 || PX_VAR.GR_FORCE:='N'
|? _gr_forc[1]=0 & _gr_forc[2]>0 || PX_VAR.GR_FORCE:='T'
?};
{? _gr_dir[1]>0 & _gr_dir[2]=0 || PX_VAR.GR_DIR:=-1
|? _gr_dir[1]=0 & _gr_dir[2]>0 || PX_VAR.GR_DIR:=1
?};

{? _can_continue>0
||
:: OKNO EDYCYJNE
   exec('px_var_win_edit','px_grp','REDG');
   {? PX_VAR.edit("exec('validate_agr','px_grp',!PxSelect.Pxgrp)")>0
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? _sel.first()
   || {!
      |? {? _obiekt.TAB.seek(_sel.REF,)
         ||
            {? _one_ver>0
            ||
               {? var_pres('_Tab')>100
               || obj_del(_Tab)
               ?};
               _Tab:=exec('tab','px_grps')
            ?};

            {? _Tab.PX_CONN=''
            ||
::             Stoje na wezle reprezentujacym PX_GRP
               PX_GRP.clear();
               {? PX_GRP.seek(_Tab.PX_GRPI,8+_Tab.PX_GRPI)
               ||
                  {? _one_ver>0
                  ||
                     {? PX_VAR.PX_SET<>null()
                     ||
::                      Praca na zestawie - aktualizuje rekord w kolejce zestawu
                        {? var_pres('_args_grps')>100
                        || obj_del(_args_grps)
                        ?};
                        _args_grps:=exec('add_a','px_grps');
                        _args_grps.PX_GRP:=PX_GRP.ref();
                        _args_grps.PX_SET:=PX_VAR.PX_SET;
                        _args_grps.GRN_DATA:=PX_VAR.GRN_DATA;
                        _args_grps.GRN_TIME:=PX_VAR.GRN_TIME;
                        _args_grps.DIR:=PX_VAR.ADD_DIR;
                        exec('update','px_grps',_args_grps.PX_GRP,_args_grps.PX_SET,_args_grps);

::                      Aktualizacja punktow czasowych
                        {? var_pres('_args_poi')>100
                        || obj_del(_args_poi)
                        ?};
                        _tm_grn:=exec('create','#tm_stamp',PX_VAR.GRN_DATA,PX_VAR.GRN_TIME);
                        _args_poi:=exec('auto_args_grps','px_point',,_tm_grn);
                        _args_poi.DEL_MANUAL:=1;
                        exec('auto_point','px_point',_args_poi)
                     ?}
                  ?};

                  {? _one_ver=0 | (_one_ver>0 & PX_VAR.PX_SET=PX_GRP.SET_SRC)
                  ||
::                   Praca bez zestawow lub na zestawie zrodlowym - modyfikuje rekord zrodlowy
                     {? PX_VAR.ADD_DIR<>0
                     || PX_GRP.DIR:=PX_VAR.ADD_DIR
                     ?};
                     {? PX_VAR.PL_FORCE<>''
                     || PX_GRP.PL_FORCE:=PX_VAR.PL_FORCE
                     ?}
                  ?};

                  _can_continue:=PX_GRP.put();

                  {? exec('is_px_set','px_param')=0
                  ||
::                   Ustawiam daty na PX_GRP
                     {? PX_VAR.GRN_DATA<>date(0,0,0)
                     || exec('dates_set','px_grp',PX_GRP.ref(),PX_VAR.GRN_DATA,PX_VAR.GRN_TIME)
                     ?}
                  ?}
               ?}
            ?}
         ?};
         _sel.next()
      !};

      {? _can_continue>0
      || exec('prenumber','px_grp',PxSelect.VER_QUE);
         exec('Pxgrp_refresh','px_grp',_obiekt)
      ?}
   ?}
?};

:: Odblokowuje wszystkie zablokowane grupy
{? _sel.first()
|| {!
   |? {? _obiekt.TAB.seek(_sel.REF,)
      ||
         {? _one_ver>0
         ||
            {? var_pres('_Tab')>100
            || obj_del(_Tab)
            ?};
            _Tab:=exec('tab','px_grps')
         ?};

         {? _Tab.PX_CONN=''
         ||
::          Stoje na wezle reprezentujacym PX_GRP
            PX_GRP.clear();
            {? PX_GRP.seek(_Tab.PX_GRPI,8+_Tab.PX_GRPI)
            || exec('unlock','px_grp')
            ?}
         ?}
      ?};
      _sel.next()
   !}
?};

KOMM.select();

::przywracam kursor na rekord na ktorym stalem przed poprawieniem
_obiekt.TAB.seek(_ref);

PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
PX_CONN.cntx_pop();

1


\validate_agr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Walidacja okna redakcyjnego zmiennej PX_VAR: REDG
::   WY: '' lub akronim pola
::----------------------------------------------------------------------------------------------------------------------
_result:='';

PX_VAR.TM_GRN:=exec('create','#tm_stamp',PX_VAR.GRN_DATA,PX_VAR.GRN_TIME);

_can_continue:=1;

:: Przy planowaniu wstecz nie mozna wymuszac kontynuacji planowania po przekroczeniu terminu
{? PX_VAR.ADD_DIR=-1 & PX_VAR.PL_FORCE='T'
|| FUN.emsg('W przypadku planowania wstecz nie można wymuszać kontynuacji planowania po przekroczeniu terminu.'@);
   _result:='ADD_DIR';
   _can_continue:=0
?};

:: Przy zachowaniu zwrotu planowania nie mozna wymuszac kontynuacji planowania po przekroczeniu terminu,
:: gdy jakakolwiek zaznaczona grupa jest planowana wstecz
{? _can_continue>0 & PX_VAR.ADD_DIR=0 & PX_VAR.PL_FORCE='T' & PX_VAR.GR_DIR<=0
|| FUN.emsg(
      'Przy zachowaniu zwrotu planowania nie można wymuszać kontynuacji planowania po przekroczeniu terminu,\n'
      'gdy którakolwiek zaznaczona grupa jest planowana wstecz.'@
   );
   _result:='ADD_DIR';
   _can_continue:=0
?};

:: Przy zachowaniu znacznika kontynuacji, gdy dowolny jest ustawiony na 'T', nie mozna ustawic planowania wstecz
{? _can_continue>0 & PX_VAR.PL_FORCE='' & PX_VAR.GR_FORCE<>'N'
|| FUN.emsg(
      'Przy planowaniu wstecz, jeżeli ma być zachowany znacznik kontynuacji planowania po przekroczeniu terminu,\n'
      'nie może być on ustawiony w żadnej zaznaczonej grupie.'@
   );
   _result:='ADD_DIR';
   _can_continue:=0
?};

{? _can_continue>0 & PX_VAR.TM_GRN<>0
||
   {? PX_VAR.ADD_DIR<>0
   ||
::    Planowanie wstecz i do przodu
      {? PX_VAR.TM_END<PX_VAR.TM_GRN
      || FUN.emsg('Podano za późny termin realizacji.'@);
         _result:='GRN_DATA'
      |? PX_VAR.GRN_DATA<date()
      || {? PX_VAR.ADD_DIR=1
         || FUN.emsg('Nie można planować w przód z datą niższą od bieżącej.'@)
         || FUN.emsg('Nie można planować wstecz dla daty niższej od bieżącej.'@)
         ?};
         _result:='GRN_DATA'
      ?}
   ?}
?};
{? _can_continue>0 & exec('is_px_set','px_param')>0
||
   _one_ver:=exec('is_one_version','px_param');
:: Walidacja dla zestawow planistycznych
   _obiekt:=($_a)();

   _sel:=_obiekt.TAB.sel_aget();

   {? _sel.first()
   || {!
      |? {? _obiekt.TAB.seek(_sel.REF,)
         ||
            {? _one_ver>0
            ||
               {? var_pres('_Tab')>100
               || obj_del(_Tab)
               ?};
               _Tab:=exec('tab','px_grps')
            ?};

            {? _Tab.PX_CONN=''
            ||
::             Stoje na wezle reprezentujacym PX_GRP
               PX_GRP.clear();
               {? PX_GRP.seek(_Tab.PX_GRPI,8+_Tab.PX_GRPI)
               || _result:=exec('validate_poi','px_grp',1);
                  {? _result<>''
                  || _can_continue:=0
                  ?}
               ?}
            ?}
         ?};
         _sel.next() & _can_continue>0
      !}
   ?}
?};

_result


\move_grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Przesuniecie jednej grupy o (n) pozycji w gore albo w dol
::   WE: _a - ilosc pozycji, o ktore przesuwamy (0 - pytanie o ilosc pozycji)
::       _b - kierunek (1 - w gore, -1 - w dol)
::----------------------------------------------------------------------------------------------------------------------
_static:=exec('is_grps_static','px_param');

_px_grp:=cur_tab(1,1);
{? _static=0
|| {? _px_grp.TYP<>'PX_GRP'
   || FUN.info('Przesuwać można tylko grupy.'@);
      return()
   ?}
?};

_num:=_a;
_dir:=_b;

{? _num=0
|| undefine();
   define('NUM',1,'O ile pozycji przesunąć?'@,,10,,0);
   def_btn('text=%1'['&Zapisz'@],'key:F2');
   def_btn('text=%1'['&Anuluj'@],'key:Esc');
   {? def_edit(,FUN.TYT)
   || _num:=DEFINE.NUM
   || return()
   ?}
?};

_records:=tab_tmp(1,'POS','INTEGER','POS','REF','INTEGER','REF','CRC','INTEGER','CRC');
_records.POS:=1;
_records.REF:=#_px_grp.ref();
_records.CRC:=0;
_records.add();
_px_grp.cntx_psh();
{? _static=0 || _px_grp.prefix(0) ?};
{! _it:=1.._num |! {? _dir>0 || _px_grp.prev() || _px_grp.next() ?} !};
_dest_rec:=_px_grp.ref();
_px_grp.cntx_pop();
{? _dest_rec<>null()
|| {? _static
   || exec('dnd_renum','px_grps',0,_records,_dest_rec)
   || exec('dnd_renum','px_grp',0,_records,_dest_rec)
   ?}
?};
~~


\move_grp_up
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Przesuniecie jednej grupy o (n) pozycji w gore
::   WE: [_a] - ilosc pozycji, o ktore przesuwamy (0 - pytanie o ilosc pozycji)
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _num:=_a || _num:=1 ?};
_dir:=1;
exec('move_grp','px_grp',_num,_dir);
~~


\move_grp_down
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Przesuniecie jednej grupy o (n) pozycji w dol
::   WE: [_a] - ilosc pozycji, o ktore przesuwamy (0 - pytanie o ilosc pozycji)
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _num:=_a || _num:=1 ?};
_dir:=-1;
exec('move_grp','px_grp',_num,_dir);
~~


\move_grp_to
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Przesuniecie jednej grupy w miejsce podanego numeru (wskazany numer przesuwany w dol)
::----------------------------------------------------------------------------------------------------------------------
_static:=exec('is_grps_static','px_param');

_px_grp:=cur_tab(1,1);

{? _px_grp.sel_size()>0
|| return()
?};

{? _static=0
|| {? _px_grp.TYP<>'PX_GRP'
   || FUN.info('Przesuwać można tylko grupy.'@);
      return()
   ?}
?};

undefine();
define('LP',0,'Podaj numer grupy'@,,10,,0);
def_btn('text=%1'['&Zapisz'@],'key:F2');
def_btn('text=%1'['&Anuluj'@],'key:Esc');
{? def_edit("{? DEFINE.LP<=0 || FUN.info('Podaj wartość większą od zera.'@); 0 || 1 ?}",FUN.TYT)
|| _records:=tab_tmp(1,'POS','INTEGER','POS','REF','INTEGER','REF','CRC','INTEGER','CRC');
   _records.POS:=1;
   _records.REF:=#_px_grp.ref();
   _records.CRC:=0;
   _records.add();
   {? _static
   || PX_GRPS.cntx_psh();
      PX_GRPS.index('LP1');
      _kind:='Z';
      {? PX_GRPS.PX_GRP().GROPS<>null()
      || _kind:='G'
      ?};
      PX_GRPS.prefix('T',PX_VAR.VER_QUE,PX_VAR.PX_SET,_kind,DEFINE.LP);
      {? PX_GRPS.first()
      || _dest_rec:=PX_GRPS.ref()
      || _dest_rec:=null()
      ?};
      PX_GRPS.cntx_pop()
   || _px_grp.cntx_psh();
      _px_grp.blank(1);
      _px_grp.TYP:='PX_GRP';
      _px_grp.LP_Q:=DEFINE.LP;
      {? _px_grp.find_rec()
      || _dest_rec:=_px_grp.ref()
      || _dest_rec:=null()
      ?};
      _px_grp.cntx_pop()
   ?};
   {? _dest_rec<>null()
   || {? _static
      || exec('dnd_renum','px_grps',0,_records,_dest_rec)
      || exec('dnd_renum','px_grp',0,_records,_dest_rec)
      ?}
   || FUN.info('Brak elementu docelowego o podanym numerze.'@)
   ?}
?};
undefine();
~~


\move_grp_to_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Przesuniecie zaznaczonych grup w miejsce podanego numeru (wskazany numer przesuwany w dol)
::----------------------------------------------------------------------------------------------------------------------
_static:=exec('is_grps_static','px_param');

_px_grp:=cur_tab(1,1);

_records:=_px_grp.sel_aget();

_px_grp.cntx_psh();
_px_grp.clear();
:: Usuniecie z zaznaczenia elementow grup - przesuwane sa tylko grupy
{? _records.first()
|| {!
   |? {? _static=0 & _px_grp.seek(_records.REF,)
      || {? _px_grp.TYP='PX_GRP'
         || _records.next()
         || _records.del()
         ?}
      || _records.next()
      ?}
   !}
?};

{? _records.size()>0
|| KOMM.init(250,'Przesuwanie grup w kolejce planu'@);
   undefine();
   define('LP',0,'Podaj numer grupy'@,,10,,0);
   def_btn('text=%1'['&Zapisz'@],'key:F2');
   def_btn('text=%1'['&Anuluj'@],'key:Esc');
   {? def_edit("{? DEFINE.LP<=0 || FUN.info('Podaj wartość większą od zera.'@); 0 || 1 ?}",FUN.TYT)
   || {? _static
      || PX_GRPS.cntx_psh();
         PX_GRPS.index('LP1');
         PX_GRPS.prefix('T',PX_VAR.VER_QUE,PX_VAR.PX_SET,DEFINE.LP);
         {? PX_GRPS.first()
         || _dest_rec:=PX_GRPS.ref()
         || _dest_rec:=null()
         ?};
         PX_GRPS.cntx_pop()
      || _px_grp.cntx_psh();
         _px_grp.blank(1);
         _px_grp.TYP:='PX_GRP';
         _px_grp.LP_Q:=DEFINE.LP;
         {? _px_grp.find_rec()
         || _dest_rec:=_px_grp.ref()
         || _dest_rec:=null()
         ?};
         _px_grp.cntx_pop()
      ?};
      {? _dest_rec<>null()
      || sel_nchk();
         {? _static
         ||
::          Przepisanie zaznaczonych rekordow to tabeli zgodnej z formatem dnd_info('dropped_records')
            _recrds:=tab_tmp(1,'POS','INTEGER','POS','REF','INTEGER','REF','CRC','INTEGER','CRC');
            _recrds.POS:=0;
            {? _records.first()
            || {!
               |? _recrds.POS+=1;
                  _recrds.REF:=_records.REF;
                  _recrds.CRC:=_records.CRC;
                  _recrds.add();
                  _records.next()
               !}
            ?};
            exec('dnd_renum','px_grps',0,_recrds,_dest_rec)
         || exec('dnd_renum','px_grp',0,_records,_dest_rec)
         ?}
      || FUN.info('Brak elementu docelowego o podanym numerze.'@)
      ?}
   ?};
   KOMM.select();
   undefine()
|| FUN.info('Przesuwać można tylko grupy.'@)
?};
_px_grp.cntx_pop();
~~


\lock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Blokada obiektu grupujacego
::   WE: [_a] - PX_GRP.ref(), a jak brak parametru, to ustawiony rekord w tabeli PX_GRP
::       [_b] - czy wyswietlac dialogi 0 - nie wyswietlac
::                                     1 - wyswietlac
::                                     2 - dodawac do KOMMa
::                                     (domyslnie 1 - wyswietlac)
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _px_grp:=_a
?};

_display:=1;
{? var_pres('_b')=type_of(0)
|| _display:=_b
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _px_grp<>null()
|| PX_GRP.clear();
   {? PX_GRP.seek(_px_grp)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   BLK.index('AMR');
   BLK.prefix('PX_GRP',8+$PX_GRP.ref(),#PX_GRP.ref());
   {? ~BLK.first()
   || BLK.ACR:='PX_GRP';
      BLK.MSK:=PX_GRP.name();
      BLK.REF:=PX_GRP.ref();
      BLK.SES_ID:=PX_GRP.ses_id();
      _result:=BLK.add()
   || _result:=1
   ?};
   {? _result
   || {? BLK.r_lock(1,1,1)
      || BLK.SES_ID:=PX_GRP.ses_id();
         _result:=BLK.put()
      ||
         _msg:='Element kolejki %1. %2  jest redagowany przez użytkownika \'%3\'\n'
               ' na terminalu \'%4\'.'@[$PX_GRP.LP_Q,PX_GRP.SYMBOL,PX_GRP.ses_info(BLK.SES_ID,'log_name'),PX_GRP.ses_info(BLK.SES_ID,'log_tty')];
         {? _display=1
         || FUN.emsg(_msg)
         || KOMM.add(_msg,2)
         ?};
         _result:=0
      ?}
   ?}
?};
PX_GRP.cntx_pop();
_result


\unlock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Usuniecie blokady obiektu grupujacego
::   WE: _a - PX_GRP.ref(), a jak brak parametru, to ustawiony rekord w tabeli PX_GRP
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _px_grp:=_a
|| _px_grp:=PX_GRP.ref()
?};
BLK.index('AMR');
BLK.prefix('PX_GRP',8+$_px_grp,#_px_grp);
{? BLK.first()
|| {? PX_GRP.ses_id()=BLK.SES_ID
   || BLK.r_unlock();
      BLK.del()
   ?}
?};
~~


\poz_prefix_mode
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Zwraca w jaki sposob prefiksowac PX_POZy dla danego PX_GRPa
::   WE: [_a] - PX_GRP.ref - jesli nie podane to biezacy
::       [_b] - INTEGER - 0/ 1 czy badac czy wersja jest zolta/biala i na podstawie tego
::                        rowniez decydowac (domyslnie tak)
::   WY: STRING - 'DIRECT' - bezposrednio na podstawie podanego PX_GRPa
::                'SOURCE' - prefiksowac ze zrodlowego PX_GRPa na podstawie PX_GRP.UID_SRC
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _px_grp:=_a
?};

_chk_yellow:=1;
{? var_pres('_b')=type_of(0)
|| _chk_yellow:=_b
?};

_result:='';
_can_continue:=1;

PX_GRP.cntx_psh();
{? _px_grp<>null()
|| PX_GRP.clear();
   {? PX_GRP.seek(_px_grp)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? PX_GRP.PX_VER=exec('get_mainversion','px_ver')
   ||
::    Jesli PX_GRP nalezy do glownej wersji to PX_POZy bezposrednio
      _result:='DIRECT'
   |? _chk_yellow=1 & exec('mainversion_vie','px_ver')<>1
   ||
::    Jesli wyswietlana jest 'zolta' wersja planu to PX_POZy bezposrednio
      _result:='DIRECT'
   |? PX_GRP.UID_SRC=''
   ||
::    Jesli PX_GRP nie ma zrodla to PX_POZy bezposrednio
      _result:='DIRECT'
   |? PX_GRP.UID_SRC<>''
   ||
::    Jesli PX_GRP ma zrodlo to PX_POZy ze zrodla
      _result:='SOURCE'
   ?}
?};

PX_GRP.cntx_pop();
_result


\formula4stages
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Wykonuje przekazana formule dla kazdego etapu planistycznego z przepisu grupy
::       Przekazana formula dziala w kontekscie rekordu PX_STAGE
::   WE: _a - PX_GRP.ref()
::       _b - FORMULA - formula do wykonania dla kazdego etapu
::       [_c] - ANY - oczekiwana wartosc ktora powinna zwrocic formula _b - jesl zwrocona wartosc
::              bedzie inna to petla po etapach jest przerywana i w wyniku bedzie 0
::   WY: -1 - porazka, wystapil jakis blad (np nieudany seek)
::       0 - porazka - przekazana formula zwrocila wynik<=0 dla ktoregos rekordu, lub zwrocila
::                     wynik rozny od _c (jesli _c podane)
::       1 - sukces - przekazana formula zwrocila wynik>0 dla kazdego rekordu lub wynik zgodny z _c (jesli podane)
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_fml:=_b;

_expected:={? var_pres('_c')>0 || _c || ~~ ?};

_result:=1;

PX_GRP.cntx_psh(); PX_GRP.clear();

{? PX_GRP.seek(_px_grp)
|| {? PX_GRP.PX_TEX<>null()
   || _result:=exec('formula4stages','px_tex',PX_GRP.PX_TEX,_fml,_expected)
   |? PX_GRP.GROPS<>null()
   || PX_STAGE.cntx_psh();
      PX_STAGE.prefix();
      _stage:=exec('px_stage4grops','px_grop');
      {? PX_STAGE.seek(_stage)
      || _args:=~~;
::       Wykonuje formule
         _wynik:=_fml(_args);

         {? type_of(_expected)>0
         ||
::          Porownuje wynik formuly z oczekiwana wartoscia
            _can_continue:={? _wynik=_expected
                           || 1
                           || 0
                           ?}
         ||
::          Oczekiwana wartosc nie podana, wiec jesli wynik formuly mniejszy rowny zero
::          modyfikuje wynik calej formuly
            {? _wynik<=0
            || _result:=0
            ?}
         ?}
      ?};
      PX_STAGE.cntx_pop()
   ?}
|| _result:=-1
?};
PX_GRP.cntx_pop();
_result


\trigger_on
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Triggery tabeli PX_GRP - wlaczenie
::----------------------------------------------------------------------------------------------------------------------
PX_GRP.trig_a('add',"exec('grp_triga_add','px_grp')",'px_gprs');
PX_GRP.trig_b('del',"exec('grp_trigb_del','px_grp')",'px_gprs')


\trigger_off
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Triggery tabeli PX_GRP - wylaczenie
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
PX_GRP.trig_a('add',"",'px_grps');
PX_GRP.trig_b('del',"",'px_grps')


\grp_triga_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Tresc trig_a('add') tabeli PX_GRP
::   WE: [_a] - INTEGER - typ wyniku: [0] - zawsze ~~
::                                     1  - w zaleznosci czy sie udalo czy nie: 0/1
::   WE: w zależności od parametru _b albo ~~ albo 0/1
::----------------------------------------------------------------------------------------------------------------------
_res_type:=0;
{? var_pres('_a')=type_of(0)
|| _res_type:=_a
?};

_result:=~~;
_can_continue:=1;

:: 1. Tworze PX_GRPsa nie przypisanego do zestawu - bedzie wyswietlany kiedy
:: uzytkownik oglada 'wszystko'
PX_GRPS.cntx_psh();
PX_GRPS.index('PX_VER');
PX_GRPS.prefix(PX_GRP.PX_VER,PX_GRP.ref(),null());
{? PX_GRPS.size()=0
|| _args:=exec('add_a','px_grps');
   _args.PX_VER:=PX_GRP.PX_VER;
   _args.PX_GRP:=PX_GRP.ref();
   _can_continue:=exec('add','px_grps',_args)
?};
PX_GRPS.cntx_pop();

:: 2. Tworze PX_GRPSy na podstawie zestawow w przepisie
_ff:="
   _result:=1;
   {? PX_STAGE.PX_SET<>null()
   ||
      PX_GRPS.cntx_psh();
      PX_GRPS.index('PX_VER');
      PX_GRPS.prefix(PX_GRP.PX_VER,PX_GRP.ref(),PX_STAGE.PX_SET);
      {? PX_GRPS.size()=0
      ||
::       Jesli nie ma takiego PX_GRPSa do grupy i etapu to go dodajemy
         _args:=exec('add_a','px_grps');
         _args.PX_VER:=PX_GRP.PX_VER;
         _args.PX_GRP:=PX_GRP.ref();
         _args.PX_SET:=PX_STAGE.PX_SET;

::       Jesli istnieja automatyczne punkty czasowe, to na ich podstawie
::       na tworzonym PX_GRPS'ie ustalam zwrot i granice
         _args.DIR:=exec('get_auto_dir','px_point',PX_GRP.ref(),PX_STAGE.PX_SET);
         {? _args.DIR=0
         || _args.DIR:=PX_GRP.DIR
         ?};
         _tm_grn:=exec('get_auto_grn','px_point',PX_GRP.ref(),PX_STAGE.PX_SET);
         {? _tm_grn>0
         || _args.GRN_DATA:=exec('tm_stamp2date','#tm_stamp',_tm_grn);
            _args.GRN_TIME:=exec('tm_stamp2time','#tm_stamp',_tm_grn)
         ?};
         _result:=exec('add','px_grps',_args)
      ?};
      PX_GRPS.cntx_pop()
   ?};
   _result
";
_can_continue:=exec('formula4stages','px_grp',PX_GRP.ref(),_ff);

{? _res_type>0
|| {? _can_continue>0
   || _result:=1
   ?}
?};
_result


\grp_trigb_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Tresc trig_b('del') tabeli PX_GRP
::----------------------------------------------------------------------------------------------------------------------
exec('del','px_grps',PX_GRP.ref())


\update_tm_start
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Jesli TM_START na PX_GRP znajduje sie wczesniej niz powinien byc to go aktualizuje
::   WE: [_a] - PX_GRP.ref
::       [_b] - obj_new - paczka planistyczna razem z obudowa
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};
_pxpack:=~~;
{? var_pres('_b')>100
|| _pxpack:=_b
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.clear();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? type_of(_pxpack)=0
   ||
::    Pobieram paczke planistyczna
      _pxpack:=exec('trzepaczka','px_tex',PX_GRP.PX_TEX,PX_GRP.ILOSC,PX_GRP.ref())
   ?};

:: Wyznaczam czas startowy jaki powinien byc na PX_GRP
   _tm_start:=exec('round_start_pck','px_tex',_pxpack.Paczka);

   {? _tm_start>0 & PX_GRP.TM_START<_tm_start
   ||
::    Czas na grupie jest mniejszy niz powinien byc, wiec go przesuwam
      PX_GRP.STARTD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',_tm_start));
      PX_GRP.STARTT:=exec('tm_stamp2time','#tm_stamp',_tm_start);
      _can_continue:=PX_GRP.put();

::    Uaktualniam automatyczne punkty czasowe na grupie
      {? _can_continue>0
      || _can_continue:=exec('auto_point_upd','px_point',PX_GRP.ref())
      ?}
   ?}
?};
PX_GRP.cntx_pop();
PX_GRP.get();
{? _can_continue>0
|| _result:=1
?};
_result


\confirm_rfrsh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Odswieza potwierdzenie PX_GRP.CONFIRM na podstawie PX_GRPS.CONFIRM
::   WE: _a - PX_GRP.ref()
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

PX_GRP.cntx_psh(); PX_GRPS.cntx_psh();
PX_GRP.prefix();
{? PX_GRP.seek(_px_grp)
|| PX_GRPS.index('PX_GRP');
   PX_GRPS.prefix(PX_GRP.ref());
   _size:=PX_GRPS.size()-1;
   _confirm:=0;
   {? PX_GRPS.first()
   || {!
      |? {? PX_GRPS.CONFIRM='T' || _confirm+=1 ?};
         PX_GRPS.next()
      !}
   ?};
   {? _confirm=_size || PX_GRP.CONFIRM:='T'
   |? _confirm=0 || PX_GRP.CONFIRM:='N'
   || PX_GRP.CONFIRM:='P'
   ?};
   PX_GRP.put()
?};
PX_GRP.cntx_pop(); PX_GRPS.cntx_pop();
~~


\usu_gb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: Usun PX_GRP - grupa przed
::   WE: [_a] - uchwyt do obiektu
::----------------------------------------------------------------------------------------------------------------------
sel_nchk();

{? exec('is_one_version','px_param')
|| _Tab:=exec('tab','px_grps')
|| _obj:=($_a)();
   _obj.f_record();
   __nr:=_obj.TAB.NR;
   __upnode:=_obj.TAB.UPNODE;
   _Tab:=_obj.TAB
?};

KOMM.init(250,,'Usuwanie pozycji kolejki'@);
PX_GRP.cntx_psh();
PX_CONN.cntx_psh();
_has_conns:=0;
_can_del:=0;
_cur_tab:=cur_tab(1,1);
_sel_tab:=_cur_tab.sel_aget();
_cur_tab.cntx_psh();
{? _sel_tab.first()
|| {!
   |? _cur_tab.clear();
      {? _cur_tab.seek(_sel_tab.REF,)
      ||
         {? var_pres('_Tab')>100
         || obj_del(_Tab)
         ?};
         {? exec('is_one_version','px_param')
         || _Tab:=exec('tab','px_grps')
         || {? var_pres('_obj')>100
            || obj_del(_obj)
            ?};
            _obj:=($_a)();
            _obj.f_record();
            __nr:=_obj.TAB.NR;
            __upnode:=_obj.TAB.UPNODE;
            _Tab:=_obj.TAB
         ?};

         {? _Tab.PX_OBJ=''
         || PX_GRP.clear();
            {? PX_GRP.seek(_Tab.PX_GRPI,8+_Tab.PX_GRPI)
            || _has_conns:=exec('has_conns','px_con_g');
               _can_del:=exec('can_del_conns','px_con_g',,0)
            ?}
         || PX_CONN.clear();
            {? PX_CONN.seek(_Tab.PX_CONN,8+_Tab.PX_CONN)
            || PX_GRP.cntx_psh();
               PX_CONN.PX_GRP();
               PX_CONN.cntx_psh();
               PX_CONN.index('PX_GRP');
               PX_CONN.prefix(PX_GRP.ref());
               {? PX_CONN.size()=1
               || _has_conns:=exec('has_conns','px_con_g',PX_CONN.PX_GRP);
                  _can_del:=exec('can_del_conns','px_con_g',,0)
               ?};
               PX_CONN.cntx_pop();
               PX_GRP.cntx_pop()
            ?}
         ?}
      ?};
      _sel_tab.next() & _has_conns=0
   !}
?};
_cur_tab.cntx_pop();
PX_GRP.cntx_pop();
PX_CONN.cntx_pop();

_ask:=0;
{? _can_del>0
||
   _msg_ask:='';
   _msg0:='';
   _msg1:='Ilość zaznaczonych pozycji: %1'@[form(cur_tab(1,1).sel_size())];
   _msg10:='Czy usuwać?'@;

   {? _has_conns>0
   || _msg2:='Niektóre z zaznaczonych pozycji są powiązane z innymi.\n'
             'Usunięcie zaznaczonych spowoduje usunięcie wszystkich powiązanych z nimi pozycji.'@;
      _msg_ask:=exec('form','#string','L',_msg1
                                          ,_msg2
                                          ,_msg0
                                          ,_msg10)
   || _msg_ask:=exec('form','#string','L',_msg1
                                          ,_msg0
                                          ,_msg10)
   ?};

   _ask:=FUN.ask(_msg_ask)
?};

{? _ask>0 & _can_del>0
|| VAR.GRUPA:='T';
   1
|| KOMM.select();
   0
?}


\usu_ga
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: Usun PX_GRP - grupa po
::   WE: [_a] - uchwyt do obiektu
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
exec('prenumber','px_grp');
{? ~exec('is_one_version','px_param')
|| _obj:=($_a)();
   _obj.load();
   _obj.TAB.index(_obj.NDX_UP);
   _obj.TAB.prefix();
   _obj.update();
   _obj.TAB.find_le(__upnode,__nr)
?};
KOMM.select();
VAR_DEL.delete('__upnode','__nr');

:: Aktualizuje przyciski dot przeliczania jednej wersji planu
{? exec('is_one_version','px_param')>0
|| exec('przelicz_btn','px_plan');

   {? exec('is_grop','px_param')>0
   || PX_GRPS.cntx_psh();
      PX_GRP.cntx_psh();
      {? PxSelect.Pxgrp.curr_WERT_G<>null()
      || {? PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT_G)=0
         || PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT_G_PREV)
         ?}
      ?};
      grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT_G,1);
      PX_GRPS.cntx_pop();
      PX_GRP.cntx_pop()
   ?};
   PX_GRPS.cntx_psh();
   PX_GRP.cntx_psh();
   {? var_pres('curr_WERT',PxSelect.Pxgrp)>0 & PxSelect.Pxgrp.curr_WERT<>null()
   || {? PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT)=0
      || PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT_PREV)
      ?}
   ?};
   grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT,1);
   PX_GRPS.cntx_pop();
   PX_GRP.cntx_pop();
   ~~
?};
:: Komunikaty bledow wylaczone, aby uniknac zbednego sprawdzania, czy jest dostepne okno grupowe
_msg:=no_msg(1);
grp_disp(PX_KONT,{? exec('tree_kont','px_param') || 'PX_WERT' || 'PX_WER' ?},1);
{? var_pres('PxSelect')>100
|| grp_disp(PxSelect.Tab_OBJ.TAB,PxSelect.Tab_OBJ.WER,1,1);
   grp_disp(PxSelect.Tab_KONT.TAB,PxSelect.Tab_KONT.WER,1,1)
?};
exec('kafelki_reload','px_plan');
no_msg(_msg);
~~


\usu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: Usun PX_GRP
::   WE: [_a] - uchwyt do obiektu
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_admin:=(exec('get','#params',8062,2,OPERATOR.USER)='T');

_result:=0;
{? exec('is_one_version','px_param')
|| {? var_pres('_a')>100
   || _Tab:=_a
   || _Tab:=exec('tab','px_grps')
   ?}
|| _obj:=($_a)();
   _obj.f_record();
   __nr:=_obj.TAB.NR;
   __upnode:=_obj.TAB.UPNODE;
   _Tab:=_obj.TAB
?};

PX_CONN.cntx_psh();

_ok:=0;
_empty:=0;
_locked:=null();
_display:=1;
{? VAR.GRUPA='T'
|| _display:=2
?};
_can_continue:=1;
PX_GRP.clear();

{?  VAR.GRUPA='T' & _Tab.PX_OBJ=''
||
:: teraz jestesmy na galezi glownej czyli trzeba posprzatac wszystkie PX_CONN w akcji grupowej
   {? PX_GRP.seek(_Tab.PX_GRPI,8+_Tab.PX_GRPI)
   ||
      {? exec('lock','px_grp',,_display)>0
      || _locked:=PX_GRP.ref();
         _what:=exec('record','#to_string',PX_GRP.ref());
         {? ~_admin & exec('is_px_set','px_param') & PX_GRP.SET_SRC<>PX_VAR.PX_SET
         || KOMM.sect_end();
            KOMM.sect_beg('Element z innego zestawu nie został usunięty: %1'@[_what],52,,1)
         |? PX_GRP.BLK='T'
         || KOMM.sect_end();
            KOMM.sect_beg('Element zablokowany nie został usunięty: %1'@[_what],52,,1)
         || _ref:=PX_GRP.ref();
            {? exec('is_whatif','px_ver',PX_GRP.PX_VER)>0
            || PX_GRP.SIM_DEL:='T';
               _result:=PX_GRP.put();
::             Stempluje modyfikacje kolejki w wersji
               exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER)
            ||
               do();
               KOMM.sect_beg('Dla: %1'@[_what]);
               PX_CONN.index('PX_GRP');
               PX_CONN.prefix(_ref);
               {? PX_CONN.first()
               || {!
                  |? _txt:='%1 w ilości: %2 %3'@[PX_CONN.PX_OBJ().SYMBOL,$PX_CONN.ILOSC,PX_CONN.PX_OBJ().JM().KOD];
                     _can_continue:=exec('delete','px_conn',PX_CONN.ref());

                     {? _can_continue>0
                     || KOMM.add('Usunięto składowe elementu kolejki %1'@[_txt],13,,1)
                     || KOMM.add('Nie udało się usunąć składowych elementu kolejki %1'@[_txt],14,,1)
                     ?};

                     PX_CONN.first() & _can_continue>0
                  !}
               ?};
               {? _can_continue>0
               || _can_continue:=exec('delete','px_grp',PX_GRP.ref());
                  {? _can_continue>0
                  || _result:=1
                  || KOMM.add('Nie udało się usunąć elementu kolejki.'@,14,,1)
                  ?}
               ?};
               KOMM.sect_end();
               _ok:=1;
               end()
            ?}
         ?}
      ?}
   || {? PX_CONN.seek(_Tab.PX_CONN,8+_Tab.PX_CONN)
      ||
         {? exec('lock','px_grp',PX_CONN.PX_GRP,_display)
         || _locked:=PX_CONN.PX_GRP;
            _txt:='%1 w ilości: %2 %3'@[PX_CONN.PX_OBJ().SYMBOL,$PX_CONN.ILOSC,PX_CONN.PX_OBJ().JM().KOD];
            {? PX_CONN.PX_GRP().BLK='T'
            || KOMM.add('Element zablokowany nie został usunięty %1'@[_txt],14,,1)
            |? PX_GRP.STATUS=exec('status_wyk1','px_grp')
            || KOMM.sect_beg('Element wykonywany nie został usunięty %1'@[_txt],14,,1)
            |? PX_GRP.STATUS=exec('status_wyk2','px_grp')
            || KOMM.add('Element wykonany całkowiecie nie został usunięty %1'@[_txt],14,,1)
            || exec('delete','px_conn',PX_CONN.ref());
               _ok:=1
            ?}
         ?}
      ?}
   ?}
|| {? _Tab.PX_OBJ=''
   ||
::    teraz jestesmy na galezi glownej czyli trzeba posprzatac wszystkie PX_CONN
      {? PX_GRP.seek(_Tab.PX_GRPI,8+_Tab.PX_GRPI)
      || _what:=exec('record','#to_string',PX_GRP.ref());
         {? exec('lock','px_grp',,_display)>0
         || _locked:=PX_GRP.ref();
            {? ~_admin & exec('is_px_set','px_param') & PX_GRP.SET_SRC<>PX_VAR.PX_SET
            || {? VAR.GRUPA='T'
               || KOMM.sect_beg('Element z innego zestawu startowego nie został usunięty: %1'@[_what],52,,1)
               || FUN.emsg('Element z innego zestawu startowego nie może być usunięty.'@)
               ?}
            |? PX_GRP.BLK='T'
            || {? VAR.GRUPA='T'
               || KOMM.sect_beg('Element zablokowany nie został usunięty: %1'@[_what],52,,1)
               || FUN.emsg('Element zablokowany nie może być usunięty.'@)
               ?}
            || _ref:=PX_GRP.ref();
               _czydel:=1;
               PX_POZ.cntx_psh();
               PX_POZ.index('TM_GRP');
               PX_POZ.prefix(PX_GRP.ref());
               {? PX_POZ.size()>0
               || _czydel:=0
               ?};
               PX_POZ.cntx_pop();

               _czywyk1:=PX_GRP.STATUS=exec('status_wyk1','px_grp');
               _czywyk2:=PX_GRP.STATUS=exec('status_wyk2','px_grp');

               {? exec('is_whatif','px_ver',PX_GRP.PX_VER)>0 & PX_GRP.UID_SRC<>''
               || _txt:='Element zostanie oznaczony do usunięcia za pomocą akcji: %1. Nie będzie brał udziału w przeliczeniu.'@['Nanieś'@]
               || _txt:='Czy na pewno chcesz usunąć cały element grupujący wraz z pozycjami?'@
               ?};
               {? _czydel=0
               || _txt:='Pozycja grupująca jest powiązana z pozycjami planu.'@+'\n'+_txt
               ?};
               {? _czywyk1
               || _txt:='Pozycja grupująca ma częściowo zarejestrowane wykonania.'@+'\n'+_txt
               |? _czywyk2
               || _txt:='Pozycja grupująca jest całkowicie wykonana.'@+'\n'+_txt
               ?};

               _can_del:=0;
               _has_conns:=exec('has_conns','px_con_g');
               {? _has_conns>0
               || _loop:=1;
                  _choi_txt:=_txt;
                  {!
                  |?
                     _choi_txt:='Jego usunięcie spowoduje usunięcie również powiązanych elementów.'@+'\n'+_txt;
                     _choi_txt:='Element kolejki jest powiązany z innymi elementami.'@+'\n'+_choi_txt;

                     _choice:=FUN.choice(_choi_txt,,'Wyświetl powiązania'@,'Usuń wszystko'@);
                     {? _choice=1
                     || exec('view_conns','px_con_g')
                     |? _choice=2
                     || _can_del:=1;
                        _loop:=0
                     || _loop:=0
                     ?};
                     _loop>0
                  !}
               || _can_del:=FUN.ask(_txt)
               ?};

               {? _can_del>0
               ||
                  {? exec('is_whatif','px_ver',PX_GRP.PX_VER)>0 & PX_GRP.UID_SRC<>''
                  || PX_GRP.SIM_DEL:='T';
                     _result:=PX_GRP.put();
::                   Stempluje modyfikacje kolejki w wersji
                     exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER)
                  ||
                     _can_del:=exec('can_del_conns','px_con_g');
                     {? _can_del
                     || _grop:={? PX_GRP.GROPS<>null() || PX_GRP.GROPS().GROP || null() ?};
                        {? exec('delete','px_grp',PX_GRP.ref())
                        || _result:=1;
                           exec('prenumber','px_grp');

::                         Aktualizuje przyciski dot przeliczania jednej wersji planu
                           {? exec('is_one_version','px_param')>0
                           || exec('przelicz_btn','px_plan')
                           ?};

::                         "Naprawa" GROPS po usunięciu GROP z planu
                           {? _grop<>null()
                           || exec('plan_restore_grop','zl_grop',_grop)
                           ?}
                        ?}
                     ?}
                  ?}
               ?}
            ?}
         ?}
      ?}
   || PX_CONN.cntx_psh();
      _empty:=~(PX_CONN.first() & PX_CONN.next());
      PX_CONN.cntx_pop();
      PX_CONN.clear();
      {? PX_CONN.seek(_Tab.PX_CONN,8+_Tab.PX_CONN) &
         PX_GRP.seek(_Tab.PX_GRPI,8+_Tab.PX_GRPI)
      ||
         {? exec('lock','px_grp',,_display)>0
         || _locked:=PX_GRP.ref();
            _what:=exec('record','#to_string',PX_GRP.ref());
            _txt:='%1 w ilości: %2 %3'@[PX_CONN.PX_OBJ().SYMBOL,$PX_CONN.ILOSC,PX_CONN.PX_OBJ().JM().KOD];
            {? PX_GRP.BLK='T'
            || {? VAR.GRUPA='T'
               || KOMM.add('Element zablokowany nie został usunięty %1'@[_txt],52,,1)
               || FUN.emsg('Element zablokowany nie może być usunięty.'@)
               ?}
            |? PX_GRP.STATUS=exec('status_wyk1','px_grp')
            || {? VAR.GRUPA='T'
               || KOMM.add('Element wykonywany nie został usunięty %1'@[_txt],52,,1)
               || FUN.emsg('Element wykonywany nie może być usunięty.'@)
               ?}
            |? PX_GRP.STATUS=exec('status_wyk2','px_grp')
            || {? VAR.GRUPA='T'
               || KOMM.add('Element wykonany w całości nie został usunięty %1'@[_txt],52,,1)
               || FUN.emsg('Element wykonany w całości nie może być usunięty.'@)
               ?}
            ||
               _can_del:=1;
               {? _can_del>0 & exec('is_whatif','px_ver',PX_CONN.PX_VER)>0
               || _can_del:=0;
                  _txt:='Nie można usuwać w symulacji elementów składowych kolejki.'@;
                  {? VAR.GRUPA='T'
                  || KOMM.add(_txt,2,,1)
                  || FUN.emsg(_txt)
                  ?}
               ?};

               {? _can_del>0
               || _txt:='Czy usunąć składową elementu kolejki?'@;

                  _has_conns:=exec('has_conns','px_con_g',PX_CONN.PX_GRP);
                  {? _has_conns>0
                  || _loop:=1;
                     _choi_txt:=_txt;
                     {!
                     |?
                        _choi_txt:='Jej usunięcie spowoduje usunięcie również powiązanych elementów.'@+'\n'+_txt;
                        _choi_txt:='Element kolejki jest powiązany z innymi elementami.'@+'\n'+_choi_txt;

                        _choice:=FUN.choice(_choi_txt,,'&Wyświetl powiązania'@,'&Usuń wszystko'@);
                        {? _choice=1
                        || exec('view_conns','px_con_g',PX_CONN.PX_GRP)
                        |? _choice=2
                        || _can_del:=1;
                           _loop:=0
                        || _loop:=0
                        ?};
                        _loop>0
                     !}
                  || _can_del:=FUN.ask(_txt)
                  ?}
               ?};
               {? _can_del>0
               || _can_del:=exec('can_del_conns','px_con_g',PX_CONN.PX_GRP)
               ?};

               {? _can_del>0
               || _txt:='%1 w ilości: %2 %3'@[PX_CONN.PX_OBJ().SYMBOL,$PX_CONN.ILOSC,PX_CONN.PX_OBJ().JM().KOD];

                  _ver:=PX_CONN.PX_VER;
                  _grp:=PX_CONN.PX_GRP;
                  exec('delete','px_conn',PX_CONN.ref());

                  {? exec('is_one_version','px_param')>0
                  ||
::                   Jesli praca na jednej wersji planu to wyciagniecie czegos z grupy
::                   powinno spowodowac ze ta grupa z ktorej wyciagamy zostaje usunieta z planu
                     exec('clean_from_plan','px_grp',_grp)
                  ?};

                  {? VAR.GRUPA='T'
                  || KOMM.add('Usunięto obiekt %1'@[_txt] ,13,,1)
                  ||
::                   Aktualizuje przyciski dot przeliczania jednej wersji planu
                     {? exec('is_one_version','px_param')>0
                     || exec('przelicz_btn','px_plan');
                        {? _empty || FUN.info('Usunięto ostatni obiekt %1'@[_txt]) ?}
                     ?}
                  ?};
                  _ok:=1
               ?}
            ?}
         ?}
      ?}
   ?}
?};

:: przenumerowanie pol
{? VAR.GRUPA='N' | VAR.GRUPA=''
|| {? _ok
   || exec('prenumber','px_grp')
   ?};
   {? ~exec('is_one_version','px_param')
   || _obj.load();
      _obj.TAB.index(_obj.NDX_UP);
      _obj.TAB.prefix();
      _obj.update();
      _obj.TAB.find_le(__upnode,__nr)
   ?}
?};
:: Odblokowuje zablokowana wczesniej grupe
{? _locked<>null()
|| exec('unlock','px_grp',_locked)
?};
{? VAR.GRUPA='N' | VAR.GRUPA=''
||
:: Komunikaty bledow wylaczone, aby uniknac zbednego sprawdzania, czy jest dostepne okno grupowe
   _msg:=no_msg(1);
   grp_disp(PX_KONT,{? exec('tree_kont','px_param') || 'PX_WERT' || 'PX_WER' ?},1);
   {? var_pres('PxSelect')>100
   || grp_disp(PxSelect.Tab_OBJ.TAB,PxSelect.Tab_OBJ.WER,1,1);
      grp_disp(PxSelect.Tab_KONT.TAB,PxSelect.Tab_KONT.WER,1,1)
   ?};
   exec('kafelki_reload','px_plan');
   no_msg(_msg)
?};
PX_CONN.cntx_pop();
{? _empty & exec('is_one_version','px_param')
|| grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT,1)
?};
_result


\can_add_obj
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy mozna dodac do grupy PX_OBJ
::   WE: _a - PX_GRP.ref() - grupa docelowa
::       _b - PX_OBJ.ref() - element przeciagany
::       [_c] - INTEGER - 0/[1] - czy dodawac info do KOMMa
::   WY: 0 - nie da sie
::       1 - da sie
::----------------------------------------------------------------------------------------------------------------------
_grp_dst:=_a;
_px_obj:=_b;

_komm:=1;
{? var_pres('_c')=type_of(0)
|| _komm:=_c
?};

_can_continue:=1;
_result:=0;


PX_GRP.cntx_psh(); PX_GRP.clear();
PX_OBJ.cntx_psh(); PX_OBJ.clear();
PX_OBJ.cntx_psh();

{? PX_GRP.seek(_grp_dst) & PX_OBJ.seek(_px_obj)
||
:: Stoje na docelowej grupie i obiekcie

:: 1. Sprawdzam czy sa jakies punkty czasowe kolidujace z teminem realizacji przeciaganego elemenu
   _fml:="
      _komm:=_a;
      _result:=1;
      PX_POINT.cntx_psh();
      PX_POINT.index('PX_GRP');
      PX_POINT.prefix(PX_GRP.ref(),PX_STAGE.ref());
      {? PX_POINT.first()
      || _stg_sym:=$PX_STAGE.NR+'. '+PX_STAGE.NAZWA;
         {? PX_POINT.TM_MAX>0 & PX_POINT.TM_MAX>PX_OBJ.TM_REA
         ||
::          Termin realizacji wczesniej niz Maksymalny czas zakonczenia
            _result:=0;

            {? _komm>0
            || _termin:=19+tm_form(PX_OBJ.TM_REA);
               _msg:='Maksymalny czas końca etapu: \'\'%1\'\' przekracza termin realizacji obiektu: %2'@[_stg_sym,PX_OBJ.SYMBOL];
               _msg+=' ('+_termin+')';
               KOMM.add(_msg,2)
            ?}
         ?};
         {? PX_POINT.TM_MIN>0 & PX_POINT.TM_MIN>PX_OBJ.TM_REA
         ||
::          Termin realizacji wczeniej niz Minimalny czas rozpoczecia
            _result:=0;

            {? _komm>0
            || _termin:=19+tm_form(PX_OBJ.TM_REA);
               _msg:='Maksymalny czas końca etapu: \'\'%1\'\' przekracza termin realizacji obiektu: %2'@[_stg_sym,PX_OBJ.SYMBOL];
               _msg+=' ('+_termin+')';
               KOMM.add(_msg,2)
            ?}
         ?}
      ?};
      PX_POINT.cntx_pop();
      _result
   ";
   _can_continue:=exec('formula4stages','px_tex',PX_GRP.PX_TEX,_fml,,_komm)
?};

PX_OBJ.cntx_pop();
PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\can_delete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy mozna usunac dana grupe z kolejki
::   WE: [_a] - PX_GRP.ref()
::       [_b] - INTEGER - tryb komunikatow: [1] - na ekran
::                                           2  - do KOMM
::   WY: 0 - nie mozna usunac
::       1 - mozna
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};
_display:=1;
{? var_pres('_b')=type_of(0)
|| _display:=_b
?};

_result:=1;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.clear();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: 1. Sprawdzam czy element mozna zablokowac
   _locked:=0;
   {? exec('lock','px_grp',,_display)
   || _locked:=1
   || _result:=0
   ?};
   _what:=exec('record','#to_string',PX_GRP.ref());
:: 2. Sprawdzam czy element jest zablokowany w planie
   {? PX_GRP.BLK='T'
   || _result:=0;
      {? _display=2
      || KOMM.add('Element zablokowany nie został usunięty %1'@[_what],52,,1)
      || FUN.emsg('Element zablokowany nie może być usunięty.'@)
      ?}
   ?};
   {? _locked>0
   || exec('unlock','px_grp')
   ?}
?};
PX_GRP.cntx_pop();
_result


\trig_add_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger tabeli PX_GRP - przed dodaniem
::   WY: 1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
exec('grp_stmp_trig','px_grp')


\trig_put_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger tabeli PX_GRP - przed poprawieniem
::   WY: 1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
exec('grp_stmp_trig','px_grp')


\update_coop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Aktualizuje informację czy pozycja kolejki zawiera kooperację
::   WE: [_a] - PX_GRP.ref - element kolejki lub bieżący rekord
::       [_b] - INTEGER - 0/[1] - czy wykonywać aktualizację pola COOP_LP dla wszystkich elementów kolejki
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};
_coop_lp:=1;
{? var_pres('_b')=type_of(0)
|| _coop_lp:=_b
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_GRP.COOP:='N';
   {? PX_GRP.PX_TEX<>null()
   || {? exec('has_coop','px_tex',PX_GRP.PX_TEX)>0
      || PX_GRP.COOP:='T'
      ?}
   ?};
   _can_continue:=PX_GRP.put();

   {? _can_continue>0
   ||
      {? _coop_lp>0
      || _can_continue:=exec('update_coop_lp','px_grp',PX_GRP.PX_VER)
      ?}
   ?};
   ~~
?};
PX_GRP.cntx_pop();
PX_GRP.get();

{? _can_continue>0
|| _result:=1
?};
_result


\update_coop_lp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Aktualizuję informację o numerze grupy wśród grup kooperacyjnych
::   WE: _a - PX_VER.ref - wersja planu
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_result:=0;
_can_continue:=1;

{? _can_continue>0
||
   PX_GRP.cntx_psh();
   _lp:=0;
   {? exec('is_whatif','px_ver',_px_ver)>0
   || PX_GRP.index('PLAN_S');
      PX_GRP.prefix(_px_ver,'N','N','N','Z')
   ||
      PX_GRP.index('PLAN');
      PX_GRP.prefix(_px_ver,'N','N','Z')
   ?};
   {? PX_GRP.first()
   || {!
      |?
         {? PX_GRP.COOP='T'
         || _lp+=1;
            PX_GRP.COOP_LP:=_lp
         || PX_GRP.COOP_LP:=0
         ?};
         _can_continue:=PX_GRP.put();
         PX_GRP.next() & _can_continue>0
      !}
   ?};
   PX_GRP.cntx_pop();
   ~~
?};
{? _can_continue>0
|| _result:=1
?};
_result


\update_m
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Aktualizuje pole materiału rekordu tabeli PX_GRP.
::   WE: _a - PX_GRP.ref()
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_press('_a')=type_of(null) || _a || return ?};
PX_GRP.cntx_psh();
_msk:=ref_name(_ref);
{? (5+_msk)='pxgrp'
|| PX_GRP.use(_msk);
   PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || PX_GRP.M:=null;
::    Jeżeli wszystkie połączenia grupujące (PX_CONN) dotyczą tego samego materiału to ustawiam materiał
      PX_CONN.cntx_psh();
      PX_CONN.index('PX_GRP_M');
      PX_CONN.prefix(_ref);
      {? PX_CONN.first
      || _size:=PX_CONN.size();
         PX_CONN.prefix(_ref,PX_CONN.M);
         {? PX_CONN.first & PX_CONN.size=_size
         || PX_GRP.M:=PX_CONN.M
         ?}
      ?};
      _put:=PX_GRP.put();
::    Przepisanie zmian z GRP do GRPS
      {? _put
      || PX_GRPS.cntx_psh();
         PX_GRPS.use('pxgrs'+(_msk+3));
         PX_GRPS.index('PX_GRP');
         PX_GRPS.prefix(PX_GRP.ref());
         {? PX_GRPS.first
         || {!
            |? PX_GRPS.M:=PX_GRP.M;
               PX_GRPS.put();
               PX_GRPS.next()
            !}
         ?};
         PX_GRPS.cntx_pop()
      ?};
      PX_CONN.cntx_pop()
   ?}
?};
PX_GRP.cntx_pop()


\has_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Sprawdza czy dla danego PX_GRP jest utworzone jakieś zlecenie
::   WE: [_a] - PX_GRP.ref lub bieżący rekord
::   WY: 0 - brak zlecenia
::       1 - jest zlecenie
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_ZL.cntx_psh();
   PX_ZL.prefix(PX_GRP.ref());
   _result:=PX_ZL.first();
   PX_ZL.cntx_pop()
?};
PX_GRP.cntx_pop();
_result


\has_zl_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Sprawdza czy dla danego PX_GRP są już utworzone zlecenia na całą ilość
::       ewentualnie czy grupa nie jest zleceniem
::   WE: [_a] - PX_GRP.ref lub bieżący rekord
::       [_b] - INTEGER - 0/1 czy badać czy grupa jest zleceniem
::   WY: 0 - nie cała ilość na zleceniach
::       1 - cala ilość na zleceniach
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};
_chk_zl:=1;
{? var_pres('_b')=type_of(0)
|| _chk_zl:=_b
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_ZL.cntx_psh();
   PX_ZL.index('PX_GRP');
   PX_ZL.prefix(PX_GRP.ref());
   _ilzl:=0;
   {? PX_ZL.first()
   || {!
      |? _ilzl+=PX_ZL.ILOSC;
         PX_ZL.next()
      !}
   ?};
   {? _ilzl>=PX_GRP.ILOSC
   || _result:=1
   ?};
   PX_ZL.cntx_pop();

   {? _chk_zl>0
   ||
      PX_CONN.cntx_psh();
      PX_CONN.index('PX_GRP');
      PX_CONN.prefix(PX_GRP.ref());
      _size:=PX_CONN.size();
      _size_zl:=0;
      {? PX_CONN.first()
      || {!
         |? {? PX_CONN.PX_OBJ().ZL<>null()
            || _size_zl+=1
            ?};
            PX_CONN.next()
         !}
      ?};

      {? _size=_size_zl
      ||
::    Grupa zawiera same zlecenia, więc też mówię że ma zlecenia
         _result:=1
      ?};
      PX_CONN.cntx_pop()
   ?};
   ~~
?};
PX_GRP.cntx_pop();
_result


\is_blocked
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Sprawdza czy grupa jest zablokowana
::   WE: [_a] - PX_GRP.ref lub bieżący rekord
::   WY: 0 - nie ma blokady
::       1 - jest
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? PX_GRP.BLK='T'
   || _result:=1
   |? PX_GRP.BLK='Z'
   || _result:=1
   ?}
?};
PX_GRP.cntx_pop();
_result


\zlecenia
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Wyświetla zlecenia wygenerowane na podstawie danej grupy w kolejce
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_can_continue:=1;
_one_ver:=exec('is_one_version','px_param');
_ref:='';
_cur_tab:=cur_tab(1,1);
{? var_pres('PX_GRP',_cur_tab)>0
|| _px_grp:=_cur_tab.PX_GRP;
   {? type_of(_px_grp)=type_of(null)
   || _ref:=$_px_grp
   |? type_of(_px_grp)=type_of('')
   || _ref:=_px_grp
   ?}
?};
{? _ref=''
|| _ref:={? _one_ver || $PX_GRPS.PX_GRP || PxSelect.Pxgrp.TAB.PX_GRPI ?}
?};
{? _ref<>''
|| _rec:=exec('FindAndGet','#table',PX_GRP,_ref,,,null());

   PX_GRP.cntx_psh(); PX_GRP.prefix();
   ZL.cntx_psh();
   {? PX_GRP.seek(_ref)
   ||
::    szukam takiego samego obiektu grupujacego ale w wersji zrodlowej
      PX_GRP.index('UID');
      _uid:='';
      _prefix_mode:=exec('poz_prefix_mode','px_grp');
      {? _prefix_mode='SOURCE'
      || _uid:=PX_GRP.UID_SRC
      || _uid:=PX_GRP.UID
      ?};
      PX_GRP.prefix(_uid);
      {? PX_GRP.first()
      || PX_ZL.cntx_psh();
         PX_ZL.index('PX_GRP');
         PX_ZL.prefix(PX_GRP.ref());
         PX_ZL.first();
         _wer:=PX_ZL.mk_sel('Zlecenia'@,,,'#pxzlsel',,,,,'U');
         PX_ZL.win_fld(_wer,,'ZL','SYM',,20,,,'Symbol'@);
         PX_ZL.win_fld(_wer,,'ZL','OPIS',,27,,,'Opis'@);
         PX_ZL.win_fld(_wer,,'ZL','IL',,15,,,'Ilość na zleceniu'@);
         PX_ZL.win_fld(_wer,,'ILOSC',,,15,,,'Ilość z planu'@);
         PX_ZL.win_fld(_wer,,'ZL','STAN',,2,,,'Stan'@);

         PX_ZL.win_fml(_wer,,'ZL','STAN','ICON_BEFORE',"exec('icon_stan','zl_head')");

         _fb:="
            params_exec('zl_display','zl_head');
            ~~
         ";
         PX_ZL.win_act(_wer,,'Wyświetl',,,,_fb);



         PX_ZL.win_sel(_wer);
         PX_ZL.select();
         PX_ZL.cntx_pop()
      ?}
   ?};
   PX_GRP.cntx_pop();
   ZL.cntx_pop();
   ~~
?};
~~


\deleted_in_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Obsługa sytuacji że jest czynność na liście todo ale obiekt grupujący usunięty
::   WE: _a - obj_new - obiekt Menadżera Procesów
::   WY: ~~
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=_a;

_msg:='Element kolejki nie został odnaleziony, prawdopodobnie został usunięty.'@;
{? _mp.isService()=0 & _mp.CLEANER=0
|| {? _mp.isGroup()
   || KOMM.add(_msg,2,,1)
   || FUN.emsg(_msg)
   ?}
?};
_mp.error(_msg);
~~


\plan_times_upd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Aktualizuje czasy rozpoczęcia i końca planu
::   WE: [_a] - PX_GRP.ref lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_GRP.STRSTART:='';
   PX_GRP.STREND:='';
   PX_POZ.cntx_psh();
   PX_POZ.index('TM_GRP');
   PX_POZ.prefix(PX_GRP.ref());
   {? PX_POZ.first()
   || PX_GRP.STRSTART:=19+tm_form(PX_POZ.TM_START)
   ?};
   PX_POZ.index('TM_GRP2');
   PX_POZ.prefix(PX_GRP.ref());
   {? PX_POZ.last()
   || PX_GRP.STREND:=19+tm_form(PX_POZ.TM_END)
   ?};
   _can_continue:=PX_GRP.put();
   PX_POZ.cntx_pop()
?};
PX_GRP.cntx_pop();
PX_GRP.get();
{? _can_continue>0
|| _result:=1
?};
_result


\get_plan_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca początek planu dla grupy
::   WE: [_a] - PX_GRP.ref lub bieżący rekord
::   WY: REAL - czas w formacie TM_STAMP
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_POZ.cntx_psh();
   PX_POZ.index('TM_GRP');
   PX_POZ.prefix(PX_GRP.ref());
   {? PX_POZ.first()
   || _result:=PX_POZ.TM_START
   ?};
   PX_POZ.cntx_pop()
?};
PX_GRP.cntx_pop();
PX_GRP.get();
_result


\get_plan_end
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca koniec planu dla grupy
::   WE: [_a] - PX_GRP.ref lub bieżący rekord
::   WY: REAL - czas w formacie TM_STAMP
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_POZ.cntx_psh();
   PX_POZ.index('TM_GRP2');
   PX_POZ.prefix(PX_GRP.ref());
   {? PX_POZ.last()
   || _result:=PX_POZ.TM_END
   ?};
   PX_POZ.cntx_pop()
?};
PX_GRP.cntx_pop();
PX_GRP.get();
_result


\copy_from_whatif
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Nanosi do planu głównego zmiany poczynione na PX_GRP w symulacji WHATIF
::   WE: [_a] - PX_GRP.ref() lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRPS.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

_grupa:=0;
{? PX_GRPS.sel_size()>0
|| _grupa:=1
?};

PX_GRP.cntx_psh();
PX_GRPS.cntx_psh();
PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');
{? _ref<>null()
|| PX_GRPS.prefix();
   {? PX_GRPS.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
{? _can_continue>0
|| {? PX_GRPS.PX_GRP<>null()
   || PX_GRPS.PX_GRP()
   || _can_continue:=0
   ?}
?};
_sim_del:=0;

{? _can_continue>0
|| {? PX_GRP.SIM_DEL='T'
   || _sim_del:=1
   ?}
?};

{? _can_continue>0 & _grupa=0
|| {? PX_GRP.UID_SRC<>''
   || _msg:='Nanieść modyfikacje elementu: %1 na plan główny?'@[exec('PX_GRP','#to_string')];
      _can_continue:=FUN.ask(_msg)
   || _msg:='Elementu: %1 nie ma w planie głównym. Dodać go do kolejki?'@[exec('PX_GRP','#to_string')];
      _can_continue:=FUN.ask(_msg)
   ?}
?};

{? _can_continue>0
|| _buffer:=exec('obj_new','#buf','PX_GRP');
   _buffer.get();
   _ref:=PX_GRP.ref();
   {? PX_GRP.UID_SRC<>''
   ||
::    Istniejący element, odszukuję ten z którego pochodził i robię mu update

      PX_GRP.cntx_psh();
      PX_GRP.index('UID');
      PX_GRP.prefix(PX_GRP.UID_SRC,);
      {? PX_GRP.first()
      ||
::       Stoję na oryginalnym elemencie

::       Sprawdzam czy się nie zmienił w czasie jak symulowałem
         {? PX_GRP.IDPUT>_buffer.IDADD & PX_GRP.UID_SRC<>_buffer.UID
         || _can_continue:=0;
            _msg:='Element kolejki: %1 został zmieniony przez innego użytkownika w czasie symulacji. Naniesienie niemożliwe.'@[exec('PX_GRP','#to_string')];
            {? _grupa>0
            || KOMM.add(_msg,2,,1)
            || FUN.emsg(_msg)
            ?}
         ?};

         {? _can_continue>0
         ||
            _setlpq:=0;
            {? _sim_del>0
            ||
               _tab:=exec('tab','px_grps');
               _tab.PX_GRPI:=$PX_GRP.ref();
               {? exec('usu','px_grp',_tab)
               || exec('delete','px_grp',_ref)
               ?}
            ||
               _buffer.UID:=~~;
               _buffer.UID_SRC:=~~;
               _buffer.KOM_ERR:=~~;
               _buffer.KOM_WARN:=~~;
               _buffer.KOM_INFO:=~~;
               _buffer.PX_VER:=~~;
               _buffer.SIM_MOD:='N';

               {? PX_GRP.LP_Q<>_buffer.LP_Q
               || _setlpq:=1
               ?};
               _buffer.set();

               {? _setlpq>0
               || PX_GRP.LP_Q:=_buffer.LP_Q-0.01
               ?};
               _can_continue:=PX_GRP.put();

               {? _can_continue>0
               ||
::                Usuwam połączenia grupujące w oryginale, bo mogły się zmienić
                  PX_CONN.prefix(PX_GRP.ref());
                  {? PX_CONN.first()
                  || {!
                     |? _next:=0;
                        _ref_nxt:=null();
                        PX_CONN.cntx_psh();
                        {? PX_CONN.next()
                        || _ref_nxt:=PX_CONN.ref()
                        ?};
                        PX_CONN.cntx_pop();

                        _can_continue:=exec('delete','px_conn',PX_CONN.ref());

                        {? _ref_nxt<>null()
                        || _next:=PX_CONN.seek(_ref_nxt)
                        ?};
                        _next>0 & _can_continue>0
                     !}
                  ?};
                  {? _can_continue>0
                  ||
::                   Klonuję z symulacji połączenia grupujące
                     PX_CONN.prefix(_buffer.Ref);
                     {? PX_CONN.first()
                     || {!
                        |? exec('clone_current','px_conn',PX_GRP.PX_VER,PX_GRP.ref());
                           PX_CONN.next()
                        !}
                     ?}
                  ?}
               ?};

               {? _can_continue>0
               ||
::                Usuwam punkty czasowe
                  _can_continue:=exec('delete4grp','px_point',PX_GRP.ref());

                  {? _can_continue>0
                  ||
::                   klonowanie punktów czasowych
                     PX_POINT.cntx_psh();
                     PX_POINT.index('PX_GRP');
                     PX_POINT.prefix(_buffer.Ref);
                     {? PX_POINT.first()
                     || {!
                        |? exec('clone','px_point',PX_GRP.ref());
                           PX_POINT.next()
                        !}
                     ?};
                     PX_POINT.cntx_pop()
                  ?}
               ?}
            ?}
         ?};

         {? _can_continue>0 & _setlpq>0
         || exec('prenumber','px_grp',PX_GRP.PX_VER)
         ?};
         {? _can_continue>0
         || exec('mod_stamp_queue','px_ver',exec('get_mainversion','px_ver'))
         ?}
      || _msg:='Nie znaleziono elementu: %1 w planie głównym'@[_buffer.SYMBOL];
         {? _grupa>0
         || KOMM.add(_msg,2,,1)
         || FUN.emsg(_msg)
         ?}
      ?};
      PX_GRP.cntx_pop();

      PX_GRP.cntx_psh(); PX_GRP.prefix();
      {? PX_GRP.seek(_ref)
      || {? _can_continue>0
         || PX_GRP.SIM_MOD:='N';
            _can_continue:=PX_GRP.put()
         ?}
      ?};
      PX_GRP.cntx_pop();
      ~~
   ||
::    Nie ma źródłowego, to znak że został dodany w symulacji i trzeba go nanieść na koniec kolejki
      _uid:=exec('uid','#blank');
      PX_GRP.cntx_psh();
      PX_GRP.prefix();
      PX_GRP.blank();
::    Nowy w kolejce będzie posiadał UID_SRC tego z symulacji
      _buffer.UID_SRC:=_buffer.UID;
      _buffer.UID:=_uid;
      _buffer.LP_Q:=_buffer.LP_Q-0.01;
      _buffer.SIM_MOD:='N';
      _buffer.SIM_DEL:='N';

      _buffer.set();
      PX_GRP.PX_VER:=exec('get_mainversion','px_ver');
      _can_continue:=PX_GRP.add();

      {? _can_continue>0
      ||
::       Klonuję z symulacji połączenia grupujące
         PX_CONN.prefix(_buffer.Ref);
         {? PX_CONN.first()
         || {!
            |? exec('clone_current','px_conn',PX_GRP.PX_VER,PX_GRP.ref());
               PX_CONN.next()
            !}
         ?}
      ?};
      {? _can_continue>0
      ||
::       klonowanie punktów czasowych
         PX_POINT.cntx_psh();
         PX_POINT.index('PX_GRP');
         PX_POINT.prefix(_buffer.Ref);
         {? PX_POINT.first()
         || {!
            |? exec('clone','px_point',PX_GRP.ref());
               PX_POINT.next()
            !}
         ?};
         PX_POINT.cntx_pop()
      ?};
      PX_GRP.cntx_pop();
      {? _can_continue>0
      || PX_GRP.UID_SRC:=_uid;
         PX_GRP.SIM_MOD:='N';
         _can_continue:=PX_GRP.put()
      ?};

::      {? _can_continue>0
::      || exec('prenumber','px_grp',exec('get_mainversion','px_ver'))
::      ?};

      {? _can_continue>0
      || exec('mod_stamp_queue','px_ver',exec('get_mainversion','px_ver'))
      ?}
   ?}
?};
PX_GRPS.cntx_pop();
PX_GRP.cntx_pop();
PX_CONN.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result


\copy_from_whatif_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja grupa przed Nanieś w symulacji whatif
::   WY: 0/1
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='T';
KOMM.init(250,,'Nanoszenie symulacji na plan główny'@);
_can_continue:=FUN.ask('Zaznaczonych elementów kolejki: %1. Nanieść je na plan główny?'@[$PX_GRPS.sel_size()]);
_can_continue


\copy_from_whatif_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja grupa po Nanieś w symulacji whatif
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\set_sim_mod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Dla grupy w innej wersji niż główna oznacza grupę jako poprawioną
::   WE: [_a] - PX_GRP.ref() lub bieżący rekord
::        _b  - STRING - 'T','N' - zmodyfikowane czy nie
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};
_mod:=_b;

_result:=0;
_can_continue:=1;
PX_VER.cntx_psh();
PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? PX_GRP.PX_VER().WHATIF='T'
   || PX_GRP.SIM_MOD:=_mod;
      _can_continue:=PX_GRP.put()
   ?}
?};
PX_GRP.cntx_pop();
PX_VER.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


:Sign Version 2.0 jowisz:1045 2023/10/23 13:36:06 0d6634cebb55b12ae5c7785653430a831895ccb683ef62adcd4212be9e252a2748ef32d25b58f222046cc938d2f0baabd00a0034dd08406392cdbbed1aef797c39d71d8ee9c3c5f4782baff6154af8e37763943d098b08cfaa34f9e2c9d96b3d2f22ca37756135505de19b7e613d45b8c9babcc7bc78b4c1783069aa344402a3
