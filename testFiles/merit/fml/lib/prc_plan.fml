:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: prc_plan.fml
:: Utworzony: 11.10.2017
:: Autor: TMR
::======================================================================================================================
:: Zawartość: Formuły do obsługi planowania - dziedzina PRC
::======================================================================================================================

\prac_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Tworzy tabele pracownikow podwladnych w zaleznosci od uprawnien w portalu
::   WE: _a   - [STRING]  - ref_sql kierownika (osoba)
::       _b   - [STRING]  - ref_sql kierownika (pracownik)
::       _c   - [STRING]  - login
::       _d   - [STRING]  - zrodlo wywolania - czy planowanie, czy grafiki (p/g)
::       _e   - [INTEGER] - czy pobierać tez informację o mnie (kierowniku) (1- domyślnie tak / 0- tylko podwładni)
::       [_f] - [DATE]    - data od - w celu sprawdzenia oddelegowań
::       [_g] - [DATE]    - data do - w celu sprawdzenia oddelegowań
::   WY: tabela z pracownikami
::  OLD: \prac_all/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=exec('tab_zal','stanprac');
_os_ref:={? var_pres('_a')=type_of(null()) || _a || return(_tab) ?};
 _p_ref:={? var_pres('_b')=type_of(null()) || _b || return(_tab) ?};
 _login:={? var_pres('_c')=type_of('')     || _c || return(_tab) ?};
    _pg:={? var_pres('_d')=type_of('')     || _d || return(_tab) ?};
    _ja:={? var_pres('_e')=type_of(0)      || _e || 1            ?};
   _beg:={? var_pres('_f')=type_of(date()) || _f || date(0,0,0)  ?};
   _end:={? var_pres('_g')=type_of(date()) || _g || date(0,0,0)  ?};

:: dodanie kierownika
UD_SKL.cntx_psh();
STN.cntx_psh();
OSOBA.cntx_psh();
OSOBA.prefix();
P.cntx_psh();
P.clear();
{? P.seek(_p_ref)
|| _szef_ref:=P.ref()
|| _szef_ref:=null()
?};

_lRole:=exec('role','prc_dane');
:: spradź czy mogę pobierać dane podwładnych
_dane_pod:=exec('dane_rola','prc_plan','P',_lRole);

{? _dane_pod
|| &_tab;
   _tab:=exec('prac_pod','prc_plan',_os_ref);
   {? _tab.first()
   || {!
      |? _tab.EDYCJA:='T';
         _tab.put();
         _tab.next()
      !}
   ?};
:: dodanie pracowników z wtyczki
   {? Plugin.runnable('PRC_POR_RCZP_DOD_PRAC')
   || Plugin.run('PRC_POR_RCZP_DOD_PRAC',_tab,_szef_ref)
   ?};
:: wyszukanie pracowników oddelegowanych do mnie
   _kodOdde:=exec('getKod4Plan','prc_oddel');
   {? OSOBA.seek(_os_ref)
   || P.index('OSOBA');
      P.prefix(_os_ref);
      {? P.first()
      || {!
         |? {? var_pres('_tabOdde')>100 || obj_del(_tabOdde) ?};
            _tabOdde:=exec('find','prc_oddel',_kodOdde,P.ref(),,'TO',_beg,_end,1,0);
            {? type_of(_tabOdde)=type_of(SYSLOG) & _tabOdde.first()
            || P.cntx_psh();
               P.prefix();
               {!
               |? {? P.seek(BIT.sqlint(_tabOdde.P),) & (P.ref()<>_szef_ref)
                  || _tab.blank(1);
                     _tab.P:=P.ref();
                     {? ~_tab.find_rec()
                     || _tab.NAZWISKO:=P.OSOBA().NAZWISKO;
                        _tab.IMIE:=P.OSOBA().PIERWSZE;
                        _tab.T:=|P.T;
                        _tab.WYDZIAL:=P.WYDZIAL().SYMBOL;
                        _tab.STN:=P.ST().ST;
                        _tab.ZA:=P.ZA;
                        _tab.ID:=P.IP;
                        _tab.P_SQL:=$P.ref;
                        _tab.J:=P.WYDZIAL().SYMBOL;
                        _tab.CZY_POD:='O';
                        _tab.F_ZATR:=P.F_ZATR().KOD;
                        _tab.EDYCJA:='T';
                        _tab.add()
                     ?}
                  ?};
                  _tabOdde.next()
               !};
               P.cntx_pop()
            ?};
            P.next()
         !}
      ?}
   ?}
?};

:: spradź czy mam i czy moge pobierać własne dane
{? _ja
|| _dane_wl:=exec('dane_rola','prc_plan','W',_lRole);
   {? _dane_wl
   || {? OSOBA.seek(_os_ref)
      || P.index('OSOBA');
         P.prefix(_os_ref,REF.FIRMA);
::       dodanie wszystkich przebiegow kierownika
         {? P.first()
         || {!
            |? _tab.blank(1);
               _tab.P_SQL:=$P.ref;
               _tab.NAZWISKO:=OSOBA.NAZWISKO;
               _tab.IMIE:=OSOBA.PIERWSZE;
               {? ~_tab.find_rec()
               || _wydzial:=P.WYDZIAL().SYMBOL;
                  _tab.L:=0;
                  _tab.NAZWISKO:=OSOBA.NAZWISKO;
                  _tab.IMIE:=OSOBA.PIERWSZE;
                  _tab.T:=|P.T;
                  _tab.WYDZIAL:=_wydzial;
                  _tab.STN:=P.ST().ST;
                  _tab.ZA:=P.ZA;
                  _tab.ID:=P.IP;
                  _tab.P:=P.ref;
                  _tab.P_SQL:=$P.ref;
                  _tab.J:=_wydzial;
                  _tab.F_ZATR:=P.F_ZATR().KOD;
                  _tab.EDYCJA:='T';
                  _tab.add()
               ?};
               P.next()
            !}
         ?}
      ?}
   ?}
?};
P.cntx_pop();
OSOBA.cntx_pop();
STN.cntx_pop();
UD_SKL.cntx_pop();
_tab


\prac_pod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Wyszukuje pracownikow podwladnych do planowania i grafikow
::   WE: _a  [REFERENCE] - wskazanie na osobe (ref lub nr)
::   WY: tabela z pracownikami podwladnymi
::  OLD: \prac_pod/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_xOsoba:={? var_pres('_a')=type_of(0) | var_pres('_a')=type_of(null())  || _a || return(_lTab) ?};
exec('prac_pod','stanprac',_xOsoba,'TYPPOZ','PLANCZP')


\find_p_gr_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Znajduje grupe do ktorej przypisany jest podwladny w portalu
::   WE: _a - P.ref (ref pracownika bedacego kierownikiem)
::     : _b - P.ref sql (ref sql pracownika podwladnego)
::   WY: ref_sql grupy lub ''
::  OLD: \find_p_gr_p/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null) || return('') ?};
{? var_pres('_b')<>type_of('_b') || return('') ?};
_ret_val:='';
P.cntx_psh();
P.clear();
{? P.seek(BIT.sqlint(_b),)
|| _p_ref:=P.ref()
|| _p_ref:=null()
?};
P_GR_P.cntx_psh();
P_GR_P.use('p_gr_p');
P_GR_P.index('PPOD');
P_GR_P.prefix(_a,_p_ref);
{? P_GR_P.first()
|| _ret_val:=$P_GR_P.GRUPA
?};
P_GR_P.cntx_pop();
P.cntx_pop();
_ret_val


\find_scp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Wyszukuje na dany dzien kalendarzowy system czasu pracy przypięty do pracownika
::   WE: _a - ref pracownika
::       _b - data kontroli
::   WY: ref systemu czasu pracy lub null
::  OLD: \find_scp/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null) || return(0) ?};
{? var_pres('_b')<>type_of(date) || return(0) ?};
_scp_ref:=null();
A_SCPP.cntx_psh();
A_SCPP.use('x_scpi');
A_SCPP.index('POD');
A_SCPP.prefix(_a);
{? A_SCPP.find_le(_b)
||
   _scp_ref:=A_SCPP.A_SCP
?};
A_SCPP.cntx_pop();
_scp_ref


\mod_kal_day
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
::  MOD: MicKoc [22.26]
:: OPIS: Modyfikuje dzien w kalendarzu indywidualnym (brudnopisie) pracownika
::   WE:  _a - P.ref
::        _b - DATA         date
::        _c - DATAW        date
::        _d - TYP          string[1]
::        _e - RODZAJ       string[1]
::        _f - POCZATEK     time
::        _g - KONIEC       time
::        _h - CZAS         time
::        _i - TYP_BRUDNOPISU 'p'(Plan)/'g'(Grafik)/'w'(Wykonanie)
::        _j - KAL_ROK.ref
::        _k - [STRING] - OPIS - opis dnia
::        _l - [STRING] - TYPWS - typ dnia wolnego/świątecznego
::        _m - P_DATA     date - data rozpoczęcia przerwy
::        _n - P_START    time - godzina rozpoczęcia przerwy
::        _o - P_CZAS     time - czas trwania przerwy
::        _p - ZMIANA     ref - wskazanie na zmianę
::   WY: 0 lub 1 lub kod bledu
::       -1 - nie mozna modyfikowac dnia - okres rozliczeniowy jest zamkniety
::       -2 - nie mozna zmodyfikować czasu pracy w buforze - istnieje w tym dniu rozliczona nieobecnosc
::  OLD: \mod_kal_day/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null) || return(0) ?};
{? var_pres('_b')<>type_of(date) || return(0) ?};
{? var_pres('_c')<>type_of(date) || return(0) ?};
{? var_pres('_d')<>type_of('_d') || return(0) ?};
{? var_pres('_e')<>type_of('_e') || return(0) ?};
{? var_pres('_f')<>type_of(time) || return(0) ?};
{? var_pres('_g')<>type_of(time) || return(0) ?};
{? var_pres('_h')<>type_of(time) || return(0) ?};
_gpw:={? var_pres('_i')<>type_of('_i') || return(0) || ~-_i ?};
{? var_pres('_j')<>type_of(null) || _kal_rok:=null() || _kal_rok:=_j ?};
_opis:={? var_pres('_k')<>type_of('_k') || '' || _k ?};
_typWS:={? var_pres('_l')<>type_of('_l') || '' || form(_l) ?};
_p_data:={? var_pres('_m')=type_of(date) || _m || #0 ?};
_p_start:={? var_pres('_n')=type_of(time) || _n || *0 ?};
_p_czas:={? var_pres('_o')=type_of(time) || _o || *0 ?};
_zmiana:={? var_pres('_p')=type_of(null) || _p || null() ?};
_przerwy:=exec('isEnabled','prc_przerwy');

A_SCPP.cntx_psh();
A_SCPP.use('x_scpi');
A_SCPP.index('POD');
KAL_DEF.cntx_psh();
P.cntx_psh();
P.clear();
_ret_val:=0;
_dzien:=_b;
{? _gpw = 'P' | _gpw = 'G' | _gpw = 'W'
|| 1
||
   P.cntx_pop();
   KAL_DEF.cntx_pop();
   A_SCPP.cntx_pop();
   return(0)
?};
_errCode:=0;
_okr_ref:=null();
{?  P.seek(_a)
||
   A_SCPP.prefix(P.ref);
   _p_ref:=P.ref();
::sprawdzenie czy okres rozliczeniowy jest otwarty i czy jest otwarty do planowania
   _okres_p:=exec('find_okr','grafik',_p_ref,_dzien,'okrp');
   {? _okres_p
   ||
      A_OKRP.cntx_psh();
      A_OKRP.use('x_okrpi');
      A_OKRP.clear();
      {? A_OKRP.seek(_okres_p)
      || _korekta:=((A_OKRP.S_PLAN='K') | exec('getStatusM_Plan','okres',_okres_p,_dzien~1,_dzien~2)='K');
         {? _gpw='P'
         || {? ((A_OKRP.S_PLAN='O') & (A_OKRP.OKR().S_PLAN='O') & (A_OKRP.OKR().S='O')) | _korekta
            || _errCode:=0
            || _errCode:=-1
            ?}
         |? (_gpw='G' | _gpw='W')
         || {? A_OKRP.OKR().S='O'
            || {? exec('get_msc_status','grafik',_dzien)='Z' | exec('getPlanStat4Pr','grafik',_p_ref,_dzien)='X'
               || _errCode:=-3
               |? exec('wyk_D_rozl','prc_graf',_p_ref,_dzien)
                  & (~exec('usun_wewy','prc_wewy',_p_ref,(_dzien-1)~1,(_dzien-1)~2,5,(_dzien-1)))
               || _errCode:=-4
               ?}
            || _errCode:=-1
            ?}
         ?};
         _okr_ref:=A_OKRP.OKR
      ?};
      A_OKRP.cntx_pop()
   ?};
   {? _errCode<>0
   || P.cntx_pop();
      KAL_DEF.cntx_pop();
      A_SCPP.cntx_pop();
      return(_errCode)
   ?};

:: sprawdz czy istnieje grafik dla pracownika i jezeli nie to go utworz
   {? _kal_rok = null()
   || _kal_rok:=exec('jest_grafik_rok','grafik',_p_ref,_dzien)
   ?};
::  jezeli jest juz rok lub zostal poprawnie utworzony to mozna modyfikowac
   _kal_buff:=0;
   {?  _kal_rok <> null()
   || KAL_BUFF.cntx_psh();
      KAL_BUFF.index('PRZNODT');
      KAL_BUFF.prefix(_p_ref,_gpw,'T',_dzien);
      {? KAL_BUFF.first()
      || _kal_buff:=1;
::       dla planowania i warstwy grafiku sprawdz czy nie ma rozliczonej nieobecnosci w tym dniu
         _nieob_lt:=exec('czy_nieob_lt','prc_graf',_p_ref,_dzien);
         {? (_gpw = 'P' | _gpw = 'G') &_nieob_lt=2 & KAL_BUFF.CZAS<>_h
         || _ret_val:=-2
         || KAL_BUFF.DATAW:=_c;
            KAL_BUFF.TYP:=_d;
            KAL_BUFF.TYPWS:=_typWS;
            KAL_BUFF.RODZAJ:=_e;
            KAL_BUFF.POCZATEK:=_f;
            KAL_BUFF.KONIEC:=_g;
            KAL_BUFF.CZAS:=_h;
            KAL_BUFF.OPIS:=_opis;
            KAL_BUFF.STATUS:='M';
            KAL_BUFF.TM_P:=KAL_BUFF.tm_stamp();
            KAL_BUFF.ZMIANA:={? KAL_BUFF.TYP='R' || _zmiana || null() ?};
            {? _przerwy
            || KAL_BUFF.P_DATA:=_p_data;
               KAL_BUFF.P_START:=_p_start;
               KAL_BUFF.P_CZAS:=_p_czas
            ?};
            _ret_val:=KAL_BUFF.put(1)
         ?}
      ?};
::    zmodyfikuj zapisy dla dnia w innych okresach rozliczeniowych
      {? _ret_val>0
      || KAL_BUFF.cntx_psh();
         KAL_BUFF.prefix(_p_ref,_gpw,'N',_dzien);
         {? KAL_BUFF.first()
         || {!|?
               KAL_BUFF.DATAW:=_c;
               KAL_BUFF.TYP:=_d;
               KAL_BUFF.TYPWS:=_typWS;
               KAL_BUFF.RODZAJ:=_e;
               KAL_BUFF.POCZATEK:=_f;
               KAL_BUFF.KONIEC:=_g;
               KAL_BUFF.CZAS:=_h;
               KAL_BUFF.OPIS:=_opis;
               KAL_BUFF.STATUS:='M';
               KAL_BUFF.TM_P:=KAL_BUFF.tm_stamp();
               KAL_BUFF.ZMIANA:={? KAL_BUFF.TYP='R' || _zmiana || null() ?};
               {? _przerwy
               || KAL_BUFF.P_DATA:=_p_data;
                  KAL_BUFF.P_START:=_p_start;
                  KAL_BUFF.P_CZAS:=_p_czas
               ?};
               KAL_BUFF.put(1);
               KAL_BUFF.next()
            !}
         ?};
         KAL_BUFF.cntx_pop()
      ?};
::    jezeli to jest wykonanie i nie ma w buforze to dodaj
      {? (_gpw = 'W') & (~_kal_buff)
      || KAL_BUFF.blank(1);
         KAL_BUFF.P:=_p_ref;
         KAL_BUFF.A_OKR:=_okr_ref;
         KAL_BUFF.GPW:=_gpw;
         KAL_BUFF.CZY_OKR:='T';
         KAL_BUFF.TM_P:=KAL_BUFF.tm_stamp();
         KAL_BUFF.DATA:=_dzien;
         KAL_BUFF.DATAW:=_c;
         KAL_BUFF.TYP:=_d;
         KAL_BUFF.RODZAJ:=_e;
         KAL_BUFF.POCZATEK:=_f;
         KAL_BUFF.KONIEC:=_g;
         KAL_BUFF.CZAS:=_h;
         KAL_BUFF.OPIS:=_opis;
         KAL_BUFF.STATUS:='M';
         KAL_BUFF.A_SCP:={? A_SCPP.find_le(_dzien) || A_SCPP.A_SCP || null() ?};
         KAL_BUFF.ZMIANA:={? KAL_BUFF.TYP='R' || _zmiana || null() ?};
         {? _przerwy
         || KAL_BUFF.P_DATA:=_p_data;
            KAL_BUFF.P_START:=_p_start;
            KAL_BUFF.P_CZAS:=_p_czas
         ?};
         KAL_BUFF.prefix();
         _ret_val:=KAL_BUFF.add(1)
      ?};
      KAL_BUFF.cntx_pop()
   ?};
::    zmodyfikuj status dla dnia w kalendarzu
   {? (_gpw='P') & (_ret_val>0)
   || __KAL.set_cal(P.KAL,_dzien~1);
      {? __KAL.get_day(_dzien) & __KAL.grafik(_dzien)='T'
      || {? KAL_DEF.STATUS<>'M'
         || KAL_DEF.STATUS:='M';
            KAL_DEF.put(1)
         ?}
      ?}
   ?}
?};
A_SCPP.cntx_pop();
P.cntx_pop();
KAL_DEF.cntx_pop();
_ret_val


\copy_buff_day
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51_24]
:: OPIS: Kopiuje dzień w buforze pomiędzy warstwami. Bazujemy na dniu z warstwy źródłowej, która należy do okresu.
::   WE: _a [REFERENCE] - wskazanie na pracowika
::       _b [DATE]      - data
::       _c [STRING]    - warstwa źródłowa
::       _d [STRING]    - warstwa docelowa
::   WY: 0/liczba zmodyfokowanych rekordów
::  OLD: \copy_buff_day/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_p_ref:={? var_pres('_a')=type_of(null) || _a || return(_result) ?};
 _date:={? var_pres('_b')=type_of(date) || _b || return(_result) ?};
  _w_s:={? var_pres('_c')=type_of('')   || _c || return(_result) ?};
  _w_d:={? var_pres('_d')=type_of('')   || _d || return(_result) ?};

{? (_w_s='P' | _w_s='G' | _w_s='W') & (_w_d='P' | _w_d='G' | _w_d='W')
||
:: powrot w przypadku zerwanej transakcji
   {? do_state()=2 || return(_result) ?};

:: zalozenie transakcji
   _mydo:=do_state()=0;
   {? _mydo || do() ?};

   KAL_BUFF.cntx_psh();
   KAL_BUFF.index('PRZNODT');
   KAL_BUFF.prefix(_p_ref,_w_s,'T',_date);
   {? KAL_BUFF.first()
   || _buff:=exec('oBuff','prc_plan');
      _buff.push(KAL_BUFF.DATA);
      KAL_BUFF.index('PRACDATA');
      KAL_BUFF.prefix(_p_ref,_date);
      {? KAL_BUFF.first()
      || {!
         |? {? KAL_BUFF.GPW=_w_d
            || _buff.pop();
               KAL_BUFF.cntx_psh();
               KAL_BUFF.prefix();
               _result+=KAL_BUFF.put(1);
               KAL_BUFF.cntx_pop()
            ?};
            KAL_BUFF.next()
         !}
      ?}
   ?};
   KAL_BUFF.cntx_pop();

   {? _mydo || end() ?}
?};
_result


\akt_buff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [mk] [12.10]
:: OPIS: Trigery
::   WE: _a - akcja
::       _b - uchwyt do tabeli
::   WY:
::  OLD: \akt_buff/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_ret_val:=~~;

:: jeżeli mamy ustawione flagi wyłączające trigggery dla tabel H, N, lub KAL_BUFF to wychodzimy
{? TRIG_OFF.N='T' | TRIG_OFF.H='T' | TRIG_OFF.KAL_BUFF='T'
|| return(_ret_val)
?};

:: jeżeli nie mamy licencji na dziedzinę to wracamy
{? ~exec('lic','#b_domain','PRC') || return(_ret_val) ?};

{? _b=N | (_b=H & _b.KZ().KZ<>'Z')
|| {? (_a='add') |
      (_a='put' &
         (bfld('OD')<>_b.OD | bfld('DO')<>_b.DO |
         {? _b=N || (bfld('NB')<>_b.NB) | (bfld('KOR')='T' & _b.KOR='N') || bfld('KZ')<>_b.KZ ?})
      )
   || KAL_BUFF.index('PRACDATA');
      {? _a='put'
      || _od:=bfld('OD');
         _do:=bfld('DO');
        {! _licz:=#_od..#_do
        |! KAL_BUFF.prefix(_b.P, #_licz);
           {? KAL_BUFF.first()
           || {!
              |? _mod:=1;
                 {? _b=N
                 || _kod_188:=__RUB.sys_rub(1162,KAL_BUFF.DATA).RN;
                    _mod:=(_kod_188<>N.NB().RN) | (bfld('NB')<>N.NB)
                 ?};
                 {? _mod
                 || KAL_BUFF.NB:=KAL_BUFF.NH:='';
                    KAL_BUFF.put()
                 ?};
                 KAL_BUFF.next()
              !}
           ?}
        !};
         _od:=_b.OD;
         _do:=_b.DO
      || _od:={? _a='add' || _b.OD || {? bfld('OD')<_b.OD || bfld('OD') || _b.OD ?} ?};
         _do:={? _a='add' || _b.DO || {? bfld('DO')>_b.DO || bfld('DO') || _b.DO ?} ?}
      ?};
      {! _licz:=#_od..#_do
      |! KAL_BUFF.prefix(_b.P, #_licz);
         {? KAL_BUFF.first()
         || {!
            |? {? KAL_BUFF.DATA>=_b.OD & KAL_BUFF.DATA<=_b.DO
               || _mod:=1;
                  {? _b=N
                  || _kod_mac:=__RUB.sys_rub(11522,KAL_BUFF.DATA).RN;
                     _kod_rod:=__RUB.sys_rub(11542,KAL_BUFF.DATA).RN;
                     _kod_188:=__RUB.sys_rub(1162,KAL_BUFF.DATA).RN;
                     _mod:=(_kod_mac<>N.NB().RN) & (_kod_rod<>N.NB().RN) & (_kod_188<>N.NB().RN)
                  ?};
                  {? _mod
                  || KAL_BUFF.NB:={? _b=N || $N.NB().RN || $exec('H2N_kod','prc_plan',H.KZ().KZ) ?};
                     KAL_BUFF.NH:=$_b.ref
                  ?}
               || KAL_BUFF.NB:=KAL_BUFF.NH:=''
               ?};
               KAL_BUFF.put();
               KAL_BUFF.next()
            !}
         ?}
      !}
   |? _a='put' & {? _b=N || bfld('NB')<>_b.NB || bfld('KZ')<>_b.KZ ?}
   || KAL_BUFF.index('NIEOBECN');
      KAL_BUFF.prefix($_b.ref(),);
      {? KAL_BUFF.first()
      || {!
         |? _mod:=1;
            {? _b=N
            || _kod_mac:=__RUB.sys_rub(11522,KAL_BUFF.DATA).RN;
               _kod_rod:=__RUB.sys_rub(11542,KAL_BUFF.DATA).RN;
               _kod_188:=__RUB.sys_rub(1162,KAL_BUFF.DATA).RN;
               _mod:=(_kod_mac<>N.NB().RN) & (_kod_rod<>N.NB().RN) & (_kod_188<>N.NB().RN)
            ?};
            {? _mod
            || KAL_BUFF.NB:={? _b=N || $N.NB().RN || $exec('H2N_kod','prc_plan',H.KZ().KZ) ?};
               KAL_BUFF.NH:=$_b.ref();
               KAL_BUFF.put()
            ?};
            KAL_BUFF.next()
         !}
      ?}
   |? _a='del' | (_a='put' & {? _b=N || bfld('KOR')='N' & _b.KOR='T'  ?})
   || KAL_BUFF.index('NIEOBECN');
      KAL_BUFF.prefix($_b.ref(),);
      {!
      |? KAL_BUFF.first()
      |! KAL_BUFF.NB:=KAL_BUFF.NH:='';
         KAL_BUFF.cntx_psh();
         KAL_BUFF.prefix('',);
         KAL_BUFF.put();
         KAL_BUFF.cntx_pop()
      !};
      {? _a='del' || _ret_val:=1 ?}
   ?}

|? _b=H & _b.KZ().KZ='Z'
||
   {? (_a='put' & (bfld('DOP_NADG')<>_b.DOP_NADG))
   || KAL_BUFF.index('PRACDATA');
      _od:=_b.OD;
      _do:=_b.DO;
      KAL_BUFF.prefix(_b.P);
      {? KAL_BUFF.find_ge(_od)
      || {!
         |? {? (KAL_BUFF.DATA>=_od) & (_do=date(0,0,0) | KAL_BUFF.DATA<=_do)
            || KAL_BUFF.DOP_NADG:=_b.DOP_NADG;
               KAL_BUFF.TM_X:=KAL_BUFF.tm_stamp();
               KAL_BUFF.put()
            ?};
            KAL_BUFF.next()
         !}
      ?}
   ?};
   {? _a='add' | _a='del' | (_a='put' & (bfld('OD')<>_b.OD | bfld('DO')<>_b.DO))
   ||
      _od:={? _a='add' | _a='del' || _b.OD || {? bfld('OD')<_b.OD || bfld('OD') || _b.OD ?} ?};
      _do:={? _a='add' | _a='del' || _b.DO || {? bfld('DO')>_b.DO & _b.DO<>date(0,0,0) || bfld('DO') || _b.DO ?} ?};
::     sprawdz czy to pierwszy zapis w H
      _prev_h:=1;
      _b.cntx_psh();
      _b.index('_HISTKOD');
      _b.prefix(_b.P,'Z');
      _prev_h:=_b.prev();
      _b.cntx_pop();
::     sprawdz czy jest to ostatni zapis w H
      _next_h:=1;
      _b.cntx_psh();
      _b.index('_HISTKOD');
      _b.prefix(_b.P,'Z');
      _next_h:=_b.next();
      _b.cntx_pop();
::    zaktualizowanie wskazania na H i wymiaru
      {? _a='del'
      || {? _b.ref()
         || KAL_BUFF.index('PRZEBIEG');
            KAL_BUFF.prefix(_b.ref());
            {!
            |? KAL_BUFF.first()
            |! KAL_BUFF.H:=null();
               KAL_BUFF.cntx_psh();
               KAL_BUFF.prefix();
               KAL_BUFF.put();
               KAL_BUFF.cntx_pop()
            !}
          ?};
         _ret_val:=1
      || KAL_BUFF.index('PRACDATA');
         KAL_BUFF.prefix(_b.P);
         {? ~_prev_h
         || {? KAL_BUFF.first()
            || {! |? {? KAL_BUFF.DATA<_b.OD || KAL_BUFF.del() ?} !}
            ?}
         ?};
         {? KAL_BUFF.find_ge(_od) | KAL_BUFF.first()
         || _fml:="KAL_BUFF.DATA>=_b.OD & (KAL_BUFF.DATA<=_b.DO | _b.DO=date(0,0,0))";
            exec('akt_buff_zm_wym','prc_plan',_a,_b,_fml)
         ?}
      ?};
      {? _a='add'
      ||
::       sprawdz w jakim pracownik jest okresie na dzien przed nowym przebiegiem
         _t_okrp:=exec('getOkrpFromDate','grafik',_b.P,_od-1)
      |? _a='del'
      ||
::       sprawdz w jakim pracownik jest okresie na dzien przed ostatnim lub dzien po pierwszym usuwanym przebiegu
         {? (~_prev_h)
         || {? _do<>date(0,0,0)
            || _od:=_do+1
            ?}
         ?};
         {? (~_next_h) || _od:=_od-1 ?};
         _t_okrp:=exec('getOkrpFromDate','grafik',_b.P,_od)
      |? _a='put'
      ||
::       utworzenie pustej tabeli
         _t_okrp:=exec('getOkrpFromDate','grafik',null());
::       jezeli zmienila sie data DO
         _old_do:=bfld('DO');
         {? _old_do<>_b.DO
         || {? (_old_do<>date(0,0,0)) & (_old_do<_b.DO) | (_b.DO=date(0,0,0))
            ||
::            to sprawdz w jakim pracownik jest okresie na stara date DO
              exec('getOkrpFromDate','grafik',_b.P,_old_do,_t_okrp)
            |? ((_old_do<>date(0,0,0)) & (_old_do>_b.DO)) | (_old_do=date(0,0,0))
            ||
::             to sprawdz w jakim pracownik jest okresie na nowa date DO
               exec('getOkrpFromDate','grafik',_b.P,_b.DO,_t_okrp)
            ?}
         ?};
::       jezeli zmienila sie data OD
         _old_od:=bfld('OD');
         {? _old_od<>_b.OD
         ||
            {? _prev_h
            ||
::             sprawdz na date przed rozpoczeciem tego przebiegu w H
               exec('getOkrpFromDate','grafik',_b.P,_b.OD-1,_t_okrp)
            ||
::             sprawdz na stara date OD
               exec('getOkrpFromDate','grafik',_b.P,_old_od,_t_okrp)
            ?}
         ?}
      ?};
::    dla wszystkich wyszukanych okresow pracownika zaktualizuj bufor planowania i grafikow
      {? _t_okrp.first()
      || A_OKR.cntx_psh();
         A_OKRP.cntx_psh();
         A_OKRP.clear();
         {!
         |? {? A_OKRP.seek(_t_okrp.NR,_t_okrp.MASK)
            || _okr_od:=A_OKRP.OKR().OD;
               _okr_do:=A_OKRP.OKR().DO;
               {? _a='del'
               || _new_od:={? _prev_h
                           || _okr_od
                           || {? _b.DO=date(0,0,0) || _okr_do+1 || {? _b.DO<=_okr_do || _b.DO+1 || _okr_do+1 ?} ?}
                           ?};
                  _new_do:={? (~_next_h)
                           || _b.OD-1
                           || {? _b.DO=date(0,0,0) | _b.DO>=_okr_do || _okr_do || A_OKRP.DO ?}
                           ?}
               ||
                  _new_od:={? _prev_h
                           || _okr_od
                           || {? _b.OD<_okr_od || _okr_od || _b.OD ?}
                           ?};
                  _new_do:={? (~_next_h) & (_b.DO>=_okr_od) & (_b.DO<=_okr_do)
                           || _b.DO
                           || {? _b.DO=date(0,0,0) | _b.DO>=_okr_do || _okr_do || A_OKRP.DO ?}
                           ?}
               ?};
               {? ~_prev_h
               || A_OKRP.OD:=_new_od
               ?};
               _max_do:=exec('get_aokrd_do','grafik',_b.P,_new_do,A_OKRP.OKR().NAZ);
::             jezeli nowa data zawiera się w znalezionym okresie
               {? (_max_do<>date(0,0,0)) & (_max_do<_new_do) & (_max_do>=_okr_od)
               || _new_do:=_max_do
               ?};
               A_OKRP.DO:=_new_do;
               {? A_OKRP.DO>=A_OKRP.OD
               || A_OKRP.put();
                  exec('oblicz','okres',1);
::             zaktualizuj bufory planowania
                  {? _a<>'del'
                  || _rok_od:=A_OKRP.OD~1; _msc_od:=A_OKRP.OD~2;
                     _rok_do:=A_OKRP.DO~1; _msc_do:=A_OKRP.DO~2;
                     _rok:=_rok_od; _msc:=_msc_od;
                     _loop:=0; _dalej:=1;
                     {!
                     |? _loop+=1;
                        _pocz:={? date(_rok,_msc,1)<A_OKRP.OD || A_OKRP.OD || date(_rok,_msc,1) ?};
                        _kon:={? date(_rok,_msc,0)>A_OKRP.DO || A_OKRP.DO || date(_rok,_msc,0) ?};
                        _status:=exec('getStatusM_Plan','okres',A_OKRP.ref(),_rok,_msc);
                        {? _status=''
                        || _status:=exec('getMscPlanStat','okres',_rok,_msc)
                        ?};
                        {? _status='' || _status:=A_OKRP.S_PLAN ?};
                        {? _status='Z'
                        || exec('dodaj_do_buff','grafik','P',_b.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,_a='add',0,_pocz,_kon)
                        || exec('dodaj_do_buff','grafik','P',_b.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,2,0,_pocz,_kon)
                        ?};
                        exec('dodaj_do_buff','grafik','G',_b.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,1,0,_pocz,_kon);
                        exec('dodaj_do_buff','grafik','W',_b.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,2);
                        _msc+=1;
                        {? _msc>12 || _rok+=1; _msc:=1 ?};
                        _dalej & ((_rok<_rok_do) | (_rok=_rok_do & _msc<=_msc_do))
                     !}
                  ?}
               ?}
            ?};
            _t_okrp.next()
         !};
::       poza okresem zatrudnienia nie usuwamy planu i grafiku, tylko ustawiamy znacznik CZY_OKR na N
         {? (_a='put') & (_old_do<>_b.DO) & (~_next_h) & (_b.DO<>date(0,0,0))
         || KAL_BUFF.cntx_psh();
            KAL_BUFF.index('PRACDATA');
            KAL_BUFF.prefix(_b.P);
            {? KAL_BUFF.find_ge(_b.DO+1)
            || {!
               |? {? KAL_BUFF.GPW='W'
                  || KAL_BUFF.next()
                  || {? KAL_BUFF.GPW<>'Z'
                     || KAL_BUFF.CZY_OKR:='N';
                        KAL_BUFF.put()
                     ?};
                     KAL_BUFF.next()
                  ?}
               !}
            ?};
            KAL_BUFF.cntx_pop()
         ?};
         A_OKRP.cntx_pop();
         A_OKR.cntx_pop()
      ?};
      exec('aktualPracKal','kaledit',P.ref(),_b.OD,_b.DO,date~1)

   |? _a='put' & bfld('WY')<>_b.WY
   || KAL_BUFF.index('PRZEBIEG');
      KAL_BUFF.prefix(_b.ref());
      {? KAL_BUFF.first()
      || exec('akt_buff_zm_wym','prc_plan',_a,_b)
      ?};
      exec('aktualPracKal','kaledit',P.ref(),_b.OD,_b.DO,date~1);
      exec('aktKalNorm4Prac','grafik',P.ref(),_b.OD,1)

   |? _a='put_a_del'
   || KAL_BUFF.index('PRACDATA');
      KAL_BUFF.prefix(_b.P);
      {? KAL_BUFF.find_ge(_b.OD) | KAL_BUFF.first()
      || exec('akt_buff_zm_wym','prc_plan',_a,_b,"KAL_BUFF.DATA>=_b.OD & (KAL_BUFF.DATA<=_b.DO | _b.DO=date(0,0,0))")
      ?};
      exec('aktualPracKal','kaledit',P.ref(),_b.OD,_b.DO,date~1)
   ?}
?};
_ret_val


\H2N_kod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Zamienia kod nieobecności z H na nr rubryki nieobecności z N. W Mericie przeniesiona dla zgodności
::   WE: _a - symbol przerwy z H
::   WY: nr rubryki
::  OLD: \H2N_kod/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_h_neob:={? var_pres('_a')=type_of('') || _a || '' ?};
_niebecn:=0;
{? _h_neob='B' || _niebecn:=2
|? _h_neob='W' || _niebecn:=3
|? _h_neob='O' || _niebecn:=15
?};
_niebecn


\akt_buff_zm_wym
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [18.02]
::  MOD: MicKoc [22.26]
:: OPIS: Funckja wykorzystywana w triggerze. Zmiana wymiary etatu => zmiana w KAL_BUFFie.
::   WE: _a - rodzaj triggera
::       _b - tabela
::       _c - formuła warunku
::       PL/WRT/CMS-SP/12.30/0021
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_fml:={? var_pres('_c')=type_of("") || _c || "1" ?};
{? var_pres('KOMM')<0 || exec('KOMM','#object') ?};
{? KOMM.is_inited()=0 || KOMM.init(200) ?};
_icon:='xwin16.png:83';

_fNorma:="
   A_SCPP.cntx_psh();
   A_SCPP.index('POD');
   A_SCPP.prefix(_b);
   _godz:=
   {? A_SCPP.find_le(_a)
   || *(A_SCPP.A_SCP().ND)/60
   || _kal_norm:=exec('get_kal_norm','grafik',_b,_a);
      {? _kal_norm=0 || _kal_norm:=8 ?};
      _kal_norm
   ?};
   {? _godz=0 || _godz:=8 ?};
   A_SCPP.cntx_pop();
   *(_godz*60)
";

:: przyspieszenie wyszukania komunikatów
_tabRM:=tab_tmp(,'RM','STRING[30]','Rok i miesiąc','LP','INTEGER','Lp komunikatu');
_tabD:=tab_tmp(,'DATA','DATE','Dzień');
_przerwy:=exec('isEnabled','prc_przerwy');
{? _przerwy
|| {? var_pres('_tabPrz')>100 || obj_del(_tabPrz); &_tabPrz ?};
   _tabPrz:=exec('get4Prac','prc_przerwy',P.ref(),KAL_BUFF.DATA,KAL_BUFF.DATA)
?};


P.cntx_psh();
P.prefix();
{!
|? {? _fml(_a,_b)
   || _msg:='';
      {? KAL_BUFF.GPW='P' & (_b.WYL/_b.WYM)<>KAL_BUFF.WY & _b.P().get()
      || {? __KAL.p_kin(KAL_BUFF.DATA)<>'T'
         || {? var_pres('_wewy')>100 || obj_del(_wewy) ?};
            _wewy:=exec('get_wewy','prc_wewy',KAL_BUFF.DATA,P.ref());
            _brak_wyk:=(_wewy.first()=0);
            _statusM:=exec('getPlanStat4Pr','grafik',P.ref(),KAL_BUFF.DATA);
            {? _statusM<>'Z'
               & exec('get_msc_status','grafik',KAL_BUFF.DATA)='O'
               & _brak_wyk
::            || _proporcja:={? KAL_BUFF.WY=0 || 0 || (_b.WYL/_b.WYM)/KAL_BUFF.WY ?}
            || {? _przerwy
               || _proporcja:=exec('ustaw_buff','prc_przerwy',_tabPrz,2)
               || _proporcja:=exec('ustaw_buff','prc_przerwy',,2)
               ?};
:: jeśli udało się pobrać czas z definicji, proporcja wynika ze zmiany w stosunku do pełnego etatu
:: jeśli się nie udało, proporcja w odniesieniu do poprzedniego zapisu, działanie domyślne
               {? _proporcja
               || _proporcja:={? KAL_BUFF.WY=0 || 0 || _b.WYL/_b.WYM ?}
               || _proporcja:={? KAL_BUFF.WY=0 || 0 || (_b.WYL/_b.WYM)/KAL_BUFF.WY ?}
               ?};
               KAL_BUFF.CZAS:=*(*KAL_BUFF.CZAS*_proporcja);
::              usuniecie informacji o sekundach
               _sek_cz:=KAL_BUFF.CZAS~3;
               {? _sek_cz>0  || KAL_BUFF.CZAS-=time(0,0,_sek_cz) ?};
               _norma:=_fNorma(KAL_BUFF.DATA,P.ref());
               {? KAL_BUFF.CZAS>_norma || KAL_BUFF.CZAS:=_norma?};
               KAL_BUFF.KONIEC:=KAL_BUFF.POCZATEK + KAL_BUFF.CZAS;
               {? KAL_BUFF.KONIEC>time(24,0,0)
               || KAL_BUFF.KONIEC-=time(24,0,0);
                  KAL_BUFF.DATAW:=KAL_BUFF.DATA+1
               || KAL_BUFF.DATAW:=KAL_BUFF.DATA
               ?};
               {? _przerwy
               || exec('ustaw_buff','prc_przerwy',_tabPrz,1)
               || exec('ustaw_buff','prc_przerwy',,1)
               ?};
               {? _przerwy & KAL_BUFF.TYP='R' & R_ZMIANY.seek(_tabPrz.ZM,,1) || KAL_BUFF.ZMIANA:=R_ZMIANY.ref() ?};
:: jeżeli jest przerwa i jest ona poza czasem pracy to zerujemy pola przerwy
               {? _przerwy & KAL_BUFF.P_DATA>#0
               || _prz_od:=KAL_BUFF.P_START+*((KAL_BUFF.P_DATA-KAL_BUFF.DATA)*(*time(24,0,0)));
                  _zawiera:=exec('zawiera','prc_przerwy',KAL_BUFF.POCZATEK,KAL_BUFF.CZAS,_prz_od,KAL_BUFF.P_CZAS,1);
                  {? _zawiera=1
                  || KAL_BUFF.KONIEC:=KAL_BUFF.POCZATEK+KAL_BUFF.CZAS+KAL_BUFF.P_CZAS;
                     {? KAL_BUFF.KONIEC>time(24,0,0)
                     || KAL_BUFF.KONIEC-=time(24,0,0);
                        KAL_BUFF.DATAW:=KAL_BUFF.DATA+1
                     || KAL_BUFF.DATAW:=KAL_BUFF.DATA
                     ?}
                  |? KAL_BUFF.POCZATEK+KAL_BUFF.CZAS<=_prz_od
                  || KAL_BUFF.KONIEC-=KAL_DEF.P_CZAS;
                     KAL_BUFF.P_DATA:=#0;
                     KAL_BUFF.P_START:=KAL_BUFF.P_CZAS:=*0
                  || KAL_BUFF.P_DATA:=#0;
                     KAL_BUFF.P_START:=KAL_BUFF.P_CZAS:=*0
                  ?}
               ?};
               _rm:=KAL_BUFF.DATA$8;
               {? _tabRM.find_key(_rm)
               || _lp:=_tabRM.LP
               || _msg:='Zmiana wymiaru etatu: wprowadzono zmianę w planie czasu pracy w miesiącu %1.'@[(_rm)];
                  _tabRM.RM:=_rm;
                  _tabRM.LP:=_lp:=KOMM.sect_beg(_msg,4);
                  _tabRM.add();
                  KOMM.sect_end()
               ?};

               {? ~_tabD.find_key(KAL_BUFF.DATA)
               || _msg:=' '+$KAL_BUFF.DATA;
                  _lp_add:=KOMM.add(_msg,_icon);
                  KOMM.chngroot(_lp_add,_lp);
                  _tabD.DATA:=KAL_BUFF.DATA;
                  _tabD.add()
               ?}
            ?}
         ?}
      ?};
      KAL_BUFF.H:=_b.ref();
      KAL_BUFF.WY:=_b.WYL/_b.WYM;
      KAL_BUFF.WYL:=_b.WYL;
      KAL_BUFF.WYM:=_b.WYM;
      KAL_BUFF.put()
   ?};
   KAL_BUFF.next()
!};
P.cntx_pop()


\dane_rola
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Funkcja sprawdzajaca czy mam uprawnienia do widoku planowania lub grafikow
::   WE: _a  [STRING] - co sprawdzamy - czy dostęp do danych podwladnych czy własnych ('W'/'P')
::      [_b] [TABLE]  - tabela z rolami
::   WY: 0/1
::  OLD: \dane_pod/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
 _co:={? var_pres('_a')=type_of('') || ~-_a || return(0)               ?};
_tab:={? var_pres('_b')=type_of(P)  || _b   || exec('role','prc_dane') ?};

_sSource:=exec('source4ses_get','prc_ws');
_ret_val:=0;
{? _tab.first()
|| {!
   |? {? _tab.ROLA*(_sSource+'EK'+_co) | _tab.ROLA*(_sSource+'PK'+_co) | _tab.ROLA*(_sSource+'ZK'+_co)
      || _ret_val:=_tab.AKT
      ?};
      (_ret_val=0) & _tab.next()
   !}
?};
_ret_val


\godzWOkresie
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GU [12.10]
:: OPIS: Zwraca ilosc godzin podanego typu dla pracownika w podanym okresie. Moze sluzyc do uzyskania nagdodzin,
::       godzin nocnych lub innych rubryk wymienionych na liscie w parametrze _e.
::       Dla miesiecy zamknietych (w sensie miesiecy z A_OKRM) wchodzacych w zakres dat pobiera dane z tabeli G,
::       a dla otwartych z R_KWGODZ. Jesli brak zapisow w A_OKRM za czesc podanego okresu, to dane pobierane są z G.
::       Sprawdzana jest tez maska tabeli G z roku kolejnego w poszukiwaniu godzin z data z przedzialu zapytania.
::       UWAGA! Za pomoca tej funkcji mozna wydobyc nadgodziny tylko wyplacone, albo wszystkie (z odebranymi).
::       Poniewaz jednak inaczej sa one reprezentowane w tabelach G i R_KWGODZ, obsluga pobierania z R_KWGODZ
::       dopasowuje się automatycznie. Jesli podamy w _e kod 63( np. ',55,56,63,'), to nadgodziny z otwatrych okresow
::       ( z R_KWGODZ) wejda wlacznie z tymi odebranymi i przeciwnie.
::   WE: _a - P.ref
::       _b - data od [DATE]
::       _c - data do [DATE]
::       [_d]  1 - tylko godziny z G;  0 lub brak - z zamknietych okresów G oraz z otwartych okresow brane z  R_KWGODZ.
::       [_e]  String zawierajacy numery rubryk rozdzielone przecinkami,
::            np.: ',55,56,63,' - zwroci sume rubryk wyszczegolnionych w ciagu
::            '' lub brak - wszystkie nadgodziny razem z odbiorami (55,56,63),
::       [_f] 0 lub brak - uwzględniaj status zamkniętego miesiąca; 1 - wymus sprawdzenie w R_KWGODZ
::   WY: suma godzin w podanym okresie [REAL]
::       wynik -1 oznacza blad
::  OLD: \godzWOkresie/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')<>type_of(null) || return(-1) || _a ?};
{? #_p_ref=0 || return(-1) ?};
_od:={? var_pres('_b')<>type_of(date) || return(-1) || _b ?};
_do:={? var_pres('_c')<>type_of(date) || return(-1) || _c ?};
{? _od>_do | _od=date(0,0,0) | _do=date(0,0,0) || return(-1) ?};
{? var_pres('_d')<>1 || _d:=0 ?};
{? var_pres('_e')<>2 || _e:=',55,56,63,' ?};
_onlyR_K:={? var_pres('_f')=type_of(0) || _f || 0 ?};
_odb:=(_e*',63,')>0;
_wynik:=0;
G.cntx_psh();
R_KWGODZ.cntx_psh();
A_OKRM.cntx_psh();
P.cntx_psh();
{? _d
||
:: jeśli _d=1 to tylko zatwierdzone, a więc pobieramy z tabeli G dla całego okresu
   {! _rok:=_od~1.._do~1+1
   |! G.use('godz'+$(_rok));
::    Cntx przywracany dla kazdej maski, a nie tylko dla pierwotnej
      G.cntx_psh();
      G.index('PRRODATA');
      G.prefix(_p_ref,'G');
      {? G.find_ge(_od)
      || {!
         |? {? G.D<=_do & _e*(','+$G.K().RN+',')>0 || _wynik+=G.G ?};
            G.next() & G.D<=_do
         !}
      ?};
      G.cntx_pop()
   !}
||
   A_OKRM.index('A_OKRMR');
:: pętla po kolejnych miesiącach podanego przedziału, żeby móc określić dla każdego miesiąca z osobna czy jest
:: zamknięty i w konsekwencji skąd pobierać dane
:: nie agregujemy przedziałów, ponieważ teoretycznie możliwe jest zamykanie okresów nie w kolejności i mogą się
:: przeplatać zamknięte z otwartymi.
   _rok:=_od~1; _mc:=_od~2;
   {!
   |? _od1:=date(_rok,_mc,1);
      {? _od1<_od || _od1:=_od ?};
      _od2:=_od1;
      _do1:=date(_rok,_mc,0);
      {? _do1>_do || _do1:=_do ?};
      A_OKRM.prefix(_rok,_mc);
::    jesli brak zapisu w A_OKRM na dany miesiąc, to dane pobieramy z G
      _dz:=_do1;
      _mStatus:=exec('get_msc_status','grafik',_od1);
      {? _mStatus='Z'
      || _dz:=exec('getMscCloseDate','grafik',_do1,1)
      ?};
      _chk_R_K:=0;
      _zam:={? _onlyR_K
            || _chk_R_K:=1; 0
            || {? _mStatus='Z'
::    czy sprawdzać również tabelę R_KWGODZ po dacie zamknięcia miesiąca
               || _chk_R_K:={? _dz<_do1 || 1 || 0 ?}; 1
               || _chk_R_K:=1; 0
               ?}
            ?};

::    zbieramy godziny dotyczące danego miesiąca, ale z dwóch masek: bieżącego roku i kolejnego, gdzie mogą
::    wystąpić korekty
      {? _zam
      || {! _it:=0..1
         |! G.use('godz'+$((_rok)+_it));
            G.cntx_psh();
            G.index('PRRODATA');
            G.prefix(_p_ref,'G');
            {? G.find_ge(_od1)
            || {!
               |? {? G.D<=_do1 & _e*(','+$G.K().RN+',')>0 || _wynik+=G.G ?};
                  G.next() & G.D<=_dz
               !}
            ?};
            G.cntx_pop()
         !};
         _od1:=_dz+1
      ?};
::    pobieramy dane z R_KWGODZ dla otwartego miesiąca lub po dacie zamknięcia miesiąca
      {? _chk_R_K
      || R_KWGODZ.use('r_kg'+(($_rok)+2)+form(_mc,-2));
         R_KWGODZ.cntx_psh();
         R_KWGODZ.index('DATA_RUB');
         R_KWGODZ.prefix(_p_ref);
         {? R_KWGODZ.find_ge(_od1)
         || {!
            |? {? (R_KWGODZ.DZ<=_do1) & (_e*(','+$R_KWGODZ.KW().RN+',')>0) & R_KWGODZ.KW().RN<>63
               || _wynik+=(*R_KWGODZ.GODZ)/60
               ?};
               R_KWGODZ.next() & R_KWGODZ.DZ<=_do1
            !}
         ?};
         R_KWGODZ.cntx_pop();
::       odjęcie odbiorów
         {? ~_odb
         || R_WYK.cntx_psh();
            R_WYK.index('R_WYKDN');
            R_WYK.prefix(_p_ref);
            {? R_WYK.find_ge(_od1)
            || {!
               |? {? (R_WYK.DN<=_do1) & (_e*(','+$R_WYK.R().RN+',')>0) & R_WYK.R().RN<>63
                  || _wynik-=(*R_WYK.G)/60
                  ?};
                  R_WYK.next() & R_WYK.DN<=_do1
               !}
            ?};
            R_WYK.cntx_pop()
         ?};
::       Odpracowania
         {? var_pres('R_ODP')>100 & (_e*'ODP')
         || _sign:={? (_e*'-ODP') || -1 || 1 ?};
            R_ODP.index('PRAC');
            R_ODP.prefix(_p_ref);
            {? R_ODP.find_ge(_od1)
            || {!
               |? {? R_ODP.DW<=_do1
                  || _wynik+=_sign*(*R_ODP.GO)/60
                  ?};
                  R_ODP.next() & R_ODP.DW<=_do1
               !}
            ?}
         ?}
      ?};
      _mc+=1; {? _mc>12 || _mc:=1; _rok+=1 ?};
      _rok<_do~1 | _rok=_do~1 & _mc<=_do~2
   !}
?};
P.cntx_pop();
A_OKRM.cntx_pop();
R_KWGODZ.cntx_pop();
G.cntx_pop();
_wynik$2


\oBuff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51_24]
:: OPIS: Obiekt pomocniczy dla KAL_BUFFa
::  OLD: \oBuff/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_buff:=obj_new('dataw','pocz','kon','czas','typ','typws','p_data','p_start','p_czas','zmiana',
               'push','pop','spr_tws','przerwy');
_buff.push:="
   _dzien:=_a;
   .dataw:=KAL_BUFF.DATAW;
   .pocz:=KAL_BUFF.POCZATEK;
   .kon:=KAL_BUFF.KONIEC;
   .czas:=KAL_BUFF.CZAS;
   .typ:=KAL_BUFF.TYP;
   .zmiana:=KAL_BUFF.ZMIANA;
   .typws:=.spr_tws(_dzien,KAL_BUFF.TYP,KAL_BUFF.TYPWS);
   {? .przerwy
   || .p_data:=KAL_BUFF.P_DATA;
      .p_start:=KAL_BUFF.P_START;
      .p_czas:=KAL_BUFF.P_CZAS
   || .p_data:=#0;
      .p_start:=.p_czas:=*0
   ?}
";

_buff.pop:="
   KAL_BUFF.DATAW:=.dataw;
   KAL_BUFF.POCZATEK:=.pocz;
   KAL_BUFF.KONIEC:=.kon;
   KAL_BUFF.CZAS:=.czas;
   KAL_BUFF.TYP:=.typ;
   KAL_BUFF.TYPWS:=.typws;
   KAL_BUFF.ZMIANA:={? KAL_BUFF.TYP='R' || .zmiana || null() ?};
   {? .przerwy
   || KAL_BUFF.P_DATA:=.p_data;
      KAL_BUFF.P_START:=.p_start;
      KAL_BUFF.P_CZAS:=.p_czas
   || KAL_BUFF.P_DATA:=#0;
      KAL_BUFF.P_START:=KAL_BUFF.P_CZAS:=*0
   ?}
";

_buff.spr_tws:="
   _TYP:=_b; _TYPWS:=_c;
   _val:=_TYP;
   _wyn:=_TYPWS;
   {? |_wyn=''
   || {? _TYPWS<>' ' || _val+=_TYPWS ?};
      {? _val='W'
      || _wyn:={? _TYPWS=' ' || 'H' || '5' ?}
      |? _val='R' | _val='S'
      || {? _a~4=7
         || _wyn:='N'
         |? __KAL.holiday(_a)
         || _wyn:={? _val='R' || 'S' || 'W' ?}
         || _wyn:=''
         ?}
      ?}
   ?};
   _wyn
";

_PDATA:=var_pres('P_DATA',KAL_BUFF)>0;
_buff.przerwy:=_PDATA & exec('isEnabled','prc_przerwy');

_buff

:Sign Version 2.0 jowisz:1045 2023/10/17 10:20:45 64c9286eed83cba85f1f0fa730165aa6b38135c55337b4f6390fb16ed24eb1653ec65bfc6480c2322ca2fc831f03f23c3976f75d20927a52cab190ee81677aca97c1bd719b1d582a7b332134b44ab4a66aef86b53ad5e63b803d8da00aafe83fd09b3ec87c25810550aca0b1365febaf704900c511c1cbc7156f91c5e79cdadd
