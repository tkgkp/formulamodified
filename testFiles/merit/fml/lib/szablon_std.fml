:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: szablon_std.fml
:: Utworzony: 11.02.2020
:: Autor: jaws
::======================================================================================================================
:: Zawartość: Formuły obsługujące szablony dokumentów - standardowe definicje.
::======================================================================================================================


\_xslo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Uzupełnia zawartość tabeli SD_XSLO
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_insert:="exec('xslo_insert','szablon_std',_a,exec('_xslo_rek','szablon_std'),_b,_c,_d)";
_insert('MIEJSCE_ZEST_1','HEADER','Nagłówek',1);
_insert('MIEJSCE_ZEST_2','CONTENT','Zawartość',2);
_insert('MIEJSCE_ZEST_3','FOOTER','Stopka',3);

_insert:="exec('xslo_insert','szablon_std',_a,exec('_xslo_fml','szablon_std'),_b,_c,_d)";
_insert('PAR_FML_1','PATTERN','Wzorzec',1);
_insert('PAR_FML_2','BLANK','Wartość początkowa',2);
_insert('PAR_FML_3','BEFORE_DISPLAY','Przed wyświetleniem',3);
_insert('PAR_FML_4','BEFORE_EDIT','Przed redagowaniem',4);
_insert('PAR_FML_5','F3','Wybór F3',5);
_insert('PAR_FML_6','AFTER_EDIT','Po redagowaniu',6);

_insert:="exec('xslo_insert','szablon_std',_a,exec('_xslo_kol','szablon_std'),_b,_c,_d)";
_insert('RODZAJ_KOL_1','WARTOSC','Wartość wyliczana typu prostego lub obiektowego',1);
_insert('RODZAJ_KOL_2','OBRAZ','Obraz pobrany z wiersza tabeli bazy danych',2);

~~


\_xslo_rek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Oznaczenie rodzaju słownika wykorzystywanego w polu SD_XSLO wiersza tabeli SD_REK.
::   WE:
::   WY: rodzaj słownika
::----------------------------------------------------------------------------------------------------------------------
'MIEJSCE_ZESTAWU'


\_xslo_fml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Oznaczenie rodzaju słownika wykorzystywanego w polu SD_XSLO wierszy tabel SD_PAR i SD_WPAR.
::   WE:
::   WY: rodzaj słownika
::----------------------------------------------------------------------------------------------------------------------
'FORMULA_PARAMETRU'


\_xslo_kol
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Oznaczenie rodzaju słownika wykorzystywanego w polu SD_XSLO wierszy tabel SD_WKOL i SD_XKOL.
::   WE:
::   WY: rodzaj słownika
::----------------------------------------------------------------------------------------------------------------------
'RODZAJ_ELEMENTU'


\_wynik
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Tworzy tablicę nazwaną używaną do zwracania wyniku przez funkcje manipulujące danymi.
::   WE:
::   WY: wskazanie tablicy nazwanej z polami
::       STATUS - wynik operacji (~~ - błąd, liczba - zależnie od kontekstu)
::       INFO - treść komunikatu
::----------------------------------------------------------------------------------------------------------------------
_ret:=obj_new(
:: wynik operacji
   'STATUS','INFO',
:: ogólne "metody" ustawiające wynik
   'set','error','message','success',
:: specjalizowani "ustawiacze" wyniku
   'err_arg','exists','missing','notfound','insert','update','delete'
);

_ret.STATUS:=~~;
_ret.INFO:='';

_ret.set:=".STATUS:=_a; .INFO:=_b; return(.)";

_ret.error:=".set(~~,_a)";
_ret.message:=".set(0,_a)";
_ret.success:=".set(1,_a)";

_ret.err_arg:="
   .error('Błędny lub pominięty argument %1 formuły \"%2\".'[$_a,_b])
";
_ret.exists:="
   .message('W tabeli %1 istnieje wiersz o kodzie \"%2\".'[2-!_a,_b])
";
_ret.missing:="
   .error('Wiersz o kodzie \"%2\" nie występuje w tabeli %1.'[2-!_a,_b])
";
_ret.notfound:="
   .message('Wiersz o kodzie \"%2\" nie występuje w tabeli %1.'[2-!_a,_b])
";
_ret.insert:="
   {? _c<>0
   || .success('Do tabeli %1 dołączono wiersz o kodzie \"%2\".'[2-!_a,_b])
   || .error('Dołączenie wiersza o kodzie \"%2\" do tabeli %1 nie powiodło się.'[2-!_a,_b])
   ?}
";
_ret.update:="
   {? _c<>0
   || .success('W tabeli %1 zmieniono wiersz o kodzie \"%2\".'[2-!_a,_b])
   || .error('Zmiana wiersza o kodzie \"%2\" w tabeli %1 nie powiodła się.'[2-!_a,_b])
   ?}
";
_ret.delete:="
   {? _c<>0
   || .success('Z tabeli %1 usunięto wiersz o kodzie \"%2\".'[2-!_a,_b])
   || .error('Usunięcie wiersza o kodzie \"%2\" z tabeli %1 nie powiodło się.'[2-!_a,_b])
   ?}
";

_ret


\def_search
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Wyszukuje zapis standardowy o podanym kodzie dla aktualizacji.
::   WE: _a STRING - kod dla aktualizacji
::   WY: wskazanie znalezionego wiersza lub null
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_kod:=_a;

_ref:=null;
SD_DEF.cntx_psh();
SD_DEF.index('KOD');
SD_DEF.prefix('T');
{? SD_DEF.find_key(_kod,)
|| _ref:=SD_DEF.ref()
?};
SD_DEF.cntx_pop();
_ref


\def_insert
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Dodaje wiersz do tabeli SD_DEF.
::   WE: _a STRING - kod dla aktualizacji
::       _b STRING - symbol definicji
::       _c STRING - nazwa definicji
::       _d [STRING] - opis dodatkowy
::   WY: wskazanie na tablicę wyniku (patrz _wynik)
::----------------------------------------------------------------------------------------------------------------------
:: wartość zwracana
_res:=exec('_wynik','szablon_std');

:: kontrola poprawności wywołania
{! _ii:=1.._
|! {? var_pres('_[%1]'[$_ii])<>type_of('') | _[_ii]=''
::    niezgodność typu lub brak wartości
   || return(_res.err_arg(_ii,'def_insert'))
   ?}
!};

:: mapa argumentów
_kod:=_a;
_symbol:=_b;
_nazwa:=_c;
_opis:=_d;

{? exec('def_search','szablon_std',_kod)<>null
:: znaleziono wiersz o podanym kodzie
|| return(_res.exists(SD_DEF,_kod))
?};

SD_DEF.clear();
SD_DEF.blank();

SD_DEF.SYSTEM:='T';
SD_DEF.KOD:=_kod;
SD_DEF.SYMBOL:=_symbol;
SD_DEF.NAZWA:=_nazwa;
SD_DEF.memo_set(_opis,'OPIS');
:: SD_DEF.AUTOR - ustawi wyzwalacz
:: SD_DEF.GRUPA - ustawi wyzwalacz

_done:=(SD_DEF.add() & SD_DEF.memo_put(,'OPIS'));
_res.insert(SD_DEF,_kod,_done)


\def_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Modyfikuje wiersz do tabeli SD_DEF.
::   WE: _a STRING - kod dla aktualizacji
::       _b [STRING] - symbol definicji
::       _c [STRING] - nazwa definicji
::       _d [STRING] - opis dodatkowy
::   WY: wskazanie na tablicę wyniku (patrz _wynik)
::----------------------------------------------------------------------------------------------------------------------
:: wartość zwracana
_res:=exec('_wynik','szablon_std');

:: kontrola poprawności wywołania
{? var_pres('_a')<>type_of('') | _a=''
:: niezgodność typu lub brak wartości
|| return(_res.err_arg(1,'def_update'))
?};

:: mapa argumentów
_kod:=_a;
_symbol:={? var_pres('_b')=type_of('') || form(_b) || '' ?};
_nazwa:={? var_pres('_c')=type_of('') || form(_c) || '' ?};
_opis:={? var_pres('_d')=type_of('') || form(_d) || '' ?};

{? (_ref:=exec('def_search','szablon_std',_kod))=null
:: nie znaleziono wiersza o podanym kodzie
|| return(_res.missing(SD_DEF,_kod))
?};

SD_DEF.clear();
{? SD_DEF.seek(_ref)=0
|| return(_ret)
?};

{? _symbol<>'' || SD_DEF.SYMBOL:=_symbol ?};
{? _nazwa<>'' || SD_DEF.NAZWA:=_nazwa ?};
{? _opis<>'' || SD_DEF.memo_set(_opis,'OPIS') ?};

_done:=(SD_DEF.put() & {? _opis<>'' || SD_DEF.memo_put(,'OPIS') || 1 ?});
_res.update(SD_DEF,_kod,_done)


\def_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Usuwa wiersz z tabeli SD_DEF.
::   WE: _a STRING - kod dla aktualizacji
::   WY: wskazanie na tablicę wyniku (patrz _wynik)
::----------------------------------------------------------------------------------------------------------------------
:: wartość zwracana
_res:=exec('_wynik','szablon_std');

:: kontrola poprawności wywołania
{? var_pres('_a')<>type_of('') | _a=''
:: niezgodność typu lub brak wartości
|| return(_res.err_arg(1,'def_delete'))
?};

:: mapa argumentów
_kod:=_a;

{? (_ref:=exec('def_search','szablon_std',_kod))=null
:: nie znaleziono wiersza o podanym kodzie
|| return(_res.notfound(SD_DEF,_kod))
?};

{? SD_DEF.seek(_ref,,1)=0
:: wskazywany rekord nie istnieje
|| return(_res.missing(SD_DEF,_kod))
?};

_done:=SD_DEF.del(1,1);
_res.delete(SD_DEF,_kod,_done)


\bdef_search
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Wyszukuje zapis standardowy o podanym kodzie dla aktualizacji.
::   WE: _a STRING - wskazanie definicji
::       _b STRING - kod dziedziny produktowej
::   WY: wskazanie znalezionego wiersza lub null
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_def:=_a;
_sym:=_b;

_ref:=null;
SD_BDEF.cntx_psh();
SD_BDEF.index('SYM_DOM');
SD_BDEF.prefix(_def);
{? SD_BDEF.find_key(_sym,)
|| _ref:=SD_BDEF.ref()
?};
SD_BDEF.cntx_pop();
_ref


\bdef_insert
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Dodaje wiersz do tabeli SD_BDEF.
::   WE: _a STRING - kod definicji dla aktualizacji
::       _b STRING - symbol dziedziny produktowej
::   WY: wskazanie na tablicę wyniku (patrz _wynik)
::----------------------------------------------------------------------------------------------------------------------
:: wartość zwracana
_res:=exec('_wynik','szablon_std');

:: kontrola poprawności wywołania
{! _ii:=1.._
|! {? var_pres('_[%1]'[$_ii])<>type_of('') | _[_ii]=''
::    niezgodność typu lub brak wartości
   || return(_res.err_arg(_ii,'bdef_insert'))
   ?}
!};

:: mapa argumentów
_kod:=_a;
_sym:=_b;
_uid:='%1-%2'[_kod,_sym];

{? (_def:=exec('def_search','szablon_std',_kod))=null
:: definicja o podanym kodzie nie istnieje
|| return(_res.missing(SD_DEF,_kod))
?};

{? exec('bdef_search','szablon_std',_def,_sym)<>null
:: znaleziono wiersz dla definicji i dziedziny
|| return(_res.exists(SD_BDEF,_uid))
?};

{? (_dom:=exec('domain_ref','#b_domain',_sym))=null
:: dziedzina o podanym symbolu nie istnieje
|| return(_res.missing(B_DOMAIN,_sym))
?};

SD_BDEF.clear();
SD_BDEF.blank();

SD_BDEF.SD_DEF:=_def;
SD_BDEF.B_DOMAIN:=_dom;

_done:=SD_BDEF.add();
_res.insert(SD_BDEF,_uid,_done)


\bdef_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Usuwa wiersz z tabeli SD_BDEF.
::   WE: _a STRING - kod definicji dla aktualizacji
::       _b STRING - symbol dziedziny produktowej
::   WY: wskazanie na tablicę wyniku (patrz _wynik)
::----------------------------------------------------------------------------------------------------------------------
:: wartość zwracana
_res:=exec('_wynik','szablon_std');

:: kontrola poprawności wywołania
{! _ii:=1.._
|! {? var_pres('_[%1]'[$_ii])<>type_of('') | _[_ii]=''
::    niezgodność typu lub brak wartości
   || return(_res.err_arg(_ii,'bdef_delete'))
   ?}
!};

:: mapa argumentów
_kod:=_a;
_sym:=_b;
_uid:='%1-%2'[_kod,_sym];

{? (_def:=exec('def_search','szablon_std',_kod))=null
:: definicja o podanym kodzie nie istnieje
|| return(_res.missing(SD_DEF,_kod))
?};

{? (_ref:=exec('bdef_search','szablon_std',_def,_sym))=null
:: nie znaleziono wiersza dla definicji i dziedziny
|| return(_res.notfound(SD_BDEF,_uid))
?};

{? SD_DEF.seek(_ref,,1)=0
:: wskazywany rekord nie istnieje
|| return(_res.missing(SD_BDEF,_uid))
?};

_done:=SD_BDEF.del(1,1)=0;
_res.delete(SD_BDEF,_uid,_done)


\xslo_search
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Wyszukuje zapis danego o podanym kodzie.
::   WE: _a STRING - kod dla aktualizacji
::   WY: wskazanie znalezionego wiersza lub null
::----------------------------------------------------------------------------------------------------------------------
_kod:=_a;

_ref:=null;
SD_XSLO.cntx_psh();
SD_XSLO.index('KOD');
SD_XSLO.prefix();
{? SD_XSLO.find_key(_kod,)
|| _ref:=SD_XSLO.ref()
?};
SD_XSLO.cntx_pop();
_ref


\xslo_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Wyszukuje zapis danego typu o podanym kodzie.
::   WE: _a [STRING] - typ zapisu
::       _b [STRING] - symbol zapisu
::   WY: wskazanie znalezionego wiersza lub null
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_typ:=_a;
_sym:=_b;

_ref:=null;
SD_XSLO.cntx_psh();
SD_XSLO.index('SYMBOL');
SD_XSLO.prefix(_typ,);
{? SD_XSLO.find_key(_sym,)
|| _ref:=SD_XSLO.ref()
?};
SD_XSLO.cntx_pop();
_ref


\xslo_insert
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Dodaje wiersz do tabeli SD_XSLO.
::   WE: _a STRING - kod dla aktualizacji
::       _b STRING - rodzaj
::       _c STRING - symbol
::       _d STRING - nazwa
::       _e [INTEGER] - numer
::   WY: wskazanie na tablicę wyniku (patrz _wynik)
::----------------------------------------------------------------------------------------------------------------------
:: wartość zwracana
_res:=exec('_wynik','szablon_std');

:: kontrola poprawności wywołania
{! _ii:=1..4
|! {? var_pres('_[%1]'[$_ii])<>type_of('') | _[_ii]=''
::    niezgodność typu lub brak wartości
   || return(_res.err_arg(_ii,'xslo_insert'))
   ?}
!};
{? var_pres('_e')>0 & var_pres('_e')<>type_of(0)
:: błędny typ, jeśli inny niż liczba
|| return(_res.err_arg(5,'xslo_insert'))
?};

:: mapa argumentów
_kod:=_a;
_rodzaj:=_b;
_symbol:=_c;
_nazwa:=_d;
_numer:=_e;

{? exec('xslo_search','szablon_std',_kod)<>null
:: znaleziono wiersz o podanym kodzie
|| return(_res.exists(SD_XSLO,_kod))
?};

SD_XSLO.clear();
SD_XSLO.blank();

SD_XSLO.KOD:=_kod;
SD_XSLO.RODZAJ:=_rodzaj;
SD_XSLO.SYMBOL:=_symbol;
SD_XSLO.NAZWA:=_nazwa;
SD_XSLO.NUMER:=_numer;

_done:=SD_XSLO.add();
_res.insert(SD_XSLO,_kod,_done)


\dok_search
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AC [20.14]
:: OPIS: Wyszukuje szablon dokumentu o podanym kodzie dla aktualizacji.
::   WE: _a STRING - kod dla aktualizacji
::   WY: wskazanie znalezionego wiersza lub null
::----------------------------------------------------------------------------------------------------------------------
_kod:=_a;

_ref:=null;
SD_DOK.cntx_psh();
SD_DOK.index('KOD');
SD_DOK.prefix('T');
{? SD_DOK.find_key(_kod,)
|| _ref:=SD_DOK.ref()
?};
SD_DOK.cntx_pop();
_ref


\dok_insert
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AC [20.14]
:: OPIS: dodaje wiersz do tabeli SD_DOK
::   WE: _a [STRING] - kod dla aktualizacji
::       _b [STRING] - symbol definicji
::       _c [STRING] - nazwa definicji
::       _d [STRING] - opis dodatkowy
::       _e [STRING] - ścieżka do pliku DOCX zgodnie z definicją ścieżek
::   WY: wskazanie na tablicę wyniku (patrz _wynik)
::----------------------------------------------------------------------------------------------------------------------
:: kontrola poprawności wywołania
{! _ii:=1.._
|! {? var_pres('_[%1]'[$_ii])<>type_of('') | _[_ii]=''
::    niezgodność typu lub brak wartości
   || return(~~)
   ?}
!};

:: mapa argumentów
_kod:=_a;
_symbol:=_b;
_nazwa:=_c;
_opis:=_d;
_szablon:=_e;

{? exec('dok_search','szablon_std',_kod)<>null
:: znaleziono wiersz
|| return(0)
?};

_ret:=~~;
SD_DOK.clear();
SD_DOK.blank();
SD_DOK.SYSTEM:='T';
SD_DOK.KOD:=_kod;
SD_DOK.SYMBOL:=_symbol;
SD_DOK.NAZWA:=_nazwa;
SD_DOK.memo_set(_opis,'OPIS');
{? fexists(_szablon,1)
|| {? SD_DOK.add() & SD_DOK.memo_put(,'OPIS') & SD_DOK.bl_put('DOCX',_szablon,1)
   || _ret:=1
   ?}
?};
_ret


\dok_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AC [20.14]
:: OPIS: Modyfikuje wiersz do tabeli SD_DOK.
::   WE: _a [STRING] - kod dla aktualizacji
::       _b [STRING] - symbol definicji
::       _c [STRING] - nazwa definicji
::       _d [STRING] - opis dodatkowy
::       _e [STRING] - ścieżka do pliku DOCX zgodnie z definicją ścieżek
::   WY: wskazanie na tablicę wyniku (patrz _wynik)
::----------------------------------------------------------------------------------------------------------------------
:: wartość zwracana
_res:=exec('_wynik','szablon_std');

:: kontrola poprawności wywołania
{? var_pres('_a')<>type_of('') | _a=''
:: niezgodność typu lub brak wartości
|| return(_res.err_arg(1,'dok_update'))
?};

:: mapa argumentów
_kod:=_a;
_symbol:={? var_pres('_b')=type_of('') || form(_b) || '' ?};
_nazwa:={? var_pres('_c')=type_of('') || form(_c) || '' ?};
_opis:={? var_pres('_d')=type_of('') || form(_d) || '' ?};
_szablon:={? var_pres('_e')=type_of('') || form(_e) || '' ?};

{? (_ref:=exec('dok_search','szablon_std',_kod))=null
:: nie znaleziono wiersza o podanym kodzie
|| return(_res.missing(SD_DOK,_kod))
?};

SD_DOK.clear();
{? SD_DOK.seek(_ref)=0
|| return(~~)
?};

_ret:=~~;
_file_changing:=0;
{? _symbol<>'' || SD_DOK.SYMBOL:=_symbol ?};
{? _nazwa<>'' || SD_DOK.NAZWA:=_nazwa ?};
{? _opis<>'' || SD_DOK.memo_set(_opis,'OPIS') ?};
{? _szablon<>''
|| {? fexists(_szablon, 1) || file_changing:=1 ?}
?};
{? _file_changing
|| {? SD_DOK.put() & SD_DOK.memo_put(,'OPIS') & SD_DOK.bl_put('DOCX',_szablon,1)
   || ret:=1
   ?}
|| {? SD_DOK.put() & SD_DOK.memo_put(,'OPIS')
   || _ret:=1
   ?}
?};
_ret


\dok_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AC [20.14]
:: OPIS: Usuwa wiersz z tabeli SD_DOK.
::   WE: _a STRING - kod dla aktualizacji
::   WY: wskazanie na tablicę wyniku (patrz _wynik)
::----------------------------------------------------------------------------------------------------------------------
:: wartość zwracana
_res:=exec('_wynik','szablon_std');

:: kontrola poprawności wywołania
{? var_pres('_a')<>type_of('') | _a=''
:: niezgodność typu lub brak wartości
|| return(_res.err_arg(1,'dok_delete'))
?};

:: mapa argumentów
_kod:=_a;

{? (_ref:=exec('dok_search','szablon_std',_kod))=null
:: nie znaleziono wiersza o podanym kodzie
|| return(_res.notfound(SD_DOK,_kod))
?};

{? SD_DOK.seek(_ref,,1)=0
:: wskazywany rekord nie istnieje
|| return(_res.missing(SD_DOK,_kod))
?};

_done:=SD_DOK.del(1,1);
_res.delete(SD_DOK,_kod,_done)

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:35 40cfbcc84d43d34fe395dbef5f39ca8bb501607567b4a9028addbbd0d33ea8ed80a9480f2151a0418fedc42a34732e919c445dc26b8ece5fc2d194657a23b5ad14041634e486109f8771387f15bbcc9825123baa0effe18f9214d8fbf3486f0c7c46e106e28b61368e97071ce51d2309071ec88039bbda6e21775a752622f985
