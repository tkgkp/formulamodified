:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: px_con_g.fml [12.30]
:: Utworzony: 10.12.2011
:: Autor: jerry
::======================================================================================================================
:: Zawartosc: Formuly do obslugi powiazan miedzy grupami w kolejce
::======================================================================================================================


\UpdatePX_VER
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Aktualizuje powiazania pomiedzy grupami w kolejce
::   WE: _a - PX_VER.ref()
::   WY: 1/0 - sukces/porazka
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_result:=1;

:: zmienna do optymalizacji
_grps:=exec('ref_table','#table');
PX_GRP.cntx_psh(); PX_GRP.clear();
PX_GRP.index('LP');
PX_GRP.prefix(_px_ver,'Z');
{? PX_GRP.first()
||
   _komm_args:=exec('add_komm_a','px_komm');
   _komm_args.PX_VER:=_px_ver;
:: tworzymy zaleznosci miedzy grupami
   {!
   |?
      _next:=0;
      {? _grps.r_find(PX_GRP.ref())=0
      ||
         _ret:=exec('UpdatePX_GRP','px_con_g',PX_GRP.ref(),_grps,,0);
         {? _ret=0
         || _result:=0;
            _next:=PX_GRP.first()
         |? _ret=2
         ||
::          jesli w Update... zostaly dodane nowe grupy, zeby sie nie pogubic, skaczemy na poczatek
            _next:=PX_GRP.first()
         || _next:=PX_GRP.next()
         ?}
      ||
         _next:=PX_GRP.next()
      ?};
      _next>0
   !};
   exec('prenumber','px_grp',_px_ver);
   {? _result>0
   || _result:=exec('reorder_px_ver','px_con_g',_px_ver)
   ?};
   ~~
?};
PX_GRP.cntx_pop();
_result


\UpdatePX_GRP
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Aktualizuje powiazania dla podanego PX_GRP
::   WE: _a - PX_GRP.ref()
::       _b - wskazanie na tabele ref'ow
::       [_c] - INTEGER - [0] - granice czasowe dla potomnych PX_GRP sa przepisywane z PX_OBJ
::                         1  - granice czasowe dla potomnych PX_GRP pochodza z nadrzednego (czyli z _a)
::       [_d] - INTEGER - 0/[1] - czy po aktualizacji przenumerować kolejke planu
::       [_e] - INTEGER - 0/[1] - czy podczas sprawdzania obiektu dokonywać sprawdzeń powiązań zamówienia i zlecenia
::   WY: 0 - blad
::       1 - ok
::       2 - ok i kolejka zostala zmodyfikowana - doszly nowe elementy
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_grps:=_b;
_grn_mode:=0;
{? var_pres('_c')=type_of(0)
|| _grn_mode:=_c
?};
_prenumber:=1;
{? var_pres('_d')=type_of(0)
|| _prenumber:=_d
?};

_tie_chk:=1;
{? var_pres('_e')=type_of(0)
|| _tie_chk:=_e
?};

_lp_step:=0.000001;
_result:=1;
_queue_mod:=0;

:: dodajemy do tablicy ze dany px_grp zostal juz obsluzony
_grps.r_add(_px_grp);
PX_GRP.cntx_psh();
PX_OBJ.cntx_psh();
PX_CONN.cntx_psh();
PX_CON_G.cntx_psh(); PX_CON_G.index('NP_LP');
PX_CON_O.cntx_psh();

:: sprzatamy aktualne PX_CON_G dla _px_grp
PX_CON_G.prefix(_px_grp);
{? PX_CON_G.first()
|| {!
   |?
      PX_CON_G.del()
   !}
?};
:: wedrowka po pozycjach grupy, jezeli brak to nie ma sensu nic dalej robic
PX_CONN.index('PX_GRP');
PX_CONN.prefix(_px_grp);
{? PX_CONN.first()
|| _px_ver:=PX_CONN.PX_VER;
:: zmienne potrzebne w dalszej czesci
   _grp_add_args:=exec('blank_a','px_grp');
   _grp_add_args.PX_VER:=_px_ver;
   _grp_add_args.SET_SRC:=PX_VAR.PX_SET;

   _komm_args:=exec('add_komm_a','px_komm');
:: przygotujemy zaleznosci pomiedzy grupami
   PX_CON_G.blank();
   PX_CON_G.PX_VER:=_px_ver;
:: _grp2upd - grupy do aktualizacji
   _grp2upd:=exec('ref_table','#table');

:: zapamietujemy dane z PX_GRP nadrzednego

   _startd:=PX_CONN.PX_GRP().STARTD().DATA;
   _startt:=PX_CONN.PX_GRP().STARTT;
   _endd:=PX_CONN.PX_GRP().ENDD().DATA;
   _endt:=PX_CONN.PX_GRP().ENDT;

   _lp:=PX_CONN.PX_GRP().LP_Q;
   {!
   |?
::    dla kazdej pozycji grupy sprawdzamy px_obj'a, czy sa wymagane jakies poprzednie
      PX_CON_O.index('NP');
      PX_CON_O.prefix(PX_CONN.PX_OBJ);
      {? PX_CON_O.first()
      ||
::       sa wymagane poprzedniki wiec... wedrujemy po pozycjach grup w biezacej kolejce, by ustalic zaleznosci
         PX_CONN.cntx_psh();
         PX_CONN.index('VER');
         {!
         |?
            PX_CONN.prefix(_px_ver,PX_CON_O.PX_OBJ_P);
            _obj_active:=PX_CON_O.PX_OBJ_P().A='T';
::          jezeli obiekt jest aktywny i nie wystepuje w grupach w kolejce, to dodajemy do kolejki
            {? ~PX_CONN.first()
             & _obj_active
            ||
               _grp_add_args.PX_TEX:=exec('get_default_tex','px_tex',PX_OBJ.ref(),1);

               _grp_add_args.SYMBOL:=exec('get_symbol','px_grp',_grp_add_args.PX_TEX);
               _grp_add_args.NAZWA:=exec('get_nazwa','px_grp',_grp_add_args.PX_TEX);
::             kazdy nastepny poprzednik ma byc w kolejce mniej wiecej w tym samym miejscu co element nadrzedny
               _lp+=_lp_step;
               _grp_add_args.LP_Q:=_lp;

               _grp_add_args.ILOSC:=PX_OBJ.IL-exec('get_ilosc_que','px_obj',_px_ver,PX_OBJ.ref());
               _grp_add_args.JM:=PX_OBJ.JM;
               _grp_add_args.DIR:={? PX_OBJ.DIR<>0
                                  || PX_OBJ.DIR
                                  |? PX_OBJ.TM_REA>0
                                  || -1
                                  || 1
                                  ?};
               {? PX_OBJ.PX_SET<>null()
               || _grp_add_args.SET_SRC:=PX_OBJ.PX_SET
               || _grp_add_args.SET_SRC:=PX_VAR.PX_SET
               ?};
               {? _grn_mode=0
               || _grp_add_args.STARTD:=PX_OBJ.STARTD().DATA;
                  _grp_add_args.STARTT:=PX_OBJ.STARTT;
                  _grp_add_args.ENDD:=PX_OBJ.ENDD().DATA;
                  _grp_add_args.ENDT:=PX_OBJ.ENDT
               |? _grn_mode=1
               || _grp_add_args.STARTD:=_startd;
                  _grp_add_args.STARTT:=_startt;
                  _grp_add_args.ENDD:=_endd;
                  _grp_add_args.ENDT:=_endt
               ?};
::             Sprawdzam czy mozna dodac PX_GRPa i PX_CONNa
               {? var_pres('_buf_con')>100
               || obj_del(_buf_con)
               ?};
               _buf_con:=exec('buffer','px_conn');
               _buf_con.blank();
               _buf_con.PX_OBJ:=PX_CON_O.PX_OBJ_P;
               _buf_con.ILOSC:=_grp_add_args.ILOSC;

               _can_add1:=exec('can_add','px_conn',_buf_con,,0,_tie_chk);
               _can_add2:=exec('can_add','px_grp',_grp_add_args);

               {? _can_add1>0 & _can_add2>0
               || {? exec('add','px_grp',_grp_add_args,PX_CON_O.PX_OBJ_P,0,_tie_chk)>0
                  || _queue_mod:=1
                  ?}
               || _result:=0
               ?}
            ?};
::          jezeli wszystko poszlo jak nalezy, to teraz obiekt powinien byc gdzies w kolejce
            {? PX_CONN.first()
            || {!
               |?
::                dodajemy zaleznosc do grupy
                  PX_CON_G.PX_GRP_N:=_px_grp;
                  PX_CON_G.PX_GRP_P:=PX_CONN.PX_GRP;
                  {? PX_CON_G.add(1)
                  ||
::                   jezeli wymagana grupa nie byla aktualizowana, to ja zapiszemy na boczku, a potem zaktualizujemy
                     {? ~_grps.r_find(PX_CONN.PX_GRP)
                      & ~_grp2upd.r_find(PX_CONN.PX_GRP)
                     || _grp2upd.r_add(PX_CONN.PX_GRP)
                     ?}
                  ?};
                  PX_CONN.next()
               !}

            |? _obj_active
            ||
               _komm_args.PX_GRP:=_px_grp;
               _komm_args.MESSAGE:='Nie odnaleziono w kolejce grupy z obiektem '+PX_CON_O.PX_OBJ_P().SYMBOL
                                  +' wymaganej przez bieżącą grupę: '
                                  + exec('FindAndGet','#table',PX_GRP,_px_grp,,"form(LP_Q)",'')
                                  ;
               exec('add_komm','px_komm',_komm_args);
               _result:=0;
               ~~
            ?};
            PX_CON_O.next()
         !};
         PX_CONN.cntx_pop();
         ~~
      ?};
      PX_CONN.next()
   !};

:: Ponowne przetworzenie - w poszukiwaniu nastepnikow
   PX_CONN.first();
   {!
   |?
::    dla kazdej pozycji grupy sprawdzamy px_obj'a, czy sa wymagane jakies nastepne
      PX_CON_O.index('PN');
      PX_CON_O.prefix(PX_CONN.PX_OBJ);
      {? PX_CON_O.first()
      ||
::       sa wymagane nastepniki wiec... wedrujemy po pozycjach grup w biezacej kolejce, by ustalic zaleznosci
         PX_CONN.cntx_psh();
         PX_CONN.index('VER');
         {!
         |?
            PX_CONN.prefix(_px_ver,PX_CON_O.PX_OBJ_N);
            _obj_active:=PX_CON_O.PX_OBJ_N().A='T';
::          jezeli obiekt jest aktywny i nie wystepuje w grupach w kolejce, to dodajemy do kolejki
            {? ~PX_CONN.first()
             & _obj_active
            ||
               _grp_add_args.PX_TEX:=exec('get_default_tex','px_tex',PX_OBJ.ref(),1);

               _grp_add_args.SYMBOL:=exec('get_symbol','px_grp',_grp_add_args.PX_TEX);
               _grp_add_args.NAZWA:=exec('get_nazwa','px_grp',_grp_add_args.PX_TEX);

               _grp_add_args.LP_Q:=SYSLOG.tm_stamp();
               _grp_add_args.ILOSC:=PX_OBJ.IL-exec('get_ilosc_que','px_obj',_px_ver,PX_OBJ.ref());
               _grp_add_args.JM:=PX_OBJ.JM;
               _grp_add_args.DIR:={? PX_OBJ.DIR<>0
                                  || PX_OBJ.DIR
                                  |? PX_OBJ.TM_REA>0
                                  || -1
                                  || 1
                                  ?};
               _grp_add_args.STARTD:=PX_OBJ.STARTD().DATA;
               _grp_add_args.STARTT:=PX_OBJ.STARTT;
               _grp_add_args.ENDD:=PX_OBJ.ENDD().DATA;
               _grp_add_args.ENDT:=PX_OBJ.ENDT;
               {? PX_OBJ.PX_SET<>null()
               || _grp_add_args.SET_SRC:=PX_OBJ.PX_SET
               || _grp_add_args.SET_SRC:=PX_VAR.PX_SET
               ?};

::             Sprawdzam czy mozna dodac PX_GRPa i PX_CONNa
               {? var_pres('_buf_con')>100
               || obj_del(_buf_con)
               ?};
               _buf_con:=exec('buffer','px_conn');
               _buf_con.blank();
               _buf_con.PX_OBJ:=PX_CON_O.PX_OBJ_N;
               _buf_con.ILOSC:=_grp_add_args.ILOSC;

               _can_add1:=exec('can_add','px_conn',_buf_con,,0,_tie_chk);
               _can_add2:=exec('can_add','px_grp',_grp_add_args);

               {? _can_add1>0 & _can_add2>0
               || {? exec('add','px_grp',_grp_add_args,PX_CON_O.PX_OBJ_N,0,_tie_chk)>0
                  || _queue_mod:=1
                  ?}
               || _result:=0
               ?}
            ?};
::          jezeli wszystko poszlo jak nalezy, to teraz obiekt powinien byc gdzies w kolejce
            {? PX_CONN.first()
            || {!
               |?
::                dodajemy zaleznosc do grupy
                  PX_CON_G.PX_GRP_P:=_px_grp;
                  PX_CON_G.PX_GRP_N:=PX_CONN.PX_GRP;
                  {? PX_CON_G.add(1)
                  ||
::                   jezeli wymagana grupa nie byla aktualizowana, to ja zapiszemy na boczku, a potem zaktualizujemy
                     {? ~_grps.r_find(PX_CONN.PX_GRP)
                      & ~_grp2upd.r_find(PX_CONN.PX_GRP)
                     || _grp2upd.r_add(PX_CONN.PX_GRP)
                     ?}
                  ?};
                  PX_CONN.next()
               !}

            |? _obj_active
            ||
               _komm_args.PX_GRP:=_px_grp;
               _komm_args.MESSAGE:='Nie odnaleziono w kolejce grupy z obiektem '+PX_CON_O.PX_OBJ_P().SYMBOL
                                  +' wymaganej przez bieżącą grupę: '
                                  + exec('FindAndGet','#table',PX_GRP,_px_grp,,"form(LP_Q)",'')
                                  ;
               exec('add_komm','px_komm',_komm_args);
               _result:=0;
               ~~
            ?};
            PX_CON_O.next()
         !};
         PX_CONN.cntx_pop();
         ~~
      ?};
      PX_CONN.next()
   !};

   {? _grp2upd.tab.first()
   || PX_GRP.cntx_psh();
      PX_GRP.clear();
      {!
      |?
         {? PX_GRP.seek(_grp2upd.tab.REF, _grp2upd.tab.NAME)
         || exec('UpdatePX_GRP','px_con_g',PX_GRP.ref(),_grps,,_prenumber,_tie_chk)
         ?};
         _grp2upd.tab.next()
      !};
      PX_GRP.cntx_pop()
   ?};

:: Przenumerowuje kolejke o ile cos sie zmienilo
   {? _queue_mod>0 & _prenumber>0
   || exec('prenumber','px_grp',_px_ver)
   ?};

:: Jesli cos sie zmienilo w kolejce to zwracam inny wynik
   {? _result>0 & _queue_mod>0
   || _result:=2
   ?}
?};

PX_CON_O.cntx_pop();
PX_CON_G.cntx_pop();
PX_CONN.cntx_pop();
PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
_result


\delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Kasuje wpisy PX_CON_G dla podanej grupy
::   WE: _a - PX_GRP.ref()
::   WY: 1/0 sukces/porazka
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_result:=1;
:: podreczna formula do kasowania PX_CON_G
_erase_con_g:="
   _result:=1;
   {? PX_CON_G.first()
   || {!
      |?
         PX_CON_G.del()
      !}
   ?};
   _result:=PX_CON_G.first()=0
";
:: okladki kontekstu
PX_CON_G.cntx_psh(); PX_CON_G.clear();
:: kasujemy poprzedniki
PX_CON_G.index('NP_LP'); PX_CON_G.prefix(_px_grp); _result*=_erase_con_g();
:: kasujemy nastepniki
PX_CON_G.index('PN_LP'); PX_CON_G.prefix(_px_grp); _result*=_erase_con_g();
PX_CON_G.cntx_pop();
_result


\get_env_range
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca przedzial srodowiskowy dla podanego PX_GRP
::   WE: _a - PX_GRP.ref()
::       _b - tabela TM_RANGE - np. wynik z exec('tm_range_create','px_logix')
::   WY: tablica _env
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_tm_range:=_b;
_env:=obj_new('DIR','TM_START','TM_END','LP_Q');
_env.DIR:=0;
_env.TM_START:=0;
_env.TM_END:=0;
PX_OBJ.cntx_psh(); PX_OBJ.clear();
PX_GRP.cntx_psh(); PX_GRP.clear();
{? PX_GRP.seek(_px_grp)
||
   _env.DIR:=PX_GRP.DIR;
   _env.LP_Q:=PX_GRP.LP_Q;
   _env.TM_START:=PX_GRP.TM_START;
   _env.TM_END:=PX_GRP.TM_END;

   PX_CON_G.cntx_psh(); PX_CON_G.clear();
   PX_CON_G.index('PN_LP');
   PX_CON_G.prefix(_px_grp);
:: szukamy informacji, kiedy dana grupa musi sie zakonczyc - indeks PN_LP - nastepniki biezacego
   {? PX_CON_G.first()
   || {!
      |?
         {? _tm_range.find_key($PX_CON_G.PX_GRP_N)
         || {? _tm_range.TM_START>0
            || {? _env.TM_END=0
                | _env.TM_END>_tm_range.TM_START
               || _env.TM_END:=_tm_range.TM_START
               ?}
            || FUN.wdrerror('Zakres bez wartości początkowej.')
            ?}
         ?};
         PX_CON_G.next()
      !}
   ?};

   PX_CON_G.index('NP_LP');
   PX_CON_G.prefix(_px_grp);
:: szukamy informacji, kiedy dana grupa moze sie rozpoczac - indeks NP_LP - poprzedniki biezacego
   {? PX_CON_G.first()
   || {!
      |?
         {? _tm_range.find_key($PX_CON_G.PX_GRP_P)
         || {? _tm_range.TM_END>0
            || {? _env.TM_START=0
                | _env.TM_START<_tm_range.TM_END
               || _env.TM_START:=_tm_range.TM_END
               ?}
            || FUN.wdrerror('Zakres bez wartości końcowej.')
            ?}
         ?};
         PX_CON_G.next()
      !}
   ?};
   PX_CON_G.cntx_pop();
   ~~
?};

PX_GRP.cntx_pop();
PX_OBJ.cntx_pop();
_env


\reorder_px_ver
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Przeorganizowuje kolejke uwzgledniajac kierunki i powiazania
::   WE: _a - PX_VER.ref()
::   WY: 1/0 - sukces/porazka
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_result:=1;
PX_CON_G.cntx_psh(); PX_CON_G.clear();
PX_GRP.cntx_psh(); PX_GRP.clear();
PX_GRP.index('LP');
PX_GRP.prefix(_px_ver,'Z');

PX_CON_G.index('VPN');
PX_CON_G.prefix(_px_ver);
{? PX_CON_G.first()
||
   _rpv:=exec('reorder_px_verO','px_con_g');

   _komm_args:=exec('add_komm_a','px_komm');
   _komm_args.PX_VER:=_px_ver;
:: ładuje powiązania (i grupy) do obiektu
   {!
   |?
      _rpv.con_add();
      PX_CON_G.next()
   !};
:: porządkuję w obiekcie
   _rpv.reorder();
:: zapisuję wynik do PX_GRP
   _rpv.save2GRP();
   ~~
?};
PX_GRP.cntx_pop();
PX_CON_G.cntx_pop();
_result


\diagram
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Generuje diagram zaleznosci miedzy grupami
::   WE: _a - PX_VER.ref()
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
PX_GRP.cntx_psh(); PX_GRP.clear();
PX_GRP.index('LP');
PX_GRP.prefix(_px_ver,'Z');
_dia:=exec('dot_obj','#graph','px_grp','svg');
{? PX_GRP.first()
 & _dia.open()
||
   _graph:=_dia.cr_graph();
   _graph.rankdir:="TB";
   _graph.rank:="min";
   _dia.add_graph('px_grp',_graph);

   _node:=_dia.cr_node();
   _node.shape:=_dia.enum.shape.Mrecord;
::   _node.shape:=_dia.enum.shape.box;
   _node.style:="filled";
::   _node.fixedsize:='true';
::   _node.height:='5.0';
::   _node.width:='5.0';
   _dia.add_node('node',_node);

   {!
   |?
      _dia.clean(_node);
      _node.label:=exec('diagram_label','px_con_g',PX_GRP.ref());
      _node.width:='5.0';
      _dia.add_node($$PX_GRP.ref(),_node);
      PX_GRP.next()
   !};

   _edge:=_dia.cr_edge();
   _edge.color:=_dia.enum.color.navy;
   PX_CON_G.cntx_psh();
   PX_CON_G.index('VPN');
   PX_CON_G.prefix(_px_ver);
   {? PX_CON_G.first()
   || {!
      |?
         _dia.add_edge($$PX_CON_G.PX_GRP_P,$$PX_CON_G.PX_GRP_N,_edge);
         PX_CON_G.next()
      !}
   ?};
   PX_CON_G.cntx_pop();

   _edge.color:=_dia.enum.color.gray;
   {? PX_GRP.first()
    & FUN.ask('Uwzględnić kolejność grup w kolejce?'@)
   || _last:=PX_GRP.ref();
      {? PX_GRP.next()
      || {!
         |?
            _dia.add_edge($$_last,$$PX_GRP.ref(),_edge);
            _last:=PX_GRP.ref();
            PX_GRP.next()
         !}
      ?}
   ?};
   _dia.run()
?};
PX_GRP.cntx_pop();
~~


\diagram_label
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Generuje wpis dla podanego PX_GRPa
::   WE: _a - PX_GRP.ref()
::   WY: STRING - tekst dla diagramu
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_label:='????';
PX_GRP.cntx_psh();
{? (PX_GRP.ref()=_px_grp)
 | (PX_GRP.clear(); PX_GRP.seek(_px_grp))
||
   _label:='<\n<TABLE CELLPADDING="0" CELLSPACING="0" BORDER="0" WIDTH="100">';
   _label+='\n<TR><TD ALIGN="LEFT">Grupa: '+PX_GRP.SYMBOL+'</TD></TR>';
   _label+='\n<TR><TD ALIGN="LEFT">Lp: '+form(PX_GRP.LP_Q,5,,'9.')+'</TD></TR>';
   _label+='\n<TR><TD ALIGN="LEFT"> </TD><TD ALIGN="LEFT"> </TD></TR>';
   _label+='\n<TR><TD ALIGN="LEFT">Planuj od: '+form(PX_GRP.STARTD().DATA)+' '+form(PX_GRP.STARTT)+'</TD></TR>';
   _label+='\n<TR><TD ALIGN="LEFT">Planuj do: '+form(PX_GRP.ENDD().DATA)+' '+form(PX_GRP.ENDT)+'</TD></TR>';
   _label+='\n<TR><TD ALIGN="LEFT">Kierunek: '+{? PX_GRP.DIR>0 || 'do przodu' || 'wstecz' ?}+'</TD></TR>';
   _label+='\n<TR><TD ALIGN="RIGHT"> </TD><TD ALIGN="LEFT"> </TD></TR>';
::   _label+='\n<TR><TD ALIGN="RIGHT"> </TD><TD ALIGN="LEFT">'+$PX_GRP.ref()+'</TD></TR>';
   _label+='\n</TABLE>\n>'
?};
PX_GRP.cntx_pop();
_label


\reorder_px_verO
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Tworzy tablice nazwana wykorzystywana przy przenumerowywaniu kolejki
::   WY: uchwyt do tablicy nazwanej
::       'tab_sort' - tablica sortowanych elementow
::----------------------------------------------------------------------------------------------------------------------
_obj:=exec('obj_new','#var');
_obj.fld('px_grp'   ,~~,'Kopia px_grp');
_obj.fld('xgrpREF'  ,~~,'Indeks wg PX_GRP.ref`a');
_obj.fld('xgrpORD'  ,~~,'Sortowanie wg ORDER');
_obj.fld('xgrpLPQ'  ,~~,'Sortowanie wg LP_Q');

_obj.fld('px_con'   ,~~,'Kopia px_con_g');
_obj.fld('xconPN'   ,~~,'Indeks połączeń Poprzednik Następnik');
_obj.fld('xconNP'   ,~~,'Indeks połączeń Następnik Poprzednik');
_obj.fld('xconREF'  ,~~,'Indeks wg PX_CON_G.ref`a');

_obj.fld('later'    ,~~,'Tabela z grupami, na pozniej');
_obj.fld('xlaterREF',~~,'later wg REFa');
_obj.fld('xlaterLPR',~~,'later wg LP,REF');

_obj.fld('CountL'   , 0,'Licznik dla kolejnych grup do obslugi');
_obj.fld('CountG'   , 0,'Licznik grup');

_obj.fld('elpeki'   ,~~,'Lista LP_Q w użyciu');

_obj.meth('init','konstruktor'
         ,"
::         kopia px_grp - tu beda wszystkie PX_GRP'y pobrane przenumerowania
           .px_grp:=tab_tmp(1
                           ,'REF'     ,'INTEGER'    ,'#PX_GRP.ref()'
                           ,'LP_Q'    ,'REAL'       ,'what lp'
                           ,'DIR'     ,'INTEGER'    ,'zwrot'
                           ,'ORDER'   ,'REAL'       ,'Nowy porządek'
                           );

           .xgrpREF:=.px_grp.index('?');
           .xgrpORD:=.px_grp.ndx_tmp(,1
                                    ,'ORDER',,
                                    ,'REF',,
                                    );
           .xgrpLPQ:=.px_grp.ndx_tmp(,1,'LP_Q',,,'REF',,);

           .px_con:=tab_tmp(1
                           ,'REF'     ,'INTEGER'    ,'#PX_CON_G.ref()'
::                         poprzednik
                           ,'PREV'   ,'INTEGER'    ,'prev#.px_grp.ref()'
::                         nastepnik
                           ,'NEXT'   ,'INTEGER'    ,'next#.px_grp.ref()'
                           );

            .xconREF:=.px_con.index('?');
            .xconPN:=.px_con.ndx_tmp('PN',
                                    ,'PREV',,
                                    ,'NEXT',,
                                    );
            .xconNP:=.px_con.ndx_tmp('PN',
                                    ,'NEXT',,
                                    ,'PREV',,
                                    );

            .later:=tab_tmp(1
                           ,'REF'     ,'INTEGER'    ,'#.px_grp.ref()'
                           ,'LP'      ,'INTEGER'    ,'Kolejnosc'
                           );

            .xlaterREF:=.later.index('?');
            .xlaterLPR:=.later.ndx_tmp(,1
                                      ,'LP' ,,
                                      ,'REF',,
                                      );

            .elpeki:=tab_tmp(1,'LP_Q','REAL','LP_Q');
            (.)
          "
         );

_obj.meth('grp_add' ,'dodaje PX_GRP do .px_grp'
         ,"
           {? .px_grp.find_key(#PX_GRP.ref())=0
           || .px_grp.blank(1);
              .px_grp.REF:=#PX_GRP.ref();
              .px_grp.LP_Q:=PX_GRP.LP_Q;
              .px_grp.DIR:=PX_GRP.DIR;
              .px_grp.ORDER:=0;
              {? .px_grp.add()
              ||
                 .elpeki.LP_Q:=.px_grp.LP_Q;
                 .elpeki.add();
                 .px_grp.ref()
              || null()
              ?}
           || .px_grp.ref()
           ?}
          "
         );

_obj.meth('con_add' ,'dodaje powiązanie PX_CON_G do .px_con'
         ,"
            {? .px_con.find_key(#PX_CON_G.ref())=0
            || .px_con.blank(1);
               PX_GRP.cntx_psh();
               .px_con.REF:=#PX_CON_G.ref();
               PX_CON_G.PX_GRP_P();
               .px_con.PREV:=.grp_add();
               PX_CON_G.PX_GRP_N();
               .px_con.NEXT:=.grp_add();
               PX_GRP.cntx_pop();
               {? .px_con.add()
               || .px_con.ref()
               || null()
               ?}
            || .px_con.ref()
            ?}
          "
         );

_obj.meth('countG'   ,'ustala numer kolejny dla grupy',".px_grp.ORDER:=(.CountG+=1); .px_grp.put()");

_obj.meth('later_add',,"
            .later.REF:={? var_pres('_a')=1 || _a || #.px_grp.ref() ?};
            .later.LP:=(.CountL+=1);
            .later.add()
         ");

_obj.meth('grp_path','znacznik do ścieżki',"$#.px_grp.ref()+'#'");

_obj.meth('reorder',,"
            .px_grp.index(.xgrpLPQ);
            {? .px_grp.first()
            ||
::             inicjuje sciezke
               _was_there:='#';
               {!
               |?
::                jezeli grupa ma juz swoje miejsce, to nie ma sensu sie nia zajmowac (juz została odwiedzona)
                  {? .px_grp.ORDER<=0
                  || .johnywalker(_was_there);
::                   sprawdzam, czy Jaś Wędrowniczek zostawił sobie grupy na później?
                     .later.index(.xlaterLPR);
                     {? .later.first()
                     || {!
                        |?
                           {? .px_grp.seek(.later.REF,)
                           ||
::                            kasuje wpis' na pozniej, bo wlasnie sie nim zajalem
                              .later.del();
::                            sprawdzam, czy Jaś ma się sie tym zająć?
                              {? .px_grp.ORDER<=0
                              || .johnywalker(_was_there)
                              ?};
::                            sprawdzam, czy jest jeszcze coś na później
                              .later.first()
                           || .later.del()
                           ?}
                        !}
                     ?}
                  ?};
                  .px_grp.next()
               !};
::             Jaś przemierzył drogę i ustalił kolejność, więc można ustalić nową numerację grup
               .px_grp.index(.xgrpORD);
               {? .px_grp.first()
                & .elpeki.first()
               || {!
                  |?
                     .px_grp.LP_Q:=.elpeki.LP_Q;
                     .px_grp.put();
                     .px_grp.next() & .elpeki.next()
                  !}
               ?}
            ?};
            ~~
         ");

_obj.meth('johnywalker',,"
::          gdzież to Jaś już był?
            _was_there:=_a;
::          kolejny znaczek do zeszytu
            _cur_path:=.grp_path();
::          sprawdzam, czy grupa powinna być przetwarzana (nie ma kolejności i nie była odwiedzana)
            {? .px_grp.ORDER<=0
             & _was_there*('#'+_cur_path)=0
            ||
::             znaczę ślad
               _was_there+=_cur_path;

::             jezeli grupa ma byc planowana od poczatku, to musi miec ustalonych poprzednikow, siebie i następnikow
               {? .px_grp.DIR=1
               || _ndx4prev:=.xconNP;
                  _fld4prev:=2;
                  _ndx4next:=.xconPN;
                  _fld4next:=3;
                  ~~

::             jezeli grupa ma byc planowana od konca, to musi miec ustalnych nastepnikow, siebie i nastepnikow
               |? .px_grp.DIR=-1
               || _ndx4prev:=.xconPN;
                  _fld4prev:=3;
                  _ndx4next:=.xconNP;
                  _fld4next:=2;
                  ~~
               ?};

::             do notatnika grupę...
               _px_grp:=exec('px_grp4jw','buffer1').get(.px_grp);
::             i Jaś rusza w drogę do poprzedników
               .px_grp.cntx_psh();
               .px_con.cntx_psh();
               .px_con.index(_ndx4prev);
               .px_con.prefix(#_px_grp.ref());
               {? .px_con.first()
               || {!
                  |?
::                   znaleziona grupa
                     {? .px_grp.seek(.px_con[_fld4prev],)
::                      ma kierunek zgodny z tym z notatnika
                     || {? .px_grp.DIR=_px_grp.DIR
                        ||
::                         Jaś idzie w te strony
                           .johnywalker(_was_there)
                        ||
::                         Jaś odkłada sobie sprawę na później
                           .later_add()
                        ?}
                     ?};
                     .px_con.next()
                  !}
               ?};
               .px_con.cntx_pop();
               .px_grp.cntx_pop();
::             Wszyscy zgodni poprzedzający zostali odwiedzeni
::             można nadać numer kolejny dla bieżącej grupy
               .countG();
::             Miejsce oznaczone na mapie, więc Jaś rusza w strony następników
               .px_grp.cntx_psh();
               .px_con.cntx_psh();
               .px_con.index(_ndx4next);
               .px_con.prefix(#_px_grp.ref());
               {? .px_con.first()
               || {!
                  |?
::                   znaleziona grupa
                     {? .px_grp.seek(.px_con[_fld4next],)
::                      ma kierunek zgodny z tym z notatnika
                     || {? .px_grp.DIR=_px_grp.DIR
                        ||
::                         Jaś idzie w te strony
                           .johnywalker(_was_there)
                        ||
::                         Jaś odkłada sobie sprawę na później
                           .later_add()
                        ?}
                     ?};
                     .px_con.next()
                  !}
               ?};
               .px_con.cntx_pop();
               .px_grp.cntx_pop();
               ~~
            ?};
            ~~
         ");

_obj.meth('save2GRP',,"
            .px_grp.clear();
            {? .px_grp.first()
            ||
               {!
               |?
                  {? PX_GRP.seek(.px_grp.REF,)
                  || PX_GRP.LP_Q:=.px_grp.LP_Q;
                     PX_GRP.put()
                  ?};
                  .px_grp.next()
               !}
            ?}
         ");

_obj.new().init()


\verify
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Weryfikuje czy element kolejki i jego poprzedniki maja poprawne zwroty i granice czasowe
::   WE: [_a] - PX_GRP.ref lub biezacy rekord
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_result:=1;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.clear();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: Najpierw usuwam stare komunikaty
   _typ:=exec('type_error','px_komm');
   _src_kind:=exec('src_con_verify','px_komm');
   exec('del_kommy','px_komm','PX_GRP',PX_GRP.ref(),_typ,_src_kind);

   _grp_dir:=PX_GRP.DIR;
   _grp_int:=exec('interval','#interval');
   _grp_int.START:=PX_GRP.TM_START;
   _grp_int.END:=PX_GRP.TM_END;
   _grp_what:=$PX_GRP.LP_Q+'. '+PX_GRP.SYMBOL;

   PX_CON_G.cntx_psh();
   PX_CON_G.index('NP_LP');
   PX_CON_G.prefix(PX_GRP.ref());
   {? PX_CON_G.first()
   ||
      _komm_args:=exec('add_komm_a','px_komm');
      _komm_args.PX_VER:=PX_GRP.PX_VER;
      _komm_args.PX_GRP:=PX_GRP.ref();
      _komm_args.TYP:=_typ;
      _komm_args.SRC_KIND:=_src_kind;
      {!
      |?
::       Podczytuje poprzednik
         PX_CON_G.PX_GRP_P();

         _pop_dir:=PX_GRP.DIR;
         {? var_pres('_pop_int')>100
         || obj_del(_pop_int)
         ?};
         _pop_int:=exec('interval','#interval');
         _pop_int.START:=PX_GRP.TM_START;
         _pop_int.END:=PX_GRP.TM_END;

         {? _grp_dir>0 & _pop_dir<0
         ||
::          Zwroty sie rozchodza: <- ->
::          Badam czy granice czasowe grup nachodza na siebie
            {? exec('intervals_chk','#interval',_grp_int,_pop_int)<>0
            ||
::             Nachodza na siebie - zglaszam problem
               _result:=0;
               _can_continue:=0;
               _komm_args.MESSAGE:='Grupa: \''+_grp_what+'\' i jej poprzedniki ';
               _komm_args.MESSAGE+='mają rozchodzące się zwroty: <- -> i nachodzące na siebie granice czasowe. ';
               _komm_args.MESSAGE+='Sugerowana korekta zwrotu lub granicy czasowej.';
               exec('add_komm','px_komm',_komm_args)
            ?}
         ?};
         PX_CON_G.next() & _can_continue>0
      !}
   ?};
   PX_CON_G.cntx_pop()
?};
PX_GRP.cntx_pop();
_result


\has_conns
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy podana grupa ma powiazania z innymi grupami
::   WE: [_a] - PX_GRP.ref
::   WY: 0 - brak powiazan
::       1 - sa powiazania
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.clear();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_CON_G.cntx_psh();
   PX_CON_G.index('NP_LP');
   PX_CON_G.prefix(PX_GRP.ref());
   {? PX_CON_G.size()>0
   ||
::    Sa poprzedniki
      _result:=1
   ?};
   {? _result=0
   ||
      PX_CON_G.index('PN_LP');
      PX_CON_G.prefix(PX_GRP.ref());
      {? PX_CON_G.size()>0
      ||
::       Sa nastepniki
         _result:=1
      ?}
   ?};
   PX_CON_G.cntx_pop()
?};
PX_GRP.cntx_pop();
_result


\collect
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Kolekcjonuje nastepniki i poprzedniki danej grupy
::   WE: [_a] - PX_GRP.ref
::       _b - obj_new() - tabela z nastepnikami
::       _c - obj_new() - tabela z poprzednikami
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_refs_next:=_b;
_refs_prev:=_c;

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.clear();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_CON_G.cntx_psh();
   PX_CON_G.index('NP_LP');
   PX_CON_G.prefix(PX_GRP.ref());
   {? PX_CON_G.first()
   ||
::    Zbieram poprzedniki do usuniecia
      {!
      |? _refs_prev.add(PX_CON_G.PX_GRP_P);
         PX_CON_G.next()
      !}
   ?};
   PX_CON_G.index('PN_LP');
   PX_CON_G.prefix(PX_GRP.ref());
   {? PX_CON_G.first()
   ||
::    Zbieram nastepniki do usuniecia
      {!
      |? _refs_next.add(PX_CON_G.PX_GRP_N);
         PX_CON_G.next()
      !}
   ?};
   PX_CON_G.cntx_pop()
?};
PX_GRP.cntx_pop();
~~


\del_connected
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Usuwa wszystkie powiazane z dana grupa poprzedniki/nastepniki
::   WE: _a - obj_new() - tabela z nastepnikami
::       _b - obj_new() - tabela z poprzednikami
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_refs_next:=_a;
_refs_prev:=_b;

_result:=0;
_can_continue:=1;

_mydo:=do_state()=0;
{? _mydo || do() ?};

PX_GRP.cntx_psh();

:: Usuwamy poprzedniki
{? _refs_prev.tab.first()
|| {!
   |? PX_GRP.clear();
      {? PX_GRP.seek(_refs_prev.tab.REF,_refs_prev.tab.NAME)
      || _can_continue:=exec('delete','px_grp',PX_GRP.ref())
      ?};
      _refs_prev.tab.next() & _can_continue>0
   !}
?};

:: Usuwamy nastepniki
{? _can_continue>0
||
   {? _refs_next.tab.first()
   || {!
      |?
         PX_GRP.clear();
         {? PX_GRP.seek(_refs_next.tab.REF,_refs_next.tab.NAME)
         || _can_continue:=exec('delete','px_grp',PX_GRP.ref())
         ?};
         _refs_next.tab.next() & _can_continue>0
      !}
   ?}
?};
PX_GRP.cntx_pop();
{? _can_continue>0
|| _result:=1
|| _result:=0;
   undo()
?};
{? _mydo || end() ?};
_result


\view_conns
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Wyswietla powiazane grupy z przekazana grupa
::   WE: [_a] - PX_GRP.ref
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
PX_SET.cntx_psh();
JM.cntx_psh();
{? _ref<>null()
|| PX_GRP.clear();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _px_grp:=PX_GRP.ref();
:: Tworze tabele tymczasowa ktora bede wyswietlac
   _tab:=tab_tmp(2,
      'REF','STRING[16]','Ref SQL',
      'LP','REAL','Lp.',
      'SYMBOL','STRING[100]','Symbol',
      'ILOSC','REAL','Ilość',
      'JM','STRING[10]','jm',
      'PX_SET','STRING[100]','Zestaw źródłowy'
   );
   _tab.fld_fml('LP','DISPLAY_FORMAT',"'out_prec=0'");
:: Zasilam tabele tymczasowa
   exec('view_load','px_con_g',,_tab);

   _ndx:=_tab.ndx_tmp(,,'LP',,,'SYMBOL',,);
   _tab.index(_ndx);

:: Tworze okno ktore wyswietle
   _wer:=_tab.mk_sel('Powiązane elementy kolejki'@,,,'pxcongview');
   _tab.win_fld(_wer,,'LP',,,2);
   _tab.win_fld(_wer,,'SYMBOL',,,40);
   _tab.win_fld(_wer,,'ILOSC',,,8,ST.DOKL);
   _tab.win_fld(_wer,,'JM',,,3);
   {? exec('is_px_set','px_param')>0
   || _tab.win_fld(_wer,,'PX_SET',,,10)
   ?};
   _tab.win_sel(_wer);
   _tab.select()
?};
PX_GRP.cntx_pop();
PX_SET.cntx_pop();
JM.cntx_pop();
~~


\view_load
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Zasila tabele tymczasowa wyswietlajaca powiazania
::   WE: [_a] - PX_GRP.ref
::       _b - tab_tmp - tabelka do zasilenia
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};
_tab:=_b;

_result:=0;
_can_continue:=1;

_tab.cntx_psh();
PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.clear();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _refs_next:=exec('ref_table','#table');
   _refs_prev:=exec('ref_table','#table');
   exec('collect','px_con_g',,_refs_next,_refs_prev);

   PX_GRP.cntx_psh();
:: Dodajemy poprzedniki
   {? _refs_prev.tab.first()
   || {!
      |? PX_GRP.clear();
         {? PX_GRP.seek(_refs_prev.tab.REF,_refs_prev.tab.NAME)
         || _tab.prefix($PX_GRP.ref());
            {? _tab.size()=0
            ||
               _tab.blank();
               _tab.REF:=$PX_GRP.ref();
               _tab.LP:=PX_GRP.LP_Q;
               _tab.SYMBOL:=PX_GRP.SYMBOL;
               _tab.ILOSC:=PX_GRP.ILOSC;
               _tab.JM:=PX_GRP.JM().KOD;
               _tab.PX_SET:=PX_GRP.SET_SRC().SYMBOL;
               _tab.add();

::             !!! REKURENCJA !!!
               exec('view_load','px_con_g',,_tab)
            ?}
         ?};
         _refs_prev.tab.next() & _can_continue>0
      !}
   ?};

:: Dodajemy nastepniki
   {? _can_continue>0
   ||
      {? _refs_next.tab.first()
      || {!
         |?
            PX_GRP.clear();
            {? PX_GRP.seek(_refs_next.tab.REF,_refs_next.tab.NAME)
            || _tab.prefix($PX_GRP.ref());
               {? _tab.size()=0
               ||
                  _tab.blank();
                  _tab.REF:=$PX_GRP.ref();
                  _tab.LP:=PX_GRP.LP_Q;
                  _tab.SYMBOL:=PX_GRP.SYMBOL;
                  _tab.ILOSC:=PX_GRP.ILOSC;
                  _tab.JM:=PX_GRP.JM().KOD;
                  _tab.PX_SET:=PX_GRP.SET_SRC().SYMBOL;
                  _tab.add();

::                !!! REKURENCJA !!!
                  exec('view_load','px_con_g',,_tab)
               ?}
            ?};
            _refs_next.tab.next() & _can_continue>0
         !}
      ?}
   ?};
   PX_GRP.cntx_pop()
?};
PX_GRP.cntx_pop();
_tab.cntx_pop();
_tab.clear();
~~


\formula4conns_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Tablica parametrów dla formula4conns
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
::             Obiekt w kolejce ktorego poprzedniki nastepniki przerabiac
               'PX_GRP'
::             Formula do wykonania
               ,'FORMULA'
::             Argumenty _b dla formuly (jako _a zostanie przekazana ta tablica)
               ,'ARGS'
::             Spodziewana wartosc zwrocona przez formule - jesli inna to koniec przetwarzania
               ,'EXPECTED'
::             Tablica odwiedzonych elementow
               ,'VISITED'
::             Wynik formuly 0/1
               ,'RESULT'
              );
_args.PX_GRP:=null();
_args.FORMULA:="";
_args.ARGS:=~~;
_args.EXPECTED:=~~;
_args.VISITED:=exec('ref_table','#table');
_args.RESULT:=1;
_args


\formula4conns
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Fukonuje przekazana formule dla wszystkich nastepnikow/poprzednikow przekazanej grupy
::   WE: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=1;
_can_continue:=1;


PX_GRP.cntx_psh(); PX_GRP.clear();

{? PX_GRP.seek(_args.PX_GRP)
||
   _args.VISITED.add(PX_GRP.ref());
:: Wykonuje przekazana formule
   _args.RESULT:=_args.FORMULA(_args,_args.ARGS);

   _can_continue:=1;

   {? type_of(_args.EXPECTED)>0
   ||
      {? _args.EXPECTED=_args.RESULT
      || _can_continue:=1
      || _can_continue:=0
      ?}
   ?};

   {? _can_continue>0
   ||
      _refs_next:=exec('ref_table','#table');
      _refs_prev:=exec('ref_table','#table');
      exec('collect','px_con_g',,_refs_next,_refs_prev);

      PX_GRP.cntx_psh();
::    Przetwarzamy poprzedniki
      {? _refs_prev.tab.first()
      || {!
         |? PX_GRP.clear();
            {? PX_GRP.seek(_refs_prev.tab.REF,_refs_prev.tab.NAME)
            ||
               {? _args.VISITED.r_find(PX_GRP.ref())=0
               ||
                  {? var_pres('_args_loc')>100
                  || obj_del(_args_loc)
                  ?};
                  _args_loc:=exec('formula4conns_a','px_con_g');
                  _args_loc.PX_GRP:=PX_GRP.ref();
                  _args_loc.FORMULA:=_args.FORMULA;
                  _args_loc.ARGS:=_args.ARGS;
                  _args_loc.EXPECTED:=_args.EXPECTED;
                  obj_del(_args_loc.VISITED);
                  _args_loc.VISITED:=_args.VISITED;

::                !!! REKURENCJA !!!
                  exec('formula4conns','px_con_g',_args_loc);
                  {? _args_loc.RESULT<=0
                  || _args.RESULT:=0
                  ?}
               ?}
            ?};
            _refs_prev.tab.next() & _can_continue>0
         !}
      ?};

::    Przetwarzamy nastepniki
      {? _refs_next.tab.first()
      || {!
         |? PX_GRP.clear();
            {? PX_GRP.seek(_refs_next.tab.REF,_refs_next.tab.NAME)
            ||
               {? _args.VISITED.r_find(PX_GRP.ref())=0
               ||
                  {? var_pres('_args_loc')>100
                  || obj_del(_args_loc)
                  ?};
                  _args_loc:=exec('formula4conns_a','px_con_g');
                  _args_loc.PX_GRP:=PX_GRP.ref();
                  _args_loc.FORMULA:=_args.FORMULA;
                  _args_loc.ARGS:=_args.ARGS;
                  _args_loc.EXPECTED:=_args.EXPECTED;
                  obj_del(_args_loc.VISITED);
                  _args_loc.VISITED:=_args.VISITED;

::                !!! REKURENCJA !!!
                  exec('formula4conns','px_con_g',_args_loc);
                  {? _args_loc.RESULT<=0
                  || _args.RESULT:=0
                  ?}
               ?}
            ?};
            _refs_next.tab.next() & _can_continue>0
         !}
      ?};
      PX_GRP.cntx_pop()
   ?}
?};
PX_GRP.cntx_pop();
PX_GRP.get();
~~


\can_del_conns
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy mozna usunac wszystkie powiazane ze soba w kolejce grupy
::   WE: [_a] - PX_GRP.ref
::       [_b] - INTEGER - 0/[1] - czy inicjowac i wywswietlac KOMM
::   WY: 0 - nie mozna
::       1 - mozna
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};
_init_komm:=1;
{? var_pres('_b')=type_of(0)
|| _init_komm:=_b
?};

_result:=0;
_can_continue:=1;

{? _init_komm>0
|| KOMM.init(250,,'Usuwanie powiązanych elementów kolejki.'@)
?};

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.clear();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _fml:="
      _args_global:=_a;
      _args_loc:=_b;

      _result:=exec('can_delete','px_grp',,2);
      _result
   ";
   _args:=exec('formula4conns_a','px_con_g');
   _args.PX_GRP:=PX_GRP.ref();
   _args.FORMULA:=_fml;
   exec('formula4conns','px_con_g',_args);
   _result:=_args.RESULT
?};
PX_GRP.cntx_pop();
{? _init_komm>0
|| KOMM.select()
?};
_result


:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:36 093e843cfeb0dd3532ac8277cf9367b663b6d60c82c035b54aa53c0f70cd65e2cb2a5cb5b831d1fb9cf1f630965340c9dbbafaf0b84c42ea7735086c1b4d75c6f678b35d24cb1377fd13843ab35ea2b1be9fb9df49bce017ab6d79b4ff838213871ec7f6b132bd96862fdb0cff165efa6182bbdc7f55019f78830a414c7f5a1a
