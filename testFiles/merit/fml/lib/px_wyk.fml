:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: px_wyk.fml [12.10]
:: Utworzony: 2011-07-30
:: Autor: TS
::======================================================================================================================
:: Zawartość: Obsługa rejestracji wykonania planu w planie strategicznym (wielowymiarowym planie pojemnościowym)
::======================================================================================================================


\px_poz_wykon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Rejestracja wykonania do pozycji planu
::       Kontekst - pozycja planu (PX_POZ)
::   WE: [_a] - 1=z dialogami (domyslnie) / 0=bez dialogow
::              Opcja bez dialogow dostepna tylko dla galezi szybkiej rejestracji wykonania
::              oraz dla wartosci parametru 8761 rownej 'P' oznacza szybka rejestracje
::       [_b] - INTEGER - 0/[1] - czy wykonywać odświeżanie kafelków
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _dialog:=_a || _dialog:=1 ?};
_kafelki_reload:=1;
{? var_pres('_b')=type_of(0)
|| _kafelki_reload:=_b
?};

{? exec('get','#params',500613,2)='N'
|| {? _dialog || exec('no_enabled','px_wyk') ?};
   return()
?};

{? exec('chk_role','#b__box',OPERATOR.USER,'TTE_WYK_DWPS')=0
|| {? _dialog || exec('no_auth','px_wyk') ?};
   return()
?};

{? PX_POZ.PL_OPER<>null() | PX_POZ.PL_OGR<>null()
|| {? _dialog
   || FUN.emsg('Pozycja planu strategicznego z planu operacyjnego — nie można bezpośrednio rejestrować wykonań.'@)
   ?};
   return()
?};

{? PX_POZ.PX_OBJ().REM_ZGL<>null()
|| {? _dialog
   || FUN.emsg('Pozycja planu strategicznego dotyczy zgłoszenia remontowego — nie można rejestrować wykonań.'@)
   ?};
   return()
?};

_px_poz:=PX_POZ.ref();
_block:=exec('blk_lock','#table','PX_POZ',_px_poz,,1);
{? ~_block
|| {? _dialog || exec('blk_comm','px_wyk',exec('blk_lock','#table','PX_POZ',_px_poz,,2)) ?};
   return()
?};

:: Trigger sprawdzający poprawność wypełnienia PX_WYK
_ff:="exec('FindAndGet','#table',PX_POZ,PX_WYK.PX_POZ,,,null())<>null()";
PX_WYK.trig_b('add',_ff,'chk_rec');

:: Z jakiego okna wywołana akcja
_kafelek:=cur_win(1,1);

Cntx.psh(PROD_REJ,PX_POZ,PX_CUP,PX_VAR);
_exit:="Cntx.pop(PROD_REJ,PX_POZ,PX_CUP,PX_VAR);PX_CUP.get()";

PROD_REJ.index('PX_POZ');
PROD_REJ.prefix('PX',PX_POZ.ref());
{? ~PROD_REJ.first()
|| FUN.emsg('Nie zainicjowano tabeli do rejestracji produkcji.\n\n(Obszar roboczy ZWS_ADM Administracja)'@)
||
   {? exec('get','#params',500633,2)='T' & PROD_REJ.DOREJ<>'T'
   || FUN.info('Zapis niedostępny do rejestracji — najpierw należy zarejestrować operacje poprzedzające.'@);
      _exit();
      exec('blk_unlock','#table','PX_POZ',_px_poz);
      return()

:: W wersji wdrozeniowej dostepne formuly przed i po standardowej obsludze
   |? exec('px_poz_wykon_b','px_prepq',_dialog)
   ||
:: Mozliwosci rejestracji wykonania w zaleznosci od parametru 8761:
:: - pytac, czy bedzie rejestracja jednorazowa, procentowa czy szczegolowa (wartosc parametru: 'P')
:: - dodanie kolejnego wpisu dla wszystkich wymiarow, sumowanie na pozycji planu (rejestracja szczegolowa: 'T')
:: - okreslenie zaawansowania dla kazdego wymiaru, pozycje dodaja sie w tle (rejestracja szczegolowa: 'N')
      {? VAR.GRUPA<>'T' & PX_POZ.STATUS=exec('status_skipped','px_poz')
      || {? _dialog || FUN.emsg('Do pozycji porzuconej nie można rejestrować wykonania.'@) ?};
         _exit();
         exec('blk_unlock','#table','PX_POZ',_px_poz);
         return()
      ?};

      _ver:=exec('get','#params',8761,2,OPERATOR.USER);
      _il_wym:=PX_POZ.PX_KONT().IL_WYM;
      _max_wym:=exec('il_wym','px_param');

      _go:=0;
      {? VAR.GRUPA='T' & _ver='P'
      || _ver:='N'
      |? _ver='P'
      || {? ~_dialog
         || _ver:='N'
         || {? PX_POZ.STATUS=exec('status_delay','px_poz')
            ||
::             Dla opóźnionych nie dajemy możliwości szczegółowej, bo w oknie wertowania po pierwszej rejestracji
::             częściowej nie ma już oryginalnej pozycji planu i jest to dezorientujące dla usera
               _choice:=FUN.choice('Jak rejestrować wykonanie?'@,,'Jednorazowo'@,'Procentowo'@);

               {? _choice=1
               || _ver:='N'; _go:=1
               |? _choice=2
               || _ver:='R'
               || _exit();
                  exec('blk_unlock','#table','PX_POZ',_px_poz);
                  return()
               ?}
            ||
               _choice:=FUN.choice('Jak rejestrować wykonanie?'@,,'Szczegółowo'@,'Jednorazowo'@,'Procentowo'@);

               {? _choice=1
               || _ver:='T'
               |? _choice=2
               || _ver:='N'; _go:=1
               |? _choice=3
               || _ver:='R'
               || _exit();
                  exec('blk_unlock','#table','PX_POZ',_px_poz);
                  return()
               ?}
            ?}
         ?}
      ?};

      {? _ver='T'
      ||
         PX_WYK.index('POZ');
         PX_WYK.prefix(PX_POZ.ref());
         PX_WYK.win_sel('WER');

         _il_wym:=PX_POZ.PX_KONT().IL_WYM;
         _max_wym:=exec('il_wym','px_param');

         {! _it:=1.._max_wym
         |!
::          czyszczę nazwy kolumn
            _fml:='PX_WYK.fld_opt(\'WER\',\'col_name=%1\'[\'\"\"\'],PX_WYK,\'CAP_WYK'+$_it+'\')';
            ($(_fml))()
         !};

         {! _it:=1.._il_wym
         |!
            _fml:='PX_WYK.fld_opt(\'WER\',\'col_name=%1\'[PX_KONT.JM'+$_it+'().KOD+\' - \'+JM.NAZ],PX_WYK,\'CAP_WYK'+$_it+'\')';
            ($(_fml))();
::            ($('PX_VAR.TITD'+$_it+':=PX_KONT.JM'+$_it+'().KOD+\' - \'+JM.NAZ'))();
            PX_WYK.fld_attr('CAP_WYK'+$_it,,3);
            _format:=$("'out_prec="+$($('PX_POZ.PX_KONT().PREC'+$_it))()+"'");
            PX_WYK.win_fml('WER',,'CAP_WYK'+$_it,,'SUM_FORMAT',_format)
         !};
         {? _il_wym<_max_wym
         || {! _it:=_il_wym+1.._max_wym
            |! ($('PX_VAR.TITD'+$_it+':=\' - \''))();
               PX_WYK.fld_attr('CAP_WYK'+$_it,,2)
            !}
         ?};
         _keys:={? PX_POZ.TM_SRC<>0 || 'DP:' || ':' ?};
         {? PX_POZ.STATUS=exec('status_wyk2','px_poz') & PX_POZ.TM_END<PX_POZ.tm_stamp()
         ||
::          Dla wykonanych w całości, ale opóźnionych zabieram akcję 'Popraw' ponieważ
::          ta ścieżka jest póki co niepoprawnie obsługiwana (poprawianie PX_WYKa jest zrobione metodą usuń stary, dodaj nowy)
::          co w takim przypadku działa dziwnie, ponieważ ilości z pozycji planu przy poprawianiu przepływają na inną pozycję
::          planu
            _keys:='P'+_keys
         ?};
         PX_WYK.select(,,,_keys)
      |? _ver='N'
      ||
::       Sprawdzenie, czy juz byla jakakolwiek rejestracja, oraz wykonanie calkowite we wszystkich wymiarach
         _wyk:=0;
         _all_wyk:=0;
         _wyk_tab:=obj_new(_il_wym);
         {! _it:=1.._il_wym
         |! _wyk+=($('PX_POZ.CAP_WYK'+$_it))();
            {? ($('PX_POZ.CAP_WYK'+$_it+'>=PX_POZ.CAP_EAT'+$_it))() || _all_wyk+=1 ?};
            _wyk_tab[_it]:=($('PX_POZ.CAP_EAT'+$_it+'-PX_POZ.CAP_WYK'+$_it))();
            {? _wyk_tab[_it]<0 || _wyk_tab[_it]:=0 ?}
         !};
         {? _all_wyk=_il_wym
         ||
            {? VAR.GRUPA<>'T' & _dialog || FUN.emsg('Do tej pozycji planu zarejestrowano już całkowite wykonanie.'@) ?}
         |? _wyk>0
         ||
            {? VAR.GRUPA='T' | ~_dialog |
               FUN.ask(
                  'Do tej pozycji planu zarejestrowano już częściowe wykonanie.\n\n'
                  'Czy zarejestrować całkowite wykonanie pozycji planu?'@
               )
            ||
               _edit:=VPRODREJ.mk_edit('Rejestracja wykonania'@,,'px_poz_param');
               VPRODREJ.win_efld(_edit,,'PLACE','KOD','*',30,0,,'Stanowisko');
               VPRODREJ.win_efld(_edit,,'PLACE','NA','*',30,0,1,' ');
               VPRODREJ.win_edit(_edit);
               exec('ok_esc','#window',VPRODREJ,_edit);
               VPRODREJ.efld_opt(_edit,'mark=1',,'PLACE','KOD');
               VPRODREJ.PLACE:=PX_POZ.PX_KONT().PL_RES().FROM_STA;
               {? VPRODREJ.edit("
                     {? __CHK.record(VPRODREJ,,'PLACE')<>''
                     || 0
                     || 1
                     ?}"
                  )
               ||
                  PX_WYK.index('POZ');
                  PX_WYK.prefix(PX_POZ.ref());
                  PX_WYK.blank();
                  PX_WYK.DATA0:=date();
                  PX_WYK.CZAS0:=time();
                  PX_WYK.DATA:=date();
                  PX_WYK.CZAS:=time();
                  PX_WYK.PX_POZ:=PX_POZ.ref();
                  PX_WYK.PX_OBJ:=PX_POZ.PX_OBJ;
                  PX_WYK.PX_VER:=PX_POZ.PX_VER;
                  PX_WYK.ZAK:='T';
                  PX_WYK.PLACE:=VPRODREJ.PLACE;
                  {! _it:=1.._il_wym
                  |! ($('PX_WYK.CAP_WYK'+$_it))():=_wyk_tab[_it]
                  !};
                  {? PX_WYK.add()
                  || exec('px_poz_update','px_wyk',PX_POZ.ref());
                     _nadwyk:=exec('nadwykon_pxpoz','px_wyk',PX_POZ.ref());
                     {? _nadwyk=2
                     || {? VAR.GRUPA<>'T'
                        ||
                           _argsfast:=exec('fast_replan_a','px_logix');
                           _argsfast.PX_GRP:=PX_POZ.PX_GRP;
                           _argsfast.MOD_START:=1;
                           exec('grp_fast_replan','px_logix',_argsfast)
                        || __Grp.add($PX_POZ.PX_GRP)
                        ?}
                     ?}
                  ?}
               ?}
            ?}
         ||
            {? VAR.GRUPA='T' | ~_dialog | _go | FUN.ask('Czy zarejestrować całkowite wykonanie pozycji planu?'@)
            ||
::             Pomijane sa pozycje porzucone
               {? PX_POZ.STATUS<>exec('status_skipped','px_poz')
               ||
                  _edit:=VPRODREJ.mk_edit('Rejestracja wykonania'@,,'px_poz_param');
                  VPRODREJ.win_efld(_edit,,'PLACE','KOD','*',30,0,,'Stanowisko');
                  VPRODREJ.win_efld(_edit,,'PLACE','NA','*',30,0,1,' ');
                  VPRODREJ.win_edit(_edit);
                  exec('ok_esc','#window',VPRODREJ,_edit);
                  VPRODREJ.efld_opt(_edit,'mark=1',,'PLACE','KOD');
                  VPRODREJ.PLACE:=PX_POZ.PX_KONT().PL_RES().FROM_STA;
                  {? VPRODREJ.edit("
                        {? __CHK.record(VPRODREJ,,'PLACE')<>''
                        || 0
                        || 1
                        ?}"
                     )
                  ||
                     PX_WYK.index('POZ');
                     PX_WYK.prefix(PX_POZ.ref());
                     PX_WYK.blank();
                     PX_WYK.DATA0:=date();
                     PX_WYK.CZAS0:=time();
                     PX_WYK.DATA:=date();
                     PX_WYK.CZAS:=time();
                     PX_WYK.PX_POZ:=PX_POZ.ref();
                     PX_WYK.PX_OBJ:=PX_POZ.PX_OBJ;
                     PX_WYK.PX_VER:=PX_POZ.PX_VER;
                     PX_WYK.ZAK:='T';
                     PX_WYK.PLACE:=VPRODREJ.PLACE;
                     {! _it:=1.._il_wym
                     |! ($('PX_WYK.CAP_WYK'+$_it+':=PX_POZ.CAP_EAT'+$_it))()
                     !};
                     {? PX_WYK.add()
                     || exec('px_poz_update','px_wyk',PX_POZ.ref());
                        _nadwyk:=exec('nadwykon_pxpoz','px_wyk',PX_POZ.ref());
                        {? _nadwyk=2
                        || {? VAR.GRUPA<>'T'
                           ||
                              _argsfast:=exec('fast_replan_a','px_logix');
                              _argsfast.PX_GRP:=PX_POZ.PX_GRP;
                              _argsfast.MOD_START:=1;
                              exec('grp_fast_replan','px_logix',_argsfast)
                           || __Grp.add($PX_POZ.PX_GRP)
                           ?}
                        ?}
                     ?}
                  ?}
               ?}
            ?}
         ?}
      |? _ver='R'
      ||
::    Sprawdzenie, czy juz byla jakakolwiek rejestracja, oraz wykonanie calkowite we wszystkich wymiarach
         _wyk:=0;
         _all_wyk:=0;
         _wyk_tab:=obj_new(_il_wym);
         {! _it:=1.._il_wym
         |! _wyk+=($('PX_POZ.CAP_WYK'+$_it))();
            {? ($('PX_POZ.CAP_WYK'+$_it+'>=PX_POZ.CAP_EAT'+$_it))() || _all_wyk+=1 ?};
            _wyk_tab[_it]:=($('PX_POZ.CAP_EAT'+$_it+'-PX_POZ.CAP_WYK'+$_it))()
         !};
         {? _all_wyk=_il_wym
         ||
            {? VAR.GRUPA<>'T' & _dialog || FUN.emsg('Do tej pozycji planu zarejestrowano już całkowite wykonanie.'@) ?}
         |? _wyk>0
         ||
            _procent:=100;
            {? VAR.GRUPA<>'T' & _dialog
            || {?
                  _edit:=VPRODREJ.mk_edit('Rejestracja wykonania'@,,'px_poz_param');
                  VPRODREJ.win_efld(_edit,AH,'H',,,,0,,'Do tej pozycji planu zarejestrowano już częściowe wykonanie:'@);
                  {! _it:=1.._il_wym
                  |! _rule:=$('_result:=0; {? PX_POZ.CAP_EAT'+$_it+'>0 || _result:=1 ?};_result');
                     {? _rule()
                     || _txt:='● '+'%1. wymiar'@[$_it]+' ['+($('PX_POZ.PX_KONT().JM'+$_it+'().KOD'))()+'] '+
                           $($('PX_POZ.CAP_WYK'+$_it))()+' / '+$($('PX_POZ.CAP_EAT'+$_it))()+
                           ' = '+($('form(PX_POZ.CAP_WYK'+$_it+'/'+'PX_POZ.CAP_EAT'+$_it+'*100,,2)'))()+'%';
                        VPRODREJ.win_efld(_edit,AH,'H',,,,0,,_txt)
                     ?}
                  !};
                  VPRODREJ.win_efld(_edit,AH,'H',,,,0,,''@);
                  VPRODREJ.win_efld(_edit,,'PROCENT',,,3,0,0,'Procentowe wykonanie');
                  VPRODREJ.win_efld(_edit,,'PLACE','KOD','*',30,0,,'Stanowisko');
                  VPRODREJ.win_efld(_edit,,'PLACE','NA','*',30,0,1,' ');
                  VPRODREJ.win_edit(_edit);
                  exec('ok_esc','#window',VPRODREJ,_edit);
                  VPRODREJ.efld_opt(_edit,'mark=1',,'PROCENT');
                  VPRODREJ.efld_opt(_edit,'mark=1',,'PLACE','KOD');
                  VPRODREJ.EDIT_PR:=1;
                  VPRODREJ.PROCENT:=_procent;
                  VPRODREJ.PLACE:=PX_POZ.PX_KONT().PL_RES().FROM_STA;
::                  undefine();
::                  define('H0',~~,'Do tej pozycji planu zarejestrowano już częściowe wykonanie:'@);
::                  {! _it:=1.._il_wym
::                  |! define('H'+$_it,~~,
::                        '● '+'%1. wymiar'@[$_it]+' ['+($('PX_POZ.PX_KONT().JM'+$_it+'().KOD'))()+'] '+
::                        $($('PX_POZ.CAP_WYK'+$_it))()+' / '+$($('PX_POZ.CAP_EAT'+$_it))()+
::                        ' = '+($('form(PX_POZ.CAP_WYK'+$_it+'/'+'PX_POZ.CAP_EAT'+$_it+'*100,,2)'))()+'%'
::                     )
::                  !};
::                  define('HN',~~);
::                  define('PROCENT',_procent,'Podaj procentowe wykonanie pozycji planu:'@,,,3,0);
::                  def_btn('text=%1'['Zapisz'@],'key:F2');
::                  def_btn('text=%1'['Anuluj'@],'key:Esc');
::                  def_edit();
                  VPRODREJ.edit("
                     {? VPRODREJ.PROCENT<=0
                     || FUN.emsg('Należy wpisać wartość większą od zera.'@);
                        0
                     |? VPRODREJ.PROCENT>100
                     || FUN.emsg('Wartość nie może być większa niż 100.'@);
                        0
                     |? __CHK.record(VPRODREJ,,'PLACE')<>''
                     || 0
                     || 1
                     ?}"
::                     '|--|'+FUN.TYT
                  )
               ||
                  _procent:=VPRODREJ.PROCENT;
                  PX_WYK.index('POZ');
                  PX_WYK.prefix(PX_POZ.ref());
                  PX_WYK.blank();
                  PX_WYK.DATA0:=date();
                  PX_WYK.CZAS0:=time();
                  PX_WYK.DATA:=date();
                  PX_WYK.CZAS:=time();
                  PX_WYK.PX_POZ:=PX_POZ.ref();
                  PX_WYK.PX_OBJ:=PX_POZ.PX_OBJ;
                  PX_WYK.PX_VER:=PX_POZ.PX_VER;
                  PX_WYK.ZAK:='T';
                  PX_WYK.PLACE:=VPRODREJ.PLACE;
                  {! _it:=1.._il_wym
                  |! ($('(PX_WYK.CAP_WYK'+$_it+':=PX_POZ.CAP_EAT'+$_it+'*'+form(_procent,,,'9.')+'/100)$PX_POZ.PX_KONT().PREC'+$_it))()
                  !};
                  {? PX_WYK.add()
                  || exec('px_poz_update','px_wyk',PX_POZ.ref());
                     _nadwyk:=exec('nadwykon_pxpoz','px_wyk',PX_POZ.ref());
                     {? _nadwyk=2
                     || {? VAR.GRUPA<>'T'
                        || _argsfast:=exec('fast_replan_a','px_logix');
                           _argsfast.PX_GRP:=PX_POZ.PX_GRP;
                           _argsfast.MOD_START:=1;
                           exec('grp_fast_replan','px_logix',_argsfast)
                        || __Grp.add($PX_POZ.PX_GRP)
                        ?}
                     ?}
                  ?}
               ?}
            ?}
         ||
            _procent:=100;
            {?
::               VAR.GRUPA='T' | ~_dialog | _go | FUN.ask('Czy zarejestrować procentowe wykonanie pozycji planu?')
               1
            ||
               {? VAR.GRUPA<>'T' & _dialog
               || _edit:=VPRODREJ.mk_edit('Rejestracja wykonania'@,,'px_poz_param');
                  VPRODREJ.win_efld(_edit,,'PROCENT',,,3,0,0,'Procentowe wykonanie');
                  VPRODREJ.win_efld(_edit,,'PLACE','KOD','*',30,0,,'Stanowisko');
                  VPRODREJ.win_efld(_edit,,'PLACE','NA','*',30,0,1,' ');
                  VPRODREJ.win_edit(_edit);
                  exec('ok_esc','#window',VPRODREJ,_edit);
                  VPRODREJ.EDIT_PR:=1;
                  VPRODREJ.PROCENT:=_procent;
                  VPRODREJ.PLACE:=PX_POZ.PX_KONT().PL_RES().FROM_STA;
                  VPRODREJ.efld_opt(_edit,'mark=1',,'PROCENT');
                  VPRODREJ.efld_opt(_edit,'mark=1',,'PLACE','KOD');
                  {? VPRODREJ.edit("
                        {? VPRODREJ.PROCENT<=0
                        || FUN.emsg('Należy wpisać wartość większą od zera.'@);
                           0
                        |? VPRODREJ.PROCENT>100
                        || FUN.emsg('Wartość nie może być większa niż 100.'@);
                           0
                        |? __CHK.record(VPRODREJ,,'PLACE')<>''
                        || 0
                        || 1
                        ?}"
                     )
                  || _procent:=VPRODREJ.PROCENT;

::                   Pomijane sa pozycje porzucone
                     {? PX_POZ.STATUS<>exec('status_skipped','px_poz')
                     ||
                        PX_WYK.index('POZ');
                        PX_WYK.prefix(PX_POZ.ref());
                        PX_WYK.blank();
                        PX_WYK.DATA0:=date();
                        PX_WYK.CZAS0:=time();
                        PX_WYK.DATA:=date();
                        PX_WYK.CZAS:=time();
                        PX_WYK.PX_POZ:=PX_POZ.ref();
                        PX_WYK.PX_OBJ:=PX_POZ.PX_OBJ;
                        PX_WYK.PX_VER:=PX_POZ.PX_VER;
                        PX_WYK.ZAK:='T';
                        PX_WYK.PLACE:=VPRODREJ.PLACE;
                        {! _it:=1.._il_wym
                        |! ($('(PX_WYK.CAP_WYK'+$_it+':=PX_POZ.CAP_EAT'+$_it+'*'+form(_procent,,,'9.')+'/100)$PX_POZ.PX_KONT().PREC'+$_it))()
                        !};
                        {? PX_WYK.add()
                        || exec('px_poz_update','px_wyk',PX_POZ.ref());
                           _nadwyk:=exec('nadwykon_pxpoz','px_wyk',PX_POZ.ref());
                           {? _nadwyk=2
                           || {? VAR.GRUPA<>'T'
                              ||
                                 _argsfast:=exec('fast_replan_a','px_logix');
                                 _argsfast.PX_GRP:=PX_POZ.PX_GRP;
                                 _argsfast.MOD_START:=1;
                                 exec('grp_fast_replan','px_logix',_argsfast)
                              || __Grp.add($PX_POZ.PX_GRP)
                              ?}
                           ?}
                        ?}
                     ?}
                  ?}
               ?}
            ?}
         ?}
      ?}
   ?};
   exec('px_poz_wykon_a','px_prepq',_dialog)
?};

:: Przeladowanie kafelkow, jesli mozliwe i wymagane
{? _kafelki_reload>0
|| exec('kafelki_reload','px_plan')
?};

_exit();
exec('blk_unlock','#table','PX_POZ',_px_poz);

{? VAR.GRUPA<>'T'
||
   {? _kafelek='KAFELEK'
   ||
::    Przeliczenie podsumowania w oknie PX_POZ.KAFELEK
      _compare:=exec('level_compare','px_view',PX_KONT.MAX_CDUR,PX_VIEW.LEVEL);
      {? _compare<>-1 & PX_POZ.f_active()>0
      || exec('szczegoly_sum','px_poz',1)
      || exec('szczegoly_sum','px_poz',0)
      ?}
   |? 7+_kafelek='KAFELEK'
   ||
::    Odswiezenie okna planu, gdy wolane z okien PX_POZ.KAFELEK1 .. PX_POZ.KAFELEK7
      _tree:=exec('tree_kont','px_param');
      {? var_pres('PxSelect')>100
      || {? PxSelect.Context*'COMPARE'>0
         || _tree:=0
         ?}
      ?};
      grp_disp(PX_KONT,{? _tree || 'PX_WERT' || 'PX_WER' ?},1);
      grp_disp(PX_POZ,_kafelek,0)
   ?}
?};

:: Przywrocenie naglowkow kolumn dla PX_POZow
exec('szczegoly_hdr','px_poz');

:: Usuniecie triggera
PX_WYK.trig_b('add',"",'chk_rec');

~~


\px_poz_wykon_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Rejestracja wykonania do pozycji planu - przed akcją grupową
::----------------------------------------------------------------------------------------------------------------------
{? exec('chk_role','#b__box',OPERATOR.USER,'TTE_WYK_DWPS')=0 | exec('get','#params',500613,2)='N'
|| exec('no_auth','px_wyk');
   return(0)
?};

{? exec('get','#params',500633,2)='T'
||
   FUN.info('Nie można rejestrować operacji grupowo przy ustawionej kontroli ilości dla planu strategicznego.'@);
   return(0)
?};

:: Jezeli akcja grupowa, to tylko rejestracja uproszczona (bez dodatkowego pytania dla parametru 8761 rownego 'P')
_ver:=exec('get','#params',8761,2,OPERATOR.USER);
{? _ver='T'
|| FUN.emsg('Szczegółowa rejestracja wykonania nie jest dostępna jako akcja grupowa.'@); 0
|| {? FUN.ask('Czy zarejestrować całkowite wykonanie zaznaczonych pozycji planu?'@)
   || VAR.GRUPA:='T';
      VAR_DEL.delete('__Grp');
      __Grp:=obj_new('TAB','add');
      __Grp.TAB:=tab_tmp(1,'REF','STRING[16]','$PX_GRP.ref()');
      __Grp.add:=".TAB.prefix(_a); {? ~.TAB.first() || .TAB.REF:=_a; .TAB.add() ?}; .TAB.clear()";
      sel_nchk();
      1
   || 0
   ?}
?}


\px_poz_wykon_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Rejestracja wykonania do pozycji planu - po akcji grupowej
::----------------------------------------------------------------------------------------------------------------------
:: przeplanowanie grup, o ile wymagane
_grp:=__Grp.TAB;
{? _grp.first()
|| _argsfast:=exec('fast_replan_a','px_logix');
   _argsfast.MOD_START:=1;
   {!
   |? _argsfast.PX_GRP:=exec('FindAndGet','#table',PX_GRP,_grp.REF,,"ref()",null());
      exec('grp_fast_replan','px_logix',_argsfast);
      _grp.next()
   !}
?};
VAR_DEL.delete('__Grp');
VAR.GRUPA:='N';
:: Z jakiego okna wywolana akcja
_kafelek:=cur_win(1,1);
:: Po akcji grupowej trzeba odswiezyc podsumowania w oknie
{? _kafelek='KAFELEK'
||
:: Przeliczenie podsumowania w oknie PX_POZ.KAFELEK
   _compare:=exec('level_compare','px_view',PX_KONT.MAX_CDUR,PX_VIEW.LEVEL);
   {? _compare<>-1
   || exec('szczegoly_sum','px_poz',1)
   || exec('szczegoly_sum','px_poz',0)
   ?}
|? 7+_kafelek='KAFELEK'
||
:: Odswiezenie okna planu, gdy wolane z okien PX_POZ.KAFELEK1 .. PX_POZ.KAFELEK7
   _tree:=exec('tree_kont','px_param');
   {? var_pres('PxSelect')>100
   || {? PxSelect.Context*'COMPARE'>0
      || _tree:=0
      ?}
   ?};
   grp_disp(PX_KONT,{? _tree || 'PX_WERT' || 'PX_WER' ?},1);
   grp_disp(PX_POZ,_kafelek,0)
?};
{? PX_POZ.f_active()>0
|| PX_POZ.f_rfresh()
?};
~~


\px_wyk_dolacz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Dołączanie / aktualizacja rekordu PX_WYK (wykonanie)
:: '-*-e-kioski-*-';
::  WE: 0 - standardowa akcja, 1 - aktualizacja istniejącego wykonania
::----------------------------------------------------------------------------------------------------------------------
'-*-e-kioski-*-';
{? _<1 || _a:=0 ?};
_px_poz:=PX_POZ.ref();
_block:=exec('blk_lock','#table','PX_POZ',_px_poz,,1);
{? _block
||
   _grp_dsp:=0;

   Cntx.psh(PROD_REJ);

:: Znajdz odpowiedni PROD_REJ
   PROD_REJ.index('PX_POZ');
   PROD_REJ.prefix('PX',_px_poz);
   {? PROD_REJ.first()
   ||
      _ok:=1;
      {? PROD_REJ.OK='T'
      || _ok:=0;
         FUN.info('Wykonanie operacji zostało już zarejestrowane.'@)
      ?};

      {? _ok>0 & PROD_REJ.DOREJ<>'T'
      || _ok:=0;
         FUN.info('Zapis niedostępny do rejestracji — najpierw należy zarejestrować operacje poprzedzające.'@)
      ?};
      {? _ok>0
      || PX_WYK.win_edit('RED');
         '-*-e-kioski-*-';
         {? ~_a
         || PX_WYK.blank();
            PX_WYK.DATA0:=date();
            PX_WYK.CZAS0:=time();
            PX_WYK.PLACE:=PX_POZ.PX_KONT().PL_RES().FROM_STA
         ?};
         PX_WYK.PX_POZ:=_px_poz;
         PX_WYK.PX_OBJ:=PX_POZ.PX_OBJ;
         PX_WYK.PX_VER:=PX_POZ.PX_VER;
         PX_WYK.DATA:=date();
         PX_WYK.CZAS:=time();
         PX_WYK.ZAK:='T';
         '-*-e-kioski-*-';
         {? _a | PX_WYK.edit("exec('px_wyk_valid','px_wyk')")
         || {? {? _a || PX_WYK.put() || PX_WYK.add() ?}
            || _grp_dsp:=1;
               exec('px_poz_update','px_wyk',_px_poz);
               _nadwyk:=exec('nadwykon_pxpoz','px_wyk',_px_poz);
               {? _nadwyk=2
               || _argsfast:=exec('fast_replan_a','px_logix');
                  _argsfast.PX_GRP:=PX_POZ.PX_GRP;
                  _argsfast.MOD_START:=1;
                  exec('grp_fast_replan','px_logix',_argsfast)
               ?};
               '-*-e-kioski-*-';
               {? ~_a
               || {? PX_WYK.size()=0 & (cur_win()='WER1' | cur_win()='WER') || sel_exit() ?}
               ?}
            ?}
         ?}
      ?}
   ?};

   Cntx.pop(PROD_REJ);

   exec('blk_unlock','#table','PX_POZ',_px_poz);

   '-*-e-kioski-*-';
   {? ~_a & var_pres('ProdRej')>100 & _grp_dsp & cur_win()<>'WER1' & cur_win()<>'WER'
   || grp_disp(PROD_REJ,{? ProdRej.F_FILTER || 'WERF' || 'WER' ?},1)
   ?}
||
   exec('blk_comm','px_wyk',exec('blk_lock','#table','PX_POZ',_px_poz,,2))
?};
~~


\px_wyk_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Poprawianie rekordu PX_WYK (wykonanie)
::----------------------------------------------------------------------------------------------------------------------
{? PX_WYK.AUTOPL='T' | PX_WYK.AUTOZL='T'
|| FUN.info('Zapis automatyczny — nie można poprawiać.'@)
||
   _px_poz:=PX_WYK.PX_POZ;
   _block:=exec('blk_lock','#table','PX_POZ',_px_poz,,1);
   {? _block
   ||
      Cntx.psh(PROD_REJ);

::    Znajdz odpowiedni PROD_REJ
      PROD_REJ.index('PX_POZ');
      PROD_REJ.prefix('PX',PX_WYK.PX_POZ);
      {? PROD_REJ.first()
      || _il_next:=exec('il_nast','px_wyk',PROD_REJ.ref());
         {? exec('get','#params',500633,2)='T' & _il_next>0
         || FUN.emsg('Zarejestowane wykonania do kolejnych operacji.'@)
         ||
            PX_WYK.win_edit('RED');
            exec('px_wyk_efld_opt','px_wyk');
            {? PX_WYK.edit("exec('px_wyk_valid','px_wyk')")
            ||
::             Zapamietanie zmodyfikowanych danych
               _px_wyk:=exec('PX_WYK','buffer1');
               _px_wyk.get();
               do();
               _px_poz:=PX_WYK.PX_POZ;
               _px_grp:=PX_WYK.PX_POZ().PX_GRP;
               _poz_changed:=0;

::             Usuniecie rekordu i sprawdzenie, czy przeplanowywac
               exec('delete','px_wyk',PX_WYK.ref(),,_px_wyk);

::             W wyniku usunięcia PX_WYKa PX_POZ mógł przestać istnieć, dlatego w przekazanym
::             buforze mam nowego PX_POZa do którego mogło nastąpić scalenie
               {? _px_poz<>_px_wyk.PX_POZ
               || _poz_changed:=1
               ?};
               _px_poz:=_px_wyk.PX_POZ;

               _moved:=exec('nadwykon_moved','px_poz',_px_poz);

::             Ponowne dodanie rekordu i ew. przeplanowanie
               {? _poz_changed>0
               || PX_WYK.prefix(_px_poz)
               ?};
               PX_WYK.blank(1);
               _px_wyk.set();
               {? PX_WYK.add()
               ||
                  exec('px_poz_update','px_wyk',_px_poz);
                  _nadwyk:=exec('nadwykon_pxpoz','px_wyk',_px_poz);
                  {? _nadwyk=2 | _moved=1
                  ||
                     _argsfast:=exec('fast_replan_a','px_logix');
                     _argsfast.PX_GRP:=_px_grp;
                     _argsfast.MOD_START:=1;
                     exec('grp_fast_replan','px_logix',_argsfast)
                  ?}
               ?};
               PX_WYK.get();
               end();
               {? (cur_win()='WER1' | cur_win()='WER')
               || {? PX_WYK.size()=0 || sel_exit() ?}
               ?}
            ?}
         ?}
      ?};

      Cntx.pop(PROD_REJ);

      exec('blk_unlock','#table','PX_POZ',_px_poz)
   ||
      exec('blk_comm','px_wyk',exec('blk_lock','#table','PX_POZ',_px_poz,,2))
   ?}
?};
~~


\px_wyk_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Usuwanie rekordu PX_WYK (wykonanie)
::----------------------------------------------------------------------------------------------------------------------
{? PX_WYK.AUTOPL='T' | PX_WYK.AUTOZL='T'
|| FUN.info('Zapis automatyczny — nie można usunąć.'@)
||
   _px_poz:=PX_WYK.PX_POZ;
   _block:=exec('blk_lock','#table','PX_POZ',_px_poz,,1);
   {? _block
   ||
      _grp_dsp:=0;

      Cntx.psh(PROD_REJ);

::    Znajdz odpowiedni PROD_REJ
      PROD_REJ.index('PX_POZ');
      PROD_REJ.prefix('PX',_px_poz);
      {? PROD_REJ.first()
      || _il_next:=exec('il_nast','px_wyk',PROD_REJ.ref());
         {? exec('get','#params',500633,2)='T' & _il_next>0
         || FUN.emsg('Zarejestowane wykonania do kolejnych operacji.'@)
         ||
            {? FUN.ask('Czy na pewno usunąć pozycję?'@)
            || _grp_dsp:=1;
               _px_grp:=PX_WYK.PX_POZ().PX_GRP;
               exec('delete','px_wyk',PX_WYK.ref());
               exec('px_poz_update','px_wyk',_px_poz);
               _moved:=exec('nadwykon_moved','px_poz',_px_poz);
               {? _moved=1
               || _argsfast:=exec('fast_replan_a','px_logix');
                  _argsfast.PX_GRP:=_px_grp;
                  _argsfast.MOD_START:=1;
                  exec('grp_fast_replan','px_logix',_argsfast);
                  {? cur_win()='WER1' | cur_win()='WER'
                  || {? PX_WYK.size()=0 || sel_exit() ?}
                  || {? PX_WYK.size()=0 || PX_POZ.blank(1) ?}
                  ?}
               ?}
            ?}
         ?}
      ?};

      Cntx.pop(PROD_REJ);

      exec('blk_unlock','#table','PX_POZ',_px_poz);

      '-*-e-kioski-*-';
      {? var_pres('ProdRej')>100 & _grp_dsp & cur_win()<>'WER1' & cur_win()<>'WER' & VEK.TERM<>'T'
      || grp_disp(PROD_REJ,{? ProdRej.F_FILTER || 'WERF' || 'WER' ?},1)
      ?}
   ||
      exec('blk_comm','px_wyk',exec('blk_lock','#table','PX_POZ',_px_poz,,2))
   ?}
?};
~~


\px_poz_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Naliczenie wykonania pozycji (PX_POZ) na podstawie czesciowych wykonan (PX_WYK)
::   WE: _a - PX_POZ.ref()
::::    [_b] - obj_new() - bufor usuwanego PX_WYKa
::----------------------------------------------------------------------------------------------------------------------
_pxpoz:=_a;

_buf_wyk:=~~;
{? var_pres('_b')>100
|| _buf_wyk:=_b
?};

PX_WYK.cntx_psh();
PX_POZ.cntx_psh();
PX_POZ.clear();
{? PX_POZ.seek(_pxpoz)
||
   _il_wym:=PX_POZ.PX_KONT().IL_WYM;

:: tablica kumulujaca wykonania
   _sum_wyk:=obj_new(_il_wym);

   {! _it:=1.._il_wym
   |! ($('PX_POZ.CAP_WYK'+$_it))():=0;
      ($('_sum:=_a;_sum['+$_it+']:=0'))(_sum_wyk)
   !};

:: 1. Sumuje wykonania dla pozycji planu
   PX_WYK.index('POZ');
   PX_WYK.prefix(PX_POZ.ref());
   {? PX_WYK.first()
   || {!
      |?
         {! _it:=1.._il_wym
         |! _rule:=$('
                        _sum_wyk:=_a;
                        _wyk_il:=PX_WYK.CAP_WYK'+$_it+';
                        _sum_wyk['+$_it+']+=_wyk_il
                     ');
            _rule(_sum_wyk)
         !};
         PX_WYK.next()
      !}
   ?};
:: 2. Ustawiam sume wykonan na pozycji planu
   _argsupdate:=exec('blank_a','px_poz');
   exec('record2args','px_poz',_argsupdate);

   _wyk_all:=1;
   _wyk_part:=0;
   {! _it:=1.._il_wym
   |! _rule:=$('
                  _wyk:=_a;
                  _argsupdate:=_b;
                  _result:=0;
                  _argsupdate.CAP_WYK'+$_it+':=_wyk;
                  {? _wyk>=_argsupdate.CAP_EAT'+$_it+'
                  || _result:=1
                  ?};
                  _result
               ');


      _wyk:=_sum_wyk[_it];
      _result:=_rule(_wyk,_argsupdate);

::    poniewaz w formuli+ nie ma funkcji max i min te warunki sa pogiete jak baranie rogi
::    ale generalnie chodzi o to ze w zmiennych _wyk_all i _wyk_part trzymam status wykonania pozycji planu
      {? _wyk_all=1
      || _wyk_all:=_result
      ?};
      {? _wyk_part=0
      || {? _wyk>0
         || _wyk_part:=1
         ?}
      ?}
   !};
   exec('update','px_poz',_argsupdate);

:: 3. Modyfikuje status pozycji planu
::    (jesli we wszystkich wymiarach zarejestrowano wykonanie co najmniej
::    takiej ilosci jaka byla zaplanowana to dopiero pozycja jest oznaczona jako 'wykonana'
::    w kazdym innym przypadku dostaje status 'wykonywana')
   exec('status_update','px_poz',PX_POZ.ref(),_buf_wyk);
   exec('px_cup_update','px_cup',PX_POZ.PX_CUP);
   exec('proc_wyk_update','px_obj',PX_POZ.PX_OBJ)
?};
PX_POZ.cntx_pop();
PX_WYK.cntx_pop();
PX_POZ.get();
~~


\px_wyk_wyk_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed wyświetleniem pola PX_WYK.CAP_WYK*
::----------------------------------------------------------------------------------------------------------------------
_dim:=#(cur_afld()+1);

{? PX_KONT.IL_WYM<_dim
|| _result:=exec('color_noavail','px_param');
   PX_WYK.efld_opt('RED','label_color='+((_result*',')-_result),,'CAP_WYK'+$_dim);
   PX_WYK.efld_opt('SZUK','label_color='+((_result*',')-_result),,'CAP_WYK'+$_dim)
|| _result:='';
   PX_WYK.efld_opt('RED','label_color=',,'CAP_WYK'+$_dim);
   PX_WYK.efld_opt('SZUK','label_color=',,'CAP_WYK'+$_dim)
?};
_result


\px_wyk_wyk_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed redakcja pola PX_WYK.CAP_WYK*
::----------------------------------------------------------------------------------------------------------------------
_dim:=#(cur_afld()+1);

{? PX_KONT.IL_WYM<_dim
|| _result:=0
|| _result:=1
?};
_result


\px_wyk_wyk_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Po redakcji pola PX_WYK.CAP_WYK*
::----------------------------------------------------------------------------------------------------------------------
{? fld()<0 || FUN.emsg('Proszę wpisać wartość nieujemną.'@); 0 || 1 ?}


\px_wyk_wyk_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Format wyswietlania pola PX_WYK.CAP_WYK*
::----------------------------------------------------------------------------------------------------------------------
_dim:=#(cur_afld()+1);

{? PX_KONT.IL_WYM<_dim
||
   _result:='empty=1'
||
   _result:='empty=0,out_prec='+$($('PX_KONT.PREC'+$_dim))()
?};
_result


\px_wyk_wyk_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Format redagowania pola PX_WYK.CAP_WYK*
::----------------------------------------------------------------------------------------------------------------------
_dim:=#(cur_afld()+1);
'in_prec='+$($('PX_KONT.PREC'+$_dim))()


\px_cup_wykon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Rejestracja wykonania dla pojemnika planu
::       Kontekst - pojemnik planu (PX_CUP)
::   WE: [_a] - INTEGER - 0/[1] - czy wykonywać odświeżanie kafelków
::----------------------------------------------------------------------------------------------------------------------
_kafelki_reload:=1;
{? var_pres('_a')=type_of(0)
|| _kafelki_reload:=_a
?};

{? exec('get','#params',500613,2)='N'
|| exec('no_enabled','px_wyk');
   return('')
?};

{? exec('chk_role','#b__box',OPERATOR.USER,'TTE_WYK_DWPS')=0
|| exec('no_auth','px_wyk');
   return('')
?};

{? exec('px_cup_wykon_b','px_prepq')
||
   _ver:=exec('get','#params',8761,2,OPERATOR.USER);
   {? _ver='T'
   || FUN.info('Szczegółowa rejestracja wykonań dostępna tylko od strony pozycji planu.'@)
   || {? FUN.ask('Czy zarejestrować pełne wykonanie wszystkich pozycji planu?'@)
      || PX_POZ.cntx_psh();
         PX_POZ.index('LP');
         PX_POZ.prefix(PX_CUP.ref());

::       Zapamietuje wszystkie pozycje planu do obrobienia, poniewaz wykonanie jakiejkolwiek
::       z powodu nadwykonan moze zmienic mi dziedzine - na ten pojemnik na ktorym
::       stoje moga wpasc inne pozycje planu ktorych na razie nie chcielibysmy rejestrowac
         _ref_table:=exec('ref_table','#table');
         {? PX_POZ.first()
         || {!
            |? _ref_table.r_add(PX_POZ.ref());
               PX_POZ.next()
            !}
         ?};
         VAR.GRUPA:='T';
         VAR_DEL.delete('__Grp');
         __Grp:=obj_new('TAB','add');
         __Grp.TAB:=tab_tmp(1,'REF','STRING[16]','$PX_GRP.ref()');
         __Grp.add:=".TAB.prefix(_a); {? ~.TAB.first() || .TAB.REF:=_a; .TAB.add() ?}; .TAB.clear()";

::       Rejestruje zapamietane pozycje
         {? _ref_table.tab.first()
         || {!
            |?
               PX_POZ.clear();
               {? PX_POZ.seek(_ref_table.tab.REF,)
               || exec('px_poz_wykon','px_wyk',0,_kafelki_reload)
               ?};
               _ref_table.tab.next()
            !}
         ?};
::       przeplanowanie grup, o ile wymagane
         _grp:=__Grp.TAB;
         {? _grp.first()
         || _argsfast:=exec('fast_replan_a','px_logix');
            _argsfast.MOD_START:=1;
            {!
            |? _argsfast.PX_GRP:=exec('FindAndGet','#table',PX_GRP,_grp.REF,,"ref()",null());
               exec('grp_fast_replan','px_logix',_argsfast);
               _grp.next()
            !}
         ?};
         VAR.GRUPA:='N';
         VAR_DEL.delete('__Grp');
         PX_POZ.cntx_pop()
      ?}
   ?}
?};
exec('px_cup_wykon_a','px_prepq');
win_disp();
''


\clone_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Tablica parametrow dla clone
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('SOURCE',
               'PX_VER',
               'PX_POZ'
               );
_args.SOURCE:=null();
_args.PX_VER:=null();
_args.PX_POZ:=null();
_args


\clone
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Klonuje wykonanie
::   WE: _args - argumenty funkcji - wynik dzialania exec('clone_a','px_wyk')
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_args:={?_=1 || _a || exec('clone_a','px_wyk') ?};
_result:=0;

PX_WYK.cntx_psh();
PX_WYK.clear();
:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

{? PX_WYK.seek(_args.SOURCE)
||
   PX_OBJ.cntx_psh();
   {? PX_WYK.PX_POZ().PX_OBJ<>null()
   || PX_OBJ.use(8+$PX_WYK.PX_POZ().PX_OBJ)
   ?};
   PX_OBJ.clear();
   _what:=$PX_WYK.ref();
   PX_OBJ.cntx_pop();
   _msg:='Duplikowanie wykonania: %1'@[_what];
   pxkomm.sect_beg(_msg);
:: dodaje tylko jesli wszystkie kluczowe powiazania rozne od null
   {? _args.PX_VER<>null() &
      _args.PX_POZ<>null()
   ||
      PX_WYK.PX_VER:=_args.PX_VER;
      PX_WYK.PX_POZ:=_args.PX_POZ;
      PX_WYK.PX_OBJ:=PX_WYK.PX_POZ().PX_OBJ;
      _result:=PX_WYK.add();
      {? _result=0
      || _msg:='Nie udało się dodanie wykonania: %1'@[_what];
         pxkomm.error(_msg)
      ?}
   ?};
   pxkomm.sect_end()
|| _msg:='Nie znaleziono wykonania pozycji planu do duplikowania: %1'@[$_args.SOURCE];
   pxkomm.error(_msg)
?};
PX_WYK.cntx_pop();
_result


\delete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Usuwa wykonanie
::   WE: _a - PX_WYK.ref()
::       _b - INTEGER - 0/[1] - czy wykonywac caly update PX_POZa po usunieciu PX_WYKa,
::                      czy tylko update obiektu i pojemnika
::       [_c] - obj_new() - bufor usuwanego PX_WYKa
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_wyk:=_a;

_poz_update:=1;
{? var_pres('_b')=type_of(0)
|| _poz_update:=_b
?};

{? var_pres('_c')>100
|| _buffer:=_c
|| _buffer:=exec('PX_WYK','buffer1')
?};

_result:=0;

PX_GRP.cntx_psh();
PX_OBJ.cntx_psh();
PX_POZ.cntx_psh();
PX_WYK.cntx_psh();
PX_WYK.clear();
_pxpoz:=null();
_pxcup:=null();
_pxobj:=null();

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

{? PX_WYK.seek(_wyk)
|| _what:=PX_WYK.PX_POZ().PX_OBJ().SYMBOL+' '+PX_WYK.PX_POZ().PX_GRP().SYMBOL;
   _msg:='Usuwanie wykonania pozycji planu: '+_what;
   pxkomm.sect_beg(_msg);
   _result:=(PX_WYK.AUTOPL='N' & PX_WYK.AUTOZL='N');
:: Sparametryzowac te formule, zeby uwzgledniala autozapisy ale tylko w watku planowania
   _result:=1;
   {? _result=0
   || _msg:='Nie można usunąć automatycznego wykonania pozycji planu: %1'@[_what];
      pxkomm.error(_msg)
   || _pxpoz:=PX_WYK.PX_POZ;
      _pxcup:=PX_WYK.PX_POZ().PX_CUP;
      _pxobj:=PX_WYK.PX_OBJ;
      _result:=PX_WYK.del(,1)
   ?};
   {? _result=0
   || _msg:='Nie udało się usunięcie wykonania pozycji planu: %1'@[_what];
      pxkomm.error(_msg)
   ?};
   pxkomm.sect_end()
|| _msg:='Nie znaleziono wykonania: %1'@[$_wyk];
   pxkomm.error(_msg)
?};
{? _result>0
|| {? _poz_update>0
   ||
::    Wykonuje powolna aktualizacje PX_POZa, pojemnika i obiektu
      exec('px_poz_update','px_wyk',_pxpoz,_buffer)
   ||
::    Wykonuje aktualizacje pojemnika i obiektu
      exec('px_cup_update','px_cup',_pxcup);
      exec('proc_wyk_update','px_obj',_pxobj)
   ?}
?};
PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
PX_WYK.cntx_pop();
PX_POZ.cntx_pop();
_result


\px_obj_wykony
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Rejestracja wykonan planu w widoku wg obiektow
::----------------------------------------------------------------------------------------------------------------------
PX_VAR.VIE_VER:=exec('get_mainversion','px_ver');
PX_VAR.EDIT:=1;

PX_OBJ.win_sel('WYK');

_px_obj:=exec('obj_find_used','px_obj',PX_VAR.VIE_VER,null());

PX_OBJ.index('SYMBOL');
PX_OBJ.clear();
PX_OBJ.f_set('SYMBOL',,'PX_OBJ.REFERENCE in (select SQLREF from :_a)',_px_obj);
PX_OBJ.select(,,,'s');
PX_OBJ.f_clear();
~~


\px_kont_wykony
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Rejestracja wykonan planu w widoku wg kontenerow (zasobow)
::----------------------------------------------------------------------------------------------------------------------
PX_VAR.VIE_VER:=exec('get_mainversion','px_ver');
PX_VAR.EDIT:=1;

PX_KONT.win_sel('WYK');

PX_KONT.index('ACT');
PX_KONT.prefix('T',exec('get_mainversion','px_ver'));
PX_KONT.select(,,,'s');
~~


\move
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Przepina PX_WYK z jednego PX_POZA na inny
::   WE: _a - PX_WYK.ref() - wykonanie do przepiecia
::       _b - PX_POZ.ref() - pozycja planu do ktorej przypiac
::       [_c] - INTEGER:  0  - nie wykonywac funkcji aktualizujacej PX_POZa
::                       [1] - wykonywac funkcje aktualizujaca PX_POZa
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_wyk:=_a;
_dest:=_b;
_do_update:=1;

{? var_pres('_c')=type_of(0)
|| _do_update:=_c
?};

_result:=0;
PX_WYK.cntx_psh();
PX_POZ.cntx_psh();
PX_POZ.clear();
PX_WYK.clear();
{? PX_WYK.seek(_px_wyk)
|| _old_poz:=PX_WYK.PX_POZ;
   {? PX_POZ.seek(_dest)
   || PX_WYK.PX_VER:=PX_POZ.PX_VER;
      PX_WYK.PX_POZ:=PX_POZ.ref();
      _result:=PX_WYK.put()
   ?}
?};
{? _result>0 & _do_update>0
|| exec('px_poz_update','px_wyk',_dest);
   exec('px_poz_update','px_wyk',_old_poz)
?};
PX_WYK.cntx_pop();
PX_POZ.cntx_pop();
PX_WYK.get();
_result


\split_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Tablica parametrów dla split
::   WY: _args:=obj_new('SRC_WYK',
::                      'DST_POZ');
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('SRC_WYK',
               'DST_POZ');
_args.SRC_WYK:=null();
_args.DST_POZ:=null();
_args


\split
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dzieli PX_WYK na dwa kawalki
::   WE: _a: _args - wynik formuly exec('split_a','px_wyk')
::       _b - obj_new() - tablica z proporcjami ilosci ktore maja pozostac na 'starym' kawalku
::   WY: null() - dzielenie zakonczone niepowodzeniem
::       PX_WYK.ref() - ref do nowo utworzonego kawalka
::----------------------------------------------------------------------------------------------------------------------
_args:={?_>=1 || _a || exec('split_a','px_wyk') ?};

{? var_pres('_b')=type_of(obj_new(1))
|| _ilosci:=_b
?};

_can_continue:=0;
PX_WYK.cntx_psh();
PX_POZ.cntx_psh();
PX_KONT.cntx_psh();
PX_WYK.clear();
{? PX_WYK.seek(_args.SRC_WYK)
||
   _il_wym:=PX_WYK.PX_POZ().PX_KONT().IL_WYM;

:: zapamietuje ilosci jakie miala stara pozycja
   _wyk_old:=exec('count_wyk','px_wyk',PX_WYK.ref());
   _wyk_new:=exec('array_copy','#array',_wyk_old);

:: modyfikuje ilosci starej pozycji
   {! _it:=1.._il_wym
   |! ($('_il:=_a;PX_WYK.CAP_WYK'+$_it+':=_a'))(_ilosci[_it])
   !};
   _can_continue:=PX_WYK.put();
   {? _can_continue>0
   ||
::    Tworze nowe wykonanie na podstawie starego
      _can_continue:=PX_WYK.add();
      {? _can_continue>0
      ||
::       Nowemu przypisuje ilosci ktore sa roznica starego przed i po modyfikacji
         exec('arrays_sub_mod','#array',_wyk_new,_ilosci);
         {! _it:=1.._il_wym
         |! ($('_il:=_a;PX_WYK.CAP_WYK'+$_it+':=_a'))(_wyk_new[_it])
         !};
         PX_WYK.put();

::       Jesli podana pozycja planu do ktorej podpiac nowe wykonanie to od razu podpinam
         {? _args.DST_POZ<>null()
         || exec('move','px_wyk',PX_WYK.ref(),_args.DST_POZ,1)
         ?}
      ?}
   ?}
?};
PX_KONT.cntx_pop();
PX_POZ.cntx_pop();
PX_WYK.cntx_pop();
PX_WYK.get();
~~


\count_wyk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca ilosci dla wykonania w wygodnej do przetwarzania tablicy
::   WE: _a - PX_WYK.ref() - wykonanie ktorego ilosci zwrocic
::   WY: obj_new(x) - wynikowa tablica z obliczonymi ilosciami
::----------------------------------------------------------------------------------------------------------------------
_px_wyk:=_a;
_result:=obj_new(1);
_result[1]:=0;

PX_WYK.cntx_psh();
PX_POZ.cntx_psh();
PX_KONT.cntx_psh();

PX_WYK.clear();
{? PX_WYK.seek(_px_wyk)
|| obj_del(_result);
   _il_wym:=PX_WYK.PX_POZ().PX_KONT().IL_WYM;
   _result:=obj_new(_il_wym);
   {! _it:=1..._il_wym
   |! _result[_it]:=($('PX_WYK.CAP_WYK'+$_it))()
   !}
?};

PX_KONT.cntx_pop();
PX_POZ.cntx_pop();
PX_WYK.cntx_pop();
_result


\px_wyk_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Walidacja okna wprowadzania wykonania
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(PX_WYK,,'DATA','PLACE');
{? _chk=''
|| {? ~exec('valid_time','#field',PX_WYK.CZAS)
   ||
      'CZAS'
   || {? exec('FindAndGet','#table',PX_POZ,PX_WYK.PX_POZ,,,null())=null()
      || FUN.info('Nie znaleziono pozycji planu.'@);
         return(0)
      ?};
      _cap_wyk:=exec('cap_wyk','px_wyk');
      _sum:=exec('array_sum','#array',_cap_wyk);
      {? _sum=0
      || FUN.info('Wykonanie w co najmniej jednym wymiarze musi być większe od zera.'@);
         'CAP_WYK1'
      || 1
      ?}
   ?}
|| _chk
?}


\px_plan_wykony
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Rejestracja wykonań produkcji - dla planu strategicznego
::----------------------------------------------------------------------------------------------------------------------
{? exec('chk_role','#b__box',OPERATOR.USER,'TTE_WYK_DWPS')=0 | exec('get','#params',500613,2)='N'
|| exec('no_auth','px_wyk');
   return()
?};

_args:=exec('rejestracja_a','prod_rej');
_args.F_NAWIG:=1;
_args.F_FILTER:=1;
_args.F_WYKON:=1;
_args.F_XWYKON:=1;
_args.F_REJ:=1;
_args.FILTR_PX:=1;
_args.ED_DATA:=1;
_args.ED_RES:=1;
_args.ED_M:=1;
_args.ED_OPIS:=1;
_args.ED_OK:=1;
_args.ED_PX:=1;
exec('rejestracja','prod_rej',_args);
~~


\fields_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ustala wartosci pol PROD_REJ zalezne od innych pol
::       Do uzycia w formulach exec('update_4rej','px_wyk'), exec('load_4rej','px_wyk')
::----------------------------------------------------------------------------------------------------------------------
PROD_REJ.OPIS:=PX_POZ.PX_OBJ().SYMBOL+' - '+PX_POZ.STATUS+' - '+PX_POZ.PX_STAGE().NAZWA;
PROD_REJ.OPER:='['+$PROD_REJ.STARTD+' '+$PROD_REJ.STARTT+'] '+PROD_REJ.OPIS;
~~


\update_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Aktualizacja tabel PROD_REJ i PROD_NXT na podstawie zmian w tabelach PX_POZ, PX_WYK (obsluga triggerow)
::   WE: _a - rodzaj triggera: 'add', 'put', 'del'
::       _b - tabela: PX_POZ, PX_WYK
::   WY: wynik sterujacy dla triggera, czyli ~~ albo 0/1
::----------------------------------------------------------------------------------------------------------------------
{? _b=PX_POZ
|| {? _a='add'
   ||
::    Pozycje "rodzą" się ze statusem normalnym, więc dodajemy wszystkie nowe z wersji głównej planu
::    z pominięceim pozycji z planu operacyjnego
      {? PX_POZ.PX_VER=exec('get_mainversion','px_ver') & PX_POZ.PL_OPER=null() & PX_POZ.PL_OGR=null() & PX_POZ.PX_OBJ().REM_ZGL=null()
      ||
         Cntx.psh(PROD_REJ,PROD_NXT,PX_CUP,PX_OBJ,PL_OPER,ZGP,GROP,GROPS);
         Cntx.clr(PROD_REJ,PROD_NXT);

         _stat:=exec('statusy','px_poz');

         PROD_REJ.blank(1);
         PROD_REJ.STARTD:=exec('tm_stamp2date','#tm_stamp',PX_POZ.TM_START);
         PROD_REJ.STARTT:=exec('tm_stamp2time','#tm_stamp',PX_POZ.TM_START);
         PROD_REJ.ENDD:=exec('tm_stamp2date','#tm_stamp',PX_POZ.TM_END);
         PROD_REJ.ENDT:=exec('tm_stamp2time','#tm_stamp',PX_POZ.TM_END);
         exec('fields_4rej','px_wyk');
         PROD_REJ.PRIORITY:='N';
         PROD_REJ.SRODZ:='PX';
         PROD_REJ.SOURCE:=$PX_POZ.ref();
         PROD_REJ.PX_POZ:=PX_POZ.ref();
         PROD_REJ.PL_OPER:=PX_POZ.PL_OPER;
         PROD_REJ.PL_OGR:=PX_POZ.PL_OGR;
         PROD_REJ.ZL:=PX_POZ.PX_OBJ().ZL;
         PROD_REJ.M:=PX_OBJ.M;
         PROD_REJ.GROP:=PX_POZ.PX_GRP().GROPS().GROP;
         PROD_REJ.GROPS:=GROPS.ref();
         PROD_REJ.RES_SYM:=PX_POZ.PX_KONT().SYMBOL;
         PROD_REJ.RES_NAZ:=PX_KONT.NAZWA;
         PROD_REJ.WYD:=exec('szukaj_ud_skl','schemat','PODZORG',PX_KONT.PL_RES().WYD);
         PROD_REJ.KONTROLA:=exec('is_kontrol','px_stage',PX_POZ.PX_STAGE);
         PROD_REJ.KJ_BAD:=exec('is_kj_bad','px_stage',PX_POZ.PX_STAGE);
         PROD_REJ.RP:=exec('is_rp','px_stage',PX_POZ.PX_STAGE);
::       Jeżeli jest wymiar zgodny z JM produktu, to z niego, w przeciwnym wypadku pierwszy wymiar
         _jm:=null();
         _dim:=1;
         {! _it:=1..PX_KONT.IL_WYM
         |! _jm:=PX_KONT.JM1;
            {? ($('PX_KONT.JM'+$_it))()=PROD_REJ.M().J || _dim:=_it; _jm:=PROD_REJ.M().J ?}
         !};
         PROD_REJ.JM:=_jm;
         PROD_REJ.START:='N';
         PROD_REJ.POTW:='N';
         PROD_REJ.PROBLEM:=PX_POZ.PROBLEM;
         PROD_REJ.PROBKLAS:=PX_POZ.PROBKLAS;
         PROD_REJ.PRAC:='N';
         PROD_REJ.BRYG:='N';
         PROD_REJ.KOOP:=PX_POZ.KOOP;
         PROD_REJ.ILC:=($('PX_POZ.CAP_EAT'+$_dim))();
         PROD_REJ.IL:=PROD_REJ.ILC-($('PX_POZ.CAP_WYK'+$_dim))();
         PROD_REJ.ILW:=($('PX_POZ.CAP_WYK'+$_dim))();
         PROD_REJ.A:={? PX_POZ.STATUS=_stat.NORMAL |
                        PX_POZ.STATUS=_stat.WYK1 |
                        PX_POZ.STATUS=_stat.WYK2 |
                        PX_POZ.STATUS=_stat.DELAY
                     || 'T'
                     || 'N'
                     ?};
         PROD_REJ.OK:={? PX_POZ.STATUS=_stat.WYK2 || 'T' || 'N' ?};
         PROD_REJ.DOREJ:={? PX_POZ.STATUS=_stat.NORMAL |
                            PX_POZ.STATUS=_stat.WYK1 |
                            PX_POZ.STATUS=_stat.DELAY
                         || 'T'
                         || 'N'
                         ?};
         {? PROD_REJ.add(1)
         || exec('uzup_prod_nxt','px_wyk');
            exec('uzup_znaczniki','px_wyk',PROD_REJ.ref())
         ?};

         Cntx.pop(PROD_REJ,PROD_NXT,PX_CUP,PX_OBJ,PL_OPER,ZGP,GROP,GROPS)
      ?};
      ~~
   |? _a='put'
   ||
::    Jezeli zmiana dotyczy PX_POZ.UPD_SUR - wywolanie z exec('generuj_ver','px_sur') - pomijamy calosc
      {? bfld('UPD_SUR')<>PX_POZ.UPD_SUR || return() ?};

::    Jezeli zmiana dotyczy PX_POZ.PX_SET - poprawianie powiazan zasobu z zestawem - pomijamy calosc
      {? bfld('PX_SET')<>PX_POZ.PX_SET || return() ?};

::    Jeżeli zmiana dotyczy pozycji z planu operacyjnego - pomijamy całość
      {? bfld('PL_OPER')<>null() | bfld('PL_OGR')<>null() || return() ?};

      Cntx.psh(PROD_REJ,PX_CUP,PX_OBJ,PL_OPER,ZGP);

      _stat:=exec('statusy','px_poz');

      PROD_REJ.index('PX_POZ');
      PROD_REJ.prefix('PX',PX_POZ.ref());
      {? PROD_REJ.first()
      ||
         PROD_REJ.STARTD:=PX_POZ.PX_CUP().STARTD().DATA;
         PROD_REJ.STARTT:=PX_CUP.STARTT;
         PROD_REJ.ENDD:=PX_CUP.ENDD().DATA;
         PROD_REJ.ENDT:=PX_CUP.ENDT;
         exec('fields_4rej','px_wyk');
         PROD_REJ.ZL:=PX_POZ.PX_OBJ().ZL;
         PROD_REJ.PL_OPER:=PX_POZ.PL_OPER;
         PROD_REJ.PL_OGR:=PX_POZ.PL_OGR;
         PROD_REJ.M:=PX_OBJ.M;
         PROD_REJ.KONTROLA:=exec('is_kontrol','px_stage',PX_POZ.PX_STAGE);
         PROD_REJ.KJ_BAD:=exec('is_kj_bad','px_stage',PX_POZ.PX_STAGE);
::       Jezeli jest wymiar zgodny z JM produktu, to z niego, w przeciwnym wypadku pierwszy wymiar
         _jm:=null();
         _dim:=1;
         {! _it:=1..PX_KONT.IL_WYM
         |! _jm:=PX_KONT.JM1;
            {? ($('PX_KONT.JM'+$_it))()=PROD_REJ.M().J || _dim:=_it; _jm:=PROD_REJ.M().J ?}
         !};
         PROD_REJ.JM:=_jm;
         PROD_REJ.ILC:=($('PX_POZ.CAP_EAT'+$_dim))();
         PROD_REJ.IL:=PROD_REJ.ILC-($('PX_POZ.CAP_WYK'+$_dim))();
         {? PROD_REJ.IL<0 || PROD_REJ.IL:=0 ?};
         PROD_REJ.ILW:=($('PX_POZ.CAP_WYK'+$_dim))();
         PROD_REJ.A:={? PX_POZ.STATUS=_stat.NORMAL |
                        PX_POZ.STATUS=_stat.WYK1 |
                        PX_POZ.STATUS=_stat.WYK2 |
                        PX_POZ.STATUS=_stat.DELAY
                     || 'T'
                     || 'N'
                     ?};
         PROD_REJ.OK:={? PX_POZ.STATUS=_stat.WYK2 || 'T' || 'N' ?};
         PROD_REJ.DOREJ:={? PX_POZ.STATUS=_stat.NORMAL |
                            PX_POZ.STATUS=_stat.WYK1 |
                            PX_POZ.STATUS=_stat.DELAY
                         || 'T'
                         || 'N'
                         ?};
         PROD_REJ.PROBLEM:=PX_POZ.PROBLEM;
         PROD_REJ.PROBKLAS:=PX_POZ.PROBKLAS;
         {? PROD_REJ.put(1)
         || exec('uzup_prod_nxt','px_wyk');
            exec('uzup_znaczniki','px_wyk',PROD_REJ.ref())
         ?}
      ?};

      Cntx.pop(PROD_REJ,PX_CUP,PX_OBJ,PL_OPER,ZGP);
      ~~
   |? _a='del'
   ||
      Cntx.psh(PROD_REJ);

      PROD_REJ.index('PX_POZ');
      PROD_REJ.prefix('PX',PX_POZ.ref());
      {? PROD_REJ.first()
      ||
         PROD_NXT.index('PROD_REJ');
         PROD_NXT.prefix(PROD_REJ.ref());
         {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};

         PROD_NXT.index('NEXT');
         PROD_NXT.prefix(PROD_REJ.ref());
         {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};

         PROD_REJ.del()
      ?};
      _res:=~PROD_REJ.first();

      Cntx.pop(PROD_REJ);
      _res
   ||
      ~~
   ?}

:: UWAGA: PX_WYK aktualizuje wyłącznie pola PROD_REJ.START
|? _b=PX_WYK
||
   {? _a='add'
   || PROD_REJ.cntx_psh();
      PROD_REJ.index('PX_POZ');
      PROD_REJ.prefix('PX',PX_WYK.PX_POZ);
      {? PROD_REJ.first()
      || {? PX_WYK.ZAK='T' || PROD_REJ.START:='N' || PROD_REJ.START:='T' ?};
         PROD_REJ.put()
      ?};
      PROD_REJ.cntx_pop();
      ~~
   |? _a='put'
   || PROD_REJ.cntx_psh();
      PROD_REJ.index('PX_POZ');
      PROD_REJ.prefix('PX',PX_WYK.PX_POZ);
      {? PROD_REJ.first()
      || {? PX_WYK.ZAK='T' || PROD_REJ.START:='N' || PROD_REJ.START:='T' ?};
         PROD_REJ.put()
      ?};
      PROD_REJ.cntx_pop();
      ~~
   |? _a='del'
   || PROD_REJ.cntx_psh();
      PROD_REJ.index('PX_POZ');
      PROD_REJ.prefix('PX',PX_WYK.PX_POZ);
      {? PROD_REJ.first()
      || PROD_REJ.START:='N';
         PROD_REJ.put()
      ?};
      PROD_REJ.cntx_pop();
      1
   ||
      ~~
   ?}
|| ~~
?}


\load_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ładuje/aktualizuje dane w tabeli do rejestracji wykonań - plan strategiczny
::       Funkcja służy tylko do zainicjowania danych - na bieżąco działają triggery
::----------------------------------------------------------------------------------------------------------------------
:: Funkcja ładująca dane z planu strategicznego
_add:="
   _status:=_a;

   _stat:=exec('statusy','px_poz');

   PX_POZ.index('VSTATUS');
   PX_POZ.prefix(exec('get_mainversion','px_ver'),_a);
   {? PX_POZ.first()
   || {!
      |? {? PX_POZ.PL_OPER=null() & PX_POZ.PL_OGR=null() & PX_POZ.PX_OBJ().REM_ZGL=null()
         || PROD_REJ.blank(1);
            PROD_REJ.STARTD:=exec('tm_stamp2date','#tm_stamp',PX_POZ.TM_START);
            PROD_REJ.STARTT:=exec('tm_stamp2time','#tm_stamp',PX_POZ.TM_START);
            PROD_REJ.ENDD:=exec('tm_stamp2date','#tm_stamp',PX_POZ.TM_END);
            PROD_REJ.ENDT:=exec('tm_stamp2time','#tm_stamp',PX_POZ.TM_END);
            exec('fields_4rej','px_wyk');
            PROD_REJ.PRIORITY:='N';
            PROD_REJ.SRODZ:='PX';
            PROD_REJ.SOURCE:=$PX_POZ.ref();
            PROD_REJ.PX_POZ:=PX_POZ.ref();
            PROD_REJ.PL_OPER:=PX_POZ.PL_OPER;
            PROD_REJ.PL_OGR:=PX_POZ.PL_OGR;
            PROD_REJ.ZL:=PX_POZ.PX_OBJ().ZL;
            PROD_REJ.M:=PX_POZ.PX_OBJ().M;
            PROD_REJ.GROP:=PX_POZ.PX_GRP().GROPS().GROP;
            PROD_REJ.GROPS:=GROPS.ref();
            PROD_REJ.RES_SYM:=PX_POZ.PX_KONT().SYMBOL;
            PROD_REJ.RES_NAZ:=PX_KONT.NAZWA;
            PROD_REJ.WYD:=exec('szukaj_ud_skl','schemat','PODZORG',PX_KONT.PL_RES().WYD);
            PROD_REJ.KONTROLA:=exec('is_kontrol','px_stage',PX_POZ.PX_STAGE);
            PROD_REJ.KJ_BAD:=exec('is_kj_bad','px_stage',PX_POZ.PX_STAGE);
            PROD_REJ.RP:=exec('is_rp','px_stage',PX_POZ.PX_STAGE);
::          Jezeli jest wymiar zgodny z JM produktu, to z niego, w przeciwnym wypadku pierwszy wymiar
            _jm:=null();
            _dim:=1;
            {! _it:=1..PX_KONT.IL_WYM
            |! _jm:=PX_KONT.JM1;
               {? ($('PX_KONT.JM'+$_it))()=PROD_REJ.M().J || _dim:=_it; _jm:=PROD_REJ.M().J ?}
            !};
            PROD_REJ.JM:=_jm;
            PROD_REJ.ILC:=($('PX_POZ.CAP_EAT'+$_dim))();
            PROD_REJ.IL:=PROD_REJ.ILC-($('PX_POZ.CAP_WYK'+$_dim))();
            {? PROD_REJ.IL<0 || PROD_REJ.IL:=0 ?};
            PROD_REJ.ILW:=($('PX_POZ.CAP_WYK'+$_dim))();
            PX_WYK.index('ZAK2');
            PX_WYK.prefix('N',PX_POZ.ref());
            {? PX_WYK.first() || _start:='T' || _start:='N' ?};
            PROD_REJ.START:=_start;
            PROD_REJ.OK:={? _status=_stat.WYK2 || 'T' || 'N' ?};
            PROD_REJ.POTW:='N';
            PROD_REJ.PROBLEM:=PX_POZ.PROBLEM;
            PROD_REJ.PROBKLAS:=PX_POZ.PROBKLAS;
            PROD_REJ.PRAC:='N';
            PROD_REJ.BRYG:='N';
            PROD_REJ.KOOP:=PX_POZ.KOOP;
            PROD_REJ.A:='T';
            PROD_REJ.DOREJ:={? _status=_stat.NORMAL | _status=_stat.DELAY | _status=_stat.WYK1 || 'T' || 'N' ?};
            {? PROD_REJ.add(1)
            || exec('uzup_prod_nxt','px_wyk')
            ?}
         ?};
         PX_POZ.next()
      !}
   ?};
   PX_POZ.clear()
";

{? FUN.ask('Czy zainicjować ponownie tabelę do rejestracji produkcji dla planu strategicznego?'@)
||
   exec('del_4rej','px_wyk');

   Cntx.psh(PROD_REJ,PROD_NXT);
   Cntx.clr(PROD_REJ,PROD_NXT);

:: Ladujemy wszystkie pozycje planu strategicznego wg statusow (mozna uzyc nie wszystkie)
   _stat:=exec('statusy','px_poz');
:: - normalne
   _add(_stat.NORMAL);
:: - zablokowane
   _add(_stat.BLK);
:: - opoznione
   _add(_stat.DELAY);
:: - porzucone
   _add(_stat.SKIPPED);
:: - wykonane czesciowo
   _add(_stat.WYK1);
:: - wykonane w calosci
   _add(_stat.WYK2);

:: Uzupelnienie/zmiana znacznikow z uwglednieniem powiazan miedzy operacjami
   PROD_REJ.index('PX_POZ');
   PROD_REJ.prefix('PX');
   {? PROD_REJ.first()
   || {!
      |? exec('uzup_znaczniki','px_wyk',PROD_REJ.ref());
         PROD_REJ.next()
      !}
   ?};

   Cntx.pop(PROD_REJ,PROD_NXT);
   FUN.info('Zainicjowano tabelę do rejestracji produkcji dla planu strategicznego.'@)
?};
''


\display_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsluga 'wyswietl' w oknie rejestracji wykonan - plan strategiczny
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(PX_POZ,PX_OBJ,ZK_N,ZK_P);

PROD_REJ.PX_POZ().PX_OBJ();

:: Przelaczenie maski zamowienia
_cur_zkn:=ZK_N.name();
_new_zkn:=ref_name(PX_OBJ.ZK_N);
_new_zkp:=ref_name(PX_OBJ.ZK_P);
{? _new_zkn<>'' & _cur_zkn<>_new_zkn
||
:: otwieram maske ZK_N i ZK_P odpowiadajace aktualnie przetwarzanemu ZK_N i ZK_P
   ZK_N.use(_new_zkn);
   ZK_P.use(_new_zkp)
?};

{? VEK.TERM='T'
|| exec('uni_display','#desktop',PX_POZ,'EK','Pozycja planu'@,0,0,'pxplan','maximized')
|| PX_POZ.win_edit('RED');
   PX_POZ.display()
?};

Cntx.pop(PX_POZ,PX_OBJ,ZK_N,ZK_P);
~~


\mat_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Informacja o materiałach wyświetlana z poziomu rejestracji wykonań - plan strategiczny
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (plan strategiczny) funkcja \'Materiały\' nie jest obsługiwana.'@);
~~


\doc_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Informacja o dokumentach wyświetlana z poziomu rejestracji wykonań - plan strategiczny
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (plan strategiczny) funkcja \'Dokumentacja\' nie jest obsługiwana.'@);
~~


\npu_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.14]
:: OPIS: Informacja o NPU wyświetlana z poziomu rejestracji wykonań - plan strategiczny
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (plan strategiczny) funkcja \'N-P-U\' nie jest obsługiwana.'@);
~~


\prac_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Pracownik' w oknie rejestracji wykonań - plan strategiczny
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (plan strategiczny) funkcja \'Pracownik\' nie jest obsługiwana.'@);
~~


\bryg_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Brygada' w oknie rejestracji wykonań - plan strategiczny
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (plan strategiczny) funkcja \'Brygada\' nie jest obsługiwana.'@);
~~


\start_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Start' w oknie rejestracji wykonań - plan strategiczny
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (plan strategiczny) funkcja \'Start\' nie jest obsługiwana.'@);
0


\stop_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Stop' w oknie rejestracji wykonań - plan strategiczny
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (plan strategiczny) funkcja \'Stop\' nie jest obsługiwana.'@);
0


\rej_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obługa przycisku 'Rejestracje' w oknie rejestracji wykonań - plan strategiczny
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
::{? exec('get','#params',500633,2)='T' & PROD_REJ.DOREJ<>'T'
::|| FUN.info('Zapis niedostępny do rejestracji — najpierw należy zarejestrować operacje poprzedzające.');
::   return()
::?};

Cntx.psh(PX_POZ,PX_WYK,PX_KONT);
Cntx.clr(PX_POZ,PX_WYK);

:: Odnalezienie zrodlowego PX_POZ
{? PX_POZ.seek(PROD_REJ.PX_POZ)
||
   _px_poz:=PX_POZ.ref();
   _block:=exec('blk_lock','#table','PX_POZ',_px_poz,,1);
   {? _block
   ||
      PX_WYK.index('POZ');
      PX_WYK.prefix(PX_POZ.ref());
      PX_WYK.win_sel('WER1');
      PX_WYK.hdr_sel();
::   PX_WYK.hdr_sel(' — podgląd');
      _il_wym:=PX_POZ.PX_KONT().IL_WYM;
      _max_wym:=exec('il_wym','px_param');

      {! _it:=1.._max_wym
      |!
::       czyszczę nazwy kolumn
          _fml:='PX_WYK.fld_opt(\'WER1\',\'col_name=%1\'[\'\"\"\'],PX_WYK,\'CAP_WYK'+$_it+'\')';
         ($(_fml))()
      !};

      {! _it:=1.._il_wym
      |!
::         ($('PX_VAR.TITD'+$_it+':=PX_KONT.JM'+$_it+'().KOD+\' - \'+JM.NAZ'))();
         _fml:='PX_WYK.fld_opt(\'WER1\',\'col_name=%1\'[PX_KONT.JM'+$_it+'().KOD+\' - \'+JM.NAZ],PX_WYK,\'CAP_WYK'+$_it+'\')';
         ($(_fml))();
         PX_WYK.fld_attr('CAP_WYK'+$_it,,3);
         _format:=$("'out_prec="+$($('PX_POZ.PX_KONT().PREC'+$_it))()+"'");
         PX_WYK.win_fml('WER',,'CAP_WYK'+$_it,,'SUM_FORMAT',_format)
      !};
      {? _il_wym<_max_wym
      || {! _it:=_il_wym+1.._max_wym
         |! ($('PX_VAR.TITD'+$_it+':=\' - \''))();
            PX_WYK.fld_attr('CAP_WYK'+$_it,,2)
         !}
      ?};

      PX_WYK.win_edit('RED');
::   PX_WYK.select(,,,'DPU:D')
      PX_WYK.select(,,,'D:D');

      PROD_REJ.f_rfresh()
   ||
      exec('blk_comm','px_wyk',exec('blk_lock','#table','PX_POZ',_px_poz,,2))
   ?};
   exec('blk_unlock','#table','PX_POZ',_px_poz)
||
   FUN.error('Nie znaleziono pozycji planu.'@)
?};

Cntx.pop(PX_POZ,PX_WYK,PX_KONT);
~~


\wykon_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Wykonano' w oknie rejestracji wykonań - plan strategiczny
::       Kontekst pracy: PROD_REJ
::       Taka sama obsługa jak z poziomu pozycji planu
::   WY: jeżeli cała operacja zrealizowana - 1, wpp - 0
::----------------------------------------------------------------------------------------------------------------------
_res:=0;

{? PROD_REJ.A<>'T'
|| FUN.info('Zapis nieaktywny — nie można rejestrować wykonania.'@);
   return(_res)
?};

{? PROD_REJ.PROBLEM='T'
|| FUN.info('Zgłoszony problem — nie można rejestrować wykonania.'@);
   return(_res)
?};

{? PROD_REJ.OK='T'
|| FUN.info('Wykonanie operacji zostało już zarejestrowane.'@);
   return(_res)
?};

{? PROD_REJ.DOREJ<>'T'
|| FUN.info('Zapis niedostępny do rejestracji — najpierw należy zarejestrować operacje poprzedzające.'@);
   return(_res)
?};

Cntx.psh(PX_POZ,PX_WYK);
Cntx.clr(PX_POZ,PX_WYK);

:: Odnalezienie zrodlowego PX_POZ
{? PX_POZ.seek(PROD_REJ.PX_POZ)
||
   exec('px_poz_wykon','px_wyk');
   _res:=1
||
   FUN.error('Nie znaleziono pozycji planu.'@)
?};

Cntx.pop(PX_POZ,PX_WYK);

_res


\xwykon_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'wyYcofaj' w oknie rejestracji wykonań - plan strategiczny
::       Kontekst pracy: PROD_REJ
::   WY: 0
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (plan strategiczny) funkcja \'Wycofaj\' nie jest obsługiwana.'@);
0


\auto_px_wyk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Trigger aktualizujacy zapisy w PX_WYK na podstawie PL_WYK oraz ZLGD
::   WE: _a - rodzaj triggera: 'add', 'put', 'del'
::       _b - tabela: PL_WYK, ZLGD
::----------------------------------------------------------------------------------------------------------------------
{? _b=PL_WYK
||
   {? (_a='put' | _a='add') & PL_WYK.PL_OGR=null()
   ||
::    'add' - dodanie zapisu w PX_WYK, jezeli od razu ma "koniec" - PL_WYK.ENDD<>null()
::    'put' - zakonczenie operacji, czyli aktualizacja zapisu w PX_WYK,
::    pod warunkiem, ze PL_WYK dostaje "koniec" - PL_WYK.ENDD bylo null a juz nie jest.
      {? _a='add' & PL_WYK.ENDD<>null()
            |
         _a='put' & bfld('ENDD')=null() & PL_WYK.ENDD<>null()
      || _popraw:=0
      || _popraw:=1
      ?};

::    Dla _popraw najpierw usuniecie poprzednich zapisow
      {? _popraw
      ||
         _can_continue:=1;
         PX_WYK.index('PL_WYK');
         PX_WYK.prefix($PL_WYK.ref());
         {? PX_WYK.first()
         || {!
            |? _can_continue:=exec('delete','px_wyk',PX_WYK.ref());
               PX_WYK.next() & _can_continue>0
            !}
         ?};
         _can_continue:=~PX_WYK.first()
      ?};

      Cntx.psh(PX_WYK,PX_POZ,PX_KONT,PL_OPER,PL_OGR,PL_PART,ZL,ZK_P);
      Cntx.clr(PX_WYK,PX_POZ,PX_KONT);

      _px_obj:=exec('get_pxobj','po_wyk');

      {? _px_obj<>null()
      ||
::       Sprawdzam czy obiekt znajduje sie w kolejce planu strategicznego
         _mainver:=exec('get_mainversion','px_ver');

:: Warunek wyłączony - zawsze aktualizujemy pozycje planu strategicznego, żeby były "odhaczone"
::         {? exec('get_que_ilosc','px_obj',_px_obj,_mainver)>0
::         ||
::          Tworze PX_WYKi na podstawie PL_WYKa
            exec('gen4plwyk','px_wyk',PL_WYK.ref())

::          Uruchamiam obsluge nadwykonan
::            exec('nadwyk_obj_add','px_wyk',_px_obj)
::         ?}
      ?};

      Cntx.pop(PX_WYK,PX_POZ,PX_KONT,PL_OPER,PL_OGR,PL_PART,ZL,ZK_P);
      ~~
   |? _a='del'
   ||
::    'del' - skasowanie zapisu w PX_WYK - jak udane to 1, jak nie to 0
      Cntx.psh(PX_WYK,ZL);

      _can_continue:=1;

      PX_WYK.index('PL_WYK');
      PX_WYK.prefix($PL_WYK.ref());
      {? PX_WYK.first()
      || {!
         |? _can_continue:=exec('delete','px_wyk',PX_WYK.ref());
            PX_WYK.next() & _can_continue>0
         !}
      ?};

::      _px_obj:=exec('get_pxobj','po_wyk');

::      {? _px_obj<>null()
::      ||
::       Sprawdzam czy obiekt znajduje sie w kolejce planu strategicznego
::         _mainver:=exec('get_mainversion','px_ver');

::         {? exec('get_que_ilosc','px_obj',_px_obj,_mainver)>0
::         ||
::          Uruchamiam obsluge nadwykonan
::            exec('nadwyk_obj_del','px_wyk',_px_obj)
::         ?}
::      ?};

      _res:=~PX_WYK.first();
      {? ~_res || KOMM.add('Nie można usunąć powiązanych zapisów wykonania planu strategicznego.'@,,,1) ?};

      Cntx.pop(PX_WYK,ZL);
      _res
   ||
      ~~
   ?}
|? _b=ZLGD
||
   {? _a='add' | _a='put'
   || Cntx.psh(PX_WYK,PX_POZ,PX_KONT,ZL,ZGH,ZGP,PX_GRP,PX_CONN,GROP);
      Cntx.clr(PX_WYK,PX_POZ,PX_KONT);

      _can_continue:=1;

::    Dla put najpierw usuniecie poprzednich zapisow
      {? _a='put'
      ||
         PX_WYK.index('ZLGD');
         PX_WYK.prefix($ZLGD.ref());
         {? PX_WYK.first()
         || {!
            |? _can_continue:=exec('delete','px_wyk',PX_WYK.ref());
               PX_WYK.next() & _can_continue>0
            !}
         ?};
         _can_continue:=~PX_WYK.first()
      ?};

      {? ~_can_continue
      || KOMM.add('Nie można usunąć powiązanych zapisów wykonania planu strategicznego.'@,,,1)
      ||
         {? ZLGD.GROP=null()
         || ZLGD.ZL();
::          Czy zlecenie w planie strategicznym?
            _zl_src:=ZL.ref();
            _top_level:=exec('top_level','zl_link',_zl_src);
            {? exec('FindAndGet','#table',ZL,_top_level,,"RODZ_TEX='Z'",0)
            || _zl:=_top_level
            || _zl:=ZL.ref()
            ?};
            _pxed:=exec('zl_utilization','px_plan',_zl);
            {? _pxed=1
            ||
::             Tworze PX_WYKi na podstawie ZLGD
               exec('gen4zlgd','px_wyk',ZLGD.ref());
               _ploper:=exec('zlec_planned','po_plan',$_zl_src);
               {? _ploper=0 || _ploper:=exec('zlec_planned','po_plan',$_zl) ?};
               {? ZLGD.AUTO<>'T' & ZLGD.PL_WYK='' & _ploper=0
               ||
::                Uruchamiam obsluge nadwykonan ale tylko jesli ZLGD nie powstal na podstawie
::                PL_WYKa i zlecenie nie znajduje sie w planie operacyjnym
                  _zl_obj:=exec('get_zl_object','px_obj',_zl);
                  exec('nadwyk_obj_add','px_wyk',_zl_obj)
               ?}
            ?}
         || ZLGD.GROP();
::          Czy grupa operacji w planie strategicznym?
            {? GROP.PLAN_PX='T'
            ||
::             Tworze PX_WYKi na podstawie ZLGD
               exec('gen4zlgd','px_wyk',ZLGD.ref());
               {? ZLGD.AUTO<>'T' & ZLGD.PL_WYK='' & GROP.PLAN_PO<>'T'
               ||
::                Uruchamiam obsluge nadwykonan ale tylko jesli ZLGD ...
                  _grop_obj:=exec('get_grop_object','px_obj',GROP.ref());
                  exec('nadwyk_obj_add','px_wyk',_grop_obj)
               ?}
            ?}
         ?}
      ?};
      Cntx.pop(PX_WYK,PX_POZ,PX_KONT,ZL,ZGH,ZGP,PX_GRP,PX_CONN,GROP);
      ~~
   |? _a='del'
   ||
::    'del' - skasowanie zapisu w PX_WYK - jak udane to 1, jak nie to 0
      Cntx.psh(PX_WYK,ZL,PX_GRP,PX_CONN);
      _can_continue:=1;
      ZLGD.ZL();

      PX_WYK.index('ZLGD');
      PX_WYK.prefix($ZLGD.ref());
      {? PX_WYK.first()
      || {!
         |? _can_continue:=exec('delete','px_wyk',PX_WYK.ref());
            PX_WYK.next() & _can_continue>0
         !}
      ?};
      {?
::       Czy zlecenie w planie strategicznym?
         _zl_src:=ZL.ref();
         _top_level:=exec('top_level','zl_link',_zl_src);
         {? exec('FindAndGet','#table',ZL,_top_level,,"RODZ_TEX='Z'",0)
         || _zl:=_top_level
         || _zl:=ZL.ref()
         ?};
         _pxed:=exec('zl_utilization','px_plan',_zl);
         _pxed=1
      ||
         _ploper:=exec('zlec_planned','po_plan',$_zl_src);
         {? _ploper=0 || _ploper:=exec('zlec_planned','po_plan',$_zl) ?};
         {? ZLGD.AUTO<>'T' & ZLGD.PL_WYK='' & _ploper=0
         ||
::          Uruchamiam obsluge nadwykonan ale tylko jesli ZLGD nie powstal na podstawie
::          PL_WYKa i zlecenie nie znajduje sie w planie operacyjnym
            _zl_obj:=exec('get_zl_object','px_obj',_zl);
            exec('nadwyk_obj_del','px_wyk',_zl_obj)
         ?}
      ?};

      _res:=~PX_WYK.first();
      {? ~_res || KOMM.add('Nie można usunąć powiązanych zapisów wykonania planu strategicznego.'@,,,1) ?};

      Cntx.pop(PX_WYK,ZL,PX_GRP,PX_CONN);

      _res
   ||
      ~~
   ?}
?}


\res_pl2px
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Rzutowanie zasobu z planu operacyjnego na zasob z planu strategicznego
::       Wynikiem sa kontenery (PX_KONT) zgodne z obciazanym zasobem (PL_OZ.PL_RES), w przeciwnym wypadku null()
::   WE: _a - PL_OZ.ref()
::       _b - PL_OPER.ref()
::       [_c] - PX_VER.ref() - wersja planu w ktorej szukac kontenera - domyslnie wersja glowna
::   WY: tab_tmp - tabela tymczasowa z refami PX_KONTow powiazanych z PL_RESEM o strukturze:
::            REF - INTEGER - #PX_KONT.ref
::            NAME - STRING[8] - nazwa maski
::            SQL_REF - STRING[16] - $PX_KONT.ref()
::       lub ~~
::----------------------------------------------------------------------------------------------------------------------
:: W planie operacyjnym PL_OZ.PL_RES (_PL_RES), PL_OZ.PL_OPER (_PL_OPER)
:: W planie strategicznym PX_POZ.PX_KONT (_PX_KONT)
_pl_oz:=_a;
_pl_oper:=_b;

_px_ver:=null();
{? var_pres('_c')=type_of(PX_VER.ref())
|| _px_ver:=_c
|| _px_ver:=exec('get_mainversion','px_ver')
?};

_px_konty:=~~;

Cntx.psh(PL_OZ,PL_OPER,PX_KONT,PX_OPER,ZGP,ZOPER);
Cntx.clr(PL_OZ);

{? PL_OZ.seek(_pl_oz)
||
:: Przejscie robie zawsze na podstawie powiazan z tabela PL_RES
:: poniewaz przejscie na podstawie powiazan z PX_STAGE nie zadziala dobrze jezeli
:: PX_STAGE ma zdefiniowane wiecej niz jednego PX_OPERa
   _px_konty:=exec('plres2pxkont','px_tie',PL_OZ.PL_RES,_px_ver)
||
:: FUN.info('Nie znaleziono kontenera w planie strategicznym na podstawie planu zasobów.');
   ~~
?};

Cntx.pop(PL_OZ,PL_OPER,PX_KONT,PX_OPER,ZGP,ZOPER);
_px_konty


\source_rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Pokazuje powiazania z rekordem rejestracji wykonan - rejestracje zrodlowe
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(PL_WYK,ZLGD);
Cntx.clr(PL_WYK,ZLGD);

{? PX_WYK.AUTOPL='T' & PX_WYK.AUTOZL='T'
||
   {? PL_WYK.seek(PX_WYK.PL_WYK,form(8+PX_WYK.PL_WYK))
      & ZLGD.seek(PX_WYK.ZLGD,form(8+PX_WYK.ZLGD))
   ||
      ZLGD.win_edit('PL_WYK');
      ZLGD.display()
   ?}
|? PX_WYK.AUTOPL='T'
||
   {? PL_WYK.seek(PX_WYK.PL_WYK,form(8+PX_WYK.PL_WYK))
   ||
      PL_WYK.win_edit('RED');
      PL_WYK.display()
   ?}
|? PX_WYK.AUTOZL='T'
||
   {? ZLGD.seek(PX_WYK.ZLGD,form(8+PX_WYK.ZLGD))
   ||
      ZLGD.win_edit('RED');
      ZLGD.display()
   ?}
||
   FUN.info('Brak zapisów źródłowych.'@)
?};

Cntx.pop(PL_WYK,ZLGD);
~~


\uzup_prod_nxt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Uzupelnienie zapisow w tabeli PROD_NXT
::         - uzyte w formulach: exec('load_4rej','px_wyk'), exec('update_4rej','px_wyk')
::       Kontekst: PROD_REJ, PX_POZ
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(PROD_REJ,PROD_NXT,PX_STAGE,PL_OPER);
Cntx.clr(PROD_REJ,PROD_NXT);

_prod_rej:=PROD_REJ.ref();
_px_stage:=PX_POZ.PX_STAGE;
_px_grp:=PX_POZ.PX_GRP;
_px_kont:=PX_POZ.PX_KONT;
_px_obj:=PX_POZ.PX_OBJ;

:: Uzupelnienie nastepnikow/poprzednikow na podstawie powiazan miedzy etapami planistycznymi
{? PX_POZ.PX_STAGE<>null()
||
   PX_POZ.PX_STAGE();
   PROD_REJ.cntx_psh();

:: Nastepniki operacji
   PX_NAST.index('PX');
   PX_NAST.prefix(PX_STAGE.ref());
   {? PX_NAST.first()
   || {!
      |? PROD_NXT.blank(1);
         PROD_NXT.PROD_REJ:=_prod_rej;
         {? PX_NAST.PX_NEXT<>null()
         || PX_POZ.cntx_psh();
            PX_POZ.index('PX_STAG1');
            PX_POZ.prefix(_px_obj,PX_NAST.PX_NEXT);
            {? PX_POZ.first()
            || {!
               |? PROD_REJ.index('PX_POZ');
                  PROD_REJ.prefix('PX',PX_POZ.ref());
                  {? PROD_REJ.first()
                  || PROD_NXT.NEXT:=PROD_REJ.ref();
                     PROD_NXT.add(1)
                  ?};
                  PX_POZ.next()
               !}
            ?};
            PX_POZ.cntx_pop()
         ?};
         PX_NAST.next()
      !}
   ?};

:: Poprzedniki operacji
   PX_NAST.index('NEXT');
   PX_NAST.prefix(PX_STAGE.ref());
   {? PX_NAST.first()
   || {!
      |? PROD_NXT.blank(1);
         PROD_NXT.NEXT:=_prod_rej;
         {? PX_NAST.PX_STAGE<>null()
         || PX_POZ.cntx_psh();
            PX_POZ.index('PX_STAG1');
            PX_POZ.prefix(_px_obj,PX_NAST.PX_STAGE);
            {? PX_POZ.first()
            || {!
               |? PROD_REJ.index('PX_POZ');
                  PROD_REJ.prefix('PX',PX_POZ.ref());
                  {? PROD_REJ.first()
                  || PROD_NXT.PROD_REJ:=PROD_REJ.ref();
                     PROD_NXT.add(1)
                  ?};
                  PX_POZ.next()
               !}
            ?};
            PX_POZ.cntx_pop()
         ?};
         PX_NAST.next()
      !}
   ?};
   PROD_REJ.cntx_pop()

::   _stg_next:=PX_STAGE.STG_NEXT;
::   _stg_prev:=PX_STAGE.STG_PREV;
::
::   {? PX_STAGE.PX_TEX<>null()
::   || _px_tex:=PX_STAGE.PX_TEX;
::      PX_STAGE.index('TEX_NR');
::      PX_STAGE.prefix(_px_tex,_stg_next);
::      {? PX_STAGE.first()
::      ||
::         Cntx.psh(PX_POZ);
::         PX_POZ.index('PX_STAG1');
::         PX_POZ.prefix(_px_obj,PX_STAGE.ref());
::         {? PX_POZ.first()
::         || {!
::            |?
::               PROD_NXT.blank(1);
::               PROD_NXT.PROD_REJ:=_prod_rej;
::               PROD_REJ.index('PX_POZ');
::               PROD_REJ.prefix('PX',PX_POZ.ref());
::               {? PROD_REJ.first()
::               ||
::                  PROD_NXT.NEXT:=PROD_REJ.ref();
::                  PROD_NXT.add(1)
::               ?};
::               PX_POZ.next()
::            !}
::         ?};
::         Cntx.pop(PX_POZ)
::      ?};
::      PX_STAGE.index('TEX_NR');
::      PX_STAGE.prefix(_px_tex,_stg_prev);
::      {? PX_STAGE.first()
::      ||
::         Cntx.psh(PX_POZ);
::         PX_POZ.index('PX_STAG1');
::         PX_POZ.prefix(_px_obj,PX_STAGE.ref());
::         {? PX_POZ.first()
::         || {!
::            |?
::               PROD_NXT.blank(1);
::               PROD_NXT.NEXT:=_prod_rej;
::               PROD_REJ.index('PX_POZ');
::               PROD_REJ.prefix('PX',PX_POZ.ref());
::               {? PROD_REJ.first()
::               ||
::                  PROD_NXT.PROD_REJ:=PROD_REJ.ref();
::                  PROD_NXT.add(1)
::               ?};
::               PX_POZ.next()
::            !}
::         ?};
::         Cntx.pop(PX_POZ)
::      ?}
::   |? PX_STAGE.TKTL<>null()
::   || _tktl:=PX_STAGE.TKTL;
::      PX_STAGE.index('TKTL_NR');
::      PX_STAGE.prefix($_tktl,_stg_next);
::      {? PX_STAGE.first()
::      ||
::         Cntx.psh(PX_POZ);
::         PX_POZ.index('PX_STAG1');
::         PX_POZ.prefix(_px_obj,PX_STAGE.ref());
::         {? PX_POZ.first()
::         || {!
::            |?
::               PROD_NXT.blank(1);
::               PROD_NXT.PROD_REJ:=_prod_rej;
::               PROD_REJ.index('PX_POZ');
::               PROD_REJ.prefix('PX',PX_POZ.ref());
::               {? PROD_REJ.first()
::               ||
::                  PROD_NXT.NEXT:=PROD_REJ.ref();
::                  PROD_NXT.add(1)
::               ?};
::               PX_POZ.next()
::            !}
::         ?};
::         Cntx.pop(PX_POZ)
::      ?};
::      PX_STAGE.index('TKTL_NR');
::      PX_STAGE.prefix($_tktl,_stg_prev);
::      {? PX_STAGE.first()
::      ||
::         Cntx.psh(PX_POZ);
::         PX_POZ.index('PX_STAG1');
::         PX_POZ.prefix(_px_obj,PX_STAGE.ref());
::         {? PX_POZ.first()
::         || {!
::            |?
::               PROD_NXT.blank(1);
::               PROD_NXT.NEXT:=_prod_rej;
::               PROD_REJ.index('PX_POZ');
::               PROD_REJ.prefix('PX',PX_POZ.ref());
::               {? PROD_REJ.first()
::               ||
::                  PROD_NXT.PROD_REJ:=PROD_REJ.ref();
::                  PROD_NXT.add(1)
::               ?};
::               PX_POZ.next()
::            !}
::         ?};
::         Cntx.pop(PX_POZ)
::      ?}
::   ?}

:: Uzupelnienie nastepnikow/poprzednikow na podstawie planu operacyjnego
|? PX_POZ.PL_OPER<>null()
||
   PX_POZ.PL_OPER();
   PROD_REJ.cntx_psh();

:: Nastepniki operacji
   PL_NEXT.index('PL_OPER');
   PL_NEXT.prefix(PL_OPER.ref());
   {? PL_NEXT.first()
   || {!
      |?
         PROD_NXT.blank(1);
         PROD_NXT.PROD_REJ:=_prod_rej;
         {? PL_NEXT.NEXT<>null()
         ||
::          nastepna jest PL_OPER
            PROD_REJ.index('PL_OPER');
            PROD_REJ.prefix('PX',PL_NEXT.NEXT);
            {? PROD_REJ.first()
            ||
               PROD_NXT.NEXT:=PROD_REJ.ref();
               PROD_NXT.add(1)
            ?}
         |? PL_NEXT.NEXT_OGR<>null()
         ||
::          nastepna jest PL_OGR
            PROD_REJ.index('PL_OGR');
            PROD_REJ.prefix('PX',PL_NEXT.NEXT_OGR);
            {? PROD_REJ.first()
            ||
               PROD_NXT.NEXT:=PROD_REJ.ref();
               PROD_NXT.add(1)
            ?}
         ?};
         PL_NEXT.next()
      !}
   ?};

:: Poprzedniki operacji
   PL_NEXT.index('NEXT');
   PL_NEXT.prefix(PL_OPER.ref());
   {? PL_NEXT.first()
   ||
      {!
      |?
         PROD_NXT.blank(1);
         PROD_NXT.NEXT:=_prod_rej;
         {? PL_NEXT.PL_OPER<>null()
         ||
::          poprzednia jest PL_OPER
            PROD_REJ.index('PL_OPER');
            PROD_REJ.prefix('PX',PL_NEXT.PL_OPER);
            {? PROD_REJ.first()
            ||
               PROD_NXT.PROD_REJ:=PROD_REJ.ref();
               PROD_NXT.add(1)
            ?}
         |? PL_NEXT.PL_OGR<>null()
         ||
::          poprzednia jest PL_OGR
            PROD_REJ.index('PL_OGR');
            PROD_REJ.prefix('PX',PL_NEXT.PL_OGR);
            {? PROD_REJ.first()
            ||
               PROD_NXT.PROD_REJ:=PROD_REJ.ref();
               PROD_NXT.add(1)
            ?}
         ?};
         PL_NEXT.next()
      !}
   ?};
   PROD_REJ.cntx_pop()
?};

Cntx.pop(PROD_REJ,PROD_NXT,PX_STAGE,PL_OPER);
~~


\uzup_znaczniki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Uzupelnienie znacznikow w tabeli PROD_REJ
::         - uzyte w formulach: exec('load_4rej','px_wyk'), exec('update_4rej','px_wyk')
::   WE: _a - PROD_REJ.ref()
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null()) || _prod_rej:=_a || _prod_rej:=null() ?};

:: Jezeli brak kontroli ilosci, to pomijana jest aktualizacja znacznikow
{? exec('get','#params',500633,2)='N' || return() ?};

Cntx.psh(PROD_REJ,PROD_NXT);
Cntx.clr(PROD_REJ         );

{? PROD_REJ.seek(_prod_rej)
||
   _stat:=exec('statusy','px_poz');

:: Analiza tylko, gdy pozycja oznaczona jako 'do rejestracji',
:: zmiana na 'nie do rejestracji' gdy nie pierwsza albo poprzedniki bez ilosci wykonanej
   {? PROD_REJ.DOREJ='T';1
   ||
      _il:=exec('il_pop','px_wyk',PROD_REJ.ref());
      {? _il.IL_POP>0 | ~_il.MAX || PROD_REJ.DOREJ:='T' || PROD_REJ.DOREJ:='N' ?};
      PROD_REJ.put();

:: To samo dla nastepnikow
      PROD_NXT.index('PROD_REJ');
      PROD_NXT.prefix(PROD_REJ.ref());
      {? PROD_NXT.first()
      || {!
         |?
            exec('uzup_znaczniki','px_wyk',PROD_NXT.NEXT);
            PROD_NXT.next()
         !}
      ?};
      ~~
   ?}
?};

Cntx.pop(PROD_REJ,PROD_NXT);
~~


\rej_zlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Rejestracja wykonan do planu strategicznego - z poziomu zlecenia
::----------------------------------------------------------------------------------------------------------------------
{? exec('chk_role','#b__box',OPERATOR.USER,'TTE_WYK_DWPS')=0 | exec('get','#params',500613,2)='N'
|| exec('no_auth','px_wyk');
   return()
?};

_args:=exec('args_4px','px_wyk');
{? var_pres('__GRUPA')<0
||
   {? VAR.A_ZLEC().RODZAJ='P'
   ||
      _args.WHERE:='ZL.REFERENCE=\''+$VAR.A_ZLEC+'\''
   ||
      _args.WHERE:='ZL.REFERENCE in (select :_a.REF from :_a)';
      _args.TAB:=tab_tmp(1,'REF','STRING[16]','$ZL.ref()');
      ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(VAR.A_ZLEC().UNRZL);
      {? ZL.first()
      || {!
         |?
            _args.TAB.REF:=$ZL.ref();
            _args.TAB.add();
            ZL.next()
         !}
      ?};
      ZL.cntx_pop()
   ?}
||
   _args.WHERE:='ZL.REFERENCE in (select :_a.REF from :_a)';
   _args.TAB:=tab_tmp(1,'REF','STRING[16]','$ZL.ref()');
   {? __GRUPA.first()
   || {!
      |?
         {? ZL.seek(__GRUPA.REF,)
         ||
            {? ZL.RODZAJ='P'
            ||
               _args.TAB.REF:=$ZL.ref();
               _args.TAB.add()
            ||
               ZL.cntx_psh();
               ZL.index('NRNZL');
               ZL.prefix(ZL.UNRZL);
               {? ZL.first()
               || {!
                  |?
                     _args.TAB.REF:=$ZL.ref();
                     _args.TAB.add();
                     ZL.next()
                  !}
               ?};
               ZL.cntx_pop()
            ?}
         ?};
         __GRUPA.next()
      !}
   ?}
?};
exec('rejestracja','prod_rej',_args);
~~


\zlec_px_wyk_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Selekcja wykonan do zlecenia (bez PROD_REJ)
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();

{? ZL.RODZAJ='P'
||
   PX_OBJ.index('ZL');
   PX_OBJ.prefix(ZL.ref());
   {? PX_OBJ.first()
   ||
:: "blankuje" PX_VAR - po to zeby sie zblankowalo PX_VAR.GREY
      PX_VAR.GREY:=exec('findfnv','#color');

      exec('mainversion_chk','px_ver');

      PX_WYK.index('PX_OBJ');
      PX_WYK.prefix(exec('get_mainversion','px_ver'),PX_OBJ.ref());
      PX_WYK.win_sel('WER_O');
      PX_WYK.win_edit('RED');
      PX_WYK.select(,,,'PU')
   ?}
||
:: "blankuje" PX_VAR - po to zeby sie zblankowalo PX_VAR.GREY
   PX_VAR.GREY:=exec('findfnv','#color');

   _tab:=tab_tmp(1,'REF','STRING[16]','$ZL.ref()');
   ZL.index('NRNZL');
   ZL.prefix(ZL.UNRZL);
   {? ZL.first()
   || {!
      |? PX_OBJ.index('ZL');
         PX_OBJ.prefix(ZL.ref());
         {? PX_OBJ.first()
         || _tab.REF:=$PX_OBJ.ref();
            _tab.add()
         ?};
         ZL.next()
      !}
   ?};

   PX_WYK.clear();
   PX_WYK.f_set('DATA,CZAS',,'PX_WYK.PX_VER=:_a and PX_WYK.PX_OBJ in (select :_b.REF from :_b)',exec('get_mainversion','px_ver'),_tab);
   PX_WYK.win_sel('WER_O');
   PX_WYK.win_edit('RED');
   PX_WYK.select(,,,'PU');
   PX_WYK.f_clear()
?};

ZL.cntx_pop();
~~


\px_wyk_rkprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Akcja przed rekord w oknie PX_WYK.WER_O
::----------------------------------------------------------------------------------------------------------------------
PX_WYK.PX_POZ().PX_KONT();
~~


\del_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Kasuje dane z tabeli do rejestracji wykonan - zapisy dotyczace planu strategicznego (PX)
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(PROD_REJ,PROD_NXT);
Cntx.clr(PROD_REJ,PROD_NXT);

PROD_REJ.index('PX_POZ');
PROD_REJ.prefix('PX');
{? PROD_REJ.first()
|| {!
   |? PROD_NXT.index('PROD_REJ');
      PROD_NXT.prefix(PROD_REJ.ref());
      {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};
      PROD_NXT.index('NEXT');
      PROD_NXT.prefix(PROD_REJ.ref());
      {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};
      PROD_REJ.del()
   !}
?};

Cntx.pop(PROD_REJ,PROD_NXT);
~~


\potw_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Potwierdź' w oknie rejestracji wykonań - plan strategiczny
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (plan strategiczny) funkcja \'Potwierdź\' nie jest obsługiwana.'@);
0


\xpotw_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obsługa przycisku 'Odrzuć' w oknie rejestracji wykonań - plan strategiczny
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (plan strategiczny) funkcja \'Odrzuć\' nie jest obsługiwana.'@);
0


\args_4px
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca wspolne wartosci argumentow dla rejestracji do planu strategicznego
::       Uzyte z formulach exec('rej_zlec','px_wyk')
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('rejestracja_a','prod_rej');
_args.F_NAWIG:=0;
_args.F_FILTER:=1;
_args.F_START:=0;
_args.F_STOP:=0;
_args.F_WYKON:=1;
_args.F_XWYKON:=0;
_args.F_PROB:=0;
_args.F_DOC:=0;
_args.F_MAT:=0;
_args.F_PRAC:=0;
_args.F_BRYG:=0;
_args.F_REJ:=1;
_args.FILTR_PX:=1;
_args.FILTR_PL:=0;
_args.FILTR_ZL:=0;
_args.PR_DATA:=date(0,0,0);
_args.ED_DATA:=0;
_args.ED_ZAKR:=0;
_args.ED_RES:=1;
_args.ED_M:=1;
_args.ED_WYD:=1;
_args.ED_OPIS:=1;
_args.ED_START:=1;
_args.ED_OK:=1;
_args.ED_PROB:=0;
_args.ED_PRAC:=0;
_args.ED_BRYG:=0;
_args.ED_KOOP:=1;
_args.ED_GROP:=0;
_args.ED_A:=1;
_args.ED_DOREJ:=1;
_args.ED_PX:=1;
_args.ED_PL:=0;
_args.ED_ZL:=0;
_args.CLOSE:="";
_args


\problem_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Zgłoś problem' w oknie rejestracji wykonań - plan strategiczny
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (plan strategiczny) funkcja \'Zgłoś problem\' nie jest obsługiwana.'@);
~~


\xproblem_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obsługa przycisku 'Rozwiąż problem' w oknie rejestracji wykonań - plan strategiczny
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (plan strategiczny) funkcja \'Rozwiąż problem\' nie jest obsługiwana.'@);
~~


\cap_wyk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca wykonanie we wszystkich wymiarach
::       Kontekst pracy - PX_WYK
::   WY: DICT - tablica - wykonanie we wszystkich wymiarach
::----------------------------------------------------------------------------------------------------------------------
_il_wym:=PX_WYK.PX_POZ().PX_KONT().IL_WYM;
_result:=obj_new(_il_wym);

::inicjuje tablice
{! _it:=1.._il_wym
|! _result[_it]:=0
!};

{? _il_wym>0
|| {! _it:=1.._il_wym
   |! _cap_max:=($('PX_WYK.CAP_WYK'+$_it))();
      _result[_it]+=_cap_max
   !}
?};
_result


\no_auth
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Komunikat o braku uprawnien do rejestracji wykonan
::----------------------------------------------------------------------------------------------------------------------
FUN.info('Brak uprawnień do rejestracji wykonań do planu strategicznego.'@);
~~


\no_enabled
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Komunikat o wylaczeniu parametru rejestracji wykonan do planu strateg
::----------------------------------------------------------------------------------------------------------------------
FUN.info('Rejestracja wykonań niedostępna dla planu strategicznego (parametr 500613).'@);
~~


\legenda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Legenda kolorowania w oknach rejestracji wykonan
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','@PX_POZ#CAP#WIN#')


\il_pop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca ilosc ogolem zarejestrowana na poprzednikach operacji
::   WE: _a - PROD_REJ.ref()
::   WY: [1] ilosc, [2] znacznik, czy pilnowac maksimum
::----------------------------------------------------------------------------------------------------------------------
_prod_rej:=_a;

_res:=obj_new('IL_POP','MAX');
_res.IL_POP:=0;
_res.MAX:=0;

Cntx.psh(PROD_REJ,PROD_NXT);
Cntx.clr(PROD_REJ         );

{? PROD_REJ.seek(_prod_rej)
||
   PROD_NXT.index('NEXT');
   PROD_NXT.prefix(PROD_REJ.ref());
   {? PROD_NXT.first()
   || {!
      |? _res.IL_POP+=PROD_NXT.PROD_REJ().ILW;
         PROD_NXT.next()
      !};
      _res.MAX:=1
   ?}
?};

Cntx.pop(PROD_REJ,PROD_NXT);

_res


\il_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca ilosc ogolem zarejestrowana na nastepnikach operacji
::   WE: _a - PROD_REJ.ref()
::   WY: ilosc rzeczywista
::----------------------------------------------------------------------------------------------------------------------
_prod_rej:=_a;

_res:=0;

Cntx.psh(PROD_REJ,PROD_NXT);
Cntx.clr(PROD_REJ         );

{? PROD_REJ.seek(_prod_rej)
||
   PROD_NXT.index('PROD_REJ');
   PROD_NXT.prefix(PROD_REJ.ref());
   {? PROD_NXT.first()
   || {!
      |? _res+=PROD_NXT.NEXT().ILW;
         PROD_NXT.next()
      !}
   ?}
?};

Cntx.pop(PROD_REJ,PROD_NXT);

_res


\gen4plwyk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Generuje rekordy PX_WYK na podstawie przekazanego PL_WYKa
::   WE: _a - PL_OPER.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_pl_wyk:=_a;

_result:=0;
_can_continue:=1;

PL_WYK.cntx_psh(); PL_WYK.clear();
PL_OPER.cntx_psh();

{? PL_WYK.seek(_pl_wyk)
||
:: Wersja glowna planu strategicznego
   _mainver:=exec('get_mainversion','px_ver');

:: Podczytanie PL_OPER
   PL_WYK.PL_OPER();

:: Wspolczynnik, ile zostalo wykonane
   _coef:=PL_WYK.IL_WYK/PL_OPER.ILOSC;

   PX_POZ.cntx_psh();

:: Prefiksowanie PX_POZ
   PX_POZ.index('PL_OPER2');
   PX_POZ.prefix(PL_OPER.ref(),_mainver);

   _px_kont:=null();
   {? PX_POZ.first()
   || _px_kont:=PX_POZ.PX_KONT;

::    Uruchamiam generator PX_WYK - na podstawie proporcji
      _result:=exec('generator1','px_wyk' ,_coef
                                          ,_px_kont
                                          ,PL_WYK.ENDD().DATA
                                          ,PL_WYK.ENDT
                                          ,_mainver
                                          ,PL_WYK.ref())
   ?};

   PX_POZ.cntx_pop()
?};
PL_OPER.cntx_pop();
PL_WYK.cntx_pop();
_result


\gen4zlgd
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Generuje rekordy PX_WYK na podstawie przekazanego ZLGD
::   WE: _a - ZLGD.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_zlgd:=_a;

_result:=0;
_can_continue:=1;

PX_POZ.cntx_psh();
ZL.cntx_psh(); ZL.prefix();
ZGH.cntx_psh();
ZGP.cntx_psh();
PX_STAGE.cntx_psh();
PX_OPER.cntx_psh();
ZLGD.cntx_psh(); ZLGD.clear();
GROP.cntx_psh();
GROPS.cntx_psh();
{? ZLGD.seek(_zlgd)
||
:: Wersja glowna planu strategicznego
   _mainver:=exec('get_mainversion','px_ver');

   {? ZLGD.GROP=null()
   ||
::    Podczytanie ZL, ZGH, ZGP, PX_STAGE
      _top_level:=exec('top_level','zl_link',ZLGD.ZL);
      {? exec('FindAndGet','#table',ZL,_top_level,,"RODZ_TEX='Z'",0)
      || ZL.seek(_top_level)
      || ZLGD.ZL()
      ?};
      ZLGD.ZGH();
      ZLGD.ZGP();
      ZGP.PX_STAGE();

      PX_OPER.index('UNIQALL');
      PX_OPER.prefix(PX_STAGE.ref());
      {? PX_OPER.first()
      || {!
         |?
::          Podczytanie PX_KONT
            PX_OPER.PX_KONT();

::          Prefiksowanie PX_POZ
            PX_POZ.index('PX_OBJ3');
            _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
            PX_POZ.prefix(_px_obj,PX_OPER.PX_KONT,PX_STAGE.ref());
            _obj_jm:=exec('FindAndGet','#table',PX_OBJ,_px_obj,,"JM",null());

::          Ile lacznie na pozycji przewodnika (jm produktu)
            _plan_jm:=ZGP.ILOSC;
::          Żeby nie było dzielenia przez zero
            {? _plan_jm=0
            || _plan_jm:=1
            ?};
::          Ile lacznie na pozycji przewodnika (minuty)
            _plan:={? ZGP.NTIME<>0 || ZGP.NTIME*60 || ZGP.MTIME*60 ?};

::          Ile na tym ZLGD (ilosc w jm produktu)
            _wyk_jm:=ZLGD.IL;
::          Ile na tym ZLGD (minuty), przyjmujemy czas skalowany wg normy (a nie czas rzeczywisty ZLGD.TIME)
            _wyk:=_wyk_jm*_plan/_plan_jm;

::          pojemnosc zjedzona i wykonana liczone narastajaco w ich jednostkach miary - zerowanie
            _cap_sum:=obj_new(PX_KONT.IL_WYM);
            _il_wyk:=obj_new(PX_KONT.IL_WYM);
            {! _dim:=1.. PX_KONT.IL_WYM
            |! _cap_sum[_dim]:=0;
               _il_wyk[_dim]:=0
            !};

::          Sumuje zuzycie zajmowane przez PX_POZy
            {? PX_POZ.first()
            || {!
               |?
                  _px_poz:=PX_POZ.ref();
                  {? var_pres('_poz_eat')>100
                  || obj_del(_poz_eat)
                  ?};
                  _poz_eat:=exec('count_eat','px_poz',PX_POZ.ref());
                  exec('arrays_add_mod','#array',_cap_sum,_poz_eat);
                  PX_POZ.next()
               !}
            ?};

::          Wymiar zgodny z jm produktu (ZL.M().JM), wymiary zgodne z przelicznikami MJM dla ZL.M (jezeli jest)
::          wymiar godziny, wymiar minuty
            {! _dim:=1.. PX_KONT.IL_WYM
            |!
               _jm:=($('PX_KONT.JM'+$_dim+'().KOD'))();
               {? _jm=exec('get','#params',500383,2)
               ||
::                czas w minutach
                  _il_wyk[_dim]:=_wyk$($('PX_KONT.PREC'+$_dim))()
               |? _jm=exec('get','#params',500380) |
                  _jm=exec('get','#params',500381) |
                  _jm=exec('get','#params',500382)
               ||
::                czas w godzinach
                  _il_wyk[_dim]:=(_wyk/60)$($('PX_KONT.PREC'+$_dim))()
               |? ($('PX_KONT.JM'+$_dim))()=_obj_jm
               ||
::                ilosc produktu
                  _il_wyk[_dim]:=_wyk_jm$($('PX_KONT.PREC'+$_dim))()
               |?
::                ilosc produktu w jednostkach przeliczeniowych
                  MJM.index('JP');
                  MJM.prefix(ZL.KTM,ZL.KTM().J,($('PX_KONT.JM'+$_dim))());
                  MJM.first()
               || _il_wyk[_dim]:=(_wyk_jm/MJM.PRZ)$($('PX_KONT.PREC'+$_dim))()
               ||
::                Nie znalazlem zadnego wymiaru pasujacego do jednostki miary
::                wiec ilosc jaka ma sie dodac na PX_WYKi wyliczam z proporcji
                  _prop:=_wyk_jm/_plan_jm;

                  _il_wyk[_dim]:=_prop*_cap_sum[_dim]$($('PX_KONT.PREC'+$_dim))()
               ?}
            !};
            _data:={? ZLGD.ZMIANA='3' || ZLGD.DT+1 || ZLGD.DT ?};
            _czas:={? ZLGD.ZMIANA='1'
                   || time(14,0,0)
                   |? ZLGD.ZMIANA='2'
                   || time(22,0,0)
                   |? ZLGD.ZMIANA='3'
                   || time(6,0,0)
                   || time(23,59,59)
                   ?};
            _can_continue:=exec('generator2','px_wyk' ,_il_wyk
                                                      ,PX_KONT.ref()
                                                      ,_data
                                                      ,_czas
                                                      ,_mainver
                                                      ,
                                                      ,ZLGD.ref());
            PX_OPER.next()
         !}
      ?}
   ||
::    Podczytanie GROP
      ZLGD.GROP();

      _px_obj:=exec('get_grop_object','px_obj',ZLGD.GROP);
      _px_stage:=exec('px_stage4grops','px_grop',ZLGD.GROPS);

::    Prefiksowanie PX_POZ
      PX_POZ.index('PX_STAG1');
      PX_POZ.prefix(_px_obj,_px_stage);
      {? PX_POZ.first()
      ||
::       Podczytanie PX_KONT
         PX_POZ.PX_KONT();

::       Przeliczenie liczby rejestrowanych uruchomień na zużyty czas (w minutach)
         _wyk:=ZLGD.IL*(exec('time2min','#convert',GROPS.CZAS));

::       pojemnosc zjedzona i wykonana liczone narastajaco w ich jednostkach miary - zerowanie
         _cap_sum:=obj_new(PX_KONT.IL_WYM);
         _il_wyk:=obj_new(PX_KONT.IL_WYM);
         {! _dim:=1.. PX_KONT.IL_WYM
         |! _cap_sum[_dim]:=0;
            _il_wyk[_dim]:=0
         !};

::       Sumuje zuzycie zajmowane przez PX_POZy
         {? PX_POZ.first()
         || {!
            |?
               _px_poz:=PX_POZ.ref();
               {? var_pres('_poz_eat')>100
               || obj_del(_poz_eat)
               ?};
               _poz_eat:=exec('count_eat','px_poz',PX_POZ.ref());
               exec('arrays_add_mod','#array',_cap_sum,_poz_eat);
               PX_POZ.next()
            !}
         ?};

         {! _dim:=1.. PX_KONT.IL_WYM
         |!
            _jm:=($('PX_KONT.JM'+$_dim+'().KOD'))();
            {? _jm=exec('get','#params',500383,2)
            ||
::             czas w minutach
               _il_wyk[_dim]:=_wyk$($('PX_KONT.PREC'+$_dim))()
            |? _jm=exec('get','#params',500380) |
               _jm=exec('get','#params',500381) |
               _jm=exec('get','#params',500382)
            ||
::             czas w godzinach
               _il_wyk[_dim]:=(_wyk/60)$($('PX_KONT.PREC'+$_dim))()
            ?}
         !};

         _data:={? ZLGD.ZMIANA='3' || ZLGD.DT+1 || ZLGD.DT ?};
         _czas:={? ZLGD.ZMIANA='1'
                || time(14,0,0)
                |? ZLGD.ZMIANA='2'
                || time(22,0,0)
                |? ZLGD.ZMIANA='3'
                || time(6,0,0)
                || time(23,59,59)
                ?};
         _can_continue:=exec('generator2','px_wyk' ,_il_wyk
                                                   ,PX_KONT.ref()
                                                   ,_data
                                                   ,_czas
                                                   ,_mainver
                                                   ,
                                                   ,ZLGD.ref())
      ?}
   ?}
?};
GROPS.cntx_pop();
GROP.cntx_pop();
ZLGD.cntx_pop();
PX_OPER.cntx_pop();
PX_STAGE.cntx_pop();
ZGP.cntx_pop();
ZGH.cntx_pop();
ZL.cntx_pop();
PX_POZ.cntx_pop();
~~


\generator1
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Generuje PX_WYKi dla kolejnych PX_POZow - na podstawie przekazanej proporcji
::       KONTEKST PRACY - zaprefiksowana dziedzina PX_POZow ktorym nawijac wykonanie
::                        UWAGA!!! Wszystkie PX_POZy MUSZA sie znajdowac na jednym kontenerze
::                        (podanym jako argument _b)
::   WE: _a - REAL - proporcja wg której nawijac wykonania - np. 0.5 oznacza
::                   ze polowa z zaprefiksowanej ilosci na PX_POZ zostanie wykonana
::       _b - PX_KONT.ref() - kontener na ktorym jest rejestrowane wykonanie
::       _c - DATE - data rejestracji
::       _d - TIME - czas rejestracji
::       _e - PX_VER - wersja do ktorej rejestrowac
::       [_f] - PL_WYK.ref() - wykonanie planu operacyjnego z ktorym powiazac tworzone PX_WYKi
::       [_g] - ZLGD.ref() - rejestracja godzin do zlecenia z ktorym powiazac tworzone PX_WYKi
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_coef:=_a;
_px_kont:=_b;
_data:=_c;
_czas:=_d;
_px_ver:=_e;
_place:=null;

_pl_wyk:=null();
{? var_pres('_f')=type_of(PL_WYK.ref())
|| _pl_wyk:=_f;
   _place:=exec('FindAndGet','#table',PL_WYK,_pl_wyk,,"PL_WYK.PLACE",null)
?};

_zlgd:=null();
{? var_pres('_g')=type_of(ZLGD.ref())
|| _zlgd:=_g;
   _place:=exec('FindAndGet','#table',ZLGD,_zlgd,,"ZLGD.PLACE",null)
?};

_result:=0;
_can_continue:=1;

:: Ilosc wymiarow
_il_wym:=exec('FindAndGet','#table',PX_KONT,_px_kont,,"IL_WYM",0);

:: Suma obciazen z PX_POZ
_eat:=obj_new(_il_wym);
{! _dim:=1.._il_wym
|! _eat[_dim]:=0
!};

{? PX_POZ.first()
||
   {!
   |? {! _dim:=1.._il_wym
      |! _eat[_dim]+=($('PX_POZ.CAP_EAT'+$_dim))()
      !};
      PX_POZ.next()
   !}
?};

_prec:=exec('precision_array','px_kont',_px_kont);

:: Wyliczenie ilosci do rozliczenia (do wpisania na PX_WYK)
_il:=obj_new(_il_wym);
{! _dim:=1.._il_wym
|!
   _il[_dim]:=(_eat[_dim]*_coef)$_prec[_dim]
!};

{? PX_POZ.first()
|| {!
   |?
      PX_WYK.blank(1);
      PX_WYK.USER:=OPERATOR.USER;
      PX_WYK.DATA0:=_data;
      PX_WYK.CZAS0:=_czas;
      PX_WYK.DATA:=_data;
      PX_WYK.CZAS:=_czas;
      PX_WYK.ZAK:='T';

      {! _dim:=1.._il_wym
      |!
::       Ile mozna jeszcze dopisac wykonania na te pozycje planu
         _il_dop:=($('PX_POZ.CAP_EAT'+$_dim+'-PX_POZ.CAP_WYK'+$_dim))();
         _dopisz:={? _il[_dim]>_il_dop || _il_dop || _il[_dim] ?};
         ($('PX_WYK.CAP_WYK'+$_dim))():=_dopisz;
::        pozostalo jeszcze do dopisania
         _il[_dim]-=_dopisz
      !};

      PX_WYK.PX_POZ:=PX_POZ.ref();
      PX_WYK.PX_OBJ:=PX_POZ.PX_OBJ;
      PX_WYK.PX_VER:=_px_ver;
      PX_WYK.PLACE:=_place;

      {? _pl_wyk<>null()
      || PX_WYK.AUTOPL:='T';
         PX_WYK.PL_WYK:=$_pl_wyk;
         PX_WYK.AUTOZL:='N';
         PX_WYK.ZLGD:=''
      |? _zlgd<>null()
      || PX_WYK.AUTOPL:='N';
         PX_WYK.PL_WYK:='';
         PX_WYK.AUTOZL:='T';
         PX_WYK.ZLGD:=$_zlgd
      ?};
::    Dodac rekord, o ile jest cokolwiek w ktoryms wymiarze
      _jest:=0;
      {! _dim:=1.._il_wym |! _jest+=($('PX_WYK.CAP_WYK'+$_dim))() !};
      {? _jest>0
      || _can_continue:=PX_WYK.add();
         {? _can_continue>0
         || exec('px_poz_update','px_wyk',PX_POZ.ref())
         ?}
      ?};
      PX_POZ.next() & _can_continue>0
   !}
?};
{? _can_continue>0
|| _result:=1
?};
_result


\generator2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Generuje PX_WYKi dla kolejnych PX_POZow - na podstawie przekazanej tablicy
::       w ktorej znajduja sie wykonane ilosci w poszczegolnych wymiarach
::       KONTEKST PRACY - zaprefiksowana dziedzina PX_POZow ktorym nawijac wykonanie
::                        UWAGA!!! Wszystkie PX_POZy MUSZA sie znajdowac na jednym kontenerze
::                        (podanym jako argument _b)
::   WE: _a - obj_new() - tablica zawierajaca wykonane ilosci w kolejnych wymiarach
::       _b - PX_KONT.ref() - kontener na ktorym jest rejestrowane wykonanie
::       _c - DATE - data rejestracji
::       _d - TIME - czas rejestracji
::       _e - PX_VER - wersja do ktorej rejestrowac
::       [_f] - PL_WYK.ref() - wykonanie planu operacyjnego z ktorym powiazac tworzone PX_WYKi
::       [_g] - ZLGD.ref() - rejestracja godzin do zlecenia z ktorym powiazac tworzone PX_WYKi
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_il_wyk:=_a;
_px_kont:=_b;
_data:=_c;
_czas:=_d;
_px_ver:=_e;
_place:=null;

_pl_wyk:=null();
{? var_pres('_f')=type_of(PL_WYK.ref())
|| _pl_wyk:=_f;
   _place:=exec('FindAndGet','#table',PL_WYK,_pl_wyk,,"PL_WYK.PLACE",null)
?};

_zlgd:=null();
{? var_pres('_g')=type_of(ZLGD.ref())
|| _zlgd:=_g;
   _place:=exec('FindAndGet','#table',ZLGD,_zlgd,,"ZLGD.PLACE",null)
?};

_result:=0;
_can_continue:=1;

:: Ilosc wymiarow
_il_wym:=exec('FindAndGet','#table',PX_KONT,_px_kont,,"IL_WYM",0);

:: Dopisywanie wykonan do kolejnych pozycji planu - iteracja po PX_POZ (first byl wczesniej)
{? PX_POZ.first()
||
   _cap_eat:=obj_new(_il_wym);
   _cap_wyk:=obj_new(_il_wym);
   {! _dim:=1.._il_wym
   |! _cap_eat[_dim]:=0;
      _cap_wyk[_dim]:=0
   !};

   {!
   |?
      PX_WYK.blank(1);
      PX_WYK.USER:=OPERATOR.USER;
      PX_WYK.DATA0:=_data;
      PX_WYK.CZAS0:=_czas;
      PX_WYK.DATA:=_data;
      PX_WYK.CZAS:=_czas;
      PX_WYK.ZAK:='T';

::    patrzymy na CAP_WYK* i CAP_EAT* - dokladamy PX_WYK, zeby bylo ok
      {! _dim:=1.._il_wym
      |!
         _cap_left:=($('PX_POZ.CAP_EAT'+$_dim))()-($('PX_POZ.CAP_WYK'+$_dim))();
         _cap_eat[_dim]+=_cap_left;

         {? _cap_wyk[_dim]+_il_wyk[_dim]<=_cap_eat[_dim]
         || ($('PX_WYK.CAP_WYK'+$_dim))():=_il_wyk[_dim];
            _cap_wyk[_dim]+=_il_wyk[_dim];
            _il_wyk[_dim]:=0
         || ($('PX_WYK.CAP_WYK'+$_dim))():=_cap_left;
            _cap_wyk[_dim]+=_cap_left;
            _il_wyk[_dim]-=_cap_left
         ?}
      !};

      PX_WYK.PX_POZ:=PX_POZ.ref();
      PX_WYK.PX_OBJ:=PX_POZ.PX_OBJ;
      PX_WYK.PX_VER:=_px_ver;
      PX_WYK.PLACE:=_place;

      {? _pl_wyk<>null()
      || PX_WYK.AUTOPL:='T';
         PX_WYK.PL_WYK:=$_pl_wyk;
         PX_WYK.AUTOZL:='N';
         PX_WYK.ZLGD:=''
      |? _zlgd<>null()
      || PX_WYK.AUTOPL:='N';
         PX_WYK.PL_WYK:='';
         PX_WYK.AUTOZL:='T';
         PX_WYK.ZLGD:=$_zlgd
      ?};
::    Dodac rekord, o ile jest cokolwiek w ktoryms wymiarze
      _jest:=0;
      {! _dim:=1.._il_wym
      |! _jest+=($('PX_WYK.CAP_WYK'+$_dim))()
      !};
      {? _jest>0
      || _can_continue:=PX_WYK.add();
         {? _can_continue>0
         ||
            exec('px_poz_update','px_wyk',PX_POZ.ref())
         ?}
      ?};
      PX_POZ.next() & _can_continue>0
   !};

   {? _can_continue>0 & PX_POZ.last()
   ||
::    Jezeli tutaj mam jeszcze cokolwiek do zapisania w PX_WYK, to dobijam do ostatniej PX_POZ (nadwykonania)
      _jest:=0;
      {! _dim:=1.._il_wym |! _jest+=_il_wyk[_dim] !};
      {? _jest>0
      || {! _dim:=1.._il_wym
         |!
            ($('PX_WYK.CAP_WYK'+$_dim))():=_il_wyk[_dim]
         !};
         _can_continue:=PX_WYK.add();
         {? _can_continue>0
         || exec('px_poz_update','px_wyk',PX_POZ.ref())
         ?}
      ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
_result


\nadwykon_pxpoz
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Analizuje czy pozycja planu posiada nadwykonania, jesli tak to przesuwa/dzieli ta pozycje
::       na pojemnik w przeszlosci na ktorym pozycja planu powinna sie znalezc
::   WE: _a - PX_POZ.ref()
::   WY: 0 - porazka - wystapil blad
::       1 - sukces - pozycja nie ma nadwykonan
::       2 - sukces - pozycja miala nadwykonanie i zostala przesunieta/podzielona
::----------------------------------------------------------------------------------------------------------------------
_pxpoz:=_a;

_result:=1;
_can_continue:=1;

PX_CUP.cntx_psh();
PX_WYK.cntx_psh();
PX_WYK.index('POZ');
PX_POZ.cntx_psh(); PX_POZ.clear();
{? PX_POZ.seek(_pxpoz)
||
   PX_WYK.prefix(PX_POZ.ref());
   {? PX_WYK.first()
   || _ile_wykow:=PX_WYK.size();
      {!
      |?
::       Po kazdym obrocie petli podczytuje PX_POza bo moglo cos sie na nim zmienic
         PX_POZ.get();
         _wyk_moved:=0;
         _next:=1;
::       Zapamietuje ref nastepnego rekordu
         _ref_next:=null();
         PX_WYK.cntx_psh();
         {? PX_WYK.next()
         || _ref_next:=PX_WYK.ref()
         ?};
         PX_WYK.cntx_pop();

         _stamp_wyk:=exec('create','#tm_stamp',PX_WYK.DATA0,PX_WYK.CZAS0);
         {? PX_POZ.TM_START>_stamp_wyk
         ||
::          Odkrylem nadwykonanie - teraz sprawdzam czy trzeba bedzie przesunac pozycje planu
::          aby trafila na pojemnik zgodny z zapisem rejestracyjnym (PX_WYK)
            {? exec('cup_closest','px_plan',PX_POZ.PX_KONT,_stamp_wyk,1)>0
            || {? PX_CUP.ref()<>PX_POZ.PX_CUP
               ||
                  {? var_pres('_argskomm')>100
                  || obj_del(_argskomm)
                  ?};
                  _argskomm:=exec('add_komm_a','px_komm');
                  _argskomm.PX_CUP:=PX_CUP.ref();
                  _argskomm.TYP:=exec('type_info','px_komm');
                  _argskomm.SRC_KIND:=exec('src_nadwykon_mv','px_komm');
                  _argskomm.MESSAGE:='Pojemnik zawiera pozycje planu przesunięte tutaj w wyniku rejestracji nadwykonań.';

::                Sprawdzam czy w pojemniku jest taki komunikat
                  _komm:=exec('get_kom','px_komm','PX_CUP'  ,PX_CUP.ref()
                                                            ,exec('type_info','px_komm')
                                                            ,exec('src_nadwykon_mv','px_komm'));

::                Nadwykonanie wymaga przesuniecia pozycji planu
                  {? PX_POZ.STATUS=exec('status_wyk2','px_poz') & _ile_wykow=1
                  ||
::                   Pozycji planu zapamietuje tm stamp zrodlowego pojemnika
                     PX_CUP.cntx_psh();
                     PX_POZ.TM_SRC:=PX_POZ.PX_CUP().TM_START;
                     _can_continue:=PX_POZ.put();
                     PX_CUP.cntx_pop();

::                   Jest tylko jeden PX_WYK a pozycja jest w calosci wykonana wiec
::                   nie musze dzielic PX_POZa tylko go po prostu przesunac na inny termin
                     {? exec('move','px_poz',PX_POZ.ref(),PX_CUP.ref())<>null()
                     || _result:=2;

::                      Jesli się udało przesunąć to dodaje do pojemnika komunikat
                        {? _komm=null()
                        || exec('add_komm','px_komm',_argskomm)
                        ?}
                     ?}
                  ||
::                   Pozycji planu zapamietuje tm stamp zrodlowego pojemnika
                     PX_CUP.cntx_psh();
                     PX_POZ.TM_SRC:=PX_POZ.PX_CUP().TM_START;
                     _can_continue:=PX_POZ.put();
                     PX_CUP.cntx_pop();

::                   Dziele pozycje planu na kawalek ktory ilosciowo odpowiada wykonaniu
                     {? var_pres('_cap_wyk')>100
                     || obj_del(_cap_wyk)
                     ?};
                     _cap_wyk:=exec('count_wyk','px_wyk',PX_WYK.ref());

                     {? var_pres('_cap_poz')>100
                     || obj_del(_cap_poz)
                     ?};
                     _cap_poz:=exec('count_eat','px_poz',PX_POZ.ref());

::                   Od zużyć pozycji planu odejmuje to co jest na wykonaniu
::                   w ten sposob otrzymam to co powinno zostac na starym kawalku
                     exec('arrays_sub_mod','#array',_cap_poz,_cap_wyk);

::                   Dalej nie moga przejsc minusy
                     exec('array_del_minus','#array',_cap_poz);

                     {? exec('array_sum','#array',_cap_poz)>0
                     ||
::                      Jesli na starej pozycji planu ma cos zostac to robie split
                        {? var_pres('_argssplit')>100
                        || obj_del(_argssplit)
                        ?};
                        _argssplit:=exec('split_a','px_poz');
                        _argssplit.SRC_POZ:=PX_POZ.ref();
                        _argssplit.DST_CUP:=PX_CUP.ref();
                        _argssplit.DST_STAT:=exec('status_wyk2','px_poz');
                        _argssplit.MOVE_WYK:=PX_WYK.ref();

                        _new_poz:=exec('split','px_poz',_argssplit,_cap_poz);

                        {? _new_poz<>null()
                        || _result:=2;
                           _wyk_moved:=1;

::                         Jesli stara pozycja planu jeszcze istnieje to zdejmuje jej zrodlowy
::                         pojemnik poniewaz jest jej juz niepotrzebny a moglby naszkudzic
::                         i zostac jesli pozycja nie bylaby przeplanowana (bo jest np zablokowana)
                           PX_POZ.cntx_psh(); PX_POZ.clear();
                           {? PX_POZ.seek(_pxpoz)
                           || PX_POZ.TM_SRC:=0;
                              _can_continue:=PX_POZ.put()
                           ?};
                           PX_POZ.cntx_pop();

::                         Jesli się udało przesunąć to dodaje do pojemnika komunikat
                           {? _komm=null()
                           || exec('add_komm','px_komm',_argskomm)
                           ?}
                        || _can_continue:=0
                        ?}
                     ||
::                      Z odejmowania wynika ze stara pozycja powinna miec same zera
::                      wiec jej nie dziele tylko przesuwam
                        {? exec('move','px_poz',PX_POZ.ref(),PX_CUP.ref())<>null()
                        || _result:=2;

::                         Jesli się udało przesunąć to dodaje do pojemnika komunikat
                           {? _komm=null()
                           || exec('add_komm','px_komm',_argskomm)
                           ?}
                        ?}
                     ?}
                  ?}
               ?}
            ?}
         ?};
         {? _wyk_moved>0
         ||
::          Jesli PX_WYK zostal przesuniety to wypadł z dziedziny
::          Sprawdzam czy zapamietalem nastepny rekord przed przesunieciem i jesli tak
::          to sie ustawiam na nim
            {? _ref_next<>null()
            || {? PX_WYK.seek(_ref_next)
               || _next:=1
               ?}
            || _next:=0
            ?}
         || _next:=PX_WYK.next()
         ?};
         _next>0
      !}
   ?}
?};
PX_CUP.cntx_pop();
PX_POZ.cntx_pop();
PX_WYK.cntx_pop();
PX_CUP.get();
PX_POZ.get();
{? _can_continue<=0
|| _result:=0
?};
_result


\nadwykon_pxgrp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Wykonuje obsluge nadwykonan dla wszystkich pozycji planu nalezacych do grupy
::   WE: _a - PX_GRP.ref()
::   WY: 0 - porazka
::       1 - sukces
::       2 - sukces, nastapilo przeplanowanie grupy
::----------------------------------------------------------------------------------------------------------------------
_pxgrp:=_a;

_result:=1;
_can_continue:=1;
_replan:=0;

PX_POZ.cntx_psh();
PX_POZ.index('TM_GRP');
PX_POZ.prefix(_pxgrp);
{? PX_POZ.first()
|| {!
   |? _can_continue:=exec('nadwykon_pxpoz','px_wyk',PX_POZ.ref());
      {? _can_continue=2
      || _replan:=1
      ?};
      PX_POZ.next() & _can_continue>0
   !};

:: Zostaly utworzone nadwykonania - nalezy przeplanowac grupe
   {? _replan>0
   || _argsfast:=exec('fast_replan_a','px_logix');
      _argsfast.PX_GRP:=_pxgrp;
      _argsfast.MOD_START:=1;

      _can_continue:=exec('grp_fast_replan','px_logix',_argsfast);
      {? _can_continue>0
      || _result:=2
      ?}
   ?}
?};
PX_POZ.cntx_pop();
{? _can_continue<=0
|| _result:=0
?};
_result


\must_replan_grp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy nalezy przeplanowac PX_GRP - tzn czy sa takie pozycje planu
::       ktore nie maja juz wykonan, ale zostaly przesuniete na jakies pojemniki podczas
::       rejstrowania nadwykonan. W takim przypadku powinny zostac przeplanowane
::   WE: _a - PX_GRP.ref
::   WY: 0 - nie trzeba przeplanowywac grupy
::       1 - grupa musi zostac przeplanowana
::----------------------------------------------------------------------------------------------------------------------
_pxgrp:=_a;

_result:=0;
_can_continue:=1;

PX_WYK.cntx_psh();
PX_WYK.index('POZ');
PX_POZ.cntx_psh();
PX_POZ.index('TM_GRP');
PX_POZ.prefix(_pxgrp);
{? PX_POZ.first()
|| {!
   |?
      {? exec('nadwykon_moved','px_poz')>0
      ||
::       Znalazlem pozycje planu ktora zostala przesunieta w wyniku nadwykonania - sprawdzam
::       czy sa jeszcze jakies PX_WYki do niej
         PX_WYK.prefix(PX_POZ.ref());
         {? PX_WYK.size()=0
         || _result:=1;
            _can_continue:=0
         ?}
      ?};
      PX_POZ.next() & _can_continue>0
   !}
?};
PX_POZ.cntx_pop();
PX_WYK.cntx_pop();
_result


\nadwyk_obj_add
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Uruchamia obsluge nadwykonan, po dodaniu/modyfikacji rekordow zrodlowych (ZLGD,PL_WYK) na zleceniu
::   WE: _a - PX_OBJ.ref
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_obj:=_a;

_result:=0;
_can_continue:=1;

_mainver:=exec('get_mainversion','px_ver');
PX_CONN.cntx_psh();
PX_CONN.index('VER');
PX_CONN.prefix(_mainver,_px_obj);
{? PX_CONN.first()
|| _argsfast:=exec('fast_replan_a','px_logix');
   _argsfast.MOD_START:=1;
   {!
   |? _can_continue:=exec('nadwykon_pxgrp','px_wyk',PX_CONN.PX_GRP);

::    Jesli grupa nie zostala przeplanowana, to sprawdzam czy musze ja przeplanowac
      {? _can_continue>0 & _can_continue<>2
      || {? exec('must_replan_grp','px_wyk',PX_CONN.PX_GRP)>0
         || _argsfast.PX_GRP:=PX_CONN.PX_GRP;
            _can_continue:=exec('grp_fast_replan','px_logix',_argsfast)
         ?}
      ?};
      PX_CONN.next() & _can_continue>0
   !}
?};
PX_CONN.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\nadwyk_obj_del
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Uruchamia obsluge nadwykonan, po usunieciu rekordow zrodlowych (ZLDG,PL_WYK) na zleceniu
::   WE: _a - PX_OBJ.ref
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_obj:=_a;

_result:=0;
_can_continue:=1;

_mainver:=exec('get_mainversion','px_ver');

PX_CONN.cntx_psh();
PX_CONN.index('VER');
PX_CONN.prefix(_mainver,_px_obj);
{? PX_CONN.first()
|| _argsfast:=exec('fast_replan_a','px_logix');
   _argsfast.MOD_START:=1;
   {!
   |? {? exec('must_replan_grp','px_wyk',PX_CONN.PX_GRP)>0
      || _argsfast.PX_GRP:=PX_CONN.PX_GRP;
         _can_continue:=exec('grp_fast_replan','px_logix',_argsfast)
      ?};
      PX_CONN.next() & _can_continue>0
   !}
?};
PX_CONN.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\blk_comm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wyswietla komunikat o zablokowaniu rejestracji przez innego uzytkownika
::   WE: _a - ID sesji
::----------------------------------------------------------------------------------------------------------------------
_ses_id:=_a;

FUN.emsg(
   'Pozycja niedostępna — redagowana przez użytkownika \'%1\' '
   'na terminalu \'%2\'.'@[KAL_UD.ses_info(_ses_id,'log_name'),KAL_UD.ses_info(_ses_id,'log_tty')]
)
;
~~


\px_wyk_find_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed Szukaj w oknie wertowania PX_WYK
::----------------------------------------------------------------------------------------------------------------------
PX_WYK.win_edit('SZUK');
exec('px_wyk_efld_opt','px_wyk');
~~


\px_wyk_find_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Po Szukaj w oknie wertowania PX_WYK
::----------------------------------------------------------------------------------------------------------------------
~~


\px_wyk_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wyświetl w oknie wertowania PX_WYK
::----------------------------------------------------------------------------------------------------------------------
PX_WYK.win_edit('RED');
exec('px_wyk_efld_opt','px_wyk');
PX_WYK.display();
~~


\px_wyk_efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Opcje pól w oknach redagowania PX_WYK
::----------------------------------------------------------------------------------------------------------------------
{! _it:=1..exec('il_wym','px_param')
|! {? _it<=PX_KONT.IL_WYM || _enable:='1' || _enable:='0' ?};
   PX_WYK.efld_opt('RED','enable='+_enable,,'CAP_WYK'+$_it);
   PX_WYK.efld_opt('RED','enable='+_enable,PX_KONT,'JM'+$_it);
   PX_WYK.efld_opt('SZUK','enable='+_enable,,'CAP_WYK'+$_it);
   PX_WYK.efld_opt('SZUK','enable='+_enable,PX_KONT,'JM'+$_it)
!};
~~


\has_wyki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy podany obiekt ma jakiekolwiek wykonania w wersji głównej planu
::   WE: [_a] - PX_OBJ.ref() lub bieżący rekord
::   WY: 0 - brak wykonań
::       1 - są jakieś wykonania
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_OBJ.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_OBJ.cntx_psh();
{? _ref<>null()
|| PX_OBJ.prefix();
   {? PX_OBJ.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _mainver:=exec('get_mainversion','px_ver');
   PX_WYK.cntx_psh();
   PX_WYK.index('PX_OBJ');
   PX_WYK.prefix(_mainver,PX_OBJ.ref());
   {? PX_WYK.size()>0
   || _result:=1
   ?};
   PX_WYK.cntx_pop();
   ~~
?};
PX_OBJ.cntx_pop();
_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:35 b8fceae7e301061a01b503e020d7a69a54b53d6da13553de2b4d90417c6d0932b402e44d63d7d2216c39512f7ac41fdc0e907ee7282e1261bc02eff974cb3bb45c7e6265ad33bce1e42e2ee173042c5f9bd9353d93a4b064fe604e10d0c92b9af13ed9d3f9e635527c93d8b720daaf7a9a68d1da4a9f391406712aa13a3ce625
