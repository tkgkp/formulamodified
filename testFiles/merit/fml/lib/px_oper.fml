:!UTF-8
::(c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: px_oper.fml [12.10]
:: Utworzony: 2011/07/12
:: Autor: jerry
::======================================================================================================================
:: Zawartosc:    Obsluga operacji dla planow strategicznych (WielowymiarowychPlanowPojemnosciowych - WWPP)
::======================================================================================================================


\PX_OPER_bD
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przed wyswietl pol w PX_OPER
::   WY: wynik dla przed wyswietl pola
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:=~~;
{? 3+_fld='CAP'
|| _fld:=3-_fld;
   _fldn:=_fld+1;
   _nfld:=#_fldn;
   {? _nfld>PX_OPER.PX_KONT().IL_WYM
   || _result:=exec('color_noavail','px_param');
      {? 1+cur_kwin()='e'
      || PX_OPER.efld_opt(cur_win(),'label_color='+((_result*',')-_result),,cur_afld())
      ?};
      ~~
   ?}
?};
_result


\PX_OPER_bE
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przed redakcja pol w PX_OPER
::   WY: mozna 1/niemozna 0
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
{? 3+_fld='CAP'
|| _fld:=3-_fld;
   _fldn:=_fld+1;
   _nfld:=#_fldn;
   {? _nfld<=PX_OPER.PX_KONT().IL_WYM
   || _fld:=_fld-1;

      {? 1+_fld='_'
      || _fld:=1-_fld;

         {? ($('form(PX_OPER.CAPF'+_fld+_fldn+')'))()=''
         || 1
         || 0
         ?}

      |? 1+_fld='F'
      || 1
      ?}
   ?}
?}


\PX_OPER_F3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Obsluga na F3 w PX_OPER
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
{? 3+_fld='CAP'
|| _fld:=3-_fld;
   _fldn:=_fld+1;
   _nfld:=#_fldn;
   {? _nfld<=PX_OPER.PX_KONT().IL_WYM
   || _fld:=_fld-1;

      {? 1+_fld='_'
      || _fld:=1-_fld;

         {? ($('form(PX_OPER.CAPF'+_fld+_fldn+')'))()=''
         || 1
         || 0
         ?}

      |? 1+_fld='F'
      || exec('F3_TPAR','tech_param')
      ?}
   ?}
?};
~~


\PX_OPER_aE
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Po redakcji pol w PX_OPER
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
{? 3+_fld='CAP'
|| _fld:=3-_fld;
   _fldn:=_fld+1;
   _nfld:=#_fldn;
   {? _nfld<=PX_OPER.PX_KONT().IL_WYM
   || _fld:=_fld-1;
      {? 1+_fld='_'
:: Wartosci
      || _fld:=1-_fld;
         {? ($('form(PX_OPER.CAPF'+_fld+_fldn+')'))()=''
         || {? fld()<0
            || FUN.emsg('Wartość nie może być ujemna.'@); 0
            || 1
            ?}
         || 0
         ?}
      |? 1+_fld='F'
:: Formuly
      || _fld:=1-_fld;
         {? var_pres('tpar')>100
         || {? fld()<>''
            || {? tpar.chk(fld())
               || ($('PX_OPER.CAP_'+_fld+_fldn+':=_a'))(tpar.calc(fld()));
                  1
               ?}
            || 1
            ?}
         || FUN.wdrerror('Nie powołano obiektu "tpar". Wykorzystanie formuł nie jest możliwe.'); 0
         ?}
      ?}
   ?}
?}


\PX_OPER_fmD
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Format wyswietlania pol w PX_OPER
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
{? 3+_fld='CAP'
|| _nfld:=#(_fld+1);
   _txt:='';
   {? _nfld>PX_OPER.PX_KONT().IL_WYM || _txt+='empty=1' ?};
   {? 'CAP_USE CAP_MAX CAP_MIN'*(7+_fld)
   || _txt+={? +_txt || ',' || '' ?}+'out_prec='+$($('PX_OPER.PX_KONT().PREC'+$_nfld))()
   ?};
   _txt
|? _fld='NROP'                        || 'out_prec=0'
                                      || ''
?}


\PX_OPER_fmE
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Format edycji pol w PX_OPER
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
{? 'CAP_USE CAP_MAX CAP_MIN'*(7+_fld) || _nfld:=#(_fld+1); 'in_prec='+$($('PX_OPER.PX_KONT().PREC'+$_nfld))()
|? _fld='NROP'                        || 'in_prec=0'
                                      || ''
?}


\Load_Px_Oper_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tablica parametrow dla Load_Px_Oper
::   WE: --
::   WY: tablica parametrow
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PxTex','TKTL','ZL','AutoImp','PX_TEX');
:: obiekt w ktorym jest Grid do ktorego ladujemy kontenery - domyslnie PxTex jezeli jest
_args.PxTex:=~~;
:: wskazanie na naglowek technologii
_args.TKTL:=null();
:: wskazanie na zlecenie
_args.ZL:=null();
:: czy automatycznie importowac z operacji gdy nie ma PX_OPERow?
_args.AutoImp:='P';
:: wskazanie na naglowek przepisu
_args.PX_TEX:=null();
:: zwracamy tablice
_args


\Px_Oper2OperTab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Aktualizacja danych PX_OPER w PxTex.OperTab
::   WE: _a - PX_OPER
::       _b - OperTab
::----------------------------------------------------------------------------------------------------------------------
_PX_OPER:=_a;
_OperTab:=_b;

_OperTab.STAGE_NR:=_PX_OPER.PX_STAGE().NR;
_OperTab.STAGENAM:=8+$_PX_OPER.PX_STAGE;
_OperTab.STAGEREF:=#_PX_OPER.PX_STAGE;
_OperTab.NAM:=_PX_OPER.PX_KONT().SYMBOL;
_OperTab.CAP_USE1:=_PX_OPER.CAP_USE1;
_OperTab.CAP_USE2:=_PX_OPER.CAP_USE2;
_OperTab.CAP_USE3:=_PX_OPER.CAP_USE3;
_OperTab.CAP_USE4:=_PX_OPER.CAP_USE4;
_OperTab.CAP_USE5:=_PX_OPER.CAP_USE5;
_OperTab.JM1:=_PX_OPER.PX_KONT().JM1().KOD;
_OperTab.JM2:=_PX_OPER.PX_KONT().JM2().KOD;
_OperTab.JM3:=_PX_OPER.PX_KONT().JM3().KOD;
_OperTab.JM4:=_PX_OPER.PX_KONT().JM4().KOD;
_OperTab.JM5:=_PX_OPER.PX_KONT().JM5().KOD;

_OperTab.ICON:='';
_OperTab.COLOR:='';
_OperTab.PX_SET:=$PX_OPER.PX_KONT().PX_SET;
_OperTab.SET_SYM:=PX_OPER.PX_KONT().PX_SET().SYMBOL;
{? PX_OPER.PX_STAGE().PX_SET<>PX_KONT.PX_SET
|| _OperTab.SET_OK:='N';
   _OperTab.cntx_psh();
   _OperTab.clear();
   {? _OperTab.seek(_OperTab.PARENT,)
   || _OperTab.SET_OK:='N';
      _OperTab.put()
   ?};
   _OperTab.cntx_pop()
?};
_OperTab.OPER_NAM:=_PX_OPER.name();
_OperTab.OPER_REF:=#_PX_OPER.ref();
_OperTab.KONT_NAM:=ref_name(_PX_OPER.PX_KONT);
_OperTab.KONT_REF:=#_PX_OPER.PX_KONT;
_OperTab.REC_KIND:='O';
_OperTab.KONT_DIM:=PX_OPER.PX_KONT().IL_WYM;
_OperTab.STGCOLOR:=PX_OPER.PX_STAGE().KOLOR;
::_OperTab.COLORCOL:=3+exec('txt_plan_fwd','px_param');
~~


\Load_Px_Oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Laduje operacje do PxTex (Grid'a)
::   WE: _args
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
{? _=1
|| _args:=_a
|| _args:=exec('Load_Px_Oper_a','px_oper');
   {? var_pres('PxTex')>100 || _args.PxTex:=PxTex ?}
?};

{? var_pres('PxTex',_args)<100
|| FUN.wdrerror('Błędny typ argumentu .PxTex w Load_Px_Oper/px_oper.');
   return(0)
?};

_loc:=obj_new('Grid','GridNdx','Stages','OperTab');
:: Tabela do ktorej mamy Grid'a z kontenerami
_loc.Grid:=_args.PxTex.GridTab;
:: Tabela z etapami
_loc.Stages:=_args.PxTex.StageTab;
_loc.OperTab:=_args.PxTex.OperTab;

Cntx.psh(_loc.Grid, PX_OPER, PX_STAGE, PX_SET);
Cntx.clr(_loc.Grid, PX_OPER, PX_STAGE);

PX_OPER.index('UNIQALL');

:: najpierw ustalamy indeks dla PX_STAGE w zaleznosic od tego czy mamy TKTL czy PX_TEX, jezeli nie to nie robimy
{? {? _args.TKTL<>null()   || PX_STAGE.index('TKTL_NR'); PX_STAGE.prefix($_args.TKTL);   1
   |? _args.PX_TEX<>null() || PX_STAGE.index('TEX_NR');  PX_STAGE.prefix(_args.PX_TEX); 1
   ?}
|| {? PX_STAGE.first()=0
    & _args.PxTex.ViewOnly=0
   ||
      _impwar:=0;
      _importuj:=0;
      _kopiuj:=0;
      {? _args.AutoImp='T' & _args.TKTL<>null()
      || _importuj:=1

      |? _args.AutoImp='P'
      ||
         _copy_only:=0;

::       Dla zlecen warsztatowych tylko kopiowanie
         {? _args.ZL<>null()
         || _typ:=exec('FindAndGet','#table',ZL,_args.ZL,,"ZL.TYP().TYP",'');
            {? _typ='W'
            || _copy_only:=1
            ?}
         ?};

         {? _copy_only=1
         ||
            _choice:=FUN.choice(exec('form','#string','L'
                                 ,'Przepis planistyczny jest pusty.'
                                 ,''
                                 ,'Możliwe rozwiązania:'
                                 ,' ● Kopiuj   - system skopiuje przepis ze wskazanego przepisu.'
                                 )
                            ,
                            ,'Kopiuj'
                            );
            {? _choice=1
            || _kopiuj:=1
            ?}

         ||
            _choice:=FUN.choice(exec('form','#string','L'
                                 ,'Przepis planistyczny jest pusty.'
                                 ,''
                                 ,'Możliwe rozwiązania:'
                                 ,' ● Importuj - system spróbuje utworzyć przepis na podstawie istniejącej technologii,'
                                 ,' ● Kopiuj   - system skopiuje przepis ze wskazanego przepisu.'
                                 )
                            ,
                            ,'Importuj'
                            ,'Kopiuj'
                            );
            {? _choice=1
            || _importuj:=1
            |? _choice=2
            || _kopiuj:=1
            ?}
         ?}
      ?};
      {? _importuj=1
      ||
         {? _args.ZL<>null()
         ||
::          jesli widok jest w kontekscie zlecenia to importuje na podstawie zlecenia
            exec('zl_tex_update','px_tex',_args.ZL)
         ||
::          widok w kontekscie technologii - kopiowanie na podstawie technologii
            _impargs:=exec('import_toper_a','px_oper');
            VAR.cntx_psh();
            TKTL.cntx_psh();
            TKTL.clear();
            TKTL.win_sel('SLO_');
            {? ( ( TKTL.seek(_args.TKTL)
                 & _args.AutoImp='T'
                 )
               | TKTL.select(,1,10,'M:M')
               )
            || _impargs.TKTLsrc:=TKTL.ref();
               _ask:=exec('warn_not_akc','px_tex');
               _nast:=exec('pxnasttab','px_nast');
               {? _args.TKTL<>null()   || _impargs.TKTLdest:=_args.TKTL
               |? _args.PX_TEX<>null() || _impargs.PX_TEXd:=_args.PX_TEX
               ?};
               {? _ask>0
               || exec('import_toper','px_oper',_impargs,_nast);
                  exec('importtoper','px_nast',_nast,TKTL.ref());
                  _nast.drop()
               ?}
            ?};
            TKTL.cntx_pop();
            VAR.cntx_pop()
         ?}
      |? _kopiuj=1
      || _tabela:=exec('PX_TEX_posbsrc','px_tex');
         {? _tabela.select()
         || _copyargs:=exec('PX_TEX_copy_a','px_tex');
            {? {? _tabela.SRC='TKTL'
               || _copyargs.TKTL_s:=exec('FindAndGet','#table',TKTL,_tabela.REF_NUMB,_tabela.REF_NAME,"ref()",null());1
               |? _tabela.SRC='PX_TEX'
               || _copyargs.PX_TEX_s:=exec('FindAndGet','#table',PX_TEX,_tabela.REF_NUMB,_tabela.REF_NAME,"ref()",null());1
               ?}
            || {? _args.TKTL<>null()   || _copyargs.TKTL_d:=_args.TKTL
               |? _args.PX_TEX<>null() || _copyargs.PX_TEX_d:=_args.PX_TEX
               ?};
               exec('PX_TEX_copy','px_tex',_copyargs)
            ?}
         ?}
      ?}
   ?};
   {? PX_STAGE.first()
   ||
      _loc.GridNdx:=_loc.Grid.ndx_tmp(,
                                      ,'TAB_NAM',,
                                      ,'TAB_REF',,
                                     );
      _loc.Grid.index(_loc.GridNdx);
      _loc.Grid.prefix();
      {? _loc.Grid.first()
      || {!|? _loc.Grid.USED:='N'; _loc.Grid.next() !};
         ~~
      ?};

      {!
      |?
         _loc.Stages.NR:=PX_STAGE.NR;
         _loc.Stages.NAZ:=PX_STAGE.NAZWA;
         _loc.Stages.NAME:=PX_STAGE.name();
         _loc.Stages.REF:=#PX_STAGE.ref();
         _loc.Stages.STGCOLOR:=PX_STAGE.KOLOR;
         _loc.Stages.add();
         _loc.OperTab.blank(1);
         _loc.OperTab.REC_KIND:='S';
         _loc.OperTab.STAGE_NR:=PX_STAGE.NR;
         _loc.OperTab.STGCOLOR:=PX_STAGE.KOLOR;
::         _loc.OperTab.COLORCOL:=3+exec('txt_plan_fwd','px_param');

         _size:=PX_STAGE.size();
         _form_dokl:=+($_size);
         _form_dokl:=-1*_form_dokl;

         _loc.OperTab.NAM:='Etap '+form(PX_STAGE.NR,_form_dokl)+' '+PX_STAGE.NAZWA;
         {? PX_STAGE.CONN_OK='N'
         || _loc.OperTab.COLOR:='PX_STAGE#01#01'
         || _loc.OperTab.COLOR:='PX_STAGE#01#02'
         ?};
         _loc.OperTab.STAGENAM:=PX_STAGE.name();
         _loc.OperTab.STAGEREF:=#PX_STAGE.ref();
         _loc.OperTab.CONN_OK:=PX_STAGE.CONN_OK;
         _loc.OperTab.PX_SET:=$PX_STAGE.PX_SET;
         _loc.OperTab.SET_SYM:=PX_STAGE.PX_SET().SYMBOL;
         _loc.OperTab.NAST:=exec('nast4oper','px_nast',PX_STAGE.ref());
         {? _loc.OperTab.add()
         || _parent:=#_loc.OperTab.ref();
            PX_OPER.prefix(PX_STAGE.ref());
            {? PX_OPER.first()
            ||
               {? _loc.Grid.first()
               || {!
                  |?
                     {? _loc.Grid.find_key(ref_name(PX_OPER.PX_KONT),#PX_OPER.PX_KONT)
                     || {? _args.PxTex.MaxCol>=_loc.Stages.NR
                        || _loc.Grid[_loc.Stages.NR]:=$PX_OPER.ref()+8
                        ?};
                        _loc.Grid.USED:='T';
                        _loc.Grid.put()
                     ?};

                     _loc.OperTab.blank();
                     _loc.OperTab.PARENT:=_parent;
                     exec('Px_Oper2OperTab','px_oper',PX_OPER,_loc.OperTab);
                     _loc.OperTab.add();

                     PX_OPER.next()
                  !}
               ?}
            ?}
         ?};
         PX_STAGE.next()
      !};
      _args.PxTex.OperTab.first();
      {? _loc.Stages.NR>_args.PxTex.DimX || _args.PxTex.DimX:=_loc.Stages.NR ?};

      _loc.Grid.ndx_drop(_loc.GridNdx);
      ~~
   ?}
?};
Cntx.pop(_loc.Grid, PX_OPER, PX_STAGE, PX_SET);
1


\PxTexOperbrek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: przed rekord w PxTex.OperTab
::   WE: _a - PxTex
::   WY: wynik przed rekord
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PxTex');
_args.PxTex:=_a;

_loc:=obj_new('Tab');
_loc.Tab:=_args.PxTex.OperTab;

PX_STAGE.cntx_psh();
PX_STAGE.clear();
{? PX_STAGE.seek(_loc.Tab.STAGEREF,_loc.Tab.STAGENAM)
||
   PX_VAR.PX_STAGE:=PX_STAGE.ref();
:: Ladowanie tabelki powiazan operacji technologicznych z etapami przepisu
   exec('load_tie_toper','px_tex',_args.PxTex,PX_STAGE.ref());
:: Okna TieSel nie ma w grupie jesli TKTL jest nullem
   grp_disp(_args.PxTex.TieTabP,_args.PxTex.TieSelP);
   grp_disp(_args.PxTex.TieTabN,_args.PxTex.TieSelN);

::    Doklejanie do tytulu okna nazwy etapu
   _args.PxTex.TieTabP.hdr_sel();
   _args.PxTex.TieTabP.hdr_sel(PX_STAGE.NAZWA);

   _args.PxTex.TieTabN.hdr_sel();
   _args.PxTex.TieTabN.hdr_sel(PX_STAGE.NAZWA);

   exec('prefix_tmat','px_mat',PX_STAGE.ref());
:: Doklejanie do tytulu okna nazwy etapu
   _args.PxTex.MaterTab.hdr_sel();
   _args.PxTex.MaterTab.hdr_sel(' powiązane z etapem: %1'@[PX_STAGE.NAZWA])
||
   PX_VAR.PX_STAGE:=null();
   exec('load_tie_toper','px_tex',_args.PxTex,null());
   ~~
?};

{? _loc.Tab.PARENT=0
|| _loc.Tab.actions(_args.PxTex.OperSel,'',,1);
   ~~

|? _loc.Tab.PARENT>0
|| _loc.Tab.actions(_args.PxTex.OperSel,'',,1);
   exec('FindAndGet','#table',PX_OPER,_loc.Tab.OPER_REF,_loc.Tab.OPER_NAM
       ,"exec('Px_Oper2OperTab','px_oper',PX_OPER,_param);_param.put()"
       ,null()
       ,_loc.Tab
       );
   ~~
?};
PX_STAGE.cntx_pop();
Color.fnd_kol(_args.PxTex.OperTab.COLOR)


\import_toper_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tablica parametrow dla exec('import_toper','px_oper')
::   WE: --
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PxTex'
               ,'TKTLsrc'
               ,'TKTLdest'
               ,'PX_TEXd'
               ,'NRNOP'
               ,'Komm'
               ,'Lp'
               ,'Qcoef'
               ,'Complex'
               ,'STAGE_1'
               ,'RECUR'
               ,'LAST_STG'
               ,'LAST_NR'
               ,'TKTLorg'
               ,'IS_POLF'
               ,'nToper'
               ,'SIMULATE'
               ,'SIM_FML'
               );
:: obiekt w ktorym jest Grid
_args.PxTex:={? var_pres('PxTex')>100 || PxTex || ~~ ?};
:: TKTL zrodlowa
_args.TKTLsrc:=null();
:: TKTL docelowa
_args.TKTLdest:=null();
:: PX_TEX docelowa
_args.PX_TEXd:=null();
:: Nr operacji nadrzednej
_args.NRNOP:=0;
:: Wskazanie na obiekt komunikatow
_args.Komm:=~~;
:: Liczba porzadkowa operacji
_args.Lp:=0;
:: wspolczynnik przeliczeniowy
_args.Qcoef:=1;
:: czy importowac przepis zlozony, gdy wystapia polfabrykaty ('T'ak, 'N'ie, 'P'ytac)
_args.Complex:='P';
:: czy inicjowany jest pierwszy etap procesu
_args.STAGE_1:=1;
:: czy wywolanie rekurencyjne - dla wywolan rekurencyjnych nie sa tworzone powiazania miedzy PX_STAGE
:: bo to powinno zostac zrobione raz na samym koncu, w wywolaniu nierekurencyjnym
_args.RECUR:=0;

:: Ref ostatnio wygenerowanego PX_STAGE'a
_args.LAST_STG:=null();

:: NR ostatnio utworzonego PX_STAGE'a
_args.LAST_NR:=-1;

:: Dla wywolan rekurencyjnych - ref TKTL na samej gorze z ktorego rozpoczynano
_args.TKTLorg:=null();

:: Czy funkcja importuje z polfabrykat?
_args.IS_POLF:=0;

:: numer operacji z karty nadrzednej
_args.nToper:=null();

:: Tryb symulacji - nie zakłada żadnych rekordów, zamiast tego wykonuje formułę SIM_FML
_args.SIMULATE:=0;
_args.SIM_FML:="";

:: zwracamy tablice
_args


\import_toper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Import PX_OPER z TOPER zlecenia
::   WE: _args - wynik formuly exec('import_toper_a','px_oper')
::       _nast - wynik formuly exec('pxnasttab','px_nast')
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_args:={? _>0 || _a || exec('import_toper_a','px_oper') ?};
_nast:={? _>1 || _b || exec('pxnasttab','px_nast') ?};
{? type_of(_args.PxTex)<100
|| FUN.wdrerror('Błędny typ argumentu .PxTex w import_toper/px_oper');
   return(0)
?};
{? type_of(_args.Komm)<100
|| _args.Komm:=obj_new(@.CLASS.JCQ);
   _args.Komm.init();
   ~~
?};

_result:=0;
_can_continue:=0;

_loc:=obj_new('PX_KONT');
_loc.PX_KONT:=null();

{? _args.TKTLorg=null()
|| _args.TKTLorg:=_args.TKTLsrc
?};

_processed:=exec('toper_processed','px_oper');

Cntx.psh(PX_OPER, TKTL, TOPER, TMAT, PX_KONT, PX_STAGE, PX_MAT);
Cntx.clr(PX_OPER, TKTL, TOPER, TMAT, PX_KONT, PX_STAGE, PX_MAT);

NASTOPER.cntx_psh();
NASTOPER.index('OPNAST');

:: Sprawdzenie, czy sa polfabrykaty nie pobierane z magazynu
_polfabr:=0;
{? _args.Complex='T' | _args.Complex='P'
||
   TMAT.index('ANL');
   TMAT.prefix('T',_args.TKTLsrc);
   {? TMAT.first()
   || {!
      |?
         {? (TMAT.KTL<>null() | TMAT.DFLT_KTL='T') & TMAT.MAG<>'T'
         || _polfabr:=1
         ?};
         TMAT.next() & _polfabr=0
      !}
   ?}
?};
_opg:=exec('get','#params',500367);
{? _polfabr
|| {? (_opg<>'N')
      & ((_args.Complex='T') | (_opg='T'))
   || _polfabr:=1
   || _polfabr:=0
   ?};
   _nast.polfabr:=_polfabr
?};
_rec_args:=exec('import_toper_a','px_oper');

exec('array_copy','libfml',_args,_rec_args,2);

_args_stg:=exec('stage_create_a','px_oper');
:: jezeli karta z surowcami do karty i polfabrykaty, to tutaj rekurencja
{? _polfabr
::   & exec('FindAndGet','#table',TKTL,_args.TKTLsrc,,"TYP().SUR",'O')='K'
||
:: Sprawdzane surowce bez przypisanej operacji
   TMAT.index('ANNL');
   TMAT.prefix('T',_args.TKTLsrc,null());
   {? TMAT.first()
   || {!
      |?
         {? ((TMAT.KTL<>null()) | (TMAT.DFLT_KTL='T')) & TMAT.MAG<>'T'
         || _rec_args.TKTLsrc:=exec('get_zktl4TMAT','px_oper',TMAT.ref());
            _rec_args.TKTLorg:=_args.TKTLsrc;
            _rec_args.NRNOP:=0;
            _rec_args.IS_POLF:=1;
            _rec_args.Lp:=_args.Lp;
            _rec_args.LAST_STG:=_args.LAST_STG;
            _rec_args.LAST_NR:=_args.LAST_NR;
            _rec_args.nToper:=_args.nToper;
            _rec_args.Complex:='T';
            _rec_args.Qcoef:=TMAT.WARB/exec('FindAndGet','#table',TKTL,_rec_args.TKTLsrc,,"XJM",1)*_args.Qcoef;
            _rec_args.STAGE_1:=1;
            _rec_args.RECUR:=1;
            exec('import_toper','px_oper',_rec_args,_nast);
            _args.Lp:=_rec_args.Lp;
            _args.LAST_STG:=_rec_args.LAST_STG;
            _args.LAST_NR:=_rec_args.LAST_NR;
            _args.nToper:=_rec_args.nToper;
            _args_stg.HAS_POLF:=1;
            ~~
         ?};
         TMAT.next()
      !}
   ?}
?};
:: Szukam pierwszego TOPERA od ktorego zaczne analize
_first:=exec('toper_first','px_oper',_args.TKTLsrc,_processed);

{? _args.nToper=null()
|| _args.nToper:=TOPER.ref()
?};

{? _first>0
||
   _args_stg.TKTLdest:=_args.TKTLdest;
   _args_stg.PX_TEXd:=_args.PX_TEXd;
   _args_stg.Lp:=_args.Lp;
   _args_stg.Qcoef:=_args.Qcoef;
   _args_stg.Complex:=_args.Complex;
   _args_stg.STAGE_1:=_args.STAGE_1;
   _args_stg.LAST_STG:=_args.LAST_STG;
   _args_stg.LAST_NR:=_args.LAST_NR;
   _args_stg.nToper:=_args.nToper;
   _args_stg.TKTLorg:=_args.TKTLorg;
   _args_stg.Polfabr:=_polfabr;
   _args_stg.RECUR:=_args.RECUR;
   _args_stg.IS_POLF:=_args.IS_POLF;
   _args_stg.SIMULATE:=_args.SIMULATE;
   _args_stg.SIM_FML:=_args.SIM_FML;

   _stages_first:=exec('opers_starting_ending','tech_oper',_args.TKTLsrc);
   _can_create:=1;
   {? _stages_first.size()>1
   ||
::    Jeżeli technologia zaczyna się od dwóch operacji równoległych, to trzeba najpierw te operacje
::    przerobić na etapy, żeby drugi etap równoległy nie wylądował na końcu

      _can_create:=0;
      TOPER.cntx_psh();
      TOPER.prefix();
      {? _stages_first.first()
      || {!
         |?
            {? TOPER.seek(_stages_first.REF)
            ||
               _loc.PX_KONT:=null();
               _args_stg.LAST_STG:=_args.LAST_STG;
               _args_stg.LAST_NR:=_args.LAST_NR;
               _args_stg.STAGE_1:=_args.STAGE_1;
               _args_stg.nToper:=_args.nToper;
               _args_stg.CAN_REC:=0;
::             Z aktualnego TOPERa robie PX_STAGE
               _can_continue:=exec('toper2stage','px_oper',_args_stg,_processed,_nast);

               _args.Lp:=_args_stg.Lp;

               _args.STAGE_1:=0
            ?};
            _stages_first.next()
         !}
      ?};
      TOPER.cntx_pop()
   ?};

   {!
   |?
      _loc.PX_KONT:=null();
      _args_stg.CAN_REC:=1;
      _args_stg.CAN_CREATE:=_can_create;
      _args_stg.LAST_STG:=_args.LAST_STG;
      _args_stg.LAST_NR:=_args.LAST_NR;
      _args_stg.STAGE_1:=_args.STAGE_1;
      _args_stg.nToper:=_args.nToper;
::    Z aktualnego TOPERa robie PX_STAGE
      _can_continue:=exec('toper2stage','px_oper',_args_stg,_processed,_nast);

      _args.Lp:=_args_stg.Lp;

      _args.STAGE_1:=0;

::    Jesli sa jeszcze jakies bez poprzednikow to sie na nich ustawiam przerabiam od poczatku
      _first:=exec('toper_first','px_oper',_args.TKTLsrc,_processed);
      _first>0 & _can_continue>0
   !};

   _args.LAST_STG:=_args_stg.LAST_STG;
   _args.LAST_NR:=_args_stg.LAST_NR;
   _args.nToper:=_args_stg.nToper;
:: Po zaimportowaniu na PX_TEX aktualizuje mu XJM ze zrodlowego TKTL
   {? _can_continue>0 & _args.PX_TEXd<>null()
   || _xjm:=exec('FindAndGet','#table',TKTL,_args.TKTLsrc,,"XJM",1);
      _can_continue:=exec('xjm_set','px_tex',_args.PX_TEXd,_xjm)
   ?}
?};
Cntx.pop(PX_OPER, TKTL, TOPER, TMAT, PX_KONT, PX_STAGE, PX_MAT);
NASTOPER.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result


\toper_processed
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Zwraca definicje tabeli tymczasowej z przetworzonymi TOPERAMI
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(1,
:: 'POLE','TYP','Nazwa w oknie',
   'REF','STRING[16]','Ref sql TOPERa',
   'CONNS_OK','STRING[1]','Powiazania na PX_STAGE poprawne?'
);
_tab


\toper_first
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy w danej technologii sa jeszcze nieprzetworzone TOPERy ktore sa rozpoczeciem
::       procesu czyli nie posiadaja zadnych poprzednikow
::       UWAGA!! Zmienia kontekst tabeli TOPER (bufor i indeks)
::   WE: _a - TKTL.ref()
::       _b - tab_tmp() - tablica z przetworzonymi juz TOPERami
::   WY: 0 - nie udalo sie znalezc zadnego topera
::       1 - toper bez poprzednikow zostal znaleziony i znajduje sie w buforze tabeli
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
_processed:=_b;

_result:=0;
_can_continue:=1;

NASTOPER.cntx_psh();
NASTOPER.index('NASTOP');
TOPER.index('NNN');
TOPER.prefix(_tktl);

{? TOPER.first()
|| {!
   |?
::    Nie analizuje operacji zlozonych i TPZ bo one nie maja poprzednikow
      {? TOPER.PZ<>'Z' & TOPER.TPZ<>'T' & TOPER.ACT='T'
      ||
::       Sprawdzam czy operacja ma poprzedniki
         NASTOPER.prefix('T',TOPER.ref());
         {? NASTOPER.size()=0
         ||
::          Stoje na TOPERZE bez poprzednikow
::          Sprawdzam czy bylo juz przerabiane, jesli nie to przerywam i ustawiam sie na tym
            _processed.prefix($TOPER.ref);
            {? _processed.first()=0
            || _result:=1;
               _can_continue:=0
            ?}
         ?}
      ?};
      {? _can_continue>0
      || _can_continue:=TOPER.next()
      ?};
      _can_continue>0
   !}
?};
NASTOPER.cntx_pop();
_result


\stage_create_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Argumenty dla funkcji exec('stage_create','px_oper')
::   WY: obj_new
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new( 'TKTLdest'
               ,'PX_TEXd'
               ,'Lp'
               ,'Qcoef'
               ,'Complex'
               ,'STAGE_1'
               ,'LAST_STG'
               ,'LAST_NR'
               ,'TKTLorg'
               ,'Polfabr'
               ,'RECUR'
               ,'CAN_REC'
               ,'CAN_CREATE'
               ,'HAS_POLF'
               ,'IS_POLF'
               ,'nToper'
               ,'SIMULATE'
               ,'SIM_FML');

:: TKTL docelowa
_args.TKTLdest:=null();
:: PX_TEX docelowa
_args.PX_TEXd:=null();
:: Liczba porzadkowa operacji
_args.Lp:=0;
:: wspolczynnik przeliczeniowy
_args.Qcoef:=1;
:: czy importowac przepis zlozony, gdy wystapia polfabrykaty ('T'ak, 'N'ie, 'P'ytac)
_args.Complex:='P';
:: czy inicjowany jest pierwszy etap procesu
_args.STAGE_1:=1;
:: Ref ostatnio wygenerowanego PX_STAGE'a
_args.LAST_STG:=null();
:: NR ostatnio utworzonego PX_STAGE'a
_args.LAST_NR:=-1;
:: Dla wywolan rekurencyjnych - ref TKTL na samej gorze z ktorego rozpoczynano
_args.TKTLorg:=null();
_args.Polfabr:=0;
_args.CAN_REC:=1;
_args.CAN_CREATE:=1;
_args.RECUR:=0;

:: Czy operacja miala importowany polfabrykat przed soba?
_args.HAS_POLF:=0;

:: Czy operacja jest importowana z polfabrykatu?
_args.IS_POLF:=0;

:: toper nadrzedny
_args.nToper:=null;

:: Tryb symulacji - nie zakłada żadnych rekordów, zamiast tego wykonuje formułę SIM_FML
_args.SIMULATE:=0;
_args.SIM_FML:="";

:: zwracamy tablice
_args


\toper2stage
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Tworzy PX_STAGE'e na podstawie calej sciezki od aktualnego topera poprzez wszystkie jego nastepniki
::       az do momentu w ktorym nastepniki sie koncza
::   WE: _args - obj_new - obiekt z parametrami - wynik formuly exec('stage_create_a','px_oper')
::       _b - tab_tmp - tabela z juz przetworzonymi TOPERami, wynik dzialania exec('toper_processed','px_oper')
::       _c - obj_new - obiekt do obsługi następników - wynik formuły exec('pxnasttab','px_nast')
::   WY: 0 - nie udalo sie dodac PX_STAGE lub PX_OPER
::       1 - dodano poprawnie PX_STAGE i PX_OPER
::       2 - dodano poprawnie PX_STAGE i PX_OPER ale z wykrzykniczkiem informujacym o niepoprawnych powiazaniach
::----------------------------------------------------------------------------------------------------------------------
_args:=~~;
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('stage_create_a','px_oper')
?};
_processed:=_b;

_nast:={? _>2 || _c || exec('pxnasttab','px_nast') ?};
_result:=0;
_can_continue:=1;

TOPER.cntx_psh();
_processed.cntx_psh();
TMAT.cntx_psh();

_rec_args:=exec('stage_create_a','px_oper');
exec('array_copy','libfml',_args,_rec_args,1);

:: Zapamietuje nr i ref etapu na ktory wrocic po wykonaniu siebie
_ret_nr:=_args.LAST_NR;
_ret_ref:=_args.LAST_STG;
_ntoper:=_nast.ntoper;

{? _args.Polfabr>0 & _args.CAN_CREATE>0
||
   TMAT.index('ANNL');
   TMAT.prefix('T',TOPER.NRK,TOPER.ref());
   _args_pol:=exec('import_toper_a','px_oper');

   {? TMAT.first()
   || {!
      |?
         {? ((TMAT.KTL<>null()) | (TMAT.DFLT_KTL='T')) & TMAT.MAG<>'T'
         || _args_pol.TKTLsrc:=exec('get_zktl4TMAT','px_oper',TMAT.ref());
            _args_pol.TKTLorg:=_args.TKTLdest;
            _args_pol.TKTLdest:=_args.TKTLdest;
            _args_pol.PX_TEXd:=_args.PX_TEXd;
            _args_pol.NRNOP:=0;
            _args_pol.RECUR:=1;
            _args_pol.IS_POLF:=1;
            _args_pol.Lp:=_args.Lp;
            _args_pol.LAST_STG:=_args.LAST_STG;
            _args_pol.LAST_NR:=_args.LAST_NR;
            _args_pol.nToper:=_args.nToper;
            _args_pol.Complex:='T';
            _args_pol.SIMULATE:=_args.SIMULATE;
            _args_pol.SIM_FML:=_args.SIM_FML;
            _args_pol.Qcoef:=TMAT.WARB/exec('FindAndGet','#table' ,TKTL
                                                                  ,_args_pol.TKTLsrc
                                                                  ,
                                                                  ,"XJM",1)*_args.Qcoef;
            _args_pol.STAGE_1:=1;
            exec('import_toper','px_oper',_args_pol,_nast);
            _args.Lp:=_args_pol.Lp;
            _args.LAST_STG:=_args_pol.LAST_STG;
            _args.LAST_NR:=_args_pol.LAST_NR;
            _args.nToper:=_args_pol.nToper;
            _args.HAS_POLF:=1;
            ~~
         ?};
         TMAT.next()
      !}
   ?}
?};

{? _args.CAN_CREATE>0
||
:: Uruchamiam tworzenie PX_STAGE na podstawie aktualnego TOPERA
   _result:=exec('stage_create','px_oper',_args,_processed,_nast)
|| _result:=1
?};
{? _args.CAN_REC>0 & _result>0
||
   _rec_args.nToper:=#TOPER.ref;
:: Dla kazdego z nastepnikow uruchamiam rekurencyjnie
   NASTOPER.cntx_psh();
   NASTOPER.index('OPNAST');
   NASTOPER.prefix('T',TOPER.ref());
   {? NASTOPER.first()
   ||
      _rec_args.Lp:=_args.Lp;
      _rec_args.STAGE_1:=0;
      _rec_args.RECUR:=1;

      _rec_args.CAN_REC:=0;
      _rec_args.CAN_CREATE:=1;
::    W pierwszej pętli tworzę operacje dla wszystkich następników
      {!
      |?
         _rec_args.LAST_STG:=_args.LAST_STG;
         _rec_args.LAST_NR:=_args.LAST_NR;
         _rec_args.nToper:=_args.nToper;

         NASTOPER.NRNAST();
::       Stoje na nastepniku, tworze z niego PX_STAGE

::       Sprawdzam czy nastepnik byl juz przetwarzany na PX_STAGE
         _processed.prefix($TOPER.ref());
         {? _processed.first()=0
         ||
            PX_STAGE.cntx_psh();
::          !!! REKURENCJA !!!
            _can_continue:=exec('toper2stage','px_oper',_rec_args,_processed,_nast);
            _args.Lp:=_rec_args.Lp;
            PX_STAGE.cntx_pop()
         ?};
         NASTOPER.next() & _can_continue>0
      !};

      _rec_args.CAN_REC:=1;
      _rec_args.CAN_CREATE:=0;
::    W drugiej pętli dla każdego następnika uruchamiam rekurencyjnie
      {? NASTOPER.first()
      || {!
         |?
            _rec_args.LAST_STG:=_args.LAST_STG;
            _rec_args.LAST_NR:=_args.LAST_NR;
            _rec_args.nToper:=_args.nToper;

            NASTOPER.NRNAST();

::          !!! REKURENCJA !!!
            PX_STAGE.cntx_psh();
            _can_continue:=exec('toper2stage','px_oper',_rec_args,_processed,_nast);
            _args.Lp:=_rec_args.Lp;
            PX_STAGE.cntx_pop();

            NASTOPER.next() & _can_continue>0
         !}
      ?};

      _args.LAST_STG:=_rec_args.LAST_STG;
      _args.LAST_NR:=_rec_args.LAST_NR;
      _args.nToper:=_rec_args.nToper
   || _args.nToper:=null
   ?};
   NASTOPER.cntx_pop();
   ~~
?};

TMAT.cntx_pop();
_processed.cntx_pop();
TOPER.cntx_pop();
_result


\stage_create
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Tworzy PX_STAGE'a na podstawie aktualnego TOPERa
::       Kontekst pracy - rekord TOPER
::   WE: _a - _args - obj_new - obiekt z parametrami - wynik formuly exec('stage_create_a','px_oper')
::       _b - tab_tmp - tabela z juz przetworzonymi TOPERami, wynik dzialania exec('toper_processed','px_oper')
::       _c - obj_new - obiekt do obsługi następników - wynik formuły exec('pxnasttab','px_nast')
::   WY: 0 - nie udalo sie dodac PX_STAGE lub PX_OPER
::       1 - dodano poprawnie PX_STAGE i PX_OPER
::       2 - dodano poprawnie PX_STAGE i PX_OPER ale z wykrzykniczkiem informujacym o niepoprawnych powiazaniach
::           2 wystepuje tylko jesli TOPER mial wiecej niz 1 poprzednika
::       3 - dodano poprawnie PX_STAGE i PX_OPER ale z wykrzykniczkiem informujacym o niepoprawnych powiazaniach
::           3 wystepuje tylko jesli TOPER mial wiecej niz 1 nastepnika
::----------------------------------------------------------------------------------------------------------------------
_args:=~~;
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('stage_create_a','px_oper')
?};
_processed:=_b;

_nast:=_c;
_result:=0;
TKTL.cntx_psh();
TPKTL.cntx_psh();
_processed.cntx_psh();
_processed.clear();

PX_STAGE.clear();
PX_STAGE.blank(1);
PX_STAGE.TKTL:={? _args.TKTLdest<>null() || _args.TKTLdest || null() ?};
PX_STAGE.PX_TEX:={? _args.PX_TEXd<>null() || _args.PX_TEXd || null() ?};
PX_STAGE.NR:=(_args.Lp+=1);
_nazwa:={? TOPER.WEW='T' || TOPER.OPER().NA
                         || TOPER.TTOUT().NA
        ?};
{? PX_STAGE.TKTL<>null()
|| _nrk:='['+TOPER.NRK().NRK+' ('+TOPER.NRK().WER+')] - '
|| _nrk:=''
?};
PX_STAGE.NAZWA:=_nrk+_nazwa;
PX_STAGE.ALIGNMEN:='';
PX_STAGE.NKO:=TOPER.NKO;
PX_STAGE.TTM:=TOPER.TTM;
PX_STAGE.TPZ:=exec('get_tpz','tech_oper');
PX_STAGE.TOPER:=TOPER.ref();
PX_STAGE.RTOPER:=$TOPER.ref();

_added:=0;
{? _args.SIMULATE>0
|| _added:=_args.SIM_FML('PX_STAGE',_args)
|| _added:=PX_STAGE.add()
?};

{? _added>0
||
   TKTL.cntx_psh();
   _nast.add(PX_STAGE.ref,TOPER.ref,TOPER.NRK,null());
   TKTL.cntx_pop();
:: stemplujemy TOPERA utworzonym PX_STAGE
   {? _args.SIMULATE=0 & _args.PX_TEXd=null() & TOPER.NRK=_args.TKTLorg
   || exec('tie_toper2stage','px_tex',TOPER.ref(),PX_STAGE.ref())
   ?};

:: operacja wewnetrzna - gniazdo albo stanowisko, kooperacja - kontener specjalny
   _px_kont:={? TOPER.WEW='T'
             || {? TOPER.GRPOJ='G'
                || _PX_KONT:=exec('get_px_kont','px_kont','G',TOPER.GRUPA,'R');
                   {? _PX_KONT<>null()
                   || _PX_KONT
                   || exec('get_px_kont','px_kont','S',TOPER.TWRKPLG().ELEMENT,'R')
                   ?}
                || _PX_KONT:=exec('get_px_kont','px_kont','S',TOPER.PLACE,'R');
                   {? _PX_KONT<>null()
                   || _PX_KONT
                   || TWRKZPO.index('ELEMENTG');
                      TWRKZPO.prefix(TOPER.PLACE);
                      {? TWRKZPO.first()
                      || exec('get_px_kont','px_kont','G',TWRKZPO.GRUPA,'R')
                      || null()
                      ?}
                   ?}
                ?}
             |? TOPER.WEW='N'
             || {? TOPER.PX_KONT<>null()
                || TOPER.PX_KONT
                || _PX_KONT:=exec('get','#params',500360);
                   {? _PX_KONT<>''
                   || exec('get_px_kont4ver','px_kont',exec('get_mainversion','px_ver'),_PX_KONT)
                   || null()
                   ?}
                ?}
             || null()
             ?};
   PX_OPER.blank();
   PX_OPER.PX_STAGE:=PX_STAGE.ref();
   PX_OPER.PX_KONT:=_px_kont;
   PX_OPER.COMMENT:=_nazwa;

   {! _it:=1.. PX_OPER.PX_KONT().IL_WYM
   |!
      _prec:=($('PX_OPER.PX_KONT().PREC'+$_it+''))();

      {? TOPER.WEW='N'
      ||
::       w wymiar z jednostka miary z parametru 500382 - czas na kooperacje
         _coef_dg:=exec('coef_dg','px_kont',TOPER.PX_KONT,0,0);
         {? ($('PX_OPER.PX_KONT().JM'+$_it+'().KOD'))()=exec('get','#params',500382)
         || ($('PX_OPER.CAP_USE'+$_it+':=(TOPER.DAYS_K*_a)'))(_coef_dg);
            ($('PX_OPER.CAP_MAX'+$_it+':=_a'))(_coef_dg)
         ?};
::       Dla kooperacji zuzycia stale niezalezne od XJM
         PX_OPER.CONST:='T'

      |? TOPER.WEW='T'
      ||
::       w wymiar z jednostka miary z parametru 500380 - wrzucamy czas operacji
         {? TOPER.NTIME>0 & ($('PX_OPER.PX_KONT().JM'+$_it+'().KOD'))()=exec('get','#params',500380)
         || ($('PX_OPER.CAP_USE'+$_it+':=(TOPER.NTIME*{? TOPER.FIX_NORM=\'T\' || 1 || _a ?})$_b'))(_args.Qcoef,_prec)
         ?};

::       w wymiar z jednostka miary z parametru 500381 - wrzucamy czas maszynowy
         {? TOPER.MTIME>0 & ($('PX_OPER.PX_KONT().JM'+$_it+'().KOD'))()=exec('get','#params',500381)
         || ($('PX_OPER.CAP_USE'+$_it+':=(TOPER.MTIME*{? TOPER.FIX_NORM=\'T\' || 1 || _a ?})$_b'))(_args.Qcoef,_prec)
         ?};

::       stały czas operacji
         PX_OPER.CONST:=TOPER.FIX_NORM
      ?};

::    w wymiar zgodny z jednostka miary produktu - wrzucamy XJM
      {? ($('PX_OPER.PX_KONT().JM'+$_it+'().KOD'))()=TOPER.NRK().JM().KOD
      || ($('PX_OPER.CAP_USE'+$_it+':=(TOPER.NRK().XJM*_a)$_b'))(_args.Qcoef,_prec)
      ?};

::    w pozostale wymiary wrzucamy XJM przeliczone wg MJM produktu
      MJM.index('JP');
      MJM.prefix(TOPER.NRK().KTM,TOPER.NRK().JM,($('PX_OPER.PX_KONT().JM'+$_it))());
      {? MJM.first()
      || ($('PX_OPER.CAP_USE'+$_it+':=TOPER.NRK().XJM/MJM.PRZ'))()
      ?}
   !};

:: Generowanie PX_MAT - import surowcow
   _argsmat:=exec('import_tmat_a','px_mat');
   _argsmat.TKTL:=TOPER.NRK;
   _argsmat.TOPER:=TOPER.ref();
::   _argsmat.SurKO:=TOPER.NRK().TYP().SUR;
   _argsmat.PX_STAGE:=PX_STAGE.ref();
   _argsmat.Polfabr:=~_args.Polfabr;
   _argsmat.Qcoef:=_args.Qcoef;
:: Przejście po surowcach bez przypisanej operacji (dla pierwszego etapu w procesie)
   {? _args.STAGE_1
   || _argsmat.SurKO:='K';
      exec('import_tmat','px_mat',_argsmat)
   ?};
:: Przejście po surowcach przypisanych do operacji
   {? 1
::      _argsmat.SurKO='O' | (_argsmat.SurKO='K' & _args.STAGE_1)
   || _argsmat.SurKO:='O';
      exec('import_tmat','px_mat',_argsmat)
   ?};

   {? PX_OPER.PX_KONT<>null()
    & ( PX_KONT.name()=ref_name(PX_OPER.PX_KONT)
      | PX_KONT.use(ref_name(PX_OPER.PX_KONT))
      )
::             & PX_OPER.PX_KONT().A='T'
   || {? _args.SIMULATE=0
      || _can_continue:=PX_OPER.add()
      || _can_continue:=_args.SIM_FML('PX_OPER',_args)
      ?}
   || _can_continue:=1
   ?};

:: Przepisanie domyślnych formuł z zasobu na operację
   {? _can_continue>0
   || _can_continue:=exec('default_kont_formulas','px_oper')
   ?};

:: Wypelnianie zestawow planistycznych
   {? _can_continue>0 & exec('is_px_set','px_param')>0
   ||
      _can_continue:=exec('px_set_fill','px_stage',PX_STAGE.ref(),1,0)
   ?};

   {? _can_continue>0
   ||
      _result:=1;

      _args.LAST_STG:=PX_STAGE.ref();
      _args.LAST_NR:=PX_STAGE.NR;

      _processed.blank();
      _processed.REF:=$TOPER.ref();
      {? _result=2 | _result=3
      || _processed.CONNS_OK:='N'
      || _processed.CONNS_OK:='T'
      ?};
      _processed.add();
      ~~
   ?}
?};
TKTL.cntx_pop();
TPKTL.cntx_pop();
_processed.cntx_pop();
_result


\import_zgp_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Tablica parametrow dla exec('import_zgp','px_oper')
::   WE: --
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PxTex'
         ,'ZLsrc'
         ,'PX_TEXd'
         ,'Komm'
         ,'Lp'
         ,'Qcoef'
         ,'MODE'
         ,'KIND'
         );
:: obiekt w ktorym jest Grid
_args.PxTex:={? var_pres('PxTex')>100 || PxTex || ~~ ?};
:: Zlecenie zrodlowe
_args.ZLsrc:=null();
:: PX_TEX docelowa
_args.PX_TEXd:=null();
:: Wskazanie na obiekt komunikatow
_args.Komm:=~~;
:: Liczba porzadkowa operacji
_args.Lp:=0;
:: wspolczynnik przeliczeniowy
_args.Qcoef:=1;
:: tryb importowania: 1 - importuje wszystkie ZGPy, 2 - importuje tylko te ZGPy których nie ma jeszcze w przepisie
_args.MODE:=1;
:: rodzaj generowanego rzepisu 'P' - prosty, do kazdego podzlecenia, 'Z' - zintegrowany do naglowka zlecenia zlozonego
_args.KIND:='P';
:: zwracamy formule
_args


\import_zgp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Import PX_OPER z ZGP
::   WE: _args - wynik formuly exec('import_zgp_a','px_oper')
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_args:={? _=1 || _a || exec('import_zgp_a','px_oper') ?};
{? type_of(_args.PxTex)<100
|| FUN.wdrerror('Błędny typ argumentu .PxTex w import_zgp/px_oper');
   return(0)
?};
{? _args.PX_TEXd=null()
|| FUN.wdrerror('Błędny typ argumentu .PX_TEXd w import_zgp/px_oper. Argument nie może być null');
   return(0)
?};
{? type_of(_args.Komm)<100
|| _args.Komm:=obj_new(@.CLASS.JCQ);
   _args.Komm.init();
   ~~
?};

_result:=0;
_can_continue:=0;

_loc:=obj_new('PX_KONT');

_loc.PX_KONT:=null();

Cntx.psh(PX_OPER,ZL,M,JM,ZGH,ZGP,PX_KONT,PX_STAGE,PX_MAT);
Cntx.clr(PX_OPER,ZL,M,JM,ZGH,ZGP,PX_KONT,PX_STAGE,PX_MAT);

PX_OPER.index('UNIQALL');
:: UWAGA! NA RAZIE NIE SA UWZGLEDNIANE TPZ

{? ZL.seek(_args.ZLsrc)
||
:: jesli zlecenie zlozone i przewodniki do podzlecen to robie rekurencje
   {? ZL.RODZAJ='Z'
   ||
      ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? _args.KIND='P'
      ||
::       generacja wielu prostych przepisow
         _rec_args:=exec('import_zgp_a','px_oper');
         exec('array_copy','libfml',_args,_rec_args,2);
         {? ZL.first()
         || _ok:=1;
            {!
            |? _rec_args.ZLsrc:=ZL.ref();
::             !!! REKURENCJA !!!
               _ok:=_ok & exec('import_zgp','px_oper',_rec_args);
               ZL.next()
            !};
            _can_continue:=_ok
         ?}
      |? _args.KIND='Z'
      ||
::       generacja przepisu zintegrowanego do naglowka zlecenia zlozonego
         {? ZL.first()
         || _main_src:=_args.ZLsrc; _ok:=1;
            {!
            |?
::             !!! REKURENCJA !!!
               _args.ZLsrc:=ZL.ref();
               _ok:=_ok & exec('import_zgp','px_oper',_args);
               ZL.next()
            !};
            _can_continue:=_ok;
            _args.ZLsrc:=_main_src
         ?}
      ?};
      ZL.cntx_pop()
   ||
      ZGH.index('ZLNR');
      ZGH.prefix(ZL.ref());

      {? _args.MODE=2
      ||
         ZGP.index('ZLEC');
         ZGP.prefix(ZL.ref());
::       Jeśli dogenerowuje tylko brakujące ZGPy to muszę najpierw wszystkie
::       PX_STAGE przenumerować w obszar wolnych numerków, żeby indeks unikalny nie został
::       naruszony
         PX_STAGE.cntx_psh();
         PX_STAGE.index('TEX_PRV');
         PX_STAGE.prefix(_args.PX_TEXd);
         _nr:=PX_STAGE.size()+ZGH.size()+ZGP.size()+1;
         {? PX_STAGE.first()
         || {!
            |?
               PX_STAGE.NR:=_nr;
               PX_STAGE.put();
               _nr+=1;
               PX_STAGE.next()
            !}
         ?};
         PX_STAGE.cntx_pop()
      ?};

      ZGP.index('PNRPP');
      _zgp_num:=0;
      {? ZGH.first()
      ||
         {!
         |?

::          Na razie bez TPZ
            ZGP.prefix(ZGH.ref(),'N');

            {? ZGP.first()
            || {!
               |?
                  _zgp_num+=1;
::                Etap tylko wtedy, gdy powiazanie z zasobem (pomijamy przewodniki "techniczne")
                  _can_add:=0;
                  {? (ZGP.GRUPA<>null() | ZGP.PLACE<>null() | ZGP.WEW='N') & ZGP.PLANUJ='T'
                  || _can_add:=1
                  ?};
                  _add:=1;
                  {? _args.MODE=2
                  || {? ZGP.PX_STAGE<>null()
                     || _add:=0
                     ?}
                  ?};

                  {? _can_add>0
                  ||
::                   tworzymy etap o numerze operacji, a do niego dopniemy kontenery
                     {? _add>0
                     || _can_continue:=1;
                        PX_STAGE.blank(1)
                     || {? ZGP.PX_STAGE<>null()
                        || _can_continue:=1;
                           ZGP.PX_STAGE()
                        || _can_continue:=0
                        ?}
                     ?};
                     {? _can_continue>0
                     || PX_STAGE.PX_TEX:=_args.PX_TEXd;
::                      wyznaczam liczbe porzadkowa
                        {? _args.MODE=1
                        ||
                           _lp:=1;
                           PX_STAGE.cntx_psh();
                           PX_STAGE.index('TEX_NR');
                           PX_STAGE.prefix(_args.PX_TEXd);
                           _lp:=PX_STAGE.size()+1;
                           PX_STAGE.cntx_pop()
                        |? _args.MODE=2
                        ||
                           _lp:=_zgp_num
                        ?};

                        PX_STAGE.NR:=_lp;
                        PX_STAGE.NAZWA:=ZGH.NRPRZ+' '+ZGP.OPIS;
                        PX_STAGE.ALIGNMEN:='';
                        PX_STAGE.NKO:=ZGP.NKO;
                        PX_STAGE.TTM:=ZGP.TTM;
                        PX_STAGE.TPZ:=exec('get_tpz','zl_guide');
                        PX_STAGE.TOPER:=ZGP.TOPER;
                        PX_STAGE.RTOPER:=$ZGP.TOPER;
                        {? _add>0
                        || _can_continue:=PX_STAGE.add()
                        || _can_continue:=PX_STAGE.put()
                        ?}
                     ?};
                     _px_oper:=1;
                     {? _can_continue>0
                     ||
::                      stemplujemy ZGP utworzonym PX_STAGE
                        exec('tie_zgp2stage','px_tex',ZGP.ref(),PX_STAGE.ref());

::                      operacja wewnetrzna - gniazdo albo stanowisko, kooperacja - kontener specjalny
                        _loc.PX_KONT:={? ZGP.WEW='T'
                                      || {? ZGP.GRUPA<>null()
                                         || _PX_KONT:=exec('get_px_kont','px_kont','G',ZGP.GRUPA,'R');
                                            {? _PX_KONT<>null()
                                            || _PX_KONT
                                            || _PX_KONT:=exec('get_px_kont','px_kont','S',ZGP.PLACE,'R');
                                               {? _PX_KONT<>null()
                                               || _PX_KONT
                                               || TWRKZPO.index('ELEMENTG');
                                                  TWRKZPO.prefix(ZGP.PLACE);
                                                  {? TWRKZPO.first()
                                                  || exec('get_px_kont','px_kont','G',TWRKZPO.GRUPA,'R')
                                                  || null()
                                                  ?}
                                               ?}
                                            ?}
                                         || _PX_KONT:=exec('get_px_kont','px_kont','S',ZGP.PLACE,'R');
                                            {? _PX_KONT<>null()
                                            || _PX_KONT
                                            || TWRKZPO.index('ELEMENTG');
                                               TWRKZPO.prefix(ZGP.PLACE);
                                               {? TWRKZPO.first()
                                               || exec('get_px_kont','px_kont','G',TWRKZPO.GRUPA,'R')
                                               || null()
                                               ?}
                                            ?}
                                         ?}
                                      |? ZGP.WEW='N'
                                      || {? ZGP.PX_KONT<>null()
                                         || _PX_KONT:=ZGP.PX_KONT
                                         || _PX_KONT:=exec('get','#params',500360);
                                            {? _PX_KONT<>''
                                            || exec('get_px_kont4ver','px_kont',exec('get_mainversion','px_ver'),_PX_KONT)
                                            || null()
                                            ?}
                                         ?}
                                      || null()
                                      ?};
                        {? _add>0
                        || PX_OPER.clear();
                           PX_OPER.blank()
                        || PX_OPER.prefix(PX_STAGE.ref());
                           _px_oper:=PX_OPER.first()
                        ?};
                        {? _can_continue>0 & _px_oper>0
                        ||
                           PX_OPER.PX_STAGE:=PX_STAGE.ref();
                           PX_OPER.PX_KONT:=_loc.PX_KONT;
                           PX_OPER.COMMENT:=ZGP.OPIS;

                           _coef_napr:=1;
                           _il_napr:=exec('count_napr4zgp','braki');
                           {? _il_napr>0
                           || _coef_napr:=(ZGP.ILOSC-_il_napr)/ZGP.ILOSC
                           ?};
                           {! _it:=1.. PX_OPER.PX_KONT().IL_WYM
                           |!

                              _prec:=($('PX_OPER.PX_KONT().PREC'+$_it+''))();
                              {? ZGP.WEW='N'
                              ||
::                               w wymiar z jednostka miary z parametru 500382 - czas na kooperacje
                                 {? ($('PX_OPER.PX_KONT().JM'+$_it+'().KOD'))()=exec('get','#params',500382,2)
                                 || _coef_dg:=exec('coef_dg','px_kont',ZGP.PX_KONT,ZGP.TMSTARTK,ZGP.TMENDK);
                                    {? ZGP.TMSTARTK>0
                                    || _time:=(ZGP.TMENDK-ZGP.TMSTARTK)/exec('minute','#tm_stamp')/60
                                    || _time:=ZGP.DAYS_K*_coef_dg
                                    ?};
                                    ($('PX_OPER.CAP_USE'+$_it+':=_a'))(_time);
                                    ($('PX_OPER.CAP_MAX'+$_it+':=_a'))(_coef_dg)
                                 ?};
::                               Dla kooperacji zuzycia stale niezalezne od XJM
                                 PX_OPER.CONST:='T'
                              |? ZGP.WEW='T'
                              ||
::                               w wymiar z jednostka miary z parametru 500380 - wrzucamy czas operacji
                                 {? ZGP.NTIME>0 & ($('PX_OPER.PX_KONT().JM'+$_it+'().KOD'))()=exec('get','#params',500380,2)
                                 || ($('PX_OPER.CAP_USE'+$_it+':=(ZGP.NTIME*{? ZGP.FIX_NORM=\'T\' || 1 || _a ?})$_b'))(_args.Qcoef*_coef_napr,_prec)
                                 ?};

::                               w wymiar z jednostka miary z parametru 500381 - wrzucamy czas maszynowy
                                 {? ZGP.MTIME>0 & ($('PX_OPER.PX_KONT().JM'+$_it+'().KOD'))()=exec('get','#params',500381,2)
                                 || ($('PX_OPER.CAP_USE'+$_it+':=(ZGP.MTIME*{? ZGP.FIX_NORM=\'T\' || 1 || _a ?})$_b'))(_args.Qcoef*_coef_napr,_prec)
                                 ?}
                              ?};

::                            w wymiar zgodny z jednostka miary produktu - wrzucamy XJM
                              {? ($('PX_OPER.PX_KONT().JM'+$_it+'().KOD'))()=ZL.KTM().J().KOD
                              || ($('PX_OPER.CAP_USE'+$_it+':=(ZGP.ILOSC*_a)$_b'))(_args.Qcoef*_coef_napr,_prec)
                              ?};

::                            w pozostale wymiary wrzucamy XJM przeliczone wg MJM produktu
                              MJM.index('JP');
                              MJM.prefix(ZGH.ZLEC().KTM,ZL.KTM().J,($('PX_OPER.PX_KONT().JM'+$_it))());
                              {? MJM.first()
                              || ($('PX_OPER.CAP_USE'+$_it+':=(ZGP.ILOSC/MJM.PRZ*_a)$_b'))(_coef_napr,_prec)
                              ?}
                           !};

                           {? PX_OPER.PX_KONT<>null()
                            & ( PX_KONT.name()=ref_name(PX_OPER.PX_KONT)
                              | PX_KONT.use(ref_name(PX_OPER.PX_KONT))
                              )
::                         & PX_OPER.PX_KONT().A='T'
                           || {? _add>0
                              || _can_continue:=PX_OPER.add()
                              || _can_continue:=PX_OPER.put()
                              ?}
                           || _can_continue:=1
                           ?};

::                         Przepisanie domyślnych formuł z zasobu na operację
                           {? _can_continue>0
                           || _can_continue:=exec('default_kont_formulas','px_oper')
                           ?}
                        ?}
                     ?};

                     {? _add>0
                     ||
::                      Wypelnianie zestawow planistycznych
                        {? _can_continue>0 & exec('is_px_set','px_param')>0
                        || _can_continue:=exec('px_set_fill','px_stage',PX_STAGE.ref(),1,0)
                        ?};

::                      Generowanie PX_MAT - import surowcow
                        _argsmat:=exec('import_zlim_a','px_mat');
                        _argsmat.ZGP:=ZGP.ref();
                        _argsmat.PX_STAGE:=PX_STAGE.ref();
                        _argsmat.ZL:=ZGP.ZL;
                        exec('import_zlim','px_mat',_argsmat);
                        obj_del(_argsmat)
                     ?}
                  || _can_continue:=1
                  ?};
                  ZGP.next() & _can_continue>0
               !}
            ?};
            ZGH.next()
         !}
      ?}
   ?}
?};
Cntx.pop(PX_OPER,ZL,M,JM,ZGH,ZGP,PX_KONT,PX_STAGE,PX_MAT);
{? _can_continue>0
|| _result:=1
?};
_result


\PX_OPER_edt_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Ustala i ustawia okienko edycyjne dla podanego PX_OPER
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
_edt:='RED';

{? PX_OPER.PX_STAGE().TKTL().TYP().PAR='T'
|| _edt:='REDP'
?};

{! _it:=1.. PX_OPER.PX_KONT().IL_WYM
|!
   _fuse:=($('PX_OPER.CAPFUSE'+$_it+''))();
   _fmin:=($('PX_OPER.CAPFMIN'+$_it+''))();
   _fmax:=($('PX_OPER.CAPFMAX'+$_it+''))();
   {? _fuse<>'' | _fmin<>'' | _fmax<>''
   || _edt:='REDP'
   ?}
!};
PX_OPER.win_edit(_edt);
1


\PX_OPER_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Dodanie PX_OPER z poziomu PxTex.OperTab
::   WE: _a - PX_STAGE.ref()
::   WY: PX_OPER.add()
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_PX_STAGE:=_a;
_result:=0;
PX_KONT.cntx_psh();
PX_OPER.cntx_psh();
PX_OPER.clear();
PX_OPER.blank();
PX_OPER.PX_STAGE:=_PX_STAGE;
_mainver:=exec('get_mainversion','px_ver');
PX_OPER.PX_KONT:=exec('sel_px_kont','px_kont',_mainver,'R');
{? PX_OPER.PX_KONT<>null()
 & exec('PX_OPER_edt_set','px_oper')
||
:: Kontrola zgodnosci zestawow planistycznych
   _set_chk:=1;
   {? exec('is_px_set','px_param')>0
   || _set_stg:=PX_OPER.PX_STAGE().PX_SET;
      _set_kont:=PX_OPER.PX_KONT().PX_SET;
      {? _set_stg<>null() & $_set_stg<>$_set_kont
      ||
::       Zestaw etapu i kontenera sie roznia - pytam czy na pewno dodac
         _msg0:='';
         _msg1:='Zestawy planistyczne etapu i zasobu są różne.';
         _msg2:='Czy na pewno wykonać powiązanie?';
         _msg3:='Zestaw etapu: '+exec('FindAndGet','#table',PX_SET
                                                           ,_set_stg
                                                           ,
                                                           ,"SYMBOL"
                                                           ,'<brak>');
         _msg4:='Zestaw zasobu: '+exec('FindAndGet','#table',PX_SET
                                                           ,_set_kont
                                                           ,
                                                           ,"SYMBOL"
                                                           ,'<brak>');
         _msg_glued:=exec('form','#string','L',_msg1
                                             ,_msg2
                                             ,_msg0
                                             ,_msg3
                                             ,_msg4);
         _set_chk:=FUN.ask(_msg_glued)
      ?}
   ?};
   {? _set_chk>0
   ||
      _result:={? PX_OPER.edit("exec('PX_OPER_a_rec','px_oper')")
               || PX_OPER.add()
               || 0
               ?}
   ?}
?};
{? _result>0
||
   {? exec('is_px_set','px_param')>0
   ||
::    Po dodaniu PX_OPERa uaktualniam zestaw na etapie
      exec('px_set_fill','px_stage',_PX_STAGE,1,0)
   ?}
?};
PX_OPER.cntx_pop();
PX_KONT.cntx_pop();
_result


\PX_OPER_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Edytuje PX_OPER
::   WE: _a - PX_OPER.ref()
::       _b - formula do wykonania po redakcji
::   WY: wynik PX_OPER.edit()
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PX_OPER','FmlAEdit');
_args.PX_OPER:=_a;
_args.FmlAEdit:=''+_b;
_result:=0;
Cntx.psh(PX_OPER, PX_KONT);
Cntx.clr(PX_OPER, PX_KONT);
{? PX_OPER.seek(_args.PX_OPER)
 & PX_OPER.PX_KONT<>null()
|| {? ( PX_KONT.name()=ref_name(PX_OPER.PX_KONT)
      | PX_KONT.use(ref_name(PX_OPER.PX_KONT))
      )
    & exec('PX_OPER_edt_set','px_oper',PX_OPER.ref())
   || _result:={? PX_OPER.edit("exec('PX_OPER_a_rec','px_oper')")
               || {? _args.FmlAEdit<>'' || ($_args.FmlAEdit)() || 1 ?}
               || 0
               ?}
   ?}
?};
Cntx.pop(PX_OPER, PX_KONT);
_result


\PX_OPER_view
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Pokazuje PX_OPER
::   WE: _a - PX_OPER.ref()
::
::   WY: wynik PX_OPER.edit()
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PX_OPER');
_args.PX_OPER:=_a;
_result:=0;
Cntx.psh(PX_OPER, PX_KONT);
Cntx.clr(PX_OPER, PX_KONT);
{? PX_OPER.seek(_args.PX_OPER)
 & PX_OPER.PX_KONT<>null()
|| {? ( PX_KONT.name()=ref_name(PX_OPER.PX_KONT)
      | PX_KONT.use(ref_name(PX_OPER.PX_KONT))
      )
    & exec('PX_OPER_edt_set','px_oper',PX_OPER.ref())
   || PX_OPER.display()
   ?}
?};
Cntx.pop(PX_OPER, PX_KONT);
~~


\PX_OPER_move_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tablica parametrow dla PX_OPER_move
::   WE: --
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PX_OPER','SrcSTAGE','SrcKONT','DstSTAGE','DstKONT');
:: tutaj ustawienie wartosci domyslnych
{! _aa:=1..obj_len(_args) |! _args[_aa]:=null() !};
:: zwracamy tablice
_args


\PX_OPER_move
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przelaczenie PX_OPER z Src do Dst
::   WE: _args
::   WY:
::UWAGA: FORMULA NIE KONTROLUJE CZY MOZNA, CZY NIE MOZNA PRZEPIAC OPERACJI !!!
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
{? _=1
|| _args:=_a
|| _args:=exec('PX_OPER_move_a','px_oper');
   _args.PX_OPER:=_a;
   _args.SrcSTAGE:=_b;
   _args.SrcKONT:=_c;
   _args.DstSTAGE:=_d;
   _args.DstKONT:=_e;
   ~~
?};
:: tablica zmiennych lokalnych
{? _args.PX_OPER<>null()
|| _fml:='';
   {? _args.SrcSTAGE<>_args.DstSTAGE || _fml+="PX_STAGE:=_param.DstSTAGE; "?};
   {? _args.SrcKONT<>_args.DstKONT
   || {? exec('FindAndGet','#table',PX_KONT,_args.DstKONT,,"A",'N')='T'
      | FUN.ask('Docelowy zasób planistyczny jest nieaktywny.'
                  +'\nCzy na pewno przesunąć powiązanie?'@
                 )
      || _fml+="PX_KONT:=_param.DstKONT; "
      || return(0)
      ?}
   ?};
   {? _fml<>''
   || _fml:=$(_fml+" put(1)");
      _result:=exec('FindAndGet','#table',PX_OPER,#_args.PX_OPER,ref_name(_args.PX_OPER),_fml,0,_args);
      {? _result>0 & _args.DstSTAGE<>null()
      ||
::       Obsluga zestawow planistycznych - nawijanie PX_SET na etap docelowy
         _result:=exec('px_set_fill','px_stage',_args.DstSTAGE,1,0)
      ?};
      {? _result>0 & _args.SrcSTAGE<>null()
      ||
::       Obsluga zestawow planistycznych - nawijanie PX_SET na etap zrodlowy
         _result:=exec('px_set_fill','px_stage',_args.SrcSTAGE,1,0)
      ?}
   || _result:=0
   ?}
|| _result:=0
?};
_result


\PX_OPER_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Kasuje wskazany PX_OPER
::   WE: _a - PX_OPER.ref()
::   WY: wynik PX_OPER.del(,1)
::----------------------------------------------------------------------------------------------------------------------
_PX_OPER:=_a;
_result:=0;
PX_OPER.cntx_psh(); PX_OPER.clear();
{? PX_OPER.seek(_PX_OPER)
||
   _px_stage:=PX_OPER.PX_STAGE;
   _result:=PX_OPER.del(,1);

   {? _result>0
   ||
      {? _px_stage<>null() & exec('is_px_set','px_param')>0
      ||
::       Uaktualniam zestaw na etapie
         exec('px_set_fill','px_stage',_px_stage,1,0)
      ?}
   ?}
?};
PX_OPER.cntx_pop();
_result


\PX_OPER_put
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Uaktualnia biezacy PX_OPER
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_px_stage:=PX_OPER.PX_STAGE;
_result:=PX_OPER.put(1);

{? _result>0
||
   {? _px_stage<>null() & exec('is_px_set','px_param')>0
   ||
::    Uaktualniam zestaw na etapie
      exec('px_set_fill','px_stage',_px_stage,1,0)
   ?}
?};
_result


\PX_OPER_a_rec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: po rekord dla PX_OPER
::   WY: 1/0/fld
::----------------------------------------------------------------------------------------------------------------------
{? PX_OPER.CAP_USE1=0
|| FUN.emsg('Należy podać wartość dla pierwszego wymiaru.'@); 'CAP_USE1'
|| 1
?}


\getPX_OPER_StKo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Zwraca PX_OPER.ref() dla wskazanego etapu i kontenera
::   WE: _a - PX_STAGE.ref()
::       _b - PX_KONT.ref()
::   WY: PX_OPER.ref()
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_PX_STAGE:=_a;
_PX_KONT:=_b;
_PX_OPER:=null();
PX_OPER.cntx_psh();
PX_OPER.index('UNIQALL');
PX_OPER.prefix();
{? PX_OPER.find_key(_PX_STAGE,_PX_KONT)
|| _PX_OPER:=PX_OPER.ref()
?};
PX_OPER.cntx_pop();
_PX_OPER


\pars_init
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Zwraca zadeklarowany i wypelniony obiekt klasy do obslugi parametrow technologii dla
::       aktualnego PX_OPERa
::   WY: CLASS - obiekt do obslugi parametrow technologii
::----------------------------------------------------------------------------------------------------------------------
_result:=~~;
PX_STAGE.cntx_psh();
PX_OPER.PX_STAGE();
{? PX_STAGE.PX_TEX<>null
|| _result:=exec('pars_init','px_tex',PX_STAGE.PX_TEX)
|? PX_STAGE.TKTL<>null()
|| _result:=exec('pars_init','px_tex',PX_STAGE.TKTL)
?};
PX_STAGE.cntx_pop();
_result


\recalculate_use
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dokonuje przeliczenia zuzyc na podstawie XJM przepisu lub przypietej formuly na zuzycie
::   WE: _a - PX_OPER.ref()
::       [_b] - REAL - przelicznik wg ktorego pomnozyc normy, domyslnie=1
::       [_c] - CLASS - obiekt do obslugi parametrow
::       [_d] - INTEGER - dla przepisow parametryzowalnych:
::                            1 - po przeliczeniu zuzycia czysc formule
::                            0 - nie czysc formuly po przeliczeniu
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_oper:=_a;

:: Inicjalizacja parametrow
_coef:=1;
{? var_pres('_b')=type_of(0)
|| _coef:=_b
?};

_pars:=~~;
{? var_pres('_c')>100
|| _pars:=_c
?};

_clean:=0;
{? var_pres('_d')=type_of(0)
|| _clean:=_d
?};

_result:=1;

{? var_pres('PxTabPar')<100
|| exec('PxTabPar','px_init')
?};
PX_KONT.cntx_psh();
PX_STAGE.cntx_psh();
PX_OPER.cntx_psh();
PX_OPER.clear();
{? PX_OPER.seek(_px_oper)
||
:: Obsluga przepisow parametryzowalnych - inicjalizacja obiektu dla parametrow
   {? type_of(_pars)=0
   || _pars:=exec('pars_init','px_oper')
   ?};
   PX_OPER.PX_KONT();
   {! _dim:=0..PX_OPER.PX_KONT().IL_WYM-1
   |! _prec:=PX_KONT[PxTabPar.PX_KONT.PREC+_dim];
      {? PX_OPER[PxTabPar.PX_OPER.CAPFUSE+_dim]<>''
      ||
::       Obsluga przepisow parametryzowalnych - ponowne przeliczenie formul
         {? type_of(_pars)>100
         || {? _coef<>1
            || _fcoef:=form(_coef,,,'9.');
               PX_OPER[PxTabPar.PX_OPER.CAPFUSE+_dim]:='('+PX_OPER[PxTabPar.PX_OPER.CAPFUSE+_dim]+')*'+_fcoef
            ?};
            PX_OPER[PxTabPar.PX_OPER.CAP_USE+_dim]:=_pars.calc(PX_OPER[PxTabPar.PX_OPER.CAPFUSE+_dim])$_prec;
            {? _clean>0
            || PX_OPER[PxTabPar.PX_OPER.CAPFUSE+_dim]:=''
            ?}
         ?}
      ||
::       Przeliczenie zuzycia na podstawie przelicznika
         PX_OPER[PxTabPar.PX_OPER.CAP_USE+_dim]:=(PX_OPER[PxTabPar.PX_OPER.CAP_USE+_dim]*_coef)$_prec
      ?}
   !};
   _result:=PX_OPER.put()
?};
PX_OPER.cntx_pop();
PX_STAGE.cntx_pop();
PX_KONT.cntx_pop();
_result


\recalculate_max
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dokonuje przeliczenia zuzyc max na podstawie formul na zuzycie
::   WE: _a - PX_OPER.ref()
::       [_b] - CLASS - obiekt do obslugi parametrow
::       [_c] - INTEGER - dla przepisow parametryzowalnych:
::                            1 - po przeliczeniu zuzycia czysc formule
::                            0 - nie czysc formuly po przeliczeniu
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_oper:=_a;

:: Inicjalizacja parametrow
_pars:=~~;
{? var_pres('_b')>100
|| _pars:=_b
?};

_clean:=0;
{? var_pres('_c')=type_of(0)
|| _clean:=_c
?};

_result:=1;

{? var_pres('PxTabPar')<100
|| exec('PxTabPar','px_init')
?};
PX_KONT.cntx_psh();
PX_STAGE.cntx_psh();
PX_OPER.cntx_psh();
PX_OPER.clear();
{? PX_OPER.seek(_px_oper)
||
:: Obsluga przepisow parametryzowalnych - inicjalizacja obiektu dla parametrow
   {? type_of(_pars)=0
   || _pars:=exec('pars_init','px_oper')
   ?};
   PX_OPER.PX_KONT();
   {! _dim:=0..PX_OPER.PX_KONT().IL_WYM-1
   |! _prec:=PX_KONT[PxTabPar.PX_KONT.PREC+_dim];
      {? PX_OPER[PxTabPar.PX_OPER.CAPFMAX+_dim]<>''
      ||
::       Obsluga przepisow parametryzowalnych - ponowne przeliczenie formul
         {? type_of(_pars)>100
         || PX_OPER[PxTabPar.PX_OPER.CAP_MAX+_dim]:=_pars.calc(PX_OPER[PxTabPar.PX_OPER.CAPFMAX+_dim])$_prec;
            {? _clean>0
            || PX_OPER[PxTabPar.PX_OPER.CAPFMAX+_dim]:=''
            ?}
         ?}
      ?}
   !};
   _result:=PX_OPER.put()
?};
PX_OPER.cntx_pop();
PX_STAGE.cntx_pop();
PX_KONT.cntx_pop();
_result


\recalculate_min
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dokonuje przeliczenia zuzyc min na podstawie formul na zuzycie
::   WE: _a - PX_OPER.ref()
::       [_b] - CLASS - obiekt do obslugi parametrow
::       [_c] - INTEGER - dla przepisow parametryzowalnych:
::                            1 - po przeliczeniu zuzycia czysc formule
::                            0 - nie czysc formuly po przeliczeniu
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_oper:=_a;

:: Inicjalizacja parametrow
_pars:=~~;
{? var_pres('_b')>100
|| _pars:=_b
?};

_clean:=0;
{? var_pres('_c')=type_of(0)
|| _clean:=_c
?};

_result:=1;

{? var_pres('PxTabPar')<100
|| exec('PxTabPar','px_init')
?};
PX_KONT.cntx_psh();
PX_STAGE.cntx_psh();
PX_OPER.cntx_psh();
PX_OPER.clear();
{? PX_OPER.seek(_px_oper)
||
:: Obsluga przepisow parametryzowalnych - inicjalizacja obiektu dla parametrow
   {? type_of(_pars)=0
   || _pars:=exec('pars_init','px_oper')
   ?};
   PX_OPER.PX_KONT();
   {! _dim:=0..PX_OPER.PX_KONT().IL_WYM-1
   |! _prec:=PX_KONT[PxTabPar.PX_KONT.PREC+_dim];
      {? PX_OPER[PxTabPar.PX_OPER.CAPFMIN+_dim]<>''
      ||
::       Obsluga przepisow parametryzowalnych - ponowne przeliczenie formul
         {? type_of(_pars)>100
         || PX_OPER[PxTabPar.PX_OPER.CAP_MIN+_dim]:=_pars.calc(PX_OPER[PxTabPar.PX_OPER.CAPFMIN+_dim])$_prec;
            {? _clean>0
            || PX_OPER[PxTabPar.PX_OPER.CAPFMIN+_dim]:=''
            ?}
         ?}
      ?}
   !};
   _result:=PX_OPER.put()
?};
PX_OPER.cntx_pop();
PX_STAGE.cntx_pop();
PX_KONT.cntx_pop();
_result


\cap_use
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Zwraca zuzywana pojemnosc we wszystkich wymiarach
::       Kontekst pracy - PX_OPER - etap na zasobie
::   WY: DICT - tablica  - zuzywana pojemnosc we wszystkich wymiarach
::----------------------------------------------------------------------------------------------------------------------

PX_KONT.cntx_psh();
_il_wym:=PX_OPER.PX_KONT().IL_WYM;
_result:=obj_new(_il_wym);

::inicjuje tablice
{! _it:=1.._il_wym
|! _result[_it]:=0
!};

{? _il_wym>0
|| {! _it:=1.._il_wym
   |! _cap_use:=($('PX_OPER.CAP_USE'+$_it))();
      _result[_it]:=_cap_use
   !}
?};
PX_KONT.cntx_pop();
_result


\veryfyilosc
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Weryfikuje poprawnosc etapu - pod wzgledem istnienia zerowych zuzyc
::   WE: _a - PX_OPER.ref()
::       _b - REAL - wspolczynnik: ilosc do planu/XJM przepisu
::   WY: STRING - komunikat o bledzie lub '' jesli wszystko ok
::----------------------------------------------------------------------------------------------------------------------
_px_oper:=_a;
_coef:=_b;

_result:='';
PX_OPER.cntx_psh();PX_OPER.clear();
PX_KONT.cntx_psh();
{? PX_OPER.seek(_px_oper)
||
:: w tej tablicy znajduja sie dokladnosci w poszczegolnych wymiarach
   _prec:=exec('precision_array','px_kont',PX_OPER.PX_KONT);
:: Przeliczam zuzycia na podstawie formul
   exec('recalculate_use','px_oper',PX_OPER.ref());
   _cap_use:=exec('cap_use','px_oper');

:: Mnoze przez XJM
   exec('array_multiply','#array',_cap_use,_coef);

:: Zaokraglam do dokladnosci kontenera
   exec('array_round_mod','#array',_cap_use,_prec);

:: Sprawdzam czy jest jakikolwiek niezerowy wymiar
   {? exec('array_sum','#array',_cap_use)=0
   || _result:='zawiera operację z zerowymi zużyciami we wszystkich wymiarach'@
   ?};
   {? _result=''
   ||
::    Sprawdzam czy pierwszy wymiar jest niezerowy
      {? _cap_use[1]=0
      || _result:='zawiera operację z zerowym zużyciem w pierwszym wymiarze'@
      ?}
   ?}
?};
PX_OPER.cntx_pop();
PX_KONT.cntx_pop();
_result


\get_zktl4TMAT
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Na podstawie struktury zlecenia zlozonego odszukanie karty polfabrykatowej obowiazujacej dla danego TMAT
::   WE: _a - TMAT.ref()
::   WY: TKTL.ref() - technologii odpowiedniej dla danego TMAT
::----------------------------------------------------------------------------------------------------------------------
{? (_<1) | (_a=~~) | (type_of(_a)<>type_of(null())) | (_a=null()) | (ref_name(_a)<>TMAT.name()) || return(null()) ?};

_odp:=null();
Cntx.psh(TKTL,TMAT,ZL); Cntx.clr(TKTL,ZL);
{? TMAT.seek(_a)
||
:: najpierw przyjecie TKTL wskazywanej bezposrednio z TMAT bo moze o nia chodzi
   _mm:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};
   {? TMAT.KTL<>null() & TMAT.MAG<>'T' || _odp:=TMAT.KTL
   |? TMAT.DFLT_KTL='T' & TMAT.MAG<>'T' || _odp:=exec('dflt_ktl','tech_prod',_mm)
   ?};
:: jezeli TMAT nalezy do technologii zlecenia to poszukanie odpowiedniego podzlecenia i jego technologii
   {? TKTL.seek(TMAT.NRK)
   ||
      {? (TKTL.TORW='Z') & (TKTL.ZL<>null())
      ||
         _top_level:=exec('top_level','zl_link',TKTL.ZL);
         _top_rodzaj:=exec('top_rodzaj','zl_link',TKTL.ZL);
         {? _top_level<>TKTL.ZL & _top_rodzaj='Z'
         ||
::          podzlecenie nalezy do zlecenia rodzaju Z - czyli warto szukac odpowieniej technologii wsrod podzlecen
            _nrnzl:=TKTL.ZL().NRNZL;
            _getodp:="{? ZL.TKTL<>null() || ZL.TKTL |? ZL.KTL<>null() || ZL.TKTL || _a ?}";
            _tree:=TKTL.ZL().TREE;
            ZL.index('TREEMTU'); ZL.prefix(_tree,_mm,_odp);
::          najpierw szukanie podleglego w strukturze na ten sam material i wg tej samej technologii bazowej
            {? ZL.first()
            || _odp:=_getodp(_odp)
            || ZL.prefix(_tree,_mm);
::             nie ma, to szukamy podleglego na ten sam KTM
               {? ZL.first()
               || _odp:=_getodp(_odp)
               || ZL.index('NRNZLMTU'); ZL.prefix(_nrnzl,_mm,_odp);
::                nie ma w strukturze podleglosci, to szukamy w ramach zlecenia na ten sam KTM i wg tej samej karty bazowej
                  {? ZL.first()
                  || _odp:=_getodp(_odp)
                  || ZL.prefix(_nrnzl,_mm);
::                   nie ma to moze jest jakies na ten sam KTM
                     {? ZL.first() || _odp:=_getodp(_odp) ?}
                  ?}
               ?}
            ?}
         ?}
      ?}
   ?}
?};
Cntx.pop(TKTL,TMAT,ZL);
_odp


\default_kont_formulas
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Przepisuje na PX_OPER domyślne formuły na zużycia w wymiarach
::   WE: [_a] - PX_OPER.ref lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_OPER.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_OPER.cntx_psh();
{? _ref<>null()
|| PX_OPER.prefix();
   {? PX_OPER.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _recal_use:=0;
   _recal_min:=0;
   _recal_max:=0;
   {? _can_continue>0
   ||
      {! _it:=1.. PX_OPER.PX_KONT().IL_WYM
      |!
         _overwrite:=0;
         {? ($('PX_KONT.CAPFOVW'+$_it+''))()='T'
         || _overwrite:=1
         ?};

         _fuse_kont:=($('PX_OPER.PX_KONT().CAPFUSE'+$_it+''))();
         _fuse_oper:=($('PX_OPER.CAPFUSE'+$_it+''))();

         _can_set:=0;
         {? _fuse_oper='' | _overwrite>0
         || _can_set:=1
         ?};

         {? _can_set>0 & _fuse_kont<>''
         || ($('PX_OPER.CAPFUSE'+$_it+':=_a'))(_fuse_kont);
            _recal_use:=1
         ?};

         _fmin_kont:=($('PX_OPER.PX_KONT().CAPFMIN'+$_it+''))();
         _fmin_oper:=($('PX_OPER.CAPFMIN'+$_it+''))();

         _can_set:=0;
         {? _fmin_oper='' | _overwrite>0
         || _can_set:=1
         ?};

         {? _can_set>0 & _fmin_kont<>''
         || ($('PX_OPER.CAPFMIN'+$_it+':=_a'))(_fmin_kont);
            _recal_min:=1
         ?};

         _fmax_kont:=($('PX_OPER.PX_KONT().CAPFMAX'+$_it+''))();
         _fmax_oper:=($('PX_OPER.CAPFMAX'+$_it+''))();

         _can_set:=0;
         {? _fmax_oper='' | _overwrite>0
         || _can_set:=1
         ?};

         {? _can_set>0 & _fmax_kont<>''
         || ($('PX_OPER.CAPFMAX'+$_it+':=_a'))(_fmax_kont);
            _recal_max:=1
         ?}
      !}
   ?};
   {? _can_continue>0 & (_recal_use>0 | _recal_min>0 | _recal_max>0)
   || _can_continue:=PX_OPER.put()
   ?};
   {? var_pres('_pars')>100
   || obj_del(_pars)
   ?};
   _pars:=exec('pars_init','px_oper');
   {? type_of(_pars)=0
   || exec('start_xpar','tech_param',PX_OPER.PX_STAGE().PX_TEX);
      _pars:=xpar
   ?};
   {? _can_continue>0 &_recal_use>0
   || _can_continue:=exec('recalculate_use','px_oper',PX_OPER.ref(),,_pars,0)
   ?};
   {? _can_continue>0 & _recal_min>0
   || _can_continue:=exec('recalculate_min','px_oper',PX_OPER.ref(),_pars,0)
   ?};
   {? _can_continue>0 & _recal_max>0
   || _can_continue:=exec('recalculate_max','px_oper',PX_OPER.ref(),_pars,0)
   ?}

?};
PX_OPER.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:38 3e697e6fbde57733e904b54d0896288a2b35dde912b8334caf91dd8fa5a360c8c7ca7dcc485e48f0bf588350b86fa5a707a9d5095d314f3d6fea78f5d5d87d3f01f918eb183f01a45a7da94024c99a048de256da7fef05b1ff07660c9a3683ea4d3ecb92577a65e93d28f5327b8927eecd06fe8b14dcb198976047fde525e2e0
