:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: tech_common.fml
:: Utworzony: 05.03.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły do obsługi wspólnych elementów na technologii (nie dotyczy nagłówków)
::            Biblioteka obsługuje tabele TOPER, TECHZAMS, TMAT, TCHMAT, TACTTLS
::======================================================================================================================


\act_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Przed wyświetleniem pola *.ACT (w tabelach TMAT, TCHMAT, TOPER, TACTTLS)
::  OLD: \act_bd/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.A_TORW='T'
|| 1
|| 0
?}


\pored_x_od
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Po redakcji pól *.OD w technologii
::   WY: 1 / 0
::  OLD: \pored_x_od/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
{? fld()>=date()
|| {? fld()=date || cur_tab(1,1).ACT:='T' || cur_tab(1,1).ACT:='N' ?};
   1
|| FUN.emsg('Data nie może być wcześniejsza niż dzisiejsza.'@)
?}


\pred_x_od
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Przed redakcją pól *.OD w technologii
::   WY: 1 / 0
::  OLD: \pred_x_od/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.KOR


\user_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Przed wyświetleniem pola *.USER (w tabelach TMAT, TCHMAT, TOPER, TACTTLS)
::  OLD: \user_bd/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
{? 1+cur_kwin()='e'
|| _tab:=cur_tab(1,1);
   {? VAR.A_TORW='T'
   || _res:='';
      _tab.efld_opt(cur_win(),'label_color=',,'USER')
   || _res:=exec('findfnv','#color');
      _tab.efld_opt(cur_win(),'label_color='+((_res*',')-_res),,'USER')
   ?}
|| _res:=''
?};
_res


\cause_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Przed wyświetleniem pola *.CAUSE (w tabelach TMAT, TCHMAT, TOPER, TACTTLS)
::  OLD: \cause_bd/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
{? 1+cur_kwin()='e'
|| _tab:=cur_tab(1,1);
   {? VAR.A_TORW='T' | VAR.KOR=1
   || _res:='';
      _tab.efld_opt(cur_win(),'label_color=',,'CAUSE')
   || _res:=exec('findfnv','#color');
      _tab.efld_opt(cur_win(),'label_color='+((_res*',')-_res),,'CAUSE')
   ?}
|| _res:=''
?};
_res


\be_txcause
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: przed redakcją pola *.CAUSE
::   WY: 0 / 1
::  OLD: \be_txcause/tech.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.KOR


\var_cre_time_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Przed wyświetleniem pol VAR1.CRE_T_T*
::  OLD: \var_cre_time_bd/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
_afld:=cur_afld();
_atab:=
   {? _afld+1='C' || 'TCHMAT'
   |? _afld+1='L' || 'TACTTLS'
   |? _afld+1='M' || 'TMAT'
   |? _afld+1='O' || 'TOPER'
                  || return(0)
   ?};
_tab:=($_atab)();
{? VAR.A_TORW='T'
|| {? ($(_atab+'.CRE_TIME=0'))()
   || ($('VAR1.'+_afld+':='''''))()
   || ($('VAR1.'+_afld+':=19+tm_form('+_atab+'.CRE_TIME)'))()
   ?};
   _res:='';
   _tab.efld_opt(cur_win(),'label_color=',VAR1,_afld)
|| _res:=exec('findfnv','#color');
   _tab.efld_opt(cur_win(),'label_color='+((_res*',')-_res),VAR1,_afld)
?};
_res


\var_mod_time_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Przed wyświetleniem pól VAR1.MOD_T_T*
::  OLD: \var_mod_time_bd/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
_afld:=cur_afld();
_atab:=
   {? _afld+1='C' || 'TCHMAT'
   |? _afld+1='L' || 'TACTTLS'
   |? _afld+1='M' || 'TMAT'
   |? _afld+1='O' || 'TOPER'
                  || return(0)
   ?};
_tab:=($_atab)();
{? VAR.A_TORW='T'
|| {? ($(_atab+'.MOD_TIME=0'))()
   || ($('VAR1.'+_afld+':='''''))()
   || ($('VAR1.'+_afld+':=19+tm_form('+_atab+'.MOD_TIME)'))()
   ?};
   _res:='';
   _tab.efld_opt(cur_win(),'label_color=',VAR1,_afld)
|| _res:=exec('findfnv','#color');
   _tab.efld_opt(cur_win(),'label_color='+((_res*',')-_res),VAR1,_afld)
?};
_res


\pfazred
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Po redakcji rekordu w oknie TOPER.WER - przypisanie fazy produkcji (i wydziału do surowca)
::  OLD: \pfazred/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? TOPER.PZ='P' & TOPER.NTIME=0
|| TOPER.BRYG:='N';
   TOPER.put()
?};

_nr:=TOPER.UNROP;
_dalej:=1; _dalej1:=1;
_nrk:=TOPER.NRK;
_bryg:=TOPER.BRYG;
_pfaz:=TOPER.PFAZ;
_wyd:=TOPER.PFAZ().WYD;
_top:=TOPER.ref();

VAR.A_PFAZ:=_pfaz;
VAR.A_WYD:=_wyd;

:: Dopisanie fazy i wydziału do surowców przypisanych do operacji
TMAT.cntx_psh();
TMAT.clear();
TMAT.index('NNL');
TMAT.prefix(_nrk,_top);
{? TMAT.first()
||
   {!
   |? _dalej
   |!
      TMAT.PFAZ:=_pfaz;
      {? _wyd<>null() || TMAT.WYD:=_wyd ?};
      TMAT.put();

      _dalej:=TMAT.next()
   !}
?};
TMAT.cntx_pop();

:: Dopisanie fazy do narzędzi przypisanych do operacji
_dalej:=1;
TACTTLS.cntx_psh();
TACTTLS.clear;
TACTTLS.index('KNROP');
TACTTLS.prefix(_nrk,_top);
{? TACTTLS.first()
||
   {!
   |? _dalej
   |!
      TACTTLS.PFAZ:=_pfaz;
      TACTTLS.put();
      _dalej:=TACTTLS.next()
   !}
?};
TACTTLS.cntx_pop();

:: Dopisanie fazy do operacji podrzędnych
_dalej:=1;
TOPER.cntx_psh();
TOPER.index('NNN');
TOPER.prefix(_nrk,_nr);
{? TOPER.first()
||
   {!
   |? _dalej
   |!
      TOPER.PFAZ:=_pfaz;
      TOPER.put();
      _nr1:=TOPER.UNROP;_nrk1:=TOPER.NRK;_top1:=TOPER.ref();

::    Dopisanie fazy i wydziału do surowców przypisanych do operacji
      TMAT.cntx_psh();
      TMAT.clear();
      TMAT.index('NNL');
      TMAT.prefix(_nrk1,_top1);
      {? TMAT.first()
      ||
         {!
         |? _dalej1
         |!
            TMAT.PFAZ:=_pfaz;
            {? _wyd<>null() || TMAT.WYD:=_wyd ?};
            TMAT.put();

            _dalej1:=TMAT.next()
         !};
         _dalej1:=1
      ?};
      TMAT.cntx_pop();

::    Dopisanie fazy do narzędzi przypisanych do operacji
      TACTTLS.cntx_psh();
      TACTTLS.clear;
      TACTTLS.index('KNROP');
      TACTTLS.prefix(_nrk1,_top1);
      {? TACTTLS.first()
      ||
         {!
         |? _dalej1
         |!
            TACTTLS.PFAZ:=_pfaz;
            TACTTLS.put();
            _dalej1:=TACTTLS.next()
         !}
      ?};
      TACTTLS.cntx_pop();
      _dalej1:=1;

::    W przypadku operacji złożonej zagnieżdżenie funkcji
      {? TOPER.PZ='Z'
      ||
         exec('pfazzl','tech_common',_nr1,_nrk1,_pfaz,_wyd)
      ?};

      _dalej:=TOPER.next()
   !};
   _dalej:=1
?};

TOPER.cntx_pop();
{? VAR1.TPZ='N'
||
:: znajdujemy czy była przypisana operacja tpz - jeżeli nie, to deaktywujemy
   TOPER.cntx_psh();
   TOPER.index('TPZ');
   TOPER.prefix('T',TOPER.UNROP);
   {? TOPER.first()
   || TOPER.ACT:='N';
      TOPER.put()
   ?};
   TOPER.cntx_pop()
||
:: jeżeli tak to znajdujemy czy była i nadpisujemy zmienioną zawartość, a jeżeli nie było to dodajemy
   _unrop:=TOPER.UNROP;
   _nrop:=TOPER.NROP;
   _place:=TOPER.PLACE;
   _grpoj:=TOPER.GRPOJ;
   _grupa:=TOPER.GRUPA;
   _twrkplg:=TOPER.TWRKPLG;
   _kontrola:=TOPER.KONTROLA;
   _kj_bad:=TOPER.KJ_BAD;
   _badseh:=TOPER.BADSEH;
   _where:=TOPER.WHERE;
   _wyk_fast:=TOPER.WYK_FAST;
   TOPER.cntx_psh();
   TOPER.index('TPZ');
   TOPER.prefix('T',TOPER.UNROP);
   {? TOPER.first()
   || TOPER.NROP:=_nrop;
      TOPER.ZAW:=VAR1.ZAW;
      TOPER.COEF:=VAR1.COEF1;
      TOPER.FCOEF:=VAR1.FCOEF1;
      TOPER.NTIME:=VAR1.NTIME1;
      TOPER.BRYG:=_bryg;
      TOPER.FNTIME:=VAR1.FNTIME1;
      TOPER.KH:=VAR1.STAWKA1;
      TOPER.PLNH:=(VAR1.STAWKA1*VAR1.COEF1)$4;
      TOPER.PLNX:=(TOPER.PLNH*VAR1.NTIME1)$4;
      TOPER.CIAGLA:=VAR1.CIAGLA;
      TOPER.PLACE:=_place;
      TOPER.GRPOJ:=_grpoj;
      TOPER.GRUPA:=_grupa;
      TOPER.TWRKPLG:=_twrkplg;
      TOPER.KONTROLA:=_kontrola;
      TOPER.KJ_BAD:=_kj_bad;
      TOPER.BADSEH:=_badseh;
      TOPER.PFAZ:=_pfaz;
      TOPER.ACT:='T';
      TOPER.WHERE:=_where;
      TOPER.WYK_FAST:=_wyk_fast;
      TOPER.put()
   || TOPER.blank();
      TOPER.PZ:='P';
      TOPER.WEW:='T';
      TOPER.NROP:=_nrop;
      TOPER.TPZ:='T';
      TOPER.BRYG:=_bryg;
      TOPER.ZAW:=VAR1.ZAW;
      TOPER.COEF:=VAR1.COEF1;
      TOPER.FCOEF:=VAR1.FCOEF1;
      TOPER.NTIME:=VAR1.NTIME1;
      TOPER.FNTIME:=VAR1.FNTIME1;
      TOPER.KH:=VAR1.STAWKA1;
      TOPER.PLNH:=(VAR1.STAWKA1*VAR1.COEF1)$4;
      TOPER.PLNX:=(TOPER.PLNH*VAR1.NTIME1)$4;
      TOPER.CIAGLA:=VAR1.CIAGLA;
      TOPER.TPZREF:=_unrop;
      TOPER.PLACE:=_place;
      TOPER.GRPOJ:=_grpoj;
      TOPER.GRUPA:=_grupa;
      TOPER.TWRKPLG:=_twrkplg;
      TOPER.PFAZ:=_pfaz;
      TOPER.KONTROLA:=_kontrola;
      TOPER.KJ_BAD:=_kj_bad;
      TOPER.BADSEH:=_badseh;
      TOPER.ACT:='T';
      TOPER.WHERE:=_where;
      TOPER.WYK_FAST:=_wyk_fast;
      TOPER.add()
   ?};
   TOPER.cntx_pop()
?};
1


\pfazzl
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przypisanie fazy do operacji - rekurencyjnie dla zlozonych
::   WE: _a - unikalny numer operacji TOPER.UNROP
::       _b - karta technologiczna TKTL.ref()
::       _c - faza produkcji PFAZ.ref()
::       _d - wydzial SLO.ref()
::  OLD: \pfazzl/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_nr:=_a;
_nrk:=_b;
_pfaz:=_c;
_wyd:=_d;
_dalej:=1;
_dalej1:=1;
TOPER.cntx_psh();
TOPER.index('NNN');
TOPER.prefix(_nrk,_nr);
{? TOPER.first()
||
   {!
   |? _dalej
   |!
::    Dopisanie fazy do operacji podrzednej
      TOPER.PFAZ:=_pfaz;
      TOPER.put();
      _nr1:=TOPER.UNROP; _nrk1:=TOPER.NRK; _top1:=TOPER.ref();
::    Dopisanie fazy do surowcow
      TMAT.cntx_psh();
      TMAT.clear;
      TMAT.index('NNL');
      TMAT.prefix(_nrk1,_top1);
      {? TMAT.first()
      ||
         {!
         |? _dalej1
         |!
            TMAT.PFAZ:=_pfaz;
            {? _wyd<>null() || TMAT.WYD:=_wyd ?};
            TMAT.put();

            _dalej1:=TMAT.next()
         !};
         _dalej1:=1
      ?};
      TMAT.cntx_pop();
::    Dopisanie fazy do narzędzi przypisanych do operacji
      TACTTLS.cntx_psh();
      TACTTLS.clear();
      TACTTLS.index('KNROP');
      TACTTLS.prefix(_nrk1,_top1);
      {? TACTTLS.first()
      ||
         {!
         |? _dalej1
         |!
            TACTTLS.PFAZ:=_pfaz;
            TACTTLS.put();
            _dalej1:=TACTTLS.next()
         !}
      ?};
      TACTTLS.cntx_pop();
      _dalej1:=1;
      {? TOPER.PZ='Z'
      ||
         exec('pfazzl','tech_common',_nr1,_nrk1,_pfaz,_wyd)
      ?};
      _dalej:=TOPER.next()
   !};
   _dalej:=1
?};
TOPER.cntx_pop();
~~


\can_modify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Sprawdza uprawnienie do modyfikacji zatwierdzonych kart technologicznych
::  OLD: \can_modify/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('get','#params',8030,2,OPERATOR.USER)='T'


\tktl_cntx_pop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wykonuje cntx_pop na wszystkich tabelach dotyczących technologii
::  OLD: \tktl_cntx_pop/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
TKTL.cntx_pop();
TKTLW.cntx_pop();
TOPER.cntx_pop();
NASTOPER.cntx_pop();
TMAT.cntx_pop();
TCHMAT.cntx_pop();
TACTTLS.cntx_pop();
TECHZAMS.cntx_pop();
TPAR.cntx_pop();
TPARTRA.cntx_pop();
TWPAR.cntx_pop();
KKTL.cntx_pop();
KALMAT.cntx_pop();
KALTTO.cntx_pop();
KALWRK.cntx_pop();
KALTOU.cntx_pop();
KALTLS.cntx_pop();
KPAR.cntx_pop();
KKALKH.cntx_pop();
KPOZK.cntx_pop();
~~


\tktl_cntx_psh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Wykonuje cntx_psh na wszystkich tabelach dotyczących technologii
::  OLD: \tktl_cntx_psh/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
TKTL.cntx_psh();
TKTLW.cntx_psh();
TOPER.cntx_psh();
NASTOPER.cntx_psh();
TMAT.cntx_psh();
TCHMAT.cntx_psh();
TACTTLS.cntx_psh();
TECHZAMS.cntx_psh();
TPAR.cntx_psh();
TPARTRA.cntx_psh();
TWPAR.cntx_psh();
KKTL.cntx_psh();
KALMAT.cntx_psh();
KALTTO.cntx_psh();
KALWRK.cntx_psh();
KALTOU.cntx_psh();
KALTLS.cntx_psh();
KPAR.cntx_psh();
KKALKH.cntx_psh();
KPOZK.cntx_psh();
~~


\tktl_use
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Otwiera maski wszystkich tabel technologii i kalkulacji
::   WE: [_a] - maska (STRING[3])
::  OLD: \tktl_use/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & +_a=3 || _maska:=_a || _maska:='___' ?};

TKTL.use('txktl'+_maska);
TKTLW.use('txktw'+_maska);
TOPER.use('txope'+_maska);
NASTOPER.use('txnst'+_maska);
TMAT.use('txmat'+_maska);
TCHMAT.use('txmac'+_maska);
TACTTLS.use('txtls'+_maska);
TECHZAMS.use('txzms'+_maska);
TPAR.use('txpar'+_maska);
TPARTRA.use('txptr'+_maska);
TWPAR.use('txwpr'+_maska);
KKTL.use('kxktl'+_maska);
KALMAT.use('kxmat'+_maska);
KALTTO.use('kxtto'+_maska);
KALWRK.use('kxwrk'+_maska);
KALTOU.use('kxtou'+_maska);
KALTLS.use('kxtls'+_maska);
KPAR.use('kxpar'+_maska);
KKALKH.use('kxhlp'+_maska);
KPOZK.use('kxpoz'+_maska);
~~


\tktl_lock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Blokada rekordu karty technologicznej ( TKTL.r_lock(1,1,1) )
::   WE: [_a] - #TKTL.ref(), a jak brak parametru, to ustawiony rekord w tabali TKTL
::       [_b] - akcja dla której ustawiona jest blokada: 'N'agłówek, 'O'peracje, 'S'urowce, 'P'ozostałe
::       [_c] - czy nie wyświetlać dialogow (domyślnie 0 - wyświetlać)
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _tktl:=_a || _tktl:=#TKTL.ref() ?};
{? var_pres('_b')=type_of('') || _action:=_b || _action:='N' ?};
{? var_pres('_c')=type_of(0) || _no_display:=_c || _no_display:=0 ?};

::msg('lock '+$_tktl);

_ok:=0;
BLK.index('AMR');
BLK.prefix('TKTL#'+_action,TKTL.name(),_tktl);
{? ~BLK.first()
|| BLK.ACR:='TKTL#'+_action;
   BLK.MSK:=TKTL.name();
   BLK.REF:=_tktl;
   BLK.SES_ID:=TKTL.ses_id();
   _ok:=BLK.add()
|| _ok:=1
?};
{? _ok
|| {? BLK.r_lock(1,1,1)
   || BLK.SES_ID:=TKTL.ses_id();
      _ok:=BLK.put()
   ||
      {? ~_no_display
      || _torw:=exec('FindAndGet','#table',TKTL,_tktl,TKTL.name(),"TORW",'T');
         {? VAR.GRUPA<>'T'
         || FUN.emsg(
               {? _torw='W'
               || {? _b='O'
                  || 'Operacje wzorca są redagowane'@
                  |? _b='S'
                  || 'Surowce wzorca są redagowane'@
                  |? _b='P'
                  || 'Pozostałe dane wzorca są redagowane'@
                  || 'Wzorzec technologii jest redagowany'@
                  ?}
               || {? _b='O'
                  || 'Operacje karty są redagowane'@
                  |? _b='S'
                  || 'Surowce karty są redagowane'@
                  |? _b='P'
                  || 'Pozostałe dane karty są redagowane'@
                  || 'Karta technologiczna jest redagowana'@
                  ?}
               ?}+
               ' przez użytkownika \'%1\' '
               'na terminalu \'%2\'.\n\n'
               'Modyfikacje nie są dostępne.'@[TKTL.ses_info(BLK.SES_ID,'log_name'),TKTL.ses_info(BLK.SES_ID,'log_tty')]
            )
         ?}
      ?};
      _ok:=0
   ?}
?};
_ok


\tktl_unlock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Usunięcie blokady rekordu zlecenia ( TKTL.r_unlock() )
::   WE: [_a] - #TKTL.ref(), a jak brak parametru, to ustawiony rekord w tabali TKTL
::       [_b] - akcja dla której ustawiona jest blokada: 'N'agłówek, 'O'peracje, 'S'urowce, 'P'ozostałe
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _tktl:=_a || _tktl:=#TKTL.ref() ?};
{? var_pres('_b')=type_of('') || _action:=_b || _action:='N' ?};

::msg('unlock '+$_tktl);

BLK.index('AMR');
BLK.prefix('TKTL#'+_action,TKTL.name(),_tktl);
{? BLK.first()
|| {? TKTL.ses_id()=BLK.SES_ID
   || BLK.r_unlock();
      BLK.del()
   ?}
?};
~~


\a_ktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2010]
:: OPIS: Zwraca VAR.A_KTL
::   WY: VAR.A_KTL
::  OLD: \a_ktl/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_KTL


\a_tktlw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2010]
:: OPIS: Zwraca VAR.A_TKTLW
::   WY: VAR.A_TKTLW
::  OLD: \a_tktlw/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_TKTLW


\a_war
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Zwraca złączenie na wariant kalkulacji
::   WY: VAR.A_WAR
::  OLD: \a_war/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_WAR


\err_form_ltzero
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Komunikat błędu, że wartość wyniku formuły ma być nieujemna
::       (przy redagowaniu formuł parametryzacyjnych dla kart technologicznych)
::  OLD: \err_form_ltzero/lib_prod.fml
::----------------------------------------------------------------------------------------------------------------------
FUN.emsg('Wyliczona wartość wyniku formuły musi być nieujemna.'@);
~~


\err_form_lgzero
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Komunikat błędu, że wartość wyniku formuły ma być większa od zera
::       (przy redagowaniu formuł parametryzacyjnych dla kart technologicznych)
::  OLD: \err_form_ltzero/lib_prod.fml
::----------------------------------------------------------------------------------------------------------------------
FUN.emsg('Wyliczona wartość wyniku formuły musi być większa od zera.'@);
~~


\display_vars
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Ustawia zmienne do wyświetlania danych o karcie technologicznej
::   WE: _a - $TKTL.ref - Sql Ref technologii
::  OLD: \display_vars/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

TKTL.cntx_psh();
_msk:=form(8+_tktl);
TKTL.use(_msk);
TKTL.clear();
{? TKTL.seek(_tktl)
|| VAR.TKTL_NRK:=TKTL.NRK;
   VAR.PRED_KTL:=TKTL.NRK;
   VAR.TRED_KTL:=TKTL.NRK;
   VAR.ZRED_KTL:=TKTL.NRK;
   VAR.TKTL_WER:=TKTL.WER;
   VAR.RED_WER:=TKTL.WER;
   ~~
?};
TKTL.cntx_pop();
~~


\tktl_dalej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obsługa przycisku 'Zakończ' w oknie wertowania kart technologicznych/wzorców - menu z przyciskami
::       Kontekst wywołania - rekord TKTL
::   WY: wynik wykonanej formuły
::----------------------------------------------------------------------------------------------------------------------
_oper:=TKTL.TYP().OPER='T';
_txt:={? TKTL.TORW='W' || 'wzorca' || 'karty' ?};

{? TKTL.STAT_N='T' & TKTL.STAT_O='T' & TKTL.STAT_S='T' & TKTL.STAT_P='T'
|| FUN.info(
      'Zakończono rejestrację %1 w pełnym zakresie (nagłówek, operacje, surowce, pozostałe dane).\n\n'
      'Modyfikacje niemożliwe.'@[_txt]
   )

|? TKTL.STAT_N='T' & ~_oper & TKTL.STAT_S='T' & TKTL.STAT_P='T'
|| FUN.info(
      'Zakończono rejestrację %1 w pełnym zakresie (nagłówek, surowce, pozostałe dane).\n\n'
      'Modyfikacje niemożliwe.'@[_txt]
   )

|| _grp:=TKTL.grp_make('Zakończ'@,,'tktldalej'+(-TKTL.TORW),100,10,,,'normal');
   _win:={? TKTL.TORW='W' || 'DALEJ_' || 'DALEJ' ?};
   TKTL.grp_edit(_grp,,_win,,,,,,'maximized');
   {? TKTL.STAT_N='T'
   || TKTL.btn_eopt(_win,'DALEJ_N','state=grayed')
   || TKTL.btn_eopt(_win,'DALEJ_N','state=normal')
   ?};
   {? TKTL.STAT_O='T' | TKTL.STAT_N='N' | ~_oper
   || TKTL.btn_eopt(_win,'DALEJ_O','state=grayed')
   || TKTL.btn_eopt(_win,'DALEJ_O','state=normal')
   ?};
   {? TKTL.STAT_S='T' | TKTL.STAT_N='N'
   || TKTL.btn_eopt(_win,'DALEJ_S','state=grayed')
   || TKTL.btn_eopt(_win,'DALEJ_S','state=normal')
   ?};
   {? TKTL.STAT_P='T' | TKTL.STAT_N='N'
   || TKTL.btn_eopt(_win,'DALEJ_P','state=grayed')
   || TKTL.btn_eopt(_win,'DALEJ_P','state=normal')
   ?};
   TKTL.win_sel(_grp);
   TKTL.select()
?};
~~


\wydzialy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.53] OWwPR013/5.1
:: OPIS: Zwraca listę wydziałów wykorzystanych w technologii
::       Przetwarza wszystkie elementy karty i z odpowiednich
::       faz produkcji pobiera wydziały (typu _SLO).
::   WE: _a - TKTL.ref()
::   WY: _wyn - tablica elementów typu SLO.ref()
::  OLD: \wydzialy/tech.fml
::----------------------------------------------------------------------------------------------------------------------
TKTL.cntx_psh();
TOPER.cntx_psh();
TMAT.cntx_psh();
TACTTLS.cntx_psh();
_tab:=tab_tmp(1,'WYD','INTEGER','Wydział');
_ndx:=_tab.ndx_tmp('',1,'WYD',,);
:------ pętla po operacjach -----------------------------------------
TOPER.index('NNN');
TOPER.prefix(_a);
{? TOPER.first()
|| {!
   |? _wyd:=#TOPER.PFAZ().WYD;
      {? _wyd<>0 & ~_tab.find_key(_wyd) || _tab.WYD:=_wyd; _tab.add() ?};
      TOPER.next()
   !}
?};
:------ pętla po surowcach ------------------------------------------
TMAT.index('NNL');
TMAT.prefix(_a);
{? TMAT.first()
|| {!
   |? _wyd:=#TMAT.PFAZ().WYD;
      {? _wyd<>0 & ~_tab.find_key(_wyd) || _tab.WYD:=_wyd; _tab.add() ?};
      TMAT.next()
   !}
?};
:------ pętla po narzędziach ----------------------------------------
TACTTLS.index('KNROP');
TACTTLS.prefix(_a);
{? TACTTLS.first()
|| {!
   |? _wyd:=#TACTTLS.PFAZ().WYD;
      {? _wyd<>0 & ~_tab.find_key(_wyd) || _tab.WYD:=_wyd; _tab.add() ?};
      TACTTLS.next()
   !}
?};
:------ tablica wynikowa --------------------------------------------
_tab.clear();
_size:=_tab.size();
{? _size>0
|| _wyn:=obj_new(_tab.size());
   _tab.index(_ndx);
   _tab.prefix();
   _i:=1;
   {? _tab.first()
   || {!
      |? {? SLO.seek(_tab.WYD,)
         || _wyn[_i]:=SLO.ref()
         || _wyn[_i]:=null()
         ?};
         _i+=1;
         _tab.next()
      !}
   ?}
|| _wyn:=obj_new(1);
   _wyn[1]:=null()
?};
TKTL.cntx_pop();
TOPER.cntx_pop();
TMAT.cntx_pop();
TACTTLS.cntx_pop();
_wyn


\getdefaulttech
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca domyslna technologie dla materialu lub pierwsza z brzegu jesli nie ma domyslnej
::   WE: _a - M.ref()
::       [_b] - INTEGER - 0/[1] - czy jezeli nie znajdzie domyslna, podpowiadac pierwsza z brzegu
::   WY: TKTL.ref() lub null()
::  OLD: \getdefaulttech/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_mat:=_a;
_get_any:=1;
{? var_pres('_b')=type_of(0)
|| _get_any:=_b
?};

_result:=null();

TKTLW.cntx_psh();

{? _get_any>0
|| TKTLW.index('PT');
   TKTLW.prefix(_mat);
   {? TKTLW.first()
   || {!
      |? {? TKTLW.TKTL().ARCH='N'
         || {? TKTLW.TKTL().DEFAULT='T'
            || _result:=TKTLW.TKTL
            ?}
         ?};
         TKTLW.next()
      !};

::    Jesli nadal wynik pusty to zwracam pierwsza lepsza
      {? _result=null()
      || TKTLW.first();
         _result:=TKTLW.TKTL
      ?}
   ?}
|| TKTLW.index('DEFAULT');
   TKTLW.prefix();
::   TKTLW.prefix('T','N','T',_mat);
   TKTLW.f_set('TKTL(NRK),TKTL(WER)','join TKTL using (TKTLW.TKTL,TKTL.REFERENCE)'
               ,'
               TKTL.TORW=\'T\'
               and TKTLW.KTM=:_a
               and TKTL.DEFAULT=\'T\'
               and TKTL.ARCH=\'N\'
               and ((TKTL.TERM_OD<=to_date(:_b) and TKTL.TERM_OD IS NOT NULL)
               or TKTL.TERM_OD IS NULL)
               and ((TKTL.TERM_DO>=to_date(:_b) and TKTL.TERM_DO IS NOT NULL)
               or TKTL.TERM_DO IS NULL)
               '
               ,_mat,date());


   {? TKTLW.f_last()
   || _result:=TKTLW.TKTL
   ?};
   TKTLW.f_clear()
?};
TKTLW.cntx_pop();
_result


\is_default_tech
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy dana karta technologiczna dla podanego materiału jest domyślna
::   WE: _a - TKTL.ref()
::       _b - M.ref()
::   WY: 1 - jest domyślna
::       0 - nie jest
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
_mat:=_b;

_result:=0;
TKTLW.cntx_psh();
TKTLW.index('REF');
TKTLW.prefix(_tktl,_mat,'T');
{? TKTLW.size()>0
|| _result:=1
?};
TKTLW.cntx_pop();
_result


\is_tech
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Sprawdza, czy dla danego materiału jest dostępna karta technologiczna
::       (niearchiwalna i zatwierdzona i/lub aktywna) albo czy jest karta jakakolwiek dla danego materiału
::   WE: _a - M.ref() lub #M.ref()
::      [_b] - 0 (domyślnie) zwraca wynik 0/1;
::             1 daje wynik: (-1) brak wogóle,
::                           (0) jest, ale archiwalna lub niezatwierdzona(lub nieaktywna, gdy _c=1),
::                           (1) dostępna (i aktywna, gdy _c=1)
::      [_c] - brać pod uwagę wyłącznie karty aktywne: [0] - nie, 1 - tak
::      [_d] - czy sprawdzać w masce niearchiwalnej: [0] - nie (maska bieżąca), 1 - tak (maska niearchiwalna)
::      [_e] - TKTLW.ref() - jeżeli podana, to karta pomijana
::   WY: -1 / 0 / 1
::  OLD: \is_tech/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')=type_of(0) || _extend:=_b || _extend:=0 ?};
{? var_pres('_c')=type_of(0) || _only_act:=_c || _only_act:=0 ?};
{? var_pres('_d')=type_of(0) || _chk_mask:=_d || _chk_mask:=0 ?};
{? var_pres('_e')=type_of(null()) || _skip_tktlw:=_e || _skip_tktlw:=null() ?};
_res:={? _extend || -1 || 0 ?};
TKTLW.cntx_psh();
TKTL.cntx_psh();
TKTL.prefix();
{? _chk_mask>0
|| _mask:=TKTLW.name()-3+'___';
   {? TKTLW.name()<>_mask || TKTLW.use(_mask) ?};
   _mask:=TKTL.name()-3+'___';
   {? TKTL.name()<>_mask || TKTL.use(_mask) ?}
?};
TKTLW.index('KSN');
TKTLW.prefix('T',_a,'T','N');
{? TKTLW.first()
|| {? _only_act=0
   || _res:={? _skip_tktlw<>TKTLW.ref() || 1 || TKTLW.next() ?}
   || {!
      |?
         TKTLW.TKTL();
         {? (TKTL.TERM_OD=date(0,0,0) | TKTL.TERM_OD<=date()) & (TKTL.TERM_DO=date(0,0,0) | TKTL.TERM_DO>=date())
            & _skip_tktlw<>TKTLW.ref()
         || _res:=1
         ?};
         _res<>1 & TKTLW.next()
      !}
   ?}
?};
{? _res<>1
|| {? _extend
   || TKTLW.prefix('T',_a);
      {? TKTLW.first()
      || {? _only_act=0
         || _res:={? _skip_tktlw=null() || 0 || {? _skip_tktlw<>TKTLW.ref() || 0 || TKTLW.next() ?} ?}
         || {!
            |?
               TKTLW.TKTL();
               {? (TKTL.TERM_OD=date(0,0,0) | TKTL.TERM_OD<=date()) & (TKTL.TERM_DO=date(0,0,0) | TKTL.TERM_DO>=date())
                  & _skip_tktlw<>TKTLW.ref()
               || _res:=0
               ?};
               _res<>0 & TKTLW.next()
            !}
         ?}
      || _res:=-1
      ?}
   || _res:=0
   ?}
?};
TKTLW.cntx_pop();
TKTL.cntx_pop();
_res


\sprsur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Po redakcji pola WYDRUK.SUR
::  OLD: \sprsur/drukujp.fml
::----------------------------------------------------------------------------------------------------------------------
{? WYDRUK.SUR='T'
|| WYDRUK.JM1:='P'
?};
1


\predjm1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Przed redakcją pola WYDRUK.JM1
::  OLD: \predjm1/drukujp.fml
::----------------------------------------------------------------------------------------------------------------------
WYDRUK.SUR='N'


\surnakt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [2009] PR/WRT/PRODUKCJ/10.20/0015
:: OPIS: Procedura pokazujaca liste nieaktywnych indeksow, które sa surowcami technologii przywracanej z archiwum
::   WE: _a - rodzaj kontroli
::           = 1 - kontrola nieaktywnosci indeksow karty technologicznej
::           = 3 - kontrola nieaktywnosci indeksow kart limitowych zlecenia
::       _b - ref karty technologicznej - TKTL.ref() / ref zlecenia - ZL.ref()
::       _c - maska zlecenia dla limitu
::       _d - czy komunikaty
::   WY: 1 - ok, 0 - sa nieaktywne indeksy
::  OLD: \surnakt/tech.fml
::----------------------------------------------------------------------------------------------------------------------
{? _<4 || _d:=1 ?};

_SURNAKT:={? _a=1
          || sql('select M.KTM, M.N
                  from TMAT
                  join M using(TMAT.PT,M.REFERENCE)
                  where TMAT.NRK=:_a and M.A=\'N\' ',_b)
          |? _a=3
          || sql('select M.KTM, M.N
                  from @ZLIM
                  join M using(ZLIM.KTM,M.REFERENCE)
                  where ZLIM.REFERENCE like \'%:_b%\' and ZLIM.ZLEC=:_a and M.A=\'N\' ',_b,_c)
          ?};

{? type_of(_SURNAKT)=type_of(~~) || exec('err_sql','#sql'); return(0) ?};

{? _SURNAKT.first()
|| {? _d=1
   || _wer:=_SURNAKT.mk_sel('Lista nieaktywnych surowców — dokonaj aktywacji indeksów KTM'@,'P',,'surnakt',10,10);
      _SURNAKT.win_fld(_wer,,'KTM',,,30,,,'KTM'@);
      _SURNAKT.win_fld(_wer,,'N',,,50,,,'Nazwa'@);
      _SURNAKT.win_sel(_wer);
      _SURNAKT.select()
   || KOMM.add('Istnieją nieaktywne indeksy — dokonaj aktywacji.'@);
      KOMM.sect_beg('Lista nieaktywnych indeksów.'@);
      _SURNAKT.first();
      {!
      |? KOMM.add(_SURNAKT.KTM+' - '+_SURNAKT.N);
         _SURNAKT.next()
      !};
      KOMM.sect_end()
   ?};
   0
|| 1
?}


\tktl_used
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza, czy karta technologiczna jest używana
::   WE: _a - TKTL.ref()
::   WY: 1 (jest używana), 0 (nie jest używana)
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
TKTL.cntx_psh();
TKTL.prefix();
{? TKTL.seek(_a)
||
:: Sprawdzenie użycia w zleceniach
   _testlink:=TKTL.testlink(2);
   _testlink.prefix('ZL',);
   {? _testlink.first()
   || _result:=1
   ?}
?};
TKTL.cntx_pop();
_result


\tktl_corrected
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza, czy karta technologiczna była korygowana
::   WE: _a - TKTL.ref()
::   WY: 1 (była korygowana), 0 (nie była korygowana)
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
TKTL.cntx_psh();
TKTL.prefix();
{? TKTL.seek(_a)
||
   _can_continue:=1;

   {? _can_continue>0
   || TOPER.cntx_psh();
      TOPER.index('NNK');
      TOPER.prefix(_a);
      {? TOPER.first()
      || {!
         |? {? TOPER.CAUSE<>null()
            || _result:=1;
               _can_continue:=0
            ?};
            _can_continue>0 & TOPER.next()
         !}
      ?};
      TOPER.cntx_pop()
   ?};

   {? _can_continue>0
   || TECHZAMS.cntx_psh();
      TECHZAMS.index('TTL');
      TECHZAMS.prefix(_a);
      {? TECHZAMS.first()
      || {!
         |? {? TECHZAMS.CAUSE<>null()
            || _result:=1;
               _can_continue:=0
            ?};
            _can_continue>0 & TECHZAMS.next()
         !}
      ?};
      TECHZAMS.cntx_pop()
   ?};

   {? _can_continue>0
   || TMAT.cntx_psh();
      TMAT.index('NL');
      TMAT.prefix(_a);
      {? TMAT.first()
      || {!
         |? {? TMAT.CAUSE<>null()
            || _result:=1;
               _can_continue:=0
            ?};
            _can_continue>0 & TMAT.next()
         !}
      ?};
      TMAT.cntx_pop()
   ?};

   {? _can_continue>0
   || TCHMAT.cntx_psh();
      TCHMAT.index('NSL');
      TCHMAT.prefix(_a);
      {? TCHMAT.first()
      || {!
         |? {? TCHMAT.CAUSE<>null()
            || _result:=1;
               _can_continue:=0
            ?};
            _can_continue>0 & TCHMAT.next()
         !}
      ?};
      TCHMAT.cntx_pop()
   ?};

   {? _can_continue>0
   || TACTTLS.cntx_psh();
      TACTTLS.index('KNROP');
      TACTTLS.prefix(_a);
      {? TACTTLS.first()
      || {!
         |? {? TACTTLS.CAUSE<>null()
            || _result:=1;
               _can_continue:=0
            ?};
            _can_continue>0 & TACTTLS.next()
         !}
      ?};
      TACTTLS.cntx_pop()
   ?}

?};
TKTL.cntx_pop();
_result


\tech_clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Uniwersalna funkcja czyszcząca czynności dla technologii - w razie potrzeby jak nie ma rekordu kluczowego zrobi
::       done albo error. Dodatkowo może być wywoływana przez czynność czyszczącą zadania na TODO
::   WE: _a - _mp - obiekt Menadżera procesów
::       _b - tablica z parametrami wejściowymi
::       [_c] - STRING - co robić jak technologia zaakceptowana: 'ERROR', ['DONE'], jeżeli puste to obsługa nie wykonywana
::       [_d] - STRING - co robić jak technologia w archiwum: ['ERROR'], 'DONE', jeżeli puste to obsługa nie wykonywana
::   WY: obj_new() - obiekt wynikowy
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=_a;
_in:=_b;
{? var_pres('_c')=type_of('')
|| _closed:=_c
|| _closed:='DONE'
?};
{? var_pres('_d')=type_of('')
|| _arch:=_d
|| _arch:='ERROR'
?};

_can_continue:=1;
_obj:=obj_new('RESULT','TKTL');
_obj.RESULT:=0;
_obj.TKTL:=null();

_keyRefs:=_mp.getRefs();

{? obj_len(_keyRefs)>0
||
   {! _it:=1..obj_len(_keyRefs)
   |! _kref:=_keyRefs[_it];

      {? type_of(_kref)>0
      ||
         {? ref_tab(_kref)=TKTL
         || _obj.TKTL:=exec('FindAndGet','#table',TKTL,_kref,,,null());

            {? _obj.TKTL=null()
            ||
::             Nie znaleziono rekordu kluczowego powiązanego z kartą, więc robię error
               _can_continue:=0;
               exec('tech_deleted_in_proc','tech_common',_mp)
            |? _closed<>'' & ~_mp.isMicro() & exec('FindAndGet','#table',TKTL,_obj.TKTL,,"TKTL.STAN",'')='T'
            ||
::             Karta zaakceptowana
               _can_continue:=0;
               exec('tech_deleted_in_proc','tech_common',_mp,{? _closed='DONE' || 0 || 1 ?},0,_obj.TKTL)
            |? _arch<>'' & ~_mp.isMicro() & exec('FindAndGet','#table',TKTL,_obj.TKTL,,"TKTL.ARCH",'')='T'
            ||
::             Karta w archiwum
               _can_continue:=0;
               exec('tech_deleted_in_proc','tech_common',_mp,{? _arch='DONE' || 0 || 1 ?},2,_obj.TKTL)
            ?}
         ?}
      ?}
   !}
?};

{? _can_continue>0
||
:: jest parametr wejściowy TKTL
   {? _obj.TKTL=null() & var_pres('TKTL',_in)=type_of(null())
   || _obj.TKTL:=_in.TKTL
   ?}
?};

{? _can_continue>0
|| _obj.RESULT:=1
?};
_obj


\tech_deleted_in_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Obsługa sytuacji że jest czynność na liście todo ale technologia została usunięta
::   WE: _a - obj_new - obiekt Menadżera Procesów
::       [_b] - INTEGER - 0/[1] - czy errorować proces, jeżeli 0 to jest robiony .done()
::       [_c] - INTEGER - 0 - zaakceptowana, [1] - usunięta, 2 - w archiwum
::       [_d] - TKTL.ref - ref karty
::   WY: ~~
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=_a;

_error:=1;
{? var_pres('_b')=type_of(0)
|| _error:=_b
?};
_deleted:=1;
{? var_pres('_c')=type_of(0)
|| _deleted:=_c
?};

_tktl:=null();
{? var_pres('_d')=type_of(TKTL.ref())
|| _tktl:=_d
?};

{? _deleted=1
|| _msg:=exec('tech_deleted_msg','tech_common')
|? _deleted=0
|| _msg:=exec('tech_accepted_msg','tech_common')
|? _deleted=2
|| _msg:=exec('tech_archived_msg','tech_common')
?};
{? _mp.isService()=0 & _mp.CLEANER=0
|| {? _mp.isGroup()
   || KOMM.add(_msg,2,,1)
   || FUN.emsg(_msg)
   ?}
?};
{? _error>0
|| _mp.error(_msg)
|| {? _tktl<>null()
   || _out:=_mp.load(exec('kind_out','#b_port'));
      {? var_pres('TKTL',_out)>=0
      || _out.TKTL:=_tktl
      ?};
      {? var_pres('TKTL_ARCH',_out)>=0
      || _out.TKTL_ARCH:=_tktl
      ?};
      _mp.save(,_out)
   ?};
   _mp.done()
?};
~~


\tech_deleted_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Komunikat o usunięciu technologii
::----------------------------------------------------------------------------------------------------------------------
'Technologia nie została odnaleziona, prawdopodobnie została usunięta.'@


\tech_accepted_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Komunikat o zatwierdzeniu technologii
::----------------------------------------------------------------------------------------------------------------------
'Technologia jest zaakceptowana — czynność zostanie zakończona.'@


\tech_archived_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Komunikat o zatwierdzeniu technologii
::----------------------------------------------------------------------------------------------------------------------
'Technologia jest w archiwum — czynność zostanie zakończona.'@


\chk_tpktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Walidacja rekordu tabeli TPKTL (karty technologiczne) - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(TPKTL,,'TYP','OPIS','CRUB');
{? _chk=''
|| {? TPKTL.XJM<0
   || FUN.info('Domyślna ilość nie może być mniejsza niż zero.'@);
      'XJM'
   |? __CHK.index(TPKTL,_a)=''
   || ''
   || 'TYP'
   ?}
|| _chk
?}


\chk_tpktlf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Walidacja rekordu tabeli TPKTLF (warianty technologii) - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(TPKTLF);
{? _chk=''
|| {? __CHK.index(TPKTLF,_a)='' || '' || 'OPC' ?}
|| _chk
?}


\chk_ttxcause
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Walidacja rekordu tabeli TTXCAUSE (przyczyny zmian w technologii)
::       - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(TTXCAUSE);
{? _chk=''
|| {? __CHK.index(TTXCAUSE,_a)='' || '' || 'NAZ' ?}
|| _chk
?}


\tktl_analizas_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Analiza dostępności surowców w czasie - akcja 'przed' dla tabeli TKTL
::       analizie podlegają tylko surowce produktów w ilości nie zleconej
::----------------------------------------------------------------------------------------------------------------------
{? TKTL.sel_size()=0
|| exec('env_create','tech_structure',1);
   _can_continue:=exec('edit_params','tech_structure',1,1,1)
|| return
?};
_env:=__ENV_STR;
::  Rozpoczynam pętle
_exit:=1;
{!
|?
   {? var_press('TAB',__ENV_STR.STRUCT)>0 || _env.STRUCT.TAB.erase  ?};
   {? var_press('ELEMENT',__ENV_STR.STRUCT)>0 || _env.STRUCT.ELEMENT.erase  ?};
   {? var_press('TAB',__ENV_STR.CHECK) > 0 || _env.CHECK.TAB.erase ?};

   {? _can_continue>0
   ||  {? var_pres('_args') > 0 || obj_del(_args) ?};
      _args:=exec('add_a','tech_structure');
      _args.M:=TKTL.KTM;
      _args.IL:={? _env.PARAMS.IL=0 || TKTL.XJM || _env.PARAMS.IL ?};
      _args.DW:=_env.PARAMS.DW;
      _args.TW:=time(0,0,0);
      _args.TKTL:=TKTL.ref();
      _args.SRC_REF:=$TKTL.ref();
      exec('add','tech_structure',_args);
      exec('expand','tech_structure',_args.ref)
   ?};
::     Wyświetlam tabelę z problemami i uzupełniam tabelę zamienników
   _ok:=1;
   {? _env.CHECK.TAB.size()>0
   || _env.CHECK.TAB.win_sel(_env.CHECK.WERA);
      _ok:=exec('tktl_chck_sel','tech_structure',1);
      {? _ok=0 || _exit:=0 ?}
   || _exit:=0
   ?};
_exit
!};
::Koniec petli

{? TKTL.sel_size()=0 & _can_continue>0 & _ok
|| exec('cumulate','tech_structure');
   exec('select','tech_structure')
?};
~~


\tktl_analizas_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Analiza dostępności surowców w czasie - akcja 'po' dla tabeli TKTL
::----------------------------------------------------------------------------------------------------------------------
~~


\tktl_analizas_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Analiza dostępności surowców w czasie - akcja 'przed grupą' dla tabeli TKTL
::----------------------------------------------------------------------------------------------------------------------
exec('env_create','tech_structure',1);
_can_continue:=exec('edit_params','tech_structure',1,1,1);
_env:=__ENV_STR;
::  Rozpoczynam pętle
_exit:=1;
{!
|?
   {? var_press('TAB',__ENV_STR.STRUCT)>0 || __ENV_STR.STRUCT.TAB.erase  ?};
   {? var_press('ELEMENT',__ENV_STR.STRUCT)>0 || __ENV_STR.STRUCT.ELEMENT.erase  ?};
   {? var_press('TAB',__ENV_STR.CHECK) > 0 || _env.CHECK.TAB.erase ?};

   {? _can_continue>0
   ||
      {? var_press('_selected')<=0 || _selected:=TKTL.sel_aget() ?};
      TKTL.sel_adel();
      {? _selected.first()
      || {!
         |? TKTL.cntx_psh();
            TKTL.prefix();
            {? TKTL.seek(_selected.REF)
            ||
               {? var_pres('_args') > 0 || obj_del(_args) ?};
               _args:=exec('add_a','tech_structure');
               _args.M:=TKTL.KTM;
               _args.IL:={? _env.PARAMS.IL=0 || TKTL.XJM || _env.PARAMS.IL ?};
               _args.DW:=_env.PARAMS.DW;
               _args.TW:=time(0,0,0);
               _args.TKTL:=TKTL.ref();
               _args.SRC_REF:=$TKTL.ref();
               exec('add','tech_structure',_args);
               exec('expand','tech_structure',_args.ref)
            ?};
            TKTL.cntx_pop();
            _selected.next()
         !}
      ?}
   ?};
::     Wyświetlam tabelę z problemami i uzupełniam tabelę zamienników
   _ok:=1;
   {? _env.CHECK.TAB.size()>0
   || _env.CHECK.TAB.win_sel(_env.CHECK.WERA);
      _ok:=exec('tktl_chck_sel','tech_structure',1);
      {? _ok=0 || _exit:=0 ?}
   || _exit:=0
   ?};
_exit
!};
::Koniec petli

{? _ok
|| exec('cumulate','tech_structure');
   exec('select','tech_structure')
?};
{? var_press('_selected')>0 || obj_del(_selected) ?};
~~


\tktl_analizas_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Analiza dostępności surowców w czasie - akcja 'po grupie' dla tabeli TKTL
::----------------------------------------------------------------------------------------------------------------------
~~


\tktlw_analizas_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Analiza dostępności surowców w czasie - akcja 'przed' dla tabeli TKTLW
::       analizie podlegają tylko surowce produktów w ilości nie zleconej
::----------------------------------------------------------------------------------------------------------------------
{? TKTLW.sel_size()=0
|| exec('env_create','tech_structure',1);
   _can_continue:=exec('edit_params','tech_structure',1,1,1)
|| return
?};
_env:=__ENV_STR;
::  Rozpoczynam pętle
_exit:=1;
{!
|?
   {? var_press('TAB',__ENV_STR.STRUCT)>0 || __ENV_STR.STRUCT.TAB.erase  ?};
   {? var_press('ELEMENT',__ENV_STR.STRUCT)>0 || __ENV_STR.STRUCT.ELEMENT.erase() ?};
   {? var_press('TAB',__ENV_STR.CHECK) > 0 || _env.CHECK.TAB.erase ?};

   {? _can_continue>0
   || {? var_pres('_args') > 0 || obj_del(_args) ?};
      _args:=exec('add_a','tech_structure');
      _args.M:=TKTLW.KTM;
      _args.IL:={? _env.PARAMS.IL=0 || TKTLW.TKTL().XJM || _env.PARAMS.IL ?};
      _args.DW:=_env.PARAMS.DW;
      _args.TW:=time(0,0,0);
      _args.TKTL:=TKTLW.TKTL;
      _args.SRC_REF:=$TKTLW.ref();
      exec('add','tech_structure',_args);
      exec('expand','tech_structure',_args.ref)
   ?};
::     Wyświetlam tabelę z problemami i uzupełniam tabelę zamienników
      _ok:=1;
      {? _env.CHECK.TAB.size()>0
      || _env.CHECK.TAB.win_sel(_env.CHECK.WERA);
         _ok:=exec('tktl_chck_sel','tech_structure',2);
         {? _ok=0 || _exit:=0 ?}
      || _exit:=0
      ?};
_exit
!};
::Koniec petli


{? TKTLW.sel_size()=0 & _can_continue>0 & _ok
|| exec('cumulate','tech_structure');
   exec('select','tech_structure')
?};
~~


\tktlw_analizas_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Analiza dostępności surowców w czasie - akcja 'po' dla tabeli TKTLW
::----------------------------------------------------------------------------------------------------------------------
~~


\tktlw_analizas_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Analiza dostępności surowców w czasie - akcja 'przed grupą' dla tabeli TKTLW
::----------------------------------------------------------------------------------------------------------------------
exec('env_create','tech_structure',1);
_can_continue:=exec('edit_params','tech_structure',1,1,1);
_env:=__ENV_STR;
::  Rozpoczynam pętle
_exit:=1;
{!
|?
   {? var_press('TAB',__ENV_STR.STRUCT)>0 || __ENV_STR.STRUCT.TAB.erase  ?};
   {? var_press('ELEMENT',__ENV_STR.STRUCT)>0 || __ENV_STR.STRUCT.ELEMENT.erase  ?};
   {? var_press('TAB',__ENV_STR.CHECK) > 0 || _env.CHECK.TAB.erase ?};

   {? _can_continue>0
   ||
      {? var_press('_selected')<=0 || _selected:=TKTLW.sel_aget() ?};
      TKTLW.sel_adel();
      {? _selected.first()
      || {!
         |? TKTLW.cntx_psh();
            TKTLW.prefix();
            {? TKTLW.seek(_selected.REF)
            ||
               {? var_pres('_args') > 0 || obj_del(_args) ?};
               _args:=exec('add_a','tech_structure');
               _args.M:=TKTLW.KTM;
               _args.IL:={? _env.PARAMS.IL=0 || TKTLW.TKTL().XJM || _env.PARAMS.IL ?};
               _args.DW:=_env.PARAMS.DW;
               _args.TW:=time(0,0,0);
               _args.TKTL:=TKTLW.TKTL;
               _args.SRC_REF:=$TKTLW.ref();
               exec('add','tech_structure',_args);
               exec('expand','tech_structure',_args.ref)
            ?};
            TKTLW.cntx_pop();
            _selected.next()
         !}
      ?}
   ?};
::     Wyświetlam tabelę z problemami i uzupełniam tabelę zamienników
   _ok:=1;
   {? _env.CHECK.TAB.size()>0
   || _env.CHECK.TAB.win_sel(_env.CHECK.WERA);
      _ok:=exec('tktl_chck_sel','tech_structure',2);
      {? _ok=0 || _exit:=0 ?}
   || _exit:=0
   ?};_exit
!};
::Koniec petli

{? _ok
|| exec('cumulate','tech_structure');
   exec('select','tech_structure')
?};
{? var_press('_selected')>0 || obj_del(_selected) ?};
~~


\tktlw_analizas_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Analiza dostępności surowców w czasie - akcja 'po grupie' dla tabeli TKTLW
::----------------------------------------------------------------------------------------------------------------------
~~


\tktl_export
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Rozpoczyna eksport kart technologicznych
::----------------------------------------------------------------------------------------------------------------------
exec('doklwg_m','material');
cur_tab(1,1).sel_adel();
_zakl:='';
_mask:='';
_tab:=cur_tab(1,1);
:: Zapamiętuję zakładkę na jakiej stoję (żeby później odtworzyć filtr dla kart)
{? _tab.name()*'txktw'>0
|| _zakl:='TKTLW'
|? _tab.name()*'txktl'>0
|| {? _tab.name()<>'txktl___'
   || _zakl:='TKTL_A';
      _mask:=_tab.name()
   || {? (TKTL.TERM_OD<>date(0,0,0) & TKTL.TERM_OD>date()) | (TKTL.TERM_DO<>date(0,0,0) & TKTL.TERM_DO<date())
      || _zakl:='TKTL_N'
      || _zakl:='TKTL'
      ?}
   ?}
|| ''
?};
::TKTL.f_clear();TKTLW.f_clear();
exec('tktl_cntx_psh','tech_common');
exec('tktl_use','tech_common');
:: Tabela mapująca operacje technologiczne (systemowe unikalne numery operacji z nowymi, wygenerowanymi numerami)
__TOPER_MAP:=tab_tmp(,'OLD','REAL','Unikalny nr operacji pobrany z systemu'
                     ,'NEW','REAL','Nowy, wygenerowany unikalny nr operacji');
_fun:=obj_new(1);
_fun[1]:='TKTL';
exec('export_init','#excel_imex',_fun,1,'TKTL','Technologie'@);
VAR_DEL.delete('__TOPER_MAP');
exec('tktl_cntx_pop','tech_common');
:: Odtworzenie filtra w oknie wertowania obszaru kart technologicznych
{? _zakl<>''
|| {? _zakl='TKTLW'
   ||  exec('set_wfilter','tech_head')
   |? _zakl='TKTL_N'
   ||  exec('set_nfilter','tech_head')
   ||  exec('set_filter','tech_head')
   ?}
?};
0


\tktl_import
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Rozpoczyna import kart technologicznych
::----------------------------------------------------------------------------------------------------------------------
KOMM.init(,,'Import kart technologicznych'@);
_zakl:='';
_mask:='';
_tab:=cur_tab(1,1);
_tab.sel_adel();
:: Zapamiętuję zakładkę na jakiej stoję (żeby później odtworzyć filtr dla kart)
{? _tab.name()*'txktw'>0
|| _zakl:='TKTLW'
|? _tab.name()*'txktl'>0
|| {? _tab.name()<>'txktl___'
   || _zakl:='TKTL_A';
      _mask:=_tab.name()
   || {? (TKTL.TERM_OD<>date(0,0,0) & TKTL.TERM_OD>date()) | (TKTL.TERM_DO<>date(0,0,0) & TKTL.TERM_DO<date())
      || _zakl:='TKTL_N'
      || _zakl:='TKTL'
      ?}
   ?}
|| ''
?};
::TKTL.f_clear();TKTLW.f_clear();
exec('tktl_cntx_psh','tech_common');
exec('tktl_use','tech_common');
exec('Tpar_decl','tech_param');
DK_C.cntx_psh();
_oddz:=ST.ODDZ;
DK_C.use('dokce'+_oddz+'__');
_fun:=obj_new(1);
_fun[1]:='TKTL';
:: Tabela przechowująca informacje o następnikach operacji
__NASTOPER:=tab_tmp(,'TKTL','STRING[16]','$TKTL.ref'
                    ,'TOPER','STRING[16]','$TOPER.ref'
                    ,'NASTOPER','REAL','Unikalny nr następnika, NASTOPER.NRNAST().UNROP');
:: Tabela przechowująca refy kart, które się źle zaimportowały lub został zgłoszony błąd
:: (rekordy odnoszące się do tych kart będą pomijane przy imporcie)
__TKTL_ERR:=tab_tmp(,'NRK','STRING[50]','Nr karty'
                    ,'WER','STRING[6]','Wersja');
:: Tabela mapująca symbol cech atrybutu dostawy (DK_C) z jego refem w docolemym systemie
__DK_C_MAP:=tab_tmp(,'SYM','STRING[50]','Symbol atrybutu dostaw (DK_C.SYM)'
                    ,'REF','STRING[16]','Ref atrybutu dostaw $DK_C.ref');
:: Tabela mapująca karty wyrobów (TKTLW) - wymagana jeżeli w trakcie importu zmieniono znacznik domyślności
__TKTLW_MAP:=tab_tmp(,'NRK','STRING[50]','Nr karty'
                     ,'WER','STRING[6]','Wersja'
                     ,'KTM','STRING[16]','Indeks materiału'
                     ,'DEFAULT','STRING[1]','Czy karta domyślna'
                     ,'REF','STRING[16]','TKTLW.ref');
exec('import_init','#excel_imex',_fun,,0,,,1);

:: Sprawdzam, czy w systemie są karty technologicznych z błędnie zaimportowanymi elementami
TKTL.cntx_psh();
TKTL.index('IMP_ERR');
TKTL.prefix('T');
{? TKTL.first()
|| exec('declare','tech_doc');
   {!
   |?
::    W systemie są błędnie zaimportowane karty (z jakiegoś powodu nie zostały usunięte podczas importu).
::    Próbuję usunąć jeszcze raz.
       {? (_result:=exec('tktl_clear_del','tech_common',TKTL.ref()))<=0
       ||
::       Nie udało się usunąć.Zmieniam stany karty, żeby nie dało się z nimi nic zrobić (blokuję zatwierdzenie nagłówka)
         TKTL.STAT_N:='N';
         TKTL.STAT_O:='N';
         TKTL.STAT_S:='N';
         TKTL.STAT_P:='N';
         TKTL.STAN:='N';
         TKTL.put();
         KOMM.add('Nie udało się usunąć błędnie zaimportowanej karty: %1 (wer. %2). Kartę należy usunąć ręcznie.'@
                  [TKTL.NRK,TKTL.WER])
       ?};
      TKTL.next()
   !}
?};
TKTL.cntx_pop();

DK_C.cntx_pop();
exec('tktl_cntx_pop','tech_common');
VAR_DEL.delete('__NASTOPER','__TKTL_ERR','__DK_C_MAP','__TKTLW_MAP');
:: Odtworzenie filtra w oknie wertowania obszaru kart technologicznych
{? _zakl<>''
|| {? _zakl='TKTLW'
   ||  exec('set_wfilter','tech_head')
   |? _zakl='TKTL_N'
   ||  exec('set_nfilter','tech_head')
   ||  exec('set_filter','tech_head')
   ?}
?};
KOMM.select();
0


\tktl_import_clear
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Funckja czyszcąca wykorzystywana TYLKO podczas importu kart technologicznych.
::       Usuwa błędnie zaimportowane technologie oraz czyści niepotrzebne komunikaty
::   WE: _a - obj_new - środowisko imex - wynik działania exec('env','#excel_imex')
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
TKTL.cntx_psh();
TKTL.index('IMP_ERR');
TKTL.prefix('T');
{? TKTL.first()
|| exec('declare','tech_doc');
   _id_grp:=_env.ID_GRP;
   {!
   |?
      _result:=exec('tktl_import_clear_del','tech_common',_env,TKTL.ref());
      TKTL.next()
   !};
   _env.ID_GRP:=_id_grp
?};
TKTL.cntx_pop();
~~


\tktl_import_clear_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Usuwa błędnie zaimportowaną kartę technologiczną oraz karty, które wykorzystywały ją jako kartę półfabrykatu.
::       Dodatkowo usuwa komunikaty powiązane z daną kartą. Funckja wykorzystywana TYLKO podczas importu kart.
::   WE: _a - obj_new - środowisko imex - wynik działania exec('env','#excel_imex')
::       _b - TKTL.ref() - ref usuwanej karty
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tktl:=_b;
_result:=1;
TKTL.cntx_psh();
TKTL.clear();
{? TKTL.seek(_tktl)
||
:: Usuwam karty, które wykorzystywały błędnie zaimportowaną kartę jako kartę półfabrykatu dla surowców
   TMAT.cntx_psh();
   TMAT.index('RKTL');
   TMAT.prefix($TKTL.ref());
   {? TMAT.first()
   || {!
      |?
::       !!!REKURENCJA!!!
         _result:=exec('tktl_import_clear_del','tech_common',_env,TMAT.NRK);
         TMAT.next() & _result>0
      !}
   ?};
   TMAT.cntx_pop();
:: Usuwam karty, które wykorzystywały błędnie zaimportowaną kartę jako kartę półfabrykatu dla zamienników surowców
   {? _result>0
   ||
      TCHMAT.cntx_psh();
      TCHMAT.index('RKTL');
      TCHMAT.prefix($TKTL.ref());
      {? TCHMAT.first()
      || {!
         |?
::          !!!REKURENCJA!!!
            _result:=exec('tktl_import_clear_del','tech_common',_env,TCHMAT.NRK);
            TCHMAT.next() & _result>0
         !}
      ?};
      TCHMAT.cntx_pop()
   ?};
:: Oznaczam kartę jako błędnie zaimportowaną i dodaję do listy ignorowanych przy imporcie
   TKTL.IMP_ERR:='T';
   TKTL.put();
   {? ~__TKTL_ERR.find_key(TKTL.NRK,TKTL.WER,)
   || __TKTL_ERR.NRK:=TKTL.NRK;
      __TKTL_ERR.WER:=TKTL.WER;
      __TKTL_ERR.add()
   ?};

:: Jak usunięte wszystkie powiązane karty to usuwam kartę główną wraz z komunikatami
   {? _result>0
   ||
      _ref:=$TKTL.ref();
      _nrk:=TKTL.NRK;
      _wer:=TKTL.WER;
      _env.ID_GRP:=_ref;
      {? (_result:=exec('TKTL_kasuj','tech_head',TKTL.ref()))>0
      ||
::       Usuwanie komunikatów
         exec('history_clear_id_grp','#excel_imex',_env,_ref);
         exec('history_clear_id_grp','#excel_imex',_env,_nrk+'-'+_wer)
      ?}
   ?}

?};
TKTL.cntx_pop();
_result


\tktl_clear_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Usuwa błędnie zaimportowaną kartę technologiczną oraz karty, które wykorzystywały ją jako kartę półfabrykatu.
::   WE: _a - TKTL.ref() - ref usuwanej karty
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_tktl:=_a;
_result:=1;
TKTL.cntx_psh();
TKTL.clear();
{? TKTL.seek(_tktl)
||
:: Usuwam karty, które wykorzystywały błędnie zaimportowaną kartę jako kartę półfabrykatu dla surowców
   TMAT.cntx_psh();
   TMAT.index('RKTL');
   TMAT.prefix($TKTL.ref());
   {? TMAT.first()
   || {!
      |?
::       !!!REKURENCJA!!!
         _result:=exec('tktl_clear_del','tech_common',TMAT.NRK);
         TMAT.next() & _result>0
      !}
   ?};
   TMAT.cntx_pop();
:: Usuwam karty, które wykorzystywały błędnie zaimportowaną kartę jako kartę półfabrykatu dla zamienników surowców
   {? _result>0
   ||
      TCHMAT.cntx_psh();
      TCHMAT.index('RKTL');
      TCHMAT.prefix($TKTL.ref());
      {? TCHMAT.first()
      || {!
         |?
::          !!!REKURENCJA!!!
            _result:=exec('tktl_clear_del','tech_common',TCHMAT.NRK);
            TCHMAT.next() & _result>0
         !}
      ?};
      TCHMAT.cntx_pop()
   ?};

:: Jak usunięte wszystkie powiązane karty to usuwam kartę główną
   {? _result>0
   || _result:=exec('TKTL_kasuj','tech_head',TKTL.ref())
   ?}
?};
TKTL.cntx_pop();
_result


\techdom_env
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Obiekt środowiska dla obsługi zakładki Technologia domyślna w kartotece materiałowej
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
::UWAGA: _fld, i _mth to formułki pomocnicze, zeby wygodniej tworzyć tablicę i komentować poszczególne jej elementy
::       powiedzmy, że to bedzie pole
         _fld:="31+form(_a)";
::       powiedzmy, że to bedzie metoda
         _mth:="31+form(_a)";

_env:=obj_new(
::             Zmienne pomocnicze
               _fld('TKTL','Technologia domyślna bieżącego materiału')
               ,_fld('OPER_SRC','Operacja')
               ,_fld('M','Materiał')
               ,_fld('TECH_reload','Czy przeładować')
               ,_fld('R_PROD','Pole filtra')
               ,_fld('R_KOMP','Pole filtra')

             );
_env.TKTL:=null();
_env.OPER_SRC:=null();
_env.M:=null();
_env.TECH_reload:=0;
_env


\techdom_after_rfr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Akcja po odświeżeniu w kartotece materiałowej dla zakładki Technologia domyślna
::   WE: [_a] - INTEGER - czy wykonywać grp_disp
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;

_grp_disp:=1;
{? var_pres('_a')=type_of(0)
|| _grp_disp:=_a
?};
_env.M:=M.ref();
_env.TKTL:=exec('getdefaulttech','tech_common',M.ref(),0);
VAR.A_KTL:=_env.TKTL;
{? _env.TKTL=null()
|| TTREE.TAB.erase();
   TTREE.ZRODLO:='';
   {? _grp_disp>0
   || grp_disp(TTREE.TAB,TTREE.WERT,,1);
      grp_disp(TMAT,'WERMAT',,1)
   ?};
   return(0)
?};
exec('techdom_operacje_load','tech_common');
exec('techdom_surowce_load','tech_common');
VAR.DJ:=exec('FindAndGet','#table',TKTL,_env.TKTL,,"TYP().DJ",'');
{? _grp_disp>0
|| grp_disp(TTREE.TAB,TTREE.WERT,1,1)
?};
~~


\techdom_cfg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Zakładka Technologia domylśna w kartotece materiałowej - init
::   WE: _a - STRING - akronim okienka grupowego
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;

_grp:=_a;

VAR.TOW_USL:='T';
ZAKR.MATU:='A';

_tab:='Technologia domyślna'@;

:: Podmiana metody 'f_record' dla zakladek
exec('declare','tech_tree');
TKTL.blank();
exec('tree','tech_oper',6,1);
set_virt(TTREE,'f_record',"
   params_set(params_get());
   _env:=params_get().env.ENV_TECH;
   _env.OPER_SRC:=null();
   VAR.A_OP:=null();
   {? _env.TKTL<>null()
   ||
:     VAR.A_KTL();
      TOPER.clear();
      {? TOPER.seek(TTREE.TAB.REF,)
      || _env.OPER_SRC:=TOPER.ref();
         VAR.A_OP:=TOPER.ref();
         exec('prep_ch','tech_oper');
         _res:=Color.rekprzed('TOPER#01#01')
      || _res:=~~
      ?};
::      TOPER.cntx_psh();
      TOPER.index('NNN');
      TOPER.prefix(_env.TKTL,TOPER.NRNOP,'N');
      M.cntx_psh();
      grp_disp(TMAT,'WERMAT',,1);
::      TOPER.cntx_pop();
      M.cntx_pop();
      _res
   ?}
");

:: Zlecenie bez wlasnej technologii

TTREE.TAB.win_sel(TTREE.WERT);
TTREE.TAB.win_fml(TTREE.WERT,,'TXT',,'ICON_BEFORE',TTREE.win_fml());
TTREE.TAB.hdr_sel('Operacje'@);

:: Dodajemy okno operacji technologii
_fb:="
   params_set(params_get());
   _env_mat:=params_get().env;

   _result:=_env_mat.DISABLE;

   _env:=_env_mat.ENV_TECH;
   _env_mat.PANEL.INFO.CUR_TAB:=_env_mat.PANEL.INFO.TAB.TECHDOM.TABNR;

   {? _a>0
   || exec('techdom_run_action','tech_common','TTE_TEC_DRTO','START');
      params_exec('techdom_after_rfr','tech_common',0)
   ?};

   {? _env.TKTL=null()
   || TTREE.TAB.erase();
      TTREE.ZRODLO:='';
      TTREE.TAB.hdr_sel();
      TTREE.TAB.hdr_sel('Operacje technologii'@);
      _result:='#disable'
   ?};
   {? _result=''
   ||
      {? _a>0
      || params_exec('techdom_operacje_load','tech_common','T');
         params_exec('techdom_surowce_load','tech_common','T')
      ?};
      VAR.ACTION:='Z';

      {? _env.TKTL<>null()
      || VAR.DJ:=exec('FindAndGet','#table',TKTL,_env.TKTL,,\"TYP().DJ\",'')
      || VAR.DJ:=''
      ?}
   ?};
   {? grp_empty(TTREE.TAB,TTREE.WERT,1)
   || _env.OPER_SRC:=null()
   ?};
   _result
";
_fa:="
   params_set(params_get());
   _env_mat:=params_get().env;
   _env:=_env_mat.ENV_TECH;
   {? _a>0
   || exec('techdom_run_action','tech_common','TTE_TEC_DRTO','STOP')
   ?};
   {? grp_empty(TTREE.TAB,TTREE.WERT,1)
   || _env.OPER_SRC:=null()
   ?};
   ~~
";
_rfr:="
   params_exec('techdom_operacje_after_rfr','tech_common','T')
";
M.grp_sel(_grp,TTREE.TAB,TTREE.WERT,_tab,_rfr,,,3,_fb,_fa,,,'maximized_with_title');
:: Przypinam okno (zakładkę) do czynności
task_attach('TTE_TEC_PKTE');
task_attach('TTE_TEC_DRTE');
task_attach('TTE_TEC_DRTO');
task_attach('TTE_TEC_DRTS');
task_attach('TTE_TEC_DRDP');

M.tab_splt(_grp,'tab0','horizontal','tab1',);

:: Dodajemy okno surowców
_fb:="
   M.cntx_psh();

   params_set(params_get());
   _env_mat:=params_get().env;
   _result:=_env_mat.DISABLE;

   _env:=_env_mat.ENV_TECH;
   _env_mat.PANEL.INFO.CUR_TAB:=_env_mat.PANEL.INFO.TAB.TECHDOM.TABNR;

   _user_action:=_a;
   _opcja:='T';
   {? _user_action>0
   || _env.R_PROD:=ZAKR.R_PROD;
      _env.R_KOMP:=ZAKR.R_KOMP;
      exec('techdom_run_action','tech_common','TTE_TEC_DRTS','START');
      {? exec('get','#params',500740,2)='N'
      || exec('filter_clear','material')
      || exec('filter','material','PS')
      ?};

      params_exec('techdom_surowce_load','tech_common');
      ~~
   ?};
   {? _env.TKTL=null()
   || _result:='#disable'
   || TKTL.prefix();
      TKTL.seek(_env.TKTL)
   ?};

   _result
";
_fa:="
   params_set(params_get());
   _env_mat:=params_get().env;
   _env:=_env_mat.ENV_TECH;
   M.cntx_pop();
   {? _a>0
   || ZAKR.R_PROD:=_env.R_PROD;
      ZAKR.R_KOMP:=_env.R_KOMP;
      exec('techdom_run_action','tech_common','TTE_TEC_DRTS','STOP')
   ?};
   ~~
";
_rfr:="
   params_exec('techdom_surowce_after_rfr','tech_common','T')
";
M.grp_sel(_grp,TMAT,'WERMAT',,_rfr,,,,_fb,_fa,,,'maximized_with_title');
:: Przypinam okno (zakładkę) do czynności
task_attach('TTE_TEC_PKTE');
task_attach('TTE_TEC_DRTE');
task_attach('TTE_TEC_DRTO');
task_attach('TTE_TEC_DRTS');
task_attach('TTE_TEC_DRDP');
_formikon:="
   TCHMAT.cntx_psh();
   TCHMAT.index('NSL');
   TCHMAT.prefix(TMAT.NRK,TMAT.ref());
   {? TCHMAT.first()
   || _ico:='xwin16.png:92'
   || _ico:='xwin16.png:110'
   ?};
   TCHMAT.cntx_pop();
   _ico
";
TMAT.win_fml('WERMAT',VAR,'K_NKTM',,'ICON_BEFORE',_formikon,1);
~~


\techdom_operacje_load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS:
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;

VAR_DEL.delete('tab');

tab:=TTREE;
_used:=0;

VAR.A_TORW:='T';
{? _env.TKTL<>null()
|| _hide:=':';
   TKTL.cntx_psh();
   TKTL.prefix();
   {? TKTL.seek(_env.TKTL,ref_name(_env.TKTL),1)
   ||
      _used:=exec('keyref_locked','#b__box',TKTL.uidref(),'TTE_TEC_DRTO',0);
      _torw:=TKTL.TORW;
      _dia:=exec('dot_obj','#graph','toper');
      _hide:='Z:Z';
      {? TKTL.ARCH='T' | _used
      || _hide:='DPUF(Z):D'
      |? TKTL.STAN='T' & TKTL.TORW='T' & exec('can_modify','tech_common')
      || _hide:=':'
      |? TKTL.STAT_O='T' | TKTL.STAT_N='N' & TKTL.TORW<>'Z'
      || _hide:='DPUF(Z):D'
      ?};
      {? exec('get','#params',100900,2)='' || _hide:='F(D)'+_hide ?};
::      {? TKTL.TYP().SUR='K' || _hide:='E(S)'+_hide ?};
      {? TKTL.TYP().UTIL='N' || _hide:='E(N)'+_hide ?};

      {? TKTL.STAT_O='T' | TKTL.STAT_N='N' & TKTL.TORW<>'Z' | TKTL.ARCH='T' | _used
      || _hide:='Z'+_hide+'Z'
      ?};
      {? _dia.dot_cmd='' || _hide:='F(D)'+_hide ?};
      {? (TKTL.STAT_O='T' | _used | TKTL.ARCH='T' | TKTL.STAT_N='N' & TKTL.TORW<>'Z')
      || _hide:='F(N)'+_hide
      ?};
      {? (TKTL.STAT_O='T' | TKTL.TORW='W' | _used | TKTL.ARCH='T' | TKTL.STAT_N='N' & TKTL.TORW<>'Z')
      || _hide:='F(W)'+_hide+'F(W)'
      ?};
::      {? TKTL.TYP().SUR='K' || _hide:='E(S)'+_hide ?};
      {? TKTL.TYP().UTIL='N' || _hide:='E(N)'+_hide ?};
      {? ~(TKTL.STAN='T' & TKTL.ARCH='N' & ~_used) || _hide:='Ó'+_hide ?};
      {? TKTL.TORW='W' || _hide:='F(U)'+_hide ?};
      {? TKTL.TORW='W' | TKTL.TORW='T' || _hide:='F(Z)'+_hide ?};

::    Ukrycie akcji wynikające z uprawnień do czynności
      {? ~(exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRTO') & _torw='T')
      || _hide:='DPUÓZF(NW)'+_hide+'DZF(W)'
      ?};

      {? tab.ZRODLO<>$_env.TKTL | _env.TECH_reload>0
      ||
         VAR.A_UNROP:=0;
         _env.TECH_reload:=0;
         tab.replica();
         tab.load();
         tab.update();
         tab.ZRODLO:=$_env.TKTL;
         {? tab.TAB.first()
         || _env.OPER_SRC:=exec('FindAndGet','#table',TOPER,tab.TAB.REF,,,null());
            VAR.A_OP:=_env.OPER_SRC
         || _env.OPER_SRC:=null();
            VAR.A_OP:=null()
         ?}
      ?};
      tab.TAB.index(tab.NDX_UP);
      tab.TAB.prefix();
      tab.TAB.blank(1);
      tab.TAB.REF:=_env.OPER_SRC;
      {? ~tab.TAB.find_rec() || tab.TAB.first() ?};
      tab.TAB.actions(tab.WERT,_hide,,1);
      ~~
   || _hide:='DPUÓZF(NW)'+_hide+'DZF(W)'
   ?};
   TKTL.cntx_pop()
|| tab.TAB.index(tab.NDX_UP);
   tab.TAB.prefix();
   tab.TAB.blank(1);
   tab.TAB.REF:=_env.OPER_SRC;
   {? ~tab.TAB.find_rec() || tab.TAB.first() ?};
   tab.TAB.actions(tab.WERT,'DPUÓZF(W):DEZF(W)',,1);
   _env.OPER_SRC:=null();
   VAR.A_OP:=null();
   ~~
?};

tab.TAB.hdr_sel();
tab.TAB.hdr_sel(
::       Takie czary, żeby zadziałało tłumaczenie poniżej (tekst MUSI być identyczny)
      'Operacje technologii [Karta typu: %1 — %2, ilość: %3, technologia: %4 wer. %5]'@['','','','',''];
      exec('FindAndGet','#table',TKTL,_env.TKTL,,"
         'Operacje technologii [Karta typu: %1 — %2, ilość: %3, technologia: %4 wer. %5]'@
         [TYP().TYP,TYP().OPIS,form(XJM),NRK,WER]
      ",'')
);
exec('start_tpar','tech_param',_env.M,_env.TKTL);
~~


\techdom_operacje_after_rfr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Po odświeżeniu okienka operacji
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
exec('techdom_surowce_load','tech_common');
M.cntx_psh();
grp_disp(TMAT,'WERMAT',,1);
M.cntx_pop();
~~


\techdom_surowce_after_rfr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Po odświeżeniu okienka surowców
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env;

::_keys:=':';
::_keys:=exec('techdom_actions_main','tech_common',_keys);
::TMAT.actions('WERMAT',_keys,,1);
~~


\techdom_surowce_load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS:
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;
_used:=0;
M.cntx_psh();
{? _env.TKTL<>null()
||
   {? TKTL.name()<>ref_name(_env.TKTL) || exec('tktl_use','tech_common',ref_name(_env.TKTL)+3) ?};
   TKTL.cntx_psh();
   TKTL.prefix();
   {? TKTL.seek(_env.TKTL)
   || _used:=exec('keyref_locked','#b__box',TKTL.uidref(),'TTE_TEC_DRTS',0);
      _keys:=':';
      _torw:=TKTL.TORW;
::    Zawsze wyświetlane wszystkie surowce
      {? 1
::         TKTL.TYP().SUR<>'O'
      || _env.OPER_SRC:=null();
         VAR.A_OP:=null()
      || {? _env.OPER_SRC=null()
         || _keys:='dpUWO'+_keys+'d'
         ?}
      ?};
      'A';
      _uprDelSur:=0;

::    Ukrycie akcji wynikające z uprawnień do czynności
      {? ~(exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRTS') & _torw='T')
      || _used:=1
      ?};

::    Ukrycie akcji wynikające z kontekstu programu
      _arc:=(TKTL.ARCH='T');

      _act:=1;
      {? _env.OPER_SRC<>null()
      || VAR.A_OP:=exec('FindAndGet','#table',TOPER,_env.OPER_SRC,,,null());
         _act:={? VAR.A_OP=null() || 1 || VAR.A_OP().ACT='T' ?};
         {? VAR.A_OP<>null() & VAR.A_OP().PZ='Z'
         ||
::          Dla operacji złożonej nie ma redagowania
            _used:=1
         ?}
      ?};
      {? TKTL.TORW<>'Z' || _keys:='W'+_keys ?};
      {? _used | _arc | ~_act | TKTL.STAN='N' & TKTL.TORW<>'Z' | TKTL.STAN='P' & TKTL.STAT_S='T'
      || _keys:='dpUWO'+_keys+'d'
      ?};
      {? TKTL.STAT_S='T' || _keys:='O'+_keys ?};
::      {? _disp_all || _keys:='d'+_keys+'d' ?};
      {? exec('is_k_res','tech_head',TKTL.TYP) | exec('is_t_res','tech_head',TKTL.TYP) || _keys:='CR'+_keys+'' ?};
      {? TKTL.TYP().PAR<>'T' || _keys:='R'+_keys ?};
      {? ~(TKTL.STAN='T' & ~_arc & ~_used) || _keys:='Ó'+_keys ?};
      {? TKTL.STAN='T' & (TKTL.TORW='W' | TKTL.TORW='Z' | ~exec('can_modify','tech_common'))
      || _keys:='dp'+{? TKTL.TORW='Z' || 'J(W)' || 'N(W)' ?}+{? _uprDelSur || '' || 'U' ?}+'ÓW'+_keys+'d'
            +{? TKTL.TORW='Z' || 'J(W)' || 'N(W)' ?}
      ?};
      {? (TKTL.TORW='Z' & TKTL.STAN<>'T') | _arc
      || _keys:='N(DPWU)'+_keys+'N(D)'
      ?};
      {? TKTL.TORW='W' || _keys:='N(W)'+_keys+'N(W)' ?};

      _keys:=exec('techdom_actions_main','tech_common',_keys);

      TMAT.actions('WERMAT',_keys,,1);
      _par:=TKTL.TYP().PAR;
      {? _par='' || TMAT.win_edit() || TMAT.win_edit('RED_'+_par)  ?};
      TMAT.win_sel('WERMAT'); TMAT.hdr_sel();
      {? _used || TMAT.hdr_sel(' — '+'PODGLĄD'@) ?};
      TMAT.index('NNL');
::       Zawsze wyświetlane wszystkie surowce
      {? 0
::         TKTL.TYP().SUR='O'
      || TMAT.prefix(TKTL.ref(),_env.OPER_SRC)
      || TMAT.prefix(TKTL.ref())
      ?};
      TMAT.first();
      VAR.P_NKTM:='';

      TMAT.fld_attr(,1);
      TMAT.dnd_sel('WERMAT',,'records.TMAT',"");
      TMAT.dnd_sel('WERMAT',,'records.M',"")
   ?};
   TKTL.cntx_pop()
||
   TMAT.index('NNL');
   TMAT.prefix(null());
   TMAT.actions('WERMAT',':d',,1)
?};
M.cntx_pop();
~~


\techdom_actions_main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: W zależności od stanu karty steruje akcjami na dolnym panelu przycisków
::   WE: [_a] - STRING - akcje które już wcześniej zostały oznaczone do wyszarzenia
::   WY: STRING - akcje które wyszarzyć, wyłączyć
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;

_grayed:=':';
{? var_pres('_a')=type_of('')
|| _grayed:=_a
?};

TKTL.cntx_psh();
TKTL.prefix();
{? TKTL.seek(_env.TKTL)
||

:: Wszystie akcje dot nagłówka karty są w tym kontekście w pustej i niepustej dziedzinie, dlatego
:: są wymieniane tutaj dwa razy
   {? TKTL.TYP=exec('ref_k_res','tech_head')
   || _grayed:='F(RALD)'+_grayed+'F(RALD)'
   ?};
   {? TKTL.TYP=null()
   || _grayed:='DFY'+_grayed+'DFY'
   ?};
   {? TKTL.TYP().UTIL='N' || _grayed:='F(N)'+_grayed+'F(N)' ?};
   {? TKTL.TYP().OPER='N' || _grayed:='F(O)Z(O)'+_grayed+'F(O)Z(O)' ?};
   {? TKTL.TYP().PAR='N' || _grayed:='F(P)'+_grayed+'F(P)' ?};
   {? TKTL.STAT_N='T' & TKTL.STAT_O='T' & TKTL.STAT_S='T' & TKTL.STAT_P='T' || _grayed:='Z'+_grayed+'Z' ?};
   {? exec('get','#params',500405,type_of(''))='T'
   ||
::    Szybka akceptacja
      {? TKTL.STAN='T'
      || _grayed:='A'+_grayed+'A'
      ?}
   ||
::    Normalna akceptacja
      {? ~exec('tktl_ended','tech_head') | TKTL.STAN='T'
      || _grayed:='A'+_grayed+'A'
      ?}
   ?};
   {? TKTL.STAT_N='N' || _grayed:='N(Y)Z(OSP)'+_grayed+'N(Y)Z(OSP)' ?};
   {? TKTL.STAT_N='T' || _grayed:='Z(N)'+_grayed+'Z(N)' ?};
   {? TKTL.STAT_O='T' || _grayed:='Z(O)'+_grayed+'Z(O)' ?};
   {? TKTL.STAT_S='T' || _grayed:='Z(S)'+_grayed+'Z(S)' ?};
   {? TKTL.STAT_P='T' || _grayed:='Z(P)'+_grayed+'Z(P)' ?};
   ~~
?};
TKTL.cntx_pop();
_grayed


\techdom_action_def_npu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Akcja Definicje -> N-P-U na zakładce 'Technologia domylśna' w kartotece materiałowej
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;
exec('action_tools','tech_tool');
{? _env.M<>null()
|| M.cntx_psh(); M.prefix();
   {? M.seek(_env.M)
   || _env.TECH_reload:=1;
      grp_disp(M,'NL_WER',1)
   ?};
   M.cntx_pop()
?};
~~


\techdom_action_def_par
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Akcja Definicje -> Parametry na zakładce 'Technologia domylśna' w kartotece materiałowej
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;
exec('action_params','!tte_tec_drdp');
{? _env.M<>null()
|| M.cntx_psh(); M.prefix();
   {? M.seek(_env.M)
   || _env.TECH_reload:=1;
      ZAKR.R_KOMP:='';
      ZAKR.R_PROD:='';
      grp_disp(M,'NL_WER',1)
   ?};
   M.cntx_pop()
?};
~~


\techdom_action_def_pro
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Akcja Definicje -> Produkty na zakładce 'Technologia domylśna' w kartotece materiałowej
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;
exec('action_products','!tte_tec_drdp');
{? _env.M<>null()
|| M.cntx_psh(); M.prefix();
   {? M.seek(_env.M)
   || _env.TECH_reload:=1;
      ZAKR.R_KOMP:='';
      ZAKR.R_PROD:='';
      grp_disp(M,'NL_WER',1)
   ?};
   M.cntx_pop()
?};
~~


\techdom_action_def_atr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Akcja Definicje -> Atrybuty karty na zakładce 'Technologia domylśna' w kartotece materiałowej
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;
exec('action_attrib','!tte_tec_drdp');
{? _env.M<>null()
|| M.cntx_psh(); M.prefix();
   {? M.seek(_env.M)
   || _env.TECH_reload:=1;
      ZAKR.R_KOMP:='';
      ZAKR.R_PROD:='';
      grp_disp(M,'NL_WER',1)
   ?};
   M.cntx_pop()
?};
~~


\techdom_action_def_dok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Akcja Definicje -> Dokumentacja karty na zakładce 'Technologia domylśna' w kartotece materiałowej
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;
exec('action_docum','!tte_tec_drdp');
{? _env.M<>null()
|| M.cntx_psh(); M.prefix();
   {? M.seek(_env.M)
   || _env.TECH_reload:=1;
      ZAKR.R_KOMP:='';
      ZAKR.R_PROD:='';
      grp_disp(M,'NL_WER',1)
   ?};
   M.cntx_pop()
?};
~~


\techdom_action_def_ope
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Akcja Definicje -> Operacje karty na zakładce 'Technologia domylśna' w kartotece materiałowej
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;
exec('action_menu','!tte_tec_drto');
{? _env.M<>null()
|| M.cntx_psh(); M.prefix();
   {? M.seek(_env.M)
   || _env.TECH_reload:=1;
      ZAKR.R_KOMP:='';
      ZAKR.R_PROD:='';
      grp_disp(M,'NL_WER',1)
   ?};
   M.cntx_pop()
?};
~~


\techdom_action_zak_nag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Akcja Zakończ -> Nagłówek na zakładce 'Technologia domylśna' w kartotece materiałowej
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;
exec('action_end','!tte_tec_drte');
{? _env.M<>null()
|| M.cntx_psh(); M.prefix();
   {? M.seek(_env.M)
   || _env.TECH_reload:=1;
      ZAKR.R_KOMP:='';
      ZAKR.R_PROD:='';
      grp_disp(M,'NL_WER',1)
   ?};
   M.cntx_pop()
?};
~~


\techdom_action_zak_ope
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Akcja Zakończ -> Operacje na zakładce 'Technologia domylśna' w kartotece materiałowej
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;
exec('action_end','!tte_tec_drto');
{? _env.M<>null()
|| M.cntx_psh(); M.prefix();
   {? M.seek(_env.M)
   || _env.TECH_reload:=1;
      ZAKR.R_KOMP:='';
      ZAKR.R_PROD:='';
      grp_disp(M,'NL_WER',1)
   ?};
   M.cntx_pop()
?};
~~


\techdom_action_zak_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Akcja Zakończ -> Surowce na zakładce 'Technologia domylśna' w kartotece materiałowej
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;
exec('action_end','!tte_tec_drts');
{? _env.M<>null()
|| M.cntx_psh(); M.prefix();
   {? M.seek(_env.M)
   || _env.TECH_reload:=1;
      ZAKR.R_KOMP:='';
      ZAKR.R_PROD:='';
      grp_disp(M,'NL_WER',1)
   ?};
   M.cntx_pop()
?};
~~


\techdom_action_zak_poz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Akcja Zakończ -> Pozostałe dane na zakładce 'Technologia domylśna' w kartotece materiałowej
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;
exec('action_end','!tte_tec_drdp');
{? _env.M<>null()
|| M.cntx_psh(); M.prefix();
   {? M.seek(_env.M)
   || _env.TECH_reload:=1;
      ZAKR.R_KOMP:='';
      ZAKR.R_PROD:='';
      grp_disp(M,'NL_WER',1)
   ?};
   M.cntx_pop()
?};
~~


\techdom_action_akc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Akcja Akceptuj na zakładce 'Technologia domylśna' w kartotece materiałowej
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;
VAR.GRUPA:='N';
exec('action_menu','!tte_tec_arte');
{? _env.M<>null()
|| M.cntx_psh(); M.prefix();
   {? M.seek(_env.M)
   || _env.TECH_reload:=1;
      ZAKR.R_KOMP:='';
      ZAKR.R_PROD:='';
      grp_disp(M,'NL_WER',1)
   ?};
   M.cntx_pop()
?};
~~


\techdom_action_wyc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Akcja Wycofaj na zakładce 'Technologia domylśna' w kartotece materiałowej
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;
exec('tktl_wycofaj','!tte_tec_arte');
{? _env.M<>null()
|| M.cntx_psh(); M.prefix();
   {? M.seek(_env.M)
   || _env.TECH_reload:=1;
      ZAKR.R_KOMP:='';
      ZAKR.R_PROD:='';
      grp_disp(M,'NL_WER',1)
   ?};
   M.cntx_pop()
?};
~~


\techdom_run_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Uruchamia czynność TTE_TEC_DRTO lub TTE_TEC_DRTS z poziomu zakładki 'Technologia domylśna' w kartotece materiałowej
::   WE: _a - STRING - UID czynnośći którą uruchomić
::       _b - STRING - akcja przekazywana do czynności
::   WY: ANY - wynik działania czynności lub ~~
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env.ENV_TECH;

_uid:=_a;
_akcja:=_b;
_res:=~~;
TKTL.cntx_psh();
TKTL.prefix();
{? TKTL.seek(_env.TKTL)
||
   _can_continue:=0;

   {? _uid='TTE_TEC_DRTO'
   || {? TKTL.STAT_O='N'
      || _can_continue:=1
      ?}
   |? _uid='TTE_TEC_DRTS'
   || {? TKTL.STAT_S='N'
      || _can_continue:=1
      ?}
   ?};

   {? _can_continue>0
   || _can_continue:=exec('chk_role','#b__box',OPERATOR.USER,_uid)
   ?};

   {? _can_continue>0
   || _ref:=TKTL.ref();
      _portsIn:=exec('portsIn','#b__box',_uid);
      exec('portsInSet','#b__box',_portsIn,_uid,'TKTL',_ref);

      _args:=exec('mp_run_a','#b__box');
      _args.ACT_UID:=_uid;
      _args.UIDREF:=TKTL.uidref();
      _args.AKCJA:=_akcja;
      _args.PORTS_IN:=_portsIn;
      _args.TODO_AUTO_MOJE:='N';
      {? _akcja='STOP' | _akcja='START'
      || _args.GRUPA:='T';
         KOMM.init(,,'Zakładka'@)
      ?};
      _res:=exec('mp_run','#b__box',_args)
   ?}
?};
TKTL.cntx_pop();
_res


\ttxcause_default
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Zwraca domyślną przyczynę zmiany dla technologii
::   WY: TTXCAUSE.ref lub null
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=null();

_par:=exec('get','#params',500403,type_of(''));

{? _par<>''
|| TTXCAUSE.cntx_psh();
   TTXCAUSE.index('NAZ');
   TTXCAUSE.prefix(_par,);
   {? TTXCAUSE.first()
   || _result:=TTXCAUSE.ref()
   ?};
   TTXCAUSE.cntx_pop()
?};
_result


\zakr_win
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Zwraca okno parametrów zakresu kart technologicznych dla okien ALL tabel TMAT, TOPER
::       (wszystkie surowce/operacje kart technologicznych)
::----------------------------------------------------------------------------------------------------------------------
_win_red:=ZAKR.mk_edit('Zakres technologii'@,,'zakr_tktla');
ZAKR.win_ewin(_win_red,,'TKTL_A');
exec('ok_esc','#window',ZAKR,_win_red);
_win_red


\zakr_get
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Pobranie wartości zmiennej ZAKR.TKTL_A (zakres technologii) dla okien ALL tabel TMAT, TOPER
::       (wszystkie surowce/operacje kart technologicznych)
::----------------------------------------------------------------------------------------------------------------------
_user:=exec('name','users');
OZ.index('OZ');
OZ.prefix(_user,_user);
{? OZ.first()
|| ZAKR.TKTL_A:=OZ.ZK_TKTL
|| ZAKR.TKTL_A:='A'
?};
{? ZAKR.TKTL_A='' | 'ANW'*ZAKR.TKTL_A=0
|| ZAKR.TKTL_A:='A'
?};
~~


\zakr_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Ustawienie wartości zmiennej ZAKR.TKTL_A (zakres technologii) dla okien ALL tabel TMAT, TOPER
::       (wszystkie surowce/operacje kart technologicznych)
::----------------------------------------------------------------------------------------------------------------------
_user:=exec('name','users');
OZ.index('OZ');
OZ.prefix(_user,_user);
{? ~OZ.first()
|| OZ.blank();
   OZ.USER:=_user;
   OZ.US:=OPERATOR.USER;
   OZ.add()
?};
OZ.ZK_TKTL:=ZAKR.TKTL_A;
OZ.put(1);
~~


\tktm_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Blank pola TKTL_KTM tabel TMAT/TOPER
::----------------------------------------------------------------------------------------------------------------------
VAR.A_KTL().KTM


\tktm_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Aktualizacja pola TKTL_KTM dla tabel TMAT/TOPER
::   WE: _a - TKTL.ref() - dla jakiej technologii aktualizować zmiany
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_pres('_a')=type_of(null()) || _a || return() ?};
_msk:=ref_name(_ref)-3;
exec('tktl_cntx_psh','tech_common');
exec('tktl_use','tech_common',_msk);
TKTL.clear();
{? TKTL.seek(_ref)
|| TMAT.index('NL');
   TMAT.prefix(TKTL.ref());
   {? TMAT.first()
   || {!
      |? TMAT.TKTL_KTM:=TKTL.KTM;
         TMAT.put();
         TMAT.next()
      !}
   ?};
   TOPER.index('DOK');
   TOPER.prefix(TKTL.ref());
   {? TOPER.first()
   || {!
      |? TOPER.TKTL_KTM:=TKTL.KTM;
         TOPER.put();
         TOPER.next()
      !}
   ?}
?};
exec('tktl_cntx_pop','tech_common');
~~


\m_tktl_icon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Formuła na ikonę dla materiałów posiadających zdefiniowane technologie
::----------------------------------------------------------------------------------------------------------------------
_icon:=exec('pusta','#icon');
_res:=exec('is_tech','tech_common',M.ref(),1,,1);
{? _res=1
|| _icon:='xwin16.png:50'
|? _res=0
|| _icon:='xwin16.png:91'
?};
_icon


\m_icon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Definiuje dodatkowe ikony dla tabeli materiałów (gdy jest licencja do obszarów produkcyjnych)
::   WE: [_a] - STRING - obszar, z którego uruchamiana jest formuła
::----------------------------------------------------------------------------------------------------------------------
_obszar:={? var_pres('_a')=type_of('') || _a || '' ?};
VAR.PROD:={? exec('tte_lic','tte')='T' || 'T' || 'N' ?};
:: Jeżeli licencja na produkcję, to dodatkowa formuła na ikonę w oknach wertowania materiałów
{? VAR.PROD='T'
|| _formicon:="exec('m_tktl_icon','tech_common')";
   {? _obszar='LSP_ZKN'
   || M.win_fml('WER_ZAM',,'KTM',,'ICON_BEFORE',_formicon,1)
   || M.win_fml('NL_WER',,'KTM',,'ICON_BEFORE',_formicon,1);
      M.win_fml('NL_WERST',,'KTM',,'ICON_BEFORE',_formicon,1);
      M.win_fml('NL_WERU',,'KTM',,'ICON_BEFORE',_formicon,1)
   ?}
?};
~~


\chk_gktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Walidacja rekordu tabeli GKTL (grupy kart technologicznych)
::       - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(GKTL);
{? _chk=''
||
:: Sprawdzenie unikalności nazwy
   _ref:={? _a=1 || GKTL.ref() || null() ?};
   _unique:=1;
   GKTL.cntx_psh();
   GKTL.index('GR');
   GKTL.prefix(GKTL.GR);
   {? GKTL.first()
   || {? _ref=GKTL.ref()
      || _unique:=~GKTL.next()
      || _unique:=0
      ?}
   ?};
   GKTL.cntx_pop();
   {? _unique=0
   || FUN.info('Istnieje już grupa kart technogicznych o danej nazwie grupy.'@);
      _chk:='GR'
   ?}
?};
_chk


\chk_ktm4tktlw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Sprawdza, czy dana technologia (TKTL) ma zdefiniowaną kartę (TKTLW) na podany produkt (M).
::       Sprawdzane wyłącznie aktywne karty produktów (niearchiwalne)
::   WE: _a - technologia: TKTL.ref()
::       _b - produkt: M.ref()
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_tktl:=_a;
_ktm:=_b;
{? _tktl<>null() & _ktm<>null()
|| TKTLW.cntx_psh();
:: Szukanie tylko w masce niearchiwalnej
   _msk:='txktw___';
   {? TKTLW.name()<>_msk || TKTLW.use(_msk) ?};
   TKTLW.index('REF');
   TKTLW.prefix(_tktl,_ktm);
   {? TKTLW.first()
   || _res:=1
   ?};
   TKTLW.cntx_pop()
?};
_res


\tktl2zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Rejestracja nagłówka zlecenia produkcyjnego z poziomu karty technologicznej (TKTL)
::   WE: [_a] - kategoria zlecenia: ['P'] - proste, 'Z' - złożone
::----------------------------------------------------------------------------------------------------------------------
_kategoria:={? var_pres('_a')=type_of('') || _a || 'P' ?};
exec('zl_add','zl_head',0,_kategoria);
~~


\tktlw2zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Rejestracja nagłówka zlecenia produkcyjnego z poziomu produktu karty technologicznej (TKTLW)
::   WE: [_a] - kategoria zlecenia: ['P'] - proste, 'Z' - złożone
::----------------------------------------------------------------------------------------------------------------------
_ref:=TKTLW.ref();
_kategoria:={? var_pres('_a')=type_of('') || _a || 'P' ?};
exec('zl_add','zl_head',1,_kategoria);
:: Odtworzenie filtru, gdy formuła uruchamiama z poziomu obszaru Kart technologicznych
{? VAR.A_TABKTL='W'
|| exec('set_wfilter','tech_head');
   TKTLW.f_seek(_ref)
?};
~~


\tktl2archive_fix
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [RR.xx]
:: OPIS: Archiwizuje technologie zamkniętych zleceń - formuła naprawcza po transferze danych z xpertis
::   WE: [_a] - INTEGER - liczba rekordów do naprawienia, doymślnie 0 - naprawia wszystkie rekordy
::----------------------------------------------------------------------------------------------------------------------
_count:={? var_pres('_a')=type_of(0) || _a || 0 ?};

KOMM.init(,,'Archiwizacja technologii zleceń'@,'');

exec('tktl_cntx_psh','tech_common');
ZL.cntx_psh();
:: Dane do naprawienia tylko w masce bieżącej
exec('tktl_use','tech_common','___');

_args:=exec('args_copy','tech_arch');
_args.DELETE:=1;
_args.COPY_ACT:=0;
_args.TRANS:=1;
_args.DIR:='ARCHIWUM';

:: Archiwizacja kart technologicznych zamkniętych zlecen
TKTL.index('ASTN');
TKTL.prefix('Z','T');
{? TKTL.first()
||
:: Brane po uwagę archiwialne technologie zleceń, które są umieszczone w masce bieżącej
   _it:=1;
   {!
   |?
      _zlec:=#TKTL.ZL;
      _next:=0;
      _ref_nxt:=null();
      TKTL.cntx_psh();
      {? TKTL.next()
      || _ref_nxt:=TKTL.ref()
      ?};
      TKTL.cntx_pop();
      {? exec('zl_lock','zl_common',_zlec,'T',1)
      ||
::       Maska docelowa archiwum jest maska typu _14 gdzie 14 to data zamkniecia zlecenia
         {? TKTL.ZL<>null()
         || _args.MASK_DST:='_'+(($(TKTL.ZL().DO~1))+2)
         || _args.MASK_DST:='_'+(($(date()~1))+2)
         ?};
         _args.TKTL_SRC:=TKTL.ref();
         _args.MASK_SRC:=ref_name(TKTL.ref())+3;
         {? exec('tktl_copy','tech_arch',_args)=0
         || KOMM.add('Nie udało się przesunąć technologii: '+TKTL.NRK+' wersja: '+TKTL.WER+' do archiwalnej maski.',2);
            _result:=0
         ?};
         {? _ref_nxt<>null()
         || _next:=(_count=0 | _it<_count) & TKTL.seek(_ref_nxt)
         ?}
      ?};
      exec('zl_unlock','zl_common',_zlec,'T');
      _it+=1;
      _next>0
   !}
?};

exec('tktl_cntx_pop','tech_common');

:: Pokazuje KOMMa
KOMM.select();

ZL.cntx_pop();
~~

:Sign Version 2.0 jowisz:1045 2023/11/30 12:42:34 4a677cefa585196fdbab12ac05a9f5823a4394aca208669574a854572f81bea2e736547cd266d73eb274361557f9eca631936d2744b8a527685195eb7b573dbd5422cdc9008d5588cff726f5b1f3512bc0c25f7e553065f03b899cef812c5b30d7e97ad6175fd97263e8e3fb99f3379f79e0210c9de70fb5e9863cde6aef8c47
