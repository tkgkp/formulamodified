:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: pracownik.fml
:: Utworzony: 17.03.2015
:: Autor: RWR
::======================================================================================================================
:: Zawartość: Plik zawiera formuły obsługi tabeli P (wspólne dla wszystkich form współpracy) oraz tabel związanych z
::            przebiegiem zatrudnienia (H_UM i H).
::======================================================================================================================


\h_um_synch_inne
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Aktualizacja brudnopisu w przypadku zmian nanoszonych w umowie w sposób inny niż przez edycję danych
::       (np. w wyniku naliczania listy płac).
::   WE:
::   WY:
:: UWAGA! wywpłanie z wyzwalacza po poprawieniu zapisu w zbiorze docelowym tabeli H_UM.
::----------------------------------------------------------------------------------------------------------------------
{? H_UM.IDLNK='' | (H_UM.EKW=bfld('EKW') & H_UM.LT=bfld('LT') & H_UM.SW=bfld('SW'))
|| return()
?};

_uid:=H_UM.IDLNK;
: synchronizuj:
_ekw:=H_UM.EKW;
_ekw_nsp:=H_UM.EKW_NSP;
_ekw_licz:=H_UM.EKW_LICZ;
_lt:=H_UM.LT;
_sw:=H_UM.SW;

H_UM.cntx_psh();
exec('otworz_h_um','pracownik','h_u_');
H_UM.clear();
{? H_UM.seek(_uid)
|| H_UM.EKW:=_ekw;
   H_UM.EKW_NSP:=_ekw_nsp;
   H_UM.EKW_LICZ:=_ekw_licz;
   H_UM.LT:=_lt;
   H_UM.SW:=_sw;
   H_UM.put()
?};
H_UM.cntx_pop();
exec('otworz_h_um','pracownik');

~~


\p_modb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Przed modyfikacją rekordu. Formuła wywoływana z wyzwalaczy "Dołącz - przed" i "Popraw - przed" dla tabeli P.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
P.T:=form(P.T);
1


\p_addb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Wyzwalacz "Dołącz - przed" dla tabeli P.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('p_modb','pracownik');
exec('p_addb','phr_xx_tab');

{? P.PORTAL='T'
:: Jeżeli P.PORTAL zostało ustawione na 'T', to sprawdzenie licencji na POR byłoby chyba trochę nadmiarowe.
|| F_ZATR.cntx_psh();
   F_ZATR.prefix();
   {? P.F_ZATR().DOCELOWA<>'T'
::    Jeżeli forma współpracy nie jest docelowa (zapis w poczekalni), to nie chcemy takiego rekordu prezentować na
::    portalu.
   || P.PORTAL:='N'
   ?};
   F_ZATR.cntx_pop()
?};
1


\p_adda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.28]
:: OPIS: Wyzwalacz "Dołącz - po" dla tabeli P.
::   WE: _a [INTEGER] - Wynik właściwej operacji.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _a & do_state()=1
|| exec('last_mod_set','#table',P);
   exec('p_adda','phr_xx_tab',_a);
:: aktualizacja 19.22_04
   {? var_pres('PPK_UCZ')=type_of(SYSLOG) & P.ZA='T'
   || exec('wer_akt','ppk_ucz',P.OSOBA)
   ?};
:: synchronizacja z portalem ABS
   {? exec('lic','#b_domain','POR')
   || {? P.PORTAL='T'
      || exec('p_portal_T','por')
      ?};
: synchronizacja tabeli etypy_p
      exec('add_etypproc','pracownik');
      exec('por_zalacz4osoba','pracownik',P.OSOBA)
   ?}
?};
~~


\p_putb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Wyzwalacz "Popraw - przed" dla tabeli P.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('p_modb','pracownik');
exec('p_putb','phr_xx_tab');

{? P.PORTAL='N' & exec('lic','#b_domain','POR')
|| F_ZATR.cntx_psh();
   F_ZATR.prefix();
   {? P.F_ZATR().DOCELOWA='T'
::    A więc teraz forma współpracy jest docelowa, a zmieniła się?
   || P.cntx_psh();
      _zmiana:=P.get() & P.F_ZATR().DOCELOWA<>'T';
      P.cntx_pop();
      {? _zmiana
      || P.PORTAL:=exec('p_portal_bl','pracownik')
      ?}
   ?};
   F_ZATR.cntx_pop()
?};
1


\p_puta
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wyzwalacz "po poprawieniu" tabeli P.
::   WE: _a [INTEGER] - wartość przekazywana do formuły przez narzędzia
::----------------------------------------------------------------------------------------------------------------------
{? ~_a | do_state()<>1
|| return()
?};

exec('p_puta','phr_xx_tab',_a);

_d0:=date(0,0,0);

: obsługa wzorców czasu pracy
{? P.DZA<>_d0 & P.DZA<bfld('DZA')
|| R_WZCZ.cntx_psh();
   R_WZCZ.use('r_wzczas');
   R_WZCZ.index('R_WZCZ');
   R_WZCZ.prefix(P.name(),P.ref());
   {? R_WZCZ.first() & P.DZA<R_WZCZ.OD
   || R_WZCZ.OD:=date(P.DZA~1,P.DZA~2,1);
      R_WZCZ.put()
   ?};
   R_WZCZ.cntx_pop()
?};

{? P.DZ<>_d0
|| exec('kart_url_usun_nadmiarowe','kart_url',1)
?};

{? P.WYDZIAL<>bfld('WYDZIAL') |
   P.POZWORG<>bfld('POZWORG') |
   P.ST<>bfld('ST') |
   P.ZA<>bfld('ZA') |
   P.T<>bfld('T')
:: aktualizuj zależności służbowe
|| exec('aktualizuj','zs_def',P.ref())
?};

{? P.ZA<>bfld('ZA') | P.OSOBA<>bfld('OSOBA') | P.WYDZIAL<>bfld('WYDZIAL') | P.KK<>bfld('KK') | P.ST<>bfld('ST')
   | P.CP<>bfld('CP') | P.F_ZATR<>bfld('F_ZATR')
:: Aktualizacja anomalii w tabelach premii uznaniowych po zmianie w rekordzie źródłowym.
|| PM_DYSP.cntx_psh();
   PM_DYSP.index('DYSP');
   PM_DYSP.prefix(P.ref());
   {? PM_DYSP.first()
   || PM_DYSP.put()
   ?};
   PM_DYSP.cntx_pop();

   PM_DOMP.cntx_psh();
   PM_DOMP.index('PD');
   PM_DOMP.prefix(P.ref());
   {? PM_DOMP.first()
   || {!
      |? PM_DOMP.put();
         PM_DOMP.next()
      !}
   ?};
   PM_DOMP.cntx_pop();

   PM_PREM.cntx_psh();
   PM_PREM.index('PLT');
   PM_PREM.prefix(P.ref());
   {? PM_PREM.first()
   || {!
      |? PM_PREM.put();
         PM_PREM.next()
      !}
   ?};
   PM_PREM.cntx_pop()
?};

exec('last_mod_set','#table',P);

{? exec('tpp_lic','tpp')='T'
|| exec('plres_update','po_plan',$P.ref())
?};

:: aktualizacja 19.22_04
{? var_pres('PPK_UCZ')=type_of(SYSLOG) & P.ZA<>bfld('ZA')
|| exec('wer_akt','ppk_ucz',P.OSOBA)
?};

{? exec('lic','#b_domain','POR')
|| {? bfld('OSOBA')<>P.OSOBA |
      bfld('WYDZIAL')<>P.WYDZIAL | bfld('ST')<>P.ST | bfld('CP')<>P.CP | bfld('F_ZATR')<>P.F_ZATR
   || BIPODB.cntx_psh();
::    Odbiorcy.
      BIPODB.index('POD');
      BIPODB.prefix(P.ref());
      {? BIPODB.first()
      || {!
         |? BIPODB.put();
            BIPODB.next()
         !}
      ?};
      BIPODB.cntx_pop();

::    Osoby odpowiadające.
      BIPPYTO.cntx_psh();
      BIPPYTO.index('P');
      BIPPYTO.prefix(P.ref());
      {? BIPPYTO.first()
      || {!
         |? BIPPYTO.put();
            BIPPYTO.next()
         !}
      ?};
      BIPPYTO.cntx_pop();

::    Wątki.
      BIPPYTN.cntx_psh();
      BIPPYTN.f_clear();
      BIPPYTN.index('P');
      BIPPYTN.prefix(P.ref());
      {? BIPPYTN.first()
      || {!
         |? BIPPYTN.put();
            BIPPYTN.next()
         !}
      ?};
      BIPPYTN.cntx_pop();

::    Wypowiedzi (pytania / odpowiedzi).
      BIPPYTP.cntx_psh();
      BIPPYTP.index('P');
      BIPPYTP.prefix(P.ref());
      {? BIPPYTP.first()
      || {!
         |? BIPPYTP.memo_set(BIPPYTP.memo_txt(,1,'TRESC'),'TRESC');
::          Ustawienie wartości pola TRESC - na potrzeby walidacji.
            BIPPYTP.put();
            BIPPYTP.next()
         !}
      ?};
      BIPPYTP.cntx_pop();

::    Benefity
      BNFTP.cntx_psh();
      BNFTP.index('PBD');
      BNFTP.prefix(P.ref());
      {? BNFTP.first()
      || {!
         |? BNFTP.put();
            BNFTP.next()
         !}
      ?};
      BNFTP.cntx_pop();

      ~~
   ?};
   {? P.PORTAL='T'
   || {? bfld('PORTAL')<>P.PORTAL
      || exec('p_portal_T','por')
      |? bfld('DZA')<>P.DZA
::       W encjach chr_PersonPayoutMethod i chr_PersonBankAccount wysyłana jest data zatrudnienia ...
      || exec('idput_ndx','#table',PKO,'_PKO',P.OSOBA)
      ?}
   ?};
: synchronizacja tabeli etypy_p
   {? P.OSOBA<>bfld('OSOBA') || exec('add_etypproc','pracownik') ?}
?};

~~


\p_delb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wyzwalacz "przed usunięciem" tabeli P.
::       Należy pamiętać, że akronimy usuwanych tabel należy również dodać do formuły \restrict/pracownik.fml
::   WY: 1 - Właściwa akcja może zostać wykonana.
::       0 - Usunięcie rekordu nie jest możliwe.
::  OLD: \restrict/osoba.fml
::----------------------------------------------------------------------------------------------------------------------
:: Jeżeli współpracownik ma składniki na choć jednej liście płac to nie będziemy go usuwali.
O_P.cntx_psh();
O_P.index('P_RMK');
O_P.prefix('T',P.ref());
_spl:=O_P.first();
O_P.cntx_pop();
{? _spl
|| return(0)
?};

: informacja dla wyzwalaczy "usuń" tabeli H_UM
exec('add','#bulk',H_UM,'del',$P.ref());

_h_um:=1;
H_UM.cntx_psh();
_names:=H_UM.names();
_loop:=_names.first();
{!
|? _loop & _h_um
|! exec('otworz_h_um','pracownik',_names.NAME);
   _h_um:=exec('del_ndx','#table',H_UM,'OD',P.ref());
   _loop:=_names.next()
!};
obj_del(_names);
H_UM.cntx_pop();
exec('otworz_h_um','pracownik');

: usuń semafor
exec('del','#bulk',H_UM,'del',$P.ref());
{? ~_h_um
|| return(0)
?};

F_ZATR.cntx_psh();
{? P.F_ZATR().DOCELOWA='T'
:: Słownik SLO_OSOB jest uzupełniany w momencie "zatrudnienia" - zmiany formy współpracy na docelową. Tak więc
:: sprawdzanie "użycia" bieżącego rekordu tabeli P w tym słowniku ma sens tylko dla form docelowych.
|| exec('__F_ZATR','object');
   _val:=__F_ZATR.P;
   __F_ZATR.mod(P.F_ZATR().KOD,'P');
   _slo_osob:=exec('slo_test','slo_slu','SLO_OSOB','ID',P.IP,0);
   __F_ZATR.mod(_val,'P')
|| _slo_osob:=0
?};
F_ZATR.cntx_pop();
{? _slo_osob<>0
|| return(0)
?};

:: usunięcie danych z R_PRACDN ze wszystkich masek
_r_pracdn:=1;
R_PRACDN.cntx_psh();
_masks:=R_PRACDN.names();
_loop:=_masks.first();
{!
|? _loop & _r_pracdn
|! R_PRACDN.use(_masks.NAME);
   _r_pracdn:=exec('del_ndx','#table',R_PRACDN,'R_PRACDN',P.ref());
   _loop:=_masks.next()
!};
obj_del(_masks);
R_PRACDN.cntx_pop();
{? ~_r_pracdn
|| return(0)
?};

:: usunięcie danych z R_ERRKAL ze wszystkich masek
_r_errkal:=1;
R_ERRKAL.cntx_psh();
_masks:=R_ERRKAL.names();
_loop:=_masks.first();
_r_errkal_ndx:=R_ERRKAL.ndx_tmp(,1,'P',,);
{!
|? _loop & _r_errkal
|! R_ERRKAL.use(_masks.NAME);
   _r_errkal:=exec('del_ndx','#table',R_ERRKAL,_r_errkal_ndx,P.ref());
   _loop:=_masks.next()
!};
obj_del(_masks);
R_ERRKAL.cntx_pop();
R_ERRKAL.ndx_drop(_r_errkal_ndx);
{? ~_r_errkal
|| return(0)
?};

:: usunięcie danych z R_ERRMAX ze wszystkich masek
_r_errmax:=1;
R_ERRMAX.cntx_psh();
_masks:=R_ERRMAX.names();
_loop:=_masks.first();
{!
|? _loop & _r_errmax
|! R_ERRMAX.use(_masks.NAME);
   _r_errmax:=exec('del_ndx','#table',R_ERRMAX,'R_ER_DZ',P.ref());
   _loop:=_masks.next()
!};
obj_del(_masks);
R_ERRMAX.cntx_pop();
{? ~_r_errmax
|| return(0)
?};

_p_oddel_p_ndx:=P_ODDEL.ndx_tmp(,1,'P',,);
_p_oddel_p_from_ndx:=P_ODDEL.ndx_tmp(,1,'P_FROM',,);
_p_oddel_p_to_ndx:=P_ODDEL.ndx_tmp(,1,'P_TO',,);

_ret:=
exec('del_ndx','#table',ETYPY_P,'PRAC',P.ref()) &
exec('del_ndx','#table',SLO_OSOB,'ID',P.F_ZATR,P.IP) &
exec('del_ndx','#table',O_P,'P_RMK','N',P.ref()) &
exec('del_ndx','#table',DS,'DYSCYPLI',P.ref()) &
exec('del_ndx','#table',LSS,'PROPOZYC',P.ref()) &
exec('del_ndx','#table',P_IPOD,'OD',P.ref()) &
exec('del_ndx','#table',BDO,'PDTO',P.ref()) &
exec('del_ndx','#table',P_DNAUK,'POS',P.ref()) &
exec('del_tmp','#table',OV_UPR,'P',P.ref()) &
exec('del_ndx','#table',OS_VIEW,'PREF',P.ref()) &
exec('del_ndx','#table',ZALACZ,'ZALACZ',P.FIRMA,P.OSOBA,P.ref()) &
exec('del_ndx','#table',R_WZCZ,'R_WZCZ',P.name(),#P.ref()) &
exec('del_ndx','#table',R_MARG,'R_MARG',P.ref()) &
exec('del_ndx','#table',R_SPEC,'R_SPECD',P.ref()) &
exec('del_ndx','#table',KART_URL,'PRAC_ROK',P.ref()) &
exec('del_ndx','#table',P_GP,'OD',P.ref()) &
exec('del_ndx','#table',P_GR_PW,'PODT',P.ref()) &
exec('del_ndx','#table',P_GR_PW,'PPOD',P.ref()) &
exec('del_ndx','#table',P_GR_P,'PODT',P.ref()) &
exec('del_ndx','#table',P_GR_P,'PPOD',P.ref()) &
exec('del_ndx','#table',P_GR,'PRACNAZ',P.ref()) &
exec('del_ndx','#table',P_KK,'OD',P.ref()) &
exec('del_ndx','#table',P_WEB_CL,'P',P.ref()) &
exec('del_ndx','#table',P_WEB_CX,'P',P.ref()) &
exec('del_ndx','#table',KAL_BUFF,'PRACDATA',P.ref()) &
exec('del_ndx','#table',N_AH,'PRACDATA',P.ref()) &
exec('del_ndx','#table',P_ODDEL,_p_oddel_p_ndx,P.ref()) &
exec('del_ndx','#table',P_ODDEL,_p_oddel_p_from_ndx,P.ref()) &
exec('del_ndx','#table',P_ODDEL,_p_oddel_p_to_ndx,P.ref()) &
exec('del_ndx','#table',PLOB_P,'PRAC',P.ref()) &
exec('del_ndx','#table',PLOB_PB,'PRAC',P.ref()) &
exec('delPrac','stp',P.ref()) &
exec('del_ndx','#table',BIPODB,'POD',P.ref()) &
exec('delete4P','pkalsync',P.ref()) &
exec('p_delb','phr_xx_tab') &
: !!! do usunięcia po realizacji zależności
exec('del_ndx','#table',STRST_P,'P',P.ref()) &
exec('del_ndx','#table',P_STAT,'TECH',P.ref());

P_ODDEL.ndx_drop(_p_oddel_p_ndx);
P_ODDEL.ndx_drop(_p_oddel_p_from_ndx);
P_ODDEL.ndx_drop(_p_oddel_p_to_ndx);

_ret


\p_dela
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.28]
:: OPIS: Wyzwalacz "Usuń - po" dla tabeli P.
::   WE: _a [INTEGER] - Wynik właściwej operacji.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _a & do_state()=1
|| exec('last_mod_set','#table',P);
   exec('p_dela','phr_xx_tab',_a);
:: aktualizacja 19.22_04
   exec('wer_akt','ppk_ucz',bfld('OSOBA'));
   {? exec('lic','#b_domain','POR')
   || exec('p_portal_T','por',bfld('OSOBA'),null())
   ?}
?};
~~


\wybierz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła obsługująca wybór pracownika(-ów).
::   WE:  _a  [ARRAY]   - Tablica z elementami parametryzującymi zakres prezentacji i sposób działania wyboru. Struktura
::                        udostępniana przez \wybierz_args.
::   WY: Tablica z elementami nazwanymi.
::----------------------------------------------------------------------------------------------------------------------
exec('__F_ZATR','object');
exec('__RUB','object');
:: Przygotowanie struktury wynikowej.
_ret:=obj_new('STATUS','P','ndx');
_ret.STATUS:='';
_ret.P:=tab_tmp(1,
:: Liczba porządkowa odzwierciedla kolejność w oknie.
   'LP','INTEGER','Lp.',
:: Wybrany pracownik - różne sposoby identyfikacji.
   'SQL','STRING[16]','$P.ref()',
   'UID','STRING[48]','P.uidref()',
   'REF','INTEGER','#P.ref()',
   'CRC','INTEGER','P.crc()',
:: Osoba związana z wybranym pracownikiem - różne sposoby identyfikacji.
   'OSQL','STRING[16]','$OSOBA.ref()',
   'OUID','STRING[48]','OSOBA.uidref()',
   'OREF','INTEGER','#OSOBA.ref()',
   'OCRC','INTEGER','OSOBA.crc()'
);
_ret.ndx:=obj_new('LP','SQL','UID','REF');
_ret.ndx.LP:=_ret.P.index('?');
_ret.ndx.SQL:=_ret.P.ndx_tmp(,,'SQL',,);
_ret.ndx.UID:=_ret.P.ndx_tmp(,,'UID',,);
_ret.ndx.REF:=_ret.P.ndx_tmp(,,'REF',,);

_prolog:="_par:=params_get(); _P:=_par.ret.P; _war:=_par.args.FML_TEST; ";
_add:="
   {? ($_war)()
   || _P.blank();
      _P.SQL:=$P.ref();
      _P.UID:=P.uidref();
      _P.REF:=#P.ref();
      _P.CRC:=P.crc();
      _P.LP:=_P.size()+1;
      _P.OSQL:=$OSOBA.ref();
      _P.OUID:=OSOBA.uidref();
      _P.OREF:=#OSOBA.ref();
      _P.OCRC:=OSOBA.crc();
      _P.add()
   ?}
";
_w1:=_prolog+_add;
_ww:=_prolog+"
   _ref:=P.ref();
   {? P.f_first()
   || {!
      |? "+_add+";
         P.f_next()
      !}
   ?};
   P.f_seek(_ref)
";

:: Weryfikacja argumentów wywołania.
{? var_pres('_a')<>type_of(obj_new(1))
|| _ret.STATUS:='Nieprawidłowy typ argumentu wywołania.'@;
   return(_ret)
?};
_in:=_a;
_args:=exec('wybierz_args','pracownik');
_ret.STATUS:=exec('wybierz_check_in','pracownik',_in,_args);
{? _ret.STATUS<>''
|| return(_ret)
?};

{? _args.POMIN_KOLUMNY=''
|| _pomin:="0"
|| _pomin:=$("',"+gsub(_args.POMIN_KOLUMNY,' ','')+",'*(','+_a+',')")
?};

:: Budowa okna pracowników.
_ws:=P.mk_sel(,'P',,'prac_wybierz',,,,,'U','T',,,,'maximized');
:: Pola
{? ~_pomin('T')
|| P.win_fld(_ws,,'T',,,-MS.fld_len(P,'T'),,,,,MS.comment(P,'T'))
?};
{? ~_pomin('IP')
|| P.win_fld(_ws,,'IP',,,-6,,,,,MS.comment(P,'IP'))
?};
P.win_fld(_ws,,'OSOBA','NAZWISKO',,-20,,,,,MS.comment(OSOBA,'NAZWISKO'));
P.win_fld(_ws,,'OSOBA','PIERWSZE',,-15,,,,,MS.comment(OSOBA,'PIERWSZE'));
{? ~_pomin('PESEL')
|| P.win_fld(_ws,,'OSOBA','PESEL',,-11,,,,,MS.comment(OSOBA,'PESEL'))
?};
{? ~_pomin('F_ZATR')
|| P.win_fld(_ws,,'F_ZATR','KOD',,-3,,,'Forma współpracy - kod'@,,MS.comment(F_ZATR,'KOD'));
   P.win_fld(_ws,,'F_ZATR','OPIS',,-10,,,'Forma współpracy - opis'@,,MS.comment(F_ZATR,'OPIS'))
?};
{? ~_pomin('WYDZIAL')
|| P.win_fld(_ws,,'WYDZIAL','SYMBOL',,-16,,,'Jednostka organizacyjna'@,,'Symbol jednostki organizacyjnej'@)
?};
{? ~_pomin('CP')
|| P.win_fld(_ws,,'CP','CP','CHARPRAW',-9,,,,,MS.comment(P,'CP'))
?};
{? ~_pomin('ST')
|| P.win_fld(_ws,,'ST','ST',,-18,,,'Stanowisko'@,,'Nazwa stanowiska'@)
?};
{? ~_pomin('ZA')
|| P.win_fld(_ws,,'ZA',,,-3,,,,,MS.comment(P,'ZA'),2,,"'T'","'N'")
?};
: Akcje
P.win_act(_ws,,'Formuła','Wybierz'@@,,,$_w1,"sel_exit()",1,_args.WIELU,{? _args.WIELU || "sel_nchk()" || "" ?},,'W');
{? _args.WIELU
|| P.win_act(_ws,,'Formuła','Wybierz ws&zystkich'@@,,,$_ww,"sel_exit()",,,,,'Z',,'target=window')
?};
{? _args.XFILTER
|| P.win_act(_ws,0,'Formuła','Rozszerzony &filtr'@@,,'Ograniczenie listy danych'@,,
      "params_exec('xfl_ustaw_a','pkd')",,,,,'F');
   P.win_act(_ws,1,'Formuła','Rozszerzony &filtr'@@,,'Ograniczenie listy danych'@,,
      "params_exec('xfl_ustaw_a','pkd')",,,,,'F');
   P.win_act(_ws,0,'Formuła','Wy&czyść filtr'@@,,'Usunięcie ograniczenia listy danych'@,
      "params_exec('xfl_wyczysc_b','pkd')","params_exec('xfl_wyczysc_a','pkd')",,,,,'C');
   P.win_act(_ws,1,'Formuła','Wy&czyść filtr'@@,,'Usunięcie ograniczenia listy danych'@,
      "params_exec('xfl_wyczysc_b','pkd')","params_exec('xfl_wyczysc_a','pkd')",,,,,'C')
?};
P.win_act(_ws,,'Menu','Szukaj'@,,,,,,,,,'S');
P.win_act(_ws,,'Formuła','Szukaj dokładnie'@@,'#S','Szukanie zapisu zgodnego ze zredagowanym wzorcem'@,
   "params_exec('p_ustaw_ezk','szukaj')","params_exec('p_d','szukaj')",,,,,'S');
P.win_act(_ws,,'Formuła','Szukaj &kontekstowo'@@,'#S','Szukanie zapisu zgodnego ze zredagowanym wzorcem'@,
   "params_exec('p_ustaw_ezk','szukaj')","params_exec('p_k','szukaj')",,,,,'K');
P.win_act(_ws,,'#F3',,,,
   "params_exec('p_ustaw_ezk','szukaj')","params_exec('p_f3_wnd','szukaj')");
P.win_act(_ws,,'Kolejność');
P.win_act(_ws,,'Wyświetl',,,,{? _args.WYSWIETL || "exec('p_bw','pracownik')" || "" ?});

:: Dodatkowe parametry potrzebne do budowy widoku.
_cfg:=obj_new('nav');
_cfg.nav:=obj_new('main','side','curr');
_cfg.nav.side:=exec('nawigator','schemat','PODZORG','MIN',,1);
_cfg.nav.main:=_ws;

params_set('args',_args,'cfg',_cfg,'ret',_ret);

P_FILTER.UD_SCH:=_args.UD_SCH;

_wnd:=exec('wybierz_conf','pracownik',_args,_cfg);

UD_DEF.cntx_psh();
UD_DEF.index('SYMBOL');
UD_DEF.prefix(P_FILTER.UD_SCH);
UD_DEF.first();
OSOBA.cntx_psh();
OSOBA.prefix();
OSOBA.fld_attr(,_args.OSOBA_FLD_ATTR);
P.cntx_psh();
P.prefix();
P.blank();
P.fld_attr(,_args.P_FLD_ATTR);
UD_DEF.win_sel(_wnd);
UD_DEF.select(,1,-1);
P.fld_attr(,1);
P.f_clear();
P.cntx_pop();
OSOBA.fld_attr(,1);
OSOBA.cntx_pop();
UD_DEF.cntx_pop();

_ret


\wybierz_silent
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [21.37]
:: OPIS: Wypełnienie struktury "wybierałki" przekazanym pracownikiem
::   WE: _a [REFERENCE] - wskazanie na pracownika
::   WY: zgodny z \wybierz/pracownik.fml
::----------------------------------------------------------------------------------------------------------------------
_prac:=exec('wybierz','pracownik');
_p_ref:={? var_pres('_a')=type_of(null) || _a || return(_prac) ?};

P.cntx_psh();
OSOBA.cntx_psh();
P.prefix();
{? P.seek(_p_ref)
|| _prac.STATUS:='';
   _prac.P.blank();
   _prac.P.SQL:=$P.ref();
   _prac.P.UID:=P.uidref();
   _prac.P.REF:=#P.ref();
   _prac.P.CRC:=P.crc();
   _prac.P.LP:=_prac.P.size()+1;
   _prac.P.OSQL:=$P.OSOBA().ref();
   _prac.P.OUID:=OSOBA.uidref();
   _prac.P.OREF:=#OSOBA.ref();
   _prac.P.OCRC:=OSOBA.crc();
   _prac.P.add()
?};
OSOBA.cntx_pop();
P.cntx_pop();
_prac


\wybierz_parses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Uproszczone wybieranie współpracowników (np. na potrzeby wydruków) na podstawie parametrów sesji.
::   WE: _a [STRING] - kod dziedziny
::      [_b] [ARRAY] - tablica z elementami zgodna z exec('wybierz_args','pracownik').
::   WY: zgodny z \wybierz/pracownik.fml
::----------------------------------------------------------------------------------------------------------------------
_args:={? var_pres('_b')=117 || _b || exec('wybierz_args','pracownik') ?};

_args.DOMAIN:=_a;
_args.UD_SCH:=exec('domyslny','schemat','PODZORG');
_args.UD_SKL:=__PARSES.getVal('JednostkaOrganizacyjna').REF;
_args.F_ZATR:=__PARSES.getVal('F_ZATR').KOD;
_args.VIEW:=__PARSES.getVal('ZakresDanych');

exec('wybierz','pracownik',_args)


\wybierz_args
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła tworzy tablicę nazwaną z elementami parametryzującymi wybór pracownika(-ów).
::       Formuła wykorzystywana w dedykowanej czynności (ZWS_PAR_PWPR) i w funkcji bibliotecznej.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
   'DOMAIN','UD_SCH','UD_SKL','F_ZATR','VIEW','SQL_FROM','SQL_WHERE','FML_TEST','HDR_SEL',
   'WIELU','POMIN_KOLUMNY','GRP_IDENT','GRP_MODE',
   'OSOBA_FLD_ATTR','P_FLD_ATTR','WYSWIETL','XFILTER'
);

_args.DOMAIN:='';
_args.UD_SCH:=null();
_args.UD_SKL:=null();
_args.F_ZATR:='';
_args.VIEW:='';
_args.SQL_FROM:='';
_args.SQL_WHERE:='';
_args.FML_TEST:='';
::_args.HDR_SEL:='';

:: Wybór wielu pracowników: [0/1].
_args.WIELU:=1;

:: Dołączanie kolumn tabeli OSOBA do okna wertowania. Jeżeli na etapie parametryzacji choć jedno pole będzie ukryte
:: (patrz POMIN_KOLUMNY), to dołączanie kolumn nie będzie możliwe.
_args.OSOBA_FLD_ATTR:=2;

:: Dołączanie kolumn tabeli P do okna wertowania. Jeżeli na etapie parametryzacji choć jedno pole będzie ukryte
:: (patrz POMIN_KOLUMNY), to dołączanie kolumn nie będzie możliwe.
_args.P_FLD_ATTR:=2;

:: Dostępność akcji Wyświetl. Jeżeli na etapie parametryzacji choć jedno pole będzie ukryte (patrz POMIN_KOLUMNY),
:: to akcja nie będzie dostępna.
_args.WYSWIETL:=0;

: Pola poniżej są wykorzystywane tylko przez formułę "wybierz" a nie w czynności.

:: Akronimy pól oddzielone przecinkami, które zostaną ukryte (pominięte) przy tworzeniu okna wertowania tabeli P.
:: Ich poprawność nie jest weryfikowana.
:: Lista pól, które można "ukryć": T, IP, PESEL, DOWOD, PASZPORT, F_ZATR, WYDZIAL, ST, ZA.
:: Lista pól, których NIE można ukryć: NAZWISKO, PIERWSZE.
_args.POMIN_KOLUMNY:='';

:: Identyfikator okna grupowego.
_args.GRP_IDENT:='p_wybierz';

:: Tryb wyświetlania okna grupowego.
_args.GRP_MODE:='maximized';

:: Dostępność rozszerzonego filtra [1/0]
_args.XFILTER:=1;

_args


\wybierz_check_in
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła analizująca tablicę z elementami parametryzującymi wybór pracownika(-ów).
::   WE: _a [ARRAY] - Tablica parametrów wejściowych.
::       _b [ARRAY] - Tablica parametrów działania uzupełniana w ramach bieżącej funkcji.
::       Uwaga. Poprawność parametrów nie jest sprawdzana.
::   WY: '' jeżeli parametry wejściowe czynności są poprawne.
::       Komunikat z opisem błędu.
::----------------------------------------------------------------------------------------------------------------------
_in:=_a;
_args:=_b;

{? exec('domain_ref','#b_domain',_in.DOMAIN)=null()
|| return('Wartość parametru "DOMAIN" [%1] nie jest poprawnym kodem dziedziny produktowej.'@ [_in.DOMAIN])
|| _args.DOMAIN:=_in.DOMAIN
?};

_ud_typ:='PODZORG';

{? var_pres('UD_SCH',_in)=type_of('') & _in.UD_SCH<>''
|| _args.UD_SCH:=exec('szukaj_ud_sch','schemat',_ud_typ,_in.UD_SCH);
   {? _args.UD_SCH=null()
   || return('Wartość parametru "UD_SCH" [%1] nie jest poprawnym symbolem schematu.'@ [_in.UD_SCH])
   ?}
|| _args.UD_SCH:=exec('domyslny','schemat',_ud_typ);
   {? _args.UD_SCH=null()
   || return('Nie znaleziono schematów danych typu PODZORG.'@)
   ?}
?};
_ud_sch:=UD_SCH.SYMBOL;

{? var_pres('UD_SKL',_in)=type_of(null)
|| UD_SKL.cntx_psh();
   SEEK.UD_SKL:=
      {? _in.UD_SKL=null
      || exec('ud_skl_firma','schemat',_ud_typ)
      || _in.UD_SKL
      ?};
   _in.UD_SKL:=SEEK.UD_SKL().SYMBOL;
   UD_SKL.cntx_pop()
?};

{? var_pres('UD_SKL',_in)=type_of('') & _in.UD_SKL<>''
|| _args.UD_SKL:=exec('szukaj_ud_skl','schemat',_ud_typ,_in.UD_SKL);
   {? _args.UD_SKL=null()
   || return('Elementu "%1" nie znaleziono wśród elementów typu "%2".'@ [_in.UD_SKL,_ud_typ])
   ?};
   _skl:=_in.UD_SKL
|? _jo:=__PARSES.getVal('JednostkaOrganizacyjna');
   _jo.REF=null()
|| return('Brak jednostki organizacyjnej w parametrach pracy.'@)
|| _args.UD_SKL:=_jo.REF;
   _skl:=_jo.SYMBOL
?};

{? exec('szukaj_ud_def','schemat',_args.UD_SCH,_args.UD_SKL).REF=null()
|| return('Element o symbolu "%1" nie został znaleziony w schemacie "%2".'@ [_skl,_ud_sch])
?};

_f_zatr:=
   {? var_pres('F_ZATR',_in)=type_of('') & _in.F_ZATR<>''
   || _in.F_ZATR
   || __PARSES.getVal('F_ZATR').KOD
   ?};
_args.F_ZATR:=exec('kody','f_zatr',,_f_zatr);

{? var_pres('VIEW',_in)=type_of('') & _in.VIEW<>''
|| {? _in.VIEW='T' | _in.VIEW='N' | _in.VIEW='W'
   || _args.VIEW:=_in.VIEW
   || return('Wartość parametru "VIEW" [%1] nie jest poprawna.'@ [_in.VIEW])
   ?}
|| _args.VIEW:=__PARSES.getVal('ZakresDanych')
?};

F_ZATR.cntx_psh();
F_ZATR.index('UNIQUE');
F_ZATR.prefix();
_args.HDR_SEL:=
   {? var_pres('HDR_SEL',_in)=type_of('')
   || _in.HDR_SEL
   |? +_args.F_ZATR=1 & F_ZATR.find_key(_args.F_ZATR,)
   || F_ZATR.OPIS
   || 'Współpracownicy'@
   ?};
F_ZATR.cntx_pop();

_args.SQL_FROM:={? var_pres('SQL_FROM',_in)=type_of('') || _in.SQL_FROM || '' ?};

_args.SQL_WHERE:={? var_pres('SQL_WHERE',_in)=type_of('') || _in.SQL_WHERE || '' ?};

_args.FML_TEST:={? var_pres('FML_TEST',_in)=type_of('') & _in.FML_TEST<>'' || _in.FML_TEST || '1' ?};

_args.WIELU:={? var_pres('WIELU',_in)=type_of(0) || _in.WIELU || 1 ?};

_args.POMIN_KOLUMNY:={? var_pres('POMIN_KOLUMNY',_in)=type_of('') || _in.POMIN_KOLUMNY || '' ?};

_args.GRP_IDENT:={? var_pres('GRP_IDENT',_in)=type_of('') || _in.GRP_IDENT || 'p_wybierz' ?};

_mode:={? var_pres('GRP_MODE',_in)=type_of('') || _in.GRP_MODE || '' ?};
_args.GRP_MODE:={? _mode='normal' || 'normal' |? _mode='html_maximized' || 'html_maximized' || 'maximized' ?};

:: Kolejne dwa parametry sterują możliwością modyfikacji listy kolumn w oknie, odpowiednio dla tabel: OSOBA i P.
::    0 - bez zmian;
::    1 - przywraca standardową obsługę - kolumny (określone pod MacroBUILDER-em) będzie można dodawać;
::    2 - brak możliwości dodawania kolumn;
::    3 - można dodawać wszystkie kolumny.
_args.OSOBA_FLD_ATTR:=
   {? +_args.POMIN_KOLUMNY
::    Jeżeli zdefiniowano kolumny, które mają zostać ukryte, to wyłączamy możliwość dodawania kolumn.
   || 2
   |? var_pres('OSOBA_FLD_ATTR',_in)=type_of('')
   || {? _in.OSOBA_FLD_ATTR='T' || 1 || 2 ?}
   |? var_pres('OSOBA_FLD_ATTR',_in)=type_of(0) & _in.OSOBA_FLD_ATTR>=0 & _in.OSOBA_FLD_ATTR<=3
   || _in.OSOBA_FLD_ATTR
::    Domyślnie chronimy kolumny.
   || 2
   ?};

_args.P_FLD_ATTR:=
   {? +_args.POMIN_KOLUMNY
   || 2
   |? var_pres('P_FLD_ATTR',_in)=type_of('')
   || {? _in.P_FLD_ATTR='T' || 1 || 2 ?}
   |? var_pres('P_FLD_ATTR',_in)=type_of(0) & _in.P_FLD_ATTR>=0 & _in.P_FLD_ATTR<=3
   || _in.P_FLD_ATTR
   || 2
   ?};

_args.WYSWIETL:=
   {? +_args.POMIN_KOLUMNY | _args.P_FLD_ATTR=2 | _args.OSOBA_FLD_ATTR=2
   || 0
   |? var_pres('WYSWIETL',_in)=type_of('')
   || _in.WYSWIETL='T'
   |? var_pres('WYSWIETL',_in)=type_of(0)
   || _in.WYSWIETL
   || 0
   ?};

_args.XFILTER:={? var_pres('XFILTER',_in)=type_of(0) || _in.XFILTER || 1 ?};

''


\ud_sch_pl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Formuła przygotowuje tłumaczenia dla kontrolki ud_sch.dsk.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_TAB:=exec('elements_table','#desktop');
_add:="_a.blank(); _a.ID_SYS:=_b; _a.NAME:=_c; _a.add()";

_add(_TAB,'schTile@panel','Schemat'@);

_TAB


\wybierz_conf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła tworząca interfejs użytkownika dla wyboru pracownika(-ów).
::   WE: _a [ARRAY] - Tablica nazwana, o strukturze określonej przez formułę 'wybierz_args', z elementami
::             parametryzującymi działanie bieżącej formuły.
::       _b [ARRAY] - Tablica nazwana z elementami do przechowywania nazw okienek.
::   WY: Akronim utworzonego okna grupowego.
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_cfg:=_b;

_mode:='maximized';

_wnd:=UD_DEF.grp_make(_args.HDR_SEL,
:  Po wyświetleniu (załaduj kontrolkę, wyświetl drzewko).
   "  _par:=params_get();
      params_set(_par);
      _args:=_par.args;
      _cfg:=_par.cfg;
      exec('nawigator_ustaw','schemat',_cfg.nav.side,P_FILTER.UD_SCH,_args.UD_SKL);
      grp_disp(UD_DEF,_cfg.nav.side,1,1)
   ",_args.GRP_IDENT+$_args.WIELU,,,,,_args.GRP_MODE
);

: Struktura.
UD_DEF.grp_sel(_wnd,UD_DEF,_cfg.nav.side,,
:  Po odświeżeniu (wyświetl współpracowników).
   "  _par:=params_get();
      params_set(_par);
      _cfg:=_par.cfg;
      grp_disp(P,_cfg.nav.main,1,1)
   ",,,18,
:  Przed obsługą (ogranicz strukturę do właściwego schematu, ustaw korzeń).
   "  _par:=params_get();
      _args:=_par.args;
      _cfg:=_par.cfg;
      UD_DEF.prefix(P_FILTER.UD_SCH);
      exec('ud_def_root','schemat',_cfg.nav.side,P_FILTER.UD_SCH,_args.UD_SKL)
   ",,,,_mode,_cfg.nav.side
);

: Współpracownicy.
UD_DEF.grp_splt(_wnd,,'vertical','p',',25%');
UD_DEF.grp_sel(_wnd,P,_cfg.nav.main,,
:  Po odświeżeniu
   "  exec('stdor_p_ar_ext','pkd');
      _args:=params_get().args;
      {? _args.XFILTER
      || {? exec('ses_get','xfilter',cur_win(1,1)).SES=null
         || _act:='C:C'
         || _act:=''
         ?};
         P.actions_grayed(cur_win(1,1),_act)
      ?}
   ",,,,
:  Przed obsługą (ustaw filtr na tabeli P).
   "  _args:=params_get().args;
      {? _args.XFILTER
      || _ses:=exec('ses_get','xfilter',cur_win(1,1))
      ?};
      exec('filtruj_p','schemat',
         _args.DOMAIN,
         UD_DEF.ref(),
         _args.F_ZATR,
         '',
         _args.VIEW,
         {? _args.SQL_FROM<>''
         || {? _args.XFILTER & _ses.JOIN<>'' || '%1 %2'[_args.SQL_FROM,_ses.JOIN] || _args.SQL_FROM ?}
         || {? _args.XFILTER || _ses.JOIN || _args.SQL_FROM ?}
         ?},
         {? _args.SQL_WHERE<>''
         || {? _args.XFILTER & _ses.WHERE<>'' || '%1 and %2'[_args.SQL_WHERE,_ses.WHERE] || _args.SQL_WHERE ?}
         || {? _args.XFILTER || _ses.WHERE || _args.SQL_WHERE ?}
         ?}
      );
      exec('stdor_p_bs_ext','pkd')
   ",,,,_mode,_cfg.nav.main,1
);

_wnd


\p_zadania_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Obsługa akcji "Zadania" w oknach wertowania tabeli P.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('todo_select','#b__box',P.uidref())


\h_um_zadania_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Obsługa akcji "Zadania" w oknach wertowania tabeli H_UM.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('todo_select','#b__box',H_UM.uidref())


\h_zadania_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Obsługa akcji "Zadania" w oknach wertowania tabeli H.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('todo_select','#b__box',H.uidref())


\h_efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła odpowiedzialna za dynamiczne ustawianie właściwości pól tabeli H. Formuła wywoływana jest w dwóch
::       kontekstach pracy:
::          - Po redagowaniu konkretnego pola, które determinuje właściwości wyświetlania innych pól.
::          - Przed wyświetleniem okna redagowania (przed właściwymi akcjami Dołącz, Popraw, Wyświetl), ustawia
::            właściwości wszystkich pól (wymagających tego).
::       Kontekst pracy jest określany na podstawie argumentu wywołania.
::   WE: [_a] [STRING] - Kontekst pracy:
::             '1' - Obsługa jednego pola [domyślnie].
::             '*' - Obsługa wszystkich pól.
::       [_b] [TABLE]  - Uchwyt tabeli, w oknie redagowania której znajdują sie pola. Jeżeli _a='1', parametr jest
::             opcjonalny - zostanie przyjęta bieżąca tabela.
::       [_c] [STRING] - Akronim okna, w którym mają być ustawione właściwości pól. Jeżeli _a='1', parametr jest
::             opcjonalny - zostanie przyjęte bieżące okno.
::       [_d] [STRING] - Identyfikator okna w grupie (parametr istotny dla webTerma).
::       [_e] [STRING] - Akronim pola, którego wartość determinuje właściwości wyświetlania innych pól. Parametr ma
::             znaczenie wyłącznie dla _a='1'. [Domyślnie: bieżące pole].
::   WY: 0 - Błąd argumentów wywołania.
::       1 - Argumenty poprawne (właściwości ustawione).
::  OLD: \ae_wal2/war_tech.fml
::  OLD: \ae_wal3/war_tech.fml
::  OLD: \h_czywal_be/war_tech.fml
::  OLD: \h_paw_be/war_tech.fml
::  OLD: \h_s2t_be/war_tech.fml
::  OLD: \h_s3t_be/war_tech.fml
::  OLD: \h_um_efld_opt/umowy.fml
::----------------------------------------------------------------------------------------------------------------------
_webTerm:=app_info('web_sesid')<>'';

_tryb:={? var_pres('_a')=type_of('') & (_a='1' | _a='*') || _a || '1' ?};
{? var_pres('_b')=type_of(H)
|| _tab:=_b
|? _tryb='1' & ~_webTerm
|| _tab:=cur_tab(1,1)
|| return(0)
?};
{? var_pres('_c')=type_of('')
|| _we:=_c
|? _tryb='1' & ~_webTerm
|| _we:=cur_win(1,1)
|| return(0)
?};
_grp_ident:={? var_pres('_d')=type_of('') || _d || '' ?};
{? var_pres('_e')=type_of('')
|| _fld:=_e
|? _tryb='1' & ~_webTerm
|| _fld:=cur_afld()
|| _fld:=''
?};

_set:=exec('efld_opt','#window',_webTerm,_we,_grp_ident);

{? _fld=''
|| _val:=(PAR_SKID.get(313)='T');
:: Redagowanie.
   _set(_tab,_we,_grp_ident,'enable=%1,mark=%2'[$_val,$(~_webTerm & _val)],EDIT_VAR,'H_PSTO');
:: Wyświetlanie.
   _set(_tab,_we,_grp_ident,'enable=%1,mark=%2'[$_val,$(~_webTerm & _val)],H,'POZWORG')
?};

{? _fld='' | _fld='OD' | _fld='RU'
|| _sval:=$(date(2016,2,22)<=H_UM.OD & H_UM.RU().K='B');
   _set(_tab,_we,_grp_ident,'enable='+_sval,H_UM,'WYM_UZAS');
   {? _fld<>''
   || exec('h_efld_opt','pracownik','1',_tab,_we,_grp_ident,'WYM_UZAS')
   ?}
?};

{? _fld='' | _fld='WYM_UZAS'
|| _val:=(date(2016,2,22)<=H_UM.OD & H_UM.RU().K='B' & H_UM.WYM_UZAS='T');
   _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H_UM,'OKR_UZAS');
   _set(_tab,_we,_grp_ident,'mark=%1'[$(~_webTerm & _val)],H_UM,'OKR_UZAS','KOD');
   _set(_tab,_we,_grp_ident,'enable=%1,mark=%2'[$_val,$(~_webTerm & _val)],H_UM,'UZASDN');
   {? _fld<>''
::    Podczas nawiązywania współpracy pola w oknie są najpierw ukrywane (enable=0), potem wszystkie odkrywane
::    (enable=1) a na koniec wykonywana jest bieżąca formuła, która w przypadku H_UM.WYM_UZAS znowu je ukrywa.
::    Właśnie w tym czasie wykonywana jest formuła "Przed wyświetleniem" (m.in.) pola H_UM.WYM_UZAS.
::    System zapamiętuje wartość pola i fakt, że formuła zwróciła 0.
::    I tutaj dochodzimy do problemu: moim zdaniem kolejna zmiana opcji (enable=0 na enable=1) powinna (sama z siebie)
::    wyświetlic pole, dla którego wartość opcji zmieniła się. Jednak tak się nie dzieje. Skutkiem jest dostępność pola
::    (można do niego wejść), ale ponieważ "Przed wyświetleniem" zwróciło 0, to pole wygląda jakby dostępne nie było.
::    Szczególnie wyraźnie widać to na przykładzie pól: H_UM.OKR_UZAS i H_UM.UZASDN, które (jako pola napisowe) są
::    wyświetlane, ale zamiast treści prezentowane są kropki - wynik "Przed wyświetleniem", które zwróciło 0.
   || win_disp()
   ?}
?};

{? _fld='' | _fld='RU' | _fld='WYM_UZAS' | _fld='OKR_UZAS'
|| _val:=(H_UM.RU<>null() & H_UM.RU().K<>'C' & H_UM.RU().K<>'E' & H_UM.RU().K<>'X' &
          (H_UM.WYM_UZAS<>'T' | form(H_UM.OKR_UZAS().KOD)<>'1')
         );
   _set(_tab,_we,_grp_ident,'mark=%1'[$(~_webTerm & _val)],H_UM,'DO');
   _set(_tab,_we,_grp_ident,'mark=%1'[$(~_webTerm & _val)],H_UM,'P_DO')
?};

{? exec('upgrade2226_nru01','wnioski_urlopowe')
|| {? _fld='' | _fld='RU'
   || _val:=(H_UM.RU<>null() & H_UM.RU().K='A');
      _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H_UM,'PRZ_USPR');
      _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H_UM,'ZAM_ZAW')
   ?};

   {? _fld='' | _fld='RU' | _fld='ZAM_ZAW'
   || _val:=(H_UM.RU<>null() & H_UM.RU().K='A' & H_UM.ZAM_ZAW='T');
      _set(_tab,_we,_grp_ident,'enable=%1,mark=%1'[$_val],H_UM,'ZAM_OKR')
   ?}
?};

{? _fld='' | _fld='MAC'
|| _val:=(H.MAC='T');
   _set(_tab,_we,_grp_ident,'enable=%1,mark=%2'[$_val,$(~_webTerm & _val)],H,'WYL');
   _set(_tab,_we,_grp_ident,'enable=%1,mark=%2'[$_val,$(~_webTerm & _val)],H,'WYM');
   _set(_tab,_we,_grp_ident,'enable='+$_val,H,'WY')
?};

{? _fld='' | _fld='RWYL' | _fld='RWYM'
|| _sval:=$(H.RWY<1);
   _set(_tab,_we,_grp_ident,'enable='+_sval,H,'CZY_NADG');
   _set(_tab,_we,_grp_ident,'enable='+_sval,H,'DOP_ST');
   {? _fld<>''
   || exec('h_efld_opt','pracownik','1',_tab,_we,_grp_ident,'CZY_NADG')
   ?}
?};

{? _fld='' | _fld='CZY_NADG'
|| _sval:=$(H.RWY<1 & H.CZY_NADG='T');
   _set(_tab,_we,_grp_ident,'enable='+_sval,H,'DOP_NADG')
?};

{? _fld='' | _fld='PAT'
|| _val:=(H.PAT='K' | H.PAT='P');
   _set(_tab,_we,_grp_ident,'enable=%1,mark=%2'[$_val,$(~_webTerm & _val)],H,'PAW')
?};

{? _fld='' | _fld='S1'
|| _set(_tab,_we,_grp_ident,'enable='+$(H.S1>0 & KST_PAR.SLBANK<>null()),H,'CZYWAL');
   _val:=(H.ODDEL='N' | H.S1);
   _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H,'S2');
   _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H,'CZYWAL2');
   _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H,'S2T');
   _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H,'S2P');
   _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H,'KADOD');
   _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H,'S3');
   _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H,'CZYWAL3');
   _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H,'S3T');
   _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H,'S3P');
   {? _fld<>''
   || exec('h_efld_opt','pracownik','1',_tab,_we,_grp_ident,'CZYWAL')
   ?}
?};

{? _fld='' | _fld='S2'
|| _sval:=$(H.S2>0);
   _set(_tab,_we,_grp_ident,'enable='+_sval,H,'S2T');
   _sval:=$(H.S2>0 & KST_PAR.SLBANK<>null());
   _set(_tab,_we,_grp_ident,'enable='+_sval,H,'CZYWAL2');
   {? _fld<>''
   || exec('h_efld_opt','pracownik','1',_tab,_we,_grp_ident,'S2T');
      exec('h_efld_opt','pracownik','1',_tab,_we,_grp_ident,'CZYWAL2')
   ?}
?};

{? _fld='' | _fld='S2T'
|| _val:=(H.S2>0 & H.S2T='P');
   _set(_tab,_we,_grp_ident,'enable=%1,mark=%2'[$_val,$(~_webTerm & _val)],H,'S2P')
?};

{? _fld='' | _fld='S3'
|| _sval:=$(H.S3>0);
   _set(_tab,_we,_grp_ident,'enable='+_sval,H,'S3T');
   _sval:=$(H.S3>0 & KST_PAR.SLBANK<>null());
   _set(_tab,_we,_grp_ident,'enable='+_sval,H,'CZYWAL3');
   {? _fld<>''
   || exec('h_efld_opt','pracownik','1',_tab,_we,_grp_ident,'S3T');
      exec('h_efld_opt','pracownik','1',_tab,_we,_grp_ident,'CZYWAL3')
   ?}
?};

{? _fld='' | _fld='S3T'
|| _val:=(H.S3>0 & H.S3T='P');
   _set(_tab,_we,_grp_ident,'enable=%1,mark=%2'[$_val,$(~_webTerm & _val)],H,'S3P')
?};

{? _fld='' | _fld='S4'
|| _sval:=$(H.S4>0 & KST_PAR.SLBANK<>null());
   _set(_tab,_we,_grp_ident,'enable='+_sval,H,'CZYWAL4');
   {? _fld<>''
   || exec('h_efld_opt','pracownik','1',_tab,_we,_grp_ident,'CZYWAL4')
   ?}
?};

{? _fld='' | _fld='CZYWAL' | _fld='CZYWAL2' | _fld='CZYWAL3' | _fld='CZYWAL4' | _fld='ODDEL'
|| _val:=(H.S1>0 & H.CZYWAL='T') | (H.S2>0 & H.CZYWAL2='T') | (H.S3>0 & H.CZYWAL3='T') |
         (H.S4>0 & H.CZYWAL4='T' & H.ODDEL='T');
   {? _val & KST_PAR.SLBANK=null()
:     Jeżeli przy choć jednym elemencie wynagrodzenia zaznaczono "Waluta" i słownik banków nie jest wskazany,
:     to trzeba o tym poinformować użytkownika.
   || FUN.emsg('Nie ustalono słownika banków w parametrach pracy programu.'@);
:     Nie mozemy pozwolić na redagowanie pól związanych z walutowością.
      _val:=0
   ?};
   _sval:=$_val;
   _set(_tab,_we,_grp_ident,'enable=%1,mark=%2'[$_val,$(~_webTerm & _val)],H,'ZWAL','KOD');
   _set(_tab,_we,_grp_ident,'enable='+_sval,H,'ZWAL','TR');
   _set(_tab,_we,_grp_ident,'enable=%1,mark=%2'[$_val,$(~_webTerm & _val)],H,'WAL','KOD');
   _set(_tab,_we,_grp_ident,'enable='+_sval,H,'WAL','TR')
?};

{? _fld='' | _fld='ODDEL'
|| _val:=exec('chk_role','#b__box',OPERATOR.USER,'PKD_EZK_OROD');
   _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H,'ODDEL');
   _val:=exec('chk_role','#b__box',OPERATOR.USER,'PKD_EZK_OROD') & H.ODDEL='T';
   _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H,'KODDEL');
   _val:=H.ODDEL='T';
   _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H,'S4');
   _set(_tab,_we,_grp_ident,'enable=%1'[$_val],H,'CZYWAL4');
   _set(_tab,_we,_grp_ident,'mark=%1'[$(~_val)],H,'S1');
   {? _fld<>''
   || exec('h_efld_opt','pracownik','1',_tab,_we,_grp_ident,'S1')
   ?}
?};

1


\p_x_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2006]
:: OPIS: Przed wyświetleniem pól tabeli P lub tabel zrelacjonowanych z P.
::  OLD: \prz_wysw/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
1


\prac_ip
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2006]
:: OPIS: Formuła tworzy tabelę tymczasową z identyfikatorami pracowników z tabel P i SLO_OSOB.
::   WE: [_a] [STRING] - Kod formy współpracy [domyślnie: P].
::   WY: Alias do tabeli tymczasowej zawierającej w kolumnie IP wszystkie identyfikatory pracowników  - jeśli działanie
::       zostało zakończone sukcesem - w przeciwnym wypadku wartość typu void.
::  OLD: \prac_ip/kali.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('')
|| _a:='P'
?};
sql(
   'select distinct P.IP as IP, P.REFERENCE as REF from P join F_ZATR '
   'where F_ZATR.KOD=\':_a\' and P.FIRMA=:_b'
   'union '
   'select SLO_OSOB.ID as IP, SLO_OSOB.REFERENCE as REF from SLO_OSOB join F_ZATR '
   'where F_ZATR.KOD=\':_a\' '
   'order by 1, 2',
   _a,
   exec('ref_firma','ustawienia')
)


\p_ip_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Wartość początkowa pola P.IP - podpowiadany jest pierwszy wolny.
::   WE: [_a] [STRING] - Kod formy współpracy [domyślnie: P].
::  OLD: \nowy_ip/kali.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__PERSONEL')=type_of(0) & __PERSONEL
|| {? var_pres('_a')<>type_of('')
   || _a:='P'
   ?};
   params_set('KOD', _a);
   _plg_ip:=Plugin.run('PKD_P_IP_001');
   {? _plg_ip<>-1 || return(_plg_ip) ?};
   _TAB:=exec('prac_ip','pracownik',_a);
   {? type_of(_TAB)<>type_of(P)
   || return(0)
   ?};
   {! _ip:=1 |? _TAB.find_key(_ip) !};
   _ip
?}


\p_wnd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Dla bieżącego rekordu tabeli P ustala akronim okna redagowania.
::       Formuła wykorzystywana przez akcje: Popraw i Wyświetl.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_f_zatr:=exec('dest','f_zatr',P.F_ZATR,'KOD');

:: spróbuj uzyskać akronim okienka od wtyczki
_wnd:=Plugin.run('PKD_P_WIN_EDIT',_f_zatr);
{? type_of(_wnd)=type_of('') & _wnd<>''
|| return(_wnd)
?};

{? _f_zatr='P'
|| 'RED_P'
|? _f_zatr='K' | _f_zatr='T'
|| 'RED_K'
|| 'RED_Z'
?}


\p_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Ogólna obsługa akcji "Popraw" tabeli P - dotyczy różnych form współpracy i jest wywoływana z różnych obszarów.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
: Zachowaj aktualne formuły pól tabeli.
_buf:=exec('fld_fml_pkd','osoba',1,0);

OSOBA.cntx_psh();
P.cntx_psh();

_f_zatr:=exec('dest','f_zatr',P.F_ZATR,'KOD');

_we:=exec('p_wnd','pracownik');
P.win_edit(_we);
exec('osoba_efld_opt','osoba','*',P,_we);
:: grupy uprawnień
exec('p_gp_def_efld_otp','pracownik',_we);
:: projekty
exec('p_projekty_efld_otp','pracownik',_we);
P.efld_opt(_we,'mark=%1' [$(_f_zatr='Z')],,'ODDZIAL');
P.efld_opt(_we,'mark=%1' [$(~('KTRZ'*_f_zatr))],,'ZAW');

_ok:=1;
_ip:=P.IP;
OSOBA.bl_file('ZDJECIE',1);
{? P.edit("exec('pracownik_sprawdz','pracownik')")
|| OSOBA.clear();
   P.clear();
   _mod_ip:=0;
   {? P.IP<>_ip
   || F_ZATR.cntx_psh();
      {? P.F_ZATR().DOCELOWA='T'
::       Słownik SLO_OSOB jest uzupełniany w momencie "zatrudnienia" - zmiany formy współpracy na docelową. Tak więc
::       sprawdzanie "użycia" bieżącego rekordu tabeli P w tym słowniku ma sens tylko dla form docelowych.
      || exec('__F_ZATR','object');
         _val:=__F_ZATR.P;
         __F_ZATR.mod(_f_zatr,'P');
         _test:=exec('slo_test','slo_slu','SLO_OSOB','ID',_ip,1);
         __F_ZATR.mod(_val,'P');
         {? _test<0
         || _ok:=0
         |? _test>0
         || FUN.emsg(
               'Identyfikator pracownika jest wykorzystywany w innych systemach.\n'
               'Przywrócona zostanie poprzednia wartość (%1) identyfikatora.'@ [$_ip]
            );
            P.IP:=_ip
         || _mod_ip:=1
         ?};
         {? _ok & _mod_ip
         || _test:=exec('control_test','pracownik',$P.ref(),_ip);
            {? ~_test
            || FUN.emsg(
                  'Identyfikator pracownika jest wykorzystywany w innych systemach.\n'
                  'Przywrócona zostanie poprzednia wartość (%1) identyfikatora.'@ [$_ip]
               );
               P.IP:=_ip;
               _mod_ip:=0
            ?}
         ?}
      || _mod_ip:=1
      ?};
      F_ZATR.cntx_pop()
   ?};
   {? _ok
   || do();
      {? OSOBA.put()
      || exec('desc_update','#b__box',OSOBA.uidref());
         {? (_file:=OSOBA.bl_file('ZDJECIE'))<>''
         || OSOBA.bl_put('ZDJECIE',_file)
         ?};
         {? P.put()
         || exec('pracownik_aktualizuj','pracownik');
            exec('desc_update','#b__box',P.uidref())
         || undo()
         ?};
         {? _mod_ip
         || SLO_OSOB.cntx_psh();
            SLO_OSOB.index('ID');
            SLO_OSOB.prefix(P.F_ZATR);
            {? SLO_OSOB.find_key(_ip)
            || SLO_OSOB.ID:=P.IP;
               {? ~SLO_OSOB.put(1)
               || undo()
               ?}
            ?};
            SLO_OSOB.cntx_pop()
         ?}
      || undo()
      ?};
      {? end()
      || P.f_rfresh()
      ?}
   ?}
?};
OSOBA.bl_file('ZDJECIE',1);
OSOBA.cntx_pop();
P.cntx_pop();
P.get();

: Odtwórz pierwotne formuły pól tabeli.
exec('restore_fml_all','#field',OSOBA,_buf);
~~


\p_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Ogólna obsługa akcji "Usuń" dla tabeli P - dotyczy różnych form współpracy i jest wywoływana z różnych obszrów.
::   WE:
::   WY: Czy rekord został usuniety?
::       0 - Tak.
::       1 - Nie.
::----------------------------------------------------------------------------------------------------------------------
F_ZATR.cntx_psh();
{? P.F_ZATR().DOCELOWA='T'
:: Słownik SLO_OSOB jest uzupełniany w momencie "zatrudnienia" - zmiany formy współpracy na docelową. Tak więc
:: sprawdzanie "użycia" bieżącego rekordu tabeli P w tym słowniku ma sens tylko dla form docelowych.
|| exec('__F_ZATR','object');
   _val:=__F_ZATR.P;
   __F_ZATR.mod(P.F_ZATR().KOD,'P');
   _test:=exec('slo_test','slo_slu','SLO_OSOB','ID',P.IP);
   __F_ZATR.mod(_val,'P')
|| _test:=0
?};
F_ZATR.cntx_pop();
{? _test<>0
|| exec('del_warn','#table');
   return(0)
?};

_ret:=0;
{? exec('del_conf','#table',P) & exec('ext_conf','pkd')
|| _state:=no_msg(1);
   _kal:=P.KAL;
   _ret:=P.del(1,1);
   {? _ret
   || exec('del_kalp','kaledit',_kal)
   || exec('restrict','pracownik','P')
   ?};
   no_msg(_state)
?};
_ret


\p_bw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Ogólna obsługa akcji "Wyświetl" dla tabeli P.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
P.win_edit(exec('p_wnd','pracownik'));
P.display()


\bds_bw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: J9SZAFRA [22.26]
:: OPIS: Ogólna obsługa akcji "Wyświetl" dla tabeli BDS.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
STN.cntx_psh();
STN.prefix();
STN.seek(BDS.STN);
STN.win_edit('RED');
STN.display();
STN.cntx_pop()


\edit_var_p_kal_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [12.10]
:: OPIS: Przed wyświetleniem pola EDIT_VAR.P_KAL.
::  OLD: \p_kal_bd/kaledit.fml
::----------------------------------------------------------------------------------------------------------------------
_act:=-menu_txt();

{? _act='popraw'
|| exec('edit_var_p_kal_be','pracownik')

|? _act='dołącz'
|| {? EDIT_VAR.P_KAL=null()
   || EDIT_VAR.P_KAL:=P.KAL
   || 1
   ?}

|| _ret:=0;
   R_WZCZ.cntx_psh();
   R_WZCZ.index('R_WZWND');
   R_WZCZ.prefix(P.name(),#P.ref(),'N','N');
   {? ~R_WZCZ.size()
   || EDIT_VAR.P_KAL:=null();
      _ret:=1
   ?};
   R_WZCZ.cntx_pop();
   _ret
?}


\edit_var_p_kal_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [12.10]
:: OPIS: Przed redagowaniem pola EDIT_VAR.P_KAL.
::  OLD: \p_kal_be/kaledit.fml
::----------------------------------------------------------------------------------------------------------------------
{? EDIT_VAR.P_KAL
|| EDIT_VAR.P_KAL().CZESC='N'
|| 1
?}


\edit_var_p_kin_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [12.10]
:: OPIS: Przed wyświetleniem pola EDIT_VAR.P_KIN.
::  OLD: \p_kin_bd/kaledit.fml
::----------------------------------------------------------------------------------------------------------------------
_act:=-menu_txt();
{? _act<>'popraw' & _act<>'dołącz'
|| EDIT_VAR.P_KIN:='?'
?};
1


\edit_var_p_kin_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [12.10]
:: OPIS: Przed redagowaniem pola EDIT_VAR.P_KIN.
::  OLD: \p_kin_be/kaledit.fml
::----------------------------------------------------------------------------------------------------------------------
fld()<>'?'


\edit_var_p_kin_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [12.10]
:: OPIS: Po redagowaniu pola EDIT_VAR.P_KIN.
::  OLD: \p_kin_ae/kaledit.fml
::----------------------------------------------------------------------------------------------------------------------
{? fld()='?' || fld('N') ?};
1


\h_um_bp_fld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Modyfikuje dostępność pól określających okres trwania umowy.
::   WE:  _a  [NUMBER] - Status dostępności pól:
::                      0 - Zablokuj.
::                      1 - Odblokuj.
::       [_b] [NUMBER] - Kontekst edycji (parametr wymagany dla _a=0):
::                      0 - Jedyny zapis.
::                      1 - Pierwszy zapis.
::                      2 - Zapis pośredni.
::                      3 - Ostatni rekord.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _a | _b=0
|| H_UM.fld_fml('OD','BEFORE_EDIT',"*");
   H_UM.fld_fml('DO','BEFORE_EDIT',"*")
|| {? _b=2 | _b=3
   || H_UM.fld_fml('OD','BEFORE_EDIT',"0")
   ?};
   {? _b=1 | _b=2
   || H_UM.fld_fml('DO','BEFORE_EDIT',"0")
   ?}
?}


\h_um_od_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Po redagowaniu pola H_UM.OD
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('h_efld_opt','pracownik')


\h_um_ewkiwalent_rozliczony
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2008]
:: OPIS: Formuła sprawdza czy ekwiwalent na umowie jest już rozliczony na liście płac.
::   WE:
::   WY:
::  OLD: \humedit/umowy.fml
::----------------------------------------------------------------------------------------------------------------------
O.cntx_psh();
O_P.cntx_psh();
O_P.index('LT');
O_P.prefix(P.ref(),-H_UM.LT,'T');
_ret:=O_P.first() & O_P.O().Z='T';
O_P.cntx_pop();
O.cntx_pop();
_ret


\h_um_lt_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Przed redagowaniem pola H_UM.LT.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H_UM.DO<>date(0,0,0) & (H_UM.LT='' | ~exec('h_um_ewkiwalent_rozliczony','pracownik'))


\h_um_ekw_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Przed redagowaniem pola H_UM.EKW.
::       Formuła sprawdza, czy ekwiwalent na umowie nie jest już aby rozliczony na liście płac.
::   WY: 0 / 1
::  OLD: \h_um_ekw_be/kali.fml
::----------------------------------------------------------------------------------------------------------------------
H_UM.DO<>date(0,0,0) & ~exec('h_um_ewkiwalent_rozliczony','pracownik')


\znajdz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS
:: OPIS: Wyszukuje zapis o kodzie przekazanym argumentem, jeżeli próba odnalezienia rekordu nie powiedzie się,
::       dodaje nową pozycję.
::   WE: _a - Kod umowy.
::       _b - Opis umowy (opcjonalnie).
::   WY: Wskazanie na rodzaj umowy (RU.ref()).
::  OLD: \znajdz/rodzum.fml
::----------------------------------------------------------------------------------------------------------------------
RU.index('K');
EDIT_VAR.SLO_TYP:='UMPRAC';
_typ:=exec('slo_typ','ext_slo');
RU.prefix(_typ);
{? ~RU.find_key(_a,_a)
|| RU.blank(1);
   RU.TYP:=_typ;
   RU.O:={? var_pres('_b')=type_of('') || _b || _a+' - dodany automatycznie' ?};
   RU.K:=_a;
   RU.add()
?};
RU.ref()


\h_um_ru_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS
:: OPIS: Wartość początkowa pola H_UM.RU.
::   WE: [_a] [_P] - wskazanie pracownika - UWAGA: może być null
::       [_b] [STRING] - kod (docelowej) formy współpracy
::   WY: Wskazanie na rodzaj umowy (RU.ref()).
::  OLD: \wphum_ru/rodzum.fml
::----------------------------------------------------------------------------------------------------------------------
_ru:=null();
_p_ref:={? var_pres('_a')=type_of(null) || _a || P.ref() ?};
_f_zatr:={? var_pres('_b')=type_of('') & _b<>'' || _b || exec('dest','f_zatr',P.F_ZATR,'KOD') ?};

H_UM.cntx_psh();
H_UM.index('HUM_RUM');
H_UM.prefix(_p_ref);

{? _f_zatr='P'
|| {? H_UM.last()
   || {? H_UM.RU().K='A' || _ru:=exec('znajdz','pracownik','B','czas określony')
      |? H_UM.RU().K='B' || _ru:=exec('znajdz','pracownik','C','czas nieokreślony')
      || _ru:=H_UM.RU
      ?}
   || _ru:=exec('znajdz','pracownik','A','okres próbny')
   ?}
|| _ru:=exec('znajdz','pracownik','X','inne')
?};

H_UM.cntx_pop();

_ru


\h_um_ru_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2008]
:: OPIS: Formuła po redagowaniu pola H_UM.RU - przepisuje rodzaj umowy do przebiegu lub sprawdza czy przy poprawianiu
::       umowy nie został wykasowany znacznik rodzaju umowy.
::  OLD: \przep_ru/umowy.fml
::----------------------------------------------------------------------------------------------------------------------
_ret:=1;
{? -menu_txt()<>'popraw'
|| H.RU:=H_UM.RU
|| {? H_UM.RU=null()
   || FUN.info('Proszę uzupełnić rodzaj umowy.'@);
      _ret:=0
   ?}
?};
exec('h_efld_opt','pracownik');
_ret


\h_um_wym_uzas_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DAROKR [12.41]
:: OPIS: Przed wyświetleniem pola H_UM.WYM_UZAS.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H_UM.RU().K='B' & date(2016,2,22)<=H_UM.OD


\h_um_wym_uzas_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DAROKR [12.41]
:: OPIS: Przed redagowaniem pola H_UM.WYM_UZAS.
::   WE:
::   WY:
::  OLD: \wym_uzas_bd/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
H_UM.RU().K='B' & date(2016,2,22)<=H_UM.OD


\h_um_wym_uzas_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Po redagowaniu pola H_UM.WYM_ZAS.
::   WE:
::   WY:
::  OLD: \wym_uzas_ae/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
exec('h_efld_opt','pracownik')


\h_um_okr_uzas_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DAROKR [12.41]
:: OPIS: Przed wyświetleniem pola H_UM.OKR_UZAS.
::   WE:
::   WY:
::  OLD: \okr_uzas_bd/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
params_exec('h_um_btn_repl','pracownik');

H_UM.RU().K='B' & date(2016,2,22)<=H_UM.OD & H_UM.WYM_UZAS='T'


\h_um_okr_uzas_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DAROKR [12.41]
:: OPIS: Przed wyświetleniem pola H_UM.OKR_UZAS.
::   WE:
::   WY:
::  OLD: \okr_uzas_bd/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
H_UM.RU().K='B' & date(2016,2,22)<=H_UM.OD & H_UM.WYM_UZAS='T'


\h_um_okr_uzas_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Po redagowaniu pola H_UM.OKR_UZAS.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('h_efld_opt','pracownik')


\h_um_uzasdn_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DAROKR [12.41]
:: OPIS: Przed wyświetleniem pola H_UM.UZASDN.
::   WE:
::   WY:
::  OLD: \uzasdn_bd/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
H_UM.RU().K='B' & date(2016,2,22)<=H_UM.OD & H_UM.WYM_UZAS='T'


\h_um_uzasdn_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DAROKR [12.41]
:: OPIS: Przed wyświetleniem pola H_UM.UZASDN.
::   WE:
::   WY:
::  OLD: \uzasdn_be/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
H_UM.RU().K='B' & date(2016,2,22)<=H_UM.OD & H_UM.WYM_UZAS='T'


\h_um_mod_pos
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Określa możliwość modyfikacji umowy poprzez jej pozycję i zawartość listy umów o pracę.
::   WE: _a [REFERENCE] - Wskazanie umowy (ref rekordu tabeli H_UM).
::       _b [REFERENCE] - Wskazanie pracownika (ref rekordu tabeli P).
::   WY: 0 - jedyna
::       1 - pierwsza
::       2 - pośrednia
::       3 - ostatnia
::----------------------------------------------------------------------------------------------------------------------
{? _a=null()
:: Taka sytuacja ma miejsce podczas obsługi akcji "Dołącz". Mimo, że rekordu nie ma jeszcze na dysku (jest tylko w
:: buforze), to merytorycznie możemy uznać, że jest to "jedyny" zapis - stąd zwracana wartość.
|| return(0)
?};
H_UM.cntx_psh();
H_UM.index('OD');
H_UM.prefix(_b);
_first:=(H_UM.first() & _a=H_UM.ref());
_last:=(H_UM.last() & _a=H_UM.ref());
_pos:=0;
{? _first<>_last
|| {? _first || _pos:=1
   |? _last || _pos:=3
   ?}
|? ~_first & ~_last
|| _pos:=2
?};
H_UM.cntx_pop();
_pos


\h_um_p_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Część wspólna dla formuł sprawdzających poprawność dodawanej umowy o pracę - edycja razem z przebiegiem.
::   WE:  _a  [NUMBER] - tryb edycji: 0 - dodawanie, 1 - poprawianie
::       [_b] [NUMBER] - tryb wsadowy (bez komunikatów): 0 - nie [domyślnie], 1 - tak
::   WY: zgodny ze specyfikacją wymagań dla formuły typu rekord po
::  OLD: \spr_hum/umowy.fml
::  OLD: \spr_h/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_popraw:=_a;
_batch:=var_pres('_b')=type_of(0) & _b;

: sprawdź poprawność umowy o pracę
_chk:=exec('h_um_p_com_ae','pracownik',_popraw,_batch);
{? (type_of(_chk)=type_of('') & _chk<>'') |
   (type_of(_chk)=type_of(0) & _chk=0)
|| {? _batch
   || return(_chk)
   || return(exec('mod_ae_ret_val','pracownik',H_UM,_chk))
   ?}
?};

{? _batch
|| _fret:="_a"
|| _fret:="FUN.emsg(_a); exec('mod_ae_ret_val','pracownik',H_UM,_b)"
?};

{? H.DO<>date(0,0,0) & H.DO<H_UM.OD
|| return(_fret('Data rozpoczęcia umowy nie może być późniejsza od %1.'@ [$H.DO],'OD'))
?};

_h_mod_pos:=exec('h_mod_pos','pracownik',H.ref(),H.UMOWA);

H.RU:=H_UM.RU;
H.OD:=H_UM.OD;
{? _popraw=0 | _h_mod_pos=0 | _h_mod_pos=3
|| H.DO:=H_UM.DO
?};

: sprawdź poprawność przebiegu zatrudnienia
_chk:=exec('h_p_com_ae','pracownik',_popraw,_batch);
{? (type_of(_chk)=type_of('') & _chk<>'') |
   (type_of(_chk)=type_of(0) & _chk=0)
|| {? _batch
   || return(_chk)
   || return(exec('mod_ae_ret_val','pracownik',H_UM,_chk))
   ?}
?};

{? _popraw=0
|| return(1)
?};

:  datami pośredniej umowy nie można swobodnie manipulować (są nieredagowalne w oknie)
:  dalsze sprawdzanie może być więc pominięte, dane poprawne (bo się nie zmieniły)
{? exec('h_um_mod_pos','pracownik',H_UM.ref(),H_UM.P)=2
|| return(1)
?};

_chk:='';
:: tylko zakończony przebieg
{? H.DO<>date(0,0,0)
|| H.cntx_psh();
   H.index('HISTUM');
   H.prefix(H_UM.ref());
:: sprawdź możliwość zmiany dat
   {? H.first() & H.DO<>date(0,0,0) & H.DO<H_UM.OD
::    próba przesunięcia daty początku umowy za datę zakończenia pierwszego przebiegu
   || _chk:=_fret('Data rozpoczęcia umowy nie może być późniejsza od %1.'@ [$H.DO],'OD')
   |? H.last() & H_UM.DO<>date(0,0,0) & H_UM.DO<H.OD
::    próba przesunięcia daty końca umowy przed datę rozpoczęcia ostatniego przebiegu
   || _chk:=_fret('Data zakończenia umowy nie może być wcześniejsza od %1.'@ [$H.OD],'DO')
   ?};
   H.cntx_pop()
?};
{? _chk<>''
|| return(exec('mod_ae_ret_val','pracownik',H_UM,_chk))
?};

1


\h_um_p_com_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Część wspólna dla formuł sprawdzających poprawność danych w umowie o pracę
::   WE:  _a  [NUMBER] - tryb edycji: 0 - dodawanie, 1 - poprawianie
::       [_b] [NUMBER] - tryb wsadowy (bez komunikatów): 0 - nie [domyślnie], 1 - tak
::   WY: zgodny ze specyfikacją wymagań dla formuły typu rekord po
::  OLD: \spr_hum/umowy.fml
::  OLD: \spr_okr_dane/umowy.fml
::  OLD: \spr_h/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_popraw:=_a;
_batch:=var_pres('_b')=type_of(0) & _b;
_silent:={? _batch || 1 || ~~ ?};

{? _batch
|| _fret:="_a"
|| _fret:="FUN.emsg(_a); _b"
?};

_f_zatr:=exec('dest','f_zatr',P.F_ZATR,'KOD');
{? _f_zatr='Z'
|| H_UM.NUMER:='ZLEC'+$P.IP
?};

{? (_chk:=__CHK.record(H_UM,_silent,'NUMER','RU',{? _f_zatr='P' || 'P_OD' || '' ?},'OD'))<>''
|| return(_chk)
?};

_zdate:=date(0,0,0);

{? exec('h_um_ru_zastepstwo','pracownik') & (H_UM.DO=_zdate | H_UM.P_DO=_zdate)
:: umowa na zastępstwo może być zawarta bez określonej daty zakończenia
|| _ret:={? H_UM.DO=_zdate
         || 'DO'
         || 'P_DO'
         ?};
   {? ~_batch & ~FUN.ask(
         'Czy na pewno zarejestrować umowę na zastępstwo bez określonego pola "%1"?'@
         [MS.name(H_UM,_ret)])
   || return(_ret)
   ?}

|? _ru:=H_UM.RU().K;
   _ru<>'C' & _ru<>'E' & _ru<>'X' & (_chk:=__CHK.record(H_UM,_silent,{? _f_zatr='P' || 'P_DO' || '' ?},'DO'))<>''
:: wymagana data zakończenia umowy
|| return(_chk)
?};

_oddelegowanie:=PAR_SKID.get(261)='T' & exec('chk_role','#b__box',OPERATOR.USER,'PKD_EZK_OROD');
:: Sprawdzenie czy uda się poprawić oddelegowanie jeśli zmieniamy datę umowy:
{? _oddelegowanie & ~_batch
|| H.cntx_psh();
   H.use(exec('h_name','pracownik'));
   H.index('HISTUM');
   {? H.last() & H.ODDEL='T'
   ||  H_ODDE.cntx_psh();
       H_ODDE.use('h_odde'+(H.name()+1));
       H_ODDE.index('HOD');
       H_ODDE.prefix(H.ref());
       {? H_ODDE.last()
       || {? (H_ODDE.O_DO<>H.DO & H_ODDE.O_OD>H.DO) |
             sql('select * from H_ODDP where H_ODDP.H_ODDE=:_a and substr(H_ODDP.LT,1,1)=\'L\'',H_ODDE.ref()).size()
          || FUN.emsg('Należy zweryfikować oddelegowania po zakończeniu redagowania.'@)
          ?}
       ?};
       H_ODDE.cntx_pop()
   ?};
   H.cntx_pop()
?};

{? _f_zatr='P' & H_UM.P_DO<>_zdate & (H_UM.DO=_zdate | H_UM.DO>H_UM.P_DO)
:: pierwotna data do mniejsza od daty obowiązywania
|| {? ~_batch & ~FUN.ask(
         'Data "%1" jest większa niż "%2".\nCzy na pewno zarejestrować umowę?'@
         [MS.name(H_UM,'DO'),MS.name(H_UM,'P_DO')])
   || _ret:={? type_of(exec('mod_ae_ret_val','pracownik',H_UM,'DO'))=type_of('')
            || 'DO'
            || 'P_DO'
            ?};
      return(_ret)
   ?}
?};

{? _f_zatr='P' & H_UM.P_DO<>_zdate & H_UM.P_DO<H_UM.P_OD
|| return(_fret('"%1" nie może być wcześniejsza niż "%2".'@ [MS.name(H_UM,'P_DO'),MS.name(H_UM,'P_OD')],'P_DO'))
?};

{? H_UM.DO<>_zdate & H_UM.DO<H_UM.OD
|| return(_fret('"%1" nie może być wcześniejsza niż "%2".'@ [MS.name(H_UM,'DO'),MS.name(H_UM,'OD')],'DO'))
?};

{? _f_zatr='P' & H_UM.OD<H_UM.P_OD
|| return(_fret('"%1" nie może być wcześniejsza niż "%2".'@ [MS.name(H_UM,'OD'),MS.name(H_UM,'P_OD')],'OD'))
?};

{? _f_zatr='P' & ~_batch & exec('info_zw','personel','P') &
   ~FUN.ask('Konflikty dla wybranej daty zakończenia umowy.\nKontynuować?'@)
|| return('OD')
?};

{? _f_zatr='P'
|| _dt:=date(2016,2,22);
   {? _dt<=H_UM.OD & (H_UM.RU().K='D' | H_UM.RU().K='E')
   || return(_fret(
         'Kodeks pracy, po zmianach obowiązujących od 22 lutego 2016 roku,\n'
         'nie przewiduje umów o kodach "D" i "E".\n'
         'Być może należy użyć kodu "B" (umowa na czas określony) i uzasadnić taki wybór.'@,'RU'))

   |? H_UM.RU().K='B' & _dt<=H_UM.OD & H_UM.WYM_UZAS='T'
   || {? (_chk:=__CHK.record(H_UM,_silent,'OKR_UZAS','UZASDN'))<>''
      || return(_chk)
      |? _max:=500;
         _ilosc:=+H_UM.memo_txt(,0,'UZASDN');
         _ilosc>_max
      || return(_fret(
            'Liczba znaków wprowadzonego tekstu uzasadnienia: %1.\n'
            'Dopuszczalna liczba znaków tekstu uzasadnienia: %2.\n'
            'Należy zmodyfikować odpowiedno treść uzasadnienia.'
            [$_ilosc,$_max], 'UZASDN'))
      ?}
   ?}
?};

{? _f_zatr='P' & exec('upgrade2226_nru01','wnioski_urlopowe')
|| {? H_UM.RU().K='A' & H_UM.ZAM_ZAW='T' & ~+(form(H_UM.ZAM_OKR))
   || return(_fret('Nie wypełniono pola "Planowany okres".'@,'ZAM_OKR'))
   ?}
?};

_par_392:=PAR_SKID.get(392);
{? _par_392<>'N' & exec('h_um_ru_zastepstwo','pracownik') & H_UM.P_ZAS=null
:: brak zasępowanego pracownika dla umowy na zastępstwo
|| {? ~_batch
   || {? _par_392='T'
      || FUN.emsg(
            'Dla umowy zawieranej na czas określony w celu zastępstwa pracownika\n'
            'w czasie jego usprawiedliwionej nieobecności w pracy należy wskazać\n'
            'zastępowanego pracownika.'@
         );
         exec('zastepstwo','pracownik')
      |? FUN.ask(
            'Dla umowy zawieranej na czas określony w celu zastępstwa pracownika\n'
            'w czasie jego usprawiedliwionej nieobecności w pracy powinien być\n'
            'wskazany zastępowany pracownik.\n\n'
            'Czy przejść do wyboru pracownika?'@
         )
      || exec('zastepstwo','pracownik')
      ?}
   ?};
   {? _par_392='T'
   || return(0)
   ?}
?};

P.cntx_psh();
{? H_UM.P_ZAS<>null & H_UM.P_ZAS().OSOBA=H_UM.P().OSOBA
:: zastępstwo samego siebie
|| {? ~_batch
   || FUN.emsg(
         'Umowa na zastępstwo nie może być zawarta dla tej samej osoby.'@
      );
      exec('zastepstwo','pracownik')
   ?};
   P.cntx_pop();
   return(0)
?};
P.cntx_pop();

: ok
1


\h_mod_pos
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Określa możliwość modyfikacji przebiegu poprzez jego pozycję i zawartość listy przebiegów.
::   WE: _a [REFERENCE/STRING] - Wskazanie przebiegu (ref lub SQL-ref rekordu tabeli H).
::       _b [REFERENCE/STRING] - Wskazanie umowy (ref lub SQL-ref rekordu tabeli H_UM).
::   WY: 0 - jedyny
::       1 - pierwszy
::       2 - pośredni
::       3 - ostatni
::----------------------------------------------------------------------------------------------------------------------
_hnum:=ref_num(_a);
{? _hnum=0
:: Taka sytuacja ma miejsce podczas obsługi akcji "Dołącz". Mimo, że rekordu nie ma jeszcze na dysku (jest tylko w
:: buforze), to merytorycznie możemy uznać, że jest to "jedyny" zapis - stąd zwracana wartość.
|| return(0)
?};
H.cntx_psh();
H.index('HISTUM');
H.prefix(ref_num(_b));
_first:=(H.first() & _hnum=#H.ref());
_last:=(H.last() & _hnum=#H.ref());
_pos:=0;
{? _first<>_last
|| {? _first || _pos:=1
   |? _last || _pos:=3
   ?}
|? ~_first & ~_last
|| _pos:=2
?};
H.cntx_pop();
_pos


\h_od_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2008]
:: OPIS: Przed redagowaniem pola H.OD.
::  OLD: \przed_h_od/umowy.fml
::----------------------------------------------------------------------------------------------------------------------
_h_ref:=H.ref();
_ret:=1;
H.cntx_psh();
H.first();
{? _h_ref<>H.ref()
|| _ret:=1
|? H_UM.prev()
|| H_UM.next();
   _ret:=0
?};
H.cntx_pop();
_ret


\h_przedst_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2008]
:: OPIS: Formuła na wartość początkową pola PRZEDST tabeli H.
::   WY: określenie przedstawiciela pracodawcy
::  OLD: \przedst/umowy.fml
::----------------------------------------------------------------------------------------------------------------------
exec('czytaj','#stalesys',,KST,'PRZEDST');
H.cntx_psh();
H.index('_HISTDAT');
H.prefix(P.ref());
{? ~H.last()
|| _ret:=KST.PRZEDST
|| {? H.DO=date(0,0,0)
   || _ret:=KST.PRZEDST
   || _date:=H.DO+1;
      _ob_przedst:=KST.PRZEDST;
      exec('czytaj','#stalesys',_date,KST,'PRZEDST');
      _ret:=KST.PRZEDST;
      KST.PRZEDST:=_ob_przedst
   ?}
?};
H.cntx_pop();

_ret


\h_wydzial_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KGS [2010]
:: OPIS: Wartość początkowa pola H.WYDZIAL.
::  OLD: \_Pwyd/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
P.WYDZIAL


\h_st_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KGS [2010]
:: OPIS: Wartość początkowa pola H.ST.
::  OLD: \__P_ST/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
P.ST


\h_s1_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Po redagowaniu pola H.S1
::   WE:
::   WY:
::  OLD: \h_s1_ae/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
{? H.S1<0
|| H.S1:=0
?};
exec('h_efld_opt','pracownik')


\h_s2_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Po redagowaniu pola H.S2.
::   WE:
::   WY:
::  OLD: \h_s2_ae/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
{? H.S2<0
|| H.S2:=0
?};
exec('h_efld_opt','pracownik')


\h_s3_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Po redagowaniu pola H.S3.
::   WE:
::   WY:
::  OLD: \h_s3_ae/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
{? H.S3<0
|| H.S3:=0
?};
exec('h_efld_opt','pracownik')


\h_kz_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KGS [2010]
:: OPIS: Wartość początkowa pola H.KZ.
::  OLD: \__Kz/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
H_ZM.cntx_psh();
H_ZM.index('ZMIANY');
H_ZM.prefix('Z');
_wyn:=null();
{? H_ZM.first()
|| _wyn:=H_ZM.ref()
|| H_ZM.blank();
   H_ZM.KZ:='Z';
   H_ZM.R:='przeszeregowanie';
   {? H_ZM.add()
   || _wyn:=H_ZM.ref()
   ?}
?};
H_ZM.cntx_pop();
_wyn


\h_ru_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Wartość początkowa pola H.RU.
::  OLD: \hruwart/umowy.fml
::----------------------------------------------------------------------------------------------------------------------
H_UM.RU


\h_cp_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KGS [2010]
:: OPIS: Wartość początkowa pola H.CP.
::  OLD: \__P_CP/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
P.CP


\h_do_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2008]
:: OPIS: Przed redagowaniem pola H.DO - formuła sprawdza czy można edytować pole H.DO.
::  OLD: \przed_h_do/umowy.fml
::----------------------------------------------------------------------------------------------------------------------
~(H.DO=date(0,0,0) & H.UMOWA().DO=date(0,0,0))


\h_czywal_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Przed wyświetleniem pola H.CZYWAL.
::   WE:
::   WY:
::  OLD: \h_czywal_bd/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
H.S1>0


\h_czywal_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Po redagowaniu pola H.CZYWAL.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('h_efld_opt','pracownik')


\h_czywal2_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Przed wyświetleniem pola H.CZYWAL2.
::   WE:
::   WY:
::  OLD: \h_czywal2_bd/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
H.S2>0


\h_czywal2_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Po redagowaniu pola H.CZYWAL2.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('h_efld_opt','pracownik')


\h_czywal3_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Przed wyświetleniem pola H.CZYWAL3.
::   WE:
::   WY:
::  OLD: \h_czywal3_bd/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
H.S3>0


\h_czywal3_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Po redagowaniu pola H.CZYWAL3.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('h_efld_opt','pracownik')


\h_umowa_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KGS [2010]
:: OPIS: Wartość początkowa pola H.UMOWA.
::  OLD: \__H_UM/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
H_UM.ref()


\h_pozworg_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KO [12.30]
:: OPIS: Wartość początkowa pola H.POZWORG.
::  OLD: \wp_pworg/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
P.POZWORG


\h_s2t_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Przed wyświetleniem pola H.S2T (typ).
::   WE:
::   WY:
::  OLD: \h_s2t_bd/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
H.S2>0


\h_s2t_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Po redagowaniu pola H.S2T (typ).
::   WE:
::   WY:
::  OLD: \h_s2t_ae/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
exec('h_efld_opt','pracownik')


\h_s2p_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Przed wyświetleniem pola H.S2P (podstawa).
::   WE:
::   WY:
::  OLD: \h_s2p_bd/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
H.S2T='P'


\h_s2p_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Przed redagowaniem pola H.S2P (podstawa).
::   WE:
::   WY:
::  OLD: \h_s2p_be/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
{? H.S2>0 & H.S2T='P' || ZMIENNE.RODZAJ:='P'; 1 ?}


\h_s3t_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Przed wyświetleniem pola H.S3T (typ).
::   WE:
::   WY:
::  OLD: \h_s3t_bd/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
H.S3>0


\h_s3t_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Po redagowaniu pola H.S3T (typ).
::   WE:
::   WY:
::  OLD: \h_s3t_ae/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
exec('h_efld_opt','pracownik')


\h_s3p_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Przed wyświetleniem pola H.S3P (podstawa).
::   WE:
::   WY:
::  OLD: \h_s3p_bd/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
H.S3T='P'


\h_s3p_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.30]
:: OPIS: Przed redagowaniem pola H.S3P (podstawa).
::   WE:
::   WY:
::  OLD: \h_s3p_be/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
{? H.S3>0 & H.S3T='P' || ZMIENNE.RODZAJ:='P'; 1 ?}


\h_pmp_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Po redagowaniu pola H.PMP.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('h_efld_opt','pracownik')


\h_wyx_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK
:: OPIS: Po redagowaniu pól tabeli H, związanych z wymiarem zatrudnienia (część wspólna).
::   WE:
::   WY:
::  OLD: \akt_wymd/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
H.RWY:={? H.RWYM || (H.RWYL/H.RWYM)$3 ?};
{? H.MAC<>'T'
|| H.WY:=H.RWY;
   H.WYM:=H.RWYM;
   H.WYL:=H.RWYL
|| H.WY:={? H.WYM || (H.WYL/H.WYM)$3 ?}
?}


\h_mac_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.30]
:: OPIS: Weryfikacja znacznika czy na urlopie macierzyńskim.
::  OLD: \_H_mac_v/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
exec('h_wyx_ae','pracownik');
exec('h_efld_opt','pracownik')


\h_wyl_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KGS [2010]
:: OPIS: Po redagowaniu pola H.WYL - licznika wymiaru zatrudnienia.
::  OLD: \_Hwyl/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
exec('h_wyx_ae','pracownik');
fld>=1 & fld<999


\h_wym_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KGS [2010]
:: OPIS: Po redagowaniu pola H.WYM - mianownika wymiaru zatrudnienia.
::  OLD: \_Hwym/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
exec('h_wyx_ae','pracownik');
fld>=1 & fld<=999


\h_rwyl_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.30]
:: OPIS: Po redagowaniu pola H.RWYL - licznika wymiaru rzeczywistego.
::  OLD: \_Hrwyl/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
exec('h_wyx_ae','pracownik');
exec('h_efld_opt','pracownik');
fld()>=1 & fld()<999


\h_rwym_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.30]
:: OPIS: Po redagowaniu pola H.RWYM - mianownika wymiaru rzeczywistego
::  OLD: \_Hrwym/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
exec('h_wyx_ae','pracownik');
exec('h_efld_opt','pracownik');
fld()>=1 & fld()<=999


\h_dop_nadg_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.41]
:: OPIS: Przed wyświetleniem pól: H.DOP_NADG.
::   WE:
::   WY:
::  OLD: \czy_dop_nadg/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
H.CZY_NADG='T'


\h_czy_nadg_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Po redagowaniu pola H.CZY_NADG.
::   WE:
::   WY:
::  OLD: \h_czynadg_ae/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
exec('h_efld_opt','pracownik')


\h_pat_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Po redagowaniu pola H.PAT.
::   WE:
::   WY:
::  OLD: \h_pat_ae/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
exec('h_efld_opt','pracownik')


\h_paw_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.41]
:: OPIS: Przed wyświetleniem pola H.PAW.
::   WE:
::   WY:
::  OLD: \h_paw_bd/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
H.PAT='K' | H.PAT='P'


\h_paw_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.41]
:: OPIS: Po redagowaniu pola H.PAW.
::   WE:
::   WY:
::  OLD: \h_paw_ae/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
{? H.PAW<0
|| H.PAW:=0
?};
1


\h_zwal_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Przed wyświetleniem pola H.ZWAL
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
(H.S1>0 & H.CZYWAL='T') | (H.S2>0 & H.CZYWAL2='T') | (H.S3>0 & H.CZYWAL3='T') | (H.S4>0 & H.CZYWAL4='T')


\h_zwal_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Formuła po edycji pola ZWAL w tabeli H.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? H.ODDEL='T' & H.ZWAL & ~H_ODDE.TKRS
|| H_ODDE.TKRS:=H.ZWAL
?};
1


\h_wal_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Przed wyświetleniem pola H.WAL.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
(H.S1>0 & H.CZYWAL='T') | (H.S2>0 & H.CZYWAL2='T') | (H.S3>0 & H.CZYWAL3='T') | (H.S4>0 & H.CZYWAL4='T')


\edit_var_h_wyd_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przed wyświetleniem EDIT_VAR.H_WYD
::  OLD: \wyd_bl/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
EDIT_VAR.H_WYD:=H.WYDZIAL().SYMBOL


\edit_var_h_wyd_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przed redagowaniem EDIT_VAR.H_WYD
::  OLD: \wyd_lck/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
EDIT_VAR.H_WYD:=EDIT_VAR.H_WYD_B:=H.WYDZIAL().SYMBOL;
1


\edit_var_h_wyd_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Po redagowaniu EDIT_VAR.H_WYD
::   WE: _a - (opcjonalny) symbol dziedziny
::  OLD: \wyd_spr/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_dom:={? var_pres('_a')=type_of('') & _a<>'' || _a || '' ?};
H.WYDZIAL:=exec('ud_skl_symbol_ae','schemat','PODZORG',_dom);
{? EDIT_VAR.H_WYD_B<>H.WYDZIAL().SYMBOL
|| H.ST:=EDIT_VAR.H_ST:=null();
   H.POZWORG:=EDIT_VAR.H_PSTO:=null()
?};
1


\edit_var_h_st_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przed wyświetleniem EDIT_VAR.H_ST
::  OLD: \stn_bl/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
EDIT_VAR.H_ST:=exec('szukaj_sto','stanprac',H.WYDZIAL,H.ST)


\edit_var_h_st_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przed redagowaniem EDIT_VAR.H_ST
::  OLD: \stn_lck/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
EDIT_VAR.H_ST_B:=EDIT_VAR.H_ST;
EDIT_VAR.H_WYD<>''


\edit_var_h_st_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Po redagowaniu EDIT_VAR.H_ST
::  OLD: \stn_spr/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
H.ST:=EDIT_VAR.H_ST().STN;
{? H.ST & EDIT_VAR.H_ST_B<>EDIT_VAR.H_ST
|| H.SP:={? H.ST().SP='T' & OSOBA.UR_DATA>date(1948,12,31) || 'T' || 'N' ?}
?};
{? EDIT_VAR.H_ST_B<>EDIT_VAR.H_ST
|| H.POZWORG:=EDIT_VAR.H_PSTO:=null()
?};
1


\edit_var_h_psto_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przed wyświetleniem EDIT_VAR.H_PSTO
::  OLD: \pw_psto/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_sto:=exec('szukaj_sto','stanprac',H.WYDZIAL,H.ST);
EDIT_VAR.H_PSTO:=exec('szukaj_psto','stanprac',_sto,H.POZWORG)


\edit_var_h_psto_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Przed redakcją EDIT_VAR.H_PSTO
::  OLD: \pr_psto/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
EDIT_VAR.H_ST<>null()


\edit_var_h_psto_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Po redakcji EDIT_VAR.H_PSTO
::  OLD: \po_psto/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
H.POZWORG:=EDIT_VAR.H_PSTO().POZWORG;
1


\mod_ae_ret_val
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Sparawdza, czy pole jest formułowo dostępne do edycji.
::   WE: _a [TABLE] - alias tabeli
::       _b [STRING] - akronim pola
::   WY: _b - jeśli pole jest dostępne do edycji
::       0 - jeśli formuła przed edycją pola zwróci 0
::----------------------------------------------------------------------------------------------------------------------
{? type_of(_b)=type_of('') & var_pres(_b,_a)>0
|| _test:=_a.fld_fml(_b,'*BEFORE_EDIT')();
   {? type_of(_test)<>type_of(0) | _test
   || _b
   ?}
|| _b
?}


\h_p_com_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Część wspólna dla formuł sprawdzających poprawność danych w przebiegu zatrudnienia
::   WE:  _a  [NUMBER]  - tryb edycji: 0 - dodawanie, 1 - poprawianie
::       [_b] [NUMBER]  - tryb wsadowy:
::                      0 - Nie [domyślnie];
::                      1 - Tak - brak interakcji, komunikatów, ... .
::       [_c]  [STRING] - lista pól (akronimy oddzielone przecinkami), honorowane akronimy: POZWORG
::   WY: Dla trybu wsadowego treść komunikatu błędu lub ''.
::       W przeciwnym wypadku - zgodny ze specyfikacją wymagań dla formuły typu rekord po.
::  OLD: \spr_hum/umowy.fml
::  OLD: \spr_h/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_edit:=_a;
_batch:=(var_pres('_b')=type_of(0) & _b);
_skip:={? var_pres('_c')=type_of('') || ','+_c+',' || '' ?};
_silent:={? _batch || 1 || ~~ ?};
{? _batch
|| _fret1:="_a";
   _fret2:="__CHK.empty_msg(MS.name(H,_a))"
|| _fret1:="FUN.emsg(_a); _b";
   _fret2:="_a"
?};

: wylicz wymiar zatrudnienia
exec('h_wyx_ae','pracownik');

_f_zatr:=exec('dest','f_zatr',P.F_ZATR,'KOD');
{? _f_zatr='Z'
|| H.PRZYG:=H.PODPIS:=H.OD
?};

: sprawdź bezwzględnie wymagane informacje
{? (_chk:=__CHK.record(H,_silent,'OD'))<>''
|| return(_fret2(_chk))

|? _f_zatr='P' & (_chk:=__CHK.record(H,_silent,'PRZYG'))<>''
|| return(_fret2(_chk))

|? (_chk:=__CHK.record(H,_silent,'PODPIS','PRZEDST','WYDZIAL'))<>''
|| {? _batch
   || return(_fret2(_chk))
   || {? _chk='WYDZIAL'
      || return('H_WYD')
      ?};
      return(_chk)
   ?}

|? H.ST=null()
|| _msg:=
      {? _f_zatr='P'
      || __CHK.empty_msg(MS.name(H,'ST'),1)
      || __CHK.empty_msg('Pełnione obowiązki'@,1)
      ?};
   {? _batch
   || return(_msg)
   || FUN.emsg(_msg);
      return('H_ST')
   ?}

|? H.DO<>date(0,0,0) & H.DO<H.OD
|| return(_fret1('"%1" nie może być późniejsza niż "%2".'@ [MS.name(H,'OD'),MS.name(H,'DO')],'OD'))
?};

: Weryfikacja stanowiska i (w określonych warunkach) pozycji w jednostce organizacyjnej.
: Warunki nadmiarowe dla redagowania w oknie, ale potrzebny np. przy grupowej aktualizacji zatrudnienia.
STO.cntx_psh();
STO.index('UNIQUE');
STO.prefix(H.WYDZIAL,H.ST);
_sto:={? STO.first() || STO.ref() || null() ?};
STO.cntx_pop();
{? _sto=null()
|| return(_fret1('Brak stanowiska "%1" w jednostce organizacyjnej "%2".'@ [H.ST().ST,H.WYDZIAL().SYMBOL],'H_ST'))
?};
: podział ze względu na kolejność walidacji
: uwaga na włączenie parametru 313 w trakcie życia programu z włączonym parametrem 180
: walidacja wiersza w transakcji pomija pozycję w organizacji (zakleszczenie wycofaj/akceptuj)
{? {? PAR_SKID.get(180)='T' || do_state()=0 || 1 ?} &
   (_skip*',POZWORG,')=0 & PAR_SKID.get(313)='T'
|| {? (_chk:=__CHK.record(H,_silent,'POZWORG'))<>''
   || {? _batch
      || return(_fret2(_chk))
      || return('H_PSTO')
      ?}
   || PSTO.cntx_psh();
      PSTO.index('PSTO');
      PSTO.prefix(_sto,H.POZWORG);
      _ok:=PSTO.first();
      PSTO.cntx_pop();
      {? ~_ok
      || return(_fret1('Nieprawidłowa pozycja w organizacji.'@,'H_PSTO'))
      ?}
   ?}
?};
: ciąg dalszy sprawdzania wymaganych danych
{? (_chk:=__CHK.record(H,_silent,'CP','MIEJSCE'))<>''
|| return(_fret2(_chk))
?};

_f_zatr:=exec('dest','f_zatr',P.F_ZATR,'KOD');
{? _f_zatr='P'
: Poniżej sprawdzane są pola charakterystyczne dla pracownika.
|| {? H.ODDEL<>'T' & (_chk:=__CHK.record(H,_silent,'S1'))<>''
   || return(_fret2(_chk))
   ?};

   {? H.ODDEL<>'T' & H.S1<=0
   || return(_fret1('Wartość pola "%1" musi być dodatnia.'@ [MS.name(H,'S1')],'S1'))
   ?};

   {! _lp:=2 .. 4
   |! {? ($('H.S'+$_lp))()<0
      || return(_fret1('Wartość pola "%1" nie może być ujemna.'@ [MS.name(H,'S'+$_lp)],'S'+$_lp))
      ?}
   !};

   {? (_chk:=exec('h_p_daty_ae','pracownik',_edit,_batch))<>''
   || return(_chk)
   ?};

   {? H.SP='T' & H.ST().SP<>'T'
   || H.SP:='N';
      return(_fret1('Praca w szczególnych warunkach lub charakterze nie jest możliwa na wybranym stanowisku.'@,'SP'))
   ?}
?};

: Wymiar dotyczy wszystkich.
{? H.RWY>1
|| return(_fret1('Wymiar zatrudnienia nie może przekraczać jednego etatu.'@,'RWYL'))
?};

: Pozostałe testy dotyczą jedynie formy współpracy P.
{? _f_zatr<>'P'
|| return('')
?};

{? H.MAC='T' & (H.WYL>0 & H.WYM>0 & (H.WYL/H.WYM)$3>0.5)
|| return(_fret1('Maksymalny wymiar czasu pracy w trakcie urlopu wynosi 1/2 etatu.'@,'WYL'))
?};

{? H.RWY<1 & H.CZY_NADG='T'
|| {? H.DOP_NADG<0
   || return(_fret1('"Dopełnienie ponad wymiar" nie może być mniejsze niż 0 godzin.'@,'DOP_NADG'))
   |? H.RWY*8+H.DOP_NADG>8
   || return(_fret1('"Wymiar zatrudnienia" i "Dopełnienie ponad wymiar" nie mogą być większe niż 8 godzin.'@,
         'DOP_NADG'))
   |? H.DOP_ST<0
   || return(_fret1('"Dopełnienie średniotygodniowe" nie może być mniejsze niż 0 godzin.'@,'DOP_ST'))
   |? H.DOP_ST>40
   || return(_fret1('"Dopełnienie średniotygodniowe" nie może być większe niż 40 godzin.'@,'DOP_ST'))
   ?}
?};

{? (H.S1>0 & H.CZYWAL='T') | (H.S2>0 & H.CZYWAL2='T') | (H.S3>0 & H.CZYWAL3='T') | (H.S4>0 & H.CZYWAL4='T')
|| {? (_chk:=__CHK.record(H,_silent,'ZWAL','WAL'))<>''
   || return(_fret2(_chk))
   ?};
   {? H.WAL=KST_PAR.NAROD
   || return(_fret1('Waluta musi być różna od waluty narodowej (%1).'@ [KST_PAR.NAROD().KOD],'WAL'))
   ?}
?};

{? (_batch | H.S2>0) & H.S2T='P' & (_chk:=__CHK.record(H,_silent,'S2P'))<>''
|| return(_fret2(_chk))
|? (_batch | H.S3>0) & H.S3T='P' & (_chk:=__CHK.record(H,_silent,'S3P'))<>''
|| return(_fret2(_chk))
?};

{? H.S2>0 & H.S2T='P' & H.S2P().SKROT='HS1' & H.CZYWAL<>H.CZYWAL2
|| return(_fret1('Brak zgodności waluty Dodatku funkcyjnego i Płacy zasadniczej.'@,'CZYWAL'))

|? H.S3>0 & H.S3T='P' & H.S3P().SKROT='HS1' & H.CZYWAL<>H.CZYWAL3
|| return(_fret1('Brak zgodności waluty Dodatku i Płacy zasadniczej.'@,'CZYWAL3'))

|? ~_batch & ((H.S2>0 & H.S2T='P' & H.CZYWAL<>H.CZYWAL2) | (H.S3>0 & H.S3T='P' & H.CZYWAL<>H.CZYWAL3))
|| _ff:="'\n'+form(_a,35)+' '+form(_b,14,2)+' '+form({? _c='T' || H.WAL().KOD || 'PLN' ?},5)";
   _txt:='Kwoty nominalne wynikające z warunków zatrudnienia:'@;
   _txt+=_ff('Płaca zasadnicza'@,H.S1,H.CZYWAL);
   {? H.S2>0
   || _txt+=_ff('Dodatek funkcyjny'@,{? H.S2T='P' || H.S2*($H.S2P().FORMULA)(H.OD)/100$2 || H.S2 ?},H.CZYWAL2)
   ?};
   {? H.S3>0
   || _txt+=_ff('Dodatek'@,{? H.S3T='P' || H.S3*($H.S3P().FORMULA)(H.OD)/100$2 || H.S3 ?},H.CZYWAL3)
   ?};
   &_ff;
   _txt+='\n\nNależy zwrócić szczególną uwagę na różnicę w walutach.\n'@;
   _txt+='Czy na pewno zatwierdzić podane warunki?'@;
   {? ~FUN.ask(&_txt)
   || return(0)
   ?}
?};

{? H.PAT='K' | H.PAT='P'
|| {? (_chk:=__CHK.record(H,_silent,'PAW'))<>''
   || return(_fret2(_chk))
   |? H.PAT='P' & H.PAW>100
   || return(_fret1('Wartość pola "%1" nie może być większa niż 100%%.'@ [MS.name(H,'PAW')],'PAW'))
   ?};
   {? H.PAT='K'
   || {? 1+H.CP().S='U'
      || {? H.PAW>H.S1
         || return(_fret1('Wartość przychodu z praw autorskich nie może być większa niż płaca zasadnicza.'@,'PAW'))
         ?}
      ||
:        Ze względu na różną liczbę godzin w różnych miesiącach sprawdzenie dla pracowników ze stawką godzinową
:        nie może być tak dokładne jak dla pracowników ze stawką miesięczną. Dlatego przyjmijmy średnią liczbę godzin
:        do przepracowania (na podstawie współczynnika do ekwiwalentu), pamiętając o tym, że:
:           1. Decyzja i tak należy do operatora.
:           2. Na liście i tak jest ograniczenie.
         {? ~_batch & H.PAW>=(H.S1*KST.EKW*8*H.WY)$2 & FUN.ask(
               'Kwota wynagrodzenia z praw autorskich może przewyższać wynagrodznia całkowitego.\n'@+
               'Czy na pewno zatwierdzić podane warunki?'@
            )=0
         || return('PAW')
         ?}
      ?}
   ?}
?};

{? (_chk:=__CHK.record(H,1,'OS_ADRES'))<>''
|| return(_fret1(__CHK.empty_msg('Miejscowość'@,~_batch),_chk))
?};

''


\h_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Sprawdza poprawność wypełnienia danych nowego przebiegu.
::   WE:  _a  [NUMBER] - tryb modyfikacji zapisu: 0 - dodawanie, 1 - poprawianie
::       [_b] [NUMBER] - tryb wsadowy (bez komunikatów): 0 - nie [domyślnie], 1 - tak
::  OLD: \spr_h/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_popraw:=_a;
_batch:=var_pres('_b')=type_of(0) & _b;

: sprawdź poprawność przebiegu zatrudnienia
_chk:=exec('h_p_com_ae','pracownik',_popraw,_batch);
{? (type_of(_chk)=type_of('') & _chk<>'') | (type_of(_chk)=type_of(0) & _chk<>0)
|| return(exec('mod_ae_ret_val','pracownik',H,_chk))
?};

{? _batch
|| _fret:="_a"
|| _fret:="
      FUN.emsg(_a);
      exec('mod_ae_ret_val','pracownik',H,_b)
   "
?};

{? {? _popraw || H.OD<H_UM.OD || H.OD<=H_UM.OD ?} | (H_UM.DO<>date(0,0,0) & H_UM.DO<H.OD)
|| _od:=MS.name(H,'OD');
   {? H_UM.DO<>date(0,0,0)
   || return(_fret('"%1" musi być w zakresie od %2 do %3.'@[_od,$H_UM.OD,$H_UM.DO],'OD'))
   || return(_fret('"%1" musi byc późniejsza od %2.'@[_od,$H_UM.OD],'OD'))
   ?}

|? (H.DO<>date(0,0,0) & H.DO<H_UM.OD) | (H_UM.DO<>date(0,0,0) & H_UM.DO<H.DO)
|| _do:=MS.name(H,'DO');
   {? H_UM.DO<>date(0,0,0)
   || return(_fret('"%1" musi być w zakresie od %2 do %3.'@[_do,$H_UM.OD,$H_UM.DO],'DO'))
   || return(_fret('"%1" nie może być późniejsza od %2.'@[_do,$H_UM.DO],'DO'))
   ?}
?};

{? _popraw
|| VAR.H:=H.ref()
|| H.cntx_psh();
   H.index('_HISTKOD');
   H.prefix(H.P,'Z');
   VAR.H:={? H.last() || H.ref() ?};
   H.cntx_pop()
?};
exec('h','overlap')


\h_p_daty_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Część wspólna dla formuł sprawdzających poprawność danych w przebiegu zatrudnienia.
::       Weryfikuje poprawność dat: przygotowania i zawarcia umowy/aneksu w przebiegu zatrudnienia lub wskazanej tabeli.
::   WE: _a - tryb edycji:
::          0 - dodawanie,
::          1 - poprawianie
::       _b - tryb wsadowy:
::          0 - Nie [domyślnie];
::          1 - Tak - brak interakcji, komunikatów, ... .
::       _c - alias do tabeli, której dane będą sprawdzane
::   WY: Dla trybu wsadowego treść komunikatu błędu lub ''.
::       W przeciwnym wypadku - zgodny ze specyfikacją wymagań dla formuły typu rekord po.
::  OLD: \spr_hum/umowy.fml
::  OLD: \spr_h/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
:: UWAGA zakłada się, że tabela wskazana aliasem zawiera kolumny: OD, PRZYG, PODPIS
::
_edit:=_a;
_batch:=(var_pres('_b')=type_of(0) & _b);
_table:={? var_pres('_c')=type_of(SYSLOG) || _c || H ?};

_silent:={? _batch || 1 || ~~ ?};

{? (_chk:=__CHK.record(_table,_silent,'OD','PRZYG','PODPIS'))<>''
|| return({? _batch || __CHK.empty_msg(MS.name(_table,_chk)) || _chk ?})

|? _table.PODPIS<_table.PRZYG
|| _txt:='"%1" nie może być późniejsza niż "%2".'@ [MS.name(_table,'PRZYG'),MS.name(_table,'PODPIS')];
   {? _batch
   || return(_txt)
   || FUN.emsg(_txt);
      return('PRZYG')
   ?}

|? ~_batch & _table.OD<_table.PODPIS & ~FUN.ask(
      '"%1" jest późniejsza niż "%2".\n'@ [MS.name(_table,'PODPIS'),MS.name(_table,'OD')]+
      'Czy na pewno zapisać podane daty?'@
   )
|| return('PODPIS')
?};

: ok
''


\norm_h_oddo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Normalizuje zapisy w przebiegu zatrudnienia pod kątem ich ciągłości.
::  OLD: /histoddo.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=H.ref();

H.cntx_psh();
H.index('HISTUM');
H.prefix(H.UMOWA);

H.cntx_psh();
_data:=H.OD-1;
: przesuń koniec poprzedniego przebiegu
{? H.prev() & H.DO<>_data
|| H.DO:=_data;
   H.put()
?};
H.cntx_pop();

{? H.DO<>date(0,0,0)
|| _data:=H.DO+1;
:  przesuń początek następnego przebiegu
   {? H.next() & H.OD<>_data
   || H.OD:=_data;
      H.put()
   ?}
?};

{? H.last()
:  normalizacja wszystkich zapisów w ramach umowy
|| {? H.DO<>H_UM.DO
   || H.DO:=H_UM.DO;
      H.put()
   ?};
   {!
   |? _data:=H.OD-1;
      H.prev()
   |! {? H.ref()<>_ref & H.DO<>_data
      || H.DO:=_data;
         H.put()
      ?}
   !};
   {? H.OD<>H_UM.OD
   || H.OD:=H_UM.OD;
      H.put()
   ?}
?};

H.cntx_pop()


\x_od_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [KGS] [2011]
:: OPIS: Wartość początkowa pola OD dla tabel związanych z P, przy pustej dziedzinie. Formuła wymaga aby prawidłowo
::       ustawione były:
::        - bufor tabeli P;
::        - indeksy i prefiksy redagowanej tabeli.
::  OLD: \datakali/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
_ret:=date();

OSOBA.cntx_psh();
OSOBA.prefix();
_kali:=OSOBA.KALI='T';
OSOBA.cntx_pop();

{? _kali & type_of(cur_tab(1,1))=type_of(P) & cur_tab(1,1).size()=0
|| {? P.OSOBA=OSOBA.ref()
   || _ret:=P.DZA
   || P.cntx_psh();
      P.index('PRACOSOB');
      P.prefix(exec('ref_firma','ustawienia'),__F_ZATR.P,OSOBA.ref());
      {? P.first()
      || _ret:=P.DZA
      ?};
      P.cntx_pop()
   ?}
?};
_ret


\test_p_ip
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Sprawdzenie unikalności identyfikatora pracownika.
::   WE: _a - tryb edycji: 0 - dodawanie, 1 - poprawianie
::       _b - 1 - wyłączone pytanie o generowanie identyfikatora
::----------------------------------------------------------------------------------------------------------------------
_ref:=${? _a || P.ref() || null() ?};
_ip:=P.IP;

_TAB:=exec('prac_ip','pracownik',P.F_ZATR().KOD);
: Funkcja zwraca tabelę z dwoma polami, IP i REF. Tabela budowan jest na podstawie tabel P i SLO_OSOB - widać to
: właśnie w polu REF. Z pomocą przychodzi nam indeks (po obu polach) i alfabet ("pracown?" jest przed "sl_osoba").
: Jeżeli bieżąca funkcja jest wykonywana dla istniejącego rekordu tabeli P, to dopuiszczalne jest występowanie
: "bieżącego" IP w tabeli _TAB, ale wyłącznie wówczas, gdy dotyczy "bieżącego" rekordu tabeli P.

{? _ip=0 | (_TAB.find_key(_ip) & _TAB.REF<>_ref)
|| {? {? var_pres('_b')<>type_of(0) | ~_b
      || FUN.ask(
            'Identyfikator pracownika ma nieunikalną wartość.\n'
            'Czy wygenerować poprawny identyfikator?'@
         )
      || 1
      ?}
   ||
      _kod_zatr:='KPRTZ';
      {? _kod_zatr*P.F_ZATR().KOD
      || params_set('KOD', P.F_ZATR().KOD);
         _plg_ip:=Plugin.run('PKD_P_IP_001');
         {? _plg_ip<>-1
         || _ip:=_plg_ip
         || {! _lp:=1 |? _TAB.find_key(_lp) !};
         _ip:=_lp
         ?}
      || {! _lp:=1 |? _TAB.find_key(_lp) !};
         _ip:=_lp
      ?}
   ?}
?};

P.IP:=_ip


\pracownik_sprawdz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Sprawdza poprawność danych osoby i pracownika.
::   WY: zgodne ze specyfikacją dla akcji "rekord po" tabeli
::  OLD: \spr_prac/kali.fml
::----------------------------------------------------------------------------------------------------------------------
: sprawdzenie danych osobowych pracownika
_chk:=exec('osoba_sprawdz','osoba');
{? (type_of(_chk)=type_of('') & _chk<>'') |
   (type_of(_chk)=type_of(0) & _chk=0)
|| return(_chk)
?};

: weryfikacja identyfikatora
exec('test_p_ip','pracownik',1,0);

: docelowa forma zatrudnienia:
_fZatr:=exec('dest','f_zatr',P.F_ZATR,'KOD');

P.T:=|P.T;
: weryfikacja zapisu
_chk:=__CHK.table(P,1,
   {? _fZatr='Z' || 1 || ~~ ?},
   'T','IP',
   {? 'KTR'*_fZatr || '' || 'ZAW' ?},
   {? exec('is_active','gp_api') || 'GP_DEF' || '' ?},
   {? _fZatr='Z' || 'ODDZIAL' || '' ?}
);
_kont:=0;
{? type_of(_chk)<>type_of(0) | ~_chk
:: Sprawdzenie wypełnienia kodu wykonywanego zawodu z możliwością przejścia dalej (dla umów o dzieło):
|| {? _fZatr='Z' & type_of(_chk)=type_of('') & _chk='ZAW'
   || {? FUN.ask('Nie wypełniono zawodu wykonywanego.\nCzy kontynuować?'@)
      || _kont:=1;
         _chk:=''
      ?}
   ?};
   {? ~_kont || return(_chk) ?}
?};

: weryfikacja długości pola zawód wykonywany:
{? ~_kont & ~('KTR'*_fZatr)
|| _zaw:=exec('zaw','rap_zus',1);
   {? ~+_zaw
   || FUN.emsg('Błędna długość kodu zawodu wykonywanego (powinien mnieć 6 znaków).'@);
      return('ZAW')
   ?}
?};

_chk


\pracownik_aktualizuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Aktualizuje dane pracownika na podstawie wskazanych parametrem elementów systemu.
::   WE: [_a] [STRING] - Zakres aktualizacji: napis, którego elementami są kody akcji oddzielone przecinkami.
::                         H     - aktualizacja na podstawie tabeli H [domyślnie];
::                         P_KK  - aktualizacja na podstawie P_KK.
::   WY:  1 - Aktualizacja była potrzebna i została wykonana.
::        0 - Aktualizacja nie była potrzebna.
::       -1 - Aktualizacja była potrzebna, ale nie została wykonana.
::  OLD: /wkupdate.fml
::----------------------------------------------------------------------------------------------------------------------
:: Zbiór informacji dla wtyczki PKD_P_AKTUALIZUJ:
_plugPar:=obj_new('AKCJE','H_UM_F','H_UM_L','H_Z','H_B','P_KK');
_plugPar.H_UM_F:=_plugPar.H_UM_L:=_plugPar.H_Z:=_plugPar.H_B:=_plugPar.P_KK:=null();

_akcje:=
   {? var_pres('_a')<>type_of('') | _a=''
   || 'H%1'[{? exec('is_active','gp_api') || ',P_GP' || '' ?}]
   || form(_a)
   ?};
_akcje:=_plugPar.AKCJE:=','+gsub(_akcje,' ','')+',';

_ret:=0;

P.cntx_psh();
P.clear();
P.get();
_crc:=P.crc();

{? _akcje*',H,'
|| F_ZATR.cntx_psh();
   F_ZATR.prefix();

   H.cntx_psh();
   H.use('_his'+{? P.F_ZATR().DOCELOWA='T' || 't' || '_' ?});

   P.POZWORG:=null();
   P.CP:=null();
   P.ST:=P.WY:=0;
   P.DZA:=P.CO:=P.DZ:=P.DZM:=P.DH:=date(0,0,0);

   H_UM.cntx_psh();
   exec('otworz_h_um','pracownik',exec('h_um_name','pracownik'));
   H_UM.index('OD');
   H_UM.prefix(P.ref());
:  data zatrudnienia
   {? H_UM.first()
   || _plugPar.H_UM_F:=H_UM.ref();
      P.DZA:=H_UM.OD
   ?};
:  data zwolnienia
   {? H_UM.last()
   || _plugPar.H_UM_L:=H_UM.ref();
      P.DZ:=H_UM.DO;
      P.USPKOD:=H_UM.USPKOD
   ?};
   H_UM.cntx_pop();
   exec('otworz_h_um','pracownik');

:  bieżący angaż
   H.index('_HISTKOD');
   H.prefix(P.ref(),'Z');
   {? H.find_le(date()) | H.first()
   || _plugPar.H_Z:=H.ref();
      P.WYDZIAL:=H.WYDZIAL;
      P.POZWORG:=H.POZWORG;
      P.ST:=H.ST;
      P.CP:=H.CP;
      P.WY:=H.RWY;
      P.DZM:=H.OD;
      P.ODDEL:=H.ODDEL;
      {? Plugin.runnable('PKD_P_H_SYNC')
      || Plugin.run('PKD_P_H_SYNC',H.ref(),P.ref())
      ?}
   ?};

   H.index('_HISTRUM');
   H.prefix(P.ref,'B');
   {? H.last()
   || _plugPar.H_B:=H.ref();
      P.CO:=H.DO
   ?};

   H.cntx_pop();

:  zatrudnienie
   {? P.F_ZATR().DOCELOWA='N'
   || P.ZA:='N'

   |? P.DZA>date()
   || P.ZA:='N'

   |? P.DZ=date(0,0,0) | P.DZ>=date()
   || P.ZA:={? P.DZA<=date() || 'T' || 'N' ?}

   || P.ZA:='N'
   ?};

   F_ZATR.cntx_pop()
?};

{? _akcje*',P_KK,'
|| P_KK.cntx_psh();
   P_KK.index('OD');
   P_KK.prefix(P.ref());
   {? P_KK.find_le(date())
   || _plugPar.P_KK:=P_KK.ref();
      _nkk:=P_KK.KK
   || _nkk:=null()
   ?};
   {? P.KK<>_nkk
   || P.KK:=_nkk
   ?};
   P_KK.cntx_pop()
?};

{? _akcje*',P_GP,'
|| P_GP.cntx_psh();
   P_GP.index('OD');
   P_GP.prefix(P.ref());
   {? P_GP.find_le(date()) & P.GP_DEF<>P_GP.GP_DEF
   || P.GP_DEF:=P_GP.GP_DEF
   ?};
   P_GP.cntx_pop()
?};

{? Plugin.runnable('PKD_P_AKTUALIZUJ')
|| Plugin.run('PKD_P_AKTUALIZUJ',_plugPar)
?};

{? _crc<>P.crc()
|| _ret:={? P.put() || 1 || -1 ?}
?};

:: UWAGA: metoda uidref() podczytuje rekord z dysku!
{? do_state()<2 & exec('lic','#b_domain','POR')
||
:: Aktualizacja "potencjalnych beneficjentów" / odbiorców elementu bazy wiedzy / odbiorców biuletynu / ...
   exec('p2bipodb_update','portal_bip',P.uidref());
:: Dezaktywacja konta.
   exec('dezaktywuj_konto','pracownik',P.uidref());
:: Aktualizacja kalendarzy na następny rok (tylko jeżeli pracownik jeszcze nie ma ich wysłanych na portal
   exec('update4PnextYear','pkalsync',P.ref());
:: Aktualizacja danych ubezpieczeniowych (tylko jeżeli w dniu sprawdzenia następuje zmiana dancyh ubezpieczeniowych)
   exec('p_info_check4portal','osoba',P.OSOBA)
?};
P.cntx_pop();
:: Metoda get() może się nie powieść ze względu na ewentualne ograniczenie dziedziny, ale nie przeszkadza nam to.
P.get();
obj_del(_plugPar);

:  !!! aktualizacja widoku zależności służbowych - do usunięcia (?)
:  {? _wydzial<>P.WYDZIAL | _stan<>P.ST | _pozworg<>P.POZWORG
:  || exec('akt_prac','stanprac');
:     {? __F_ZATR.control(0,'P') || exec('akt_p','projekty') ?}
:  ?};
_ret


\filtr_firma
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Nakłada filtr na tabelę P. Dziedzina zostaje ograniczona do wierszy właściwych dla ustawionej
::       firmy. W uzasadnionych przypadkach należy zastąpić użycie P.f_clear() wywołaniem tej formuły.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
P.clear();
P.f_set(,,'P.FIRMA=:_a',exec('ref_firma','ustawienia'))


\opis
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Formuła dla bieżącego rekordu tabeli P zwraca opis zadania.
::   WE:  _a  [STRING] - Tekst opisujący czynność.
::       [_b] [STRING] - Wariant opisu:
::                      ''          - Opis standardowy (wynikający z reprezentacji tekstowej) [domyślnie].
::                      'NITJOST'   - Nazwisko, Imię, Teczka, Jednostka organizacyjna, Stanowisko.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_desc:=_a;
_mode:={? var_pres('_b')=type_of('') || _b || '' ?};

{? _mode='NITJOST'
|| OSOBA.cntx_psh();
   OSOBA.prefix();
   UD_SKL.cntx_psh();
   UD_SKL.prefix();
   STN.cntx_psh();
   STN.prefix();
   _desc+=
      ': %1 %2, Numer teczki - %3, Jednostka - %4, Stanowisko %5'@
      [P.OSOBA().NAZWISKO,P.OSOBA().PIERWSZE,P.T,P.WYDZIAL().SYMBOL,P.ST().ST];
   STN.cntx_pop();
   UD_SKL.cntx_pop();
   OSOBA.cntx_pop()
|| _desc+=': %1'@[exec('P','#to_string',1)]
?};

_desc


\desc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Dla czynności ustala jej opis na liście zadań.
::   WE:  _a  [OBJECT] - Wskazanie na obiekt menadżera procesu.
::       [_b] [STRING] - Wariant opisu:
::                      ''          - Opis standardowy (wynikający z reprezentacji tekstowej) [domyślnie].
::                      'NITJOST'   - Nazwisko, Imię, Teczka, Jednostka organizacyjna, Stanowisko.
::----------------------------------------------------------------------------------------------------------------------
_mp:=_a;
_in:=_mp.load(exec('kind_in','#b_port'));
_mode:={? var_pres('_b')=type_of('') || _b || '' ?};
_tab:=exec('init_desc_tab','pracownik');

P.cntx_psh();
P.prefix();
{? type_of(_in.P)=type_of(null()) & _in.P<>null() & P.seek(_in.P)
|| _mp.keyRef(P.uidref(),0,0);
   _mp.keyRef(P.OSOBA().uidref(),0,0);
   _tab.ZAW_DANE:='T';
   OSOBA.cntx_psh();
   OSOBA.prefix();
   _tab.NAZWISKO:=P.OSOBA().NAZWISKO;
   _tab.PIERWSZE:=OSOBA.PIERWSZE;
   _tab.OBCY:=OSOBA.OBCY;
   _tab.PASZPORT:=OSOBA.PASZPORT;
   _tab.PESEL:=OSOBA.PESEL;
   _tab.UR_DATA:=$OSOBA.UR_DATA;
   _tab.T:=P.T;
   _tab.IP:=$P.IP;
   {? _mode='NITJOST'
   || UD_SKL.cntx_psh();
      UD_SKL.prefix();
      STN.cntx_psh();
      STN.prefix();
      _tab.UD_SKL:=P.WYDZIAL().SYMBOL;
      _tab.STN:=P.ST().ST;
      STN.cntx_pop();
      UD_SKL.cntx_pop()
   ?};
   OSOBA.cntx_pop()
|| _tab.ZAW_DANE:='N'
?};
P.cntx_pop();

_tab


\grp_edisp_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: rwr [17.00]
:: OPIS: Aktualizacja nagłówka okienka kartoteki.
::   WE: _a - Akronim okienka nagłówkowego.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
grp_edisp(P,_a)


\kk_hist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wyszukuje konto kosztów pracownika na dany dzień.
::   WE:  _a [REFERENCE] - Wskazanie pracownika.
::        _b [DATE]      - Data.
::   WY: Wskazanie konta kosztów.
::  OLD: \kk_hist/kontohis.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
P_KK.cntx_psh();
P_KK.index('OD');
P_KK.prefix(_a);
{? P_KK.find_le(_b)
|| _ref:=P_KK.KK
?};
P_KK.cntx_pop();
_ref


\h_um_pull
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Odświeża kopię roboczą umów o pracę wskazanego pracownika
::   WE: _a - wskazanie pracownika
::   WY: 1 - odświeżenie zakończone sukcesem, 0 - porażka
::----------------------------------------------------------------------------------------------------------------------
_state:=do_state();
{? _state=2
|| return(0)
|? _state=0
|| do()
?};

_rollback:=$(
   {? _state=1
   || ''
   || 'undo(); end(); '
   ?}+"
   H_UM.cntx_pop();
   exec('otworz_h_um','pracownik');
   H.cntx_pop();
   H_ODDE.trig_on('*','*');
   H_ODDE.cntx_pop()
");

H.cntx_psh();
H_UM.cntx_psh();
H_ODDE.cntx_psh();
exec('otworz_h_um','pracownik','h_u_');
H.use('_his_');
H_ODDE.use('h_odde_');
H_ODDE.trig_off('*','*');
: usuń istniejące kopie umów o pracę
{? ~exec('del_ndx','#table',H_UM,'OD',_a)
|| _rollback();
   return(0)
?};

exec('otworz_h_um','pracownik','h_um');
H_UM.index('OD');
H_UM.prefix(_a);
_loop:=H_UM.first();
{!
|? _loop
|! _src:=H_UM.uidref();
   _ref:=H_UM.ref();
   H_UM.memo_get(,'UZASDN');
   _tmp:='';
   H_UM.cntx_psh();
   exec('otworz_h_um','pracownik','h_u_');
   H_UM.clear();
   {? H_UM.add() & H_UM.memo_put(,'UZASDN')
   || exec('sync','zalacz',H_UM.uidref(),_src,2);
      H_UM.IDMOD:='__';
      H_UM.IDLNK:=_src;
      H_UM.put();
      _tmp:=H_UM.uidref();
      {? ~exec('h_pull','pracownik',_ref,H_UM.ref())
      || H_UM.cntx_pop();
         _rollback();
         return(0)
      ?}
   || H_UM.cntx_pop();
      _rollback();
      return(0)
   ?};
   H_UM.cntx_pop();
   H_UM.IDLNK:=_tmp;
   {? ~H_UM.put()
   || _rollback();
      return(0)
   ?};
   _loop:=H_UM.next()
!};

: porządki
H_ODDE.trig_on('*','*');
H_ODDE.cntx_pop();
H_UM.cntx_pop();
H.cntx_pop();
exec('otworz_h_um','pracownik');

{? _state=0
|| end()
?};

: ok
1


\h_pull
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Odświeża kopię roboczą przebiegu wskazanej umowy
::   WE: _a - wskazanie oryginału umowy
::       _b - wskazanie kopii umowy
::   WY: 1 - odświeżenie zakończone sukcesem, 0 - porażka
::----------------------------------------------------------------------------------------------------------------------
_state:=do_state();
{? _state=2
|| return(0)
|? _state=0
|| do()
?};

_rollback:=$({? _state=1 || '' || 'undo(); end(); ' ?}+'H_ODDE.cntx_pop(); H.cntx_pop()');

H.cntx_psh();
H.use('_his_');
H_ODDE.cntx_psh();
H_ODDE.use('h_odde_');

: usuń istniejące kopie przebiegów
{? ~exec('del_ndx','#table',H,'HISTUM',_b)
|| _rollback();
   return(0)
?};

H.use('_hist');
H.index('HISTUM');
H.prefix(_a);
_loop:=H.first();
{!
|? _loop
|! _txt:=H.memo_txt(,1,'INNE');
   _src:=H.uidref();
   _ref:=H.ref();
   _tmp:='';
   H.cntx_psh();
   H.use('_his_');
   H.clear();
   H.UMOWA:=_b;
   {? H.add()
   || exec('sync','zalacz',H.uidref(),_src,2);
:     ze względu na porównanie z wersją docelową należy
:     treść notatki zapisać w pierwszej kolejności
      H.memo_set(_txt,'INNE');
      {? ~H.memo_put(,'INNE')
      || H.cntx_pop();
         _rollback();
         return()
      ?};
      H.IDMOD:='__';
      H.IDLNK:=_src;
      {? H.put()
      || _tmp:=H.uidref()
      || H.cntx_pop();
         _rollback();
         return(0)
      ?}
   || H.cntx_pop();
      _rollback();
      return(0)
   ?};
   H.cntx_pop();
   exec('add','#bulk',H,'IDLNK',$_ref);
   H.IDLNK:=_tmp;

:: Przeniesienie informacji o oddelegowaniach do "brudnopisu".
   {? PAR_SKID.get(261)='T' & H.ODDEL='T'
   || _ok:=exec('h_odde_pull','oddelegowanie')
   ?};
   _ok:=H.put();
   exec('del','#bulk',H,'IDLNK',$_ref);
   {? ~_ok
   || _rollback();
      return(0)
   ?};
   _loop:=H.next()
!};

H_ODDE.cntx_pop();
H.cntx_pop();
{? _state=0
|| end()
?};

: ok
1


\h_um_merge
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zatwierdza modyfikację bieżącej lub wskazanej umowy współpracy.
::   WE: _a - wskazanie umowy (opcjonalny) ref lub sqlref, jeśli pominięty działanie dla bieżącej
::   WY: 1 - operacja zakończona powodzeniem, 0 - wystąpił błąd
::----------------------------------------------------------------------------------------------------------------------
_epilog:="
   H_UM.cntx_pop();
   exec('otworz_h_um','pracownik')
";

H_UM.cntx_psh();
{? (var_pres('_a')=type_of('') & _a<>'') |
   (var_pres('_a')=type_of(null()) & _a<>null())
|| {? ref_tab(_a)=H_UM & ref_name(_a)='h_u_'
   || exec('otworz_h_um','pracownik',ref_name(_a));
      H_UM.prefix();
      {? H_UM.seek(_a)
      || H_UM.index('OD');
         H_UM.prefix(H_UM.P);
         H_UM.P()
      || FUN.error('Nie znaleziono umowy o wskazaniu (%1).'@ [$_a]);
         _epilog();
         return(0)
      ?}
   || FUN.error('Błędne wskazanie umowy współpracy (%1).'@ [$_a]);
      _epilog();
      return(0)
   ?}
?};

{? H_UM.IDMOD='__'
|| _epilog();
   return(1)
?};

_state:=do_state();
_start:=0;
{? _state=0
|| _start:=1;
   do()
|? _state<>1
|| _epilog();
   return(0)
?};

errno();

_ret:=0;
_srct:=H_UM.uidref();

_org:=exec('H_UM','buffer');
_tmp:=exec('H_UM','buffer');
_tmp.get(1);
_txt:='';

H_UM.cntx_psh();
exec('otworz_h_um','pracownik','h_um');
H_UM.index('OD');
H_UM.prefix(H_UM.P);

{? (1+_tmp.IDMOD)='D'
|| H_UM.blank();
   H_UM.memo_set(,'UZASDN');
   _tmp.set();
   H_UM.IDLNK:=_srct;
   {? H_UM.add(1) & H_UM.memo_put(,'UZASDN')
   || _srcd:=H_UM.uidref();
      _org.get(1);
      _epilog();
      H_UM.IDLNK:=_srcd;
      {? exec('sync','zalacz',_srct,H_UM.IDLNK,1) & H_UM.put(1)
      || _ret:=exec('h_merge_all','pracownik',_tmp.Ref)
      ?}
   || _epilog()
   ?}

|? (1+_tmp.IDMOD)='P' & H_UM.seek(_tmp.IDLNK)
|| _org.get();
   _tmp.set();
   H_UM.IDADD:=_org.IDADD;
   H_UM.IDLNK:=_org.IDLNK;
   {? H_UM.memo_put(,'UZASDN') & H_UM.put(1)
   || _epilog();
      {? exec('sync','zalacz',_srct,H_UM.IDLNK,1) & H_UM.put(1)
      || _ret:=exec('h_merge_all','pracownik',_tmp.Ref)
      ?}
   || _epilog()
   ?}

|? (_tmp.IDMOD+1)='H' & H_UM.seek(_tmp.IDLNK)
|| _ret:=exec('h_merge_all','pracownik',_tmp.Ref);
   {? ~_ret || _txt:=exec('msg_grp_akceptuj','oddelegowanie',_tmp.Ref) ?};
   _org.get(1);
   _epilog()

|| _epilog()
?};

{? errno()
|| _ret:=0
?};

{? ~_ret |
   ~exec('h_um_validate','pracownik','h_um',_org.P) |
   ~exec('h_validate','pracownik',_org.Ref)
|| {? _start
   || undo();
      end()
   ?};
   {? do_state()=0
   || FUN.emsg(exec('h_um_synch_msg','pracownik',H_UM,1,_txt))
   ?}
|| exec('pracownik_aktualizuj','pracownik')
?};

{? _start
|| end()
?};

_epilog();

_ret


\h_um_cancel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wycofuje modyfikację bieżącej lub wskazanej umowy współpracy.
::   WE: _a - wskazanie umowy (opcjonalny), jeśli pominięty działanie dla bieżącej
::   WY: 1 - operacja zakończona powodzeniem, 0 - wystąpił błąd
::----------------------------------------------------------------------------------------------------------------------
_epilog:="
   H_UM.cntx_pop();
   exec('otworz_h_um','pracownik')
";

H_UM.cntx_psh();
{? (var_pres('_a')=type_of('') & _a<>'') |
   (var_pres('_a')=type_of(null()) & _a<>null())
|| {? ref_tab(_a)=H_UM & ref_name(_a)='h_u_'
   || exec('otworz_h_um','pracownik',ref_name(_a));
      H_UM.prefix();
      {? H_UM.seek(_a)
      || H_UM.index('OD');
         H_UM.prefix(H_UM.P);
         H_UM.P()
      || FUN.error('Nie znaleziono umowy o wskazaniu (%1).'@ [$_a]);
         _epilog();
         return(0)
      ?}
   || FUN.error('Błędne wskazanie umowy współpracy (%1).'@ [$_a]);
      _epilog();
      return(0)
   ?}
?};

{? H_UM.IDMOD='__'
|| _epilog();
   return(1)
?};

_state:=do_state();
_start:=0;
{? _state=0
|| _start:=1;
   do()
|? _state<>1
|| _epilog();
   return(0)
?};

errno();

_ret:=0;

_org:=exec('H_UM','buffer');
_tmp:=exec('H_UM','buffer');
_tmp.get(1);
_srct:=H_UM.uidref();

{? (1+_tmp.IDMOD)='D'
|| _ret:=H_UM.del(,1)

|? (1+_tmp.IDMOD)='P'
|| H_UM.cntx_psh();
   exec('otworz_h_um','pracownik','h_um');
   H_UM.index('OD');
   H_UM.prefix(P.ref());
   {? H_UM.seek(_tmp.IDLNK)
   || _org.get(1);
      H_UM.cntx_pop();
      exec('otworz_h_um','pracownik');
      _org.set();
      H_UM.IDADD:=_tmp.IDADD;
      H_UM.IDLNK:=_tmp.IDLNK;
      {? exec('sync','zalacz',_srct,H_UM.IDLNK,2) & H_UM.memo_put(,'UZASDN') & H_UM.put(1)
      || _ret:=
            {? (_tmp.IDMOD+1)='H'
            || exec('h_cancel_all','pracownik',_tmp.Ref)
            || 1
            ?}
      ?}
   || _epilog()
   ?}

|? (_tmp.IDMOD+1)='H'
|| _ret:=exec('h_cancel_all','pracownik',_tmp.Ref)
?};

{? errno()
|| _ret:=0
?};

{? ~_ret |
   ~exec('h_um_validate','pracownik','h_u_',_tmp.P) |
   ~exec('h_validate','pracownik',_tmp.Ref)
|| {? _start
   || undo();
      end()
   ?};
   {? do_state()=0
   || FUN.emsg(exec('h_um_synch_msg','pracownik',H_UM,0))
   ?}
?};

{? _start
|| end()
?};

_epilog();

_ret


\h_um_validate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Sprawdza ciągłość umów. Wykorzystywana do sprawdzenia, czy umowy będą poprawne po ich akceptacji/wycofaniu.
::   WE: _a - nazwa zbioru: h_um, h_u_
::       _b - wskazanie pracownika
::   WY: 0/1 - wynik testu (błędne/poprawne)
::----------------------------------------------------------------------------------------------------------------------
_ok:=1;
H_UM.cntx_psh();
exec('otworz_h_um','pracownik',_a);
H_UM.index('OD');
H_UM.prefix(_b);
{? H_UM.first()
|| _od:=H_UM.DO+1;
   {!
   |? {? H_UM.next()
      || {? H_UM.OD=_od
         || _od:=H_UM.DO+1
         || _ok:=0
         ?};
         _ok
      ?}
   !}
?};
H_UM.cntx_pop();
exec('otworz_h_um','pracownik');
_ok


\h_merge_one
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zatwierdza bieżącą modyfikację przebiegu umowy.
::   WE: _a - weryfikacja poprawności danych:
::          pominięty - poprawność sprawdzana
::          0 - nie weryfikuje poprawności danych
::   WY: 1 - operacja zakończona powodzeniem, 0 - wystąpił błąd
::----------------------------------------------------------------------------------------------------------------------
{? H.IDMOD='__' || return(1) ?};

_ret:=0;
_srct:=H.uidref();
_txt:='';

_h_um:=null();
H_UM.cntx_psh();
exec('otworz_h_um','pracownik','h_u_');
_uid:=H.UMOWA().IDLNK;
exec('otworz_h_um','pracownik','h_um');
H_UM.clear();
{? H_UM.seek(_uid)
|| _h_um:=H_UM.ref()
|| H_UM.cntx_pop();
   exec('otworz_h_um','pracownik');
   return(0)
?};
H_UM.cntx_pop();
exec('otworz_h_um','pracownik');

_state:=do_state();
_start:=0;
{? _state=0
|| _start:=1;
   do()
|? _state<>1
|| return(0)
?};

errno();

_org:=exec('H','buffer');
_tmp:=exec('H','buffer');
_tmp.get(1);

:: Sprawdzenie czy zostały wypełnione informacje o oddelegowaniu do pracy za granicą.
:: Jeżeli nie, akceptacja nie jest możliwa.
{? -menu_txt()='akceptuj'
   &
   PAR_SKID.get(261)='T'
   &
   H.ODDEL='T'
   &
   ~exec('czy_jest_H_ODDE','oddelegowanie')
   &
   ((1+H.IDMOD)='D' | (1+H.IDMOD)='P')
|| {? _start
   || undo();
      end()
   ?};
   {? _state<>1
   || FUN.emsg('%1\n%2'
         [  'Brak szczegółowych informacji o oddelegowaniu do pracy za granicą.'@,
            'Wprowadzenie wybranych modyfikacji skutkowałoby powstaniem błędnych zapisów.'@
         ]
      )
   ?};
   return(0)
?};

H.cntx_psh();
H.use('_hist');
H.index('_HISTDAT');
H.prefix(_tmp.P);

{? (1+H.IDMOD)='D'
|| _tmp.set();
   H.UMOWA:=_h_um;
   H.IDLNK:=_srct;

   {? H.add(1) & H.memo_put(,'INNE')
   || _srcd:=H.uidref();
      _org.get(1);
      H.cntx_pop();
      H.IDLNK:=_srcd;
      _ret:=exec('sync','zalacz',_srct,H.IDLNK,1) & H.put(1);
      {? PAR_SKID.get(261)='T' & _ret & H.ODDEL='T'
      || exec('synchronizuj','oddelegowanie',H.IDLNK)
      ?}
   || H.cntx_pop()
   ?}

|? (1+H.IDMOD)='P' & H.seek(_tmp.IDLNK)
|| _org.get(1);
   _tmp.set();
   H.UMOWA:=_org.UMOWA;
   H.IDADD:=_org.IDADD;
   H.IDLNK:=_org.IDLNK;
   {? H.put(1) & H.memo_put(,'INNE')
   || H.cntx_pop();
      _ret:=
         exec('sync','zalacz',_srct,H.IDLNK,1)
         &
         {? PAR_SKID.get(261)='T' & H.ODDEL='T'
         || _ret:=exec('synchronizuj','oddelegowanie',H.IDLNK)
         || 1
         ?}
         &
         H.put(1)
      || H.cntx_pop()
   ?}

|| H.cntx_pop()
?};

{? errno()
|| _ret:=0
?};

_validate:=(var_pres('_a')<>type_of(0) | _a);
{? ~_ret | {? _validate || ~exec('h_validate','pracownik',_org.UMOWA) ?}
|| {? _start
   || undo();
      end()
   ?};
   {? do_state()=0
   || FUN.emsg(exec('h_um_synch_msg','pracownik',H,1,_txt))
   ?};
   return(0)
?};

{? _start
|| end()
?};

{? do_state()=0 & KOMM.is_inited() & KOMM.get_size()>0
|| KOMM.select('Komunikaty dotyczące zmian w przebiegu zatrudnienia'@,,,,,0);

   VAR_DEL.delete('KOMM');
   exec('KOMM','#object')
?};

1


\h_cancel_one
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wycofuje bieżącą modyfikację przebiegu umowy.
::   WE: _a - weryfikacja poprawności danych:
::          pominięty - poprawność sprawdzana
::          0 - nie weryfikuje poprawności danych
::   WY: 1 - operacja zakończona powodzeniem, 0 - wystąpił błąd
::----------------------------------------------------------------------------------------------------------------------
{? H.IDMOD='__' || return(1) ?};

_state:=do_state();
_start:=0;
{? _state=0
|| _start:=1;
   do()
|? _state<>1
|| return(0)
?};

errno();

_ret:=0;
_org:=exec('H','buffer');
_tmp:=exec('H','buffer');
_tmp.get(1);
_srct:=H.uidref();

{? (1+_tmp.IDMOD)='D'
|| _ret:=H.del(,1)

|? (1+_tmp.IDMOD)='P'
|| H.cntx_psh();
   H.use('_hist');
   H.index('_HISTDAT');
   H.prefix(_tmp.P);
   {? H.seek(_tmp.IDLNK)
   || _org.get(1);
      H.cntx_pop();
      _org.set();
      H.UMOWA:=_tmp.UMOWA;
      H.IDADD:=_tmp.IDADD;
      H.IDLNK:=_tmp.IDLNK;
:     ze względu na porównanie z wersją docelową należy
:     treść notatki zapisać w pierwszej kolejności
      _ret:=
         exec('sync','zalacz',_srct,H.IDLNK,2) & exec('h_odde_cancel','oddelegowanie') & H.memo_put(,'INNE') & H.put(1)
   || H.cntx_pop()
   ?}
?};

{? errno()
|| _ret:=0
?};

_validate:=(var_pres('_a')<>type_of(0) | _a);
{? ~_ret | {? _validate || ~exec('h_validate','pracownik',_tmp.UMOWA) ?}
|| {? _start
   || undo();
      end()
   ?};
   {? do_state()=0
   || FUN.emsg(exec('h_um_synch_msg','pracownik',H,0))
   ?}
?};

{? _start
|| end()
?};

_ret


\h_validate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Sprawdza ciągłość przebiegu umowy. Wykorzystywana do sprawdzenia, czy przebiegi będą poprawne po ich akceptacji
::       lub wycofaniu.
::   WE: _a - wskazanie umowy
::   WY: 0/1 - wynik testu (błędne/poprawne)
::----------------------------------------------------------------------------------------------------------------------
_cntx_pop:="H_UM.cntx_pop();H.cntx_pop()";

_ok:=1;
H.cntx_psh();
H_UM.cntx_psh();
exec('otworz_h_um','pracownik',ref_name(_a));
H.use(exec('h_name','pracownik',_a));
H.index('HISTUM');
H.prefix(_a);
{? H.last() & H.DO<>H_UM.DO
|| _cntx_pop();
   return(0)
?};
{? H.first()
|| {? H.OD<>H_UM.OD
   || _cntx_pop();
      return(0)
   ?};
   _od:=H.DO+1;
:: ER/WRT/XP/20.14/2007/0072
:: wyłączono kontrolę wypełnienia i poprawności wszystkich zapisów
:: weryfikowana jest jedynie ciągłość dat rozpoczęcia i zakończenia
   {!
   |? {? H.next()
      || {? H.OD=_od
         || _od:=H.DO+1
         || _ok:=0
         ?};
         _ok
      ?}
   !}
?};
H_UM.cntx_pop();
H.cntx_pop();
_ok


\h_synch_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zatwierdza/wycofuje wszystkie modyfikacje przebiegu umowy.
::   WE: _a - wskazanie umowy, której przebiegi mają być zatwierdzone/wycofane
::       _b - rodzaj operacji:
::          1 - zatwierdzenie
::          0 - wycofanie
::   WY: 1 - operacja zakończona powodzeniem, 0 - wystąpił błąd
::----------------------------------------------------------------------------------------------------------------------
_state:=do_state();
_start:=0;
{? _state=0
|| _start:=1;
   do()
|? _state<>1
|| return(0)
?};

H.cntx_psh();
H.use(exec('h_name','pracownik',_a));
H.index('HISTUM');
H.prefix(_a);

_ret:=1;
_loop:=H.first();
{!
|? _loop
|! _ret:=
      {? _b
      || exec('h_merge_one','pracownik',0)
      || exec('h_cancel_one','pracownik',0)
      ?};
   _loop:=(_ret & H.next())
!};

H.cntx_pop();

{? errno()
|| _ret:=0
?};

{? ~_ret | ~exec('h_validate','pracownik',_a)
|| {? _start
   || undo()
   ?};
   {? do_state()<>1
   || FUN.emsg(exec('h_um_synch_msg','pracownik',H,_b))
   ?}
?};

{? _start
|| end()
?};

_ret


\h_um_synch_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca treść komunikatu o niepowodzeniu operacji wprowadzenia/wycofania zmian
::   WE: _a - alias do tabeli (H lub H_UM)
::       _b - rodzaj operacji:
::          1 - zatwierdzenie
::          0 - wycofanie
::       [_c] - dodatkowy tekst do komunikatu
::   WY: treść komunikatu
::----------------------------------------------------------------------------------------------------------------------
_txt:={? var_pres('_c')=type_of('') || _c || '' ?};

{? _a=H
|| {? _b
   || 'Przeniesienie informacji do docelowej wersji kartoteki przebiegu nie powiodło się.'@
   || 'Przywrócenie informacji z docelowej wersji kartoteki przebiegu nie powiodło się.'@
   ?}+
   '\nWprowadzenie wybranych modyfikacji skutkowałoby powstaniem błędnych zapisów.'@

|? _a=H_UM
|| {? _b
   || 'Przeniesienie informacji do docelowej wersji kartoteki umów nie powiodło się.'@+_txt
   || 'Przywrócenie informacji z docelowej wersji kartoteki umów nie powiodło się.'@
   ?}+
   '\nWprowadzenie wybranych modyfikacji skutkowałoby powstaniem błędnych zapisów.'@

|| ''
?}


\h_merge_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zatwierdza wszystkie modyfikacje przebiegu umowy.
::   WE: _a - wskazanie umowy, której przebiegi mają być zatwierdzone
::   WY: 1 - operacja zakończona powodzeniem, 0 - wystąpił błąd
::----------------------------------------------------------------------------------------------------------------------
exec('h_synch_all','pracownik',_a,1)


\h_cancel_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Wycofuje wszystkie modyfikacje przebiegu umowy.
::   WE: _a - wskazanie umowy, której przebiegi mają być wycofane
::   WY: 1 - operacja zakończona powodzeniem, 0 - wystąpił błąd
::----------------------------------------------------------------------------------------------------------------------
exec('h_synch_all','pracownik',_a,0)


\h_um_name
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca nazwę zbioru tabeli H_UM właściwą dla maski aktualnie otwartej tabeli H lub wskazania przebiegu.
::   WE: _a - wskazanie przebiegu, jeśli pominięty zwrócona zostanie nazwa właściwa dla aktualnie otwartego zbioru H
::   WY: nazwa zbioru tabeli H_UM
::----------------------------------------------------------------------------------------------------------------------
_h:={? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=H || ref_name(_a) || H.name() ?};
'h_u'+{? _h='_hist' || 'm' || '_' ?}


\h_name
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca nazwę zbioru tabeli H właściwą dla maski aktualnie otwartej tabeli H_UM lub wskazania umowy.
::   WE: _a - wskazanie umowy, jeśli pominięty zwrócona zostanie nazwa właściwa dla aktualnie otwartego zbioru H_UM
::   WY: nazwa zbioru tabeli H
::----------------------------------------------------------------------------------------------------------------------
_h_um:={? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=H_UM || ref_name(_a) || H_UM.name() ?};
'_his'+{? _h_um='h_um' || 't' || '_' ?}


\h_drukuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Część wspólna wydruków uruchamianych z poziomu przebiegu zatrudnienia.
::   WE: _a - Wskazanie przebiegu zatrudnienia [domyślnie bieżący].
::       _b - Typ wydruku.
::       [_c] - Szablon wydruku.
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| _a:=H.ref()

|? ~(((var_pres('_a')=type_of('') & _a<>'') | (var_pres('_a')=type_of(null()) & _a<>null())) & ref_tab(_a)=H)
|| FUN.error('Błędne wskazanie przebiegu zatrudnienia (%1).'@ [$_a]);
   return()
?};
_szab:={? var_pres('_c')=type_of('') & +|_c || _c || ~~ ?};
OSOBA.cntx_psh();
OSOBA.prefix();
P.cntx_psh();
P.prefix();
H.cntx_psh();
H.use(ref_name(_a));
H.index('_HISTDAT');
H.prefix();
{? H.seek(_a)
|| H.P().OSOBA();
   H_UM.cntx_psh();
   exec('otworz_h_um','pracownik',exec('h_um_name','pracownik'));
   H_UM.index('OD');
   H.UMOWA();

   _tab:=tab_tmp(1,
      'P','STRING[16]','Pracownik',
      'H','STRING[16]','Aneks do umowy o pracę',
      'PPSF_H','STRING[16]','Praca zdalna',
      'PPSF_ADR','STRING[240]','Adresy pracy zdalnej',
      'CFG','STRING[6]','Parametry PPSF',
      'LP','INTEGER','Kolejność'
   );
   _tab.H:=$H.ref();
   _tab.P:='';
   _tab.add();
   {? _b='prze'
::    Przeszeregowanie
   || params_set('P',_tab,'DALEJ','');
      rep_exec('pkd_zaswprzeszeregowanie')
   |? _b='prze_seria'
::    Przeszeregowanie - dla drukowania seryjnego
   || params_set('P',_tab,'DALEJ','','SERIA','T','SERIA_RET',obj_new('STATUS','INFO'),'SZABLON',_szab);
      rep_exec('pkd_zaswprzeszeregowanie');
      H_UM.cntx_pop();
      exec('otworz_h_um','pracownik');
      H.cntx_pop();
      P.cntx_pop();
      OSOBA.cntx_pop();
      return(params_get(1).SERIA_RET)

   |? _b='anum'
::    Aneks do umowy
   || _pos:=exec('h_mod_pos','pracownik',H.ref(),H.UMOWA);
      Cntx.psh(PPSF_H,PPSF_ADR);
      _obj:=obj_new('jestH','jestA','brakH','brakA','pobierz','PPSF_H','PPSF_ADR','drukH','drukA','exit_code','CFG');
      params_set('H',_tab,'ZAL','1','DALEJ','','obj',_obj);
      exec('wybor_do_druku_aneksu','ppsf',_obj);
      _obj.pobierz();
      _druk:=_obj.drukH+_obj.drukA;
      {? _druk=0 & (_pos=0 | _pos=1)
      || FUN.info('Wydruk aneksu do umowy o pracę możliwy jest tylko dla zapisu zmieniającego jej warunki.'@)
      || _tab.PPSF_H:=_obj.PPSF_H;
         _tab.PPSF_ADR:=_obj.PPSF_ADR;
         _tab.CFG:=_obj.CFG;
         _tab.put();
         rep_exec('pkd_zaswaneksdoumowy')
      ?};
      {? PPSF_H.f_active() || PPSF_H.f_clear() ?};
      {? PPSF_ADR.f_active() || PPSF_ADR.f_clear() ?};
      Cntx.pop(PPSF_H,PPSF_ADR)
   |? _b='anum_seria'
::    Aneks do umowy - dla drukowania seryjnego
   || _pos:=exec('h_mod_pos','pracownik',H.ref(),H.UMOWA);
      {? _pos>1
      || _obj:=obj_new('jestH','jestA','brakH','brakA','pobierz','PPSF_H','PPSF_ADR','drukH','drukA','exit_code','CFG');
         _obj.jestH:=_obj.jestA:=0;
         _obj.brakH:=_obj.brakA:=0;
         _obj.drukH:=_obj.drukA:=0;
         _obj.PPSF_H:=_obj.PPSF_ADR:='';
         _obj.CFG:='000000';
         params_set('H',_tab,'ZAL','1','DALEJ','','SERIA','T','SERIA_RET',obj_new('STATUS','INFO'),'SZABLON',_szab,
            'obj',_obj
         );
         _tab.PPSF_H:=_obj.PPSF_H;
         _tab.PPSF_ADR:=_obj.PPSF_ADR;
         _tab.CFG:=_obj.CFG;
         _tab.put();
         rep_exec('pkd_zaswaneksdoumowy');
         H_UM.cntx_pop();
         exec('otworz_h_um','pracownik');
         H.cntx_pop();
         P.cntx_pop();
         OSOBA.cntx_pop();
         return(params_get(1).SERIA_RET)
      ?}
   ?};

   H_UM.cntx_pop();
   exec('otworz_h_um','pracownik')

|| FUN.error('Nie znaleziono przebiegu o wskazaniu (%1).'@ [$_a])
?};
H.cntx_pop();
P.cntx_pop();
OSOBA.cntx_pop();
~~


\h_drukuj_prze
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Uruchamia wydruk przeszeregowania z menu okienka przebiegu zatrudnienia.
::   WE: _a - Wskazanie przebiegu zatrudnienia [domyślnie bieżący].
::  OLD: \wydprzeb/kali.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| _a:=H.ref()
?};
exec('h_drukuj','pracownik',_a,'prze')


\h_drukuj_anum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KFI [2008]
:: OPIS: Uruchamia wydruk aneksu do umowy o pracę z menu okienka przebiegu zatrudnienia.
::   WE: _a - Wskazanie przebiegu zatrudnienia [domyślnie bieżący].
::  OLD: \wydruman/kali.fml
::  OLD: \test_rpm/umowy.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| _a:=H.ref()
?};
exec('h_drukuj','pracownik',_a,'anum')


\ustawkal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła ustawia kalendarz na przypisany do bieżącego pracownika.
::   WE:
::   WY:
::  OLD: \ustawkal/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_rok:=date()~1;
__KAL.set_cal(
   {? P.KAL || P.KAL || 'standard' ?},
   {? P.DZA~1<=_rok & (P.DZ=date(0,0,0) | _rok<=P.DZ~1)
   || _rok
   |? P.DZA~1<=_rok
   || P.DZ~1
   || P.DZA~1
   ?}
)


\setup_h_tmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Sprawdza, czy dozwolona jest zmiana ustawień "brudnopisu" przebiegu umów o pracę. Jeśli tak, to zależnie od
::       ustawienia usuwa nadmiarowe informacje lub odświeża "brudnopis". Wykorzystywana po edycji parametru 180.
::   WE: _a - nowa wartość parametru 180
::       _b - poprzednia wartość parametru 180
::   WY: 1 - zmiana dozwolona, 0 - zmiana niemożliwa
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('') || return(0)
|? var_pres('_b')<>type_of('') || return(0)
|? _a=_b || return(1)
?};

{? _a='T'
|| _msg:='Proszę czekać. Trwa tworzenie wersji roboczej kartoteki umów współpracy...'@;
   P.cntx_psh();
   P.index('PRACOSOB');
   P.prefix(exec('ref_firma','ustawienia'));
   _count:=0;
   _size:=P.size();
   _loop:=P.first();
   {!
   |? _loop
   |! progress(100*(_count+=1)/_size,_msg,FUN.TYT);
      {? P.F_ZATR().DOCELOWA='T'
      || {? ~exec('h_um_pull','pracownik',P.ref())
         || FUN.emsg('Synchronizacja danych nie powiodła się.'@);
            P.cntx_pop();
            prgs_clr();
            return(0)
         ?}
      ?};
      _loop:=P.next()
   !};
   prgs_clr();
   P.cntx_pop();
:  można włączyć
   1

|? _a='N'
|| _RS:=sql(
      'select count(*) as TEST '+
      'from @H_UM '+
      'join P using (H_UM.P,P.REFERENCE) '+
      'join F_ZATR using (P.F_ZATR,F_ZATR.REFERENCE) '+
      'where P.FIRMA=:_a and F_ZATR.DOCELOWA=\'T\' and H_UM.IDMOD<>\'__\' and '+
      '      F_ZATR.KOD in (\'P\',\'p\')',
      exec('ref_firma','ustawienia')
   );
   {? type_of(_RS)=type_of(SYSLOG)
   || {? _RS.first() & _RS.TEST<>0
      || FUN.info(
            'Znaleziono wersje robocze umów współpracy.\n'
            'Zmiana parametru pracy nie jest możliwa.'@
         );
         return(0)
      ?};
      obj_del(_RS)
   || return(0)
   ?};

   _RS:=sql(
      'select count(*) as TEST '+
      'from @H '+
      'join P using (H.P,P.REFERENCE) '+
      'join F_ZATR using (P.F_ZATR,F_ZATR.REFERENCE) '+
      'where P.FIRMA=:_a and F_ZATR.DOCELOWA=\'T\' and H.IDMOD<>\'__\' and '+
      '      F_ZATR.KOD in (\'P\',\'p\')',
      exec('ref_firma','ustawienia')
   );
   {? type_of(_RS)=type_of(SYSLOG)
   || {? _RS.first() & _RS.TEST<>0
      || FUN.info(
            'Znaleziono wersje robocze aneksów do umów.\n'
            'Zmiana parametru pracy nie jest możliwa.'@
         );
         return(0)
      ?};
      obj_del(_RS)
   || return(0)
   ?};
:  można wyłączyć
   1
?}


\h_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PKOSO [8.70]
:: OPIS:   Funkcja zwraca wartość pola w tabeli H
::   WE:  [_a] [STRING] - akronim, jeśli nie podany to 'S1'
::        [_b] [DATE]   - data, jeśli nie podany to ostatni dzień miesiąca listy lub data bieżąca
::        [_c] [STRING] - kod, jeśli nie podany to 'Z'
::   WY:  wartość pola lub pusty jeśli nie znaleziono odpowiedniego rekordu
::  OLD: \h_find/waluty.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('')|| _a:='S1' ?};
{? var_pres('_b')<>type_of(date) || _b:={? VAR.JESTLIST || date(O.R,O.M,0) || date ?} ?};
{? var_pres('_c')<>type_of('')|| _c:='Z'?};

_typ:=type_of(($('H.'+_a))());
_wyn:=
   {? _typ = 5 || time(0,0,0)
   |? _typ = 4 || date(0,0,0)
   |? _typ = 2 || ''
   |? _typ = 1 || 0
   |? _typ = 7 || null()
   || ~~
   ?};

H.index('_HISTKOD');
H.prefix(P.ref,_c);
{? H.find_le(_b)
|| _wyn:=($('H.'+_a))()
?};
_wyn


\zn_ttub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Ustala rekord w tabeli P_INFO.
::   WE: _a [_OSOBA] - wskazanie osoby, domyślnie bieżący rekord
::       _b [DATE] - data na jaką ma być wyszukana informacja, domyślnie bieżąca data
::       _c [STRING] - rodzaj wyszukiwanego zapisu 'm'/'w' - informacje właściwe dla urlopu, jeśli pominięty
::          wyszukiwany jest zapis niezwiązany z urlopem
::   WY: wskazanie na znaleziony zapis lub null jeśli nie udało się go odszukać
::  OLD: \zn_ttub/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_a:={? var_pres('_a')=type_of(null()) || _a || OSOBA.ref() ?};
_b:={? var_pres('_b')=type_of(date) || _b || date() ?};
_c:={? var_pres('_c')=type_of('') || _c || '' ?};

P_INFO.index('OD');
P_INFO.prefix(exec('ref_firma','ustawienia'),_a);
{? P_INFO.find_le(_b)
|| {!
   |? _kod:=P_INFO.TTUB().KOD;
      {? {? _c='m' || _kod='1240'
         |? _c='w' || _kod<>'1240' & (2+_kod)='12'
         || (2+_kod)<>'12'
         ?}
      || return(P_INFO.ref())
      || P_INFO.prev()
      ?}
   !}
?};
null()


\szukaj_p_ipod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Wyszukuje odpowiedni zapis w kartotece pracownika.
::   WE: [_a][DATE]      - data (domyślnie bieżąca)
::       [_b][REFERENCE] - ref pracownika
::   WY: "ref" rekordu jeżeli wyszukanie powiodło się
::       null() jeśli informacje podatkowe nie zostały znalezione
::  OLD: \szukaj/infpod.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(date)
|| _a:=date
?};
_P_ref:={? var_pres('_b')=type_of(null) || _b || P.ref() ?};
P_IPOD.index('OD');
P_IPOD.prefix(_P_ref);
{? P_IPOD.find_le(_a)
|| P_IPOD.ref()
|| null()
?}


\ustaw_p_ipod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2010]
:: OPIS: Przypisuje polom domyślne wartości zależnie od daty i trybu.
::       Wywołanie bezpośrednio po redakcji pola "Od dnia" z wartością pola OD z pominięciem drugiego argumentu,
::       oraz z podatek4.fml z datą ostatniego dnia miesiąca listy płac i znacznikiem 'A'
::   WE: [_a] [DATE]   - data do określenia zapisu źródłowego (domyślnie bieżąca)
::       [_b] [STRING] - informacja o aktualizowanych polach
::          - 'W' rekord wprowadza operator
::          - 'A' rekord tworzony jest automatycznie podczas naliczania listy
::  OLD: \ustaw/infpod.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(date) || _a:=date ?};
_b:={? var_pres('_b')<>type_of('') || 'W' || _b ?};
P_IPOD.cntx_psh();
P_IPOD.blank();
_ku:=P_IPOD.KU;
_up:={? _a~1>2022 || 'B' || P_IPOD.UP ?};
_op:=P_IPOD.OP;
_proc:=P_IPOD.PROC;
_przy:=P_IPOD.PRZYCH;
{? exec('szukaj_p_ipod','pracownik',_a)
|| _ku:=P_IPOD.KU;
   {? _b='A' & _a~1>2022
   || _up:=P_IPOD.UP;
      _op:=P_IPOD.OP
   || {? P_IPOD.UP<>'Z' & P_IPOD.UP<>'D'
      || _up:=P_IPOD.UP
      ?}
   ?};
   {? _b='W'
   || _up:=P_IPOD.UP;
      _op:=P_IPOD.OP;
      _proc:=P_IPOD.PROC;
      _przy:=P_IPOD.PRZYCH
   ?}
?};
P_IPOD.cntx_pop();
P_IPOD.P:=P.ref();
P_IPOD.KU:=_ku;
P_IPOD.UP:=_up;
P_IPOD.OP:=_op;
P_IPOD.PROC:=_proc;
P_IPOD.PRZYCH:=_przy;
P_IPOD.ST:=_b


\view_val
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła pozwala wybrać zakres przezentowanych współpracowników (T/N/W).
::   WE: [_a] [STRING] - Aktualny stan (aktualna wartość) parametru.
::   WY: Wybrany status.
::----------------------------------------------------------------------------------------------------------------------
_in:=
   {? var_pres('_a')=type_of('') & (_a='T' | _a='N' | _a='W')
   || _a
   || __PARSES.getVal('ZakresDanych')
   ?};

_PAR:=tab_tmp(1,'VIEW','STRING[1]','Prezentowani współpracownicy'@);
_we:=_PAR.mk_edit('Status prezentowanych współpracowników'@);
_PAR.win_esep(_we,'Status');
_PAR.win_efld(_we,,'VIEW',,,,,,,,'','radio-buttons',,
   'Zatrudnieni / aktywni',"'T'",
   'Zwolnieni / archiwalni',"'N'",
   'Wszyscy',"'W'"
);
exec('ok_esc','#window',_PAR,_we);
_PAR.win_edit(_we);
_PAR.VIEW:=_in;
{? _PAR.edit()
|| _PAR.VIEW
|| _in
?}


\uzd_nskl_kartprac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Składki na ubezpieczenie zdrowotne od osób przebywających na urlopie wychowawczym.
::   WE:
::   WY:
::  OLD: \uzd_nskl/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_b[5]:=
   {? _podst:=FUNKCJE.LU_SYS(56421)
   ||  exec('okr_nskl_kartprac','lista_licz',_a,_b);
      _b[4]:=_podst;
      {? _b[1]=_b[3]
      || FUNKCJE.LU_SYS(57421)
      || _b[4]:=(_b[4]/_b[1]*_b[3])$2;
         _b[4]*KST.PRKC/100$2
      ?}
   ?}


\czyscp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2010]
:: OPIS: Formula usuwa niewykorzystane rekordy z tabeli P, ktorych pole WYDZIAL jest puste.
::   WE: [_a] [INTEGER] - parametr określa, czy utworzyć tabelę tymczasową do zapisu informacji o usuniętych
::       pracownikach, dla 1 - tak, 0 lub brak - nie
::   WY: tabela tymczasowa zawierająca informacje o usuniętych pracownikach lub ~~
::  OLD: \czyscp/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_delTab:={? var_pres('_a')=type_of(0) || _a || 0 ?};
{? _delTab
|| _TAB_P:=tab_tmp(1,
      'IP',       'INTEGER',     'IP',
      'NAZWISKO', 'STRING[30]',  'NAZWISKO',
      'PIERWSZE', 'STRING[20]',  'PIERWSZE',
      'PESEL',    'STRING[11]',  'PESEL'
      );
   _del_ip:=0
?};
exec('__F_ZATR','object');
_val:=__F_ZATR.P;
F_ZATR.cntx_psh();
P.cntx_psh;
P.index('PRACOWYZ');
P.prefix(null());
_loop:=P.first();
{!
|? _loop
|! {? P.FIRMA=exec('ref_firma','ustawienia') & (P.count()=0) & P.r_lock(1,1)
   || _ip:=P.IP;
      __F_ZATR.mod(P.F_ZATR().KOD,'P');
      _f_zatr:=P.F_ZATR;
      _docelowa:=P.F_ZATR().DOCELOWA;
      {? _delTab
      || _TAB_P.IP:=_del_ip:=P.IP;
         _TAB_P.NAZWISKO:=P.OSOBA().NAZWISKO;
         _TAB_P.PIERWSZE:=OSOBA.PIERWSZE;
         _TAB_P.PESEL:=OSOBA.PESEL;
         _TAB_P.add(1)
      ?};
      _loop:=P.del(1,1);
      {? _loop
      || {? _docelowa='T' & exec('slo_test','slo_slu','SLO_OSOB','ID',_ip,1)=0
::          Słownik SLO_OSOB jest uzupełniany w momencie "zatrudnienia" - zmiany formy współpracy na docelową. Tak więc
::          sprawdzanie "użycia" bieżącego rekordu tabeli P w tym słowniku ma sens tylko dla form docelowych.
         || SLO_OSOB.cntx_psh();
            SLO_OSOB.index('ID');
            SLO_OSOB.prefix(_f_zatr,_ip);
            {? SLO_OSOB.first()
            || {! |? SLO_OSOB.del() !}
            ?};
            SLO_OSOB.cntx_pop()
         ?};
         {? _loop=1 || _loop:=0
         |? _loop=4 || _loop:=P.next()
         |? _loop=5 || _loop:=P.prev()
         ?}
      || {? _delTab
         || {? _TAB_P.find_key(_del_ip) || _TAB_P.del(1) ?}
         ?};
         P.r_unlock();
         _loop:=P.next()
      ?}
   || _loop:=P.next()
   ?}
!};
P.cntx_pop();
F_ZATR.cntx_pop();
__F_ZATR.mod(_val,'P');
{? _delTab || _TAB_P || ~~ ?}


\ust_wym
::----------------------------------------------------------------------------------------------------------------------
::  UTW: EJ 12.10
:: OPIS: Wyliczenie wymiaru pracownika na dzień przekazany parametrem.
::   WE: _a [DATE] - Data badania stanu.
::   WY: wymiar etatu
::  OLD: \ust_wym/plf_nadg.fml
::----------------------------------------------------------------------------------------------------------------------
H.cntx_psh();
H.index('_HISTKOD');
H.prefix(P.ref(),'Z');
_wym:=0;
{? H.find_le(_a)
|| _wym:=H.WY
|| _wym:=P.WY
?};
H.cntx_pop();
_wym


\dza_stn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KO [12.30]
:: OPIS: Data zatrudnienia na stanowisku
::   WE: _a [_P] - wskazanie wiersza tabeli P
::       _b [_STN] - wskazanie wiersza tabeli STN
::   WY: data ostatniego zatrudnienia na podanym stanowisku lub data zerowa
::  OLD: \spr_dzat/szk_prac.fml
::----------------------------------------------------------------------------------------------------------------------
_zdate:=date(0,0,0);
_ret:=_zdate;
H.cntx_psh();
H.index('_HISTKOD');
H.prefix(_a,'Z');
_loop:=H.last();
{!
|? _loop
|! {? H.ST<>_b
   || _loop:=H.prev()
   || _ret:=H.OD;
      _loop:=0
   ?}
!};
H.cntx_pop();
_ret


\dane_pracownika
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.41]
:: OPIS: Procedura ma za zadanie zwrócić tabelę wypełnioną informacjami w okresie dla pracownika w buforze.
::      'ROK','INTEGER','Rok',
::      'MC','INTEGER','Miesiąc',
::      'D','INTEGER','Numer dnia',
::      'DATA','DATE','Data badania',
::      'D_TYP','STRING[2]','Typ dnia',
::      'NB','INTEGER','Kod nieobecności',
::      'NG','REAL','Liczba godzin nieobecności',
::      'NR','INTEGER','Dzień roboczy nieobecności',
::      'NK','INTEGER','Dzień kalendarzowy nieobecności',
::      'PARTDAY','STRING[1]','Nieobecność na część dnia',
::      'N_LT','STRING[8]','Znak listy nieobecności',
::      'WY','REAL','Wymiar zatrudnienia dla dnia',
::      'DG','REAL','Liczba godzin nominalnych',
::      'MG','REAL','Liczba godzin nominalnych w miesiącu',
::      'DGS','REAL','Liczba godzin nominał dla standardu,
::      'DR','INTEGER','Dzień roboczy',
::      'DRS','INTEGER','Dzień roboczy dla standardu',
::      'NORMA','REAL','Norma dzienna czasu pracy',
::      'CP','STRING[4]','Charakter pracy',
::      'S1','REAL','Płaca zasadnicza',
::      'S2','REAL','Dodatek funkcyjny',
::      'S3','REAL','Dodatek stały'
::      'DS1','REAL','Dzienna płaca zasadnicza',
::      'DS2','REAL','Dzienny dodatek funkcyjny',
::      'DS3','REAL','Dzienny dodatek stały',
::      'ODDEL','STRING[1]','Oddelegowanie do pracy za granicą'
::   WE: domyślnie okresem jest bieżacy miesiąc i bieżący pracownik
::       [_a] - P.ref lub nr ref
::       [_b] - okres od
::       [_c] - okres do
::       [_d] - 1 - bez ustalania obiektu __KAL
:        [_e] - 1 - do ustalenia daty kursu waluty ze sprawozdań GUS
::   WY: _tab - tabela z informacjami na każdy dzień okresu
::  OLD: \dane_pracownika/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null)
|| _P:=#_a
|? var_pres('_a')=type_of(0)
|| _P:=_a
|? var_pres('_a')=type_of('')
|| _P:=BIT.sqlint(_a)
|| _P:=#P.ref()
?};
_start:={? var_pres('_b')=type_of(date) || _b || date(,,1) ?};
_stop:={? var_pres('_c')=type_of(date) || _c || date(,,0) ?};
_bez_KAL:={? var_pres('_d')=type_of(1) || _d || 0 ?};
_wal_gus:={? var_pres('_e')=type_of(0) & _e || _e || ~~ ?};

:: Tabela wynikowa
_tab:=tab_tmp(3,'ROK','INTEGER','Rok',
   'MC','INTEGER','Miesiąc',
   'D','INTEGER','Numer dnia',
   'DATA','DATE','Data badania',
   'D_TYP','STRING[2]','Typ dnia',
   'NB','INTEGER','Kod nieobecności',
   'NG','REAL','Liczba godzin nieobecności',
   'NR','INTEGER','Dzień roboczy nieobecności',
   'NK','INTEGER','Dzień kalendarzowy nieobecności',
   'PARTDAY','STRING[1]','Nieobecność na część dnia',
   'N_LT','STRING[8]','Znak listy nieobecności',
   'WY','REAL','Wymiar zatrudnienia dla dnia',
   'DG','REAL','Liczba godzin nominalnych',
   'MG','REAL','Liczba godzin nominalnych w miesiącu',
   'DGS','REAL','Liczba godzin nominał dla standardu',
   'DR','INTEGER','Dzień roboczy',
   'DRS','INTEGER','Dzień roboczy dla standardu',
   'NORMA','REAL','Norma dzienna czasu pracy',
   'CP','STRING[4]','Charakter pracy',
   'S1','REAL','Płaca zasadnicza',
   'S2','REAL','Dodatek funkcyjny',
   'S3','REAL','Dodatek stały',
   'DS1','REAL','Dzienna płaca zasadnicza',
   'DS2','REAL','Dzienny dodatek funkcyjny',
   'DS3','REAL','Dzienny dodatek stały',
   'ODDEL','STRING[1]','Oddelegowanie do pracy za granicą'
   );
P.cntx_psh();
P.prefix();
{? ~P.seek(_P,) || P.cntx_pop(); return(_tab) ?};
:: Warunki na datę zatrudnienia i zwolnienia
{? P.DZA>_stop | (P.DZ<_start & P.DZ<>#0) || P.cntx_pop(); return(_tab) ?};
{? P.DZA>_start || _start:=P.DZA ?};
{? P.DZ<_stop & P.DZ<>#0 || _stop:=P.DZ ?};

{? var_pres('__KAL')<100
|| exec('declare','kalendarz');
   __KAL:=obj_new(@.CLASS.KALEND)
?};
:: ustawienie kalendarza pracownika z zapamiętaniem danych celem przywrócenia kalendarza
_kal_naz:=__KAL.nazwa;
_kal_rok:=__KAL.rok;
{? P.KAL & ~_bez_KAL
|| __KAL.set_cal(P.KAL,_start~1)
?};

:: Założenie podstawowych rekordów do tabeli - utworzenie rekordów tabeli na każdy dzień okresu
:: wypisanie danych z kalendarza
_do:=_stop;
{!
|? _do>=_start
|! _tab.blank();
   _tab.ROK:=_do~1;
   _tab.MC:=_do~2;
   _tab.D:=_do~3;
   _tab.DATA:=_do;
   _tab.D_TYP:=__KAL.type_day(_do);
   _tab.NORMA:=exec('norma','godziny',_do);
   _tab.DG:=__KAL.w_hours(_do,_do);
   _tab.DR:=__KAL.w_days(_do,_do);
   _tab.MG:=__KAL.w_hours(date(_do~1,_do~2,1),date(_do~1,_do~2,0))$2;
   _tab.add();
   _do-=1
!};

__KAL.set_cal('standard',_start~1);
_do:=_stop;
{!
|? _do>=_start
|! {? _tab.find_key(_do~1,_do~2,_do~3)
   || _tab.DGS:=__KAL.w_hours(_do,_do);
      _tab.DRS:=__KAL.w_days(_do,_do);
      _tab.put()
   ?};
   _do-=1
!};

N.cntx_psh();
H.cntx_psh();

H.index('_HISTKOD');
:: bieżace dane z przebiegu zatrudnienia
H.prefix(P.ref(),'Z');
{? H.find_le(_stop)
|| {!
   |? {? H.OD<=_stop & (H.DO>=_start | H.DO=#0)
      || _od:={? H.OD>_start || H.OD || _start ?};
         _do:={? H.DO<_stop & H.DO<>#0 || H.DO || _stop ?};
         {? _od<=_do
         || {!
            |? _do>=_od
            |! {? _tab.find_key(_do~1,_do~2,_do~3)
               || {? var_pres('_hsx')>100 || obj_del(_hsx) ?};
                  _hsx:=exec('hsx','lista_licz',_do,_do,_wal_gus);
                  _tab.WY:=H.WY; _tab.S1:=_hsx.S1; _tab.S2:=_hsx.S2; _tab.S3:=_hsx.S3; _tab.CP:=H.CP().S;
                  _tab.ODDEL:={? H.ODDEL='T' || 'T' || 'N' ?};
                  {? _tab.DG & _tab.MG
                  || {? -_tab.CP='umy'
                     || _tab.DS1:=(_hsx.S1/_tab.MG$2)*_tab.DG;
                        _tab.DS2:=(_hsx.S2/_tab.MG$2)*_tab.DG;
                        _tab.DS3:=(_hsx.S3/_tab.MG$2)*_tab.DG
                     || _tab.DS1:=_hsx.S1*_tab.DG;
                        _tab.DS2:=(_hsx.S2/_tab.MG$2)*_tab.DG;
                        _tab.DS3:=(_hsx.S3/_tab.MG$2)*_tab.DG
                     ?}
                  ?};
                  _tab.put
               ?};
               _do-=1
            !}
         ?}
      ?};
      H.prev() & H.DO>=_start
   !}
?};

:: pobranie danych z tabeli N
N.index('NIEOBECN');
N.prefix('N',P.ref);

{? N.find_le(_stop)
|| {!
   |? {? N.OD<=_stop & N.DO>=_start
      || _od:={? N.OD>_start || N.OD || _start ?};
         _do:={? N.DO<_stop || N.DO || _stop ?};
         {? _od<=_do
         || {!
            |? _do>=_od
            |! {? _tab.find_key(_do~1,_do~2,_do~3)
               || _tab.NB:=N.NB().RN;
                  _tab.PARTDAY:=N.PARTDAY; _tab.NG:={? N.PARTDAY='T' || N.NG || _tab.DG ?};
                  _tab.NR:=_tab.DR; _tab.NK:=1; _tab.N_LT:=N.LT;
                  _tab.put
               ?};
               _do-=1
            !}
         ?}
      ?};
      N.prev() & N.DO>=_start
    !}
?};
P.cntx_pop();
H.cntx_pop();
N.cntx_pop();
__KAL.set_cal(_kal_naz,_kal_rok);
_tab


\p_projekty_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.42]
:: OPIS: Przed wyświetleniem pola PROJEKTY
::----------------------------------------------------------------------------------------------------------------------
_val:={? +exec('uprawnieniawrap','pkd','Brak wymaganych uprawnień'@,'ZWS_PAR_KPRR','ZWS_PAR_KPRP')
          |
          KST.PROJZAKR='Nie dotyczy'
      || 0
      || 1
      ?};
_val


\p_projekty_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.28]
:: OPIS: Przed redakcją pola PROJEKTY
::----------------------------------------------------------------------------------------------------------------------
_val:=exec('p_projekty_efld_otp','pracownik');
{? _val
|| _val:=exec('projekty_be','projekty');
   ProjBez:='WM';
   PROJEKTY.win_dict('WER')
?};
_val


\p_projekty_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.28]
:: OPIS: Po redakcji pola PROJEKTY
::----------------------------------------------------------------------------------------------------------------------
exec('projekty_ae','projekty');

:: przywrócenie kontekstu osoby - w trakcie wyboru projektu możliwa jest zmiana tego kontekstu
{? OSOBA.ref()<>REF.OSOBA
|| REF.OSOBA()
?};
1


\p_projekty_efld_otp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.28]
:: OPIS: Formuła odpowiedzialna za dynamiczne ustawianie właściwości pola PROJEKTY tabeli P.
::       Formuła wywoływana jest w dwóch kontekstach pracy:
::          - Po redagowaniu konkretnego pola, które determinuje właściwości wyświetlania innych pól.
::          - Przed wyświetleniem okna redagowania (przed właściwymi akcjami Dołącz, Popraw, Wyświetl), ustawia
::            właściwości wszystkich pól (wymagających tego).
::       Kontekst pracy jest określany na podstawie argumentu wywołania.
::   WE: [_a] [STRING] - Akronim okna, w którym mają być ustawione właściwości pól.
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_we:={? var_pres('_a')=type_of('') || _a || cur_win(1,1) ?};

exec('czytaj','#stalesys',date(),KST,'PROJZAKR');
_val:=exec('p_projekty_bd','pracownik');
_sval:=$_val;

P.efld_opt(_we,'enable='+_sval,P,'PROJEKTY','NR');
P.efld_opt(_we,'enable='+_sval,P,'PROJEKTY','SYM');
P.efld_opt(_we,'enable='+_sval,P,'PROJEKTY','NAZWA');
_val


\h_oddel_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Po redagowaniu pola H.ODDEL - aktywowanie do edycji pola KODDEL.
::   WE:
::   WY: Informacja czy można zakończyć edycję w polu "Oddelegowanie".
::----------------------------------------------------------------------------------------------------------------------
_result:=1;

{? H.ODDEL='N' || H.KODDEL:='N' ?};
: Ustaleni aktywności akcji "Zakończ" w przegu zatrudnienia
exec('h_efld_opt','pracownik');

{? 2-!cur_tab()='H' & PAR_SKID.get(180)='T'
|| H.btn_opt(params_get().svc.BUTTON,
      'state='+{? H.ODDEL='T' || 'grayed' || 'normal' ?}
   )
?};

{? exec('h_oddel_editable','oddelegowanie',1)
:: Ustalenie dostępności pól do edycji w zakładce "Oddelegowania do pracy za granicą" w przebiegu zatrudnienia:
|| exec('acces2fld_h_odde','oddelegowanie',cur_tab(),cur_win(),H.ODDEL='T')
?};

:: Właściwe czyszczenie wartości pól H_ODDE odbywa się w \h_modb/!pkd_ezk_rpza.fml
{? H_ODDE.H=null()
|| exec('h_odde_blank','oddelegowanie')
?};

:: Zapisanie kursu waluty z przebiegu zatrudnienia do oddelegowania
{? H.ZWAL & ~H_ODDE.TKRS
|| H_ODDE.TKRS:=H.ZWAL
?};

_result


\h_koddel_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.42]
:: OPIS: Po redagowaniu pola H.KODDEL - sprawdzenie czy można zmienić wartość w polu.
::   WE:
::   WY: Informacja czy można zakończyć edycję w polu "Praca w kilku krajach".
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
H_ODDE.cntx_psh();
H_ODDE.use('h_odde'+(H.name()+1));
{? H.KODDEL='N'
   &
   sql('select distinct H_ODDE.KRAJ from H_ODDE join H using (H_ODDE.H,H.REFERENCE) where H.REFERENCE=\':_a\'',
      $H.ref()
   ).size()>1
|| FUN.emsg('%1\n%2'
      [  'Wprowadzono oddelegowania do kilku krajów.'@,
         'Zmiana wartości w polu "Praca w kilku krajach" nie jest możliwa.'@
      ]
   );
   H.KODDEL:='T';
   _result:=0
?};
H_ODDE.cntx_pop();
_result


\h_oddel_ask
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK[18.42]
:: OPIS: Sprawdzenie czy w podanym okresie pracownik był delegowany.
::   WE: _a - początek okresu
::       _b - koniec okresu
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
_start:=_a;
_stop:=_b;
_wynik:=0;
H.cntx_psh();
H.index('_HISTKOD');
H.prefix(P.ref(),'Z');
{? H.find_le(_stop)
|| {!
   |? {? H.OD<=_stop & (H.DO>=_start | H.DO=#0)
      || {? H.ODDEL='T'
         || _wynik:=1
         ?}
      ?};
      ~_wynik & H.prev() & H.DO>=_start
   !}
?};
H.cntx_pop();
_wynik


\otworz_h_um
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.42]
:: OPIS: Otwiera zbiór tabeli H_UM i właściwe dla niego zbiory tabel H_UM_E??
::   WE: _a [STRING] - nazwa zbioru tabeli H_UM
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & (_a='h_um' | _a='h_u_')
|| H_UM.use(_a)
?};

_mask:=H_UM.name();
H_UM_EKW.use(_mask+'_ekw');
H_UM_ESK.use(_mask+'_esk');

~~


\h_um_ekwiwalent_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.42]
:: OPIS: Wyświetla zawartość kartoteki zawierającej wyliczenia podstawy ekwiwalentu za niewykorzystany urlop.
::   WE: _a _H_UM - wskazanie umowy o pracę
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null) | _a=null | ref_tab(_a)<>H_UM
|| return()
?};
:: mapa argumentów
_um:=_a;

_epilog:="
   P.cntx_pop();
   OSOBA.cntx_pop();
   H_UM.cntx_pop();
   ~~
";

P.cntx_psh();
OSOBA.cntx_psh();
H_UM.cntx_psh();
H_UM.prefix();
{? H_UM.seek(_um)
|| {? H_UM.EKW=0 & H_UM.EKW_NSP=0
   || _epilog();
      return()
   ?};
   H_UM.P().OSOBA();

   H_UM_EKW.cntx_psh();
   exec('otworz_h_um','pracownik');
   H_UM_EKW.index('UNIQUE');

   H_UM_EKW.win_sel('GRP');
   H_UM_EKW.win_edit('RED');
   H_UM_EKW.win_patt('WZO');

:: Parametry wykorzystywane do zachowania i przywrócenia kontekstu przeglądania w zakładkach.
:: W przypadku dodania kolejnych zakładek należy zmodyfikować \grp_params/!ppl_pll_rume.fml
:: zmieniając sprawdzenie rozmiaru tablicy.
   _par:=obj_new(8);
   params_set('par',_par);
   {! _ii:=1..obj_len(_par)
   |! _par[_ii]:=obj_new('ndx','pos')
   !};
   H_UM_EKW.select();

   H_UM_EKW.cntx_pop()
?};

_epilog();
~~


\control_test
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DAROKR [12.51]
:: OPIS: Sprawdzenie czy dany pracownik jest w schemacie controllingu Personel
::   WE: _a - REF_SQL pracownika
::       _b - P.IP pracownika przed modyfikacja
::   WY: 1 możliwa zmiana pola P.IP lub 0 niemożliwa zmiana pola P.IP ponieważ jest już używany
::  OLD: \control_test/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_p_ref:=_a;
_ip:=_b;
_czy_mod:=1;
{? PAR_SKID.get(80)<>'T' | ~KST_PAR.SKID_MB
|| return(_czy_mod)
|| UD_TYP.cntx_psh();
   UD_SCH.cntx_psh();
   UD_SCH.index('TECH');
   UD_SCH.prefix();
   {? UD_SCH.find_key('STANPRAC','STR_PRAC',)
   || UD_SCH.UD_TYP().SYMBOL;
      UD_POW.cntx_psh();
      UD_POW.index('SQL');
      UD_POW.prefix(UD_TYP.ref(),_p_ref);
      {? UD_POW.first()
      || {!
         |? _sym:=UD_POW.SYMBOL+8;
            _sym:=#_sym;
            {? _sym=_ip
            || _czy_mod:=0
            ?};
            _czy_mod & UD_POW.next()
         !}
      || _czy_mod:=1
      ?};
      UD_POW.cntx_pop()
   || _czy_mod:=1
   ?};
   UD_SCH.cntx_pop();
   UD_TYP.cntx_pop()
?};
_czy_mod


\ustal_wydzial
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [19.42]
:: OPIS: Ustalenie bieżącego na podany argument wydzialu dla pracownika.
::   WE: _a - P.ref
::       [_b] - date - data badania, gdy bez argumentu uslala na date biezaca
::       [_c] 0 lub bez argument - UD_SKL.ref
::            1 - UD_SKL.SYMBOL
::            2 - UD_SKL.NAZWA
::   WY: UD_SKL.ref lub zgodnie z trzecim argumentem
::----------------------------------------------------------------------------------------------------------------------
_b:={? var_pres('_b')=type_of(date) || _b || date ?};
_c:={? var_pres('_c')=type_of(0) || _c || 0 ?};
H.cntx_psh;
H.index('_HISTKOD');
H.prefix(_a,'Z');
_wyn:=
   {? H.find_le(_b)
   || {? _c=1
      || H.WYDZIAL().SYMBOL
      |? _c=2
      || H.WYDZIAL().OPIS
      || H.WYDZIAL
      ?}
   || {? _c || '' || null ?}
   ?};
H.cntx_pop;
_wyn


\get_P_STAT
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [20.42]
:: OPIS: Zwraca status pracownika
::   WE: _a - wskazanie na pracownika
::       _b - kod statusu
::       [_c] - Ref listy
::   WY: 0 - nie udalo sie znalezc rekordu wlasciwego dla statusu, 1 - rekord statusu zostal znaleziony
:: UWAGA: poprawnosc argumentow wywolania nie jest weryfikowana
::  OLD: \get_P_STAT/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_lista:={? var_pres('_c')=type_of(null) || _c || null ?};
P_STAT.index('TECH');
P_STAT.prefix(_a,exec('kod','ext_slo','P_STAT',_b),_lista);
P_STAT.first()


\add_P_STAT
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [20.42]
:: OPIS: Dodaje status pracownika
::   WE: _a - wskazanie na pracownika
::       _b - kod statusu
::       [_c] [DATE] - data zdarzenia - domyślnie bieżąca
::       [_d] [TIME] - czas zdarzenia - domyślnie bieżący
::       [_e] [REF] - Ref listy
::       [_f] [STRING] - krotki opis
::   WY: powodzenie operacji
::  OLD: \add_P_STAT/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_data:={? var_pres('_c')=type_of(date) || _c || date() ?};
_godzina:={? var_pres('_d')=type_of(time) || _d || time() ?};
_lista:={? var_pres('_e')=type_of(null) || _e || null ?};
_opis:={? var_pres('_f')=type_of('') || _f || '' ?};

P_STAT.P:=_a;
P_STAT.SLO_KOD:=exec('kod','ext_slo','P_STAT',_b);
P_STAT.DATA:=_data;
P_STAT.GODZ:=_godzina;
P_STAT.O:=_lista;
P_STAT.KTO:=OPERATOR.USER;
P_STAT.OPIS:=_opis;
P_STAT.add


\put_P_STAT
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [20.42]
:: OPIS: Aktualizuje status pracownika
::   WE: _a - wskazanie na pracownika
::       _b - kod statusu
::       [_c] [DATE] - data zdarzenia - domyślnie bieżąca
::       [_d] [TIME] - czas zdarzenia - domyślnie bieżący
::       [_e] [REF] - REF listy
::       [_f] [STRING] - krotki opis
::   WY: powodzenie operacji
::  OLD: \put_P_STAT/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_data:={? var_pres('_c')=type_of(date) || _c || date() ?};
_godzina:={? var_pres('_d')=type_of(time) || _d || time() ?};
_lista:={? var_pres('_e')=type_of(null) || _e || null ?};
_opis:={? var_pres('_f')=type_of('') || _f || '' ?};

{? exec('get_P_STAT','pracownik',_a,_b,_lista)
|| P_STAT.OPIS:=_opis;
   P_STAT.DATA:=date;
   P_STAT.GODZ:=time;
   P_STAT.O:=_lista;
   P_STAT.KTO:=OPERATOR.USER;
   P_STAT.put
|| exec('add_P_STAT','pracownik',_a,_b,_data,_godzina,_lista,_opis)
?}


\del_P_STAT
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [20.42]
:: OPIS: Usuwa wszystklie wystapienia statusu pracownika. Jeżeli zostanie podany znak listy, to usunie tylko dla podanej
::   WE: _a - wskazanie na pracownika
::       _b - kod statusu
::       [_c] - [REF] - Ref listy płac
:: UWAGA: poprawnosc argumentow wywolania nie jest weryfikowana
::  OLD: \del_P_STAT/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_lista:={? var_pres('_c')=type_of(null) || _c || null ?};
P_STAT.index('TECH');
P_STAT.prefix(_a,exec('kod','ext_slo','P_STAT',_b),_lista);
{? P_STAT.first()
|| {! |? P_STAT.del() !}
?}


\add_etypproc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MP [20.42]
:: OPIS: Dodaje rekordy etypproc
::   WE: kontekst rekordu P
::----------------------------------------------------------------------------------------------------------------------
ETYPPROC.cntx_psh();
ETYPPROC.index('UNIK');
ETYPPROC.prefix();
{? ETYPPROC.first()
|| {!
   |? ETYPY.cntx_psh();
      _act:={? exec('EDOKUM_typ','portal_seod','W',,ETYPPROC.ETYPY().TYPOBIEG) || 'OBE_FAW_DARP' || 'OBE_FDL_DBRP' ?};
      ETYPY.cntx_pop();
      _usrs:=exec('get_proc_users','#b__box',ETYPPROC.PROC_SYM,ETYPPROC.PROC_VER,_act);
      OSOBA.cntx_psh();
      {? _usrs.first()
      || {!
         |? {? _usrs.OSOBA=$P.OSOBA
            || exec('add_etypy_p','obiegi2',P.ref(),ETYPPROC.ETYPY,ETYPPROC.FIRMA)
            ?};
            _usrs.next()
         !}
      ?};
      &_usrs; OSOBA.cntx_pop();
      ETYPPROC.next()
   !}
?};
ETYPPROC.cntx_pop();
~~


\init_desc_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [20.42]
:: OPIS: Tworzy i inicjalizuje tablicę nazwaną dla elementów opisu czynności.
::   WE:
::   WY: tablica nazwana
::----------------------------------------------------------------------------------------------------------------------
_tab:=obj_new(
:: Czy tablica zawiera dane [T/N]
   'ZAW_DANE',
:: Nazwisko osoby
   'NAZWISKO',
:: Pierwsze imię osoby
   'PIERWSZE',
:: Czy osoba jest obcokrajowcem [T/N]
   'OBCY',
:: Numer paszportu
   'PASZPORT',
:: PESEL osoby
   'PESEL',
:: Data urodzenia osoby
   'UR_DATA',
:: Numer teczki (w aktach)
   'T',
:: Identyfikator jednostki organizacyjnej
   'UD_SKL',
:: Nazwa stanowiska
   'STN',
:: Identyfikator pracownika
   'IP'
);
{! _ii..obj_len(_tab) |! _tab[_ii]:='' !};
_tab


\dezaktywacja_error
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MicKoc [20.42]
:: OPIS: Słownik komunikatów o błędach.
::   WE: _a [INTEGER] - Rodzaj komunikatu
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_a:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_dk:='Dezaktywacja konta.'@;
{? _a=1
|| '%1\nPracownik nie jest użytkownikiem systemu.'@[_dk]
|? _a=2
|| '%1\nPracownik jest zatrudniony na innym etacie.'@[_dk]
|? _a=3
|| '%1\nNie znaleziono pracownika.'@[_dk]
|| '%1\nOperacja nie powiodła się.'@[_dk]
?}


\dezaktywuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MicKoc [20.42]
:: OPIS: Właściwa formuła obsługująca zwolnienie pracownika.
::   WE: _a [REFERENCE] - Wskazanie pracownika do zwolnienia.
::       _b [DATE] - Data badania.
::   WY: Tablica z informacjami o dezaktywacji.
::----------------------------------------------------------------------------------------------------------------------
_ret:=obj_new('STATUS','OK');
_ret.STATUS:=exec('dezaktywacja_error','pracownik');
_ret.OK:=0;

_p_ref:={? (var_pres('_a')=type_of(null()) & _a<>null()) | (var_pres('_a')=type_of('') & +|_a)
        || _a
        || return(_ret)
        ?};
 _data:={? var_pres('_b')=type_of(date()) || _b || date() ?};

:: powrot w przypadku zerwanej transakcji
{? do_state()=2 || return(_ret) ?};

_ret.STATUS:='';
_ret.OK:=1;

P.cntx_psh();
P.index('OSOBA');
P.prefix();
{? P.seek(_p_ref)
|| USERS.cntx_psh();
   USERS.index('OSOBA');
   USERS.prefix(P.OSOBA);
:: jeżeli pracownik jest zwolniony we wszystkich firmach to blokujemy konto
   P.prefix(P.OSOBA);
   _aktywne_zatr:=P.size();
   {? P.first()
   || {!
   |? {? (P.DZ<>#0) & (P.DZ<=_data) || _aktywne_zatr-=1 ?};
         P.next()
      !}
   ?};
   {? _aktywne_zatr=0
   || _mydo:=do_state()=0;
      {? _mydo || do() ?};
::    dajemy pętlę po wszystkich usersach osoby, choć w wersji 20.42 już powinniśmy mieć powiązanie jeden do jednego
      {? USERS.first()
      || {!
         |? {? USERS.PXPRAC<>1 | USERS.PXKIER<>1
::             ustawiamy blokadę na dostęp dla pracownika i kierownika
            || USERS.PXPRAC:=USERS.PXKIER:=1;
                  USERS.put()
               ?};
               USERS.next()
         !}
      || _ret.STATUS:=exec('dezaktywacja_error','pracownik',1);
         _ret.OK:=1
      ?};
      {? _mydo || end() ?}

      || _ret.STATUS:=exec('dezaktywacja_error','pracownik',2);
         _ret.OK:=1
      ?};
      USERS.cntx_pop()
   || _ret.STATUS:=exec('dezaktywacja_error','pracownik',3);
      _ret.OK:=1
?};
P.cntx_pop();
_ret


\dezaktywuj_konto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MicKoc [20.42]
:: OPIS: Wywołanie dezaktywacji konta z aktualizacji zatrudnienia
::   WE: _a [STRING] - Uidref pracownika
::       _b [DATE] - badanie na dzień
::----------------------------------------------------------------------------------------------------------------------
_vp:=var_pres('_a');
{? _vp=-1
|| _ref:=P.uidref()
|? (_vp=type_of('') & (+_a=16 | +_a=48)) | (_vp=type_of(null()) & _a<>null())
|| _ref:=_a
|| return(0)
?};
{? var_press('_b')=type_of(date) & _b<>#0
|| _data:=_b
|| _data:=date()
?};
_dni:=#PAR_SKID.get(275);
{? _dni<0 || _dni:=0 ?};
_data:=#((#_data)-_dni);

exec('dezaktywuj','pracownik',_ref,_data)


\autouzu_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [20.42]
:: OPIS: Zwraca ref pracownika na podstawie podanego ciągu znaków (np. początek nazwiska) jeśli znajdzie jednoznacznego.
::   WE: _a [STRING] - ciąg znaków, np. początek nazwiska
::       _b [STRING] - kod dziedziny produktowej
::      [_c][STRING] - kody form współpracy oddzielone przecinkami (np. 'P,Z,p')
::      [_d][INTEGER]- 0/1 - czy zwracać tabelę z wieloma pracownikami (niejednoznaczne znalezienie), domyślnie 0
::      [_e][STRING] - Opcjonalne WHERE dla zapytania SQL.
::   WY: tabela tymczasowa z danymi pracownika lub null() jeśli nie znaleziono jednoznacznego
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('') | ~+_a || return(~~) ?};
_osoba:=spli_str(form(_a),' ');
_kod:={? var_pres('_b')=type_of('') || _b || '' ?};
_fZatr:={? var_pres('_c')=type_of('') || _c || exec('kody','f_zatr') ?};
_all:={? var_pres('_d')=type_of(0) || _d || 0 ?};
_where:={? var_pres('_e')=type_of('') || _e || '' ?};

_query:=
   'select P.REFERENCE as REF, OSOBA.NAZWISKO, OSOBA.PIERWSZE '
   'from P '
   'join OSOBA using(P.OSOBA, OSOBA.REFERENCE) '
   'join :_a using (P.REFERENCE, :_a.REF) '
   'where ';
_w2:='';
_osobaLen:=obj_len(_osoba);
{! _ii:=1.._osobaLen
|! _w2+='(OSOBA.NAZWISKO like \':_%1\%\')'[%(_ii+97)];
   {? _ii<_osobaLen
   || _w2+=' or '
   ?}
!};
_query+={? _where='' || '' || _where+' and ' ?}+'(%1)' [_w2];
_query+=
   ' order by OSOBA.NAZWISKO';

_sql:='sql(_a,exec(\'dostepne_p\',\'schemat\',_b,_c)';
{! _ii:=1.._osobaLen
|! _sql+=',_d[%1]'[$_ii]
!};
_sql+=')';
_OSOBY:=($_sql)(_query,_kod,_fZatr,_osoba);

{? _OSOBY.size()=1 | (_OSOBY.size()>0 & _all)
|| _OSOBY
|| null()
?}


\h_um_ru_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.14]
:: OPIS: Przed wyświetleniem pola RU tabeli H_UM.
::   WE:
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
params_exec('h_um_btn_repl','pracownik')


\h_um_ru_zastepstwo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.14]
:: OPIS: Sprawdzenie, czy umowa o pracę jest umową na zastępstwo.
::   WE:
::   WY: 0/1 - nie/tak
::----------------------------------------------------------------------------------------------------------------------
H_UM.RU().K='D' | H_UM.OKR_UZAS().KOD='1'


\h_um_btn_repl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.14]
:: OPIS: Aktywuje/dezaktywuje przycisk "Zastępstwo".
::   WE:
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
_btn:='';
_par:=params_get();
{? type_of(_par)<100
:: brak kontekstu
|| return(1)
?};

{? var_pres('svc',_par)>100 & var_pres('BTN_REPL',_par.svc)=type_of('')
:: obsługa z poziomu edycji umowy o pracę
|| _btn:=_par.svc.BTN_REPL

|? var_pres('cfg',_par)>100 & var_pres('btnZAST',_par.cfg)=type_of('')
:: obsługa z poziomu nawiązywania współpracy
|| _btn:=_par.cfg.btnZAST

|| return(1)
?};

_opt:='state=grayed';
{? exec('h_um_ru_zastepstwo','pracownik')
|| _opt:='state=normal'
?};

_TAB:=cur_tab();
_TAB.btn_eopt(_TAB.win_edit('?'),_btn,_opt);

1


\h_um_zastepstwo_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.14]
:: OPIS: Obsługa akcji "Zastępstwo" w okienkach wertowania tabeli H_UM.
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
params_exec('zastepstwo','pracownik',1);
~~


\zastepstwo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.14]
:: OPIS: Obsługa przycisku "Zastępstwo".
::   WE: _a INTEGER - tryb działania: 0 lub brak - edycja, <>0 - wyświetlenie
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_mod:={? var_pres('_a')=type_of(0) || _a=0 || 1 ?};

P.cntx_psh();
OSOBA.cntx_psh();
EDIT_VAR.cntx_psh();
EDIT_VAR.win_edit('P_ZAS');

{? _mod=0
|| EDIT_VAR.display()
|| _zas:=H_UM.P_ZAS;
   _opt:='state=%1'[{? H_UM.P_ZAS<>null || 'normal' || 'grayed' ?}];
   EDIT_VAR.btn_eopt('P_ZAS','OK',_opt);
   {? ~EDIT_VAR.edit()
   || H_UM.P_ZAS:=_zas
   || {? H.WYDZIAL=null & H.POZWORG=null() & H.ST=null & H.CP=null
::       uzupełnij zatrudnienie na podstawie umowy zastępowanego
      || _wyd:=null;
         _poz:=null;
         _st:=null;
         _cp:=null;
         _wy:=0;
         _wyl:=0;
         _wym:=0;
         _mpr:='';
         H.cntx_psh();
         H.use('_hist');
         H.index('_HISTKOD');
         H.prefix(H_UM.P_ZAS,'Z');
         {? H.find_le(H_UM.OD)
         || _wyd:=H.WYDZIAL;
            _poz:=H.POZWORG;
            _st:=H.ST;
            _cp:=H.CP;
            _wy:=H.WY;
            _wyl:=H.WYL;
            _wym:=H.WYM;
            _mpr:=H.MIEJSCE
         ?};
         H.cntx_pop();
         H.WYDZIAL:=_wyd;
         H.POZWORG:=_poz;
         H.ST:=_st;
         H.CP:=_cp;
         H.WY:=_wy;
         H.WYL:=_wyl;
         H.WYM:=_wym;
         H.MIEJSCE:=_mpr;
         exec('edit_var_h_wyd_bd','pracownik');
         exec('edit_var_h_st_bd','pracownik');
         exec('edit_var_h_psto_bd','pracownik');
         win_disp()
      ?}
   ?}
?};

EDIT_VAR.cntx_pop();
OSOBA.cntx_pop();
P.cntx_pop();
~~


\p_zas_wybierz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.14]
:: OPIS: Wybór zastępowanego współpracownika.
::   WE:
::   WY: ''
::----------------------------------------------------------------------------------------------------------------------
_arg:=exec('wybierz_args','pracownik');
_arg.DOMAIN:='PKD';
_arg.F_ZATR:='*T';
_P:=exec('wybierz','pracownik',_arg).P;

{? _P.first() & P.seek(_P.SQL,,1)
|| H_UM.P_ZAS:=P.ref();
   _opt:='state=%1'[{? H_UM.P_ZAS<>null || 'normal' || 'grayed' ?}];
   EDIT_VAR.btn_eopt('P_ZAS','OK',_opt)
?};
''


\p_zas_zs_def
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.14]
:: OPIS: Wyświetlenie informacji o zależnościach służbowych zastępowanego pracownika.
::   WE: _a _P - wskazanie wiersza w tabeli P
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null) | _a=null | ref_tab(_a)<>P
:: wymagane wskazanie wiersza tabeli P
|| return()
?};
:: mapa argumentów
_ref:=_a;
_msg:='';

P.cntx_psh();
OSOBA.cntx_psh();
SEEK.P:=_ref;
ZS_DEF.cntx_psh();
ZS_TYP.cntx_psh();
ZS_TYP.index('TREE');
ZS_TYP.prefix(exec('ref_firma','ustawienia'),0);
_loop:=ZS_TYP.first();
{!
|? _loop
|! _def:=exec('szukaj','zs_def',_ref,ZS_TYP.SLO_KOD,1);
   {? _def.REF<>null
::    znaleziono zależność służbową
   || _msg+='\n\n'+ZS_TYP.SLO_KOD().NAZWA;
      {? _def.REF_NAD<>null & ZS_DEF.seek(_def.REF_NAD,,1)
      || _msg+='\n\t- jest podwładnym, bezpośredni przełożony: %1'[ZS_DEF.NAZWA]
      ?};
      {? _def.LICZ_POD<>0
      || _msg+='\n\t- jest przełożonym, liczba bezpośrednich podwładnych: %1'@[$_def.LICZ_POD]
      ?}
   ?};
   obj_del(_def);
   _loop:=ZS_TYP.next()
!};

{? _msg<>''
|| SEEK.P().OSOBA();
   FUN.info(
      'Pracownik %1 %2 (%3) jest uwzględniony w zależnościach:%4\n\n'
      'Należy zweryfikować relacje przełożony-podwładny.'@
      [OSOBA.NAZWISKO,OSOBA.PIERWSZE,P.T,_msg]
   )
?};

:: porządki
ZS_TYP.cntx_pop();
ZS_DEF.cntx_pop();
OSOBA.cntx_pop();
P.cntx_pop();
~~


\h_stat_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [20.14]
:: OPIS: Wyświetla okienko wertowania tabeli H_STAT. Akcja Status w okienku tabeli H.
::   WE:
::   WY:
::  OLD: \status/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
USERS.cntx_psh();
H_STAT.index('KOD');
H_STAT.prefix(H.ref());
H_STAT.index('NAZWA');
H_STAT.prefix(H.ref());
H_STAT.win_sel('WER');
H_STAT.hdr_sel(' '+H.P().OSOBA().NAZWISKO+' '+OSOBA.PIERWSZE);
H_STAT.select();
USERS.cntx_pop()


\h_stat_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [20.14]
:: OPIS: Dodanie statusu tabela H_STAT  - akcja Status typu menu - w okienku WER tabeli H_STAT
::       _a - wskazanie na aneks do umowy
::       _b - kod statusu
::       [_c] - krótki opis
:: UWAGA: Poprawność argumentów wywołania nie jest weryfikowana.
::  OLD: \add_stat/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
H_STAT.prefix(_a);
H_STAT.blank(1);
H_STAT.H:=_a;
H_STAT.SLO_KOD:=exec('kod','ext_slo','H_STAT',_b);
H_STAT.DATA:=date();
H_STAT.GODZ:=time();
H_STAT.KTO:=OPERATOR.USER;
H_STAT.OPIS:={? var_pres('_c')=type_of('') || _c || 'Wprowadzono przez operatora' ?};
H_STAT.add()


\h_stat_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [20.14]
:: OPIS: Usuwa status aneksu do umowy o pracę.
::   WE: [_a] - wskazanie na aneks do umowy o pracę
::       [_b] - kod statusu
:: UWAGA: Poprawność argumentów wywołania nie jest weryfikowana.
::  OLD: \del_stat/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
_H:={? var_pres('_a')=7 || _a || H.ref() ?};
_status:={? var_pres('_b')=type_of('') || _b || H_STAT.SLO_KOD().KOD ?};
{? exec('h_stat_get','pracownik',_H,_status)
|| {? FUN.ask('Czy usunąć bieżący wiersz?'@)
   || H_STAT.del()
   ?}
?}


\h_stat_get
::----------------------------------------------------------------------------------------------------------------------
::  UTW:areKc [20.14]
:: OPIS: Zwraca status aneksu do umowy o pracę.
::   WE: _a - wskazanie na aneks do umow
::       _b - kod statusu
::   WY: 0 - nie udało sie znaleźć rekordu właściwego dla statusu, 1 - rekord statusu został znaleziony
:: UWAGA: Poprawność argumentów wywołania nie jest weryfikowana.
::  OLD: \get_stat/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('H_STAT',@)<0
|| return(0)
?};
H_STAT.index('KOD');
H_STAT.prefix(_a);
H_STAT.find_key(_b,_b)


\h_stat_czy_tarcza
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [20.14]
:: OPIS: Ustalenie czy przebieg związany z tarczą
::   WE: [_a] - date - data badania - bez argumenta bieżąca
::       [_b] - STRING - ewentualnie kod zmiany - jeśli nie wypełniony bada dwa kody dla tarczy
::   WY: 1 - jeśli tarcza
::  OLD: \h_czy_tarcza/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('H_STAT',@)<0
|| return(0)
?};

_data:={? var_pres('_a')=type_of(date) || _a || date ?};
_KOD:={? var_pres('_b')=type_of('') || _b || '' ?};
_wyn:=0;
H.cntx_psh;
H.index('_HISTKOD');
H.prefix(P.ref,'Z');
{? H.find_le(_data)
|| {? _KOD<>''
   || _wyn:=exec('h_stat_get','pracownik',H.ref(),_KOD)
   || _wyn:=(exec('h_stat_get','pracownik',H.ref(),'T_ZM_WYM') | exec('h_stat_get','pracownik',H.ref(),'T_ZM_WAR'))
   ?}
?};
H.cntx_pop;
_wyn


\repair_nkor
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DG [21.14]
:: OPIS: Naprawa błędnych nieobecności korygowanych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_n_refs:=tab_tmp(1,'REF','INTEGER',,'TYP','STRING[1]',);
N.cntx_psh();
_ndx_tmp:=N.ndx_tmp('',1,'KOR',,0,'RODZAJ',,0);
N.index(_ndx_tmp);
N.prefix('T','X');
{? N.first()
|| {!
   |? _n_kor:=#N.ref();
      N.cntx_psh();
      N.index('NIEOTREE');
      N.prefix(_n_kor);
      _n_refs.TYP:={? ~N.first() || 'Z' || 'R' ?};
      _n_refs.REF:=_n_kor;
      _n_refs.add();
      N.cntx_pop();
      N.next()
   !}
?};
N.ndx_drop(_ndx_tmp);
N.cntx_pop();

{? _n_refs.first()
|| {!
   |? N.cntx_psh();
      N.clear();
      {? N.seek(_n_refs.REF)
      || _locked:=exec('blk_lock','#table','N',N.ref,,1);
         {? _locked
         || {? _n_refs.TYP='Z'
            || N.KOR:='N';
               N.RODZAJ:='Z'
            || N.RODZAJ:='R'
            ?};
            N.put();
            exec('blk_unlock','#table','N',N.ref)
         ?}
      ?};
      N.cntx_pop();
      _n_refs.next()
   !}
?};
&_n_refs;
~~


\por_zalacz4osoba
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.42]
:: OPIS: Formuła zmieniająca znacznik modyfikacji rekordu załącznika "osobowego".
::       Po dodaniu P dla istniejącego wcześniej OSOBA zachodzi potrzeba wysłania załaczników "osobowych".
::   WE: _a [REFERENCE] - Wskazanie osoby.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
ZALACZ.cntx_psh();
ZALACZ.f_clear();
ZALACZ.index('S1');
ZALACZ.prefix(_a);
{? ZALACZ.first()
|| ZALACZ.trig_off('*','*');
   {!
   |? {? ZALACZ.P=null()
      || ZALACZ.put(,1)
      ?};
      ZALACZ.next()
   !};
   ZALACZ.trig_on('*','*')
?};
ZALACZ.cntx_pop();
~~


\p_portal_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [20.42]
:: OPIS: Formuła ustala wartość początkową pola P.PORTAL. Wykorzystywana jest również w wyzwalaczach tabeli P
::       (add przed i put przed) w związku z różną obsługą dla docelowych form współprcay i niedocelowych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? exec('lic','#b_domain','POR')
|| _typ:=XINFO.POR_CONF;
   _p0:=XINFO.POR0PPOR;
   _p_:=XINFO.POR_PPOR;
   exec('czytaj','#stalesys',,XINFO,'POR_CONF','POR0PPOR','POR_PPOR');
   _blank:=
      {? XINFO.POR_CONF='W'
      || {? XINFO.POR0PPOR='T' || XINFO.POR0PPOR || 'N' ?}
      || {? XINFO.POR_PPOR='T' || XINFO.POR_PPOR || 'N' ?}
      ?};
   XINFO.POR_PPOR:=_p_;
   XINFO.POR0PPOR:=_p0;
   XINFO.POR_CONF:=_typ;
   _blank
|| 'N'
?}


\h_um_do_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Przed redagowaniem pola H_UM.DO
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? H_UM.DO=date(0,0,0) & H_UM.OD<>date(0,0,0)
|| _plg_do:=Plugin.run('PKD_H_UM_DO_001', RU.K, H_UM.OD);
   H_UM.DO:=_plg_do
?};
1


\restrict
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KGS [20.42]
:: OPIS: restrykcje do kasowania rekurencyjnego danych
::       Mechanizm wyświetla listę powiązanych tabel do tabeli P lub OSOBA
::       z wyłączeniem tabel wskazancyh funkcją _Radd('TABELA'), których usunięcie jest oprogramowane
::       w wyzwalaczu przed del (\p_delb/pracownik.fml)
::   WE: _a - akronim tabeli [STRING] ('P' lub 'OSOBA')
::  OLD: \restrict/osoba.fml
::----------------------------------------------------------------------------------------------------------------------
VAR_DEL.delete('__Rtb');
_clear:="VAR_DEL.delete('__Rtb');
         prgs_clr();
         {? _=1 & var_pres('_a')=type_of('')
         || FUN.emsg('Działanie funkcji przerwane przez użytkownika.'@)
         |? _=2 & var_pres('_a')=type_of(~~) & var_pres('_b')>100
         || {? _b.first & FUN.ask('Usunięcie informacji z kartoteki nie jest możliwe.\n'@+
                                  'Zapis jest wykorzystywany.\n'@+
                                  'Wyświetlić listę powiązań?'@)
            || _comm:=sql('select distinct :_a.TABELA as TABELA,\\\''+(60*' ')+'\\\' as OPIS from :_a order by 1',_b);
               {? _comm.first
               || {!
                  |? _comm.OPIS:=($_comm.TABELA)().comment;
                     _comm.put(1);
                     _comm.next
                  !}
               ?};
               _wina:=_comm.mk_sel(,,,'prdo_restrict');
               _comm.win_sel(_wina);
               _comm.win_fld(_wina,,'TABELA',,,,,,,,'Tabela w której występują powiązania'@);
               _comm.win_fld(_wina,,'OPIS',,,,,,,,'Opis'@);
               _comm.hdr_sel('Powiązania:'@);
               _comm.select
            ?}
         ?}
        ";
progress(0,'Trwa weryfikacja żądania usunięcia zapisu.\n'+
           'Proszę czekać, operacja może być czasochłonna.',FUN.TYT,1);

__Rtb:=tab_tmp(,'TAB','STRING[8]','Tabela');
_Radd:="{? _<>1 || return(0) ?}; __Rtb.TAB:=_a; __Rtb.add(1)";

:: funkcja testu restrykcji
:: _a - _link - tabela wynikowa testlink [TABLE]
_valid:="__Rtb.prefix();
         {? __Rtb.first
         || {!
            |? _a.prefix(__Rtb.TAB,__Rtb.TAB);
               {? _a.first || {!|? _a.del !} ?};
               __Rtb.next
            !}
         ?};
         _a.prefix();
         {? _a.size=0 || 1 || 0 ?}
         ";

_sloosob:="_wyn:=1;
           SLO_OSOB.cntx_psh();
           SLO_OSOB.prefix();
           _a.prefix('SLO_OSOB','SLO_OSOB');
           {? _a.first
           || {!
              |? {? SLO_OSOB.seek(_a.REF,_a.MASKA)
                 || _wyn:={? exec('slo_test','slo_slu','SLO_OSOB','ID',SLO_OSOB.ID,1)=0 || 1 || 0 ?}
                 ?};
                 _wyn & _a.next
              !}
           ?};
           SLO_OSOB.cntx_pop();
           _wyn
         ";


{? _a='OSOBA'
|| {? var_pres('_link')>0 || &_link ?};
   _link:=OSOBA.testlink(,OSOBA.count);
   {? var_pres('_link')<100 || _clear('msg'); return(0) ?};

   _ndx0:=_link.index('?');
   _ndx:=_link.ndx_tmp(,1,'TABELA',,,'TABELA',,);
   _link.index(_ndx);
   {? ~_sloosob(_link) ||  _link.index(_ndx0); _link.ndx_drop(_ndx);_clear(,_link); return(0) ?};
   _Prac:=sql('select * from :_a where :_a.TABELA=\'P\'',_link);

   _Radd('P');
   _Radd('GIODO');
   _Radd('OS_ADRES');
   _Radd('OS_NOTKA');
   _Radd('PKO');
   _Radd('STAZ');
   _Radd('SLO_OSOB');
   _Radd('P_INFO');
   _Radd('OS_SZKOL');
   _Radd('ZJ');
   _Radd('RD');
   _Radd('ZALACZ');
   _Radd('WOJ');
   _Radd('OS_US');
   _Radd('STRST_P');
   _Radd('ULGI_POD');
   _Radd('KART_DOD');
   _Radd('OS_VIEW');
   _Radd('OV_UPR');
   _Radd('ZUS_RAP');

   {? ~_valid(_link) || _link.index(_ndx0); _link.ndx_drop(_ndx); _clear(,_link); return(0) ?};
   _link.index(_ndx0); _link.ndx_drop(_ndx); &_link
?};

{? _a='P' | (_a='OSOBA' & var_pres('_Prac')>100 & _Prac.first)
|| __Rtb.erase();
   _Radd('H');
   _Radd('H_UM');
   _Radd('P_IPOD');
   _Radd('BDO');
   _Radd('R_WZCZ');
   _Radd('R_MARG');
   _Radd('R_PRACDN');
   _Radd('R_SPEC');
   _Radd('STRST_P');
   _Radd('ZALACZ');
   _Radd('OS_VIEW');
   _Radd('OV_UPR');
   _Radd('ZP_DET');
   _Radd('P_GR');
   _Radd('P_GR_P');
   _Radd('P_GR_PW');
   _Radd('P_WEB_CX');
   _Radd('P_WEB_CL');
   _Radd('R_SZYCH');
   _Radd('STP');
   _Radd('PKALSYNC');
   _Radd('BIPODB');
   _Radd('P_STAT');
   _Radd('KAL_BUFF');
   _Radd('N_AH');
   _Radd('P_ODDEL');
   _Radd('PLOB_P');
   _Radd('PLOB_PB');
   _Radd('R_ERRKAL');
   _Radd('R_ERRMAX');

   {? _a='OSOBA'
   || P.cntx_psh();
      P.prefix();
      {!
      |? {? P.seek(_Prac.REF,_Prac.MASKA)
         || {? var_pres('_link')>0 || &_link ?};
            _link:=P.testlink(,P.count);
            {? var_pres('_link')<100 || P.cntx_pop(); _clear('msg'); return(0) ?};

            _ndx0:=_link.index('?'); _ndx:=_link.ndx_tmp(,1,'TABELA',,,'TABELA',,);
            _link.index(_ndx);
            {? ~_valid(_link) || _link.index(_ndx0); _link.ndx_drop(_ndx); P.cntx_pop(); _clear(,_link); return(0) ?};
            _link.index(_ndx0); _link.ndx_drop(_ndx); &_link
         ?};
         _Prac.next
      !};
      P.cntx_pop()
   |? _a='P' & #P.ref
   ||
      {? var_pres('_link')>0 || &_link ?};
      _link:=P.testlink(,P.count);
      {? var_pres('_link')<100 || _clear('msg'); return(0) ?};

      _ndx0:=_link.index('?'); _ndx:=_link.ndx_tmp(,1,'TABELA',,,'TABELA',,);
      _link.index(_ndx);
      {? ~_valid(_link) || _link.index(_ndx0); _link.ndx_drop(_ndx); _clear(,_link); return(0) ?};
      _link.index(_ndx0); _link.ndx_drop(_ndx); &_link
   ?}
?};

_clear();
1


\p_gp_def_pt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [22.26]
:: OPIS: Wzorzec dla pola GP_DEF tabeli P.
::   WE:
::   WY: ''
::----------------------------------------------------------------------------------------------------------------------
exec('filtruj_def','gp_api','PKD');
''


\p_gp_def_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [22.26]
:: OPIS: Przed wyświetleniem pola GP_DEF tabeli P.
::   WE:
::   WY: 0/1 - wartość ukryta/widoczna
::----------------------------------------------------------------------------------------------------------------------
exec('is_active','gp_api')<>0


\p_gp_def_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [22.26]
:: OPIS: Przed edycją pola GP_DEF tabeli P.
::   WE:
::   WY: 0/1 - edycja zablokowana/możliwa
::----------------------------------------------------------------------------------------------------------------------
{? exec('is_active','gp_api')
|| exec('p_gp_can_mod','pracownik',P.ref())
?}


\p_gp_def_efld_otp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [22.26]
:: OPIS: Formuła odpowiedzialna za dynamiczne ustawianie właściwości pola GP_DEF tabeli P.
::   WE: [_a] [STRING] - Akronim okna, w którym mają być ustawione właściwości pól.
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_wnd:={? var_pres('_a')=type_of('') || _a || cur_win(1,1) ?};
_isa:=exec('is_active','gp_api');

P.efld_opt(_wnd,'enable=%1,mark=%1'[$_isa],,'GP_DEF');

_isa<>0


\p_gp_can_mod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [22.26]
:: OPIS: Formuła sprawdza, czy informacja o grupie współpracownika może być zmodyfikowana.
::   WE: _a [_P] - wskazanie współpracownika
::   WY: 0/1 - możliwość modyfikacji P.GP_DEF (0-nie/1-tak)
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_ref:=_a;

_mod:=0;
P_GP.cntx_psh();
P_GP.index('OD');
P_GP.prefix(_ref);
_mod:=(P_GP.size()<=1);
P_GP.cntx_pop();
_mod


\h_s4_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Po redagowaniu pola H.S4.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? H.S4<0
|| H.S4:=0
?};
exec('h_efld_opt','pracownik')


\h_czywal4_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Przed wyświetleniem pola H.CZYWAL4.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
H.S4>0


\h_czywal4_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Po redagowaniu pola H.CZYWAL4.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('h_efld_opt','pracownik')


\h_um_p_od_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Przed redagowaniem pola H.P_OD
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
~~


\h_um_p_do_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Przed redagowaniem pola H.P_DO
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
~~


\h_um_p_od_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Po redagowaniu pola H.P_OD
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
~~


\h_um_p_do_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Po redagowaniu pola H.P_DO
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_d0:=date(0,0,0);
{? H_UM.OD=_d0
|| {? H_UM.P_OD<>_d0
   || H_UM.OD:=H_UM.P_OD
   ?};
   {? H_UM.DO=_d0 & H_UM.P_DO<>_d0
   || H_UM.DO:=H_UM.P_DO
   ?}
?};

~~


\pkd_p_di
::----------------------------------------------------------------------------------------------------------------------
::   UTW: mafilo [22.26]
::  OPIS: Uzupełnienie pól DI w tabeli P
::    WE: _a - tablica zwrócona przez formułę \pkd_p_di_arg określająca, które wtyczki należy wywołać
::        [_b] -  argument wtyczki PKD_P_DI_1_001
::        [_c] -  argument wtyczki PKD_P_DI_2_001
::        [_d] -  argument wtyczki PKD_P_DI_3_001
:: UWAGA: Poprawność argumentów wywołania nie jest weryfikowana, użycie niezgodne ze specyfikacją spowoduje błąd.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<100 || return() ?};
{? _a.wtyczka1=0 & _a.wtyczka2=0 & _a.wtyczka3=0 || return() ?};

P.cntx_psh();
P.index('OSOZATR');
P.prefix(exec('ref_firma','ustawienia'));
{? P.first()
||
   {!
   |? _put:=0;
      {? _a.wtyczka1<>0 & Plugin.runnable('PKD_P_DI_1_001')
      || _wtyczka:=Plugin.run('PKD_P_DI_1_001',{? var_pres('_b')>=0 || _b || ~~ ?});
         {? type_of(_wtyczka)<>type_of(~~)
         || P.DI_1:=form(_wtyczka);
            _put+=1
         ?}
      ?};
      {? _a.wtyczka2<>0 & Plugin.runnable('PKD_P_DI_2_001')
      || _wtyczka:=Plugin.run('PKD_P_DI_2_001',{? var_pres('_c')>=0 || _c || ~~ ?});
         {? type_of(_wtyczka)<>type_of(~~)
         || P.DI_2:=form(_wtyczka);
            _put+=1
         ?}
      ?};
      {? _a.wtyczka3<>0 & Plugin.runnable('PKD_P_DI_3_001')
      || _wtyczka:=Plugin.run('PKD_P_DI_3_001',{? var_pres('_d')>=0 || _d || ~~ ?});
         {? type_of(_wtyczka)<>type_of(~~)
         || P.DI_3:=form(_wtyczka);
            _put+=1
         ?}
      ?};
      {? _put<>0
      || P.put()
      ?};
      P.next()
   !}
?};
P.cntx_pop();
~~


\pkd_p_di_arg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: mafilo [22.26]
:: OPIS: Formuła tworzy tablicę nazwaną z elementami parametryzującymi wybór wtyczki.
::       Formuła wykorzystywana w funckji \pkd_p_di
::   WE: [_a] -  wywołanie dla pola DI_1 (jeśli puste - nie wywołuj wtyczki PKD_P_DI_1_001)
::       [_b] -  wywołanie dla pola DI_2 (jeśli puste - nie wywołuj wtyczki PKD_P_DI_2_001)
::       [_c] -  wywołanie dla pola DI_3 (jeśli puste - nie wywołuj wtyczki PKD_P_DI_3_001)
::----------------------------------------------------------------------------------------------------------------------
_arg:=obj_new('wtyczka1','wtyczka2','wtyczka3');
_arg.wtyczka1:=0;
_arg.wtyczka2:=0;
_arg.wtyczka3:=0;

{? var_pres('_a')=type_of(0) || _arg.wtyczka1:=(_a<>0) ?};
{? var_pres('_b')=type_of(0) || _arg.wtyczka2:=(_b<>0) ?};
{? var_pres('_c')=type_of(0) || _arg.wtyczka3:=(_c<>0) ?};

_arg


\win_title_ext
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [23.25]
:: OPIS: Tworzy napis zawierający nazwisko, imię i numer teczki doklejany do tytułu okienka.
::   WE:
::   WY: napis do doklejenia do tytułu okienka
::----------------------------------------------------------------------------------------------------------------------
': %1 %2 (nr teczki %3)'@[P.OSOBA().NAZWISKO,OSOBA.PIERWSZE,P.T]


\err_ref_change
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.37]
:: OPIS: Zwraca treść komunikatu o niedozwolonej zmianie wskazania współpracownika.
::   WE:
::   WY: napis
::----------------------------------------------------------------------------------------------------------------------
'Niedozwolona zmiana wskazania współpracownika.'@


\h_um_zam_zaw_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Formuła po redagowaniu pola ZAM_ZAW tabeli H_UM
::   WE:
::   WY:
::  OLD: \h_um_zam_zaw_ae/umowy.fml
::----------------------------------------------------------------------------------------------------------------------
exec('h_efld_opt','pracownik')


\h_um_nieo_uspr_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Pokazuje nieobecności usprawiedliwione z atrybutu 1902 (Nieobecności usprawiedliwione)
::       występujące w trakcie trwania umowy.
::       Uwaga: Kontekst tabeli H_UM musi być ustalony.
::   WE:
::   WY:
::  OLD: \h_um_nieo_uspr_b/umowy.fml
::----------------------------------------------------------------------------------------------------------------------
RU.cntx_psh();
_ru:=H_UM.RU().K;
RU.cntx_pop();
{? _ru<>'A' | H_UM.PRZ_USPR<>'T'
|| FUN.info('Funkcja dostępna jedynie dla umów rodzaju "A - okres próbny"\n'
            'z zaznaczonym polem "Przedłużona o nieobecności usprawiedliwione".'@);
   return(~~)
?};
_atrUspr:=1902;
exec('__RUB','object');
__RUB.fill();
_rubUspr:=__RUB.sys_sql(_atrUspr);
_umOd:=H_UM.P_OD;
_umDo:=H_UM.P_DO;

{? +_rubUspr
|| _USPR:=sql('
      select N.OD as OD, N.DO as DO, N.NK as NK, N.NR as NR, N.NG as NG, R.RN as RN, R.RT as RT,
         N.NK as NK_U, N.NR as NR_U, N.NG as NG_U
      from N
         join R using(N.NB, R.REFERENCE)
      where N.P=:_a and N.KOR=\'N\' and (to_date(:_b) is null or N.OD<=to_date(:_b)) and N.DO>=to_date(:_c)
         and R.RN in (:_d)
      order by 1
      ',H_UM.P,_umDo,_umOd,_rubUspr);
   {? _USPR.first()
   || exec('declare','kalendarz');
      {? var_pres('__KAL')<>type_of(@.CLASS.KALEND)
      || __KAL:=obj_new(@.CLASS.KALEND,'standard')
      ?};
      P.cntx_psh();
      OSOBA.cntx_psh();
      _kalNazw:=__KAL.kal_nazw;
      __KAL.set_cal(H_UM.P().KAL);
      exec('PROGRESS','#object');
      PROGRESS.set(_USPR.size(),'Trwa obliczanie nieobecności...'@);
      {!
      |? {? _USPR.OD<_umOd | (_umDo<>date(0,0,0) & _USPR.DO>_umDo)
         || _od:={? _USPR.OD<_umOd || _umOd || _USPR.OD ?};
            _do:={? _umDo=date(0,0,0) | _USPR.DO<_umDo || _USPR.DO || _umDo ?};
            _USPR.NK_U:=_do-_od+1;
            _USPR.NR_U:=__KAL.w_days(_od,_do);
            _USPR.NG_U:=exec('nominal','godziny',_od,_do);
            _USPR.put()
         ?};
         PROGRESS.next();

         _USPR.next()
      !};
      PROGRESS.close();
      _wer:=_USPR.mk_sel('%1 %2 [%3 %4-%5] - Nieobecności usprawiedliwione przedłużające umowę'@
                         [H_UM.P().OSOBA().NAZWISKO,OSOBA.PIERWSZE,form(H_UM.NUMER),$_umOd,$_umDo]
                         ,,0,'#humusprn',,,20,,'U',,,,,'html_maximized',,'on');
      OSOBA.cntx_pop();
      P.cntx_pop();
      __KAL.set_cal(_kalNazw);
      _USPR.win_fld(_wer,,'RN',,,6,,,'Kod'@,,'Kod rubryki'@);
      _USPR.win_fld(_wer,,'RT',,,16,,,'Nazwa'@,,'Nazwa rubryki'@);
      _USPR.win_fld(_wer,,'OD',,,10,,,'Data od'@,,'Data rozpoczęcia'@);
      _USPR.win_fld(_wer,,'DO',,,10,,,'Data do'@,,'Data zakończenia'@);
      _USPR.win_fld(_wer,,'NK',,,-10,,,'Dni kalendarzowe'@,,'Liczba dni kalendarzowych'@);
      _USPR.win_fld(_wer,,'NR',,,-10,,,'Dni robocze'@,,'Liczba dni roboczych'@);
      _USPR.win_fld(_wer,,'NG',,,-10,2,,'Godziny robocze'@,,'Liczba godzin roboczych'@);
      _USPR.win_fld(_wer,,'NK_U',,,-10,,,'Dni kalendarzowe w umowie'@,,'Liczba dni kalendarzowych w okresie umowy'@);
      _USPR.win_fld(_wer,,'NR_U',,,-10,,,'Dni robocze w umowie'@,,'Liczba dni roboczych w okresie umowy'@);
      _USPR.win_fld(_wer,,'NG_U',,,-10,2,,'Godziny robocze w umowie'@,,'Liczba godzin roboczych w okresie umowy'@);
      _USPR.win_fml(_wer,,'RN',,'ICON_BEFORE',
         "_rn:=cur_tab().RN;
          'xwin16.png:'+${? __RUB.sys_attr(_rn,1921) || '54'
                         |? __RUB.sys_attr(_rn,1922) || '55'
                         |? __RUB.sys_attr(_rn,1923) || '33'
                         |? __RUB.sys_attr(_rn,1924) || '56'
                         || '110'
                         ?}");
      _USPR.win_sel(_wer);
      _USPR.select()
   || FUN.info('Brak usprawiedliwionych nieobecności przedłużających umowę.'@)
   ?}
|| FUN.emsg('Brak rubryk w atrybucie %1'@[$_atrUspr])
?};

~~


\czy_zmiana_wym
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [11.22]
:: OPIS: Sprawdzenie czy była zmiana wymiaru zatrudnienia w podanym roku i miesiącu dla bieżącego pracownika.
::   WE: _a [date] - data z rokiem i miesiącem badania
::   WY: INTEGER - 1 - byla zmiana; 0 - brak zmiany
::  OLD: \czy_zm_wym/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
H.cntx_psh();
H.index('_HISTKOD');
H.prefix(P.ref(),'Z');
{? H.find_le(date(_a~1,_a~2,0))
|| _wym:=H.WY;
   {!
   |? {? H.prev() & H.DO>=date(_a~1,_a~2,1)
      || {? H.WY<>_wym
         || H.cntx_pop();
            return(1)
         ?}
      ?}
   !}
?};
H.cntx_pop();
0


\ekw_rok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.51]
:: OPIS: Formuła zwraca liczbę godzin ekwiwalentu zapisanego na umowie.
::   WE: [_a] [REFERENCE] - Wskazanie pracownika [domyślnie: P.ref()].
::       [_b] [NUMBER]    - Rok [domyślnie: date()~1].
::   WY: Tablica elementów nazwanych.
::----------------------------------------------------------------------------------------------------------------------
_ret:=json_parse('{"ok":0,"EKW":0,"EKW_NSP":0,"DT":""}');

_pref:={? var_pres('_a')=type_of(null()) & _a<>null() & ref_tab(_a)=P || _a || P.ref() ?};
_rok:={? var_pres('_b')=type_of(0) || _b || date()~1 ?};

H_UM.cntx_psh();
H_UM.index('OD');
H_UM.prefix(_pref);
{? H_UM.first()
|| _ret.ok:=1;
   {!
   |? {? H_UM.DO~1=_rok
      || _ret.DT:=H_UM.DO;
         _ret.EKW+=H_UM.EKW;
         _ret.EKW_NSP+=H_UM.EKW_NSP
      ?};
      H_UM.next()
   !}
?};
H_UM.cntx_pop();

_ret

:Sign Version 2.0 jowisz:1045 2024/02/26 14:31:05 3d38cd1347057d6a6ed1cef4c997a299e2c1ed3936840e35b079107dc75ca7a8f1e359332189448e4509889301e6fe12f47a99a374fe4d4a34f16ad7bceb93c1bcfa8bf22bdeb1128b8659fa82b3a5087d6132ca8988c8fc8fdec16af7c82a5e71a4eaa391cb24b6974774fe4f68e9ba995f4468e35fdaa6bdd17fa1bf88a6fe
