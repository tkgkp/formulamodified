:!UTF-8
::(c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: px_stage.fml [12.10]
:: Utworzony: 2011/09/23
:: Autor: jerry
::======================================================================================================================
:: Zawartosc: Obsluga PX_STAGE
::======================================================================================================================


\PX_STAGE_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Wyswietlenie etapow dla wskazanego TKTL.ref()
::   WE: _a - TKTL.ref() lub PX_TEX.ref()
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_RootRef:=_a;
PX_STAGE.cntx_psh();
PX_STAGE.clear();
{? exec('PX_STAGE_prefix','px_stage',_RootRef)<>''
||
   PX_STAGE.first();
   PX_STAGE.win_sel('WER');
   PX_STAGE.select()
?};
PX_STAGE.cntx_pop();
~~


\PX_STAGE_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Dodaje wpis w PX_STAGE dla podanych parametrow
::   WE: _a - TKTL.ref() lub PX_TEX.ref()
::       _b - NUMBER numer etapu, ktory ma powstac (w razie jakby co, przenumerujemy)
::   WY: PX_STAGE.add()
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_RootRef:=_a;
_STAGEnr:=_b;
_result:=0;
PX_STAGE.cntx_psh();
PX_STAGE.clear();
_PXorTKTL:=exec('PX_STAGE_prefix','px_stage',_RootRef);
{? _PXorTKTL<>''
||
:: teraz edycja
   PX_STAGE.blank();
   PX_STAGE.TKTL:={? _PXorTKTL='TKTL' || _RootRef || null() ?};
   PX_STAGE.PX_TEX:={? _PXorTKTL='PX_TEX' || _RootRef || null() ?};
   PX_STAGE.NR:=_STAGEnr;
   PX_STAGE.NAZWA:='';
   {? exec('is_oper_nast_time','px_param')
   || PX_STAGE.win_edit('RED_NAKL')
   || PX_STAGE.win_edit('RED')
   ?};
   {? PX_STAGE.edit()
   || _mydo:=do_state()=0;
      {? _mydo || do() ?};

::    przenumerowuje kolejne etapy za mna
      PX_STAGE.cntx_psh();
      {? PX_STAGE.find_key(_STAGEnr)
       & PX_STAGE.last()
      || {!
         |? {? PX_STAGE.NR>=_STAGEnr
            ||
               PX_STAGE.NR+=1;
               PX_STAGE.put();
               PX_STAGE.prev()
            ?}
         !}
      ?};
      PX_STAGE.cntx_pop();
      _result:=PX_STAGE.add();
      {? _result=0 || undo() ?};
      {? _mydo || end() ?}
   ?}
?};
PX_STAGE.cntx_pop();
_result


\PX_STAGE_put
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Poprawia wpis w PX_STAGE dla podanych parametrow
::   WE: _a - PX_STAGE.ref()
::   WY: PX_STAGE.put()
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_PXSTAGE:=_a;
_result:=0;
PX_STAGE.cntx_psh();
PX_STAGE.clear();
{? exec('is_oper_nast_time','px_param')
|| PX_STAGE.win_edit('RED_NAKL')
|| PX_STAGE.win_edit('RED')
?};
_valid:="
   _result:='';
   {? _result=''
   || {? PX_STAGE.TTM<0
      || FUN.emsg('Czas odczekania nie może być mniejszy od zera.'@);
         _result:='TTM'
      ?}
   ?};
   {? _result=''
   || {? PX_STAGE.NKO<0
      || FUN.emsg('Czas nakładkowania nie może być mniejszy od zera.'@);
         _result:='NKO'
      ?}
   ?};
   {? _result=''
   || {? PX_STAGE.TPZ<0
      || FUN.emsg('Czas TPZ nie może być mniejszy od zera.'@);
         _result:='TPZ'
      ?}
   ?};
   _result
";

{? PX_STAGE.seek(_PXSTAGE)
 & PX_STAGE.edit(_valid)
|| _result:=PX_STAGE.put()
?};

PX_STAGE.cntx_pop();
_result


\PX_STAGE_view
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Podglad PX_STAGE dla podanych parametrow
::   WE: _a - PX_STAGE.ref()
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_PXSTAGE:=_a;
_result:=0;
PX_STAGE.cntx_psh();
PX_STAGE.clear();
{? exec('is_oper_nast_time','px_param')
|| PX_STAGE.win_edit('RED_NAKL')
|| PX_STAGE.win_edit('RED')
?};
{? PX_STAGE.seek(_PXSTAGE)
|| PX_STAGE.display()
?};
PX_STAGE.cntx_pop();
_result


\PX_STAGE_bFE
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przed redakcja pol w PX_STAGE
::   WY: 1/0
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
{? _fld='NAZWA'    || 1
|? _fld='ALIGNMEN' || 1
?}


\PX_STAGE_aFE
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Po redakcji pol w PX_STAGE
::   WY: 1/0
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
{? _fld='NAZWA'    || {? fld()='' || FUN.info('Proszę podać nazwę etapu.'@);0 || 1 ?}
|? _fld='ALIGNMEN' || 1
?}


\PX_STAGE_BD
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Przed wyswietl dla pol w tabeli PX_STAGE
::   WY: STRING - kolor pola
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_fld:=cur_afld();

{? _fld='PX_SET'
|| {? ~exec('is_one_version','px_param')
   || _result:=exec('findfnrd','color')
   ?}
?};
_result


\PX_STAGE_FD
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Format wyswietlania dla pol w tabeli PX_STAGE
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_fld:=cur_afld();
_result


\GetLastNr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Zwraca maksymalny nr etapu dla technologii
::   WE: TKTL.ref() lub PX_TEX.ref()
::   WY: NUMBER
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_RootRef:=_a;
_STAGEnr:=0;
PX_STAGE.cntx_psh();
PX_STAGE.clear();
{? exec('PX_STAGE_prefix','px_stage',_RootRef)<>''
 & PX_STAGE.last()
|| _STAGEnr:=PX_STAGE.NR
?};
PX_STAGE.cntx_pop();
_STAGEnr


\PX_STAGE_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Kasuje PX_STAGE z PX_OPERami i PX_MATami
::   WE: PX_STAGE.ref()
::   WY: 1/0 sukces/porazka
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_PX_STAGE:=_a;
_result:=0;
_mydo:=do_state()=0;
{? _mydo || do() ?};

_can_continue:=1;

PX_STAGE.cntx_psh();
PX_STAGE.clear();
{? PX_STAGE.seek(_PX_STAGE)
||
:: Sprawdzam czy etap jest uzywany w planie czyli czy istnieja powiazane pozycje planu
   _used:=exec('used_in_plan','px_stage',PX_STAGE.ref());
   {? _used=0
   ||
::    1. Usuwanie PX_OPERow
      PX_OPER.cntx_psh();
      PX_OPER.index('UNIQALL');
      PX_OPER.prefix(PX_STAGE.ref());
      {? PX_OPER.first()
      || _deleted:='';
         {!
         |? _deleted+=$PX_OPER.ref();
::          kasujemy
            exec('PX_OPER_del','px_oper',PX_OPER.ref())
::          idziemy na poczatek
            & PX_OPER.first()
::          gdyby jednak nie zostalo skasowane, to konczymy bo bysmy sie zapetlili
            & (_deleted*$PX_OPER.ref())=0
         !};
         _can_continue:=~PX_OPER.first()
      ?};
      PX_OPER.cntx_pop()
   || _can_continue:=0
   ?};

   {? _can_continue>0
   ||
::    2. Usuwanie PX_MATow
      PX_MAT.cntx_psh();
      PX_MAT.index('UNIQALL');
      PX_MAT.prefix(PX_STAGE.ref());
      {? PX_MAT.first()
      || _deleted:='';
         {!
         |? _deleted+=$PX_MAT.ref();
::          kasujemy
            exec('PX_MAT_del','px_mat',PX_MAT.ref())
::          idziemy na poczatek
            & PX_MAT.first()
::          gdyby jednak nie zostalo skasowane, to konczymy bo bysmy sie zapetlili
            & (_deleted*$PX_MAT.ref())=0
         !};
         _can_continue:=~PX_MAT.first()
      ?};
      PX_MAT.cntx_pop()
   ?};

   {? _can_continue>0
   ||
::    3. Usuwanie punktow czasowych
      _can_continue:=exec('delete4stage','px_point',PX_STAGE.ref())
   ?}
|| _can_continue:=0
?};

{? _can_continue>0
||
:: usuwam powiazania etapu z TOPEREM, ZOPEREM, ZGPem
   _can_continue:=exec('clean_ties','px_stage',PX_STAGE.ref());

   {? _can_continue>0 & PX_STAGE.del(,1)
   || _can_continue:=1
   || _can_continue:=0; undo()
   ?}
?};
{? _can_continue>0
|| PX_VAR.PX_STAGE:=null();
   _result:=1
?};

PX_STAGE.cntx_pop();
{? _mydo || end() ?};
_result


\PX_STAGE_renum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Renumeruje etapy
::   WE: TKTL.ref() lub PX_TEX.ref()
::   WY:
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_RootRef:=_a;
_STAGEnr:=0;
PX_STAGE.cntx_psh();
PX_STAGE.clear();

{? exec('PX_STAGE_prefix','px_stage',_RootRef)<>''
 & PX_STAGE.first()
|| {!
   |? _STAGEnr+=1;

      PX_STAGE.NR:=_STAGEnr;
      PX_STAGE.put();
      PX_STAGE.next()
   !};
   _STAGEnr:=PX_STAGE.NR
?};
PX_STAGE.cntx_pop();
~~


\PX_STAGE_prefix
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Ustala indeks i zaklada prefix dla PX_STAGE na postawie podanego parametru
::   WE: _a - TKTL.ref() lub PX_STAGE.ref()
::       [_b] - PX_TEX.ref() - zestaw planistyczny
::   WY: STRING ktory to wariant (TKTL/PX_TEX)
::----------------------------------------------------------------------------------------------------------------------
_RootRef:=_a;

_px_set:=null();
{? var_pres('_b')=type_of(PX_SET.ref())
|| _px_set:=_b
?};

{? (5+ref_name(_RootRef))=(5+TKTL.name())
|| {? _px_set<>null()
   || PX_STAGE.index('SET_TKTL');
      PX_STAGE.prefix(_px_set,$_RootRef)
   || PX_STAGE.index('TKTL_NR');
      PX_STAGE.prefix($_RootRef)
   ?};
   'TKTL'

|? ref_name(_RootRef)=PX_TEX.name()
|| {? _px_set<>null()
   || PX_STAGE.index('SET_TEX');
      PX_STAGE.prefix(_px_set,_RootRef)
   || PX_STAGE.index('TEX_NR');
      PX_STAGE.prefix(_RootRef)
   ?};
   'PX_TEX'
|| ''
?}


\px_stage_nkl_bl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Blank pola tabeli PX_STAGE.NAKL_PRC
::   WY: REAL
::----------------------------------------------------------------------------------------------------------------------
100


\px_stage_nkl_be
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Przed edycja pola tabeli PX_STAGE.NAKL_PRC
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
1


\px_stage_nkl_ae
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Po edycji pola tabeli PX_STAGE.NAKL_PRC
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
{? PX_STAGE.NAKL_PRC>100 | PX_STAGE.NAKL_PRC<0
|| _result:=0;
   FUN.emsg('Niedozwolona wartość.\nPoprawna wartość musi się zawierać w przedziale 0..100.'@)
?};
_result


\px_stage_prevf3
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: F3 w polu tabeli PX_STAGE.STG_PREV
::   WY: INTEGER - numer wybranego etapu
::----------------------------------------------------------------------------------------------------------------------
~~


\clean_ties
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Usuwa powiazania z podanym rekordem PX_STAGE
::   WE: _a - PX_STAGE.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:=0;

_can_continue:=0;
PX_STAGE.cntx_psh();
PX_STAGE.clear();
{? PX_STAGE.seek(_px_stage)
|| _can_continue:=1;

:: Powiazania z TOPERami
   _args_top:=obj_new('PX_STAGE');
   _args_top.PX_STAGE:=PX_STAGE.ref();
   _formula:="
      _args:=_b;
      _result:=0;
      _can_continue:=1;
      TOPER.cntx_psh();
      TOPER.index('PX_STAGE');
      TOPER.prefix('T',PX_STAGE.ref());
      {? TOPER.first()
      || {!
         |? TOPER.cntx_psh();
            TOPER.clear();
            TOPER.PX_STAGE:=null();
            _can_continue:=TOPER.put();
            TOPER.cntx_pop();
            TOPER.first() & _can_continue>0
         !}
      ?};
      {? _can_continue>0
      ||
         TOPER.prefix('N',PX_STAGE.ref());
         {? TOPER.first()
         || {!
            |? TOPER.cntx_psh();
               TOPER.clear();
               TOPER.PX_STAGE:=null();
               _can_continue:=TOPER.put();
               TOPER.cntx_pop();
               TOPER.first() & _can_continue>0
            !}
         ?}
      ?};
      TOPER.cntx_pop();
      {? _can_continue>0
      || _result:=1
      ?};
      _result
   ";
   _can_continue:=exec('for_each_mask','#table',TOPER,_formula,,,_args_top,1);

:: Powiazania z ZOPERami
   {? _can_continue>0
   || ZOPER.cntx_psh();
      ZOPER.index('PX_STAGE');
      ZOPER.prefix(PX_STAGE.ref());
      {? ZOPER.first()
      || {!
         |? ZOPER.cntx_psh();
            ZOPER.clear();
            ZOPER.PX_STAGE:=null();
            _can_continue:=ZOPER.put();
            ZOPER.cntx_pop();
            ZOPER.first() & _can_continue>0
         !}
      ?};
      ZOPER.cntx_pop()
   ?};

:: Powiazania z ZGPami
   {? _can_continue>0
   || ZGP.cntx_psh();
      ZGP.index('PX_STAGE');
      ZGP.prefix(PX_STAGE.ref());
      {? ZGP.first()
      || {!
         |? ZGP.cntx_psh();
            ZGP.clear();
            ZGP.PX_STAGE:=null();
            _can_continue:=ZGP.put();
            ZGP.cntx_pop();
            ZGP.first() & _can_continue>0
         !}
      ?};
      ZGP.cntx_pop()
   ?};

:: Powiązania z następnikami
   {? _can_continue>0
   || _can_continue:=exec('clean4stage','px_nast',PX_STAGE.ref())
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
PX_STAGE.cntx_pop();
_result


\coop_zgp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy dany etap jest powiazany z ZGP kooperacyjnym
::   WE: _a - PX_STAGE.ref()
::   WY: 0 - PX_STAGE nie jest powiazany z ZGP kooperacyjnym
::       1 - istnieje ZGP kooperacyjny ktory wskazuje na tego PX_STAGE
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:=0;

ZGP.cntx_psh();
ZGP.index('PX_STAGE');
ZGP.prefix(_px_stage);
{? ZGP.first()
|| {? ZGP.WEW='N'
   || _result:=1
   ?}
?};
ZGP.cntx_pop();
_result


\coop_zgp_start
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca czas startu kooperacji podany na ZGP
::   WE: _a - PX_STAGE.ref()
::   WY: REAL - czas w formacie tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:=0;

ZGP.cntx_psh();
ZGP.index('PX_STAGE');
ZGP.prefix(_px_stage);
{? ZGP.first()
|| _result:=ZGP.TMSTARTK
?};
ZGP.cntx_pop();
_result


\coop_zgp_end
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca czas startu kooperacji podany na ZGP
::   WE: _a - PX_STAGE.ref()
::   WY: REAL - czas w formacie tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:=0;

ZGP.cntx_psh();
ZGP.index('PX_STAGE');
ZGP.prefix(_px_stage);
{? ZGP.first()
|| _result:=ZGP.TMENDK
?};
ZGP.cntx_pop();
_result


\coop_zgp_akc
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy dane do planowania na kooperacji zostały zaakceptowane ręcznie
::   WE: _a - PX_STAGE.ref()
::   WY: 0 - PX_STAGE nie jest powiazany z ZGP kooperacyjnym
::       1 - istnieje ZGP kooperacyjny ktory wskazuje na tego PX_STAGE
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:=0;

ZGP.cntx_psh();
ZGP.index('PX_STAGE');
ZGP.prefix(_px_stage);
{? ZGP.first()
|| {? ZGP.KOOP_AKC='T'
   || _result:=1
   ?}
?};
ZGP.cntx_pop();
_result


\planned_grop_il
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca ilosc dla danego etapu w planie grup operacji
::   WE: _a - PX_STAGE.ref()
::   WY: REAL - ilosc danego zgp'a w planie operacyjnym we wszystkich zaplanowanych grupach
::              ilosc ta uwzglednia to ze dany zgp moze byc w kilku grupach, a te grupy moga byc w
::              kilku czesciach w planie
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:=0;

ZGP.cntx_psh();
ZGP.index('PX_STAGE');
ZGP.prefix(_px_stage);
{? ZGP.first()
|| _result:=exec('zgp_planned_il','po_ogr',ZGP.ref())
?};
ZGP.cntx_pop();
_result


\planned_grop_pr
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca proporcje dla danego etapu - ilosc ZGPa w stosunku do ilosci w planie grupy operacji
::   WE: _a - PX_STAGE.ref()
::   WY: REAL - 0..1 - proporcja ktora mowi jaka czesc PX_STAGE znajduje sie w planie operacyjnym
::              w grupach operacji
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:=1;
_il_groper:=exec('planned_grop_il','px_stage',_px_stage);
_il_zgp:=0;
{? _il_groper>0
|| ZGP.cntx_psh();
   ZGH.cntx_psh();
   ZGP.index('PX_STAGE');
   ZGP.prefix(_px_stage);
   {? ZGP.first()
   || _il_zgp:=ZGP.ILOSC
   ?};
   ZGP.cntx_pop();
   ZGH.cntx_pop();

   {? _il_zgp>0
   || _result:=1-(_il_groper/_il_zgp);
      {? _result>1
      || _result:=1
      |? _result<0
      || _result:=0
      ?}
   ?};
   ~~
?};
_result


\planned_grop_s
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca poczatek planu operacyjnego w grupach dla podanego PX_STAGE
::   WE: _a - PX_STAGE.ref()
::   WY: REAL - tm_stamp()
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:=0;

ZGP.cntx_psh();
ZGP.index('PX_STAGE');
ZGP.prefix(_px_stage);
{? ZGP.first()
|| _result:=exec('zgp_plan_start','po_ogr',ZGP.ref())
?};
ZGP.cntx_pop();
_result


\planned_grop_e
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca koniec planu operacyjnego w grupach dla podanego PX_STAGE
::   WE: _a - PX_STAGE.ref()
::   WY: REAL - tm_stamp()
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:=0;

ZGP.cntx_psh();
ZGP.index('PX_STAGE');
ZGP.prefix(_px_stage);
{? ZGP.first()
|| _result:=exec('zgp_plan_end','po_ogr',ZGP.ref())
?};
ZGP.cntx_pop();
_result


\used_in_plan
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy PX_STAGE jest uzywany w planie
::   WE: _a - PX_STAGE.ref
::   WY: 0 - brak pozycji planu powiazanych z PX_STAGE
::       1 - istnieja pozycje planu powiazane z PX_STAGE
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:=0;

PX_POZ.cntx_psh();
PX_POZ.index('PX_STAG2');
PX_POZ.prefix(_px_stage);
{? PX_POZ.size()>0
|| _result:=1
?};
PX_POZ.cntx_pop();
_result


\is_wew
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy PX_STAGE jest powiazany ze zrodlowa operacja (ZGP, ZOPER, TOPER) wewnetrzna (tzn nie kooperacja)
::       Poniewaz jeden PX_STAGE moze byc powiazany z wieloma ZGP, ZOPER, TOPER jezeli ktorykolwiek z nich jest zewnetrzny
::       to caly PX_STAGE bedzie traktowany jako zewnetrzny
::   WE: _a - PX_STAGE.ref()
::   WY: 'N' - PX_STAGE jest powiazany z operacja zewnetrzna (kooperacja)
::       'T' - PX_STAGE jest powiazany z operacja wewnetrzna
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:='';

PX_STAGE.cntx_psh(); PX_STAGE.clear();
{? PX_STAGE.seek(_px_stage)
||
:: 1. Powiazania z ZGP
   {? _result=''
   || ZGP.cntx_psh();
      ZGP.index('PX_STAGE');
      ZGP.prefix(PX_STAGE.ref());
      {? ZGP.first()
      ||
         _result:='T';
         {!
         |? {? ZGP.WEW='N'
            || _result:='N'
            ?};
            ZGP.next() & _result='T'
         !}
      ?};
      ZGP.cntx_pop()
   ?};
:: 2. Powiazania z TOPER
   {? _result=''
   || TOPER.cntx_psh();
      TOPER.index('PX_STAGE');
      TOPER.prefix('T',PX_STAGE.ref());
      {? TOPER.first()
      ||
         _result:='T';
         {!
         |? {? TOPER.WEW='N'
            || _result:='N'
            ?};
            TOPER.next() & _result='T'
         !}
      ?};
      TOPER.cntx_pop()
   ?};
   {? _result=''
   || _result:='T'
   ?}
?};
PX_STAGE.cntx_pop();
_result


\clean_from_plan
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Usuwa z planu wszystkie pozycje planu powiazane z danym PX_STAGE
::   WE: _a - PX_STAGE.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:=0;
_can_continue:=1;

PX_STAGE.cntx_psh(); PX_STAGE.clear();
PX_POZ.cntx_psh();

{? PX_STAGE.seek(_px_stage)
|| PX_POZ.index('PX_STAG2');
   PX_POZ.prefix(PX_STAGE.ref());
   {? PX_POZ.first()
   || {!
      |? _can_continue:=exec('delete','px_poz',PX_POZ.ref());
         PX_POZ.first() & _can_continue>0
      !}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
PX_POZ.cntx_pop();
PX_STAGE.cntx_pop();
_result


\mask_current
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca niearchiwalna maske dla tabeli PX_STAGE
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
PX_STAGE.name()


\px_set_fill
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Na podstawie zasobow nalezacych do etapu planistycznego wypelnia na etapie
::       pole PX_SET
::   WE: _a - PX_STAGE.ref()
::       [_b] - INTEGER - [0]/1 - czy nadpisywac wypelniony juz zestaw?
::       [_c] - INTEGER - 0/[1] - czy po wypelnieniu dokonac weryfikacji czy wszystkie zasoby
::                        etapu naleza do tego samego etapu
::       [_d] - INTEGER - [0]/1 - czy inicjowac i wyswietlac KOMMa
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_overwrite:=0;
{? var_pres('_b')=type_of(0)
|| _overwrite:=_b
?};

_verify:=1;
{? var_pres('_c')=type_of(0)
|| _verify:=_c
?};

_komm_init:=0;
{? var_pres('_d')=type_of(0)
|| _komm_init:=_d
?};

{? _komm_init>0
|| KOMM.init(250,,'Wypełnianie zestawów planistycznych dla etapów przepisu.'@)
?};

_result:=0;
_can_continue:=1;

PX_STAGE.cntx_psh(); PX_STAGE.clear();
PX_SET.cntx_psh();
PX_KONT.cntx_psh();
PX_OPER.cntx_psh();
PX_OPER.index('UNIQALL');

{? PX_STAGE.seek(_px_stage)
||
   _can_set:=1;
   {? _overwrite=0 & PX_STAGE.PX_SET<>null()
   ||
::    Jesli zestaw juz wypelniony i nie jest wlaczone nadpisywanie to zostawiam w spokoju
      _can_set:=0
   ?};

   {? _can_set>0
   ||
      PX_OPER.prefix(PX_STAGE.ref());
      {? PX_OPER.first()
      || {!
         |? _px_set:=PX_OPER.PX_KONT().PX_SET;
            PX_STAGE.PX_SET:=_px_set;
            _can_continue:=PX_STAGE.put();
            PX_OPER.next() & PX_STAGE.PX_SET=null() & _can_continue>0
         !}
      ||
::       Jesli nie ma zadnych PX_OPERow to czyszcze PX_SETa
         PX_STAGE.PX_SET:=null();
         _can_continue:=PX_STAGE.put()
      ?};
      {? _can_continue>0 & PX_STAGE.PX_SET=null()
      ||
::       Brak zestawu wiec usuwam wszystkie automatyczne punkty jakie moze miec etap
         PX_POINT.cntx_psh();
         PX_POINT.index('PX_STAGE');
         PX_POINT.prefix(PX_STAGE.ref());
         {? PX_POINT.first()
         || {!
            |? _next:=0;
               _nxt_ref:=null();
               PX_POINT.cntx_psh();
               {? PX_POINT.next()
               || _nxt_ref:=PX_POINT.ref()
               ?};
               PX_POINT.cntx_pop();

               {? PX_POINT.TYP='A' | PX_POINT.TYP='P'
               || _can_continue:=exec('delete','px_point',PX_POINT.ref())
               ?};

               {? _nxt_ref<>null()
               || _next:=PX_POINT.seek(_nxt_ref)
               || _next:=0
               ?};

               _next>0 & _can_continue>0
            !}
         ?};
         PX_POINT.cntx_pop()
      ?}
   ?};
   {? _verify>0
   ||
::    Weryfikuje czy wszystkie zasoby etapu naleza do tego samego zestawu
      _can_continue:=exec('px_set_verify','px_stage')
   ?}
?};
{? _komm_init>0
|| KOMM.select()
?};

PX_OPER.cntx_pop();
PX_KONT.cntx_pop();
PX_SET.cntx_pop();
PX_STAGE.cntx_pop();
PX_STAGE.get();
{? _can_continue>0
|| _result:=1
?};
_result


\px_set_verify
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Weryfikuje czy wszystkie zasoby przypisane do etapu naleza do tego samego
::       zestawu planistycznego
::   WE: [_a] - PX_STAGE.ref lub jesli nie podany biezacy rekord
::       [_b] - INTEGER - [0]/1 - czy inicjowac i wyswietlac KOMMa
::   WY: -1 - brak zestawu na etapie
::        0 - niezgodnosc zestawu na etapie i zasobie
::        1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=null();
{? var_pres('_a')=type_of(null())
|| _px_stage:=_a
?};
_komm_init:=0;
{? var_pres('_b')=type_of(0)
|| _komm_init:=_b
?};

{? _komm_init>0
|| KOMM.init(255,,'Weryfikacja zestawów planistycznych na etapach'@)
?};

_result:=1;
_can_continue:=1;

PX_STAGE.cntx_psh();
PX_SET.cntx_psh();
PX_KONT.cntx_psh();
PX_OPER.cntx_psh();
PX_OPER.index('PX_STAGE');

{? _px_stage<>null()
|| _can_continue:=0;
   PX_STAGE.clear();
   {? PX_STAGE.seek(_px_stage)
   || _can_continue:=1
   ?}
?};

{? _can_continue>0
||
:: Stoje na etapie ktory weryfikowac
   _set_stg:=null();
   PX_OPER.prefix('T',PX_STAGE.ref());
   {? PX_OPER.first()
   || {? PX_OPER.PX_STAGE().PX_SET<>null()
      ||
::       Etap ma przypisany zestaw, porownuje go z zestawami na zasobach
         {!
         |?
            _set_kont:=PX_OPER.PX_KONT().PX_SET;
            {? _set_kont<>null()
            ||
               {? _set_stg=null()
               ||
::                Zestaw dla etapu jeszcze nie okreslony, wiec biore z pierwszego kontenera
                  _set_stg:=_set_kont
               ||
::                Zestaw dla etapu juz okreslony, porownuje go z zestawem biezacego kontenera
                  {? _set_stg<>_set_kont
                  ||
::                   Zestawy sie roznia
                     _result:=0
                  ?}
               ?}
            ||
::             Zestaw kontenera pusty, badam czy czy zestaw etapu rowniez pusty
               {? _set_stg<>null()
               ||
::                Zestawy etapu wypelniony czyli kicha
                  _result:=0
               ?}
            ?};
            PX_OPER.next()
         !};

         {? _result=0
         ||
::          Dodaje komunikat do KOMMa
            _str_stage:='Różne zestawy planistyczne na zasobach etapu: %1'@[exec('record','#to_string',PX_STAGE.ref())];
            _str_tex:='';
            {? PX_STAGE.TKTL<>null()
            || _str_tex:='Karta technologiczna: %1'@[exec('record','#to_string',PX_STAGE.TKTL)]
            |? PX_STAGE.PX_TEX<>null()
            || _str_tex:='Przepis planistyczny: %1'@[exec('record','#to_string',PX_STAGE.PX_TEX)]
            ?};

            {? KOMM.find_msg(_str_tex)
            || KOMM.set_root(_str_tex)
            || KOMM.sect_beg(_str_tex)
            ?};
            {? KOMM.find_msg(_str_stage)
            || KOMM.set_root(_str_stage)
            || KOMM.sect_beg(_str_stage,2)
            ?};

            PX_OPER.prefix('T',PX_STAGE.ref());
            {? PX_OPER.first()
            || {!
               |? _msg:='Zasób: %1'@[PX_OPER.PX_KONT().SYMBOL];
                  {? PX_KONT.PX_SET<>null()
                  || _msg+=' '+'(zestaw: %1)'@[PX_KONT.PX_SET().SYMBOL]
                  || _msg+=' '+'(brak zestawu planistycznego)'@
                  ?};
                  KOMM.add(_msg,'xwin16.png:3');
                  PX_OPER.next()
               !}
            ?};
            KOMM.sect_end();
            KOMM.sect_end()
         ?}
      ||
::       Etap nie ma przypisanego zestawu
         _result:=-1;
::       Dodaje komunikat do KOMMa
         _str_stage:='Brak zestawu planistycznego na etapie: %1'@[exec('record','#to_string',PX_STAGE.ref())];
         _str_tex:='';
         {? PX_STAGE.TKTL<>null()
         || _str_tex:='Karta technologiczna: %1'@[exec('record','#to_string',PX_STAGE.TKTL)]
         |? PX_STAGE.PX_TEX<>null()
         || _str_tex:='Przepis planistyczny: %1'@[exec('record','#to_string',PX_STAGE.PX_TEX)]
         ?};

         {? KOMM.find_msg(_str_tex)
         || KOMM.set_root(_str_tex)
         || KOMM.sect_beg(_str_tex)
         ?};
         KOMM.add(_str_stage,2);
         KOMM.sect_end()
      ?}
   ||
::    Etap nie ma zadnych powiazan z zasobami
      {? PX_STAGE.PX_SET=null()
      ||
::       Etap nie ma przypisanego zestawu
         _result:=-1;
::       Dodaje komunikat do KOMMa
         _str_stage:='Brak zestawu planistycznego na etapie: %1'@[exec('record','#to_string',PX_STAGE.ref())];
         _str_tex:='';
         {? PX_STAGE.TKTL<>null()
         || _str_tex:='Karta technologiczna: %1'@[exec('record','#to_string',PX_STAGE.TKTL)]
         |? PX_STAGE.PX_TEX<>null()
         || _str_tex:='Przepis planistyczny: %1'@[exec('record','#to_string',PX_STAGE.PX_TEX)]
         ?};

         {? KOMM.find_msg(_str_tex)
         || KOMM.set_root(_str_tex)
         || KOMM.sect_beg(_str_tex)
         ?};
         KOMM.add(_str_stage,2);
         KOMM.sect_end()
      ?}
   ?}
?};
{? _komm_init>0
|| KOMM.select()
?};

PX_OPER.cntx_pop();
PX_KONT.cntx_pop();
PX_SET.cntx_pop();
PX_STAGE.cntx_pop();
_result


\walk_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Argumenty dla funkcji walk
::   WY: obj_new - tablica nazwana
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
::             Etap startowy - PX_STAGE.ref
               'START'
::             Czym prefisowac PX_STAGE (PX_TEX.ref lub TKTL.ref)
               ,'ROOTREF'
::             Kierunek w ktorym isc
               ,'DIR'
::             Formula ktora wykonac dla kazdego etapu - formula jako _a dostanie te tablice
               ,'FORMULA'
::             Tablica z refami odwiedzonych etapow
               ,'VISITED'
::             Czy jestem na poczatku sciezki
               ,'PATH_START'
::             Oczekiwany rezultat formuly - jesli inny niz oczekiwany to koncze chodzenie
               ,'EXPECTED'
::             Przebyta odleglosc
               ,'DISTANCE'
              );
_args.START:=null();
_args.ROOTREF:=null();
_args.DIR:=0;
_args.FORMULA:="";
_args.VISITED:=exec('ref_table','#table');
_args.PATH_START:=0;
_args.EXPECTED:=~~;
_args.DISTANCE:=0;
_args


\walk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Przechodzi po kolejnych etapach wg nastepstwa i wykonuje dla kazdego etapu formule
::       Kontekst pracy PX_STAGE
::   WE: _args - argumenty dla funkcji, wynik dzialania exec('walk_a','px_stage')
::   WY: 0 - przerwano chodzenie bo formula zwrocila 0 lub wynik niezgodny z oczekiwaniem
::       1 - doszlo do konca sciezki
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

PX_STAGE.cntx_psh();
_args.VISITED.add(PX_STAGE.ref());

_args.DISTANCE+=1;

:: Wykonuje przekazana formule
_fml_res:=_args.FORMULA(_args);

_can_continue:=1;

{? type_of(_args.EXPECTED)>0
||
   {? _args.EXPECTED=_fml_res
   || _can_continue:=1
   || _can_continue:=0
   ?}
|| {? _fml_res>0
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _stages_next:=exec('stages_next','px_stage',,_args.DIR);
   {? _stages_next.first()
   || {!
      |? PX_STAGE.prefix();
         {? PX_STAGE.seek(_stages_next.REF)
         ||
            {? _args.VISITED.r_find(PX_STAGE.ref())=0
            ||
::             !!! REKURENCJA !!!
               _args.PATH_START:=0;
               _result:=exec('walk','px_stage',_args)
            ?}
         ?};
         _stages_next.next() & _result=0
      !}
   ?}
?};
PX_STAGE.cntx_pop();
~~


\px_set_get
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Zwraca zestaw ktory jest przypisany do etapu na podstawie PX_OPERow nalezacych do tego
::       etapu
::   WE: [_a] - PX_STAGE.ref()
::       [_b] - PX_KONT.ref() - kontener ktorego nie brac pod uwage
::   WY: PX_SET lub null
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};
_kont_omit:=null();
{? var_pres('_b')=type_of(SYSLOG.ref())
|| _kont_omit:=_b
?};

_result:=null();
_can_continue:=1;

PX_KONT.cntx_psh();
PX_STAGE.cntx_psh();
{? _ref<>null()
|| PX_STAGE.clear();
   {? PX_STAGE.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_OPER.cntx_psh();
   PX_OPER.index('UNIQALL');
   PX_OPER.prefix(PX_STAGE.ref());
   {? PX_OPER.first()
   || {!
      |?
         {? _kont_omit<>null() & _kont_omit=PX_OPER.PX_KONT
         || _can_continue:=0
         ?};
         {? _can_continue
         || _result:=PX_OPER.PX_KONT().PX_SET
         ?};
         PX_OPER.next() & _result=null()
      !}
   ?};
   PX_OPER.cntx_pop()
?};
PX_STAGE.cntx_pop();
PX_KONT.cntx_pop();
_result


\trigger_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger przed put i przed add tabeli PX_STAGE
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? PX_STAGE.TKTL<>null()
|| PX_STAGE.RTKTL:=$PX_STAGE.TKTL
?};
{? PX_STAGE.KOLOR=''
|| PX_STAGE.KOLOR:=exec('kolor_rand','#color')
?};
1


\delete4tktl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Kasuje PX_STAGE'e nalezace do TKTL, pod warunkiem ze nie sa uzywane w planie
::   WE: _a - TKTL.ref
::   WY: -1 - porazka
::       1 - sukces
::  OLD: \px_stage/tkasuj.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

_result:=-1;
_can_continue:=1;

PX_STAGE.cntx_psh();
PX_STAGE.index('TKTL_NR');
PX_STAGE.prefix($_tktl);
{? PX_STAGE.first()
|| {!
   |? _can_continue:=exec('PX_STAGE_del','px_stage',PX_STAGE.ref());
      PX_STAGE.first() & _can_continue>0
   !}
?};
{? _can_continue>0
|| _result:=1
?};
PX_STAGE.cntx_pop();
_result


\renall_simple
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Formula przenumerowuje wszystkie etapy w ramach struktury zlecenia zlozonego z przeisami prostymi
::       Proceura wykonywana jest wylacznie gdy wywolano ja dla zlecenia naglowkowego
::       gdy ZL.RODZAJ='Z' & ZL.RODZ_TEX='P'
::       Przenumerowanie odbywa sie na podstawie powiazan PX_NAST pomiedzy PX_STAGE
::       Jednak zaklada sie, ze w ramach jednego przepisu etapy numerowane sa rosnaca
::       i tak kolejnosc decyduje w ramach przepisu podzlecenia
::   WE: _a - ZL.ref() [VAR.A_ZLEC]
::----------------------------------------------------------------------------------------------------------------------
_zl:=VAR.A_ZLEC;
{? var_pres('_a')=type_of(null()) || _zl:=_a ?};
{? ref_name(_zl)<>ZL.name() || return() ?};

Cntx.psh(ZL,PX_TEX,PX_NAST,PX_STAGE);
ZL.prefix();
{? ZL.seek(_zl) & (ZL.RODZAJ='Z') & (ZL.RODZ_TEX='P')
|| _zlp:=exec('main_podzlec','zl_link',ZL.ref());
   {? _zlp<>null()
   ||
::    analiza rozpoczyna sie od aktywnego przepisu 1 podzlecenia
      PX_TEX.index('ZLASYM'); PX_TEX.prefix(_zlp,'T');
      {? PX_TEX.first()
      || exec('rentex_simple','px_stage',PX_TEX.ref(),0,null())
      ?}
   ?}
?};
Cntx.pop(ZL,PX_TEX,PX_NAST,PX_STAGE)


\rentex_simple
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Renumeracja etapow w ramach wskazanego przepisu
::   WE: _a - PX_TEX.ref()
::       _b - ostatni wykorzystany numer
::       _c - PX_STAGE.ref() etapu z ktorego wychodzi powiazanie wyzej
::            _a, _b, musza byc podane, inaczej ma zglosic blad, bo nie ma dobrej opcji przy blednych parametrach
::   WY: najwyzszy wykorzystany numer
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;
_pop_nr:=_b;
_fin_stg:=null();
{? var_pres('_c')=type_of(null()) || _fin_stg:=_c ?};

Cntx.psh(PX_TEX,PX_NAST,PX_STAGE,ZGP);
PX_TEX.clear();
{? PX_TEX.seek(_px_tex)
||
:: warunkiem jest istnienie chociaz jednego etapu
   PX_STAGE.index('TEX_NR'); PX_STAGE.prefix(PX_TEX.ref());
   {? PX_STAGE.first()
   ||
::    tabela zapamietujaca pierwotne numery PX_STAGE w ramach przepisu
      _kol:=tab_tmp(1
               ,'NR','INTEGER','NR'
               ,'ZGH','INTEGER','#ZGH.ref()'
               ,'PX_STAGE','INTEGER','PX_STAGE.ref()');
      {!
      |? _kol.blank();
         _kol.NR:=PX_STAGE.NR;
         _kol.PX_STAGE:=#PX_STAGE.ref();
         _kol.ZGH:=#exec('find_ZGH4STAGE','px_stage',PX_STAGE.ref());
         _kol.add();
         PX_STAGE.next()
      !};
::    od tej chwili interesuja nas juz tylko etapy wpisane w _kol
      {? _kol.first()
      ||
         PX_STAGE.prefix();
         _cur_zgh:=0;
::       ktore nalerza do przewodnika z ktorego pochodzi _fin_stg
         {? _fin_stg=0
         || {? PX_STAGE.seek(_kol.PX_STAGE,) || _cur_zgh:=#exec('find_ZGH4STAGE','px_stage',PX_STAGE.ref()) ?}
         || _cur_zgh:=#exec('find_ZGH4STAGE','px_stage',_fin_stg)
         ?};
::       przewijamy _kol na 1 rekord z tego przewodnika
         {! |? {? _kol.ZGH<>_cur_zgh || _kol.next() || 0 ?} !};
         {!
         |?
            {? PX_STAGE.seek(_kol.PX_STAGE,)
            ||
               _my_tex:=PX_STAGE.PX_TEX;
               PX_NAST.index('NEXT'); PX_NAST.prefix(PX_STAGE.ref());
::             sprawdzamy wszystkie etapy, dla ktorych biezacy jest nastepnikiem
               {? PX_NAST.first()
               ||
                  {!
                  |?
::                   interesuja nas tylko te PX_NAST, ktore przychodza z innego przepisu
                     {? PX_NAST.PX_TEX<>_my_tex
                     ||
::                      rekurencja - _pop_nr moze tylko tak jak entropia - rosnac
                        _pop_nr:=exec('rentex_simple','px_stage',PX_NAST.PX_TEX,_pop_nr,PX_NAST.PX_STAGE)
                     ?};
                     PX_NAST.next()
                  !}
               ?};
::             nadanie numeru PX_STAGE
               _pop_nr+=1;
               {? PX_STAGE.NR<_pop_nr
               ||
::                nalezy prenumerowac wszystkie nastepne niezaleznie od ZGH tak aby zrobic miejsce na ten numer
                  _roz:=_pop_nr-PX_STAGE.NR; _cur:=PX_STAGE.ref();
                  PX_STAGE.cntx_psh();
                  _kol.cntx_psh();
                  {? _kol.last()
                  ||
                     _go:=1;
                     {!
                     |? PX_STAGE.seek(_kol.PX_STAGE,) & (PX_STAGE.ref()<>_cur)
                     |! PX_STAGE.NR+=_roz; PX_STAGE.put();
                        _go:=_kol.prev()
                     !}
                  ?};
                  _kol.cntx_pop();
                  PX_STAGE.cntx_pop();
                  PX_STAGE.get();
                  PX_STAGE.NR:=_pop_nr;
                  PX_STAGE.put()
               ?}
            ?};
::          przegladanie ma byc kontynuowane do konca tylko w przepisie 1 podzlecenia (_fin_stg=0)
::          w pozostalych, do konca biezacego rpzewodnika
            {? _kol.next()
            || {? _fin_stg=0 || 1 || _kol.ZGH=_cur_zgh ?}
            || 0
            ?}
         !}
      ?};
      obj_del(_kol)
   ?}
?};
Cntx.pop(PX_TEX,PX_NAST,PX_STAGE,ZGP);
_pop_nr


\renall_complex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Formula przenumerowuje wszystkie etapy w ramach struktury zlecenia zlozonego z przepisem zintegrowanym
::       Proceura wykonywana jest wylacznie gdy wywolano ja dla zlecenia naglowkowego
::       gdy ZL.RODZAJ='Z' & ZL.RODZ_TEX='Z'
::       Przenumerowanie odbywa sie na podstawie powiazan PX_NAST pomiedzy PX_STAGE
::       Jednak zaklada sie, ze wstepnie ramach jednego przepisu etapy numerowane sa rosnaca
::   WE: _a - ZL.ref() [VAR.A_ZLEC]
::  OLD: \PX_STAGE_renall/qharstr.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=VAR.A_ZLEC;
{? var_pres('_a')=type_of(null()) || _zl:=_a ?};
{? ref_name(_zl)<>ZL.name() || return() ?};

Cntx.psh(ZL,PX_TEX,PX_NAST,PX_STAGE);
ZL.clear();
{? ZL.seek(_zl) & (ZL.RODZAJ='Z') & (ZL.RODZ_TEX='Z')
|| _zlp:=exec('main_podzlec','zl_link',_zl);
   {? _zlp<>null()
   ||
      Cntx.psh(PX_TEX,PX_NAST,PX_STAGE,ZGP,ZGH);
      ZGH.clear();
::    analiza rozpoczyna sie od aktywnego przepisu 1 podzlecenia
      PX_TEX.index('ZLASYM'); PX_TEX.prefix(_zl,'T');
      {? PX_TEX.first()
      ||
::       warunkiem jest istnienie chociaz jednego etapu
         PX_STAGE.index('TEX_NR'); PX_STAGE.prefix(PX_TEX.ref());
         {? PX_STAGE.first()
         ||
::          tabela zapamietujaca pierwotne numery PX_STAGE w ramach przepisu
            _allstg:=tab_tmp(1
                     ,'NR','INTEGER','NR'
                     ,'ZGH','INTEGER','#ZGH.ref()'
                     ,'ZL','INTEGER','#ZGH.ZLEC'
                     ,'ZL_SYM','STRING[20]','Symbol zlecenia'
                     ,'PX_STAGE','INTEGER','#PX_STAGE.ref()'
                     ,'NRNEW','INTEGER','Nowy numer etapu');
            {!
            |? _allstg.blank();
               _allstg.NR:=PX_STAGE.NR;
               _allstg.PX_STAGE:=#PX_STAGE.ref();
               _allstg.ZGH:=#exec('find_ZGH4STAGE','px_stage',PX_STAGE.ref());
               ZGH.cntx_psh();
               {? (_allstg.ZGH>0) & ZGH.seek(_allstg.ZGH,)
               || _allstg.ZL:=ZGH.ZLEC;
                  _allstg.ZL_SYM:=ZGH.ZLEC().SYM
               ?};
               ZGH.cntx_pop();
               _allstg.add();
               PX_STAGE.next()
            !};
::          analiza rozpoczynana od 1 podzlecenia
::          indeks obowiazujacy w ramach analizy
            _indzl:=_allstg.ndx_tmp(,,'ZL',,, 'NR',,);
            _indpx:=_allstg.ndx_tmp(,,'PX_STAGE',,, 'NR',,);
            _allstg.index(_indzl);
            _allstg.prefix(#_zlp);
            {? _allstg.first()
            ||
::             przekazanie do procedury rekurencyjnej
               PX_STAGE.clear();
               {? PX_STAGE.seek(_allstg.PX_STAGE,)
               ||
                  exec('rentex_complex','px_stage',_allstg,_indpx,PX_STAGE.ref(),0,null())
               ?}
            ?};
            _allstg.index(_allstg.ndx_tmp(,,'NRNEW',,));
            {? _allstg.first()
            ||
               {? _allstg.NRNEW<>0
               ||
::                w transakcji przenumerowanie etapow
                  _do:=do_state()=0; _blad:=0;
::                >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                  {? _do || do() ?};
::                najpierw przesuniecie numerow etapow poza dziedzine, aby podczas porzadkowania nie spowodowac podwojenia indeksu
                  {!
                  |? {? PX_STAGE.seek(_allstg.PX_STAGE,)
                     || PX_STAGE.NR:=-PX_STAGE.NR;
                        PX_STAGE.put()
                     || _blad:=1
                     ?};
                     (_blad=0) & _allstg.next()
                  !};
::                teraz nadanie nowych numerow etapom
                  {? (~_blad) & _allstg.first()
                  || {!
                     |?
                        PX_STAGE.seek(_allstg.PX_STAGE,);
                        PX_STAGE.NR:=_allstg.NRNEW;
                        PX_STAGE.put();
                        _allstg.next()
                     !};
::                   i na koniec poprzeczepianie powiazan wewnetrznych PX_STAGE
::                     exec('PX_STAGE_stgkol','qharstr',PX_TEX.ref())
                     ~~
                  ?};
                  {? _blad || undo() ?};
                  {? _do || end() ?}
::                <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
               || FUN.emsg('Nieprawidłowa struktura powiązań przewodników.\nPrzenumerowanie etapów niemożliwe.'@)
               ?}
            ?};
            obj_del(_allstg)
         ?}
      ?};
      Cntx.pop(PX_TEX,PX_NAST,PX_STAGE,ZGP,ZGH)
   ?}
?};
Cntx.pop(ZL,PX_TEX,PX_NAST,PX_STAGE)


\rentex_complex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Renumeracja etapow w ramach wskazanego przepisu
::   WE: _a - tabela z wykazem wszystkich etapow przepisu
::       _b - index tabeli _a do szukania wg PX_STAGE
::       _c - etap wskazujacy fragment przepisu do analizy
::       _d - ostatni wykorzystany numer
::       _e - PX_STAGE.ref() etapu z ktorego wychodzi powiazanie wyzej
::            _a.. _d, musza byc podane, inaczej ma zglosic blad, bo nie ma dobrej opcji przy blednych parametrach
::   WY: najwyzszy wykorzystany numer
::  OLD: \PX_STAGE_rentex/qharstr.fml
::----------------------------------------------------------------------------------------------------------------------
_allstg:=_a;
_indpx:=_b;
_stg:=_c;
_pop_nr:=_d;
_fin_stg:=null();

{? var_pres('_e')=type_of(null()) || _fin_stg:=_e ?};

_ind:=_allstg.index('?');
_allstg.index(_indpx); _allstg.clear();
{? _allstg.find_key(#_stg)
||
   _allstg.index(_ind);
:: tabela zapamietujaca pierwotne numery PX_STAGE w ramach zlecenia
   _kol:=tab_tmp(1
         ,'NR','INTEGER','NR'
         ,'ZGH','INTEGER','#ZGH.ref()'
         ,'PX_STAGE','INTEGER','PX_STAGE.ref()'
         ,'ALL','INTEGER','#_allstg.ref()'
      );
   _allstg.prefix(_allstg.ZL);
   _allstg.first();
   {!
   |?
      _kol.blank();
      _kol.NR:=_allstg.NR;
      _kol.ZGH:=_allstg.ZGH;
      _kol.PX_STAGE:=_allstg.PX_STAGE;
      _kol.ALL:=#_allstg.ref();
      _kol.add();
      _allstg.next()
   !};
   Cntx.psh(PX_TEX,PX_NAST,PX_STAGE,ZGP,ZGH);
:: od tej chwili interesuja nas juz tylko etapy wpisane w _kol
   {? _kol.first()
   ||
      PX_STAGE.clear();
      _cur_zgh:=0;
::    ktore nalerza do przewodnika z ktorego pochodzi _fin_stg
      {? _fin_stg=0
      || {? PX_STAGE.seek(_kol.PX_STAGE,) || _cur_zgh:=#exec('find_ZGH4STAGE','px_stage',PX_STAGE.ref()) ?}
      || _cur_zgh:=#exec('find_ZGH4STAGE','px_stage',_fin_stg)
      ?};

::    przewijamy _kol na 1 rekord z tego przewodnika
      {! |? {? _kol.ZGH<>_cur_zgh || _kol.next() || 0 ?} !};

::    rozpoczynamy analize z zaglebianiem sie w powiazania strukturalne
      {!
      |?
         {? PX_STAGE.seek(_kol.PX_STAGE,)
         ||
            _ten_stg:=PX_STAGE.ref();
            _my_zgh:=#exec('find_ZGH4STAGE','px_stage',_ten_stg);
            PX_NAST.index('NEXT'); PX_NAST.prefix(_ten_stg);
::          sprawdzamy wszystkie etapy, dla ktorych biezacy jest nastepnikiem
            {? PX_NAST.first()
            ||
               {!
               |?
::                interesuja nas tylko te PX_NAST, ktore przychodza innego przewodnika
                  _zgh_cur:=#exec('find_ZGH4STAGE','px_stage',PX_NAST.PX_STAGE);
                  {? _zgh_cur<>_my_zgh
                  ||
::                   rekurencja - _pop_nr moze tylko tak jak entropia - rosnac
                     _pop_nr:=exec('rentex_complex','px_stage',_allstg,_indpx,PX_NAST.PX_STAGE,_pop_nr,PX_NAST.PX_STAGE)
                  ?};
                  PX_NAST.next()
               !}
            ?};
::          nadanie numeru dla PX_STAGE
            _pop_nr+=1;
::          nadanie nowych numeru dla etapu i zapisanie tymczasowe w _allstg
            _allstg.clear(); _allstg.seek(_kol.ALL,);
            {? _allstg.NRNEW<_pop_nr
            ||
::             nalezy prenumerowac wszystkie nastepne niezaleznie od ZGH w ramach tego samego zlecenia
               _num:=_allstg.NRNEW:=_pop_nr;   _allstg.put();
               _kol.cntx_psh();
               {!
               |? _kol.next()
               |! _allstg.seek(_kol.ALL,);
                  _num+=1;
                  _allstg.NRNEW=_num; _allstg.put()
               !};
               _kol.cntx_pop()
            ?}
         ?};
::       przegladanie ma byc kontynuowane do konca tylko w przepisie 1 podzlecenia (_fin_stg=0)
::       w pozostalych, do konca biezacego rpzewodnika
         {? _kol.next()
         || {? _fin_stg=0 || 1 || _kol.ZGH=_cur_zgh ?}
         || 0
         ?}
      !}
   ?};
   obj_del(_kol);
   Cntx.pop(PX_TEX,PX_NAST,PX_STAGE,ZGP,ZGH)
?};
_allstg.index(_ind);
_pop_nr


\find_ZGH4STAGE
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Znalezienie ZGH powiazanego z danym PX_STAGE
::   WE: _a - PX_STAGE.ref()
::   WY: ZGH.ref() lub null()
::----------------------------------------------------------------------------------------------------------------------
{? (var_pres('_a')<>type_of(null())) | (ref_name(_a)<>PX_STAGE.name()) || return(null()) ?};

_result:=null();
ZGP.index('PX_STAGE');
{? ZGP.find_key(_a)
|| {? ZGP.NRZLP=null()
   || _result:=ZGP.NRPRZ
   || _result:=ZGP.NRZLP
   ?}
?};
_result


\is_kj_bad
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.46]
:: OPIS: Sprawdza czy PX_STAGE jest powiazany ze zrodlowa operacja (ZGP, ZOPER, TOPER) która ma badania
::   WE: _a - PX_STAGE.ref()
::   WY: 'B' - PX_STAGE jest powiazany z operacją która ma badania
::       'P' - PX_STAGE jest powiązany z operacja która ma proste potwierdzanie ilości
::       'N' - PX_STAGE nie jest powiazany z operacją która ma badania
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:='';

PX_STAGE.cntx_psh(); PX_STAGE.clear();
{? PX_STAGE.seek(_px_stage)
||
:: 1. Powiazania z ZGP
   {? _result=''
   || ZGP.cntx_psh();
      ZGP.index('PX_STAGE');
      ZGP.prefix(PX_STAGE.ref());
      {? ZGP.first()
      ||
         _result:='N';
         {!
         |? {? ZGP.KJ_BAD='B'
            || _result:='B'
            |? ZGP.KJ_BAD='P'
            || _result:='P'
            ?};
            ZGP.next() & _result='N'
         !}
      ?};
      ZGP.cntx_pop()
   ?};
:: 2. Powiazania z TOPER
   {? _result=''
   || TOPER.cntx_psh();
      TOPER.index('PX_STAGE');
      TOPER.prefix('T',PX_STAGE.ref());
      {? TOPER.first()
      ||
         _result:='N';
         {!
         |? {? TOPER.KJ_BAD='B'
            || _result:='B'
            |? TOPER.KJ_BAD='P'
            || _result:='P'
            ?};
            TOPER.next() & _result='N'
         !}
      ?};
      TOPER.cntx_pop()
   ?}
?};
PX_STAGE.cntx_pop();
_result


\is_kontrol
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: MagLak [12.46]
:: OPIS: Sprawdza czy PX_STAGE jest powiazany ze zrodlowa operacja (ZGP, ZOPER, TOPER) kontroli jakości
::   WE: _a - PX_STAGE.ref()
::   WY: 'T' - PX_STAGE jest powiazany z operacją kontroli jakości
::       'N' - PX_STAGE nie jest powiazany z operacją kontroli jakości
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:='';

PX_STAGE.cntx_psh(); PX_STAGE.clear();
{? PX_STAGE.seek(_px_stage)
||
:: 1. Powiazania z ZGP
   {? _result=''
   || ZGP.cntx_psh();
      ZGP.index('PX_STAGE');
      ZGP.prefix(PX_STAGE.ref());
      {? ZGP.first()
      ||
         _result:='N';
         {!
         |? {? ZGP.KONTROLA='T'
            || _result:='T'
            ?};
            ZGP.next() & _result='N'
         !}
      ?};
      ZGP.cntx_pop()
   ?};
:: 2. Powiazania z TOPER
   {? _result=''
   || TOPER.cntx_psh();
      TOPER.index('PX_STAGE');
      TOPER.prefix('T',PX_STAGE.ref());
      {? TOPER.first()
      ||
         _result:='N';
         {!
         |? {? TOPER.KONTROLA='T'
            || _result:='T'
            ?};
            TOPER.next() & _result='N'
         !}
      ?};
      TOPER.cntx_pop()
   ?}
?};
PX_STAGE.cntx_pop();
_result


\is_rp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [21.14]
:: OPIS: Sprawdza czy PX_STAGE jest powiazany ze zrodlowa operacja (ZGP, ZOPER, TOPER) raportującą dokument
::   WE: _a - PX_STAGE.ref()
::   WY: 'T' - PX_STAGE jest powiazany z operacją kontroli jakości
::       'N' - PX_STAGE nie jest powiazany z operacją kontroli jakości
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:='';

PX_STAGE.cntx_psh(); PX_STAGE.clear();
{? PX_STAGE.seek(_px_stage)
||
:: 1. Powiazania z ZGP
   {? _result=''
   || ZGP.cntx_psh();
      ZGP.index('PX_STAGE');
      ZGP.prefix(PX_STAGE.ref());
      {? ZGP.first()
      ||
         _result:='N';
         {!
         |? {? ZGP.DOK<>null()
            || _result:='T'
            ?};
            ZGP.next() & _result='N'
         !}
      ?};
      ZGP.cntx_pop()
   ?};
:: 2. Powiazania z TOPER
   {? _result=''
   || TOPER.cntx_psh();
      TOPER.index('PX_STAGE');
      TOPER.prefix('T',PX_STAGE.ref());
      {? TOPER.first()
      ||
         _result:='N';
         {!
         |? {? TOPER.DOK<>null()
            || _result:='T'
            ?};
            TOPER.next() & _result='N'
         !}
      ?};
      TOPER.cntx_pop()
   ?}
?};
PX_STAGE.cntx_pop();
_result


\kolor_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [1246]
:: OPIS: Przed wyswietl pola tabeli PX_STAGE.KOLOR
::   WY: String koloru
::----------------------------------------------------------------------------------------------------------------------
_wyn:=PX_STAGE.KOLOR+','+PX_STAGE.KOLOR;
_wyn


\kolor_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [2010]
:: OPIS: Formula na F3 pola PX_STAGE.KOLOR
::----------------------------------------------------------------------------------------------------------------------
_q:=exec('edit_color','#edit',PX_STAGE.KOLOR);
{? _q<>''
|| PX_STAGE.KOLOR:=_q
?};
~~


\has_oper_prev
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy dany etap ma jakies poprzedniki
::   WE: [_a] - PX_STAGE.ref
::   WY: 0 - nie ma
::       1 - ma
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_STAGE.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_STAGE.cntx_psh();
{? _ref<>null()
|| PX_STAGE.prefix();
   {? PX_STAGE.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_NAST.cntx_psh();
   PX_NAST.index('NEXT');
   PX_NAST.prefix(PX_STAGE.ref());
   {? PX_NAST.size()>0
   || _result:=1
   ?};
   PX_NAST.cntx_pop();
   ~~
?};
PX_STAGE.cntx_pop();
_result


\has_oper_next
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy dany etap ma jakies nastepniki
::   WE: [_a] - PX_STAGE.ref
::   WY: 0 - nie ma
::       1 - ma
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_STAGE.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_STAGE.cntx_psh();
{? _ref<>null()
|| PX_STAGE.prefix();
   {? PX_STAGE.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_NAST.cntx_psh();
   PX_NAST.index('PX');
   PX_NAST.prefix(PX_STAGE.ref());
   {? PX_NAST.size()>0
   || _result:=1
   ?};
   PX_NAST.cntx_pop()
?};
PX_STAGE.cntx_pop();
_result


\stages_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy tablice tymczasową zawierającą etapy
::   WY: tab_tmp
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=tab_tmp(1,
   'REF','STRING[16]','Ref etapu',
   'NR','INTEGER','Nr etapu',
   'NAME','STRING[100]','Nazwa etapu',
   'PX_SET','STRING[16]','Zestaw etapu',
   'SET_DEF','STRING[1]','Czy zestaw etapu domyślny'
);
_result


\stages_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Dodaje do tabeli z etapami bieżącego PX_STAGE o ile jeszcze go tam nie ma
::   WE: _a - tab_tmp - tabelka do której dodawać
::       [_b] - PX_STAGE.ref() - etap który dodać lub bieżący rekord
::   WY: 0/1
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_ref:=null();
{? var_pres('_b')=type_of(PX_STAGE.ref())
|| _ref:=_b
?};

_result:=1;
_can_continue:=1;

PX_STAGE.cntx_psh();
{? _ref<>null()
|| PX_STAGE.prefix();
   {? PX_STAGE.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _tab.prefix($PX_STAGE.ref());
   {? _tab.size()=0
   ||
      _tab.blank();
      _tab.NR:=PX_STAGE.NR;
      _tab.REF:=$PX_STAGE.ref();
      _tab.NAME:=PX_STAGE.NAZWA;
      _tab.PX_SET:=$PX_STAGE.PX_SET;
      _tab.SET_DEF:=PX_STAGE.PX_SET().DEFAULT;
      _result:=_tab.add()
   ?}
?};
PX_STAGE.cntx_pop();
_result


\stages_starting_ending
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca tabelkę zawierającą wszystkie operacje bez poprzedników (strartowe w danym przepisie)
::   WE: [_a] - PX_TEX.ref() - przepis
::       [_b] - TKTL.ref()   - karta technologiczna
::       [_c] - INTEGER - -1/[1] - czy zwracać początkowe operacje (1), czy końcowe (-1)
::   WY: tab_tmp - tabelka zawierająca etapy początkowe w danym przepisie, pola: NR,REF,NAME,PX_SET,SET_DEF
::                 wynik działania exec('stages_tab','px_stage')
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_rtktl:='';

_ref:=null();
{? var_pres('_a')=type_of(PX_TEX.ref())
|| _ref:=_a;
   _rtktl:=exec('FindAndGet','#table',PX_TEX,_ref,,"RTKTL",'')
?};

_tktl:=null();
{? var_pres('_b')=type_of(TKTL.ref())
|| _tktl:=_b;
   _rtktl:=$_tktl
?};

_dir:=1;
{? var_pres('_c')=type_of(0)
|| _dir:=_c
?};

_result:=exec('stages_tab','px_stage');
_ndx_nr:=_result.ndx_tmp(,,'NR',,);

_can_continue:=1;

PX_TEX.cntx_psh();

{? _can_continue>0
||
   PX_SET.cntx_psh();
   PX_STAGE.cntx_psh();
   PX_STAGE.index('TEX_NR');
   _size:=0;
   {? _ref<>null()
   ||
      PX_STAGE.prefix(_ref);
      {? PX_STAGE.first()
      || _size:=PX_STAGE.size();
::       Etapy należą do przepisu
         {!
         |?
            _has_next:=0;
            {? _dir>0
            || _has_next:=exec('has_oper_prev','px_stage')
            |? _dir<0
            || _has_next:=exec('has_oper_next','px_stage')
            ?};

            {? _has_next=0
            ||
::          Jeśli nie ma poprzedników to znak że startowy/końcowy
               exec('stages_add','px_stage',_result)
            ?};
            PX_STAGE.next()
         !}
      ?}
   ?};
:: Etapy należą do technologii
   {? _size=0 & _rtktl<>''
   ||
      PX_STAGE.index('TKTL_NR');
      PX_STAGE.prefix(_rtktl);
      {? PX_STAGE.first()
      || {!
         |?
            _has_next:=0;
            {? _dir>0
            || _has_next:=exec('has_oper_prev','px_stage')
            |? _dir<0
            || _has_next:=exec('has_oper_next','px_stage')
            ?};

            {? _has_next=0
            ||
::             Jeśli nie ma poprzedników to znak że startowy/końcowy
               exec('stages_add','px_stage',_result)
            ?};
            PX_STAGE.next()
         !}
      ?}
   ?};
   PX_SET.cntx_pop();
   PX_STAGE.cntx_pop();
   ~~
?};
_result.index(_ndx_nr);
_result.prefix();
PX_TEX.cntx_pop();
_result


\stages_next
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca następniki podanej operacji
::   WE: [_a] - PX_STAGE.ref lub bieżący rekord
::       [_b] - INTEGER - -1/[1] - czy zwracać następniki operacji (1), czy poprzedniki (-1)
::   WY: tab_tmp - tabelka zawierająca etapy początkowe w danym przepisie, pola: NR,REF,NAME,PX_SET,SET_DEF
::                 wynik działania exec('stages_tab','px_stage')
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_STAGE.ref())
|| _ref:=_a
?};

_dir:=1;
{? var_pres('_b')=type_of(0)
|| _dir:=_b
?};

_result:=exec('stages_tab','px_stage');
_can_continue:=1;

PX_STAGE.cntx_psh();
{? _ref<>null()
|| PX_STAGE.prefix();
   {? PX_STAGE.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_NAST.cntx_psh();
   {? _dir>0
   || PX_NAST.index('PX')
   |? _dir<0
   || PX_NAST.index('NEXT')
   ?};
   PX_NAST.prefix(PX_STAGE.ref());
   {? PX_NAST.first()
   || {!
      |?
         _stage:=null();

         {? _dir>0
         || _stage:=PX_NAST.PX_NEXT
         |? _dir<0
         || _stage:=PX_NAST.PX_STAGE
         ?};

         {? _stage<>null()
         || exec('stages_add','px_stage',_result,_stage)
         ?};
         PX_NAST.next()
      !}
   ?};
   PX_NAST.cntx_pop();
   ~~
?};
PX_STAGE.cntx_pop();
_result


\px_nast_chk_required
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Sprawdza czy trzeba wykonywać kontrolę utworzenia następników dla danego etapu.
::       Kontrola może być niewymagana jeżeli PX_STAGe powstał na podstawie jednopozycyjnych przewodników zlecenia
::   WE: [_a] - PX_STAGE.ref
::   WY: 0 - kontrola niewymagana
::       1 - wymagana
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_STAGE.ref())
|| _ref:=_a
?};

_result:=1;
_can_continue:=1;

PX_STAGE.cntx_psh();
{? _ref<>null()
|| PX_STAGE.prefix();
   {? PX_STAGE.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| ZGP.cntx_psh();
   ZGH.cntx_psh();
   ZGP.index('PX_STAGE');
   ZGP.prefix(PX_STAGE.ref());
   {? ZGP.first()
   ||
::    PX_STAGE powstał na podstawie ZGPa
      _zgh:=ZGP.NRZLP;
      ZGP.index('NRPP');
      ZGP.prefix(_zgh,'N');
      _size:=0;
      {? ZGP.first()
      || {!
         |? {? ZGP.NAPRAW<>'T'
            || _size+=1
            ?};
            ZGP.next()
         !}
      ?};
      {? _size=1
      || _result:=0
      ?}
   ?};
   ZGH.cntx_pop();
   ZGP.cntx_pop();
   ~~
?};
PX_STAGE.cntx_pop();
_result


\toper_clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Usuwa powiązania wszystkich PX_STAGE do wskazanego TOPERa
::   WE: [_a] - TOPER.ref lub bieżący ref
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(TOPER.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

TOPER.cntx_psh();
{? _ref<>null()
|| TOPER.prefix();
   {? TOPER.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_STAGE.index('RTOPER');
   PX_STAGE.prefix($TOPER.ref(),);
   {? PX_STAGE.first()
   || {!
      |? PX_STAGE.cntx_psh();
         PX_STAGE.clear();
         PX_STAGE.TOPER:=null();
         PX_STAGE.RTOPER:='';
         _can_continue:=PX_STAGE.put();
         PX_STAGE.cntx_pop();
         PX_STAGE.first() & _can_continue>0
      !}
   ?}
?};
TOPER.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result

:Sign Version 2.0 jowisz:1045 2024/02/15 08:04:14 1a44604618d943ee7ec238231d1ea9456d21bc19f630056d7f6a02e407f9cebec281294625d102bb41c0f05660d652a2919737fdc27243444f9256acebb59cf03a0a4804e8b5803cc340e9267c99ab8aa19b0860bdb3e43e1053c5224537b7b01435f3dc7b7af816f54e1503b68b57d347bb587068f178eabfa9993b9832d423
