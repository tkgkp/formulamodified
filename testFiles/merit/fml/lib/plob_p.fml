:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: plob_pb.fml
:: Utworzony: 04.07.2018
:: Autor: TMR
::======================================================================================================================
:: Zawartość: Formuły do obsługi tabeli formuł wykorzystywanych do definiowania obiektu lokalizacji
::======================================================================================================================


\trig_add_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [18.42]
:: OPIS: Trigger przed dodaniem PLOB_P
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('trig_mod_b','plob_p')


\trig_put_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [18.42]
:: OPIS: Trigger przed poprawieniem PLOB_P
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('trig_mod_b','plob_p')


\trig_mod_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [18.42]
:: OPIS: Trigger przed modyfikacją PLOB_P
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? PLOB_P.PLOB_H
|| PLOB_P.PLOB_L:=PLOB_P.PLOB_H().PLOB_L;
   PLOB_P.KK:=PLOB_H.KK
?};
1


\del_podz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [18.42]
:: OPIS: Funkcja sprawdza czy są, a jeżeli tak to usuwa podziały z właściwej tabeli przypisań
::   WE:  _a  [REFERENCE] - wskazanie na pracownika
::        _b  [STRING]    - warstwa 'p'(Plan)/'g'(Grafik)/'w'(Wykonanie)
::        _c  [DATE]      - data podziału
::       [_d] [TIME]      - godz od
::       [_e] [TIME]      - godz od
::   WY: -1/0/1
::----------------------------------------------------------------------------------------------------------------------
_result:=-1;
  _p_ref:={? var_pres('_a')=7 || _a   || return(_result) ?};
_warstwa:={? var_pres('_b')=2 || ~-_b || return(_result) ?};
_data_dp:={? var_pres('_c')=4 || _c   || return(_result) ?};
     _od:={? var_pres('_d')=4 || _d   || time(0,0,0)     ?};
     _do:={? var_pres('_e')=4 || _e   || time(0,0,0)     ?};

PLOB_P.cntx_psh();
PLOB_P.index('PRAC');
PLOB_P.prefix(_p_ref,_warstwa,_data_dp);
{? PLOB_P.first()
|| {? _od=_do & _od=time(0,0,0)
::    usuwamy wszystko
   || {! |? PLOB_P.del() !}
::    usuwamy tylko rekord pasujący
   || {!
      |? {? PLOB_P.GODZ_OD=_od & PLOB_P.GODZ_DO=_do
         || PLOB_P.del()
         || PLOB_P.next()
         ?}
      !}
   ?}
?};
_result:=(PLOB_P.size()=0);
PLOB_P.cntx_pop();
_result


\copyPodz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [18.42]
:: OPIS: Kopiowanie podziałów pomiędzy warstwami w zakresie dat
::   WE: _a [REFERENCE]  - wskazanie na pracownika
::       _b [STRING]     - warstwa z
::       _c [STRING]     - warstwa do
::       _d [DATE]       - data od
::       _e [DATE]       - data do
::   WY: -1/0/1
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_p_ref:={? var_pres('_a')=7 || _a || return(_result) ?};
  _w_z:={? var_pres('_b')=2 || _b || return(_result) ?};
 _w_do:={? var_pres('_c')=2 || _c || return(_result) ?};
   _od:={? var_pres('_d')=4 || _d || return(_result) ?};
   _do:={? var_pres('_e')=4 || _e || return(_result) ?};

:: powrot w przypadku zerwanej transakcji
{? do_state()=2 || return(_result) ?};

:: zalozenie transakcji
_mydo:=do_state()=0;
{? _mydo || do() ?};

_buffer:=exec('buffer','plob_p');

PLOB_P.cntx_psh();
PLOB_P.index('PRAC');
PLOB_P.prefix();
{! _data:=#_od..#_do
|! _dzien:=#_data;
:: usuwamy podzial w warstwie "do"
   {? exec('del_podz','plob_p',_p_ref,_w_do,_dzien)
   ||
::    wyszukujemy podzial w warstwie "od"
      PLOB_P.prefix(_p_ref,_w_z,_dzien);
      {? PLOB_P.first()
      || {!
         |? _buffer.blank(~~);
            _buffer.get();
            _buffer.GPW:=_w_do;
::          dodajemy podzial do warstwy "do"
            _result+=exec('add','plob_p',_buffer);
            PLOB_P.next()
         !}
      ?}
   ?}
!};
PLOB_P.cntx_pop();

{? _mydo || end() ?};

_result


\add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [18.42]
:: OPIS: Funkcja dodajaca wpis do PLOB_P
::   WE: _a - [obj_new] - bufor tabeli PLOB_P
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_buffer:={? var_pres('_a')=117 || _a || return(0) ?};
_res:=0;
PLOB_P.cntx_psh();
PLOB_P.prefix();
PLOB_P.blank(1);
:: Przepisanie z obiektu do tabeli
_buffer.set(_buffer);
_res:=PLOB_P.add();
PLOB_P.cntx_pop();
_res


\exist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [18.42]
:: OPIS: Funkcja sprawdza czy na podaną datę istnieją zapisu podziałów
::   WE: _a [REFERENCE] - wskazanie na pracownika
::       _b [STRING]    - sprawdzana warstwa
::       _c [DATE]      - data badania
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
  _p_ref:={? var_pres('_a')=type_of(null) || _a   || return(_result) ?};
_warstwa:={? var_pres('_b')=type_of('')   || ~-_b || return(_result) ?};
   _data:={? var_pres('_c')=type_of(date) || _c   || return(_result) ?};

PLOB_P.cntx_psh();
PLOB_P.index('PRAC');
PLOB_P.prefix(_p_ref,_warstwa,_data);
_result:=PLOB_P.first();
PLOB_P.cntx_pop();
_result


\cut
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [18.42]
:: OPIS: Funkcja przycinająca zapisy podziałów
::   WE: _a [REFERENCE] - wskazanie na pracownika
::       _b [STRING]    - warstwa
::       _c [DATE]      - data
::       _d [NUMBER]    - wejście (2) / wyjście (3) - zgodnie ze statusem wejść/wyjść z R_REJ_WW
::       _e [TIME]      - stara wartość godziny
::       _f [TIME]      - nowa wartość godziny
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
  _p_ref:={? var_pres('_a')=type_of(null) || _a   || return(_result) ?};
_warstwa:={? var_pres('_b')=type_of('')   || ~-_b || return(_result) ?};
   _data:={? var_pres('_c')=type_of(date) || _c   || return(_result) ?};
 _status:={? var_pres('_d')=type_of(0)    || _d   || return(_result) ?};
  _g_old:={? var_pres('_e')=type_of(time) || _e   || return(_result) ?};
  _g_new:={? var_pres('_f')=type_of(time) || _f   || return(_result) ?};

PLOB_P.cntx_psh();
PLOB_P.index('PRAC');
PLOB_P.prefix(_p_ref,_warstwa,_data);
:: przycinamy podział rozpoczynający lub kończący się tak jak stara godzina przekazana do funkcji
{? PLOB_P.first()
|| {!
   |? _del:=0;
      _jest:=0;
::    przycinamy wejście więc sprawdzamy godzinę rozpoczęcia podziału
      {? _status=2 & PLOB_P.GODZ_OD=_g_old
      || _jest:=1;
         {? _g_new<PLOB_P.GODZ_DO
         || PLOB_P.GODZ_OD:=_g_new
         || _del:=1
         ?}
      |? _status=2 & _g_new>PLOB_P.GODZ_OD
      || _jest:=1;
         {? _g_new<PLOB_P.GODZ_DO
         || PLOB_P.GODZ_OD:=_g_new
         || _del:=1
         ?}
::    przycinamy wyjście więc sprawdzamy godzinę zakończenia podziału
      |? _status=3 & PLOB_P.GODZ_DO=_g_old
      || _jest:=1;
         {? _g_new>PLOB_P.GODZ_OD
         || PLOB_P.GODZ_DO:=_g_new
         || _del:=1
         ?}
      |? _status=3 & PLOB_P.GODZ_DO>_g_new
      || _jest:=1;
         {? PLOB_P.GODZ_OD<=_g_new
         || PLOB_P.GODZ_DO:=_g_new
         || _del:=1
         ?}
      ?};
      {? _jest
      || _result:={? _del || PLOB_P.del() || PLOB_P.put(1); PLOB_P.next() ?}
      || PLOB_P.next()
      ?}
   !}
?};
PLOB_P.cntx_pop();
_result

:: - - - - - - - - BUFFER dla tabeli PLOB_P - - - - -

\buffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW:  TMR [18.42]
:: OPIS: tablica buforowa dla tabeli PLOB_P
::   WE: FORMULA [_a] - dodatkowe pola do obiektu - umieszczane na końcu - nie obsługiwane przez standardowe metody [""]
::   WY: tablica buforowa o następującej strukturze
::----------------------------------------------------------------------------------------------------------------------
_buffer:=$("obj_new('Ref'
      ,'P'
      ,'PLOB_H'
      ,'PLOB_L'
      ,'KK'
      ,'GPW'
      ,'DATA_OD'
      ,'DATA_DO'
      ,'DATA_DP'
      ,'GODZ_OD'
      ,'GODZ_DO'
      ,'GR'
      ,'STATUS'
      ,'IDADD'
      ,'IDPUT'
      ,'blank'
      ,'bl_void'
      ,'bl_table'
      ,'voidize'
      ,'get'
      ,'set'
      ,'mask'
      ,'maskSet'
      ,'setf'
      ,'cntx_get'
      ,'ref'
      ,'name'
      ,'this'
      ,'acronyms'
      ,'types'
      "+{? var_pres('_a')=3 & form(_a)<>'' || ","+_a || "" ?}+"
      )");
_buffer:=_buffer();

:: metody - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

_buffer.blank:="
      {? var_pres('_a')=0   || .bl_void()
      |? var_pres('_a')>100 || .bl_table(_a)
      || .bl_table(PLOB_P)
      ?}
      ";

_buffer.bl_void:="
      .P:=~~;
      .PLOB_H:=~~;
      .PLOB_L:=~~;
      .KK:=~~;
      .GPW:=~~;
      .DATA_OD:=~~;
      .DATA_DO:=~~;
      .DATA_DP:=~~;
      .GODZ_OD:=~~;
      .GODZ_DO:=~~;
      .GR:=~~;
      .STATUS:=~~;
      .IDADD:=~~;
      .IDPUT:=~~;
      .Ref:=null();
      1
      ";

_buffer.bl_table:="
      _tab:=PLOB_P;
      _tab.cntx_psh();
      _tab.blank(1);
      .get(1);
      _tab.cntx_pop();
      _tab.get();
      .Ref:=null();
      1
      ";

_buffer.voidize:="
      {? exec('is_empty_value','#var',.Ref)>0 || .Ref:=~~ ?};
      {? exec('is_empty_value','#var',.P)>0 || .P:=~~ ?};
      {? exec('is_empty_value','#var',.PLOB_H)>0 || .PLOB_H:=~~ ?};
      {? exec('is_empty_value','#var',.PLOB_L)>0 || .PLOB_L:=~~ ?};
      {? exec('is_empty_value','#var',.KK)>0 || .KK:=~~ ?};
      {? exec('is_empty_value','#var',.GPW)>0 || .GPW:=~~ ?};
      {? exec('is_empty_value','#var',.DATA_OD)>0 || .DATA_OD:=~~ ?};
      {? exec('is_empty_value','#var',.DATA_DO)>0 || .DATA_DO:=~~ ?};
      {? exec('is_empty_value','#var',.DATA_DP)>0 || .DATA_DP:=~~ ?};
      {? exec('is_empty_value','#var',.GODZ_OD)>0 || .GODZ_OD:=~~ ?};
      {? exec('is_empty_value','#var',.GODZ_DO)>0 || .GODZ_DO:=~~ ?};
      {? exec('is_empty_value','#var',.GR)>0 || .GR:=~~ ?};
      {? exec('is_empty_value','#var',.STATUS)>0 || .STATUS:=~~ ?};
      {? exec('is_empty_value','#var',.IDADD)>0 || .IDADD:=~~ ?};
      {? exec('is_empty_value','#var',.IDPUT)>0 || .IDPUT:=~~ ?};
      ~~
      ";

_buffer.get:="
      .P:=PLOB_P.P;
      .PLOB_H:=PLOB_P.PLOB_H;
      .PLOB_L:=PLOB_P.PLOB_L;
      .KK:=PLOB_P.KK;
      .GPW:=PLOB_P.GPW;
      .DATA_OD:=PLOB_P.DATA_OD;
      .DATA_DO:=PLOB_P.DATA_DO;
      .DATA_DP:=PLOB_P.DATA_DP;
      .GODZ_OD:=PLOB_P.GODZ_OD;
      .GODZ_DO:=PLOB_P.GODZ_DO;
      .GR:=PLOB_P.GR;
      .STATUS:=PLOB_P.STATUS;
      .IDADD:=PLOB_P.IDADD;
      .IDPUT:=PLOB_P.IDPUT;
      .Ref:=PLOB_P.ref();
      (.)
      ";

_buffer.set:="
      {? .P<>~~          || PLOB_P.P:=.P ?};
      {? .PLOB_H<>~~     || PLOB_P.PLOB_H:=.PLOB_H ?};
      {? .PLOB_L<>~~     || PLOB_P.PLOB_L:=.PLOB_L ?};
      {? .KK<>~~         || PLOB_P.KK:=.KK ?};
      {? .GPW<>~~        || PLOB_P.GPW:=.GPW ?};
      {? .DATA_OD<>~~    || PLOB_P.DATA_OD:=.DATA_OD ?};
      {? .DATA_DO<>~~    || PLOB_P.DATA_DO:=.DATA_DO ?};
      {? .DATA_DP<>~~    || PLOB_P.DATA_DP:=.DATA_DP ?};
      {? .GODZ_OD<>~~    || PLOB_P.GODZ_OD:=.GODZ_OD ?};
      {? .GODZ_DO<>~~    || PLOB_P.GODZ_DO:=.GODZ_DO ?};
      {? .GR<>~~         || PLOB_P.GR:=.GR ?};
      {? .STATUS<>~~     || PLOB_P.STATUS:=.STATUS ?};
      {? .IDADD<>~~      || PLOB_P.IDADD:=.IDADD ?};
      {? .IDPUT<>~~      || PLOB_P.IDPUT:=.IDPUT ?};
      ~~
      ";

_buffer.mask:="
      {? var_pres('_a')>100 || _target:=_a || _target:=PLOB_P ?};

      {? .P<>~~          || .maskSet(_target,'.P') ?};
      {? .PLOB_H<>~~     || .maskSet(_target,'.PLOB_H') ?};
      {? .PLOB_L<>~~     || .maskSet(_target,'.PLOB_L') ?};
      {? .KK<>~~         || .maskSet(_target,'.KK') ?};
      {? .GPW<>~~        || .maskSet(_target,'.GPW') ?};
      {? .DATA_OD<>~~    || .maskSet(_target,'.DATA_OD') ?};
      {? .DATA_DO<>~~    || .maskSet(_target,'.DATA_DO') ?};
      {? .DATA_DP<>~~    || .maskSet(_target,'.DATA_DP') ?};
      {? .GODZ_OD<>~~    || .maskSet(_target,'.GODZ_OD') ?};
      {? .GODZ_DO<>~~    || .maskSet(_target,'.GODZ_DO') ?};
      {? .GR<>~~         || .maskSet(_target,'.GR') ?};
      {? .STATUS<>~~     || .maskSet(_target,'.STATUS') ?};
      {? .IDADD<>~~      || .maskSet(_target,'.IDADD') ?};
      {? .IDPUT<>~~      || .maskSet(_target,'.IDPUT') ?};
      ~~
      ";

_buffer.maskSet:="
      _val1:=($('_a'+_b))(_a,_b); _val2:=($_b)();
      {? type_of(_val1)<>type_of(_val2)&type_of(_val1)=2
      || ($('_a'+_b+':=$'+_b))(_a,_b)
      || ($('_a'+_b+':='+_b))(_a,_b)
      ?};
      ~~
      ";

_buffer.setf:="
      PLOB_P.P:=.P;
      PLOB_P.PLOB_H:=.PLOB_H;
      PLOB_P.PLOB_L:=.PLOB_L;
      PLOB_P.KK:=.KK;
      PLOB_P.GPW:=.GPW;
      PLOB_P.DATA_OD:=.DATA_OD;
      PLOB_P.DATA_DO:=.DATA_DO;
      PLOB_P.DATA_DP:=.DATA_DP;
      PLOB_P.GODZ_OD:=.GODZ_OD;
      PLOB_P.GODZ_DO:=.GODZ_DO;
      PLOB_P.GR:=.GR;
      PLOB_P.STATUS:=.STATUS;
      PLOB_P.IDADD:=.IDADD;
      PLOB_P.IDPUT:=.IDPUT;
      ~~
      ";

_buffer.cntx_get:="
      _tab:=PLOB_P;
      {? type_of(_a)=7 || _ref:=#_a; _mask:=ref_name(_a)
      |? type_of(_a)=1 || _ref:=_a;  _mask:={? var_pres('_b')=2 || _b || _tab.name() ?}
      || .blank(~~); return(.)
      ?};
      _tab.cntx_psh();
      {? {? _tab.name()<>_mask
         || _tab.use(_mask)
         || 1
         ?}
      || _tab.prefix();
         {? _tab.seek(_ref,)
         || .get()
         || .blank(~~)
         ?}
      || .blank(~~)
      ?};
      _tab.cntx_pop();
      (.)
      ";

_buffer.ref:=".Ref";

_buffer.name:="'PLOB_P'";

_buffer.this:="exec('buffer','plob_p')";

_buffer.acronyms:="
      _tab:=obj_new(15);
      _tab[1]:='Ref';
      _tab[2]:='P';
      _tab[3]:='PLOB_H';
      _tab[4]:='PLOB_L';
      _tab[5]:='KK';
      _tab[6]:='GPW';
      _tab[7]:='DATA_OD';
      _tab[8]:='DATA_DO';
      _tab[9]:='DATA_DP';
      _tab[10]:='GODZ_OD';
      _tab[11]:='GODZ_DO';
      _tab[12]:='GR';
      _tab[13]:='STATUS';
      _tab[14]:='IDADD';
      _tab[15]:='IDPUT';
      _tab
      ";

_buffer.types:="
      _tab:=obj_new(15);
      _tab[1]:='_PLOB_P';
      _tab[2]:='_P';
      _tab[3]:='_PLOB_H';
      _tab[4]:='_PLOB_L';
      _tab[5]:='_KK';
      _tab[6]:='STRING';
      _tab[7]:='DATE';
      _tab[8]:='DATE';
      _tab[9]:='DATE';
      _tab[10]:='TIME';
      _tab[11]:='TIME';
      _tab[12]:='TIME';
      _tab[13]:='STRING';
      _tab[14]:='IDADD';
      _tab[15]:='IDPUT';
      _tab
      ";
_buffer.bl_void();

_buffer

:Sign Version 2.0 jowisz:1028 2019/06/07 15:59:57 06a4c5a97455b71d94863eb77df35964877bd93830891325e3bdb4af5d3978d9f7dc4ba3d73d03e0706a128e5bb7296cfc87b5555f43e8cf83b2d2c2c5c017b15a28e50f9dd39f1fbd281c11a19bd615cfeac3a768462177a9ebce50bf514eb1ef306d70f9a15c3a3f4ad503b420388b5a3242898eddf745d55e70a7e51e82cb
