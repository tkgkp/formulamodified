:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku:  px_al.fml
:: Utworzony: 12.06.2018
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Formuły do obsługi tabeli PX_CAL - Kalendarze wewnątrz pojemnika
::======================================================================================================================

\add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Dodaje rekord PX_CAL
::   WE: _a - obj_new() - interwał definiujący zapis kalendarza, wynik exec('interval','#interval')
::       _b - INTEGER - poziom
::       [_c] - PX_CUP.ref lub bieżący rekord
::       [_d] - PL_RES.ref - zasób planistyczny który powiązać z rekordem kalendarza
::   WY: ref utworzonej pozycji kalendarza, lub scalonej lub null jeśli porażka
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_interval:=_a;
_level:=_b;

_ref:=null();
{? var_pres('_c')=type_of(PX_CUP.ref())
|| _ref:=_c
?};
_plres:=null();
{? var_pres('_d')=type_of(PL_RES.ref())
|| _plres:=_d
?};

_result:=null();
_can_continue:=1;

PX_CUP.cntx_psh();
PX_CAL.cntx_psh();
PX_CAL.index('PX_CUP');
{? _ref<>null()
|| PX_CUP.prefix();
   {? PX_CUP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
{? exec('interval_dur','#interval',_interval)=0
|| _can_continue:=0
?};

_cup_duration:=PX_CUP.TM_END-PX_CUP.TM_START;

{? _cup_duration<=0
|| _can_continue:=0
?};

_interval_cup:=exec('interval','#interval');
_interval_cup.START:=PX_CUP.TM_START;
_interval_cup.END:=PX_CUP.TM_END;
{? _can_continue>0
||

   {? exec('intervals_chk','#interval',_interval,_interval_cup)=0
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: Nigdy nie mogę przekroczyć granic pojemnika
   _interval.START:=exec('max','#math',_interval.START,_interval_cup.START);
   _interval.END:=exec('min','#math',_interval.END,_interval_cup.END);
   ~~
?};

{? _can_continue>0
||
:: Zanim dodam nowy odpalam ewentualne scalenie z innymi
   _merged:=exec('merge','px_cal',_interval,_level);
   {? _merged<>null()
   || _can_continue:=0;
      _result:=_merged
   ?}
?};

{? _can_continue>0
||
   PX_CAL.prefix();
   PX_CAL.blank();
   PX_CAL.PX_CUP:=PX_CUP.ref();
   PX_CAL.PX_KONT:=PX_CUP.PX_KONT;
   PX_CAL.TM_START:=_interval.START;
   PX_CAL.TM_END:=_interval.END;
   PX_CAL.LEVEL:=_level;
   PX_CAL.STARTD:=exec('tm_stamp2date','#tm_stamp',PX_CAL.TM_START);
   PX_CAL.STARTT:=exec('tm_stamp2time','#tm_stamp',PX_CAL.TM_START);
   PX_CAL.ENDD:=exec('tm_stamp2date','#tm_stamp',PX_CAL.TM_END);
   PX_CAL.ENDT:=exec('tm_stamp2time','#tm_stamp',PX_CAL.TM_END);
   PX_CAL.PL_RES:=_plres;
   {? PX_CAL.add()
   || _result:=PX_CAL.ref()
   ?}
?};
PX_CUP.cntx_pop();
PX_CAL.cntx_pop();
_result


\merge
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Scala ze sobą interwał i PX_CAL należące do podanego pojemnika
::   WE: _a  - obj_new() - interwał który scalić - wynik działania exec('interval','#interval')
::       _b - INTEGER - poziom
::      [_c] - PX_CUP.ref() - pojemnik w którym dokonać scalenia
::      [_d] - PX_CAL.ref() - dla wywołania rekurencyjnego, rekord PX_CAL który ominąć
::   WY: PX_CAL.ref() - ref scalonego PX_CAL lub null jeśli porażka
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_interval:=_a;
_level:=_b;

_ref:=null();
{? var_pres('_c')=type_of(PX_CUP.ref())
|| _ref:=_c
?};

_omit:=null;
{? var_pres('_d')=type_of(PX_CAL.ref())
|| _omit:=_d
?};

_result:=null();
_can_continue:=1;

PX_CAL.cntx_psh();
PX_CAL.index('PX_CUP');
PX_CUP.cntx_psh();
{? _ref<>null()
|| PX_CUP.prefix();
   {? PX_CUP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
{? _can_continue>0
||
:: Iterujemy po istniejących zapisach kalendarza pojemnika
   PX_CAL.prefix(PX_CUP.ref(),_level);
   {? PX_CAL.first()
   || _interval_cal:=exec('interval','#interval');
      {!
      |?
         _can_merge:=1;
         {? _omit<>null()
         || {? $_omit=$PX_CAL.ref()
            || _can_merge:=0
            ?}
         ?};

         {? _can_merge>0
         ||
            _interval_cal.START:=PX_CAL.TM_START;
            _interval_cal.END:=PX_CAL.TM_END;
            {? exec('equals','#interval',_interval,_interval_cal)>0
            || _result:=PX_CAL.ref()
            ||
               _chk:=exec('intervals_chk','#interval',_interval,_interval_cal);
               {? _chk>0
               ||
                  {? _chk=1
                  || PX_CAL.TM_END:=_interval.END;
                     PX_CAL.ENDD:=exec('tm_stamp2date','#tm_stamp',PX_CAL.TM_END);
                     PX_CAL.ENDT:=exec('tm_stamp2time','#tm_stamp',PX_CAL.TM_END)
                  |? _chk=2
                  || PX_CAL.TM_START:=_interval.START;
                     PX_CAL.TM_END:=_interval.END;
                     PX_CAL.STARTD:=exec('tm_stamp2date','#tm_stamp',PX_CAL.TM_START);
                     PX_CAL.STARTT:=exec('tm_stamp2time','#tm_stamp',PX_CAL.TM_START);
                     PX_CAL.ENDD:=exec('tm_stamp2date','#tm_stamp',PX_CAL.TM_END);
                     PX_CAL.ENDT:=exec('tm_stamp2time','#tm_stamp',PX_CAL.TM_END)
                  |? _chk=3
                  || PX_CAL.TM_START:=_interval.START;
                     PX_CAL.STARTD:=exec('tm_stamp2date','#tm_stamp',PX_CAL.TM_START);
                     PX_CAL.STARTT:=exec('tm_stamp2time','#tm_stamp',PX_CAL.TM_START)
                  ?};
                  _can_continue:=PX_CAL.put();

                  {? _can_continue>0
                  || _result:=PX_CAL.ref();
::                   Jeżeli udało się scalić to uruchamiam rekurencję żeby się ewentualnie ten scalony
::                   połączył z innymi istniejącymi w tym pojemniku
                     _interval_cal.START:=PX_CAL.TM_START;
                     _interval_cal.END:=PX_CAL.TM_END;
                     _result_rec:=exec('merge','px_cal',_interval_cal,_level,,_result);
                     {? _result_rec<>null()
                     || _result:=_result_rec
                     ?}
                  ?}
               ?}
            ?}
         ?};
         PX_CAL.next() & _result=null()
      !}
   ?}
?};
PX_CUP.cntx_pop();
PX_CAL.cntx_pop();
_result


\split
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Rozdziela pozycje kalendarza w taki sposób że podany interwał traktowany jest jako
::       nowa pozycja planu, która powinna zmniejszyć dostępny kalendarz
::   WE: _a  - obj_new() - interwał rozdzielający kalendarz - wynik działania exec('interval','#interval')
::       _b - INTEGER - poziom
::      [_c] - PX_CUP.ref() - pojemnik w którym dokonać scalenia
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_interval:=_a;
_level:=_b;

_ref:=null();
{? var_pres('_c')=type_of(PX_CUP.ref())
|| _ref:=_c
?};

_result:=null();
_can_continue:=1;

PX_CAL.cntx_psh();
PX_CAL.index('PX_CUP');
PX_CUP.cntx_psh();
{? _ref<>null()
|| PX_CUP.prefix();
   {? PX_CUP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: Iterujemy po istniejących zapisach kalendarza pojemnika
   PX_CAL.prefix(PX_CUP.ref(),_level);
   {? PX_CAL.first()
   || _inteval_cal:=exec('interval','#interval');

      {!
      |? _next:=0;
         _ref_nxt:=null();
         PX_CAL.cntx_psh();
         {? PX_CAL.next()
         || _ref_nxt:=PX_CAL.ref()
         ?};
         PX_CAL.cntx_pop();

         _can_split:=1;


         {? _can_split>0
         ||
            _inteval_cal.START:=PX_CAL.TM_START;
            _inteval_cal.END:=PX_CAL.TM_END;
            _plres:=PX_CAL.PL_RES;

            _chk:=exec('intervals_chk','#interval',_interval,_inteval_cal);
            {? _chk>0
            ||
               {? _chk=1
               || PX_CAL.TM_END:=_interval.START;
                  PX_CAL.ENDD:=exec('tm_stamp2date','#tm_stamp',PX_CAL.TM_END);
                  PX_CAL.ENDT:=exec('tm_stamp2time','#tm_stamp',PX_CAL.TM_END);
                  _can_continue:=PX_CAL.put()
               |? _chk=2
               ||
::                Usuwam
                  _can_continue:=exec('delete','px_cal',PX_CAL.ref())
               |? _chk=3
               || PX_CAL.TM_START:=_interval.END;
                  PX_CAL.STARTD:=exec('tm_stamp2date','#tm_stamp',PX_CAL.TM_START);
                  PX_CAL.STARTT:=exec('tm_stamp2time','#tm_stamp',PX_CAL.TM_START);
                  _can_continue:=PX_CAL.put()
               |? _chk=4
               ||
                  _old_start:=PX_CAL.TM_START;
                  _old_end:=PX_CAL.TM_END;
                  PX_CAL.TM_END:=_interval.START;
                  PX_CAL.ENDD:=exec('tm_stamp2date','#tm_stamp',PX_CAL.TM_END);
                  PX_CAL.ENDT:=exec('tm_stamp2time','#tm_stamp',PX_CAL.TM_END);
                  {? PX_CAL.TM_START=PX_CAL.TM_END
                  ||
::                   Powstał by interwał o zerowym czasie trwania więc go tnę
                     _can_continue:=exec('delete','px_cal',PX_CAL.ref())
                  || _can_continue:=PX_CAL.put()
                  ?};

::                Zakładam nowy
                  _inteval_cal.START:=_interval.END;
                  _inteval_cal.END:=_old_end;
                  _result:=exec('add','px_cal',_inteval_cal,_level,,_plres)
               ?}
            ?}
         ?};
         {? _ref_nxt<>null()
         || _next:=PX_CAL.seek(_ref_nxt)
         ?};
         _next>0 & _can_continue>0
      !}
   ?}
?};
PX_CUP.cntx_pop();
PX_CAL.cntx_pop();
_result


\add4cup
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Generuje zapisy kalendarza dla podanego PX_CUP
::   WE: [_a] - PX_CUP.ref lub bieżący rekord
::       [_b] - obj_new - interwał kalendarza jaki wygenerować, jeśli nie podane
::                        to tworzony na podstawie pojemnika
::       [_c] - INTEGER - poziom kalendarza
::       [_d] - INTEGER - 0/1 czy aktualizować czasy w pojemniku (na wypadek zmiany kalendarza)
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_CUP.ref())
|| _ref:=_a
?};
_result:=0;
_can_continue:=1;

{? var_pres('KAL')<100
|| exec('declare','kalendarz');
   KAL:=obj_new(@.CLASS.KALEND)
?};

PX_CUP.cntx_psh();
PX_POZ.cntx_psh();
PX_KONT.cntx_psh();
TWRKZBR.cntx_psh();
TWRKZPO.cntx_psh();
TWRKPLC.cntx_psh();
TWRKZPO.index('GRUPA');
{? _ref<>null()
|| PX_CUP.prefix();
   {? PX_CUP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
_can_add:=1;
{? _can_continue>0
||
   {? PX_CUP.PX_KONT<>null()
   || PX_CUP.PX_KONT();
      {? exec('is_koop','px_kont')
      || {? PX_VAR.COOP_QUE=-1
         ||
            PX_GRP.cntx_psh();
            PX_GRP.index('COOP');
            PX_GRP.prefix(PX_CUP.PX_VER,'N','N','T');
            PX_VAR.COOP_QUE:=PX_GRP.size();
            PX_GRP.cntx_pop()
         ?};
         {? PX_VAR.COOP_QUE>0
         || PX_CUP.CAL_LVL:=PX_VAR.COOP_QUE
         || PX_CUP.CAL_LVL:=1
         ?};
         _can_continue:=PX_CUP.put()
      ?}
   ?}
?};
{? _can_continue>0 & _can_add>0
||
   _interval_cup:=~~;
   {? var_pres('_b')>100
   || _interval_cup:=_b
   || _interval_cup:=exec('interval','#interval');
      _interval_cup.START:=PX_CUP.TM_START;
      _interval_cup.END:=PX_CUP.TM_END
   ?};
   _level:=-1;
   {? var_pres('_c')=type_of(0)
   || _level:=_c
   ?};

   _update_pxcup:=0;
   {? var_pres('_d')=type_of(0)
   || _update_pxcup:=_d
   ?};

   PX_POZ.index('LANE');
:: Specjalna obsługa dla gniazd
   _gniazdo_size:=0;

   {? PX_CUP.PX_KONT().PL_RES().FROM_GNI<>null() & PX_KONT.PARALLEL<>'1'
   || TWRKZPO.prefix(PL_RES.FROM_GNI);
      _gniazdo_size:=TWRKZPO.size()
   ?};
   _parallel:=0;
   {? PX_CUP.PX_KONT().PL_RES().PARALLEL='1'
   || _parallel:=1
   ?};
   {? PX_KONT.PARALLEL='1'
   || _parallel:=1
   ?};

   _lanes:=1;
   {? PX_KONT.PARALLEL<>'1'
   || _lanes:=PX_CUP.CAL_LVL
   ?};
   {? _gniazdo_size>0
   || _lanes:=_gniazdo_size
   ?};
   _loop:=1;
   {? _gniazdo_size>0
   || _loop:=TWRKZPO.first()
   ?};
   _interval_poz:=exec('interval','#interval');
   _plres:=PX_CUP.PX_KONT().PL_RES;

   {? _update_pxcup>0
   ||
::    Aktualizacja czasów pojemnika
      _interval_cup.START:=0;
      _interval_cup.END:=0;

      _intervals:=tab_tmp(1,
         'DURATION','REAL','Czas trwania',
         'TM_START','REAL','Czas startu',
         'TM_END','REAL','Czas końca'
      );

      {! _it:=1.._lanes
      |? _loop>0 & _can_continue>0
      |!
         _cal:=null();
         {? _gniazdo_size>0
         || _cal:=TWRKZPO.ELEMENT().KAL
         || {? PX_CUP.PX_KONT().PL_RES().FROM_STA<>null()
            || _cal:=PX_CUP.PX_KONT().PL_RES().FROM_STA().KAL
            |? PX_CUP.PX_KONT().PL_RES().FROM_BRY<>null()
            || _cal:=PX_CUP.PX_KONT().PL_RES().FROM_BRY().KAL
            |? PX_CUP.PX_KONT().PL_RES().FROM_PRA<>null()
            || _cal:=PX_CUP.PX_KONT().PL_RES().FROM_PRA().KAL
            ?}
         ?};
         {? _cal<>null()
         ||
            _date1:=exec('tm_stamp2date','#tm_stamp',PX_CUP.TM_START);
            KAL.set_cal(_cal,_date1~1);
            {? KAL.get_day(_date1)<>null()
            || {? var_pres('_interval_kal')>100
               || obj_del(_interval_kal)
               ?};
               _interval_kal:=exec('interval','#interval');
               _interval_kal.START:=KAL_DEF.TM_START;
               _interval_kal.END:=KAL_DEF.TM_END;

               _intervals.blank();
               _intervals.TM_START:=KAL_DEF.TM_START;
               _intervals.TM_END:=KAL_DEF.TM_END;
               _intervals.DURATION:=exec('interval_dur','#interval',_interval_kal);
               _intervals.add();
               ~~
            ?}
         ?};
         {? _can_continue>0 & _gniazdo_size>0
         || _loop:=TWRKZPO.next()
         || _loop:=0
         ?}
      !};

      {? _intervals.last()
      || {? _intervals.TM_START<>PX_CUP.TM_START | _intervals.TM_END<>PX_CUP.TM_END
         || _can_continue:=exec('put_time','px_cup',,_intervals.TM_START,_intervals.TM_END,0);
            {? _can_continue>0
            || _update_pxcup:=2
            ?}
         ?}
      ?}
   ?};

   _loop:=1;
   {? _gniazdo_size>0
   || _loop:=TWRKZPO.first()
   ?};
   {! _it:=1.._lanes
   |? _loop>0 & _can_continue>0
   |! _px_poz_size:=0;

      _interval_cup.START:=PX_CUP.TM_START;
      _interval_cup.END:=PX_CUP.TM_END;
      _can_add:=1;
      {? _level>-1
      || _can_add:=0;
         {? _it=_level
         || _can_add:=1
         ?}
      ?};
      {? _can_add>0
      ||
         {? _gniazdo_size>0
         ||
::          Specjalna obsługa dla gniazd. Nie biorę interwału pojemnika
::          tylko interwał z pozycji kalendarza stanowiska wchodzacego w skład
::          gniazda
            _plres:=exec('get_plres','po_plan','S',TWRKZPO.ELEMENT);
            _date1:=exec('tm_stamp2date','#tm_stamp',PX_CUP.TM_START);
            KAL.set_cal(TWRKZPO.ELEMENT().KAL,_date1~1);
            {? KAL.get_day(_date1)<>null()
            || {? var_pres('_interval_kal')>100
               || obj_del(_interval_kal)
               ?};
               _interval_kal:=exec('interval','#interval');
               _interval_kal.START:=KAL_DEF.TM_START;
               _interval_kal.END:=KAL_DEF.TM_END;

               {? var_pres('_interval_and')>100
               || obj_del(_interval_and)
               ?};
               _interval_and:=exec('intervals_and','#interval',_interval_cup,_interval_kal);
               _interval_cup.START:=_interval_and.START;
               _interval_cup.END:=_interval_and.END
            || _interval_cup.START:=0;
               _interval_cup.END:=0
            ?}
         ?};
         _cup_duration:=_interval_cup.END-_interval_cup.START;
         {? _cup_duration>0
         ||
            {? var_pres('_tab')>100
            || obj_del(_tab)
            ?};
            {? _parallel=0
            || _tab:=PX_POZ;
               PX_POZ.prefix(PX_CUP.ref(),_it)
            ||
::             Jeżeli zasób umożliwia równoległe planowanie to znak że będą pozycje
::             równoległe i rekurencja niżej nie przeżyje ograniczeń MacroBASE
::             Dlatego trzeba skompresować równoległe pozycje planu żeby było mniej do iterowania
               _tab:=exec('compress_pxpoz','px_cup',PX_CUP.ref(),_it)
            ?};
            {? _tab.first() & PX_KONT.PARALLEL<>'1'
            ||
::             Są pozycje planu
               {!
               |?
                  _can_add:=1;
                  {? _can_add>0
                  ||
                     {? _tab.STATUS<>exec('status_wyk2','px_poz')
                     ||
                        _interval_poz.START:=_tab.TM_START;
                        _interval_poz.END:=_tab.TM_END;
                        _poz_duration:=_tab.TM_END-PX_POZ.TM_START;

                        {? _poz_duration>0
                        ||
                           {? exec('equals','#interval',_interval_poz,_interval_cup)=0
                           ||
                              {? var_pres('_interval_and')>100
                              || obj_del(_interval_and)
                              ?};
                              _interval_and:=exec('intervals_and','#interval',_interval_poz,_interval_cup);
                              {? exec('interval_dur','#interval',_interval_and)>0
                              || _px_poz_size+=1
                              ?};
::                            Opłaca się generować zapisy kalendarza tylko jeżeli poziom ten sam i pozycja planu ma inny czas startu i końca
::                            niż pojemnik, w przeciwnym wypadku wiadomo że nie będzie w ogóle wolnego czasu w pojemniku
                              {? var_pres('_diff')>100
                              || obj_del(_diff)
                              ?};
                              _diff:=exec('interval_diff','#interval',_interval_cup,_interval_poz);
                              {? type_of(_diff)>100
                              || {? exec('interval_dur','#interval',_diff.LEFT)>0 & exec('equals','#interval',_interval_poz,_diff.LEFT)=0
                                 ||

::                                  Lewy zawsze dodaję jeżeli nie jest zerowy
                                    {? exec('add','px_cal',_diff.LEFT,_it,,_plres)=null()
                                    || _can_continue:=0
                                    ?};
                                    ~~
                                 ?};

                                 {? _can_continue>0 & exec('interval_dur','#interval',_diff.RIGHT)>0 & exec('equals','#interval',_interval_poz,_diff.RIGHT)=0
                                 ||
::                                  Prawy ustawiam na bieżąco analizowany dla kolejnych pozycji planu
                                    {? var_pres('_interval_cup')>100
                                    || obj_del(_interval_cup)
                                    ?};
                                    _interval_cup:=_diff.RIGHT;
                                    ~~
                                 ?}
                              ?}
                           || _px_poz_size+=1
                           ?}
                        ?}
                     ?}
                  ?};
                  _tab.next()
               !}
            ?};
            {? _can_continue>0
            ||
::             Jeżeli przepętliłem się po wszystkich pozycjach planu i został jakiś
::             _interval_cup który trwa więcej niż zero to znaczy że coś zostało i należy
::             z niego zrobić wolny zapis kalendarza
               {? exec('interval_dur','#interval',_interval_cup)>0
               || {? exec('add','px_cal',_interval_cup,_it,,_plres)=null()
                  || _can_continue:=0
                  ?}
               ?}
            ?};
            ~~
         ?}
      ?};
      {? _can_continue>0 & _gniazdo_size>0
      || _loop:=TWRKZPO.next()
      ?}
   !};

:: Aktualizacja pojemności pojemnika
   {? _can_continue>0 & _update_pxcup>0
   || _can_continue:=exec('cup_cap','px_gen')
   ?}
?};
PX_POZ.cntx_pop();
PX_CUP.cntx_pop();
TWRKPLC.cntx_pop();
TWRKZPO.cntx_pop();
TWRKZBR.cntx_pop();
PX_KONT.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Kasuje podany rekord tabeli PX_CAL (wykonywane w transakcji!!!)
::   WE: _a - PX_CAL.ref()
::   WY: >0 -wyczyszczone,
::       <=0 -niewyczyszczone
::  TAG: <PUBLICZNA><DEL>
::UWAGA: Parametry bez [] są wymagane, formula może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=0;
_can_continue:=1;

:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;
{? _mydo || do() ?};
PX_CAL.cntx_psh(); PX_CAL.clear();
{? PX_CAL.seek(_ref)
|| {? exec('clean','px_cal',_ref)>0
   || {? PX_CAL.del(,1)>0
      || _result:=1
      || undo();
         _result:=-3
      ?}
   || _result:=-2
   ?}
|| _result:=0
?};

{? _result<0
|| undo()
?};

PX_CAL.cntx_pop();
{? _mydo || end() ?};
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Czyści powiązania do rekordu tabeli PX_CAL
::   WE: _a - PX_CAL.ref()
::   WY: >0  -wyczyszczone,
::       <=0 -niewyczyszczone
::  TAG: <PRYWATNA><CLEAN>
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=0;
_can_continue:=1;

_mydo:=do_state()=0;
{? _mydo || do() ?};
:: --- powiązania do ---

:: --- wszystkie powiazania usuniete? ---

{? _can_continue>0
|| _result:=1
|| undo()
?};

{? _mydo || end() ?};

_result


\delete4cup
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Usuwa wszystkie kalendarze dla pojemnika
::   WE: [_a] - PX_CUP.ref - pojemnik lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_CUP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_CUP.cntx_psh();
{? _ref<>null()
|| PX_CUP.prefix();
   {? PX_CUP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_CAL.cntx_psh();
   PX_CAL.index('PX_CUP');
   PX_CAL.prefix(PX_CUP.ref());
   {? PX_CAL.first()
   || {!
      |? _can_continue:=exec('delete','px_cal',PX_CAL.ref());
         PX_CAL.first() & _can_continue>0
      !}
   ?};
   PX_CAL.cntx_pop();
   ~~
?};
PX_CUP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\delete4kont
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Usuwa wszystkie kalendarze dla zasobu
::   WE: [_a] - PX_KONT.ref - zasób lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_KONT.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_KONT.cntx_psh();
{? _ref<>null()
|| PX_KONT.prefix();
   {? PX_KONT.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_CAL.cntx_psh();
   PX_CAL.index('TM_START');
   PX_CAL.prefix(PX_KONT.ref());
   {? PX_CAL.first()
   || {!
      |? _can_continue:=exec('delete','px_cal',PX_CAL.ref());
         PX_CAL.first() & _can_continue>0
      !}
   ?};
   PX_CAL.cntx_pop();
   ~~
?};
PX_KONT.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\delete4plres
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Usuwa wszystkie kalendarze dla zasobu
::   WE: [_a] - PL_RES.ref - zasób lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PL_RES.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PL_RES.cntx_psh();
{? _ref<>null()
|| PL_RES.prefix();
   {? PL_RES.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_CAL.cntx_psh();
   PX_CAL.index('PO_START');
   PX_CAL.prefix(PL_RES.ref());
   {? PX_CAL.first()
   || {!
      |? _can_continue:=exec('delete','px_cal',PX_CAL.ref());
         PX_CAL.first() & _can_continue>0
      !}
   ?};
   PX_CAL.cntx_pop();
   ~~
?};
PL_RES.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\select4cup
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Selekcja kalendarzy dla pojemnika
::   WE: [_a] - PX_CUP.ref lub bieżący rekord
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_CUP.ref())
|| _ref:=_a
?};

_can_continue:=1;

PX_CUP.cntx_psh();
{? _ref<>null()
|| PX_CUP.prefix();
   {? PX_CUP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? PX_CUP.get()=0
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_KONT.cntx_psh();
   PX_CAL.cntx_psh();

   PX_VAR.IL_WYM:=PX_KONT.IL_WYM;
   PX_CAL.index('PX_CUP');
   PX_CAL.prefix(PX_CUP.ref());
   PX_CAL.first();

   _wer:=PX_CAL.mk_sel('Wolne zapisy kalendarza pojemnika: %1'@[PX_CUP.SYMBOL],'P',,'#pxcalsel',,10,25,,'U',,,,1);
   PX_CAL.win_fld(_wer,,'STARTD','DATA',,,,,'Od'@);
   PX_CAL.win_fld(_wer,,'STARTT',,,8,,,,1);
   PX_CAL.win_fld(_wer,,'ENDD','DATA',,,,,'Do'@);
   PX_CAL.win_fld(_wer,,'ENDT',,,8,,,,1);
   PX_CAL.win_fld(_wer,,'LEVEL',,,,,,'Poziom'@);

   {? exec('mainversion_vie','px_ver') & PX_VAR.EDIT=1
   ||
      PX_CAL.win_act(_wer,,'Formuła','O&dtwórz'@@,,'Odtworzenie kalendarza'@,"exec('rebuild4cup','px_cal')",,0,,,,'D');
      task_attach('TPP_PPS_DPLA');
      PX_CAL.win_act(_wer,1,'Formuła','O&dtwórz'@@,,'Odtworzenie kalendarza'@,"exec('rebuild4cup','px_cal')",,0,,,,'D');
      task_attach('TPP_PPS_DPLA');
      ~~
   ?};
   PX_CAL.win_act(_wer,,'Kolejność',,,,);
:: PX_CUP.win_act(_wer,,'Rekord',,,,$("{? '"+_kind+"'='W' || PX_CUP.UID_PAR='' || ~~ ?}"));
:: PX_CUP.win_fml(_wer,,'SYMBOL',,'ICON_BEFORE',"exec('ico_fill','px_cup',0,,1,0)");
   PX_CAL.win_sel(_wer);

   PX_CAL.select(,1,5);
   PX_KONT.cntx_pop();
   PX_CAL.cntx_pop()
|| FUN.emsg('Nie znaleziono pojemnika. Wyświetlenie kalendarza niemożliwe.'@)
?};
PX_CUP.cntx_pop();
''

\rebuild4cup
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Odtworzenie kalendarzy w pojemniku
::   WE: [_a] - PX_CUP.ref lub bieżący rekord
::       [_b] - INTEGER - czy wyświetlać dialogi
::       [_c] - INTEGER - 0/1 czy aktualizować czasy w pojemniku (na wypadek zmiany kalendarza)
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_CUP.ref())
|| _ref:=_a
?};
_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};
_update_pxcup:=0;
{? var_pres('_c')=type_of(0)
|| _update_pxcup:=_c
?};
_result:=0;
_can_continue:=1;

PX_CUP.cntx_psh();
{? _ref<>null()
|| PX_CUP.prefix();
   {? PX_CUP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? _dialog>0
   || _can_continue:=FUN.ask('Czy odtworzyć zapisy kalendarza w pojemniku %1'@[PX_CUP.SYMBOL])
   ?}
?};

{? _can_continue>0
||
:: Najpierw usuwamy wszystko
   _can_continue:=exec('delete4cup','px_cal')
?};
{? _can_continue>0
||
:: Generujemy nowe
   _can_continue:=exec('add4cup','px_cal',,,,_update_pxcup)
?};

PX_CUP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\rebuild4all_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Przycisk w oknie - akcja odtwarzania kalendarzy
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
exec('rebuild4all','px_cal');
''


\rebuild4all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Odtworzenie kalendarzy we wszystkich pojemnikach, lub usunięcie jeśli
::       parametr 500370 ma odpowiednią wartość
::   WE: [_a] - INTEGER - 0/[1] - czy wyświetlać dialogi
::       [_b] - INTEGER - 0/[1]/2 - czy wyświetlać progress
::       [_c] - REAL - czas od którego zaczynać odtwarzanie
::       [_d] - obj_new - obiekt do obsługi multiprogressa
::       [_e] - PX_VER.ref() - wersja planu
::       [_f] - INTEGER - 0/[1] czy aktualizować czasy w pojemniku (na wypadek zmiany kalendarza)
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};
_progress:=1;
{? var_pres('_b')=type_of(0)
|| _progress:=_b
?};
_tm_start:=0;
{? var_pres('_c')=type_of(0)
|| _tm_start:=_c
?};
_argsprog:=~~;
{? var_pres('_d')>100
|| _argsprog:=_d
?};
_ver:=exec('get_mainversion','px_ver');
{? var_pres('_e')=type_of(PX_VER.ref())
|| _ver:=_e
?};

_update_pxcup:=1;
{? var_pres('_f')=type_of(0)
|| _update_pxcup:=_f
?};

_result:=1;
_can_continue:=1;

PX_CUP.cntx_psh();

{? _dialog>0
|| _can_continue:=FUN.ask('Czy odtworzyć zapisy kalendarza we wszystkich pojemnikach?'@)
?};

_prg_step:=20;
_calendars_needed:=exec('is_oper_nast_time','px_param');
{? _can_continue>0
||
   {? _tm_start>0
   ||
      PX_CUP.index('VER2');
      PX_CUP.prefix(_ver);
      _can_continue:=PX_CUP.find_ge(_tm_start)
   ||
      PX_CUP.index('VER');
      PX_CUP.prefix(_ver);
      _can_continue:=PX_CUP.first()
   ?}
?};
{? _can_continue>0
||
   _lp:=1;
   {? _progress=1
   || {? _calendars_needed>0
      || _msg:='Odtwarzanie kalendarzy w pojemnikach...'@
      || _msg:='Usuwanie kalendarzy z pojemników...'@
      ?};
      FUN.prg_start(PX_CUP.size()/_prg_step,_msg,,,1)
   ?};
   {!
   |?
      {? _progress=1
      || {? _lp%*_prg_step=0
         || FUN.prg_next()
         ?}
      ?};
      {? _progress=2
      ||
         {? _lp%*_prg_step=0
         || _argsprog.PROGLOC+=1;
            _can_continue:=exec('plan_progress','px_logix',_argsprog,_prg_step)
         ?}
      ?};

::    Najpierw usuwamy wszystko
      _can_continue:=exec('delete4cup','px_cal');
      {? _can_continue>0 & _calendars_needed>0
      ||
::       Generujemy nowe
         _can_continue:=exec('add4cup','px_cal',,,,_update_pxcup)
      ?};
      {? _can_continue<=0
      || _result:=0
      ?};
      _lp+=1;
      PX_CUP.next()
   !};
   {? _progress=1
   || FUN.prg_stop()
   ?}
?};
PX_CUP.cntx_pop();
_result


\clone
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Klonuje zapisy kalendarza dla podanych pojemników
::   WE: _a - PX_CUP.ref() - pojemnik źródłowy
::       _b - PX_CUP.ref - pojemnik docelowy
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_src:=_a;
_dst:=_b;

_can_continue:=1;
_result:=0;

PX_CAL.cntx_psh();
PX_CUP.cntx_psh();
{? _can_continue>0
||
:: Najpierw usuwamy wszystko w docelowym
   _can_continue:=exec('delete4cup','px_cal',_dst)
?};

{? _can_continue>0
||
   PX_CAL.index('PX_CUP');
   PX_CAL.prefix(_src);
   {? PX_CAL.first()
   || {!
      |?
         PX_CAL.cntx_psh();
         PX_CAL.prefix();
         PX_CAL.PX_CUP:=_dst;
         PX_CAL.PX_KONT:=PX_CAL.PX_CUP().PX_KONT;
         _can_continue:=PX_CAL.add();
         PX_CAL.cntx_pop();
         PX_CAL.next() & _can_continue>0
      !}
   ?}
?};
PX_CUP.cntx_pop();
PX_CAL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


:Sign Version 2.0 jowisz:1045 2022/06/30 14:23:22 aa029939d1111a4e40a1d595e152e4c676ac1efc7b439f965a2ea09e2970e0dc8e484e3f497ec6244bdb3256c07c5e3103030357a469247a94206b11a9253b52134dc97166988615de6283d666ffb08e7e0d0c107cbc208d8dacdcee4810198d0330098894058f7c04df679e88f97616a0fb7748c6dfb2ef3f0b7bf56f2ae5b1
