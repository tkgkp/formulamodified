:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku:  po_plan.fml [17.00]
:: Utworzony: 14-10-2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Zbiór różnych funkcji dla planu operacyjnego
::======================================================================================================================


\tab_utilization
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Wykorzystanie zasobow - dla wybranej tabeli
::   WE: _a - 0 - wyswietlanie
::            1 - sprawdza, czy jest wykorzystanie
::       _b - 'ZL', 'ZK_P', 'ZGH', 'ZGP' (tab)
::       _c - tab.ref()
::   WY: dla _a=0: ~~
::       dla _a=1: 1 - wykorzystany, 0 - brak zapisow
::  OLD: \tab_utilization/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=~~;
ZL.cntx_psh();
PL_OPER.cntx_psh();
PL_PART.cntx_psh();

{? _a
|| _result:=0;
   {? _b='ZGP'
   || PL_OPER.index('ZGP');
      PL_OPER.prefix(_c);
      _result:=PL_OPER.first()
   |? _b='ZL'
   ||
      ZL.clear();
      {? ZL.seek(_c)
      || {? ZL.RODZAJ<>'P'
         ||
            PL_PART.index('NRNZL');
            PL_PART.prefix(ZL.UNRZL);
            _result:=PL_PART.first()
         || PL_PART.index(_b);
            PL_PART.prefix(_c);
            _result:=PL_PART.first()
         ?}
      ?}
   |? _b='ZGH'
   || ZGH.cntx_psh(); ZGH.clear();
      ZGP.cntx_psh();
      ZL.cntx_psh();
      _can_continue:=1;
      {? ZGH.seek(_c)
      || ZGH.ZLEC();

         {? ZL.RODZAJ<>'P' & ZL.GENPRZEW='N'
         || ZGP.index('NRPP')
         || ZGP.index('PNRPP')
         ?};
         ZGP.prefix(ZGH.ref());
         {? ZGP.first()
         || {!
            |? {? exec('zgp_utilization','po_plan',1,ZGP.ref())>0
               || _result:=1;
                  _can_continue:=0
               ?};
               ZGP.next() & _can_continue>0
            !}
         ?}
      ?};
      ZGH.cntx_pop();
      ZGP.cntx_pop();
      ZL.cntx_pop();
      ~~
   || PL_PART.index(_b);
      PL_PART.prefix(_c);
      _result:=PL_PART.first()
   ?}
||
   _where:=_b+'.REFERENCE=\''+$_c+'\'';
   {? _b='ZL'
   || ZL.clear();
      {? ZL.seek(_c)
      || {? ZL.RODZAJ='Z'
         || ZL.index('NRNZL');
            ZL.prefix(ZL.UNRZL);
            {? ZL.size()>0
            || _where:='ZL.REFERENCE in (select REFERENCE from prefixed_table(ZL))'
            ?}
         ?}
      ?}
   ?};

   _tab:=sql('
      select
         PL_OPER.STARTD as STARTD,
         PL_OPER.STARTT as STARTT,
         PL_OPER.ENDD as ENDD,
         PL_OPER.ENDT as ENDT,
         PL_PART.ILOSC as ILOSC,
         PL_PART.ZL as ZL_REF,
         ZL.SYM as ZL_SYM,
         ZL_M.KTM as ZL_KTM,
         PL_PART.ZK_P as ZAM_REF,
         ZK_N.SYM as ZAM_SYM,
         ZK_P.POZ as ZAM_POZ,
         ZAM_M.KTM as ZAM_KTM,
         PL_PART.ZGH as ZGH_REF,
         PL_OPER.ZGP as ZGP_REF,
         PL_RES.TYP as RES_TYP,
         nvl(PL_RES.SYM,\'{KOOPERACJA}\') as RES_SYM,
         nvl(PL_RES.NAZ,\'Kooperacja\') as RES_NAZ
      from PL_OPER
       left join PL_OZ using(PL_OZ.PL_OPER,PL_OPER.REFERENCE)
       left join PL_RES using(PL_OZ.PL_RES,PL_RES.REFERENCE)
:       join PL_OPER using(PL_OZ.PL_OPER,PL_OPER.REFERENCE)
        join PL_PART using(PL_OPER.PL_PART,PL_PART.REFERENCE)
         left join ZL using(PL_PART.ZL,ZL.REFERENCE)
          left join M as ZL_M using(ZL.KTM,ZL_M.REFERENCE)
         left join @ZK_P using(PL_PART.ZK_P,ZK_P.REFERENCE)
          left join @ZK_N using(ZK_P.N,ZK_N.REFERENCE)
          left join M as ZAM_M using(ZK_P.M,ZAM_M.REFERENCE)
         left join ZGH using(PL_PART.ZGH,ZGH.REFERENCE)
         left join ZGP using(PL_OPER.ZGP,ZGP.REFERENCE)
      where :_a
      order by 1,2
   ',_where);
   _tab.fld_attr('STARTT',,2);
   _tab.fld_attr('ENDT',,2);
   _wer:=_tab.mk_sel('Wykorzystanie zasobów — zaplanowane operacje'@,'P',0,'plozwertab',1,10,,,'U');
   _tab.win_fld(_wer,,'RES_TYP',,,3,,,'Typ'@);
   _tab.win_fld(_wer,,'RES_SYM',,,20,,,'Symbol zasobu'@);
   _tab.win_fld(_wer,,'RES_NAZ',,,30,,,'Nazwa zasobu'@);
::   _tab.win_fld(_wer,,'ZL_SYM',,,15,,,'Zlecenie');
::   _tab.win_fld(_wer,,'ZL_KTM',,,15,,,'Zlecony KTM');
::   _tab.win_fld(_wer,,'ZAM_SYM',,,15,,,'Zamówienie');
::   _tab.win_fld(_wer,,'ZAM_POZ',,,3,,,'Poz');
::   _tab.win_fld(_wer,,'ZAM_KTM',,,15,,,'Zamówiony KTM');
   _tab.win_fld(_wer,,'STARTD',,,,,,'Data początkowa'@);
   _tab.win_fld(_wer,,'STARTT',,,,,,'Godzina'@);
   _tab.win_fld(_wer,,'ENDD',,,,,,'Data końcowa'@);
   _tab.win_fld(_wer,,'ENDT',,,,,,'Godzina'@);
   _tab.win_act(_wer,,'Kolejność');
   _tab.win_sel(_wer);
   _tab.select();
   ~~
?};
PL_OPER.cntx_pop();
PL_PART.cntx_pop();
ZL.cntx_pop();
_result


\zl_utilization
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Wykorzystanie zasobów - dla zleceń
::   WE: _a - 0 - wyświetlanie
::            1 - sprawdza, czy jest wykorzystanie
::       _b - ZL.ref()
::   WY: dla _a=0: ~~
::       dla _a=1: 1 - wykorzystany, 0 - brak zapisów
::  OLD: \zl_utilization/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
exec('tab_utilization','po_plan',_a,'ZL',_b)


\zkp_utilization
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Wykorzystanie zasobów - dla pozycji zamówienia
::   WE: _a - 0 - wyświetlanie
::            1 - sprawdza, czy jest wykorzystanie
::       _b - ZK_P.ref()
::   WY: dla _a=0: ~~
::       dla _a=1: 1 - wykorzystany, 0 - brak zapisów
::  OLD: \zkp_utilization/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
exec('tab_utilization','po_plan',_a,'ZK_P',_b)


\zgh_utilization
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Wykorzystanie zasobów - dla przewodnika
::   WE: _a - 0 - wyświetlanie
::            1 - sprawdza, czy jest wykorzystanie
::       _b - ZGH.ref()
::   WY: dla _a=0: ~~
::       dla _a=1: 1 - wykorzystany, 0 - brak zapisów
::  OLD: \zgh_utilization/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
exec('tab_utilization','po_plan',_a,'ZGH',_b)


\zgp_utilization
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Wykorzystanie zasobów - dla pozycji przewodnika
::   WE: _a - 0 - wyświetlanie
::            1 - sprawdza, czy jest wykorzystanie
::       _b - ZGP.ref()
::   WY: dla _a=0: ~~
::       dla _a=1: 1 - wykorzystany, 0 - brak zapisów
::  OLD: \zgp_utilization/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
exec('tab_utilization','po_plan',_a,'ZGP',_b)


\res_utilization
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Wykorzystanie zasobow - ogolnie
::   WE: _a - 0 - wyswietlanie
::            1 - sprawdza, czy jest wykorzystanie
::   WY: dla _a=0: ~~
::       dla _a=1: 1 - wykorzystany, 0 - brak zapisow
::  OLD: \res_utilization/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
PL_OZ.index('PL_RES');
PL_OZ.prefix(PL_RES.ref());
{? _a
||
   PL_OZ.first()
||
   _tab:=sql('
      select
         PL_OPER.STARTD as STARTD,
         PL_OPER.STARTT as STARTT,
         PL_OPER.ENDD as ENDD,
         PL_OPER.ENDT as ENDT,
         PL_PART.ILOSC as ILOSC,
         ZL.SYM as ZL_SYM,
         ZL_M.KTM as ZL_KTM,
         ZK_N.SYM as ZAM_SYM,
         ZK_P.POZ as ZAM_POZ,
         ZAM_M.KTM as ZAM_KTM
      from PL_OZ
       join PL_OPER
        join PL_PART
         left join ZL using(PL_PART.ZL,ZL.REFERENCE)
          left join M as ZL_M using(ZL.KTM,ZL_M.REFERENCE)
         left join @ZK_P using(PL_PART.ZK_P,ZK_P.REFERENCE)
          left join @ZK_N using(ZK_P.N,ZK_N.REFERENCE)
          left join M as ZAM_M using(ZK_P.M,ZAM_M.REFERENCE)
      where PL_OZ.PL_RES=:_a
      order by 1,2
   ',PL_RES.ref());
   _tab.fld_attr('ZAM_POZ',,2);
   _tab.fld_attr('STARTT',,2);
   _tab.fld_attr('ENDT',,2);
   _wer:=_tab.mk_sel('Wykorzystanie zasobu — zaplanowane operacje'@,'P',0,'plozwerres',1,10,,,'U');
   _tab.win_fld(_wer,,'ZL_SYM',,,15,,,'Zlecenie'@);
   _tab.win_fld(_wer,,'ZL_KTM',,,15,,,'Zlecony produkt'@);
   _tab.win_fld(_wer,,'ZAM_SYM',,,15,,,'Zamówienie'@);
   _tab.win_fld(_wer,,'ZAM_POZ',,,3,,,'Poz'@);
   _tab.win_fld(_wer,,'ZAM_KTM',,,15,,,'Zamówiony produkt'@);
   _tab.win_fld(_wer,,'STARTD',,,,,,'Data początkowa'@);
   _tab.win_fld(_wer,,'STARTT',,,,,,'Godzina'@);
   _tab.win_fld(_wer,,'ENDD',,,,,,'Data końcowa'@);
   _tab.win_fld(_wer,,'ENDT',,,,,,'Godzina'@);
   _tab.win_act(_wer,,'Kolejność');
   _tab.win_sel(_wer);
   _tab.select();
   ~~
?}


\zlec_planned
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Sprawdza czy zlecenie zostalo juz zaplanowane
::   WE: [_a] - $ZL.ref() - ref SQL zlecenia lub bieżący rekord
::       [_b] - INTEGER - 0/[1] - czy dla zlecen podrzednych ilosc zwracana traktowac proporcja
::   WY: REAL - ile zostało zaplanowane
::  OLD: \zlec_planned/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zlec:='';
{? _>0
|| _zlec:=_a
?};

_prop:=1;
{? var_pres('_b')=type_of(0)
|| _prop:=_b
?};

_result:=0;
_can_continue:=1;

M.cntx_psh();
ZL.cntx_psh();
{? _zlec<>''
|| ZL.clear();
   {? ZL.seek(_zlec)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

PL_PART.cntx_psh();
PL_PART.index('ZL');

{? _can_continue>0
||
   _dokl:=ZL.KTM().DOKL;
   PL_PART.prefix(ZL.ref());
   {? PL_PART.first>0
   || {!
      |? _result+=PL_PART.ILOSC;
         PL_PART.next()
      !}
   ?};
:: jesli zlecenie zlozone to sprawdzam czy jego podrzedne sa zaplanowane (!!rekurencja!!)
   {? ZL.RODZAJ<>'P'
   || ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.clear();
      ZL.prefix(ZL.UNRZL);
      _zlo_il:=ZL.IL;
      _size:=ZL.size();
      {? ZL.first()
      || {!
         |? _pod_il:=exec('zlec_planned','po_plan',$ZL.ref());
            {? ZL.IL>0
            || _pod_prp:=_pod_il/ZL.IL
            || _pod_prp:=0
            ?};
            {? _pod_prp>1
            || _pod_prp:=1
            |? _pod_prp<0
            || _pod_prp:=0
            ?};
            {? _prop
            || _result+=_zlo_il/_size*_pod_prp
            || _result+=_pod_il
            ?};
            ZL.next()
         !};
         _result:=_result$_dokl
      ?};
      ZL.cntx_pop()
   ?}
?};
M.cntx_pop();
PL_PART.cntx_pop();
ZL.cntx_pop();
_result


\bounds_update
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Aktualizuje granice czasowe dla PL_OPERów i PL_OGRów na podstawie kooperacji
::   WE: _a - ZGP.ref() - pozycja przewodnika która została zaktualizowana
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \bounds_update/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_result:=0;

_can_continue:=0;

ZGP.cntx_psh(); ZGP.clear();
NASZGP.cntx_psh();
PL_OPER.cntx_psh();
PL_OPER.index('ZGP');
PL_OGR.cntx_psh();
PL_OGR.index('GROP');
GROPP.cntx_psh();
GROPP.index('ZGP');

{? ZGP.seek(_zgp)
||
:: Aktualizacja dat i godzin dla PL_OPERA kooperacyjnego
   PL_OPER.prefix(ZGP.ref());
   {? PL_OPER.first()
   || {!
      |? PL_OPER.STARTD:=ZGP.STARTDK;
         PL_OPER.STARTT:=ZGP.STARTTK;
         PL_OPER.ENDD:=ZGP.ENDDK;
         PL_OPER.ENDT:=ZGP.ENDTK;
         PL_OPER.MINDATE:=ZGP.STARTDK;
         PL_OPER.MINTIME:=ZGP.STARTTK;
         PL_OPER.MAXDATE:=ZGP.ENDDK;
         PL_OPER.MAXTIME:=ZGP.ENDTK;
         _can_continue:=PL_OPER.put();
         PL_OPER.next() & _can_continue>0
      !}
   ?};

:: Aktualizacja następnych operacji względem podanej
   NASZGP.index('OPNAST');
   NASZGP.prefix(_zgp);
   {? NASZGP.first()
   || _can_continue:=1;
      {!
      |?
::       Określam nowe czasy dla następnika
         _zgp_min:=exec('zgp_min_start','po_plan',NASZGP.NRNAST);

::       Aktualizuję PL_OPERy dla następnika
         PL_OPER.prefix(NASZGP.NRNAST);
         {? PL_OPER.first()
         || {!
            |?
::             Wystarczy zaktualizować minimalny czas początku
               PL_OPER.MINDATE:=exec('tm_stamp2date','#tm_stamp',_zgp_min);
               PL_OPER.MINTIME:=exec('tm_stamp2time','#tm_stamp',_zgp_min);
               _can_continue:=PL_OPER.put();
               PL_OPER.next() & _can_continue>0
            !}
         ?};

::       Aktualizuję PL_OGRy dla następnika
         {? _can_continue>0
         || GROPP.prefix(NASZGP.NRNAST);
            {? GROPP.first()
            || {!
               |?
                  PL_OGR.prefix(GROPP.GROP);
                  {? PL_OGR.first()
                  || {!
                     |? PL_OGR.TM_MIN:=_zgp_min;
                        _can_continue:=PL_OGR.put();
                        PL_OGR.next() & _can_continue>0
                     !}
                  ?};
                  GROPP.next() & _can_continue>0
               !}
            ?}
         ?};
         NASZGP.next() & _can_continue>0
      !}
   ?};

:: Aktualizacja poprzednich operacji względem podanej
   NASZGP.index('NASTOP');
   NASZGP.prefix(_zgp);
   {? NASZGP.first()
   || _can_continue:=1;
      {!
      |?
::       Określam nowe czasy dla poprzednika
         _zgp_max:=exec('zgp_max_end','po_plan',NASZGP.OPER);

::       Aktualizuję PL_OPERy dla poprzednika
         PL_OPER.prefix(NASZGP.OPER);
         {? PL_OPER.first()
         || {!
            |?
::             Wystarczy zaktualizować maksymalny czas końca
               PL_OPER.MAXDATE:=exec('tm_stamp2date','#tm_stamp',_zgp_max);
               PL_OPER.MAXTIME:=exec('tm_stamp2time','#tm_stamp',_zgp_max);
               _can_continue:=PL_OPER.put();
               PL_OPER.next() & _can_continue>0
            !}
         ?};

::       Aktualizuję PL_OGRy dla następnika
         {? _can_continue>0
         || GROPP.prefix(NASZGP.OPER);
            {? GROPP.first()
            || {!
               |?
                  PL_OGR.prefix(GROPP.GROP);
                  {? PL_OGR.first()
                  || {!
                     |? PL_OGR.TM_MAX:=_zgp_max;
                        _can_continue:=PL_OGR.put();
                        PL_OGR.next() & _can_continue>0
                     !}
                  ?};
                  GROPP.next() & _can_continue>0
               !}
            ?}
         ?};
         NASZGP.next() & _can_continue>0
      !}
   ?}
?};
GROPP.cntx_pop();
PL_OGR.cntx_pop();
PL_OPER.cntx_pop();
NASZGP.cntx_pop();
ZGP.cntx_pop();
_result


\zgp_min_start
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca minimalny czas początku w planie dla ZGPa uwzględniając nastepujące kryteria:
::       1. Kooperacje jako poprzedniki
::       [2. Plan operacyjny - plan grup operacji]
::   WE: _a  - ZGP.ref() - pozycja przewodnika dla której zwrocić wymagany czas
::       [_b] - INTEGER - 1 - uwzględniać kryterium grup; [0] - nie uwzględniać kryterium grup
::   WY: REAL - tm_stamp
::  OLD: \zgp_min_start/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_grops:=0;
{? var_pres('_b')=type_of(0)
|| _grops:=_b
?};

_result:=0;

ZGP.cntx_psh(); ZGP.clear();
NASZGP.cntx_psh();
NASZGP.index('NASTOP');
{? ZGP.seek(_zgp)
||
:: Wyznaczam minimalny czas początku na podstawie poprzedników podanego ZGPa
   NASZGP.prefix(ZGP.ref());
   {? NASZGP.first()
   || {!
      |?
::       Podczytanie ZGP - stoję na poprzedniku
         NASZGP.OPER();

::       1. Kryterium kooperacji
         {? ZGP.WEW='N'
         || {? _result=0 | (ZGP.TMENDK>0 & ZGP.TMENDK>_result)
            || _result:=ZGP.TMENDK
            ?}
         ?};
         NASZGP.next()
      !}
   ?}
?};
NASZGP.cntx_pop();
ZGP.cntx_pop();
_result


\zgp_max_end
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca maksymalny czas końca w planie dla ZGPa uwzględniając nastepujące kryteria:
::       1. Kooperacje jako następniki
::   WE: _a  - ZGP.ref() - pozycja przewodnika dla której zwrocić wymagany czas
::   WY: REAL - tm_stamp
::  OLD: \zgp_max_end/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_result:=0;

ZGP.cntx_psh(); ZGP.clear();
NASZGP.cntx_psh();
NASZGP.index('OPNAST');
{? ZGP.seek(_zgp)
||
:: Wyznaczam maksymalny czas końca na podstawie następników podanego ZGPa
   NASZGP.prefix(ZGP.ref());
   {? NASZGP.first()
   || {!
      |?
::       Podczytanie ZGP - stoję na następniku
         NASZGP.NRNAST();

::       1. Kryterium kooperacji
         {? ZGP.WEW='N'
         || {? _result=0 | (ZGP.TMSTARTK>0 & ZGP.TMSTARTK<_result)
            || _result:=ZGP.TMSTARTK
            ?}
         ?};
         NASZGP.next()
      !}
   ?}
?};
NASZGP.cntx_pop();
ZGP.cntx_pop();
_result


\pl_next_update
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Po dodaniu NASZGP uaktualniam tabele PL_NEXT (tworze polaczenia miedzy PL_OPERAmi)
::       jezeli ich jeszcze nie bylo a sa wymagana (np polaczenia miedzy PL_OPERAmi z podzlecen zlecenia zlozonego)
::       Kontekst pracy - nowo dodany rekord NASZGP
::   WE: _a - ZGP.ref() - pozycja przewodnika ktorej regeneruje polaczenia zaczynajace sie od
::   WY: 0 - porazka
::       1 - sukces
::  OLD: \pl_next_update/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_result:=0;
_can_continue:=1;

NASZGP.cntx_psh();
NASZGP.index('OPNAST');
PL_NEXT.cntx_psh();
PL_OPER.cntx_psh();
PL_OPER.index('ZGP');
GROPP.cntx_psh();
GROPP.index('ZGP');
PL_OGR.cntx_psh();
PL_OGR.index('GROP');
ZGP.cntx_psh();

:: Usuwam powiazane z ZGP PL_NEXTy
_can_continue:=exec('plnext_del2zgp','po_plan',_zgp);

{? _can_continue>0
||
:: Polaczenie PL_OPER->PL_OPER lub PL_OPER->PL_OGR
   PL_NEXT.index('PL_OPER');
   PL_OPER.prefix(_zgp);
   {? PL_OPER.first()
   ||
      {!
      |?
         PL_NEXT.blank();
         PL_NEXT.PL_OPER:=PL_OPER.ref();

::       Iteruje po wszystkich nastepnikach zgpa i sprawdzam czy następne operacje sa w planie
::       Jesli sa to robie PL_NEXTy
         NASZGP.prefix(_zgp);
         {? NASZGP.first()
         || {!
            |?
::             Sprawdzam czy nastepnik jest zwyklym ploperem czy plogrem
               {? NASZGP.NRNAST<>null()
               ||
::                Podczytanie ZGP - stoje na nastepniku
                  NASZGP.NRNAST();

::                Tworze polaczenia PL_OPER->PL_OPER
                  PL_OPER.cntx_psh();
                  PL_OPER.prefix(ZGP.ref());
                  {? PL_OPER.first()
                  || {!
                     |?
                        PL_NEXT.NEXT:=PL_OPER.ref();
                        _can_continue:=PL_NEXT.add(1);
                        PL_OPER.next() & _can_continue>0
                     !}
                  ?};
                  PL_OPER.cntx_pop();

::                Tworze polaczenia PL_OPER->PL_OGR
                  GROPP.prefix(ZGP.ref());
                  {? GROPP.first()
                  || {!
                     |? PL_OGR.prefix(GROPP.GROP);
                        {? PL_OGR.first()
                        || {!
                           |? PL_NEXT.NEXT:=null();
                              PL_NEXT.NEXT_OGR:=PL_OGR.ref();
                              _can_continue:=PL_NEXT.add(1);
                              PL_OGR.next() & _can_continue>0
                           !}
                        ?};
                        GROPP.next() & _can_continue>0
                     !}
                  ?}
               ?};
               NASZGP.next()
            !}
         ?};
         {? _can_continue>0
         ||
::          Aktualizacja tm_stampow na PL_NEXT
            exec('next_tm_oper','po_plan',PL_OPER.ref())
         ?};
         PL_OPER.next() & _can_continue>0
      !}
   ?};

   {? _can_continue>0
   ||
::    Polaczenie PL_OGR->PL_OPER
      PL_NEXT.index('PL_OGR');
      GROPP.prefix(_zgp);
      {? GROPP.first()
      || {!
         |?
::          Iteruje po wszystkich nastepnikach zgpa i sprawdzam czy następne operacje sa w planie
::          Jesli sa to robie PL_NEXTy
            NASZGP.prefix(_zgp);
            {? NASZGP.first()
            || {!
               |?
                  PL_OGR.prefix(GROPP.GROP);
                  {? PL_OGR.first()
                  || {!
                     |?
::                      Sprawdzam czy PL_OGR ma PL_NEXta
                        PL_NEXT.prefix(PL_OGR.ref());
                        {? PL_NEXT.size()=0
                        ||
::                         Nie ma PL_NEXta - zakladam
                           PL_NEXT.blank();
                           PL_NEXT.PL_OGR:=PL_OGR.ref();

                           {? NASZGP.NRNAST<>null()
                           ||
::                            Podczytanie ZGP - stoje na nastepniku
                              NASZGP.NRNAST();

::                            Tworze polaczenia PL_OGR->PL_OPER
                              PL_OPER.cntx_psh();
                              PL_OPER.prefix(ZGP.ref());
                              {? PL_OPER.first()
                              || {!
                                 |?
                                    PL_NEXT.NEXT:=PL_OPER.ref();
                                    _can_continue:=PL_NEXT.add(1);
                                    PL_OPER.next() & _can_continue>0
                                 !}
                              ?};
                              PL_OPER.cntx_pop()
                           ?}
                        ?};
                        {? _can_continue>0
                        ||
::                         Aktualizacja tm_stampow na PL_NEXT
                           exec('next_tm_ogr','po_plan',PL_OGR.ref())
                        ?};
                        PL_OGR.next() & _can_continue>0
                     !}
                  ?};
                  NASZGP.next()
               !}
            ?};
            GROPP.next() & _can_continue>0
         !}
      ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};

NASZGP.cntx_pop();
ZGP.cntx_pop();
PL_NEXT.cntx_pop();
PL_OPER.cntx_pop();
PL_OGR.cntx_pop();
GROPP.cntx_pop();
_result


\plnext_del2zgp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Usuwa PL_NEXTy które się zaczynają od podanego ZGPa
::   WE: _a - ZGP.ref
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \plnext_del2zgp/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_result:=0;
_can_continue:=1;

PL_NEXT.cntx_psh();
PL_OPER.cntx_psh();
PL_OPER.index('ZGP');
GROPP.cntx_psh();
GROPP.index('ZGP');

:: 1. Czysczę PL_NEXty powiązane z PL_OPERami
PL_NEXT.index('PL_OPER');
PL_OPER.prefix(_zgp);
{? PL_OPER.first()
|| {!
   |? PL_NEXT.prefix(PL_OPER.ref());
      {? PL_NEXT.first()
      || {!
         |?
            _can_continue:=exec('del_plnext','po_plan',$PL_NEXT.ref());
            PL_NEXT.first() & _can_continue>0
         !}
      ?};
      PL_OPER.next()
   !}
?};

{? _can_continue>0
||
:: 2. Czyszczę PL_NEXty powiązane z PL_OGRAmi
   PL_NEXT.index('PL_OGR');
   GROPP.prefix(_zgp);
   {? GROPP.first()
   || {!
      |? PL_OGR.prefix(GROPP.GROP);
         {? PL_OGR.first()
         || {!
            |? PL_NEXT.prefix(PL_OGR.ref());
               {? PL_NEXT.first()
               || {!
                  |? _can_continue:=exec('del_plnext','po_plan',$PL_NEXT.ref());
                     PL_NEXT.first() & _can_continue>0
                  !}
               ?};
               PL_OGR.next()
            !}
         ?};
         GROPP.next()
      !}
   ?}
?};

PL_NEXT.cntx_pop();
PL_OPER.cntx_pop();
GROPP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\next_tm_oper
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Aktualizuje pola tm_stamp dla PL_NEXTow powiązanych z ploperem
::   WE: _a - PL_OPER.ref()
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \next_tm_oper/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_pl_oper:=_a;

_result:=0;
_can_continue:=1;

PL_OPER.cntx_psh(); PL_OPER.clear();
PL_NEXT.cntx_psh();
{? PL_OPER.seek(_pl_oper)
|| _tm_start:=PL_OPER.TM_START;
   _tm_end:=PL_OPER.TM_END;
   PL_NEXT.index('PL_OPER');
   PL_NEXT.prefix(PL_OPER.ref());
   {? PL_NEXT.first()
   || {!
      |? PL_NEXT.TM_START:=_tm_start;
         PL_NEXT.TM_END:=_tm_end;
         _can_continue:=PL_NEXT.put();
         PL_NEXT.next() & _can_continue>0
      !}
   ?}
?};
PL_NEXT.cntx_pop();
PL_OPER.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\next_tm_ogr
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Aktualizuje pola tm_stamp dla PL_NEXTow powiązanych z plogrem
::   WE: _a - PL_OGR.ref()
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \next_tm_ogr/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_pl_ogr:=_a;

_result:=0;
_can_continue:=1;

PL_OGR.cntx_psh(); PL_OGR.clear();
PL_NEXT.cntx_psh();
{? PL_OGR.seek(_pl_ogr)
|| _tm_start:=PL_OGR.TM_START;
   _tm_end:=PL_OGR.TM_END;
   PL_NEXT.index('PL_OGR');
   PL_NEXT.prefix(PL_OGR.ref());
   {? PL_NEXT.first()
   || {!
      |? PL_NEXT.TM_START:=_tm_start;
         PL_NEXT.TM_END:=_tm_end;
         _can_continue:=PL_NEXT.put();
         PL_NEXT.next() & _can_continue>0
      !}
   ?}
?};
PL_NEXT.cntx_pop();
PL_OGR.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\del_plnext
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Usuwa PL_NEXTa
::   WE: _a - Ref SQL usuwanego plnexta
::   WY: 0 / 1
::  OLD: \del_plnext/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:='';
_result:=0;
{? _>0
|| _ref:=_a
|| return(0)
?};
PL_NEXT.cntx_psh();
PL_NEXT.clear();
{? PL_NEXT.seek(_ref)
|| {? PL_NEXT.del(,1)>0
   || _result:=1
   || _result:=0
   ?}
?};
PL_NEXT.cntx_pop();
_result


\zl_dates_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Uuaktualniam daty i czasy poczatku i konca na zleceniu
::   WE: _a - ZL.ref()
::   WY: 0 / 1
::  OLD: \zl_dates_update/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| return()
?};
_zl:=_a;
_ok:=0;

PL_PART.cntx_psh();
ZL.cntx_psh();
ZL.clear();
_startd:=date(0,0,0);
_startt:=time(0,0,0);
_endd:=date(0,0,0);
_endt:=time(0,0,0);
{? ZL.seek(_zl)
|| PL_PART.index('ZL_START');
   PL_PART.prefix(ZL.ref());
::------------indeks jest posortowany od najmniejszej daty i czasu wiec biegne od poczatku i sprawdzam czy data ustawiona
   _continue:=1;
   {? PL_PART.first()
   || {!
      |? {? PL_PART.STARTD>date(1970,1,1) & PL_PART.ENDD>date(1970,1,1)
         || _startd:=PL_PART.STARTD;
            _startt:=PL_PART.STARTT;
            _continue:=0
         ?};
         _continue>0 & PL_PART.next()
      !}
   ?};
   PL_PART.index('ZL_END');
   PL_PART.prefix(ZL.ref());
::----------------------------------------------------------------------------------------------------------------------
   _continue:=1;
   {? PL_PART.last()
   || {!
      |? {? PL_PART.STARTD>date(1970,1,1) & PL_PART.ENDD>date(1970,1,1)
         || _endd:=PL_PART.ENDD;
            _endt:=PL_PART.ENDT;
            _continue:=0
         ?};
         _continue>0 & PL_PART.prev()
      !}
   ?};
::----------------------------------------------------------------------------------------------------------------------
   ZL.STARTD:=_startd;
   ZL.STARTT:=_startt;
   ZL.ENDD:=_endd;
   ZL.ENDT:=_endt;
   _ok:=ZL.put();

   {? _ok>0
   ||
::    Sprawdzam czy zlecenie ma nadrzedne
      _top:=exec('top_level','zl_link',ZL.ref());

      {? _top<>ZL.ref()
      || _ok:=exec('zl_dates_nad','po_plan',_top)
      ?}
   ?}
?};
ZL.cntx_pop();
PL_PART.cntx_pop();
_ok


\zl_dates_nad
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Uaktualniam daty i czasy
::   WE: _a - ZL.ref
::   WY: 0 - porazka
::       1 - sukces
::  OLD: \zl_dates_nad/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=0;
_can_continue:=1;

ZL.cntx_psh(); ZL.clear();
{? ZL.seek(_zl)
||
:: Sprawdzam czy zlecenie ma podzlecenia
   {? exec('subzlec_exist','zl_link',ZL.ref())>0
   ||
      _startd:=date(0,0,0);
      _startt:=time(0,0,0);
      _endd:=date(0,0,0);
      _endt:=time(0,0,0);

      _can_continue:=1;
      ZL.cntx_psh();
::    Znajduje podzlecenie z najwczesniejszym poczatkiem
      ZL.index('UP_START');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? {? ZL.STARTD>date(1970,1,1) & ZL.ENDD>date(1970,1,1)
            ||
               _startd:=ZL.STARTD;
               _startt:=ZL.STARTT;
               _can_continue:=0
            ?};
            ZL.next() & _can_continue>0
         !}
      ?};
      ZL.cntx_pop();

      _can_continue:=1;
      ZL.cntx_psh();
::    Znajduje podzlecenie z najpozniejszym koncem
      ZL.index('UP_END');
      ZL.prefix(ZL.UNRZL);
      {? ZL.last()
      || {!
         |? {? ZL.STARTD>date(1970,1,1) & ZL.ENDD>date(1970,1,1)
            ||
               _endd:=ZL.ENDD;
               _endt:=ZL.ENDT;
               _can_continue:=0
            ?};
            ZL.prev() & _can_continue>0
         !}
      ?};
      ZL.cntx_pop();

::    Ustawiam daty na zleceniu nadrzednym
      ZL.STARTD:=_startd;
      ZL.STARTT:=_startt;
      ZL.ENDD:=_endd;
      ZL.ENDT:=_endt;
      _result:=ZL.put()
   ?}
?};
ZL.cntx_pop();
_result


\zgh_dates_upd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Ustawiam date startu i poczatku dla przewodnika
::   WE: _a - PL_PART.ref()
::  OLD: \zgh_dates_upd/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| return()
?};
_plpart_ref:=_a;

PL_PART.cntx_psh();
ZGH.cntx_psh();
ZGH.clear();
PL_PART.clear();

{? PL_PART.seek(_plpart_ref)
|| {? ZGH.seek(PL_PART.ZGH)
   || ZGH.STARTD:=PL_PART.STARTD;
      ZGH.STARTT:=PL_PART.STARTT;
      ZGH.ENDD:=PL_PART.ENDD;
      ZGH.ENDT:=PL_PART.ENDT;
      ZGH.put()
   ?}
?};
PL_PART.cntx_pop();
ZGH.cntx_pop();
~~


\find_zl_toper
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Na podstawie zlecenia i TOPERa zrodlowego z technologii znajduje TOPERa w technologii zlecenia
::   WE: _a - ZL.ref
::       _b - TOPER.ref nalezacy do technologii zrodlowej
::   WY: TOPER.ref lub null()
::  OLD: \find_zl_toper/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_toper:=_b;

_args:=obj_new('TOPER_SRC','ZL','RESULT');
_args.TOPER_SRC:=_toper;
_args.ZL:=_zl;
_args.RESULT:=null();

_rule:="
   _args:=_b;
   _result:=0;
   TKTL.cntx_psh();
   TOPER.cntx_psh();
   TOPER.index('SRC');
   TOPER.prefix($_args.TOPER_SRC);
   {? TOPER.first()
   || {!
      |?
::       Zmieniam maske TKTLa
         TKTL.use(5+TKTL.name()+(TOPER.name()+3));
         {? TOPER.NRK().TORW='Z'
         || {? TOPER.NRK().ZL=_args.ZL
            || _args.RESULT:=TOPER.ref();
               _result:=1
            ?}
         ?};
         TOPER.next() & _result=0
      !}
   ?};
   TKTL.cntx_pop();
   TOPER.cntx_pop();
   _result
";

_name:=5+TOPER.name();
_msk_start:=_name+'_'+(2-$(ZL.OD~1));
_msk_end:=_name+'___';
exec('for_each_mask','#table',TOPER,_rule,_msk_start,_msk_end,_args,0);
_args.RESULT


\zgp_dates_upd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Ustawiam date startu i poczatku dla pozycji przewodnika
::   WE: _a - PL_OPER.ref()
::  OLD: \zgp_dates_upd/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| return()
?};
_ploper_ref:=_a;

PL_OPER.cntx_psh();
ZGP.cntx_psh();
ZGP.clear();
PL_OPER.clear();

{? PL_OPER.seek(_ploper_ref)
|| {? PL_OPER.ZGP<>null()
   || {? ZGP.seek(PL_OPER.ZGP)
      ||
         _tm_start:=0;
         _tm_end:=0;
         PL_OPER.index('ZGPSTART');
         PL_OPER.prefix(ZGP.ref());
         {? PL_OPER.first()
         || {!
            |? {? PL_OPER.TM_START>0
               || _tm_start:=PL_OPER.TM_START
               ?};
               PL_OPER.next() & _tm_start=0
            !}
         ?};
         PL_OPER.index('ZGPEND');
         PL_OPER.prefix(ZGP.ref());
         {? PL_OPER.last()
         || _tm_end:=PL_OPER.TM_END
         ?};

         {? _tm_start>0 & _tm_end>0
         ||
            ZGP.STARTD:=exec('tm_stamp2date','#tm_stamp',_tm_start);
            ZGP.STARTT:=exec('tm_stamp2time','#tm_stamp',_tm_start);

            ZGP.ENDD:=exec('tm_stamp2date','#tm_stamp',_tm_end);
            ZGP.ENDT:=exec('tm_stamp2time','#tm_stamp',_tm_end);

            {? ZGP.put()
            ||
::             Aktualizuje czasy na ZGPie TPZtowym o ile jest
               ZGP.cntx_psh();
               ZGP.index('TPZ');
               ZGP.prefix('T',ZGP.UID);
               {? ZGP.first()
               || ZGP.STARTD:=PL_OPER.STARTD;
                  ZGP.STARTT:=PL_OPER.STARTT;
                  ZGP.ENDD:=PL_OPER.ENDD;
                  ZGP.ENDT:=PL_OPER.ENDT;
                  ZGP.put()
               ?};
               ZGP.cntx_pop();
               exec('zlim_dates_upd','zl_limit',ZGP.ref())
            ?}
         ?}
      ?}
   ?}
?};
ZGP.cntx_pop();
PL_OPER.cntx_pop();
~~


\get_plres
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca zasób planistyczny
::   WE: _a - Typ zasobu - B,L,P,G,S,W
::       _b - ref źródła z którego powstał zasób (UD_SKL.ref(), TWRKPLC.ref() itp)
::   WY: PL_RES.ref()
::  OLD: \get_plres/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=null();
{? _<2
|| return(_result)
?};

_typ:=_a;
_source:=_b;
_prefix:=1;

PL_RES.cntx_psh();
:: stanowisko produkcyjne
{? _typ='S' || PL_RES.index('FROM_STA')

:: gniazdo produkcyjne
|? _typ='G' || PL_RES.index('FROM_GNI')

:: linia produkcyjna
|? _typ='L' || PL_RES.index('FROM_LIN')

:: brygada pracownicza
|? _typ='B' || PL_RES.index('FROM_BRY')

:: pracownik
|? _typ='P' || PL_RES.index('FROM_PRA')

:: wydział
|? _typ='W' || PL_RES.index('FROM_WYD')

:: nieznane więc nie robimy prefixa i tyle
|| _prefix:=0
?};

{? _prefix
|| PL_RES.prefix(_source);
   {? PL_RES.first()
   || _result:=PL_RES.ref()
   ?}
?};

PL_RES.cntx_pop();
_result


\zam_planned
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Sprawdza czy zamówienie zostało już zaplanowane
::   WE: _a - $ZK_P.ref() - SQL ref pozycji zamówienia
::   WY: REAL - ile zostało zaplanowane
::  OLD: \zam_planned/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zkp:='';
{? _>0
|| _zkp:=_a
?};

_result:=0;

ZK_P.cntx_psh();
ZK_P.clear();
PL_PART.cntx_psh();
PL_PART.index('ZK_P');

{? ZK_P.seek(_zkp)
|| PL_PART.prefix(ZK_P.ref());
   {? PL_PART.first()
   || {!
      |? _result+=PL_PART.ILOSC;
         PL_PART.next()
      !}
   ?}
?};

PL_PART.cntx_pop();
ZK_P.cntx_pop();
_result


\del_zam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Usuwa caly plan produkcji pozycji zamowienia
::   WE: _a - Ref SQL ZK_P
::   WY: 0 / 1
::  OLD: \del_zam/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:='';
_result:=0;
{? _>0
|| _ref:=_a
|| return(0)
?};
ZK_P.cntx_psh();
PL_PART.cntx_psh();
ZK_P.clear();
{? ZK_P.seek(_ref)
||
::----------------------------------------------------------------------------------------------------------------------
   _plpart_ok:=1;
   PL_PART.index('ZK_P');
   PL_PART.prefix(ZK_P.ref());
   {? PL_PART.first()
   || {!
      |? _plpart_ok:=exec('del_plpart','po_plan',$PL_PART.ref());
         _plpart_ok>0 & PL_PART.first()
      !}
   ?};
   {? _plpart_ok>0
   || _result:=1
   || _result:=0
   ?}
?};
ZK_P.cntx_pop();
PL_PART.cntx_pop();
_result


\del_plpart
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Usuwa PL_PART'a, wszystkie nalezace do niego plopery i plozy
::   WE: _a - Ref SQL usuwanego plparta
::       [_b] - INTEGER - [0]/1 - usuwać nawet jeżeli są wykonania
::   WY: 0 / 1
::  OLD: \del_plpart/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:='';
_result:=0;
{? _>0
|| _ref:=_a
|| return(0)
?};
_force:=0;
{? var_pres('_b')=type_of(0)
|| _force:=_b
?};
PL_OPER.cntx_psh();
ZL.cntx_psh();
ZGH.cntx_psh(); ZGH.clear();
PL_OZ.cntx_psh();
PL_PART.cntx_psh();
PL_PART.clear();
_zlecenie:=null;
_zgh:=null;
{? PL_PART.seek(_ref)
||
::-------zapamietuje zlecenie jesli bylo ustawione (po to by moc zresetowac zleceniu daty po usunieciu ostatniego plparta)
   _zlecenie:=PL_PART.ZL;
::----------------------------------------------------------------------------------------------------------------------
   _zgh:=PL_PART.ZGH;
::----------------------------------------------------------------------------------------------------------------------
   _ploper_ok:=1;
   PL_OPER.index('PL_PART');
   PL_OPER.prefix(PL_PART.ref());
   {? PL_OPER.first()
   || {!
      |? _ploper_ok:=exec('del_ploper','po_plan',$PL_OPER.ref(),,,,,_force);
         _ploper_ok>0 & PL_OPER.first()
      !}
   ?};

   _can_continue:=1;
   {? _ploper_ok>0
   ||
::    4. Usuwam powiazane rekordy z tabeli PL_SPLIT
      PL_SPLIT.cntx_psh();
      PL_SPLIT.index('PL_PART');
      PL_SPLIT.prefix(PL_PART.ref());
      {? PL_SPLIT.first()
      || {!
         |? _can_continue:=exec('delete','po_split',PL_SPLIT.ref());
            PL_SPLIT.first() & _can_continue>0
         !}
      ?};
      PL_SPLIT.cntx_pop()
   ?};

::----------------------------------------------------------------------------------------------------------------------
   {? _ploper_ok & _can_continue>0
   || {? PL_PART.del(,1)>0
      || _result:=1
      || _result:=0
      ?}
   ?}
?};
{? _result>0
|| {? _zlecenie<>null()
   || {? ZL.seek(_zlecenie)
      ||
         PL_PART.index('ZL');
         PL_PART.prefix(ZL.ref());
         {? PL_PART.size()=0
         || ZL.PLAN_PO:='N';
            ZL.put();
            exec('zl_dates_reset','po_plan',ZL.ref())
         ?};

         {? ZL.TREE<>null()
         || _top:=exec('top_level','zl_link',ZL.ref());
            {? _top<>ZL.ref()
            || exec('zl_plan_update','zl_common',_top)
            ?}
         ?}
      ?}
   ?};
   {? _zgh<>null()
   || {? ZGH.seek(_zgh)
      || exec('zgh_dates_reset','po_plan',ZGH.ref());

::       Odtwarzam statusy rejestracji wykonań na ZGP
         exec('recover_sta_zgh','zl_guide',_zgh)
      ?}
   ?}
?};
ZL.cntx_pop();
ZGH.cntx_pop();
PL_OPER.cntx_pop();
PL_OZ.cntx_pop();
PL_PART.cntx_pop();
_result


\del_ploz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Usuwa PL_OZ'a
::   WE: _a - Ref SQL usuwanego ploza
::       [_b] - INTEGER - 0/[1] - czy aktualizować status zaplanowania zdarzeń
::       [_c] - INTEGER - 0/[1] - czy sprawdzać uprawnienia do widoków planu
::       [_d] - INTEGER - [0]/1 - usuwać nawet jeżeli są wykonania
::   WY: 0 / 1
::  OLD: \del_ploz/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:='';
_result:=0;
{? _>0
|| _ref:=_a
|| return(0)
?};
_zdarzenia_upd:=1;
{? var_pres('_b')=type_of(0)
|| _zdarzenia_upd:=_b
?};
_view_upr:=1;
{? var_pres('_c')=type_of(0)
|| _view_upr:=_c
?};
_force:=0;
{? var_pres('_d')=type_of(0)
|| _force:=_d
?};

PL_OZ.cntx_psh();
ZL.cntx_psh();
ZGH.cntx_psh();
PL_PART.cntx_psh();
PL_PART.clear();
ZL.clear();
ZGH.clear();
PL_OZ.clear();
ZGP.cntx_psh();
ZGP.clear();

_plpart:=null;
_zgp:=null();
_ploper:=null();
_pl_evenr:=null();
_pl_res:=null();

{? PL_OZ.seek(_ref)
|| _pl_res:=PL_OZ.PL_RES;
   {? PL_OZ.PL_OPER<>null()
   || PL_OZ.PL_OPER();
      _ploper:=PL_OPER.ref();
      {? PL_OPER.PL_PART<>null()
      || _plpart:=PL_OPER.PL_PART
      ?};
      {? PL_OPER.ZGP<>null()
      || _zgp:=PL_OPER.ZGP
      ?};
      {? PL_OPER.PL_EVENR<>null()
      || _pl_evenr:=PL_OPER.PL_EVENR
      ?}
   ?};

   _can_del:=1;
   PL_WYK.index('PL_OZ');
   PL_WYK.prefix(PL_OZ.ref());
   {? _force>0
   || {? PL_WYK.first()
      || {!
         |? _next:=0;
            _ref_nxt:=null();
            PL_WYK.cntx_psh();
            {? PL_WYK.next()
            || _ref_nxt:=PL_WYK.ref()
            ?};
            PL_WYK.cntx_pop();

            _can_continue:=PL_WYK.del(,1);

            {? _ref_nxt<>null()
            || _next:=PL_WYK.seek(_ref_nxt)
            ?};
            _next>0 & _can_continue>0
         !}
      ?}
   ||

      {? PL_WYK.first()
      || KOMM.add('Operacja %1 %2 na zasobie: %3 - zarejestrowano wykonania.'@[PL_OPER.SYMBOL,PL_OPER.OPIS,PL_OZ.PL_RES().SYM],2,,1);
         _can_del:=0
      ?}
   ?};

   {? _view_upr>0
   || {? exec('has_upr4plres','po_param',PL_OZ.PL_RES)=0
      || KOMM.add('Operacja %1 %2 na zasobie: %3 - brak uprawnień do redagowania zasobu.'@[PL_OPER.SYMBOL,PL_OPER.OPIS,PL_OZ.PL_RES().SYM],2,,1);
         _can_del:=0
      ?}
   ?};

   {? _can_del>0
   || exec('del_pl_conf','po_plan')
   ?};

   {? _can_del>0
   ||
      {? PL_OZ.del(,1)>0
      || _result:=1
      ?}
   ?}
?};

{? _result>0
|| {? _plpart<>null()
   || {? PL_PART.seek(_plpart)
      || {? ZL.seek(PL_PART.ZL)
         || exec('zl_dates_update','po_plan',ZL.ref())
         ?};
         {? ZGH.seek(PL_PART.ZGH)
         || exec('zgh_dates_upd','po_plan',PL_PART.ref())
         ?}
      ?}
   ?};
   {? _ploper<>null()
   || PL_OZ.index('PL_OPER');
      PL_OZ.prefix(_ploper);
::    jesli sa jeszcze jakies zapisy obciazajace to update dat na pozycji przewodnika, jesli nie ma to reset dat
      {? PL_OZ.size()>0
      || exec('zgp_dates_upd','po_plan',_ploper)
      || {? _zgp<>null()
         || {? ZGP.seek(_zgp)
            || exec('zgp_dates_reset','po_plan',ZGP.ref())
            ?}
         ?}
      ?}
   ?}
|| _result:=-1
?};

{? _result>0 & _zdarzenia_upd>0 & _pl_evenr<>null
|| _result:=exec('plan_del','po_event',_pl_evenr,_ploper,_pl_res)
?};

ZGP.cntx_pop();
PL_OZ.cntx_pop();
ZL.cntx_pop();
ZGH.cntx_pop();
PL_PART.cntx_pop();
_result


\del_ploper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Usuwa PL_OPER'a i wszystkie nalezace do niego PL_OZ'y
::   WE: _a - Ref SQL usuwanego plopera
::       [_b] - INTEGER - [0]/1 - czy usuwać pustego plparta po usunięciu plopera
::       [_c] - INTEGER - [0]/1 - czy aktualizować daty na plparcie
::       [_d] - INTEGER - 0/[1] - czy aktualizować status zaplanowania zdarzeń
::       [_e] - INTEGER - 0/[1] - czy sprawdzać uprawnienia do widoków planu
::       [_f] - INTEGER - [0]/1 - usuwać nawet jeżeli są wykonania
::   WY: 0 - porazka
::       1 - sukces
::  OLD: \del_ploper/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:='';
_result:=0;
{? _>0
|| _ref:=_a
|| return(0)
?};
_del_plpart:=0;
{? var_pres('_b')=type_of(0)
|| _del_plpart:=_b
?};
_plpart_upd:=0;
{? var_pres('_c')=type_of(0)
|| _plpart_upd:=_c
?};
_zdarzenia_upd:=1;
{? var_pres('_d')=type_of(0)
|| _zdarzenia_upd:=_d
?};
_view_upr:=1;
{? var_pres('_e')=type_of(0)
|| _view_upr:=_e
?};
_force:=0;
{? var_pres('_f')=type_of(0)
|| _force:=_f
?};

PL_OPER.cntx_psh();
PL_OZ.cntx_psh();
PL_PART.cntx_psh();
ZL.cntx_psh();
ZGH.cntx_psh();
ZGP.cntx_psh();
ZL.clear();
ZGH.clear();
ZGP.clear();
PL_PART.clear();
PL_NEXT.cntx_psh();
PL_OPER.clear();

_plpart:=null();
_zgp:=null();

_can_continue:=1;

{? PL_OPER.seek(_ref)
||
   _pl_oper:=PL_OPER.ref();
   {? PL_OPER.PL_PART<>null()
   || _plpart:=PL_OPER.PL_PART
   ?};
   {? PL_OPER.ZGP<>null()
   || _zgp:=PL_OPER.ZGP
   ?};

:: Sprawdzam czy mozna usunac
   {? _force>0
   || _can_delete:=1
   || _can_delete:=exec('can_move_ploper','px_tie',PL_OPER.ref())
   ?};
   {? _can_delete>0
   ||
      PX_POZ.cntx_psh();
      PX_POZ.index('PL_OPER2');
      PX_POZ.prefix(PL_OPER.ref());
      {? PX_POZ.size()>0
      ||
::       Oznaczam wersje glowna do przeliczenia
         exec('mod_stamp_queue','px_ver',exec('get_mainversion','px_ver'));

::       Usuwanie powiazan dla PL_OPERa w planie strategicznym
         _can_continue:=exec('ploper_clear','px_poz',PL_OPER.ref(),,_force);
         {? _can_continue=0
         || _msg:='Usunięcie operacji: '+PL_OPER.SYMBOL+' ('+PL_OPER.OPIS+') niemożliwe. Istnieją powiazania w planie stratgegicznym.';
            KOMM.error(_msg,0,1)
         ?}
      ?};
      PX_POZ.cntx_pop()

   || _px_ok:=0;
      _can_continue:=0;
      _result:=0;
      _msg:='Usunięcie operacji: '+PL_OPER.SYMBOL+' ('+PL_OPER.OPIS+') niemożliwe.';
      {? _can_delete=-3
      || _msg+=' Istnieją wykonania w Planie strategicznym.'
      |? _can_delete=-4
      || _msg+=' Istnieją wykonania w Planie operacyjnym.'
      || _msg+=' Przyczyna nieznana.'
      ?};
      KOMM.error(_msg,0,1)
   ?};

   {? _can_continue>0
   ||
::    1. Usuwanie PL_OZow
      PL_OZ.index('PL_OPER');
      PL_OZ.prefix(PL_OPER.ref());
      {? PL_OZ.first()
      || {!
         |? _pl_res:=PL_OZ.PL_RES;
            _can_continue:=exec('del_ploz','po_plan',$PL_OZ.ref(),_zdarzenia_upd,_view_upr,_force);
            _can_continue>0 & PL_OZ.first()
         !}
      ?}
   ?};
   {? _can_continue>0
   ||
::    2. Usuwanie PL_NEXT (ta operacja)
      PL_NEXT.index('PL_OPER');
      PL_NEXT.prefix(PL_OPER.ref());
      {? PL_NEXT.first()
      || {!
         |? _can_continue:=exec('del_plnext','po_plan',$PL_NEXT.ref());
            _can_continue>0 & PL_NEXT.first()
         !}
      ?}
   ?};
   {? _can_continue>0
   ||
::    3. Usuwanie PL_NEXT (do tej operacji)
      PL_NEXT.index('NEXT');
      PL_NEXT.prefix(PL_OPER.ref());
      {? PL_NEXT.first()
      || {!
         |? _can_continue:=exec('del_plnext','po_plan',$PL_NEXT.ref());
            _can_continue>0 & PL_NEXT.first()
         !}
      ?}
   ?};
   {? _can_continue>0
   ||
::    4. Usuwanie powiązań ze PL_SPLITami
      PL_SPLIT.cntx_psh();
      PL_SPLIT.index('PL_OPER');
      PL_SPLIT.prefix(PL_OPER.ref());
      {? PL_SPLIT.first()
      || {!
         |? PL_SPLIT.cntx_psh();
            PL_SPLIT.clear();
            PL_SPLIT.PL_OPER:=null();
            _can_continue:=PL_SPLIT.put();
            PL_SPLIT.cntx_pop();
            PL_SPLIT.first() & _can_continue>0
         !}
      ?};
      PL_SPLIT.cntx_pop();
      ~~
   ?};
   {? _can_continue>0
   || PL_WYK.cntx_psh();
      PL_WYK.index('PL_OPER');
      PL_WYK.prefix(PL_OPER.ref());
      {? PL_WYK.first()
      || {!
         |? _can_continue:=PL_WYK.del(,1);
            PL_WYK.first() & _can_continue>0
         !}
      ?};
      PL_WYK.cntx_pop()
   ?};

   {? _can_continue>0
   ||
::    KOMM.add('@del_ploper: '+$_ploz_ok+'|'+$_plnext1+'|'+$_plnext2+'|'+$_px_ok,,,1);
::    4. Usuwanie PL_OPERA
      {? PL_OPER.del(,1)>0
      || _can_continue:=1
      || _can_continue:=0
      ?}
   ?}
?};
{? _can_continue>0
|| {? _plpart<>null()
   || {? PL_PART.seek(_plpart)
      ||
         _zl:=PL_PART.ZL;
         _zgh:=PL_PART.ZGH;
         {? _del_plpart>0
         ||
            PL_OPER.cntx_psh();
            PL_OPER.index('PL_PART');
            PL_OPER.prefix(PL_PART.ref());
            {? PL_OPER.size()=0
            || exec('del_plpart','po_plan',$PL_PART.ref())
            ?};
            PL_OPER.cntx_pop()
         ?};
         {? _plpart_upd>0
         || exec('plpart_date_upd','po_plan',_plpart)
         ?};
         {? ZL.seek(_zl)
         || exec('zl_dates_update','po_plan',ZL.ref())
         ?};
         {? ZGH.seek(_zgh)
         || exec('zgh_dates_upd','po_plan',PL_PART.ref())
         ?}
      ?}
   ?};
   {? _zgp<>null()
   || {? ZGP.seek(_zgp)
      || exec('zgp_dates_reset','po_plan',ZGP.ref())
      ?}
   ?}
?};
PL_OPER.cntx_pop();
PL_OZ.cntx_pop();
PL_NEXT.cntx_pop();
PL_PART.cntx_pop();
ZL.cntx_pop();
ZGH.cntx_pop();
ZGP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\zam_tech
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zwraca technologię wg której zostało zaplanowane zamówienie
::   WE: _a - $ZK_P.ref() - SQL ref pozycji zamówienia
::   WY: TKTL.ref() lub null()
::  OLD: \zam_tech/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zkp:='';
{? _>0
|| _zkp:=_a
?};

_result:=null();

ZK_P.cntx_psh();
ZK_P.clear();
PL_PART.cntx_psh();
PL_PART.index('ZK_P');
{? ZK_P.seek(_zkp)
|| PL_PART.prefix(ZK_P.ref());
   {? PL_PART.first()
   || _result:=PL_PART.TKTL
   ?}
?};

PL_PART.cntx_pop();
ZK_P.cntx_pop();
_result


\zam2zlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Przeksztalca plan zamowienia w plan zlecenia
::   WE: _a - $ZK_P.ref() - SQL ref pozycji zamowienia z ktorego plan przerabiam
::       _b - $ZL.ref() - SQL ref zlecenia do ktorego plan przepinam
::   WY: 0 / 1 - sukces czy porazka
::  OLD: \zam2zlec/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zkp:='';
_zl:='';
_result:=0;

{? _>0
|| _zkp:=_a
?};
{? _>1
|| _zl:=_b
?};

ZK_P.cntx_psh();
ZL.cntx_psh();
PL_PART.cntx_psh();
PL_PART.index('ZK_P');
PL_PART.clear();
ZK_P.clear();
ZL.clear();
{? ZK_P.seek(_zkp,8+_zkp)
|| PL_PART.prefix(ZK_P.ref());
   {? PL_PART.first()
   || {? ZL.seek(_zl,8+_zl)
      || {!
         |? PL_PART.cntx_psh();
            PL_PART.clear();
            PL_PART.ZL:=ZL.ref();
            PL_PART.ZKTL:=ZL.KTLZ;

::          Zostawiam plpartowi zlaczenie do ZK_P po to aby nie planowac ponownie ZK_P
::          PL_PART.ZK_P:=null();
            PL_PART.TKTL:=null();
            _result:=PL_PART.put();

            {? _result>0
            || exec('ploper_sym_upd','po_plan',PL_PART.ref())
            ?};

            PL_PART.cntx_pop();
            PL_PART.next() & _result>0
         !}
      ?}
   ?}
?};
PL_PART.cntx_pop();
ZL.cntx_pop();
ZK_P.cntx_pop();
_result


\ploper_sym_upd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Aktualizuje opisy pl_operow na podstawie tego do czego jest podpiety pl_part - priorytet maja zlecenia
::       UWAGA!   Plopery maja opis generowany rowniez od strony javy, po to aby go bylo widac podczas symulacji kiedy
::                nie ma jeszcze plopera w bazie, wiec jesli tutaj zostanie zmieniony sposob generowania opisu
::                nalezy go w ten sam sposob zmienic w javie w PloperPlanningTools.createPloper(...)
::   WE: _a - PL_PART.ref() - przewodnik planistyczny zawierajacy plopery
::   WY: 0 / 1 - sukces czy porazka
::  OLD: \ploper_sym_upd/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_plpart:=null();
_result:=0;
{? _>0
|| _plpart:=_a
?};
::konteksty
PL_PART.cntx_psh();
PL_OPER.cntx_psh();

PL_PART.clear();
PL_OPER.clear();
PL_OPER.index('PL_PART');
{? PL_PART.seek(_plpart)
|| PL_OPER.prefix(PL_PART.ref());
   {? PL_OPER.first()
   || {!
      |? _sym:=exec('get_ploper_sym','po_plan');
         PL_OPER.SYMBOL:=_sym;
         _result:=PL_OPER.put();
::       gdyby w formule byly zmiany dat lub tm_stamp'ow, to nalezy odkomentowac ponizsza formule
::         exec('ploz_tm_update','pl_okr3',PL_OPER.ref());
         _result & PL_OPER.next()
      !}
   ?}
?};
PL_OPER.cntx_pop();
PL_PART.cntx_pop();
_result


\get_ploper_sym
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Zwraca symbol dla przekazanego plopera
::   WE: [_a] - PL_OPER.ref lub bieżący rekord
::   WY: STRING - symbol plopera
::  TAG: <PUBLICZNA>
::  OLD: \get_ploper_sym/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_sym:='';
_can_continue:=1;

PL_OPER.cntx_psh();
ZK_P.cntx_psh();
ZK_N.cntx_psh();
ZL.cntx_psh();
ZGH.cntx_psh();

{? _ref<>null()
|| PL_OPER.clear();
   {? PL_OPER.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PL_PART.cntx_psh();
   PL_OPER.PL_PART();
   {? PL_PART.ZK_P<>null()
   ||
::    otwieram maski zamowien
      _zkp_masa:=$PL_PART.ZK_P;
      ZK_P.use(8+_zkp_masa);
      ZK_N.use(5+ZK_N.name()+(8+_zkp_masa+3));
      ZK_P.clear();
      ZK_N.clear();
      _sym:='ZM: '+PL_PART.ZK_P().N().SYM+' '+PL_PART.NAZWA
   ?};
   {? PL_PART.ZL<>null()
   || {? PL_PART.ZGH<>null()
      || _sym:='ZL: '+PL_PART.ZGH().NRPRZ
      || _sym:='ZL: '+PL_PART.ZL().SYM+' '+PL_PART.NAZWA
      ?}
   ?};
:: na razie pl_part powinien miec przypisanie, ale to na przyszlosc gdyby byla mozliwosc generowania pl_partow recznie
   {? _sym=''
   || _sym:='Brak powiązań'
   ?};
   PL_PART.cntx_pop()
?};
ZK_P.cntx_pop();
ZK_N.cntx_pop();
ZGH.cntx_pop();
ZL.cntx_pop();
PL_OPER.cntx_pop();
_sym


\plres_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Dodaje do tabeli PL_RES rekord
::   WE: _a: PL_RES.TYP - STRING[1]
::       _b: PL_RES.REF - STRING[16]
::       _c: PL_RES.SYM - STRING[20]
::       _d: PL_RES.NAZ - STRING[40]
::       _e: PL_RES.KAL_NAZW - KAL_NAZW.ref()
::       _f: PL_RES.WYD - STRING[10] - symbol wydzialu
::       [_g]: PL_RES.PARALLEL - STRING[1]
::   WY: 0 / 1 - sukces :) lub calkowita porazka :(
::  OLD: \plres_add/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
:: sprawdzanie argumentow
_typ:='';
_ref:='';
_sym:='';
_naz:='';
_kal_nazw:=null();
_wyd:='';
{? _=0
|| return(0)
?};
{? _>0
|| _typ:=_a
?};
{? _>1
|| _ref:=_b
?};
{? _>2
|| _sym:=_c
?};
{? _>3
|| _naz:=_d
?};
{? _>4
|| _kal_nazw:=_e
?};
{? _>5
|| _wyd:=_f
?};
_parallel:='0';
{? var_pres('_g')=type_of('')
|| _parallel:=_g
?};
:: dodawanie rekordu
PL_RES.clear();
PL_RES.blank();
PL_RES.TYP:=_typ;
PL_RES.REF:=_ref;
PL_RES.SYM:=_sym;
PL_RES.NAZ:=_naz;
PL_RES.KAL_NAZW:=_kal_nazw;
PL_RES.WYD:=_wyd;
PL_RES.PARALLEL:=_parallel;

:: ustawiam pola zrodlowe
:: stanowisko produkcyjne
{? _typ='S'
|| TWRKPLC.cntx_psh();
   TWRKPLC.clear();
   {? TWRKPLC.seek(PL_RES.REF)
   || PL_RES.FROM_STA:=TWRKPLC.ref()
   ?};
   TWRKPLC.cntx_pop()
?};
:: gniazdo produkcyjne
{? _typ='G'
|| TWRKZBR.cntx_psh();
   TWRKZBR.clear();
   {? TWRKZBR.seek(PL_RES.REF)
   || PL_RES.FROM_GNI:=TWRKZBR.ref()
   ?};
   TWRKZBR.cntx_pop()
?};
:: brygada pracownicza
{? _typ='B'
|| ZLBR.cntx_psh();
   ZLBR.clear();
   {? ZLBR.seek(PL_RES.REF)
   || PL_RES.FROM_BRY:=ZLBR.ref()
   ?};
   ZLBR.cntx_pop()
?};
:: pracownik
{? _typ='P'
|| P.cntx_psh();
   P.clear();
   {? P.seek(PL_RES.REF)
   || PL_RES.FROM_PRA:=P.ref()
   ?};
   P.cntx_pop()
?};
:: wydzial
{? _typ='W'
|| UD_SKL.cntx_psh();
   UD_SKL.clear();
   {? UD_SKL.seek(PL_RES.REF)
   || PL_RES.FROM_WYD:=UD_SKL.ref()
   ?};
   UD_SKL.cntx_pop()
?};
_ok:=PL_RES.add();
_ok


\get_kal_nazwa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Zwraca tekstowa nazwe kalendarza lub ...................... jesli kalendarz czastkowy
::   WE: _a - SQL Ref zasobu
::       _b - Typ zasobu - B,L,P,G,S,W
::   WY: [1] STRING - Nazwa kalendarza
::       [2] STRING[16] - Ref kalendarza
::  OLD: \get_kal_nazwa/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_kal:=obj_new(2); _kal[1]:=''; _kal[2]:='';
_ref:='';
_typ:='';
{? _>0
|| _ref:=_a
?};
{? _>1
|| _typ:=_b
?};
:: stanowisko produkcyjne
{? _typ='S'
|| TWRKPLC.cntx_psh();
   TWRKPLC.clear();
   {? TWRKPLC.seek(_ref)
   || {? TWRKPLC.KAL().CZESC='N' & TWRKPLC.KAL().GRAFIK='N'
      || _kal[1]:=TWRKPLC.KAL().NAZWA;
         _kal[2]:=$TWRKPLC.KAL
      || _kal[1]:='........................................................';
         _kal[2]:=$TWRKPLC.KAL
      ?}
   ?};
   TWRKPLC.cntx_pop()
?};
:: gniazdo produkcyjne
{? _typ='G'
|| TWRKZBR.cntx_psh();
   TWRKZBR.clear();
   {? TWRKZBR.seek(_ref)
   || {? TWRKZBR.KAL().CZESC='N' & TWRKZBR.KAL().GRAFIK='N'
      || _kal[1]:=TWRKZBR.KAL().NAZWA;
         _kal[2]:=$TWRKZBR.KAL
      || _kal[1]:='........................................................';
         _kal[2]:=$TWRKZBR.KAL
      ?}
   ?};
   TWRKZBR.cntx_pop()
?};
:: brygada pracownicza
{? _typ='B'
|| ZLBR.cntx_psh();
   ZLBR.clear();
   {? ZLBR.seek(_ref)
   || {? ZLBR.KAL().CZESC='N' & ZLBR.KAL().GRAFIK='N'
      || _kal[1]:=ZLBR.KAL().NAZWA;
         _kal[2]:=$ZLBR.KAL
      || _kal[1]:='........................................................';
         _kal[2]:=$ZLBR.KAL
      ?}
   ?};
   ZLBR.cntx_pop()
?};
:: pracownik
{? _typ='P'
|| P.cntx_psh();
   P.clear();
   {? P.seek(_ref)
   || {? P.KAL().CZESC='N' & P.KAL().GRAFIK='N'
      || _kal[1]:=P.KAL().NAZWA;
         _kal[2]:=$P.KAL
      || _kal[1]:='........................................................';
         _kal[2]:=$P.KAL
      ?}
   ?};
   P.cntx_pop()
?};
:: wydzial
{? _typ='W'
|| UD_SKL.cntx_psh();
   UD_SKL.clear();
   {? UD_SKL.seek(_ref)
   || KAL_UD.index('RESORWYD');
      KAL_UD.prefix(UD_SKL.ref(),'W');
      {? KAL_UD.first()
      || {? KAL_UD.KAL().CZESC='N' & KAL_UD.KAL().GRAFIK='N'
         || _kal[1]:=KAL_UD.KAL().NAZWA;
            _kal[2]:=$KAL_UD.KAL
         || _kal[1]:='........................................................';
            _kal[2]:=$KAL_UD.KAL
         ?}
      || _kal[1]:='';
         _kal[2]:=''
      ?}
   ?};
   UD_SKL.cntx_pop()
?};
_kal


\ikona_res
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Ikona zasobu
::   WE: _a - typ zasobu
::  OLD: \ikona_res/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a='S' || _nr:=158
|? _a='G' || _nr:=72
|? _a='B' || _nr:=31
|? _a='P' || _nr:=100
|? _a='W' || _nr:=91
|? _a=''  || _nr:=76
          || _nr:=110
?}


\rule4kaldef
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Zwraca rekord tabeli KAL_DEF z podanego kalendarza i o podanej dacie (uwglednia kalendarze czastkowe)
::   WE: _a - KAL_NAZW.ref()
::       _b - REAL - tm_start
::       _c - REAL - tm_end
::       _d - FORMULA - formula do wykonania dla kazdego kal_defa - musi zwracac wynik 0/1. Jesli zwroci 0 przetwarzanie
::                      zostaje przerwane
::       [_e] - INTEGER - 0/1: [0] - wykonuj formule rowniez dla tych kal_defow ktore trwaja w momencie _tm_start
::                              1 - nie wykonuj formuly dla kal_defow ktore trwaja w momencie _tm_start
::       [_f] - obj_new - tablica nazwana - argumenty dla formuly
::       [_g] - ref_table - tablica refow odwiedzonych kalendarzy
::  WY: 0 - ktoras z formul zwrocila wynik 0
::      1 - wszystkie wykonane formuly zwrocily wynik wiekszy od 0
::  OLD: \rule4kaldef/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? _<2
|| return()
?};
_kal_nazw:=_a;
_tm_start:=_b;
_tm_end:=_c;
_rule:=_d;
_mode_start:=0;

{? var_pres('_e')=type_of(0)
|| _mode_start:=_e
?};

_args:=~~;
{? var_pres('_f')>0
|| _args:=_f
?};

{? var_pres('_g')>100
|| _ref_table:=_g
|| _ref_table:=exec('ref_table','#table')
?};

_result:=0;

_can_continue:=1;

_int_view:=exec('interval','#interval');
_int_view.START:=_tm_start;
_int_view.END:=_tm_end;

KAL_DEF.cntx_psh();
R_WZCZ.cntx_psh();
KAL_NAZW.cntx_psh(); KAL_NAZW.clear();
{? KAL_NAZW.seek(_kal_nazw)
||

:: jesli kalendarz jest czastkowy to trzeba siegnac do tabeli R_WZCZ gdzie bedzie przekierowanie na odpowiedni kalendarz
   {? KAL_NAZW.CZESC='T' & _ref_table.r_find(KAL_NAZW.ref())=0
   ||
      _ref_table.add(KAL_NAZW.ref());
      R_WZCZ.index('R_WZCZE');
      R_WZCZ.prefix(KAL_NAZW.ref());

      _day_od:=exec('tm_stamp2date','#tm_stamp',_tm_start);
      _day_do:=exec('tm_stamp2date','#tm_stamp',_tm_end);
::    szukam rekordu R_WZCZ ktory ma w polu OD date wieksza lub rowna niz ta ktorej poszukuje (ten rekord da mi wskazanie
::    na kalendarz obowiazujacy w szukanym dniu
      {? R_WZCZ.find_le(_day_od)
      ||
         {? R_WZCZ.OD<_day_do
         ||
            {!
            |?
               _next_change:=date(0,0,0);
               R_WZCZ.cntx_psh();
               {? R_WZCZ.next()
               || _next_change:=R_WZCZ.OD
               ?};
               R_WZCZ.cntx_pop();

               _r_start:=exec('create','#tm_stamp',R_WZCZ.OD,time(0,0,0));

               {? _next_change>date(0,0,0)
               || _r_end:=exec('create','#tm_stamp',_next_change,time(0,0,0))
               || _r_end:=_tm_end
               ?};

::             uruchamiam funkcje rekurencyjnie, ale tym razem jako parametr okreslajacy kalendarz podaje kalendarz ktory nie powinien
::             byc juz czastkowy
               _mode_rec:=1;
               {? _tm_start>=_r_start & _tm_end<=_r_end
               || _mode_rec:=0
               ?};
               _rek_start:=exec('max','#math',_r_start,_tm_start);
               _rek_end:=exec('min','#math',_r_end,_tm_end);
               _can_continue:=exec('rule4kaldef','po_plan',R_WZCZ.KAL,_rek_start,_rek_end,_rule,_mode_rec,_args,_ref_table);
               _can_continue>0 & R_WZCZ.next() & R_WZCZ.OD<_day_do
            !}
         ?}
      ?}
   ||
      {? _mode_start=0
      ||
         KAL_DEF.index('TM_END');
         KAL_DEF.prefix(KAL_NAZW.ref());
         {? KAL_DEF.find_ge(_tm_start)
         || _int_rec:=exec('interval','#interval');
            {!
            |? _int_rec.START:=KAL_DEF.TM_START;
               _int_rec.END:=KAL_DEF.TM_END;
               {? exec('intervals_chk','#interval',_int_rec,_int_view)>0
               || _can_continue:=_rule(_args)
               ?};
               _can_continue>0 & KAL_DEF.next()
            !}
         ?}
      |? _mode_start=1
      ||
         KAL_DEF.index('TM_START');
         KAL_DEF.prefix(KAL_NAZW.ref());
         {? KAL_DEF.find_ge(_tm_start)
         || _int_rec:=exec('interval','#interval');
            {!
            |? _int_rec.START:=KAL_DEF.TM_START;
               _int_rec.END:=KAL_DEF.TM_END;
               {? exec('intervals_chk','#interval',_int_rec,_int_view)>0
               || _can_continue:=_rule(_args)
               ?};
               _can_continue>0 & KAL_DEF.next()
            !}
         ?}
      ?}
   ?}
?};

{? _can_continue>0
|| _result:=1
?};

KAL_NAZW.cntx_pop();
R_WZCZ.cntx_pop();
KAL_DEF.cntx_pop();
_result


\zl_dates_reset
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Usuwa daty ze zlecenia
::   WE: _a - ZL.ref()
::  OLD: \zl_dates_reset/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| return()
?};
_zl_ref:=_a;

_can_continue:=1;

ZL.cntx_psh();
{? ZL.seek(_zl_ref)
|| ZL.STARTD:=date(0,0,0);
   ZL.STARTT:=time(0,0,0);
   ZL.ENDD:=date(0,0,0);
   ZL.ENDT:=time(0,0,0);
   _can_continue:=ZL.put();

   {? _can_continue>0
   ||
::    Sprawdzam czy zlecenie ma nadrzedne
      _top:=exec('top_level','zl_link',ZL.ref());

      {? _top<>ZL.ref()
      || exec('zl_dates_nad','po_plan',_top)
      ?}
   ?}
?};
ZL.cntx_pop();
~~


\zgh_dates_reset
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Usuwa daty z naglowka przewodnika
::   WE: _a - ZGH.ref()
::  OLD: \zgh_dates_reset/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| return()
?};
_zgh_ref:=_a;
ZGH.cntx_psh();
{? ZGH.seek(_zgh_ref)
|| ZGH.STARTD:=date(0,0,0);
   ZGH.STARTT:=time(0,0,0);
   ZGH.ENDD:=date(0,0,0);
   ZGH.ENDT:=time(0,0,0);
   ZGH.put()
?};
ZGH.cntx_pop();
~~


\zgp_dates_reset
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Usuwa daty z pozycji przewodnika
::   WE: _a - ZGP.ref()
::  OLD: \zgp_dates_reset/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| return()
?};
_zgp_ref:=_a;
ZGP.cntx_psh();
ZGP.clear();
{? ZGP.seek(_zgp_ref)
|| ZGP.STARTD:=date(0,0,0);
   ZGP.STARTT:=time(0,0,0);
   ZGP.ENDD:=date(0,0,0);
   ZGP.ENDT:=time(0,0,0);
   {? ZGP.put()
   || exec('zlim_dates_upd','zl_limit',ZGP.ref())
   ?}
?};
ZGP.cntx_pop();
~~


\plres_cmplx
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy podany PL_RES jest plresem grupujacym tzn gniazdem, linia, badz brygada
::   WE: _a - PL_RES.ref()
::   WY: 0 - zasob nie jest zasobem zlozonym
::       1 - zasob jest zasobem zlozonym
::  OLD: \plres_cmplx/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_plres:=_a;

_result:=0;

PL_RES.cntx_psh();
PL_RES.clear();
{? PL_RES.seek(_plres)
|| {? PL_RES.FROM_BRY<>null() | PL_RES.FROM_GNI<>null() | PL_RES.FROM_LIN<>null() | PL_RES.FROM_WYD<>null()
   || _result:=1
   ?}
?};
PL_RES.cntx_pop();
_result


\count_zlec_pod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Zlicza ile zlecen podrzednych ma podane w argumencie zlecenie
::   WE: _a - $ZL.ref()
::   WY: INTEGER - ilosc zlecen podrzednych
::  OLD: \count_zlec_pod/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| return(0)
?};
_ref:=_a;
_result:=0;
ZL.cntx_psh();
ZL.clear();
ZL.index('NRNZL');
{? ZL.seek(_ref)
|| ZL.prefix(ZL.UNRZL);
   _result:=ZL.size()
?};
ZL.cntx_pop();
_result


\interzlec_conns
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Dla zlecenia podrzednego lub nadrzednego sprawdza czy posiada wygenerowane
::       powiazania miedzyzleceniowe
::   WE: _a - $ZL.ref - Ref SQL zlecenia
::       [_b] - ZL.ref - top_level - zlecenie na samej górze (optymalizacja)
::   WY: 'N' - brak powiazan miedzyzleceniowych
::       'T' - sa powiazania miedzyzleceniowe
::  OLD: \interzlec_conns/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_top_level:=null;
{? var_pres('_b')=type_of(ZL.ref())
|| _top_level:=_b
?};

_result:='N';

ZL.cntx_psh(); ZL.clear();
{? ZL.seek(_zl)
||
   _result:=ZL.INTERZL;
:: Znajduje zlecenie na samej gorze
   {? _top_level=null()
   || _top_level:=exec('top_level','zl_link',ZL.ref())
   ?};

   {? ZL.seek(_top_level)
   || _result:=ZL.INTERZL
   ?}
?};
ZL.cntx_pop();
_result


\interzlec_zl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Dla zlecenia podrzednego iteruje po przewodnikach i sprawdza czy posiadaja powiazania miedzyzleceniowe
::   WE: _a - ZL.ref() - zlecenie proste
::       [_b] - tab_tmp - tabelka tymczasowa do optymalizacji
::   WY: 'N' - brak powiazan miedzyzleceniowych
::       'T' - sa powiazania miedzyzleceniowe
::  OLD: \interzlec_zl/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

{? var_pres('_b')>100
|| _tab:=_b
|| _tab:=exec('interzlec_tab','po_plan')
?};

_result:='N';
_can_continue:=1;

ZL.cntx_psh();
ZGH.cntx_psh();
ZGH.index('ZLNR');
ZGP.cntx_psh();
ZGP.index('PNRPP');
NASZGP.cntx_psh();
NASZGP.index('OPNAST');

_tab.prefix($_zl);
{? _tab.first()
|| _result:=_tab.RESULT
|| _tab.blank();
   _tab.ZL:=$_zl;
   _tab.RESULT:='N';
   ZGH.prefix(_zl);
   {? ZGH.first()
   || {!
      |?
::    Iteruje po pozycjach przewodnika
         ZGP.prefix(ZGH.ref(),'N');
         {? ZGP.first()
         || {!
            |?
::          Iteruje po nastepnikach
               NASZGP.prefix(ZGP.ref());
               {? NASZGP.first()
               || {!
                  |?
::                Jezeli nastepnik ma zlaczenia do zlecen nie puste
::                oraz wskazuja one na rozne zlecenia to znak ze jest powiazanie miedzyzleceniowe
                     {? NASZGP.ZLNAST<>null() & NASZGP.KTL<>null()
                     || {? NASZGP.ZLNAST<>NASZGP.KTL
                        || _can_continue:=0;
                           _result:='T';
                           _tab.RESULT:='T'
                        ?}
                     ?};
                     NASZGP.next() & _can_continue>0
                  !}
               ?};
               ZGP.next() & _can_continue>0
            !}
         ?};
         ZGH.next() & _can_continue>0
      !}
   ?};
   _tab.add()
?};
NASZGP.cntx_pop();
ZGP.cntx_pop();
ZGH.cntx_pop();
ZL.cntx_pop();
_result


\interzlec_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tabelka zawierająca zlecenia juz przeanalizowane pod względem powiązań między zleceniowych
::       Do optymalizacji
::   WY: tab_tmp()
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(1,
:: 'POLE','TYP','Nazwa w oknie',
   'ZL','STRING[16]','SQL Ref zlecenia',
   'RESULT','STRING[1]','Czy ma połączenia'
);
_tab


\count_plparts
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Zlicza ile plpartow ma zamowienie\zlecenie
::   WE: _a - 'ZM' \ 'ZL'
::       _b - Ref SQL zamowienia lub zlecenia
::   WY: INTEGER - ilosc plpartow
::  OLD: \count_plparts/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
{? _<2
|| return(0)
?};
_typ:=_a;
_ref_z:=_b;
PL_PART.cntx_psh();
{? _typ='ZM'
|| ZK_P.cntx_psh();
   ZK_P.clear();
   {? ZK_P.seek(_ref_z)
   || PL_PART.index('ZK_P');
      PL_PART.prefix(ZK_P.ref());
      _result:=PL_PART.size()
   ?};
   ZK_P.cntx_pop()
?};
{? _typ='ZL'
|| ZL.cntx_psh();
   ZL.clear();
   {? ZL.seek(_ref_z)
   || PL_PART.index('ZL');
      PL_PART.prefix(ZL.ref());
      _result:=PL_PART.size()
   ?};
   ZL.cntx_pop()
?};
{? _typ='ZGH'
|| ZGH.cntx_psh();
   ZGH.clear();
   {? ZGH.seek(_ref_z)
   || PL_PART.index('ZGH');
      PL_PART.prefix(ZGH.ref());
      _result:=PL_PART.size()
   ?};
   ZGH.cntx_pop()
?};
PL_PART.cntx_pop();
_result


\tm_start_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zwraca tm_stamp poczatku planu zlecenia (poczatek pierwszej operacji)
::   WE: _a - $ZL.ref() - SQL ref zlecenia
::   WY: NUMBER - data i czas startu w formacie tm_stamp
::  OLD: \tm_start_zl/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_zlec:='';
{? _>0
|| _zlec:=_a
?};

ZL.cntx_psh();
ZL.clear();
PL_PART.cntx_psh();
PL_PART.index('ZL');
PL_PART.clear();
_zl_ref:=BIT.sqlint(_zlec);
{? ZL.seek(_zl_ref,)
||
:: sprawdzam czy zlecenie ma podzlecenia, jesli tak to obliczam czas planu z podzlecen
   ZL.cntx_psh();
   ZL.index('NRNZL');
   ZL.prefix(ZL.UNRZL);
   {? ZL.first()
   || {!
      |?
::       rekurencja!!!
         _zlec_start:=exec('tm_start_zl','po_plan',$ZL.ref());
         {? _result=0 | (_zlec_start>0 & _zlec_start<_result)
         || _result:=_zlec_start
         ?};
         ZL.next()
      !}
   || PL_PART.prefix(_zl_ref);
::    jade po plpartach i sprawdzam ktory sie najwczesjniej zaczyna
      {? PL_PART.first()
      || {!
         |? _plpart_start:=exec('tm_start_plpart','po_plan',$PL_PART.ref());
            {? _result=0 | (_plpart_start>0 & _plpart_start<_result)
            || _result:=_plpart_start
            ?};
            PL_PART.next()
         !}
      ?}
   ?};
   ZL.cntx_pop()
?};
PL_PART.cntx_pop();
ZL.cntx_pop();
_result


\tm_end_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zwraca tm_stamp konca planu zlecenia (koniec ostatniej operacji)
::   WE: _a - $ZL.ref() - SQL ref zlecenia
::   WY: NUMBER - data i czas startu w formacie tm_stamp
::  OLD: \tm_end_zl/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_zlec:='';
{? _>0
|| _zlec:=_a
?};

ZL.cntx_psh();
ZL.clear();
PL_PART.cntx_psh();
PL_PART.index('ZL');
PL_PART.clear();
_zl_ref:=BIT.sqlint(_zlec);
{? ZL.seek(_zl_ref,)
||
:: sprawdzam czy zlecenie ma podzlecenia, jesli tak to obliczam czas planu z podzlecen
   ZL.cntx_psh();
   ZL.index('NRNZL');
   ZL.prefix(ZL.UNRZL);
   {? ZL.first()
   || {!
      |?
::       rekurencja!!!
         _zlec_end:=exec('tm_end_zl','po_plan',$ZL.ref());
         {? _result=0 | _zlec_end>_result
         || _result:=_zlec_end
         ?};
         ZL.next()
      !}
   || PL_PART.prefix(_zl_ref);
::    jade po plpartach i sprawdzam ktory sie najwczesjniej zaczyna
      {? PL_PART.first()
      || {!
         |? _plpart_end:=exec('tm_end_plpart','po_plan',$PL_PART.ref());
            {? _plpart_end>0 & _plpart_end>_result
            || _result:=_plpart_end
            ?};
            PL_PART.next()
         !}
      ?}
   ?};
   ZL.cntx_pop()
?};
PL_PART.cntx_pop();
ZL.cntx_pop();
_result


\tm_start_zkp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zwraca tm_stamp poczatku planu zamowienia (poczatek pierwszej operacji)
::   WE: _a - $ZK_P.ref() - SQL ref zamowienia
::   WY: NUMBER - data i czas startu w formacie tm_stamp
::  OLD: \tm_start_zkp/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_zkp:='';
{? _>0
|| _zkp:=_a
?};

ZK_P.cntx_psh();
ZK_P.clear();
PL_PART.cntx_psh();
PL_PART.index('ZK_P');
PL_PART.clear();
{? ZK_P.seek(_zkp,8+_zkp)
|| PL_PART.prefix(ZK_P.ref());
:: jade po plpartach i sprawdzam ktory sie najwczesjniej zaczyna
   {? PL_PART.first()
   || {!
      |? _plpart_start:=tm_stamp(   PL_PART.STARTD~1,
                                    PL_PART.STARTD~2,
                                    PL_PART.STARTD~3,
                                    PL_PART.STARTT~1,
                                    PL_PART.STARTT~2,
                                    PL_PART.STARTT~3,
                                    0);
         {? _result=0 | (_plpart_start>0 & _plpart_start<_result)
         || _result:=_plpart_start
         ?};
         PL_PART.next()
      !}
   ?}
?};
PL_PART.cntx_pop();
ZK_P.cntx_pop();
_result


\tm_end_zkp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zwraca tm_stamp konca planu zamowienia (koniec ostatniej operacji)
::   WE: _a - $ZK_P.ref() - SQL ref zamowienia
::   WY: NUMBER - data i czas startu w formacie tm_stamp
::  OLD: \tm_end_zkp/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_zkp:='';
{? _>0
|| _zkp:=_a
?};

ZK_P.cntx_psh();
ZK_P.clear();
PL_PART.cntx_psh();
PL_PART.index('ZK_P');
PL_PART.clear();
{? ZK_P.seek(_zkp,8+_zkp)
|| PL_PART.prefix(ZK_P.ref());
:: jade po plpartach i sprawdzam ktory sie najpozniej konczy
   {? PL_PART.first()
   || {!
      |? _plpart_end:=tm_stamp(     PL_PART.ENDD~1,
                                    PL_PART.ENDD~2,
                                    PL_PART.ENDD~3,
                                    PL_PART.ENDT~1,
                                    PL_PART.ENDT~2,
                                    PL_PART.ENDT~3,
                                    0);
         {? _plpart_end>0 & _plpart_end>_result
         || _result:=_plpart_end
         ?};
         PL_PART.next()
      !}
   ?}
?};
PL_PART.cntx_pop();
ZK_P.cntx_pop();
_result


\tm_start_zkn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zwraca tm_stamp poczatku planu zamowienia (poczatek pierwszej operacji)
::   WE: _a - $ZK_N.ref() - SQL ref zamowienia
::   WY: NUMBER - data i czas startu w formacie tm_stamp
::  OLD: \tm_start_zkn/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_zkn:='';
{? _>0
|| _zkn:=_a
?};

ZK_N.cntx_psh();
ZK_N.clear();
ZK_P.cntx_psh();
ZK_P.index('NAG');
ZK_P.clear();

{? ZK_N.seek(_zkn)
|| ZK_P.prefix(ZK_N.ref());
   {? ZK_P.first()
   || {!
      |? _zkp_plan:=exec('tm_start_zkp','po_plan',$ZK_P.ref());
         {? _result=0 | (_zkp_plan>0 & _zkp_plan<_result)
         || _result:=_zkp_plan
         ?};
         ZK_P.next()
      !}
   ?}
?};
ZK_N.cntx_pop();
ZK_P.cntx_pop();
_result


\tm_end_zkn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zwraca tm_stamp konca planu zamowienia (koniec ostatniej operacji)
::   WE: _a - $ZK_P.ref() - SQL ref zamowienia
::   WY: NUMBER - data i czas startu w formacie tm_stamp
::  OLD: \tm_end_zkn/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_zkn:='';
{? _>0
|| _zkn:=_a
?};

ZK_N.cntx_psh();
ZK_N.clear();
ZK_P.cntx_psh();
ZK_P.index('NAG');
ZK_P.clear();

{? ZK_N.seek(_zkn)
|| ZK_P.prefix(ZK_N.ref());
   {? ZK_P.first()
   || {!
      |? _zkp_plan:=exec('tm_end_zkp','po_plan',$ZK_P.ref());
         {? _zkp_plan>0 & _zkp_plan>_result
         || _result:=_zkp_plan
         ?};
         ZK_P.next()
      !}
   ?}
?};
ZK_N.cntx_pop();
ZK_P.cntx_pop();
_result


\tm_start_plpart
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zwraca tm_stamp poczatku plparta (poczatek piewszej operacji)
::   WE: _a - $PL_PART.ref() - SQL ref plparta
::   WY: NUMBER - data i czas startu w formacie tm_stamp
::  OLD: \tm_start_plpart/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_plpart:=null();
{? _>0
|| _plpart:=_a
?};
PL_PART.cntx_psh();
PL_PART.clear();

{? PL_PART.seek(_plpart)
|| _result:=PL_PART.TM_START
?};
PL_PART.cntx_pop();
_result


\tm_end_plpart
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zwraca tm_stamp konca plparta (koniec ostatniej operacji)
::   WE: _a - $PL_PART.ref() - SQL ref plparta
::   WY: NUMBER - data i czas konca w formacie tm_stamp
::  OLD: \tm_end_plpart/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_plpart:=null();
{? _>0
|| _plpart:=_a
?};
PL_PART.cntx_psh();
PL_PART.clear();
{? PL_PART.seek(_plpart)
|| _result:=PL_PART.TM_END
?};
PL_PART.cntx_pop();
_result


\pl_res_typ_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Wartosc domyslna pola tabeli PL_RES.TYP
::   WY: 'L'
::  OLD: \pl_res_typ_bl/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
'L'


\pl_res_sym_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Formula na F3 pola tabeli PL_RES.SYM
::  OLD: \pl_res_sym_f3/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\plres_sym_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Po redakcji pola PL_RES.SYM
::  OLD: \plres_sym_ae/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
win_disp();
~~


\plres_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Przed wyswietleniem pola PL_RES.KAL_NAZW
::   WY: 0 / 1
::  OLD: \plres_bd/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:=~~;
{? _fld='KAL_NAZW'
|| _result:=PL_RES.KAL_NAZW().CZESC<>'T'
|? _fld='PARALLEL'
||
   {? cur_kwin()*'edit'>0 |  cur_kwin()*'disp'>0
   || exec('plres_grayed','po_plan')
   ?}
?};
_result


\plres_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Przed redagowaniem pol PL_RES.NAZ i PL_RES.KAL_NAZW
::   WY: 0 / 1
::  OLD: \plres_be/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
1


\plpart_date_upd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Uaktualnia daty na plparcie na podstawie dat ploperow nalezacych do niego
::   WE: _a - PL_PART.ref() - ref plparta
::  OLD: \plpart_date_upd/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| return()
?};
_plpart_ref:=_a;
_ok:=0;

PL_PART.cntx_psh();
PL_PART.clear();
PL_OPER.cntx_psh();
PL_OPER.clear();

_startd:=date(0,0,0);
_startt:=time(0,0,0);
_endd:=date(0,0,0);
_endt:=time(0,0,0);
{? PL_PART.seek(_plpart_ref)
|| PL_OPER.index('PL_START');
   PL_OPER.prefix(PL_PART.ref());
::------------indeks jest posortowany od najmniejszej daty i czasu startu wiec biegne od poczatku i sprawdzam czy data ustawiona
   _continue:=1;
   {? PL_OPER.first()
   || {!
      |? {? PL_OPER.STARTD>date(1970,1,1) & PL_OPER.ENDD>date(1970,1,1)
         || _startd:=PL_OPER.STARTD;
            _startt:=PL_OPER.STARTT;
            _continue:=0
         ?};
         _continue>0 & PL_OPER.next()
      !}
   ?};
::------------indeks jest posortowany od najmniejszej daty i czasu konca wiec biegne od konca i sprawdzam czy data ustawiona
   PL_OPER.index('PL_END');
   PL_OPER.prefix(PL_PART.ref());
   _continue:=1;
   {? PL_OPER.last()
   || {!
      |? {? PL_OPER.STARTD>date(1970,1,1) & PL_OPER.ENDD>date(1970,1,1)
         || _endd:=PL_OPER.ENDD;
            _endt:=PL_OPER.ENDT;
            _continue:=0
         ?};
         _continue>0 & PL_OPER.prev()
      !}
   ?};
::----------------------------------------------------------------------------------------------------------------------
   PL_PART.STARTD:=_startd;
   PL_PART.STARTT:=_startt;
   PL_PART.ENDD:=_endd;
   PL_PART.ENDT:=_endt;
   _ok:=PL_PART.put();

::uaktualniam czasy na przewodnikach i zleceniach
   {? _ok
   || exec('zgh_dates_upd','po_plan',PL_PART.ref());
      exec('zl_dates_update','po_plan',PL_PART.ZL)
   ?}
?};
PL_PART.cntx_pop();
PL_OPER.cntx_pop();
~~


\del_zlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Usuwa caly plan produkcji zlecenia
::   WE: _a - Ref SQL ZL
::       [_b] - INTEGER - [0]/1 - usuwać nawet jeżeli są wykonania
::   WY: 0 / 1
::  OLD: \del_zlec/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:='';
_result:=0;
{? _>0
|| _ref:=_a
|| return(0)
?};

_force:=0;
{? var_pres('_b')=type_of(0)
|| _force:=_b
?};

ZL.cntx_psh();
PL_PART.cntx_psh();
ZL.clear();
{? ZL.seek(_ref)
||
   _subzlec:=exec('subzlec_exist','zl_link',ZL.ref());
   {? _subzlec=0
   ||
::    ----------usuwam wszystkie plparty
      _plpart_ok:=1;
      PL_PART.index('ZL');
      PL_PART.prefix(ZL.ref());
      {? PL_PART.first()
      || {!
         |? _plpart_ok:=exec('del_plpart','po_plan',$PL_PART.ref(),_force);
            _plpart_ok>0 & PL_PART.first()
         !}
      ?};
      {? _plpart_ok>0
      || _result:=1
      || _result:=0
      ?}
   |? _subzlec>0
   ||
::    Jesli zlecenie zlozone to rekurencyjnie usuwam wszystkie podzlecenia
      ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? _result:=exec('del_zlec','po_plan',$ZL.ref());
            ZL.next() & _result>0
         !}
      ?};
      ZL.cntx_pop();
      ~~
   ?}
?};
ZL.cntx_pop();
PL_PART.cntx_pop();
_result


\get_login_line
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Zwraca numer linii od ktorej sa wpisy z logowania wstecz
::   WE: _a - nazwa systemu np. prod
::       _b - ile logowan wstecz mnie interesuje
::   WY: INT - numer linii w pliku .log od ktorej zaczynaja sie wpisy z ostatniego logowania
::  OLD: \get_login_line/pl_okr2.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| return()
?};
_wstecz:=1;
{? _>1
|| _wstecz:=_b
?};
_file_name:=_a+'.log';
_file:=fopen(_file_name,'Ur',1);
_line_nr:=0;
_login_nr:=0;
{? _file>0
||
:: tabela w ktorej trzymam wszystkie numery linii w logu z rozpoczeciem logowania
   _login_lines:=tab_tmp(1,'NR','INTEGER','Numer');
   {? _file>0
   || {! |? _line:=fread(_file);_line<>'\n'
      |! {? _line*'LOGIN'>0
         || _login_lines.NR:=_line_nr;
            _login_lines.add()
         ?};
         _line_nr+=1
      !}
   ?};
:: jade petelka po wszystkich numerach linii i biore ten od konca ktory mnie interesuje
   {? _login_lines.last()
   || _k:=0;
      {!
      |? _k+=1;
         _login_nr:=_login_lines.NR;
         _login_lines.prev() & _k<>_wstecz
      !}
   ?};
   fclose(_file);
   VAR_DEL.delete(_login_lines)
?};
_login_nr


\count_prevs_ope
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dla podanego PL_OPERa zlicza ilosc operacji poprzednich
::   WE: _a - PL_OPER.ref()
::   WY: INTEGER - ilosc poprzednikow
::  OLD: \count_prevs_ope/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ploper:=_a;

_result:=0;
PL_NEXT.cntx_psh();
PL_NEXT.index('NEXT');
PL_NEXT.prefix(_ploper);
_result:=PL_NEXT.size();
PL_NEXT.cntx_pop();
_result


\count_nexts_ope
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dla podanego PL_OPERa zlicza ilosc operacji nastepnych
::   WE: _a - PL_OPER.ref()
::   WY: INTEGER - ilosc nastepnikow
::  OLD: \count_nexts_ope/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ploper:=_a;

_result:=0;
PL_NEXT.cntx_psh();
PL_NEXT.index('PL_OPER');
PL_NEXT.prefix(_ploper);
_result:=PL_NEXT.size();
PL_NEXT.cntx_pop();
_result


\count_prevs_ogr
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dla podanego PL_OGRa zlicza ilosc operacji poprzednich
::   WE: _a - PL_OGR.ref()
::   WY: INTEGER - ilosc poprzednikow
::  OLD: \count_prevs_ogr/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_plogr:=_a;

_result:=0;
PL_NEXT.cntx_psh();
PL_NEXT.index('NEXT_OGR');
PL_NEXT.prefix(_plogr);
_result:=PL_NEXT.size();
PL_NEXT.cntx_pop();
_result


\count_nexts_ogr
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dla podanego PL_OGRa zlicza ilosc operacji nastepnych
::   WE: _a - PL_OGR.ref()
::   WY: INTEGER - ilosc nastepnikow
::  OLD: \count_nexts_ogr/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_plogr:=_a;

_result:=0;
PL_NEXT.cntx_psh();
PL_NEXT.index('PL_OGR');
PL_NEXT.prefix(_plogr);
_result:=PL_NEXT.size();
PL_NEXT.cntx_pop();
_result


\gettech
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Zasilenie procedury wbudowanej gettech@po_plope
::   WE: _a - :RS
::       _b - :MREF, czyli $M.ref()
::       _c - STRING - typ planowanego obiektu czyli 'ZK_P' lub 'ZL_P' (jak co innego, patrzy tylko na :MREF)
::       _d - :Z_REF, czyli $ZL.ref() lub $ZK_P.ref()
::       [_e] - INTEGER: 0 - zwracaj wszystkie technologie ; 1 - zwracaj tylko domyslna technologie
::  OLD: \gettech/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
:: nie sprawdzamy przekazanych argumentow!
_rs:=_a;
_m_ref:=_b;
_src_typ:=_c;
_z_ref:=_d;
{? _>4
|| _default:=_e
|| _default:=0
?};

TKTL.cntx_psh();
M.cntx_psh();
TKTLW.cntx_psh();
ZL.cntx_psh();
ZK_P.cntx_psh();

{? _src_typ='ZL_P'
||
:: ze zlecenia konkretna technologia, albo wlasna albo zrodlowa (TKTL)
   ZL.clear();
   {? ZL.seek(_z_ref)
   || {? ZL.TYP().TECH='T'
      || {? ZL.RTKTL<>''
         ||
::          Wymyslam maske na podstawie pola z sql_refem
            _msk:=form(8+ZL.RTKTL);

::          Otwieram maske technologii
            TKTL.use(_msk);
            TKTL.clear();
            {? TKTL.seek(ZL.RTKTL)
            ||
               _rs.REF:=$TKTL.ref();
               _rs.NRK:=TKTL.NRK;
               _rs.VER:=TKTL.WER;
               _rs.TYP:=TKTL.TYP().TYP;
               _rs.T_Z:='Z';
               _rs.USED:=exec('tech_used','po_plan','ZL',$TKTL.ref(),_z_ref);
               _rs.DEFAULT:=1;
               _rs.add()
            ?}
         ?}
      || {? ZL.RKTL<>''
         ||
            ZGH.cntx_psh();
            ZGH.index('ZLNR');
            ZGH.prefix(ZL.ref);
            {? ZGH.first()
            ||
::             Wymyslam maske na podstawie pola z sql_refem
               _msk:=form(8+ZL.RKTL);

::             Otwieram maske technologii
               TKTL.use(_msk);
               TKTL.clear();
               {? TKTL.seek(ZL.RKTL)
               ||
                  _rs.REF:=$TKTL.ref();
                  _rs.NRK:=TKTL.NRK;
                  _rs.VER:=TKTL.WER;
                  _rs.TYP:=TKTL.TYP().TYP;
                  _rs.T_Z:='T';
                  _rs.USED:=exec('tech_used','po_plan','ZL',$TKTL.ref(),_z_ref);
                  _rs.DEFAULT:=1;
                  _rs.add()
               ?}
            ||
::             Wymyslam maske na podstawie pola z sql_refem
               _msk:=form(8+ZL.RKTL);

::             Otwieram maske technologii
               TKTL.use(_msk);
               TKTL.clear();
               {? TKTL.seek(ZL.RKTL) & exec('tktl_act','tech_head',0) & TKTL.ARCH='N'
               ||
                  _rs.REF:=$TKTL.ref();
                  _rs.NRK:=TKTL.NRK;
                  _rs.VER:=TKTL.WER;
                  _rs.TYP:=TKTL.TYP().TYP;
                  _rs.T_Z:='T';
                  _rs.USED:=exec('tech_used','po_plan','ZL',$TKTL.ref(),_z_ref);
                  _rs.DEFAULT:=1;
                  _rs.add()
               ||
                  _msk:=form(5+ZL.RKTL+'___');
                  TKTL.use(_msk);
                  TKTL.clear();
                  exec('lista_tktl','po_plan',_rs,_m_ref)
               ?}
            ?};
            ZGH.cntx_pop()
         ?}
      ?}
   ?}
|? _src_typ='ZK_P'
||
:: jezeli pozycja zamowienia jest spojna z przekazanym materialem, to dalej jak dla materialu
   ZK_P.clear();
   {? ZK_P.seek(_z_ref,8+_z_ref)
   || {? $ZK_P.M=_m_ref
      || exec('lista_tktl','po_plan',_rs,_m_ref,_z_ref,_default)
      ?}
   ?}
||
:: jezeli nie zamowienie i nie zlecenie, to poprostu analiza dla materialu - kilka technologii do wyboru
   exec('lista_tktl','po_plan',_rs,_m_ref)
?};

TKTL.cntx_pop();
M.cntx_pop();
TKTLW.cntx_pop();
ZL.cntx_pop();
ZK_P.cntx_pop();
~~


\lista_tktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Lista technologii dla materialu - do formuly gettech/pl_okr3
::   WE: _a - tabela wynikowa (:RS)
::       _b - $M.ref()
::       [_c] - Ref SQL pozycji zamowienia lub zlecenia
:        [_d] - INTEGER: 0 - zwracaj wszystkie technologie ; 1 - zwracaj tylko domyslna technologie
::  OLD: \lista_tktl/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
:: nie sprawdzamy przekazanych argumentow!
_rs:=_a;
_m_ref:=_b;
_z_ref:='';
{? _>2
|| _z_ref:=_c
?};
{? _>3
|| _default:=_d
|| _default:=0
?};
TKTL.clear();

{? _m_ref<>''
|| M.clear();
   {? M.seek(_m_ref)
   || TKTLW.index('KARC');
      TKTLW.prefix();
::      TKTLW.prefix('T',M.ref(),'N');
      TKTLW.clear();
      TKTLW.f_set(,'join TKTL using (TKTLW.TKTL,TKTL.REFERENCE)'
            ,'
            TKTL.TORW=\'T\'
            and TKTLW.KTM=:_a
            and TKTL.ARCH=\'N\'
            and ((TKTL.TERM_OD<=to_date(:_b) and TKTL.TERM_OD IS NOT NULL)
            or TKTL.TERM_OD IS NULL)
            and ((TKTL.TERM_DO>=to_date(:_b) and TKTL.TERM_DO IS NOT NULL)
            or TKTL.TERM_DO IS NULL)
            '
            ,M.ref(),date());

      {? TKTLW.f_first()
      || {!
         |? {? TKTLW.TKTL().STAN='T'
            || {? _default=0 | (_default=1 & TKTLW.DEFAULT='T')
               ||
                  _rs.blank();
                  _rs.REF:=$TKTL.ref();
                  _rs.NRK:=TKTL.NRK;
                  _rs.VER:=TKTL.WER;
                  _rs.TYP:=TKTL.TYP().TYP;
                  {? TKTLW.DEFAULT='T'
                  || _rs.DEFAULT:=1
                  || _rs.DEFAULT:=0
                  ?};
                  _rs.T_Z:='T';
                  {? _z_ref<>''
                  || _rs.USED:=exec('tech_used','po_plan','ZM',$TKTL.ref(),_z_ref)
                  ?};
                  _rs.add()
               ?}
            ?};
            TKTLW.f_next()
         !}
      ?};
      TKTLW.f_clear()
   ?}
?}


\gettechdata
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Zasilenie procedury wbudowanej gettechdata@po_plope
::   WE: _a - :RS
::       _b - STRING[1] - typ zrodla: 'T'echnologia, technologia 'Z'lecenia, 'P' przewodnik
::       _c - $M.ref()
::       _d - SQL ref - ref zrodla pochodzenia danych czyli $TKTL.ref(), $ZGH.ref()
::       _e - REAL - planowana ilosc
::       _f - SQL ref - ref planowanego obiektu - $ZL.ref(), $ZK_P.ref()
::       _g - STRING[10] - typ planowanego obiektu: 'ZL_P', 'ZK_P'
::       _f - STRING[255] - nazwa przewodnika planistycznego
::  OLD: \gettechdata/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
:: nie sprawdzamy przekazanych argumentow!
_rs:=_a;
_t_z:=_b;
_m_ref:=_c;
_source:=_d;
_il:=_e;
_obj_ref:=_f;
_obj_typ:=_g;
_plpart:=_h;

_ndx_def:=_rs.index('?');

ZGH.cntx_psh(); ZGH.clear();
ZGP.cntx_psh(); ZGP.clear();
NASZGP.cntx_psh();
ZL.cntx_psh(); ZL.clear();
M.cntx_psh();
M.clear();

:: Wszystkim tabelom dotyczacym technologii robie cnxt_psh
exec('tktl_cntx_psh','tech_common');

:: numer operacji w procesie
_num:=0;

:: calkowity czas procesu
_alltime:=0;

_root:=null();

:: Minimalny czas rozpoczecia wspolny dla wszystkich operacji - z planu strategicznego
_mps_min:='';

:: Maksymalny czas zakonczenia wspolny dla wszystkich operacji - z planu strategicznego
_mps_max:='';

_mainver:=exec('get_mainversion','px_ver');
{? _obj_typ='ZL_P'
||
   {? exec('zl_plannedSQL','px_obj',_obj_ref,_mainver)>0
   || _tm_start:=exec('zlec_start_sql','px_tie',_obj_ref);
      _tm_end:=exec('zlec_end_sql','px_tie',_obj_ref);
      {? _tm_start>0
      || _mps_min:=exec('to_string','#tm_stamp',_tm_start)
      ?};
      {? _tm_end>0
      || _mps_max:=exec('to_string','#tm_stamp',_tm_end)
      ?}
   ?}
?};
{? _obj_typ='ZK_P'
|| {? exec('zkp_plannedSQL','px_obj',_obj_ref,_mainver)>0
   || _tm_start:=exec('zkp_start_sql','px_tie',_obj_ref);
      _tm_end:=exec('zkp_end_sql','px_tie',_obj_ref);
      {? _tm_start>0
      || _mps_min:=exec('to_string','#tm_stamp',_tm_start)
      ?};
      {? _tm_end>0
      || _mps_max:=exec('to_string','#tm_stamp',_tm_end)
      ?}
   ?}
?};
{? _obj_typ='ZGP'
|| _tm_start:=exec('zgp_start_sql','px_tie',_obj_ref);
   _tm_end:=exec('zgp_end_sql','px_tie',_obj_ref);
   {? _tm_start>0
   || _mps_min:=exec('to_string','#tm_stamp',_tm_start)
   ?};
   {? _tm_end>0
   || _mps_max:=exec('to_string','#tm_stamp',_tm_end)
   ?}
?};

{? _t_z='T'
||
:: Wymyslam maske na podstawie pola z sql_refem
   _msk:=form((8+_source)+3);

:: Otwieram wlasciwa maske dla tabel z technologia
   exec('tktl_use','tech_common',_msk);

   TKTLW.index('REF');
   TKTLW.prefix(BIT.sqlint(_source),BIT.sqlint(_m_ref));
   TKTL.clear();
   {? TKTLW.first() & TKTL.seek(_source) & M.seek(_m_ref)
   ||
      VAR.A_KTL:=TKTL.ref();
      exec('start_tpar','tech_param',M.ref());

      _rs.blank();
      _rs.TYP:='C';
      _rs.SYM:='Całość';
      _rs.NAZWA:='Całość';
      _rs.LEVEL:=0;
      _rs.PAR:=0;
      _rs.add();
      _root:=_rs.ref();
      _rs.ID:=#_rs.ref();
      _rs.put();
      _par_c:=_rs.ID;

::    kolejnosc operacji wg zlozonosci
      _toper:=tab_tmp(1,
         'NUM','INTEGER','Numer',
         'REF','INTEGER','#TOPER.ref()',
         'REF_SQL', 'STRING[16]', '$TOPER.ref()'
      );

      __formulka:="
         TOPER.cntx_psh();
         TOPER.index('ANNN');
         TOPER.prefix('T','N',_b,_c);
         {? TOPER.first()
         || {!
            |?
               {? TOPER.PZ='P' & tpar.calc(TOPER.EXIST)
               || _a.REF:=#TOPER.ref();
                  _a.REF_SQL:=$TOPER.ref();
                  _a.add();
                  _a.NUM:=#_a.ref();
                  _a.put()
               ?};
               __formulka(_a,_b,TOPER.UNROP);
               TOPER.next()
            !}
         ?};
         TOPER.cntx_pop()
      ";
      __formulka(_toper,TKTL.ref(),0);
      &__formulka;

      _toper.clear();
      TOPER.clear();

      {? _toper.first()
      ||
         _offset:=0;
         _duration:=0;
         {!
         |?
            {? TOPER.seek(_toper.REF,)
            ||
               _num+=1;

               _coef:=_il/TKTL.XJM;
               _rs.blank();
               _rs.TYP:='O';
               {? TOPER.WEW='T'
               ||
                  _rs.SYM:=TOPER.OPER().KOD;
                  _rs.NAZWA:=TTOPER.NA;
                  _rs.COOP:='N'
               ||
                  _rs.SYM:=TOPER.TTOUT().KOD;
                  _rs.NAZWA:=TTOUT.NA;
                  _rs.COOP:='T'
               ?};
               _rs.LEVEL:=1;
               _rs.PAR:=_par_c;

::             Uwaga: przeliczenie, jezeli technologia parametryzowana
               _mtime:={? TOPER.FMTIME<>'' || tpar.calc(TOPER.FMTIME) || TOPER.MTIME ?};
               _ntime:={? TOPER.FNTIME<>''|| tpar.calc(TOPER.FNTIME) || TOPER.NTIME ?};
               _ttm:={? TOPER.FTTM<>''|| tpar.calc(TOPER.FTTM) || TOPER.TTM ?};
               _nko:={? TOPER.FNKO<>''|| tpar.calc(TOPER.FNKO) || TOPER.NKO ?};
               _exist:={? TOPER.EXIST<>'' || tpar.calc(TOPER.EXIST) || 1 ?};
               {? TOPER.WEW='T'
               || _rs.DURATION:={? _mtime=0 || _ntime || _mtime ?}*60*{? TOPER.FIX_NORM='T' || 1 || _coef ?}
               ||
::                czas dla kooperacji
                  _rs.DURATION:=TOPER.DAYS_K*exec('coef_dg','px_kont',TOPER.PX_KONT,0,0)*60*_coef
               ?};
               _rs.OFFSET_P:=_offset;
               _rs.OFFSET_O:=(_ttm-_nko)*60;
               _duration+=_rs.DURATION + _ttm*60*_coef - _nko*60*_coef;
               _rs.REF_RES:='';

::             obsluga TPZ
               TOPER.cntx_psh();
               TOPER.index('TPZ');
               TOPER.prefix('T',TOPER.UNROP);
               {? TOPER.first()
               ||
                  _rs.TP:={? TOPER.FNTIME<>''|| tpar.calc(TOPER.FNTIME) || TOPER.NTIME ?}*60;
                  _rs.TPDEF:=_rs.TP
               ?};
               TOPER.cntx_pop();

::             Granice czasowe z planu strategicznego
               {? _mps_min<>''
               || _rs.TM_MIN:=_mps_min;
                  _rs.SYM_MIN:=exec('bound_sym_mps','px_tie')
               ?};
               {? _mps_max<>''
               || _rs.TM_MAX:=_mps_max;
                  _rs.SYM_MAX:=exec('bound_sym_mps','px_tie')
               ?};

::             Granice czasowe dla kooperacji - w przypadku TOPERow zawsze 'Brak' czyli nie bedzie sie dalo zaplanowac
::             takiego zlecenia/zamowienia
               {? TOPER.WEW='N'
               || _rs.TM_MIN:='Brak';
                  _rs.TM_MAX:='Brak'
               ?};

               {? _obj_typ='ZL_P'
               || _rs.INFO1:='ZL: ';
                  _rs.INFO1+=exec('FindAndGet','#table',ZL,_obj_ref,,"SYM",'');
                  _rs.INFO1+=' '+_plpart
               |? _obj_typ='ZK_P'
               || _rs.INFO1:='ZM: ';
                  _rs.INFO1+=exec('FindAndGet','#table',ZK_P,_obj_ref,,"ZK_P.N().SYM",'');
                  _rs.INFO1+=' '+_plpart
               ?};
               _rs.INFO2:=_rs.SYM+' / '+M.KTM;
               _rs.KTM:=M.KTM;
               _rs.INFO3:='';
               _rs.PLO_SYM:=_rs.INFO1;
               _rs.PLO_OPIS:=_rs.SYM;
               M.cntx_psh();
               M.clear();
               {? M.seek(_m_ref)
               || _rs.KOLOR_M:=M.KOLOR;
                  _rs.KOLOR_G:=M.MGR().KOLOR
               ?};
               M.cntx_pop();
               _rs.KOLOR_TO:=TOPER.OPER().KOLOR;

               _tktl:=TOPER.NRK;
               TACTTLS.cntx_psh();
               TACTTLS.index('AKNROP');

::               _util:=exec('FindAndGet','#table',TKTL,_tktl,,"TYP().UTIL",'');
::             W pierwszej kolejności sprawdza czy są NPU do operacji, jak nie ma, to sprawdza czy są do karty
               {? 1
::                  _util='O'
               || TACTTLS.prefix('T',_tktl,TOPER.ref())
::               || TACTTLS.prefix('T',_tktl)
               ?};
               {? TACTTLS.size()>0
               || _rs.NPU:='T'
               || TACTTLS.prefix('T',_tktl,null());
                  {? TACTTLS.size()>0
                  || _rs.NPU:='T'
                  ?}
               ?};
               TACTTLS.cntx_pop();

               _rs.TOPER:=$TOPER.ref();
               _rs.NUM:=_num;
               _rs.ID_NEXT:='';
               {? _exist>0
               || _rs.add();
                  _rs.ID:=#_rs.ref();
                  _rs.put();
                  _par_o:=_rs.ID;
                  _duration:=_rs.DURATION;
                  _offset+=_duration;
                  _alltime+=_duration;
                  _tp_dur:=_rs.TP;
                  _tz_dur:=_rs.TZ;

::                Zasoby do operacji
::                Uwaga: operacje kooperacyjne uwzgledniane sa bez zasobow
                  {? TOPER.WEW='T'
                  ||
                     _resources:=exec('get_resources','po_plan',$TOPER.ref(),_il,,'TOPER');
                     _resources.prefix();
                     {? _resources.first()
                     || {!
                        |?
                           _rs.blank();
                           _rs.TYP:='R';
                           _rs.LEVEL:=2;
                           _rs.PAR:=_par_o;
                           _rs.SYM:=_resources.SYM;
                           _rs.NAZWA:=_resources.NAZWA;
                           _rs.REF_RES:=_resources.REF_RES;
                           _rs.ALERT:=_resources.ALERT;
                           _rs.DURATION:=_resources.DURATION;
                           _rs.OFFSET_O:=_resources.OFFSET_O;
                           _rs.TP:=_tp_dur;
                           _rs.TPDEF:=_rs.TP;
                           _rs.TZ:=_tz_dur;
                           _rs.TZDEF:=_rs.TZ;
                           _rs.DEFAULT:=_resources.DEFAULT;
                           {? _resources.ZAM_WHAT='ZAMIENNIK'
                           || _rs.ZAM:=1
                           ?};
                           _rs.add();
                           _rs.ID:=#_rs.ref();
                           _rs.put();
                           _resources.next()
                        !}
                     ?};
                     obj_del(_resources)
                  ?}
               ?}
            ?};
            _toper.next()
         !};
::       Jesli granice czasowe z planu strategicznego podane to pierwszej i ostatniej operacji
::       ustawiam żądane czasy rozpoczęcia lub zakończenia
         {? _mps_min<>'' & _mps_max<>''
         || _rs.cntx_psh();
            _ndx_tmp:=_ndx:=_rs.ndx_tmp(,,'TYP',,,'TOPER',,);
            _rs.index(_ndx_tmp);
            {? _toper.first()
            || _rs.prefix('O',_toper.REF_SQL);
               {? _rs.first()
               || _rs.TM_REQ_S:=_mps_min;
                  _rs.put()
               ?}
            ?};
            {? _toper.last()
            || _rs.prefix('O',_toper.REF_SQL);
               {? _rs.first()
               || _rs.TM_REQ_E:=_mps_max;
                  _rs.put()
               ?}
            ?};
            _rs.cntx_pop()
         ?}
      ?};
      exec('stop_tpar','tech_param')
   ?}
|? _t_z='Z'
||
:: Wymyslam maske na podstawie pola z sql_refem
   _msk:=form((8+_source)+3);

:: Otwieram wlasciwa maske dla tabel z technologia
   exec('tktl_use','tech_common',_msk);
   TKTL.clear();
   {? TKTL.seek(_source)
   ||
      exec('start_tpar','tech_param',TKTL.KTM,TKTL.ref());
      _rs.blank();
      _rs.TYP:='C';
      _rs.SYM:='Całość';
      _rs.NAZWA:='Całość';
      _rs.LEVEL:=0;
      _rs.PAR:=0;
      _rs.add();
      _root:=_rs.ref();
      _rs.ID:=#_rs.ref();
      _rs.put();
      _par_c:=_rs.ID;

::    kolejnosc operacji wg zlozonosci
      _toper:=tab_tmp(1,
         'NUM','INTEGER','Numer',
         'REF','INTEGER','#TOPER.ref()',
         'REF_SQL', 'STRING[16]', '$TOPER.ref()'
      );

      __formulka:="
         TOPER.cntx_psh();
         TOPER.index('NNN');
         TOPER.prefix(_b,_c);
         {? TOPER.first()
         || {!
            |?
               {? TOPER.PZ='P' & TOPER.TPZ='N'
               || _a.REF:=#TOPER.ref();
                  _a.REF_SQL:=$TOPER.ref();
                  _a.add();
                  _a.NUM:=#_a.ref();
                  _a.put()
               ?};
               __formulka(_a,_b,TOPER.UNROP);
               TOPER.next()
            !}
         ?};
         TOPER.cntx_pop()
      ";
      __formulka(_toper,TKTL.ref(),0);
      &__formulka;

      _toper.clear();
      TOPER.clear();
      {? _toper.first()
      ||
         _offset:=0;
         _duration:=0;
         {!
         |?
            {? TOPER.seek(_toper.REF,)
            ||
               _num+=1;

               _coef:=_il/TKTL.XJM;
               _rs.blank();
               _rs.TYP:='O';
               {? TOPER.WEW='T'
               ||
                  _rs.SYM:=TOPER.OPER().KOD;
                  _rs.NAZWA:=TTOPER.NA;
                  _rs.COOP:='N'
               ||
                  _rs.SYM:=TOPER.TTOUT().KOD;
                  _rs.NAZWA:=TTOUT.NA;
                  _rs.COOP:='T'
               ?};
               _rs.LEVEL:=1;
               _rs.PAR:=_par_c;
               {? TOPER.WEW='T'
               || _rs.DURATION:={? TOPER.MTIME=0 || TOPER.NTIME || TOPER.MTIME ?}*60*{? TOPER.FIX_NORM='T' || 1 || _coef ?}
               ||
::                czas dla kooperacji
                  _rs.DURATION:=TOPER.DAYS_K*exec('coef_dg','px_kont',TOPER.PX_KONT,0,0)*60*_coef
               ?};
               _exist:={? TOPER.EXIST<>'' || tpar.calc(TOPER.EXIST) || 1 ?};
               _rs.OFFSET_P:=_offset;
               _rs.OFFSET_O:=(TOPER.TTM-TOPER.NKO)*60;
               _duration+=_rs.DURATION + TOPER.TTM*60*_coef - TOPER.NKO*60*_coef;
               _rs.REF_RES:='';
::             obsluga TPZ
               TOPER.cntx_psh();
               TOPER.index('TPZ');
               TOPER.prefix('T',TOPER.UNROP);
               {? TOPER.first()
               ||
                  _rs.TP:=TOPER.NTIME*60;
                  _rs.TPDEF:=_rs.TP
               ?};
               TOPER.cntx_pop();

::             Granice czasowe z planu strategicznego
               {? _mps_min<>''
               || _rs.TM_MIN:=_mps_min;
                  _rs.SYM_MIN:=exec('bound_sym_mps','px_tie')
               ?};
               {? _mps_max<>''
               || _rs.TM_MAX:=_mps_max;
                  _rs.SYM_MAX:=exec('bound_sym_mps','px_tie')
               ?};

::             Granice czasowe dla kooperacji - w przypadku TOPERow zawsze 'Brak' czyli nie bedzie sie dalo zaplanowac
::             takiego zlecenia
               {? TOPER.WEW='N'
               || _rs.TM_MIN:='Brak';
                  _rs.TM_MAX:='Brak'
               ?};

               _ktm:='';
               {? _obj_typ='ZL_P'
               || _ktm:=exec('FindAndGet','#table',ZL,_obj_ref,,"ZL.KTM().KTM",'');
                  _rs.INFO1:='ZL: ';
                  _rs.INFO1+=exec('FindAndGet','#table',ZL,_obj_ref,,"SYM",'');
                  _rs.INFO1+=' '+_plpart
               |? _obj_typ='ZK_P'
               || _ktm:=exec('FindAndGet','#table',ZK_P,_obj_ref,,"ZK_P.M().KTM",'');
                  _rs.INFO1:='ZM: ';
                  _rs.INFO1+=exec('FindAndGet','#table',ZK_P,_obj_ref,,"ZK_P.N().SYM",'');
                  _rs.INFO1+=' '+_plpart
               ?};
               _rs.KTM:=_ktm;
               _rs.INFO2:=_rs.SYM+' / '+_ktm;
               _rs.INFO3:='';

               _rs.PLO_SYM:=_rs.INFO1;
               _rs.PLO_OPIS:=_rs.SYM;
               M.cntx_psh();
               M.clear();
               {? M.seek(_m_ref)
               || _rs.KOLOR_M:=M.KOLOR;
                  _rs.KOLOR_G:=M.MGR().KOLOR
               ?};
               M.cntx_pop();
               _rs.KOLOR_TO:=TOPER.OPER().KOLOR;

               TACTTLS.cntx_psh();

               _tktl:=TOPER.NRK;
::               _util:=exec('FindAndGet','#table',TKTL,_tktl,,"TYP().UTIL",'');
::             W pierwszej kolejności sprawdza czy są NPU do operacji, jak nie ma, to sprawdza czy są do karty
               {? 1
::                  _util='O'
               || TACTTLS.prefix('T',_tktl,TOPER.ref())
::               || TACTTLS.prefix('T',_tktl)
               ?};
               {? TACTTLS.size()>0
               || _rs.NPU:='T'
               || TACTTLS.prefix('T',_tktl,null());
                  {? TACTTLS.size()>0
                  || _rs.NPU:='T'
                  ?}
               ?};
               TACTTLS.cntx_pop();

               _rs.TOPER:=$TOPER.ref();
               _rs.NUM:=_num;
               _rs.ID_NEXT:='';
               {? _exist>0
               ||
                  _rs.add();
                  _rs.ID:=#_rs.ref();
                  _rs.put();
                  _par_o:=_rs.ID;
                  _duration:=_rs.DURATION;
                  _offset+=_duration;
                  _alltime+=_duration;
                  _tp_dur:=_rs.TP;
                  _tz_dur:=_rs.TZ;

::                Zasoby do operacji
::                Uwaga: operacje kooperacyjne uwzgledniane sa bez zasobow
                  {? TOPER.WEW='T'
                  ||
                     _resources:=exec('get_resources','po_plan',$TOPER.ref(),_il,,'TOPER');
                     _resources.prefix();
                     {? _resources.first()
                     || {!
                        |?
                           _rs.blank();
                           _rs.TYP:='R';
                           _rs.LEVEL:=2;
                           _rs.PAR:=_par_o;
                           _rs.SYM:=_resources.SYM;
                           _rs.NAZWA:=_resources.NAZWA;
                           _rs.REF_RES:=_resources.REF_RES;
                           _rs.ALERT:=_resources.ALERT;
                           _rs.DURATION:=_resources.DURATION;
                           _rs.OFFSET_O:=_resources.OFFSET_O;
                           _rs.TP:=_tp_dur;
                           _rs.TPDEF:=_rs.TP;
                           _rs.TZ:=_tz_dur;
                           _rs.TZDEF:=_rs.TZ;
                           _rs.DEFAULT:=_resources.DEFAULT;
                           {? _resources.ZAM_WHAT='ZAMIENNIK'
                           || _rs.ZAM:=1
                           ?};
                           _rs.add();
                           _rs.ID:=#_rs.ref();
                           _rs.put();
                           _resources.next()
                        !}
                     ?};
                     obj_del(_resources)
                  ?}
               ?}
            ?};
            _toper.next()
         !};
::       Jesli granice czasowe z planu strategicznego podane to pierwszej i ostatniej operacji
::       ustawiam żądane czasy rozpoczęcia lub zakończenia
         {? _mps_min<>'' & _mps_max<>''
         || _rs.cntx_psh();
            _ndx_tmp:=_ndx:=_rs.ndx_tmp(,,'TYP',,,'TOPER',,);
            _rs.index(_ndx_tmp);
            {? _toper.first()
            || _rs.prefix('O',_toper.REF_SQL);
               {? _rs.first()
               || _rs.TM_REQ_S:=_mps_min;
                  _rs.put()
               ?}
            ?};
            {? _toper.last()
            || _rs.prefix('O',_toper.REF_SQL);
               {? _rs.first()
               || _rs.TM_REQ_E:=_mps_max;
                  _rs.put()
               ?}
            ?};
            _rs.cntx_pop()
         ?}
      ?};
      exec('stop_tpar','tech_param')
   ?}
|? _t_z='P'
||
   _ndx_zgp:=_rs.ndx_tmp(,,'ZGP',,);
   {? ZGH.seek(_source)
   ||
::    Podczytanie zlecenia
      ZGH.ZLEC();

      _rs.blank();
      _rs.TYP:='C';
      _rs.SYM:='Całość';
      _rs.NAZWA:='Całość';
      _rs.LEVEL:=0;
      _rs.PAR:=0;
      _rs.add();
      _root:=_rs.ref();
      _rs.ID:=#_rs.ref();
      _rs.put();
      _par_c:=_rs.ID;

      {? ZL.NRNZL<>0
      || ZGP.index('PNRPP')
      || ZGP.index('NRPP')
      ?};
      ZGP.prefix(ZGH.ref(),'N');
      {? ZGP.first()
      ||
         _offset:=0;
         _duration:=0;
         _argszgp:=exec('zgp2techdata_a','po_plan');
         _argszgp.PARENT:=_par_c;
         _argszgp.MPS_MIN:=_mps_min;
         _argszgp.MPS_MAX:=_mps_max;
         {? _il>0
         || _argszgp.COEF:=_il/ZGP.ILOSC
         ?};

         {!
         |? {? ZGP.PLANUJ='T'
            || exec('zgp2techdata','po_plan',_argszgp,_rs,_ndx_zgp)
            ?};
            ZGP.next()
         !};
         _alltime:=_argszgp.ALLTIME
      ?};
::    Jesli granice czasowe z planu strategicznego podane to pierwszej i ostatniej operacji
::    ustawiam żądane czasy rozpoczęcia lub zakończenia
      {? _mps_min<>'' & _mps_max<>''
      || _rs.cntx_psh();
         _ndx_tmp:=_ndx:=_rs.ndx_tmp(,,'TYP',,,'ZGP',,);
         _rs.index(_ndx_tmp);
         {? ZGP.first()
         || _rs.prefix('O',$ZGP.ref());
            {? _rs.first()
            || _rs.TM_REQ_S:=_mps_min;
               _rs.put()
            ?}
         ?};
         {? ZGP.last()
         || _rs.prefix('O',$ZGP.ref());
            {? _rs.first()
            || _rs.TM_REQ_E:=_mps_max;
               _rs.put()
            ?}
         ?};
         _rs.cntx_pop()
      ?}
   ?}
?};

_rs.clear();
{? _rs.seek(_root) || _rs.DURATION:=_alltime; _rs.put() ?};

_ndx:=_rs.ndx_tmp(,,'TYP',,,'TOPER',,,'ZOPER',,,'ZGP',,);
_rs.index(_ndx);

:: Petla do nadawania wartosci dla pola _rs.ID_NEXT - dla kazdej operacji wyznaczamy liste nastepnikow
_rs.prefix('O');
{? _rs.first()
|| {!
   |?
      {? _rs.TOPER<>''
      || _id_next:='';
         _rs.cntx_psh();
         NASTOPER.index('OPNAST');
         NASTOPER.prefix('T',BIT.sqlint(_rs.TOPER));
         {? NASTOPER.first()
         || {!
            |?
               _rs.prefix('O',$NASTOPER.NRNAST);
               {? _rs.first()
               || _id_next+=$_rs.ID+';'
               ?};
               NASTOPER.next()
            !}
         ?};
         _rs.cntx_pop();
         _rs.ID_NEXT:=_id_next
      |? _rs.ZGP<>''
      || _id_next:='';
         _rs.cntx_psh();
         NASZGP.index('OPNAST');
         NASZGP.prefix(BIT.sqlint(_rs.ZGP));
         {? NASZGP.first()
         || {!
            |?
               _rs.prefix('O','','',$NASZGP.NRNAST);
               {? _rs.first()
               || _id_next+=$_rs.ID+';'
               ?};
               NASZGP.next()
            !}
         ?};
         _rs.cntx_pop();
         _rs.ID_NEXT:=_id_next
      ?};
      {? _rs.ID_NEXT='' || _rs.ID_NEXT:='-1;' ?};
      _rs.put();
      _rs.next()
   !}
?};

:: Obsluga kooperacji - nastepnikom i poprzednikom kooperacji nadajemy max i minimalne czasy
_rs.prefix('O');
{? _rs.first()
|| {!
   |?
      {? _rs.ZGP<>''
      || _rs.cntx_psh();
         NASZGP.index('OPNAST');
         NASZGP.prefix(BIT.sqlint(_rs.ZGP));
         {? NASZGP.first()
         || {!
            |?
::             Ustawiam sie na biezacej operacji
               NASZGP.OPER();
               {? ZGP.WEW='N'
               ||
::                jesli biezaca operacja jest kooperacja to nastepnej ustawiam minimalny czas rozpoczecia
                  _rs.prefix('O','','',$NASZGP.NRNAST);
                  {? _rs.first()
                  || _tm_min:=exec('to_string','#tm_stamp',ZGP.TMENDK);
                     _rs.TM_MIN:=_tm_min;
                     _rs.TM_REQ_S:=_tm_min;
                     _rs.SYM_MIN:='Kooperacja';
                     {? ZGP.KONTRAH<>null()
                     || _rs.SYM_MIN+=' z: '+ZGP.KONTRAH().KOD
                     ?};
                     _rs.put()
                  ?}
               ?};

::             Ustawiam sie na nastepnej operacji
               NASZGP.NRNAST();
               {? ZGP.WEW='N'
               ||
::                jesli nastepna operacja jest kooperacja to poprzedniej ustawiam maksymalny czas zakonczenia
                  _rs.prefix('O','','',$NASZGP.OPER);
                  {? _rs.first()
                  || _tm_max:=exec('to_string','#tm_stamp',ZGP.TMSTARTK);
                     _rs.TM_MAX:=_tm_max;
                     _rs.TM_REQ_E:=_tm_max;
                     _rs.SYM_MAX:='Kooperacja';
                     {? ZGP.KONTRAH<>null()
                     || _rs.SYM_MAX+=' z: '+ZGP.KONTRAH().KOD
                     ?};
                     _rs.put()
                  ?}
               ?};
               NASZGP.next()
            !}
         ?};
         _rs.cntx_pop()
      ?};
      _rs.next()
   !}
?};

_rs.clear();
_rs.index(_ndx_def);

:: Wszystkim tabelom dotyczacym technologii robie cnxt_pop
exec('tktl_cntx_pop','tech_common');

M.cntx_pop();
ZGH.cntx_pop();
ZGP.cntx_pop();
NASZGP.cntx_pop();
ZL.cntx_pop();
~~


\zgp2techdata_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Tablica parametrów dla zgp2techdata
::   WY: _args
::  OLD: \zgp2techdata_a/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new( 'blank'
               ,'NUM'
               ,'OFFSET_P'
               ,'PARENT'
               ,'MPS_MIN'
               ,'MPS_MAX'
               ,'ALLTIME'
               ,'COEF'
              );
:: - - - - ponizej ustawienie wartosci domyslnych
_args.blank:="
         .NUM:=0;
         .OFFSET_P:=0;
         .PARENT:=0;
         .MPS_MIN:='';
         .MPS_MAX:='';
         .ALLTIME:=0;
         .COEF:=1;
         ~~";
:: - - - - koniec ustalania wartosci domyslnych
_args.blank();
_args


\zgp2techdata
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Dodaje do paczki technologicznej Planu operacyjnego informacje o ZGPie
::       Kontekst pracy - rekord ZGP
::   WE: _a - _args
::       _b - ResultSet ktory wypelniac
::       _c - STRING - identyfikator indeksu tymczasowego w ResultSet - sortowanie po $ZGP.ref()
::  OLD: \zgp2techdata/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('zgp2techdata_a','po_plan')
?};
_rs:=_b;
_ndx:=_c;

ZGP.cntx_psh();
NASZGP.cntx_psh();
NASZGP.index('NASTOP');
ZLIM.cntx_psh();

:: Jezeli ZGP ma poprzedniki i nie zostaly one jeszcze dodane do RSa to je dodaje rekurencyjnie
_rs.cntx_psh();
_rs.index(_ndx);
NASZGP.prefix(ZGP.ref());
{? NASZGP.first()
||
   {!
   |?
::    Podczytanie ZGP - stoje na poprzedniku
      NASZGP.OPER();

::    Sprawdzam czy ten ZGP jest juz w ResultSet
      _rs.prefix($ZGP.ref());
      {? _rs.size()=0
      ||
::       REKURENCJA
         exec('zgp2techdata','po_plan',_args,_rs,_ndx)
      ?};
      NASZGP.next()
   !};
   ~~
?};
NASZGP.cntx_pop();
ZGP.cntx_pop();

ZGH.cntx_psh();
ZL.cntx_psh();
M.cntx_psh();
_rs.clear();

_rs.prefix($ZGP.ref());
{? _rs.size()=0
||
   _args.NUM+=1;

   _rs.blank();
   _rs.TYP:='O';
   {? ZGP.WEW='T'
   || _rs.COOP:='N'
   || _rs.COOP:='T'
   ?};
   _rs.ILOSC:=ZGP.ILOSC;
   _rs.SYM:=$ZGP.NRP+'. '+ZGP.OPIS;
   _rs.NAZWA:='';
   _rs.LEVEL:=1;
   _rs.PAR:=_args.PARENT;
   {? ZGP.WEW='T'
   || _rs.DURATION:={? ZGP.MTIME=0 || ZGP.NTIME || ZGP.MTIME ?}*60*{? ZGP.FIX_NORM='T' || 1 || _args.COEF ?}
   ||
::    czas dla kooperacji
      _rs.DURATION:=(ZGP.TMENDK-ZGP.TMSTARTK)/exec('minute','#tm_stamp')
   ?};
   _rs.OFFSET_P:=_args.OFFSET_P;
   _rs.OFFSET_O:=(ZGP.TTM-ZGP.NKO)*60;
   _rs.REF_RES:='';
:: obsluga TPZ
   ZGP.cntx_psh();
   ZGP.index('TPZ');
   ZGP.prefix('T',ZGP.UID);
   {? ZGP.first()
   ||
      _rs.TP:=ZGP.NTIME*60
   ?};
   ZGP.cntx_pop();

:: obsluga TPZ domyślnego
   {? ZGP.TOPER<>null()
   ||

      TOPER.cntx_psh();
      TOPER.index('TPZ');
      TOPER.prefix('T',ZGP.TOPER().UNROP);
      {? TOPER.first()
      ||
         {? ZGP.ZL().TYP().TECH='T'
         ||
::          Zlecenie z własną technologią, norma TPZ przeliczona
            _rs.TPDEF:=TOPER.NTIME*60
         ||
::          Zlecenie bez własnej technologii trzeba przeliczyć czas TPZ
            {? TOPER.FNTIME<>''
            || exec('start_tpar','tech_param',ZL.KTM,ZGP.ZL().KTL);
                _rs.TPDEF:=tpar.calc(TOPER.FNTIME)*60
            ||  _rs.TPDEF:=TOPER.NTIME*60
            ?}
         ?}
      ?};
      TOPER.cntx_pop()
   ?};

:: Granice czasowe z planu strategicznego
   {? _args.MPS_MIN<>''
   || _rs.TM_MIN:=_args.MPS_MIN;
      _rs.SYM_MIN:=exec('bound_sym_mps','px_tie')
   ?};
   {? _args.MPS_MAX<>''
   || _rs.TM_MAX:=_args.MPS_MAX;
      _rs.SYM_MAX:=exec('bound_sym_mps','px_tie')
   ?};

:: Obsluga kooperacji - przekazuje ramy czasowe operacji kooperacyjnej
   {? ZGP.WEW='N'
   || _coop_ok:=1;
      {? ZGP.TMSTARTK>0
      || _tm_str:=exec('to_string','#tm_stamp',ZGP.TMSTARTK);
         _rs.TM_REQ_S:=_tm_str;
         _rs.TM_MIN:=_tm_str
      || _rs.TM_MIN:='Brak';
         _coop_ok:=0
      ?};
      {? ZGP.TMENDK>0
      || _tm_str:=exec('to_string','#tm_stamp',ZGP.TMENDK);
         _rs.TM_REQ_E:=_tm_str;
         _rs.TM_MAX:=_tm_str
      || _rs.TM_MAX:='Brak';
         _coop_ok:=0
      ?};

      {? _coop_ok>0
      ||
         {? ZGP.KOOP_AKC<>'T'
         || _rs.TM_REQ_S:='';
            _rs.TM_REQ_E:='';
            _rs.TM_MIN:='Brak akc.';
            _rs.TM_MAX:='Brak akc.'
         ?}
      ?}
   ?};

:: Obsluga grup operacji
   _rs.IN_GROP:=ZGP.PL_GRP;
:: Obsluga grup operacji - zwracam najwczesniej zaplanowana grupe do ktorej nalezy zgp
   _grop_first:=exec('grop_first4zgp','po_ogr',ZGP.ref());
   {? _grop_first<>null()
   || _rs.GR_STA_R:=$_grop_first;
      _rs.GR_STA_S:=exec('FindAndGet','#table',GROP,_grop_first,,"KOD+' '+OPIS",'')
   ?};
:: Obsluga grup operacji - zwracam najpozniej zaplanowana grupe do ktorej nalezy zgp
   _grop_last:=exec('grop_last4zgp','po_ogr',ZGP.ref());
   {? _grop_last<>null()
   || _rs.GR_END_R:=$_grop_last;
      _rs.GR_END_S:=exec('FindAndGet','#table',GROP,_grop_last,,"KOD+' '+OPIS",'')
   ?};

   _rs.INFO1:='ZL: ';
   _rs.INFO1+=ZGP.NRZLP().NRPRZ;
   _rs.INFO2:=ZGP.OPIS+' / '+ZGP.NRZLP().ZLEC().KTM().KTM;
   _rs.INFO3:='';
   _rs.KTM:=M.KTM;
   _rs.PLO_SYM:=_rs.INFO1;
   _rs.PLO_OPIS:=ZGP.OPIS;
   _rs.KOLOR_M:=ZGP.NRZLP().ZLEC().KTM().KOLOR;
   _rs.KOLOR_G:=M.MGR().KOLOR;
   _rs.KOLOR_TO:=ZGP.TOPER().OPER().KOLOR;

:: Występowanie limitów
   exec('openmask','zl_common',ZGP.ZL);
   ZLIM.index('ZGP_KM');
   ZLIM.prefix(ZGP.ref());
   {? ZLIM.size()>0
   || _rs.LIMITY:='T'
   || _rs.LIMITY:='N'
   ?};

:: Występowanie NPU
   _tktl:=ZGP.ZL().TKTL;
   {? _tktl=null()
   || _tktl:=ZGP.ZL().KTL
   ?};
   TACTTLS.cntx_psh();
   TACTTLS.index('AKNROP');
::   _util:=exec('FindAndGet','#table',TKTL,_tktl,,"TYP().UTIL",'');
:: W pierwszej kolejności sprawdza czy są NPU do operacji, jak nie ma, to sprawdza czy są do karty
   {? 1
::      _util='O'
   || TACTTLS.prefix('T',_tktl,ZGP.TOPER)
::   || TACTTLS.prefix('T',_tktl)
   ?};
   {? TACTTLS.size()>0
   || _rs.NPU:='T'
   || {? ZGP.TOPER<>null()
      || TACTTLS.prefix('T',_tktl,null());
         {? TACTTLS.size()>0
         || _rs.NPU:='T'
         ?}
      ?}
   ?};
   TACTTLS.cntx_pop();

   _rs.ZGP:=$ZGP.ref();
   _rs.ZGH:=$ZGP.NRZLP;
   _rs.NUM:=_args.NUM;
   _rs.ID_NEXT:='';
   _rs.add();
   _rs.ID:=#_rs.ref();
   _rs.put();
   _par_o:=_rs.ID;
   _duration:=_rs.DURATION;
   _args.OFFSET_P+=_duration;
   _args.ALLTIME+=_duration;
   _tp_dur:=_rs.TP;
   _tz_dur:=_rs.TZ;
   _tp_def:=_rs.TPDEF;

:: Zasoby do operacji
:: Uwaga: operacje kooperacyjne uwzgledniane sa bez zasobow
   {? ZGP.WEW='T' & ZGP.PL_GRP<>'T'
   ||

      _tktl:=null();
      {? ZL.RTKTL<>''
      || _tktl:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,,null())
      |? ZL.RKTL<>''
      || _tktl:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,,null())
      ?};

      exec('start_tpar','tech_param',M.ref(),_tktl);

      _resources:=exec('get_resources','po_plan',$ZGP.ref(),ZGP.ILOSC,,'ZGP');
      _resources.prefix();
      {? _resources.first()
      || {!
         |?
            _rs.cntx_psh();
            _rs.clear();
            _rs.blank();
            _rs.TYP:='R';
            _rs.LEVEL:=2;
            _rs.PAR:=_par_o;
            _rs.SYM:=_resources.SYM;
            _rs.NAZWA:=_resources.NAZWA;
            _rs.REF_RES:=_resources.REF_RES;
            _rs.ALERT:=_resources.ALERT;
            _rs.DURATION:=_resources.DURATION*_args.COEF;
            _rs.OFFSET_O:=_resources.OFFSET_O;
            _rs.TP:=_tp_dur;
            _rs.TPDEF:=_tp_def;
            _rs.TZ:=_tz_dur;
            _rs.DEFAULT:=_resources.DEFAULT;
            {? _resources.ZAM_WHAT='ZAMIENNIK'
            || _rs.ZAM:=1
            ?};
            _rs.add();
            _rs.ID:=#_rs.ref();
            _rs.put();
            _rs.cntx_pop();
            _resources.next()
         !}
      ?};
      obj_del(_resources)
   ?}
?};
_rs.cntx_pop();

ZGH.cntx_pop();
ZL.cntx_pop();
M.cntx_pop();
ZLIM.cntx_pop();
~~


\tech_used
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Sprawdza czy dana technologia zostala uzyta w planie zlecenia lub zamowienia
::   WE: _a - 'ZM' / 'ZL' - przetwarzamy zlecenia lub zamowienia
::       _b - Ref SQL Technologii (TKTL)
::       _c - Ref SQL zlecenia lub zamowienia (ZK_P lub ZL)
::   WY: 0 / 1
::  OLD: \tech_used/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? _<3
|| return(0)
?};
PL_PART.cntx_psh();
TKTL.cntx_psh();
_result:=0;
_typ:=_a;
_ref_tech:=_b;
_ref_plan:=_c;
::----------------------------------------------------------------------------------------------------------------------
{? _typ='ZM'
|| ZK_P.cntx_psh();
   ZK_P.clear();
   TKTL.clear();
   {? TKTL.seek(_ref_tech)
   || {? ZK_P.seek(_ref_plan)
      ||
         PL_PART.index('ZK_P');
         PL_PART.prefix(ZK_P.ref(),$TKTL.ref());
         {? PL_PART.first()
         || _result:=1
         ?}
      ?}
   ?};
   ZK_P.cntx_pop()

?};
::----------------------------------------------------------------------------------------------------------------------
{? _typ='ZL'
|| ZL.cntx_psh();
   ZL.clear();
   TKTL.clear();
   {? TKTL.seek(_ref_tech)
   || {? ZL.seek(_ref_plan)
      || PL_PART.index('ZL2');
         PL_PART.prefix(ZL.ref(),$TKTL.ref());
         {? PL_PART.first()
         || _result:=1
         ?}
      ?}
   ?};
   ZL.cntx_pop()
?};
PL_PART.cntx_pop();
TKTL.cntx_pop();
_result


\get_resources
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: zwraca zasoby do operacji
::   WE: _a - $TOPER.ref(), $ZGP.ref(), $TECHZAMS.ref()
::       _b - ILOŚĆ planowana/zaplanowana
::       [_c] - tab_tmp - tabela tymczasowa do której dodawać
::       [_d] - STRING - akronim tabeli ktorej dotyczy _a (TOPER, ZGP, TECHZAMS) - domyslnie TOPER
::       [_e] - INTEGER 0/[1] - dla wywołań rekurencyjnych - czy uzupełniać pole DEFAULT które spowoduje
::                              utworzenie pozycji planu podczas planowania
::  OLD: \get_resources/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;

_ilosc:=_b;

{? var_pres('_c')>100
|| _res:=_c
||
   _res:=tab_tmp(3,
   'TYP','STRING[1]','Typ',
   'REF_RES','STRING[16]','$PL_RES.ref()',
   'SYM','STRING[50]','Symbol zasobu',
   'NAZWA','STRING[100]','Nazwa zasobu',
   'ALERT','STRING[1]','Alert, jeżeli brak zasobu',
   'REF','STRING[16]','$ref() zasobu',
   'DURATION','REAL','Czas trwania w minutach',
   'OFFSET_O','REAL','Odstęp od poprzedniej operacji',
   'TECHZAMS','STRING[16]','Wskazanie na zamiennik operacji',
   'ZAM_WHAT','STRING[30]','Tekst mówiący czy zamiennik czy zamiennik stanowiska',
   'DEFAULT', 'STRING[1]', 'Czy zasob domyslny (dla gniazd)'
   )
?};

_tab:='TOPER';
{? var_pres('_d')=type_of('')
|| _tab:=_d
?};

_default:=1;
{? var_pres('_e')=type_of(0)
|| _default:=_e
?};

_oper:=($_tab)();
PL_RES.cntx_psh();
TWRKPLC.cntx_psh();
TWRKZBR.cntx_psh();
LPROD.cntx_psh();
TKTL.cntx_psh();

_oper.cntx_psh();
_oper.clear();
{? _oper.seek(_ref)
||
   _coef:=1;
   _exist:=1;
   {? _tab='ZGP'
   ||
      _coef:=_ilosc/_oper.ILOSC
   ||
::    Podczytanie technologii
      _oper.NRK();
      _coef:=_ilosc/TKTL.XJM
   ?};
   {? _tab='TOPER'
   || _exist:={? _oper.EXIST<>'' || tpar.calc(_oper.EXIST) || 1 ?}
   ?};
   _wew:='T';
   {? _tab<>'TECHZAMS'
   || _wew:=_oper.WEW
   ?};


   {? _exist>0
   ||
      PL_RES.index('TYP');
::    1. Stanowisko -------------------------------------------------------------------------------------------------------
      _chk_stan:=0;
      {? _tab='ZGP'
      || {? ZGP.GRUPA=null()
         || _chk_stan:=1
         ?}
      || {? _oper.GRPOJ='S'
         || _chk_stan:=1
         ?}
      ?};

      _res.blank();
      {? _default>0
      || _res.DEFAULT:='?'
      || _res.DEFAULT:='N'
      ?};

      {? _tab='TECHZAMS'
      || _res.ZAM_WHAT:='ZAMIENNIK';
         _res.DEFAULT:='N'
      ?};

      {? _tab<>'ZGP'
      ||
::       Operacja technologii lub zamiennnik
         {? _wew='T'
         ||
::          Operacja wewnętrzna
            _fix_norm:={? _tab='TOPER' || _oper.FIX_NORM || _oper.TOPER().FIX_NORM ?};
            _ntime:={? _oper.FNTIME<>'' || tpar.calc(_oper.FNTIME)$5 || _oper.NTIME ?};
            _mtime:={? _oper.FMTIME<>'' || tpar.calc(_oper.FMTIME)$5 || _oper.MTIME ?};
            _ttm:={? _oper.FTTM<>'' || tpar.calc(_oper.FTTM)$5 || _oper.TTM ?};
            _nko:={? _oper.FNKO<>'' || tpar.calc(_oper.FNKO)$5 || _oper.NKO ?};
            _res.DURATION:={? _mtime=0 || _ntime || _mtime ?}*60*{? _fix_norm='T' || 1 || _coef ?};
            _res.OFFSET_O:=(_ttm-_nko)*60
         ||
::          Kooperacja
            {? _tab='TOPER'
            || _res.DURATION:=_oper.DAYS_K*exec('coef_dg','px_kont',_oper.PX_KONT,0,0)*60*_coef
            ?}
         ?}
      ||
::       Pozycja przewodnika
         {? _wew='T'
         ||
::          Operacja wewnętrzna
            _res.DURATION:={? _oper.MTIME=0 || _oper.NTIME || _oper.MTIME ?}*60*{? _oper.FIX_NORM='T' || 1 || _coef ?};
            _res.OFFSET_O:=(_oper.TTM-_oper.NKO)*60
         ||
::          Kooperacja
            _res.DURATION:=(_oper.TMENDK-_oper.TMSTARTK)/exec('minute','#tm_stamp')
         ?};
         {? exec('is_zamiennik','zl_guide')=1
         ||
::          To jest wątek gdy ZGP jest już umieszczony na zamienniku
            _res.ZAM_WHAT:='ZAMIENNIK';
            _res.OFFSET_O:=exec('zamiennik_offset','zl_guide')
         ?}
      ?};

      {? _chk_stan>0
      ||
         _res.TYP:='S';
         _res.SYM:=_oper.PLACE().KOD;
         _res.NAZWA:=_oper.PLACE().NA;
         _res.REF:=$_oper.PLACE;
         PL_RES.prefix('S',$_oper.PLACE);
         {? PL_RES.first()
         || _res.REF_RES:=$PL_RES.ref();
            _res.ALERT:=''
         || _res.REF_RES:='';
            _res.ALERT:='R'
         ?};
         _can_add:=0;
         _res.cntx_psh();
         _res.prefix(_res.TYP,_res.REF_RES);
         {? _res.size()=0
         || _can_add:=1
         ?};
         _res.cntx_pop();
         {? _can_add>0
         || _res.add()
         ?}
      ?};
::    2. Gniazdo ----------------------------------------------------------------------------------------------------------
      _chk_gnd:=0;
      {? _tab='ZGP'
      || {? ZGP.GRUPA<>null()
         || _chk_gnd:=1
         ?}
      || {? _oper.GRPOJ='G'
         || _chk_gnd:=1
         ?}
      ?};

      {? _chk_gnd>0
      || _res.TYP:='G';
         _res.SYM:=_oper.GRUPA().SYMBOL;
         _res.NAZWA:=TWRKZBR.NAZWA;
         _res.REF:=$_oper.GRUPA;
         PL_RES.prefix('G',$_oper.GRUPA);
         {? PL_RES.first()
         || _res.REF_RES:=$PL_RES.ref();
            _res.ALERT:=''
         || _res.REF_RES:='';
            _res.ALERT:='R'
         ?};
         _can_add:=0;
         _res.cntx_psh();
         _res.prefix(_res.TYP,_res.REF_RES);
         {? _res.size()=0
         || _can_add:=1
         ?};
         _res.cntx_pop();
         {? _can_add>0
         || _res.add()
         ?};
         TWRKZPO.index('GRUPA');
         TWRKZPO.prefix(TWRKZBR.ref());
         {? TWRKZPO.first()
         || {!
            |? _res.TYP:='S';
               _res.SYM:=TWRKZPO.ELEMENT().KOD;
               _res.NAZWA:=TWRKZPO.ELEMENT().NA;
               _res.REF:=$TWRKZPO.ELEMENT;
               _res.ZAM_WHAT:='ZAM. - ELEMENT GNIAZDA';

               {? _tab='ZGP'
               || {? ZGP.PLACE=TWRKZPO.ELEMENT & _default>0
                  || _res.DEFAULT:='T'
                  || _res.DEFAULT:='N'
                  ?}
               || {? _oper.TWRKPLG=TWRKZPO.ref() & _default>0
                  || _res.DEFAULT:='T'
                  || _res.DEFAULT:='N'
                  ?}
               ?};

               PL_RES.prefix('S',$TWRKZPO.ELEMENT);
               {? PL_RES.first()
               || _res.REF_RES:=$PL_RES.ref();
                  _res.ALERT:=''
               || _res.REF_RES:='';
                  _res.ALERT:='R'
               ?};
               _can_add:=0;
               _res.cntx_psh();
               _res.prefix(_res.TYP,_res.REF_RES);
               {? _res.size()=0
               || _can_add:=1
               ?};
               _res.cntx_pop();
               {? _can_add>0
               || _res.add()
               ?};
               TWRKZPO.next()
            !}
         ?}
      ?};
::    3. Pracownicy zgodni pod wzgledem zawodow z operacja ----------------------------------------------------------------
      {? _tab<>'TECHZAMS'
      ||
         _prac:=tab_tmp(1,
            'REF','STRING[16]','$ref() zasobu',
            'SYM','STRING[50]','Symbol zasobu',
            'NAZWA','STRING[100]','Nazwa zasobu'
         );
         _zawod:=null();
         {? _tab='ZGP'
         || _zawod:=_oper.TOPER().OPER().ZAWOD
         || _zawod:=_oper.OPER().ZAWOD
         ?};

         {? _zawod<>null()
         || P.index('PRACOZAW');
            P.prefix(exec('ref_firma','ustawienia'),__F_ZATR.P,_zawod);
            {? P.first()
            || {!
               |?
                  _can_add:=1;
                  {? _can_add>0
                  ||
                     _prac.REF:=$P.ref();
                     _prac.SYM:=P.OSOBA().NAZWISKO+' '+OSOBA.PIERWSZE;
                     _prac.NAZWA:=P.ST().ST;
                     _prac.add()
                  ?};
                  P.next()
               !}
            ?}
         ?};
         {? _prac.first()
         || _it:=0;
            {!
            |?
               _res.TYP:='P';
               _res.SYM:=_prac.SYM;
               _res.NAZWA:=_prac.NAZWA;
               _res.REF:=_prac.REF;
               PL_RES.prefix('P',_prac.REF);
               {? PL_RES.first()
               || _res.REF_RES:=$PL_RES.ref();
                  _res.ALERT:=''
               || _res.REF_RES:='';
                  _res.ALERT:='R'
               ?};
               {? _it=0
               || _res.DEFAULT:='?'
               || _res.DEFAULT:='N'
               ?};
               _can_add:=0;
               _res.cntx_psh();
               _res.prefix(_res.TYP,_res.REF_RES);
               {? _res.size()=0
               || _can_add:=1
               ?};
               _res.cntx_pop();
               {? _can_add>0
               || _res.add()
               ?};
               _it+=1;
               _prac.next()
            !}
         ?};
::       4. Brygady, jezeli w ich skladzie sa pracownicy ---------------------------------------------------------------------
         _bryg:=tab_tmp(1,
            'REF','STRING[16]','$ref() zasobu',
            'SYM','STRING[50]','Symbol zasobu',
            'NAZWA','STRING[100]','Nazwa zasobu'
         );
         {? _prac.first()
         || {!
            |?
               ZLBS.index('PODB');
               _p_ref:=exec('FindAndGet','#table',P,_prac.REF,,,null());
               {? _p_ref<>null()
               ||
                  ZLBS.prefix(_p_ref);
                  {? ZLBS.first()
                  || {!
                     |?
                        _bryg.prefix($ZLBS.BR);
                        {? ~_bryg.first()
                        ||
                           _bryg.REF:=$ZLBS.BR;
                           _bryg.SYM:=ZLBS.BR().KOD;
                           _bryg.NAZWA:=ZLBR.NAZ;
                           _bryg.add()
                        ?};
                        ZLBS.next()
                     !}
                  ?}
               ?};
               _prac.next()
            !}
         ?};
         _bryg.clear();
         {? _bryg.first()
         || {!
            |?
               _res.TYP:='B';
               _res.SYM:=_bryg.SYM;
               _res.NAZWA:=_bryg.NAZWA;
               _res.REF:=_bryg.REF;
               PL_RES.prefix('B',_bryg.REF);
               {? PL_RES.first()
               || _res.REF_RES:=$PL_RES.ref();
                  _res.ALERT:=''
               || _res.REF_RES:='';
                  _res.ALERT:='R'
               ?};
               _can_add:=0;
               _res.cntx_psh();
               _res.prefix(_res.TYP,_res.REF_RES);
               {? _res.size()=0
               || _can_add:=1
               ?};
               _res.cntx_pop();
               {? _can_add>0
               || _res.add()
               ?};
               _bryg.next()
            !}
         ?};
         obj_del(_bryg);
         obj_del(_prac)
      ?};

::    Zamienniki operacji
      _toper:=null();
      {? _tab='TOPER'
      || _toper:=_oper.ref()
      |? _tab='ZGP'
      || _toper:=_oper.TOPER
      ?};

      {? _toper<>null()
      ||
         {? exec('is_zamiennik','tech_oper',_toper)=0
         ||
            TECHZAMS.cntx_psh();
            TECHZAMS.index('ATL');
            TECHZAMS.prefix('T',_toper);
            {? TECHZAMS.first()
            || {!
               |?
::                !!! REKURENCJA !!!
                  exec('get_resources','po_plan',$TECHZAMS.ref(),_ilosc,_res,'TECHZAMS',0);
                  TECHZAMS.next()
               !}
            ?};
            TECHZAMS.cntx_pop()
         ?};
         ~~
      ?};

      {? _tab='ZGP'
      || _toper:=_oper.TOPER;

         {? _toper<>null()
         ||
            {? exec('is_zamiennik','zl_guide',_oper)=1
            ||
::             Pobieram dla ZGPa, który mógł być już zamieniony oryginalne zasoby z operacji technologicznej
::             !!! REKURENCJA !!!
               exec('get_resources','po_plan',$_toper,_ilosc,_res,'TOPER',0)
            ?}
         ?}
      ?};
      ~~
   ?}
?};
TKTL.cntx_pop();
PL_RES.cntx_pop();
TWRKPLC.cntx_pop();
TWRKZBR.cntx_pop();
LPROD.cntx_pop();
_oper.cntx_pop();
_res


\plpart_to_rs
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dodaje aktualnego PL_PARTa do RS'a przekazanego w argumencie
::   WE: _a - ResultSet
::  OLD: \plpart_to_rs/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| ZK_P.cntx_psh();
   ZK_N.cntx_psh();
   ZL.cntx_psh();
   M.cntx_psh();
   TKTL.cntx_psh();
   _rs:=_a;
   _rs.REF:=$PL_PART.ref();
   _rs.REF_ZL:=$PL_PART.ZL;
   _rs.REF_ZKP:=$PL_PART.ZK_P;
   _rs.REF_TKTL:=PL_PART.RTKTL;
   _rs.REF_ZKTL:=$PL_PART.ZKTL;
   _rs.ILOSC:=PL_PART.ILOSC;
   _rs.NAZWA:=PL_PART.NAZWA;
   _rs.SYM_ZL:=PL_PART.ZL().SYM;
:: jesli tutaj zostanie zmieniony sposob nadawania symbolu to w ten sam sposob prosze zmienic w
:: PlpartGenerator.java w metodzie doInBackground(...)
   {? PL_PART.ZK_P<>null()
   ||
::    otwieram maski ZK_P i ZK_N odpowiadajaca aktualnie przetwarzanemu PL_PART
      _mask_current:=ZK_P.name();
      _mask_suff:=(ref_name(PL_PART.ZK_P)+3);
      _mask_needed:='zkpoz'+_mask_suff;
      {? _mask_current<>_mask_needed
      || ZK_N.use('zknag'+_mask_suff);
         ZK_P.use('zkpoz'+_mask_suff)
      ?};
      _rs.SYM_ZK:=PL_PART.ZK_P().N().SYM+' poz.'+$PL_PART.ZK_P().POZ+' ('+PL_PART.ZK_P().M().KTM+')'
   ?};
   _rs.REF_ZGH:=$PL_PART.ZGH;
   _rs.STARTD:=PL_PART.STARTD;
   _rs.STARTT:=PL_PART.STARTT;
   _rs.ENDD:=PL_PART.ENDD;
   _rs.ENDT:=PL_PART.ENDT;

   {? PL_PART.TM_START>0
   || _rs.PL_START:=exec('to_string','#tm_stamp',PL_PART.TM_START)
   ?};
   {? PL_PART.TM_END>0
   || _rs.PL_END:=exec('to_string','#tm_stamp',PL_PART.TM_END)
   ?};

   _rs.REF_M:=$PL_PART.M;
   _rs.PX_OBJ:=$PL_PART.PX_OBJ;
   {? PL_PART.ZL<>null()
   || _top:=exec('top_level','zl_link',PL_PART.ZL);
      _top_rodzaj:=exec('top_rodzaj','zl_link',PL_PART.ZL);
      {? _top_rodzaj='N'
      || _top:=PL_PART.ZL
      ?};
      _rs.REF_TOP:=$_top;
      _rs.SYM_TOP:=exec('FindAndGet','#table',ZL,_top,,"SYM",'');
      ~~
   ?};
   _rs.KTM:=PL_PART.M().KTM;
   _rs.KTM_NAZ:=M.N;
   {? PL_PART.TKTL<>null()
   || PL_PART.TKTL();
      _rs.TKTL_SYM:=exec('TKTL','#to_string')
   ?};
   ZK_P.cntx_pop();
   ZK_N.cntx_pop();
   ZL.cntx_pop();
   M.cntx_pop();
   TKTL.cntx_pop();
   ~~
?};
~~


\ploper_to_rs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Dodaje aktualnego PL_OPERa do RS'a przekazanego w argumencie
::   WE: _a - :RS
::   WY: 0 / 1
::  OLD: \ploper_to_rs/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? _>0
|| _tab:=_a
|| return()
?};
PL_PART.cntx_psh();
M.cntx_psh();
ZL.cntx_psh();
TTOPER.cntx_psh();
TOPER.cntx_psh();
MGR.cntx_psh();
ZGP.cntx_psh();
ZLIM.cntx_psh();
REM_ZGL.cntx_psh();
REM_PLAN.cntx_psh();
PL_EVENR.cntx_psh();
PL_EVENT.cntx_psh();
_tab.blank();
_tab.REF:=$PL_OPER.ref;
_tab.PLPART:=$PL_OPER.PL_PART;
_tab.DURATION:=PL_OPER.DURATION;
_tab.STARTD:=PL_OPER.STARTD;
_tab.ENDD:=PL_OPER.ENDD;
_tab.STARTT:=PL_OPER.STARTT;
_tab.ENDT:=PL_OPER.ENDT;
_tab.TP:=PL_OPER.TP;
_tab.TZ:=PL_OPER.TZ;
_tab.SYMBOL:=PL_OPER.SYMBOL;
_tab.OPIS:=PL_OPER.OPIS;
_tab.KOLOR:=PL_OPER.KOLOR;
_tab.OFFSET_P:=PL_OPER.OFFSET_P;
_tab.OFFSET_O:=PL_OPER.OFFSET_O;
_tab.OFFSET_U:=PL_OPER.OFFSET_U;
_tab.MINDATE:=PL_OPER.MINDATE;
_tab.MAXDATE:=PL_OPER.MAXDATE;
_tab.MINTIME:=PL_OPER.MINTIME;
_tab.MAXTIME:=PL_OPER.MAXTIME;
_tab.WHO_ADD:=PL_OPER.WHO_ADD;
_tab.WHO_MOD:=PL_OPER.WHO_MOD;
_tab.WYK:=PL_OPER.WYK;
_tab.TOPER:=PL_OPER.RTOPER;
_tab.PLANNED:=PL_OPER.PLANNED;
{? PL_OPER.TM_START>0
|| _tab.PL_START:=exec('to_string','#tm_stamp',PL_OPER.TM_START)
?};
{? PL_OPER.TM_END>0
|| _tab.PL_END:=exec('to_string','#tm_stamp',PL_OPER.TM_END)
?};
_tab.TYP:=PL_OPER.TYP;
::pozwalam na przesuwanie operacji tylko dla zwyklych operacji i rezerwacji
{? _tab.TYP='O' | _tab.TYP='R'
|| _tab.MOVEABLE:=1
|| _tab.MOVEABLE:=0
?};
_tab.ILOSC:=PL_OPER.ILOSC;
_tab.ZGP:=$PL_OPER.ZGP;
{? PL_OPER.ZGP<>null() & PL_OPER.PL_PART<>null & PL_OPER.PL_PART().ZL<>null()
|| exec('openmask','zl_common',PL_OPER.PL_PART().ZL);
   ZLIM.index('ZGP_KM');
   ZLIM.prefix(PL_OPER.ZGP);
   {? ZLIM.size()>0
   || _tab.LIMITY:='T'
   || _tab.LIMITY:='N'
   ?};
   ~~
?};

_tktl:=null();

{? PL_OPER.PL_PART().ZL<>null()
||
   _tktl:=PL_OPER.PL_PART().ZL().TKTL;
   {? _tktl=null()
   || _tktl:=PL_OPER.PL_PART().ZL().KTL
   ?}
|? PL_OPER.PL_PART().TKTL<>null()
|| _tktl:=PL_OPER.PL_PART().TKTL
?};
_toper:=null();
{? PL_OPER.ZGP<>null()
|| _toper:=PL_OPER.ZGP().TOPER
?};
{? _toper=null()
|| _toper:=PL_OPER.TOPER
?};

{? _tktl<>null() & _toper<>null()
||
   TACTTLS.cntx_psh();
   TACTTLS.index('AKNROP');

::   _util:=exec('FindAndGet','#table',TKTL,_tktl,,"TYP().UTIL",'');
   {? 1
::      _util='O'
   || TACTTLS.prefix('T',_tktl,_toper)
::   || TACTTLS.prefix('T',_tktl)
   ?};
   {? TACTTLS.size()>0
   || _tab.NPU:='T'
   || {? _toper<>null()
      || TACTTLS.prefix('T',_tktl,null());
         {? TACTTLS.size()>0
         || _tab.NPU:='T'
         ?}
      ?}
   ?};
   TACTTLS.cntx_pop()
?};

{? PL_OPER.ZGP<>null()
|| _tab.IL_NAPR:=exec('count_napr4zgp','braki',PL_OPER.ZGP)
?};

_tab.GROUPKEY:=PL_OPER.GROUPKEY;
_tab.PREVS:=exec('count_prevs_ope','po_plan',PL_OPER.ref());
_tab.NEXTS:=exec('count_nexts_ope','po_plan',PL_OPER.ref());
_tab.SYM_MIN:=PL_OPER.SYM_MIN;
_tab.SYM_MAX:=PL_OPER.SYM_MAX;
_tab.TERMIN:=exec('get_plpart_term','po_plan',PL_OPER.PL_PART);
_tab.NUM:=PL_OPER.NUM;
_tab.KTM:=PL_OPER.PL_PART().M().KTM;
_tab.JM:=M.J().KOD;
_tab.PL_SPLIT:=$PL_OPER.PL_SPLIT;
{? PL_OPER.TOPER<>null()
|| _tab.KOLOR_T:=PL_OPER.TOPER().OPER().KOLOR
|? PL_OPER.ZGP<>null()
|| _tab.KOLOR_T:=PL_OPER.ZGP().TOPER().OPER().KOLOR
?};
_tab.KOLOR_M:=M.KOLOR;
_tab.KOLOR_G:=M.MGR().KOLOR;

_tab.INFO1:=PL_OPER.SYMBOL;
{? _tab.KTM<>''
|| _tab.INFO2:=PL_OPER.OPIS+' / '+_tab.KTM
|| _tab.INFO2:=PL_OPER.OPIS
?};
_tab.INFO3:='';
_tab.SINGLE:=PL_OPER.SINGLE;
_tab.PL_EVENR:=$PL_OPER.PL_EVENR;
{? PL_OPER.PL_EVENR<>null()
|| _tab.PL_EVENT:=$PL_OPER.PL_EVENR().PL_EVENT;
   _tab.EVE_TRYB:=PL_EVENR.PL_EVENT().PL_TRYB;
   {? PL_EVENR.PL_EVENT().TM_MAX=0
   || _tab.EVE_BT:='T'
   ?};
   _tab.EVE_EAT:=exec('get','#params',500330,type_of(''));
   _tab.EVE_USE:=PL_EVENR.USABLE
?};
ZGP.cntx_pop();
TTOPER.cntx_pop();
TOPER.cntx_pop();
MGR.cntx_pop();
ZL.cntx_pop();
PL_PART.cntx_pop();
M.cntx_pop();
ZLIM.cntx_pop();
REM_ZGL.cntx_pop();
REM_PLAN.cntx_pop();
PL_EVENR.cntx_pop();
PL_EVENT.cntx_pop();
~~


\ploz_to_rs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Dodaje aktualnego PL_OZa do RS'a przekazanego w argumencie
::   WE: _a - :RS
::   WY: 0 / 1
::  OLD: \ploz_to_rs/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? _>0
|| _tab:=_a
|| return()
?};
PL_EVENR.cntx_psh();
PL_EVENT.cntx_psh();
PL_OPER.cntx_psh();
PL_RES.cntx_psh();
_tab.REF:=$PL_OZ.ref();
_tab.PLOPER:=$PL_OZ.PL_OPER;
{? PL_OZ.PL_OPER<>null()
|| _tab.PLPART:=$PL_OZ.PL_OPER().PL_PART;
   {? PL_OPER.PL_EVENR<>null()
   || _tab.WYKFORCE:=PL_OPER.PL_EVENR().PL_EVENT().WYK
   ?}
?};
_tab.PLRES:=$PL_OZ.PL_RES;
_tab.PLRESSYM:=PL_OZ.PL_RES().SYM;
_tab.PLRESNAZ:=PL_OZ.PL_RES().NAZ;
_tab.KONFPLUG:=PL_OZ.memo_txt(,1,'KONFPLUG');
PL_OPER.cntx_pop();
PL_RES.cntx_pop();
PL_EVENR.cntx_pop();
PL_EVENT.cntx_pop();
~~


\get_plpart_term
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca termin realizacji dla podanego PL_PARTA
::   WE: _a - PL_PART.ref()
::   WY: STRING - termin realizacji w formacie 'YYYY/MM/DD HH:MM:SS'
::  OLD: \get_plpart_term/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_plpart:=_a;

_result:='';

ZL.cntx_psh();
PL_PART.cntx_psh();
PL_PART.clear();
{? PL_PART.seek(_plpart)
|| {? PL_PART.ZL<>null()
   || PL_PART.ZL();
      _result:=exec('zlec_termin2','px_tie')
   |? PL_PART.ZK_P<>null()
   || _result:=exec('zkp_termin','px_tie',$PL_PART.ZK_P)
   ?}
?};
ZL.cntx_pop();
PL_PART.cntx_pop();
_result


\ploz_tm_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Aktualizacja TM_START i TM_STOP na PL_OZ'ach do PL_OPERa
::   WE: _a - PL_OPER.ref()
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::  OLD: \ploz_tm_update/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
PL_OPER.cntx_psh();
PL_OZ.cntx_psh();
PL_OZ.clear();
PL_OZ.index('PL_OPER');
PL_OZ.prefix(_a);

_can_continue:=1;
{? PL_OZ.first()
|| _start:=PL_OZ.PL_OPER().TM_START;
   _stop:=PL_OZ.PL_OPER().TM_END;
   {!
   |?
      PL_OZ.TM_START:=_start;
      PL_OZ.TM_END:=_stop;
      _can_continue:=PL_OZ.put(1);

      {? _can_continue>0
      || PL_CONF.cntx_psh();
         PL_CONF.index('PL_OZ');
         PL_CONF.prefix(PL_OZ.ref());
         {? PL_CONF.first()
         || {!
            |? PL_CONF.TM_START:=_start;
               PL_CONF.TM_END:=_stop;
               _can_continue:=PL_CONF.put();
               PL_CONF.next() & _can_continue>0
            !}
         ?};
         PL_CONF.cntx_pop()
      ?};
      PL_OZ.next() & _can_continue>0
   !}
?};
PL_OZ.cntx_pop();
PL_OPER.cntx_pop();
~~


\lock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2009]
:: OPIS: Blokada tabel planow okresowych.
::       Ustawia zmienna VAR.PL_BLK:='T' jezeli ktos inny blokuje
::   WE: _a - UD_SKL.ref()
::       _b - czy bez dialogow (1 - wysylane do KOMMa / 0 - wyswietlane)
::       _c - opcjonalny identyfikator sesji
::   WY: _result - czy kontynuowac (0 / 1)
::  OLD: \bl_okr/pl_okr.fml
::----------------------------------------------------------------------------------------------------------------------
_no_display:=_b;
_session_id:='';
{? _>2
|| _session_id:=_c
?};
KAL_UD.index('KAL');
KAL_UD.prefix(_a);
{? ~KAL_UD.first()
|| _sym:=exec('FindAndGet','#table',UD_SKL,_a,,"SYMBOL",'');
   FUN.emsg('Nieprzypisany widok planu operacyjnego do wydziału: %1.\nNależy uzupełnić parametryzację systemu.'@[_sym]);
   return(0)
?};

_result:=0;
BLK.index('AMR');
BLK.prefix('KAL_UD',KAL_UD.name(),#KAL_UD.ref());
{? ~BLK.first()
|| BLK.ACR:='KAL_UD';
   BLK.MSK:=KAL_UD.name();
   BLK.REF:=#KAL_UD.ref();
   BLK.SES_ID:=KAL_UD.ses_id();
   _result:=BLK.add()
|| _result:=1
?};
{? _result
|| {? BLK.r_lock(1,1,1)
   || BLK.SES_ID:=KAL_UD.ses_id();
      BLK.put();
      VAR.PL_BLK:='N'
   ||
:: jesli identyfikator sesji rozny od zapisu w tabeli BLK to znaczy ze ktos inny niz ja blokuje
      {? _session_id<>BLK.SES_ID
      || {? _no_display
         ||
            KOMM.sect_beg('Wydział: '+KAL_UD.UD_SKL().SYMBOL);
            KOMM.add('Plan okresowy wydziału został wcześniej zablokowany','xwin16.png:9');
            KOMM.add('Praca na planie wydziału możliwa jedynie w trybie podglądu','xwin16.png:9');
            _usersym:=KAL_UD.ses_info(BLK.SES_ID,'log_name');
            USERS.cntx_psh();
            USERS.clear();
            USERS.index('USR_KKOD');
            USERS.prefix(_usersym,_usersym);
            {? USERS.first()
            || _userdata:=USERS.DANE
            || _userdata:=''
            ?};
            USERS.cntx_pop();
            KOMM.sect_beg('Blokuje użytkownik: '+_usersym);
            KOMM.add('Pełna nazwa: '+_userdata,'xwin16.png:76');
            KOMM.add('Terminal: '+KAL_UD.ses_info(BLK.SES_ID,'log_tty'),'xwin16.png:76');
            _session_start:=$KAL_UD.ses_info(BLK.SES_ID,'log_date')+' - ';
            _session_start+=$KAL_UD.ses_info(BLK.SES_ID,'log_time');
            KOMM.add('Zalogowany od: '+_session_start,'xwin16.png:76');
            KOMM.sect_end();
            KOMM.sect_end();
            _result:=0
         ||
            _msg:='Plan jest redagowany przez użytkownika \''+KAL_UD.ses_info(BLK.SES_ID,'log_name')+'\' ';
            _msg+='na terminalu \''+KAL_UD.ses_info(BLK.SES_ID,'log_tty')+'\'.\n\n';
            _msg+='Istnieje możliwość wyświetlenia planu w trybie podglądu.\n\n';
            _choice:=FUN.choice(_msg,,'Podgląd');
            {? _choice>0
            || _result:=1
            || _result:=0
            ?}
         ?};
         VAR.PL_BLK:='T'
::    jesli to ja sam sobie blokuje, to nie wyswietlam komunikatow i ustawiam zmiennna VAR.PL_BLK
      || VAR.PL_BLK:='N';
         _result:=1
      ?}
   ?}
|| VAR.PL_BLK:='T'
?};
_result


\unlock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2009]
:: OPIS: Zwolnienie blokady tabel planow okresowych.
::   WE: _a - UD_SKL.ref()
::  OLD: \zw_okr/pl_okr.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.PL_BLK='N'
||
   KAL_UD.index('KAL');
   KAL_UD.prefix(_a);
   {? ~KAL_UD.first() || return() ?};

   BLK.index('AMR');
   BLK.prefix('KAL_UD',KAL_UD.name(),#KAL_UD.ref());
   {? BLK.first()
   || BLK.r_unlock();
      BLK.del()
   ?}
?};
VAR.PL_BLK:='N';
~~


\zlec2rs
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dodaje zlecenie do RSa
::       Kontekst pracy - zlecenie ktore dodac
::       UWAGA - przyjeto zalozenie ze tabela RS ma ustawiony indeks ktorego pierwszym polem jest UN_ZL
::   WE: _a - RS - czyli tabela tymczasowa
::       _b - STRING - filtr
::       _c - INTEGER - skad brac kolor
::       _d - STRING - czy pobierac zlecenia zaplanowane czy nie: A - wszystkie, P - zaplanowane, N - niezaplanowane
::       _e - STRING - indeks tymczasowy RSa: UN_ZL
::       _f - STRING - indeks tymczasowy RSa: ID
::       _g - STRING - zakres pobieranych zleceń: ALL - wszystkie, REPLAN - wymagające doplanowania
::       [_h] - INTEGER - id parenta, 0 jeżeli nie podano
::   WY: 0 - zlecenie nie zostalo dodane do RSa
::       INTEGER>0 - ID w RS dodanego zlecenia
::  OLD: \zlec2rs/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_rs:=_a;
_filter:=_b;
_kolor_mode:=_c;
_plan_mode:=_d;
_ndx_un:=_e;
_ndx_id:=_f;
_scope:=_g;
_parent:=0;
{? var_pres('_h')=type_of(0)
|| _parent:=_h
?};

_result:=0;
_can_continue:=1;

_rs.cntx_psh();
_rs.clear();

::{? _check_added>0
::|| _rs.prefix(ZL.UNRZL);
::   {? _rs.size()>0
::   || _can_continue:=0
::   ?}
::?};

{? _parent>0
|| _rs.prefix(_parent,ZL.UNRZL);
   {? _rs.first()
   || _can_continue:=0;
      _result:=_rs.ID
   ?};
   _rs.prefix()
||
   _rs.prefix(ZL.UNRZL);
   {? _rs.size()>0
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: Sprawdzam czy zlecenie przejdzie filtr
   _can_continue:=exec('zlec_filter','po_plan',_filter);

   {? _can_continue>0
   || _can_continue:=exec('can_load_zlec','po_plan')
   ?};

   {? _can_continue>0
   ||
      _can_continue:=0;
      _planned:=exec('zlec_planned','po_plan',$ZL.ref());
      _top_level:=exec('top_level','zl_link',ZL.ref());
      _interzlec:=exec('interzlec_conns','po_plan',$ZL.ref(),_top_level);

      _replan:=0;
      {? _plan_mode='A'
      || _can_continue:=1;

         {? _planned>0 & _scope='REPLAN'
         || _replan:=exec('zlec_replan','po_plan');
            _can_continue:=_replan
         ?}

      |? _plan_mode='P'
      || {? _planned>0
         || _can_continue:=1;

            {? _scope='REPLAN'
            || _replan:=exec('zlec_replan','po_plan');
               _can_continue:=_replan
            ?}
         ?}
      |? _plan_mode='N'
      || _top_rodzaj:=exec('top_rodzaj','zl_link',ZL.ref());
         {? (_top_rodzaj='Z' | ZL.RODZAJ='Z') & _interzlec='T'
         || _top_planned:=exec('zlec_planned','po_plan',$_top_level);
            {? _top_planned=0
            || _can_continue:=1
            ?}
         |? _planned<ZL.IL | ZL.IL=0
         || _can_continue:=1
         ?};

         {? _planned>0 & _scope='REPLAN'
         || _replan:=exec('zlec_replan','po_plan')
         ?}
      ?};
      {? _can_continue>0
      ||
::       Jesli nie ma jeszcze takiego to dodaje
         _rs.blank();

         {? ZL.NRNZL<>0
         ||
::          Najpierw dodaje zlecenie nadrzedne
            ZL.cntx_psh();
            ZL.index('UNRZL');
            ZL.prefix(ZL.NRNZL);
            {? ZL.first()
            ||
::             !!! REKURENCJA !!!
               _par_rec:=exec('zlec2rs','po_plan',_rs,_filter,_kolor_mode,_plan_mode,_ndx_un,_ndx_id,_scope,_parent);

               {? _par_rec=0
               ||
                  _rs.cntx_psh();
                  _rs.prefix(ZL.UNRZL);
                  {? _rs.first()
                  || _par_rec:=_rs.ID
                  ?};
                  _rs.cntx_pop()
               ?};
               {? _par_rec>0
               || _parent:=_par_rec
               ?}
            ?};
            ZL.cntx_pop();
            _rs.LEVEL:=2
         || _rs.LEVEL:=1
         ?};

         _rs.GROP_OK:=1;
         _rs.GROP_OK2:=1;
         _rs.REF_M:=$ZL.KTM;

::       Podczytanie tabeli M
         _rs.DOKL:=ZL.KTM().DOKL;
         _rs.REF:=$ZL.ref();
         _rs.UN_ZL:=ZL.UNRZL;
         _rs.KTM:=M.KTM;

         _rs.cntx_psh();
         _rs.clear();
         _id:=_rs.size()+1;
         _rs.cntx_pop();

         _rs.ID:=_id;
         _rs.PAR:=_parent;
         _rs.SYM:=ZL.SYM;
         _rs.NAZWA:=ZL.OPIS;

::       Podczytanie kontrahenta
         _rs.KH:=ZL.KH().SKR;

         _rs.ILOSC:=ZL.IL;

         _rs.DZATW:=ZL.DZATW;
         _rs.GENPRZEW:=ZL.GENPRZEW;
         _rs.PROCENT:=0;
         _rs.ZATWOSOB:=ZL.ZATW().DANE;

         {? ZL.KTM<>null()
         || _rs.PRODUKT:=M.KTM+' ('+M.N+')';
            _rs.JM:=M.J().KOD
         ?};
         _rs.REF_TOP:=$_top_level;
         {? exec('has_grop_zl','po_ogr',ZL.ref())>0
         || _rs.PL_GROP:='T';
            _rs.GROP_OK:=exec('can_plan','po_ogr',ZL.ref());
            _rs.GROP_OK2:=exec('can_plan2','po_ogr',ZL.ref())
         || _rs.PL_GROP:='N'
         ?};
         _rs.PART_IL:=exec('zl_ile_part','zl_partie',ZL.ref());

         {? _kolor_mode=1
         || _rs.KOLOR_B:=KH.KOLOR
         |? _kolor_mode=2
         || _kolor:='255:255:255';
            ZLZAM.cntx_psh();
            ZK_P.cntx_psh();
            ZK_N.cntx_psh();
            ZLZAM.index('ZLZM');
            ZLZAM.clear();
            ZLZAM.prefix(ZL.ref());
            _maskzkn:=ZK_N.name();
            {? ZLZAM.first()
            || {!
               |? {? (5+ZLZAM.ZAMPOZ)=(5+ZK_P.name())
                  || ZK_P.clear();
                     {? ZK_P.seek(ZLZAM.ZAMPOZ,8+ZLZAM.ZAMPOZ)
                     || ZK_N.use((5+_maskzkn)+((8+ZLZAM.ZAMPOZ)+3));
                        _kolor:=ZK_P.N().KOLOR
                     ?}
                  ?};
                  ZLZAM.next()
               !}
            ?};
            ZLZAM.cntx_pop();
            ZK_N.cntx_pop();
            ZK_P.cntx_pop();
            _rs.KOLOR_B:=_kolor
         |? _kolor_mode=3
         || _rs.KOLOR_B:=M.MGR().KOLOR
         ?};

         _rs.STAN:=ZL.STAN;
         _rs.PLPARTS:=exec('count_plparts','po_plan','ZL',$ZL.ref());
         _rs.ZGHCOUNT:=exec('count_zgh','po_plan',$ZL.ref());

         _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
         {? _px_obj<>null()
         || _il_queue:=exec('get_ilosc_que','px_obj',exec('get_mainversion','px_ver'),_px_obj);
            {? _il_queue>0
            || _rs.MPS:=_il_queue;

::             Nanosze ilosc z planu strateg na nadzlecenie
               {? _parent>0
               || _rs.cntx_psh();
                  _rs.index(_ndx_id);
                  _rs.prefix(_parent);
                  {? _rs.first()
                  || _rs.MPS+=_il_queue;
                     _rs.put()
                  ?};
                  _rs.cntx_pop();
                  ~~
               ?}
            ?}
         ?};

         _tm_start:=exec('zlec_start','px_tie',ZL.ref(),_top_level);
         _tm_end:=exec('zlec_end','px_tie',ZL.ref(),_top_level);
         {? _tm_start>0
         || _rs.MPSSTART:=exec('to_string','#tm_stamp',_tm_start)
         ?};
         {? _tm_end>0
         || _rs.MPSEND:=exec('to_string','#tm_stamp',_tm_end)
         ?};

         {? _rs.MPSSTART<>'' | _rs.MPSEND<>'' & _parent>0
         ||
::          Nanosze terminy z planu stateg. na nadzlecenie
            _rs.cntx_psh();
            _rs.index(_ndx_id);
            _rs.prefix(_parent);
            {? _rs.first()
            ||
               _nad_s:=exec('str2tm_stamp','libfml',_rs.MPSSTART);
               _nad_e:=exec('str2tm_stamp','libfml',_rs.MPSEND);
               {? _nad_s=0 | _tm_start<_nad_s
               || _rs.MPSSTART:=exec('to_string','#tm_stamp',_tm_start)
               ?};
               {? _nad_e=0 | _tm_end>_nad_e
               || _rs.MPSEND:=exec('to_string','#tm_stamp',_tm_end)
               ?};
               _rs.put()
            ?};
            _rs.cntx_pop()
         ?};

         _subzlec:=exec('subzlec_exist','zl_link',ZL.ref());
         _rs.TERMIN:=exec('zlec_termin2','px_tie');

         _rs.ILOSC_PL:=_planned;
         _rs.REPLAN:=_replan;
         _rs.INTERZL:=_interzlec;
         {? exec('zl_single_plan','po_plan')>0
         || _rs.SINGLE:='T'
         || _rs.SINGLE:='N'
         ?};
         {? _subzlec>0
         || _rs.TYP:='ZL_N'
         || _rs.TYP:='ZL_P'
         ?};
         {? _planned>0
         || _tm_start:=exec('tm_start_zl','po_plan',$ZL.ref());
            _tm_end:=exec('tm_end_zl','po_plan',$ZL.ref());
            {? _tm_start>0
            || _rs.PL_START:=(tm_form(_tm_start)-10)
            ?};
            {? _tm_end>0
            || _rs.PL_END:=(tm_form(_tm_end)-10)
            ?}
         ?};
::       Dodawanie rekordu do RSa
         {? _rs.add()
         || _result:=_rs.ID
         || _result:=0
         ?}
      ?}
   ?}
?};
_rs.cntx_pop();
_result


\zlec_filter
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy zlecenie moze wejsc do RSa - czy pasuje do przekazanego filtra
::       Kontekst pracy - zlecenie ktore sprawdzac
::   WE: _a - STRING - filtrujacy ciag znakow
::   WY: 0 - zlecenie nie pasuje do filtra
::       1 - zlecenie pasuje do filtra
::  OLD: \zlec_filter/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_filter:=_a;

_result:=0;

{? _filter='%' | _filter=''
|| _result:=1
||
:: Podczytuje pole po ktorych bede filtrowal
   ZL.KH();
   ZL.KTM();
   ZL.ZATW();

:: Sprawdzam po kolei pola
   {? KH.SKR*_filter>0
   || _result:=1
   ?};

   {? _result=0
   || {? KH.NAZ*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? ZL.SYM*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? ZL.OPIS*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? M.KTM*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? M.N*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? USERS.DANE*_filter>0
      || _result:=1
      ?}
   ?};
   ~~
?};
_result


\zgp2rs
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.46]
:: OPIS: Dodaje pozycje przewodnika zlecenia do RSa
::       Kontekst pracy - zlecenie ktorego pozycje dodac
::       UWAGA - przyjeto zalozenie ze tabela RS ma ustawiony indeks ktorego pierwszym polem jest UN_ZL
::   WE: _a - RS - czyli tabela tymczasowa
::       _b - STRING - filtr
::       _c - STRING - czy pobierac zlecenia zaplanowane czy nie: A - wszystkie, P - zaplanowane, N - niezaplanowane
::       _d - STRING - indeks unikalny RSa
::   WY: 0 - zlecenie nie zostalo dodane do RSa
::       INTEGER>0 - ID w RS dodanej pozycji przewodnika
::  OLD: \zgp2rs/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_rs:=_a;
_filter:=_b;
_plan_mode:=_c;
_ndx_uniq:=_d;

_result:=0;
_can_continue:=1;

_rs.cntx_psh();
_rs.index(_ndx_uniq);
_rs.clear();

_parent:=0;

ZL.cntx_psh();
ZGP.cntx_psh();
ZGP.index('STATUS');
ZGH.cntx_psh();
ZGH.index('ZLNR');
ZGH.prefix(ZL.ref());
NASZGP.cntx_psh();
NASZGP.index('NASTOP');

{? _can_continue>0
||
   {? ZGH.first()
   ||
      {!
      |? ZGP.prefix(ZGH.ref(),'N');
         {? ZGP.first()
         ||
            {!
            |?
               _can_continue:=1;
               {? ZGP.WEW='T' & ZGP.PL_GRP<>'T'
               ||
                  _rs.blank();
                  _status:=ZGP.STATUS;

                  _can_continue:=0;
::                obsluga TPZ
                  ZGP.cntx_psh();
                  ZGP.index('TPZ');
                  _stat_tpz:='';
                  ZGP.prefix('T',ZGP.UID);
                  {? ZGP.first()
                  || _stat_tpz:=ZGP.STATUS;
                     _rs.TP:=ZGP.NTIME*60
                  ?};
                  ZGP.cntx_pop();
                  {? _stat_tpz='O' & _status<>'O'
                  || _status:='O'
                  ?};

                  {? _status='O'
                  ||
                     _planned:=exec('zgp_planned','po_plan',ZGP.ref());
                     _to_plan:=0;
::                   Zwracam ilosc ktora moge zaplanowac na operacji na podstawie rejestracji
::                   wykonan z poprzednich operacji
                     {? var_pres('_il_wyk')>100
                     || obj_del(_il_wyk)
                     ?};
                     _il_wyk:=exec('il_pop','zl_guide',ZGP.ref());
                     {? _il_wyk.MAX>0
                     || _to_plan:=_il_wyk.IL_POP
                     || _to_plan:=ZGP.ILOSC
                     ?};

                     {? _plan_mode='A'
                     || _can_continue:=1
                     |? _plan_mode='P'
                     || {? _planned>0
                        || _can_continue:=1
                        ?}
                     |? _plan_mode='N'
                     ||
                        {? _planned<_to_plan
                        || _can_continue:=1
                        ?}
                     ?};
                     _parent:=0;
                     {? _can_continue>0
                     || _rs.prefix($ZGP.ref());
                        {? _rs.size()>0
                        || _can_continue:=0
                        ?}
                     ?};
                     {? _can_continue>0
                     || _can_continue:=exec('zgp_filter','po_plan',_filter)
                     ?};

                     {? _can_continue>0
                     ||

                        _rs.GROP_OK:=1;
                        _rs.GROP_OK2:=1;
                        _rs.REF_M:=$ZL.KTM;

::                      Podczytanie tabeli M
                        _rs.DOKL:=ZL.KTM().DOKL;
                        _rs.REF:=$ZGP.ref();
                        _rs.KTM:=M.KTM;

                        _rs.cntx_psh();
                        _rs.clear();
                        _id:=_rs.size()+1;
                        _rs.cntx_pop();

                        _rs.ID:=_id;
                        _rs.PAR:=_parent;
                        _rs.SYM:=ZL.SYM;
                        _rs.ZLECSYM:=ZL.SYM;
                        _rs.ZL:=$ZL.ref();
                        _rs.NAZWA:=ZL.OPIS;
                        _rs.OPER:=$ZGP.NRP+'. '+ZGP.OPIS;
                        _rs.ZGHSYM:=ZGH.NRPRZ;
                        _rs.ZGH:=$ZGH.ref();
                        _rs.NRP:=ZGP.NRP;

::                      Podczytanie kontrahenta
                        _rs.KH:=ZL.KH().SKR;

                        _rs.ILOSC:=_to_plan;

                        _rs.GENPRZEW:=ZL.GENPRZEW;

                        {? ZL.KTM<>null()
                        || _rs.PRODUKT:=M.N;
                           _rs.JM:=M.J().KOD
                        ?};
                        _top:=exec('top_level','zl_link',ZL.ref());
                        _rs.REF_TOP:=$_top;
                        _rs.SYM_TOP:=exec('FindAndGet','#table',ZL,_top,,"SYM",'');
                        {? exec('has_grop_zl','po_ogr',ZL.ref())>0
                        || _rs.PL_GROP:='T';
                           _rs.GROP_OK:=exec('can_plan','po_ogr',ZL.ref());
                           _rs.GROP_OK2:=exec('can_plan2','po_ogr',ZL.ref())
                        || _rs.PL_GROP:='N'
                        ?};
                        _rs.PART_IL:=exec('zgh_ile_part','zl_partie',ZGH.ref());

                        _rs.PLPARTS:=exec('count_plparts','po_plan','ZGH',$ZGH.ref());
                        _rs.ZGHCOUNT:=1;

                        _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
                        {? _px_obj<>null()
                        || _il_queue:=exec('get_ilosc_que','px_obj',exec('get_mainversion','px_ver'),_px_obj);
                           {? _il_queue>0
                           || _rs.MPS:=_il_queue
                           ?}
                        ?};

                        _tm_start:=exec('zgp_start','px_tie');
                        _tm_end:=exec('zgp_end','px_tie');
                        {? _tm_start>0
                        || _rs.MPSSTART:=exec('to_string','#tm_stamp',_tm_start)
                        ?};
                        {? _tm_end>0
                        || _rs.MPSEND:=exec('to_string','#tm_stamp',_tm_end)
                        ?};

                        _subzlec:=exec('subzlec_exist','zl_link',ZL.ref());
                        _rs.TERMIN:=exec('zlec_termin2','px_tie');

                        _rs.ILOSC_PL:=_planned;
                        _inter:=exec('interzlec_conns','po_plan',$ZL.ref());
                        _rs.INTERZL:=_inter;
                        _rs.TYP:='ZGP';
                        {? _planned>0
                        || _tm_start:=exec('tm_start_zgp','po_plan');
                           _tm_end:=exec('tm_end_zgp','po_plan');
                           {? _tm_start>0
                           || _rs.PL_START:=(tm_form(_tm_start)-10)
                           ?};
                           {? _tm_end>0
                           || _rs.PL_END:=(tm_form(_tm_end)-10)
                           ?}
                        ?};
                        _duration:=0;
                        {? ZGP.MTIME>0
                        || _duration:=ZGP.MTIME*60
                        |? ZGP.NTIME>0
                        || _duration:=ZGP.NTIME*60
                        ?};
                        _rs.DUR_MIN:=_duration;

::                      Ilość poprzedników - od tego zależy czy podczas planowania
::                      pojawi się pytanie o czas startu
                        NASZGP.prefix(ZGP.ref());
                        _rs.PREVIL:=NASZGP.size();

                        _tp_dur:=_rs.TP;
                        _tz_dur:=_rs.TZ;

::                      Dodawanie rekordu do RSa
                        {? _rs.add()
                        || _result:=_rs.ID
                        || _result:=0
                        ?}
                     ?}
                  ?}
               ?};
               ZGP.next()
            !}
         ?};
         ZGH.next()
      !}
   ?}
?};
NASZGP.cntx_pop();
ZGH.cntx_pop();
ZGP.cntx_pop();
ZL.cntx_pop();
_rs.cntx_pop();
_result


\zgp_filter
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.46]
:: OPIS: Sprawdza czy pozycja przewodnika moze wejsc do RSa - czy pasuje do przekazanego filtra
::       Kontekst pracy - przewodnik ktory sprawdzac
::   WE: _a - STRING - filtrujacy ciag znakow
::   WY: 0 - pozycja przewodnika nie pasuje do filtra
::       1 - pozycja przewodnika pasuje do filtra
::  OLD: \zgp_filter/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_filter:=_a;

_result:=0;

ZGP.cntx_psh();
ZGH.cntx_psh();
{? _filter='%' | _filter=''
|| _result:=1
||
:: Podczytuje pole po ktorych bede filtrowal
   ZGP.NRZLP();
   ZL.KH();
   ZL.KTM();
   ZL.ZATW();

:: Sprawdzam po kolei pola
   {? KH.SKR*_filter>0
   || _result:=1
   ?};

   {? _result=0
   || {? KH.NAZ*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? ZL.SYM*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? ZL.OPIS*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? M.KTM*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? M.N*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? USERS.DANE*_filter>0
      || _result:=1
      ?}
   ?};
   {? ZGP.OPIS*_filter>0
   || _result:=1
   ?};

   {? _result=0
   || {? ZGH.NRPRZ*_filter>0
      || _result:=1
      ?}
   ?};
   ~~
?};
ZGP.cntx_pop();
ZGH.cntx_pop();
_result


\zkp2rs
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Dodaje do RSa pozycje zamowienia o ile takiej jeszcze nie bylo
::       Kontekst pracy - rekord ZK_P
::       UWAGA - przyjeto zalozenie ze tabela RS ma ustawiony indeks ktorego pierwszym polem jest REF
::   WE: _a - RS - czyli tabela tymczasowa
::       _b - STRING - filtr
::       _c - INTEGER - skad brac kolor
::       _d - STRING - czy pobierac zamowienia zaplanowane czy nie: A - wszystkie, P - zaplanowane, N - niezaplanowane
::       _e - INTEGER - ID parenta czyli RS.ID naglowka zamowienia
::   WY: 0 - zamowienie nie zostalo dodane do RSa
::       INTEGER>0 - ID w RS dodanego zamowienia
::  OLD: \zkp2rs/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_rs:=_a;
_filter:=_b;
_kolor_mode:=_c;
_plan_mode:=_d;
_parent:=_e;

_result:=0;
_can_continue:=1;

_rs.cntx_psh();
_rs.clear();

_id:=_rs.size()+1;

_rs.prefix($ZK_P.ref());

{? _rs.size()=0
||
:: Najpierw sprawdzam czy ZK_P spelnia warunki brzegowe
   _can_continue:=0;
   {? (ZK_P.M().R='W' | ZK_P.M().R='P') & (ZK_P.ILP-ZK_P.ILRB)>0 &
      (ZK_P.TOP=1)
   || _can_continue:=1
   ?};

   {? _can_continue>0
   ||
::    Sprawdzam czy zamowienie przejdzie filtr
      _can_continue:=exec('zkp_filter','po_plan',_filter);

      {? _can_continue>0
      ||
         _can_continue:=0;
         _planned:=exec('zam_planned','po_plan',$ZK_P.ref());
         {? _plan_mode='A'
         || _can_continue:=1
         |? _plan_mode='P'
         || {? _planned>0
            || _can_continue:=1
            ?}
         |? _plan_mode='N'
         || {? _planned<ZK_P.ILZ
            || _can_continue:=1
            ?}
         ?};
         {? _can_continue>0
         ||
::          Jesli nie ma jeszcze takiego to dodaje
            _rs.blank();

::          Podczytuje naglowek
            ZK_P.N();

            _rs.REF:=$ZK_P.ref();
            _rs.REF_M:=$ZK_P.M;

::          Podczytanie M
            _rs.DOKL:=ZK_P.M().DOKL;
            _rs.ID:=_id;
            _rs.LEVEL:=2;
            _rs.PAR:=_parent;
            _rs.SYM:=ZK_N.SYM+' poz. '+$ZK_P.POZ+' ('+M.KTM+')';
            _rs.ZAM_SYM:=ZK_N.SYM;
            _rs.NAZWA:=M.N;
            _rs.ZAM_KL:=ZK_N.ZAM_KL;
            _rs.KTM:=M.KTM;

::          Podczytanie kontrahenta
            _rs.KH:=ZK_N.KH().SKR;
            _rs.ILOSC:=ZK_P.ILP-ZK_P.ILRB;
            {? _kolor_mode=1
            || _rs.KOLOR_B:=KH.KOLOR
            |? _kolor_mode=2
            || _rs.KOLOR_B:=ZK_N.KOLOR
            |? _kolor_mode=3
            || _rs.KOLOR_B:=ZK_P.M().MGR().KOLOR
            ?};
            _rs.AKC:=ZK_N.AKC;
            _rs.TYP:='ZK_P';
            _rs.PLPARTS:=exec('count_plparts','po_plan','ZM',$ZK_P.ref());
            _rs.ZKP_POZ:=ZK_P.POZ;
            _rs.ZKP_KTM:=M.KTM;
            _rs.JM:=M.J().KOD;

            _px_obj:=exec('get_zkp_object','px_obj',ZK_P.ref());
            {? _px_obj<>null()
            || _il_queue:=exec('get_ilosc_que','px_obj',exec('get_mainversion','px_ver'),_px_obj);
               {? _il_queue>0
               || _rs.MPS:=_il_queue
               ?}
            ?};

            _tm_start:=exec('zkp_start','px_tie',ZK_P.ref());
            _tm_end:=exec('zkp_end','px_tie',ZK_P.ref());
            {? _tm_start>0
            || _rs.MPSSTART:=exec('to_string','#tm_stamp',_tm_start)
            ?};
            {? _tm_end>0
            || _rs.MPSEND:=exec('to_string','#tm_stamp',_tm_end)
            ?};
            _rs.SAVE_B:=0;
            _rs.TERMIN:=exec('zkp_termin','px_tie',$ZK_P.ref());
            _rs.ILOSC_PL:=_planned;

::          Dla zamówień sprawdzamy czy zostaly juz na ich podstawie wygenerowane zlecenia
            ZLZAM.cntx_psh();
            ZLZAM.clear();
            ZLZAM.index('ZMZL');
            ZLZAM.prefix($ZK_P.ref());
            _rs.ZLECENIA:=ZLZAM.size();
            ZLZAM.cntx_pop();

            {? _planned>0
            || _tm_start:=exec('tm_start_zkn','po_plan',$ZK_P.N);
               _tm_end:=exec('tm_end_zkn','po_plan',$ZK_P.N);
               {? _tm_start>0
               || _rs.PL_START:=(tm_form(_tm_start)-10)
               ?};
               {? _tm_end>0
               || _rs.PL_END:=(tm_form(_tm_end)-10)
               ?}
            ?};

            {? _rs.add()
            || _result:=_rs.ID
            || _result:=0
            ?}
         ?}
      ?}
   ?}
?};

_rs.cntx_pop();
_result


\zkn2rs
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Dodaje do RSa naglowek zamowienia o ile takiego jeszcze nie bylo
::       Kontekst pracy - rekord ZK_N
::       UWAGA - przyjeto zalozenie ze tabela RS ma ustawiony indeks ktorego pierwszym polem jest REF
::   WE: _a - RS - czyli tabela tymczasowa
::       _b - STRING - filtr
::       _c - INTEGER - skad brac kolor
::       _d - STRING - czy pobierac zamowienia zaplanowane czy nie: A - wszystkie, P - zaplanowane, N - niezaplanowane
::   WY: 0 - zamowienie nie zostalo dodane do RSa
::       INTEGER>0 - ID w RS dodanego zamowienia
::  OLD: \zkn2rs/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_rs:=_a;
_filter:=_b;
_kolor_mode:=_c;
_plan_mode:=_d;

_result:=0;
_can_continue:=1;

_rs.cntx_psh();
_rs.clear();

_id:=_rs.size()+1;

_rs.prefix($ZK_N.ref());

{? _rs.size()=0
||
:: Najpierw sprawdzam czy ZK_N spelnia warunki brzegowe
   _can_continue:=0;

   {? (ZK_N.AKC='T' & ZK_N.A='A') &
      (ZK_N.STAN<>'ZRE')
   || _can_continue:=1
   ?};

   {? _can_continue>0
   ||
::    Sprawdzam czy zamowienie przejdzie filtr
      _can_continue:=exec('zkn_filter','po_plan',_filter);

      {? _can_continue>0
      ||
         _can_continue:=0;

         _planned:=exec('zkn_planned','po_plan',ZK_N.ref());
         {? _plan_mode='A'
         || _can_continue:=1
         |? _plan_mode='P'
         ||
            {? _planned>0
            || _can_continue:=1
            ?}
         |? _plan_mode='N'
         ||
            _plan_all:=exec('zkn_planned_all','po_plan',ZK_N.ref());
            {? _plan_all=0
            || _can_continue:=1
            ?}
         ?};
         {? _can_continue>0
         ||
            _rs.blank();
            _rs.REF:=$ZK_N.ref();
            _rs.REF_M:='';
            _rs.ID:=_id;
            _rs.LEVEL:=1;
            _rs.PAR:=0;
            _rs.SYM:=ZK_N.SYM;
            _rs.ZAM_SYM:=ZK_N.SYM;
            _rs.NAZWA:=ZK_N.ZAM_KL;
            _rs.ZAM_KL:=ZK_N.ZAM_KL;

::          Podczytanie kontrahenta
            _rs.KH:=ZK_N.KH().SKR;
            _rs.ILOSC:=0;
            _rs.DTERMIN:=ZK_N.DT;
            _rs.PROCENT:=ZK_N.PR;
            _rs.HAN:=ZK_N.HAN().NAZ;
            {? _kolor_mode=1
            || _rs.KOLOR_B:=KH.KOLOR
            |? _kolor_mode=2
            || _rs.KOLOR_B:=ZK_N.KOLOR
            |? _kolor_mode=3
            || _rs.KOLOR_B:='255:255:255'
            ?};
            _rs.AKC:=ZK_N.AKC;
            _rs.TYP:='ZK_N';

            {? _planned>0
            || _tm_start:=exec('tm_start_zkn','po_plan',$ZK_N.ref());
               _tm_end:=exec('tm_end_zkn','po_plan',$ZK_N.ref());
               {? _tm_start>0
               || _rs.PL_START:=(tm_form(_tm_start)-10)
               ?};
               {? _tm_end>0
               || _rs.PL_END:=(tm_form(_tm_end)-10)
               ?}
            ?};
            {? _rs.add()
            || _result:=_rs.ID
            || _result:=0
            ?}
         ?}
      ?}
   ?}
?};

_rs.cntx_pop();
_result


\zkp_filter
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy pozycja zamowienia moze wejsc do RSa - czy pasuje do przekazanego filtra
::       Kontekst pracy - ZK_P ktory sprawdzac
::   WE: _a - STRING - filtrujacy ciag znakow
::   WY: 0 - zamowienie nie pasuje do filtra
::       1 - zamowienie jest zgodne z filtrem
::  OLD: \zkp_filter/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_filter:=_a;

_result:=0;

{? _filter='%' | _filter=''
|| _result:=1
||
:: Podczytuje pole po ktorych bede filtrowal
   ZK_P.N().KH();
   ZK_P.N().HAN();
   ZK_P.M();

:: Sprawdzam po kolei pola
   {? KH.SKR*_filter>0
   || _result:=1
   ?};

   {? _result=0
   || {? KH.NAZ*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? ZK_N.SYM*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? ZK_N.ZAM_KL*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? M.KTM*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? M.N*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? HAN.NAZ*_filter>0
      || _result:=1
      ?}
   ?};
   ~~
?};
_result


\zkn_filter
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy naglowek zamowienia moze wejsc do RSa - czy pasuje do przekazanego filtra
::       Kontekst pracy - ZK_N ktory sprawdzac
::   WE: _a - STRING - filtrujacy ciag znakow
::   WY: 0 - zamowienie nie pasuje do filtra
::       1 - zamowienie jest zgodne z filtrem
::  OLD: \zkn_filter/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_filter:=_a;

_result:=0;

{? _filter='%' | _filter=''
|| _result:=1
||
:: Podczytuje pole po ktorych bede filtrowal
   ZK_N.KH();
   ZK_N.HAN();

:: Sprawdzam po kolei pola
   {? KH.SKR*_filter>0
   || _result:=1
   ?};

   {? _result=0
   || {? KH.NAZ*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? ZK_N.SYM*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? ZK_N.ZAM_KL*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? HAN.NAZ*_filter>0
      || _result:=1
      ?}
   ?};
   ~~
?};
_result


\zgp_planned
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Sprawdza czy pozycja przewodnika została już zaplanowana
::   WE: [_a] - ZGP.ref lub bieżący rekord
::       [_b] - INTEGER - co sprawdzać: [0] - sprawdzać czy istnieją PL_OPERY
::                                       1 - sprawdzać czy istnieją PL_OZy
::   WY: REAL - ile zostało zaplanowane
::  OLD: \zgp_planned/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};
_mode:=0;
{? var_pres('_b')=type_of(0)
|| _mode:=_b
?};

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
{? _ref<>null()
|| ZGP.clear();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PL_OZ.cntx_psh();
   PL_OZ.index('PL_OPER');
   PL_OPER.cntx_psh();
   PL_OPER.index('ZGP');
   PL_OPER.prefix(ZGP.ref());
   {? PL_OPER.first()
   || {!
      |? _add:=0;
         {? _mode=1
         ||
            PL_OZ.prefix(PL_OPER.ref());
            {? PL_OZ.size()>0
            || _add:=1
            ?}
         || _add:=1
         ?};
         {? _add>0
         || _result+=PL_OPER.ILOSC
         ?};
         PL_OPER.next()
      !}
   ?};
   PL_OPER.cntx_pop();
   PL_OZ.cntx_pop()
?};
ZGP.cntx_pop();
_result


\zlec_replan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Sprawdza czy zlecenie trzeba doplanować tzn czy są jakieś pozycje przewodnika których nie ma w planie
::   WE: [_a] - $ZL.ref lub bieżący rekord
::   WY: 0 - zlecenie nie ma żadnych pozycji przewodnika które byłyby niezaplanowane
::       1 - zlecenie ma pozycje przewodnika które są niezaplanowane
::  OLD: \zlec_replan/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zlec:='';
{? _>0
|| _zlec:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _zlec<>''
|| ZL.clear();
   {? ZL.seek(_zlec)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

ZGP.cntx_psh();
ZGH.cntx_psh();
ZGH.index('ZLNR');
ZGP.index('PNRPP');
{? _can_continue>0
||
   {? ZL.RODZAJ<>'P'
   ||
::    jesli zlecenie zlozone to sprawdzam czy jego podrzedne sa zaplanowane (!!rekurencja!!)
      ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.clear();
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |?
::          !!! REKURENCJA !!!
            _result:=exec('zlec_replan','po_plan');
            ZL.next() & _result=0
         !}
      ?};
      ZL.cntx_pop()
   ||
::    zlecenie proste, sprawdzam czy jego wszystkie przewodniki są zaplanowane
      ZGH.prefix(ZL.ref());
      {? ZGH.first()
      || {!
         |?
            ZGP.prefix(ZGH.ref(),'N');
            {? ZGP.first()
            || {!
               |?
                  {? ZGP.PLANUJ='T' & exec('zgp_planned','po_plan',,1)=0
                  || _result:=1
                  ?};
                  ZGP.next() & _result=0
               !}
            ?};
            ZGH.next() & _result=0
         !}
      ?}
   ?}
?};
ZGH.cntx_pop();
ZGP.cntx_pop();
ZL.cntx_pop();
_result


\count_zgh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zlicza ile przewodnikow ma zlecenie
::   WE: _a - $ZL.ref()
::   WY: INTEGER - ilosc przewodnikow (ZGH)
::  OLD: \count_zgh/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0
|| return(0)
?};
_ref:=_a;
_result:=0;
ZL.cntx_psh();
ZL.clear();
ZGH.cntx_psh();
ZGH.clear();
ZGH.index('ZLNR');
{? ZL.seek(_ref)
|| ZGH.prefix(ZL.ref());
   _result:=ZGH.size()
?};
ZL.cntx_pop();
ZGH.cntx_pop();
_result


\zl_single_plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Sprawdza czy zlecenie albo którekolwiek z jego podzleceń zostało zaplanowane
::   WE: [_a] - ZL.ref lub aktualny rekord
::   WY: 0 - brak operacji zaplanowanych pojedynczo
::       1 - są operacje zaplanowane pojedynczo
::  OLD: \zl_single_plan/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.clear();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PL_PART.cntx_psh();
   PL_PART.index('ZL_START');
   PL_OPER.cntx_psh();
   PL_OPER.index('PL_PART');
   PL_PART.prefix(ZL.ref());
   {? PL_PART.first()
   || {!
      |? PL_OPER.prefix(PL_PART.ref());
         {? PL_OPER.first()
         || {!
            |?
               {? PL_OPER.SINGLE='T'
               || _result:=1
               ?};
               PL_OPER.next() & _result=0
            !}
         ?};
         PL_PART.next()
      !}
   ?};
   PL_PART.cntx_pop();
   PL_OPER.cntx_pop();

   {? _result=0
   ||
      ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |?
::          !!! REKURENCJA !!!
            _result:=exec('zl_single_plan','po_plan');
            ZL.next() & _result=0
         !}
      ?};
      ZL.cntx_pop()
   ?};
   ~~
?};
ZL.cntx_pop();
_result


\tm_start_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Zwraca czas startu pozycji przewodnika w planie
::   WE: [_a] - ZGP.ref lub bieżący rekord
::   WY: REAL - ile zostało zaplanowane
::  OLD: \tm_start_zgp/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
{? _ref<>null()
|| ZGP.clear();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PL_OPER.cntx_psh();
   PL_OPER.index('ZGPSTART');
   PL_OPER.prefix(ZGP.ref());
   {? PL_OPER.first()
   || {!
      |? {? PL_OPER.TM_START>0
         || _result:=PL_OPER.TM_START
         ?};
         PL_OPER.next() & _result=0
      !}
   ?};
   PL_OPER.cntx_pop()
?};
ZGP.cntx_pop();
_result


\tm_end_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Zwraca czas końca pozycji przewodnika w planie
::   WE: [_a] - ZGP.ref lub bieżący rekord
::   WY: REAL - ile zostało zaplanowane
::  OLD: \tm_end_zgp/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
{? _ref<>null()
|| ZGP.clear();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PL_OPER.cntx_psh();
   PL_OPER.index('ZGPEND');
   PL_OPER.prefix(ZGP.ref());
   {? PL_OPER.last()
   || _result:=PL_OPER.TM_END
   ?};
   PL_OPER.cntx_pop()
?};
ZGP.cntx_pop();
_result


\zkn_planned
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy zamowienie ma jakakolwiek pozycje zaplanowana
::   WE: _a - ZK_N.ref()
::   WY: 0 - brak pozycji zaplanowanych
::       1 - sa zaplanowane jakies ZK_Py
::  OLD: \zkn_planned/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zkn:=_a;

_result:=0;
_can_continue:=1;

ZK_N.cntx_psh(); ZK_N.clear();
ZK_N.clear();
ZK_P.cntx_psh();
ZK_P.index('NAG');

PL_PART.cntx_psh();
PL_PART.index('ZK_P');

{? ZK_N.seek(_zkn)
||
   ZK_P.prefix(ZK_N.ref());
   {? ZK_P.first()
   || {!
      |? {? ZK_P.TOP=1
         ||
            PL_PART.prefix(ZK_P.ref());
            {? PL_PART.first()
            || _result:=1;
               _can_continue:=0
            ?}
         ?};
         ZK_P.next() & _can_continue>0
      !}
   ?}
?};
ZK_N.cntx_pop();
PL_PART.cntx_pop();
ZK_P.cntx_pop();
_result


\zkn_planned_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy wszystkie pozycje zamowienia sa zaplanowane
::   WE: _a - ZK_N.ref()
::   WY: 0 - zamowienie nie jest w calosci zaplanowane
::       1 - zamowienie w calosci zaplanowane
::  OLD: \zkn_planned_all/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zkn:=_a;

_result:=0;
_can_continue:=1;

M.cntx_psh();
ZK_N.cntx_psh(); ZK_N.clear();
ZK_N.clear();
ZK_P.cntx_psh();
ZK_P.index('NAG');

PL_PART.cntx_psh();
PL_PART.index('ZK_P');

{? ZK_N.seek(_zkn)
||
   ZK_P.prefix(ZK_N.ref());
   {? ZK_P.first()
   ||
      _result:=1;
      {!
      |? {? ZK_P.TOP=1 & (ZK_P.M().R='W' | ZK_P.M().R='P')
         ||
            PL_PART.prefix(ZK_P.ref());
            {? PL_PART.first()=0
            || _result:=0;
               _can_continue:=0
            ?}
         ?};
         ZK_P.next() & _can_continue>0
      !}
   ?}
?};
ZK_N.cntx_pop();
PL_PART.cntx_pop();
ZK_P.cntx_pop();
M.cntx_pop();
_result


\zgh_planned
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca ilosc zaplanowana dla ZGH
::   WE: _a - ZGH.ref()
::   WY: REAL - ilosc w planie operacyjnym
::  OLD: \zgh_planned/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_zgh:=_a;

_result:=0;

ZGH.cntx_psh(); ZGH.clear();
PL_PART.cntx_psh();
PL_PART.index('ZGH');
{? ZGH.seek(_zgh)
|| PL_PART.prefix(ZGH.ref());
   {? PL_PART.first()
   || {!
      |? _result+=PL_PART.ILOSC;
         PL_PART.next()
      !}
   ?}
?};
PL_PART.cntx_pop();
ZGH.cntx_pop();
_result


\zlim2rs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Dodaje limit do RSa
::   WE: _a - RS do którego dodać limit
::       [_b] - ZLIM.ref lub bieżący rekord
::  OLD: \zlim2rs/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_rs:=_a;
_ref:=null();
{? var_pres('_b')=type_of(ZLIM.ref())
|| _ref:=_b
?};

_result:=0;
_can_continue:=1;

ZK_N.cntx_psh();
ZK_P.cntx_psh(); ZK_P.clear();
ZLIM.cntx_psh();
M.cntx_psh();
ZGH.cntx_psh();
ZGP.cntx_psh();
JM.cntx_psh();
{? _ref<>null()
|| ZLIM.clear();
   {? ZLIM.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _rs.REF:=$ZLIM.ref();
   _rs.LIM:=ZLIM.LIMIT;
   _rs.KTM:=ZLIM.KTM().KTM;
   _rs.KTM_NAZ:=M.N;
   _rs.ILOSC:=exec('sum_il','zl_limit',ZLIM.ref());
   _rs.JM:=M.J().KOD;
   _rs.NR:=ZLIM.NR;
   _rs.ZGH:=ZLIM.ZGP().NRZLP().NRPRZ;
   _rs.OPER:=ZGP.OPIS;
   {? ZLIM.KOR>0 | ZLIM.KOR2>0
   || _rs.KOR:='T'
   || _rs.KOR:='N'
   ?};
   _rs.UWAGI:='';

   {? ZLIM.KTM<>null()
   || exec('obl_stan','magazyn_stan',ZLIM.KTM,6);
      _rs.SD:=BEER.SD;
      ~~
   ?};
   _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
   {? _zk_p<>null()
   || REZ.cntx_psh();
      REZ.index('ZK_P');
      REZ.prefix(_zk_p);
      {? REZ.first()
      || {!
         |? {? REZ.RODZ='B'
            || _rs.SR+=REZ.ILR
            |? REZ.RODZ='W'
            || _rs.SRC+=REZ.ILR
            ?};
            REZ.next()
         !}
      ?};
      REZ.cntx_pop();
      ~~
   ?};
   ~~
?};
M.cntx_pop();
ZGH.cntx_pop();
ZGP.cntx_pop();
JM.cntx_pop();
ZLIM.cntx_pop();
ZK_P.cntx_pop();
ZK_N.cntx_pop();
~~


\npu2rs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Dodaje NPU do RSa
::   WE: _a - RS do którego dodać limit
::       [_b] - TACTTLS.ref lub bieżący rekord
::----------------------------------------------------------------------------------------------------------------------
_rs:=_a;
_ref:=null();
{? var_pres('_b')=type_of(ZLIM.ref())
|| _ref:=_b
?};

_result:=0;
_can_continue:=1;

TACTTLS.cntx_psh();
M.cntx_psh();
JM.cntx_psh();
{? _ref<>null()
|| TACTTLS.clear();
   {? TACTTLS.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _rs.REF:=$TACTTLS.ref();
   _rs.KTM:=TACTTLS.M().KTM;
   _rs.KTM_NAZ:=M.N;
   _rs.GRUPA:=M.MGR().NAZ;
   _rs.ILOSC:=TACTTLS.ILE;
   _rs.JM:=M.J().KOD;
   _rs.ZXJM:=TACTTLS.ZXJM;
   _rs.ZH:=TACTTLS.ZH;
   exec('npu_rodz','tech_tool');
   {? VAR1.NPU='N'
   || _rs.KIND:='Narzędzie'
   |? VAR1.NPU='P'
   || _rs.KIND:='Przyrząd'
   |? VAR1.NPU='U'
   || _rs.KIND:='Urządzenie'
   || _rs.KIND:='Inne'
   ?};
   ~~
?};
M.cntx_pop();
JM.cntx_pop();
TACTTLS.cntx_pop();
~~


\trig_ploper_ab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger dla tabeli PL_OPER (przed add)
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_OPER='T'
|| return(1)
?};
{? PL_OPER.TOPER<>null()
|| PL_OPER.RTOPER:=$PL_OPER.TOPER
?};
_zerod:=date(0,0,0);
{? PL_OPER.STARTD>_zerod
||
   PL_OPER.TM_START:=tm_stamp(PL_OPER.STARTD~1,
                              PL_OPER.STARTD~2,
                              PL_OPER.STARTD~3,
                              PL_OPER.STARTT~1,
                              PL_OPER.STARTT~2,
                              PL_OPER.STARTT~3,
                              0)
?};

{? PL_OPER.ENDD>_zerod
||
   PL_OPER.TM_END:=tm_stamp(  PL_OPER.ENDD~1,
                              PL_OPER.ENDD~2,
                              PL_OPER.ENDD~3,
                              PL_OPER.ENDT~1,
                              PL_OPER.ENDT~2,
                              PL_OPER.ENDT~3,
                              0)
?};

{? PL_OPER.MAXDATE>_zerod
||
   PL_OPER.TM_MAX:=tm_stamp(  PL_OPER.MAXDATE~1,
                              PL_OPER.MAXDATE~2,
                              PL_OPER.MAXDATE~3,
                              PL_OPER.MAXTIME~1,
                              PL_OPER.MAXTIME~2,
                              PL_OPER.MAXTIME~3,
                              0)
?};

{? PL_OPER.MINDATE>_zerod
||
   PL_OPER.TM_MIN:=tm_stamp(  PL_OPER.MINDATE~1,
                              PL_OPER.MINDATE~2,
                              PL_OPER.MINDATE~3,
                              PL_OPER.MINTIME~1,
                              PL_OPER.MINTIME~2,
                              PL_OPER.MINTIME~3,
                              0)
?};
1


\trig_ploper_aa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger dla tabeli PL_OPER (po add)
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_OPER='T'
|| return()
?};
~~


\trig_ploper_pb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger dla tabeli PL_OPER (przed put)
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_OPER='T'
|| return(1)
?};

{? PL_OPER.TOPER<>null()
|| PL_OPER.RTOPER:=$PL_OPER.TOPER
?};
_zerod:=date(0,0,0);
{? PL_OPER.STARTD>_zerod
||
   PL_OPER.TM_START:=tm_stamp(PL_OPER.STARTD~1,
                              PL_OPER.STARTD~2,
                              PL_OPER.STARTD~3,
                              PL_OPER.STARTT~1,
                              PL_OPER.STARTT~2,
                              PL_OPER.STARTT~3,
                              0)
?};

{? PL_OPER.ENDD>_zerod
||
   PL_OPER.TM_END:=tm_stamp(  PL_OPER.ENDD~1,
                              PL_OPER.ENDD~2,
                              PL_OPER.ENDD~3,
                              PL_OPER.ENDT~1,
                              PL_OPER.ENDT~2,
                              PL_OPER.ENDT~3,
                              0)
?};

{? PL_OPER.MAXDATE>_zerod
||
   PL_OPER.TM_MAX:=tm_stamp(  PL_OPER.MAXDATE~1,
                              PL_OPER.MAXDATE~2,
                              PL_OPER.MAXDATE~3,
                              PL_OPER.MAXTIME~1,
                              PL_OPER.MAXTIME~2,
                              PL_OPER.MAXTIME~3,
                              0)
?};

{? PL_OPER.MINDATE>_zerod
||
   PL_OPER.TM_MIN:=tm_stamp(  PL_OPER.MINDATE~1,
                              PL_OPER.MINDATE~2,
                              PL_OPER.MINDATE~3,
                              PL_OPER.MINTIME~1,
                              PL_OPER.MINTIME~2,
                              PL_OPER.MINTIME~3,
                              0)
?};
1


\trig_ploper_pa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger dla tabeli PL_OPER (po put)
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_OPER='T'
|| return()
?};
~~


\trig_ploper_db
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger dla tabeli PL_OPER (przed del)
::   WE:
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_OPER='T'
|| return(1)
?};
1


\trig_ploper_da
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger dla tabeli PL_OPER (po del)
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_OPER='T'
|| return()
?};
~~


\trig_plpart_ab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger dla tabeli PL_PART (przed add)
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_PART='T'
|| return(1)
?};
{? PL_PART.TKTL<>null()
|| PL_PART.RTKTL:=$PL_PART.TKTL
?};
PL_PART.TM_START:=tm_stamp(PL_PART.STARTD~1,
                           PL_PART.STARTD~2,
                           PL_PART.STARTD~3,
                           PL_PART.STARTT~1,
                           PL_PART.STARTT~2,
                           PL_PART.STARTT~3,
                           0);

PL_PART.TM_END:=tm_stamp(  PL_PART.ENDD~1,
                           PL_PART.ENDD~2,
                           PL_PART.ENDD~3,
                           PL_PART.ENDT~1,
                           PL_PART.ENDT~2,
                           PL_PART.ENDT~3,
                           0);
1


\trig_plpart_aa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger dla tabeli PL_PART (po add)
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_PART='T'
|| return()
?};
~~


\trig_plpart_pb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger dla tabeli PL_PART (przed put)
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_PART='T'
|| return(1)
?};

{? PL_PART.TKTL<>null()
|| PL_PART.RTKTL:=$PL_PART.TKTL
?};
PL_PART.TM_START:=tm_stamp(PL_PART.STARTD~1,
                           PL_PART.STARTD~2,
                           PL_PART.STARTD~3,
                           PL_PART.STARTT~1,
                           PL_PART.STARTT~2,
                           PL_PART.STARTT~3,
                           0);

PL_PART.TM_END:=tm_stamp(  PL_PART.ENDD~1,
                           PL_PART.ENDD~2,
                           PL_PART.ENDD~3,
                           PL_PART.ENDT~1,
                           PL_PART.ENDT~2,
                           PL_PART.ENDT~3,
                           0);
1


\trig_plpart_pa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger dla tabeli PL_PART (po put)
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_PART='T'
|| return()
?};
~~


\trig_plpart_db
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger dla tabeli PL_PART (przed del)
::   WE:
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_PART='T'
|| return(1)
?};
1


\trig_plpart_da
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger dla tabeli PL_PART (po del)
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_PART='T'
|| return()
?};
~~


\plres_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2011]
:: OPIS: Uaktualnia podany w argumencie zasob, o ile go znajdzie
::   WE: _a - Ref SQL Linii produkcyjnej, stanowiska, gniazda, brygady, pracownika, wydzialu
::  OLD: \plres_update/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:='';
{? _>0
|| _ref:=_a
|| return()
?};
_res:=0;
PL_RES.cntx_psh();
PL_RES.index('REF');
PL_RES.prefix(_ref,_ref);
{? PL_RES.first()
||
:: gniazdo produkcyjne
   {? PL_RES.TYP='G'
   || TWRKZBR.cntx_psh();
      TWRKZBR.clear();
      {? TWRKZBR.seek(_ref)
      || PL_RES.SYM:=TWRKZBR.SYMBOL;
         PL_RES.NAZ:=TWRKZBR.NAZWA;
         PL_RES.KAL_NAZW:=TWRKZBR.KAL;
         PL_RES.WYD:=TWRKZBR.WYD().KOD;
         _res:=PL_RES.put()
      ?};
      TWRKZBR.cntx_pop()
   ?};
:: stanowisko produkcyjne
   {? PL_RES.TYP='S'
   || TWRKPLC.cntx_psh();
      TWRKPLC.clear();
      {? TWRKPLC.seek(_ref)
      || PL_RES.SYM:=TWRKPLC.KOD;
         PL_RES.NAZ:=TWRKPLC.NA;
         PL_RES.KAL_NAZW:=TWRKPLC.KAL;
         PL_RES.WYD:=TWRKPLC.WYD().KOD;
         _res:=PL_RES.put()
      ?};
      TWRKPLC.cntx_pop()
   ?};
:: brygada pracownicza
   {? PL_RES.TYP='B'
   || ZLBR.cntx_psh();
      ZLBR.clear();
      {? ZLBR.seek(_ref)
      || PL_RES.SYM:=ZLBR.KOD;
         PL_RES.NAZ:=ZLBR.NAZ;
         PL_RES.KAL_NAZW:=ZLBR.KAL;
         _res:=PL_RES.put()
      ?};
      ZLBR.cntx_pop()
   ?};
:: pracownik
   {? PL_RES.TYP='P'
   || P.cntx_psh();
      P.clear();
      {? P.seek(_ref)
      || PL_RES.SYM:=P.OSOBA().NAZWISKO+' '+P.OSOBA().PIERWSZE;
         PL_RES.NAZ:=P.ST().ST;
         PL_RES.KAL_NAZW:=P.KAL;
         PL_RES.WYD:=P.WYDZIAL().SYMBOL;
         _res:=PL_RES.put()
      ?};
      P.cntx_pop()
   ?};
:: wydzial
   {? PL_RES.TYP='W'
   || SLO.cntx_psh();
      SLO.index('SL');
      SLO.clear();
      UD_SKL.cntx_psh();
      UD_SKL.clear();
      {? UD_SKL.seek(_ref)
      || SLO.prefix(XINFO.SLWYDZIA,UD_SKL.SYMBOL,);
         _kal:=exec('get_kal_nazwa','po_plan',_ref,'W');
         PL_RES.SYM:=SLO.KOD;
         PL_RES.NAZ:=SLO.TR;
         PL_RES.WYD:=SLO.KOD;
         KAL_NAZW.cntx_psh();
         KAL_NAZW.clear();
         {? KAL_NAZW.seek(_kal[2])
         || PL_RES.KAL_NAZW:=KAL_NAZW.ref()
         ?};
         KAL_NAZW.cntx_pop();
         _res:=PL_RES.put()
      ?};
      UD_SKL.cntx_pop();
      SLO.cntx_pop()
   ?};
:: Aktualizacja zasobow w planie strategicznym
   {? _res & exec('tpp_lic','tpp')='T'
   || exec('plres2pxkonts','px_kont',PL_RES.ref())
   ?};
:: Aktualizacja widoków planu operacyjnego
   {? _res
   || PL_OPIS.cntx_psh();
      PL_OPIS.index('PL_RES');
      PL_OPIS.prefix(PL_RES.ref());
      {? PL_OPIS.first()
      || {!
         |? PL_OPIS.OPIS:=PL_RES.SYM;
            PL_OPIS.put();
            PL_OPIS.next()
         !}
      ?};
      PL_OPIS.cntx_pop()
   ?}
?};
PL_RES.cntx_pop();
~~


\pl_oper_koop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Czy PL_OPER kooperacyjny
::       Funkcja dziala na biezacym buforze tabeli PL_OPER
::   WY: 0 / 1
::  OLD: \pl_oper_koop/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
{? PL_OPER.ZGP<>null()
|| _res:=(PL_OPER.ZGP().WEW='N')
|? PL_OPER.TOPER<>null()
|| _res:=(PL_OPER.TOPER().WEW='N')
?};
_res


\plres_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.14]
:: OPIS: Po redagowaniu w tabeli PL_RES
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_fld:=cur_afld();
{? _fld='PARALLEL'
|| exec('plres_grayed','po_plan')
?};
~~


\plres_grayed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.14]
:: OPIS: Wyszarzator pól w oknie wertowania PLRES
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
{? PL_RES.PARALLEL='1'
|| PL_RES.efld_opt(cur_win(),'enable=1',,'LAYERS')
|| PL_RES.efld_opt(cur_win(),'enable=0',,'LAYERS')
?};
~~


\plan_generator
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.14]
:: OPIS: Generuje plan operacyjny - od teraz w przyszłość.
::       Służy do szybkiego wygenerowania danych do mierzenia wydajności
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_loops:=1;

__PARSES.setEnv('TPP');
exec('init','tpp');
KOMM.init(250,,'Generowanie planu operacyjnego (demo)');

_can_continue:=1;

:: Pytanie o datę startową
_startd:=exec('edit_date','#edit',date(),'Generuj plan od:');
{? type_of(_startd)<>type_of(date())
|| _can_continue:=0
?};

:: Pytanie o ilosć zleceń
{? _can_continue>0
|| _loops:=exec('edit_number','#edit',_loops,'Ilość zleceń do wygenerowania i zaplanowania',0);
   {? type_of(_loops)<>type_of(0)
   || _can_continue:=0
   ?}
?};

_ilosc:=0;
:: Pytanie o ilość na każdym zleceniu
{? _can_continue>0
|| _ilosc:=exec('edit_number','#edit',_ilosc,'Ilość na każdym zleceniu',0);
   {? type_of(_ilosc)<>type_of(0)
   || _can_continue:=0
   ?}
?};

PL_PART.cntx_psh();
PL_OPER.cntx_psh();
PL_OZ.cntx_psh();
PL_RES.cntx_psh();
PL_RES.clear();
ZL.cntx_psh();

TKTL.cntx_psh();
TKTL.clear();
_nrk:='';
{? _can_continue>0
|| _nrk:=exec('tktl_f3','sql','*')
?};
exec('add_ref','zl_gen');
{? _can_continue>0 & _nrk<>'' & _loops>0 & _ilosc>0
||
:: Na czas generowania wyłączam triggery
   exec('trig_PL_OPER','prod_rej',0);
   exec('trig_PL_OZ','prod_rej',0);
   exec('trig_PL_NEXT','prod_rej',0);

   _times:=tab_tmp(3,
      'TOPER','STRING[16]','Nazwa pola 1',
      'TM_END','REAL','Nazwa pola 2',
      'ENDD','DATE','Nazwa pola 2',
      'ENDT','TIME','Nazwa pola 2'
   );

   _args:=exec('gen_zlec_a','zl_gen');
   _args.KTM:=TKTLW.KTM().KTM;
   _args.DTR:=date()+100;
   _args.ILOSC:=_ilosc;
   _args.ZTP:=exec('ztp_select','zl_head','P');
   _args.ZL_NAD:=null();
   _args.KH:='';
   _args.TKTL:=TKTL.ref();
   _args.RODZAJ:='';
   _args.PL_DATA:=date(0,0,0);
   _args.PL_TIME:=time(0,0,0);
   _args.PL_DIR:=1;
   _args.PL_FORCE:='N';
   _args.DK_C:='';
   _args.MG:=null();
   _args.COMPLEX:='P';
   _args.GRP_KEY:='';

   VAR.TYMCZAS:='generator danych planu operacyjnego';

   _can_continue:=1;
   {! _it:=1.._loops
   |? _can_continue>0
   |! _zl:=exec('gen_zlec','zl_gen',_args);

      {? _zl<>null()
      ||
         _techdata:=proc_exe('gettechdata@po_plope',$TKTLW.KTM,$TKTLW.TKTL,_args.ILOSC,'T',$_zl,'ZL_P','Plpart generowany');
         _i2:=_techdata.ndx_tmp('',1,'TYP',,0, 'NUM',,0);
         _i3:=_techdata.ndx_tmp('',1,'TYP',,0, 'PAR',,0);
         _i4:=_techdata.ndx_tmp('',1,'TYP',,0, 'ID',,0);
         _techdata.index(_i2);
         {? _techdata.first()
         || PL_PART.blank();
            PL_PART.ZL:=_zl;
            PL_PART.ILOSC:=_args.ILOSC;
            PL_PART.TKTL:=TKTL.ref();
            PL_PART.NAZWA:='Plpart generowany';
            PL_PART.M:=TKTLW.KTM;
            PL_PART.RTKTL:=$TKTL.ref();
            _can_continue:=PL_PART.add();

            {? _can_continue>0
            ||
               _techdata.prefix('O');
               {? _techdata.first()
               || _start:=exec('create','#tm_stamp',_startd,time(0,0,0));
                  {!
                  |? PL_OPER.prefix();
                     PL_OPER.blank();
                     PL_OPER.PL_PART:=PL_PART.ref();
                     PL_OPER.DURATION:=_techdata.DURATION+_techdata.TP+_techdata.TZ;
                     PL_OPER.TP:=_techdata.TP;
                     PL_OPER.TZ:=_techdata.TZ;
                     PL_OPER.SYMBOL:=_techdata.PLO_SYM;
                     PL_OPER.OPIS:=_techdata.PLO_OPIS;
                     PL_OPER.KOLOR:=exec('kolor_rand','#color');
                     PL_OPER.TOPER:=exec('FindAndGet','#table',TOPER,_techdata.TOPER);
                     PL_OPER.PLANNED:='T';
                     PL_OPER.TYP:='O';
                     PL_OPER.ILOSC:=_args.ILOSC;
                     PL_OPER.NUM:=_techdata.NUM;
                     PL_OPER.RTOPER:=_techdata.TOPER;
                     PL_OPER.UID:=exec('uid','#blank');

                     _times.prefix(_techdata.TOPER);
                     {? _times.first()
                     || {? _times.TM_END>=_start
                        ||
                           PL_OPER.STARTD:=_times.ENDD;
                           PL_OPER.STARTT:=_times.ENDT;
                           PL_OPER.TM_START:=_times.TM_END
                        || PL_OPER.STARTD:=exec('tm_stamp2date','#tm_stamp',_start);
                           PL_OPER.STARTT:=exec('tm_stamp2time','#tm_stamp',_start);
                           PL_OPER.TM_START:=_start
                        ?};

                        PL_OPER.TM_END:=PL_OPER.TM_START+(PL_OPER.DURATION*exec('minute','#tm_stamp'));
                        PL_OPER.ENDD:=exec('tm_stamp2date','#tm_stamp',PL_OPER.TM_END);
                        PL_OPER.ENDT:=exec('tm_stamp2time','#tm_stamp',PL_OPER.TM_END);

                        _times.TM_END:=PL_OPER.TM_END;
                        _times.ENDD:=PL_OPER.ENDD;
                        _times.ENDT:=PL_OPER.ENDT;

                        _times.put()
                     ||
                        PL_OPER.TM_START:=_start;
                        PL_OPER.STARTD:=exec('tm_stamp2date','#tm_stamp',_start);
                        PL_OPER.STARTT:=exec('tm_stamp2time','#tm_stamp',_start);

                        PL_OPER.TM_END:=PL_OPER.TM_START+(PL_OPER.DURATION*exec('minute','#tm_stamp'));
                        PL_OPER.ENDD:=exec('tm_stamp2date','#tm_stamp',PL_OPER.TM_END);
                        PL_OPER.ENDT:=exec('tm_stamp2time','#tm_stamp',PL_OPER.TM_END);

                        _times.blank();
                        _times.TOPER:=$PL_OPER.TOPER;
                        _times.TM_END:=PL_OPER.TM_END;
                        _times.ENDD:=PL_OPER.ENDD;
                        _times.ENDT:=PL_OPER.ENDT;
                        _times.add()
                     ?};
                     _can_continue:=PL_OPER.add();

                     {? _can_continue>0
                     || _start:=PL_OPER.TM_END;

::                      W ZOPER będę trzymał ref utworzonego PL_OPERa żeby móc wygenerować PL_NEXTy
                        _techdata.ZOPER:=$PL_OPER.ref();
                        _techdata.put();

                        _techdata.cntx_psh();
                        _techdata.index(_i3);
                        _techdata.prefix('R',_techdata.ID);
                        _break:=0;
                        {? _techdata.first()
                        || {!
                           |? {? _techdata.REF_RES<>''
                              || {? PL_RES.seek(_techdata.REF_RES) & PL_RES.TYP='S'
                                 || PL_OZ.blank();
                                    PL_OZ.PL_OPER:=PL_OPER.ref();
                                    PL_OZ.PL_RES:=PL_RES.ref();
                                    PL_OZ.TM_START:=PL_OPER.TM_START;
                                    PL_OZ.TM_END:=PL_OPER.TM_END;
                                    _can_continue:=PL_OZ.add();
                                    {? _can_continue>0
                                    || _break:=1
                                    ?}
                                 ?}
                              ?};
                              _techdata.next() & _can_continue>0 & _break=0
                           !}
                        ?};
                        _techdata.cntx_pop();
                        ~~
                     ?};
                     _techdata.next() & _can_continue>0
                  !};

                  PL_OPER.cntx_psh();
                  PL_OPER.index('NUM');
                  _techdata.index(_i2);
                  _techdata.prefix('O');
                  {? _techdata.first()
                  || {!
                     |? {? _techdata.ID_NEXT<>''
                        || _plo_src:=_techdata.ZOPER;
                           {? var_pres('_split')>100
                           || obj_del(_split)
                           ?};
                           _split:=spli_str(_techdata.ID_NEXT,';');
                           _spli_size:=obj_len(_split);
                           {? _spli_size>0
                           || {! _num:=1.._spli_size
                              |!
                                 _next_id:=#_split[_num];
                                 {? _next_id>=0
                                 ||
                                    _techdata.cntx_psh();
                                    _techdata.index(_i4);
                                    _techdata.prefix('O',_next_id);
                                    {? _techdata.first()
                                    || _plo_dest:=_techdata.ZOPER;
                                       PL_NEXT.prefix();
                                       PL_NEXT.blank();
                                       PL_NEXT.NEXT:=exec('FindAndGet','#table',PL_OPER,_plo_dest,,,null());
                                       PL_NEXT.PL_OPER:=exec('FindAndGet','#table',PL_OPER,_plo_src,,,null());
                                       _can_continue:=PL_NEXT.add();
                                       {? _can_continue>0
                                       || exec('next_tm_oper','po_plan',PL_NEXT.PL_OPER)
                                       ?}
                                    ?};
                                    _techdata.cntx_pop()
                                 ?}
                              !}
                           ?}
                        ?};
                        _techdata.next() & _can_continue>0
                     !}
                  ?};
                  PL_OPER.cntx_pop()
               ?};
               exec('plpart_date_upd','po_plan',PL_PART.ref())
            ?}
         ?};
         _techdata.ndx_drop(_i2);
         _techdata.ndx_drop(_i3);
         _techdata.ndx_drop(_i4);
         obj_del(_techdata)
      ?}
   !};

:: Po generowaniu włączam z powrotem trigerry
   exec('ustaw_trigger','prod_rej')

?};
KOMM.select();
TKTL.cntx_pop();

PL_PART.cntx_pop();
PL_OPER.cntx_pop();
PL_OZ.cntx_pop();
PL_RES.cntx_pop();
ZL.cntx_pop();
~~


\kaldef_conflict
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy nie nastąpi konflikt bieżącego KAL_DEFa z takim który już został dodany do RSa
::       Kontekst pracy - rekord KAL_DEF, dziedzina _rs
::   WE: _a - ResultSet
::   WY: 0 - jest konflikt
::       1 - wszystko ok
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_rs:=_a;

_result:=1;

::Sprawdzam czy ten juz dodany ma dlugosc wieksza od zera - zerowe w niczym nie przeszkadzaja
_rs_duration:=0;
_start:=exec('create','#tm_stamp',_rs.STARTD,_rs.STARTT);
_end:=exec('create','#tm_stamp',_rs.ENDD,_rs.ENDT);
_rs_duration:=_end-_start;
{? _rs_duration>0
||
:: Sprawdzam czy ten już dodany zazębi się z aktualnym, jeśli nie zazębi się to ok
   _int_old:=exec('interval','#interval');
   _int_old.START:=_start;
   _int_old.END:=_end;
   _int_curr:=exec('interval','#interval');
   _int_curr.START:=KAL_DEF.TM_START;
   _int_curr.END:=KAL_DEF.TM_END;

   _int_and:=exec('intervals_and','#interval',_int_old,_int_curr);
   {? exec('interval_dur','#interval',_int_and)>0
   || _result:=0
   ?}
?};
_result


\plres_bm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Przed akcją Miesiąc pracy
::   WE: Kontekst wywołania:
::       0 - tabela PL_RES
::       1 - tabela PX_KONT
::----------------------------------------------------------------------------------------------------------------------
{? var_press('_a')=type_of(0) || _con:=_a || _con:=0 ?};
_typ:='';
_ref:='';
{? _con=0
|| _typ:=PL_RES.TYP;
   _ref:=PL_RES.REF
|? _con=1
|| {? PX_KONT.PL_RES<>null()
   || PL_RES.cntx_psh();
      PX_KONT.PL_RES();
      _typ:=PL_RES.TYP;
      _ref:=PL_RES.REF;
      PL_RES.cntx_pop()
   ?}
?};
{? _typ<>'' & _ref<>''
|| exec('start_res','kal_mies',_typ,_ref)
?};
~~


\rem_clear
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Usuwa z planu wszystkie PL_OPERy powiazane z danym remontem
::   WE: [_a] - REM_ZGL.ref()
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

REM_ZGL.cntx_psh();
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PL_OPER.cntx_psh();
   PL_OPER.index('REM_PLAN');
   REM_PLAN.cntx_psh();
   REM_PLAN.index('REM_ZGL');
   REM_PLAN.prefix(REM_ZGL.ref());
   {? REM_PLAN.first()
   || {!
      |?
         PL_OPER.prefix(REM_PLAN.ref());
         {? PL_OPER.first()
         || {!
            |? _next:=0;
               _ref_nxt:=null();
               PL_OPER.cntx_psh();
               {? PL_OPER.next()
               || _ref_nxt:=PL_OPER.ref()
               ?};
               PL_OPER.cntx_pop();

               _can_continue:=exec('del_ploper','po_plan',$PL_OPER.ref(),,,0,0);

               {? _ref_nxt<>null()
               || _next:=PL_OPER.seek(_ref_nxt)
               ?};
               _next>0 & _can_continue>0
            !}
         ?};
         REM_PLAN.next() & _can_continue>0
      !}
   ?};
   REM_PLAN.cntx_pop();


   {? _can_continue>0
   ||
::    Stempluje zgłoszenie
      _can_continue:=exec('plan_pl_update','remonty_plan')
   ?};

   {? _can_continue>0
   || _tm_end:=REM_ZGL.TM_END;
      {? _tm_end=0
      ||
::       Po usunięciu pozycji planu oper dla remontu bezterminowego muszę odświeżyć plan strategiczny
         _can_continue:=exec('replan_px','remonty_plan')
      ?}
   ?};
   PL_OPER.cntx_pop()
?};
REM_ZGL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\konfplug_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Uruchamia wtyczkę PO_AFTER_CHANGE_001 dla podanego PL_OZa i aktualizuje mu treść konfliktu
::       wdrożeniowego
::   WE: [_a] - PL_OZ.ref lub bieżący rekord
::       _b - STRING - rodzaj zmiany: ADD,CHANGE_TIME,CHANGE_RES,RUN4ALL
::   WY: STRING - treść zaktualizowanego konfliktu lub napis XXX_MULTIKONF_XXX jeżeli
::                są konflikty wielokrotne i trzeba je pobrać z bazy osobną procedurą
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PL_OZ.ref())
|| _ref:=_a
?};

_kind:=_b;

_result:='';
_can_continue:=1;

PL_OZ.cntx_psh();
PL_CONF.cntx_psh();
PL_CONF.prefix();
{? _ref<>null()
|| PL_OZ.prefix();
   {? PL_OZ.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
_plugin_res:='';
{? _can_continue>0
|| _plugin_run:=Plugin.run('PO_AFTER_CHANGE_001',_kind,PL_OZ.ref());

   _plugin_res:=json_parse(_plugin_run);
   {? type_of(_plugin_res)=type_of(~~) & type_of(_plugin_run)=type_of('')
   || _plugin_res:=_plugin_run
   ?};

   {? type_of(_plugin_res)=type_of('')
   ||
::    Zwykły jeden konflikt
      _can_continue:=exec('del_pl_conf','po_plan');

      {? _can_continue>0
      ||
         PL_OZ.memo_set(_plugin_res,'KONFPLUG');
         _can_continue:=PL_OZ.memo_put(,'KONFPLUG');

         {? _can_continue>0
         || _result:=_plugin_res
         ?}
      ?}
   |? type_of(_plugin_res)>100
   ||
::    Konflikt wielokrotny
      _can_continue:=exec('del_pl_conf','po_plan');

      {? _can_continue>0
      || PL_OZ.memo_set('','KONFPLUG');
         _can_continue:=PL_OZ.memo_put(,'KONFPLUG')
      ?};

      {? _can_continue>0
      ||
         {! _it:=1..obj_len(_plugin_res)
         |? _can_continue>0
         |!
            {? var_pres('_konf_obj')>100
            || obj_del(_konf_obj)
            ?};
            _konf_obj:=_plugin_res[_it];

            {? type_of(_konf_obj)>100 & obj_len(_konf_obj)>1
            || _typ:=~~;
               _opis:=~~;
               {? var_pres('TYP',_konf_obj)>0
               || _typ:=_konf_obj.TYP
               ?};
               {? var_pres('OPIS',_konf_obj)>0
               || _opis:=_konf_obj.OPIS
               ?};

               {? type_of(_typ)=type_of('') & type_of(_opis)=type_of('')
               || PL_CONF.blank();
                  PL_CONF.PL_OZ:=PL_OZ.ref();
                  PL_CONF.LP:=_it;
                  PL_CONF.TYP:=_typ;
                  PL_CONF.OPIS:=_opis;
                  PL_CONF.TM_START:=PL_OZ.TM_START;
                  PL_CONF.TM_END:=PL_OZ.TM_END;
                  _can_continue:=PL_CONF.add()
               ?}
            ?}
         !}
      ?};

      {? _can_continue>0
      || PL_CONF.cntx_psh();
         PL_CONF.index('PL_OZ');
         PL_CONF.prefix(PL_OZ.ref());
         {? PL_CONF.first()
         || _result:='XXX_MULTIKONF_XXX'
         ?};
         PL_CONF.cntx_pop()
      ?}
   ?}
?};
PL_OZ.cntx_pop();
PL_CONF.cntx_pop();
_result


\konfplug_run
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Uruchamia wtyczkę PO_AFTER_CHANGE_001 dla wszystkich pozycji planu w zadanym okresie czasu
::   WE: _a - REAL - tm_stamp początku
::       _b - REAL - tm_stamp końca
::       [_c] - STRING - rodzaj operacji (domyślnie O)
::   WY: REAL - ilość zaktualizowanych konfliktów lub -1 jeżeli wtyczka nie zdefiniowana
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tm_start:=_a;
_tm_end:=_b;

_result:=0;
_typ:='O';
{? var_pres('_c')=type_of('')
|| _typ:=_c
?};

{? Plugin.runnable('PO_AFTER_CHANGE_001')>0
||
   PL_OZ.cntx_psh();
   PL_OPER.cntx_psh();

   _int_view:=exec('interval','#interval');
   _int_view.START:=_tm_start;
   _int_view.END:=_tm_end;
   PL_OZ.index('TM_END');
   PL_OZ.clear();
   {? PL_OZ.find_ge(_tm_start)
   ||
      {? PL_OZ.TM_START<_tm_end
      || _int_rec:=exec('interval','#interval');
         {!
         |? _ok:=0;
            {? _typ=''
            || _ok:=1
            |? _typ='O'
            || _ok:={? PL_OZ.PL_OPER().TYP='O' || 1 || 0 ?}
            |? _typ<>'O'
            || _ok:={? PL_OZ.PL_OPER().TYP<>'O' || 1 || 0 ?}
            ?};
            {? _ok>0
            || _int_rec.START:=PL_OZ.TM_START;
               _int_rec.END:=PL_OZ.TM_END;
               {? exec('intervals_chk','#interval',_int_rec,_int_view)>0
               || _before:=PL_OZ.memo_txt(,1,'KONFPLUG');
                  _after:=exec('konfplug_update','po_plan',,'RUN4ALL');
                  {? type_of(_after)=type_of('')
                  ||
                     {? _before<>_after
                     || _result+=1
                     ?}
                  |? type_of(_after)>100
                  || _result+=1
                  ?}
               ?}
            ?};
            PL_OZ.next()
         !}
      ?}
   ?};

   PL_OPER.cntx_pop();
   PL_OZ.cntx_pop()
|| _result:=-1
?};
_result


\del_pl_conf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Usuwa konflikty dla podanego PL_OZ
::   WE: [_a] - PL_OZ.ref lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_pl_oz:=PL_OZ.ref();
{? var_pres('_a')=type_of(PL_OZ.ref())
|| _pl_oz:=_a
?};

_can_continue:=1;
_result:=0;

PL_CONF.cntx_psh();
PL_CONF.index('PL_OZ');
PL_CONF.prefix(_pl_oz);
{? PL_CONF.first()
|| {!
   |? _can_continue:=PL_CONF.del(,1);
      PL_CONF.first() & _can_continue>0
   !}
?};
PL_CONF.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\tacttls2rs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Dodaje rekord TACTTLS do RSa
::   WE: _a - tab_tmp - :RS do którego dodawać
::       [_b] - STRING - filtr
::   WY: ID dodanego elementu lub 0 jeżeli porażka
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_rs:=_a;
_filter:='';
{? var_pres('_b')=type_of('')
|| _filter:=_b
?};

_parent:=0;
_result:=0;
{? TACTTLS.M<>null()
||
   _rs.clear();
   _rs.prefix(_parent,#TACTTLS.M);

   {? _rs.size()=0
   ||
      TACTTLS.M();
      _can_continue:=exec('material_filter','po_plan',_filter);
      {? _can_continue>0
      ||
         _rs.blank();
         _rs.TYP:='GRP';
         _rs.cntx_psh();
         _rs.clear();
         _id:=_rs.size()+1;
         _rs.cntx_pop();

         _rs.ID:=_id;
         _rs.PAR:=_parent;
         _rs.SYM:=TACTTLS.M().KTM;
         _rs.NAZWA:=TACTTLS.M().N;
         _rs.REF_M:=$M.ref();
         _rs.DOKL:=M.DOKL;
         _rs.REF:=$TACTTLS.ref();
         _rs.UN_ZL:=#M.ref();
         _rs.KTM:=M.KTM;

         {? _rs.add()
         || _result:=_rs.ID
         ?};
         ~~
      ?};
      ~~
   ?}
?};
_result


\material_filter
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy NPU moze wejsc do RSa - czy pasuje do przekazanego filtra
::       Kontekst pracy - rekord tabeli M
::   WE: _a - STRING - filtrujacy ciag znakow
::   WY: 0 - NPU nie pasuje do filtra
::       1 - NPU pasuje do filtra
::  OLD: \zlec_filter/pl_okr3.fml
::----------------------------------------------------------------------------------------------------------------------
_filter:=_a;

_result:=0;

{? _filter='%' | _filter=''
|| _result:=1
||
:: Podczytuje pole po ktorych bede filtrowal

:: Sprawdzam po kolei pola
   {? _result=0
   || {? M.KTM*_filter>0
      || _result:=1
      ?}
   ?};

   {? _result=0
   || {? M.N*_filter>0
      || _result:=1
      ?}
   ?};
   ~~
?};
_result



\tacttls4zlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca listę NPU dla zlecenia
::   WE: [_a] - ZL.ref() lub bieżący rekord

::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};
_result:=exec('ref_table','#table');
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _tktl:=null();
   {? ZL.RTKTL<>''
   || _tktl:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,,null())
   |? ZL.RKTL<>''
   || _tktl:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,,null())
   ?};
   {? _tktl<>null()
   || TACTTLS.cntx_psh();
      TACTTLS.index('AKNROP');
      TACTTLS.prefix('T',_tktl);
      {? TACTTLS.first()
      || {!
         |? _result.add(TACTTLS.M);
            TACTTLS.next()
         !}
      ?};
      TACTTLS.cntx_pop()
   ?}
?};
ZL.cntx_pop();
_result


\can_load_zlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy zlecenie można dodać do RSa
::       Kontekst pracy - rekord ZL
::   WE:
::   WY: 0/1
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
ZGP.cntx_psh();
TOPER.cntx_psh();


{? ZL.TYP().WP='W'
||
:: Warsztatowych nie obsługujemy póki co w planie bo nie mają technologii
   _result:=0
|? ZL.RODZAJ='P'
||
:: Dla zleceń pojedynczych sprawdzam czy są jakieś operacje planowane, nie grupowe
   ZGP.index('TO_PLAN');
   ZGP.prefix(ZL.ref(),'N','T','N');
   {? ZGP.first()
   || _result:=1
   ?};

   {? _result=0
   || _tktl:=null();
      {? ZL.RTKTL<>''
      || _tktl:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,,null())
      ?};
      {? _tktl<>null()
      ||
         TOPER.index('TO_PLAN');
         TOPER.prefix(_tktl,'T','N','N');
         {? TOPER.first()
         || _result:=1
         ?}
      ?}
   ?};
   {? _result=0
   || _tktl:=null();
      {? ZL.RKTL<>''
      || _tktl:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,,null())
      ?};
      {? _tktl<>null()
      ||
         TOPER.index('TO_PLAN');
         TOPER.prefix(_tktl,'T','N','N');
         {? TOPER.first()
         || _result:=1
         ?}
      ?}
   ?}
|| _result:=1
?};
TOPER.cntx_pop();
ZGP.cntx_pop();
_result


:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:36 c5ea435d21146133c24d3ba94039a530a7a55b932956c5769ede27feeec57afdaf4242c62cb968a868422781ea3a9bed3f1e94c7dd3dc5ad822243f6a1eda87a4abf4fd3c3f787cfbc51a75ceb50d899809d1c8993ab10213a9f1178aa327f769a8fed2fc6f76c28839af7d52e4fb7121a63f7937b75edf2323abb858f9d4339
