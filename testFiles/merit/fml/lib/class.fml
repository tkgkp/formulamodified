:!UTF-8
::(c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: class.fml []
:: Utworzony: 2010/09/30
:: Autor: jerry
::======================================================================================================================
:: Zawartość: Klasa do obsługi CLASS
:: OLD: skid_cls.fml
:: UWAGA: Klasa musi zostać zadeklarowana praktycznie przed powołaniem jakichkolwiek innych obiektów
::======================================================================================================================
::
:: Wywołanie: exec(,'class')
::
:: Po co to to jest?: Klasa powstała, aby dac możliwość wielokrotnej 'redeklaracji' klas, czego Formuła nie udostępnia.
::
:: W jaki sposób?:    Klasa jest 'warstwą pośredniczącą' pomiędzy programistą a @.CLASS.
::                    Pola klasy (z wyjątkiem rozpoczynajacych sie od 'x') to aliasy faktycznych definicji klas
::
::                    Możliwości wynikają z metod: get_name() i setclass()
::                    get_name(STRING propozycja) - zwraca nazwe klasy, którą programista chce zadeklarować
::                       Domyślnie zwracana jest propozycja, ale gdy:
::                          @.Class.xIsDevel=1
::                        i użytkownik jest 'superużytkownikiem'
::                        i klasa o proponowanej nazwie jest już zadeklarowana
::                       metoda szuka wolnej 8 znakowej nazwy wdrożeniowej skladającej się z .xcPrefix i kolejnego numeru
::                       np. wdr00013
::
::                    setclass(STRING alias, @.CLASS klasa)
::                    setclass(STRING alias, STRING nazwa_klasy) - ustala nowe wskazanie aliasu
::                       upraszczajac: @.Class.alias:=klasa lub @.Class.alias:=@.CLASS.nazwa_klasy
::
::
:: Jak korzystać?:    1. dodać pole do definicji Class o nazwie jaką będziemy wykorzystywać w kodzie np. TESTOWA
::                    2. deklaracje klasy TESTOWA zmodyfikować wg podanego poniżej przykładu:
::
::                    bylo(?)
::
::                       {? var_pres('TESTOWA',@.CLASS)<=0
::                       || obj_decl('TESTOWA',
::                          ,obj_fld('Pole',0)
::                          ...
::
::                          )
::                       ?};
::                       _tst:=obj_new(@.CLASS.TESTOWA)
::
::
::                    po zmianach
::
::                       _cl_name:=@.Class.get_name('TESTOWA');
::                       {? var_pres(_cl_name,@.CLASS)<=0
::                       || obj_decl(_cl_name,
::                          ,obj_fld('Pole',0)
::                          ...
::
::                          );
::                          @.Class.setclass('TESTOWA',_cl_name)
::                       ?};
::                       _tst:=obj_new(@.Class.TESTOWA)
::
::
::                    Reasumujac:
::                       > nazwa klasy powinna byc przefiltrowana przez .get_name()
::                       > po deklaracji klasy należy przypisać ją do interesującego nas aliasu
::                       > powoływanie obiektów powinno odbywać sie poprzez alias w @.Class, a nie bezpośrednio z @.CLASS
::
:: Wiele wariantów?:  Możliwe jest również stworzenie wielu 'wariantów' danej klasy. Można to uzyskać poprzez
::                    zdefiniowanie aliasu jako tablicy n-elementowej.
::                    W takim przypadku do setclass() należy podać 3 parametr oznaczający numer wariantu, który chcemy
::                    ustalić, podczas powoływania obiektów wskazać odpowiedni wariant np.:
::                      _tst:=obj_new(@.Class.TESTOWA[3])
::
::
:: Korzysci:          1. Gdy zalogowany jest użytkownik niewdrożeniowy - system zachowuje się standardowo
::                       Bez właczonego -d i tak nie odbywa sie podczytywanie formuł, wiec efektów i tak by nie było.
::
::                    2. Gdy zalogowany jest wdrożeniowiec, system umożliwia testowanie klasy bez ciagłego przelogowywania
::                       aplikacji, co w przypadku logistyki lub produkcji może być b.czasochłonne
::
::                    3. Możliwość tworzenia czarnych skrzynek pracujących na obiektach danej klasy (aliasu)
::======================================================================================================================
::
:: SZABLON DEKLARACJI Z WYKORZYSTANIEM Class
::
::_CL_NAME:='Klasa';
::_cl_name:=@.Class.get_name(_CL_NAME);
::{? var_pres(_cl_name,@.CLASS)<=0
::|| obj_decl(_cl_name
::   ,obj_fld('this'    ,'Wskazanie na siebie';~~)
::
::   );
::   @.Class.setclass(_CL_NAME,_cl_name)
::?};
::~~
::======================================================================================================================


:: * * * * *   K O N F I G U R A C J A   M E C H A N I Z M U   * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

:: - - - - -   K L A S Y  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"LISTA KLAS OBSLUGIWANYCH PRZEZ OBIEKT (kazda klasa w osobnej linii)"; _klasy:="

:: Konwersja tekstów
   cStrConv

:: Obsługa systemu szesnastkowego
   cHex

:: Klasa do obsługi systemów liczbowych
   cNSystem

:: Klasa do przedstawiania statusów
   cSTATSls

:: Klasa do obsługi wyników
   cResult

:: Klasa do obsługi parametrów
   cFPars

:: Klasa do obsługi grupy kontekstów
   cContext

:: Klasa menu
   C_ANp
:: Klasa do obsługi kopiowania do excela
   EXCEL
:: Klasa do obsługi kopiowania do worda
   WORD
:: Klasa do konwersji Office na PDF
   OFCE2PDF
" + exec('klasy','#class');'KONIEC LISTY OBSŁUGIWANYCH KLAS';


:: - - - - -   I N I C J A L I Z A C J A   T A B L I C   K L A S  - - - - - - - - - - - - - - - - - - - - - - - - - - -
"FORMUŁA INICJUJĄCA TABLICE KLAS (treść formuły zostanie wklejona w konstrukcje 'with'=> {|_a|! ..... |}";_init:="


";'KONIEC FORMUŁY INICJUJĄCEJ';


:: - - - - -   K O P I O W A N I E   T A B L I C   K L A S  - - - - - - - - - - - - - - - - - - - - - - - - - - -
"FORMUŁA KOPIUJĄCA TABLICE KLAS (_old - stary obiekt, _new - nowy obiekt";_tab_cpy:="_old:=_a; _new:=_b;


";'KONIEC FORMUŁY KOPIUJĄCEJ';


:: - - - - -   D E K L A R A C J A   K L A S  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
"FORMUŁA WYKONYWANA PO PIERWSZYM POWOŁANIU OBIEKTU Class"; _declare:="

:: cStrConv
   exec('cStrConv','libfml');

:: cHex
   exec('cHex','libfml');

:: cNSystem
   exec('cNSystem','libfml');

:: cSTATSls
::   exec('cSTATSls','statexam');

:: cResult
   exec('cResult','libfml');

:: cFPars
   exec('cFPars','libfml');

:: cContext
   exec('cContext','libfml');

:: C_ANp
::   exec('C_ANp_declare','skid_anp');

" + exec('declare','#class');'KONIEC FORMUŁY WYKONYWANEJ PO PIERWSZYM POWOŁANIU OBIEKTU Class';

:: * * * * *   K O N I E C   K O N F I G U R A C J I   M E C H A N I Z M U   * * * * * * * * * * * * * * * * * * * * * *





















































::======================================================================================================================
:: Poniżej obsługa mechanizmu... tutaj praktycznie nie powinno być potrzeby wprowadzania modyfikacji
::======================================================================================================================

_obj:=_cl_name:=_CL_NAME:='Class';

:: ---- zabieg dla klasy Class - gdyby np. dodano nowe pole do klasy --------------------------------------------
{? ( var_pres(_CL_NAME,@.CLASS)>=0
   &  __develop>0
   )
|| _xcPrefix:='Class';
   _xcNumber:=1;
   _xcl:=(+_xcPrefix)-8;
   _xcNumber-=1;
   {!
   |? _cl_name:=_xcPrefix+form(_xcNumber,_xcl,,'99');
      _xcNumber+=1;
      var_pres(_cl_name,@.CLASS)>=0
   !}
?};
:: ------------------ nazwa klasy ustalona przechodzimy do deklaracji -------------------------------------------------
{? var_pres(_cl_name,@.CLASS)<=0
|| _obj_decl:="obj_decl('"+_cl_name+"'";
:: ----------------------------- pola wskaźników do klas - aliasy klas ------------------------------------------------
   _klasy:=form(_klasy);
   {!
   |? _klpoz:=_klasy*'\n';
      _klasa:='';
      {? _klpoz>0
      || _klasa:=form((_klpoz+_klasy)-1);
         _klasy:=form(_klpoz-_klasy)
      |? +_klasy
      || _klasa:=_klasy;
         _klasy:=''
      ?};
      {? _klasa<>''
      || _obj_decl+="\n,obj_fld('"+_klasa+"','Wskaźnik do klasy';~~)"
      ?};
      +_klasy
   !};

:: pola techniczne
   _obj_decl+="
   ,obj_fld('xTmStamp','!!! to jest pierwsze pole techniczne - przed nim tylko wskaźniki do klas !!!!';0)
   ,obj_fld('xThis'   ,'Wskazanie na siebie';~~)
   ,obj_fld('xIsDevel','gdy 1 - możliwe pseudo-redeklaracje klas';0)
   ,obj_fld('xcPrefix','prefiks nazwy klasy wdrożeniowej';'wdr')
   ,obj_fld('xcNumber','kolejny numer klasy wdrożeniowej';1)
   ";
:: konstruktor -------------------------------------------------------------------------------------------------  __init
   _init:=form(_init);
   {? +_init=0    || _init:='~~'
   |? _init+1=';' || _init+='\n~~'
   ?};

   _obj_decl+="\n,obj_meth('__init',\"
           _a.xThis:=_a;
           _a.xIsDevel:=__develop;
           {|_a
           |!"+_init+"
           |};
           ~~
   \")";

:: metody
   _obj_decl+="\n,obj_meth('get_name',\"
               _cl_name:=_a;
               {? ( .xIsDevel
                  & var_pres(_cl_name,@.CLASS)>=0
                  & __develop>0
                  )
               ||
                  _xcl:=(+.xcPrefix)-8;
::                na wypadek gdyby poprzednia deklaracja sie nie powiodła - oszczędzamy miejsce...
                  .xcNumber-=1;
                  {!
                  |? _cl_name:=.xcPrefix+form(.xcNumber,_xcl,,'99');
                     .xcNumber+=1;
                     var_pres(_cl_name,@.CLASS)>=0
                  !}
               ?};
               _cl_name
   \")";

   _obj_decl+="\n,obj_meth('setclass',\"
               _fld:='.'+_a;
               _fldacr:=_a;
               _class:={? type_of(_b)>100 || '_a'
                       |? type_of(_b)=2   || {? var_pres(_b,@.CLASS)>100
                                             || '@.CLASS.'+_b
                                             || return(0)
                                             ?}
                                          || return(0)
                       ?};
               _c:={? _>2 & type_of(_c)=0 || _c || 0 ?};

               {? _c || _fld:=_fld+'['+form(_c,,,'99')+']' ?};
               {? var_pres(_fldacr,.xThis)>100 || ($('obj_del('+_fld+')'))() ?};
               {? var_pres(_fldacr,.xThis)>=0
               || ($(_fld+':='+_class))(_b);
                  ($(_fld+'='+_class))(_b)
               || -1
               ?}
   \")";


   _obj_decl+="\n,obj_meth('exists',\"
               {? var_pres(_a,.xThis)>100 ||  1
               |? var_pres(_a,.xThis)>=0  ||  0
                                          || -1
               ?}
   \")";


   _obj_decl+="\n)";
   ($_obj_decl)()
?};

:: procedura ewentualnej 'podmiany' obiektu Class
_fml:=$(_obj+':=obj_new(@.CLASS.'+_cl_name+')');
{? var_pres(_obj)<100
|| _fml();
   _declare:=form(_declare);
   {? +_declare>0
   || {? _declare+1=';' || _declare+='~~' ?};
      ($_declare)()
   ?}
|? var_pres(_obj)>100
 & _CL_NAME<>_cl_name
||
   _old:=($_obj)(); ($('obj_del('+_obj+')'))();
   _fml();
   _new:=($_obj)();

   _tmstamp:=SYSLOG.tm_stamp();
   _old.xTmStamp:=_tmstamp;
   {! _fld:=1..obj_len(_old)
   |? ~( type_of(_old[_fld])=type_of(_tmstamp)
       & _old[_fld]=_tmstamp
       )
   |!
::    trzeba uwzglednic ze moga byc tablice klas
      {? type_of(_new[_fld])<100
      || _new[_fld]:=_old[_fld]
      ?}
   !};

:: sprawdzimy czy jest określony mechanizm kopiowania tablic klas
   _tab_cpy:=form(_tab_cpy);
   {? +_tab_cpy
   || {? _tab_cpy+1=';' || _tab_cpy+='~~'?};
      ($_tab_cpy)(_old,_new)
   ?}
?}

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:38 5323297de9a884eea84b37390702455b7cc7fe4f87bc7914710ada662e6cd0626e35006264b6f3d38cd488608856a4164e155533657fc9471f0ce706b7e4e9f604459960d1aeef5922fc86a23c76f121a83810e964472cce89d94748e90d43e300f1aa668a43274da1dda11d8638681a3f6869b773a566660f3c987380dce8f1
