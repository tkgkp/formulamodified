:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: zl_head.fml
:: Utworzony: 22.06.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Obsługa nagłówków zleceń (selekcja i redakcja) - tabela ZL
::            Plik biblioteczny - wspólna obsługa dla czynności obszaru roboczego TTE_PZL:
::            - TTE_PZL_PZLE
::            - TTE_PZL_PWAR
::            - TTE_PZL_DZLE
::            - TTE_PZL_DWAR
::            - TTE_PZL_DZLP
::            - TTE_PZL_DZLN
::            - TTE_PZL_MZLE
::            - TTE_PZL_MZLP
::            - TTE_PZL_SZLE
::======================================================================================================================


\buffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca obiekt nazwany - bufor tabeli ZL
::   WY: obj_new()
::----------------------------------------------------------------------------------------------------------------------
exec('ZL','buffer')


\zl_act_uid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca UID czynności odpowiadający parametrom
::   WE: _a - 'W'arsztatowe/'P'rodukcyjne
::       _b - ZL.RODZAJ ('P','Z','N')
::       _c - ZL.STAN ('N','O')
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_c')<>type_of('') || _c:='N' ?};
{? _a='W'          || 'TTE_PZL_DWAR'
|? _a='P' & _b='P' || {? _c='O' || 'TTE_PZL_MZLE' || 'TTE_PZL_DZLE' ?}
|? _a='P' & _b='Z' || {? _c='O' || 'TTE_PZL_MZLP' || 'TTE_PZL_DZLP' ?}
|? _a='P' & _b='N' || 'TTE_PZL_DZLN'
                   || '???'
?}


\action_modify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Rejestracja nagłówka zlecenia - akcja Popraw
::----------------------------------------------------------------------------------------------------------------------
_il_before:=ZL.IL;

_args:=exec('mp_run_a','#b__box');
_args.ACT_UID:=exec('zl_act_uid','zl_head',ZL.TYP().WP,ZL.RODZAJ,ZL.STAN);
_args.UIDREF:=ZL.uidref();
_args.AKCJA:='POPRAW';
_args.PROC_START:={? ZL.STAN='O' || 'T' || 'N' ?};
_args.CONTEXT:=obj_new('ZL'); _args.CONTEXT.ZL:=ZL.ref();

exec('mp_run','#b__box',_args);

{? ZL.STAN='O'
|| ZL.get();
   {? _il_before<>ZL.IL || params_get().env.ZLIM_reload:=1 ?}
?};
~~


\action_copy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Rejestracja nagłówka zlecenia - akcja Kopiuj
::----------------------------------------------------------------------------------------------------------------------
_ref:=#ZL.ref();
{? exec('zl_lock','zl_common',_ref,'N')
|| _familyres:=exec('zl_lockfamily','zl_common',_ref,'N');
   {? _familyres.LOCKED>0
   || _args:=exec('mp_run_a','#b__box');
      _args.ACT_UID:=exec('zl_act_uid','zl_head',ZL.TYP().WP,ZL.RODZAJ);
      _args.AKCJA:='KOPIUJ';
      _args.PROC_START:='T';
      _args.CONTEXT:=obj_new('ZL'); _args.CONTEXT.ZL:=ZL.ref();

      exec('mp_run','#b__box',_args)
   || FUN.info('Jedno z powiązanych zleceń jest redagowanie.\nKopiowanie niemożliwe.'@)
   ?};
   exec('zl_unlockfamily','zl_common',_familyres.TAB,'N');
   exec('zl_unlock','zl_common',_ref,'N')
?}


\action_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Rejestracja nagłówka zlecenia - akcja Usuń
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());

ZL.cntx_psh();
_up_zl:=exec('get_nadzlec','zl_link',ZL.ref());
{? ZL.prev() || _prev_zl:=ZL.ref() || _prev_zl:=null() ?};
ZL.cntx_pop();

_args:=exec('mp_run_a','#b__box');
_args.ACT_UID:=exec('zl_act_uid','zl_head',ZL.TYP().WP,ZL.RODZAJ);
_args.UIDREF:=ZL.uidref();
_args.AKCJA:='USUŃ';
_args.GRUPA:={? ZL.sel_size()>0 || 'T' || 'N' ?};
_args.CONTEXT:=obj_new('ZL','RESULT'); _args.CONTEXT.ZL:=ZL.ref(); _args.CONTEXT.RESULT:=0;

exec('mp_run','#b__box',_args);
{? _args.CONTEXT.RESULT
|| ZL.seek(_prev_zl);
   {? cur_win(1,1)='STRUCT' & ZL.size()>0
   || _env.ZL_UP:=_up_zl
   ?}
?};
~~


\action_delete_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Rejestracja nagłówka zlecenia - akcja Usuń przed grupą rekordów
::  OLD: \pr_zlgru/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
{? (_choice:=FUN.choice('Ilość zaznaczonych zleceń: %1. Czy usunąć wybrane zlecenia i powiązane z nimi zadania?'@[form(ZL.sel_size())]
                         ,,'Usuń tylko &zlecenie'@,'Usuń wraz z zadaniami'@))
|| VAR.GRUPA:='T';
   {? _choice=2
   || ZLEC.CLEANER:='T'
   || ZLEC.CLEANER:='N'
   ?};
   KOMM.init(,,'Usuwanie zleceń'@,'');
   VAR_DEL.delete('__matakt');
   __matakt:=tab_tmp(2,
      'REF','STRING[16]',''
     ,'NRK','INTEGER',''
     ,'ILR','REAL',''
     ,'ZKP','STRING[16]',''
     ,'ZKN','STRING[16]',''
   );
   sel_nchk();
   1
|| 0
?}


\action_delete_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Rejestracja nagłówka zlecenia - akcja Usuń po grupie rekordów
::  OLD: \po_zlgru/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
exec('akt_rezy','rezerwacje');
VAR_DEL.delete('__matakt');
KOMM.select();
1


\action_end
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Rejestracja nagłówka zlecenia - akcja Zakończ
::----------------------------------------------------------------------------------------------------------------------
{? ZL.STAT_N='N'
|| {? ZL.TYP().WP='P' & ZL.MG=null()
   || _msg:='W zleceniu %1 należy wypełnić pole \'Magazyn\'.'@[ZL.SYM];
      {? VAR.GRUPA='T'
      || KOMM.add(_msg)
      || FUN.info(_msg)
      ?}

   |? ZL.DTR<>date(0,0,0) & ZL.DTR<date()
   || _msg:='Termin realizacji zlecenia %1 nie może być wcześniejszy od daty dzisiejszej.'@[ZL.SYM];
      {? VAR.GRUPA='T'
      || KOMM.add(_msg)
      || FUN.info(_msg)
      ?}

   || {? exec('zl_lock','zl_common',,'N')
      || _familyres:=exec('zl_lockfamily','zl_common',,'N');
         {? _familyres.LOCKED>0
         || _args:=exec('mp_run_a','#b__box');
            _args.ACT_UID:=exec('zl_act_uid','zl_head',ZL.TYP().WP,ZL.RODZAJ);
            _args.UIDREF:=ZL.uidref();
            _args.GRUPA:=VAR.GRUPA;
            _args.AKCJA:='ZAKOŃCZ';
            _args.CONTEXT:=obj_new('ZL','ORDERS'); _args.CONTEXT.ZL:=ZL.ref(); _args.CONTEXT.ORDERS:=0;

            exec('mp_run','#b__box',_args)
         || _msg:='Jedno ze zleceń powiązanych z %1 jest redagowane.\nModyfikacje niemożliwe.'@[ZL.SYM];
            {? VAR.GRUPA='T'
            || KOMM.add(gsub(_msg,'\n',' '))
            || FUN.info(_msg)
            ?}
         ?};
         exec('zl_unlockfamily','zl_common',_familyres.TAB,'N');
         exec('zl_unlock','zl_common',,'N')
      ?}
   ?}

|| _msg:='Zakończono rejestrację nagłówka zlecenia %1.\nModyfikacje niemożliwe.'@[ZL.SYM];
   {? VAR.GRUPA='T'
   || KOMM.add(gsub(_msg,'\n',' '))
   || FUN.info(_msg)
   ?}
?};
'key:Esc'


\action_end_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.42]
:: OPIS: Rejestracja nagłówka zlecenia - akcja Zakończ przed grupą rekordów
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Ilość zaznaczonych zleceń: %1. Czy zakończyć rejestrację nagłówków?'@[form(ZL.sel_size())])
|| VAR.GRUPA:='T';
   KOMM.init(,,'Rejestracja nagłówków zleceń'@,'');
   sel_nchk();
   1
|| 0
?}


\action_end_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.42]
:: OPIS: Rejestracja nagłówka zlecenia - akcja Zakończ po grupie rekordów
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
1


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Selekcja zleceń
::   WE: _a - środowisko selektora zleceń
::  OLD: \select/zl.fml
::----------------------------------------------------------------------------------------------------------------------
_env:=_a;
_env_mater:=exec('env_mater','tech_mater');
_env_oper:=exec('env_oper','tech_oper');
_env_tool:=exec('env_tool','tech_tool');
_env_guide:=exec('env_guide','zl_guide');
_env_other:=exec('env_other','zl_common');
_env_atr:=exec('env_atr','tech_atr');
params_set(
   'env',_env,
   'env_mater',_env_mater,
   'env_oper',_env_oper,
   'env_tool',_env_tool,
   'env_guide',_env_guide,
   'env_other',_env_other,
   'env_atr',_env_atr,
   'env_blob',_env.env_blob
);

ZAKR.ZTP_WP:=VAR.A_WP:=_env.WP;
VAR.A_ZLEC:=VAR.L_ZLEC:=null();

{? exec('chk_broken_zl','zl_head')
|| FUN.emsg('Wykryto nieprawidłowości w kartotece zleceń.\nProszę o kontakt z %1.'@[exec('producent','#system')])
?};

POMOC.MGR:=null();
POMOC.RODZ:='T';
ANWAR.actions('WER0','dpUFSOIE:dI');
ANWAR.actions('WER1','dpUFSOIE:dI');
ANWAR.clear();

:: wstępnie ustawienia zadane parametrami formuły:
VAR.A_STAN:='';
FILTER.STAN_ZL:='';
VAR.S_TPZL:='0';
VAR.A_KTL:=null();

exec('vzl_tzl','zl_view');

:: Ikony
_formikon:="params_exec('icon_symbol','zl_head')";
ZL.win_fml('PWER_P',,'SYM',,'ICON_BEFORE',_formikon);
ZL.win_fml('PWER_W',,'SYM',,'ICON_BEFORE',_formikon);
_formikon:="params_exec('icon_ktm','zl_head')";
ZL.win_fml('PWER_P',,'KTM','KTM','ICON_BEFORE',_formikon,2);
ZL.win_fml('PWER_W',,'KTM','KTM','ICON_BEFORE',_formikon,2);
ZL.win_fml('STRUCT',,'KTM','KTM','ICON_BEFORE',_formikon,2);
_formikon:="params_exec('icon_stat_pl','zl_head')";
ZL.win_fml('PWER_P',VAR1,'STAT_PL',,'ICON_BEFORE',_formikon);
ZL.win_fml('PWER_W',VAR1,'STAT_PL',,'ICON_BEFORE',_formikon);
ZL.win_fml('STRUCT',VAR1,'STAT_PL',,'ICON_BEFORE',_formikon,2);
_formikon:="params_exec('icon_stan','zl_head')";
ZL.win_fml('PWER_P',,'STAN',,'ICON_BEFORE',_formikon);
ZL.win_fml('PWER_W',,'STAN',,'ICON_BEFORE',_formikon);
ZL.win_fml('STRUCT',,'STAN',,'ICON_BEFORE',_formikon,2);

::======================================================================================================================
:: Ustalenie treści linku
_params:=params_get();
{? type_of(_params)>0 & var_pres('LINK',_params)
|| _link:=_params.LINK
|| _link:=''
?};
:: Obsługa linku
_forced_zakr_vzl:='';
_forced_zakr_zl_stan:='';
{? _link<>''
||
:: Ustalenie parametrów sesji na podstawie przekazanego rekordu
   {? ref_tab(_link)=ZL
   || _oddz:=exec('FindAndGet','#table',ZL,_link,,"ODDZ",'');
      _mg:=exec('FindAndGet','#table',ZL,_link,,"MG",null());
      _oddz_ref:=exec('FindInSet','#table','ODDZ','KOD2',_oddz,,,1);
::    Wykluczenie dostępu na podstawie uprawnień do danych - oddziały i magazyny
      {? exec('spr_upr','users','ODDZ',_oddz_ref) & {? _mg=null() || 1 || exec('spr_upr','users','MAG',_mg) ?}
      || __PARSES.setVal('OddzialLogProd',_oddz);
         __PARSES.setVal('Magazyn',_mg)
      || return()
      ?}
   || return()
   ?};
:: Ustawienie rekordu
   _ini_zl_pod:=exec('FindAndGet','#table',ZL,_link,,"ref()",null());
   _ini_zl:=exec('top_level','zl_link',_ini_zl_pod);
:: Ustawienie "siłowe" parametrów widoku - zlecenie wg stanu musi być widoczne
   _forced_zakr_zl_stan:='A'
|| _ini_zl_pod:=null();
   _ini_zl:=null()
?};
::======================================================================================================================

:: Właściwa pętla obsługująca selekcję zleceń
{!
|? VAR.TOW_USL:='T';
   VAR.GRUPA:='N';
   _nrk:=FILTER.NRK;
   _podzl:=VAR.ZLPRZ;
   FILTER.NRK:='';
   VAR.FILTER:='N';
   VAR.A_TORW:='T';
   VAR.A_ZLNAD:=null();

:: Pola techniczne ukrywamy dla zwykłego użytkownika
   {? sec_superuser()=0
   || ZL.fld_attr('MASKA',2);
      ZL.fld_attr('ZMASK',2);
      ZL.fld_attr('UNRZL',2);
      ZL.fld_attr('NRNZL',2);
      ZL.fld_attr('NRPZL',2);
      ZL.fld_attr('PROJEKTY',2);
      ZL.fld_attr('PROJETAP',2);
      ZL.fld_attr('OSOBA',2);
      ZL.fld_attr('SYMZ',2);
      ZL.fld_attr('USER_ZAM',2);
      ZL.fld_attr('DAT_ZAM',2);
      ZL.fld_attr('GODZ_ZAM',2);
      ZL.fld_attr('MODKONEL',2)
   ?};

   ZTP.f_clear();
   _typy:=exec('typy_zlecen','zl_head',ZAKR.ZTP_WP);
   ZTP.f_set('TYP',,'ZTP.REFERENCE in (select :_a.REF from :_a)',_typy);
   obj_del(_typy);
   ZTP.win_dict('SLO');

:: Okno wertowania (osobne dla produkcyjnych i warsztatowych)
   _wer:={? VAR.A_WP='P' || _env.WERP || _env.WERW ?};
   _grp:={? VAR.A_WP='P' || _env.GRPP || _env.GRPW ?};
   _zrp:={? VAR.A_WP='P' || _env.ZRPP || _env.ZRPW ?};
   _win:={? ZAKR.ZZL='T' || _win:=_zrp || _win:=_grp ?};
   ZL.win_sel(_win);
   ZL.hdr_sel();

:: TODO: FILTRY
::   exec('filter_reset','zlecenia');
   {? ZAKR.ZTP_WP='W' || ZAKR.ZL_ZTP:=ZAKR.ZL_ZTPW ?};
   exec('ust_zakr','zl_view');
   {? _forced_zakr_zl_stan<>'' || ZAKR.ZL_STAN:=_forced_zakr_zl_stan; _forced_zakr_zl_stan:='' ?};
   exec('zakr_all','zl_view');
   _env.AKT_ZL:=ZL.NODE;
:: TODO: WIDOKI
:: Okno wertowania (zawsze grupowe) wg widoku
::   exec('khartotek','khv',_wer,'ZL');
   BEER.NAWIGTEN:=0;
   BEER.ESC:=0;
   _env.RELOAD:=0;
   _env.env_limit.ZLIMp.WP:=_env.WP;
   _env_guide.WP:=_env.WP;

   AreaTitle.setTabWin(ZL,_win);
   AreaTitle.setTitle();

   {? _ini_zl_pod<>null() | _ini_zl<>null()
   || ZL.seek(_ini_zl);
      _formula:=
         {? _ini_zl<>_ini_zl_pod
         || $("ZL.cntx_psh();
               ZL.prefix();
               ZL.seek('"+$_ini_zl_pod+"');
               params_exec('struktura','zl_view');
               ZL.cntx_pop();
               ~~
            ")
         || "~~"
         ?};
      ZL.select(,1,5,,,_formula,1);
      _ini_zl_pod:=null();
      _ini_zl:=null()
   || ZL.select(,1,5)
   ?};

   ZL.seek(VAR.L_ZLEC);
   ZL.f_clear();
   ZTP.f_clear();
   VAR.ZLPRZ:='';
   clr_sel();
   FILTER.NRK:=_nrk;

   BEER.NAWIGTEN
!};
FILTER.STAN_ZL:='';
ZL.fld_attr(,1);
ANWAR.actions('WER0');
ANWAR.actions('WER1');
~~


\select_slo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Uniwersalny słownik zleceń, bazuje na aktualnym kontekście tabeli ZL
::   WY: ZL.ref - ref wybranego zlecenia lub null
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=null();
ZL.win_sel('SLO_SL');
ZL.actions('SLO_SL','XY','W');
{? ZL.select(,1,5)>0
|| _result:=ZL.ref()
?};
_result


\icon_symbol
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ikona w polu ZL.SYM - informacja, czy ...
::  OLD: \icon_symbol/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=params_get();
{? var_pres('_args')>100
|| _env:=_args.env;
   _result:=exec('pusta','#icon');
   _jest:=_env.AKT_ZL<>'' & ZAKR.VZL='A' & ZAKR.ZTP_WP<>'W';
   {? _jest & _env.AKT_ZL=ZL.NODE
   || _level:=ZL.LEVEL;
      _poz:={? _level=0 || 0
            |? _level>=2 || 3
            |? _level=1 || exec('poz_zlec','zl_head')
            || 0
            ?};
      _result:={? _poz=0 || 'xwin16.png:76'
               |? _poz>=3 || 'xwin16.png:26'
               |? _poz<3 || 'xwin16.png:2'+form(_poz+3)
               || ''
               ?}
   |? ~_jest
   || _result:=''
   ?}
|| _result:=''
?};
_result


\icon_ktm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Ikona w polu ZL.KTM - informacja, czy zlecenie ma atrybuty
::  OLD: \icon_ktm/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=exec('pusta','#icon');
{? ZL.DK_C<>null()
||
   DK_C.cntx_psh();
   {? ref_name(ZL.DK_C)<>DK_C.name() || DK_C.use(ref_name(ZL.DK_C)) ?};
   ZL.DK_C();

   _buffer:=exec('buffer','mat_atr');
   _buffer.get_dkc();
   {? _buffer.is_empty()=0
   || _result:='xwin16.png:50'
   ?};
   DK_C.cntx_pop();
   ~~
?};
_result


\icon_stan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Ikona stanu zlecenia
::  OLD: \icon_stan/zl.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZL.STAN='N'
|| 'xwin16.png:18'
|? ZL.STAN='O'
|| 'xwin16.png:156'
|? ZL.STAN='Z'
|| 'xwin16.png:157'
|| exec('pusta','#icon')
?}


\icon_stat_pl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Ikona statusu planowania
::  OLD: \icon_stat_pl/zl.fml
::----------------------------------------------------------------------------------------------------------------------
:: Jeżeli w planie operacyjnym
{? ZL.PLAN_PO='T'
|| exec('pl_plan','icon')

:: Jeżeli w planie strategicznym
|? ZL.PLAN_PX='T'
|| exec('px_plan','icon')

:: Bez planu
|| exec('pusta','#icon')
?}


\icons_slo_sl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Ustawia ikony dla okna ZL.SLO_SL
::----------------------------------------------------------------------------------------------------------------------
_formikon:="params_exec('icon_ktm','zl_head')";
ZL.win_fml('SLO_SL',,'KTM','KTM','ICON_BEFORE',_formikon);
_formikon:="params_exec('icon_stat_pl','zl_head')";
ZL.win_fml('SLO_SL',VAR1,'STAT_PL',,'ICON_BEFORE',_formikon);
_formikon:="params_exec('icon_stan','zl_head')";
ZL.win_fml('SLO_SL',,'STAN',,'ICON_BEFORE',_formikon);
~~


\poz_zlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [12.41]
:: OPIS: zwraca numer poziomu zagłębienia
::   WE: poziom zagłębienia gałęzi 0-najwyższy poziom
::  OLD: \poz_zlec/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
{? ZL.TREE
|| {? ZL.TREE=BIT.sqlint(ZL.NODE)
   || _wyn:=1
   || ZL.cntx_psh();
      ZL.prefix();
      {? ZL.seek(ZL.TREE,) & ZL.TREE=BIT.sqlint(ZL.NODE)
      || _wyn:=2
      || _wyn:=3
      ?};
      ZL.cntx_pop()
   ?}
?};
_wyn


\chk_broken_zl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy w danych jest zlecenie o zerowym unikalnym numerze - to zlecenie jest
::       niebezpieczne, ponieważ na pewno spowoduje że będą generowane nieprawidłowe dane w różnych miejscach
::       systemu
::   WY: 0 - wszystko jest ok
::       1 - w systemie jest nieprawidłowe zlecenie
::  OLD: \chk_broken_zl/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
ZL.cntx_psh();
ZL.index('UNRZL');
ZL.prefix(0);
{? ZL.size()>0
|| _result:=1
?};
ZL.cntx_pop();
_result


\typy_zlecen
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Tworzy tabelę z refami dostępnych typów zleceń (np. do budowania filtrów)
::   WE: [_a] - 'W'arsztatowe, 'P'rodukcyjne (gdy nie podano - wszystkie)
::   WY: tabela wynikowa
::  OLD: \typy_zlecen/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') || _wp:=_a || _wp:='' ?};
{? _wp=''
|| _typy:=sql('select ZTP.REFERENCE as REF from ZTP where SUBSTR(ZTP.TYP,0,1)<>\'~\'')
|| _typy:=sql('select ZTP.REFERENCE as REF from ZTP where ZTP.WP=\':_a\' and SUBSTR(ZTP.TYP,0,1)<>\'~\'',_wp)
?};
_typy


\mk_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Tworzy okno redagowania tabeli ZL (przyciski należy dodawać w odpowiednich miejscach użycia)
::   WE: _a - 'W'arsztatowe/'P'rodukcyjne
::       _b - kategoria zlecenia (P/Z/N)
::   WY: akronim okna/~~
::----------------------------------------------------------------------------------------------------------------------
_wp:=_a;
_kategoria:={? var_pres('_b')>0 || _b || 'P' ?};
{? _wp='P'
|| _txt:={? _kategoria='N'
         || 'złożone z podzleceniami niezależnymi'@
         |? _kategoria='Z'
         || 'złożone z podzleceniami na półfabrykaty'@
         || 'pojedyncze'@
         ?};
   _red:=ZL.mk_edit('Zlecenie produkcyjne'@+' ('+_txt+')',,'zlredp',,,'html_maximized');
   ZL.win_etab(_red,'Dane podstawowe'@);
   ZL.win_ewin(_red,,'RED_PROD');
   ZL.win_etab(_red,'Dane dodatkowe'@);
   ZL.win_ewin(_red,,'DOD_PROD');
   ZL.win_etab(_red,'Koszty'@);
   ZL.win_ewin(_red,,'KOSZTY_P')
|? _wp='W'
|| _red:=ZL.mk_edit('Zlecenie warsztatowe'@,,'zlredw',,,'html_maximized');
   ZL.win_etab(_red,'Dane podstawowe'@);
   ZL.win_ewin(_red,,'RED_WAR');
   ZL.win_etab(_red,'Dane dodatkowe'@);
   ZL.win_ewin(_red,,'DOD_WAR');
   ZL.win_etab(_red,'Koszty'@);
   ZL.win_ewin(_red,,'KOSZTY_W')
|| _red:=~~
?};
_red


\set_dict
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Ustawia okna słowników
::----------------------------------------------------------------------------------------------------------------------
KH.win_dict('WER');
KH.actions('WER','W');
~~


\add_btn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Dodaje przyciski do okna redagowania tabeli ZL
::   WE: _a - akronim okna - wynik formuły exec('mk_edit','zl_head')
::       _b - czy przycisk 'Zakończ' jest dostępny (1), wyszarzony (0)
::       _c - czy przycisk 'Ok' jest dostępny (1), niedostępny (0)
::----------------------------------------------------------------------------------------------------------------------
_red:=_a;
_proc:=_b;
_ok:=_c;
_ff:="params_exec('priority_action_red','#b__box')";
ZL.win_ebtn(_red,'text=%1,btn_label_align=center,panel=bottom,align=begin'['Pr&iorytet'@],_ff);
exec('zakoncz','#window',ZL,_red,_proc,"params_get().args.buffer.STAT_N:='T';'key:F2'",0,
   exec('help_red_zakoncz','#window','C'),exec('text_red_zakoncz','#window','C'));
exec('ok_esc','#window',ZL,_red,_proc,,,_ok,,exec('help_red_ok','#window','Z'),exec('text_red_ok','#window')
   ,exec('help_red_esc','#window','A'));
~~


\efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Opcje pól nagłówka zlecenia
::   WE: _a - akronim okna redagowania
::----------------------------------------------------------------------------------------------------------------------
_tech:=ZL.TYP().TECH='N' | ZL.RODZAJ='Z';
_atr:=ZL.KTM().M_ATR;
_edit_ktm:=_edit_tktl:=1;
{? type_of(params_get())>0 & var_pres('args',params_get())>0
|| {? var_pres('edit_ktm',params_get().args)>0 || _edit_ktm:=params_get().args.edit_ktm ?};
   {? var_pres('edit_tktl',params_get().args)>0 || _edit_tktl:=params_get().args.edit_tktl ?}
?};
ZL.efld_opt(_a,{? ZL.RODZAJ='N' || 'enable=0' || 'enable=1,editable='+$_edit_ktm ?},,'KTM');
ZL.efld_opt(_a,{? ZL.RODZAJ='N' || 'enable=0'
   |? _tech || 'mark=1,enable=1,editable='+$_edit_tktl || 'mark=0,enable=1,editable='+$_edit_tktl ?},VAR,'ZRED_KTL');
ZL.efld_opt(_a,{? ZL.RODZAJ='N' || 'enable=0' || 'enable=1' ?},VAR,'RED_WER');
ZL.efld_opt(_a,{? ZL.RODZAJ='N' || 'enable=0' || 'enable=1' ?},,'IL');
ZL.efld_opt(_a,{? ZL.RODZAJ='N' || 'enable=0' || 'enable=1' ?},M,'J');
ZL.efld_opt(_a,{? ZL.RODZAJ='N' || 'enable=0' || 'enable=1' ?},VAR,'SERIATCH');
ZL.efld_opt(_a,{? ZL.RODZAJ='Z' || 'enable=1' || 'enable=0' ?},,'AUTGENZL');
ZL.efld_opt(_a,{? ZL.RODZAJ='P' || 'enable=0' || 'enable=1' ?},,'GENLIM');
ZL.efld_opt(_a,{? ZL.RODZAJ='P' || 'enable=0' || 'enable=1' ?},,'GENPRZEW');
ZL.efld_opt(_a,{? ZL.RODZAJ='N' | _atr=null() || 'enable=0' || 'enable=1' ?},M_ATR,'SYM');
ZL.efld_opt(_a,{? ZL.RODZAJ='N' | _atr=null() || 'enable=0' || 'enable=1' ?},M_ATR,'NAZ');
ZL.efld_opt(_a,{? ZL.RODZAJ='N' | _atr=null() || 'enable=0' || 'enable=1' ?},,'DK_C');
ZL.efld_opt(_a,{? ZL.RODZAJ='N' | _atr=null() || 'enable=0' || 'enable=1' ?},DK_C,'KOD');
{! _it:=1..10
|! ZL.efld_opt(_a,{? ZL.RODZAJ='N' | _atr=null() || 'enable=0' || 'enable=1' ?},M_ATR,'SL_'+form(_it,-2,0));
   ZL.efld_opt(_a,{? ZL.RODZAJ='N' | _atr=null() || 'enable=0' || 'enable=1' ?},ATR,'WAR'+form(_it,-2,0))
!};
ZL.efld_opt(_a,{? ZL.RODZAJ='N' || 'enable=0' |? _tech || 'enable=0' || 'enable=1' ?},,'STAT_T');
_rubr:=exec('crub','zl_head');
{! _it:=1.. obj_len(_rubr)
|! _crub:=($('VAR1.CRUB'+_rubr[_it]+'=null()'))();
   ZL.efld_opt(_a,{? _crub  || 'enable=0' || 'enable=1' ?},VAR1,'CRUB'+_rubr[_it]);
   ZL.efld_opt(_a,{? _crub  || 'enable=0' || 'enable=1' ?},VAR1,'WAR0'+_rubr[_it]);
   ZL.efld_opt(_a,{? _crub  || 'enable=0' || 'enable=1' ?},VAR1,'WAR1'+_rubr[_it])
!};
:: Projekt
{? ZL.PROJEKTY=null() & (ZL.TYP().PROJZAKR='' | ZTP.PROJZAKR=exec('projzakr_nie_dotyczy','projekty'))
|| ZL.efld_opt(_a,'enable=0',,'PROJEKTY')
|| ZL.efld_opt(_a,'enable=1',,'PROJEKTY')
?};
~~


\zl_dolacz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Przed 'Dodaj' zlecenie
::   WE: _a - rodzaj zlecenia: 'P'rodukcyjne, 'W'arsztatowe
::       [_b] - typ zlecenia: ZTP.ref()
::       [_c] - kategoria zlecenia (ZL.RODZAJ) P/Z/N
::       [_d] - zlecenie nadrzędne - ma znaczenie tylko dla prostego zlecenia produkcyjnego
::              może to być zlecenie niezależne albo zlecenie podrzędne zlecenia z półfabrykatami
::       [_e] - technologia zlecenia: TKTL.ref()
::       [_f] - produkt zlecenia: M.ref()
::   WY: ZL.ref() / null()
::  OLD: \zl_b_dod/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') || _wp:=_a || FUN.info('Brak parametru _a.'@); return() ?};
{? var_pres('_b')=type_of(null()) || _ztp:=_b || _ztp:=null() ?};
{? var_pres('_c')=type_of('') || _kategoria:=_c || _kategoria:='P' ?};
{? var_pres('_d')=type_of(null()) || _zl_nad:=_d || _zl_nad:=null() ?};
{? var_pres('_e')=type_of(null()) || _tktl:=_e || _tktl:=null() ?};
{? var_pres('_f')=type_of(null()) || _ktm:=_f || _ktm:=null() ?};

_zl_top:=exec('top_level','zl_link',_zl_nad);

_res:=null();

KOMM.init(200,,'Dołączanie zlecenia — dodatkowe informacje'@);

VAR.A_ZLNAD:=_zl_nad;
VAR.LEVEL:={? _zl_nad<>null() || 1 || 0 ?};

_atrmjs:=ATR.MJS;
ATR.MJS:='ZL';
{! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !};

{? ~exec('sprdt','zl_head') || return(_res) ?};

{? _ztp<>null()
|| ~~
|? _zl_nad<>null()
|| _ztp:=exec('FindAndGet','#table',ZL,_zl_nad,,"TYP",null())
|| _ztp:=exec('ztp_select','zl_head',_wp,1)
?};
{? _ztp<>null() || VAR.A_TPZL:=_ztp || return(_res) ?};

VAR.A_TPZL:=_ztp;

{? 1+VAR.A_TPZL().TYP='~'
|| FUN.emsg('Funkcja niedostępna — zastrzeżony typ zlecenia.'@);
   return(0)
?};

{? VAR.A_TPZL().KOD_ZLC=''
|| FUN.emsg('Funkcja niedostępna — typ zlecenia nie ma określonego sposobu numeracji.'@);
   return(0)
?};

{? VAR.A_TPZL().WP='P' & VAR.A_TPZL().KOD_ZLP=''
|| FUN.emsg('Funkcja niedostępna — typ zlecenia nie ma określonego sposobu numeracji podzleceń.'@);
   return(0)
?};

exec('tktl_use','tech_common');

{? _zl_nad<>null()
|| POM.TYPDOK:=ZTP.KOD_ZLP
|| POM.TYPDOK:=ZTP.KOD_ZLC
?};
POM.TAB:='ZL';
exec('add_grnr','numery','ZLC');
exec('add_grnr','numery','ZLP');

_sprawdz:=1;
_a_stan:=VAR.A_STAN;
_a_hid:=VAR.A_HIDDEN;
_ok:=1; _add_wyd:=0;
{? _wp='P'
|| {?
:: TODO: ZLECENIA_ZŁOŻONE
      1
::      VAR.A_ZLNAD=null() | (VAR.A_ZLNAD<>null() & VAR.TECH)
   || {? VAR.A_ZLNAD<>null()
      & 0
::      & VAR.A_ZLNAD().AUTGENZL='T'
      || FUN.emsg('Dla tego typu zlecenia podzlecenia dołączane są automatycznie.'@);
         _ok:=0
      || _red:=exec('mk_edit','zl_head',_wp,_kategoria);
         exec('add_btn','zl_head',_red,1,1);
         exec('set_dict','zl_head');
         ZL.win_edit(_red);
         _ok:=1
      ?}
   || FUN.emsg('Zatwierdzona technologia zlecenia nadrzędnego.\nDodanie nowego zlecenia nie jest możliwe.'@);
      _ok:=0
   ?};
   {? VAR.A_ZLNAD<>null() & VAR.A_ZLNAD().RODZAJ='N'
   || _add_wyd:=1; _wyd:=ZL.JORG
   ?}
|? _wp='W'
|| _red:=exec('mk_edit','zl_head',_wp);
   exec('add_btn','zl_head',_red,1,1);
   exec('set_dict','zl_head');
   ZL.win_edit(_red);
   _ok:=1
|| _ok:=0
?};

ZL.cntx_psh();
ZL.prefix();
_new_zl:=0;
_old_unrzl:=VAR.A_UNRZL;
{? 4+cur_win(1,1)='PWER'
|| VAR.A_UNRZL:=0
?};
ZL.blank(1); ZL.blank();
ZL.RODZAJ:=_kategoria;
ZL.TREE_TYP:=_kategoria;
{? exec('is_main_podzlec','zl_link')>0
|| {? _zl_nad=null()
   || ZL.RP:='T'
   ||
::    Przypadek ręcznego dołączania podzlecenia:
      _top_rodzaj:=exec('top_rodzaj','zl_link',_zl_nad);
::    - Jeżeli na samej górze coś innego rodzaju niż 'Z' to umożliwiam raportowanie na magazyn (np zlecenie niezależne)
      {? _top_rodzaj<>'Z'
      || ZL.RP:='T'
      ?};
::    - Podmiana typu w drzewie z P na F (zlecenie półfabrykatowe) jeżeli w zleceniu złożonym
      {? _top_rodzaj='Z'
      || ZL.TREE_TYP:='F'
      ?}
   ?}
?};

VAR.A_UNRZL:=_old_unrzl;

{? _add_wyd || ZL.JORG:=_wyd ?};
ZL.MG:={? ZL.ODDZ=ZTP.MG().ODDZ || ZTP.MG || null() ?};
{? ZL.MG=null() || ZL.MG:=exec('ustmwyd','zl_common',ZL.ODDZ,ZL.JORG,0) ?};
{? ZL.ODDZ<>ZL.MG().ODDZ || ZL.MG:=null() ?};
ZL.LEVEL:=VAR.LEVEL;
ZL.TREE:=#_zl_nad;
ZL.NRPZL:=exec('FindAndGet','#table',ZL,_zl_nad,,"UNRZL",0);
ZL.NRNZL:=exec('FindAndGet','#table',ZL,_zl_top,,"UNRZL",0);

{? ZL.TREE || ZL.NODE:=exec('node','zl_head') ?};

:: PROJEKTY dla zlecenia złożonego
{? _zl_nad<>null()
|| _proj_nad:=exec('FindAndGet','#table',ZL,_zl_nad,,"PROJEKTY",null());
   ZL.PROJEKTY:=_proj_nad
?};

:: Gdy podany indeks, a zlecenie bez własnej technologii, to sprawdzenie, czy indeks posiada aktywną technologię
{? _ktm<>null() & ~(ZL.TYP().TECH='T' & ZL.RODZAJ='P') & exec('is_tech','tech_common',_ktm,1,1,1)<=0
|| _msg:='Nie można utworzyć zlecenia produkcyjnego.\n'
         'Indeks materiałowy %1 nie posiada aktywnej technologii.'@[exec('FindAndGet','#table',M,_ktm,,"KTM",'')];
   FUN.info(_msg);
   _ok:=0
?};

exec('ust_znac','zl_head');
exec('set_rodz_tex','zl_head');
ZL.SYM:='~'+$ZL.tm_stamp();
{? _ok & ZL.add() & exec('zl_lock','zl_common',,'N')
|| ZL.memo_set('','OPIS_DOD');
   ZL.memo_put(,'OPIS_DOD');
   _new_zl:=#ZL.ref();
   {? ZL.TREE=0
   || ZL.NODE:=exec('node','zl_head')
   ?};
   ZL.put();
   {? exec('enabled','zl_uslugi')
   || exec('mat_grp_f3','zl_uslugi',0,'W')
   || exec('slo_m_ok','material','T',0,,'W');
      exec('filter','material','WP')
   ?};
   MG.f_clear();

   exec('ustaw_pola','zl_head');

   exec('openmask','zl_common',ZL.ref());
   ZL.get();
   ZL.SYM:='';

  _buffer:=exec('buffer','zl_head'); _buffer.get();
   _args:=obj_new('buffer','sprawdz','edit','edit_tktl','edit_ktm');
   _args.buffer:=_buffer;
   _args.sprawdz:=_sprawdz;
   _args.edit:=1;
   _args.edit_tktl:=_tktl=null();
   _args.edit_ktm:=_ktm=null();
   params_set('args',_args);

:: Uzupełnienie wartoścamii domyślnymi, gdy zlecenie tworzone z poziomu materiału/technologii
   {? _tktl<>null() & _ktm=null()
   ||
::    Uzupełnienie produktem domyślnym gdy podana technologia zlecenia
      _ktm:=exec('FindAndGet','#table',TKTL,_tktl,,"TKTL.KTM",null());
      {? _ktm=null()
      || _tktl:=null();
         _args.edit_tktl:=1
      ?}
   |? _ktm<>null() & _tktl=null()
   ||
::    Uzupełnienie domyślnej technologii, gdy podany produkt zlecenia
      _tktl:=exec('dflt_ktl','tech_prod',_ktm,1,0)
   ?};

:: Wtyczka na wypełnienie konta kosztowego
   {? Plugin.runnable('ZL_KONTO_001')
   || _kk:=Plugin.run('ZL_KONTO_001',ZL.ODDZ,ZL.JORG);
      {? type_of(_kk)=type_of(KK.ref()) & _kk<>null()
      || ZL.KK:=_kk
      ?}
   ?};

:: ZLECENIE PRODUKCYJNE
   {? _wp='P'
   ||
::    Przypisanie produktu i technologii zlecenia
      ZL.KTM:=_ktm;
      ZL.KTL:=_tktl;
      VAR.ZRED_KTL:=ZL.KTL().NRK;
      VAR.RED_WER:=ZL.KTL().WER;
      {? _ktm<>null()
      || {? ~exec('poredt','zl_head',0)
         ||
::          Nie udało się przypisać produktu
            ZL.KTM:=null();
            ZL.KTL:=null();
            _args.edit_ktm:=1;
            _args.edit_tktl:=1
         || {? _tktl<>null()
            || {? ~exec('zred_ktl_po','zl_head',0)
               ||
::                Nie udało się przypisać technologii
                  ZL.KTL:=null();
                  _args.edit_tktl:=1
               ||
::                Dodatkowe przypisanie zmiennych na podstawie technologii
                  VAR.RED_WER:=ZL.KTL().WER;
                  VAR.SERIATCH:=TKTL.SERIA;
                  {? ZL.IL=0 || ZL.IL:=exec('optymseria','zl_head') ?};
                  ZL.GKTL:=TKTL.GKTL
               ?}
            ?}
         ?}
      ?};
      VAR.ZRED_KTL:=ZL.KTL().NRK;
      VAR.RED_WER:=ZL.KTL().WER;

      {? VAR.FILTER='T' || ZL.KTM:=FILTER.KTM ?};
      _valid:="exec('valid_add','zl_head','P')";
      exec('efld_opt','zl_head',_red);
      menu_txt(,'Dołącz');
      _args.buffer.STAT_N:=ZL.STAT_N;
      {? ZL.edit(_valid)
      || ZL.IL0:=ZL.IL;
         ZL.STAT_N:=_args.buffer.STAT_N;
         exec('set_rodz_tex','zl_head');
         ZL.SCEAN:=exec('blzl_sce','kody_kresk');
         ZL.ZLEAN:=exec('blzl2sce','kody_kresk');
::       Dołączenie cechy dostawy
         {? (1+ZL.MG().TYP)='D' & ATR.FLAG_ED & ATR.FLAG<>1
         || exec('akcepatr','mat_atr',0,1)
         ?};

         {? ZL.put()
         || ZL.memo_put(,'OPIS_DOD');
            {? ZL.SCEAN<>'' & ZL.KTM().IDMOB='Z' || exec('mkodkadd','kody_kresk',ZL.KTM,ZL.SCEAN,$ZL.ref()) ?};
            VAR.A_ZLEC:=ZL.ref();
            {? ZL.NRNZL=0
            || {? ZL.f_active()=1
               || ZL.f_add()
               |? ZL.f_active()>=2
               || ZL.f_rfresh()
               ?}
            ?};

            exec('add_zleczam','zl_gen',ZL.ref(),ZL.IL);
:: TODO: ZLECENIA_ZŁOŻONE
::            exec('ae_join','zlec4');
            exec('zl2obj','px_obj');

            exec('add_zwar_pos','zl_common','_n',0);
            exec('zl_unlock','zl_common',,'N');
            _res:=ZL.ref()
         ||
            oldnumer:=1;
            numer:=ZL.NR;
            exec('nr_old','numery');
            exec('zl_unlock','zl_common',,'N');
            ZL.del();
            _res:=null()
         ?}
      ||
         oldnumer:=1;
         numer:=ZL.NR;
         exec('nr_old','numery');
         exec('zl_unlock','zl_common',,'N');
         ZL.del();
         _res:=null()
      ?}

:: ZLECENIE WARSZTATOWE
   || _valid:="exec('valid_add','zl_head','W')";
      menu_txt(,'Dołącz');
      _args.buffer.STAT_N:=ZL.STAT_N;
      {? ZL.edit(_valid)
      || ZL.STAT_N:=_args.buffer.STAT_N;
         {? ZL.put()
         || ZL.memo_put(,'OPIS_DOD');
            exec('set_rodz_tex','zl_head');
            {? ZL.SCEAN<>'' & ZL.KTM().IDMOB='Z' || exec('mkodkadd','kody_kresk',ZL.KTM,ZL.SCEAN,$ZL.ref()) ?};
            VAR.A_ZLEC:=ZL.ref();
            {? ZL.NRNZL=0
            || {? ZL.f_active()=1
               || ZL.f_add()
               |? ZL.f_active()>=2
               || ZL.f_rfresh()
               ?}
            ?};

            exec('add_zleczam','zl_gen',ZL.ref(),ZL.IL);
:: TODO: ZLECENIA_ZŁOŻONE
::            exec('ae_join','zlec4');
            exec('zl2obj','px_obj');

            exec('add_zwar_pos','zl_common','_n',0);
            exec('zl_unlock','zl_common',,'N');
            _res:=ZL.ref()
         ||
            oldnumer:=1;
            numer:=ZL.NR;
            exec('nr_old','numery');
            exec('zl_unlock','zl_common',,'N');
            ZL.del();
            _res:=null()
         ?}
      ||
         oldnumer:=1;
         numer:=ZL.NR;
         exec('nr_old','numery');
         exec('zl_unlock','zl_common',,'N');
         ZL.del();
         _res:=null()
      ?}
   ?};
:: Przywracam tytuł i akcje w słowniku materiałów
   exec('filter_clear','material');
   {? M.f_active()>0 || M.f_clear() ?}
?};
ZL.cntx_pop();
{? _res & _new_zl || exec('findadzl','zl_head',_new_zl) ?};
VAR.A_STAN:=_a_stan;
VAR.A_HIDDEN:=_a_hid;

KOMM.select();
_res


\valid_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Walidacja przy dołączaniu zlecenia
::   WE: _a - 'W'arsztatowe/'P'rodukcyjne
::   WY: '' albo akronim pola, do którego powrocić
::----------------------------------------------------------------------------------------------------------------------
_wp:=_a;
_result:='';

{? _result='' & ZL.NR=0
|| {? exec('wol_nr','numery','ZL')>0
   || FUN.info('Numer zlecenia musi być wypełniony.'@);
      _result:='NR'
   ?}
?};

{? _result='' & ZL.DTR<>date(0,0,0) & ZL.DTR<date()
|| FUN.info('Termin realizacji zlecenia nie może być wcześniejszy od daty dzisiejszej.'@);
   _result:='DTR'
?};

{? ZL.PL_DATA=date(0,0,0) || ZL.PL_DATA:=ZL.DTR ?};
{? _result='' & ZL.PL_DATA>ZL.DTR
|| FUN.info(
      'Wewnętrzny termin realizacji nie może być późniejszy niż planowany termin realizacji zlecenia.\n'
      'Należy podać wcześniejszą datę.'@
   );
   _result:='PL_DATA'
?};

{? _wp='W'
|| {? _result=''
   || _result:=__CHK.record(ZL,,'TYP','PWYD','OPIS');
      {? _result=''
      || {? ZL.STARTD>ZL.ENDD & ZL.ENDD<>date(0,0,0) | ZL.STARTD=ZL.ENDD & ZL.STARTT>ZL.ENDT
         || FUN.info('Data rozpoczęcia musi być wcześniejsza od daty zakończenia.'@);
            _result:='STARTD'
         ?}
      ?}
   ?}

|? _wp='P'
||
:: Sprawdzenie produktu w zleceniach nadrzędnych
   {? ZL.TREE<>0 & ZL.KTM<>null()
   || {? exec('chk_ktm','zl_head',ZL.TREE,ZL.KTM)>0
      || FUN.info('Indeks produktu jest wykorzystany w zleceniu wyższego poziomu.'@);
         _result:='KTM'
      ?}
   ?};

:: Sprawdzenie podstawiowych zależności
   {? _result=''
   || _result:={? exec('spr1_tech','zl_head')>0 || '' || 'ZRED_KTL' ?}
   ?};
   {? _result=''
   || _result:={? ZL.RODZAJ='N'
               || __CHK.record2(ZL,'TYP',,'MG',,'PWYD',,'OPIS',)
               |? ZL.TYP().TECH='N'
               || __CHK.record2(ZL,'TYP',,'MG',,'PWYD',,'KTM',,'KTL','Technologia','IL','Ilość','OPIS',)
               || __CHK.record2(ZL,'TYP',,'MG',,'PWYD',,'KTM',,'IL','Ilość','OPIS',)
               ?};
      {? _result='KTL' || _result:='ZRED_KTL' ?};
      {? _result=''
      || {? ZL.STARTD>ZL.ENDD & ZL.ENDD<>date(0,0,0) | ZL.STARTD=ZL.ENDD & ZL.STARTT>ZL.ENDT
         || FUN.info('Data rozpoczęcia musi być wcześniejsza od daty zakończenia.'@);
            _result:='STARTD'
         ?}
      ?}
   ?};
   {? _result='' & (ZL.RODZAJ='P' & ZL.TYP().TECH='N' | ZL.RODZAJ='Z') & VAR.ZRED_KTL=''
   || TKTLW.index('KSN');
      TKTLW.prefix('T',ZL.KTM,'T','N');
      {? TKTLW.first()
      || FUN.info('Należy wypełnić pole \'\'Technologia\'\'.'@);
         _result:='ZRED_KTL'
      || FUN.info('Należy zmienić produkt.'@);
         _result:='KTM'
      ?}
   ?};
   {? _result='' & ZL.RODZAJ='P' & VAR.ZRED_KTL='' & ZL.SRCTECH='T'
   || _result:={? exec('valid_tech','zl_head') || '' || 'ZRED_KTL' ?}
   ?};

:: Sprawdzam czy magazyn jest z tego samego oddziału co zlecenie
   {? _result='' & ZL.MG().ODDZ<>ZL.ODDZ
   || FUN.emsg('Magazyn przypisany do zlecenia musi być powiązany z tym samym oddziałem co zlecenie.'@);
      _result:='MG'
   ?};

:: Sprawdzam czy magazyn kooperacyjny
   {? _result='' & ZL.MG().KOOP='T'
   || FUN.emsg('Magazyn przypisany do zlecenia nie może służyć do rejestracji kooperacji.'@);
      _result:='MG'
   ?};

:: Sprawdzam czy magazyn zlecenia jest zgodny z cechą zlecenia
   {? _result='' & ZL.DK_C<>null()
   || {? ~(ZL.MG().TYP*'DOST')
      || FUN.emsg('Zlecenie ma wypełnioną cechę. '
                  'Magazyn przypisany do zlecenia musi być typu: \'\'DOSTAWY\'\' lub \'\'DOSTEWI\'\'.'@);
         _result:='MG'
      ?}
   ?};

:: Sprawdzam czy magazyn zlecenia jest zgodny z partiowalnością wyrobu zlecenia
   {? _result='' & exec('material_party','material',ZL.KTM)>0
   || {? ~(ZL.MG().TYP*'DOST')
      || FUN.emsg('Produkt zlecenia jest partiowany. '
                  'Magazyn przypisany do zlecenia musi być typu: \'\'DOSTAWY\'\' lub \'\'DOSTEWI\'\'.'@);
         _result:='MG'
      ?}
   ?}

|| _result:=''
?};

:: Sprawdzanie poprawnosci zwrotu planowania i znacznika kontynuacji po przekroczeniu
{? _result=''
|| _result:=exec('pl_force_chk','px_utils','ZL')
?};

:: Projekty
{? _result='' & ZL.PROJEKTY<>null()
|| _result:=exec('tabdok_chk','projekty',ZL)
?};

:: Identyfikator księgowy
{? _result='' & ZL.ID_KSG<>0
|| ZL.cntx_psh();
   ZL.index('ID_KSG');
   ZL.prefix(ZL.ID_KSG);
   _idadd:=ZL.IDADD;
   {? ZL.first() & ZL.IDADD<>_idadd
   || FUN.emsg('Istnieje zlecenie o identyfikatorze księgowym: %1.'@[$ZL.ID_KSG]);
      _result:='ID_KSG'
   ?};
   ZL.cntx_pop()
?};

:: Jeżeli wszystko dobrze, to dodatkowa walidacja za pomocą wtyczki (tylko podczas dołączania w oknie redagowania)
{? _result='' & cur_kwin()='e_edit' & cur_tab(1,1)=ZL
|| ZL.cntx_psh();
   _result:=Plugin.run('ZL_VALID_001','ADD');
   ZL.cntx_pop()
?};

_result


\findadzl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [12.41]
:: OPIS: ustawia się na aktualnie dodanym zleceniu
::   WE: _a - integer-ref zlecenia
::  OLD: \findadzl/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a>0 & ~ZL.seek(_a,)
|| FUN.info('Dodane zlecenie nie znajduje się w bieżącym zakresie.\nNależy zmienić zakres.'@)
|| {? ZL.f_active()>1 & ~ZL.f_test()
   || FUN.info('Dodane zlecenie nie znajduje się w bieżącym filtrze użytkownika.\nNależy zmienić filtr.'@)
   ?}
?};
~~


\zl_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Przed 'Popraw' zlecenia (w przygotowaniu, otwarte)
::   WE: _a - ZL.ref()
::       _b - czy uruchomiona w procesie (dostępny przycisk Zakończ)
::       [_c] - czy dostępny przycisk OK (domyślnie 1-tak)
::       [_d] - czy dostępny dialog (domyślnie 1-tab)
::       [_e] - bufor tabeli ZL z wartościami, którymi zastąpić aktualne wartości
::       [_f] - INTEGER - [0]/1 - czy aktualizować limit na zleceniu nadrzędnym
::       [_g] - INTEGER - [0]/1 - czy uruchamiane podczas podziału zlecenia
::   WY: 0 / 1
::  OLD: \zl_b_pop/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_proces:=_b;
_btn_ok:={? var_pres('_c')=type_of(0) || _c || 1 ?};
_dialog:={? var_pres('_d')=type_of(0) || _d || 1 ?};
{? var_pres('_e')>100 || _buffer_in:=_e || _buffer_in:=exec('buffer','zl_head'); _buffer_in.bl_void() ?};
_lim_nad:={? var_pres('_f')=type_of(0) || _f || 0 ?};
_split:={? var_pres('_g')=type_of(0) || _g || 0 ?};
_res:=0;
_can_continue:=1;

ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
||
   _buffer:=exec('buffer','zl_head');
   _buffer.get();

   _buffer_tmp:=exec('buffer','zl_head');
   _buffer_tmp.get();
   _buffer_in.mask(_buffer_tmp);
   _buffer_tmp.setf();

   _atrmjs:=ATR.MJS;
   ATR.MJS:='ZL';
   ATR.M_ATR:=ZL.KTM().M_ATR;
   ATR.UZUP:=exec('wz_uzup','mat_atr',ATR.M_ATR);
   {? ZL.DK_C<>null() & ZL.DK_C().M_ATR<>null()
   || {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=($('ZL.DK_C().WAR'+form(_i,-2,,'99')))() !}
   || {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !}
   ?};
   {? ZL.STAN<>'N'
   || ATR.FLAG_ED:=0;
      ATR.FLAG:=0
   || ATR.FLAG_ED:=(1+ZL.MG().TYP)='D' & ATR.CZY_ATR & ATR.M_ATR().EDIT;
      ATR.FLAG:={? ATR.FLAG_ED & ZL.KTM().M_ATR<>null() || 2 || 0 ?};
      {? ATR.FLAG_ED || {? ZL.KTM().M_ATR<>null() || ATR.FLAG_ED:=2 ?} ?}
   ?};

   exec('tktl_use','tech_common');
   _wp:=ZL.TYP().WP;
   DK_C.cntx_psh();
   {? ZL.DK_C<>null() & ref_name(ZL.DK_C)<>DK_C.name() || DK_C.use(ref_name(ZL.DK_C)) ?};
   _ok:={? _wp='P'
        || _red:=exec('mk_edit','zl_head',_wp,ZL.RODZAJ);
           exec('add_btn','zl_head',_red,_proces,_btn_ok);
           exec('set_dict','zl_head');
           ZL.win_edit(_red);
           1
        |? _wp='W'
        || _red:=exec('mk_edit','zl_head',_wp);
           exec('add_btn','zl_head',_red,_proces,_btn_ok);
           exec('set_dict','zl_head');
           ZL.win_edit(_red);
           1
        || 0
        ?};

:: Wyjścia awaryjne - uwaga na konteksty!
   {? ZTP.KOD_ZLC=''
   || FUN.emsg('Funkcja niedostępna — typ zlecenia nie ma określonego sposobu numeracji.'@);
      DK_C.cntx_pop();
      ZL.cntx_pop();
      return(0)
   ?};
   {? ZTP.WP='P' & ZTP.KOD_ZLP=''
   || FUN.emsg('Funkcja niedostępna — typ zlecenia nie ma określonego sposobu numeracji podzleceń.'@);
      DK_C.cntx_pop();
      ZL.cntx_pop();
      return(0)
   ?};

   exec('add_grnr','numery','ZLC');
   exec('add_grnr','numery','ZLP');
   {? VAR.A_ZLNAD<>null() || POM.TYPDOK:=ZTP.KOD_ZLP || POM.TYPDOK:=ZTP.KOD_ZLC ?};
   POM.TAB:='ZL';

   _il:=ZL.IL;
   _sprawdz:=exec('sprawdz_podzlecenia','zl_link',ZL.ref());
   {? _sprawdz || _sprawdz:=~exec('has_zgh','zl_common',ZL.ref()) ?};
   {? _sprawdz || _sprawdz:=~exec('is_zlim_zl','zl_limit',ZL.ref()) ?};

   KOMM.init(250,,'Korekta zlecenia'@,'');
   {? _ok
   ||
::    Zapamiętuje wartości atrybutów przed poprawieniem
      VAR_DEL.delete('DKC_BEF');
      DKC_BEF:=exec('buffer','mat_atr');
      {? ZL.DK_C<>null()
      || DK_C.cntx_psh();
         DK_C.clear();
         {? DK_C.seek(ZL.DK_C)
         || DKC_BEF.get_dkc()
         ?};
         DK_C.cntx_pop()
      ?};

      {? exec('enabled','zl_uslugi')
      || exec('mat_grp_f3','zl_uslugi',0,'W')
      || exec('slo_m_ok','material','T',0,,'W');
         exec('filter','material','WP')
      ?};
      MG.f_clear();

      {? (ZL.STAN='O' & ZL.RODZAJ<>'N') | exec('zlhead_chk','zl_head')
      || {? exec('zl_lock','zl_common',,'N')
         ||
            _familyres:=exec('zl_lockfamily','zl_common',,'N');
            {? _familyres.LOCKED>0
            ||
               exec('ustaw_pola','zl_head');

               _args:=obj_new('buffer','sprawdz','edit');
               _args.buffer:=_buffer;
               _args.sprawdz:=_sprawdz;
               _args.edit:=1;
               params_set('args',_args);

               ZL.memo_get(,'OPIS_DOD',0);

::             ZLECENIE PRODUKCYJNE
               {? _wp='P'
               || _valid:=$("params_exec('valid_modify','zl_head','P',"+$_proces+","+$_dialog+","+$_split+")");
                  exec('efld_opt','zl_head',_red);
                  menu_txt(,'Popraw');
                  _args.buffer.STAT_N:=ZL.STAT_N;
                  {? {? _dialog
                     || {? ZL.edit(_valid)
                        ||
::                         Sprawdzam czy aktualizowane zlecenie nie jest powiązane z limitem zlecenia nadrzędnego
                           {? ZL.NRPZL>0 & ZL.RTMATSRC<>'' & ZL.RP='T' & ZL.IL<>_buffer.IL
                           || _ktm:=ZL.KTM;
::                              _zl:=ZL.ref();
::                            szukam zlecenia nadrzędnego
                              ZL.cntx_psh();
                              ZL.index('UNRZL');
                              ZL.prefix(ZL.NRPZL);
                              {? ZL.first()
                              || ZLIM.cntx_psh();
                                 exec('openmask','zl_common',ZL.ref());
                                 ZLIM.clear();
                                 ZLIM.index('ZKK');
                                 ZLIM.prefix(ZL.ref(),'T',0,_ktm);
                                 {? ZLIM.first()
                                 ||
                                    _msg:='Zlecenie powiązane jest z limitem zlecenia nadrzędnego.\n'
                                          'Czy automatycznie skorygować ilość na tym limicie?'@;
                                    _lim_nad:=FUN.ask(_msg)
                                 ?};
                                 ZLIM.cntx_pop()
                              ?};
                              ZL.cntx_pop()
                           ?};
                           1
                        ?}
                     || VAR.ZRED_KTL:=ZL.KTL().NRK;
                        _valid()=''
                     ?}
                  ||
                     {? ZL.RODZAJ='N'
                     || _has_zgh:=0;
                        _has_part:=0
                     || _main_podzlec:=exec('main_podzlec','zl_link');
                        {? ZL.RODZAJ='Z'
                        || _has_zgh:=exec('get_ilosc_zgh','zl_common',_main_podzlec)
                        || _has_zgh:=exec('get_ilosc_zgh','zl_common',ZL.ref())
                        ?};
                        _has_part:=exec('zl_ile_part','zl_partie',_main_podzlec)
                     ?};

                     _il_zl_zgh:=0;
                     _il_zl_part:=0;
                     _il_zgh:=0;
                     _il_part:=0;
                     _tree:=1;

                     {? ZL.RODZAJ='Z' & exec('kor_coef_equal','zl_head')=0
                     || _msg:='Ilość na zleceniach podrzędnych była korygowana ręcznie.\n'
                              'Zmiana ilości na tym zleceniu nie zostanie naniesiona na strukturę zleceń podrzędnych.\n\n'
                              'Kontynuować?';
                        _can_continue:=FUN.ask(_msg);
                        _tree:=0
                     ?};

                     {? _can_continue>0
                     ||
                        _oper:='';
                        _tktl:='';
                        {? ZL.RTKTL<>''
                        || _tktl:=ZL.RTKTL
                        |? ZL.RKTL<>''
                        || _tktl:=ZL.RKTL
                        ?};
                        {? _tktl<>''
                        || _oper:=exec('FindAndGet','#table',TKTL,_tktl,,"TYP().OPER",'N')
                        ?};

                        {? ZL.IL>_buffer.IL & _has_zgh>=_buffer.IL & _oper='T'
                        ||
::                         Jeżeli zwiększam ilość to najpierw pytanie o podział na przewodniki
::                         o ile nie jest skonfigurowana wtyczka ZGH_F_ILGEN_001
                           {? Plugin.runnable('ZGH_F_ILGEN_001')
                           || _il_zl_zgh:=-1;
                              _il_zgh:=-1
                           || _res_ilosc:=exec('generuj_get_ilosc','zl_guide',,_dialog,0,0);
                              {? _res_ilosc.OK>0
                              || _il_zl_zgh:=_res_ilosc.IL_ZL;
                                 _il_zgh:=_res_ilosc.IL_ZGH
                              || _can_continue:=0
                              ?}
                           ?}
                        |? ZL.IL>_buffer.IL & _has_part>=_buffer.IL
                        ||
::                         Jeżeli zwiększam ilość to najpierw pytanie o podział na partie
                           _can_continue:=exec('generuj_get_ilosc','zl_partie',,_dialog);
                           {? _can_continue>0
                           || _il_zl_part:=ZLEC.IL_ZL;
                              _il_part:=ZLEC.IL_PART
                           ?}
                        |? ZL.IL<_buffer.IL
                        ||
                           _coef:={? _buffer.IL<>0 || ZL.IL/_buffer.IL || 0 ?};
::                         Sprawdzam czy ilości na podzleceniach po korekcie nie będą mniejsze od ilości zaraportowanej
                           _result:=exec('kor_chk_ildok','zl_head',ZL.ref(),_coef,_tree);
                           _can_continue:=_result.RESULT;
                           {? _can_continue=0
                           ||_msg:='Do zlecenia %1 wygenerowano dokumenty raportujące na ilość %2. \n'
                                 'Ilość na zleceniu po korekcie nie może być mniejsza od ilości zaraportowanej.'@
                                 [_result.ZL_SYM,$_result.MIN_IL];
                              {? _dialog
                              || FUN.emsg(_msg)
                              || KOMM.add(_msg,2)
                              ?}
                           ?}
                        ?}
                     ?};

                     _locked:=exec('ref_table','#table');
                     {? _can_continue>0 & ZL.IL<>_buffer.IL
                     ||
::                      Nastąpiło zwiększenie ilości więc przed transakcją blokuje wszystkie
::                      przewodniki żeby im później móc wygenerować powiązania
                        _zl_main:=exec('main_podzlec','zl_link',VAR.A_ZLEC);

::                      Najpierw blokowanie wszystkich przewodników
                        ZGH.index('ZLNR');
                        ZGH.prefix(_zl_main);
                        {? ZGH.first()
                        || {!
                           |? {? exec('blk_lock','#table','ZGH',ZGH.ref())>0
                              || _locked.add(ZGH.ref())
                              || _can_continue:=0;
                                 _msg:='Przewodnik %1 zablokowany, funkcji nie można kontynuować.'@[ZGH.NRPRZ];
                                 {? _dialog
                                 || FUN.emsg(_msg)
                                 || KOMM.add(_msg,2)
                                 ?}
                              ?};
                              ZGH.next() & _can_continue>0
                           !}
                        ?}
                     ?};

::                   Ostrzeżenie o nieaktywnej/archiwalnej technologii
                     {? _can_continue>0  & _args.buffer.STAT_N='T' & ZL.STAT_N<>_args.buffer.STAT_N
                        & exec('FindAndGet','#table',TKTL,ZL.RKTL,,"TKTL.ARCH",'')='T'
                     || _can_continue:=0;
                        _msg:='Nie można zakończyć redakcji nagłówka. Do zlecenia %1 przypisana jest archiwalna technologia'@[ZL.SYM];
                        {? _dialog
                        || FUN.emsg(_msg)
                        || KOMM.add(_msg,2)
                        ?}
                     |? _can_continue>0 & _args.buffer.STAT_N='T' & ZL.STAT_N<>_args.buffer.STAT_N & ZL.KTL<>null & ~exec('tktl_act','tech_head',1)
                     ||
                        _msg:='Do zlecenia %1 przypisana jest nieaktualna karta technologiczna.Czy zakończyć redakcję nagłówka zlecenia na jej podstawie?'@[ZL.SYM];
                        _choice:=FUN.choice(_msg,,'Tak',,,,'Nie');
                        {? _choice
                        || _can_continue:=1
                        || _can_continue:=0;
                           _msg:='Nie zakończono redakcji nagłówka. Do zlecenia %1 przypisana jest nieaktualna technologia'@[ZL.SYM];
                           {? _dialog
                           || FUN.emsg(_msg)
                           || KOMM.add(_msg,2)
                           ?}
                        ?}
                     ?};
::                   Jeżeli zwiększam ilość (i będą generowane przewodiki) to najpierw pytanie
::                   czy generować operacje wariantowe ostatniego przewodnika
                     {? _can_continue>0 & _il_zgh<>0 & ZL.IL>_buffer.IL
                     || {? exec('zl_has_wariant','zl_head',ZL.ref(),'LAST',_tree)>0
                        || _msg:='Technologia zlecenia posiada zdefiniowane wariantowe operacje ostatniego przewodnika.\n'
                                 'Czy wygenerować takie operacje do tworzonego przewodnika oraz usunać '
                                 'wariantowe operacje z aktualnie ostatniego przewodnika?'@;
                           _choice:=FUN.choice(_msg,,'Generuj i usuń'@,'Generuj i nie usuwaj'@,,,'Nie generuj'@);
                           {? _choice=2
                           || VAR.WAR_GEN:='T';
                              VAR.WAR_DEL:='N'
                           |? _choice=1
                           || VAR.WAR_GEN:='T';
                              VAR.WAR_DEL:='T'
                           || VAR.WAR_GEN:='N';
                              VAR.WAR_DEL:='N'
                           ?}
                        ?}
                     ?};

                     {? _can_continue>0
                     ||
::                      Rozpoczęcie transakcji
                        do();
                        ZL.STAT_N:=_args.buffer.STAT_N;
                        _coef_top:={? _buffer.IL<>0 || ZL.IL/_buffer.IL || 0 ?};
                        {? _buffer.IL<>ZL.IL
                        || ZL.KOR_COEF:=_coef_top
                        ?};
::                      Modyfikacje ZLZAM dotyczą zlecenia prostego albo nagłówka złożonego
::                     {? exec('top_rodzaj','zl_link',ZL.ref())='Z'
::                     || _zlec:=exec('top_level','zl_link',ZL.ref())
::                     || _zlec:=ZL.ref()
::                     ?};
                        {? ZL.RODZAJ='Z' | ZL.RODZAJ='P' & ZL.NRNZL=0
                        || _zlec:=ZL.ref();
::                         Gdy zmniejszona ilość na zleceniu to sprawdzamy czy powiązane z zamówieniem
                           {? ZL.IL<_buffer.IL
                           || _can_continue:=exec('zlzam_decrease','zl_gen',,ZL.IL);
                              {? _can_continue>0
                              || _can_continue:=ZL.put()
                              ?}
                           || _can_continue:=ZL.put();
                              {? _can_continue>0
                              || exec('add_zleczam','zl_gen',_zlec,ZL.IL-_il)
                              ?}
                           ?}
                        |? ZL.RODZAJ='P' & ZL.NRNZL<>0 & exec('top_rodzaj','zl_link',ZL.ref())='Z'
                        ||
::                         Gdy zlecenie pojedyncze w strukturze zlecenia złożonego, usuwamy powiązania między przewodnikami
                           _can_continue:=ZL.put();
                           {? _can_continue>0
                           || _var_zlec:=VAR.A_ZLEC;
                              VAR.A_ZLEC:=exec('root_zlec','zl_link',ZL.ref());
                              exec('gendom_zl','zl_guide','N',0);
                              VAR.A_ZLEC:=_var_zlec
                           ?}
                        || _can_continue:=ZL.put()
                        ?};
::                      Usunięcie wariantowych operacji ostatniego przewodnika
                        {? _can_continue>0 & VAR.WAR_DEL='T'
                        || ZGH.cntx_psh();
                           ZGH.index('ZLNR');
                           ZGH.prefix(ZL.ref(),);
                           {? ZGH.last()
                           || ZGP.cntx_psh();
                              ZGP.index('WHERE');
                              ZGP.prefix(ZGH.ref(),'O',);
                              {? ZGP.first()
                              || VAR_DEL.delete('_visited');
                                 _visited:=exec('ref_table','#table');
                                 {!
                                 |?
                                    _del:=0;
                                    {? _visited.r_find(ZGP.ref())=0
                                    || _visited.add(ZGP.ref());
                                       _del:=exec('zgp_del','zl_guide',1)
                                    ?};
                                    {? _del=0
                                    || _next:=ZGP.next()
                                    |? _del=1
                                    || _next:=0
                                    || _next:=1
                                    ?};
                                    _next
                                 !};
                                 VAR_DEL.delete('_visited')
                              ?};
                              ZGP.cntx_pop()
                           ?};
                           ZGH.cntx_pop()
                        ?};

                        {? _can_continue>0 & ZL.STAN='O'
                        || exec('obl_prod','magazyn_stan',ZL.KTM,ZL.MG,2)
                        ?};
                        {? _can_continue>0 & _tree>0
                        ||
::                         Nanoszę współczynnik korekty na podzlecenia
                           _can_continue:=exec('kor_coef_set','zl_head',,ZL.KOR_COEF)
                        ?};
                        _zgh_corrected:=exec('ref_table','#table');
                        {? _can_continue>0
                        ||
::                         Po zaputowaniu zlecenia uruchamiamy faktyczne modyfikacje przewodników, limitów itp
                           _can_continue:=exec('zl_il_change','zl_head',,_buffer
                                                                        ,ZL.IL
                                                                        ,_buffer.IL
                                                                        ,_buffer.KTM
                                                                        ,_buffer.KTL
                                                                        ,
                                                                        ,
                                                                        ,_il_zl_zgh
                                                                        ,_il_zgh
                                                                        ,_il_zl_part
                                                                        ,_il_part
                                                                        ,
                                                                        ,_tree
                                                                        ,_zgh_corrected
                                                                        ,_lim_nad)
                        ?};

                        {? _can_continue>0
                        ||
::                         Jeżeli stoję na zleceniu montażowym, to uruchamiam też na zleceniu na samej górze
                           _top_rodzaj:=exec('top_rodzaj','zl_link',ZL.ref());
                           {? _top_rodzaj='Z' & exec('is_main_podzlec','zl_link')
                           || _top_level:=exec('top_level','zl_link',ZL.ref());

                              {? _can_continue>0 & _tree>0
                              ||
::                               Nanoszę współczynnik korekty na nadzlecenie
                                 _can_continue:=exec('kor_coef_set','zl_head',_top_level,ZL.KOR_COEF,0)
                              ?};
                              {? _can_continue>0
                              ||
                                 _can_continue:=exec('zl_il_change','zl_head',_top_level
                                                                              ,_buffer,ZL.IL
                                                                              ,_buffer.IL
                                                                              ,_buffer.KTM
                                                                              ,_buffer.KTL
                                                                              ,
                                                                              ,
                                                                              ,_il_zl_zgh
                                                                              ,_il_zgh
                                                                              ,_il_zl_part
                                                                              ,_il_part
                                                                              ,1
                                                                              ,0
                                                                              ,_zgh_corrected
                                                                              ,_lim_nad)
                              ?}
                           ?}
                        ?};

                        {? _can_continue>0
                        || {? _args.buffer.STAT_N='T'
                           || exec('akt_terminy','zl_common',_buffer,0)
                           ?}
                        ?};
                        {? _can_continue>0
                        || {? _args.buffer.STAT_N='T'
                           || exec('akt_plany','zl_common',_buffer.STARTD,_buffer.STARTT,_buffer.ENDD,_buffer.ENDT,0)
                           ?}
                        ?};
                        {? _can_continue>0
                        || exec('akt_znaczniki','zl_common',_buffer.PL_FORCE,_buffer.PL_DIR)
                        ?};
                        {? _can_continue>0
                        || GROPP.cntx_psh();
                           GROPP.index('ZL');
                           GROPP.prefix(ZL.ref());
                           {? GROPP.first()
                           || {!
                              |? exec('termin_update','zl_grop',GROPP.GROP);
                                 GROPP.next()
                              !}
                           ?};
                           GROPP.cntx_pop()
                        ?};
                        {? _can_continue>0
                        || exec('akt_projekty','zl_common',_buffer.PROJEKTY)
                        ?};

                        {? _can_continue>0
                        || ZL.memo_put(,'OPIS_DOD');
                           {? ZL.SCEAN<>'' & ZL.KTM().IDMOB='Z'
                           || exec('mkodkadd','kody_kresk',ZL.KTM,ZL.SCEAN,$ZL.ref())
                           ?}
                        ?};
                        {? _can_continue>0
                        ||
::                         Aktualizacja obiektu planowanego dotyczącego zlecenia
                           exec('zl2obj','px_obj',ZL.ref());
::                         Poprawienie słowników użytkownika
                           exec('pop_slo','slo_slu','ZL')
                        ?};

                        {? _can_continue>0
                        ||
::                         Porównuje wartości cechy po poprawieniu
                           _dkc_after:=exec('buffer','mat_atr');
                           {? ZL.DK_C<>null()
                           || DK_C.cntx_psh();
                              DK_C.clear();
                              {? DK_C.seek(ZL.DK_C)
                              || _dkc_after.get_dkc()
                              ?};
                              DK_C.cntx_pop()
                           ?};
                           {? DKC_BEF.compare(_dkc_after)<>1
                           ||
::                            Jeśli wartości atrybutów się zmieniły to aktualizuje podzlecenia
                              exec('podzlec_dkc_upd','zl_common',ZL.ref())
                           ?}
                        ?};
                        {? _can_continue<=0
                        || undo()
                        ?};
                        end()
                     ?};

::                   Odblokowuje wszystkie zablokowane przewodniki
                     _tab:=_locked.tab;
                     _tab.prefix();
                     {? _tab.first()
                     || {!
                        |? exec('blk_unlock','#table','ZGH',ref_name(_tab.SQL),BIT.sqlint(_tab.SQL));
                           _tab.next()
                        !}
                     ?};
                     ~~
                  ||
::                   Użytkownik nacisnął ESC lub walidacja nie udana jak bezdialogowo
                     _can_continue:=0
                  ?}
::             ZLECENIE WARSZTATOWE
               || _valid:=$("params_exec('valid_modify','zl_head','W',"+$_proces+")");
                  menu_txt(,'Popraw');
                  _args.buffer.STAT_N:=ZL.STAT_N;
                  {? {? _dialog
                     || ZL.edit(_valid)
                     || _valid()=''
                     ?}
                  || ZL.STAT_N:=_args.buffer.STAT_N;
                     _can_continue:=ZL.put();
                     {? _can_continue>0
                     || ZL.memo_put(,'OPIS_DOD');
                        {? ZL.SCEAN<>'' & ZL.KTM().IDMOB='Z' || exec('mkodkadd','kody_kresk',ZL.KTM,ZL.SCEAN,$ZL.ref()) ?};
::                      Aktualizacja obiektu planowanego dotyczacego zlecenia
                        exec('zl2obj','px_obj',ZL.ref());
::                      Poprawienie słowników użytkownika
                        exec('pop_slo','slo_slu','ZL')
                     ?}
                  ||
::                Użytkownik nacisnął ESC
                     _can_continue:=0
                  ?}
               ?}
            ?};
            exec('zl_unlockfamily','zl_common',_familyres.TAB,'N');
            exec('zl_unlock','zl_common',,'N')
         ?}
      ?};
::    Przywracam tytuł i akcje w słowniku materiałów
      exec('filter_clear','material')
   ?};
   VAR_DEL.delete('DKC_BEF');
   KOMM.select();
   DK_C.cntx_pop();
   VAR.A_STAN:=ZL.STAN;
   VAR.WAR_GEN:='T';
   VAR.WAR_DEL:='N';
   ATR.MJS:=_atrmjs
?};
ZL.cntx_pop();
{? _can_continue>0
|| _res:=1
?};
_res


\zl_usun_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy można usunąć zlecenie razem ze wszystkimi podzleceniami
::   WE: [_a] - ZL.ref lub bieżący rekord
::       [_b] - INTEGER - [0]/1 - czy akcja grupowa
::       [_c] - INTEGER - 0/[1] - czy włączone dialogi
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_grupa:=0;
{? var_pres('_b')=type_of(0)
|| _grupa:=_b
?};

_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _result:=1;
   _sect:=exec('ZL','#to_string',ZL.ref());
:: 1. sprawdzenie powiązań ze słownikami użytkownika
   {? _can_continue>0
   || {? exec('czy_slo','slo_slu','ZL')
      ||
         {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
         KOMM.add('Zlecenie wykorzystywane w "Słownikach użytkownika".'@,2,,1);
         KOMM.sect_end();
         _result:=0
      ?}
   ?};

:: 2. sprawdzenie stanu zlecenia
   {? _can_continue>0
   || {? ZL.STAN<>'N'
      || {? exec('uprDelZatwZl','zl_head')=0
         || {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
            KOMM.add('Zlecenie ma innny stan niż w przygotowaniu.'@,2,,1);
            KOMM.sect_end();
            _result:=0
         ?}
      ?}
   ?};

:: 3. sprawdzenie nowo dołączanego zlecenia
   {? _can_continue>0
   || {? ZL.OPIS='' & (ZL.sel_size()>0 | sec_superuser()=0)
      || {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
         KOMM.add('Nowo dołączane zlecenie, usunięcie nie jest możliwe.'@,2,,1);
         KOMM.sect_end();
         _result:=0
      ?}
   ?};
   _top_level:=exec('top_level','zl_link',ZL.ref());

:: 4. sprawdzenie wykorzystywania w planie operacyjnym
   {? _can_continue>0
   || {? exec('zlec_planned','po_plan',$ZL.ref())>0
      || {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
         KOMM.add('Zlecenie znajduje się w planie operacyjnym, usunięcie nie jest możliwe.'@,2,,1);
         KOMM.sect_end();
         _result:=0
      ?}
   ?};

:: 5. sprawdzenie wykorzystywania w planie strategicznym
   {? _can_continue>0
   || {? exec('zl_utilization','px_plan',ZL.ref())>0
      || {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
         KOMM.add('Zlecenie znajduje się w planie strategicznym, usunięcie nie jest możliwe.'@,2,,1);
         KOMM.sect_end();
         _result:=0
      ?}
   ?};

:: 6. Sprawdzenie czy zlecenie nadrzędne jest w planie strategicznym jeśli przepis zintegrowany
   {? ZL.RODZ_TEX='Z'
   || {? exec('zl_utilization','px_plan',_top_level)>0
      || {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
         KOMM.add('Zlecenie nadrzędne znajduje się w planie strategicznym, usunięcie nie jest możliwe.'@,2,,1);
         KOMM.sect_end();
         _result:=0
      ?}
   ?};

:: 6. sprawdzenie czy można usunąć partie zlecenia
   {? _can_continue>0
   || {? exec('zl_delete_chk','zl_partie',ZL.ref(),1)=0
      || _result:=0
      ?}
   ?};

:: TODO: FILTRY
::exec('spr_fltr','zlec5',0);
   _locked:=0;
:: 7. sprawdzenie blokad
   {? _can_continue>0
   || {? exec('zl_lock','zl_common',,'N',1) &
         exec('zl_lock','zl_common',,'T',1) &
         exec('zl_lock','zl_common',,'I',1)
      || _locked:=1
      || KOMM.add('Zlecenie jest redagowane przez innego użytkownika, usunięcie nie jest możliwe.'@,2,,1);
         KOMM.sect_end();
         _result:=0
      ?}
   ?};
   _locktab:=exec('zl_lock_tab','zl_common');
   {? _can_continue>0
   || _locked1:=exec('zl_lockfamily','zl_common',,'N',0,_locktab);
      _locked2:=exec('zl_lockfamily','zl_common',,'T',0,_locktab);
      _locked3:=exec('zl_lockfamily','zl_common',,'I',0,_locktab);
      {? _locked1.LOCKED=0 | _locked2.LOCKED=0 | _locked3.LOCKED=0
      || {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
         KOMM.add('Zlecenie podrzędne jest redagowane przez innego użytkownika, usunięcie nie jest możliwe.'@,2,,1);
         KOMM.sect_end();
         _result:=0
      ?}
   ?};
   _zloz:=1;
   {? ZL.NRNZL=0 & ZL.RODZAJ<>'P'
   || {? exec('sprawdz_podzlecenia','zl_link',ZL.ref())
      || _zloz:=1
      || _zloz:=2
      ?}
   ?};
:: 8. sprawdzenie zatwierdzeń nadzleceń
::   {? _can_continue>0 & _zloz=1
::   || ZL.cntx_psh();
::      ZL.index('UNRZL');
::      ZL.prefix(ZL.NRNZL);
::      {? ZL.first()
::      || {? ZL.STAT_T='T'
::         || {? exec('uprDelZatwZl','zl_head')=0
::            || _result:=0;
::               {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
::               KOMM.add('Zlecenie nadrzędne posiada zatwierdzenia, usunięcie nie jest możliwe.'@,2,,1);
::               KOMM.sect_end();
::               _result:=0
::            ?}
::         ?}
::      ?};
::      ZL.cntx_pop()
::   ?};

:: 9. Sprawdzenie czy są porejestrowane wykonania
   _sub_zlec:=exec('subzlec_exist','zl_link',ZL.ref());
   {? _sub_zlec=0
   || {? exec('has_zlgd','zl_common',ZL.ref())>0
      ||
         {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
         KOMM.add('Zlecenie posiada zarejestrowaną robociznę, usunięcie nie jest możliwe.'@,2,,1);
         KOMM.sect_end();
         _result:=0
      ?}
   ?};
:: 10. Sprawdzenie czy istnieją jakieś dokumenty magazynowe
   _args_hasdk:=exec('has_dok4mask_a','zl_common');
   _args_hasdk.ZL:=ZL.ref();
   _args_hasdk.RW:=1;
   _args_hasdk.ZW:=1;
   _args_hasdk.RP:=1;
   _args_hasdk.ZP:=1;
   {? exec('has_dokumenty','zl_common',_args_hasdk)
   || {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
      KOMM.add('Zlecenie powiązane z dokumentami magazynowymi, usunięcie nie jest możliwe.'@,2,,1);
      KOMM.sect_end();
      _result:=0
   ?};

:: 11. Sprawdzenie, czy są zlecenia powołane do zamówień limitowych
   {? _can_continue>0
   || {? exec('chk_zl4zlim','zl_gen',ZL.ref())>0
      ||
         {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
         KOMM.add('Zlecenie posiada zlecenia powiązane z zamówieniami limitowymi, usunięcie nie jest możliwe.'@,2,,1);
         KOMM.sect_end();
         _result:=0
      ?}
   ?};

:: Sprawdziłem siebie teraz rekurencyjnie sprawdzam wszystkie swoje podzlecenia
   ZL.cntx_psh();
   ZL.index('ZLTREE');
   ZL.prefix(ZL.TYP,ZL.NODE,ZL.ref());
   {? ZL.first()
   || {!
      |?
         _result_rec:=exec('zl_usun_chk','zl_head',,_grupa,0);
         {? _result_rec=0
         || _result:=0
         ?};
         ZL.next()
      !}
   ?};
   ZL.cntx_pop();

   exec('zl_unlockfamily','zl_common',_locktab,'N');
   exec('zl_unlockfamily','zl_common',_locktab,'T');
   exec('zl_unlockfamily','zl_common',_locktab,'I');
   exec('zl_unlock','zl_common',ZL.ref(),'N');
   exec('zl_unlock','zl_common',ZL.ref(),'T');
   exec('zl_unlock','zl_common',ZL.ref(),'I');
   ~~
?};
ZL.cntx_pop();
_result


\zl_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Usuwanie całego zlecenia
::   WE: _a - ZL.ref()
::       [_b] - INTEGER - [0]/1 - czy wykonywanie w akcji dla grupy rekordów - wtedy komunikaty do KOMM
::                                (domyślnie dla pojedynczego rekordu),
::                                nie uwzględniane są też specjalne uprawnienia do usuwania zatwierdzonych zleceń
::       [_c] - INTEGER - 0/[1] - czy włączone dialogi (domyślnie 1)
::       [_d] - INTEGER - 0/[1] - czy wykonywać sprawdzanie czy można usunąć
::   WY: 0 / 1
::  OLD: \zl_usun/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_grupa:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_dialog:={? var_pres('_c')=type_of(0) || _c || 1 ?};

_chk:=1;
{? var_pres('_d')=type_of(0)
|| _chk:=_d
?};

_res:=0;
_can_continue:=1;

ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
|| _askDel:=1;
   _locked:=0;
   _locked_family:=0;
   _dalej:=1;
   VAR.A_ZLEC:=ZL.ref();
   {? ~_grupa || KOMM.init(150,,'Usuwanie zlecenia'@,'') ?};
   _podzlec:=exec('is_podzlec','zl_link');
   _nadzlec_sym:='';
   _nadzlec_ref:=null();
   _ktm:=ZL.KTM;

   {? _podzlec>0
   || ZL.cntx_psh();
      ZL.clear();
      {? ZL.seek(ZL.TREE,)
      || _nadzlec_sym:=ZL.SYM;
         _nadzlec_ref:=ZL.ref()
      ?};
      ZL.cntx_pop();
      ~~
   ?};
   _delete_polf:=0;
   _delete_head:=0;
   _px_tex:=exec('get_tex_zl','px_tex',ZL.ref());
   _lock_res:=~~;
:: Pytania
   {? _chk>0
   || _can_continue:=exec('zl_lock','zl_common',,'N',_grupa) &
                     exec('zl_lock','zl_common',,'T',_grupa) &
                     exec('zl_lock','zl_common',,'I',_grupa);
      {? _can_continue>0 & _px_tex<>null()
      || _lock_res:=exec('lock','px_tex',_px_tex,_grupa);
         _can_continue:=_lock_res.LOCKED
      ?};
      {? _can_continue>0
      || _locked:=1
      ?}
   ?};
   {? _can_continue>0
   || _top_rodzaj:=exec('top_rodzaj','zl_link',ZL.ref());
      {? ZL.STAN<>'N' & ZL.RODZAJ<>'N' & _top_rodzaj<>'N'
      || {? exec('uprDelZatwZl','zl_head')
         || {? _dialog>0 & _grupa=0
            || {? _podzlec>0
               || _msg:='Zlecenie: %1 jest uruchomione. Czy mimo to chcesz usunąć to zlecenie?'@[ZL.SYM]
               || _msg:='Zlecenie: %1 jest uruchomione. Czy mimo to chcesz usunąć to zlecenie wraz z powiązanymi zadaniami?'@[ZL.SYM]
               ?};
               {? _podzlec>0
               ||
                  {? var_pres('_res_multi')>100
                  || obj_del(_res_multi)
                  ?};
                  _option1:='text=';
                  _option1+='Usuwać także półfabrykat z technologii zlecenia nadrzędnego: %1'@[_nadzlec_sym];
                  _option1+=';selected=N';

                  _option2:='text=';
                  _option2+='Usuwać także zadania powiązane ze zleceniem'@;
                  _option2+=';selected=N';

                  _option3:='';
                  {? _zl=exec('main_podzlec','zl_link',ZL.ref())
                  || _option3:='text=';
                     _option3+='W przypadku usunięcia podzlecenia montażowego usunąć także zlecenie nadrzędne: %1'@[_nadzlec_sym];
                     _option3+=';selected=N'
                  ?};

                  {? _option3=''
                  || _res_multi:=FUN.multichoice(_msg,,,100,,_option1,_option2)
                  || _res_multi:=FUN.multichoice(_msg,,,100,,_option1,_option2,_option3)
                  ?};
                  {? +_res_multi[1]>0
                  || _can_continue:=1
                  || _can_continue:=0
                  ?};
                  {? +_res_multi[2]>0
                  || _delete_polf:=1
                  ?};
                  {? +_res_multi[3]>0
                  || _choice:=2
                  || _choice:=1
                  ?};
                  {? _option3<>'' & +_res_multi[4]>0
                  || _delete_head:=1
                  ?};
::                Sprawdzam czy są uprawnienia do usunięcia półfabrykatu, jeżeli nie, to nic nie usuwam
                  {? _delete_polf>0 & exec('uprDelSurZatwZl','tech_mater')=0
                  || _can_continue:=0;
                     FUN.emsg('Brak uprawnień do usuwania surowców zleceń z zatwierdzoną technologią.'
                              '\n\nParametr użytkownika nr 8903.'@)
                  ?}
               || _can_continue:=_choice:=FUN.choice(_msg,,'Usuń tylko &zlecenie'@,'Usuń wraz z zadaniami'@)
               ?};
               _askDel:=0
            ?}
         || _can_continue:=0
         ?}
      ?}
   ?};
   _zloz:=1;
   {? ZL.NRNZL=0 & ZL.RODZAJ<>'P'
   || {? exec('sprawdz_podzlecenia','zl_link',ZL.ref())
      || _zloz:=1
      || _zloz:=2
      ?}
   ?};

   {? _can_continue>0 & _zloz=1
   || ZL.cntx_psh();
      ZL.index('UNRZL');
      ZL.prefix(ZL.NRNZL);
      {? ZL.first()
      || {? ZL.STAT_T='T' & ZL.RODZAJ<>'N'
         || {? exec('uprDelZatwZl','zl_head')
            || {? _dialog>0 & _grupa=0 & _askDel>0
               || _askDel:=0;
                  {? _podzlec>0
                  || _msg:='Zlecenie nadrzędne: %1 posiada zatwierdzenia. Czy mimo to chcesz usunąć to zlecenie?'@[ZL.SYM]
                  || _msg:='Zlecenie nadrzędne: %1 posiada zatwierdzenia. Czy mimo to chcesz usunąć to zlecenie wraz z powiązanymi zadaniami?'@[ZL.SYM]
                  ?};
                  {? _podzlec>0
                  ||
                     {? var_pres('_res_multi')>100
                     || obj_del(_res_multi)
                     ?};
                     _option1:='text=';
                     _option1+='Usuwać także półfabrykat z technologii zlecenia nadrzędnego: %1'@[_nadzlec_sym];
                     _option1+=';selected=N';

                     _option2:='text=';
                     _option2+='Usuwać także zadania powiązane ze zleceniem'@;
                     _option2+=';selected=N';

                     _option3:='';
                     {? _zl=exec('main_podzlec','zl_link',ZL.ref())
                     || _option3:='text=';
                        _option3+='W przypadku usunięcia podzlecenia montażowego usunąć także zlecenie nadrzędne: %1'@[_nadzlec_sym];
                        _option3+=';selected=N'
                     ?};
                     {? _option3=''
                     || _res_multi:=FUN.multichoice(_msg,,,100,,_option1,_option2)
                     || _res_multi:=FUN.multichoice(_msg,,,100,,_option1,_option2,_option3)
                     ?};
                     {? +_res_multi[1]>0
                     || _can_continue:=1
                     || _can_continue:=0
                     ?};
                     {? +_res_multi[2]>0
                     || _delete_polf:=1
                     ?};
                     {? +_res_multi[3]>0
                     || _choice:=2
                     || _choice:=1
                     ?};
                     {? _option3<>'' & +_res_multi[4]>0
                     || _delete_head:=1
                     ?};

::                   Sprawdzam czy są uprawnienia do usunięcia półfabrykatu, jeżeli nie, to nic nie usuwam
                     {? _delete_polf>0 & exec('uprDelSurZatwZl','tech_mater')=0
                     || _can_continue:=0;
                        FUN.emsg('Brak uprawnień do usuwania surowców zleceń z zatwierdzoną technologią.'
                                 '\n\nParametr użytkownika nr 8903.'@)
                     ?}
                  || _can_continue:=_choice:=FUN.choice(_msg,,'Usuń tylko &zlecenie'@,'Usuń wraz z zadaniami'@)
                  ?}
               ?}
            || _can_continue:=0;
               {? _dialog>0
               || FUN.emsg('Brak uprawnień do usuwania zatwierdzonych zleceń.'
                                 '\n\nParametr użytkownika nr 8902.'@)
               ?}
            ?}
         ?}
      ?};
      ZL.cntx_pop()
   ?};

   {? _can_continue>0 & _askDel>0
   || _choice:=1;
      {? _grupa | ~_dialog | (_choice:=FUN.choice('Czy na pewno usunąć zlecenie: %1 oraz powiązane z nim zadania?'@[ZL.SYM]
                                                  ,,'Usuń tylko &zlecenie'@,'Usuń wraz z zadaniami'@))
      || _can_continue:=1
      || _can_continue:=0
      ?}
   ?};

:: Sprawdzenie czy można usunąć zlecenie wraz z całą rodziną poniżej
   {? _can_continue>0 & _chk>0
   || _can_continue:=exec('zl_usun_chk','zl_head',,_grupa,_dialog)
   ?};

   _locktab:=exec('zl_lock_tab','zl_common');
   {? _can_continue>0
   ||
::    Czy urucamiać cleanera dla zlecenia
      {? ~_grupa
      || {? _choice=2
         || ZLEC.CLEANER:='T'
         || ZLEC.CLEANER:='N'
         ?}
      ?};

::    Blokowanie
      {? _chk>0
      ||
         _can_continue:=exec('zl_lock','zl_common',,'N',1) & exec('zl_lock','zl_common',,'T',1);
         {? _can_continue>0
         || _locked:=1
         ?}
      ?};
      {? _can_continue>0
      ||
::       Blokowanie całej rodziny
         {? _chk>0
         || _locked1:=exec('zl_lockfamily','zl_common',,'N',0,_locktab);
            _locked2:=exec('zl_lockfamily','zl_common',,'T',0,_locktab);
            {? _locked1.LOCKED>0 & _locked2.LOCKED>0
            || _locked_family:=1
            ?}
         ?};

         {? _can_continue>0
         ||
            _mydo:=do_state()=0;
            {? _mydo
            || do();
::             Utworzenie tablicy zawierającego refy zleceń dla których będzie uruchomiony cleaner
               {? var_press('__zl_cleantab')>100 || obj_del(__zl_cleantab) ?};
               __zl_cleantab:=tab_tmp(,'UID','STRING[100]','ZL.uidref()')
            ?};

            _result_rec:=1;
::          Najpierw usuwam wszystko rekurencyjnie od samego dołu
            ZL.cntx_psh();
            ZL.index('ZLTREE');
            ZL.prefix(ZL.TYP,ZL.NODE,ZL.ref());
            {? ZL.first()
            || {!
               |?
::                !!! REKURENCJA !!!
                  _can_continue:=exec('zl_usun','zl_head',ZL.ref(),1,0,0);
                  ZL.next() & _can_continue>0
               !}
            ?};
            ZL.cntx_pop();
::          Uidref usuwanego zlecenia
            _uid:=ZL.uidref();
::          Jak pousuwałem wszystko poniżej to kasuję siebie
            {? _can_continue>0
            ||
               VAR.A_ZLEC:=ZL.ref();
               exec('openmask','zl_common',VAR.A_ZLEC);
               _can_continue:=exec('usuzatw','zl_common');

::             Usunięcie powiązań w pozycjach koszyku planu dostaw
               exec('del_lnk_zl','plan_dostaw',VAR.A_ZLEC);

::             Usunięcie zlecenia
               {? _can_continue>0
               || _can_continue:=exec('zl_del','zl_head',ZL.ref())
               ?}
            ?};
            {? _can_continue<=0
            || undo();
              {? var_press('__zl_cleantab')>100 || obj_del(__zl_cleantab);&__zl_cleantab ?}
            ?};

            {? _mydo || end() ?};

            {? _can_continue>0
            ||
::             Jeżeli usunąłem zlecenie to usuwam półfabrykat z technologii lub zmieniam rezerwacje dedykowane
               exec('delTmatZl','tech_mater',_nadzlec_ref,_ktm,0,1,~(_delete_polf>0))
            ?};

            {? _can_continue>0 & ZLEC.CLEANER='T'
            ||
::             Jeżeli usunąłem zlecenie to dodaje zlecenie do tabeli cleanera
               {? ~__zl_cleantab.find_key(_uid)
               || __zl_cleantab.UID:=_uid;
                  __zl_cleantab.add()
               ?}
            ?};

            {? _can_continue>0 & _nadzlec_ref<>null()
            ||
::             Jeżeli usunąłem podzlecenie to aktualizuje znacznik modyfikacji nadzlecenia
::             oraz dopisuje mu do dziennika info
               ZL.cntx_psh();
               ZL.prefix();
               {? ZL.seek(_nadzlec_ref)
               || {? ZL.STAT_T='T'
                  || ZL.MOD:='T';
                     ZL.put();
                     exec('add_zwar_pos','zl_common','m2',0,'Usunięto podzlecenie.',ZL.ref())
                  ?}
               ?};
               ZL.cntx_pop()
            ?};
            {? _can_continue & _delete_head>0
            ||
::             Jeżeli użytkownik wybrał również usunięcie nadzlecenia to je usuwam
               _nadzlec_uid:=exec('FindAndGet','#table',ZL,_nadzlec_ref,,"ZL.uidref()",'');
               _can_continue:=exec('zl_del','zl_head',_nadzlec_ref);
               {? _can_continue>0 & ZLEC.CLEANER='T'
               ||
::                 Jeżeli usunąłem zlecenie to dodaje zlecenie do tabeli cleanera
                  {? ~__zl_cleantab.find_key(_nadzlec_uid)
                  || __zl_cleantab.UID:=_nadzlec_uid;
                     __zl_cleantab.add()
                  ?}
               ?}
            ?}
         ?}
      ?}
   ?};
   exec('zl_unlockfamily','zl_common',_locktab,'N');
   exec('zl_unlockfamily','zl_common',_locktab,'T');
   exec('zl_unlockfamily','zl_common',_locktab,'I');
   exec('zl_unlock','zl_common',_zl,'N');
   exec('zl_unlock','zl_common',_zl,'T');
   exec('zl_unlock','zl_common',_zl,'I');
   {? _px_tex<>null()
   || exec('unlock','px_tex',_lock_res)
   ?};
   {? ~_grupa || KOMM.select() ?}
?};
ZL.cntx_pop();
{? _can_continue>0
|| _res:=1;
:: Uruchamian cleanera dla wybranych rekordów (po transakcji)
   {? _mydo & ZLEC.CLEANER='T'
   || _tab:=__zl_cleantab;
      {? _tab.first()
      || {!
         |?
            exec('clean_record','#b__box',_tab.UID,0);
            _tab.next()
         !}
      ?};
      {? var_press('__zl_cleantab')>100 || obj_del(__zl_cleantab);&__zl_cleantab ?}
   ?}
|| {? var_press('__zl_cleantab')>100 || obj_del(__zl_cleantab);&__zl_cleantab ?}
?};
_res


\zl_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Usunięcie zlecenia oraz elementów powiązanych
::   WE: _a - ZL.ref()
::   WY: 0 / 1
::  OLD: \zl_del/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
||
:: usuwanie limitów
   _can_continue:=exec('usunlim','zl_limit',ZL.ref());

:: usuwanie przewodników
   {? _can_continue>0
   ||
      ZGH.index('ZLNR');
      ZGP.index('NRPP');
      ZGH.clear();
      ZGH.prefix(ZL.ref());
      {? ZGH.first()
      || {!
         |? ZGP.clear();
            ZGP.prefix(ZGH.ref());
            {? ZGP.first()
            || {!
               |? _can_continue:=ZGP.del(,1);
                  ZGP.first() & _can_continue>0
               !}
            ?};

            {? _can_continue>0
            || _can_continue:=ZGH.del(,1)
            ?};
            ZGH.first() & _can_continue>0
         !}
      ?}
   ?};

:: usuwanie karty technologicznej zlecenia
   {? _can_continue>0 & ZL.TKTL<>null()
   || _can_continue:=exec('usun_tktl','zl_tech','no ask','ext_del')
   ?};

   {? _can_continue>0
   ||
::    usuwanie atrybutów zlecenia
      ATR.TACR:='ZL';
      ATR.TREF:=#ZL.ref();
      ATR.TMSK:=ref_name(ZL.ref());

      UAT.clear();
      UAT.index('TR');
      UAT.prefix(ATR.TACR+'*',ATR.TREF,ATR.TMSK+'*',);
      {? UAT.first()
      || {!
         |? _can_continue:=UAT.del(,1);
            UAT.first() & _can_continue>0
         !}
      ?}
   ?};
   {? _can_continue>0
   ||
::    usuwanie dokumentów przypisanych do zlecenia
      DocLib.del('ZL',ZL.ref())
   ?};

   {? _can_continue>0
   ||
::    usuwanie dziennika zlecenia
      ZWAR.clear();
      ZWAR.index('ZDG');
      ZWAR.prefix(ZL.ref());
      {? ZWAR.first()
      || {!
         |? _can_continue:=ZWAR.del(,1);
            ZWAR.first() & _can_continue>0
         !}
      ?}
   ?};

   {? _can_continue>0
   ||
::    usuwanie kalkulacji i analiz
      ANZH.clear();
      ANZH.index('ZN');
      {! _i:=0..1
      |! ANZH.prefix($_i,ZL.ref());
         {? ANZH.first()
         || {!
            |? _can_continue:=exec('anzh_del','zl_kalk',ANZH.ref());
               {? _can_continue>0 || _can_continue:=ANZH.del(,1) ?};
               ANZH.first() & _can_continue>0
            !}
         ?}
      !}
   ?};

   {? _can_continue>0
   ||
::    usuwanie powiązań z obiektami w kolejce
      PX_ZL.cntx_psh();
      PX_ZL.index('ZL');
      PX_ZL.prefix(ZL.ref());
      {? PX_ZL.first()
      || {!
         |? _can_continue:=exec('delete','px_zl',PX_ZL.ref());
            PX_ZL.first() & _can_continue>0
         !}
      ?};
      PX_ZL.cntx_pop()
   ?};

   {? _can_continue>0
   ||
::    usuwanie ZLZAM
      {? var_pres('__matakt')<0
      || _matakt:=tab_tmp(2,
            'REF','STRING[16]',''
           ,'NRK','INTEGER',''
           ,'ILR','REAL',''
           ,'ZKP','STRING[16]',''
           ,'ZKN','STRING[16]',''
         );
         _aktrezy:=1
      || _aktrezy:=0
      ?};
      ZLZAM.index('ZLZM');
      ZLZAM.prefix(ZL.ref());
      {? ZLZAM.first()
      || {!
         |? {? ZLZAM.SRC='Z' & _can_continue>0
            || exec('zlzam2Rez','zamsiw_wspolne',ZLZAM.ZAMPOZ,-1,0,,,~_aktrezy);
               exec('admatzkp','rezerwacje',
                  $ZL.KTM,
                  0,
                  ZLZAM.ILZL,
                  exec('FindAndGet','#table',ZK_P,ZLZAM.ZAMPOZ,,"$N",''),
                  ZLZAM.ZAMPOZ,
                  {? _aktrezy || _matakt || __matakt ?}
               )
            |? ZLZAM.SRC='S' & _can_continue>0
            || exec('FindAndGet','#table',PSP,ZLZAM.ZAMPOZ,,"PSP.ILZL-=ZLZAM.ILZL;PSP.put()",~~)
            ?};
            _can_continue:=ZLZAM.del(,1);
            ZLZAM.first() & _can_continue>0
         !}
      ?};
      {? _aktrezy || exec('akt_rezy','rezerwacje',_matakt) ?}
   ?};

   {? _can_continue>0
   ||
::    usuwanie PX_OBJ i powiązanych
      _can_continue:=exec('zl_delete','px_plan',ZL.ref())
   ?};

   {? _can_continue>0
   ||
::    usuwanie partii zlecenia
      _can_continue:=exec('zl_delete','zl_partie',ZL.ref())
   ?};

   {? _can_continue>0 & exec('zl_czy_wyr','zl_wyr',ZL.ref())
   ||
::    usuwanie produktów zlecenia
      _can_continue:=exec('del4ZL','zl_wyr',ZL.ref())
   ?};

   {? _can_continue>0
   ||
::    usuwanie powiązanych ze zleceniem rezerwacji
      _can_continue:=exec('zl_delete_rez','zl_common',ZL.ref())
   ?};

   {? _can_continue>0
   ||
::    uwolnienie numeracji
      POM.TAB:='ZL';
      exec('add_grnr','numery','ZLC');
      exec('add_grnr','numery','ZLP');
      {? ZL.NRNZL<>0 || POM.TYPDOK:=ZL.TYP().KOD_ZLP || POM.TYPDOK:=ZL.TYP().KOD_ZLC ?};
      numer:=ZL.NR;
      oldnumer:=1;
      exec('nr_old','numery');

      exec('zl_unlock','zl_common',,'N');
      _can_continue:=ZL.del(,1);
      VAR.A_ZLEC:=null()
   ?}
?};
ZL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\zl_kopiuj
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Kopiowanie zlecenia
::   WE: _a - ZL.ref()
::  OLD: \zlkopiuj/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_zl_new:=null();

{? ~exec('sprdt','zl_head') || return(null()) ?};

ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
||
:: Sprawdzam czy zlecenie bez własnej technologii i któreś z podzleceń używa
:: archiwalnej karty technologicznej - w takim przypadku kopiowanie niemożliwe
   _can_continue:=1;
   {? ZL.TYP().TECH='N' & exec('subzlec_exist','zl_link',ZL.ref())>0
   || {? exec('check_tktl_arch','zl_link',ZL.ref())=1
      || _can_continue:=0;
         _msg:='Jedno z podzleceń zlecenia: %1 używa archiwalnej technologii.\n'
               'Kopiowanie zabronione.'@[ZL.SYM];
         FUN.emsg(_msg)
      ?}
   ?};

   {? _can_continue>0 & FUN.ask('Czy utworzyć nowe zlecenie na podstawie zlecenia %1?'@[ZL.SYM])
   || KOMM.init(150,,'Kopiowanie zlecenia'@,'');
      _zl_new:=exec('kopiuj','zl_head',ZL.ref());
      KOMM.select()
   ?}
?};
ZL.cntx_pop();
{? _zl_new
|| exec('findadzl','zl_head',_zl_new);
   {? ZL.f_active()>0 || ZL.f_rfresh() ?}
?};
_zl_new


\kopiuj
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Kopiowanie zlecenia
::   WE: _a - ZL.ref()
::       [_b] - nadawać wartości początkowe dla wybranych pól i tworzyć rekord ZLZAM?
::       [_c] - bufor tabeli ZL z wartościami, którymi zastąpić wygenerowane wartości
::   WY: ZL.ref() nowego zlecenia albo null(), gdy nie udane
::  OLD: \kopiuj/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
{? var_pres('_b')=type_of(0) || _blank:=_b || _blank:=1 ?};
{? var_pres('_c')>100 || _buffer_in:=_c || _buffer_in:=exec('buffer','zl_head'); _buffer_in.bl_void() ?};

_zl_new:=null();

ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
||
:: Dane źródłowego zlecenia:
   _sym:=ZL.SYM;
   _rodzaj:=ZL.RODZAJ;
   _wp:=ZL.TYP().WP;
   _aut:=ZL.AUTGENZL;
   _tktl:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,"ref()",null());

:: POCZĄTEK TRANSAKCJI
   do();

   ZL.prefix();
   ZL.AR:=ST.AR;
:: Nowe zlecenie nie jest nigdy podzleceniem
   ZL.NRNZL:=0;

   {? _blank || ZL.OPIS:='Kopia: '+_sym ?};
   {? _blank || ZL.OD:=date() ?};
   ZL.DO:=date(0,0,0);
   ZL.STAN:='N';
   ZL.TKTL:=null();
   ZL.RTKTL:='';
   ZL.POWOL:=OPERATOR.USER;
   ZL.DZATW:=date(0,0,0);
   ZL.ZATW:=null();
   ZL.CLOSED:=null();
   ZL.HIDDEN:='T';
   ZL.ZMASK:=20*'1';
   {? _blank || ZL.DTR:=date()+exec('get','#params',500103,1) ?};
   ZL.MASKA:='____';
   ZL.ILWYK:=0;
   ZL.ILWYK_D:=0;
   ZL.ILDOK:=0;
   ZL.HWYK:=0;
   ZL.STARTD:=ZL.ENDD:=date(0,0,0);
   ZL.STARTT:=ZL.ENDT:=time(0,0,0);
   {? _blank || ZL.PL_DATA:=ZL.DTR ?};
   {? _blank || ZL.PL_TIME:=time(0,0,0) ?};
   ZL.TREE:=0;
   ZL.NSTAN:=ZL.STAN+'_';
   ZL.SCEAN:=exec('blzl_sce','kody_kresk');
   ZL.ZLEAN:=exec('blzl2sce','kody_kresk');
   ZL.ID_KSG:=exec('zl_idksg_bl','zl_head');
   ZL.STAT_N:=ZL.STAT_T:='N';
   ZL.IDSRC:=ZL.IDADD;
   ZL.PLAN_PO:='N';
   ZL.PLAN_PX:='N';
   ZL.TREE_TYP:=ZL.RODZAJ;
   ZL.PRIORITY:=0;
   {? ZL.TREE || ZL.NODE:=exec('node','zl_head') ?};
   exec('ust_znac','zl_head');
   ZL.SYM:='~'+$ZL.tm_stamp();
   ZL.memo_get(,'OPIS_DOD',0);
   _buffer:=exec('buffer','zl_head');
   _buffer.get();

   _buffer_tmp:=exec('buffer','zl_head');
   _buffer_tmp.get();
   _buffer_in.mask(_buffer_tmp);
   _buffer_tmp.setf();

   {? ZL.add()
   || POM.TAB:='ZL';
      exec('add_grnr','numery','ZLC');
      exec('add_grnr','numery','ZLP');
      POM.TYPDOK:={? ZL.NRNZL=0 || ZL.TYP().KOD_ZLC || ZL.TYP().KOD_ZLP ?};
      ZL.NR:=0;
      ZL.NR:=exec('numer_new','numery','PACZKA');
      exec('znak','numery','ZL',1);
      ZL.memo_put(,'OPIS_DOD');
      {? ZL.TREE=0 || ZL.NODE:=exec('node','zl_head'); ZL.put() ?};
      {? ZL.SCEAN<>'' & ZL.KTM().IDMOB='Z' || exec('mkodkadd','kody_kresk',ZL.KTM,ZL.SCEAN,$ZL.ref()) ?};
::    tutaj replika nagłówka zlecenia z drobnymi modyfikacjami
      _zl_new:=ZL.ref();
      {? _blank || exec('add_zleczam','zl_gen',ZL.ref(),ZL.IL) ?};
      VAR.A_ZLEC:=ZL.ref();
      _ok:=exec('add_zwar_pos','zl_common','_n',0);
      {? _ok
      || UAT.cntx_psh();
         UAT.index('TR');
         UAT.prefix('ZL'+'*',#_zl,ref_name(_zl)+'*',);
         {? UAT.first()
         || _uat:=FUN.ask('Czy kopiować atrybuty zlecenia?'@)
         || _uat:=0
         ?};
         UAT.cntx_pop();
         {? _uat
         || _ok:=exec('uat_copy','tech_arch',,'ZL',_zl,ZL.ref())
         ?}
      ?};
      {? _ok
      || _ok:=DocLib.copy('ZL',_zl,'ZL',ZL.ref())
      ?};

:: TODO: kopiowanie pozostałych elementów wyłączone - powinno być obsłużone w procesie
::      {? _ok
::      ||
::::       Zlecenie produkcyjne proste = kopiowanie karty technologicznej
::         {? _rodzaj='P' & _wp='P'
::         || {? _tktl<>null()
::            || _args:=exec('args_copy','tech_arch');
::               _args.DIR:='KARTOTEKA';
::               _args.MASK_SRC:=(8+ref_name(_tktl))+3;
::               _args.TKTL_SRC:=_tktl;
::               _args.DST_TMASK:=exec('samejedynki','#blank');
::               _args.DST_TORW:='Z';
::               _args.DST_STAN:='N';
::               _args.DST_ZL:=ZL.ref();
::               _args.DST_ZLNAD:=exec('get_nadzlec','zl_link',ZL.ref());
::               _args.DST_SYM:=ZL.SYM;
::               _args.DST_WER:=exec('tktl_wer_bl','tech_head');
::               _args.TPAR_ASK:=0;
::               _args.M_ONLY:=ZL.KTM;
::               _args.M_VALS:=ZL.KTM;
::               _args.FILL_SRC:=1;
::               {? exec('tktl_copy','tech_arch',_args)
::               || ZL.TKTL:=_args.TKTL_DST;
::                  _ok:=ZL.put()
::               || _ok:=0
::               ?};
::               obj_del(_args)
::            ?}
::
::::       Zlecenie produkcyjne złożone = kopiowanie struktury podzleceń
::         |? _wp='P' & ((_rodzaj='Z' & _aut='T') | _rodzaj='N')
::         || _ok:=exec('zktlnew','zl_head',ZL.ref(),_zl,1,ZL.UNRZL)
::
::::       Zlecenie warsztatowe = kopiowanie przewodników i limitów
::         |? _wp='W'
::         || _ok:=exec('cp_zlec','zl_common',ZL.ref(),_zl)
::
::         ?}
::      || undo()
::      ?};
      {? ~_ok
      || undo()
      ?}
   || undo()
   ?};

:: KONIEC TRANSAKCJI
   {? end()
   ||
      _msg:=
         'Na podstawie zlecenia '+_sym+' zostało wygenerowane zlecenie o symbolu: '+
          ZL.SYM+{? ZL.KTM<>null() || ' dla produktu: '+ZL.KTM().KTM || '' ?};
      {? ZL.TYP().WP<>'W' & ZL.RODZAJ<>'N' & ZL.KTL=null() & ZL.SRCTECH='T'
      || KOMM.sect_beg(_msg,'xwin16.png:38');
         KOMM.add('Zlecenie powołane na podstawie archiwalnej technologii'@,'xwin16.png:3');
         KOMM.sect_end()
      || KOMM.add(_msg,'xwin16.png:38')
      ?};
      {? ~exec('ctrl_zl','zl_view',ZL.ref())
      || KOMM.add(' Uwaga. W celu podglądu zlecenia należy zmienić aktualny zakres zleceń.'@,3)
      ?};
      exec('zl2obj','px_obj')
   ||
      KOMM.add(
         'Nie udało się utworzyć zlecenia na podstawie '+
          _sym +{? ZL.KTM<>null() || ' dla produktu: '+ZL.KTM().KTM || '' ?},
          'xwin16.png:81'
       )
   ?}
?};
ZL.cntx_pop();
_zl_new


\zktlnew
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Kopiowanie zlecenia złożonego
::   WE: _a: ZL.ref() - nowe
::       _b: ZL.ref() - źródłowe
::       _c: 0-kolejne uruchomienie, 1-pierwsze uruchomienie
::       _d: zlecenie nadrzedne
::   WY: 1 (zawsze udane?)
::  OLD: \zktlnew/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_tree:=#_a;
_nrn:=_d;
{? _c
|| __UNRGR:=tab_tmp(1,'UNROLD','INTEGER','UNROLD',
                      'UNRNEW','INTEGER','UNRNEW')
?};
ZL.cntx_psh();
ZL.prefix();
ZL.seek(_b);
ZL.index('ZLTREE');
ZL.prefix(ZL.TYP,ZL.NODE,ZL.ref());
{? ZL.first()
|| {!
   |? exec('podzl_kop','zl_head',ZL.ref(),_nrn,_tree);
      ZL.next()
   !}
?};
ZL.cntx_pop();
{? _c || obj_del(__UNRGR) ?};
1


\podzl_kop
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: kopiowanie podzlecenia na nowe, kopiowany jest nagłówek oraz karta technologiczna zlecenia
::   WE: _a - ZL.ref() - źródłowe zlecenie
::       _b - ZL.UNRZL - numer zlecenia nadrzędnego, do którego podpiąć nowe zlecenie
::       _c - tree - #ZL.ref() zlecenia nadrzędnego, do którego podpiąć nowe zlecenie
::  OLD: \podzl_kop/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_nrnzl:=_b;
_tree:=_c;

ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
||
   _unrzl:=ZL.UNRZL;
   _tktl:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,"ref()",null());

   ZL.NRNZL:=_nrnzl;

   POM.TAB:='ZL';
   exec('add_grnr','numery','ZLC');
   exec('add_grnr','numery','ZLP');
   POM.TYPDOK:={? ZL.NRNZL=0 || ZL.TYP().KOD_ZLC || ZL.TYP().KOD_ZLP ?};
   ZL.NR:=0;
   ZL.NR:=exec('numer_new','numery','PACZKA');
   exec('znak','numery','ZL',0);

   ZL.OPIS:='Kopia: '+ZL.OPIS;
   ZL.OD:=date();
   ZL.DO:=date(0,0,0);
   ZL.STAN:='N';
   ZL.TKTL:=null();
   ZL.RTKTL:='';
   ZL.JORG:=ST.A_WYD;
   ZL.POWOL:=OPERATOR.USER;
   ZL.DZATW:=date(0,0,0);
   ZL.ZATW:=null();
   ZL.CLOSED:=null();
   ZL.HIDDEN:='T';
   ZL.ZMASK:=20*'1';
   ZL.DTR:=date(0,0,0);
   ZL.MASKA:='____';
   ZL.ILWYK:=0;
   ZL.ILWYK_D:=0;
   ZL.TREE:=_tree;
   ZL.NSTAN:=ZL.STAN+'_';
:: UWAGA: nie czuje, co ten kawalek robi:
   {? ZL.NRPZL<>0
   || __UNRGR.prefix(ZL.NRPZL);
      {? __UNRGR.first()
      || _ok:=__UNRGR.UNRNEW
      || _ok:=0
      ?};
      ZL.NRPZL:=_ok
   ?};
   ZL.SCEAN:=exec('blzl_sce','kody_kresk');
   ZL.ZLEAN:=exec('blzl2sce','kody_kresk');
   ZL.STAT_N:=ZL.STAT_T:='N';
   {? ZL.TREE || ZL.NODE:=exec('node','zl_head') ?};
   exec('ust_znac','zl_head');
:: ----------------------------------------
   _zl_new:=null();
   {? ZL.add()
   || _zl_new:=ZL.ref();
      {? ZL.TREE=0 || ZL.NODE:=exec('node','zl_head'); ZL.put() ?};
      {? ZL.SCEAN<>'' & ZL.KTM().IDMOB='Z' || exec('mkodkadd','kody_kresk',ZL.KTM,ZL.SCEAN,$ZL.ref()) ?};
      __UNRGR.clear();
      __UNRGR.UNRNEW:=ZL.UNRZL;
      __UNRGR.UNROLD:=_unrzl;
      __UNRGR.add();
      exec('add_zleczam','zl_gen',ZL.ref(),ZL.IL);
      VAR.A_ZLEC:=ZL.ref();
      _ok:=exec('add_zwar_pos','zl_common','_n',0);
      {? _ok
      || UAT.cntx_psh();
         UAT.index('TR');
         UAT.prefix('ZL'+'*',#_zl,ref_name(_zl)+'*',);
         {? UAT.first()
         || _uat:=FUN.ask('Czy kopiować atrybuty zlecenia %1 ?'@[ZL.SYM])
         || _uat:=0
         ?};
         UAT.cntx_pop();
         {? _uat
         || _ok:=exec('uat_copy','tech_arch',,'ZL',_zl,ZL.ref())
         ?}
      ?};
      {? _ok
      || {? _tktl<>null()
         || _args:=exec('args_copy','tech_arch');
            _args.MASK_SRC:=(8+ref_name(_tktl))+3;
            _args.TKTL_SRC:=_tktl;
            _args.DST_TMASK:=exec('samejedynki','#blank');
            _args.DST_TORW:='Z';
            _args.DST_STAN:='N';
            _args.DST_ZL:=ZL.ref();
            _args.DST_ZLNAD:=exec('get_nadzlec','zl_link',ZL.ref());
            _args.DST_SYM:=ZL.SYM;
            _args.DST_WER:=exec('tktl_wer_bl','tech_head');
            _args.TPAR_ASK:=0;
            _args.M_ONLY:=ZL.KTM;
            _args.M_VALS:=ZL.KTM;
            _args.FILL_SRC:=1;
            {? exec('tktl_copy','tech_arch',_args)
            || ZL.TKTL:=_args.TKTL_DST;
               ZL.put()
            ?}
         ?};
         {? ZL.RKTL<>'' & ZL.SRCTECH='T'
         || _arch:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,"ARCH",'N');
            {? _arch='T'
            || KOMM.add('Podzlecenie: %1 powołano na podstawie archiwalnej technologii.'@[ZL.SYM],'xwin16.png:3')
            ?}
         ?}
      ?};
      exec('zktlnew','zl_head',_zl_new,_zl,0,ZL.NRNZL)
   ?}
?};
ZL.cntx_pop();
~~


\zlhead_chk
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: sprawdza czy można zrobić cokolwiek z nagłówkiem zlecenia
::  OLD: \zlhead_chk/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('zl_lock','zl_common',,'N')
|| exec('zl_unlock','zl_common',,'N');
   1
|| 0
?}


\ustaw_pola
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.60]
:: OPIS: Ustawienie wartości pól w oknie redakcyjnym zleceń
::  OLD: \ustaw_pola/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
exec('procent','zl_head');

ANZH.index('ZRO1'); ANZP.index('NRARUB');
ANZH.prefix('0',ZL.ref(),0,0,'T');
{? ANZH.last()
|| VAR1.ANZH0:=ANZH.ref(); VAR1.ANWAR0:=ANZH.OPC
|| VAR1.ANZH0:=null(); VAR1.ANWAR0:=null()
?};
ANZH.prefix('1',ZL.ref(),ST.AR,ST.AM,'T');
{? ANZH.last()
|| VAR1.ANZH1:=ANZH.ref(); VAR1.ANWAR1:=ANZH.OPC
|| VAR1.ANZH1:=null(); VAR1.ANWAR1:=null()
?};
ANRUB.index('RUBR');
_rubr:=exec('crub','zl_head');
{! _it:=1.. obj_len(_rubr)
|! _rub:=($('ZL.TYP().CRUB'+_rubr[_it]))();
   ANRUB.prefix(_rub);
   {? ANRUB.first()
   || ($('VAR1.CRUB'+_rubr[_it]+':=ANRUB.ref()'))();
      ANZP.prefix(VAR1.ANZH0,ANRUB.NR);
      {? ANZP.first()
      || ($('VAR1.WAR0'+_rubr[_it]+':=ANZP.WAR'))()
      || ($('VAR1.WAR0'+_rubr[_it]+':=0'))()
      ?};
      ANZP.prefix(VAR1.ANZH1,ANRUB.NR);
      {? ANZP.first()
      || ($('VAR1.WAR1'+_rubr[_it]+':=ANZP.WAR'))()
      || ($('VAR1.WAR1'+_rubr[_it]+':=0'))()
      ?}
   || ($('VAR1.CRUB'+_rubr[_it]+':=null()'))();
      ($('VAR1.WAR0'+_rubr[_it]+':=0'))();
      ($('VAR1.WAR1'+_rubr[_it]+':=0'))()
   ?}
!};
~~


\crub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Tablica akronimów rubryk kalkulacyjnych
::----------------------------------------------------------------------------------------------------------------------
_rubr:=obj_new(6);
_rubr[1]:='IL0';
_rubr[2]:='IL';
_rubr[3]:='MAT';
_rubr[4]:='ROB';
_rubr[5]:='ALL';
_rubr[6]:='JEDN';
_rubr


\ust_znac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [12.41]
:: OPIS: aktualizuje znaczniki zlecenia
::  OLD: \ust_znac/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.ST_W:={? ZL.HIDDEN='T' || 'T' || 'N' ?};
ZL.ST_O:={? ZL.HIDDEN='N' & ZL.STAN='O' || 'T' || 'N' ?};
ZL.ST_Z:={? ZL.HIDDEN='N' & ZL.STAN='Z' || 'T' || 'N' ?};
ZL.ST_N:={? ZL.STAN<>'Z' || 'T' || 'N' ?};
ZL.ST_MJS:={? ZL.TYP().TYP='~PR' || 'P'
           |? ZL.TYP().TYP='~RE' || 'R'
           || 'Z'
           ?}


\node
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Wyznaczanie wartości ZL.NODE
::  OLD: \node/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZL.TREE=0
|| _wyn:=$ZL.ref()
|| ZL.cntx_psh();
   ZL.prefix();
   {? ZL.seek(ZL.TREE,) || _wyn:=exec('node','zl_head') ?};
   ZL.cntx_pop()
?};
_wyn


\prn_zl
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: wydruki dla konkretnego zlecenia w menu DEFINICJE
::  OLD: \zldod/drukujp.fml
::----------------------------------------------------------------------------------------------------------------------
exec('rep_exec','#b_report','TTE_PZL_XXXX','tte_zldod*','Wydruki dotyczące zlecenia'@,1);
1


\zl_display
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
::   WE: [_a] - INTEGER - [0]/1 - czy przyciski dot. kontroli oraz zamknięcia zlecenia
:: OPIS: Wyświetl na zleceniu
::  OLD: \zl_display/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_btn_zam:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_wp:=ZL.TYP().WP;

:: Zapamiętuje aktualne okno redagowania
_red:=ZL.win_edit('?');
_disp:='';
_atrmjs:=ATR.MJS;
ATR.MJS:='ZL';
DK_C.cntx_psh();
{? ZL.DK_C<>null() & ref_name(ZL.DK_C)<>DK_C.name() || DK_C.use(ref_name(ZL.DK_C)) ?};
_atryb:=exec('czytadkc','mat_atr',ZL.DK_C,ZL.RDKC);

_disp:=ZL.mk_edit({? _wp='W' || 'Zlecenie warsztatowe'@ || 'Zlecenie produkcyjne'@ ?},,'zldisp'+(-_wp));
{? _wp='P'
|| ZL.win_etab(_disp,'Dane podstawowe'@);
   ZL.win_ewin(_disp,,'DISP_PRO');
   ZL.win_etab(_disp,'Dane dodatkowe'@);
   ZL.win_ewin(_disp,,'DOD_DPRO');
   ZL.win_etab(_disp,'Koszty'@);
   ZL.win_ewin(_disp,,'KOSZTY_P')
|| ZL.win_etab(_disp,'Dane podstawowe'@);
   ZL.win_ewin(_disp,,'DISP_WAR');
   ZL.win_etab(_disp,'Dane dodatkowe'@);
   ZL.win_ewin(_disp,,'DOD_WAR');
   ZL.win_etab(_disp,'Koszty'@);
   ZL.win_ewin(_disp,,'KOSZTY_W')
?};

:: Ustawiam zmienne potrzebne gdyby karta technologiczna źródłowa była w archiwum
{? ZL.RKTL<>''
|| exec('display_vars','tech_common',ZL.RKTL)
?};

:: Podczytuje M_ATR
{? _atryb>0
|| ZL.KTM().M_ATR()
?};

:: Ustawiam nowe okno na display
{? _disp<>''
|| ZL.win_edit(_disp);
   {? _btn_zam>0
   || _form:="
         Cntx.psh(ZL,ZGH,ZGP);
         params_exec('kontr_zamk_b','!tte_pzl_ezam');
         Cntx.pop(ZL,ZGH,ZGP);
         ''
      ";
      _btn:=ZL.win_ebtn(_disp,'text=%1,align=begin,display=1'['&Kontrola zamknięcia zlecenia'@],_form);
      task_attach('TTE_PZL_EZAM');
      {? ZL.STAN='Z'
      || ZL.btn_eopt(_disp,_btn,'state=grayed')
      ?};

      _form:="
         Cntx.psh(ZL,ZGH,ZGP);
         params_exec('action_close','!tte_pzl_ezam');
         Cntx.pop(ZL,ZGH,ZGP);
         ZL.get();
         {? ZL.STAN='Z'
         || FUN.info('Zlecenie %1 zostało zamknięte.'@[ZL.SYM])
         ?};
         ''
      ";
      _btn:=ZL.win_ebtn(_disp,'text=%1,align=begin,display=1'['&Zamknij zlecenie'@],_form);
      task_attach('TTE_PZL_EZAM');
      {? ZL.STAN='Z'
      || ZL.btn_eopt(_disp,_btn,'state=grayed')
      ?}
   ?}
?};
exec('ustaw_pola','zl_head');
exec('efld_opt','zl_head',_disp);
ZL.DK_C();
ZL.display();
VAR.A_STAN:=ZL.STAN;
DK_C.cntx_pop();

:: Przywracam poprzednio używane okno redagowania
ZL.win_edit(_red);
ATR.MJS:=_atrmjs;
~~


\zl_display_red_full
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Tworzy okienko redagowania zlecenia z przyciskami na pełny podgląd zlecenia
::   WE: [_a] - STRING - tytuł okienka, domyślnie 'Podgląd zlecenia'
::       [_b] - STRING - nazwa przycisku Anuluj, domyślnie Anuluj
::       [_c] - obj_new() - tablica nazwana z definicją dodatkowego przycisku zwykłego (txt, fml)
::       [_d] - obj_new() - tablica nazwana z definicją dodatkowego przycisku wyróżnionego (txt, fml)
::       [_e] - INTEGER - [0]/1 - czy przycisk Kalkulacja dostępny
::       [_f] - INTEGER - [0]/1 - czy przycisk Analiza dostępny
::       [_g] - INTEGER - [0]/1 - czy okno redagowania (domyślnie grupowe okno selekcji)
::   WY: akronim okna
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_title:='Podgląd zlecenia %1'@[ZL.SYM];
{? var_pres('_a')=type_of('')
|| _title:=_a
?};

_anuluj_sym:='Anuluj'@;
{? var_pres('_b')=type_of('')
|| _anuluj_sym:=_b
?};

_btn_dod1:=~~;
{? var_pres('_c')>100
|| _btn_dod1:=_c
?};

_btn_dod2:=~~;
{? var_pres('_d')>100
|| _btn_dod2:=_d
?};

_btn_calc:=0;
{? var_pres('_e')=type_of(0)
|| _btn_calc:=_e
?};

_btn_anal:=0;
{? var_pres('_f')=type_of(0)
|| _btn_anal:=_f
?};

_win_red:=0;
{? var_pres('_g')=type_of(0)
|| _win_red:=_g
?};

ATR.MJS:='ZL';
{? ZL.DK_C<>null() & ref_name(ZL.DK_C)<>DK_C.name() || DK_C.use(ref_name(ZL.DK_C)) ?};
_atryb:=exec('czytadkc','mat_atr',ZL.DK_C,ZL.RDKC);
:: Ustawiam zmienne potrzebne gdyby karta technologiczna źródłowa była w archiwum
{? ZL.RKTL<>''
|| exec('display_vars','tech_common',ZL.RKTL)
?};
:: Podczytuje M_ATR
{? _atryb>0
|| ZL.KTM().M_ATR()
?};

_rodzaj:=ZL.RODZAJ;
_wp:=ZL.TYP().WP;
_red:=ZL.mk_edit(_title,,'zl_eakc_'+(-_wp),,,
   'html_maximized',
   {? _win_red>0 || 'auto' || 'wrapped' ?}
);
::ZL.win_ewin(_red,,'DISP_'+{? _wp='W' || 'WAR' || 'PRO' ?});
ZL.win_etab(_red,'Dane podstawowe'@);
ZL.win_ewin(_red,,'DISP_'+{? _wp='W' || 'WAR' || 'PRO' ?});
ZL.win_etab(_red,'Dane dodatkowe'@);
ZL.win_ewin(_red,,'DOD_'+{? _wp='W' || 'WAR' || 'DPRO' ?});
ZL.win_etab(_red,'Koszty'@);
ZL.win_ewin(_red,,'KOSZTY_'+_wp);

{? _wp='P'
|| _btn:=ZL.win_ebtn(_red,'text=%1,align=begin,display=1'['Technologia'@],"exec('view_tech','zl_head')");
   task_attach('TTE_PZL_DTEC');
   {? _rodzaj='Z' | ZL.TYP().TECH='N'
   || ZL.btn_eopt(_red,_btn,'state=grayed,tooltip=%1'['Technologia zlecenia'@])
   || ZL.btn_eopt(_red,_btn,'tooltip=%1'['Technologia zlecenia'@])
   ?}
?};
_tktl:=ZL.RTKTL;
{? _tktl=''
|| _tktl:=ZL.RKTL
?};
_oper:=exec('FindAndGet','#table',TKTL,_tktl,,"TYP().OPER");
_btn:=ZL.win_ebtn(_red,'text=%1,align=begin,display=1'['Przewodniki'@],"exec('view_guide','zl_head')");
task_attach('TTE_PZL_DPRZ');
{? _rodzaj='Z' | _oper='N'
|| ZL.btn_eopt(_red,_btn,'state=grayed')
?};

_btn:=ZL.win_ebtn(_red,'text=%1,align=begin,display=1'['Limity'@],"exec('view_lim','zl_head')");
task_attach('TTE_PZL_DLIM');
{? _rodzaj='Z'
|| ZL.btn_eopt(_red,_btn,'state=grayed')
?};

{? ZL.TYP().WP='P'
|| _btn:=ZL.win_ebtn(_red,'text=%1,align=begin,display=1'['Nielimitowane'@],"exec('view_nlim','zl_head')");
   task_attach('TTE_PZL_DLIM');
   {? _rodzaj='Z'
   || ZL.btn_eopt(_red,_btn,'state=grayed')
   ?}
?};
_btn:=ZL.win_ebtn(_red,'text=%1,align=begin,display=1'['Atrybu&ty'@],"exec('view_attrib','zl_head')");
task_attach('TTE_PZL_DPOZ');
{? _rodzaj='Z'
|| ZL.btn_eopt(_red,_btn,'state=grayed')
?};
_btn:=ZL.win_ebtn(_red,'text=%1,align=begin,display=1'['Doku&mentacja'@],"exec('view_docum','zl_head')");
task_attach('TTE_PZL_DPOZ');
{? _rodzaj='Z'
|| ZL.btn_eopt(_red,_btn,'state=grayed')
?};

{? _btn_calc>0
|| _btn:=ZL.win_ebtn(_red,'text=%1,align=begin,display=1'['Kalkulacja'@],"exec('view_anal0','zl_head')");
   task_attach('TTE_PZL_KKAL');
   task_attach('TTE_PZL_PKAL')
?};
{? _btn_anal>0
|| _btn:=ZL.win_ebtn(_red,'text=%1,align=begin,display=1'['Analiza'@],"exec('view_anal1','zl_head')");
   task_attach('TTE_PZL_KANA');
   task_attach('TTE_PZL_PANA')
?};

{? type_of(_btn_dod1)>0 & var_pres('txt',_btn_dod1)=type_of('') & var_pres('fml',_btn_dod1)=type_of("")
|| _btn:=ZL.win_ebtn(_red,_btn_dod1.txt,_btn_dod1.fml);
   ZL.btn_eopt(_red,_btn,'default=0')
?};

_default:=0;
{? type_of(_btn_dod2)>0 & var_pres('txt',_btn_dod2)=type_of('') & var_pres('fml',_btn_dod2)=type_of("")
|| _btn:=ZL.win_ebtn(_red,_btn_dod2.txt,_btn_dod2.fml);
   ZL.btn_eopt(_red,_btn,'default=1');
   _default:=1
?};
_btn:=ZL.win_ebtn(_red,'text=%1,align=end,display=1'[_anuluj_sym],"'key:Esc'");
{? _default=0
|| ZL.btn_eopt(_red,_btn,'default=1')
?};

{? _win_red>0
|| _red
|| _grp:=ZL.grp_make(_title,,'gr_edisp_'+(-_wp),,,,,'normal');
   ZL.grp_edit(_grp,,_red,,,,,,'maximized');
   _grp
?}


\view_tech
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podgląd technologii zlecenia (do uniwersalnego okna nagłówka zlecenia na liście zadań)
::  TAG: <PRYWATNA>
::  OLD: \view_tech/!tte_pzl_eakc.fml
::  OLD: \view_tech/!tte_pzl_ezam.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
_args:=exec('showzktl_a','tech_head');
_args.ZL:=ZL.ref();
VAR.A_ZLEC:=ZL.ref();
_args.SHOW:=1;
_args.TPAR_ASK:=1;
_args.EDIT:=0;
exec('showzktl','tech_head',_args);
''


\view_guide
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podgląd przewodników zlecenia (do uniwersalnego okna nagłówka zlecenia na liście zadań)
::  TAG: <PRYWATNA>
::  OLD: \view_guide/!tte_pzl_eakc.fml
::  OLD: \view_guide/!tte_pzl_ezam.fml
::----------------------------------------------------------------------------------------------------------------------
_env_guide:=exec('env_guide','zl_guide');
_env_guide.used:=1;
_env_guide.zgh_actions:='E:';
_env_guide.zgp_actions:='EYW:';
_env:=exec('env','zl_view');
_env.ZL:=ZL.ref();
_env.BUF_ZL.get();
_env.UID_ZL:=ZL.uidref();
_env.WP:=ZL.TYP().WP;
params_set('env',_env,'env_guide',_env_guide);
VAR.A_ZLEC:=ZL.ref();
exec('przewodniki','zl_guide',0);
''


\view_lim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podgląd limitów zlecenia (do uniwersalnego okna nagłówka zlecenia na liście zadań)
::  OLD: \view_lim/!tte_pzl_eakc.fml
::  OLD: \view_lim/!tte_pzl_ezam.fml
::----------------------------------------------------------------------------------------------------------------------
_result:='';
exec('kart_lim','zl_limit',1,ZL.ref(),'T',null(),null(),ZL.TYP().WP);
_result


\view_nlim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podgląd nielimitów zlecenia (do uniwersalnego okna nagłówka zlecenia na liście zadań)
::  OLD: \view_nlim/!tte_pzl_eakc.fml
::  OLD: \view_nlim/!tte_pzl_ezam.fml
::----------------------------------------------------------------------------------------------------------------------
_result:='';
exec('sur_nlim','zl_limit',1,ZL.ref(),,,1);
_result


\view_docum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podgląd dokumentacji zlecenia (do uniwersalnego okna nagłówka zlecenia na liście zadań)
::  OLD: \view_docum/!tte_pzl_eakc.fml
::  OLD: \view_docum/!tte_pzl_ezam.fml
::----------------------------------------------------------------------------------------------------------------------
exec('ZL','tech_doc',ZL.ref(),1);
''


\view_attrib
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podgląd atrybutów zlecenia (do uniwersalnego okna nagłówka zlecenia na liście zadań)
::  OLD: \view_attrib/!tte_pzl_eakc.fml
::  OLD: \view_attrib/!tte_pzl_ezam.fml
::----------------------------------------------------------------------------------------------------------------------
exec('ZL','tech_atr',ZL.ref(),1);
''


\view_anal0
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Podgląd kalkulacji zlecenia (do uniwersalnego okna nagłówka zlecenia na liście zadań)
::  OLD: \view_anal0/!tte_pzl_ezam.fml
::----------------------------------------------------------------------------------------------------------------------
_result:='';
exec('anal_poj','zl_kalk','0',ZL.ref(),0,0);
_result


\view_anal1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Podgląd analiz zlecenia (do uniwersalnego okna nagłówka zlecenia na liście zadań)
::  OLD: \view_anal1/!tte_pzl_ezam.fml
::----------------------------------------------------------------------------------------------------------------------
_result:='';
exec('anal_poj','zl_kalk','1',ZL.ref(),0,0);
_result


\zl_b_szuk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: przed Szukaj w oknach wertowania zleceń
::  OLD: \zl_b_szuk/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.ZRED_KTL:=VAR.RED_WER:='';
_wp:=VAR.A_WP;
{? _wp='P'
|| {? exec('enabled','zl_uslugi')
   || exec('mat_grp_f3','zl_uslugi',0,'W')
   || exec('slo_m_ok','material','T',0,,'W');
      exec('filter','material','WP')
   ?};
   ZL.win_patt('WZOR_PRO')
|| ZL.win_patt('WZOR_WAR')
?}


\legenda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Legenda w oknie zleceń (tabela ZL - okna PWER_P, PWER_W, STRUCT
::   WY: Schemat kolorowania [STRING]
::  OLD: \legenda/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
::_jest:=var_pres('__akt_zl')>0 & ZAKR.VZL='A' & ZAKR.ZTP_WP<>'W';

::{? _jest
::|| exec('legenda','color','ZL#01#0','ZL#01#15','@ZL#START','@ZL#END','#ZL#02','#ZL#03','#ZL#04','#ZL#05')
::|| exec('legenda','color','ZL#01#0','ZL#01#15','@ZL#START','@ZL#END','#ZL#02','#ZL#03','#ZL#05')
::?}
{? ZAKR.ZTP_WP='W'
|| exec('legenda','color','@ZL#START','@ZL#END','#ZL#03','#ZL#05')
:: 'ZL#01#0','ZL#01#15','@ZL#START','@ZL#END','#ZL#02','#ZL#03','#ZL#05')
|| {? ZAKR.VZL='A'
   || exec('legenda','color','ZL#01#01','ZL#01#15','@ZL#START','@ZL#END','#ZL#02','#ZL#03','#ZL#04','#ZL#05')
   || exec('legenda','color','ZL#01#01','@ZL#START','@ZL#END','#ZL#02','#ZL#03','#ZL#05')
   ?}
::'ZL#01#0','ZL#01#15','@ZL#START','@ZL#END','#ZL#02','#ZL#03','#ZL#04','#ZL#05')
?}


\leg_zlkalk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Legenda w oknie ZL.WERW
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','#ZL#05','#ZL#03')


\be_zl_nr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [17.00]
:: OPIS: Przed redakcją symbolu zlecenia
::  OLD: \be_zl_nr/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
-(6+menu_txt())='szukaj'


\ae_zl_nr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AMK [17.00]
:: OPIS: Po redakcji symbolu zlecenia
::----------------------------------------------------------------------------------------------------------------------
{? -(6+menu_txt())='szukaj'
|| 1
|| exec('chk_fld','#valid')
?}


\zl_opis_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Formuła na blank albo aktualizująca dla pola ZL.OPIS
::  OLD: \zl_opis_bl/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZTP.WP='P'
|| _opcja:=exec('get','#params',500101,2)
|| _opcja:=exec('get','#params',500102,2)
?};

{? +_opcja=2 & _opcja='#B'
|| 'Brak opisu'
|? 1+_opcja<>'#'
|| _opcja
|? +_opcja=2 & _opcja='#K' & ZL.KTM<>null()
|| ZL.KTM().KTM+' — '+ZL.PWYD().PWYD
|? +_opcja=2 & _opcja='#N' & ZL.KTM<>null()
|| ZL.KTM().N
|| ''
?}


\ust_jorg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS
:: OPIS: Wartość początkowa pola ZL.JORG
::   WY: ref()
::  OLD: \ust_jorg/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZTP.WYD<>null()
|| ZTP.WYD
|| null()
?}


\czy_redw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.62]
:: OPIS: czy redagować pole ZL.JORG
::  OLD: \czy_redw/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_edit:=params_get().args.edit;
_result:=1;
{? _edit
||
   {? ZL.PROJEKTY<>null & ZL.PROJEKTY().UD_SKL<>null() & ZTP.PROJWJO='T'
   || _result:=0
   ?};

   {? _result>0
   || {? ZL.STAN<>'N'
      || _result:=0
      ?}
   ?};
   {? _result>0
   || ZL.cntx_psh();
      _ktm:=ZL.KTM;
      {? exec('jakislw','wzorce')
      || {? VAR.FILTER='T' & FILTER.JORG<>null()
         || _result:=0
         || {? VAR.A_ZLNAD<>null() & VAR.A_ZLNAD().KTM=_ktm
            || _result:=0
            || _result:=1
            ?}
         ?}
      || _result:=0
      ?};
      ZL.cntx_pop()
   ?}
|| _result:=0
?};
_result


\zl_jorg_po
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Po redakcji pola ZL.JORG
::   WY: 1
::  OLD: \zl_jorg_po/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZL.MG=null() || ZL.MG:=exec('ustmwyd','zl_common',ZL.ODDZ,ZL.JORG,0) ?};
1


\zl_typ_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed redagowaniem pola ZL.TYP
::----------------------------------------------------------------------------------------------------------------------
fld()=null()


\czyred
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: przed redakcją pola ZL.KTM
::  OLD: \czyred/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_buffer:=params_get().args.buffer;
_buffer.KTM:=ZL.KTM;

_edit:=params_get().args.edit;
{? ~_edit || return(0) ?};

_edit_ktm:={? var_pres('edit_ktm',params_get().args)>0 || params_get().args.edit_ktm || 1 ?};
{? ~_edit_ktm || return(0) ?};

:: Czy zlecenie jest powiązane ze źródłowymi zamówieniami
_zlzam:=0;
ZLZAM.index('ZLZM');
ZLZAM.prefix(ZL.ref());
{? ZLZAM.first()
|| {!
   |? {? ZLZAM.ZAMPOZ<>'' || _zlzam:=1 ?};
      ZLZAM.next()
   !}
?};

:: Czy zlecenie jest w planie strategicznym
_pxed:=exec('zl_utilization','px_plan',ZL.ref());

:: Czy do zlecenia są przewodniki
_zgh:=0;
ZGH.cntx_psh();
ZGH.index('ZLNR');
ZGH.prefix(ZL.ref());
{? ZGH.first() || _zgh:=1 ?};
ZGH.cntx_pop();

_ok:=0;
{? ZL.RODZAJ<>'N' & _zlzam=0 & _pxed=0 & _zgh=0
||
   {? VAR.FILTER='T' & FILTER.KTM<>null()
   || VAR.A_T:=FILTER.KTM;
      VAR.A_TORW:='T';
      _ok:=0
   || ZL.TKTL=null() &
      {? ZL.SYM<>''
      || _ok:=exec('czy_red','zl_head')
      || _ok:=1
      ?}
   ?}
|| _ok:=0
?};

{? _ok
|| ZAKR.MATU:='A';
   _edit_tktl:={? var_pres('edit_tktl',params_get().args)>0 || params_get().args.edit_tktl || 1 ?};
:: _only_ktm - przypadek, gdy technologia zablokowana, a dozwolona redakcja produktu (generowanie zleceń z technologii)
   _only_ktm:=_edit_tktl=0 & _edit_ktm=1;

   {? exec('enabled','zl_uslugi')
   || _actions:={? _only_ktm>0 || 'DPUWIORE' || 'W' ?};
      exec('mat_grp_f3','zl_uslugi',0,_actions)
   || _actions:={? _only_ktm>0 || 'DPUWIORE' || 'W' ?};
      exec('slo_m_ok','material','T',0,,_actions);
      exec('filter','material','WP')
   ?};

   {? _only_ktm
   ||
::    Zawężenie zakresu materiałów (filtr) wyłącznie do produktów zlecenia
      exec('ktm_f_set','zl_head')
   ?};
   exec('wpm_opis','material',FILTER.T_WPM,' — '+exec('zakr_naz','material',ZAKR.MATU))
?};
_ok


\poredt
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: po redakcji pola 'Kod produktu' na zleceniu
::   WE: [_a] - miejsce wywołania: [1] - po redagowaniu pola w oknie
::                                  0 - przed wyświetleniem okna redagowania, po wcześniejszym ustaleniu wartości pola
::   WY: 0 / 1
::  OLD: \poredt/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_czy_ae:={? var_pres('_a')=type_of(0) || 0 || 1 ?};
_buffer:=params_get().args.buffer;
ATR.MJS:='ZL';

_wyn:=1;
{? _czy_ae>0
|| {? VAR.FILTER='T'
   || {? FILTER.GRUPA<>null() & FILTER.GRUPA<>ZL.KTM().MGR
      || FUN.emsg('Zgodnie z ustawieniami filtra,\n'+
            'produkt musi należeć do grupy: '+FILTER.GRUPA().KOD+'.');
         return(0)
      |? FILTER.WPM<>'' & FILTER.WPM<>ZL.KTM().R
      || FUN.emsg('Zgodnie z ustawieniami filtra,\n'+
            'produkt musi być '+{? FILTER.WPM='W' || 'wyrobem.' |? FILTER.WPM='P' || 'półfabrykatem.' || '??' ?});
         return(0)
      ?}
   ?}
?};

{? (_czy_ae=0 & ZL.KTM<>null()) | (_czy_ae>0 & chk_fld(1))
||
   {? ZL.KTM().A<>'T'
   || {? _czy_ae>0
      || FUN.error('Produktem zlecenia może być tylko aktywny materiał.'@)
      ?};
      return(0)
   ?};

:: Jeśli zmiana KTM, to odblokowanie redagowania technologii
   {? _buffer.KTM<>ZL.KTM || ZL.SRCTECH:='T' ?};

:: Jeśli zmiana KTM, to ostrzeżenie o zmianie opisu (gdy opis generowany wg #K albo #N)
   {? _czy_ae>0
   || _opcja:=exec('get','#params',500101,2);
      {? (_opcja='#K' | _opcja='#N') & _buffer.KTM<>null() & _buffer.KTM<>ZL.KTM
      || {? FUN.ask(
               'Wpisany został inny KTM produktu.\n\n'
               'Polu \'Opis\' zostanie nadana nowa wartość.\n\n'
               'Czy kontynuować?'@
            )
         || ZL.OPIS:=''
         || _wyn:=0
         ?}
      ?}
   ?};

:: Podpowiedź TKTL
   {? _wyn & ZL.KTL=null() & ZL.SRCTECH='T'
   || TKTLW.cntx_psh();
      TKTLW.clear();
      TKTLW.index('KSN');
      TKTLW.prefix();
::    TKTLW.prefix('T',M.ref(),'T','N');
      TKTLW.f_set(,'join TKTL using (TKTLW.TKTL,TKTL.REFERENCE)'
            ,'
            TKTL.TORW=\'T\'
            and TKTLW.KTM=:_a
            and TKTL.STAN=\'T\'
            and TKTL.ARCH=\'N\'
            and ((TKTL.TERM_OD<=to_date(:_b) and TKTL.TERM_OD IS NOT NULL)
            or TKTL.TERM_OD IS NULL)
            and ((TKTL.TERM_DO>=to_date(:_b) and TKTL.TERM_DO IS NOT NULL)
            or TKTL.TERM_DO IS NULL)
            '
            ,M.ref(),date());
      _ok:=1;
      {? TKTLW.f_first() & ~TKTLW.f_next()
      || ZL.KTL:=TKTLW.TKTL;
         VAR.RED_WER:=ZL.KTL().WER;
         VAR.SERIATCH:=TKTL.SERIA;
         {? ZL.IL=0 || ZL.IL:=exec('optymseria','zl_head') ?};
         ZL.GKTL:=TKTL.GKTL;
         _ok:=0
      || _ok:=1;
         {? TKTLW.f_first()
         || {!
            |? {? TKTLW.DEFAULT='T'
               || _ok:=0;
                  ZL.KTL:=TKTLW.TKTL;
                  VAR.RED_WER:=ZL.KTL().WER;
                  VAR.SERIATCH:=TKTL.SERIA;
                  {? ZL.IL=0 || ZL.IL:=exec('optymseria','zl_head') ?};
                  ZL.GKTL:=TKTL.GKTL;
                  0
               || TKTLW.f_next()
               ?}
            !}
         || {? ZL.TYP().TECH='T' & ZL.RODZAJ='P'
            || {? _czy_ae>0 & ~FUN.ask('Wskazany produkt nie ma technologii.\n\nCzy kontynuować?'@)
               || TKTLW.cntx_pop();
                  return(0)
               ?}
            || {? _czy_ae>0
               || FUN.info('Wskazany produkt nie ma technologii.'@);
                  TKTLW.cntx_pop();
                  return(0)
               ?}
            ?}
         ?};
         {? _ok=1 || ZL.KTL:=null(); ZL.GKTL:=null(); ZL.RKTL:='' ?}
      ?};
      TKTLW.cntx_pop();
      {? ZL.OPIS='' || ZL.OPIS:=exec('zl_opis_bl','zl_head') ?};
      1
:: TKTL już jest wypełniona
   |? _wyn & ZL.SRCTECH='T'
   || TKTLW.cntx_psh();
      TKTLW.clear();
      TKTLW.index('KSN');
      TKTLW.prefix();
::    TKTLW.prefix('T',M.ref(),'T','N');
      TKTLW.f_set(,'join TKTL using (TKTLW.TKTL,TKTL.REFERENCE)'
            ,'
            TKTL.TORW=\'T\'
            and TKTLW.KTM=:_a
            and TKTL.STAN=\'T\'
            and TKTL.ARCH=\'N\'
            and ((TKTL.TERM_OD<=to_date(:_b) and TKTL.TERM_OD IS NOT NULL)
            or TKTL.TERM_OD IS NULL)
            and ((TKTL.TERM_DO>=to_date(:_b) and TKTL.TERM_DO IS NOT NULL)
            or TKTL.TERM_DO IS NULL)
            '
            ,M.ref(),date());
      {? TKTLW.f_first()
      ||
::       Sprawdzenie, czy dowolna TKTLW zgadza się ze wpisaną TKTL
         _is_tktl:=0;
         {!
         |?
            {? TKTLW.TKTL=ZL.KTL || _is_tktl:=1 ?};
            TKTLW.f_next()
         !};
         {? _is_tktl
         || _ok:=1
         || {? ZL.KTL<>null & ZL.KTL().KTM=ZL.KTM & ~exec('tktl_act','tech_head',1)
            || _txt:='Wpisana technologia dla produktu jest nieaktualna.\n\n'
                     'Pole \'Technologia\' zostanie wyczyszczone.\n\n'
                     'Czy kontynuować?'@
            || _txt:='Wpisany produkt ma inną technologię niż wpisana.\n\n'
                     'Pole \'Technologia\' zostanie wyczyszczone.\n\n'
                     'Czy kontynuować?'@
            ?};
            {? _czy_ae=0 | FUN.ask(_txt)
            || ZL.KTL:=null(); ZL.GKTL:=null(); ZL.RKTL:='';
               ZL.OPIS:='';
               _ok:=1
            || _ok:=0
            ?}
         ?}
      || {? _czy_ae>0
         || FUN.emsg('Wskazany produkt nie ma technologii.'@)
         ?};
         ZL.KTL:=null(); ZL.GKTL:=null(); ZL.RKTL:='';
         _ok:=0
      ?};
      TKTLW.cntx_pop();
      {? ZL.OPIS='' || ZL.OPIS:=exec('zl_opis_bl','zl_head') ?};
      _wyn:=_ok;
      _ok
   ?};
   TKTLW.f_clear();
:: Wyznaczenie magazynu po zmianie produktu (wtyczka)
   {? _wyn & ZL.KTM<>null() & _buffer.KTM<>ZL.KTM
   || {? Plugin.runnable('ZL_MG_ZLEC_001')
      || _mg:=Plugin.run('ZL_MG_ZLEC_001',ZL.ODDZ,ZL.KTM,ZL.JORG);
         {? type_of(_mg)=type_of(MG.ref()) & _mg<>null()
         || {? ZL.MG<>_mg & ZL.ODDZ=exec('FindAndGet','#table',MG,_mg,,"MG.ODDZ",'')
            || {? ZL.MG=null()
               || ZL.MG:=_mg
               || _mg_sym:=exec('FindAndGet','#table',MG,_mg,,"SYM",'');
                  {? _czy_ae=0 | FUN.ask(
                     'Sugerowany magazyn dla produktu %3: %1 (obecenie %2).\n\n'
                     'Czy zmienić magazyn zlecenia na %1?'@[_mg_sym,ZL.MG().SYM,ZL.KTM().KTM]
                  )
                  ||  ZL.MG:=_mg
                  ?}
               ?}
            ?}
         ?}
      ?}
   ?};
   {? _wyn
   ||
::    ustawienie słownika okienka cech
      ATR.MJS:='ZL';
      {? #ZL.KTM().M_ATR<>#ATR.M_ATR
      || {! _i..10 |! ($('ATR.WAR'+form(_i,-2,0,'99')))():='' !};
         ZL.DK_C:=null
      ?};
      ATR.M_ATR:=ZL.KTM().M_ATR;
      {? ZL.STAN<>'N'
      || ATR.FLAG_ED:=0;
         ATR.FLAG:=0
      || ATR.FLAG_ED:=(1+ZL.MG().TYP)='D' & ATR.CZY_ATR & ATR.M_ATR().EDIT;
         ATR.FLAG:={? ATR.FLAG_ED & ZL.KTM().M_ATR<>null() || 2 || 0 ?};
         {? ATR.FLAG_ED || {? ZL.KTM().M_ATR<>null() || ATR.FLAG_ED:=2 ?} ?}
      ?};
::    opcje dla pól
      {? _czy_ae>0
      || exec('efld_opt','zl_head',ZL.win_edit('?'));
         win_disp()
      ?}
   ?};
   _wyn
|| {? _czy_ae>0
   || FUN.emsg('Proszę wypełnić pole.'@)
   ?};
   _wyn:=0
?};
:: Wyczyszczenie filtru na kartotece materiałowej
{? M.f_active()>0 || M.f_clear() ?};
_wyn


\stan_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Format wyświetlania pola ZL.STAN
::  OLD: \stan_fd/zl.fml
::----------------------------------------------------------------------------------------------------------------------
'empty=1'


\stat_pl_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Format wyświetlania pola VAR1.STAT_PL
::  OLD: \stat_pl_fd/zl.fml
::----------------------------------------------------------------------------------------------------------------------
''


\sprdt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Sprawdza czy możliwe jest utworzenia zlecenia w danym roku.
::   WY: 1 - tak, 0 - nie
::  OLD: \sprdt/plprod.fml
::----------------------------------------------------------------------------------------------------------------------
_okro:=exec('szuk_okro','okresy',date());
{? _okro=null()
|| FUN.emsg(
      'Uwaga: nie powinno się dołączać zleceń.\n\n'
      'Należy uzupełnić tabelę okresów obrachunkowych dla roku %1\n'
      '(czynność tę powinna wykonać uprawniona osoba).'@[$(date()~1)],
   );
   _ok:=0
|| _ok:=1
?};
_ok


\usunzm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Akcja okienko po ZL
::   WY: 1
::  OLD: \usunzm/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_ZLNAD:=null();
1


\rkprz_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Rekord przed ZL
::   WY: Napis określający kolor (akcja przed rekord w oknach tabeli ZL)
::  OLD: \rkprz_zl/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
params_exec('rekprzed','color','ZL#01#')


\rkprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.53]
:: OPIS: Wylicza procenty zaawansowania (wolne pola) oraz koloruje rekordy zleceń (faktyczna akcja przed rekord)
::   WY: schemat kolorów
::  OLD: \procent/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
:: Środowisko potrzebne tylko do kolorowania panelu struktury (patrz na koniec formuły)
:: Dodatkowo zabezpieczenie, gdy odświeżanie okna wykonane zostanie w niespodziewanym kontekście
{? cur_win(1,1)='STRUCT'
|| _params:=params_get();
   {? var_pres('_params')>100 & var_pres('env',_params)>100
   || _env:=params_get().env
   || _env:=~~
   ?}
?};

:: Wylicza procenty zaawansowania
exec('procent','zl_head');

:: Wyświetla stan magazynowy
{? ZL.TYP().WP='W'
|| SM.blank(1)
|| {? ZL.RODZAJ='N'
   || SM.blank(1)
   |? ZL.RODZAJ='Z'
   || SM.index('SM');
      SM.prefix(ZL.MG,ZL.KTM);
      {? ~SM.first() || SM.blank(1) ?}
   |? exec('is_main_podzlec','zl_link',ZL.ref())
   || SM.index('SM');
      SM.prefix(ZL.MG,ZL.KTM);
      {? ~SM.first() || SM.blank(1) ?}
   || {? ZL.MG<>null()
      || _mag:=ZL.MG().SYM
      || _mag:=exec('get','#params',500005)
      ?};
      {? _mag=''
      || SM.blank(1)
      || SM.index('SMM');
         SM.prefix(ZL.KTM,_mag,);
         {? ~SM.first() || SM.blank(1) ?}
      ?}
   ?}
?};
VAR1.SD:=SM.SD;
:: Zmienna dla bieżącego zlecenia
VAR.A_ZLEC:=ZL.ref();

:: Zmienne dla zleceń podrzędnych
{? ZL.RODZAJ='P' & ZL.NRNZL<>0
|| ZL.cntx_psh();
   ZL.clear();
   ZL.index('UNRZL');
   ZL.prefix(ZL.NRNZL);
   {? ZL.first()
   || VAR.A_UNRZL:=ZL.UNRZL;
      VAR.A_ZLNAD:=ZL.ref()
   || VAR.A_UNRZL:=0;
      VAR.A_ZLNAD:=null()
   ?};
   ZL.cntx_pop()
|| VAR.A_UNRZL:=0;
   VAR.A_ZLNAD:=null()
?};

:: Kolorowanie
{? cur_win(1,1)='STRUCT' & type_of(_env)>100 &
   exec('green_branch','zl_view',exec('FindAndGet','#table',ZL,_env.ZL_TREE),ZL.ref())=0
|| 'ZL#01#15'
|| {? ZL.TYP().TOL>=100-VAR.REAL
   || 'ZL#01#01'
   || ''
   ?}
?}


\procent
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wylicza procent zaawansowania (wolne pola)
::----------------------------------------------------------------------------------------------------------------------
{? ZL.RODZAJ<>'N' | ZL.NRNZL<>0
|| {? ZL.IL<>0
   || VAR.REAL:=ZL.ILWYK/ZL.IL*100;
      VAR.REAL1:=ZL.ILDOK/ZL.IL*100
   || VAR.REAL:=0;
      VAR.REAL1:=0;
      ZL.cntx_psh();
      {? ZL.RODZAJ='Z'
      || _zlnr:=ZL.UNRZL;
         ZL.index('NRNZL');
         ZL.prefix(_zlnr);
         {? ZL.first()
         || VAR.REAL:={? ZL.IL=0 || 0 || ZL.ILWYK/ZL.IL*100 ?};
            VAR.REAL1:={? ZL.IL=0 || 0 || ZL.ILDOK/ZL.IL*100 ?}
         ?}
      ?};
      ZL.cntx_pop()
   ?}
|| ZL.cntx_psh();
   ZL.index('NRNZL');
   ZL.prefix(ZL.UNRZL);
   VAR.REAL:=0;
   VAR.REAL1:=0;
   _ile:=0;
   {? ZL.first()
   || {!
      |? VAR.REAL+={? ZL.IL <> 0 || ZL.ILWYK/ZL.IL*100 || 0 ?};
         VAR.REAL1+={? ZL.IL <> 0 || ZL.ILDOK/ZL.IL*100 || 0 ?};
         _ile+=1;
         ZL.next()
      !};
      VAR.REAL:={? _ile<>0 || VAR.REAL/_ile || 0 ?};
      VAR.REAL1:={? _ile<>0 || VAR.REAL1/_ile || 0 ?}
   ?};
   ZL.cntx_pop()
?};
VAR.JM:=ZL.KTM().J;
_ilosc:=0;
ZGH.cntx_psh(); ZGP.cntx_psh();
ZGH.index('ZLNR');
ZGH.prefix(ZL.ref());
{? ZGH.first()
|| {!
   |? ZGP.prefix();
      {? ZL.NRNZL=0
      || ZGP.index('NRPP')
      || ZGP.index('PNRPP')
      ?};
      ZGP.prefix(ZGH.ref());
      {? ZGP.first()
      || {!
         |? {? ZGP.TPZ='N'
            || {? ZGP.NTIME=0
               || _ilosc+=ZGP.MTIME
               || _ilosc+=ZGP.NTIME
               ?}
            ?};
            ZGP.next()
         !}
      ?};
      ZGH.next()
   !}
?};
ZGH.cntx_pop(); ZGP.cntx_pop();
{? _ilosc=0
|| VAR.REAL2:=0
|| VAR.REAL2:=(ZL.HWYK/_ilosc)*100
?};
~~


\czy_red
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Używane w formułach sprawdzających redagowanie pól w nagłówku zlecenia (dla podzlecenia)
::   WY: 0 / 1
::  OLD: \czy_red/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
ZL.index('NRNZL');
{? ZL.NRNZL=0
|| ZL.prefix(ZL.UNRZL);
   ZL.first();
   {? ZL.size()>1 || _ok:=0 || _ok:=1 ?}
|| _ok:=1
?};
ZL.cntx_pop();
_ok


\be_zlec_od
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Przed redakcją pola ZL.OD
::  OLD: \be_zlec_pd/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_edit:=1;
{? -(1+menu_txt())<>'d'
|| _edit:=1
?};
_edit


\ae_zlec_od
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Po redakcji pola ZL.OD
::  OLD: \ae_zlec_od/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZL.OD~1<>ZL.AR
|| FUN.emsg('Data powołania zlecenia musi być zgodna z rokiem %1.'@[$ZL.AR]);
   0
|? ZL.DZATW<>date(0,0,0) & ZL.OD>ZL.DZATW
|| FUN.emsg('Data powołania zlecenia nie może być późniejsza niż data zatwierdzenia.'@)
|| 1
?}


\be_zlec_do
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Przed redakcją pola ZL.DO
::  OLD: \be_zlec_do/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
0


\ae_zlec_do
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Po redakcji pola ZL.DO
::  OLD: \be_zlec_dp/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
1


\ilczyred
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Przed redakcją pola ZL.IL
::   WY: 1 (można redagować) / 0 (nie można redagować)
::  OLD: \ilczyred/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_edit:=params_get().args.edit;

{? ~_edit | (ZL.STAN<>'N' & ZL.STAN<>'O') || return(0) ?};

_result:=0;

:: Pozwalamy na redagowanie ilości na zleceniu innym niż niezależne nagłowkowe
{? ZL.RODZAJ<>'N'
|| exec('openmask','zl_common',ZL.ref());
:: Otwarte zawsze można (korekty przewodników i limitów wykonywane są po zredagowaniu)
   {? ZL.STAN='O'
   || _result:=1
:: W przygotowaniu można
   |? ZL.STAN='N'
   || {? ZL.IL=0 || ZL.IL:=exec('optymseria','zl_head') ?};
      _result:=1
   ?}
?};

_result


\optymseria
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Roman Firla [12.30]
:: OPIS: Zwraca wartość optymalnej serii dla zlecenia
::   WY: Seria optymalna
::  OLD: \optymseria/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('get','#params',500110,2)='T' || VAR.SERIATCH || 0 ?}


\zlpoil
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Kontrola podzielności jednostek
::   WY: 0 / 1
::  OLD: \zlpoil/polap.fml
::----------------------------------------------------------------------------------------------------------------------
_cc:=exec('jaka_dok_m','jm',ZL.KTM);
_res:=exec('poil','zl_common','T','ZL.IL',_cc);
{? menu_txt='Popraw' & ZL.IL=0
|| FUN.error('Ilość nie może być zerowa.'@);
   _res:=0
?};
return(_res)


\bd_zlktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Przed wyświetleniem pola KTL tabeli ZL
::  OLD: \bd_zlktl/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_T:=ZL.KTM;
~~


\ztp_kk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Zwraca ZTP.KK
::   WY: ZTP.KK
::  OLD: \ztp_kk/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
ZTP.KK


\zl_pwyd_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Blank pola ZL.PWYD
::  OLD: \zl_pwyd_bl/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.A_ZLNAD<>null() & VAR.A_UNRZL<>0
|| ZL.cntx_psh();
   ZL.index('UNRZL');
   ZL.prefix(VAR.A_UNRZL);
   {? ZL.first() || _res:=ZL.PWYD || _res:=null() ?};
   ZL.cntx_pop();
   _res
||
   _pwyd:=exec('get','#params',8002,2,OPERATOR.USER);
   {? _pwyd='' || _pwyd:=exec('get','#params',500100,2) ?};
   {? _pwyd=''
   || null()
   || ZPWYD.clear();
      ZPWYD.blank(1);
      ZPWYD.PWYD:=_pwyd;
      {? ZPWYD.find_rec()
      || ZPWYD.ref()
      || null()
      ?}
   ?}
?}


\zpwyd_pp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Przed popraw zapisu ZPWYD
::   WY: 1 / 0
::  OLD: \zpwyd_pp/slownik1.fml
::----------------------------------------------------------------------------------------------------------------------
{? 1+ZPWYD.PWYD='~'
|| FUN.emsg('Zapis zastrzeżony.\n\nModyfikacje nie są możliwe.'@);
   0
|| 1
?}


\zpwyd_pu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Usunięcie zapisu ZPWYD
::  OLD: \zpwyd_pu/slownik1.fml
::----------------------------------------------------------------------------------------------------------------------
{? 1+ZPWYD.PWYD='~'
|| FUN.emsg('Zapis zastrzeżony.\n\nUsunięcie nie jest możliwe.'@)
||
   _link:=ZPWYD.testlink(2);
   {? _link.first()
   || FUN.emsg('Usunięcie nie jest możliwe.\nWskazana pozycja jest już użyta w systemie.'@)
   ||
      {? FUN.ask('Czy usunąć wskazaną pozycję?'@)
      || ZPWYD.del()
      ?}
   ?}
?};
~~


\zpwyd_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Przed redakcją pola ZPWYD.PWYD
::   WY: 1
::  OLD: \zpwyd_be/slownik1.fml
::----------------------------------------------------------------------------------------------------------------------
1


\zl_pwyd_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Przed redakcją pola ZL.PWYD
::   WY: 1 / 0
::   OLD: \zl_pwyd_be/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_edit:=params_get().args.edit;
{? _edit
|| {? ZL.STAN<>'N'
   || 0
   || {? 1+ZL.PWYD().PWYD='~' || 0 || 1 ?}
   ?}
|| 0
?}


\zl_pwyd_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Po redakcji pola ZL.PWYD
::   WY: 1 / 0
::  OLD: \zl_pwyd_ad/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
{? 1+ZL.PWYD().PWYD='~'
|| FUN.info('Zastrzeżona podstawa powołania zlecenia — podaj inną.'@);
   0
|| 1
?}


\zl_dtr_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Formula na blank pola ZL.DTR
::       Jeżeli zlecenie podrzędne, to domyślnie z nadrzędnego, wpp wg parametru 500103
::  OLD: \zl_dtr_bl/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.A_ZLNAD<>0
|| ZL.cntx_psh();
   _dt:=VAR.A_ZLNAD().DTR;
   ZL.cntx_pop();
   _dt
|| _opcja:=exec('get','#params',500103,1);
   ZL.OD+_opcja
?}


\zl_dt_wys
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Przed wyświetl dla pola ZL.DTR
::   WY: 0 / 1 / kolor
::  OLD: \zl_dt_wys/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZL.DTR=date(0,0,0)
|| 1
|? ZL.DTR<date()
|| exec('flddisp','color','ZL#DTR#01')
|| 1
?}


\dtr_spr
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Po redakcji pola ZL.DTR
::   WY: 0 / 1
::  OLD: \dtr_spr/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZL.DTR<date() & ZL.DTR<>date(0,0,0)
|| FUN.emsg('Termin realizacji nie może być wcześniejszy od daty dzisiejszej.'@);
   return(0)
?};

:: Dla zleceń podrzędnych dodatkowa kontrola przekroczenia terminu ze zlecenia nadrzędnego
{? ZL.NRNZL<>0
|| ZL.cntx_psh();
   ZL.index('UNRZL');
   ZL.prefix(ZL.NRNZL);
   {? ZL.first() || _dtr:=ZL.DTR || _dtr:=date(0,0,0) ?};
   ZL.cntx_pop();
   {? ZL.DTR>_dtr
   || FUN.emsg(
         'Termin realizacji podzlecenia nie może być późniejszy niż dla zlecenia głównego (%1).\n'
         'Należy podać wcześniejszą datę.'@[$_dtr]
      );
      return(0)
   ?}
?};

:: Jezeli wewnętrzny termin realizacji nie jest określony, to przypisuje taki jak termin realizacji
{? ZL.PL_DATA=date(0,0,0) || ZL.PL_DATA:=ZL.DTR ?};
1


\be_zl_kh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Przed redakcją pola ZL.KH (sprawdzenie, czy zlecenie z zamówienia, wtedy nie redagować)
::  OLD: \be_zl_kh/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
_edit:=params_get().args.edit;

_result:=1;
{? _edit
||
   {? ZL.PROJEKTY<>null & ZL.PROJEKTY().KH<>null() & ZTP.PROJZKH='T'
   || _result:=0
   ?};

   {? _result>0
   ||
      ZLZAM.cntx_psh();
      ZLZAM.index('ZLZM');
      ZLZAM.prefix(ZL.ref());
      {? ZLZAM.first()
      || {!
         |? {? ZLZAM.ZAMPOZ<>''
            || _result:=0
            ?};
            ZLZAM.next() & _result>0
         !}
      ?};
      ZLZAM.cntx_pop()
   ?}
|| _result:=0
?};
_result


\sdefopca
::----------------------------------------------------------------------------------------------------------------------
::  UTW:
:: OPIS: Zmienia wariant domyślny analizy dla zlecenia
::   WE: _a - '0' kalkulacja zlecenia
::            '1' analiza zlecenia
::  OLD: \sdefopca/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A01:=_a;
ANWAR.win_dict('WER'+VAR.A01);
_tab:=sql('select ZTPF.OPC as OPC from ZTPF where ZTPF.TYP=\':_a\'',$ZL.TYP);
{? ~ANWAR.f_set('NA',,'"ANWAR"."A01"=\':_a\' and ("ANWAR"."REFERENCE" in (select OPC from :_b))',VAR.A01,_tab)
||
   exec('err_sql','#sql');
   return(0)
?};
1


\bl_zlnrn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [TS] - 2001/10/30 - [7.53] OWwPR020/5.1
:: OPIS: blank ZL.NRNZL
::  OLD: \bl_zlnrn/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_UNRZL


\spr1_tech
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Sprawdza, czy w technologii zlecenia występują półfabrykaty
::   WE: [_a] - dialog [domyslnie - 1], bez dialogu [0]
::   WY: (0/1)
::  OLD: \spr1_tech/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _dialog:=_a || _dialog:=1 ?};

{? ZL.RODZAJ='Z' & ZL.KTL<>null()
|| _arch:=0;
   _czy_pf:=exec('czy_pf','tech_mater',ZL.KTL);
   {? _czy_pf=0
   || {? _dialog
      || _ok:=FUN.ask(
            'W wybranej technologii nie są wykorzystywane półfabrykaty.\n'
            'Czy utworzyć według niej zlecenie z podzleceniami?'@
         )
      || _ok:=0
      ?}
   || _ok:=1
   ?};

   {? _ok>0
   ||
::    Jeśli są półfabrykaty to sprawdzam czy nie używają archiwalnych kart
      _arch:=exec('chk_pf_arch','zl_head',ZL.KTL,_dialog);
      {? _arch=1
      || _ok:=0
      ?}
   ?};
::   {? _ok=0
::   ||
::      ZL.RODZAJ:='P';
::      ZL.GENLIM:='N';
::      ZL.AUTGENZL:='N';
::      win_disp()
::   ?};
   ~~
|| _ok:=1
?};
_ok


\chk_pf_arch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy półfabrykaty przekazanej technologii używają archiwalnych kart
::   WE: _a - TKTL.ref
::       [_b] - INTEGER - 0/[1] - czy wyświetlać dialogi
::   WY: 0 - półfabrykaty nie używają archiwalnych kart
::       1 - półfabrykaty używają archiwalnych kart
::   OLD: \chk_pf_arch/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_result:=0;

TMAT.cntx_psh();
TMAT.index('ANL');
TMAT.prefix('T',_tktl);
_id_tktl:=exec('FindAndGet','#table',TKTL
                                    ,#_tktl
                                    ,ref_name(_tktl)
                                    ,"NRK+' wer. '+WER"
                                    ,'');

{? TMAT.first()
||
   {!
   |? {? TMAT.RKTL<>''
      ||
::       Sprawdzam czy karta jest archiwalna
         _tech_arch:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,"ARCH",'N');
         {? _tech_arch='T'
         || _result:=1
         ?}
      ?};
      TMAT.next() & _result=0
   !}
?};

{? _result=1
|| {? _dialog>0
   || FUN.emsg(
         'Półfabrykaty technologii: \'%1\' używają archiwalnych kart technologicznych\n'
         'i nie można utworzyć dla niej zlecenia z podzleceniami.'@[_id_tktl]
      )
   ?}
?};
TMAT.cntx_pop();
_result


\bl_autogen
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Wartość początkowa pola ZL.AUTGENZL
::  OLD: \bl_autogen/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
{? ZL.NRNZL=0 & ZL.RODZAJ<>'N'
|| _wyn:=ZL.TYP().AUTGENZL
|? ZL.NRNZL<>0
|| _wyn:=VAR.A_ZLNAD().AUTGENZL
|| _wyn:='N'
?};
ZL.cntx_pop();
_wyn


\pr_autogen
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Przed redakcją pola ZL.AUTGENZL
::  OLD: \pr_autogen/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_sprawdz:=params_get().args.sprawdz;
ZL.RODZAJ='Z' & ZL.TKTL=null() & _sprawdz


\zl_fld_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Przed wyświetlaniem pól w tabeli ZL: STARTD, STARTT, ENDD, ENDT
::  OLD: \zl_fld_bd/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
{? cur_afld()='STARTD'
||
   {? ZL.STARTD=date(0,0,0)
   || 1
   |? ZL.STARTD<date()
   || exec('flddisp','color','ZL#STARTD#01')
   || 1
   ?}
|? cur_afld()='STARTT'
||
   {? ZL.STARTD=date(0,0,0)
   || 1
   |? $ZL.STARTD+$ZL.STARTT < $date()+$time()
   || exec('flddisp','color','ZL#STARTT#01')
   || 1
   ?}
|? cur_afld()='ENDD'
||
   {? ZL.ENDD=date(0,0,0)
   || 1
   |? ZL.ENDD<date()
   || exec('flddisp','color','ZL#ENDD#01')
   || 1
   ?}
|? cur_afld()='ENDT'
||
   {? ZL.ENDD=date(0,0,0)
   || 1
   |? ZL.ENDD<date() | ZGP.ENDD=date() & ZGP.ENDT<time()
   || exec('flddisp','color','ZL#ENDT#01')
   || 1
   ?}
||
   1
?}


\zl_fld_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Przed redagowaniem pól w tabeli ZL: STARTD, STARTT, ENDD, ENDT
::       OPIS, DTR, PL_DATA, PL_TIME
::   WE: [_a] - STRING - akronim pola które badać, jeśli nie podane to cur_afld. Przydatne
::                       do sprawdzenia w różnych wątkach programu (np walidacja) redagowalność pól
::  OLD: \zl_fld_be/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_edit:=params_get().args.edit;

_a_fld:='';
{? var_pres('_a')=type_of('')
|| _a_fld:=_a
|| _a_fld:=cur_afld()
?};

:: Wyłączenie redagowania działa na wszystkie pola
{? ~_edit
|| 0

:: Dla tych pól zawsze redagowanie (o ile nie wyłączone)
|? _a_fld='OPIS' | _a_fld='PL_DATA' | _a_fld='PL_TIME'
|| 1

:: Jezeli w planie operacyjnym, to nieredagowalne
|? ZL.PLAN_PO='T'
|| 0

:: Jezeli w planie strategicznym, to nieredagowalne
|? ZL.PLAN_PX='T'
|| 0

:: Godziny redagowalne dla niezerowych dat
|| {? _a_fld='STARTT'
   || ZL.STARTD<>date(0,0,0)
   |? _a_fld='ENDT'
   || ZL.ENDD<>date(0,0,0)
   || 1
   ?}
?}


\zl_fld_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Po redagowaniu pól w tabeli ZL: STARTD, STARTT, ENDD, ENDT
::  OLD: \zl_fld_ae/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
{? cur_afld()='STARTD' & fld()=date(0,0,0)
|| ZL.STARTT:=time(0,0,0)
|? cur_afld()='ENDD' & fld()=date(0,0,0)
|| ZL.ENDT:=time(0,0,0)
?};

{? cur_afld()='STARTD' & ZL.STARTD<>date(0,0,0) & ZL.ENDD=date(0,0,0)
|| ZL.ENDD:=ZL.DTR
|? cur_afld()='STARTT' | cur_afld()='ENDT'
|| exec('valid_time','#field',fld())
|| 1
?}


\zl_fld_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Format wyświetlania pól w tabeli ZL: STARTD, STARTT, ENDD, ENDT, IL, IL0, ILWYK, ILDOK, ILPWYK, ILPDOK
::  OLD: \zl_fld_fd/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_empty:=
   {? (cur_afld()='STARTD' | cur_afld()='ENDD') & fld()=date(0,0,0)
   || 'empty=1'
   |? cur_afld()='STARTT' & ZL.STARTD=date(0,0,0) & fld()=time(0,0,0)
   || 'empty=1'
   |? cur_afld()='ENDT' & ZL.ENDD=date(0,0,0) & fld()=time(0,0,0)
   || 'empty=1'
   |? (cur_afld()='IL' | cur_afld()='IL0') & (ZL.TYP().WP='W' | ZL.RODZAJ='N')
   || 'empty=1'
   |? (cur_afld()='ILWYK' | cur_afld()='ILPWYK') & (ZL.TREE_TYP='Z' | ZL.TREE_TYP='N')
   || 'empty=1'
   |? (cur_afld()='ILDOK' | cur_afld()='ILPDOK') & (ZL.TREE_TYP='F' & ZL.RP='N')
   || 'empty=1'
   || 'empty=0'
   ?};
_out_prec:=
   {? cur_afld()='IL' | cur_afld()='IL0' |
      cur_afld()='ILWYK' | cur_afld()='ILDOK' | cur_afld()='ILPWYK' | cur_afld()='ILPDOK'
   || ',out_prec='+{? (2+cur_kwin())='e_' || $ZL.KTM().DOKL || $ST.DOKL_P ?}
   || ''
   ?};
_empty+_out_prec


\zl_fld_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Format redagowania pól w tabeli ZL: STARTD, STARTT, ENDD, ENDT
::  OLD: \zl_fld_fe/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
''


\genlimwp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Wartość początkowa pola ZL.GENLIM
::  OLD: \genlimwp/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:='P';
_wyn


\predglim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Przed redagowaniem ZL.GENLIM
::  OLD: \predglim/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_sprawdz:=params_get().args.sprawdz;
ZL.RODZAJ<>'P' & ZL.TKTL=null() & _sprawdz


\genprzpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Wartość początkowa pola ZL.GENPRZEW
::  OLD: \genprzpo/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:='P';
_wyn


\zl_pldir_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wartość początkowa pola ZL.PL_DIR
::  OLD: \zl_pldir_bl/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.TYP().PL_DIR


\zl_pldt_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wartosc początkowa pola ZL.PL_DATA
::  OLD:\zl_pldt_bl/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.A_UNRZL<>0
|| ZL.cntx_psh();
   _dt:=VAR.A_ZLNAD().PL_DATA;
   ZL.cntx_pop();
   _dt
|| date(0,0,0)
?}


\zl_pldt_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Po redakcji pola ZL.PL_DATA
::   WY: 0 / 1
::  OLD: \zl_pldt_ae/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
:: Dla zleceń podrzędnych dodatkowa kontrola przekroczenia terminu ze zlecenia nadrzednego
{? ZL.NRNZL<>0
|| ZL.cntx_psh();
   ZL.index('UNRZL');
   ZL.prefix(ZL.NRNZL);
   {? ZL.first() || _pl_data:=ZL.PL_DATA || _pl_data:=date(0,0,0) ?};
   ZL.cntx_pop();
   {? ZL.PL_DATA>_pl_data
   || FUN.emsg(
         'Wewnętrzny termin realizacji podzlecenia nie może być późniejszy niż dla zlecenia głównego (%1).\n'
         'Należy podać wcześniejszą datę.'@[$_pl_data]
      );
      return(0)
   ?}
?};
1


\zl_pltm_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Po redakcji pola ZL.PL_TIME
::   WY: 0 - godzina >=24:0:0
::       1 - godzina w przedziale <0:0:0 - 24:0:0)
::   OLD: \zl_pltm_ae/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
exec('valid_time','#field',fld())


\zl_pltm_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wartość początkowa pola ZL.PL_TIME
::   OLD: \zl_pltm_bl/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.A_UNRZL<>0
|| ZL.cntx_psh();
   _tm:=VAR.A_ZLNAD().PL_TIME;
   ZL.cntx_pop();
   _tm
|| time(0,0,0)
?}


\zl_dk_c_be
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Przed redakcją pola DK_C tabeli ZL
::  OLD: \zl_dk_c_bd/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
ATR.MJS:=2-!cur_tab(1,1);
ATR.FLAG_TEX:=0;

_mat:={? ATR.MJS<>'' || exec('acr2acr','mat_atr') || 'M' ?};

_result:=0;
_atr:=($(ATR.MJS+'.'+_mat+'().M_ATR'))();
{? _atr<>null()
 & {? exec('rozm_atr','mat_atr',_atr)=1 || ($(ATR.MJS+'.'+_mat+'().M_ATR().SL_01().TYP'))()<>'P' || 1 ?}
|| {? ZL.ILWYK>0 | ZL.STAN<>'N'
   || _result:=0
   || _result:=1
   ?};
   exec('dk_atr_dict','mat_atr')
?};
{? _result || _result:=ATR.FLAG_ED<>2 ?};
_result


\zl_dk_c_ae
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Po redakcji pola DK_C tabeli ZL
::  OLD: \zl_dk_c_ae/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
:: Wybrana cecha na zleceniu nie może mieć wypełnionej wartości typu 'Partia'
{? exec('dkc_has_part','mat_atr',ZL.DK_C)>0
|| FUN.emsg('Cecha zlecenia nie może posiadać wartości typu \'Partia\'.'@);
   _result:=0
?};
{? ATR.FLAG_ED<>2
|| {? ZL.DK_C<>null()
   || {! _i..10 |! ($('ATR.WAR'+form(_i,-2,0,'99')))():=($('ZL.DK_C().WAR'+form(_i,-2,0,'99')))() !}
   || {! _i..10 |! ($('ATR.WAR'+form(_i,-2,0,'99')))():='' !}
   ?}
?};
_result


\zl_mg_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Przed redakcją pola ZL.MG
::  OLD:\zl_mg_be/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_edit:=params_get().args.edit;
_edit


\zl_plforce_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wartość początkowa pola ZL.PL_FORCE
::  OLD: \zl_plfprce_bl/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.TYP().PL_FORCE


\zl_plforce_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed redagowaniem pola ZL.PL_FORCE
::  OLD:\zl_plforce_be/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.NRNZL=0


\zred_ktl_xx
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: wspólna treść
::  OLD: \zred_ktl_xx/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_T:=ZL.KTM;
::VAR.A_STAN:='T';
{? ZL.RKTL<>''
||
   TKTL.cntx_psh();
   TKTL.use(form(8+ZL.RKTL));
   TKTL.clear();
   {? TKTL.seek(ZL.RKTL)
   || VAR.ZRED_KTL:=TKTL.NRK;
      VAR.RED_WER:=TKTL.WER;
      VAR.SERIATCH:=TKTL.SERIA
   ?};
   TKTL.cntx_pop()
||
   VAR.ZRED_KTL:=ZL.KTL().NRK;
   VAR.RED_WER:=ZL.KTL().WER;
   VAR.SERIATCH:=ZL.KTL().SERIA
?};
~~


\zred_ktl_pw
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: przed wyświetl VAR.ZRED_KTL
::   WY: 0 / 1 / kolor
::  OLD: \zred_ktl_pw/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
exec('zred_ktl_xx','zl_head');
1


\zred_ktl_pr
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: przed redakcją VAR.ZRED_KTL
::  OLD: \zred_ktl_pr/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_edit:=params_get().args.edit;
_edit_tktl:={? var_pres('edit_tktl',params_get().args)>0 || params_get().args.edit_tktl || 1 ?};
{? ~_edit | ~_edit_tktl | ZL.RODZAJ='N' | ZL.KTM=null() | (ZL.SRCTECH='N' & ZL.TYP().TECH='T')
|| 0
|| exec('zred_ktl_xx','zl_head');
:: Czy do zlecenia są przewodniki
   _zgh:=0;
   ZGH.cntx_psh();
   ZGH.index('ZLNR');
   ZGH.prefix(ZL.ref());
   {? ZGH.first() || _zgh:=1 ?};
   ZGH.cntx_pop();
   ZL.TKTL=null() & _zgh=0 & {? ZL.SYM<>'' || exec('czy_red','zl_head') || 1 ?}=1
?}


\zred_ktl_f3
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: na F3 dla VAR.ZRED_KTL
::  OLD: \zred_ktl_f3/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
TKTLW.cntx_psh();
TKTLW.win_sel('WER_P');
TKTLW.index('KSN');
TKTLW.prefix();
::TKTLW.prefix('T',ZL.KTM,'T','N');
TKTLW.f_set(,'join TKTL using (TKTLW.TKTL,TKTL.REFERENCE)'
            ,'
            TKTL.TORW=\'T\'
            and TKTLW.KTM=:_a
            and TKTL.STAN=\'T\'
            and TKTL.ARCH=\'N\'
            and ((TKTL.TERM_OD<=to_date(:_b) and TKTL.TERM_OD IS NOT NULL)
            or TKTL.TERM_OD IS NULL)
            and ((TKTL.TERM_DO>=to_date(:_b) and TKTL.TERM_DO IS NOT NULL)
            or TKTL.TERM_DO IS NULL)
            '
            ,ZL.KTM,date());
{? TKTLW.f_first()
||
   TKTLW.f_find('T',ZL.KTM,'T','N',VAR.ZRED_KTL,VAR.RED_WER);
   {? TKTLW.select(,1,10)
   || ZL.KTL:=TKTLW.TKTL;
      ZL.RKTL:=$ZL.KTL;
      VAR.ZRED_KTL:=TKTLW.TKTL().NRK;
      VAR.RED_WER:=TKTL.WER;
      ZL.GKTL:=TKTL.GKTL
   ?}
||
   FUN.info('Wskazany produkt nie ma technologii.'@)
?};
TKTLW.f_clear();
TKTLW.cntx_pop();
VAR.ZRED_KTL
::TKTLW.win_sel('WER_P');
::TKTLW.index('KSN');
::TKTLW.prefix('T',ZL.KTM,'T','N');
::{? TKTLW.first()
::||
::   TKTLW.find_key(VAR.ZRED_KTL,VAR.RED_WER);
::   {? TKTLW.select(,1,10)
::   || ZL.KTL:=TKTLW.TKTL;
::      ZL.RKTL:=$ZL.KTL;
::      VAR.ZRED_KTL:=TKTLW.TKTL().NRK;
::      VAR.RED_WER:=TKTL.WER
::   ?}
::||
::   FUN.info('Wskazany produkt nie ma technologii.'@)
::?};
::VAR.ZRED_KTL


\zred_ktl_po
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: po redakcji VAR.ZRED_KTL
::   WE: [_a] - miejsce wywołania: [1] - po redagowaniu pola w oknie
::                                  0 - przed wyświetleniem okna redagowania, po wcześniejszym ustaleniu wartości pola
::  OLD: \zred_ktl_po/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_czy_ae:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_tktl:=ZL.KTL().NRK;
_improve:=TKTL.IMPROVE;
_ret:=1;

TKTLW.cntx_psh();
::{? chk_fld(1)
::|| TKTLW.index('KSN');
::   TKTLW.prefix('T',ZL.KTM,'T','N',VAR.ZRED_KTL,VAR.RED_WER);
::   {? TKTLW.first()
::   || _ret:=1
::   || _wyb:=choice('Brak pozycji w słowniku.'@,FUN.TYT,'EXCLAM',1,0,,'Powtórzenie'@,'Rezygnacja'@);
::      {? _wyb=1 || VAR.ZRED_KTL:=_tktl; VAR.SERIATCH:=ZL.KTL().SERIA ?};
::      _ret:=0
::   ?}
::|| _ret:=exec('valid_tech','zl_head')
::?};

{? (_czy_ae=0 & ZL.KTL<>null()) | (_czy_ae>0 & chk_fld(1))
|| TKTLW.index('KSN');
   TKTLW.clear;
   TKTLW.f_set(,'join TKTL using (TKTLW.TKTL,TKTL.REFERENCE)'
            ,'
            TKTL.TORW=\'T\'
            and TKTLW.KTM=:_a
            and TKTL.STAN=\'T\'
            and TKTL.ARCH=\'N\'
            and TKTL.NRK=\':_c\'
            and TKTL.WER=\':_d\'
            and ((TKTL.TERM_OD<=to_date(:_b) and TKTL.TERM_OD IS NOT NULL)
            or TKTL.TERM_OD IS NULL)
            and ((TKTL.TERM_DO>=to_date(:_b) and TKTL.TERM_DO IS NOT NULL)
            or TKTL.TERM_DO IS NULL)
            '
            ,ZL.KTM,date(),VAR.ZRED_KTL,VAR.RED_WER);
   {? TKTLW.f_first()
   || _ret:=1
   || {? _czy_ae>0
      || _wyb:=choice('Brak pozycji w słowniku.'@,FUN.TYT,'EXCLAM',1,0,,'Powtórzenie'@,'Rezygnacja'@)
      || _wyb:=1
      ?};
      {? _wyb=1
      || VAR.ZRED_KTL:=_tktl;
         VAR.SERIATCH:=ZL.KTL().SERIA
      ?};
      _ret:=0
   ?}
|| _ret:=exec('valid_tech','zl_head',_czy_ae>0)
?};
TKTLW.f_clear();
TKTLW.cntx_pop();
{? _ret>0 || ZL.IMPROVE:=_improve ?};
{? _czy_ae>0
|| win_disp()
?};
_ret


\valid_tech
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza wypełnienie pola 'Technologia' gdy jest puste, ewentualnie przestawia flagę ZL.SRCTECH
::       Kontekst wywołania - po redakcji pola VAR.ZRED_KTL albo podczas walidacji rekordu ZL
::   WE: [_a] - czy wyświetlać dialogi: [1]/0
::   WY: 1 - ok, 0 - powrót do redagowania pola
::----------------------------------------------------------------------------------------------------------------------
_dialog:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_result:=1;

{? ZL.TYP().TECH='T'
|| TKTLW.index('KSN');
   TKTLW.prefix('T',ZL.KTM,'T','N');

   _ask:=1;
   {? _dialog>0 & ZL.RODZAJ='P' & TKTLW.size()>0
   || _ask:=FUN.ask('Czy chcesz pozostawić pole ''Technologia'' niewypełnione?'@)
   ?};

   {? _ask>0
   || {? ZL.RODZAJ<>'P'
      || {? _dialog>0
         || FUN.info('Należy wypełnić pole ''Technologia''.'@)
         ?};
         ZL.SRCTECH:='T';
         _result:=0
      || ZL.SRCTECH:='N'
      ?}
   || ZL.SRCTECH:='T';
      _result:=0
   ?};
   {? ZL.SRCTECH='N'
   || VAR.ZRED_KTL:='';
      VAR.RED_WER:='';
      ZL.KTL:=null();
      ZL.RKTL:='';
      ZL.GKTL:=null()
   ?}

|| VAR.ZRED_KTL:='';
   VAR.RED_WER:='';
   ZL.KTL:=null();
   ZL.RKTL:='';
   ZL.GKTL:=null()
?};
_result


\zl_trig_add_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Trigger przed add dla tabeli ZL
::  OLD: \ZL/trigger.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZL.KTL<>null()
|| ZL.RKTL:=$ZL.KTL
?};
{? ZL.TKTL<>null()
|| ZL.RTKTL:=$ZL.TKTL
?};
{? ZL.RKTL<>'' | ZL.RTKTL<>''
|| ZL.GKTL:=exec('FindAndGet','#table',TKTL,{? ZL.RTKTL<>'' || ZL.RTKTL || ZL.RKTL ?},,"GKTL",null())
|| ZL.GKTL:=null()
?};
{? ZL.TYP().WP='P'
|| ZL.MGR:=ZL.KTM().MGR;
   ZL.R:=ZL.KTM().R
?};
ZL.ROK_MAX:=ZL.OD~1;
ZL.UNRZL:=exec('bl_zlunr','zl_head');
{? ZL.UNRZL
|| 1
|| undo('Nie udało się nadać zleceniu unikalnego numeru'@);
   0
?}


\zl_trig_put_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Trigger przed put dla tabeli ZL
::  OLD: \ZL/trigger.fml
::----------------------------------------------------------------------------------------------------------------------
_brktl:=ZL.RKTL;
_brtktl:=ZL.RTKTL;
{? ZL.KTL<>null()
|| ZL.RKTL:=$ZL.KTL
?};
{? ZL.TKTL<>null()
|| ZL.RTKTL:=$ZL.TKTL
?};
:: Przypisanie grupy kart technologicznych
{? ZL.RKTL='' & ZL.RKTL=''
|| ZL.GKTL:=null()
|? ZL.RKTL<>_brktl | ZL.RTKTL<>_brtktl
|| ZL.GKTL:=exec('FindAndGet','#table',TKTL,{? ZL.RTKTL<>'' || ZL.RTKTL || ZL.RKTL ?},,"GKTL",null())
?};
{? ZL.TYP().WP='P'
|| ZL.MGR:=ZL.KTM().MGR;
   ZL.R:=ZL.KTM().R;
   ZL.ILPWYK:={? ZL.TREE_TYP='Z' | ZL.TREE_TYP='N' || 0 || ZL.IL-ZL.ILWYK ?}; {? ZL.ILPWYK<0 || ZL.ILPWYK:=0 ?};
   ZL.ILPDOK:={? ZL.TREE_TYP='F' & ZL.RP='N' || 0 || ZL.IL-ZL.ILDOK ?}; {? ZL.ILPDOK<0 || ZL.ILPDOK:=0 ?}
?};
:: Ustalenie znacznika STAT_T dla zleceń złożonych
{? ZL.RODZAJ='Z' | ZL.RODZAJ='N'
|| ZL.STAT_T:=ZL.STAT_N
?};
1


\zl_trig_put_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Trigger po put dla tabeli ZL
::  OLD: \ZL/trigger.fml
::----------------------------------------------------------------------------------------------------------------------
:: Generowanie przewodnika technicznego, gdy wymagany
{? ZL.RODZAJ='P'
   & bfld('STAT_N')='N'
   & ZL.STAT_N='T'
   & ZL.TYP().TECH='N'
   & exec('FindAndGet','#table',TKTL,ZL.RKTL,,"TYP().OPER",'T')='N'
   |
   ZL.RODZAJ='P'
   & bfld('STAT_T')='N'
   & ZL.STAT_T='T'
   & ZL.TYP().TECH='T'
   & exec('FindAndGet','#table',TKTL,ZL.RTKTL,,"TYP().OPER",'T')='N'
|| exec('gen_tech_guid','zl_guide',ZL.ref())
?};
:: Ustalenie statusów pozycji przewodników
exec('update_zgp','zl_guide','put',ZL);
:: Aktualizacja kontrahenta na przewodnikach
{? bfld('KH')<>ZL.KH
|| ZGH.cntx_psh();
   ZGH.index('ZLNR');
   ZGH.prefix(ZL.ref());
   {? ZGH.first()
   || {!
      |?
         ZGH.KH:=ZL.KH;
         ZGH.put();
         ZGH.next()
      !}
   ?};
   ZGH.cntx_pop()
?};
{? exec('get','#params',100704)='T'
   & (bfld('STAN')='Z' | ZL.STAN='Z') & bfld('STAN')<>ZL.STAN
||
   ZLIM.cntx_psh();
   exec('openmask','zl_common',ZL.ref());
   ZLIM.index('MAG');
   ZLIM.prefix(ZL.ref());
   _loop:=ZLIM.first();
   {!
   |? _loop
   |!
      _loop:=ZLIM.put() & ZLIM.next()
   !};
   ZLIM.cntx_pop()
?};
~~


\bl_zlunr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.53]
:: OPIS: "blank" pola ZL.UNRZL
::  OLD: \bl_zlunr/skid_zlc.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.tm_stamp()


\ztp_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wybór typu zlecenia - w formule exec('zl_dolacz','zl_head) oraz przy parmetryzacji czynności
::   WE: _a - 'W'arsztatowe, 'P'rodukcyjne (gdy nie podano - wszystkie)
::   WY: ZTP.ref() / null()
::----------------------------------------------------------------------------------------------------------------------
_wp:=_a;

_res:=null();

_typy:=exec('typy_zlecen','zl_head',_wp);

ZTP.f_set('TYP',,'ZTP.REFERENCE in (select :_a.REF from :_a)',_typy);
{? ZTP.f_size()=0
|| FUN.info({? _wp='W'
            || 'Brak dostępnych typów zleceń warsztatowych.'@
            |? _wp='P'
            || 'Brak dostępnych typów zleceń produkcyjnych.'@
            || 'Brak dostępnych typów zleceń.'@
            ?})
|? ZTP.f_size()=1
|| ZTP.f_first();
   _res:=ZTP.ref()
|| ZTP.win_sel('WER_SEL');
   ZTP.actions('WER_SEL',,'W');
   {? ZTP.select() || _res:=ZTP.ref() ?}
?};
_res


\zl_dkc_update
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Akcja wykonywana gdy na nagłówku zlecenia zmieni się atrybut - wyświetla ostrzeżenie o tym że być może należy
::       sobie ręcznie poprawić atrybuty na limitach
::   WE: _a - ZL.ref()
::       [_b] - bufor zlecenia który trzyma wartości atrybutów, jeśli nie podany to wypełniany na podstawie _a
::   WY: 0 - brak limitów które dziedziczyły cechę lub wartości zgodne ze zleceniem
::       1 - były takie limity które dziedziczyły cechę i wartości na limicie i zleceniu różne
::  OLD: \zl_dkc_update/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_buf_zl:=~~;
{? var_pres('_b')>100
|| _buf_zl:=_b
?};

{? var_pres('KOMM2')<100
|| KOMM2:=obj_new(@.CLASS.JCQ)
?};
KOMM2.init(250,,'Informacje dot. niezgodności dziedziczonych przez limity atrybutów'@,'');

_chk:=exec('zl_inherit_chk','zl_common',_zl,_buf_zl);

{? _chk>0
|| _msg0:='';
   _msg1:='Zmieniły się atrybuty zlecenia, które posiada limity dziedziczące atrybuty ze zlecenia.';
   _msg2:='Wartości atrybutów na zleceniu różnią się z wartościami na limitach zlecenia.';
   _msg3:='Wymagana jest korekta atrybutów zlecenia.';
   _msg_glued:=exec('form','#string','L',_msg1
                                        ,_msg2
                                        ,_msg0
                                        ,_msg3);
   _choice:=FUN.choice(_msg_glued,,'Szczegóły'@,,,,'OK'@);
   {? _choice=1
   || KOMM2.select()
   ?}
?};
obj_del(KOMM2);
_chk


\zl_poren
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2009]
:: OPIS: Po redakcji pola ilość na zleceniu w przygotowaniu nanosi ilość na pod/nad-zlecenia,
::       dodaje odpowiednie notatki do dziennika zlecenia.
::   WE: _a - REAL - stara ilość, przed poprawieniem
::       _b - M.ref - stary produkt zlecenia
::       _c - TKTL.ref - stara technologia zlecenia
::   WY: 0 / 1
::  OLD: \zl_poren/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
ZL.put();
_old_il:=_a;
_old_ktm:=_b;
_old_tktl:=_c;

_ktm:=ZL.KTM;
_ktl:=ZL.KTL;
_zl:=ZL.IL;
_proc:={? _old_il || _zl/_old_il || 0 ?};
_nad:=0;
_il:=0;
{? _old_il<>_zl | _old_ktm<>_ktm | _old_tktl<>_ktl
||
:: Złożone z podzleceniami od strony nadrzędnego - zmiana ilości na wszystkich podrzędnych wg proporcji
   {? ZL.RODZAJ='Z'
   || ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? {? ZL.NR=1
            || ZL.KTM:=_ktm;
               ZL.KTL:=_ktl;
               ZL.IL:=_zl;
               _can_continue:=ZL.put();
               {? _can_continue>0
               || exec('zl2obj','px_obj')
               ?}
            || ZL.IL:=exec('zaokr','jm',_proc*ZL.IL,ZL.KTM);
               _can_continue:=ZL.put();
               {? _can_continue>0
               || exec('zl2obj','px_obj')
               ?}
            ?};
            ZL.next()
         !}
      ?};
      ZL.cntx_pop()

:: Złożone z pozleceniami od strony podrzędnego
   |? ZL.RODZAJ='P' & ZL.NRNZL<>0 & exec('top_rodzaj','zl_link',ZL.ref())='Z'
   ||
::    Zlecenie montażowe
      {? ZL.NR=1
      ||
::       Zlecenie nadrzędne - naniesienie ilości, zmiana produktu i technologii
         _ktm:=ZL.KTM;
         _ktl:=ZL.KTL;
         ZL.cntx_psh();
         ZL.index('UNRZL');
         ZL.prefix(ZL.NRNZL);
         {? ZL.first()
         || ZL.KTM:=_ktm;
            ZL.KTL:=_ktl;
            ZL.IL:=_zl;
            _can_continue:=ZL.put();
            {? _can_continue>0
            || exec('zl2obj','px_obj')
            ?}
         ?};
::       Zlecenia podrzędne podrzędnych - zmiana wg proporcji
         ZL.index('NRNZL');
         ZL.prefix(ZL.UNRZL);
         {? ZL.first()
         || {!
            |? {? ZL.NR<>1
               || _il:=exec('zaokr','jm',_proc*ZL.IL,ZL.KTM);
                  ZL.IL:=_il;
                  _can_continue:=ZL.put();
                  {? _can_continue>0
                  || exec('zl2obj','px_obj')
                  ?}
               ?};
               ZL.next()
            !}
         ?};
         ZL.cntx_pop()

::    Pozostałe podzlecenia - zmiana tylko na podrzędnych do modyfikowanego wg proporcji
      |? ZL.NR<>1
      || ZL.cntx_psh();
         ZL.index('NRPZL');
         ZL.prefix(ZL.UNRZL);
         {? ZL.first()
         || {!
            |? _il:=exec('zaokr','jm',_proc*ZL.IL,ZL.KTM);
               ZL.IL:=_il;
               _can_continue:=ZL.put();
               {? _can_continue>0
               || exec('zl2obj','px_obj')
               ?};
               ZL.next()
            !}
         ?};
         ZL.cntx_pop()
      ?}
   ?}
?};
ZL.cntx_pop()


\nrnzl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Zwraca symbol zlecenia
::   WE: _a - ZL.UNRZL poszukiwanego zlecenia
::   WY: ZL.SYM znalezionego zlecenia, wpp. ''
::  OLD: \nrnzl/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
ZL.index('UNRZL');
ZL.prefix(_a);
{? ZL.first() || _res:=ZL.SYM || _res:='' ?};
ZL.cntx_pop();
_res


\zl_popraw_term
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Poprawienie zlecenia - tylko terminy
::   WE: [_a] - ZL.ref() lub bieżący rekord
::  OLD: \zl_popraw_term/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| VAR.A_ZLNAD:=ZL.ref();
   ZL.cntx_psh();
   ZL.index('UNRZL');
   ZL.prefix(ZL.NRNZL);
   {? ZL.first()
   || VAR.A_ZLNAD:=ZL.ref()
   ?};
   ZL.cntx_pop();

   {? exec('zl_lock','zl_common',,'N')
   || _buffer:=exec('buffer','zl_head'); _buffer.get();
      _args:=obj_new('buffer','sprawdz','edit'); _args.buffer:=_buffer; _args.sprawdz:=1; _args.edit:=1;
      params_set('args',_args);

      ZL.win_edit('TERMINY');
      {? ZL.edit("exec('zl_valid_term','zl_head')")
      || {? ZL.put()
         || exec('zl2obj','px_obj',ZL.ref());
            exec('akt_terminy','zl_common',_buffer,1);
            exec('akt_plany','zl_common',_buffer.STARTD,_buffer.STARTT,_buffer.ENDD,_buffer.ENDT,1);
            exec('akt_znaczniki','zl_common',_buffer.PL_FORCE,_buffer.PL_DIR);

            GROPP.cntx_psh();
            GROPP.index('ZL');
            GROPP.prefix(ZL.ref());
            {? GROPP.first()
            || {!
               |? exec('termin_update','zl_grop',GROPP.GROP);
                  GROPP.next()
               !}
            ?};
            GROPP.cntx_pop();
            ~~
         ?}
      ?};
      exec('zl_unlock','zl_common',,'N')
   ?}
?};
ZL.cntx_pop();
~~


\zl_valid_term
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Walidacja okna z terminami zlecenia
::  OLD: \zl_valid_term/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=exec('pl_force_chk','px_utils','ZL')
;
_wyn


\ztp_export
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuła eksportująca wartość parametru ZTP dla czynności
::   WE: _a - ZTP.ref() - wartość parametru
::   WY: STRING - treść formuły która się wykona po stronie importu
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ztp:=_a;

_fml:='';

ZTP.cntx_psh();
ZTP.clear();
{? ZTP.seek(_ztp)
||
   _fml:=exec('formulizer_common','#b_export');
   _fml+='
      ZTP.cntx_psh();
      ZTP.index(\'TP\');
      ZTP.prefix(\''+ZTP.TYP+'\',);
      {? ZTP.first()
      || _result.REF:=ZTP.ref();
         _result.RESULT:=1
      || _result.RESULT:=0;
         _result.REF:=null();
         {? _komm>0
         ||
            _msg:=\'Nie znaleziono typu zlecenia o symbolu: %1\'@[\''+ZTP.TYP+'\'];
            exec(\'import_komm\',\'#b_export\',_msg)
         ?}
      ?};
      ZTP.cntx_pop();
      _result
   ';
   _fml:=exec('formulizer_clean','#b_export',_fml)
?};
ZTP.cntx_pop();
_fml


\set_rodz_tex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Ustawienie wartości w polu ZL.RODZ_TEX w zależności od rodzaju zlecenia i parametru
::  OLD: \set_rodz_tex/zl.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.RODZ_TEX:=exec('get_rodz_tex','px_tex')


\uprDelZatwZl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.46]
:: OPIS: Sprawdzenie uprawnienia do usuwania zatwierdzonych zleceń
::  OLD: \uprDelZatwZl/zlec6.fml
::----------------------------------------------------------------------------------------------------------------------
exec('get','#params',8902,2,OPERATOR.USER)='T'


\chk_ktm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza, czy indeks produktu wykorzystany jest w zleceniach wyższego poziomu
::   WE: _a - #ZL.ref()
::       _b - M.ref()
::   WY: 1 - indeks jest wykorzystany, 0 - indeks nie jest wykorzystany
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_material:=_b;

_result:=0;

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl,)
|| {? ZL.KTM=_material
   || _result:=1
   || {? ZL.TREE<>0
      || _result:=exec('chk_ktm','zl_head',ZL.TREE,_material)
      ?}
   ?}
?};
ZL.cntx_pop();
_result


\wp_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.28]
:: OPIS: Wybór: zlecenie warsztatowe czy produkcyjne (np. do parametrów czynności)
::----------------------------------------------------------------------------------------------------------------------
_choice:=FUN.choice('Wybierz zakres zleceń'@,2,'Warsztatowe'@,'Produkcyjne'@);
_wp:={? _choice=1
     || 'W'
     |? _choice=2
     || 'P'
     || ~~
     ?};
_wp


\stan_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.28]
:: OPIS: Wybór stanu zlecenia (np. do parametrów czynności)
::----------------------------------------------------------------------------------------------------------------------
_choice:=FUN.choice('Wybierz stan zleceń'@,2,'W przygotowaniu'@,'Otwarte'@,'Zamknięte'@);
_stan:={? _choice=1
       || 'N'
       |? _choice=2
       || 'O'
       |? _choice=3
       || 'Z'
       || ~~
       ?};
_stan


\add_selected_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.28]
:: OPIS: Dodanie zlecenia do tabeli refów (wybór zleceń w czynnościach - w szczególności dla akcji grupowej)
::----------------------------------------------------------------------------------------------------------------------
_ref_table:=params_get().ref_table;
_ref_table.add(ZL.ref());
~~


\zl_idksg_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.28]
:: OPIS: Blankowanie pola ZL.ID_KSG (identyfikator księgowy)
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
ZL.cntx_psh();
ZL.index('ID_KSG');
{? ZL.last()
|| _result:=ZL.ID_KSG+1
|| _result:=1
?};
ZL.cntx_pop();
_result


\valid_modify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.28]
:: OPIS: Walidacja przy poprawianiu nagłówka zlecenia
::   WE: _a - 'W'arsztatowe/'P'rodukcyjne
::       _b - czy uruchomiona w procesie
::       _c - czy sprawdzać warunki dotyczących korekty powiązanego limitu - [0]/1
::       [_d] - INTEGER - [0]/1 - czy uruchamiane podczas podziału zlecenia
::   WY: '' albo akronim pola, do którego powrocić
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_wp:=_a;
_proces:=_b;
_czy_kor:={? var_press('_c')=type_of(0) || _c || 0 ?};
_split:={? var_press('_d')=type_of(0) || _d || 0 ?};
_result:='';
{? _wp='P'
||
   _buffer:=params_get().args.buffer;

   {? _result='' & ZL.NR=0
   || {? exec('wol_nr','numery','ZL')>0
      || FUN.info('Numer zlecenia musi być wypełniony.'@);
         _result:='NR'
      ?}
   ?};

:: Sprawdzenie produktu w zleceniach nadrzędnych
   {? _result='' & _buffer.KTM<>ZL.KTM & ZL.TREE<>0 & ZL.KTM<>null()
   || {? exec('chk_ktm','zl_head',ZL.TREE,ZL.KTM)>0
      || FUN.info('Indeks produktu jest wykorzystany w zleceniu wyższego poziomu.'@);
         _result:='KTM'
      ?}
   ?};

   {? _result='' & (ZL.RODZAJ='P' & ZL.TYP().TECH='N' | ZL.RODZAJ='Z') & VAR.ZRED_KTL=''
   || TKTLW.index('KSN');
      TKTLW.prefix('T',ZL.KTM,'T','N');
      {? TKTLW.first()
      || FUN.info('Należy wypełnić pole \'\'Technologia\'\'.'@);
         _result:='ZRED_KTL'
      || FUN.info('Należy zmienić produkt.'@);
         _result:='KTM'
      ?}
   ?};

   {? _result='' & _split=0 & ZL.RODZAJ='P' & VAR.ZRED_KTL='' & ZL.SRCTECH='T'
   || _result:={? exec('valid_tech','zl_head') || '' || 'ZRED_KTL' ?}
   ?};

   {? _proces
   || {? _result='' & ZL.DTR<>date(0,0,0) & ZL.DTR<date() & exec('zl_fld_be','zl_head','DTR')>0
      || FUN.info('Termin realizacji zlecenia %1 nie może być wcześniejszy od daty dzisiejszej.'@[ZL.SYM]);
         _result:='DTR'
      ?}
   ?};

   {? ZL.PL_DATA=date(0,0,0) || ZL.PL_DATA:=ZL.DTR ?};
   {? _result='' & ZL.PL_DATA>ZL.DTR & exec('zl_fld_be','zl_head','PL_DATA')>0
   || FUN.info(
         'Wewnętrzny termin realizacji nie może być późniejszy niż planowany termin realizacji zlecenia.\n'
         'Należy podać wcześniejszą datę.'@
      );
      _result:='PL_DATA'
   ?};

   {? _result=''
   || {? _buffer.IL>ZL.IL & exec('zl_il_zam','zl_gen',ZL.ref())>0
      ||
::       Ostrzeżenie przed zmniejszeniem ilości na zleceniu wygenerowanym z zamówienia
         {? FUN.ask(
               'Zlecenie %1 zostało wygenerowane z pozycji zamówienia.\n\n'
               'Zmniejszenie ilości może spowodować,\n'
               'że zamówienie nie zostanie w całości zrealizowane.\n\nCzy kontynuować?'@[ZL.SYM]
            )=0
         || _result:='IL'
         ?}
      ?}
   ?};

   {? _result=''
   || {? _buffer.IL>ZL.IL & exec('chk_zl','zl_grop',ZL.ref())>0
      ||
::       Ostrzeżenie przed zmniejszeniem ilości na zleceniu użytym w grupach operacji
         {? FUN.ask(
               'Operacje zlecenia %1 zostały wykorzystane w grupach operacji.\n\n'
               'Zmniejszenie ilości może spowodować,\n'
               'że grupy zostaną nieprawidłowo skonfigurowane.\n\nCzy kontynuować?'@[ZL.SYM]
            )=0
         || _result:='IL'
         ?}
      ?}
   ?};

   {? _result=''
   ||
::    Blokada zmniejszania ilości jeżeli zlecenie jest w planie operacyjnym
      {? _buffer.IL>ZL.IL
      ||
         {? ZL.RODZAJ='Z'
         ||
::          Zlecenie złożone - sprawdzam podzlecenia
            ZL.cntx_psh();
            ZL.clear();
            ZL.index('NRNZL');
            ZL.prefix(ZL.UNRZL);
            {? ZL.first()
            || {!
               |?
                  {? exec('zlec_planned','po_plan',$ZL.ref())
                  || _msg:='Jedno ze zleceń podrzędnych zlecenia %1 znajduje się w Planie operacyjnym.'
                           '\nAby zmniejszyć ilość należy usunąć to zlecenie z planu.'@[ZL.SYM];
                     FUN.emsg(_msg);
                     _result:='IL'
                  ?};
                  _result='' & ZL.next()
               !}
            ?};
            ZL.cntx_pop()
         |? ZL.RODZAJ='P'
         ||
            {? exec('zlec_planned','po_plan',$ZL.ref())
            || _msg:='Zlecenie %1 znajduje się w Planie operacyjnym.'
                     '\nAby zmniejszyć ilość należy usunąć zlecenie z planu.'@[ZL.SYM];
               FUN.emsg(_msg);
               _result:='IL'
            ?}
         ?}
      ?}
   ?};

   {? _result=''
   ||
::    Blokada zmniejszania ilości poniżej ilości w planie strategicznym
      {? _buffer.IL>ZL.IL
      ||
         {? ZL.RODZAJ='Z'
         || _il_nad:=ZL.IL;
::          Zlecenie zlożone - sprawdzam podzlecenia
            ZL.cntx_psh();
            ZL.clear();
            ZL.index('NRNZL');
            ZL.prefix(ZL.UNRZL);
            {? ZL.first()
            || {!
               |?
                  _proporcja:=ZL.IL/_buffer.IL;
                  _il_prop:=_il_nad*_proporcja;
                  {? exec('zl_utilization','px_plan',ZL.ref())>0
                  || _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
                     {? _px_obj<>null()
                     || _mainver:=exec('get_mainversion','px_ver');
                        _il_queued:=exec('get_ilosc_que','px_obj',_mainver,_px_obj);

                        {? _il_queued>_il_prop
                        || _msg:='Jedno ze zleceń podrzędnych zlecenia %1 znajduje się w Planie strategicznym.'
                                 '\nAby zmniejszyć ilość poniżej %2, należy usunąć zlecenie z planu.'@
                                 [ZL.SYM,$_il_queued];
                           FUN.emsg(_msg);
                           _result:='IL'
                        ?}
                     ?}
                  ?};
                  _result='' & ZL.next()
               !}
            ?};
            ZL.cntx_pop()
         |? ZL.RODZAJ='P'
         ||
            {? exec('zl_utilization','px_plan',ZL.ref())>0
            || _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
               {? _px_obj<>null()
               || _mainver:=exec('get_mainversion','px_ver');
                  _il_queued:=exec('get_ilosc_que','px_obj',_mainver,_px_obj);

                  {? _il_queued>ZL.IL
                  || _msg:='Zlecenie %1 znajduje się w Planie strategicznym.'
                           '\nAby zmniejszyć ilość poniżej %2, należy usunąć zlecenie z planu.'@
                           [ZL.SYM,$_il_queued];
                     FUN.emsg(_msg);
                     _result:='IL'
                  ?}
               ?}
            ?}
         ?}
      ?}
   ?};

   {? _result=''
   ||
::    Blokada zmniejszenia ilości jeżeli partie powiązane z dokumentami
      {? _buffer.IL>ZL.IL
      ||
         _zl_to_chk:=ZL.ref();
         {? ZL.RODZAJ='Z'
         ||
::          Zlecenie zlożone - sprawdzam partie na zleceniu montażowym
            _zl_to_chk:=exec('main_podzlec','zl_link',ZL.ref())
         ?};
         {? _zl_to_chk<>null()
         ||
            ZL.cntx_psh(); ZL.prefix();
            {? ZL.seek(_zl_to_chk)
            || _il_part:=exec('zl_ile_part','zl_partie',ZL.ref());
               {? _il_part>0
               || _il_part_free:=exec('zl_ile_part_free','zl_partie',ZL.ref());
                  _il_part_zaj:=(_il_part-_il_part_free);
                  {? ZL.IL<_il_part_zaj
                  || _msg:='Zlecenie %1 posiada partie powiązane z dokumentami.'
                           '\nNie można zmniejszyć ilości poniżej: %2.'@[ZL.SYM,$_il_part_zaj];
                     FUN.emsg(_msg);
                     _result:='IL'
                  ?}
               ?}
            ?};
            ZL.cntx_pop()
         ?}
      ?};
      ~~
   ?};

   {? _result=''
   || _result:={? ZL.RODZAJ='N'
               || __CHK.record2(ZL,'TYP',,'MG',,'PWYD',,'OPIS',)
               || __CHK.record2(ZL,'TYP',,'MG',,'PWYD',,'KTM',,'IL','Ilość','OPIS',)
               ?}
   ?};

:: Sprawdzam czy magazyn jest z tego samego oddziału co zlecenie
   {? _result='' & ZL.MG().ODDZ<>ZL.ODDZ
   || FUN.emsg('Magazyn przypisany do zlecenia %1 musi być powiązany z tym samym oddziałem co zlecenie.'@[ZL.SYM]);
      _result:='MG'
   ?};

:: Sprawdzam czy magazyn kooperacyjny
   {? _result='' & ZL.MG().KOOP='T'
   || FUN.emsg('Magazyn przypisany do zlecenia %1 nie może służyć do rejestracji kooperacji.'@[ZL.SYM]);
      _result:='MG'
   ?};

:: Sprawdzam dokumenty dostępne w magazynie
   {? _result='' & exec('chk_mg4zl','zl_common',ZL.MG)=0
   || FUN.emsg(
         'Magazyn przypisany do zlecenia %1 powinien mieć przypisany przynajmniej jeden typ dokumentu\n'
         'określony parametrem %2 %3.'@[ZL.SYM,'500701',exec('name','#params',500701,'A')]
      );
      _result:='MG'
   ?};

:: Sprawdzam czy magazyn zlecenia jest zgodny z cechą zlecenia
   {? _result='' & ZL.DK_C<>null()
   || {? ~(ZL.MG().TYP*'DOST')
      || FUN.emsg('Zlecenie ma wypełnioną cechę. '
                  'Magazyn przypisany do zlecenia musi być typu: \'\'%1\'\' lub \'\'%2\'\'.'@['DOSTAWY','DOSTEWI']);
         _result:='MG'
      ?}
   ?};

:: Sprawdzam czy magazyn zlecenia jest zgodny z partiowalnością wyrobu zlecenia
   {? _result='' & exec('material_party','material',ZL.KTM)>0
   || {? ~(ZL.MG().TYP*'DOST')
      || FUN.emsg('Produkt zlecenia jest partiowany. '
                  'Magazyn przypisany do zlecenia musi być typu: \'\'%1\'\' lub \'\'%2\'\'.'@['DOSTAWY','DOSTEWI']);
         _result:='MG'
      ?}
   ?};

:: Dołączenie cechy dostawy
   {? _result='' & (1+ZL.MG().TYP)='D' & ATR.FLAG_ED & ATR.FLAG<>1
   || exec('akcepatr','mat_atr',0,1)
   ?};

:: Sprawdzanie poprawności zwrotu planowania i znacznika kontynuacji po przekroczeniu
   {? _result=''
   || _result:=exec('pl_force_chk','px_utils','ZL')
   ?};

:: Projekty
   {? _result='' & ZL.PROJEKTY<>null()
   || _result:=exec('tabdok_chk','projekty',ZL)
   ?};

:: Porównuje wartości cechy po poprawieniu
   _dkc_after:=exec('buffer','mat_atr');
   {? ZL.DK_C<>null()
   || DK_C.cntx_psh();
      DK_C.clear();
      {? DK_C.seek(ZL.DK_C)
      || _dkc_after.get_dkc()
      ?};
      DK_C.cntx_pop()
   ?};
   {? DKC_BEF.compare(_dkc_after)<>1
   ||
      _zl_top:=ZL.ref();
      _main_podzlec:=exec('main_podzlec','zl_link',ZL.ref());
      {? ZL.ref()=_main_podzlec
      || _zl_top:=exec('top_level','zl_link',ZL.ref())
      ?};
::    Sprawdzam czy limity dziedziczyły atrybut i wyświetlam ostrzeżenie
      {? exec('zl_dkc_update','zl_head',_zl_top,_dkc_after)>0
      || {? ZL.KTM().M_ATR().EDIT
         ||
::          Redakcja bezposrednia - wracam do pierwszego redagowalnego pola
            _red_field:=exec('chk_red_field','mat_atr');
            {? _red_field<>''
            || _result:=5-_red_field
            || _result:='DK_C'
            ?}
         ||
::          Redakcja niebezposrednia - wracam do cechy
            _result:='DK_C'
         ?}
      ?}
   ?};

:: Identyfikator księgowy
   {? _result='' & ZL.ID_KSG<>0
   || ZL.cntx_psh();
      ZL.index('ID_KSG');
      ZL.prefix(ZL.ID_KSG);
      _idadd:=ZL.IDADD;
      {? ZL.first() & _idadd<>ZL.IDADD
      || FUN.emsg('Istnieje zlecenie o identyfikatorze księgowym: %1.'@[$ZL.ID_KSG]);
         _result:='ID_KSG'
      ?};
      ZL.cntx_pop()
   ?};
   {? _result='' & _buffer.IL<>ZL.IL
   ||
::    sprawdzamy czy są jakieś niezatwierdzone limity lub korekty
      ZLIM.cntx_psh();
      ZLIM.index('ZKN');
      ZLIM.prefix(VAR.A_ZLEC,'T');
      {? ZLIM.first()
      || {!
         |? {? ZLIM.AKC='N'
            || FUN.info(
                  'Istnieją niezaakceptowane limity lub korekty.\nNie jest możliwa zmiana ilości na zleceniu %1.'@
                  [ZL.SYM]
               );
               _result:='IL'
            ?};
            ZLIM.next() & _result=''
         !}
      ?};
      ZLIM.cntx_pop()
   ?};

   _top:=exec('top_level','zl_link',VAR.A_ZLEC);

   {? _result='' & _buffer.IL>ZL.IL
   ||
::    sprawdzamy, czy są oddane przewodniki
      ZGH.index('ZLNR');
      ZGH.prefix(_top);
      {? ZGH.first()
      || {!
         |? {? ZGH.STAN='T'
            || FUN.info('Istnieją oddane przewodniki.\nNie jest możliwe zmniejszenie ilości na zleceniu %1.'@[ZL.SYM]);
               _result:='IL'
            ?};
            ZGH.next() & _result=''
         !}
      ?}
   ?};
   {? _result='' & _buffer.IL<>ZL.IL
   || {? exec('has_closed','zl_link')>0
      || FUN.info(
            'Redagowane zlecenie %1, lub któreś z jego podzleceń jest zamknięte. Redakcja ilości niemożliwa.'@
            [ZL.SYM]
         );
         _result:='IL'
      ?}
   ?};

   {? _result='' & _buffer.IL>ZL.IL
   ||
      ZL.cntx_psh();
      ZL.clear();
      {? ZL.seek(_top)
      || ZL.index('NRNZL');
         ZL.prefix(ZL.UNRZL);
         {? ZL.first()
         || ZGH.cntx_psh();
            ZGH.index('ZLNR');
            {!
            |?
               ZGH.prefix(ZL.ref());
               {? ZGH.first()
               || {!
                  |? {? ZGH.STAN='T'
                     || FUN.info(
                           'Istnieją oddane przewodniki.\nNie jest możliwe zmniejszenie ilości na zleceniu %1.'@[ZL.SYM]
                        );
                        _result:='IL'
                     ?};
                     ZGH.next() & _result=''
                  !}
               ?};
               ZL.next() & _result=''
            !};
            ZGH.cntx_pop()
         ?}
      ?};
      ZL.cntx_pop()
   ?};

   {? _result=''
   || {? ZL.STARTD>ZL.ENDD & ZL.ENDD<>date(0,0,0) | ZL.STARTD=ZL.ENDD & ZL.STARTT>ZL.ENDT & exec('zl_fld_be','zl_head','STARTD')>0
      || FUN.info('Data rozpoczęcia zlecenia %1 musi być wcześniejsza od daty zakończenia.'@[ZL.SYM]);
         _result:='STARTD'
      ?}
   ?};

:: Sprawy związane ze zmianą ilości
   {? _result='' & ZL.IL<>_buffer.IL
   ||
      _ok:=1;
      _star_il:=_buffer.IL;
      ZL.cntx_psh();
      _il:=exec('spr_ilosc','zl_guide',_star_il);
      _ilk:=exec('spr_ilosc','zl_guide',_star_il,1);
      _ilw:=exec('spr_ilwyk','zl_guide',_star_il);
::      _ilr:=exec('spr_ilrea','zl_limit',_star_il);
      ZL.cntx_pop();
      {? _star_il<ZL.IL
      ||
::       Zwiększenie serii
         {? _il>ZL.IL
         ||
::          Przypadek gdy było już zarejetrowane więcej robocizny niż zwiększyłem ilości na zleceniu
            _msg:='Zwiększenie serii z %1 do %2 jest możliwe.\n\nAkord został już zarejestrowany dla %3'
                  '\% produktu.\nSugerowana minimalna ilość jaką można wpisać to: %4'
                  '\n\nCzy pozostawiasz ilość: %2?'@[form(_star_il),$ZL.IL,form(_il/_star_il*100,,2),form(_il)];

            _choice:=FUN.choice(_msg,,'Pozostaw: %1'@[$ZL.IL],'Zmień na: %1'@[form(_il)]);
            {? _choice=1
            ||
::             Zostawiam taką ilość jaka była w oknie, nic się nie dzieje
               ~~
            |? _choice=2
            ||
::             Wpisuję ilość sugerowaną w komunikacie
               ZL.IL:=_il
            ||
::             Użytkownik anulował, wracam do redakcji pola
               _result:='IL'
            ?}
         |? _buffer.ILDOK>ZL.IL
         ||
::          Przypadek gdy było już zarejestrowane więcej na dokumentach RP niż zwiększyłem ilości na zleceniu
            _msg:='Zwiększenie serii z %1 do %2 jest możliwe.\n\Dokumenty raportujace zostały już zarejestrowane na %3 %4'
                  '\nSugerowana minimalna ilość jaką można wpisać to: %3'
                  '\n\nCzy pozostawiasz ilość: %2?'@[form(_star_il),$ZL.IL,form(_buffer.ILDOK),ZL.KTM().J().KOD];

            _choice:=FUN.choice(_msg,,'Pozostaw: %1'@[$ZL.IL],'Zmień na: %1'@[form(_buffer.ILDOK)]);
            {? _choice=1
            ||
::             Zostawiam taką ilość jaka była w oknie, nic się nie dzieje
               ~~
            |? _choice=2
            ||
::             Wpisuję ilość sugerowaną w komunikacie
               ZL.IL:=_buffer.ILDOK
            ||
::             Użytkownik anulował, wracam do redakcji pola
               _result:='IL'
            ?}
         ?}
      ||
::       Zmniejszenie serii
::         {? _ilw>ZL.IL
::         || FUN.emsg('Zmniejszenie serii nie jest możliwe.\n\nWykonano już %1'
::               '\% produktu.\nMinimalna ilość jaką można wpisać to: %2.'@[form(_ilw/_star_il*100,,2),form(_ilw)]
::            );
::            _result:='IL'
::         |? _il>ZL.IL
::         || FUN.emsg('Zmniejszenie serii nie jest możliwe.\n\nAkord został już zarejestrowany dla %1'
::               '\% produktu.\nMinimalna ilość jaką można wpisać to: %2.'@[form(_il/_star_il*100,,2),form(_il)]
::            );
::            _result:='IL'
         {? _ilk>ZL.IL
         || FUN.emsg('Zmniejszenie serii nie jest możliwe.\n\nKooperację wydano już dla %1'
               '\% produktu.\nMinimalna ilość jaką można wpisać to: %2.'@[form(_ilk/_star_il*100,,2),form(_ilk)]
            );
            _result:='IL'
         ?}
      ?}
   ?};
   {? _result='' & ZL.IL<_buffer.IL
   ||
::    Sprawdzamy czy można zmniejszyć ilość w oparciu o to o ile można zmniejszyć przewodniki
::    Na przewodnikach ta ilość jest wyliczana w oparciu o robociznę i rozliczenie partii
      _obj:=obj_new('COEF');
      _coef:=1-(ZL.IL/_buffer.IL);
      _obj.COEF:=~~;
      exec('get_ilosc2decrease_zl','zl_head',ZL.ref,_obj,_coef);

      {? type_of(_obj.COEF)>0
      ||
::       Mam współczynnik więc obliczam o ile można zmniejszyć
         {? _obj.COEF>0
         || _min_ilosc:=_buffer.IL*_obj.COEF
         || _min_ilosc:=ZL.IL
         ?};
         _min_ilosc:=exec('zaokr','jm',_min_ilosc,ZL.KTM);

         {? _min_ilosc>0 & ZL.IL<_min_ilosc
         ||
::          Użytkownik wpisał mniej niż dozwolone, komunikat i powrót do redagowania
            _msg:=
               'Nie można zmniejszyć ilości na zleceniu %1 do %2.\n\n'
               'Minimalna ilość wyliczona w oparciu o istniejącą robociznę,\nrozliczenie partii to: %3.'@
               [ZL.SYM,$ZL.IL,$_min_ilosc];
            FUN.emsg(_msg);
            _result:='IL'
         ?}
      ?}
   ?};

:: Sprawdzam czy po ewentualnej korekcie ilości na podzleceniach i powiązanych z nimi limitach będą zgodne
   {? _czy_kor & _result='' & ZL.IL<>_buffer.IL
   ||
      _coef:={? _buffer.IL<>0 || ZL.IL/_buffer.IL || 0 ?};
      {? exec('subsubzlec_exist','zl_link',ZL.ref())>0
      || _limzl:=exec('kor_chk_limzl','zl_common',ZL.ref(),_coef);
         {? _limzl.RESULT=0
         || _msg:='UWAGA!\nPo wprowadzeniu korekty ilość na przynajmniej jednym limicie nie będzie zgodna z '
                  'ilością powiązanego z nim zlecenia.\n\nDla przykładu:\n'
                  'Ilość na zleceniu %1 po korekcie:%2.\n'
                  'Ilość na powiązanym limicie:%3.\n\n'
                  'Do zachowania spójności wymagane będzie przeprowadzenie dodatkowych korekt.\n'
                  'Czy mimo to zatwierdzić modyfikacje danych zlecenia?'@[_limzl.ZL,$_limzl.IL_ZL,$_limzl.IL_ZLIM];
            {? ~FUN.ask(_msg)
            || _result:='IL'
            ?}
         ?}
      ?}
   ?}
||
:: Zlecenie warsztatowe
   {? _proces
   || {? _result='' & ZL.DTR<>date(0,0,0) & ZL.DTR<date() & exec('zl_fld_be','zl_head','DTR')>0
      || FUN.info('Termin realizacji zlecenia %1 nie może być wcześniejszy od daty dzisiejszej.'@[ZL.SYM]);
         _result:='DTR'
      ?}
   ?};

   {? ZL.PL_DATA=date(0,0,0) || ZL.PL_DATA:=ZL.DTR ?};
   {? _result='' & ZL.NR=0
   || {? exec('wol_nr','numery','ZL')>0
      || FUN.info('Numer zlecenia musi być wypełniony.'@);
         _result:='NR'
      ?}
   ?};

   {? _result='' & ZL.PL_DATA>ZL.DTR & exec('zl_fld_be','zl_head','PL_DATA')>0
   || FUN.info(
         'Wewnętrzny termin realizacji nie może być późniejszy niż planowany termin realizacji zlecenia %1.\n'
         'Należy podać wcześniejszą datę.'@[ZL.SYM]
      );
      _result:='PL_DATA'
   ?};

   {? _result='' || _result:=__CHK.record(ZL,,'TYP','PWYD','OPIS') ?};

   {? _result=''
   || {? ZL.STARTD>ZL.ENDD & ZL.ENDD<>date(0,0,0) | ZL.STARTD=ZL.ENDD & ZL.STARTT>ZL.ENDT & exec('zl_fld_be','zl_head','STARTD')>0
      || FUN.info('Data rozpoczęcia zlecenia %1 musi być wcześniejsza od daty zakończenia.'@[ZL.SYM]);
         _result:='STARTD'
      ?}
   ?};

:: Sprawdzanie poprawnosci zwrotu planowania i znacznika kontynuacji po przekroczeniu
   {? _result=''
   || _result:=exec('pl_force_chk','px_utils','ZL')
   ?};

:: Identyfikator księgowy
   {? _result='' & ZL.ID_KSG<>0
   || ZL.cntx_psh();
      ZL.index('ID_KSG');
      ZL.prefix(ZL.ID_KSG);
      _idadd:=ZL.IDADD;
      {? ZL.first() & _idadd<>ZL.IDADD
      || FUN.emsg('Istnieje zlecenie o identyfikatorze księgowym: %1.'@[$ZL.ID_KSG]);
         _result:='ID_KSG'
      ?};
      ZL.cntx_pop()
   ?}
?};

:: Jeżeli wszystko dobrze, to dodatkowa walidacja za pomocą wtyczki (tylko podczas modyfikacji w oknie redagowania)
{? _result='' & cur_kwin()='e_edit' & cur_tab(1,1)=ZL
|| ZL.cntx_psh();
   _result:=Plugin.run('ZL_VALID_001','MOD');
   ZL.cntx_pop()
?};
_result


\zl_il_change
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Uruchamia funkcje zmniejszające/zwiększające różne rzeczy po poprawieniu na zleceniu
::       ilości
::   WE: [_a] - ZL.ref - zlecenie lub bieżący rekord
::       _b - obj_new - bufor zlecenia przed poprawieniem (bufor tego zlecenia które było edytowane przez użytkownika)
::       _c - REAL - nowa ilość, po poprawieniu
::       _d - REAL - stara ilość, przed poprawieniem
::       _e - M.ref() - stary materiał na zleceniu
::       _f - TKTL.ref() - stara technologia
::       [_g] - REAL - współczynnik poprawienia (aktualny poziom)
::       [_h] - REAL - współczynnik poprawienia (sama góra)
::       [_i] - REAL - ilość ze zlecenia którą podzielić na przewodniki
::       [_j] - REAL - ilość na jednym przewodniku
::       [_k] - REAL - ilość zlecenia jaką popartiować
::       [_l] - REAL - ilość jaka ma być na jednej partii
::       [_m] - INTEGER - [0]/1 - czy wywołanie rekurencyjne
::       [_n] - INTEGER - 0/[1] - czy aktualizować podzlecenia
::       [_o] - ref_table - tablica przewodników które były już korygowane
::       [_p] - INTEGER - [0]/1 - czy aktualizować limit na zleceniu nadrzędnym
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};
_buffer:=_b;
_new_il:=_c;
_old_il:=_d;
_old_ktm:=_e;
_old_tktl:=_f;
_coef:={? _old_il<>0 || _new_il/_old_il || 0 ?};
{? var_pres('_g')=type_of(0)
|| _coef:=_g
?};
_coef_top:={? _old_il<>0 || _new_il/_old_il || 0 ?};
{? var_pres('_h')=type_of(0)
|| _coef_top:=_h
?};

_il_zl_zgh:=0;
{? var_pres('_i')=type_of(0)
|| _il_zl_zgh:=_i
?};
_il_zgh:=0;
{? var_pres('_j')=type_of(0)
|| _il_zgh:=_j
?};

_il_zl_part:=0;
{? var_pres('_k')=type_of(0)
|| _il_zl_part:=_k
?};

_il_part:=0;
{? var_pres('_l')=type_of(0)
|| _il_part:=_l
?};

_rec:=0;
{? var_pres('_m')=type_of(0)
|| _rec:=_m
?};

_tree:=1;
{? var_pres('_n')=type_of(0)
|| _tree:=_n
?};

_zgh_corrected:=~~;
{? var_pres('_o')>100
|| _zgh_corrected:=_o
|| _zgh_corrected:=exec('ref_table','#table')
?};

_lim_nad:=0;
{? var_pres('_p')=type_of(0)
|| _lim_nad:=_p
?};

_result:=0;
_can_continue:=1;

TKTL.cntx_psh();
TMAT.cntx_psh();
ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
{? _can_continue>0
||
   _old_var:=VAR.A_ZLEC;
   VAR.A_ZLEC:=ZL.ref();

   _top_rodzaj:=exec('top_rodzaj','zl_link',ZL.ref());

:: Sprawdzam czy aktualizowane zlecenie nie jest powiązane z limitem zlecenia nadrzędnego
   {? _can_continue>0 & _rec=0 & _lim_nad>0
   ||
      {? ZL.NRPZL>0 & ZL.RTMATSRC<>'' & ZL.RP='T'
      ||
         _ktm:=ZL.KTM;
::       szukam zlecenia nadrzędnego
         ZL.cntx_psh();
         ZL.index('UNRZL');
         ZL.prefix(ZL.NRPZL);
         {? ZL.first()
         || ZLIM.cntx_psh();
            exec('openmask','zl_common',ZL.ref());
            ZLIM.clear();
            ZLIM.index('ZKK');
            ZLIM.prefix(ZL.ref(),'T',0,_ktm);
            {? ZLIM.last()
            ||
               _sum_il:=0;
               ZLSTW.cntx_psh();
               ZLSTW.index('K');
               ZLSTW.prefix('~KOR_ILZL');
               {? ZLSTW.first()
               || _zlstw:=ZLSTW.ref()
               || ZLSTW.KOD:='~KOR_ILZL';
                  ZLSTW.NAZ:='Korekta po zmianie ilości na powiązanym zleceniu';
                  {? ZLSTW.add() || _zlstw:=ZLSTW.ref() || _zlstw:=null() ?}
               ?};
               ZLSTW.cntx_pop();

                _dokl:=exec('jaka_dok_m','jm',ZLIM.KTM);
::             Wyliczenie ilości docelowej
               _il_korekt:=(_new_il-_old_il)$_dokl;
::             Koryguje ilość na powiązanym ze zleceniu limitem
               {!
               |? _il_tmp:=_il_korekt;
                  _il_max:=exec('sum_il','zl_limit',ZLIM.ref(),1);
                  {? _il_tmp+_il_max<0 || _il_tmp:=_il_max*-1 ?};
                  _can_continue:=exec('lim_kor_add','zl_limit',ZLIM.ref(),_il_tmp,_zlstw,1);
                  {? _can_continue>0
                  || _il_korekt:=_il_korekt-_il_tmp
                  ?};
                  ZLIM.prev() & _il_korekt<0 & _can_continue>0
               !}
            ?};
            ZLIM.cntx_pop()
         ?};
         ZL.cntx_pop()
      ?}
   ?};
:: Usunięcie wariantowych operacji ostatniego przewodnika
   {? _can_continue>0 & VAR.WAR_DEL='T'
   || ZGH.cntx_psh();
      ZGH.index('ZLNR');
      ZGH.prefix(ZL.ref(),);
      {? ZGH.last()
      || ZGP.cntx_psh();
         ZGP.index('WHERE');
         ZGP.prefix(ZGH.ref(),'O',);
         {? ZGP.first()
         || VAR_DEL.delete('_visited');
            _visited:=exec('ref_table','#table');
            {!
            |?
               _del:=0;
               {? _visited.r_find(ZGP.ref())=0
               || _visited.add(ZGP.ref());
                  _del:=exec('zgp_del','zl_guide',1)
               ?};
               {? _del=0
               || _next:=ZGP.next()
               |? _del=1
               || _next:=0
               || _next:=1
               ?};
               _next
            !};
            VAR_DEL.delete('_visited')
         ?};
         ZGP.cntx_pop()
      ?};
      ZGH.cntx_pop()
   ?};
:: Nanoszenie ilości na podzlecenia
   {? _rec>0
   || _put:=0;
      {? exec('is_main_podzlec','zl_link')
      ||
         {? _buffer.KTM<>ZL.KTM
         || ZL.KTM:=_buffer.KTM;
            _put:=1
         ?};

         {? _buffer.KTL<>ZL.KTL
         || ZL.KTL:=_buffer.KTL;
            _put:=1
         ?};

::       Przepisanie ilości na zlecenie montażowe
         {? _old_il<>_new_il
         || ZL.IL:=exec('zaokr','jm',_new_il,ZL.KTM);
            _put:=1
         ?};
         {? _put>0
         || _can_continue:=ZL.put()
         ?};
         {? _can_continue>0
         || exec('zl2obj','px_obj')
         ?}
      ||
::       Na podzleceniach nowa ilość jest wyliczana na podstawie współczynnika
         _old_il:=ZL.IL;
         _new_il:=exec('zaokr','jm',_coef*ZL.IL,ZL.KTM);

         {? _old_il<>_new_il & _new_il>0
         ||
::          Po zaokrągleniu obliczam nowy _coef żeby go poprawnie przekazać poziom w dół
            _coef:={? _old_il<>0 || _new_il/_old_il || 0 ?};
            ZL.IL:=_new_il;
            _can_continue:=ZL.put();
            {? _can_continue>0
            || exec('zl2obj','px_obj')
            ?}
         ?}
      ?}
   ?};

   _ile_zgh:=exec('get_ilosc_zgh','zl_common');
   _ile_part:=exec('zl_ile_part','zl_partie');

   {? _ile_zgh>0
   ||
::    Są przewodniki
      {? _new_il>_old_il & (_ile_zgh>=_old_il)
      ||
         {? _rec>0 & exec('is_main_podzlec','zl_link')=0
         ||
::          Jeśli wywołanie rekurencyjne, to znak że podzlecenie i być może trzeba przeskalować
::          ilość na jaką wygenerować przewodniki
            _il_zl_zgh:=-1;
            _il_zgh:=-1
         ?};
::       Zwiększenie ilości
         _can_continue:=exec('zl_il_increase','zl_guide',_new_il-_old_il,_new_il/_old_il,_il_zl_zgh,_il_zgh);
         {? _can_continue>0
         ||
            _can_continue:=exec('zlim_gen_all','zl_limit','',ZL.ref());
            {? _can_continue>0
            || _il_zaokr:=exec('zaokr','jm',_old_il,ZL.KTM);
               exec('add_mod_pos','zl_common','mz','Zwiększenie ilości na zleceniu z: '+form(_il_zaokr)+' na: '+form(ZL.IL))
            ?}
         || _ok:=0
         ?}
      |? _new_il<_old_il & (_new_il<_ile_zgh)
      ||
::       Zmniejszenie ilości
         _decrease:=_ile_zgh-_new_il;
         _zgh_decrease:=1;
         {? _decrease>0
         ||
            _zgh_tied:=exec('chk_zgh_tied','zl_guide');

::          Wyłączenie poprawiania ilości na podzleceniach, bo przewodniki mogły być już
::          skorygowane rekurencyjnie poziom wyżej
            {? _top_rodzaj='Z'
            || {? _zgh_tied>0 & _rec>0
               || _zgh_decrease:=0
               ?}
            ?};
            {? _zgh_decrease>0
            ||
               _can_continue:=exec('zl_il_decrease','zl_guide',_decrease,_new_il/_ile_zgh,_zgh_corrected);
               {? _can_continue>0
               ||
                  _il_zaokr:=exec('zaokr','jm',_old_il,ZL.KTM);
                  exec('add_mod_pos','zl_common','mz','Zmniejszenie ilości na zleceniu z: '+form(_il_zaokr)+' na: '+form(ZL.IL))
               || _ok:=0
               ?}
            ?}
         ?}
      ?}
   |? _ile_part>0
   ||
::    Są partie, nie ma jeszcze przewodników
      {? _new_il>_old_il & (_ile_part>=_old_il)
      ||
::       Zwiększenie ilości
         _can_continue:=exec('generuj','zl_partie',ZL.ref(),,1,0,_il_zl_part,_il_part)
      |? _new_il<_old_il & (_new_il<_ile_part)
      ||
::       Zmniejszenie ilości
         _decrease:=_ile_part-_new_il;
         {? _decrease>0
         ||
            ZPARN.cntx_psh();
            ZPARN.index('ZL2');
            ZPARN.prefix(ZL.ref());
            _can_continue:=exec('correction_decrease','zl_partie',_decrease);
            ZPARN.cntx_pop()
         ?}
      ?}
   ?};

:: Tu trzeba zrobić naniesienie ilości na podzlecenia i uruchomienie korekt dla podzleceń
:: Trzeba też dodać nowe pole ZL.KOR_COEF do zlecenia które będzie pilnowało czy podzlecenia
:: w danej ścieżce były modyfikowane tym samym wpółczynnikiem, czy ktoś to sobie rozwalił modyfikując ręcznie
:: i wtedy rekurencyjnie nie nanosimy nic w dół

   _future_tree:=_tree;
   {? _tree=0 & ZL.RODZAJ='Z'
   ||
::    Nawet jeżeli nanoszenie w dół wyłączone, to i tak zawsze to robię dla zlecenia montażowego
      _tree:=1;
      _future_tree:=0
   ?};

   {? _can_continue>0 & _tree>0
   || {? ZL.RODZAJ<>'N'
      || ZL.cntx_psh();
         ZL.index('TREEMTU');
         ZL.prefix(ZL.ref());
         {? ZL.first()
         || {!
            |?
::             !!! REKURENCJA !!!
               _can_continue:=exec('zl_il_change','zl_head',
                                                            ,_buffer
                                                            ,_new_il
                                                            ,ZL.IL
                                                            ,ZL.KTM
                                                            ,ZL.KTL
                                                            ,_coef
                                                            ,_coef_top
                                                            ,_il_zl_zgh
                                                            ,_il_zgh
                                                            ,_il_zl_part
                                                            ,_il_part
                                                            ,1
                                                            ,_future_tree
                                                            ,_zgh_corrected);
               ZL.next() & _can_continue>0
            !}
         ?};
         ZL.cntx_pop()
      ?}
   ?};

   {? _can_continue>0 & _new_il>_old_il
   ||
::    Uzupelnienie powiazan miedzy przewodnikami podzlecen oraz odtworzenie statusow pozycji przewodnikow
      {? ZL.RODZAJ='Z'
      || exec('gendom_zl','zl_guide','N',0);
         ZL.cntx_psh();
         ZL.index('NRNZL');
         ZL.prefix(ZL.UNRZL);
         {? ZL.first()
         || {!
            |? ZGH.index('ZLNR');
               ZGH.prefix(ZL.ref());
               {? ZGH.first()
               || {!
                  |? exec('recover_sta_zgh','zl_guide',ZGH.ref());
                     ZGH.next()
                  !}
               ?};
               ZL.next()
            !}
         ?};
         ZL.cntx_pop()
      ?}
   ?};
   VAR.A_ZLEC:=_old_var;
   ~~
?};
ZL.cntx_pop();
TKTL.cntx_pop();
TMAT.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\get_ilosc2decrease_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Zwraca współczynnik proporcji o jaką można zmniejszyć zlecenie opierając się o robociznę i rozliczenie partii
::       na przewodnikach
::   WE: [_a] - ZL.ref lub bieżący rekord
::       _b - obj_new - obiekt z polem COEF, w którym będzie zwracana wartość
::       _c - REAL - współczynik zmniejszenia (1 - zmniejszam wszystko, 0 - nie zmniejszam nic)
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};
_result:=_b;
_coef:=_c;

_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
{? _can_continue>0
||
   _new_il:=ZL.IL-(ZL.IL*_coef);
::   _new_il:=exec('zaokr','jm',_new_il,ZL.KTM);
   _il:=ZL.IL-_new_il;
   ZGH.cntx_psh();
   ZGH.index('ZLNR');
   _curr_zl:=0;
   _zgh_il:=0;
   ZGH.prefix(ZL.ref());
   {? ZGH.first()
   || {!
      |?
         _zgh_decrease:=0;
         {? _il>=ZGH.ILNPRZ
         || _zgh_decrease:=ZGH.ILNPRZ;
            _zgh_il+=ZGH.ILNPRZ
         || _zgh_decrease:=_il;
            _zgh_il+=ZGH.ILNPRZ
         ?};
         _coef_zgh:=exec('get_ilosc2decrease','zl_guide',,_zgh_decrease/ZGH.ILNPRZ);
         _curr_zl+=ZGH.ILNPRZ*_coef_zgh;
         ZGH.next()
      !}
   ?};
   _curr_coef:=0;
   {? _zgh_il>0
   || _curr_coef:=(_zgh_il-_curr_zl)/_zgh_il
   ?};
   {? ZL.IL>_zgh_il
   ||
::    Jeśli ilość na zleceniu większa niż na przewodnikach to wyliczony współczynnik należy jeszcze przeskalować
      _curr_coef:=_zgh_il/ZL.IL*_curr_coef
   ?};
:: Zaokrąglam żeby się pozbyć śmieci kwantyzacji w MacroBASE
   _round:=roundmet(1);
   _curr_coef:=_curr_coef$14;
   roundmet(_round);

   {? type_of(_result.COEF)=0 | (_curr_coef>0 & _curr_coef>_result.COEF)
   || _result.COEF:=_curr_coef
   ?};

   ZL.cntx_psh();
   ZL.index('TREEMTU');
   ZL.prefix(ZL.ref());
   {? ZL.first()
   ||
::    Zlecenie ma podrzędne
      {!
      |?
         exec('get_ilosc2decrease_zl','zl_head',,_result,_coef);
         ZL.next()
      !}
   ?};

   ZL.cntx_pop();
   ZGH.cntx_pop()
?};
ZL.cntx_pop();
~~


\kor_coef_equal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Sprawdza czy dane zlecenie i wszystkie jego podzlecenia mają ten sam współczynniki
::       korekty, czyli były korygowane 'wspólnie'
::   WE: [_a] - ZL.ref lub bieżący rekord
::       [_b] - REAL - współczynnik korekty poziom wyżej
::   WY: 0 - współczynnik korekty różni się na jakimś poziomie
::       1 - współczynnik korekty wszędzie taki sam
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};
_upper_coef:=-1;
{? var_pres('_b')=type_of(0)
|| _upper_coef:=_b
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? _upper_coef=-1
   || _upper_coef:=ZL.KOR_COEF
   ?};

   ZL.cntx_psh();
   ZL.index('TREEMTU');
   ZL.prefix(ZL.ref());
   {? ZL.first()
   || {!
      |?
         {? ZL.KOR_COEF<>_upper_coef
         || _can_continue:=0
         ?};

         {? _can_continue>0
         ||
::          !!! REKURENCJA !!!
            _can_continue:=exec('kor_coef_equal','zl_head',,_upper_coef)
         ?};
         ZL.next() & _can_continue>0
      !}
   ?};
   ZL.cntx_pop()
?};
ZL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\kor_coef_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Ustawia danemu zleceniu oraz wszystkim zleceniom poniżej ten sam współczynnik korekty
::   WE: [_a] - ZL.ref lub bieżący rekord
::       _b - REAL - współczynnik korekty poziom wyżej
::       [_c] - INTEGER - 0/[1] - czy uruchamiać rekurencyjnie dla podzleceń?
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};
_upper_coef:=_b;
_tree:=1;
{? var_pres('_c')=type_of(0)
|| _tree:=_c
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   ZL.KOR_COEF:=_upper_coef;
   _can_continue:=ZL.put();

   {? _can_continue>0 & _tree
   ||
      ZL.cntx_psh();
      ZL.index('TREEMTU');
      ZL.prefix(ZL.ref());
      {? ZL.first()
      || {!
         |?
::          !!! REKURENCJA !!!
            _can_continue:=exec('kor_coef_set','zl_head',,_upper_coef);
            ZL.next() & _can_continue>0
         !}
      ?};
      ZL.cntx_pop()
   ?}
?};
ZL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\chk_zpwyd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Walidacja rekordu tabeli ZPWYD (podstawy powołania zleceń)
::       - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(ZPWYD,,'PWYD');
{? _chk=''
|| {? 1+ZPWYD.PWYD='~'
   || FUN.info('Podstawa powołania zlecenia nie może się zaczynać od znaku ''%1''.'@['~']);
      'PWYD'
   |? __CHK.index(ZPWYD,_a)=''
   || ''
   || 'PWYD'
   ?}
|| _chk
?}


\tryb_rezw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [20.42]
:: OPIS: Modyfikuje sposób rezerwacji warunkowych
::   WE: _a - 'N' - standardowa obsługa, 'T' - rezerwacje dedykowane podzleceniom
::       [_b] - ref SQL ZLIM-a
::----------------------------------------------------------------------------------------------------------------------
_tryb:={? var_pres('_a')=type_of('') & (';TN'*_a)>1 || _a || 'N' ?};
_zlec:={? var_pres('_b')=type_of('') & _b<>''
       || exec('FindAndGet','#table',ZLIM,_b,,"ZLEC",null())
       || ZL.ref()
       ?};

{? _zlec<>null()
|| ZL.cntx_psh();
   {? ZL.seek(_zlec)
   || {? ZL.RP_REZ={? _tryb='T' || 'Z' || 'S' ?}
      || FUN.info('Sposób obsługi rezerwacji warunkowych dla limitów zlecenia %1 zgodny z wybranym.'@[ZL.SYM])
      |? {? _tryb='T'
         || FUN.ask('Czy zmienić sposób obsługi rezerwacji warunkowych dla limitów zlecenia %1?\n\n'
                    'Uwaga. Dla obsługiwanych podzleceń rezerwacje bezwarunkowe\n'
                    'zostaną zmienione na warunkowe dedykowane.'@[ZL.SYM])
         || FUN.ask('Czy zmienić sposób obsługi rezerwacji warunkowych dla limitów zlecenia %1?\n\n'
                    'Uwaga. Rezerwacje zostaną ponownie rozpisane.'@[ZL.SYM])
         ?}
      || VAR_DEL.delete('__aktzkp');

         __aktzkp:=tab_tmp(1,'MAT','STRING[16]',''
                    ,'NRK','INTEGER',''
                    ,'ILR','REAL','');
         do();
         ZL.RP_REZ:={? _tryb='T' || 'Z' || 'S' ?};
         ZL.put(1);
         {? _tryb='T' || exec('usurez','zamsiw_limit',ZL.ref(),null(),,1) ?};
         REZ.index('ZL');
         REZ.prefix(ZL.ref(),'Z','W');
         {? REZ.first()
         || {!
            |? {? REZ.RP_REZ='T'
               || __aktzkp.clear();
                  {? __aktzkp.find_key($REZ.M)
                  || __aktzkp.ILR+=REZ.ILR;
                     __aktzkp.put(1)
                  || __aktzkp.blank();
                     __aktzkp.MAT:=$REZ.M;
                     __aktzkp.ILR:=REZ.ILR;
                     __aktzkp.NRK:=exec('FindInSet','#table','REZ','RODZ',REZ.M,'W',"REZ.NRK",,,0);
                     __aktzkp.add(1)
                  ?}
               ?};
               REZ.RP_REZ:=_tryb;
               REZ.put(1);
               REZ.next()
            !}
         ?};
         __aktzkp.clear();
         {? __aktzkp.first()
         || {!
            |? _refm:=exec('FindAndGet','#table','M',__aktzkp.MAT,,,null());
               exec('aktu_rez','rezerwacje',_refm,__aktzkp.NRK,__aktzkp.ILR);
               __aktzkp.next()
            !}
         ?};
         end();
         VAR_DEL.delete('__aktzkp');
         _tab:=cur_tab(1,1);
         _tab.cntx_psh();
         {? _tab.first() || {! |? exec('bd_zlimt','zl_limit'); _tab.next() !} ?};
         _tab.cntx_pop()
      ?}
   ?};
   ZL.cntx_pop()
?};
~~


\kor_chk_ildok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Sprawdza czy po korekcie nowa ilość na zleceniach nie będzie mniejsza niż ilość już zaraportowana
::   WE: [_a] - ZL.ref lub bieżący rekord
::       _b - REAL - współczynnik korekty poziom wyżej
::       [_c] - INTEGER - 0/[1] - czy uruchamiać rekurencyjnie dla podzleceń?
::   WY: obiekt _result o polach:
::       RESULT: 1 - poprawne ilości, 0 - błędne ilości
::       ZL_SYM: Symbol zlecenia, którego ilość jest nieprawidłowa lub ''
::       MIN_IL: Minimalna ilość na zleceniu na jaką może zostać zrobiona korekta
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};
_upper_coef:=_b;
_tree:=1;
{? var_pres('_c')=type_of(0)
|| _tree:=_c
?};

_result:=obj_new('RESULT','ZL_SYM','MIN_IL');
_result.RESULT:=0;
_result.ZL_SYM:='';
_result.MIN_IL:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: Wyliczam nową ilość dla podzlecenia i sprawdzam czy jest większa od ilości zaraportowanej
   _new_il:=exec('zaokr','jm',_upper_coef*ZL.IL,ZL.KTM);
   _can_continue:=_new_il>=ZL.ILDOK;

   {? _can_continue>0 & _tree
   ||
      ZL.cntx_psh();
      ZL.index('TREEMTU');
      ZL.prefix(ZL.ref());
      {? ZL.first()
      || {!
         |?
::          !!! REKURENCJA !!!
            {? var_press('_tmp')>100 || obj_del(_tmp) ?};
            _tmp:=exec('kor_chk_ildok','zl_head',ZL.ref(),_upper_coef,_tree);
            _can_continue:=_tmp.RESULT;
            {? _can_continue=0
            || _result.ZL_SYM:=_tmp.ZL_SYM;
               _result.MIN_IL:=_tmp.MIN_IL
            ?};
            ZL.next() & _can_continue>0
         !}
      ?};
      ZL.cntx_pop()
   || {? _can_continue=0
      || _result.ZL_SYM:=ZL.SYM;
         _result.MIN_IL:=ZL.ILDOK
      ?}
   ?}
?};
ZL.cntx_pop();
{? _can_continue>0
|| _result.RESULT:=1
?};
_result


\zl_word
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Wydruk zlecenia produkcyjnego do WORD
::----------------------------------------------------------------------------------------------------------------------
{? ZL.KH<>null()
|| ZL.KH()
|| KH.seek(,,,1)
?};

{? ZL.DK_C<>null()
|| ZL.DK_C()
|| DK_C.seek(,,,1)
?};

exec('generuj','szablon_zws','TTE_ZLECENIE');
~~


\is_improvement
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Sprawdza, czy zlecenie jest rodzaju 'Ulepszenie', czyli zawiera w surowcach swój produkt
::   WE: _a - ZL.ref()
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl) & ZL.TYP().WP='P'
||
:: Jeśli są zapotrzebowania, to wg nich
   {? _can_continue>0
   || ZLIM.cntx_psh();
      exec('openmask','zl_common',ZL.ref());
      ZLIM.index('ZN');
      ZLIM.prefix(_zl);
      {? ZLIM.first()
      || _can_continue:=0;
         {!
         |? {? ZLIM.KTM=ZL.KTM
            || _result:=1
            ?};
            _result=0 & ZLIM.next()
         !}
      ?};
      ZLIM.cntx_pop()
   ?};

:: Jeśli jest karta zlecenia, to wg niej
   {? _can_continue>0 & ZL.RTKTL<>''
   || _can_continue:=0;
      _result:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,"TKTL.IMPROVE='T'",0)
   ?};

:: Jeśli jest karta źródłowa, to wg niej
   {? _can_continue>0 & ZL.RKTL<>''
   || _can_continue:=0;
      _result:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,"TKTL.IMPROVE='T'",0)
   ?}
?};

ZL.cntx_pop();

_result


\zl_has_wariant
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, czy technologia zlecenia (lub techn. jednego z podzleceń) posiada wariantowe operacje
::       (dedykowane dla pierwszego lub ostatniego przewodnika)
::   WE: _a - ZL.ref()
::       [_b] - STRING - jakie operacje sprawdzać: 'FIRST' - tylko operacje wariantowe pierwszego przewodnika,
::          'LAST' - tylko operacje wariantowe ostatniego przewodnika, '' - wartość domyślna, dowolne operacje wariant.
::       [_c] - czy sprawdzać podzlecenia: [0] - nie, 1 - tak
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_zl:={? var_press('_a')=type_of(null()) || _a || null() ?};
_what:={? var_press('_b')=type_of('') || _b || '' ?};
_chk_podzl:={? var_press('_c')=type_of(0) || _c || 0 ?};
_res:=0;
{? _zl<>null()
|| ZL.cntx_psh();
   ZL.clear();
   {? ZL.seek(_zl)
   ||
      ZTP.cntx_psh();
      {? ZL.TYP().TECH='T'
      || _ktl:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,"ref()",null())
      || _ktl:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,"ref()",null())
      ?};
      ZTP.cntx_pop();
      _res:=exec('tktl_has_wariant','tech_head',_ktl,_what);
::    Przechodzę po podzleceniach zlecenia złożonego
      {? _res=0 & _chk_podzl>0
      || ZL.cntx_psh();
         ZL.index('NRNZL');
         ZL.prefix(ZL.UNRZL);
         {? ZL.first()
         || {!
            |?
::             !!! REKURENCJA !!!
               _res:=exec('zl_has_wariant','zl_head',ZL.ref(),_what,_chk_podzl);
               ZL.next() &  _res=0
            !}
         ?};
         ZL.cntx_pop()
      ?}
   ?};
   ZL.cntx_pop()
?};
_res


\pr_eanl_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [22.26]
:: OPIS: Przed zmianą lokalizacji dla magazynu
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
{? ZL.MG().SL='T'
|| EANX.MG:=ZL.MG;
   EANX.WYLZAL:={? EANX.MG().MWS='T' & EANX.MG().P_ALL || '' || 'T' ?};
   1
|| 0
?}


\zl_mg_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [22.26]
:: OPIS: Po wyborze magazynu
::----------------------------------------------------------------------------------------------------------------------
{? ZL.EANL<>null() & ZL.EANL().MG<>ZL.MG || ZL.EANL:=null() ?};
1


\zl_from_sm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, czy zlecenie zostało wygenerowane na podstawie stanów magazynowych
::   WE: _a - ZL.ref()
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_zl:={? var_pres('_a')=type_of(null()) || _a || null() ?};
{? _zl<>null()
|| ZL.cntx_psh();
   ZL.clear();
   {? ZL.seek(_zl)
   || {? ZL.PWYD<>null() & ZL.PWYD=exec('zpwyd_sm','zl_gen',1)
      || _result:=1
      ?}
   ?};
   ZL.cntx_pop()
?};
_result


\zl_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Rejestracja nagłówka zlecenia produkcyjnego na podstawie technologii lub materiału
::   WE: _a - miejsce wywołania: 0 - karty technologiczne (TKTL),
::                               1 - produkty karty (TKTLW),
::                               2 - materiały/usługi (M)
::       [_b] - kategoria zlecenia: ['P'] - proste, 'Z' - złożone
::----------------------------------------------------------------------------------------------------------------------
_where:={? var_pres('_a')=type_of(0) || _a || return() ?};
_kategoria:={? var_pres('_b')=type_of('') || _b || 'P' ?};
_tktl:=_ktm:=null();
{? _where=0
|| _tktl:=TKTL.ref()
|? _where=1
|| _tktl:=TKTLW.TKTL;
   _ktm:=TKTLW.KTM
|| _ktm:=M.ref()
?};
_torw:=VAR.A_TORW;
{? _tktl<>null() | _ktm<>null()
|| {? ((_where=0 | _where=1) & ~exec('chk_tktl4zl','zl_common',_tktl))
      | (_where=2 & ~exec('chk_ktm4zl','zl_common',_ktm,,_kategoria))
   || _args:=exec('mp_run_a','#b__box');
      _args.ACT_UID:={? _kategoria='Z' || 'TTE_PZL_DZLP' || 'TTE_PZL_DZLE' ?};
      _args.AKCJA:='DOŁĄCZ';
      _args.PROC_START:='T';
      _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);

      {? _tktl<>null()
      || exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'TKTL',_tktl)
      ?};
      {? _ktm<>null()
      || exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'KTM',_ktm)
      ?};

      exec('mp_run','#b__box',_args)
   ?}
|| FUN.emsg('Technologia lub produkt zlecenia musi zostać określony.'@)
?};
VAR.A_TORW:=_torw;
~~


\ktm_f_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Ustawia filtr dla pola ZL.KTM - ustala listę produktów zlecenia, na podstawie wybranej technologii.
::----------------------------------------------------------------------------------------------------------------------
_where:='A=\'T\' and (R_PROD=\'T\' and RODZ=\'T\' or RODZ=\'U\') '
        ' and TKTLW.REFERENCE like \'txktw___%\' and TKTLW.TKTL=:_a';
_sort:='KTM';
_from:='left join @TKTLW using (TKTLW.KTM, M.REFERENCE)';

M.clear();
M.f_set(_sort,_from,_where,ZL.KTL);
~~

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:36 71e37d8490ded49b92a35b9f5144372fc8479c13df29284cc9d7f0d3600da25bca324ac974eb4ba845ce0d5b3dd7ee931870eb6d4c60a055a620e3411f1eb071e0e90f1b4a7da089b3eaf0d8fe0dd451c24e2b5f8260bb9d4bc7383a8dde4c4c1adc8c249d9b34864f82027dd2ada3cf9e774a0f405b5fe10a35b9db47cbf575
