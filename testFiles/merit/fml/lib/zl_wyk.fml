:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: zl_wyk.fml
:: Utworzony: 12.01.2016
:: Autor: WH
::======================================================================================================================
:: Zawartość: Formuły do obsługi rejestracji wykonań do zleceń:
::            obsługa PROD_REJ, ZLGD, ZLGB
::======================================================================================================================


\zlgd_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Formuła na usuń ZLGD
::       Jeżeli bez pytań (usuwanie algorytmiczne), to usuwanie także w przypadku powiązań z wygenerowanymi dokumentami.
::       Funkcja użyta w transakcji nie używa blk_locka.
::   WE: [_a] - (0/1) czy pytać, domyslnie TAK (1)
::       [_b] - 1 wymusza usunięcie jeżeli zapis automatyczny, [0] standard
::   WY: 1 - zapis został usunięty, 0 i wartości ujemne - zapis nie został usunięty
::  OLD: \zlgd_usun/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _ask:=_a || _ask:=1 ?};
{? var_pres('_b')=type_of(0) || _force:=_b || _force:=0 ?};

{? ZLGD.AUTO='T' & ~_force
|| {? _ask || FUN.info('Zapis automatyczny — nie można usunąć.'@) ?};
   return(-1)
?};

{? ZLGD.BADH<>null() & ZLGD.BADH().STAN<>'P'
|| FUN.info('Wysłano do badania, które zostało zaakceptowane — modyfikacje niemożliwe.'@);
   return(-2)
?};

{? var_pres('ProdRej')<0 & ZLGD.KOOP='T'
|| {? _ask || FUN.info('Kooperacja — modyfikacje możliwe tylko od strony modułu rejestracji wykonań.'@) ?};
   return(-3)
?};

{? ZLGD.ZGP().NTIME=0 & var_pres('ProdRej')<0
|| FUN.info('Operacja tylko z czasem maszynowym — modyfikacje możliwe tylko od strony modułu rejestracji wykonań.'@);
   return(-4)
?};

{? ZLGD.ZGH().STAN='T'
|| {? _ask || FUN.info('Przewodnik oddany — nie można usunąć.'@) ?};
   return(-5)
?};

{? do_state()=0
|| {? exec('blk_lock','#table','ZGH',ZLGD.ZGH,,,
         {? _ask || 'Przewodnik %1 jest redagowany'@[exec('record','#to_string',ZLGD.ZGH)] || '' ?}
      )=0
   || return(-6)
   ?}
?};

_zgh:=ZLGD.ZGH;

:: Sprawdzenie podczas usuwania innego zapisu niz 'zamykajacego operacje'
{? ZLGD.OK='N' & ZLGD.ZAK='T'
|| _usun:=1;
   ZLGD.cntx_psh();
   ZLGD.index('ZLPP');
   ZLGD.prefix(ZLGD.ZL,ZLGD.ZGH,ZLGD.ZGP);
   {? ZLGD.first()
   || {!
      |? {? ZLGD.OK='T' || _usun:=0 ?};
         ZLGD.next()
      !}
   ?};
   ZLGD.cntx_pop();
   {? ~_usun
   || {? _ask || FUN.info('Najpierw należy usunąć zapis kończący wykonywanie operacji.'@) ?};
      return(-7)
   ?}
?};

_chkak:=exec('get','#params',500631,2);

:: Sprawdzenie czy Tpz ma rejestracje do operacji glownej
{? ZLGD.ZGP().TPZ='T' & ZLGD.ZAK='T' & _chkak='T'
|| _po_tpz:=exec('po_tpz','zl_wyk',ZLGD.ZGP);

   {? _po_tpz<>0
   || {? _ask || FUN.info('Opercja Tpz — najpierw należy usunąć zapisy do operacji głównej.'@) ?};
      return(-8)
   ?}
?};

:: Sprawdzenie nastepnych operacji, w przypadku wydania do kooperacji magazynowej nie mozna usunac biezacej
{? _chkak='T'
|| _next:=exec('tab_zgp_next','zl_guide',ZLGD.ZGP);
   {? _next.first()
   || {!
      |? {? _next.IL_KOOP>0
         || {? _ask || FUN.info('Produkcja przekazana do kooperacji — nie można usunąć.'@) ?};
            return(-9)
         ?};
         _next.next()
      !}
   ?}
?};

:: Ile na dokumentach
_ilegen:=exec('get_ilosc_rp','zl_wyk');

KOMM.init(250,,'Usuwanie robocizny'@);

_res:=-10;

ZGP.cntx_psh(); ZL.cntx_psh();
ZGP.clear();

{? ~_ask | _ilegen=0 | ZLGD.ZL().TYP().WP='W'
||
   ZLGB.index('ZLGD');
   ZLGB.prefix(ZLGD.ref());
   {? ~_ask | FUN.ask('Czy usunąć zapis?'@)
   || {? _chkak='T'
      || ZGP.cntx_psh();
         _ilw:=0;
         {? ZGP.seek(ZLGD.ZGP)
         || _ilw+=ZGP.IL;
            _ilwyk:=exec('obl_ilw','zl_guide');
            ZGP.cntx_pop();
            {? _ilwyk=0
            || {? ~_ask | _ilegen=0
               || {? exec('usun','zl_wyk') || _res:=1 ?}
               || {? ZLGD.ZL().TYP().WP<>'W'
                  || FUN.info('Dla tego przewodnika został już wygenerowany raport z produkcji.'@)
                  || FUN.emsg('Tej pozycji nie można usunąć.'@)
                  ?}
               ?}
            || {? _ilwyk>_ilw-ZLGD.IL
               || FUN.info('Nie można usunąć, włączona kontrola ilości na przewodnikach.'@)
               || {? exec('usun','zl_wyk') || _res:=1 ?}
               ?}
            ?}
         ||
            ZGP.cntx_pop()
         ?}
      || {? ~_ask | _ilegen=0
         || {? exec('usun','zl_wyk') || _res:=1 ?}
         || {? ZLGD.ZL().TYP().WP<>'W'
            || FUN.info('Dla tego przewodnika został już wygenerowany raport z produkcji.'@)
            || FUN.emsg('Tej pozycji nie można usunąć.'@)
            ?}
         ?}
      ?}
   ?}
|| FUN.emsg('Na część lub całość został wygenerowany dokument produkcyjny.\nNależy usunąć raport produkcji.'@)
?};

KOMM.select();

ZGP.cntx_pop(); ZL.cntx_pop();

{? do_state()=0 || exec('blk_unlock','#table','ZGH',_zgh) ?};

_res


\usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: Usuniecie ZLGD i powiazanych kartotek
::  OLD: \usun/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_can_continue:=1;
_zlgd_zl:=ZLGD.ZL;

BRAKI_GD.index('ZLGD');
BRAKI_GD.prefix(ref_name(ZLGD.ref()),ZLGD.ref());
{? BRAKI_GD.first()
|| FUN.info('Wygenerowano kwalifikację braków dla operacji naprawczych — modyfikacje niemożliwe.'@);
   _can_continue:=0
?};

{? _can_continue>0
||
   {? ZLGB.first() || {! |? ZLGB.del() !} ?};

   _dalej:=1;
   {? ZLGD.ZL().TYP().WP='W'
   ||
::    gdy warsztatowe to usuwamy ilosc wykonana na zleceniu rowniez
      _zgp:=ZLGD.ZGP;
      ZGP.cntx_psh();
      ZGP.index('PNRPP');
      ZGP.prefix(ZLGD.ZGH);
      {? ZGP.last()
      || {? ZGP.ref()=_zgp
         || ZL.clear();
            _dalej:=0;
            {? ZL.seek(ZLGD.ZL)
            || ZL.ILWYK-=ZLGD.IL;
               {? ZGP.TPZ='N' || ZL.HWYK-=ZLGD.TIME_P ?};
               ZL.put();
               {? ZL.NRNZL<>0
               || ZL.cntx_psh();
                  ZL.index('UNRZL');
                  ZL.prefix(ZL.NRNZL);
                  {? ZL.first()
                  || ZL.ILWYK-=ZLGD.IL;
                     {? ZGP.TPZ='N' || ZL.HWYK-=ZLGD.TIME_P ?}
                  ?};
                  ZL.put();
                  ZL.cntx_pop()
               ?}
            ?}
         ?}
      ?};
      ZGP.cntx_pop();
      {? ZLGD.ZGH().STAN='T'
      || ZGH.STAN:='N';
         ZGH.put()
      ?}
   ?};

   {? ZLGD.ZGP().TPZ='N' & _dalej
   || ZL.clear();
      {? ZL.seek(ZLGD.ZL)
      || ZL.ILWYK-=ZLGD.IL;
         ZL.HWYK-=ZLGD.TIME_P;
         ZL.put();
         {? ZL.NRNZL<>0
         || ZL.cntx_psh();
            ZL.index('UNRZL');
            ZL.prefix(ZL.NRNZL);
            {? ZL.first()
            || ZL.HWYK-=ZLGD.TIME_P;
               ZL.put()
            ?};
            ZL.cntx_pop()
         ?}
      ?}
   ?}
?};

_zlgd:=$ZLGD.ref();
{? _can_continue>0
|| _can_continue:=exec('del4ZLGD','statexam');
   {? _can_continue>0
   || exec('del4ZLGD','zl_limit');
      exec('del4ZLGD','zl_wyr')
   ?}
?};

{? _can_continue>0 & ZLGD.del(,1)
|| exec('oblicz_zgh_1zl','zl_wyk',_zlgd_zl);
   _res:=1
?};
_res


\po_tpz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca czy cokolwiek zarejestrowano do operacji glownej
::   WE: _a - ZGP.ref() - operacja Tpz
::  OLD: \po_tpz/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_po_tpz:=0;

ZGP.cntx_psh();
ZGP.clear();
{? ZGP.seek(_zgp) & ZGP.TPZ='T'
||
   ZGP.index('UID');
   ZGP.prefix(ZGP.UID_TPZ);
   {? ZGP.first()
   || {? ZGP.IL+ZGP.IL_BRAK>0
      || _potpz:=1
      || _tab:=exec('zlgd_zgp','zl_guide',ZGP.ref());
         {? _tab.size()>0 || _po_tpz:=1 ?}
      ?}
   ?}
?};
ZGP.cntx_pop();
_po_tpz


\_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS: formula na popraw dla ZLGD
::   WY: 0 / 1
::  OLD: \_popraw/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLGD.AUTO='T'
|| FUN.info('Zapis automatyczny — nie można poprawić.'@);
   return(0)
?};

BRAKI_GD.index('ZLGD');
BRAKI_GD.prefix(ref_name(ZLGD.ref()),ZLGD.ref());
{? BRAKI_GD.first()
|| FUN.info('Wygenerowano operacje naprawcze — modyfikacje niemożliwe.'@);
   return(0)
?};

{? ZLGD.BADH<>null() & ZLGD.BADH().STAN<>'P'
|| FUN.info('Wysłano do badania, które zostało zaakceptowane — modyfikacje niemożliwe.'@);
   return(0)
?};

{? ZLGD.KOOP='T' & var_pres('ProdRej')<0
|| FUN.info('Kooperacja — modyfikacje możliwe tylko od strony modułu rejestracji wykonań.'@);
   return(0)
?};

{? ZLGD.ZGP().NTIME=0 & var_pres('ProdRej')<0
|| FUN.info('Operacja tylko z czasem maszynowym — modyfikacje możliwe tylko od strony modułu rejestracji wykonań.'@);
   return(0)
?};

{? ZLGD.KJ_DONE='T'
|| FUN.info('Operacja zakwalifikowana — modyfikacje niemożliwe.'@);
   return(0)
?};

{? exec('blk_lock','#table','ZGH',ZLGD.ZGH,,,'Przewodnik %1 jest redagowany'@[exec('record','#to_string',ZLGD.ZGH)])=0
|| return(0)
?};

_edit_ok:=0;
VAR1.REJ_WYR:='N';
_ilegen:=exec('get_ilosc_rp','zl_wyk');

{? ZLGD.ZGP().WEW='T'
|| {? exec('zlgd_czy_wyr','zl_wyr',ZLGD.ref())
   || _env:=exec('env','zl_wyr',1);
      exec('fill_env','zl_wyr',ZLGD.ZGP,ZLGD.ref());
      VAR1.REJ_WYR:='T';
      __valid:="exec('chk_rec_zlgd','zl_wyk')"
   |? ZGP.NTIME=0
   || ZLGD.win_edit('RED_WRK')
   || ZLGD.win_edit('RED_P');
      {? ZLGD.BP='P'
      || ZLGD.efld_opt('RED_P','mark=1',VAR1,'P_NAZ');
         ZLGD.efld_opt('RED_P','mark=0',,'B','KOD')
      || ZLGD.efld_opt('RED_P','mark=0',VAR1,'P_NAZ');
         ZLGD.efld_opt('RED_P','mark=1',,'B','KOD')
      ?}
   ?}
|| ZLGD.win_edit('RED_KOOP')
?};

_msg_gen:='Na część lub całość wyrobu został wygenerowany dokument produkcyjny.\nModyfikacje nie są możliwe.'@;
_msg_sta:=
   'Zwiększono ilość wykonaną do pozycji przewodnika, a kolejna operacja oznaczona jest jako zakończona.\n'
   'Jeżeli wymagana jest rejestracja kolejnej operacji, to należy jej status zmienić ręcznie.'@;

_kj_bad:=ZLGD.ZGP().KJ_BAD;
{? _kj_bad='N'
|| VAR1.IL:=ZLGD.IL;
   VAR1.IL_BRAK:=ZLGD.IL_BRAK;
   VAR1.BRAKI_R:=ZLGD.BRAKI_R
|| VAR1.IL:=ZLGD.DEK_IL;
   VAR1.IL_BRAK:=ZLGD.DEK_BR;
   VAR1.BRAKI_R:=ZLGD.DEK_RBR
?};

_zlgd_il:=VAR1.IL;
_time_p:=ZLGD.TIME_P;

{? var_pres('Akord')>100
|| Akord.NTIME:=ZLGD.ZGP().NTIME;
   Akord.MTIME:=ZLGD.ZGP().MTIME;
   Akord.IL_N:=ZLGD.ZGH().ILNPRZ
?};

exec('zlgd_efld_opt','zl_wyk');

{? ZLGD.BP='P'
|| {? VAR1.IL<>0 || zlgdil:=VAR1.IL || zlgdil:=0 ?};
   {? ZLGD.TIME<>0 || _zlgdti:=ZLGD.TIME || _zlgdti:=0 ?};
   {? ZLGD.ST<>0 || _zlgdst:=ZLGD.ST || _zlgdst:=0 ?};
   {? _ilegen<>0
   || FUN.emsg(_msg_gen)
   ||
      {? {? VAR1.REJ_WYR='T' || _env.TAB_P.select() || ZLGD.edit("exec('chk_rec_zlgd','zl_wyk')") ?}
      ||
         {? ZLGD.put()
         ||
            _edit_ok:=1;

            {? ZLGD.BP='P'
            ||
               ZLGB.index('ZLGD');
               ZLGB.prefix(ZLGD.ref());
               {? ZLGB.first()
               ||
                  ZLGB.P:=ZLGD.P;
                  ZLGB.ST:=exec('zlgb_st','zl_wyk',ZLBS.P);
                  ZLGB.TIME:=ZLGD.TIME;
                  ZLGB.TIME_P:=ZLGD.TIME_P;
                  ZLGB.IL:=ZLGD.IL;
                  ZLGB.IL_BRAK:=ZLGD.IL_BRAK;
                  ZLGB.DEK_IL:=ZLGD.DEK_IL;
                  ZLGB.DEK_BR:=ZLGD.DEK_BR;
                  ZLGB.KW:=ZLGD.KW;
                  ZLGB.R:=ZLGD.R;
                  ZLGB.put()
               ?}
            ?};

            {? ZLGD.ZGP().TPZ='N' & _time_p<>ZLGD.TIME_P
            || {? ZL.seek(ZLGD.ZL)
               ||
                  ZL.HWYK:=ZL.HWYK-_time_p+ZLGD.TIME_P;
                  ZL.put();
                  {? ZL.NRNZL<>0
                  || ZL.cntx_psh();
                     ZL.index('UNRZL');
                     ZL.prefix(ZL.NRNZL);
                     {? ZL.first()
                     || ZL.HWYK:=ZL.HWYK-_time_p+ZLGD.TIME_P;
                        ZL.put
                     ?};
                     ZL.cntx_pop()
                  ?}
               ?}
            ?};
::          Aktualizacja ZL_WYRGD (zapisów robocizny w rozbiciu na wyroby)
            {? VAR1.REJ_WYR='T'
            || exec('zl_wyrgd_from_tab','zl_wyr')
            ?};
            {? ZLGD.IL>_zlgd_il & exec('get','#params',500631,2)<>'N'
            || _sta_end:=exec('status_end','zl_guide');
               _status:='';
               _next:=exec('tab_zgp_next','zl_guide',ZLGD.ZGP);
               {? _next.first()
               || {!
                  |? {? _next.STATUS=_sta_end || _status:=_sta_end ?};
                     _status<>_sta_end & _next.next()
                  !}
               ?};
               {? _status=_sta_end || FUN.info(_msg_sta) ?}
            ?}
         ?}
      ?}
   ?}
|| ZLGB.index('ZLGD');
   ZLGB.prefix(ZLGD.ref());
:: Rejestracja akordu - rozliczania godzinowe operacji brygadowych - parametr 500600='T'
   {? (ZLGD.IL=0 & ZLGD.IL_BRAK=0 & ZLGD.DEK_IL=0 & ZLGD.DEK_BR=0)
      | exec('get','#params',500600,2)='T'
      | ZLGD.ZGP().TPZ='T'
      | ZGP.NRZLP().ZLEC().TYP().WP='W'
   || ZLGB.win_sel('WERG')
   || ZLGB.win_sel('WER')
   ?};

   ZLGB.win_edit('RED');
   {? ZLGD.ILGEN<>0
   || FUN.emsg(_msg_gen)
   || {? ZLGD.r_lock(1,1,1)
      || {? {? VAR1.REJ_WYR='T' || _env.TAB_P.select() || ZLGD.edit("exec('chk_rec_zlgd','zl_wyk')") ?}
         || {? ZLGD.put()
            ||
               _edit_ok:=1;

               raport:=ZLGD.IL;
               rapbrak:=ZLGD.IL_BRAK;

               {? ZLGB.first()
               || VAR.SUM_ZLGB:=0;
                  VAR.SUM_GBIL:=0;
                  VAR.SUM_GBIB:=0;
                  VAR.SUM_GBTI:=0;
                  VAR1.SUM_GDIL:=0;
                  VAR1.SUM_GDIB:=0;
                  {!
                  |?
                     VAR.SUM_ZLGB+=ZLGB.KW;
:: Rejestracja akordu - rozliczania godzinowe operacji brygadowych - parametr 500600='T'
                     {? exec('get','#params',500600,2)='T'
                     || VAR.SUM_GBIL:=ZLGD.IL;
                        VAR.SUM_GBIB:=ZLGD.IL_BRAK;
                        VAR1.SUM_GDIL:=ZLGD.DEK_IL;
                        VAR1.SUM_GDIB:=ZLGD.DEK_BR
                     || VAR.SUM_GBIL+=ZLGB.IL;
                        VAR.SUM_GBIB+=ZLGB.IL_BRAK;
                        VAR1.SUM_GDIL+=ZLGB.DEK_IL;
                        VAR1.SUM_GDIB+=ZLGB.DEK_BR
                     ?};
                     VAR.SUM_GBTI+=ZLGB.TIME;
                     ZLGB.next()
                  !}
               ?};
::             Aktualizacja ZL_WYRGD (zapisów robocizny w rozbiciu na wyroby)
               {? VAR1.REJ_WYR='T'
               || exec('zl_wyrgd_from_tab','zl_wyr')
               ?};
::
               {? ZLGD.ZGP().NTIME<>0 || ZLGB.select() ?};

               {? ZLGD.IL>_zlgd_il & exec('get','#params',500631,2)<>'N'
               || _sta_end:=exec('status_end','zl_guide');
                  _status:='';
                  _next:=exec('tab_zgp_next','zl_guide',ZLGD.ZGP);
                  {? _next.first()
                  || {!
                     |? {? _next.STATUS=_sta_end || _status:=_sta_end ?};
                        _status<>_sta_end & _next.next()
                     !}
                  ?};
                  {? _status=_sta_end || FUN.info(_msg_sta) ?}
               ?}
            ?}
         ?};
         ZLGD.r_unlock()
      ?}
   ?}
?};

:: Jezeli stawka zadana jest zerowa, to sumujemy kwoty
{? _edit_ok & ZLGD.ST=0
|| ZLGD.KW:=0;
   ZLGB.index('ZLGD');
   ZLGB.prefix(ZLGD.ref());
   {? ZLGB.first()
   || {!
      |? ZLGD.KW+=ZLGB.KW;
         ZLGB.next()
      !};
      ZLGD.put()
   ?}
?};

ZLGB.clear();
{? VAR1.REJ_WYR='T'
|| VAR1.REJ_WYR:='N';
   VAR_DEL.delete('__ENV_WYR','__valid')
?};
exec('oblicz_zgh_1zl','zl_wyk',ZLGD.ZL);

exec('blk_unlock','#table','ZGH',ZLGD.ZGH);

_edit_ok


\chk_rec_zlgd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Kontrola poprawnosci rekordu ZLGD
::   WE: _a - Wyjście komunikatów [0] - FUN, 1 - KOMM (wymagany wcześniej utworzony obiekt KOMM)
::   WY: '' lub akronim pola
::  OLD: \chk_rec_zlgd/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
_res:='';
_komm:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_txt:={? VAR1.KN3='N'
      || 'Wystąpił błąd podczas walidacji danych. Komunikat błędu: '@
      || ''
      ?};
{? ZLGD.ZL().OD>ZLGD.DT
|| {? _komm>0
   || _txt+='Zlecenie powołane z późniejszą datą.'@
   || FUN.emsg('Zlecenie powołane z późniejszą datą.'@)
   ?};
   _res:='DT'
?};

{? _res=''
|| {? ZLGD.ZGH=null()
   || {? exec('be_zgh_zlgd','zl_wyk')
      || _res:='ZGH'
      || _res:='ZGP'
      ?}
   ?}
?};

{? _komm>0
|| {? _res=''
   || {? ZLGD.BP='P'
      || {? ZLGD.ZGP().NTIME<>0 & VAR1.P_NAZ=''
         || _res:='P_NAZ';
            _txt+='Należy wskazać pracownika.'@
         ?}
      || {? ZLGD.B=null()
         || _res:='B';
            _txt+='Należy wskazać brygadę'@
         ?}
      ?}
   ?}
|| {? _res=''
   || {? ZLGD.BP='P'
      || _res:=__CHK.record(ZLGD,,'ZL2','TIMEP');
         {? _res='' & ZLGD.ZGP().NTIME<>0 || _res:=__CHK.record(VAR1,,'P_NAZ') ?}
      || _res:=__CHK.record(ZLGD,,'ZL2','TIMEP','B')
      ?}
   ?}
?};

_tpz:=ZLGD.ZGP().TPZ;
_wp:=ZLGD.ZL().TYP().WP;
_kj:=~(ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T');

{? _res=''
   & _tpz<>'T'
   & _wp='P'
::   & exec('get','#params',500602,2)='N'
   & {? ~_kj
     || (ZLGD.IL+ZLGD.IL_BRAK+ZLGD.DEK_IL+ZLGD.DEK_BR<=0 | ZLGD.IL+ZLGD.DEK_IL<0 | ZLGD.IL_BRAK+ZLGD.DEK_BR<0)
     || (ZLGD.DEK_IL+ZLGD.DEK_BR<=0 | ZLGD.DEK_IL<0 | ZLGD.DEK_BR<0)
     ?}
|| {? _komm>0
   || _txt+='Łączna ilość (dobre + braki) musi być większa od zera.'@
   || FUN.emsg('Łączna ilość (dobre + braki) musi być większa od zera.'@)
   ?};
   _res:='IL'
|? ZLGD.TIME<=0 & ZLGD.ZGP().NTIME<>0
|| {? _komm>0
   || _txt+='Czas musi być większy od zera.'@
   || FUN.emsg('Czas musi być większy od zera.'@)
   ?};
   _res:='TIME'
?};

{? _res=''
   & _tpz<>'T'
   & _wp='P'
   & {? ~_kj || ZLGD.IL=0 || ZLGD.DEK_IL=0 ?}
   & {? ~_kj || ZLGD.IL_BRAK=0 || ZLGD.DEK_BR=0 ?}
   & ZLGD.OK='T'
|| {? _komm>0
   || _txt+='Zakończyć można tylko operację z wpisaną ilością.'@
   || FUN.emsg('Zakończyć można tylko operację z wpisaną ilością.'@)
   ?};
   _res:='OK'
?};

{? _res=''
   & {? ~_kj || ZLGD.IL<0 || ZLGD.DEK_IL<0 ?}
|| {? _komm>0
   || _txt+='Ilość nie może być ujemna.'@
   || FUN.emsg('Ilość nie może być ujemna.'@)
   ?};
   _res:='IL'
?};

{? _res=''
   & {? ~_kj || ZLGD.IL_BRAK<0 || ZLGD.DEK_BR<0 ?}
|| {? _komm>0
   || _txt+='Ilość braków nie może być ujemna.'@
   || FUN.emsg('Ilość braków nie może być ujemna.'@)
   ?};
   _res:='IL'
?};

:: Kontrola zgodności ilości na przewodniku (parametry 500631, 500634)
{? _res=''
   & _tpz<>'T'
   & _wp='P'
   & {? ~_kj || ZLGD.IL>0 | ZLGD.IL_BRAK>0 || ZLGD.DEK_IL>0 | ZLGD.DEK_BR>0 ?}
   & (_result:=exec('chk_il_pop','zl_wyk'); _result.RES=0)
|| _msg:=_result.TXT;
   {? _komm=0
   || FUN.emsg(_msg)
   ?};
   _txt+=gsub(_msg,'\n',' ');
   _res:='IL'
?};

:: Kontrola partii
{? _res='' & VAR1.REJ_WYR<>'T'
||
:: Sprawdzam czy pole z partią musi być wypełnione
   _party_req:=exec('party_req','zl_wyk',ZLGD.ZL);
   {? _party_req>0
   ||
      {? ZLGD.ZPARN=null()
      || _party_zl:=exec('party_first','zl_link',ZLGD.ZL);
         _zl_sym:=exec('record','#to_string',_party_zl);
         _msg:='Zlecenie: %1 jest partiowane.\n'
               'Należy wskazać partię do której zostanie przypisana rejestrowana robocizna.'@[_zl_sym];
         {? _komm=0
         || FUN.emsg(_msg)
         ?};
         _txt+=gsub(_msg,'\n',' ');
         _res:='ZPARN'
      ?}
   ?}
?};
:: Kontrola stanowiska
{? _res='' & ZLGD.ZGP().WEW='T' & ZLGD.PLACE=null()
|| {? _komm>0
   || _txt+='Należy wskazać stanowisko, na którym została wykonana operacja.'@
   || FUN.emsg('Należy wskazać stanowisko, na którym została wykonana operacja.'@)
   ?};
   _res:='PLACE'
?};
:: Kontrola rodzaju braku
{? _res='' & (ZLGD.IL_BRAK>0 | ZLGD.DEK_BR>0) & exec('get','#params',500635,2)='T' & VAR1.BRAKI_R=null()
|| {? _komm>0
   || _txt+='Należy określić rodzaj braku.'@
   || FUN.emsg('Należy określić rodzaj braku.'@)
   ?};
   _res:='BRAKI_R'
?};

{? _komm>0 & _res<>''
|| KOMM.add(_txt,5)
?};
_res


\be_zgh_zlgd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.53] Uwaga 73
:: OPIS: przed redakcja pola ZLGD.ZGH
::       jezeli jest jeden przewodnik do zlecenia, to go wpisuje
::       i pole pozostaje niereadgowalne
::  OLD: \be_zgh_zlgd/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('in_prod_rej','prod_rej')
|| 0
|? ZLGD.ZL<>null()
|| ZGH.index('ZLNR');
   ZGH.prefix(ZLGD.ZL);
   {? ZGH.first() & ~ZGH.next()
   || ZLGD.ZGH:=ZGH.ref();
      {? ZLGD.ZL().NRNZL<>0
      || VAR.A_NRZLP:=ZGH.ref();
         ZGP.index('PNRPP');
         ZGP.prefix(ZGH.ref());
         ZGP.first();
         VAR.A_NRPRZ:=ZGP.NRPRZ
      || VAR.A_NRZLP:=ZGH.ref();
         VAR.A_NRPRZ:=ZGH.ref()
      ?};

      _party_req:=exec('party_req','zl_wyk',ZLGD.ZL);
      {? _party_req>0
      ||
         _party_zgh:=exec('party_first_zgh','zl_guide',ZLGD.ZGH);
         {? _party_zgh<>null()
         ||
            ZPARN.cntx_psh();
            ZPARN.index('ZGH');
            ZPARN.prefix(_party_zgh);
            {? ZPARN.size()=1
            || {? ZPARN.first()
               || ZLGD.ZPARN:=ZPARN.ref()
               ?}
            ?};
            ZPARN.cntx_pop()
         ?}
      ?};

      win_disp();
      0
   || 1
   ?}
|| 1
?}


\zlgb_st
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wylicza stawke ZLGB.ST
::   WE: _a - P.ref()
::       Kontekst pracy - aktualny rekord tabeli ZLGD
::  OLD: \zlgb_st/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_prac:=_a;

_res:=0;

_po:=ZLGD.ZGP().PO;
_wp:=ZLGD.ZGH().ZLEC().TYP().WP;
_tpz:=ZLGD.ZGP().TPZ;

_res:={? _po='P'
      || exec('stawka','zl_wyk',_prac,ZLGD.DT,'S1')
      || {? _tpz='T' | _wp='W'
         || ZLGD.ST
         || ZLGD.PLNH
         ?}
      ?};
_res


\stawka
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2010]
:: OPIS: Zwraca wartosc stawki zaszeregowania pracownika z historii zatrudnienia
::   WE: _a - P.ref()
::       _b - data
::       _c - rodzaj stawki - akronim pola w historii zatrudnienia ('S1', 'S2', 'S3')
::   WY: wartosc pola
::  OLD: \stawka/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_char:=exec('FindAndGet','#table',P,_a,,"CP().S",'');
{? 1+_char='F'
||
   H.index('_HISTDAT');
   H.prefix(_a);
   {? H.last()
   || _can_continue:=1;
      {!
      |? {? H.OD<=_b  & (H.DO=date(0,0,0) | _b<=H.DO)
         || _result:=($('H.'+_c))();
            _can_continue:=0
         ?};
         _can_continue & H.prev()
      !}
   ?}
?};
_result


\wyswietl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: 'Wyswietl' w oknie wertowania podgladu godzin pracownikow
::       Kontekst: rekord ZLGB
::  OLD: \wyswietl/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
ZLGD.clear();
{? ZLGD.seek(ZLGB.ZLGD)
||
   VAR.AK_DAT:=1;
   {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T'
   || VAR1.IL:=ZLGD.IL;
      VAR1.IL_BRAK:=ZLGD.IL_BRAK;
      VAR1.BRAKI_R:=ZLGD.BRAKI_R
   || VAR1.IL:=ZLGD.DEK_IL;
      VAR1.IL_BRAK:=ZLGD.DEK_BR;
      VAR1.BRAKI_R:=ZLGD.DEK_RBR
   ?};
   ZLGB.P();
   ZLGD.win_edit('RED_B');
   ZLGD.display()
|| 0
?}


\zgi
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Zwraca informację, czy są ilości zarejestrowane do zlecenia
::   WE: _a - ZL.ref()
::   WY: 0 / 1
::  OLD: \zgi/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
ZGP.cntx_psh();
ZGP.index('ZLEC');
ZGP.prefix(_a);
{? ZGP.first()
|| {!
   |? {? ZGP.IL<>0 | ZGP.IL_BRAK<>0 | ZGP.DEK_IL<>0 | ZGP.DEK_BR<>0 || ZGP.cntx_pop(); return(1) ?};
      ZGP.next()
   !}
?};
ZGP.cntx_pop();
0


\zgp_oddane
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Zwraca informację, czy przewodniki są oddane
::   WE: _a - ZL.ref()
::   WY: 0 / 1
::  OLD: \zgp_oddane/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
ZGH.cntx_psh();
ZGH.index('ZLNR');
ZGH.prefix(_a);
{? ZGH.first()
|| {!
   |? {? ZGH.STAN='T' || ZGH.cntx_pop(); return(1) ?};
      ZGH.next()
   !}
?};
ZGH.cntx_pop();
0


\update_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Aktualizacja tabel PROD_REJ i PROD_NXT
::       na podstawie zmian w tabelach ZGP, NASZGP, ZGH, ZL, KAP, ZLGD, GROP (obsługa triggerów)
::   WE: _a - rodzaj triggera: 'add', 'put', 'del'
::       _b - tabela: ZGP, NASZGP, ZGH, ZL, KAP, ZLGD, GROP
::   WY: wynik sterujacy dla triggera, czyli ~~ albo 0/1
::  OLD: \update_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? _b=ZGP
||
   {? _a='add'
   ||
      Cntx.psh(PROD_REJ,PROD_NXT,ZGH,ZL);

::    UWAGA: Podczytanie ZGH zlecenia podrzędnego oraz zlecenia podrzędnego
      ZGP.NRZLP().ZLEC();

::    Pominięcie przewodników technicznych
      {? ZGH.KIND='T' || Cntx.pop(PROD_REJ,PROD_NXT,ZGH,ZL); return() ?};

      PROD_REJ.clear();
      PROD_REJ.blank(1);
      {? ZGP.WEW='T'
      || PROD_REJ.STARTD:={? ZGP.STARTD=date(0,0,0) || ZL.OD || ZGP.STARTD ?};
         PROD_REJ.STARTT:=ZGP.STARTT;
         PROD_REJ.ENDD:={? ZGP.ENDD=date(0,0,0) || ZL.DTR || ZGP.ENDD ?};
         PROD_REJ.ENDT:=ZGP.ENDT
      || PROD_REJ.STARTD:={? ZGP.STARTDK=date(0,0,0) || ZL.OD || ZGP.STARTDK ?};
         PROD_REJ.STARTT:=ZGP.STARTTK;
         PROD_REJ.ENDD:={? ZGP.ENDDK=date(0,0,0) || ZL.DTR || ZGP.ENDDK ?};
         PROD_REJ.ENDT:=ZGP.ENDTK
      ?};
      exec('fields_4rej','zl_wyk');
      PROD_REJ.WYD:=exec('wyd','zl_guide');
      PROD_REJ.PRIORITY:='N';
      PROD_REJ.SRODZ:='ZL';
      PROD_REJ.SOURCE:=$ZGP.ref();
      PROD_REJ.ZL:=ZL.ref();
      PROD_REJ.ZGH:=ZGH.ref();
      PROD_REJ.ZGP:=ZGP.ref();
      PROD_REJ.M:=ZL.KTM;
      PROD_REJ.JM:=ZL.KTM().J;
      {? ZGP.WEW='T'
      || PROD_REJ.RES_SYM:=ZGP.PLACE().KOD;
         PROD_REJ.RES_NAZ:=TWRKPLC.NA
      || PROD_REJ.RES_SYM:='{KOOPERACJA}';
         PROD_REJ.RES_NAZ:='Kooperacja'
      ?};
      PROD_REJ.KH:=ZGP.KONTRAH;
      PROD_REJ.GKTL:=ZGP.NRPRZ().GKTL;
      PROD_REJ.IL:=ZGP.ILOSC;
      PROD_REJ.ILC:=ZGP.ILOSC;
      PROD_REJ.START:='N';
      PROD_REJ.OK:='N';
      PROD_REJ.POTW:='N';
      PROD_REJ.PROBLEM:='N';
      PROD_REJ.PROBKLAS:='';
      PROD_REJ.PRAC:='N';
      PROD_REJ.BRYG:='N';
      PROD_REJ.KOOP:={? ZGP.WEW='T' || 'N' || 'T' ?};
      PROD_REJ.RP:='N';
      PROD_REJ.IL_KAP:=exec('prod_rej_il_kap','prod_rej');
      {? ZGP.DOK<>null()
      || PROD_REJ.RP:='T'
      ?};
      PROD_REJ.A:={? ZL.STAN='O' & ZGH.STAN='N' || 'T' || 'N' ?};
      PROD_REJ.DOREJ:={? ZGP.STATUS=exec('status_pending','zl_guide') || 'T' || 'N' ?};
      PROD_REJ.KONTROLA:={? ZGP.KONTROLA='T' || 'T' || 'N'?};
      PROD_REJ.KJ_BAD:=ZGP.KJ_BAD;
      {? PROD_REJ.add(1)
      ||
         _prod_rej:=PROD_REJ.ref();
         PROD_NXT.clear();

::       Dodanie następnika, jeżeli operacja Tpz
         {? ZGP.TPZ='T'
         || ZGP.cntx_psh();
            ZGP.index('UID');
            ZGP.prefix(ZGP.UID_TPZ);
            {? ZGP.first()
            ||
               PROD_NXT.blank(1);
               PROD_NXT.PROD_REJ:=PROD_REJ.ref();
               PROD_REJ.index('ZGP');
               PROD_REJ.prefix('ZL',ZGP.ref());
               {? PROD_REJ.first()
               ||
                  PROD_NXT.NEXT:=PROD_REJ.ref();
                  PROD_NXT.add(1)
               ?}
            ?};
            ZGP.cntx_pop()
         ?}
      ?};

      Cntx.pop(PROD_REJ,PROD_NXT,ZGH,ZL);
::    Aktualizacja pól ZGH.W_FIRST i ZGH.W_LAST
      {? ZGP.WHERE<>'W'
      || ZGH.cntx_psh();
         ZGP.NRPRZ();
         {? ZGP.WHERE='P' & ZGH.W_FIRST='N'
         || ZGH.W_FIRST:='T';
            ZGH.put()
         |? ZGP.WHERE='O' & ZGH.W_LAST='N'
         || ZGH.W_LAST:='T';
            ZGH.put()
         ?};
         ZGH.cntx_pop()
      ?};
      ~~
   |? _a='put'
   ||
      Cntx.psh(PROD_REJ,ZGH,ZL);

::    UWAGA: Podczytanie ZGH zlecenia podrzędnego oraz zlecenia podrzędnego
      ZGP.NRZLP().ZLEC();

::    Pominięcie przewodników technicznych
      {? ZGH.KIND='T' || Cntx.pop(PROD_REJ,ZGH,ZL); return() ?};

      PROD_REJ.index('ZGP');
      PROD_REJ.prefix('ZL',ZGP.ref());
      {? PROD_REJ.first()
      ||
         {? ZGP.WEW='T'
         || PROD_REJ.STARTD:={? ZGP.STARTD=date(0,0,0) || ZL.OD || ZGP.STARTD ?};
            PROD_REJ.STARTT:=ZGP.STARTT;
            PROD_REJ.ENDD:={? ZGP.ENDD=date(0,0,0) || ZL.DTR || ZGP.ENDD ?};
            PROD_REJ.ENDT:=ZGP.ENDT
         || PROD_REJ.STARTD:={? ZGP.STARTDK=date(0,0,0) || ZL.OD || ZGP.STARTDK ?};
            PROD_REJ.STARTT:=ZGP.STARTTK;
            PROD_REJ.ENDD:={? ZGP.ENDDK=date(0,0,0) || ZL.DTR || ZGP.ENDDK ?};
            PROD_REJ.ENDT:=ZGP.ENDTK
         ?};
         PROD_REJ.WYD:=exec('wyd','zl_guide');
         exec('fields_4rej','zl_wyk');
::         PROD_REJ.PRIORITY:='N';
         {? ZGP.WEW='T'
         ||
            PROD_REJ.RES_SYM:=ZGP.PLACE().KOD;
            PROD_REJ.RES_NAZ:=TWRKPLC.NA
         ||
            PROD_REJ.RES_SYM:='{KOOPERACJA}';
            PROD_REJ.RES_NAZ:='Kooperacja'
         ?};
         PROD_REJ.KH:=ZGP.KONTRAH;
         PROD_REJ.GKTL:=ZGP.NRPRZ().GKTL;
         _change:=ZGP.ILOSC-PROD_REJ.ILC;
         PROD_REJ.IL+=_change;
         PROD_REJ.ILC:=ZGP.ILOSC;
         PROD_REJ.A:={? ZL.STAN='O' & ZGH.STAN='N' || 'T' || 'N' ?};
         PROD_REJ.DOREJ:={? ZGP.STATUS=exec('status_pending','zl_guide') || 'T' || 'N' ?};
         PROD_REJ.OK:={? ZGP.STATUS=exec('status_end','zl_guide') || 'T' || 'N' ?};
::       Sprawdzenie wykorzystania w grupach operacji
         {? ZGP.PL_GRP='T'
         || {? exec('FindInSet','#table','GROPP','ZGP',ZGP.ref(),,"1",,,0)
            || PROD_REJ.DOREJ:='N';
               PROD_REJ.A:='N'
            ?}
         ?};
         PROD_REJ.PROBLEM:={? ZGH.PROBLEM='T' || 'T' || ZGP.PROBLEM ?};
         PROD_REJ.PROBKLAS:={? ZGH.PROBLEM='T' || exec('prob_class_blocking','zl_wkj') || ZGP.PROBKLAS ?};
         PROD_REJ.KONTROLA:={? ZGP.KONTROLA='T' || 'T' || 'N' ?};
         PROD_REJ.KJ_BAD:=ZGP.KJ_BAD;
         PROD_REJ.IL_KAP:=exec('prod_rej_il_kap','prod_rej');
         PROD_REJ.put()
      ?};

      Cntx.pop(PROD_REJ,ZGH,ZL);
      ~~
   |? _a='del'
   ||
::    Przed usunięciem pozycji przewodnika usuwany jest zapis PROD_REJ i ewentualnie PROD_NXT do niego
      Cntx.psh(PROD_REJ);

      PROD_REJ.index('ZGP');
      PROD_REJ.prefix('ZL',ZGP.ref());
      {? PROD_REJ.first()
      ||
         PROD_NXT.index('PROD_REJ');
         PROD_NXT.prefix(PROD_REJ.ref());
         {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};
         PROD_NXT.index('NEXT');
         PROD_NXT.prefix(PROD_REJ.ref());
         {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};
         PROD_REJ.del()
      ?};
      _res:=~PROD_REJ.first();

      Cntx.pop(PROD_REJ);
      _res
   ?}

|? _b=NASZGP
||
   {? _a='add'
   ||
::    Po dodaniu następnika dołączane są zapisy PROD_NXT
      Cntx.psh(PROD_REJ,PROD_NXT,ZGP,GROPP);
      Cntx.clr(PROD_NXT);

::    1) Połączenie wg NASZGP między ZGP a ZGP - uwzględnia Tpz
      PROD_REJ.index('ZGP');
      PROD_REJ.prefix('ZL',NASZGP.OPER);
      {? PROD_REJ.first()
      ||
         _prod_rej:=PROD_REJ.ref();

         PROD_NXT.blank(1);
         PROD_NXT.PROD_REJ:=PROD_REJ.ref();
         PROD_REJ.prefix('ZL',NASZGP.NRNAST);
         {? PROD_REJ.first()
         ||
::          Jeżeli następnik ma Tpz, to biorę go w zamian tego następnika
            _prod_rej:=PROD_REJ.ref();
            ZGP.index('TPZ');
            ZGP.prefix('T',NASZGP.NRNAST().UID);
            {? ZGP.first()
            || PROD_REJ.index('ZGP');
               PROD_REJ.prefix('ZL',ZGP.ref());
               {? PROD_REJ.first()
               || _prod_rej:=PROD_REJ.ref()
               ?}
            ?};
            PROD_NXT.NEXT:=_prod_rej;
            PROD_NXT.add(1)
         ?}
      ?};

::    2) Połączenie wg NASZGP między GROPP dla danego ZGP (poprzednika) a ZGP (następnika)
      PROD_REJ.index('GROP');
      GROPP.index('ZGP');
      GROPP.prefix(NASZGP.OPER);
      {? GROPP.first()
      || {!
         |? PROD_REJ.prefix('ZL',GROPP.GROP);
            {? PROD_REJ.first()
            || PROD_NXT.blank(1);
               PROD_NXT.PROD_REJ:=PROD_REJ.ref();
               PROD_REJ.index('ZGP');
               PROD_REJ.prefix('ZL',NASZGP.NRNAST);
               {? PROD_REJ.first()
               || PROD_NXT.NEXT:=PROD_REJ.ref();
                  PROD_NXT.add(1)
               ?}
            ?};
            GROPP.next()
         !}
      ?};

::    3) Połączenie wg NASZGP między ZGP (poprzednika) a GROPP dla danego ZGP (następnika)
      PROD_REJ.index('ZGP');
      PROD_REJ.prefix('ZL',NASZGP.OPER);
      {? PROD_REJ.first()
      || _prod_rej:=PROD_REJ.ref();
         GROPP.index('ZGP');
         GROPP.prefix(NASZGP.NRNAST);
         {? GROPP.first()
         || {!
            |? PROD_REJ.index('GROP');
               PROD_REJ.prefix('ZL',GROPP.GROP);
               {? PROD_REJ.first()
               || PROD_NXT.PROD_REJ:=_prod_rej;
                  PROD_NXT.NEXT:=PROD_REJ.ref();
                  PROD_NXT.add(1)
               ?};
               GROPP.next()
            !}
         ?}
      ?};

      Cntx.pop(PROD_REJ,PROD_NXT,ZGP,GROPP);
      ~~
   |? _a='put'
   ||
      ~~
   |? _a='del'
   ||
::    Przed usunięciem następnika usuwane są zapisy PROD_NXT
      Cntx.psh(PROD_REJ,PROD_NXT,GROPP);

      _result:=0;

      PROD_REJ.index('ZGP');

      _to:=null();
      PROD_REJ.prefix('ZL',NASZGP.NRNAST);
      {? PROD_REJ.first()
      || _to:=PROD_REJ.ref()
      ?};

      _from:=null();
      PROD_REJ.prefix('ZL',NASZGP.OPER);
      {? PROD_REJ.first()
      || _from:=PROD_REJ.ref()
      ?};

      PROD_NXT.index('PROD_REJ');

::    1) Połączenie wg NASZGP między ZGP a ZGP - uwzględnia Tpz
      PROD_NXT.prefix(_from,_to);
      {? PROD_NXT.first() || PROD_NXT.del() ?};
      _result:=(PROD_NXT.size()=0);

::    2) Połączenie wg NASZGP między GROPP dla danego ZGP (poprzednika) a ZGP (następnika)
      GROPP.index('ZGP');
      GROPP.prefix(NASZGP.OPER);
      {? GROPP.first()
      || {!
         |? PROD_REJ.index('GROP');
            PROD_REJ.prefix('ZL',GROPP.GROP);
            {? PROD_REJ.first()
            || PROD_NXT.prefix(PROD_REJ.ref(),_to);
               {? PROD_NXT.first() || PROD_NXT.del() ?};
               _result:=(PROD_NXT.size()=0)*_result
            ?};
            GROPP.next()
         !}
      ?};

::    3) Połączenie wg NASZGP między ZGP (poprzednika) a GROPP dla danego ZGP (następnika)
      GROPP.index('ZGP');
      GROPP.prefix(NASZGP.NRNAST);
      {? GROPP.first()
      || {!
         |? PROD_REJ.index('GROP');
            PROD_REJ.prefix('ZL',GROPP.GROP);
            {? PROD_REJ.first()
            || PROD_NXT.prefix(_from,PROD_REJ.ref());
               {? PROD_NXT.first() || PROD_NXT.del() ?};
               _result:=(PROD_NXT.size()=0)*_result
            ?};
            GROPP.next()
         !}
      ?};

      Cntx.pop(PROD_REJ,PROD_NXT,GROPP);
      _result
   ?}

|? _b=ZGH
||
:: Po poprawieniu nagłówka przewodnika aktualizacja ilości w PROD_REJ
:: Dla 'add' i 'del' nic nie robimy, bo nie ma ZGP a tym bardziej PROD_REJ
   {? _a='put'
   ||
      Cntx.psh(PROD_REJ,ZL,ZGP);

      PROD_REJ.index('ZGH');
      PROD_REJ.prefix('ZL',ZGH.ref());
      {? PROD_REJ.first()
      || {!
         |? {? PROD_REJ.ZGP<>null()
            || _change:=PROD_REJ.ZGP().ILOSC-PROD_REJ.ILC
            || _change:=ZGH.ILNPRZ-PROD_REJ.ILC
            ?};
::          nie zmieniane: PROD_REJ.ILW
            PROD_REJ.IL+=_change;
            {? PROD_REJ.ZGP<>null()
            || PROD_REJ.ILC:=PROD_REJ.ZGP().ILOSC
            || PROD_REJ.ILC:=ZGH.ILNPRZ
            ?};
            PROD_REJ.A:={? ZGH.ZLEC().STAN='O' & ZGH.STAN='N' || 'T' || 'N' ?};
            PROD_REJ.IL_KAP:=exec('prod_rej_il_kap','prod_rej');
            PROD_REJ.PROBLEM:={? ZGH.PROBLEM='T' || 'T' || ZGP.PROBLEM ?};
            PROD_REJ.PROBKLAS:={? ZGH.PROBLEM='T' || exec('prob_class_blocking','zl_wkj') || ZGP.PROBKLAS ?};
            PROD_REJ.put();
            PROD_REJ.next()
         !}
      ?};

      Cntx.pop(PROD_REJ,ZL,ZGP);
      ~~
   |? _a='del'
   ||
::    Przed usunięciem przewodnika usuwane są wszystkie z nim skojarzone zapisy PROD_REJ (o ile pozostały)
      Cntx.psh(PROD_REJ,PROD_NXT);

      PROD_REJ.index('ZGH');
      PROD_REJ.prefix('ZL',ZGH.ref());
      {? PROD_REJ.first()
      || {!
         |? PROD_NXT.index('PROD_REJ');
            PROD_NXT.prefix(PROD_REJ.ref());
            {? PROD_NXT.first()
            || {! |? PROD_NXT.del() !}
            ?};
            PROD_NXT.index('NEXT');
            PROD_NXT.prefix(PROD_REJ.ref());
            {? PROD_NXT.first()
            || {! |? PROD_NXT.del() !}
            ?};
            PROD_REJ.del()
         !}
      ?};
      _res:=~PROD_REJ.first();

      Cntx.pop(PROD_REJ,PROD_NXT);
      _res
   ?}

|? _b=ZL
||
:: Po zamknięciu zlecenia nadrzędnego - usuwanie PROD_REJ, przy otwarciu awaryjnym - odtworzenie.
:: Po poprawieniu zlecenia aktualizacja dat i stanu aktywnosci PROD_REJ
:: Dla 'add' i 'del' nic nie robimy, bo nie ma ZGP a tym bardziej PROD_REJ
   {? _a='put'
   ||
      Cntx.psh(PROD_REJ,ZGH,ZGP);

      {? ZL.STAN='Z'
      || {? bfld('STAN')<>'Z' || exec('del_4rej','zl_wyk',ZL.ref()) ?}
      |? bfld('STAN')='Z'
      || exec('load_one4rej','zl_wyk',ZL.ref())
      || PROD_REJ.index('ZL');
         PROD_REJ.prefix('ZL',ZL.ref());
         {? PROD_REJ.first()
         || {!
            |?
               {? PROD_REJ.ZGP().STARTD=date(0,0,0) || PROD_REJ.STARTD:=ZL.OD ?};
               {? PROD_REJ.ZGP().ENDD=date(0,0,0) || PROD_REJ.ENDD:=ZL.DTR ?};
               PROD_REJ.A:={? ZL.STAN='O' & PROD_REJ.ZGH().STAN='N' || 'T' || 'N' ?};
::             Sprawdzenie wykorzystania w grupach operacji
               {? ZGP.PL_GRP='T'
               || {? exec('FindInSet','#table','GROPP','ZGP',ZGP.ref(),,"1",,,0)
                  || PROD_REJ.DOREJ:='N';
                     PROD_REJ.A:='N'
                  ?}
               ?};
               PROD_REJ.put();
               PROD_REJ.next()
            !}
         ?}
      ?};

      Cntx.pop(PROD_REJ,ZGH,ZGP);
      ~~
   ?}

|? _b=ZLGD
||
:: Na podstawie rejestracji robocizny:
   {? _a='add' || _zgp:=ZLGD.ZGP; _grops:=ZLGD.GROPS;
                  _before:=0; _after:=ZLGD.IL; _bbefore:=0; _bafter:=ZLGD.IL_BRAK;
                  _potw:=ZLGD.POTW; _ok:=ZLGD.OK
   |? _a='put' || _zgp:=ZLGD.ZGP; _grops:=ZLGD.GROPS;
                  _before:=bfld('IL'); _after:=ZLGD.IL; _bbefore:=bfld('IL_BRAK'); _bafter:=ZLGD.IL_BRAK;
                  _potw:=ZLGD.POTW; _ok:=ZLGD.OK
   |? _a='del' || _zgp:=bfld('ZGP'); _grops:=bfld('GROPS');
                  _before:=bfld('IL'); _after:=0; _bbefore:=bfld('IL_BRAK'); _bafter:=0;
                  _potw:='N'; _ok:='N'
               || return()
   ?};

   Cntx.psh(PROD_REJ,ZGP,GROP);

:: - Aktualizacja ilosci - PROD_REJ.IL (ilość do wykonania), PROD_REJ.ILW (ilość wykonana), PROD_REJ.ILWB (ilość braków)
   {? _grops<>null()
   || PROD_REJ.index('GROPS');
      PROD_REJ.prefix('ZL',_grops);
      {? PROD_REJ.first()
      || PROD_REJ.ILW+=_after-_before;
         PROD_REJ.ILWB+=_bafter-_bbefore;
         PROD_REJ.IL-=_after-_before;
         PROD_REJ.OK:='N';
         {? _ok='T' || PROD_REJ.OK:='T' ?};
         {? PROD_REJ.IL<=0 || PROD_REJ.OK:='T' ?};
         PROD_REJ.POTW:=_potw;
         PROD_REJ.put()
      ?}
   || PROD_REJ.index('ZGP');
      PROD_REJ.prefix('ZL',_zgp);
      {? PROD_REJ.first()
      || PROD_REJ.ILW+=_after-_before;
         PROD_REJ.ILWB+=_bafter-_bbefore;
::         PROD_REJ.IL-=_after-_before;
         _zgp_il:=exec('FindAndGet','#table',ZGP,_zgp,,"ZGP.ILOSC",0);
         PROD_REJ.IL:=_zgp_il-PROD_REJ.ILW;
         {? PROD_REJ.IL<0 || PROD_REJ.IL:=0 ?};
::       Aktualizacja znacznika START (czy operacja rozpoczęta na e-kiosku)
         PROD_REJ.START:={? exec('czyStartProdRej','ekioski',0) || 'T' || 'N' ?};
::      {? PROD_REJ.IL<=0 || PROD_REJ.OK:='T' || PROD_REJ.OK:='N' ?};
         PROD_REJ.put()
      ?}
   ?};
::   _ilc:=PROD_REJ.ILC;
::   _ilw:=PROD_REJ.ILW;
::   _ilwb:=PROD_REJ.ILWB;
::   _il:=PROD_REJ.IL;

   Cntx.pop(PROD_REJ,ZGP,GROP);
   ~~

|? _b=KAP
||
:: Aktualizacja znacznika PROD_REJ.PRAC, PROD_REJ.BRYG, PROD_REJ.IL_KAP
   {? _a='add' | _a='put'
   ||
      Cntx.psh(PROD_REJ,KAP,ZGP);

      {? exec('zgp_is_kap','zl_kap',KAP.ZGP)>0
      || _kap:='T'
      || _kap:='N'
      ?};

      PROD_REJ.index('ZGP');
      PROD_REJ.prefix('ZL',KAP.ZGP);
      {? PROD_REJ.first()
      || {? PROD_REJ.ZGP().BRYG='T' || PROD_REJ.BRYG:=_kap || PROD_REJ.PRAC:=_kap ?};
         PROD_REJ.IL_KAP:=exec('prod_rej_il_kap','prod_rej');
         PROD_REJ.put()
      ?};

      Cntx.pop(PROD_REJ,KAP,ZGP);
      ~~
   |? _a='del'
   ||
      Cntx.psh(PROD_REJ,KAP,ZGP);

      {? exec('zgp_is_kap','zl_kap',bfld('ZGP'))>0
      || _kap:='T'
      || _kap:='N'
      ?};

      PROD_REJ.index('ZGP');
      PROD_REJ.prefix('ZL',bfld('ZGP'));
      {? PROD_REJ.first()
      || {? PROD_REJ.ZGP().BRYG='T' || PROD_REJ.BRYG:=_kap || PROD_REJ.PRAC:=_kap ?};
         PROD_REJ.IL_KAP:=exec('prod_rej_il_kap','prod_rej');
         PROD_REJ.put()
      ?};

      Cntx.pop(PROD_REJ,KAP,ZGP);
      ~~
   ?}
?}


\load_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ładuje dane do tabeli do rejestracji wykonań
::       Funkcja służy tylko do zainicjowania danych - na bieżąco działają triggery
::   WE: [_a] - ZL.ref() opcjonalnie, wtedy odtworzenie wskazanego zlecenia
::       [_b] - czy dialogi: 1 [domyslnie tak] / 0
::  OLD: \load_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null()) || _zlec:=_a   || _zlec:=null() ?};
{? var_pres('_b')=type_of(0)      || _dialog:=_b || _dialog:=1    ?};

ZL.cntx_psh();

_dalej:=0;
{? _zlec=null()
|| {? _dialog
   || _choice:=FUN.choice(
         'Czy zainicjować ponownie tabelę do rejestracji produkcji dla:\n\n'
         'UWAGA:\nW przypadku używania operacji grupowych należy wykonać\n'
         'następnie inicjowanie dla grup operacji.'@,,
         'Wybranego &zlecenia'@,'Wszystkich zleceń'@
      )
   || _choice:=2
   ?};

:: wybór zlecenia
   {? _choice=1
   || _wer:=ZL.mk_sel('Zlecenia'@,,,'wybierzzlecenie',,,,,'U');
      ZL.win_fld(_wer,,'SYM',,,15,,,'Symbol'@);
      ZL.win_fld(_wer,,'OPIS',,,40,,,'Opis'@);
      ZL.win_fld(_wer,,'STAN',,,-3,,,'Stan zlecenia: N-w przygotowaniu, Otwarte, Zamknięte'@);
      ZL.win_fld(_wer,,'RODZAJ',,,,,,'Rodzaj zlecenia'@);
      ZL.win_act(_wer,,'Formuła','Wybierz'@@,,,"sel_exit()",,1);
      ZL.win_sel(_wer);
      ZL.win_fml(_wer,,'STAN',,'ICON_BEFORE',"exec('icon_stan','zl_head')");
      ZL.win_edit();
      ZL.f_set('SYM',,'ZL.NRNZL=0 and ZL.SYM<>\'\'');
      {? ZL.select()
      || _zlec:=ZL.ref();
         _zl_sym:=ZL.SYM;
         _dalej:=1
      ?};
      ZL.f_clear()
:: wszystkie zlecenia (czy dać ograniczenia?)
   |? _choice=2
   || _dalej:=1
   ?}
||
   {? ZL.seek(_zlec)
   ||
      {? _dialog
      || _zl_sym:=ZL.SYM;
         _dalej:=FUN.ask('Czy zainicjować ponownie tabelę do rejestracji produkcji dla zlecenia: %1?'@[_zl_sym])
      || _dalej:=1
      ?}
   ?}
?};

{? _dalej
|| {? _zlec=null()
   || ZL.f_set('SYM',,'ZL.NRNZL=0 and ZL.SYM<>\'\'');
      {? ZL.f_first()
      || FUN.prg_start(ZL.f_size(),'Aktualizacja tabeli do rejestracji wykonań dla zleceń.'@,,,1);
         {!
         |? FUN.prg_next();
            exec('del_4rej','zl_wyk',ZL.ref());
            exec('load_one4rej','zl_wyk',ZL.ref());
            ZL.f_next()
         !};
         FUN.prg_stop()
      ?};
      ZL.f_clear()
   || echo(_zl_sym);
      exec('del_4rej','zl_wyk',_zlec);
      exec('load_one4rej','zl_wyk',_zlec)
   ?};

   {? _dialog
   || {? _zlec=null()
      || FUN.info('Zainicjowano tabelę do rejestracji produkcji dla zleceń.'@)
      || FUN.info('Zainicjowano tabelę do rejestracji produkcji dla zlecenia %1.'@[_zl_sym])
      ?}
   ?}
?};

ZL.cntx_pop();
''


\display_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa 'wyświetl' w oknie rejestracji wykonań - przewodnik/grupa operacji
::       Kontekst pracy: PROD_REJ
::  OLD: \display_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
ZGP.cntx_psh(); GROP.cntx_psh();
{? PROD_REJ.ZGP<>null()
|| PROD_REJ.ZGP();
   {? ZGP.TPZ='T'
   || ZGP.index('UID');
      ZGP.prefix(ZGP.UID_TPZ);
      ZGP.first();
      _tpz:=1
   || _tpz:=0
   ?};
   VAR.A_ZLEC:=ZGP.ZL;
   exec('przp_dsp','zl_guide');
   exec('zgp_efld_opt','zl_guide');
   {? VEK.TERM='T'
   || exec('uni_display','#desktop',ZGP,ZGP.win_edit('?'),'Pozycja przewodnika'@,0,0,'zgp1','maximized')
   || ZGP.display(,,,{? _tpz || 'NTIME1' || '' ?})
   ?}
|? PROD_REJ.GROP<>null()
|| PROD_REJ.GROP();
   exec('setGropsInfo','zl_grop');
   exec('grop_efld_opt','zl_grop');
   exec('filtrPlResGr','zl_grop');

   {? VEK.TERM='T'
   || exec('uni_display','#desktop',GROP,'RED','Grupa operacji'@,5,3,'grop','normal')
   || _red:=GROP.mk_edit('Grupa operacji'@);
      GROP.win_ewin(_red,,'RED');
      GROP.win_ebtn(_red,'text=%1,align=begin,display=1'['Pozycje'@],"exec('gropp_select','zl_grop')");
      GROP.win_ebtn(_red,'text=%1,align=begin,display=1'['Zasoby'@],"exec('grops_select','zl_grop')");
      GROP.win_edit(_red);
      GROP.display()
   ?}
?};
ZGP.cntx_pop(); GROP.cntx_pop();
~~


\mat_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Informacja o materiałach wyświetlana z poziomu rejestracji wykonań - przewodnik
::       Kontekst pracy: PROD_REJ
::  OLD: \mat_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
ZGP.cntx_psh();
ZGP.clear();
{? ZGP.seek(PROD_REJ.ZGP)
|| exec('mat_4zgp','zl_wyk')
|| FUN.error('Brak przewodnika.'@)
?};
ZGP.cntx_pop();
~~


\mat_4zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Informacja o materialach wyswietlana z poziomu pozycji przewodnika
::       Kontekst pracy: ZGP
::  OLD: \mat_4zgp/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
:: Kontekst zmiennej - lepiej obsluzyc, bo moga byc rozne miejsca wywolania
_a_zlec:=VAR.A_ZLEC;
VAR.A_ZLEC:=ZGP.NRZLP().ZLEC;

:: Aktualna wersja - wyswietla limity przypisane do pozycji przewodnika
exec('kart_lim','zl_limit',1,ZGP.NRZLP().ZLEC,'',,ZGP.ref());

VAR.A_ZLEC:=_a_zlec;
~~


\del_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Kasuje dane z tabeli do rejestracji wykonan - zapisy dotyczace rejestracji robocizny (ZL)
::   WE: _a - ZL.ref() kasuje dla wskazanego zlecenia z podzleceniami
::       (w polu PROD_REJ.ZL jest wskazanie na zlecenie glowne)
::  OLD: \del_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null()) || _zlec:=_a || return() ?};

Cntx.psh(PROD_REJ,PROD_NXT,ZL);
Cntx.clr(PROD_REJ,PROD_NXT,ZL);

_del_zl:="
   {? PROD_REJ.first()
   || {!
      |? PROD_NXT.index('PROD_REJ');
         PROD_NXT.prefix(PROD_REJ.ref());
         {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};
         PROD_NXT.index('NEXT');
         PROD_NXT.prefix(PROD_REJ.ref());
         {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};
         PROD_REJ.del()
      !}
   ?}
";

{? ZL.seek(_a)
|| {? ZL.TREE_TYP='P'
   || PROD_REJ.index('ZL');
      PROD_REJ.prefix('ZL',ZL.ref());
      _del_zl()
   || ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? PROD_REJ.index('ZL');
            PROD_REJ.prefix('ZL',ZL.ref());
            _del_zl();
            ZL.next()
         !}
      ?}
   ?}
?};

Cntx.pop(PROD_REJ,PROD_NXT,ZL);
~~


\load_one4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ładuje dane do rejestracji wykonań dla jednego zlecenia (jeśli złożone/niezależne, to cała struktura)
::   WE: _a - ZL.ref()
::  OLD: \load_one4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(PROD_REJ,PROD_NXT,ZL,ZGH,ZGP);
Cntx.clr(PROD_REJ,PROD_NXT,ZL,ZGH);

{? ZL.seek(_a) & (ZL.STAN<>'Z' | ZL.RODZAJ='N')
||
   {? ZL.RODZAJ='Z'
   || ZGH.f_set(
         'UID_VIEW,NRPRZ',,
         'ZGH.UID_VIEW=\':_a\'',
         ZL.uidref()
      )
   |? ZL.RODZAJ='N'
   || ZGH.f_set(
         'ZLEC,NRPRZ',
         'join ZL join ZL as ZL1 using(ZL1.UNRZL,ZL.NRNZL)',
         'ZL.STAN<>\'Z\' and ZL1.REFERENCE=:_a',
         ZL.ref()
      )
   || ZGH.f_set(
         'ZLEC,NRPRZ',,
         'ZGH.ZLEC=:_a',
         ZL.ref()
      )
   ?};

:: Przewodniki do zlecenia głównego - pierwsze naliczenie tworzy zapisy PROD_REJ
   {? ZGH.f_first()
   || {!
      |?
         {? ZGH.KIND='N'
         ||
            ZGP.index('NRPP');
            ZGP.prefix(ZGH.ref());
            {? ZGP.first()
            || {!
               |?
                  Cntx.psh(ZL,ZGH);
::                UWAGA: Podczytanie zlecenia podrzędnego
                  ZGH.ZLEC();

                  PROD_REJ.blank(1);
                  {? ZGP.WEW='T'
                  || PROD_REJ.STARTD:={? ZGP.STARTD=date(0,0,0) || ZL.OD || ZGP.STARTD ?};
                     PROD_REJ.STARTT:=ZGP.STARTT;
                     PROD_REJ.ENDD:={? ZGP.ENDD=date(0,0,0) || ZL.DTR || ZGP.ENDD ?};
                     PROD_REJ.ENDT:=ZGP.ENDT
                  || PROD_REJ.STARTD:={? ZGP.STARTDK=date(0,0,0) || ZL.OD || ZGP.STARTDK ?};
                     PROD_REJ.STARTT:=ZGP.STARTTK;
                     PROD_REJ.ENDD:={? ZGP.ENDDK=date(0,0,0) || ZL.DTR || ZGP.ENDDK ?};
                     PROD_REJ.ENDT:=ZGP.ENDTK
                  ?};
                  exec('fields_4rej','zl_wyk');
                  PROD_REJ.WYD:=exec('wyd','zl_guide');
                  PROD_REJ.PRIORITY:='N';
                  PROD_REJ.SRODZ:='ZL';
                  PROD_REJ.SOURCE:=$ZGP.ref();
                  PROD_REJ.ZL:=ZL.ref();
                  PROD_REJ.ZGH:=ZGH.ref();
                  PROD_REJ.ZGP:=ZGP.ref();
                  PROD_REJ.M:=ZL.KTM;
                  PROD_REJ.JM:=ZL.KTM().J;
                  {? ZGP.WEW='T'
                  ||
                     PROD_REJ.RES_SYM:=ZGP.PLACE().KOD;
                     PROD_REJ.RES_NAZ:=TWRKPLC.NA
                  ||
                     PROD_REJ.RES_SYM:='{KOOPERACJA}';
                     PROD_REJ.RES_NAZ:='Kooperacja'
                  ?};
                  PROD_REJ.KH:=ZGP.KONTRAH;
                  PROD_REJ.GKTL:=ZGP.NRPRZ().GKTL;
::                Zlicz ilości z rejestracji źródłowych
                  ZLGD.cntx_psh();
                  _oddzial:=ZL.ODDZ;
                  {? _oddzial='' || _oddzial:='_' ?};
                  _rok1:=ZL.OD~1;
                  _rok2:=date()~1;
                  _il:=0; _ilb:=0;
                  {! _it:=_rok1.._rok2
                  |!
                     _rok:=form(_it,-4,,'0')+2;
                     ZLGD.use('zlgd_'+_oddzial+_rok);
                     ZLGD.index('ZLPP');
                     ZLGD.prefix(ZGH.ZLEC,ZGH.ref(),ZGP.ref());
                     {? ZLGD.first()
                     || {!
                        |? _il+=ZLGD.IL;
                           _ilb+=ZLGD.IL_BRAK;
                           ZLGD.next()
                        !}
                     ?}
                  !};
                  ZLGD.cntx_pop();
                  {? PROD_REJ.ZGP<>null()
                  || PROD_REJ.ILC:=ZGP.ILOSC
                  || PROD_REJ.ILC:=ZGH.ILNPRZ
                  ?};
                  PROD_REJ.ILW:=_il;
                  PROD_REJ.ILWB:=_ilb;
                  {? PROD_REJ.ZGP<>null()
                  || PROD_REJ.IL:=ZGP.ILOSC-_il
                  || PROD_REJ.IL:=ZGH.ILNPRZ-_il
                  ?};
                  {? PROD_REJ.IL<0 || PROD_REJ.IL:=0 ?};
                  PROD_REJ.START:={? exec('czyStartProdRej','ekioski',0) || 'T' || 'N' ?};
                  PROD_REJ.OK:={? ZGP.STATUS=exec('status_end','zl_guide') || 'T' || 'N' ?};
                  PROD_REJ.POTW:='N';
                  PROD_REJ.PROBLEM:={? ZGH.PROBLEM='T' || 'T' || ZGP.PROBLEM ?};
                  PROD_REJ.PROBKLAS:={? ZGH.PROBLEM='T' || exec('prob_class_blocking','zl_wkj') || ZGP.PROBKLAS ?};
                  PROD_REJ.PRAC:='N';
                  PROD_REJ.BRYG:='N';
                  PROD_REJ.KOOP:={? ZGP.WEW='T' || 'N' || 'T' ?};
                  PROD_REJ.A:={? ZL.STAN='O' & ZGH.STAN='N' || 'T' || 'N' ?};
                  PROD_REJ.KONTROLA:={? ZGP.KONTROLA='T' || 'T' || 'N' ?};
                  PROD_REJ.KJ_BAD:=ZGP.KJ_BAD;
                  PROD_REJ.RP:='N';
                  {? ZGP.DOK<>null()
                  || PROD_REJ.RP:='T'
                  ?};
::                Domyślnie zablokowane do rejestracji, chyba że Tpz (już inaczej)
                  PROD_REJ.DOREJ:=
                     {? ZGP.STATUS=exec('status_pending','zl_guide')
                     || 'T'
                     || 'N'
                     ?};
::                  {? ZGP.TPZ='T' || 'T' || 'N' ?};
::                Sprawdzenie wykorzystania w grupach operacji
                  {? ZGP.PL_GRP='T'
                  || {? exec('FindInSet','#table','GROPP','ZGP',ZGP.ref(),,"1",,,0)
                     || PROD_REJ.DOREJ:='N';
                        PROD_REJ.A:='N'
                     ?}
                  ?};
                  {? exec('zgp_is_kap','zl_kap',ZGP.ref())>0
                  || {? ZGP.BRYG='T' || PROD_REJ.BRYG:='T' || PROD_REJ.PRAC:='T' ?}
                  ?};
                  PROD_REJ.IL_KAP:=exec('prod_rej_il_kap','prod_rej');
                  PROD_REJ.add(1);

                  Cntx.pop(ZL,ZGH);

                  ZGP.next()
               !}
            ?}
         ?};
         ZGH.f_next()
      !}
   ?};

:: Przewodniki do zlecenia głównego - drugie naliczenie tworzy zapisy PROD_NXT
   {? ZGH.f_first()
   || {!
      |?
         {? ZGH.KIND='N'
         ||
            ZGP.index('NRPP');
            ZGP.prefix(ZGH.ref());
            {? ZGP.first()
            || {!
               |?
                  PROD_REJ.index('ZGP');
                  PROD_REJ.prefix('ZL',ZGP.ref());
                  {? PROD_REJ.first()
                  ||
                     _prod_rej:=PROD_REJ.ref();

::                   Następniki
                     PROD_REJ.cntx_psh();
                     _next:=exec('tab_zgp_next','zl_guide',ZGP.ref());
                     {? _next.first()
                     || {!
                        |?
                           PROD_REJ.index('ZGP');
                           PROD_REJ.prefix('ZL',_next.REF);
                           {? PROD_REJ.first()
                           || PROD_NXT.PROD_REJ:=_prod_rej;
                              PROD_NXT.NEXT:=PROD_REJ.ref();
                              PROD_NXT.add(1)
                           ?};
                           _next.next()
                        !}
                     ?};
                     obj_del(_next);
                     PROD_REJ.cntx_pop();

::                   Poprzedniki - na wszelki wypadek
                     PROD_REJ.cntx_psh();
                     _prev:=exec('tab_zgp_prev','zl_guide',ZGP.ref());
                     {? _prev.first()
                     || {!
                        |?
                           PROD_REJ.index('ZGP');
                           PROD_REJ.prefix('ZL',_prev.REF);
                           {? PROD_REJ.first()
                           || PROD_NXT.PROD_REJ:=PROD_REJ.ref();
                              PROD_NXT.NEXT:=_prod_rej;
                              PROD_NXT.add(1)
                           ?};
                           _prev.next()
                        !}
                     ?};
                     obj_del(_prev);
                     PROD_REJ.cntx_pop();
                     ~~
                  ?};
                  ZGP.next()
               !}
            ?}
         ?};
         ZGH.f_next()
      !}
   ?}
?};

ZGH.f_clear();
Cntx.pop(PROD_REJ,PROD_NXT,ZL,ZGH,ZGP);
~~


\fields_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ustala wartosci pol PROD_REJ zalezne od innych pol
::       Do uzycia w formulach exec('update_4rej','zl_wyk'), exec('load_4rej','zl_wyk')
::  OLD: \fields_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
:: Pobrany symbol zlecenia i przewodnika
:: (w przypadku zlecenia zlozonego kontekst powinien byc ustawiony na zlecenie podrzedne)
PROD_REJ.OPIS:=ZGH.ZLEC().SYM+' - '+ZGH.NRPRZ+' - '+$ZGP.NRP+{? ZGP.TPZ='T' || ' [1Tpz]' || ' [2G]' ?};
PROD_REJ.OPER:='['+$PROD_REJ.STARTD+' '+$PROD_REJ.STARTT+'] '+PROD_REJ.OPIS;
ZL.cntx_pop();
~~


\problem_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Zgłoś problem' w oknie rejestracji wykonań - przewodnik
::       Kontekst pracy: PROD_REJ
::  OLD: \problem_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~exec('access','zl_wyk') || return() ?};

{? PROD_REJ.GROP<>null()
|| _grop:=PROD_REJ.GROP;
   {? exec('blk_lock','#table','GROP',_grop,,1,'Grupa operacji jest redagowana'@)
   || {? exec('upr_problem','zl_wkj')
      || exec('problem','prod_rej',_grop)
      || FUN.info('Brak uprawnień do zgłaszania problemów.'@)
      ?}
   ?};
   exec('blk_unlock','#table','GROP',_grop)
|| _zgh:=PROD_REJ.ZGH;
   {? exec('blk_lock','#table','ZGH',_zgh,,1,'Przewodnik jest redagowany'@)
   || {? exec('upr_problem','zl_wkj')
      || exec('problem','prod_rej',PROD_REJ.ZGP)
      || FUN.info('Brak uprawnień do zgłaszania problemów.'@)
      ?}
   ?};
   exec('blk_unlock','#table','ZGH',_zgh)
?};
~~


\xproblem_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Rozwiąż problem' w oknie rejestracji wykonań - przewodnik
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
{? ~exec('access','zl_wyk') || return() ?};

{? PROD_REJ.GROP<>null()
|| _grop:=PROD_REJ.GROP;
   {? exec('blk_lock','#table','GROP',_grop,,1,'Grupa operacji jest redagowana'@)
   || {? exec('upr_xproblem','zl_wkj')
      || exec('xproblem','prod_rej',_grop)
      || FUN.info('Brak uprawnień do rozwiązywania problemów.'@)
      ?}
   ?};
   exec('blk_unlock','#table','GROP',_grop)
|| _zgh:=PROD_REJ.ZGH;
   {? exec('blk_lock','#table','ZGH',_zgh,,1,'Przewodnik jest redagowany'@)
   || {? exec('upr_xproblem','zl_wkj')
      || exec('xproblem','prod_rej',{? PROD_REJ.ZGH().PROBLEM='T' || PROD_REJ.ZGH || PROD_REJ.ZGP ?})
      || FUN.info('Brak uprawnień do rozwiązywania problemów.'@)
      ?}
   ?};
   exec('blk_unlock','#table','ZGH',_zgh)
?};
~~


\access
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Sprawdzenie, czy jest dostęp do rejestracji wykonań do przewodników zleceń
::   WE: [_a] - czy komunikaty (1 - tak, domyslnie), 0 - nie
::  OLD: \access/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _msg:=_a || _msg:=1 ?};

{? exec('chk_role','#b__box',OPERATOR.USER,'TTE_WYK_DWZL')=0 | exec('get','#params',500611,2)='N'
||
   {? _msg || FUN.info('Brak uprawnień do rejestracji wykonań do przewodników zleceń.'@) ?};
   0
|? exec('get','#params',500621,2)='P'
||
   {? _msg
   || FUN.info(exec('form','#string','L',
         'Brak dostępu do rejestracji wykonań do przewodników zleceń.'@,
         'Ustawiona synchronizacja wykonań z planu operacyjnego.'@
      ))
   ?};
   0
||
   1
?}


\doc_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Informacja o dokumentach wyświetlana z poziomu rejestracji wykonań - przewodnik
::       Kontekst pracy: PROD_REJ
::  OLD: \doc_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
ZGP.cntx_psh(); GROP.cntx_psh();
ZGP.prefix(); GROP.prefix();
{? PROD_REJ.ZGP<>null() & ZGP.seek(PROD_REJ.ZGP)
|| _env_oper:=exec('env_oper','tech_oper');
   _env_oper.used:=1;
   params_set('env_oper',_env_oper);
   params_exec('doc_4zgp','zl_guide')
|? PROD_REJ.GROP<>null() & GROP.seek(PROD_REJ.GROP)
||
::   _env_oper:=exec('env_oper','tech_oper');
::   _env_oper.used:=1;
::   params_set('env_oper',_env_oper);
   params_exec('doc_4zgp','zl_grop')
|| FUN.error('Brak przewodnika lub grupy operacji.'@)
?};
ZGP.cntx_pop(); GROP.cntx_pop();
~~


\npu_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.14]
:: OPIS: Informacja o NPU wyświetlana z poziomu rejestracji wykonań - przewodnik
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
ZGP.cntx_psh();
ZGP.clear();
{? ZGP.seek(PROD_REJ.ZGP)
|| _env_tool:=exec('env_tool','tech_tool');
   _env_tool.used:=1;
   params_set('env_tool',_env_tool);
   params_exec('npu_4zgp','zl_guide')
|| FUN.error('Brak przewodnika.'@)
?};
ZGP.cntx_pop();
~~


\start_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Start' w oknie rejestracji wykonań - przewodnik
::       Kontekst pracy: PROD_REJ
::  OLD: \start_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (przewodnik zlecenia) funkcja \'Start\' nie jest obsługiwana.'@);
0


\stop_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Stop' w oknie rejestracji wykonań - przewodnik
::       Kontekst pracy: PROD_REJ
::  OLD: \stop_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (przewodnik zlecenia) funkcja \'Stop\' nie jest obsługiwana.'@);
0


\rej_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Rejestracje' w oknie rejestracji wykonań - przewodnik
::   WE: _a - czy zapis jest zablokowany przez innego operatora
::       Kontekst pracy: PROD_REJ
::  OLD: \rej_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
PROD_REJ.ZGP();
PROD_REJ.ZGH();
exec('zgp_rej','zl_wyk',,_a);
~~


\zgp_rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Wyświetla rejestracje robocizny do pozycji przewodnika
::   WE: [_a] - ZGP.ref lub bieżący rekord
::       [_b] - czy zapis jest zablokowany przez innego operatora
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};
_blk:=0;
{? var_pres('_b')=type_of(0)
|| _blk:=_b
?};

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
{? _ref<>null()
|| ZGP.prefix();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| exec('prepzch','zl_guide');
   {? ZGP.NTIME<>0
   || _zgp_godz:=exec('zgp_godz','zl_wyk',0);
      exec('zgp_godz','zl_wyk',0,_zgp_godz.TAB);
      _zgp_godz.TAB.win_sel(_zgp_godz.GRP);
      _zgp_godz.TAB.hdr_sel();
      _zgp_godz.TAB.hdr_sel({? _blk || ' — '+'PODGLĄD'@ || '' ?});
      _zgp_godz.TAB.select(,,,{? _blk || 'PUG' || '' ?})

   || _zgp_wrk:=exec('zgp_wrk','zl_wyk',0);
      exec('zgp_wrk','zl_wyk',0,_zgp_wrk.TAB);
      _zgp_wrk.TAB.win_sel(_zgp_wrk.GRP);
      _zgp_wrk.TAB.hdr_sel();
      _zgp_wrk.TAB.hdr_sel({? _blk || ' — '+'PODGLĄD'@ || '' ?});
      _zgp_wrk.TAB.select(,,,{? _blk || 'PUG' || '' ?})
   ?}
?};
ZGP.cntx_pop();
~~


\wykon_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Wykonano' w oknie rejestracji wykonań - przewodnik/grupa operacji
::  OLD: \wykon_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_no_error:=0;
_is_term:=VEK.TERM='T' | VAR1.ZAK_EK='T';
{? ~exec('access','zl_wyk') || return(_res) ?};

{? date(ST.AR,ST.AM,0)>date(,,0)
|| _txt:='Nie można rejestrować wykonania — wybrany okres obrachunkowy nie może być późniejszy od bieżącej daty.'@;
   {? VAR1.KN3='N'
   || KOMM.add(_txt,5)
   || FUN.info(_txt)
   ?};
   return(_res)
?};

{? PROD_REJ.A<>'T'
|| _txt:='Zapis nieaktywny — nie można rejestrować wykonania.'@;
   {? VAR1.KN3='N'
   || KOMM.add(_txt,5)
   || FUN.info(_txt)
   ?};
   return(_res)
?};

{? PROD_REJ.PROBLEM='T' & PROD_REJ.PROBKLAS<>exec('prob_class_information','zl_wkj')
|| _txt:='Zgłoszony problem klasy \'%1\' — nie można rejestrować wykonania.'@[PROD_REJ.PROBKLAS];
   {? VAR1.KN3='N'
   || KOMM.add(_txt,5)
   || FUN.info(_txt)
   ?};
   return(_res)
?};

{? PROD_REJ.ZGP<>null() & PROD_REJ.ZGP().SRW='M'
|| _txt:='Rejestracja wykonań możliwa poprzez moduł magazynowy.'@;
   {? VAR1.KN3='N'
   || KOMM.add(_txt,5)
   || FUN.info(_txt)
   ?};
   return(_res)
?};

{? PROD_REJ.ZGP<>null() & exec('FindInSet','#table','GROPP','ZGP',PROD_REJ.ZGP)
|| _txt:='Zapis użyty w grupie operacji — nie można bezpośrednio rejestrować wykonania.'@;
   {? VAR1.KN3='N'
   || KOMM.add(_txt,5)
   || FUN.info(_txt)
   ?};
   return(_res)
?};

{? PROD_REJ.GROP<>null()
|| {? PROD_REJ.GROPS=null()
   || _txt:='Grupa operacji nieplanowana — nie można rejestrować wykonania.'@;
      {? VAR1.KN3='N'
      || KOMM.add(_txt,5)
      || FUN.info(_txt)
      ?};
      return(_res)
   ?};
   GROPP.index('GROP');
   GROPP.prefix(PROD_REJ.GROP);
   {? GROPP.first()
   || {!
      |? {? GROPP.ZGP().NRZLP().ZLEC().STAN<>'O'
         ||
            {? VAR1.KN3='N'
            || KOMM.add(
                  'W skład grupy wchodzi operacja zlecenia %1, które nie jest otwarte.\n'
                  'Nie można rejestrować wykonania dla tej grupy.'@[ZL.SYM],5
               )
            || FUN.info(
                  'W skład grupy wchodzi operacja zlecenia %1, które nie jest otwarte.\n'
                  'Nie można rejestrować wykonania dla tej grupy.'@[ZL.SYM]
               )
            ?};
            return(_res)
         ?};
         GROPP.next()
      !}
   ?}
?};

_date:=date();
{? VAR1.ZAK_EK<>'T'
|| {? date(ST.AR,ST.AM,0)<>date(,,0)
   || {? VAR1.KN3<>'N' & ~FUN.ask('Wybrany okres obrachunkowy nie jest zgodny z bieżącą datą.\n\nCzy rejestrować wykonania z datą %1?'@
                  [$date(ST.AR,ST.AM,0)]
         )
      || {? VAR1.KN3='N'
         || KOMM.add('Wybrany okres obrachunkowy nie jest zgodny z bieżącą datą.'@,5)
         ?};
         return(_res)
      || _date:=date(ST.AR,ST.AM,0)
      ?}
   ?}
?};

{? PROD_REJ.ZL<>null() & PROD_REJ.ZL().OD>_date
|| _txt:='Zlecenie powołane z późniejszą datą.'@;
   {? VAR1.KN3='N'
   || KOMM.add(_txt,5)
   || FUN.emsg(_txt)
   ?};
   return(_res)
?};

::{? PROD_REJ.GROP<>null() & PROD_REJ.GROP().DATA>_date
::|| FUN.emsg('Grupa operacji zaplanowana do realizacji z późniejszą datą.'@);

::   return(_res)
::?};

_forced:=0;
{? PROD_REJ.OK='T'
|| {? _is_term
   || {? FUN.ask('Wykonanie operacji zostało już zakończone.'@+'\n'+
                  'Czy na pewno zarejestrować wykonanie?'@)
      || _forced:=1
      || return(_res)
      ?}
   || _txt:='Wykonanie operacji zostało już zakończone.'@;
      {? VAR1.KN3='N'
      || KOMM.add(_txt,5)
      || FUN.info(_txt)
      ?};
      return(_res)
   ?}
?};

_chkak:=exec('get','#params',500631,2);
{? _chkak='T' & PROD_REJ.DOREJ<>'T'
|| {? _is_term & _forced
   || ~~
   || _txt:='Zapis niedostępny do rejestracji — najpierw należy zarejestrować operacje poprzedzające.'@;
      {? VAR1.KN3='N'
      || KOMM.add(_txt,5)
      || FUN.info(_txt)
      ?};
      return(_res)
   ?}
?};

_p500645:=exec('get','#params',500645,2);

Cntx.psh(ZL,ZGH,ZGP,KAP,GROP);
Cntx.clr(ZL,ZGH,ZGP,KAP,GROP);

:: Odnalezienie źródłowego GROP
{? PROD_REJ.GROP<>null() & GROP.seek(PROD_REJ.GROP)
   & exec('blk_lock','#table','GROP',PROD_REJ.GROP,,1,'Grupa operacji jest redagowana'@)
||
   _bryg:=exec('grop_bryg','zl_grop',GROP.ref());
   {? _bryg='N'
   || {? _is_term
      || _pracownik:=VEK.P
      || {? exec('is_fast_wyk','prod_rej')
         || _pracownik:=exec('p_select_simple','prod_rej')
         || _pracownik:=exec('p_select','prod_rej')
         ?}
      ?};
      _zlbr:=null();
      _ok:=_pracownik<>null()
   || _pracownik:=null();
      _zlbr:={? _is_term || VEK.A_ZLBR || exec('zlbr_select','prod_rej') ?};
::    Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (tylko Merit, ekiosk sprawdzany później)
      _dalej:={? _is_term || 1 || exec('zlbr_chk_zlbs','prod_rej',_zlbr) ?};
      _ok:=_zlbr<>null() & _dalej>0
   ?};

   {? _ok
   || {? ~_is_term & exec('get','#params',500602)='T'
      || _ok:=exec('grop_full_edit','zl_wyk',
            {? exec('grop_bryg','zl_grop',GROP.ref())='T' || 'B' || 'P' ?},
            _pracownik,
            _zlbr,
            0
         );
         {? _ok
         || _args:=exec('add_akord_a','zl_wyk');
            _args.GROP:=GROP.ref();
            _args.GROPS:=PROD_REJ.GROPS;
            _args.IL:=VPRODREJ.IL;
            _args.IL_BRAK:=VPRODREJ.IL_BRAK;
            _args.OK:=VPRODREJ.OK;
            _args.P:=_pracownik;
            _args.ZLBR:=_zlbr;
            _args.TIME:=VPRODREJ.TIME;
            _args.ZMIANA:=VPRODREJ.ZMIANA;
            _args.R:=VPRODREJ.R;
            _args.ST:=VPRODREJ.ST;
            _args.PLACE:=VPRODREJ.PLACE;
            _res:=exec('add_akord','zl_wyk',_args);
            {? _res>0 & FUN.ask('Czy potwierdzić wykonanie operacji?'@)
            || exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"exec('zlgd_potw','zl_grop')")
            ?}
         ?}
      || _ok:=exec('grop_edit','zl_wyk');
         {? _ok
         || _args:=exec('add_akord_a','zl_wyk');
            _args.GROP:=GROP.ref();
            _args.GROPS:=PROD_REJ.GROPS;
            _args.IL:=VPRODREJ.IL;
            _args.OK:=VPRODREJ.OK;
            _args.P:=_pracownik;
            _args.ZLBR:=_zlbr;
            _args.TIME:=VPRODREJ.TIME;
            _args.ENDD:=VPRODREJ.ENDD;
            _args.ENDT:=VPRODREJ.ENDT;
            {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
            {? _args.ENDT<>time(0,0,0) & _p500645='C'
            || _args.ZMIANA:='C'
            |? _args.ENDT<>time(0,0,0) & _p500645='K'
            || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
            || _args.ZMIANA:=''
            ?};
            _args.PLACE:=VPRODREJ.PLACE;
            {? _is_term & VPRODREJ.WYD<>null()
            || _args.WYD:=VPRODREJ.WYD
            ?};
::          Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (ekiosk)
            _dalej:={? _is_term & _zlbr<>null() || exec('zlbr_chk_zlbs','prod_rej',_zlbr,_args.DT) || 1 ?};
            {? _dalej>0
            || {? _is_term
               ||
::                Jeżeli rejestracja na ilość zerową  to potwierdzenie grupy operacji następuje bezdialogowo
                  {? _args.IL=0
                  || _choice:=2
                  ||  _choice:=FUN.choice('Czy zarejestrować wykonanie operacji grupowej?'@,,'Tak'@,
                        'Tak, z potwierdzeniem'@)
                  ?};
                  {? _choice=1
                  || _res:=exec('add_akord','zl_wyk',_args)
                  |? _choice=2
                  || _res:=exec('add_akord','zl_wyk',_args);
                     {? _res>0
                     || exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"exec('zlgd_potw','zl_grop')")
                     ?}
                  ?}
               || _res:=exec('add_akord','zl_wyk',_args);
                  {? _res>0 & FUN.ask('Czy potwierdzić wykonanie operacji?'@)
                  || exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"exec('zlgd_potw','zl_grop')")
                  ?}
               ?}
            ?}
         ?}
      ?}
   ?};

   exec('blk_unlock','#table','GROP',PROD_REJ.GROP)

:: Odnalezienie źródłowego ZGP
|? ZGP.seek(PROD_REJ.ZGP)
   & exec('blk_lock','#table','ZGH',PROD_REJ.ZGH,,1,'Przewodnik jest redagowany'@)
||
   {? VAR1.KN3<>'N' || VPRODREJ.ZPARN:=null() ?};

   _party_req:=exec('party_req','zl_wyk',PROD_REJ.ZL);
:: Sprawdzam czy zlecenie na którym powstaje produkt jest zleceniem partiowanym
   {? _party_req>0
   ||
::    Sprawdzam czy zlecenie produkcyjne jest zleceniem na które rejestruję robociznę
::    jeśli tak, to mogę spróbować podpowiedzieć partie. Jeśli nie to pewnie jest przypadek
::    zlecenia złożonego i nie mogę podpowiedzieć partii
::    Jeśli zlecenie jest partiowane to sprawdzam ile partii ma przewodnik - jeśli tylko jedną
::    to podpowiadam partię
      ZPARN.cntx_psh();
      ZPARN.index('ZGH');
      _zgh:=null();
      _zgp:=null();
      {? PROD_REJ.SRODZ='ZL'
      || _zgh:=PROD_REJ.ZGH;
         _zgp:=PROD_REJ.ZGP
      |? PROD_REJ.SRODZ='PL'
      || _zgh:=PROD_REJ.PL_OPER().ZGP().NRZLP;
         _zgp:=PROD_REJ.PL_OPER().ZGP
      ?};
      {? _zgh<>null()
      ||
         _party_zgh:=exec('party_first_zgh','zl_guide',_zgh);
         {? _party_zgh<>null()
         ||
            {? exec('is_fast_wyk','prod_rej')
            || VPRODREJ.ZPARN:=exec('first_not_completed','zl_partie',null(),_party_zgh,'R',_zgp)
            ||
               ZPARN.prefix(_party_zgh);
               {? ZPARN.size()=1
               || {? ZPARN.first()
                  || VPRODREJ.ZPARN:=ZPARN.ref()
                  ?}
               ?}
            ?};
            ~~
         ?}
      ?};
      ZPARN.cntx_pop()
   ?};

:: Kontekst dla kart pracy - bieżący okres
   KAP.index('ZGP_PB');
   KAP.prefix(ZGP.ref());

   {? ZGP.NRPRZ().STAN='T'
   || _txt:='Przewodnik oddany — rejestracja nie jest możliwa.'@;
      {? VAR1.KN3='N'
      || KOMM.add(_txt,5)
      || FUN.info(_txt)
      ?}

   |? ZGP.NRPRZ().KIND='T'
   || _txt:='Przewodnik "techniczny" — rejestracja nie jest możliwa.'@;
      {? VAR1.KN3='N'
      || KOMM.add(_txt,5)
      || FUN.info(_txt)
      ?}

   |? ZGP.NRPRZ().ZLEC().STAN<>'O'
   || _txt:='Zlecenie nie jest otwarte — rejestracja nie jest możliwa.'@;
      {? VAR1.KN3='N'
      || KOMM.add(_txt,5)
      || FUN.info(_txt)
      ?}

:: Rejestracja kooperacji - bezpośrednio do pozycji przewodnika
   |? PROD_REJ.KOOP='T'
   ||
      exec('wykon_start','zl_wyk',ZGP.ref());
      {? ZGP.NRPRZ().ZLEC().TYP().WP='W'
      ||
         _ok:=FUN.ask('Czy zarejestrować całkowite wykonanie kooperacji?'@);
         {? _ok
         ||
            _args:=exec('add_akord_a','zl_wyk');
            _args.ZGP:=ZGP.ref();
            _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
            _args.OK:='T';
            _args.ZPARN:=VPRODREJ.ZPARN;
            _res:=exec('add_akord','zl_wyk',_args)
         ?}
      ||
         _ok:=exec('ile_edit','zl_wyk');
         {? _ok
         ||
            _args:=exec('add_akord_a','zl_wyk');
            _args.ZGP:=ZGP.ref();
            _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
            _args.IL:=VPRODREJ.IL;
            _args.IL_BRAK:=VPRODREJ.IL_BRAK;
            _args.OK:=VPRODREJ.OK;
            _args.ZPARN:=VPRODREJ.ZPARN;
            _args.BRAKI_R:=VPRODREJ.BRAKI_R;
            _res:=exec('add_akord','zl_wyk',_args)
         ?}
      ?}

:: Rejestracja gdy brak czasu dla pracownika - bezpośrednio do pozycji przewodnika
   |? ZGP.NTIME=0
   || exec('wykon_start','zl_wyk',ZGP.ref());
      {? ~_is_term & exec('get','#params',500602)='T'
      || _ok:=exec('full_edit','zl_wyk');
         {? _ok
         ||
            _args:=exec('add_akord_a','zl_wyk');
            _args.ZGP:=ZGP.ref();
            _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
            _args.IL:=VPRODREJ.IL;
            _args.IL_BRAK:=VPRODREJ.IL_BRAK;
            _args.OK:=VPRODREJ.OK;
            _args.ZPARN:=VPRODREJ.ZPARN;
            _args.TIME:=VPRODREJ.TIME;
            _args.ZMIANA:=VPRODREJ.ZMIANA;
            _args.R:=VPRODREJ.R;
            _args.ST:=VPRODREJ.ST;
            _args.PLACE:=VPRODREJ.PLACE;
            _args.BRAKI_R:=VPRODREJ.BRAKI_R;
            _res:=exec('add_akord','zl_wyk',_args)
         ||
            _res:=0
         ?}
      |? ZGP.NRPRZ().ZLEC().TYP().WP='W'
      || _ok:=exec('work_edit','zl_wyk',,0);
         {? _ok
         ||
            _args:=exec('add_akord_a','zl_wyk');
            _args.ZGP:=ZGP.ref();
            _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
            _args.IL:=0;
            _args.IL_BRAK:=0;
            _args.OK:=VPRODREJ.OK;
            _args.ZPARN:=VPRODREJ.ZPARN;
            _args.PLACE:=VPRODREJ.PLACE;
            {? _is_term & VPRODREJ.WYD<>null()
            || _args.WYD:=VPRODREJ.WYD
            ?};
            _args.ZMIANA:='';
            _res:=exec('add_akord','zl_wyk',_args)
         ?}
      || _ok:=exec('ile_edit','zl_wyk');
         {? _ok
         ||
            _args:=exec('add_akord_a','zl_wyk');
            _args.ZGP:=ZGP.ref();
            _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
            _args.IL:=VPRODREJ.IL;
            _args.IL_BRAK:=VPRODREJ.IL_BRAK;
            _args.OK:=VPRODREJ.OK;
            _args.ZPARN:=VPRODREJ.ZPARN;
            _args.PLACE:=VPRODREJ.PLACE;
            {? _is_term & VPRODREJ.WYD<>null()
            || _args.WYD:=VPRODREJ.WYD
            ?};
            _args.BRAKI_R:=VPRODREJ.BRAKI_R;
            {? _p500645<>'K' || _args.ZMIANA:='' ?};
            _res:=exec('add_akord','zl_wyk',_args)
         ?}
      ?}

:: Rejestracja operacji dla brygady wg karty pracy (gdy są karty w bieżącej masce - roku)
   |? PROD_REJ.BRYG='T' &
      ({? _is_term || KAP.prefix(ZGP.ref(),null(),VEK.A_ZLBR) || KAP.prefix(ZGP.ref()) ?};
      KAP.first() & VAR1.BEZ_KAP<>'T')
   ||
      exec('wykon_start','zl_wyk',ZGP.ref());
::      KAP.win_sel('SLO_BZ');
      KAP.win_sel(exec('win_grp','zl_kap',,1,'SLO_BZ'));
      '-*-e-kioski-*-';
      _kap_sel:=exec('findFirstKap','ekioski');
      {? VAR1.BEZ_KAP='T'
      ||
::       Rejestracja z pominięciem kart pracy
::       !!! REKURENCJA !!!
         _res:=exec('wykon_4rej','zl_wyk');
         {? ~_is_term
         || VAR1.BEZ_KAP:='N'
         ?}
      ||
         {? _kap_sel
         ||
            _ile:=KAP.IL;
            _time:=KAP.TIME;
            _czy_zlgd:=0;
            Cntx.psh(ZLGD);
            ZLGD.index('KAP');
            ZLGD.prefix(KAP.ref());
            {? ZLGD.first()
            || {!
               |? _ile-=ZLGD.IL;
                  _time-=ZLGD.TIME;
::                Sprawdzam czy do karty pracy zarejestrowano (zakończone) wykonanie produkcji
                  {? _czy_zlgd=0 & ZLGD.ZAK='T'
                  || _czy_zlgd:=1
                  ?};
                  ZLGD.next()
               !}
            ?};
            Cntx.pop(ZLGD);
::          Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (tylko Merit, ekiosk sprawdzany później)
            _zlbr:=KAP.B;
            _dalej:={? _is_term || 1 || exec('zlbr_chk_zlbs','prod_rej',_zlbr,,0) ?};

            {? KAP.IL>0 & _ile<=0
            || FUN.info('Do tej karty pracy zarejestrowano już całą ilość.'@);
               _res:=0
            |? KAP.IL=0 & KAP.TIME=0 & _czy_zlgd=1
            || FUN.info('Do tej karty pracy zarejestrowano już wszystkie wykonania.'@);
               _res:=0
            |? _dalej=0
            || FUN.emsg('Pusty skład brygady na dzień %1.'@[$_date]);
               _res:=0
            ||
               {? ~_is_term & exec('get','#params',500602)='T'
               || _ok:=exec('full_edit','zl_wyk',
                     {? KAP.ZGP().BRYG='T' || 'B' || 'P' ?},,
                     KAP.B,
                     {? KAP.ZGH().ZLEC().TYP().WP='W' | KAP.ZGP().TPZ='T' || 0 || _ile ?},
                     {? KAP.ZGH().ZLEC().TYP().WP='W' | KAP.ZGP().TPZ='T' || {? _time<0 || 0 || _time ?} || 0 ?},
                     KAP.ref()
                  );
                  {? _ok
                  ||
                     _args:=exec('add_akord_a','zl_wyk');
                     _args.KAP:=KAP.ref();
                     _args.ZGP:=KAP.ZGP;
                     _args.ZLBR:=KAP.B;
                     _args.TIME:=VPRODREJ.TIME;
                     _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                     _args.IL:=VPRODREJ.IL;
                     _args.IL_BRAK:=VPRODREJ.IL_BRAK;
                     _args.OK:=VPRODREJ.OK;
                     _args.ZPARN:=VPRODREJ.ZPARN;
                     _args.ZMIANA:=VPRODREJ.ZMIANA;
                     _args.R:=VPRODREJ.R;
                     _args.ST:=VPRODREJ.ST;
                     _args.PLACE:=VPRODREJ.PLACE;
                     _args.BRAKI_R:=VPRODREJ.BRAKI_R;
                     _res:=exec('add_akord','zl_wyk',_args)
                  ||
                     _res:=0
                  ?}
               ||
                  {? KAP.ZGH().ZLEC().TYP().WP='W'
                  ||
                     _ok:=exec('work_edit','zl_wyk',_time);
                     {? _ok
                     ||
                        _args:=exec('add_akord_a','zl_wyk');
                        _args.KAP:=KAP.ref();
                        _args.ZGP:=KAP.ZGP;
                        _args.ZLBR:=KAP.B;
                        _args.TIME:=VPRODREJ.TIME;
                        _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                        _args.OK:=VPRODREJ.OK;
                        _args.ZPARN:=VPRODREJ.ZPARN;
                        _args.ENDD:=VPRODREJ.ENDD;
                        _args.ENDT:=VPRODREJ.ENDT;
                        {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                        {? _args.ENDT<>time(0,0,0) & _p500645='C'
                        || _args.ZMIANA:='C'
                        |? _args.ENDT<>time(0,0,0) & _p500645='K'
                        || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                        || _args.ZMIANA:=''
                        ?};
                        _args.PLACE:=VPRODREJ.PLACE;
                        {? _is_term & VPRODREJ.WYD<>null()
                        || _args.WYD:=VPRODREJ.WYD
                        ?};
::                      Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (ekiosk)
                        _dalej:={? _is_term || exec('zlbr_chk_zlbs','prod_rej',_zlbr,_args.DT) || 1 ?};
                        {? _dalej>0
                        || _res:=exec('add_akord','zl_wyk',_args)
                        ?}
                     || _res:=0
                     ?}
                  |? KAP.ZGP().TPZ='T'
                  ||
                     _ok:=exec('tpz_edit','zl_wyk',_time);
                     {? _ok
                     ||
                        _args:=exec('add_akord_a','zl_wyk');
                        _args.KAP:=KAP.ref();
                        _args.ZGP:=KAP.ZGP;
                        _args.ZLBR:=KAP.B;
                        _args.TIME:=VPRODREJ.TIME;
                        _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                        _args.OK:=VPRODREJ.OK;
                        _args.ENDD:=VPRODREJ.ENDD;
                        _args.ENDT:=VPRODREJ.ENDT;
                        {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                        {? _args.ENDT<>time(0,0,0) & _p500645='C'
                        || _args.ZMIANA:='C'
                        |? _args.ENDT<>time(0,0,0) & _p500645='K'
                        || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                        || _args.ZMIANA:=''
                        ?};
                        _args.PLACE:=VPRODREJ.PLACE;
                        {? _is_term & VPRODREJ.WYD<>null()
                        || _args.WYD:=VPRODREJ.WYD
                        ?};
::                      Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (ekiosk)
                        _dalej:={? _is_term || exec('zlbr_chk_zlbs','prod_rej',_zlbr,_args.DT) || 1 ?};
                        {? _dalej>0
                        || _res:=exec('add_akord','zl_wyk',_args)
                        ?}
                     || _res:=0
                     ?}
                  ||
                     _ok:=exec('ile_edit','zl_wyk',_ile);
                     {? _ok
                     ||
                        _args:=exec('add_akord_a','zl_wyk');
                        _args.KAP:=KAP.ref();
                        _args.ZGP:=KAP.ZGP;
                        _args.ZLBR:=KAP.B;
                        _args.TIME:=VPRODREJ.TIME;
                        _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                        _args.IL:=VPRODREJ.IL;
                        _args.IL_BRAK:=VPRODREJ.IL_BRAK;
                        _args.OK:=VPRODREJ.OK;
                        _args.ZPARN:=VPRODREJ.ZPARN;
                        _args.ENDD:=VPRODREJ.ENDD;
                        _args.ENDT:=VPRODREJ.ENDT;
                        {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                        {? _args.ENDT<>time(0,0,0) & _p500645='C'
                        || _args.ZMIANA:='C'
                        |? _args.ENDT<>time(0,0,0) & _p500645='K'
                        || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                        || _args.ZMIANA:=''
                        ?};
                        _args.PLACE:=VPRODREJ.PLACE;
                        {? _is_term & VPRODREJ.WYD<>null()
                        || _args.WYD:=VPRODREJ.WYD
                        ?};
                        _args.BRAKI_R:=VPRODREJ.BRAKI_R;
::                      Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (ekiosk)
                        _dalej:={? _is_term || exec('zlbr_chk_zlbs','prod_rej',_zlbr,_args.DT) || 1 ?};
                        {? _dalej>0
                        || _res:=exec('add_akord','zl_wyk',_args)
                        ?}
                     ||
                        _res:=0
                     ?}
                  ?}
               ?}
            ?}
         ||
            _res:=0
         ?}
      ?}

:: Rejestracja operacji dla pracownika wg karty pracy (gdy są karty w bieżącej masce - roku)
   |? PROD_REJ.PRAC='T' &
      ({? _is_term || KAP.prefix(ZGP.ref(),VEK.P,null()) || KAP.prefix(ZGP.ref()) ?};
      KAP.first() & VAR1.BEZ_KAP<>'T')
   ||
      exec('wykon_start','zl_wyk',ZGP.ref());
      KAP.win_sel('SLO_Z');

      '-*-e-kioski-*-';
      _kap_sel:=exec('findFirstKap','ekioski');
      {? VAR1.BEZ_KAP='T'
      ||
::       Rejestracja z pominięciem kart pracy
::       !!! REKURENCJA !!!
         _res:=exec('wykon_4rej','zl_wyk');
         {? ~_is_term
         || VAR1.BEZ_KAP:='N'
         ?}
      ||
         {? _kap_sel
         ||
            _ile:=KAP.IL;
            _time:=KAP.TIME;
            _czy_zlgd:=0;
            ZLGD.cntx_psh();
            ZLGD.index('KAP');
            ZLGD.prefix(KAP.ref());
            {? ZLGD.first()
            || {!
               |? _ile-=ZLGD.IL;
                  _time-=ZLGD.TIME;
::                Sprawdzam czy do karty pracy zarejestrowano (zakończone) wykonanie produkcji
                  {? _czy_zlgd=0 & ZLGD.ZAK='T'
                  || _czy_zlgd:=1
                  ?};
                  ZLGD.next()
               !}
            ?};
            ZLGD.cntx_pop();
            {? KAP.IL>0 & _ile<=0
            || FUN.info('Do tej karty pracy zarejestrowano już całą ilość.'@);
               _res:=0
            |? KAP.IL=0 & KAP.TIME=0 & _czy_zlgd=1
            || FUN.info('Do tej karty pracy zarejestrowano już wszystkie wykonania.'@);
               _res:=0
            ||
               {? ~_is_term & exec('get','#params',500602)='T'
               || _ok:=exec('full_edit','zl_wyk',
                     {? KAP.ZGP().BRYG='T' || 'B' || 'P' ?},
                     KAP.P,,
                     {? KAP.ZGH().ZLEC().TYP().WP='W' | KAP.ZGP().TPZ='T' || 0 || _ile ?},
                     {? KAP.ZGH().ZLEC().TYP().WP='W' | KAP.ZGP().TPZ='T' || {? _time<0 || 0 || _time ?} || 0 ?},
                     KAP.ref()
                  );
                  {? _ok
                  ||
                     _args:=exec('add_akord_a','zl_wyk');
                     _args.KAP:=KAP.ref();
                     _args.ZGP:=KAP.ZGP;
                     _args.P:=KAP.P;
                     _args.TIME:=VPRODREJ.TIME;
                     _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                     _args.IL:=VPRODREJ.IL;
                     _args.IL_BRAK:=VPRODREJ.IL_BRAK;
                     _args.OK:=VPRODREJ.OK;
                     _args.ZPARN:=VPRODREJ.ZPARN;
                     _args.ZMIANA:=VPRODREJ.ZMIANA;
                     _args.R:=VPRODREJ.R;
                     _args.ST:=VPRODREJ.ST;
                     _args.PLACE:=VPRODREJ.PLACE;
                     _args.BRAKI_R:=VPRODREJ.BRAKI_R;
                     _res:=exec('add_akord','zl_wyk',_args)
                  ||
                     _res:=0
                  ?}
               || {? KAP.ZGH().ZLEC().TYP().WP='W'
                  ||
                     _ok:=exec('work_edit','zl_wyk',_time);
                     {? _ok
                     ||
                        _args:=exec('add_akord_a','zl_wyk');
                        _args.KAP:=KAP.ref();
                        _args.ZGP:=KAP.ZGP;
                        _args.P:=KAP.P;
                        _args.TIME:=VPRODREJ.TIME;
                        _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                        _args.OK:=VPRODREJ.OK;
                        _args.ZPARN:=VPRODREJ.ZPARN;
                        _args.ENDD:=VPRODREJ.ENDD;
                        _args.ENDT:=VPRODREJ.ENDT;
                        {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                        {? _args.ENDT<>time(0,0,0) & _p500645='C'
                        || _args.ZMIANA:='C'
                        |? _args.ENDT<>time(0,0,0) & _p500645='K'
                        || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                        || _args.ZMIANA:=''
                        ?};
                        _args.PLACE:=VPRODREJ.PLACE;
                        {? _is_term & VPRODREJ.WYD<>null()
                        || _args.WYD:=VPRODREJ.WYD
                        ?};
                        _res:=exec('add_akord','zl_wyk',_args)
                     || _res:=0
                     ?}
                  |? KAP.ZGP().TPZ='T'
                  ||
                     _ok:=exec('tpz_edit','zl_wyk',_time);
                     {? _ok
                     ||
                        _args:=exec('add_akord_a','zl_wyk');
                        _args.KAP:=KAP.ref();
                        _args.ZGP:=KAP.ZGP;
                        _args.P:=KAP.P;
                        _args.TIME:=VPRODREJ.TIME;
                        _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                        _args.OK:=VPRODREJ.OK;
                        _args.ZPARN:=VPRODREJ.ZPARN;
                        _args.ENDD:=VPRODREJ.ENDD;
                        _args.ENDT:=VPRODREJ.ENDT;
                        {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                        {? _args.ENDT<>time(0,0,0) & _p500645='C'
                        || _args.ZMIANA:='C'
                        |? _args.ENDT<>time(0,0,0) & _p500645='K'
                        || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                        || _args.ZMIANA:=''
                        ?};
                        _args.PLACE:=VPRODREJ.PLACE;
                        {? _is_term & VPRODREJ.WYD<>null()
                        || _args.WYD:=VPRODREJ.WYD
                        ?};
                        _res:=exec('add_akord','zl_wyk',_args)
                     ||
                        _res:=0
                     ?}
                  ||
                     _ok:=exec('ile_edit','zl_wyk',_ile);
                     {? _ok
                     ||
                        _args:=exec('add_akord_a','zl_wyk');
                        _args.KAP:=KAP.ref();
                        _args.ZGP:=KAP.ZGP;
                        _args.P:=KAP.P;
                        _args.TIME:=VPRODREJ.TIME;
                        _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                        _args.IL:=VPRODREJ.IL;
                        _args.IL_BRAK:=VPRODREJ.IL_BRAK;
                        _args.OK:=VPRODREJ.OK;
                        _args.ZPARN:=VPRODREJ.ZPARN;
                        _args.ENDD:=VPRODREJ.ENDD;
                        _args.ENDT:=VPRODREJ.ENDT;
                        {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                        {? _args.ENDT<>time(0,0,0) & _p500645='C'
                        || _args.ZMIANA:='C'
                        |? _args.ENDT<>time(0,0,0) & _p500645='K'
                        || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                        || _args.ZMIANA:=''
                        ?};
                        _args.PLACE:=VPRODREJ.PLACE;
                        {? _is_term & VPRODREJ.WYD<>null()
                        || _args.WYD:=VPRODREJ.WYD
                        ?};
                        _args.BRAKI_R:=VPRODREJ.BRAKI_R;
                        _res:=exec('add_akord','zl_wyk',_args)
                     ||
                        _res:=0
                     ?}
                  ?}
               ?}
            ?}
         ||
            _res:=0
         ?}
      ?}

:: Rejestracja operacji dla brygady bezpośrednio do pozycji przewodnika
   |? ZGP.BRYG='T'
   ||
      exec('wykon_start','zl_wyk',ZGP.ref());
      {? _is_term
      || _zlbr:=VEK.A_ZLBR
      || _zlbr:={? VAR1.KN3='N' & FILTER.PR_ZLBR<>null()
                || FILTER.PR_ZLBR
                || exec('zlbr_select','prod_rej')
                ?};
::        Jak rejestracja z poziomu partii to przypisuje do zmiennej wybraną brygadę
         {? VAR1.KN3='N' & FILTER.PR_ZLBR=null() & _zlbr<>null()
         || FILTER.PR_ZLBR:=_zlbr
         |? VAR1.KN3='N' & _zlbr=null()
         || _no_error:=1
         ?}
      ?};
::    Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (tylko Merit, ekiosk sprawdzany później)
      _dalej:={? _is_term || 1 || exec('zlbr_chk_zlbs','prod_rej',_zlbr) ?};
      {? _dalej=0 & VAR1.KN3='N' || _no_error:=1 ?};

      {? _zlbr<>null() & _dalej>0
      ||
::       Podpowiadam czas tylko dla operacji TPZ lub zleceń warsztatowych
         _do_rej:={? ZGP.NRPRZ().ZLEC().TYP().WP='W' | ZGP.TPZ='T'
                  || ZGP.NTIME-exec('zgp_time_rej','zl_wyk',ZGP.ref())
                  || 0
                  ?};
         {? ~_is_term & exec('get','#params',500602)='T'
         || _ok:=exec('full_edit','zl_wyk',{? ZGP.BRYG='T' || 'B' || 'P' ?},,_zlbr,,{? _do_rej<0 || 0 || _do_rej ?});
            {? _ok
            ||
               _args:=exec('add_akord_a','zl_wyk');
               _args.ZGP:=ZGP.ref();
               _args.ZLBR:=_zlbr;
               _args.TIME:=VPRODREJ.TIME;
               _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
               _args.IL:=VPRODREJ.IL;
               _args.IL_BRAK:=VPRODREJ.IL_BRAK;
               _args.OK:=VPRODREJ.OK;
               _args.ZPARN:=VPRODREJ.ZPARN;
               _args.ZMIANA:=VPRODREJ.ZMIANA;
               _args.R:=VPRODREJ.R;
               _args.ST:=VPRODREJ.ST;
               _args.PLACE:=VPRODREJ.PLACE;
               _args.BRAKI_R:=VPRODREJ.BRAKI_R;
               _res:=exec('add_akord','zl_wyk',_args)
            ||
               _res:=0
            ?}
         ||
            {? ZGP.NRPRZ().ZLEC().TYP().WP='W'
            ||
               _ok:=exec('work_edit','zl_wyk',{? _do_rej<0 || 0 || _do_rej ?});
               {? _ok
               ||
                  _args:=exec('add_akord_a','zl_wyk');
                  _args.ZGP:=ZGP.ref();
                  _args.ZLBR:=_zlbr;
                  _args.TIME:=VPRODREJ.TIME;
                  _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                  _args.OK:=VPRODREJ.OK;
                  _args.ZPARN:=VPRODREJ.ZPARN;
                  _args.ENDD:=VPRODREJ.ENDD;
                  _args.ENDT:=VPRODREJ.ENDT;
                  {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                  {? _args.ENDT<>time(0,0,0) & _p500645='C'
                  || _args.ZMIANA:='C'
                  |? _args.ENDT<>time(0,0,0) & _p500645='K'
                  || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                  || _args.ZMIANA:=''
                  ?};
                  _args.PLACE:=VPRODREJ.PLACE;
                  {? _is_term & VPRODREJ.WYD<>null()
                  || _args.WYD:=VPRODREJ.WYD
                  ?};
::                 Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (ekiosk)
                  _dalej:={? _is_term || exec('zlbr_chk_zlbs','prod_rej',_zlbr,_args.DT) || 1 ?};
                  {? _dalej>0
                  || _res:=exec('add_akord','zl_wyk',_args)
                  ?}
               || _res:=0
               ?}
            |? ZGP.TPZ='T'
            ||
               _ok:=exec('tpz_edit','zl_wyk',{? _do_rej<0 || 0 || _do_rej ?});
               {? _ok
               ||
                  _args:=exec('add_akord_a','zl_wyk');
                  _args.ZGP:=ZGP.ref();
                  _args.ZLBR:=_zlbr;
                  _args.TIME:=VPRODREJ.TIME;
                  _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                  _args.OK:=VPRODREJ.OK;
                  _args.ZPARN:=VPRODREJ.ZPARN;
                  _args.ENDD:=VPRODREJ.ENDD;
                  _args.ENDT:=VPRODREJ.ENDT;
                  {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                  {? _args.ENDT<>time(0,0,0) & _p500645='C'
                  || _args.ZMIANA:='C'
                  |? _args.ENDT<>time(0,0,0) & _p500645='K'
                  || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                  || _args.ZMIANA:=''
                  ?};
                  _args.PLACE:=VPRODREJ.PLACE;
                  {? _is_term & VPRODREJ.WYD<>null()
                  || _args.WYD:=VPRODREJ.WYD
                  ?};
::                 Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (ekiosk)
                  _dalej:={? _is_term || exec('zlbr_chk_zlbs','prod_rej',_zlbr,_args.DT) || 1 ?};
                  {? _dalej>0
                  || _res:=exec('add_akord','zl_wyk',_args)
                  ?}
               || _res:=0
               ?}
            ||
               _ok:=exec('ile_edit','zl_wyk');
               {? _ok
               ||
                  _args:=exec('add_akord_a','zl_wyk');
                  _args.ZGP:=ZGP.ref();
                  _args.ZLBR:=_zlbr;
                  _args.TIME:=VPRODREJ.TIME;
                  _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                  _args.IL:=VPRODREJ.IL;
                  _args.IL_BRAK:=VPRODREJ.IL_BRAK;
                  _args.OK:=VPRODREJ.OK;
                  _args.ZPARN:=VPRODREJ.ZPARN;
                  _args.ENDD:=VPRODREJ.ENDD;
                  _args.ENDT:=VPRODREJ.ENDT;
                  {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                  {? _args.ENDT<>time(0,0,0) & _p500645='C'
                  || _args.ZMIANA:='C'
                  |? _args.ENDT<>time(0,0,0) & _p500645='K'
                  || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                  || _args.ZMIANA:=''
                  ?};
                  _args.PLACE:=VPRODREJ.PLACE;
                  {? _is_term & VPRODREJ.WYD<>null()
                  || _args.WYD:=VPRODREJ.WYD
                  ?};
                  _args.BRAKI_R:=VPRODREJ.BRAKI_R;
::                 Sprawdzam czy brygada ma zdefiniowany skład w danym okresie (ekiosk)
                  _dalej:={? _is_term || exec('zlbr_chk_zlbs','prod_rej',_zlbr,_args.DT) || 1 ?};
                  {? _dalej>0
                  || _res:=exec('add_akord','zl_wyk',_args)
                  ?}
               ||
                  _res:=0
               ?}
            ?}
         ?}
      ||
         _res:=0
      ?}

:: Rejestracja operacji dla pracownika bezpośrednio do pozycji przewodnika
   ||
      exec('wykon_start','zl_wyk',ZGP.ref());
      '-*-e-kioski-*-';
      {? _is_term
      || _pracownik:=VEK.P
      || _pracownik:={? VAR1.KN3='N' & FILTER.PR_P<>null()
                     || FILTER.PR_P
                     || {? exec('is_fast_wyk','prod_rej')
                        || exec('p_select_simple','prod_rej')
                        || exec('p_select','prod_rej')
                        ?}
                     ?};
::        Jak rejestracja z poziomu partii to przypisuje do zmiennej wybranego pracownika
         {? VAR1.KN3='N' & FILTER.PR_P=null() & _pracownik<>null()
         || FILTER.PR_P:=_pracownik
         |? VAR1.KN3='N' & _pracownik=null()
         || _no_error:=1
         ?}
      ?};

      {? _pracownik<>null()
      ||
::       Podpowiadam czas tylko dla operacji TPZ lub zleceń warsztatowych
         _do_rej:={? ZGP.NRPRZ().ZLEC().TYP().WP='W' | ZGP.TPZ='T'
                  || ZGP.NTIME-exec('zgp_time_rej','zl_wyk',ZGP.ref())
                  || 0
                  ?};
         {? ~_is_term & exec('get','#params',500602)='T'
         || _ok:=exec('full_edit','zl_wyk',{? ZGP.BRYG='T' || 'B' || 'P' ?},_pracownik,,,{? _do_rej<0 || 0 || _do_rej ?});
            {? _ok
            ||
               _args:=exec('add_akord_a','zl_wyk');
               _args.ZGP:=ZGP.ref();
               _args.P:=_pracownik;
               _args.TIME:=VPRODREJ.TIME;
               _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
               _args.IL:=VPRODREJ.IL;
               _args.IL_BRAK:=VPRODREJ.IL_BRAK;
               _args.OK:=VPRODREJ.OK;
               _args.ZPARN:=VPRODREJ.ZPARN;
               _args.ZMIANA:=VPRODREJ.ZMIANA;
               _args.R:=VPRODREJ.R;
               _args.ST:=VPRODREJ.ST;
               _args.PLACE:=VPRODREJ.PLACE;
               _args.BRAKI_R:=VPRODREJ.BRAKI_R;
               _res:=exec('add_akord','zl_wyk',_args)
            ||
               _res:=0
            ?}
         ||
            {? ZGP.NRPRZ().ZLEC().TYP().WP='W'
            ||
               _ok:=exec('work_edit','zl_wyk',{? _do_rej<0 || 0 || _do_rej ?});
               {? _ok
               ||
                  _args:=exec('add_akord_a','zl_wyk');
                  _args.ZGP:=ZGP.ref();
                  _args.P:=_pracownik;
                  _args.TIME:=VPRODREJ.TIME;
                  _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                  _args.OK:=VPRODREJ.OK;
                  _args.ZPARN:=VPRODREJ.ZPARN;
                  _args.ENDD:=VPRODREJ.ENDD;
                  _args.ENDT:=VPRODREJ.ENDT;
                  _args.PLACE:=VPRODREJ.PLACE;
                  {? _is_term & VPRODREJ.WYD<>null()
                  || _args.WYD:=VPRODREJ.WYD
                  ?};
                  {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                  {? _args.ENDT<>time(0,0,0) & _p500645='C'
                  || _args.ZMIANA:='C'
                  |? _args.ENDT<>time(0,0,0) & _p500645='K'
                  || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                  || _args.ZMIANA:=''
                  ?};
                  _res:=exec('add_akord','zl_wyk',_args)
               || _res:=0
               ?}
            |? ZGP.TPZ='T'
            ||
               _ok:=exec('tpz_edit','zl_wyk',{? _do_rej<0 || 0 || _do_rej ?});
               {? _ok
               ||
                  _args:=exec('add_akord_a','zl_wyk');
                  _args.ZGP:=ZGP.ref();
                  _args.P:=_pracownik;
                  _args.TIME:=VPRODREJ.TIME;
                  _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                  _args.OK:=VPRODREJ.OK;
                  _args.ZPARN:=VPRODREJ.ZPARN;
                  _args.ENDD:=VPRODREJ.ENDD;
                  _args.ENDT:=VPRODREJ.ENDT;
                  _args.PLACE:=VPRODREJ.PLACE;
                  {? _is_term & VPRODREJ.WYD<>null()
                  || _args.WYD:=VPRODREJ.WYD
                  ?};
                  {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                  {? _args.ENDT<>time(0,0,0) & _p500645='C'
                  || _args.ZMIANA:='C'
                  |? _args.ENDT<>time(0,0,0) & _p500645='K'
                  || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                  || _args.ZMIANA:=''
                  ?};
                  _res:=exec('add_akord','zl_wyk',_args)
               ||
                  _res:=0
               ?}
            ||
               _ok:=exec('ile_edit','zl_wyk');
               {? _ok
               ||
                  _args:=exec('add_akord_a','zl_wyk');
                  _args.ZGP:=ZGP.ref();
                  _args.P:=_pracownik;
                  _args.TIME:=VPRODREJ.TIME;
                  _args.IL_DEKL:={? ZGP.KJ_BAD='N' || 'N' || 'T' ?};
                  _args.IL:=VPRODREJ.IL;
                  _args.IL_BRAK:=VPRODREJ.IL_BRAK;
                  _args.OK:=VPRODREJ.OK;
                  _args.ZPARN:=VPRODREJ.ZPARN;
                  _args.ENDD:=VPRODREJ.ENDD;
                  _args.ENDT:=VPRODREJ.ENDT;
                  _args.PLACE:=VPRODREJ.PLACE;
                  {? _is_term & VPRODREJ.WYD<>null()
                  || _args.WYD:=VPRODREJ.WYD
                  ?};
                  _args.BRAKI_R:=VPRODREJ.BRAKI_R;
                  {? _args.ENDD<>date(0,0,0) || _args.DT:=_args.ENDD ?};
                  {? _args.ENDT<>time(0,0,0) & _p500645='C'
                  || _args.ZMIANA:='C'
                  |? _args.ENDT<>time(0,0,0) & _p500645='K'
                  || _args.ZMIANA:=exec('zmiana','zl_common',_args.ENDT)
                  || _args.ZMIANA:=''
                  ?};
                  _res:=exec('add_akord','zl_wyk',_args)
               ||
                  _res:=0
               ?}
            ?}
         ?}
      ||
         _res:=0
      ?}
   ?};

   exec('blk_unlock','#table','ZGH',PROD_REJ.ZGH)

?};

Cntx.pop(ZL,ZGH,ZGP,KAP,GROP);
:: Jeżeli rejestracja od strony partii i użytkownik wyszedł z selekcji pracownika/brygady to zawracam -1, żeby nie
:: wyświetlać komunikatu błędu
{? VAR1.KN3='N' & _no_error>0
|| _res:=-1
?};
_res


\xwykon_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Wycofaj' w oknie rejestracji wykonań - przewodnik
::  OLD: \xwykon_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
FUN.info('W tym kontekście (przewodnik zlecenia) funkcja \'Wycofaj\' nie jest obsługiwana.'@);
0


\potw_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Potwierdź' w oknie rejestracji wykonań - przewodnik
::       Kontekst pracy: PROD_REJ
::  OLD: \potw_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~exec('access','zl_wyk') || return(0) ?};

{? PROD_REJ.A<>'T'
|| FUN.info('Zapis nieaktywny — nie można potwierdzić wykonania.'@);
   return(0)
?};

{? PROD_REJ.GROP=null()
|| FUN.info('Potwierdzenie wykonania dostępne tylko dla grup operacji.'@)
|| ZLGD.index('GROP');
   ZLGD.prefix(PROD_REJ.GROP);
   _size:=ZLGD.size();
   {? _size=0
   || FUN.info('Brak zapisów do potwierdzenia.'@)
   |? _size=1
   || {? ZLGD.first() || exec('zlgd_potw','zl_grop') ?}
   || exec('rej_4rej','zl_grop',0,'PUO')
   ?}
?};
1


\xpotw_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obsługa przycisku 'Odrzuć' w oknie rejestracji wykonań - przewodnik
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
{? ~exec('access','zl_wyk') || return(0) ?};

{? PROD_REJ.A<>'T'
|| FUN.info('Zapis nieaktywny — nie można odrzucić wykonania.'@);
   return(0)
?};

{? PROD_REJ.GROP=null()
|| FUN.info('Odrzucenie wykonania dostępne tylko dla grup operacji.'@)
|| ZLGD.index('GROP');
   ZLGD.prefix(PROD_REJ.GROP);
   _size:=ZLGD.size();
   {? _size=0
   || FUN.info('Brak zapisów do odrzucenia.'@)
   |? _size=1
   || {? ZLGD.first() || exec('zlgd_xpotw','zl_grop') ?}
   || exec('rej_4rej','zl_grop',0,'PUI')
   ?}
?};
1


\prac_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Pracownik' w oknie rejestracji wykonań - przewodnik
::       Kontekst pracy: PROD_REJ
::  OLD: \prac_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
ZGP.cntx_psh(); GROPP.cntx_psh();
ZGP.clear();
{? PROD_REJ.ZGP<>null()
|| {? ZGP.seek(PROD_REJ.ZGP)
   || VAR.A_NRPRZ:=ZGP.NRPRZ;
      VAR.A_NRZLP:=ZGP.NRZLP;
      {? ZGP.NTIME=0
      || FUN.info('Operacja tylko z czasem maszynowym — nie można przypisać pracownika.'@)
      |? ZGP.BRYG='T'
      || FUN.info('Operacja brygadowa — nie można przypisać pracownika.'@)
      |? GROPP.index('ZGP');
         GROPP.prefix(ZGP.ref());
         GROPP.first()
      || FUN.info('Zapis użyty w grupie operacji — nie można przypisać pracownika.'@)
      || exec('przp_kap','zl_kap',ZGP.ref())
      ?}
   || FUN.error('Brak przewodnika.'@)
   ?}
|? PROD_REJ.GROP<>null()
|| FUN.info('Grupa operacji — nie można przypisać pracownika.'@)
?};
ZGP.cntx_pop(); GROPP.cntx_pop();
~~


\bryg_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsługa przycisku 'Brygada' w oknie rejestracji wykonań - przewodnik
::       Kontekst pracy: PROD_REJ
::  OLD: \bryg_4rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
ZGP.cntx_psh(); GROPP.cntx_psh();
ZGP.clear();
{? PROD_REJ.ZGP<>null()
|| {? ZGP.seek(PROD_REJ.ZGP)
   || VAR.A_NRPRZ:=ZGP.NRPRZ;
      VAR.A_NRZLP:=ZGP.NRZLP;
      {? ZGP.NTIME=0
      || FUN.info('Operacja tylko z czasem maszynowym — nie można przypisać brygady.'@)
      |? ZGP.BRYG='N'
      || FUN.info('Operacja indywidualna — nie można przypisać brygady.'@)
      |? GROPP.index('ZGP');
         GROPP.prefix(ZGP.ref());
         GROPP.first()
      || FUN.info('Zapis użyty w grupie operacji — nie można przypisać brygady.'@)
      || exec('przp_kap','zl_kap',ZGP.ref())
      ?}
   || FUN.error('Brak przewodnika.'@)
   ?}
|? PROD_REJ.GROP<>null()
|| FUN.info('Grupa operacji — nie można przypisać brygady.'@)
?};
ZGP.cntx_pop(); GROPP.cntx_pop();
~~


\args_4guid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca wspólne wartości argumentów dla rejestracji do pozycji przewodnikow
::       Użyte z formułach exec('rej_zlec','zl_wyk'), exec('rej_zgh_pr','zl_wyk'),
::                         exec('rej_zgh_gpr','zl_wyk'), exec('rej_zgp_pr','zl_wyk')
::                         exec('rej_zgp_gpr','zl_wyk')
::  OLD: \args_4guid/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('rejestracja_a','prod_rej');
_args.F_NAWIG:=0;
_args.F_FILTER:=1;
_args.F_START:=0;
_args.F_STOP:=0;
_args.F_WYKON:=1;
_args.F_XWYKON:=1;
_args.F_PROB:=1;
_args.F_XPROB:=1;
_args.F_DOC:=1;
_args.F_MAT:=1;
_args.F_PRAC:=1;
_args.F_BRYG:=1;
_args.F_REJ:=1;
_args.F_NPU:=1;
_args.FILTR_PX:=0;
_args.FILTR_PL:=0;
_args.FILTR_ZL:=1;
_args.PR_DATA:=date(0,0,0);
_args.ED_DATA:=0;
_args.ED_ZAKR:=0;
_args.ED_RES:=1;
_args.ED_M:=1;
_args.ED_WYD:=1;
_args.ED_KH:=1;
_args.ED_OPIS:=1;
_args.ED_START:=1;
_args.ED_OK:=1;
_args.ED_POTW:=0;
_args.ED_PROB:=0;
_args.ED_PRAC:=1;
_args.ED_BRYG:=1;
_args.ED_KOOP:=1;
_args.ED_GROP:=0;
_args.ED_A:=1;
_args.ED_DOREJ:=1;
_args.ED_PX:=0;
_args.ED_PL:=0;
_args.ED_ZL:=1;
_args.ED_KONT:=1;
_args.CLOSE:="";
_args


\rej_zgp_pr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Rejestracja wykonan - z poziomu pozycji przewodnika (akcja przed)
::   WE: [_a] - miesjce wywołania: [1] - z poziomu tabeli ZGP,
::                                 0 - podczas kontroli zamknięcia zlecenia (rekord tabeli tymczasowej)
::  OLD: \rej_zgp_pr/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_where:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_tab:={? _where=0 || cur_tab(1,1) || ZGP ?};
{? _tab.sel_size()=0
||
   {? ~exec('access','zl_wyk') || return() ?};

   _args:=exec('args_4guid','zl_wyk');
   _args.WHERE:='PROD_REJ.ZGP in (select :_a.REF from :_a)';
   _args.JOIN:='';
   _args.TAB:=tab_tmp(1,'REF','STRING[16]','$ZGP.ref()');
   _ref:={? _where=0 || _tab.REF || $ZGP.ref() ?};
   _args.TAB.REF:=_ref;
   _args.TITLE:='Rejestracja dla '+exec('record','#to_string',ZGP.ref());
   _args.TAB.add();
   ZGP.cntx_psh();
   ZGP.index('TPZ');
   ZGP.prefix('T',ZGP.UID);
   {? ZGP.first()
   || _args.TAB.REF:=$ZGP.ref();
      _args.TAB.add()
   ?};
   exec('rejestracja','prod_rej',_args);
   ZGP.cntx_pop()
?};
~~


\rej_zgp_po
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Rejestracja wykonan - z poziomu pozycji przewodnika (akcja po)
::  OLD: \rej_zgp_po/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\rej_zgp_gpr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Rejestracja wykonan - z poziomu pozycji przewodnika (akcja przed grupa rekordow)
::   WE: [_a] - miesjce wywołania: [1] - z poziomu tabeli ZGP,
::                                 0 - podczas kontroli zamknięcia zlecenia (rekord tabeli tymczasowej)
::  OLD: \rej_zgp_gpr/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~exec('access','zl_wyk') || return(0) ?};

_where:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_tab_base:={? _where=0 || cur_tab(1,1) || ZGP ?};

sel_nchk();

ZGP.cntx_psh();
ZGP.clear();
_args:=exec('args_4guid','zl_wyk');
_args.WHERE:='PROD_REJ.ZGP in (select :_a.REF from :_a)';
_args.JOIN:='';
_tab:=_tab_base.sel_aget(); _tab_base.sel_adel();
_args.TAB:=tab_tmp(1,'REF','STRING[16]','$ZGP.ref()');
{? _tab.first()
|| {!
   |?
      _ref:={? _where=0 || exec('FindAndGet','#table',_tab_base,_tab.REF,,"REF",'') || _tab.REF ?};
      {? ZGP.seek(_ref,)
      ||
         _args.TAB.REF:=$ZGP.ref();
         _args.TAB.add();
         ZGP.cntx_psh();
         ZGP.index('TPZ');
         ZGP.prefix('T',ZGP.UID);
         {? ZGP.first()
         || _args.TAB.REF:=$ZGP.ref();
            _args.TAB.add()
         ?};
         ZGP.cntx_pop()
      ?};
      _tab.next()
   !}
?};
exec('rejestracja','prod_rej',_args);
ZGP.cntx_pop();
1


\rej_zgp_gpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Rejestracja wykonan - z poziomu pozycji przewodnika (akcja po grupie rekordow)
::  OLD: \rej_zgp_gpo/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\rej_zgh_pr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Rejestracja wykonan - z poziomu przewodnika (akcja przed)
::  OLD: \rej_zgh_pr/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZGH.sel_size()=0
||
   {? ~exec('access','zl_wyk') || return() ?};

   _args:=exec('args_4guid','zl_wyk');
   _args.WHERE:='ZGH.REFERENCE=\''+$ZGH.ref()+'\'';
   _args.JOIN:='
      join ZGH using(PROD_REJ.ZGH,ZGH.REFERENCE)
   ';
   _args.TITLE:='Rejestracja dla '+exec('record','#to_string',ZGH.ref());
   _args.CLOSE:="";
   exec('rejestracja','prod_rej',_args)
?};
~~


\rej_zgh_po
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Rejestracja wykonan - z poziomu przewodnika (akcja po)
::  OLD: \rej_zgh_po/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\rej_zgh_gpr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Rejestracja wykonan - z poziomu przewodnika (akcja przed grupa rekordow)
::  OLD: \rej_zgh_gpr/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~exec('access','zl_wyk') || return(0) ?};

_args:=exec('args_4guid','zl_wyk');
_args.WHERE:='ZGH.REFERENCE in (select :_a.REF from :_a)';
_args.JOIN:='
   join ZGH using(PROD_REJ.ZGH,ZGH.REFERENCE)
';
_tab:=ZGH.sel_aget(); ZGH.sel_adel();
_args.TAB:=tab_tmp(1,'REF','STRING[16]','$ZGH.ref()');
{? _tab.first()
|| {!
   |?
      {? ZGH.seek(_tab.REF,)
      ||
         _args.TAB.REF:=$ZGH.ref();
         _args.TAB.add()
      ?};
      _tab.next()
   !}
?};
exec('rejestracja','prod_rej',_args);
1


\rej_zgh_gpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Rejestracja wykonan - z poziomu przewodnika (akcja po grupie rekordow)
::  OLD: \rej_zgh_gpo/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\rej_zlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Rejestracja wykonań do przewodników - z poziomu zlecenia
::   WE: [_a] - czy uruchomienie z poziomu procesu lub listy ToDo
::  OLD: \rej_zlec/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~exec('access','zl_wyk') || return() ?};

_proces:={? var_pres('_a')=type_of(0) || _proces:=_a || _proces:=0 ?};

ZL.cntx_psh();

_args:=exec('args_4guid','zl_wyk');
_args.PROCES:=_proces;

{? var_pres('__GRUPA')<0
||
   _args.TITLE:='Rejestracje dla %1'@[exec('record','#to_string',VAR.A_ZLEC)];
   {? VAR.A_ZLEC().RODZAJ='P'
   ||
      _args.WHERE:='ZL.REFERENCE=\''+$VAR.A_ZLEC+'\''
   ||
      _args.WHERE:='ZL.REFERENCE in (select :_a.REF from :_a)';
      _args.TAB:=tab_tmp(1,'REF','STRING[16]','$ZL.ref()');
      ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(VAR.A_ZLEC().UNRZL);
      {? ZL.first()
      || {!
         |?
            _args.TAB.REF:=$ZL.ref();
            _args.TAB.add();
            ZL.next()
         !}
      ?};
      ZL.cntx_pop()
   ?}
||
   _args.WHERE:='ZL.REFERENCE in (select :_a.REF from :_a)';
   _args.TAB:=tab_tmp(1,'REF','STRING[16]','$ZL.ref()');
   {? __GRUPA.first()
   || {!
      |?
         {? ZL.seek(__GRUPA.REF,)
         ||
            {? ZL.RODZAJ='P'
            ||
               _args.TAB.REF:=$ZL.ref();
               _args.TAB.add()
            ||
               ZL.cntx_psh();
               ZL.index('NRNZL');
               ZL.prefix(ZL.UNRZL);
               {? ZL.first()
               || {!
                  |?
                     _args.TAB.REF:=$ZL.ref();
                     _args.TAB.add();
                     ZL.next()
                  !}
               ?};
               ZL.cntx_pop()
            ?}
         ?};
         __GRUPA.next()
      !}
   ?}
?};
exec('rejestracja','prod_rej',_args);
ZL.cntx_pop();
~~


\add_akord_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Tablica parametrow dla exec('add_akord','zl_wyk'), exec('update_akord','zl_wyk')
::  OLD: \add_akord_a/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
:: Źródłowy przewodnik (dla zlecenia zlożonego - podzlecenia)
   'ZGH',
:: Źródłowa pozycja przewodnika
   'ZGP',
:: Źródłowa grupa operacji
   'GROP',
:: Źródłowe stanowisko grupy operacji
   'GROPS',
:: Źródłowa karta pracy
   'KAP',
:: Pracownik
   'P',
:: Brygada
   'ZLBR',
:: Data, zmiana
   'DT',
   'ZMIANA',
:: Okres
   'OKR',
:: Wydzial (typu UD_SKL)
   'WYD',
:: Kwalifikacja godzin
   'R',
:: Stawka
   'ST',
:: czy rejestrowac wszystko, konkretna ilosc, czy % ?
:: Ilosc
   'IL',
   'IL_BRAK',
:: czy ilosc deklarowana (przed KJ) 'T', czy standard 'N'
   'IL_DEKL',
:: Czas, data i czas poczatku i konca operacji
   'TIME',
   'STARTD',
   'STARTT',
   'ENDD',
   'ENDT',
:: Oznaczenie, ze to juz koniec operacji (wazne dla Tpz)
   'OK',
:: Czy zapis automatyczny
   'AUTO',
:: Zrodlowy PL_WYK.UID jezeli replikacja z planu operacyjnego
   'PL_WYK',
:: Źródłowy $ZLGD.ref() jeżeli rejestracja dla grupy operacji
   'ZLGD_SRC',
:: Partia ktora przypisac do akordu
   'ZPARN',
:: ZWRACAMY ref dolaczonego rekordu
   'ZLGD',
:: czy zakończona e-kioski
   'ZAK',
::  Stanowisko
   'PLACE',
::  Rodzaj braku
   'BRAKI_R',
:: Status rejestracji braków
   'STAT_B'
::
);
_args.ZGH:=null();
_args.ZGP:=null();
_args.GROP:=null();
_args.GROPS:=null();
_args.KAP:=null();
_args.P:=null();
_args.ZLBR:=null();
_args.DT:={? date(ST.AR,ST.AM,0)=date(,,0) || date() || date(ST.AR,ST.AM,0) ?};
_args.ZMIANA:=exec('zmiana','zl_common',time());
_args.OKR:=exec('bl_a_okr','zl_wyk');
_args.WYD:=exec('bl_a_wyd','zl_wyk');
_args.R:=exec('bl_zlgd_r','zl_wyk');
_args.ST:=0;
_args.IL:=0;
_args.IL_BRAK:=0;
_args.IL_DEKL:='N';
_args.TIME:=0;
_args.STARTD:=date(0,0,0);
_args.STARTT:=time(0,0,0);
_args.ENDD:=date(0,0,0);
_args.ENDT:=time(0,0,0);
_args.OK:='N';
_args.AUTO:='N';
_args.PL_WYK:='';
_args.ZLGD_SRC:='';
_args.ZPARN:=null();
_args.ZLGD:=null();
_args.PLACE:=null;
_args.BRAKI_R:=null;
_args.STAT_B:='N';
'-*-e-kioski-*-';
exec('setArgs','ekioski',_args);
_args


\add_akord
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Dodaje rekord/rekordy ZLGD/ZLGB wg zadanych kryteriow
::       Dzialanie:
::       - jezeli podany ZGH, a brak ZGP, KAP, to zbiorcza rejestracja calego przewodnika
::       - jezeli podany ZGP, a brak KAP, to rejestracja do pozycji przewodnika
::       - jeżeli podany GROP (brak ZGH, ZGP, KAP), to rejestracja do grupy operacji
::       - jezeli podany KAP, to rejestracja do karty pracy
::   WE: _args - argumenty funkcji - wynik exec('add_akord_a','zl_wyk')
::   WY: 0 / 1 - czy operacja sie udala
::       Dodatkowo w _args.ZLGD przekazywany jest ZLGD.ref() dolaczonego rekordu
::  OLD: \add_akord/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_args:={? _=1 || _a || exec('add_akord_a','zl_wyk') ?};

_res:=0;

Cntx.psh(KAP,ZLGB,ZLGD,ZGH,ZGP,GROP,GROPS);

:: Otwieram maski zgodne z parametrami pracy
ZLGD.use(5+ZLGD.name()+ST.ODDZ+(2-form(ST.AR,-4,,'99')));
ZLGB.use(5+ZLGB.name()+ST.ODDZ+(2-form(ST.AR,-4,,'99')));
ZL_WYRGD.use(5+ZL_WYRGD.name()+ST.ODDZ+(2-form(ST.AR,-4,,'99')));

Cntx.clr(KAP,ZLGB,ZLGD,ZGH,ZGP,GROP,GROPS);
_cntx_pop:="Cntx.pop(KAP,ZLGB,ZLGD,ZGH,ZGP,GROP,GROPS)";

:: Sprawdzic zgodnosc ZGH i ZGP
{? _args.ZGH<>null() & _args.ZGP<>null()
|| {? ZGP.seek(_args.ZGP)
   || {? ZGP.NRZLP<>_args.ZGH
      || FUN.info('Niezgodność przekazanych danych — nagłówek i pozycja przewodnika.'@);
         _cntx_pop();
         return(0)
      ?}
   ?}
?};

:: Sprawdzic zgodnosc GROP i GROPS
{? _args.GROP<>null() & _args.GROPS<>null()
|| {? GROPS.seek(_args.GROPS)
   || {? GROPS.GROP<>_args.GROP
      || FUN.info('Niezgodność przekazanych danych — grupa operacji i zasób.'@);
         _cntx_pop();
         return(0)
      ?}
   ?}
?};
:: Sprawdzic zgodnosc KAP z ZGP
{? _args.KAP<>null() & _args.ZGP<>null()
|| {? KAP.seek(_args.KAP)
   || {? KAP.ZGP<>_args.ZGP
      || FUN.info('Niezgodność przekazanych danych — karta pracy i pozycja przewodnika.'@);
         _cntx_pop();
         return(0)
      ?}
   ?}
?};

:: pracownik/brygada z karty pracy, ilosci domyslnie z karty pracy, ale mozna zmienic
:: Kontekst tabel zrodlowych: KAP ustawione juz wczesniej
{? _args.KAP<>null()
|| {? KAP.seek(_args.KAP)
   || KAP.ZGP(); KAP.ZGH(); ZGH.ZLEC()
   || _cntx_pop();
      return(0)
   ?}

:: pracownik/brygada do wyboru, ilosci domyslnie z pozycji przewodnika, ale mozna zmienic
|? _args.ZGP<>null()
|| {? ZGP.seek(_args.ZGP)
   || ZGP.NRZLP(); ZGH.ZLEC()
   || _cntx_pop();
      return(0)
   ?}

:: grupa operacji
|? _args.GROPS<>null()
|| {? GROPS.seek(_args.GROPS)
   || GROPS.GROP()
   || _cntx_pop();
      return(0)
   ?}

|| _cntx_pop();
   return(0)
?};

'-*-e-kioski-*-';
{? VEK.TERM='T' | VAR1.ZAK_EK='T'
|| _ref:=exec('findZlgdZ','ekioski',_args.ZGP,_args.P,_args.ZLBR,_args.GROPS);
:: Dla operacji z czasem tylko maszynowycm czyścimy pracownika i brygadę
   {? _ref<>null() & _args.ZGP<>null() & exec('FindAndGet','#table',ZGP,_args.ZGP,,"ZGP.NTIME=0",0)
   || _args.P:=null(); _args.ZLBR:=null()
   ?}
|| _ref:=null()
?};
_add:=1;
{? _ref
||
   {? ref_name(_ref)<>ZLGD.name()
   || ZLGD.use(ref_name(_ref));
      ZLGB.use((5+ZLGB.name())+(ZLGD.name()+3));
      ZL_WYRGD.use((5+ZL_WYRGD.name())+(ZLGD.name()+3))
   ?};
   ZLGD.clear();
   {? ZLGD.seek(_ref)
   || _add:=0
   ?}
?};
{? _add
|| ZLGD.blank(1)
?};
{? _args.GROP<>null() | _args.GROPS<>null()
|| ZLGD.GROP:=_args.GROP;
   ZLGD.GROPS:=_args.GROPS;
   ZLGD.BP:={? _args.ZLBR<>null() || 'B' || 'P' ?}
|| ZLGD.ZL:=ZL.ref();
   ZLGD.ZGH:=ZGH.ref();
   ZLGD.ZGP:=ZGP.ref();
   ZLGD.BP:={? ZGP.BRYG='T' || 'B' || 'P' ?}
?};
ZLGD.B:=_args.ZLBR;
ZLGD.P:=_args.P;
ZLGD.DT:=_args.DT;
ZLGD.O:=_args.OKR;
ZLGD.IL_N:=0;      'ilosc nominalna';
ZLGD.TIME:=0;      'czas rzeczywisty';
ZLGD.IL:=0;        'ilosc rzeczywista';
ZLGD.IL_BRAK:=0;
ZLGD.DEK_IL:=0;
ZLGD.DEK_BR:=0;
ZLGD.ST:=0;        'stawka rzeczywista';
ZLGD.KW:=0;        'kwota rzeczywista';
ZLGD.WYD:=_args.WYD;
ZLGD.PLNX:=0;      'placa na XJM';
ZLGD.PLNH:=0;      'placa na godzine';
ZLGD.NTIME:=0;     'norma czasowa';
ZLGD.TIME_P:=0;    'czas kalkulowany';
ZLGD.ILGEN:=0;     'ilosc w raportach';
ZLGD.R:=_args.R;
ZLGD.KAP:=_args.KAP;
ZLGD.PLACE:=_args.PLACE;
ZLGD.STAT_B:=_args.STAT_B;
'-*-e-kioski-*-';
{? _add & _args.STARTD<>date(0,0,0)
|| ZLGD.STARTD:=exec('get','daty',_args.STARTD);
   ZLGD.STARTT:=_args.STARTT
?};
ZLGD.ENDD:=exec('get','daty',_args.ENDD);
ZLGD.ENDT:=_args.ENDT;
{? _args.ZMIANA='C' & ZLGD.STARTD<>null()
|| ZLGD.ZMIANA:=exec('zmiana_czasowo','zl_common',ZLGD.STARTD().DATA,ZLGD.STARTT,ZLGD.ENDD().DATA,ZLGD.ENDT)
|? _args.ZMIANA<>'' & _args.ZMIANA<>'C'
|| ZLGD.ZMIANA:=_args.ZMIANA
|? ZLGD.ZMIANA=''
|| ZLGD.ZMIANA:=exec('zmiana','zl_common',{? _args.STARTD=date(0,0,0) || time() || _args.STARTT ?})
?};
ZLGD.AUTO:=_args.AUTO;
ZLGD.PL_WYK:=_args.PL_WYK;
ZLGD.ZLGD_SRC:=_args.ZLGD_SRC;
ZLGD.USER:=OPERATOR.USER;
ZLGD.OK:=_args.OK;
{? VAR1.REJ_WYR='T'
||
:: Jeżeli rejestraja do wielu wyrobów to na zapisie robocizny nie ma partii - partie rozpisane na zapisach ZL_WYRGD
   ZLGD.ZPARN:=null()
|| ZLGD.ZPARN:=_args.ZPARN
?};
{? ZLGD.ZGP<>null()
|| ZLGD.KOOP:={? ZGP.WEW='T' || 'N' || 'T' ?};
   {? ZGP.KJ_BAD='N' || ZLGD.KJ_DONE:='N' || ZLGD.KJ_DONE:='P' ?};
   ZLGD.KJ_NEED:={? ZLGD.KJ_DONE='P' || 'T' || 'N' ?}
?};
'-*-e-kioski-*-';
ZLGD.ZAK:=_args.ZAK;
ZLGD.POTW:='N';

:: Wyliczenie pol analogicznie jak przy redagowaniu akordu
exec('wylicz_zlgd','zl_wyk');
:: Wyliczenie pozostalych pol, rozpisanie skladu brygady (ZLGB - jezeli wymagane)
VAR1.IL:=_args.IL;
VAR1.IL_BRAK:=_args.IL_BRAK;
VAR1.BRAKI_R:=_args.BRAKI_R;
{? _args.IL_DEKL='T'
|| ZLGD.DEK_IL:=VAR1.IL;
   ZLGD.DEK_BR:=VAR1.IL_BRAK;
   ZLGD.DEK_RBR:=_args.BRAKI_R
|| ZLGD.IL:=VAR1.IL;
   ZLGD.IL_BRAK:=VAR1.IL_BRAK;
   ZLGD.BRAKI_R:=_args.BRAKI_R
?};
{? _args.TIME<>0
|| ZLGD.TIME:=_args.TIME
|? ZLGD.STARTD<>null() & ZLGD.ENDD<>null() & exec('get','#params',500644)='T'
|| ZLGD.TIME:=(exec('create','#tm_stamp',ZLGD.ENDD().DATA,ZLGD.ENDT)
               -exec('create','#tm_stamp',ZLGD.STARTD().DATA,ZLGD.STARTT))/exec('hour','#tm_stamp')
|| ZLGD.TIME:=ZLGD.TIME_P
?};
exec('zlgd_kw','zl_wyk');
:: Zapis dla grupy operacji akceptowany bezwarunkowo
{? _args.GROP<>null() | exec('po_zg_is','zl_wyk','add_akord')
|| '-*-e-kioski-*-';
   {? do_state()
   || {? {? _add || ZLGD.add() || ZLGD.put() ?}
      || _args.ZLGD:=ZLGD.ref();
         '-*-e-kioski-*-';
         {? ZLGD.ZAK='T' & _args.GROP=null()
         || exec('zlgb_se1','zl_wyk')
         ?};
::       Utworzenie zapisów robocizny w rozbiciu na wyroby
         {? VAR1.REJ_WYR='T'
         || exec('zl_wyrgd_from_tab','zl_wyr')
         |? VAR1.KN3='N' & exec('zgp_czy_wyr','zl_wyr',ZLGD.ZGP)
         ||
::          Rejestracja wykonań od strony partii - tworzony 1 zapis zl_wyrgd na całą ilość na produkt główny zlec.
            exec('zl_wyrgd_add_main','zl_wyr')
         ?};
         _res:=1
      ?}
   || ZLGD.win_edit('RED');
      {?
::         Do testow mozna wlaczyc okno, w ktorym wyswietlane sa dane akordowe
::         ZLGD.edit("exec('chk_rec_zlgd','zl_akor1')")
         1
      || {? {? _add || ZLGD.add() || ZLGD.put() ?}
         || _args.ZLGD:=ZLGD.ref();
            '-*-e-kioski-*-';
            {? ZLGD.ZAK='T' & _args.GROP=null()
            || exec('zlgb_se1','zl_wyk')
            ?};
::          Utworzenie zapisów robocizny w rozbiciu na wyroby
            {? VAR1.REJ_WYR='T'
            || exec('zl_wyrgd_from_tab','zl_wyr')
            |? VAR1.KN3='N' & exec('zgp_czy_wyr','zl_wyr',ZLGD.ZGP)
            ||
::             Rejestracja wykonań od strony partii - tworzony 1 zapis zl_wyrgd na całą ilość na produkt główny zlec.
               exec('zl_wyrgd_add_main','zl_wyr')
            ?};
            _res:=1
         ?}
      ?}
   ?}
?};

:: Sprawdzam czy wymagany jest podział partii (par 500771)
{?  exec('get','#params',500771)='T' & VPRODREJ.AUTO='T' & _args.ZPARN<>null() & VAR1.REJ_WYR<>'T'
    & exec('FindAndGet','#table',ZL,ZLGD.ZL,,"ZL.RP='T'",0)
||
:: Wydzielenie nowej partii
   _new_ref:=exec('zparn_split','zl_wyk',ZLGD.ref(),_args.ZPARN,_args.ZGP,{? ZGP.BRYG='T' || ZLGD.B || ZLGD.P ?});
:: Przypisanie nowej partii
   {? _new_ref<>null() & _new_ref<>ZLGD.ZPARN
   ||  ZLGD.ZPARN:=_new_ref;
       ZLGD.put()
   ?}
?};

:: Zapisanie rozpiski rozliczenia surowców
{? var_pres('__ENV_REJ')>100 & __ENV_REJ.TYPE=0
|| __ENV_REJ.ZLGD:=ZLGD.ref();
   _tab:=__ENV_REJ.TAB;
   _tab.prefix();
   {? _tab.first()
   || {!
      |?
         exec('rej_mat_update','ekioski',1);
         _tab.next()
      !}
   ?};
   VAR_DEL.delete('__ENV_REJ')
?};

:: Sprawdzam czy korzystano z kontroli jakości w locie i jest to ostatnia rejestracja wykonania do danej operacji
{? _res=1 &  VAR1.KN1='T' & ( PROD_REJ.OK='T' | VPRODREJ.OK='T' | ZGP.STATUS=exec('status_end','zl_guide'))
||
:: Usuwam powiązany BADO, wiąże ZLGD z BADH
   BADH.cntx_psh();
   BADO.index('ZGP');
   BADO.prefix(VPRODREJ.PROD_REJ().ZGP);
   _first:=1;
   {? BADO.last()
   || {!
      |? {? BADVAR.BADH().AUTO<>'T'
         || {? _first=1
            || ZLGD.BADH:=BADO.BADH;
               ZLGD.KJ_NEED:='T';
               ZLGD.put();
              _first:=0
            ?}
         ?};
         {? BADO.BADH<>null()
         || BADH.cntx_psh();
            BADO.BADH();
            BADH.ZLGD:=ZLGD.ref();
            BADH.IL:=ZLGD.IL;
            BADH.IL_BRAK:=ZLGD.IL_BRAK;
            BADH.PREV_IL:=ZLGD.IL;
            BADH.PREV_BR:=ZLGD.IL_BRAK;
            BADH.put();
            BADH.cntx_pop()
         ?};
         BADO.del()
      !}
   ?};
   BADH.cntx_pop()
?};

:: Sprawdzam czy operacja wymaga przeprowadzenia badań w trakcie wykonywania operacji
{? _add
||
   '-*-e-kioski-*-';
   {? VEK.TERM='T'
   ||
::     Jak e-kiosk to tworzę badanie podczas staru operacji
      _bad_op:=exec('FindAndGet','#table',ZGP,ZLGD.ZGP,,"ZGP.BAD_OP",null());
      {? _bad_op<>null()
      ||
::       Tworzę badanie
         _badh:=exec('BADH_add_new','statexam',null(),_bad_op,0,,,,ZLGD.ZGP,1);
         {? _badh<>null()
         || ZLGD.BAD_OP:=_badh;
            ZLGD.put();
            BADH.cntx_psh();
            ZLGD.BAD_OP();
            BADH.ZLGD:=ZLGD.ref();
            BADH.TYP:='C';
            BADH.AUTO:='N';
            {? VEK.TERM<>'T'
            || BADH.STAN:='W'
            ?};
            BADH.put();
            BADH.cntx_pop()
         ?}
      ?}
   ||
      {? var_pres('__ENV_BAD')>100
      ||
::       Wyniki badania zarejestrowane podczas rejestracji wykonania produkcji w ERP
         _env:=__ENV_BAD;
         _tmp:=_env.TAB;
         BADSEH.cntx_psh();
         BADSEH.clear();
         {? BADSEH.seek(_env.BADSEH)
         ||
::          Tworzę badanie
            _badh:=exec('BADH_add_new','statexam',null(),BADSEH.ref(),0,,,,ZLGD.ZGP,1);
            {? _badh<>null()
            || BADP.cntx_psh();
               BADP.index('BADHBPAR');
               BADP.prefix(_badh);
::             Usuwam nadmiarowe parametry
               {? BADP.first() & VAR1.KN3<>'N'
               || {!
                  |?
                     {? ~_tmp.find_tab(,'PARREF',,'=',$BADP.BADPAR)
                     || _loop:=BADP.del(,1)=2
                     || _loop:=BADP.next()
                     ?};
                     _loop
                  !}
               ?};
::             Uzupełniam wartości parametrów
               _tmp.cntx_psh();
               _tmp.clear();
               {? _tmp.first() & VAR1.KN3<>'N'
               ||
                  {!
                  |?
                     _badpar:=exec('FindAndGet','#table',BADPAR,_tmp.PARREF,,,null());
                     {? _badpar<>null()
                     || _add:=1;
                        BADP.blank();
                        {? BADP.find_tab(,'BADPAR',,'=',_badpar)
                        || _add:=0
                        ?};
                        BADP.BADH:=_badh;
                        BADP.BADMSEP:=null();
                        BADP.BADPAR:=_badpar;
                        BADP.WAR:=_tmp.WAR;
                        BADP.VALUE:=_tmp.VALUE;
                        BADP.MAD_DT:=date();
                        BADP.MAD_TM:=time();
                        BADP.MAD_USER:=OPERATOR.USER;
                        {? _add>0
                        || BADP.add(1)
                        || BADP.put(1)
                        ?}
                     ?};
                     _tmp.next()
                  !}
               ?};
               _tmp.cntx_pop();
               BADP.cntx_pop();
::             Przypinam badanie(BADH) do robocizny(ZLGD), i zapis robocziny do badania
               ZLGD.BAD_OP:=_badh;
               ZLGD.put();
               BADH.cntx_psh();
               ZLGD.BAD_OP();
               BADH.ZLGD:=ZLGD.ref();
               BADH.TYP:='C';
               BADH.AUTO:='N';
               BADH.STAN:='W';
               BADH.MAD_DT:=date();
               BADH.MAD_TM:=time();
               BADH.MAD_USER:=OPERATOR.USER;
               BADH.put();
               BADH.cntx_pop()
            ?}
         ?};
         VAR_DEL.delete('__ENV_BAD');
         BADSEH.cntx_pop()
      ?}
   ?}
||
   '-*-e-kioski-*-';
:: Sprawdzam czy było utworzone badanie przy starcie operacji i aktualizuje je
   BADH.cntx_psh();
   BADH.index('TZLGD');
   BADH.prefix('C',ZLGD.ref(),ref_name(ZLGD.ref()));
   {? BADH.first()
   || BADH.STAN:='W';
      BADH.MAD_DT:=date();
      BADH.MAD_TM:=time();
      BADH.MAD_USER:=OPERATOR.USER;
      BADH.put()
   ?};
   BADH.cntx_pop()
?};
_cntx_pop();
_zl_ref:=exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"ZL",null());
_zl_uid:=exec('FindAndGet','#table',ZL,_zl_ref,,"uidref()",'');

:: Obsługa procesowości (tylko gdy nie ma transakcji/triggera, nie jest to grupa operacji,
:: i jest uprawnienie do TTE_WYK_DWZL) może powodować popchnięcie/wzbudzenie procesów zawierających tę czynność
{? _res=1
   & _args.GROP=null()
   & do_state()=0
   & exec('chk_role','#b__box',OPERATOR.USER,'TTE_WYK_DWZL')
||
:: Nie jest to start operacji
   {? exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"ZAK='T'",0)
   || _arg:=exec('mp_run_a','#b__box');
      _arg.ACT_UID:='TTE_WYK_DWZL';
      _arg.UIDREF:=_zl_uid;
      _arg.AKCJA:='ZAKOŃCZ';
      _arg.PORTS_IN:=exec('portsIn','#b__box',_arg.ACT_UID);
      _arg.PROC_START:='T';
      _arg.CONTEXT:=obj_new('ZLGD','ZGP','ILOSC','BRAKI');
         _arg.CONTEXT.ZLGD:=_args.ZLGD;
         _arg.CONTEXT.ZGP:=exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"ZGP",null());
         _arg.CONTEXT.ILOSC:=exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"IL",0);
         _arg.CONTEXT.BRAKI:=exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"IL_BRAK",0);
      exec('portsInSet','#b__box',_arg.PORTS_IN,_arg.ACT_UID,'ZL',_zl_ref);

      exec('mp_run','#b__box',_arg)

:: Start operacji
   || _arg:=exec('mp_run_a','#b__box');
      _arg.ACT_UID:='TTE_WYK_DWZL';
      _arg.UIDREF:=_zl_uid;
      _arg.AKCJA:='ROZPOCZNIJ';
      _arg.PORTS_IN:=exec('portsIn','#b__box',_arg.ACT_UID);
      _arg.PROC_START:='T';
      _arg.CONTEXT:=obj_new('ZLGD','ZGP');
         _arg.CONTEXT.ZLGD:=_args.ZLGD;
         _arg.CONTEXT.ZGP:=exec('FindAndGet','#table',ZLGD,_args.ZLGD,,"ZGP",null());

      exec('portsInSet','#b__box',_arg.PORTS_IN,_arg.ACT_UID,'ZL',_zl_ref);

      exec('mp_run','#b__box',_arg)
   ?}
?};

{? _res=1 & VAR1.IL_BRAK>0
|| exec('desc_update','#b__box',_zl_uid,'TTE_PZL_DGBR')
?};

_res


\update_akord
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Modyfikuje rekord/rekordy ZLGD/ZLGB wg zadanych kryteriow
::       Obecnie dzialanie puste, o ile dotyczy takiego PL_WYK.UID, ktore jest juz w bazie
::       wpp. undo transakcji, gdyz jest to bledne wywolanie
::   WE: _args - argumenty funkcji - wynik exec('add_akord_a','zl_wyk')
::  OLD: \update_akord/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_args:={? _=1 || _a || exec('add_akord_a','zl_wyk') ?};

Cntx.psh(ZLGD,ZLGB);

ZLGD.index('PL_WYK');
ZLGD.prefix(_args.PL_WYK);
{? ZLGD.first()
|| ZLGD.B:=_args.ZLBR;
   ZLGD.P:=_args.P;
   ZLGD.DT:=_args.DT;
   ZLGD.O:=_args.OKR;
   ZLGD.ZMIANA:=_args.ZMIANA;
   ZLGD.STARTD:=exec('get','daty',_args.STARTD);
   ZLGD.STARTT:=_args.STARTT;
   ZLGD.ENDD:=exec('get','daty',_args.ENDD);
   ZLGD.ENDT:=_args.ENDT;
   ZLGD.OK:=_args.OK;
   ZLGD.PLACE:=_args.PLACE;

:: Wyliczenie pol analogicznie jak przy redagowaniu akordu
   exec('wylicz_zlgd','zl_wyk');
:: Wyliczenie pozostalych pol, rozpisanie skladu brygady (ZLGB - jezeli wymagane)
   VAR1.IL:=_args.IL;
   VAR1.IL_BRAK:=_args.IL_BRAK;
   {? _args.IL_DEKL='T'
   || ZLGD.DEK_IL:=VAR1.IL;
      ZLGD.DEK_BR:=VAR1.IL_BRAK
   || ZLGD.IL:=VAR1.IL;
      ZLGD.IL_BRAK:=VAR1.IL_BRAK
   ?};
   {? _args.TIME<>0 || ZLGD.TIME:=_args.TIME || ZLGD.TIME:=ZLGD.TIME_P ?};
   exec('zlgd_kw','zl_wyk');
   {? exec('po_zg_is','zl_wyk','update_akord')
   || {? do_state()
      || {? ZLGD.put()
         || ZLGB.index('ZLGD');
            ZLGB.prefix(ZLGD.ref());
            {? ZLGB.first() || {! |? ZLGB.del() !} ?};
            exec('zlgb_se1','zl_wyk');
            _res:=1
         ?}
      || ZLGD.win_edit('RED');
         {?
::         Do testow mozna wlaczyc okno, w ktorym wyswietlane sa dane akordowe
::         ZLGD.edit("exec('chk_rec_zlgd','zl_akor1')")
            1
         || {? ZLGD.put()
            || ZLGB.index('ZLGD');
               ZLGB.prefix(ZLGD.ref());
               {? ZLGB.first() || {! |? ZLGB.del() !} ?};
               exec('zlgb_se1','zl_wyk');
               _res:=1
            ?}
         ?}
      ?}
   || undo('Nie można poprawić zapisu akordowego.'@)
   ?};
   ~~
||
   undo('Formuła %1 — błędne wywołanie.'@['\update_akord/zl_akor2.fml'])
?};

Cntx.pop(ZLGD,ZLGB);
~~


\ile_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Okno redagowania ilosci do pozycji przewodnika - mozliwosc podania %
::       Kontekst pracy: rekord ZGP, rekord PROD_REJ, pola VPRODREJ.IL_POP, VPRODREJ.MAX
::   WE: [_a] - wartosc poczatkowa pola VPRODREJ.IL
::   WY: 1 - potwierdzenie, 0 - rezygnacja
::       Wypelniane sa pola VPRODREJ.IL, VPRODREJ.IL_BRAK
::  OLD: \ile_edit/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
VPRODREJ.EDIT_ILP:=0;
VPRODREJ.EDIT_IL:=1;
VPRODREJ.EDIT_ILB:=1;
VPRODREJ.EDIT_PR:=0;
VPRODREJ.EDIT_OK:=1;

VPRODREJ.PROD_REJ:=PROD_REJ.ref();
VPRODREJ.OPER:=PROD_REJ.OPER;
VPRODREJ.M:=PROD_REJ.M;
VPRODREJ.DOKL:=PROD_REJ.M().DOKL;
VPRODREJ.JM:=PROD_REJ.JM;
VPRODREJ.PROCENT:=100;
VPRODREJ.PLACE:=PROD_REJ.ZGP().PLACE;
VPRODREJ.IL_PLAN:=PROD_REJ.ILC;
VPRODREJ.IL_DOREJ:=
   {? var_pres('_a')=type_of(0)
   || _a
   || {? VPRODREJ.MAX
      || VPRODREJ.IL_POP-{? ZGP.IL>0 | ZGP.IL_BRAK>0 || ZGP.IL+ZGP.IL_BRAK || ZGP.DEK_IL-ZGP.DEK_BR ?}
      || PROD_REJ.ILC-ZGP.DEK_IL-ZGP.DEK_BR-exec('count_napr4zgp','braki',ZGP.ref())
      ?}
   ?};
{? exec('is_fast_wyk','prod_rej') & VPRODREJ.IL_DOREJ<=0 & exec('get','#params',500634)<>'T'
|| VPRODREJ.IL_DOREJ:=PROD_REJ.ILC-ZGP.DEK_IL-ZGP.DEK_BR-exec('count_napr4zgp','braki',ZGP.ref())
?};
{? exec('is_fast_wyk','prod_rej') & VPRODREJ.ZPARN<>null()
||
:: Zmniejszam ilość do rejestracji na tą dostępną dla partii, pod warunkiem że partia jest dla tego zlecenia do którego
:: rejestruję. W przypadku zleceń złożonych może być przypadek że rejestruję do półfabrykatu którego jest 400
:: a na zleceniu montażowym partia ma 100, wiec nie powinienem ograniczać ilości
   {? VPRODREJ.ZPARN().ZL=PROD_REJ.ZL
   || VPRODREJ.IL_DOREJ:=exec('min','#math',VPRODREJ.IL_DOREJ,exec('ilosc_left','zl_partie',VPRODREJ.ZPARN,'R',ZGP.ref()))
   ?}
?};

{? VPRODREJ.IL_DOREJ<0 || VPRODREJ.IL_DOREJ:=0 ?};
:: Jak rejestracja z poziomu partii lub zakańczanie operacji rozpoczętej to zmienne są już wypełnione
{? VAR1.KN3<>'N' & VAR1.ZAK_EK<>'T'
|| VPRODREJ.IL:=VPRODREJ.IL_DOREJ;
   VPRODREJ.IL_BRAK:=0;
   VPRODREJ.TIME:=0;
   VPRODREJ.OK:='N'
?};
VPRODREJ.BRAKI_R:=null();
:: Podpowiadanie braków po kontroli jakości
BADO.cntx_psh();
BADO.index('ZGP');
BADO.prefix(VPRODREJ.PROD_REJ().ZGP);
_bado:=0;
{? BADO.last()
|| _badh:=BADO.BADH;
   {? _badh<>null
   || _msk_old:=BADH.name;
      _msk_new:=ref_name(_badh);
      {? _msk_old<>_msk_new
      || BADH.use(_msk_new)
      ?};
      {? BADH.seek(_badh) & BADH.STAN='Z'
      || _bado:=1;
         BADVAR.BADH:=BADH.ref
      ?}
   ?}
?};
{? _bado=1
||
::   VPRODREJ.IL_BRAK:=BADO.IL_BRAK;
   {? BADO.ILP>0
   || _il:={? BADO.IL_BRAK<BADO.ILP || BADO.ILP || BADO.IL_BRAK ?};
      FUN.info('Do wskazanej operacji została przeprowadzona kontrola jakości. Stwierdzono liczbę braków w liczbie: %1'@
               [$_il])
   ?};
   VAR1.KN1:='T'
|| VAR1.KN1:='N'
?};
:: Sprawdzenie, czy dostępna funkcjonalność rejestracji wykonania do wielu produktów
{? VAR1.KN3<>'N' & exec('zgp_czy_wyr','zl_wyr',PROD_REJ.ZGP)
|| VAR1.REJ_WYR:='T';
   VPRODREJ.IL:=0
|| VAR1.REJ_WYR:='N'
?};
{? VEK.TERM='T'
|| VPRODREJ.AUTO:='T'
|? VAR1.KN3='N'
|| VPRODREJ.AUTO:='N'
|? VPRODREJ.AUTO=''
|| VPRODREJ.AUTO:='T'
?};
VPRODREJ.win_edit('ZL_WYK_L');
:: Zablokowanie pola stanowisko dla rejestracji do kooperacji
{? ZGP.WEW<>'T'
|| VPRODREJ.efld_opt(VPRODREJ.win_edit('?'),'editable=grayed,mark=0',,'PLACE')
|| VPRODREJ.efld_opt(VPRODREJ.win_edit('?'),'editable=1,mark=1',,'PLACE')
?};
:: Sprawdzenie czy są surowce nielimitowane do rozliczenia
{? VEK.TERM<>'T' & VAR1.ZAK_EK<>'T'
|| ZLIM.cntx_psh();
   exec('openmask','zl_common',PROD_REJ.ZL);
   ZLIM.index('ZGP_ROZ');
   ZLIM.prefix(PROD_REJ.ZGP,'N','T');
   {? ZLIM.first()
   || _create:=1;
      VPRODREJ.btn_eopt('ZL_WYK_L','SUROWCE','state=normal');
      {? var_pres('__ENV_REJ')>100
      || {? __ENV_REJ.ZGP<>PROD_REJ.ZGP
         || obj_del(__ENV_REJ)
         || _create:=0
         ?}
      ?};
      {? var_pres('_tab')>0 || obj_del(_tab) ?};
      _il:={? VEK.TERM<>'T' | VAR1.ZAK_EK='T'
           || VPRODREJ.IL+VPRODREJ.IL_BRAK
           || #(exec('get_value','#desktop','#:ctr_menu_end','ctr_menu_end','fld_il@menu_end')) +
              #(exec('get_value','#desktop','#:ctr_menu_end','ctr_menu_end','fld_il_brak@menu_end'))
           ?};
      {? _create
      || exec('env_rej_mat','zl_wyk');
         __ENV_REJ.ZGP:=ZLGD.ZGP;
         _tab:=__ENV_REJ.TAB;
         VAR.fld_fml('A_MAG','AFTER_EDIT',"
            _tab:=__ENV_REJ.TAB;
            _ktm:=exec('FindAndGet','#table','M',_tab.MREF,,\"M.ref\",null);
            _dk_c:=exec('FindAndGet','#table','DK_C',_tab.DKCREF,,\"DK_C.ref\",null);
            _zl:=exec('FindAndGet','#table','ZL',_tab.ZLREF,,\"ZL.ref\",null);
::          Sprawdzam dostępny stan magazynowy dla podanej pozycji
            {? _dk_c<>null()
            || exec('obl_stan','magazyn_stan',_ktm,1,VAR.A_MAG,,,date(),-2,,,,_dk_c)
            || exec('obl_stan','magazyn_stan',_ktm,1,VAR.A_MAG,,,date(),-2)
            ?};
            VAR.REAL:=BEER.SD;
            VAR.REAL+=exec('zlim_il_rez','zl_nlimit',_tab.ZLIMREF);
             1
         ");
::       Tworzy rozpiskę do rozliczeń surowców nielimitowanych
         {!
         |? _tab.KTM:=exec('FindAndGet','#table',M,ZLIM.KTM,,"KTM",'');
            _tab.M:=exec('FindAndGet','#table',M,ZLIM.KTM,,"N",'');
            _tab.JM:=exec('FindAndGet','#table',M,ZLIM.KTM,,"J().KOD",'');
            _tab.MG:=exec('FindAndGet','#table',MG,ZLIM.MG,,"SYM",'');
::            _tab.STAN:=exec('FindInSet','#table','SM','SM',ZLIM.KTM,ZLIM.MG,"SM.SD",,,0);
            _tab.LIL:=ZLIM.LIL;
            _tab.MGREF:=$ZLIM.MG;
            _tab.MREF:=$ZLIM.KTM;
            _tab.TMATREF:=$ZLIM.TMAT;
            _tab.ZLIMREF:=$ZLIM.ref;
            _tab.ZLREF:=$ZLIM.ZLEC;
            _tab.DKCREF:={? ZLIM.DK_C<>null || $ZLIM.DK_C || '' ?};

::          Sprawdzam dostępny stan magazynowy dla podanej pozycji
            {? ZLIM.DK_C<>null()
            || exec('obl_stan','magazyn_stan',ZLIM.KTM,1,ZLIM.MG,,,date(),-2,,,,ZLIM.DK_C)
            || exec('obl_stan','magazyn_stan',ZLIM.KTM,1,ZLIM.MG,,,date(),-2)
            ?};
            _tab.STAN:=BEER.SD;
            _tab.STAN+=exec('zlim_il_rez','zl_nlimit',_tab.ZLIMREF);
            _tab.IL:=0;
::          Wyliczam ilość - tylko przy rejestracji wykonań z poziomu partii
            {? VAR1.KN3='N'
            || _dokl:=exec('jaka_dok_m','jm',ZLIM.KTM);
               _il_zgp:=exec('FindAndGet','#table','ZGP',ZLIM.ZGP,,"ZGP.ILOSC",1);
::            _il_zl:=exec('FindAndGet','#table','ZL',ZLIM.ZLEC,,"ZL.IL",1);
               _tab.IL:={? _dokl>0
                        || ((ZLIM.LIL*_il)/_il_zgp)$ _dokl
                        || ceil(((ZLIM.LIL*_il)/_il_zgp))
                        ?}
            ?};
            _tab.add();
            ZLIM.next()
         !}
      ?}
   || VPRODREJ.btn_eopt('ZL_WYK_L','SUROWCE','state=grayed')
   ?};
   ZLIM.cntx_pop()
?};

:: Sprawdzam czy operacja wymaga przeprowadzenia badań w trakcie wykonywania operacji
{? VEK.TERM<>'T' & VAR1.ZAK_EK<>'T'
|| _bad_op:=exec('FindAndGet','#table',ZGP,VPRODREJ.PROD_REJ().ZGP,,"ZGP.BAD_OP",null());
   {? _bad_op<>null()
   || VPRODREJ.btn_eopt('ZL_WYK_L','BADANIE','state=normal');
::    Tworzę środowisko do rejestrowania badań
      _env:=exec('env_bad_op','statexam');
      _env.BADSEH:=_bad_op;
      {? var_pres('_tab')>100 || obj_del(_tab) ?};
      _tab:=_env.TAB;
::    Przepisuje parametry badania
      BADSEP.cntx_psh();
      BADSEP.index('SEHPAR_');
      BADSEP.prefix(_bad_op);
      {? BADSEP.first()
      ||
         {!
         |?
            _tab.blank();
            _tab.PAR:=BADSEP.BADPAR().N;
            _tab.TYP:=BADSEP.BADPAR().TYP;
            _tab.SOURCE:=BADSEP.SOURCE;
            _tab.PARREF:=$BADSEP.BADPAR;
            {? BADSEP.CZY_DEF='T'
            || {? BADSEP.BADPAR().TYP='D' & BADSEP.DEF_CURD='T'
               ||
::                Wyznaczenie wartości domyślnej na podstawie bieżącej daty
                  _tab.WAR:=(date()+BADSEP.DEF_DNI)$1
               || _tab.WAR:=BADSEP.DEF_VAL
               ?};
               _tab.VALUE:=exec('getvalfromwar','statexam',_tab.TYP,_tab.WAR)
            ?};
            _tab.add(1);
            BADSEP.next()
         !}
      ?};
      BADSEP.cntx_pop()
   || VPRODREJ.btn_eopt('ZL_WYK_L','BADANIE','state=grayed')
   ?}
?};

_valid:="
:: Czy zbierać informacje do KOMM
   _komm:={? var_pres('_a')=type_of(0) || _a || 0 ?};
   _ctr_ilosc:={? (VEK.TERM='T' | VAR1.ZAK_EK='T') & exec('get','#params',500643)='T' || 0 || 1 ?};
   _result:='';
   _txt:={? VAR1.KN3='N'
         || 'Wystąpił błąd podczas walidacji danych. Komunikat błędu: '@
         || ''
         ?};
   _bado_ilb:=BADO.IL_BRAK;
   {? VAR1.KN1='T' & _bado_ilb<BADO.ILP
   || _bado_ilb:=BADO.ILP
   ?};
   {? _ctr_ilosc & VPRODREJ.IL=0 & VPRODREJ.IL_BRAK=0
   || {? _komm>0
      || _txt+='Ilość musi być określona.'@
      || FUN.info('Ilość musi być określona.'@)
      ?};
      {? VPRODREJ.EDIT_PR
      || _result:='PROCENT'
      || _result:='IL'
      ?}
   |? VPRODREJ.IL<0
   || {? _komm>0
      || _txt+='Proszę podać ilość większą lub równą zero.'@
      || FUN.info('Proszę podać ilość większą lub równą zero.'@)
      ?};
      _result:='IL'
   |? VPRODREJ.IL_BRAK<0
   || {? _komm>0
      || _txt+='Proszę podać ilość większą lub równą zero.'@
      || FUN.info('Proszę podać ilość większą lub równą zero.'@)
      ?};
      _result:='IL_BRAK'
   |? (exec('get','#params',500631,2)='T' | exec('get','#params',500634,2)='T')
      & VPRODREJ.MAX & VPRODREJ.IL+VPRODREJ.IL_BRAK>VPRODREJ.IL_POP-ZGP.IL-ZGP.IL_BRAK-ZGP.DEK_IL-ZGP.DEK_BR
   || {? _komm>0
      || _txt+='Maksymalna ilość, którą można zarejestrować: %1 %2.'@
               [$(VPRODREJ.IL_POP-ZGP.IL-ZGP.IL_BRAK-ZGP.DEK_IL-ZGP.DEK_BR),VPRODREJ.JM().KOD]
      || FUN.emsg('Maksymalna ilość, którą można zarejestrować: %1 %2.'@
               [$(VPRODREJ.IL_POP-ZGP.IL-ZGP.IL_BRAK-ZGP.DEK_IL-ZGP.DEK_BR),VPRODREJ.JM().KOD])
      ?};
      {? VPRODREJ.EDIT_PR
      || _result:='PROCENT'
      || _result:='IL'
      ?}
   |? VPRODREJ.TIME<0
   || {? _komm>0
      || _txt+='Czas nie może być ujemny.'@
      || FUN.info('Czas nie może być ujemny.'@)
      ?};
      _result:='TIME'
:: Kontrola jakości w locie przy manualnym zakończaniu operacji
   |? VAR1.KN1='T' & VPRODREJ.OK='T' & VPRODREJ.IL_BRAK<BADO.ILP
   || _ilb:=BADO.ILP;
      {? _komm>0
      || _txt+='Próba zakończenia operacji z nieprawidłową liczbą zarejestrowanych braków.'
               'Ilość braków nie może być mniejsza od liczby wskazanej przy kontroli jakości (%1).'@[$_bado_ilb]
      || FUN.info('Próba zakończenia operacji z nieprawidłową liczbą zarejestrowanych braków.\n'
                  'Ilość braków nie może być mniejsza od liczby wskazanej przy kontroli jakości (%1).\n'
                  'Dotychczas zarejestrowano %2/%1 braków.\n'
                  'Podczas bieżącej rejestracji liczba braków musi wynosić co najmniej %3.'@[$_bado_ilb,$(_bado_ilb-BADO.ILP),$_ilb])
      ?};
      _result:='IL_BRAK'
:: Kontrola jakości w locie przy kontroli ilościowej
   |? VAR1.KN1='T' & (PROD_REJ.SRODZ='ZL' & (exec('get','#params',500631,2)='T' | exec('get','#params',500634,2)='T')
         | (PROD_REJ.SRODZ='PX' & exec('get','#params',500633,2)='T')  | (PROD_REJ.SRODZ='PL' & exec('get','#params',500632,2)='T'))
         & VPRODREJ.IL_BRAK<BADO.ILP
         & ( ( VPRODREJ.IL_POP<>0
         & VPRODREJ.IL+BADO.ILP>VPRODREJ.IL_POP-ZGP.IL-ZGP.IL_BRAK-ZGP.DEK_IL-ZGP.DEK_BR)
         | ( VPRODREJ.IL_POP=0
         & VPRODREJ.IL+BADO.ILP>ZGP.ILOSC-ZGP.IL-ZGP.DEK_IL-ZGP.IL_BRAK-ZGP.DEK_BR))
   || _ilb:=BADO.ILP;
      _ilm:={? VPRODREJ.IL_POP<>0 || VPRODREJ.IL_DOREJ || ZGP.ILOSC-ZGP.IL-ZGP.DEK_IL-ZGP.IL_BRAK-ZGP.DEK_BR ?} - VPRODREJ.IL-VPRODREJ.IL_BRAK;
      {? _ilb<_ilm
      || _ilb:=_ilm-_ilb
      || _ilb:=_ilb - {? _ilm>0 || _ilm || 0 ?}
      ?};
      {? _komm>0
      || _txt+='Próba zakończenia operacji z nieprawidłową liczbą zarejestrowanych braków.'
               'Ilość braków nie może być mniejsza od liczby wskazanej przy kontroli jakości (%1).'@[$_bado_ilb]
      || FUN.info('Próba zakończenia operacji z nieprawidłową liczbą zarejestrowanych braków.\n'
                  'Ilość braków nie może być mniejsza od liczby wskazanej przy kontroli jakości (%1).\n'
                  'Dotychczas zarejestrowano %2/%1 braków.\n'
                  'Podczas bieżącej rejestracji liczba braków musi wynosić co najmniej %3.'@[$_bado_ilb,$(_bado_ilb-BADO.ILP),$_ilb])
      ?};
      _result:='IL_BRAK'
:: Kontrola jakości w locie przy braku kontroli ilościowej
   |? VAR1.KN1='T' & (PROD_REJ.SRODZ='ZL' & (exec('get','#params',500631,2)='N' & exec('get','#params',500634,2)='N')
         | (PROD_REJ.SRODZ='PX' & exec('get','#params',500633,2)='N')  | (PROD_REJ.SRODZ='PL' & exec('get','#params',500632,2)='N'))
         & VPRODREJ.IL_BRAK<BADO.ILP
         & VPRODREJ.IL+BADO.ILP>ZGP.ILOSC-ZGP.IL-ZGP.DEK_IL-ZGP.IL_BRAK-ZGP.DEK_BR
   || _ilm:=ZGP.ILOSC-ZGP.IL-ZGP.DEK_IL-ZGP.IL_BRAK-ZGP.DEK_BR-VPRODREJ.IL-VPRODREJ.IL_BRAK;
      _ilb:=BADO.ILP;
      {? _ilb<_ilm
      || _ilb:=_ilm-_ilb
      ?};
      {? _komm>0
      || _txt+='Próba zakończenia operacji z nieprawidłową liczbą zarejestrowanych braków.'
               'Ilość braków nie może być mniejsza od liczby wskazanej przy kontroli jakości (%1).'@[$_bado_ilb]
      || FUN.info('Próba zakończenia operacji z nieprawidłową liczbą zarejestrowanych braków.\n'
                  'Ilość braków nie może być mniejsza od liczby wskazanej przy kontroli jakości (%1).\n'
                  'Dotychczas zarejestrowano %2/%1 braków.\n'
                  'Podczas bieżącej rejestracji liczba braków musi wynosić co najmniej %3.'@[$_bado_ilb,$(_bado_ilb-BADO.ILP),$_ilb])
      ?};
      _result:='IL_BRAK'
:: Kontrola rodzaju braku
   |? VPRODREJ.IL_BRAK>0 & exec('get','#params',500635,2)='T' & VPRODREJ.BRAKI_R=null()
   || {? _komm>0
      || _txt+='Należy określić rodzaj braku.'@
      || FUN.emsg('Należy określić rodzaj braku.'@)
      ?};
      _result:='BRAKI_R'
   |? ZGP.WEW='T' & VPRODREJ.PLACE=null()
   || {? _komm>0
      || _txt+='Należy wskazać stanowisko, na którym została wykonana operacja.'@
      || FUN.info('Należy wskazać stanowisko, na którym została wykonana operacja.'@)
      ?};
      _result:='PLACE'
:: Kontrola rozpiski rozliczeń surowców
   |? (_mat:=exec('chk_rej_mat','zl_nlimit'))<>''
   || {? _komm>0
      || _txt+='Nieprawidłowa wartość ilości dla materiału: %1.'@[_mat]
      || FUN.info('Nieprawidłowa wartość ilości dla materiału: %1.'@[_mat])
      ?};
      _result:='IL'
   |? VPRODREJ.MAX & VPRODREJ.IL+VPRODREJ.IL_BRAK>VPRODREJ.IL_POP-ZGP.IL-ZGP.IL_BRAK-ZGP.DEK_IL-ZGP.DEK_BR
   ||
::      FUN.emsg('Maksymalna ilość, którą powinno się zarejestrować: '+$(VPRODREJ.IL_POP-ZGP.IL-ZGP.IL_BRAK)+' '+VPRODREJ.JM().KOD+'.');
      _result:=''
   ?};
:: Kontrola partii
   {? _result='' & (VAR1.REJ_WYR<>'T' |
      ((VEK.TERM='T' | VAR1.ZAK_EK='T') & VAR1.REJ_WYR='T' & VPRODREJ.IL+VPRODREJ.IL_BRAK=0))
   ||
::    Sprawdzam czy pole z partią musi być wypełnione
      _party_req:=exec('party_req','zl_wyk',PROD_REJ.ZL);
      {? _party_req>0
      ||
         {? VPRODREJ.ZPARN=null()
         || _party_zl:=exec('party_first','zl_link',PROD_REJ.ZL);
            _zl_sym:=exec('record','#to_string',_party_zl);
            _msg:='Zlecenie: %1 jest partiowane.\n'
                  'Należy wskazać partię do której zostanie przypisana rejestrowana robocizna.'@[_zl_sym];
            _txt+=gsub(_msg,'\n',' ');
            {? _komm=0
            || FUN.emsg(_msg)
            ?};
            _result:='ZPARN'
         ?}
      ?}
   ?};
:: Kontrola czasu przy zakańczaniu rozpoczętych operacji
   {? _result='' & VAR1.ZAK_EK='T'
   ||
::    moment startu operacji (z dokładnością do sekundy)
      _stm_stamp:=exec('create','#tm_stamp',VPRODREJ.STARTD,VPRODREJ.STARTT);
::    proponowany czas (z dokładnością do minuty)
      _etm_stamp:=exec('create','#tm_stamp',VPRODREJ.ENDD,VPRODREJ.ENDT);

::    punkt końcowy (obecna chwila - wyrównanie do najbliższej minuty z dokładnością do sekundy)
      _max_stamp:=exec('create','#tm_stamp',date(),time((time()+time(0,1,))~1,(time()+time(0,1,))~2,0));
      {? _stm_stamp<=_etm_stamp & _etm_stamp<=_max_stamp
      || 1
      || FUN.emsg(
            'Wprowadzona data jest niepoprawna — powinna być z zakresu:\n'
            'Start: %1 %2\n'
            'Koniec: %3 %4\n\n'
            'Twoja propozycja: %5 %6'@
            [form(VPRODREJ.STARTD),form(VPRODREJ.STARTT,,5),
             form(exec('tm_stamp2date','#tm_stamp',_max_stamp)),form(exec('tm_stamp2time','#tm_stamp',_max_stamp),,5),
             form(VPRODREJ.ENDD),form(VPRODREJ.ENDT,,)
            ]
         );
         _result:='ENDD'
      ?}
   ?};
:: Jeżeli wszystko dobrze, to dodatkowa walidacja za pomocą wtyczki
   {? _result=''
   || _result:=Plugin.run('VPRODREJ_VALID_001','IL')
   ?};
:: Kontrola wypełnienia w całości rozpiski rozliczeń surowców (czy wszystkie pozycje surowców zostały rozpisane)
   {? (type_of(_result)=type_of('') & _result='' | type_of(_result)=type_of(0) & _result=1)
   || {? VEK.TERM<>'T' & VAR1.ZAK_EK<>'T' & exec('chk_fill_rej_mat','zl_wyk')=0
      || {? _komm=0
         || {? ~FUN.ask('Nie zarejestrowano pobrania dla wszystkich surowców.\nKontynuować?'@)
            || _result:=0
            ?}
         ?}
      ?}
   ?};
   {? _komm>0 & type_of(_result)=2 & _result<>''
   || KOMM.add(_txt,5)
   ?};
   _result
";

{? VEK.TERM<>'T' & VAR1.ZAK_EK<>'T'
||
:: Sprawdzam czy pole z partią musi być wypełnione
   _party_req:=exec('party_req','zl_wyk',PROD_REJ.ZL);
   VPRODREJ.efld_opt(VPRODREJ.win_edit('?'),{? _party_req>0 || 'mark=1' || 'mark=0' ?},,'ZPARN')
?};
exec('vprodrej_efld_opt','prod_rej');
'-*-e-kioski-*-';
{? VEK.TERM='T'
|| _res:=exec('setEndVar','ekioski',_valid)
|? VAR1.ZAK_EK='T'
||
:: Zakańczanie rozpoczętych operacji ekioskowych od strony Merit ERP
   {? VAR1.REJ_WYR='T'
   ||
::       Rejestracja wykonań w rozbiciu na wiele wyrobów
      _env_wyr:=exec('env','zl_wyr');
      exec('fill_env','zl_wyr',PROD_REJ.ZGP);
      __valid:=_valid;
      exec('env_efld_opt','zl_wyr');
      {? __ENV_WYR.TAB_P.select()
      || _res:=1
      || _res:=0;
         VAR_DEL.delete('__ENV_REJ','__ENV_BAD','__ENV_WYR')
      ?};
      VAR_DEL.delete('__valid')
   || _win:=exec('vprod_win_ek','zl_wyk');
      VPRODREJ.win_edit(_win);
      __valid:=_valid;
      {? VPRODREJ.edit("
         _res:=__valid();
         {? type_of(_res)=type_of('') & _res='' | type_of(_res)=type_of(0) & _res=1
         || _res:=exec('setEndVar','ekioski',__valid)
         ?};
         _res
      ")
      || _res:=1
      || _res:=0;
         VAR_DEL.delete('__ENV_REJ','__ENV_BAD')
      ?};
      VAR_DEL.delete('__valid')
   ?}
|? VAR1.KN3='N'
||
:: Rejestracja wykonań od strony partii
   _validated:=_valid(1);
   {? (type_of(_validated)=2 & _validated='' | type_of(_validated)=1 & _validated=1)
   || _res:=1
   || _res:=0;
      VAR_DEL.delete('__ENV_REJ','__ENV_BAD')
   ?}
|? VAR1.REJ_WYR='T'
||
:: Rejestracja wykonań w rozbiciu na wiele wyrobów
:: Tworzenie środowiska
   _env_wyr:=exec('env','zl_wyr');
   exec('fill_env','zl_wyr',PROD_REJ.ZGP);
   __valid:=_valid;
   exec('env_efld_opt','zl_wyr');
   {? __ENV_WYR.TAB_P.select()
   || _res:=1
   || _res:=0;
      VAR_DEL.delete('__ENV_REJ','__ENV_BAD','__ENV_WYR')
   ?};
   VAR_DEL.delete('__valid')
||
   _can_fast:=0;
   {? exec('is_fast_wyk','prod_rej') & VPRODREJ.IL_DOREJ>0
   ||
      _val_result:=_valid();

      {? type_of(_val_result)=type_of(0) & _val_result>0
      || _can_fast:=1
      ?};
      {? type_of(_val_result)=type_of('') & _val_result=''
      || _can_fast:=1
      ?}
   ?};
   {? _can_fast>0
   ||
      {? VPRODREJ.ZPARN<>null()
      || _msg:='Czy zarejestrować wykonanie w ilości: %1 dobrych do partii: \'%2\'?'@[$VPRODREJ.IL_DOREJ,exec('record','#to_string',VPRODREJ.ZPARN)]
      || _msg:='Czy zarejestrować wykonanie w ilości: %1 dobrych?'@[$VPRODREJ.IL_DOREJ]
      ?};
      _choice:=FUN.choice(_msg,,'Tak'@,'Popraw...'@);
      {? _choice=1
      || _res:=1
      |? _choice=2
      || _res:=VPRODREJ.edit(_valid)
      || _res:=0
      ?}
   ||
      {? VPRODREJ.edit(_valid)
      || _res:=1
      || _res:=0
      ?}
   ?};
   {? _res=0 || VAR_DEL.delete('__ENV_REJ','__ENV_BAD') ?}
?};
VAR.fld_fml('A_MAG','AFTER_EDIT',"*");
BADO.cntx_pop();
_res


\work_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Okno redagowania dla operacji przewodnika zlecenia warsztatowego
::       Kontekst pracy: rekord ZGP, rekord PROD_REJ, pole VPRODREJ.OK
::   WE: [_a] - wartosc poczatkowa pola VPRODREJ.TIME
::       [_b] - czy redagować czas [1]/0
::   WY: 1 - potwierdzenie, 0 - rezygnacja
::       Wypelniane jest pole VPRODREJ.TIME
::  OLD: \work_edit/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')=type_of(0)
|| _edit_tm:=_b
|| _edit_tm:=1
?};
{? VAR1.ZAK_EK<>'T'
|| VPRODREJ.EDIT_TM:=_edit_tm
?};
VPRODREJ.EDIT_OK:=1;

VPRODREJ.PROD_REJ:=PROD_REJ.ref();
VPRODREJ.OPER:=PROD_REJ.OPER;
VPRODREJ.TIME:={? var_pres('_a')=type_of(0) || _a || 0 ?};
VPRODREJ.OK:='N';
VPRODREJ.PLACE:=PROD_REJ.ZGP().PLACE;

::VPRODREJ.ENDD:=date();
::VPRODREJ.ENDT:=time();

_valid:="
   {? VPRODREJ.EDIT_TM & VPRODREJ.TIME<=0 & ~((VEK.TERM='T' | VAR1.ZAK_EK='T') & exec('get','#params',500644)='T')
   || FUN.info('Należy wpisać czas większy od zera.'@); 0
   |? VPRODREJ.PLACE=null()
   || FUN.info('Należy wskazać stanowisko, na którym została wykonana operacja.'@);
      _result:='PLACE'
   || 1
   ?}
";
'-*-e-kioski-*-';
{? VEK.TERM='T' | VAR1.ZAK_EK='T'
|| _valid:="
      _dalej:=1;
      _res:='';
      {? VAR1.ZAK_EK='T'
      ||
::        Zakańczanie rozpoczętych operacji ekioskowych od strony Merit ERP
          _czas:=VPRODREJ.TIME;
          _place:=VPRODREJ.PLACE
      ||
         _czas:=#gsub(exec('get_value','#desktop','','ctr_menu_end','29a0732gg67e9a9blmknejfca2n3e'),',','.');
         _place_kod:=exec('get_value','#desktop','#:ctr_menu_end','ctr_menu_end','combo_stanowisko@menu_end');
         {? _place_kod=''
         || _place:=null()
         || _place:=exec('FindInSet','#table','TWRKPLC','KOD',_place_kod,,\"TWRKPLC.ref()\",1,,null())
         ?}
      ?};
::    Kontrola casu przy zakańczaniu rozpoczętych operacji
      {? _dalej & VAR1.ZAK_EK='T'
      ||
::       moment startu operacji (z dokładnością do sekundy)
         _stm_stamp:=exec('create','#tm_stamp',VPRODREJ.STARTD,VPRODREJ.STARTT);
::       proponowany czas (z dokładnością do minuty)
         _etm_stamp:=exec('create','#tm_stamp',VPRODREJ.ENDD,VPRODREJ.ENDT);
::       punkt końcowy (obecna chwila - wyrównanie do najbliższej minuty z dokładnością do sekundy)
         _max_stamp:=exec('create','#tm_stamp',date(),time((time()+time(0,1,))~1,(time()+time(0,1,))~2,0));
         {? _stm_stamp<=_etm_stamp & _etm_stamp<=_max_stamp
         || 1
         || FUN.emsg(
               'Wprowadzona data jest niepoprawna — powinna być z zakresu:\n'
               'Start: %1 %2\n'
               'Koniec: %3 %4\n\n'
               'Twoja propozycja: %5 %6'@
               [form(VPRODREJ.STARTD),form(VPRODREJ.STARTT,,5),
                form(exec('tm_stamp2date','#tm_stamp',_max_stamp)),form(exec('tm_stamp2time','#tm_stamp',_max_stamp),,5),
                form(VPRODREJ.ENDD),form(VPRODREJ.ENDT,,)
               ]
            );
            _dalej:=0;
            _res:='ENDD'
         ?}
      ?};
      {? _dalej
      ||
         {? _czas>0
         ||
            {? _place=null()
            || FUN.info('Należy wskazać stanowisko, na którym została wykonana operacja.'@);
               _dalej:=0;
               _res:='PLACE'
            ||
               _dalej:=1;
               VPRODREJ.TIME:=_czas;
               VPRODREJ.PLACE:=_place;
               {? FUN.ask('Czy zakończyć wykonywanie operacji?'@)
               || VPRODREJ.OK:='T'
               ?}
            ?}
         || {? exec('get','#params',500644)='T'
            || _choice:=FUN.choice('Czy chcesz zarejestrować operację?'@,,'Tak'@,'Tak i zakończyć'@);
               {? _choice=1
               || _dalej:=1
               |? _choice=2
               || _dalej:=1;
                  VPRODREJ.OK:='T'
               || _dalej:=0;
                  _res:=0
               ?}
            || FUN.info('Należy wpisać czas większy od zera.'@);
               _dalej:=0;
               _res:='TIME'
            ?};
            {? _dalej & _place=null()
            || FUN.info('Należy wskazać stanowisko, na którym została wykonana operacja.'@);
               _dalej:=0;
               _res:='PLACE'
            || VPRODREJ.PLACE:=_place
            ?};
            {? _dalej & VAR1.ZAK_EK<>'T'
            || {? var_pres('vvar')>100
               || VPRODREJ.ENDD:=vvar.data;
                  VPRODREJ.ENDT:=time(vvar.godz,vvar.mind*10+vvar.minj,0)
               || VPRODREJ.ENDD:=date();
                  VPRODREJ.ENDT:=time()
               ?}
            ?}
         ?}
      ?};
      {? VAR1.ZAK_EK='T'
      || _res
      || _dalej
      ?}
   ";
   {? VAR1.ZAK_EK='T'
   || _win:=exec('vprod_win_ek','zl_wyk',0);
      VPRODREJ.win_edit(_win);
      _dalej:=VPRODREJ.edit(_valid)
   || _dalej:=_valid()
   ?}

|| VPRODREJ.win_edit('ZL_WORK');
   VPRODREJ.efld_opt('ZL_WORK',{? VPRODREJ.EDIT_TM || 'mark=1' || 'mark=0' ?},,'TIME');

:: Sprawdzam czy operacja wymaga przeprowadzenia badań w trakcie wykonywania operacji
   {? VEK.TERM<>'T' & VAR1.ZAK_EK<>'T'
   || _bad_op:=exec('FindAndGet','#table',ZGP,VPRODREJ.PROD_REJ().ZGP,,"ZGP.BAD_OP",null());
      {? _bad_op<>null()
      || VPRODREJ.btn_eopt('ZL_WORK','BADANIE','state=normal');
::       Tworzę środowisko do rejestrowania badań
         _env:=exec('env_bad_op','statexam');
         _env.BADSEH:=_bad_op;
         {? var_pres('_tab')>100 || obj_del(_tab) ?};
         _tab:=_env.TAB;
::       Przepisuje parametry badania
         BADSEP.cntx_psh();
         BADSEP.index('SEHPAR_');
         BADSEP.prefix(_bad_op);
         {? BADSEP.first()
         ||
            {!
            |?
               _tab.blank();
               _tab.PAR:=BADSEP.BADPAR().N;
               _tab.TYP:=BADSEP.BADPAR().TYP;
               _tab.SOURCE:=BADSEP.SOURCE;
               _tab.PARREF:=$BADSEP.BADPAR;
               {? BADSEP.CZY_DEF='T'
               || {? BADSEP.BADPAR().TYP='D' & BADSEP.DEF_CURD='T'
                  ||
::                   Wyznaczenie wartości domyślnej na podstawie bieżącej daty
                     _tab.WAR:=(date()+BADSEP.DEF_DNI)$1
                  || _tab.WAR:=BADSEP.DEF_VAL
                  ?};
                  _tab.VALUE:=exec('getvalfromwar','statexam',_tab.TYP,_tab.WAR)
               ?};
               _tab.add(1);
               BADSEP.next()
            !}
         ?};
         BADSEP.cntx_pop()
      || VPRODREJ.btn_eopt('ZL_WORK','BADANIE','state=grayed')
      ?}
   ?};
   _dalej:=VPRODREJ.edit(_valid)
?};
{? _dalej
|| 1
|| 0
?}


\tpz_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Okno redagowania dla operacji Tpz przewodnika
::       Kontekst pracy: rekord ZGP, rekord PROD_REJ, pole VPRODREJ.OK
::   WE: [_a] - wartosc poczatkowa pola VPRODREJ.TIME
::   WY: 1 - potwierdzenie, 0 - rezygnacja
::       Wypelniane jest pole VPRODREJ.TIME
::  OLD: \tpz_edit/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR1.ZAK_EK<>'T'
|| VPRODREJ.EDIT_TM:=1
?};
VPRODREJ.EDIT_OK:=1;

VPRODREJ.PROD_REJ:=PROD_REJ.ref();
VPRODREJ.OPER:=PROD_REJ.OPER;
VPRODREJ.M:=PROD_REJ.M;
VPRODREJ.DOKL:=PROD_REJ.M().DOKL;
:: Jak rejestracja do partii to czas już ustalony
{? VAR1.KN3<>'N' & VAR1.ZAK_EK<>'T'
|| VPRODREJ.TIME:={? var_pres('_a')=type_of(0) || _a || 0 ?};
   VPRODREJ.OK:='N'
?};
VPRODREJ.AUTO:='N';
VPRODREJ.PLACE:=PROD_REJ.ZGP().PLACE;

_valid:="
:: Czy zbierać informacje do KOMM
   _komm:={? var_pres('_a')=type_of(0) || _a || 0 ?};
   _result:='';
   _txt:={? VAR1.KN3='N'
         || 'Wystąpił błąd podczas walidacji danych. Komunikat błędu: '@
         || ''
         ?};
   {? VPRODREJ.TIME<=0 & ~((VEK.TERM='T' | VAR1.ZAK_EK='T') & exec('get','#params',500644)='T')
   || {? _komm>0
      || _txt+='Należy wpisać czas większy od zera.'@
      || FUN.info('Należy wpisać czas większy od zera.'@)
      ?};
      _result:='TIME'
   |? VPRODREJ.PLACE=null()
   || {? _komm>0
      || _txt+='Należy wskazać stanowisko, na którym została wykonana operacja.'@
      || FUN.info('Należy wskazać stanowisko, na którym została wykonana operacja.'@)
      ?};
      _result:='PLACE'
   ?};

:: Kontrola partii
   {? _result=''
   ||
::    Sprawdzam czy pole z partią musi być wypełnione
      _party_req:=exec('party_req','zl_wyk',PROD_REJ.ZL);
      {? _party_req>0
      ||
         {? VPRODREJ.ZPARN=null()
         || _party_zl:=exec('party_first','zl_link',PROD_REJ.ZL);
            _zl_sym:=exec('record','#to_string',_party_zl);
            _msg:='Zlecenie: %1 jest partiowane.\n'
                  'Należy wskazać partię do której zostanie przypisana rejestrowana robocizna.'@[_zl_sym];
            _txt+=gsub(_msg,'\n',' ');
            {? _komm=0 || FUN.emsg(_msg) ?};
            _result:='ZPARN'
         ?}
      ?}
   ?};
:: Kontrola czasu przy zakańczaniu rozpoczętych operacji
   {? _result='' & VAR1.ZAK_EK='T'
   ||
::    moment startu operacji (z dokładnością do sekundy)
      _stm_stamp:=exec('create','#tm_stamp',VPRODREJ.STARTD,VPRODREJ.STARTT);
::    proponowany czas (z dokładnością do minuty)
      _etm_stamp:=exec('create','#tm_stamp',VPRODREJ.ENDD,VPRODREJ.ENDT);

::    punkt końcowy (obecna chwila - wyrównanie do najbliższej minuty z dokładnością do sekundy)
      _max_stamp:=exec('create','#tm_stamp',date(),time((time()+time(0,1,))~1,(time()+time(0,1,))~2,0));
      {? _stm_stamp<=_etm_stamp & _etm_stamp<=_max_stamp
      || 1
      || FUN.emsg(
            'Wprowadzona data jest niepoprawna — powinna być z zakresu:\n'
            'Start: %1 %2\n'
            'Koniec: %3 %4\n\n'
            'Twoja propozycja: %5 %6'@
            [form(VPRODREJ.STARTD),form(VPRODREJ.STARTT,,5),
             form(exec('tm_stamp2date','#tm_stamp',_max_stamp)),form(exec('tm_stamp2time','#tm_stamp',_max_stamp),,5),
             form(VPRODREJ.ENDD),form(VPRODREJ.ENDT,,)
            ]
         );

         _result:='ENDD'
      ?}

   ?};
:: Jeżeli wszystko dobrze, to dodatkowa walidacja za pomocą wtyczki
   {? _result=''
   || _result:=Plugin.run('VPRODREJ_VALID_001','TPZ')
   ?};
   {? _komm>0 & type_of(_result)=2 & _result<>''
   || KOMM.add(_txt,5)
   ?};
   _result
";

_res:=0;
'-*-e-kioski-*-';
{? VEK.TERM='T'
|| _res:=exec('setEndVar','ekioski',_valid)
|? VAR1.ZAK_EK='T'
||
:: Zakańczanie rozpoczętych operacji ekioskowych od strony Merit ERP
   _win:=exec('vprod_win_ek','zl_wyk',0);
   VPRODREJ.win_edit(_win);
   __valid:=_valid;
   {? VPRODREJ.edit("
      _res:=__valid();
      {? type_of(_res)=type_of('') & _res='' | type_of(_res)=type_of(0) & _res=1
      || _res:=exec('setEndVar','ekioski',__valid)
      ?};
      _res
   ")
   || _res:=1
   || _res:=0
   ?};
   VAR_DEL.delete('__valid');
   _res
|? VAR1.KN3='N'
||
:: Rejestracja wykonań od strony partii
   _validated:=_valid(1);
   {? (type_of(_validated)=2 & _validated='' | type_of(_validated)=1 & _validated=1)
   || _res:=1
   ?}
|| VPRODREJ.win_edit('ZL_TPZ');
   {? VEK.TERM<>'T' & VAR1.ZAK_EK<>'T'
   ||
::    Sprawdzam czy pole z partią musi być wypełnione
      _party_req:=exec('party_req','zl_wyk',PROD_REJ.ZL);
      VPRODREJ.efld_opt(VPRODREJ.win_edit('?'),{? _party_req>0 || 'mark=1' || 'mark=0' ?},,'ZPARN')
   ?};
   _can_fast:=0;
   {? exec('is_fast_wyk','prod_rej') & VPRODREJ.TIME>0
   ||
      _val_result:=_valid();

      {? type_of(_val_result)=type_of(0) & _val_result>0
      || _can_fast:=1
      ?};
      {? type_of(_val_result)=type_of('') & _val_result=''
      || _can_fast:=1
      ?}
   ?};
   {? _can_fast>0
   || {? VPRODREJ.ZPARN<>null()
      || _msg:='Czy zarejestrować wykonanie TPZ w czasie: %1 h do partii: \'%2\'?'@[$VPRODREJ.TIME,exec('record','#to_string',VPRODREJ.ZPARN)]
      || _msg:='Czy zarejestrować wykonanie TPZ w czasie: %1 h?'@[$VPRODREJ.TIME]
      ?};
      _choice:=FUN.choice(_msg,,'Tak'@,'Popraw...'@);
      {? _choice=1
      || VPRODREJ.OK:='T';
         _res:=1
      |? _choice=2
      || _res:=VPRODREJ.edit(_valid)
      || _res:=0
      ?}
   || _res:=VPRODREJ.edit(_valid)
   ?}
?};
_res


\zgp_time_rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Pobiera laczny czas zarejestrowany dla ZGP (suma ZLGD.TIME)
::   WE: _a - ZGP.ref()
::  OLD: \zgp_time_rej/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_zlgd:=sql('
   select sum(ZLGD.TIME) as TIME
   from @ZLGD
   where ZLGD.ZGP=:_a
',_a);

{? _zlgd.first()
|| _zlgd.TIME
|| 0
?}


\bl_a_okr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Blank na pole O tabeli ZLGD
::   WY: OKR.ref()
::  OLD: \bl_a_okr/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
ST.OKR_REF


\bl_zlgd_r
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Wartość początkowa pola ZLGD.R
::  OLD: \bl_zlgd_r/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=null();
R.cntx_psh();
R.index('RUBKOD');
R.prefix(exec('get','#params',500603,1));
{? R.first() || _res:=R.ref() ?};
R.cntx_pop();
_res


\bl_a_wyd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: blank pola WYD w tabeli ZLGD
::  OLD: \bl_a_wyd/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
ST.WYD


\wylicz_zlgd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: wylicza rozne wartosci do rejestracji akordu
::  OLD: \wylicz_zlgd/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_ilosc:=0;
_ilwyk:=0;
_ilbrak:=0;

_timedok:=exec('get','#params',500604,1);

VAR.ZGP_FP:=1;
_zn:=ZLGD.ZGP().TPZ;
ZGP.cntx_psh();
_ref:=ZGP.ref();
{? ZLGD.ZL().NRNZL=0
|| ZGP.index('NRPP')
|| ZGP.index('PNRPP')
?};
ZGP.prefix(ZLGD.ZGH,_zn);
{? ZGP.seek(_ref)
||
:: Wyliczenie ilosci wykonanej do tej pory dla danej pozycji przewodnika
   _ilwyk:=ZGP.IL;
   _ilbrak:=ZGP.IL_BRAK;

:: Sprawdzenie ile zostalo wpisane dla poprz. pozycji przewodnika, podpowiedz ile do wpisania w tej pozycji
   {? exec('get','#params',500631,2)='T'
   || _ilosc:=exec('spr_zgi','zl_wyk',ZGP.ref(),ZLGD.ZGH,ZLGD.ZGP().ILOSC,_ilwyk,ZLGD.ZL,ZLGD.DT,ZLGD.ZMIANA)
   || _ilosc:=ZLGD.ZGP().ILOSC-_ilwyk
   ?};

   {? _ilosc<0
   || _ilosc:=0
   ?};

   Akord.IL_N:=ZLGD.ZGP().ILOSC;
   Akord.NTIME:=ZLGD.ZGP().NTIME;
   Akord.MTIME:=ZLGD.ZGP().MTIME;

   ZGP.cntx_pop();
:: jesli jest to TPZ
   {? ZLGD.ZGP().TPZ='T'
   || ZLGD.IL:=ZLGD.IL_BRAK:=ZLGD.IL_N:=0;
      _wsp:=1
   ||
      {? ZLGD.IL=0
      ||
::         ZLGD.IL:=ZLGD.IL_N:=_ilosc;
::         ZLGD.IL_BRAK:=0
         ~~
      || ZLGD.IL_N:=_ilosc
      ?};
::    tu mamy policzona ilosc
::    teraz normy czasowe i stawki
      _wsp:={? ZLGD.ZGP().ILOSC<>0 || ZLGD.IL_N/ZLGD.ZGP().ILOSC || 1 ?}
   ?};
:: wspolczynnik do podzialu
   {? ZLGD.ZGP().TOPER=null()
   ||
::    jak nie ma TOPER, to wez z ZGP
      ZLGD.PLNX:=(ZLGD.ZGP().PLNX*_wsp)$2;
      ZLGD.PLNH:=ZLGD.ZGP().PLNH; 'było *_wsp';
      ZLGD.NTIME:={? ZLGD.ZGP().NTIME<>0
                  || (ZGP.NTIME*_wsp)$_timedok
                  || (ZGP.MTIME*_wsp)$_timedok
                  ?};
::    stawka z pracownika lub z przewodnika
      {? -menu_txt()<>'popraw'
      || ZLGD.ST:={? ZLGD.ZGP().PO='P' || exec('stawka','zl_wyk',ZLGD.P,ZLGD.DT,'S1') || ZLGD.PLNH ?}
      ?}
   ||
::    kiedy jest TOPER
      _stawka:={? ZLGD.ZGP().PO='P'
               || exec('stawka','zl_wyk',ZLGD.P,ZLGD.DT,'S1')
               |? ZLGD.ZGP().TPZ='T'
               || (ZLGD.ZGP().PLNH/exec('FindAndGet','#table',TOPER,ZLGD.ZGP().TOPER,,"COEF",0))$2
               || exec('FindAndGet','#table',TOPER,ZLGD.ZGP().TOPER,,"(OPER().STAWKA*COEF)$2",0)
               ?};
      _xjm:=exec('FindAndGet','#table',TOPER,ZLGD.ZGP().TOPER,,"exec('FindAndGet','#table',TKTL,NRK,,\"XJM\",0)",0);
      {? ZLGD.ZGP().NTIME<>0
      || ZLGD.NTIME:=(ZLGD.ZGP().NTIME*_wsp)$_timedok
      || ZLGD.NTIME:=(ZLGD.ZGP().MTIME*_wsp)$_timedok
      ?};
      ZLGD.PLNH:=(exec('FindAndGet','#table',TOPER,ZLGD.ZGP().TOPER,,"COEF",0)*_stawka)$2;
      ZLGD.PLNX:=(ZLGD.PLNH*ZLGD.NTIME)$2;
      {? -menu_txt()<>'popraw'
      || ZLGD.ST:=ZLGD.PLNH
      ?}
   ?};
   {? ZLGD.TIME_P=0 || ZLGD.TIME_P:=ZLGD.NTIME ?};
:: Tu nie moze byc win_disp(), bo psuje kontekst przy pracy z zakladkami
::   win_disp();
   ~~
||
   ZGP.cntx_pop()
?};
~~


\zlgb_se1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Selekcja pozycji godzin w rozbiciu na pracownikow - po dolacz
::       Generuje zapis do badan
::       Wypelniamy ZLGB wg aktualnej zawartosci brygady z ZLBS
::       dla znacznika ZLGD.BP=P zaklada pojedynczy rekord w ZLGB i nie robi select.
::       Jezeli wywolane w transakcji albo trigerze, to funkcje dialogowe wylaczone, oraz nie generuje dokumentow.
::  OLD: \zlgb_se1/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh(); ZGP.cntx_psh();
ZL.prefix(); ZGP.prefix();

_timedok:=exec('get','#params',500604,1);

:: Aktualizacja godzin na zleceniach
{? ZLGD.ZGP().TPZ='N'
|| {? ZL.seek(ZLGD.ZL)
   || ZL.HWYK+=ZLGD.TIME_P;
      ZL.put()
   ?};
   {? ZL.NRNZL<>0
   || ZL.cntx_psh();
      ZL.index('UNRZL');
      ZL.prefix(ZL.NRNZL);
      {? ZL.first()
      || ZL.HWYK+=ZLGD.TIME_P;
         ZL.put()
      ?};
      ZL.cntx_pop()
   ?}
?};

_ok:=1;
_suma_il:=0; _suma_br:=0; _sumadil:=0; _sumadbr:=0; _suma_tm:=0; _suma_kw:=0;
_czy_szer:=0;
_czy_oper:=(ZLGD.ZGP().PO='O');
{? ZLGD.BP='B' & ZLGD.B<>null() &
   ((ZLGD.IL=0 & ZLGD.IL_BRAK=0 & ZLGD.DEK_IL=0 & ZLGD.DEK_BR=0)
    | ZLGD.ZGP().TPZ='T'
    | ZLGD.ZL().TYP().WP='W'
    | (exec('get','#params',500600,2)='T')
   )
||
:: Rozliczanie brygadowe - rozliczanie godzinowe operacji brygadowych - parametr 500600='T'
::  albo obsługa zleceń warsztatowych
   ZLGB.clear();
   ZLBS.clear();

   exec('zlbs_f_set','zasoby',ZLGD.B,ZLGD.DT);

   _size:=ZLBS.f_size();
   {? ZLBS.f_first()
   ||
      {!
      |?
         ZLGB.blank();
         ZLGB.P:=ZLBS.P;
         ZLGB.ST:=exec('zlgb_st','zl_wyk',ZLBS.P);
         ZLGB.IL:=ZLGD.IL;
         ZLGB.IL_BRAK:=ZLGD.IL_BRAK;
         ZLGB.DEK_IL:=ZLGD.DEK_IL;
         ZLGB.DEK_BR:=ZLGD.DEK_BR;

         {? ZLGB.TIME=0 || ZLGB.TIME:=(ZLGD.TIME/_size)$_timedok ?};
         ZLGB.TIME_P:=(ZLGD.TIME_P/_size)$_timedok;
         exec('zlgb_kw','zl_wyk');
         ZLGB.add();
         _suma_tm+=ZLGB.TIME; _suma_kw+=ZLGB.KW;
         ZLBS.f_next()
      !};

::    Nie korygujemy tutaj ilosci - robi to trigger exec('update_zgp','zl_guide')
::      {? ZLGB.ZLGD().ZGP().TPZ='N'
::      ||
::         ZGP.IL+=ZLGD.IL;
::         ZGP.IL_BRAK+=ZLGD.IL_BRAK;
::         ZGP.put()
::      ?};
      ZLGD.put()
   || {? do_state()
      || undo('Pusty skład brygady na dzień %1.'@[$ZLGD.DT])
      || FUN.emsg('Pusty skład brygady na dzień %1.'@[$ZLGD.DT])
      ?}
   ?};

   ZLBS.f_clear();

:: Jezeli stawka zadana jest zerowa, to sumujemy kwoty
   {? ZLGD.ST=0
   || ZLGD.KW:=0;
      ZLGB.index('ZLGD');
      ZLGB.prefix(ZLGD.ref());
      {? ZLGB.first()
      || {!
         |? ZLGD.KW+=ZLGB.KW;
            ZLGB.next()
         !};
         ZLGD.put()
      ?}
   ?};

:: ewentualne korekty zaokraglen
   {? _suma_tm<>ZLGD.TIME
   || ZLGB.index('ZLGD');
      ZLGB.prefix(ZLGD.ref());
      {? ZLGB.last()
      || ZLGB.TIME-=_suma_tm-ZLGD.TIME;
         ZLGB.put()
      ?}
   ?};
   {? _suma_kw<>ZLGD.KW
   || ZLGB.index('ZLGD');
      ZLGB.prefix(ZLGD.ref());
      {? ZLGB.last()
      || ZLGB.KW-=_suma_kw-ZLGD.KW;
         ZLGB.put()
      ?}
   ?};

   ZLGB.index('ZLGD');
   ZLGB.prefix(ZLGD.ref());
   ZLGB.win_sel('WERG');
   ZLGB.win_edit('RED');
   {? _czy_szer
   || VAR.SUM_ZLGB:=ZLGD.ST;
      VAR.SUM_GBIL:=ZLGD.IL;
      VAR.SUM_GBIB:=ZLGD.IL_BRAK;
      VAR1.SUM_GDIL:=ZLGD.DEK_IL;
      VAR1.SUM_GDIB:=ZLGD.DEK_BR;
      VAR.SUM_GBTI:=ZLGD.TIME
   || VAR.SUM_ZLGB:=0;
      VAR.SUM_GBTI:=0;
      VAR.SUM_GBIL:=ZLGD.IL;
      VAR.SUM_GBIB:=ZLGD.IL_BRAK;
      VAR1.SUM_GDIL:=ZLGD.DEK_IL;
      VAR1.SUM_GDIB:=ZLGD.DEK_BR;
      {? ZLGB.first()
      || {!
         |?
            VAR.SUM_ZLGB+=ZLGB.KW;
            ZLGB.ZLGD();
            VAR.SUM_GBTI+=ZLGB.TIME;
            ZLGB.next()
         !}
      ?}
   ?};
   raport:=ZLGD.IL;
   rapbrak:=ZLGD.IL_BRAK;

   '-*-e-kioski-*-';
   {? ~do_state() & VEK.TERM<>'T' & VAR1.KN3<>'N' || ZLGB.select() ?}

|? ZLGD.BP='B' & ZLGD.B<>null() & (exec('get','#params',500600,2)='N')
||
:: Rozliczenie brygadowe - rozliczanie ilościowe operacji brygadowych - parametr 500600='N'
   ZLGB.clear();
   ZLBS.clear();

   exec('zlbs_f_set','zasoby',ZLGD.B,ZLGD.DT);

   _size:=ZLBS.f_size();

   {? ZLBS.f_first()
   ||
      {!
      |?
         ZLGB.blank();
         ZLGB.P:=ZLBS.P;
         ZLGB.ST:=exec('zlgb_st','zl_wyk',ZLBS.P);

         {? _suma_il<ZLGD.IL
         ||
            ZLGB.IL:={? _czy_szer
                     || ZLGD.IL
                     || {? ZLGD.ZL().TYP().WP='W'
                        || (ZLGD.IL/_size)$4
                        || (ZLGD.IL/_size)$exec('jaka_dok_m','jm',ZLGD.ZL().KTM)
                        ?}
                     ?}
         ||
            ZLGB.IL:=0
         ?};
         {? _suma_br<ZLGD.IL_BRAK
         ||
            ZLGB.IL_BRAK:={? _czy_szer
                          || ZLGD.IL_BRAK
                          || {? ZLGD.ZL().TYP().WP='W'
                             || (ZLGD.IL/_size)$4
                             || (ZLGD.IL_BRAK/_size)$exec('jaka_dok_m','jm',ZLGD.ZL().KTM)
                             ?}
                          ?}
         ||
            ZLGB.IL_BRAK:=0
         ?};

         {? _sumadil<ZLGD.DEK_IL
         || ZLGB.DEK_IL:={? _czy_szer
                         || ZLGD.DEK_IL
                         || {? ZLGD.ZL().TYP().WP='W'
                            || (ZLGD.DEK_IL/_size)$4
                            || (ZLGD.DEK_IL/_size)$exec('jaka_dok_m','jm',ZLGD.ZL().KTM)
                            ?}
                         ?}
         || ZLGB.DEK_IL:=0
         ?};

         {? _sumadbr<ZLGD.DEK_BR
         || ZLGB.DEK_BR:={? _czy_szer
                         || ZLGD.DEK_BR
                         || {? ZLGD.ZL().TYP().WP='W'
                            || (ZLGD.DEK_BR/_size)$4
                            || (ZLGD.DEK_BR/_size)$exec('jaka_dok_m','jm',ZLGD.ZL().KTM)
                            ?}
                         ?}
         || ZLGB.DEK_BR:=0
         ?};

         _wsp:={? ZLGD.IL+ZLGD.IL_BRAK<>0
               || (ZLGB.IL+ZLGB.IL_BRAK)/(ZLGD.IL+ZLGD.IL_BRAK)
               |? ZLGD.DEK_IL+ZLGD.DEK_BR<>0
               || (ZLGB.DEK_IL+ZLGB.DEK_BR)/(ZLGD.DEK_IL+ZLGD.DEK_BR)
               |? ZLGB.ZLGD().ZGP().TPZ='T'
               || 1/_size
               || 0
               ?};
         {? ZLGB.TIME=0 || ZLGB.TIME:=(ZLGD.TIME*_wsp)$_timedok ?};
         ZLGB.TIME_P:=(ZLGD.TIME_P*_wsp)$_timedok;
         exec('zlgb_kw','zl_wyk');
         ZLGB.add();
         _suma_il+=ZLGB.IL; _suma_br+=ZLGB.IL_BRAK;
         _sumadil+=ZLGB.DEK_IL; _sumadbr+=ZLGB.DEK_BR;
         _suma_tm+=ZLGB.TIME; _suma_kw+=ZLGB.KW;
         ZLBS.f_next()
      !};

::    Nie korygujemy tutaj ilosci - robi to trigger exec('update_zgp','zl_guide')
::      {? ZLGB.ZLGD().ZGP().TPZ='N'
::      ||
::         ZGP.IL+=ZLGD.IL;
::         ZGP.IL_BRAK+=ZLGD.IL_BRAK;
::         ZGP.put()
::      ?};
      ZLGD.put()
   || {? do_state()
      || undo('Pusty skład brygady na dzień %1.'@[$ZLGD.DT])
      || FUN.emsg('Pusty skład brygady na dzień %1.'@[$ZLGD.DT])
      ?}
   ?};

   ZLBS.f_clear();

:: Jezeli stawka zadana jest zerowa, to sumujemy kwoty
   {? ZLGD.ST=0
   || ZLGD.KW:=0;
      ZLGB.index('ZLGD');
      ZLGB.prefix(ZLGD.ref());
      {? ZLGB.first()
      || {!
         |? ZLGD.KW+=ZLGB.KW;
            ZLGB.next()
         !};
         ZLGD.put()
      ?}
   ?};

:: ewentualne korekty zaokraglen
   {? _suma_il<>ZLGD.IL
   || ZLGB.index('ZLGD');
      ZLGB.prefix(ZLGD.ref());
      {? ZLGB.last()
      || ZLGB.IL-=_suma_il-ZLGD.IL;
         ZLGB.put()
      ?}
   ?};
   {? _suma_br<>ZLGD.IL_BRAK
   || ZLGB.index('ZLGD');
      ZLGB.prefix(ZLGD.ref());
      {? ZLGB.last()
      || ZLGB.IL_BRAK-=_suma_br-ZLGD.IL_BRAK;
         ZLGB.put()
      ?}
   ?};
   {? _sumadil<>ZLGD.DEK_IL
   || ZLGB.index('ZLGD');
      ZLGB.prefix(ZLGD.ref());
      {? ZLGB.last()
      || ZLGB.DEK_IL-=_sumadil-ZLGD.DEK_IL;
         ZLGB.put()
      ?}
   ?};
   {? _sumadbr<>ZLGD.DEK_BR
   || ZLGB.index('ZLGD');
      ZLGB.prefix(ZLGD.ref());
      {? ZLGB.last()
      || ZLGB.DEK_BR-=_sumadbr-ZLGD.DEK_BR;
         ZLGB.put()
      ?}
   ?};
   {? _suma_tm<>ZLGD.TIME
   || ZLGB.index('ZLGD');
      ZLGB.prefix(ZLGD.ref());
      {? ZLGB.last()
      || ZLGB.TIME-=_suma_tm-ZLGD.TIME;
         ZLGB.put()
      ?}
   ?};
   {? _suma_kw<>ZLGD.KW
   || ZLGB.index('ZLGD');
      ZLGB.prefix(ZLGD.ref());
      {? ZLGB.last()
      || ZLGB.KW-=_suma_kw-ZLGD.KW;
         ZLGB.put()
      ?}
   ?};

   ZLGB.index('ZLGD');
   ZLGB.prefix(ZLGD.ref());
   ZLGB.win_sel('WER');
   ZLGB.win_edit('RED');
   {? _czy_szer
   || VAR.SUM_ZLGB:=ZLGD.ST;
      VAR.SUM_GBIL:=ZLGD.IL;
      VAR.SUM_GBIB:=ZLGD.IL_BRAK;
      VAR1.SUM_GDIL:=ZLGD.DEK_IL;
      VAR1.SUM_GDIB:=ZLGD.DEK_BR;
      VAR.SUM_GBTI:=ZLGD.TIME
   || VAR.SUM_ZLGB:=0;
      VAR.SUM_GBIL:=0;
      VAR.SUM_GBIB:=0;
      VAR.SUM_GBTI:=0;
      VAR1.SUM_GDIL:=0;
      VAR1.SUM_GDIB:=0;
      {? ZLGB.first()
      || {!
         |?
            VAR.SUM_ZLGB+=ZLGB.KW;
            ZLGB.ZLGD();
            VAR.SUM_GBIL+=ZLGB.IL;
            VAR.SUM_GBIB+=ZLGB.IL_BRAK;
            VAR1.SUM_GDIL+=ZLGB.DEK_IL;
            VAR1.SUM_GDIB+=ZLGB.DEK_BR;
            VAR.SUM_GBTI+=ZLGB.TIME;
            ZLGB.next()
         !}
      ?}
   ?};
   raport:=ZLGD.IL;
   rapbrak:=ZLGD.IL_BRAK;

   '-*-e-kioski-*-';
   {? ~do_state() & VEK.TERM<>'T' & VAR1.KN3<>'N' || ZLGB.select() ?}

||
:: Pojedynczy pracownik
   _pierwszy:=0;
   {? ZLGD.ZGP().TPZ='T'
   ||
::    Operacja Tpz
      ZLGB.clear();
      ZLGB.blank();
      ZLGB.P:=ZLGD.P;
      ZLGB.ST:=exec('zlgb_st','zl_wyk',ZLBS.P);
      ZLGB.TIME:=ZLGD.TIME;
      ZLGB.TIME_P:=ZLGD.TIME_P;
      ZLGB.IL:=0;
      ZLGB.IL_BRAK:=0;
      ZLGB.DEK_IL:=0;
      ZLGB.DEK_BR:=0;
      ZLGB.KW:=ZLGD.KW;
      ZLGB.R:=ZLGD.R;
      ZLGB.add()
   ||
::    Operacja
      popr:=0;
      ZLGB.clear();
      ZLGB.blank();
      ZLGB.P:=ZLGD.P;
      ZLGB.ST:=exec('zlgb_st','zl_wyk',ZLBS.P);
      ZLGB.TIME:=ZLGD.TIME;
      ZLGB.TIME_P:=ZLGD.TIME_P;
      ZLGB.IL:=ZLGD.IL;
      ZLGB.IL_BRAK:=ZLGD.IL_BRAK;
      ZLGB.DEK_IL:=ZLGD.DEK_IL;
      ZLGB.DEK_BR:=ZLGD.DEK_BR;
      ZLGB.KW:=ZLGD.KW;
      ZLGB.R:=ZLGD.R;
      raport:=ZLGD.IL;
      rapbrak:=ZLGD.IL_BRAK;

      ZLGB.add();

::    Nie korygujemy tutaj ilosci - robi to trigger exec('update_zgp','zl_guide')
::      ZGP.IL+=ZLGD.IL;
::      ZGP.IL_BRAK+=ZLGD.IL_BRAK;
::      ZGP.put()
      ~~
   ?}
?};

{? _ok>0
||
   {? ZLGD.ZGP().KJ_BAD='B'
   ||
::    Jeśli włączona kontrola jakości przez moduł badań to automatycznie generuję nagłówek badania
::      _opis:='Zlecenie: '+ZLGD.ZGP().ZL().SYM+'\n';
::      _opis+='Przewodnik: '+ZLGD.ZGP().NRZLP().NRPRZ+'\n';
::      _opis+='Operacja: '+$ZLGD.ZGP().NRP+'. '+ZLGD.ZGP().OPIS+'\n';
        _opis:='';

      _badh:=exec('BADH_add_new','statexam', ,ZLGD.ZGP().BADSEH
                                             ,0
                                             ,ZLGD.DEK_IL+ZLGD.DEK_BR
                                             ,ZLGD.ZGP().ZL
                                             ,_opis,ZLGD.ZGP);
      {? _badh<>null()
      || ZLGD.BADH:=_badh;
         BADH.cntx_psh();
         ZLGD.BADH();
         BADH.ZLGD:=ZLGD.ref;
         BADH.put;
         BADH.cntx_pop();

         _ok:=ZLGD.put()
      ?}
   ?}
?};

:: Aktualizacja ilości wykonanej na przewodnikach i zleceniach
::_ilosc:=exec('ilegen','magdok_prod').ilegen;
::exec('nawzl','zl_wyk',_ilosc,0);
exec('oblicz_zgh_1zl','zl_wyk',ZLGD.ZL);

ZLGB.clear();
KAL_ROK.clear();
ZLBS.clear();
ZL.cntx_pop(); ZGP.cntx_pop();
~~


\zlgd_kw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Wylicza pole ZLGD.KW
::  OLD: \zlgd_kw/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('get','#params',500605,2)='P'
|| ZLGD.KW:=ZLGD.TIME_P*ZLGD.ST $2
|| ZLGD.KW:=ZLGD.TIME*ZLGD.ST $2
?}


\po_zg_is
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Kontrole poprawnosci wypelnienia po rekacji pola ilosc i stawka
::       Po redakcji pol ZLGD.IL, ZLGD.IL_BRAK, ZLGD.ST, VAR1.IL, VAR1.IL_BRAK, i w formule exec('add_akord','zl_wyk')
::       Jezeli wywolana w transakcji (np. w triggerze) to wylaczone dialogi
::   WE: [_a] - STRING - ['after_edit']    - formula wykonywana w kontekscie: po redakcji pola
::                        'jakis_kontekst' - formula wywolana w innym kontekscie
::   WY: 0 / 1
::  OLD: \po_zg_is/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_context:='after_edit';
{? var_pres('_a')=type_of('')
|| _context:=_a
?};
_kj_bad:=ZLGD.ZGP().KJ_BAD;
_fixed_norm:=ZGP.FIX_NORM;
{? _kj_bad='N' | ZLGD.KJ_DONE='T'
|| ZLGD.IL:=VAR1.IL;
   ZLGD.IL_BRAK:=VAR1.IL_BRAK
|| ZLGD.DEK_IL:=VAR1.IL;
   ZLGD.DEK_BR:=VAR1.IL_BRAK
?};
_timedok:=exec('get','#params',500604,1);

_do_state:=do_state();
_dziel:=exec('jaka_dok_m','jm',ZLGD.ZL().KTM);
_wynik1:=exec('poil','zl_wyk',{? _dziel=0 || 'N' || 'T' ?},'VAR1.IL',_dziel);
_wynik2:=exec('poil','zl_wyk',{? _dziel=0 || 'N' || 'T' ?},'VAR1.IL_BRAK',_dziel);
_wynik3:=exec('zlgd_st_ae','zl_wyk',ZLGD.ST);
_chkak:=exec('get','#params',500631,2);
_chkak1:=exec('get','#params',500634,2);
_wp:=ZLGD.ZL().TYP().WP;
_tpz:=ZLGD.ZGP().TPZ;
_ilnprz:=ZLGD.ZGP().ILOSC;
_il:=exec('il_pop','zl_guide',ZLGD.ZGP);
_il_pop:=_il.IL_POP;
_max:=_il.MAX;
_first_op:=_il.FIRST;

:: Warunki
{? _wynik1 & _wynik2 & _wynik3
||
   {? _wp='P'
   ||
      _wynik:=
         {? VAR1.IL<>0 | VAR1.IL_BRAK<>0 | _tpz='T'
         ||
            {? exec('sprawdz','zl_wyk')
            || {? _first_op
               ||
                  {? _context<>'after_edit' & _tpz='N' & _chkak1='T'
                     & (_result:=exec('chk_il_pop','zl_wyk'); _result.RES=0)
                  || _txt:=_result.TXT;
                     {? _do_state
                     || undo(_txt)
                     || FUN.emsg(_txt)
                     ?};
                     0
::                  |? _tpz='N' & VAR1.IL<>_ilnprz & _ilnprz<>0
::                  ||
::                     {? ~_do_state
::                     || _msg:='Ilość różna od wynikającej z przewodnika.'@;
::                      Komunikat o różnicy z przewodnikiem
::                        {? ~(_context='after_edit' & cur_afld()='ST') || FUN.info(_msg) ?};
::                        ~~
::                     ?};
::                     1
                  || 1
                  ?}
               || {? _context<>'after_edit' & _tpz='N' & _chkak='T'
                     & (_result:=exec('chk_il_pop','zl_wyk'); _result.RES=0)
                  || _txt:=_result.TXT;
                     {? _do_state
                     || undo(_txt)
                     || FUN.emsg(_txt)
                     ?};
                     0
::                  |? _tpz='N' & VAR1.IL>_ilnprz & _chkak='T'
::                  || {? ~_do_state
::                     || _msg:='Ilość większa od wynikającej z przewodnika.'@;
::                      Komunikat o ilości większej niż na przewodniku
::                        {? ~(_context='after_edit' & cur_afld()='ST') || FUN.info(_msg) ?}
::                     ?};
::                     1
                  || 1
                  ?}
               ?}
            || 0
            ?}
         || {? ~_do_state
            ||
::               FUN.emsg('Proszę wypełnić pole.'@);
               ~~
            ?};
            1
         ?}
   || _wynik:=1
   ?};

   {? _wynik
   ||
      _wsp:={? _fixed_norm='T'
            || 1
            |? Akord.IL_N<>0 & ZLGD.ZGP().TPZ='N'
            || (VAR1.IL+VAR1.IL_BRAK)/Akord.IL_N
            || 1
            ?};
      {? ZLGD.TIME=0
      || {? Akord.NTIME<>0
         || ZLGD.TIME:=(Akord.NTIME*_wsp)$_timedok
         || ZLGD.TIME:=(Akord.MTIME*_wsp)$_timedok
         ?}
      ?};
      {? Akord.NTIME<>0
      || ZLGD.TIME_P:=(Akord.NTIME*_wsp)$_timedok
      || ZLGD.TIME_P:=(Akord.MTIME*_wsp)$_timedok
      ?};
      exec('zlgd_kw','zl_wyk');
      {? VAR1.IL_BRAK<=0
      || VAR1.BRAKI_R:=null();
         exec('var1_braki_r_ae','zl_wyk')
      ?}
   ?}
|| _wynik:=0
?};

exec('zlgd_efld_opt','zl_wyk');

_wynik


\spr_zgi
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Spradza ile zostalo wpisane na pozycji przewodnika.
::   WE: _a - ZGP.ref()
::       _b - ZGH.ref()
::       _c - Ilosc do wykonania na przewodniku
::       _d - Ilosc wykonana na przewodniku
::       _e - ZL.ref()
::       _f - ZLGD.DT
::       _g - ZLGD.ZMIANA
::   WY: Ilosc mozliwa do wpisania (najmniejsza ilosc ze wszystkich mozliwych poprzednikow z uwzglednieniem czasu)
::  OLD: \spr_zgi/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_ilosc:=0;
_wynik:=0;
NASZGP.cntx_psh();
NASZGP.index('UNROP');
NASZGP.prefix(_e,_a,_e);
{? NASZGP.first()
|| {!
   |? _ilosc:=0;
      {? NASZGP.OPER().WEW='N'
      || _ilosc:=exec('spr_zgi','zl_wyk',NASZGP.OPER,_b,_c,_d,_e,_f,_g)
      || VAR.ZGP_FP:=0;
         _ilosc:=exec('zgp_il','zl_wyk',ZGP.ref(),_f,_g);
         {? _ilosc>0
         || _ilosc:=_ilosc-_d;
            {? _ilosc<0
            || {? exec('get','#params',500631,2)='T'
               || _ilosc:=0
               || _ilosc:=_c-_d
               ?}
            ?}
         || _ilosc:=0
         ?}
      ?};
      {? _wynik>_ilosc | _wynik=0
      || _wynik:=_ilosc
      ?};
      NASZGP.next()
   !};
   _ilosc:=_wynik
||
:: Wariant, gdy nie ma poprzednika (pierwsza operacja procesu)
   VAR.ZGP_FP:=1;
   _ilosc:=_c-_d;
   {? _ilosc<0
   || _ilosc:=0
   ?}
?};
NASZGP.cntx_pop();
_ilosc


\zlgb_kw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Wylicza pole ZLGB.KW
::  OLD: \zlgb_kw/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('get','#params',500605,2)='P'
|| ZLGB.KW:=(ZLGB.TIME_P*ZLGB.ST) $2
|| ZLGB.KW:=(ZLGB.TIME*ZLGB.ST) $2
?}


\poil
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Po redakcji ilosci - gdy ilosc nie moze byc ujemna
::   WE: _a - czy podzielnosc (T/N)
::       _b - wartosc do zaokraglenia - formula w postaci STRING, np. 'TAB.POLE'
::       _c - zaokraglenie
::   WY: 0 / 1
::  OLD: \poil/polap.fml
::----------------------------------------------------------------------------------------------------------------------
roundmet(2);
_wynik:=1;
_tab:=($_b)();
_int:=int(_tab);
{? _tab<0
|| FUN.emsg('Ilość nie może być ujemna.'@);
   _tab:=0;
   _wynik:=0
|| {? _a='N' & _int<>_tab
   || FUN.emsg('Jednostka miary nie jest podzielna. Wprowadź liczbę całkowitą.'@);
      _wynik:=0
   || _tab:=_tab $ _c;
      ($(_b+':='+form(_tab,,,'9.')))()
   ?}
?};
_wynik


\zlgd_st_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: 'po redagowaniu ZLGD.ST' w formule exec('po_zg_is','zl_wyk')
::       Dziala w kontekscie tabeli ZLGD
::       Jezeli wywolana w transakcji (np. w triggerze) to wylaczone dialogi
::   WY: 0 / 1
::  OLD: \zlgd_st_ae/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLGD.ST<0
|| {? ~do_state() || FUN.info('Stawka nie może być ujemna.'@) ?};
   0
|| 1
?}


\sprawdz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Sprawdza poprawnosc wpisanej ilosci. Minimalna ilosc jaka mozna wpisac
::       Jezeli wywolana w transakcji (np. w triggerze) to wylaczone dialogi
::       Koentekst wywolania: rekord ZLGD
::   WY: 0/1
::  OLD: \sprawdz/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
:: Ile wykowane na ZGP.IL
_ilw:=0;
:; Ile wykonane w nastepnej operacji
_il_next:=0;
:: Ile bylo poprzednio w polu ZLGD.IL
{? -menu_txt()='popraw' | -menu_txt()='kwalifikuj'
|| ZLGD.cntx_psh();
   ZLGD.get();
   _ilp:=ZLGD.IL;
   ZLGD.cntx_pop()
|| _ilp:=0
?};

ZGP.cntx_psh();
ZGP.prefix();
{? ZGP.seek(ZLGD.ZGP)
|| {? ZGP.NAPRAW='T'
   || _zgp_top:=exec('zgp_top_level','braki',ZGP.ref());
      _ilw:=exec('FindAndGet','#table',ZGP,_zgp_top,,"ZGP.IL",0)+exec('count_wyk4zgp','braki',_zgp_top).ILWYK
   || _ilw:=ZGP.IL
   ?};
   _il_next:=exec('nazgp','zl_wyk',ZLGD.ZGH,ZGP.ref(),ZLGD.ZL);
   ZGP.cntx_pop();
   {? _ilw<>0 & exec('get','#params',500631,2)='T'
   || {? (_il_next<=_ilw-_ilp+ZLGD.IL)
      || 1
      || {? ~do_state() || FUN.info('Minimalna ilość jaką należy podać to: %1'@[form(_il_next-_ilw+_ilp)]) ?};
         0
      ?}
   || 1
   ?}
|| ZGP.cntx_pop();
   0
?}


\nazgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Sprawdza poprawnosc wpisanej ilosci.
::   WE: _a: ZGH.ref
::       _b: ZGP.ref - tylko ten parametr jest uzywany!
::       _c: ZL.ref
::   WY: _wynik - ilosc, jaka mozna wpisac (najwieksza ilosc z operacji nastepnych)
::  OLD: \nazgp/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_wynik:=0;
ZGP.cntx_psh();
ZGP.clear();
{? ZGP.seek(_b)
||
   _next:=exec('tab_zgp_next','zl_guide',_b);
   {? _next.first()
   || {!
      |? {? _next.TPZ='T'
         || ZGP.cntx_psh();
            ZGP.clear();
            {? ZGP.seek(_next.REF,)
            ||
               _next1:=exec('sum_zgp_next','zl_guide',ZGP.ref());
               {? _next1.first()
               || {? (_next1.IL+_next1.IL_BRAK)/_next1.COEF>_wynik || _wynik:=(_next1.IL+_next1.IL_BRAK)/_next1.COEF ?}
               ?};
               obj_del(_next1)
            ?};
            ZGP.cntx_pop()
         || {? (_next.IL+_next.IL_BRAK)/_next.COEF>_wynik || _wynik:=(_next.IL+_next.IL_BRAK)/_next.COEF ?}
         ?};
         _next.next()
      !}
   ?}
?};
_wynik:=_wynik/ZGP.NRPRZ().ILNPRZ*ZGP.NRZLP().ILNPRZ;
ZGP.cntx_pop();
_wynik


\zgp_il
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca ilosc zarejestrowana do pozycji przewodnika w terminie poprzedzajacym lub rownym podanemu
::   WE: _a - ZGP.ref()
::       _b - data
::       _c - zmiana
::  OLD: \zgp_il/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;
_data:=_b;
_zmiana:=_c;

_tab:=sql('
   select sum(ZLGD.IL) as IL
   from @ZLGD
      join ZGP using (ZLGD.ZGP,ZGP.REFERENCE)
   where
      ZLGD.ZGP=:_a and
      (ZLGD.DT<to_date('':_b'') or (ZLGD.DT=to_date('':_b'') and (ZLGD.ZMIANA<='':_c'' or ZLGD.ZMIANA='''')))
',_zgp,$_data,_zmiana);

{? type_of(_tab)=type_of(~~) || exec('err_sql','#sql'); return(0) ?};

{? _tab.first()
|| _tab.IL
|| 0
?}


\zlgd_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2010]
:: OPIS: Zwraca wartość ZLGD.ref()
::  OLD: \zlgd_ref/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
ZLGD.ref()


\bl_zlgb_r
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Wartość początkowa pola ZLGB.R
::  OLD: \bl_zlgb_r/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
ZLGB.ZLGD().R


\bp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Zwraca VAR.BP
::   WY: VAR.BP
::  OLD: \bp/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.BP


\a_dat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Zwraca VAR.A_DAT
::   WY: VAR.A_DAT
::  OLD: \a_dat/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_DAT


\zlgd_zparn_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Blank na pole tabeli ZLGD.ZPARN
::  OLD: \zlgd_zparn_bl/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\zlgd_trig_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Trigger przed add() i przed put() w tabeli ZLGD.
::       Automatycznie wypełnia pola: ZLGD.TM_START i ZLGD.TM_END
::  OLD: \zlgd_trig_b/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.ZLGD='T'
|| return(1)
?};
ZLGD.TM_START:=exec('create','#tm_stamp',ZLGD.STARTD().DATA,ZLGD.STARTT);
ZLGD.TM_END:=exec('create','#tm_stamp',ZLGD.ENDD().DATA,ZLGD.ENDT);
1


\zlgd_trig_add_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Trigger przed add() w tabeli ZLGD
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.ZLGD='T'
|| return(1)
?};
:: Uzupełnienie pól ze znacznikami czasowymi w tabeli ZLGD
exec('zlgd_trig_b','zl_wyk');
1


\zlgd_trig_add_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Trigger po add() w tabeli ZLGD
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.ZLGD='T'
|| return()
?};
:: Aktualizacja pola ZGP.STATUS
exec('update_zgp','zl_guide','add',ZLGD);
:: Aktualizacja pola GROP.ILW
exec('update_grop','zl_grop','add');
:: Aktualizacja pola GROPS.ILW
exec('update_grops','zl_grop','add');
:: Generowanie zapisów do planu operacyjnego
exec('auto_pl_wyk','po_wyk','add');
:: Generowanie zapisów do planu strategicznego
exec('auto_px_wyk','px_wyk','add',ZLGD);
:: Aktualizacja pola BADO.ILP
exec('update_ilp','statexam','add');
::Aktualizacja pola ZL.BRAKI
exec('update_zlgd_braki','zl_common','add');
~~


\zlgd_trig_put_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Trigger przed put() w tabeli ZLGD
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.ZLGD='T'
|| return(1)
?};
:: Uzupełnienie pól ze znacznikami czasowymi w tabeli ZLGD
exec('zlgd_trig_b','zl_wyk');
1


\zlgd_trig_put_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Trigger po put() w tabeli ZGLD
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.ZLGD='T'
|| return()
?};
:: Aktualizacja pola ZGP.STATUS
exec('update_zgp','zl_guide','put',ZLGD);
:: Aktualizacja pola GROP.ILW
exec('update_grop','zl_grop','put');
:: Aktualizacja pola GROPS.ILW
exec('update_grops','zl_grop','put');
:: Generowanie zapisów do planu operacyjnego
exec('auto_pl_wyk','po_wyk','put');
:: Generowanie zapisów do planu strategicznego
exec('auto_px_wyk','px_wyk','put',ZLGD);
:: Aktualizacja pola BADO.ILP
exec('update_ilp','statexam','put');
::Aktualizacja pola ZL.BRAKI
exec('update_zlgd_braki','zl_common','put');
~~


\zlgd_trig_del_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Trigger przed del() w tabeli ZLGD
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.ZLGD='T'
|| return(1)
?};
:: Generowanie zapisów do planu operacyjnego
_ok:=exec('auto_pl_wyk','po_wyk','del');
:: Generowanie zapisów do planu strategicznego
{? _ok || exec('auto_px_wyk','px_wyk','del',ZLGD) ?};
_ok


\zlgd_trig_del_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Trigger po del() w tabeli ZLGD
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.ZLGD='T'
|| return()
?};
:: Aktualizacja pola ZGP.STATUS
::{? _a || exec('update_zgp','zl_guide','del',ZLGD) || ~~ ?};
exec('update_zgp','zl_guide','del',ZLGD);
:: Aktualizacja pola GROP.ILW
exec('update_grop','zl_grop','del');
:: Aktualizacja pola GROPS.ILW
exec('update_grops','zl_grop','del');
:: Aktualizacja pola BADO.ILP
exec('update_ilp','statexam','del');
::Aktualizacja pola ZL.BRAKI
exec('update_zlgd_braki','zl_common','del');
~~


\nawzl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Aktualizuje ilość wykonaną na zleceniach i przewodnikach.
::   WE: _a - ilość na jaką można wystawić RP
::       _b - 0 - exec('get','#params',500114,2)='P'
::            1 - exec('get','#params',500114,2)='R'
::  OLD: \nawzl/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
_ujwyk:={? ZLGD.ZL().NRNZL=0
        || ZGP.NRPRZ().ILWYK
        || ZGP.NRZLP().ILWYK
        ?};
_uj:={? ZLGD.ZL().NRNZL=0
     || ZGP.NRPRZ().ILGEN
     || ZGP.NRZLP().ILGEN
     ?};
{? _b=0
|| exec('akzlzgh','zl_wyk',_a-_ujwyk,_a-_ujwyk)
|| exec('akzlzgh','zl_wyk',_a,_a-_ujwyk)
?};
~~


\akzlzgh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Aktualizuje ilosc wykonana na zleceniach i przewodnikach.
::   WE: _a: Ilosc o jaka bedzie aktualizowana ilosc wykonana na zleceniach.
::       _b: Ilosc o jaka bedzie aktualizowana ilosc wykonana na przewodnikach.
::  OLD: \akzlzgh/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('akt_zl','zl_wyk',ZLGD.ZL,_a);
{? ZLGD.ZL().NRNZL=0
|| _seek:=ZGH.seek(ZGP.NRPRZ)
|| _seek:=ZGH.seek(ZGP.NRZLP)
?};
{? _seek
|| ZGH.ILWYK+=_b;
   ZGH.put()
?};
~~


\akt_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Aktualizuje ilosc wykonana na zleceniach
::   WE: _a - ZL.ref()
::       _b - ilosc, o ktora bedzie zwiekszona ilosc wykonana
::  OLD: \akt_zl/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_a)
|| ZL.ILWYK+=_b;
   ZL.put();
   {? ZL.NRNZL<>0 & ZL.NR=1
   || _nrn:=ZL.NRNZL;
      ZL.cntx_psh();
      ZL.index('UNRZL');
      ZL.prefix(_nrn);
      {? ZL.first()
      || {? ZL.RODZAJ='Z'
         || ZL.ILWYK+=_b;
            ZL.put()
         ?}
      ?};
      ZL.cntx_pop()
   ?}
?};
ZL.cntx_pop();
~~


\pracnaz_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed wyświetleniem pola VAR1.P_NAZ
::  OLD: \pracnaz_bd/karta.fml
::----------------------------------------------------------------------------------------------------------------------
:: Wyłączenie okna ustawionego w obsludze 'przed rekord'
:: W kontekscie okna ZGP.WYBZB nie jest odświeżana zawartosc REF
{? cur_tab(1,1)=ZGP | cur_tab(1,1)=VAR1
|| ZGP.win_edit()
|? cur_tab(1,1)=FILTER
|| fld(cur_tab(1,1).PR_OSOBA().NAZWISKO);
   REF.OSOBA:=cur_tab(1,1).PR_OSOBA
|| fld(cur_tab(1,1).P().OSOBA().NAZWISKO);
   REF.P:=cur_tab(1,1).P;
   REF.OSOBA:=cur_tab(1,1).P().OSOBA
?};
1


\pracnaz_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed redakcja pola VAR1.P_NAZ
::  OLD: \pracnaz_be/karta.fml
::----------------------------------------------------------------------------------------------------------------------
{? cur_tab(1,1)=ZLGD
|| {? exec('p_red_zp','zl_wyk')=0 || return(0) ?}
?};

{? cur_tab(1,1)=KAP & VAR.ZAKLADKI*'R'>0
|| {? KAP.ZGP().BRYG='T' || return(0) ?}
?};

:: Jeżeli poprzednio wybrany i wartość pola pasuje, to szukam konkretnego pracownika
{? REF.P<>null() & REF.P().OSOBA().NAZWISKO=fld()
|| P.prefix();
   P.seek(REF.P)
?};
1


\pracnaz_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Obsługa na F3 dla pola VAR1.P_NAZ
::  OLD: \pracnaz_f3/karta.fml
::----------------------------------------------------------------------------------------------------------------------
_fld:=fld();

:: W kontekście okna ZGP.WYBZB brana poprzednia zawartość REF
{? cur_tab(1,1)=ZGP | cur_tab(1,1)=VAR1
|| _ref:=REF.P
|? cur_tab(1,1)=FILTER
|| _ref:=cur_tab(1,1).PR_P
|| _ref:=cur_tab(1,1).P
?};

_p8771:=exec('get','#params',8771,2,OPERATOR.USER);

_view:=1+_p8771;
_jorg:=_p8771+1;

{? _ret:=exec('wybierz_pracownika','tte',0,_view,_jorg);
   {? _ret.STATUS=''
   || {? _ret.P.first() || _res:=exec('FindAndGet','#table',P,_ret.P.UID,,"ref()",null()) || _res:=null() ?}
   || FUN.emsg(_ret.STATUS);
      _res:=null()
   ?};
   _res<>null()

|| REF.P:=_res;
   REF.OSOBA:=REF.P().OSOBA;
   {? cur_tab(1,1)=ZGP | cur_tab(1,1)=VAR1
   || ~~
   |? cur_tab(1,1)=FILTER
   || cur_tab(1,1).PR_P:=REF.P;
      cur_tab(1,1).PR_OSOBA:=REF.P().OSOBA
   || cur_tab(1,1).P:=REF.P
   ?};
   fld(REF.OSOBA().NAZWISKO);
   win_disp()

|| {? cur_tab(1,1)=ZGP | cur_tab(1,1)=VAR1
   || {? REF.P=null()
      || OSOBA.blank(1)
      ?}
   |? cur_tab(1,1)=FILTER
   || cur_tab(1,1).PR_P:=_ref;
      cur_tab(1,1).PR_OSOBA:=cur_tab(1,1).PR_P().OSOBA
   || cur_tab(1,1).P:=_ref;
      cur_tab(1,1).P()
   ?};
   fld(_fld)

?};
fld()


\pracnaz_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Po redakcji pola VAR1.P_NAZ
::  OLD: \pracnaz_ae/karta.fml
::----------------------------------------------------------------------------------------------------------------------
{? fld()=''
||
   {? cur_tab(1,1)=ZGP | cur_tab(1,1)=VAR1
   || OSOBA.blank(1)
   |? cur_tab(1,1)=FILTER
   || cur_tab(1,1).PR_P:=null();
      cur_tab(1,1).PR_OSOBA:=null()
   || cur_tab(1,1).P:=null()
   ?};
   REF.P:=null();
   REF.OSOBA:=null();
   _res:=1

|? REF.P<>null() & REF.P().OSOBA().NAZWISKO=fld()
||
   _res:=1

|? UD_FIR.cntx_psh();
   UD_FIR.index('UD_SKL');
   UD_FIR.prefix(REF.FIRMA);
   {? UD_FIR.first()
   || _ud_skl:=UD_FIR.UD_SKL
   || _ud_skl:=null()
   ?};
   UD_FIR.cntx_pop();
   _ud_def:=exec('szukaj_ud_def','schemat',
      exec('domyslny','schemat','PODZORG'),
      _ud_skl
   ).REF;
   exec('filtruj_p','schemat','TTE',_ud_def,'','T','W');
   P.f_find(fld())
||
   {? cur_tab(1,1)=ZGP | cur_tab(1,1)=VAR1
   || P.OSOBA();
      fld(OSOBA.NAZWISKO)
   |? cur_tab(1,1)=FILTER
   || cur_tab(1,1).PR_P:=P.ref()
   || cur_tab(1,1).P:=P.ref()
   ?};
   REF.P:=P.ref(); REF.P();
   REF.OSOBA:=P.OSOBA; REF.OSOBA();
   _res:=1
||
   FUN.emsg('Brak pracownika lub uprawnień do pracownika o wpisanym nazwisku.'@);
   _res:=0
?};

{? _res
|| {? cur_tab(1,1)=ZLGD
   || _res:=exec('_po_prac','zl_wyk','ZLGD')
   |? cur_tab(1,1)=ZLGB
   || _res:=exec('_po_prac','zl_wyk','ZLGB')
   || _res:=1
   ?}
?};
_res


\_zlgdzgh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: po redakcji pola przewodnik na ZLGD - sprawdza, czy pole zlecenie jest puste
::   WY: 0 / 1
::  OLD: \_zlgdzgh/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
{? chk_fld(1)
|| {? ZLGD.ZGH().STAN='T'
   || FUN.info('Przewodnik już został oddany.'@);
      0
   || ZLGD.ZL:=ZLGD.ZGH().ZLEC;
      {? ZLGD.ZL().NRNZL<>0
      || ZMSLAPP.ZL2:=ZLGD.ZL().SYM-3;
         ZMSLAPP.ZL4:=ZLGD.ZL().SYM
      || ZMSLAPP.ZL2:=ZLGD.ZL().SYM
      ?};
      {? ZLGD.ZL().NRNZL<>0
      || VAR.A_NRZLP:=ZGH.ref();
         ZGP.index('PNRPP');
         ZGP.prefix(ZGH.ref());
         ZGP.first();
         VAR.A_NRPRZ:=ZGP.NRPRZ
      || VAR.A_NRZLP:=ZGH.ref();
         VAR.A_NRPRZ:=ZGH.ref()
      ?};

::    Zwracam zlecenie na ktorym powstaje produkt
      _prod_zl:={? ZLGD.ZL().RP='T'
                || ZLGD.ZL
                || exec('main_podzlec','zl_link',ZLGD.ZL)
                ?};

::    Sprawdzam czy pole z partią musi być wypełnione
      _party_req:=exec('party_req','zl_wyk',ZLGD.ZL);
      {? _party_req>0
      ||
         _party_zgh:=exec('party_first_zgh','zl_guide',ZLGD.ZGH);
         {? _party_zgh<>null()
         ||
            ZPARN.cntx_psh();
            ZPARN.index('ZGH');
            ZPARN.prefix(_party_zgh);
            {? ZPARN.size()=1
            || {? ZPARN.first()
               || ZLGD.ZPARN:=ZPARN.ref()
               ?}
            ?};
            ZPARN.cntx_pop()
         ?}
      ?};
      1
   ?}
|| FUN.info('Wypełnij pole przewodnika.'@);
   0
?}


\prz_r_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Przed redakcją ZLGD.ZGP
::  OLD: \prz_r_zgp/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('in_prod_rej','prod_rej')
|| 0
|| ZLGD.ZGH<>null()
?}


\po_red_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: po redakcji zgp na ZLGD
::  OLD: \po_red_zgp/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_chkak:=exec('get','#params',500631,2);
_res:=0;

: ustawic brygade
{? ZLGD.ZGP<>null()
|| ZLGD.ZGP();
   exec('prepzch','zl_guide');
   {? ZLGD.ZGP().WEW='T'
   || {? -menu_txt()='dołącz'
      || ZLGD.IL_N:=ZLGD.IL:=ZLGD.IL_BRAK:=ZLGD.DEK_IL:=ZLGD.DEK_BR:=ZLGD.TIME:=ZLGD.TIME_P:=ZLGD.NTIME:=0;
         VAR1.IL:=VAR1.IL_BRAK:=0
      ?};
      _bryg:=ZGP.BRYG;
      {? VAR1.TPZ='T'
      || {? FUN.ask('Operacja z TPZ, czy chcesz zarejestrować przezbrojenie?'@)
         || ZLGD.ZGP:=__ZGPTPZ;
            ZLGD.ZGP()
         ?}
      ?};

      {? ZGP.KJ_BAD='N' || ZLGD.KJ_DONE:='N' || ZLGD.KJ_DONE:='P' ?};

      {? ZGP.NRZLP().KIND='T'
      || FUN.info('Operacja niedostępna do rejestracji — dotyczy przewodnika "technicznego".'@)
      |? ZGP.PROBLEM='T'
      || FUN.info('Operacja niedostępna do rejestracji — zgłoszony problem.'@)
      |? _chkak='T' & (ZGP.STATUS=exec('status_new','zl_guide') | ZGP.STATUS=exec('status_waiting','zl_guide'))
      || FUN.info('Operacja niedostępna do rejestracji — wymagane wykonanie poprzedniej.'@)
      |? _chkak='T' & ZGP.STATUS=exec('status_end','zl_guide')
      || FUN.info('Operacja niedostępna do rejestracji — oznaczona jako zakończona.'@)
      |? ZGP.NTIME<>0 | menu_pth()*'RAR'<>0 | var_pres('ProdRej')>0
      || {? ~(ZGP.STARTD<=ZLGD.DT & ZGP.ENDD>=ZLGD.DT) & ZGP.STARTD<>date(0,0,0) & ZGP.ENDD<>date(0,0,0)
         || FUN.info('Zaplanowany czas produkcji (%1 ÷ %2) jest inny niż data rejestracji.'@[$ZGP.STARTD,$ZGP.ENDD])
         ?};
         {? VAR.BP='P'
         || ZLGD.BP:='P';
            {? ZLGD.ZGP().BRYG='T'
            || FUN.info('Operacja przypisana do tej pozycji\nwykonywana jest przez brygadę.'@);0
            || {? _chkak='T'
               || _ok:=exec('spr_date','zl_wyk',ZLGD.ZL,ZLGD.ZGH,ZLGD.ZGP,ZLGD.DT,ZLGD.ZMIANA);
                  {? _ok=0
                  || FUN.info(
                        'Rejestracja tej pozycji przewodnika\n z datą: %1 dla zmiany %2 nie jest możliwa.\n\n'
                        'Nie będzie zachowana chronologia operacji.'@[form(ZLGD.DT),ZLGD.ZMIANA]
                     )
                  ?};
                  _res:=_ok
               || _res:=1
               ?}
            ?}
         || ZLGD.BP:={? _bryg='T' || 'B' || 'P' ?};
            {? _chkak='T'
            || _ok:=exec('spr_date','zl_wyk',ZLGD.ZL,ZLGD.ZGH,ZLGD.ZGP,ZLGD.DT,ZLGD.ZMIANA);
               {? _ok=0
               || FUN.info(
                        'Rejestracja tej pozycji przewodnika\n z datą: %1 dla zmiany %2 nie jest możliwa.\n\n'
                        'Nie będzie zachowana chronologia operacji.'@[form(ZLGD.DT),ZLGD.ZMIANA]
                  )
               ?};
               _res:=_ok
            || _res:=1
            ?}
         ?}
      || FUN.info('Operacja powiązana jedynie z czasem maszynowym.\nNie jest możliwa rejestracja od strony pracownika.'@)
      ?}
   || FUN.info('Rejestracja akordu może się odbywać tylko dla operacji wewnętrznych.'@)
   ?}
|| FUN.emsg('Proszę wypełnić pole.'@)
?};

{? VAR1.IL=0
||
:  Wyliczenie ilosci wykonanej do tej pory dla danej pozycji przewodnika
   _ilwyk:=ZGP.IL+ZGP.DEK_IL;
   _ilbrak:=ZGP.IL_BRAK+ZGP.DEK_BR;

:  Sprawdzenie ile zostalo wpisane dla poprz. pozycji przewodnika, podpowiedz ile do wpisania w tej pozycji
   {? _chkak='T'
   || _ilosc:=exec('spr_zgi','zl_wyk',ZLGD.ZGP,ZLGD.ZGH,ZLGD.ZGP().ILOSC,_ilwyk,ZLGD.ZL,ZLGD.DT,ZLGD.ZMIANA)
   || _ilosc:=ZLGD.ZGP().ILOSC-_ilwyk
   ?};

   VAR1.IL:=_ilosc;
   ~~
?};

_res


\spr_date
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Sprawdza czy istnieją zarejestrowane wcześniej poprzedniki operacji.
::       wszystkie poprzedniki muszą być poprawnie zarejestrowane.
::   WE: _a: ZL.ref
::       _b: ZGH.ref
::       _c: ZGP.ref
::       _d: data
::       _e: zmiana
::   WY: 0 / 1
::  OLD: \spr_date/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_ok:=0;
_poprawnie:=0;
_zewn:=0;
_dalej:=1;
NASZGP.cntx_psh();
NASZGP.index('UNROP');
NASZGP.prefix(_a,_c,_a);
ZGP.cntx_psh();
{? NASZGP.first()
|| {!
   |?
      {? NASZGP.OPER().WEW='N'
      || _poprawnie:=exec('spr_date','zl_wyk',_a,_b,NASZGP.OPER,_d,_e)
      || {? var_pres('_tab')>0
         || obj_del(_tab)
         ?};
         _tab:=sql('
            select ZLGD.DT from @ZLGD
               join ZL using (ZLGD.ZL,ZL.REFERENCE)
               join ZGH using (ZLGD.ZGH,ZGH.REFERENCE)
               join ZGP using (ZLGD.ZGP,ZGP.REFERENCE)
            where ZL.REFERENCE=:_a and ZGH.REFERENCE=:_b
            and ZGP.REFERENCE=:_c and (ZLGD.DT<to_date('':_d'')
            or (ZLGD.DT=to_date('':_d'') and (ZLGD.ZMIANA<='':_e'' or ZLGD.ZMIANA='''')))
         ',_a,_b,NASZGP.OPER,$_d,_e);
         {? type_of(_tab)=type_of(~~) || exec('err_sql','#sql'); NASZGP.cntx_pop(); ZGP.cntx_pop(); return(0) ?};

         {? _tab.first() || _poprawnie:=1 ?};
::       oznacza brak poprawnie zarejestrowanego akordu
         {? _poprawnie=0 || _dalej:=0 ?}
      ?};
      _dalej & NASZGP.next()
   !}
|| _poprawnie:=1
?};
ZGP.cntx_pop();
NASZGP.cntx_pop();
_poprawnie


\p_red_zb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: przed redakcją pola ZLGD.B
::   WY: 0 / 1
::  OLD: \p_red_zb/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLGD.BP='B'
|| {? ZLGD.ZGP<>null() & ZLGD.ZGP().NTIME<>0
   || {? -menu_txt()='dołącz' || exec('ustkap','zl_wyk') ?};
      {? VAR.EDIT='X'
      || 0
      || 1
      ?}
   || 0
   ?}
|| 0
?}


\ustkap
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Ustawia dane na pozycji akordu wg danych przypisanych do kart pracy
::  OLD: \ustkap/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
KAP.cntx_psh();
KAP.index('ZDP');
KAP.prefix(ZGP.ref(),ZLGD.DT);
{? _size:=KAP.size();
   KAP.first()
|| {? _size=1
   || {? KAP.P<>null()
      || ZLGD.P:=KAP.P;
         ZLGD.P().OSOBA().PIERWSZE
      || ZLGD.B:=KAP.B
      ?};
      ZLGD.IL:=KAP.IL;
      ZLGD.KAP:=KAP.ref();
      win_disp()
   |? _size>1
   || {? ZLGD.ZGP().BRYG='T'
      || KAP.win_sel(exec('win_grp','zl_kap',,1,'SLO_BZ'))
::         KAP.win_sel('SLO_BZ')
      || KAP.win_sel('SLO_Z')
      ?};
      {? KAP.select()
      || {? KAP.P<>null()
         || ZLGD.P:=KAP.P;
            ZLGD.P().OSOBA()
         || ZLGD.B:=KAP.B
         ?};
         ZLGD.IL:=KAP.IL;
         ZLGD.KAP:=KAP.ref();
         win_disp()
      ?}
   ?}
|| KAP.prefix(ZGP.ref());
   _size:=KAP.size();
   KAP.first();
   {? _size=1
   || FUN.emsg(
         'Brak kart pracy na podany dzień dla wybranej pozycji przewodnika.\n'
         'Wpisano dane z dnia %1.'@[$KAP.DT]
      );
      {? KAP.P<>null()
      || ZLGD.P:=KAP.P;
         ZLGD.P().OSOBA()
      || ZLGD.B:=KAP.B
      ?};
      ZLGD.IL:=KAP.IL;
      ZLGD.KAP:=KAP.ref();
      win_disp()
   |? _size>1
   || FUN.emsg(
         'Brak kart pracy na podany dzień dla wybranej pozycji przewodnika.\n'
         'Proszę wybrać kartę z innego dnia.'@
      );
      {? ZLGD.ZGP().BRYG='T'
      || KAP.win_sel(exec('win_grp','zl_kap',,1,'SLO_BZ'))
::         KAP.win_sel('SLO_BZ')
      || KAP.win_sel('SLO_Z')
      ?};
      {? KAP.select()
      ||
         {? KAP.P<>null()
         || ZLGD.P:=KAP.P;
            ZLGD.P().OSOBA()
         || ZLGD.B:=KAP.B
         ?};
         ZLGD.IL:=KAP.IL;
         ZLGD.KAP:=KAP.ref();
         win_disp()
      ?}
   ?}
?};
KAP.cntx_pop();
~~


\chk_bryg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Po redakcji pola ZLGD.B
::   WY: 0 / 1
::  OLD: \chk_bryg/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
OSOBA.blank(1);
{? ZLGD.B<>null()
|| 1
|| FUN.info('Proszę wypełnić pole.'@);
   0
?}


\p_red_zp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: przed redakcją pola ZLGD.P
::   WY: 0 / 1
::  OLD: \p_red_zp/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLGD.BP='P'
|| {? ZLGD.ZGP<>null() & ZLGD.ZGP().NTIME<>0
   || {? -menu_txt()='dołącz' || exec('ustkap','zl_wyk') ?};
      {? VAR.EDIT='X'
      || 0
      || 1
      ?}
   || 0
   ?}
|| 0
?}


\_po_prac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: po redakcji pola pracownik na ZLGD lub ZLGB
::   WE: _a -> ZLGB lub ZLGD lub dowolna tabela z polem P - pracownik
::       _b -> _KAL_NAZW (opcjonalnie, zeby ostrzegać w przypadku niezgodności)
::  OLD: \_po_prac/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_dalej:=0;
{? chk_fld(1)
|| REF.OSOBA();
   {? REF.P().ZA<>'T'
   || _dalej:=FUN.ask('Pracownik %1 %2 niezatrudniony.\n\nWpisać?'@[OSOBA.PIERWSZE,OSOBA.NAZWISKO])
   || _dalej:=1
   ?};
   {? _dalej
   || {? REF.P().F_ZATR().KOD='P' & REF.P().CP().S<>'FIZ'
      || _dalej:=FUN.ask('Pracownik %1 %2 nie jest pracownikiem FIZYCZNYM.\n\nWpisać?'@[OSOBA.PIERWSZE,OSOBA.NAZWISKO])
      |? REF.P().F_ZATR().KOD='Z'
      || _dalej:=FUN.ask('Pracownik %1 %2 jest zleceniobiorcą.\n\nWpisać?'@[OSOBA.PIERWSZE,OSOBA.NAZWISKO])
      |? REF.P().F_ZATR().KOD='I'
      || _dalej:=FUN.ask('Pracownik %1 %2 jest innym pracownikiem.\n\nWpisać?'@[OSOBA.PIERWSZE,OSOBA.NAZWISKO])
      || _dalej:=1
      ?}
   ?};
   {? _dalej & _>1
   || {? ($(_a+'.P().KAL'))()<>_b
      || KAL_NAZW.prefix();
         {? KAL_NAZW.seek(_b)
         || _dalej:=FUN.ask(
               'Pracownik %1 %2\n\n'
               'Wymagany kalendarz: %3\n'
               'Kalendarz pracownika: %4\n\n'
               'Wpisać?'@
               [OSOBA.PIERWSZE,
                OSOBA.NAZWISKO,
                KAL_NAZW.NAZWA,
                {? %(1+P.KAL().NAZWA)=255 || 'wzorzec indywidualny'@ || P.KAL().NAZWA ?}
               ]
            )
         || _dalej:=1
         ?}
      || 1
      ?}
   || _dalej
   ?};
   {? _dalej
   || REF.OSOBA:=OSOBA.ref()
   ?};
   _dalej
|| 1
?}


\zlgd_fld_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Przed wyswietleniem pol w tabeli ZLGD
::  OLD: \zlgd_fld_bd/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
{? _fld='R'
||
   {? ZLGD.BP='P' & ZLGD.P=null()
   || exec('findfnrd','color')
   || 1
   ?}
|? _fld='DT'
||
   {? VAR.AK_DAT & 1+cur_kwin()='e' || exec('findfnrd','color') || 1 ?}
|? _fld='IL_N' | _fld='NTIME' | _fld='PLNH' | _fld='PLNX' | _fld='KW' | _fld='ST' | _fld='KAP' | _fld='TIME_P'
||
   {? 1+cur_kwin()='e' || exec('findfnrd','color') || 1 ?}
||
   ~~
?}


\zlgd_fld_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Przed redagowaniem pol w tabeli ZLGD
::  OLD: \zlgd_fld_be/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:=0;
{? _fld='R'
||
   {? ZLGD.BP='B' | ZLGD.P<>null()
   || _result:=1
   ?}
|? _fld='DT'
||
   _result:=~VAR.AK_DAT
|? _fld='OK'
||
   {? exec('get','#params',500631,2)='T'
   || _result:=exec('po_tpz','zl_wyk',ZLGD.ZGP)=0
   || _result:=1
   ?}
|? _fld='ZPARN'
||
   __VAR1_IL:=VAR1.IL;

:: Sprawdzam czy pole z partią musi być wypełnione
   _party_req:=exec('party_req','zl_wyk',ZLGD.ZL);

:: Zwracam najbliższe zlecenie partiowane
   _prod_zl:=exec('party_first','zl_link',ZLGD.ZL);
   _result:=_party_req;
   {? _result>0
   ||
::    Ustawiam okno słownika w ZPARN
      ZPARN.win_dict('SLO_ZGP');
      ZPARN.actions('SLO_ZGP','W:W');

::    ATR.ZL i ATR.ZGH sluzy do niejawnego prefiksowania slownika partii
      ATR.ZL:=_prod_zl;

      {? _prod_zl=ZLGD.ZL
      ||
::       Jesli zlecenie na ktorym powstaje produkt i zlecenie ktore jest na ZLGD to
::       prefiksuje lepiej partie. Moge to zrobic tylko w tym wypadku, poniewaz sa takie sytuacje
         ATR.ZGH:=ZLGD.ZGH
      || ATR.ZGH:=null()
      ?}
   ?}
|? _fld='PLACE'
|| exec('twrkplc_filter_plugin','zasoby',PROD_REJ.ref());
   _result:=1
|? _fld='BRAKI_R'
|| _result:=exec('var1_braki_r_be','zl_wyk')
||
   ~~
?};
_result


\zlgd_fld_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Po redakcji pola w tabeli ZLGD
::  OLD: \zlgd_fld_ae/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
_afld:=cur_afld();
{? _afld='ZPARN'
|| VAR1.IL:=__VAR1_IL;
   ZLGD.ZGH()
?};
1


\zlgd_fld_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Format wyświetlania pól w tabeli ZLGD
::  OLD: \zlgd_fld_fd/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
''


\zlgd_fld_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Format redagowania pól w tabeli ZLGD
::  OLD: \zlgd_fld_fe/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
''


\zlgb_fld_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Format wyświetlania pól w tabeli ZLGB
::----------------------------------------------------------------------------------------------------------------------
_res:='';
{? cur_afld()='TIME' | cur_afld()='TIME_P'
|| _res:='out_prec='+$exec('get','#params',500604,1)
?};
_res


\zlgb_fld_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Format redagowania pól w tabeli ZLGB
::----------------------------------------------------------------------------------------------------------------------
_res:='';
{? cur_afld()='TIME' | cur_afld()='TIME_P'
|| _res:='in_prec='+$exec('get','#params',500604,1)
?};
_res


\p_red_time
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Przed redakcją ZLGD.TIME
::  OLD: \p_red_time/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=ZLGD.IL<>0
   | VAR1.TPZ='T'
   | ZLGD.ZL().TYP().WP='W'
   | exec('get','#params',500602,2)='T';
{? _res
|| _kj_bad:=ZLGD.ZGP().KJ_BAD;
   {? _kj_bad='N' | ZLGD.KJ_DONE='T'
   || ZLGD.IL:=VAR1.IL;
      ZLGD.IL_BRAK:=VAR1.IL_BRAK
   || ZLGD.DEK_IL:=VAR1.IL;
      ZLGD.DEK_BR:=VAR1.IL_BRAK
   ?}
?};
:: Wyliczenie stawki dla operacji TPZ w oknie formularza szczegółowego
{? ZLGD.ZGP().TPZ='T' & exec('get','#params',500602,2)='T'
|| exec('wylicz_zlgd','zl_wyk')
?};
_res


\po_zg_time
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Po redakcji pola ZLGD.TIME
::  OLD: \po_zg_time/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
{? menu_txt()='Popraw'@ | ZLGD.ZGP().TPZ='T'| ZLGD.ZL().TYP().WP='W'
|| _timedok:=exec('get','#params',500604,1);
   {? ZLGD.TIME$_timedok>0
   || exec('zlgd_kw','zl_wyk');
      1
   || FUN.info('Czas musi być większy od zera i zaokrąglony do %1 miejsc po przecinku.'@[form(_timedok)]);
      0
   ?}
|| 1
?}


\p_red_zi
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: przed redakcją pola ZLGD.IL, ZLGD.IL_BRAK - woła wyliczenie wartości stawki i ilości
::       przed redakcja pola VAR1.IL, VAR1.IL_BRAK - wola wyliczenie wartosci stawki i ilosci
::   WY: 0 / 1
::  OLD: \p_red_zi/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
:: Czy potrzebny jest ponizszy wiersz?
::zlgd:=ZLGD.IL;
exec('wylicz_zlgd','zl_wyk');
(ZLGD.ZGP<>null() & ZLGD.ZGP().TPZ<>'T' & ZLGD.ZL().TYP().WP='P') | ZLGD.GROP<>null()


\p_red_zs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: przed redakcją pola ZLGD.ST
::   WY: 0 / 1
::  OLD: \p_red_zs/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLGD.BP='B' & ZLGD.ZGP().PO='P'
|| 0
|| 0
::   exec('get','#params',500600,2)='T' | ZLGD.IL<>0 | ZLGD.ZGP().TPZ='T' | ZLGD.ZL().TYP().WP='W'
?}


\be_zb_il
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2010]
:: OPIS: Przed redakcją pola ZLGB.IL, ZLGB.IL_BRAK
::   WY: 0 / 1
::  OLD: \be_zb_il/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLGB.ST=0
|| ZLGB.ST:=exec('zlgb_st','zl_wyk',ZLGB.P)
?};
{? cur_afld()='IL' | cur_afld()='IL_BRAK' | cur_afld()='BIL' | cur_afld()='BIL_BRAK'
:: Rejestracja akordu - rozliczania godzinowe operacji brygadowych - parametr 500600='T'
|| {? exec('get','#params',500600,2)='T'
   || {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T' | ZLGD.BADH<>null
      || VAR1.BIL:=ZLGD.IL;
         VAR1.BIL_BRAK:=ZLGD.IL_BRAK
      || VAR1.BIL:=ZLGD.DEK_IL;
         VAR1.BIL_BRAK:=ZLGD.DEK_BR
      ?};
      0
   || (ZLGB.ZLGD().ILGEN=0 & ZLGD.ZGP().TPZ<>'T' & ZGP.NRZLP().ZLEC().TYP().WP<>'W')
   ?}
|| 1
?}


\po_zb_il
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Po redakcji pola ZLGB.IL, ZLGB.IL_BRAK
::       Po redakcji pola VAR1.BIL, VAR1.BIL_BRAK
::   WY: 0 / 1
::  OLD: \po_zb_il/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
{? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T' | (ZLGD.BADH<>null() & ZLGD.BADH().AUTO='N')
|| ZLGB.IL:=VAR1.BIL;
   ZLGB.IL_BRAK:=VAR1.BIL_BRAK
|| ZLGB.DEK_IL:=VAR1.BIL;
   ZLGB.DEK_BR:=VAR1.BIL_BRAK
?};
_timedok:=exec('get','#params',500604,1);

{? {? ZLGB.ZLGD().ZL().TYP().WP='W'
   || ZLGB.IL:=ZLGB.IL$4;
      1
   || exec('poil','zl_wyk',
         {? exec('jaka_dok_m','jm',ZLGB.ZLGD().ZL().KTM)=0 || 'N' || 'T' ?},
         {? 1+_fld='B' || 'VAR1.' || 'ZLGB.' ?}+_fld,
         exec('jaka_dok_m','jm',ZLGB.ZLGD().ZL().KTM)
      )
   ?}
||
   {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T' | (ZLGD.BADH<>null() & ZLGD.BADH().AUTO='N')
   || (_a_il:=ZLGD.IL-((VAR.SUM_GBIL-VAR.ZGB_ILP)+fld()))
   || (_a_il:=ZLGD.DEK_IL-((VAR.SUM_GBIL-VAR.ZGB_ILP)+fld()))
   ?};
   {? _a_il>=0
   ||
      {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T' | (ZLGD.BADH<>null() & ZLGD.BADH().AUTO='N')
      || _wsp:={? ZLGD.IL<>0
               || ZLGB.IL/ZLGD.IL
               |? ZLGB.ZLGD().ZGP().TPZ='T'
               || 1/ZLGB.size()
               || 0
               ?}
      || _wsp:={? ZLGD.DEK_IL<>0
               || ZLGB.DEK_IL/ZLGD.DEK_IL
               |? ZLGB.ZLGD().ZGP().TPZ='T'
               || 1/ZLGB.size()
               || 0
               ?}
      ?};
      {? ZLGB.TIME=0
      || ZLGB.TIME:=(ZLGD.TIME*_wsp)$_timedok
      ?};
      ZLGB.TIME_P:=(ZLGD.TIME_P*_wsp)$_timedok;
      exec('zlgb_kw','zl_wyk');
      ilosc:=VAR.ZGB_ILP;
      1
   || {? fld()+_a_il<0
      ||
::         FUN.info(
::            'Z sumy wprowadzonych ilości wynika, że na tej pozycji należałoby wprowadzić ilość mnieszą od zera.\n'+
::            'Najpierw należy zmodyfikować pozostałe zapisy.'
::         );
         1
      || FUN.info('Ilość wprowadzona nie powinna być większa niż: %1.'@[form((fld()+_a_il))]);
         {? _a_il>0 || fld(fld()+_a_il) ?};
         1
      ?}
   ?}
|| 0
?}


\po_zb_time
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Po redakcji pola ZLGB.TIME
::  OLD: \po_zb_time/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=0;

_timedok:=exec('get','#params',500604,1);

_wp:=ZGP.NRZLP().ZLEC().TYP().WP;

{? (ZLGD.IL<>0 | ZLGD.IL_BRAK<>0 | ZLGD.DEK_IL<>0 | ZLGD.DEK_BR<>0)
   & ((ZLGD.KJ_NEED<>'T' & ZLGB.IL=0) | (ZLGD.KJ_NEED='T' & ZLGB.DEK_IL=0))
   & ZLGB.ZLGD().ZGP().TPZ<>'T'
   & _wp<>'W'
   & exec('get','#params',500600,2)='N'
|| ZLGB.TIME:=ZLGB.TIME_P:=0;
   _res:=1
|? (ZLGB.TIME$_timedok)<0
|| FUN.info('Czas musi być większy od zera i zaokrąglony do %1 miejsc po przecinku.'@[form(_timedok)])
:: Rejestracja akordu - rozliczania godzinowe operacji brygadowych - parametr 500600='T'
|? exec('get','#params',500600,2)='T' | _wp='W'
|| _res:=1
|| {? (_a_ti:=ZLGD.TIME-((VAR.SUM_GBTI-VAR.ZGB_TIM)+fld())); _a_ti>=0
   || exec('zlgb_kw','zl_wyk');
      _res:=1
   || FUN.emsg('Czas wprowadzony nie może być większy niż: %1.'@[form((fld()+_a_ti),,_timedok)]);
      fld(fld()+_a_ti)
   ?}
?};

{? _res || exec('zlgb_kw','zl_wyk') ?};

exec('zlgd_efld_opt','zl_wyk');

_res


\be_zb_st
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2010]
:: OPIS: Przed redakcją pola ZLGB.ST
::   WY: 1
::  OLD: \be_zb_st/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.ZLGB_STA:=ZLGB.ST;
1


\po_zb_is
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: po redakcji stawka na ZLGB
::  OLD: \po_zb_is/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
exec('zlgb_kw','zl_wyk');
_wyn:=0;
:: Rejestracja akordu - rozliczania godzinowe operacji brygadowych - parametr 500600='T'
{? (_a_kw:=ZLGD.KW-((VAR.SUM_ZLGB-VAR.ZLGB_KW)+(fld()*ZLGB.TIME)$2));
   _a_kw>=0 | ZLGD.KW=0 | exec('get','#params',500600,2)='T' | ZGP.NRZLP().ZLEC().TYP().WP='W'
|| _wyn:=1
|| FUN.info('Wyliczona kwota nie powinna być większa niż: %1.'@[form(ZLGB.KW+_a_kw,,2)]);
   fld(fld());
   _wyn:=1
?};
"VAR.SUM_ZLGB:=VAR.SUM_ZLGB+(ZLGB.TIME*ZLGB.ST)-(VAR.ZGB_TIM*VAR.ZLGB_STA)";
_wyn


\po_zlgbblok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Roman Firla [12.30]
:: OPIS: Procedura uruchamiana po redakcji pola ZLGB.BLOK
::   WY: 0 - powrot do redakcji, 1 - zakonczenie redakcji
::  OLD: \po_zlgbblok/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLGB.BLOK='T'
|| {? (menu_pth()+1)='D' || _lr:=1; _ref:=null() || _lr:=2; _ref:=ZLGB.ref() ?};

   {? ZLGB.size() < _lr
   || FUN.info('Nie można zablokować rozliczenia pozycji gdy w rozliczeniu brygady wprowadzono jeden akord.'@);
      0
   |? ZLGB.KW>ZLGD.KW
   || FUN.info(
         'Nie można zablokować rozliczenia pozycji, której wartość jest większa\n'
         'od wartości operacji brygadowej: %1'@[form(ZLGD.KW)]
      );
      0
   |? exec('czynblok','zl_wyk',_ref)
   || FUN.info('W rozliczeniu brygady musi być przynajmniej jeden akord nie zablokowany.'@);
      0
   |? exec('czysumblok','zl_wyk',_ref)+ZLGB.KW > ZLGD.KW
   || FUN.info(
         'W rozliczeniu brygady suma kwoty pozycji zablokowanych nie może być większa\n'
         'od wartości operacji brygadowej: %1'@[form(ZLGD.KW)]
      );
      0
   || 1
   ?}
|| 1
?}


\czynblok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Roman Firla [12.30]
:: OPIS: Procedura sprawdza czy w rozliczeniu brygady występuje przynajmniej jeden nie zablokowany akord (z wyjątkiem
::       aktualnie redagowanego)
::   WE: _a - wskazanie na bieżący akord (ZLGB.ref()) - będzie pomijany
::   WY: 0 - jest przynajmniej jeden nie zablokowany, 1 - wszystkie są zablokowane
::  OLD: \czynblok/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_ok:=1;
ZLGB.cntx_psh();
{? ZLGB.first()
|| {!
   |? {? ZLGB.BLOK<>'T' & (ZLGB.ref()<>_a | _a=null()) || _ok:=0 ?};
      _ok & ZLGB.next()
   !}
?};
ZLGB.cntx_pop();
_ok


\czysumblok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Roman Firla [12.30]
:: OPIS: Procedura określa sumę kwoty zablokowanych akordów
::   WE: _a - wskazanie na bieżący akord (ZLGB.ref()) - będzie pomijany
::   WY: wartość sumy kwoty zablokowanych akordów
::  OLD: \czysumblok/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_sum:=0;
ZLGB.cntx_psh();
{? ZLGB.first()
|| {!
   |? {? ZLGB.BLOK='T' & (ZLGB.ref()<>_a | _a=null()) || _sum+=ZLGB.KW ?};
      ZLGB.next()
   !}
?};
ZLGB.cntx_pop();
_sum


\sprzgbil
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Po oknie ZLGB.WER
::   WY: 0 / 1
::  OLD: \sprzgbil/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
:: Rejestracja akordu - rozliczania godzinowe operacji brygadowych - parametr 500600='T'
_roz_godz:=(exec('get','#params',500600,2)='T');
:: pozostale zmienne
_tpz:=ZLGD.ZGP().TPZ;
_wp:=ZLGD.ZGH().ZLEC().TYP().WP;
_il_0:=(ZLGD.IL=0 & ZLGD.IL_BRAK=0 & ZLGD.DEK_IL=0 & ZLGD.DEK_BR=0);

{? _roz_godz
   & VAR.SUM_ZLGB<>ZLGD.KW
|| {? FUN.ask(
         'Nominalna kwota musi być równa: %1.\n'
         'Czy przeliczyć kwoty wszystkich pracowników do kwoty nominalnej?'@[form(ZLGD.KW)]
      )
   || exec('przel_kw','zl_wyk',ZLGD.ref())
   ?};
   ZLGB.size()=0
|? ~_roz_godz
   & (ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T' | (ZLGD.BADH<>null() & ZLGD.BADH().AUTO='N'))
   & (VAR.SUM_GBIL<>ZLGD.IL | VAR.SUM_GBIB<>ZLGD.IL_BRAK)
|| _dokl:=ZLGD.ZL().KTM().DOKL;
   _jm:=M.J().KOD;
   {? FUN.ask(
         'Suma raportowanej ilości musi być równa:\n\n'
         '• dobre: %1 %2\n'
         '• braki: %3 %2\n\n'
         'Czy przeliczyć ilości proporcjonalnie na pracowników brygady?'@
         [form(ZLGD.IL,10,_dokl,'9,'),_jm,form(ZLGD.IL_BRAK,10,_dokl,'9,')]
      )
   || exec('przel_ilosc','zl_wyk',ZLGD.ref())
   ?};
   0
|? ~_roz_godz
   & ZLGD.ZGP().KJ_BAD<>'N'
   & ZLGD.KJ_DONE<>'T'
   & (ZLGD.BADH=null() | (ZLGD.BADH<>null() & ZLGD.BADH().AUTO<>'N'))
   & (VAR1.SUM_GDIL<>ZLGD.DEK_IL | VAR1.SUM_GDIB<>ZLGD.DEK_BR)
|| _dokl:=ZLGD.ZL().KTM().DOKL;
   _jm:=M.J().KOD;
   {? FUN.ask(
         'Suma raportowanej ilości musi być równa:\n\n'
         '• dobre: %1 %2\n'
         '• braki: %3 %2\n\n'
         'Czy przeliczyć ilości proporcjonalnie na pracowników brygady?'@
         [form(ZLGD.DEK_IL,10,_dokl,'9,'),_jm,form(ZLGD.DEK_BR,10,_dokl,'9,')]
      )
   || exec('przel_ilosc','zl_wyk',ZLGD.ref())
   ?};
   0
|? ~_roz_godz
   & (_tpz='T' | _wp='W' | _il_0)
   & ZLGD.ST<>0
   & VAR.SUM_ZLGB<>ZLGD.KW
|| {? FUN.ask(
         'Nominalna kwota musi być równa: %1.\n'
         'Czy wyrównać zaokrąglenia dla ostatniego pracownika brygady?'@[form(ZLGD.KW)]
      )
   || exec('przel_zaokr','zl_wyk',ZLGD.ref())
   ?};
   ZLGB.size()=0
|? ~_roz_godz
   & (_tpz='T' | _wp='W')
   & VAR.SUM_ZLGB<>ZLGD.KW
|| ZLGD.KW:=VAR.SUM_ZLGB;
   ZLGD.put()
|? ZLGB.size()=0
|| FUN.emsg('Proszę uzupełnić skład brygady.'@);
   0
|| 1
?}


\przel_kw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Roman Firla [12.30]
:: OPIS: Funkcja przeliczajaca kwote i stawke akordu pracownika w godzinach na zleceniu
::   WE: [_a] - wskazanie na pozyje godzin na zleceniach (ZLGD.ref())
::  OLD: \przel_kw/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null()) || _zlgd:=ZLGD.ref() || _zlgd:=_a ?};

{? VAR.SUM_ZLGB=ZLGD.KW
|| FUN.info('Przeliczenie nie jest wymagane.'@)
|| _ster:={? exec('czynblok','zl_wyk',null())
          || FUN.info('W rozliczeniu brygady musi być przynajmniej jeden akord nie zablokowany.'@);
             0
          |? exec('czysumblok','zl_wyk',null()) > ZLGD.KW
          || FUN.info(
                'W rozliczeniu brygady suma kwoty pozycji zablokowanych nie może być większa\n'
                'od wartości operacji brygadowej: %1.'@[form(ZLGD.KW)]
             );
             0
          || 1
          ?};

   {? _ster
   ||
      ZLGB.cntx_psh();
      ZLGB.index('ZLGD');
      ZLGB.prefix(_zlgd);
      {? ZLGB.first()
      ||
         _czasblok:=_kwotablok:=_ilblok:=0;
::    Suma czasu i kwot zablokowanych
         {!
         |? {? ZLGB.BLOK='T'
            ||
               _czasblok+=ZLGB.TIME;
               _kwotablok+=ZLGB.KW;
               _ilblok+=1
            ?};
            ZLGB.next()
         !};
         _do_rozl:=_do_przel:=ZLGD.KW-_kwotablok;
         _kwotanblok:=VAR.SUM_ZLGB-_kwotablok;
         _ilnblok:=ZLGB.size()-_ilblok;

::    Przeliczenie
         ZLGB.first();
         {!
         |? {? ZLGB.BLOK<>'T' & _kwotanblok<>0
::            & _do_przel<>0
            || ZLGB.KW:=(ZLGB.KW/_kwotanblok*_do_przel) $2;
               ZLGB.ST:={? ZLGB.TIME<>0 || (ZLGB.KW/ZLGB.TIME) $2 || 0 ?};
               ZLGB.put();
               _do_rozl-=ZLGB.KW
            |? ZLGB.BLOK<>'T' & _ilnblok<>0
::            & _do_przel<>0
            || ZLGB.KW:=(ZLGD.KW/_ilnblok) $2;
               ZLGB.ST:={? ZLGB.TIME<>0 || (ZLGB.KW/ZLGB.TIME) $2 || 0 ?};
               ZLGB.put();
               _do_rozl-=ZLGB.KW
            ?};
            ZLGB.next()
         !};

::    Upchniecie roznicy
         {? _do_przel>0
         || ZLGB.KW:=(ZLGB.KW+_do_rozl) $2;
            ZLGB.ST:={? ZLGB.TIME<>0 || ZLGB.KW/ZLGB.TIME || 0 ?};
            ZLGB.put()
         ?};

::    Sumujemy ponownie kwoty
         ZLGB.first();
         VAR.SUM_ZLGB:=0;
         {! |? VAR.SUM_ZLGB+=ZLGB.KW; ZLGB.next() !}
      ?};
      ZLGB.cntx_pop();
      {? VAR.SUM_ZLGB=ZLGD.KW
      || FUN.info(
            'Kwoty wszystkich pracowników zostały przeliczone do nominalnej wartości operacji %1.'@
            [form(ZLGD.KW)]
         )
      || FUN.info(
            'Nie powiodło się przeliczenie kwot wszystkich pracowników do nominalnej wartości operacji %1.'@
            [form(ZLGD.KW)]
         )
      ?}
   ?}
?};
~~


\przel_zaokr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Przelicza zapisy brygady tak, aby w ostatnim pracowniku skorygowac zaokraglenia
::   WE: _a - ZLGD.ref()
::  OLD: \przel_zaokr/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_zlgd:=_a;
_suma_tm:=_suma_kw:=0;

Cntx.psh(ZLGD,ZLGB);
Cntx.clr(ZLGD     );

{? ZLGD.seek(_zlgd)
||
   ZLGB.index('ZLGD');
   ZLGB.prefix(_zlgd);

   {? ZLGB.first()
   || {!
      |? _suma_tm+=ZLGB.TIME;
         _suma_kw+=ZLGB.KW;
         ZLGB.next()
      !}
   ?};

   {? _suma_tm<>ZLGD.TIME
   || {? ZLGB.last()
      || ZLGB.TIME-=_suma_tm-ZLGD.TIME;
         ZLGB.put()
      ?}
   ?};

   {? _suma_kw<>ZLGD.KW
   || {? ZLGB.last()
      || ZLGB.KW-=_suma_kw-ZLGD.KW;
         ZLGB.put()
      ?}
   ?}
?};

VAR.SUM_ZLGB:=ZLGD.KW;

Cntx.pop(ZLGD,ZLGB);
~~


\po_zb_po
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: po popraw na ZLGB
::  OLD: \po_zb_po/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.SUM_ZLGB:=0;
VAR.SUM_GBIL:=0;
VAR.SUM_GBIB:=0;
VAR1.SUM_GDIL:=0;
VAR1.SUM_GDIB:=0;
VAR.SUM_GBTI:=0;

ZLGB.cntx_psh();
{? ZLGB.first()
|| {!
   |? VAR.SUM_ZLGB+=ZLGB.KW;
      ZLGB.ZLGD();
::    Rejestracja akordu - rozliczania godzinowe operacji brygadowych - parametr 500600='T'
      {? exec('get','#params',500600,2)='T'
      || VAR.SUM_GBIL:=ZLGD.IL;
         VAR.SUM_GBIB:=ZLGD.IL_BRAK;
         VAR1.SUM_GDIL:=ZLGD.DEK_IL;
         VAR1.SUM_GDIB:=ZLGD.DEK_BR
      || VAR.SUM_GBIL+=ZLGB.IL;
         VAR.SUM_GBIB+=ZLGB.IL_BRAK;
         VAR1.SUM_GDIL+=ZLGB.DEK_IL;
         VAR1.SUM_GDIB+=ZLGB.DEK_BR
      ?};
      VAR.SUM_GBTI+=ZLGB.TIME;
      ZLGB.next()
   !}
?};
ZLGB.cntx_pop();
VAR.ZGB_ILP:=0;
VAR.ZGB_TIM:=0;
VAR.ZLGB_KW:=0;
1


\po_zb_re
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2009]
:: OPIS: na rekord po dla tabeli ZLGB
::   WY: 1 / 'P' (jako wynik zgodny z chk_rec)
::  OLD: \po_zb_re/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_res:='';
_res:=__CHK.record(VAR1,,'P_NAZ');
_popraw:=~-menu_txt()='POPRAW';
{? _res=''
|| {? __CHK.index(ZLGB,_popraw)<>'' || _res:='P_NAZ' ?}
?};
{? _res=''
|| {? exec('po_zlgbblok','zl_wyk')=0
   || _res:='BLOK'
   ?}
?};
_res


\pr_zb_po
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: przed popraw ZLGB
::  OLD: \pr_zb_po/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.ZGB_ILP:={? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T' || ZLGB.IL || ZLGB.DEK_IL ?};
VAR.ZGB_TIM:=ZLGB.TIME;
VAR.ZLGB_KW:=ZLGB.KW;
:: Stawkę przenosi z ZLGD
{? ZLGB.ST=0
|| ZLGB.ST:=exec('zlgb_st','zl_wyk',ZLGB.P)
?};
{? ZLGB.ZLGD().ILGEN<>0
|| FUN.info(
      'Na część lub całość wyrobu został wygenerowany dokument produkcyjny.\n'
      'Modyfikacje nie są możliwe.'@
   );
   0
|| exec('zlgb_efld_opt','zl_wyk');
   1
?}


\pr_zb_us
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2009]
:: OPIS: przed usun na ZLGB
::  OLD: \pr_zb_us/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
1


\po_zb_us
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: po popraw na ZLGB
::  OLD: \po_zb_us/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.SUM_ZLGB:=0;
VAR.SUM_GBIL:=0;
VAR.SUM_GBTI:=0;
ZLGB.cntx_psh();
{? ZLGB.first()
|| {!
   |? VAR.SUM_ZLGB+=ZLGB.KW;
      VAR.SUM_GBIL+=ZLGB.IL;
      VAR.SUM_GBIB+=ZLGB.IL_BRAK;
      VAR.SUM_GBTI+=ZLGB.TIME;
      ZLGB.next()
   !}
?};
ZLGB.cntx_pop();
1


\zlgb_kor
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Umożliwia skorygowanie zapisu w ZLGB
::  OLD: \zlgb_kor/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
_stred:=ZLGB.win_edit('?');
_red:=ZLGB.mk_edit('Korekta zapisu robocizny'@,0,'zlgb_kor');
ZLGB.win_efld(_red,VAR1,'P_NAZ',,,30,,,'Pracownik'@,,,,'F3_button=1');
ZLGB.win_efld(_red,OSOBA,'PIERWSZE',,,33,,1,'Imię'@);
ZLGB.win_efld(_red,OSOBA,'DRUGIE',,,33,,1,' ');
exec('ok_esc','#window',ZLGB,_red);
ZLGB.efld_opt(_red,'mark=1',VAR1,'P_NAZ');
_ref_osoba:=REF.OSOBA;
REF.OSOBA:=OSOBA.ref();
ZLGB.win_edit(_red);
_form:="
   _res:='';
   _res:=__CHK.record2(VAR1,'P_NAZ','Pracownik');
   {? _res=''
   || {? __CHK.index(ZLGB,1)<>'' || _res:='P_NAZ' ?}
   ?};
   _res
";
{? ZLGB.edit(_form)
|| ZLGB.put()
?};
REF.OSOBA:=_ref_osoba;
ZLGB.win_edit(_stred);
~~


\zgp_godz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Wyświetla godziny zarejestrowane do pozycji przewodnika/partii
::       Kontekst pracy: ZGP, ZGH, VAR1.TPZ, __ZGPTPZ, ZPARN
::   WE: _a - sposób pracy: 1 (domyślnie) selekcja, 0 - brak selekcji, TAB - brak selekcji, odświeża przekazana tabele
::       _b - INTEGER - opcja: [0] - godziny zarejestrowane do pozycji przewodnika
::                              1 - godziny zarejestrowane do wybranej partii
::   WY: _res.TAB, _res.WER
::  OLD: \zgp_godz/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=obj_new('TAB','WER','GRP','WERR');

{? var_pres('_a')=type_of(0)
|| _select:=_a
|? var_pres('_a')=type_of(SYSLOG)
|| _select:=0
|| _select:=1
?};
_opcja:={? var_pres('_b')=type_of(0) || _b || 0 ?};

_timedok:=exec('get','#params',500604,1);

exec('var_akord','zl_guide');

{? var_pres('_a')=type_of(SYSLOG)
|| _res.TAB:=_a
|| _res.TAB:=tab_tmp(2,
      'END','STRING[1]','Zakończona'@,
      'DT','DATE','Data'@,
      'PRAC','STRING[51]','Pracownik'@,
      'ILOSC','REAL','Ilość — dobre'@,
      'IL_BRAK','REAL','Ilość — braki'@,
      'ILGEN','REAL','Ilość na dokumentach'@,
      'TIME','REAL','Czas rzeczywisty'@,
      'TIME_P','REAL','Czas kalkulowany'@,
      'TPZ','STRING[1]','Tpz',
      'ZLGB','STRING[16]','$ZLGB.ref()',
      'ZLGD','STRING[16]','$ZLGD.ref()',
      'OK','STRING[1]','Zapis zamykający operację'@,
      'STARTD','DATE','',
      'STARTT','TIME','',
      'ENDD','DATE','',
      'ENDT','TIME','',
      'ZPARN','STRING[16]','$ZPARN.ref()',
      'ZPARNSYM','STRING[25]','Partia'@,
      'F','INTEGER','',
      'ZL_SYM','STRING[20]','Zlecenie'@,
      'ZGP_NRP','STRING[30]','Numer przewodnika'@,
      'ZGP_POZ','INTEGER','Pozycja'@,
      'ZGP_OPIS','STRING[60]','Opis'@,
      'DK','STRING[48]','Pozycja dokumentu magazynowego'@,
      'ZL_WYRGD','STRING[16]','$ZL_WYRGD.ref()',
      'STAT_B','STRING[1]','Status rejestracji braków'@,
      'PLACE','STRING[30]','Stanowisko'@,
      'BRAKI_R','STRING[20]','Rodzaj braku'@
   )
?};
{? _opcja=1
|| _res.TAB.index(_res.TAB.ndx_tmp(,,'ZL_SYM',,,'ZGP_NRP',,,'ZGP_POZ',,,'TPZ',,1,'DT',,))
?};
_res.GRP:=_res.TAB.grp_make({? _opcja=0 || 'Godziny do pozycji przewodnika'@ || 'Rejestracje do partii'@ ?},
                            ,'grp_godz'+$_opcja,,,,,'html_maximized');
_res.WER:=_res.TAB.mk_sel({? _opcja=0 || 'Godziny do pozycji przewodnika'@ || 'Rejestracje do partii'@ ?},,
                          ,'zgp_godz'+$_opcja,,10,,,'U',,,,,'html_maximized');
{? _opcja=1
|| _res.TAB.win_fld(_res.WER,,'ZL_SYM',,,20);
   _res.TAB.win_fld(_res.WER,,'ZGP_NRP',,,20);
   _res.TAB.win_fld(_res.WER,,'ZGP_POZ',,,-6,);
   _res.TAB.win_fld(_res.WER,,'ZGP_OPIS',,,30)
|| _res.TAB.fld_attr('ZL_SYM',2);
   _res.TAB.fld_attr('ZGP_NRP',2);
   _res.TAB.fld_attr('ZGP_POZ',2);
   _res.TAB.fld_attr('ZGP_OPIS',2)
?};
_res.TAB.win_fld(_res.WER,,'DT');
_res.TAB.win_fld(_res.WER,,'PRAC',,,30);
_res.TAB.win_fld(_res.WER,,'ILOSC',,,-15,ST.DOKL_P);
_res.TAB.win_fld(_res.WER,,'IL_BRAK',,,-15,ST.DOKL_P);
_res.TAB.win_fld(_res.WER,,'TPZ',,,-3,,,'Tpz'@,,'Czas przygotowawczo-zakończeniowy (T/N)'@,2,,"'T'","'N'");
_res.TAB.win_fld(_res.WER,,'TIME',,,-15,_timedok);
_res.TAB.win_fld(_res.WER,,'TIME_P',,,-15,_timedok);
_res.TAB.win_fld(_res.WER,,'OK',,,-3,,,,,'Zapis zamykający operację'@,2,,"'T'","'N'");
:: Okno z rozpoczętymi operacjami (z e-kiosku)
_res.WERR:=_res.TAB.mk_sel('Rozpoczęte operacje'@ ,,,'zgp_rozp'+$_opcja,,10,,,'U');
_res.TAB.win_fld(_res.WERR,,'STARTD',,,,,,'Data'@);
_res.TAB.win_fld(_res.WERR,,'STARTT',,,,,,'Godzina'@);
_res.TAB.win_fld(_res.WERR,,'PRAC',,,40,,,'Pracownik/brygada'@);
_res.TAB.win_fld(_res.WERR,,'TPZ',,,-3,,,'Tpz'@,,'Czas przygotowawczo-zakończeniowy (T/N)'@,2,,"'T'","'N'");

_fb:="
   Cntx.psh(ZLGD,ZLGB);
   _tab:=cur_tab(1,1);
   _opcja:={? var_pres('__Opcja')=type_of(0) || __Opcja || 0 ?};
   ZLGD.use(8+_tab.ZLGD);
   ZLGB.use(8+_tab.ZLGB);
   Cntx.clr(ZLGD,ZLGB);
   {? ZLGD.seek(_tab.ZLGD)
   || {? exec('_popraw','zl_wyk')
      ||
         _zlgd_ref:=$ZLGD.ref();
         _chk_wyr:=0;
::       Ponowne załadowanie wartości do tabeli
         _tab.cntx_psh();
         {? _tab.first()
         || {!
            |? {? ZLGD.seek(_tab.ZLGD) &
                  ZLGB.seek(_tab.ZLGB)
               || _put:=1;
::                  _czy_wyr:=exec('zlgd_czy_wyr','zl_wyr',ZLGD.ref());
                  _czy_wyr:=_tab.ZL_WYRGD<>'';
::                Przypadek modyfikacji zapisu robocizny w rozbiciu na wyroby od strony partii
                  {? _opcja=1 & _czy_wyr>0
                  ||
                     ZL_WYRGD.cntx_psh();
                     ZL_WYRGD.use((5+ZL_WYRGD.name())+((8+_tab.ZLGD)+3));
::                   Sprawdzenie, czy do rozpiski nie dodano nowych zapisów (raz dla danago ZLGD)
                     {? _zlgd_ref=$ZLGD.ref() & _chk_wyr=0
                     || _chk_wyr:=1;
                        _ndx:=ZL_WYRGD.ndx_tmp(,,'ZLGD',,,'ZPARN',,);
                        ZL_WYRGD.index(_ndx);
                        ZL_WYRGD.prefix(ZLGD.ref(),ZPARN.ref());
                        {? ZL_WYRGD.first()
                        || _tab.cntx_psh();
                           _tab.clear();
                           {!
                           |?
                              _ref:=_tab.ZL_WYRGD;
                              {? ~_tab.find_tab(,'ZL_WYRGD',,'=',$ZL_WYRGD.ref())
                              ||
::                               Dodano nowy wpis wyrobu do przetwarzanej partii, dodanie wpisu do listy wykonań
                                 _tab.DT:=ZLGD.DT;
                                 _tab.TPZ:=exec('FindAndGet','#table',ZGP,ZLGD.ZGP,,\"ZGP.TPZ\",'N');
                                 _tab.OK:=ZLGD.OK;
                                 _tab.ZLGD:=$ZLGD.ref();
                                 _tab.ZL_WYRGD:=$ZL_WYRGD.ref();
                                 ZL.cntx_psh();ZGP.cntx_psh();ZGH.cntx_psh();
                                 _tab.ZL_SYM:=ZLGD.ZL().SYM;
                                 _tab.ZGP_NRP:=ZLGD.ZGP().NRPRZ().NRPRZ;
                                 _tab.ZGP_POZ:=ZLGD.ZGP().NRP;
                                 _tab.ZGP_OPIS:=ZLGD.ZGP().OPIS;
                                 ZL.cntx_pop();ZGP.cntx_pop();ZGH.cntx_pop();
                                 ZLGB.cntx_psh();
                                 ZLGB.index('ZLGD');
                                 ZLGB.prefix(ZLGD.ref());
                                 {? ZLGB.first()
                                 || {!
                                    |? _tab.PRAC:=ZLGB.P().OSOBA().NAZWISKO+' '+OSOBA.PIERWSZE;
                                       {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T'
                                       || _tab.ILOSC:=ZL_WYRGD.IL;
                                          _tab.IL_BRAK:=ZL_WYRGD.IL_BRAK
                                       || _tab.ILOSC:=ZL_WYRGD.DEK_IL;
                                          _tab.IL_BRAK:=ZL_WYRGD.DEK_BR
                                       ?};
                                       _tab.ILGEN:=ZLGD.ILGEN;
                                       _tab.TIME:=ZLGB.TIME;
                                       _tab.TIME_P:=ZLGB.TIME_P;
                                       _tab.STARTD:=ZLGD.STARTD().DATA;
                                       _tab.STARTT:=ZLGD.STARTT;
                                       _tab.ENDD:=ZLGD.ENDD().DATA;
                                       _tab.ENDT:=ZLGD.ENDT;
                                       _tab.STAT_B:=ZLGD.STAT_B;
                                       _tab.PLACE:=ZLGD.PLACE().KOD;
                                       _tab.END:='T';
                                       _tab.ZLGB:=$ZLGB.ref();
                                       _tab.ZPARN:=$ZL_WYRGD.ZPARN;
                                       _tab.ZPARNSYM:=ZL_WYRGD.ZPARN().SYM;
                                       _tab.add();
                                       ZLGB.next()
                                    !}
                                 ?};
                                 ZLGB.cntx_pop()
                              ?};
                              ZL_WYRGD.next()
                           !};
                           _tab.cntx_pop()
                        ?}
                     ?};
::                   Sprawdzenie, czy dana rozpiska nie została usunięta
                     ZL_WYRGD.clear();
                     {? ~ZL_WYRGD.seek(_tab.ZL_WYRGD)
                     ||
::                       Zapis robocizny w rozbiciu na wyrobu został usunięty, usuwam go również z widoku wykonań
                         _put:=0
                     || _zparn:=$ZL_WYRGD.ZPARN;
                        _zparnsym:=ZL_WYRGD.ZPARN().SYM;
                        {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T'
                        || _ilosc:=ZL_WYRGD.IL;
                           _il_brak:=ZL_WYRGD.IL_BRAK;
                           _braki_r:=ZLGD.BRAKI_R().KOD
                        || _ilosc:=ZL_WYRGD.IL;
                           _il_brak:=ZL_WYRGD.DEK_BR;
                           _braki_r:=ZLGD.DEK_RBR().KOD
                        ?}
                     ?};
                     ZL_WYRGD.cntx_pop()
                  || _zparn:=$ZLGD.ZPARN;
                     _zparnsym:=ZLGD.ZPARN().SYM;
                     {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T'
                     || _ilosc:=ZLGB.IL;
                        _il_brak:=ZLGB.IL_BRAK;
                        _braki_r:=ZLGD.BRAKI_R().KOD
                     || _ilosc:=ZLGB.DEK_IL;
                        _il_brak:=ZLGB.DEK_BR;
                        _braki_r:=ZLGD.DEK_RBR().KOD
                     ?}
                  ?};
::                Jeżeli w widoku rejestracji od strony partii zmieniono w zapisie robocizny partię to usuwam rekord
::                z tabeli (zapis już nie należy do danej partii)
                  {? _opcja=1 & _put>0 & _tab.ZPARN<>_zparn
                  || _put:=0
                  ?};
                  {? _put>0
                  || _tab.PRAC:=ZLGB.P().OSOBA().NAZWISKO+' '+OSOBA.PIERWSZE;
                     _tab.ILOSC:=_ilosc;
                     _tab.IL_BRAK:=_il_brak;
                     _tab.ILGEN:=ZLGD.ILGEN;
                     _tab.TIME:=ZLGB.TIME;
                     _tab.TIME_P:=ZLGB.TIME_P;
                     _tab.STARTD:=ZLGD.STARTD().DATA;
                     _tab.STARTT:=ZLGD.STARTT;
                     _tab.ENDD:=ZLGD.ENDD().DATA;
                     _tab.ENDT:=ZLGD.ENDT;
                     _tab.END:={? ZLGD.STARTD<>null() & ZLGD.ENDD=null() || 'N' || 'T' ?};
                     _tab.ZPARN:=_zparn;
                     _tab.ZPARNSYM:=_zparnsym;
                     _tab.OK:=ZLGD.OK;
                     _tab.BRAKI_R:=_braki_r;
                     _tab.put();
                     _next:=_tab.next()
                  || _next:=_tab.del(,1)=2
                  ?}
               || _next:=_tab.next()
               ?};
               _next
            !}
         ?};
         _tab.cntx_pop()
      ?}
   ?};
   Cntx.pop(ZLGD,ZLGB)
";
_res.TAB.win_act(_res.WER,,'Formuła','Popraw'@@,,,_fb,,,,,,'P');
task_attach('TTE_WYK_DWZL');
_fb:="
   exec('end_zlgd_ek','zl_wyk')
";
_res.TAB.win_act(_res.WERR,,'Formuła','&Zakończ'@@,,,_fb,,,,,,'Z');
task_attach('TTE_WYK_DWZL');
_fb:="
   _tab:=cur_tab(1,1);
   _zlgd:=_tab.ZLGD;
   Cntx.psh(ZLGD,ZLGB,_tab);
   ZLGD.use(8+_tab.ZLGD);
   {? _tab.ZLGB<>''
   || ZLGB.use(8+_tab.ZLGB)
   || ZLGB.use((5+ZLGB.name())+((8+_tab.ZLGD)+3))
   ?};
   Cntx.clr(ZLGD,ZLGB);
   {? ZLGD.seek(_tab.ZLGD)
   || {? exec('zlgd_usun','zl_wyk')>0
      || {? _tab.first()
         || {!
            |?
               {? _tab.ZLGD=_zlgd || _tab.del() || _tab.next() ?}
            !}
         ?}
      ?}
   ?};
   Cntx.pop(ZLGD,ZLGB,_tab)
";
_res.TAB.win_act(_res.WER,,'Formuła','Usuń'@@,,,_fb,,,,,,'U');
task_attach('TTE_WYK_DWZL');
_res.TAB.win_act(_res.WERR,,'Formuła','Usuń'@@,,,_fb,,,,,,'U');
task_attach('TTE_WYK_DWZL');
_fb:="
   _tab:=cur_tab(1,1);
   _zlgd:=_tab.ZLGD;
   ZLGD.cntx_psh();
   ZLGB.cntx_psh();
   ZLGD.use(8+_tab.ZLGD);
   ZLGB.use(8+_tab.ZLGB);
   ZLGD.prefix();
   {? ZLGD.seek(_tab.ZLGD)
   || exec('zlgd_kordt','zl_wyk')
   ?};
   ZLGD.cntx_pop();
   ZLGB.cntx_pop();
   ~~
";
_res.TAB.win_act(_res.WER,,'Formuła','Ko&ryguj'@@,,,_fb,,,,,,'R');
task_attach('TTE_WYK_DWZL');
_res.TAB.win_act(_res.WER,,'Menu','Fu&nkcje'@@,,,,,,,,,'N');
_res.TAB.win_act(_res.WERR,,'Menu','Fu&nkcje'@@,,,,,,,,,'N');

_res.TAB.win_act(_res.WER,,'Formuła','-- Q','#N',,,,,,,,'Ź');

_fb:="
   _zlgd:=cur_tab(1,1).ZLGD;
   Cntx.psh(ZLGD,ZL_WYRGD);
   ZLGD.use(8+_zlgd);
   _mask:=(8+_zlgd)+3;
   ZL_WYRGD.use(5+ZL_WYRGD.name()+_mask);
   Cntx.clr(ZLGD,ZL_WYRGD);
   {? ZLGD.seek(_zlgd)
   || ZL_WYRGD.win_sel('WER');
      ZL_WYRGD.index('ZLGD');
      ZL_WYRGD.prefix(ZLGD.ref());
      ZL_WYRGD.select(,,,'DPU:D')
   ?};
   Cntx.pop(ZLGD,ZL_WYRGD)
";
_res.TAB.win_act(_res.WER,,'Formuła','Rozpisanie pr&oduktów'@@,'#N',,_fb,,,,,,'O');

_fb:="
   _tab:=cur_tab(1,1);
   _zlgd:=exec('FindAndGet','#table',ZLGD,_tab.ZLGD,,\"ZLGD.ref()\",null());
   _zl:=exec('FindAndGet','#table',ZLGD,_tab.ZLGD,,\"ZLGD.ZL\",null());
::   VAR.fld_fml('REAL','DISPLAY_FORMAT',\"'out_prec='+$ST.DOKL\");
   ZLGD.cntx_psh();
   _mask:=ref_name(_zlgd);
   {? ZLGD.name()<>_mask || ZLGD.use(_mask) ?};
   ZLGD.prefix();
   {? ZLGD.seek(_zlgd)
   || exec('rozpirez','rezerwacje',,2)
   ?};
   ZLGD.cntx_pop()
";
_res.TAB.win_act(_res.WER,,'Formuła','Pobrania &surowców'@@,'#N',,_fb,,,,,,'S');
task_attach('TTE_WYK_DGRW');
_res.TAB.win_act(_res.WERR,,'Formuła','Pobrania &surowców'@@,'#N',,_fb,,,,,,'S');
task_attach('TTE_WYK_DGRW');

_fb:="
   _tab:=cur_tab(1,1);
   _zlgd:=exec('FindAndGet','#table',ZLGD,_tab.ZLGD,,\"ZLGD.ref\",null);
   BADH.cntx_psh();
   BADH.index('TZLGD');
   BADH.prefix('C',_zlgd,ref_name(_zlgd));
   {? BADH.first()
   || _badh:=BADVAR.BADH;
      BADVAR.BADH:=BADH.ref();
      BADP.cntx_psh();
      BADP.index('BADHBPAR');
      BADP.prefix(BADH.ref());
      BADP.first();
      BADP.win_sel('WER_B_OP');
      _zak:=exec('FindAndGet','#table',ZLGD,_zlgd,,\"ZLGD.ZAK\",'N');
      {? _zak<>'T'
      || BADP.actions('WER_B_OP','WA')
      || BADP.actions('WER_B_OP','')
      ?};

      BADP.select();
      BADVAR.BADH:=_badh;
      BADP.cntx_pop()
   || FUN.info('Brak zarejestrownaych badań dla danego zapisu robocizny.'@)
   ?};
   BADH.cntx_pop()
";
_res.TAB.win_act(_res.WER,,'Formuła','Powiązane &badanie'@@,'#N',,_fb,,,,,,'B');
_res.TAB.win_act(_res.WERR,,'Formuła','Powiązane &badanie'@@,'#N',,_fb,,,,,,'B');

_fb:="
   _tab:=cur_tab(1,1);
   _zlgd:=_tab.ZLGD;
   ZLGD.cntx_psh();
   ZLGD.use(8+_tab.ZLGD);
   ZLGD.prefix();
   {? ZLGD.seek(_tab.ZLGD)
   || exec('zlnd_sel','magdok_prod')
   ?};
   ZLGD.cntx_pop()
";
_res.TAB.win_act(_res.WER,,'Formuła','&Dokumenty magazynowe'@@,'#N',,_fb,,,,,,'D');
_fb:="
   ZLGD.cntx_psh();
   ZLGD.use(8+cur_tab(1,1).ZLGD);
   ZLGD.prefix();
   {? ZLGD.seek(cur_tab(1,1).ZLGD)
   || exec('zmiany','#syslog',ZLGD)
   ?};
   ZLGD.cntx_pop()
";
_res.TAB.win_act(_res.WER,,'Formuła','-- X','#N',,,,,,,,'Ą');
_res.TAB.win_act(_res.WER,,'Formuła','Zmiany — &wykonanie'@@,'#N',,_fb,,,,,,'W');
_fb:="
   ZLGB.cntx_psh();
   ZLGB.use(8+cur_tab(1,1).ZLGB);
   ZLGB.prefix();
   {? ZLGB.seek(cur_tab(1,1).ZLGB)
   || exec('zmiany','#syslog',ZLGB)
   ?};
   ZLGB.cntx_pop()
";
_res.TAB.win_act(_res.WER,,'Formuła','Zmiany — &godziny'@@,'#N',,_fb,,,,,,'G');
_fb:="
   Cntx.psh(ZLGD,ZLGB,KAP);
   ZLGD.use(8+cur_tab(1,1).ZLGD);
   _mask:=(8+cur_tab(1,1).ZLGD)+3;
   {? cur_tab(1,1).ZLGB<>''
   || ZLGB.use(8+cur_tab(1,1).ZLGB)
   || ZLGB.use((5+ZLGB.name())+_mask)
   ?};
   KAP.use('kap__'+_mask);
   Cntx.clr(ZLGD,ZLGB,KAP);
   {? cur_tab(1,1).ZLGB<>'' & ZLGB.seek(cur_tab(1,1).ZLGB)
   || exec('wyswietl','zl_wyk')
   || {? ZLGD.seek(cur_tab(1,1).ZLGD)
      || ZLGD.win_edit('RED');
         {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T'
         || VAR1.IL:=ZLGD.IL;
            VAR1.IL_BRAK:=ZLGD.IL_BRAK;
            VAR1.BRAKI_R:=ZLGD.BRAKI_R
         || VAR1.IL:=ZLGD.DEK_IL;
            VAR1.IL_BRAK:=ZLGD.DEK_BR;
            VAR1.BRAKI_R:=ZLGD.DEK_RBR
         ?};
         ZLGD.display()
      ?}
   ?};
   Cntx.pop(ZLGD,ZLGB,KAP)
";
_res.TAB.win_act(_res.WER,,'Wyświetl',,,,_fb);
_res.TAB.win_act(_res.WERR,,'Wyświetl',,,,_fb);

_res.TAB.grp_sel(_res.GRP,,_res.WER,'Rejestracje'@,,,,,"cur_tab(1,1).prefix('T');~~",,,,'maximized',,1);
{? _opcja=0 & exec('get','#params',8715,2,OPERATOR.USER)='T'
|| _res.TAB.grp_sel(_res.GRP,,_res.WERR,'Rozpoczęte operacje'@,,,,,"cur_tab(1,1).prefix('N');~~",,,,'maximized')
?};

_res.TAB.win_sel(_res.GRP);
_res.TAB.fld_fml('ILOSC','DISPLAY_FORMAT',"{? cur_tab(1,1).TPZ='T' || 'empty=1' || 'empty=0' ?}");
_res.TAB.fld_fml('IL_BRAK','DISPLAY_FORMAT',"{? cur_tab(1,1).TPZ='T' || 'empty=1' || 'empty=0' ?}");

{? ZGP.TPZ='T'
|| ZGP.cntx_psh();
   ZGP.index('UID');
   ZGP.prefix(ZGP.UID_TPZ);
   {? ZGP.first()
   || _zgp:=ZGP.ref()
   || _zgp:=null()
   ?};
   ZGP.cntx_pop()
|| {? VAR1.TPZ='T' || {? var_pres('__ZGPTPZ')>0 || _zgp:=__ZGPTPZ || _zgp:=null() ?} || _zgp:=null() ?}
?};

_name:=5+ZLGD.name();
_msk_start:=_name+ZGH.ZLEC().ODDZ+(2-$(ZL.OD~1));
_msk_end:=~~;

:: Formuła do wykonania w każdej masce ZLGD, wewnątrz ustalana maska ZLGB i ZL_WYRGD
_rule:="
   _args:=_b;
   _tab:=_args.TAB;
   _opcja:=_args.OPCJA;
   ZLGB.cntx_psh();
   ZLGB.use((5+ZLGB.name())+(ZLGD.name()+3));
   ZL_WYRGD.cntx_psh();
   ZL_WYRGD.use((5+ZL_WYRGD.name())+(ZLGD.name()+3));
   {? _opcja=1
   || ZLGD.index('ZPARN');
      ZLGD.prefix(_args.ZPARN)
   || ZLGD.index('S2');
      ZLGD.prefix(_args.ZGP)
   ?};
   {? ZLGD.first()
   || {!
      |?
         _tab.DT:=ZLGD.DT;
         _tab.TPZ:={? _opcja=1 || exec('FindAndGet','#table',ZGP,ZLGD.ZGP,,\"ZGP.TPZ\",'N') || 'N' ?};
         _tab.OK:=ZLGD.OK;
         _tab.ZLGD:=$ZLGD.ref();
         _tab.DK:=ZLGD.DK;
         {? _opcja=1
         || ZL.cntx_psh();ZGP.cntx_psh();ZGH.cntx_psh();
            _tab.ZL_SYM:=ZLGD.ZL().SYM;
            _tab.ZGP_NRP:=ZLGD.ZGP().NRPRZ().NRPRZ;
            _tab.ZGP_POZ:=ZLGD.ZGP().NRP;
            _tab.ZGP_OPIS:=ZLGD.ZGP().OPIS;
            ZL.cntx_pop();ZGP.cntx_pop();ZGH.cntx_pop()
         ?};
         {? ZLGD.ZGP<>null() & ZLGD.ZAK='N'
         ||
::           Operacja rozpoczęta na e-kiosku (niezakończona)
            _tab.PRAC:={? ZLGD.B<>null() || ZLGD.B().NAZ || ZLGD.P().OSOBA().NAZWISKO+' '+OSOBA.PIERWSZE ?};
            _tab.STARTD:=ZLGD.STARTD().DATA;
            _tab.STARTT:=ZLGD.STARTT;
            _tab.END:='N';
            _tab.ZLGB:='';
            _tab.add()
         || ZLGB.index('ZLGD');
            ZLGB.prefix(ZLGD.ref());
            {? ZLGB.first()
            || {!
               |? _tab.PRAC:=ZLGB.P().OSOBA().NAZWISKO+' '+OSOBA.PIERWSZE;
                  {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T'
                  || _tab.ILOSC:=ZLGB.IL;
                     _tab.IL_BRAK:=ZLGB.IL_BRAK;
                     _tab.BRAKI_R:=ZLGD.BRAKI_R().KOD
                  || _tab.ILOSC:=ZLGB.DEK_IL;
                     _tab.IL_BRAK:=ZLGB.DEK_BR;
                     _tab.BRAKI_R:=ZLGD.DEK_RBR().KOD
                  ?};
                  _tab.ILGEN:=ZLGD.ILGEN;
                  _tab.TIME:=ZLGB.TIME;
                  _tab.TIME_P:=ZLGB.TIME_P;
                  _tab.STARTD:=ZLGD.STARTD().DATA;
                  _tab.STARTT:=ZLGD.STARTT;
                  _tab.ENDD:=ZLGD.ENDD().DATA;
                  _tab.ENDT:=ZLGD.ENDT;
                  _tab.STAT_B:=ZLGD.STAT_B;
                  _tab.PLACE:=ZLGD.PLACE().KOD;
                  _tab.END:='T';
                  _tab.ZLGB:=$ZLGB.ref();
                  _tab.ZPARN:=$ZLGD.ZPARN;
                  _tab.ZPARNSYM:=ZLGD.ZPARN().SYM;
                  _tab.add();
                  ZLGB.next()
               !}
            ?}
         ?};
         ZLGD.next()
      !}
   ?};
   {? _opcja=0
   || ZLGD.prefix(_args.ZGP_TPZ);
      {? ZLGD.first()
      || {!
         |? _tab.DT:=ZLGD.DT;
            _tab.TPZ:='T';
            _tab.OK:=ZLGD.OK;
            _tab.ZLGD:=$ZLGD.ref();
            {? ZLGD.ZGP<>null() & ZLGD.ZAK='N'
            ||
::             Operacja rozpoczęta na e-kiosku (niezakończona)
               _tab.PRAC:={? ZLGD.B<>null() || ZLGD.B().NAZ || ZLGD.P().OSOBA().NAZWISKO+' '+OSOBA.PIERWSZE ?};
               _tab.STARTD:=ZLGD.STARTD().DATA;
               _tab.STARTT:=ZLGD.STARTT;
               _tab.END:='N';
               _tab.ZLGB:='';
               _tab.add()
            || ZLGB.index('ZLGD');
               ZLGB.prefix(ZLGD.ref());
               {? ZLGB.first()
               || {!
                  |? _tab.PRAC:=ZLGB.P().OSOBA().NAZWISKO+' '+OSOBA.PIERWSZE;
                     {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T'
                     || _tab.ILOSC:=ZLGB.IL;
                        _tab.IL_BRAK:=ZLGB.IL_BRAK;
                        _tab.BRAKI_R:=ZLGD.BRAKI_R().KOD
                     || _tab.ILOSC:=ZLGB.DEK_IL;
                        _tab.IL_BRAK:=ZLGB.DEK_BR;
                        _tab.BRAKI_R:=ZLGD.DEK_RBR().KOD
                     ?};
                     _tab.ILGEN:=ZLGD.ILGEN;
                     _tab.TIME:=ZLGB.TIME;
                     _tab.TIME_P:=ZLGB.TIME_P;
                     _tab.STARTD:=ZLGD.STARTD().DATA;
                     _tab.STARTT:=ZLGD.STARTT;
                     _tab.ENDD:=ZLGD.ENDD().DATA;
                     _tab.ENDT:=ZLGD.ENDT;
                     _tab.STAT_B:=ZLGD.STAT_B;
                     _tab.PLACE:=ZLGD.PLACE().KOD;
                     _tab.END:='T';
                     _tab.ZLGB:=$ZLGB.ref();
                     _tab.ZPARN:=$ZLGD.ZPARN;
                     _tab.ZPARNSYM:=ZLGD.ZPARN().SYM;
                     _tab.add();
                     ZLGB.next()
                  !}
               ?}
            ?};
            ZLGD.next()
         !}
      ?}
   |? _opcja=1
   ||
::    Przejście po zapisach robocizny w rozbiciu na wyrobu (tylko dla widoku od strony partii)
      ZL_WYRGD.index('ZPARN');
      ZL_WYRGD.prefix(_args.ZPARN);
      {? ZL_WYRGD.first()
      || {!
         |?
::          Podczytanie ZLGD
            ZL_WYRGD.ZLGD();
            _tab.DT:=ZLGD.DT;
            _tab.TPZ:=exec('FindAndGet','#table',ZGP,ZLGD.ZGP,,\"ZGP.TPZ\",'N');
            _tab.OK:=ZLGD.OK;
            _tab.ZLGD:=$ZLGD.ref();
            _tab.ZL_WYRGD:=$ZL_WYRGD.ref();
            ZL.cntx_psh();ZGP.cntx_psh();ZGH.cntx_psh();
            _tab.ZL_SYM:=ZLGD.ZL().SYM;
            _tab.ZGP_NRP:=ZLGD.ZGP().NRPRZ().NRPRZ;
            _tab.ZGP_POZ:=ZLGD.ZGP().NRP;
            _tab.ZGP_OPIS:=ZLGD.ZGP().OPIS;
            ZL.cntx_pop();ZGP.cntx_pop();ZGH.cntx_pop();
            ZLGB.index('ZLGD');
            ZLGB.prefix(ZLGD.ref());
            {? ZLGB.first()
            || {!
               |? _tab.PRAC:=ZLGB.P().OSOBA().NAZWISKO+' '+OSOBA.PIERWSZE;
                  {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T'
                  || _tab.ILOSC:=ZL_WYRGD.IL;
                     _tab.IL_BRAK:=ZL_WYRGD.IL_BRAK;
                     _tab.BRAKI_R:=ZLGD.BRAKI_R().KOD
                  || _tab.ILOSC:=ZL_WYRGD.DEK_IL;
                     _tab.IL_BRAK:=ZL_WYRGD.DEK_BR;
                     _tab.BRAKI_R:=ZLGD.DEK_RBR().KOD
                  ?};
                  _tab.ILGEN:=ZLGD.ILGEN;
                  _tab.TIME:=ZLGB.TIME;
                  _tab.TIME_P:=ZLGB.TIME_P;
                  _tab.STARTD:=ZLGD.STARTD().DATA;
                  _tab.STARTT:=ZLGD.STARTT;
                  _tab.ENDD:=ZLGD.ENDD().DATA;
                  _tab.ENDT:=ZLGD.ENDT;
                  _tab.STAT_B:=ZLGD.STAT_B;
                  _tab.PLACE:=ZLGD.PLACE().KOD;
                  _tab.END:='T';
                  _tab.ZLGB:=$ZLGB.ref();
                  _tab.ZPARN:=$ZL_WYRGD.ZPARN;
                  _tab.ZPARNSYM:=ZL_WYRGD.ZPARN().SYM;
                  _tab.add();
                  ZLGB.next()
               !}
            ?};
            ZL_WYRGD.next()
         !}
      ?}
   ?};
   ZLGB.cntx_pop();
   ZL_WYRGD.cntx_pop();
   ~~
";

_args:=obj_new('TAB','ZGP','ZGP_TPZ','ZPARN','OPCJA');
_args.TAB:=_res.TAB;
_args.ZGP:={? ZGP.TPZ='T' || _zgp || ZGP.ref() ?};
_args.ZGP_TPZ:={? ZGP.TPZ='T' || ZGP.ref() || _zgp ?};
_args.ZPARN:=ZPARN.ref();
_args.OPCJA:=_opcja;

_res.TAB.erase();
exec('for_each_mask','#table',ZLGD,_rule,_msk_start,_msk_end,_args);
_res.TAB.first();

_grayed:=':';
{? ZGP.DOK=null() || _grayed:='G'+_grayed ?};
{? ZGP.NRZLP().STAN<>'N' || _grayed:='PUR'+_grayed ?};
{? ZGP.ZL().STAN='Z' || _grayed:='PUR'+_grayed ?};
_res.TAB.actions_grayed(_res.WER,_grayed);

{? _select || _res.TAB.select() ?};
_res


\zgp_wrk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wyswietla rejestracje tylko z czasem maszynowym do pozycji przewodnika
::       Kontekst pracy: ZGP, ZGH
::   WE: _a - sposob pracy: 1 (domyslnie) selekcja, 0 - brak selekcji, TAB - brak selekcji, odswieza przekazana tabele
::   WY: _res.TAB, _res.WER
::  OLD: \zgp_wrk/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=obj_new('TAB','WER','GRP','WERR');

{? var_pres('_a')=type_of(0)
|| _select:=_a
|? var_pres('_a')=type_of(SYSLOG)
|| _select:=0
|| _select:=1
?};

{? var_pres('_a')=type_of(SYSLOG)
||
   _res.TAB:=_a
||
   _res.TAB:=tab_tmp(2,
      'END','STRING[1]','Zakończona'@,
      'DT','DATE','Data',
      'ILOSC','REAL','Ilość - dobre',
      'IL_BRAK','REAL','Ilość - braki',
      'ILGEN','REAL','Ilość na dokumentach'@,
      'ZLGD','STRING[16]','$ZLGD.ref()',
      'STARTD','DATE','',
      'STARTT','TIME','',
      'PRAC','STRING[51]','Pracownik'@,
      'BRAKI_R','STRING[20]','Rodzaj braku'@,
      'F','INTEGER',''
   )
?};
_res.GRP:=_res.TAB.grp_make('Rejestracje do pozycji przewodnika (stanowisko)'@,,'grp_wrk',,,,,'normal');
_res.WER:=_res.TAB.mk_sel('Rejestracje do pozycji przewodnika (stanowisko)'@,,,'zgp_wrk',,10,,,'U');
_res.TAB.win_fld(_res.WER,,'DT',,,,,,'Data'@);
_res.TAB.win_fld(_res.WER,,'ILOSC',,,15,ST.DOKL_P,,'Ilość — dobre'@);
_res.TAB.win_fld(_res.WER,,'IL_BRAK',,,15,ST.DOKL_P,,'Ilość — braki'@);
:: Okno z rozpoczętymi operacjami (z e-kiosku)
_res.WERR:=_res.TAB.mk_sel('Rozpoczęte operacje'@ ,,,'zgp_wrkr',,10,,,'U');
_res.TAB.win_fld(_res.WERR,,'STARTD',,,,,,'Data'@);
_res.TAB.win_fld(_res.WERR,,'STARTT',,,,,,'Godzina'@);
_res.TAB.win_fld(_res.WERR,,'PRAC',,,40,,,'Pracownik'@);
_fb:="
   {? var_pres('ProdRej')<0
   || FUN.info('Funkcja dostępna tylko od strony modułu rejestracji wykonań.'@)
   ||
      Cntx.psh(ZLGD);
      ZLGD.use(8+cur_tab(1,1).ZLGD);
      Cntx.clr(ZLGD);
      {? ZLGD.seek(cur_tab(1,1).ZLGD)
      || exec('wrk_popraw','zl_wyk')
      ?};
      Cntx.pop(ZLGD)
   ?}
";
_res.TAB.win_act(_res.WER,,'Formuła','Popraw'@@,,,_fb,,,,,,'P');
_fb:="
   exec('end_zlgd_ek','zl_wyk',1)
";
_res.TAB.win_act(_res.WERR,,'Formuła','&Zakończ'@@,,,_fb,,,,,,'Z');
task_attach('TTE_WYK_DWZL');
_fb:="
   {? var_pres('ProdRej')<0
   || FUN.info('Funkcja dostępna tylko od strony modułu rejestracji wykonań.'@)
   ||
      Cntx.psh(ZLGD);
      ZLGD.use(8+cur_tab(1,1).ZLGD);
      Cntx.clr(ZLGD);
      {? ZLGD.seek(cur_tab(1,1).ZLGD)
      || exec('wrk_usun','zl_wyk')
      ?};
      Cntx.pop(ZLGD)
   ?}
";
_res.TAB.win_act(_res.WER,,'Formuła','Usuń'@@,,,_fb,,,,,,'U');
_res.TAB.win_act(_res.WERR,,'Formuła','Usuń'@@,,,_fb,,,,,,'U');

_res.TAB.win_act(_res.WER,,'Menu','Fu&nkcje'@@,,,,,,,,,'N');
_res.TAB.win_act(_res.WERR,,'Menu','Fu&nkcje'@@,,,,,,,,,'N');

_fb:="
   _zlgd:=cur_tab(1,1).ZLGD;
   Cntx.psh(ZLGD,ZL_WYRGD);
   ZLGD.use(8+_zlgd);
   _mask:=(8+_zlgd)+3;
   ZL_WYRGD.use(5+ZL_WYRGD.name()+_mask);
   Cntx.clr(ZLGD,ZL_WYRGD);
   {? ZLGD.seek(_zlgd)
   || ZL_WYRGD.win_sel('WER');
      ZL_WYRGD.index('ZLGD');
      ZL_WYRGD.prefix(ZLGD.ref());
      ZL_WYRGD.select(,,,'DPU:D')
   ?};
   Cntx.pop(ZLGD,ZL_WYRGD)
";
_res.TAB.win_act(_res.WER,,'Formuła','Rozpisanie pr&oduktów'@@,'#N',,_fb,,,,,,'O');

_fb:="
   _tab:=cur_tab(1,1);
   _zlgd:=exec('FindAndGet','#table',ZLGD,_tab.ZLGD,,\"ZLGD.ref()\",null());
   _zl:=exec('FindAndGet','#table',ZLGD,_tab.ZLGD,,\"ZLGD.ZL\",null());
   ZLGD.cntx_psh();
   _mask:=ref_name(_zlgd);
   {? ZLGD.name()<>_mask || ZLGD.use(_mask) ?};
   ZLGD.prefix();
   {? ZLGD.seek(_zlgd)
   || exec('rozpirez','rezerwacje',,2)
   ?};
   ZLGD.cntx_pop()
";
_res.TAB.win_act(_res.WER,,'Formuła','Pobrania &surowców'@@,'#N',,_fb,,,,,,'S');
task_attach('TTE_WYK_DGRW');
_res.TAB.win_act(_res.WERR,,'Formuła','Pobrania &surowców'@@,'#N',,_fb,,,,,,'S');
task_attach('TTE_WYK_DGRW');

_fb:="
   _tab:=cur_tab(1,1);
   _zlgd:=exec('FindAndGet','#table',ZLGD,_tab.ZLGD,,\"ZLGD.ref\",null);
   BADH.cntx_psh();
   BADH.index('TZLGD');
   BADH.prefix('C',_zlgd,ref_name(_zlgd));
   {? BADH.first()
   || _badh:=BADVAR.BADH;
      BADVAR.BADH:=BADH.ref();
      BADP.cntx_psh();
      BADP.index('BADHBPAR');
      BADP.prefix(BADH.ref());
      BADP.first();
      BADP.win_sel('WER_B_OP');
      _zak:=exec('FindAndGet','#table',ZLGD,_zlgd,,\"ZLGD.ZAK\",'N');
      {? _zak<>'T'
      || BADP.actions('WER_B_OP','WA')
      || BADP.actions('WER_B_OP','')
      ?};

      BADP.select();
      BADVAR.BADH:=_badh;
      BADP.cntx_pop()
   || FUN.info('Brak zarejestrownaych badań dla danego zapisu robocizny.'@)
   ?};
   BADH.cntx_pop()
";
_res.TAB.win_act(_res.WER,,'Formuła','Powiązane &badanie'@@,'#N',,_fb,,,,,,'B');
_res.TAB.win_act(_res.WERR,,'Formuła','Powiązane &badanie'@@,'#N',,_fb,,,,,,'B');

_fb:="
   _tab:=cur_tab(1,1);
   _zlgd:=_tab.ZLGD;
   ZLGD.cntx_psh();
   ZLGD.use(8+_tab.ZLGD);
   ZLGD.prefix();
   {? ZLGD.seek(_tab.ZLGD)
   || exec('zlnd_sel','magdok_prod')
   ?};
   ZLGD.cntx_pop()
";
_res.TAB.win_act(_res.WER,,'Formuła','Dokumenty &magazynowe'@@,'#N',,_fb,,,,,,'M');

_res.TAB.win_act(_res.WER,,'Formuła','-- X','#N',,,,,,,,'Ą');

_fb:="
   ZLGD.cntx_psh();
   ZLGD.use(8+cur_tab(1,1).ZLGD);
   ZLGD.prefix();
   {? ZLGD.seek(cur_tab(1,1).ZLGD)
   || exec('zmiany','#syslog',ZLGD)
   ?};
   ZLGD.cntx_pop()
";
_res.TAB.win_act(_res.WER,,'Formuła','Zmiany — &wykonanie'@@,'#N',,_fb,,,,,,'W');
_fb:="
   Cntx.psh(ZLGD);
   ZLGD.use(8+cur_tab(1,1).ZLGD);
   Cntx.clr(ZLGD);
   {? ZLGD.seek(cur_tab(1,1).ZLGD)
   || exec('wrk_wyswietl','zl_wyk')
   ?};
   Cntx.pop(ZLGD)
";
_res.TAB.win_act(_res.WER,,'Wyświetl',,,,_fb);
_res.TAB.win_act(_res.WERR,,'Wyświetl',,,,_fb);

_res.TAB.grp_sel(_res.GRP,,_res.WER,'Rejestracje'@,,,,,"cur_tab(1,1).prefix('T');~~",,,,'maximized',,1);
{? exec('get','#params',8715,2,OPERATOR.USER)='T'
|| _res.TAB.grp_sel(_res.GRP,,_res.WERR,'Rozpoczęte operacje'@,,,,,"cur_tab(1,1).prefix('N');~~",,,,'maximized')
?};
_res.TAB.win_sel(_res.GRP);

_tab:=sql('
   select
      ZLGD.ZAK as "END",
      ZLGD.DT as DT,
      ZLGD.IL as ILOSC,
      ZLGD.IL_BRAK as IL_BRAK,
      ZLGD.ILGEN as ILGEN,
      to_string(ZLGD.REFERENCE) as ZLGD,
      DATY.DATA as STARTD,
      ZLGD.STARTT as STARTT,
      OSOBA.PIERWSZE || \' \' || OSOBA.NAZWISKO as PRAC,
      BRAKI_R.KOD as BRAKI_R
   from @ZLGD
        left join DATY using (ZLGD.STARTD,DATY.REFERENCE)
        left join P using (ZLGD.P,P.REFERENCE)
        left join OSOBA using (P.OSOBA,OSOBA.REFERENCE)
        left join BRAKI_R using (ZLGD.BRAKI_R,BRAKI_R.REFERENCE)
   where
      ZLGD.ZGP=:_a and ZLGD.ZGH=:_b
',ZGP.ref(),ZGH.ref());

{? type_of(_tab)=type_of(~~) || exec('err_sql','#sql'); return(_res) ?};

exec('tab2tab','#table',_tab,_res.TAB);

{? ZGP.DOK=null() || _res.TAB.actions_grayed(_res.WER,'G') ?};

{? _select || _res.TAB.select() ?};
_res


\zgp_wykon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wyświetla wykonania do pozycji przewodnika
::----------------------------------------------------------------------------------------------------------------------
{? ZGP.WEW='T'
|| {? ZGP.NTIME<>0
   || exec('zgp_godz','zl_wyk')
   || exec('zgp_wrk','zl_wyk')
   ?}
|| exec('zgp_koop','zl_koop')
?}


\wrk_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsluga Popraw w oknie ZLGD dla kooperacji
::  OLD: \wrk_popraw/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLGD.ZGP().NTIME=0
||
   Cntx.psh(ZLGD,ZLGB);
   ZLGD.use(8+cur_tab(1,1).ZLGD);
   ZLGB.use('zlgb'+((8+cur_tab(1,1).ZLGD)+4));
   Cntx.clr(ZLGD,ZLGB);
   {? ZLGD.seek(cur_tab(1,1).ZLGD)
   || {? exec('_popraw','zl_wyk')
      ||
         _tab:=cur_tab(1,1);
         _tab.ILOSC:=ZLGD.IL;
         _tab.IL_BRAK:=ZLGD.IL_BRAK;
         _tab.DT:=ZLGD.DT;
         _tab.BRAKI_R:=ZLGD.BRAKI_R().KOD;
         _tab.put()
      ?}
   ?};
   Cntx.pop(ZLGD,ZLGB)

|| FUN.emsg('To nie jest operacja tylko z czasem maszynowym.'@)
?};
~~


\wrk_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsluga Usun w oknie ZLGD dla kooperacji
::  OLD: \wrk_usun/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLGD.ZGP().NTIME=0
||
   Cntx.psh(ZLGD,ZLGB);
   ZLGD.use(8+cur_tab(1,1).ZLGD);
   ZLGB.use('zlgb'+((8+cur_tab(1,1).ZLGD)+4));
   Cntx.clr(ZLGD,ZLGB);
   {? ZLGD.seek(cur_tab(1,1).ZLGD)
   || {? exec('zlgd_usun','zl_wyk')>0
      || cur_tab(1,1).del()
      ?}
   ?};
   Cntx.pop(ZLGD,ZLGB)

|| FUN.emsg('To nie jest operacja tylko z czasem maszynowym.'@)
?};
~~


\wrk_wyswietl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Obsluga Wyswietl w oknie ZLGD dla kooperacji
::  OLD: \wrk_wyswietl/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T'
|| VAR1.IL:=ZLGD.IL;
   VAR1.IL_BRAK:=ZLGD.IL_BRAK;
   VAR1.BRAKI_R:=ZLGD.BRAKI_R
|| VAR1.IL:=ZLGD.DEK_IL;
   VAR1.IL_BRAK:=ZLGD.DEK_BR;
   VAR1.BRAKI_R:=ZLGD.DEK_RBR
?};
ZLGD.win_edit('RED_WRK');
ZLGD.display();
~~


\godz_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2011]
:: OPIS: Podglad zarejestrowanych godzin pracy dla zlecenia/przewodnika
::   WE: [_a] - INTEGER - kontekst wywołania: [1] - zlecenia, 0 - przewodnik
::  OLD: \godz_sel/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
_mode:={? var_pres('_a')=type_of(0) || _a || 1 ?};
{? _mode=0
|| _ref:=VAR.A_NRPRZ
|| _ref:=ZL.UNRZL
?};
:: zbieram wszystkie wpisy do ZLGB (pojedyncze godziny pracownikow)
_tab:=sql('
   select
      cast (NULL AS TREE_REF_TYPE) as Parent,
      \'                              \' as LABEL1,
      \'                                                                      \' as LABEL2,
      \' \' as TYP,
      OSOBA.NAZWISKO as Nazwisko,
      OSOBA.PIERWSZE as Imie,
      P.T as NR_TEK,
      ZL.SYM as SYM,
      ZL.OPIS as OPIS,
      ZL.ILWYK as ILWYK,
      ZLBR.KOD as Kod,
      ZLBR.NAZ as Nazwa,
      ZLGB.IL as Ilosc,
      ZLGB.TIME as Czas,
      ZLGB.TIME_P as "Czas kalkulowany",
      ZLGB.ST as "Stawka",
      ZLGB.KW as "Kwota",
      ZLGD.DT as Data,
      ZLGD.BP as BP,
      ZLGD.IL as Bilosc,
      ZLGD.TIME as Bczas,
      ZLGD.REFERENCE as ZLGDREF,
      ZLGB.REFERENCE as ZLGBREF,
      ZL.REFERENCE as ZLREF,
      ZPARN.SYM as Partia,
      MG.SYM as Magazyn,
      EANL.KOD as "Lokalizacja",
      ZGP.OPIS as OPER,
      ZGP.REFERENCE as ZGPREF,
      ZGH.NRPRZ as NRPRZ,
      ZGH.REFERENCE as ZGHREF
   from @ZLGB
      join @ZLGD using(ZLGB.ZLGD, ZLGD.REFERENCE)
      join ZGP using(ZLGD.ZGP, ZGP.REFERENCE)
      join ZGH using (ZGP.NRPRZ,ZGH.REFERENCE)
      join ZL using(ZLGD.ZL, ZL.REFERENCE)
      left join @P using (ZLGB.P, P.REFERENCE)
      left join ZLBR using(ZLGD.B, ZLBR.REFERENCE)
      join OSOBA using(P.OSOBA, OSOBA.REFERENCE)
      left join ZPARN using(ZLGD.ZPARN, ZPARN.REFERENCE)
      left join MG using (ZL.MG,MG.REFERENCE)
      left join EANL using (ZL.EANL,EANL.REFERENCE)
   where '+{? _mode=0 || 'ZGH.REFERENCE=:_a' || 'ZL.UNRZL=:_a or ZL.NRNZL=:_a ' ?}+'
   order by PARENT
', _ref);

:: przetworzenie tabeli na drzewo
exec('godz_proc','zl_wyk',_tab,_mode);

_ndx2:=_tab.ndx_tmp(,1,'PARENT',,,'LABEL2',,);
_tab.index(_ndx2);
_wer:=_tab.mk_sel('Zarejestrowana robocizna'@,'P',0,'#godzsel',,10,,1);
_tab.win_fld(_wer,,'LABEL1',,,25,,,'Pracownik/brygada'@,,'Zlecenie/Pracownik/Brygada'@,,,,,,'mobile_header=1,mobile_visible=1');
_tab.win_fld(_wer,,'LABEL2',,,30,,,'Opis'@,,'Nazwisko i imię pracownika / Nazwa Brygady'@,,,,,,'mobile_visible=1');
_tab.win_fld(_wer,VAR,'DATE',,,10,,,'Data'@,,'Data rejestracji czasu pracy'@);
_tab.win_fld(_wer,,'OPER',,,10,,,'Operacja'@,,'Operacja do której zarejestrowano robociznę'@,,,,,,'mobile_visible=1');
_tab.win_fld(_wer,,'ILOSC',,,15,ST.DOKL_P,,'Ilość'@,,'Ilość wykonana'@,,,,,,'mobile_visible=1');
_tab.win_fld(_wer,,'CZAS',,,15,4,,'Czas'@,,'Zarejestrowany czas pracy'@,,,,,,'mobile_visible=1');
_tab.win_act(_wer,,'Formuła','Zwiń/roz&wiń'@@,,'Zwiń/rozwiń wszystkie rekordy'@,
   "exec('zwrw_all','#tree',cur_tab(1,1),'PARENT')",,,,,,,,'target=window');
_tab.win_act(_wer,,'Menu','Fu&nkcje'@@,,,,,,,,,'N');
_form:="
   _tab:=cur_tab(1,1);
   _zlgd:=exec('FindAndGet','#table',ZLGD,_tab.ZLGDREF,,\"ZLGD.ref\",null());
   BADH.cntx_psh();
   BADH.index('TZLGD');
   BADH.prefix('C',_zlgd,ref_name(_zlgd));
   {? BADH.first()
   || _badh:=BADVAR.BADH;
      BADVAR.BADH:=BADH.ref();
      BADP.cntx_psh();
      BADP.index('BADHBPAR');
      BADP.prefix(BADH.ref());
      BADP.first();
      BADP.win_sel('WER_B_OP');
      BADP.select();
      BADVAR.BADH:=_badh;
      BADP.cntx_pop()
   || FUN.info('Brak zarejestrownaych badań dla danego zapisu robocizny.'@)
   ?};
   BADH.cntx_pop()

";
_tab.win_act(_wer,,'Formuła','Powiązane &badanie'@@,'#N',,_form,,,,,,'B');
_tab.win_act(_wer,,'Formuła','-- X','#N',,,,,,,,'Ą');
_fb:="
   ZLGD.cntx_psh();
   ZLGD.use(8+cur_tab(1,1).ZLGDREF);
   ZLGD.prefix();
   {? ZLGD.seek(cur_tab(1,1).ZLGDREF)
   || exec('zmiany','#syslog',ZLGD)
   ?};
   ZLGD.cntx_pop()
";
_tab.win_act(_wer,,'Formuła','Zmiany — &wykonanie'@@,'#N',,_fb,,,,,,'W');
_fb:="
   ZLGB.cntx_psh();
   ZLGB.use(8+cur_tab(1,1).ZLGBREF);
   ZLGB.prefix();
   {? ZLGB.seek(cur_tab(1,1).ZLGBREF)
   || exec('zmiany','#syslog',ZLGB)
   ?};
   ZLGB.cntx_pop()
";
_tab.win_act(_wer,,'Formuła','Zmiany — &godziny'@@,'#N',,_fb,,,,,,'G');
{? exec('get','#params',8712,type_of(''),OPERATOR.USER)='T'
||
   _fb:="
      _zgp:=exec('FindAndGet','#table',ZGP,cur_tab(1,1).ZGPREF,,,null());
      {? _zgp<>null()
      || exec('zgp_rej','zl_wyk',_zgp)
      || FUN.emsg('Nie znaleziono pozycji przewodnika'@)
      ?};
      ~~
   "
?};
_tab.win_act(_wer,,'Formuła','&Rejestracje'@@,,,_fb,,,,,,'G');
_tab.win_act(_wer,,'Formuła','Legenda'@@,,,"exec('legenda','color','#ROB#02')",,,,,,'L',,'target=window');
_tab.win_act(_wer,,'Rekord',,,,"exec('godz_rkp','zl_wyk',_a)");
_winfml:=" {? cur_tab(1,1).TYP='Z'
           || 'xwin16.png:75'
           |? cur_tab(1,1).TYP='P'
           || 'xwin16.png:100'
           |? cur_tab(1,1).TYP='B'
           || 'xwin16.png:31'
           || 'xwin16.png:76'
           ?}
         ";
_tab.win_fml(_wer,,'LABEL1',,'ICON_BEFORE',_winfml);
_tab.win_sel(_wer);
_tab.fld_attr('ZLGDREF',2); _tab.fld_attr('ZLREF',2); _tab.fld_attr('ZLGBREF',2); _tab.fld_attr('BILOSC',2);
_tab.fld_attr('BCZAS',2); _tab.fld_attr('LABEL1',2); _tab.fld_attr('LABEL2',2); _tab.fld_attr('NAZWA',2);
_tab.fld_attr('KOD',2); _tab.fld_attr('BP',2); _tab.fld_attr('NAZWISKO',2); _tab.fld_attr('IMIE',2);
_tab.fld_attr('SYM',2); _tab.fld_attr('OPIS',2); _tab.fld_attr('ILWYK',2);

VAR.fld_fml('DATE','DISPLAY_FORMAT',"{? fld()=date(0,0,0) || 'empty=1' || 'empty=0' ?}");
VAR.fld_fml('DATE','BEFORE_DISPLAY',"1");
_tab.select();
VAR.fld_fml('DATE','DISPLAY_FORMAT',"*");
VAR.fld_fml('DATE','BEFORE_DISPLAY',"*");
~~


\godz_rkp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2011]
:: OPIS: Rekord - przed dla okna tabeli wyswietlajacej godziny zarejestrowane dla zlecenia.
::   WE: _a - parametr systemowy
::  OLD: \godz_rkp/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
{? _a
|| _tab.actions_grayed(cur_win(1,1),{? 1+_tab.LABEL1='Z' || 'YN(B)' || '' ?})
?};
{? 1+_tab.LABEL1='Z'
|| VAR.DATE:=date(0,0,0)
|| VAR.DATE:=_tab.DATA
?};
~~


\godz_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2011]
:: OPIS: Przetworzenie tabeli z zarejestrowanym akordem dla zlecenia na drzewo
::   WE: _a - przetwarzana tabela
::   WE: [_b] - INTEGER - kontekst wywołania: [1] - zlecenia, 0 - przewodnik
::  OLD: \godz_proc/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_mode:={? var_pres('_b')=type_of(0) || _b || 1 ?};
_ndx1:=_tab.ndx_tmp(,1,'ZLREF',,,'ZLGDREF',,,'ZLGBREF',,);
_tab.index(_ndx1);
_parent:=0;
_zlparent:=0;
_zlref:='';
_zlgdref:='';
_sumkw:=0;
_sumkalk:=0;
_sumst:=0;
_lp:=0;
_sumczas:=0;
_czy_wyr:=0;
:: lecę po całej tabeli i formuje z niej drzewo
{? _tab.first()
|| {!
   |?
::    Czy nie stworzyć nowego węzła dla kolejnego zlecenia
      {? _tab.ZLREF<>_zlref
      || _tab.cntx_psh();
         {? _mode=0
         || _tab.LABEL1:='Przewodnik: %1'@[_tab.NRPRZ];
            _tab.LABEL2:=''
         || _tab.LABEL1:='Zlecenie: %1'@[_tab.SYM];
            _tab.LABEL2:=_tab.OPIS
         ?};
         _tab.TYP:='Z';
         _tab.NAZWISKO:='';
         _tab.IMIE:='';
         _tab.NAZWA:='';
         _tab.KOD:='';
         _tab.OPER:='';
         _tab.add();
         _tab.cntx_psh();
         {? _zlref<>''
         || {? _tab.seek(_zlparent,)
            || _tab.ILOSC:=_tab.ILWYK;
               _tab.CZAS:=_sumczas;
               _tab.KWOTA:=_sumkw;
               _tab.STAWKA:={? _lp<>0 || _sumst/_lp || 0 ?};
               _tab.CZAS0002:=_sumkalk;
               _sumkw:=0;
               _sumczas:=0;
               _sumst:=0;
               _lp:=0;
               _sumkalk:=0;
               _tab.put()
            ?}
         ?};
         _tab.cntx_pop();
         _zlref:=_tab.ZLREF;
         _zlparent:=#_tab.ref();
         _tab.cntx_pop()
      ?};
      {? _tab.ZLGDREF<>_zlgdref
      || _czy_wyr:=exec('zlgd_czy_wyr','zl_wyr',_tab.ZLGDREF)
      ?};
::    jak wpis dotyczy brygady
      {? _tab.BP='B'
      ||
::       ponizszy warunek to ochrona przed zapętleniem
         {? _tab.ZLGDREF<>_zlgdref
         || _tab.cntx_psh();
            _tab.LABEL1:='Brygada: %1'@[_tab.KOD];
            _tab.LABEL2:=_tab.NAZWA;
            _tab.TYP:='B';
            _tab.NAZWISKO:='';
            _tab.IMIE:='';
            _tab.ILOSC:=_tab.BILOSC;
            _tab.CZAS:=_tab.BCZAS;
            _tab.PARENT:=_zlparent;
            _tab.add();
            _parent:=#_tab.ref;
            _tab.cntx_pop();
            _zlgdref:=_tab.ZLGDREF;
            {? _czy_wyr>0
            || _tab.cntx_psh();
               _tab.LABEL1:='Produkty:'@;
               _tab.LABEL2:='Produkty zlecenia';
               _tab.TYP:='X';
               _tab.NAZWISKO:='';
               _tab.IMIE:='';
               _tab.ILOSC:=_tab.BILOSC;
               _tab.CZAS:=_tab.BCZAS;
               _tab.PARENT:=_parent;
               _tab.ZLGBREF:='';
               _tab.add();
               _parent2:=#_tab.ref;
               _tab.cntx_pop();
::               _zlgdref:=_tab.ZLGDREF;
               _zlgd:=exec('FindAndGet','#table',ZLGD,_tab.ZLGDREF,,,null());
               ZPARN.cntx_psh(); MG.cntx_psh(); EANL.cntx_psh();
               _tab.cntx_psh();
               ZL_WYRGD.cntx_psh();
               _mask:=(5+ZL_WYRGD.name())+(ref_name(_zlgd)+3);
               {? ZL_WYRGD.name()<>_mask
               || ZL_WYRGD.use(_mask)
               ?};
               ZL_WYRGD.index('ZLGD');
               ZL_WYRGD.prefix(_zlgd);
               {? ZL_WYRGD.first()
               ||
                  {!
                  |?
                     _tab.LABEL1:='%1'[ZL_WYRGD.KTM().KTM];
                     _tab.LABEL2:='%1'[ZL_WYRGD.KTM().N];
                     _tab.TYP:='W';
                     _tab.ILOSC:=ZL_WYRGD.IL;
                     _tab.CZAS:=_tab.BCZAS;
                     _tab.PARTIA:=ZL_WYRGD.ZPARN().SYM;
                     _tab.MAGAZYN:=ZL_WYRGD.MG().SYM;
                     _tab.LOKALIZACJA:=ZL_WYRGD.EANL().KOD;
                     _tab.PARENT:=_parent2;
                     _tab.ZLGBREF:='';
                     _tab.add();
                     _lp+=1;
                     ZL_WYRGD.next()
                  !}
               ?};
               ZL_WYRGD.cntx_pop();
               _tab.cntx_pop();
               ZPARN.cntx_pop(); MG.cntx_pop(); EANL.cntx_pop()
            ?};
            {!
            |? {? _tab.TYP<>'B' & _tab.TYP<>'Z'
               || _tab.LABEL1:='Pracownik: %1 %2'@[_tab.NAZWISKO,_tab.IMIE];
                  _tab.LABEL2:='Nr teczki: %1'[_tab.NR_TEK];
                  _tab.TYP:='P';
                  _tab.PARENT:=_parent;
                  _tab.put();
                  _sumkw+=_tab.KWOTA;
                  _lp+=1;
                  _sumst+=_tab.STAWKA;
                  _sumkalk+=_tab.CZAS0002;
                  _sumczas+=_tab.CZAS
               ?};
               _tab.next() & _tab.ZLGDREF=_zlgdref
            !}
         ?}

::    jak wpis dotyczy pojedynczego pracownika
      || {? _tab.TYP<>'B' & _tab.TYP<>'Z'
         || _tab.PARENT:=_zlparent;
            _tab.LABEL1:='Pracownik: %1 %2'@[_tab.NAZWISKO,_tab.IMIE];
            _tab.LABEL2:='Nr teczki: %1'[_tab.NR_TEK];
            _tab.TYP:='P';
            _tab.put();
            _parent:=#_tab.ref;
            _sumkw+=_tab.KWOTA;
            _lp+=1;
            _sumst+=_tab.STAWKA;
            _sumkalk+=_tab.CZAS0002;
            _sumczas+=_tab.CZAS;
            {? _czy_wyr>0
            || _zlgd:=exec('FindAndGet','#table',ZLGD,_tab.ZLGDREF,,,null());
               ZPARN.cntx_psh(); MG.cntx_psh(); EANL.cntx_psh();
               _tab.cntx_psh();
               ZL_WYRGD.cntx_psh();
               _mask:=(5+ZL_WYRGD.name())+(ref_name(_zlgd)+3);
               {? ZL_WYRGD.name()<>_mask
               || ZL_WYRGD.use(_mask)
               ?};
               ZL_WYRGD.index('ZLGD');
               ZL_WYRGD.prefix(_zlgd);
               {? ZL_WYRGD.first()
               ||
                  {!
                  |?
                     _tab.LABEL1:='%1'[ZL_WYRGD.KTM().KTM];
                     _tab.LABEL2:='%1'[ZL_WYRGD.KTM().N];
                     _tab.TYP:='W';
                     _tab.ILOSC:=ZL_WYRGD.IL;
                     _tab.CZAS:=_tab.BCZAS;
                     _tab.PARTIA:=ZL_WYRGD.ZPARN().SYM;
                     _tab.MAGAZYN:=ZL_WYRGD.MG().SYM;
                     _tab.LOKALIZACJA:=ZL_WYRGD.EANL().KOD;
                     _tab.PARENT:=_parent;
                     _tab.ZLGBREF:='';
                     _tab.add();
                     _lp+=1;
                     ZL_WYRGD.next()
                  !}
               ?};
               ZL_WYRGD.cntx_pop();
               _tab.cntx_pop();
               ZPARN.cntx_pop(); MG.cntx_pop(); EANL.cntx_pop()
            ?}
         ?};
         _tab.next()
      ?}
   !};
   _tab.cntx_psh();
   {? _zlref<>''
   || {? _tab.seek(_zlparent,)
      || _tab.ILOSC:=_tab.ILWYK;
         _tab.CZAS:=_sumczas;
         _tab.KWOTA:=_sumkw;
         _tab.STAWKA:={? _lp<>0 || _sumst/_lp || 0 ?};
         _tab.CZAS0002:=_sumkalk;
         _sumkw:=0;
         _sumczas:=0;
         _sumst:=0;
         _lp:=0;
         _sumkalk:=0;
         _tab.put()
      ?}
   ?};
   _tab.cntx_pop()
?}


\odtworz_ilwyk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [TS] - 2001/08/16 - [7.53]
:: OPIS: Odtwarza zawartość pola ZL.ILWYK
::  OLD: \odtworz_zl/produ.fml
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy odtwarzać dane?'@)
||
:: najpierw wyczyszczenie aktualnej zawartosci pola ZL.ILWYK
:: tylko zlecenia ~HIDDEN
   ZL.cntx_psh();
   ND.cntx_psh();
   DK.cntx_psh();

   ZL.index('HIDDEN');
   ZL.prefix('N');
   {? ZL.first()
   || FUN.prg_start(ZL.size(),'Aktualizacja zleceń: zerowanie ilości.'@,,,1);
      {!
      |? FUN.prg_next();
         ZL.ILWYK:=0;
         ZL.ILWYK_D:=0;
         ZL.put();
         ZL.next()
      !};
      FUN.prg_stop()
   ?};

:: Wyliczenia wg przewodników
   exec('oblicz_zgh','zl_wyk');

:: Uwzględnienie dokumentów zwrotu na produkcję
   _tab:=sql('
      select sum(DK.IL) as IL, ZL.SYM, ZL.REFERENCE as REF
      from ZL join @DK using (DK.ZL,ZL.REFERENCE)
              join @ND using (DK.N,ND.REFERENCE)
              join TYPYDOK using (ND.TYP,TYPYDOK.REFERENCE)
      where TYPYDOK.P=''N'' and ND.Z=''T'' and TYPYDOK.WYR=''T''
      group by ZL.SYM,ZL.REFERENCE
   ');

   {? type_of(_tab)=type_of(~~)
   || exec('err_sql','#sql');
      ZL.cntx_pop();
      ND.cntx_pop();
      DK.cntx_pop();
      return('')
   ?};

   {? _tab.first()
   || FUN.prg_start(_tab.size(),'Aktualizacja zleceń: nanoszenie zwrotów.'@,,,1);
      {!
      |? FUN.prg_next();
         ZL.clear();
         {? ZL.seek(_tab.REF)
         || ZL.ILWYK-=_tab.IL;
            ZL.put()
         ?};
         _tab.next()
      !};
      FUN.prg_stop()
   ?};

   ZL.cntx_pop();
   ND.cntx_pop();
   DK.cntx_pop()
?};
''


\odtworz_ildok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [TS] - 2001/08/16 - [7.53]
:: OPIS: Odtwarza zawartość pola ZL.ILDOK
::  OLD: \odtworz_zl/produ.fml
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy odtwarzać dane?'@)
||
:: najpierw wyczyszczenie aktualnej zawartosci pola ZL.ILDOK
:: tylko zlecenia ~HIDDEN
   ZL.cntx_psh();
   ND.cntx_psh();
   DK.cntx_psh();

   ZL.index('HIDDEN');
   ZL.prefix('N');
   {? ZL.first()
   || FUN.prg_start(ZL.size(),'Aktualizacja zleceń: zerowanie ilości.'@,,,1);
      {!
      |? FUN.prg_next();
         ZL.ILDOK:=0;
         ZL.put();
         ZL.next()
      !};
      FUN.prg_stop()
   ?};

:: Wyliczenia wg raportów produkcji (zaraportowane minus zwrócone na produkcję)
   _tab:=sql('
      select sum(DK.IL) as IL, ZL.SYM, ZL.REFERENCE as REF
      from ZL join @DK using (DK.ZL,ZL.REFERENCE)
              join @ND using (DK.N,ND.REFERENCE)
              join TYPYDOK using (ND.TYP,TYPYDOK.REFERENCE)
      where TYPYDOK.P=''T'' and ND.Z=''T'' and TYPYDOK.WYR=''T''
      group by ZL.SYM, ZL.REFERENCE
      union all
      select sum(DK.IL*-1) as IL, ZL.SYM, ZL.REFERENCE as REF
      from ZL join @DK using (DK.ZL,ZL.REFERENCE)
              join @ND using (DK.N,ND.REFERENCE)
              join TYPYDOK using (ND.TYP,TYPYDOK.REFERENCE)
      where TYPYDOK.P=''N'' and ND.Z=''T'' and TYPYDOK.WYR=''T''
      group by ZL.SYM, ZL.REFERENCE
   ');

   {? type_of(_tab)=type_of(~~)
   || exec('err_sql','#sql');
      ZL.cntx_pop();
      ND.cntx_pop();
      DK.cntx_pop();
      return('')
   ?};

   {? _tab.first()
   || FUN.prg_start(_tab.size(),'Aktualizacja zleceń: nanoszenie ilości.'@,,,1);
      {!
      |? FUN.prg_next();
         ZL.clear();
         {? ZL.seek(_tab.REF)
         || {? exec('is_usluga_zl','zl_uslugi') & _tab.IL<0
            || _tab.IL:=_tab.IL*(-1)
            ?};
            ZL.ILDOK+=_tab.IL;
            ZL.put();
            {? ZL.NRNZL<>0 & ZL.NR=1
            || _nrn:=ZL.NRNZL;
               ZL.cntx_psh();
               ZL.index('UNRZL');
               ZL.prefix(_nrn);
               {? ZL.first()
               || {? ZL.RODZAJ='Z' | ZL.RODZAJ='N'
                  || ZL.ILDOK+=_tab.IL;
                     ZL.put()
                  ?}
               ?};
               ZL.cntx_pop()
            ?}
         ?};
         _tab.next()
      !};
      FUN.prg_stop()
   ?};

   ZL.cntx_pop();
   ND.cntx_pop();
   DK.cntx_pop()
?};
''


\oblicz_zgh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Wylicza ilość wykonaną na zleceniach na podstawie przewodników
::  OLD: \oblicz_zgh/produ.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
ZL.clear();
ZL.index('RODZAJ');
ZL.prefix('P');
{? ZL.first()
|| FUN.prg_start(ZL.size(),'Aktualizacja zleceń: nanoszenie ilości.'@,,,1);
   {!
   |? FUN.prg_next();
      exec('oblicz_zgh_1zl','zl_wyk',ZL.ref());
      ZL.next()
   !};
   FUN.prg_stop()
?};
ZGH.clear();
ZGP.clear();
ZL.cntx_pop();
~~


\oblicz_zgh_1zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wylicza ilość wykonaną na zleceniu na podstawie przewodników
::   WE: _a - ZL.ref()
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_a)
|| _ilosc:=0;
   _ilosc_d:=0;
   _ilwtok:=0;
   {? ZL.HIDDEN='N'
   || ZGH.cntx_psh(); ZGP.cntx_psh();
      ZGH.index('ZLNR');
      ZGH.prefix(ZL.ref());
      {? ZGH.first()
      || {!
         |? {? ZGH.STAN='T'
            || _ilosc+=ZGH.ILGEN;
               _ilwtok+=ZGH.ILGEN
            || {? ZL.NRNZL=0
               || ZGP.index('NRPP');
                  ZGP.prefix(ZGH.ref(),'N')
               || ZGP.index('PNRPP');
                  ZGP.prefix(ZGH.ref(),'N')
               ?};
               _ilmin:=0;
               _ilmax:=0;
               _ilmin_d:=0;
               {? ZGP.first()
               || _ilmin+=ZGP.IL;
                  _ilmax+=ZGP.IL;
                  _ilmin_d+=ZGP.IL+ZGP.DEK_IL;
                  {? ZGP.NAPRAW<>'T'
                  ||
::                   Dodanie ilośći z powiązanych operacji naprawczych
                     {? var_pres('_res')>100 || obj_del(_res) ?};
                     _res:=exec('count_wyk4zgp','braki',ZGP.ref());
                     _ilmin+=_res.ILWYK;
                     _ilmin_d+=_res.ILWYK_D
                  ?};
                  _il1:=0;
                  _il2:=0;
                  {!
                  |?
::                   Pomijam opearcje naprawcze (ilości wykonane wliczone do operacji źródłowych)
                     {? ZGP.NAPRAW<>'T'
                     || _il1+=ZGP.IL;
                        _il2+=ZGP.IL+ZGP.DEK_IL;
::                      Dodanie ilośći z powiązanych operacji naprawczych
                        _result:=exec('count_wyk4zgp','braki',ZGP.ref());
                        _il1+=_result.ILWYK;
                        _il2+=_result.ILWYK_D;
                        {? _il1<_ilmin || _ilmin:=_il1 ?};
                        {? _il1>_ilmax || _ilmax:=_il1 ?};
                        {? _il2<_ilmin_d || _ilmin_d:=_il2 ?};
                        obj_del(_result)

                     ?};
                     _il1:=0;
                     _il2:=0;
                     ZGP.next()
                  !}
               ?};
               ZGH.ILWYK:=_ilmin;
               ZGH.put();
               _ilosc+=_ilmin;
               _ilwtok+=_ilmax;
               _ilosc_d+=_ilmin_d
            ?};
            ZGH.next()
         !}
      ?};
      ZGH.cntx_pop(); ZGP.cntx_pop();
      ZL.ILWYK:=_ilosc;
      ZL.ILWYK_D:=_ilosc_d;
      ZL.put()
   ?}
?};
ZL.cntx_pop();
~~


\odtworz_hwyk
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Odtwarza godziny wykonane na zleceniach - tylko zlecenia otwarte
::  OLD: \odtworz_h/produ.fml
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy odtwarzać dane?'@)
||
:: Zerowanie
   ZL.prefix();
   {? ZL.first()
   || FUN.prg_start(ZL.size(),'Aktualizacja zleceń: zerowanie godzin.'@,,,1);
      {!
      |? FUN.prg_next();
         {? ZL.HIDDEN='N' & ZL.STAN='O'
         || ZL.HWYK:=0;
            ZL.put()
         ?};
         ZL.next()
      !};
      FUN.prg_stop()
   ?};

:: Odtwarzanie
   _names:=ZLGD.names();
   {? _names.first()
   || FUN.prg_start(_names.size(),'Aktualizacja zleceń: nanoszenie godzin.'@,,,1);
      {!
      |? FUN.prg_next();
         {? _names.SIZE<>0
         || ZLGD.use(_names.NAME);
            ZLGD.prefix();
            ZLGD.first();
            {!
            |? {? ZLGD.ZL().HIDDEN='N' & ZLGD.ZL().STAN='O' & ZLGD.ZGP().TPZ='N'
               || ZL.seek(ZLGD.ZL);
                  ZL.HWYK+=ZLGD.TIME_P;
                  ZL.put();
                  {? ZL.NRNZL<>0
                  || ZL.cntx_psh();
                     ZL.index('UNRZL');
                     ZL.prefix(ZL.NRNZL);
                     {? ZL.first()
                     || ZL.HWYK+=ZLGD.TIME_P;
                        ZL.put()
                     ?};
                     ZL.cntx_pop()
                  ?}
               ?};
               ZLGD.next()
            !}
         ?};
         _names.next()
      !};
      FUN.prg_stop()
   ?}
?};
''


\action_zlgd_generate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Generowanie dokumentu raportującego w kontekście rekordu ZLGD
::       - akcja menu okna rejestracji robocizny
::       Umożliwia wygenerowanie dokumentu przypisanego do pozycji robocizny na zaraportowaną ilość
::----------------------------------------------------------------------------------------------------------------------
:: Generowanie od strony ZLGD usunięte w wersji 21.14 i przeniesione na ZGP
~~


\kontr_rob
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.62]
:: OPIS: kontrola rejestracji robocizny
::   WE: ustawione VAR.A_ZLEC = ZL.ref()
::       _a - T: analizować, N: nic nie robić
::       [_b] - parametr wywołania 'A','R',['S']
::       [_c] - tabela z niezgodnościami w rejestracji, jeżeli podana to aktualizowane dane
::   WY: 0: ok, _tab: są niezgodności w rejestracji
::  OLD: \kontr_rob/zlec2.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')=type_of('') || _param:=_b || _param:='S' ?};
{? var_pres('_c')>100 || _aktu:=1; _tab_rob:=_c || _aktu:=0; _tab_rob:=~~ ?};
{? _a='T'
||
   _zl_ref:=$VAR.A_ZLEC;
   _zl_sym:=ZL.SYM;
   _wp:=ZL.TYP().WP;
   {? _wp='P'
   || _xjm:=ZL.KTLZ().XJM;
      {? INFO.SPILW='P'
      || _wp_str_n:='ZGH.ILGEN * ZGP.NTIME / ZGH.ILNPRZ';
         _wp_str_m:='ZGH.ILGEN * ZGP.MTIME / ZGH.ILNPRZ'
      || _wp_str_n:='ZGP.NTIME';
         _wp_str_m:='ZGP.MTIME'
      ?}
   || _xjm:=1;
      _wp_str_n:='ZGP.NTIME';
      _wp_str_m:='ZGP.MTIME'
   ?};
   _przew:={? ZL.NRNZL=0 || 'NRPRZ' || 'NRZLP' ?};
::----------------------------------------------------------------------------------------------------------------------
:: _tab - dane z przewodników
::----------------------------------------------------------------------------------------------------------------------
   _tab:=sql('
      select
         ZGP.REFERENCE REF,
         ZGH.NRPRZ,
         ZGP.NRP POZ,
         ZGP.OPIS,
         case when (:_c)=0 then (:_d) else (:_c) end as TIME_N,
         0/2 as TIME,
         space(1) as DTX,
         space(1) as MTX,
         space(1) as STX,
         space(20) as OTX,
         0/2 as TIME_P,
         space(1) as DPX,
         space(1) as MPX,
         space(1) as SPX,
         space(20) as OPX,
         ZGP.TPZ,
         ''T'' as ZAK
      from ZGP
         join ZGH using(ZGP.:_b, ZGH.REFERENCE)
      where ZGH.ZLEC='':_a''
      order by REF ',
   _zl_ref, _przew, _wp_str_n, _wp_str_m);
   _tab.fld_attr('REF',2);
   _tab.fld_fml('TIME_P','DISPLAY_FORMAT',"_tab:=cur_tab(1,1); {? _tab.TPZ='T' || 'empty=1' || 'empty=0' ?}");
   _tab.fld_fml('OPX','DISPLAY_FORMAT',"_tab:=cur_tab(1,1); {? _tab.TPZ='T' || 'empty=1' || 'empty=0' ?}");
::----------------------------------------------------------------------------------------------------------------------
:: _godz - dane z rejestracji godzin
::----------------------------------------------------------------------------------------------------------------------
   _godz:=sql('
      select
       ZGP.REFERENCE REF,
       ZLGB.TIME,
       ZLGB.TIME_P
      from @ZLGB
       join @ZLGD
        join ZGP
         join ZGH using(ZGP.:_b, ZGH.REFERENCE)
      where ZGH.ZLEC='':_a'' ',
   _zl_ref, _przew );
::----------------------------------------------------------------------------------------------------------------------
:: _start_zgp - operacje rozpoczęte i nie zarejestowane (na e-kioskach do pozycji przewodników)
::----------------------------------------------------------------------------------------------------------------------
   _start_zgp:=sql('
      select
       ZGP.REFERENCE REF
      from @ZLGD
       join ZGP
        join ZGH using(ZGP.:_b, ZGH.REFERENCE)
     where ZGH.ZLEC='':_a'' and ZLGD.ZAK=''N'' ',
   _zl_ref, _przew );
::----------------------------------------------------------------------------------------------------------------------
:: _start_grop - operacje rozpoczęte i nie zarejestowane (na e-kioskach do grup operacji)
::----------------------------------------------------------------------------------------------------------------------
   _start_grop:=sql('
      select
       ZGP.REFERENCE as REF
      from @ZLGD
       join GROP using(ZLGD.GROP, GROP.REFERENCE)
        join GROPP using(GROPP.GROP, GROP.REFERENCE)
         join ZGP using(GROPP.ZGP, ZGP.REFERENCE)
          join ZGH using(ZGP.:_b, ZGH.REFERENCE)
     where ZGH.ZLEC='':_a'' and ZLGD.ZAK=''N'' ',
   _zl_ref, _przew );
::----------------------------------------------------------------------------------------------------------------------
:: naniesienie godzin i rozpoczętych operacji do __TAB
::----------------------------------------------------------------------------------------------------------------------
   {? (type_of(_tab)>100) & (type_of(_godz)>100) & (type_of(_start_zgp)>100) & (type_of(_start_grop)>100)
   || {? _godz.first()
      || {!
         |?
            _tab.prefix(_godz.REF);
            {? _tab.first()
            || _tab.TIME+=_godz.TIME;
               {? _tab.TPZ='N' || _tab.TIME_P+=_godz.TIME_P ?};
               _tab.put()
            ?};
            _godz.next()
         !}
      ?};
      {? _start_zgp.first()
      || {!
         |?
            _tab.prefix(_start_zgp.REF);
            {? _tab.first()
            || _tab.ZAK:='N';
               _tab.put()
            ?};
            _start_zgp.next()
         !}
      ?};
      {? _start_grop.first()
      || {!
         |?
            _tab.prefix(_start_grop.REF);
            {? _tab.first()
            || _tab.ZAK:='N';
               _tab.put()
            ?};
            _start_grop.next()
         !}
      ?};
::----------------------------------------------------------------------------------------------------------------------
:: Naniesienie znaczników i usunięcie rekordów zgodnych
::----------------------------------------------------------------------------------------------------------------------
      _tab.prefix();
      {? _tab.first()
      || {!
         |?
            {? _tab.TIME>_tab.TIME_N || _tab.DTX:='X'
            |? _tab.TIME<_tab.TIME_N || _tab.MTX:='X'
            ?};
            _tab.STX:={? _tab.DTX='X' || 'D' |? _tab.MTX='X' || 'M' || 'N' ?};
            _tab.OTX:={? _tab.DTX='X' || 'Przekroczenie'@ |? _tab.MTX='X' || 'Niedobór'@ || 'Zgodnie z normą'@ ?};
            {? _tab.TIME_P>_tab.TIME_N || _tab.DPX:='X'
            |? _tab.TIME_P<_tab.TIME_N || _tab.MPX:='X'
            ?};
            _tab.SPX:={? _tab.DPX='X' || 'D' |? _tab.MPX='X' || 'M' || 'N' ?};
            _tab.OPX:={? _tab.DPX='X' || 'Przekroczenie'@ |? _tab.MPX='X' || 'Niedobór'@ || 'Zgodnie z normą'@ ?};
            {? _tab.ZAK='T' &
               {? _tab.TPZ='N'
               || _tab.TIME_N$4=_tab.TIME$4 & _tab.TIME_N$4=_tab.TIME_P$4
               || _tab.TIME_N$4=_tab.TIME$4
               ?}
            || _tab.del()
            || _tab.put();
               _tab.next()
            ?}
         !}
      ?};
::    Przepisanie danych do tabeli docelowej w przypadku aktualizacji danych
      {? _aktu>0
      ||
::       Zapamiętanie refa, do którego ZGP wrócić
         _zgp:=_tab_rob.REF;
         exec('tab2tab','#table',_tab,_tab_rob,0,1);
         _tab_rob.find_tab(,'REF',,'=',_zgp)
      ?};
::----------------------------------------------------------------------------------------------------------------------
      {? _tab.first() & _aktu=0
      ||
         _wer:=_tab.mk_sel('Niezgodności rejestracji godzin'@,'N',0,'zlec2_rob_sel',,,,,'U');
         _tab.win_fld(_wer,,'NRPRZ',,,,,,'Przewodnik'@);
         _tab.win_fld(_wer,,'POZ',,,-4,,,'Pozycja'@);
         _tab.win_fld(_wer,,'TPZ',,,3,,,'TPZ',,,2,,"'T'","'N'");
         _tab.win_fld(_wer,,'TIME_N',,,-15,4,,'Norma'@);
         _tab.win_fld(_wer,,'TIME',,,-15,4,,'Czas faktyczny'@);
::         _tab.win_fld(_wer,,'MTX',,,3,,,'M?'@,,'Czas realizacji mniejszy niż planowano'@,2,,"'X'","''");
::         _tab.win_fld(_wer,,'DTX',,,3,,,'D?'@,,'Czas realizacji większy niż planowano'@,2,,"'X'","''");
         _tab.win_fld(_wer,,'OTX',,,20,,,'Status'@);
         _tab.win_fld(_wer,,'TIME_P',,,-15,4,,'Czas prognozowany'@);
::         _tab.win_fld(_wer,,'MPX',,,3,,,'M?'@,,'Czas realizacji mniejszy niż planowano'@,2,,"'X'","''");
::         _tab.win_fld(_wer,,'DPX',,,3,,,'D?'@,,'Czas realizacji większy niż planowano'@,2,,"'X'","''");
         _tab.win_fld(_wer,,'OPX',,,20,,,'Status'@);
         _tab.win_fld(_wer,,'ZAK',,,-3,,,'Zakończone'@,,,2,,"'T'","'N'");
         _tab.win_act(_wer,0,'Rekord',,,,
            "_tab:=cur_tab(1,1); {? _tab.TIME=0 | _tab.TPZ='N' & _tab.TIME_P=0 || Color.rekprzed('__TABX#01#01') || '' ?}"
         );
         {? _param='R'
         || _tab.win_act(_wer,,'Formuła','Zamknij zlecenie'@@,,'Zamknij zlecenie mimo niezgodności'@,"sel_exit()"
               ,,1,,,,'Z',,'target=window')
         ?};
         _tab.win_act(_wer,,'Formuła','Rejestracja'@@,,'Rejestracja produkcji'@,"exec('rej_zgp_pr','zl_wyk',0)"
               ,"exec('kontr_rob','zl_wyk','T',,cur_tab(1,1))",,1
               ,"exec('rej_zgp_gpr','zl_wyk',0)","exec('kontr_rob','zl_wyk','T',,cur_tab(1,1))",'R',,'target=record');
         task_attach('TTE_WYK_DWZL');

         _formula:="
            exec('pozrap','magdok_prod',1,0,1,,1);
            exec('kontr_rob','zl_wyk','T',,cur_tab(1,1));
            VAR.RFR_DOK:=1;
            ~~
         ";
         _tab.win_act(_wer,,'Formuła','&Dokumenty magazynowe'@@,'','Podgląd i rejestracja dokumentów magazynowych'@
            ,_formula,,,,,,'D');

         _tab.win_act(_wer,,'Formuła','Druku&j'@@,,, "params_set(params_get()); rep_exec('tte_rapzmkzl',,1)"
            ,,{? _param='R' || 0 || 1 ?},,,,'J',,'target=window,icon=print');
         _tab.win_act(_wer,,'Formuła','Legenda'@@,,,"exec('legenda','color','__TABX#01#01')",,,,,,'L',,'target=window');
         _tab.win_btn(_wer,'text=%1,panel=bottom,align=begin'['Druku&j'@],'menu:J');
         {? _param='R'
         || _tab.win_btn(_wer,'text=%1,panel=bottom,align=end'['Zamknij zlecenie'@],'menu:Z')
         ?};
         _tab.win_sel(_wer);
         _red:=_tab.mk_edit('Rejestracja godzin'@,0,'zlec2_rob_edit');
         _tab.win_esep(_red,'Operacja'@);
         _tab.win_efld(_red,,'NRPRZ',,,,,,'Przewodnik'@);
         _tab.win_efld(_red,,'POZ',,,5,,,'Pozycja'@);
         _tab.win_efld(_red,,'OPIS',,,50,,,'Opis operacji'@);
         _tab.win_esep(_red,'Rozliczenie'@);
         _tab.win_efld(_red,,'TIME_N',,,15,4,,'Norma'@);
         _tab.win_efld(_red,,'TIME',,,15,4,,'Czas faktyczny'@);
::         _tab.win_efld(_red,,'MTX',,,2,,,'Poniżej normy'@,,,
::            'check-box','check_label="%1"'['Czas realizacji mniejszy niż planowano'@],"'X'","''"
::         );
::         _tab.win_efld(_red,,'DTX',,,2,,,'Przekroczenie normy'@,,,
::            'check-box','check_label="%1"'['Czas realizacji większy niż planowano'@],"'X'","''"
::         );
         _tab.win_efld(_red,,'STX',,,,,,'Status'@,,,'radio-buttons',,
            'Przekroczenie normy'@,"'D'",
::            'Zgodnie z normą'@,"'N'",
            'Poniżej normy'@,"'M'"
         );
         _tab.win_efld(_red,,'TIME_P',,,15,4,,'Czas prognozowany'@);
::         _tab.win_efld(_red,,'MPX',,,2,,,'Poniżej normy'@,,,
::            'check-box','check_label="%1"'['Czas realizacji mniejszy niż planowano'@],"'X'","''"
::         );
::         _tab.win_efld(_red,,'DPX',,,2,,,'Przekroczenie normy'@,,,
::            'check-box','check_label="%1"'['Czas realizacji większy niż planowano'@],"'X'","''"
::         );
         _tab.win_efld(_red,,'SPX',,,,,,'Status'@,,,'radio-buttons',,
            'Przekroczenie normy'@,"'D'",
::            'Zgodnie z normą'@,"'N'",
            'Poniżej normy'@,"'M'"
         );
         _tab.win_efld(_red,,'ZAK',,,,,,'Zakończone?'@,,,'check-box',
            'check_label="%1"'['Wszystkie rozpoczęte operacje zostały zakończone'@],"'T'","'N'"
         );
         _tab.win_edit(_red);
::----------------------------------------------------------------------------------------------------------------------
:: Wynik formuły - jeśli są jakieś rekordy, to niedobrze
::----------------------------------------------------------------------------------------------------------------------
         _res:=obj_new(2);
         _res[1]:=_tab;
         _res[2]:=_wer;
         _res
      || 0
      ?}
   || exec('err_sql','#sql');
      0
   ?}
|| 0
?}


\kontr_ilo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.62]
:: OPIS: kontrola rejestracji ilości na przewodnikach
::   WE: ustawione VAR.A_ZLEC = ZL.ref()
::       _a - T: analizować, N: nic nie robić
::       [_b] - parametr wywołania 'A','R','S'
::       [_c] - tabela z niezgodnościami w rejestracji, jeżeli podana to aktualizowane dane
::   WY: 0: ok, _tab: sa niezgodności w rejestracji
::  OLD: \kontr_ilo/zlec2.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')=type_of('') || _param:=_b || _param:='S' ?};
{? var_pres('_c')>100 || _aktu:=1; _tab_rob:=_c || _aktu:=0; _tab_rob:=~~ ?};

{? _a='T'
||
   _zl_sym:=ZL.SYM;
::----------------------------------------------------------------------------------------------------------------------
:: _tab - dane z przewodników
::----------------------------------------------------------------------------------------------------------------------
   _tab:=tab_tmp(2,
      'NRPRZ','STRING[20]','Nr przewodnika',
      'POZ','INTEGER','Pozycja przewodnika',
      'OPIS','STRING[60]','Opis',
      'ILNPRZ','REAL','Ilość na przewodniku',
      'ILOSC','REAL','Ilość zarejestrowana - dobre',
      'IL_BRAK','REAL','Ilość zarejestrowana - braki',
      'IL_KOOP','REAL','Ilość w kooperacji',
      'DX','STRING[1]','Za dużo',
      'MX','STRING[1]','Za mało',
      'SX','STRING[1]','Status',
      'OX','STRING[20]','Status opisowo',
      'REF','STRING[16]','$ZGP.ref()'
   );
   ZGH.index('ZLNR');
   ZGH.prefix(VAR.A_ZLEC);
   {? ZGH.first()
   || {!
      |?
         {? ZGH.KIND<>'T'
         || ZGH.cntx_psh();
            {? ZL.NRNZL=0 || ZGP.index('NRPP') || ZGP.index('PNRPP') ?};
            ZGP.prefix(ZGH.ref(),'N');
            {? ZGP.first()
            || {!
               |? _tab.blank();
                  _tab.REF:=$ZGP.ref();
                  _tab.NRPRZ:=ZGP.NRZLP().NRPRZ;
                  _tab.POZ:=ZGP.NRP;
                  _tab.OPIS:=ZGP.OPIS;
                  _tab.ILNPRZ:=ZGP.ILOSC;
                  _tab.ILOSC:=ZGP.IL+exec('count_wyk4zgp','braki',ZGP.ref()).ILWYK;
                  _tab.IL_BRAK:=ZGP.IL_BRAK;
                  _tab.IL_KOOP:=ZGP.IL_KOOP;
                  {? _tab.ILNPRZ<>_tab.ILOSC | _tab.IL_KOOP>0
                  || {? _tab.ILNPRZ < _tab.ILOSC
                     || _tab.DX:='X';
                        _tab.SX:='D';
                        _tab.OX:='Przekroczenie'@
                     |? _tab.ILNPRZ > _tab.ILOSC
                     || _tab.MX:='X';
                        _tab.SX:='M';
                        _tab.OX:='Niedobór'@
                     || _tab.SX:='N';
                        _tab.OX:='Zgodnie z planem'@
                     ?};
                     _tab.add()
                  ?};
                  ZGP.next()
               !}
            ?};
            ZGH.cntx_pop()
         ?};
         ZGH.next()
      !}
   ?};
:: Przepisanie danych do tabeli docelowej w przypadku aktualizacji danych
   {? _aktu>0
   ||
::    Zapamiętanie refa, do którego ZGP wrócić
      _zgp:=_tab_rob.REF;
      exec('tab2tab','#table',_tab,_tab_rob,0,1);
      _tab_rob.find_tab(,'REF',,'=',_zgp)
   ?};
::----------------------------------------------------------------------------------------------------------------------
   {? _tab.first() & _aktu=0
   ||
      _wer:=_tab.mk_sel('Niezgodności rejestracji ilości'@,'N',0,'zlec2_ilo_sel',,,,,'U');
      _tab.win_fld(_wer,,'NRPRZ',,,,,,'Przewodnik'@);
      _tab.win_fld(_wer,,'POZ',,,-4,,,'Pozycja'@);
      _tab.win_fld(_wer,,'ILNPRZ',,,-15,4,,'Ilość na przewodniku'@);
      _tab.win_fld(_wer,,'IL_KOOP',,,-15,4,,'Ilość w kooperacji'@);
      _tab.win_fld(_wer,,'ILOSC',,,-15,4,,'Ilość zarejestrowana'@);
::      _tab.win_fld(_wer,,'MX',,,,,,'M?'@,,'Zarejestrowano mniej niż planowano'@,2,,"'X'","''");
::      _tab.win_fld(_wer,,'DX',,,,,,'D?'@,,'Zarejestrowano więcej niż planowano'@,2,,"'X'","''");
      _tab.win_fld(_wer,,'OX',,,20,,,'Status'@);
      _tab.win_act(_wer,0,'Rekord',,,,
         "{? cur_tab(1,1).ILOSC=0 & cur_tab(1,1).IL_KOOP=0 || Color.rekprzed('__TABX#01#01') || '' ?}"
      );
      {? _param='R'
      || _tab.win_act(_wer,,'Formuła','Zamknij zlecenie'@@,,'Zamknij zlecenie mimo niezgodności'@,"sel_exit()"
            ,,1,,,,'Z',,'target=window')
      ?};
      _tab.win_act(_wer,,'Formuła','Rejestracja'@@,,'Rejestracja produkcji'@,"exec('rej_zgp_pr','zl_wyk',0)"
         ,"exec('kontr_ilo','zl_wyk','T',,cur_tab(1,1))",,1
         ,"exec('rej_zgp_gpr','zl_wyk',0)","exec('kontr_ilo','zl_wyk','T',,cur_tab(1,1))",'R',,'target=record');
      task_attach('TTE_WYK_DWZL');

      _formula:="
            exec('pozrap','magdok_prod',1,0,1,,1);
            exec('kontr_ilo','zl_wyk','T',,cur_tab(1,1));
            VAR.RFR_DOK:=1;
            ~~
         ";
      _tab.win_act(_wer,,'Formuła','&Dokumenty magazynowe'@@,'','Podgląd i rejestracja dokumentów magazynowych'@
         ,_formula,,,,,,'D');

      _tab.win_act(_wer,,'Formuła','Druku&j'@@,,,"params_set(params_get()); rep_exec('tte_rapzmkzl',,1)"
         ,,{? _param='R' || 0 || 1 ?},,,,'J',,'target=window,icon=print');
      _tab.win_act(_wer,,'Formuła','Legenda'@@,,,"exec('legenda','color','__TABX#01#01')",,,,,,'L',,'target=window');
      _tab.win_btn(_wer,'text=%1,panel=bottom,align=begin'['Druku&j'@],'menu:J');
      {? _param='R'
      || _tab.win_btn(_wer,'text=%1,panel=bottom,align=end'['Zamknij zlecenie'@],'menu:Z')
      ?};
      _tab.win_sel(_wer);
      _red:=_tab.mk_edit('Ilości na przewodniku'@,0,'zlec2_ilo_edit');
      _tab.win_esep(_red,'Operacja'@);
      _tab.win_efld(_red,,'NRPRZ',,,,,,'Przewodnik'@);
      _tab.win_efld(_red,,'POZ',,,5,,,'Pozycja'@);
      _tab.win_efld(_red,,'OPIS',,,50,,,'Opis operacji'@);
      _tab.win_esep(_red,'Rozliczenie'@);
      _tab.win_efld(_red,,'ILNPRZ',,,,4,,'Ilość na przewodniku'@);
      _tab.win_efld(_red,,'IL_KOOP',,,,4,,'Ilość w kooperacji'@);
      _tab.win_efld(_red,,'ILOSC',,,,4,,'Ilość zarejestrowana'@);
::      _tab.win_efld(_red,,'MX',,,2,,,'Niedobór'@,,,
::         'check-box','check_label="%1"'['Zarejestrowano mniej niż planowano'@],"'X'","''"
::      );
::      _tab.win_efld(_red,,'DX',,,2,,,'Przekroczenie'@,,,
::         'check-box','check_label="%1"'['Zarejestrowano więcej niż planowano'@],"'X'","''"
::      );
      _tab.win_efld(_red,,'SX',,,,,,'Status'@,,,'radio-buttons',,
         'Przekroczenie'@,"'D'",
::         'Zgodnie z planem'@,"'N'",
         'Niedobór'@,"'M'"
      );
      _tab.win_edit(_red);
::----------------------------------------------------------------------------------------------------------------------
:: Wynik formuły - jeśli są jakieś rekordy, to niedobrze
::----------------------------------------------------------------------------------------------------------------------
      _res:=obj_new(2);
      _res[1]:=_tab;
      _res[2]:=_wer;
      _res
   || 0
   ?}
|| 0
?}


\zlgd_efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Opcje pól dla tabeli ZLGD
::----------------------------------------------------------------------------------------------------------------------
_enable:={? ZLGD.ZL().TYP().WP='W' || 'enable=0' || 'enable=1' ?};
ZLGD.efld_opt('RED',_enable,,'IL');
ZLGD.efld_opt('RED',_enable,,'IL_BRAK');
ZLGD.efld_opt('RED',_enable,ZGH,'ILNPRZ');
ZLGD.efld_opt('RED',_enable,,'KAP','IL');
ZLGD.efld_opt('RED_B',_enable,,'IL');
ZLGD.efld_opt('RED_B',_enable,,'IL_BRAK');
ZLGD.efld_opt('RED_B',_enable,ZGH,'ILNPRZ');
ZLGD.efld_opt('RED_B',_enable,,'KAP','IL');
ZLGD.efld_opt('RED_P',_enable,,'IL');
ZLGD.efld_opt('RED_P',_enable,,'IL_BRAK');
ZLGD.efld_opt('RED_P',_enable,ZGH,'ILNPRZ');
ZLGD.efld_opt('RED_P',_enable,,'KAP','IL');
ZLGD.efld_opt('RED_PR',_enable,,'IL');
ZLGD.efld_opt('RED_PR',_enable,,'IL_BRAK');
ZLGD.efld_opt('RED_PR',_enable,ZGH,'ILNPRZ');
ZLGD.efld_opt('RED_PR',_enable,,'KAP','IL');

ZLGD.efld_opt('RED_P',{? ZLGD.ZGP().TPZ='T' | ZLGD.ZL().TYP().WP='W' || 'mark=0' || 'mark=1' ?},VAR1,'IL');
ZLGD.efld_opt('RED_P',{? ZLGD.ZGP().TPZ='T' | ZLGD.ZL().TYP().WP='W' || 'mark=0' || 'mark=1' ?},VAR1,'IL_BRAK');
ZLGD.efld_opt('RED_P','mark=1',,'TIME');

ZLGD.efld_opt('RED_PR',{? ZLGD.ZGP().TPZ='T'| ZLGD.ZL().TYP().WP='W' || 'mark=0' || 'mark=1' ?},VAR1,'IL');
ZLGD.efld_opt('RED_PR',{? ZLGD.ZGP().TPZ='T'| ZLGD.ZL().TYP().WP='W' || 'mark=0' || 'mark=1' ?},VAR1,'IL_BRAK');
ZLGD.efld_opt('RED_PR','mark=1',,'TIME');

_partia_mark:='mark=0';
{? exec('party_req','zl_wyk',ZLGD.ZL)>0
|| _partia_mark:='mark=1'
?};
ZLGD.efld_opt('RED',_partia_mark,,'ZPARN');
ZLGD.efld_opt('RED_B',_partia_mark,,'ZPARN');
ZLGD.efld_opt('RED_P',_partia_mark,,'ZPARN');
ZLGD.efld_opt('RED_PR',_partia_mark,,'ZPARN');

_braki_r_mark:='mark=0';
{? VAR1.IL_BRAK>0 & exec('get','#params',500635,2)='T'
|| _braki_r_mark:='mark=1'
?};
{? VAR1.KN2='T'
||
:: Kwalifikacja ilośći (kontrola jakości)
   ZLGD.efld_opt('KWALIFIK',_braki_r_mark,,'BRAKI_R');
   ZLGD.efld_opt('KWALIF_O',_braki_r_mark,,'BRAKI_R');
   ZLGD.efld_opt('KWAL_KJ',_braki_r_mark,,'BRAKI_R')
|| ZLGD.efld_opt('RED',_braki_r_mark,VAR1,'BRAKI_R');
   ZLGD.efld_opt('RED_B',_braki_r_mark,VAR1,'BRAKI_R');
   ZLGD.efld_opt('RED_P',_braki_r_mark,VAR1,'BRAKI_R');
   ZLGD.efld_opt('RED_PR',_braki_r_mark,VAR1,'BRAKI_R');
   ZLGD.efld_opt('RED_WRK',_braki_r_mark,VAR1,'BRAKI_R');
   ZLGD.efld_opt('RED_WRKR',_braki_r_mark,VAR1,'BRAKI_R');
   ZLGD.efld_opt('ZL_WYR',_braki_r_mark,VAR1,'BRAKI_R')
?};
~~


\zlgb_efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Opcje pól dla tabeli ZLGB
::----------------------------------------------------------------------------------------------------------------------
_enable:=
   {? exec('get','#params',500600,2)='T'
      | (ZLGD.IL=0 & ZLGD.IL_BRAK=0 & ZLGD.DEK_IL=0 & ZLGD.DEK_BR=0)
      | ZLGD.ZGP().TPZ='T'
      | ZGP.NRZLP().ZLEC().TYP().WP='W'
   || 'enable=0'
   || 'enable=1'
   ?};
ZLGB.efld_opt('RED',_enable,VAR1,'BIL');
ZLGB.efld_opt('RED',_enable,VAR1,'BIL_BRAK');
~~


\auto_zlgd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Trigger po add(), put(), przed del() w tabeli PL_WYK. Automatycznie aktualizuje ZLGD/ZLGB
::   WE: _a - rodzaj triggera: 'add', 'put', 'del'
::  OLD: \auto_zlgd/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('get','#params',500621,2)='Z' | PL_WYK.PL_OPER().ZGP().SRW='M'
||
:: Jezeli aktualizacja ZL->PL lub rozliczenie kooperacji 'magazynowe', to trigger nic nie robi
   {? _a='del' || 1 || ~~ ?}
||
:: Aktualizacja PL->ZL i rozliczenie kooperacji 'standardowe'
   {? _a='add' | _a='put'
   ||
::    'add' - dodanie zapisu w PX_WYK, jezeli od razu ma "koniec" - PL_WYK.ENDD<>null()
::    'put' - zakonczenie operacji, czyli aktualizacja zapisu w PX_WYK,
::    pod warunkiem, ze PL_WYK dostaje "koniec" - PL_WYK.ENDD bylo null a juz nie jest
      {? PL_WYK.PL_OPER<>null() &
         (  _a='add' & PL_WYK.ENDD<>null()
               |
            _a='put' & bfld('ENDD')=null() & PL_WYK.ENDD<>null()
               |
            _a='put' & bfld('IL_WYK')<>PL_WYK.IL_WYK
               |
            _a='put' & bfld('ZLBR')<>PL_WYK.ZLBR
               |
            _a='put' & bfld('OS_VIEW')<>PL_WYK.OS_VIEW
               |
            _a='put' & bfld('OK')<>PL_WYK.OK
               |
            _a='put' & bfld('PLACE')<>PL_WYK.PLACE
         )
      ||
::       Podczytanie powiazanych rekordow
         PL_WYK.PL_OPER().ZGP().NRZLP();

::       add czy update?
         ZLGD.index('PL_WYK');
         ZLGD.prefix(PL_WYK.UID);
         {? ZLGD.first()
         || _update:=1
         || _update:=0
         ?};

::       Walidacja
         {? ~_update
         ||
            {? ZGP.PROBLEM='T'
            || undo('Do powiązanej operacji przewodnika (%1 - %2) zgłoszono problem.'@[ZGH.NRPRZ,$ZGP.NRP])
            |? ZGP.STATUS=exec('status_end','zl_guide')
            || undo('Powiązana operacja przewodnika (%1 - %2) oznaczona jako zakończona.'@[ZGH.NRPRZ,$ZGP.NRP])
            |? ZGH.ZLEC().STAN<>'O'
            || undo('Powiązana operacja przewodnika (%1 - %2) nie dotyczy otwartego zlecenia.'@[ZGH.NRPRZ,$ZGP.NRP])
            ?}
         ?};
         {? do_state()<>2
         ||
::          Pojedyncza operacja
            _args:=exec('add_akord_a','zl_wyk');
            {? PL_WYK.TP='T'
            || _args.ZGP:=exec('tpz_ref','zl_guide',PL_WYK.PL_OPER().ZGP)
            || _args.ZGP:=PL_WYK.PL_OPER().ZGP
            ?};
::          Operacja tylko z czasem maszynowym
            {? PL_WYK.TP<>'T' &  PL_WYK.PL_OPER<>null() & PL_WYK.PL_OPER().ZGP().NTIME=0
            || _args.P:=null();
               _args.ZLBR:=null()
            || _args.P:=PL_WYK.P;
               _args.ZLBR:=PL_WYK.ZLBR
            ?};
            _args.DT:=PL_WYK.STARTD().DATA;
            {? PL_WYK.TP='T' | ZGP.KJ_BAD='N'
            || _args.IL_DEKL:='N';
               _args.IL:=PL_WYK.IL_WYK;
               _args.IL_BRAK:=PL_WYK.IL_BRAK
            || _args.IL_DEKL:='T';
               _args.IL:=PL_WYK.DEK_IL;
               _args.IL_BRAK:=PL_WYK.DEK_BR
            ?};
            _args.TIME:=(PL_WYK.TM_END-PL_WYK.TM_START)/exec('minute','#tm_stamp')/60;
            _args.STARTD:=PL_WYK.STARTD().DATA;
            _args.STARTT:=PL_WYK.STARTT;
            _args.ENDD:=PL_WYK.ENDD().DATA;
            _args.ENDT:=PL_WYK.ENDT;
            _args.ZMIANA:=exec('zmiana','zl_common',_args.STARTT);
            _args.AUTO:='T';
            _args.PL_WYK:=PL_WYK.UID;
            _args.OK:=PL_WYK.OK;
            _args.PLACE:=PL_WYK.PLACE;
            {? PL_WYK.ZPARN<>null()
            ||
::          Jesli partia na PL_WYKU podana to ja tu wykorzystuje
::          zeby ja wpisac rowniez do ZLGD
               _args.ZPARN:=PL_WYK.ZPARN
            ?};
            ZLGD.index('PL_WYK');
            ZLGD.prefix(PL_WYK.UID);

            {? _update
            || exec('update_akord','zl_wyk',_args)
            || exec('add_akord','zl_wyk',_args)
            ?}
         ?}

      |? PL_WYK.PL_OGR<>null() & _a='put'
      ||
::       Grupa operacji - generowanie zapisow dopiero jezeli operacja potwierdzona, usuwanie jak usuniecie potwierdzenia
         _potw:=bfld('POTW');
         {? _potw='N' & PL_WYK.POTW='T'
         ||
            _timedok:=exec('get','#params',500604,1);

            _args:=exec('add_akord_a','zl_wyk');

            Cntx.psh(GROP,GROPP);
            Cntx.clr(GROP,GROPP);
            ProdRej.GROPP.TAB.clear();
            ProdRej.GROPP.TAB.index(ProdRej.GROPP.NdxPoz);

::          Podczytanie powiazanych rekordow
            PL_WYK.PL_OGR().GROP();

            GROPP.index('GROP');
            GROPP.prefix(GROP.ref());
            {? GROPP.first()
            || {!
               |?
::                Podczytanie powiazanych rekordow
                  GROPP.ZGP().NRZLP();
::                Walidacja
                  {? ZGP.PROBLEM='T'
                  || undo('Do powiązanej operacji przewodnika (%1 - %2) zgłoszono problem.'@[ZGH.NRPRZ,$ZGP.NRP])
                  |? ZGP.STATUS=exec('status_end','zl_guide')
                  || undo('Powiązana operacja przewodnika (%1 - %2) oznaczona jako zakończona.'@[ZGH.NRPRZ,$ZGP.NRP])
                  |? ZGH.ZLEC().STAN<>'O'
                  || undo('Powiązana operacja przewodnika (%1 - %2) nie dotyczy otwartego zlecenia.'@[ZGH.NRPRZ,$ZGP.NRP])
                  ?};
                  {? do_state()<>2
                  ||
                     ProdRej.GROPP.TAB.prefix(#GROPP.ref());
                     {? ProdRej.GROPP.TAB.first()
                     ||
                        _args.ZGP:=GROPP.ZGP;
                        _args.P:=PL_WYK.P;
                        _args.ZLBR:=PL_WYK.ZLBR;
                        _args.DT:=PL_WYK.STARTD().DATA;
                        _args.STARTD:=PL_WYK.STARTD().DATA;
                        _args.STARTT:=PL_WYK.STARTT;
                        _args.ENDD:=PL_WYK.ENDD().DATA;
                        _args.ENDT:=PL_WYK.ENDT;
                        _args.ZMIANA:=exec('zmiana','zl_common',_args.STARTT);
                        _args.IL:=ProdRej.GROPP.TAB.IL_WYK;
                        _args.IL_BRAK:=ProdRej.GROPP.TAB.IL-ProdRej.GROPP.TAB.IL_WYK;
                        _args.TIME:=(ProdRej.GROPP.TAB.CZASM/60)$_timedok;
::                     (PL_WYK.TM_END-PL_WYK.TM_START)/exec('minute','#tm_stamp')/60;
                        _args.AUTO:='T';
                        _args.PL_WYK:=PL_WYK.UID;
                        _args.OK:=PL_WYK.OK;
                        _args.PLACE:=PL_WYK.PLACE;
                        _args.ZPARN:=null();

                        _party_req:=exec('party_req','zl_wyk',GROPP.ZL);
                        {? _party_req>0
                        ||
::                      Przypisuje partię z rozpiski (jeżeli była)
                           {? ProdRej.GROPP.TAB.ZPARN>0
                           || _args.ZPARN:=exec('FindAndGet','#table',ZPARN,ProdRej.GROPP.TAB.ZPARN,,"ZPARN.ref",null)
                           ||
::                         Sprawdzam czy przewodnik posiada dokladnie jedna partie, wtedy moge
::                         przekazac dalej ta partie i nie pytac o nia podczas rejestracji dokumentu
                              ZPARN.cntx_psh();
                              ZPARN.index('ZGH');
                              _party_zgh:=exec('party_first_zgh','zl_guide',GROPP.ZGP().NRZLP);
                              {? _party_zgh<>null()
                              || ZPARN.prefix(_party_zgh);
                                 {? ZPARN.size()=1
                                 || {? ZPARN.first()
                                    || _args.ZPARN:=ZPARN.ref()
                                    ?}
                                 ?}
                              ?};
                              ZPARN.cntx_pop();
                              ~~
                           ?}
                        ?};

                        ZLGD.index('PL_WYK');
                        ZLGD.prefix(PL_WYK.UID,GROPP.ZGP);
                        {? ZLGD.first()
                        ||
                           exec('update_akord','zl_wyk',_args)
                        || VPRODREJ.AUTO:='N';
                           exec('add_akord','zl_wyk',_args)
                        ?}
                     ?}
                  ?};
                  GROPP.next()
               !}
            ?};

            Cntx.pop(GROP,GROPP)

         |? _potw='T' & PL_WYK.POTW='N'
         ||
::          Usuniecie ZLGD/ZLGB
            ZLGD.index('PL_WYK');
            ZLGD.prefix(PL_WYK.UID);
            {? ZLGD.first()
            || {!
               |? ZLGB.index('ZLGD');
                  ZLGB.prefix(ZLGD.ref());
                  {? ZLGB.first()
                  || {! |? ZLGB.del() !}
                  ?};

                  ZL.cntx_psh();
                  ZL.clear();
                  {? ZL.seek(ZLGD.ZL)
                  || {? ZLGD.ZGP().TPZ='N' || ZL.HWYK-=ZLGD.TIME_P ?};
                     ZL.put();
                     {? ZL.NRNZL<>0
                     || ZL.cntx_psh();
                        ZL.index('UNRZL');
                        ZL.prefix(ZL.NRNZL);
                        {? ZL.first()
                        || {? ZLGD.ZGP().TPZ='N' || ZL.HWYK-=ZLGD.TIME_P ?};
                           ZL.put()
                        ?};
                        ZL.cntx_pop()
                     ?}
                  ?};
                  ZL.cntx_pop();

                  exec('del4ZLGD','statexam');
                  exec('del4ZLGD','zl_limit');
                  exec('del4ZLGD','zl_wyr');
                  ZLGD.del()
               !}
            ?};
::          Inne przyczyny niemoznosci usuniecia robocizny?
            _res:=~ZLGD.first();
            {? ~_res || KOMM.add('Nie można usunąć powiązanych zapisów robocizny.',,,1) ?}
         ?}
      ?};
      ~~
   |? _a='del'
   ||
::    Usuniecie ZLGD/ZLGB
      ZLGD.index('PL_WYK');
      ZLGD.prefix(PL_WYK.UID);
      {? ZLGD.first()
      || {!
         |? ZLGB.index('ZLGD');
            ZLGB.prefix(ZLGD.ref());
            {? ZLGB.first()
            || {! |? ZLGB.del() !}
            ?};

            ZL.cntx_psh();
            ZL.clear();
            {? ZL.seek(ZLGD.ZL)
            || {? ZLGD.ZGP().TPZ='N' || ZL.HWYK-=ZLGD.TIME_P ?};
               ZL.put();
               {? ZL.NRNZL<>0
               || ZL.cntx_psh();
                  ZL.index('UNRZL');
                  ZL.prefix(ZL.NRNZL);
                  {? ZL.first()
                  || {? ZLGD.ZGP().TPZ='N' || ZL.HWYK-=ZLGD.TIME_P ?};
                     ZL.put()
                  ?};
                  ZL.cntx_pop()
               ?}
            ?};
            ZL.cntx_pop();

            exec('del4ZLGD','statexam');
            exec('del4ZLGD','zl_limit');
            exec('del4ZLGD','zl_wyr');
            ZLGD.del()
         !}
      ?};
::    Inne przyczyny niemoznosci usuniecia robocizny?
      _res:=~ZLGD.first();
      {? ~_res || KOMM.add('Nie można usunąć powiązanych zapisów robocizny.',,,1) ?};
      _res
   ?}
?}


\zlgd_varfld_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Przed wyświetl dla pól VAR1.IL, VAR1.IL_BRAK umieszczanych w oknie tabeli ZLGD
::  OLD: \zlgd_varfld_bd/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\zlgd_varfld_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Przed redakcją dla pól VAR1.IL, VAR1.IL_BRAK umieszczanych w oknie tabeli ZLGD
::  OLD: \zlgd_varfld_be/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
exec('p_red_zi','zl_wyk')


\zlgd_varfld_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Po redakcji dla pól VAR1.IL, VAR1.IL_BRAK umieszczanych w oknie tabeli ZLGD
::  OLD: \zlgd_varfld_ae/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
exec('po_zg_is','zl_wyk')


\zlgd_varfld_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Format wyświetlania dla pól VAR1.IL, VAR1.IL_BRAK umieszczanych w oknie tabeli ZLGD
::  OLD: \zlgd_varfld_fd/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('FindAndGet','#table',ZGP,ZLGD.ZGP,,"ZGP.TPZ='T'",0) || 'empty=1' || 'empty=0' ?}


\zlgd_varfld_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Format redagowania dla pól VAR1.IL, VAR1.IL_BRAK umieszczanych w oknie tabeli ZLGD
::  OLD: \zlgd_varfld_fe/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
''


\zlgd_kwalifik
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Kwalifikacja jakościowa zapisu robocizny. Działa w kontekście aktywnego badania.
::   WE: [_a] - STRING - sposób zasilania ilości w oknie:
::                                                      ['P'] - pozytywnie, cała ilość dobrych deklarowana przez
::                                                              pracownika jest przepisywana w oknie w pole dobre
::                                                       'N'  - negatywnie, cała ilość dobrych i złych deklarowana
::                                                              przez pracownika jest przepiwywana w oknie w pole braków
::       [_b] - INTEGER - 0/[1] - czy sprawdzać czy badanie do ZLGD zostało ostatecznie zatwierdzone
::       [_c] - INTEGER - [0]/1 - czy uruchomione dla badań z obszaru Kontrola jakości
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \zlgd_kwalifik/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_mode:='P';
{? var_pres('_a')=type_of('')
|| _mode:=_a
?};
_chk_akc:=1;
{? var_pres('_b')=type_of(0)
|| _chk_akc:=_b
?};
_kj_area:=0;
{? var_pres('_c')=type_of(0)
|| _kj_area:=_c
?};

_result:=0;
_can_continue:=1;

_kj_bad:=ZLGD.ZGP().KJ_BAD;
BADH.cntx_psh();
{? _kj_bad<>'P' & _kj_bad<>'B' & (ZLGD.BADH<>null & ZLGD.BADH().AUTO<>'N')
|| FUN.info('Zapis nie podlega kwalifikacji jakościowej.'@);
   _can_continue:=0
?};
BADH.cntx_pop();
{? _can_continue>0
|| BADH.cntx_psh();
   ZLGD.cntx_psh();
   {? ZLGD.BADH<>BADH.ref || ZLGD.BADH:=BADH.ref ?};
   {? ZLGD.BADH<>null()
   || {? ZLGD.BADH().STAN='P'
      || FUN.info('Badanie powiązane z tą rejestracją wykonania nie zostało jeszcze zaakceptowane.'@);
         _can_continue:=0
      ?};
      {? _can_continue>0 & _chk_akc>0
      || {? ZLGD.BADH().STAN='Z'
         || _can_continue:=0;
            FUN.info('Badanie powiązane z tą rejestracją wykonania zostało już ostatecznie zatwierdzone.'@)
         ?}
      ?}
   ?};
   ZLGD.cntx_pop();
   BADH.cntx_pop();
   _buffer:=exec('ZLGD','buffer');
   _buffer.get();
   _prev_il:=BADH.IL;
   _prev_il_br:=BADH.IL_BRAK;
   _dek_changed:=0;
   {? _can_continue>0
   || VAR1.REJ_WYR:='N';
      {? exec('zlgd_czy_wyr','zl_wyr',ZLGD.ref())
      || _env:=exec('env','zl_wyr',2);
         exec('fill_env','zl_wyr',ZLGD.ZGP,ZLGD.ref(),_mode);
         VAR1.REJ_WYR:='T';
         __valid:="exec('chk_kwalifik','zl_wyk')"
      |? _kj_area=1
      || ZLGD.win_edit('KWAL_KJ');
         {? ZLGD.BADH<>null() & ZLGD.BADH().AUTO='N'
         ||
::          Ustawiam deklarowane ilości po kontroli jakości
            {? ZLGD.DEK_IL=0 & ZLGD.DEK_BR=0
            || ZLGD.DEK_IL:=ZLGD.IL;
               ZLGD.DEK_BR:=ZLGD.IL_BRAK;
               _dek_changed:=1
            ?}
         ?}
      || {? BADH.AUTO='N'
         || ZLGD.win_edit('KWALIF_O');
::          Ustawiam deklarowane ilości po kontroli jakości
            {? ZLGD.DEK_IL=0 & ZLGD.DEK_BR=0
            || ZLGD.DEK_IL:=ZLGD.IL;
               ZLGD.DEK_BR:=ZLGD.IL_BRAK;
               _dek_changed:=1
            ?}
         || ZLGD.win_edit('KWALIFIK')
         ?}
      ?};
::    Sprawdzam czy wykonaną wcześniej inną kontrolę na danym ZLGD,
::    jeśli tak to podpowiadam wartości z ostatniej kontroli
      _ref:=BADH.ref;
      BADH.cntx_psh();
      BADH.index('MZLGD');
      BADH.prefix(ZLGD.ref(),ref_name(ZLGD.ref()),'Z','T');
      _ok:=1;
      _il:=0;
      _il_brak:=0;
      {? BADH.first()
      ||
::       Sprawdzam czy nie znaleziono tego samego badania
         {? BADH.ref()=_ref || _ok:=BADH.next() ?}
      || _ok:=0
      ?};
      BADH.cntx_pop();

      {? _ok
      || VAR1.IL:=ZLGD.IL;
         VAR1.IL_BRAK:=ZLGD.IL_BRAK;
         VAR1.BRAKI_R:=ZLGD.BRAKI_R
      || {? _mode='P'
         || VAR1.IL:=ZLGD.DEK_IL;
            VAR1.IL_BRAK:=ZLGD.DEK_BR
         |? _mode='N'
         || VAR1.IL:=0;
            VAR1.IL_BRAK:=ZLGD.DEK_IL+ZLGD.DEK_BR
         ?};
         VAR1.BRAKI_R:=ZLGD.DEK_RBR
      ?};
      ZLGD.BRAKI_R:=VAR1.BRAKI_R;
      BADH.PREV_IL:=ZLGD.IL;
      BADH.PREV_BR:=ZLGD.IL_BRAK;
      ZLGD.KJ_DONE:='T';
      VAR1.KN2:='T';
      exec('zlgd_efld_opt','zl_wyk');
      {?  {? VAR1.REJ_WYR='T' || _env.TAB_P.select() || ZLGD.edit("exec('chk_kwalifik','zl_wyk')",,'IL') ?}
      || ZLGD.prefix();
         {? BADH.ref()<>null()
         || BADH.IL:=ZLGD.IL;
            BADH.IL_BRAK:=ZLGD.IL_BRAK;
            BADH.ZLGD:=ZLGD.ref();
            ZLGD.BADH:=BADH.ref();
            ZLGD.KJ_NEED:='T';
            {? _dek_changed || ZLGD.DEK_IL:=_buffer.DEK_IL; ZLGD.DEK_BR:=_buffer.DEK_BR ?};
            _can_continue:=BADH.put()
         ?};
::       Aktualizacja ZL_WYRGD (zapisów robocizny w rozbiciu na wyroby)
         {? VAR1.REJ_WYR='T'
         || exec('zl_wyrgd_from_tab','zl_wyr')
         ?};
         {? _can_continue || _can_continue:=ZLGD.put() ?};
::       Rozliczenie brygadowe - rozliczanie ilosciowe operacji brygadowych - parametr 500600='N'
         {? _can_continue & ZLGD.BP='B' & exec('get','#params',500600,2)='N'
         || exec('zlgb_sel','zl_wyk')
::       Rozliczenie brygadowe - rozliczenie godzinowe operacji brygadowych - parametr 500600='T'
         |? _can_continue & ZLGD.BP='B' & exec('get','#params',500600,2)='T'
         || ZLGB.index('ZLGD');
            ZLGB.prefix(ZLGD.ref());
            {? ZLGB.first()
            || {!
               |?
::                  ZLGB.P:=ZLGD.P;
::                  ZLGB.ST:=exec('zlgb_st','zl_wyk',ZLGB.P);
::                  ZLGB.TIME:=ZLGD.TIME;
::                  ZLGB.TIME_P:=ZLGD.TIME_P;
                  ZLGB.IL:=ZLGD.IL;
                  ZLGB.IL_BRAK:=ZLGD.IL_BRAK;
                  ZLGB.DEK_IL:=ZLGD.DEK_IL;
                  ZLGB.DEK_BR:=ZLGD.DEK_BR;
::                  ZLGB.KW:=ZLGD.KW;
::                  ZLGB.R:=ZLGD.R;
                  ZLGB.put();
                  ZLGB.next()
               !}
            ?}
         |? _can_continue & ZLGD.BP='P'
         || ZLGB.index('ZLGD');
            ZLGB.prefix(ZLGD.ref());
            {? ZLGB.first()
            || ZLGB.P:=ZLGD.P;
               ZLGB.ST:=exec('zlgb_st','zl_wyk',ZLGB.P);
               ZLGB.TIME:=ZLGD.TIME;
               ZLGB.TIME_P:=ZLGD.TIME_P;
               ZLGB.IL:=ZLGD.IL;
               ZLGB.IL_BRAK:=ZLGD.IL_BRAK;
               ZLGB.DEK_IL:=ZLGD.DEK_IL;
               ZLGB.DEK_BR:=ZLGD.DEK_BR;
               ZLGB.KW:=ZLGD.KW;
               ZLGB.R:=ZLGD.R;
               ZLGB.put()
            ?}
         ?}
      || _can_continue:=0
      ?};
      VAR1.KN2:=''
   ?};
   {? _can_continue>0 & ZLGD.BADH<>null()
   || {? ZLGD.BADH().STAN='W'
      || {? _kj_area=1
         || exec('BADH_akceptuj','statexam',ZLGD.BADH,'Z',WYDRUKIL.STR1,0)
         || exec('BADH_akceptuj','statexam',ZLGD.BADH,'Z','P',0)
         ?}
      ?}
   ?};
   {? _can_continue>0 & exec('get','#params',500621,2)='P'
   ||
::    Jeśli synchronizacja wykonań plan->zlecenie to po potwierdzeniu kwalifikacji nawijam też wykonania na plan
      PL_WYK.cntx_psh();
      PL_WYK.index('UID');
      PL_WYK.prefix(ZLGD.PL_WYK);
      {? PL_WYK.first()
      ||
         {!
         |? PL_WYK.IL_WYK:=ZLGD.IL;
            PL_WYK.IL_BRAK:=ZLGD.IL_BRAK;
            PL_WYK.KJ_DONE:='T';
::          Wyłączam trigger aktualizujacy ZLGD, bo w tym przypadku jest niepotrzebny bo ZLGD już zaktualizowane
            PL_WYK.trig_a('put',"",'autozlgd');
            _can_continue:=PL_WYK.put();
            PL_WYK.trig_a('put',"exec('auto_zlgd','zl_wyk','put')",'autozlgd');
            PL_WYK.next()
         !}
      ?};
      PL_WYK.cntx_pop();
      ~~
   ?};

   exec('oblicz_zgh_1zl','zl_wyk',ZLGD.ZL);

:: Aktualizacja ilości wyzwala TTE_WYK_DWZL
   {? _can_continue>0 & ZLGD.KJ_DONE='T' & exec('chk_role','#b__box',OPERATOR.USER,'TTE_WYK_DWZL')
   || _zl_ref:=ZLGD.ZL;
      _zl_uid:=exec('FindAndGet','#table',ZL,_zl_ref,,"uidref()",'');

      _arg:=exec('mp_run_a','#b__box');
      _arg.ACT_UID:='TTE_WYK_DWZL';
      _arg.UIDREF:=_zl_uid;
      _arg.AKCJA:='ZAKOŃCZ_KJ';
      _arg.PORTS_IN:=exec('portsIn','#b__box',_arg.ACT_UID);
      _arg.PROC_START:='T';
      _arg.CONTEXT:=obj_new('ZLGD','ZGP','ILOSC','BRAKI');
         _arg.CONTEXT.ZLGD:=ZLGD.ref();
         _arg.CONTEXT.ZGP:=ZLGD.ZGP;
         _arg.CONTEXT.ILOSC:=ZLGD.IL;
         _arg.CONTEXT.BRAKI:=ZLGD.IL_BRAK;
      exec('portsInSet','#b__box',_arg.PORTS_IN,_arg.ACT_UID,'ZL',_zl_ref);

      exec('mp_run','#b__box',_arg)
   ?};
   {? _can_continue=0
   || ZLGD.KJ_DONE:=_buffer.KJ_DONE;
      ZLGD.IL:=_buffer.IL;
      ZLGD.IL_BRAK:=_buffer.IL_BRAK;
      ZLGD.BADH:=_buffer.BADH;
      ZLGD.KJ_NEED:=_buffer.KJ_NEED;
      ZLGD.BRAKI_R:=_buffer.BRAKI_R;
      {? _dek_changed || ZLGD.DEK_IL:=_buffer.DEK_IL; ZLGD.DEK_BR:=_buffer.DEK_BR ?};
::    Odtworzenie pól TIME, TIME_P, KW tabeli ZLGD
      exec('po_zg_is','zl_wyk');
      ZLGD.put();
      {? BADH.ref<>null
      || BADH.IL:=_prev_il;
         BADH.IL_BRAK:=_prev_il_br;
         BADH.put()
      ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
_result


\odkwalifikuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Wycofanie kwalifikacji jakościowej akordu
::       Kontekst pracy - rekord ZLGD
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \odkwalifikuj/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_can_continue:=1;
_null:=0;

_kj_bad:=ZLGD.ZGP().KJ_BAD;
{? _kj_bad<>'P' & _kj_bad<>'B' & (ZLGD.BADH<>null & ZLGD.BADH().AUTO<>'N')
|| FUN.info('Zapis nie podlega kwalifikacji jakościowej.'@);
   _can_continue:=0
?};
{? _can_continue>0
||
:: Ile na dokumentach
   _il_rp:=exec('get_ilosc_rp','zl_wyk');
   {? _il_rp>0
   || _can_continue:=0;
      KOMM.add(
         'Do rejestracji wykonania zostały wygenerowane dokumenty raportujące. '
         'Nie można wycofać kwalifikacji wykonań.'@,2,,1
      )
   ?}
?};

{? _can_continue>0
|| ZLGD.KJ_DONE:='P';
:: Sprawdzam czy są zarejestrowane inne badania do danej operacji. Jeżeli są to pobieram wartości z poprzedniego
:: badania, jeśli takich badań nie ma pobieram wartości zadeklarowane/zarejestrowane przez pracownika.
   BADH.cntx_psh();
   BADH.index('MZLGD');
   BADH.prefix(ZLGD.ref(),ref_name(ZLGD.ref()),'Z','T');
   _ok:=1;
   {? BADH.first()
   || {? BADH.ref()=ZLGD.BADH || _ok:=BADH.next() ?};
      {? _ok
      || ZLGD.IL:=BADH.IL;
         ZLGD.IL_BRAK:=BADH.IL_BRAK;
         ZLGD.BADH:=BADH.ref();
         ZLGD.KJ_DONE:='T'
      ?}
   || _ok:=0
   ?};
   BADH.cntx_pop();
   BADH.cntx_psh();
   {? ~_ok & (ZLGD.BADH<>null & ZLGD.BADH().AUTO<>'N')
   || ZLGD.IL:=BADH.PREV_IL;
      ZLGD.IL_BRAK:=BADH.PREV_BR;
      ZLGD.BRAKI_R:=null();
::    Jeżeli rejestracja w rozpbiciu na produkty, to odkręcam ilości na poszczególnych zapisach
      {? exec('zlgd_czy_wyr','zl_wyr',ZLGD.ref())
      || exec('odkwalifikuj','zl_wyr')
      ?}
   |? ~_ok
   || ZLGD.IL:=BADH.PREV_IL;
      ZLGD.IL_BRAK:=BADH.PREV_BR;
      ZLGD.BRAKI_R:=null();
      _null:=1;
      ZLGD.KJ_DONE:='N'
   ?};
   BADH.cntx_pop()
?};

ZLGD.cntx_psh();
ZLGD.clear();
_can_continue:=ZLGD.put();
{? _can_continue & ZLGD.BP='B' & exec('get','#params',500600,2)='N'
|| exec('zlgb_sel','zl_wyk')
|? _can_continue & ZLGD.BP='B' & exec('get','#params',500600,2)='T'
|| ZLGB.index('ZLGD');
   ZLGB.prefix(ZLGD.ref());
   {? ZLGB.first()
   || {!
      |?
         ZLGB.IL:=ZLGD.IL;
         ZLGB.IL_BRAK:=ZLGD.IL_BRAK;
         ZLGB.DEK_IL:=ZLGD.DEK_IL;
         ZLGB.DEK_BR:=ZLGD.DEK_BR;
         ZLGB.put();
         ZLGB.next()
      !}
   ?}
|? _can_continue & ZLGD.BP='P'
|| ZLGB.index('ZLGD');
   ZLGB.prefix(ZLGD.ref());
   {? ZLGB.first()
   || ZLGB.TIME:=ZLGD.TIME;
      ZLGB.TIME_P:=ZLGD.TIME_P;
      ZLGB.IL:=ZLGD.IL;
      ZLGB.IL_BRAK:=ZLGD.IL_BRAK;
      ZLGB.DEK_IL:=ZLGD.DEK_IL;
      ZLGB.DEK_BR:=ZLGD.DEK_BR;
      ZLGB.KW:=ZLGD.KW;
      ZLGB.R:=ZLGD.R;
      ZLGB.put()
   ?}
?};

{? _can_continue>0 & exec('get','#params',500621,2)='P'
||
:: Jeśli synchronizacja wykonań plan->zlecenie to po wycofaniu kwalifikacji nawijam
:: też wykonania na plan
   PL_WYK.cntx_psh();
   PL_WYK.index('UID');
   PL_WYK.prefix(ZLGD.PL_WYK);
   {? PL_WYK.first()
   || {!
      |? PL_WYK.IL_WYK:=ZLGD.IL;
         PL_WYK.IL_BRAK:=ZLGD.IL_BRAK;
         PL_WYK.KJ_DONE:=ZLGD.KJ_DONE;
::       Wyłączam trigger aktualizujacy ZLGD, bo w tym przypadku jest niepotrzebny bo ZLGD już zaktualizowane
         PL_WYK.trig_a('put',"",'autozlgd');
         _can_continue:=PL_WYK.put();
         PL_WYK.trig_a('put',"exec('auto_zlgd','zl_wyk','put')",'autozlgd');
         PL_WYK.next()
      !}
   ?};
   PL_WYK.cntx_pop();
   ~~
?};
{? _null=1
|| ZLGD.BADH:=null();
   ZLGD.put()
?};
ZLGD.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\chk_kwalifik
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Kontrola po redakcji okna kwalifikacji ilosci
::  OLD: \chk_kwalifik/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_res:='';
{? VAR1.IL+VAR1.IL_BRAK<>ZLGD.DEK_IL+ZLGD.DEK_BR
|| {?  BADH.AUTO='N' & ZLGD.ZGP().KJ_BAD='N'
   || FUN.emsg('Łączna ilość zakwalifikowana (dobre + braki) musi być zgodna z łączną ilością zarejestrowaną.'@)
   || FUN.emsg('Łączna ilość zakwalifikowana (dobre + braki) musi być zgodna z łączną ilością deklarowaną.'@)
   ?};
   _res:='IL'
|? VAR1.IL_BRAK>0 & exec('get','#params',500635,2)='T' & ZLGD.BRAKI_R=null()
|| FUN.emsg('Należy określić rodzaj braku.'@);
   _res:='BRAKI_R'
:: Kontrola ilości z poprzednich operacji
|? (_result:=exec('chk_il_pop','zl_wyk'); _result.RES=0)
|| _txt:=_result.TXT;
   FUN.emsg(_txt);
   _res:='IL'
?};
:: Kontrola ilości badania w locie przy zamkniętym zleceniu
{? _res='' & BADH.AUTO='N' & ZLGD.ZL<>null & ZLGD.ZL().STAN='Z'
|| {? (ZLGD.IL<>ZLGD.DEK_IL) | (ZLGD.IL_BRAK<>ZLGD.DEK_BR)
   || FUN.emsg('Badanie operacyjne jest powiązane ze zleceniem zamkniętym.\n'
               'Ilości dobre i braków muszą zgadzać się z ilościami zadeklarowanymi.'@);
      _res:='IL'
   ?}
?};
:: Kontrola ilości badania w locie przy zarejestrowanych wykonaniach do operacji następnych
{? _res='' & BADH.AUTO='N' & exec('get','#params',500631,2)='T' & ZLGD.ZGP<>null()
|| ZLGD.ZGP();
   _ile:=exec('obl_ilw','zl_guide');
   {? _ile & ((ZLGD.IL<>ZLGD.DEK_IL) | (ZLGD.IL_BRAK<>ZLGD.DEK_BR))
   || FUN.emsg('Do kolejnej operacji zostały już zarejestrowane wykonania.\n'
               'Ilości dobre i braków muszą zgadzać się z ilościami zadeklarowanymi.'@);
      _res:='IL'
   ?}
?};
_res


\zlgd_kwalpar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Wyświetla mierzone parametry ze skojarzonego zestawu pomiarowego
::  OLD: \zlgd_kwalpar/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLGD.BADH=null()
|| FUN.info('Z zapisem nie jest powiązane badanie.'@)
|| exec('BADP_select','statexam',ZLGD.BADH)
?};
~~


\BADH_powiazane
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Wyświetla zapis robocizny powiazany z badaniem
::   WE: _a - BADH.ref()
::  OLD: \BADH_powiazane/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_badh:=_a;
_can_continue:=1;
ZLGD.cntx_psh();
_names:=ZLGD.names();
_found:=0;
::sprawdzam czy ZLGD ma przypisane wskazane badanie
{? _names.first()
|| {!
   |? ZLGD.use(_names.NAME);
      ZLGD.index('BADH');
      ZLGD.prefix(_badh);
      {? ZLGD.first()
      || exec('zlgd_display','zl_wyk');
         _can_continue:=0;
         _found:=1
      ?};
      _can_continue>0 & _names.next()
   !}
?};
ZLGD.cntx_pop();
::sprawdzam czy BADH ma zapisany ref do ZLGD
{? ~_found
|| {? BADH.ZLGD<>null
   ||
      _msk_old:=ZLGD.name();
      _msk_new:=ref_name(BADH.ZLGD);
      {? _msk_old<>_msk_new
      || ZLGD.use(_msk_new)
      ?};
      {? ZLGD.seek(BADH.ZLGD)
      || exec('zlgd_display','zl_wyk');
         _found:=1
      ?}
   ?}
?};
::Jeśli nie znaleziono ZLGD wyświetlam wwszystkie wykonania danego ZGP
{? ~_found
|| BADH.cntx_psh();
   ZGP.cntx_psh();
   BADH.use(ref_name(_badh));
   BADH.seek(_badh);
   BADH.ZGP();
   exec('zgp_godz','zl_wyk');
   ZGP.cntx_pop;
   BADH.cntx_pop()
?};
~~


\zlgd_legenda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Legenda w oknie wertowania tabeli ZLGD
::  OLD: \zlgd_legenda/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','#ZLGD#01');
~~


\get_ilosc_rp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca ilosc na powiazanych dokumentach raportujących
::   WE: [_a] - ZLGD.ref() lub bieżący rekord
::   WY: suma ilości
::  OLD: \get_ilosc_rp/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZLGD.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZLGD.cntx_psh();
{? _ref<>null()
|| ZLGD.prefix();
   {? ZLGD.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? ZLGD.DK<>''
   || _result:=exec('FindAndGet','#table',DK,ZLGD.DK,,"DK.IL",0)
   ?};
   {? _result=0
   || ZL_WYRGD.cntx_psh();
      ZL_WYRGD.index('ZLGD');
      ZL_WYRGD.prefix(ZLGD.ref());
      {? ZL_WYRGD.first()
      || {!
         |? {? ZL_WYRGD.DK<>''
            || _result+=exec('FindAndGet','#table',DK,ZL_WYRGD.DK,,"DK.IL",0)
            ?};
            ZL_WYRGD.next()
         !}
      ?};
      ZL_WYRGD.cntx_pop()
   ?}
?};
ZLGD.cntx_pop();
_result


\zlgb_varfld_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Przed wyswietleniem pol VAR1.BIL, VAR1.BIL_BRAK w oknie redakcyjnym tabeli ZLGB
::  OLD: \zlgb_varfld_bd/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
{? 1+cur_kwin()='s'
|| {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T' | (ZLGD.BADH<>null() & ZLGD.BADH().AUTO='N')
   || VAR1.BIL:=ZLGB.IL;
      VAR1.BIL_BRAK:=ZLGB.IL_BRAK
   || VAR1.BIL:=ZLGB.DEK_IL;
      VAR1.BIL_BRAK:=ZLGB.DEK_BR
   ?}
?};
1


\zlgb_varfld_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Przed redagowaniem pol VAR1.BIL, VAR1.BIL_BRAK w oknie redakcyjnym tabeli ZLGB
::  OLD: \zlgb_varfld_be/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
exec('be_zb_il','zl_wyk')


\zlgb_varfld_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Po redagowaniu pol VAR1.BIL, VAR1.BIL_BRAK w oknie redakcyjnym tabeli ZLGB
::  OLD: \zlgb_varfld_ae/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
exec('po_zb_il','zl_wyk')


\zlgb_varfld_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Format wyswietlania pol VAR1.BIL, VAR1.BIL_BRAK w oknie redakcyjnym tabeli ZLGB
::  OLD: \zlgb_varfld_fd/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
''


\zlgb_varfld_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.46]
:: OPIS: Format redagowania pol VAR1.BIL, VAR1.BIL_BRAK w oknie redakcyjnym tabeli ZLGB
::  OLD: \zlgb_varfld_fe/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
''


\zlgb_sel
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: selekcja pozycji godzin w rozbiciu na pracownikow
::  OLD: \zlgb_sel/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
_keys:={? ZLGD.ILGEN<>0 | ZLGD.AUTO='T' || 'dpu:d' || '' ?};
{? ZLGD.BP='B'
|| ZLGB.index('ZLGD');
   ZLGB.prefix(ZLGD.ref());
:: Rejestracja akordu - rozliczania godzinowe operacji brygadowych - parametr 500600='T'
   {? exec('get','#params',500600,2)='T' | ZLGD.ZGP().TPZ='T' | ZGP.NRZLP().ZLEC().TYP().WP='W'
   || ZLGB.win_sel('WERG')
   || ZLGB.win_sel('WER')
   ?};

   ZLGB.win_edit('RED');
   raport:=ZLGD.IL;
   rapbrak:=ZLGD.IL_BRAK;

   {? ZLGD.r_lock(1,1,1)
   ||
      VAR.SUM_ZLGB:=0;
      VAR.SUM_GBIL:=0;
      VAR.SUM_GBIB:=0;
      VAR.SUM_GBTI:=0;
      {? ZLGB.first()
      || {!
         |?
            VAR.SUM_ZLGB+=ZLGB.KW;
            ZLGB.ZLGD();

:: W przypadku kwalifikacji przepisanie ilosci deklarowanych do rzeczywistych
            {? ZLGD.KJ_DONE='T' & (ZLGB.DEK_IL<>0 | ZLGB.DEK_BR<>0) & (ZLGB.IL=0 & ZLGB.IL_BRAK=0)
            || ZLGB.IL:=ZLGB.DEK_IL;
               ZLGB.IL_BRAK:=ZLGB.DEK_BR;
               ZLGB.put()
            ?};
:: W przypadku kwalifikacji do badania niewygenerowanego automatycznie przepisanie ilosci rzeczywistych do deklarowanych
            {? ZLGD.KJ_DONE='T' & (ZLGB.DEK_IL=0 & ZLGB.DEK_BR=0) & (ZLGB.IL<>0 | ZLGB.IL_BRAK<>0)
            || ZLGB.DEK_IL:=ZLGB.IL;
               ZLGB.DEK_BR:=ZLGB.IL_BRAK;
               ZLGB.put()
            ?};
:: Rejestracja akordu - rozliczania godzinowe operacji brygadowych - parametr 500600='T'
            {? exec('get','#params',500600,2)='T'
            || {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T' | ZLGD.BADH<>null
               || VAR.SUM_GBIL:=ZLGD.IL;
                  VAR.SUM_GBIB:=ZLGD.IL_BRAK
               || VAR.SUM_GBIL:=ZLGD.DEK_IL;
                  VAR.SUM_GBIB:=ZLGD.DEK_BR
               ?}
            ||
               {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T' | ZLGD.BADH<>null
               || {? ZLGD.KJ_DONE<>'T' & ZLGD.BADH<>null & ZLGD.BADH().AUTO<>'N'
                  || VAR.SUM_GBIL:=0;
                     VAR.SUM_GBIB:=0;
                     VAR1.SUM_GDIL:=ZLGD.DEK_IL;
                     VAR1.SUM_GDIB:=ZLGD.DEK_BR;
                     ZLGB.IL:=0;
                     ZLGB.IL_BRAK:=0;
                     ZLGB.put
                  |? ZLGD.KJ_DONE<>'T' & ZLGD.BADH<>null & ZLGD.BADH().AUTO='N'
                  || VAR.SUM_GBIL:=ZLGD.IL;
                     VAR.SUM_GBIB:=ZLGD.IL_BRAK;
                     VAR1.SUM_GDIL:=ZLGD.IL;
                     VAR1.SUM_GDIB:=ZLGD.IL_BRAK;
                     ZLGB.IL:=ZLGB.DEK_IL;
                     ZLGB.IL_BRAK:=ZLGB.DEK_BR;
                     ZLGB.put()
                  || VAR.SUM_GBIL+=ZLGB.IL;
                     VAR.SUM_GBIB+=ZLGB.IL_BRAK
                  ?}
               || VAR.SUM_GBIL+=ZLGB.DEK_IL;
                  VAR.SUM_GBIB+=ZLGB.DEK_BR
               ?}
            ?};
            VAR.SUM_GBTI+=ZLGB.TIME;
            ZLGB.next()
         !}
      ?};
      ZLGB.select(,,,_keys);

:: Jezeli stawka zadana jest zerowa, to sumujemy kwoty
      {? ZLGD.ST=0
      || ZLGD.KW:=0;
         ZLGB.index('ZLGD');
         ZLGB.prefix(ZLGD.ref());
         {? ZLGB.first()
         || {!
            |? ZLGD.KW+=ZLGB.KW;
               ZLGB.next()
            !};
            ZLGD.put()
         ?}
      ?};

      ZLGD.r_unlock()
   || FUN.emsg('Rekord modyfikowany przez innego użytkownika.'@)
   ?}
|| FUN.emsg('Pozycje — tylko dla brygady.'@)
?};
~~


\zlgd_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wyswietl w oknie ZLGD.WER
::  OLD: \zlgd_display/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLGD.KOOP='T'
|| ZLGD.win_edit('RED_KOOP')
|? ZLGD.ZGP().NTIME=0
|| ZLGD.win_edit('RED_WRK')
|| ZLGD.win_edit('RED')
?};
{? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T'
|| VAR1.IL:=ZLGD.IL;
   VAR1.IL_BRAK:=ZLGD.IL_BRAK;
   VAR1.BRAKI_R:=ZLGD.BRAKI_R
|| VAR1.IL:=ZLGD.DEK_IL;
   VAR1.IL_BRAK:=ZLGD.DEK_BR;
   VAR1.BRAKI_R:=ZLGD.DEK_RBR
?};
{? ZLGD.KAP<>null() || {? ref_name(ZLGD.KAP)<>KAP.name() || KAP.use(ref_name(ZLGD.KAP)) ?} ?};
:: Sprawdzam czy ZLGD powiązany z badaniem przeprowadzonym w trakcie wykonywania operacji
{? ZLGD.win_edit('?')='RED_WRK' | ZLGD.win_edit('?')='RED'
|| BADH.cntx_psh();
   BADH.index('TZLGD');
   BADH.prefix('C',ZLGD.ref(),ref_name(ZLGD.ref()));
   {? BADH.first()
   || ZLGD.btn_eopt(ZLGD.win_edit('?'),'BADANIE','state=normal')
   || ZLGD.btn_eopt(ZLGD.win_edit('?'),'BADANIE','state=grayed')
   ?};
   BADH.cntx_pop()
?};
ZLGD.display();
~~


\oknoprzed
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed okno ZLGD.WER
::  OLD: \oknoprzed/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
ilosc:=czas:=raport:=rapbrak:=popr:=zlgdil:=ilr:=czasr:=0


\oknopo
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Po oknie ZLGD.WER
::  OLD: \oknopo/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
VAR_DEL.delete('ilosc','czas','raport','popr','ilr','czasr','zlgdil');
1


\zlgd_dsp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.53] Uwaga 77
:: OPIS: przed rekord dla rekordu ZLGD w oknie WER
::  OLD: \zlgd_dsp/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLGD.KOOP='T'
|| VAR.STRING:='Kooperacja'@
|? ZLGD.ZGP().NTIME=0
|| VAR.STRING:='Stanowisko'@
|? ZLGD.BP='P'
|| VAR.STRING:='Pracownik: %1'@[ZLGD.P().OSOBA().NAZWISKO+' '+ZLGD.P().OSOBA().PIERWSZE]
|| VAR.STRING:='Brygada: %1'@[ZLGD.B().KOD+' '+ZLGD.B().NAZ]
?};
ZLGD.ZGH().ZLEC();
{? ZL.NRNZL=0
|| ZMSLAPP.ZL4:=''
|| ZMSLAPP.ZL4:=ZL.SYM
?};
:: Wyszarzanie akcji dla okna WER_WKJ
_typ:=FILTER.TMP;

_hid:='';
{? cur_win(1,1)='WER_WKJ'
|| {? ZLGD.ZGP().KJ_BAD='P' & ZLGD.BADH=null
   || _hid+='B'
   || {? ~exec('chk_role','#b__box',OPERATOR.USER,'LMG_BAD_DWYK')
      || _hid+='F'
      ?}
   ?}
?};
ZLGD.actions_grayed('WER_WKJ',_hid);
~~


\czy_wydz
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: sprawdza m.in. czy w stalych wybrano wydzial - przed dolaczeniem ZLGD
::   WY: 0 / 1
::  OLD: \czy_wydz/zl_akord.fml
::----------------------------------------------------------------------------------------------------------------------
P.blank(1);
OSOBA.blank(1);
ZLGD.win_edit('RED');
ZMSLAPP.ZL4:='';
{? ST.A_WYD<>null()
|| VAR.A_WYD:=ST.A_WYD;
   VAR1.IL:=0;
   VAR1.IL_BRAK:=0;
   1
|| FUN.info('Nie wybrano wydziału.'@);
   0
?}


\zlgd_kor
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Umozliwia skorygowanie zapisu w ZLGD
::  OLD: \zlgd_kor/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLGD.BP='B'
|| FUN.emsg('Zapisu nie można skorygować — dotyczy brygady.'@);
   return()
?};

{? ZLGD.KAP<>null()
|| FUN.emsg('Zapisu nie można skorygować — dotyczy karty pracy.'@);
   return()
?};

_stred:=ZLGD.win_edit('?');
_red:=ZLGD.mk_edit('Korekta zapisu robocizny'@,0,'zlgd_kor');
ZLGD.win_efld(_red,VAR1,'P_NAZ',,,30,,,'Pracownik'@,,,,'F3_button=1');
ZLGD.win_efld(_red,OSOBA,'PIERWSZE',,,33,,1,'Imię'@);
ZLGD.win_efld(_red,OSOBA,'DRUGIE',,,33,,1,'');
exec('ok_esc','#window',ZLGD,_red);
_ref_osoba:=REF.OSOBA;
REF.OSOBA:=OSOBA.ref();
ZLGD.win_edit(_red);
{? ZLGD.edit()
|| {? ZLGD.put()
   || ZLGB.index('ZLGD');
      ZLGB.prefix(ZLGD.ref());
      {? ZLGB.first()
      || ZLGB.OS_VIEW:=ZLGD.OS_VIEW;
         ZLGB.P:=ZLGD.P;
         ZLGB.put()
      ?}
   ?}
?};
REF.OSOBA:=_ref_osoba;
ZLGD.win_edit(_stred);
~~


\end_akord_4po
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Uruchamia proces dla zapisów akordowych wygenerowanych dla zapisów rejestracji do planu operacyjnego (PL_WYK)
::   WE: _a - PL_WYK.UID
::----------------------------------------------------------------------------------------------------------------------
_pl_wyk:=_a;

ZLGD.cntx_psh();
ZLGD.index('PL_WYK');
ZLGD.prefix(_pl_wyk,);
{? ZLGD.first()
|| {!
   |?
::    Obsługa procesowości
      {? ZLGD.KJ_DONE='T'
      || _zl_ref:=ZLGD.ZL;
         _zl_uid:=exec('FindAndGet','#table',ZL,_zl_ref,,"uidref()",'');

         _args:=exec('mp_run_a','#b__box');
         _args.ACT_UID:='TTE_WYK_DWZL';
         _args.UIDREF:=_zl_uid;
         _args.AKCJA:='ZAKOŃCZ';
         _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
         _args.PROC_START:='T';
         _args.CONTEXT:=obj_new('ZLGD','ZGP','ILOSC','BRAKI');
            _args.CONTEXT.ZLGD:=ZLGD.ref();
            _args.CONTEXT.ZGP:=ZLGD.ZGP;
            _args.CONTEXT.ILOSC:=ZLGD.IL;
            _args.CONTEXT.BRAKI:=ZLGD.IL_BRAK;

         exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',_zl_ref);

         exec('mp_run','#b__box',_args);

         obj_del(_args)
      ?};
      ZLGD.next()
   !}
?};
ZLGD.cntx_pop();
~~


\full_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.14]
:: OPIS: Szczegółowa rejestracja wykonania - okno ZLGD
::       Kontekst pracy: rekord ZGP, rekord PROD_REJ, pola VPRODREJ.IL_POP, VPRODREJ.MAX
::   WE: [_a] - brygadowo (B), pracownik (P)
::       [_b] - pracownik
::       [_c] - brygada
::       [_d] - wartosc początkowa pola VPRODREJ.IL
::       [_e] - wartość początkowa pola VPRODREJ.TIME
::       [_f] - karta pracy
::   WY: 1 - potwierdzenie, 0 - rezygnacja
::       Wypełniane są pola VPRODREJ.IL, VPRODREJ.IL_BRAK, VPRODREJ.TIME, VPRODREJ.ZPARN, VPRODREJ.OK,
::                          VPRODREJ.ZMIANA, VPRODREJ.R, VPRODREJ.ST
::----------------------------------------------------------------------------------------------------------------------
_bp:={? var_pres('_a')=type_of('') || _a || 'P' ?};
VAR.cntx_psh();
VAR.BP:=_bp;
VAR.A_ZLEC:=ZGP.ZL;
VAR.A_DAT:={? date(ST.AR,ST.AM,0)=date(,,0) || date() || date(ST.AR,ST.AM,0) ?};
VAR.EDIT:='X';
ZLGD.blank();
ZLGD.ZGP:=ZGP.ref();
ZLGD.ZGH:=ZGP.NRZLP;
ZLGD.BP:=_bp;
{? VAR1.KN3='N'
||
:: Rejestracja z poziomu partii - przypianie ZLGD wcześniej określonych wartości zmiennnych
   ZLGD.IL:=VAR1.IL:=VPRODREJ.IL;
   ZLGD.IL_BRAK:=VAR1.IL_BRAK:=VPRODREJ.IL_BRAK;
   ZLGD.TIME:=VPRODREJ.TIME;
   ZLGD.P:=FILTER.PR_P;
   ZLGD.B:=FILTER.PR_ZLBR;
   {? ZLGD.P<>null()
   || VAR1.P_NAZ:=exec('FindAndGet','#table',P,ZLGD.P,,"P.OSOBA().NAZWISKO",'')
   || ''
   ?};
   ZLGD.OK:=VPRODREJ.OK
|| ZLGD.IL:=VAR1.IL:={? var_pres('_d')=type_of(0) || _d || 0 ?};
   ZLGD.IL_BRAK:=VAR1.IL_BRAK:=0;
   VAR1.BRAKI_R:=null();
   ZLGD.TIME:={? var_pres('_e')=type_of(0) || _e || 0 ?};
   ZLGD.P:={? var_pres('_b')=type_of(null()) || _b || null() ?};
   ZLGD.B:={? var_pres('_c')=type_of(null()) || _c || null() ?}
?};
ZLGD.ZMIANA:=exec('zmiana','zl_common',time());
ZLGD.KAP:={? var_pres('_f')=type_of(null()) || _f || null() ?};
ZLGD.PLACE:=ZGP.PLACE;
:: Jeżeli jest karta pracy, to dodatkowo wyliczenie czasu
{? ZLGD.KAP<>null()
|| {? var_pres('Akord')>100
   || Akord.NTIME:=ZLGD.ZGP().NTIME;
      Akord.MTIME:=ZLGD.ZGP().MTIME;
      Akord.IL_N:=ZLGD.ZGH().ILNPRZ
   ?};
   exec('po_zg_is','zl_wyk','przelicz')
?};
ZLGD.ZPARN:=VPRODREJ.ZPARN;
:: Sprawdzam czy pole z partią musi być wypełnione
_party_req:=exec('party_req','zl_wyk',ZLGD.ZL);
{? ZGP.NTIME=0
|| ZLGD.win_edit('RED_WRKR');
   ZLGD.efld_opt('RED_WRKR',{? _party_req>0 || 'mark=1' || 'mark=0' ?},,'ZPARN')
|| ZLGD.win_edit('RED_PR');
   ZLGD.efld_opt('RED_PR',{? _party_req>0 || 'mark=1' || 'mark=0' ?},,'ZPARN')
?};

{? VEK.TERM='T'
|| VPRODREJ.AUTO:='T'
|? VAR1.KN3='N'
|| VPRODREJ.AUTO:='N'
|? VPRODREJ.AUTO=''
|| VPRODREJ.AUTO:='T'
?};
:: Sprawdzenie, czy dostępna funkcjonalność rejestracji wykonania do wielu produktów
{? exec('zgp_czy_wyr','zl_wyr',ZLGD.ZGP)
|| VAR1.REJ_WYR:='T';
   {? ZLGD.P<>null()
   || VAR1.P_NAZ:=exec('FindAndGet','#table',P,ZLGD.P,,"P.OSOBA().NAZWISKO",'')
   ?};
   ZLGD.IL:=0
|| VAR1.REJ_WYR:='N'
?};
:: Sprawdzenie czy są surowce nielimitowane do rozliczenia
{? VEK.TERM<>'T'
|| ZLIM.cntx_psh();
   exec('openmask','zl_common',ZLGD.ZL);
   ZLIM.index('ZGP_ROZ');
   ZLIM.prefix(ZLGD.ZGP,'N','T');
   {? ZLIM.first()
   || ZLGD.btn_eopt(ZLGD.win_edit('?'),'SUROWCE','state=normal');
      _create:=1;
      {? var_pres('__ENV_REJ')>100
      || {? __ENV_REJ.ZGP<>ZLGD.ZGP
         || obj_del(__ENV_REJ)
         || _create:=0
         ?}
      ?};
      {? var_pres('_tab')>0 || obj_del(_tab) ?};
      _il:={? VEK.TERM<>'T'
           || VAR1.IL+VAR1.IL_BRAK
           || #(exec('get_value','#desktop','#:ctr_menu_end','ctr_menu_end','fld_il@menu_end')) +
              #(exec('get_value','#desktop','#:ctr_menu_end','ctr_menu_end','fld_il_brak@menu_end'))
           ?};
      {? _create
      || exec('env_rej_mat','zl_wyk');
         __ENV_REJ.ZGP:=ZLGD.ZGP;
         _tab:=__ENV_REJ.TAB;
         VAR.fld_fml('A_MAG','AFTER_EDIT',"
            _tab:=__ENV_REJ.TAB;
            _ktm:=exec('FindAndGet','#table','M',_tab.MREF,,\"M.ref\",null);
            _dk_c:=exec('FindAndGet','#table','DK_C',_tab.DKCREF,,\"DK_C.ref\",null);
            _zl:=exec('FindAndGet','#table','ZL',_tab.ZLREF,,\"ZL.ref\",null);
::          Sprawdzam dostępny stan magazynowy dla podanej pozycji
            {? _dk_c<>null()
            || exec('obl_stan','magazyn_stan',_ktm,1,VAR.A_MAG,,,date(),-2,,,,_dk_c)
            || exec('obl_stan','magazyn_stan',_ktm,1,VAR.A_MAG,,,date(),-2)
            ?};
            VAR.REAL:=BEER.SD;
            VAR.REAL+=exec('zlim_il_rez','zl_nlimit',_tab.ZLIMREF);
            1
         ");
::       Tworzy rozpiskę do rozliczeń surowców nielimitowanych
         {!
         |? _tab.KTM:=exec('FindAndGet','#table',M,ZLIM.KTM,,"KTM",'');
            _tab.M:=exec('FindAndGet','#table',M,ZLIM.KTM,,"N",'');
            _tab.JM:=exec('FindAndGet','#table',M,ZLIM.KTM,,"J().KOD",'');
            _tab.MG:=exec('FindAndGet','#table',MG,ZLIM.MG,,"SYM",'');
            _tab.LIL:=ZLIM.LIL;
            _tab.MGREF:=$ZLIM.MG;
            _tab.MREF:=$ZLIM.KTM;
            _tab.TMATREF:=$ZLIM.TMAT;
            _tab.ZLIMREF:=$ZLIM.ref();
            _tab.ZLREF:=$ZLIM.ZLEC;
            _tab.DKCREF:={? ZLIM.DK_C<>null || $ZLIM.DK_C || '' ?};

::          Sprawdzam dostępny stan magazynowy dla podanej pozycji
            {? ZLIM.DK_C<>null()
            || exec('obl_stan','magazyn_stan',ZLIM.KTM,1,ZLIM.MG,,,date(),-2,,,,ZLIM.DK_C)
            || exec('obl_stan','magazyn_stan',ZLIM.KTM,1,ZLIM.MG,,,date(),-2)
            ?};
            _tab.STAN:=BEER.SD;
            _tab.STAN+=exec('zlim_il_rez','zl_nlimit',_tab.ZLIMREF);
            _tab.IL:=0;
::          Wyliczam ilość - tylko przy rejestracji wykonań z poziomu partii
            {? VAR1.KN3='N'
            || _dokl:=exec('jaka_dok_m','jm',ZLIM.KTM);
::            _il_zl:=exec('FindAndGet','#table','ZL',ZLIM.ZLEC,,"ZL.IL",1);
               _il_zgp:=exec('FindAndGet','#table','ZGP',ZLIM.ZGP,,"ZGP.ILOSC",1);
               _tab.IL:={? _dokl>0
                        || ((ZLIM.LIL*_il)/_il_zgp)$ _dokl
                        || ceil(((ZLIM.LIL*_il)/_il_zgp))
                        ?}
            ?};
            _tab.add();
            ZLIM.next()
         !}
      ?}
   || ZLGD.btn_eopt(ZLGD.win_edit('?'),'SUROWCE','state=grayed')
   ?};
   ZLIM.cntx_pop()
?};

:: Sprawdzam czy operacja wymaga przeprowadzenia badań w trakcie wykonywania operacji
{? VEK.TERM<>'T'
|| _bad_op:=exec('FindAndGet','#table',ZGP,ZLGD.ZGP,,"ZGP.BAD_OP",null());
   {? _bad_op<>null()
   || ZLGD.btn_eopt(ZLGD.win_edit('?'),'BADANIE','state=normal');
::    Tworzę środowisko do rejestrowania badań
      _env:=exec('env_bad_op','statexam');
      _env.BADSEH:=_bad_op;
      {? var_pres('_tab')>100 || obj_del(_tab) ?};
      _tab:=_env.TAB;
::    Przepisuje parametry badania
      BADSEP.cntx_psh();
      BADSEP.index('SEHPAR_');
      BADSEP.prefix(_bad_op);
      {? BADSEP.first()
      ||
         {!
         |?
            _tab.blank();
            _tab.PAR:=BADSEP.BADPAR().N;
            _tab.TYP:=BADSEP.BADPAR().TYP;
            _tab.SOURCE:=BADSEP.SOURCE;
            _tab.PARREF:=$BADSEP.BADPAR;
            {? BADSEP.CZY_DEF='T'
            || {? BADSEP.BADPAR().TYP='D' & BADSEP.DEF_CURD='T'
               ||
::                Wyznaczenie wartości domyślnej na podstawie bieżącej daty
                  _tab.WAR:=(date()+BADSEP.DEF_DNI)$1
               || _tab.WAR:=BADSEP.DEF_VAL
               ?};
               _tab.VALUE:=exec('getvalfromwar','statexam',_tab.TYP,_tab.WAR)
            ?};
            _tab.add(1);
            BADSEP.next()
         !}
      ?};
      BADSEP.cntx_pop()
   || ZLGD.btn_eopt(ZLGD.win_edit('?'),'BADANIE','state=grayed')
   ?}
?};

:: Podpowiadanie braków po kontroli jakości
BADO.cntx_psh();
BADO.index('ZGP');
BADO.prefix(PROD_REJ.ZGP);
_bado:=0;
{? BADO.last()
|| _badh:=BADO.BADH;
   {? _badh<>null
   || _msk_old:=BADH.name;
      _msk_new:=ref_name(_badh);
      {? _msk_old<>_msk_new
      || BADH.use(_msk_new)
      ?};
      {? BADH.seek(_badh) & BADH.STAN='Z'
      || _bado:=1;
         BADVAR.BADH:=BADH.ref
      ?}
   ?}
?};
{? _bado=1
||
::   VPRODREJ.IL_BRAK:=BADO.IL_BRAK;
   {? BADO.ILP>0
   || _il:={? BADO.IL_BRAK<BADO.ILP || BADO.ILP || BADO.IL_BRAK ?};
      FUN.info('Do wskazanej operacji została przeprowadzona kontrola jakości. Stwierdzono liczbę braków w liczbie: %1'@
               [$_il])
   ?};
   VAR1.KN1:='T'
|| VAR1.KN1:='N'
?};
exec('zlgd_efld_opt','zl_wyk');
_valid:="
   _komm:={? var_pres('_a')=type_of(0) || _a || 0 ?};
   _result:=exec('chk_rec_zlgd','zl_wyk',_komm);
   {? _result=''
   ||
::    Czy zbierać informacje do KOMM
      _txt:={? VAR1.KN3='N'
            || 'Wystąpił błąd podczas walidacji danych. Komunikat błędu: '@
            || ''
            ?};
      _bado_ilb:=BADO.IL_BRAK;
      {? VAR1.KN1='T' & _bado_ilb<BADO.ILP
      || _bado_ilb:=BADO.ILP
      ?};
::    Kontrola jakości w locie przy manualnym zakończaniu operacji
      {? VAR1.KN1='T' & ZLGD.OK='T' & VAR1.IL_BRAK<BADO.ILP
      || _ilb:=BADO.ILP;
         {? _komm>0
         || _txt+='Próba zakończenia operacji z nieprawidłową liczbą zarejestrowanych braków.'
                  'Ilość braków nie może być mniejsza od liczby wskazanej przy kontroli jakości (%1).'@[$_bado_ilb]
         || FUN.info('Próba zakończenia operacji z nieprawidłową liczbą zarejestrowanych braków.\n'
                     'Ilość braków nie może być mniejsza od liczby wskazanej przy kontroli jakości (%1).\n'
                     'Dotychczas zarejestrowano %2/%1 braków.\n'
                     'Podczas bieżącej rejestracji liczba braków musi wynosić co najmniej %3.'@[$_bado_ilb,$(_bado_ilb-BADO.ILP),$_ilb])
         ?};
         _result:='IL_BRAK'
::    Kontrola jakości w locie przy kontroli ilościowej
      |? VAR1.KN1='T' & (PROD_REJ.SRODZ='ZL' & (exec('get','#params',500631,2)='T' | exec('get','#params',500634,2)='T')
            | (PROD_REJ.SRODZ='PX' & exec('get','#params',500633,2)='T')  | (PROD_REJ.SRODZ='PL' & exec('get','#params',500632,2)='T'))
            & VAR1.IL_BRAK<BADO.ILP
            & ( ( VPRODREJ.IL_POP<>0
            & VAR1.IL+BADO.ILP>VPRODREJ.IL_POP-ZGP.IL-ZGP.IL_BRAK-ZGP.DEK_IL-ZGP.DEK_BR)
            | ( VPRODREJ.IL_POP=0
            & VAR1.IL+BADO.ILP>ZGP.ILOSC-ZGP.IL-ZGP.IL_BRAK-ZGP.DEK_IL-ZGP.DEK_BR))
      || _ilb:=BADO.ILP;
         _ilm:={? VPRODREJ.IL_POP<>0 || VPRODREJ.IL_POP-ZGP.IL-ZGP.IL_BRAK-ZGP.DEK_IL-ZGP.DEK_BR || ZGP.ILOSC-ZGP.IL-ZGP.DEK_IL-ZGP.IL_BRAK-ZGP.DEK_BR ?} - VAR1.IL-VAR1.IL_BRAK;
         {? _ilb<_ilm
         || _ilb:=_ilm-_ilb
         || _ilb:=_ilb - {? _ilm>0 || _ilm || 0 ?}
         ?};
         {? _komm>0
         || _txt+='Próba zakończenia operacji z nieprawidłową liczbą zarejestrowanych braków.'
                  'Ilość braków nie może być mniejsza od liczby wskazanej przy kontroli jakości (%1).'@[$_bado_ilb]
         || FUN.info('Próba zakończenia operacji z nieprawidłową liczbą zarejestrowanych braków.\n'
                     'Ilość braków nie może być mniejsza od liczby wskazanej przy kontroli jakości (%1).\n'
                     'Dotychczas zarejestrowano %2/%1 braków.\n'
                     'Podczas bieżącej rejestracji liczba braków musi wynosić co najmniej %3.'@[$_bado_ilb,$(_bado_ilb-BADO.ILP),$_ilb])
         ?};
         _result:='IL_BRAK'
::    Kontrola jakości w locie przy braku kontroli ilościowej
      |? VAR1.KN1='T' & (exec('get','#params',500631,2)='N' & exec('get','#params',500634,2)='N')
            & VAR1.IL_BRAK<BADO.ILP
            & VAR1.IL+BADO.ILP>ZGP.ILOSC-ZGP.IL-ZGP.IL_BRAK-ZGP.DEK_IL-ZGP.DEK_BR
      || _ilm:=ZGP.ILOSC-ZGP.IL-ZGP.DEK_IL-ZGP.IL_BRAK-ZGP.DEK_BR-VAR1.IL-VAR1.IL_BRAK;
         _ilb:=BADO.ILP;
         {? _ilb<_ilm
         || _ilb:=_ilm-_ilb
         ?};
         {? _komm>0
         || _txt+='Próba zakończenia operacji z nieprawidłową liczbą zarejestrowanych braków.'
                  'Ilość braków nie może być mniejsza od liczby wskazanej przy kontroli jakości (%1).'@[$_bado_ilb]
         || FUN.info('Próba zakończenia operacji z nieprawidłową liczbą zarejestrowanych braków.\n'
                     'Ilość braków nie może być mniejsza od liczby wskazanej przy kontroli jakości (%1).\n'
                     'Dotychczas zarejestrowano %2/%1 braków.\n'
                     'Podczas bieżącej rejestracji liczba braków musi wynosić co najmniej %3.'@[$_bado_ilb,$(_bado_ilb-BADO.ILP),$_ilb])
         ?};
         _result:='IL_BRAK'
::    Kontrola rozpiski rozliczeń surowców
      |? (_mat:=exec('chk_rej_mat','zl_nlimit'))<>''
      || {? _komm>0
         || _txt+='W wybranym magazynie nie ma wystarczającej ilośći materiału: %1.'@[_mat]
         || FUN.info('W wybranym magazynie nie ma wystarczającej ilośći materiału: %1.'@[_mat])
         ?};
         _result:='IL'
      ?};
      {? _komm>0 & type_of(_result)=2 & _result<>''
      || KOMM.add(_txt,5)
      ?}
   ?};
:: Jeżeli wszystko dobrze, to dodatkowa walidacja za pomocą wtyczki
   {? _result=''
   || _result:=Plugin.run('VPRODREJ_VALID_001',{? ZLGD.ZGP().TPZ='T' || 'TPZ' || 'IL' ?})
   ?};
:: Kontrola wypełnienia w całości rozpiski rozliczeń surowców (czy wszystkie pozycje surowców zostały rozpisane)
   {? (type_of(_result)=type_of('') & _result='' | type_of(_result)=type_of(0) & _result=1)
   || {? VEK.TERM<>'T' & exec('chk_fill_rej_mat','zl_wyk')=0
      || {? _komm=0
         || {? ~FUN.ask('Nie zarejestrowano pobrania dla wszystkich surowców.\nKontynuować?'@)
            || _result:=0
            ?}
         ?}
      ?}
   ?};
   _result
";
{? VAR1.KN3='N'
|| _validated:=_valid(1);
   {? (type_of(_validated)=2 & _validated='' | type_of(_validated)=1 & _validated=1)
   || _ok:=1
   || _ok:=0;
      VAR_DEL.delete('__ENV_REJ','__ENV_BAD')
   ?}
|? VAR1.REJ_WYR='T'
||
:: Tworzenie środowiska
   _env_wyr:=exec('env','zl_wyr');
   exec('fill_env','zl_wyr',ZLGD.ZGP);
   __valid:=_valid;
   exec('env_efld_opt','zl_wyr');
   {? __ENV_WYR.TAB_P.select()
   || _kj_bad:=ZGP.KJ_BAD;
      {? _kj_bad='N' | ZLGD.KJ_DONE='T'
      || VPRODREJ.IL:=ZLGD.IL;
         VPRODREJ.IL_BRAK:=ZLGD.IL_BRAK
      || VPRODREJ.IL:=ZLGD.DEK_IL;
         VPRODREJ.IL_BRAK:=ZLGD.DEK_BR
      ?};
      VPRODREJ.OK:=ZLGD.OK;
      VPRODREJ.ZPARN:=ZLGD.ZPARN;
      VPRODREJ.TIME:=ZLGD.TIME;
      VPRODREJ.ZMIANA:=ZLGD.ZMIANA;
      VPRODREJ.R:=ZLGD.R;
      VPRODREJ.ST:=ZLGD.ST;
      VPRODREJ.PLACE:=ZLGD.PLACE;
      VPRODREJ.BRAKI_R:=ZLGD.BRAKI_R;
      _ok:=1
   || _ok:=0;
      VAR_DEL.delete('__ENV_REJ','__ENV_BAD','__ENV_WYR')
   ?}
|? ZLGD.edit(_valid)
|| _kj_bad:=ZGP.KJ_BAD;
   {? _kj_bad='N' | ZLGD.KJ_DONE='T'
   || VPRODREJ.IL:=ZLGD.IL;
      VPRODREJ.IL_BRAK:=ZLGD.IL_BRAK;
      VPRODREJ.BRAKI_R:=ZLGD.BRAKI_R
   || VPRODREJ.IL:=ZLGD.DEK_IL;
      VPRODREJ.IL_BRAK:=ZLGD.DEK_BR;
      VPRODREJ.BRAKI_R:=ZLGD.DEK_RBR
   ?};
   VPRODREJ.OK:=ZLGD.OK;
   VPRODREJ.ZPARN:=ZLGD.ZPARN;
   VPRODREJ.TIME:=ZLGD.TIME;
   VPRODREJ.ZMIANA:=ZLGD.ZMIANA;
   VPRODREJ.R:=ZLGD.R;
   VPRODREJ.ST:=ZLGD.ST;
   VPRODREJ.PLACE:=ZLGD.PLACE;
   _ok:=1
|| _ok:=0;
   VAR_DEL.delete('__ENV_REJ','__ENV_BAD')
?};
BADO.cntx_pop();
VAR.fld_fml('A_MAG','AFTER_EDIT',"*");
VAR.cntx_pop();
_ok


\zlgd_kordt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.28]
:: OPIS: Umożliwia skorygowanie daty i zmiany na zpisie akordowym
::       Kontekst wywołania: rekord ZLGD
::----------------------------------------------------------------------------------------------------------------------
{? ZLGD.AUTO='T'
|| FUN.emsg('Zapisu nie można skorygować — został wygenerowany automatycznie.'@);
   return()
?};

PL_WYK.cntx_psh();
PL_WYK.index('ZLGD');
PL_WYK.prefix($ZLGD.ref());
_pl_wyk:=PL_WYK.first();
PL_WYK.cntx_pop();
{? _pl_wyk
|| FUN.emsg('Zapisu nie można skorygować — powiązany z wykonaniami w planie operacyjnym.'@);
   return()
?};

PX_WYK.cntx_psh();
PX_WYK.index('ZLGD');
PX_WYK.prefix($ZLGD.ref());
_px_wyk:=PX_WYK.first();
PX_WYK.cntx_pop();
{? _pl_wyk
|| FUN.emsg('Zapisu nie można skorygować — powiązany z wykonaniami w planie strategicznym.'@);
   return()
?};

_red:=ZLGD.mk_edit('Korekta zapisu robocizny'@,0,'zlgd_kordt');
ZLGD.win_esep(_red,'Dane podstawowe'@);
ZLGD.win_efld(_red,,'DT');
ZLGD.win_efld(_red,,'ZMIANA',,,3,,,,,,,'F3_button=1');
exec('ok_esc','#window',ZLGD,_red);
ZLGD.win_edit(_red);
VAR.AK_DAT:={? ZLGD.O().ROK=ST.AR & OKR.MC=ST.AM || 0 || 1 ?};
{? ZLGD.edit("
               _res:='';
               {? ZLGD.ZL().OD>ZLGD.DT
               || FUN.emsg('Zlecenie powołane z późniejszą datą.'@);
                  _res:='DT'
               ?};
               _res
            ")
|| ZLGD.put()
?};
~~


\rej_grop_pr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Rejestracja wykonan - z poziomu grup operacji (akcja przed)
::----------------------------------------------------------------------------------------------------------------------
{? ~exec('access','zl_wyk') || return() ?};

{? GROP.sel_size()=0
|| _args:=exec('args_4grop','zl_wyk');
   _args.WHERE:='PROD_REJ.GROP in (select :_a.REF from :_a)';
   _args.JOIN:='';
   _args.TAB:=tab_tmp(1,'REF','STRING[16]','$GROP.ref()');
   _args.TAB.REF:=$GROP.ref();
   _args.TAB.add();
   exec('rejestracja','prod_rej',_args)
?};
~~


\rej_grop_po
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Rejestracja wykonan - z poziomu grup operacji (akcja po)
::----------------------------------------------------------------------------------------------------------------------
~~


\rej_grop_gpr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Rejestracja wykonan - z poziomu grup operacji (akcja przed grupa rekordow)
::----------------------------------------------------------------------------------------------------------------------
{? ~exec('access','zl_wyk') || return(0) ?};

GROP.cntx_psh();
GROP.clear();
sel_nchk();
_args:=exec('args_4grop','zl_wyk');
_args.WHERE:='PROD_REJ.GROP in (select :_a.REF from :_a)';
_args.JOIN:='';
_tab:=GROP.sel_aget();
_args.TAB:=tab_tmp(1,'REF','STRING[16]','$GROP.ref()');
{? _tab.first()
|| {!
   |? {? GROP.seek(_tab.REF,)
      || _args.TAB.REF:=$GROP.ref();
         _args.TAB.add()
      ?};
      _tab.next()
   !}
?};
exec('rejestracja','prod_rej',_args);
GROP.cntx_pop();
1


\rej_grop_gpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Rejestracja wykonań - z poziomu grup operacji (akcja po grupie rekordoów)
::----------------------------------------------------------------------------------------------------------------------
~~


\args_4grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Zwraca wspólne wartości argumentow dla rejestracji do grup operacji
::       Użyte z formułach exec('rej_grop_pr','zl_wyk'), exec('rej_grop_gpr','zl_wyk')
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('rejestracja_a','prod_rej');
_args.F_NAWIG:=0;
_args.F_FILTER:=1;
_args.F_START:=0;
_args.F_STOP:=0;
_args.F_WYKON:=1;
_args.F_XWYKON:=1;
_args.F_POTW:=1;
_args.F_XPOTW:=1;
_args.F_PROB:=1;
_args.F_XPROB:=1;
_args.F_DOC:=1;
_args.F_MAT:=0;
_args.F_PRAC:=0;
_args.F_BRYG:=0;
_args.F_REJ:=1;
_args.FILTR_PX:=0;
_args.FILTR_PL:=0;
_args.FILTR_ZL:=1;
_args.PR_DATA:=date(0,0,0);
_args.PR_GROP:='T';
_args.ED_DATA:=0;
_args.ED_ZAKR:=0;
_args.ED_RES:=1;
_args.ED_M:=0;
_args.ED_WYD:=0;
_args.ED_KH:=0;
_args.ED_OPIS:=1;
_args.ED_START:=1;
_args.ED_OK:=1;
_args.ED_POTW:=1;
_args.ED_PROB:=0;
_args.ED_PRAC:=0;
_args.ED_BRYG:=0;
_args.ED_KOOP:=0;
_args.ED_GROP:=1;
_args.ED_A:=1;
_args.ED_DOREJ:=1;
_args.ED_PX:=0;
_args.ED_PL:=0;
_args.ED_ZL:=1;
_args.CLOSE:="";
_args


\grop_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Okno redagowania ilości do grupy operacji
::       Kontekst pracy: rekord GROP, rekord PROD_REJ, pola VPRODREJ.IL_POP, VPRODREJ.MAX
::   WE: [_a] - wartość początkowa pola VPRODREJ.IL
::   WY: 1 - potwierdzenie, 0 - rezygnacja
::       Wypełniane jest pole VPRODREJ.IL
::----------------------------------------------------------------------------------------------------------------------
VPRODREJ.EDIT_ILP:=0;
VPRODREJ.EDIT_IL:=1;
VPRODREJ.EDIT_ILB:=0;
VPRODREJ.EDIT_PR:=0;
VPRODREJ.EDIT_OK:=1;

VPRODREJ.PROD_REJ:=PROD_REJ.ref();
VPRODREJ.OPER:=PROD_REJ.OPER;
VPRODREJ.M:=null();
VPRODREJ.DOKL:=0;
VPRODREJ.JM:=null();
VPRODREJ.PROCENT:=100;
VPRODREJ.IL_PLAN:=PROD_REJ.ILC;
VPRODREJ.IL_DOREJ:=
   {? var_pres('_a')=type_of(0)
   || _a
   || PROD_REJ.IL
   ?};
:: Jak zakańczanie operacji rozpoczętej to zmienne są już wypełnione
{? VAR1.ZAK_EK<>'T'
|| VPRODREJ.IL:=1;
   VPRODREJ.IL_BRAK:=0;
   VPRODREJ.TIME:=0;
   VPRODREJ.OK:='N'
?};
VPRODREJ.PLACE:=PROD_REJ.GROPS().PL_RES().FROM_STA;

VPRODREJ.win_edit('ZGR_WYK');

_valid:="
   _result:='';
   {? VPRODREJ.IL=0 & (VEK.TERM<>'T' | ((VEK.TERM='T' | VAR1.ZAK_EK='T') & exec('get','#params',500643)<>'T'))
   || FUN.info('Ilość musi być określona.'@);
      _result:='IL'
   |? VPRODREJ.IL<0
   || FUN.info('Ilość nie może być ujemna.'@);
      _result:='IL'
   |? VPRODREJ.IL>VPRODREJ.IL_DOREJ
   || FUN.info('Ilość nie może być większa niż %1.'@[$VPRODREJ.IL_DOREJ]);
      _result:='IL'
   |? VPRODREJ.PLACE=null()
   || FUN.info('Należy wskazać stanowisko, na którym została wykonana operacja.'@);
      _result:='PLACE'
   ?};

:: Jeżeli wszystko dobrze, to dodatkowa walidacja za pomocą wtyczki
   {? _result=''
   || _result:=Plugin.run('VPRODREJ_VALID_001','GROP')
   ?};
   _result
";

{? VEK.TERM='T'
|| exec('setEndVar','ekioski',_valid)
|? VAR1.ZAK_EK='T'
||
:: Zakańczanie rozpoczętych operacji ekioskowych od strony Merit ERP
   _win:=exec('vprod_win_ek','zl_wyk',2);
   VPRODREJ.win_edit(_win);
   __valid:=_valid;
   {? VPRODREJ.edit("
      _res:=__valid();
      {? type_of(_res)=type_of('') & _res='' | type_of(_res)=type_of(0) & _res=1
      || _res:=exec('setEndVar','ekioski',__valid)
      ?};
      _res
   ")
   || _res:=1
   || _res:=0
   ?};
   VAR_DEL.delete('__valid');
   _res
|? VPRODREJ.edit(_valid)
|| 1
|| 0
?}


\grop_full_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Szczegółowa rejestracja wykonania - okno ZLGD
::       Kontekst pracy: rekord GROP, rekord PROD_REJ, pola VPRODREJ.IL_POP, VPRODREJ.MAX
::   WE: [_a] - brygadowo (B), pracownik (P)
::       [_b] - pracownik
::       [_c] - brygada
::       [_d] - wartość początkowa pola VPRODREJ.TIME
::   WY: 1 - potwierdzenie, 0 - rezygnacja
::       Wypełniane są pola VPRODREJ.IL, VPRODREJ.TIME, VPRODREJ.OK, VPRODREJ.ZMIANA, VPRODREJ.ST, VPRODERJ.R
::----------------------------------------------------------------------------------------------------------------------
_bp:={? var_pres('_a')=type_of('') || _a || 'P' ?};
VAR.cntx_psh();
VAR.BP:=_bp;
VAR.A_DAT:={? date(ST.AR,ST.AM,0)=date(,,0) || date() || date(ST.AR,ST.AM,0) ?};
VAR.EDIT:='X';
ZLGD.blank();
ZLGD.GROP:=PROD_REJ.GROP;
ZLGD.GROPS:=PROD_REJ.GROPS;
ZLGD.ZGH:=ZGP.NRZLP;
ZLGD.BP:=_bp;
ZLGD.P:={? var_pres('_b')=type_of(null()) || _b || null() ?};
ZLGD.B:={? var_pres('_c')=type_of(null()) || _c || null() ?};
ZLGD.IL:=VAR1.IL:=1;
VAR1.IL_BRAK:=0;
ZLGD.TIME:={? var_pres('_e')=type_of(0) || _e || 0 ?};
ZLGD.ZMIANA:=exec('zmiana','zl_common',time());
ZLGD.PLACE:=PROD_REJ.GROPS().PL_RES().FROM_STA;

ZLGD.win_edit('RED_GROP');
{? ZLGD.edit("
      _result:=exec('chk_rec_zlgd','zl_wyk');
::    Dodatkowa walidacja dla GROP
      {? _result='' & VAR1.IL<=0
      || FUN.info('Ilość musi być większa od zera.'@);
         _result:='IL'
      ?};
      {? _result='' & VAR1.IL>PROD_REJ.IL
      || FUN.info('Ilość nie może być większa niż %1.'@[$PROD_REJ.IL]);
         _result:='IL'
      ?};
      {? _result='' & ZLGD.PLACE=null()
      || FUN.info('Należy wskazać stanowisko, na którym została wykonana operacja.'@);
         _result:='PLACE'
      ?};
::    Jeżeli wszystko dobrze, to dodatkowa walidacja za pomocą wtyczki
      {? _result=''
      || _result:=Plugin.run('VPRODREJ_VALID_001','GROP')
      ?};
      _result
   ")
|| VPRODREJ.IL:={? ZLGD.DEK_IL<>0 || ZLGD.DEK_IL || ZLGD.IL ?};
   VPRODREJ.OK:=ZLGD.OK;
   VPRODREJ.TIME:=ZLGD.TIME;
   VPRODREJ.ZMIANA:=ZLGD.ZMIANA;
   VPRODREJ.R:=ZLGD.R;
   VPRODREJ.ST:=ZLGD.ST;
   VPRODREJ.PLACE:=ZLGD.PLACE;
   _ok:=1
|| _ok:=0
?};
VAR.cntx_pop();
_ok


\wykon_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Rozpoczyna rejestrację wykonania - zadanie ląduje na ToDo
::   WE: _a - ZGP.ref()
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;
_zl:=exec('FindAndGet','#table',ZGP,_zgp,,"ZL",'');

_arg:=exec('mp_run_a','#b__box');
_arg.ACT_UID:='TTE_WYK_DWZL';
_arg.UIDREF:=exec('FindAndGet','#table',ZL,_zl,,"uidref()",'');
_arg.AKCJA:='ROZPOCZNIJ';
_arg.PORTS_IN:=exec('portsIn','#b__box',_arg.ACT_UID);
_arg.PROC_START:='T';
_arg.CONTEXT:=obj_new('ZGP');
   _arg.CONTEXT.ZGP:=_zgp;

exec('portsInSet','#b__box',_arg.PORTS_IN,_arg.ACT_UID,'ZL',_zl);

exec('mp_run','#b__box',_arg);
~~


\ongoing
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Sprawdza, czy pracownik/brygada ma aktualnie wykonywane (rozpoczęte) operacje
::   WE: _a - P.ref(), ZLBR.ref()
::   WY: 0/1 - czy są rozpoczęte operacje
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
ZLGD.cntx_psh();
ZLGD.index('EK2');
{? ref_tab(_a)=P
|| ZLGD.prefix('N',_a,null())
|? ref_tab(_a)=ZLBR
|| ZLGD.prefix('N',null(),_a)
|| ZLGD.prefix('N',null(),null())
?};
{? ZLGD.first() || _result:=1 ?};
ZLGD.cntx_pop();
_result


\BADH_pow_ZLGD
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Wyszukuje powiązanego z badaniem ZLGD
::   WE: _a - BADH.ref()
::   WY: $ZLGD.ref()
::----------------------------------------------------------------------------------------------------------------------
_badh:=_a;
_found:=1;
ZLGD.cntx_psh();
_names:=ZLGD.names();
_ref:='';
{? _names.first()
|| {!
   |? ZLGD.use(_names.NAME);
      ZLGD.index('BADH');
      ZLGD.prefix(_badh);
      {? ZLGD.first()
      ||
         _found:=0;
         _ref:=$ZLGD.ref
      ?};
      _found>0 & _names.next()
   !}
?};
ZLGD.cntx_pop();
::Jak nie znaleziono powiązanego ZLGD sprawdzam czy BADH ma zapisany ref do ZLGD
{? _found
|| {? BADH.ZLGD<>null
   ||
      _msk_old:=ZLGD.name();
      _msk_new:=ref_name(BADH.ZLGD);
      {? _msk_old<>_msk_new
      || ZLGD.use(_msk_new)
      ?};
      {? ZLGD.seek(BADH.ZLGD)
      || _ref:=$ZLGD.ref()
      ?}
   ?}
?};
_ref


\KJ_kwalifik
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Przed akcją Kwalifikuj w obszarze roboczym Kontrola jakości
::----------------------------------------------------------------------------------------------------------------------
{? ZLGD.ZGP().KJ_BAD='P' & ZLGD.BADH=null()
||
:: Zerowanie bufora tabeli BADH
   ZLGD.cntx_psh();
   BADH.seek(0,,,1);
   exec('zlgd_kwalifik','zl_wyk');
   ZLGD.cntx_pop()
|| ZLGD.cntx_psh();
   {? ZLGD.BADH=null()
   || FUN.info('Z zapisem nie jest powiązane badanie.'@)
   || ZLGD.BADH();
      exec('zlgd_kwalifik','zl_wyk','P',,1)
   ?};
   ZLGD.cntx_pop()
?};
~~


\zgp_il_part
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.14]
:: OPIS: Ustala ilość zarejestrowaną do danej pozycji przewodnika i partii
::   WE: _a - ZPARN.ref()
::       _b - ZGP.ref()
::----------------------------------------------------------------------------------------------------------------------
_zparn:=_a;
_zgp:=_b;
_result:=0;
ZLGD.cntx_psh();
_names:=ZLGD.names();
{? _names.first()
|| {!
   |? ZLGD.use(_names.NAME);
      ZLGD.index('ZPARN');
      ZLGD.prefix(_zparn,_zgp);
      {? ZLGD.first()
      || {!
         |? _result+=ZLGD.IL;
            ZLGD.next()
         !}
      ?};
      _names.next()
   !}
?};
ZLGD.cntx_pop();
_result


\zlgb_add_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.14]
:: OPIS: Przed akcją 'Dołącz' w oknach wertowania ZLGB
::----------------------------------------------------------------------------------------------------------------------
VAR1.BIL:=VAR1.BIL_BRAK:=0;
1


\przel_ilosc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.14]
:: OPIS: Przelicza zapisy brygady tak, aby ilosci były jednakowe, ew. ostatni zapis wynikający z zaokrągleń
::   WE: _a - ZLGD.ref()
::----------------------------------------------------------------------------------------------------------------------
_zlgd:=_a;

_timedok:=exec('get','#params',500604,1);

Cntx.psh(ZLGD,ZLGB);
Cntx.clr(ZLGD     );

{? ZLGD.seek(_zlgd)
||
   _suma_il:=ZLGD.IL;
   _suma_br:=ZLGD.IL_BRAK;
   _sumadil:=ZLGD.DEK_IL;
   _sumadbr:=ZLGD.DEK_BR;

   ZLGB.index('ZLGD');
   ZLGB.prefix(_zlgd);

   _size:=ZLGB.size();

   {? ZLGB.first()
   || {!
      |? ZLGB.IL:={? ZLGD.ZL().TYP().WP='W'
                  || (ZLGD.IL/_size)$4
                  || (ZLGD.IL/_size)$exec('jaka_dok_m','jm',ZLGD.ZL().KTM)
                  ?};
         _suma_il-=ZLGB.IL;

         ZLGB.IL_BRAK:={? ZLGD.ZL().TYP().WP='W'
                  || (ZLGD.IL_BRAK/_size)$4
                  || (ZLGD.IL_BRAK/_size)$exec('jaka_dok_m','jm',ZLGD.ZL().KTM)
                  ?};
         _suma_br-=ZLGB.IL_BRAK;

         ZLGB.DEK_IL:={? ZLGD.ZL().TYP().WP='W'
                  || (ZLGD.DEK_IL/_size)$4
                  || (ZLGD.DEK_IL/_size)$exec('jaka_dok_m','jm',ZLGD.ZL().KTM)
                  ?};
         _sumadil-=ZLGB.DEK_IL;

         ZLGB.DEK_BR:={? ZLGD.ZL().TYP().WP='W'
                  || (ZLGD.DEK_BR/_size)$4
                  || (ZLGD.DEK_BR/_size)$exec('jaka_dok_m','jm',ZLGD.ZL().KTM)
                  ?};
         _sumadbr-=ZLGB.DEK_BR;

         _wsp:={? ZLGD.IL+ZLGD.IL_BRAK<>0
               || (ZLGB.IL+ZLGB.IL_BRAK)/(ZLGD.IL+ZLGD.IL_BRAK)
               |? ZLGD.DEK_IL+ZLGD.DEK_BR<>0
               || (ZLGB.DEK_IL+ZLGB.DEK_BR)/(ZLGD.DEK_IL+ZLGD.DEK_BR)
               |? ZLGB.ZLGD().ZGP().TPZ='T'
               || 1/_size
               || 0
               ?};
         ZLGB.TIME:=(ZLGD.TIME*_wsp)$_timedok;
         ZLGB.TIME_P:=(ZLGD.TIME_P*_wsp)$_timedok;
         exec('zlgb_kw','zl_wyk');

         ZLGB.put();
         ZLGB.next()
      !}
   ?};

:: Korekty ilości na ostatnim rekordzie
   {? ZLGB.last()
   ||
      ZLGB.IL+=_suma_il;
      ZLGB.IL_BRAK+=_suma_br;
      ZLGB.DEK_IL+=_sumadil;
      ZLGB.DEK_BR+=_sumadbr;

      _wsp:={? ZLGD.IL+ZLGD.IL_BRAK<>0
            || (ZLGB.IL+ZLGB.IL_BRAK)/(ZLGD.IL+ZLGD.IL_BRAK)
            |? ZLGD.DEK_IL+ZLGD.DEK_BR<>0
            || (ZLGB.DEK_IL+ZLGB.DEK_BR)/(ZLGD.DEK_IL+ZLGD.DEK_BR)
            |? ZLGB.ZLGD().ZGP().TPZ='T'
            || 1/_size
            || 0
            ?};
      ZLGB.TIME:=(ZLGD.TIME*_wsp)$_timedok;
      ZLGB.TIME_P:=(ZLGD.TIME_P*_wsp)$_timedok;
      exec('zlgb_kw','zl_wyk');

      ZLGB.put()
   ?}
?};

VAR1.SUM_GDIL:=ZLGD.DEK_IL;
VAR1.SUM_GDIB:=ZLGD.DEK_BR;
VAR.SUM_GBIL:=ZLGD.IL;
VAR.SUM_GBIB:=ZLGD.IL_BRAK;

Cntx.pop(ZLGD,ZLGB);
~~


\party_req
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Sprawdza czy pole z partią musi być wypełnione podczas rejestracji robocizny
::   WE: [_a] - ZL.ref - zlecenie do którego rejestrowana jest robocizna
::   WY: 0 - nie musi
::       1 - musi
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
|| _can_continue:=0
?};

{? _can_continue>0
||
   {? ZL.RP='T'
   ||
::    Zlecenie raportowane na magazyn musi mieć partię tylko w przypadku jeżeli jego produkt jest partiowany
::    Jeżeli produkt jest niepartiowany, to nie ma sensu wypełnianie pola z partią ponieważ to pójdzie na magazyn
::    i nie wiadomo czy zostanie wykorzystane do bieżącego zlecenia złożonego, czy do zupełnie innego
      {? exec('material_party','material',ZL.KTM)
      || _result:=1
      ?}
   ||
::    Zlecenie nieraportowane na magazym musi mieć partię tylko w przypadku gdy w drzewie podzleceń na jego ścieżce znajdzie
::    się zlecenie z partiami
      {? exec('party_first','zl_link')<>null()
      || _result:=1
      ?}
   ?}
?};
ZL.cntx_pop();
_result


\rej_zparn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Rejestracja wykonań - z poziomu  okna wertowania partii (tabela ZPARN)
::       Umożliwia rejestrację wykonań produkcji do zaznaczonych partii
::----------------------------------------------------------------------------------------------------------------------
{? ~exec('access','zl_wyk') || return() ?};

{? VAR.A_ZLEC().STAN<>'O'
|| FUN.info('Zlecenie: %1 nie jest otwarte, generowanie wykonań produkcji do partii niemożliwe.'@[VAR.A_ZLEC().SYM]);
   return()
?};

ZL.cntx_psh();
ZGP.cntx_psh();
ZGP.f_clear();
ZGP.clear();
_prac:=null();
_bryg:=null();
{? var_pres('_tab')>100 || obj_del(_tab) ?};
_tab:=tab_tmp(1,'REF','STRING[16]','$ZL.ref()');
exec('var_akord','zl_guide');

:: Zbieram listę operacji, jak zlecenia złożone to również zbieram operacje ze zleceń podrzędnych, które mogą rejestrować
:: wykonanie do danej partii
{? ZPARN.ZL().TREE_TYP='P'
|| _where:='ZL.REFERENCE=\''+$ZPARN.ZL+'\''
|| _where:='ZL.REFERENCE in (select :_a.REF from :_a)';
   exec('rej_zparn_zl_list','zl_wyk',ZPARN.ZL,_tab);
   _tab.REF:=$ZPARN.ZL;
   _tab.add()
?};
ZGP.f_set('ZL(SYM),NRZLP(NRPRZ),NRP,TPZ^','join ZL using(ZGP.ZL,ZL.REFERENCE) join ZGH using (ZGP.NRPRZ,ZGH.REFERENCE)',_where,_tab);

:: Tworzę okno wyświetlające listę operacji
_wer:=ZGP.mk_sel('Wybierz operację'@,,0,'zgp_zparn_oper',,,,,'U');
ZGP.win_fld(_wer,,'ZL','SYM',,18,,,'Zlecenie'@);
ZGP.win_fld(_wer,,'M','KTM',,18,,,'Produkt'@);
ZGP.win_fld(_wer,,'NRZLP','NRPRZ',,18,,,'Numer przewdonika'@);
ZGP.win_fld(_wer,,'NRP',,,3,,,'Pozycja'@);
ZGP.win_fld(_wer,,'OPIS',,,23);
ZGP.win_fld(_wer,,'ILOSC',,,15,,,'Ilość planowana'@);
ZGP.win_fld(_wer,,'IL',,,-20,,,'Przyjęte - dobre (łącznie)'@);
ZGP.win_fld(_wer,,'IL_BRAK',,,-20,,,'Przyjęte - braki (łącznie)'@);
ZGP.win_fld(_wer,VAR,'REAL3',,,-20,,,'Przyjęte - dobre (dla partii wybranych)'@);
ZGP.win_fld(_wer,VAR,'REAL4',,,-20,,,'Przyjęte - braki (dla partii wybranych)'@);
ZGP.win_sel(_wer);

ZGP.win_act(_wer,,'Formuła','Wybierz'@,,,"sel_exit()",,,,,,'W');
_fb:="
   VAR.REAL3:=0;
   VAR.REAL4:=0;
   {? var_pres('_sql')>100 || obj_del(_sql) ?};
   {? var_pres('_tab')>100 || obj_del(_tab) ?};
   {? var_pres('_sel')>100 || obj_del(_sel) ?};
   _tab:=tab_tmp(1,'REF','STRING[16]','$ZPARN.ref()');
   ZPARN.cntx_psh();
   ZPARN.clear();
   _sel:=ZPARN.sel_aget();
   {? _sel.first()
   || {!
      |?
         {? ZPARN.seek(_sel.REF)
         || _tab.REF:=$ZPARN.ref();
            _tab.add()
         ?};
        _sel.next()
      !}
   || _tab.REF:=$ZPARN.ref();
      _tab.add()
   ?};
   ZPARN.cntx_pop();
   {? _tab.size()>0
   || _sql:=sql('select SUM(ZLGD.IL) as IL,SUM(ZLGD.IL_BRAK) as IL_BRAK '
                'from @ZLGD join @ZPARN using (ZLGD.ZPARN,ZPARN.REFERENCE) '
                'join ZGP using (ZLGD.ZGP,ZGP.REFERENCE) '
                'where ZGP.REFERENCE=\\':_a\\' '
                'and ZPARN.REFERENCE in (select :_b.REF from :_b)'
                ,$ZGP.ref(),_tab);
      VAR.REAL3:=_sql.IL;
      VAR.REAL4:=_sql.IL_BRAK
   ?}
";
ZGP.win_act(_wer,,'Rekord',,,,_fb);
ZGP.actions(_wer,,'W');

{? ZGP.select()
||
:: Sprawdzam czy do wybranej operacji są utworzone karty pracy - jeśli tak to wychodzę z funkcji
   KAP.cntx_psh();
   KAP.clear();
   KAP.index('ZGP_PB');
   KAP.prefix(ZGP.ref());
   {? ~KAP.first()
   ||
::    Sprawdzam czy do operacji nie została przeprowadzona kontrola jakości w locie - jeśli tak to wychodzę z funkcji
      BADO.cntx_psh();
      BADO.index('ZGP');
      BADO.prefix(ZGP.ref());
      {? ~BADO.first()
      ||
::       Szukam PROD_REJ powiązanego z ZGP
         PROD_REJ.cntx_psh();
         PROD_REJ.index('ZGP');
         PROD_REJ.prefix('ZL',ZGP.ref());
         {? PROD_REJ.first()
         ||
            KOMM.init(250,,'Rejestracja robocizny');
::          Uzupełniam wartości zmiennej Akord
            Akord.IL_N:=ZGP.ILOSC;
            Akord.NTIME:=ZGP.NTIME;
            Akord.MTIME:=ZGP.MTIME;
::          Zapisuje poprzednie wartości zmiennych
            _pr_zlbr:=FILTER.PR_ZLBR;
            _pr_p:=FILTER.PR_P;
            _kn3:=VAR1.KN3;

            FILTER.PR_ZLBR:=null();
            FILTER.PR_P:=null();
::          VAR1.KN3 - Zmienna blokująca wyświetlanie okien podczas rejestracji wykonań z poziomu partii
            VAR1.KN3:='N';

            _sel_size:=ZPARN.sel_size();
            _sel:=ZPARN.sel_aget();
            _ii:=0;

            ZPARN.cntx_psh();
            ZPARN.prefix();
            {? _sel_size>0
            || {? _sel.first()
               || {!
                  |? _res:=1;
                     _ii+=1;
                     {? ZPARN.seek(_sel.REF,)
                     ||
::                      Jeżeli rejestracja do operacji TPZ to ostatnia rejestracja oznacza operację jako wykonaną
                        _res:=exec('rej_zparn_single','zl_wyk',{? ZGP.TPZ='T' & _ii=_sel_size || 1 || 0 ?})
                     ?};
                     _sel.next() & _res>0
                  !}
               ?}
            ||
::             Jeżeli rejestracja do operacji TPZ to oznaczam operację jako wykonaną
               exec('rej_zparn_single','zl_wyk',{? ZGP.TPZ='T' || 1 || 0 ?})
            ?};
            ZPARN.cntx_pop();
            ZPARN.sel_adel();
::          Przywracam wcześniejsze wartości zmiennych
            FILTER.PR_ZLBR:=_pr_zlbr;
            FILTER.PR_P:=_pr_p;
            VAR1.KN3:=_kn3;

            KOMM.select()
         ?};
         PROD_REJ.cntx_pop()
      || FUN.info('Do operacji przeprowadzono kontrolę jakości w locie — nie można rejestrować wykonania z tego poziomu.')
      ?};
      BADO.cntx_pop()
   || FUN.info('Do operacji wygenerowano karty pracy — nie można rejestrować wykonania z tego poziomu.')
   ?};
   KAP.cntx_pop()
?};
ZGP.f_clear();
ZGP.cntx_pop();
ZL.cntx_pop();
~~


\rej_zparn_single
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Rejestruje wykonanie do pojedyńczej partii
::       Kontekst pracy: rekord ZGP, rekord ZPARN
::       _a - Czy zakończyć operację: 1 - Tak, [0] - Nie
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_txt:='';
_zak_op:={? var_pres('_a')>0 || _a || 0 ?};
:: czy_koniec - czy zakończyć przetwarzenie pętli po partiach po zarejestrowaniu tego wykonania
_czy_koniec:=0;
:: Podczytanie aktualnych wartości ZGP,PROD_REJ i ZPARN
ZGP.get();
ZPARN.get();
PROD_REJ.get();
:: Wyznaczenie ilosci maksymalnej mozliwej do zarejestrowania
exec('vprodrej_fill','prod_rej');

_il:=0;
_il_dorej_zgp:=VPRODREJ.IL_POP-ZGP.IL-ZGP.IL_BRAK-ZGP.DEK_IL-ZGP.DEK_BR;
{? _il_dorej_zgp<0 || _il_dorej_zgp:=0 ?};
_il_max_zgp:=PROD_REJ.ZGP().ILOSC-ZGP.IL-ZGP.IL_BRAK-ZGP.DEK_IL-ZGP.DEK_BR;
{? _il_max_zgp<0 || _il_max_zgp:=0 ?};
::_procent:=ZPARN.IL/exec('FindAndGet','#table',ZL,ZPARN.ZL,,"ZL.IL",1);
_il_zgp_zparn_raw:=(exec('FindAndGet','#table',ZL,ZGP.ZL,,"ZL.IL",1)*
                   ZPARN.IL/exec('FindAndGet','#table',ZL,ZPARN.ZL,,"ZL.IL",1));
{? _il_zgp_zparn_raw>ZGP.ILOSC || _il_zgp_zparn_raw:=ZGP.ILOSC ?};
_dokl:=exec('jaka_dok_m','jm',PROD_REJ.M);
_il_zgp_zparn:={? _dokl>0
               || (_il_zgp_zparn_raw)$_dokl
               || ceil(_il_zgp_zparn_raw)
               ?};
_il_dorej_zparn:=_il_zgp_zparn-exec('zgp_il_part','zl_wyk',ZPARN.ref(),ZGP.ref);

{? ZGP.TPZ<>'T'
|| {? _il_dorej_zparn<=0
   || KOMM.add('Do partii %1 zostały już zarejstrowane wszystkie wykonania.'@[ZPARN.SYM],2);
      return(1)
   |? (exec('get','#params',500631,2)='T' | exec('get','#params',500634,2)='T') & VPRODREJ.MAX & _il_dorej_zgp=0
   || KOMM.add('Rejestracja niemożliwa — najpierw należy zarejestrować operacje poprzedzające.'@,3);
      return(0)
   |? ~(exec('get','#params',500631,2)='T' | exec('get','#params',500634,2)='T') & _il_max_zgp=0
   || KOMM.add('Rejestracja niemożliwa — Do operacji zarejestrowano już całą ilość.'@,3);
      return(0)
   |? (exec('get','#params',500631,2)='T' | exec('get','#params',500634,2)='T')
         & VPRODREJ.MAX & _il_dorej_zparn>_il_dorej_zgp
   || _il:=_il_dorej_zgp;
      _czy_koniec:=1;
      _txt:='Zarejestrowano częściowe wykonanie do partii %1 na ilość %2 (pozostała ilość z poprzedniej operacji).'
            ' Dalsze przetwarzanie zostanie zakończone.'@[ZPARN.SYM,$_il]
   |? ~(exec('get','#params',500631,2)='T' | exec('get','#params',500634,2)='T') & _il_dorej_zparn>_il_max_zgp
   || _il:=_il_max_zgp;
      _czy_koniec:=1;
      _txt:='Zarejestrowano częściowe wykonanie do partii %1 na ilość %2 (pozostała ilość na operacji).'
            ' Dalsze przetwarzanie zostanie zakończone.'@[ZPARN.SYM,$_il]
   || _il:=_il_dorej_zparn;
      {? _il<>_il_zgp_zparn
      || _txt:='Partia %1 posiada już zarejestrowane wykonania. Zarejestrowano wykonanie do partii na ilość pozostałą (%2).'@[ZPARN.SYM,$_il]
      ?}
   ?}
?};
{? ZGP.TPZ='T' | _il>0
||
:: Przygotowuje dane
   {? var_pres('_args')>100 || obj_del(_args) ?};
   VPRODREJ.IL:={? ZGP.TPZ='T'
                || 0
                || _il
                ?};
   VPRODREJ.IL_BRAK:=0;
   VPRODREJ.ZPARN:=ZPARN.ref();
   _wsp:={? ZGP.FIX_NORM='T'
         || 1
         |? Akord.IL_N<>0 & ZGP.TPZ='N'
         || (VPRODREJ.IL)/Akord.IL_N
         || 1
         ?};
   _timedok:=exec('get','#params',500604,1);
   VPRODREJ.TIME:={? Akord.NTIME<>0
                  || (Akord.NTIME*_wsp)$_timedok
                  || (Akord.MTIME*_wsp)$_timedok
                  ?};
   VPRODREJ.OK:={? _zak_op>0 || 'T' || 'N' ?};
   _res:=exec('wykon_4rej','zl_wyk');
   {? _res>0
   || {? _txt<>''
      || KOMM.add(_txt,{? _czy_koniec>0 || 3 || 2 ?});
         {? _czy_koniec>0 || _res:=0 ?}
      || {? ZGP.TPZ='T'
         || KOMM.add('Zarejestrowano wykonanie operacji TPZ do partii %1.'@[ZPARN.SYM],1)
         || KOMM.add('Zarejestrowano wykonanie do partii %1 na ilość %2.'@[ZPARN.SYM,$_il],1)
         ?}
      ?}
   |? _res=0
   || KOMM.add('Wystąpił błąd podczas rejestracji wykonania do partii %1. Dalsze przetwarzanie zostanie zakończone.'@[ZPARN.SYM],3)
   ?}
?};
_res


\rej_zparn_zl_list
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Wyszukuje listę zleceń, które mogą rejestrować wykonianie do partii wskazanego zlecenia
::   WE: _a - ZL.ref() - zlecenie, do partii którego będą wykonywane rejestracje
::       _b - tabela z refami zleceń
::   WY: tabela z refami (pod)zleceń
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_tab:={? var_pres('_b')>100 || _b || tab_tmp(1,'REF','STRING[16]','$ZL.ref()')  ?};
ZL.cntx_psh();
{? ZL.seek(_zl)
||
:: Odrzucam zlecenia partiowane i raportowane na magazyn
   _party:=exec('zlec_party','zl_common',ZL.ref());
   {? ZL.ref()<>ZPARN.ZL & ZL.RP='N' & _party=0
   || _tab.REF:=$ZL.ref();
      _tab.add()
   ?};
   {? (ZL.ref()=ZPARN.ZL) | (ZL.ref()<>ZPARN.ZL & _party=0)
   ||
::    Przechodzę po podzleceniach
      ZL.cntx_psh();
      ZL.index('NRPZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |?
::          !!! REKURENCJA !!!
            exec('rej_zparn_zl_list','zl_wyk',ZL.ref(),_tab);
            ZL.next()
         !}
      ?};
      ZL.cntx_pop()
   ?}
?};
ZL.cntx_pop();
_tab


\env_rej_mat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Buduje środowisko do rozliczania surowców nielimitowanych przy rejestracji wykonania produkcji
::   WE: _a - NUMBER - typ okna: [0] - pojedyncze(Merit ERP), 1 - grupowe (ekiosk)
::            , 2 - grupowe (ekiosk)-limity, -2 2 - grupowe (ekiosk)-limity(palety)
::----------------------------------------------------------------------------------------------------------------------
_type:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_mgp:={? _type=-2 || _type:=2; 1 || 0 ?};

{? var_pres('__ENV_REJ')>100 || obj_del(__ENV_REJ) ?};
__ENV_REJ:=_env:=obj_new('TAB','WER','EDIT','TAB_N','WER_N','TAB_Z','WER_Z','RED_Z','TAB_P','WER_P'
                         ,'NDX','NDX2','NDX3','NDX4','NDX_N','NDX_Z1','NDX_Z2'
                         ,'GEN','ZGP','WHERE','TYPE','ZLGD','MGP');
:: GEN - czy generować na nowo rozpiskę jeżeli zmieniono ilość: [1] - tak, 0 - nie
:: WHERE - miejsce wywołąnia: 1 - zakańczanie rejestracji wykonania, 0 - start operacji
_env.GEN:=1;
_env.WHERE:=1;
_env.TYPE:={? _type=2 || 1 || 0 ?};
_env.MGP:=_mgp;
_env.ZGP:=null();
_env.ZLGD:=null();
_env.TAB:=_tab:=tab_tmp(2,
      'KTM','STRING[50]','Indeks materiału',
      'M','STRING[100]','Nazwa materiału',
      'IL','REAL','Ilość',
      'LIL','REAL','Limit ilościowy(ZLIM.LIL)',
      'JM','STRING[10]','Jednostka miary',
      'MG','STRING[8]','Magazyn',
      'STAN','REAL','Stan magazynu',
      'MREF','STRING[16]','M.ref',
      'MGREF','STRING[16]','MG.ref',
      'TMATREF','STRING[16]','TMAT.ref',
      'ZLIMREF','STRING[16]','ZLIM.ref',
      'ZLREF','STRING[16]','ZL.ref',
      'DKCREF','STRING[16]','DK_C.ref',
      'RSC','STRING[16]','Ref SQL dostawy',
      'RSC_OLD','STRING[16]','Ref SQL dostawy wyznaczony przy starcie operacji',
      'SCEAN','STRING[128]','Kod identyfikujący dostawę',
      'KODPAL','STRING[30]','Kod palety',
      'SC_DATE','DATE','Data dostawy',
      'EANLREF','STRING[16]','Ref lokalizacji - $EANL.ref()',
      'REJ_MAT','STRING[16]','',
      'ZRPREF','STRING[16]','$__zknrea.ref()',
      'ZK_RP','STRING[16]','$ZK_RP.ref()',
      'PAL','STRING[16]','PAL.ref()',
      'PAL_POZ','STRING[16]','PAL.POZ.ref()',
      'KOD','STRING[30]','Paleta',
      'LOK','STRING[30]','Lokalizacja',
      'ILW','REAL','Ilość wydana',
      'REFTYM','STRING[16]','Wskazanie'
);
_env.TAB_N:=_tab2:=tab_tmp(3,
      'MG','STRING[8]','Magazyn',
      'KTM','STRING[50]','Indeks materiału',
      'M','STRING[100]','Nazwa materiału',
      'MREF','STRING[16]','$M.ref()',
      'IL','REAL','Ilość',
      'LIL','REAL','Limit ilościowy(ZLIM.LIL)',
      'JM','STRING[10]','Jednostka miary',
      'STAN','REAL','Stan magazynu',
      'MGREF','STRING[16]','$MG.ref()',
      'TMATREF','STRING[16]','$TMAT.ref()',
      'ZLIMREF','STRING[16]','$ZLIM.ref()',
      'ZLREF','STRING[16]','$ZL.ref()',
      'DKCREF','STRING[16]','$DK_C.ref()',
      'ZRPREF','STRING[16]','$__zknrea.ref()'
);
_tab.fld_attr(,2);
_tab2.fld_attr(,2);
_tab.fld_fml('SC_DATE','BEFORE_DISPLAY',"{? cur_tab(1,1).SC_DATE<>date(0,0,0) || 1 || 0 ?}");
::_tab.fld_fml('IL','EDIT_FORMAT',"'in_prec='+$ST.DOKL");
_env.NDX:=_tab.ndx_tmp(,,'MREF',,);
_env.NDX2:=_tab.ndx_tmp(,,'MREF',,,'MGREF',,,'SCEAN',,,'EANLREF',,);
_env.NDX3:=_tab.ndx_tmp(,,'ZRPREF',,);
_env.NDX4:=_tab.ndx_tmp(,,'MREF',,,'MGREF',,,'KODPAL',,,'EANLREF',,,'RSC',,);
_env.NDX_N:=_tab2.ndx_tmp(,,'MREF',,);
{? _type=0
|| _env.WER:=_wer:=_tab.mk_sel('Surowce'@,'P',,'sur_wer'+$_env.TYPE,,,,,'U','T');
   _tab.win_fld(_wer,,'KTM',,,-16,,1,'Indeks materiału'@);
   _tab.win_fld(_wer,,'M',,,-20,,1,'Nazwa materiału'@);
   _tab.win_fld(_wer,,'JM',,,-5,,1,'jm'@);
   _tab.win_fld(_wer,,'LIL',,,-12,ST.DOKL,1,'Norma brutto'@);
   _tab.win_fld(_wer,,'IL',,,,ST.DOKL,,'Ilość pobrana'@);
   {? VEK.TERM='T' | VAR1.ZAK_EK='T'
   || _tab.win_fld(_wer,VAR,'STRING',,,20,,,'Kod identyfikujący'@,,'Kod dostawy/palety'@)
::   _tab.win_fld(_wer,,'EANLREF',,,20,,,'Lokalizacja'@)
   ?};
   _tab.win_fld(_wer,,'MG',,,,,,'Magazyn'@);
   _tab.win_fld(_wer,,'STAN',,,,ST.DOKL,1,'Stan dostępny'@);
   _tab.win_sel(_wer)
|| _env.WER_N:=_wer2:=_tab2.mk_sel('Surowce'@,'P',,'sur_wer_n'+$_env.TYPE,,,,,'P','T');
   _tab2.win_fld(_wer2,,'KTM',,,-14,,1,'Indeks materiału'@);
   _tab2.win_fld(_wer2,,'M',,,-15,,1,'Nazwa materiału'@);
   _tab2.win_fld(_wer2,,'JM',,,-4,,1,'jm'@);
   _tab2.win_fld(_wer2,,'LIL',,,-12,ST.DOKL,,{? _type=2 || 'Pozostało'@ || 'Norma brutto'@ ?});
   _tab2.win_fld(_wer2,,'IL',,,-12,ST.DOKL,,{? _type=2 || 'Do realizacji'@ || 'Ilość pobrana'@ ?});
   {? ~_mgp
   || _env.WER:=_wer:=_tab.mk_sel('Pozycje'@,'P',,'sur_wer_p3',,,,,'P','T');
      _tab.win_fld(_wer,VAR,'STRING',,,-16,,,'Kod identyfikujący'@,,'Kod dostawy/palety'@);
      _tab.win_fld(_wer,,'IL',,,-12,ST.DOKL,,{? _type=2 || 'Zarezerwowano'@ || 'Ilość pobrana'@ ?});
::    _tab.win_fld(_wer,,'JM',,,-4,,1,'jm'@);
      _tab.win_fld(_wer,,'MG',,,-8,,,'Magazyn'@)
   || _env.WER:=_wer:=_tab.mk_sel('Pozycje'@,'P',,'sur_wer_p'+$_env.TYPE,,,,,'P','T');
      _tab.win_fld(_wer,,'KOD',,,-20,,,'Paleta/Indeks'@,,'Kod palety lub indeks dla rozpakowania'@);
      _tab.win_fld(_wer,,'LOK',,,-20,,,'Lokalizacja/Paleta'@,,'Lokalizacja lub paleta dla rozpakowania'@);
::      _tab.win_fld(_wer,,'JM',,,-4,,1,'jm'@)
      _tab.win_fld(_wer,,'ILW',,,-12,ST.DOKL,,'Rozpakowano'@);
      _tab.fld_fml('ILW','DISPLAY_FORMAT',"{? cur_tab(1,1).ILW=0 || 'empty=1' || 'empty=0' ?}")
   ?};
::   _tab.win_fld(_wer,,'STAN',,,,ST.DOKL,1,'Stan dostępny'@);
   _tab.win_sel(_wer);
   _tab2.win_sel(_wer2);
   {? _type<>2
   || _before:="
         _tab:=__ENV_REJ.TAB;
         _tab2:=__ENV_REJ.TAB_N;
::       Wyliczenie sumarycznej ilości pobranej, ustawienie prefixu na tabelę z pozycjami
         _sum:=0;
::      _ref:=_tab.ref();
         _tab.index(__ENV_REJ.NDX);
         _tab.prefix(_tab2.MREF);
         _tab.cntx_psh();
         {? _tab.first()
         || {!
            |?
               _sum+=_tab.IL;
               _tab.next()
            !}
         ?};
         _tab.cntx_pop();
::      _tab.seek(_ref);
         _tab2.IL:=_sum;
         _tab2.put();
         ~~
      ";
      _tab2.win_act(_wer2,,'Rekord',,,,_before)
   ?};
   {? VEK.TERM='T'
   || _before:="
         _tab:=cur_tab(1,1);
         VAR.STRING:={? _tab.PAL<>'' || _tab.KODPAL || _tab.SCEAN ?};
         ~~
      ";
      _tab.win_act(_wer,,'Rekord',,,,_before)
   ?}
?};

_valid:="
   _res:='key:F2';
   _tab:=__ENV_REJ.TAB;

   {? (_chk:=__CHK.record3(VAR,'A_MAG','Magazyn'@))<>''
   || _res:='edit:'+_chk
   |? _tab.IL<0
   || FUN.info('Ilość powinna być większa od zera.'@);
      _res:='edit:IL'
   |? _tab.IL>VAR.REAL
   || FUN.info('W wybranym magazynie nie ma wystarczającej ilości surowców.\n'
               'Należy wskazać inny magazyn lub zmniejszyć ilość rozliczanego surowca.'@);
      _res:='edit:IL'
   ||
::    Brak błędów, przypisuje magazyn i jego aktualny stan
      __ENV_REJ.GEN:=0;
      _tab.MG:=VAR.A_MAG().SYM;
      _tab.MGREF:=$VAR.A_MAG;
      _tab.STAN:=VAR.REAL
   ?};
   _res
";

{? VEK.TERM<>'T' & VAR1.ZAK_EK<>'T'
||
   _formula:="
      _tab:=__ENV_REJ.TAB;
      _ktm:=exec('FindAndGet','#table','M',_tab.MREF,,\"M.ref\",null);
      _dk_c:=exec('FindAndGet','#table','DK_C',_tab.DKCREF,,\"DK_C.ref\",null);
      _mg:=VAR.A_MAG:=exec('FindInSet','#table','MG','MAGAZYNY',_tab.MG,,,,,null);
      _zl:=exec('FindAndGet','#table','ZL',_tab.ZLREF,,\"ZL.ref\",null);
::    Sprawdzam dostępny stan magazynowy dla podanej pozycji
      {? _dk_c<>null()
      || exec('obl_stan','magazyn_stan',_ktm,1,_mg,,,date(),-2,,,,_dk_c)
      || exec('obl_stan','magazyn_stan',_ktm,1,_mg,,,date(),-2)
      ?};

      _valid:=\"
         _res:='key:F2';
         _tab:=__ENV_REJ.TAB;

         {? (_chk:=__CHK.record3(VAR,'A_MAG','Magazyn'@))<>''
         || _res:=_chk
         |? _tab.IL<0
         || FUN.info('Ilość powinna być większa od zera.'@);
            _res:='IL'
         |? _tab.IL>VAR.REAL
         || FUN.info('W wybranym magazynie nie ma wystarczającej ilości surowców.\n'
                     'Należy wskazać inny magazyn lub zmniejszyć ilość rozliczanego surowca.'@);
            _res:='IL'
         ||
::          Brak błędów, przypisuje magazyn i jego aktualny stan
            __ENV_REJ.GEN:=0;
            _tab.MG:=VAR.A_MAG().SYM;
            _tab.MGREF:=$VAR.A_MAG;
            _tab.STAN:=VAR.REAL
         ?};
         _res
      \";

      VAR.REAL:=BEER.SD;
      VAR.REAL+=exec('zlim_il_rez','zl_nlimit',_tab.ZLIMREF);
      {? _tab.edit(_valid)
      || _tab.put()
      ?};
      ~~
   ";
   _tab.win_act(_wer,,'Formuła','Popraw'@,,,_formula,,1);
   _tab.win_act(_wer,,'Formuła','Zamienniki'@,,,"params_exec('sur_show_zam','zl_nlimit',0)",,,,,,'Z');
   task_attach('TTE_PZL_DLIM')
?};

_env.EDIT:=_edit:=_tab.mk_edit('Surowiec'@,,'sur_edit');
_tab.win_efld(_edit,,'IL',,,20,ST.DOKL,,'Ilość pobrana'@);
_tab.win_efld(_edit,VAR,'A_MAG','SYM','MAG',17,,,'Magazyn'@);
_tab.win_efld(_edit,,'LIL',,,20,ST.DOKL,1,'Norma brutto'@);
_tab.win_efld(_edit,VAR,'REAL',,,20,ST.DOKL,1,'Stan magazynu'@);
_tab.efld_opt(_edit,'mark=1',VAR,'A_MAG');

exec('ok_esc','#window',_tab,_edit,,_valid);
_tab.win_edit(_edit);

:: Pozycje palety
_env.TAB_P:=_pal:=tab_tmp(3,
      'KODK','STRING[30]','Kod palety',
      'KTM','STRING[50]','Indeks materiału',
      'M','STRING[100]','Nazwa materiału',
      'MREF','STRING[16]','$M.ref()',
      'IL','REAL','Ilość',
      'ILC','REAL','Ilość całkowita',
      'ILP','REAL','Ilość pozostała',
      'JM','STRING[10]','Jednostka miary',
      'DKCREF','STRING[16]','$DK_C.ref()',
      'PAL','STRING[16]','$PAL.ref()',
      'PAL_POZ','STRING[16]','$PAL_PZ.ref()',
      'MGREF','STRING[16]','$MG.ref()',
      'EANLREF','STRING[16]','$EANL.ref()',
      'RSC','STRING[16]','Ref SQL dostawy',
      'LIL','REAL','Limit ilościowy (Norma brutto)',
      'ZLIMREF','STRING[16]','$ZLIM.ref()'
);
_env.WER_P:=_werp:=_pal.mk_sel('Pozycje palety'@,'P',,'sur_wer_p'+$_env.TYPE,,,,,'P','T');
_pal.win_fld(_werp,,'KTM',,,-20,,1,'Indeks materiału'@);
_pal.win_fld(_werp,,'M',,,-30,,1,'Nazwa materiału'@);
_pal.win_fld(_werp,,'JM',,,-4,,1,'jm'@);
_pal.win_fld(_werp,,'ILP',,,-12,ST.DOKL,,'Pozostało'@);
_pal.win_fld(_werp,,'IL',,,-12,ST.DOKL,,{? _type=2 || 'Do realizacji'@ || 'Ilość pobrana'@ ?});
_pal.fld_attr(,2);
_pal.win_sel(_env.WER_P);

::Zamienniki
_env.TAB_Z:=_zam:=tab_tmp(3,
   'KTM','STRING[50]','Indeks',
   'NAZ','STRING[106]','Nazwa',
   'MAGSYM','STRING[8]','Symbol magazynu',
   'MAGNAME','STRING[100]','Nazwa magazynu',
   'ILOSC','REAL','Ilość',
   'JM','STRING[10]','jm',
   'MAG','STRING[16]','$MG.ref()',
   'TYP','STRING[25]','Typ zamiennika',
   'MREF','STRING[16]','$M.ref()',
   'SD','REAL','Stan dostępny',
   'GRP','STRING[10]','Grupa technologiczna',
   'LIL','REAL','Limit ilościowy (Norma brutto)'
);
_env.NDX_Z1:=_zam.index('?');
_env.NDX_Z2:=_zam.ndx_tmp(,,'MREF',,);

_zam.fld_fml('ILOSC','EDIT_FORMAT',"'in_prec='+$VAR.A_T().DOKL");
_zam.fld_fml('ILOSC','DISPLAY_FORMAT',"'out_prec='+{? (2+cur_kwin())='e_' || $VAR.A_T().DOKL || $ST.DOKL ?}");
_zam.fld_fml('LIL','EDIT_FORMAT',"'in_prec='+$VAR.A_T().DOKL");
_zam.fld_fml('LIL','DISPLAY_FORMAT',"'out_prec='+{? (2+cur_kwin())='e_' || $VAR.A_T().DOKL || $ST.DOKL ?}");

_env.WER_Z:=_zam.mk_sel('Zamienniki surowca'@,'P',,'#sur_wer_z',,,15,,'U',,,,,'html_maximized');
_zam.win_fld(_env.WER_Z,,'KTM',,,25,,1,'Indeks materiału'@);
_zam.win_fld(_env.WER_Z,,'NAZ',,,45,,1,'Nazwa'@);
_zam.win_fld(_env.WER_Z,,'JM',,,5,,1,'jm'@);
_zam.win_fld(_env.WER_Z,,'LIL',,,12,ST.DOKL,,'Norma brutto'@);
_zam.win_fld(_env.WER_Z,,'ILOSC',,,12,ST.DOKL,,'Ilość pobrana'@);
_zam.win_fld(_env.WER_Z,,'MAGSYM',,,8,,1,'Magazyn'@);
_zam.win_fld(_env.WER_Z,,'SD',,,15,,1,'Stan dostępny'@);

_formula:="
   _env:=__ENV_REJ;
   _tab:=_env.TAB;
   {? exec('spr_zam','zl_nlimit')>0
   || sel_exit()
   ||
::    Nie udało się zmodyfikować rekordu, przywrócenie wartości bufora
      _tab.get()
   ?}
";
_zam.win_act(_env.WER_Z,,'Formuła','Wybierz'@@,,,,_formula,1);
_zam.win_act(_env.WER_Z,,'Popraw');

_before:="
   _tab:=cur_tab(1,1);
   VAR.A_T:=exec('FindAndGet','#table',M,_tab.MREF,,,null());
   ~~
";
_after:="
   _tab:=cur_tab(1,1);
   _res:=exec('zam_valid','zl_nlimit',_tab,0);
   _res
";
_zam.win_act(_env.WER_Z,,'Rekord',,,,_before,_after);

_formula:="
   M.cntx_psh();
   M.clear();
   {? M.seek(cur_tab(1,1).MREF)
   || exec('info_zam','magazyn_stan',3)
   ?};
   M.cntx_pop();
   ~~
";
_zam.win_act(_env.WER_Z,,'Formuła','Szczegóły'@@,,,,_formula);
_zam.win_act(_env.WER_Z,,'Kolejność');
_zam.win_sel(_env.WER_Z);

_env


\find_zlgd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Wyszukuje wykonania produkcji, do których zostały utworzone rozpiski rozliczeń surowców
::----------------------------------------------------------------------------------------------------------------------
_env_gen:=__ENV_GEN;
params_set('env_gen',_env_gen);

_dk:=_env_gen.DK.TAB;
_dk_ndxref:=_env_gen.DK.NDXREF;
_dk_ndxzl:=_env_gen.DK.NDXZL;
_sur_ndxscean:=_env_gen.SUR.NDXSCEAN;
_sur_ndxpal:=_env_gen.SUR.NDXKODPAL;
_sur:=_env_gen.SUR.TAB;
_sur.cntx_psh();
_sur.index(_sur_ndxscean);
_sur.prefix();

::{? exec('top_rodzaj','zl_link',ZL.ref())='N'
::|| _top:=ZL.ref();
::   _top_sym:=ZL.SYM
::|| _top:=exec('top_level','zl_link',ZL.ref());
::   _top_sym:=exec('FindAndGet','#table',ZL,_top,,"SYM",'')
::?};

:: ZASILENIE
REZ.cntx_psh();
_rez_mask:=(REZ.name()-2)+'__';
{? REZ.name()<>_rez_mask || REZ.use(_rez_mask) ?};
REZ.index('ZLREZP2');
REZ.prefix(ZL.ref(),'S','R','T');
{? REZ.first()
|| {!
   |?
      {? REZ.REFREA<>''
      || _dk.index(_dk_ndxref);
         _dk.prefix(REZ.REFREA);
         {? ~_dk.first()
         || _dk.blank(1);
            _dk.ZLEC:=ZL.SYM;
            _dk.M:=ZL.KTM().KTM;
            _dk.JM:=ZL.KTM().J().KOD;
            _dk.IL:=exec('FindAndGet','#table',ZLGD,REZ.REFREA,,"ZLGD.IL+ZLGD.IL_BRAK+ZLGD.DEK_IL+ZLGD.DEK_BR",0);
            _dk.DT:=exec('FindAndGet','#table',ZLGD,REZ.REFREA,,"ZLGD.DT",date(0,0,0));
            _dk.ZL_REF:=$ZL.ref();
            _dk.REF:=REZ.REFREA;
            _dk.ZGH_REF:=exec('FindAndGet','#table',ZGP,REZ.ZGP,,"$ZGP.NRPRZ",'');
            _dk.OPER:=exec('FindAndGet','#table',ZGP,REZ.ZGP,,"'Operacja '+$ZGP.NRP+': '+ZGP.OPIS",'');
            _dk.PRAC:=exec('FindAndGet','#table',ZLGD,REZ.REFREA,,
               "{? ZLGD.BP='B' || ZLGD.B().KOD || ZLGD.P().OSOBA().NAZWISKO + ' ' + ZLGD.P().OSOBA().PIERWSZE ?}",'');
            _dk.SYMBOL:=exec('FindAndGet','#table',ZGH,_dk.ZGH_REF,,"ZGH.NRPRZ",'');
            _dk.add()
         ?};
         _jest:=0;
         {? REZ.KODPAL<>''
         || _sur.index(_sur_ndxpal);
            _jest:=_sur.find_key(#_dk.ref(),REZ.ZLIM,#REZ.MG,REZ.KODPAL,REZ.ZD_POZ,REZ.SC)
         || _sur.index(_sur_ndxscean);
            _jest:=_sur.find_key(#_dk.ref(),REZ.ZLIM,#REZ.MG
                          ,exec('FindAndGet','#table',DK,REZ.SC,,"DK.SCEAN",''),REZ.ZD_POZ)
         ?};
         {? _jest>0
         || _sur.ILOSC+=REZ.ILR;
            _sur.RAP_IL+=REZ.ILR;
            _sur.put()
         || _sur.blank(1);
            _sur.REFDK:=#_dk.ref();
            _zlim:=REZ.ZLIM;
            _sur.MAT:=#REZ.M;
            _sur.ZLIM:=_zlim;
            _sur.KTM:=REZ.M().KTM;
            _sur.NAZ:=REZ.M().N;
            _sur.JM:=REZ.M().J().KOD;
            _sur.ILOSC:=REZ.ILR;
            _sur.ZPARN:=exec('FindAndGet','#table',ZLGD,REZ.REFREA,,"$ZLGD.ZPARN",'');
            _sur.PARSYM:=exec('FindAndGet','#table',ZPARN,_sur.ZPARN,,"ZPARN.SYM",'');
            _sur.REJ_MAT:='T';
            ZLIM.cntx_psh();
            {? ZLIM.name()<>ref_name(_zlim) || ZLIM.use(ref_name(_zlim)) ?};
            ZLIM.prefix();
            {? ZLIM.seek(_zlim)
            || ZL.cntx_psh();
               _sur.ZL:=#ZLIM.ZLEC;
               _sur.ZL_SYM:=ZLIM.ZLEC().SYM;
               _sur.ZL_REF:=$ZLIM.ZLEC;
               _sur.WYD:=#ZLIM.WYD;
               _sur.DK_C:=$ZLIM.DK_C;
               _sur.ZLEC:=#ZLIM.ZLEC;
               _sur.ZLDOD:=#ZLIM.ZLDOD;
               ZL.cntx_pop()
            ?};
            ZLIM.cntx_pop();
            _sur.MAG:=#REZ.MG;
            _sur.MAGNAME:=REZ.MG().NAZ;
            _sur.MAGSYM:=REZ.MG().SYM;
            _sur.AUTO:='T';
            ZGP.cntx_psh(); ZGH.cntx_psh();
            ZGP.prefix();
            {? ZGP.seek(REZ.ZGP)
            || _sur.ZGP:=#ZGP.ref();
               _sur.ZGP_NAME:=ZGP.NRZLP().NRPRZ+' '+exec('separator','zl_limit')+' '+$ZGP.NRP;
               _sur.ZGP_OPIS:=ZGP.OPIS;
               _sur.ZGH_IL:=ZGP.NRPRZ().ILNPRZ
            ?};
            ZGP.cntx_pop(); ZGH.cntx_pop();
            _sur.RAP_IL:=REZ.ILR;
            _sur.RSC:=REZ.SC;
            _sur.KODPAL:=REZ.KODPAL;
            _sur.SCEAN:=
               {? _sur.KODPAL='' & _sur.RSC<>''
               || exec('FindAndGet','#table',DK,REZ.SC,,"DK.SCEAN",'')
               || ''
               ?};
            _sur.EANL:=REZ.ZD_POZ;
::          Sprawdzenie, czy do surowca istnieją rezerwacje dedykowana do nielimitów
            {? exec('zlim_il_rez','zl_nlimit',_zlim)>0
            || _sur.CZY_REZ:=1
            ?};
            _sur.add()
         ?}
      ?};
      REZ.next()
   !}
?};
REZ.cntx_pop();
_sur.cntx_pop();
~~


\fill_zlgd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Tworzy i wypełnia zmienna środowiskową do rozliczeń surowców nielimiowanych na podstawie zarezerowoanych
::       pobrań surowców do przekazanego rekordu ZLGD
::   WE: _a - $ZLGD.ref
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_zlgd:={? var_pres('_a')=type_of(null) || _a || null ?};
{? _zlgd<>null
|| ZLGD.cntx_psh();
   _msk:=ref_name(_zlgd);
   {? ZLGD.name()<>_msk || ZLGD.use(_msk) ?};
   ZLGD.prefix();
   {? ZLGD.seek(_zlgd)
   || _env_gen:=params_get().env_gen;
      _dk:=_env_gen.DK.TAB;
      _dk_ndxref:=_env_gen.DK.NDXREF;
      _dk_ndxzl:=_env_gen.DK.NDXZL;
      _sur:=_env_gen.SUR.TAB;

::    ZASILENIE
      REZ.cntx_psh();
      REZ.index('ZLREZR');
      REZ.prefix(ZLGD.ZL,'S','R',$ZLGD.ref(),);
      {? REZ.first()
      || _res:=1;
         _dk.blank(1);
         _dk.ZLEC:=ZLGD.ZL().SYM;
         _dk.M:=ZLGD.ZL().KTM().KTM;
         _dk.JM:=ZLGD.ZL().KTM().J().KOD;
         _dk.IL:=ZLGD.IL+ZLGD.IL_BRAK+ZLGD.DEK_IL+ZLGD.DEK_BR;
         _dk.DT:=ZLGD.DT;
         _dk.ZL_REF:=$ZLGD.ZL;
         _dk.REF:=$ZLGD.ref;
         _dk.ZGH_REF:=$ZLGD.ZGH;
         _dk.OPER:='Operacja '+$ZLGD.ZGP().NRP + ': '+ ZLGD.ZGP().OPIS;
         _dk.PRAC:={? ZLGD.BP='B' || ZLGD.B().KOD || ZLGD.P().OSOBA().NAZWISKO + ' ' + ZLGD.P().OSOBA().PIERWSZE ?};
         _dk.SYMBOL:=exec('FindAndGet','#table',ZGH,_dk.ZGH_REF,,"ZGH.NRPRZ",'');
         _dk.add();
         {!
         |?
            _sur.blank(1);
            _zlim:=REZ.ZLIM;
            _sur.REFDK:=#_dk.ref();
            _sur.MAT:=#REZ.M;
            _sur.ZLIM:=_zlim;
            _sur.KTM:=REZ.M().KTM;
            _sur.NAZ:=REZ.M().N;
            _sur.JM:=REZ.M().J().KOD;
            _sur.ILOSC:=REZ.ILR;
            _sur.ZPARN:=$ZLGD.ZPARN;
            _sur.PARSYM:=exec('FindAndGet','#table',ZPARN,ZLGD.ZPARN,,"ZPARN.SYM",'');
            _sur.REJ_MAT:='T';

            ZLIM.cntx_psh();
            {? ZLIM.name()<>ref_name(_zlim) || ZLIM.use(ref_name(_zlim)) ?};
            ZLIM.prefix();
            {? ZLIM.seek(_zlim)
            || _sur.ZL:=#ZLIM.ZLEC;
               _sur.ZL_SYM:=ZLIM.ZLEC().SYM;
               _sur.ZL_REF:=$ZLIM.ZLEC;
               _sur.WYD:=#ZLIM.WYD;
               _sur.DK_C:=$ZLIM.DK_C;
               _sur.ZLEC:=#ZLIM.ZLEC;
               _sur.ZLDOD:=#ZLIM.ZLDOD
            ?};
            ZLIM.cntx_pop();
            _sur.MAG:=#REZ.MG;
            _sur.MAGNAME:=REZ.MG().NAZ;
            _sur.MAGSYM:=REZ.MG().SYM;
            _sur.AUTO:='T';
            ZGP.cntx_psh();ZGH.cntx_psh();
            ZGP.prefix();
            {? ZGP.seek(REZ.ZGP)
            || _sur.ZGP:=#ZGP.ref();
               _sur.ZGP_NAME:=ZGP.NRZLP().NRPRZ+' '+exec('separator','zl_limit')+' '+$ZGP.NRP;
               _sur.ZGP_OPIS:=ZGP.OPIS;
               _sur.ZGH_IL:=ZGP.NRPRZ().ILNPRZ
            ?};
            ZGP.cntx_pop(); ZGH.cntx_pop();
            _sur.RAP_IL:=REZ.ILR;
            _sur.RSC:=REZ.SC;
            _sur.SCEAN:={? _sur.RSC<>'' || exec('FindAndGet','#table',DK,REZ.SC,,"DK.SCEAN",'') || '' ?};
            _sur.EANL:=REZ.ZD_POZ;
::          Sprawdzenie, czy do surowca istnieją rezerwacje dedykowana do nielimitów
            {? exec('zlim_il_rez','zl_nlimit',_zlim)
            || _sur.CZY_REZ:=1
            ?};
            _sur.add();

            REZ.next()
         !};
         params_set('env_gen',_env_gen)
      ?};
      REZ.cntx_pop()
   ?};
   ZLGD.cntx_pop()
?};
_res


\vprod_win_ek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Tworzy okno do zakańczania rozpoczętych operacji
::   WE: [_a] - typ operacji: 0 - TPZ, [1] - ilościowa, 2 - grupa operacji
::   WY: utworzone okno
::----------------------------------------------------------------------------------------------------------------------
_typ:={? var_press('_a')=type_of(0) || _a || 1 ?};
_title:={? _typ=2 || 'Rejestracja wykonania grupy operacji'@ || 'Rejestracja wykonania operacji'@ ?};
_win:=VPRODREJ.mk_edit(_title,0,'vprodrejek_wyk'+$_typ,19,5,'','');
VPRODREJ.win_esep(_win,'Dane operacji'@@);
VPRODREJ.win_efld(_win,VPRODREJ,'OPER','','',53,0,1,'',0,'',,'');
{? _typ<>2 || VPRODREJ.win_efld(_win,VPRODREJ,'M','KTM','*',50,0,1,'Produkt'@@,0,'',,'add_to_dict=yes,') ?};
{? _typ=1 | _typ=2
|| VPRODREJ.win_efld(_win,VPRODREJ,'IL_PLAN','','',15,4,0,'Ilość planowana'@@,0,'',,'');
   {? _typ=1 || VPRODREJ.win_efld(_win,VPRODREJ,'JM','KOD',,12,0,1,'Jednostka miary'@@,0,'') ?};
   VPRODREJ.win_efld(_win,VPRODREJ,'IL_DOREJ','','',15,4,0,'Do zarejestrowania'@@,0,'',,'')
?};
VPRODREJ.win_esep(_win,'Wykonanie'@@);
{? _typ=1 | _typ=2
|| VPRODREJ.win_efld(_win,VPRODREJ,'IL','','',15,4,0,{? _typ=2 || 'Ilość'@ || '' ?},0,'',,'');
   VPRODREJ.efld_opt(_win,'mark=1',VPRODREJ,'IL','');
   {? _typ=1
   || VPRODREJ.win_efld(_win,VPRODREJ,'IL_BRAK','','',15,4,0,'',0,'',,'');
      VPRODREJ.efld_opt(_win,'mark=1',VPRODREJ,'IL_BRAK','');
      VPRODREJ.win_efld(_win,VPRODREJ,'BRAKI_R','KOD','*',50,0,0,'Rodzaj braku'@@,0,'',,'add_to_dict=yes,');
      VPRODREJ.win_efld(_win,VPRODREJ,'BRAKI_R','OPIS',,50,0,1,'',1,'',,'add_to_dict=yes,')
   ?}
?};
{? _typ<>2
|| VPRODREJ.win_efld(_win,VPRODREJ,'TIME','','',15,5,0,'Czas'@@,0,'',,'');
   {? _typ=0 & exec('get','#params',500644)='N'
   || VPRODREJ.efld_opt(_win,'mark=1',VPRODREJ,'TIME','')
   || VPRODREJ.efld_opt(_win,'mark=0',VPRODREJ,'TIME','')
   ?}
?};
VPRODREJ.win_efld(_win,AH,'H','','',,,0,'',0,'',,'');
::VPRODREJ.win_efld(_win,VPRODREJ,'OK','','',35,2,0,'',0,'','radio-buttons','left_label=1','Operacja będzie trwała nadal'@@,"exec('str_n_','#blank')",'Zakończono wykonywanie operacji'@@,"exec('str_t_','#blank')");
VPRODREJ.win_efld(_win,VPRODREJ,'PLACE','KOD','*',50,0,0,'Stanowisko'@@,0,'',,'add_to_dict=yes,');
VPRODREJ.efld_opt(_win,'mark=1',VPRODREJ,'PLACE','KOD');
VPRODREJ.win_efld(_win,VPRODREJ,'PLACE','NA','*',50,0,1,'',1,'',,'add_to_dict=yes,');
{? _typ<>2
|| {? VAR1.REJ_WYR<>'T'
   || VPRODREJ.win_efld(_win,VPRODREJ,'ZPARN','SYM','ZGH2',50,0,0,'Partia'@@,0,'',,'add_to_dict=yes,')
   ?};
:: Sprawdzam czy pole z partią musi być wypełnione
   _party_req:=exec('party_req','zl_wyk',PROD_REJ.ZL);
   VPRODREJ.efld_opt(_win,{? _party_req>0 || 'mark=1' || 'mark=0' ?},,'ZPARN')
?};
::VPRODREJ.win_efld(_win,VPRODREJ,'AUTO','','',3,0,0,'Automatycznie?'@@,0,'','check-box','left_label=1,check_label="%1"'['Czy podzielić partię automatycznie?'@@],"exec('str_t_','#blank')","exec('str_n_','#blank')");
::VPRODREJ.win_efld(_win,AH,'H','','',,,0,'Czas zakończenia operacji'@@,0,,);
VPRODREJ.win_efld(_win,AH,'H','','',,,0,'',0,'',,'');
VPRODREJ.win_efld(_win,VPRODREJ,'ENDD',,,,,,'Data'@@);
VPRODREJ.efld_opt(_win,'mark=1',VPRODREJ,'ENDD');
VPRODREJ.win_efld(_win,VPRODREJ,'ENDT',,,7,,,'Godzina'@@);
exec('ok_esc','#window',VPRODREJ,_win);
_win


\end_zlgd_ek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Zakańcza rozpoczętą operację (e-kioskową) z poziomu Merit ERP
::   WE: [_a] - rodzaj operacji: [0] - operacja z normą czasową,
::                                1 - operacja tylko z czasem maszynowym
::                                2 - grupa operacji
::----------------------------------------------------------------------------------------------------------------------
_what:={? var_pres('_a')=type_of(0) || _a || 0 ?};

_tab:=cur_tab(1,1);

Cntx.psh(ZGP,ZLGD,ZLGB,_tab);
ZLGD.use(8+_tab.ZLGD);
{? _what=0
|| {? _tab.ZLGB<>''
   || ZLGB.use(8+_tab.ZLGB)
   || ZLGB.use((5+ZLGB.name())+((8+_tab.ZLGD)+3))
   ?}
?};
Cntx.clr(ZGP,ZLGD,ZLGB);
{? ZLGD.seek(_tab.ZLGD)
||
   exec('end_zlgd_ek_core','zl_wyk',_what,1)
?};
Cntx.pop(ZGP,ZLGD,ZLGB,_tab);
~~


\end_zlgd_ek_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Zakańcza rozpoczętą operację (e-kioskową) z poziomu Merit ERP
::       Przed wywołaniem musi być ustalony kontekst tabel ZLGD i ZLGB oraz ustawiony rekord ZLGD
::   WE: [_a] - rodzaj operacji: [0] - operacja z normą czasową,
::                                1 - operacja tylko z czasem maszynowym
::                                2 - grupa operacji
::       [_b] - odświeżać widoki (_tab i PROD_REJ): 0/[1]
::----------------------------------------------------------------------------------------------------------------------
_what:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_rfrsh:={? var_pres('_b')=type_of(0) || _b || 1 ?};

_tab:=cur_tab(1,1);

VEK.cntx_psh();
VAR1.cntx_psh();
VPRODREJ.cntx_psh();
VEK.RODZA:='REJ_WYK';
VAR1.ZAK_EK:='T';
{? ZLGD.P<>null()
|| _pracownik:=ZLGD.P;
   _brygada:=null()
|| _pracownik:=exec('FindAndGet','#table',ZLBR,ZLGD.B,,"P",null());
   _brygada:=ZLGD.B
?};
{? ZLGD.ZGP<>null()
|| _prod_rej:=exec('FindInSet','#table','PROD_REJ','ZGP',ZLGD.ZGP,'ZL')
|| _prod_rej:=exec('FindInSet','#table','PROD_REJ','GROP',ZLGD.GROP,'ZL')
?};

{? _prod_rej<>null()
||
:: Podmiana bieżącego pracownika i brygady
   VEK.P:=_pracownik;
   VEK.A_ZLBR:=_brygada;
   PROD_REJ.cntx_psh();
   PROD_REJ.prefix();
   {? PROD_REJ.seek(_prod_rej)
   || PROD_REJ.ZGP();
      VPRODREJ.EDIT_END:=1;
      VPRODREJ.EDIT_TM:={? exec('get','#params',500644)='N' & PROD_REJ.ZGP().NTIME<>0 || 1 || 0 ?};
      VPRODREJ.ENDD:=date();
      _godz:=time()~1;
      _mind:=#(1+form(time()~2,-2));
      _minj:=#(form(time()~2,-2)+1);
      _time:=time(_godz,(10*_mind+_minj),0);
      VPRODREJ.ENDT:=_time;
      VPRODREJ.STARTD:=ZLGD.STARTD().DATA;
      VPRODREJ.STARTT:=ZLGD.STARTT;
      VPRODREJ.IL:=0;
      VPRODREJ.IL_BRAK:=0;
      VPRODREJ.TIME:=0;
::    Ustalenie wartości VEK.KAP oraz VEK.IL
      exec('vek_il_set','ekioski');

      ZLGD.cntx_psh();ZLGB.cntx_psh();
::    Podczytuje rozpisane surowce
      VAR_DEL.delete('__ENV_REJ');
      exec('rej_mat_fill_tmp','ekioski');
::    Rejestruję wykonanie
      exec('wykon_4rej','zl_wyk');
      ZLGD.cntx_pop();ZLGB.cntx_pop();
::    Jak zakończono operację to usuwam z widoku
      ZLGD.get();
      {? ZLGD.ZAK='T'
      || _tab.del();
         {? _rfrsh
         ||
::          odświeżenie okna
            _tab.cntx_psh();
            _tab.prefix();
            {? _what=2
            || exec('grop_godz','zl_grop',_tab)
            |? _what=1
            || exec('zgp_wrk','zl_wyk',_tab)
            || exec('zgp_godz','zl_wyk',_tab)
            ?};
            _tab.cntx_pop();
::          odświeżenie filtra PROD_REJ
            {? PROD_REJ.f_active() || PROD_REJ.f_rfresh() ?}
         ?}
      ?}
   ?};
   PROD_REJ.cntx_pop()
|| FUN.emsg('Nie znaleziono operacji.'@+'\n'+'Zgłoś się do administratora.'@)
?};
VPRODREJ.cntx_pop();
VAR1.cntx_pop();
VEK.cntx_pop();
~~


\chk_fill_rej_mat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, czy zostały rozpisane (rozliczone) wszystkie pozycje surowców nielimitowanych rozliczanych
::       do operacji. (sprawdzana tabela tymczasowa zmiennej __ENV_REJ)
::   WY: 1 - wszystko rozpisane, 0 - są nierozpisane surowce
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
{? var_press('__ENV_REJ')>100 & __ENV_REJ.TYPE=0
|| _env:=__ENV_REJ;
   _tab:={? VEK.TERM='T' || _env.TAB_N || _env.TAB ?};
   {? _tab.first()
   || {!
      |?
         {? _tab.IL<=0
         || _result:=0
         ?};
         _result=1 & _tab.next()
      !}
   ?}
?};
_result


\zparn_split
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Wydziela nową partię po zarejestrowaniu wykonania produkcji (funkcjonalność dla parametru 500771)
::       _a - ZLGD.ref() - utworzony zapis robocizny
::       _b - ZPARN.ref() - dzielona partia
::       _c - ZGP.ref()
::       _d - ZLBR.ref()/P.ref() - pracownik/brygada rejestrujący wykonanie
::   WY: ZPARN.ref() lub null(), gdy partia nie powstała
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;
_zparn:=_b;
_zgp:=_c;
_pb:=_d;
_new_ref:=null();
_result:=1;
_il:=0;
ZGP.cntx_psh();
{? VAR1.REJ_WYR<>'T'
|| ZLGD.cntx_psh();
   ZLGD.index('ZPARN');
   ZLGD.prefix(_zparn,_zgp);
   {? ZLGD.first()
   || {!
      |?
::       Jeżeli do tej samej partii inna osoba zarejestrowała wykonanie to trzeba podzielić partię
         {? ZLGD.ZGP().BRYG='T'
         || {? ZLGD.B<>_pb || _result:=0 ?}
         || {? ZLGD.P<>_pb || _result:=0 ?}
         ?};
         {? ZLGD.ref()<>_ref || _il+=ZLGD.IL+ZLGD.DEK_IL+ZLGD.IL_BRAK+ZLGD.DEK_BR ?};
         ZLGD.next()
      !}
   ?};
   ZLGD.cntx_pop()
|| ZLGD.cntx_psh();
   ZL_WYRGD.cntx_psh();
   ZL_WYRGD.index('ZPARN');
   ZL_WYRGD.prefix(_zparn,_zgp);
   {? ZL_WYRGD.first()
   || {!
      |?
         ZL_WYRGD.ZLGD();
::       Jeżeli do tej samej partii inna osoba zarejestrowała wykonanie to trzeba podzielić partię
         {? ZLGD.ZGP().BRYG='T'
         || {? ZLGD.B<>_pb || _result:=0 ?}
         || {? ZLGD.P<>_pb || _result:=0 ?}
         ?};
         {? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T'
         || _il+=ZL_WYRGD.IL+ZL_WYRGD.IL_BRAK
         || _il+=ZL_WYRGD.DEK_IL+ZL_WYRGD.DEK_BR
         ?};
         ZL_WYRGD.next()
      !}
   ?};
   ZL_WYRGD.cntx_pop();
   ZLGD.cntx_pop()
?};
:: Wydzielam nową partię na ilość pozostałą
{? _result=0
||
   _zparn_il:=exec('FindAndGet','#table',ZPARN,_zparn,,"IL",0);
   _zparn_ilw:=exec('get_ilosc_rp','zl_partie',_zparn);
   _il_dorej:=_zparn_il-_zparn_ilw;
   {? _il_dorej<_il || _il:=_il_dorej ?};
   {? _il>0
   || {? exec('split','zl_partie',_zparn,_il,0)
      ||
::       znalezienie refa nowo utworzonej partii
         ZPARN.cntx_psh();
         _srcid:=exec('FindAndGet','#table',ZPARN,_zparn,,"IDADD",0);
         ZPARN.index('IDSRC_ID');
         ZPARN.prefix(_srcid);
         {? ZPARN.last() || _new_ref:=ZPARN.ref() ?};
         ZPARN.cntx_pop()
      ?}
   ?}
?};
ZGP.cntx_pop();
_new_ref


\var1_braki_r_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Przed redagowaniem pola VAR1.BRAKI_R, ZLGD.BRAKI_R
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
{? ZLGD.ZGP().KJ_BAD='N' | ZLGD.KJ_DONE='T'
|| {? ZLGD.IL_BRAK>0
   || _result:=1
   ?}
|| {? ZLGD.DEK_BR>0
   || _result:=1
   ?}
?};
{? _result>0
|| BRAKI_R.win_dict('WER');
   BRAKI_R.actions('WER','O');
   exec('braki_r_filter','braki',ZLGD.ZGP)
?};
_result


\var1_braki_r_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Po redagowaniu pola VAR1.BRAKI_R
::----------------------------------------------------------------------------------------------------------------------
_kj_bad:=ZLGD.ZGP().KJ_BAD;
{? _kj_bad='N' | ZLGD.KJ_DONE='T'
|| ZLGD.BRAKI_R:=VAR1.BRAKI_R
|| ZLGD.DEK_RBR:=VAR1.BRAKI_R
?};
1


\chk_il_pop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Kontrole poprawnosci wypelnienia ilości na ZLGD - kontrola ilości z poprzednich operacji
::       (parametry 500631, 500634). Działa na aktualynm rekordzie tabeli ZLGD
::   WY: obiekt RESULT o polach: RES - czy poprawnie wypełnione ilości 0/1
::                               TXT - treść koumnikatu błędu, gdy ilość błędnie wypełniona
::----------------------------------------------------------------------------------------------------------------------
_result:=obj_new('RES','TXT');
_res:=1;
_txt:='';

_chkak:=exec('get','#params',500631,2);
_chkak1:=exec('get','#params',500634,2);
_wp:=ZLGD.ZL().TYP().WP;
_tpz:=ZLGD.ZGP().TPZ;
_ilnprz:=ZLGD.ZGP().ILOSC;
_il:=exec('il_pop','zl_guide',ZLGD.ZGP);
_il_pop:=_il.IL_POP;
_max:=_il.MAX;
_first_op:=_il.FIRST;
:: wartosci przed redakcja
{? {? VAR1.REJ_WYR='T'
   || var_pres('__ENV_WYR')>100 & __ENV_WYR.ZLGD<>null()
   || (-menu_txt()='popraw' | -menu_txt()='kwalifikuj' | VAR1.KN2='T')
   ?}
|| ZLGD.cntx_psh();
   ZLGD.get();
   _be_il:=ZLGD.IL;
   _be_ilb:=ZLGD.IL_BRAK;
   ZLGD.cntx_pop()
|| _be_il:=0; _be_ilb:=0
?};
:: wartosci aktualne w sumie
_zgp_il:=ZLGD.ZGP().IL;
_zgp_ilb:=ZLGD.ZGP().IL_BRAK;

:: Warunki
{? _wp='P'
|| {? _first_op
   || {? _tpz='N' & _chkak1='T' & _zgp_il+_zgp_ilb-_be_il-_be_ilb+VAR1.IL+VAR1.IL_BRAK>_ilnprz
      || _txt:=
            'Zlecenie: %1; przewodnik %2 poz. %3'@[ZL.SYM,ZGH.NRPRZ,$ZGP.NRP]+'\n'+
            'Łączna ilość (dobre + braki) większa od wynikającej z przewodnika.'@+'\n'+
            'Maksymalna ilość, którą można zarejestrować: %1'@[$(_ilnprz-_zgp_il-_zgp_ilb+_be_il+_be_ilb)];
         _res:=0
      ?}
   || {? _tpz='N' & _chkak='T' & _zgp_il+_zgp_ilb-_be_il-_be_ilb+VAR1.IL+VAR1.IL_BRAK>_il_pop
      || _txt:=
            'Zlecenie: %1; przewodnik %2 poz. %3'@[ZL.SYM,ZGH.NRPRZ,$ZGP.NRP]+'\n'+
            'Łączna ilość (dobre + braki) większa niż zarejestrowana w poprzedniej operacji (%1).'@[$_il_pop]+'\n'+
            'Maksymalna ilość, którą można zarejestrować: %1'@[$(_il_pop-_zgp_il-_zgp_ilb+_be_il+_be_ilb)];
         _res:=0
      ?}
   ?}
?};
_result.RES:=_res;
_result.TXT:=_txt;
_result


\godz_sel_zgh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Akcja Robocizna w oknie przewodnika zlecenia - podglad zarejestrowanych godzin pracy
::----------------------------------------------------------------------------------------------------------------------
exec('godz_sel','zl_wyk',0);
~~


\zlgd_chk4rez
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Sprawdza, czy do podanego zapisu robocizny (ZLGD) są zdefiniowane rezwerwacje do pobrań surowców.
::   WE: _a - ZLGD.ref()
::   WY: STRING - maska, w której znajdują się rezerwacje lub '', gdy ich nie ma
::----------------------------------------------------------------------------------------------------------------------
_zlgd:=_a;
_zl:=exec('FindAndGet','#table',ZLGD,_zlgd,,"ZLGD.ZL",null());
_mask:='';
_continue:=1;
REZ.cntx_psh();
_rez_mask:=REZ.names();
{? _rez_mask.first()
||
   {!
   |?
      REZ.use(_rez_mask.NAME);
      REZ.index('ZLREZR');
      REZ.prefix(_zl,'S','R',$_zlgd,);
      {? REZ.first()
      || _mask:=REZ.name();
         _continue:=0
      ?};
     _rez_mask.next() & _continue>0
   !}
?};
REZ.cntx_pop();
_mask

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:35 3be9f484a3fe854924b3200893ab3b8377fab2ef40da4dd04c57f410a3114958b757709bf34e2119f8a22ae8551018e2c84ab8d5089a7d159f897dacd105f09736ecd63ac4a9e865a514d77972d3440b0bbc0b7a721927af1329be724fcb4475b2def0f6a5b92fbf070d14aefdf1afbf6f57233d7b3fd873ee0659950b3c8a0c
