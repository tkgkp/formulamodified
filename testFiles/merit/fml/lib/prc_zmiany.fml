:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: prc_zmiany.fml
:: Utworzony: 2017/10/12
:: Autor: TMR
::======================================================================================================================
:: Zawartosc: Formuły do obsługi tabeli z definicją pracy zmianowej.
::======================================================================================================================

\r_zmiany_opis_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.02]
:: OPIS: Formuła po edycji pola OPIS w tabeli R_ZMIANY.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? fld() * '|'
|| FUN.info('Niedozwolony znak (|) w opisie zmiany.'@);
   0
|| 1
?}


\r_zmiany_godz_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.02]
:: OPIS: Formuła przed edycją pola GODZ_OD i GODZ_DO tabeli R_ZMIANY.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
VAR.ZMIANAP:=fld();
1


\r_zmiany_wyj_nd_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [12.51_24]
:: OPIS: Formuła po edycji pola WYJ_ND w tabeli R_ZMIANY.
::   WE:
::   WY:
::  OLD: \r_zmiany_wnd_ae/r_zmiany.fml
::----------------------------------------------------------------------------------------------------------------------
R_ZMIANY.CZAS:=(R_ZMIANY.GODZ_DO-R_ZMIANY.GODZ_OD)+*((R_ZMIANY.WYJ_ND*'T')*(*time(24,0,0)));
R_ZMIANY.CZAS-=R_ZMIANY.P_CZAS;
1


\r_zmiany_min_max_od_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.02]
:: OPIS: Formuła po edycji pola MIN_OD i MAX_OD w tabeli R_ZMIANY.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
{? cur_afld()='MIN_OD'
|| {? fld()>R_ZMIANY.GODZ_OD
   || FUN.info('Wartość w polu "%1" nie może być większa od godziny rozpoczęcia zmiany'@[cur_nfld()]);
      _result:=0
   ?}
|? cur_afld()='MAX_OD'
|| {? fld()<R_ZMIANY.GODZ_OD
   || FUN.info('Wartość w polu "%1" nie może być mniejsza od godziny rozpoczęcia zmiany'@[cur_nfld()]);
      _result:=0
   ?}
?};
_result


\r_zmiany_wer_ar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51_24]
::  MOD: MicKoc [22.26]
:: OPIS: Formuła "rekord po" w oknie WER tabeli R_ZMIANY.
::   WE:
::   WY:
::  OLD: \r_zmiany_wer_ar/r_zmiany.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=__CHK.record(R_ZMIANY,,'OPIS');
{? _result='' & R_ZMIANY.P_CZAS>*60
|| FUN.info('Czas trwania przerwy nie może przekraczać jednej godziny.'@);
   _result:='P_CZAS'
?};
{? _result=''
|| _t_24:=time(24,0,0);
   R_ZMIANY.CZAS:=(R_ZMIANY.GODZ_DO-R_ZMIANY.GODZ_OD)+*((R_ZMIANY.WYJ_ND*'T')*(*_t_24));
   R_ZMIANY.CZAS-=R_ZMIANY.P_CZAS;
   {? R_ZMIANY.GODZ_OD>=_t_24
   || FUN.info('Godzina rozpoczęcia zmiany musi zawierać się pomiędzy %1 a %2'@['00:00','23:59']);
      _result:='GODZ_OD'
   ?};
   {? R_ZMIANY.GODZ_DO>=_t_24
   || FUN.info('Godzina zakończenia zmiany musi zawierać się pomiędzy %1 a %2'@['00:00','23:59']);
      _result:='GODZ_DO'
   ?};
   {? R_ZMIANY.CZAS<=*0
   || FUN.info('Czas trwania zmiany nie może być mniejszy lub równy zero'@);
      _result:='GODZ_OD'
   ?};
:: jeżeli mamy zaznaczoną domyślną przerwę, to nie może ona wyjść poza planowane godziny zmiany
   {? R_ZMIANY.P_DOMYSL='T'
   || _zm_od:=R_ZMIANY.GODZ_OD;
      _zm_do:=_zm_od+R_ZMIANY.CZAS+R_ZMIANY.P_CZAS;
      _prz_od:=R_ZMIANY.P_STARTD;
      {? _prz_od<R_ZMIANY.GODZ_DO & _zm_od>R_ZMIANY.GODZ_DO
      || _prz_od+=_t_24
      ?};
      _prz_do:=_prz_od+R_ZMIANY.P_CZAS;
      {? ~(_prz_od>=_zm_od & _prz_od<=_zm_do &
           _prz_do>=_zm_od & _prz_do<=_zm_do)
      || FUN.info('Rozpoczęcie i zakończenie przerwy musi zawierać się w czasie trwania zmiany (%1 - %2).'@
            [$R_ZMIANY.GODZ_OD,$R_ZMIANY.GODZ_DO]
         );
         _result:='P_STARTD'
      ?}
   || R_ZMIANY.P_STARTD:=*0
   ?};
   {? menu_pth+1='P' & _result='' & exec('isEnabled','prc_przerwy')
   || _mydo:=do_state()=0;
      {? _mydo || do() ?};
      _przes:=exec('przesun','prc_przerwy',R_ZMIANY.ref(),R_ZMIANY.GODZ_OD,R_ZMIANY.CZAS,R_ZMIANY.P_CZAS);
      {? _przes=-1 || undo() ?};
      {? _mydo || end() ?};
      {? _przes=1
      || FUN.info('Ze względu na modyfikację godzin trwania zmiany, zmodyfikowane zostały '
                  'godziny rozpoczęcia powiązanych przerw.\n'
                  'Należy zweryfikować poprawność powiązanych przerw w pracy.'@)
      ?}
   ?}
?};
_result


\import
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.02]
:: OPIS: Importuje dane z pliku tekstowego do tabeli zmian.
::   WE: _a - [TABLE] - tabela Zmiany
::   WY: 0/1
::  OLD: \import/plan_zm.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=(_exist:=fopen('zmiany.txt','ur',1));

{? _exist
|| fclose(_exist);
   R_ZMIANY.import('zmiany.txt',,,'|','UTF-8',,
      'OPIS',,1,,
      'GODZ_OD',,2,1,
      'MIN_OD',,3,1,
      'MAX_OD',,4,1,
      'GODZ_DO',,5,1,
      'WYJ_ND',,6,1,
      'CZAS',,7,1
   )
?};
_result


\zmiany_domyslne
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DAROKR [19.02]
:: OPIS: Tworzy zapisy o domyślnych zmianach tabela R_ZMIANY
::----------------------------------------------------------------------------------------------------------------------
_zmian:="
   R_ZMIANY.index('R_ZMIANY');
   R_ZMIANY.prefix();
   {? ~R_ZMIANY.find_key(_b)
   || R_ZMIANY.blank();
      R_ZMIANY.OPIS:=_a;
      R_ZMIANY.GODZ_OD:=_b;
      R_ZMIANY.MIN_OD:=_c;
      R_ZMIANY.MAX_OD:=_d;
      R_ZMIANY.GODZ_DO:=_e;
      R_ZMIANY.WYJ_ND:=_f;
      R_ZMIANY.CZAS:=_g;
      R_ZMIANY.add(1)
   ?}
";
_zmian('Zmiana I   (06:00 - 14:00)',time(6,0,0),time(6,0,0),time(6,0,0),time(14,0,0),'N',time(8,0,0));
_zmian('Zmiana II  (14:00 - 22:00)',time(14,0,0),time(14,0,0),time(14,0,0),time(22,0,0),'N',time(8,0,0));
_zmian('Zmiana III (22:00 - 06:00)',time(22,0,0),time(22,0,0),time(22,0,0),time(6,0,0),'T',time(8,0,0))


\czyAktBuff4Zm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [22.26]
:: OPIS: Czy aktualizować bufor planowania dla wskazanej zmiany
::   WE: _a  [REFERENCE] - wskazanie na rekord R_ZMIANY
::      [_b] [REFERENCE] - wskazanie na rekord R_PRZER
::   WY: 1
::  OLD: \czyAktBuff4Zm/r_zmiany.fml
::----------------------------------------------------------------------------------------------------------------------
    _ref:={? var_pres('_a')=type_of(null()) || _a || return(1) ?};
_r_przer:={? var_pres('_b')=type_of(null()) || _b || null() ?};

{? FUN.ask('Czy zaktualizować planowanie czasu pracy dla pracowników z przypisaną zmianą/przerwą\n'
           'w miesiącach otwartych do planowania?'@)
|| undefine();
   define('OD',date(),'Modyfikacja od daty:'@);
   _wynik:=def_edit(,'|--|Proszę podać datę, od której ma być zaktualizowane planowanie.'@);
   _data:={? _wynik || DEFINE.OD || #0 ?};
   undefine();
   exec('akt_buff','prc_zmiany','put',_ref,_r_przer,_data)
 ?};
1


\akt_buff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [22.26]
:: OPIS: Trigger na tabeli R_ZMIANY aktualizujący KAL_BUFFa w zakresie niepłatnej przerwy
::       _a  [STRING]    - rodzaj triggera
::       _b  [REFERENCE] - wskazanie na rekord tabeli R_ZMIANY
::      [_c] [REFERENCE] - wskazanie na rekord tabeli R_PRZER
::      [_d] [DATA]      - data od której będą aktualizowane rekordy
::  OLD: \akt_buff/r_zmiany.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
    _typ:={? var_pres('_a')=type_of('')   || _a || return(_result) ?};
    _ref:={? var_pres('_b')=type_of(null) || _b || return(_result) ?};
_r_przer:={? var_pres('_c')=type_of(null) || _c || null()          ?};
_data_od:={? var_pres('_d')=type_of(date) || _d || #0              ?};

_result:={? _typ='del' || 1 || ~~ ?};

{? ~exec('isEnabled','prc_przerwy') || return(_result) ?};

:: obecnie zakładamy, że aktualizowane są tylko bufory planowania
_warstwa:='P';

KAL_BUFF.cntx_psh();
KAL_BUFF.index('ZMIANA');
KAL_BUFF.prefix(_ref,_warstwa);
{? _typ='del'
|| {!
   |? KAL_BUFF.first()
   |! KAL_BUFF.ZMIANA:=null;
      KAL_BUFF.cntx_psh();
      KAL_BUFF.prefix();
      KAL_BUFF.put();
      KAL_BUFF.cntx_pop()
   !}

|? _typ='put'
||
:: pobieramy wszystkich pracowników spełniających warunki
   _sql:=''+"select distinct P from KAL_BUFF
             where GPW=':_a' and ZMIANA=:_b and (DATA>=to_date(:_c) or to_date(:_c) is NULL)";
   _tabP:=sql(_sql,_warstwa,_ref,_data_od);

   {? _tabP.first()
   || _sql:=''+"select KAL_BUFF.DATA from KAL_BUFF
             where
               KAL_BUFF.P=:_a and
               KAL_BUFF.GPW='Z' and
               KAL_BUFF.DATA>=to_date(:_b) and
               KAL_BUFF.DATA<=to_date(:_c)
             order by 1,2";
      SLO_KOD.cntx_psh();
      R_PRZER.cntx_psh();
      R_PRZER.index('UNIQUE');
      P.cntx_psh();
      P.prefix();
      {!
      |? {? P.seek(_tabP.P,)
         || _p_ref:=P.ref();
::          pobierz wszystkie okresy rozliczeniowe otwarte do planowania
            {? var_pres('_t_okrp')>0 || obj_del(_t_okrp) ?};
            _t_okrp:=exec('getOkrpFromDate','grafik',_p_ref,_data_od,,,'O',,'OD');
            {? _t_okrp.first()
            || _statusM:='';
               _rok:=0;
               _msc:=0;
               {!
               |? _od:={? _t_okrp.OD<_data_od || _data_od || _t_okrp.OD ?};
                  _do:=_t_okrp.DO;
:: wyszukanie zatwierdzonych wykonań w zakresie pobieranych dat
                  {? var_pres('_tabWyk')>0 || obj_del(_tabWyk) ?};
                  _tabWyk:=sql(_sql,_p_ref,_od,_do);
:: wstępnie sprawdzamy czy wogóle coś jest w badanym zakresie
                  KAL_BUFF.prefix(_ref,_warstwa,_p_ref);
                  {? KAL_BUFF.find_ge(_od)
                  || {! _data_nr:=#_od..#_do
                     |! _data:=#_data_nr;
                        KAL_BUFF.prefix(_ref,_warstwa,_p_ref,_data);
                        _tabWyk.prefix(_data);
                        {? KAL_BUFF.first() & _tabWyk.size()=0
                        || {? _data~1<>_rok | _data~2<>_msc | _statusM=''
                           || _statusM:=exec('getPlanStat4Pr','grafik',_p_ref,_data);
                              _rok:=_data~1;
                              _msc:=_data~2
                           ?};
                           {!
                           |? {? _statusM<>'Z'
                              || _dalej:=1;
                                 KAL_BUFF.POCZATEK:=R_ZMIANY.GODZ_OD;
                                 KAL_BUFF.KONIEC:=R_ZMIANY.GODZ_DO;
                                 KAL_BUFF.DATAW:=KAL_BUFF.DATA+R_ZMIANY.WYJ_ND*'T';
                                 KAL_BUFF.ZMIANA:={? KAL_BUFF.TYP='R' || R_ZMIANY.ref() || null() ?};
:: jeżeli w defnicji zmiany ustawiono czas przerwy to wstępnie ustawiamy przerwę na początku dnia pracy
:: w kolejnym kroku sprawdzimy czy pracownik jest przypisany do jakiejś grupy z przerwami i ustawimy mu wtedy przerwę
:: jeśli pracownik nie jest przypisany do żadnej grupy z przerwami, natomiast włączona jest domyślna przerwa dla zmiany
:: to przerwa dla takiego pracownika zostaje ustalona na podstawie przerwy domyślnej (początek przerwy ustalany jest
:: dla definicji zmiany, nie dla grupy pracowników). Brak jakichkolwiek grup z przerwami przy jednoczesnym włączeniu
:: przerw domyślnych dla zmiany  będzie skutkować tym, że dla pracowników podlegających pod daną zmianę przerwa zostanie
:: wyznaczona na podstawie przerwy domyślnej.
                                 {? R_ZMIANY.P_CZAS>*0
                                 || {? _r_przer=null()
                                    || KAL_BUFF.P_DATA:=KAL_BUFF.DATA;
                                       KAL_BUFF.P_START:=KAL_BUFF.POCZATEK;
                                       KAL_BUFF.P_CZAS:=R_ZMIANY.P_CZAS
                                    ?};
                                    _domysl:=R_ZMIANY.P_DOMYSL='T';
                                    R_PRZER.prefix(_ref);
                                    {? R_PRZER.first()
                                    || _nalezy:=exec('Nalezy','grupprac',R_PRZER.GRUPA().KOD,_p_ref,_data);
                                       {!
                                       |? _check:=_r_przer=null() | _r_przer=R_PRZER.ref();
                                          {? _check
                                          || KAL_BUFF.P_DATA:=KAL_BUFF.DATA+R_PRZER.OD_ND*'T';
                                             KAL_BUFF.P_START:={? ~_nalezy & _domysl
                                                               || R_ZMIANY.P_STARTD
                                                               || R_PRZER.GODZ_OD
                                                               ?};
                                             KAL_BUFF.CZAS:=KAL_BUFF.KONIEC-KAL_BUFF.POCZATEK-KAL_BUFF.P_CZAS;
                                             KAL_BUFF.CZAS+=(KAL_BUFF.DATAW-KAL_BUFF.DATA)*60*24;
                                             _dalej:=0
                                          ?};
                                          _dalej & R_PRZER.next()
                                       !}
                                    || {? _domysl
                                       || KAL_BUFF.P_DATA:=KAL_BUFF.DATA+R_PRZER.OD_ND*'T';
                                          KAL_BUFF.P_START:=R_ZMIANY.P_STARTD;
                                          KAL_BUFF.CZAS:=KAL_BUFF.KONIEC-KAL_BUFF.POCZATEK-KAL_BUFF.P_CZAS;
                                          KAL_BUFF.CZAS+=(KAL_BUFF.DATAW-KAL_BUFF.DATA)*60*24
                                       ?}
                                    ?}
                                 || KAL_BUFF.P_DATA:=#0;
                                    KAL_BUFF.P_START:=*0;
                                    KAL_BUFF.P_CZAS:=*0
                                 ?};
                                 KAL_BUFF.put()
                              ?};
                              KAL_BUFF.next()
                           !}
                        ?}
                     !}
                  ?};
                  _t_okrp.next()
               !}
            ?}
         ?};
         _tabP.next()
      !};
      P.cntx_pop();
      R_PRZER.cntx_pop();
      SLO_KOD.cntx_pop()
   ?}
?};
KAL_BUFF.cntx_pop();

_result


\r_zmiany_godz_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [12.51_24]
:: OPIS: Formuła po edycji pola GODZ_OD i GODZ_DO tabeli R_ZMIANY.
::   WE:
::   WY:
::  OLD: \r_zmiany_godzae/r_zmiany.fml
::----------------------------------------------------------------------------------------------------------------------
{? fld()<>VAR.ZMIANAP
|| {? cur_afld()+2='OD'
   || {? FUN.ask('Czy nadpisać wartości pól "Najwcześniej od" i "Najpóźniej od" godziną z pola "Początek zmiany"?'@)
      || R_ZMIANY.MIN_OD:=fld();
         R_ZMIANY.MAX_OD:=fld()
      || {? R_ZMIANY.MIN_OD>fld()
         || R_ZMIANY.MIN_OD:=fld()
         ?};
         {? R_ZMIANY.MAX_OD<>*0 & R_ZMIANY.MAX_OD<fld()
         || R_ZMIANY.MAX_OD:=fld()
         ?}
      ?}
   ?}
?};
R_ZMIANY.CZAS:=(R_ZMIANY.GODZ_DO-R_ZMIANY.GODZ_OD)+*((R_ZMIANY.WYJ_ND*'T')*(*time(24,0,0)));
R_ZMIANY.CZAS-=R_ZMIANY.P_CZAS;
VAR.ZMIANAP:=time(0,0,0);
1


\r_zmiany_pdchec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RO [12.51]
:: OPIS: Po edycji pola P_DOMYSL (parametr - przerwa domyślna) tabeli R_ZMIANY
::  OLD: \r_zmiany_pdchec/r_zmiany.fml
::----------------------------------------------------------------------------------------------------------------------
{? fld()='T'
|| R_ZMIANY.efld_opt('RED_P','enable=1',,'P_STARTD')
|| R_ZMIANY.efld_opt('RED_P','enable=0',,'P_STARTD')
?};
~~


\r_zmiany_bdel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51_24]
:: OPIS: Triggery dla tabeli R_ZMIANY
::  OLD: \R_ZMIANY/trigger.fml
::  OLD: \r_przer_bdel/prc_przerwy.fml
::----------------------------------------------------------------------------------------------------------------------
exec('akt_buff','prc_zmiany','del',R_ZMIANY.ref())


\r_zmiany_adel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MicKoc [22.26]
:: OPIS: Akcja usuń po R_ZMIANY
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_txt1:='Czy usunąć bieżący wiersz?'@;
_txt2:=
   {? exec('isEnabled','prc_przerwy')
   || '\n\n(Usunięte również zostaną powiązane rekordy przerw niepłatnych)'@
   || ''
   ?};
{? FUN.ask('%1%2'[_txt1,_txt2])
|| exec('delete','prc_zmiany',R_ZMIANY.ref())
?}


\r_zmiany_aput
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MicKoc [22.26]
:: OPIS: Akcja popraw po R_ZMIANY
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('czyAktBuff4Zm','prc_zmiany',R_ZMIANY.ref())


\delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51_24]
:: OPIS: Kasuje podany rekord tabeli R_ZMIANY (wykonywane w transakcji!!!)
::   WE: _a - R_ZMIANY.ref()
::   WY: >0 -wyczyszczone,
::      <=0 -niewyczyszczone
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::  OLD: \delete/r_zmiany.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_ref:={? var_pres('_a')=type_of(null) || _a || return(_result) ?};

:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_can_continue:=1;

:: założenie transakcji
_mydo:=do_state()=0;
{? _mydo || do() ?};

R_ZMIANY.cntx_psh();
R_ZMIANY.clear();
{? R_ZMIANY.seek(_ref)
|| {? exec('clean','prc_zmiany',_ref)>0
   || {? R_ZMIANY.del(,1)>0
      || _result:=1
      || undo();
         _result:=-3
      ?}
   || _result:=-2
   ?}
|| _result:=0
?};
R_ZMIANY.cntx_pop();

{? _result<0
|| undo()
?};
{? _mydo || end() ?};
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51_24]
:: OPIS: Czysci powiazania do rekordu tabeli R_ZMIANY
::   WE: _a - R_ZMIANY.ref()
::   WY: >0 -wyczyszczone,
::       <=0 -niewyczyszczone
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::  OLD: \clean/r_zmiany.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_ref:={? var_pres('_a')=type_of(null) || _a || return(_result) ?};

{? do_state()=2 || return(-100) ?};

_can_continue:=1;
:: założenie transakcji
_mydo:=do_state()=0;
{? _mydo || do() ?};

:: --- powiązania do R_ZMIANY---
_can_continue:=exec('delete4','prc_przerwy',_ref);

:: --- wszystkie powiazania usuniete? ---
{? _can_continue>0
|| _result:=1
|| undo()
?};

{? _mydo || end() ?};
_result


\r_zmiany_kolor_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [22.26]
:: OPIS: Przed wyświetleniem dla pola R_ZMIANY.KOLOR
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
fld()+','+fld()


\r_zmiany_kolor_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [22.26]
:: OPIS: Przed redagowaniem dla pola R_ZMIANY.KOLOR
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
fld(dlg_color(fld()));win_disp();0


\r_zmiany_addb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [22.26]
:: OPIS: Wyzwalacz "Dodaj - przed" dla tabeli R_ZMIANY
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('r_zmiany_modb','prc_zmiany')


\r_zmiany_putb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [22.26]
:: OPIS: Wyzwalacz "Popraw - przed" dla tabeli R_ZMIANY
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('r_zmiany_modb','prc_zmiany')


\r_zmiany_modb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [22.26]
:: OPIS: Przed modyfikacją rekordu.
::       Formuła wywoływana z wyzwalaczy "Dołącz - przed" i "Popraw - przed" dla tabeli R_ZMIANY.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
R_ZMIANY.HEX:=exec('dec2hex','#color',R_ZMIANY.KOLOR);
1

:Sign Version 2.0 jowisz:1045 2022/06/30 14:23:22 2efc9b7aa6b0f9972b90cf743e592fdd32c13f2f0e41469b125b37fff1791670831ca19170dbefee2f3bd42ae35b0a01e7e49248f606f61b80a4a1885ac2cc0c8866314b64b7f0a945972393969b603efa7a85ff8c0aa67bd2b1f093bb15a33fddf6330d7c7639f641cdc52e5f2d958c3d578d8cd49db6eed87c9a471a344742
