:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: kalk_oper.fml
:: Utworzony: 12.05.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły do obsługi kalkulacji operacji kart technologicznych, technologii zlecenia
::            (biblioteka wspólna dla TTE_TEC, TTE_PZL)
::======================================================================================================================


\get_proc_price
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JM [7.62]
:: OPIS: Pobiera wartości lub czasy dla całego procesu
::   WE: _a - wskazanie do obiektu kalkulacyjnego
::       _b - technologia - TKTL.ref() albo $TKTL.ref()
::       _c = 'R' - robocizna (operacje wewnętrzne)
::            'U' - usługi obce (operacje zewnętrzne)
::            'W' - koszt stanowisk (operacje wewnętrzne)
::            'G' - godziny pracy (operacje wewnętrzne)
::       [_d] - REAL - opcjonalny współczynik który skaluje wynik
::       [_e] - ilość kalkulowana (xjm). Gdy nie podana lub równa zeru to przeliczana wg ilości na technologii/zleceniu
::   WY: _wyn[] dla poszczegolnych faz, drugi wymiar Tpz
::  OLD: \get_proc_price/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=obj_new(obj_len(_a.FAZY));
{! _ii:=1..(obj_len(_a.FAZY)) |! _wyn[_ii]:=obj_new(4); _wyn[_ii][1]:=0; _wyn[_ii][2]:=0; _wyn[_ii][3]:=0; _wyn[_ii][4]:=0 !};

{? var_pres('_b')=type_of('')
|| _tktl_ref:=BIT.sqlint(_b);
   _msk:=(8+_b)+3
|? var_pres('_b')=type_of(null())
|| _tktl_ref:=#_b;
   _msk:=ref_name(_b)+3
|| return(_wyn)
?};
_coef:=1;
{? var_pres('_d')=type_of(0)
|| _coef:=_d
?};
_xjm:=0;
{? var_pres('_e')=type_of(0)
|| _xjm:=_e
?};

exec('tktl_cntx_psh','tech_common');
exec('tktl_use','tech_common',_msk);

TOPER.clear();
TOPER.index('NNN');
TOPER.prefix(_tktl_ref,0);
{? TOPER.first()
|| {!
   |?
      {? TOPER.ACT='T'
      || {! _ll:=1..(obj_len(_a.FAZY))
         |! {? _a.FAZY[_ll]=TOPER.PFAZ || _kk:=_ll ?}
         !};
         {? _a.tpar.calc(TOPER.EXIST)
         || _wyn[_kk][1]+=(exec('get_oper_price','kalk_oper',_a,TOPER.UNROP,_c,'N',_xjm,_coef));
            _wyn[_kk][2]+=(exec('get_oper_price','kalk_oper',_a,TOPER.UNROP,_c,'T',_xjm,_coef))
         ?}
      ?};
      TOPER.next()
   !}
?};

exec('tktl_cntx_pop','tech_common');
_wyn


\get1_proc_price
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Pobiera wartosci lub czasy dla calego procesu - wg definicji tymczasowej __TOPER
::   WE: _a - wskazanie do obiektu kalkulacyjnego
::       _b - technologia - TKTL.ref() albo $TKTL.ref() (parametr nie uzywany)
::       _c = 'R' - robocizna (operacje wewnetrzne)
::            'U' - uslugi obce (operacje zewnetrzne)
::            'W' - koszt stanowisk (operacje wewnetrzne)
::            'G' - godziny pracy (operacje wewnetrzne)
::   WY: _wyn[] dla poszczegolnych faz, drugi wymiar Tpz
::  OLD: \get1_proc_price/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=obj_new(obj_len(_a.FAZY));
{! _ii:=1..(obj_len(_a.FAZY)) |! _wyn[_ii]:=obj_new(4); _wyn[_ii][1]:=0; _wyn[_ii][2]:=0; _wyn[_ii][3]:=0; _wyn[_ii][4]:=0 !};
__TOPER.clear();
TOPER.clear();
{? __TOPER.first()
|| {!
   |?
      {? TOPER.seek(__TOPER.REF,)
      ||
         _par:=(TOPER.NRK().TYP().PAR='T');
         {? TOPER.ACT='T'
         || {! _ll:=1..(obj_len(_a.FAZY))
            |! {? _a.FAZY[_ll]=TOPER.PFAZ || _kk:=_ll ?}
            !};
            {? ~_par | _a.tpar.calc(TOPER.EXIST)
            ||
               {? __TOPER.TECHZAMS=0
               ||
                  {? _c='R'
                  || _coef:={? _par & TOPER.FCOEF<>'' & TOPER.FCOEF<>'1' || _a.tpar.calc(TOPER.FCOEF) || TOPER.COEF ?};
                     _ntime:={? _par & TOPER.FNTIME<>'' || _a.tpar.calc(TOPER.FNTIME) || TOPER.NTIME ?};
                     _ww:=(TOPER.OPER().STAWKA*_coef)$4;
                     _wyn[_kk][{? TOPER.TPZ='T' || 2 || 1 ?}]+=(_ww*_ntime)$4;
                     _a.ant.add(TOPER.OPER,_ww,,,_ntime,TOPER.PFAZ().WYD().KOD)
                  |? _c='U'
                  || _wyn[_kk][{? TOPER.TPZ='T' || 2 || 1 ?}]+={? _par & TOPER.FCENA<>'' || _a.tpar.calc(TOPER.FCENA) || TOPER.CENA ?};
                     _a.ano.add(TOPER.TTOUT,TOPER.TTOUT().CENA)
                  |? _c='W'
                  || _mtime:={? _par & TOPER.FMTIME<>'' || _a.tpar.calc(TOPER.FMTIME) || TOPER.MTIME ?};
                     _ww:=TOPER.KH;
                     _wyn[_kk][{? TOPER.TPZ='T' || 2 || 1 ?}]+=(_ww*_mtime)$4;
                     _a.anw.add({? TOPER.GRPOJ='S' || TOPER.PLACE || TOPER.TWRKPLG().ELEMENT ?},_ww)
                  |? _c='G'
                  || _coef:={? _par & TOPER.FCOEF<>'' & TOPER.FCOEF<>'1' || _a.tpar.calc(TOPER.FCOEF) || TOPER.COEF ?};
                     _ntime:={? _par & TOPER.FNTIME<>'' || _a.tpar.calc(TOPER.FNTIME) || TOPER.NTIME ?};
                     _wyn[_kk][{? TOPER.TPZ='T' || 2 || 1 ?}]+=_ntime$4
                  ?}
               ||
                  {? TECHZAMS.seek(__TOPER.TECHZAMS,)
                  ||
                     {? _c='R'
                     || _coef:={? TECHZAMS.FCOEF<>'' & TECHZAMS.FCOEF<>'1'
                                || _a.tpar.calc(TECHZAMS.FCOEF)
                                || TECHZAMS.COEF
                                ?};
                        _ntime:={? TECHZAMS.FNTIME<>'' || _a.tpar.calc(TECHZAMS.FNTIME) || TECHZAMS.NTIME ?};
                        _ww:=(TOPER.OPER().STAWKA*_coef)$4;
                        _wyn[_kk][{? TOPER.TPZ='T' || 2 || 1 ?}]+=(_ww*_ntime)$4;
                        _a.ant.add(TOPER.OPER,_ww,,,_ntime,TOPER.PFAZ().WYD().KOD)
                     |? _c='U'
                     || _wyn[_kk][{? TOPER.TPZ='T' || 2 || 1 ?}]+={? TOPER.FCENA<>'' || _a.tpar.calc(TOPER.FCENA) || TOPER.CENA ?};
                        _a.ano.add(TOPER.TTOUT,TOPER.TTOUT().CENA)
                     |? _c='W'
                     || _mtime:={? TECHZAMS.FMTIME<>'' || _a.tpar.calc(TECHZAMS.FMTIME) || TECHZAMS.MTIME ?};
                        _ww:=TECHZAMS.KH;
                        _wyn[_kk][{? TOPER.TPZ='T' || 2 || 1 ?}]+=(_ww*_mtime)$4;
                        _a.anw.add({? TECHZAMS.GRPOJ='S' || TECHZAMS.PLACE || TECHZAMS.TWRKPLG().ELEMENT ?},_ww,,,_mtime)
                     |? _c='G'
                     || _coef:={? TECHZAMS.FCOEF<>'' & TECHZAMS.FCOEF<>'1'
                                || _a.tpar.calc(TECHZAMS.FCOEF)
                                || TECHZAMS.COEF
                                ?};
                        _ntime:={? TECHZAMS.FNTIME<>'' || _a.tpar.calc(TECHZAMS.FNTIME) || TECHZAMS.NTIME ?};
                        _wyn[_kk][{? TOPER.TPZ='T' || 2 || 1 ?}]+=_ntime$4
                     ?}
                  ?}
               ?}
            ?}
         ?}
      ?};
      __TOPER.next()
   !}
?};
_wyn


\get2_proc_price
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.60] OWwPR032
:: OPIS: Pobiera PLNX dla wszystkich operacji procesu
::       Działa analogicznie do get_proc_price/kalk_oper,
::       ale dla kalkulacji wstępnej zlecenia.
::       Pobiera PLNX lub CENA w zależnosci od WE
::   WE: _a - kalkulacja
::       _b - zlecenie
::       _c = 'R' - robocizna (operacje wewnętrzne)
::            'U' - usługi obce (operacje zewnętrzne)
::            'W' - koszt stanowisk
::            'G' - godziny pracy
::       [_d] - REAL - opcjonalny współczynik który skaluje wynik
::       [_e] - ilość kalkulowana (xjm). Gdy nie podana lub równa zeru to przeliczana wg ilości na przewdoniku
::   WY: _wyn[] dla poszczegolnych faz, drugi wymiar Tpz oraz czy operacja naprawcza
::  OLD: \get1_proc_price/zl_zoper.fml
::----------------------------------------------------------------------------------------------------------------------
_wynik:=obj_new(obj_len(_a.FAZY));
{! _ii:=1..(obj_len(_a.FAZY))
|! _wynik[_ii]:=obj_new(4); _wynik[_ii][1]:=0; _wynik[_ii][2]:=0; _wynik[_ii][3]:=0; _wynik[_ii][4]:=0
!};
_coef:=1;
{? var_pres('_d')=type_of(0)
|| _coef:=_d
?};
_xjm:=0;
{? var_pres('_e')=type_of(0)
|| _xjm:=_e
?};
ZGH.index('ZLNR');
ZGH.prefix(_b);
{? ZGH.first()
|| {!
   |? ZGP.index('PNRPP');
      ZGP.prefix(ZGH.ref());
      {? ZGP.first()
      || {!
         |? {! _ll:=1..(obj_len(_a.FAZY))
            |! _kk:=1; {? _a.FAZY[_ll]=ZGP.PFAZ || _kk:=_ll ?}
            !};
            _wynik[_kk][1]+=exec('get1_oper_price','kalk_oper',_a,_c,'N','N',_xjm,_coef);
            _wynik[_kk][2]+=exec('get1_oper_price','kalk_oper',_a,_c,'T','N',_xjm,_coef);
            _wynik[_kk][3]+=exec('get1_oper_price','kalk_oper',_a,_c,'N','T',_xjm,_coef);
            _wynik[_kk][4]+=exec('get1_oper_price','kalk_oper',_a,_c,'T','T',_xjm,_coef);
            ZGP.next()
         !}
      ?};
      ZGH.next()
   !}
?};
ZGH.clear();
_wynik


\get_oper_price
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: pobiera wartości lub czasy dla operacji
::   WE: _a - wskazanie na obiekt kalkulacyjny
::       _b - UNROP operacji
::       _c = 'R' - robocizna (operacje wewnętrzne)
::            'U' - usługi obce (operacje zewnętrzne)
::            'W' - koszt stanowisk (operacje wewnętrzne)
::            'G' - godziny pracy (operacje wewnętrzne)
::       _d = 'T' - tylko TPZ
::            'N' - tylko czas jednostkowy
::       _e - ilość kalkulowana (xjm)
::       [_f] - REAL - opcjonalny współczynik który skaluje wynik
::   WY: wyliczona wartość
::  OLD: \get_oper_price/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
_kalk:=_a;

TOPER.cntx_psh();
TOPER.clear();
TOPER.index('UNROP');
TOPER.prefix(_b);
{? TOPER.first()
|| _par:=(TOPER.NRK().TYP().PAR='T');
   {? TOPER.ACT='T'
   || {? TOPER.PZ='P' & TOPER.TPZ=_d
      || _coefinal:={? var_pres('_f')=type_of(0) || _f || 1 ?};
::       Wyjątki, dla których wynik nie jest skalowany
         {? TOPER.TPZ='T' | (_c='R' & TOPER.OPER().PLATNE='A') | TOPER.FIX_NORM='T' || _coefinal:=1  ?};
         {? _c='R'
         || _coef:={? _par & TOPER.FCOEF<>'' & TOPER.FCOEF<>'1' || _kalk.tpar.calc(TOPER.FCOEF) || TOPER.COEF ?};
            _ntime:={? _par & TOPER.FNTIME<>'' || _kalk.tpar.calc(TOPER.FNTIME) || TOPER.NTIME ?};
::          Skalowanie wg podanego przelicznika
            _ntime:=_ntime*_coefinal;
            {? TOPER.NRK().ZL=null()
            || _xjm:={? _e>0 || _e || KKTL.NRK().XJM ?}
            || _xjm:={? _e>0 || _e || exec('FindAndGet','#table',ZL,ANZH.ZLEC,,"IL",0) ?}
            ?};
            _ww:={? _d='T' || (TOPER.KH*_coef)$4 || (TOPER.OPER().STAWKA*_coef)$4 ?};
            {? TOPER.OPER().PLATNE='A' || _wyn+=(_ww*_xjm)$4 || _wyn+=(_ww*_ntime)$4 ?};
::            _il:=(_ww*_ntime)$4;
            _kalk.ant.add(TOPER.OPER,_ww,,,{? TOPER.OPER().PLATNE='A' || _xjm || _ntime ?},TOPER.PFAZ().WYD().KOD)
         |? _c='U'
         || _ww:={? _par & TOPER.FCENA<>'' || _kalk.tpar.calc(TOPER.FCENA) || TOPER.CENA ?};
            _cena:=TOPER.TTOUT().CENA;
            _il:={? _cena=0 || 0 || TOPER.CENA/_cena ?};
::          Skalowanie wg podanego przelicznika
            _ww:=_ww*_coefinal;
            _il:=_il*_coefinal;
            _wyn+=_ww$4;
            _kalk.ano.add(TOPER.TTOUT,_cena,,,_il)
         |? _c='W'
         || _mtime:={? _par & TOPER.FMTIME<>'' || _kalk.tpar.calc(TOPER.FMTIME) || TOPER.MTIME ?};
::          Skalowanie wg podanego przelicznika
            _mtime:=_mtime*_coefinal;
            _ww:={? TOPER.GRPOJ='S' || TOPER.KH || TOPER.TWRKPLG().ELEMENT().KH ?};
            _wyn+=(_ww*_mtime)$4;
            _kalk.anw.add({? TOPER.GRPOJ='S' || TOPER.PLACE || TOPER.TWRKPLG().ELEMENT ?},_ww,,,_mtime)
         |? _c='G'
         || _coef:={? _par & TOPER.FCOEF<>'' & TOPER.FCOEF<>'1' || _kalk.tpar.calc(TOPER.FCOEF) || TOPER.COEF ?};
            _ntime:={? _par & TOPER.FNTIME<>'' || _kalk.tpar.calc(TOPER.FNTIME) || TOPER.NTIME ?};
            _wyn+=_ntime$4
         ?}
      |? TOPER.PZ='Z'
      || _ktl:=TOPER.NRK;
         _unrop:=TOPER.UNROP;
         TOPER.cntx_psh();
         TOPER.clear();
         TOPER.index('NNN');
         TOPER.prefix(_ktl,_unrop);
         {? TOPER.first()
         || {!
            |? {? ~_par | _kalk.tpar.calc(TOPER.EXIST)
               || _wyn+=exec('get_oper_price','kalk_oper',_kalk,TOPER.UNROP,_c,_d,_e)
               ?};
               TOPER.next()
            !}
         ?};
         TOPER.cntx_pop()
      ?}
   ?}
?};
TOPER.cntx_pop();
_wyn


\get1_oper_price
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.60] OWwPR032, OWwPR034
:: OPIS: Dziala analogicznie do get_oper_price/kalk_oper,
::       ale dla kalkulacji wstępnej zlecenia.
::       Pobiera PLN lub CENA w zależności od WE
::   WE: _a - kalkulacja
::       _b = 'R' - robocizna (operacje wewnętrzne)
::            'U' - usługi obce (operacje zewnętrzne)
::            'W' - koszt stanowisk
::            'G' - godziny pracy
::       _c = 'T' - tylko TPZ
::            'N' - tylko czas jednostkowy
::       _d = 'T' - operacja naprawcza
::            'N' - operacja zwykła
::       _e - ilość kalkulowana (xjm)
::       [_f] - REAL - opcjonalny współczynik który skaluje wynik
::  OLD: \get1_oper_price/zl_zoper.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;

{? ZGP.TPZ=_c & ZGP.NAPRAW=_d
|| _fix_norm:=exec('FindAndGet','#table',TOPER,ZGP.RTOPER,,"FIX_NORM='T'",0);
   _platne:=exec('FindAndGet','#table',TOPER,ZGP.RTOPER,,"OPER().PLATNE='A'",0);
   _coefinal:={? var_pres('_f')=type_of(0) || _f || 1 ?};
:: Wyjątki, dla których wynik nie jest skalowany
   {? ZGP.TPZ='T' | (_b='R' & _platne) | _fix_norm || _coefinal:=1  ?};

   {? _b='R'
   || _xjm:={? _e>0 || _e || ZGP.ILOSC ?};
::    Skalowanie wg podanego przelicznika
      _ntime:=ZGP.NTIME*_coefinal;
      _ww:={? ZGP.NTIME=0 || exec('FindAndGet','#table',TOPER,ZGP.RTOPER,,"OPER().STAWKA",0) || ZGP.PLNX/ZGP.NTIME ?};
      {? _platne
      || _wyn+=_ww*_xjm
      || _wyn+=_ww*_ntime
      ?};
      _a.ant.add(exec('FindAndGet','#table',TOPER,ZGP.RTOPER,,"OPER",null()),_ww,,,{? _platne || _xjm || _ntime ?}
      )
   |? _b='U'
   || _cena:=exec('FindAndGet','#table',TOPER,ZGP.RTOPER,,"TTOUT().CENA",0);
      _il:={? _cena<>0 || ZGP.CENA/_cena || 0 ?};
::    Skalowanie wg podanego przelicznika
      _il:=_il*_coefinal;
      _wyn+=(ZGP.CENA*_coefinal)$4;
      _a.ano.add(exec('FindAndGet','#table',TOPER,ZGP.RTOPER,,"TTOUT",null()),_cena,,,_il)
   |? _b='W'
   || _mtime:=ZGP.MTIME;
::    Skalowanie wg podanego przelicznika
      _mtime:=_mtime*_coefinal;
      _ww:=ZGP.PLACE().KH;
      _wyn+=(_ww*_mtime)$4;
      _a.anw.add(ZGP.PLACE,ZGP.PLACE().KH,,,_mtime)
   |? _b='G'
   || _wyn+=ZGP.NTIME
   ?}
?};
_wyn


\get_rob_price
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: zwraca koszt robocizny wykonanej na zlecenie
::   WE: _a - wskazanie na obiekt kalkulacyjny
::       _b - ZL.ref()
::       _c - 2. parametr funkcji r() lub w() lub g() (czy od początku zlecenia)
::       _d - 'R', 'W', 'G'
::   WY: tablica wynikowa
::  OLD: \get_rob_price/zl_zoper.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_zlref:=_b;
_allokr:=_c;
_rwg:=_d;

_wynik:=obj_new(obj_len(_obj.FAZY));
{! _ii:=1..obj_len(_obj.FAZY)
|! _wynik[_ii]:=obj_new(4); _wynik[_ii][1]:=0; _wynik[_ii][2]:=0; _wynik[_ii][3]:=0; _wynik[_ii][4]:=0
!};

{? ANZH.OKR=null() & ANZH.DT=date(0,0,0)
|| _dataod:=date(date()~1,date()~2,1);
   _datado:=date(date()~1,date()~2,0)
|? ANZH.OKR=null()
|| _dataod:=date(ANZH.DT~1,ANZH.DT~2,1);
   _datado:=date(ANZH.DT~1,ANZH.DT~2,0)
|| _dataod:=date(ANZH.OKR().ROK,ANZH.OKR().MC,1);
   _datado:=date(ANZH.OKR().ROK,ANZH.OKR().MC,0)
?};
_zlgd:=sql(''+
           "
             SELECT
                REFERENCE AS REF
               ,ZGH
               ,ZGP
               ,DT
               ,TO_DATE(:_b)
               ,TO_DATE(:_c)
             FROM
               @ZLGD
             WHERE
               ZLGD.ZL=:_a
           "
           +{? _allokr=0
            || "
               AND ZLGD.DT BETWEEN TO_DATE(:_b) AND TO_DATE(:_c)
               "
            || "
               AND ZLGD.DT<=TO_DATE(:_c)
               "
            ?}
           +
           "
           "
           ,_zlref
           ,_dataod
           ,_datado
          );
::Debug:
::_zlgd.win_sel(_zlgd.mk_sel(,,1));
::_zlgd.select();

_dane:=sql(''
          +"
            SELECT
               NVL(ZGP.PFAZ,'________________') AS PFAZ
              ,ZLGB.KW        AS KW
              ,ZLGB.TIME      AS TIME
              ,ZLGB.IL        AS IL
              ,ZGP.ILOSC      AS ILNPRZ
              ,ZGP.MTIME      AS MTIME
              ,TWRKPLC.KH     AS KH
              ,ZGP.TPZ        as TPZ
              ,ZGP.NAPRAW     as NAPRAW
            FROM
              :_a zlgd
              LEFT OUTER JOIN @ZLGB   USING (zlgd.REF,  ZLGB.ZLGD)
              LEFT OUTER JOIN @ZGH    USING (zlgd.ZGH,  ZGH.REFERENCE)
              LEFT OUTER JOIN @ZGP    USING (zlgd.ZGP,  ZGP.REFERENCE)
              LEFT OUTER JOIN TWRKPLC USING (ZGP.PLACE, TWRKPLC.REFERENCE)
          "
          ,_zlgd
          );
::Debug:
::_dane.win_sel(_dane.mk_sel(,,1));
::_dane.select();

_res:=sql(''
         +"
            SELECT
               fazyt.LP       AS LP
              ,fazyt.KOD      AS KOD
              ,SUM(case when dane.TPZ='N' and dane.NAPRAW='N' then dane.KW else 0 end)   AS RN_R
              ,SUM(case when dane.TPZ='N' and dane.NAPRAW='T' then dane.KW else 0 end)   AS RT_R
              ,SUM(case when dane.TPZ='T' and dane.NAPRAW='N' then dane.KW else 0 end)   AS PN_R
              ,SUM(case when dane.TPZ='T' and dane.NAPRAW='T' then dane.KW else 0 end)   AS PT_R
              ,SUM(case when dane.TPZ='N' and dane.NAPRAW='N' then dane.TIME else 0 end) AS RN_G
              ,SUM(case when dane.TPZ='N' and dane.NAPRAW='T' then dane.TIME else 0 end) AS RT_G
              ,SUM(case when dane.TPZ='T' and dane.NAPRAW='N' then dane.TIME else 0 end) AS PN_G
              ,SUM(case when dane.TPZ='T' and dane.NAPRAW='T' then dane.TIME else 0 end) AS PT_G
              ,SUM(case when dane.TPZ='N' and dane.NAPRAW='N' then
                    CASE
                      WHEN dane.ILNPRZ=0 OR dane.IL=0 THEN 0
                      ELSE (dane.IL/dane.ILNPRZ)*dane.MTIME*dane.KH
                    END
                   else 0 end)       AS RN_W
              ,SUM(case when dane.TPZ='N' and dane.NAPRAW='T' then
                    CASE
                      WHEN dane.ILNPRZ=0 OR dane.IL=0 THEN 0
                      ELSE (dane.IL/dane.ILNPRZ)*dane.MTIME*dane.KH
                    END
                   else 0 end)       AS RT_W
              ,SUM(case when dane.TPZ='T' and dane.NAPRAW='N' then
                    CASE
                      WHEN dane.ILNPRZ=0 OR dane.IL=0 THEN 0
                      ELSE (dane.IL/dane.ILNPRZ)*dane.MTIME*dane.KH
                    END
                   else 0 end)       AS PN_W
              ,SUM(case when dane.TPZ='T' and dane.NAPRAW='T' then
                    CASE
                      WHEN dane.ILNPRZ=0 OR dane.IL=0 THEN 0
                      ELSE (dane.IL/dane.ILNPRZ)*dane.MTIME*dane.KH
                    END
                   else 0 end)       AS PT_W
            FROM
              :_a fazyt
              LEFT OUTER JOIN :_b dane USING(fazyt.REF, dane.PFAZ)
            GROUP BY
               fazyt.LP
              ,fazyt.KOD
          "
         ,_obj.FAZYt
         ,_dane
         );

{? _res.first()
|| {!
   |? _wynik[_res.LP][1]:={? _rwg='R' || _res.RN_R
                          |? _rwg='G' || _res.RN_G
                          |? _rwg='W' || _res.RN_W
                                      || 0
                          ?};
      _wynik[_res.LP][2]:={? _rwg='R' || _res.PN_R
                          |? _rwg='G' || _res.PN_G
                          |? _rwg='W' || _res.PN_W
                                      || 0
                          ?};
      _wynik[_res.LP][3]:={? _rwg='R' || _res.RT_R
                          |? _rwg='G' || _res.RT_G
                          |? _rwg='W' || _res.RT_W
                                      || 0
                          ?};
      _wynik[_res.LP][4]:={? _rwg='R' || _res.PT_R
                          |? _rwg='G' || _res.PT_G
                          |? _rwg='W' || _res.PT_W
                                      || 0
                          ?};
      _res.next()
   !}
?};
_wynik


::======================================================================================================================
:: Zamienniki w symulacji what-if
::======================================================================================================================


\oper_kalk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Utworzenie i wypełnienie tabeli tymczasowej operacji technologii
::  OLD: \oper_kalk/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__TOPER')<=0
|| __TOPER:=tab_tmp(1,
      'LP','INTEGER','Lp.',
      'REF','INTEGER','#TOPER.ref()',
      'NROP','STRING[30]','Numer operacji',
      'PLACE','INTEGER','Stanowisko - #TWRKPLC.ref()',
      'KOD','STRING[10]','Kod stanowiska',
      'NA','STRING[60]','Nazwa stanowiska',
      'TECHZAMS','INTEGER','Zamiennik stanowiska - #TECHZAMS.ref()',
      'NTIME','REAL','Norma czasowa',
      'MTIME','REAL','Czas maszynowy');
   __TOPER.fld_attr(,2);

   TOPER.clear();
   TOPER.index('ANNN');
   TOPER.prefix('T','N',VAR.A_KKTL().NRK);
   {? TOPER.first()
   || _i:=1;
      {!
      |?
         {? TOPER.PZ='P' & TOPER.WEW='T'
         ||
            __TOPER.LP:=_i;
            __TOPER.REF:=#TOPER.ref();
            __TOPER.NROP:=exec('get_oper_nr','tech_oper',TOPER.UNROP);
            {? TOPER.GRPOJ='S'
            ||
               __TOPER.PLACE:=#TOPER.PLACE;
               __TOPER.KOD:=TOPER.PLACE().KOD;
               __TOPER.NA:=TOPER.PLACE().NA
            ||
               __TOPER.PLACE:=#TOPER.TWRKPLG().ELEMENT;
               __TOPER.KOD:=TOPER.TWRKPLG().ELEMENT().KOD;
               __TOPER.NA:=TOPER.TWRKPLG().ELEMENT().NA
            ?};
            __TOPER.TECHZAMS:=0; 'domyslnie';
            __TOPER.NTIME:=TOPER.NTIME;
            __TOPER.MTIME:=TOPER.MTIME;
            _i+=1;
            __TOPER.add()
         ?};
         TOPER.next()
      !}
   ?}
?};
_wer:=__TOPER.mk_sel('Stanowiska kalkulowanej technologii'@,'N',0,'toper_wer',,5,29);
__TOPER.win_fld(_wer,,'NROP',,,14,,,'Numer operacji'@);
__TOPER.win_fld(_wer,,'KOD',,,10,,,'Kod'@);
__TOPER.win_fld(_wer,,'NA',,,40,,,'Nazwa'@);
__TOPER.win_fld(_wer,,'NTIME',,,15,4,,'Norma czasowa'@);
__TOPER.win_fld(_wer,,'MTIME',,,15,4,,'Czas maszynowy'@);
__TOPER.win_act(_wer,0,'Formuła','Zamienniki'@@,,,"exec('zamoper','kalk_oper')",,1);
__TOPER.win_sel(_wer);
__TOPER.prefix();
__TOPER.first();
__TOPER.select();
~~


\zamoper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Wyświetla zamienniki do stanowiska operacji i pozwala je podmienić
::       Formuła działa w kontekscie tabeli __TOPER
::  OLD: \zamoper/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
VAR_DEL.delete('__TOPERZ');
__TOPERZ:=tab_tmp(1,
   'TOPER','INTEGER','#__TOPER.ref()',
   'REF','INTEGER','#TOPER.ref()',
   'PLACE','INTEGER','Stanowisko - #TWRKPLC.ref()',
   'KOD','STRING[10]','Kod stanowiska',
   'NA','STRING[60]','Nazwa stanowiska',
   'TECHZAMS','INTEGER','Zamiennik stanowiska - #TECHZAMS.ref()',
   'NTIME','REAL','Norma czasowa',
   'MTIME','REAL','Czas maszynowy',
   'ZAMIENN','INTEGER','Zamiennik');
__TOPERZ.fld_attr(,2);
__TOPERZ.fld_attr('NTIME',1);
__TOPERZ.fld_attr('MTIME',1);

{? TOPER.seek(__TOPER.REF,)
|| __TOPERZ.TOPER:=#__TOPER.ref();
   __TOPERZ.REF:=#TOPER.ref();
   {? TOPER.GRPOJ='S'
   ||
      __TOPERZ.PLACE:=#TOPER.PLACE;
      __TOPERZ.KOD:=TOPER.PLACE().KOD;
      __TOPERZ.NA:=TOPER.PLACE().NA
   ||
      __TOPERZ.PLACE:=#TOPER.TWRKPLG().ELEMENT;
      __TOPERZ.KOD:=TOPER.TWRKPLG().ELEMENT().KOD;
      __TOPERZ.NA:=TOPER.TWRKPLG().ELEMENT().NA
   ?};
   __TOPERZ.TECHZAMS:=0;
   __TOPERZ.NTIME:=TOPER.NTIME;
   __TOPERZ.MTIME:=TOPER.MTIME;
   __TOPERZ.ZAMIENN:=0;
   __TOPERZ.add();
   TECHZAMS.index('TL');
   TECHZAMS.prefix(TOPER.ref());
   {? TECHZAMS.first()
   || {!
      |? {? TECHZAMS.GRPOJ='S'
         || __TOPERZ.TOPER:=#__TOPER.ref();
            __TOPERZ.REF:=#TOPER.ref();
            __TOPERZ.PLACE:=#TECHZAMS.PLACE;
            __TOPERZ.KOD:=TECHZAMS.PLACE().KOD;
            __TOPERZ.NA:=TECHZAMS.PLACE().NA;
            __TOPERZ.TECHZAMS:=#TECHZAMS.ref();
            __TOPERZ.NTIME:=TECHZAMS.NTIME;
            __TOPERZ.MTIME:=TECHZAMS.MTIME;
            __TOPERZ.ZAMIENN:=1;
            __TOPERZ.add()
         || TWRKZPO.cntx_psh();
            TWRKZPO.index('GRUPA');
            TWRKZPO.prefix(TECHZAMS.GRUPA);
            {? TWRKZPO.first()
            || {!
               |? __TOPERZ.TOPER:=#__TOPER.ref();
                  __TOPERZ.REF:=#TOPER.ref();
                  __TOPERZ.PLACE:=#TWRKZPO.ELEMENT;
                  __TOPERZ.KOD:=TWRKZPO.KOD_;
                  __TOPERZ.NA:=TWRKZPO.NAZ_;
                  __TOPERZ.TECHZAMS:=#TECHZAMS.ref();
                  __TOPERZ.NTIME:=TECHZAMS.NTIME;
                  __TOPERZ.MTIME:=TECHZAMS.MTIME;
                  __TOPERZ.ZAMIENN:=1;
                  __TOPERZ.add();
                  TWRKZPO.next()
               !}
            ?};
            TWRKZPO.cntx_pop()
         ?};
         TECHZAMS.next()
      !}
   ?}
?};

_wer:=__TOPERZ.mk_sel('Dostępne stanowiska'@,'N',0,'zamoper',,10,15);
__TOPERZ.win_fld(_wer,,'KOD',,,,,,'Kod'@);
__TOPERZ.win_fld(_wer,,'NA',,,,,,'Naza'@);
__TOPERZ.win_fld(_wer,,'NTIME',,,15,5,,'Norma czasowa'@);
__TOPERZ.win_fld(_wer,,'MTIME',,,15,5,,'Czas maszynowy'@);
__TOPERZ.win_fld(_wer,,'ZAMIENN',,,,,,'Zamiennik'@,,,2,,"1","0");
__TOPERZ.win_act(_wer,,'Formuła','Wybierz'@@,,,"
   __TOPER.PLACE:=__TOPERZ.PLACE;
   __TOPER.KOD:=__TOPERZ.KOD;
   __TOPER.NA:=__TOPERZ.NA;
   __TOPER.NTIME:=__TOPERZ.NTIME;
   __TOPER.MTIME:=__TOPERZ.MTIME;
   __TOPER.TECHZAMS:=__TOPERZ.TECHZAMS;
   __TOPER.put();
   sel_exit()
",,1);
__TOPERZ.win_act(_wer,,'Rekord',,,,"{? __TOPER.PLACE=__TOPERZ.PLACE || exec('findtmp','#color') || ~~ ?}");
__TOPERZ.win_act(_wer,,'Formuła','Legenda'@@,,,"exec('legenda','color','$%1'['Wybrane stanowisko'@])");
__TOPERZ.win_sel(_wer);
__TOPERZ.select();
VAR_DEL.delete('__TOPERZ');
~~

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:36 997d80e5b712bc79dde96eaa62c35babdd9bccd7ca02db7e8c7c01dbb2cde2a74688bb803c9d6954803dd02cb1829dfb82a84d55b61f7949a161ce695f57cea3f1261347f95e99e9793be8f20d98577095bc6e8fe38d3ece6613d882054c6f8e3d5e967c4e0b93d81a534b78f4df584bcbe50de838b4d4506623ce1bbd81d774
