:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: zasoby.fml
:: Utworzony: 17.02.2014
:: Autor: TS
::======================================================================================================================
:: Zawartość: Wspólne formuły do obsługi zasobów projektowo-remontowo-produkcyjnych (biblioteka)
::======================================================================================================================


\projdost
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMK] [2009]
:: OPIS: Edycja rekordow w tabeli PROJDOST od strony tabeli źrodłowej
::   WE: _a - ref sql tabeli zasobu
::       _b - data początkowa
::       _c - data końcowa
::       _d - Dostępność / Niedostępność
::       _e - wymiar (kadry i płace)
::       _f - 1 dołączanie - 2 - poprawianie (dla bieżącego rekordu)
::       [_g] - jeśli zadeklarowane to od razu uzupełniane pole PROJDOST.PROJZAS
::   WY: ref/null - jeśli udało się dołączanie/poprawianie rekordu w tabeli PROJDOST to ref
::                  rekordu, w przeciwnym przypadku null
::  OLD: \projdost/skid_prj.fml
::  TAG: <TAB:PROJDOST><ADD><PUT>
::----------------------------------------------------------------------------------------------------------------------
_zwrot:=null();
PROJDOST.cntx_psh();
PROJDOST.index('ZRODLOZ'); PROJDOST.prefix();
{? _f=1 || PROJDOST.blank(1) ?};
PROJDOST.ZRODLOZ:=_a;
PROJDOST.POCZATEK:=_b;
PROJDOST.KONIEC:=_c;
PROJDOST.DOSNDOS:=_d;
PROJDOST.WYMIAR:=_e;
{? _=7 & _g=1 || PROJDOST.PROJZAS:=PROJZAS.ref() ?};
_ok:={? _f=1 || PROJDOST.add() || PROJDOST.put() ?};
{? _ok || _zwrot:=PROJDOST.ref() ?};
PROJDOST.cntx_pop();
_zwrot


\f_zsb_stan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [2009]
:: OPIS: Wyszukiwanie zasobu dla stanowiska
::   WY: 1 - znaleziono zasób dla stanowiska, 0 - brak zasobu
::  OLD: \f_zsb_stan/skid_rem.fml
::----------------------------------------------------------------------------------------------------------------------
_jest:=0;
PROJZAS.index('TWRKPLC');
PROJZAS.prefix(TWRKPLC.ref());
{? PROJZAS.first() || _jest:=1 ?};
_jest


\twrkplc_pop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PJ [2009]
:: OPIS: Aktualizacja nazwy zasobu (jeśli jest) po zmianie nazwy stanowiska
::        produkcyjnego
::  OLD: \twrkplc_pop/skid_rem.fml
::  TAG: <TAB:PROJZAS><PUT>
::----------------------------------------------------------------------------------------------------------------------
{? exec('f_zsb_stan','zasoby')
|| {? PROJZAS.NAZWA<>TWRKPLC.NA
   || PROJZAS.NAZWA:=TWRKPLC.NA;
      PROJZAS.put()
   ?}
?}


\projdost_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Usuwa powiązane rekordy PROJDOST z konkretnym zasobem źródłowym
::   WE: _a - SQL ref zasobu źródłowego
::   WY: 0 / 1 - czy udało się skasować (NIE pozostały rekordy)
::  TAG: <TAB:PROJDOST><DEL>
::----------------------------------------------------------------------------------------------------------------------
PROJDOST.index('ZRODLOZ');
PROJDOST.prefix(_a,_a);
{? PROJDOST.first() || {! |? PROJDOST.del() !} ?};
~PROJDOST.first()


\twrkplc_filter_wye
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: TWRKPLC - Ustawia filtr słownika na wydział VAR.A_WYD oraz bez wydziału
::  OLD: \wrkplc_wye/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
FILTER.WYD:=2;
_wyd:=$VAR.A_WYD;
{? _wyd=''
|| exec('twrkplc_filter_all','zasoby');
   TWRKPLC.actions('SLO','Fk')
|| TWRKPLC.f_set('KOD',,'"TWRKPLC"."WYD"=\':_a\' or "TWRKPLC"."WYD" is null',_wyd);
   TWRKPLC.actions('SLO','k')
?};
exec('twrkplc_title','zasoby');
~~


\twrkplc_filter_wyd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: TWRKPLC - Ustawia filtr słownika na wydzial VAR.A_WYD
::  OLD: \wrkplc_wyd/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
FILTER.WYD:=1;
_wyd:=$VAR.A_WYD;
{? _wyd=''
|| exec('twrkplc_filter_all','zasoby');
   TWRKPLC.actions('SLO','Fk')
|| TWRKPLC.f_set('KOD',,'"TWRKPLC"."WYD"=\':_a\'',_wyd);
   TWRKPLC.actions('SLO','k')
?};
exec('twrkplc_title','zasoby');
~~


\twrkplc_filter_grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ustawia filtr słownika TWRKPLC na gniazdo ZGP.GRUPA (tylko przy redagowaniu pozycji przewodnika)
::  OLD: \wrkplc_grp/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZGP.GRUPA<>null()
|| TWRKPLC.f_set('KOD','join TWRKZPO','TWRKZPO.GRUPA=:_a',ZGP.GRUPA);
   TWRKPLC.hdr_sel();
   TWRKPLC.hdr_sel(' '+'gniazda %1'@[ZGP.GRUPA().SYMBOL])
?};
~~


\twrkplc_filter_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: TWRKPLC - Ustawia filtr słownika na całą dziedzinę
::  OLD: \wrkplc_all/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
FILTER.WYD:=0;
TWRKPLC.f_set('KOD');
exec('twrkplc_title','zasoby');
~~


\twrkplc_filter_place
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: TWRKPLC - Ustawia filtr słownika na konkretne stanowisko
::   WE: _a - ref stanowiska TWRKPLC.ref()
::----------------------------------------------------------------------------------------------------------------------
_place:=$_a;
{? _place=''
|| exec('twrkplc_filter_all','zasoby')
|| TWRKPLC.f_set('KOD',,'"TWRKPLC"."REFERENCE"=\':_a\'',_place)
?};
~~


\twrkplc_filter_plugin
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Uruchamia wtyczkę TWRKPLC_FILTER_001, która ma za zadanie ustawienie filtru na tabelę TWRKPLC.
::       Jeżeli wtyczka nie ma zdefiniowanej formuły lub po jej wywołaniu nie będzie ustawiony filtr na stanowiska, to
::       zostaje ustawiony filtr na całą dziedzinę
::   WE: [_a] - PROD_REJ.ref() - wymagany parametr do wtyczki, jeżeli nie podany to brany jest akutalny rekord
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_press('_a')=type_of(PROD_REJ.ref()) || _a || PROD_REJ.ref() ?};
{? TWRKPLC.f_active()>0 || TWRKPLC.f_clear() ?};
_plugin:=0;
:: Jak jest zdefiniowana formuła na wtyczkę TWRKPLC_FILTER_001 to uruchamiam (ustawiam filtr na stanowiska)
{? Plugin.runnable('TWRKPLC_FILTER_001')
|| _plugin:=1;
   Plugin.run('TWRKPLC_FILTER_001',_ref)
?};
:: Jak nie ma wtyczki lub nie ustalono filtru to pokazuje wszystkie stanowiska
{? _plugin=0 | TWRKPLC.f_active()=0
|| exec('twrkplc_filter_all','zasoby')
?};
TWRKPLC.actions('SLO','F:F');
~~


\twrkplc_title
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: TWRKPLC - Formuła do ustawiania tytułów okien tabeli jako słownika (dla filtra)
::  OLD: \wz_twrkplc/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
TWRKPLC.win_sel(TWRKPLC.win_dict('?'));
TWRKPLC.hdr_sel();
_tail:=
   {? FILTER.WYD=0
   || 'wszystkie'@
   |? FILTER.WYD=1
   || 'z wydziału %1'@[VAR.A_WYD().KOD]
   |? FILTER.WYD=2
   || 'z wydziału %1 i bez wydziału'@[VAR.A_WYD().KOD]
   || ''
   ?};
TWRKPLC.hdr_sel(' '+_tail);
''


\twrkzbr_filter_wye
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Ustawia filtr słownika TWRKZBR na wydział VAR.A_WYD oraz bez wydziału
::  OLD: \wrkzbr_wye/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
_wyd:=$VAR.A_WYD;
{? _wyd=''
|| FILTER.WYD:=0;
   TWRKZBR.f_set('SYMBOL')
|| FILTER.WYD:=2;
   TWRKZBR.f_set('SYMBOL',,'"TWRKZBR"."WYD"=\':_a\' or "TWRKZBR"."WYD" is null',_wyd)
?};
exec('twrkzbr_title','zasoby');
~~


\twrkzbr_filter_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Ustawia filtr słownika TWRKZBR na całą dziedzinę
::----------------------------------------------------------------------------------------------------------------------
FILTER.WYD:=0;
TWRKZBR.f_set('SYMBOL');
exec('twrkzbr_title','zasoby');
~~


\twrkzpo_filter_wye
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Ustawia filtr słownika TWRKZPO na wydział oraz bez wydziału
::  OLD: \wrkzpo_wye/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
:_wyd:=VAR.A_WYD().KOD;
_wyd:=TWRKZBR.WYD().KOD;
TWRKZPO.prefix();
TWRKPLC.blank();
{? _wyd=''
|| TWRKZPO.f_set(
      'KOD_',
      'join "TWRKZBR"',
      '"TWRKZBR"."SYMBOL"=\':_a\'',
      TWRKZBR.SYMBOL
   );
   TWRKZPO.actions('SLO')
|| TWRKZPO.f_set(
      'KOD_',
      'join "TWRKZBR"',
      '("TWRKZPO"."WYD_"=\':_a\' or "TWRKZPO"."WYD_"=\'\') and "TWRKZBR"."SYMBOL"=\':_b\'',
      _wyd,
      TWRKZBR.SYMBOL
   );
   TWRKZPO.actions('SLO')
?};
exec('twrkzbr_title','zasoby');
~~


\twrkzbr_title
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: TWRKZBR - Formuła do ustawiania tytułów okien tabeli jako słownika (dla filtra)
::----------------------------------------------------------------------------------------------------------------------
TWRKZBR.win_sel(TWRKZBR.win_dict('?'));
TWRKZBR.hdr_sel();
_tail:=
   {? FILTER.WYD=0
   || 'wszystkie'@
   |? FILTER.WYD=1
   || 'z wydziału %1'@[VAR.A_WYD().KOD]
   |? FILTER.WYD=2
   || 'z wydziału %1 i bez wydziału'@[VAR.A_WYD().KOD]
   || ''
   ?};
TWRKZBR.hdr_sel(' '+_tail);
''


\twrkzpo_filter_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Ustawia filtr słownika TWRKZPO na całą dziedzinę
::----------------------------------------------------------------------------------------------------------------------
TWRKZPO.f_set(
   'KOD_',
   'join "TWRKZBR"',
   '"TWRKZBR"."SYMBOL"=\':_a\'',
   TWRKZBR.SYMBOL
);
TWRKZPO.actions('SLO');
~~


\zlb_dost
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2009]
:: OPIS: Aktualizuje informacje o dostępności brygady - zasobu
::  OLD: \zlb_dost/skid_prr.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=$ZLBR.ref();
PROJDOST.cntx_psh;
PROJDOST.index('ZRODLOZ');
PROJDOST.prefix(_ref,_ref,'D');
{? PROJDOST.first()
|| PROJDOST.POCZATEK:=ZLBR.OD;
   PROJDOST.KONIEC:=ZLBR.DO;
   PROJDOST.put()
|| PROJDOST.blank();
   PROJDOST.ZRODLOZ:=_ref;
   PROJZAS.cntx_psh();
   PROJZAS.index('ZLBR');
   PROJZAS.prefix();
   {? PROJZAS.find_key(ZLBR.ref())
   || PROJDOST.PROJZAS:=PROJZAS.ref()
   ?};
   PROJZAS.cntx_pop();
   PROJDOST.WYMIAR:=1;
   PROJDOST.POCZATEK:=ZLBR.OD;
   PROJDOST.KONIEC:=ZLBR.DO;
   PROJDOST.DOSNDOS:='D';
   PROJDOST.add()
?};
PROJDOST.cntx_pop()


\ae_kod_h
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MZ [2009]
:: OPIS: po redakcji kodu harmonogramu
::  OLD: \ae_kod_h/um.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=1; _txt:='';
{? cur_tab.name()='samochod'
|| _tab:=($'SAM')();
  _txt:='samochodu'@
|? cur_tab.name()='zlbryg'
|| _tab:=($'ZLBR')();
  _txt:='brygady'@
|? cur_tab.name()='prac_smi'
|| _tab:=($'PRACW')();
  _txt:='pracownika'@
?};
{? _tab.H<>''
||
   _kod:=_tab.H;
   _ref:=_tab.ref();
   _tab.cntx_psh();
   _ndx:=_tab.ndx_tmp(,,'ODDZ',,,'H',,,'H',,);
   _tab.index(_ndx);
   _tab.prefix(ST.ODDZ,_kod,_kod);
   {? _tab.first()
   ||
      {!
      |?
         {? _tab.ref()<>_ref | -(1+menu_txt)='d'
         ||
           FUN.info('Istnieje już kod '@+_txt+' '+_kod+'.'); _wyn:=0
         ?};
         _wyn=1 & _tab.next()
      !}
   ?};
   _tab.ndx_drop(_ndx);
   _tab.cntx_pop()
?};
_wyn


\zlbs_f_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ustawia filtr na sklad brygady na zadany dzien
::   WE: _a - ZLBR.ref()
::       _b - date()
::   WY: wynik f_set()
::  OLD: \zlbs_f_set/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_zlbr:=_a;
_date:=_b;

ZLBS.prefix();
ZLBS.f_set(,'join P using(ZLBS.P,P.REFERENCE) left join CP using(P.CP,CP.REFERENCE)','
   P.FIRMA=:_c
   and
   "ZLBS"."BR"=:_a
:: TODO: czy dalej ograniczać do pracowników "fizycznych"?
::   and CP.S=\'FIZ\'
   and
       ( ( to_date(:_b) between "ZLBS"."OD" and "ZLBS"."DO" )
         or
         ( "ZLBS"."OD" is null and "ZLBS"."DO">=to_date(:_b) )
         or
         ( "ZLBS"."OD"<=to_date(:_b) and "ZLBS"."DO" is null )
         or
         ("ZLBS"."OD" is null and "ZLBS"."DO" is null )
       )
',_zlbr,_date,exec('ref_firma','ustawienia'))


\chk_twrkplc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Walidacja rekordu tabeli TWRKPLC (stanowiska) - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::       [_b] - czy sprawdzać wypełnienie pola 'Wydział' (domyślnie 0 - nie)
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')=type_of(0) || _chk_wyd:=_b || _chk_wyd:=1 ?};

_res:=__CHK.record(TWRKPLC,,'KOD','NA');
{? _res=''
||
   {? TWRKPLC.f_active()>0 & FILTER.WYD>0 & TWRKPLC.WYD<>null() & TWRKPLC.WYD<>VAR.A_WYD
   || FUN.info(
         'Przy aktualnym ustawieniu filtra nie można zatwierdzić definicji stanowiska.\n\n'
         'Proszę poprawić pole \'Wydział\'.'@
      );
      _res:='WYD'
   |? VAR.DPE<>date(0,0,0) & VAR.DKE<>date(0,0,0) & VAR.DPE>VAR.DKE
   ||
      FUN.emsg('Data końca eksploatacji nie może być wcześniejsza niż początkowa.'@);
      _res:='DKE'
   |? _chk_wyd & TWRKPLC.WYD=null()
   || {? FUN.ask(
            'Wskazanie jest określenie wydziału na którym pracuje stanowisko.\n\n'
            'Czy chcesz pozostawić pole \'Wydział\' niewypełnione?'@
         )
      || _res:=''
      || _res:='WYD'
      ?}
   ?};
   {? _res=''
   || {? TWRKPLC.KH<0
      || FUN.info('Wartość parametru "%1" nie może być ujemna.'@['Koszt godziny pracy'@]);
         _res:='KH'
      |? TWRKPLC.SKS<0
      || FUN.info('Wartość parametru "%1" nie może być ujemna.'@['Średni koszt serwisu'@]);
         _res:='SKS'
      |? TWRKPLC.LGBP<0
      || FUN.info('Wartość parametru "%1" nie może być ujemna.'@['Liczba godzin bezawaryjnej pracy'@]);
         _res:='LGBP'
      || _res:=''
      ?}
   ?};
   {? _res=''
   || _res:=__CHK.index(TWRKPLC,_a)
   ?}
?};
_res


\chk_twrkzbr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Walidacja rekordu tabeli TWRKZBR (gniazda) - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(TWRKZBR,,'SYMBOL','NAZWA');
{? _chk=''
|| {? __CHK.index(TWRKZBR,_a)<>''
   || _chk:='SYMBOL'
   ?}
?};
_chk


\chk_twrkzpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Walidacja rekordu tabeli TWRKZPO (elementy gniazda) - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(TWRKZPO,,'ELEMENT');
{? _chk=''
|| {? __CHK.index(TWRKZPO,_a)<>''
   || _chk:='ELEMENT'
   ?}
?};
_chk


\chk_prac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Mario [2009]
:: OPIS: po rekord
::  OLD: \chk_prac/um.fml
::----------------------------------------------------------------------------------------------------------------------
exec('chk_pracw_core','zasoby',-menu_txt()='popraw')


\chk_pracw_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: Mario [2009]
:: OPIS: po rekord
::  OLD: \chk_prac/um.fml
::----------------------------------------------------------------------------------------------------------------------
_zwrot:=__CHK.record(PRACW,,'H','P');
{? _zwrot=''
|| {? __CHK.index(PRACW,_a)<>'' || _zwrot:='H' ?}
?};
_zwrot


\ae_prac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MZ [2009]
:: OPIS: po redakcji PRACW.OSOBA uzupełnia imię i nazwisko
::  OLD: \ae_prac/um.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
{? fld<>0
|| PRACW.IM:=PRACW.P().PIERWSZE;
   PRACW.NA:=PRACW.P().NAZWISKO;
   exec('nazwisko','zasoby')
?};
''


\nazwisko
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MZ [2009]
:: OPIS: sumuje nazwisko i imie
::  OLD: \nazwisko/um.fml
::----------------------------------------------------------------------------------------------------------------------
PRACW.PRAC:=PRACW.NA+' '+PRACW.IM


\ae_p_typ
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MZ [2009]
:: OPIS: rodzaj pracownikow
::  OLD: \ae_p_typ/um.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
{? fld<>'N' & fld<>'W'
|| FUN.info('Dozwolone wartości.\nW - Warsztat, N - Nieczystości.'@)
|| _wyn:=1
?};
_wyn


\be_usun_pracw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [19.02]
:: OPIS: Przed usunięciem rekordu tabeli PRACW. Sprawdza, czy nie wykorzystywany
::   WY: 0 - nie można usuwać, pracownik wykorzystywany w innych danych systemie
::       1 - można usuwać
::----------------------------------------------------------------------------------------------------------------------
_count:=PRACW.count();
{? _count || FUN.emsg('Nie można usunąć pracownika. Istnieją zapisy z nim powiązane.'@) ?};
~_count


\rem_zas_windows
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Ustawia okna wertowania i redakcji dla zasobów remontowych i powiązanych kartotek
::----------------------------------------------------------------------------------------------------------------------
_res:=obj_new('WER','WERT');

REM_KAT.win_sel('WER');

exec('slo_m_ok','material','T',1);

REM_ZAS.win_edit('RED');

_res.WER:='WER';
_res.WERT:='WERT';

_res


\rem_zas_typ_val_pojazdy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Typ zasobu - pojazd
::----------------------------------------------------------------------------------------------------------------------
'Pojazd'


\rem_zas_typ_val_srsr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Typ zasobu - środek trwały
::----------------------------------------------------------------------------------------------------------------------
'Środek trwały'


\rem_zas_typ_val_twrkplc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Typ zasobu - stanowisko produkcyjne
::----------------------------------------------------------------------------------------------------------------------
'Stanowisko produkcyjne'


\rem_zas_typ_val_twrkzbr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Typ zasobu - gniazdo produkcyjne
::----------------------------------------------------------------------------------------------------------------------
'Gniazdo produkcyjne'


\rem_zas_typ_val_m
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Typ zasobu - materiał
::----------------------------------------------------------------------------------------------------------------------
'Materiał'


\rem_zas_typ_val_dk_c
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Typ zasobu - cecha dostawy
::----------------------------------------------------------------------------------------------------------------------
'Cecha dostawy'


\rem_zas_typ_val_null
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Typ zasobu - ogólny
::----------------------------------------------------------------------------------------------------------------------
'Niepowiązany'


\rem_zas_typ_val_multi
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Typ zasobu - wielokrotnie powiązany
::----------------------------------------------------------------------------------------------------------------------
'Wielokrotnie powiązany'


\chk_rem_kat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Walidacja rekordu tabeli REM_KAT - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(REM_KAT,,'SYMBOL');
{? _chk=''
|| {? __CHK.index(REM_KAT,_a)<>''
   || _chk:='SYMBOL'
   ?}
?};
:: Sprawdzam unikalność na polu TYP (Typ wniosku administracyjnego)
{? _chk='' & REM_KAT.TYP<>null()
|| _ref:=REM_KAT.ref();
   REM_KAT.cntx_psh();
   REM_KAT.index('TYP');
   REM_KAT.prefix(REM_KAT.TYP);
   {? REM_KAT.first() & REM_KAT.ref<>_ref
   || ETYPY.cntx_psh();
      FUN.emsg('Typ wniosku \'%1\' jest już przypisany do innej kategorii zasobu remontowego.'@[REM_KAT.TYP().NAZWA]);
      _chk:='TYP';
      ETYPY.cntx_pop()
   ?};
   REM_KAT.cntx_pop()
?};
_chk


\rem_zas_set_fml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Podmiana formuł dla pól w tabeli REM_ZAS
::----------------------------------------------------------------------------------------------------------------------
exec('set_fml','#field',UD_POM,'JORG',
   "UD_POM.JORG:=REM_ZAS.UD_SKL().SYMBOL; ~~",
   "exec('domyslny','schemat','PODZORG')<>null()",
   "exec('ud_def_symbol_f3','schemat','PODZORG')",
   "  {? fld()='' || REM_ZAS.UD_SKL:=null(); return(1) ?};
      _ref:=exec('ud_def_symbol_ae','schemat',UD_SCH.ref());
      {? _ref
      || REM_ZAS.UD_SKL:=_ref;
         fld(REM_ZAS.UD_SKL().SYMBOL)
      ?}
   "
);
~~


\rem_zas_srsr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Formuła sprawdza czy w systemie występuje zapis w tabeli REM_ZAS dla wskazanego środka
::   WE: SRSR.ref()
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
_srsr:=_a;
_res:=0;
REM_ZAS.cntx_psh();
REM_ZAS.index('SRSR');
REM_ZAS.prefix(_srsr);
{? REM_ZAS.first() || _res:=1 ?};
REM_ZAS.cntx_pop();
_res


\rem_zas_typ_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Zwraca ref() typu zasobu
::   WE: _a - typ zasobu (wynik formuły exec('rem_zas_typ_val_*','zasoby'))
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
REM_ZTP.cntx_psh();
REM_ZTP.index('TYP');
REM_ZTP.prefix(_a,);
{? REM_ZTP.first()
|| _ref:=REM_ZTP.ref()
?};
REM_ZTP.cntx_pop();
_ref


\rem_zasu_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja Dołącz w tabeli wertowania REM_ZASU
::   WE:
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------

_result:=0;
_can_continue:=1;

REM_ZASU.win_edit('RED');
REM_ZASU.cntx_psh();
REM_ZASU.prefix();
REM_ZASU.blank();
REM_ZASU.REM_ZAS:=REM_ZAS.ref();
REM_ZASU.OSOBA:=OPERATOR.USER().OSOBA;
REM_ZASU.OD:=date();
{? REM_ZASU.edit("exec('rem_zasu_valid','zasoby',0)")
|| _can_continue:=REM_ZASU.add();
   {? _can_continue>0
   ||
::    Przypisanie użytkownika, jeżeli osoba posiada takiego w systemie
      USERS.cntx_psh();
      USERS.index('OSOBA');
      USERS.prefix(REM_ZASU.OSOBA);
      {? USERS.first()
      || REM_ZASU.USERS:=USERS.ref();
         _can_continue:=REM_ZASU.put()
      ?};
      USERS.cntx_pop()
   ?}
?};
REM_ZASU.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\rem_zasu_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja Popraw w tabeli wertowania REM_ZASU
::   WE:
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------

_result:=0;
_can_continue:=1;

REM_ZASU.win_edit('RED');
REM_ZASU.cntx_psh();
{? REM_ZASU.edit("exec('rem_zasu_valid','zasoby',1)")
|| _can_continue:=REM_ZASU.put();
   {? _can_continue>0
   ||
::    Przypisanie użytkownika, jeżeli osoba posiada takiego w systemie
      USERS.cntx_psh();
      USERS.index('OSOBA');
      USERS.prefix(REM_ZASU.OSOBA);
      {? USERS.first()
      || REM_ZASU.USERS:=USERS.ref();
         _can_continue:=REM_ZASU.put()
      ?};
      USERS.cntx_pop()
   ?}
?};
REM_ZASU.cntx_pop();
REM_ZASU.get();
{? _can_continue>0
|| _result:=1
?};
_result


\rem_zasu_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Walidacja rekordu w tabeli REM_ZASU
::   WE: _a - INTEGER - rodzaj akcji: 0 - dołącz, 1 - popraw
::   WY: STRING
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_action:=_a;

_ref:=null();
{? _action=1
|| _ref:=REM_ZASU.ref()
?};
_result:='';
_rem_zas:=REM_ZASU.REM_ZAS;
_zas_str:=exec('record','#to_string',_rem_zas);

{? REM_ZASU.OSOBA=null()
||
:: Sprawdzam czy można wrócić do pola OSOBA
   _can_ret:=exec('chk_role','#b__box',OPERATOR.USER,'ZWS_DOS_PPDO') | exec('chk_role','#b__box',OPERATOR.USER,'ZWS_DOS_PRDO');
   {? _can_ret=0
   || _result:='OD';
      FUN.emsg('Nie można dodawać użytkowników zasobów. Brak dostępu do słownika danych osobowych.'@)
   ?}
?};

{? _result=''
|| _result:=__CHK.record(REM_ZASU,,'OSOBA','OD')
?};


{? _result=''
|| {? __CHK.index(REM_ZASU,_action)<>''
   || _result:='OSOBA'
   ?}
?};

{? _result=''
|| {? REM_ZASU.DO<>date(0,0,0) & REM_ZASU.OD>REM_ZASU.DO
   || _result:='OD';
      FUN.emsg('Nieprawidłowy zakres dat.\n\'Data od\' nie może być późniejsza niż \'Data do\'.'@)
   ?}
?};

_od:=REM_ZASU.OD;
_current:=exec('interval','#interval');
_current.START:=exec('create','#tm_stamp',REM_ZASU.OD,time(0,0,0));
{? REM_ZASU.DO<>date(0,0,0)
|| _current.END:=exec('create','#tm_stamp',REM_ZASU.DO,time(23,59,59))
?};

_last:=0;
{? _result=''
||
   REM_ZASU.cntx_psh();
   REM_ZASU.index('TM_START');

   REM_ZASU.cntx_psh();
   REM_ZASU.prefix(_rem_zas);
   {? REM_ZASU.last()
   || _last:=REM_ZASU.TM_END;

      {? _ref=REM_ZASU.ref()
      ||
::       Jeżeli poprawiam ostatni zapis skończony, to dla celów kontrolnych muszę wziąść inny zasób
::       niż poprawiany
         {? REM_ZASU.prev()
         || _last:=REM_ZASU.TM_END
         || _last:=0
         ?}
      ?}
   ?};
   REM_ZASU.cntx_pop();

   {? REM_ZASU.DO<>date(0,0,0)
   ||
      REM_ZASU.prefix(_rem_zas,exec('create','#tm_stamp',REM_ZASU.DO,time(0,0,0)));
      {? REM_ZASU.first() & REM_ZASU.ref()<>_ref
      || _osoba:=REM_ZASU.OSOBA().NAZWISKO+' '+REM_ZASU.OSOBA().PIERWSZE;
         _msg:='Istnieje już użytkownik: %1 zasobu: %2, który kończy jego użytkowanie w dniu: %3.\n'
               'Należy wskazać inną datę.'@[_osoba,_zas_str,$REM_ZASU.DO];
         FUN.emsg(_msg);
         _result:='DO'
      ?}
   ?};
   REM_ZASU.cntx_pop()
?};
{? _result=''
||
   REM_ZASU.cntx_psh();
   REM_ZASU.index('TM_START');
   REM_ZASU.prefix(_rem_zas,exec('create','#tm_stamp',REM_ZASU.OD,time(0,0,0)));
   {? REM_ZASU.first() & REM_ZASU.ref()<>_ref
   ||
      _osoba:=REM_ZASU.OSOBA().NAZWISKO+' '+REM_ZASU.OSOBA().PIERWSZE;
      _msg:='Istnieje już użytkownik: %1 zasobu: %2, który zaczyna jego użytkowanie w dniu: %3.\n'
            'Należy wskazać inną datę.'@[_osoba,_zas_str,$REM_ZASU.OD];
      FUN.emsg(_msg);
      _result:='OD'
   ?};
   REM_ZASU.cntx_pop()
?};


{? _result=''
||
   REM_ZASU.cntx_psh();
   REM_ZASU.index('TM_END');

   {? REM_ZASU.DO=date(0,0,0)
   ||
      {? _current.START<_last
      || _msg:='Bezterminowy okres użytkowania nie może się zaczynać wcześniej niż inne okresy z podanym terminem końcowym.'@;
         FUN.emsg(_msg);
         _result:='OD'
      ?}
   ?};
   REM_ZASU.cntx_pop()
?};


{? _result=''
||
   REM_ZASU.cntx_psh();
   REM_ZASU.index('TM_END');

   {? REM_ZASU.DO=date(0,0,0)
   || REM_ZASU.prefix(_rem_zas,0);
      {? REM_ZASU.first() & REM_ZASU.ref()<>_ref
      ||
         _osoba:=REM_ZASU.OSOBA().NAZWISKO+' '+REM_ZASU.OSOBA().PIERWSZE;
         {? _od>REM_ZASU.OD
         ||
            _msg:='Istnieje już użytkownik: %1 zasobu: %2 używający go bezterminowo.\n'
                  'Można skorygować bezterminowy zapis użytkownika: %1 lub ponowić redagowanie.'@[_osoba,_zas_str];
            _choice:=FUN.choice(_msg,,'Korekta poprzedniego zapisu'@);

            {? _choice=1
            || REM_ZASU.prefix();
               REM_ZASU.DO:=_od-1;
               {? REM_ZASU.put()=0
               || FUN.emsg('Nie udało się skorygować poprzedniego zapisu.'@);
                  _result:='DO'
               ?}
            || _result:='DO'
            ?}
         ||  _result:='OD';
             _msg:='Istnieje już użytkownik: %1 zasobu: %2 używający go bezterminowo.\n'
                   'Bieżący zapis koliduje z tamtym zapisem.'@[_osoba,_zas_str];
             FUN.emsg(_msg)
         ?}
      ?}
   ?};
   REM_ZASU.cntx_pop()
?};

{? _result=''
||
   _int:=exec('interval','#interval');

   {? _current.END=0
   || {? _last>0
      || _current.END:=_last+exec('day','#tm_stamp')
      || _current.END:=_current.START+exec('day','#tm_stamp')
      ?}
   ?};

   REM_ZASU.cntx_psh();
   REM_ZASU.index('REM_ZAS');
   REM_ZASU.prefix(REM_ZAS.ref());
   {? REM_ZASU.first()
   || {!
      |?
         {? REM_ZASU.ref()<>_ref
         ||
            _osoba:=REM_ZASU.OSOBA().NAZWISKO+' '+REM_ZASU.OSOBA().PIERWSZE;
            {? REM_ZASU.DO=date(0,0,0)
            || _msg:='Wprowadzony okres użytkowania zasobu: %1 koliduje z zapisem bezterminowym użytkownika: %2'@[_zas_str,_osoba];
               {? _current.START>REM_ZASU.TM_START
               || FUN.emsg(_msg);
                  _result:='OD'
               ?}
            || _msg:='Wprowadzony okres użytkowania zasobu: %1 koliduje z zapisem użytkownika: %2 (od: %3 do: %4)'@[_zas_str,_osoba,$REM_ZASU.OD,$REM_ZASU.DO];
               _int.START:=exec('create','#tm_stamp',REM_ZASU.OD,time(0,0,0));
               _int.END:=exec('create','#tm_stamp',REM_ZASU.DO,time(23,59,59));

               {? exec('intervals_chk','#interval',_int,_current)>0
               || FUN.emsg(_msg);
                  _result:='OD'
               ?}
            ?}
         ?};
         REM_ZASU.next() & _result=''
      !}
   ?};
   REM_ZASU.cntx_pop();
   ~~
?};
_result


\rem_zasu_del_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja w oknie - usunięcie rekordu
::   WE: [_a] - INTEGER - 0/[1] - czy wyświetlać dialogi
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRIVATE><AKCJA><DEL>
::----------------------------------------------------------------------------------------------------------------------
_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};

_result:=0;
_can_continue:=1;

_tab:=REM_ZASU;

_group:=0;
{? _tab.sel_size()>0
|| _group:=1;
   _dialog:=0
?};

:: Sprawdzam czy można usunąć
{? _group>0
|| _can_continue:=exec('rem_zasu_can_del','zasoby',,2)
|| _can_continue:=exec('rem_zasu_can_del','zasoby',,1)
?};

{? _dialog>0 & _can_continue>0
||
   _osoba:=REM_ZASU.OSOBA().NAZWISKO+' '+REM_ZASU.OSOBA().PIERWSZE;
   _zas_str:=exec('REM_ZAS','#to_string',REM_ZASU.REM_ZAS);
   _can_continue:=FUN.ask('Usunąć osobę: %1 użytkującą zasób: %2?'@[_osoba,_zas_str])
?};

{? _can_continue>0
|| _result:=exec('rem_zasu_delete','zasoby',_tab.ref())
?};
_result


\rem_zasu_del_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja usuń grupa przed w oknie wertowania tabeli REM_ZASU
::   WY: 0 - porazka
::       1 - sukces
::  TAG: <PRIVATE><AKCJA><GRUPA><DEL>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_tab:=cur_tab(1,1);
{? FUN.ask('Zaznaczono: %1 rekordów. Czy usunąć je wszystkie?'@[$_tab.sel_size()])
|| _result:=1;
   sel_nchk();
   KOMM.init(200,,'Usuwanie...'@,'')
?};
_result


\rem_zasu_del_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja usuń grupa po w oknie wertowania tabeli REM_ZASU
::  TAG: <PRIVATE><AKCJA><GRUPA><DEL>
::----------------------------------------------------------------------------------------------------------------------
KOMM.select(,,,,,0);
~~


\rem_zasu_can_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Sprawdza możliwość usunięcia rekordu REM_ZASU
::   WE: [_a] - REM_ZASU.ref, jeśli nie podany to aktualny rekord
::       [_b] - INTEGER - czy wyswietlac komunikaty:  0  - nie
::                                                   [1] - wyskakujący komunikat
::                                                    2  - w KOMM
::   WY: 0 - nie można usunąć rekordu
::       1 - można usuwać
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();

_display:=1;
{? var_pres('_b')=type_of(0)
|| _display:=_b
?};

_result:=0;
_can_continue:=1;

REM_ZASU.cntx_psh();
{? var_pres('_a')=type_of(REM_ZASU.ref())
|| _ref:=_a;
   _can_continue:=0;
   REM_ZASU.clear();
   {? REM_ZASU.seek(_ref)
   || _can_continue:=1
   ?}
?};

{? _can_continue>0
|| {? REM_ZASU.count()=0
   || _result:=1
   ?}
?};
REM_ZASU.cntx_pop();
_result


\rem_zasu_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Kasuje podany rekord tabeli REM_ZASU (wykonywane w transakcji!!!)
::   WE: _a - REM_ZASU.ref()
::   WY: >0 -wyczyszczone,
::       <=0 -niewyczyszczone
::  TAG: <PUBLICZNA><DEL>
::UWAGA: Parametry bez [] są wymagane, formula może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=0;
_can_continue:=1;

:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;
{? _mydo || do() ?};
REM_ZASU.cntx_psh(); REM_ZASU.clear();
{? REM_ZASU.seek(_ref)
|| {? exec('rem_zasu_clean','zasoby',_ref)>0
   || {? REM_ZASU.del(,1)>0
      || _result:=1
      || undo();
         _result:=-3
      ?}
   || _result:=-2
   ?}
|| _result:=0
?};

{? _result<0
|| undo()
?};

REM_ZASU.cntx_pop();
{? _mydo || end() ?};
_result


\rem_zasu_clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Czyści powiązania do rekordu tabeli REM_ZASU
::   WE: _a - REM_ZASU.ref()
::   WY: >0  -wyczyszczone,
::       <=0 -niewyczyszczone
::  TAG: <PRYWATNA><CLEAN>
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=0;
_can_continue:=1;

_mydo:=do_state()=0;
{? _mydo || do() ?};
:: --- powiązania do ---

:: --- wszystkie powiazania usuniete? ---

{? _can_continue>0
|| _result:=1
|| undo()
?};

{? _mydo || end() ?};
_result


\rem_zasu_after_rfr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Po odświeżeniu w oknie REM_ZAS
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
REM_ZASU.index('REM_ZAS');
REM_ZASU.prefix(REM_ZAS.ref());
REM_ZASU.first();

_grayed:=':';

{? REM_ZAS.AKT='N'
|| _grayed:='DPU'+_grayed+'D'
?};

REM_ZASU.actions_grayed('WER',_grayed);
~~


\rem_zasu_trig_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Trigger przed w tabeli REM_ZASU
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
REM_ZASU.TM_START:=exec('create','#tm_stamp',REM_ZASU.OD,time(0,0,0));
REM_ZASU.TM_END:=exec('create','#tm_stamp',REM_ZASU.DO,time(0,0,0));
1


\rem_zasu_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Przed redakcją pól w tabeli REM_ZASU
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:=1;
{? _fld='OSOBA'
|| _result:=exec('chk_role','#b__box',OPERATOR.USER,'ZWS_DOS_PPDO') | exec('chk_role','#b__box',OPERATOR.USER,'ZWS_DOS_PRDO')

?};
_result


\rem_zasu_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Odszukuje osobę która była użytkownikiem podanego zasobu w danym dniu
::   WE: _a - REM_ZAS.ref - zasób
::       _b - DATE - data
::   WY: OSOBA.ref
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_rem_zas:=_a;
_date:=_b;

_result:=null();

REM_ZASU.cntx_psh();

{? _date<>date(0,0,0)
||
:: Sprawdzam czy jest zapis bezterminowy
   REM_ZASU.index('TM_END');
   REM_ZASU.prefix(_rem_zas,0);
   {? REM_ZASU.first() & _date>=REM_ZASU.OD
   || _result:=REM_ZASU.OSOBA
   ?};

   {? _result=null()
   ||
::    Iteruję po kolejnych użytkownikach, których koniec użytkowania wcześniej niż podana data
      _tm_stamp:=exec('create','#tm_stamp',_date,time(0,0,0));
      REM_ZASU.prefix(_rem_zas);
      {? REM_ZASU.find_ge(_tm_stamp)
      || {!
         |?
            {? REM_ZASU.DO<>date(0,0,0)
            ||
               {? var_pres('_int1')>100
               || obj_del(_int1)
               ?};
               _int1:=exec('interval','#interval');
               _int1.START:=REM_ZASU.TM_START;
               _int1.END:=REM_ZASU.TM_END;

               {? var_pres('_int2')>100
               || obj_del(_int2)
               ?};
               _int2:=exec('interval','#interval');
               _int2.START:=_tm_stamp;
               _int2.END:=_int2.START+1;

               {? exec('intervals_chk','#interval',_int1,_int2)>0
               || _result:=REM_ZASU.OSOBA
               ?}
            ?};
            REM_ZASU.next() & _result=null()
         !}
      ?}
   ?}
?};
REM_ZASU.cntx_pop();
_result


\rem_zasu_email
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Zwraca email osoby będącej użytkownikiem podanego zasobu w danym dniu
::   WE: _a - REM_ZAS.ref - zasób
::       _b - DATE - data
::   WY: STRING - adres email
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_rem_zas:=_a;
_date:=_b;

_result:='';

_osoba:=exec('rem_zasu_find','zasoby',_rem_zas,_date);
{? _osoba<>null()
|| USERS.cntx_psh();
   USERS.index('OSOBA');
   USERS.prefix(_osoba);
   {? USERS.first()
   || _result:=USERS.EMAIL
   ?};
   USERS.cntx_pop();

   {? _result=''
   || _result:=exec('email','osoba',_osoba)
   ?}
?};
_result


\rem_gwar_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja Dołącz w tabeli wertowania REM_GWAR
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------

_result:=0;
_can_continue:=1;

REM_GWAR.win_edit('RED');
REM_GWAR.blank();
REM_GWAR.memo_set('','DESC');
REM_GWAR.REM_ZAS:=REM_ZAS.ref();
exec('rem_gwar_efld_opt','zasoby');
REM_ZAS.PRZ_JM();

{? REM_GWAR.edit("exec('rem_gwar_valid','zasoby',0)")
|| _can_continue:=REM_GWAR.add();
   {? _can_continue>0
   || _can_continue:=REM_GWAR.memo_put(,'DESC')
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
_result


\rem_gwar_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja Popraw w tabeli wertowania REM_GWAR
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------

_result:=0;
_can_continue:=1;
{? REM_GWAR.r_lock(1,1,1)
||
   _before:=exec('REM_GWAR','buffer1');
   _before.get();
   exec('rem_gwar_efld_opt','zasoby');
   REM_ZAS.PRZ_JM();
   REM_GWAR.memo_get(,'DESC',0);

   REM_GWAR.win_edit('RED');
   REM_GWAR.cntx_psh();
   {? REM_GWAR.edit("exec('rem_gwar_valid','zasoby',1)")
   || _can_continue:=REM_GWAR.put();
      {? _can_continue>0
      || _can_continue:=REM_GWAR.memo_put(,'DESC')
      ?};
      exec('rem_gwar_sent_reset','zasoby',,_before,2)
   ?};
   REM_GWAR.cntx_pop();
   REM_GWAR.get();
   REM_GWAR.r_unlock()
?};
{? _can_continue>0
|| _result:=1
?};
_result


\rem_gwar_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Walidacja rekordu w tabeli REM_GWAR
::   WE: _a - INTEGER - rodzaj akcji: 0 - dołącz, 1 - popraw
::   WY: STRING
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_action:=_a;

_ref:=null();
{? _action=1
|| _ref:=REM_GWAR.ref()
?};

_rem_zas:=REM_GWAR.REM_ZAS;
_zas_str:=exec('record','#to_string',_rem_zas);

_result:=__CHK.record(REM_GWAR,,'SYMBOL','DUR_MODE');

{? _result=''
|| {? REM_GWAR.DUR_PRZE<0
   || _result:='DUR_PRZE';
      _msg:='Pole: \'%1\' musi mieć wartość większą od zera.'@['Do przebiegu'@];
      FUN.emsg(_msg)
   ?}
?};

{? _result=''
|| {? REM_GWAR.WARN_DAY<0
   || _result:='WARN_DAY';
      _msg:='Pole: \'%1\' musi mieć wartość większą od zera.'@['Ilość dni przed'@];
      FUN.emsg(_msg)
   ?}
?};

{? _result=''
|| {? REM_GWAR.WARN_PRZ<0
   || _result:='WARN_PRZ';
      _msg:='Pole: \'%1\' musi mieć wartość większą od zera.'@['Po przekroczeniu przebiegu'@];
      FUN.emsg(_msg)
   ?}
?};

{? _result=''
|| {? REM_GWAR.DUR_DATE=date(0,0,0) & (REM_GWAR.DUR_MODE='D' | REM_GWAR.DUR_MODE='O')
   || _result:='DUR_DATE';
      _msg:='Pole: \'%1\' musi być wypełnione.'@['Do daty'@];
      FUN.emsg(_msg)
   |? REM_GWAR.DUR_PRZE=0 & (REM_GWAR.DUR_MODE='P' | REM_GWAR.DUR_MODE='O')
   || _result:='DUR_PRZE';
      _msg:='Pole: \'%1\' musi być wypełnione.'@['Do przebiegu'@];
      FUN.emsg(_msg)
   ?}
?};



_result


\rem_gwar_del_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja w oknie - usunięcie rekordu
::   WE: [_a] - INTEGER - 0/[1] - czy wyświetlać dialogi
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};

_result:=0;
_can_continue:=1;

_tab:=REM_GWAR;

_group:=0;
{? _tab.sel_size()>0
|| _group:=1;
   _dialog:=0
?};

:: Sprawdzam czy można usunąć
{? _group>0
|| _can_continue:=exec('rem_gwar_can_del','zasoby',,2)
|| _can_continue:=exec('rem_gwar_can_del','zasoby',,1)
?};

{? _dialog>0 & _can_continue=0
|| FUN.emsg('Nie można usunąć gwarancji: %1. Istnieją powiązania w systemie.'@[exec('REM_GWAR','#to_string')])
?};

{? _dialog>0 & _can_continue>0
|| _can_continue:=FUN.ask('Usunąć gwarancję: %1?'@[exec('REM_GWAR','#to_string')])
?};

{? _can_continue>0
|| _result:=exec('rem_gwar_delete','zasoby',_tab.ref())
?};
_result


\rem_gwar_del_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja usuń grupa przed w oknie wertowania tabeli REM_ZASU
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_tab:=cur_tab(1,1);
{? FUN.ask('Zaznaczono: %1 rekordów. Czy usunąć je wszystkie?'@[$_tab.sel_size()])
|| _result:=1;
   sel_nchk();
   KOMM.init(200,,'Usuwanie...'@,'')
?};
_result


\rem_gwar_del_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja usuń grupa po w oknie wertowania tabeli REM_ZASU
::----------------------------------------------------------------------------------------------------------------------
KOMM.select(,,,,,0);
~~


\rem_gwar_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Kasuje podany rekord tabeli REM_GWAR (wykonywane w transakcji!!!)
::   WE: _a - REM_GWAR.ref()
::   WY: >0 -wyczyszczone,
::       <=0 -niewyczyszczone
::  TAG: <PUBLICZNA><DEL>
::UWAGA: Parametry bez [] są wymagane, formula może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=0;
_can_continue:=1;

:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;
{? _mydo || do() ?};
REM_GWAR.cntx_psh(); REM_GWAR.clear();
{? REM_GWAR.seek(_ref)
|| {? exec('rem_gwar_clean','zasoby',_ref)>0
   || {? REM_GWAR.del(,1)>0
      || _result:=1
      || undo();
         _result:=-3
      ?}
   || _result:=-2
   ?}
|| _result:=0
?};

{? _result<0
|| undo()
?};

REM_GWAR.cntx_pop();
{? _mydo || end() ?};
_result


\rem_gwar_clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Czyści powiązania do rekordu tabeli REM_GWAR
::   WE: _a - REM_GWAR.ref()
::   WY: >0  -wyczyszczone,
::       <=0 -niewyczyszczone
::  TAG: <PRYWATNA><CLEAN>
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=0;
_can_continue:=1;

_mydo:=do_state()=0;
{? _mydo || do() ?};
:: --- powiązania do ---

REM_GWAZ.cntx_psh();
REM_GWAZ.index('REM_GWAR');
REM_GWAZ.prefix(_ref);
{? REM_GWAZ.first()
|| {!
   |? _can_continue:=REM_GWAZ.del(,1);
      REM_GWAZ.first() & _can_continue>0
   !}
?};
REM_GWAZ.cntx_pop();

:: --- wszystkie powiazania usuniete? ---

{? _can_continue>0
|| _result:=1
|| undo()
?};

{? _mydo || end() ?};

_result


\rem_gwar_can_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Sprawdza możliwość usunięcia rekordu REM_GWAR
::   WE: [_a] - REM_ZASU.ref, jeśli nie podany to aktualny rekord
::       [_b] - INTEGER - czy wyswietlac komunikaty:  0  - nie
::                                                   [1] - wyskakujący komunikat
::                                                    2  - w KOMM
::   WY: 0 - nie można usunąć rekordu
::       1 - można usuwać
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();

_display:=1;
{? var_pres('_b')=type_of(0)
|| _display:=_b
?};

_result:=0;
_can_continue:=1;

REM_GWAR.cntx_psh();
{? var_pres('_a')=type_of(REM_GWAR.ref())
|| _ref:=_a;
   _can_continue:=0;
   REM_GWAR.clear();
   {? REM_GWAR.seek(_ref)
   || _can_continue:=1
   ?}
?};

{? _can_continue>0
|| _result:=1
?};
REM_GWAR.cntx_pop();
_result


\rem_gwar_berec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Rekord przed w tabeli REM_GWAR
::   WE: _a - INTEGER - czy ostatni odrysowany rekord
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? REM_GWAR.DUR_MODE='P' | REM_GWAR.DUR_MODE='O'
|| REM_GWAR.REM_ZAS().PRZ_JM()
|| JM.blank()
?};
~~


\rem_gwar_after_rfr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Po odświeżeniu w oknie REM_GWAR
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
REM_GWAR.index('REM_ZAS');
REM_GWAR.prefix(REM_ZAS.ref());
REM_GWAR.first();

_grayed:=':';

{? REM_ZAS.AKT='N'
|| _grayed:='DPURT'+_grayed+'D'
?};

REM_GWAR.actions_grayed('WER',_grayed);
~~


\rem_gwar_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Po redagowaniu w tabeli REM_GWAR
::   WY: ANY
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:=~~;
{? _fld='DUR_MODE'
|| exec('rem_gwar_efld_opt','zasoby')
?};
~~


\rem_gwar_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Format wyświetlania dla tabeli REM_GWAR
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:='';
{? _fld='DUR_DATE'
|| {? REM_GWAR.DUR_MODE='D' | REM_GWAR.DUR_MODE='O'
   || _result:='empty=0'
   || _result:='empty=1'
   ?}
|? _fld='DUR_PRZE'
|| _result:='out_prec=%1,'[$REM_GWAR.REM_ZAS().PRZ_DOKL];
   {? REM_GWAR.DUR_MODE='P' | REM_GWAR.DUR_MODE='O'
   || _result+='empty=0'
   || _result+='empty=1'
   ?}
?};
_result


\rem_gwar_efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Metoda opcji dla pól w tabeli REM_GWAR
::   WE: [_a] - STRING - akronim okienka
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_win:='RED';
{? var_pres('_a')=type_of('')
|| _win:=_a
?};

{? REM_GWAR.DUR_MODE='D'
|| REM_GWAR.efld_opt(_win,'mark=1',,'DUR_DATE');
   REM_GWAR.efld_opt(_win,'enable=1',,'DUR_DATE');
   REM_GWAR.efld_opt(_win,'enable=1',,'WARN_DAY');
   REM_GWAR.efld_opt(_win,'mark=0',,'DUR_PRZE');
   REM_GWAR.efld_opt(_win,'enable=0',,'DUR_PRZE');
   REM_GWAR.efld_opt(_win,'enable=0',JM,'KOD');
   REM_GWAR.efld_opt(_win,'enable=0',,'WARN_PRZ')
|? REM_GWAR.DUR_MODE='P'
|| REM_GWAR.efld_opt(_win,'mark=0',,'DUR_DATE');
   REM_GWAR.efld_opt(_win,'enable=0',,'DUR_DATE');
   REM_GWAR.efld_opt(_win,'enable=0',,'WARN_DAY');
   REM_GWAR.efld_opt(_win,'mark=1',,'DUR_PRZE');
   REM_GWAR.efld_opt(_win,'enable=1',,'DUR_PRZE');
   REM_GWAR.efld_opt(_win,'enable=1',,'WARN_PRZ');
   REM_GWAR.efld_opt(_win,'enable=1',JM,'KOD')
|? REM_GWAR.DUR_MODE='O'
|| REM_GWAR.efld_opt(_win,'mark=1',,'DUR_DATE');
   REM_GWAR.efld_opt(_win,'enable=1',,'DUR_DATE');
   REM_GWAR.efld_opt(_win,'mark=1',,'DUR_PRZE');
   REM_GWAR.efld_opt(_win,'enable=1',,'DUR_PRZE');
   REM_GWAR.efld_opt(_win,'enable=1',JM,'KOD');
   REM_GWAR.efld_opt(_win,'enable=1',,'WARN_PRZ');
   REM_GWAR.efld_opt(_win,'enable=1',,'WARN_DAY')
|| REM_GWAR.efld_opt(_win,'mark=0',,'DUR_DATE');
   REM_GWAR.efld_opt(_win,'enable=0',,'DUR_DATE');
   REM_GWAR.efld_opt(_win,'mark=0',,'DUR_PRZE');
   REM_GWAR.efld_opt(_win,'enable=0',,'DUR_PRZE');
   REM_GWAR.efld_opt(_win,'enable=0',JM,'KOD');
   REM_GWAR.efld_opt(_win,'enable=0',,'WARN_PRZ');
   REM_GWAR.efld_opt(_win,'enable=0',,'WARN_DAY')
?};
~~


\rem_gwar_zal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja Załączniki dla REM_GWAR
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_edit:=1;
{? REM_GWAR.REM_ZAS().AKT='N'
|| _edit:=0
?};

{? REM_GWAR.r_lock(1,1,1)
|| REM_GWAZ.index('REM_GWAR');
   REM_GWAZ.prefix(REM_GWAR.ref());

   _tab_tmp:=tab_tmp(1
      ,'NAME','STRING[255]','Nazwa pliku'@
      ,'SIZE','REAL','Rozmiar'@
      ,'MOD_DATE','STRING[16]','Data modyfikacji'@
      ,'ADD_DATE','STRING[19]','Data dodania'@
      ,'INT_DATA','INTEGER','Identyfikator pliku'@
      ,'STR_DATA','STRING[48]','Identyfikator pliku'@
      ,'NAZWA','STRING[50]','Opis'@
   );
   _fml_load:="
      _tab_ctrl:=_a;
      _tab:=_b;
      _tab_ctrl.blank();
      _blob_ref:=($('_tab:=_a;_tab.'+.FIELD))(_tab);
      {? _blob_ref<>null()
      || _tab_ctrl.NAME:=_tab.bl_info(.FIELD,'NAME');
         _tab_ctrl.SIZE:=_tab.bl_info(.FIELD,'SIZE');
         _tab_ctrl.MOD_DATE:=$_tab.bl_info(.FIELD,'MODIFY_DATE')+' '+$_tab.bl_info(.FIELD,'MODIFY_TIME')
      || _tab_ctrl.NAME:='brak pliku'
      ?};
      _tab_ctrl.ADD_DATE:=19+_tab.IDADD;
      _tab_ctrl.STR_DATA:=_tab.uidref();
      _tab_ctrl.NAZWA:=_tab.NAZWA;
      _tab_ctrl.add()
   ";
   _fml_edit:="
      params_set(params_get());
      _env:=params_get().env_blob;
      _args:=_a;
      _buffer:=_b;
      _action:=_c;
      _uid:=_d;
      _can_continue:=1;
      _result:=0;
      REM_GWAZ.cntx_psh();
      REM_GWAZ.clear();
      _locked:=0;
      {? _action='Dołącz'
      || REM_GWAZ.blank();
         REM_GWAZ.REM_GWAR:=_args.REM_GWAR
      |? _action='Popraw'
      || _can_continue:=REM_GWAZ.seek(_uid,ref_name(_uid),1);
         {? _can_continue>0
         || _can_continue:=exec('blk_lock','#table','REM_ZASA',REM_GWAZ.ref(),,1,
               'Załącznik: %1 jest redagowany.'@[REM_GWAZ.bl_info('ATA','NAME')]);
            {? _can_continue>0
            || _locked:=1
            ?}
         || FUN.emsg('Załącznik został usunięty.'@)
         ?}
      ?};
      {? _can_continue>0
      ||
         _valid:=\"__CHK.record(REM_GWAZ,,'ATA')\";
         _red:=REM_GWAZ.mk_edit(FUN.TYT,,'readattach',,,'normal');
         REM_GWAZ.win_efld(_red,,'ATA',,,47,,,'Nazwa pliku'@,,,,'F3_button=1');
         REM_GWAZ.win_efld(_red,,'NAZWA',,,50,,,'Opis'@);
         REM_GWAZ.efld_opt(_red,'mark=1',,'ATA');
         exec('ok_esc','#window',REM_GWAZ,_red);
         REM_GWAZ.win_edit(_red);
         REM_GWAZ.bl_file('ATA',1);
         {? REM_GWAZ.edit(_valid)
         ||
            {? _action='Dołącz'
            || _can_continue:=REM_GWAZ.add()
            |? _action='Popraw'
            || _can_continue:=REM_GWAZ.put()
            ?};

            {? _can_continue>0
            || {? (_file:=REM_GWAZ.bl_file('ATA'))<>''
               || _can_continue:=REM_GWAZ.bl_put('ATA',_file)
               || _can_continue:=0
               ?}
            ?}
         ?}
      ?};
      {? _locked>0
      || exec('blk_unlock','#table','REM_GWAZ',REM_GWAZ.ref())
      ?};
      REM_GWAZ.cntx_pop();
      _env.SELECT_STR:=_uid;
      _buffer.REM_GWAR:=_args.REM_GWAR;
::    Wynik 0 żeby nie wykonywać standardowej obsługi
      0
   ";
   _fml_file:="";
   _fml_valid:="
      _filename:=_c;
      _dialog:=_e;
      _result:=1;
      _env:=params_get().env_blob;
      {? _env.has_file(_filename)>0
      || _result:=0;
         _msg:='Plik o nazwie: %1 jest już dodany jako załącznik i nie może zostać dodany ponownie.'@[_filename];
         {? _dialog=0
         || FUN.emsg(_msg)
         || KOMM.add(_msg,2,,1)
         ?}
      ?};
      _result
   ";
   _args:=obj_new('REM_GWAR');
   _args.REM_GWAR:=REM_GWAR.ref();
   exec('edit_blob','#edit',REM_GWAZ
      ,'ATA'
      ,exec('REM_GWAZ','buffer1')
      ,_fml_edit
      ,_fml_file
      ,_args
      ,_edit
      ,'Załączniki'@+{? _edit || '' || ' — '+'PODGLĄD'@ ?}
      ,'icons'
      ,_tab_tmp
      ,_fml_load
      ,_fml_valid
   );

   REM_GWAR.r_unlock()
|| FUN.emsg('Redagowanie listy załączników nie jest możliwe.\nRekord jest redagowany lub przetwarzany.'@)
?};
~~


\rem_gwar_legenda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja Legenda w oknie wertowania tabeli REM_GWAR
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','REM_GWAR#01');
~~


\rem_gwar_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja Wyświetl w oknie tabeli REM_GWAR
::   WE: [_a] - REM_GWAR.ref lub bieżący rekord
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_GWAR.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

REM_GWAR.cntx_psh();
{? _ref<>null()
|| REM_GWAR.prefix();
   {? REM_GWAR.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
REM_ZAS.PRZ_JM();
{? _can_continue>0
||
   REM_GWAR.win_edit('RED');
   exec('rem_gwar_efld_opt','zasoby');
   REM_GWAR.memo_get(,'DESC',0);
   REM_GWAR.display();
   ~~


?};
REM_GWAR.cntx_pop();
~~


\rem_gwar_extend
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja Przedłuż w oknie wertowania tabeli REM_GWAR
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_can_continue:=1;

{? REM_GWAR.r_lock(1,1,1)
||
   _before:=exec('REM_GWAR','buffer1');
   _before.get();
   exec('rem_gwar_efld_opt','zasoby','EXTEND');
   REM_ZAS.PRZ_JM();
   REM_GWAR.memo_get(,'DESC',0);

   REM_GWAR.win_edit('EXTEND');
   {? REM_GWAR.edit("exec('rem_gwar_valid','zasoby',1)")
   || _can_continue:=REM_GWAR.put();
      {? _can_continue>0
      || _can_continue:=REM_GWAR.memo_put(,'DESC')
      ?};
      exec('rem_gwar_sent_reset','zasoby',,_before,2)
   ?};
   REM_GWAR.get();
   REM_GWAR.r_unlock()
?};
{? _can_continue>0
|| _result:=1
?};
_result


\rem_gwar_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Sprawdza czy należy wysłać powiadomienie o upłyniętym lub upływającym terminie
::       gwarancji
::   WE: [_a] - REM_GWAR.ref lub bieżący rekord
::       [_b] - DATE - data na którą sprawdzać (domyślnie bieżąca)
::   WY: 0 - brak problemu z gwarancją
::       1 - gwarancja za niedługo upłynie
::       2 - gwarancja już upłynęła
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZAS.ref())
|| _ref:=_a
?};

_date:=date();
{? var_pres('_b')=type_of(date())
|| _date:=_b
?};

_ref:=null();
{? var_pres('_a')=type_of(REM_GWAR.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

REM_ZAS.cntx_psh();
REM_GWAR.cntx_psh();
{? _ref<>null()
|| REM_GWAR.prefix();
   {? REM_GWAR.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| REM_GWAR.REM_ZAS();
   {? REM_GWAR.DUR_MODE='D' | REM_GWAR.DUR_MODE='O'
   || {? REM_GWAR.DUR_DATE<_date
      || _result:=2
      |? REM_GWAR.DUR_DATE=_date
      || _result:=1
      ?}
   ?};
   {? _result=0 & (REM_GWAR.DUR_MODE='P' | REM_GWAR.DUR_MODE='O')
   || {? REM_ZAS.PRZ>REM_GWAR.DUR_PRZE
      || _result:=2
      |? REM_ZAS.PRZ=REM_GWAR.DUR_PRZE
      || _result:=1
      ?}
   ?};

   {? _result=0 & REM_GWAR.WARN_DAY>0 & (REM_GWAR.DUR_MODE='D' | REM_GWAR.DUR_MODE='O')
   || _data:=date()+REM_GWAR.WARN_DAY;
      {? _data>=REM_GWAR.DUR_DATE
      || _result:=1
      ?}
   ?};

   {? _result=0 & REM_GWAR.WARN_PRZ>0 & (REM_GWAR.DUR_MODE='P' | REM_GWAR.DUR_MODE='O')
   || _przebieg:=REM_ZAS.PRZ+REM_GWAR.WARN_PRZ;
      {? _przebieg>=REM_GWAR.DUR_PRZE
      || _result:=1
      ?}
   ?}
?};
REM_GWAR.cntx_pop();
REM_ZAS.cntx_pop();
_result


\rem_zas_gwar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Uaktualnia status zasobu - czy jest na gwarancji
::   WE: _a - REM_ZAS.ref - zasób
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZAS.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

REM_ZAS.cntx_psh();
{? _ref<>null()
|| REM_ZAS.prefix();
   {? REM_ZAS.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

:: Najpierw resetujemy status gwarancyjności
{? _can_continue>0
|| REM_ZAS.GWAR:='N';
   _can_continue:=REM_ZAS.put();
   {? _can_continue>0
   || _result:=1
   ?}
?};

{? _can_continue>0
|| {? exec('zasob_na_gwarancji','zasoby')>0
   || REM_ZAS.GWAR:='T';
      _result:=REM_ZAS.put()
   ?};
   ~~
?};
REM_ZAS.cntx_pop();
_result


\rem_gwar_trig_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Trigger po add, put, del w tabeli REM_GWAR
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? REM_GWAR.REM_ZAS<>null
|| REM_ZAS.cntx_psh();
   REM_GWAR.REM_ZAS();
   exec('rem_zas_gwar','zasoby');
   REM_ZAS.cntx_pop();
   REM_ZAS.get()
?};
~~


\rem_gwar_sent_reset
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Resetuje status wysyłki powiadomienia
::   WE: [_a] - REM_GWAR.ref lub bieżący rekord
::       [_b] - obj_new - bufor rekordu REM_GWAR
::       [_c] - INTEGER - czy wyświetlać dialogi
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_GWAR.ref())
|| _ref:=_a
?};

_buffer:=~~;
{? var_pres('_b')>100
|| _buffer:=_b
?};

_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};

_result:=0;
_can_continue:=1;

REM_GWAR.cntx_psh();
{? _ref<>null()
|| REM_GWAR.prefix();
   {? REM_GWAR.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? REM_GWAR.SENT_BEF='T' | REM_GWAR.SENT_BEF='' |
      REM_GWAR.SENT_AFT='T' | REM_GWAR.SENT_AFT=''
   ||
      _can_reset:=1;
      _msg:='Zresetować status wysyłki powiadomień o upłynięciu gwarancji?';
      {? type_of(_buffer)>100
      || _can_reset:=0;
         {? _buffer.DUR_MODE<>REM_GWAR.DUR_MODE |
            _buffer.DUR_DATE<>REM_GWAR.DUR_DATE |
            _buffer.DUR_PRZE<>REM_GWAR.DUR_PRZE |
            _buffer.WARN_DAY<>REM_GWAR.WARN_DAY |
            _buffer.WARN_PRZ<>REM_GWAR.WARN_PRZ
         || _can_reset:=1;

            _msg:='Zmieniły się warunki gwarancji, lub właściwości dot. powiadomień.\n'
                  'Zresetować status wysyłki powiadomień o upłynięciu gwarancji?'
         ?}
      ?};

      {? _can_reset>0 & _dialog>0
      || _can_continue:=FUN.ask(_msg)
      ?};

      {? _can_reset>0 & _can_continue>0
      || REM_GWAR.SENT_BEF:='N';
         REM_GWAR.SENT_AFT:='N';
         _can_continue:=REM_GWAR.put()
      ?}
   || {? _dialog>0 & _dialog<>2
      || FUN.emsg('Status wysyłki nie wymaga resetowania.'@)
      ?}
   ?}
?};
REM_GWAR.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\zasob_na_gwarancji
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Sprawdza czy zasób ma jeszcze jakąś ważną gwarancję
::   WE: [_a] - REM_ZAS.ref
::   WY: 0 - brak ważnej gwarancji
::       1- jest gwarancja
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZAS.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

REM_ZAS.cntx_psh();
{? _ref<>null()
|| REM_ZAS.prefix();
   {? REM_ZAS.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| REM_GWAR.cntx_psh();
   REM_GWAR.index('REM_ZAS');
   REM_GWAR.prefix(REM_ZAS.ref());
   {? REM_GWAR.first()
   || {!
      |? _chk:=exec('rem_gwar_chk','zasoby');
         {? _chk=0 | _chk=1
         || _result:=1
         ?};
         REM_GWAR.next() & _result=0
      !}
   ?};
   REM_GWAR.cntx_pop()
?};
REM_ZAS.cntx_pop();
_result


\rem_zas_set_active
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Aktywuje lub dezaktywuje dany zasób
::   WE: [_a] - REM_ZAS.ref lub aktualny rekord
::       [_b] - STRING - [T]/N - aktywować czy dezaktywować
::       [_c] - INTEGER - 0/[1] - czy wyświetlać dialogi
::       [_d] - INTEGER - 0/[1] - czy aktualizować drzewo w dół
::       [_e] - ref_table - tablica odwiedzonych rekordów
::       [_f] - INTEGER - [0]/1 - czy wywołanie rekurencyjne
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
|? var_pres('_a')=type_of(0)
|| _ref:=exec('FindAndGet','#table',REM_ZAS,_a,REM_ZAS.name(),,null())
?};
_active:='T';
{? var_pres('_b')=type_of('')
|| _active:=_b
?};
_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};

_down_update:=0;
{? var_pres('_d')=type_of(0)
|| _down_update:=_d
?};

_visited:=~~;
{? var_pres('_e')>100
|| _visited:=_e
|| _visited:=exec('ref_table','#table')
?};

_rec:=0;
{? var_pres('_f')=type_of(0)
|| _rec:=_f
?};

_result:=0;
_can_continue:=1;

REM_ZAS.cntx_psh();
REM_ZAS.clear();
{? _ref<>null()
|| {? REM_ZAS.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? _visited.r_find(REM_ZAS.ref())=0
   || _visited.add(REM_ZAS.ref());

      _can_mod:=1;
      _what:=exec('REM_ZAS','#to_string');
      _tab:=cur_tab(1,1);
      _group:=0;
      {? _tab.sel_size()>0
      || _group:=1;
         _dialog:=0
      ?};

      _tree_up:=exec('rem_zas_tree_chk','zasoby',,_active,1);
      _tree_down:=exec('rem_zas_tree_chk','zasoby',,_active,-1);

      {? _dialog>0
      ||
         _opt_down:='';
         {? _tree_down=0
         || _opt_down:= 'text=%1;selected=%2'['Nanosić zmiany w dół drzewa'@,'N']
         ?};

         {? _active='T'
         ||
            _msg:='Czy aktywować zasób: %1?'@[_what];
            {? _tree_up=0 | _tree_down=0
            ||
               {? _tree_up=0
               || _msg+='\nAktywacja zasobu spowoduje również aktywację zasobów nadrzędnych.'@
               ?};

               {? _opt_down<>''
               || _choice:=FUN.multichoice(_msg,,,80,6,_opt_down);

                  {? _choice[1]=''
                  || _can_mod:=0
                  ?};
                  {? _can_mod>0
                  || {? _choice[2]<>''
                     || _down_update:=1
                     ?}
                  ?}
               || _can_mod:=FUN.ask(_msg)
               ?}
            || _can_mod:=FUN.ask(_msg)
            ?}
         |? _active='N'
         ||
            _msg:='Czy dezaktywować zasób: %1?'@[_what];
            {? _tree_down=0
            || _down_update:=1;
               _msg+='\nDezaktywacja zasobu spowoduje również dezaktywację zasobów podrzędnych.'@
            ?};
            _can_mod:=FUN.ask(_msg)
         ?}
      ?};

      {? _can_mod>0 & _active='T'
      ||
         {? REM_ZAS.AKT='T'
         || _can_mod:=0;
            _msg:='Zasób: %1 jest już aktywny.'@[_what];
            {? _dialog>0
            || FUN.info(_msg)
            |? _group>0 & _rec=0
            || KOMM.add(_msg,7)
            ?}
         ?}
      |? _can_mod>0 & _active='N'
      ||
         {? REM_ZAS.AKT='N'
         || _can_mod:=0;
            _msg:='Zasób: %1 jest już nieaktywny.'@[_what];
            {? _dialog>0
            || FUN.info(_msg)
            |? _group>0 & _rec=0
            || KOMM.add(_msg,7)
            ?}
         ?}
      ?};
      {? _can_mod>0
      || REM_ZAS.AKT:=_active;
         _can_continue:=REM_ZAS.put();

         {? _can_continue=0
         || _msg:='Zmiana aktywności zasobu: %1 zakończona niepowodzeniem'@[_what];
            {? _dialog>0
            || FUN.info(_msg)
            |? _group>0
            || KOMM.add(_msg,2)
            ?}
         ?}
      ?};
      {? _can_mod>0 & _active='T' & _can_continue>0 & REM_ZAS.TREE<>null()
      ||
::       Zawsze aktywujemy w górę
         _can_continue:=exec('rem_zas_set_active','zasoby',REM_ZAS.TREE,_active,0,0,_visited,1)
      ?};

      {? _can_mod>0 & _can_continue>0 & _down_update>0
      ||
         REM_ZAS.cntx_psh();
         REM_ZAS.index('TREE');
         REM_ZAS.prefix(REM_ZAS.ref());
         {? REM_ZAS.first()
         || {!
            |?
::             !!! REKURENCJA !!!
               exec('rem_zas_set_active','zasoby',,_active,0,_down_update,_visited,1);
               REM_ZAS.next()
            !}
         ?};
         REM_ZAS.cntx_pop()
      ?}
   ?}
?};
REM_ZAS.cntx_pop();


REM_ZAS.get();
{? _can_continue>0
|| _result:=1
?};
_result


\rem_zas_tree_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Sprawdza koherentność pola AKT w drzewie dla podanego zasobu
::   WE: [_a] - REM_ZAS.ref lub bieżący rekord
::       [_b] - STRING - wartość pola AKT
::       [_c] - INTEGER - -1/[1] - kierunek analizy: -1 w doł, 1 w górę
::   WY: 0 - występują rozbieżności
::       1 - wszystkie rekordy w badanej strukturze mają oczekiwaną wartość pola AKT
::       2 - brak struktury drzewa w badanym kierunku
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZAS.ref())
|| _ref:=_a
?};

_akt:=~~;
{? var_pres('_b')=type_of('')
|| _akt:=_b
?};

_dir:=1;
{? var_pres('_c')=type_of(0)
|| _dir:=_c
?};

_result:=0;
_can_continue:=1;

REM_ZAS.cntx_psh();
{? _ref<>null()
|| REM_ZAS.prefix();
   {? REM_ZAS.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? type_of(_akt)=0
   || _akt:=REM_ZAS.AKT
   ?};
   {? _dir>0
   ||
      {? REM_ZAS.TREE<>null()
      ||
         REM_ZAS.cntx_psh();
         REM_ZAS.prefix();
         {? REM_ZAS.seek(REM_ZAS.TREE)
         || {? REM_ZAS.AKT<>_akt
            || _can_continue:=0
            ?};

            {? _can_continue>0
            ||
::             !!! REKURENCJA !!!
               _can_continue:=exec('rem_zas_tree_chk','zasoby',,_akt,_dir)
            ?}
         ?};
         REM_ZAS.cntx_pop()
      || _can_continue:=-1
      ?}
   ?};
   {? _dir<0
   || REM_ZAS.cntx_psh();
      REM_ZAS.index('TREE');
      REM_ZAS.prefix(REM_ZAS.ref());
      {? REM_ZAS.first()
      || {!
         |? {? REM_ZAS.AKT<>_akt
            || _can_continue:=0
            ?};

            {? _can_continue>0
            ||
::             !!! REKURENCJA !!!
               _can_continue:=exec('rem_zas_tree_chk','zasoby',,_akt,_dir)
            ?};
            REM_ZAS.next() & _can_continue>0
         !}
      || _can_continue:=-1
      ?};
      REM_ZAS.cntx_pop()
   ?}
?};
REM_ZAS.cntx_pop();
{? _can_continue>0
|| _result:=1
|? _can_continue=-1
|| _result:=2
?};
_result


\rem_zas_activate_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja 'Aktywuj' w oknie wertowania zasobów
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
exec('rem_zas_set_active','zasoby',,'T')


\rem_zas_activate_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja grupa przed 'Aktywuj' w oknie wertowania zasobów
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_tab:=cur_tab(1,1);
{? FUN.ask('Zaznaczonych zasobów: %1. Czy aktywować je wszystkie?'@[$_tab.sel_size()])
|| _result:=1;
   sel_nchk();
   KOMM.init(200,,'Aktywowanie zasobów')
?};
_result


\rem_zas_activate_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja grupa po 'Aktywuj' w oknie wertowania zasobów
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
KOMM.select()


\rem_zas_deactivate_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja 'Dezaktywuj' w oknie wertowania zasobów
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
exec('rem_zas_set_active','zasoby',,'N')


\rem_zas_deactivate_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja grupa przed 'Dezaktywuj' w oknie wertowania zasobów
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_tab:=cur_tab(1,1);
{? FUN.ask('Zaznaczonych zasobów: %1. Czy dezaktywować je wszystkie?'@[$_tab.sel_size()])
|| _result:=1;
   sel_nchk();
   KOMM.init(200,,'Dezaktywacja zasobów')
?};
_result


\rem_zas_deactivate_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja grupa po 'Dezaktywuj' w oknie wertowania zasobów
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
KOMM.select()


\rem_zas_zakres_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja 'Zakres' w oknie wertowania zasobów
::   WE: [_a] - INTEGER - czy wyświetlać dialogi
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env_zasoby;
params_set(params_get());

_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};

{? _dialog>0
|| _interface:=exec('interface','#params','U','N',6770,OPERATOR.USER().KOD);
   exec('p6770','params',_interface)
?};

_param1:=exec('get','#params',6770,type_of(''),OPERATOR.USER);

_param2:=exec('get','#params',6772,type_of(''),OPERATOR.USER);

_param3:=exec('get','#params',700701,type_of(''));

{? _param2='P' | _param3='N'
||
:: Indeksowanie, prefiksowanie zakresu dostępne tylko jeżeli widok z filtrami (płaski)
   {? _param1='A'
   || REM_ZAS.index('SYM');
      REM_ZAS.prefix()
   |? _param1='T'
   || REM_ZAS.index('AKT');
      REM_ZAS.prefix('T')
   |? _param1='N'
   || REM_ZAS.index('AKT');
      REM_ZAS.prefix('N')
   ?}
|? _param2='D'
||
   REM_ZAS.index('TREE')
?};
~~


\rem_zas_view_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Akcja 'Widok' w oknie zasobów remontowych (umieszczonym w oknie obszaru roboczego ZWS_ZAS)
::   WE: [_a] - INTEGER - czy wyświetlać dialogi
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env_zasoby;
params_set(params_get());

_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};

{? _dialog>0
|| _interface:=exec('interface','#params','U','N',6772,OPERATOR.USER().KOD);
   exec('p6772','params',_interface)
?};

_param1:=exec('get','#params',6772,type_of(''),OPERATOR.USER);

_param2:=exec('get','#params',700701,type_of(''));
_env.REM_ZAS_VIEW:=0;

{? _param1='D' & _param2='T'
|| _env.REM_ZAS_VIEW:=1
?};

{? _dialog>0
|| tab_sel({? _env.REM_ZAS_VIEW || 4 || 3 ?},'panel0');
   tab_hide({? _env.REM_ZAS_VIEW || 3 || 4 ?},1,'panel0')
?};
~~


\rem_zas_record_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Akcja rekord przed w tabeli REM_ZAS
::   WE: _a - INTEGER - systemowy parametr czy ostatnie odrysowanie
::   WY: STRING
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_result:='';

VAR.STRING:=exec('parent_symbol','!zws_tre_dzas',REM_ZAS.ref());
{? REM_ZAS.DK_C<>null() & ref_name(REM_ZAS.DK_C)<>DK_C.name()
|| DK_C.use(ref_name(REM_ZAS.DK_C))
?};

::Aktualizacja statusu gwarancji
exec('rem_zas_gwar','zasoby');

:: Wyszarzanie akcji
{? _a=1
|| exec('rem_zas_action_grayed','zasoby')
?};

:: Kolorowanie
{? REM_ZAS.AKT='N'
|| _result:=Color.fnd_kol('REM_ZAS#01#02')
|? REM_ZAS.S_END='T' | REM_ZAS.S_VER_P='T'
|| _result:=Color.fnd_kol('REM_ZAS#01#01')
?};
_result


\rem_zas_action_grayed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Wyszarzator akcji w REM_ZAS
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_grayed:=':';

{? REM_ZAS.sel_size()=0
||
   {? REM_ZAS.AKT='T'
   || _grayed:='A'+_grayed
   || _grayed:='F(EG)T'+_grayed
   ?}
?};

REM_ZAS.actions_grayed(cur_win(1,1),_grayed);
~~


\rem_zas_status
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Wypełnia pola statusów zasobu remontowego
::   WE: [_a] - Ref rekordu tabeli REM_ZAS
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_press('_a')=7 || _a || null() ?};
{? _ref<>null
||
   REM_ZGL.cntx_psh();
   REM_ZAS.cntx_psh();
   {? REM_ZAS.seek(_ref)
   || REM_ZGL.index('STATUS');
      REM_ZGL.prefix(_ref,exec('status_closed','remonty_zgloszenia'));
      {? REM_ZGL.first()
      || REM_ZAS.S_CLO:='T'
      || REM_ZAS.S_CLO:='N'
      ?};
      REM_ZGL.prefix(_ref,exec('status_completed','remonty_zgloszenia'));
      {? REM_ZGL.first()
      || REM_ZAS.S_COM:='T'
      || REM_ZAS.S_COM:='N'
      ?};
      REM_ZGL.prefix(_ref,exec('status_ended','remonty_zgloszenia'));
      {? REM_ZGL.first()
      || REM_ZAS.S_END:='T'
      || REM_ZAS.S_END:='N'
      ?};
      REM_ZGL.prefix(_ref,exec('status_new','remonty_zgloszenia'));
      {? REM_ZGL.first()
      || REM_ZAS.S_NEW:='T'
      || REM_ZAS.S_NEW:='N'
      ?};
      REM_ZGL.prefix(_ref,exec('status_verified','remonty_zgloszenia'),'T');
      {? REM_ZGL.first()
      || REM_ZAS.S_VER_P:='T'
      || REM_ZAS.S_VER_P:='N'
      ?};
      REM_ZGL.prefix(_ref,exec('status_verified','remonty_zgloszenia'),'N');
      {? REM_ZGL.first()
      || REM_ZAS.S_VER_O:='T'
      || REM_ZAS.S_VER_O:='N'
      ?};
      REM_ZAS.put(1)
   ?};
   REM_ZAS.cntx_pop();
   REM_ZGL.cntx_pop()
?};
~~


\rem_zas_win_dict
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Ustawia okno słownika tabeli REM_ZAS
::----------------------------------------------------------------------------------------------------------------------
REM_ZAS.win_dict('WER_SLO');
REM_ZAS.actions('WER_SLO','FATE:FE');
~~


\rem_zasp_after_rfr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Po odświeżeniu w oknie REM_ZASP (przebiegi)
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
REM_ZASP.index('ZASDT');
REM_ZASP.prefix(REM_ZAS.ref());
REM_ZASP.first();

_grayed:=':';

{? REM_ZAS.AKT='N'
|| _grayed:='DPU'+_grayed+'D'
?};

REM_ZASP.actions_grayed('WER',_grayed);
~~


\rem_zasa_env
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Zwraca środowisko do obsługi załączników w tabeli REM_ZASA
::   WY: obj_new
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_env_blob:=exec('env_blob','#edit');
_env_blob.TAB:=REM_ZASA;
_env_blob.FIELD:='ATA';
_env_blob.EDITABLE:=1;

:: Wyłączanie wszystkich akcji, również podglądu
::_env_blob.EDITABLE:=-1;

:: Wyłączanie poszczególnych akcji
::_env_blob.ACTIONS.DOŁĄCZ:=0;
::_env_blob.ACTIONS.DOŁĄCZ:=0;
::_env_blob.ACTIONS.POPRAW:=0;
::_env_blob.ACTIONS.USUŃ:=0;
::_env_blob.ACTIONS.REDAGUJ:=0;
::_env_blob.ACTIONS.OTWÓRZ:=0;
::_env_blob.ACTIONS.ZAPISZ:=0;
::_env_blob.ACTIONS.WIDOK:=0;

:: Obsługa własnych akcji
::_env_blob.FML_ACTIONS_INI:="
::   params_set(params_get());
::   _env:=params_get().env_blob;
::
::   ctr_set(,_env.ctr_id,'addAction','lemon','Cytryny'@,'','Akcja cytrynowa (grupowa)'@,2,0);
::   ctr_set(,_env.ctr_id,'addAction','orange','Po&marańcze'@,'','Akcja pomarańczowa (pojedyńcza)'@,1,0)
::";
::_env_blob.FML_ACTIONS_RUN:="
::   _action_id:=_a;
::   _selected:=_b;
::
::   _tab:=.TAB;
::   _tab.cntx_psh();
::   {? _action_id='lemon'
::   || {? _selected.first()
::      || {!
::         |? _uidref:=_selected.STR_DATA;
::            {? _tab.seek(_uidref,ref_name(_uidref),1)
::            || FUN.info('Akcja cytrynowa dla: %1'@[_tab.bl_info('ATA','NAME')])
::            ?};
::            _selected.next()
::         !}
::      ?}
::   |? _action_id='orange'
::   || {? _selected.first()
::      || _uidref:=_selected.STR_DATA;
::         {? _tab.seek(_uidref,ref_name(_uidref),1)
::         || FUN.info('Akcja pomarańczowa dla: %1'@[_tab.bl_info('ATA','NAME')])
::         ?}
::      ?}
::   ?};
::   _tab.cntx_pop();
::   ~~
::";

_env_blob.BUFFER:=exec('REM_ZASA','buffer1');
_env_blob.FML_EDIT:="params_exec('rem_zasa_edit','zasoby',_a,_b,_c,_d,_e)";
_env_blob.FML_FILE:="";
_env_blob.FML_ARGS:=obj_new('REM_ZAS');
_env_blob.FML_VALID:=exec('rem_zasa_valid','zasoby');
obj_del(_env_blob.TAB_CTRL);
_env_blob.TAB_CTRL:=tab_tmp(1,
:: 'POLE','TYP','Nazwa w oknie',
   'NAME','STRING[255]','Nazwa pliku',
   'SIZE','REAL','Rozmiar',
   'MOD_DATE','STRING[16]','Data modyfikacji',
   'INT_DATA','INTEGER','Identyfikator pliku',
   'STR_DATA','STRING[48]','Identyfikator pliku',
   'OPIS','STRING[100]','Opis'
);
_env_blob.FML_LOAD:="
   _tab_ctrl:=_a;
   _tab:=_b;

   _tab_ctrl.blank();
   _blob_ref:=($('_tab:=_a;_tab.'+.FIELD))(_tab);
   {? _blob_ref<>null()
   ||
      _tab_ctrl.NAME:=_tab.bl_info(.FIELD,'NAME');
      _tab_ctrl.SIZE:=_tab.bl_info(.FIELD,'SIZE');
      _tab_ctrl.MOD_DATE:=$_tab.bl_info(.FIELD,'MODIFY_DATE')+' '+$_tab.bl_info(.FIELD,'MODIFY_TIME')
   || _tab_ctrl.NAME:='brak pliku'
   ?};
   _tab_ctrl.STR_DATA:=_tab.uidref();
   _tab_ctrl.OPIS:=_tab.NAZWA;

   REM_ZAS.cntx_psh();
   .BLOB_TITLE:='Załączniki zasobu: %1'@[_tab.REM_ZAS().SYMBOL];
   REM_ZAS.cntx_pop();

   _tab_ctrl.add()
";
_env_blob.mk_ctr();
_env_blob


\rem_zasa_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Formuła na edycję załączników w tabeli REM_ZASA dla kontrolki
::   WY: FORMULA
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env_blob;
_args:=_a;
_buffer:=_b;
_action:=_c;
_uidref:=_d;
_dnd:=_e;

_can_continue:=1;
_result:=0;
_dndsize:={? type_of(_dnd)>0 & _dnd.first() || _dnd.size() || 0 ?};

REM_ZASA.cntx_psh();
REM_ZASA.prefix();

{? _action='Popraw'
||
   _can_continue:=(REM_ZASA.seek(_uidref,ref_name(_uidref),1));
   {? _can_continue=0
   || FUN.emsg('Załącznik został usunięty.'@)
   ?};
   {? _can_continue>0
   || _can_continue:=exec('blk_lock','#table','REM_ZASA',REM_ZASA.ref(),,1,
        'Załącznik: %1 jest redagowany.'@[REM_ZASA.bl_info('ATA','NAME')])
   ?}
|| REM_ZASA.blank();
   REM_ZASA.REM_ZAS:=REM_ZAS.ref()
?};

_valid:="__CHK.record(REM_ZASA,,'ATA')";
_red:=REM_ZASA.mk_edit(FUN.TYT,,'readattach',,,'normal');
{? _dndsize=0
||
:: Jeśli drag'n'drop to nie wyświetlam nazwy pliku, bo nie potrzeba
   REM_ZASA.win_efld(_red,,'ATA',,,47,,,'Nazwa pliku'@,,,,'F3_button=1')
?};
REM_ZASA.win_efld(_red,,'NAZWA',,,50,,,'Opis'@);
REM_ZASA.efld_opt(_red,'mark=1',,'ATA');
exec('ok_esc','#window',REM_ZASA,_red);
REM_ZASA.win_edit(_red);
_file:='';
_filepath:='';
_sep:=exec('sep','#file');
{? exec('interm','#system')
|| _sep:='/'
?};
{? _dndsize>0
||
   _file:=_dnd.FILENAME;
   _monkey:='';
   {? exec('interm','#system')=0
   ||
::    Na jterm trzeba dodać małpę do ścieżki, bo plik jest na końcówce klienta
      _monkey:='@'
   ?};
   _filepath:=_monkey+_dnd.DIR+_sep+_dnd.FILENAME;
   REM_ZASA.bl_file('ATA',1,_filepath)
||
   REM_ZASA.bl_file('ATA',1)
?};
_can_continue:=REM_ZASA.edit(_valid);
{? _can_continue>0
||
   {? _action='Dołącz'
   ||
      {? _dndsize<2
      ||
::       pojedyńczy plik z akcji albo d'n'd
         _filepath:=REM_ZASA.bl_file('ATA');

         {? _file='' & _filepath<>''
         || _file:=exec('file_from_path','#file',_filepath)
         ?};
         {? _file<>''
         ||
            _can_continue:=_env.validate(_file,_filepath,1);
            {? _can_continue>0
            ||
               REM_ZASA.cntx_psh();
               REM_ZASA.prefix();
               _can_continue:=REM_ZASA.add();
               {? _can_continue>0
               || _env.SELECT_STR:=REM_ZASA.uidref();
                  _can_continue:=REM_ZASA.bl_put('ATA',_filepath,,,_file)
               ?};
               REM_ZASA.cntx_pop()
            ?}
         ?};
         _can_continue:=0

      |? _dndsize>1
      ||
::       kilka plików z d'n'd
         _mydo:=do_state()=0;
         {? _mydo || do() ?};
         {!
         |?
            _file:=_dnd.FILENAME;
            {? _file<>''
            ||
               _can_continue:=_env.validate(_file,_filepath,1);
               {? _can_continue>0 & _env.FML_FILE<>""
               ||
::                Jeśli formuła dla każdego pliku podana to ją wywołuję
                  _can_continue:=_env.FML_FILE(_env.FML_ARGS,_env.BUFFER,_file,_filepath);
                  {? type_of(_can_continue)<>type_of(0)
                  || _can_continue:=0
                  ?}
               ?};
               {? _can_continue>0
               ||
                  REM_ZASA.cntx_psh();
                  REM_ZASA.prefix();
                  _can_continue:=REM_ZASA.add();
                  {? _can_continue>0
                  || _env.SELECT_STR:=REM_ZASA.uidref();
                     _can_continue:=REM_ZASA.bl_put(_env.FIELD,_filepath,,,_file)
                  ?};
                  REM_ZASA.cntx_pop()
               ?}
            ?};
            _dnd.next()
         !};
         {? _mydo || end() ?};
         _can_continue:=0
      ?}
   |? _action='Popraw'
   ||
      _filepath:=REM_ZASA.bl_file('ATA');
      _file:='';
      {? _filepath<>''
      || _file:=exec('file_from_path','#file',_filepath)
      ?};
      _can_continue:=_env.validate(_file,_filepath,1);
      {? _can_continue>0
      ||
         REM_ZASA.cntx_psh();
         REM_ZASA.prefix();
         _can_continue:=REM_ZASA.put();
         {? _can_continue>0 & _file<>''
         || _can_continue:=REM_ZASA.bl_put('ATA',_filepath,,,_file)
         ?};
         REM_ZASA.cntx_pop()
      ?};
      _can_continue:=0;
      exec('blk_unlock','#table','REM_ZASA',REM_ZASA.ref())
   ?}
|| _can_continue:=0
?};

REM_ZASA.cntx_pop();
_env.SELECT_STR:=_uidref;
{? _can_continue>0
|| _result:=1
?};
_buffer.REM_ZAS:=_args.REM_ZAS;
_result


\rem_zasa_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Zwraca formułę na walidację załączników w tabeli REM_ZASA dla kontrolki
::   WY: FORMULA
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_fml:="
      _filename:=_c;
      _dialog:=_e;
      _result:=1;
      _env:=params_get().env_blob;
      {? _env.has_file(_filename)>0
      || _result:=0;
         _msg:='Plik o nazwie: %1 jest już dodany jako załącznik i nie może zostać dodany ponownie.'@[_filename];
         {? _dialog=0
         || FUN.emsg(_msg)
         || KOMM.add(_msg,2,,1)
         ?}
      ?};
      _result
   ";
_fml


\env_zasoby_remontowe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Zwraca środowisko dla zasobów remontowych
::   WY: obj_new
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
::UWAGA: _fld, i _mth to formułki pomocnicze, zeby wygodniej tworzyć tablicę i komentować poszczególne jej elementy
::       powiedzmy, że to bedzie pole
         _fld:="31+form(_a)";
::       powiedzmy, że to bedzie metoda
         _mth:="31+form(_a)";

_env:=obj_new(
::             Zmienne pomocnicze
                _fld('REM_ZAS_VIEW','Widok w zasobach remontowych (płaski/drzewo)')
               ,_fld('env_blob','Środowisko do obsługi załączników')
               ,_fld('DISABLE','Wyłączator okienek')
               ,_fld('CUR_TAB','Zakładka na której aktualnie stoję')
               ,_fld('DONE','Sterowanie zakończeniem czynności')
             );
_env.REM_ZAS_VIEW:=0;
_env.env_blob:=exec('rem_zasa_env','zasoby');
_env.DISABLE:='';
_env.CUR_TAB:='';
_env.DONE:=0;
_env


\rem_zasa_after_rfr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Ładuje zawartość na zakładce załączników remontowych
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env:=params_get().env_zasoby;
_env_blob:=_env.env_blob;

{? REM_ZAS.AKT<>'T' | _env.DISABLE='#disable'
|| _env_blob.EDITABLE:=0
|| _env_blob.EDITABLE:=1
?};
_env_blob.actions_grayed();

{? _env.DISABLE=''
:: załadować i wyświetlić załączniki
|| REM_ZASA.index('REM_ZAS');
   _env_blob.FML_ARGS.REM_ZAS:=REM_ZAS.ref();
   REM_ZASA.prefix(REM_ZAS.ref());
   _env_blob.update();
   ~~
:: zdezaktywować kontrolkę
|| REM_ZASA.index('NAZWA');
   REM_ZASA.prefix('*',REM_ZAS.IDADD);
   _env_blob.update();
   ~~
?};
~~


\rem_zas_after_rfr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Po odświeżeniu w okienku REM_ZAS
::   WE: [_a] - INTEGER - czy wykonywać grp_disp okien?
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get);
_env:=params_get().env_zasoby;

_grp_disp:=1;
{? var_pres('_a')=type_of(0)
|| _grp_disp:=_a
?};
{? _env.CUR_TAB='Zgłoszenia remontowe'
|| exec('rem_zgl_zas_after_rfr','remonty_zgloszenia')
|? _env.CUR_TAB='Planowane zdarzenia - harmonogram'
|| exec('rem_zas_plan_select','remonty_cykliczne','H')
|? _env.CUR_TAB='Planowane zdarzenia - przebiegi'
|| exec('rem_zas_plan_select','remonty_cykliczne','P')
|? _env.CUR_TAB='Osoby użytkujące zasób'
|| exec('rem_zasu_after_rfr','zasoby')
|? _env.CUR_TAB='Gwarancje'
|| exec('rem_gwar_after_rfr','zasoby')
|? _env.CUR_TAB='Przebiegi'
|| exec('rem_zasp_after_rfr','zasoby')
|? _env.CUR_TAB='Załączniki'
|| exec('rem_zasa_after_rfr','zasoby')
|? _env.CUR_TAB='Problemy produkcyjne'
|| exec('ek_prob_after_rfr','zl_wkj')
?};
{? _grp_disp>0
|| _env.DISABLE:='';
   {? grp_empty(REM_ZAS,cur_win(1,1)) || _env.DISABLE:='#disable' ?};
   exec('rem_zas_grp_disp','zasoby')
?};
~~


\rem_zas_grp_disp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Uruchamia odświeżenie okien
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get);
_env:=params_get().env_zasoby;
{? _env.CUR_TAB='Zgłoszenia remontowe'
|| grp_disp(REM_ZGL,'WERC')
|? _env.CUR_TAB='Planowane zdarzenia - harmonogram'
|| grp_disp(REM_HARM,'WER_H')
|? _env.CUR_TAB='Planowane zdarzenia - przebiegi'
|| grp_disp(REM_HARM,'WER_P')
|? _env.CUR_TAB='Osoby użytkujące zasób'
|| grp_disp(REM_ZASU,'WER',1)
|? _env.CUR_TAB='Gwarancje'
|| grp_disp(REM_GWAR,'WER',1)
|? _env.CUR_TAB='Przebiegi'
|| grp_disp(REM_ZASP,'WER',1)
|? _env.CUR_TAB='Załączniki'
|| ~~
|? _env.CUR_TAB='Problemy produkcyjne'
|| grp_disp(EK_PROB,'WER',1)
?};
{? grp_empty(REM_ZAS,cur_win(1,1)) || _env.DISABLE:='#disable' ?};
~~


\chk_opiekun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.42]
:: OPIS: Sprawdza czy podany użytkownik jest opiekunem zasobu
::   WE: _a - USERS.ref - użytkownik
::       [_b] - REM_ZAS.ref lub bieżący rekord
::   WY: 0 - user nie jest opiekunem
::       1 - user jest opiekunem, lub zasób nie ma opiekunów
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_users:=_a;

_ref:=null();
{? var_pres('_b')=type_of(REM_ZAS.ref())
|| _ref:=_b
?};

_result:=1;
_can_continue:=1;

REM_ZAS.cntx_psh();
{? _ref<>null()
|| REM_ZAS.prefix();
   {? REM_ZAS.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? REM_ZAS.KAT<>null()
   ||
::    Sprawdzam czy są w ogóle opiekunowie
      REM_KATO.cntx_psh();
      REM_KATO.index('REM_KAT');
      REM_KATO.prefix(REM_ZAS.KAT);
      {? REM_KATO.first()
      || _result:=0;

         REM_KATO.prefix(REM_ZAS.KAT,_users);
         {? REM_KATO.first()
         || _result:=1
         ?}
      ?};
      REM_KATO.cntx_pop()
   ?}
?};
REM_ZAS.cntx_pop();
_result


\rem_zasp_win_fml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Formuły dla pól w okienkach wertowania tabeli REM_ZASP
::----------------------------------------------------------------------------------------------------------------------
REM_ZASP.win_fml('WER',,'PRZ',,'ICON_BEFORE',"{? REM_ZASP.MODE='C' || 'xwin16.png:33' || 'xwin16.png:76' ?}");
REM_ZASP.win_fml('WER',,'PRZ',,'SUM_FORMAT', "'out_prec='+$REM_ZASP.REM_ZAS().PRZ_DOKL",2);
~~


\rem_zas_px
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Sprawdza czy podany zasób występuje w planie strategicznym
::   WE: [_a] - REM_ZAS.ref lub bieżący rekord
::   WY: null() - nie ma tego zasobu w planie
::       PX_KONT.ref() - jest
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZAS.ref())
|| _ref:=_a
?};

_result:=null();
_can_continue:=1;

REM_ZAS.cntx_psh();
{? _ref<>null()
|| REM_ZAS.prefix();
   {? REM_ZAS.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _pl_res1:=null();
   _pl_res2:=null();
   {? REM_ZAS.TWRKPLC<>null()
   || _pl_res1:=exec('get_plres','po_plan','S',REM_ZAS.TWRKPLC)
   ?};
   {? REM_ZAS.TWRKZBR<>null()
   || _pl_res2:=exec('get_plres','po_plan','G',REM_ZAS.TWRKZBR)
   ?};

   {? _pl_res1<>null()
   || PX_KONT.cntx_psh();
      PX_KONT.index('PL_RES');
      PX_KONT.prefix(exec('get_mainversion','px_ver'),_pl_res1);
      {? PX_KONT.first()
      || {? PX_KONT.A='T'
         || _result:=PX_KONT.ref()
         ?}
      ?};
      PX_KONT.cntx_pop()
   ?};
   {? _result=null() & _pl_res2<>null()
   || PX_KONT.cntx_psh();
      PX_KONT.index('PL_RES');
      PX_KONT.prefix(exec('get_mainversion','px_ver'),_pl_res2);
      {? PX_KONT.first()
      || {? PX_KONT.A='T'
         || _result:=PX_KONT.ref()
         ?}
      ?};
      PX_KONT.cntx_pop()
   ?}
?};
REM_ZAS.cntx_pop();
_result


\rem_zas_pl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Sprawdza czy podany zasób występuje w planie operacyjnym
::   WE: [_a] - REM_ZAS.ref lub bieżący rekord
::   WY: null() - nie ma tego zasobu w planie
::       PL_RES.ref - jest
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZAS.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

REM_ZAS.cntx_psh();
{? _ref<>null()
|| REM_ZAS.prefix();
   {? REM_ZAS.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _pl_res:=null();
   {? REM_ZAS.TWRKPLC<>null()
   || _pl_res:=exec('get_plres','po_plan','S',REM_ZAS.TWRKPLC)
   |? REM_ZAS.TWRKZBR<>null()
   || _pl_res:=exec('get_plres','po_plan','G',REM_ZAS.TWRKZBR)
   ?};

   {? _pl_res<>null()
   || PL_OPIS.cntx_psh();
      PL_OPIS.index('PL_RES');
      PL_OPIS.prefix(_pl_res);
      {? PL_OPIS.first()
      || _result:=_pl_res
      ?};
      PL_OPIS.cntx_pop()
   ?}
?};
REM_ZAS.cntx_pop();
_result


\rem_czyn_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula dodaje czynnosc do slownika czynnosci remontowych
::----------------------------------------------------------------------------------------------------------------------
REM_CZYN.win_edit('RED');
REM_CZYG.win_sel('WER');
REM_CZYN.blank();
{? REM_CZYN.edit("exec('chk_rem_czyn','zasoby',1)")
|| REM_CZYN.add()
?}


\chk_rem_czyn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula weryfikuje dane w oknie redagowania slownika czynnosci remontowych
::   WE: 1 - dołączanie, 2 - poprawianie
::----------------------------------------------------------------------------------------------------------------------
_fld:='';
_fld:=__CHK.record(REM_CZYN,,'KOD','OPIS');
{? _fld=''
||
   {? _a=1
   ||
      _kod:=REM_CZYN.KOD;
      REM_CZYN.cntx_psh();
      REM_CZYN.index('KOD');
      REM_CZYN.prefix(_kod,);
      {? REM_CZYN.first()
      || FUN.emsg('Czynność o podanym kodzie już istnieje w słowniku.'@);
         _fld:='KOD'
      ?};
      REM_CZYN.cntx_pop()
   |? _a=2
   || _ref:=REM_CZYN.ref();
      _kod:=REM_CZYN.KOD;
      REM_CZYN.cntx_psh();
      REM_CZYN.index('KOD');
      REM_CZYN.prefix(_kod,);
      {? REM_CZYN.first() & REM_CZYN.ref()<>_ref
      || FUN.emsg('Czynność o podanym kodzie już istnieje w słowniku.'@);
         _fld:='KOD'
      ?};
      REM_CZYN.cntx_pop()
   ?}
?};
_fld


\rem_czyn_pop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula poprawia czynnosc w slowniku czynnosci remontowych
::----------------------------------------------------------------------------------------------------------------------
REM_CZYN.win_edit('RED');
{? REM_CZYN.r_lock(1,1)
|| {? REM_CZYN.count()>0
   || {? FUN.ask('Bieżąca czynność została już wykorzystana w systemie. Czy mimo to rozpocząć edycję?'@)
      || {? REM_CZYN.edit("exec('chk_rem_czyn','zasoby',2)")
         || REM_CZYN.put()
         ?}
      ?}
   || {? REM_CZYN.edit("exec('chk_rem_czyn','zasoby',2)")
      || REM_CZYN.put()
      ?}
   ?};
   REM_CZYN.r_unlock()
|| FUN.info('Bieżącą pozycję słownika obsługuje inny operator.'@)
?}


\rem_czyn_usu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: formula usuwa czynnosc ze slownika czynnosci remontowych
::----------------------------------------------------------------------------------------------------------------------
{? REM_CZYN.count()=0
|| {? FUN.ask('Usunąć czynność: %1?'@[REM_CZYN.KOD]) || REM_CZYN.del() ?}
|| FUN.emsg('Nie można usunąć czynności ze względu na powiązania z innymi zapisami w bazie danych.'@)
?}


\rem_czyg_usu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula usuwa grupę czynności remontowych
::----------------------------------------------------------------------------------------------------------------------
{? REM_CZYG.count()>0
|| FUN.emsg('Grupa czynności jest wykorzystywana i nie można jej usunąć.'@);
   0
|| 1
?}


\rem_czyt_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula dolacza szablon zestawu czynnosci
::----------------------------------------------------------------------------------------------------------------------
REM_CZYT.blank();
REM_CZYT.win_edit('RED');
{? REM_CZYT.edit("exec('chk_rem_czyt','zasoby',1)")
|| REM_CZYT.add()
?}


\chk_rem_czyt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula weryfikuje poprawnosc wypelnienia okna redagowania tabeli REM_CZYT
::   WE: [1] - dołączanie, 2 - poprawianie
::   WY: '' lub kod pola
::----------------------------------------------------------------------------------------------------------------------
_fld:='';
_type:={? var_press('_a')=type_of(0) || _a || 1 ?};
_fld:=__CHK.record(REM_CZYT,,'KOD','OPIS');
{? _fld=''
||  {? _type=1
    || REM_CZYT.cntx_psh();
       REM_CZYT.index('KOD');
       REM_CZYT.prefix(REM_CZYT.KOD,);
       {? REM_CZYT.first()
       || FUN.emsg('Szablon o podanym kodzie już istnieje.'@);
          _fld:='KOD'
       ?};
       REM_CZYT.cntx_pop()
    |? _type=2
    || _ref:=REM_CZYT.ref();
       REM_CZYT.cntx_psh();
       REM_CZYT.index('KOD');
       REM_CZYT.prefix(REM_CZYT.KOD,);
       {? REM_CZYT.first() & _ref<>REM_CZYT.ref()
       || FUN.emsg('Szablon o podanym kodzie już istnieje.'@);
          _fld:='KOD'
       ?};
       REM_CZYT.cntx_pop()
    ?}
?};
_fld


\rem_czyt_usu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula usuwa szablon zestawu czynnosci
::----------------------------------------------------------------------------------------------------------------------
{? REM_CZYT.count()>0
|| FUN.info('Szablon jest wykorzystywany i nie można go usunąć.'@);
   return(0)
?};
{? FUN.ask('Usunąć szablon: %1 ?'@[REM_CZYT.KOD])
|| do();
   REM_CZYP.index('REM_CZYT');
   REM_CZYP.prefix(REM_CZYT.ref());
   {? REM_CZYP.first()
   || {! |?
         REM_CZYP.del()
      !}
   ?};
   REM_CZYT.del();
   end()
?}


\rem_czyt_pop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula do edycji szablonu zestawu czynnosci
::----------------------------------------------------------------------------------------------------------------------
{? REM_CZYT.r_lock(1,1)
|| REM_CZYT.win_edit('RED');
   {? REM_CZYT.edit("exec('chk_rem_czyt','zasoby',2)")
   || REM_CZYT.put()
   ?};
   REM_CZYT.r_unlock()
|| FUN.info('Szablon edytuje inny operator.'@)
?}


\rem_czyp_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula dodaje pozycje szablonu
::----------------------------------------------------------------------------------------------------------------------
REM_CZYN.cntx_psh();
REM_CZYN.win_sel('WER');
REM_CZYP.win_edit('RED');
REM_CZYP.blank();
REM_CZYP.REM_CZYT:=REM_CZYT.ref();
:: Ustalenie nowego numeru
REM_CZYP.NR:=exec('rem_znajdz_nr','zasoby',REM_CZYP);
{? REM_CZYP.edit("exec('chk_rem_czyp','zasoby',1)")
|| REM_CZYP.add()
?};
REM_CZYN.cntx_pop()


\rem_czyp_usu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula usuwa pozycje szablonu
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Usunąć pozycję z szablonu?'@)
|| REM_CZYP.del();
   exec('rem_licz','zasoby',REM_CZYP)
?}


\rem_czyp_pop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula do edycji pozycji szablonu
::----------------------------------------------------------------------------------------------------------------------
REM_CZYP.win_edit('RED');
{? REM_CZYP.edit("exec('chk_rem_czyp','zasoby',2)")
|| REM_CZYP.put()
?}


\chk_rem_czyp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula weryfikuje poprawnosc wypelnienia okna redagowania tabeli REM_CZYP
::   WE: 1 - dołączanie, 2 - poprawianie
::   WY: '' lub kod pola
::----------------------------------------------------------------------------------------------------------------------
_fld:='';
_fld:=__CHK.record(REM_CZYP,,'REM_CZYN');
{? _fld=''
||  {? _a=1
    || REM_CZYP.cntx_psh();
       REM_CZYP.index('REM_CZYT');
       REM_CZYP.prefix(REM_CZYP.REM_CZYT,REM_CZYP.REM_CZYN);
       {? REM_CZYP.first()
       || FUN.emsg('Wskazana czynność jest już elementem bieżącego szablonu.'@);
          _fld:='REM_CZYN'
       ?};
       REM_CZYP.cntx_pop()
    |? _a=2
    || _ref:=REM_CZYP.ref();
       REM_CZYP.cntx_psh();
       REM_CZYP.index('REM_CZYT');
       REM_CZYP.prefix(REM_CZYP.REM_CZYT,REM_CZYP.REM_CZYN);
       {? REM_CZYP.first() & _ref<>REM_CZYP.ref()
       || FUN.emsg('Wskazana czynność jest już elementem bieżącego szablonu.'@);
          _fld:='REM_CZYN'
       ?};
       REM_CZYP.cntx_pop()
    ?}
?};
_fld


\rem_czyu_add
::----------------------------------------------------------------------------------------------------------------------
:: UTW  : AKUL [20.14]
:: OPIS : Formula dodaje czynnosc
::----------------------------------------------------------------------------------------------------------------------
REM_CZYU.cntx_psh();
REM_CZYU.index('REM_CZYN');
REM_CZYU.prefix();
REM_CZYU.blank();
REM_CZYU.memo_set('','OPIS_DOD');
REM_CZYU.REM_ZGL:=REM_ZGL.ref();
:: Ustalenie nowego numeru
REM_CZYU.NR:=exec('rem_znajdz_nr','zasoby',REM_CZYU);
REM_CZYU.efld_opt(REM_CZYU.win_edit('?'),'editable=0,mark=0',,'DW');
REM_CZYU.win_edit('RED');
_ref:=null;
{? REM_CZYU.edit("exec('chk_rem_czyu','zasoby',1)")
|| REM_CZYU.KOD_CZYN:=REM_CZYU.REM_CZYN().KOD;
   {? REM_CZYU.add()
   || REM_CZYU.memo_put(,'OPIS_DOD');
      _ref:=REM_CZYU.ref()
   ?}
?};
REM_CZYU.efld_opt(REM_CZYU.win_edit('?'),'editable=1,mark=1',,'DW');
REM_CZYU.cntx_pop();
{? _ref<>null()
|| REM_CZYU.seek(_ref)
?};
~~


\rem_czyu_add_templ
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Dolaczanie czynnosci na podstawie szablonu
::----------------------------------------------------------------------------------------------------------------------
REM_CZYU.cntx_psh();
REM_CZYU.index('REM_CZYN');
REM_CZYU.prefix();
REM_CZYT.index('KOD');
REM_CZYT.prefix();
REM_CZYT.win_sel('SELECT');
_ref:=null;
::{? REM_CZYT.first()
::||
   {? REM_CZYT.select()
   || REM_CZYP.index('NR');
      REM_CZYP.prefix(REM_CZYT.ref());
      {? REM_CZYP.first()
      || {!
         |?
            REM_CZYU.blank();
            REM_CZYU.memo_set('','OPIS_DOD');
            REM_CZYU.REM_ZGL:=REM_ZGL.ref();
            REM_CZYU.REM_CZYN:=REM_CZYP.REM_CZYN;
            REM_CZYU.NR:=exec('rem_znajdz_nr','zasoby',REM_CZYU);
            REM_CZYU.WYK:='N';
            REM_CZYU.KOD_CZYN:=REM_CZYU.REM_CZYN().KOD;
            REM_CZYU.add();
            REM_CZYP.next()
         !};
         _ref:=REM_CZYU.ref()
      || FUN.info('Nie dodano czynności do realizacji zgłoszenia. Wybrano pusty szablon (bez pozycji).'@)
      ?}
   ?};
REM_CZYU.cntx_pop();
{? _ref<>null()
|| REM_CZYU.seek(_ref)
?};
~~
::|| FUN.info('Nie zdefiniowano żadnego szablonu dla remontów.'@)
::?}


\rem_czyu_add_templ_auto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Dolaczanie czynnosci na podstawie szablonu (wykonywana automatycznie podczas weryfikacji zgłoszenia lub
::       generowania zdarzeń czyklicznych
::   WE: _a - zgłoszenie (REM_ZGL.ref)
::       _v - kod szablonu czynności
::   WY: 1 / 0
::----------------------------------------------------------------------------------------------------------------------
_zgl:= {? var_press('_a')=type_of(REM_ZGL.ref()) || _a || return(0) ?};
_kod:= {? var_press('_b')=type_of('') || _b || return(0) ?};
REM_CZYU.cntx_psh();
REM_CZYU.index('REM_CZYN');
REM_CZYU.prefix();
REM_CZYT.index('KOD');
REM_CZYT.prefix(_kod);
REM_CZYU.prefix();
{? REM_CZYT.first()
|| REM_CZYP.index('NR');
   REM_CZYP.prefix(REM_CZYT.ref());
   {? REM_CZYP.first()
   || {!
      |?
         REM_CZYU.blank();
         REM_CZYU.memo_set('','OPIS_DOD');
         REM_CZYU.REM_ZGL:=_zgl;
         REM_CZYU.REM_CZYN:=REM_CZYP.REM_CZYN;
         REM_CZYU.NR:=exec('rem_znajdz_nr','zasoby',REM_CZYU);
         REM_CZYU.WYK:='N';
         REM_CZYU.KOD_CZYN:=REM_CZYU.REM_CZYN().KOD;
         REM_CZYU.add();
         REM_CZYP.next()
      !}
      ?}
::|| FUN.info('Nie znaleziono szablonu o podanym kodzie.'@)
?};
REM_CZYU.cntx_pop()


\rem_czyu_pop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula Popraw czynnosci powiązanej ze zgłoszeniem
::----------------------------------------------------------------------------------------------------------------------
{? REM_CZYU.r_lock(1,1)
|| REM_CZYU.efld_opt(REM_CZYU.win_edit('?'),'editable=0,mark=0',,'DW');
   {? REM_CZYU.WYK='T'
   || REM_CZYU.efld_opt(REM_CZYU.win_edit('?'),'editable=0,mark=0',,'REM_CZYN')
   || REM_CZYU.efld_opt(REM_CZYU.win_edit('?'),'editable=1,mark=1',,'REM_CZYN')
   ?};
   REM_CZYU.win_edit('RED');
   REM_CZYU.memo_get(,'OPIS_DOD');
   {? REM_CZYU.edit("exec('chk_rem_czyu','zasoby',2)")
   || REM_CZYU.KOD_CZYN:=REM_CZYU.REM_CZYN().KOD;
      {? REM_CZYU.put()
      || REM_CZYU.memo_put(,'OPIS_DOD')
       ?}
   ?};
   REM_CZYU.efld_opt(REM_CZYU.win_edit('?'),'editable=1,mark=1',,'DW');
   REM_CZYU.r_unlock()
|| FUN.info('Czynność obsługiwana przez innego operatora.'@)
?}


\rem_czyu_usu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Usuwanie czynnosci powiązanej ze zgłoszeniem
::----------------------------------------------------------------------------------------------------------------------
{? REM_CZYU.WYK<>'N'
|| {? VAR.GRUPA='T'
   || KOMM.add('Czynność %1 została już wykonana i nie można jej usunąć.'@[REM_CZYU.REM_CZYN().KOD])
   || FUN.emsg('Wskazana czynność została już wykonana i nie można jej usunąć.'@)
   ?};
   return(0)
?};
{? VAR.GRUPA='T' | FUN.ask('Usunąć bieżącą czynność?'@)
|| REM_CZYU.del();
   {? VAR.GRUPA<>'T'
   || exec('rem_licz','zasoby',REM_CZYU)
   ?}
?}


\rem_czyu_wyk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula dla akcji Wykonaj w oknie czynnosci powiązanej ze zgłoszeniem
::----------------------------------------------------------------------------------------------------------------------
{? REM_CZYU.WYK='N'
|| {? REM_CZYU.r_lock(1,1)
   ||
::      REM_CZYU.win_edit('RED');
      REM_CZYU.DW:=date();
      REM_CZYU.GW:=time();
::      REM_CZYU.efld_opt(REM_CZYU.win_edit('?'),'editable=0,mark=0',,'REM_CZYN','KOD');
      REM_CZYU.memo_get(,'OPIS_DOD');
::      {? REM_CZYU.edit("exec('chk_rem_czyu_wyk','zasoby')")
::      ||
      REM_CZYU.WYK:='T';
      {? VEK.TERM='T'
      || REM_CZYU.P:=VEK.P
      || REM_CZYU.P:=null()
      ?};
      REM_CZYU.USER:=OPERATOR.USER;
      {? REM_CZYU.put()
      || REM_CZYU.memo_put(,'OPIS_DOD')
      ?};
::      ?};
::      REM_CZYU.efld_opt(REM_CZYU.win_edit('?'),'editable=1,mark=1',,'REM_CZYN','KOD');
      REM_CZYU.r_unlock()
   || {? VAR.GRUPA='T'
      || KOMM.add('Czynność %1 obsługiwana przez innego operatora.'@[REM_CZYU.REM_CZYN().KOD])
      || FUN.info('Czynność obsługiwana przez innego operatora.'@)
      ?}
   ?}
|| {? VAR.GRUPA='T'
   || KOMM.add('Czynność %1 została już wykonana.'@[REM_CZYU.REM_CZYN().KOD])
   || FUN.emsg('Czynność została już wykonana.'@)
   ?}
?};
~~


\chk_rem_czyu_wyk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Weryfikacja okna redagowania przy wykonaniu czynnosci
::----------------------------------------------------------------------------------------------------------------------
_fld:='';
_fld:=__CHK.record(REM_CZYU,,'DW');
_fld


\rem_czyu_wyc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Anulowanie wykonania czynnosci
::----------------------------------------------------------------------------------------------------------------------
{? REM_CZYU.WYK<>'N'
|| {? REM_CZYU.r_lock(1,1)
   || REM_CZYU.WYK:='N';
      REM_CZYU.DW:=date(0,0,0);
      REM_CZYU.GW:=time(0,0,0);
      REM_CZYU.P:=null();
      REM_CZYU.USER:=null();
      REM_CZYU.put();
      REM_CZYU.r_unlock()
   || {? VAR.GRUPA='T'
      || KOMM.add('Czynność %1 obsługuje inny operator.'@[REM_CZYU.REM_CZYN().KOD])
      || FUN.info('Czynność obsługuje inny operator.'@)
      ?}
   ?}
|| {? VAR.GRUPA='T'
   || KOMM.add('Czynność %1 nie została jeszcze wykonana.'@[REM_CZYU.REM_CZYN().KOD])
   || FUN.emsg('Czynność nie została jeszcze wykonana.'@)
   ?}
?}


\rem_czyp_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula wyswietla okno pozycji szablonu, jesli lista szabonow wywolana jest jako slownik
::----------------------------------------------------------------------------------------------------------------------
REM_CZYP.index('NR');
REM_CZYP.prefix(REM_CZYT.ref());
REM_CZYP.win_sel('WER');
::REM_CZYP.win_edit('RED');
REM_CZYP.select()


\rem_czyu_br
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula na rekord przed w oknach wertowania REM_CZYU
::   WE: _a - parametr systemowy
::----------------------------------------------------------------------------------------------------------------------
:: Podczytanie wykonawcy czynności
_str:='';
Cntx.psh(P,OSOBA,USERS);
{? REM_CZYU.P<>null()
|| REM_CZYU.P().OSOBA();
   _str:='%1 %2'[OSOBA.NAZWISKO,OSOBA.PIERWSZE]
|? REM_CZYU.USER<>null()
|| {? REM_CZYU.USER().OSOBA<>null()
   || REM_CZYU.USER().OSOBA();
      _str:='%1 %2'[OSOBA.NAZWISKO,OSOBA.PIERWSZE]
   || _str:='%1'[USERS.DANE]
   ?}
?};
Cntx.pop(P,OSOBA,USERS);
VAR.STRING:=_str;
~~


\chk_rem_czyu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula weryfikuje poprawnosc wypelnienia rekordu tabeli REM_CZYU
::   WE: _a = 1 - kontrola przy dodawaniu, _a = 2 - kontrola przy poprawianiu
::----------------------------------------------------------------------------------------------------------------------
_fld:='';
_fld:=__CHK.record(REM_CZYU,,'REM_CZYN');
_fld


\be_var_czyn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula przed redagowaniem dla pól zmiennych powiązanych z czynnościami
::----------------------------------------------------------------------------------------------------------------------
_afld:=cur_afld();
1


\ae_var_czyn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula po redagowanieu dla pól zmiennych powiązanych z czynnościami
::----------------------------------------------------------------------------------------------------------------------
_afld:=cur_afld();
_res:=1;
{? _afld='REM_CZYU'
|| {? fld()=''
   || cur_tab(1,1).REM_CZYU:=null();
      cur_tab(1,1).REM_CZYU().REM_CZYN();
      _res:=1
   || REM_CZYU.cntx_psh();
      REM_CZYU.index('REM_CZYN');
      _czyn:=exec('FindInSet','#table','REM_CZYN','KOD',fld(),,"REM_CZYN.ref()",0,,null);
      REM_CZYU.prefix(REM_GRG.REM_ZGL,_czyn);
      {? REM_CZYU.first()
      || cur_tab(1,1).REM_CZYU:=REM_CZYU.ref();
         fld( REM_CZYU.REM_CZYN().KOD);
         _res:=1
      || FUN.emsg('Nie znaleziono czynności o wpisanym kodzie.'@);
         _res:=0
      ?};
      REM_CZYU.cntx_pop();
      cur_tab(1,1).REM_CZYU().REM_CZYN()
   ?}
?};
_res


\bd_var_czyn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula przed wyświetleniem pól zmiennych powiązanych z czynnościami
::----------------------------------------------------------------------------------------------------------------------
_afld:=cur_afld();
{? _afld='REM_OPIS'
|| {? VAR.REM_CZYN=null()
   || REM_GRG.efld_opt('RED','editable=grayed',VAR,'REM_OPIS')
   || REM_GRG.efld_opt('RED','editable=1',VAR,'REM_OPIS')
   ?}
|? _afld='REM_CZYU'
|| fld(cur_tab(1,1).REM_CZYU().REM_CZYN().KOD)
?};
1


\f3_var_czyn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula na f3 dla zmiennych powiązanych z czynnościami
::----------------------------------------------------------------------------------------------------------------------
_afld:=cur_afld();
{? _afld='REM_CZYU'
|| _fld:=fld();
:: Zapisywana poprzednia zawartość REF
   _ref:=cur_tab(1,1).REM_CZYU;
   REM_CZYU.cntx_psh();
   REM_CZYU.win_sel('SEL');
   REM_CZYU.index('NR');
   REM_CZYU.prefix(REM_GRG.REM_ZGL);
   {? REM_CZYU.select()
   || _res:=REM_CZYU.REM_CZYN().KOD;
      cur_tab(1,1).REM_CZYU:=REM_CZYU.ref();
      fld(_res)
   || cur_tab(1,1).REM_CZYU:=_ref;
      fld(_fld)
   ?};
   REM_CZYU.cntx_pop();
   cur_tab(1,1).REM_CZYU().REM_CZYN();
   fld()
?}


\rem_czyg_sel
::---------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula wyswietla slownik grup czynnosci remontowych
::---------------------------------------------------------------------------------
REM_CZYG.index('KOD');
REM_CZYG.prefix();
REM_CZYG.win_sel('WER');
REM_CZYG.win_edit('RED');
REM_CZYG.select()


\rem_czyn_sel
::---------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula wyswietla slownik czynnosci remontowych
::---------------------------------------------------------------------------------
REM_CZYN.index('KOD');
REM_CZYN.prefix();
REM_CZYN.win_sel('WER');
REM_CZYN.win_edit('RED');
REM_CZYN.select()


\sel_czyp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula do odswiezania zawartosci okna z pozycjami szablonu
::----------------------------------------------------------------------------------------------------------------------
REM_CZYP.index('NR');
REM_CZYP.prefix(REM_CZYT.ref());
grp_disp(REM_CZYP,'WER')


\rem_czyt_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Definicje szablonow zestawow czynnosci
::----------------------------------------------------------------------------------------------------------------------
REM_CZYT.index('KOD');
REM_CZYT.prefix();
_group:=REM_CZYT.grp_make('Szablony',,'_grp_tpl',,,,,'normal');
REM_CZYT.grp_sel(_group,REM_CZYT,'WER',,"exec('sel_czyp','zasoby')",,,14);
REM_CZYT.grp_splt(_group,,'horizontal','bottom');
_fb:="
   {? grp_empty(REM_CZYT,'WER')
   || '#disable'
   ?}
";
REM_CZYT.grp_sel(_group,REM_CZYP,'WER',,"",,,14,_fb,,,,);

REM_CZYP.index('NR');
REM_CZYP.prefix(REM_CZYT.ref());
:: Renumeracja rekordow za pomoca d'n'd
REM_CZYP.dnd_sel('WER',,'records.REM_CZYP',"exec('renum','zasoby',REM_CZYP)");


REM_CZYT.win_sel(_group);
REM_CZYT.win_edit('RED');
REM_CZYT.select()


\rem_czyg_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula dodaje grupę czynnosci remontowych
::----------------------------------------------------------------------------------------------------------------------
REM_CZYG.win_edit('RED');
REM_CZYG.blank();
{? REM_CZYG.edit("exec('chk_rem_czyg','zasoby',1)")
|| REM_CZYG.add()
?}


\chk_rem_czyg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula weryfikuje dane w oknie redagowania slownika grup czynnosci remontowych
::   WE: 1 - dołączanie, 2 - poprawianie
::----------------------------------------------------------------------------------------------------------------------
_fld:='';
_fld:=__CHK.record(REM_CZYG,,'KOD','OPIS');
{? _fld=''
||
   {? _a=1
   ||
      _kod:=REM_CZYG.KOD;
      REM_CZYG.cntx_psh();
      REM_CZYG.index('KOD');
      REM_CZYG.prefix(_kod,);
      {? REM_CZYG.first()
      || FUN.emsg('Grupa czynności o podanym kodzie już istnieje w słowniku.'@);
         _fld:='KOD'
      ?};
      REM_CZYG.cntx_pop()
   |? _a=2
   || _ref:=REM_CZYG.ref();
      _kod:=REM_CZYG.KOD;
      REM_CZYG.cntx_psh();
      REM_CZYG.index('KOD');
      REM_CZYG.prefix(_kod,);
      {? REM_CZYG.first() & REM_CZYG.ref()<>_ref
      || FUN.emsg('Grupa czynności o podanym kodzie już istnieje w słowniku.'@);
         _fld:='KOD'
      ?};
      REM_CZYG.cntx_pop()
   ?}
?};
_fld


\rem_czyg_pop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula Popraw dla grupy czynnosci remontowych
::----------------------------------------------------------------------------------------------------------------------
REM_CZYG.win_edit('RED');
{? REM_CZYG.edit("exec('chk_rem_czyg','zasoby',2)")
|| REM_CZYG.put()
?};
~~


\rem_czyn_okno
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Akcja Okienko przed dla okna SLO tabeli REM_CZYN
::----------------------------------------------------------------------------------------------------------------------
::_ndx:=REM_CZYN.ndx_tmp(,,'GRUPA','KOD',1);
REM_CZYN.index('KOD');
~~


\renum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Obsluga renumeracji pozycji pozycji czynnośći szablonu/zgłoszenia (REM_CZYP/REM_CZYU)
::   WE: _a - Tabela, która będzie przenumerowana
::       [_b] - ''(domyślnie) - drag&drop, 'U','D','N'-akcja do przenumerowania
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_tryb:={? var_pres('_b')=type_of('') & (';UDN'*_b)>1 || _b || '' ?};

_result:=0;
_can_continue:=1;

_akr:={? var_press('_a')=type_of(SYSLOG) || _a || return(~~) ?};

_akr.cntx_psh();
{? _akr=REM_CZYP
|| _akr.index('NR');
   _akr.prefix(_akr.REM_CZYT)
|? _akr=REM_CZYU
|| _akr.index('NR');
   _akr.prefix(_akr.REM_ZGL)
?};
{? _can_continue>0
||
:: Wlasciwa renumeracja
   {? _tryb=''
   || _ref:=dnd_info('dest_record');
      {? _akr.seek(_ref) || exec('zmien_lp','#dragdrop','NR',_akr.index('?'),,_akr) ?}
   || exec('zmien_lpa','#dragdrop','NR',_akr.index('?'),,_akr,_tryb)
   ?}
?};
_akr.cntx_pop();
_akr.get();
{? _can_continue>0
|| _result:=1
?};
_result


\rem_licz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Przenumerowuje pozycji czynnośći szablonu/zgłoszenia (REM_CZYP/REM_CZYU)
::   WE: _a - Tabela, która będzie przenumerowana
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(3
   ,'NR_OLD','INTEGER','Stary numer'
   ,'NR_NEW','INTEGER','Nowy numer'
   ,'REF','STRING[16]','$REM_CZYP.ref'
);

_akr:={? var_press('_a')=type_of(SYSLOG) || _a || return(~~) ?};

_akr.cntx_psh();

{? _akr=REM_CZYP
|| _akr.index('NR');
   _akr.prefix(_akr.REM_CZYT)
|? _akr=REM_CZYU
|| _akr.index('NR');
   _akr.prefix(_akr.REM_ZGL)
?};

:: znalezienie rekordu ok którego zacznie się zmiana numeracji
{? _akr.first()
||
   {!
   |?
      _tab.NR_OLD:=_akr.NR;
      _tab.NR_NEW:=0;
      _tab.REF:=$_akr.ref();
      _tab.add();
      _akr.next
   !}
?};
_akr.cntx_pop();

_akr.cntx_psh();
_ndx:=_tab.ndx_tmp(,,'NR_OLD',,);
_tab.index(_ndx);

:: Ustalenie nowej kolejności
{? _tab.first()
|| _anr:=1;
   {!
   |?
      {? _akr.seek(_tab.REF)
      || _akr.NR:=_anr;
         {? _akr.put(1) || _anr+=1 ?}
      ?};
     _tab.next()
   !}
?};
_akr.cntx_pop();
~~


\rem_znajdz_nr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Ustala numer nowo dodanej pozycji czynności szablonu/zgłoszenia
::   WE: _a - Tabela, która będzie przenumerowana
::   WY: Numer pozycji
::----------------------------------------------------------------------------------------------------------------------
_akr:={? var_press('_a')=type_of(SYSLOG) || _a || return(~~) ?};

_nr:=1;
_akr.cntx_psh();

{? _akr=REM_CZYP
|| _akr.index('NR');
   _akr.prefix(_akr.REM_CZYT)
|? _akr=REM_CZYU
|| _akr.index('NR');
   _akr.prefix(_akr.REM_ZGL)
?};

{? _akr.last()
|| _nr:=_akr.NR+1
?};
_akr.cntx_pop();
_nr


\rem_czyu_usu_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Przed grupowym usuwaniem czynnosci powiązanych ze zgłoszeniem
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy usunąć zaznaczone czynności?'@)
|| VAR.GRUPA:='T';
   KOMM.init(,,'Usuwanie czynności'@,'');
   1
|| 0
?}


\rem_czyu_usu_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Po grupowym usuwaniu czynnosci powiązanych ze zgłoszeniem
::----------------------------------------------------------------------------------------------------------------------
KOMM.select();
VAR.GRUPA:='N';
exec('rem_licz','zasoby',REM_CZYU);
~~


\rem_czyu_wyk_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula przed dla akcji Wykonaj w oknie czynnosci powiązanej ze zgłoszeniem - dla grupy rekordów
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy oznaczyć wybrane czynności jako wykonane?'@)
|| VAR.GRUPA:='T';
   KOMM.init(,,'Wykonanie czynności'@,'');
   1
|| 0
?}


\rem_czyu_wyk_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Formula przed dla akcji Wykonaj w oknie czynnosci powiązanej ze zgłoszeniem - dla grupy rekordów
::----------------------------------------------------------------------------------------------------------------------
KOMM.select();
VAR.GRUPA:='N';
~~


\rem_czyu_wyc_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Anulowanie wykonania czynnosci - akcja przed dla grupy rekordów
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy anulować wykonanie wybranych czynności?'@)
|| VAR.GRUPA:='T';
   KOMM.init(,,'Wycofanie czynności'@,'');
   1
|| 0
?}


\rem_czyu_wyc_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Anulowanie wykonania czynnosci - akcja po dla grupy rekordów
::----------------------------------------------------------------------------------------------------------------------
KOMM.select();
VAR.GRUPA:='N';
~~


\rem_czyu_wyb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Akcja Wybierz w oknie redagowania 'SLO' tabeli REM_CZYU
::----------------------------------------------------------------------------------------------------------------------
{? REM_CZYU.WYK='T'
|| {? FUN.ask('Wybrana czynność została już wykonana. Czy mimo to chcesz ją wybrać?'@)
   || sel_exit()
   || 0
   ?}
|| sel_exit()
?}


\rem_czyu_grg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Akcja Wykonawcy w oknie redagowania tabeli REM_CZYU - wyświetla rozliczenia godzinowe powiązane z daną czynnością
::----------------------------------------------------------------------------------------------------------------------
REM_GRG.cntx_psh();
REM_GRG.win_sel('WER_CZYN');
REM_GRG.index('REM_CZYU');
REM_GRG.prefix(REM_CZYU.ref());
{? REM_GRG.select()
|| ~~
?};
REM_GRG.cntx_pop()


\rem_zas_chk_in_plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Sprawdza czy dany zasób remontowy jest zaplanowany w planie strategicznym lub operacyjnym (jest zaplanowana awaria)
::   WE: _a - REM_ZAS.ref()
::       [_b] - #REM_ZAS.ref() - nowy ref rekordu nadrzędnego
::   WY: 1 - zaplanowany / 0 - niezaplanowany
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;
_res:=0;
REM_ZAS.cntx_psh();
REM_ZAS.prefix();
{? REM_ZAS.seek(_ref)
|| REM_ZGL.cntx_psh();
:: Plan strategiczny
   REM_ZGL.index('ZAS_PX');
   REM_ZGL.prefix(REM_ZAS.ref(),'T');
   {? REM_ZGL.first()
   || _res:=1
   ?};
:: Plan operacyjny
   {? _res=0
   || REM_ZGL.index('ZAS_PL');
      REM_ZGL.prefix(REM_ZAS.ref(),'T');
      {? REM_ZGL.first()
      || _res:=1
      ?}
   ?};
   REM_ZGL.cntx_pop();
:: Sprawdzenie elementów nadrzędnych - rekurencja
   _ref_n:= {? var_press('_b')=type_of(0) || _b || REM_ZAS.TREE ?};
   {? _res=0 &_ref_n<>0
   || _res:=exec('rem_zas_chk_in_plan','zasoby',_ref_n)
   ?}
?};
REM_ZAS.cntx_pop();
_res


\zlbr_win_grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Tworzy i zwraca okno grupowe do zarządzania brygadami i ich składowymi
::   WE: [_a] - czy okno selekcji (z akcją wybierz): [0] - nie, 1 - tak
::   WY: utworzone okno grupowe
::----------------------------------------------------------------------------------------------------------------------
exec('__KAL','object');

ZLBR.clear();
ZLBR.index('KOD');
R_WZCZ.index('R_WZWND');

_czy_sel:={? var_press('_a')=type_of(0) || _a || 0 ?};
VAR_DEL.delete('__wer');
__wer:={? _czy_sel || 'SEL_PRJ' || 'WER_PRJ'?};
_grp:=ZLBR.grp_make('Brygady'@,,'zlbr_sel',,,,,'html_maximized');
ZLBR.grp_sel(_grp,,__wer,,"exec('zlb_aref','!zws_par_tbrg')",,,15,,,,,'maximized');
ZLBR.grp_splt(_grp,,'horizontal','zlbs');
ZLBR.grp_sel(_grp,ZLBS,'WER_PRJ','Skład brygady'@,,,,,"
   {? grp_empty(ZLBR,__wer)
   || '#disable'
   || _grayed:={? ZLBR.AKT='T' & exec('blk_lock','#table','ZLBR',ZLBR.ref()) || '' || 'DpuG:DG' ?};
      ZLBS.actions_grayed('WER_PRJ',_grayed);
      ~~
   ?}
   ","exec('blk_unlock','#table','ZLBR',ZLBR.ref())",,,'maximized'
);

ZLBR.grp_sel(_grp,R_WZCZ,'ZAS','Wzorce czasu pracy'@,,,,,"
   {? grp_empty(ZLBR,__wer)
   || '#disable'
   || R_WZCZ.prefix(ZLBR.name(),ZLBR.ref(),'N','N');
      {? ~R_WZCZ.size()
      || exec('dod_kal_czesc','kaledit',ZLBR)
      ?};
      R_WZCZ.win_edit('KAL');
      {? _a
      || exec('r_wzcz_fld_fml','kaledit',ZLBR);
         __KAL.set_cal(ZLBR.KAL)
      ?};
      ~~
   ?}
   ","exec('r_wzcz_fld_fml','kaledit')",,,'maximized'
);
ZLBR.win_edit('RED_PRJ');
ZLBR.win_patt('WZO_PRJ');
ZLBS.win_edit('RED_PRJ');
ZLBS.win_patt('WZO_PRJ');
_grp


\rem_kato_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Wyświetla listę opiekunów kategorii zasobu - bez akcji redakcyjnych
::   WE: _a - REM_KAT.ref()
::----------------------------------------------------------------------------------------------------------------------
_rem_kat:=_a;

REM_KATO.cntx_psh();

_wer:=REM_KATO.mk_sel('Opiekunowie kategorii zasobów'@,,,,,,,,,,,,,'normal');
REM_KATO.win_fld(_wer,,'USERS','KOD');
REM_KATO.win_fld(_wer,,'USERS','DANE');
REM_KATO.win_sel(_wer);

REM_KATO.index('REM_KAT');
REM_KATO.prefix(_rem_kat);

REM_KATO.select();

REM_KATO.cntx_pop();
~~


\rem_czyu_status
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Sprawdza status wykonania czynności remontowych dla danego zgłoszenia (w jakim stopniu zostały wykonane)
::   WE: _a - REM_ZGL.ref() - zgłoszenie remontowe
::   WY: status wykonania czynności: -1: brak zdefiniowanych czynności
::                                    0: żadna z czynności nie jest oznaczona jako wykonana
::                                    1: czynności częściowo wykonane
::                                    2: wszystkie czynności wykonane
::----------------------------------------------------------------------------------------------------------------------
_res:=-1;
_rem_zgl:={? var_pres('_a')=type_of(null()) || _a || null() ?};
REM_ZGL.cntx_psh();
REM_ZGL.prefix();
{? REM_ZGL.seek(_rem_zgl)
|| REM_CZYU.cntx_psh();
   REM_CZYU.index('REM_ZGL');
   REM_CZYU.prefix(REM_ZGL.ref());
   {? REM_CZYU.first()
   ||  _il_all:=REM_CZYU.size();
      REM_CZYU.prefix(REM_ZGL.ref(),'T');
      _il_wyk:=REM_CZYU.size();
      {? _il_all=_il_wyk
      || _res:=2
      |? _il_wyk>0
      || _res:=1
      || _res:=0
      ?}
   ?};
   REM_CZYU.cntx_pop()
?};
REM_ZGL.cntx_pop();
_res

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:36 1c9848acff50af88602ba56a941411621ba1a8b837c2e6669f799711c8132c15c3ebfeb31dd7a16a5254fbe4f9f7692c5f6e55e38cb0df0ec1590888fa072b05072b7c55731ea4fe75dea7bd6fd6987e2a3affacd0d89f9ae922159e33e1fccd4462c67d6f66e6cff5ac1c68e339ef250a864f30df382e136f75ac1cbe951217
