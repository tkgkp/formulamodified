:!UTF-8
::(c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: daty.fml [12.10]
:: Utworzony: 2011/07/01
:: Autor: jerry
::======================================================================================================================
:: Zawartość: Formuły do obsługi tabel DATY i DATYW
::======================================================================================================================


\WeekNumber
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Zwraca numer tygodnia dla podanej daty
::   WE: _a - data
::   WY: NUMBER - numer tygodnia (lub zero gdy blad)
::----------------------------------------------------------------------------------------------------------------------
_dt:={? _>0 & type_of(_a)=type_of(date()) || _a || return(0) ?};
:: przenosimy sie w dacie na poniedzialek
_dt:=_dt-(_dt~4)+4;
:: teraz ustalamy czwarty stycznia wg roku z powyzszego poniedzialku
_jan4:=date(_dt~1,1,4);
:: teraz skorygujemy, kiedy wypadal poniedzialek w tygodniu z 4 stycznia
_jan4:=_jan4-(_jan4~4)+4;
1+floor(1.0*(_dt-_jan4)/7)


\DATY_gen
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Generuje zapisy w DATY
::   WE: _a - data poczatkowa (domyslnie dzisiejsza)
::       _b - data koncowa    (domyslnie dzisiejsza)
::       _c - nadpisuj (1)    (domyslnie 0 - nie nadpisuje)
::   WY: 1 - ok, -<nr_bledu>
::               -1 - data poczatkowa jest wczesniejsza niz 1971/01/01
::----------------------------------------------------------------------------------------------------------------------
_dt_od:={? _>0 & type_of(_a)=type_of(date()) || _a || date() ?};
_dt_do:={? _>1 & type_of(_b)=type_of(date()) || _b || _dt_od ?};
_overw:={? _>2 & type_of(_c)=type_of(1)      || _c || 0      ?};
:: teraz sprawdzamy zakresy, jezeli bledne, to zamieniamy
{? _dt_od>_dt_do || _dt_od==_dt_do ?};
{? _dt_od<date(1971,1,1) || return(-1) ?};
_result:=1;
_numofdays:=_dt_do-_dt_od+1;
DATY.cntx_psh();
DATY.index('DATA');
DATY.prefix();
_data:=_dt_od-1;

{! .._numofdays
|! _data:=_data+1;
   _found:={? DATY.find_key(_data) || 1 || DATY.blank();0 ?};
   {? ~_found
    | _overw=1
   || DATY.DATA:=_data;
::    podstawowe konwersje
      DATY.ROK:=DATY.DATA~1;
      DATY.MIESIAC:=DATY.DATA~2;
      DATY.TYDZIEN:=exec('WeekNumber','daty',DATY.DATA);
      DATY.DZIEN_M:=DATY.DATA~3;
      DATY.DZIEN_T:=DATY.DATA~4;
      DATY.DZIEN_E:=#DATY.DATA;
      DATY.DZIEN_R:=#DATY.DATA-#date(DATY.ROK,1,1)+1;
::    teraz to co mozemy uzyskac z powyzszych danych
      DATY.POLROCZE:={? DATY.MIESIAC<7 || 1 || 2 ?};
      DATY.KWARTAL:=int((DATY.MIESIAC-1)/3)+1;
      DATY.ROK_T:=(DATY.DATA-DATY.DZIEN_T+4)~1;

      DATY.STAMP_S:=tm_stamp(DATY.ROK,DATY.MIESIAC,DATY.DZIEN_M, 0,0,0);
      _dt1:=date(DATY.ROK,DATY.MIESIAC,DATY.DZIEN_M)+1;
      DATY.STAMP_E:=tm_stamp(_dt1~1,_dt1~2,_dt1~3, 0,0,0);

      {? _found || DATY.put() || DATY.add() ?};
      ~~
   ?}
!};
DATY.cntx_pop();
_result


\DATYW_gen
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Generuje zapisy w DATY
::   WE: _a - rok poczatkowy
::       _b - rok koncowy
::   WY: 1 - ok, -<nr_bledu>
::----------------------------------------------------------------------------------------------------------------------
_rok_od:={? _>0 & type_of(_a)=type_of(1) || _a || date()~1 ?};
_rok_do:={? _>1 & type_of(_b)=type_of(1) || _b || _rok_od  ?};
{? _rok_od>_rok_do || _rok_od==_rok_do ?};
{? _rok_od<1971 || return(-1) ?};
:: daty na pewno juz sa... wiec do dziela
_result:=1;
DATY.cntx_psh();
DATY.index('RMD');
{! _rok:=_rok_od.._rok_do
|! echo('Generowanie tabeli dat. Proszę czekać...'@,form(_rok,,,'99'));
:: najpierw dogenerowanie DATY, jezeli jest taka potrzeba - bez nadpisywania
   exec('DATY_gen','daty',date(_rok,1,1),date(_rok,12,31));
:: teraz dodajemy dla kazdego <jezyk>_<LOKALIZACJA>
:: polski_POLSKA
   exec('DATYW_loc_pl_PL','daty',_rok);
:: angielski_POLSKA
:: exec('DATYW_loc_en_PL','daty',_rok);
:: niemiecki_POLSKA
:: exec('DATYW_loc_de_PL','daty',_rok);
:: rosyjski_POLSKA
:: exec('DATYW_loc_ru_PL','daty',_rok);
:: czeski_POLSKA
:: exec('DATYW_loc_cz_PL','daty',_rok);
   ~~
!};
DATY.cntx_pop();
echo();
_result


\DATYW_loc_pl_PL
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: nanosi swieta/dni wolne dla danego roku - praca na aktualnym prefiksie DATY (rok)
::   WE: _rok - numer roku
::----------------------------------------------------------------------------------------------------------------------
_rok:={? _>0 & type_of(_a)=type_of(1) || _a || date()~1 ?};
DATY.cntx_psh();
DATY.prefix(_rok);
:: mamy ustalony roczek..., wiec ustalamy swieta
{? DATY.first()
|| DATYW.blank();
   _datyw:="
      DATYW.LOCAL:='pl_PL';
      DATYW.DATY:=_a;
      DATYW.KIND:=_b;
      DATYW.OPIS:=_c;
      DATYW.add(1)
      ";

:: najpierw swieta stale
   {? DATY.find_key( 1, 1) || _datyw(DATY.ref(),'S','Nowy Rok')  ?};
   {? DATY.find_key( 1, 6) || _datyw(DATY.ref(),'S','Święto Trzech Króli')  ?};
:: teraz wyznaczymy wielkanoc i powiazane
   _Wielk1:=exec('wielkan','kalendarz',_rok);
   _Wielk2:=_Wielk1+1;
   _CorpCh:=_Wielk1+60;
   _data:=_Wielk1; {? DATY.find_key(_data~2,_data~3) || _datyw(DATY.ref(),'S','Wielkanoc')  ?};
   _data:=_Wielk2; {? DATY.find_key(_data~2,_data~3) || _datyw(DATY.ref(),'S','Wielkanoc (drugi dzień)')  ?};

   {? DATY.find_key( 5, 1) || _datyw(DATY.ref(),'S','Święto pracy')  ?};
   {? DATY.find_key( 5, 3) || _datyw(DATY.ref(),'S','Konstytucji 3 Maja')  ?};
   _data:=_CorpCh; {? DATY.find_key(_data~2,_data~3) || _datyw(DATY.ref(),'S','Boże Ciało')  ?};
   {? DATY.find_key( 8,15) || _datyw(DATY.ref(),'S','Wniebowzięcie N.M.P.')  ?};
   {? DATY.find_key(11, 1) || _datyw(DATY.ref(),'S','Wszystkich Świętych')  ?};
   {? DATY.find_key(11,11) || _datyw(DATY.ref(),'S','Święto Niepodległości')  ?};

   {? DATY.find_key(12,25) || _datyw(DATY.ref(),'S','Boże Narodzenie')  ?};
   {? DATY.find_key(12,26) || _datyw(DATY.ref(),'S','Boże Narodzenie (drugi dzień)')  ?};

   ~~
:: dodac obsluge bledu gdy rzeczywiscie nie ma roku
|| _result:=-1
?};
DATY.cntx_pop();
~~


\nowedane_DATY
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: nowe dane - generowanie dla aktualnego roku +20 lat (w wersji demo +5 lat) ale nie więcej niż 2038
::   WE: --
::   WY: --
::----------------------------------------------------------------------------------------------------------------------
_rok_b:=date()~1;

_rok_e:=_rok_b+{? exec('demo','libfml') || 4 || 20 ?};
{? _rok_e>2037
|| _rok_e:=2037
?};

DATY.cntx_psh();
DATY.index('DMR');
DATY.prefix(1,1);
{? DATY.last() || _rok_b:=DATY.ROK+1 ?};
DATY.clear();
{? _rok_b<=_rok_e
|| exec('DATYW_gen','daty',_rok_b,_rok_e)
?};
DATY.cntx_pop();
~~


\to_string
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca tekstowa reprezentacje rekordu DATY, na podstawie przedstawionego poziomu
::       KONTEKST PRACY - rekord tabeli DATY
::   WE: _a - STRING - poziom z ktorego zrobic string:   'R' - rok
::                                                       'P' - polrocze
::                                                       'K' - kwartal
::                                                       'M' - miesiac
::                                                       'T' - tydzien
::                                                       'D' - dzien
::       [_b] - INTEGER - tryb generowania opisu
::                         1 - normalny
::                         2 - bardzo krotki
::                         3 - bardzo dlugi
::   WY: STRING - tekstowa reprezentacja rekordu
::----------------------------------------------------------------------------------------------------------------------
_level:=_a;

_mode:=1;

{? var_pres('_b')=type_of(0)
|| _mode:=_b
?};

_result:='';

{? _mode=1
|| {? _level='R'
   || _result:=$DATY.ROK
   |? _level='P'
   || _result:=$DATY.ROK+'/pół.'+$DATY.POLROCZE
   |? _level='K'
   || _result:=$DATY.ROK+'/kw.'+$DATY.KWARTAL
   |? _level='M'
   || _result:=DATY.DATA$8
   |? _level='T'
   || {? DATY.TYDZIEN=1 & DATY.POLROCZE=2
      ||
::       Jakiś chory przypadek który wystąpił na przełomie roku 2018 i 2019. 1 Tydzień zaczynał się w poprzednim roku
::       więc etykieta miała zły rok bo poprzedni
         _result:='Tydzień '+$DATY.TYDZIEN+' ('+$(DATY.ROK+1)+')'
      || _result:='Tydzień '+$DATY.TYDZIEN+' ('+$DATY.ROK+')'
      ?}
   |? _level='D'
   || _result:=$DATY.DATA
   ?}
|? _mode=2
||
   {? _level='R'
   || _result:=$DATY.ROK+2
   |? _level='P'
   || _result:=($DATY.ROK+2)+'/p'+$DATY.POLROCZE
   |? _level='K'
   || _result:=($DATY.ROK+2)+'/k.'+$DATY.KWARTAL
   |? _level='M'
   || _result:=form(DATY.MIESIAC,-2)+'/'+($DATY.ROK+2)
   |? _level='T'
   || _result:='T.'+$DATY.TYDZIEN
   |? _level='D'
   || _result:=$DATY.DATA+5
   ?}
|? _mode=3
|| _result:=$DATY.DATA+' Tydzień '+$DATY.TYDZIEN
?};
_result


\find_next
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Ustawia sie na nastepnym rekordzie tabeli dat o jeden wiekszym w wartosci na wymaganym poziomie
::       UWAGA! - modyfikuje kontekst tabeli DATY
::   WE: _a - STRING - poziom ktorego uzywac do skoku:   'R' - rok
::                                                       'P' - polrocze
::                                                       'K' - kwartal
::                                                       'M' - miesiac
::                                                       'T' - tydzien
::                                                       'D' - dzien
::       [_b] - INTEGER - kierunek poruszania sie: 1 - do przodu
::                                                -1 - wtecz
::   WY: 0 - nie znalazl sie rekord spelniajacy wymagania
::       1 - tabela dat przeskoczyla na kolejny rekordzik
::----------------------------------------------------------------------------------------------------------------------
_level:=_a;
_dir:=1;
{? var_pres('_b')=type_of(0)
|| _dir:=_b
?};

_result:=0;

_curr_ndx:=DATY.index('?');

{? _level='R'
|| DATY.index('RMD');
   _rok:=DATY.ROK+_dir;
   DATY.prefix(_rok);
   _result:=DATY.first()
|? _level='P'
|| DATY.index('ROKPOL');
   _rok:=DATY.ROK;
   _polrok:=DATY.POLROCZE+_dir;
   {? _polrok>2
   || _rok+=1;
      _polrok:=1
   |? _polrok<1
   || _rok-=1;
      _polrok:=2
   ?};
   DATY.prefix(_rok,_polrok);
   _result:=DATY.first()
|? _level='K'
|| DATY.index('ROKKWA');
   _rok:=DATY.ROK;
   _kwartal:=DATY.KWARTAL+_dir;
   {? _kwartal>4
   || _rok+=1;
      _kwartal:=1
   |? _kwartal<1
   || _rok-=1;
      _kwartal:=4
   ?};
   DATY.prefix(_rok,_kwartal);
   _result:=DATY.first()
|? _level='M'
|| DATY.index('ROKMIE');
   _rok:=DATY.ROK;
   _miesiac:=DATY.MIESIAC+_dir;
   {? _miesiac>12
   || _rok+=1;
      _miesiac:=1
   |? _miesiac<1
   || _rok-=1;
      _miesiac:=12
   ?};
   DATY.prefix(_rok,_miesiac);
   _result:=DATY.first()
|? _level='T'
||
   _rok:=DATY.ROK;
   _tydzien:=DATY.TYDZIEN+_dir;
   _polrok:=DATY.POLROCZE;

:: Specjalna obsluga lat ktore maja 53 tygodnie
   {? _tydzien>=52 & _polrok=2
   ||
      DATY.index('RPTDT');
::    Sprawdzam czy w danym roku (czyli jego 2. polroczu) wystepuje 53 tydzien
      DATY.prefix(_rok,_polrok,_tydzien);
      {? DATY.first()
      || _result:=1
      ||
::       Brak 53. tygodnia, wiec sprawdzam, czy jest 1. tydzien w 2. polroczu tego roku
         _tydzien:=1;
         DATY.prefix(_rok,_polrok,_tydzien);
         {? DATY.first()
         || _result:=1
         ||
::          Brak 53. tygodnia i nie ma 1. tygodnia w 2. polroczu tego roku, wiec przeskakuje o rok.
::          Jezeli jestem w pierwszym polroczu to znaczy ze np 1 styczen 2012 jest w 52 tygodniu
::          i przeskok o rok spowodowalby ze ominalbym caly rok 2012 i stanal na 2013
            _polrok:=1;
            _rok+=1;
            DATY.prefix(_rok,_polrok,_tydzien);
            _result:=DATY.first()
         ?}
      ?}
   |? _tydzien>53 & _polrok=1 | (_tydzien>=52 & _dir=0 & _polrok=1)
   ||
::    Jakiś chory przypadek który wystąpił w roku 2016. 1 stycznia należał do 53 tygodnia roku 2015 i przejście na
::    kolejny tydzień czyli 54 roku 2016 się oczywiście nie udawał
      _tydzien:=1;
      DATY.index('RPTDT');
      DATY.prefix(_rok,_polrok,_tydzien);
      _result:=DATY.first()
   |? _tydzien<1 & _polrok=1
   ||
      DATY.index('RPTDT');
      _rok-=1;
      _polrok:=2;
::    Sprawdzam czy w poprzednim roku wystepuje 53 tydzien
      DATY.prefix(_rok,_polrok,53);
      {? DATY.first()
      || _result:=1
      ||
::       Brak 53 tygodnia wiec ustawiam sie na 52
         _tydzien:=52;
         DATY.prefix(_rok,_polrok,_tydzien);
        _result:=DATY.first()
      ?}
   |? _tydzien=2 & _polrok=2
   ||
::    Jakiś chory przypadek który wystąpił na przełomie roku 2018 i 2019. 1 Tydzień zaczynał się w poprzednim roku
::    więc na drugim tygodniu następował przeskok na początek 2018 roku i się zapętlało
      _polrok:=1;
      _rok+=1;
      DATY.index('RPTDT');
      DATY.prefix(_rok,_polrok,_tydzien);
      _result:=DATY.first()
   || DATY.index('RTDT');
      DATY.prefix(_rok,_tydzien);
      _result:=DATY.first()
   ?}
|? _level='D'
|| DATY.index('DATA');
   _data:=DATY.DATA+_dir;
   DATY.prefix(_data);
   _result:=DATY.first()
?};

DATY.index(_curr_ndx);
DATY.clear();
_result


\create_interval
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Na podstawie dwóch rekordow z tabeli DATY tworzy interwal czasowy
::   WE: _a - DATY.ref() - rekord startowy
::       _b - DATY.ref() - rekord koncowy
::       [c] - REAL - przesuniecie czasowe dodawane do poczatku i konca interwalu
::   WY: obj_new - tablica nazwana o dwoch polach START i END - wynik exec('interval','#interval')
::----------------------------------------------------------------------------------------------------------------------
_dt_start:=_a;
_dt_end:=_b;

_offset:=0;
{? var_pres('_c')=type_of(0)
|| _offset:=_c
?};

_result:=exec('interval','#interval');

DATY.cntx_psh(); DATY.clear();
{? DATY.seek(_dt_start)
|| _result.START:=DATY.STAMP_S+_offset
?};
{? DATY.seek(_dt_end)
|| _result.END:=DATY.STAMP_S+_offset
?};
DATY.cntx_pop();
_result


\round_start
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Ustawia sie na pierwszym rekordzie DATY ktory dotyczy podanego poziomu na podstawie przekazanego
::       poziomu. Np jezeli w _a bedzie 2013/05/15 a w _b='M' to funkcja zwroci pierwszy dzien miesiaca czyli
::       2013/05/01
::   WE: _a - DATY.ref() - rekord ktory zaokraglic
::       _b - STRING - poziom do ktorego zaokraglic:  'R' - rok
::                                                    'P' - polrocze
::                                                    'K' - kwartal
::                                                    'M' - miesiac
::                                                    'T' - tydzien
::                                                    'D' - dzien
::   WY: DATY.ref() - zaokraglony refik
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;
_level:=_b;

_result:=null();

DATY.cntx_psh();
DATY.clear();
{? DATY.seek(_ref)
||
   {? exec('find_next','daty',_level,0)>0
   || _result:=DATY.ref()
   ?}
?};
DATY.cntx_pop();
_result


\get
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca DATY.ref() dla podanej daty
::   WE: _a - DATE - date()
::       [_b] - FORMULA/STRING - formuła do wykonania dla znalezionej daty
::       [_c] - ANY - wartość domyślna gdy nie znaleziono DATY
::   WY: DATY.ref()/null()
::       wynik "_b" lub _c
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::  OLD: \get/kalendarz.fml
::----------------------------------------------------------------------------------------------------------------------
_data:=_a;
{? _=1
|| _formula:="DATY.ref()"; _result:=null()

|? _=3
|| _formula:=$(''+_b);     _result:=_c

|| return(~~)
?};
DATY.cntx_psh();
DATY.index('DATA');
DATY.prefix(_data);
{? DATY.first() || _result:=_formula() ?};
DATY.cntx_pop();
_result


\startd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca pierwsza date
::   WY: DATE
::  OLD: \startd/kalendarz.fml
::----------------------------------------------------------------------------------------------------------------------
DATY.cntx_psh();
DATY.index('DATA');
{? DATY.first()
|| _startd:=DATY.DATA
|| _startd:=date()
?};
DATY.cntx_pop();
_startd


\wybierz_rok_miesiac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
:: OPIS: Formuła do wybierania roku i miesiąca. Bazuje na tabeli DATY. W razie braku danych w tabeli DATY, automatycznie
::       generuje w niej zapisy.
::   WE: [_a] - rok domyślny
::       [_b] - miesiąc domyślny
::   WY: obiekt z polami 'R' - (rok) oraz 'M' - (miesiąc)
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) & _a<>0 || _rok:=_a || _rok:=date()~1 ?};
{? var_pres('_b')=type_of(0) & _b<>0 || _miesiac:=_b || _miesiac:=date()~2 ?};

_result:=obj_new('R','M');
_result.R:=0;
_result.M:=0;

exec('nowedane_DATY','daty');

_sql:='select distinct ROK, MIESIAC from DATY';
_tab:=sql(_sql);

_tab.cntx_psh();
_ndx:=_tab.ndx_tmp('',1,'ROK',,0, 'MIESIAC',,0);
_tab.index(_ndx);

_wer:=_tab.mk_sel('Wybór roku i miesiąca'@,,0,'select_rok_mies',,,13,,'U','U',1);
_tab.win_fld(_wer,,'ROK',,,10,,,'Rok'@);
_tab.win_fld(_wer,,'MIESIAC',,,6,,,'Miesiąc'@);
_tab.win_act(_wer,,'Formuła','Wybierz'@@,,,"sel_exit()",,1,0,,,'W');
_tab.win_btn(_wer,'text=%1,panel=right'['Wybierz'@],'menu:W');
_tab.win_sel(_wer);

_tab.find_le(_rok,_miesiac);
{? _tab.select(,1,5)
|| _result.R:=_tab.ROK;
   _result.M:=_tab.MIESIAC
?};
_tab.cntx_pop();
_tab.ndx_drop(_ndx);

_result

:Sign Version 2.0 jowisz:1045 2020/04/03 17:16:35 e4b13ec4e4c0fc01849401f87289d9a1e82ba1df527a353c3c5a5fb23dba4c0c5f888fbd6cab71764fa3092b4d0bb140489218847078ba50ce82767dc9b326af130158443fa5c9cee4448d3dc73b21242ff2dada406bdf4c7822831a8fb7dbeab52bd507516041d6322c63e67f8e2c2719803ee581c229cb4d27213fdabb8b85
