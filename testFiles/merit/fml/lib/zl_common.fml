:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: zl_common.fml
:: Utworzony: 22.06.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły do obsługi wspólnych elementów na zleceniu
::            Plik biblioteczny - wspólna obsługa dla czynności obszaru roboczego TTE_PZL
::======================================================================================================================


\env_other
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca zmienną środowiskową do obsługi danych dodatkowych zlecenia
::----------------------------------------------------------------------------------------------------------------------
_env:=obj_new('used');
_env.used:=0;
_env


\ustmwyd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Ustala domyślny magazyn wydziałowy
::   WE: _a - kod oddziału
::       _b - ref wydziału - SLO.ref()
::       _c - kontekst wywołania: zapotrzebowanie (surowiec nielimitowany) - 1, zlecenie - 0
::       [_d] - czy sprawdzać magazyn przypisany do źródłowego surowca technologii: [0] - Nie, 1 - tak
::              Działa wyłącznie, gdy _c=1. Działa na bieżącym buforze tabeli ZLIM
::   WY: MG.ref()
::  OLD: \ustmwyd/polap.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=null();
_oddzial:=_a;
_wyd:=_b;
_context:=_c;
_spr_tmat:={? var_pres('_d')=type_of(0) || _d || 0 ?};

_res:=null();

:: Obsługa tylko dla zapotrzebowania (surowiec nielimitowany)
:: Sprawdzenie magazynu przypisanego do źródłowego surowca technologii
{? _context || _res:=Plugin.run('ZLIM_MG_NLIM_001',_oddzial,_wyd) ?};

:: Obsługa tylko dla zapotrzebowania (surowiec nielimitowany)
:: Gdy wtyczka nie zwróciła magazynu, a został podany TMAT, to magazyn z niego pobierany (jeżeli zgodny oddział)
{? _context & _spr_tmat>0 & (type_of(_res)=0 | _res=null())
|| _mag:=exec('FindAndGet','#table',TMAT,ZLIM.TMAT,,"TMAT.MG",null());
   {? exec('FindAndGet','#table',MG,_mag,,"MG.ODDZ",'')=_oddzial
   || _res:=_mag
   ?}
?};

{? type_of(_res)=0 | _res=null()
||
   _sym:=exec('get','#params',500006,2);

   {? _wyd<>null()
   || MG.index('WYD');
      MG.prefix(_wyd);
      {? MG.first() & MG.ODDZ=_oddzial
      || {? _sym<>''
         || {!
            |? {? (_sym*(','+MG.SYM)>0 | _sym*(MG.SYM+' ,')>0 | _sym*(MG.SYM+',')>0 | _sym=MG.SYM) & _wyd=MG.WYD
               || _res:=MG.ref();
                  0
               || MG.next()
               ?}
            !}
         || {? MG.size()=1
            || _res:=MG.ref()
            ?}
         ?}
      ?}
   ?}
?};

_res


\ustmag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Ustala domyślny magazyn surowców, półproduktow dla wskazanego materiału
::   WE: [_a] - kod oddziału
::       _b - M.ref() - nie jest sprawdzana obecność ani typ parametru
::       [_c] - czy sprawdzać magazyn przypisany do źródłowego surowca technologii: [0] - Nie, 1 - tak
::              Działa na bieżącym buforze tabeli ZLIM
::   WY: MG.ref()
::  OLD: \ustmag/polap.fml
::----------------------------------------------------------------------------------------------------------------------
_oddzial:={? var_pres('_a')=type_of('') || _a || '' ?};
_material:=_b;
_spr_tmat:={? var_pres('_c')=type_of(0) || _c || 0 ?};

:: opcja: "D"omyślne, wg M"X", wg M"S"T
_opcja:=exec('get','#params',500014,2);

:: Jeżeli wtyczka zwróci niepuste złączenie, to ma większą moc niż standardowa obsługa
_res:=Plugin.run('ZLIM_MG_LIM_001',_oddzial,_material);

:: Sprawdzenie magazynu przypisanego do źródłowego surowca technologii
{? _spr_tmat>0 & (type_of(_res)=0 | _res=null())
|| _mag:=exec('FindAndGet','#table',TMAT,ZLIM.TMAT,,"TMAT.MG",null());
   {? exec('FindAndGet','#table',MG,_mag,,"MG.ODDZ",'')=_oddzial
   || _res:=_mag
   ?}
?};

{? type_of(_res)=0 | _res=null()
||
:: lista magazynów uwzględnianych podczas wyliczania stanu dostępnych surowców
   _magazyny:=exec('get','#params',500002,2);

:: Wariant domyślny ustalany zawsze
   _res:=null();
   M.cntx_psh();
   M.prefix();
   {? M.seek(_material)
   || {? M.R='S'
      || _sym:=exec('get','#params',500004,2)
      || _sym:=exec('get','#params',500005,2)
      ?};
      {? _oddzial=''
      || MG.index('MAGAZYNY');
         MG.prefix(_sym,);
         {? MG.first()
         || _res:=MG.ref()
         ?}
      || MG.index('MAG');
         MG.prefix(_oddzial,_sym,);
         {? MG.first()
         || _res:=MG.ref()
         ?}
      ?}
   ?};
   M.cntx_pop();

:: Według kartoteki MX
   _can_continue:=1;
   {? _opcja='X'
   || MX.cntx_psh();
      MX.index('M');
      MX.prefix(_material);
      {? MX.first()
      || {!
         |? MX.MG();
            {? MX.A='T' & MG.ODDZ=_oddzial & (_magazyny*(','+MG.SYM)>0 | _magazyny*(MG.SYM+' ,')>0 | _magazyny=MG.SYM)
            || _res:=MX.MG; _can_continue:=0
            ?};
            _can_continue>0 & MX.next()
         !}
      ?};
      MX.cntx_pop()

:: Według kartoteki MST
   |? _opcja='S'
   || MST.cntx_psh();
      MST.index('MG');
      MST.prefix(_material);
      {? MST.first()
      || {!
         |? MST.MG();
            {? MG.ODDZ=_oddzial & (_magazyny*(','+MG.SYM)>0 | _magazyny*(MG.SYM+' ,')>0 | _magazyny=MG.SYM)
            || _res:=MST.MG; _can_continue:=0
            ?};
            _can_continue>0 & MST.next()
         !}
      ?};
      MST.cntx_pop()
   ?}
?};

_res


\ustmodp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Ustala domyślny magazyn odpadów
::   WE: _a - oddział
::       _b - M.ref() - używany tylko jako parametr wtyczki
::       [_c] - czy sprawdzać magazyn przypisany do źródłowego surowca technologii: [0] - Nie, 1 - Tak
::              Działa na bieżącym buforze tabeli ZLIM
::   WY: MG.ref()
::----------------------------------------------------------------------------------------------------------------------
_oddzial:=_a;
_material:=_b;
_spr_tmat:={? var_pres('_c')=type_of(0) || _c || 0 ?};

:: Jeżeli wtyczka zwróci niepuste złączenie, to ma większą moc niż standardowa obsługa
_res:=Plugin.run('ZLIM_MG_ODP_001',_oddzial,_material);

:: Sprawdzenie magazynu przypisanego do źródłowego surowca technologii
{? _spr_tmat>0 & (type_of(_res)=0 | _res=null())
|| _mag:=exec('FindAndGet','#table',TMAT,ZLIM.TMAT,,"TMAT.MG",null());
   {? exec('FindAndGet','#table',MG,_mag,,"MG.ODDZ",'')=_oddzial
   || _res:=_mag
   ?}
?};

{? type_of(_res)=0 | _res=null()
|| _sym:=exec('get','#params',500017,2);
   _res:=null();
   MG.cntx_psh();
   MG.index('MAG');
   MG.prefix(_oddzial,_sym,);
   {? MG.first()
   || _res:=MG.ref()
   ?};
   MG.cntx_pop()
?};
_res


::----------------------------------------------------------------------------------------------------------------------
:: Obsługa blokad zlecenia
::----------------------------------------------------------------------------------------------------------------------


\zl_lock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS
:: OPIS: Blokada rekordu zlecenia ( ZL.r_lock(1,1,1) )
::   WE: [_a] - #ZL.ref(), a jak brak parametru, to ustawiony rekord w tabali ZL
::       [_b] - akcja dla której ustawiona jest blokada: 'N'agłówek, 'T'echnologia, 'P'rzewodniki,
::              'L'imity (zapotrzebowania), 'I'nne (pozostałe) dane, 'R' - paRtie, 'B' - operacje naprawcze do braków,
::              'K'alkulacja, 'A'naliza
::       [_c] - czy nie wyświetlać dialogów (domyślnie 0 - wyświetlać)
::   WY: 0 / 1
::  OLD: \zl_lock/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _zl:=_a || _zl:=#ZL.ref() ?};
{? var_pres('_a')=type_of(ZL.ref()) || _zl:=#_a ?};
{? var_pres('_b')=type_of('') || _action:=_b || _action:='N' ?};
{? var_pres('_c')=type_of(0) || _no_display:=_c || _no_display:=0 ?};

_info:='';
{? ~_no_display
|| {? _action='T'
   || _info:='Technologia zlecenia jest redagowana'@
   |? _action='P'
   || _info:='Przewodniki zlecenia są redagowane'@
   |? _action='L'
   || _info:='Zapotrzebowania do zlecenia są redagowane'@
   |? _action='I'
   || _info:='Pozostałe dane zlecenia są redagowane'@
   |? _action='R'
   || _info:='Partie zlecenia są redagowane'@
   |? _action='B'
   || _info:='Operacje naprawcze zlecenia są redagowane'@
   |? _action='K'
   || _info:='Kalkulacje zlecenia są redagowane'@
   |? _action='A'
   || _info:='Analizy zlecenia są redagowane'@
   || _info:='Zlecenie jest redagowane'@
   ?}
?};

_ok:=exec('blk_lock','#table','ZL#'+_action,ZL.name(),_zl,1,_info);
_ok


\zl_lock_sesid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca identyfikator sesji blokującej rekord zlecenia
::   WE: [_a] - #ZL.ref(), a jak brak parametru, to ustawiony rekord w tabali ZL
::       [_b] - akcja dla której ustawiona jest blokada: 'N'agłówek, 'T'echnologia, 'P'rzewodniki,
::              'L'imity (zapotrzebowania), 'I'nne (pozostałe) dane, 'R' - paRtie, 'B' - operacje naprawcze do braków,
::              'K'alkulacja, 'A'naliza
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _zl:=_a || _zl:=#ZL.ref() ?};
{? var_pres('_a')=type_of(ZL.ref()) || _zl:=#_a ?};
{? var_pres('_b')=type_of('') || _action:=_b || _action:='N' ?};

_sesid:=exec('blk_lock','#table','ZL#'+_action,ZL.name(),_zl,2);
_sesid


\zl_unlock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS
:: OPIS: Usunięcie blokady rekordu zlecenia ( ZL.r_unlock() )
::   WE: [_a] - #ZL.ref(), a jak brak parametru, to ustawiony rekord w tabali ZL
::       [_b] - akcja dla której ustawiona jest blokada: 'N'agłówek, 'T'echnologia, 'P'rzewodniki,
::              'L'imity (zapotrzebowania), 'I'nne (pozostałe) dane, 'R' - paRtie, 'B' - operacje naprawcze do braków,
::              'K'alkulacja, 'A'naliza
::   WY: ~~
::  OLD: \zl_unlock/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _zl:=_a || _zl:=#ZL.ref() ?};
{? var_pres('_a')=type_of(ZL.ref()) || _zl:=#_a ?};
{? var_pres('_b')=type_of('') || _action:=_b || _action:='N' ?};

exec('blk_unlock','#table','ZL#'+_action,ZL.name(),_zl);
~~


\zl_lockfamily
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS
:: OPIS: blokada rodziny dla zlecenia
::       Kontekst: ustawiony rekord w tabeli ZL
::   WE: [_a] - #ZL.ref(), a jak brak parametru, to ustawiony rekord w tabali ZL
::       [_b] - akcja dla której ustawiona jest blokada: 'N'agłówek, 'T'echnologia, 'P'rzewodniki,
::              'L'imity (zapotrzebowania), 'I'nne (pozostałe) dane
::       [_c] - blokować całe zlecenie złożone (domyślnie - 1), czy tylko zlecenia podrzędne do danego (0)
::       [_d] - tab_tmp - tabelka tymczasowa do której odkładać zablokowane rekordy
::   WY: obj_new - wynik działania
::  OLD: \zl_lockfamily/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _zl:=_a || _zl:=#ZL.ref() ?};
{? var_pres('_a')=type_of(ZL.ref()) || _zl:=#_a ?};
{? var_pres('_b')=type_of('') || _action:=_b || _action:='N' ?};
{? var_pres('_c')=type_of(0) || _all:=_c || _all:=1 ?};
_tab:=1;
{? var_pres('_d')>100
|| _tab:=_d
|| _tab:=exec('zl_lock_tab','zl_common')
?};
_locked:=1;
_result:=obj_new('LOCKED','TAB');
_result.LOCKED:=1;
_result.TAB:=_tab;

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl,)
|| {? ZL.RODZAJ<>'P'
   || ZL.cntx_psh();
      ZL.clear();
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? _lockres:=exec('zl_lock','zl_common',,_action,1);
            {? _lockres>0
            || _tab.blank();
               _tab.NUM:=#ZL.ref();
               _tab.add()
            ?};
            _locked*=_lockres;
            ZL.next()
         !}
      ?};
      ZL.cntx_pop()
   |? ZL.RODZAJ='P' & ZL.NRNZL<>0 & _all
   || ZL.cntx_psh();
      ZL.clear();
      ZL.index('UNRZL');
      ZL.prefix(ZL.NRNZL);
      {? ZL.first()
      ||
         _lockres:=exec('zl_lock','zl_common',,_action,1);
         {? _lockres>0
         || _tab.blank();
            _tab.NUM:=#ZL.ref();
            _tab.add()
         ?};
         _locked*=_lockres;
         ZL.cntx_psh();
         ZL.clear();
         ZL.index('NRNZL');
         ZL.prefix(ZL.UNRZL);
         {? ZL.first()
         || {!
            |? _lockres:=exec('zl_lock','zl_common',,_action,1);
               {? _lockres>0
               ||
                  _tab.blank();
                  _tab.NUM:=#ZL.ref();
                  _tab.add()
               ?};
               _locked*=_lockres;
               ZL.next()
            !}
         ?};
        ZL.cntx_pop()
      ?};
      ZL.cntx_pop()
   |? ZL.RODZAJ='P'
   || ZL.cntx_psh();
      ZL.index('NRPZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? _lockres:=exec('zl_lock','zl_common',,_action,1);
            {? _lockres>0
            || _tab.blank();
               _tab.NUM:=#ZL.ref();
               _tab.add()
            ?};
            _locked*=_lockres;
            ZL.next()
         !}
      ?};
      ZL.cntx_pop()
   ?}
?};
ZL.cntx_pop();
_tab.clear();
_result.LOCKED:=_locked;
_result


\zl_lock_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Zwraca tabelkę tymczasową dla zl_lockfamily
::   WY: tab_tmp
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=tab_tmp(1,
   'NUM','INTEGER','Numer rekordu'
);
_result


\zl_unlockfamily
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS
:: OPIS: odblokowanie rodziny dla zlecenia
::   WE: _a - tab_tmp - tabelka z numerami zablokowanych zleceń
::       [_b] - akcja dla której ustawiona jest blokada: 'N'agłówek, 'T'echnologia, 'P'rzewodniki,
::              'L'imity (zapotrzebowania), 'I'nne (pozostałe) dane
::  OLD: \zl_unlockfamily/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
{? var_pres('_b')=type_of('') || _action:=_b || _action:='N' ?};

_tab.clear();
{? _tab.first()
|| {!
   |? exec('zl_unlock','zl_common',_tab.NUM,_action);
      _tab.next()
   !}
?};
~~


::----------------------------------------------------------------------------------------------------------------------
:: Obsługa dziennika zlecenia
::----------------------------------------------------------------------------------------------------------------------


\add_zwar_pos
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JM [7.53]
:: OPIS: Dodaje pozycję do dziennika zlecenia
::   WE: _a - STRING[2] - rodzaj operacji
::       _b - INTEGER - 0/1 - czy redagować
::       [_c] - przyczyna - STRING
::       [_d] - ZL.ref() - zlecenie któremu dodawać, jeśli nie podane to VAR.A_ZLEC
::   WY: czy dodano rekord w dzienniku (1/0)
::  OLD: \add_zwar_pos/zl_zwar.fml
::----------------------------------------------------------------------------------------------------------------------
_ok:=0;

_kind:=_a;
_edit:=_b;

_cause:='';
{? var_pres('_c')=type_of('')
|| _cause:=_c
?};
_zl:=VAR.A_ZLEC;
{? var_pres('_d')=type_of(ZL.ref())
|| _zl:=_d
?};

_ok:=1;

ZWAR.win_edit('RED');
ZWAR.clear();
ZWAR.blank();
ZWAR.ZL:=_zl;
ZWAR.KIND:=_kind;
{? _cause<>''
|| ZWAR.CAUSE:=_cause
?};
{? _edit>0
|| _ok:=ZWAR.edit("__CHK.record(ZWAR,,'CAUSE')")
?};
{? _ok || _ok:=ZWAR.add(1) ?};
_ok


\add_mod_pos
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: dodaje informacje o modyfikacji do dziennika zlecenia
::   WE: _a - MO,MP,MR
::       _b - przyczyna
::       _c - godzina operacji
::  OLD: \add_mod_pos/zl_zwar.fml
::----------------------------------------------------------------------------------------------------------------------
_ok:=0;
ZWAR.cntx_psh();
ZWAR.clear();
ZWAR.blank();
ZWAR.ZL:=VAR.A_ZLEC;
ZWAR.KIND:=_a;
ZWAR.CAUSE:=_b;
{? _>2
|| ZWAR.H:=_c
?};
_ok:=ZWAR.add(1);
ZWAR.cntx_pop();
_ok


\show_zwar_pos
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JM [7.53]
:: OPIS: pokazuje pozycje dziennika dla aktualnego zlecenia
::  OLD: \show_zwar_pos/zl_zwar.fml
::----------------------------------------------------------------------------------------------------------------------
ZWAR.index('ZDG');
ZWAR.prefix(ZL.ref());
ZWAR.win_sel('SLO');
ZWAR.win_edit('RED');
ZWAR.select();
~~


\zlec_zwar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Dziennik zleceń - wywołanie całego dziennika
::  OLD: \zlec_zwar/zl_zwar.fml
::----------------------------------------------------------------------------------------------------------------------
_wp:=params_get().env.WP;

ZL.cntx_psh();
ZWAR.index('WPDGZ');
ZWAR.prefix(_wp);
ZWAR.win_sel('WER');
ZWAR.hdr_sel();
ZWAR.hdr_sel({? _wp='W' || ' '+'warsztatowych'@ || ' '+'produkcyjnych'@ ?});
_formikon:="exec('icon_stan','zl_head')";
ZWAR.win_fml('WER',,'ZL','STAN','ICON_BEFORE',_formikon,1);
ZWAR.win_edit('RED');
ZWAR.select();
ZL.cntx_pop();
~~


\brec_slo_zwar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JM [7.53]
:: OPIS: przed rekord w ZWAR.SLO
::  OLD: \brec_slo_zwar/zl_zwar.fml
::----------------------------------------------------------------------------------------------------------------------
_result:='';
VAR.STRING:=
   {? ZWAR.KIND='_n'
   || _result:='ZWAR#01#01';
      'powołanie'@
   |? ZWAR.KIND='no'
   || _result:='ZWAR#01#02';
      'akceptacja'@
   |? ZWAR.KIND='oz'
   || _result:='ZWAR#01#03';
      'zamknięcie'@
   |? ZWAR.KIND='ZO'
   || _result:='ZWAR#01#04';
      'AWARYJNE otwarcie'@
   |? ZWAR.KIND='mz'
   || _result:='ZWAR#01#05';
      'modyfikacja zlecenia'@
   |? ZWAR.KIND='mr'
   || _result:='ZWAR#01#06';
      'modyfikacja przewodnika'@
   |? ZWAR.KIND='mp'
   || _result:='ZWAR#01#07';
      'modyfikacja pozycji przewodnika'@
   |? ZWAR.KIND='on'
   || _result:='ZWAR#01#08';
      'wycofanie akceptacji'@
   |? ZWAR.KIND='pl'
   || _result:='';
      'usunięcie z planu'@
   || _result:='';
      ''
   ?};
_result


\zwar_trig_add_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Trigger przed add dla tabeli ZWAR
::----------------------------------------------------------------------------------------------------------------------
ZWAR.WP:=exec('FindAndGet','#table',ZL,ZWAR.ZL,,"TYP().WP",'');
1


\legenda_zwar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Legenda w oknie dziennika zlecenia (tabela ZWAR, okno SLO)
::  OLD: \legenda/zl_zwar.fml
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','ZWAR#01#')


\legenda_zwar_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Legenda w oknie dziennika zleceń (tabela ZWAR, okno WER)
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','ZWAR#01#','#ZL#03','#ZL#05')


::----------------------------------------------------------------------------------------------------------------------
:: Inne
::----------------------------------------------------------------------------------------------------------------------


\openmask
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Otwarcie tabel maskowalnych (limity, dostawy do zlecenia)
::   WE: _a - ZL.ref()
::       [_b] - GROP.ref()
::  OLD: \openmask/zl_limit.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_grop:={? var_pres('_b')=type_of(null()) || _b || null() ?};
_maska:='0000';

{? _grop<>null()
|| _maska:='grop'

|? _zl<>null()
|| ZL.cntx_psh();
   ZL.prefix();
   {? ZL.seek(_zl)
   || {? ZL.MASKA=''
      ||
::       dla zlecen ze starego programu
         ZL.MASKA:='0000'; ZL.put()
      |? ZL.MASKA='____' & ZL.NRNZL=0
      ||
::       dla nowych zlecen
         ZL.MASKA:=form(((#ZL.ref())/1000)+1,-4,0,'9'); ZL.put()
      |? ZL.MASKA='____' & ZL.NRNZL<>0
      ||
::       dla zlecen podrzednych
         _nrzl:=ZL.NRNZL;
         _sym:=ZL.SYM;
         ZL.cntx_psh();
         ZL.index('UNRZL');
         ZL.prefix(_nrzl);
         {? ZL.first()
         || {? ZL.MASKA='____'
            || ZL.MASKA:=form(((#ZL.ref())/1000)+1,-4,0,'9');
               ZL.put();
               _maska:=ZL.MASKA
            || _maska:=ZL.MASKA
            ?};
            ZL.cntx_pop()
         || FUN.emsg('Brak zlecenia nadrzędnego dla zlecenia: %1'@[_sym]);
            ZL.cntx_pop();
            _maska:=form(((#ZL.ref())/1000)+1,-4,0,'9')
         ?};
         ZL.MASKA:=_maska;
         ZL.put()
      ?};
      _maska:=ZL.MASKA
   ?};
   ZL.cntx_pop()
?};

ZLIM.use('zlim'+_maska)


\poil
::----------------------------------------------------------------------------------------------------------------------
::  UTW:
:: OPIS: Po redakcji ilości - gdy ilość nie może być ujemna
::   WE: _a - czy podzielność (T/N)
::       _b - wartość do zaokrąglenia - formuła w postaci STRING, np. 'TAB.POLE'
::       _c - zaokrąglenie
::   WY: 0 / 1
::  OLD: \polil/polap.fml
::----------------------------------------------------------------------------------------------------------------------
roundmet(2);
_wynik:=1;
_tab:=($_b)();
_int:=int(_tab);
{? _tab<0
|| FUN.emsg('Ilość nie może być ujemna.'@);
   _tab:=0;
   _wynik:=0
|| {? _a='N' & _int<>_tab
   || FUN.emsg('Jednostka miary nie jest podzielna. Wprowadź liczbę całkowitą.'@);
      _wynik:=0
   || _tab:=_tab $ _c;
      ($(_b+':='+form(_tab,,,'9.')))()
   ?}
?};
_wynik


\a_tpzl_opca
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Zwraca domyślny wariant analizy dla typu zlecenia z VAR.A_TPZL
::   WY: VAR.A_TPZL().DEF_OPCA
::  OLD: \a_tpzl_opca/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_TPZL().DEF_OPCA


\a_tpzl_opck
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Zwraca domyslny wariant kalkulacji dla typu zlecenia z VAR.A_TPZL
::   WY: VAR.A_TPZL().DEF_OPCK
::  OLD: \a_tpzl_opck/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_TPZL().DEF_OPCK


\a_tpzl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Zwraca VAR.A_TPZL
::   WY: VAR.A_TPZL
::  OLD: \a_tpzl/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_TPZL


\a_zlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Zwraca VAR.A_ZLEC
::   WY: VAR.A_ZLEC
::  OLD: \a_zlec/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_ZLEC


\podzlec_dkc_upd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Aktualizuje cechę na podzleceniach które odziedziczyły wartości atrybutów z surowców
::       technologicznych
::   WE: _a - ZL.ref()
::   WY: 0 - porazka
::       1 - sukces
::  OLD: \podzlec_dkc_upd/zlec5.fml
::  TAG: <PUBLIC>
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=0;
_can_continue:=1;

ZL.cntx_psh(); ZL.clear();
M.cntx_psh();
{? ZL.seek(_zl)
||
   _main_podzlec:=exec('main_podzlec','zl_link',ZL.ref());
:: Wykonuje ta aktualizacje tylko dla zlecenia zlozonego lub dla zlecenia na produkt
   {? ZL.RODZAJ='Z' | _main_podzlec=_zl
   ||
::    Zapamietuje ceche zlecenia na ktorym edytowalem
      _dkc_zl:=ZL.DK_C;

      _top:=exec('top_level','zl_link',ZL.ref());
      _unrzl:=exec('FindAndGet','#table',ZL,_top,,"UNRZL",0);

::    Przechodze na podzlecenie montazowe bo nadrzedne nie ma technologii

      {? ZL.seek(_main_podzlec)
      ||
         {? _zl<>_main_podzlec
         ||
::          Aktualizacja cechy na zleceniu nadrzędnym - podzleceniu montażowemu aktualizuje cechę
            ZL.DK_C:=_dkc_zl;
            _can_continue:=ZL.put()
         ?};
         {? _zl=_main_podzlec
         ||
            _top:=exec('top_level','zl_link',_main_podzlec);
::          Aktualizacja cechy na podzleceniu montażowym - podzleceniu nadrzędnemu aktualizuje cechę
            ZL.cntx_psh(); ZL.clear();
            {? ZL.seek(_top)
            || ZL.DK_C:=_dkc_zl;
               _can_continue:=ZL.put()
            ?};
            ZL.cntx_pop()
         ?};

::       Aktualizuje cechę na podzleceniach na półfabrykaty
         {? _can_continue>0
         ||
            {? ZL.TYP().TECH='T'
            || _ktl:=ZL.TKTL;
               _xjm:=ZL.TKTL().XJM
            || _ktl:=ZL.KTL;
               _xjm:=ZL.KTL().XJM
            ?};
            TMAT.cntx_psh();
            TMAT.index('NNL');
            TMAT.prefix(_ktl);
            {? TMAT.first()
            ||
::             Iteruje po TMATach i jeśli któryś z nich jest półfabrykatem szukam takiego podzlecenia
               {!
               |?
                  _ktm:=null();
                  _ktm:={? TMAT.GRKTM='G'
                        || TMAT.TGDFLT().PT
                        || TMAT.PT
                        ?};
                  _m_rodz:=exec('FindAndGet','#table',M,_ktm,,"R",'');

                  {? _m_rodz='P' & TMAT.ATR_MASK*'T'>0
                  ||
                     ZL.cntx_psh();
                     ZL.index('NRNZL');
                     ZL.prefix(_unrzl);
                     {? ZL.first()
                     || {!
                        |?
                           {? ZL.KTM=_ktm
                           ||
::                            Znalazłem zlecenie na ten sam półfabrykat - uaktualniam mu DK_C
                              _dk_c:=exec('create_dkc','zl_common',_dkc_zl,TMAT.DK_C,TMAT.ATR_MASK,_ktm);
                              ZL.DK_C:=_dk_c;
                              _can_continue:=ZL.put()
                           ?};
                           ZL.next() & _can_continue>0
                        !}
                     ?};
                     ZL.cntx_pop()
                  ?};
                  TMAT.next() & _can_continue>0
               !}
            ?};
            TMAT.cntx_pop()
         ?}
      ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
M.cntx_pop();
ZL.cntx_pop();
_result


\usuzatw
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Usunięcie limitów i przewodników zlecenia
::       Kontekst wywołania - VAR.A_ZLEC
::   WY: 0 / 1 - czy udało sie usunąć limity i przewodniki
::  OLD: \usuzatw/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
_ok:=exec('usunlim','zl_limit',VAR.A_ZLEC,1);
{? _ok || _ok:=exec('usuprze','zl_guide',VAR.A_ZLEC,1) ?};
_ok


\cp_zlec
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Kopiowanie limitów i przewodników zlecenia
::   WE: _a: ZL.ref() - nowe
::       _b: ZL.ref() - źródlowe
::   WY: 0 / 1 - czy udało się kopiowanie (jest zawsze 1, ale warto poprawić)
::  OLD: \cp_zlec/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_zlnew:=_a;
_zlold:=_b;
exec('openmask','zl_common',_zlold);

ZGH.cntx_psh();
ZGP.cntx_psh();
ZGH.index('ZLNR');
ZGH.prefix(_zlold);
{? ZGH.first()
|| {!
   |?
      _zghold:=ZGH.ref();
      ZGH.cntx_psh();
      ZGH.ZLEC:=_zlnew;
      ZGH.NRPRZ:='';
      ZGH.NRPRZ:=exec('bl_nrprz','zl_guide',1);
      ZGH.GKTL:=exec('gktl_from_zl','zl_common',ZGH.ZLEC);
      ZGH.KTM:=exec('FindAndGet','#table',ZL,_zlnew,,"KTM",null());
      ZGH.KH:=exec('FindAndGet','#table',ZL,_zlnew,,"KH",null());
      ZGH.prefix();
      {? ZGH.add()
      || _zghnew:=ZGH.ref()
      || _zghnew:=null()
      ?};
      ZGH.cntx_pop();
      ZGP.index('NRPP');
      ZGP.prefix(_zghold);
      {? ZGP.first()
      || {!
         |? _txt:=ZGP.memo_txt(,1,'OPISMEMO');
            ZGP.cntx_psh();
            ZGP.NRPRZ:=_zghnew;
            ZGP.NRZLP:=_zghnew;
            ZGP.prefix();
            {? ZGP.add()
            || _zgpnew:=ZGP.ref();
               ZGP.memo_set(_txt,'OPISMEMO');
               ZGP.memo_put(,'OPISMEMO')
            || _zgpnew:=null()
            ?};
            ZGP.cntx_pop();

            ZLIM.cntx_psh();
            ZLIM.index('ZGP_M');
            ZLIM.prefix(ZGP.ref());
            {? ZLIM.first()
            || {!
               |?
                  {? ZLIM.KOR=0
                  || _lil:=exec('sum_il','zl_limit',ZLIM.ref(),1);
                     ZLIM.cntx_psh();
                     exec('openmask','zl_common',_zlnew);
                     ZLIM.ZLEC:=_zlnew;
                     ZLIM.ZGP:=_zgpnew;
                     ZLIM.LIL:=_lil;
                     ZLIM.AKC:='N';
                     ZLIM.prefix();
                     ZLIM.add();
                     exec('openmask','zl_common',_zlold);
                     ZLIM.cntx_pop()
                  ?};
                  ZLIM.next()
               !}
            ?};
            ZLIM.cntx_pop();

            ZGP.next()
         !}
      ?};
      ZGH.next()
   !}
?};
ZGP.cntx_pop();
ZGH.cntx_pop();
1


\p_res_string
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Zwraca kod zastrzezonego typu zlecenia (zadania) dla projektow
::   WY: '~PR'
::  OLD: \p_res_string/skid_zlc.fml
::----------------------------------------------------------------------------------------------------------------------
'~PR'


\zlec_party
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy zlecenie powinno byc partiowane. Zlecenie moze byc partiowane w nastepujacych przypadkach:
::       1. Jest zleceniem pojedynczym i jego wyrob ma atrybut dostawy typu 'partia'
::       2. Jest zleceniem podrzednym i:
::             a). Nalezy do zlecenia nadrzednego ze zleceniami niezaleznymi i jego wyrob jest partiowany
::             b). Nalezy do zlecenia nadrzednego, jest podzleceniem montazowym, jego wyrob jest partiowany
::       3. Jest zleceniem nadrzędnym i nie ma jeszcze zlecenia montażowego, ale wyrób jest partiowany
::   WE: _a - ZL.ref()
::   WY: 0 - material nie moze byc partiowany
::       1 - material musi byc partiowany
::  OLD: \zlec_party/zparn.fml
::  TAG: <PUBLIC>
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=0;
ZL.cntx_psh(); ZL.clear();
{? ZL.seek(_zl)
|| _rp:=ZL.RP;
:: Sprawdzam 'partiowalnosc' produktu zlecenia
   _mat_part:=exec('material_party','material',ZL.KTM);
   {? ZL.RODZAJ='P' & ZL.NRNZL=0
   ||
::    Jesli zlecenie jest pojedyncze to jako wynik zwracam partiowalnosc produktu
      _result:=_mat_part
   |? ZL.RODZAJ='P' & ZL.NRNZL>0
   ||
::    Jesli jest zleceniem podrzednym to znajduje zlecenie nadrzedne najwyzszego poziomu
      _zl_nad:=exec('top_level','zl_link',ZL.ref());

      {? _zl_nad<>null() & _zl_nad<>_zl
      ||
         ZL.cntx_psh(); ZL.clear();
         {? ZL.seek(_zl_nad)
         ||
::          Stoje na zleceniu nadrzednym

            {? ZL.RODZAJ='N'
            ||
::             1. Jesli nadrzedne ma zlecenia niezalezne to jako wynik wystarczy partiowalnosc produktu
::                zlecenia podrzednego
               _result:=_mat_part
            |? ZL.RODZAJ='Z'
            ||
::             2. Jesli nadrzedne ma normalne podzlecenia to musze sprawdzic czy przekazane w _a zlecenie:
::                a.) jest podzleceniem montazowym, jesli tak to moze byc partiowane (jesli wyrob jest partiowalny)
::                b.) jest podzleceniem raportowanym na magazyn
               _zl_mont:=exec('main_podzlec','zl_link',ZL.ref());
               {? _zl_mont=_zl | _rp='T'
               || _result:=_mat_part
               ?}
            ?}
         ?};
         ZL.cntx_pop()
      ?}
   |? ZL.RODZAJ='Z'
   || {? exec('main_podzlec','zl_link',ZL.ref())=null()
      || _result:=_mat_part
      ?}
   ?}
?};
ZL.cntx_pop();
_result


\zl_inherit_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy na zleceniu istnieja takie limity ktore odziedziczyly wartosc atrybutu z naglowka zlecenia
::       a jesli tak to czy aktualna wartosc atrybutu na limicie jest zgodna z atrybutem na zleceniu
::   WE: _a - ZL.ref()
::       [_b] - bufor zlecenia ktory trzyma wartosci atrybutow, jesli nie podany to wypelniany na podstawie _a
::   WY: 0 - brak limitow ktore dziedziczyly ceche lub wartosci zgodne ze zleceniem
::       1 - byly takie limity ktore dziedziczyly ceche i wartosci na limicie i zleceniu rozne
::  OLD: \zl_inherit_chk/zlec5.fml
::  TAG: <PRIVATE>
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_buf_zl:=~~;
{? var_pres('_b')>100
|| _buf_zl:=_b
?};

_result:=0;

ZL.cntx_psh(); ZL.clear();
{? ZL.seek(_zl)
||
:: Sprawdzam czy zlecenie posiada podzlecenia
   {? exec('subzlec_exist','zl_link',ZL.ref())>0
   ||
::    Zlecenie zlozone
      ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |?
::          !!! REKURENCJA !!!
            {? exec('zl_inherit_chk','zl_common',ZL.ref(),_buf_zl)>0
            || _result:=1
            ?};
            ZL.next()
         !}
      ?};
      ZL.cntx_pop()
   ||
::    Zlecenie proste
      _result:=exec('inherit_check','zl_limit',ZL.ref(),_buf_zl)
   ?}
?};
ZL.cntx_pop();
_result


\nd_party
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy dla dokumentu wyswietlic rozliczenie partii, czyli czy ktores ze zlecen
::       powiazanych z pozycja dokumentu powinno byc partiowane
::   WE: _a - ND.ref()
::   WY: 0 - nie trzeba rozliczac partii dla dokumentu
::       1 - nalezy rozliczyc partie dla dokumentu
::  OLD: \nd_party/zparn.fml
::  TAG: <PUBLIC>
::----------------------------------------------------------------------------------------------------------------------
_nd:=_a;

_result:=0;
_can_continue:=1;

ND.cntx_psh(); ND.clear();
{? ND.seek(_nd)
||
   DK.cntx_psh();
   DK.index('DOKMAG');
   DK.prefix(ND.ref());
   {? DK.first()
   || {!
      |?
         {? DK.ZL<>null()
         ||
            {? exec('zlec_party','zl_common',DK.ZL)>0
            ||
               _can_continue:=0;
               _result:=1
            ?}
         ?};
         DK.next() & _can_continue>0
      !}
   ?};
   DK.cntx_pop()
?};
ND.cntx_pop();
_result


\zl_p_wys
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed 'Wyswietl' zlecenie - dokumenty magazynowe
::   WE: _a: akronim pola tabeli
::       _b: akronim pola zmiennej
::   WY:
::  OLD: \zl_p_wys/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_PoleTab:=$(_a);
_PoleZm:=$(_b);
_PoleRel:=$(_a+'()');
{? _PoleTab()<>null()
|| _PoleRel();
   {? ZL.NRNZL=0
   || _PoleZm():=ZL.SYM
   || _PoleZm():=exec('nrnzl','zl_head',ZL.NRNZL)
   ?};
   _PoleTab():=ZL.ref()
|| _PoleZm():=''
?}


\zl_p_red
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed 'Wyswietl' zlecenie - dokumenty magazynowe
::   WE: _a - 'ND','DK','ZK_N','ZK_P','KARO' - czy z poziomu naglowka czy pozycji dokumentu.
::  OLD: \zl_p_red/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a='ND'
   & ND.PROJEKTY
   & ND.TYP().PROJWJO='T'
|| return(0)
|? _a='DK'
   & DK.PROJEKTY
   & ND.TYP().PROJWJO='T'
|| return(0)|? _a='ZK_N'
   & ZK_N.PROJEKTY
   & ZK_N.T().PROJWJO='T'
|| return(0)
|? _a='ZK_P'
   & ZK_P.PROJEKTY
   & ZK_N.T().PROJWJO='T'
|| return(0)
?};

{? {? (_a='ND' | _a='DK') || ND.TYP().ZLEC='N' & ND.TYP().KOOP='N'
   |? _a='ZAKR' || 0
   |? ZK_N.T().TYPYDOK<>null || ZK_N.T().TYPYDOK().ZLEC='N'
   || 0
   ?}
|| {? _a='ZK_P'
   || ZMSLAPP.ZL1W:='';
      ZK_P.ZL:=null
   |? _a='ZK_N'
   || ZMSLAPP.ZL11W:='';
      ZK_N.ZL:=null
   ?};
   win_disp();
   0
|| {? _a='ND'
   || _ok:=exec('FindInSet','#table','DK','DOKMAG',ND.ref())=null | ND.MAG().PAL='T';
      {? VAR.ZAKLADKI*'D'>0 | VAR.ZAKLADKI*'M'>0
      ||
::       Jesli dokument klasy RP to ustawiam zlecenie na ktorym powstaje produkt
         {? exec('nd_is_rp','magdok_wspolne',ND.ref()) & exec('is_separate_zl','zl_link',ZL.ref())=0
         ||
            _main_podzlec:={? VAR.A_ZLEC().RP='T'
                           || ZL.ref()
                           || exec('main_podzlec','zl_link',ZL.ref())
                           ?};
            {? _main_podzlec<>null()
            || _main_sym:=exec('FindAndGet','#table'  ,ZL
                                                      ,#_main_podzlec
                                                      ,ref_name(_main_podzlec)
                                                      ,"SYM"
                                                      ,'');
               ND.ZL:=_main_podzlec;
               ZMSLAPP.ZL11:=ZL.SYM;
               ZMSLAPP.ZL12:=_main_sym
            ?}
         ||
            ND.ZL:=ZL.ref();
            ZMSLAPP.ZL11:=ZL.SYM
         ?};
         win_disp();
         0
      || _ok
      ?}
   |? _a='DK'
   ||
::    Zapamietuje przed redakcja ref zlecenia
      VAR1.ZL_BEF:=DK.ZL;
      {? ND.ZL<>null
      || DK.ZL:=ND.ZL;
         {? ND.TYP().WYR='T'
         || {? ~(exec('nd_is_rp','magdok_wspolne',DK.N)>0 & exec('zl_czy_wyr','zl_wyr',DK.ZL)>0)
            || DK.M:=ND.ZL().KTM
            ?}
         ?};
         0
      || 1
      ?}
   |? _a='ZK_N'
   || _ok:=exec('FindInSet','#table','ZK_P','NAG',ZK_N.ref())=null;
      _ok
   |? _a='ZK_P'
   || {? ZK_N.ZL<>null
      || ZK_P.ZL:=ZK_N.ZL;
         {? ZK_N.T().TYPYDOK<>null & ZK_N.T().TYPYDOK().WYR='T'
         || ZK_P.M:=ZK_N.ZL().KTM
         ?};
         0
      || 1
      ?}
   |? _a='ZAKR'
   || 1
   |? _a='KARO'
   || 1
   ?}
?}


\zl_f3_1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Na F3 do redakcji pola zlecenia.
::   WE: _a: akronim pola zmiennej
::       _b: akronim pola tabeli
::       [_c] - czy dokumenty magazynowe=1 (domyslnie) czy zamowienia wewnetrzne=0 zakres=-1 ZAKR=-2
::  OLD \zl_f3_1/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
{? _>=3  || {? type_of(_c)<>1 || _c:=1 ?}  || _c:=1  ?};

_wybor:=0;

_exit:="
   exec('err_psql','#sql');
   exec('empty_f_set','#table','ZL')
";
_prod:=exec('tte_lic','tte');

_refktm:={? _c=-3 || EANP.M || null ?};
_PoleTab:=$(_b);
_PoleZm:=$(_a);
_loop:=0;
ZL.cntx_psh();
ZL.win_sel('SLO_SL');
ZL.actions('SLO_SL','XY','W');
ZL.clear();
{? {? _c>0 || ND.TYP().ZLEC='T' & ND.TYP().WYR='T' || 1 ?}
|| {? _prod='N'
   ||
      {? ~ZL.f_set('SYM','',
             ' "ZL"."HIDDEN"=\'N\'
               and "ZL"."STAN"=\'O\'
               and "ZL"."TYP"=:_a'
             +{? _c=-3 || ' and "ZL"."SCEAN"=\'\' and "ZL"."KTM"=:_b' || ''  ?},exec('m_res_ref','zl_common'),_refktm)
      ||
         _exit()
      ?}
   ||
      _typy:=exec('typy_zlecen','zl_head');
      {? ~ZL.f_set('SYM,TYP(WP)',' join "ZTP" ',
             ' "ZL"."HIDDEN"=\'N\'
               and "ZL"."STAN"=\'O\'
               and "ZTP"."WP"=\'P\'
               and ZL.TYP in (select :_a.REF from :_a)'
::             Jeżeli dokument RP to filtruje również po podzleceniach, do których można generować dokument raportujący
             +{? ((' '+exec('get','#params',500701,2,null()))*(' '+ND.TYP().T+' '))>0
              || ' and "ZL"."RP"=\'T\''
              || ' and "ZL"."NRNZL"=0'
              ?}
             +{? _c=-3 || ' and "ZL"."SCEAN"=\'\' and "ZL"."KTM"=:_b' || ''  ?},_typy,_refktm)
      ||
         _exit()
      ?}
   ?}
|| {? _prod='N'
   ||
      {? ~ZL.f_set('SYM',,
             ' "ZL"."HIDDEN"=\'N\'
               and "ZL"."STAN"=\'O\'
               and "ZL"."TYP"=:_a'
             +{? _c=-3 || ' and "ZL"."SCEAN"=\'\' and "ZL"."KTM"=:_b' || ''  ?},exec('m_res_ref','zl_common'),_refktm)
      ||
         _exit()
      ?}
   || {? TYPYDOK.KOOP='T'
      ||
::       F3 na dokumencie kooperacyjnym - pokazuje również podzlecenia
         _typy:=exec('typy_zlecen','zl_head');
         {? ~ZL.f_set('SYM',' join "ZTP" ',
                ' "ZL"."HIDDEN"=\'N\'
                  and "ZL"."STAN"=\'O\'
                  and "ZTP"."WP"=\'P\'
                  and ZL.TYP in (select :_a.REF from :_a)'
                +{? _c=-3 || ' and "ZL"."SCEAN"=\'\' and "ZL"."KTM"=:_b' || ''  ?},_typy,_refktm)
         ||
            _exit()
         ?}
      |?  (' '+exec('get','#params',500709,2,null()))*(' '+TYPYDOK.T+' ')=0
      ||
         _typy:=exec('typy_zlecen','zl_head');
         {? ~ZL.f_set('SYM',,
                ' "ZL"."HIDDEN"=\'N\'
                  and "ZL"."STAN"=\'O\'
                  and "ZL"."NRNZL"=0
                  and ZL.TYP in (select :_a.REF from :_a)'
                +{? _c=-3 || ' and "ZL"."SCEAN"=\'\' and "ZL"."KTM"=:_b' || ''  ?},_typy,_refktm)
         ||
            _exit()
         ?}
      ||
         _typy:=exec('typy_zlecen','zl_head');
         {? ~ZL.f_set('SYM',,
                ' "ZL"."HIDDEN"=\'N\'
                  and ("ZL"."STAN"=\'O\')
                  and "ZL"."NRNZL"=0
                  and ZL.TYP in (select :_a.REF from :_a)'
                +{? _c=-3 || ' and "ZL"."SCEAN"=\'\' and "ZL"."KTM"=:_b' || ''  ?},_typy,_refktm)
         ||
            _exit()
         ?}
      ?}
   ?}
?};
_wynik:=0;
{? _PoleZm()<>''
|| ZL.f_find(_PoleZm())
|| ZL.f_first()
?};

_env:=exec('env','zl_view');
params_set('env',_env);

{!
|?
   {? ZL.select(,1,10)
   || _wybor:=1;
      {? _c>0 & ZL.OD>ND.D
      || FUN.info('Zlecenie powołane jest z datą późniejszą niż data dokumentu.'@);
         _loop:=1
      |? ~_c & ZL.OD>ZK_N.DP
      || FUN.info('Zlecenie powołane jest z datą późniejszą niż data zamówienia.'@);
         _loop:=1
      |? _c=-2 & ZL.OD>{? var_pres('__eanpzl')=1 || EANP.EANN().DATA |? var_pres('__dk2zl')=1 || ND.D || ZAKR.DP  ?}
      || FUN.info('Zlecenie powołane jest z datą późniejszą niż data przyjęcia dokumentu.'@);
         _loop:=1
      |? (ZL.TYP().WP<>'P'
        & {? _c=1
          || ND.TYP().ZLEC='T' & ND.TYP().WYR='T'
          |? ~_c
          || {? ZK_N.T().TYPYDOK<>null || ZK_N.T().TYPYDOK().ZLEC='T' & ZK_N.T().TYPYDOK().WYR='T' || 0 ?}
          |? _c=-2
          || {? HELP.TYP<>null || HELP.TYP().ZLEC='T' & HELP.TYP().WYR='T' || 0 ?}
          ?})
      || FUN.info('Nie można wybrać tego typu zlecenia\nna dokumentach powiązanych z wyrobami (półproduktami).'@);
         _loop:=1
      |? _c=1 &  ND.TYP().ZLEC='T' & ND.TYP().WYR='T' & ZL.MG<>null() & ZL.MG<>ND.MAG
      || FUN.info('Magazyn wskazany w zleceniu (%1) różny od bieżącego magazynu.'@[ZL.MG().SYM]);
         _loop:=1
      || {? _PoleTab<>""
         || _PoleTab():=ZL.ref();
            {? (2+_b)='DK'
            || {? DK.KK=null
               || DK.KK:=ZL.KK
               |? DK.KK<>ZL.KK
                & FUN.ask('Konto kosztów na zleceniu jest różne od podanego.\nCzy przypisać konto ze zlecenia?'@)
               || DK.KK:=ZL.KK
               ?};
               exec('_chk_pdp','zl_common',DK.M,ND.MAG,ND.D,ZL.ref())
            |? (2+_b)='ND'
            || {? ND.KK=null
               || ND.KK:=ZL.KK
               |? ND.KK<>ZL.KK
                & FUN.ask('Konto kosztów na zleceniu jest różne od podanego.\nCzy przypisać konto ze zlecenia?'@)
               || ND.KK:=ZL.KK
               ?}
            |? (4+_b)='ZAKR'
            || {? ZAKR.KK=null
               || ZAKR.KK:=ZL.KK
               |? ZAKR.KK<>ZL.KK
                & FUN.ask('Konto kosztów na zleceniu jest różne od podanego.\nCzy przypisać konto ze zlecenia?'@)
               || ZAKR.KK:=ZL.KK
               ?}
            ?}
         ?};
         _PoleZm():=ZL.SYM;
:: to przerobka dla pozycji dokumentu PDP.T:=ZL.KTM;
         _loop:=0
      ?}
   ||
::      _PoleZm():='';
::      _PoleTab():=null();
      _loop:=0
   ?};
   _loop
!};
ZL.f_clear();
ZL.cntx_pop();
{? _c<>-3 || fld() || _wybor ?}


\m_res_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Zwraca ref zastrzezonego typu zlecenia magazynowego
::   WY: ZL.ref()
::  OLD: \m_res_ref/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_m_res:=exec('m_res_string','zl_common');
ZTP.clear();
{? ZTP.find_tab(,'TYP',,'=',_m_res) || _res:=ZTP.ref() || _res:=null() ?};
_res


\m_res_string
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Zwraca kod zastrzezonego typu zlecenia magazynowego
::   WY: '~ML'
::  OLD: \m_res_string/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
'~ML'


\_chk_pdp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.53]
:: OPIS: po redakcji towaru na dokumentach
::   WE: kontekst pozycji dokumentu
::       _a: M.ref
::       _b: MAG.ref
::       _c: Data
::       _d: ZL.ref
::   WY: 0 / 1
::  OLD: \_chk_pdp/polap.fml
::----------------------------------------------------------------------------------------------------------------------
_tmg:=1+ND.MAG().TYP;
_only:=ND.MAG().IL='T';
{? ND.TYP().P='T'
|| {? 'E' *_tmg = 1
   || DK.C:=exec('biez_cen','ceny_dok',_a,_b,_c);
      {? DK.C=0
      || DK.C:=exec('mptz_prop','zl_common',_a,exec('get','#params',500711),_d)
      ?}
   || DK.C:={? _only || 0 || exec('mptz_prop','zl_common',_a,exec('get','#params',500711),_d) ?}
   ?}
|| {? 'E' *_tmg = 1
   || DK.C:=exec('biez_cen','ceny_dok',_a,_b,_c)
   ?}
?};
1


\mptz_prop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.60] (wycena rozdzielni)
:: OPIS: Proponowana cena produktu z propozycji cen
::   WE: _a - M.ref()
::       _b - rodzaj propozycji ceny (K - kalkulacja TKW, Z - kalkulacja zlecenia, A - analiza zlecenia, R - ręcznie)
::       _c - ZL.ref() (tylko dla _b= 'Z', 'A')
::   WY: znaleziona cena, wpp. zero
::  OLD: \mptz_prop/polap.fml
::----------------------------------------------------------------------------------------------------------------------
_cena:=0;
M.cntx_psh();
M.clear();
{? M.seek(_a)
|| {? M.R='S'
   || PTC.clear();
      PTC.index('TO');
      PTC.prefix(M.ref());
      {? PTC.last()
      || {!
         |? _prev:=0;
            {? date(ST.AR,ST.AM,0)>=PTC.DOD
            || {? ~((date(ST.AR,ST.AM,0)>PTC.DDO)&(PTC.DDO<>date(0,0,0)))|| _cena:=PTC.PRICE ?}
            || _prev:=1
            ?};
            {? _prev || PTC.prev() ?}
         !}
      ?}
   ||
      MPTZ.index('AKT');
      {? _b='K' | _b='R'
      || MPTZ.prefix('T',_b,_a)
      || ZL.cntx_psh();
: Jezeli jest to podzlecenie na produkt glowny zlecenia z podzleceniami,
: to propozycja dla kalkulacji lub analizy pobierana jest ze zlecenia naglowkowego.
         {? ZL.seek(_c)
         || _unrzl:=ZL.NRNZL;
            {? _unrzl<>0 & ZL.NR=1
            || {? ZL.seek(_c)
               || ZL.index('UNRZL');
                  ZL.prefix(_unrzl);
                  {? ZL.first() & ZL.RODZAJ='Z'
                  || _c:=ZL.ref()
                  ?}
               ?}
            ?}
         ?};
         ZL.cntx_pop();
         MPTZ.prefix('T',_b,_a,_c)
      ?};
      {? MPTZ.first()
      || _cena:=MPTZ.PRICE
      || _cena:=0
      ?};
      MPTZ.clear()
   ?}
?};
M.cntx_pop();
_cena


\zl_p_wys3
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed 'Wyswietl' zlecenie podrzedne - dokumenty magazynowe
::   WE: _a: akronim pola tabeli
::       _b: akronim pola zmiennej
::  OLD: \zl_p_wys3/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_PoleTab:=$(_a);
_PoleZm:=$(_b);
_PoleRel:=$(_a+'()');
{? _PoleTab()<>null() & _PoleRel().NRNZL<>0
|| _PoleRel();
   _PoleTab():=ZL.ref();
   {? ZL.RODZAJ='P' & ZL.NRNZL=0
   || _PoleZm():='';
      0
   || {? ZL.RODZAJ='P'
      || _PoleZm():=ZL.SYM
      ?};
      1
   ?}
|| _PoleZm():='';
   1
?}


\zl_p_wys2
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed redakcja pola zlecenie - dokumenty magazynowe
::   WE: _a: akronim pola tabeli
::       _b: akronim pola zmiennej zlecenia nadrzednego
::       _c: akronim pola zmiennej zlecenia podrzednego
::   WY: 0/1
::  OLD: \zl_p_wys2/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a='ND.ZL'
   & ND.PROJEKTY
   & ND.TYP().PROJWJO='T'
|| return(0)
|? _a='DK.ZL'
   & DK.PROJEKTY
   & ND.TYP().PROJWJO='T'
|| return(0)
|? _a='ZK_N.ZL'
   & ZK_N.PROJEKTY
   & ZK_N.T().PROJWJO='T'
|| return(0)
|? _a='ZK_P.ZL'
   & ZK_P.PROJEKTY
   & ZK_N.T().PROJWJO='T'
|| return(0)
?};

{? _a='ZLGD.ZL' & VAR.ZAKLADKI*'R'>0 &  ZLGD.ZL=VAR.A_ZLEC
|| return(0)
?};

{? (_a='DK.ZL' &  ND.ZL<>null) | (_a='ZK_P.ZL' & ZK_N.ZL<>null)
|| _res:=0
|| _res:=1;
   {? _a='ND.ZL'
   ||
::    Jezeli dokument ma pozycje to nie redaguje pola zlecenie
      _res:=exec('FindInSet','#table','DK','DOKMAG',ND.ref())=null
   |? _a='ZK_N.ZL'
   || _res:=exec('FindInSet','#table','ZK_P','NAG',ZK_N.ref())=null
   ?};
   {? _a='ND.ZL' | _a='DK.ZL'
   || {? _res=0 & ($(_a))()<>null & 1+(-menu_txt)='d' || _res:=1 ?}
   ?};
   {? _res=1
   || _zl:=$(_a);
      _zl();
      VAR1.ZLP_BEF:=DK.ZL;
      _sym:=ZL.SYM;
      _PoleZm:=$(_b);
      _PolePr:=$(_c);
      {? _PoleZm()<>''
      || ZL.index('SYM');
         ZL.prefix(_PoleZm());
         {? ZL.first()
         || {? _PolePr()*ZL.SYM<=0
            || _PolePr():=''
            ?};
            {? _a<>'ZLGD.ZL'
            ||
::             W zaleznosci od tego czy dokument jest powiazany z produktem czy nie
::             czyli czy jest klasy RP czy RW sprawdzam redagowalnosc pola w rozny sposob
               {? ND.TYP().WYR='T'
               ||
::                Klasa dokumentu RP
                  {? ZL.RODZAJ='Z' | ZL.RODZAJ='P'
                  || _res:=0
                  || _res:=1
                  ?}
               ||
::                Klasa dokumentu RW
                  {? ZL.RODZAJ='P'
                  || _res:=0
                  || _res:=1
                  ?}
               ?}
            || {? ZL.RODZAJ='P'
               || _res:=0
               || _res:=1
               ?}
            ?}
         || _res:=0
         ?};
         ZL.clear()
      || _res:=0
      ?}
   ?}
?};
_res


\zl_f3_2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Na F3 dla podzlecenia.
::   WE: _a: akronim pola tabeli
::       _b: akronim pola zmiennej zlecenia podrzednego.
::       _c: data
::       _d: akronim pola zmiennej zlecenia nadzednego.
::   WY:
::  OLD: \zl_f3_2/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_PoleRel:=$(_d);
ZL.cntx_psh();
ZL.index('SYM');
{? ZL.find_tab(0,'SYM',,'=',_PoleRel())
|| _nrn:=ZL.UNRZL
|| _nrn:=0
?};
ZL.cntx_pop();
ZL.cntx_psh();
_f_active:=ZL.f_active();
{? _f_active>0
||
:: Czyszcze filtr na zleceniach
   ZL.f_clear()
?};
ZL.win_sel('SLO_SL');
ZL.actions('SLO_SL','XY','W');
ZL.index('STAN');
ZL.prefix('N','O',_nrn);
_PoleTab:=$(_a);
_PoleZm:=$(_b);
_PoleRel:=$(_a+'()');
{? _PoleZm()<>''
|| ZL.blank(1);
   ZL.SYM:=_PoleZm();
   ZL.find_tab(0,'SYM',,'=',_PoleZm(),'LEVEL',,'<>',1)
||
   ZL.first()
?};

_env:=exec('env','zl_view');
params_set('env',_env);

{? VAR.P_NKTM:=''; ZL.select(,1)
|| {? _PoleTab<>"" || _PoleTab():=ZL.ref() ?};
   VAR.A_ZLEC:=ZL.ref();
   _PoleZm():=ZL.SYM;
   ZL.cntx_pop()
|| ZL.cntx_pop()
?};
{? _f_active>0
||
:: Przywracam filtr zlecen
   exec('filter_reset','zl_common')
?};
fld()


\filter_reset
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Ustawia filtr w zleceniach - albo domyslny, ktory jest ustawiany na wejsciu
::       albo bardziej zawezony na podstawie pol ktore ustawil uzytkownik akcja 'Filtr'
::  OLD: \filter_reset/zlecenia.fml
::  TAG: <PUBLIC>
::----------------------------------------------------------------------------------------------------------------------
{? VAR.FILTER='T'
|| exec('set_filter_usr','zl_common')
|| exec('set_filter','zl_common')
?};
~~


\set_filter_usr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Ustawia filtr programowy na podstawie zmiennych ktore sobie ustawil uzytkownik
::  OLD: \set_filter_usr/zlecenia.fml
::  TAG: <PUBLIC>
::----------------------------------------------------------------------------------------------------------------------
{? VAR.FILTER='T'
||
   _typy:=exec('typy_zlecen','zl_head',VAR.A_WP);
   _where:='"ZL".NRNZL=0';
   {? VAR.S_TPZL='0'
   || _sort:='NRNZL,HIDDEN,STAN,SYM';
      {? FILTER.ZTP<>null()
      || _where+=' and "ZL".TYP=\':_a\''
      || _where+=' and "ZL".TYP in (select :_i.REF from :_i) '
      ?}
   || _sort:='NRNZL,TYP,HIDDEN,STAN,SYM';
      _where+=' and "ZL".TYP=\':_a\''
   ?};
   _where+=' and "ZL".HIDDEN like \':_b%\'';
   {? FILTER.STAN_ZL='X'
   || _where+=' and "ZL".STAN<>\'Z\''
   || _where+=' and "ZL".STAN like \':_c%\''
   ?};
   {? FILTER.JORG<>null()
   || _where+=' and "ZL".JORG=\':_d\''
   ?};
   {? FILTER.GRUPA<>null()
   || _where+=' and "M".MGR=\':_e\''
   ?};
   {? FILTER.WPM<>''
   || _where+=' and "M".R=\':_f\''
   ?};
   {? FILTER.KTM<>null()
   || _where+=' and "ZL".KTM=\':_g\''
   ?};
   _where+=' and "ZL".SYM like \':_h%\'';
   ZL.f_set(_sort, 'left join "M"', _where,
            {? VAR.S_TPZL='0' || $FILTER.ZTP || $VAR.A_TPZL ?},
            FILTER.HIDDEN, FILTER.STAN_ZL,
            $FILTER.JORG, $FILTER.GRUPA, FILTER.WPM,
            $FILTER.KTM, FILTER.SYM, _typy)
?};
~~


\set_filter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Ustawia filtr dla zlecen (wartosci podstawowe przed selekcja)
::  OLd: \set_filter/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.prefix();
ZL.f_clear();
_exit:="
   exec('err_psql','#sql');
   exec('empty_f_set','#table','ZL')
";
_down:='';
{? VAR.S_TPZL='0'
||
   _typy:=exec('typy_zlecen','zl_head',VAR.A_WP);

   {? ~ZL.f_set('SYM'+_down, '',
                '"ZL".NRNZL=0
                and "ZL".TYP in (select :_a.REF from :_a)',
                _typy)
   ||
      _exit()
   ?}
||
   {? ~ZL.f_set('SYM'+_down, '',
                '"ZL".NRNZL=0 and "ZL".TYP=:_a and "ZL".HIDDEN=\':_b\' and "ZL".STAN like \':_c%\'',
                VAR.A_TPZL, VAR.A_HIDDEN, VAR.A_STAN)
   ||
      _exit()
   ?}
?};
~~


\zl_po_red
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: po redakcji pola zlecenia na DK i ZLGD
::       i jeszcze wpisanie ceny wyrobu - tak jak po polu "wyrob",
::       szczegolnie dla wyceny ze zlecenia
::   WE: _a - pole tabeli
::       _b - redagowane pole zmiennej
::       _c - 1 dla dokumentu, wpp. 0
::   WY: 0 / 1
::  OLD: \zl_po_red/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_wynik:=0;
_PoleTab:=$(_a);
_PoleZm:=$(_b);
_PoleRel:=$(_a+'()');
{? _PoleZm()='' & {? _c || ND.TYP().ZLEC='T' || 1 ?}
|| FUN.info('Proszę wypełnić pole.'@);
   _wynik:=0
|| {? _PoleZm()='' & {? _c || ND.TYP().ZLEC='O' || 1 ?}
   || {? _>3
      || _PoleTab():=''
      || _PoleTab():=null()
      ?};
      VAR.A_ZLEC:=null();
      _wynik:=1
   || ZL.cntx_psh();
      ZL.clear();
      ZL.index('SYM');
      {? _c
      ||
         _wynik:=ZL.find_tab(0,'SYM',,'=',_PoleZm(),'STAN',,'=','O')
      || {? cur_afld()='ZL4'
         ||
            ZL.cntx_psh();
            ZL.clear();
            {? ZL.find_tab(0,'SYM',,'=',ZMSLAPP.ZL2)
            || _unrzl:=ZL.UNRZL
            || _unrzl:=0
            ?};
            ZL.cntx_pop();
            _wynik:=ZL.find_tab(0,'SYM',,'=',_PoleZm(),'STAN',,'=','O','NRNZL',,'=',_unrzl)
         ||
            _wynik:=ZL.find_tab(0,'SYM',,'=',_PoleZm(),'STAN',,'=','O','JORG',,'=',ST.A_WYD) |
                    ZL.find_tab(0,'SYM',,'=',_PoleZm(),'STAN',,'=','O','JORG',,'=',null())
         ?}
      ?};
      {? _wynik=0
      || FUN.info('Brak w słowniku otwartego zlecenia o podanym symbolu.'@)
      || {? _c
         ||
::          dokument magazynowy
            _wynik:=exec('_chk_pdp','zl_common',DK.M,ND.MAG,ND.D,ZL.ref())
         ||
::          akord
            ZGH.cntx_psh();
            _wynik1:=1;
            _wynik2:=1;
            ZL.cntx_psh();
            ZL.index('NRNZL');
            ZL.prefix(ZL.UNRZL);
            {? ZL.first()
            || _wynik2:=0;
               {!
               |?
                  {? ZL.STAN='O' || _wynik2:=1 ?};
                  ZL.next()
               !}
            ?};
            {? _wynik1=0
            || FUN.info('To zlecenie ma oddane wszystkie przewodniki.'@);
               _wynik:=0
            |? _wynik1=-1
            || FUN.info('To zlecenie nie ma przewodników.'@);
               _wynik:=0
            |? _wynik2=0
            || FUN.info('To zlecenie nie ma otwartych podzleceń.'@);
               _wynik:=0
            ?};
            {? ZLGD.ZGH().ZLEC<>ZLGD.ZL || ZLGD.ZGH:=null() ?};
            ZL.cntx_pop();
            ZGH.cntx_pop()
         ?};
         {? _>3
         || _PoleTab():=ZL.SYM
         || _PoleTab():=ZL.ref()
         ?};
         VAR.A_ZLEC:=ZL.ref()
      ?};
      ZL.cntx_pop()
   ?}
?};
{? _c
|| {? _wynik=0
   || {? _>3
      || ($_b)():='';_PoleTab():=''
      || ($_b)():='';_PoleTab():=null()
      ?}
   ?}
?};
win_disp();
_wynik


\zl_p_re1
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed redakcja pola zlecenia dla rachuby
::   WY: 0/1
::  OLD: \zl_p_re1/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('in_prod_rej','prod_rej')
|| 0
|? ZLGD.ZL<>null() & VAR.ZAKLADKI*'R'>0
|| 0
|| 1
?}


\zl_f3
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Na F3 do redakcji pola zlecenia.
::   WE: _a: akronim pola tabeli
::       _b: akronim pola zmiennej
::       _c: data
::   WY: 0/1
::  OLD: \zl_f3/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_loop:=0;
ZL.cntx_psh();
ZL.win_sel('SLO_SL');
ZL.actions('SLO_SL','XY','W');
ZL.clear();
ZL.f_clear();
_typy:=exec('typy_zlecen','zl_head');
{? ~ZL.f_set('SYM',,' "ZL"."HIDDEN"=\'N\'
                      and "ZL"."STAN"=\'O\'
                      and "ZL"."NRNZL"=0
                      and ("ZL"."JORG"=:_a or "ZL"."JORG" is null)
                      and ZL.TYP in (select :_b.REF from :_b)
                    ', ST.A_WYD,_typy)
||
   exec('err_psql','#sql');
   VAR.A_ZLEC:=null();
   ZL.cntx_pop();
   return(0)
?};
_PoleTab:=$(_a);
_PoleZm:=$(_b);
{? _<4
|| _PoleRel:=$(_a+'()')
|| _PoleRel:=$(_d)
?};
{? _PoleZm()<>''
|| ZL.f_find(_PoleZm())
|| ZL.f_first()
?};
{!
|?
   {? VAR.P_NKTM:=''; ZL.select(,1)
   || {? ZL.OD>_c
      || FUN.error('Zlecenie powołane z późniejszą datą.'@);
         _loop:=1
      || {? _>3
         || _PoleTab():=ZL.SYM;
            _PoleRel():=ZL.KTM().KTM
         || _PoleTab():=ZL.ref()
         ?};
         VAR.A_ZLEC:=ZL.ref();
         _PoleZm():=ZL.SYM;
         _wynik:=ZL.SYM;
         _loop:=0
      ?}
   || _loop:=0;
      _wynik:=0
   ?};
   _loop
!};
ZL.f_clear();
ZL.cntx_pop();
_wynik


\aktuzl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Aktualizuje stany zleceń (pole ZL.ILDOK), dla dokumentów raportu produkcji i zwrotu na produkcję.
::   WE: _a: ND.ref()
::       _b: 1 - podczas akceptacji dokumentu
::          -1 - podczas wycofania dokumentu
::       _c: [0]/1 - operacja grupowa
::  OLD: \aktuzl/produ.fml
::----------------------------------------------------------------------------------------------------------------------
_group:=0;
{? var_pres('_c')=type_of(0)
|| _group:=_c
?};
DK.index('DOKMAG');
DK.prefix(_a);
{? DK.first()
|| {!
   |? _mnoznik:={? DK.N().TYP().P='T' | exec('is_usluga_typ','zl_uslugi',DK.N().TYP) || 1*_b || -1*_b ?};
      ZL.cntx_psh();
      ZL.clear();
      {? ZL.seek(DK.ZL) || ZL.ILDOK+=_mnoznik*DK.IL; ZL.put() ?};
      {? ZL.NRNZL<>0 & ZL.NR=1
      || _nrn:=ZL.NRNZL;
         ZL.cntx_psh();
         ZL.index('UNRZL');
         ZL.prefix(_nrn);
         {? ZL.first()
         || {? ZL.RODZAJ='Z' | ZL.RODZAJ='N'
            || ZL.ILDOK+=_mnoznik*DK.IL;
               {? ZL.ILDOK<0
               || _txt:='Akceptajca dokumentu spowoduje ujemną ilość wykonaną na zleceniu.'@;
                  {? _group
                  || exec('add_kom','#message',DK.N().SYM,5,gsub(_txt,'\n',' '))
                  || exec('add_kom','#message',_txt,4)
                  ?};
                  undo()
               || {? ~ZL.put()
                  || _txt:='Nie udana próba zapisania informacji na zleceniu.'@;
                     {? _group
                     || exec('add_kom','#message',DK.N().SYM,5,gsub(_txt,'\n',' '))
                     || exec('add_kom','#message',_txt,4)
                     ?};
                     undo()
                  ?}
               ?}
            ?}
         ?};
         ZL.cntx_pop()
      ?};
      ZL.cntx_pop();
      DK.next()
   !}
?};
~~


\zlst
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: nowe stare ZLST
::   WE: _a - ZL.ref
::       [_b] - DATE - data wystawienia dokumentu (od), domyślnie wszystkie
::       [_c] - DATE - data wystawienia dokumentu (do), domyślnie wszystkie
::       [_d] - tryb: [0] - zbiera listę dokumentów do podanego zlecenia w par. _a
::                     1 - zbiera listę zleceń, do których wygenerowano dokumenty w podanym okresie (par. _b i _c)
::   WY: gdy _d=0 to tabela odpowiednik ZLST, gdy _d=1 to tabela z listą refów zleceń
::  OLD: \zlst/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_od:={? var_pres('_b')=type_of(date()) || _b || date(0,0,0) ?};
_do:={? var_pres('_c')=type_of(date()) || _c || date(0,0,0) ?};
_tryb:={? var_pres('_d')=type_of(0) || _d || 0 ?};

_pprod:=exec('tte_lic','tte');
_p500701:=exec('get','#params',500701,2,null());
_mpdoks:=exec('get','#params',500705,2,null());
{? _tryb=1
|| _Zlst:=exec('ref_table','#table')
|| _Zlst:=tab_tmp(1
      ,'ZL'       ,'STRING[16]'  ,'Zlecenie'
      ,'KOD'      ,'STRING[16]'  ,'Materiał'
      ,'IL_00'    ,'REAL'        ,'Ilość pocz.'
      ,'WAR_00'   ,'REAL'        ,'Wartość pocz.'
      ,'IL_P'     ,'REAL'        ,'Ilość pobrana'
      ,'WAR_P'    ,'REAL'        ,'Wartość pobrana'
      ,'IL_Z'     ,'REAL'        ,'Ilość zwrócona'
      ,'WAR_Z'    ,'REAL'        ,'Wartość zwrócona'
      ,'IL'       ,'REAL'        ,'Ilość aktualna'
      ,'WAR'      ,'REAL'        ,'Wartość aktualna'
      ,'OKRES'    ,'STRING[16]'  ,'Okres'
      ,'WYD'      ,'STRING[16]'  ,'Wydział'
      ,'ROK'      ,'INTEGER'     ,'Rok wystawienia dokumentu'
      ,'MC'       ,'INTEGER'     ,'M-c wystawienia dokumentu'
      ,'DOKL'     ,'INTEGER'     ,'Dokładność ilości');
   _ndx1:=_Zlst.ndx_tmp(,,'ZL',,,'WYD',,,'KOD',,,'ROK',,,'MC',,);
   _Zlst.index(_ndx1)
?};

OKR.cntx_psh();
ND.cntx_psh();
DK.cntx_psh();

_Mask:=DK.names();
_loop:=_Mask.first();
{!
|? _loop
|!
   _ok:=1;
   _year:=2000+(#(_Mask.NAME+2));
:: Wykluczenie masek, jeżeli niezgodny przedział datowy
   {? (_od<>date(0,0,0) & _od~1>_year)  | (_do<>date(0,0,0) & _do~1<_year)
   || _ok:=0
   ?};

   {? _ok>0
   || DK.use(_Mask.NAME);
      {? _tryb=1
      || DK.prefix();
         DK.f_set(,,'DK.ZL is not null');
         _loop:=DK.f_first()
      || DK.index('DOKZL');
         DK.prefix(_zl);
         _loop:=DK.first()
      ?}
   || _loop:=0
   ?};
   {!
   |? _loop
   |!
      ND.use(ref_name(DK.N));
      _add:=0;
      DK.N().TYP();
::    Wykluczenie pozycji dokumentu, jeżeli niezgodny przedział datowy
      _ok:=1;
      {? (_od<>date(0,0,0) & _od>ND.D) | (_do<>date(0,0,0) & _do<ND.D)
      || _ok:=0
      ?};
      {? _ok>0
      || {? _pprod='N'
          | {? _pprod='T' & (' '+_mpdoks)*(' '+TYPYDOK.T+' ')=0 & (' '+_p500701)*(' '+TYPYDOK.T+' ')=0
            || TYPYDOK.ZLEC<>'N' & TYPYDOK.WYR<>'T'
            || _pprod='T' & (' '+_mpdoks)*(' '+TYPYDOK.T+' ')>0
            ?}
         || {? _tryb=1
            || _Zlst.add(DK.ZL)
            || OKR.index('OKR');
               OKR.prefix(REF.FIRMA,ND.AR,ND.AM);
               {? OKR.first()
               || _wsp:={? DK.PLUS='T' & (' '+_mpdoks)*(' '+TYPYDOK.T+' ')=0 || -1 || 1 ?};
                  _dokl:=exec('jaka_dok_m','jm',DK.M);
                  {? _Zlst.find_key($DK.ZL,$DK.WYD,$DK.M,OKR.ROK,OKR.MC)
                  || {? _wsp=1
                     || _Zlst.IL_P+=DK.IL $_dokl;
                        _Zlst.WAR_P+=DK.WAR $2
                     || _Zlst.IL_Z+=DK.IL $_dokl;
                        _Zlst.WAR_Z+=DK.WAR $2
                     ?};
                     _Zlst.put()
                  || _Zlst.blank();
                     _Zlst.ZL:=$DK.ZL;
                     _Zlst.KOD:=$DK.M;
                     _Zlst.OKRES:=$OKR.ref();
                     _Zlst.ROK:=OKR.ROK;
                     _Zlst.MC:=OKR.MC;
                     _Zlst.WYD:=$DK.WYD;
                     _Zlst.DOKL:=_dokl;
                     {? _wsp=1
                     || _Zlst.IL_P:=DK.IL $_dokl;
                        _Zlst.WAR_P:=DK.WAR $2
                     || _Zlst.IL_Z:=DK.IL $_dokl;
                        _Zlst.WAR_Z:=DK.WAR $2
                     ?};
                     _Zlst.add()
                  ?};
                  {? _add || _Zlst.add() || _Zlst.put() ?}
               ?}
            ?}
         ?}
      ?};
      _loop:=DK.next()
   !};
   _loop:=_Mask.next()
!};

:: ilość aktualna i stan początkowy
{? _tryb=0
|| _il_00:=_war_00:=0;
   _kod:=_wyd:='';
   _loop:=_Zlst.first();
   {!
   |? _loop
   |!
::    stan początkowy
      {? _Zlst.KOD=_kod & _Zlst.WYD=_wyd
      ||  _Zlst.IL_00:=_il_00;
         _Zlst.WAR_00:=_war_00
      || _kod:=_Zlst.KOD;
         _wyd:=_Zlst.WYD
      ?};
::    stan aktualny
      _Zlst.IL:=(_Zlst.IL_00+_Zlst.IL_P-_Zlst.IL_Z)$_Zlst.DOKL;
      _Zlst.WAR:=(_Zlst.WAR_00+_Zlst.WAR_P-_Zlst.WAR_Z)$2;
      {? _Zlst.put()
      || _il_00:=_Zlst.IL;
         _war_00:=_Zlst.WAR;
         _loop:=_Zlst.next()
      || _loop:=0
      ?}
   !}
?};

DK.cntx_pop();
ND.cntx_pop();
OKR.cntx_pop();
{? _tryb=1 || _Zlst.tab || _Zlst ?}


\dobra_data
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Sprawdza, czy data będąca _a jest w aktywnym okresie/masce i nie w przyszłości
::   WE: _a - data
::       [_b] - bez komunikatu
::       [_c] - blokować?
::   WY: 1 / 0
::  OLD: \dobra_data/produ.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')=type_of(0) || _no_msg:=_b || _no_msg:=0 ?};
{? var_pres('_c')=type_of(0) || _blk:=_c || _blk:=1 ?};
OKR.cntx_psh();
_res:={? _a>date()
      || {? ~_no_msg || choice('Data późniejsza niż dzisiejsza.'@,FUN.TYT,{? _blk || 'ERROR' || 'EXCLAM' ?}) ?};
         ~_blk
      |? _a>=date(ST.AR,ST.AM,1) & _a<=date(ST.AR,ST.AM,0)
      || 1
      || {? ~_no_msg || choice('Data poza bieżącym okresem.'@,FUN.TYT,{? _blk || 'ERROR' || 'EXCLAM' ?}) ?};
         ~_blk
      ?};
OKR.cntx_pop();
_res


\s_nlim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.10]
:: OPIS: Ustawienia pól dla surowców nielimitowanych zlecenia
::  OLD: \s_nlim/pset_var.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.XJM:=exec('FindAndGet','#table',TKTL,#VAR.A_KTL,ref_name(VAR.A_KTL),"XJM",1);
VAR.JM:=VAR.A_ZLEC().KTM().J;
~~


\GetZL_STAN_txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [2011]
:: OPIS: Zwraca nazwe stanu zlecenia
::   WE: [_a] - ZL.STAN
::  OLD: \GetZL_STAN_txt/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_stan:={? _>0 & type_of(_a)=2 || ~-(1+_a) || ZL.STAN ?};

{? _stan='N' || 'w przygotowaniu'@
|? _stan='O' || 'otwarte'@
|? _stan='Z' || 'zamknięte'@
             || ''
?}


\zlpor11w
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [2011]
:: OPIS: Po redakcji pola ZMSLAPP.ZL11W
::  OLD: \zlpor11w/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_wynik:=1;
_prod:=exec('tte_lic','tte');
{? ZMSLAPP.ZL11W<>''
|| ZL.cntx_psh();
   ZL.clear();
   ZL.blank(1);
   ZL.index('HIDDEN');
   _wynik:={? _prod='T'
           || ZL.find_tab(0,'SYM',,'=',ZMSLAPP.ZL11W,'HIDDEN',,'=','N','STAN',,'=','O')
           || ZL.find_tab(0,'SYM',,'=',ZMSLAPP.ZL11W,'HIDDEN',,'=','N','STAN',,'=','O','TYP','TYP','=','~ML')
           ?};
   {? _wynik=0
   || FUN.info('Brak w słowniku otwartego zlecenia o podanym symbolu.'@)
   || {? ZL.OD>ZK_N.DP
      || FUN.info('Zlecenie powołane jest z datą późniejszą niż data przyjęcia zamówienia.'@);
         _wynik:=0
      || ZK_N.ZL:=ZL.ref()
      ?};
      {? _prod='N'
      || ZK_N.WYD:=ZL.JORG
      ?}
   ?};
   ZL.cntx_pop()
|| ZK_N.ZL:=null;
   ZK_N.WYD:=null
?};
win_disp();
_wynik


\zlpor12w
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [2011]
:: OPIS: Po redakcji pola ZMSLAPP.ZL12W
::  OLD: \zlpor12w/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_wynik:=0;
{? ZMSLAPP.ZL12W=''
|| {? ZK_N.ZL().GENLIM='N'
   || _wynik:=1
   || FUN.info('Proszę wypełnić pole.'@);
      _wynik:=0
   ?}
|| ZL.cntx_psh();
   ZL.clear();
   ZL.blank(1);
   ZL.index('STAN');
   _wynik:=ZL.find_tab(0,'SYM',,'=',ZMSLAPP.ZL12W,'HIDDEN',,'=','N','STAN',,'=','O','NRNZL',,'<>',0);
   {? _wynik=0
   || FUN.info('Niepoprawny symbol zlecenia.'@)
   || ZK_N.ZL:=ZL.ref()
   ?};
   ZL.cntx_pop();
   win_disp()
?};
_wynik


\for_each_args
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tablica parametrów dla \for_each_tree
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
       'ZL'
       ,'FORMULA'
       ,'ARGS'
       ,'RESULT'
       ,'EXPECTED'
              );
_args.ZL:=null();
_args.FORMULA:="";
_args.RESULT:=~~;
_args.ARGS:=~~;
_args.EXPECTED:=~~;
_args


\for_each_tree
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Dla podanego zlecenia oraz wszystkich jego podzleceń w strukturze wykonuje podają formułę
::   WE: _args - argumenty funkcji
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('for_each_args','zl_common')
?};

_can_continue:=1;

ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_args.ZL)
||
:: Stoje na przekazanym zleceniu

   _args.RESULT:=_args.FORMULA(_args.ARGS);

   {? type_of(_args.EXPECTED)>0
   || {? _args.RESULT=_args.EXPECTED
      || _can_continue:=1
      || _can_continue:=0
      ?}
   ?};

   {? _can_continue>0
   ||
::    Iteruję po wszystkich podzleceniach danego zlecenia
      ZL.index('ZLTREE');
      ZL.prefix(ZL.TYP,ZL.NODE,ZL.ref());
      {? ZL.first()
      || {!
         |?
            {? var_pres('_args_rec')>100
            || obj_del(_args_rec)
            ?};
            _args_rec:=exec('for_each_args','zl_common');
            _args_rec.ZL:=ZL.ref();
            _args_rec.FORMULA:=_args.FORMULA;
            _args_rec.ARGS:=_args.ARGS;
            _args_rec.EXPECTED:=_args.EXPECTED;

::          !!! REKURENCJA !!!
            exec('for_each_tree','zl_common',_args_rec);

            {? type_of(_args_rec.EXPECTED)>0
            || {? _args_rec.RESULT=_args_rec.EXPECTED
               || _can_continue:=1
               || _can_continue:=0
               ?}
            ?};
            {? var_pres('RESULT',_args)>100
            || obj_del(_args.RESULT)
            ?};
            _args.RESULT:=_args_rec.RESULT;
            ZL.next() & _can_continue>0
         !}
      ?}
   ?}
?};
ZL.cntx_pop();
~~


\zlpo_p1w
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [2011]
:: OPIS: po redakcji pola zlecenia na ZK_P,
::       dodatkowo automatyczna podpowiedz wyrobu ze zlecenia
::       i jeszcze wpisanie ceny wyrobu - tak jak po polu "wyrob",
::       ktore tu nieredagowalne
::   WE: kontekst pozycji dokumentu
::   WY: 0 / 1
::  OLD: \zlpo_p1w/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_wynik:=0;
_prod:=exec('tte_lic','tte');
_sym:=ZK_P.ZL().SYM;
{? ZMSLAPP.ZL1W='' &  {? ZK_N.T().TYPYDOK<>null || ZK_N.T().TYPYDOK().ZLEC='T' || 0 ?}
|| FUN.info('Proszę wypełnić pole.'@)
|? ZMSLAPP.ZL1W<>''
|| ZL.cntx_psh();
   ZL.clear();
   ZL.index('SYM');
    _wynik:={? _prod='T'
            || ZL.find_tab(0,'SYM',,'=',ZMSLAPP.ZL1W,'NRNZL',,'=',0)
            || ZL.find_tab(0,'SYM',,'=',ZMSLAPP.ZL1W,'NRNZL',,'=',0,'TYP','TYP','=','~ML')
            ?};
    {? _wynik=0
    || FUN.info('Brak w słowniku otwartego zlecenia o podanym symbolu.'@)
    || {? ZL.OD>ZK_N.DP
       || FUN.info('Zlecenie powołane jest z datą późniejszą niż data dokumentu.'@);
          _wynik:=0
       |? _sym*ZMSLAPP.ZL1W<=0
       ||
         {? ZL.RODZAJ='P'
         || ZK_P.ZL:=ZL.ref();
            {? {? ZK_N.T().TYPYDOK<>null || ZK_N.T().TYPYDOK().WYR='T' || 1 ?}
            || ZK_P.WYD:=ZL.JORG
            ?};
            _wynik:=1
         || ZK_P.ZL:=ZL.ref();
            {? ZK_P.WYD=null || ZK_P.WYD:=ZL.JORG ?}
         ?}
        ?}
    ?};
    ZL.cntx_pop()
|| ZK_P.ZL:=null;
   ZK_P.WYD:=null;
   _wynik:=1
?};
win_disp();
_wynik


\po_zl7w
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [2011]
:: OPIS: po redakcji pola zlecenia podrzędnego na PDP,
::       dodatkowo automatyczna podpowiedź wyrobu ze zlecenia
::       i jeszcze wpisanie ceny wyrobu - tak jak po polu "wyrób",
::       które tu nieredagowalne
::   WE: kontekst pozycji dokumentu
::   WY: 0 / 1
::  OLD: \po_zl7w/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_wynik:=0;
{? ZMSLAPP.ZL7W=''
|| {? ZK_P.ZL().GENLIM='N'
   || _wynik:=1
   || FUN.info('Proszę wypełnić pole.'@);
      _wynik:=0
   ?}
|| ZL.cntx_psh();
   ZL.clear();
   ZL.index('SYM');
   _wynik:=ZL.find_tab(0,'SYM',,'=',ZMSLAPP.ZL7W,'NRNZL',,'<>',0);
   {? _wynik=0
   || FUN.info('Niepoprawny symbol zlecenia.'@)
   || ZK_P.ZL:=ZL.ref();
      _wynik:=1
   ?};
   ZL.cntx_pop()
?};
win_disp();
_wynik


\ilezl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Ile z półfabrykatu znajduje się na zleceniu.
::   WE: _a - TMAT.ref() - półfabrykat na technologii
::       _b - REAL - ZL.UNRZL - zlecenie poziom wyżej
::  OLD: \ilezl/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_tmat:=_a;
_unrzl:=_b;

_ilzl:=0;
ZL.cntx_psh();
ZL.index('TMAT_SRC');
ZL.prefix(_unrzl,_tmat);
{? ZL.first()
|| {!
   |? _ilzl+=ZL.IL;
      ZL.next()
   !}
?};
ZL.cntx_pop();
_ilzl


\GetZLref4UNRZL
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [2011]
:: OPIS: Zwraca ZL.ref() dla podanej wartości ZL.UNRZL
::   WE: _a - ZL.UNRZL
::   WY: ZL.ref() lub null()
::  OLD: \GetZLref4UNRZL/skid_zlc.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=null();
{?_>0 & type_of(_a)=1 & _a>0
|| ZL.cntx_psh();
   ZL.index('UNRZL');
   ZL.prefix(_a);
   {? ZL.first() || _result:=ZL.ref() ?};
   ZL.cntx_pop()
?};
_result


\akt_terminy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Aktualizacja terminow realizacji na zleceniach podrzednych
::   WE: _a - poprzednia zawartość bufora tabeli ZL
::       _b - czy wywołanie z dialogami?
::  OLD: \akt_terminy/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_buffer:=_a;
_dialog:=_b;

:: Określona data początkowa - nanosimy na zapotrzebowania
{? ZL.STARTD=date(0,0,0)
||
   {? ZL.NRNZL=0 & (ZL.RODZAJ='Z' | ZL.RODZAJ='N')
   || {? ZL.DTR<>_buffer.DTR | ZL.PL_DATA<>_buffer.PL_DATA | ZL.PL_TIME<>_buffer.PL_TIME
      || _has_lim:=0;
         _has_podzl:=0;
         _zlref:=ZL.UNRZL;
         ZL.cntx_psh();
         ZL.index('NRNZL');
         ZL.prefix(_zlref);
         {? ZL.first()
         || _has_podzl:=1;
            {!
            |? exec('openmask','zl_common',ZL.ref());
               ZLIM.index('ZKN');
               ZLIM.prefix(ZL.ref());
               {? ZLIM.first()
               || _has_lim:=1
               ?};
               _has_lim=0 & ZL.next()
            !}
         ?};
         ZL.cntx_pop();

         ZL.cntx_psh();
         ZL.index('NRNZL');
         ZL.prefix(_zlref);
         {? _has_podzl>0 &
            {? _dialog
            || FUN.ask(
                  {? _has_lim
                  || 'Czy zmiany terminów realizacji zlecenia nanieść na zlecenia podrzędne i zapotrzebowania?'@
                  || 'Czy zmiany terminów realizacji zlecenia nanieść na zlecenia podrzędne?'@
                  ?}
               )
            || 1
            ?}
         || _dtr:=ZL.DTR;
            _pl_data:=ZL.PL_DATA;
            _pl_time:=ZL.PL_TIME;
            {? ZL.first()
            || {!
               |? ZL.DTR:=_dtr;
                  ZL.PL_DATA:=_pl_data;
                  ZL.PL_TIME:=_pl_time;
                  ZL.put();
::                Aktualizacja zapotrzebowań
                  {? _has_lim>0
                  || exec('openmask','zl_common',ZL.ref());
                     ZLIM.index('ZKN');
                     ZLIM.prefix(ZL.ref());
                     {? ZLIM.first()
                     || {!
                        |? ZLIM.STARTD:=ZL.PL_DATA;
                           ZLIM.STARTT:=ZL.PL_TIME;
                           {? ZLIM.put()
                           || exec('zkp_date_upd','zamsiw_limit',ZLIM.ref())
                           ?};
                           ZLIM.next()
                        !}
                     ?}
                  ?};
::                Aktualizacja obiektu planowanego dotyczacego zlecenia
                  exec('zl2obj','px_obj',ZL.ref());
                  ZL.next()
               !}
            ?}
         ?};
         ZL.cntx_pop()
      ?}
   || {? ZL.DTR<>_buffer.DTR | ZL.PL_DATA<>_buffer.PL_DATA | ZL.PL_TIME<>_buffer.PL_TIME
      || exec('openmask','zl_common',ZL.ref());
         ZLIM.index('ZKN');
         ZLIM.prefix(ZL.ref());
         {? ZLIM.first()
         || {? {? _dialog
               || FUN.ask('Czy zmiany terminów realizacji zlecenia nanieść na zapotrzebowania?'@)
               || 1
               ?}
            || {!
               |? ZLIM.STARTD:=ZL.PL_DATA;
                  ZLIM.STARTT:=ZL.PL_TIME;
                  {? ZLIM.put()
                  || exec('zkp_date_upd','zamsiw_limit',ZLIM.ref())
                  ?};
                  ZLIM.next()
               !}
            ?}
         ?}
      ?}
   ?}

:: Brak daty początkowej - nie ma potrzeby aktualizacji zapotrzebowań
|| {? ZL.NRNZL=0 & (ZL.RODZAJ='Z' | ZL.RODZAJ='N')
   || {? ZL.DTR<>_buffer.DTR | ZL.PL_DATA<>_buffer.PL_DATA | ZL.PL_TIME<>_buffer.PL_TIME
      || {? {? _dialog
            || FUN.ask('Czy zmiany terminów realizacji zlecenia nanieść na zlecenia podrzędne?'@)
            || 1
            ?}
         || _zlref:=ZL.UNRZL;
            _dtr:=ZL.DTR;
            _pl_data:=ZL.PL_DATA;
            _pl_time:=ZL.PL_TIME;
            ZL.cntx_psh();
            ZL.index('NRNZL');
            ZL.prefix(_zlref);
            {? ZL.first()
            || {!
               |? ZL.DTR:=_dtr;
                  ZL.PL_DATA:=_pl_data;
                  ZL.PL_TIME:=_pl_time;
                  ZL.put();
::                Aktualizacja obiektu planowanego dotyczacego zlecenia
                  exec('zl2obj','px_obj',ZL.ref());
                  ZL.next()
               !}
            ?};
            ZL.cntx_pop()
         ?}
      ?}
   ?}
?};
~~


\akt_plany
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Aktualizacja terminow planowanych na zleceniach podrzednych, przewodnikach i limitach
::   WE: _a - poprzednia wartosc ZL.STARTD
::       _b - poprzednia wartosc ZL.STARTT
::       _c - poprzednia wartosc ZL.ENDD
::       _d - poprzednia wartosc ZL.ENDT
::       _e - czy wywołanie z dialogami
::       Kontekst wywolania - rekord tabeli ZL
::  OLD: \akt_plany/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_dialog:=_e;

{? ZL.STARTD<>_a | ZL.STARTT<>_b | ZL.ENDD<>_c | ZL.ENDT<>_d
|| {? ZL.NRNZL=0 & (ZL.RODZAJ='Z' | ZL.RODZAJ='N')
   || {? {? _dialog
         || FUN.ask('Czy zmiany planowanej realizacji zlecenia nanieść na zlecenia podrzędne, przewodniki i limity?'@)
         || 1
         ?}
      || _zlref:=ZL.UNRZL;
         _startd:=ZL.STARTD;
         _startt:=ZL.STARTT;
         _endd:=ZL.ENDD;
         _endt:=ZL.ENDT;
         ZL.cntx_psh();
         ZL.index('NRNZL');
         ZL.prefix(_zlref);
         {? ZL.first()
         || {!
            |? ZL.STARTD:=_startd;
               ZL.STARTT:=_startt;
               ZL.ENDD:=_endd;
               ZL.ENDT:=_endt;
               ZL.put();
               exec('akt_zgh_plany','zl_guide',ZL.ref());
               ZL.next()
            !}
         ?};
         ZL.cntx_pop();
         exec('akt_zgh_plany','zl_guide',ZL.ref())
      ?}
   || {? {? _dialog
         || FUN.ask('Czy zmiany planowanej realizacji zlecenia nanieść na przewodniki i limity?'@)
         || 1
         ?}
      || exec('akt_zgh_plany','zl_guide',ZL.ref())
      ?}
   ?}
?};
~~


\akt_znaczniki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Aktualizacja znaczników dotyczących planowania na zleceniach podrzędnych
::       Obecnie aktualizowane pole ZL.PL_FORCE - bez dodatkowych pytań
::   WE: _a - poprzednia wartość pola ZL.PL_FORCE
::       _b - poprzednia wartość pola ZL.PL_DIR
::  OLD: \akt_znaczniki/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZL.PL_FORCE<>_a | ZL.PL_DIR<>_b
|| {? ZL.NRNZL=0 & (ZL.RODZAJ='Z' | ZL.RODZAJ='N')
   || _pl_force:=ZL.PL_FORCE;
      _pl_dir:=ZL.PL_DIR;
      _zlref:=ZL.UNRZL;
      ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(_zlref);
      {? ZL.first()
      || {!
         |? ZL.PL_FORCE:=_pl_force;
            ZL.PL_DIR:=_pl_dir;
            {? ZL.put()
            || exec('zl2obj','px_obj')
            ?};
            ZL.next()
         !}
      ?};
      ZL.cntx_pop()
   ?}
?};
~~


\akt_projekty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.14]
:: OPIS: Aktualizacja projektów na zleceniach podrzędnych
::       Obecnie aktualizowane pole ZL.PROJEKTY - bez dodatkowych pytań
::   WE: _a - poprzednia wartość pola ZL.PROJEKTY
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_can_continue:=1;
ZTP.cntx_psh();
{? ZL.PROJEKTY<>_a
|| _can_continue:=1;
   {? exec('ile_podzlec','zl_link',ZL.ref())>0
   || _projekty:=ZL.PROJEKTY;
      _jorg:=ZL.JORG;
      _kh:=ZL.KH;
      _zlref:=ZL.ref();
      ZL.cntx_psh();
      ZL.index('TREEMTU');
      ZL.prefix(_zlref);
      {? ZL.first()
      || {!
         |? ZL.PROJEKTY:=_projekty;

            {? ZL.TYP().PROJWJO='T'
            || ZL.JORG:=_jorg
            ?};
            {? ZL.TYP().PROJZKH='T'
            || ZL.KH:=_kh
            ?};
            _can_continue:=ZL.put();

            {? _can_continue>0
            ||
::             !!! REKURENCJA !!!
               _can_continue:=exec('akt_projekty','zl_common',_a)
            ?};
            ZL.next() & _can_continue>0
         !}
      ?};
      ZL.cntx_pop()
   ?}
?};
ZTP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\zlec_m_stan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Stan zlecenia w programie EMAG (bez współpracy z PRODUKCJA)
::       oraz podgląd w szczegolach analizy zlecenia w programie PRODUKCJA
::       Konteskt wywołania - rekord tabeli ZL
::   WE: [_a]: 0 - w programie EMAG, 1 - analiza w programie PRODUKCJA
::   WY: dla _a=0: ~~; dla _a=1: [1] - tabela, [2] - okno wertowania
::  OLD: \zlec_m_stan/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
:: TODO: jeśli nie wystąpi wywołanie _a=0, to przenieść do %drill_...
{? _<1 || _a:=0 ?};

_zl:=tab_tmp(1,'REF','STRING[16]','$ZL.ref()');

ZL.cntx_psh();
{? ZL.NRNZL<>0 & ZL.GENLIM='N'
|| ZL.index('UNRZL');
   ZL.prefix(ZL.NRNZL);
   {? ZL.first()
   || _zl.REF:=$ZL.ref();
      _zl.add()
   ?}
|? ZL.NRNZL<>0 & ZL.GENLIM='P' | ZL.NRNZL=0 & ZL.GENLIM='N'
|| _zl.REF:=$ZL.ref();
   _zl.add()
|? ZL.NRNZL=0 & ZL.GENLIM='P'
|| ZL.cntx_psh();
   ZL.index('NRNZL');
   ZL.prefix(ZL.UNRZL);
   {? ZL.first()
   || {!
      |? _zl.REF:=$ZL.ref();
         _zl.add();
         ZL.next()
      !}
   ?};
   ZL.cntx_pop()
?};
ZL.cntx_pop();

exec('openmask','zl_common',ZL.ref());

VAR_DEL.delete('__ZLST');
exec('slo_m_ok','material','T',0,'P');
ZAKR.MATU:='A';

__ZLST:=obj_new(2);

__ZLST[1]:=tab_tmp(5,
   'PARENT','TREE_REF','',
   'KTM','STRING[50]','KTM',
   'WYD','STRING[8]','Wydział',
   'ROK','INTEGER','Rok',
   'MC','INTEGER','Miesiąc',
   'TREE_LAB','STRING[20]','',
   'N','STRING[100]','Nazwa',
   'M_REF','STRING[16]','$M.ref()',
   'IL_00','REAL','',
   'WAR_00','REAL','',
   'IL_P','REAL','',
   'WAR_P','REAL','',
   'IL_Z','REAL','',
   'WAR_Z','REAL','',
   'IL','REAL','',
   'WAR','REAL','',
   'OKRES','STRING[20]','Okres'
);

Cntx.psh(ND,DK);

_rule:="
   ND.use('nagdo'+(DK.name()+3));
   _zl:=_b.ZL;
   _res:=_b.RES;
   _zl.clear();
   {? _zl.first()
   || {!
      |?
         DK.index('DOKZL');
         DK.prefix(BIT.sqlint(_zl.REF));
         {? DK.first()
         || {!
            |? {? DK.N().TYP().ZLEC='T' & TYPYDOK.WYR='N'
               || _ktm:=DK.M().KTM;
                  _wyd:=DK.WYD().KOD;
                  _rok:=DK.AR;
                  _mc:=DK.N().AM;

                  _res.prefix(0,_ktm,_wyd,_rok,_mc);
                  {? _res.first()
                  || _res.IL_P+={? DK.PLUS='T' || 0 || DK.IL ?};
                     _res.IL_Z+={? DK.PLUS='T' || DK.IL || 0 ?};
                     _res.WAR_P+={? DK.PLUS='T' || 0 || DK.WAR ?};
                     _res.WAR_Z+={? DK.PLUS='T' || DK.WAR || 0 ?};
                     _res.put()
                  || _res.IL_P:={? DK.PLUS='T' || 0 || DK.IL ?};
                     _res.IL_Z:={? DK.PLUS='T' || DK.IL || 0 ?};
                     _res.WAR_P:={? DK.PLUS='T' || 0 || DK.WAR ?};
                     _res.WAR_Z:={? DK.PLUS='T' || DK.WAR || 0 ?};
                     _res.M_REF:=$DK.M;
                     _res.KTM:=DK.M().KTM;
                     _res.N:=M.N;
                     _res.WYD:=DK.WYD().KOD;
                     _res.ROK:=DK.AR;
                     _res.MC:=DK.N().AM;
                     _res.OKRES:=$_res.ROK+'/'+form(_res.MC,-2,0,'9.');
                     _res.add()
                  ?}
               ?};

               DK.next()
            !}
         ?};
         _zl.next()
      !}
   ?}
";

_param:=obj_new('ZL','RES');
_param.ZL:=_zl;
_param.RES:=__ZLST[1];
exec('for_each_mask','#table',DK,_rule,,,_param);

Cntx.pop(ND,DK);

__ZLST[1].prefix();
__ZLST[1].fld_fml('IL_00','EDIT_FORMAT',
   "'in_prec='+{? (2+cur_kwin())='e_' || $exec('FindAndGet','#table',M,__ZLST[1].M_REF,,\"DOKL\",ST.DOKL) || $ST.DOKL ?}");
__ZLST[1].fld_fml('IL_00','DISPLAY_FORMAT',
   "'out_prec='+{? (2+cur_kwin())='e_' || $exec('FindAndGet','#table',M,__ZLST[1].M_REF,,\"DOKL\",ST.DOKL) || $ST.DOKL ?}");
__ZLST[1].fld_fml('IL_P','EDIT_FORMAT',
   "'in_prec='+{? (2+cur_kwin())='e_' || $exec('FindAndGet','#table',M,__ZLST[1].M_REF,,\"DOKL\",ST.DOKL) || $ST.DOKL ?}");
__ZLST[1].fld_fml('IL_P','DISPLAY_FORMAT',
   "'out_prec='+{? (2+cur_kwin())='e_' || $exec('FindAndGet','#table',M,__ZLST[1].M_REF,,\"DOKL\",ST.DOKL) || $ST.DOKL ?}");
__ZLST[1].fld_fml('IL_Z','EDIT_FORMAT',
   "'in_prec='+{? (2+cur_kwin())='e_' || $exec('FindAndGet','#table',M,__ZLST[1].M_REF,,\"DOKL\",ST.DOKL) || $ST.DOKL ?}");
__ZLST[1].fld_fml('IL_Z','DISPLAY_FORMAT',
   "'out_prec='+{? (2+cur_kwin())='e_' || $exec('FindAndGet','#table',M,__ZLST[1].M_REF,,\"DOKL\",ST.DOKL) || $ST.DOKL ?}");

_sum:=sql('
   select
      :_a.M_REF,
      :_a.KTM,
      :_a.N,
      :_a.WYD,
      sum(:_a.IL_P) as IL_P,
      sum(:_a.IL_Z) as IL_Z,
      sum(:_a.WAR_P) as WAR_P,
      sum(:_a.WAR_Z) as WAR_Z
   from :_a
   group by M_REF,KTM,N,WYD
',__ZLST[1]);

{? _sum.first()
|| {!
   |? __ZLST[1].blank();
      __ZLST[1].M_REF:=_sum.M_REF;
      __ZLST[1].KTM:=_sum.KTM;
      __ZLST[1].N:=_sum.N;
      __ZLST[1].WYD:=_sum.WYD;
      __ZLST[1].IL_P:=_sum.IL_P;
      __ZLST[1].IL_Z:=_sum.IL_Z;
      __ZLST[1].WAR_P:=_sum.WAR_P;
      __ZLST[1].WAR_Z:=_sum.WAR_Z;
      __ZLST[1].add();
      _sum.next()
   !}
?};

_ndx:=__ZLST[1].index('?');
__ZLST[1].index(__ZLST[1].ndx_tmp(,,'KTM',,,'WYD',,));
{? __ZLST[1].first()
|| {!
   |?
      {? __ZLST[1].ROK=0
      || _parent:=__ZLST[1].ref();
         __ZLST[1].cntx_psh();
         __ZLST[1].prefix(__ZLST[1].KTM,__ZLST[1].WYD,);
         {? __ZLST[1].first()
         || {!
            |?
               {? __ZLST[1].ROK<>0
               || __ZLST[1].PARENT:=_parent;
                  __ZLST[1].TREE_LAB:=__ZLST[1].OKRES;
                  __ZLST[1].put()
               || __ZLST[1].TREE_LAB:=__ZLST[1].KTM;
                  __ZLST[1].put()
               ?};
               __ZLST[1].next()
            !}
         ?};
         __ZLST[1].cntx_pop()
      ?};
      __ZLST[1].next()
   !}
?};
__ZLST[1].index(_ndx);

__ZLST[1].prefix(0);
{? __ZLST[1].first()
|| {!
   |?
      _il:=0;
      _war:=0;
      __ZLST[1].cntx_psh();

      __ZLST[1].prefix(#__ZLST[1].ref());
      {? __ZLST[1].first()
      || {!
         |? __ZLST[1].IL_00:=_il;
            __ZLST[1].WAR_00:=_war;
            _il:=_il+__ZLST[1].IL_P-__ZLST[1].IL_Z;
            _war:=_war+__ZLST[1].WAR_P-__ZLST[1].WAR_Z;
            __ZLST[1].IL:=_il;
            __ZLST[1].WAR:=_war;
            __ZLST[1].put();
            __ZLST[1].next()
         !}
      ?};

      __ZLST[1].cntx_pop();
      __ZLST[1].IL_00:=0;
      __ZLST[1].WAR_00:=0;
      __ZLST[1].IL:=_il;
      __ZLST[1].WAR:=_war;
      __ZLST[1].put();
      __ZLST[1].next()
   !}
?};

__ZLST[1].clear();

__ZLST[2]:=__ZLST[1].mk_sel('Stany zlecenia'@,'P',0,'stanyzlecenia',,10,,1);
__ZLST[1].win_fld(__ZLST[2],,'TREE_LAB',,,,,,'Indeks / okres'@);
__ZLST[1].win_fld(__ZLST[2],,'N',,,27,,,'Nazwa materiału'@);
__ZLST[1].win_fld(__ZLST[2],,'IL_00',,,-15,ST.DOKL,,'Stan początkowy'@);
__ZLST[1].win_fld(__ZLST[2],,'IL_P',,,-15,ST.DOKL,,'Pobrano'@);
__ZLST[1].win_fld(__ZLST[2],,'IL_Z',,,-15,ST.DOKL,,'Zwrócono'@);
__ZLST[1].win_fld(__ZLST[2],,'IL',,,-15,ST.DOKL,,'Stan końcowy'@);
__ZLST[1].win_fld(__ZLST[2],,'WYD',,,,,,'Wydział'@);
__ZLST[1].win_act(__ZLST[2],,'Formuła','Zwiń/roz&wiń'@@,,'Zwiń/rozwiń wszystkie rekordy'@,
   "exec('zwrw_all','#tree','__ZLST[1]','PARENT',__ZLST[2])",,,,,,'W');
::__ZLST[1].win_act(__ZLST[2],,'Formuła','dokuMenty',,,"exec('zlst_dok','dokmag')",,1);
__ZLST[1].win_sel(__ZLST[2]);

__ZLST[1].win_fml(__ZLST[2],__ZLST[1],'TREE_LAB',,'ICON_BEFORE',"
   {? __ZLST[1].PARENT=0
   || {? __ZLST[1].tr_state()=1
      || 'xwin16.png:75'
      || 'xwin16.png:74'
      ?}
   || 'xwin16.png:118'
   ?}
");

{? _a
|| _res:=__ZLST
|| __ZLST[1].select();
   _res:=~~
?};

obj_del(__ZLST);
M.f_clear();
_res


\has_zlgd
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy zlecenie ma wykonania do przewodnikow (ZLGD)
::   WE: _a - ZL.ref()
::   WY: 0 - brak wykonan
::       1 - sa wykonania
::  OLD: \has_zlgd/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=0;
_can_continue:=1;

_rule:="exec('has_zlgd4mask','zl_common',_b)";

ZL.cntx_psh(); ZL.clear();
{? ZL.seek(_zl)
||
   _sub_zlec:=exec('subzlec_exist','zl_link',ZL.ref());
   {? _sub_zlec=0
   ||
::    Zlecenie bez podrzednych
      _args:=exec('has_zlgd4mask_a','zl_common');
      _args.ZL:=ZL.ref();
::    Sprawdzam czy sa ZLGD we wszystkich maskach
      _name:=ZLGD.name()-3;
      _msk_start:=_name+ZL.ODDZ+(2-$(ZL.OD~1));
      _msk_end:=~~;
      {? ZL.STAN='Z'
      || _rok:=exec('max','#math',ZL.ROK_MAX,ZL.DO~1);
         _msk_end:=_name+ZL.ODDZ+(2-$(_rok))
      || _rok:=exec('max','#math',ZL.ROK_MAX,date()~1,ST.AR);
         _msk_end:=_name+ZL.ODDZ+(2-$(_rok))
      ?};
      exec('for_each_mask','#table',ZLGD,_rule,_msk_start,_msk_end,_args);
      {? _args.ILOSC>0
      || _result:=1
      ?}
   ||
::    Zlecenie zlozone z podzleceniami
      ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |?
            {? var_pres('_args')>100
            || obj_del(_args)
            ?};
            _args:=exec('has_zlgd4mask_a','zl_common');
            _args.ZL:=ZL.ref();
::          Sprawdzam czy sa ZLGD we wszystkich maskach
            _name:=ZLGD.name()-3;
            _msk_start:=_name+ZL.ODDZ+(2-$(ZL.OD~1));
            _msk_end:=~~;
            {? ZL.STAN='Z'
            || _rok:=exec('max','#math',ZL.ROK_MAX,ZL.DO~1);
               _msk_end:=_name+ZL.ODDZ+(2-$(_rok))
            || _rok:=exec('max','#math',ZL.ROK_MAX,date()~1,ST.AR);
               _msk_end:=_name+ZL.ODDZ+(2-$(_rok))
            ?};
            exec('for_each_mask','#table',ZLGD,_rule,_msk_start,_msk_end,_args);
            {? _args.ILOSC>0
            || _result:=1;
               _can_continue:=0
            ?};
            ZL.next() & _can_continue>0
         !}
      ?};
      ZL.cntx_pop()
   ?}
?};
ZL.cntx_pop();
_result


\has_zlgd4mask_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Tablica parametrów dla \has_zlgd4mask
::   WY: _args
::  OLD: \has_zlgd4mask_a/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('ZL'
               ,'ILOSC'
              );

_args.ZL:=null();
_args.ILOSC:=0;
_args


\has_zlgd4mask
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS:
::   WE: _args
::   WY:
::  OLD: \has_zlgd4mask/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('has_zlgd4mask_a','zl_common')
?};

ZLGD.cntx_psh();
ZLGD.index('ZLECENIE');
ZLGD.prefix(_args.ZL);
{? ZLGD.size()>0
|| _args.ILOSC+=ZLGD.size()
?};
ZLGD.cntx_pop();
~~


\has_dokumenty
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy dla zlecenia sa wystawione naglowki dokumentow magazynowych we wszystkich maskach
::   WE: _a - obj_new() - argumenty funkcji - wynik działania exec('has_dok4mask_a','zl_common')
::   WY: 0 - brak naglowkow dokumentow dla zlecenia
::       1 - istnieja jakies naglowki dokumentow dla zlecenia
::  OLD: \has_dokumenty/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>0
|| _args:=_a
|| _args:=exec('has_dok4mask_a','zl_common')
?};

_result:=0;

ZL.cntx_psh(); ZL.clear();
{? ZL.seek(_args.ZL)
||
:: Zliczam ilosc dla zlecenia w dokumentach z masek od powolania zlecenia

   _name:=5+ND.name();
   _msk_start:=_name+ZL.ODDZ+(2-$(ZL.OD~1));
   _msk_end:=~~;
   {? ZL.STAN='Z'
   || _rok:=exec('max','#math',ZL.ROK_MAX,ZL.DO~1);
      _msk_end:=_name+ZL.ODDZ+(2-$(_rok))
   || _rok:=exec('max','#math',ZL.ROK_MAX,date()~1,ST.AR);
      _msk_end:=_name+ZL.ODDZ+(2-$(_rok))
   ?};
:: Formula do wykonania w kazdej masce DK poczawszy od maski poczatkowej
   _rule:="exec('has_dok4mask','zl_common',_b)";

:: Sprawdzam istnienie naglowkow we wszystkich maskach, jesli w ktorejs sie znajdzie to
:: petla sie przerywa a for_each_mask zwraca 0
   {? exec('for_each_mask','#table',ND,_rule,_msk_start,_msk_end,_args,0)=0
   || _result:=1
   || _result:=0
   ?};
   ~~
?};
ZL.cntx_pop();
_result


\has_dok4mask_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Tablica parametrów dla has_dok4mask
::   WY: _args
::  OLD: \has_dok4mask_a/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new( 'blank'
               ,'ZL'
::               INTEGER - 0/1 sprawdzac dokumenty klasy RP
               ,'RP'
::               INTEGER - 0/1 sprawdzac dokumenty klasy RW
               ,'RW'
::               INTEGER - 0/1 sprawdzac dokumenty klasy ZW
               ,'ZW'
::               INTEGER - 0/1 sprawdzac dokumenty klasy ZP
               ,'ZP'
::              INTEGER - Jaki status akceptacji dokumentów brać pod uwagę:
::                0 - sprawdzac wszystkie dokumenty, nie wazne czy zaakceptowane czy nie
::                1 - sprawdzac tylko zaakceptowane dokumenty
::                2 - sprawdzac tylko niezaakceptowane dokumenty
               ,'AKC');
:: - - - - ponizej ustawienie wartosci domyslnych
_args.blank:="
       .ZL:=null();
       .RW:=0;
       .RP:=0;
       .ZP:=0;
       .ZW:=0;
       .AKC:=0;
       ~~
      ";
:: - - - - koniec ustalania wartosci domyslnych
_args.blank();
_args


\has_dok4mask
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy w aktualnie otwartej masce zlecenie ma jakies naglowki dokumentow
::   WE: _a - obj_new() - argumenty funkcji - wynik działania exec('has_dok4mask_a','zl_common')
::   WY: 0 - brak naglowkow dokumentow dla zlecenia
::       1 - istnieja jakies naglowki dokumentow dla zlecenia
::  OLD: \has_dok4mask/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('has_dok4mask_a','zl_common')
?};

_result:=0;

ND.cntx_psh();
ND.index('NAGZL');
ND.prefix(_args.ZL);
{? ND.first()
|| {!
   |?
      _can_continue:=1;

      {? _args.AKC>0
      ||
::       Sprawdzam status akceptacji dokumentu
         {? _args.AKC=1
         ||
::          Sprawdzam czy dokument jest zaakceptowany
            {? ND.Z='N'
            || _can_continue:=0
            ?}
         |? _args.AKC=2
         ||
::          Sprawdzam czy dokument jest niezaakceptowany
            {? ND.Z='T'
            || _can_continue:=0
            ?}
         ?}
      ?};

      {? _can_continue>0
      ||
         {? _args.RW=0 & _args.ZW=0 & _args.RP=0 & _args.ZP=0
         ||
::          Nie sprawdzam typu dokumentu, po prostu do wyniku dodaje ilosc
            _result:=1
         ||
::          Typy dokumentow ktore sprawdzac zostaly okreslone w argumentach
            {? _args.RW>0
            || {? exec('nd_is_rw','magdok_wspolne',ND.ref())>0
               || _result:=1
               ?}
            ?};
            {? _args.RP>0
            || {? exec('nd_is_rp','magdok_wspolne',ND.ref())>0
               || _result:=1
               ?}
            ?};
            {? _args.ZP>0
            || {? exec('nd_is_zp','magdok_wspolne',ND.ref())>0
               || _result:=1
               ?}
            ?};
            {? _args.ZW>0
            || {? exec('nd_is_zw','magdok_wspolne',ND.ref())>0
               || _result:=1
               ?}
            ?}
         ?}
      ?};
      ND.next() & _result=0
   !}
?};
ND.cntx_pop();
_result


\get_ilosc_dk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca ilość dla ustalonych parametrów (zlecenie, przewodnik...),
::       która jest w jakis sposob powiazana na dokumentach magazynowych we wszystkich maskach
::   WE: _a - obj_new() - argumenty funkcji - wynik działania exec('ilosc_dk_a','zl_common')
::   WY: REAL - ilosc wykonana dla partii
::  OLD: \get_ilosc_dk/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('ilosc_dk_a','zl_common')
?};

_args.RESULT:=0;
_result:=0;

ZL.cntx_psh(); ZL.clear();
{? ZL.seek(_args.ZL)
||
   {? _args.RP>0 | _args.ZP>0
   || _args.M:=ZL.KTM
   ?};

:: Zliczam ilosc dla zlecenia w dokumentach z masek od powolania zlecenia
   _name:=5+DK.name();
   _msk_start:=_name+ZL.ODDZ+(2-$(ZL.OD~1));
   _msk_end:=~~;
   {? ZL.STAN='Z'
   || _rok:=exec('max','#math',ZL.ROK_MAX,ZL.DO~1);
      _msk_end:=_name+ZL.ODDZ+(2-$(_rok))
   || _rok:=exec('max','#math',ZL.ROK_MAX,date()~1,ST.AR);
      _msk_end:=_name+ZL.ODDZ+(2-$(_rok))
   ?};

:: Formula do wykonania w kazdej masce DK poczawszy od maski poczatkowej
   _rule:="exec('ilosc_dk','zl_common',_b)";

:: Zliczam ilosc dla zlecenia na DK w kazdej masce
   exec('for_each_mask','#table',DK,_rule,_msk_start,_msk_end,_args);

   _result:=_args.RESULT
?};
ZL.cntx_pop();
_result


\ilosc_dk_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Tablica parametrów dla ilosc_dk
::   WY: _args - obj_new
::  OLD: \ilosc_dk_a/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new( 'blank'
               ,'RESULT'
::             Pozycja przewodnika dla której zbierać
               ,'ZGP'
::             Przewodnik dla którego zbierać
               ,'ZGH'
::             Zlecenie dla którego zbierać
               ,'ZL'
::             Partia dla której zbierać
               ,'ZPARN'
               ,'M'
::             INTEGER - 0/1 zbierac z dokumentow klasy RP
               ,'RP'
::             INTEGER - 0/1 zbierac z dokumentow klasy ZP
               ,'ZP'
::             INTEGER - 0/1 zbierac z dokumentow klasy RW
               ,'RW'
::             INTEGER - 0/1 zbierac z dokumentow klasy ZW
               ,'ZW'
::             INTEGER - Jaki status akceptacji dokumentów brać pod uwagę:
::                0 - sprawdzac wszystkie dokumenty, nie wazne czy zaakceptowane czy nie
::                1 - sprawdzac tylko zaakceptowane dokumenty
::                2 - sprawdzac tylko niezaakceptowane dokumenty
               ,'AKC'
::              DK.ref - dokument ktorego nie uwzgledniac podczas zliczania
::                       (przydatne aby nie uwzględniac dokumentu ktory aktualnie poprawiam)
               ,'OMIT'
);
:: - - - - ponizej ustawienie wartosci domyslnych
_args.blank:="
       .RESULT:=0;
       .ZGP:=null();
       .ZGH:=null();
       .ZPARN:=null();
       .ZL:=null();
       .M:=null();
       .RW:=0;
       .RP:=0;
       .ZP:=0;
       .ZW:=0;
       .AKC:=0;
       .OMIT:=null();
       ~~
      ";
:: - - - - koniec ustalania wartosci domyslnych
_args.blank();
_args


\ilosc_dk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Zlicza ilosc na DK dla podanych parametrów (zlecenie, przewodnik...), wynik jest zwracany w _args
::   WE: _a - obj_new() - argumenty funkcji - wynik działania exec('ilosc_dk_a','zl_common')
::  OLD: \ilosc_dk/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('ilosc_dk_a','zl_common')
?};

DK.cntx_psh();
{? _args.ZGP<>null()
|| DK.index('ZGP');
   DK.prefix(_args.ZGP)
|? _args.ZGH<>null()
|| DK.index('ZGH');
   DK.prefix(_args.ZGH)
|? _args.ZPARN<>null()
|| DK.index('PARTIA');
   DK.prefix(_args.ZPARN)
|? _args.M<>null()
|| DK.index('DOKZL');
   DK.prefix(_args.ZL,_args.M)
|| DK.index('DOKZL');
   DK.prefix(_args.ZL)
?};
{? DK.first()
||
   {!
   |?
      _can_continue:=1;

      {? _args.OMIT<>null() & _args.OMIT=DK.ref()
      || _can_continue:=0
      ?};

      {? _can_continue>0 & _args.AKC>0
      ||
::       Sprawdzam status akceptacji dokumentu
         _akc:=exec('FindAndGet','#table',ND,$DK.N,,"Z",'N');
         {? _args.AKC=1
         ||
::          Sprawdzam czy dokument jest zaakceptowany
            {? _akc='N'
            || _can_continue:=0
            ?}
         |? _args.AKC=2
         ||
::          Sprawdzam czy dokument jest niezaakceptowany
            {? _akc='T'
            || _can_continue:=0
            ?}
         ?}
      ?};

      {? _can_continue>0
      ||
         {? _args.RW=0 & _args.ZW=0 & _args.RP=0 & _args.ZP=0
         ||
::          Nie sprawdzam typu dokumentu, po prostu do wyniku dodaje ilosc
            _args.RESULT+=DK.IL
         ||
::          Typy dokumentow ktore sprawdzac zostaly okreslone w argumentach
            {? _args.RW>0
            || {? exec('dk_is_rw','magdok_wspolne',DK.ref())>0
               || _args.RESULT+=DK.IL
               ?}
            ?};
            {? _args.RP>0
            || {? exec('dk_is_rp','magdok_wspolne',DK.ref())>0
               || _args.RESULT+=DK.IL
               ?}
            ?};
            {? _args.ZP>0
            || {? exec('dk_is_zp','magdok_wspolne',DK.ref())>0
               || _args.RESULT+=DK.IL
               ?}
            ?};
            {? _args.ZW>0
            || {? exec('dk_is_zw','magdok_wspolne',DK.ref())>0
               || _args.RESULT+=DK.IL
               ?}
            ?}
         ?}
      ?};
      DK.next()
   !}
?};
DK.cntx_pop();
~~


\realz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [12.10]
:: OPIS: Sprawdza czy istnieja realizacje do zamówień wewnętrznych dla zlecenia. Dziala w kontekscie VAR.A_ZLEC
::   WE: ZL.ref()
::   WY: 0/1
::  OLD: \realz/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
_wynik:=0;
ZK_N.cntx_psh();
ZK_RN.cntx_psh();
ZK_RN.index('ZAM');
ZK_N.index('ZLALW');
ZK_N.prefix(_a);
{? ZK_N.first()
|| {!
   |?
      ZK_RN.prefix(ZK_N.ref());
      {? ZK_RN.first()
      || _wynik:=1;0
      || ZK_N.next()
      ?}
   !}
?};
ZK_RN.cntx_pop();
ZK_N.cntx_pop();
_wynik


\zmiana
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Tłumaczy godzinę na numer zmiany
::   WE: _a - godzina
::   WY: numer/symbol zmiany: '1', '2', '3'
::  OLD: \zmiana/zl_akor2.fml
::----------------------------------------------------------------------------------------------------------------------
_time:=_a;
_tm:=exec('zmiana_tm','zl_common',0);
{? _time<_tm[1]
|| '3'
|? _time>=_tm[1] & _time<_tm[2]
|| '1'
|? _time>=_tm[2] & _time<_tm[3]
|| '2'
|| '3'
?}


\zmiana_tm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Zwraca tablicę z godzinami rozpoczęcia albo zakończenia zmian
::   WE: _a - sposób pracy: 0-rozpoczęcie, 1 (>0) -zakończenie
::----------------------------------------------------------------------------------------------------------------------
_tm:=obj_new(3);
_obj:=spli_str(exec('get','#params',500650),'|');
{? _a>0
|| _tm[1]:=exec('str2time','#convert',_obj[3]);
   _tm[2]:=exec('str2time','#convert',_obj[4]);
   _tm[3]:=exec('str2time','#convert',_obj[2])
|| _tm[1]:=exec('str2time','#convert',_obj[2]);
   _tm[2]:=exec('str2time','#convert',_obj[3]);
   _tm[3]:=exec('str2time','#convert',_obj[4])
?};
_tm


\zmiana_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Tłumaczy zmianę na godzinę początku
::   WE: _a - symbol zmiany: '1', '2', '3'
::   WY: godzina [TIME]
::----------------------------------------------------------------------------------------------------------------------
_tm:=exec('zmiana_tm','zl_common',0);
_tm[#_a]


\zmiana_end
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Tłumaczy zmianę na godzinę końca
::   WE: _a - symbol zmiany: '1', '2', '3'
::   WY: godzina [TIME]
::----------------------------------------------------------------------------------------------------------------------
_tm:=exec('zmiana_tm','zl_common',1);
_tm[#_a]


\zmiana_czasowo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Ustala numer zmiany na podstawie tego, czy więcej czasu zostało zarejestrowane
::       na zmianie startującej operację, czy kończącej operację
::   WE: _a - data rozpoczęcia operacji
::       _b - godzina rozpoczęcia operacji
::       _c - data zakończenia operacji
::       _d - godzina zakończenia operacji
::   WY: numer/symbol zmiany: '1', '2', '3'
::----------------------------------------------------------------------------------------------------------------------
_result:='x';

:: interwał pracy pracownika (start .. stop)
_work:=exec('interval','#interval');
_work.START:=exec('create','#tm_stamp',_a,_b);
_work.END:=exec('create','#tm_stamp',_c,_d);

:: tabela ze zmianami - zawiera dane od dnia poprzedzającego rozpoczęcie, do dnia zakończenia
_tab:=tab_tmp(
   ,'DATA','DATE','Data'
   ,'ZMIANA','STRING[1]','Zmiana'
   ,'START','REAL','Start'
   ,'END','REAL','Koniec'
);

{! _day:=(#_a)-1 .. #_c
|! {! _zmiana:=1 .. 3
   |! _tab.DATA:=#_day;
      _tab.ZMIANA:=$_zmiana;
      _tab.START:=exec('create','#tm_stamp',_tab.DATA,exec('zmiana_start','zl_common',_tab.ZMIANA));
      _tab.END:=exec('create','#tm_stamp',_tab.DATA+{? _zmiana=3 || 1 || 0 ?},exec('zmiana_end','zl_common',_tab.ZMIANA));
      _tab.add()
   !}
!};

_interval:=exec('interval','#interval');
:: maksymalny czas zalogowany na zmianie
_max:=0;
:: liczba pełnych zmian
_full:=0;
:: ostatnia zmiana, na której zalogowano czas
_last:='x';
{? _tab.first()
|| {!
   |? _interval.START:=_tab.START;
      _interval.END:=_tab.END;
      _interval_and:=exec('intervals_and','#interval',_work,_interval);
      _duration:=_interval_and.END-_interval_and.START;
      _full+=(_duration=_tab.END-_tab.START);
      obj_del(_interval_and);
      {? _duration>_max || _result:=_tab.ZMIANA; _max:=_duration ?};
      {? _duration>0 || _last:=_tab.ZMIANA ?};
      _tab.next()
   !}
?};
:: jeżeli czas zalogowany na więcej niż jednej pełnej zmianie, to zwracana jest ostatnia zalogowana zmiana
{? _full>1 || _result:=_last ?};
_result


\f3_zmiana
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: na F3 dla pól 'Zmiana' w różnych tabelach
::  OLD: \f3_zmiana/produ.fml
::----------------------------------------------------------------------------------------------------------------------
_buf:=fld();
_choice:=FUN.choice('Wybierz zmianę:'@,#_buf,'1.','2.','3.','Informacje'@);
{? _choice=0
|| ~~
|? _choice=4
|| FUN.info(
      'Zakres zmian:\n\n'
      '1. %1 ÷ %2\n'
      '2. %3 ÷ %4\n'
      '3. %5 ÷ %6'
      [  $exec('zmiana_start','zl_common','1'),
         $exec('zmiana_end','zl_common','1'),
         $exec('zmiana_start','zl_common','2'),
         $exec('zmiana_end','zl_common','2'),
         $exec('zmiana_start','zl_common','3'),
         $exec('zmiana_end','zl_common','3')
      ]
   );
   ~~
|| $(_choice)
?}


\pr_zmiana
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: po redakcji pól 'Zmiana' w różnych tabelach
::       UWAGA: dla zmiennej VAR pole może być niwypelnione
::  OLD: \pr_zmiana/produ.fml
::----------------------------------------------------------------------------------------------------------------------
_var:=cur_tab(1,1)=VAR;
{? fld()='' & ~_var
|| FUN.info('Proszę wypełnić pole.'@); 0
|| {? ('123'*fld())<>0
   || 1
   || FUN.emsg(
         {? _var
         || 'Możliwe wartości pola: ''%1'', ''%2'', ''%3'', '' ''.'@['1','2','3']
         || 'Możliwe wartości pola: ''%1'', ''%2'', ''%3''.'@['1','2','3']
         ?}
      );
      0
   ?}
?}


\zl_mg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca magazyn ze zlecenia
::   WE: _a - ZL.ref(), #ZL.ref()
::   WY: MG.ref() / null()
::  OLD: \zl_mg/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
{? type_of(_a)=type_of(null()) || _zl:=#_a |? type_of(_a)=type_of(0) || _zl:=_a || _zl:=0 ?};
ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl,)
|| _mg:=ZL.MG
|| _mg:=null()
?};
ZL.cntx_pop();
_mg


\zl_wyd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca wydzial ze zlecenia
::   WE: _a - ZL.ref(), #ZL.ref()
::   WY: SLO.ref() / null()
::  OLD: \zl_wyd/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
{? type_of(_a)=type_of(null()) || _zl:=#_a |? type_of(_a)=type_of(0) || _zl:=_a || _zl:=0 ?};
ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl,)
|| _wyd:=ZL.JORG
|| _wyd:=null()
?};
ZL.cntx_pop();
_wyd


\komm_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Dla aktualnego zlecenia/grupy operacji dodaje do KOMMa podany komunikat
::       Kontekst wywołania - rekord tabeli ZL/GROP
::   WE: _a - STRING - komunikat
::       [_b] - INTEGER - 0/1/2 - typ komunikatu: 0 - błąd
::                                                1 - ostrzeżenie
::                                                2 - niezgodności
::                                                3 - informacje
::       [_c] - INTEGER - [0]/1 - czy szukać czy taki komunikat już istnieje i go nie dodawać
::       [_d] - obj_new - obiekt KOMM do którego dodawać komunikaty
::       [_e] - INTEGER - czego dotyczy: [0] - zlecenie 1 - grupa operacji
::----------------------------------------------------------------------------------------------------------------------
_msg:=_a;

{? var_pres('_b')=type_of(0) || _mode:=_b || _mode:=0 ?};
{? var_pres('_c')=type_of(0) || _find:=_c || _find:=0 ?};

_komm:=~~;
{? var_pres('_d')>100
|| _komm:=_d
|| _komm:=KOMM
?};
{? var_pres('_e')=type_of(0) || _where:=_e || _where:=0 ?};
_icon:='';

{? _mode=0
|| _sect:='Błędy'@;
   _icon:='xwin16.png:81'
|? _mode=1
|| _sect:='Ostrzeżenia'@;
   _icon:='xwin16.png:7'
|? _mode=2
|| _sect:='Niezgodności'@;
   _icon:='xwin16.png:3'
|? _mode=3
|| _sect:='Informacje'@;
   _icon:='xwin16.png:19'
?};

_sect_nr:=0;
{? _komm.find_msg(_sect) || _sect_nr:=_komm.set_root(_sect) || _sect_nr:=_komm.sect_beg(_sect) ?};
{? _where=0
|| _sect:='Zlecenie: %1'@[exec('record','#to_string',ZL.ref())]
|| _sect:='Grupa operacji: %1'@[exec('record','#to_string',GROP.ref())]
?};

{? _sect_nr>0
|| {? _komm.find_msg(_sect,_sect_nr)
   || _sect_nr:=_komm.set_root(_sect)
   || _sect_nr:=_komm.sect_beg(_sect)
   ?}
|| {? _komm.find_msg(_sect)
   || _sect_nr:=_komm.set_root(_sect)
   || _sect_nr:=_komm.sect_beg(_sect)
   ?}
?};

_found:=0;
{? _find>0
|| {? _sect_nr>0
   || _found:=_komm.find_msg(_msg,_sect_nr)
   || _found:=_komm.find_msg(_msg)
   ?}
?};
{? _found=0
|| _komm.add(_msg,_icon,,1)
?};

_komm.sect_end();
_komm.sect_end();
~~


\dkc_compare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Porównuje wartości atrybutów na przekazanej cesze i zleceniu
::   WE: _a - DK_C.ref() - cecha z którą porównywać zlecenie
::       _b - ZL.ref() - zlecenie
::       [_c] - INTEGER - 0 - nie wyswietlać komunikatu o niezgodnosciach
::                       [1] - wyświetlać komunikat o niezgodnościach
::                        2  - dodawać info o niezgodnościach do KOMM
::       [_d] - uchwyt do obiektu KOMM, jeśli nie podany to standardowy KOMM
::   WY: 0 - wartości atrybutów są niezgodne
::       1 - wartości atrybutów są zgodne
::  TAG: <PUBLIC>
::  OLD: \dkc_compare/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_dkc:=_a;
_zl:=_b;

_kom_mode:=1;

_result:=1;

{? var_pres('_c')=type_of(0)
|| _kom_mode:=_c
?};

_komm:=~~;
{? var_pres('_d')>100
|| _komm:=_d
|| {? var_pres('KOMM')>100
   || _komm:=KOMM
   ?}
?};

ZL.cntx_psh(); ZL.clear();

{? ZL.seek(_zl)
|| _result:=0;

   _buf_dk:=exec('buffer','mat_atr');
   _buf_zl:=exec('buffer','mat_atr');

   DK_C.cntx_psh();
   DK_C.clear();
   {? DK_C.seek(_dkc)
   || _buf_dk.get_dkc()
   ?};

   {? ZL.DK_C<>null()
   ||
      {? ref_name(ZL.DK_C)<>DK_C.name() || DK_C.use(ref_name(ZL.DK_C)) ?};
      ZL.DK_C();
      _buf_zl.get_dkc()
   ?};

:: Porównuje cechę dokumentu z cechą zlecenia
   _result:=_buf_dk.compare(_buf_zl,1);
   {? _result<=0 & _kom_mode=1
   ||
::    Wyświetlam komunikat o niezgodnościach
      _msg:='Wartości atrybutów cech na dokumencie i zleceniu są różne.\n'
            'Należy wybrać inną cechę, której atrybuty mają wymagane na zleceniu wartości.'@;

      _m_atr:=obj_new(_buf_dk.NUM_MAX);

      {! _it:=1.._buf_dk.NUM_MAX
      |! _m_atr[_it]:='';
         ~~
      !};

      {! _it:=1.._buf_dk.NUM_MAX
      |! _fit:=form(_it,-2,0,'99');
         _rule_set:=$('
                     _m_atr:=_a;
                     _war1:=_b;
                     _war2:=_c;

                     {? _war1=\'\'
                     || _war1:=\'<brak>\'
                     ?};
                     {? _war2=\'\'
                     || _war2:=\'<brak>\'
                     ?};

                     {? _war1<>\'<brak>\' | _war2<>\'<brak>\'
                     || _m_atr['+_fit+']:=\'Zlecenie: %1; Dokument: %2\'@[_war1,_war2]
                     ?}
                 ');
         _get:=$('_buffer:=_a;_buffer.WAR'+_fit);
         _rule_set(_m_atr,_get(_buf_zl),_get(_buf_dk));
         ~~
      !};

      _msg:=_msg+'\n\n'+_m_atr[1]+'\n'+
                        _m_atr[2]+'\n'+
                        _m_atr[3]+'\n'+
                        _m_atr[4]+'\n'+
                        _m_atr[5]+'\n'+
                        _m_atr[6]+'\n'+
                        _m_atr[7]+'\n'+
                        _m_atr[8]+'\n'+
                        _m_atr[9]+'\n'+
                        _m_atr[10];
      FUN.emsg(_msg);
      ~~
   |? _result<=0 & _kom_mode=2
   ||
::    Dodaje info do KOMM
      _dk_sym:=exec('FindAndGet','#table',ND,#DK.N,ref_name(DK.N),"SYM",'');
      _msg:='Wartości atrybutów cech na dokumencie: %1 poz. %2 i przypisanym do niego zleceniu są różne.'@
            [_dk_sym,$DK.P];
      {? type_of(_komm)>100
      || _komm.add(_msg,'xwin16.png:2')
      ?}
   ?};
   DK_C.cntx_pop();
   ~~
?};
ZL.cntx_pop();
_result


\zl_bez_oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Czy zlecenie z technologią bez operacji
::   WE: _a - ZL.ref()
::   WY: 0 (nie) / 1 (tak)
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_res:=0;
ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
|| _res:=ZL.TYP().TECH='N' & exec('FindAndGet','#table',TKTL,ZL.RKTL,,"TYP().OPER",'T')='N'
            |
         ZL.TYP().TECH='T' & exec('FindAndGet','#table',TKTL,ZL.RTKTL,,"TYP().OPER",'T')='N'
?};
ZL.cntx_pop();
_res


\zl_deleted_in_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Obsługa sytuacji że jest czynność na liście todo ale zlecenie zostało usunięte/zamknięte
::   WE: _a - obj_new - obiekt Menadżera Procesów
::       [_b] - INTEGER - 0/[1] - czy errorować proces, jeżeli 0 to jest robiony .done()
::       [_c] - INTEGER - 0 - zamknięte, [1] - usunięte
::   WY: ~~
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=_a;

_error:=1;
{? var_pres('_b')=type_of(0)
|| _error:=_b
?};
_deleted:=1;
{? var_pres('_c')=type_of(0)
|| _deleted:=_c
?};
{? _deleted
|| _msg:=exec('zl_deleted_msg','zl_common')
|| _msg:=exec('zl_closed_msg','zl_common')
?};
{? _mp.isService()=0 & _mp.CLEANER=0
|| {? _mp.isGroup()
   || KOMM.add(_msg,2,,1)
   || FUN.emsg(_msg)
   ?}
?};
{? _error>0
|| _mp.error(_msg)
|| _mp.done()
?};
~~


\zl_deleted_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Komunikat o usunięciu zlecenia
::----------------------------------------------------------------------------------------------------------------------
'Zlecenie nie zostało odnalezione, prawdopodobnie zostało usunięte.'@@


\has_zgh
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy zlecenie ma przewodniki (ZGH)
::   WE: _a - ZL.ref()
::   WY: 0 - brak przewodników
::       1 - sa przewodniki
::  OLD: \is_zgh_zl/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=0;
_can_continue:=1;

ZGH.cntx_psh();
ZGH.index('ZLNR');
ZL.cntx_psh(); ZL.clear();
{? ZL.seek(_zl)
||
   _sub_zlec:=exec('subzlec_exist','zl_link',ZL.ref());
   {? _sub_zlec=0
   ||
::    Zlecenie bez podrzednych
      ZGH.prefix(ZL.ref());
      {? ZGH.size()>0
      || _result:=1
      ?}
   ||
::    Zlecenie zlozone z podzleceniami
      ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |?
::          !!! REKURENCJA !!!
            {? exec('has_zgh','zl_common',ZL.ref())>0
            || _result:=1;
               _can_continue:=0
            ?};
            ZL.next() & _can_continue>0
         !}
      ?};
      ZL.cntx_pop()
   ?}
?};
ZL.cntx_pop();
ZGH.cntx_pop();
_result


\zl_iterate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Rekurencyjne iteruje po drzewie zlecenia i wykonuje formułę na każdym elemencie
::       Kontekst wywołania: bieżący rekord ZL lub wskazany rekord ZL
::   WE: _a - RULE - formuła do wykonania na rekordzie
::       [_b] - ZL.ref()
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of("") || _formula:=_a || _formula:="KOMM.add('Test: %1'@[ZL.SYM])" ?};
{? var_pres('_b')=type_of(null()) || _zl:=_b || _zl:=null() ?};

ZL.cntx_psh();
{? _zl<>null() || ZL.prefix(); ZL.seek(_zl) ?};
ZL.index('ZLTREE');
ZL.prefix(ZL.TYP,ZL.NODE,#ZL.ref());
{? ZL.first()
|| {!
   |? params_exec('zl_iterate','zl_common',_formula);
      _formula();
      ZL.next()
   !}
?};
ZL.cntx_pop();
~~


\chk_mg4zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza, czy podany magazyn może być przypisany do zlecenia/typu zlecenia
::   WE: _a - MG.ref()
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_p500701:=exec('get','#params',500701,2,null());

T2MG.index('T');
T2MG.prefix(_a);
_result:=0;
{? T2MG.first()
|| {!
   |? {? (' '+_p500701)*(' '+T2MG.T().T+' ')<>0 || _result:=1 ?};
      T2MG.next()
   !}
|| _result:=1
?};
_result


\chk_napraw_or_split
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza, czy do zlecenia wygenerowana operacje naprawcze lub są operacje wynikające z podziału w planie
::   WE: _a - ZL.ref()
::   WY: 0 - nie ma operacji, 1 - są operacje naprawcze lub wynikające z podziału w planie
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=0;

ZGP.cntx_psh();
ZGP.index('S1');
ZGP.prefix(_a);
{? ZGP.first()
|| {!
   |? {? ZGP.NAPRAW='T' | ZGP.PL_SPLIT<>null() || _result:=1 ?};
      _result=0 & ZGP.next()
   !}
?};
ZGP.cntx_pop();

{? _result>0
|| FUN.info('Funkcja niedostępna, jeżeli w zleceniu występują operacje naprawcze albo wynikające z podziału w planie.'@)
?};
_result


\is_planned
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Sprawdza czy przekazane zlecenie lub którekolwiek podzlecenie przekazanego zlecenia jest w planie
::   WE: [_a] - ZL.ref() lub bieżące zlecenie
::       [_b] - INTEGER - wybór planu: 0 - wszystkie plany, 1 - operacyjny, 2 - strategiczny
::       [_c] - INGEGER - czy sprawdzać zaplanowalność również na przekazanym zleceniu, czy tylko na podzleceniach
::   WY: 0 - nie ma w planie
::       1 - jest w planie
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};
_mode:=0;
{? var_pres('_b')=type_of(0)
|| _mode:=_b
?};
_this:=1;
{? var_pres('_c')=type_of(0)
|| _this:=_c
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? _this>0
   ||
      {? _mode=0 | _mode=1
      || {? ZL.PLAN_PO='T'
         || _result:=1
         ?}
      ?};
      {? _mode=0 | _mode=2
      || {? ZL.PLAN_PX='T'
         || _result:=1
         ?}
      ?}
   ?};

   {? _result=0
   ||
      ZL.cntx_psh();
      ZL.index('TREEMTU');
      ZL.prefix(ZL.ref());
      {? ZL.first()
      || {!
         |?
::          !!! REKURENCJA !!!
            _result:=exec('is_planned','zl_common',ZL.ref(),_mode,1);
            ZL.next() & _result=0
         !}
      ?};
      ZL.cntx_pop()
   ?};
   ~~
?};
ZL.cntx_pop();
_result


\is_planned_po
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Sprawdza czy przekazane zlecenie lub którekolwiek podzlecenie przekazanego zlecenia jest w planie operacyjnym
::   WE: [_a] - ZL.ref lub bieżący rekord
::       [_b] - INGEGER - czy sprawdzać zaplanowalność również na przekazanym zleceniu, czy tylko na podzleceniach
::   WY: 0 - nie ma w planie
::       1 - jest w planie
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};
_this:=1;
{? var_pres('_b')=type_of(0)
|| _this:=_b
?};
_result:=0;
{? _ref<>null()
|| _result:=exec('is_planned','zl_common',_ref,1,_this)
|| _result:=exec('is_planned','zl_common',,1,_this)
?};
_result


\is_planned_px
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Sprawdza czy przekazane zlecenie lub którekolwiek podzlecenie przekazanego zlecenia jest w planie strategicznym
::   WE: [_a] - ZL.ref lub bieżący rekord
::       [_b] - INGEGER - czy sprawdzać zaplanowalność również na przekazanym zleceniu, czy tylko na podzleceniach
::   WY: 0 - nie ma w planie
::       1 - jest w planie
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};
_this:=1;
{? var_pres('_b')=type_of(0)
|| _this:=_b
?};
_result:=0;
{? _ref<>null()
|| _result:=exec('is_planned','zl_common',_ref,2,_this)
|| _result:=exec('is_planned','zl_common',,2,_this)
?};
_result


\zl_plan_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Aktualizuje pole ZL.PLAN_PO i ZL.PLAN_PX na podanym zleceniu analizując podzlecenia
::   WE: [_a] - ZL.ref lub aktualne zlecenie
::   WY: 0  - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};
_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _this:=1;
   {? exec('subzlec_exist','zl_link',ZL.ref())>0
   || _this:=0
   ?};
   {? exec('is_planned_po','zl_common',,_this)>0
   || ZL.PLAN_PO:='T'
   || ZL.PLAN_PO:='N'
   ?};
   {? exec('is_planned_px','zl_common',,_this)>0
   || ZL.PLAN_PX:='T'
   || ZL.PLAN_PX:='N'
   ?};
   _can_continue:=ZL.put()
?};
ZL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\get_ilosc_zgh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.28]
:: OPIS: Zwraca ilość na przewodnikach dla danego zlecenia
::   WE: [_a] - ZL.ref lub bieżący rekord
::   WY: REAL
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| ZGH.cntx_psh();
   ZGH.index('ZLNR');
   ZGH.prefix(ZL.ref());
   {? ZGH.first()
   || {!
      |? _result+=ZGH.ILNPRZ;
         ZGH.next()
      !}
   ?};
   ZGH.cntx_pop()
?};
ZL.cntx_pop();
_result


\chk_ztp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Walidacja rekordu tabeli ZTP (typy zleceń) - wołana z poziomu okna oraz funkcji importujących
::       Musi być ustawiona zmienna BEER.NRDOK_AB
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
{? ZTP.WP='P'
|| _chk:=__CHK.record(ZTP,,'TYP','OPIS','ZAM_TYP','KOD_ZLC','KOD_ZLP','KOD_PAR','ILE_PRZ');
   {? _chk=''
   || {? exec('ae_spkod','numery',ZTP.KOD_ZLC)=0
      || _chk:='KOD_ZLC'
      ?}
   ?};
   {? _chk=''
   || {? exec('ae_spkod','numery',ZTP.KOD_ZLP)=0
      || _chk:='KOD_ZLP'
      ?}
   ?};
   {? _chk=''
   || {? exec('ae_spkod','numery',ZTP.KOD_PAR)=0
      || _chk:='KOD_PAR'
      ?}
   ?}
|| _chk:=__CHK.record(ZTP,,'TYP','OPIS',          'KOD_ZLC',                    'ILE_PRZ');
   {? _chk=''
   || {? exec('ae_spkod','numery',ZTP.KOD_ZLC)=0
      || _chk:='KOD_ZLC'
      ?}
   ?}
?};
{? _chk=''
|| {? ZTP.MG().KOOP='T'
   || FUN.info('Magazyn przypisany do zlecenia nie może służyć do rejestracji kooperacji.'@);
      'MG'
   |? exec('chk_mg4zl','zl_common',ZTP.MG)=0
   || FUN.info(
         'Magazyn przypisany do typu zlecenia powinien mieć przypisany przynajmniej jeden typ dokumentu\n'
         'określony parametrem %1 %2.'@['500701',exec('name','#params',500701,'A')]
      );
      'MG'
   |? ZTP.TOL<0 | ZTP.TOL>100
   || FUN.info('Proszę podać liczbę z zakresu %1..%2.'@['0','100']);
      'TOL'
   |? ZTP.ILE_PRZ<0
   || FUN.info('Wartość parametru "Liczba znaków" musi być większa od zera.'@);
      'ILE_PRZ'
   |? _chk:=exec('pl_force_chk','px_utils','ZTP');
      _chk<>''
   || _chk
   |? __CHK.index(ZTP,_a)=''
   || ''
   || 'TYP'
   ?}
|| _chk
?}


\chk_ztpf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Walidacja rekordu tabeli ZTPF (warianty dla typów zleceń) - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(ZTPF);
{? _chk=''
|| {? __CHK.index(ZTPF,_a)='' || '' || 'OPC' ?}
|| _chk
?}


\zl_analizas_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Część wspólna akcji przed i przed grupą - faktyczne naliczenie analizy
::----------------------------------------------------------------------------------------------------------------------
_env:=__ENV_STR;

_tab:=_env.SELECTED.TAB;
{? _tab.first()
|| {!
   |? {? _tab.OMIT='N'
      || ZL.cntx_psh();
         ZL.prefix();
         {? ZL.seek(_tab.REF,)
         ||
            {? ZL.IL
            || _args:=exec('add_a','tech_structure');
               _args.M:=ZL.KTM;
::             Ilość pozostała
               _il:=ZL.IL;
::             Ilości nie zmniejszamy o ilość wykonaną
               {? _il>0
               ||
::                Znajdujemy obiekt planistyczny i wyliczamy ilość w kolejce
                  _px_il:=0;
                  _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
                  {? _px_obj<>null() || _px_il:=exec('get_que_ilosc','px_obj',_px_obj,exec('get_mainversion','px_ver')) ?};

::                Ilość zaplanowana
                  {? _px_il>0
                  || _args.IL:=_px_il;
                     _args.DW:={? ZL.PL_DATA<>date(0,0,0) || ZL.PL_DATA |? ZL.DTR<>date(0,0,0) || ZL.DTR || date() ?};
                     _args.TW:=ZL.PL_TIME;
                     _args.SRC_REF:=$_px_obj;
                     exec('add','tech_structure',_args);
                     exec('expand','tech_structure',_args.ref)
                  ?};
                  {? _il-_px_il>0
                  || _args.IL:=_il-_px_il;
                     _args.DW:={? ZL.PL_DATA<>date(0,0,0) || ZL.PL_DATA |? ZL.DTR<>date(0,0,0) || ZL.DTR || date() ?};
                     _args.TW:=ZL.PL_TIME;
                     _args.TKTL:=
                        exec('FindAndGet','#table',TKTL,{? ZL.RTKTL<>'' || ZL.RTKTL || ZL.RKTL ?},,"ref()",null());
                     _args.SRC_REF:=$ZL.ref();
                     exec('add','tech_structure',_args);
                     exec('expand','tech_structure',_args.ref)
                  ?}
               ?};
               obj_del(_args)
            ?}
         ?};
         ZL.cntx_pop()
      ?};
      _tab.next()
   !};
:: Usunięcie zapisów źródłowych TMAT dla podzleceń, które mają wypełnione pole ZL.TMAT_SRC
   _struct:=_env.STRUCT.TAB;
   _struct.prefix();
   {? _struct.first()
   || {!
      |? _continue:=1;
         {? _struct.SRC_REF<>''
         ||  _tmat_src:=exec('FindAndGet','#table',ZL,_struct.SRC_REF,,"RTMATSRC",'');
             _mref:=_struct.M;
             _tmat_srcs:='';
::          Sprawdzam czy dodana gałąź nie występowała jako półfabrykat innego zlecenia (usuwam zapis z drzewa)
            {!
            |? _tmat_src<>'' & _continue |!
               _struct.cntx_psh();
               _struct.blank();
               _struct.NORM_REF:=_tmat_src;
               {? _struct.find_rec()
               ||
::                Znaleziono powiązany rekord w drzewie i usuwam go
                  _continue:=0;
                  {? _tmat_srcs=''
                  || exec('tree_del','#tree',_struct,#_struct.ref())
                  ||
::                   Przechodze po kolejnych poziomach drzewa i odnajduje odpowiednią gałąź do usunięcia
                     _tmat_srcs:=_tmat_srcs-1;
                     {? var_press('_tab_src')>100 || obj_del(_tab_src) ?};
                     _tab_src:=spli_str(_tmat_srcs,';');
                     _ndx:=_struct.ndx_tmp(,,'PARENT',,,'M',,);
                     _struct.index(_ndx);
                     _ok:=1;
                     {! _i:=obj_len(_tab_src)//-1..2 |!
                        {? _ok
                        ||  _struct.prefix(#_struct.ref(),exec('FindAndGet','#table',TMAT,_tab_src[_i-1],,"$TMAT.PT",''))
                        ?};
                        {? ~_struct.first()
                        || _ok:=0
                        ?}
                     !};
                     {? _ok
                     || _struct.prefix(#_struct.ref(),_mref);
                        {? _struct.first()
                        || exec('tree_del','#tree',_struct,#_struct.ref())
                        ?}
                     ?}
                  ?}
               ?};
               _struct.cntx_pop();
               _tmat_src:=exec('FindAndGet','#table',TMAT,_tmat_src,,
                  " TKTL.cntx_psh();
                    TKTL.use(ref_name(TMAT.NRK));
                    _res:=TMAT.NRK().ZL().RTMATSRC;
                    TKTL.cntx_pop();
                    _res
                  ",'');
               _tmat_srcs+=_tmat_src+';'
            !}
         ?};
         _struct.next()
      !}
   ?}
?};
~~


\zl_analizas_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Analiza dostępności surowców w czasie - akcja 'przed' dla tabeli ZL
::       analizie podlegają tylko surowce produktów w ilości nie zleconej
::----------------------------------------------------------------------------------------------------------------------
{? ZL.sel_size()>0 || return() ?};

ZL.cntx_psh();

{? ZL.RODZAJ='N' & exec('subzlec_exist','zl_link',ZL.ref())=0
|| FUN.info('Zlecenie niezależne %1 bez podzleceń nie podlega analizie.'@[ZL.SYM]);
   _can_continue:=0
|| exec('env_create','tech_structure',1);
   _can_continue:=exec('edit_params','tech_structure',,,1)
?};
_env:=__ENV_STR;
::  Rozpoczynam pętle
_exit:=1;
{!
|?
   {? var_pres('TAB',__ENV_STR.STRUCT)>0 || __ENV_STR.STRUCT.TAB.erase() ?};
   {? var_pres('TAB',__ENV_STR.SELECTED)>0 || __ENV_STR.SELECTED.TAB.erase() ?};
   {? var_pres('ELEMENT',__ENV_STR.STRUCT)>0 || __ENV_STR.STRUCT.ELEMENT.erase() ?};
   {? var_pres('TAB',__ENV_STR.CHECK) > 0 || _env.CHECK.TAB.erase() ?};

   {? _can_continue>0
   || {? var_pres('_tab')>0 || obj_del(_tab) ?};
      _tab:=_env.SELECTED.TAB;
::    Zlecenie niezależne zamieniane na jego elementy (bezwarunkowo)
      {? ZL.RODZAJ='N'
      || ZL.cntx_psh();
         ZL.prefix();
         ZL.index('NRNZL');
         ZL.prefix(ZL.UNRZL);
         {? ZL.first()
         || {!
            |? _tab.REF:=#ZL.ref();
               _tab.OMIT:='N';
               _tab.add();
               ZL.next()
            !}
         ?};
         ZL.cntx_pop()

::    Zlecenie złożone zamieniane na montażowe (o ile już są podzlecenia)
      |? ZL.RODZAJ='Z' & exec('subzlec_exist','zl_link',ZL.ref())>0
      || ZL.cntx_psh();
         ZL.prefix();
         ZL.index('NRNZL');
         ZL.prefix(ZL.UNRZL,1);
         {? ZL.first()
         || {!
            |? {? ZL.TREE_TYP='M'
               || _tab.REF:=#ZL.ref();
                  _tab.OMIT:='N';
                  _tab.add()
               ?};
               ZL.next()
            !}
         ?};
         ZL.cntx_pop()

      || _tab.REF:=#ZL.ref();
         _tab.OMIT:='N';
         _tab.add()
      ?};
      exec('zl_analizas_core','zl_common')
   ?};
:: Wyświetlam tabelę z problemami i uzupełniam tabelę zamienników
   _ok:=1;
   {? _env.CHECK.TAB.size()>0
   || _env.CHECK.TAB.win_sel(_env.CHECK.WERA);
      _ok:=exec('tktl_chck_sel','tech_structure');
      {? _ok=0 || _exit:=0 ?}
   || _exit:=0
   ?};
   _exit
!};
:: Koniec petli

{? _ok
|| exec('cumulate','tech_structure');
   exec('select','tech_structure')
?};
ZL.cntx_pop();
~~


\zl_analizas_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Analiza dostępności surowców w czasie - akcja 'po' dla tabeli ZL
::----------------------------------------------------------------------------------------------------------------------
~~


\zl_analizas_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Analiza dostępności surowców w czasie - akcja 'przed grupą' dla tabeli ZL
::----------------------------------------------------------------------------------------------------------------------
exec('env_create','tech_structure',1);
{? exec('edit_params','tech_structure',0,0,1)
||  _env:=__ENV_STR;
::  Rozpoczynam pętle
   _exit:=1;
   {!
   |?
      {? var_press('TAB',__ENV_STR.STRUCT)>0 || __ENV_STR.STRUCT.TAB.erase  ?};
      {? var_press('TAB',__ENV_STR.SELECTED)>0 || __ENV_STR.SELECTED.TAB.erase  ?};
      {? var_press('ELEMENT',__ENV_STR.STRUCT)>0 || __ENV_STR.STRUCT.ELEMENT.erase() ?};
      {? var_press('TAB',__ENV_STR.CHECK) > 0 || _env.CHECK.TAB.erase ?};
      {? var_press('_tab')>0 || obj_del(_tab) ?};
      {? var_press('_selected')>0 || obj_del(_selected) ?};

::       zaznaczone rekordy przeładowuję do tabeli _tab
      _tab:=_env.SELECTED.TAB;
      _selected:=ZL.sel_aget();
      {? _selected.first()
      || {!
         |? ZL.cntx_psh();
            ZL.prefix();
            {? ZL.seek(_selected.REF,)
            ||
::          Zlecenie niezależne zamieniane na jego elementy (bezwarunkowo)
               {? ZL.RODZAJ='N'
               || ZL.cntx_psh();
                  ZL.prefix();
                  ZL.index('NRNZL');
                  ZL.prefix(ZL.UNRZL);
                  {? ZL.first()
                  || {!
                     |? _tab.cntx_psh();
                        _tab.prefix(#ZL.ref());
                        {? ~_tab.first()
                        || _tab.REF:=#ZL.ref();
                           _tab.OMIT:='N';
                           _tab.add()
                        ?};
                        _tab.cntx_pop();
                        ZL.next()
                     !}
                  ?};
                  ZL.cntx_pop()

::          Zlecenie złożone zamieniane na montażowe (o ile już są podzlecenia)
               |? ZL.RODZAJ='Z' & exec('subzlec_exist','zl_link',ZL.ref())>0
               || ZL.cntx_psh();
                  ZL.prefix();
                  ZL.index('NRNZL');
                  ZL.prefix(ZL.UNRZL,1);
                  {? ZL.first()
                  || {!
                     |? {? ZL.TREE_TYP='M'
                        || _tab.cntx_psh();
                           _tab.prefix(#ZL.ref());
                           {? ~_tab.first()
                           || _tab.REF:=#ZL.ref();
                              _tab.OMIT:='N';
                              _tab.add()
                           ?};
                           _tab.cntx_pop()
                        ?};
                        ZL.next()
                     !}
                  ?};
                  ZL.cntx_pop()

               || _tab.cntx_psh();
                  _tab.prefix(#ZL.ref());
                  {? ~_tab.first()
                  || _tab.REF:=#ZL.ref();
                     _tab.OMIT:='N';
                     _tab.add()
                  ?};
                  _tab.cntx_pop()
               ?}
            ?};
            ZL.cntx_pop();
            _selected.next()
         !}
      ?};
::    Eliminacja zleceń
      ZL.cntx_psh();
      {? _tab.first()
      || {!
         |? {? ZL.seek(_tab.REF,)
            ||
::          Wyłączam zlecenie złożone niezależne
               {? ZL.RODZAJ='N'
               || _env.KOMM.add('Zlecenie niezależne %1 nie podlega analizie.'@[ZL.SYM]);
                  _tab.OMIT:='T';
                  _tab.put()
::          Wyłączam zlecenie nadrzędne jeżeli ma zlecenie montażowe (dokładnie: ma podzlecenia)
::            |? ZL.RODZAJ='Z' & exec('subzlec_exist','zl_link',ZL.ref())>0
::            || _env.KOMM.add('Zlecenie nadrzędne %1 ma zlecenie montażowe.'@[ZL.SYM]);
::               _tab.OMIT:='T';
::               _tab.put()
               ?}
            ?};
            _tab.next()
         !}
      ?};
      ZL.cntx_pop();
      exec('zl_analizas_core','zl_common');
::     Wyświetlam tabelę z problemami i uzupełniam tabelę zamienników
      _ok:=1;
      {? _env.CHECK.TAB.size()>0
      || _env.CHECK.TAB.win_sel(_env.CHECK.WERA);
         _ok:=exec('tktl_chck_sel','tech_structure');
         {? _ok=0 || _exit:=0 ?}
      || _exit:=0
      ?};
   _exit
   !};
::   Koniec petli

{? _ok
|| exec('cumulate','tech_structure');
   exec('select','tech_structure')
?};
1
|| 0
?}


\zl_analizas_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Analiza dostępności surowców w czasie - akcja 'po grupie' dla tabeli ZL
::----------------------------------------------------------------------------------------------------------------------
~~


\zl_closed_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Komunikat o zamknięciu zlecenia
::----------------------------------------------------------------------------------------------------------------------
'Zlecenie jest zamknięte — czynność zostanie zakończona.'@@


\zl_clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Uniwersalna funkcja czyszcząca czynności dla zleceń - w razie potrzeby jak nie ma rekordu kluczowego zrobi
::       done albo error. Dodatkowo może być wywoływana przez czynność czyszczącą zadania na TODO
::       Cleanery zleceń o innym działaniu
::       exec('clean','!lmg_zam_iprz')
::       exec('clean','!tpp_pps_dgpl')
::       exec('clean','!tpp_pps_dopl')
::       exec('clean','!tte_pzl_dzlg')
::       exec('clean','!tte_wyk_dgrp')
::   WE: _a - _mp - obiekt Menadżera procesów
::       _b - tablica z parametrami wejściowymi
::       [_c] - STRING - co robić jak zlecenie zamknięte: ['ERROR'], 'DONE'
::       [_d] - INTEGER - czy obsługa wg przewodnika zlecenia (ZGH) : [0]/1
::   WY: obj_new() - obiekt wynikowy
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=_a;
_in:=_b;
{? var_pres('_c')=type_of('str')
|| _closed:=_c
|| _closed:='ERROR'
?};
{? var_pres('_d')=type_of(0)
|| _czy_zgh:=_d
|| _czy_zgh:=0
?};

_can_continue:=1;
_obj:=obj_new('RESULT','ZL','ZGH');
_obj.RESULT:=0;
_obj.ZL:=null();
_obj.ZGH:=null();

_keyRefs:=_mp.getRefs();

{? obj_len(_keyRefs)>0
||
   {! _it:=1..obj_len(_keyRefs)
   |! _kref:=_keyRefs[_it];
      {? type_of(_kref)>0
      ||
         {? ref_name(_kref)=ZL.name()
         || _obj.ZL:=exec('FindAndGet','#table',ZL,_kref,,,null());
            {? _obj.ZL=null()
            ||
::             Nie znaleziono rekordu kluczowego powiązanego ze zleceniem, więc robię error
               _can_continue:=0;
               exec('zl_deleted_in_proc','zl_common',_mp)
            |? ~_mp.isMicro() & exec('FindAndGet','#table',ZL,_obj.ZL,,"ZL.STAN",'')='Z'
            ||
::            Zlecenie zostało zamknięte, więc robie error
               _can_continue:=0;
               exec('zl_deleted_in_proc','zl_common',_mp,{? _closed='DONE' || 0 || 1 ?},0)
            ?}
         |? _czy_zgh>0 & ref_name(_kref)=ZGH.name()
         || _obj.ZGH:=exec('FindAndGet','#table',ZGH,_kref,,,null());
            {? _obj.ZGH=null()
            ||
::             Nie znaleziono rekordu kluczowego powiązanego z przewodnikiem, więc robię error
               _can_continue:=0;
               exec('zgh_deleted_in_proc','zl_guide',_mp)
            ?}
         ?}
      ?}
   !}
?};

{? _can_continue>0
||
:: jest parametr wejściowy ZL
   {? _obj.ZL=null() & var_pres('ZL',_in)=type_of(null())
   || _obj.ZL:=_in.ZL
   ?};
:: jest parametr wejściowy ZGH
   {? _czy_zgh>0 & _obj.ZGH=null() & var_pres('ZGH',_in)=type_of(null())
   || _obj.ZGH:=exec('FindAndGet','#table',ZGH,_in.ZGH,,"ref()",null())
   ?}
?};

{? _can_continue>0
|| _obj.RESULT:=1
?};
_obj


\create_dkc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Tworzy ceche dla limitu lub podzlecenia na podstawie cechy TMAT, cechy ZL uwzględniając maskę dziedziczenia TMAT
::   WE: _a - DK_C.ref() - cecha zlecenia
::       _b - DK_C.ref() - cecha TMAT
::       _c - STRING - maska dziedziczenia
::       _d - M.ref() - materiał dla surowca TMAT
::   WY: DK_C.ref() - cecha dla limitu/podzlecenia lub null()
::  TAG: <PUBLIC>
::----------------------------------------------------------------------------------------------------------------------
_cech_zl:=_a;
_cech_tex:=_b;
_mask:=_c;
_m_tex:=_d;

_result:=null();
_can_continue:=1;

_buf_tex:=exec('buffer','mat_atr');
_buf_zl:=exec('buffer','mat_atr');
DK_C.cntx_psh();
DK_C.clear();
_tex_empty:=0;
_name:=ref_name(_cech_tex);
{? _name<>DK_C.name() & _name<>'' || DK_C.use(_name) ?};
{? _name<>'' & DK_C.seek(_cech_tex)
||
:: Stoję na cesze surowca technologicznego
   _buf_tex.get_dkc()
||
:: Surowiec nie ma cechy
   _tex_empty:=1
?};
_name:=ref_name(_cech_zl);
{? _name<>DK_C.name() & _name<>'' || DK_C.use(_name) ?};
{? _name<>'' & DK_C.seek(_cech_zl)
||
:: Stoję na cesze zlecenia
   _buf_zl.get_dkc();

:: Jeśli surowiec nie ma cechy, ale maska dziedziczona ustawiona, oznacza to tylko jeden przypadek:
:: Na technologii surowiec miał dziedziczyć któreś z atrybutów produktu, ale pozostałe dostał puste, więc
:: cecha się nie przypisała do surowca
   {? _tex_empty>0 & _mask*'T'>0
   || M.cntx_psh(); M.clear();
      M_ATR.cntx_psh();
      {? M.seek(_m_tex)
      || {? M.M_ATR<>null()
         ||
::          Podczytuje M_ATR surowca
            M.M_ATR();
::          Ustawiam bufor surowca na odpowiedniego M_ATRa (typy)
            _buf_tex.get_matr()
         || _can_continue:=0
         ?}
      || _can_continue:=0
      ?};
      M_ATR.cntx_pop();
      M.cntx_pop();
      ~~
   ?}
?};
{? _can_continue>0
||
:: Do bufora surowca scalam bufor zlecenia
   _buf_tex.inherit(_buf_zl,_mask);

   {? _tex_empty>0 & _mask*'T'>0
   ||
::    Czyszczę te wartości które nie miały być dziedziczone
      _buf_tex.clr4msk(_mask)
   ?};

   {? _buf_tex.is_empty()=0
   ||
::    Zakładam ceche, lub zwracam istniejącą
      _result:=exec('m_atr_sprdod','mat_atr',_buf_tex.WAR01
                                            ,_buf_tex.WAR02
                                            ,_buf_tex.WAR03
                                            ,_buf_tex.WAR04
                                            ,_buf_tex.WAR05
                                            ,_buf_tex.WAR06
                                            ,_buf_tex.WAR07
                                            ,_buf_tex.WAR08
                                            ,_buf_tex.WAR09
                                            ,_buf_tex.WAR10
                                            ,_buf_tex.M_ATR
                                            )
   ?}
?};
DK_C.cntx_pop();
_result


\is_atrybut
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Sprawdza czy wyrób zlecenia ma atrybut dostawy
::   WE: [_a] - ZL.ref lub bieżący rekord
::   WY: 0 - nie ma
::       1 - ma
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

M.cntx_psh();
ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? ZL.KTM().M_ATR<>null
   || _result:=1
   ?}
?};
ZL.cntx_pop();
M.cntx_pop();
_result


\kor_chk_limzl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Sprawdza czy po korekcie nowe ilość na zleceniu i powiązanym limicie będą zgodne
::   WE: _a - ZL.ref - Zlecenie, od którego zacząć sprawdzanie zgodności
::       _b - REAL - współczynik korekty
::   WY: obiekt _result o polach:
::       RESULT: 1 - zgodne ilości, 0 - niezgodne ilości
::       ZL: Symbol zlecenia, w którym wystąpiła niezgodność
::       IL_ZL: Ilość po korekcie na zleceniu
::       IL_LIM: Ilość po korekcie na limicie
::----------------------------------------------------------------------------------------------------------------------
_zl:={? var_press('_a')=type_of(null()) || _a || null() ?};
::_zlim:={? var_press('_b')=type_of(null()) || _b || null() ?};
_coef:={? var_press('_b')=type_of(1) || _b || 0 ?};
_result:=obj_new('RESULT','ZL','IL_ZL','IL_ZLIM');
_result.RESULT:=1;
_result.ZL:='';
_result.IL_ZL:=0;
_result.IL_ZLIM:=0;

{? _zl<>null() & _coef<>0
||
   ZL.cntx_psh();
   ZL.clear();
   {? ZL.seek(_zl)
   ||
      ZLIM.cntx_psh();
      exec('openmask','zl_common',ZL.ref());
      ZLIM.clear();
::    Przechodzę po limitach zlecenia, które mogą być raportowane na magazyn (mają zarówno limit jak i zlecenie)
      {? ZLIM.find_tab('first','TMAT','MAG','=','P','ZLEC',,'=',ZL.ref(),'KOR',,'=',0,'KOR2',,'=',0)
      ||
         _ktm:=null();
         {!
         |?
            {? _ktm<>ZLIM.KTM
            || _ktm:=ZLIM.KTM;
::             Wyliczam nową ilość powiązanego zlecenia
               _zl_old_il:=_zl_new_il:=0;
               _zl_sym:='';
               ZL.cntx_psh();
               ZL.index('RTMATSRC');
               ZL.prefix(ZLIM.RTMAT,ZLIM.ZLEC().UNRZL);
               {? ZL.first()
               || _zl_sym:=ZL.SYM;
                  _zl_old_il:=ZL.IL;
                  _zl_new_il:=exec('zaokr','jm',_coef*ZL.IL,ZL.KTM)
               ?};
               ZL.cntx_pop();

               _zlim_old_il:=_zlim_new_il:=0;
::             Wyliczam dotychczasową ilość powiązanego limitu (wraz z korektami)
               ZLIM.cntx_psh();
               ZLIM.clear();
               ZLIM.index('ZKK');
               ZLIM.prefix(ZL.ref(),'T',0,_ktm);
               {? ZLIM.first()
               || {!
                  |?
                     _zlim_old_il+=exec('sum_il','zl_limit',ZLIM.ref(),1);
                     ZLIM.next()
                  !}
               ?};
               ZLIM.cntx_pop();

::             Sprawdzam zgodność tylko, jeśli do tej pory była ona zachowana
               {? _zlim_old_il=_zl_old_il
               ||
::                Wyliczam nową ilość powiązanego limitu
                  _dokl:=exec('jaka_dok_m','jm',ZLIM.KTM);
                  TMAT.cntx_psh();
                  TMAT.use(form(8+ZLIM.RTMAT));
                  TMAT.clear();
                  {? TMAT.seek(ZLIM.RTMAT)
                  || _xjm:=exec('FindAndGet','#table',TKTL,$TMAT.NRK,,"XJM",1);
                     _wsp:=((exec('zaokr','jm',_coef*ZL.IL,ZL.KTM))-ZL.IL)/_xjm;
                     {? _dokl>0
                     || _zlim_new_il:=TMAT.WARB*_wsp
                     || _zlim_new_il:=TMAT.WARB*_wsp
                     ?}
                  ?};
                  TMAT.cntx_pop();
                  _zlim_new_il:=_zlim_old_il+_zlim_new_il;
                  {? _zl_new_il<>_zlim_new_il
                  || _result.RESULT:=0;
                     _result.ZL:=_zl_sym;
                     _result.IL_ZL:=_zl_new_il;
                     _result.IL_ZLIM:=_zlim_new_il
                  ?}
               ?}
            ?};
            ZLIM.find_tab('next','TMAT','MAG','=','P','ZLEC',,'=',ZL.ref(),'KOR',,'=',0,'KOR2',,'=',0) & _result.RESULT>0
         !}
      ?};
      ZLIM.cntx_pop();

::    Przechodzę po podzleceniach zlecenia złożonego
      {? _result.RESULT>0
      ||
         ZL.cntx_psh();
         ZL.index('NRNZL');
         ZL.prefix(ZL.UNRZL);
         {? ZL.first()
         || {!
            |?
::             !!! REKURENCJA !!!
               {? var_press('_tmp')>100 || obj_del(_tmp) ?};
               _tmp:=exec('kor_chk_limzl','zl_common',ZL.ref(),_coef);
               {? _tmp.RESULT=0
               || _result.RESULT:=0;
                  _result.ZL:=_tmp.ZL;
                  _result.IL_ZL:=_tmp.IL_ZL;
                  _result.IL_ZLIM:=_tmp.IL_ZLIM
               ?};
               ZL.next() &  _tmp.RESULT>0
            !}
         ?};
         ZL.cntx_pop()
      ?}
   ?};
   ZL.cntx_pop()
?};
_result


\rej_mat_il_rez
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Zwraca ilość jaka została zarezerwowana dla surowca podczas rejestracji wykonania produkcji
::   WE: _a - w zależności od parametru '_f' ZLGD.ref() lub ZGP.ref() - zapis akordowy/przewodnik.
::            w zależności od parametru '_g' dla którego sprawdzać / pomijać rezerwacje
::       _b - $ZLIM.ref() - limit zlecenia, dla którego sprawdzać rezerwacje
::       _c - MG.ref() - magazyn, dla którego sprawdzać rezerwacje
::       [_d] - $DK.ref() - Ref dok. dostawy w postaci SQL, dla której podrezerwowono surowce
::       [_e] - $EANL.ref() - ref lokalizacji (tylko jak _d<>'' )
::       [_f] - STRING - tryb wywołania : '[ZLGD]' - rezerwacje pojedyńczego zapisu akordowego,
::                                        'ZGP' - rezerwacje wszystkich zapisów akordowych podanej pozycji przewodnika
::       [_g] - NUMBER - tryb sprawdzania: [0] - sprawdzanie dla konkretnego ZGP/ZLGD
::                                          1  - pomijanie konkretnego ZGP/ZLGD, zliczam rezerwacje z pozostałych
::       [_h] - kod palety - gdy podany, sprawdzane rezerwacje z podanym kodem
::   WY: REAL - ilośc zarezerwowana
::----------------------------------------------------------------------------------------------------------------------
_tryb:={? var_pres('_f')=type_of('str') || _f || 'ZLGD' ?};
_ref:={? var_pres('_a')=type_of('') || _a || $_a ?};
_zlim:=_b;
_mg:=_c;
_sc:={? var_pres('_d')=type_of('') || _d || '' ?};
_chk_eanl:=0;
_eanl:={? var_pres('_e')=type_of('') || _chk_eanl:=1;_e || '' ?};
_skip:={? var_pres('_g')=type_of(0) || _g || 0 ?};
_kodpal:={? var_pres('_h')=type_of('') || _h || '' ?};
_ktm:=exec('FindAndGet','#table','ZLIM',_zlim,,"ZLIM.KTM",null());
::_dk_c:=exec('FindAndGet','#table','ZLIM',_zlim,,"ZLIM.DK_C",null());
_zl:=exec('FindAndGet','#table','ZLIM',_zlim,,"ZLIM.ZLEC",null());
_ilr:=0;
REZ.cntx_psh();
{? _skip=0
||
   {? _tryb='ZLGD'
   || REZ.index('ZLREZR');
      {? _sc=''
      || REZ.prefix(_zl,'S','R',_ref,_ktm,_mg,_sc,)
      || {? _chk_eanl>0
         || REZ.prefix(_zl,'S','R',_ref,_ktm,_mg,_sc,_eanl,)
         || REZ.prefix(_zl,'S','R',_ref,_ktm,_mg,_sc,)
         ?}
      ?}
   |? _tryb='ZGP'
   || REZ.index('ZLREZP');
      {? _sc=''
      || REZ.prefix(_zl,'S','R',_ref,_ktm,_mg,_sc,)
      || {? _chk_eanl>0
         || REZ.prefix(_zl,'S','R',ref,_ktm,_mg,_sc,_eanl,)
         || REZ.prefix(_zl,'S','R',_ref,_ktm,_mg,_sc,)
         ?}
      ?}
   ?}
|| REZ.index('ZLREZN');
   {? _sc=''
   || REZ.prefix(_zl,'S','R',_ktm,_mg)
   || {? _chk_eanl>0
      || REZ.prefix(_zl,'S','R',_ktm,_mg,_sc,_eanl,)
      || REZ.prefix(_zl,'S','R',_ktm,_mg,_sc,)
      ?}
   ?}
?};
{? REZ.first()
|| {!
   |?
      {? (_skip=0 | (_skip=1 & ((_tryb='ZLGD' & _ref<>REZ.REFREA) | (_tryb='ZGP' & _ref<>REZ.ZGP))))
         & (_kodpal='' | _kodpal=REZ.KODPAL)
      || _ilr+=REZ.ILR
      ?};
      REZ.next()
   !}
?};
REZ.cntx_pop();
_ilr


\rej_mat_chk_stan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Sprawdza stan magazynowy dla rozpsiek pobieranych surowców REJ_MAT.
::       Stan uwzględnia dedykowane rezerwacje, dostawę oraz lokalizację.
::   WE: _a - w zależności od parametru '_g' $ZLGD.ref() lub #ZGP.ref() - zapis akordowy/przewodnik.
::       _b - $ZLIM.ref() - limit zlecenia, dla którego sprawdzać stan
::       _c - $MG.ref() - magazyn, dla którego sprawdzać stan
::       _d - $ZL.ref()
::       [_e] - $DK.ref() - Ref dok. dostawy w postaci SQL, dla której sprawdzić stan
::       [_f] - $EANL.ref() - ref lokalizacji (tylko jak _e<>'' )
::       [_g] - STRING - tryb wywołania : '[ZLGD]' - rozpiski pojedyńczego zapisu akordowego,
::                                        'ZGP' - rozpiski wszystkich zapisów akordowych podanej pozycji przewodnika
::       [_h] - Typ rozpisek: 'T' - tymczasowe (ekiosk), [N] - nietymczasowe
::       [_i] - NUMBER - uwzględniać dedykowane rezerwacje [1] - Tak, 0 - Nie
::       [_j] - tabela tymczasowa z listą dostaw, wynik wywołania exec('sc_tmp_scean','magazyn_stan')
::              wymagana jak _e<>''
::       [_k] - tabela tymczasowa z listą zarezerwowanych ilości pod konkretne dostawy
::       [_l] - Czy do stanu dostawy dodawać ilośc z rezerwacji ze wszystkich dokumentów dostawy
::              czy tylko podanego refa (_e): [1] - wszystkie, 0 - tylko podany
::       [_m] - co zwracać: [0] - aktualny stan, 1 - łączna ilość już zarezerwowana (ekiosk)
::       [_n] - kod palety
::   WY: REAL - aktualyn stan lub łączna ilość zarezerwowana (zależne od _m)
::----------------------------------------------------------------------------------------------------------------------
_stan:=0;
_tryb:={? var_pres('_g')=type_of('str') || _g || 'ZLGD' ?};
_ref:={? _tryb='ZGP'
      || exec('FindAndGet','#table','ZGP',_a,'zguidep',,null())
      || exec('FindAndGet','#table','ZLGD',_a,,,null())
      ?};
_zlim:=exec('FindAndGet','#table','ZLIM',_b,,,null());
_ktm:=exec('FindAndGet','#table','ZLIM',$_zlim,,"ZLIM.KTM",null());
_mg:=exec('FindAndGet','#table',MG,_c,'mag_s',"ref()",null);
_zl:=exec('FindAndGet','#table','ZL',_d,'zlec_akt',,null());
_sc:={? var_pres('_e')=type_of('str') || _e || '' ?};
_eanl:={? var_pres('_f')=type_of('str') || _f || '' ?};
_lok_dflt:={? _eanl<>'' || exec('FindAndGet','#table','EANL',_eanl,,,null()) || null() ?};
_tmp:={? var_pres('_h')=type_of('str') || _h || 'N' ?};
_rez:={? var_pres('_i')=type_of(0) || _i || 1 ?};
_sctab:={? var_pres('_j')>100
        || _j
::        || _sctab:=exec('sc_tmp_scean','magazyn_stan',null(),_scean);
::           _sctab.prefix()
        ?};
_tab_rez:={? var_pres('_k')>100 || _k || ~~ ?};
_all_sc:={? var_pres('_l')=type_of(0) || _l || 1 ?};
_ret:={? var_pres('_m')=type_of(0) || _m || 0 ?};
_kodpal:={? var_pres('_n')=type_of('') || _n || '' ?};
_pal:={? _kodpal<>'' || exec('kodkINakt','magdok_palety',_kodpal) || null() ?};
_sum_rez:=0;
_czy_rez:=exec('zlim_il_rez','zl_nlimit',$_zlim);
_scean:=exec('FindAndGet','#table',DK,_sc,,"DK.SCEAN",'');
:: Surowiec bez przypisanej dostawy
_dk_c:=exec('FindAndGet','#table','ZLIM',$_zlim,,"ZLIM.DK_C",null());
{? _dk_c<>null()
|| exec('obl_stan','magazyn_stan',_ktm,{? _mg<>null() || 1 || 3 ?},_mg,,,,-2,,,,_dk_c)
|| exec('obl_stan','magazyn_stan',_ktm,{? _mg<>null() || 1 || 3 ?},_mg,,,,-2)
?};
_stan+=BEER.SD;
:: Sprawdzam czy była rezerwacja
{? _rez>0
|| {? _sc='' | _all_sc=0
   || {? _tmp='N'
      || _stan+=exec('rej_mat_il_rez','zl_common',_ref,$_zlim,_mg,_sc,,_tryb,,_kodpal)
      || _ilrez:=exec('rej_mat_check_rez','ekioski',$_zlim,_sc,_kodpal);
         _stan+=_ilrez;
         _sum_rez+=_ilrez
      ?};
::    Dodanie dedykowanych rezerwacji do nielimitów
      {? _czy_rez>0 || _stan+=exec('zlim_il_rez','zl_nlimit',$_zlim) ?}
   || _sctab.prefix(_scean,$_mg,$_ktm);
      {? _sctab.first()
      || {!
         |?
            {? _tmp='N'
            || _stan+=exec('rej_mat_il_rez','zl_common',_ref,$_zlim,_mg,_sctab.SRDK,,_tryb,,_kodpal)
            || _ilrez:=exec('rej_mat_check_rez','ekioski',$_zlim,_sctab.SRDK,_kodpal);
               _stan+=_ilrez;
               _sum_rez+=_ilrez
            ?};
::          Dodanie dedykowanych rezerwacji do nielimitów
            {? _czy_rez>0 || _stan+=exec('sc_il_rez','zl_nlimit',_sctab.SRDK,$_zlim) ?};
            _sctab.next()
         !}
      ?}
   ?}
?};
{? _kodpal<>''
|| _sum_rez:=0;
::  Surowiec z przypisaną paletą (stan ogólny)
   _stan1:=_stan;
   _stan2:=0;
   _stan2+=exec('stnilwym','magazyn_stan',,_mg,_ktm,_lok_dflt,date(),'',_sc,_pal);
   {? _sc='' | _all_sc=0
   || _ilr:=exec('rej_mat_il_rez','zl_common',_ref,$_zlim,_mg,_sc,,_tryb,1,_kodpal);
      _stan2-=_ilr;
      {? _tmp='N'
      || _stan2+=_ilr
      || _ilrez:=exec('rej_mat_check_rez','ekioski',$_zlim,_sc,_kodpal);
         _stan2+=_ilrez;
         _sum_rez+=_ilrez
      ?};
::    Dodanie dedykowanych rezerwacji do nielimitów
      {? _czy_rez>0 || _stan2+=exec('zlim_il_rez','zl_nlimit',$_zlim) ?}
   || _sctab.prefix(_scean,$_mg,$_ktm);
      {? _sctab.first()
      || {!
         |?
            _ilr:=exec('rej_mat_il_rez','zl_common',_ref,$_zlim,_mg,_sctab.SRDK,,_tryb,1,_kodpal);
            _stan2-=_ilr;
            {? _tmp='N'
            || _stan2+=_ilr
            || _ilrez:=exec('rej_mat_check_rez','ekioski',$_zlim,_sctab.SRDK,_kodpal);
               _stan2+=_ilrez;
               _sum_rez+=_ilrez
            ?};
::          Dodanie dedykowanych rezerwacji do nielimitów
            {? _czy_rez>0 || _stan2+=exec('sc_il_rez','zl_nlimit',_sctab.SRDK,$_zlim) ?};
            _sctab.next()
         !}
      ?}
   ?};
   _stan:={? _stan1<_stan2 || _stan1 || _stan2 ?}
?};
{? _sc<>'' & (_scean<>'' | _kodpal<>'')
|| _sum_rez:=0;
::  Surowiec z przypisaną dostawą
   _stan1:=_stan;
   _stan2:=0;
   _sctab.prefix(_scean,$_mg,$_ktm);
   {? _sctab.first()
   ||
      _dk_c_sc:=exec('FindAndGet','#table','DK_C',_sctab.DK_C,,,null());
      {? exec('dkc_compare','zl_limit',_dk_c_sc,_zlim,,0)>0
      ||
::         _stan2+=exec('obl_ssc','magazyn_stan',,,_mg,_ktm,'T',,_scean);
         {!
         |?
            _stan2+=exec('obl_stsc','magazyn_stan',_sctab.RDK,_sctab.NDK,_mg,_ktm,date(0,0,0));
            {? _rez>0
            ||
::             Sprawdzam czy na poszczególne dostawy nie było robionych rezerwacji
               {? _all_sc=1 | (_all_sc=0 & _sc=_sctab.SRDK)
               || _ilr:=exec('rej_mat_il_rez','zl_common',_ref,$_zlim,_mg,_sctab.SRDK,,_tryb,,_kodpal);
                  {? _tmp='N'
                  || _stan2+=_ilr
                  || _ilrez:=exec('rej_mat_check_rez','ekioski',$_zlim,_sctab.SRDK,_kodpal);
                     _stan2+=_ilrez;
                     _sum_rez+=_ilrez
                  ?};
::                Dodanie dedykowanych rezerwacji utworzonych podczas generowania zleceń na podstawie stanów mag.
                  {? _czy_rez>0 || _stan2+=exec('sc_il_rez','zl_nlimit',_sctab.SRDK,$_zlim) ?};
                  {? type_of(_tab_rez)<>0 & _ilr>0
                  || {? _tab_rez.find_key(_sctab.REF,'R')
                     || _tab_rez.ILR+=_ilr;
                        _tab_rez.put()
                     || _tab_rez.REF:=_sctab.REF;
                        _tab_rez.SRDK:=_sctab.SRDK;
                        _tab_rez.SCEAN:=_scean;
                        _tab_rez.ILR:=_ilr;
                        _tab_rez.TYP:='R';
                        _tab_rez.MREF:=$_ktm;
                        _tab_rez.ZLREF:=$_zl;
                        _tab_rez.ZLIM:=$_zlim;
::                        _tab_rez.KODPAL:=_kodpal;
                        _tab_rez.add()
                     ?}
                  ?}
               ?}
            ?};
            _sctab.next()
         !}
      ?}
   ?};
   _stan:={? _stan1<_stan2 || _stan1 || _stan2 ?};
   {? _eanl<>''
   || _sum_rez:=0;
::    Surowiec z przypisaną dostawą i lokalizacją
      _stan1:=_stan;
      _stan2:=0;
      {? _kodpal<>''
      || _stan2+=exec('stnilwym','magazyn_stan',,_mg,_ktm,_lok_dflt,date(),'',_sc,_pal)
      |? _scean<>''
      || _stan2+=exec('stnscean','magazyn_stan',_mg,_ktm,_scean,null(),_lok_dflt,date(0,0,0),0,0)
      || _stan2+=_stan1
      ?};
      _sctab.prefix(_scean,$_mg,$_ktm);
      {? _sctab.first()
      ||
         {!
         |?
::          Od stanu usuwam rezerwacje wynikające z rozpisek REJ_MAT
::          Sprawdzam czy na poszczególne dostawy nie było robionych rezerwacji
            _stan2-=exec('rej_mat_il_rez','zl_common',_ref,$_zlim,_mg,_sctab.SRDK,_eanl,_tryb,1,_kodpal);
            {? _tmp='T' & _rez>0 & (_all_sc=1 | (_all_sc=0 & _sc=_sctab.SRDK))
            || _ilrez:=exec('rej_mat_check_rez','ekioski',$_zlim,_sctab.SRDK,_kodpal);
               _stan2+=_ilrez;
               _sum_rez+=_ilrez;
::             Dodanie dedykowanych rezerwacji
               {? _czy_rez>0 || _stan2+=exec('sc_il_rez','zl_nlimit',_sctab.SRDK,$_zlim) ?}
            ?};
            _sctab.next()
         !}
      ?};
      _stan:={? _stan1<_stan2 || _stan1 || _stan2 ?}
   ?}
?};
{? _ret>0
|| _sum_rez
|| _stan
?}


\biq_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MW [21.14]
:: OPIS: Analiza BI w obszarze "Zlecenia produkcyjne"
::----------------------------------------------------------------------------------------------------------------------
exec('np_run','#b__box','BIQ_TTE_PZLA')


\update_zlgd_braki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Trigery obsługujące pole ZL.BRAKI, ZGH.BRAKI (czy są niezakwalifikowane braki) na podstawie zmian tabeli ZLGD
::   WE: _a - rodzaj trigera: 'add', 'put', 'del'
::----------------------------------------------------------------------------------------------------------------------
_par:='';
_update:=1;
_zl:=ZLGD.ZL;
_zgh:=ZLGD.ZGH;
{? _a='add'
|| {? ZLGD.IL_BRAK>0
   || _par:='T'
   ||
::    Jak wykonanie bez zarejestrowanych braków to nie aktulizuje pola
      _update:=0
   ?}
|? _a='put'
|| _before:=bfld('IL_BRAK');
   _after:=ZLGD.IL_BRAK;
:: Jak nie zmieniono liczby braków to nie aktualizuje pola
   {? _before=_after
   || _update:=0
:: Jak liczba braków została zwiększona to od razu oznaczam jako T
   |? _before<_after
   || _par:='T'
   ?}
|? _a='del'
|| _before:=bfld('IL_BRAK');
:: Jak usunięto zapis, który nie miał zarejestrowanych braków to nie akutalizuje
   {? _before=0
   || _update:=0
   || _zl:=bfld('ZL');
      _zgh:=bfld('ZGH')
   ?}
?};
{? _update>0
|| exec('update_braki','zl_common',_zl,_par);
   exec('update_braki','zl_common',_zgh,_par,,ZGH)
?};
~~


\update_braki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Aktualizuje wartość pola ZL/ZGH.BRAKI (czy są niezakwalifikowane braki) danego zlecenia/przewodnika.
::       Dla zleceń złożonych aktualizowana jest wartość pola dla zlecenia podrzędnego i nadrzędnego
::   WE: _a - ZL.ref()/ZGH.ref()
::       [_b] - STRING - ustalana wartość: T/N - od razu ustala wartość na podaną, jak nie podany (wartość pusta)
::             to wartość jest wyliczana.
::       [_c] - NUMBER - czy aktualizować znacznik na zleceniu nadrzędnym: [1] - Tak, 0 - Nie
::       [_d] - modyfikowana tabela: [ZL] - zlecenie, ZGH - przewodnik
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;
{? type_of(_ref)<>type_of(ZL.ref())
|| return()
?};
_tab:={? var_pres('_d')=type_of(ZL) || _d || ZL ?};
_tab.cntx_psh();
_tab.clear();
{? _tab.seek(_ref)
|| _war_new:={? var_press('_b')=type_of('') || _b || '' ?};
   _update_top:={? var_press('_c')=type_of(0) || _c || 1 ?};
   _war_old:=_tab.BRAKI;
   {? _war_new=''
   ||
::    Sprawdzam czy zlecenie ma niezakwalifikowane braki
      _braki:=exec('has_braki_todo','braki',_ref,0,_tab);
      _war_new:={? _braki>0 || 'T' || 'N' ?};
      _tab.BRAKI:=_war_new;
      {? _tab=ZL & _war_new='T'
      || ZL.STAT_B:='N'
      ?};
      _tab.put()
:: Jak podana wartość to od razu aktualizuje pole, bez ponownego wyliczania
   |? _war_new='T' | _war_new='N'
   || ZL.BRAKI:=_war_new;
      {? _tab=ZL & _war_new='T'
      || ZL.STAT_B:='N'
      ?};
      _tab.put()
   ?};
   {? _update_top>0 & _tab=ZL
   ||
::    Aktualizuje znacznik na zleceniu nadrzędnym na najwyższym poziomie
      _top:=exec('top_level','zl_link',ZL.ref());
      {? _top<>ZL.ref()
      || {? ZL.seek(_top)
         || _war_nad:=ZL.BRAKI;
            {? _war_new<>_war_old
            || {? _war_new='T' & _war_nad<>'T'
               || ZL.BRAKI:=_war_new;
                  {? _war_new='T'
                  || ZL.STAT_B:='N'
                  ?};
                  ZL.put()
               |? _war_new='N'
               ||
::                Sprawdzam czy zlecenie nadrzędne posiada w strukturze zlecenie z niezakwalifikowanymi brakami
                  _braki:=exec('has_braki_todo','braki',ZL.ref(),0);
                  _war_new:={? _braki>0 || 'T' || 'N' ?};
                  ZL.BRAKI:=_war_new;
                  {? _war_new='T'
                  || ZL.STAT_B:='N'
                  ?};
                  ZL.put()
               ?}
            ?}
         ?}
      ?}
   ?}
?};
_tab.cntx_pop();
~~


\typydok_rap
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Zwraca tabelę z typami dokumentów raportujących do zlecenia
::   WE: _a - ZL.ref()
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

{? exec('is_usluga_zl','zl_uslugi',_zl)>0
|| _typydok:=exec('GetTabFromList','#table','TYPYDOK','T',exec('get_typydok_sym','zl_uslugi'))
|| _typydok:=exec('GetTabFromList','#table','TYPYDOK','T',exec('get','#params',500701,2))
?};

_typydok


\zl_delete_rez
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Usuwa powiązane ze zleceniem rezerwacje (do nielimitów)
::   WE: _a - ZL.ref()
::       [_b] - STRING - zakres usuwanych rezerwacji (REZ.ZL_REZ):
::                'T' - dedykowane dla zleceń (nierozpisane rezerwacje dla zleceń wygenerowanych ze stanów mag.),
::                'P' - dedykowane dla nielimitów,
::               [''] - dowolne (wszystkie)
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_zl:={? var_pres('_a')=type_of(null()) || _a || null() ?};
_zl_rez:={? var_pres('_b')=type_of('') || _b || '' ?};
_result:=0;
_can_continue:=1;
{? _zl<>null()
|| _tabmat:=tab_tmp(2,'MREF','STRING[16]','','ILR','REAL','');
   REZ.cntx_psh();
   REZ.use((REZ.name()-2)+'__');
   REZ.index('ZLREZ');
   {? _zl_rez<>''
   || REZ.prefix(_zl,'S','B',_zl_rez)
   || REZ.prefix(_zl,'S','B')
   ?};
   {? REZ.first()
   || {!
      |?
         {? ~_tabmat.find_key($REZ.M)
         || _tabmat.MREF:=$REZ.M;
            _tabmat.ILR:=REZ.ILR;
            _tabmat.add()
         || _tabmat.ILR+=REZ.ILR;
            _tabmat.put()
         ?};
         _can_continue:=REZ.del(,1);
         REZ.first() & _can_continue>0
      !}
   ?};
   REZ.cntx_pop();
:: Aktualizacja stanów po usunięciu rezerwacji
   {? _tabmat.first()
   || {!
      |?
         _mat:=exec('FindAndGet','#table',M,_tabmat.MREF,,,null());
         exec('obl_stan','magazyn_stan',_mat,5);
         exec('aktu_rez','rezerwacje',_mat,0,_tabmat.ILR);
         _tabmat.next()
      !}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
_result


\sc_from_rez
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Wyciąga ref dostawy z podanej rezerwacji
::   WE: _a - REZ.ref()
::   WY: $SC.ref()
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;
_result:='';
REZ.cntx_psh();
_rez_mask:=ref_name(_a);
{? REZ.name()<>_rez_mask || REZ.use(_rez_mask) ?};
REZ.clear();
{? REZ.seek(_a)
|| SC.cntx_psh();
   _msk:=SC.name()-2;
   {? REZ.SC<>'' & 'dokma'=(5+REZ.SC)
   || SC.use(_msk+(form(8+REZ.SC)+2));
      SC.index('SRDK');
      SC.prefix(REZ.SC,REZ.SC);
      {? SC.first()
      || _result:=$SC.ref()
      ?}
   ?};
   SC.cntx_pop()
?};
REZ.cntx_pop();
_result


\gktl_from_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Zwraca grupę kart technologicznych (GKTL.ref()) na postawie przekazanego zlecenia produkcyjnego
::   WE: _a - ZL.ref()
::   WY: GKTL.ref()
::----------------------------------------------------------------------------------------------------------------------
_zl:={? var_pres('_a')=type_of(null()) || _a || return(null()) ?};
_res:=null();
ZL.cntx_psh();
_mask:=ref_name(_zl);
{? _mask<>ZL.name() || ZL.use(_mask) ?};
ZL.prefix();
{? ZL.seek(_zl)
|| _res:=ZL.GKTL
::   _res:=exec('FindAndGet','#table',TKTL,{? ZL.RTKTL<>'' || ZL.RTKTL || ZL.RKTL ?},,"GKTL",null())
?};
ZL.cntx_pop();
_res


\chk_tktl4zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Sprawdza, czy na podstawie danej technologii może zostać wygenerowane zlecenia produkcyjne
::   WE: _a - technologia: TKTL.ref()
::       [_b] - czy wyświetlać dialogi: [1]/0
::   WY: 0 - OK (brak błedu), inna wartość - wystąpił błąd (zwracany nr błędu)
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_tktl:=_a;
_dialog:={? var_pres('_b')=type_of(0) || _b || 1 ?};
_msg:='';
{? _tktl<>null()
|| TKTL.cntx_psh();
   TKTL.prefix();
   {? TKTL.seek(_tktl,ref_name(_tktl),1)
   || {? TKTL.STAN<>'T'
      || _msg:='Nie można utworzyć zlecenia produkcyjnego.\nTechnologia jest niezaakceptowana.'@;
         _res:=2
      |? TKTL.ARCH='T'
      || _msg:='Nie można utworzyć zlecenia produkcyjnego.\nTechnologia jest archiwalna.'@;
         _res:=3
      |? TKTL.TERM_OD<>date(0,0,0) & TKTL.TERM_OD>date() | TKTL.TERM_DO<>date(0,0,0) & TKTL.TERM_DO<date()
      || _msg:='Nie można utworzyć zlecenia produkcyjnego.\nTechnologia jest nieaktualna.'@;
         _res:=4
      ?}
   ?};
   TKTL.cntx_pop()
|| _res:=1;
   FUN.info('Nie można utworzyć zlecenia produkcyjnego.\nNie odnaleziono przekazanej technologii'@)
?};
{? _res>0 & _dialog>0 & _msg<>''
|| FUN.info(_msg)
?};
_res


\chk_ktm4zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Sprawdza, czy na podstawie danego materiału może zostać wygenerowane zlecenia produkcyjne
::   WE: _a - materiał: M.ref()
::       [_b] - czy wyświetlać dialogi: [1]/0
::       [_c] - kategoria zlecenia: ['P'] - proste, 'Z' - złożone
::   WY: 0 - OK (brak błedu), inna wartość - wystąpił błąd (zwracany nr błędu)
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_ktm:=_a;
_dialog:={? var_pres('_b')=type_of(0) || _b || 1 ?};
_kategoria:={? var_pres('_c')=type_of('') || _c || 'P' ?};
_msg:='';
{? _ktm<>null()
|| M.cntx_psh();
   M.prefix();
   {? M.seek(_ktm)
   || {? M.A<>'T'
      || _msg:='Nie można utworzyć zlecenia produkcyjnego.\nIndeks materiałowy jest nieaktywny.'@;
         _res:=2
      |? M.RODZ='T' & M.R_PROD<>'T'
      || _msg:='Nie można utworzyć zlecenia produkcyjnego.\nIndeks materiałowy nie jest produktem.'@;
         _res:=3
      ||
::       Sprawdzenie, czy materiał posiada dowolną (aktywną) technologię na podstawie któej można utworzyć zlecenie
         {? _kategoria='Z'
         || {? exec('is_tech','tech_common',M.ref(),1,1,1)<=0
            || _msg:='Nie można utworzyć zlecenia produkcyjnego złożonego.\n'
                     'Indeks materiałowy nie posiada aktywnej technologii.'@;
               _res:=4
            ?}
         ?}
      ?}
   ?};
   M.cntx_pop()
|| _res:=1;
   _msg:='Nie można utworzyć zlecenia produkcyjnego.\nNie odnaleziono przekazanego materiału'@
?};
{? _res>0 & _dialog>0 & _msg<>''
|| FUN.info(_msg)
?};
_res


\grop_deleted_in_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Obsługa sytuacji że jest czynność na liście todo ale grupa operacji została usunięta/zamknięta
::   WE: _a - obj_new - obiekt Menadżera Procesów
::       [_b] - INTEGER - 0/[1] - czy errorować proces, jeżeli 0 to jest robiony .done()
::       [_c] - INTEGER - 0 - zamknięte, [1] - usunięte
::   WY: ~~
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_mp:=_a;

_error:=1;
{? var_pres('_b')=type_of(0)
|| _error:=_b
?};
_deleted:=1;
{? var_pres('_c')=type_of(0)
|| _deleted:=_c
?};
{? _deleted
|| _msg:=exec('grop_deleted_msg','zl_common')
|| _msg:=exec('grop_closed_msg','zl_common')
?};
{? _mp.isService()=0 & _mp.CLEANER=0
|| {? _mp.isGroup()
   || KOMM.add(_msg,2,,1)
   || FUN.emsg(_msg)
   ?}
?};
{? _error>0
|| _mp.error(_msg)
|| _mp.done()
?};
~~


\grop_deleted_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Komunikat o usunięciu grupy operacji
::----------------------------------------------------------------------------------------------------------------------
'Grupa operacji nie została odnaleziona, prawdopodobnie została usunięta.'@@


\grop_closed_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Komunikat o zamknięciu grupy operacji
::----------------------------------------------------------------------------------------------------------------------
'Grupa operacji jest zamknięta — czynność zostanie zakończona.'@@


\kontr_zamk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.62]
:: OPIS: kontrola możliwosci zamknięcia zlecenia
::   WE: [_a] - 'A' - kontrola automatyczna podczas zamykania zlecenia,
::                    bez wyświetlania wyników, w przypadku błędów _res=0, wpp _res=1
::              'R' - kontrola ręczna podczas zamykania zlecenia,
::                    z wyświetlaniem wyników, operator decyduje o tym, czy _res=0 lub _res=2
::              'S' lub brak parametru - kontrola wywołana z menu, _res=~~
::       [_b] - czy inicjować i wyświetlac KOMM 0/[1]
::       [_c] - INTEGER - tabela, dla której uruchamiana: [0] - zlecenia (ZL), 1 - grupy operacji (GROP)
::   WY: _res - opisane wyzej
::  OLD: \kontr_zamk/zlec2.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') || _param:=_a || _param:='S' ?};
{? var_pres('_b')=type_of(0) || _komm:=_b || _komm:=1 ?};
{? var_pres('_c')=type_of(0) || _where:=_c || _where:=0 ?};

ZL.cntx_psh();

:: Ustawienie VAR.A_ZLEC/VAR.A_GROP - formuły \kontr_* działają w tym kontekście
{? _where=0
|| VAR.A_ZLEC:=ZL.ref();
   VAR.A_GROP:=null()
|| VAR.A_ZLEC:=null();
   VAR.A_GROP:=GROP.ref()
?};

{? _komm
|| {? _where=0
   || KOMM.init(,,'Kontrola zamknięcia zlecenia'@,'')
   || KOMM.init(,,'Kontrola zamknięcia grupy operacji'@,'')
   ?}
?};

_res:=0;

::_zl_sym:=VAR.A_ZLEC().SYM;
VAR.RFR_DOK:=VAR.RFR_LIM:=VAR.RFR_NLI:=0;

{? _where=0
||
   _nzl:=VAR.A_ZLEC().TYP().K_NZL;
   _lim:=ZTP.K_LIM;
   _pdp:=ZTP.K_PDP;
   _nli:=ZTP.K_NLI;
   _rob:=ZTP.K_ROB;
   _ilo:=ZTP.K_ILO
|| _par:=exec('get','#params',500121,type_of(0));
   _nzl:=1+_par;
   _lim:=1+(2-_par);
   _pdp:=1+(1-_par);
   _nli:=1+(3-_par);
   _rob:='N';
   _ilo:=_par+1
?};
::----------------------------------------------------------------------------------------------------------------------
:: Czy wszystkie limity sa zaakceptowane?
_tab2:=exec('kontr_nzl','zl_limit',_nzl,_param,_where);
::----------------------------------------------------------------------------------------------------------------------
:: Czy sa niezaakceptowane dokumenty magazynowe do danego zlecenia/grupy?
_tab4:=exec('kontr_pdp','magdok_prod',_pdp,_param,,_where);
::----------------------------------------------------------------------------------------------------------------------
:: Czy sa pobrane wszystkie surowce limitowane (czy nie pobrano za malo)?
:: Czy nie ma przekroczen w pobraniach surowcow limitowanych, ktore sugerowalyby koniecznosc
::    dokonania zwrotow (uwzgledniajac zarejestrowane braki)?
_tab3:=exec('kontr_lim','zl_limit',_lim,,_param,,,,_where);
::----------------------------------------------------------------------------------------------------------------------
:: Czy sa rozliczone wszystkie surowce nielimitowane lub rozliczono za duzo surowca?
_tab5:=exec('kontr_nli','zl_limit',_nli,,_param,,_where);
::----------------------------------------------------------------------------------------------------------------------
:: Czy jest zarejestrowana robocizna do wszystkich pozycji przewodnikow?
:: Czy sa przekroczenia norm przy zarejestrowanej robociznie?
{? _where=0
|| _tab6:=exec('kontr_rob','zl_wyk',_rob,_param)
|| _tab6:=~~
?};
::----------------------------------------------------------------------------------------------------------------------
:: Czy jest zarejestrowana na pozycjach przewodnika lub zasobach grupy taka ilosc produktu, jaka miala byc zrobiona
{? _where=0
|| _tab7:=exec('kontr_ilo','zl_wyk',_ilo,_param)
|| _tab7:=exec('kontr_ilo','zl_grop',_ilo,_param)
?};
::----------------------------------------------------------------------------------------------------------------------
:: Czy nie minela data zakonczenia zlecenia?
::----------------------------------------------------------------------------------------------------------------------
:: Wyświetlenie wyniku analizy
::----------------------------------------------------------------------------------------------------------------------
params_set('tab2',_tab2,'tab3',_tab3,'tab4',_tab4,'tab5',_tab5,'tab6',_tab6,'tab7',_tab7);

_array:=obj_new(2);
_first:=null();

_test:=obj_new(7);
{! _it:=1..7
|! _test[_it]:=var_pres('_tab'+$_it)=type_of(_array)
!};

{? _test[2] || _first:=_tab2[1]
|? _test[4] || _first:=_tab4[1]
|? _test[3] || _first:=_tab3[1]
|? _test[5] || _first:=_tab5[1]
|?  _where=0 & _test[6] || _first:=_tab6[1]
|? _test[7] || _first:=_tab7[1]
?};

{? type_of(_first)<>type_of(null())
|| {? (_param='R' | _param='S')
   ||
      _tmp:=''; {! _i:=1..7 |! _tmp+=$_test[_it] !};
      {? _where=0
      || _grp:=_first.grp_make('Kontrola zamknięcia zlecenia: %1'@[VAR.A_ZLEC().SYM],,'zlec2_'+_tmp,,,,,'normal')
      || _grp:=_first.grp_make('Kontrola zamknięcia grupy: %1'@[VAR.A_GROP().KOD],,'grop2_'+_tmp,,,,,'normal')
      ?};
      {? _test[2]
      || _first.grp_sel(_grp,_tab2[1],_tab2[2],'Akceptacja limitów'@,,,,,,,,,'maximized_with_title');
         _tab2[1].first()
      ?};
      {? _test[4]
      || _formula:="
            {? VAR.RFR_DOK>0
            || VAR.RFR_DOK:=0;
               exec('kontr_pdp','magdok_prod','T',,cur_tab(1,1),{? VAR.A_GROP<>null() || 1 || 0 ?})
            ?};
            ~~
         ";
         _first.grp_sel(_grp,_tab4[1],_tab4[2],'Akceptacja dokumentów'@,,,,,_formula,,,,'maximized_with_title')
         ; _tab4[1].first()
      ?};
      {? _test[3]
      || _formula:="
            {? VAR.RFR_LIM>0
            || VAR.RFR_LIM:=0;
               exec('kontr_lim','zl_limit','T',0,,cur_tab(1,1),,,{? VAR.A_GROP<>null() || 1 || 0 ?})
            ?};
            ~~
         ";
         _first.grp_sel(_grp,_tab3[1],_tab3[2],'Rozliczenie limitów'@,,,,,_formula,,,,'maximized_with_title');
         _tab3[1].first()
      ?};
      {? _test[5]
      || _formula:="
            {? VAR.RFR_NLI>0
            || VAR.RFR_NLI:=0;
               exec('kontr_nli','zl_limit','T',0,,cur_tab(1,1),,{? VAR.A_GROP<>null() || 1 || 0 ?})
            ?};
            ~~
         ";
         _first.grp_sel(_grp,_tab5[1],_tab5[2],'Rozliczenie surowców nielimitowanych'@,,,,
            ,_formula,,,,'maximized_with_title');
         _tab5[1].first() ?};
      {? _where=0 & _test[6]
      || _first.grp_sel(_grp,_tab6[1],_tab6[2],'Rozliczenie robocizny'@,,,,,,,,,'maximized_with_title');
         _tab6[1].first()
      ?};
      {? _test[7]
      || _first.grp_sel(_grp,_tab7[1],_tab7[2],'Rozliczenie ilości'@,,,,,,,,,'maximized_with_title');
         _tab7[1].first()
      ?};
      _first.win_sel(_grp);
      {? _first.select() & _param='R' || _res:=2 ?}
   ||
      {? _test[2] || exec('komm_add','zl_common','Akceptacja limitów'@,2,,,_where) ?};
      {? _test[4] || exec('komm_add','zl_common','Akceptacja dokumentów'@,2,,,_where) ?};
      {? _test[3] || exec('komm_add','zl_common','Rozliczenie surowców limitowanych'@,2,,,_where) ?};
      {? _test[5] || exec('komm_add','zl_common','Rozliczenie surowców nielimitowanych'@,2,,,_where) ?};
      {? _test[6] || exec('komm_add','zl_common','Rozliczenie robocizny'@,2,,,_where) ?};
      {? _test[7] || exec('komm_add','zl_common','Rozliczenie ilości na przewodnikach'@,2,,,_where) ?};
      {? _komm || KOMM.select() ?};
      _res:=0
   ?}
|| {? _nzl='N' & _pdp='N' & _lim='N' & _nli='N' & _rob='N' & _ilo='N'
   || {? _where=0
      || exec('komm_add','zl_common',
            'Nie przeprowadzono kontroli zlecenia,'
            ' w definicji typu nie określono żadnego rodzaju kontroli.'@,3
         )
      || exec('komm_add','zl_common',
            'Nie przeprowadzono kontroli grupy operacji,'
            ' w parametrze nr 500121 nie określono żadnego rodzaju kontroli.'@,3,,,1
         )
      ?};
      _res:=1
   ||
      exec('komm_add','zl_common','Nie wykazano niezgodności'@,3,,,_where);
      {? _where=0
      || {? ZL.ILWYK=0 & exec('zl_bez_oper','zl_common',ZL.ref())=0
         || exec('komm_add','zl_common','Uwaga: nie zarejestrowano żadnej operacji'@,3)
         ?};
         {? ZL.ILDOK=0
         || exec('komm_add','zl_common','Uwaga: nie zarejestrowano żadnego dokumentu raportującego'@,3)
         ?}
      || {? GROP.ILW=0
         || exec('komm_add','zl_common','Uwaga: nie zarejestrowano żadnego wykonania'@,3,,,1)
         ?}
      ?};
::      exec('komm_add','zl_common','Podczas kontroli zlecenia sprawdzono:'@,3);
::      {? _nzl='T' || exec('komm_add','zl_common','Akceptację limitów zlecenia'@,3) ?};
::      {? _pdp='T' || exec('komm_add','zl_common','Akceptację dokumentów produkcyjnych'@,3) ?};
::      {? _lim='T' || exec('komm_add','zl_common','Poprawność rozliczenia surowców limitowanych'@,3) ?};
::      {? _nli='T' || exec('komm_add','zl_common','Poprawność rozliczenia surowców nielimitowanych'@,3) ?};
::      {? _rob='T' || exec('komm_add','zl_common','Poprawność rejestracji robocizny'@,3) ?};
::      {? _ilo='T' || exec('komm_add','zl_common','Poprawność rejestracji ilości do przewodników'@,3) ?};
      _res:=1
   ?};
   {? _komm || KOMM.select() ?}
?};

{? var_pres('__ZLIM4LIM')>100 || obj_del(__ZLIM4LIM) ?};
{? var_pres('__ZLIM4NLIM')>100 || obj_del(__ZLIM4NLIM) ?};

ZL.cntx_pop();

{? _param='S' || ~~ || _res ?}


\zl_parses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Uniwersalna funkcja na PARSES dla czynności zleceń
::       UWAGA. Do pobrania parametrów stosować params_get() = tablica nazwana:
::       in  - [obj_new] - parametry wejściowe czynności
::       int - [obj_new] - parametry wewnętrzne czynności
::       out - [obj_new] - parametry wyjściowe czynności
::       mp  - obiekt odpowiedzialny za obsługę procesu
::   WE:
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_in:=params_get().in;
_mp:=params_get().mp;

_result:=0;

{? _mp.isService()
|| _zl:={? var_pres('ZL',_in)=type_of(null()) & _in.ZL
        || _in.ZL
        |? var_pres('ZGH',_in)=type_of(null()) & _in.ZGH
        || exec('FindAndGet','#table',ZGH,_in.ZGH,,"ZLEC",null())
        |? var_pres('ZL_NAD',_in)=type_of(null()) & _in.ZL_NAD
        || _in.ZL_NAD
        || null()
        ?};
   {? _zl<>null()
   || _oddz:=exec('FindAndGet','#table',ZL,_zl,,"ODDZ",'');
      {? _oddz<>''
      || _result:=1;
         __PARSES.setVal('OddzialLogProd',_oddz);
         _args:=__PARSES.args('OkresRok');
         _args.OBSZAR:='LMG';
         _args.AR:=date()~1;
         _args.AM:=date()~2;
         __PARSES.setVal('OkresRok',_args)
      ?}
   ?}
|| _result:=1
?};

:: Jeżeli nie udało się ustalić parsesa w trybie serwisowym, to robie error
{? _result=0 & _mp.isService()
|| _msg:='Błędna konfiguracja procesu — brak parametru wejściowego %1.'@@['ZL'];
   _mp.error(_msg)
?};

_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:38 096d51bdc7fe83e02ed853a6bbd29e68ade1fc7336f7eb0fdfff774d01feecac8a4e41e170fc4b40e71cd05dda96e1b3a3db7cce51cd2e57f80c059383415100802b67524039af8bc94d40beb02d6f24644b58b29681d9f7d3cacedfc901da8fee3a3421c77c0ba2d028907a432564c40dbc5e2e3bd39a4feaaa71309093eed9
