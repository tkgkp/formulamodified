:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: remonty_plan.fml
:: Utworzony: 30.10.2019
:: Autor: WH
::======================================================================================================================
:: Zawartość: Obsługa planowania zgłoszeń remontowych
::======================================================================================================================


\plan_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Rozpoczęcie planowania zgłoszenia remontowego
::   WE: [_a] - REM_ZGL.ref()
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};
_result:=0;
_can_continue:=1;

REM_ZGL.cntx_psh();
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? REM_ZGL.WERYFIK='N'
   || _can_continue:=0;
      FUN.emsg('Wynik weryfikacji zgłoszenia: %1 nie pozwala na jego planowanie.'@[exec('REM_ZGL','#to_string')])
   ?}
?};


{? _can_continue>0
|| _can_continue:=exec('plan_load','remonty_plan')
?};

_zas_in_plan:=0;
{? _can_continue>0
|| REM_PLAN.cntx_psh();
   REM_PLAN.index('REM_ZGL');
   REM_PLAN.prefix(REM_ZGL.ref());
   {? REM_PLAN.first()
   || _zas_in_plan:=1
   ?};
   REM_PLAN.cntx_pop()
?};

{? _zas_in_plan>0 & _can_continue>0
||
   {? REM_ZGL.REM_ZAS<>null()
   ||
      {? REM_ZGL.DT_PST=date(0,0,0)
      || REM_ZGL.DT_PST:=date();
         REM_ZGL.TM_PST:=time()
      ?};

      {? REM_ZGL.DUR_TIME=time(0,0,0)
      || REM_ZGL.DUR_TIME:=exec('min2time','#convert',exec('get','#params',500331,type_of(0)))
      ?};

      REM_ZGL.win_edit('PLAN');
      REM_ZGL.hdr_edit('Zgłoszenie remontowe — dane do planowania'@);
      exec('rem_zgl_efld_opt','remonty_zgloszenia','PLAN');
      {? REM_ZGL.edit("params_exec('valid_zgl','remonty_plan')")
      ||
         _can_continue:=REM_ZGL.put();
         {? _can_continue>0
         || _can_continue:=exec('generator_start','remonty_plan')
         ?}
      || _can_continue:=0
      ?}
   ?}
?};
REM_ZGL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\valid_zgl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Walidacja okienka z planowaniem tabeli REM_ZGL
::   WY: '' lub akronim pola do którego wrócić
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_chk:='';

_has_planned_zas:=1;
REM_PLAN.cntx_psh();
REM_PLAN.index('REM_ZGL');
REM_PLAN.prefix(REM_ZGL.ref());
{? REM_PLAN.first()=0
|| _has_planned_zas:=0
?};
REM_PLAN.cntx_pop();

{? REM_ZGL.WERYFIK='T' & _has_planned_zas>0
||
   _tmstmp_pst:=exec('create','#tm_stamp',REM_ZGL.DT_PST,REM_ZGL.TM_PST);
   _tmstmp_pua:=exec('create','#tm_stamp',REM_ZGL.DT_PUA,REM_ZGL.TM_PUA);
   _tmstmp_wa:=exec('create','#tm_stamp',REM_ZGL.DT_WA,REM_ZGL.TM_WA);
   {? _chk=''
   ||
      {? REM_ZGL.PL_TRYB<>'R'
      ||
         {? REM_ZGL.DT_PST=date(0,0,0)
         || FUN.info('Data planowanego rozpoczęcia nie może być pusta.'@);
            _chk:='DT_PST'
         |? REM_ZGL.DT_PUA<>date(0,0,0) & _tmstmp_pua<_tmstmp_wa
         || FUN.info('Data i godzina planowanego usunięcia nie może być wcześniejsza niż data i godzina zdarzenia.'@);
            _chk:='DT_PUA'
         |? REM_ZGL.DT_PUA<>date(0,0,0) & _tmstmp_pua<_tmstmp_pst
         || FUN.info('Data i godzina planowanego rozpoczęcia nie może być wcześniejsza niż data i godzina zakończenia.'@);
            _chk:='DT_PST'
         ?};
         {? _chk='' & REM_ZGL.DT_PUA=date(0,0,0) & REM_ZGL.TM_PUA<>time(0,0,0)
         || _msg:='Data planowanego usunięcia nie może być zerowa'@;
            FUN.info(_msg);
            _chk:='DT_PUA'
         ?}
      ?}
   ?};
   {? _chk='' & REM_ZGL.PL_TRYB<>'R'
   || {? REM_ZGL.DT_PST<date()
      || _msg:='Data planowanego rozpoczęcia nie może być w przeszłości'@;
         FUN.info(_msg);
         _chk:='DT_PST'
      ?}
   ?};
   {? _chk='' & REM_ZGL.PL_TRYB='R'
   || {? REM_ZGL.DUR_TIME=time(0,0,0)
      || _msg:='Domyślny czas trwania nie może być zerowy'@;
         FUN.info(_msg);
         _chk:='DUR_TIME'
      ?}
   ?};
   {? _chk='' & REM_ZGL.PL_TRYB<>'R' & REM_ZGL.PL_DOST<>'B'
   || _chk:=exec('valid_calend','remonty_plan')
   ?}
?};
_chk


\plan_zasoby
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Przycisk 'Zasoby' w oknie planowania zgłoszenia remontowego
::   WE: [_a] REM_ZGL.ref - zgłoszenie lub bieżący rekord
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};

_can_continue:=1;

REM_ZGL.cntx_psh();
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _chk:=exec('valid_zgl','remonty_plan');
   {? _chk<>''
   || _can_continue:=0
   ?};

   {? _can_continue>0
   ||
      _can_continue:=exec('plan_load','remonty_plan');
      {? _can_continue>0
      ||
         VAR.STRING:='%';
         REM_PLAN.cntx_psh();
         REM_PLAN.win_sel('WERT');
         REM_PLAN.win_edit('RED');
         REM_PLAN.index('TREE');
         REM_PLAN.prefix(REM_ZGL.ref());
         REM_PLAN.first();
         REM_PLAN.select();
         REM_PLAN.cntx_pop()
      || FUN.emsg('Nie udało się załadowanie dostępnych zasobów.'@)
      ?}
   ?}
?};
REM_ZGL.cntx_pop();
''


\plan_load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Tworzy aktualizuje rekordy tabeli REM_PLAN dla danego zgłoszenia remontowego
::   WE: [_a] REM_ZGL.ref - zgłoszenie lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};
_result:=0;
_can_continue:=1;
REM_ZGL.cntx_psh();
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? REM_ZGL.REM_ZAS<>null
   ||
      REM_ZAS.cntx_psh();
      REM_ZGL.REM_ZAS();
      _can_continue:=exec('rem_zas2rem_plan','remonty_plan');

      {? _can_continue>0
      || _can_continue:=exec('rem_plan_tree','remonty_plan')
      ?};
      REM_ZAS.cntx_pop();
      ~~
   ||
::    Brak zasobu na zgłoszeniu - usuwam wszystkie REM_PLANy
      REM_PLAN.cntx_psh();
      REM_PLAN.index('REM_ZGL');
      REM_PLAN.prefix(REM_ZGL.ref());
      {? REM_PLAN.first()
      || {!
         |? _can_continue:=exec('rem_plan_delete','remonty_plan',REM_PLAN.ref());
            REM_PLAN.first() & _can_continue>0
         !}
      ?};
      REM_PLAN.cntx_pop()
   ?}
?};
REM_ZGL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\rem_zas2rem_plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Tworzy lub aktualizuje rekord REM_PLAN na podstawie bieżącego REM_ZAS i REM_ZGL
::   WE: [_a] - INTEGER - 0/1 czy rekurencyjnie można dodawać zasoby nadrzędne
::       [_b] - INTEGER - 0/1 czy rekurencyjnie można dodawać zasoby podrzędne
::       [_c] - REAL - tm_stamp modyfikacji
::       [_d] - INTEGER - [0]/1 - czy wywołanie rekurencyjne
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------

_rec_up:=1;
{? var_pres('_a')=type_of(0)
|| _rec_up:=_a
?};

_rec_down:=1;
{? var_pres('_b')=type_of(0)
|| _rec_down:=_b
?};

_mod:=REM_PLAN.tm_stamp();
{? var_pres('_c')=type_of(0)
|| _mod:=_c
?};

_rec:=0;
{? var_pres('_d')=type_of(0)
|| _rec:=_d
?};

_result:=0;
_can_continue:=1;

REM_PLAN.cntx_psh();
REM_PLAN.index('REM_ZGL');

_px:=exec('rem_zas_px','zasoby');
_pl:=exec('rem_zas_pl','zasoby');

REM_PLAN.prefix(REM_ZGL.ref(),REM_ZAS.ref());
{? (_px>0 | _pl>0) & REM_ZAS.AKT='T'
||
   {? REM_PLAN.first()=0
   ||
::    Dołączanie nowego
      REM_PLAN.blank();
      REM_PLAN.REM_ZAS:=REM_ZAS.ref();
      REM_PLAN.REM_ZGL:=REM_ZGL.ref();

      {? REM_ZGL.PL_DOST='' | REM_ZGL.PL_DOST='B'
      || REM_PLAN.USABLE:=100
      |? REM_ZGL.PL_DOST='P'
      || REM_PLAN.USABLE:=50
      |? REM_ZGL.PL_DOST='C'
      || REM_PLAN.USABLE:=0
      ?};
      {? _pl<>null()
      || REM_PLAN.PL_OCCUR:='T';
         REM_PLAN.PL_RES:=_pl
      ?};
      {? _px<>null()
      || REM_PLAN.PX_OCCUR:='T'
      ?};
      REM_PLAN.TM_MOD:=_mod;
      _can_continue:=REM_PLAN.add()
   ||
::    Poprawianie istniejącego
      {? REM_PLAN.MANUAL<>'T'
      ||
         {? REM_ZGL.PL_DOST='' | REM_ZGL.PL_DOST='B'
         || REM_PLAN.USABLE:=100
         |? REM_ZGL.PL_DOST='P'
         || REM_PLAN.USABLE:=50
         |? REM_ZGL.PL_DOST='C'
         || REM_PLAN.USABLE:=0
         ?}
      ?};
      {? _pl<>null()
      || REM_PLAN.PL_OCCUR:='T';
         REM_PLAN.PL_RES:=_pl
      ?};
      {? _px<>null()
      || REM_PLAN.PX_OCCUR:='T'
      ?};
      REM_PLAN.TM_MOD:=_mod;
      _can_continue:=REM_PLAN.put()
   ?}
||
:: Jeżeli nie ma w zasobach do planu już, to usuwam
   {? REM_PLAN.first()
   || _can_continue:=exec('rem_plan_delete','remonty_plan',REM_PLAN.ref())
   ?}
?};

REM_PLAN.cntx_pop();

{? _can_continue>0
|| {? REM_ZAS.TREE<>null() & _rec_up>0
   ||
::    Dodaję rekurencyjnie również zasoby nadrzędne
      REM_ZAS.cntx_psh();
      REM_ZAS.prefix();
      {? REM_ZAS.seek(REM_ZAS.TREE,)
      ||
::       !!! REKURENCJA !!!
         _can_continue:=exec('rem_zas2rem_plan','remonty_plan',_rec_up,0,_mod,1)
      ?};
      REM_ZAS.cntx_pop()
   ?}
?};

{? _can_continue>0 & _rec_down>0
||
:: Dodaję rekurencyjnie również zasoby podrzędne
   REM_ZAS.cntx_psh();
   REM_ZAS.index('TREE');
   REM_ZAS.prefix(REM_ZAS.ref());

   {? REM_ZAS.first()
   || {!
      |?
::       !!! REKURENCJA !!!
         _can_continue:=exec('rem_zas2rem_plan','remonty_plan',0,_rec_down,_mod,1);
         REM_ZAS.next() & _can_continue>0
      !}
   ?};
   REM_ZAS.cntx_pop()
?};

{? _rec=0
||
:: Usuwam zbędne rekordy REM_PLAN (zabezpieczenie na wypadek zmiany zasobu na zgłoszeniu)
   REM_PLAN.cntx_psh();
   REM_PLAN.index('REM_ZGL');
   REM_PLAN.prefix(REM_ZGL.ref());
   {? REM_PLAN.first()
   || {!
      |? _next:=0;
         _ref_nxt:=null();
         REM_PLAN.cntx_psh();
         {? REM_PLAN.next()
         || _ref_nxt:=REM_PLAN.ref()
         ?};
         REM_PLAN.cntx_pop();

         {? REM_PLAN.TM_MOD<>_mod
         || _can_continue:=exec('rem_plan_delete','remonty_plan',REM_PLAN.ref())
         ?};

         {? _ref_nxt<>null()
         || _next:=REM_PLAN.seek(_ref_nxt)
         ?};
         _next>0 & _can_continue>0
      !}
   ?};
   REM_PLAN.cntx_pop()
?};

{? _can_continue>0
|| _result:=1
?};
_result


\rem_plan_tree
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Aktualizuje drzewo w tabeli REM_PLAN dla danego REM_ZGL
::   WE: [_a] REM_ZGL.ref - zgłoszenie lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

REM_ZGL.cntx_psh();
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| REM_ZAS.cntx_psh();
   REM_PLAN.cntx_psh();
   REM_PLAN.index('REM_ZGL');
   REM_PLAN.prefix(REM_ZGL.ref());
   {? REM_PLAN.first()
   || {!
      |? {? REM_PLAN.REM_ZAS<>null()
         || REM_PLAN.TREE:=exec('rem_plan_find','remonty_plan',,REM_PLAN.REM_ZAS().TREE);
            _can_continue:=REM_PLAN.put()
         ?};
         REM_PLAN.next()
      !}
   ?};
   REM_ZAS.cntx_pop();
   REM_PLAN.cntx_pop();
   ~~
?};
REM_ZGL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\rem_plan_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Znajduje rekord REM_PLAN
::   WE: [_a] - REM_ZGL.ref - zgłoszenie
::       _b - REM_ZAS.ref - zasób
::   WY: null lub REM_PLAN.ref
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};
_rem_zas:=_b;

_result:=null;
_can_continue:=1;

REM_ZGL.cntx_psh();
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0 & _rem_zas<>null()
||
   REM_PLAN.cntx_psh();
   REM_PLAN.index('REM_ZGL');
   REM_PLAN.prefix(REM_ZGL.ref(),_rem_zas);
   {? REM_PLAN.first()
   || _result:=REM_PLAN.ref()
   ?};
   REM_PLAN.cntx_pop()
?};
REM_ZGL.cntx_pop();
_result


\popraw_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Akcja 'Popraw' w oknie wertowania REM_PLAN
::   WE: [_a] - INTEGER - 0/1 - czy wyświetlać dialogi, jeżeli nie podane to badane na podstawie
::                        zaznaczenia w tabeli REM_PLAN
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------

_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
|| {? REM_PLAN.sel_size()>0
   || _dialog:=0
   ?}
?};

_result:=0;
_can_continue:=1;

{? _dialog>0
|| REM_PLAN.win_edit('RED');
   REM_PLAN.hdr_edit('Dostępność zasobu: %1'@[exec('record','#to_string',REM_PLAN.REM_ZAS)]);
   {? REM_PLAN.edit("params_exec('valid_plan','remonty_plan')")
   || REM_PLAN.MANUAL:='T';
      _can_continue:=REM_PLAN.put()
   || _can_continue:=0
   ?}
||
:: Dla akcji grupowej dostępność przychodzi ze zmiennej REMONTY
   REM_PLAN.USABLE:=REMONTY.USABLE;
   REM_PLAN.MANUAL:='T';
   _can_continue:=REM_PLAN.put()
?};
{? _can_continue>0
|| _result:=1
?};
_result


\valid_plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Walidacja okienka redagowania REM_PLAN
::   WY: '' lub pole do którego wrócić
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_result:='';
{? REM_ZGL.PL_TRYB<>'R'
||
   {? cur_tab(1,1).USABLE<0
   || FUN.emsg('Dostępność musi być większa lub równa zero.'@);
      _result:='USABLE'
   ?};
   {? _result=''
   || {? cur_tab(1,1).USABLE>100
      || FUN.emsg('Dostępność nie może być większa niż: %1'@['100%']);
         _result:='USABLE'
      ?}
   ?}
?};
_result


\valid_calend
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Walidacja okienka redagowania REM_PLAN - część dotycząca kalendarzy
::   WY: '' lub pole do którego wrócić
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_result:='';

_args:=obj_new( 'DATE'
               ,'TIME'
               ,'DIR'
               ,'TM_START'
               ,'TM_END'
               ,'RESULT'
               ,'REM_INT'
               ,'ZASOB');

_args.TM_START:=exec('create','#tm_stamp',REM_ZGL.DT_PST,REM_ZGL.TM_PST);
_args.TM_END:=exec('create','#tm_stamp',REM_ZGL.DT_PUA+1,REM_ZGL.TM_PUA);

{? REM_ZGL.DT_PUA<>date(0,0,0)
|| ~~
||
:: Remont bezterminowy
   _args.TM_END:=REM_ZGL.TM_START+1
?};
KOMM.init(250,,'Weryfikacja kalendarzy zasobów'@);
exec('plan_load','remonty_plan');

_args.RESULT:=0;
_args.DIR:=1;
_args.REM_INT:=exec('interval','#interval');
_args.REM_INT.START:=_args.TM_START;
_args.REM_INT.END:=_args.TM_END;
_args.ZASOB:='';

_rule:="
   _args:=_a;
   _can_continue:=1;

   _int_kal:=exec('interval','#interval');
   _int_kal.START:=KAL_DEF.TM_START;
   _int_kal.END:=KAL_DEF.TM_END;

   _int_rem1:=exec('interval','#interval');
   _point:=exec('create','#tm_stamp',_args.DATE,_args.TIME);
   {? _args.DIR>0
   || _int_rem1.START:=_point;
      _int_rem1.END:=_point+1
   || _int_rem1.START:=_point-1;
      _int_rem1.END:=_point
   ?};

   _dur_and1:=exec('intervals_and','#interval',_int_kal,_int_rem1);
   {? exec('interval_dur','#interval',_dur_and1)>0
   ||
::    Jest część wspólna dla badanego punktu czasowego
      _args.RESULT:=1;
      _can_continue:=0
   ?};
   _can_continue
";

PL_RES.cntx_psh();
KAL_ROK.cntx_psh();
KAL_ROK.index('KAL_ROK');
REM_PLAN.cntx_psh();
REM_PLAN.index('REM_ZGL');
REM_PLAN.prefix(REM_ZGL.ref());
{? REM_PLAN.first()
|| {!
   |? {? REM_PLAN.USABLE<100 & REM_PLAN.PL_RES<>null()
      || _kal_nazw:=REM_PLAN.PL_RES().KAL_NAZW;
         {? _kal_nazw<>null()
         || _args.ZASOB:=PL_RES.SYM;

            {? _result=''
            ||
               _args.DATE:=REM_ZGL.DT_PST;
               _args.TIME:=REM_ZGL.TM_PST;
               _args.DIR:=1;
               _args.RESULT:=0;
               exec('rule4kaldef','po_plan',_kal_nazw,_args.TM_START,_args.TM_END,_rule,,_args);
               {? _args.RESULT=0
               || _result:='DT_PST';
                  _msg:='Planowane rozpoczęcie: %1 jest niezgodne z kalendarzem zasobu: %2'@[$_args.TIME,_args.ZASOB];
                  KOMM.add(_msg,2)
               ?}
            ?};
            {? _result='' & REM_ZGL.DT_PUA<>date(0,0,0)
            || _args.DATE:=REM_ZGL.DT_PUA;
               _args.TIME:=REM_ZGL.TM_PUA;
               _args.DIR:=-1;
               _args.RESULT:=0;
               exec('rule4kaldef','po_plan',_kal_nazw,_args.TM_START,_args.TM_END,_rule,,_args);
               {? _args.RESULT=0
               || _result:='DT_PUA';
                  _msg:='Planowane zakończenie: %1 jest niezgodne z kalendarzem zasobu: %2'@[$_args.TIME,_args.ZASOB];
                  KOMM.add(_msg,2)
               ?}
            ?}
         ?}
      ?};
      REM_PLAN.next() & _result=''
   !}
?};
KOMM.select();
REM_PLAN.cntx_pop();
KAL_ROK.cntx_pop();
PL_RES.cntx_pop();
_result


\popraw_action_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Akcja grupa przed 'Popraw' w oknie wertowania REM_PLAN
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_tab:=cur_tab(1,1);

REM_PLAN.blank();
REM_PLAN.REM_ZAS:=REM_ZGL.REM_ZAS;
REM_PLAN.REM_ZGL:=REM_ZGL.ref();
REM_PLAN.win_edit('RED');
REM_PLAN.hdr_edit('Dostępność zasobów (grupowa)'@);
{? REM_PLAN.edit("params_exec('valid_plan','remonty_plan')")
|| REMONTY.USABLE:=REM_PLAN.USABLE;
   _result:=1;
   sel_nchk();
   KOMM.init(200,,'Grupowa edycja dostępności zasobów'@)
?};
_result


\popraw_action_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Akcja grupa po 'Popraw' w oknie wertowania REM_PLAN
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
KOMM.select()


\default_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Akcja 'Odtwórz domyślne' w oknie wertowania REM_PLAN
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_msg:='Czy odtworzyć domyślną dostępność w planie wszystkich zasobów zgłoszenia: %1'@[exec('record','#to_string',REM_ZGL.ref())];
_can_continue:=FUN.ask(_msg);

_result:=0;

{? _can_continue>0
|| REM_PLAN.cntx_psh();
   REM_PLAN.index('REM_ZGL');
   REM_PLAN.prefix(REM_ZGL.ref());

   {? REM_PLAN.first()
   || {!
      |? _can_continue:=exec('rem_plan_delete','remonty_plan',REM_PLAN.ref());
         REM_PLAN.first()>0 & _can_continue>0
      !}
   ?};

   {? _can_continue>0
   ||
::    Wszystko usunięte, ładuję nową zawartość
      exec('plan_load','remonty_plan')
   || FUN.emsg('Nie udało się odtworzyć domyślnych wartości dostępności zasobów.'@)
   ?};
   REM_PLAN.cntx_pop();
   ~~
?};
{? _can_continue>0
|| _result:=1
?};
_result


\zwin_rozwin
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Akcja 'Zwiń/rozwiń' w tabeli REM_PLAN
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
exec('zwin_rozwin','#tree');
~~


\generator_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Odświeżenie planów zgłoszenia remontowego
::   WE: [_a] - REM_ZGL.ref - zgłoszenie lub bieżący rekord
::       [_b] - INTEGER - 0/[1] - czy inicjować i wyświetlać KOMMa
::       [_c] - INTEGER - [0]/1 - czy aktualizować progressa?
::       [_d] - INTEGER - 0/[1] - czy planować strategicznie?
::       [_e] - INTEGER - 0/[1] - czy planować operacyjnie?
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};
_komm_init:=1;
{? var_pres('_b')=type_of(0)
|| _komm_init:=_b
?};
_progress:=0;
{? var_pres('_c')=type_of(0)
|| _progress:=_c
?};
_plan_px:=1;
{? var_pres('_d')=type_of(0)
|| _plan_px:=_d
?};
_plan_pl:=1;
{? var_pres('_e')=type_of(0)
|| _plan_pl:=_e
?};

_result:=0;
_can_continue:=1;

{? _komm_init>0
|| KOMM.init(250,,'Planowanie zgłoszenia remontowego'@)
?};

REM_ZGL.cntx_psh();
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _can_continue:=exec('plan_load','remonty_plan')
?};

{? _can_continue>0
||
:: Uaktualniam zdarzenie
   _can_continue:=exec('REM_ZGL_add','po_event')
?};

{? _can_continue>0
||
:: Najpierw usuwam z wersji wszystkie PX_POZy powiazane z tym remontem, jesli jakies istnialy
   _px_ver:=exec('get_mainversion','px_ver');
   _can_continue:=exec('rem_clear','px_poz',REM_ZGL.ref(),_px_ver);
   _tm_stamp:=exec('create','#tm_stamp',REM_ZGL.DT_PST,REM_ZGL.TM_PST);
   {? _can_continue>0 & _tm_stamp>0 & REM_ZGL.PL_DOST<>'B'
   ||
      REM_PLAN.cntx_psh();
      REM_PLAN.index('REM_ZGL');
      REM_PLAN.prefix(REM_ZGL.ref());
      {? REM_PLAN.first()
      || {!
         |? {? _plan_px>0 & REM_PLAN.PX_OCCUR='T' & REM_ZGL.PL_TRYB<>'R'
            ||
               {? _progress=1
               || _msg:='Planowanie zgłoszenia: %1'@[exec('REM_ZGL','#to_string')];
                  progress(,_msg+'…',exec('nazwa','#system'),1)
               ?};
               exec('generator_px','remonty_plan')
            ?};
            {? _plan_pl>0 & REM_PLAN.PL_OCCUR='T'
            ||
               {? _progress=1
               || _msg:='Planowanie zgłoszenia: %1'@[exec('REM_ZGL','#to_string')];
                  progress(,_msg+'…',exec('nazwa','#system'),1)
               ?};

::             Przeplanowanie w planie operacyjnym następuje po stronie javy
::             tutaj musimy usunąć z planu to co było wcześniej zaplanowane
               exec('rem_clear','po_plan')
            ?};
            REM_PLAN.next() & _can_continue>0
         !}
      ?};
      REM_PLAN.cntx_pop()
   ?}
?};
REM_ZGL.cntx_pop();

{? _komm_init>0
|| KOMM.select()
?};

{? _can_continue>0
|| _result:=1
?};
_result


\generator_px
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Tworzy plan zgłoszenia na pojedynczym zasobie planu strategicznego
::   WE: [_a] - REM_PLAN.ref - plan zgłoszenia remontowego lub bieżący rekord
::       [_b] - PX_VER.ref() - wersja w ktorej tworzyc
::       [_c] - INTEGER      - 0/1 - czy ustalać wartość zmiennej PX_VAR.NAST_ALG
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_PLAN.ref())
|| _ref:=_a
?};
_px_ver:=exec('get_mainversion','px_ver');
{? var_pres('_b')=type_of(PX_POZ.ref())
|| _px_ver:=_b
?};

_nast_alg:=1;
{? var_pres('_c')=type_of(0)
|| _nast_alg:=_c
?};
{? _nast_alg>0
|| exec('opernast_init','px_init')
?};

_result:=0;
_can_continue:=1;

{? PX_VAR.NAST_ALG=0
|| exec('opernast_init','px_init')
?};
PX_VAR.P500380:=exec('get','#params',500380,type_of(''));
PX_VAR.P500381:=exec('get','#params',500381,type_of(''));

PX_VER.cntx_psh();
PX_VER.prefix();
PX_KONT.cntx_psh();
PX_KONT.prefix();
REM_ZGL.cntx_psh();
REM_PLAN.cntx_psh();
{? _ref<>null()
|| REM_PLAN.prefix();
   {? REM_PLAN.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _can_continue:=PX_VER.seek(_px_ver)
?};
{? _can_continue>0
|| _px_kont:=exec('rem_zas_px','zasoby',REM_PLAN.REM_ZAS);
   _pl_res:=null();
   {? REM_PLAN.REM_ZGL().TWRKPLC<>null()
   || _pl_res:=exec('get_plres','po_plan','S',REM_ZAS.TWRKPLC)
   |? REM_PLAN.REM_ZGL().TWRKZBR<>null()
   || _pl_res:=exec('get_plres','po_plan','G',REM_ZAS.TWRKZBR)
   ?};
   {? REM_PLAN.USABLE<100 & REM_PLAN.REM_ZGL().PL_DOST<>'B' & _px_kont<>null()
   ||
      {? PX_KONT.seek(_px_kont)
      ||
         _dir:=1;
         _kal_nazw:=PX_KONT.PL_RES().KAL_NAZW;

::       Wyszukiwanie lub zakladanie PX_OBJ
         _px_obj:=exec('get_rem_object','px_obj',REM_ZGL.ref());
         {? _px_obj=null()
         || exec('rem2obj','px_obj');
            _px_obj:=exec('get_rem_object','px_obj',REM_ZGL.ref())
         ?};

         _ti_ver:=exec('interval','#interval');
         _ti_ver.START:=PX_VER.TM_START;
         _ti_ver.END:=PX_VER.TM_END;

         {? _can_continue>0
         ||
            _can_continue:=0;
::          Sprawdzanie statusu zgłoszenia
            {? REM_ZGL.STAT_REJ=exec('status_verified','remonty_zgloszenia') |
               REM_ZGL.STAT_REJ=exec('status_completed','remonty_zgloszenia')
            || _can_continue:=1
            ?}
         ?};

         {? _can_continue>0
         ||
            _ti_oporg:=exec('interval','#interval');
            _ti_oporg.START:=exec('create','#tm_stamp',REM_ZGL.DT_PST,REM_ZGL.TM_PST);
            _ti_oporg.END:=exec('create','#tm_stamp',REM_ZGL.DT_PUA,REM_ZGL.TM_PUA);
            {? REM_ZGL.DT_PUA=date(0,0,0)
            ||
::             Jeżeli data usunięcia awarii zerowa, to planuję do ostatniego pojemnika
               PX_CUP.cntx_psh();
               PX_CUP.index('TM_START');
               PX_CUP.prefix(PX_KONT.ref());
               {? PX_CUP.last()
               || _ti_oporg.END:=PX_CUP.TM_END
               ?};
               PX_CUP.cntx_pop()
            ?};

            _dur_oporg:=exec('interval_dur','#interval',_ti_oporg);

::          Musze zaplanowac tylko takie remonty ktore przecinaja zakres wersji
::          i tylko w zakresie w ktorym operacja i wersja sie przecinaja
            _ti_oper:=exec('intervals_and','#interval',_ti_ver,_ti_oporg);
            _dur_oper:=exec('interval_dur','#interval',_ti_oper);
            {? _dur_oper>0 & _ti_oper.END>0
            ||
::             Znajduje kontener w wersji docelowej
               PX_KONT.index('ACT');
               PX_KONT.prefix('T',_px_ver,PX_KONT.SYMBOL,);
               {? PX_KONT.first()
               ||
::                Jestem na docelowym kontenerze
::                Szukam pierwszego pojemnika od ktorego bede planowal
                  {? var_pres('_tab')>100
                  || obj_del(_tab)
                  ?};
                  _tab:=~~;
                  {? PX_VAR.NAST_ALG=2
                  ||
::                   Algorytm nakładkowania metodą proporcji czasowej działa w oparciu o PX_CAL
                     _tab:=PX_CAL
                  ||
::                   Standardowe planowanie działa w oparciu o PX_CUP
                     _tab:=PX_CUP
                  ?};
                  _start:=0;
                  {? _dir>0
                  || _start:=_ti_oper.START
                  || _start:=_ti_oper.END
                  ?};
                  {? exec('cup_point_check','px_plan',PX_KONT.ref(),_start,_dir,_tab,PX_KONT.PL_RES)>0
                  ||
                     {? _tab=PX_CAL
                     ||
::                      Jeżeli operuję na PX_CAL to i tak muszę ustawić indeks na PX_CUP
                        exec('cup_point_check','px_plan',PX_KONT.ref(),_start,_dir,PX_CUP,PL_OZ.PL_RES);
                        PX_CAL.PX_CUP()
                     ?};

::                   Wyznaczam ilosc pojemnikow w ktorych powinienem zaplanowac operacje
                     _cups_count:=exec('cups_count','px_tie',_ti_oper);
                     _next_cup:=1;

::                   Do proporcji między zasobami dodaję proporcję z dostępności
::                     _prop:=1-(REM_PLAN.USABLE/100);
::
::                     {? _prop<=0
::                     || _prop:=0
::                     ?};
::                     {? _prop>1
::                     || _prop:=1
::                     ?};
                     _prop:=1;
                     {? _pl_res<>null()
                     ||
::                      Wyznaczam proporcje miedzy zasobami
                        _prop:=exec('plres_prop','px_tie',PX_KONT.PL_RES,_pl_res);
                        {? _prop<=0
                        || _prop:=1
                        ?}
                     ?};


::                   W petli po pojemnikach dodaje wyliczone pojemnosci
                     {! _it:=1.._cups_count
                     |?
                        _next_cup>0
                     |!
                        {? PX_VAR.NAST_ALG=2 & _it>1
                        || exec('cup_point_check','px_plan',PX_KONT.ref(),PX_CUP.TM_START,_dir,PX_CAL,PL_OZ.PL_RES)>0
                        ?};

                        _can_continue:=exec('interval2pxpoz','px_tie',_ti_oporg,_dir,_kal_nazw,null(),_px_obj,null,_prop,,REM_PLAN.ref());

                        {? _can_continue>0
                        || _next_cup:=PX_CUP.next()
                        || _next_cup:=0
                        ?}
                     !}
                  ||
                     {? _tab=PX_CAL
                     || _nast_alg:=PX_VAR.NAST_ALG;
                        PX_VAR.NAST_ALG:=3;
::                      Jeżeli nie znalazłem kalendarza to pewnie dlatego że w PX coś zaplanowane w tym czasie
::                      zmieniam algorytm następstwa i planuję tam ponownie na siłę
::                      !!! REKURENCJA !!!
                        _can_continue:=exec('generator_px','remonty_plan',,,0);
                        PX_VAR.NAST_ALG:=_nast_alg;
                        ~~
                     || _can_continue:=0;
                        _msg:='Nie powiodło się zaplanowanie remontu. ';
                        {? _tab=PX_CUP
                        || _msg+='Nie znaleziono pojemnika o czasie: %1 na zasobie: %2'@[exec('to_string','#tm_stamp',_start),PX_KONT.SYMBOL]
                        |? _tab=PX_CAL
                        || _msg+='Nie znaleziono wolnego zapisu kalendarza o czasie: %1 na zasobie: %2'@[exec('to_string','#tm_stamp',_start),PX_KONT.SYMBOL]
                        ?};
                        KOMM.error(_msg,0,1)
                     ?}
                  ?}
               || _can_continue:=0;
                  _msg:='Nie powiodło się zaplanowanie remontu. ';
                  _msg+='Nie znaleziono aktywnego zasobu: %1'@[PX_KONT.SYMBOL+' '+PX_KONT.NAZWA];
                  KOMM.error(_msg,0,1)
               ?}
            ?}
         ?}
      ?}
   ?};

   {? _can_continue>0
   ||
::    Oznaczam wersje do przeliczenia
      _can_continue:=exec('mod_stamp_queue','px_ver',_px_ver)
   ?};
   {? _can_continue>0
   ||
::    Stempluję zgłoszenie
      REM_ZGL.PLAN_PX:='T';
      _can_continue:=REM_ZGL.put()
   ?};
   {? _can_continue>0
   || _result:=1
   ?}
?};
PX_KONT.cntx_pop();
REM_PLAN.cntx_pop();
REM_ZGL.cntx_pop();
REM_ZGL.get();
PX_VER.cntx_pop();

_result


\plan_view
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Tworzy i wyświetla okno pokazujące jak wyglądają plany produkcji zgłoszenia remontowego
::   WE: [_a] - REM_ZGL.ref - zgłoszenie remontowe lub bieżący rekord
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_OBJ.cntx_psh();
REM_ZGL.cntx_psh();
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_VAR.VIE_VER:=exec('get_mainversion','px_ver');
   _env:=obj_new('WIN_PX'
                 ,'WIN_PL'
                 ,'TAB_PL');
   params_set('env',_env);

   _env.WIN_PX:='WER_REM';
   _tab:=tab_tmp(3
      ,'RES_SYM','STRING[100]','Nazwa pola 1'
      ,'RES_NAZ','STRING[100]','Nazwa pola 1'
      ,'OPER_SYM','STRING[100]','Nazwa pola 2'
      ,'OPER_OP','STRING[100]','Nazwa pola 2'
      ,'PL_START','STRING[20]','Nazwa pola 2'
      ,'PL_END','STRING[20]','Nazwa pola 2'
   );
   _env.TAB_PL:=_tab;

   exec('fill_tab_pl','remonty_plan',_tab);
   _tab.first();

   _title:='Pozycje planu operacyjnego dla: %1'@[exec('REM_ZGL','#to_string')];
   _wer:=_tab.mk_sel(_title,'P',0,'#rem_plan_pl',1,1,,,'U');

   _tab.win_fld(_wer,,'RES_SYM',,,20,,,'Symbol zasobu'@);
   _tab.win_fld(_wer,,'RES_NAZ',,,20,,,'Nazwa zasobu'@);
   _tab.win_fld(_wer,,'OPER_SYM',,,40,,,'Symbol operacji'@);
   _tab.win_fld(_wer,,'OPER_OP',,,40,,,'Opis operacji'@);
   _tab.win_fld(_wer,,'PL_START',,,20,,,'Od'@);
   _tab.win_fld(_wer,,'PL_END',,,20,,,'Do'@);

   _formula:="
      params_set(params_get());
      _env:=params_get().env;
      exec('delete_plan_pl','remonty_plan');
      _env.TAB_PL.erase();
      exec('fill_tab_pl','remonty_plan',_env.TAB_PL);
      ~~
   ";
   _tab.win_act(_wer,0,'Formuła','&Usuń plan'@@,,,_formula,,,,,,'U');
   task_attach('TRE_ZGL_AWZG');
   _tab.win_btn(_wer,'text=%1,panel=bottom,align=begin'['&Usuń plan'@],'menu:U');

   _env.WIN_PL:=_wer;

   _grpbefor:="
         params_set(params_get());
         _env:=params_get().env;

         grp_disp(PX_POZ,_env.WIN_PX);
         grp_disp(_env.TAB_PL,_env.WIN_PL);
         ~~
      ";
   _grp:=_tab.grp_make('Plan zgłoszenia',_grpbefor,'#rem_plan_zgl',1,1);


   _before:="
      params_set(params_get());
      _env:=params_get().env;

      _result:='';
      _px_obj:=exec('get_rem_object','px_obj',REM_ZGL.ref());

      _mainver:=exec('get_mainversion','px_ver');
      {? _px_obj<>null()
      || PX_OBJ.prefix();
         PX_CUP.blank(1);
         {? PX_OBJ.seek(_px_obj,)
         || _il_wym:=exec('il_wym','px_param');
            PX_POZ.index('TM_VOBJ');
            PX_POZ.prefix(_mainver,_px_obj);
            PX_POZ.first()
         || _result:='#disable'
         ?}

      || _result:='#disable'
      ?};
      _result
   ";
:: Okno planu strategicznego
   _tab.grp_sel(_grp,PX_POZ,_env.WIN_PX,,,,,10,_before,,,,'maximized_with_title');

   _tab.grp_splt(_grp,,'horizontal','dolny');

   _before:="
      params_set(params_get());
      _env:=params_get().env;
      ~~
   ";
   PX_POZ.win_sel('WER_REM');
   PX_POZ.hdr_sel('');
   _title:='Pozycje planu strategicznego dla: %1'@[exec('REM_ZGL','#to_string')];
   PX_POZ.hdr_sel(_title);

:: Okno planu operacyjnego
   _tab.grp_sel(_grp,_env.TAB_PL,_env.WIN_PL,,,,,,_before,,,,'maximized_with_title');

   _tab.win_sel(_grp);
   _tab.select();
   ~~

?};
REM_ZGL.cntx_pop();
PX_OBJ.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\fill_tab_pl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Wypełnia tabelkę tymczasową prezentującą plan operacyjny
::   WE: _a - tab_tmp - tabelka do zasilenia
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

PL_OPER.index('REM_PLAN');
PL_OZ.cntx_psh();
PL_OZ.index('PL_OPER');
PL_OPER.cntx_psh();

REM_PLAN.cntx_psh();
REM_PLAN.index('REM_ZGL');
REM_PLAN.prefix(REM_ZGL.ref());
{? REM_PLAN.first()
|| {!
   |?
      PL_OPER.prefix(REM_PLAN.ref());
      {? PL_OPER.first()
      || {!
         |? PL_OZ.prefix(PL_OPER.ref());
            {? PL_OZ.first()
            || {!
               |? _tab.blank();
                  _tab.RES_SYM:=PL_OZ.PL_RES().SYM;
                  _tab.RES_NAZ:=PL_RES.NAZ;
                  _tab.OPER_SYM:=PL_OPER.SYMBOL;
                  _tab.OPER_OP:=PL_OPER.OPIS;
                  _tab.PL_START:=19+tm_form(PL_OPER.TM_START);
                  {? REM_ZGL.TM_END=0 & REM_ZGL.PL_DOST='C'
                  || _tab.PL_END:='bezterminowy'@
                  || _tab.PL_END:=19+tm_form(PL_OPER.TM_END)
                  ?};
                  _tab.add();
                  PL_OZ.next()
               !}
            ?};
            PL_OPER.next()
         !}
      ?};
      REM_PLAN.next()
   !}
?};
REM_PLAN.cntx_pop();
PL_OPER.cntx_pop();
PL_OZ.cntx_pop();
~~


\delete_plan_px
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Usuwa plan stretegiczny danego zgłoszenia remontowego
::   WE: [_a] - REM_ZGL.ref - zgłoszenie remontowe lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

REM_ZGL.cntx_psh();
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _can_continue:=FUN.ask('Usunąć z planu strategicznego zgłoszenie: %1?'@[exec('REM_ZGL','#to_string')])
?};

{? REM_ZGL.PLAN_PL='T'
|| FUN.emsg('Zgłoszenie jest zaplanowane operacyjnie. Najpierw należy usunąć plan operacyjny.'@);
   _can_continue:=0
?};

{? _can_continue>0
||
   _px_obj:=exec('get_rem_object','px_obj',REM_ZGL.ref());
   {? _px_obj<>null()
   || _mainver:=exec('get_mainversion','px_ver');
      _can_continue:=exec('rem_clear','px_poz',REM_ZGL.ref(),_mainver)
   ?};
   ~~
?};
REM_ZGL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\delete_plan_pl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Usuwa plan operacyjny danego zgłoszenia remontowego
::   WE: [_a] - REM_ZGL.ref - zgłoszenie remontowe lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

REM_ZGL.cntx_psh();
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _can_continue:=FUN.ask('Usunąć z planu operacyjnego zgłoszenie: %1?'@[exec('REM_ZGL','#to_string')])
?};

{? _can_continue>0
|| _can_continue:=exec('rem_clear','po_plan',REM_ZGL.ref());
   ~~
?};
REM_ZGL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\plan_pl_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Aktualizuje stan zaplanowania operacyjnego na podstawie istenijących PL_OPERów
::   WE: [_a] - REM_ZGL.ref - zgłoszenie remontowe lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

REM_ZGL.cntx_psh();
REM_PLAN.cntx_psh();
REM_PLAN.index('REM_ZGL');
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};


{? _can_continue>0
||
   REM_ZGL.PLAN_PL:='N';
   _can_continue:=REM_ZGL.put()
?};
{? _can_continue>0
||
   REM_PLAN.prefix(REM_ZGL.ref());
   {? REM_PLAN.first()
   || {!
      |? REM_PLAN.PLAN_PL:='N';
         _can_continue:=REM_PLAN.put();
         REM_PLAN.next() & _can_continue>0
      !}
   ?}
?};

{? _can_continue>0
||
   PL_OPER.cntx_psh();
   PL_OPER.index('REM_PLAN');
   REM_PLAN.prefix(REM_ZGL.ref());
   {? REM_PLAN.first()
   || {!
      |? PL_OPER.prefix(REM_PLAN.ref());
         {? PL_OPER.first()
         || REM_ZGL.PLAN_PL:='T';
            _can_continue:=REM_ZGL.put();
            {? _can_continue>0
            || REM_PLAN.PLAN_PL:='T';
               _can_continue:=REM_PLAN.put()
            ?}
         ?};
         REM_PLAN.next() & _can_continue>0
      !}
   ?};
   PL_OPER.cntx_pop();
   ~~
?};
REM_ZGL.cntx_pop();
REM_PLAN.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\plan_px_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Aktualizuje stan zaplanowania strategicznego na podstawie istenijących PX_POZów
::   WE: [_a] - REM_ZGL.ref - zgłoszenie remontowe lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

REM_ZGL.cntx_psh();
REM_PLAN.cntx_psh();
REM_PLAN.index('REM_ZGL');
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};


{? _can_continue>0
||
   REM_ZGL.PLAN_PX:='N';
   _can_continue:=REM_ZGL.put()
?};
{? _can_continue>0
||
   REM_PLAN.prefix(REM_ZGL.ref());
   {? REM_PLAN.first()
   || {!
      |? REM_PLAN.PLAN_PX:='N';
         _can_continue:=REM_PLAN.put();
         REM_PLAN.next() & _can_continue>0
      !}
   ?}
?};

{? _can_continue>0
||
   PX_POZ.cntx_psh();
   PX_POZ.index('PX_KONT2');
   {? REM_PLAN.first()
   || {!
      |? _px_kont:=exec('rem_zas_px','zasoby',REM_PLAN.REM_ZAS);
         _px_obj:=exec('get_rem_object','px_obj',REM_PLAN.REM_ZGL);
         PX_POZ.prefix(_px_kont,_px_obj);
         {? PX_POZ.first()
         || REM_ZGL.PLAN_PX:='T';
            _can_continue:=REM_ZGL.put();
            {? _can_continue>0
            || REM_PLAN.PLAN_PX:='T';
               _can_continue:=REM_PLAN.put()
            ?}
         ?};
         REM_PLAN.next() & _can_continue>0
      !}
   ?};
   PX_POZ.cntx_pop();
   ~~
?};
REM_ZGL.cntx_pop();
REM_PLAN.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\replan_px
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Odświeżenie planu strategicznego zgłoszenia remontowego
::   WE: [_a] - REM_ZGL.ref - zgłoszenie lub bieżący rekord
::       [_b] - INTEGER - [0]/1 - czy inicjować i wyświetlać KOMMa
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};
_komm_init:=0;
{? var_pres('_b')=type_of(0)
|| _komm_init:=_b
?};

_result:=0;
_can_continue:=1;

{? _komm_init>0
|| KOMM.init(250,,'Planowanie zgłoszenia remontowego'@)
?};

REM_ZGL.cntx_psh();
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _can_continue:=exec('generator_start','remonty_plan',,0,0,1,0)
?};
REM_ZGL.cntx_pop();

{? _komm_init>0
|| KOMM.select()
?};

{? _can_continue>0
|| _result:=1
?};
_result


\replan_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Odświeża plan wszystkich remontów w planie
::   WE: [_a] - INTEGER - 0/[1] - czy wyświetlać dialogi
::       [_b] - INTEGER - 0/[1] - czy inicjować i wyświetlać KOMMa
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};
_komm_init:=1;
{? var_pres('_b')=type_of(0)
|| _komm_init:=_b
?};

_result:=1;
_can_continue:=1;

_st1:=exec('status_verified','remonty_zgloszenia');
_st2:=exec('status_completed','remonty_zgloszenia');

{? _dialog>0
|| _msg:='Usunąć z planu operacyjnego i strategicznego wszystkie zgłoszenia remontowe o statusach: %1 i %2?\n\n'
         'Zgłoszenie remontowe w planie operacyjnym zostaną ponownie zaplanowane przy wejściu do planu.\n'
         'Zgłoszenia remontowe w planie strategicznym zostaną automatycznie przeplanowane teraz.'@[_st1,_st2];
   _can_continue:=FUN.ask(_msg)
?};

_msg:='Planowanie zgłoszeń remontowych'@;
{? _komm_init>0
|| KOMM.init(250,,_msg)
?};

{? _dialog>0
|| progress(,_msg+'…',exec('nazwa','#system'),1)
?};

{? _can_continue>0
||
   REM_PLAN.cntx_psh();
   REM_PLAN.index('REM_ZGL');
   REM_ZGL.cntx_psh();
   REM_ZGL.index('STAT_REJ');
   REM_ZGL.prefix(_st1);
   {? REM_ZGL.first()
   || {!
      |? {? exec('generator_start','remonty_plan',,0,1)=0
         || _result:=0
         ?};
         REM_ZGL.next()
      !}
   ?};
   REM_ZGL.prefix(_st2);
   {? REM_ZGL.first()
   || {!
      |? {? exec('generator_start','remonty_plan',,0,1)=0
         || _result:=0
         ?};
         REM_ZGL.next()
      !}
   ?};
   REM_ZGL.cntx_pop();
   REM_PLAN.cntx_pop()
?};

{? _dialog>0
|| prgs_clr()
?};

{? _komm_init>0
|| KOMM.select()
?};

_result


\status_planned
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Zwraca listę statusów zgłoszeń, które powinny być obsługiwane w planie.
::       Separatorem jest znak ','
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=exec('status_verified','remonty_zgloszenia')+',';
_result+=exec('status_completed','remonty_zgloszenia');
_result


\rem_plan_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Usuwa rekord REM_PLAN
::   WE: _a - REM_PLAN.ref lub bieżący rekord
::       _b - TREE.ref - rekord nadrzędny w drzewie
::   WY:  0 - porażka
::        1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=0;
_can_continue:=1;

:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;
{? _mydo || do() ?};


REM_PLAN.cntx_psh(); REM_PLAN.clear();
{? REM_PLAN.seek(_ref)
||
:: Usuwam najpierw wszystkie moje liście w drzewie
   REM_PLAN.cntx_psh();
   REM_PLAN.index('TREE');
   REM_PLAN.prefix(REM_PLAN.REM_ZGL,_ref);
   {? REM_PLAN.first()
   || {!
      |?
::       !!! REKURENCJA !!!
         _can_continue:=exec('rem_plan_delete','remonty_plan',REM_PLAN.ref());
         REM_PLAN.first() & _can_continue>0
      !}
   ?};
   REM_PLAN.cntx_pop();

   {? _can_continue>0 & exec('rem_plan_clean','remonty_plan',_ref)>0
   || {? REM_PLAN.del(,1)>0
      || _can_continue:=1
      || undo();
         _can_continue:=0
      ?}
   || _can_continue:=0
   ?}
|| _can_continue:=0
?};

{? _can_continue=0
|| undo()
?};
{? _can_continue>0
|| _result:=1
?};

REM_PLAN.cntx_pop();
{? _mydo || end() ?};
_result


\rem_plan_clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Czyści powiązania do rekordu tabeli REM_PLAN
::   WE: _a - REM_PLAN.ref()
::   WY: >0  -wyczyszczone,
::       <=0 -niewyczyszczone
::  TAG: <PRYWATNA><CLEAN>
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=0;
_can_continue:=1;

_mydo:=do_state()=0;
{? _mydo || do() ?};
:: --- powiązania do ---
PL_OPER.cntx_psh();
PL_OPER.index('REM_PLAN');
PL_OPER.prefix(_ref);
{? PL_OPER.first()
|| {!
   |? _can_continue:=exec('del_ploper','po_plan',$PL_OPER.ref(),,,,0);
      PL_OPER.first() & _can_continue>0
   !}
?};
PL_OPER.cntx_pop();

:: --- wszystkie powiazania usuniete? ---

{? _can_continue>0
|| _result:=1
|| undo()
?};

{? _mydo || end() ?};
_result


\rem_plan_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Akcja wyświetl w oknie wertowania REM_PLAN
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
REM_PLAN.win_edit('RED');
REM_PLAN.hdr_edit('Dostępność zasobu: %1'@[exec('record','#to_string',REM_PLAN.REM_ZAS)]);
REM_PLAN.display();
~~


\plan_clear
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Usuwa zgłoszenie z obu planów
::   WE: [_a] - REM_ZGL.ref()
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

REM_ZGL.cntx_psh();
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _px_obj:=exec('get_rem_object','px_obj',REM_ZGL.ref());
   {? _px_obj<>null()
   || _can_continue:=exec('rem_clear','px_poz',REM_ZGL.ref());
      {? _can_continue=0
      || _msg:='Nie udało się usunąć zgłoszenia: %1 z planu strategicznego.'@[exec('REM_ZGL','#to_string')];
         FUN.emsg(_msg)
      ?}
   ?}

?};

{? _can_continue>0
|| _can_continue:=exec('rem_clear','po_plan',REM_ZGL.ref());
   {? _can_continue=0
   || _msg:='Nie udało się usunąć zgłoszenia: %1 z planu operacyjnego.'@[exec('REM_ZGL','#to_string')];
      FUN.emsg(_msg)
   ?}
?};
REM_ZGL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\rem_plan_kalendarz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Akcja 'Kalendarz' w okienku wertowania REM_PLAN
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_owner:=~~;
exec('__KAL','object');
TWRKPLC.cntx_psh();
TWRKZBR.cntx_psh();
REM_ZAS.cntx_psh();

{? REM_PLAN.REM_ZAS<>null()
||
   {? REM_PLAN.REM_ZAS().TWRKPLC<>null()
   || REM_PLAN.REM_ZAS().TWRKPLC();
      _owner:=TWRKPLC
   |? REM_PLAN.REM_ZAS().TWRKZBR<>null()
   || REM_PLAN.REM_ZAS().TWRKZBR();
      _owner:=TWRKZBR
   ?}
?};
{? type_of(_owner)>0
|| exec('start','kal_mies',_owner,'01')
|| FUN.emsg('Zasób nie ma kalendarza.'@)
?};
REM_ZAS.cntx_pop();
TWRKPLC.cntx_pop();
TWRKZBR.cntx_pop();
''

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:35 e131ad648a69e816e43dbf793be298a9c31af21a362781cdc878f4c8d5d1b822f1c3b2ebd119c729affe128a2d30d0fd440a9a717279517e40091c51a08a2d25f627dd8be23bdf90d92d66f3e6c06ab8f29176be920e6acfa9b75b293f80aab661a0eed44704dd83baaa5b126815705d88718ee30aa89bae296dfdd4e8c41758
