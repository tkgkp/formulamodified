:!UTF-8
::(c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: px_whisk.fml [12.10]
:: Utworzony: 2011/09/05
:: Autor: jerry
::======================================================================================================================
:: Zawartosc: Formuly dla 'trzepaczki'
::======================================================================================================================


\pck_params
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Zwraca tablice nazwana z parametrami dla formul generujacych paczki
::   WY: tablica nazwana parametrow pck_*
::----------------------------------------------------------------------------------------------------------------------
_eggs:=obj_new(   'Formula',
                  'Quantity',
                  'Qcoef',
                  'PxPack',
                  'Directio',
                  'TKTL',
                  'PX_TEX',
                  'PX_OBJ',
                  'PX_GRP',
                  'PX_STAGE',
                  'PxOPER',
                  'PxMAT',
                  'PL_FORCE',
                  'GROPS');
:: --- wartosci domyslne
::  formula do wykonania
_eggs.Formula:='';
::  ilosc
_eggs.Quantity:=0;
::  wspolczynnik dla zuzycia w przepisie
_eggs.Qcoef:=1;
::  paczka planistyczna - material dla algorytmu planistycznego
_eggs.PxPack:=~~;
::  kierunek planowania
_eggs.Directio:=-1;
::  wskazanie na technologie, w ktorej znajduje sie definicja przepisu
_eggs.TKTL:=null();
::  wskazanie na przepis
_eggs.PX_TEX:=null();
::  wskazanie na obiekt planistyczny
_eggs.PX_OBJ:=null();
::  wskazanie na grupe planistyczna
_eggs.PX_GRP:=null();
::  wskazanie na etap planistyczny
_eggs.PX_STAGE:=null();
::  czy obrabiane sa zasoby
_eggs.PxOPER:=1;
::  czy obrabiane sa materialy
_eggs.PxMAT:=1;
:: czy mozliwe jest planowanie poza termin realizacji obiektu
_eggs.PL_FORCE:='N';
:: grupa operacji
_eggs.GROPS:=null();
:: ------------------------
_eggs


\pck_px_tex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Generowanie zawartosci paczki na podstawie podanego przepisu
::   WE: _eggs - wynik formuly exec('pck_params','px_whisk')
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_eggs:=_a;
PX_STAGE.cntx_psh();
PX_STAGE.clear();
PX_STAGE.index('TEX_NR');
PX_STAGE.prefix(_eggs.PX_TEX);
{? PX_STAGE.first()
|| {? PX_STAGE.PX_TEX().XJM=0
   || _eggs.Qcoef:=0
   || _eggs.Qcoef:=_eggs.Quantity/PX_STAGE.PX_TEX().XJM
   ?};
   _eggs.Directio:=exec('FindAndGet','#table',PX_GRP,_eggs.PX_GRP,,"DIR",-1);
   exec('Stages2PxPack','px_whisk',_eggs)
?};
PX_STAGE.cntx_pop();
~~


\pck_technology
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Generowanie zawartosci paczki na podstawie podanej technologii
::   WE: _eggs - wynik formuly exec('pck_params','px_whisk')
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_eggs:=_a;
PX_STAGE.cntx_psh();
PX_STAGE.clear();
PX_STAGE.index('TKTL_NR');
PX_STAGE.prefix($_eggs.TKTL);
{? {? _eggs.PX_STAGE<>null() || PX_STAGE.seek(_eggs.PX_STAGE) || PX_STAGE.first() ?}
|| _xjm:=exec('FindAndGet','#table',TKTL,PX_STAGE.RTKTL,,"XJM",1);
   _eggs.Qcoef:={? _xjm=0 || 0 || _eggs.Quantity/_xjm ?};
   _eggs.Directio:=exec('FindAndGet','#table',PX_GRP,_eggs.PX_GRP,,"DIR",-1);
   exec('Stages2PxPack','px_whisk',_eggs)
?};
PX_STAGE.cntx_pop();
~~


\pck_autopx
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Generowanie zawartosci paczki na podstawie podanego przepisu automatycznego
::   WE: _eggs - wynik formuly exec('pck_params','px_whisk')
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_eggs:=_a;
PX_STAGE.cntx_psh();
PX_STAGE.clear();
PX_STAGE.index('TEX_NR');
PX_STAGE.prefix(_eggs.PX_TEX);
{? PX_STAGE.first()
|| _eggs.Qcoef:=_eggs.Quantity;
   _eggs.Directio:=exec('FindAndGet','#table',PX_GRP,_eggs.PX_GRP,,"DIR",-1);
   exec('Stages2PxPack','px_whisk',_eggs)
?};
PX_STAGE.cntx_pop();
~~


\pck_delays
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Tworzy paczke technologiczna na podstawie opoznien obiektu grupujacego
::   WE: _a - PxPack - paczka obudowana - exec('PxPack_declare','px_tex')
::       _b - PX_GRP.ref() - zrodlowy obiekt grupujacy z opoznionymi pozycjami planu
::       _c - PX_GRP.ref() - docelowy obiekt grupujacy z ktorym maja zostac powiazane nowe pozycje planu
::   WY: tab_tmp() - paczka technologiczna
::----------------------------------------------------------------------------------------------------------------------
_pxpack:=_a;
_grp_src:=_b;
_grp_dst:=_c;
_paczka:=_pxpack.Paczka;

PX_GRP.cntx_psh();
PX_POZ.cntx_psh();
_paczka.cntx_psh();

_ndx_stage:=_paczka.ndx_tmp(,1,'PX_STAGE',,,'PX_OBJ',,,'REF_KONT',,);
_paczka.index(_ndx_stage);


PX_GRP.clear();
{? PX_GRP.seek(_grp_dst)
||
   _packS:=_pxpack.add_a();
   _packO:=_pxpack.add_a();
   PX_POZ.index('STATUS3');
   PX_POZ.prefix(_grp_src,exec('status_delay','px_poz'));

   {? PX_POZ.first()
   || {!
      |?
         _parent:=0;
         _il_wym:=PX_POZ.PX_KONT().IL_WYM;
::       sprawdzam czy paczka ma juz taki PX_STAGE, jesli nie to zakladam
         _paczka.prefix($PX_POZ.PX_STAGE,$PX_POZ.PX_OBJ);
         {? _paczka.first()=0
         ||
            _pxpack.blank(_packS);
            _packS.PARENT:=0;
            _packS.SYMBOL:='Etap '+form(PX_POZ.PX_STAGE().NR,-2);
            _packS.NUM:=PX_POZ.PX_STAGE().NR;
            _packS.NUM_STAG:=PX_STAGE.NR;
            _packS.NAZWA:=PX_POZ.PX_STAGE().NAZWA;
            _packS.BRANCH:='T';
            _packS.TYP:='O';
            _packS.LEVEL:=0;
            _packS.ILOSC:=PX_GRP.ILOSC;
            {? PX_POZ.KOOP='T'
            || _packS.WEW:='N'
            || _packS.WEW:='T'
            ?};
            {? PX_VAR.NAST_ALG=2 & PX_POZ.KOOP='T'
            ||
::             Jeżeli kooperacja to pozycja planu zajmuje dla siebie poziom
::             kalendarza unikalny w ramach całej kolejki
               _packS.LANE:=PX_GRP.COOP_LP
            ?};

::          UWAGA!!! Opoznienia planujemy zawsze do przodu
            _packS.DIR:=1;
            _packS.PX_STAGE:=$PX_POZ.PX_STAGE;
            _packS.PX_STAGM:=PX_POZ.PX_STAGE().name();
            _packS.PX_STAGR:=#PX_POZ.PX_STAGE;
            _packS.ALIGNMEN:=PX_POZ.PX_STAGE().ALIGNMEN;

            _packS.PX_OBJ:=$PX_POZ.PX_OBJ;

            _parent:=_pxpack.add(_packS)
         || _parent:=_paczka.ref()
         ?};
::       sprawdzam czy paczka ma juz taki PX_KONT w PX_STAGE, jesli nie to zakladam
         _paczka.prefix($PX_POZ.PX_STAGE,$PX_POZ.PX_OBJ,$PX_POZ.PX_KONT);
         {? _paczka.first()=0
         ||
::          TWORZE NOWY REKORD PACZKI - Operacja na kontenerze

            _pxpack.blank(_packO);
            _packO.PARENT:=#_parent;
            _packO.SYMBOL:='('+PX_POZ.PX_KONT().SYMBOL+') '+PX_POZ.PX_KONT().NAZWA;
            _packO.BRANCH:='N';
            _packO.TYP:='K';
            _packO.LEVEL:=1;
            _packO.ILOSC:=PX_GRP.ILOSC;
            _packO.NUM:=_packS.NUM;
            _packO.NUM_STAG:=_packS.NUM_STAG;

            {? PX_POZ.KOOP='T'
            || _packO.WEW:='N'
            || _packO.WEW:='T'
            ?};
            {? PX_VAR.NAST_ALG=2 & PX_POZ.KOOP='T'
            ||
::             Jeżeli kooperacja to pozycja planu zajmuje dla siebie poziom
::             kalendarza unikalny w ramach całej kolejki
               _packO.LANE:=PX_GRP.COOP_LP
            ?};

            _packO.NAKL_PRC:=PX_POZ.PX_STAGE().NAKL_PRC;

::          UWAGA!!! Opoznienia planujemy zawsze do przodu
            _packO.DIR:=1;
::          rekordom paczki 'opoznieniowej' nadaje status opozniony
            _packO.STATUS:=exec('status_pck_dlay','px_tex');

            _packO.PX_STAGE:=$PX_POZ.PX_STAGE;
            _packO.PX_STAGM:=PX_POZ.PX_STAGE().name();
            _packO.PX_STAGR:=#PX_POZ.PX_STAGE;

            _packO.REF_KONT:=$PX_POZ.PX_KONT;
            _packO.REF_KONM:=ref_name(PX_OPER.PX_KONT);
            _packO.REF_KONR:=#PX_POZ.PX_KONT;

            {! _it:=1.._il_wym
            |! _rule:=$('  _packO:=_a;
                           _packO.CAP_DIM'+$_it+':=PX_POZ.CAP_EAT'+$_it+'-PX_POZ.CAP_WYK'+$_it+';
                           _packO.CAP_MIN'+$_it+':=PX_POZ.CAP_MIN'+$_it+';
                           _packO.CAP_MAX'+$_it+':=PX_POZ.CAP_MAX'+$_it+';
                           ~~
                        ');
               _rule(_packO)
            !};
            _packO.PX_OBJ:=$PX_POZ.PX_OBJ;

            _pxpack.add(_packO)
         ||
::          DOPISUJE ILOŚCI
            {! _it:=1.._il_wym
            |! _rule:=$('_paczka:=_a;_paczka.CAP_DIM'+$_it+'+=PX_POZ.CAP_EAT'+$_it+'-PX_POZ.CAP_WYK'+$_it+'');
               _rule(_paczka)
            !};
            _paczka.put()
         ?};
         PX_POZ.next()
      !}
   ?}
?};
PX_POZ.cntx_pop();
PX_GRP.cntx_pop();
_paczka.cntx_pop();
_paczka


\Stages2PxPack
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Generuje paczke na podstawie aktualnej dziedziny PX_STAGE
::   WE: _eggs - wynik formuly exec('pck_params','px_whisk')
::   WY: ~~
::UWAGA: PRACA NA AKTUALNYM KONTEKSCIE PX_STAGE - Przed wywolaniem musi zostac wykonane PX_STAGE.first()!!!
::       albo PX_STAGE.seek(_eggs.PX_STAGE) - WTEDY PRZETWARZANY TYLKO TEN JEDEN ETAP!
::----------------------------------------------------------------------------------------------------------------------
_eggs:=_a;

PX_OPER.cntx_psh();
PX_OPER.clear();
PX_OPER.index('UNIQALL');
PX_KONT.cntx_psh();

{? var_pres('PxTabPar')<100 || exec('PxTabPar','px_init') ?};
_packp:=_eggs.PxPack.tabpar;
_packS:=_eggs.PxPack.add_a();
_packB:=_eggs.PxPack.add_a();
_packO:=_eggs.PxPack.add_a();
_packM:=_eggs.PxPack.add_a();
_packN:=_eggs.PxPack.add_a();
_packP:=_eggs.PxPack.add_a();

_stage:=exec('stage','px_nast');
exec('start_xpar','tech_param',_eggs.PX_TEX);
{!
|?
   _planned:='N';
   _grop_member:='N';
   _packS.PARENT:=0;
   _packS.REASON:=exec('reason_plan','px_param');
   _size:=PX_STAGE.size();
   _form_dokl:=+($_size);
   _form_dokl:=-1*_form_dokl;

   _packS.SYMBOL:='Etap '+form(PX_STAGE.NR,_form_dokl);

   _packS.NAZWA:=PX_STAGE.NAZWA;
   _packS.BRANCH:='T';
   _packS.TYP:='O';
   _packS.LEVEL:=0;
   _packS.ILOSC:=_eggs.Quantity;
   _packS.NUM:=PX_STAGE.NR;
   _packS.NUM_STAG:=PX_STAGE.NR;
   _packS.DIR:=_eggs.Directio;
   _packS.PX_STAGE:=$PX_STAGE.ref();
   _packS.PX_STAGM:=PX_STAGE.name();
   _packS.PX_STAGR:=#PX_STAGE.ref();
   _packS.ALIGNMEN:=PX_STAGE.ALIGNMEN;
   _wew:=exec('is_wew','px_stage',PX_STAGE.ref());
   _packS.WEW:=_wew;
   _packS.PL_FORCE:=_eggs.PL_FORCE;
   {? PX_VAR.NAST_ALG=2 & _wew='N'
   ||
::    Jeżeli kooperacja to operacja zajmuje dla siebie poziom
::    kalendarza unikalny w ramach całej kolejki na każdym zasobie
::    kooperacyjnym
      _packS.LANE:=exec('FindAndGet','#table',PX_GRP,_eggs.PX_GRP,,"COOP_LP",-1)
   || _packS.LANE:=-1
   ?};

   _tm_min:=0;
   _tm_max:=0;
   {? _eggs.PX_GRP<>null()
   ||
::    Obsługa operacji grupowych
      PX_GRP.cntx_psh(); PX_GRP.prefix();
      {? PX_GRP.seek(_eggs.PX_GRP)
      || {? PX_VAR.PL_GROP>0 & exec('is_grop_member','px_grop',_eggs.PX_GRP)>0
         ||
            {? exec('stage_planned_in_grop','px_grop',,PX_GRP.PX_VER)
            || _planned:='T';
               _grop_member:='T'
            ||
               {? _eggs.Directio>0
               || _tm_min:=exec('get_time_zl','px_grop',_eggs.PX_GRP,PX_STAGE.ref())
               || _tm_max:=exec('get_time_zl','px_grop',_eggs.PX_GRP,PX_STAGE.ref())
               ?};
               {? _tm_min>0 | _tm_max>0
               || _eggs.PxPack.HASPOINT:=1;
                  _packS.REASON:=exec('reason_grop','px_param')
               ?}
            ?}
         ?}
      ?};
      PX_GRP.cntx_pop();

      {? _tm_min=0 & _tm_max=0
      ||
::       Sprawdzam czy dany etap dla danej grupy ma punkty czasowe
         PX_POINT.cntx_psh();
         PX_POINT.index('PX_GRP');
         PX_POINT.prefix(_eggs.PX_GRP,PX_STAGE.ref());
         {? PX_POINT.first()
         || _eggs.PxPack.HASPOINT:=1;
            _tm_min:=PX_POINT.TM_MIN;
            _tm_max:=PX_POINT.TM_MAX;
            _packS.REASON:=exec('reason_point','px_param')
         ?};
         PX_POINT.cntx_pop()
      ?};
      ~~
   ?};
   _packS.PLANNED:=_planned;
   _packS.GROPED:=_grop_member;
   _packS.TM_MIN:=_tm_min;
   _packS.TM_MAX:=_tm_max;

   _parentS:=_eggs.PxPack.add(_packS);

   {? _parentS<>null()
   ||
::    Galaz zasobow etaptu
      {? _eggs.PxOPER
      ||
         _packB.PARENT:=#_parentS;
         _packB.SYMBOL:='Zasoby';
         _packB.NAZWA:='Zasoby etapu '+form(PX_STAGE.NR,_form_dokl);
         _packB.BRANCH:='T';
         _packB.TYP:='B';
         _packB.LEVEL:=1;
         _packB.PL_FORCE:=_eggs.PL_FORCE;
         _packB.NUM_STAG:=PX_STAGE.NR;

         _packB.ILOSC:=_eggs.Quantity;

         _packB.PX_STAGE:=$PX_STAGE.ref();
         _packB.PX_STAGM:=PX_STAGE.name();
         _packB.PX_STAGR:=#PX_STAGE.ref();

         _parentB:=_eggs.PxPack.add(_packB);

         {? _parentB<>null()
         ||
::          Operacje dla etapu
            PX_OPER.prefix(PX_STAGE.ref());
            {? PX_OPER.first()
            || {!
               |?
                  _packO.PARENT:=#_parentB;
                  _packO.SYMBOL:='('+PX_OPER.PX_KONT().SYMBOL+') '+PX_OPER.PX_KONT().NAZWA;
                  _packO.NAZWA:=PX_OPER.COMMENT;
                  _packO.BRANCH:='N';
                  _packO.TYP:='K';
                  _packO.LEVEL:=2;
                  _packO.ILOSC:=_eggs.Quantity;
                  _packO.NUM:=_packS.NUM;
                  _packO.NUM_STAG:=_packS.NUM_STAG;

                  _packO.DIR:=_eggs.Directio;
                  _packO.PX_STAGE:=$PX_STAGE.ref();
                  _packO.PX_STAGM:=PX_STAGE.name();
                  _packO.PX_STAGR:=#PX_STAGE.ref();

                  _packO.PLANNED:=_planned;
                  _packO.GROPED:=_grop_member;
                  _packO.TM_MIN:=_tm_min;
                  _packO.TM_MAX:=_tm_max;
                  _packO.REASON:=_packS.REASON;

                  _coop:=exec('coop_zgp','px_stage',PX_STAGE.ref());
                  _grop_pr:=exec('planned_grop_pr','px_stage',PX_STAGE.ref());

                  _packO.WEW:=_wew;
                  {? PX_VAR.NAST_ALG=2 & _wew='N'
                  ||
::                   Jeżeli kooperacja to operacja zajmuje dla siebie poziom
::                   kalendarza unikalny w ramach całej kolejki na każdym zasobie
::                   kooperacyjnym
                     _packO.LANE:=exec('FindAndGet','#table',PX_GRP,_eggs.PX_GRP,,"COOP_LP",-1)
                  || _packO.LANE:=-1
                  ?};

                  _packO.PL_FORCE:=_eggs.PL_FORCE;

                  _coop_start:=0;
                  _coop_end:=0;
                  _coop_akc:=exec('coop_zgp_akc','px_stage',PX_STAGE.ref());
                  {? _coop>0
                  ||
::                   specjalna obsluga kooperacji na zleceniu ktore ma przewodniki
                     _coop_start:=exec('coop_zgp_start','px_stage',PX_STAGE.ref());
                     _coop_end:=exec('coop_zgp_end','px_stage',PX_STAGE.ref());
                     {? _coop_start>0 & _coop_end>0 & _coop_akc>0
                     || _packO.COOP:=1;
                        _packO.TM_START:=_coop_start;
                        _packO.TM_END:=_coop_end;
                        _packO.STARTD:=exec('tm_stamp2date','#tm_stamp',_coop_start);
                        _packO.STARTT:=exec('tm_stamp2time','#tm_stamp',_coop_start);
                        _packO.ENDD:=exec('tm_stamp2date','#tm_stamp',_coop_end);
                        _packO.ENDT:=exec('tm_stamp2time','#tm_stamp',_coop_end)
                     ?}
                  |? _grop_pr<1
                  ||
::                   obsluga grup operacji na zleceniu ktore ma przewodniki
::                   pobieram proporcje ktora sluzyc ma do skorygowania ilosci ktora jest zaplanowana
                     _packO.COOP:=0;
                     _grop_start:=exec('planned_grop_s','px_stage',PX_STAGE.ref());
                     _grop_end:=exec('planned_grop_e','px_stage',PX_STAGE.ref());
                     _packO.TM_START:=_grop_start;
                     _packO.TM_END:=_grop_end;
                     _packO.STARTD:=exec('tm_stamp2date','#tm_stamp',_grop_start);
                     _packO.STARTT:=exec('tm_stamp2time','#tm_stamp',_grop_start);
                     _packO.ENDD:=exec('tm_stamp2date','#tm_stamp',_grop_end);
                     _packO.ENDT:=exec('tm_stamp2time','#tm_stamp',_grop_end)
                  || _packO.COOP:=0;
                     _packO.TM_START=0;
                     _packO.TM_END:=0;
                     _packO.STARTD:=date(0,0,0);
                     _packO.STARTT:=time(0,0,0);
                     _packO.ENDD:=date(0,0,0);
                     _packO.ENDT:=time(0,0,0)
                  ?};


                  _packO.REF_KONT:=$PX_OPER.PX_KONT;
                  _packO.REF_KONM:=ref_name(PX_OPER.PX_KONT);
                  _packO.REF_KONR:=#PX_OPER.PX_KONT;

                  _packO.ALIGNMEN:=PX_STAGE.ALIGNMEN;
                  _packO.NAKL_PRC:=PX_STAGE.NAKL_PRC;
                  _packO.NKO:=PX_STAGE.NKO*exec('hour','#tm_stamp');
                  _packO.TTM:=PX_STAGE.TTM*exec('hour','#tm_stamp');

::                Wspolczynnik dla zuzyc wyznaczony na podstawie XJM
                  _coef:=_eggs.Qcoef;
                  {? PX_OPER.CONST='T'
                  ||
::                   Zuzycia zawsze stale - niezalezne od XJM
                     _coef:=1
                  ?};

                  {! _dim:=0..PX_OPER.PX_KONT().IL_WYM-1
                  |! PX_OPER.PX_KONT();
                     _prec:=PX_KONT[PxTabPar.PX_KONT.PREC+_dim];

                     _packO[_packp.CAP_DIM+_dim]:=({? PX_OPER[PxTabPar.PX_OPER.CAPFUSE+_dim]<>''
                                                   || xpar.calc(PX_OPER[PxTabPar.PX_OPER.CAPFUSE+_dim])
                                                   || PX_OPER[PxTabPar.PX_OPER.CAP_USE+_dim]
                                                   ?}*_coef*_grop_pr
                                                  )$_prec;

                     _packO[_packp.CAP_MIN+_dim]:=({? PX_OPER[PxTabPar.PX_OPER.CAPFMIN+_dim]<>''
                                                   || xpar.calc(PX_OPER[PxTabPar.PX_OPER.CAPFMIN+_dim])
                                                   || PX_OPER[PxTabPar.PX_OPER.CAP_MIN+_dim]
                                                   ?}
                                                  )$_prec;

                     _packO[_packp.CAP_MAX+_dim]:=({? PX_OPER[PxTabPar.PX_OPER.CAPFMAX+_dim]<>''
                                                   || xpar.calc(PX_OPER[PxTabPar.PX_OPER.CAPFMAX+_dim])
                                                   || PX_OPER[PxTabPar.PX_OPER.CAP_MAX+_dim]
                                                   ?}
                                                  )$_prec;
::                   Dosumowuje czas TPZ
                     {? ($('PX_KONT.JM'+$(_dim+1)+'().KOD'))()=exec('get','#params',500380,2)
                     || _packO[_packp.CAP_DIM+_dim]:=(_packO[_packp.CAP_DIM+_dim]+PX_STAGE.TPZ)$_prec
                     ?};
                     ~~
                  !};

                  {? _coop_start>0 & _coop_end>0 & PX_VAR.NAST_ALG=2 & exec('is_koop','px_kont',PX_OPER.PX_KONT)
                  || _duration:=_coop_end-_coop_start;
                     _packO[_packp.CAP_DIM]:=_duration/exec('hour','#tm_stamp');
                     _packO[_packp.CAP_MAX]:=0
                  ?};

::                teraz wyczyscimy pozostale wymiary
                  {! _dim:=PX_OPER.PX_KONT().IL_WYM..PxTabPar.il_wym-1
                  |! _packO[_packp.CAP_DIM+_dim]:=0;
                     _packO[_packp.CAP_MIN+_dim]:=0;
                     _packO[_packp.CAP_MAX+_dim]:=0;
                     ~~
                  !};

                  _refpackO:=_eggs.PxPack.add(_packO);
                  _stage.add(_packS.PX_STAGE
                            ,$_refpackO
                            ,#_parentS
                            ,_packS.SYMBOL
                            ,_packS.NUM
                            ,_eggs.PxPack.Paczka.UID
                            ,_packO.SYMBOL);
                  PX_OPER.next()
               !}

            |? _eggs.PxPack.Paczka.seek(_parentB)
            || _eggs.PxPack.Paczka.del()
            ?}
         ?}
      ?};

      {? _eggs.PxMAT
      ||
         _packB.PARENT:=#_parentS;
         _packB.SYMBOL:='Surowce';
         _packB.NAZWA:='Surowce etapu '+form(PX_STAGE.NR,_form_dokl);
         _packB.BRANCH:='T';
         _packB.TYP:='B';
         _packB.LEVEL:=1;
         _packB.PL_FORCE:=_eggs.PL_FORCE;
         _packB.ILOSC:=_eggs.Quantity;
         _packB.NUM_STAG:=PX_STAGE.NR;

         _packB.PX_STAGE:=$PX_STAGE.ref();
         _packB.PX_STAGM:=PX_STAGE.name();
         _packB.PX_STAGR:=#PX_STAGE.ref();

         _parentB:=_eggs.PxPack.add(_packB);

         {? _parentB<>null()
         ||
::          --- Surowce dla etapu
            PX_MAT.prefix(PX_STAGE.ref());
            {? PX_MAT.first()
            || {!
               |?
                  _packM.PARENT:=#_parentB;
                  _packM.SYMBOL:=PX_MAT.M().KTM;
                  _packM.NAZWA:=M.N;
                  _packM.BRANCH:='N';
                  _packM.TYP:='M';
                  _packM.LEVEL:=2;
                  _packM.ILOSC:=_eggs.Quantity;
                  _packM.PL_FORCE:=_eggs.PL_FORCE;
                  _packM.NUM:=_packS.NUM;
                  _packM.NUM_STAG:=_packS.NUM_STAG;

                  _packM.DIR:=_eggs.Directio;
                  _packM.PX_STAGE:=$PX_STAGE.ref();
                  _packM.PX_STAGM:=PX_STAGE.name();
                  _packM.PX_STAGR:=#PX_STAGE.ref();

                  _packM.MATERIAL:=$PX_MAT.M;
                  _il:=PX_MAT.IL*_eggs.Qcoef;
                  _packM.NORMA:={? M.DOKL=0 || ceil(_il) || _il$M.DOKL ?};

                  _eggs.PxPack.add(_packM);

                  PX_MAT.next()
               !}
            |? _eggs.PxPack.Paczka.seek(_parentB)
            || _eggs.PxPack.Paczka.del()
            ?}
         ?}
      ?}

   ?};
   _eggs.PX_STAGE=null() & PX_STAGE.next()
!};

{? _stage.tab.first()
||
   {!
   |? _px_stage:=exec('FindAndGet','#table',PX_STAGE,_stage.tab.REF,,,null());
      _ref:=_stage.tab.ref();
      _uid:=_stage.tab.UID;
      _parent:=_stage.tab.PARENT;
      _etap:=_stage.tab.ETAP;
      _num:=_stage.tab.NUM;
      _zasob:=_stage.tab.ZASOB;
      Cntx.psh(_stage.tab,PX_NAST,PX_STAGE);
      PX_NAST.index('PX');
      PX_NAST.prefix(_px_stage);
      {? PX_NAST.first()
      ||
::       są nastepniki, ale trzeba sprawdzic czy nie pochodzi z innego podzlecenia
         _stage.tab.prefix($PX_NAST.PX_NEXT);
         {? _stage.tab.first()
         ||
::          jest w analizowanej dziedzinie
            _packB.PARENT:=_parent;
            _packB.SYMBOL:='Następnik';
            _packB.NAZWA:='Następnik etapu '+form(_num,_form_dokl);
            _packB.BRANCH:='T';
            _packB.TYP:='B';
            _packB.LEVEL:=1;
            _packB.PL_FORCE:=_eggs.PL_FORCE;
            _packB.ILOSC:=_eggs.Quantity;

            _packB.PX_STAGE:=$_px_stage;
            _packB.PX_STAGM:=8+$_px_stage;
            _packB.PX_STAGR:=#_px_stage;

            _packB.UID:=0;
            _packB.NUM_STAG:=_num;

            _parentB:=_eggs.PxPack.add(_packB);
            {? _parentB<>null()
            ||
               _stage.tab.cntx_psh();
               _stage.tab.prefix();
               {? _stage.tab.seek(_ref)
               ||
                  _eggs.PxPack.Paczka.cntx_psh();
                  _eggs.PxPack.Paczka.prefix();
::                Aktualizuje rekord zasobu, mówiąc mu że ma następniki
                  {? _eggs.PxPack.Paczka.seek(_stage.tab.REFZ)
                  || _eggs.PxPack.Paczka.HAS_NEXT:='T';
                     _eggs.PxPack.Paczka.put()
                  ?};

::                Aktualizuje rekord etapu mówiąc mu że ma następniki
                  {? _eggs.PxPack.Paczka.seek(_parent)
                  || _eggs.PxPack.Paczka.HAS_NEXT:='T';
                     _eggs.PxPack.Paczka.put()
                  ?};
                  _eggs.PxPack.Paczka.cntx_pop()
               ?};
               _stage.tab.cntx_pop();

               {!
               |? _stage.tab.prefix($PX_NAST.PX_NEXT);
                  _stage.tab.first();
                  _packN.PARENT:=_parentB;
                  _packN.SYMBOL:=_stage.tab.ETAP;
                  _packN.NAZWA:=_stage.tab.ZASOB;
                  _packN.TYP:='N';
                  _packN.LEVEL:=2;
                  _packN.PL_FORCE:=_eggs.PL_FORCE;
                  _packN.ILOSC:=_eggs.Quantity;

                  _packN.PX_STAGE:=$PX_NAST.PX_NEXT;
                  _packN.PX_STAGM:=8+$PX_NAST.PX_NEXT;
                  _packN.PX_STAGR:=#PX_NAST.PX_NEXT;
                  _packN.NUM_STAG:=PX_NAST.PX_NEXT().NR;

                  _packN.NUM:=_num;
                  _packN.UID:=_stage.tab.UID;

                  _eggs.PxPack.add(_packN);
                  PX_NAST.next()
               !}
            ?}
         ?}
      ?};
      PX_NAST.index('NEXT');
      PX_NAST.prefix(_px_stage);
      {? PX_NAST.first()
      ||
::       są poprzedniki, ale trzeba sprawdzic czy nie pochodzi z innego podzlecenia
         _stage.tab.prefix($PX_NAST.PX_STAGE);
         {? _stage.tab.first()
         ||
::          jest w analizowanej dziedzinie
            _packB.PARENT:=_parent;
            _packB.SYMBOL:='Poprzednik';
            _packB.NAZWA:='Poprzednik etapu '+form(_num,_form_dokl);
            _packB.BRANCH:='T';
            _packB.TYP:='B';
            _packB.LEVEL:=1;
            _packB.PL_FORCE:=_eggs.PL_FORCE;
            _packB.ILOSC:=_eggs.Quantity;

            _packB.PX_STAGE:=$_px_stage;
            _packB.PX_STAGM:=8+$_px_stage;
            _packB.PX_STAGR:=#_px_stage;
            _packB.NUM_STAG:=_num;

            _packB.UID:=0;

            _parentB:=_eggs.PxPack.add(_packB);
            {? _parentB<>null()
            ||
               _stage.tab.cntx_psh();
               _stage.tab.prefix();
               {? _stage.tab.seek(_ref)
               ||
                  _eggs.PxPack.Paczka.cntx_psh();
                  _eggs.PxPack.Paczka.prefix();
::                Aktualizuje rekord zasobu, mówiąc mu że ma poprzedniki
                  {? _eggs.PxPack.Paczka.seek(_stage.tab.REFZ)
                  || _eggs.PxPack.Paczka.HAS_PREV:='T';
                     _eggs.PxPack.Paczka.put()
                  ?};

::                Aktualizuje rekord etapu mówiąc mu że ma poprzedniki
                  {? _eggs.PxPack.Paczka.seek(_parent)
                  || _eggs.PxPack.Paczka.HAS_PREV:='T';
                     _eggs.PxPack.Paczka.put()
                  ?};
                  _eggs.PxPack.Paczka.cntx_pop()
               ?};
               _stage.tab.cntx_pop();

               {!
               |? _stage.tab.prefix($PX_NAST.PX_STAGE);
                  _stage.tab.first();
                  _packP.PARENT:=_parentB;
                  _packP.SYMBOL:=_stage.tab.ETAP;
                  _packP.NAZWA:=_stage.tab.ZASOB;
                  _packP.TYP:='P';
                  _packP.LEVEL:=2;
                  _packP.PL_FORCE:=_eggs.PL_FORCE;
                  _packP.ILOSC:=_eggs.Quantity;

                  _packP.PX_STAGE:=$PX_NAST.PX_STAGE;
                  _packP.PX_STAGM:=8+$PX_NAST.PX_STAGE;
                  _packP.PX_STAGR:=#PX_NAST.PX_STAGE;
                  _packP.NUM_STAG:=PX_NAST.PX_STAGE().NR;

                  _packP.NUM:=_num;
                  _packP.UID:=_stage.tab.UID;

                  _eggs.PxPack.add(_packP);
                  PX_NAST.next()
               !}
            ?}
         ?}
      ?};

      Cntx.pop(_stage.tab,PX_NAST,PX_STAGE);
      _stage.tab.next()
  !}
?};

PX_OPER.cntx_pop();
PX_KONT.cntx_pop();
_eggs.PxPack.ErrCode:=0;
~~


\Grops2PxPack
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Generuje paczke na podstawie aktualnej dziedziny GROPS
::   WE: _eggs - wynik formuly exec('pck_params','px_whisk')
::   WY: ~~
::UWAGA: PRACA NA AKTUALNYM KONTEKSCIE GROPS - Przed wywolaniem musi zostac wykonane GROPS.first()!!!
::       albo GROPS.seek(_eggs.GROPS)
::----------------------------------------------------------------------------------------------------------------------
_eggs:=_a;

{? var_pres('PxTabPar')<100 || exec('PxTabPar','px_init') ?};
_packp:=_eggs.PxPack.tabpar;
_packS:=_eggs.PxPack.add_a();
_packB:=_eggs.PxPack.add_a();
_packO:=_eggs.PxPack.add_a();
_packM:=_eggs.PxPack.add_a();
_packN:=_eggs.PxPack.add_a();
_packP:=_eggs.PxPack.add_a();

_stage:=exec('stage','px_nast');
_packS.PARENT:=0;

_mainver:=exec('get_replan_version','px_ver');

_size:=1;
_form_dokl:=+($_size);
_form_dokl:=-1*_form_dokl;

_px_stage:=exec('px_stage4grops','px_grop');
_tm_min:=0;
_tm_max:=0;
PX_STAGE.cntx_psh(); PX_STAGE.prefix();
PX_KONT.cntx_psh();
{? PX_STAGE.seek(_px_stage)
||
   _packS.SYMBOL:='Etap '+form(PX_STAGE.NR,_form_dokl);
   _packS.NAZWA:=PX_STAGE.NAZWA;
   _packS.BRANCH:='T';
   _packS.TYP:='O';
   _packS.LEVEL:=0;
   _packS.ILOSC:=_eggs.Quantity;
   _packS.NUM:=PX_STAGE.NR;
   _packS.NUM_STAG:=PX_STAGE.NR;
   _packS.DIR:=_eggs.Directio;
   _packS.PX_STAGE:=$PX_STAGE.ref();
   _packS.PX_STAGM:=PX_STAGE.name();
   _packS.PX_STAGR:=#PX_STAGE.ref();
   _packS.ALIGNMEN:=PX_STAGE.ALIGNMEN;
   _wew:=exec('is_wew','px_stage',PX_STAGE.ref());
   _packS.WEW:=_wew;
   _packS.PL_FORCE:=_eggs.PL_FORCE;
   _packS.LANE:=-1;

   {? _eggs.PX_GRP<>null()
   ||
      PX_GRP.cntx_psh(); PX_GRP.prefix();
      {? PX_GRP.seek(_eggs.PX_GRP)
      || {? _eggs.Directio>0
         || _tm_min:=exec('get_time_grop','px_grop',GROP.ref(),1,PX_GRP.PX_VER)
         || _tm_max:=exec('get_time_grop','px_grop',GROP.ref(),-1,PX_GRP.PX_VER)
         ?}
      ?};
      PX_GRP.cntx_pop();
      ~~
   ?};
   _packS.TM_MIN:=_tm_min;
   _packS.TM_MAX:=_tm_max;
   ~~
?};
PX_STAGE.cntx_pop();

::   {? _eggs.PX_GRP<>null()
::   ||
::::    Sprawdzam czy dany etap dla danej grupy ma punkty czasowe
::      PX_POINT.cntx_psh();
::      PX_POINT.index('PX_GRP');
::      PX_POINT.prefix(_eggs.PX_GRP,PX_STAGE.ref());
::      {? PX_POINT.first()
::      || _eggs.PxPack.HASPOINT:=1;
::         _tm_min:=PX_POINT.TM_MIN;
::         _tm_max:=PX_POINT.TM_MAX
::      ?};
::      PX_POINT.cntx_pop();
::      ~~
::   ?};

_parentS:=_eggs.PxPack.add(_packS);

{? _parentS<>null()
||
:: Galaz zasobow etaptu
   {? _eggs.PxOPER
   ||
      _packB.PARENT:=#_parentS;
      _packB.SYMBOL:='Zasoby';
      _packB.NAZWA:='Zasoby etapu '+form(1,_form_dokl);
      _packB.BRANCH:='T';
      _packB.TYP:='B';
      _packB.LEVEL:=1;
      _packB.PL_FORCE:=_eggs.PL_FORCE;
      _packB.NUM_STAG:=1;

      _packB.PX_STAGE:=_packS.PX_STAGE;
      _packB.PX_STAGM:=_packS.PX_STAGM;
      _packB.PX_STAGR:=_packS.PX_STAGR;

      _packB.ILOSC:=_eggs.Quantity;

      _parentB:=_eggs.PxPack.add(_packB);

      {? _parentB<>null()
      ||
         _konty:=exec('plres2pxkont','px_tie',GROPS.PL_RES,_mainver);

         {? type_of(_konty)>0 & _konty.first()
         ||
            {!
            |?
::             Operacje dla etapu
               PX_KONT.clear();
               {? PX_KONT.seek(_konty.REF,_konty.NAME)
               ||
                  _packO.PARENT:=#_parentB;
                  _packO.SYMBOL:='('+PX_KONT.SYMBOL+') '+PX_KONT.NAZWA;
                  _packO.NAZWA:=PX_KONT.NAZWA;
                  _packO.BRANCH:='N';
                  _packO.TYP:='K';
                  _packO.LEVEL:=2;
                  _packO.ILOSC:=_eggs.Quantity;
                  _packO.NUM:=_packS.NUM;
                  _packO.NUM_STAG:=_packS.NUM_STAG;
                  _packO.PX_STAGE:=_packS.PX_STAGE;
                  _packO.PX_STAGM:=_packS.PX_STAGM;
                  _packO.PX_STAGR:=_packS.PX_STAGR;

                  _packO.DIR:=_eggs.Directio;

                  _packO.TM_MIN:=_tm_min;
                  _packO.TM_MAX:=_tm_max;

                  _packO.WEW:='T';
                  _packO.LANE:=-1;
                  _packO.PL_FORCE:=_eggs.PL_FORCE;

                  _packO.COOP:=0;
                  _packO.TM_START=0;
                  _packO.TM_END:=0;
                  _packO.STARTD:=date(0,0,0);
                  _packO.STARTT:=time(0,0,0);
                  _packO.ENDD:=date(0,0,0);
                  _packO.ENDT:=time(0,0,0);

                  _packO.REF_KONT:=$PX_KONT.ref;
                  _packO.REF_KONM:=ref_name(PX_KONT.ref);
                  _packO.REF_KONR:=#PX_KONT.ref();

::                  _packO.ALIGNMEN:=PX_STAGE.ALIGNMEN;
::                  _packO.NAKL_PRC:=PX_STAGE.NAKL_PRC;
::                  _packO.NKO:=PX_STAGE.NKO*exec('hour','#tm_stamp');
::                  _packO.TTM:=PX_STAGE.TTM*exec('hour','#tm_stamp');

                  _it:=0;
                  {! _dim:=0..PX_KONT.IL_WYM-1
                  |! _it+=1;
                     _prec:=PX_KONT[PxTabPar.PX_KONT.PREC+_dim];

                     _plres_prop:=exec('plres_prop','px_tie',PX_KONT.PL_RES,GROPS.PL_RES);
                     {? _plres_prop<=0
                     || _plres_prop:=1
                     ?};
::                   Do przemyślenia czy stosować proporcję
                     _plres_prop:=1;

                     {? ($('PX_KONT.JM'+$_it+'().KOD'))()=exec('get','#params',500380)
                     || _packO[_packp.CAP_DIM+_dim]:=(exec('time2float','#convert',GROPS.CZAS)*_eggs.Quantity*_plres_prop)$_prec
                     |? ($('PX_KONT.JM'+$_it+'().KOD'))()=exec('get','#params',500381)
                     || _packO[_packp.CAP_DIM+_dim]:=(exec('time2float','#convert',GROPS.CZAS)*_eggs.Quantity*_plres_prop)$_prec
                     ?};
                     ~~
                  !};

::                teraz wyczyscimy pozostale wymiary
                  {! _dim:=PX_KONT.IL_WYM..PxTabPar.il_wym-1
                  |! _packO[_packp.CAP_DIM+_dim]:=0;
                     _packO[_packp.CAP_MIN+_dim]:=0;
                     _packO[_packp.CAP_MAX+_dim]:=0;
                     ~~
                  !};

                  _refpackO:=_eggs.PxPack.add(_packO);
                  _stage.add(_packS.PX_STAGE
                            ,$_refpackO
                            ,#_parentS
                            ,_packS.SYMBOL
                            ,_packS.NUM
                            ,_eggs.PxPack.Paczka.UID
                            ,_packO.SYMBOL)
               ?};
               _konty.next()
            !}
         |? _eggs.PxPack.Paczka.seek(_parentB)
         || _eggs.PxPack.Paczka.del()
         ?}
      ?}
   ?}
?};
PX_KONT.cntx_pop();
_eggs.PxPack.ErrCode:=0;
~~

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:36 069c31ea2a1359e7e1d74d823e2f5a078c53b05a9c5cb8a6c4c443df9dce3f1fc0f2053305bea937734c223d44213bd1fbbb8138be26aa36d84a8b1114bc2ee4621904f79387f68c62ffe7f726cca81367f04c04b76380033994b3462dcabdfdeae12395388d61a2cb9c47d5cfa644502b81600e3bde0c16638895ad957c7524
