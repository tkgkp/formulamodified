:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: ro_class.fml
:: Utworzony: 12.01.2018
:: Autor: RWR
:: Systemy: RODO
::======================================================================================================================
:: Zawartość: Definicja klasy RODO.
::======================================================================================================================


\rodo_decl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Definicja klasy RODO.
::       Klasa korzysta z następujących struktur danych:
::       Tabele: RO_REQN, RO_REQP, RO_REQT.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: Przy powtórnym wywołaniu deklaracji klasy RODO - zakończ.
{? var_pres('RODO',@.CLASS)>0
|| return()
?};

obj_decl('RODO',

:: Stałe  --------------------------------------------------------------------------------------------------------------


:: Wersja runtime-ów.
   obj_fld('runtime',user(11)),


:: Pola prywatne  ------------------------------------------------------------------------------------------------------


:: Tabela tymczasowa z konfiguracją pól-parametrów żądań.
:: Ponieważ klucze, które przychodzą poprzez webservice-y są dłuższe niż 8 znaków istnieje potrzeba ich mapowania.
:: Tabela zawiera informacje o akronimie, nazwie i typie "naszego" odpowiednika oraz kluczu.
   obj_fld('TCID',~~),
:: Tablica z elementami nazwanymi - indeksami tabeli TCID.
   obj_fld('NCID',~~),


:: Tabela tymczasowa z "naszymi" polami-parametrami żądań.
   obj_fld('TBUF',~~),


:: Tabela tymczasowa z polami-parametrów żądań, które standardowo nie są dalej przetwarzane, a potrzebne są
:: ze względów technicznych/redakcyjnych np. obsługi pól o innym typie niż STRING
   obj_fld('TEDIT',~~),


:: Okno redagowania parametrów.
   obj_fld('we',~~),


:: Pola zawierające formuły.
   obj_fld('fTAB',''),
   obj_fld('fARR',''),

   obj_fld('msg',~~),


:: Metody prywatne  ----------------------------------------------------------------------------------------------------


   obj_meth('addTCID',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Formuła dodaje jeden rekord do tabeli .TCID.
::   WE: _a [STRING] - Akronim pola.
::       _b [STRING] - Nazwa pola.
::       _c [STRING] - Typo pola.
::       _d [STRING] - Nazwa klucza.
::   WY: Wynik operacji.
::----------------------------------------------------------------------------------------------------------------------
   "  .TCID.blank();
      .TCID.LP:=.TCID.size()+1;
      .TCID.ACR:=_a;
      .TCID.TYPE:=_b;
      .TCID.NAME:=_c;
      .TCID.KEY:=_d;
      .TCID.add()
   "),


   obj_meth('crtTCID',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Metoda tworzy strukturę i wypełnia danymi tabelę tymczasową .TCID.
::   WE:
::   WY: Wynik operacji.
::----------------------------------------------------------------------------------------------------------------------
   "  .TCID:=tab_tmp(1,
         'LP','INTEGER','Lp.',
         'ACR','STRING[8]','Akronim pola',
         'TYPE','STRING[12]','Typ pola',
         'NAME','STRING[64]','Nazwa pola',
         'KEY','STRING[20]','Nazwa klucza'
      );
      .NCID:=obj_new('LP','ACR','KEY');
      .NCID.LP:=.TCID.index('?');
      .NCID.ACR:=.TCID.ndx_tmp(,,'ACR',,);
      .NCID.KEY:=.TCID.ndx_tmp(,,'KEY',,);

::    Dane podstawowe
      .addTCID('NAZWISKO','STRING[255]','Nazwisko'@,'SurName') &
      .addTCID('PIERWSZE','STRING[255]','Imię'@,'FirstName') &
      .addTCID('DRUGIE','STRING[255]','Drugie imię'@,'SecondName') &
::    Dane dodatkowe
      .addTCID('PESEL','STRING[11]','PESEL'@,'PESEL') &
      .addTCID('NIP','STRING[15]','NIP'@,'TIN') &
      .addTCID('REGON','STRING[25]','REGON'@,'REGON') &
      .addTCID('DOWOD','STRING[11]','Dowód osobisty'@,'IDCardNo') &
      .addTCID('PASZPORT','STRING[40]','Paszport'@,'PassportNo') &
      .addTCID('ZNIP','STRING[50]','Zagraniczny numer identyfikacyjny podatnika'@,'ForeignTIN') &
      .addTCID('DATAUR','STRING[10]','Data urodzenia'@,'BirthDate') &
      .addTCID('TELEFON','STRING[30]','Telefon'@,'PhoneNo') &
      .addTCID('FAX','STRING[30]','Numer faxu'@,'Fax') &
      .addTCID('EMAIL','STRING[40]','E-mail'@,'EMail') &
      .addTCID('WWW','STRING[80]','Strona internetowa'@,'WWWPage') &
      .addTCID('ADRES','STRING[80]','Adres zamieszkania (Ulica, nr domu)'@,'Address') &
      .addTCID('ULICA','STRING[40]','Ulica'@,'Street') &
      .addTCID('DOM','STRING[10]','Numer domu'@,'BldgNo') &
      .addTCID('LOKAL','STRING[10]','Numer mieszkania/lokalu'@,'AptNo') &
      .addTCID('KODPOCZ','STRING[8]','Kod pocztowy'@,'ZipCode') &
      .addTCID('MIASTO','STRING[40]','Miejscowość'@,'City') &
      .addTCID('KRAJ','STRING[40]','Kraj'@,'Country') &
      .addTCID('WOJ','STRING[40]','Województwo'@,'District') &
      .addTCID('RU_DS','STRING[40]','Źródło danych'@,'DataSource') &
      .addTCID('RU_AD','STRING[40]','Decyzja automatyczna'@,'AutoDecision')
   "),


   obj_meth('crtTEDIT',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ARTSLO [19.22]
:: OPIS: Metoda tworzy strukturę i wypełnia danymi tabelę tymczasową .TEDIT.
::   WE:
::   WY: Wynik operacji.
::----------------------------------------------------------------------------------------------------------------------
   "  .TEDIT:=tab_tmp(1,
         'URDATA','DATE','Data urodzenia'@
      );
:: .add robione po to by mieć pewność, że w tabeli znajduje się choć jeden rekord, żeby można było wykorzystać
:: ref_tab umożliwiające dostęp do tabeli w miejscach gdzie standardowo go nie ma
      .TEDIT.blank();
      .TEDIT.add()
   "),


   obj_meth('crtF',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Metoda tworzy tabelę tymczasową .BUF.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
   "  .TCID.cntx_psh();
      .TCID.index(.NCID.LP);
      .TCID.prefix();
      {? .TCID.first()
      || .fTAB:='tab_tmp(1';
         .fARR:='';
         {!
         |? .fTAB+=',\\''+.TCID.ACR+'\\',\\''+.TCID.TYPE+'\\',\\''+.TCID.NAME+'\\'';
            .fARR+=',\\''+.TCID.ACR+'\\'';
            .TCID.next()
         !};
         .fTAB+=')';
         .fARR:='obj_new('+(1-.fARR)+')'
      ?};
      .TCID.cntx_pop();
      .fTAB<>'' & .fARR<>''
   "),


   obj_meth('isEmpty',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Metoda sprawdza, czy podana wartość typu liczba / ciąg znaków / data/ czas ma wartość "pustą" (zerową).
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
   "_a=0",type_of(0),-1),

   obj_meth('isEmpty',"_a=''",type_of(''),-1),

   obj_meth('isEmpty',"_a=date(0,0,0)",type_of(date()),-1),

   obj_meth('isEmpty',"_a=time(0,0,0)",type_of(time()),-1),


:: Metody publiczne  ---------------------------------------------------------------------------------------------------


   obj_meth('__init',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Metoda inicjująca obiekt. Tworzy struktury złożone.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
   "  .crtTCID();
      .crtF();
      .crtTEDIT();
      .TBUF:=($.fTAB)();
      .TEDIT.fld_fml('URDATA','AFTER_EDIT',""_TEDIT:=cur_tab(1,1); _TEDIT.DATAUR:=$fld(); 1 "");
      .msg:=exec('get_msgs','ro_class');
      ~~
   "),


   obj_meth('los_dt',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Metoda losuje datę z podanego przedziału.
::   WE: [_a] [DATE] - Data początkowa przedziału [domyślnie: 1900/01/01].
::       [_b] [DATE] - Data końcowa przedziału [domyślnie: bieżąca].
::   WY: Losowa data.
::----------------------------------------------------------------------------------------------------------------------
   "  _od:={? var_pres('_a')=type_of(date()) || _a || date(1900,1,1) ?};
      _do:={? var_pres('_b')=type_of(date()) || _b || date() ?};
      {? _od>_do
      || _od==_do
      ?};
      _delta:=1+_do-_od;
      _od+{? _delta>1 || int(_delta*rand()) ?}
   "),


   obj_meth('los_int',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Metoda losuje liczbę całkowitą z podanego przedziału.
::   WE: [_a] [NUMBER] - Dolna granica przedziału [domyślnie: 1].
::       [_b] [NUMBER] - Górna granica przedziału [domyślnie: 1000].
::   WY:
::----------------------------------------------------------------------------------------------------------------------
   "  _min:={? var_pres('_a')=type_of(0) || _a || 1 ?};
      _max:={? var_pres('_b')=type_of(0) || _b || 1000 ?};
      {? _min>_max
      || _min==_max
      ?};
      _delta:=1+_max-_min;
      _min+{? _delta>1 || int(_delta*rand()) ?}
   "),


   obj_meth('los_str',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Metoda generuje napis składający się z losowo wybranych znaków.
::   WE: [_a] [NUMBER] - Oczekiwana długość napisu [domyślnie: 0].
::       [_b] [STRING] - Napis zawierający kody zestawu znaków, z których tworzona będzie odpowiedź.
::                       Obsługiwane zestawy:
::                         0 - cyfry;
::                         a - małe litery alfabetu łacińskiego (26 znaków);
::                         ą - małe litery alfabetu łacińskiego oraz polskie znaki diakrytyczne (34 znaki);
::                         A - wielkie litery alfabetu łacińskiego [domyślnie];
::                         Ą - wielkie litery alfabetu łacińskiego oraz polskie znaki diakrytyczne;
::       [_c] [STRING] - Napis zawierający kody zestawu znaków, z których losowany będzie pierwszy znak odpowiedzi
::                       (patrz wyżej).
::       [_d] [NUMBER] - Liczba znaków, które mogą zostać pominięte [domyślnie: 0]. Wartość parametru musi być mniejsza
::                       od wartości podanej w parametrze _a. Jeżeli parametr zostanie podany, to wynikiem metody będzie
::                       napis, którego długość będzie z przedziału (_a-_d,_a).
::   WY: Napis składający się z losowo wybranych znaków.
::----------------------------------------------------------------------------------------------------------------------
   "  {? var_pres('_a')=type_of(0) & _a>0
      || _dl:=_a
      || return('')
      ?};

::    Funkcja zwraca napis zawierający znaki alfabetu zbudowanego z zbiorów określonych kodami.
::       _a [STRING] - Napis zawierający kody zestawu znaków, z których tworzona będzie odpowiedź.
      _getSet:=""
         _ret:='';
         {? _a*'0'
         || _ret+='0123456789'
         ?};
         {? _a*'ą'
         || _ret+='aąbcćdeęfghijklłmnńoópqrstuvwxyzźż'
         |? _a*'a'
         || _ret+='abcdefghijklmnopqrstuvwxyz'
         ?};
         {? _a*'Ą'
         || _ret+='AĄBCĆDEĘFGHIJKLŁMNŃOÓPQRSTUVWXYZŹŻ'
         |? _a*'A'
         || _ret+='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
         ?};
         _ret
      "";

      _ax:={? var_pres('_b')=type_of('') || _getSet(_b) || '' ?};
      {? _ax=''
      || _ax:=_getSet('A')
      ?};
      _dx:=+_ax;
      _a1:={? var_pres('_c')=type_of('') || _getSet(_c) || '' ?};
      {? _a1=''
      || _a1:=_ax
      ?};

::    Funkcja zwraca wylosowany znak.
::       _a [STRING] - Znaki alfabetu.
::       _b [NUMBER] - Liczba znaków alfabetu (optymalizacyjnie).
      _losuj:=""1+(int(rand()*_b)-_a)"";

      _ndl:=_dl-{? var_pres('_d')=type_of(0) & _d>0 & _d<=_dl || int((1+_d)*rand()) ?};

::    Losowanie I-szego znaku.
      {? _ndl
      || _ret:=_losuj(_a1,+_a1);
         {! _lp:=2 .. _ndl
::       Losowanie kolejnych znaków.
         |!  _ret+=_losuj(_ax,_dx)
         !};
         _ret
      || ''
      ?}
   "),


   obj_meth('unify',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Metoda unifikująca wartość wskazanego pola. Obecnie wszystkie obsługiwane pola są typu napisowego, dlatego
::       metoda zakłada, że takiego typu będzie przekazana wartość (kontrola na poziomie klasy).
::   WE: _a [STRING] - Akronim pola / metoda unifikacji.
::       _b [STRING] - Wartość pola (do zunifikowania).
::   WY: Wartość zunifikowana pola.
::----------------------------------------------------------------------------------------------------------------------
   "  _acr:=_a;
      _ret:=_b;
      {? _a='TYP'
::       Obsługa pola technicznego mówiącego o typie danych (ORG / UNI).
      || _ret:='UNI'
      |? _a='NAZWISKO' | _a='PIERWSZE' | _a='DRUGIE' | _a='DOWOD' | _a='PASZPORT' | _a='EMAIL'
::       Litery na małe, bez spacji (początkowych, końcowych, wewnętrznych).
      || _ret:=gsub(-_ret,' ','')
      |? _a='PESEL' | _a='NIP' | _a='REGON' | _a='ZNIP'
::       Bez separatorów / białych znaków.
      || _sep:=spli_str(' ^-','^');
         _ret:=gsub(-_ret,_sep,'')
      |? _a='TELEFON'
::       Bez separatorów / białych znaków.
      || _sep:=spli_str(' ^-','^');
         _ret:=gsub(-_ret,_sep,'')
      ?};
      _ret
   ",type_of(''),type_of(''),-1),


   obj_meth('equal',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Metoda porównuje
::   WE: _a [STRING] - Akronim porównywanej wartości.
::       _b [ANY]    - Wartość wzorcowa (po unifikacji).
::       _c [ANY]    - Wartość porównywana (przed unifikacją).
::   WY:
::----------------------------------------------------------------------------------------------------------------------
   "  _typ:=_a;
      _uni:={? _>1 || _b || '' ?};
      _val:={? _>2 || _c || '' ?};
      ~.isEmpty(_uni) & ~.isEmpty(_val) & _uni=.unify(_typ,_val)
   ",type_of('')),


   obj_meth('read',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Metoda odczytuje parametry żądania wskazanego parametrem i zapisuje je w buforze wewnętrznej tabeli
::       tymczasowej.
::   WE: _a [REFERENCE] - Wskazanie nagłówka żądania - rekordu tabeli RO_REQN;
::   WY: Wynik operacji.
::----------------------------------------------------------------------------------------------------------------------
   "  _ref:=_a;
      _ret:=0;
      RO_REQN.cntx_psh();
      RO_REQN.prefix();
      {? RO_REQN.seek(_ref)
      || RO_REQP.cntx_psh();
         RO_REQP.index('KEY');
         RO_REQP.prefix(RO_REQN.ref(),null());
         .TBUF.blank();
         .TEDIT.blank();
         {? RO_REQP.first()
         || _ok:=1;
            _fld:=0;
            .TCID.cntx_psh();
            .TCID.index(.NCID.KEY);
            .TCID.prefix();
            {!
            |? {? .TCID.find_key(RO_REQP.RO_REQI().NAME)
               || _fld+=1;
                  ($('_a.'+.TCID.ACR+':=_b'))(.TBUF,RO_REQP.VAL)
               || _ok:=0
               ?};
               RO_REQP.next()
            !};
            {? _ok & _fld>0
            || _ret:=1
            || .TBUF.blank();
               .TEDIT.blank()
            ?};
            .TCID.cntx_pop()
         ?};
         RO_REQP.cntx_pop()
      ?};
      RO_REQN.cntx_pop();
      _ret
   ",type_of(null()),-1),


   obj_meth('write',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Metoda dla wskazanego parametrem nagłówka żądania, zapisuje parametry na podstawie wartości zawartych w buforze
::       wewnętrznej tabeli tymczasowej.
::   WE: _a [REFERENCE] - Wskazanie nagłówka żądania.
::   WY: Wynik operacji.
::----------------------------------------------------------------------------------------------------------------------
   "  _ref:=_a;
      _ret:=0;
      RO_REQN.cntx_psh();
      RO_REQN.prefix();
      {? RO_REQN.seek(_ref)
      || RO_REQP.cntx_psh();
         RO_REQP.index('KEY');
         RO_REQP.prefix(_ref,null());
         .TCID.cntx_psh();
         .TCID.prefix();
         _loop:=.TCID.first();
         do();
         {!
         |? _loop
         |! _val:=($('_a.'+.TCID.ACR))(.TBUF);
            _find:=RO_REQP.find_key(.TCID.KEY,);
            {? .isEmpty(_val)
            || {? _find
               || _ret:=RO_REQP.del(1,1)>0
               ?}
            || {? ~_find
               || RO_REQP.blank();
                  RO_REQP.RO_REQN:=_ref;
                  RO_REQP.RO_REQC:=null();
                  RO_REQP.RO_REQI:=exec('find_ro_reqi','ro_req',.TCID.KEY)
               ?};
               RO_REQP.VAL:=_val;
               _ret:={? _find || RO_REQP.put(1) || RO_REQP.add(1) ?}
            ?};
            _loop:=.TCID.next()
         !};
         _ret:=end();
         .TCID.cntx_pop();
         RO_REQP.cntx_pop()
      ?};
      RO_REQN.cntx_pop();
      _ret
   ",type_of(null()),-1),


   obj_meth('get_we',".get_we($'')",-1),

   obj_meth('get_we',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Metoda przygotowuje okno redagowania.
::   WE: _a [RULE] - Formuła wykonywana przez przycisk "Wprowadź". Jeżeli pusta to brak przycisku.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
   "  _rule:=_a;

      _szer:=50;
      _we:=.TBUF.mk_edit('Wywołanie żądania'@,,'red');

      .TBUF.win_esep(_we,'Zapytanie'@);
      .TBUF.win_efld(_we,RO_REQN,'RO_REQT','NAME','MNAME',_szer-3,,,'Typ zapytania'@,,,1);
      .TBUF.efld_opt(_we,'mark=1',RO_REQN,'RO_REQT','NAME');

      .TBUF.win_esep(_we,'Dane podstawowe'@);
      .TBUF.win_efld(_we,.TBUF,'NAZWISKO',,,_szer,,,,,'Aktulane nazwisko'@);
      .TBUF.win_efld(_we,.TBUF,'PIERWSZE',,,_szer,,,,,'Pierwsze imię'@);
      .TBUF.win_efld(_we,.TBUF,'DRUGIE',,,_szer,,,,,'Drugie imię'@);
      .TBUF.win_efld(_we,.TEDIT,'URDATA',,,11,,,,,'Data urodzenia'@);

      .TBUF.win_esep(_we,'Dane dodatkowe'@);
      .TBUF.win_efld(_we,.TBUF,'PESEL',,,_szer,,,,,'Numer PESEL'@);
      .TBUF.win_efld(_we,.TBUF,'NIP',,,_szer,,,,,'Numer identyfikacji podatkowej'@);
      .TBUF.win_efld(_we,.TBUF,'REGON',,,_szer,,,,,'Numer REGON'@);
      .TBUF.win_efld(_we,.TBUF,'DOWOD',,,_szer,,,,,'Seria i numer dowodu osobistego'@);
      .TBUF.win_efld(_we,.TBUF,'PASZPORT',,,_szer,,,,,'Seria i numer paszportu'@);
      .TBUF.win_efld(_we,.TBUF,'ZNIP',,,_szer,,,,,'Zagraniczny numer identyfikacyjny podatnika'@);
      .TBUF.win_efld(_we,.TBUF,'TELEFON',,,_szer,,,,,'Numer telefonu'@);
      .TBUF.win_efld(_we,.TBUF,'EMAIL',,,_szer,,,,,'Adres elektronicznej skrzynki pocztowej'@);
      {? +_rule
      || _brun:=.TBUF.win_ebtn(_we,'text='+'Wprowadź'@+',panel=bottom,align=begin,edit=0,display=1',
            $(""  _TEDIT:=ref_tab('""+$.TEDIT.ref()+""');
                  RO_REQT.cntx_psh();
                  RO_REQT.index('MNAME');
                  RO_REQT.prefix('T');
                  {? RO_REQT.size()=1 & RO_REQT.first()
                  || RO_REQN.RO_REQT:=RO_REQT.ref()
                  ?};
                  _be:=RO_REQN.fld_fml('RO_REQT','BEFORE_EDIT',$$(RO_REQN.RO_REQT=null()));
                  {? edit_start(""""exec('valid','ro_class')"""")
                  || _a:=RO_REQN.RO_REQT().KEY; ""+_rule+""
                  ?};
                  RO_REQN.fld_fml('RO_REQT','BEFORE_EDIT',_be);
                  RO_REQT.cntx_pop();
                  RO_REQN.blank();
                  cur_tab(1,1).blank();
                  _TEDIT.blank();
                  ''
            "")
         );
         .TBUF.btn_opt(_brun,'default=1,tooltip='+'Wprowadzenie nowego żądania'@)
      ?};
      _bok:=.TBUF.win_ebtn(_we,'text='+exec('text_red_ok','#window'),'key:F2');
      .TBUF.btn_opt(_bok,'tooltip='+'Zatwierdzenie parametrów i wysłanie zapytania'@);
      _besc:=.TBUF.win_ebtn(_we,'text='+'Anuluj'@,'key:Esc');
      .TBUF.btn_opt(_besc,'tooltip='+'Rezygnacja z wysłania zapytania'@);

      _we
   ",type_of(""),-1),


   obj_meth('edit',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Metoda odpowiedzialna za pobranie danych od użytkownika.
::   WE:
::   WY: Klucz wybranej akcji lub '', jeżeli nie podano poprawnych danych.
::----------------------------------------------------------------------------------------------------------------------
   " {? type_of(.we)=type_of(~~)
     || .we:=.get_we()
     ?};

      RO_REQT.cntx_psh();
      RO_REQT.index('MNAME');
      RO_REQT.prefix('T');
      _manual:=RO_REQT.fld_fml('MANUAL','BLANK',""'T'"");

      RO_REQN.cntx_psh();
      RO_REQN.prefix();
      RO_REQN.blank();
      {? RO_REQT.size()=1 & RO_REQT.first()
      || RO_REQN.RO_REQT:=RO_REQT.ref()
      ?};
      _be:=RO_REQN.fld_fml('RO_REQT','BEFORE_EDIT',$$(RO_REQN.RO_REQT=null()));

      .TBUF.win_edit(.we);
      .TBUF.blank();
      .TEDIT.blank();
      _ret:=.TBUF.edit(""exec('valid','ro_class')"");
      _akcja:=RO_REQN.RO_REQT().KEY;

      RO_REQN.fld_fml('RO_REQT','BEFORE_EDIT',_be);
      RO_REQN.cntx_pop();

      RO_REQT.fld_fml('MANUAL','BLANK',_manual);
      RO_REQT.cntx_pop();
      {? _ret
      || _akcja
      || ''
      ?}
   "),


   obj_meth('getPar',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Metoda zwraca tablicę z dwoma elementami nazwanymi: ORG i UNI, które również są tablicami nazwanymi,
::       zawierającymi parametry żądania, które znajdują się w wewnętrznej tabeli tymczasowej .TBUF.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
   "  _ret:=obj_new('ORG','UNI','IDS');
      _ret.ORG:=($.fARR)();
      _ret.UNI:=($.fARR)();
      _ret.IDS:=($.fARR)();
      {! _lp:=1 .. .TBUF.fld_num()
      |! _acr:=.TBUF.fld_acr(_lp);
         _val:=($('_a.'+_acr))(.TBUF);
         ($('_a.'+_acr+':=_b'))(_ret.ORG,_val);
         ($('_a.'+_acr+':=_b'))(_ret.UNI,.unify(_acr,_val));
         ($('_a.'+_acr+':=_b'))(_ret.IDS,'')
      !};
      _ret
   ")

)


\valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [18.22]
:: OPIS: Formuła sprawdzająca poprawność (kompletność) wypełnienia parametrów żądania.
::   WE: [_a] [TABLE]  - Uchwyt tabeli, której pola będą weryfikowane [domyślnie: cur_tab(1,1)]
::       [_b] [NUMBER] - Przetwarzanie wsadowe (brak komunikatów):
::                         0 - Nie [domyślnie];
::                         1 - Tak.
::   WY: Akronim pola do wypełnienia lub wynik weryfikacji:
::          0 - Parametry niepoprawne;
::          1 - Parametry poprawne.
::----------------------------------------------------------------------------------------------------------------------
:: Zgodnie z wytycznymi projektu przyjmuje się, że wypełnione musi być co najmniej jedno pole.
_TAB:={? var_pres('_a')=type_of(SYSLOG) || _a || cur_tab(1,1) ?};
_batch:=var_pres('_b')=type_of(0) & _b;

{? RO_REQN.RO_REQT=null()
|| FUN.emsg('Pole "Typ zapytania" musi być wypełnione.\n(uzupełnij brakujące informacje)'@);
   return('RO_REQT')
?};

_ret:=
   _TAB.NAZWISKO<>'' | _TAB.PIERWSZE<>'' | _TAB.DRUGIE<>'' | _TAB.PESEL<>'' | _TAB.NIP<>'' | _TAB.REGON<>'' |
   _TAB.ZNIP<>'' | _TAB.DOWOD<>'' | _TAB.PASZPORT<>'' | _TAB.TELEFON<>'' | _TAB.EMAIL<>'' | _TAB.DATAUR<>'';

{? ~_ret & ~_batch
|| FUN.emsg('Co najmniej jedno z pól musi być wypełnione.'@)
?};
_ret


\get_msgs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [18.22]
:: OPIS: Tworzy i wypełnia tablicę formułek zwracających treści komunikatów.
::   WE:
::   WY: wskazanie tablicy
::----------------------------------------------------------------------------------------------------------------------
_msg:=obj_new('noId','noRec');
_msg.noId:=$('\'Brak identyfikatora do przeszukania kartoteki \"\'+_a.comment()+\'\" (tabela \'+(2-!_a)+\').\'');
_msg.noRec:=$('\'Nie znaleziono przetwarzanego wiersza w kartotece \"\'+_a.comment()+\'\" (tabela \'+(2-!_a)+\').\'');
_msg

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:37 80346c7920c9536e6e36d55d5fcb63da6e55bc3708e3c1d8071988a7a0b5f427497861511931da42f526b84af10eb017182b6a72447b7e68670c2b332bd56911374cd6961bc5d2c2edd1b58a0e16586567cf67be3e35b650a4f212da1c09d7d1d9a57af24b1d9a14ced962c02b1f6153c103d8c0c55c564b0c7e9cb6c381b671
