:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku:  px_ver.fml [12.10]
:: Utworzony: 2011-07-20
:: Autor: WH
::======================================================================================================================
:: Zawartość: Obsługa wersji planu w planie strategicznym (wielowymiarowym planie pojemnościowym)
::======================================================================================================================


\select
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER/MENU
::  UTW: WH [12.10]
::   WE: [_a] - INTEGER - 0/[1] - czy akcja pokaż dostępna
::       [_b] - INTEGER - 0/[1] - czy akcja kolejka dostępna
::       [_c] - INTEGER - 0/[1] - czy akcja kolejka dostępna
:: OPIS: Wyswietla wszystkie wersje planu
::----------------------------------------------------------------------------------------------------------------------
_act_show:=1;
{? var_pres('_a')=type_of(0)
|| _act_show:=_a
?};
_act_queue:=1;
{? var_pres('_b')=type_of(0)
|| _act_queue:=_b
?};
_act_del:=1;
{? var_pres('_c')=type_of(0)
|| _act_del:=_c
?};

PX_VER.cntx_psh();
PX_VER.index('TIMEP');
PX_VER.clear();
PX_VER.win_sel('WER');
PX_VER.timer('sel','WER',1,"win_disp()");
_hide:='L';
{? _act_show=0
|| _hide+='P'
?};
{? _act_queue=0
|| _hide+='O'
?};
{? _act_del=0
|| _hide+='U'
?};
PX_VER.select(,,,_hide);
PX_VER.timer('sel','WER',0);
PX_VER.cntx_pop();
~~


\mainversion_chk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Sprawdza czy zalozona jest glowna wersja planu i czy wszystkie kontenerery glownej wersji maja pojemniki
::       w wymaganym zakresie
::----------------------------------------------------------------------------------------------------------------------

PX_VER.cntx_psh();
PX_VER.index('SYM');
PX_VER.prefix(1);

{? PX_VER.first()
||
:: jesli jest glowna wersja to ja przypisuje do zmiennej
   {? PX_VAR.MAINVER=null()
   || PX_VAR.MAINVER:=PX_VER.ref()
   ?}
||
:: jesli nie ma wersji glownej planu to ja zakladam
   _dni:=exec('get','#params',500350,1);
   _ok:=exec('px_ver_add','px_ver','Plan główny',  date(),
                                                   time(0,0,0),
                                                   date()+_dni+1,
                                                   time(0,0,0),
                                                   1,
                                                   exec('status_accepted','px_ver')
                                                   );
   {? _ok
   || PX_VAR.MAINVER:=PX_VER.ref()
   ?}
?};
PX_VER.cntx_pop();
~~


\get_mainversion
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca ref do głównej wersji planu
::   WY: PX_VER.ref()
::----------------------------------------------------------------------------------------------------------------------
_result:=null();
PX_VER.cntx_psh();
PX_VER.index('SYM');
PX_VER.prefix(1);
{? PX_VER.first()
|| _result:=PX_VER.ref();
   {? PX_VAR.MAINVER=null()
   ||
::    przypisuje wersję główna do zmiennej, tylko jak jeszcze nie ustawiona
      PX_VAR.MAINVER:=PX_VER.ref()
   ?}
?};
PX_VER.cntx_pop();
_result


\px_ver_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Zakłada nową wersję planu
::   WE: _a - STRING - symbol wersji
::       _b - DATE - data rozpoczęcia
::       _c - TIME - czas rozpoczęcia
::       _d - DATE - data zakończenia
::       _e - TIME - czas zakończenia
::       [_f] - INTEGER - 0=zwykła wersja [domyślnie], 1=plan główny
::       [_g] - STRING - status
::       [_h] - STRING - czy symulacja whatif
::   WY: 0 / 1 - kompletna katastrofa czy kompletny sukces
::  TAG: <PUBLIC>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
{? _<5
|| return(_result)
?};
_daty_s:=null();
_daty_e:=null();

_sym:=_a;
_startt:=_c;
_endt:=_e;
_primary:=0;
_status:='';

{? _>5
|| _primary:=_f
?};

{? _>6
|| _status:=_g
?};
_whatif:='N';
{? var_pres('_h')=type_of('')
|| _whatif:=_h
?};

PX_VER.blank();
PX_VER.SYMBOL:=_sym;
PX_VER.STARTD:=exec('get','daty',_b);
PX_VER.STARTT:=_startt;
PX_VER.ENDD:=exec('get','daty',_d);
PX_VER.ENDT:=_endt;
PX_VER.PRIMARY:=_primary;
{? _status<>''
|| PX_VER.STATUS:=_status
?};
PX_VER.ADD_DATE:=date();
PX_VER.ADD_TIME:=time();
PX_VER.ADD_WHO:=OPERATOR.USER;
PX_VER.WHATIF:=_whatif;
{? PX_VER.add()
|| _result:=1;
   exec('mod_stamp','px_ver',PX_VER.ref());
   ~~
?};
_result


\delete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC/MBUILDER
::  UTW: WH [12.10]
:: OPIS: Usuwa wersje planu czyli wszystko co wchodzi w sklad danej wersji:
::       - kontenery - PX_KONT
::       - pojemniki - PX_CUP
::       - obiekty grupujace - PX_GRP
::       - polaczenia grupujace - PX_CONN
::       - pozycje planu - PX_POZ
::   WE: _a - PX_VER.ref() - wersja planu ktora ma zostac usunieta
::       [_b] 0 / [1] - nie pyta lub pyta o potwierdzenie
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_ver2del:=_a;
_pyta:=1;
_group:=0;
{? _>1
|| _pyta:=_b
?};
:: dla akcji grupowej nie pytam, bo pytanie jest w grupa przed
{? PX_VER.sel_size()>0
|| _pyta:=0;
   _group:=1
?};

:: sprawdzenie czy wersja nie jest zablokowana
{? ~exec('lock','px_ver',_ver2del,_pyta)
|| return()
?};

:: sprawdzenie czy wersja nie jest wersją główną planu
{? _ver2del=exec('get_mainversion','px_ver')
|| {? _pyta || FUN.emsg('Usuwanie wersji głównej planu niemożliwe.'@) ?};
   return()
?};

::konteksty
PX_VER.cntx_psh();
PX_VER.clear();
PX_KONT.cntx_psh();
PX_GRP.cntx_psh();
PX_CONN.cntx_psh();

::rozpoczynam usuwanie
_can_continue:=1;
{? PX_VER.seek(_ver2del)
|| _ok:=1;
   {? _pyta>0
   || _ok:=FUN.ask('Czy usunąć wersję planu: %1?'@[PX_VER.SYMBOL])
   ?};
   {? _ok>0
   ||
      {? PX_VER.STATUS=exec('status_pending','px_ver')
      || FUN.emsg('Usuwanie wersji aktualnie przeliczanej zabronione.'@)
      ||
::       Sprawdzam czy da sie zablokowac wersje, jesli nie to nie moge usunac
         {? exec('lock','px_ver',PX_VER.ref())>0
         ||
            exec('unlock','px_ver',PX_VER.ref());
::          1. Usuwam kaskadowo kontenery->pojemniki->pozycje planu
            PX_KONT.index('SYM');
            PX_KONT.prefix(_ver2del);
            {? PX_KONT.first()
            || {? _group=0 & _pyta>0
               || FUN.prg_start(PX_KONT.size(),,0)
               ?};
               {!
               |? _can_continue:=exec('delete','px_kont',PX_KONT.ref());
                  {? _group=0 & _pyta>0
                  || FUN.prg_next(1,'Usuwanie wersji...')
                  ?};
                  PX_KONT.first() & _can_continue>0
               !};
               {? _group=0 & _pyta>0
               || FUN.prg_stop()
               ?}
            ?};
::          2. Usuwam kaskadowo obiekty grupujace->polaczenia grupujace
            {? _can_continue>0
            || PX_GRP.index('LP');
               PX_GRP.prefix(_ver2del);
               {? PX_GRP.first()
               || {!
                  |? _can_continue:=exec('delete','px_grp',PX_GRP.ref());
                     PX_GRP.first() & _can_continue>0
                  !}
               ?}
            ?};
::          3. Jesli zostaly jakies polaczenia grupujace nalezace do wersji to je usuwam
::          (czasami zdarzyc sie moze ze z powodu jakiegos bledu PX_CONNy nie sa poprawnie
::          polaczone z PX_GRP i sie nie usuna przy okazji usuwania PX_GRP)
            {? _can_continue>0
            || PX_CONN.index('VER');
               PX_CONN.prefix(_ver2del);
               {? PX_CONN.first()
               || {!
                  |? _can_continue:=exec('delete','px_conn',PX_CONN.ref());
                     PX_CONN.first() & _can_continue>0
                  !}
               ?}
            ?};

::          4. Usuwam skojarzonego PX_TASK
            exec('delete','px_task',PX_VER.ref());

::          5. Usuwam komunikaty
            {? _can_continue>0
            || _can_continue:=exec('del_ver','px_komm',PX_VER.ref())
            ?};

::          6. Usuwam wersje
            {? _can_continue>0
            || _result:=PX_VER.del(,1)
            ?}
         ?}
      ?}
   ?}
?};
:: Konteksty spowrotem
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
PX_KONT.cntx_pop();
PX_VER.cntx_pop();

exec('unlock','px_ver',_ver2del);
~~


\px_ver_del_gr1
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.10]
:: OPIS: Grupa przed usun w tabeli PX_VER, okna: WER
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_ok:=0;
{? FUN.ask('Zaznaczono: %1 wersji planu. Czy usunąć je wszystkie?'@[$PX_VER.sel_size()])
|| _ok:=1
?};
_ok


\clean
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Czysci wersje z wszystkiego oprocz kolejki
::       W praktyce uzywane przed planowaniem wersji - zeby przygotowac wersje pod klonowanie
::   WE: _a - PX_VER.ref() - wersja planu ktora popsprzatac
::       [_b] - _args - argumenty dla funkcji raportujacej progress
::                      wynik dzialania exec('plan_progress_a','px_logix')
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_ver:=_a;
_argsprog:={?_>=2 || _b || exec('plan_progress_a','px_logix') ?};

_can_continue:=1;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

PX_KONT.cntx_psh();
PX_VER.cntx_psh();
PX_VER.clear();
{? PX_VER.seek(_ver)
||
   _msg:='Czyszczenie wersji planu: '+PX_VER.SYMBOL;
   pxkomm.sect_beg(_msg);
:: 1. Usuwam kaskadowo kontenery->pojemniki->pozycje planu
   PX_KONT.index('ACT');
   PX_KONT.prefix('T',_ver);

   {? PX_KONT.first()
   || _argsprog.SIZELOC:=PX_KONT.size();
      _argsprog.STRING:='Czyszczenie...';
      {!
      |?
::       raportuje progress
         _argsprog.PROGLOC+=1;
         _can_continue:=exec('plan_progress','px_logix',_argsprog,1);
         _can_continue:=exec('delete','px_kont',PX_KONT.ref());
         PX_KONT.first() & _can_continue>0
      !}
   ?};
   pxkomm.sect_end()
|| _msg:='Nie znaleziono wersji planu o refie: '+$_ver;
   pxkomm.error(_msg)
?};
{? _can_continue>0
|| _result:=1
?};
PX_KONT.cntx_pop();
PX_VER.cntx_pop();
_result


\clean_queue
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Czysci obiekty grupujace w kolejce ze wszystkich powiazan
::   WE: _a - PX_VER.ref()
::       [_b] - INTEGER - 0/[1] - czy czyscic komunikaty powiazane z elementem kolejki
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ver:=_a;

_komm_del:=1;
{? var_pres('_b')=type_of(0)
|| _komm_del:=_b
?};

PX_VER.cntx_psh();
PX_VER.clear();
PX_GRP.cntx_psh();
{? PX_VER.seek(_ver)
|| PX_GRP.index('LP');
   PX_GRP.prefix(PX_VER.ref());
   {? PX_GRP.first()
   || {!
      |? exec('clean','px_grp',PX_GRP.ref(),0,0,_komm_del);
         PX_GRP.next()
      !}
   ?}
?};
PX_VER.cntx_pop();
PX_GRP.cntx_pop();
~~


\px_ver_temp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Tworzy tymczasowa wersje planu, po to by user mogl od razu edytowac kolejke
::   WE: _a - 0 / [1] 0=nie klonowac kolejki z planu glownego 1=klonowac kolejke z planu glownego
::       [_b] - STRING - 'T'/'N' - czy wersja dla symulacji whatif
::   WY: PX_VER.ref() jesli sukces lub null() jesli porazka
::----------------------------------------------------------------------------------------------------------------------
_result:=null();

_clone:=1;
{? _>0
|| _clone:=_a
?};
_whatif:='N';
{? var_pres('_b')=type_of('')
|| _whatif:=_b
?};

{? PX_VAR.MAINVER<>null()
||
   _symbol:=exec('symbol_temp','px_ver');
   {? _whatif='T'
   || _symbol:=exec('symbol_whatif','px_ver')
   ?};
   _ok:=exec('px_ver_add','px_ver', _symbol,
                                    date(),
                                    time(),
                                    PX_VAR.MAINVER().ENDD().DATA,
                                    PX_VAR.MAINVER().ENDT,
                                    0,
                                    exec('status_temp','px_ver'),
                                    _whatif
                                    );
   {? _ok>0
   || _result:=PX_VER.ref();
::    jesli sie udalo dodanie tymczasowej wersji to klonuje kolejke z wersji glownej do tymczasowej
      {? _clone>0
      || exec('clone_all','px_grp',PX_VAR.MAINVER,PX_VER.ref())
      ?}
   ?}
?};
_result


\ver_stmp_trig
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Trigger przed add() i przed put() w tabeli PX_VER. Automatycznie nawija pola:
::       PX_VER.TM_START i PX_VER.TM_END
::----------------------------------------------------------------------------------------------------------------------
PX_VER.TM_START:=tm_stamp( PX_VER.STARTD().DATA~1,
                           DATY.DATA~2,
                           DATY.DATA~3,
                           PX_VER.STARTT~1,
                           PX_VER.STARTT~2,
                           PX_VER.STARTT~3,
                           0);
PX_VER.TM_END:=tm_stamp(   PX_VER.ENDD().DATA~1,
                           DATY.DATA~2,
                           DATY.DATA~3,
                           PX_VER.ENDT~1,
                           PX_VER.ENDT~2,
                           PX_VER.ENDT~3,
                           0);
1


\status_new
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca status wersji - nowa
::       UWAGA! - Uzywana jako blank pola PX_VER.STATUS
::   WY: STRING[20]
::----------------------------------------------------------------------------------------------------------------------
'NOWA'


\status_todo
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca status wersji - do przeliczenia
::   WY: STRING[20]
::----------------------------------------------------------------------------------------------------------------------
'DO PRZELICZENIA'


\status_pending
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca status wersji - aktualnie przeliczana
::   WY: STRING[20]
::----------------------------------------------------------------------------------------------------------------------
'PRZELICZANA...'


\status_ready
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca status wersji - przeliczona
::   WY: STRING[20]
::----------------------------------------------------------------------------------------------------------------------
'PRZELICZONA'


\status_accepted
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca status wersji - zaakceptowana
::   WY: STRING[20]
::----------------------------------------------------------------------------------------------------------------------
'ZATWIERDZONA'


\status_acceptin
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca status wersji - zatwierdzana
::   WY: STRING[20]
::----------------------------------------------------------------------------------------------------------------------
'ZATWIERDZANA...'


\status_temp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca status wersji - tymczasowa
::   WY: STRING[20]
::----------------------------------------------------------------------------------------------------------------------
'TYMCZASOWA'


\status_cloning
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca status wersji - klonowana
::   WY: STRING[20]
::----------------------------------------------------------------------------------------------------------------------
'KLONOWANA...'


\status_cloned
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca status wersji - sklonowana
::   WY: STRING[20]
::----------------------------------------------------------------------------------------------------------------------
'SKLONOWANA'


\status_sim_zkp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca status wersji - symulacja zamowienia
::   WY: STRING[20]
::----------------------------------------------------------------------------------------------------------------------
'SYMULACJA ZAMÓWIENIA'


\status_sim_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Zwraca status wersji - symulacja zlecenia
::   WY: STRING[20]
::----------------------------------------------------------------------------------------------------------------------
'SYMULACJA ZLECENIA'


\status_que_copy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca status wersji - kopia kolejki
::   WY: STRING[20]
::----------------------------------------------------------------------------------------------------------------------
'KOPIA KOLEJKI'


\mainversion_vie
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Sprawdza, czy wersja wyswietlana planu jest wersja glowna
::----------------------------------------------------------------------------------------------------------------------
PX_VAR.VIE_VER=PX_VAR.MAINVER


\px_ver_ses_id
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.10]
:: OPIS: Blank pola PX_VER.SES_ID
::   WY: STRING[11] - identyfikator sesji
::----------------------------------------------------------------------------------------------------------------------
PX_VER.ses_id()


\garbage
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Czysci wersje ze smieci. Sa dwa rodzaje smieci:
::       1. Wersje polowicznie sklonowane
::          Klonujac wersje zakladany jest lock na wersje docelowa i status wersji exec('status_cloning','px_ver')
::          Jesli klonowanie sie nie powiedzie to ten status pozostanie na wersji. Poniewaz klonowanie
::          nie jest robione w transakcji (dlugi proces) trzeba taka wersje sprzatnac
::       2. Wersje tymczasowe, ktore powstaly w sesjach ktore juz sa nieaktywne
::          Zalozenie jest takie ze wersja tymczasowa powinna zostac usunieta po wyjsciu z okna planu glownego,
::          ale jesli uzytkownik zamknie program bedac w planie glownym wersja tymczasowa pozostanie
::          Z tego wzgledu powstala ta funkcja - sprzata smieci ktore mogly pozostac
::----------------------------------------------------------------------------------------------------------------------
PX_VER.cntx_psh();
PX_VER.index('STATUS');

:: 1. Czyszcze tymczasowe wersje planu
PX_VER.prefix(0,exec('status_temp','px_ver'));
_can_continue:=0;
{? PX_VER.first()
|| {!
   |?
::    sprawdzam czy sesja w ktorej utworzono wersje planu tymczasowa jest jeszcze aktywna - jesli nie to usuwam wersje
      _deleted:=0;
      {? PX_VER.ses_info(PX_VER.SES_ID,'exist')=0
      || _deleted:=exec('delete','px_ver',PX_VER.ref(),0)
      ?};
      _can_continue:={? _deleted=2 | _deleted=3
                     || _can_continue:=1
                     || PX_VER.next()
                     ?};
      _can_continue>0
   !}
?};

:: 2. Czyszcze nie do konca sklonowane wersje planu ktore mogly pozostac w wyniku bledu
PX_VER.prefix(0,exec('status_cloning','px_ver'));
{? PX_VER.first()
||
   {!
   |? _deleted:=0;
::    jesli sie da zablokowac, to znaczy ze mozna usunac bo to smiec
      {? exec('lock','px_ver',PX_VER.ref())>0
      || exec('unlock','px_ver',PX_VER.ref());
         _deleted:=exec('delete','px_ver',PX_VER.ref(),)
      ?};
      _can_continue:={? _deleted=2 | _deleted=3
                     || _can_continue:=1
                     || PX_VER.next()
                     ?};
      _can_continue>0
   !}
?};

PX_VER.cntx_pop();
~~


\clone_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Tablica parametrow dla clone
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('SOURCE',
               'DEST',
               'TM_START',
               'TM_END',
               'MODE',
               'GRP',
               'STARTMOD',
               'ACCEPTIN'
               );
_args.SOURCE:=null();
_args.DEST:=null();
_args.TM_START:=0;
_args.TM_END:=0;

:: 0 - nie klonuje PX_GRP
:: 1 - klonuje PX_GRP
_args.GRP:=0;

:: 0 - nie klonuje zadnych pozycji planu, ale klonuje zajete pojemnosci pojemnika
:: 1 - klonuje tylko zablokowane pozycje planu, pojemnosci pojemnikow ustawia na nowo
:: 2 - klonuje wszystkie pozycje planu i pojemnosci pojemnikow
_args.MODE:=0;

:: 'NASTEPNY POJEMNIK' - pierwszym pojemnikiem w sklonowanych kontenerach jest nastepny pojemnik po TM_START
:: 'AKTUALNY POJEMNIK' - pierwszym pojemnikiem w sklonowanych kontenerach jest pojemnik trwajacy w TM_START
_args.STARTMOD:=exec('start_nextcup','px_param');
:: czy klonowanie jest wynikiem akceptacji - ma wplyw na klonowanie kontenerow
_args.ACCEPTIN:='N';
_args


\clone
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Kopiuje kontenery z jednej wersji planu do drugiej
::   WE: _a - _args  - argumenty funkcji wynik dzialania exec('clone_a','px_ver')
::       [_b] - _args - argumenty dla funkcji raportujacej progress
::                      wynik dzialania exec('plan_progress_a','px_logix')
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_args:={? _>=1 || _a || exec('clone_a','px_ver') ?};
_argsprog:={? _>=2 || _b || exec('plan_progress_a','px_logix') ?};
_result:=0;

PX_VER.cntx_psh();
PX_KONT.cntx_psh();

PX_GRP.clear();
PX_VER.clear();
_can_continue:=1;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

{? PX_VER.seek(_args.SOURCE)
||
   _msg:='Duplikowanie wersji źródłowej: '+PX_VER.SYMBOL;
   pxkomm.sect_beg(_msg);
:: sprawdzam czy mozna zablokowac wersje zrodlowa i docelowa
   {? exec('lock','px_ver',_args.SOURCE)>0 & exec('lock','px_ver',_args.DEST)>0
   ||
::    wersji docelowej ustawiam status ze jest klonowana - jesli nie zdejme tego statusu po sklonowaniu
::    to ta wersja zostanie automatycznie posprzatana
      exec('status_set','px_ver',_args.DEST,exec('status_cloning','px_ver'),0);

::    klonowanie PX_GRP
      {? _args.GRP=1
      ||
::       przed sklonowaniem obiektow grupujacych musze przepiac wszystkie pozycje
::       planu opoznione, wykonywane i wykonane z wersji docelowej do źrodlowej
::       po to aby klonowanie kolejki nie wycielo tych pozycji planu w wersji docelowej

::       Robie to tylko w przypadku gdy takiej pozycji planu nie ma w biezacej wersji - zapewnia to granica czasowa
::       (nie przeszla do przeliczanej wersji w trakcie klonowania pojemnikow)

::       czyli teraz przepinam pozycje z wersji glownej do wersji przeliczonej ktorej kolejka
::       zaraz bedzie kolejka wersji glownej
::       1. Zablokowane pozycje planu
         exec('px_poz_move','px_grp',_args.DEST,_args.SOURCE,exec('status_blk','px_poz'),_args.TM_START);
::       2. Wykonane pozycje planu
         exec('px_poz_move','px_grp',_args.DEST,_args.SOURCE,exec('status_wyk2','px_poz'),_args.TM_START);
::       3. Wykonywane pozycje planu
         exec('px_poz_move','px_grp',_args.DEST,_args.SOURCE,exec('status_wyk1','px_poz'),_args.TM_START);
::       4. Porzucone pozycje planu
         exec('px_poz_move','px_grp',_args.DEST,_args.SOURCE,exec('status_skipped','px_poz'),_args.TM_START);
         _can_continue:=exec('clone_all','px_grp',_args.SOURCE,_args.DEST,1,_args.TM_START,0)
      ?};
      {? _can_continue>0
      ||
::       klonuje kontenery
         PX_KONT.index('ACT');
         PX_KONT.prefix('T',_args.SOURCE);
         _argsprog.STRING:='Duplikowanie zasobów';
         _argsprog.SIZELOC:=PX_KONT.size();

         _argskont:=exec('clone_a','px_kont');
         _argskont.PX_VER:=_args.DEST;
         _argskont.MODE:=_args.MODE;
         _argskont.STARTMOD:=_args.STARTMOD;
         _argskont.ACCEPTIN:=_args.ACCEPTIN;

::       poczatek klonowania dla kontenerow widokowych - wspolny w obrebie calej wersji
         _cws:=0;
::       koniec klonowania dla kontenerow widokowych - wspolny w obrebie calej wersji
         _cwe:=0;
::       tabelka tymczasowa zawierajaca poczatki klonowania dla kontenerow rzeczywistych
         _crs:=tab_tmp(  1,
                           'REF','STRING[16]','Ref SQL kontenera',
                           'CLONE_S','REAL','Poczatek klonowania dla kontenera');
::       tabelka tymczasowa zawierajaca konce klonowania dla kontenerow rzeczywistych
         _cre:=tab_tmp(  1,
                           'REF','STRING[16]','Ref SQL kontenera',
                           'CLONE_E','REAL','Koniec klonowania dla kontenera');

::       !!!Okreslam granice czasowe klonowania kontenerów!!!
         {? PX_KONT.first()
         ||
            {!
            |?
::             Mozliwe sa dwa przypadki:
::             1. _args.ACCEPTIN='N' - granice klonowania pojemnikow sa brane z argumentow funkcji, ale sa zaokraglane
::                                     (ten przypadek wystepuje podczas przygotowania kontenerow do zaplanowania)
::             2. _args.ACCEPTIN='T' - granice klonowania sa wyznaczane przez zawartosc kontenera zrodlowego
::                                     dlatego to jest tak zrobione aby podczas akceptacji program nie zzeral pojemnikow,
::                                     wtedy jest gwarancja ze pojemniki w wersji docelowej zostana zastapione pojemnikami
::                                     z wersji zrodlowej
::                                     (ten przypadek wystepuje podczas akceptacji planu)
               _r_start:=0;
               _r_end:=0;
               {? _args.ACCEPTIN='N'
               ||
                  _r_start:=_args.TM_START;
                  _r_end:=_args.TM_END;
::                Zaokraglenie granic czasowych klonowania do czasow pojemnikow rzeczywistych,
::                ktore przecinaja te granice - zrobione jest to po to by sklonowaly sie wszystkie pojemniki
::                rzeczywiste i odpowiadajace im widokowe (bez zaokraglenia mogloby zabraknac widokowych)
                  {? _r_start>0
                  || _clone_mode:='';
                     {? _args.STARTMOD=exec('start_nextcup','px_param')
                     || _clone_mode:='START_NEXT'
                     |? _args.STARTMOD=exec('start_curcup','px_param')
                     || _clone_mode:='START'
                     ?};
                     _r_start:=exec('round_time','px_kont',PX_KONT.ref(),_r_start,_clone_mode)
                  ?};
                  {? _r_end>0
                  || _r_end:=exec('round_time','px_kont',PX_KONT.ref(),_r_end,'END')
                  ?}
               |? _args.ACCEPTIN='T'
               || _r_start:=exec('get_start','px_kont',PX_KONT.ref());
                  _r_end:=exec('get_end','px_kont',PX_KONT.ref())
               ?};

::             Jesli start pozniej niz koniec to musze odwrocic start i koniec zeby sie dobrze sklonowalo
               {? _r_end>0 & _r_start>_r_end
               || _tmp1:=_r_start;
                  _tmp2:=_r_end;

                  _r_start:=_tmp2;
                  _r_end:=_tmp1
               ?};

::             dodaje do tabelek z granicami klonowania dla kontenerow wyznaczone czasy
               _crs.blank();
               _crs.REF:=$PX_KONT.ref();
               _crs.CLONE_S:=_r_start;
               _crs.add();

               _cre.blank();
               _cre.REF:=$PX_KONT.ref();
               _cre.CLONE_E:=_r_end;
               _cre.add();


::             granice czasowe klonowania kontenerow widokowych sa wspolne tak ze:
::             start - jest najmniejszym startem w calej wersji
::             koniec - jest najwiekszym koncem w calej wersji
               {? _cws=0 | _r_start<_cws
               || _cws:=_r_start
               ?};
               {? _cwe=0 | _r_end>_cwe
               || _cwe:=_r_end
               ?};
               PX_KONT.next()
            !}
         ?};

         _lenght:=_cwe-_cws;
         {? _lenght=0
         || _msg0:='';
            _msg1:='Planowana wersja ma zerową długość czasową, więc nie będzie przeliczana.';
            _msg2:='Sytuacja taka występuje, jeżeli wszystkie elementy kolejki są planowane w tył ';
            _msg3:='oraz ich granice czasowe są wcześniej niż początek planowanej wersji.';
            _msg4:='Aby przeliczyć taką wersję, należy zredagować kolejkę i poprawić granice ';
            _msg5:='czasowe na co najmniej jednym elemencie.';
            _msg6:='Start wersji: '+tm_form(_cws);
            _msg7:='Koniec wersji: '+tm_form(_cwe);
            _msg_glued:=exec('form','#string','L'
                                             ,_msg1
                                             ,_msg2
                                             ,_msg3
                                             ,_msg4
                                             ,_msg5
                                             ,_msg0
                                             ,_msg6
                                             ,_msg7);
            FUN.emsg(_msg_glued);
            _can_continue:=0
         ?}
      ?};

      {? _can_continue>0 & PX_KONT.first()
      ||
         {!
         |?

::          1. KLONOWANIE KONTENERA RZECZYWISTEGO

::          Pobieram granice klonowania z wyliczonej wczesniej tabelki
            _crs.prefix($PX_KONT.ref());
            {? _crs.first()
            || _argskont.TM_START:=_crs.CLONE_S
            || _argskont.TM_START:=0
            ?};
            _cre.prefix($PX_KONT.ref());
            {? _cre.first()
            || _argskont.TM_END:=_cre.CLONE_E
            || _argskont.TM_END:=0
            ?};
            _argskont.SOURCE:=PX_KONT.ref();
            _can_continue:=exec('clone','px_kont',_argskont);

::          raportuje progress
            {? _can_continue>0
            || _argsprog.PROGLOC+=1;
               _can_continue:=exec('plan_progress','px_logix',_argsprog,1)
            ?};
            PX_KONT.next() & _can_continue>0
         !}
      ?};

::    jesli wersja docelowa jest glowna to PX_OBJtom nawijam pola PX_OBJ.PLANENDD i PX_OBJ.PLANENDT
      {? _args.DEST=exec('get_mainversion','px_ver')
      || PX_CONN.cntx_psh();
         PX_CONN.index('VER');
         PX_CONN.prefix(_args.DEST);
         {? PX_CONN.first()
         || {!
            |? exec('planend_refresh','px_obj',PX_CONN.PX_OBJ);

::             Aktualizacja pola ZL.PLAN_PX
               {? PX_CONN.PX_OBJ().ZL<>null()
               || PX_CONN.PX_OBJ().ZL().PLAN_PX:='T';
                  _top:=exec('top_level','zl_link',PX_CONN.PX_OBJ().ZL);
                  {? _top<>PX_CONN.PX_OBJ().ZL
                  || ZL.cntx_psh(); ZL.prefix();
                     {? ZL.seek(_top)
                     || ZL.PLAN_PX:='T';
                        ZL.put()
                     ?};
                     ZL.cntx_pop()
                  ?}
               ?};
               PX_CONN.next()
            !}
         ?};
         PX_CONN.cntx_pop()
      ?};

::    ustawiam status wersji docelowej na 'sklonowana'
      {? _can_continue>0
      || exec('status_set','px_ver',_args.DEST,exec('status_cloned','px_ver'),100)
      ?};

::    po klonowaniu ustawiam wersji docelowej wlasciwy zakres dat wg zawartosci
      {? _can_continue>0
      || exec('dates_recreate','px_ver',_args.DEST)
      ?};
::    oblokowuje werjse planu
      exec('unlock','px_ver',_args.SOURCE);
      exec('unlock','px_ver',_args.DEST)
   || _msg:='Duplikowanie - nie udało się zablokować wersji źródłowej lub docelowej.';
      pxkomm.error(_msg);
      _can_continue:=0
   ?};
   pxkomm.sect_end()
|| _msg:='Nie znaleziono wersji do duplikowania: '+$_args.SOURCE;
   pxkomm.error(_msg);
   _can_continue:=0
?};
{? _can_continue>0
|| _result:=1
?};

PX_VER.cntx_pop();
PX_KONT.cntx_pop();
_result


\lock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Blokada wersji planu ( PX_VER.r_lock(1,1,1) )
::   WE: [_a] - PX_VER.ref(), a jak brak parametru, to ustawiony rekord w tabeli PX_VER
::       [_b] - czy wyswietlac dialogi (domyslnie 1 - wyswietlac)
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _px:=_a
|| _px:=PX_VER.ref()
?};

{? var_pres('_b')=type_of(0)
|| _display:=_b
|| _display:=1
?};

_ok:=0;
BLK.index('AMR');
BLK.prefix('PX_VER',8+$_px,#_px);
{? ~BLK.first()
|| BLK.ACR:='PX_VER';
   BLK.MSK:=PX_VER.name();
   BLK.REF:=_px;
   BLK.SES_ID:=PX_VER.ses_id();
   _ok:=BLK.add()
|| _ok:=1
?};
{? _ok
|| {? BLK.r_lock(1,1,1)
   || BLK.SES_ID:=PX_VER.ses_id();
      _ok:=BLK.put()
   || _msg:='Wersja planu jest redagowana przez użytkownika "%1" na terminalu "%2"'@
            [KAL_UD.ses_info(BLK.SES_ID,'log_name'),KAL_UD.ses_info(BLK.SES_ID,'log_tty')];
      {? _display=1
      || FUN.emsg(_msg)
      |? _display=2
      || KOMM.add(_msg,2,,1)
      ?};
      _ok:=0
   ?}
?};
_ok


\unlock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Usuniecie blokady wersji planu ( PX_VER.r_unlock() )
::   WE: _a - PX_VER.ref(), a jak brak parametru, to ustawiony rekord w tabeli PX_VER
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_px:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _px:=_a
|| _px:=PX_VER.ref()
?};
BLK.index('AMR');
BLK.prefix('PX_VER',8+$_px,#_px);
{? BLK.first()
|| {? PX_VER.ses_id()=BLK.SES_ID
   || BLK.r_unlock();
      BLK.del()
   ?}
?};
~~


\symbol_real
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca symbol dla przeliczanych wersji planu
::   WE: _a - PX_VER.ref() - wersja planu dla ktorej wygenerowac symbol
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_ver:=_a;

PX_VER.cntx_psh();
PX_VER.clear();
{? PX_VER.seek(_ver)
||
:: buduje symbol na podstawie granic czasowych wersji
   _result:=$PX_VER.STARTD().DATA+' '+$PX_VER.STARTT;
   _result+=' - '+$PX_VER.ENDD().DATA+' '+$PX_VER.ENDT
?};
PX_VER.cntx_pop();
_result


\symbol_temp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca symbol dla tymczasowych wersji planu
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'Tymczasowa - %1'@[$date()+' '+$time()+' '+OPERATOR.USER().DANE]


\symbol_copy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Zwraca symbol dla kopii kolejki planu
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'Kopia - %1'@[$date()+' '+$time()+' '+OPERATOR.USER().DANE]


\symbol_whatif
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [23.25]
:: OPIS: Zwraca symbol dla wersji planu będących symulacją whatif
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'Symulacja whatif - %1'@[$date()+' '+$time()+' '+OPERATOR.USER().DANE]


\accept
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Akceptuje wersje planu
::   WE: _a - PX_VER.ref()
::       [_b] - 0 / [1] - pytac czy nie pytac o potwierdzenie
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ver:=_a;
_pyta:=1;
_mainver:=exec('get_mainversion','px_ver');
_result:=0;

_can_continue:=0;
_start:=0;

PX_VER.cntx_psh();
PX_VER.clear();
{? PX_VER.seek(_ver)
||
   _confirmed:=1;
   {? _pyta>0
   || _confirmed:=FUN.ask(
         'Czy zaakceptować wyświetlaną wersję planu?\n\n'
         '• Zawartość wyświetlanej wersji planu (symulacji)\n'
         '  zostanie naniesiona na główną wersję planu.'@)
   ?};
   {? _confirmed>0
   ||
::    przed akceptacja planu sprawdzam czy w miedzy czasie ktos inny nie zaakceptowal planu
      _mod_chk:=exec('mod_chk','px_ver',_mainver,_ver);
      {? _mod_chk>0
      || _can_continue:=1
      |? _mod_chk=0
      || _can_continue:=exec('mod_warn','px_ver',_mainver,_ver)
      |? _mod_chk<0
      || _can_continue:=0;
         FUN.emsg('Porównanie czasu modyfikacji wersji zakończone niepowodzeniem. Przerwanie planowania.'@)
      ?};

      {? _can_continue>0
      ||
::       przed akceptacja planu regeneruje zakres dat na wersji - po to by na pewno zakres odpowiadal zawartosci
         exec('dates_recreate','px_ver',_ver);
         PX_VER.get();

         _start:=PX_VER.TM_START;
         _end:=PX_VER.TM_END;
         _argsprog:=exec('plan_progress_a','px_logix');
         _argsprog.PX_VER:=PX_VER.ref();
         _argsprog.MODE:=2;
         _argsprog.SIZEALL:=1000;
         _argsprog.PHASES:=1;
         _argsprog.PHASE:=1;

         _clone_size:=exec('task_size_clone','px_logix',_ver);
         _pxpoz_size:=exec('task_size_pxpoz','px_logix',_ver);
         _pxcon_size:=exec('task_size_pxcon','px_logix',_ver);

::       Inicjuje multiprogress
         {? _argsprog.MODE=2
         || {? _clone_size>0
            || _argsprog.MULTI.add_progress('Nanoszenie zmian na wersję główną planu'@,_clone_size);
               _argsprog.MULTI.add_progress('Nanoszenie zapotrzebowań do bufora planu dostaw'@,_pxpoz_size);
               _argsprog.MULTI.add_progress('Nanoszenie terminów na obiekty źródłowe'@,_pxcon_size);
::             Podczas akceptacji musze wyszarzyc przycisk 'Przerwij'
               _argsprog.MULTI.BREAK_ON:='N'
            ?}
         ?};

::       blokuje wersje
         {? exec('lock','px_ver',_ver)>0 & exec('lock','px_ver',_mainver)>0
         ||
            {? _argsprog.MODE=1
            || FUN.prg_start(100,,0)
            |? _argsprog.MODE=2
            || exec('start','#progress',_argsprog.MULTI);
               _argsprog.MULTI.next_phase()
            ?};
::          W wersji docelowej usuwam wszystkie komunikaty dotyczace przeliczenia planu
::          te komunikaty zostana sklonowane z przeliczonej wersji (o ile jakies są)
            _src_kom:=exec('src_plan_prefix','px_komm');
            _typ1:=exec('type_error','px_komm');
            _typ2:=exec('type_warning','px_komm');
            _typ3:=exec('type_info','px_komm');
            exec('del_kommy','px_komm','PX_VER',_mainver,_typ1,_src_kom);
            exec('del_kommy','px_komm','PX_VER',_mainver,_typ2,_src_kom);
            exec('del_kommy','px_komm','PX_VER',_mainver,_typ3,_src_kom);

::          ustawiam statusy obu wersji...
            exec('status_set','px_ver',_mainver,exec('status_acceptin','px_ver'),0);
            exec('status_set','px_ver',_ver,exec('status_acceptin','px_ver'),0);

::          uruchamiam klonowanie wersji
            _argsclone:=exec('clone_a','px_ver');
            _argsclone.SOURCE:=_ver;
            _argsclone.DEST:=_mainver;
            _argsclone.TM_START:=_start;
            _argsclone.TM_END:=_end;
            _argsclone.MODE:=2;
            _argsclone.GRP:=1;
            _argsclone.ACCEPTIN:='T';

::          akceptacja zawsze od poczatkowego pojemnika wersji
            _argsclone.STARTMOD:=exec('start_curcup','px_param');
            _result:=exec('clone','px_ver',_argsclone,_argsprog);

            _argsprog.PHASE:=2;
            _argsprog.PROGLOC:=0;
            {? _argsprog.MODE=2
            || _argsprog.MULTI.next_phase()
            ?};

::          Ponowne generowanie zapisow do planu zamowien dostaw
            exec('generuj_ver','px_sur',_mainver,_argsprog);

            _argsprog.PHASE:=3;
            _argsprog.PROGLOC:=0;
            {? _argsprog.MODE=2
            || _argsprog.MULTI.next_phase()
            ?};

::          aktualizacja terminow na obiektach zrodlowych
            exec('src_obj_act','px_plan',_mainver,_argsprog);

::          klonuje komunikaty z przeliczonej wersji do glownej
            _argskomm:=exec('clone_a','px_komm');
            _argskomm.PX_VER:=_mainver;
            exec('clone_ver','px_komm',_ver,_argskomm);

::          ustawiam statusy obu wersji...
            exec('status_set','px_ver',_mainver,exec('status_accepted','px_ver'),100);
            exec('status_set','px_ver',_ver,exec('status_accepted','px_ver'),100);

::          po akceptacji nawijam wersji glownej nowe granice czasowe - bo wersja moze miec inny zestaw pojemnikow
            exec('dates_recreate','px_ver',_mainver);

::          gasze progress
            {? _argsprog.MODE=1
            || FUN.prg_stop()
            |? _argsprog.MODE=2
            || exec('stop','#progress',_argsprog.MULTI)
            ?};

            {? _result>0
            ||
::             jesli akceptacja sie udala to na wersji glownej ustawiam czas i uzytkownika ktory
::             zmodyfikowal wersje
               exec('mod_stamp','px_ver',_mainver);

::             Usuwam komunikaty dotyczace koniecznosci przeliczenia planu
               _type:=exec('type_warning','px_komm');
               _src:=exec('src_refresh_que','px_komm');
               exec('del_kommy','px_komm','PX_VER',_mainver,_type,_src)
            ?};

::          wykonuje formule wdrozeniowa, po akceptacji wersji planu
            exec('ver_accepted','px_prepq',PX_VER.ref());

::          odblokowuje wersje planu
            exec('unlock','px_ver',_ver);
            exec('unlock','px_ver',_mainver)
         ?}
      ?}
   ?}
?};
PX_VER.cntx_pop();
{? _result
|| sel_exit()
?};
_result


\status_set
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Ustawia status dla wersji
::   WE: _a - PX_VER.ref
::       _b - STRING[20] - status: wynik dzialania funkcji exec('status...','px_ver')
::       [_c] - REAL - opcjonalnie progress - jesli nie podany to nie ustawiany
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ver:=_a;
_status:=_b;
_prog_set:=0;
_prog:=0;
{? _>2
|| _prog_set:=1;
   _prog:=_c
?};

_result:=0;

PX_VER.cntx_psh();
PX_VER.clear();
{? PX_VER.seek(_ver)
|| PX_VER.STATUS:=_status;
   {? _prog_set>0
   || PX_VER.PROGRESS:=_prog
   ?};
   _result:=PX_VER.put()
?};
PX_VER.cntx_pop();
_result


\dates_recreate
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Podanej wersji planu odswieza granice czasowe na podstawie pojemnikow ktore zawiera wersja
::   WE: _a - PX_VER.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------

_ver:=_a;
_result:=0;
PX_VER.cntx_psh();
PX_CUP.cntx_psh();
PX_KONT.cntx_psh();
PX_KONT.index('ACT');
PX_VER.clear();
_start:=0;
_end:=0;
_startd:=null();
_startt:=time(0,0,0);
_endd:=null();
_endt:=time(0,0,0);
{? PX_VER.seek(_ver)
||
:: Robie petle po kontenerach wylacznie rzeczywistych i aktywnych
   PX_KONT.prefix('T',PX_VER.ref());
   {? PX_KONT.first()
   ||
      {!
      |? PX_CUP.index('TM_START');
         PX_CUP.prefix(PX_KONT.ref());
::       Musze znalezc pierwszy pojemnik o niezerowym czasie startu, jezeli w bazie
::       bylby popsuty pojemnik z zerowym czasem, to zawsze psulby zawsze cala wersje planu
         {? PX_CUP.find_ge(1)
         || {? _start=0 | PX_CUP.TM_START<_start
            || _start:=PX_CUP.TM_START;
               _startd:=PX_CUP.STARTD;
               _startt:=PX_CUP.STARTT
            ?}
         ?};
         PX_CUP.index('TM_END');
         PX_CUP.prefix(PX_KONT.ref());
         {? PX_CUP.last()
         || {? _end=0 | PX_CUP.TM_END>_end
            || _end:=PX_CUP.TM_END;
               _endd:=PX_CUP.ENDD;
               _endt:=PX_CUP.ENDT
            ?}
         ?};
         PX_KONT.next()
      !}
   ?};
   PX_VER.STARTD:=_startd;
   PX_VER.STARTT:=_startt;
   PX_VER.ENDD:=_endd;
   PX_VER.ENDT:=_endt;
   _result:=PX_VER.put()
?};
PX_CUP.cntx_pop();
PX_VER.cntx_pop();
PX_KONT.cntx_pop();
_result


\stat_set_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBIUILDER
::  UTW: WH [12.10]
:: OPIS: Akcja 'Zmien status' w tabeli PX_VER, okna wertowania: WER
::----------------------------------------------------------------------------------------------------------------------
{? exec('lock','px_ver')>0
||
   _choice:=FUN.choice('Zmień status na: '@,,'Zatwierdzony'@,'Tymczasowy'@);
   {? _choice=1
   || PX_VER.STATUS:=exec('status_accepted','px_ver');
      PX_VER.put()
   |? _choice=2
   || PX_VER.STATUS:=exec('status_temp','px_ver');
      PX_VER.put()
   ?};
   exec('unlock','px_ver')
?};
~~


\px_ver_rkprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed rekord w oknie PX_VER.WER
::----------------------------------------------------------------------------------------------------------------------
~~


\px_ver_legenda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Legenda w oknie PX_VER.WER
::----------------------------------------------------------------------------------------------------------------------
~~


\px_plan_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja planu/symulacji z poziomu okna PX_VER.WER
::----------------------------------------------------------------------------------------------------------------------
{? PX_VER.STATUS=exec('status_cloning','px_ver')
|| FUN.emsg('Wersja w trakcie duplikowania — nie można wyświetlić.'@)
|? PX_VER.STATUS=exec('status_acceptin','px_ver')
|| FUN.emsg('Wersja w trakcie zatwierdzania — nie można wyświetlić.'@)
|? PX_VER.STATUS=exec('status_pending','px_ver')
|| FUN.emsg('Wersja w trakcie przeliczania — nie można wyświetlić.'@)
|? PX_VER.STATUS=exec('status_temp','px_ver')
|| FUN.emsg('Wersja tymczasowa — nie można wyświetlić.'@)
|? PX_VER.STATUS=exec('status_que_copy','px_ver')
|| FUN.emsg('Kopia kolejki — nie można wyświetlić.'@)
|| _one_version:=exec('is_one_version','px_param');
   exec('select','px_plan',PX_VER.ref(),,-1,'VER',_one_version)
?};
~~


\mod_stamp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Oznacza wersje jako zmodyfikowana - stempluje ja aktualnym czasem i uzytkownikiem
::   WE: _a - PX_VER.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ver:=_a;
_result:=0;

PX_VER.cntx_psh();
PX_VER.clear();
{? PX_VER.seek(_ver)
|| PX_VER.MOD_USER:=OPERATOR.USER;
   PX_VER.MOD_TM:=PX_VER.tm_stamp();
   _result:=PX_VER.put()
?};
PX_VER.cntx_pop();
PX_VER.get();
_result


\mod_stamp_queue
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Oznacza kolejke wersji jako zmodyfikowana - stempluje ja aktualnym czasem i uzytkownikiem
::   WE: _a - PX_VER.ref() - wersja ktora oznaczyc
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ver:=_a;
_result:=0;
PX_VER.cntx_psh();
PX_VER.clear();
{? PX_VER.seek(_ver)
|| PX_VER.MOD_USRQ:=OPERATOR.USER;
   PX_VER.MOD_TM_Q:=PX_VER.tm_stamp();
   _result:=PX_VER.put()
?};
PX_VER.cntx_pop();
PX_VER.get();
_result


\mod_chk_queue
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Porownuje czas modyfikacji wersji z czasem modyfikacji kolejki
::   WE: _a - PX_VER.ref
::   WY: 0 - kolejka zostala zmodyfikowana pozniej niz wersja - moze
::           to oznaczac ze wersja nie zostala jeszcze przeliczona
::       1 - wersja zostala zmodyfikowana pozniej niz kolejka, wiec zawiera w sobie modyfikacje
::           kolejki
::----------------------------------------------------------------------------------------------------------------------
_ver:=_a;
_result:=1;

PX_VER.cntx_psh();
PX_VER.clear();
{? PX_VER.seek(_ver)
||
   {? PX_VER.MOD_TM_Q>0
   ||
      {? PX_VER.MOD_TM_Q>PX_VER.MOD_TM
      || _result:=0
      ?}
   ?}
?};
PX_VER.cntx_pop();
_result


\mod_chk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Porownuje czas modyfikacji dwoch wersji planu
::   WE: _a - PX_VER.ref() - wersja wazniejsza (wersja glowna)
::       _b - PX_VER.ref() - wersja tymczasowa (przeliczana)
::   WY:  1 - wersja wazniejsza zostala zmodyfikowana przed utworzeniem tymczasowej - jest ok
::        0 - wersja wazniejsza zostala zmodyfikowana po utworzeniu tymczasowej - mozliwy konflikt
::       -1 - powstal jakis blad (np. nie znaleziono wersji)
::----------------------------------------------------------------------------------------------------------------------
_ver1:=_a;
_ver2:=_b;
_result:=-1;
USERS.cntx_psh();
PX_VER.cntx_psh();
PX_VER.clear();

_mod1:=0;
_mod2:=0;
_user1:=null();
_user2:=null();

{? PX_VER.seek(_ver1)
|| _mod1:=PX_VER.MOD_TM;
   _user1:=PX_VER.MOD_USER().DANE;

   {? PX_VER.seek(_ver2)
   || _mod2:=PX_VER.MOD_TM;
      _user2:=PX_VER.MOD_USER().DANE
   ?};

   {? _mod1>_mod2
   || _result:=0
   |? _mod1<_mod2
   || _result:=1
   |? _mod1=_mod2
   || _result:=1
   ?}
?};
PX_VER.cntx_pop();
USERS.cntx_pop();
_result


\mod_warn
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Wyswietla zapytanie o mozliwym konflikcie wersji
::   WE: _a - PX_VER.ref() - wersja wazniejsza (wersja glowna)
::       _b - PX_VER.ref() - wersja tymczasowa (przeliczana)
::   WY:  0 - uzytkownik sie przestraszyl komunikatu i nie chce dalej kontynuowac
::        1 - uzytkownik jest twardzielem i kontynuuje nadpisujac komus modyfikacje
::       -1 - powstal jakis blad (np. nie znaleziono wersji)
::----------------------------------------------------------------------------------------------------------------------
_ver1:=_a;
_ver2:=_b;
_result:=-1;
USERS.cntx_psh();
PX_VER.cntx_psh();
PX_VER.clear();

_mod1:=0;
_mod2:=0;
_user1:=null();
_user2:=null();
_ver_n1:='';
_ver_n2:='';

{? PX_VER.seek(_ver1)
|| _mod1:=PX_VER.MOD_TM;
   _user1:=PX_VER.MOD_USER().DANE;
   _ver_n1:=PX_VER.SYMBOL;

   {? PX_VER.seek(_ver2)
   || _mod2:=PX_VER.MOD_TM;
      _user2:=PX_VER.MOD_USER().DANE;
      _ver_n2:=PX_VER.SYMBOL
   ?};
   _msg_empty:='';
   _msg1:='Uwaga! Wersja planu: '+_ver_n1;
   _msg2:='została zmodyfikowana po utworzeniu wersji: '+_ver_n2;
   _msg3:='Czas ostatniej modyfikacji: '+(19+tm_form(_mod1));
   _msg4:='Osoba ostatnio modyfikująca: '+_user1;
   _msg5:='Możliwe są następujące opcje:';
   _msg6:='1. Kontynuuj';
   _msg7:='   (modyfikacje innego użytkownika zostaną nadpisane)';
   _msg8:='2. Przerwij';
   _msg9:='   (przerywa planowanie - twoje modyfikacje nie zostaną uwzględnione)';
   _msg_glued:=exec('form','#string','L'
                                    ,_msg1
                                    ,_msg2
                                    ,_msg_empty
                                    ,_msg3
                                    ,_msg4
                                    ,_msg_empty
                                    ,_msg5
                                    ,_msg6
                                    ,_msg7
                                    ,_msg8
                                    ,_msg9);
   _result:=FUN.choice(_msg_glued,,'Kontynuuj',,,,'Przerwij')
?};
PX_VER.cntx_pop();
USERS.cntx_pop();
_result


\reset_plan_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Akcja 'Resetuj plan' w oknie WER tabeli PX_VER
::----------------------------------------------------------------------------------------------------------------------

_can_continue:=1;

{? PX_VER.STATUS=exec('status_pending','px_ver')
|| _can_continue:=0;
   FUN.emsg('Resetowanie wersji aktualnie przeliczanej zabronione.'@)
?};

{? _can_continue>0
|| _msg0:='';
   _msg:='Uwaga! Akcja ta jest nieodwracalna. Usunięte zostaną:\n\n'
         '1. Wszystkie elementy kolejki do planu.\n'
         '2. Wszystkie pozycje planu danej wersji.\n\n'
         'Dodatkowo wszystkim pojemnikom zostaną zainicjowane domyślne pojemności.\n'
         'Kontynuować?'@;
   _can_continue:=FUN.ask(_msg)
?};
{? _can_continue>0
||
:: Blokuje wersje
   {? exec('lock','px_ver',PX_VER.ref())>0
   ||
      {? exec('clean_pxpoz','px_ver',PX_VER.ref())>0
      || exec('capacity_init','px_ver',PX_VER.ref())
      ?};
::    Odblokowuje zablokowana werjse
      exec('unlock','px_ver',PX_VER.ref())
   ?}
?};
~~


\clean_pxpoz
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Usuwa dla wersji caly plan tzn wszystkie pozycje planu i wszystkie elementy kolejki
::   WE: _a - PX_VER.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_result:=0;

_can_continue:=1;
PX_VER.cntx_psh();
PX_GRP.cntx_psh();
PX_POZ.cntx_psh();
PX_VER.clear();
{? PX_VER.seek(_px_ver)
||
:: 1. Usuwanie elementów kolejki
   PX_GRP.index('LP');
   PX_GRP.prefix(PX_VER.ref());
   {? PX_GRP.first()
   || {!
      |? _can_continue:=exec('delete','px_grp',PX_GRP.ref());
         PX_GRP.next() & _can_continue>0
      !}
   ?};

:: 2. Usuwanie pozycji planu (o ile jakies zostaly, bo usuwajac elementy kolejki usuwaja sie tez pozycje planu)
   PX_POZ.index('VSTATUS');
   PX_POZ.prefix(PX_VER.ref());
   {? PX_POZ.first()
   || {!
      |? _can_continue:=exec('delete','px_poz',PX_POZ.ref(),1);
         PX_POZ.first() & _can_continue>0
      !}
   ?};
   {? _can_continue>0
   || _result:=1
   ?}
?};
PX_VER.cntx_pop();
PX_GRP.cntx_pop();
PX_POZ.cntx_pop();
_result


\capacity_init
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Inicjuje pojemnosc pojemnikow wszystkim aktywnym kontenerom danej wersji
::   WE: _a - PX_VER.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_result:=0;

_can_continue:=1;
PX_KONT.cntx_psh();
PX_VER.cntx_psh();
PX_VER.clear();
{? PX_VER.seek(_px_ver)
|| PX_KONT.index('ACT');
   PX_KONT.prefix('T',_px_ver);
   {? PX_KONT.first()
   || {!
      |? _can_continue:=exec('capacity_init','px_gen' ,PX_KONT.ref()
                                                      ,PX_VER.TM_START
                                                      ,PX_VER.TM_END
                                                      ,0);
         PX_KONT.next()
      !}
   ?}
?};
PX_VER.cntx_pop();
PX_KONT.cntx_pop();
_result


\ver_borders_ok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.20]
:: OPIS: Sprawdza, czy granice czasowe wersji sa poprawne (niezerowe)
::   WE: _a - PX_VER.ref()
::----------------------------------------------------------------------------------------------------------------------
_res:=0;

PX_VER.cntx_psh();
PX_VER.clear();
{? PX_VER.seek(_a)
||
   {? PX_VER.STARTD().DATA=date(0,0,0) | PX_VER.ENDD().DATA=date(0,0,0)
   || FUN.emsg('Plan strategiczny wymaga konfiguracji w obszarze roboczym "ZWS_PAR - Ustawienia i parametryzacja".'@)
   || _res:=1
   ?}
?};
PX_VER.cntx_pop();

_res


\lock_queue
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Blokuje wszystkie grupy z danej wersji, albo zadna jesli sie nie udalo
::   WE: _a - PX_VER.ref()
::       [_b] - INTEGER - 0/1 - czy wyswietlac i inicjowac KOMMa (domyslnie tak)
::   WY: 0 - nie udalo sie zablokowac nic, bo co najmniej jednej sie nie udalo zablokowac
::       1 - wszystkie grupy w danej wersji zablokowane
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_komm:=1;
{? var_pres('_b')=type_of(0)
|| _komm:=_b
?};

_result:=0;
_can_continue:=1;

{? _komm>0
|| KOMM.init(250,,'Blokowanie elementów kolejki'@)
?};

PX_GRP.cntx_psh();
PX_GRP.index('LP');
PX_GRP.prefix(_px_ver);
{? PX_GRP.first()
|| {!
   |? _display:=0;
      {? _komm>0
      || _display:=2
      ?};
      {? exec('lock','px_grp',,_display)=0
      || _can_continue:=0
      ?};
      PX_GRP.next()
   !}
?};

{? _can_continue=0
||
:: Nie udalo sie wszystkich zablokowac wiec odblokowuje te ktore zablokowalem
   {? PX_GRP.first()
   || {!
      |? exec('unlock','px_grp');
         PX_GRP.next()
      !}
   ?}
?};
{? _komm>0
|| KOMM.select()
?};
PX_GRP.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result


\unlock_queue
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Odblokowyje wszystkie grupy z danej wersji
::   WE: _a - PX_VER.ref()
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

PX_GRP.cntx_psh();
PX_GRP.index('LP');
PX_GRP.prefix(_px_ver);
{? PX_GRP.first()
|| {!
   |? exec('unlock','px_grp');
      PX_GRP.next()
   !}
?};
PX_GRP.cntx_pop();
~~


\wersje_visible
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MENU KONTEKSTOWE
::  UTW: WH [12.41]
:: OPIS: Okresla czy w menu kontekstowym planu strategicznego widoczna jest pozycja 'WERSJE'
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
{? exec('is_one_version','px_param')
|| _result:=0;
   {? sec_superuser()>0
   || _result:=1
   ?}
?};
_result


\trig_add_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Triggery dla tabeli PX_GRP
::  OLD: \PX_VER/trigger.fml
::  TAG: <PRIVATE>
::----------------------------------------------------------------------------------------------------------------------
exec('ver_stmp_trig','px_ver');
1


\trig_put_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: OPIS: Triggery dla tabeli PX_GRP
::  OLD: \PX_VER/trigger.fml
::  TAG: <PRIVATE>
::----------------------------------------------------------------------------------------------------------------------
exec('ver_stmp_trig','px_ver');
1


\get_replan_version
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca przeliczaną wersję
::   WY: PX_VER.ref()
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=null();
{? PX_VAR.VIE_VER<>null()
|| _result:=PX_VAR.VIE_VER
|| _result:=exec('get_mainversion','px_ver')
?};
_result


\is_whatif
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy wersja planu jest symulacją whatif
::   WE: [_a] - PX_VER.ref() lub bieżący rekord
::   WY: 0 - nie jest
::       1 - jest
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_VER.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_VER.cntx_psh();
{? _ref<>null()
|| PX_VER.prefix();
   {? PX_VER.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? PX_VER.WHATIF='T'
   || _result:=1
   ?}
?};
PX_VER.cntx_pop();
_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:39 4e2db4663041a030d1550af8ef635200635f66d8ae0a9db235e639b67b8bc72c0d49b891d6977b82a91cda2037b3f96c0e5bc9224650edddee1343edd70a48b1999f759f5eabdf8ca4bb7597a1c187ca40d1f501e5a91bc55e30f9d7bd6dbdfcc7921fbbc651cd6ea176dd224ef3fb6c8170e23ff9d00288fd6c437dc42c59c7
