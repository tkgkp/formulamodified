:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku:  px_poz.fml [12.10]
:: Utworzony: 2011-07-28
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Obsluga pozycji planu w planie strategicznym (wielowymiarowym planie pojemnosciowym)
::
:: Informacje o indeksach wystepujacych w tabeli PX_POZ:
::
:: BLK      -
:: BLK2     -
:: GRPBACK  -
:: GRPFORW  -
:: LP       -
:: PL_OPER  -
:: PL_OPER2 -
:: PX_GRP   -
:: PX_GRP2  -
:: PX_KONT  -
:: PX_OBJ   -
:: PX_OBJ2  -
:: PX_OBJ3  -
:: PX_POZ   -
:: PX_SET   -
:: PX_STAG1 -
:: PX_STAG2 -
:: PX_STAG3 - wykorzystywany w funkcjach: exec('generuj_grp','px_sur'), exec('src_obj_act','px_plan')
:: PX_STAG4 - wykorzystywany w funkcji: exec('generuj_ver','px_sur')
:: PX_STAGE -
:: STATUS   -
:: STATUS2  -
:: STATUS3  -
:: TM_GRP   -
:: TM_KONT  -
:: TM_VOBJ  -
:: TM_VOBJ2 -
:: TM_VOBJK -
:: VSTAGE   - wykorzystywany podczas aktualizacji wykonan w planie strategicznym na podstawie wykonan
::            do przewodnikow zlecen - exec('auto_px_wyk','px_wyk')
:: VSTATUS  -
::======================================================================================================================


\clone_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Tablica parametrow dla clone
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('SOURCE',
               'PX_VER',
               'PX_GRP',
               'PX_CUP',
               'PX_KONT'
               );
_args.SOURCE:=null();
_args.PX_VER:=null();
_args.PX_GRP:=null();
_args.PX_CUP:=null();
_args.PX_KONT:=null();
_args


\clone
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Klonuje pozycje planu
::   WE: _a - _args  - argumenty funkcji wynik dzialania exec('clone_a','px_poz')
::   WY: 0 - zguba
::       1 - zwyciestwo
::----------------------------------------------------------------------------------------------------------------------
_args:={? _=1 || _a || exec('clone_a','px_poz') ?};
_result:=0;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

PX_WYK.cntx_psh();
PX_POZ.cntx_psh();
PX_POZ.clear();
_cloned:=null();
_px_obj:=null();
{? PX_POZ.seek(_args.SOURCE)
|| _what:=$PX_POZ.ref();
   _src_ver:=PX_POZ.PX_VER;
   _msg:='Duplikowanie pozycji planu: '+_what;
   pxkomm.sect_beg(_msg);
   _px_obj:=PX_POZ.PX_OBJ;
:: dodaje tylko jesli wszystkie kluczowe powiazania rozne od null
   {? _args.PX_VER<>null() &
      _args.PX_CUP<>null() &
      _args.PX_KONT<>null()
   ||
      PX_POZ.PX_VER:=_args.PX_VER;
      PX_POZ.PX_GRP:=_args.PX_GRP;
      PX_POZ.PX_CUP:=_args.PX_CUP;
      PX_POZ.PX_KONT:=_args.PX_KONT;
      PX_POZ.UPD_SUR:='N';
      PX_POZ.UPD_TIM:='N';
      PX_POZ.KOM_ERR:='N';
      PX_POZ.KOM_WARN:='N';
      PX_POZ.KOM_INFO:='N';
      _result:=PX_POZ.add();
      {? _result=0
      || _msg:='Duplikowanie pozycji planu - nie udalo się dodać zduplikowanej pozycji planu';
         pxkomm.error(_msg)
      ?}
   ?};
   _cloned:=PX_POZ.ref();

:: 1. Jesli sie udalo sklonowac to klonuje tez wykonania
   {? _result>0
   || _msg:='Duplikowanie wykonań dla pozycji planu: '+_what;
      pxkomm.sect_beg(_msg);
      _argswyk:=exec('clone_a','px_wyk');
      _argswyk.PX_VER:=_args.PX_VER;
      _argswyk.PX_POZ:=_cloned;
      PX_WYK.index('POZ');
      PX_WYK.prefix(_args.SOURCE);
      {? PX_WYK.first()
      ||
         {!
         |? _argswyk.SOURCE:=PX_WYK.ref();
            exec('clone','px_wyk',_argswyk);
            PX_WYK.next()
         !}
      ?};
      pxkomm.sect_end()
   || _msg:='Nie udało się dodanie pozycji planu: '+_what;
      pxkomm.error(_msg)
   ?};

:: 2. Jesli się udalo sklonowac to klonuje tez komunikaty
   {? _result>0
   ||
      _argskomm:=exec('clone_a','px_komm');
      _argskomm.PX_VER:=_args.PX_VER;
      _argskomm.PX_GRP:=_args.PX_GRP;
      _argskomm.PX_CUP:=_args.PX_CUP;
      _argskomm.PX_POZ:=_cloned;
      _argskomm.PX_OBJ:=_px_obj;
      exec('clone_poz','px_komm',_args.SOURCE,_argskomm)
   ?};

:: 3. Dla symulacji what-if robię też klonowanie PX_SUR
   {? _result>0 & exec('is_whatif','px_ver',_args.PX_VER)>0
   || exec('clone','px_sur',_src_ver,_args.SOURCE,_args,_cloned)
   ?};

   pxkomm.sect_end()
|| _msg:='Nie znaleziono pozycji planu do duplikowania: '+$_args.SOURCE;
   pxkomm.error(_msg)
?};
PX_POZ.cntx_pop();
PX_WYK.cntx_pop();
_result


\blank_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Tablica parametrow dla blank
::   WE: --
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PX_VER',
               'PX_GRP',
               'PX_OBJ',
               'PX_CUP',
               'PX_KONT',
               'PX_SET',
               'PX_STAGE',
               'DATE_MIN',
               'TIME_MIN',
               'DATE_MAX',
               'TIME_MAX',
               'CAP_EAT1',
               'CAP_EAT2',
               'CAP_EAT3',
               'CAP_EAT4',
               'CAP_EAT5',
               'CAP_WYK1',
               'CAP_WYK2',
               'CAP_WYK3',
               'CAP_WYK4',
               'CAP_WYK5',
               'CAP_MIN1',
               'CAP_MIN2',
               'CAP_MIN3',
               'CAP_MIN4',
               'CAP_MIN5',
               'CAP_MAX1',
               'CAP_MAX2',
               'CAP_MAX3',
               'CAP_MAX4',
               'CAP_MAX5',
               'LP',
               'STATUS',
               'DIR',
               'BLK',
               'PL_OPER',
               'PL_OGR',
               'SRC_OPER',
               'KOOP',
               'TM_SRC',
               'TM_START',
               'TM_END',
               'STARTD',
               'ENDD',
               'LANE',
               'WHEN',
               'REASON'
               );
_args.PX_VER:=null();
_args.PX_GRP:=null();
_args.PX_OBJ:=null();
_args.PX_CUP:=null();
_args.PX_KONT:=null();
_args.PX_SET:=null();
_args.PX_STAGE:=null();
_args.DATE_MIN:=date(0,0,0);
_args.DATE_MAX:=date(0,0,0);
_args.TIME_MIN:=time(0,0,0);
_args.TIME_MAX:=time(0,0,0);
_args.CAP_EAT1:=0;
_args.CAP_EAT2:=0;
_args.CAP_EAT3:=0;
_args.CAP_EAT4:=0;
_args.CAP_EAT5:=0;
_args.CAP_WYK1:=0;
_args.CAP_WYK2:=0;
_args.CAP_WYK3:=0;
_args.CAP_WYK4:=0;
_args.CAP_WYK5:=0;
_args.CAP_MIN1:=0;
_args.CAP_MIN2:=0;
_args.CAP_MIN3:=0;
_args.CAP_MIN4:=0;
_args.CAP_MIN5:=0;
_args.CAP_MAX1:=0;
_args.CAP_MAX2:=0;
_args.CAP_MAX3:=0;
_args.CAP_MAX4:=0;
_args.CAP_MAX5:=0;
_args.LP:=-1;
_args.DIR:=1;
_args.STATUS:=exec('status_normal','px_poz');
_args.BLK:='N';
_args.PL_OPER:=null();
_args.PL_OGR:=null();
_args.SRC_OPER:='N';
_args.KOOP:='N';
_args.TM_SRC:=0;
_args.TM_START:=0;
_args.TM_END:=0;
_args.STARTD:=null();
_args.ENDD:=null();
_args.LANE:=1;
_args.WHEN:='';
_args.REASON:='';
:: zwracamy deklaracje parametrow
_args


\blank
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Blankuje PX_POZ
::   WE: _a - _args
::----------------------------------------------------------------------------------------------------------------------
_args:={? _=1 || _a || exec('blank_a','px_poz') ?};
PX_POZ.blank();
exec('args2record','px_poz',_args);

~~


\args2record
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Ustawia bufor na podstawie wartosci argumentow w tabeli nazwanej exec('blank_a','px_poz')
::   WE: _args
::----------------------------------------------------------------------------------------------------------------------
_args:={? _=1 || _a || exec('blank_a','px_poz') ?};

PX_POZ.PX_VER:=_args.PX_VER;
PX_POZ.PX_GRP:=_args.PX_GRP;
PX_POZ.PX_OBJ:=_args.PX_OBJ;
PX_POZ.PX_CUP:=_args.PX_CUP;
PX_POZ.PX_KONT:=_args.PX_KONT;
PX_POZ.PX_SET:=_args.PX_SET;
PX_POZ.PX_STAGE:=_args.PX_STAGE;
PX_POZ.DATE_MIN:=_args.DATE_MIN;
PX_POZ.DATE_MAX:=_args.DATE_MAX;
PX_POZ.TIME_MIN:=_args.TIME_MIN;
PX_POZ.TIME_MAX:=_args.TIME_MAX;

_il_wym:=PX_POZ.PX_KONT().IL_WYM;
{! _it:=1.._il_wym
|! _rule:=$('
               _args:=_a;
               _prec:=PX_POZ.PX_KONT().PREC'+$_it+';
               PX_POZ.CAP_EAT'+$_it+':=_args.CAP_EAT'+$_it+'$_prec;
               PX_POZ.CAP_WYK'+$_it+':=_args.CAP_WYK'+$_it+'$_prec;
               PX_POZ.CAP_MIN'+$_it+':=_args.CAP_MIN'+$_it+'$_prec;
               PX_POZ.CAP_MAX'+$_it+':=_args.CAP_MAX'+$_it+'$_prec;
               ~~
            ');
   _rule(_args)
!};
PX_POZ.LP:=_args.LP;
PX_POZ.STATUS:=_args.STATUS;
PX_POZ.BLK:=_args.BLK;
PX_POZ.PL_OPER:=_args.PL_OPER;
PX_POZ.PL_OGR:=_args.PL_OGR;
PX_POZ.SRC_OPER:=_args.SRC_OPER;
PX_POZ.PX_STAGE:=_args.PX_STAGE;
PX_POZ.KOOP:=_args.KOOP;
PX_POZ.TM_SRC:=_args.TM_SRC;
PX_POZ.TM_START:=_args.TM_START;
PX_POZ.TM_END:=_args.TM_END;
PX_POZ.STARTD:=_args.STARTD;
PX_POZ.ENDD:=_args.ENDD;
PX_POZ.LANE:=_args.LANE;
PX_POZ.WHEN:=_args.WHEN;
PX_POZ.REASON:=_args.REASON;
~~


\record2args
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Ustawia wartosci argumentow w tabeli nazwanej na podstawie aktualnego bufora
::   WE: _args
::----------------------------------------------------------------------------------------------------------------------
_args:={? _=1 || _a || exec('blank_a','px_poz') ?};

_args.PX_VER:=PX_POZ.PX_VER;
_args.PX_GRP:=PX_POZ.PX_GRP;
_args.PX_OBJ:=PX_POZ.PX_OBJ;
_args.PX_CUP:=PX_POZ.PX_CUP;
_args.PX_KONT:=PX_POZ.PX_KONT;
_args.PX_SET:=PX_POZ.PX_SET;
_args.PX_STAGE:=PX_POZ.PX_STAGE;
_args.DATE_MIN:=PX_POZ.DATE_MIN;
_args.DATE_MAX:=PX_POZ.DATE_MAX;
_args.TIME_MIN:=PX_POZ.TIME_MIN;
_args.TIME_MAX:=PX_POZ.TIME_MAX;

_il_wym:=PX_POZ.PX_KONT().IL_WYM;
{! _it:=1.._il_wym
|! _rule:=$('
               _args:=_a;
               _prec:=PX_POZ.PX_KONT().PREC'+$_it+';
               _args.CAP_EAT'+$_it+':=PX_POZ.CAP_EAT'+$_it+'$_prec;
               _args.CAP_WYK'+$_it+':=PX_POZ.CAP_WYK'+$_it+'$_prec;
               _args.CAP_MIN'+$_it+':=PX_POZ.CAP_MIN'+$_it+'$_prec;
               _args.CAP_MAX'+$_it+':=PX_POZ.CAP_MAX'+$_it+'$_prec;
               ~~
            ');
   _rule(_args)
!};
_args.LP:=PX_POZ.LP;
_args.STATUS:=PX_POZ.STATUS;
_args.BLK:=PX_POZ.BLK;
_args.PL_OPER:=PX_POZ.PL_OPER;
_args.PL_OGR:=PX_POZ.PL_OGR;
_args.SRC_OPER:=PX_POZ.SRC_OPER;
_args.PX_STAGE:=PX_POZ.PX_STAGE;
_args.KOOP:=PX_POZ.KOOP;
_args.TM_SRC:=PX_POZ.TM_SRC;
_args.TM_START:=PX_POZ.TM_START;
_args.TM_END:=PX_POZ.TM_END;
_args.STARTD:=PX_POZ.STARTD;
_args.ENDD:=PX_POZ.ENDD;
_args.LANE:=PX_POZ.LANE;
_args.WHEN:=PX_POZ.WHEN;
_args.REASON:=PX_POZ.REASON;
~~


\add
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Dodaje rekord do tabeli PX_POZ
::   WE: _args - exec('blank_a','px_poz')
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_args:={? _=1 || _a || exec('blank_a','px_poz') ?};
_result:=0;

:: przypisuje kolejny numer w pojemniku, o ile wartosc domyslna kolejnosci nie byla modyfikowana
:: niektore funkcje (np. szatkownica) moga nadawac specjalna kolejnosc pozycji planu ktora nie powinna byc modyfikowana
{? _args.LP=-1
||
:: LP nowej pozycji planu kolejne w pojemniku
   PX_CUP.cntx_psh();
   PX_POZ.cntx_psh();
   PX_CUP.clear();

   {? PX_CUP.seek(_args.PX_CUP)
   || PX_POZ.index('LP');
      PX_POZ.prefix(PX_CUP.ref());
      {? PX_POZ.last()
      || _args.LP:=PX_POZ.LP+1
      ?}
   ?};
   PX_POZ.cntx_pop();
   PX_CUP.cntx_pop()
?};

exec('fill_when','px_poz',_args);

::blankuje
exec('blank','px_poz',_args);

::dodaje tylko jesli ilosci w ktorymkolwiek wymiarze sa rozne od zera
_add:=0;
_il_wym:=PX_POZ.PX_KONT().IL_WYM;
{! _it:=1.._il_wym
|? _add=0
|! _rule:=$('{? PX_POZ.CAP_EAT'+$_it+'>0 || 1 || 0 ?}');
   _add:=_rule()
!};
{? _add>0
|| _result:=PX_POZ.add()
?};

:: jesli planowanie bylo w tyl to nowa pozycja planu zostala utworzona na poczatku, reszte trzeba przenumerowac
{? _result>0 & _args.DIR<0
||
:: RENUMERACJA POZYCJI PLANU
   exec('renumerate','px_poz',_args.PX_CUP)
?};
:: Uaktualniam status, blokade pozycji planu i dystrybuuje status w gore
{? _result>0
|| exec('status_set','px_poz',PX_POZ.ref(),PX_POZ.STATUS)
?};
_result


\update
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Uaktualniam biezacy rekord PX_POZ
::       Kontekst pracy - PX_POZ
::   WE: _args
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_args:={? _=1 || _a || exec('blank_a','px_poz') ?};

{? _args.TM_START<>PX_POZ.TM_START | _args.TM_END<>PX_POZ.TM_END
|| exec('fill_when','px_poz',_args)
?};
exec('args2record','px_poz',_args);

_result:=PX_POZ.put();

:: Uaktualniam status, blokade pozycji planu i dystrybuuje status w gore
{? _result>0
|| exec('status_set','px_poz',PX_POZ.ref(),PX_POZ.STATUS)
?};
_result


\szczegoly
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Szczeglowe rozwiniecie pozycji planu w pojemniku (kafelek)
::----------------------------------------------------------------------------------------------------------------------
DATY.cntx_psh();
PX_CUP.cntx_psh();
PX_POZ.cntx_psh();
PX_OBJ.cntx_psh();
ZK_N.cntx_psh();
ZK_P.cntx_psh();

PX_POZ.win_sel('KAFELEK');
PX_POZ.hdr_sel();
PX_POZ.hdr_sel('Pozycje planu'@);
exec('szczegoly_hdr','px_poz');

{? PX_VAR.NAST_ALG<>2
|| PX_POZ.actions('KAFELEK','E:E',,1)
?};

_can_continue:=1;

:: Blankuje PX_OBJ zeby w przypadku pustej dziedziny PX_POZ w oknie nie pojawialy sie nieprawidlowe informacje
PX_OBJ.blank(1);

:: Podczytanie widoku
PX_VAR.PX_VIEW();

:: Poczytanie "kafelka"
_kafelek:=cur_win(1,1);

{? PX_VAR.SEL_KONT<>null()
||
:: Podczytanie PX_KONT
   PX_VAR.SEL_KONT();

   _offset:=exec('time','#tm_stamp',PX_VIEW.OFFSET);

:: Porównuje poziom widoku z poziomem pojemnikow
   _compare:=exec('level_compare','px_view',PX_KONT.MAX_CDUR,PX_VIEW.LEVEL);
   {? _compare<>-1
   ||
::    Filtrowanie sie odbywa tylko jesli poziom widoku bardziej ogolny niz poziom na kontenerze
      PX_POZ.clear();
      PX_CUP.clear();

      _tm_start:=DATY.STAMP_S+_offset;
      _tm_end:=0;

      DATY.cntx_psh();
      {? exec('find_next','daty',PX_VIEW.LEVEL)>0
      || _tm_end:=DATY.STAMP_S+_offset
      ?};
      DATY.cntx_pop();
      _fil_poz:=exec('view_filter','px_poz',_tm_start,_tm_end,PX_VAR.SEL_KONT);
      {? _fil_poz=0
      || FUN.emsg('Założenie filtra na pozycje planu zakończone niepowodzeniem.'@);
         _can_continue:=0
      ?};

      _fil_cup:=exec('view_filter','px_cup',_tm_start,_tm_end,PX_VAR.SEL_KONT);
      {? _fil_poz=0
      || FUN.emsg('Założenie filtra na pojemniki zakończone niepowodzeniem.'@);
         _can_continue:=0
      ?};

      {? _can_continue>0
      || exec('szczegoly_sum','px_poz',1)
      ?}
   ||
::    Jesli poziom widoku bardziej szczegolowy niz poziom na kontenerze to
::    dzialam w kontekscie PX_CUP i w oknie wyswietlam ilosci prosto z PX_CUP
      {? _can_continue>0
      || exec('szczegoly_sum','px_poz',0)
      ?}
   ?}
|| _can_continue:=0;
   FUN.info('Akcja szczegóły w tym kontekście niedostępna'@)
?};
{? _can_continue>0
|| PX_POZ.select(,1,5);
   _tree:=exec('tree_kont','px_param');
   {? var_pres('PxSelect')>100
   || {? PxSelect.Context*'COMPARE'>0
      || _tree:=0
      ?}
   ?};
   grp_disp(PX_KONT,{? _tree || 'PX_WERT' || 'PX_WER' ?},1);
   grp_disp(PX_POZ,_kafelek,0);
   ~~
?};

PX_POZ.f_clear();
PX_CUP.f_clear();
PX_POZ.cntx_pop();
PX_CUP.cntx_pop();
PX_OBJ.cntx_pop();
ZK_N.cntx_pop();
ZK_P.cntx_pop();
DATY.cntx_pop();
~~


\szczegoly_hdr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Naglowki kolumn w oknie szczegolowego rozwiniecia pozycji planu (kafelek)
::----------------------------------------------------------------------------------------------------------------------
{! _it:=1..5
|! {? _it<=PX_KONT.IL_WYM
   || ($('PX_VAR.TITD'+$_it+':=\'Il. [\'+PX_KONT.JM'+$_it+'().KOD+\']\''))();
      ($('PX_VAR.TITW'+$_it+':=\'Wyk. [\'+PX_KONT.JM'+$_it+'().KOD+\']\''))()
   || ($('PX_VAR.TITD'+$_it+':=\'\''))();
      ($('PX_VAR.TITW'+$_it+':=\'\''))()
   ?}
!};
~~


\szczegoly_hdr_interm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
::   WE: _a - STRING - akronim okienka PX_POZ
:: OPIS: Naglowki kolumn w oknie szczegolowego rozwiniecia pozycji planu (kafelek)
::----------------------------------------------------------------------------------------------------------------------
_wer:=_a;

{! _it:=1..exec('il_wym','px_param')
|! {? _it<=PX_KONT.IL_WYM
   || ($('PX_VAR.TITD'+$_it+':=\'Il. [\'+PX_KONT.JM'+$_it+'().KOD+\']\''))();
      ($('PX_VAR.TITW'+$_it+':=\'Wyk. [\'+PX_KONT.JM'+$_it+'().KOD+\']\''))()
   || ($('PX_VAR.TITD'+$_it+':=\'""\''))();
      ($('PX_VAR.TITW'+$_it+':=\'""\''))()
   ?};
   _war:=($('PX_VAR.TITD'+$_it))();
   PX_POZ.fld_opt(_wer,'col_name=%1'[_war],PX_POZ,'CAP_EAT'+$_it);
   _war2:=($('PX_VAR.TITW'+$_it))();
   PX_POZ.fld_opt(_wer,'col_name=%1'[_war2],PX_POZ,'CAP_WYK'+$_it)
!};
~~


\px_poz_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wyswietl w oknach PX_POZ.KAFELEK*, PX_POZ.WER_*
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(PX_POZ,PX_OBJ,ZK_N,ZK_P);

:: Przelaczenie maski zamowienia
_cur_zkn:=ZK_N.name();
PX_POZ.PX_OBJ();
_new_zkn:=ref_name(PX_OBJ.ZK_N);
_new_zkp:=ref_name(PX_OBJ.ZK_P);
{? _new_zkn<>'' & _cur_zkn<>_new_zkn
||
:: otwieram maske ZK_N i ZK_P odpowiadajace aktualnie przetwarzanemu ZK_N i ZK_P
   ZK_N.use(_new_zkn);
   ZK_P.use(_new_zkp)
?};

PX_POZ.win_edit('RED');
exec('px_poz_efld_opt','px_poz');
PX_POZ.display();

Cntx.pop(PX_POZ,PX_OBJ,ZK_N,ZK_P);
~~


\px_poz_op_rkprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed rekord w oknie opoznionych pozycji planu
::----------------------------------------------------------------------------------------------------------------------
exec('rekprzed','color','PX_POZ#02#')


\px_poz_op_bre
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wlasciwa akcja przed rekord w oknie opoznionych pozycji planu
::----------------------------------------------------------------------------------------------------------------------
PX_POZ.PX_OBJ();
PX_POZ.PX_CUP();
PX_POZ.PX_KONT();
{? exec('mainversion_vie','px_ver') || '' || 'PX_POZ#02#01' ?}


\px_poz_op_leg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Legenda w oknie opoznionych pozycji planu
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','PX_POZ#02#');
~~


\px_poz_op_disp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: 'Wyswietl' w oknie opoznionych pozycji planu
::----------------------------------------------------------------------------------------------------------------------
PX_POZ.win_edit('RED');
PX_POZ.display();
~~


\kafelek_rkprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Rekord przed w oknie PX_POZ.KAFELEK*, PX_POZ.WER_*
::----------------------------------------------------------------------------------------------------------------------
exec('rekprzed','color','PX_POZ#01#')


\kafelek_bre
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wlasciwa akcja na rekord przed w oknie PX_POZ.KAFELEK*, PX_POZ.WER_*
::----------------------------------------------------------------------------------------------------------------------
{? PX_VAR.PX_WER<>''
|| _wer:=PX_VAR.PX_WER
|| _wer:=PX_POZ.win_sel('?')
?};
_mainver:=1;
PX_VER.cntx_psh();
{? PX_POZ.ref()<>null()
|| {? PX_POZ.PX_VER().PRIMARY=0
   || _mainver:=0
   ?}
|? PX_VAR.VIE_VER().PRIMARY=0
|| _mainver:=0
?};
PX_VER.cntx_pop();

PX_OBJ.cntx_psh();

:: Podczytanie PX_OBJ
PX_VAR.OBJ_SYM:=PX_POZ.PX_OBJ().SYMBOL;

{? 7+_wer='KAFELEK' & _wer<>'KAFELEK'
||
:: Podsumy tylko dla "kafelkow"
   PX_VAR.ILOSC:=($('PX_POZ.CAP_EAT'+$PxSelect.PX_WK.WYMIAR))();
   PX_VAR.MADE:=($('PX_POZ.CAP_WYK'+$PxSelect.PX_WK.WYMIAR))()
||
:: Przelaczenie maski zamowienia tylko dla "nie-kafelkow"
   _cur_zkn:=ZK_N.name();
   _new_zkn:=ref_name(PX_OBJ.ZK_N);
   _new_zkp:=ref_name(PX_OBJ.ZK_P);
   {? _new_zkn<>'' & _cur_zkn<>_new_zkn
   ||
::    otwieram maske ZK_N i ZK_P odpowiadajace aktualnie przetwarzanemu ZK_N i ZK_P
      ZK_N.use(_new_zkn);
      ZK_P.use(_new_zkp)
   ?}
?};

PX_OBJ.cntx_pop();

:: Tylko w oknie PX_POZ.WER_GRP podczytywanie PX_OBJ
{? cur_win(1,1)='WER_GRP' || PX_POZ.PX_OBJ() ?};

:: Dla wersji tymczasowych bez rejestracji wykonania
_actions:=':';
{? _mainver & PX_VAR.EDIT=1
|| {? exec('get','#params',500613,2)<>'T'
   || _actions:='W'+_actions
   ?}
|| _actions:='WRP'+_actions
?};

{? PX_VAR.NAST_ALG<>2
|| _actions:='E'+_actions+'E'
?};

{? ST.ODDZ=''
|| _actions:='C'+_actions
?};

{? _actions=':'
|| _actions:=''
?};

PX_POZ.actions(_wer,_actions,,1);

:: Kolorowanie
{? PX_POZ.STATUS=exec('status_delay','px_poz')
||
:: Pozycje opoznione
   'PX_POZ#01#02'
|? PX_POZ.STATUS=exec('status_skipped','px_poz')
||
:: Pozycje porzucone
   'PX_POZ#01#03'
|? _mainver
||
   ''
||
:: Jezeli kopia/symulacja to inny kolor tla
   'PX_POZ#01#01'
?}


\kafelek_legenda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Legenda w oknie PX_POZ.KAFELEK*
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color'  ,'PX_POZ#01#'
                           ,'@PX_POZ#CAP#WIN#'
                           ,'#PX_POZ#01'
                           ,'#PX_POZ#02'
                           ,'#PX_POZ#03'
                           ,'@PX_KOMM#01#'
)


\wer1_legenda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Legenda w oknie PX_POZ.WER1
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','#PX_POZ#02')


\px_poz_cape_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed wyswietleniem pola PX_POZ.CAP_EAT*
::----------------------------------------------------------------------------------------------------------------------
_wymiar:=#(cur_afld()+1);
{? _wymiar<=PX_POZ.PX_KONT().IL_WYM
|| {? ($('PX_POZ.CAP_EAT'+$_wymiar+'=PX_POZ.CAP_WYK'+$_wymiar))()
   || exec('flddisp','color','PX_POZ#CAP#WIN#01')
   |? ($('PX_POZ.CAP_EAT'+$_wymiar+'<PX_POZ.CAP_WYK'+$_wymiar))()
   || exec('flddisp','color','PX_POZ#CAP#WIN#02')
   || ''
   ?}
|| exec('color_noavail','px_param')
?}


\px_poz_cape_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Format wyswietlania pola PX_POZ.CAP_EAT*
::----------------------------------------------------------------------------------------------------------------------
_wymiar:=#(cur_afld()+1);
{? _wymiar<=PX_POZ.PX_KONT().IL_WYM
|| 'empty=0,out_prec='+$($('PX_KONT.PREC'+$_wymiar))()
|| 'empty=1'
?}


\px_poz_capw_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed wyswietleniem pola PX_POZ.CAP_WYK*
::----------------------------------------------------------------------------------------------------------------------
_wymiar:=#(cur_afld()+1);
{? _wymiar<=PX_POZ.PX_KONT().IL_WYM
|| {? ($('PX_POZ.CAP_EAT'+$_wymiar+'=PX_POZ.CAP_WYK'+$_wymiar))()
   || exec('flddisp','color','PX_POZ#CAP#WIN#')
   |? ($('PX_POZ.CAP_EAT'+$_wymiar+'<PX_POZ.CAP_WYK'+$_wymiar))()
   || exec('flddisp','color','PX_POZ#CAP#WIN#02')
   || ''
   ?}
|| exec('color_noavail','px_param')
?}


\px_poz_capw_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Format wyswietlania pola PX_POZ.CAP_WYK*
::----------------------------------------------------------------------------------------------------------------------
_wymiar:=#(cur_afld()+1);
{? _wymiar<=PX_POZ.PX_KONT().IL_WYM
|| 'empty=0,out_prec='+$($('PX_KONT.PREC'+$_wymiar))()
|| 'empty=1'
?}


\status_normal
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status - normalny
::----------------------------------------------------------------------------------------------------------------------
'NORMALNY'


\status_blk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status zablokowany
::----------------------------------------------------------------------------------------------------------------------
'BLOKADA'


\status_wyk1
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status wykonanie - czesciowo
::----------------------------------------------------------------------------------------------------------------------
'WYKONYWANE'


\status_wyk2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status wykonanie - w calosci
::----------------------------------------------------------------------------------------------------------------------
'WYKONANO'


\status_skipped
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status porzucone
::----------------------------------------------------------------------------------------------------------------------
'PORZUCONE'


\status_delay
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Status opozniony
::----------------------------------------------------------------------------------------------------------------------
'OPÓŹNIONE'


\status_todel
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status 'do usuniecia'
::----------------------------------------------------------------------------------------------------------------------
'USUNĄĆ!!!'


\status_todelay
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status 'do opóźnienia'
::----------------------------------------------------------------------------------------------------------------------
'OPÓŹNIĆ!!!'


\px_poz_stat_bl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Blank pola tabeli PX_POZ.STATUS
::----------------------------------------------------------------------------------------------------------------------
exec('status_normal','px_poz')


\status_set
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Ustawia PX_POZowi status
::   WE: _a - PX_POZ.ref()
::       _b - STRING - status
::   WY: 0 - zguba
::       1 - zwyciestwo
::----------------------------------------------------------------------------------------------------------------------
_pxpoz:=_a;
_status:=_b;
_result:=1;

PX_POZ.cntx_psh();
PX_POZ.clear();
PX_GRP.cntx_psh();

{? PX_POZ.seek(_pxpoz)
||
   _can_change:=1;
   {? _status<>exec('status_normal','px_poz') & PX_POZ.PX_OBJ().REM_ZGL<>null()
   || _can_change:=0
   ?};

   {? _status=exec('status_delay','px_poz') &  exec('get','#params',500392)<>'T'
   || _can_change:=0
   ?};

   {? _can_change>0
   ||
      PX_POZ.STATUS:=_status;
      _result:=PX_POZ.put();

      {? _result>0
      ||
::       jesli nowy status to opozniony, wykonywany lub wykonany to musze zdjac z pozycji planu
::       znacznik blokada po to by algorytm planujacy nie zaplanowal tej pozycji planu dwa razy
         {? PX_POZ.STATUS=exec('status_wyk1','px_poz') |
            PX_POZ.STATUS=exec('status_wyk2','px_poz')
         || exec('unblock','px_poz',PX_POZ.ref())
         ?};
::       jesli nowy status to opozniony to zdejmuje blokade z calego PX_GRP, po to by opoznione pozycje
::       byly planowane zawsze przed zablokowanymi (inaczej popitoli sie kolejnosc operacji)
         {? PX_POZ.STATUS=exec('status_delay','px_poz')
         || exec('unblock','px_grp',PX_POZ.PX_GRP)
         ?}
      ?};

::    nanosze status w gore czyli na PX_GRP
      {? _result>0
      || exec('status_rebuild','px_grp',PX_POZ.PX_GRP)
      ?}
   ?}
?};
PX_GRP.cntx_pop();
PX_POZ.cntx_pop();
PX_POZ.get();
_result


\px_poz_trig
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Trigger przed add() i przed put() w tabeli PX_POZ. Automatycznie nawija pola:
::       PX_POZ.TM_START i PX_POZ.TM_END
::----------------------------------------------------------------------------------------------------------------------
::PX_CUP.cntx_psh();
::PX_POZ.TM_START:=PX_POZ.PX_CUP().TM_START;
::PX_POZ.TM_END:=PX_POZ.PX_CUP().TM_END;
::PX_POZ.STARTD:=PX_CUP.STARTD;
::PX_POZ.ENDD:=PX_CUP.ENDD;
::PX_CUP.cntx_pop();
1


\select_cup
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja PX_POZ-ow od strony PX_CUP
::----------------------------------------------------------------------------------------------------------------------
PX_OBJ.blank();
PX_VAR.CUPTITLE:=PX_CUP.SYMBOL;
PX_VAR.CUPSTART:=PX_CUP.STARTD().DATA;
PX_VAR.CUPEND:=PX_CUP.ENDD().DATA;
PX_VAR.CUP_T_S:=PX_CUP.STARTT;
PX_VAR.CUP_T_E:=PX_CUP.ENDT;

_wymiar:=1;

PX_VAR.CAPACITY:=($('PX_CUP.CAP_MAX'+$_wymiar))();
PX_VAR.SUMA:=($('PX_CUP.CAP_USE'+$_wymiar))();
PX_VAR.MADE:=($('PX_CUP.CAP_WYK'+$_wymiar))();
exec('szczegoly_sum','px_poz',0);
exec('select_cup1','px_poz');
~~


\select_cup1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja PX_POZ-ow od strony PX_CUP (rzeczywistego)
::----------------------------------------------------------------------------------------------------------------------
PX_POZ.cntx_psh();
_wer:='KAFELEK';
PX_POZ.win_sel(_wer);

{? PX_VAR.NAST_ALG<>2
|| PX_POZ.actions(_wer,'E:E',,1)
?};

PX_POZ.hdr_sel();
PX_POZ.hdr_sel('Pozycje planu'@);

exec('szczegoly_hdr_interm','px_poz',_wer);
PX_POZ.index('LP');
PX_POZ.prefix(PX_CUP.ref());
PX_POZ.select();
PX_POZ.cntx_pop();
~~


\select_poz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja PX_POZ-ow od strony glownej zakladki planu
::----------------------------------------------------------------------------------------------------------------------
exec('select','px_poz',0,#PX_KONT.ref());
~~


\select_kont
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja PX_POZ-ow od strony kontenerow - rejestracja wykonan
::----------------------------------------------------------------------------------------------------------------------
exec('select','px_poz',0,#PX_KONT.ref());
~~


\select_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja PX_POZ-ow od strony obiektow - rejestracja wykonan
::----------------------------------------------------------------------------------------------------------------------
_context:=PxSelect.Context;
PxSelect.Context:=_context+'|WIN';
exec('select','px_poz',#PX_OBJ.ref(),0);
PxSelect.Context:=_context;
~~


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja PX_POZ-ow
::   WE: _a - #PX_OBJ.ref() (0 - bez obiektu)
::       _b - #PX_KONT.ref() (0 - bez kontenera)
::----------------------------------------------------------------------------------------------------------------------
:: Obsługa automatycznych podsumowań - wstępnie wyłączenie wszystkich kolumn
{! _it:=1..exec('il_wym','px_param')
|! PX_POZ.fld_attr('CAP_EAT'+$_it,,2);
   PX_POZ.fld_attr('CAP_WYK'+$_it,,2)
!};

PX_OBJ.cntx_psh(); PX_KONT.cntx_psh();
PX_OBJ.clear(); PX_KONT.clear();

:: Blankuje zeby w przypadku pustej dziedziny PX_POZ glupoty sie nie wyswietlaly w oknie
PX_OBJ.blank(1);
PX_CUP.blank(1);

{? _a=0
||
:: widok pozycji planu dla kontenera (rozne obiekty)
   {? PX_KONT.seek(_b,)
   || _il_wym:=PX_KONT.IL_WYM;
      PX_POZ.index('TM_KONT');
      PX_POZ.prefix(_b);
      PX_POZ.win_sel('WER_K');
::    Obsługa automatycznych podsumowań - ustawienie dokładności, włączenie kolumn
      {! _it:=1.. _il_wym
      |! _format:=$("'out_prec="+$($('PX_KONT.PREC'+$_it))()+"'");
         PX_POZ.win_fml('WER_K',,'CAP_EAT'+$_it,,'SUM_FORMAT',_format);
         PX_POZ.win_fml('WER_K',,'CAP_WYK'+$_it,,'SUM_FORMAT',_format);
         PX_POZ.fld_attr('CAP_EAT'+$_it,,3);
         PX_POZ.fld_attr('CAP_WYK'+$_it,,3)
      !};
      exec('szczegoly_hdr_interm','px_poz','WER_K');
      ~~
   ?}
|? _b=0
||
:: widok pozycji planu dla obiektu (rozne kontenery)
   PX_CUP.blank(1);
   {? PX_OBJ.seek(_a,)
   || _il_wym:=exec('il_wym','px_param');
      PX_POZ.index('TM_VOBJ');
      PX_POZ.prefix(PX_VAR.VIE_VER,_a);
      PX_POZ.win_sel('WER_O')
   ?}
||
:: widok pozycji planu dla kontenera i obiektu
   {? PX_OBJ.seek(_a,) & PX_KONT.seek(_b,)
   || _il_wym:=PX_KONT.IL_WYM;
      PX_POZ.index('TM_VOBJK');
      PX_POZ.prefix(PX_VAR.VIE_VER,_a,_b);
      PX_POZ.win_sel('WER_KO');
::    Obsługa automatycznych podsumowań - ustawienie dokładności, włączenie kolumn
      {! _it:=1.. _il_wym
      |! _format:=$("'out_prec="+$($('PX_KONT.PREC'+$_it))()+"'");
         PX_POZ.win_fml('WER_KO',,'CAP_EAT'+$_it,,'SUM_FORMAT',_format);
         PX_POZ.win_fml('WER_KO',,'CAP_WYK'+$_it,,'SUM_FORMAT',_format);
         PX_POZ.fld_attr('CAP_EAT'+$_it,,3);
         PX_POZ.fld_attr('CAP_WYK'+$_it,,3)
      !};
      exec('szczegoly_hdr_interm','px_poz','WER_KO');
      ~~
   ?}
?};

PX_POZ.hdr_sel();
PX_POZ.hdr_sel('Pozycje planu'@);
PX_POZ.select();
PX_OBJ.cntx_pop(); PX_KONT.cntx_pop();
~~


\px_poz_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Aktualizacja pozycji planu - jezeli sa opoznione pozycje, to oznaczanie ich do ponownego zaplanowania
::   WE: [_a] - 1 = z pytaniem, domyslnie bez pytania
::   WY: 1 - OK, 0 - wystąpiły jakieś błędy
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(0) || _ask:=0 || _ask:=_a ?};
PX_POZ.cntx_psh();

_can_continue:=0;
_result:=1;
{? ~_ask | FUN.ask('Czy aktualizować pozycje planu i opóźnienia?'@)
|| _mainver:=exec('get_mainversion','px_ver');
   {? exec('px_poz_update','px_prepq')
   || PX_POZ.index('TM_VOBJ');
      PX_POZ.prefix(_mainver);
      {? PX_POZ.first()
      || {!
         |? _can_continue:=exec('status_update','px_poz',PX_POZ.ref());
            {? _can_continue=0 || _result:=0 ?};
            PX_POZ.next() & _can_continue>0
         !}
      ?}
   ?}
?};
PX_POZ.cntx_pop();
_result


\px_poz_made
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Zwraca informacje, czy pozycja planu zostala wykonana
::       Kontekst: aktualny PX_POZ
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_il_wym:=PX_POZ.PX_KONT().IL_WYM;
{! _it:=1.._il_wym
|! {? ($('PX_POZ.CAP_EAT'+$_it+'<=PX_POZ.CAP_WYK'+$_it))() || _res+=1 ?}
!};
_res=_il_wym


\px_poz_making
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Zwraca informacje, czy pozycja planu jest wykonywana
::       Kontekst: aktualny PX_POZ
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_il_wym:=PX_POZ.PX_KONT().IL_WYM;
{! _it:=1.._il_wym
|! {? ($('PX_POZ.CAP_WYK'+$_it+'>0'))() || _res+=1 ?}
!};
{? _res=0
|| PX_WYK.cntx_psh();
   PX_WYK.index('POZ');
   PX_WYK.prefix(PX_POZ.ref());
   {? PX_WYK.first()
   || _res:=1
   ?};
   PX_WYK.cntx_pop();
   ~~
?};
_res>0


\dnd_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Definiuje mechanizm d'n'd dla tabeli PX_POZ (okna KAFELEK*)
::   WE: [_a] - 0=definiowanie (domyslnie), 1=usuwanie
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _delete:=_a || _delete:=0 ?};

{? _delete
||
   {! _it:=1..exec('il_kol','px_plan')
   |! PX_POZ.dnd_sel('KAFELEK'+$_it,,'records.PX_POZ',"");
      PX_POZ.dnd_sel('KAFELEK'+$_it,,'records.PX_OBJ',"")
   !}
||
   {! _it:=1..exec('il_kol','px_plan')
   |! PX_POZ.dnd_sel('KAFELEK'+$_it,,
                  'records.PX_POZ',
                  "
                     _tab:=dnd_info(\'dropped_records\');
                     {? type_of(_tab)=type_of(~~) || return(0) ?};
:: tutaj obsluga przesuwania pozycji w planie
::                     msg(\'przeplanuj \'+PX_CUP.SYMBOL);
::                     PX_POZ.cntx_psh();
::                     PX_WYK.cntx_psh();
::                     PX_POZ.clear();
::                     {? _tab.first()
::                     || {? PX_POZ.seek(_tab.REF,)
::                        || PX_WYK.index('POZ');
::                           _px_wyk:=null();
::                           PX_WYK.prefix(PX_POZ.ref());
::                           {? PX_WYK.first()
::                           || _px_wyk:=PX_WYK.ref()
::                           ?};
::                           exec('move','px_poz',PX_POZ.ref(),PX_CUP.ref(),_px_wyk)
::                        ?}
::                     ?};
::                     PX_POZ.cntx_pop();
::                     PX_WYK.cntx_pop();
::                     exec('split_pxpoz','px_test',_tab.REF);
                     ~~
                  "
                  );
::      PX_POZ.dnd_sel('KAFELEK'+$_it,,
::                  'records.PX_OBJ',
::                  "
::                     _tab:=dnd_info(\'dropped_records\');
::                     {? type_of(_tab)=type_of(~~) || return(0) ?};
::                   Zmienna PX_VAR.CUPSTART powinna byc ustawiona
::                   poniewaz zadba o to formula exec('kafelek_bf','px_plan')
::
::                     exec('dnd_drop_obj','px_obj',_tab,PX_VAR.CUPSTART,time(0,0,0));
::                     ~~
::                  "
::                  )
      ~~
   !}
?};
~~


\delete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Usuwa rekord PX_POZ
::       _a - PX_POZ.ref() - rekord do usuniecia
::       [_b] - 0 - nie wykonywac formuly po wylaniu na pojemniku
::              1 - wykonywac formule po wylaniu na pojemniku [domyslnie]
::       [_c] - INTEGER - 0/[1] - czy po usunieciu wykonywac renumeracje pozycji planu na pojemniku
::       [_d] - INTEGER - 0/[1] - czy po usunięciu odbudowywać kalendarze w pojemniku
::   WY: 0 - porazka
::       >0 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_poz:=_a;
_result:=0;
_po_wylaniu:=1;
{? var_pres('_b')=type_of(0)
|| _po_wylaniu:=_b
?};
_renumerate:=1;
{? var_pres('_c')=type_of(0)
|| _renumerate:=_c
?};
_rebuild_cal:=1;
{? var_pres('_d')=type_of(0)
|| _rebuild_cal:=_d
?};
PX_KONT.cntx_psh();
PX_OBJ.cntx_psh();
PX_GRP.cntx_psh();
PX_WYK.cntx_psh();
PX_POZ.cntx_psh();
PX_CUP.cntx_psh();
PX_POZ.clear();
PX_WYK.index('POZ');
PX_WYK.clear();
_can_continue:=1;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

{? PX_POZ.seek(_px_poz)
||
   PX_OBJ.cntx_psh();
   {? PX_POZ.PX_OBJ<>null()
   || PX_OBJ.use(8+$PX_POZ.PX_OBJ)
   ?};
   PX_OBJ.clear();
   _what:=PX_POZ.PX_OBJ().SYMBOL+' '+PX_POZ.PX_GRP().SYMBOL;
   PX_OBJ.cntx_pop();

   _msg:='Usuwanie pozycji planu: '+_what;
   pxkomm.sect_beg(_msg,,1);
:: 1. Usuwam wykonania
   PX_WYK.prefix(PX_POZ.ref());
   {? PX_WYK.first()
   || {!
      |? _can_continue:=exec('delete','px_wyk',PX_WYK.ref(),0);
         PX_WYK.next() & _can_continue>0
      !}
   ?};

:: 2. Usuwam zapisy dla bufora planu dostaw
   {? _can_continue>0
   || _can_continue:=exec('delete','px_sur',PX_POZ.PX_VER,PX_POZ.ref())
   ?};

:: 3. Usuwam komunikaty
   {? _can_continue>0
   || _can_continue:=exec('del_poz','px_komm',PX_POZ.ref())
   ?};

:: 4. Usuwam PROD_REJ
   {? _can_continue>0
   ||
      PROD_NXT.cntx_psh();
      PROD_REJ.cntx_psh();
      PROD_REJ.index('PX_POZ');
      PROD_REJ.prefix('PX',PX_POZ.ref());
      {? PROD_REJ.first()
      || {!
         |?
            PROD_NXT.index('PROD_REJ');
            PROD_NXT.prefix(PROD_REJ.ref());
            {? PROD_NXT.first()
            || {!
               |? _can_continue:=PROD_NXT.del(,1);
                  PROD_NXT.first() & _can_continue>0
               !}
            ?};
            {? _can_continue>0
            ||
               PROD_NXT.index('NEXT');
               PROD_NXT.prefix(PROD_REJ.ref());
               {? PROD_NXT.first()
               || {!
                  |? _can_continue:=PROD_NXT.del(,1);
                     PROD_NXT.first() & _can_continue>0
                  !}
               ?}
            ?};
            {? _can_continue>0
            || _can_continue:=PROD_REJ.del(,1)
            ?};
            PROD_REJ.first() & _can_continue>0
         !}
      ?};
      PROD_REJ.cntx_pop();
      PROD_NXT.cntx_pop()
   ?};

:: 5. Usuwam EK_PROB
   {? _can_continue>0
   || EK_PROB.cntx_psh();
      EK_PROB.index('PROBX1');
      EK_PROB.prefix(PX_POZ.ref());
      {? EK_PROB.first()
      || {!
         |? _can_continue:=EK_PROB.del(,1);
            EK_PROB.next() & _can_continue>0
         !}
      ?};
      EK_PROB.cntx_pop()
   ?};

:: 6. Usuwam pozycje planu
   {? _can_continue>0
   ||
::    Sprawdzam czy pozycja jeszcze istnieje - moze sie zdarzyc tak ze w wyniku usunieciu wykonan
::    oraz aktualizacji statusu pozycja mogla zostac scalona z inna pozycja i usunieta
      PX_POZ.clear();
      {? PX_POZ.seek(_px_poz)
      || {? var_pres('_argspoz')>100
         || obj_del(_argspoz)
         ?};
         _argspoz:=exec('blank_a','px_poz');
         exec('record2args','px_poz',_argspoz);
         _px_cup:=PX_POZ.PX_CUP;
         _interval_poz:=exec('interval','#interval');
         _interval_poz.START:=PX_POZ.TM_START;
         _interval_poz.END:=PX_POZ.TM_END;
         _lane:=PX_POZ.LANE;
         _result:=PX_POZ.del(,1);
         {? _result=0
         || _msg:='Nie udało się usunięcie pozycji planu: '+_what;
            pxkomm.error(_msg)
         ?};

         {? _result>0 & _px_cup<>null() & _po_wylaniu>0
         ||
::          uruchamiam formule po wylaniu
            exec('po_wylaniu','px_logix',_px_cup,_argspoz,_renumerate)
         ?};
         {? PX_VAR.NAST_ALG=2 & _rebuild_cal>0
         ||
::          Algorytm nakładkowania metodą proporcji czasowej
::          Zwalniam pozycję planu więc dodaję rekord kalendarza
::            exec('add','px_cal',_interval_poz,_lane,_px_cup)
            exec('rebuild4cup','px_cal',_px_cup,0,0)
         ?}
      ||
::       Jesli pozycji juz nie ma to zwracam 1
         _result:=1
      ?}
   ?};
   pxkomm.sect_end()
|| _msg:='Nie znaleziono pozycji planu: '+$_px_poz;
   pxkomm.error(_msg)
?};
PX_POZ.cntx_pop();
PX_CUP.cntx_pop();
PX_WYK.cntx_pop();
PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
PX_KONT.cntx_pop();
_result


\renumerate
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Dokonuje przenumerowania pozycji planu w pojemniku
::   WE: _a - PX_CUP.ref() - pojemnik w ktorym przenumerowac pozycje planu
::----------------------------------------------------------------------------------------------------------------------
_px_cup:=_a;

_poz:=tab_tmp(1,  'REF','STRING[16]','Ref SQL',
                  'LP','INTEGER','Kolejny numer pozycji');

PX_POZ.cntx_psh();
PX_CUP.cntx_psh();
PX_CUP.clear();
{? PX_CUP.seek(_px_cup)
||
:: wylaczam triggery PX_POZ dotyczace PRODREJ
   {? exec('get','#params',500613,2)='T'
   || exec('trig_PX_POZ','prod_rej',0)
   ?};

   PX_POZ.index('LP');
   PX_POZ.prefix(PX_CUP.ref());
   {? PX_POZ.first()
   || _it:=1;
      {!
      |? _poz.blank();
         _poz.REF:=$PX_POZ.ref();
         _poz.LP:=_it;
         _poz.add();
         _it+=1;
         PX_POZ.next()
      !}
   ?};
:: zmieniam kolejnosc na taka ktora nie zawiera pola ktore bede nadpisywal
   PX_POZ.index('STATUS');
   PX_POZ.prefix(PX_CUP.ref());
   {? PX_POZ.first()
   || {!
      |?
::       pobieram numer
         _lp:=0;
         _poz.prefix($PX_POZ.ref());
         {? _poz.first()
         || _lp:=_poz.LP;
            {? _lp<>PX_POZ.LP
            || PX_POZ.LP:=_lp;
               PX_POZ.put()
            ?}
         ?};
         PX_POZ.next()
      !}
   ?};
:: wlaczam triggery PX_POZ dotyczace PRODREJ
   {? exec('get','#params',500613,2)='T'
   || exec('trig_PX_POZ','prod_rej',1)
   ?}
?};
obj_del(_poz);
PX_CUP.cntx_pop();
PX_POZ.cntx_pop();
~~


\count_status
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zlicza ilosci na px_pozach nalezacych do danego PX_GRP ktore maja podany status.
::       Funkcja uzywana w algorytmie planujacym do korekty ilosci w paczce technologicznej, po to
::       aby nie planowac ilosci wykonanych, opoznionych itp ktore sie znajda w planie w specjalnym trybie
::   WE:
::       _a - PX_GRP.UID - unikalny symbol obiektu grupujacego
::       _b - PX_STAGE.ref() - operacja/etap
::       _c - PX_KONT.UID - kontener
::       _d - STRING[20] - status ktory policzyc
::   WY: obj_new(exec('il_wym','px_param')) - tablica z ilosciami danego statusu we wszystkich wymiarach
::----------------------------------------------------------------------------------------------------------------------
_uid_grp:=_a;
_stage:=_b;
_uid_kont:=_c;
_status:=_d;

_il_wym:=exec('il_wym','px_param');

_result:=obj_new(_il_wym);
{! _it:=1.._il_wym
|! _result[_it]:=0
!};

PX_GRP.cntx_psh();
PX_STAGE.cntx_psh();
PX_KONT.cntx_psh();
PX_POZ.cntx_psh();
PX_GRP.index('UID');

{? _uid_grp<>''
|| PX_GRP.prefix(_uid_grp);

   {? PX_GRP.first()
   || PX_STAGE.clear();
      {? PX_STAGE.seek(_stage)
      ||
         PX_KONT.index('UID');
         PX_KONT.prefix(_uid_kont);
         {? PX_KONT.first()
         ||

            PX_POZ.index('STATUS2');
            PX_POZ.prefix(PX_GRP.ref(),PX_KONT.ref(),PX_STAGE.ref(),_status);
            {? PX_POZ.first()
            || {!
               |? {! _it:=1.._il_wym
                  |! _rule:=$('_result:=_a;_result['+$_it+']+=PX_POZ.CAP_EAT'+$_it);
                     _rule(_result)
                  !};
                  PX_POZ.next()
               !}
            ?}
         ?}
      ?}
   ?}
?};
PX_POZ.cntx_pop();
PX_KONT.cntx_pop();
PX_STAGE.cntx_pop();
PX_GRP.cntx_pop();
_result


\count_blk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zlicza ilosci na px_pozach nalezacych do danego PX_GRP ktore sa zablokowane
::       Funkcja uzywana w algorytmie planujacym do korekty ilosci w paczce technologicznej, po to
::       aby nie planowac ilosci zablokowanych ktore znajda w planie w specjalnym trybie
::   WE:
::       _a - PX_GRP.UID - unikalny symbol obiektu grupujacego
::       _b - PX_STAGE.ref() - operacja/etap
::       _c - PX_KONT.UID - kontener
::   WY: obj_new(exec('il_wym','px_param')) - tablica z ilosciami danego statusu we wszystkich wymiarach
::----------------------------------------------------------------------------------------------------------------------
_uid_grp:=_a;
_stage:=_b;
_uid_kont:=_c;

_il_wym:=exec('il_wym','px_param');

_result:=obj_new(_il_wym);
{! _it:=1.._il_wym
|! _result[_it]:=0
!};

PX_GRP.cntx_psh();
PX_STAGE.cntx_psh();
PX_KONT.cntx_psh();
PX_POZ.cntx_psh();
PX_GRP.index('UID');

{? _uid_grp<>''
||
   PX_GRP.prefix(_uid_grp);

   {? PX_GRP.first()
   || PX_STAGE.clear();
      {? PX_STAGE.seek(_stage)
      ||
         PX_KONT.index('UID');
         PX_KONT.prefix(_uid_kont);
         {? PX_KONT.first()
         ||

            PX_POZ.index('BLK2');
            PX_POZ.prefix(PX_GRP.ref(),PX_KONT.ref(),PX_STAGE.ref(),'T');
            {? PX_POZ.first()
            || {!
               |? {! _it:=1.._il_wym
                  |! _rule:=$('_result:=_a;_result['+$_it+']+=PX_POZ.CAP_EAT'+$_it);
                     _rule(_result)
                  !};
                  PX_POZ.next()
               !}
            ?}
         ?}
      ?}
   ?}
?};
PX_POZ.cntx_pop();
PX_KONT.cntx_pop();
PX_STAGE.cntx_pop();
PX_GRP.cntx_pop();
_result


\count_now
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zlicza ilosci na px_pozach trwajacych na aktualnym pojemniku nalezacych do PX_GRPa i PX_STAGE
::   WE:
::       _a - PX_GRP.UID - unikalny symbol obiektu grupujacego
::       _b - PX_STAGE.ref() - operacja/etap
::       _c - PX_KONT.UID - kontener
::   WY: obj_new(exec('il_wym','px_param')) - tablica z ilosciami danego statusu we wszystkich wymiarach
::----------------------------------------------------------------------------------------------------------------------
_uid_grp:=_a;
_stage:=_b;
_uid_kont:=_c;

_il_wym:=exec('il_wym','px_param');

_result:=obj_new(_il_wym);
{! _it:=1.._il_wym
|! _result[_it]:=0
!};

PX_POZ.cntx_psh();
PX_POZ.index('PX_STAGE');
PX_KONT.cntx_psh();
PX_KONT.index('UID');
PX_GRP.cntx_psh();
PX_GRP.index('UID');
PX_CUP.cntx_psh();
PX_STAGE.cntx_psh(); PX_STAGE.clear();

{? _uid_grp<>''
||
   PX_GRP.prefix(_uid_grp);
   {? PX_GRP.first()
   ||
      PX_KONT.prefix(_uid_kont);
      {? PX_KONT.first()
      ||
::       Szukam aktualnego pojemnika na kontenerze
         _during:=exec('cup_point_check','px_plan',PX_KONT.ref(),PX_KONT.tm_stamp());
         {? _during>0
         ||
            PX_POZ.prefix(PX_CUP.ref(),PX_GRP.ref(),_stage);
            {? PX_POZ.first()
            || {!
               |? {! _it:=1.._il_wym
                  |! _rule:=$('_result:=_a;_result['+$_it+']+=PX_POZ.CAP_EAT'+$_it);
                     _rule(_result)
                  !};
                  PX_POZ.next()
               !}
            ?}
         ?}
      ?}
   ?}
?};
PX_STAGE.cntx_pop();
PX_CUP.cntx_pop();
PX_GRP.cntx_pop();
PX_KONT.cntx_pop();
PX_POZ.cntx_pop();
_result


\px_poz_skip
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Oznaczenie pozycji planu jako 'porzuconej'
::----------------------------------------------------------------------------------------------------------------------
_skipped:=exec('status_skipped','px_poz');

{? VAR.GRUPA='T'
||
   {? PX_POZ.STATUS<>_skipped & exec('can_skip','px_poz')>0
   ||
::    Porzucanie
      PX_POZ.STATUS:=_skipped;
      PX_POZ.put()
   |? PX_POZ.STATUS<>_skipped & exec('can_skip','px_poz')=0
   ||
::    Brak mozliwosci porzucenia
      KOMM.add('Pozycja planu: %1 nie może zostać porzucona'@[exec('record','#to_string',PX_POZ.ref())],2)
   ?}
||
:: Porzucanie
   {? PX_POZ.STATUS<>_skipped & exec('can_skip','px_poz')>0
   || {? FUN.ask('Czy porzucić wykonywanie pozycji planu?'@)
      || PX_POZ.STATUS:=_skipped;
         PX_POZ.put()
      ?}
   ||
::    Brak mozliwosci porzucenia
      {? PX_POZ.PX_OBJ().REM_ZGL<>null()
      || FUN.emsg('Pozycja planu strategicznego dotyczy zgłoszenia remontowego — nie można porzucać.'@)
      || FUN.emsg('Tylko pozycje planu nie powiązane z planem operacyjnym i \'Opóźnione\' w przeszłości mogą być porzucone.'@)
      ?}
   ?}
?};
~~


\px_poz_skip_revert
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wycofywanie porzucenia
::----------------------------------------------------------------------------------------------------------------------
_can_back:=(exec('get','#params',8057,2,OPERATOR.USER)='T');
_skipped:=exec('status_skipped','px_poz');

{? VAR.GRUPA='T'
||
   {? PX_POZ.STATUS=_skipped & _can_back>0
   ||
::    Wycofanie porzucenia
      PX_POZ.STATUS:=exec('status_delay','px_poz');
      PX_POZ.put()
   |? PX_POZ.STATUS=_skipped & _can_back=0
   ||
::    Wycofanie porzucenia - brak uprawnien
      KOMM.add('Brak uprawnień do przywracania porzuconych pozycji planu.'@,2)
   |? PX_POZ.STATUS<>_skipped
   || KOMM.add('Pozycja planu: %1 nie jest porzucona.'@[exec('record','#to_string',PX_POZ.ref())])
   ?}
||
:: Pojedynczo 'porzucanie' i 'przywracanie'
   {? PX_POZ.STATUS=_skipped & _can_back>0 & FUN.ask('Czy przywrócić \'Opóźniony\' status dla pozycji planu?'@)
   ||
::    Wycofanie porzucenia
      PX_POZ.STATUS:=exec('status_delay','px_poz');
      PX_POZ.put()
   |? PX_POZ.STATUS=_skipped & _can_back=0
   ||
::    Wycofanie porzucenia - brak uprawnien
      FUN.emsg('Brak uprawnień do przywracania porzuconych pozycji planu.'@)
   |? PX_POZ.STATUS<>_skipped
   || FUN.emsg('Pozycja planu nie jest porzucona.'@)
   ?}
?};
~~


\can_skip
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy biezaca pozycja planu moze byc porzucona
::   WY: 0 - nie mozna porzucac tej pozycji
::       1 - pozycja moze byc porzucona
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

:: poki co moge porzucac tylko te ktore sa opoznione i znajduja w przeszlosci
{? PX_POZ.STATUS=exec('status_delay','px_poz')
|| {? PX_POZ.TM_END<PX_POZ.tm_stamp()
   || _result:=1
   ?}
?};

{? _result>0
||
:: Nie można porzucać tych które są utworzone na podstawie planu operacyjnego
   {? PX_POZ.PL_OPER<>null() | PX_POZ.PL_OGR<>null()
   || _result:=0
   ?}
?};

{? _result>0
||
:: Nie można porzucać zgłoszeń remontowych
   {? PX_POZ.PX_OBJ().REM_ZGL<>null()
   || _result:=0
   ?}
?};

_result


\px_poz_skip_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Oznaczenie pozycji planu jako 'porzuconej' - przed grupa rekordow
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy porzucić wykonywanie zaznaczonych pozycji planu?'@)
|| KOMM.init(200,,'Porzucanie pozycji planu'@,'');
   VAR.GRUPA:='T';
   1
|| 0
?}


\px_poz_skip_revert_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Oznaczenie pozycji planu jako 'porzuconej' - po grupie rekordow
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\px_poz_skip_revert_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Oznaczenie pozycji planu jako 'porzuconej' - przed grupa rekordow
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy przywrócić porzucone pozycje planu?'@)
|| KOMM.init(200,,'Przywracanie pozycji planu'@,'');
   VAR.GRUPA:='T';
   1
|| 0
?}


\px_poz_skip_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Oznaczenie pozycji planu jako 'porzuconej' - po grupie rekordow
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\move
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Przesuwa pozycje planu do pojemnika
::   WE: _a - PX_POZ.ref() - co przesunac
::       _b - PX_CUP.ref() - gdzie przesunac
::       [_c] - INTEGER - opcjonalnie PX_POZ.LP ktora powinien miec PX_POZ w nowym pojemniku
::                        (aczkolwiek moze ona byc rozna od podanej bo w po_wlaniu sie wykonuje formula
::                         exec('renumerate','px_poz') ktora nadaje LP od nowa)
::       [_d] - INTEGER - 0/[1] - czy po przesunieciu zmieniac status z opoznionej
::   WY: null() - funkcja zakonczona niepowodzeniem
::       PX_POZ.ref() - ref pozycji planu ktora przesunieto, lub do ktorej scalono przesuwana pozycje
::                      nawet jesli scalono czesc
::----------------------------------------------------------------------------------------------------------------------
_pxpoz:=_a;
_pxcup:=_b;
_lp:=-9999;

{? var_pres('_c')=type_of(0)
|| _lp:=_c
?};

_del_delay:=1;
{? var_pres('_d')=type_of(0)
|| _del_delay:=_d
?};

_result:=null();
_can_continue:=0;

PX_POZ.cntx_psh();
PX_CUP.cntx_psh();
PX_KONT.cntx_psh();
PX_POZ.clear();
PX_CUP.clear();
{? PX_POZ.seek(_pxpoz)
|| {? PX_CUP.seek(_pxcup)
   ||
      _cup_src:=PX_POZ.PX_CUP;
      _cup_dst:=PX_CUP.ref();
      _duration:=PX_POZ.TM_END-PX_POZ.TM_START;
      _tm_start_old:=PX_POZ.TM_START;
      _tm_end_old:=PX_POZ.TM_END;

      {? _del_delay>0
      ||
::       Aktualizuje status pozycji planu - byc moze po przesunieciu nie bedzie juz opozniona
         {? PX_CUP.TM_END>PX_CUP.tm_stamp()
         || exec('status_set','px_poz',PX_POZ.ref(),exec('status_normal','px_poz'))
         ?}
      ?};

::    Sprawdzam czy wymagane bedzie scalenie pozycji planu i od razu scalam jesli trzeba
      _merged_with:=null();
      _status_updated:=0;
      {? PX_VAR.NAST_ALG=2
      ||
::       Tutaj potrzebuję status zaktualizować najpierw, bo reszta funkcji działa w oparciu o to
         {? exec('status_update','px_poz',PX_POZ.ref())>0
         || _status_updated:=1
         ?};
         {? PX_POZ.STATUS=exec('status_wyk2','px_poz')
         || _merged_with:=exec('merge_complete','px_poz',PX_CUP.ref(),PX_POZ.ref())
         ?}
      || _merged_with:=exec('merge_complete','px_poz',PX_CUP.ref(),PX_POZ.ref())
      ?};

      {? _merged_with=null()
      ||
::       !!! BRAK SCALANIA, PO PROSTU PRZESUWAM !!!
         _argspoz:=exec('blank_a','px_poz');
         _old_cup:=PX_POZ.PX_CUP;
         exec('record2args','px_poz',_argspoz);
         _argspoz.PX_VER:=PX_CUP.PX_VER;
         _argspoz.PX_KONT:=PX_CUP.PX_KONT;
         _argspoz.PX_CUP:=PX_CUP.ref();
         _argspoz.STARTD:=PX_CUP.STARTD;
         _argspoz.ENDD:=PX_CUP.ENDD;
         {? _lp<>-9999
         || _argspoz.LP:=_lp
         ?};
         {? PX_VAR.NAST_ALG=2
         ||
            {? _cup_src<>_cup_dst
            || exec('set_new_time','px_poz',,_argspoz)
            ?}
         || _argspoz.TM_START:=PX_CUP.TM_START;
            _argspoz.TM_END:=PX_CUP.TM_END
         ?};
         {? _tm_start_old<>_argspoz.TM_START | _tm_end_old<>_argspoz.TM_END
         || _argspoz.DATE_MIN:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_START);
            _argspoz.TIME_MIN:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_START);
            _argspoz.DATE_MAX:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_END);
            _argspoz.TIME_MAX:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_END)
         ?};

         _can_continue:=exec('update','px_poz',_argspoz);
         {? _can_continue>0
         ||
            _result:=PX_POZ.ref();

::          uruchamiam formule po wlaniu
            exec('po_wlaniu','px_logix',_cup_dst,_argspoz);

::          uruchamiam formule po wylaniu
            exec('po_wylaniu','px_logix',_old_cup,_argspoz);

::          aktualizacja statusu
            {? _status_updated=0
            || exec('status_update','px_poz',PX_POZ.ref())
            ?};

            {? PX_VAR.NAST_ALG=2
            || {? _cup_src<>_cup_dst
               || exec('rebuild4cup','px_cal',_cup_dst,0)
               ?}
            ?}
         ?}
      || _result:=_merged_with
      ?};

::    Aktualizuje pojemnosc na pojemniku zrodlowym
      exec('update','px_cup',_cup_src,0);

::    Aktualizuje pojemnosc na pojemniku docelowym
      exec('update','px_cup',_cup_dst,0)
   ?}
?};
PX_KONT.cntx_pop();
PX_CUP.cntx_pop();
PX_POZ.cntx_pop();
_result


\block
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Blokuje pozycje planu
::   WE: [_a] - PX_POZ.ref() - pozycja ktora zablokowac lub biezacy rekord
::   WY: 0 - zguba
::       1 - zwyciestwo
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_POZ.cntx_psh();
{? _ref<>null()
|| PX_POZ.clear();
   {? PX_POZ.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _can_block:=1;

:: Nie moge blokowac pozycji planu opoznionych, wykonywanych lub wykonanych
   {? PX_POZ.STATUS=exec('status_delay','px_poz')
   || _can_block:=0
   ?};
   {? PX_POZ.STATUS=exec('status_wyk1','px_poz')
   || _can_block:=0
   ?};
   {? PX_POZ.STATUS=exec('status_wyk2','px_poz')
   || _can_block:=0
   ?};

   {? _can_block>0
   ||
      PX_POZ.BLK:='T';
      _result:=PX_POZ.put()
   ?}
?};
PX_POZ.cntx_pop();
_result


\unblock
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Odblokowuje pozycje planu
::   WE: _a - PX_POZ.ref() - pozycja ktora odblokowac
::   WY: 0 - zguba
::       1 - zwyciestwo
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_POZ.cntx_psh();
{? _ref<>null()
|| PX_POZ.clear();
   {? PX_POZ.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||  PX_POZ.BLK:='N';
   _result:=PX_POZ.put()
?};
PX_POZ.cntx_pop();
_result


\px_poz_grp_move
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Przepina pozycje planu o danym statusie z jednego PX_GRP do drugiego
::   WE: _a - PX_GRP.ref() - źródłowy PX_GRP
::       _b - PX_GRP.ref() - docelowy PX_GRP
::       [_c] - STRING - status jakiego pozycje planu przepiac
::       [_d] - REAL - tm_stamp czasu ktory jest granica okreslajaca ze tylko ponizej tej granicy przepinam pozycje planu
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_source:=_a;
_dest:=_b;
_status:='';
_result:=0;
_time_border:=0;

{? var_pres('_c')=type_of('')
|| _status:=_c
?};
{? var_pres('_d')=type_of(0)
|| _time_border:=_d
?};

PX_GRP.cntx_psh();
PX_POZ.cntx_psh();
PX_GRP.clear();
{? PX_GRP.seek(_dest)
||
   {? _status<>''
   || {? _status=exec('status_blk','px_poz')
      ||
         PX_POZ.index('BLK3');
         PX_POZ.prefix(_source,'T')
      ||
         PX_POZ.index('STATUS3');
         PX_POZ.prefix(_source,_status)
      ?}
   || PX_POZ.index('STATUS3');
      PX_POZ.prefix(_source)
   ?};
:: Petla wykluczajaca elementy
   _can_continue:=1;
   {? PX_POZ.first()
   || {!
      |?
         _next:=0;
         _chk_border:=0;
         {? PX_POZ.TM_END<=_time_border
         || _chk_border:=1
         ?};

::       jesli granica czasowa podana to przepinam tylko te pozycje planu ktore sa w przeszlosci wzgledem granicy
         {? _time_border=0 | _chk_border>0
         ||
::          Przepinam pozycje planu do innego PX_GRP i do jego wersji
            PX_POZ.cntx_psh();
            PX_POZ.clear();
            PX_POZ.PX_GRP:=PX_GRP.ref();
            PX_POZ.PX_VER:=PX_GRP.PX_VER;
            _can_continue:=PX_POZ.put();

::          Przepinam tez komunikatom nalezacym do PX_POZa
            {? _can_continue>0
            || exec('komm4poz_move','px_komm',PX_POZ.ref(),PX_POZ.PX_GRP,PX_POZ.PX_VER)
            ?};

            PX_POZ.cntx_pop();
            {? _can_continue>0
            || _next:=PX_POZ.first()
            ?}
         || _next:=PX_POZ.next()
         ?};
         _next>0
      !}
   ?};
   {? _can_continue>0
   || _result:=1
   ?}
?};
PX_POZ.cntx_pop();
PX_GRP.cntx_pop();
_result


\today_move
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Przepina pozycje planu z biezacego pojemnika z jednego PX_GRP do drugiego
::   WE: _a - PX_GRP.ref() - źródłowy PX_GRP
::       _b - PX_GRP.ref() - docelowy PX_GRP
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_source:=_a;
_dest:=_b;

_result:=0;
_can_continue:=1;

PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');
PX_POZ.cntx_psh();
PX_POZ.index('TM_VOBJ2');
PX_GRP.cntx_psh(); PX_GRP.clear();
{? PX_GRP.seek(_source)
||
   {? PX_CONN.first()
   ||
      _int_poz:=exec('interval','#interval');
      _int_now:=exec('interval','#interval');
      _int_now.START:=SYSLOG.tm_stamp();
      _int_now.END:=SYSLOG.tm_stamp();
      {!
      |?
         _next:=0;
         PX_POZ.prefix(PX_GRP.PX_VER,PX_CONN.PX_OBJ);
         {? PX_POZ.find_ge(SYSLOG.tm_stamp())
         ||
            {!
            |?
               _ref_nxt:=null();
::             Sprawdzam czy pozycja planu 'dzisiaj'
               _int_poz.START:=PX_POZ.TM_START;
               _int_poz.END:=PX_POZ.TM_END;

               {? exec('intervals_chk','#interval',_int_poz,_int_now)=2
               ||
                  PX_POZ.cntx_psh();
                  {? PX_POZ.next()
                  || _ref_nxt:=PX_POZ.ref()
                  ?};
                  PX_POZ.cntx_pop();

                  PX_POZ.cntx_psh();
                  PX_POZ.clear();
                  PX_POZ.PX_GRP:=_dest;
                  PX_POZ.PX_VER:=exec('FindAndGet','#table',PX_GRP,_dest,,"PX_VER",null());
                  _can_continue:=PX_POZ.put();
                  PX_POZ.cntx_pop();

                  {? _ref_nxt<>null()
                  || _next:=PX_POZ.seek(_ref_nxt)
                  || _next:=0
                  ?}
               ||
::                Pozycja planu nie dzisiaj wiec moge przerwac przetwarzanie, bo nastepne
::                wg indeksu pozycje na bank nie beda dzisiaj
                  _next:=0
               ?};
               _next>0
            !}
         ?};
         PX_CONN.next() & _can_continue>0
      !}
   ?}
?};

PX_GRP.cntx_pop();
PX_POZ.cntx_pop();
PX_CONN.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\is_today
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy pozycja planu znajduje sie na biezacym pojemniku
::   WE: [_a] - PX_POZ.ref - pozycja ktora sprawdzac lub biezacy rekord
::   WY: 0 - pozycja nie znajduje sie na biezacym pojemniku
::       1 - znajduje sie
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_POZ.cntx_psh();
{? _ref<>null()
|| PX_POZ.clear();
   {? PX_POZ.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _int_poz:=exec('interval','#interval');
   _int_poz.START:=PX_POZ.TM_START;
   _int_poz.END:=PX_POZ.TM_END;
   _int_now:=exec('interval','#interval');
   _int_now.START:=SYSLOG.tm_stamp();
   _int_now.END:=SYSLOG.tm_stamp();

   {? exec('intervals_chk','#interval',_int_poz,_int_now)=2
   || _result:=1
   ?}
?};
PX_POZ.cntx_pop();
_result


\count_today
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Zlicza ilosci na px_pozach znajdujacych sie na biezacym pojemniku.
::   WE: _a - PX_GRP.UID - unikalny symbol obiektu grupujacego
::       _b - PX_STAGE.ref() - operacja/etap
::       _c - PX_KONT.UID - kontener
::   WY: obj_new(exec('il_wym','px_param')) - tablica z ilosciami danego statusu we wszystkich wymiarach
::----------------------------------------------------------------------------------------------------------------------
_uid_grp:=_a;
_stage:=_b;
_uid_kont:=_c;

_il_wym:=exec('il_wym','px_param');

_result:=obj_new(_il_wym);
{! _it:=1.._il_wym
|! _result[_it]:=0
!};

PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');
PX_GRP.cntx_psh();
PX_STAGE.cntx_psh();
PX_KONT.cntx_psh();
PX_POZ.cntx_psh();
PX_POZ.index('PX_GRP3');
PX_GRP.index('UID');

{? _uid_grp<>''
||
   PX_GRP.prefix(_uid_grp);

   {? PX_GRP.first()
   ||
      _int_poz:=exec('interval','#interval');
      _int_now:=exec('interval','#interval');
      _int_now.START:=SYSLOG.tm_stamp();
      _int_now.END:=SYSLOG.tm_stamp();

      _px_kont:=null();
      PX_KONT.index('UID');
      PX_KONT.prefix(_uid_kont);
      {? PX_KONT.first()
      || _px_kont:=PX_KONT.ref()
      ?};
      _next:=0;
      PX_POZ.prefix(PX_GRP.ref(),_px_kont,_stage);
      {? PX_POZ.find_ge(SYSLOG.tm_stamp())
      ||
         {!
         |?
::          Sprawdzam czy pozycja planu 'dzisiaj'
            _int_poz.START:=PX_POZ.TM_START;
            _int_poz.END:=PX_POZ.TM_END;

            {? exec('intervals_chk','#interval',_int_poz,_int_now)=2
            ||
::             Zliczam tylko te o statusie normalnym i niezablokowane, poniewaz
::             tamte zostana zliczone innymi formulami
               {? PX_POZ.STATUS=exec('status_normal','px_poz') & PX_POZ.BLK<>'T'
               ||
                  {! _it:=1.._il_wym
                  |! _rule:=$('_result:=_a;_result['+$_it+']+=PX_POZ.CAP_EAT'+$_it);
                     _rule(_result)
                  !}
               ?};
               _next:=PX_POZ.next()
            ||
::             Pozycja planu nie dzisiaj wiec moge przerwac przetwarzanie, bo nastepne
::             wg indeksu pozycje na bank nie beda dzisiaj
               _next:=0
            ?};
            _next>0
         !}
      ?}
   ?}
?};
PX_CONN.cntx_pop();
PX_POZ.cntx_pop();
PX_KONT.cntx_pop();
PX_STAGE.cntx_pop();
PX_GRP.cntx_pop();
_result


\split_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Tablica parametrów dla split
::   WY: _args:=obj_new('SRC_POZ',
::                      'SRC_STAT',
::                      'DST_STAT',
::                      'DST_CUP',
::                      'SPLITWYK',
::                      'MOVE_WYK');
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('SRC_POZ',
               'SRC_STAT',
               'DST_STAT',
               'DST_CUP',
               'SPLITWYK',
               'MOVE_WYK',
               'MERGE');
_args.SRC_POZ:=null();
_args.SRC_STAT:='';
_args.DST_STAT:='';
_args.DST_CUP:=null();

:: czy podczas dzielenia pozycji planu dzielic tez wykonania
_args.SPLITWYK:=0;

:: ref wykonania ktory przepiac na splita
_args.MOVE_WYK:=null();

:: czy w przypadku gdy nowo utworzona pozycja planu nie jest przesuwana na inny pojemnik
:: próbować scalić ją w bieżącym pojemniku z inną pozycją
_args.MERGE:=1;

:: zwracamy deklaracje argumentow
_args


\split
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dzieli PX_POZa na dwa kawalki, przy okazji moze przeniesc nowo utworzony kawalek na nowy pojemnik
::       Funkcja moze dzielic wykonania, ale jezeli nie bedzie dzielic to wykonania pozostaja na zrodlowej pozycji
::   WE: _a: _args - wynik formuly exec('split_a','px_poz')
::       _b: obj_new(x) - tablica z ilosciami dla PX_POZ.CAP_EATx ktore maja zostac na starym kawalku
::   WY: null() - dzielenie zakonczone niepowodzeniem
::       PX_POZ.ref - ref nowego kawalka, lub kawalka z ktorym scalono nowo utworzony
::                   (w przypadku jednoczesnego przesuwania)
::----------------------------------------------------------------------------------------------------------------------
_args:={?_>=1 || _a || exec('split_a','px_poz') ?};

{? var_pres('_b')=type_of(obj_new(1))
|| _ilosci:=_b
?};

_can_continue:=0;
_result:=null();

PX_POZ.cntx_psh();
PX_POZ.clear();
{? PX_POZ.seek(_args.SRC_POZ)
||
:: inicjalizacja tablicy nazwanej do aktualizacji px_poza
   _argsupdate:=exec('blank_a','px_poz');
   _argsclone:=exec('blank_a','px_poz');
:: inicjuje tablice nazwana rekordem w buforze
   exec('record2args','px_poz',_argsupdate);
   exec('record2args','px_poz',_argsclone);

   _cap_before:=exec('count_eat','px_poz',_args.SRC_POZ);

   {? _args.DST_STAT<>''
   || _argsclone.STATUS:=_args.DST_STAT
   ?};

:: Tworze nowa pozycje planu tylko wtedy jezeli ilosci na starej pozycji maja pozostac wieksze od zera
:: w przeciwnym wypadku nie tworze nowej pozycji planu, zostawiam stara, ktora ewentualnie przesuwam
   {? exec('array_sum','#array',_ilosci)>0
   ||
      _il_wym:=PX_POZ.PX_KONT().IL_WYM;
      _split_il:=obj_new(_il_wym);
      {! _it:=1.._il_wym
      |! _rule:=$('
                     _il:=_a;
                     _argsupdate:=_b;
                     _argsclone:=_c;

::                   Na starej pozycji planu nie moze byc mniej niz zero
                     _il:=exec(\'max\',\'#math\',0,_il);

::                   Zrodlowa pozycja planu po podzieleniu nie moze miec wiecej niz miala
::                   bo wtedy dzielenie nie ma sensu
                     _cap_old:=_argsupdate.CAP_EAT'+$_it+';
                     _cap_src:=exec(\'min\',\'#math\',_cap_old,_il);

                     _eat:=PX_POZ.CAP_EAT'+$_it+';
::                   obliczam ilosc dla nowej pozycji
                     _diff:=_eat-_cap_src;
::                   ilosc nowej pozycji nie moze byc ujemna
                     {? _diff<0
                     || _diff:=0
                     ?};
                     _argsclone.CAP_EAT'+$_it+':=_diff;
::                   nowej pozycji planu resetuje wykonania
                     _argsclone.CAP_WYK'+$_it+':=0;

::                   zrodlowej pozycji planu ustawiam nowe pojemnosci
                     {? _argsupdate.CAP_EAT'+$_it+'>0
                     || _argsupdate.CAP_EAT'+$_it+':=_cap_src
                     ?}
                  ');
         _rule(_ilosci[_it],_argsupdate,_argsclone)
      !};
::    uaktualniam ilosci na zrodlowej pozycji planu
      _can_continue:=exec('update','px_poz',_argsupdate);

::    Zrodlowej pozycji nadaje nowy status
      {? _args.SRC_STAT<>''
      || _can_continue:=exec('status_set','px_poz',_args.SRC_POZ,_args.SRC_STAT)
      ?};

      {? _can_continue>0
      ||
::       Tworze nowy kawalek
         _can_continue:=exec('add','px_poz',_argsclone);
         {? _can_continue>0
         ||
            _new_poz:=PX_POZ.ref();
            _result:=_new_poz;

::          Obsluga wykonan
            {? _args.SPLITWYK>0
            ||
::             Jesli dzielic tez wykonania to robie to, jesli nie to wykonania zostaja na zrodlowej pozycji
               exec('split_wyk','px_poz',_args.SRC_POZ,PX_POZ.ref(),_cap_before)
            |? _args.MOVE_WYK<>null()
            ||
::             Jesli mam przesunac jedno konkretne wykonanie to to robie
               exec('move','px_wyk',_args.MOVE_WYK,_new_poz)
            ?};

::          Przesuwam nowy kawalek
            {? _args.DST_CUP<>null() & _args.DST_CUP<>_argsclone.PX_CUP
            || _new_poz:=exec('move','px_poz',PX_POZ.ref(),_args.DST_CUP);
               {? _new_poz<>null()
               || _result:=_new_poz
               || _can_continue:=0;
                  _result:=null()
               ?}
            ||
::             jesli nigdzie nie przesuwam to byc moze trzeba scalic nowy kawalek z juz istniejacym
               {? _args.MERGE>0
               || _merged:=exec('merge_complete','px_poz',PX_POZ.PX_CUP,PX_POZ.ref());
                  {? _merged<>null()
                  || _result:=_merged
                  ?}
               ?};

::             jesli nigdzie nie przesunalem to musze zregenerowac kolejnosc na kafelku
::             bo w przeciwnym razie na kafelku po sklonowaniu beda dwie pozycje planu o tym
::             samym numerze porzadkowym
               exec('renumerate','px_poz',PX_POZ.PX_CUP)
            ?};
::          Aktualizuje wykonania i status nowo utworzonego kawalka - na wszelki wypadek
            {? _can_continue>0
            || exec('px_poz_update','px_wyk',_new_poz)
            ?}
         ?}
      ?};
::    Aktualizuje wykonania i status kawalka zrodlowego
      exec('px_poz_update','px_wyk',_args.SRC_POZ)
   ||
::    Przypadek w ktorym ktos chce uzyc splita jak move - czyli podal zerowe ilosci dla starej czesci
::    ale podal tez docelowy pojemnik, rozny od obecnego
      {? _args.DST_CUP<>null() & _args.DST_CUP<>PX_POZ.PX_CUP
      || _new_poz:=exec('move','px_poz',PX_POZ.ref(),_args.DST_CUP);
         {? _new_poz<>null()
         || _result:=_new_poz
         || _can_continue:=0;
            _result:=null()
         ?}
      ?}
   ?}
?};
PX_POZ.cntx_pop();
PX_POZ.get();
_result


\count_eat
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Oblicza ilosci zajmowane przez pozycje planu
::   WE: _a - PX_POZ.ref() - pozycja planu ktorej ilosci obliczyc
::   WY: obj_new(x) - wynikowa tablica z obliczonymi ilosciami
::----------------------------------------------------------------------------------------------------------------------
_px_poz:=_a;
_result:=~~;

PX_KONT.cntx_psh();
PX_POZ.cntx_psh();
PX_POZ.clear();
{? PX_POZ.seek(_px_poz)
|| _il_wym:=PX_POZ.PX_KONT().IL_WYM;
   _result:=obj_new(_il_wym);
   {! _it:=1.._il_wym
   |! _result[_it]:=($('PX_POZ.CAP_EAT'+$_it))()
   !}
?};
PX_POZ.cntx_pop();
PX_KONT.cntx_pop();
_result


\count_wyk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Oblicza ilosci wykonane na pozycji planu
::   WE: _a - PX_POZ.ref() - pozycja planu ktorej ilosci obliczyc
::   WY: obj_new(x) - wynikowa tablica z obliczonymi ilosciami
::----------------------------------------------------------------------------------------------------------------------
_px_poz:=_a;
_result:=~~;

PX_KONT.cntx_psh();
PX_POZ.cntx_psh();
PX_POZ.clear();
{? PX_POZ.seek(_px_poz)
|| _il_wym:=PX_POZ.PX_KONT().IL_WYM;
   _precision:=exec('precision_array','px_kont',PX_POZ.PX_KONT);
   _result:=obj_new(_il_wym);
   {! _it:=1.._il_wym
   |! _result[_it]:=($('_prec:=_a;PX_POZ.CAP_WYK'+$_it+'$_prec'))(_precision[_it])
   !}
?};
PX_POZ.cntx_pop();
PX_KONT.cntx_pop();
_result


\select_grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Selekcja pozycji planu od strony grupy obiektow w kolejce
::----------------------------------------------------------------------------------------------------------------------
Cntx.psh(PX_OBJ,PX_POZ,PX_CUP);

_Tab:=
   {? exec('is_one_version','px_param')
   || exec('tab','px_grps')
   || PxSelect.Pxgrp.TAB
   ?};

PX_GRP.clear();
PX_CUP.blank();
PX_OBJ.blank();
{? PX_GRP.seek(_Tab.PX_GRPI,8+_Tab.PX_GRPI)
||
   _prefix_mode:=exec('poz_prefix_mode','px_grp');
   {? _prefix_mode='SOURCE'
   || PX_GRP.index('UID');
      PX_GRP.prefix(PX_GRP.UID_SRC);
      {? PX_GRP.first()
      ||
         PX_POZ.index('TM_GRP');
         PX_POZ.prefix(PX_GRP.ref());
         PX_POZ.win_sel('WER_GRP');
         PX_POZ.hdr_sel('Pozycje planu dla grupy %1'@[PX_GRP.SYMBOL]);
         PX_POZ.select()
      ?}
   || PX_POZ.index('TM_GRP');
      PX_POZ.prefix(PX_GRP.ref());
      PX_POZ.win_sel('WER_GRP');
      PX_POZ.hdr_sel('Pozycje planu dla grupy %1'@[PX_GRP.SYMBOL]);
      PX_POZ.select()
   ?}
?};

Cntx.pop(PX_OBJ,PX_POZ,PX_CUP);
~~


\status_update
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Uaktualnia status pozycji planu na podstawie wykonan itp.
::   WE: _a - PX_POZ.ref()
::       [_b] - obj_new() - bufor usuwanego PX_WYKa
::       [_c] - INTEGER - 0/[1] - czy pozwalać na status opóźniony
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_pxpoz:=_a;

_buf_wyk:=~~;
{? var_pres('_b')>100
|| _buf_wyk:=_b
?};
_allow_delay:=1;
{? var_pres('_c')=type_of(0)
|| _allow_delay:=_c
?};

_result:=0;
_can_continue:=1;

_stat_before:='';

PX_POZ.cntx_psh();
PX_POZ.clear();
{? PX_POZ.seek(_pxpoz)
||
   _merge:=0;
   _dlay_bef:={? PX_POZ.STATUS=exec('status_delay','px_poz')
              || 1
              || 0
              ?};
:: 0. Resetuje status na normalny
   {? PX_POZ.STATUS<>exec('status_delay','px_poz')
   || _can_continue:=exec('status_set','px_poz',PX_POZ.ref(),exec('status_normal','px_poz'))
   ?};
   {? _can_continue>0
   ||
::    1. Status wykonane
      {? exec('px_poz_made','px_poz')
      || _can_continue:=exec('status_set','px_poz',PX_POZ.ref(),exec('status_wyk2','px_poz'))
      ?};
::    2. Status opoznione
      {? PX_POZ.STATUS=exec('status_normal','px_poz') | PX_POZ.STATUS=exec('status_delay','px_poz')
      ||
::       Sprawdzam czy pozycja byla przesuwana w wyniku nadwykonan
         _nadwykon:=exec('nadwykon_moved','px_poz');
         _making:=exec('px_poz_making','px_poz');
         {? _nadwykon=0 & PX_POZ.TM_END<PX_POZ.tm_stamp() & PX_POZ.SRC_OPER<>'T' & _allow_delay>0 & exec('get','#params',500392)='T'
         ||
::          Jesli jest opoznione, ale czesciowo wykonane to dziele ta pozycje na dwa kawalki
::          1. w calosci wykonany
::          2. opozniony, w ogole nie wykonywany
            {? _making>0
            ||
               _argsplit:=exec('split_a','px_poz');
               _argsplit.SRC_POZ:=PX_POZ.ref();
               _argsplit.DST_STAT:=exec('status_delay','px_poz');
               _argsplit.SRC_STAT:=exec('status_wyk2','px_poz');
               _wyk:=exec('count_wyk','px_poz',PX_POZ.ref());

::             dzielenie pozycji planu
               _splitres:=exec('split','px_poz',_argsplit,_wyk);
               {? _splitres=null()
               || _can_continue:=0
               || _can_continue:=1
               ?}
            || _can_continue:=exec('status_set','px_poz',PX_POZ.ref(),exec('status_delay','px_poz'))
            ?}
         ?};

         {? _nadwykon>0 & _making>0
         ||
::          Pozycja byla przesuwana w wyniku nadwykonan i jest czesciowo wykonana
::          Trzeba ja podzielic na dwa kawalki:
::          1. W calosci wykonany
::          2. Normalny, bez wykonan ktory zostanie przeplanowany (nie moze sie opoznic)
            _argsplit:=exec('split_a','px_poz');
            _argsplit.SRC_POZ:=PX_POZ.ref();
            _argsplit.SRC_STAT:=exec('status_wyk2','px_poz');
            _wyk:=exec('count_wyk','px_poz',PX_POZ.ref());

::          dzielenie pozycji planu
            _splitres:=exec('split','px_poz',_argsplit,_wyk);
            {? _splitres=null()
            || _can_continue:=0
            || _can_continue:=1
            ?}
         ?}
      ?};
::    3. Status wykonywane
      {? PX_POZ.STATUS=exec('status_normal','px_poz')
      || {? exec('px_poz_making','px_poz')>0
         || _can_continue:=exec('status_set','px_poz',PX_POZ.ref(),exec('status_wyk1','px_poz'))
         ?}
      ?};
      {? _can_continue>0
      ||
::       jesli status opozniony, wykonywany lub wykonany to musze zdjac z pozycji planu
::       znacznik blokada po to by algorytm planujacy nie zaplanowal tej pozycji planu dwa razy
         {? PX_POZ.STATUS=exec('status_delay','px_poz') |
            PX_POZ.STATUS=exec('status_wyk1','px_poz') |
            PX_POZ.STATUS=exec('status_wyk2','px_poz')
         || _can_continue:=exec('unblock','px_poz',PX_POZ.ref())
         ?};
::       Jezeli status normalny, ale PX_GRP zablokowany to przywracam znacznik blokady dla PX_POZ
         {? PX_POZ.STATUS=exec('status_normal','px_poz')
         ||
            {? PX_POZ.PX_GRP<>null()
            ||
               PX_GRP.cntx_psh();
               {? PX_POZ.PX_GRP().BLK='T'
               || _can_continue:=exec('block','px_poz',PX_POZ.ref())
               ?};
               PX_GRP.cntx_pop()
            ?}
         ?}
      ?};
      _dlay_aft:={? PX_POZ.STATUS=exec('status_delay','px_poz')
                 || 1
                 || 0
                 ?};
      {? _can_continue>0
      ||
         {? _dlay_bef<>_dlay_aft
         ||
::          jesli zmienil sie status po wzgledem opoznien, to byc moze trzeba scalic ta pozycje planu
::          z inna pozycja planu, do tej pory mialy rozne statusy wiec mogly zyc osobno,
::          teraz trzeba sprawdzic czy nie nalezy dokonac scalenia
            _new_poz:=exec('merge_complete','px_poz',PX_POZ.PX_CUP,PX_POZ.ref());

            {? _new_poz<>null & var_pres('_buf_wyk')>100
            ||
::             Jeżeli usuwany był PX_WYK to do jego bufora przekazuję nowy ref PX_POZa
::             po to aby funkcje aktualizujące PX_WYKi mogły sobie wykorzystać fakt że być
::             może powstała nowa pozycja planu w wyniku mergowania
               _buf_wyk.PX_POZ:=_new_poz
            ?}
         ?}
      ?}
   ?}
?};
PX_POZ.cntx_pop();
PX_POZ.get();

{? _can_continue>0
|| _result:=1
?};
_result


\merge_needed
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy do danego pojemnika mozna przesunac pozycje planu, czy mozna ja scalic
::       z pozycja planu ktora dotyczy tego samego:
::          - PX_GRP.ref()
::          - PX_STAGE.ref()
::          - PX_OBJ.ref()
::
::   WE: _a - PX_CUP.ref() - pojemnik na ktory przesuwam pozycje planu
::       _b - PX_POZ.ref() - pozycja planu ktora jest przesuwana
::   WY: null() - scalanie nie jest potrzebne, mozna przesunac pozycje planu
::       PX_POZ.ref() - wymagane jest scalenie przesuwanej pozycji z ta pozycja
::----------------------------------------------------------------------------------------------------------------------
_px_cup:=_a;
_px_poz:=_b;
_result:=null();

PX_POZ.cntx_psh();
PX_POZ.clear();
{? PX_POZ.seek(_px_poz)
|| _px_grp:=PX_POZ.PX_GRP;
   _px_stage:=PX_POZ.PX_STAGE;
   _status:=PX_POZ.STATUS;
   _px_obj:=PX_POZ.PX_OBJ;
   _pl_oper:=PX_POZ.PL_OPER;
   _pl_ogr:=PX_POZ.PL_OGR;
   _tm_src:=PX_POZ.TM_SRC;

::   _pl_oper:=null();
::   _pl_ogr:=null();

   _merge_with:=exec('merge_needed2','px_poz',_px_cup
                                             ,_px_grp
                                             ,_px_stage
                                             ,_status
                                             ,_px_obj
                                             ,_tm_src
                                             ,_px_poz
                                             ,_pl_oper
                                             ,_pl_ogr);
   _result:=_merge_with
?};
PX_POZ.cntx_pop();
_result


\merge_needed2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy w danym pojemniku bedzie konieczne scalenie pozycji planu o podanych wlasciwosciach
::   WE: _a - PX_CUP.ref() - pojemnik w ktorym sprawdzam
::       _b - PX_GRP.ref()
::       _c - PX_STAGE.ref()
::       _d - STRING - Status
::       _e - PX_OBJ.ref()
::       _f - REAL - tm_stamp zrodlowego pojemnika z ktorego pochodzi pozycja (obsluga nadwykonan)
::       [_g] - PX_POZ.ref() -   pozycja planu ktorej nie brac pod uwage w poszukiwaniu
::                               (wazne podczas sprawdzania czy jakas pozycje na pojemniku
::                               mozna scalic z inna, np po zmianie statusu)
::       [_h] - PL_OPER.ref() - PL_OPER powiazany z PX_POZ
::       [_i] - PL_OGR.ref() - PL_OGR powiazany z PX_POZ
::   WY: null() - scalanie nie jest potrzebne, mozna przesunac pozycje planu
::       PX_POZ.ref() - wymagane jest scalenie przesuwanej pozycji z ta pozycja
::----------------------------------------------------------------------------------------------------------------------
_px_cup:=_a;
_px_grp:=_b;
_px_stage:=_c;
_status:=_d;
_px_obj:=_e;
_tm_src:=_f;

_skip_poz:=null();
{? var_pres('_g')=type_of(SYSLOG.ref())
|| _skip_poz:=_g
?};

_pl_oper:=null();
{? var_pres('_h')=type_of(PL_OPER.ref())
|| _pl_oper:=_h
?};
_pl_ogr:=null();
{? var_pres('_i')=type_of(PL_OGR.ref())
|| _pl_ogr:=_i
?};

_result:=null();

PX_CUP.cntx_psh();
PX_POZ.cntx_psh();
PX_CUP.clear();
{? PX_CUP.seek(_px_cup)
||
   PX_POZ.index('PX_STAGE');
   _can_continue:=1;

   {? _status=exec('status_delay','px_poz')
   ||
::    Opoznione scalam tylko do opoznionych
      {? _pl_oper<>null() | _pl_ogr<>null()
      ||
::       Pozycje planu ktore powstaly na podstawie Planu operacyjnego
         _can_continue:=exec('find_in_cup_ope','px_poz',_pl_oper,_pl_ogr,_skip_poz,_status,_px_obj,_tm_src)
      ||
::       Normalne pozycje z Planu strategicznego
         _can_continue:=exec('find_in_cup','px_poz',_px_grp,_px_stage,_skip_poz,_status,_px_obj,_tm_src)
      ?};
      {? _can_continue>0
      || _result:=PX_POZ.ref()
      ?}
   ||
::    Nie opoznione moge scalic do:
::       - normalnych
::       - wykonywanych
::       - wykonanych

::    --- Normalne ---
      {? _result=null()
      || _status:=exec('status_normal','px_poz');

         {? _pl_oper<>null() | _pl_ogr<>null()
         ||
::          Pozycje planu ktore powstaly na podstawie Planu operacyjnego
            _can_continue:=exec('find_in_cup_ope','px_poz',_pl_oper,_pl_ogr,_skip_poz,_status,_px_obj,_tm_src)
         ||
::          Normalne pozycje z Planu strategicznego
            _can_continue:=exec('find_in_cup','px_poz',_px_grp,_px_stage,_skip_poz,_status,_px_obj,_tm_src)
         ?};

         {? _can_continue>0
         || _result:=PX_POZ.ref()
         ?}
      ?};
::    --- Wykonywane ---
      {? _result=null()
      || _status:=exec('status_wyk1','px_poz');

         {? _pl_oper<>null() | _pl_ogr<>null()
         ||
::       Pozycje planu ktore powstaly na podstawie Planu operacyjnego
            _can_continue:=exec('find_in_cup_ope','px_poz',_pl_oper,_pl_ogr,_skip_poz,_status,_px_obj,_tm_src)
         ||
::       Normalne pozycje z Planu strategicznego
            _can_continue:=exec('find_in_cup','px_poz',_px_grp,_px_stage,_skip_poz,_status,_px_obj,_tm_src)
         ?};

         {? _can_continue>0
         || _result:=PX_POZ.ref()
         ?}
      ?};
::    --- Wykonane ---
      {? _result=null()
      || _status:=exec('status_wyk2','px_poz');

         {? _pl_oper<>null() | _pl_ogr<>null()
         ||
::          Pozycje planu ktore powstaly na podstawie Planu operacyjnego
            _can_continue:=exec('find_in_cup_ope','px_poz',_pl_oper,_pl_ogr,_skip_poz,_status,_px_obj,_tm_src)
         ||
::          Normalne pozycje z Planu strategicznego
            _can_continue:=exec('find_in_cup','px_poz',_px_grp,_px_stage,_skip_poz,_status,_px_obj,_tm_src)
         ?};

         {? _can_continue>0
         || _result:=PX_POZ.ref()
         ?}
      ?}
   ?}
?};
PX_POZ.cntx_pop();
PX_CUP.cntx_pop();
_result


\merge_complete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Jesli potrzeba to scala podana pozycja planu z inna pozycja na pojemniku
::   WE: _a - PX_CUP.ref() - pojemnik na ktorym poszukac pasujacej pozycji planu
::       _b - PX_POZ.ref() - scalana pozycja planu
::   WY: null() - nie scalono
::       PX_POZ.ref() - ref pozycji planu z ktora scalono podana pozycje, nawet jesli scalono czesc
::----------------------------------------------------------------------------------------------------------------------
_px_cup:=_a;
_px_poz:=_b;


_result:=null();
PX_POZ.cntx_psh();
PX_POZ.clear();
{? PX_POZ.seek(_px_poz)
||
   _old_cup:=PX_POZ.PX_CUP;
   _merge_with:=exec('merge_needed','px_poz',_px_cup,_px_poz);
   {? _merge_with<>null() & _merge_with<>_px_poz
   ||
      _merged:=exec('merge','px_poz',_merge_with,_px_poz);
      _sum_m:=exec('array_sum','#array',_merged);
      {? _sum_m>0
      ||
         _result:=_merge_with;

::       Po scaleniu musze sprawdzic czy calosc zostala scalona, czyli czy moge usunac zrodlowa
::       pozycje planu, czy musze ja zostawic ale zmodyfikowac jej ilosci
         _cap_src:=exec('count_eat','px_poz',_px_poz);

         _sum_src:=exec('array_sum','#array',_cap_src);
         {? _sum_m=_sum_src
         ||
::          Calosc zostala scalona, usuwam scalana pozycje planu
            _can_continue:=exec('delete','px_poz',_px_poz,1)
         ||
::          Udalo sie scalic tylko czesc, przesuwana pozycja planu zostanie zmodyfikowana
            _il_wym:=PX_POZ.PX_KONT().IL_WYM;
            _argspoz:=exec('blank_a','px_poz');
            _argswyl:=exec('blank_a','px_poz');
            exec('record2args','px_poz',_argspoz);
            exec('record2args','px_poz',_argswyl);

::          Obliczam nowe ilosci dla pozycji planu
            {! _it:=1.._il_wym
            |!
               _rule:=$('
                           _argspoz:=_a;
                           _merged:=_b;

                           _new_cap:=PX_POZ.CAP_EAT'+$_it+'-_merged;
                           _argspoz.CAP_EAT'+$_it+':=_new_cap;
::                         z roznych zaokraglen moze wynikac ze ilosc jest mniejsza od zera,
::                         nie mozna do tego dopuscic
                           {? _argspoz.CAP_EAT'+$_it+'<0
                           || _argspoz.CAP_EAT'+$_it+':=0
                           ?};
                           ~~
                     ');
               _rule(_argspoz,_merged[_it])
            !};
::          Aktualizuje pozycje planu - ilosci pomniejszam o to co zostalo scalone
::          zabezpieczam sie przed sytuacja, w ktorej rekord scalany przestal istniec
            PX_POZ.clear();
            {? PX_POZ.seek(_px_poz)
            ||
               _can_continue:=exec('update','px_poz',_argspoz);
               {? _can_continue>0
               ||
::                Obliczam ilosci dla formuly po wylaniu
                  {! _it:=1.._il_wym
                  |!
                     _rule:=$('
                                 _argswyl:=_a;
                                 _new_cap:=PX_POZ.CAP_EAT'+$_it+';
                                 _argswyl.CAP_EAT'+$_it+'-=_new_cap;
::                               z roznych zaokraglen moze wynikac ze ilosc jest mniejsza od zera,
::                               nie mozna do tego dopuscic
                                 {? _argswyl.CAP_EAT'+$_it+'<0
                                 || _argswyl.CAP_EAT'+$_it+':=0
                                 ?};
                                 ~~
                            ');
                     _rule(_argswyl)
                  !};
::                uruchamiam formule po wylaniu
                  exec('po_wylaniu','px_logix',_old_cup,_argswyl);

::                Aktualizuje wykonania i status zrodlowej pozycji planu
                  exec('px_poz_update','px_wyk',PX_POZ.ref())
               ?}
            ?}
         ?};
::       Aktualizuje pojemnosci w pojemniku pierwotnym
         exec('update','px_cup',_old_cup);

::       Aktualizuje pojemnosci w pojemniku nowym
         {? _old_cup<>_px_cup
         || exec('update','px_cup',_px_cup)
         ?}
      ?}
   ?}
?};
PX_POZ.cntx_pop();
_result


\merge
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Scala ze soba dwie pozycje planu
::   WE: _a - PX_POZ.ref() - DEST - pozycja planu do ktorej scalam
::       _b - PX_POZ.ref() - SOURCE - pozycja planu ktora scalam
::   WY: DICT - tablica - ile pojemnosci zostalo scalone w poszczegolnych wymiarach
::----------------------------------------------------------------------------------------------------------------------
_dest:=_a;
_source:=_b;

_args_s:=exec('blank_a','px_poz');

_can_continue:=0;

PX_POZ.cntx_psh();
PX_POZ.clear();
{? PX_POZ.seek(_source)
|| exec('record2args','px_poz',_args_s)
?};

_result:=exec('merge_core','px_poz',_dest,_args_s,0,,0);
_sum_merged:=exec('array_sum','#array',_result);

{? _sum_merged>0
||
:: Przepinanie wykonan - PX_WYK
   PX_WYK.cntx_psh();
   PX_WYK.index('POZ');
   PX_WYK.prefix(_source);
   {? PX_WYK.first()
   || {!
      |? _can_continue:=exec('move','px_wyk',PX_WYK.ref(),_dest,0);

::       Poniewaz move sprawi ze PX_WYK wyskoczy z dziedziny w petli musze iterowac za pomoca first
         PX_WYK.first() & _can_continue>0
      !}
   ?};
:: Uaktualniam pozycje docelowa (wykonania i status)
   exec('px_poz_update','px_wyk',_dest);

   PX_WYK.cntx_pop()
?};
PX_POZ.cntx_pop();
PX_POZ.get();
_result


\merge_core
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Scala ze soba dwie pozycje planu na pojemniku
::   WE: _a - PX_POZ.ref() - DEST - pozycja planu do ktorej scalam
::       _b - SOURCE - co scalam, pozycja planu ktora scalam reprezentowana przez
::                     tablice nazwana exec('blank_a','px_poz')
::       _c - INTEGER - 0: brak kontroli pol CAP_MAXx na PX_POZ
::                      1: scalenie jest robione tylko do pojemnosci CAP_MAXx pozycji DEST
::       [_d] - tab_tmp - w kontekscie rekordu paczki planistycznej
::       [_e] - INTEGER:  0 - nie wykonywac aktualizacji statusu docelowej pozycji planu
::                       [1] - wykonywac aktualizacje statusu docelowej pozycji planu
::   WY: DICT - tablica - ile pojemnosci zostalo scalone w poszczegolnych wymiarach
::----------------------------------------------------------------------------------------------------------------------
_px_poz:=_a;
_args_s:=_b;
_control:=_c;

{? var_pres('_d')>100
|| _paczka:=_d
|| _paczka:=~~
?};

_upd_status:=1;
{? var_pres('_e')=type_of(0)
|| _upd_status:=_e
?};

_result:=obj_new(1);
_result[1]:=0;

:: inicjalizacja obiektu KOMM
exec('pxkomm_init','px_logix');
_msg:='Uruchomienie scalania pozycji planu (scalanie do: '+$_px_poz+')';
pxkomm.sect_beg(_msg);

PX_POZ.cntx_psh();
PX_CUP.cntx_psh();
PX_KONT.cntx_psh();
PX_POZ.clear();
{? PX_POZ.seek(_px_poz)
||
   _il_wym:=PX_POZ.PX_CUP().PX_KONT().IL_WYM;
:: inicjalizacja wyniku
   obj_del(_result);
   _result:=obj_new(_il_wym);
   {! _it:=1.._il_wym
   |! _result[_it]:=0
   !};

:: przeksztalcam biezacego PX_POZa w tablice nazwane ktore bede modyfikowal, albo uzywal do
:: roznych wyliczen
   _args_d:=exec('blank_a','px_poz');
   _argsbefore:=exec('blank_a','px_poz');

   exec('record2args','px_poz',_args_d);
   exec('record2args','px_poz',_argsbefore);

:: przypisuje ilosci w kolejnych wymiarach
   {! _it:=1.._il_wym
   |! _rule:=$('
                  _args_d:=_a;
                  _args_s:=_b;
                  _control:=_c;
                  _max:=_args_d.CAP_MAX'+$_it+';
                  _args_d.CAP_EAT'+$_it+':=_args_s.CAP_EAT'+$_it+'+PX_POZ.CAP_EAT'+$_it+';
::                nigdy nie przekraczam maksimum technologicznego, jesli maksimum okreslone
::                i kontrola maksimum wlaczona
                  {? _max<>0 & _control>0
                  || {? _args_d.CAP_EAT'+$_it+'>_max
                     || _args_d.CAP_EAT'+$_it+':=_max
                     ?}
                  ?};
                  ~~
              ');
      _rule(_args_d,_args_s,_control)
   !};
   {? PX_VAR.NAST_ALG=2
   || exec('set_new_time','px_poz',,_args_d)
   ?};

:: !!!AKTUALIZUJE ILOSC POZYCJI PLANU!!!
:: zaokraglanie ilosci PX_POZa do prezycji PX_KONTa jest robione przed samym putem rekordu
:: w formulce exec('args2record','px_poz')
   {? exec('update','px_poz',_args_d)>0
   ||
      {! _it:=1.._il_wym
      |!
::       obliczam roznice ilosci ktora miala wpasc do planu wzgledem tego co faktycznie jest w planie
         _rule:=$('  _argsbefore:=_a;
                     _result:=0;
                     _result:=PX_POZ.CAP_EAT'+$_it+'-_argsbefore.CAP_EAT'+$_it+';
                     _result
                 ');
         _diff:=_rule(_argsbefore);
::       przypisuje wynik
         _rule:=$('
                      _result:=_a;
                      _diff:=_b;
                      _result['+$_it+']:=_diff
                 ');
         _res:=_rule(_result,_diff);
         _msg:='Wynik formuly w wymiarze: '+$_it+'='+$_result[_it];
         pxkomm.info(_msg);
::       aktualizuje rekord w paczce
         {? type_of(_paczka)>100
         || _rule:=$('
                        _paczka:=_a;
                        _diff:=_b;
                        _paczka.DID_DIM'+$_it+'+=_diff
                    ');
            _rule(_paczka,_diff)
         ?};
::       modyfikuje _args_s dla celow formuly po wlaniu - ustawiam ilosc na tyle ile modyfikowalem
         _rule:=$('
                     _args_s:=_a;
                     _diff:=_b;
                     _args_s.CAP_EAT'+$_it+':=_diff
                 ');
         _rule(_args_s,_diff)
      !};

::    uruchamiam formule po wlaniu
      exec('po_wlaniu','px_logix',PX_POZ.PX_CUP,_args_s);

::    Aktualizuje pojemnosc na pojemniku
      exec('update','px_cup',PX_POZ.PX_CUP,0);

::    aktualizuje status pozycji planu
      {? _upd_status>0
      || exec('status_update','px_poz',PX_POZ.ref())
      ?};

      {? PX_VAR.NAST_ALG=2
      || exec('rebuild4cup','px_cal',,0)
      ?}
   ?}
?};
PX_KONT.cntx_pop();
PX_CUP.cntx_pop();
PX_POZ.cntx_pop();

pxkomm.sect_end();

_result


\split_wyk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Po podzeleniu PX_POZa na dwa kawalki przepina po kolei wykonania ze starej czesci
::       do nowej, a jesli jest koniecznosc to dzieli jedno z wykonan
::   WE: _a - PX_POZ.ref() - SOURCE - pozycja planu zrodlowa
::       _b - PX_POZ.ref() - DEST - pozycja planu utworzona w wyniku split
::       _c - obj_new() - tablica zawierajaca ilosci CAP_EATx ze zrodla PRZED splitem
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_source:=_a;
_dest:=_b;
_src_org:=_c;

PX_POZ.cntx_psh();
PX_WYK.cntx_psh();
PX_KONT.cntx_psh();
PX_POZ.clear();

_dst_eat:=exec('count_eat','px_poz',_dest);
_src_wyk:=exec('count_wyk','px_poz',_source);
_divs:=exec('arrays_div','#array',_dst_eat,_src_org);

{? PX_POZ.seek(_dest)
|| _il_wym:=PX_POZ.PX_KONT().IL_WYM;

:: w tej tablicy znajduja sie ilosci wykonane ktore maja zostac przepiete na docelowa pozycje planu
   _wyk_new:=obj_new(_il_wym);
   {! _it:=1..._il_wym
   |! _wyk_new[_it]:=_src_wyk[_it]*_divs[_it]
   !};

:: w tej tablicy znajduja sie dokladnosci w poszczegolnych wymiarach
   _prec:=exec('precision_array','px_kont',PX_POZ.PX_KONT);

   {? exec('array_sum','#array',_wyk_new)>0
   ||
::    Po kolei przepinam PX_WYKi
      _can_continue:=1;
      _split:=0;

      PX_WYK.index('POZ');
      PX_WYK.prefix(_source);
      {? PX_WYK.first()
      ||
         _argssplit:=exec('split_a','px_wyk');
         {!
         |? {? var_pres('_wyk')>100
            || obj_del(_wyk)
            ?};
            _wyk:=exec('count_wyk','px_wyk',PX_WYK.ref());

::          badam czy mozna przepiac px_wyk czy trzeba go podzielic
            {? var_pres('_copy')>100
            || obj_del(_copy)
            ?};
            _copy:=exec('array_copy','#array',_wyk_new);
            exec('arrays_sub_mod','#array',_copy,_wyk);
            {? exec('array_has_minus','#array',_copy)>0
            ||
::             jesli w tablicy z ilosciami pozostalymi do przetworzenia jest minus,
::             to znak ze na wykonaniu jest za duzo i trzeba przestac przetwarzac kolejne
::             PX_WYKi i podzielic aktualnego PX_WYKa na dwa kawalki

::             obliczam proporcje wg ktorej ma nastapic podzielenie PX_WYK

::             tablica z proporcjami we wszystkich wymiarach
               {? var_pres('_tab_prop')>100
               || obj_del(_tab_prop)
               ?};
               _tab_prop:=exec('arrays_div','#array',_wyk_new,_wyk);
::             wyznaczam najmniejsza proporcje (ale rozna od zera)
               _prop_new:=exec('array_min2','#array',_tab_prop,0);
               _prop_old:=1-_prop_new;
               {? _prop_old>0
               ||
::                obliczam ilosci ktore maja byc pozostawione w starym wykonaniu
                  {? var_pres('_old_il')>100
                  || obj_del(_old_il)
                  ?};
                  _old_il:=exec('array_copy','#array',_wyk);
                  exec('array_multiply','#array',_old_il,_prop_old);

::                zaokraglam ilosci do dokladnosci na kontenerze
                  exec('array_round_mod','#array',_old_il,_prec);

::                dziele wykonanie
                  _argssplit.SRC_WYK:=PX_WYK.ref();
                  _argssplit.DST_POZ:=_dest;

                  exec('split','px_wyk',_argssplit,_old_il);

                  _can_continue:=0
               ?}
            ||
::             jesli ilosc do przetworzenia wieksza od zera to przepinam wykonanie i jade dalej
               _can_continue:=exec('move','px_wyk',PX_WYK.ref(),_dest,0);
               {? _can_continue>0
               || exec('arrays_sub_mod','#array',_wyk_new,_wyk)
               ?}
            ?};
            PX_WYK.first() & _can_continue>0
         !};
::       Aktualizuje statusy zrodlowej i docelowej pozycji planu
         exec('px_poz_update','px_wyk',_source);
         exec('px_poz_update','px_wyk',_dest)
      ?}
   ?}
?};

PX_KONT.cntx_pop();
PX_WYK.cntx_pop();
PX_POZ.cntx_pop();
~~


\find_in_cup
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy w aktualnym pojemniku, jest pozycja planu pasujaca pod wzgledem:
::       - PX_POZ.PX_GRP
::       - PX_POZ.PX_STAGE
::       - PX_POZ.STATUS
::       - PX_POZ.PX_OBJ
::       - PX_POZ.TM_SRC
::
:: UWAGA! Zmienia kontekst tabeli PX_POZ - jesli to mozliwe ustawia sie na szukanej pozycji
::   WE: _a - PX_GRP.ref()
::       _b - PX_STAGE.ref()
::       [_c] - PX_POZ.ref() - pozycja planu ktorej nie uwzgledniac w poszukiwaniu
::       [_d] - STRING - PX_POZ.STATUS
::       [_e] - PX_OBJ.ref()
::       [_f] - REAL - tm_stamp zrodlowego pojemnika z ktorego pochodzi pozycja (obsluga nadwykonan)
::   WY: 0 - w aktualnym pojemniku brak pozycji o wymaganych kryteriach
::       1 - w aktualnym pojemniki znaleziono pozycje o wymaganych kryteriach
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_px_stage:=_b;
_status:='';
_skip_poz:=null();
{? var_pres('_c')=type_of(SYSLOG.ref())
|| _skip_poz:=_c
?};
{? var_pres('_d')=type_of('')
|| _status:=_d
?};
_px_obj:=null();
{? var_pres('_e')=type_of(SYSLOG.ref())
|| _px_obj:=_e
?};
_tm_src:=-1;
{? var_pres('_f')=type_of(0)
|| _tm_src:=_f
?};

_result:=0;

_can_continue:=0;
{? _status='' & _px_obj=null()
|| PX_POZ.index('PX_STAGE');
   PX_POZ.prefix(PX_CUP.ref(),_px_grp,_px_stage);
   _can_continue:=1
|? _status<>'' & _px_obj=null() & _tm_src=-1
|| PX_POZ.index('PX_STAGE');
   PX_POZ.prefix(PX_CUP.ref(),_px_grp,_px_stage,_status);
   _can_continue:=1
|? _status<>'' & _px_obj=null() & _tm_src>-1
|| PX_POZ.index('PX_GRP');
   PX_POZ.prefix(PX_CUP.ref(),_px_grp,_px_stage,_status,_tm_src);
   _can_continue:=1
|? _status<>'' & _px_obj<>null() & _tm_src=-1
|| PX_POZ.index('PX_STAGE');
   PX_POZ.prefix(PX_CUP.ref(),_px_grp,_px_stage,_status,_px_obj);
   _can_continue:=1
|? _status<>'' & _px_obj<>null() & _tm_src>-1
|| PX_POZ.index('PX_STAGE');
   PX_POZ.prefix(PX_CUP.ref(),_px_grp,_px_stage,_status,_px_obj,_tm_src);
   _can_continue:=1
?};

{? _can_continue>0
||
   {? PX_POZ.first()
   || {!
      |? {? PX_POZ.ref()<>_skip_poz
         || _result:=1;
            _can_continue:=0
         || _can_continue:=PX_POZ.next()
         ?};
         _can_continue>0
      !}
   ?};
   PX_POZ.clear()
?};
_result


\find_in_cup_ope
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy w aktualnym pojemniku, jest pozycja planu pasujaca pod wzgledem:
::       - PX_POZ.STATUS
::       - PX_POZ.PX_OBJ
::       - PX_POZ.PL_OPER
::       - PX_POZ.PL_OGR
::       - PX_POZ.TM_SRC
::
:: UWAGA! Zmienia kontekst tabeli PX_POZ - jesli to mozliwe ustawia sie na szukanej pozycji
::   WE: [_a] - PL_OPER.ref()
::       [_b] - PL_OGR.ref()
::       [_c] - PX_POZ.ref() - pozycja planu ktorej nie uwzgledniac w poszukiwaniu
::       [_d] - STRING - PX_POZ.STATUS
::       [_e] - PX_OBJ.ref()
::       [_f] - REAL - tm_stamp zrodlowego pojemnika z ktorego pochodzi pozycja (obsluga nadwykonan)
::   WY: 0 - w aktualnym pojemniku brak pozycji o wymaganych kryteriach
::       1 - w aktualnym pojemniki znaleziono pozycje o wymaganych kryteriach
::----------------------------------------------------------------------------------------------------------------------
_pl_oper:=null();
{? var_pres('_a')=type_of(PL_OPER.ref())
|| _pl_oper:=_a
?};

_pl_ogr:=null();
{? var_pres('_b')=type_of(PL_OGR.ref())
|| _pl_ogr:=_b
?};
_status:='';
_skip_poz:=null();
{? var_pres('_c')=type_of(SYSLOG.ref())
|| _skip_poz:=_c
?};
{? var_pres('_d')=type_of('')
|| _status:=_d
?};
_px_obj:=null();
{? var_pres('_e')=type_of(SYSLOG.ref())
|| _px_obj:=_e
?};
_tm_src:=0;
{? var_pres('_f')=type_of(0)
|| _tm_src:=_f
?};

_result:=0;

_can_continue:=0;
{? _pl_oper<>null()
|| PX_POZ.index('PL_OPER');
   {? _status='' & _px_obj=null()
   || PX_POZ.prefix(PX_CUP.ref(),_pl_oper);
      _can_continue:=1
   |? _status<>'' & _px_obj=null()
   || PX_POZ.prefix(PX_CUP.ref(),_pl_oper,_status);
      _can_continue:=1
   |? _status<>'' & _px_obj<>null() & _tm_src=0
   || PX_POZ.prefix(PX_CUP.ref(),_pl_oper,_status,_px_obj);
      _can_continue:=1
   |? _status<>'' & _px_obj<>null() & _tm_src>0
   || PX_POZ.prefix(PX_CUP.ref(),_pl_oper,_status,_px_obj,_tm_src);
      _can_continue:=1
   ?}
|? _pl_ogr<>null()
|| PX_POZ.index('PL_OGR');
   {? _status='' & _px_obj=null()
   || PX_POZ.prefix(PX_CUP.ref(),_pl_ogr);
      _can_continue:=1
   |? _status<>'' & _px_obj=null()
   || PX_POZ.prefix(PX_CUP.ref(),_pl_ogr,_status);
      _can_continue:=1
   |? _status<>'' & _px_obj<>null() & _tm_src=0
   || PX_POZ.prefix(PX_CUP.ref(),_pl_ogr,_status,_px_obj);
      _can_continue:=1
   |? _status<>'' & _px_obj<>null() & _tm_src>0
   || PX_POZ.prefix(PX_CUP.ref(),_pl_ogr,_status,_px_obj,_tm_src);
      _can_continue:=1
   ?}
?};

{? _can_continue>0
||
   {? PX_POZ.first()
   || {!
      |? {? PX_POZ.ref()<>_skip_poz
         || _result:=1;
            _can_continue:=0
         || _can_continue:=PX_POZ.next()
         ?};
         _can_continue>0
      !}
   ?};
   PX_POZ.clear()
?};
_result


\cap_max_correct
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy podana pojemnosc w danym wymiarze mozna zaplanowac jeszcze w pojemniku
::       uwzgledniajac zuzycie max na PX_STAGE dla danych kryteriow:
::       - PX_POZ.PX_GRP
::       - PX_POZ.PX_STAGE
::       Kontekst pracy - PX_CUP
::   WE: _a - PX_GRP.ref()
::       _b - PX_STAGE.ref()
::       _c - obj_new - zadana pojemnosci do zaplanowania na pojemniku
::   WY: REAL - ile zostalo wolnego do zuzycia max lub -1 jesli osiagnieto zuzycie max
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_px_stage:=_b;
_required:=_c;

PX_KONT.cntx_psh();
PX_POZ.cntx_psh();
_il_wym:=PX_CUP.PX_KONT().IL_WYM;

_result:=obj_new(_il_wym);
_used:=obj_new(_il_wym);
_max:=obj_new(_il_wym);

{! _it:=1.._il_wym
|! _result[_it]:=_required[_it];
   _max[_it]:=0;
   _used[_it]:=0
!};

PX_POZ.index('PX_STAGE');
PX_POZ.prefix(PX_CUP.ref(),_px_grp,_px_stage);
{? PX_POZ.first()
||
:: Przypisuje maksima w kazdym wymiarze
   {! _it:=1.._il_wym
   |! _max[_it]:=($('PX_POZ.CAP_MAX'+$_it))()
   !};
   {!
   |?
::    Obliczam ile jest zuzytej pojemnosci na tym pojemniku dla tego etapu
      {? var_pres('_poz_eat')>100
      || obj_del(_poz_eat)
      ?};
      _poz_eat:=exec('count_eat','px_poz',PX_POZ.ref());
      exec('arrays_add_mod','#array',_used,_poz_eat);
      PX_POZ.next()
   !};
:: Obliczam roznice
   {! _it:=1.._il_wym
   |! _result[_it]:=_max[_it]-_used[_it];
::    Jesli dostepne maksimum wyczerpane, to zwracam -1 (zeby nie zwracac zera, ktore oznacza
::    brak maksimum w przepisie technologicznym)
      {? _result[_it]<=0
      || _result[_it]:=-1
      ?}
   !}
?};
PX_KONT.cntx_pop();
PX_POZ.cntx_pop();
_result


\ploper_clear
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Usuwa z planu wszystkie PX_POZy powiazane z danym ploperem
::   WE: _a - PL_OPER.ref()
::       [_b] - PX_VER.ref() - wersja w ktorej czyscic, jesli nie podane to czyscic ze wszsytkich wersji
::       [_c] - INTEGER - [0]/1 - usuwać nawet jeżeli są wykonania
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_pl_oper:=_a;

_px_ver:=null();
{? var_pres('_b')=type_of(PX_VER.ref())
|| _px_ver:=_b
?};

_force:=0;
{? var_pres('_c')=type_of(0)
|| _force:=_c
?};

{? PX_VAR.NAST_ALG=0
|| exec('opernast_init','px_init')
?};

_result:=0;
_can_continue:=1;

PX_POZ.cntx_psh();
PX_POZ.index('PL_OPER2');
{? _px_ver<>null
|| PX_POZ.prefix(_pl_oper,_px_ver)
|| PX_POZ.prefix(_pl_oper)
?};
{? PX_POZ.first()
|| {!
   |?
      {? _force>0
      || ~~
      ||
         {? exec('has_wyki','px_poz',PX_POZ.ref())=0
         || _can_continue:=1
         || _can_continue:=0
         ?}
      ?};
      {? _can_continue>0
      || _can_continue:=exec('delete','px_poz',PX_POZ.ref())
      ?};
      PX_POZ.first() & _can_continue>0
   !}
?};
{? _px_ver<>null()
||
:: Oznaczam wersje do przeliczenia
   exec('mod_stamp_queue','px_ver',_px_ver)
?};

{? _can_continue>0
|| _result:=1
?};

PX_POZ.cntx_pop();
_result


\plogr_clear
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Usuwa z planu wszystkie PX_POZy powiazane z danym plogrem
::   WE: _a - PL_OGR.ref()
::       [_b] - PX_VER.ref() - wersja w ktorej czyscic, jesli nie podane to czyscic ze wszsytkich wersji
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_pl_ogr:=_a;

_px_ver:=null();
{? var_pres('_b')=type_of(PX_VER.ref())
|| _px_ver:=_b
?};

_result:=0;
_can_continue:=1;

PX_POZ.cntx_psh();
PX_POZ.index('PL_OGR2');
{? _px_ver<>null
|| PX_POZ.prefix(_pl_ogr,_px_ver)
|| PX_POZ.prefix(_pl_ogr)
?};
{? PX_POZ.first()
|| {!
   |?
      {? exec('has_wyki','px_poz',PX_POZ.ref())=0
      || _can_continue:=1
      || _can_continue:=0
      ?};
      {? _can_continue>0
      || _can_continue:=exec('delete','px_poz',PX_POZ.ref())
      ?};
      PX_POZ.first() & _can_continue>0
   !}
?};

{? _can_continue>0
|| _result:=1
?};

PX_POZ.cntx_pop();
_result


\rem_clear
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [20.14]
:: OPIS: Usuwa z planu wszystkie PX_POZy powiazane z danym remontem
::   WE: _a - REM_ZGL.ref()
::       [_b] - PX_VER.ref() - wersja w ktorej czyscic, jesli nie podane to czyscic ze wszsytkich wersji
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_ZGL.ref())
|| _ref:=_a
?};

_px_ver:=null();
{? var_pres('_b')=type_of(PX_VER.ref())
|| _px_ver:=_b
?};

_result:=0;
_can_continue:=1;
_deleted:=0;

REM_ZGL.cntx_psh();
{? _ref<>null()
|| REM_ZGL.prefix();
   {? REM_ZGL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
PX_POZ.cntx_psh();

{? _can_continue>0
||
   _px_obj:=exec('get_rem_object','px_obj',REM_ZGL.ref());

   {? _px_obj<>null()
   ||
      {? _px_ver<>null
      || PX_POZ.index('PX_POZ');
         PX_POZ.prefix(_px_ver,_px_obj)
      || PX_POZ.index('PX_OBJ3');
         PX_POZ.prefix(_px_obj)
      ?};
      {? PX_POZ.first()
      || {!
         |?
            {? exec('has_wyki','px_poz',PX_POZ.ref())=0
            || _can_continue:=1
            || _can_continue:=0
            ?};
            {? _can_continue>0
            || _can_continue:=exec('delete','px_poz',PX_POZ.ref());
               {? _can_continue>0
               || _deleted:=1
               ?}
            ?};
            PX_POZ.first() & _can_continue>0
         !}
      ?}
   ?};

   {? _can_continue>0
   ||
::    Stempluje zgłoszenie
      _can_continue:=exec('plan_px_update','remonty_plan',REM_ZGL.ref())
   ?}
?};
REM_ZGL.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
{? _deleted>0
||
:: Oznaczam wersje do przeliczenia
   {? _px_ver=null()
   || _px_ver:=exec('get_mainversion','px_ver')
   ?};
   exec('mod_stamp_queue','px_ver',_px_ver)
?};

PX_POZ.cntx_pop();
_result


\rem_clear4zas
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [20.14]
:: OPIS: Usuwa z planu wszystkie PX_POZy powiazane z planem remontu
::   WE: _a - REM_PLAN.ref()
::       _b - PX_KONT.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(REM_PLAN.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;
_deleted:=0;

REM_PLAN.cntx_psh();
{? _ref<>null()
|| REM_PLAN.prefix();
   {? REM_PLAN.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
PX_POZ.cntx_psh();

{? _can_continue>0
||
   _px_kont:=exec('rem_zas_px','zasoby',REM_PLAN.REM_ZAS);
   _px_obj:=exec('get_rem_object','px_obj',REM_PLAN.REM_ZGL);

   {? _px_obj<>null() & _px_kont<>null()
   ||
      PX_POZ.index('PX_KONT2');
      PX_POZ.prefix(_px_kont,_px_obj);
      {? PX_POZ.first()
      || {!
         |?
            {? exec('has_wyki','px_poz',PX_POZ.ref())=0
            || _can_continue:=1
            || _can_continue:=0
            ?};
            {? _can_continue>0
            || _can_continue:=exec('delete','px_poz',PX_POZ.ref());
               {? _can_continue>0
               || _deleted:=1
               ?}
            ?};
            PX_POZ.first() & _can_continue>0
         !}
      ?}
   ?}
?};
REM_PLAN.cntx_pop();

{? _can_continue>0
|| _can_continue:=exec('plan_px_update','remonty_plan',REM_PLAN.REM_ZGL)
?};

{? _can_continue>0
|| _result:=1
?};
{? _deleted>0
||
:: Oznaczam wersje glowna planu do przeliczenia
   _px_ver:=exec('get_mainversion','px_ver');
   exec('mod_stamp_queue','px_ver',_px_ver)
?};

PX_POZ.cntx_pop();
_result


\select_obj_btn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Selekcja PX_POZ-ow od strony obiektow - wariant dla przycisku w kontrolce
::----------------------------------------------------------------------------------------------------------------------
{? PxSelect.OBJ_sget.size()>0
||
   FUN.info('Akcja nieaktywna dla grupy zaznaczonych rekordów.'@)
||
   exec('select_obj','px_poz')
?};
~~


\px_poz_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Selekcja surowcow do pozycji planu strategicznego
::----------------------------------------------------------------------------------------------------------------------
{? exec('is_zlim_ploper','zl_limit',PX_POZ.PL_OPER)
|| exec('sel_zlim_ploper','zl_limit',PX_POZ.PL_OPER)
|? exec('is_zlim_pxstag','zl_limit',PX_POZ.PX_STAGE)
|| exec('sel_zlim_pxstag','zl_limit',PX_POZ.PX_STAGE)
|? exec('is_sur_pxpoz','px_sur',PX_POZ.ref())
|| exec('sel_sur_pxpoz','px_sur',PX_POZ.ref())
|? exec('is_zlim_grop','zl_limit1',PX_POZ.PX_OBJ().GROP)
|| exec('sur_all','zl_nlimit',,,,1,GROP.ref())
|| FUN.info('Do pozycji planu nie przypisano surowców.'@)
?}


\has_wyki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Czy do danej pozycji planu zarejestrowane sa wykonania
::   WE: _a - PX_POZ.ref()
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
PX_WYK.cntx_psh();
PX_WYK.index('POZ');
PX_WYK.prefix(_a);
_result:=PX_WYK.size()>0;
PX_WYK.cntx_pop();
_result


\statusy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca strukture z wartosciami opisowymi statusow pozycji planu
::----------------------------------------------------------------------------------------------------------------------
_statusy:=obj_new('NORMAL','BLK','DELAY','SKIPPED','WYK1','WYK2');

_statusy.NORMAL:=exec('status_normal','px_poz');
_statusy.BLK:=exec('status_blk','px_poz');
_statusy.DELAY:=exec('status_delay','px_poz');
_statusy.SKIPPED:=exec('status_skipped','px_poz');
_statusy.WYK1:=exec('status_wyk1','px_poz');
_statusy.WYK2:=exec('status_wyk2','px_poz');

_statusy


\view_chk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy dla podanej daty, kontenera i obiektu sa jakies pozycje planu
::       Kontekst pracy:
::                         aktualny widok planu - PX_VIEW
::                         ustawiony indeks PX_POINT: PX_GRP
::   WE: _a - PX_VER.ref()
::       _b - DATY.ref()
::       _c - STRING - rodzina indeksow uzywanych do prefiksowania:
::                                                                   KONT - widok 'Zasoby' - wymagany par. _d
::                                                                   OBJ  - widok 'Obiekty' - wymagany par. _e
::       _d - STRING - PX_KONT.MAX_CDUR
::       [_e] - PX_KONT.ref()
::       [_f] - PX_OBJ.ref()
::       [_g] - PX_GRP.ref()
::       [_h] - PX_STAGE.ref()
::       [_i] - PX_SET.ref()
::   WY: STRING - jesli pusty to znak ze brak pozycji planu
::                jesli cos zawiera to znak ze sa pozycje planu
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_data:=_b;
_ndx_family:=_c;
_max_cdur:=_d;

_px_kont:=null();
{? var_pres('_e')=type_of(PX_KONT.ref())
|| _px_kont:=_e
?};

_px_obj:=null();
{? var_pres('_f')=type_of(PX_OBJ.ref())
|| _px_obj:=_f
?};

_px_grp:=null();
{? var_pres('_g')=type_of(PX_GRP.ref())
|| _px_grp:=_g
?};

_px_stage:=null();
{? var_pres('_h')=type_of(PX_STAGE.ref())
|| _px_stage:=_h
?};

_px_set:=null();
{? var_pres('_i')=type_of(PX_SET.ref())
|| _px_set:=_i
?};

_result:='';
_can_continue:=1;

_txt_nul:=exec('txt_plan_nul','px_param');
_txt_fwd:=exec('txt_plan_fwd','px_param');
_txt_bck:=exec('txt_plan_bck','px_param');
_txt_free:=exec('txt_free','px_param');
_txt_point:=exec('txt_point','px_param');

_level:=PX_VIEW.LEVEL;
_offset:=exec('time','#tm_stamp',PX_VIEW.OFFSET);

DATY.cntx_psh(); DATY.clear();
PX_POZ.cntx_psh();

{? DATY.seek(_data)
||
   DATY.cntx_psh();
   _next:=null();
   {? exec('find_next','daty',_level)>0
   || _next:=DATY.ref()
   ?};
   DATY.cntx_pop();

   _int_org:=exec('create_interval','daty',DATY.ref(),_next,_offset);
   _int_poz:=exec('interval','#interval');

:: 1. Najpierw sprawdzamy czy sa takie pozycje planu ktore przecinaja wyswietlany okres na danym poziomie
:: Poczatek
   {? _px_set=null()
   || _index:='S_'+_level+'_'+_ndx_family
   || _index:='SS'+_level+'_'+_ndx_family
   ?};
   PX_POZ.index(_index);
   exec('level_prefix','px_poz',_px_ver,_level,_ndx_family,_px_kont,_px_obj,_px_grp,_px_stage,_px_set);

   {? PX_POZ.first()
   ||
      _int_poz.START:=PX_POZ.TM_START;
      _int_poz.END:=PX_POZ.TM_END;

::    Sprawdzam czy interwal pozycji planu i wyswietlanego okresu sie przecina
      _int_and:=exec('intervals_and','#interval',_int_org,_int_poz);
      _dur_and:=exec('interval_dur','#interval',_int_and);

      {? _dur_and>0
      ||
         {? _px_grp<>null() & _px_stage<>null()
         ||
::          Jesli podana byla grupa i etap, to sprawdzam czy jest punkt czasowy
            PX_POINT.prefix(_px_grp,_px_stage);
            {? PX_POINT.size()>0
            || _result:=_txt_point
            || _result:={? PX_POZ.PX_GRP().DIR=-1
                        || _txt_bck
                        |? PX_POZ.PX_GRP().DIR=1
                        || _txt_fwd
                        || _txt_nul
                        ?}
            ?}
         || _result:={? PX_POZ.PX_GRP().DIR=-1
                     || _txt_bck
                     |? PX_POZ.PX_GRP().DIR=1
                     || _txt_fwd
                     || _txt_nul
                     ?}
         ?};
         _can_continue:=0
      ?}
   ?};

   {? _can_continue>0
   ||
::    Koniec
      {? _px_set=null()
      || _index:='E_'+_level+'_'+_ndx_family
      || _index:='ES'+_level+'_'+_ndx_family
      ?};
      PX_POZ.index(_index);
      exec('level_prefix','px_poz',_px_ver,_level,_ndx_family,_px_kont,_px_obj,_px_grp,_px_stage,_px_set);

      {? PX_POZ.first()
      ||
         _int_poz.START:=PX_POZ.TM_START;
         _int_poz.END:=PX_POZ.TM_END;

::       Sprawdzam czy interwal pozycji planu i wyswietlanego okresu sie przecina
         _int_an2:=exec('intervals_and','#interval',_int_org,_int_poz);
         _dur_and:=exec('interval_dur','#interval',_int_an2);

         {? _dur_and>0
         ||
            {? _px_grp<>null() & _px_stage<>null()
            ||
::             Jesli podana byla grupa i etap, to sprawdzam czy jest punkt czasowy
               PX_POINT.prefix(_px_grp,_px_stage);
               {? PX_POINT.size()>0
               || _result:=_txt_point
               || _result:={? PX_POZ.PX_GRP().DIR=-1
                           || _txt_bck
                           |? PX_POZ.PX_GRP().DIR=1
                           || _txt_fwd
                           || _txt_nul
                           ?}
               ?}
            || _result:={? PX_POZ.PX_GRP().DIR=-1
                        || _txt_bck
                        |? PX_POZ.PX_GRP().DIR=1
                        || _txt_fwd
                        || _txt_nul
                        ?}
            ?};
            _can_continue:=0
         ?}
      ?}
   ?};

   {? _can_continue>0
   ||
::    2. Jeżeli nie znalazłem pozycji planu na wyswietlanym poziomie to szukam na poziomach wyzszych
      _hierarchy:=exec('hierarchy','px_view');
      _lev_nr:=_hierarchy*_level;
      _max_nr:=_hierarchy*_max_cdur;

      {! _it:=_lev_nr//-1..1
      |? _can_continue>0
      |!
         _higher:=1+((_it-1)-_hierarchy);

::       Jesli wyzszy poziom przekracza maksymalny poziom kontenera to przerywam petlenie
         {? _it<_max_nr
         || _can_continue:=0
         ?};

         {? _can_continue>0 & _higher<>_level
         ||
::          Interwal czasu trwania okresu widokowego na wyzszym poziomie
            {? var_pres('_int_daty')>100
            || obj_del(_int_daty)
            ?};
            DATY.cntx_psh();
            _next:=null();
            {? exec('find_next','daty',_higher)>0
            || _next:=DATY.ref()
            || _can_continue:=0
            ?};
            DATY.cntx_pop();

            {? _can_continue>0
            ||
               _int_daty:=exec('create_interval','daty',DATY.ref(),_next,_higher);
               _dur_daty:=exec('interval_dur','#interval',_int_daty);

::             Prefiksuje wyzsze poziomy
::             Poczatek
               {? _px_set=null()
               || _index:='S_'+_higher+'_'+_ndx_family
               || _index:='SS'+_higher+'_'+_ndx_family
               ?};
               PX_POZ.index(_index);
               exec('level_prefix','px_poz',_px_ver,_higher,_ndx_family,_px_kont,_px_obj,_px_grp,_px_stage,_px_set);

               {? PX_POZ.first()
               ||
                  {? _px_grp<>null() & _px_stage<>null()
                  ||
::                   Jesli podana byla grupa i etap, to sprawdzam czy jest punkt czasowy
                     PX_POINT.prefix(_px_grp,_px_stage);
                     {? PX_POINT.size()>0
                     || _result:=_txt_point
                     || _result:={? PX_POZ.PX_GRP().DIR=-1
                                 || _txt_bck
                                 |? PX_POZ.PX_GRP().DIR=1
                                 || _txt_fwd
                                 || _txt_nul
                                 ?}
                     ?}
                  || _result:={? PX_POZ.PX_GRP().DIR=-1
                              || _txt_bck
                              |? PX_POZ.PX_GRP().DIR=1
                              || _txt_fwd
                              || _txt_nul
                              ?}
                  ?};
                  _can_continue:=0
               ?}

::               {? _can_continue>0
::               ||
::::                Koniec
::                  _index:='E_'+_higher+'_'+_ndx_family;
::                  exec('level_prefix','px_poz',_higher,_ndx_family,_px_kont,_px_obj,_px_grp,_px_stage);
::                  {? PX_POZ.first()
::                  || _result:={? PX_POZ.PX_GRP().DIR=-1
::                              || _txt_bck
::                              |? PX_POZ.PX_GRP().DIR=1
::                              || _txt_fwd
::                              || _txt_nul
::                              ?};
::                     _can_continue:=0
::                  ?}
::               ?}
            ?}
         ?}
      !}
   ?}
?};

PX_POZ.cntx_pop();
DATY.cntx_pop();
_result


\level_prefix
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Prefiksuje PX_POZy na odpowiednim poziomie widoku
::   WE:  _a - PX_VER.ref()
::        _b - STRING - poziom widoku
::        _c - STRING - rodzina indeksow uzywanych do prefiksowania:
::                                                                   KONT - widok 'Zasoby' - wymagany par. _c
::                                                                   OBJ  - widok 'Obiekty' - wymagany par. _d
::       [_d] - PX_KONT.ref()
::       [_e] - PX_OBJ.ref()
::       [_f] - PX_GRP.ref()
::       [_g] - PX_STAGE.ref()
::       [_h] - PX_SET.ref()
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_level:=_b;
_ndx_family:=_c;

_px_kont:=null();
{? var_pres('_d')=type_of(PX_KONT.ref())
|| _px_kont:=_d
?};

_px_obj:=null();
{? var_pres('_e')=type_of(PX_OBJ.ref())
|| _px_obj:=_e
?};

_px_grp:=null();
{? var_pres('_f')=type_of(PX_GRP.ref())
|| _px_grp:=_f
?};

_px_stage:=null();
{? var_pres('_g')=type_of(PX_STAGE.ref())
|| _px_stage:=_g
?};

_px_set:=null();
{? var_pres('_h')=type_of(PX_SET.ref())
|| _px_set:=_h
?};

{? _level='R'
|| {? _ndx_family='KONT'
   || {? _px_obj<>null() & _px_grp & _px_stage<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,_px_kont,_px_obj,_px_grp,_px_stage)
      |? _px_obj<>null() & _px_grp<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,_px_kont,_px_obj,_px_grp)
      |? _px_obj<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,_px_kont,_px_obj)
      || PX_POZ.prefix(_px_ver,DATY.ROK,_px_kont)
      ?}
   |? _ndx_family='OBJ'
   || {? _px_set=null()
      || {? _px_grp<>null() & _px_stage<>null() & _px_kont<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,_px_obj,_px_grp,_px_stage,_px_kont)
         |? _px_grp<>null() & _px_stage<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,_px_obj,_px_grp,_px_stage)
         |? _px_grp<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,_px_obj,_px_grp)
         || PX_POZ.prefix(_px_ver,DATY.ROK,_px_obj)
         ?}
      || {? _px_grp<>null() & _px_stage<>null() & _px_kont<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,_px_obj,_px_grp,_px_stage,_px_kont)
         |? _px_grp<>null() & _px_stage<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,_px_obj,_px_grp,_px_stage)
         |? _px_grp<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,_px_obj,_px_grp)
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,_px_obj)
         ?}
      ?}
   ?}

|? _level='P'
|| {? _ndx_family='KONT'
   || {? _px_obj<>null() & _px_grp & _px_stage<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.POLROCZE,_px_kont,_px_obj,_px_grp,_px_stage)
      |? _px_obj<>null() & _px_grp<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.POLROCZE,_px_kont,_px_obj,_px_grp)
      |? _px_obj<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.POLROCZE,_px_kont,_px_obj)
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.POLROCZE,_px_kont)
      ?}
   |? _ndx_family='OBJ'
   || {? _px_set=null()
      || {? _px_grp<>null() & _px_stage<>null() & _px_kont<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.POLROCZE,_px_obj,_px_grp,_px_stage,_px_kont)
         |? _px_grp<>null() & _px_stage<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.POLROCZE,_px_obj,_px_grp,_px_stage)
         |? _px_grp<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.POLROCZE,_px_obj,_px_grp)
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.POLROCZE,_px_obj)
         ?}
      || {? _px_grp<>null() & _px_stage<>null() & _px_kont<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.POLROCZE,_px_obj,_px_grp,_px_stage,_px_kont)
         |? _px_grp<>null() & _px_stage<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.POLROCZE,_px_obj,_px_grp,_px_stage)
         |? _px_grp<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.POLROCZE,_px_obj,_px_grp)
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.POLROCZE,_px_obj)
         ?}
      ?}
   ?}

|? _level='K'
|| {? _ndx_family='KONT'
   || {? _px_obj<>null() & _px_grp & _px_stage<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.KWARTAL,_px_kont,_px_obj,_px_grp,_px_stage)
      |? _px_obj<>null() & _px_grp<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.KWARTAL,_px_kont,_px_obj,_px_grp)
      |? _px_obj<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.KWARTAL,_px_kont,_px_obj)
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.KWARTAL,_px_kont)
      ?}
   |? _ndx_family='OBJ'
   || {? _px_set=null()
      || {? _px_grp<>null() & _px_stage<>null() & _px_kont<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.KWARTAL,_px_obj,_px_grp,_px_stage,_px_kont)
         |? _px_grp<>null() & _px_stage<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.KWARTAL,_px_obj,_px_grp,_px_stage)
         |? _px_grp<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.KWARTAL,_px_obj,_px_grp)
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.KWARTAL,_px_obj)
         ?}
      || {? _px_grp<>null() & _px_stage<>null() & _px_kont<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.KWARTAL,_px_obj,_px_grp,_px_stage,_px_kont)
         |? _px_grp<>null() & _px_stage<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.KWARTAL,_px_obj,_px_grp,_px_stage)
         |? _px_grp<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.KWARTAL,_px_obj,_px_grp)
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.KWARTAL,_px_obj)
         ?}
      ?}
   ?}

|? _level='M'
|| {? _ndx_family='KONT'
   || {? _px_obj<>null() & _px_grp & _px_stage<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.MIESIAC,_px_kont,_px_obj,_px_grp,_px_stage)
      |? _px_obj<>null() & _px_grp<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.MIESIAC,_px_kont,_px_obj,_px_grp)
      |? _px_obj<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.MIESIAC,_px_kont,_px_obj)
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.MIESIAC,_px_kont)
      ?}
   |? _ndx_family='OBJ'
   || {? _px_set=null()
      || {? _px_grp<>null() & _px_stage<>null() & _px_kont<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.MIESIAC,_px_obj,_px_grp,_px_stage,_px_kont)
         |? _px_grp<>null() & _px_stage<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.MIESIAC,_px_obj,_px_grp,_px_stage)
         |? _px_grp<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.MIESIAC,_px_obj,_px_grp)
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.MIESIAC,_px_obj)
         ?}
      || {? _px_grp<>null() & _px_stage<>null() & _px_kont<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.MIESIAC,_px_obj,_px_grp,_px_stage,_px_kont)
         |? _px_grp<>null() & _px_stage<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.MIESIAC,_px_obj,_px_grp,_px_stage)
         |? _px_grp<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.MIESIAC,_px_obj,_px_grp)
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.MIESIAC,_px_obj)
         ?}
      ?}
   ?}

|? _level='T'
|| {? _ndx_family='KONT'
   || {? _px_obj<>null() & _px_grp & _px_stage<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.TYDZIEN,_px_kont,_px_obj,_px_grp,_px_stage)
      |? _px_obj<>null() & _px_grp<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.TYDZIEN,_px_kont,_px_obj,_px_grp)
      |? _px_obj<>null()
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.TYDZIEN,_px_kont,_px_obj)
      || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.TYDZIEN,_px_kont)
      ?}
   |? _ndx_family='OBJ'
   || {? _px_set=null()
      || {? _px_grp<>null() & _px_stage<>null() & _px_kont<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.TYDZIEN,_px_obj,_px_grp,_px_stage,_px_kont)
         |? _px_grp<>null() & _px_stage<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.TYDZIEN,_px_obj,_px_grp,_px_stage)
         |? _px_grp<>null()
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.TYDZIEN,_px_obj,_px_grp)
         || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.TYDZIEN,_px_obj)
         ?}
      || {? _px_grp<>null() & _px_stage<>null() & _px_kont<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.TYDZIEN,_px_obj,_px_grp,_px_stage,_px_kont)
         |? _px_grp<>null() & _px_stage<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.TYDZIEN,_px_obj,_px_grp,_px_stage)
         |? _px_grp<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.TYDZIEN,_px_obj,_px_grp)
         || PX_POZ.prefix(_px_set,_px_ver,DATY.ROK,DATY.TYDZIEN,_px_obj)
         ?}
      ?}
   ?}

|? _level='D'
|| {? _ndx_family='KONT'
   || {? _px_obj<>null() & _px_grp & _px_stage<>null()
      || PX_POZ.prefix(_px_ver,DATY.DATA,_px_kont,_px_obj,_px_grp,_px_stage)
      |? _px_obj<>null() & _px_grp<>null()
      || PX_POZ.prefix(_px_ver,DATY.DATA,_px_kont,_px_obj,_px_grp)
      |? _px_obj<>null()
      || PX_POZ.prefix(_px_ver,DATY.DATA,_px_kont,_px_obj)
      || PX_POZ.prefix(_px_ver,DATY.DATA,_px_kont)
      ?}
   |? _ndx_family='OBJ'
   || {? _px_set=null()
      || {? _px_grp<>null() & _px_stage<>null() & _px_kont<>null()
         || PX_POZ.prefix(_px_ver,DATY.DATA,_px_obj,_px_grp,_px_stage,_px_kont)
         |? _px_grp<>null() & _px_stage<>null()
         || PX_POZ.prefix(_px_ver,DATY.DATA,_px_obj,_px_grp,_px_stage)
         |? _px_grp<>null()
         || PX_POZ.prefix(_px_ver,DATY.DATA,_px_obj,_px_grp)
         || PX_POZ.prefix(_px_ver,DATY.DATA,_px_obj)
         ?}
      || {? _px_grp<>null() & _px_stage<>null() & _px_kont<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.DATA,_px_obj,_px_grp,_px_stage,_px_kont)
         |? _px_grp<>null() & _px_stage<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.DATA,_px_obj,_px_grp,_px_stage)
         |? _px_grp<>null()
         || PX_POZ.prefix(_px_set,_px_ver,DATY.DATA,_px_obj,_px_grp)
         || PX_POZ.prefix(_px_set,_px_ver,DATY.DATA,_px_obj)
         ?}
      ?}
   ?}

?};
~~


\view_prefix
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Prefiksuje tabele PX_POZ na podstawie aktualnego rekordu tabeli daty
::       Kontekst pracy - aktualny widok planu - PX_VIEW
::   WE: _a - PX_VER.ref()
::       _b - DATY.ref()
::       _c - PX_KONT.ref()
::       _d - STRING - tryb prefiksowania: S - po czasie rozpoczecia pozycji planu
::                                         E - po czasie zakonczenia pozycji planu
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_data:=_b;
_px_kont:=_c;
_mode:=_d;

_level:=PX_VIEW.LEVEL;
_ndx_family:='KONT';

DATY.cntx_psh();
DATY.clear();
{? DATY.seek(_data)
||
   _index:=_mode+'_'+_level+'_'+_ndx_family;
   PX_POZ.index(_index);

   {? _level='R'
   || PX_POZ.prefix(_px_ver,DATY.ROK,_px_kont)
   |? _level='P'
   || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.POLROCZE,_px_kont)
   |? _level='K'
   || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.KWARTAL,_px_kont)
   |? _level='M'
   || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.MIESIAC,_px_kont)
   |? _level='T'
   || PX_POZ.prefix(_px_ver,DATY.ROK,DATY.TYDZIEN,_px_kont)
   |? _level='D'
   || PX_POZ.prefix(_px_ver,DATY.DATA,_px_kont)
   ?};
   ~~
?};
DATY.cntx_pop();
~~


\view_filter
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Prefiksuje tabele PX_POZ na podstawie przekazanego interwalu czasu
::   WE: _a - REAL - tm_stamp poczatkowy
::       _b - REAK - tm_stamp koncowy
::       _c - PX_KONT.ref()
::   WY: 0/1 - czy filtr zostal nalozony, czy nie
::----------------------------------------------------------------------------------------------------------------------
_start:=_a;
_end:=_b;
_px_kont:=_c;

_aa:='NOT(PX_POZ.TM_END>:_f      AND PX_POZ.TM_END<:_g)';
_bb:='NOT(PX_POZ.TM_START>=:_f   AND PX_POZ.TM_END<=:_g)';
_cc:='NOT(PX_POZ.TM_START>=:_f   AND PX_POZ.TM_START<:_g)';
_dd:='NOT(PX_POZ.TM_START<:_f    AND PX_POZ.TM_END>:_g)';
_ee:='PX_POZ.PX_KONT=:_h';

_result:=PX_POZ.f_set('TM_START' ,
                                 ,
                                 'NOT (:_a AND :_b AND :_c AND :_d) AND :_e',
                                 _aa,_bb,_cc,_dd,_ee,_start,_end,_px_kont
                                 );
_result


\szczegoly_sum
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Na podstawie biezacej dziedziny filtra tabeli PX_POZ zlicza ilosci zajete, wykonane itp i wypelnia odpowiednie
::       pola zmiennej PX_VAR
::       Kontekst pracy - PX_KONT, PX_CUP
::   WE: _a - INTEGER - tryb wypelniania zmiennej PX_VAR: 0 - na podstawie aktualnego PX_CUPa
::                                                        1 - na podstawie zafiltrowanych PX_POZ i PX_CUP
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_mode:=_a;

_il_wym:=PX_KONT.IL_WYM;
_cap_max:=obj_new(_il_wym);
_cap_min:=obj_new(_il_wym);

:: Obsługa automatycznych podsumowań - wstępnie wyłączenie wszystkich kolumn
{! _it:=1..exec('il_wym','px_param')
|! PX_POZ.fld_attr('CAP_EAT'+$_it,,2);
   PX_POZ.fld_attr('CAP_WYK'+$_it,,2)
!};

{! _it:=1.._il_wym
|!
   _cap_max[_it]:=0;
   _cap_min[_it]:=0;

:: Czyszczenie zmiennych wyswietlanych w oknie
   _rule:=$('PX_VAR.CAP_MAX'+$_it+':=0');
   _rule2:=$('PX_VAR.CAP_MIN'+$_it+':=0');
   _rule();
   _rule2();

:: Obsługa automatycznych podsumowań - włączenie kolumn i ustawienie dokładności
   PX_POZ.fld_attr('CAP_EAT'+$_it,,3);
   PX_POZ.fld_attr('CAP_WYK'+$_it,,3);
   _format:=$("'out_prec="+$($('PX_KONT.PREC'+$_it))()+"'");
   PX_POZ.win_fml('KAFELEK',,'CAP_EAT'+$_it,,'SUM_FORMAT',_format);
   PX_POZ.win_fml('KAFELEK',,'CAP_WYK'+$_it,,'SUM_FORMAT',_format)
!};

{? _mode=0
|| {! _it:=1.._il_wym
   |!
      _rule:=$('PX_VAR.CAP_MAX'+$_it+':=PX_CUP.CAP_MAX'+$_it);
      _rule2:=$('PX_VAR.CAP_MIN'+$_it+':=PX_CUP.CAP_MIN'+$_it);
      _rule();
      _rule2();
      ~~
   !}
|? _mode=1
||
:: Zliczam z zafiltrowanych PX_CUP pojemnosci max i min
   {? PX_CUP.f_first()
   ||
      {!
      |?
         {? var_pres('_max')>100
         || obj_del(_max)
         ?};
         _max:=exec('cap_max','px_cup',PX_CUP.ref());

         {? var_pres('_min')>100
         || obj_del(_min)
         ?};
         _min:=exec('cap_min','px_cup',PX_CUP.ref());
         exec('arrays_add_mod','#array',_cap_max,_max);
         exec('arrays_add_mod','#array',_cap_min,_min);
         PX_CUP.f_next()
      !};
      PX_CUP.f_first()
   ?};

   {! _it:=1.._il_wym
   |!
      _rule:=$('PX_VAR.CAP_MAX'+$_it+':=_a');
      _rule2:=$('PX_VAR.CAP_MIN'+$_it+':=_a');
      _rule(_cap_max[_it]);
      _rule2(_cap_min[_it])
   !}
?};
~~


\kolor_komm
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [17.00]
:: OPIS: Przed wyswietleniem pola PX_POZ.PX_OBJ i PX_POZ.PX_CUP
::   WY: STRING lub ~~
::----------------------------------------------------------------------------------------------------------------------
_result:=~~;

{? cur_tab(1,1)=PX_POZ
|| PX_KOMM.cntx_psh();
   PX_KOMM.index('PX_POZ');
   PX_KOMM.prefix(PX_POZ.ref());
   {? PX_KOMM.size()>0
   || _result:=exec('komm_colorizer','px_komm')
   ?};
   PX_KOMM.cntx_pop()
?};
_result


\nadwykon_moved
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy pozycja planu byla przesuwana w wyniku nadwykonan
::   WE: [_a] - PX_POZ.ref() - pozycja ktora badac - jesli argument nie podany to badac
::                             biezaca
::   WY: 0 - pozycja planu nie byla przesuwana w wyniku nadwykonan
::       1 - pozycja planu byla przesuwana w wyniku nadwykonan
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_can_continue:=1;

PX_POZ.cntx_psh();
PX_CUP.cntx_psh();

{? var_pres('_a')=type_of(PX_POZ.ref())
||
   _px_poz:=_a;
   PX_POZ.clear();
   {? PX_POZ.seek(_px_poz)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? PX_POZ.TM_SRC>0 & PX_POZ.TM_SRC<>PX_POZ.PX_CUP().TM_START
   || _result:=1
   ?}
?};
PX_CUP.cntx_pop();
PX_POZ.cntx_pop();
_result


\restore_px_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Odtwarza zawartosc pola PX_POZ.PX_SET
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy odtworzyć powiązania zestawów planistycznych z pozycjami planu i etapami przepisu?'@)
|| KOMM.init(250,,'Aktualizacja powiązań z zestawami planistycznymi'@);
   exec('for_each_mask','#table',PX_POZ,"PX_POZ.PX_SET:=PX_POZ.PX_KONT().PX_SET; PX_POZ.put()");
   exec('for_each_mask','#table',PX_STAGE,"exec('px_set_fill','px_stage',PX_STAGE.ref(),1,1)");
   {? exec('get','#params',500366,2)=exec('kind_pxtex','px_set')
   ||  exec('for_each_mask','#table',PX_OBJ,"exec('update_px_set','px_obj',PX_OBJ.ref(),1)")
   ?};
   KOMM.select()
?};
~~


\update_px_kont
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Aktualizuje pole PX_POZ.PX_SET po zmianie w PX_KONT
::   WE: _a - PX_KONT.ref()
::----------------------------------------------------------------------------------------------------------------------
_px_kont:=_a;

PX_KONT.cntx_psh();
PX_POZ.cntx_psh();
PX_KONT.prefix();
{? PX_KONT.seek(_px_kont)
|| PX_POZ.index('PX_KONT');
   PX_POZ.prefix(_px_kont);
   {? PX_POZ.first()
   || {!
      |? PX_POZ.cntx_psh();
         _next:=null();
         {? PX_POZ.next() || _next:=PX_POZ.ref() ?};
         PX_POZ.cntx_pop();

         PX_POZ.cntx_psh();
         PX_POZ.prefix();
         PX_POZ.PX_SET:=PX_KONT.PX_SET;
         PX_POZ.put();
         PX_POZ.cntx_pop();

         PX_POZ.seek(_next)
      !}
   ?}
?};
PX_KONT.cntx_pop();
PX_POZ.cntx_pop();
~~


\del_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Usuwa rekord PX_SUR do PX_POZ
::       _a - PX_POZ.ref() - rekord do usuniecia
::   WY: 0 - porazka
::       >0 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_poz:=_a;
_result:=0;

PX_POZ.cntx_psh();

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

{? PX_POZ.seek(_px_poz)
|| _result:=exec('delete','px_sur',PX_POZ.PX_VER,PX_POZ.ref())
|| _msg:='Nie znaleziono pozycji planu: '+$_px_poz;
   pxkomm.error(_msg)
?};

PX_POZ.cntx_pop();

_result


\trig_add_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger tabeli PX_POZ - przed dodaniem
::   WY: 1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
exec('px_poz_trig','px_poz')


\trig_put_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger tabeli PX_POZ - przed poprawieniem
::   WY: 1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
exec('px_poz_trig','px_poz')


\px_poz_efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Opcje pól w oknach redagowania PX_POZ
::----------------------------------------------------------------------------------------------------------------------
{! _it:=1..exec('il_wym','px_param')
|! {? _it<=PX_KONT.IL_WYM || _enable:='1' || _enable:='0' ?};
   PX_POZ.efld_opt('RED','enable='+_enable,PX_KONT,'JM'+$_it);
   PX_POZ.efld_opt('RED','enable='+_enable,,'CAP_EAT'+$_it);
   PX_POZ.efld_opt('RED','enable='+_enable,,'CAP_WYK'+$_it)
!};
~~


\fill_when
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Nawija pole PX_POZ.WHEN - do wyświetlania w okienkach
::   WE: _args - exec('blank_a','px_poz')
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
{? PX_VAR.NAST_ALG=2
||
:: Algorytm następstwa czasowego metodą proporcji ilościowej - pozycje planu mają godziny
:: więc nawijamy pole bardziej szczegółowo
   _interval:=exec('interval','#interval');
   _interval.START:=_args.TM_START;
   _interval.END:=_args.TM_END;
   _args.WHEN:=exec('to_string2','#interval',_interval)
|| _args.WHEN:=exec('FindAndGet','#table',PX_CUP,_args.PX_CUP,,"SYMBOL",'')
?};
~~


\set_new_time
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Ustala nowe czasy dla pozycji planu po przesunięciu, scaleniu
::   WE: [_a] - PX_CUP.ref lub bieżący pojemnik
::       _b - obj_new - argspoz
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------

_ref:=null();
{? var_pres('_a')=type_of(PX_CUP.ref())
|| _ref:=_a
?};

_argspoz:=_b;

_result:=0;
_can_continue:=1;

PX_KONT.cntx_psh();
PX_CUP.cntx_psh();
{? _ref<>null()
|| PX_CUP.prefix();
   {? PX_CUP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _tm_start_old:=PX_POZ.TM_START;
   _tm_end_old:=PX_POZ.TM_END;
   {? PX_VAR.NAST_ALG=2
   ||
      _il_wym:=PX_CUP.PX_KONT().IL_WYM;
      _time_value:=0;
      _time_wym:=0;
      {! _it:=1.._il_wym
      |! _jm:=($('PX_KONT.JM'+$_it+'().KOD'))();
         {? _jm=PX_VAR.P500380 | _jm=PX_VAR.P500381
         || _time_wym:=($('_argspoz:=_a;_argspoz.CAP_EAT'+$_it))(_argspoz);
            {? _time_value=0 | (_time_value<_time_wym)
            || _time_value:=_time_wym
            ?}
         ?}
      !};
      _duration:=(_time_value*exec('hour','#tm_stamp'));

::    Ustalam czas dla pozycji planu jeżeli są kalendarze pojemników. Tutaj przyjmuję założenie że nie dbam o czas trwania pozycji
::    czyli nie obchodzi mnie że pozycja planu będzie 'wystawała' poza pojemnik
::    bo zostaje przesuwana (a nie przeplanowywana z konkretnego powodu)
      {? PX_POZ.STATUS=exec('status_wyk2','px_poz')
      ||
::       Pozycja wykonana w całości (np nadwykonania) ma czas początku taki jak początek pojemnika)
         _argspoz.TM_START:=PX_CUP.TM_START;
         _argspoz.TM_END:=_argspoz.TM_START+_duration
      ||
::       Pozycja każda inna szuka pierwszego wolnego rekordu kalendarza
         PX_CAL.cntx_psh();
         PX_CAL.index('TM_START');
         PX_CAL.prefix(PX_CUP.ref());
         {? PX_CAL.first()
         || _argspoz.TM_START:=PX_CAL.TM_START;
            _argspoz.TM_END:=exec('min','#math',_argspoz.TM_START+_duration,PX_CUP.TM_END)
         ||
::          Brak wolnego kalendarza, przyjmuję że pozycja planu dostanie czas początku pojemnika
            _argspoz.TM_START:=PX_CUP.TM_START;
            _argspoz.TM_END:=exec('min','#math',_argspoz.TM_START+_duration,PX_CUP.TM_END)
         ?};
         PX_CAL.cntx_pop()
      ?}
   || _argspoz.TM_START:=PX_CUP.TM_START;
      _argspoz.TM_END:=PX_CUP.TM_END
   ?};
   {? _tm_start_old<>_argspoz.TM_START | _tm_end_old<>_argspoz.TM_END
   || _argspoz.DATE_MIN:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_START);
      _argspoz.TIME_MIN:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_START);
      _argspoz.DATE_MAX:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_END);
      _argspoz.TIME_MAX:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_END)
   ?}
?};
PX_CUP.cntx_pop();
PX_KONT.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\status_delay_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja usunięcia statusu opóźnionego dla pozycji planu opóźnionej
::       Kontekst pracy - PX_POZ
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------

_group:=0;
{? PX_POZ.sel_size()>0
|| _group:=1
?};

_can_continue:=1;
_result:=0;

{? _group=0
|| _can_continue:=FUN.ask('Usunąć status opóźniony dla pozycji: %1'@[exec('PX_POZ','#to_string')])
?};

{? _can_continue>0
|| {? PX_POZ.STATUS<>exec('status_delay','px_poz')
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _can_continue:=exec('status_set','px_poz',PX_POZ.ref(),exec('status_normal','px_poz'));
   {? _can_continue>0
   || _can_continue:=exec('status_update','px_poz',PX_POZ.ref(),,0)
   ?};
   {? _can_continue>0
   || _can_continue:=exec('status_rebuild','px_grp',PX_POZ.PX_GRP)
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
_result


\status_delay_del_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja usunięcia statusu opóźnionego - grupa przed
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_can_continue:=1;
_result:=0;
sel_nchk();

{? PX_POZ.sel_size()>0
|| _can_continue:=FUN.ask('Zaznaczonych pozycji planu: %1. Usunąć im status opóźniony?'@[$PX_POZ.sel_size()])
?};
{? _can_continue>0
|| _result:=1
?};
_result


\status_delay_del_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja usunięcia statusu opóźnionego - grupa po
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
~~


:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:38 c5aea4f1a892e5219ae82ef39a0008f5572e9f12f29ac149399ef0a8cd448f15e373e27a147a2f04452b2fda08f7ec2c288b6d4a2687f6a898e6bf3cf75c7c42584f71524279089b5276a1d08ac27b6af4ab4f802f2d712da13ee737da4715aac9c5d95883deb960414bab3967f2739b9b47a95964ab79199bf716fe180da95e
