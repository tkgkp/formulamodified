:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: stp.fml
:: Utworzony: 24.01.2013
:: Autor: TMR
::======================================================================================================================
:: Zawartosc: Formuly do obslugi zaleznosci sluzbowych
::======================================================================================================================


\lista
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Wyswietla okno z zaleznosciami sluzbowymi
::----------------------------------------------------------------------------------------------------------------------
:: odlozenie kontekstow
SLO_KOD.cntx_psh();
P.cntx_psh();
OSOBA.cntx_psh();
UD_SKL.cntx_psh();
STN.cntx_psh();
STP.index('STP_P');

:: utworzenie obiektu oStp
{? var_pres('oStp')>100 || obj_del(oStp) ?};
oStp:=exec('stp_create','stp');
oStp.select();

:: przywrocenie kontekstow i usuniecie obiektu oStp
STN.cntx_pop();
UD_SKL.cntx_pop();
OSOBA.cntx_pop();
P.fld_fml('F_ZATR','BEFORE_DISPLAY',"*");
P.cntx_pop();
SLO_KOD.cntx_pop();
obj_del(oStp);
&oStp;
~~


\cb_typ_zal_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Formula wykonywana przed pobraniem danych do comboboxa z typem zaleznosci
::----------------------------------------------------------------------------------------------------------------------
_slo_typ:=exec('slo_typ','ext_slo','TYPPOZ');
SLO_KOD.index('KOD');
SLO_KOD.prefix(_slo_typ)


\cb_typ_zal_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Formula dla comboboxa - wybor typu zaleznosci
::----------------------------------------------------------------------------------------------------------------------
_sel_typ:=exec('get_value','#desktop','','stp_rodzaj',oStp.pSID.cbTypZal);
_rb1:=exec('get_value','#desktop','','stp_rodzaj',oStp.pSID.rbPrac);
_rb2:=exec('get_value','#desktop','','stp_rodzaj',oStp.pSID.rbPoz);
_r:={? _rb1='true'
    || 'P'
    |? _rb2='true'
    || 'O'
    ?};
oStp.R:=_r;
oStp.Typ:=_sel_typ;
oStp.refresh();
1


\rb_rodzaj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Formula dla radiobuttona - wybor rodzaju prezentacji
::   WE: _a - [STRING] - 'P' (wg. pracowników), 'O' (wg. pozycji w organizacji)
::----------------------------------------------------------------------------------------------------------------------
_rodzaj:={? var_pres('_a')=type_of('_a') || _a || 'P' ?};
{? _rodzaj='P'
||
   exec('set_value','#desktop','','stp_rodzaj',oStp.pSID.rbPoz,'false');
:: pokazujemy buttony Przelozeni/Podwaldni
   exec('set_visible','#desktop','','stp_rodzaj',oStp.pSID.btnPrzel,1);
   exec('set_visible','#desktop','','stp_rodzaj',oStp.pSID.btnPodwl,1);
:: ukrywamy buttony Nadrzedny/Podrzedny
   exec('set_visible','#desktop','','stp_rodzaj',oStp.pSID.btnNadrz,0);
   exec('set_visible','#desktop','','stp_rodzaj',oStp.pSID.btnPodrz,0);
:: przelaczamy zakladki
   tab_hide(2,,'panel0');
   tab_show(1,'panel0')
|? _rodzaj='O'
||
   exec('set_value','#desktop','','stp_rodzaj',oStp.pSID.rbPrac,'false');
:: ukrywamy buttony Przelozeni/Podwaldni
   exec('set_visible','#desktop','','stp_rodzaj',oStp.pSID.btnPrzel,0);
   exec('set_visible','#desktop','','stp_rodzaj',oStp.pSID.btnPodwl,0);
:: pokazujemy buttony Nadrzedny/Podrzedny
   exec('set_visible','#desktop','','stp_rodzaj',oStp.pSID.btnNadrz,1);
   exec('set_visible','#desktop','','stp_rodzaj',oStp.pSID.btnPodrz,1);
:: przelaczamy zakladki
   tab_hide(1,,'panel0');
   tab_show(2,'panel0')
?};
_sel_typ:=exec('get_value','#desktop','','stp_rodzaj',oStp.pSID.cbTypZal);
oStp.R:=_rodzaj;
oStp.Typ:=_sel_typ;
oStp.refresh();
1


\stp_create
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Tworzy obiekt nazwany do obsługi tabeli STP
::   WY: Obiekt _stp
::----------------------------------------------------------------------------------------------------------------------
::pomysl jerrego do formatowania pol obiektu ;-)
::UWAGA: _fld, i _mth to formulki pomocnicze, zeby wygodniej tworzyc tablice i komentowac poszczegolne jej elementy
_fld:="8+form(_a)";
_mth:="8+form(_a)";
::tworze tablice nazwana do przechowywania zmiennych
_stp:=obj_new(
                _fld('pSID'    ,'obiekt przechowujacy SID elementow pulpitu')
::             pola do przechowywania informacji
               ,_fld('R'       ,'wskazanie na wybrany rodzaj zaleznosci')
               ,_fld('Typ'     ,'wskazanie na wybrany slo kod')
               ,_fld('Stp_ref' ,'wskazanie na wybrany rekord STP')

::             identyfikatory okienek
               ,_fld('wid_Grup' ,'ID okienka grupowego STP')
               ,_fld('wid_Prac' ,'ID okienka tabeli STP dla pracownikow')
               ,_fld('wid_Poz'  ,'ID okienka tabeli STP dla pozycji w organizacji')

               ,_fld('Tab'      ,'Tabela STP')
               ,_fld('GrupSel'  ,'Okienko grupowe tabeli STP')
               ,_fld('PracSel'  ,'Okienko tabeli STP dla widoku pracownikow')
               ,_fld('PozSel'   ,'Okienko tabeli STP dla widoku pozycji')

               ,_fld('TABPL'   ,'Tabela na tłumaczenia')

               ,_mth('prefix'   ,'prefixuje tabele STP')
               ,_mth('refresh'  ,'Odswieza informacje w oknie')
               ,_mth('select'   ,'Wyswietla STP')
               ,_mth('add'      ,'Dolacza pracownika dla STP')
               ,_mth('del'      ,'Usuwa pozycje w organizacji dla STP')
               ,_mth('dndPrac'  ,'DnD dla pracownika w STP')
               ,_mth('dndPoz'   ,'DnD dla pozycji w organizacji w STP')
               ,_mth('rekPrzPr' ,'rekord przed dla pracownika')
               ,_mth('rekPrzPo' ,'rekord przed dla pozycji')
               ,_mth('ib_za'    ,'ikona przed pola P.ZA')
               ,_mth('gBefore'  ,'Grupa przed')
             );
::usuwamy zbedne zmienne
&_mth; &_fld;

:: dodajemy SID elementow pulpitu
_stp.pSID:=obj_new('lbTyp','lbWg',
                   'rbPrac','rbPoz',
                   'cbTypZal',
                   'btnDodaj','btnUsun','btnKop','btnPrzel','btnPodwl','btnPodrz','btnNadrz');

_stp.pSID.lbTyp:='2hje63kkd8enl0n5jnf4egk71a81c';
_stp.pSID.lbWg:='3i4jb992j629d6bch618m59518n7';
_stp.pSID.rbPrac:='29e41n2eed5l0f4kl7k23kfi13jj6';
_stp.pSID.rbPoz:='190edk9bg65mceb3mg9fbb8nigdn0';
_stp.pSID.cbTypZal:='21a00h5bb5cccii5alclb1b8jf4jf';
_stp.pSID.btnDodaj:='5bh9824me314748j3f71l3jhgbc3';
_stp.pSID.btnUsun:='73d18f6daa9e8lglc18bd469cl98';
_stp.pSID.btnKop:='58aa42c4jm5nmegm02a6j2ma627a';
_stp.pSID.btnPrzel:='11n71iejfg55ennb480c152g5e5fl';
_stp.pSID.btnPodwl:='15gi5abkeb022i0cfaji6j34mbeml';
_stp.pSID.btnPodrz:='2agcb4ni7iafjnclg3j01lj070206';
_stp.pSID.btnNadrz:='33cg733eb8g0862hjdeddli1gk0f';

_stp.TABPL:=exec('elements_table','#desktop');
_add:="_a.blank(); _a.ID_SYS:=_b; _a.NAME:=_c; _a.add()";
_add(_stp.TABPL,_stp.pSID.lbTyp,'Typ zależności'@);
_add(_stp.TABPL,_stp.pSID.lbWg,'Przeglądanie według'@);
_add(_stp.TABPL,_stp.pSID.rbPrac,'pracowników'@);
_add(_stp.TABPL,_stp.pSID.rbPoz,'pozycji w organizacji'@);
_add(_stp.TABPL,_stp.pSID.btnDodaj,'Dołącz'@);
_add(_stp.TABPL,_stp.pSID.btnUsun,'Usuń'@);
_add(_stp.TABPL,_stp.pSID.btnKop,'Kopiuj schemat'@);
_add(_stp.TABPL,_stp.pSID.btnPrzel,'Przełożeni'@);
_add(_stp.TABPL,_stp.pSID.btnPodwl,'Podwładni'@);
_add(_stp.TABPL,_stp.pSID.btnPodrz,'Podrzędne'@);
_add(_stp.TABPL,_stp.pSID.btnNadrz,'Nadrzędne'@);

_stp.Tab:=STP;
_stp.Stp_ref:=null();
_stp.R:='';
_stp.Typ:='';

:: nadajemy wartosci identyfikatorom okien
_stp.wid_Grup:='#stp_sel_grupa_';
_stp.wid_Prac:='#stp_sel_prac__';
_stp.wid_Poz:='#stp_sel_poz___';

_stp.GrupSel:='';
_stp.PracSel:='';
_stp.PozSel:='';

:: formula prefixujaca
_stp.prefix:="
   _slo_kod:=exec('kod','ext_slo','TYPPOZ',.Typ);
   STP.index('STP_P');
   STP.prefix(exec('ref_firma','ustawienia'),.R,_slo_kod);
   ~~
";
::formula no odswiezenie okien
_stp.refresh:="
   .prefix();
   {? .Tab.first()
   || .Stp_ref:=.Tab.ref()
   || .Stp_ref:=null()
   ?};
   grp_disp(.Tab,.PracSel);
   grp_disp(.Tab,.PozSel);
   ~~
";

:: formula na Dolacz
_stp.add:="
   {? oStp.R='P'
   || exec('addPrac','stp')
   |? oStp.R='O'
   || exec('addPoz','stp')
    ?};
   ~~
";

:: formula na Usun (wg. pracownikow i pozycji w organizacji)
_stp.del:="
   exec('delPoz','stp');
   ~~
";

:: formula na DnD (wg. pracownikow)
_stp.dndPrac:="
   _ruleSrc:=\"STP.P().OSOBA().NAZWISKO + ' ' + OSOBA.PIERWSZE + ' ('+form(P.T)+')'\";
   _ruleDst:=_ruleSrc;
   exec('dnd_tree_grp','libfml',STP,_ruleSrc,_ruleDst,1)
";

:: formula na DnD (wg. pozycji w organizacji)
_stp.dndPoz:="
   _ruleSrc:=\"STP.POZWORG().KOD + ' - ' + STP.POZWORG().OPIS\";
   _ruleDst:=_ruleSrc;
   exec('dnd_tree_grp','libfml',STP,_ruleSrc,_ruleDst,1)
";

_stp.rekPrzPr:="
   STP.P().OSOBA().NAZWISKO;
   REF.OSOBA:=OSOBA.ref();
   STP.P().ST().ST;
   STP.P().WYDZIAL().SYMBOL;
   STP.POZWORG:=STP.P().POZWORG
";

_stp.rekPrzPo:="
   STP.POZWORG().KOD
";

_stp.ib_za:="
   {? STP.P().ZA = 'T'
   || 'xwin16.png:13'
   || 'xwin16.png:14'
   ?}
";

_stp.gBefore:="
    tab_hide(1,,'panel0');
    tab_hide(2,,'panel0');
    oStp.refresh();
::  laduje desktop
    exec('load','#desktop','stp_rodzaj','stp_rodzaj.dsk',,,,,oStp.TABPL,1);
::  domyslnie ustawiam widok wg pracownikow i typ zaleznosci akceptacja wnioskow (nadpisywane pozniej wyborem usera)
    exec('set_value','#desktop','','stp_rodzaj',oStp.pSID.rbPrac,'true');
    exec('set_value','#desktop','','stp_rodzaj',oStp.pSID.cbTypZal,'AKCWNIO');
::  na razie ukrywam widok zaleznosci wg pozycji w organizacji
    exec('set_value','#desktop','','stp_rodzaj',oStp.pSID.rbPoz,'false');
    exec('set_visible','#desktop','','stp_rodzaj',oStp.pSID.rbPrac,1);
    exec('set_visible','#desktop','','stp_rodzaj',oStp.pSID.rbPoz,1);
    exec('set_visible','#desktop','','stp_rodzaj','12274eja699dg1ba0gid5mednh4n9',0);
    1
";

_stp.select:="
   {? exec('interm','#system')
   || FUN.emsg(exec('interm_nacc_msg','#system'));
      return()
   ?};
   exec('stpCreateSel','stp',.);
   STP.index('STP_P');
   STP.prefix(exec('ref_firma','ustawienia'),'',null);
   .Tab.select();
   ~~
";

::zwracamy obiekt _stp
_stp


\stpCreateSel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Tworzy okienka dla tabeli STP
::   WE: _a - wskazanie na obiekt _stp
::----------------------------------------------------------------------------------------------------------------------
_stp:=_a;

:: okienka skladowe
{? _stp.PracSel='' || exec('stpCPracSel' ,'stp',_stp) ?};
{? _stp.PozSel=''  || exec('stpCPozSel' ,'stp',_stp) ?};

:: okienko grupowe
{? _stp.GrupSel='' || exec('stpCGrupSel' ,'stp',_stp) ?};
1


\stpCPracSel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Tworzy okienko dla pracownikow tabeli STP
::   WE: _a - wskazanie na obiekt _stp
::----------------------------------------------------------------------------------------------------------------------
_stp:=_a;

_akt_sch:="
   {? FUN.ask(
         'Aktualizacja schematu spowoduje nadpisanie istniejących zależności służbowych.\n'
         'Czy kontynuować działanie?'@
      )
   || exec('makeTabStp','stp',2,1,oStp.R,'TYPPOZ',oStp.Typ)
   ?}";

_wer:=STP.mk_sel('','N',0,_stp.wid_Prac,,,,1);
STP.win_act(_wer,1,'Formuła','Dołącz'@@,,,_stp.add,,1);
STP.win_act(_wer,1,'Formuła','Kopiuj schemat'@@,,,"exec('oKopSelect','stp',oStp.R)");
STP.win_act(_wer,1,'Formuła','Aktualizuj schemat'@@,,,_akt_sch);
STP.win_act(_wer,0,'Formuła','Dołącz'@@,,,_stp.add,,1);
STP.win_act(_wer,,'Formuła','Usuń'@@,,,_stp.del);
STP.win_act(_wer,,'Formuła','Przełożeni'@@,,,"exec('showPracPodNad','stp',STP.ref(),oStp.Typ,1)");
STP.win_act(_wer,,'Formuła','P&odwładni'@@,,,"exec('showPracPodNad','stp',STP.ref(),oStp.Typ,0)");
STP.win_act(_wer,,'Formuła','Kopiuj schemat'@@,,,"exec('oKopSelect','stp',oStp.R)");
STP.win_act(_wer,,'Formuła','Aktualizuj schemat'@@,,,_akt_sch);
STP.win_act(_wer,,'Formuła','Szukaj'@@,,,"exec('szukaj','stp')");
STP.win_act(_wer,0,'Formuła','Zwiń/rozwiń'@@,,,"exec('zwrw_all','#tree',STP,'STP',oStp.PracSel)",,,,,,
   'Z',,'target=window'
);
STP.win_act(_wer,,'Rekord',,,,_stp.rekPrzPr);

STP.win_fld(_wer,OSOBA,'NAZWISKO','P',,25,,,'Nazwisko'@,,,,,,,,);
STP.win_fld(_wer,OSOBA,'PIERWSZE','P',,15,,,'Imię'@,,,,,,,,);
STP.win_fld(_wer,P,'F_ZATR','KOD',,-5,,,'Forma współpracy'@,,,,,,,,);
STP.win_fld(_wer,P,'T',,,-9,,,'Nr teczki'@,,,,,,,,);
STP.win_fld(_wer,UD_SKL,'SYMBOL','P',,-10,,,'Jednostka organizacyjna'@,,,,,,,,);
STP.win_fld(_wer,STN,'ST','P',,15,,,'Stanowisko'@,,,,,,,,);
STP.win_fld(_wer,STN,'K','P',,7,,,'Kierownicze?'@,,,2,,"'T'","'N'",,);
STP.win_fld(_wer,P,'ZA',,,5,,,'Aktywny?'@,,,,,,,,);

STP.win_fml(_wer,P,'ZA',,'ICON_BEFORE',_stp.ib_za);
STP.tr_fml(_wer,"","{? _a=-1 || 1 || {? _a>0 || 1 || 0 ?} ?}");

STP.dnd_sel(_wer,,'records.STP',_stp.dndPrac);

_stp.PracSel:=_wer;
~~


\szukaj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Wyszukuje rekord na podstawie wzorca
::----------------------------------------------------------------------------------------------------------------------
undefine();
define('NAZWISKO','','Nazwisko'@,,30,30,);
define('IMIE','','Imię'@,,20,30,);
{? def_edit(,'Szukaj'@)
|| OSOBA.cntx_psh();
   _ref_o:=OSOBA.find_tab(0,
                          'NAZWISKO',,':-',DEFINE.NAZWISKO,
                          'PIERWSZE',,':-',DEFINE.IMIE
                         );

   {? _ref_o
   || {? ~STP.find_tab(0,
                       'R',,'=','P',
                       'P','OSOBA','=',OSOBA.ref(),
                       'P','FIRMA','=',exec('ref_firma','ustawienia')
                       )
      || FUN.info('Nie znaleziono rekordu zgodnego ze wzorcem.'@)
      ?}
   ?};
   OSOBA.cntx_pop()
?}


\stpCPozSel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Tworzy okienko dla pracownikow tabeli STP
::   WE: _a - wskazanie na obiekt _stp
::----------------------------------------------------------------------------------------------------------------------
_stp:=_a;

_wer:=STP.mk_sel('','P',0,_stp.wid_Poz,,,,1);
STP.win_act(_wer,1,'Formuła','Dołącz'@@,,,_stp.add);
STP.win_act(_wer,0,'Formuła','Dołącz'@@,,,_stp.add);
STP.win_act(_wer,,'Formuła','Usuń'@@,,,_stp.del);
STP.win_act(_wer,,'Rekord',,,,_stp.rekPrzPo);
STP.win_act(_wer,0,'Formuła','Zwiń/rozwiń'@@,,,"exec('zwrw_all','#tree',STP,'STP',oStp.PozSel)",,
   1,,,,'Z',,'target=window'
);
STP.win_act(_wer,,'Formuła','pOdrzędne'@@,,,"exec('showPozPodNad','stp',STP.ref(),oStp.Typ,0)");
STP.win_act(_wer,,'Formuła','Nadrzędne'@@,,,"exec('showPozPodNad','stp',STP.ref(),oStp.Typ,1)");
STP.win_act(_wer,1,'Formuła','Kopiuj schemat'@@,,,"exec('oKopSelect','stp',oStp.R)");
STP.win_act(_wer,,'Formuła','Kopiuj schemat'@@,,,"exec('oKopSelect','stp',oStp.R)");

STP.win_fld(_wer,POZWORG,'OPIS','POZWORG',,90,,,'Opis'@,,,,,,,,);
STP.win_fld(_wer,POZWORG,'KOD','POZWORG',,15,,,'Kod'@,,,,,,,,);

STP.tr_fml(_wer,"","{? _a=-1 || 1 || {? _a>0 || 1 || 0 ?} ?}");

STP.dnd_sel(_wer,,'records.STP',_stp.dndPoz);

_stp.PozSel:=_wer;
~~


\stpCGrupSel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Tworzy okienko grupowe dla tabeli STP
::   WE: _a - wskazanie na obiekt _stp
::----------------------------------------------------------------------------------------------------------------------
_stp:=_a;

_grp:=STP.grp_make('Zależności służbowe'@,_stp.gBefore,_stp.wid_Grup,,,,);
STP.grp_sel(_grp,,_stp.PracSel,'Zależności służbowe wg. pracowników'@,,,,,,,,,'maximized');
STP.grp_sel(_grp,,_stp.PozSel,'Zależności służbowe wg. pozycji w organizacji'@,,,,,,,,,'maximized');
:: dodanie kontrolki z wyborem widoku i typu zaleznosci
STP.grp_splt(_grp,,'vertical','panel1');
exec('create','#desktop',_stp.Tab,'stp_rodzaj',_grp,20,50);

_stp.GrupSel:=_grp;
STP.win_sel(_grp);
~~


\afterLoad
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Formula wykonywana po wczytaniu kontrolki w celu odczytania ustawionych parametrow
::----------------------------------------------------------------------------------------------------------------------
:: pobierz wartosci radiobuttonow z kontrolki
_rb1:=exec('get_value','#desktop','','stp_rodzaj',oStp.pSID.rbPrac);
_rb2:=exec('get_value','#desktop','','stp_rodzaj',oStp.pSID.rbPoz);
_r:={? _rb1='true'
    || 'P'
    |? _rb2='true'
    || 'O'
    ?};
:: symulacja wybrania pozycji z radiobuttona
exec('rb_rodzaj','stp',_r)


\addPrac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Dodaje pracownika do zaleznosci zluzbowych
::       Musi byc zdefinowany obiekt oStp
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('wybierz_args','pracownik');
_args.DOMAIN:='PKD';
_args.UD_SCH:=exec('domyslny','schemat','PODZORG');
_args.UD_SKL:=exec('ud_skl_firma','schemat','PODZORG');
_args.F_ZATR:='*T';
_args.VIEW:='W';

_kod:=exec('kod','ext_slo','TYPPOZ',oStp.Typ);
_ret:=exec('wybierz','pracownik',_args);
_loop:=_ret.P.first();
P.cntx_psh();
P.f_clear();
P.clear();
{!
|? _loop
|! {? P.seek(_ret.P.SQL)
   || STP.blank(1);
      STP.R:=oStp.R;
      STP.TYP:=_kod;
      STP.P:=P.ref();
      STP.STP:=STP.ref();
      STP.cntx_psh();
      STP.prefix();
      STP.add();
      STP.cntx_pop()
   ?};
   _loop:=_ret.P.next()
!};
P.cntx_pop();
~~


\addPoz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Dodaje pozycje w organizacji do zaleznosci zluzbowych
::       Musi byc zdefinowany obiekt oStp
::----------------------------------------------------------------------------------------------------------------------
POZWORG.cntx_psh();
POZWORG.index('KOD');
POZWORG.prefix(exec('ref_firma','ustawienia'));
_wer:=POZWORG.mk_sel('Pozycja w organizacji'@,'P',0,'201303121456',,,,,'U');
POZWORG.win_act(_wer,,'Formuła','Wybierz'@@,,,
  "_grupa:=0;
   {? cur_tab().sel_size()>0
   || _grupa:=1
   ?};
   {? STP.get()
   || _stp_ref:=STP.ref()
   || _stp_ref:=null()
   ?};
   _poz_ref:=POZWORG.ref();
   _jest_p:=0;
   _slo_kod:=exec('kod','ext_slo','TYPPOZ',oStp.Typ);
:: sprawdzenie czy pozycja jest juz w tabeli zaleznosci
   STP.cntx_psh();
   _ndx:=STP.ndx_tmp('',1,'P','FIRMA',,'R',,,'TYP',,,'POZWORG',,);
   STP.index(_ndx);
   STP.prefix(exec('ref_firma','ustawienia'),oStp.R,_slo_kod,_poz_ref);
   {? STP.first()
   || {? ~_grupa
      || FUN.info('Wybrana pozycja jest już dodana do tabeli zależności służbowych.'@)
      ?};
      _jest_p:=1
   ?};
   {? ~_jest_p
   || STP.blank(1);
      STP.R:=oStp.R;
      STP.TYP:=_slo_kod;
      STP.POZWORG:=_poz_ref;
      STP.STP:=_stp_ref;
      STP.prefix();
      STP.add()
   ?};
   STP.ndx_drop(_ndx);
   STP.cntx_pop();
   {? cur_tab().sel_size()=0
   || {? ~_jest_p || sel_exit() ?}
   ?};
   ~~",,1,1,
::grupa przed
   "{? FUN.ask('Czy przypisać zaznaczone pozycje?'@) || 1 || 0 ?}",
::grupa po
   "{? cur_tab().sel_size()=0 || sel_exit() ?}"
);


POZWORG.win_act(_wer,,'Rekord',,,,"
   _poz_ref:=POZWORG.ref();
   _slo_kod:=exec('kod','ext_slo','TYPPOZ',oStp.Typ);
:: sprawdzenie czy pracownik jest juz w tabeli zaleznosci
   STP.cntx_psh();
   _ndx:=STP.ndx_tmp('',1,'P','FIRMA',,'R',,,'TYP',,,'POZWORG',,);
   STP.index(_ndx);
   STP.prefix(exec('ref_firma','ustawienia'),oStp.R,_slo_kod,_poz_ref);
   {? STP.first()
   || POLA_GRP.TXT_1:='T'
   || POLA_GRP.TXT_1:='N'
   ?};
   STP.ndx_drop(_ndx);
   STP.cntx_pop();
   ''
");
POZWORG.win_fld(_wer,POLA_GRP,'TXT_1',,,5,,,'Dodana?'@,,,2,,"'T'","'N'");
POZWORG.win_fld(_wer,POZWORG,'KOD',,,10,,,'Kod'@,,,,,,,,);
POZWORG.win_fld(_wer,POZWORG,'OPIS',,,30,,,'Opis'@,,,,,,,,);
POZWORG.win_sel(_wer);
POZWORG.select();
POZWORG.cntx_pop();
~~


\delPoz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Usuwa pozycje w STP.
::   WE: _a  [REFERENCE] - wskazanie na STP
::      [_b]  [NUMBER]    - sposób usuwania rekordów 1-przepina podrzędne, 2-usuwa podrzędne
::      [_c] [NUMBER]    - czy wyświetlać komunikaty
::      [_d] [NUMBER]    - czy wyszukać rodzica
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
       _ref:={? var_pres('_a')=type_of(null()) || _a || STP.ref() ?};
       _del:={? var_pres('_b')=type_of(0)      || _b || 0         ?};
       _msg:={? var_pres('_c')=type_of(0)      || _c || 1         ?};
_seekParent:={? var_pres('_d')=type_of(0)      || _d || 1         ?};

_del:={? _msg & _del=0
      || FUN.choice('Czy usunąć bieżący zapis?'@,0,'Pozostaw podrzędne'@,'Usuń podrzędne'@)
      || _del
      ?};

:: powrot w przypadku zerwanej transakcji
{? do_state()=2 || return(0) ?};

STP.cntx_psh();
STP.prefix();
{? _del>0 & STP.seek(_ref)
|| _ref2seek:=STP.STP;
:: zalozenie transakcji
   _mydo:=do_state()=0;
   {? _mydo || do() ?};
   {? {? _del=1 || exec('move_tree','libfml',STP,'STP',,#_ref)
      |? _del=2 || exec('del_tree_branch','#tree',STP,'STP',,#_ref)
      ?}
   || _result:=STP.del(,1);
      {? _result
      || {? _seekParent || STP.seek(_ref2seek,) ?}
      || undo()
      ?}
   ?};
   {? _mydo || end() ?}
?};
STP.cntx_pop();
_result


\delPrac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [18.42]
:: OPIS: Usuwa wszystkie rekordy STP dla pracownika
::   WE: _a [REFERENCE] - wskazanie na pracownika
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_p_ref:={? var_pres('_a')=type_of(null()) || _a || return(_result) ?};

STP.cntx_psh();
STP.index('S1');
STP.prefix(_p_ref);
{? STP.first()
|| {!
   |? {? exec('delPoz','stp',STP.ref(),1,0,0)
      || _result+=1;
         STP.next()
      || 0
      ?}
   !}
|| _result:=1
?};
STP.cntx_pop();
_result


\prac_pod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja zwraca pracownikow podwladnych pracownika przekazanego parametrem
::   WE: _a - [REFERENCE]  - wskazanie na pracownika
::       _b - [STRING]     - symbol slownika kodow, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::       _c - [STRING]     - symbol kodu zaleznosci sluzbowych, jesli pominiety lub inny niz napis,
::                           to przyjety zostanie NIEZNANY
::       _d - [TABLE]      - tabela z pracownikami podwladnymi
::       _e - [STRING]     - path
::   WY:      [TABLE]      - tabela z pracownikami podwladnymi
::            UWAGA!!!     - jezeli przekazane parametry beda bledne, to zostanie zwrocona pusta tabela
::----------------------------------------------------------------------------------------------------------------------
:: tworzymy tabele zaleznosci pracownikami
   _tab:={? var_pres('_d')<>type_of(SYSLOG)      || exec('tab_zal','stanprac') || _d ?};
 _p_ref:={? var_pres('_a')<>type_of(null())      || return(_tab)               || _a ?};
   _slo:={? var_pres('_b')<>type_of('') | |_b='' || 'NIEZNANY'                 || _b ?};
   _kod:={? var_pres('_c')<>type_of('') | |_c='' || 'NIEZNANY'                 || _c ?};
  _path:={? var_pres('_e')<>type_of('') | |_e='' || 'B'                        || _e ?};

:: wypelniamy tabele
exec('stp_pod','stp',_p_ref,_slo,_kod,'P',_tab,_path);
P.cntx_psh();
P.prefix();
{? P.seek(_p_ref)
||
:: dodajemy podwladnych wynikających z zastepstw
   exec('prac_pod_zal','stp',P.OSOBA,_slo,_kod,_tab);
:: dodajemy podwladnych wynikających z pelnionych obowiazkow
   exec('prac_pod_ob','stp',P.ref(),_slo,_kod,_tab)
?};
P.cntx_pop();
_tab


\pwo_pod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja zwraca pozycje podrzedne dla pozycji w organizacji przekazanej parametrem
::   WE: _a - [REFERENCE]  - wskazanie na pozycje w organizacji
::       _b - [STRING]     - symbol kodu zaleznosci sluzbowych (typ zalezniosci)
::   WY:      [TABLE]      - tabela z pozycjami podrzednymi
::            UWAGA!!!     - jezeli przekazane parametry beda bledne, to zostanie zwrocona pusta tabela
::----------------------------------------------------------------------------------------------------------------------
:: tworzymy tabele zaleznosci pwo
_tab:=exec('tab_zal_pwo','stp');
:: wypelniamy tabele
exec('stp_pod','stp',_a,_b,'O',_tab);
_tab


\prac_nad
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja zwraca przelozonych pracownika przekazanego parametrem
::   WE: _a - [REFERENCE]  - wskazanie na pracownika
::       _b - [INTEGER]    - 1 - nie wybiera nieobecnych pracownikow, 0 - wybiera wszystkich
::       _c - [STRING]     - symbol slownika kodow, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::       _d - [STRING]     - symbol kodu zaleznosci sluzbowych (typ zalezniosci)
::       _e - [TABLE]      - tabela z pracownikami przelozonymi
::       _f - [INTEGER]    - poziom zaleznosci
::   WY:      [TABLE]      - tabela z pracownikami przelozonymi
::            UWAGA!!!     - jezeli przekazane parametry beda bledne, to zostanie zwrocona pusta tabela
::----------------------------------------------------------------------------------------------------------------------
:: tworzymy tabele zaleznosci pracownikami
   _tab:={? var_pres('_e')<>type_of(SYSLOG)      || exec('tab_zal','stanprac')      || _e ?};
 _p_ref:={? var_pres('_a')<>type_of(null())      || return(_tab)                    || _a ?};
    _nb:={? var_pres('_b')<>type_of(0)           || 0                               || _b ?};
   _slo:={? var_pres('_c')<>type_of('') | |_c='' || 'NIEZNANY'                      || _c ?};
   _kod:={? var_pres('_d')<>type_of('') | |_d='' || 'NIEZNANY'                      || _d ?};
_poziom:={? var_pres('_f')<>type_of(0)  | _f<0   || _f:=1                           || _f ?};

:: wypelniamy tabele
exec('stp_nad','stp',_p_ref,_slo,_kod,'P',_tab,_nb,_poziom);
_tab


\pwo_nad
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja zwraca pozycje nadrzedne dla pozycji w organizacji przekazanej parametrem
::   WE: _a - [REFERENCE] - wskazanie na pozycje w organizacji
::       _b - [STRING] - symbol kodu zaleznosci sluzbowych (typ zalezniosci)
::   WY:      [TABLE] - tabela z pozycjami podrzednymi
::            UWAGA!!! - jezeli przekazane parametry beda bledne, to zostanie zwrocona pusta tabela
::----------------------------------------------------------------------------------------------------------------------
:: tworzymy tabele zaleznosci pwo
  _tab:={? var_pres('_e')<>type_of(SYSLOG)      || exec('tab_zal_pwo','stp') || _e ?};
_p_ref:={? var_pres('_a')<>type_of(null())      || return(_tab)              || _a ?};
   _nb:={? var_pres('_b')<>type_of(0)           || 0                         || _b ?};
  _slo:={? var_pres('_c')<>type_of('') | |_c='' || 'NIEZNANY'                || _c ?};
  _kod:={? var_pres('_d')<>type_of('') | |_d='' || 'NIEZNANY'                || _d ?};
   _nb:={? var_pres('_f')<>type_of(0) | f<0     || 1                         || _f ?};
:: wypelniamy tabele
exec('stp_nad','stp',_p_ref,_slo,_kod,'O',_tab,_nb);
_tab


\showPracPodNad
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Wyswietla okienko z podwladnymi pracownika
::   WE: _a - [REFERENCE] - wskazanie na STP (ważne pole P - pracownik)
::       _b - [STRING]    - wybrany typ zaleznosci
::       _c - [STRING]    - 0 - podrzedne, 1 - nadrzedne
::----------------------------------------------------------------------------------------------------------------------
_title:='';
STP.cntx_psh();
{? _c=0
|| {? STP.seek(_a)
   || _prac:=STP.P().OSOBA().NAZWISKO+' '+OSOBA.PIERWSZE+' ('+form(P.T)+')';
      _title:='Podwładni pracownika: %1'@[_prac];
      _tab:=exec('prac_pod','stp',STP.P,'TYPPOZ',_b)
   ?}
|? _c=1
|| {? STP.seek(_a)
   || _prac:=STP.P().OSOBA().NAZWISKO+' '+OSOBA.PIERWSZE+' ('+form(P.T)+')';
      _title:='Przełożeni pracownika: %1'@[_prac];
      _nb:=~FUN.ask('Czy uwzględniać nieobecnych pracowników?'@);
      _tab:=exec('prac_nad','stp',STP.P,_nb,'TYPPOZ',_b)
   ?}
?};

:: jezeli nie udalo sie utworzyc tabeli to utworz ja
{? var_pres('_tab')<0
|| _tab:=exec('tab_zal','stanprac')
?};
STP.cntx_pop();

_wer:=_tab.mk_sel(_title,'P',0,'prac_str_st_pod',,,,,'U');
_tab.win_fld(_wer,,'L',,,3);
_tab.win_fld(_wer,,'J',,,15);
_tab.win_fld(_wer,,'T',);
_tab.win_fld(_wer,,'NAZWISKO',,,20);
_tab.win_fld(_wer,,'IMIE',,,15);
_tab.win_fld(_wer,,'STN',,,20);
{? @.PAR_SKID.get(313)='T'
|| _tab.win_fld(_wer,,'POZWORG',,,10)
?};
_tab.win_fld(_wer,,'WYDZIAL',,,-15);
_tab.win_act(_wer,,'Kolejność');
_tab.win_sel(_wer);
_tab.select()


\showPozPodNad
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Wyswietla okienko z podrzednymi/nadrzednymi zapisami wskazanej pozycji w organizacji
::   WE: _a - [REFERENCE] - wskazanie na STP (ważne pole POZWORG - pozycja w organizacji)
::       _b - [STRING]    - wybrany typ zaleznosci
::       _c - [STRING]    - 0 - podrzedne, 1 - nadrzedne
::----------------------------------------------------------------------------------------------------------------------
_title:='';
{? _c=0
|| {? STP.seek(_a)
   || _title:='Podrzędne pozycje w organizacji dla pozycji: %1 - %2'@[STP.POZWORG().OPIS,STP.POZWORG().KOD];
      _tab:=exec('pwo_pod','stp',STP.POZWORG,_b)
   ?}
|? _c=1
|| {? STP.seek(_a)
   || _title:='Nadrzędne pozycje w organizacji dla pozycji: %1 - %2'@[STP.POZWORG().OPIS,STP.POZWORG().KOD];
      _tab:=exec('pwo_nad','stp',STP.POZWORG,_b)
   ?}
?};

:: jezeli nie udalo sie utworzyc tabeli to utworz ja
{? var_pres('_tab')<0
|| _tab:=exec('tab_zal_pwo','stp')
?};

_wer:=_tab.mk_sel(_title,'P',0,'pwo_str_st_pod_',,,,,'U');
_tab.win_fld(_wer,,'L',,,3);
_tab.win_fld(_wer,,'OPIS');
_tab.win_fld(_wer,,'KOD');
_tab.win_act(_wer,,'Kolejność');
_tab.win_sel(_wer);
_tab.select()


\tab_zal_pwo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Tworzy tabele zawierajaca informacje o podrzednych zapisach wskazanej pozycji w organizacji
::----------------------------------------------------------------------------------------------------------------------
tab_tmp(1,
   'L'      , 'INTEGER'                                  , 'Poziom'@,
   'POZWORG', 'INTEGER'                                  , 'Pozycja w organizacji'@,
   'POZ_SQL', 'STRING[16]'                               , 'Pozycja w organizacji (SQL REF)'@,
   'KOD'    , 'STRING['+$MS.fld_len('POZWORG','KOD')+']' , 'Kod'@,
   'OPIS'   , 'STRING['+$MS.fld_len('POZWORG','OPIS')+']', 'Opis'@,
   'ZRODLO' , 'STRING[30]'                               , 'Źródło pochodzenia'@,
   'PWO_NAD', 'INTEGER'                                  , 'Zapis nadrzedny'@
)


\add_pwo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Dodaje zapis do tabeli zaleznosci słuzbowych pozycji w organizacji
::   WE: _a - alias do tabeli tymczasowej
::       _b - ref pozycji
::       _c - poziom zaleznosci
::       _d - zrodlo pochodzenia
::       _e - nadrzedny
::   WY: 1 informacje zostaly dopisane do tabeli, 0 w przeciwnym wypadku
::----------------------------------------------------------------------------------------------------------------------
_a.blank();
_a.POZWORG:=_b;
{? _a.find_rec
|| return(0)
?};

POZWORG.cntx_psh();
POZWORG.clear();
_val:=null();
{? POZWORG.seek(_b)
|| _a.L:=_c;
   _a.POZWORG:=_b;
   _a.POZ_SQL:=$_b;
   _a.KOD:=POZWORG.KOD;
   _a.OPIS:=POZWORG.OPIS;
   _a.ZRODLO:={? var_pres('_d')=type_of('') || _d || '' ?};
   _a.PWO_NAD:={? var_pres('_e')=type_of(null) || _e ?};
   _val:=_a.add()
?};
POZWORG.cntx_pop;
_val


\stp_pod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja wypelniajaca tabele zapisow podrzednych
::   WE: _a - [REFERENCE]  - wskazanie na pracownika lub na pozycje w organizacji
::       _b - [STRING]     - symbol slownika kodow, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::       _c - [STRING]     - symbol kodu zaleznosci sluzbowych, jesli pominiety lub inny niz napis,
::                           to przyjety zostanie NIEZNANY
::       _d - [STRING]     - rodzaj zaleznosci ('P' - pracownik, 'O' - pozycja w rganizacji)
::       _e - [TABLE]      - tabela z pracownikami podwladnymi
::       _f - path
::   WY:      [TABLE]      - tabela z pracownikami podwladnymi
::----------------------------------------------------------------------------------------------------------------------
:: sprawdzamy parametry wywolania
    _ref:={? var_pres('_a')<>type_of(null())      || return(0)  || _a ?};
    _slo:={? var_pres('_b')<>type_of('') | |_b='' || 'NIEZNANY' || _b ?};
    _kod:={? var_pres('_c')<>type_of('') | |_c='' || 'NIEZNANY' || _c ?};
 _rodzaj:={? var_pres('_d')<>type_of('')          || return(0)  || _d ?};
    _tab:={? var_pres('_e')<>type_of(SYSLOG)      || return(0)  || _e ?};
   _path:={? var_pres('_f')<>type_of('') | |_f='' || 'B'        || _f ?};

:: ustalenie maksymalnego poziomu zaleznosci
_max_poz:=#exec('get_par','#parametr',235,2);

:: ustalamy wskazanie na typ zaleznosci (SLO_KOD.ref)
_slo_kod:=exec('kod','ext_slo',_slo,_kod);
{? _slo_kod=null() || return(_tab) ?};

:: tworzymy obiekt pomocniczy
_obj:=obj_new('add','R','TYP');
_obj.R:=_rodzaj;
_obj.TYP:=_slo_kod;

:: jezeli parametr 232 ustawiony na 'N' to pobieraj tylko zatrudnionych
_zatr:=exec('get_par','#parametr',232,2)='N';

:: metoda do rekurencynego dodawania pozycji podrzędnych
_obj.add:="
   _tab:=_a;
   _stp:=_b;
   _nad:=_c;
   _opis:=_d;
   _poziom:=_e;
   _max_poz:=_f;
   _zatr:=_g;
   _path:=_h;
   _slo:=_i;
   _kod:=_j;
   {? (_max_poz=0 | _poziom<=_max_poz)
   || STP.cntx_psh();
      STP.index('STP_P');
      STP.prefix(exec('ref_firma','ustawienia'),.R,.TYP,#_stp);
      {? STP.first()
      || {!
         |?
            STP.cntx_psh();
            {? .R='P'
            || {? _zatr & STP.P().ZA='N' & (_slo='TYPPOZ' & _kod='PLANCZP')
               || A_OKRP.cntx_psh();
                  A_OKRP.use('x_okrpi');
                  A_OKRP.index(A_OKRP.ndx_tmp(,1,'OKR','S',,'P',,,'OD',,));
                  A_OKRP.prefix('O',STP.P);
                  {? A_OKRP.find_le(STP.P().DZ)
                  || _zatr:=0
                  ?};
                  A_OKRP.ndx_drop();
                  A_OKRP.cntx_pop()
               ?};
               {? _zatr=0 | (_zatr & STP.P().ZA='T')
               || {? exec('add_zal','stanprac',_tab,STP.P,STP.P().WYDZIAL().SYMBOL,_poziom,_opis,_nad,,,_path)
                  || .add(_tab,STP.ref,STP.P,_opis,_poziom+1,_max_poz,_zatr,_path,_slo,_kod)
                  ?}
               ?}
            |? .R='O'
            ||
               exec('add_pwo','stp',_tab,STP.POZWORG,_poziom,_opis,_nad);
               .add(_tab,STP.ref,STP.POZWORG,_opis,_poziom+1,_max_poz,_zatr,_path)
            ?};
            STP.cntx_pop();
            STP.next()
         !}
      ?};
      STP.cntx_pop()
   ?}
";

P.cntx_psh();
POZWORG.cntx_psh();
STP.cntx_psh();
{? _rodzaj='P'
||
:: tworzymy index tymczasowy do wyszukania pracownika
   _ndx:=STP.ndx_tmp('',1,'R',,,'TYP',,,'P',,);
   STP.index(_ndx);
   STP.prefix(_rodzaj,_slo_kod,_ref);
   {? STP.first()
   ||
::    pracownik zostal znaleziony wiec dodajemy jego podwladnych
      {!
      |? _opis:=exec('opis_bp','stanprac');
         _obj.add(_tab,STP.ref,STP.P,_opis,1,_max_poz,_zatr,_path,_slo,_kod);
         STP.next()
      !}
   ?};
   STP.ndx_drop(_ndx);
   exec('par250','stp',_slo,_kod,_tab)

|? _rodzaj='O'
||
:: tworzymy index tymczasowy do wyszukania pozycji w organizacji
   _ndx:=STP.ndx_tmp('',1,'P','FIRMA',,'R',,,'TYP',,,'POZWORG',,);
   STP.index(_ndx);
   STP.prefix(exec('ref_firma','ustawienia'),_rodzaj,_slo_kod,_ref);
   {? STP.first()
   ||
::    pozycja zostala znaleziona wiec dodajemy pozycje podrzedne
      {!
      |? _opis:=exec('opis_pwo','stanprac');
         _obj.add(_tab,STP.ref,STP.POZWORG,_opis,1,_max_poz,_zatr);
         STP.next()
      !}
   ?};
   STP.ndx_drop(_ndx)
?};
STP.cntx_pop();
POZWORG.cntx_pop();
P.cntx_pop();

::zwracamy tablice z podwladnymi
_tab


\par250
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Obsluga parametru 250
::   WE: _a - [REFERENCE]  - wskazanie na osobe
::       _b - [STRING]     - symbol slownika kodow, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::       _c - [STRING]     - symbol kodu zaleznosci sluzbowych, jesli pominiety lub inny niz napis,
::                           to przyjety zostanie NIEZNANY
::       _d - [TABLE]      - tabela z pracownikami podwladnymi
::       _e - [INTEGER]    - max poziom zaleznosci (parametr 235)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=~~;
:: sprawdzamy parametry wywolania
    _slo:={? var_pres('_a')<>type_of('') | |_a='' || 'NIEZNANY'                      || _a ?};
    _kod:={? var_pres('_b')<>type_of('') | |_b='' || 'NIEZNANY'                      || _b ?};
    _tab:={? var_pres('_c')<>type_of(SYSLOG)      || return(_result)                 || _c ?};

:  Dla parametru 250='N' usunięcie pracownika zastępowanego dla typu TYPPOZ:DOSTINF
_par250:=exec('get_par','#parametr',250,2)='N';

{? (_slo='TYPPOZ') & (_kod='DOSTINF')
||
   _tab.cntx_psh();
   _ndx_zas:=_tab.ndx_tmp(,,'P_ZAS',,);
   _tab.index(_ndx_zas);
   _tab.prefix('T');
   {? _tab.first()
   || {!
      |? {? _par250 & _tab.PATH='Z'
         || _del:=_tab.del(,1);_del=2
         || {? _tab.L=0
            || _tab.L:=1;
               _tab.put()
            ?};
            _tab.next()
         ?}
      !}
   ?};
   _tab.cntx_pop();
   _tab.ndx_drop(_ndx_zas)
?};
_result


\stp_nad
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja wypelniajaca tabele zapisow nadrzednych
::   WE: _a - [REFERENCE]  - wskazanie na pracownika lub na pozycje w organizacji
::       _b - [STRING]     - symbol kodu zaleznosci sluzbowych (typ zalezniosci)
::       _c - [STRING]     - symbol kodu zaleznosci sluzbowych (typ zalezniosci)
::       _d - [STRING]     - rodzaj zaleznosci ('P' - pracownik, 'O' - pozycja w organizacji)
::       _e - [TABLE]      - tabela do wypelnienia danymi
::       _f - [INTEGER]    - 1 - nie wybiera nieobecnych pracownikow, 0 - wybiera wszystkich
::       _g - [INTEGER]    - poziom zaleznosci
::   WY:      [TABLE]      - tabela z pracownikami przelozonymi
::----------------------------------------------------------------------------------------------------------------------
:: sprawdzamy parametry wywolania
   _ref:={? var_pres('_a')<>type_of(null)        || return(0)  || _a ?};
   _slo:={? var_pres('_b')<>type_of('') | |_b='' || 'NIEZNANY' || _b ?};
   _kod:={? var_pres('_c')<>type_of('') | |_c='' || 'NIEZNANY' || _c ?};
_rodzaj:={? var_pres('_d')<>type_of('')          || return(0)  || _d ?};
   _tab:={? var_pres('_e')<>type_of(SYSLOG)      || return(0)  || _e ?};
 _nieob:={? var_pres('_f')<>type_of(0)           || 0          || _f ?};
_poziom:={? var_pres('_g')<>type_of(0)  | _g<0   || _g:=1      || _g ?};

:: ustalenie maksymalnego poziomu zaleznosci
_max_poz:=#exec('get_par','#parametr',235,2);

:: ustalamy wskazanie na typ zaleznosci (SLO_KOD.ref)
_slo_kod:=exec('kod','ext_slo',_slo,_kod);
{? _slo_kod=null() || return(_tab) ?};

:: tworzymy obiekt pomocniczy
_obj:=obj_new('add','R','TYP','slo','kod','Ref');
_obj.R:=_rodzaj;
_obj.TYP:=_slo_kod;
_obj.slo:=_slo;
_obj.kod:=_kod;
:: zapamietujemy ref-a, dla ktorego jest wywolywana metoda
_obj.Ref:=_ref;
:: metoda do dodawania rekurencynego pozycji podrzędnych
_obj.add:="
   _tab:=_a;
   _stp:=_b;
   _nad:=_c;
   _opis:=_d;
   _poziom:=_e;
   _max_poz:=_f;
   _nieob:=_g;
   STP.prefix();
   {? (_max_poz=0 | _poziom<=_max_poz) & STP.seek(_stp,)
   ||
      {? .R='P'
      ||
         _skl:=STP.P().WYDZIAL;
         _stn:=STP.P().ST;
         _pozworg:=STP.P().POZWORG;
         _wydz:=STP.P().WYDZIAL().SYMBOL;
::       kto zastępuje STP.P na stałe lub okresowo
::       badamy w dół aż do bieżącego pracownika
         _zas:=exec('prac_zas_trn','stanprac',STP.P,,.slo,.kod,'N',.Ref);
::       badamy w dół tylko jeden poziom
         _zas_0:=exec('prac_zas_trn','stanprac',STP.P,,.slo,.kod,'N',null());
::       kto zastępuje STP.P na czas nieobecności
::       badamy w dół aż do bieżącego pracownika
         _zas_N:=exec('prac_zas_trn','stanprac',STP.P,,.slo,.kod,'T',.Ref);
::       badamy w dół tylko jeden poziom
         _zas_N_0:=exec('prac_zas_trn','stanprac',STP.P,,.slo,.kod,'T',null());
::       dodajemy przelozonych wynikajacych z zastepstw
         {? (_zas<>.Ref & _zas_N<>.Ref) & (_zas_0<>.Ref & _zas_N_0<>.Ref)
         || exec('prac_nad_zal','stp',STP.P,_nieob,.slo,.kod,_tab,_poziom)
         ?};
::       wyszukanie pracownika pelniacego dane obowiazki na stale
         {? (_ref:=exec('prac_pob_trn','stanprac',_skl,_stn,,.slo,.kod,'N',_pozworg))<>null
         || {? _ref<>.Ref
            || exec('add_zal','stanprac',_tab,_ref,_wydz,_poziom,exec('opis_po','stanprac'),,1,,'O')
            ?}
         |? (STP.STP<>0 & (_zas<>.Ref & _zas_N<>.Ref) & (_zas_0<>.Ref & _zas_N_0<>.Ref) | STP.STP=0) &
            (_nieob=0 | (_nieob & ~exec('czy_jest','nieobecnosc',STP.P)))
::       tu idzie normalne wyszukanie kierownika
         || exec('add_zal','stanprac',_tab,STP.P,_wydz,_poziom,_opis,_nad,1)
         |? (_ref:=exec('prac_pob_trn','stanprac',_skl,_stn,,.slo,.kod,,_pozworg))<>null
::       brak pracownika stale pelniacego obowiazki i pracownika zatrudnionego,
::       ale jest informacja o pelnionych obowiazkach z ustawiona flaga NB
         || {? _ref<>.Ref
            || exec('add_zal','stanprac',_tab,_ref,_wydz,_poziom,exec('opis_pon','stanprac'),,1,,'O')
            ?}
         ?};
         .add(_tab,STP.STP,null,_opis,_poziom+1,_max_poz,_nieob)
      |? .R='O'
      ||
         exec('add_pwo','stp',_tab,STP.POZWORG,_poziom,_opis,_nad);
         .add(_tab,STP.STP,null,_opis,_poziom+1,_max_poz)
      ?}
   ?}
";

P.cntx_psh();
POZWORG.cntx_psh();
STP.cntx_psh();
{? _rodzaj='P'
||
:: tworzymy index tymczasowy do wyszukania pracownika
   _ndx:=STP.ndx_tmp('',1,'R',,,'TYP',,,'P',,);
   STP.index(_ndx);
   STP.prefix(_rodzaj,_slo_kod,_ref);
   {? STP.first()
   || {!
      |?
::       pracownik zostal znaleziony wiec dodajemy jego przelozonych
         _opis:=exec('opis_bp','stanprac');
::       wynikajacych z bezposredniego przypisania jako podwladnego w tabeli P_PZ
         exec('prac_nad_zal','stanprac',_ref,_nieob,_slo,_kod,_tab,_poziom);
::       wynikajacych z obowiazkow P_PO
         exec('prac_nad_ob','stp',_ref,_nieob,_slo,_kod,_tab,_poziom);
::       wynikajacych z pozostalych zaleznosci
         STP.cntx_psh();
::       dodawaj kierownikow na najwyzszym poziomie drzewa
         _kier:=STP.P().ST().K;
         {? STP.STP=0 & _kier='T'
         || _zas:=exec('prac_zas_trn','stanprac',STP.P,,_obj.slo,_obj.kod,'N');
            _zas_N:=exec('prac_zas_trn','stanprac',STP.P,,_obj.slo,_obj.kod,'T');
            _prac:=null();
            {? _zas
            || _prac:=_zas;
               _opis:=exec('opis_za','stanprac')
            |? _zas_N & exec('czy_jest','nieobecnosc',STP.P)
            || _prac:=_zas_N;
               _opis:=exec('opis_zan','stanprac')
            ?};
            {? ~(_prac & P.seek(_prac))
            || _prac:=STP.P
            ?};
            _wydz:=STP.P().WYDZIAL().SYMBOL;
            exec('add_zal','stanprac',_tab,_prac,_wydz,_poziom,_opis,,1)
         || _obj.add(_tab,STP.STP,null,_opis,_poziom,_max_poz,_nieob)
         ?};
         STP.cntx_pop();
         STP.next()
      !}
   ?};
   STP.ndx_drop(_ndx)
|? _rodzaj='O'
||
:: tworzymy index tymczasowy do wyszukania pozycji w organizacji
   _ndx:=STP.ndx_tmp('',1,'P','FIRMA',,'R',,,'TYP',,,'POZWORG',,);
   STP.index(_ndx);
   STP.prefix(exec('ref_firma','ustawienia'),_rodzaj,_slo_kod,_ref);
   {? STP.first()
   ||
::    pozycja zostala znaleziona wiec dodajemy pozycje nadrzedne
      _opis:=exec('opis_pwo','stanprac');
      _obj.add(_tab,STP.STP,null,_opis,1,_max_poz)
   ?};
   STP.ndx_drop(_ndx)
?};
STP.cntx_pop();
POZWORG.cntx_pop();
P.cntx_pop();

::zwracamy tablice z przelozonymi
_tab


\prac_nad_ob
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS & TMR [12.41]
:: OPIS: Dodaje przelozonych pracownika wynikajacych z obowiazkow
::   WE: _a - ref pracownika
::       _b - 1 - nie wybiera nieobecnych pracownikow, 0 - wybiera wszystkich
::       _c - symbol slownika kodow
::       _d - symbol kodu zaleznosci sluzbowych
::       _e - alias do bufora danych
::       _f - poziom zaleznosci
::   WY: alias do tabeli zawierajacej informacje o zaleznosciach
::UWAGA: poprawnosc argumentow wywolania nie jest weryfikowana
::----------------------------------------------------------------------------------------------------------------------
_done:=0;
{? @.PAR_SKID.get(232)='N'
|| return()
?};

_par313:=@.PAR_SKID.get(313)='T';
P.cntx_psh;

UD_DEF.cntx_psh;
UD_DEF.index('PODTEC');
UD_DEF.prefix(exec('szukaj_ud_sch','schemat','PODZORG','STR_STAN'));

STZ.cntx_psh;
{? _par313
|| STZ.index('STNPOZ')
|| STZ.index('STN')
?};

STRST_P.cntx_psh();
STRST_P.index('P');
STRST_P.prefix(_a);
_loop:=STRST_P.first;
{!
|? _loop & UD_DEF.find_key(STRST_P.UD_SKL)
|!
   {? _par313
   || STZ.prefix(STRST_P.P().ST,STRST_P.P().POZWORG)
   || STZ.prefix(exec('ref_firma','ustawienia'),STRST_P.P().ST)
   ?};
   {!
   |? _loop:=STZ.first;
      {!
      |? _loop
      |! STZ.cntx_psh;
         STZ.prefix;
         {!
         |? {? STZ.seek(STZ.STZ,)
            || _brak_p:=1;
               {? (_ref:=exec('prac_pob_trn','stanprac',UD_DEF.UD_SKL,STZ.STN,,_c,_d,'N',STZ.POZWORG))<>null
:                 znaleziono pracownika pelniacego dane obowiazki na stale
               || {? exec('add_zal','stanprac',_e,_ref,UD_DEF.UD_SKL().SYMBOL,_f,exec('opis_po','stanprac'),,,,'O')
                  || _brak_p:=0;
                     _done:=1
                  ?}
               ?};
               {? _brak_p & (_ref:=exec('prac_pob_trn','stanprac',UD_DEF.UD_SKL,STZ.STN,,_c,_d,,STZ.POZWORG))<>null
:                 brak pracownika stale pelniacego obowiazki i pracownika zatrudnionego,
:                 ale jest informacja o pelnionych obowiazkach z ustawiona flaga NB
               || {? exec('add_zal','stanprac',_e,_ref,UD_DEF.UD_SKL().SYMBOL,_f,exec('opis_pon','stanprac'),,,,'O')
                  || _done:=1
                  ?}
               ?};
::             zawsze zwracamy 1 aby w petli isc w gore drzewka zaleznosci sluzbowych
               1

            |? STZ.STZ=0 & STZ.STN=STRST_P.P().ST & STZ.STN().K<>'N'
            || _ref:=P.ref;
               _opis:=exec('opis_stn','stanprac');
               _jest_prac:=exec('jest_prac','obiegi',,,1);
               _path:='O';
               {? (_ref_o:=exec('prac_pob_trn','stanprac',UD_DEF.UD_SKL,STZ.STN,,_c,_d,'N'))<>null
:                 znaleziono pracownika pelniacego dane obowiazki na stale
               || _opis:=exec('opis_po','stanprac');
                  _ref:=_ref_o;
                  _path:='O'
               |? _b & _jest_prac & exec('czy_jest','nieobecnosc',P.ref)
               || _opis:=exec('opis_zan','stanprac');
                  {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'T'))=null
                  || _opis:=exec('opis_pon','stanprac');
                     _ref:=exec('prac_pob_trn','stanprac',UD_DEF.UD_SKL,P.ST,,_c,_d,'T',P.POZWORG);
                     _path:='O'
                  ?}
               |? ~_jest_prac
               || _ref:=null
               ?};
               {? _ref<>null
               || exec('add_zal','stanprac',_e,_ref,UD_DEF.UD_SKL().SYMBOL,_f,_opis,,,,_path)
               ?};
               0
            ?}
         !};
         STZ.cntx_pop;
         _loop:=(~_done & STZ.next)
      !};
      ~_done & UD_DEF.seek(UD_DEF.UD_DEF,)
   !};
   _loop:=(~_done & STRST_P.next)
!};

STRST_P.cntx_pop();
UD_DEF.cntx_pop;
STZ.cntx_pop;
P.cntx_pop()


\oKopSelect
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Wyswietla okno z kontrolka do kopiowania typow zaleznosci
::   WE: _a - [STRING] -  rodzaj zaleznosci ('P' lub 'O')
::----------------------------------------------------------------------------------------------------------------------
EDIT_VAR.win_edit('STZ_KOP');
{? EDIT_VAR.edit("
      _chk:=__CHK.record(EDIT_VAR,,'KOD_Z','KOD_D');
      {? _chk<>''
      || return(_chk)
      |? EDIT_VAR.KOD_Z=EDIT_VAR.KOD_D
      || FUN.info('Typ docelowy nie może być taki sam jak typ źródłowy.'@);
         'KOD_D'
      || 1
      ?}
   ")
|| _res:=exec('kopiujTyp','stp',oStp.R,EDIT_VAR.KOD_Z,EDIT_VAR.KOD_D);
   {? _res>0
   || FUN.info('Skopiowano wybrany typ zależności służbowych.'@)
   |? _res=-2
   || ~~
   || FUN.emsg('Nie udało się skopiować schematu zalezności.'@)
   ?};
   ~~
?};
~~


\kopiujTyp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Kopiuje schemat zaleznosci pomiedzy wskazanymi typami
::   WE: _a - [STRING] - rodzaj zaleznosci ('P' lub 'O')
::       _a - [STRING] - typ zrodlowy
::       _b - [STRING] - typ docelowy
::   WY: 0 (nie skopiowano i transakcja wycofana) lub 1 (skopiowano i jest ok)
::----------------------------------------------------------------------------------------------------------------------
_rodzaj:={? var_pres('_a')=type_of('_a') || _a || return(0) ?};
_typSrc:={? var_pres('_b')=type_of('_b') || _b || return(0) ?};
_typDst:={? var_pres('_c')=type_of('_c') || _c || return(0) ?};

:: sprawdzam czy wybrano rozne typy, jezeli nie to koniec
{? _typSrc=_typDst || return(-1) ?};

_chkDst:=exec('chkTypDstSize','stp');
_chkSrc:=exec('chkTypSrcSize','stp');
_msg:='';
_msg+={? +_chkSrc.msg || _chkSrc.msg || '' ?};
_msg+={? (+_chkDst.msg) & (+_msg) || '\n\n' || '' ?};
_msg+={? +_chkDst.msg || _chkDst.msg || '' ?};
{? +_msg
|| {? ~FUN.ask(_msg+'\n\n'+'Czy kontynuaować?'@)
   || return(-2)
   ?}
?};

P.cntx_psh();
SLO_KOD.cntx_psh();
POZWORG.cntx_psh();
STP.cntx_psh();
P.clear();
SLO_KOD.clear();
POZWORG.clear();

do();

_obj:=obj_new('add','find','rodzaj','slo_src','slo_dst','ok');
_obj.ok:=1;
_obj.rodzaj:=_rodzaj;

:: formula do wyszukiwania rekordu w STP z typem zrodlowym
_obj.find:="
   _parentS:=_a;
   _parentD:=_b;
   STP.index('STP_P');
   STP.prefix(exec('ref_firma','ustawienia'),.rodzaj,.slo_src,_parentS);
   {? STP.first()
   || {!
      |? STP.cntx_psh();
         .add(_parentD,STP.P,STP.POZWORG,STP.ref());
         STP.cntx_pop();
         STP.next()
      !}
   ?}
";

:: formula do dodawania rekordu w STP z typem docelowym
_obj.add:="
   _parentS:=_d;
   STP.prefix();
   STP.blank(1);
   STP.STP:=_a;
   STP.P:=_b;
   STP.POZWORG:=_c;
   STP.R:=.rodzaj;
   STP.TYP:=.slo_dst;
   _ref:=null();
   {? STP.add(1)
   || .find(_parentS,STP.ref())
   ?}
";

:: wyszukanie typow
_slo_src:=exec('kod','ext_slo','TYPPOZ',_typSrc);
_slo_dst:=exec('kod','ext_slo','TYPPOZ',_typDst);

{? _slo_src<>null() & _slo_dst<>null()
||
   _obj.slo_src:=_slo_src;
   _obj.slo_dst:=_slo_dst;
:: usuniecie zapisow z typem docelowym
   STP.prefix(_rodzaj,_slo_dst);
   {? STP.first() || {!|? exec('del_tree_branch','#tree',STP,'STP',,STP.ref()); STP.del() !} ?};

:: no to kopiujemy
   _obj.find(null(),null())
?};

:: jezeli byly jakis bledy to wycofaj transakcje
{? ~_obj.ok || undo() ?};
end();

STP.cntx_pop();
SLO_KOD.cntx_pop();
POZWORG.cntx_pop();
P.cntx_pop();
_obj.ok


\chkTypSrcSize
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Formula sprawdzajaca rozmiar schematu zrodlowego
::   WY: obiekt z informacjami o schemacie
::----------------------------------------------------------------------------------------------------------------------
_res:=obj_new('size','msg');
_typ_src:=exec('get_value','#desktop','','stp_kop_typ','j4j4eej4mc80dcjfnh8j1me2m2j3');
_slo_src:=exec('kod','ext_slo','TYPPOZ',_typ_src);
STP.cntx_psh();
STP.index('STP_P');
STP.prefix(exec('ref_firma','ustawienia'),oStp.R,_slo_src);
_res.size:=STP.size();
_res.msg:='';
{? _res.size=0
|| _res.msg:='Wybrany typ źródłowy, nie ma zdefiniowanego schematu zależności służbowych.'@
?};
STP.cntx_pop();
_res


\chkTypDstSize
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Formula sprawdzajaca rozmiar schematu docelowego
::   WY: obiekt z informacjami o schemacie
::----------------------------------------------------------------------------------------------------------------------
_res:=obj_new('size','msg');
_typ_dst:=exec('get_value','#desktop','','stp_kop_typ','1jc2997236d83ai06meb45k825amn');
_slo_dst:=exec('kod','ext_slo','TYPPOZ',_typ_dst);
STP.cntx_psh();
STP.index('STP_P');
STP.prefix(exec('ref_firma','ustawienia'),oStp.R,_slo_dst);
_res.size:=STP.size();
_res.msg:='';
{? _res.size>0
|| _res.msg:='Typ docelowy posiada zdefiniowany schemat zależności służbowych.'@+'\n'+
             'Kopiowanie wybranego typu nadpisze istniejące dane w typie docelowym.'@
?};
STP.cntx_pop();
_res


\prac_pod_ob
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja dodaje do przekazanej tabeli pracownikow podwladnych na podstawie informacji o pelnionych obowiazkach
::   WE: _a - [REFERENCE]  - wskazanie na pracownika
::       _b - [STRING]     - symbol slownika kodow, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::       _c - [STRING]     - symbol kodu zaleznosci sluzbowych, jesli pominiety lub inny niz napis,
::                           to przyjety zostanie NIEZNANY
::       _d - [TABLE]      - tabela z pracownikami podwladnymi
::----------------------------------------------------------------------------------------------------------------------
 _p_ref:={? var_pres('_a')<>type_of(null())      || return(0)  || _a ?};
   _slo:={? var_pres('_b')<>type_of('') | |_b='' || 'NIEZNANY' || _b ?};
   _kod:={? var_pres('_c')<>type_of('') | |_c='' || 'NIEZNANY' || _c ?};
   _tab:={? var_pres('_d')<>type_of(SYSLOG)      || return(0)  || _d ?};

_par232:=@.PAR_SKID.get(232)='T';
_par313:=@.PAR_SKID.get(313)='T';

_LWYD:=exec('lwyd_buff','stanprac');
_LSTN:=exec('lstn_buff','stanprac');

{? _par313
|| _LSTN.index(_LSTN.ndx_tmp(,,'STN',,,'POZWORG',,))
|| _LSTN.index(_LSTN.ndx_tmp(,,'STN',,))
?};

_lstwyd:=exec('lwyd_form','stanprac');
_lststn:=exec('lstn_form','stanprac');
_erase:="_a.clear(); {? _a.first() || {! |? _a.del() !} ?}";
_sch:=exec('szukaj_ud_sch','schemat','PODZORG','STR_STAN');
_opis:=exec('opis_po','stanprac');

P.cntx_psh();
SLO_KOD.cntx_psh();
P_PO.cntx_psh();
P_PO.index('P_PO');
P_PO.prefix(_p_ref);
_loop:=P_PO.first();
{!
|? _loop
|! {? P_PO.TYP().KOD=_kod & SLO_KOD.SLO_TYP().SYMBOL=_slo
      &
      {? P_PO.CO='T' || P_PO.OD<=date & date<=P_PO.DO || 1 ?}
   ||
      {? _par232
      || _erase(_LWYD);
         _erase(_LSTN);

         {? _par313
         || __NDSTZ:=STZ.ndx_tmp(,,'STZ',,,'STN','ST',,'POZWORG',,)
         || __NDSTZ:=STZ.ndx_tmp(,,'FIRMA',,,'STZ',,,'STN','ST',)
         ?};

         {? P_PO.NB='N'
         || _lststn(_LSTN,P_PO.ST,P_PO.POZWORG,_lststn,0,1);
            _lstwyd(_LWYD,_sch,P_PO.WYDZIAL,_lstwyd,0,1)
         || P.cntx_psh();
            P.index('PRACOWST');
            P.prefix(P_PO.WYDZIAL,P_PO.ST,'T');
            {? P.first()
            || {!
               |? {? exec('czy_jest','nieobecnosc',P.ref())
                  || _lststn(_LSTN,P_PO.ST,P_PO.POZWORG,_lststn,0,1);
                     _lstwyd(_LWYD,_sch,P_PO.WYDZIAL,_lstwyd,0,1)
                  ?};
                  P.next()
               !}
            ?};
            P.cntx_pop()
         ?};
         STZ.ndx_drop(&__NDSTZ);

         STRST_P.cntx_psh();
         P.cntx_psh();
         _loop:=_LWYD.first();
         {!
         |? _loop
         |! STRST_P.index('UD_SKL_S');
            STRST_P.prefix(_LWYD.WYD);
            _loop:=STRST_P.first();
            {!
            |? _loop
            |! STRST_P.cntx_psh;
               {? {? _par313
                  || _LSTN.find_key(#STRST_P.P().ST, #STRST_P.P().POZWORG)
                  || _LSTN.find_key(#STRST_P.P().ST)
                  ?}
               || {? exec('add_zal','stanprac',_tab,P.ref,P.WYDZIAL().SYMBOL,1,_opis,_p_ref,,,'O')
                  || exec('prac_pod','stp',P.ref,_slo,_kod,_tab,'O')
                  ?}
               ?};
               STRST_P.cntx_pop();
               _loop:=STRST_P.next()
            !};
            _loop:=_LWYD.next()
         !};
         P.cntx_pop();
         STRST_P.cntx_pop()
      ||
::       struktura zaleznosci wg pozycji w organizacji
         {? _par313
         || P.index('PRACOWSP');
            P.prefix(P_PO.WYDZIAL,P_PO.ST,P_PO.POZWORG,'T')
         || P.index('PRACOWST');
            P.prefix(P_PO.WYDZIAL,P_PO.ST,'T')
         ?};
         {? P.first()
         || {!
            |? _nb:=exec('czy_jest','nieobecnosc',P.ref());
               _ok:={? P_PO.NB='T' || _nb || 1 ?};
               {? _ok || exec('prac_pod','stp',P.ref(),_slo,_kod,_tab,'O') ?};
               P.next()
            !}
         ?}
      ?}
   ?};
   _loop:=P_PO.next()
!};
P_PO.cntx_pop();
SLO_KOD.cntx_pop();
P.cntx_pop()


\prac_pod_zal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS & TMR [12.30]
:: OPIS: Zwraca w postaci tabeli liste pracownikow podleglych osobie
::   WE: _a - ref osoby
::       _b - symbol slownika kodow (zawsze przyjmowany jest 'TYPPOZ')
::       _c - symbol kodu zaleznosci sluzbowych
::       _d - alias do bufora danych
::   WY: alias do tabeli zawierajacej informacje o zaleznosciach
::UWAGA: poprawnosc argumentow wywolania nie jest weryfikowana
::----------------------------------------------------------------------------------------------------------------------
_typ:=exec('kod','ext_slo',_b,_c);
{? _typ=null || return(_d) ?};

_por:=exec('lic','#b_domain','POR');

P.cntx_psh;
P.index('PRACOSOW');
P.prefix(exec('ref_firma','ustawienia'),_a);
{? P.first
|| P_PZ.cntx_psh;
   {!
   |? {? P.ZA='T'
      || _nad:=P.ref;
::       --------------------------------------
::       przegladanie podwladnych zastepowanego
         P_PZ.index('REVERT');
::       zaleznosci czasowe
         P_PZ.prefix('Z',_typ,P.ref,'T');
         {? P_PZ.first
         || P.cntx_psh;
            {!
            |? P_PZ.P();
               {? P_PZ.OD<=date & {? ~_por || date<=P_PZ.DO || 1 ?}
               || {? exec('add_zal','stanprac',_d,P.ref,P.WYDZIAL().SYMBOL,1,exec('opis_bp','stanprac'),_nad,,'T','Z')
                  || exec('prac_pod','stp',P.ref(),_b,_c,_d,'Z')
                  ?}
               ?};
               P_PZ.next
            !};
            P.cntx_pop
         ?};
::       zaleznosci domyslne
         P_PZ.prefix('Z',_typ,P.ref,'N');
         {? P_PZ.first
         || P.cntx_psh;
            {!
            |? P_PZ.P();
               {? exec('add_zal','stanprac',_d,P.ref,P.WYDZIAL().SYMBOL,1,exec('opis_bp','stanprac'),_nad,,'T','Z')
               || exec('prac_pod','stp',P.ref(),_b,_c,_d,'Z')
               ?};
               P_PZ.next
            !};
            P.cntx_pop
         ?};
::       -------------------------------------
::       przegladanie przypisanych podwladnych
         P_PZ.index('UNIQUE');
::       zaleznosci czasowe
         P_PZ.prefix('P',_typ,P.ref,'T');
         {? P_PZ.first
         || P.cntx_psh;
            {!
            |? P_PZ.PZ();
               {? P_PZ.OD<=date & {? ~_por || date<=P_PZ.DO || 1 ?}
               || {? exec('add_zal','stanprac',_d,P.ref,P.WYDZIAL().SYMBOL,1,exec('opis_bp','stanprac'),_nad,,,'P')
                  || exec('prac_pod','stp',P.ref(),_b,_c,_d,'P')
                  ?}
               ?};
               P_PZ.next
            !};
            P.cntx_pop
         ?};
::       zaleznosci domyslne
         P_PZ.prefix('P',_typ,P.ref,'N');
         {? P_PZ.first
         || P.cntx_psh;
            {!
            |? P_PZ.PZ();
               {? exec('add_zal','stanprac',_d,P.ref,P.WYDZIAL().SYMBOL,1,exec('opis_bp','stanprac'),_nad,,,'P')
               || exec('prac_pod','stp',P.ref(),_b,_c,_d,'P')
               ?};
               P_PZ.next
            !};
            P.cntx_pop
         ?}
      ?};
      P.next
   !};
   P_PZ.cntx_pop
?};
P.cntx_pop;
_d


\prac_nad_zal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS & TMR [12.30]
:: OPIS: Zwraca w postaci tabeli liste przelozonych pracownika.
::   WE: _a - ref pracownika
::       _b - 1 - nie wybiera nieobecnych pracownikow, 0 - wybiera wszystkich
::       _c - symbol slownika kodow
::       _d - symbol kodu zaleznosci sluzbowych
::       _e - alias do bufora danych
::       _f - poziom zaleznosci
::   WY: alias do tabeli zawierajacej informacje o zaleznosciach
::UWAGA: poprawnosc argumentow wywolania nie jest weryfikowana
::----------------------------------------------------------------------------------------------------------------------
_typ:=exec('kod','ext_slo',_c,_d);
{? _typ=null || return(_e) ?};
_por:=exec('lic','#b_domain','POR');
UD_SKL.cntx_psh();
P.cntx_psh();
P_PZ.cntx_psh();
P_PZ.index('UNIQUE');
:: zaleznosci czasowe
P_PZ.prefix('Z',_typ,_a,'T');
{? P_PZ.first()
|| {!
   |? P_PZ.P();
      {? P_PZ.OD<=date
      || {? {? ~_por || date<=P_PZ.DO || 1 ?}
         || {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'N'))<>null
            || _opis:=exec('opis_za','stanprac');
               {? exec('add_zal','stanprac',_e,_ref,P.WYDZIAL().SYMBOL,_f,_opis)
               || 0
               ?}
            |? _b & exec('czy_jest','nieobecnosc',P.ref)
            || _opis:=exec('opis_zan','stanprac');
               {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'T'))=null
               || _opis:=exec('opis_pon','stanprac');
                  _ref:=exec('prac_pob_trn','stanprac',P.WYDZIAL,P.ST,,_c,_d)
               ?};
               {? _ref<>null
               || exec('add_zal','stanprac',_e,_ref,P.WYDZIAL().SYMBOL,_f,_opis)
               || 0
               ?}
            || {? exec('add_zal','stanprac',_e,P.ref,P.WYDZIAL().SYMBOL,_f,exec('opis_bp','stanprac'))
               || 0
               ?}
            ?}
         || 1
         ?}
      ?} & P_PZ.next()
   !}
?};
:: zaleznosci domyslne
P_PZ.prefix('Z',_typ,_a,'N');
{? P_PZ.first()
|| {!
   |? P_PZ.P();
      {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'N'))<>null
      || _opis:=exec('opis_za','stanprac');
         {? exec('add_zal','stanprac',_e,_ref,P.WYDZIAL().SYMBOL,_f,_opis)
         || 0
         ?}
      |? _b & exec('czy_jest','nieobecnosc',P.ref)
      || _opis:=exec('opis_zan','stanprac');
         {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d))=null
         || _opis:=exec('opis_pon','stanprac');
            _ref:=exec('prac_pob_trn','stanprac',P.WYDZIAL,P.ST,,_c,_d)
         ?};
         {? _ref<>null & _ref<>_a
         || exec('add_zal','stanprac',_e,_ref,P.WYDZIAL().SYMBOL,_f,_opis)
         || 0
         ?}
      || {? exec('add_zal','stanprac',_e,P.ref,P.WYDZIAL().SYMBOL,_f,exec('opis_bp','stanprac'))
         || 0
         ?}
      ?} & P_PZ.next()
   !}
?};
P_PZ.cntx_pop();
P.cntx_pop();
UD_SKL.cntx_pop();
_e


:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
::
::  Obsluga aktualizacji tabeli STP
::
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\oWynik
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Zwraca tablicę nazwaną wykorzystywaną do obsługi wyniku przetwarzania zasilania tabeli STP - wykorzystywane w
::       alercie
::   WY: tablica nazwana z dwoma polami 'wynik' i 'opis'
::----------------------------------------------------------------------------------------------------------------------
_result:=obj_new('wynik','opis');
_result.wynik:=0;
_result.opis:='';
_result


\makeTabStp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Zasila tabele STP w celu szybszego wyszukiwania podwladnych
::   WE: [_a] - [INTEGER]    - aktualizacja (0 - dodaje informacje o koniecznosci aktualizacj tabeli STP;
::                             1 - jeżeli jest to konieczne; 2 - wymuszona aktualizacja)
::         _b - [INTEGER]    - czy wyswietlac komunikaty
::         _c - [STRING]     - Rodzaj
::         _d - [STRING]     - symbol slownika kodow, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::         _e - [STRING]     - symbol kodu zaleznosci sluzbowych, jesli pominiety lub inny niz napis
::----------------------------------------------------------------------------------------------------------------------
{? cli_ver()='mbasic' || return(0) ?};

exec('VAR_DEL','#object');

_start:={? var_pres('_a')=type_of(0) || _a || 0 ?};
{? ~_start
|| exec('addUpdateReq','stp');
   return(0)
?};

_msg:={? var_pres('_b')=type_of(0) || _b || 1 ?};
_msg:=_msg*{? cli_ver()='jterm' || 1 || 0 ?};

_rodzaj:={? var_pres('_c')=type_of('') || _c || 'P' ?};
   _slo:={? var_pres('_d')=type_of('') || _d || ''  ?};
   _kod:={? var_pres('_e')=type_of('') || _e || ''  ?};

_result:=exec('oWynik','stp');

_update:={? _start=1
         || exec('isUpdateReq','stp')
         |? _start=2
         || 1
         || 0
         ?};
_trans:=do_state()>0;
{? exec('get_par','#parametr',241,2)='N'
|| {? ~_trans
   || {? _start
      || {? ~_update
         || ntc_eat(,'stpUpdate');
            _result.wynik:=1;
            _result.opis:='Nie jest wymagana aktualizacja tabeli podwładnych.'@;
            return(_result)
         ?}
      || {? _msg & ~FUN.ask('Czy zaktualizować zależności służbowe?'@)
         || return(_result)
         || 1
         ?}
      ?}
   ?}
|| ntc_eat(,'stpUpdate');
   __STP_A:=0;
   _result.wynik:=1;
   _result.opis:='Parametr %1 ma wartość różną od %2.'@['241','N'];
   return(_result)
?};

:: sprawdzamy czy trwa aktualizacja tabeli STP
{? exec('isUpdateInProg','stp')
|| _result.opis:='Trwa aktualizacja tabeli podwładnych.'@;
   return(_result)
?};
:: wlasciwa aktualizacja
obj_del(_result);
_result:=exec('update','stp',_rodzaj,_slo,_kod,_msg);
_result


\update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Aktualizuje tabele STP
::   WE:  _a - [STRING] - Rodzaj
::        _b - [STRING] - symbol slownika kodow, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::        _c - [STRING] - symbol kodu zaleznosci sluzbowych, jesli pominiety lub inny niz napis,
::        _d - [INTEGER]- czy wyswietlac komunikaty
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_rodzaj:={? var_pres('_a')=type_of('') || _a || 'P' ?};
   _slo:={? var_pres('_b')=type_of('') || _b || ''  ?};
   _kod:={? var_pres('_c')=type_of('') || _c || ''  ?};
   _msg:={? var_pres('_d')=type_of(0)  || _d || 0   ?};

_msg:=_msg*{? cli_ver()='jterm' || 1 || 0 ?};

_result:=exec('oWynik','stp');

__STP_A:=1;
:: usuwamy informacje o koniecznosci aktualizacji
exec('delUpdateReq','stp');
:: dodajemy informacje o trwajacej aktualizacji
{? exec('addUpdateInProg','stp')
||
:: robimy aktualizacje do tabeli tymczasowej
   _tabSTP:=exec('getSTP_tab_tmp','stp');
   _etapy:=3;
   _slo_kod_size:=0;
   _size:=0;
   _loop:=1;
   _dalej:=1;
   _typ_N:=null();
   SLO_TYP.clear;
   SLO_TYP.index('SYMBOL');
   {? SLO_TYP.find_key('NIEZNANY','NIEZNANY')
   || _slo_typ:=SLO_TYP.SYMBOL;
      SLO_KOD.index('KOD');
      SLO_KOD.prefix(SLO_TYP.ref());
      {? SLO_KOD.first()
      || {!
         |? _slo_kod:=SLO_KOD.KOD;
            _typ_N:=SLO_KOD.ref();
            SLO_KOD.cntx_psh();
            {? _size=0 || _size:=1 ?};
            obj_del(_result);
            _result:=exec('add2pracPod','stp',_slo_typ,_slo_kod,_loop,_etapy,_rodzaj,_tabSTP,_msg);
            SLO_KOD.cntx_pop();
            SLO_KOD.next()
         !}
      ?}
   ?};
:: kopiujemy _tabSTP do STP
   {? _result.wynik
   || {? STP.lock(1,1)
      || STP.cntx_psh();
:: usuwamy rekordy
         {? _slo='' & _kod=''
         || _ndx:=STP.ndx_tmp('',1,'P','FIRMA',,'R',,,'STP',,);
            STP.index(_ndx);
            STP.prefix(exec('ref_firma','ustawienia'),_rodzaj,0)
         || _typ:=exec('kod','ext_slo',_slo,_kod);
            _ndx:=STP.ndx_tmp('',1,'P','FIRMA',,'R',,,'TYP',,,'STP',,);
            STP.index(_ndx);
            STP.prefix(exec('ref_firma','ustawienia'),_rodzaj,_typ,0)
         ?};
         _loop+=1;
         {? _msg
         || PROGRESS.set(STP.size(),
                         'Trwa aktualizacja zależności służbowych dla tabeli: \'%1\'...(etap %2/%3)'@
                         ['STP',$_loop,$_etapy],
                         'Podwładni'@)
         ?};
         {? STP.first()
         || {!
            |? {? _msg || PROGRESS.next() ?};
               {? exec('del_tree_branch','#tree',STP,'STP',,#STP.ref())
               || STP.del()
               || STP.next()
               ?}
            !}
         ?};
         {? _msg || PROGRESS.close() ?};
:: kopiujemy do odpowiednich słowników
         _loop+=1;
         {? _msg
         || {? _slo='' & _kod=''
            || {? _typ_N<>null() || _slo_kod_size:=1 ?};
               {? SLO_TYP.find_key('TYPPOZ','TYPPOZ')
               || _slo_typ:=SLO_TYP.SYMBOL;
                  SLO_KOD.index('KOD');
                  SLO_KOD.prefix(SLO_TYP.ref());
                  _slo_kod_size+=SLO_KOD.size()
               ?}
            || _slo_kod_size:=1
            ?};
            PROGRESS.set(_slo_kod_size,
                         'Trwa aktualizacja zależności służbowych dla tabeli: \'%1\'...(etap %2/%3)'@
                         ['STP',$_loop,$_etapy],
                         'Podwładni'@)
         ?};
         {? _slo='' & _kod=''
         || {? _typ_N<>null()
            || {? _msg || PROGRESS.next() ?};
               exec('copyToSTP','stp',_tabSTP,_rodzaj,_typ_N)
            ?};
            {? SLO_TYP.find_key('TYPPOZ','TYPPOZ')
            || _slo_typ:=SLO_TYP.SYMBOL;
               SLO_KOD.index('KOD');
               SLO_KOD.prefix(SLO_TYP.ref());
               {? SLO_KOD.first()
               || {!
                  |? _typ:=SLO_KOD.ref();
                     SLO_KOD.cntx_psh();
                     {? _msg || PROGRESS.next() ?};
                     exec('copyToSTP','stp',_tabSTP,_rodzaj,_typ);
                     SLO_KOD.cntx_pop();
                     SLO_KOD.next()
                  !}
               ?}
            ?}
         || _typ:=exec('kod','ext_slo',_slo,_kod);
            {? _msg || PROGRESS.next() ?};
            exec('copyToSTP','stp',_tabSTP,_rodzaj,_typ)
         ?};
         {? _msg || PROGRESS.close() ?};
         STP.cntx_pop();
         STP.ndx_drop(_ndx);
         STP.unlock()
      ?};
:: zjadamy powiadomienia
      _result.wynik:=1;
      _result.opis:='Aktualizacja zakończona.'@;
      ntc_eat(,'stpUpdate')
   ?};
:: usuwamy informacje o trwajacej aktualizacji
   exec('delUpdateInProg','stp')
|| _result.opis:='Nie udało się dodać informacji o trwajacej aktualizacji.'@
?};
__STP_A:=0;
_result


\add2pracPod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Dodaje podwladnych do tabeli STP zgodnych ze wskazanym symbolem zaleznosci sluzbowych
::   WE: _a [STRING] - symbol slownika kodow
::       _b [STRING] - symbol kodu zaleznosci sluzbowych
::       _c [INTEGER]- etap
::       _d [INTEGER]- rozmiar wszystkich etapow
::       _e [STRING] - rodzaj
::       _f [TABLE]  - tabela tymczasowa do obslugi kopiowania w tle
::       _g [INTEGER]- czy wyswietlac komunikaty
::----------------------------------------------------------------------------------------------------------------------
_slo_typ:={? var_pres('_a')=type_of('') || _a || return(-1) ?};
_slo_kod:={? var_pres('_b')=type_of('') || _b || return(-1) ?};
   _loop:={? var_pres('_c')=type_of(0)  || _c || 1          ?};
  _etapy:={? var_pres('_d')=type_of(0)  || _d || 1          ?};
 _rodzaj:={? var_pres('_e')=type_of('') || _e || 'P'        ?};
 _tabSTP:={? var_pres('_f')=type_of(SYSLOG) || _f || exec('getSTP_tab_tmp','stp') ?};
    _msg:={? var_pres('_g')=type_of(0)      || _g || 1                            ?};

_msg:=_msg*{? cli_ver()='jterm' || 1 || 0 ?};

_typ:=exec('kod','ext_slo',_slo_typ,_slo_kod);

STP.cntx_psh();
_ndx:=STP.ndx_tmp('',1,'R',,,'TYP',,,'P',,);
STP.index(_ndx);
P.cntx_psh();
P.index('OSOBA');
OSOBA.cntx_psh();
OSOBA.index('OSOBA');
OSOBA.prefix();
_size:=OSOBA.size();

:: wcześniejsze utworzenie tabeli w celu przyspieszenie działania
_tab:=exec('tab_zal','stanprac');
_tab.index(_tab.ndx_tmp(,,'L',,));

{? _msg
|| PROGRESS.set(_size,
                'Trwa aktualizacja zależności służbowych dla tabeli: \'%1\'...(etap %2/%3)'@['STP',$_loop,$_etapy],
                'Podwładni'@)
?};
_obj:=obj_new('add_prac','add_nad','slo_typ','slo_kod','typ','rodzaj','STP','ndx');
_obj.slo_typ:=_slo_typ;
_obj.slo_kod:=_slo_kod;
_obj.typ:=_typ;
_obj.rodzaj:=_rodzaj;
: do pola obiektu przypisujemy tabele z ustawionym juz wczesniej indexem
_obj.STP:=_tabSTP;
_obj.ndx:=_tabSTP.ndx_tmp(,1,'R',,,'TYP',,,'STP',,,'P',,);
:: formula do dodawania pracownika podwladnego
_obj.add_prac:="
   _p_ref:=_a;
   _stp_nad:=_b;
   _jest_nad:=0;
   .STP.cntx_psh();
   .STP.prefix(.rodzaj,.typ,_p_ref);
   {? .STP.first()
   || {? .STP.STP=0
      || .STP.STP:=_stp_nad;
         {? .STP.put()
         || _jest_nad:=1
         ?}
      || .STP.cntx_psh();
         .STP.index(.ndx);
         .STP.prefix(.rodzaj,.typ,_stp_nad);
         {? .STP.first()
         || {!
            |? {? .STP.P=_p_ref || _jest_nad:=1 ?};
               ~_jest_nad & .STP.next()
            !}
         ?};
         .STP.cntx_pop()
      ?}
   ?};
   {? ~_jest_nad
   || .STP.blank(1);
      .STP.R:=.rodzaj;
      .STP.TYP:=.typ;
      .STP.P:=_p_ref;
      .STP.STP:=_stp_nad;
      .STP.prefix();
      .STP.add()
   ?};
   .STP.cntx_pop()
";
:: formula do rekurencyjnego dodawania przelozonych
_obj.add_nad:="
   _p_ref:=_a;
   _tab:=exec('prac_nad_old','stanprac',_p_ref,0,.slo_typ,.slo_kod,,,,1);
   {? _tab.first()
   || {!
      |? P.prefix();
         {? P.seek(_tab.P,)
         || _p_nad:=P.ref();
::          wyszukanie (i ewntualne dodanie) pracownika nadrzędnego
            _stp_nad:=null();
            .STP.prefix(.rodzaj,.typ,_p_nad);
            {? .STP.first()
            ||
::             dla wszystkich rekordow przelozonoego dodaj pracownika podwladnego
               {!
               |? _stp_nad:=.STP.ref();
                  .STP.cntx_psh();
::                wyszukanie (i ewntualne dodanie) pracownika
                  {? _p_nad<>_p_ref & _tab.L=1
                  || .add_prac(_p_ref,_stp_nad)
                  ?};
                  .STP.cntx_pop();
                  .STP.next()
               !}
            ||
::             jezeli nie ma przelozonego to dodaj go oraz dodaj podwladnego
               .STP.blank(1);
               .STP.R:=.rodzaj;
               .STP.TYP:=.typ;
               .STP.P:=_p_nad;
               .STP.prefix();
               {? .STP.add()
               || _stp_nad:=.STP.ref()
               ?};
::             wyszukanie (i ewntualne dodanie) pracownika
               {? _p_nad<>_p_ref & _tab.L=1
               || .add_prac(_p_ref,_stp_nad)
               ?}
            ?}
         ?};
::       rekurencyjne dodanie przelozonych pracownika przelozonego
         {? _p_nad<>_p_ref
         || .add_nad(_p_nad)
         ?};
         _tab.next()
      !}
   ?}
";

_result:=exec('oWynik','stp');
{? OSOBA.first()
|| {!
   |? OSOBA.cntx_psh();
      P.prefix(OSOBA.ref(),exec('ref_firma','ustawienia'));
      {? P.first()
      || {!
         |? _p_ref:=P.ref();
            _o_ref:=P.OSOBA;
::          pobieramy wszystkich przelozonych wyznaczonych dynamicznie
            {? _tab.first() || {! |? _tab.del() !} ?};
            exec('prac_nad_old','stanprac',_p_ref,0,_a,_b,_tab,,,1);
::          dodanie zmian do STP dla rekordow,
            {? _tab.first()
            || {!
               |? P.cntx_psh();
                  P.prefix();
                  {? P.seek(_tab.P,)
                  || _p_nad:=P.ref();
                     _obj.add_nad(_p_nad)
                  ?};
                  P.cntx_pop();
                  _stp_nad:=null();
                  _obj.STP.prefix(_rodzaj,_typ,_p_nad);
                  {? _obj.STP.first()
                  ||
::             dla wszystkich rekordow przelozonoego dodaj pracownika podwladnego
                     {!
                     |? _stp_nad:=_obj.STP.ref();
                        _obj.STP.cntx_psh();
::                      wyszukanie (i ewntualne dodanie) pracownika
                        {? _p_nad<>_p_ref & _tab.L=1
                        || _obj.add_prac(_p_ref,_stp_nad)
                        ?};
                        _obj.STP.cntx_pop();
                        _obj.STP.next()
                     !}
                  ||
::             jezeli nie ma przelozonego to dodaj go oraz dodaj podwladnego
                     _obj.STP.blank(1);
                     _obj.STP.R:=_rodzaj;
                     _obj.STP.TYP:=_typ;
                     _obj.STP.P:=_p_nad;
                     _obj.STP.prefix();
                     {? _obj.STP.add()
                     || _stp_nad:=_obj.STP.ref()
                     ?};
::             wyszukanie (i ewntualne dodanie) pracownika
                     {? _p_nad<>_p_ref & _tab.L=1
                     || _obj.add_prac(_p_ref,_stp_nad)
                     ?}
                  ?};
                  _tab.next()
               !}
            ?};
            P.next()
         !}
      ?};
      OSOBA.cntx_pop();
      {? _msg || PROGRESS.next() ?};
      {? exec('isUpdateReq','stp')
      || _result.wynik:=0;
         _result.opis:='Aktualizacja przerwana. Konieczne ponowne rozpoczęcie aktualizacji.'@
      || _result.wynik:=1;
         _result.opis:='Aktualizacja w trakcie.'@
      ?};
      _result.wynik & OSOBA.next()
   !}
?};
{? _msg || PROGRESS.close() ?};

_obj.STP.ndx_drop(_obj.ndx);
OSOBA.cntx_pop();
P.cntx_pop();
STP.cntx_pop();
STP.ndx_drop(_ndx);
_result


\isUpdateReq
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja sprawdzajaca czy tabela STP wymaga aktualizacji
::----------------------------------------------------------------------------------------------------------------------
_ok:=0;
_ref:=0;
BLK.index('AMR');
BLK.prefix('STP',STP.name(),_ref);
{? BLK.first()
|| _ok:=1
?};
:: sprawdz czy poprzednia aktualizacja sie udala do konca (nie zostal rekord z 1)
{? ~_ok
|| BLK.prefix('STP',STP.name(),1);
   {? BLK.first()
   || {? BLK.SES_ID<>STP.ses_id()
      || {? BLK.r_lock(1,1,1)
         || BLK.r_unlock();
            _ok:=1
         ?}
      ?}
   ?}
?};
_ok


\addUpdateReq
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja dodajaca informacje o koniecznosci aktualizacji tabeli STP
::----------------------------------------------------------------------------------------------------------------------
_ok:=0;
_ref:=0;
BLK.index('AMR');
BLK.prefix('STP',STP.name(),_ref);
{? ~BLK.first()
|| BLK.ACR:='STP';
   BLK.MSK:=STP.name();
   BLK.REF:=_ref;
   BLK.SES_ID:=STP.ses_id();
   _ok:=BLK.add()
|| _ok:=1
?};
{? _ok
|| PARAMETR.cntx_psh();
   PARAMS.cntx_psh();
   {? (exec('get_par','#parametr',241,2)='N') & (exec('get_par','#parametr',244,2)='T')
   || exec('ntc_send_update','stp')
   ?};
   PARAMS.cntx_pop();
   PARAMETR.cntx_pop()
?};
_ok


\delUpdateReq
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja usuwajaca informacje o koniecznosci aktualizacji tabeli STP
::----------------------------------------------------------------------------------------------------------------------
_ref:=0;
BLK.index('AMR');
BLK.prefix('STP',STP.name(),_ref);
{? BLK.first()
|| BLK.del()
?};
~~


\isUpdateInProg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja sprawdzajaca czy tabela STP jest w trakcie aktualizacji
::----------------------------------------------------------------------------------------------------------------------
_ok:=0;
_ref:=1;
BLK.index('AMR');
BLK.prefix('STP',STP.name(),_ref);
{? BLK.first()
|| {? BLK.SES_ID=STP.ses_id()
   || _ok:=1
   || {? BLK.r_lock(1,1,1)
      || BLK.r_unlock()
      || _ok:=1
      ?}
   ?}
?};
_ok


\addUpdateInProg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja dodajaca informacje o trwajacej aktualizacji tabeli STP
::----------------------------------------------------------------------------------------------------------------------
_ok:=0;
_ref:=1;
BLK.index('AMR');
BLK.prefix('STP',STP.name(),_ref);
{? ~BLK.first()
|| BLK.ACR:='STP';
   BLK.MSK:=STP.name();
   BLK.REF:=_ref;
   BLK.SES_ID:=STP.ses_id();
   _ok:=BLK.add()
|| _ok:=1
?};
:: jezeli udalo sie dodac rekord - zaloz na nim blokade
{? _ok
|| {? BLK.r_lock(1,1,1)
   || BLK.SES_ID:=STP.ses_id();
      _ok:=BLK.put()
   || _ok:=0
   ?}
?};
_ok


\delUpdateInProg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja usuwajaca informacje o trwajacej aktualizacji tabeli STP
::----------------------------------------------------------------------------------------------------------------------
_ref:=1;
BLK.index('AMR');
BLK.prefix('STP',STP.name(),_ref);
{? BLK.first()
|| BLK.r_unlock();
   BLK.del()
?};
~~


\isSTPEnabled
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Czy wlaczone jest korzystanie z tabeli STP
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_stp_a:=var_pres('__STP_A');
{? var_pres('__PAR241')<0 || __PAR241:=exec('get_par','#parametr',241,2)='N' ?};
(__PAR241 & ({?_stp_a<0 || 1 || __STP_A=0 ?}))


\getSTP_tab_tmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja zwraca tabele tymczasowa zgodna z STP
::   WY: tab_tmp
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(1,
         'STP'    , 'TREE_REF'   , 'Nadrzędny'@,
         'P'      , 'INTEGER'    , 'Pracownik'@,
         'POZWORG', 'INTEGER'    , 'Pozycja w organizacji'@,
         'TYP'    , 'INTEGER'    , 'Typ zależności'@,
         'R'      , 'STRING[1]'  , 'Rodzaj'@
      );
_ndx:=_tab.ndx_tmp('',1,'R',,,'TYP',,,'P',,);
_tab.index(_ndx);
_tab


\copyToSTP
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Kopiuje zawartosc tabeli tymczasowej do tabeli stalej STP
::   WE: _a - [TABLE]      - tabela tymczasowa _tabSTP
::       _b - [STRING]     - Rodzaj
::       _c - [REFERENCE]  -  wskazanie na typ zależności (SLO_KOD)
::----------------------------------------------------------------------------------------------------------------------
   _tab:={? var_pres('_a')=type_of(SYSLOG) || _a || return(0) ?};
_rodzaj:={? var_pres('_b')=type_of('')     || _b || return(0) ?};
   _typ:={? var_pres('_c')=type_of(null)   || _c || return(0) ?};

_ndx2:=_tab.ndx_tmp(,1,'STP',,);
_tab.index(_ndx2);

:: powolanie obiektu do obslugi kopiowania
_obj:=obj_new('STP','TAB','add');
_obj.STP:=STP;
_obj.TAB:=_tab;

_obj.add:="
   _parentD:=_a;
   _parentS:=_b;
   _rodzaj:=_c;
   _typ:=_d;
   STP.STP:=_parentD;
   STP.R:=_rodzaj;
   STP.P:={? P.seek(.TAB.P,) || P.ref() || null() ?};
   STP.POZWORG:={? POZWORG.seek(.TAB.POZWORG,) || POZWORG.ref() || null() ?};
   STP.TYP:=_typ;
   STP.cntx_psh();
   STP.prefix();
   {? STP.add()
   || .TAB.cntx_psh();
      .TAB.prefix(.TAB.ref());
      {? .TAB.first()
      || {!
         |? .add(STP.ref(),.TAB.STP,_rodzaj,_typ);
            .TAB.next()
         !}
      ?};
      .TAB.cntx_pop()
   ?};
   STP.cntx_pop()
";

:: kopiowanie
P.cntx_psh();
POZWORG.cntx_psh();
SLO_KOD.cntx_psh();
P.prefix();
POZWORG.prefix();
SLO_KOD.prefix();
_obj.TAB.prefix(0);
{? _obj.TAB.first()
|| {!
   |? _obj.add(0,_obj.TAB.STP,_rodzaj,_typ);
      _obj.TAB.next()
   !}
?};
SLO_KOD.cntx_pop();
POZWORG.cntx_pop();
P.cntx_pop();
~~


\ntc_send_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Dodaje powiadomienie o konieczności aktualizacji tabeli STP
::----------------------------------------------------------------------------------------------------------------------
{? ntc_info(,'stpUpdate')=0
|| _button1:='Aktualizuj';
   _action1:="exec('start_proces','b_proces',0);exec('makeTabStp','stp',1,1,'P')";
   ntc_send(,,,
      'Wymagana aktualizacja zależności służbowych pracowników'@,
      '<html>'
      '<p>'
      'Nastąpiła zmiana danych, mająca wpływ na wyznaczenie zależności służbowych.'@+'<br>'
      'Konieczna jest aktualizacja struktury przechowującej informacje o tych zależnościach.'@+
      '</p>'
      '</html>',
      'stpUpdate',1,,date()+14,
      _button1,_action1
   )
?}


\rodz_stan_ob
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [12.41]
:: OPIS: Funkcja ustala czy stanowisko pracownika jest stanowiskiem kierowniczym z uwzglednieniem pelnionych obowiazkow
::   WE: _a - [REFERENCE]  - wskazanie na pracownika
::       _b - [STRING]     - symbol slownika kodow, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::       _c - [STRING]     - symbol kodu zaleznosci sluzbowych, jesli pominiety lub inny niz napis,
::                           to przyjety zostanie NIEZNANY
::       _d - [STRING]     - informacja czy podstawowe stanowisko pracownika jest kierownicze
::   WY: T/N - informacja czy stanowisko kierownicze
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null()) || return(0)?};
{? var_pres('_b')<>type_of('') | |_b='' || _b:='NIEZNANY' ?};
{? var_pres('_c')<>type_of('') | |_c='' || _c:='NIEZNANY' ?};
_szef:={? var_pres('_d')<>type_of('') | |_d='' || 'N' || _d ?};

P.cntx_psh();
SLO_KOD.cntx_psh();
P_PO.cntx_psh();
P_PO.index('P_PO');
P_PO.prefix(_a);
{? P_PO.first()
|| {!
   |? {? P_PO.TYP().KOD=_c & SLO_KOD.SLO_TYP().SYMBOL=_b & {? P_PO.CO='T' || P_PO.OD<=date & date<=P_PO.DO || 1 ?}
      || {? P_PO.NB='N'
         || _szef:=P_PO.ST().K
         || P.index('PRACOWST');
            P.prefix(P_PO.WYDZIAL,P_PO.ST,'T');
            {? P.first() & exec('czy_jest','nieobecnosc',P.ref())
            || _szef:=P_PO.ST().K
            ?}
         ?}
      ?};
      P_PO.next()
   !}
?};
P_PO.cntx_pop();
SLO_KOD.cntx_pop();
P.cntx_pop();
_szef


\rodz_stan_pz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Funkcja ustala czy stanowisko pracownika jest stanowiskiem kierowniczym z uwzglednieniem przypisanych zastępstw
::   WE: _a - [REFERENCE]  - wskazanie na pracownika
::       _b - [STRING]     - symbol slownika kodow, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::       _c - [STRING]     - symbol kodu zaleznosci sluzbowych, jesli pominiety lub inny niz napis,
::                           to przyjety zostanie NIEZNANY
::   WY: T/N - informacja czy stanowisko kierownicze
::----------------------------------------------------------------------------------------------------------------------
_result:='N';
  _p_ref:={? var_pres('_a')=type_of(null())    || _a || return(_result) ?};
_sym_typ:={? var_pres('_b')=type_of('')&(+|_b) || _b || _b:='NIEZNANY'  ?};
_sym_kod:={? var_pres('_c')=type_of('')&(+|_c) || _c || _c:='NIEZNANY'  ?};

_typ:=exec('kod','ext_slo',_sym_typ,_sym_kod);
_por:=exec('lic','#b_domain','POR');

P.cntx_psh();
P.prefix();
{? P.seek(_p_ref)
|| STN.cntx_psh();
   _result:=P.ST().K;
   {? _result<>'T'
   || P_PZ.cntx_psh();
      P_PZ.index('REVERT');

::    zaleznosci czasowe
      P_PZ.prefix('Z',_typ,P.ref,'T');
      {? P_PZ.first()
      || {!
         |? _ok:=0;
            {? P_PZ.OD<=date & {? ~_por || date<=P_PZ.DO || 1 ?}
            || _ok:={? P_PZ.NB='T' || exec('czy_jest','nieobecnosc',P_PZ.P) || 1 ?};
               {? _ok || _result:=P_PZ.P().ST().K ?}
            ?};
            (_result<>'T') & P_PZ.next()
         !}
      ?};

::    zaleznosci domyslne
      P_PZ.prefix('Z',_typ,P.ref,'N');
      {? (_result<>'T') & P_PZ.first()
      || {!
         |? _ok:={? P_PZ.NB='T' || exec('czy_jest','nieobecnosc',P_PZ.P) || 1 ?};
            {? _ok || _result:=P_PZ.P().ST().K ?};
            (_result<>'T') & P_PZ.next()
         !}
      ?};

      P_PZ.cntx_pop()
   ?};
   STN.cntx_pop()
?};
P.cntx_pop();
_result


\rodz_stan_pp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Funkcja ustala czy stanowisko pracownika jest stanowiskiem kierowniczym ze wzgledu na bezposrednie przypisanie
::       podwladnych
::   WE: _a - [REFERENCE]  - wskazanie na pracownika
::       _b - [STRING]     - symbol slownika kodow, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::       _c - [STRING]     - symbol kodu zaleznosci sluzbowych, jesli pominiety lub inny niz napis,
::                           to przyjety zostanie NIEZNANY
::   WY: T/N - informacja czy stanowisko kierownicze
::----------------------------------------------------------------------------------------------------------------------
_result:='N';
  _p_ref:={? var_pres('_a')=type_of(null())    || _a || return(_result) ?};
_sym_typ:={? var_pres('_b')=type_of('')&(+|_b) || _b || _b:='NIEZNANY'  ?};
_sym_kod:={? var_pres('_c')=type_of('')&(+|_c) || _c || _c:='NIEZNANY'  ?};

_typ:=exec('kod','ext_slo',_sym_typ,_sym_kod);
_por:=exec('lic','#b_domain','POR');

P.cntx_psh();
P.prefix();
{? P.seek(_p_ref)
|| STN.cntx_psh();
   _result:=P.ST().K;
   {? _result<>'T'
   || P_PZ.cntx_psh();
      P_PZ.index('UNIQUE');

::    zaleznosci domyslne
      P_PZ.prefix('P',_typ,P.ref,'N');
      {? (_result<>'T') & P_PZ.first()
      || _result:='T'
      ?};

::    zaleznosci czasowe
      P_PZ.prefix('P',_typ,P.ref,'T');
      {? (_result<>'T') &  P_PZ.first()
      || {!
         |? _ok:=0;
            {? P_PZ.OD<=date & {? ~_por || date<=P_PZ.DO || 1 ?}
            || _result:='T'
            ?};
            (_result<>'T') & P_PZ.next()
         !}
      ?};

      P_PZ.cntx_pop()
   ?};
   STN.cntx_pop()
?};
P.cntx_pop();
_result


\czyKier_Zal_Ob
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Funkcja sprawdza czy pracownik pracuje na stanowsiku kierowniczym z uwzglednieniem pelnionych obowiazkow lub
::       przypisanych zastepstw
::   WE: _a - [REFERENCE] - wskazanie na pracownika
::       _b - [STRING]     - symbol slownika kodow, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::       _c - [STRING]     - symbol kodu zaleznosci sluzbowych, jesli pominiety lub inny niz napis,
::                           to przyjety zostanie NIEZNANY
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:='N';
  _p_ref:={? var_pres('_a')=type_of(null())    || _a || return(_result) ?};
_sym_typ:={? var_pres('_b')=type_of('')&(+|_b) || _b || _b:='NIEZNANY'  ?};
_sym_kod:={? var_pres('_c')=type_of('')&(+|_c) || _c || _c:='NIEZNANY'  ?};

P.cntx_psh();
P.prefix();
{? P.seek(_p_ref)
|| STN.cntx_psh();
   _result:=P.ST().K;
:: sprawdzenie bezposredniego przypisania podwladnych
   {? _result<>'T'
   || _result:=exec('rodz_stan_pp','stp',P.ref(),_sym_typ,_sym_kod)
   ?};
:: sprawdzenie zastepstw
   {? _result<>'T'
   || _result:=exec('rodz_stan_pz','stp',P.ref(),_sym_typ,_sym_kod)
   ?};
:: sprawdzenie pelnionych obowiazkow
   {? _result<>'T'
   || _result:=exec('rodz_stan_ob','stp',P.ref(),_sym_typ,_sym_kod,P.ST().K)
   ?};
   STN.cntx_pop()
?};
P.cntx_pop();
_result

:Sign Version 2.0 jowisz:1045 2022/06/30 14:23:24 16f68b7cdc462cd6d3d615723fd58be400e311158b19b245d509db9446245b06bd084112cc7c5595cdd0f5dc7b551762a4987540c91e1b098e2c1dcdf498306b9418d3ed991a4951e6ef07c09379c514bfbc1da64272f5ceadad7e00f47acc631033543a091c0ecd022ca9231f430ff49b00fc77fc6a34fe273cdd1c7b7c8b47
