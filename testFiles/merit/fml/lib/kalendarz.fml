:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: kalendarz.fml
:: Utworzony: 2015.02.18
:: Autor: jaws
::======================================================================================================================
:: Zawartość: Definicje funkcji i deklaracja obiektu do obsługi kalendarzy.
::            Obsługa tabeli DATY.
::======================================================================================================================


\standard_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [2009]
:: OPIS: Wartość początkowa pól przechowujących wskazanie na nazwę kalendarza. Wyszukuje kalendarz o nazwie 'standard'.
::       Jeśli nie znaleziono kalendarza o takiej nazwie, to jest on tworzony (jedynie zapis w tabeli KAL_NAZW a nie
::       cała definicja kalendarza).
::   WY: Wskazanie na kalendarz o nazwie 'standard'.
::  OLD: \std_ref/kaledit.fml
::----------------------------------------------------------------------------------------------------------------------
exec('nazwa_ref','kalendarz','standard')


\nazwa_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [2009]
:: OPIS: Wartość początkowa pól przechowujących wskazanie na nazwę kalendarza. Wyszukuje kalendarz o podanej nazwie.
::       Jeśli nie znaleziono kalendarza o takiej nazwie, to jest on tworzony (jedynie zapis w tabeli KAL_NAZW a nie
::       cała definicja kalendarza).
::   WE: _a - nazwa kalendarza
::   WY: Wskazanie na kalendarz o podanej nazwie.
::UWAGA: poprawność argumentu wywołania nie jest weryfikowana
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
KAL_NAZW.cntx_psh();
KAL_NAZW.index('KAL_CZES');
KAL_NAZW.prefix(exec('ref_firma','ustawienia'),'N');
{? KAL_NAZW.find_key(_a,_a)
|| _ref:=KAL_NAZW.ref
|| KAL_NAZW.blank(1);
   KAL_NAZW.NAZWA:=_a;
   KAL_NAZW.NORMA:=8;
   KAL_NAZW.CZESC:='N';
   KAL_NAZW.GRAFIK:='N';
   KAL_NAZW.FIRMA:=exec('ref_firma','ustawienia');
   {? KAL_NAZW.add(1)
   || _ref:=KAL_NAZW.ref
   || FUN.emsg('Utworzenie kalendarza "%1" nie powiodło się.'@[_a])
   ?}
?};
KAL_NAZW.cntx_pop();
_ref


\declare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Deklaruje klasę KALEND odpowiedzialną za obsługę wewnętrznego kalendarza systemu.
::  OLD: \define/kalend.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('KALEND',@.CLASS)>0
|| return
?};

: Deklaracja klasy
obj_decl('KALEND',

   obj_fld('nazwa',''),
   obj_fld('kal_nazw',0),
   obj_fld('rok',0),
   obj_fld('kal_rok',0),
   obj_fld('czesc',0),
   obj_fld('f_year',0),
   obj_fld('f_month',0),
   obj_fld('f_day',0),
   obj_fld('t_year',0),
   obj_fld('t_month',0),
   obj_fld('t_day',0),
   obj_fld('year',0),
   obj_fld('month',0),
   obj_fld('day',0),
   obj_fld('m_d',0),
   obj_fld('ws',0),
   obj_fld('start_d',date(0,0,0)),
   obj_fld('start_h',time(0,0,0)),
   obj_fld('NO_ERR',0),
   obj_fld('FOUND',1),
   obj_fld('par330',0),

   obj_meth('__init',"
      {? _<2
      || _b:=date()~1;
         _c:=0
      |? _<3
      || _c:=0
      ?};
      .m_d:=obj_new(12);
      .m_d[1]:=31;
      .m_d[2]:=28;
      .m_d[3]:=31;
      .m_d[4]:=30;
      .m_d[5]:=31;
      .m_d[6]:=30;
      .m_d[7]:=31;
      .m_d[8]:=31;
      .m_d[9]:=30;
      .m_d[10]:=31;
      .m_d[11]:=30;
      .m_d[12]:=31;
      .set_cal('standard',_b,_c);
      .ws:=exec('ws_create','kalendarz');
      .par330:=exec('get_par','#parametr',330,2)='T'
   "),

   obj_meth('clear',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Ustawia wartości początkowe pól obiektu
::----------------------------------------------------------------------------------------------------------------------
   "  .nazwa:='';
      .kal_nazw:=null();
      .rok:=0;
      .kal_rok:=null();
      .czesc:=0;
      ~~
   ",-1),

   obj_meth('set_cal',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Ustawia kalendarz 'standard'
::----------------------------------------------------------------------------------------------------------------------
   ".set_cal('standard')",-1),

   obj_meth('set_cal',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Ustawia kalendarz
::   WE: _a - wskazanie na rekord w tabeli KAL_NAZW
::----------------------------------------------------------------------------------------------------------------------
   "  KAL_NAZW.index('KAL_NAZW');
      KAL_NAZW.prefix(exec('ref_firma','ustawienia'));
      {? ~KAL_NAZW.seek(_a)
      || return(0)
      ?};
      .nazwa:=KAL_NAZW.NAZWA;
      .kal_nazw:=_a;
      .rok:={? var_pres('_b')=type_of(0) & _b>0 || _b || date()~1 ?};
      .no_err(var_pres('_c')=type_of(0) & _c);
      .kal_rok:=null();
      .czesc:=((1+.nazwa)=%255);
      {? .rok<>0 || .yearpres(.rok) ?}
   ",type_of(null())),

   obj_meth('set_cal',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Ustawia kalendarz
::   WE: _a - nazwa kalendarza
::----------------------------------------------------------------------------------------------------------------------
   "  .set_cal(
         .find_cal(_a),
         {? var_pres('_b')=type_of(0) & _b>0 || _b || ~~ ?},
         var_pres('_c')=type_of(0) & _c
      )
   ",type_of('')),

   obj_meth('p_kin',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca informację o tym, czy kalendarz bieżącego pracownika jest indywidualny.
::   WY: 'T' - kalendarz indywidualny, 'N' - kalendarz ogólny
::----------------------------------------------------------------------------------------------------------------------
   "  R_WZCZ.cntx_psh();
      R_WZCZ.index('R_WZCZ');
      R_WZCZ.prefix(P.name(),P.ref());
      _wyn:=
         {? R_WZCZ.find_le(_a)
         || R_WZCZ.KIN
         || 'N'
         ?};
      R_WZCZ.cntx_pop();
      _wyn
   ",type_of(date())),

   obj_meth('grafik',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca informację o tym, czy kalendarz bieżącego pracownika jest grafikiem.
::   WY: 'T' - kalendarz jest grafikiem, 'N' - kalendarz ogólny
::----------------------------------------------------------------------------------------------------------------------
   "  R_WZCZ.cntx_psh();
      R_WZCZ.index('R_WZWND');
      R_WZCZ.prefix(P.name(),P.ref(),'N','N');
      _wyn:=
         {? R_WZCZ.find_le(_a)
         || R_WZCZ.GRAFIK
         || 'N'
         ?};
      R_WZCZ.cntx_pop();
      _wyn
   ",type_of(date())),

   obj_meth('except',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Metoda dla bieżącej zawartości bufora tabeli P sprawdza, czy podany dzień jest odstępstwem
::       (dniem poza wzorcem).
::   WE: _a - Badana data.
::   WY: 1 - Podany dzień jest odstępstwem.
::       0 - Podany dzień nie jest odstępstwem.
::----------------------------------------------------------------------------------------------------------------------
   "  _dzien:=_a;
      R_WZCZ.cntx_psh();
      R_WZCZ.index('R_WZWND');
      R_WZCZ.prefix(P.name(),P.ref(),'T','N',_dzien);
      _wyn:=R_WZCZ.first();
      R_WZCZ.cntx_pop();
      _wyn
   ",type_of(date())),

      obj_meth('wzo_name',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [18.42]
:: OPIS: Zwraca informację o nazwie wzorca kalendarza dla dnia
::   WY: nazwa wzorca lub 'standard'
::----------------------------------------------------------------------------------------------------------------------
   "  R_WZCZ.cntx_psh();
      R_WZCZ.index('R_WZWND');
      R_WZCZ.prefix(P.name(),P.ref(),'N','N');
      _wyn:='standard';
      {? R_WZCZ.find_le(_a)
      || _nazwa:=R_WZCZ.KAL().NAZWA;
         KAL_ROK.cntx_psh();
         KAL_ROK.index('KAL_NAZ');
         KAL_ROK.prefix(exec('ref_firma','ustawienia'),_nazwa,_nazwa,_a~1);
         {? KAL_ROK.first()
         || _wyn:=KAL_ROK.WZORZEC
         ?};
         KAL_ROK.cntx_pop()
      ?};
      R_WZCZ.cntx_pop();
      _wyn
   ",type_of(date())),


   obj_meth('w_days',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca liczbę dni roboczych w okresie
::   WE: _a - data początku okresu
::       _b - data końca okresu
::   WY: liczba dni roboczych
::----------------------------------------------------------------------------------------------------------------------
   ".cnt_days(_a,_b,'R')",type_of(date()),type_of(date())),

   obj_meth('f_days',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca liczbę dni wolnych od pracy w okresie
::   WE: _a - data początku okresu
::       _b - data końca okresu
::   WY: liczba dni wolnych od pracy
::----------------------------------------------------------------------------------------------------------------------
   ".cnt_days(_a,_b,'W')",type_of(date()),type_of(date())),

   obj_meth('h_days',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca liczbę dni świątecznych w okresie
::   WE: _a - data początku okresu
::       _b - data końca okresu
::   WY: liczba dni świątecznych
::----------------------------------------------------------------------------------------------------------------------
   ".cnt_days(_a,_b,'S')",type_of(date()),type_of(date())),

   obj_meth('w_hours',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zwraca liczbę godzin roboczych w okresie
::   WE: _a - data początku okresu
::       _b - data końca okresu
::       _c - czy pomijać wymiar zatrudnienia w przypadku pracownika
::       _d - typ i format wyniku:
::            - liczba > 0    => wynik typu REAL bez zaokrąglenia do dwóch miejsc po przecinku
::            - 'T' lub 't'   => wynik typu TIME
::            - wpp           => wynik typu REAL zaokrąglony do dwóch miejsc po przecinku
::   WY: liczba godzin roboczych
::----------------------------------------------------------------------------------------------------------------------
   "  _ret:=.cnt_hour(_a,_b,(var_pres('_c')=type_of(0) & _c>0));
      {? var_pres('_d')=type_of(0) & _d>0
      || *_ret/60
      |? var_pres('_d')=type_of('') & -_d='t'
      || _ret
      || (*_ret/60)$2
      ?}
   ",type_of(date()),type_of(date())),

   obj_meth('find_cal',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [2010]
:: OPIS: Wyszukuje kalendarz o podanej argumentem nazwie. Dla wywołania bez podania argumentu, argumentem typu innego
::       niż ciąg znaków, lub pustego ciągu znaków zwracana jest wartość null(). W pozostałych przypadkach zwracane jest
::       wskazanie na rekord w tabeli KAL_NAZW lub null() jeśli nie udało się odnaleźć rekordu.
::   WE: _a - nazwa kalendarza
::   WY: wskazanie na kalendarz o podanej argumentem _a nazwie
:: UWAGA! metoda zmienia kontekst tabeli KAL_NAZW
::----------------------------------------------------------------------------------------------------------------------
   "  {? var_pres('_a')<>type_of('') | |_a=''
      || return(null())
      ?};
      KAL_NAZW.index('KAL_NAZW');
      KAL_NAZW.prefix(exec('ref_firma','ustawienia'));
      {? KAL_NAZW.find_key(_a,_a)
      || KAL_NAZW.ref()
      || null()
      ?}
   ",type_of('')),

::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2010]
:: OPIS: Metoda zwraca typ dnia
::  R - dzień roboczy
::  WH - Harmonogramowo wolny
::  W5 - dzień wolny wynikający z pieciodniowego tygodnia pracy
::  SW - święto
::  SN - niedziela
::----------------------------------------------------------------------------------------------------------------------
   obj_meth('type_day',"
      _val:=' ';
      {? .get_day(_a)
      || _val:=KAL_DEF.TYP;
         {? KAL_DEF.TYPWS<>' ' || _val+=KAL_DEF.TYPWS ?};
         {? |KAL_DEF.TYPWS=''
         ||
::       dodanie sprawdzenia dni świątecznych i wolnych w celu zapewnienia
::       "wstecznej kompatybilności" podczas kwalifikacji
            {? _val='R'
         || {? _a~4=7
               || _val:='RN'
            |? .holiday(_a)
               || _val:='RW'
               ?}
            |? _val='S'
            || {? _a~4=7
               || _val:='SN'
               |? .holiday(_a)
            || _val:='SW'
            ?}
            |? _val='W'
            || _val:={? KAL_DEF.TYPWS=' ' || 'WH' || 'W5' ?}
            ?}
         ?}
      ?};
      _val
      ",type_of(date)),

::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [12.41]
:: OPIS: Metoda zwraca informację, czy w sprawdzanym dniu jest święto.
::       Sprawdzanie bazuje na dniach określonych jako świąteczne (tabela KAL_OPIS) dla wzorca kalendarza standard.
::       W celu przyspieszenia wyszukiwania cała dziedzina tabeli KAL_OPIS znajduje się w tabeli tymczasowej.
::----------------------------------------------------------------------------------------------------------------------
   obj_meth('holiday',"
      .ws.holiday(_a,_b)
   ",type_of(date),type_of('')),

   obj_meth('holiday',"
      .ws.holiday(_a,.wzo_name(_a))
   ",type_of(date)),
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [12.41]
:: OPIS: Metoda zwraca 1 jesli jest swieto lub niedziela
::----------------------------------------------------------------------------------------------------------------------
   obj_meth('all_holiday',"
      .holiday(_a,_b) | _a~4=7
   ",type_of(date),type_of('')),

   obj_meth('all_holiday',"
      .holiday(_a,.wzo_name(_a)) | _a~4=7
   ",type_of(date)),

::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [12.41]
:: OPIS: Metoda zwraca opis święta
::----------------------------------------------------------------------------------------------------------------------
   obj_meth('holidayO',"
      .ws.opis(_a,_b)
   ",type_of(date),type_of('')),

   obj_meth('holidayO',"
      .ws.opis(_a,'standard')
   ",type_of(date)),

   obj_meth('exist_c',"
      exec('exist_c','kalendarz',.,_a)
   ",type_of(1)),

   obj_meth('yearpres',"
      exec('yearpres','kalendarz',.,_a)
   ",type_of(1)),

   obj_meth('cnt_days',
   "  .FOUND:=1;
      exec('cnt_days','kalendarz',.,_a,_b,_c)
   ",type_of(date()),type_of(date()),type_of('')),

   obj_meth('cnt_hour',
   "  .FOUND:=1;
      exec('cnt_hour','kalendarz',.,_a,_b,,(var_pres('_c')=type_of(0) & _c>0))
   ",type_of(date()),type_of(date())),

   obj_meth('get_day',
   "  .FOUND:=1;
      exec('day','kalendarz',.,_a)
   ",type_of(date())),

   obj_meth('isValOk',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Metoda sprawdza, czy ostatnio wykonana operacja dotycząca wyliczenia liczby dni/godzin lub pobrania dnia
::       przebiegła poprawnie. W szczególności znalezione zostały wszystkie kalendarze.
::   WE:
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
      ".FOUND",-1),

   obj_meth('set_sdh',"
      .start_d:=_a;
      .start_h:=_b
   ",type_of(date()),type_of(time())),

   obj_meth('w_start',"
      .set_sdh(date(0,0,0),time(0,0,0));
      _start:=_a;
      {!
      |! {? .get_day(_a)=null()
         || return(0)
         ?};
         {? KAL_DEF.TYP='R'
         || {? _start<KAL_DEF.DATA
            || .set_sdh(_a,KAL_DEF.POCZATEK);
               return(1)
            || {? _b<=KAL_DEF.POCZATEK
               || .set_sdh(_a,KAL_DEF.POCZATEK);
                  return(1)
               |? _b<KAL_DEF.KONIEC
               || .set_sdh(_a,_b);
                  return(1)
               ?}
            ?}
         ?};
         _a+=1
      !}
   ",type_of(date()),type_of(time())),

   obj_meth('w_end',"
      .set_sdh(date(0,0,0),time(0,0,0));
      _start:=_a;
      {!
      |! {? .get_day(_a)=null()
         || return(0)
         ?};
         {? KAL_DEF.TYP='R'
         || {? _start>KAL_DEF.DATA
            || .set_sdh(_a,KAL_DEF.KONIEC);
               return(1)
            || {? _b>=KAL_DEF.KONIEC
               || .set_sdh(_a,KAL_DEF.KONIEC);
                  return(1)
               |? _b>KAL_DEF.POCZATEK
               || .set_sdh(_a,_b);
                  return(1)
               ?}
            ?}
         ?};
         _a-=1
      !}
   ",type_of(date()),type_of(time())),

   obj_meth('whp_end',"
      {? ~.w_start(_a,_b) || return(0) ?};
      _dt:=*(KAL_DEF.KONIEC-.start_h);
      _c:=(_c+_e)*60;
      {? _dt>_c
      || .start_h+=_c;
         return(1)
      ?};
      _a+=1;
      _c-=_dt;
      {!
      |! {? .get_day(_a)=null()
         || return(0)
         ?};
         {? KAL_DEF.TYP='R'
         || _czas:={? _d='T' || {? _f='T' || _c || _c - _e ?} || {? _f='T' || _e || 0 ?} ?};
            {? *KAL_DEF.CZAS>=_czas
            || {? *KAL_DEF.CZAS>=_c
               || .set_sdh(_a,KAL_DEF.POCZATEK+_c);
                  return(1)
               || _c-=*KAL_DEF.CZAS;
                  _e:=0;
                  _a+=1
               ?}
            || _a+=1
            ?}
         || _a+=1
         ?}
      !}
   ",type_of(date()),type_of(time())),

   obj_meth('whp_start',"
      {? ~.w_end(_a,_b) || return(0) ?};
      _dt:=*(.start_h-KAL_DEF.POCZATEK);
      _c:=(_c+_e)*60;
      {? _dt>_c
      || .start_h-=_c;
         return(1)
      ?};
      _a-=1;
      _c-=_dt;
      {!
      |! {? .get_day(_a)=null()
         || return(0)
         ?};
         {? KAL_DEF.TYP='R'
         || _czas:={? _d='T' || {? _f='T' || _c || _c - _e ?} || {? _f='T' || _e || 0 ?}?};
            {? *KAL_DEF.CZAS>=_czas
            || {? *KAL_DEF.CZAS>=_c
               || .set_sdh(_a,KAL_DEF.KONIEC-_c);
                  return(1)
               || _c-=*KAL_DEF.CZAS;
                  _e:=0;
                  _a-=1
               ?}
            || _a-=1
            ?}
         || _a-=1
         ?}
      !}
   ",type_of(date()),type_of(time())),

   obj_meth('wh_end',"
      {? ~.w_start(_a,_b) || return(0) ?};
      _dt:=*(KAL_DEF.KONIEC-.start_h);
      _c:=_c*60;
      {? _dt>=_c
      || .start_h+=_c;
         return(1)
      ?};
      _a+=1;
      _c-=_dt;
      {!
      |! {? .get_day(_a)=null()
         || return(0)
         ?};
         {? KAL_DEF.TYP='R'
         || {? *KAL_DEF.CZAS<_c
            || _c-=*KAL_DEF.CZAS
            |? *KAL_DEF.CZAS=_c
            || .set_sdh(_a,KAL_DEF.KONIEC);
               return(1)
            || .set_sdh(_a,KAL_DEF.POCZATEK+_c);
               return(1)
            ?}
         ?};
         _a+=1
      !}
   ",type_of(date()),type_of(time()),type_of(0)),

   obj_meth('wd_end',"
      {? ~.w_start(_a,_b) || return(0) ?};
      _dt:=(*(KAL_DEF.KONIEC-.start_h))/*KAL_DEF.CZAS;
      {? _dt>=_c
      || .start_h+=*KAL_DEF.CZAS*_dt;
         return(1)
      ?};
      _a+=1;
      _c-=_dt;
      {!
      |! {? .get_day(_a)=null()
         || return(0)
         ?};
         {? KAL_DEF.TYP='R'
         || {? _c>1
            || _c-=1
            |? _c=1
            || .set_sdh(_a,KAL_DEF.KONIEC);
               return(1)
            || _dt:=*KAL_DEF.CZAS*_c;
               .set_sdh(_a,KAL_DEF.POCZATEK+_dt);
               return(1)
            ?}
         ?};
         _a+=1
      !}
   ",type_of(date()),type_of(time()),type_of(0)),

   obj_meth('comment',"
      exec('comment','kalendarz',.,_a)
   ",type_of(date())),

:: Metoda ustawia/wymusza zmianę parametru 330 dla obiektu KAL bez zmiany ustawienia samego parametru
   obj_meth('set330',"
      .par330:=_a>0
   ",type_of(0)),

   obj_meth('rdat',"
      {? _a>_b || _a==_b ?};
      .f_year:=_a~1;.f_month:=_a~2;.f_day:=_a~3;
      .t_year:=_b~1;.t_month:=_b~2;.t_day:=_b~3;
      {? _a=date(0,0,0)
      || FUN.emsg('Błędny argument (zerowa data).'@); 0
      || .year:=.t_year-.f_year;
         .day:=0;

         {? .par330
:: Zgodnie z "potocznym", "naturalnym" pojmowaniem wyrażenia "rok pracy".
:: Okres oblicza się przy założeniu, że:
:: - nieprzerwany okres roku pracy upływa w przeddzień dnia odpowiadającego nazwie dnia początkowego
::   (rok to okres od 2005/10/10 do 2006/10/09)
:: - nieprzerwany okres miesiąca pracy upływa w dniu poprzedzającym dzień, który datą odpowiada początkowemu dniowi tego
::   okresu, a gdyby takiego dnia w takim miesiącu nie było - w ostatnim dniu tego miesiąca
::   (od 17 kwietnia do 16 maja; od 31 stycznia do 29 lutego)
         || .month:=.t_month-.f_month;
            {? .month<0 | (.month=0 & .year>0)
            || .year-=1;
               .month:=12+.month
            ?};
            {? .t_day=(.f_day-1)
::             dzień daty zakończenia jest o jeden mniejszy od daty rozpoczęcia więc są to pełne miesiące
            || .day:=0

            |? .t_day>(.f_day-1)
::             dzień daty zakończenia jest równy bądź większy od daty rozpoczęcia (pełne miesiące +)
            || _t_lmd:=.m_day(.t_year,.t_month);
               .day:=(.t_day-.f_day)+1;
               {? _t_lmd=.day
               || .day:=0;
                  .month+=1
               ?}

::             dzień daty zakończenia jest więcej niż o jeden mniejszy od daty rozpoczęcia (pełne miesiące -)
            || .month-=1;
::             ostatni dzień miesiąca
               _t_month:=.t_month-1;
               _t_year:=.t_year;
               {? _t_month<1 || _t_month:=12; _t_year-=1 ?};
               _t_lmd:=.m_day(_t_year,_t_month);
               _end_d:=.f_day-1;
::             jeżeli wyliczony dzień jest większy niż ostatni dzień miesiąca końcowego
               _lmd:=.m_day(.t_year,.t_month);
               {? _end_d>_lmd & _b~3=_lmd
               || .month+=1;
                  .day:=0
               || _end_d:={? _end_d>_t_lmd || _t_lmd || _end_d ?};
                  _end_fm:=date(.t_year,.t_month-1,_end_d);
                  .day:=#_b-#_end_fm
               ?}
            ?};
            {? .month>=12 || .month-=12; .year+=1 ?};
            1
:: Zgodnie z Kodeksem Cywilnym
         || {? (_b+1)~1<>.f_year & (_b+1)~2=.f_month & (_b+1)~3=.f_day
            || .year:=(_b+1)~1-.f_year;.month:=0;1
            || {? .year=0
               || .month:=.t_month-.f_month;
                  {? .month=0
                  || .day:=.t_day-.f_day+1;
                     {? .day=.m_day(.t_year,.t_month)
                     || .month:=1; .day:=0
                     ?}
                  || .set_dmy()
                  ?}
               || .year-=1;
                  .month:=12+.t_month-.f_month;
                  {? .month>=12 || .year+=1; .month-=12 ?};
                  .set_dmy()
               ?}; 1
            ?}
         ?}
      ?}
      ",type_of(date()),type_of(date())),

   obj_meth('leap',"
      (_a%*4=0 & _a%*100<>0) | (_a%*4=0 & _a%*100=0 & _a%*400=0)
      ",type_of(1)),

   obj_meth('m_day',"
      {? .leap(_a) || .m_d[2]:=29 || .m_d[2]:=28 ?};
      .m_d[_b]",type_of(1),type_of(1)),

   obj_meth('set_dmy',"
      {? .t_day=.m_day(.t_year,.t_month)
         || {? .f_day=1
               || .month+=1;
                  {? .month=12 || .year+=1; .month:=0 ?}
               || .day:=1+.m_day(.f_year,.f_month)-.f_day
            ?}
         ||  {? .f_day=1
               || .day:=.t_day
             |? .f_month=.t_month
               || {? .t_day=(.f_day-1)
                     || .month+=1;
                        {? .month=12 || .year+=1; .month:=0 ?}
                     || {? .f_day<=.t_day
                          || .day:=(.t_day-.f_day)+1
                          || .day:=(1+.m_day(.f_year,.f_month)-.f_day+.t_day);
                             {? .month=0 || .month:=11; .year-=1 || .month-=1 ?}
                        ?}
                  ?}
               || .day:=(1+.m_day(.f_year,.f_month)-.f_day+.t_day)-30;
                  {? .day<0 ||
                     {? .month=0 || .month:=11; .year-=1 || .month-=1 ?};
                     .day:=30+.day
            ?}    ?}
      ?}",-1,-1),


   obj_meth('sub_date',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Metoda wylicza datę o py lat, pm miesięcy i pd dni wcześniejszą niż dt. Parametry metody określające okres
::       (py/pm/pd) nie mogą być ujemne. Dodatkowo nieprawidłowym jest wywołanie z "zerowym" okresem
::       (py=0 & pm=0 & pd=0).
::       Poprawność działania metody można sprawdzić wykorzystując metodę rdat(). Jeżeli bowiem wynikiem
::       __KAL.sub_date(dt,py,pm,pd) jest dp, to po wywołaniu __KAL.rdat(dp,dt) pola
::       __KAL.year/__KAL.month/__KAL.day przyjmą wartości py/pm/pd.
::       Należy jednak pamiętać, że metody sub_date() nie można użyc do sprawdzenia poprawności działania metody rdat().
::       Przyczyną jest brak jednoznaczności w odwzorowaniu dat na różniący je przedział czasowy.
::       Przykład:
::             A  | __KAL.rdat(date(2014,06,30),date(2014,12,15)) -> 0/7/16
::             B1 | __KAL.rdat(date(2014,05,01),date(2014,12,15)) -> 0/7/15
::             B2 | __KAL.rdat(date(2014,05,02),date(2014,12,15)) -> 0/7/15
::             C  | __KAL.rdat(date(2014,05,03),date(2014,12,15)) -> 0/7/14
::          podczas gdy
::             C  | __KAL.sub_date(date(2014,12,15),0,7,14) -> date(2014,05,03)
::             B1 | __KAL.sub_date(date(2014,12,15),0,7,15) -> date(2014,05,01)
::             A  | __KAL.sub_date(date(2014,12,15),0,7,16) -> date(2014,06,30)
::   WE: _a    dt - Data.
::       _b    py - Lata.
::       _c    pm - Miesiące.
::       _d    pd - Dni.
::   WY: Dla poprawnych argumentów wywołania - data poprzedzająca dt o py lat, pm miesięcy i pd dni.
::       Dla niepoprawnych argumentów wywołania - data zerowa.
::----------------------------------------------------------------------------------------------------------------------
   "  _data:=_a;
      _lata:=_b;
      _mce:=_c;
      _dni:=_d;

      _d0:=date(0,0,0);
:     Weryfikacja wartości argumentów wywołania.
      _info:='Data: %1\nOkres: %2/%3/%4\n'@[_data$2,$_lata,$_mce,$_dni];
      _msg:=
         {? _data=_d0 || 'Błędny argument (zerowa składowa daty).'@
         |? _lata=0 & _mce=0 & _dni=0 || 'Błędny argument (zerowy okres).'@
         |? _lata<0 | _mce<0 | _dni<0 || 'Błędny argument (ujemne wartości okresu).'@
         || ''
         ?};
      {? _msg<>''
      || FUN.emsg(_info+_msg);
         return(_d0)
      ?};

:     Normalizacja wartości argumentów wywołania.
      _ldwm:={? .par330 || 30 || 29 ?};
      {? _dni>_ldwm || _mce+=_dni%30; _dni:=_dni%*30 ?};
      {? _mce>11 || _lata+=_mce%12; _mce:=_mce%*12 ?};

      _sr:=_data~1;
      _sm:=_data~2;
      _sd:=_data~3;
      _kmd:=.m_day(_sr,_sm);

      _sr-=_lata;
      _sm-=_mce;
      {? _sm<1 || _sm+=12; _sr-=1 ?};
      _km:=.m_day(_sr,_sm);

      {? .par330
      || {? _dni=0
::       jeżeli odejmujemy pełne lata lub miesiące i cofamy się od ostatniego dnia miesiąca, to kończymy na:
         || {? _sd=_kmd
            || {? _mce=0 & _km>_kmd
::             ostatnim dniu miesiąca jeżeli to były pełne lata
               || _sd:=0
::             pierwszym dniu następnego miesiąca
               || _sd:=1;
                  _sm+=1; {? _sm=13 || _sm:=1; _sr+=1 ?}
               ?}
::          jeżeli cofamy się od innego dnia niż ostatni dzień miesiąca
            || _sd+=1;
               {? _sd<1   || _sd+=31; _sm-=1; {? _sm=0 || _sm:=12; _sr-=1 ?} ?};
               {? _sd>_km || _sd:=1; _sm+=1; {? _sm=13 || _sm:=1; _sr+=1 ?} ?}
            ?}
::       jeżeli odejmujemy niepełne lata lub miesiące
         || {? _sd=_km & _sd=_dni
::          jeżeli dzień, od którego się cofamy jest również ostatnim dniem miesiąca w dacie początkowej i cofamy
::          się o liczbę dni równą liczbie dni tego miesiąca to cofamy się o jeden miesiąc
            || _sd:=0; _sm-=1; {? _sm=0 || _sm:=12; _sr-=1 ?}
::          w pozostałych przypadkach wyliczamy datę początkową odejmując najpierw liczbę dni (+1) a następnie
::          liczbę lat i miesięcy
            ||
               _data:=(_data-_dni)+1;
               _sr:=_data~1-_lata;
               _sm:=_data~2-_mce;
               {? _sm<1 || _sm+=12; _sr-=1 ?};
               _km:=.m_day(_sr,_sm);
               _sd:=_data~3;
               {? _sd>_km || _sd:=1; _sm+=1; {? _sm=13 || _sm:=1; _sr+=1 ?} ?}
            ?}
         ?}
      ||
         {? _mce=0 & _dni=0
:        Odejmujemy pelne lata.
         || _sd+=1;
            {? _sd>_km || _sd:=1; _sm+=1; {? _sm=13 || _sm:=1; _sr+=1 ?} ?}

         |? _sd=_kmd
:        Odejmujemy od konca miesiaca.
         || _sd:=_km-_dni+1;
            {? _sd<1 || _sd+=30; _sm-=1; {? _sm=0 || _sm:=12; _sr-=1 ?} ?};
            {? _sd>_km || _sd:=1; _sm+=1; {? _sm=13 || _sm:=1; _sr+=1 ?} ?}

         |? _sd<_dni
:        Odejmujemy wiecej dni niz jest w miesiacu.
         || _sm-=1;
            {? _sm=0 || _sm:=12; _sr-=1 ?};
            _km:=.m_day(_sr,_sm);
            _sd:=_sd-_dni+1+_km;
            {? _sd>_km || _sd:=1; _sm+=1; {? _sm=13 || _sm:=1; _sr+=1 ?} ?}

         |? _dni=_sd
:        Odejmujemy dni "b.m.".
         || _sd:=1

         |? _dni<_sd
         || _sd:=_sd-_dni+1+{? _mce || _km-30 ?};
            {? _sd>_km || _sd:=1; _sm+=1; {? _sm=13 || _sm:=1; _sr+=1 ?} ?}
         ?}
      ?};
      {? _sr<=0
      || FUN.emsg(_info+'Zbyt długi okres w stosunku do daty.'@);
         _d0
      || date(_sr,_sm,_sd)
      ?}
   ",type_of(date()),type_of(0),type_of(0),type_of(0)),


   obj_meth('filled',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51]
:: OPIS: Sprawdza czy ustawiony kalendarz ma wszystkie zapisy (na każdy dzień) w ramach badanych dat
::   WE: _a [DATE] - data od
::       _b [DATE] - data do
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
      _ret_val:=1;
      {! _ind:=#_a..#_b
      |? _ret_val
      |! _data:=#_ind;
         _ret_val:=.get_day(_data)<>null()
      !};
      _ret_val
   ",type_of(date),type_of(date)),


   obj_meth('no_err',
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Metoda ustawia / zwraca informację o fladze, która blokuje wyświetlanie komunikatów o błędach w metodzie
::       ErrMsg.
::       Metoda eliminuje dotychczasowe użycie zmiennej globalnej 'errorobl'.
::   WE: _a - Nowa wartość flagi (opcjonalnie):
::          1 - Prezentacja komunikatów będzie zablokowana.
::          0 - Prezentacja komunikatów nie będzie zablokowana.
::   WY: Dotychczasowa wartość flagi.
::----------------------------------------------------------------------------------------------------------------------
      "_a==.NO_ERR",type_of(0),-1),

   obj_meth('no_err',".NO_ERR",-1),


   obj_meth('ErrMsg',
   "  {? var_pres('_b')=type_of(0) & _b
      || return(0)
      ?};
      {? ~.NO_ERR & ~do_state()
      || _a:={? var_pres('_a')=type_of(0) || _a ?};
         FUN.emsg(
            {? .czesc
            || {? _a=3
               || 'Brak kalendarza częściowego na rok %1.'@[$.rok]
               || 'Brak kalendarza częściowego.'
               ?}
            || {? _a=3
               || 'Brak kalendarza %1 na rok %2.'@[.nazwa,$.rok]
               || 'Brak kalendarza %1.'@[.nazwa]
               ?}
            ?}
         )
      ?};
      0
   ")
)


\exist_c
::----------------------------------------------------------------------------------------------------------------------
::  UTW:
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_c:={? var_pres('_c')=type_of(null()) || _c || ~~ ?};
_exc:=(var_pres('_d')=type_of(0) & _d);

_test:="
   _off:=(var_pres('_b')=type_of(0) & _b);
   {? ~KAL_DEF.first || _a.ErrMsg(3,_off) || 1 ?}
";

exec('yearpres','kalendarz',_a,_b,_c,_test,_exc)


\yearpres
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS
:: OPIS: Sprawdza, czy istnieje definicja kalendarza na dany rok.
::  OLD: \yearpres/kalend.fml
::----------------------------------------------------------------------------------------------------------------------
_d:={? var_pres('_d')=type_of("") || _d || "1" ?};
_exc:=(var_pres('_e')=type_of(0) & _e);

_a.rok:=_b;
{? _a.nazwa=''
|| _a.ErrMsg()
|? _a.czesc & var_pres('_c')<>type_of(null())
|| _test:=1;
   R_WZCZ.cntx_psh();
   R_WZCZ.index('R_WZCZE');
   R_WZCZ.prefix(_a.kal_nazw);
   {? R_WZCZ.find_le(date(_b,12,0))
   || {!
      |? {? R_WZCZ.GRAFIK='T'
         || _test:=exec('yearpres','kalendarz',_a,_b,R_WZCZ.CZESC,_d,1)
         || _test:=exec('yearpres','kalendarz',_a,_b,R_WZCZ.KAL,_d)
         ?};
         (R_WZCZ.OD-1)~1=_b & R_WZCZ.prev()
      !}
   || _test:=_a.ErrMsg()
   ?};
   R_WZCZ.cntx_pop();
   _test

|| KAL_ROK.index('KAL_ROK');
   KAL_ROK.prefix({? var_pres('_c')=type_of(null()) || _c || _a.kal_nazw ?});
   {? KAL_ROK.find_key(_b)
   || KAL_DEF.index('KAL_DEF');
      KAL_DEF.prefix(KAL_ROK.ref());
      _a.kal_rok:=KAL_ROK.ref();
      _d(_a,_exc)
   || _a.ErrMsg(3,_exc)
   ?}
?}


\cnt_days
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS
:: OPIS: Zlicza dni określonego typu w podanym okresie.
::   WE: _a - wskazanie na obiekt klasy KALEND
::       _b - data początku okresu
::       _c - data końca okresu
::       _d - typ dnia
::       _e - (opcjonalny) wskazanie na kalendarz
::   WY: liczba dni
::  OLD: \cnt_days/kalend.fml
::----------------------------------------------------------------------------------------------------------------------
_ret_val:=0;
{? ~_a.FOUND
|| return(_ret_val)
?};

{? _b>_c
|| _b==_c
?};

{? _b~1<_c~1
|| _r:=_b~1;
   {!
   |? _r<=_c~1
   |! _ret_val+=
         {? _r=_b~1
         || _a.cnt_days(_b,date(_r,12,0),_d)
         |? _r=_c~1
         || _a.cnt_days(date(_r,1,1),_c,_d)
         || _a.cnt_days(date(_r,1,1),date(_r,12,0),_d)
         ?};
      _r+=1
   !}

|? _a.czesc & var_pres('_e')<>type_of(null())
|| R_WZCZ.cntx_psh();
   R_WZCZ.index('R_WZCZE');
   R_WZCZ.prefix(_a.kal_nazw);
   {? R_WZCZ.find_le(_c)
   || _do:=_c;
      _od:={? R_WZCZ.OD<=_b || _b || R_WZCZ.OD ?};
      {!
      |? {? R_WZCZ.GRAFIK='T'
         || {? exec('exist_c','kalendarz',_a,_od~1,R_WZCZ.CZESC,1)
            || _ret_val+=exec('cnt_days','kalendarz',_a,_od,_do,_d,R_WZCZ.CZESC)
            || _ret_val+=exec('cnt_days','kalendarz',_a,_od,_do,_d,R_WZCZ.KAL)
            ?}
         || _ret_val+=exec('cnt_days','kalendarz',_a,_od,_do,_d,R_WZCZ.KAL)
         ?};
         _rod:=R_WZCZ.OD;
         {? _b<_rod & R_WZCZ.prev() & (R_WZCZ.OD<_rod | R_WZCZ.prev())
         || _do:=_od-1;
            _od:={? R_WZCZ.OD<=_b || _b || R_WZCZ.OD ?};
            1
         ?}
      !}
   || _a.FOUND:=0
   ?};
   R_WZCZ.cntx_pop()

|| _get:=$('KAL_DEF.D'+_d);
   {? var_pres('_e')<>type_of(null())
   || _e:=~~
   ?};
   {? exec('day','kalendarz',_a,_b,_e)
   || _typ:=KAL_DEF.TYP;
      _drws:=_get();
      1
   || _a.FOUND:=0
   ?}
   &
   {? KAL_DEF.find_key(_c)
   || _ret_val+=_get()-_drws+(_typ=_d)
   || _a.FOUND:=0
   ?}
?};

_ret_val


\cnt_hour
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS
:: OPIS: Zlicza godziny robocze w podanym okresie.
::   WE: _a - wskazanie na obiekt klasy KALEND
::       _b - data początku okresu
::       _c - data końca okresu
::       _d - (opcjonalny) wskazanie na kalendarz
::       _e - większy od zera - pomijanie informacji o zatrudnieniu pracownika
::   WY: liczba godzin - wartość typu TIME
::  OLD: \cnt_hour/kalend.fml
::----------------------------------------------------------------------------------------------------------------------
_ret_val:=time(0,0,0);
{? ~_a.FOUND
|| return(_ret_val)
?};

{? _b>_c
|| _b==_c
?};

{? _b~1<_c~1
|| _r:=_b~1;
   {!
   |? _r<=_c~1
   |! _ret_val+=
         {? _r=_b~1
         || _a.cnt_hour(_b,date(_r,12,0),_e)
         |? _r=_c~1
         || _a.cnt_hour(date(_r,1,1),_c,_e)
         || _a.cnt_hour(date(_r,1,1),date(_r,12,0),_e)
         ?};
      _r+=1
   !}

|? _a.czesc & var_pres('_d')<>type_of(null())
|| R_WZCZ.cntx_psh();
   R_WZCZ.index('R_WZCZE');
   R_WZCZ.prefix(_a.kal_nazw);
   {? R_WZCZ.find_le(_c)
   || _do:=_c;
      _od:={? R_WZCZ.OD<=_b || _b || R_WZCZ.OD ?};
      {!
      |? {? ~_e & R_WZCZ.P<>null() &
            {? R_WZCZ.KIN='N'
            || R_WZCZ.GRAFIK='N'
            || R_WZCZ.GRAFIK='T' & ~exec('exist_c','kalendarz',_a,_od~1,R_WZCZ.CZESC,1)
            ?}
         || _zdate:=date(0,0,0);
            P.cntx_psh();
            H.cntx_psh();
            H.index('_HISTKOD');
            H.prefix(R_WZCZ.P,'Z');
            {? H.find_le(_do)
            || _cnt:=0;
               _org_h_od:=H.OD;
               _org_h_do:=H.DO;
               {!
               |? _hod:={? H.OD<_od | P.DZA=H.OD || _od || H.OD ?};
                  _hdo:=H.DO;
                  {? ~_cnt & (H.DO=_zdate | _do<H.DO | H.DO=H.P().DZ)
                  || _hdo:=_do
                  ?};
                  {? _hod<=_hdo
                  || _cnt+=1;
                     _h_wy:={? H.WYM<>0 || H.WYL/H.WYM || H.WY ?};
                     _ret_val+=*(*exec('cnt_hour','kalendarz',_a,_hod,_hdo,R_WZCZ.KAL,_e)*_h_wy);
                     _prev:=_b<>_c & H.prev();
:: jeżeli jesteśmy w transakcji to musimy sprawdzić czy nie mamy do czynienia z dodawaniem nowego rekordu w H
:: bo wtedy możemy się zapętlić (nakładanie się okresów - nowe H dodane a stare jeszcze nie zmienione)
                     {? _prev & do_state()=1
                     || {!
                        |? {? exec('is','overlap',H,_org_h_od,_org_h_do)
                           || _prev:=H.prev()
                           ?}
                        !}
                     ?};
                     _prev & _od<=H.DO
                  || _a.FOUND:=0
                  ?}
               !}
            |? H.first()
            || _h_wy:={? H.WYM<>0 || H.WYL/H.WYM || H.WY ?};
               _ret_val+=*(*exec('cnt_hour','kalendarz',_a,_od,_do,R_WZCZ.KAL,_e)*_h_wy)
            || _ret_val+=exec('cnt_hour','kalendarz',_a,_od,_do,R_WZCZ.KAL,_e)
            ?};
            H.cntx_pop();
            P.cntx_pop()
         || {? R_WZCZ.GRAFIK='T'
            || {? exec('exist_c','kalendarz',_a,_od~1,R_WZCZ.CZESC,1)
               || _ret_val+=exec('cnt_hour','kalendarz',_a,_od,_do,R_WZCZ.CZESC,_e)
               || _ret_val+=exec('cnt_hour','kalendarz',_a,_od,_do,R_WZCZ.KAL,_e)
               ?}
            || _ret_val+=exec('cnt_hour','kalendarz',_a,_od,_do,R_WZCZ.KAL,_e)
            ?}
         ?};
         _rod:=R_WZCZ.OD;
         {? _b<_rod & R_WZCZ.prev() & (R_WZCZ.OD<_rod | R_WZCZ.prev())
         || _do:=_od-1;
            _od:={? R_WZCZ.OD<=_b || _b || R_WZCZ.OD ?};
            1
         ?}
      !}
   || _a.FOUND:=0
   ?};
   R_WZCZ.cntx_pop()

|| {? var_pres('_d')<>type_of(null())
   || _d:=~~
   ?};
   {? exec('day','kalendarz',_a,_b,_d)
   || _czas:=KAL_DEF.CZAS;
      _gr:=KAL_DEF.GR;
      1
   || _a.FOUND:=0
   ?}
   &
   {? KAL_DEF.find_key(_c)
   || _ret_val+=KAL_DEF.GR-_gr+_czas;
      1
   || _a.FOUND:=0
   ?}
?};

_ret_val


\day
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS
:: OPIS: Wyszukuje zapis w tabeli KAL_DEF właściwy dla danego dnia.
::   WY: wskazanie na rekord w tabeli KAL_DEF lub null() jeśli rekordu nie udało się ustalić
::  OLD: \day/kalend.fml
::----------------------------------------------------------------------------------------------------------------------
_ret_val:=null();
{? ~_a.FOUND
|| return(_ret_val)
?};

{? _a.czesc & var_pres('_c')<>type_of(null())
|| R_WZCZ.cntx_psh();
   R_WZCZ.index('R_WZCZE');
   R_WZCZ.prefix(_a.kal_nazw);
   {? R_WZCZ.find_le(_b)
   || _grafik:=R_WZCZ.GRAFIK='T';
::    dla pracowników wyszukujemy czy nie jesteśmy w okresie grafikowania (pomijamy zapisy ukryte i odstępstwa)
      {? _a.nazwa*'pracowni'>0 & (1-_a.nazwa=$P.ref())
      || _grafik:=exec('grafik_rwzcz','kaledit',R_WZCZ.OD,P)
      ?};
      _ret_val:=exec('day','kalendarz',_a,_b,
                     {? R_WZCZ.KAL().CZESC='T' | (_grafik & _a.yearpres(_b~1))
                     || _a.kal_nazw
                     || R_WZCZ.KAL
                     ?}
                    )
   || _a.FOUND:=0
   ?};
   R_WZCZ.cntx_pop()

|| {? var_pres('_c')<>type_of(null())
   || _c:=_a.kal_nazw
   ?};
   KAL_DEF.index('KAL_DATA');
   KAL_DEF.prefix(_c,_b~1);
   {? KAL_DEF.find_key(_b)
   || _ret_val:=KAL_DEF.ref()
   || _a.FOUND:=0
   ?}
?};

_ret_val


\comment
::----------------------------------------------------------------------------------------------------------------------
::  UTW:
:: OPIS:
::   WE:
::   WY:
::  OLD: \comment/kalend.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a.get_day(_b) || KAL_DEF.OPIS || '' ?}


\dzienRob
::----------------------------------------------------------------------------------------------------------------------
::  UTW: BL  [8.50]
:: OPIS: Funkcja zwraca skorygowaną datę, np. terminu płatności będącą dniem roboczym.
::   WE: _a - data do zweryfikowania
::       _b - czy kontrolować dzień roboczy
::          =0 - nie sprawdzać
::          =1 - sprawdzać i zwracać dzień roboczy
::       Jeśli na liście parametrów nie ustawiony parametr nr 8
::          to WY = date(0,0,0)
::          wpp WY = data przypadająca w dzień roboczy
::       Jeśli, w aktywnym wzorcu brak definicji dla roku kalendarzowego, w którym zawierałaby się data
::          to WY= date(0,0,0)
::       _c - czy traktować dni wolne jako święta
::          =1 uwzględnia dni wolne
::          =0 wpp
::       _d - jaka data w przypadku braku kalendarzy
::          =1 - WY = _a
::          =0/brak - WY = date(0,0,0)
::       _e - dzień do sprawdzenia gdy _a dniem nie roboczym
::          >=0 - kolejny dzień
::          <0  - poprzedni dzień
::  WY: data
::  OLD: \dzienRob/kaledit.fml
::----------------------------------------------------------------------------------------------------------------------
{? _<4 || _d:=0; _e:=1 |? _<5 || _e:=1 ?};
_e:={? _e>=0 || 1 || -1 ?};
_wy:=date(0,0,0);
{? (_wzorzec:=exec('zn_wzor','kalendarz',PAR_SKID.get(8)))
|| {? _ & type_of(_a)=4 & _a<>date(0,0,0)
   || _wy:=_a;
      {? var_pres('_b')>0 & _b
      || {? exec('czyWolne','kalendarz',_wy,_wzorzec,(var_pres('_c')>0 & _c))
         || {! |? _wy+=_e; exec('czyWolne','kalendarz',_wy,_wzorzec,(var_pres('_c')>0 & _c)) !}
         ?}
      ?}
   ?}
?};
{? ~exec('jestOpis','kalendarz',_wzorzec,_wy~1) || _wy:=date(0,0,0) ?};
{? #_wy=0 & _d || _wy:=_a ?};
_wy


\czyWolne
::----------------------------------------------------------------------------------------------------------------------
::  UTW: BL  [8.50]
:: OPIS: Funkcja sprawdza czy dzień przekazany parametrem _a (data) jest dniem wolnym, tj. sobotą, niedzielą lub świętem
::       z listy świąt dla wzorca kalendarza przekazanego parametrem _b
::       Jeśli nie podano parametru _b, sprawdzone zostaną tylko soboty i niedziele
::       Wywołania: (dzienRob,kaledit)
::   WE: _a - data
::       _b - wzorzec kalendarza - nazwa (STRING) lub ref wzorca (REF)
::       _c - parametr traktowania dni wolnych jak dni świątecznych
::          =1 - Wolny=Świąteczny
::          =0 - Wolny=Roboczy
::   WY:
::  OLD: \czyWolne/kaledit.fml
::----------------------------------------------------------------------------------------------------------------------
_fiesta:={? _ & type_of(_a) = 4
         || _a~4=6 & _c  | _a~4=7
         || 1
         ?};
{? ~_fiesta & _>1
|| _wzorzec:={? type_of(_b) = 7
             || _b
             |? type_of(_b) = 2
             || exec('zn_wzor','kalendarz',_b)
             || 0
             ?};
   _rok:=_a~1;
   {? _wzorzec
   || KAL_OPIS.cntx_psh;
      KAL_OPIS.index('KAL_OPIS');
      KAL_OPIS.prefix(_wzorzec,_rok);
      _fiesta:=KAL_OPIS.find_tab('first','TYP',,'<>','R','DATA',,'=',_a$1);
      KAL_OPIS.cntx_pop
   ?}
?};
_fiesta


\jestOpis
::----------------------------------------------------------------------------------------------------------------------
::  UTW: BL  [8.50]
:: OPIS: Funkcja sprawdza czy podany wzorzec kalendarza ma opis na konkretny rok
::   WE: _a - wzorzec kalendarza
::       _b - nr roku kalendarzowego
::   WY: =1 - jest opis kalendarza
::       =0 - wpp
::  OLD: \jestOpis/kaledit.fml
::----------------------------------------------------------------------------------------------------------------------
_jestOpis:=0;
{? _
|| KAL_OPIS.cntx_psh;
   KAL_OPIS.index('KAL_OPIS');
   KAL_OPIS.prefix(_a,_b);
   _jestOpis:=KAL_OPIS.first();
   KAL_OPIS.cntx_pop
?};
_jestOpis


\zn_wzor
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS
:: OPIS: szuka wzorca kalendarza o podanej nazwie
::   WE: _a [STRING] - KAL_WZOR.NAZWA
::   WY: wskazanie na rekord w tabeli KAL_WZOR
::  OLD: \zn_wzor/kaledit.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('')
|| FUN.error('Błędny typ argumentu funkcji zn_wzor.'@);
   return(0)
|? |_a=''
|| return(0)
?};
_ret:=0;
KAL_WZOR.cntx_psh;
KAL_WZOR.index('KAL_WZOR');
KAL_WZOR.prefix(exec('ref_firma','ustawienia'));
{? KAL_WZOR.find_key(_a,_a)
|| _ret:=KAL_WZOR.ref
|? app_info('web_sesid')<>'' | do_state()=1 | FUN.ask('Wzorzec \'%1\' nie istnieje.\nCzy utworzyć nowy wzorzec?'@ [_a])
|| KAL_WZOR.blank();
   KAL_WZOR.NAZWA:=_a;
   {? KAL_WZOR.add(1)
   || _ret:=KAL_WZOR.ref()
   || FUN.emsg('Utworzenie wzorca nie powiodło się.'@)
   ?}
?};
KAL_WZOR.cntx_pop;
_ret


\WzKalPar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: BL [8.50]
:: OPIS: Funkcja kontrolująca zdefiniowanie zawartości kalendarza na lata objęte systemem.
::   WE: _a - nazwa (STRING) wzorca
::       _b - tabela lat (ROK lub ROK_F)
::  OLD: \WzKalPar/kaledit.fml
::----------------------------------------------------------------------------------------------------------------------
_wzorOK:=1;
_Alfa:=_Omega:=0;
_b.cntx_psh();
KAL_WZOR.cntx_psh();
KAL_WZOR.index('KAL_WZOR');
KAL_WZOR.prefix(exec('ref_firma','ustawienia'));
KAL_OPIS.cntx_psh();
KAL_OPIS.index('KAL_OPIS');
{? _b=ROK_F
|| _b.index('KOD')
|| _b.index('KOD')
?};
_b.clear();
_Alfa:={? _b.first || exec('kal_Rok','kalendarz',0) ?};
_Omega:={? _b.last || exec('kal_Rok','kalendarz',1) ?};
{? _Alfa & _Omega & _b.first()
|| {! |? _RokPocz:=exec('kal_Rok','kalendarz',0);
         _RokKonc:=exec('kal_Rok','kalendarz',1);
         {? KAL_WZOR.find_key(_a)
         || KAL_OPIS.prefix(KAL_WZOR.ref);
            {? ~KAL_OPIS.find_key(_RokPocz) & ~KAL_OPIS.find_key(_RokKonc)
            || _wzorOK:=0
            ?}
         ?};
         _wzorOK & _b.next
   !}
?};
{? ~_wzorOK
|| _wzorOK:=FUN.choice('Nie zredagowano wskazanego wzorca kalendarza'+
                       '\ndla wszystkich dostępnych w systemie okresów.'+
                       '\n\nZakres lat zdefiniowanych w systemie: '+$_Alfa+' - '+$_Omega,,
                       'Wybierz inny wzorzec','Uzupełnij dane automatycznie');
               {? _wzorOK
               || {! _i:=_Alfa.._Omega
                  |! _wzorOK:=exec('sel_opis','kalendarz',KAL_WZOR.ref,_i,-1)
                  !}
               ?}
?};
KAL_OPIS.cntx_pop();
KAL_WZOR.cntx_pop();
_b.cntx_pop();
_wzorOK


\kal_Rok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: BL [8.50]
:: OPIS: Funkcja znajduje rok z pierwszego/ostatniego okresu w roku bilansowym
::       UWAGA
::        Tabele, do których przekazywany jest alias, MUSZĄ mieć taką samą strukturę
::        (jest tak w istocie dla OKR (emag) i ROK_F, OKRO_F (fiks)
::         dotyczy również tabel OKRO i OKRO_F
::   WE: _a  - jaki okres 0 - pierwszy, 1 - ostatni
::   WY:  rok kalendarzowy (INTEGER)
::  OLD: \kal_Rok/kaledit.fml
::----------------------------------------------------------------------------------------------------------------------
_rokF:=ROK_F; _okres:=OKRO_F;
_rok:=0;
_rokF.cntx_psh();
_okres.cntx_psh();
_okres.index('ROK');
_rokF.clear();
_okres.prefix(ROK_F.ref,{? _a || _rokF.LOBR || 1 ?});
_rok:={? _okres.first()
      || {? _a || _okres.KON~1 || _okres.POCZ~1 ?}
      ?};
_rokF.cntx_pop();
_okres.cntx_pop();
_rok


\sel_opis
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS
:: OPIS: Redakcja wzorcy kalendarza
::   WE: _a - wskazanie na wzorzec
::       _b - rok kalendarzowy
::       _c - wyświetlenie okienka pozycji (opcjonalny typu INTEGER)
::       _d - ukrycie akcji następny i poprzedni w okienku pozycji (opcjonalny typu INTEGER)
::  OLD: \sel_opis/kaledit.fml
::----------------------------------------------------------------------------------------------------------------------
: wzorzec
KAL_WZOR.cntx_psh();
KAL_WZOR.index('KAL_WZOR');
KAL_WZOR.prefix(exec('ref_firma','ustawienia'));
{? var_pres('_a')<>type_of(null()) | _a=null() | ~KAL_WZOR.seek(_a)
|| FUN.error('Błędny argument _a formuły sel_opis.');
   KAL_WZOR.cntx_pop();
   return(0)
?};
: rok
{? var_pres('_b')<>type_of(0)
|| FUN.error('Błędny argument _b formuły sel_opis.');
   KAL_WZOR.cntx_pop();
   return(0)
?};
: wyświetlanie okienka pozycji wzorca
{? var_pres('_c')<0
|| _c:=0
|? var_pres('_c')<>type_of(0)
|| FUN.error('Błędny argument _c formuły sel_opis.');
   KAL_WZOR.cntx_pop();
   return(0)
?};
: wyłączenie akcji następny i poprzedni
{? var_pres('_d')=type_of(0) || _d:=_d<>0
|? var_pres('_d')<0 || _d:=0
|| FUN.error('Błędny argument _d formuły sel_opis.');
   KAL_WZOR.cntx_pop();
   return(0)
?};

KAL_OPIS.index('KAL_OPIS');
KAL_OPIS.prefix(_a,_b);
{? ~KAL_OPIS.first
:: ustawienie opisu kalendarza wg standardowego szablonu
|| exec('kal_opis_fill','kalendarz',_a,_b);
   {? _c=0
   || _c:=1
   ?}
?};
KAL_OPIS.first;
KAL_OPIS.hdr_sel;
KAL_OPIS.hdr_sel(' '+KAL_WZOR.NAZWA+' na rok '+$_b);
{? _c>0
|| {? _d
   || KAL_OPIS.select
   || KAL_OPIS.select(,,,'NZ')
   ?}
?};
KAL_WZOR.cntx_pop();
1


\kal_opis_fill
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.00]
::  MOD: MicKoc [22.26]
:: OPIS: Wypełnia tabelę KAL_OPIS zapisami na wskazany rok dla podanego wzorca
::   WE: _a [REFERENCE] - wskazanie na wzorzec kalendarza
::       _b [INTEGER]   - rok
::   WY: 0 lub liczba dodanych pozycji wzorca
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_wzorzec:={? var_pres('_a')=type_of(null)       || _a || return(_result) ?};
    _rok:={? var_pres('_b')=type_of(0) & (_b>0) || _b || return(_result) ?};

KAL_OPIS.cntx_psh();
KAL_OPIS.index('KAL_OPIS');
KAL_OPIS.prefix(_wzorzec);
_baza:={? KAL_OPIS.find_le(_rok) || KAL_OPIS.ROK ?};

_add:=$(
   "  KAL_OPIS.NUMER+=1;\n"+
   {? _baza
   || "  KAL_OPIS.cntx_psh();
         {? KAL_OPIS.NUMER<8 & KAL_OPIS.find_key("+$_baza+",KAL_OPIS.NUMER)
         || _b:=KAL_OPIS.OPIS;
            _d:=KAL_OPIS.TYP;
            _f:=KAL_OPIS.POCZATEK;
            _g:=KAL_OPIS.KONIEC;
            _h:=KAL_OPIS.CZAS;
            _i:=KAL_OPIS.DNI;
            _j:=KAL_OPIS.P_CZAS;
            _k:=KAL_OPIS.P_OD;
            _l:=KAL_OPIS.P_OD_ND
         ?};
         KAL_OPIS.cntx_pop();
      "
   || ""
   ?}+
   "  {? var_pres('_a')=type_of('')   || KAL_OPIS.DZIEŃ:=_a ?};
      {? var_pres('_b')=type_of('')   || KAL_OPIS.OPIS:=_b ?};
      {? var_pres('_c')=type_of('')   || KAL_OPIS.DATA:=_c ?};
      {? var_pres('_d')=type_of('')   || KAL_OPIS.TYP:=_d ?};
      {? var_pres('_e')=type_of('')   || KAL_OPIS.RODZAJ:=_e ?};
      {? var_pres('_f')=type_of(time) || KAL_OPIS.POCZATEK:=_f ?};
      {? var_pres('_g')=type_of(time) || KAL_OPIS.KONIEC:=_g ?};
      {? var_pres('_h')=type_of(time) || KAL_OPIS.CZAS:=_h ?};
      {? var_pres('_i')=type_of(0)    || KAL_OPIS.DNI:=_i ?};
      {? var_pres('_j')=type_of(time) || KAL_OPIS.P_CZAS:=_j ?};
      {? var_pres('_k')=type_of(time) || KAL_OPIS.P_OD:=_k ?};
      {? var_pres('_l')=type_of('')   || KAL_OPIS.P_OD_ND:=_l ?};
      KAL_OPIS.add(1)
   ");

: wartości domyślne opisu
KAL_OPIS.WZORZEC:=_wzorzec;
KAL_OPIS.ROK:=_rok;
KAL_OPIS.NUMER:=0;

_result+=_add('poniedziałek','',$_rok,'R','G',time(7,0,0),time(15,0,0),time(8,0,0),0,time(0,0,0),time(0,0,0),'N');
_result+=_add('wtorek');
_result+=_add('środa');
_result+=_add('czwartek');
_result+=_add('piątek');
_result+=_add('sobota','sobota',,'W','G',time(0,0,0),time(0,0,0),time(0,0,0));
_result+=_add('niedziela','niedziela',,'S','G');

_typ:='S';
_result+=_add('Nowy Rok','Nowy Rok',$date(_rok,1,1),_typ);

{? _rok>2010
|| _result+=_add('Trzech Króli','Święto Trzech Króli',$date(_rok,1,6),_typ)
?};
_wielkanoc:=exec('wielkan','kalendarz',_rok);
_result+=_add('Wielkanoc','Wielkanoc',$_wielkanoc,_typ);

_result+=_add('Wielkanoc','Wielkanoc (drugi dzień)',$(_wielkanoc+1),_typ);

_1_maja:=date(_rok,5,1);
_result+=_add('1 Maja','Święto pracy',$_1_maja,_typ);

_3_maja:=date(_rok,5,3);
_result+=_add('3 Maja','Konstytucji 3 Maja',$_3_maja,_typ);

_zielone_sw:=_wielkanoc+49;
_result+=_add('Zielone Świątki','Zesłanie Ducha Świętego',$(_zielone_sw),_typ);

_boze_cialo:=_wielkanoc+60;
_result+=_add('Boże Ciało','Boże Ciało',$(_boze_cialo),_typ);

_15_sierpnia:=date(_rok,8,15);
_result+=_add('15 Sierpnia','Wniebowzięcie N.M.P.',$_15_sierpnia,_typ);

_1_listopada:=date(_rok,11,1);
_result+=_add('1 Listopada','Wszystkich Świętych',$_1_listopada,_typ);

_11_listopada:=date(_rok,11,11);
_result+=_add('11 Listopada','Niepodległości',$_11_listopada);

:: jednorazowe święto z okazji 100-lecia niepodległości
{? _rok=2018
|| _add('12 Listopada','100-lecie Odzyskania Niepodległości',$date(_rok,11,12))
?};

_boze_narodzenie:=date(_rok,12,25);
_result+=_add('Boże Narodzenie','Boże Narodzenie',$_boze_narodzenie,_typ);
_result+=_add('Boże Narodzenie','Boże Narodzenie (drugi dzień)',$(_boze_narodzenie+1),_typ);

:: przepisanie ręczenie dodanych świąt ze wzorca roku bazowego
{? _baza
|| KAL_OPIS.index('STATUS');
   KAL_OPIS.prefix(_wzorzec,_baza,'R');
   {? KAL_OPIS.first()
   || {!
      |? _buffer:=exec('KAL_OPIS','buffer');
         _buffer.get();
         _data_sw:=exec('str2date','#convert',_buffer.DATA);

         _buffer.ROK:=_rok;
         _buffer.DATA:=$date(_rok,_data_sw~2,_data_sw~3);
         _result:=exec('add_to_kal_opis','kalendarz',_buffer);
         obj_del(_buffer);
         KAL_OPIS.next()
      !}
   ?}
?};

KAL_OPIS.cntx_pop();
:: aktualizacja informacji w obiekcie __KAL
__KAL.ws.dirty();

_result


\wielkan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS
:: OPIS: Zwraca datę Świąt Wielkiej Nocy w roku podanym argumentem
::   WE: _a - rok, dla którego ma być ustalona data Świąt
::   WY: data Świąt Wielkiej Nocy
::  OLD: \wielkan/kaledit.fml
::----------------------------------------------------------------------------------------------------------------------
_rok:=_a;
_A:=24;
_B:=5;
_a:=_rok%*19;
_b:=_rok%*4;
_c:=_rok%*7;
_d:=(_a*19+_A)%*30;
_e:=(2*_b+4*_c+6*_d+_B)%*7;
_wynik:=date(_rok,3,22)+_d+_e;
{? _d=29 & _e=6
|| _wynik:=date(_rok,4,26)
|? _d=28 & _e=6 & (11*_A+11)%*30 < 19
|| _wynik:=date(_rok,4,18)
?};
_wynik


\ws_create
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Tworzy obiekt nazwany do obsługi typów WS
::   WY: Obiekt
::----------------------------------------------------------------------------------------------------------------------
::pomysl jerrego do formatowania pol obiektu ;-)
::UWAGA: _fld, i _mth to formulki pomocnicze, zeby wygodniej tworzyc tablice i komentowac poszczegolne jej elementy
_fld:="31+form(_a)";
_mth:="31+form(_a)";
::tworze tablice nazwana do przechowywania zmiennych
_ws:=obj_new(
                _fld('wzorzec'  ,'wzorzec kalendarza standard')
               ,_fld('z_date'   ,'data zerowa')
               ,_fld('mod_time' ,'czas ostatniej modyfikacji tabeli KAL_OPIS')
               ,_fld('Tab'      ,'Tabela ze świętami dla wskazanego wzorca')
               ,_fld('chkRebuild','decyduje czy sprawdzać konieczność odbudowy')

::             metody PRYWATNE / TECHNICZNE
               ,_mth('init'     ,'Inicjuje obiekt')
               ,_mth('initTab'  ,'Zasila tabelę świąt z KAL_OPIS')
               ,_mth('rebuild'  ,'Sprawdza czy konieczna jest odbudowa tabeli tymczasowej')

::             metody PUBLICZNE
               ,_mth('holiday'  ,'Zwraca informację czy w danym dniu jest święto')
               ,_mth('opis'     ,'Zwraca opis święta')
               ,_mth('dirty'    ,'Informuje pozostałe obiekty o konieczności przebudowy tabeli')
             );
::usuwamy zbedne zmienne
&_mth; &_fld;

:: inicjowanie pól i metod
_ws.init:="
   .z_date:=date(0,0,0);
   .wzorzec:='standard';
   .chkRebuild:=1;
   .rebuild()
";

:: wczytujemy całą dziedzinę tabeli KAL_OPIS w celu przyspieszenia wyszukania dnia świątecznego
_ws.initTab:="
   {? var_pres('Tab',.)>100 || obj_del(.Tab) ?};
   _firma:=exec('ref_firma','ustawienia');
   _sql:=''+\"select KAL_WZOR.NAZWA as WZOR, KAL_OPIS.DATA, KAL_OPIS.OPIS from KAL_OPIS join KAL_WZOR
              where KAL_WZOR.FIRMA=:_a and CHAR_LENGTH(KAL_OPIS.DATA)=10
              order by WZOR, DATA\";
   .Tab:=sql(_sql,_firma)
";

:: metoda odpisuje do tabeli BLK informację o konieczności odbudowy danych w obiekcie
_ws.dirty:="
   exec('last_mod_set','#table',KAL_OPIS)
";

:: metoda sprawdza czy konieczna jest odbudowa tabeli tymczasowej obiektu
_ws.rebuild:="
   {? .chkRebuild
   || _lm:=exec('last_mod_get','#table',KAL_OPIS);
      {? .mod_time<_lm
      || .mod_time:=_lm;
         .initTab()
      ?}
   ?}
";

:: metoda zwraca informacje czy w podanym dniu jest święto
_ws.holiday:="
      _data:={? var_pres('_a')=4 || _a || return(0) ?};
   _wzorzec:={? var_pres('_b')=2 || _b || .wzorzec  ?};
   .rebuild();
   .Tab.prefix(_wzorzec,$_data);
   .Tab.first()
";

:: metoda zwraca opis dnia
_ws.opis:="
   _result:='';
      _data:={? var_pres('_a')=4 || _a || return(0) ?};
   _wzorzec:={? var_pres('_b')=2 || _b || .wzorzec  ?};
   .rebuild();
   .Tab.prefix(_wzorzec,$_data);
   {? .Tab.first()
   || _result:=.Tab.OPIS
   ?};
   _result
";

_ws.init();
_ws


\add_to_kal_opis
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [18.42]
:: OPIS: Dodaje zapis do tabeli KAL_OPIS
::   WE: _a [DICT] - objekt buforowy dla tabeli KAL_OPIS
::   WY: -1 - błędny typ parametru wejściowego
::       -2 - rekord już występuje w tabeli
::        0 - nie udało się dodać rekordu
::        1 - dodano rekord
::----------------------------------------------------------------------------------------------------------------------
_result:=-1;
  _buffer:={? var_pres('_a')=117 || _a || return(_result) ?};
_result:=0;

KAL_OPIS.cntx_psh();
KAL_OPIS.index('KAL_OPIS');
KAL_OPIS.prefix(_buffer.WZORZEC,_buffer.ROK);
{? KAL_OPIS.last()
|| _data_sw:=exec('str2date','#convert',_buffer.DATA);
:: sprawdzenie czy było już to święto w danych
   _brak_sw:=1;
   {!
   |? {? KAL_OPIS.NUMER>7 & _data_sw=exec('str2date','#convert',KAL_OPIS.DATA)
::    jest już w KAL_OPISie zdefiniowane święto na tą datę
      || _brak_sw:=0
      ?};
      _brak_sw & KAL_OPIS.prev()
   !};

:: dodaj święto jeśli nie było go we wzorcu
   {? _brak_sw
   || _mydo:=do_state()=0;
::    zalozenie transakcji
      {? _mydo || do() ?};
      KAL_OPIS.last();
      {!
      |? _data:=exec('str2date','#convert',form(KAL_OPIS.DATA));
         {? KAL_OPIS.NUMER>7 & _data>_data_sw
::          święta przypadające po dacie przekazanego święta - trzeba zrobić miejsce i przesunąć numerację
         || KAL_OPIS.NUMER:=KAL_OPIS.NUMER+1;
            KAL_OPIS.put()
         |? KAL_OPIS.NUMER>=7 & _data<_data_sw
         || _nr:=KAL_OPIS.NUMER;
            KAL_OPIS.blank(1);
            _buffer.set();
            KAL_OPIS.NUMER:=_nr+1;
            _result:=KAL_OPIS.add(1);
            {? _result || _brak_sw:=0 ?}
         ?};
         _brak_sw & KAL_OPIS.prev()
      !};

      {? _mydo || end() ?}
   || _result:=-2
   ?}
?};
KAL_OPIS.cntx_pop();
_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:38 da8980cd56517cd34609aa0516654fe9b7938a3f7d9486afe0a0300dada6bc0ad5a8330e3402808606d4fe7887514f347fc114e426895bb395474cd3e33d3a5b0a615b9b492e89cb0d9bc97a4d0a9ba08c3e808c0c0d61f19fbdc9a84bc23c9e38c3afdc3616236463eeeb52ae84479305081972d81c6934c12cc643502eaa2c
