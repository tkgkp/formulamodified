:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: plan_kal.fml [2011]
:: Utworzony: 2011/08/22
:: Autor: TMR
::======================================================================================================================
:: Zawartość: Formuły do obsługi współpracy systemem PORTAL.
::======================================================================================================================


\find_okr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Wyszukuje czy pracownik w danym dniu kalendarzowym jest przypięty do okresu rozliczeniowego.
::   WE: _a - ref pracownika
::       _b - data kontroli
::       _c - co ma być zwracane 'okr' (ref A_OKR) / 'okrp' (ref A_OKRP)
::   WY: A_OKR.ref lub A_OKRP.ref lub null
::  OLD: \find_okr/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null()) || return(0) ?};
{? var_pres('_b')<>type_of(date()) || return(0) ?};
{? var_pres('_c')<>type_of('') | (_c<>'okr' & _c<>'okrp') || return(0) ?};
_ref:=null();
_dalej:=1;
A_OKR.cntx_psh();
A_OKRP.cntx_psh();
A_OKRP.use('x_okrpi');
A_OKRP.index('A_OKRDP');
A_OKRP.prefix(_a);
{? A_OKRP.find_le(_b) | A_OKRP.first()
|| {!
   |? {? (_b>=A_OKRP.OD) & (_b<=A_OKRP.DO) & (_b>=A_OKRP.OKR().OD) & (_b<=A_OKR.DO)
      || {? _c='okr'
         || _ref:=A_OKRP.OKR
         |? _c='okrp'
         || _ref:=A_OKRP.ref()
         ?};
         _dalej:=0
      ?};
      _dalej & A_OKRP.next()
   !}
?};
A_OKRP.cntx_pop();
A_OKR.cntx_pop();
_ref


\pocz_okr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Zwraca początek lub koniec okresu rozliczeniowego dla pracownika (domyślnie początek).
::   WE: _a - P.ref
::       _b - data kontroli
::       _c - co ma być zwracane - data poczatkowa czy data koncowa (0 - pocz, 1 - kon)
::   WY: data OD  lub data zerowa
::  OLD: \pocz_okr/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_ret_val:=date(0,0,0);
{? var_pres('_a')<>type_of(null()) || return(_ret_val) ?};
{? var_pres('_b')<>type_of(date()) || return(_ret_val) ?};
_c:={? var_pres('_c')=type_of(0) || _c=1 ?};
:: Wyszukaj okres rozliczeniowy pracownika na dany dzień
_okrp_ref:=exec('find_okr','grafik',_a,_b,'okrp');
{? _okrp_ref<>null()
|| A_OKRP.cntx_psh();
   A_OKRP.use('x_okrpi');
   A_OKRP.index('A_OKPP');
   A_OKRP.prefix();
   {? A_OKRP.seek(_okrp_ref)
   || {? _c
      || _ret_val:=A_OKRP.DO
      || _ret_val:=A_OKRP.OD
      ?}
   ?};
   A_OKRP.cntx_pop()
?};
_ret_val


\kon_okr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Funkcja zwraca koniec okresu rozliczeniowego dla pracownika.
::   WE: _a - P.ref
::       _b - data kontroli
::   WY: data DO  lub data zerowa
::  OLD: \kon_okr/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_ret_val:=date(0,0,0);
{? var_pres('_a')<>type_of(null()) || return(_ret_val) ?};
{? var_pres('_b')<>type_of(date()) || return(_ret_val) ?};
exec('pocz_okr','grafik',_a,_b,1)


\usun_ods
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Usuwa odstępstwa od wzorca czasu pracy od podanego dnia.
::   WE: _a - P.ref
::       _b - data od
::  OLD: \usun_ods/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
R_WZCZ.cntx_psh();
R_WZCZ.index('R_WZWND');
R_WZCZ.prefix(form(8+$_a),#_a,'T','N');
{? R_WZCZ.find_ge(_b)
|| {! |? R_WZCZ.del(,1) = 2 !}
?};
R_WZCZ.cntx_pop()


\get_graf_wzor
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Pobiera nazwę kalendarza użytego jako wzór do tworzenia grafiku.
::   WE: _a - P.ref
::       _b - data sprawdzania
::   WY: 0 lub 1
::  OLD: \get_graf_wzor/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null()) || return('') ?};
{? var_pres('_b')<>type_of(date()) || return('') ?};
_ret_val:='';
_od:=_b;
{? _od=date(0,0,0) || return('') ?};
R_WZCZ.cntx_psh();
R_WZCZ.index('R_WZWND');
R_WZCZ.prefix(form(8+$_a),#_a,'N','N');
{? R_WZCZ.find_le(_od)
|| _ret_val:=R_WZCZ.KAL().NAZWA
?};
R_WZCZ.cntx_pop();
_ret_val


\new_grafik
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Tworzy kalendarz indywidualny (grafik) dla pracownika w R_WZCZ
::   WE: _a [REFERENCE] - P.ref
::       _b [DATE]      - data od
::   WY: 1 (udalo sie utworzyc) lub 0 ( nie udalo sie )
::  OLD: \new_grafik/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null()) || return(0) ?};
{? var_pres('_b')<>type_of(date()) || return(0) ?};
_od:=exec('pocz_okr','grafik',_a,_b);
_do:=exec('kon_okr','grafik',_a,_b);
{? _od=date(0,0,0) | _do=date(0,0,0) || return(0) ?};

R_WZCZ.cntx_psh();
R_WZCZ.index('R_WZWND');
exec('dod_kal_czesc','kaledit',P);
:: Sprawdź jaki ostatnio byl kalendarz
_kal_naz:=null();
_od_iden:=0;
R_WZCZ.prefix(form(8+$_a),#_a,'N','N');
{? R_WZCZ.find_le(_od)
|| _kal_naz:=R_WZCZ.KAL;
   _kal_cz:=R_WZCZ.CZESC;
   _kin:=R_WZCZ.KIN;
   _od_iden:={? R_WZCZ.OD=_od || 1 || 0 ?}
?};

_ok:=0;
{? _kal_naz<>null()
|| exec('usun_ukr','kaledit',P);
   R_WZCZ.blank();
   R_WZCZ.P:=P.ref();
   R_WZCZ.MASKA:=P.name();
   R_WZCZ.REKORD:=#P.ref();
   R_WZCZ.OD:=_od;
   R_WZCZ.KAL:=_kal_naz;
   R_WZCZ.CZESC:=_kal_cz;
   R_WZCZ.GRAFIK:='T';
   R_WZCZ.KIN:=_kin;
   R_WZCZ.cntx_psh();
   R_WZCZ.prefix();
   _ok:={? _od_iden || R_WZCZ.put() || R_WZCZ.add() ?};
   R_WZCZ.cntx_pop();

   {? _ok
   || R_WZCZ.cntx_psh();
::    Wszystkie zapisy R_WZCZ w okresie rozliczeniowym pracownika ustawiamy jako grafik
      {? R_WZCZ.next()
      || {!
         |? {? R_WZCZ.GRAFIK<>'T' & R_WZCZ.OD>=_od & R_WZCZ.OD<=_do
            || R_WZCZ.GRAFIK:='T';
               R_WZCZ.put()
            ?};
            R_WZCZ.next()
         !}
      ?};
      R_WZCZ.cntx_pop();
      exec('usun_ods','grafik',_a,_od)
   ?};
   exec('norm_kal','kaledit',P)
?};
R_WZCZ.cntx_pop();
_ok


\jest_grafik
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Sprawdza czy pracownik ma kalendarz indywidualny (grafik).
::   WE: _a -P.ref
::       _b - data sprawdzania
::   WY: 0 lub 1
::  OLD: \jest_grafik/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null()) || return(0) ?};
{? var_pres('_b')<>type_of(date()) || return(0) ?};
_ret_val:=0;
_od:=exec('pocz_okr','grafik',_a,_b);
{? _od=date(0,0,0) || _od:=_b ?};
R_WZCZ.cntx_psh();
R_WZCZ.index('R_WZWND');
R_WZCZ.prefix(form(8+$_a),#_a,'N','N');
{? R_WZCZ.find_le(_od)
|| _ret_val:=R_WZCZ.GRAFIK='T'
?};
R_WZCZ.cntx_pop();
_ret_val


\jest_grafik_rok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Wyszukuje na dany dzien kalendarzowy kal_rok
::   WE: _a - ref pracownika
::       _b - data kontroli
::       [_c] - czy w przypadku braku kalendarza typu grafik, dodac taki kalendarz (domyslnie tak(1))
::   WY: ref do kal_rok lub null
::  OLD: \jest_grafik_rok/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_kal_rok:=null();
{? var_pres('_a')<>type_of(null) || return(_kal_rok) ?};
{? var_pres('_b')<>type_of(date) || return(_kal_rok) ?};
_czyDod:={? var_pres('_c')<>type_of(0) || 1 || _c ?};
P.cntx_psh();
P.clear();
_dzien:=_b;
{? P.seek(_a)
|| _jest_grafik:=exec('jest_grafik','grafik',P.ref(),_dzien);
   {? _jest_grafik
   || _graf_wzor:=exec('get_graf_wzor','grafik',P.ref(),_dzien);
      _kal_rok:=exec('jest_rok','kaledit',P.KAL,_dzien,_graf_wzor)
   || {? _czyDod
      || _nowy_grafik:=exec('new_grafik','grafik',P.ref(),_dzien);
         {? _nowy_grafik
         || _graf_wzor:=exec('get_graf_wzor','grafik',P.ref(),_dzien);
             _kal_rok:=exec('jest_rok','kaledit',P.KAL,_dzien,_graf_wzor)
         ?}
      ?}
   ?}
?};
P.cntx_pop();
_kal_rok


\getPlanStat4Pr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja zwracająca status planowania dla pracownika na podaną datę.
::   WE: _a [REFERENCE] - wskazanie pracownika
::       _b [DATE]      - data badania
::      [_c][REFERENCE] - wskazanie na pracownika w okresie rozliczeniowym
::   WY:    [STRING]    - status planowania
::  OLD: \getPlanStat4Pr/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')=type_of(null()) || _a || return('') ?};
 _data:={? var_pres('_b')=type_of(date()) || _b || return('') ?};

_okrp_ref:={? var_pres('_c')=type_of(null())
           || _c
           || exec('find_okr','grafik',_p_ref,_data,'okrp')
           ?};
_status:='';
{? _okrp_ref<>null()
|| _status:=exec('getStatusM_Plan','okres',_okrp_ref,_data~1,_data~2);
   {? _status=''
   || _status:=exec('getMscPlanStat','okres',_data~1,_data~2)
   ?};
:: Jeżeli nie ma wgranej aktualizacji planowania na miesiące to sprawdź status planowania pracownika w okresie.
   {? _status=''
   || A_OKRP.cntx_psh();
      A_OKRP.use('x_okrpi');
      A_OKRP.index('A_OKPP');
      A_OKRP.prefix();
      {? A_OKRP.seek(_okrp_ref)
      || _status:=A_OKRP.S_PLAN
      ?};
      A_OKRP.cntx_pop()
   ?}
?};
_status


\r_wzcz4kal_nazw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Zwraca liste wzorczow czasu pracy dla wskazanego rekordu KAL_NAZW
::   WE: _a - [REFERENCE] - wskazanie na KAL_NAZW
::   WY: tabela tymczasowa ze wzorcami czasu pracy
::  OLD: \r_wzcz4kal_nazw/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_kal_nazw:={? var_pres('_a')=type_of(null) || _a || null() ?};

_sql:=''+"select * from @R_WZCZ where R_WZCZ.KAL=:_a";

sql(_sql,_kal_nazw)


\aktKalNorm4Plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Aktualizuje pole KAL_BUFF.GR, które pracuje jako norma kalendarza (KAL_NAZW.NORMA)
::       UWAGA!!! formuła wykorzystywana w triggerze
::   WE: _a - [REFERENCE] - wskazanie na KAL_NAZW
::   WY: 0 lub liczba zaktualizowanych KAL_BUFFów
::  OLD: \aktKalNorm4Plan/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_kal_nazw:={? var_pres('_a')=type_of(null) || _a || return(_result) ?};
{? ref_name(_kal_nazw)<>'kal_nazw' || return(_result) ?};

KAL_NAZW.cntx_psh();
KAL_NAZW.prefix();
{? KAL_NAZW.seek(_kal_nazw)
||
   _tab:=exec('r_wzcz4kal_nazw','grafik',_kal_nazw);
   _size:=_tab.size();
   _loop:=0;
   {? _tab.first()
   || OSOBA.cntx_psh(); P.cntx_psh(); P.index('PRACOIP');
      P.prefix(exec('firma','ustawienia'));
      PROGRESS.set(_size,'Trwa aktualizacja buforów planowania pracowników...');
      {!
      |? {? (_tab.CZESC<>_tab.KAL & _tab.UKRYTY<>'T') & P.seek(BIT.sqlint(_tab.P),)
         || _p_ref:=P.ref();
            _loop+=1;
            echo('Trwa aktualizacja buforów planowania pracowników ('+$_loop+'/'+$_size+')',
                 P.OSOBA().NAZWISKO + ' '+OSOBA.PIERWSZE);

            _result:=exec('aktKalNorm4Prac','grafik',_p_ref,_tab.OD)
         ?};
         PROGRESS.next();
         _tab.next()
      !};
      PROGRESS.close();echo();
      P.cntx_pop(); OSOBA.cntx_pop()
   ?}
?};
KAL_NAZW.cntx_pop();
_result


\aktKalNorm4Prac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Aktualizuje pole KAL_BUFF.GR, które pracuje jako norma kalendarza (KAL_NAZW.NORMA)
::       UWAGA!!! formuła wykorzystywana w triggerze
::   WE: _a  - [REFERENCE] - wskazanie na pracownika
::       _b  - [DATE]      - data od
::      [_c] - [NUMBER]    - tylko aktualizuj normę dla otwartych okresów rozliczeniowych pracownika od wskazanej daty
::                           (domyślnie 0)
::   WY: 0 lub liczba zaktualizowanych KAL_BUFFów
::  OLD: \aktKalNorm4Prac/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
  _p_ref:={? var_pres('_a')=type_of(null) || _a || return(_result) ?};
_data_od:={? var_pres('_b')=type_of(date) || _b || return(_result) ?};
_onlyAkt:={? var_pres('_c')=type_of(0)    || _c || 0               ?};

:: pobieram wszystkie okresy pracownika od wskazanej daty otwarte do planowania
_t_okrp:=exec('getOkrpFromDate','grafik',_p_ref,_data_od,,,'O',,'OD');

_end:=date(date~1,12,0);
_okrp_od:=_end;
{? _t_okrp.first()
|| _okrp_od:=_t_okrp.OD;
   _t_okrp.last();
   {? _t_okrp.DO>_end || _end:=_t_okrp.DO ?}
?};

P.cntx_psh();
P.index('PRACOIP');
P.prefix(exec('firma','ustawienia'));
{? P.seek(_p_ref) & _t_okrp.size()>0
|| _od:={? P.DZA<_data_od || _data_od || P.DZA ?};
   _od:={? _okrp_od<_od || _od || _okrp_od ?};
   _do:={? P.DZ=date(0,0,0) || _end || P.DZ ?};
   _statusM:='';
   _rok:=0;
   _msc:=0;

   KAL_BUFF.cntx_psh();
   KAL_BUFF.index('PRACDATA');
   KAL_BUFF.prefix(_p_ref);
:: wstępnie sprawdzamy czy wogóle coś jest w badanym zakresie
   {? ~_onlyAkt & KAL_BUFF.find_ge(_od)
   || {! _nr:=#_od..#_do
      |! _data:=#_nr;
         KAL_BUFF.prefix(_p_ref,_data);
         {? KAL_BUFF.first()
         || {? _data~1<>_rok | _data~2<>_msc | _statusM=''
            || _statusM:=exec('getPlanStat4Pr','grafik',_p_ref,_data);
               _rok:=_data~1;
               _msc:=_data~2
            ?};
            {? _statusM<>'Z'
            || _gr:=exec('get_kal_norm','grafik',_p_ref,_data);
               {!
               |? KAL_BUFF.GR:=_gr;
                  _result+=KAL_BUFF.put();
                  KAL_BUFF.next()
               !}
            ?}
         ?}
      !}
   ?};
   KAL_BUFF.cntx_pop();
:: uaktualniamy warości wymiaru dla pobranych okresów rozliczniowych
   R_WZCZ.cntx_psh();
   {? _t_okrp.first()
   || exec('__HARM','object');
      exec('__RUB','object');
      exec('MASK','object');
      exec('__KAL','object');
      A_OKRP.cntx_psh();
      A_OKRP.use('x_okrpi');
      A_OKRP.index('A_OKRDP');
      A_OKRP.prefix();
      {!
      |? {? A_OKRP.seek(_t_okrp.NR, _t_okrp.MASK)
         || exec('oblicz','okres',0,,,_t_okrp.OD,_t_okrp.DO)
         ?};
         _t_okrp.next()
      !};
      A_OKRP.cntx_pop()
   ?};
   R_WZCZ.cntx_pop()
?};
P.cntx_pop();
_result


\trig_aktKalNorm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Formula na trigger do aktualizacji pola KAL_BUFF.GR, które pracuje jako norma kalendarza (KAL_NAZW.NORMA)
::       Wykorzystywana w triggerze dla tabeli R_WZCZ
::   WE: _a - [STRING] - akcja
::  OLD: \trig_aktKalNorm/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=~~;
_akcja:={? var_pres('_a')=type_of('') || _a || return(_result) ?};

:: nie aktualizujemy jeżeli mamy ustawioną zmienną TRIG_OFF oraz dla zapisów ukrytych i dla kalendarza odstępstw
{? TRIG_OFF.KAL_BUFF='T'
|| return(_result)
?};
{? R_WZCZ.CZESC=R_WZCZ.KAL | R_WZCZ.UKRYTY='T'
|| return(_result)
?};

{? R_WZCZ.P<>null() & (_akcja='add' | _akcja='del' |
   (_akcja='put' & (R_WZCZ.KAL<>bfld('KAL') | R_WZCZ.OD<>bfld('OD'))))
|| _lic_por:=exec('lic','#b_domain','POR');
   _upd_graf:=exec('get_par','#parametr',282);
   _normaOld:=_normaNew:=0;
   _kalOld:=_kalNew:=R_WZCZ.KAL;
   _aktOd:=_aktDo:=R_WZCZ.OD;
   {? _akcja='put'
   || _aktOd:={? R_WZCZ.OD<bfld('OD') || R_WZCZ.OD || bfld('OD') ?};
      _aktDo:={? bfld('OD')>_aktOd || bfld('OD') || _aktOd ?};
      _aktDo:={? R_WZCZ.OD>_aktDo || R_WZCZ.OD || _aktDo ?}
   ?};
   KAL_NAZW.cntx_psh();
   KAL_NAZW.prefix();
   {? (_akcja='put' | _akcja='del') & KAL_NAZW.seek(bfld('KAL'))
   || _normaOld:=KAL_NAZW.NORMA;
      _kalOld:=KAL_NAZW.ref();
      {? _akcja='del'
      || R_WZCZ.cntx_psh();
         R_WZCZ.index('R_WZWND');
         R_WZCZ.prefix(bfld('MASKA'),bfld('REKORD'),'N','N');
         {? R_WZCZ.find_le(bfld('OD'))
         || _normaNew:=R_WZCZ.KAL().NORMA;
            _aktOd:=R_WZCZ.OD;
            {? _lic_por
            || {? R_WZCZ.next()
               || _aktDo:=R_WZCZ.OD-1
               || KAL_ROK.cntx_psh();
                  KAL_ROK.index('KAL_ROK');
                  KAL_ROK.prefix(R_WZCZ.KAL);
                  {? KAL_ROK.last() || _aktDo:=date(KAL_ROK.ROK,12,31) ?};
                  KAL_ROK.cntx_pop()
               ?}
            ?}
         ?};
         R_WZCZ.cntx_pop()
      || _normaNew:=R_WZCZ.KAL().NORMA
      ?}
   |? _akcja='add'
   || _normaNew:=R_WZCZ.KAL().NORMA
   ?};
   KAL_NAZW.cntx_pop();

   {? _normaNew<>_normaOld | (_akcja='put' &  R_WZCZ.OD<>bfld('OD')) | _akcja='del'
   || exec('aktKalNorm4Prac','grafik',R_WZCZ.P,_aktOd)
   ?};

:: synchronizacja kalendarzy PKALSYNC
   {? _lic_por
   || _p_ref:=R_WZCZ.P;
      {? _akcja='add' | (_akcja='put' & (_kalOld<>_kalNew | R_WZCZ.OD<>bfld('OD')))
      || _ref:=R_WZCZ.ref();
         _maska:=R_WZCZ.MASKA;
         _rekord:=R_WZCZ.REKORD;
         _old_od:={? _akcja='add' || R_WZCZ.OD || bfld('OD') ?};
         _jest:=0;
         R_WZCZ.cntx_psh();
         R_WZCZ.index('R_WZWND');
         R_WZCZ.prefix(_maska,_rekord,'N','N');
         {? R_WZCZ.seek(_ref) & R_WZCZ.next()
         || {!
            |? {? _old_od>R_WZCZ.OD
               || _jest:=R_WZCZ.next()
               || _jest:=1; 0
               ?}
            !};
            _aktDo:=R_WZCZ.OD-1
         ?};
         {? ~_jest
         || KAL_ROK.cntx_psh();
            KAL_ROK.index('KAL_ROK');
            KAL_ROK.prefix(R_WZCZ.KAL);
::          aktualizujemy tylko dla założonych lat kalendarza, jeżeli nie ma jeszcze założonego roku a dodajemy
::          zapis w R_WZCZ dla tego roku, to aktualizacja zostanie wykonana podczas dodawania brakującego roku
            {? KAL_ROK.last() || _aktDo:=date(KAL_ROK.ROK,12,31) ?};
            KAL_ROK.cntx_pop()
         ?};
         R_WZCZ.cntx_pop()
      |? _akcja='del'
      || _p_ref:=bfld('P')
      ?};
      {? _aktDo>=_aktOd || exec('update_od_do','pkalsync',_p_ref,_aktOd,_aktDo) ?}
   ?}
?};
_result


\trigKalUpd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Triger KAL_DEF dotyczący aktualizacji KAL_BUFFa - obsługa.
::   WE: _a - Wskazanie pracownika (P.ref()).
::       _b - Wskazanie dnia kalendarza (KAL_DEF.ref()).
::       [_c] - Uwzględnienie wniosków o nadgodziny [1/0-domyślnie]
::  OLD: \trigKalUpd/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
  _p_ref:={? var_pres('_a')=type_of(null()) || _a || null() ?};
_kal_def:={? var_pres('_b')=type_of(null()) || _b || null() ?};
_wn_nadg:={? var_pres('_c')=type_of(0)      || _c || 0      ?};
_przerwy:=exec('isEnabled','prc_przerwy');
KAL_DEF.cntx_psh();
KAL_DEF.prefix();
{? KAL_DEF.seek(_kal_def)
|| _data:=KAL_DEF.DATA;
   P.cntx_psh();
   OSOBA.cntx_psh();
   KAL_BUFF.cntx_psh();
   KAL_BUFF.index('PRACDATA');
   KAL_BUFF.prefix(_p_ref,_data);
   {? KAL_BUFF.first()
   || _status:=exec('getPlanStat4Pr','grafik',_p_ref,_data);
      {? _status<>'Z'
      || {!
         |? KAL_BUFF.DATAW:=KAL_DEF.DATAW;
            KAL_BUFF.POCZATEK:=KAL_DEF.POCZATEK;
            KAL_BUFF.KONIEC:=KAL_DEF.KONIEC;
            KAL_BUFF.CZAS:=KAL_DEF.CZAS;
            KAL_BUFF.TYP:=KAL_DEF.TYP;
            KAL_BUFF.TYPWS:=KAL_DEF.TYPWS;
            KAL_BUFF.RODZAJ:=KAL_DEF.RODZAJ;
            KAL_BUFF.OPIS:=KAL_DEF.OPIS;
            {? _przerwy
            || KAL_BUFF.P_DATA:=KAL_DEF.P_DATA;
               KAL_BUFF.P_START:=KAL_DEF.P_START;
               KAL_BUFF.P_CZAS:=KAL_DEF.P_CZAS
            ?};

::          wnioski o pracę w nadgodzinach
            {? _wn_nadg & KAL_BUFF.GPW='G'
            || _godz:=exec('ile_nadg','prc_nadg',_p_ref,KAL_BUFF.DATA,KAL_BUFF.CZAS);
               {? _godz.ALL>*0 & ((_godz.TYPE='G' & KAL_BUFF.TYP<>'R') | (_godz.TYPE<>'G' & KAL_BUFF.TYP='R'))
               || {? KAL_BUFF.TYP<>'R' | KAL_BUFF.CZAS=*0
                  || KAL_BUFF.POCZATEK:=_godz.GSTART;
                     KAL_BUFF.KONIEC:=KAL_BUFF.POCZATEK+_godz.ALL
                  || KAL_BUFF.POCZATEK-=_godz.POCZATEK;
                     KAL_BUFF.KONIEC+=_godz.KONIEC
                  ?};
                  {? KAL_BUFF.KONIEC>=time(24,0,0)
                  || KAL_BUFF.DATAW+=1;
                     KAL_BUFF.KONIEC-=time(24,0,0)
                  ?};
                  KAL_BUFF.CZAS+=_godz.ALL

::                Jeśli wniosek nie może zostać uwzględniony w zmodyfikowanym grafiku to uwaga
               |? _godz.ALL>*0 & ((_godz.TYPE='G' & KAL_BUFF.TYP='R') | (_godz.TYPE<>'G' & KAL_BUFF.TYP<>'R'))
               || _sect:=' %1 %2 %3:'[KAL_BUFF.P().OSOBA().NAZWISKO,OSOBA.PIERWSZE,'[nr teczki - %1]'@[form(P.T)]];
                  {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect,'xwin16.png:100') ?};
                  _msg:='Wniosek o nadgodziny na dzień %1 nie został uwzględniony w grafiku.'@[$KAL_BUFF.DATA];
                  {? ~KOMM.find_msg(_msg) || KOMM.add(_msg,4) ?};
                  KOMM.sect_end()
               ?};
               obj_del(_godz); &_godz
            ?};

            KAL_BUFF.put(1);
            KAL_BUFF.next()
         !}
      ?}
   ?};
   KAL_BUFF.cntx_pop();
   OSOBA.cntx_pop();
   P.cntx_pop()
?};
KAL_DEF.cntx_pop();
~~


\trigKalOn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Triger KAL_DEF dotyczący aktualizacji KAL_BUFFa - włączenie.
::       Uwaga!!! - kontekst tabeli P musi byc określony
::  OLD: \trigKalOn/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
KAL_DEF.trig_a('put',"exec('trigKalUpd','grafik',P.ref(),KAL_DEF.ref())",'kal_buff');
~~


\trigKalOff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Triger KAL_DEF dotyczący aktualizacji KAL_BUFFa - wyłączenie.
::  OLD: \trigKalOff/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
KAL_DEF.trig_a('put',"",'kal_buff');
~~


\nieo_nazwa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Zwraca nazwę rubryki
::   WE:  _a - [INTEGER] - nr rubryki
::   WY: string - nazwa rubryki
::  OLD: \nieo_nazwa/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(0) || return('') ?};
{? _a = 0 || return('') ?};
__RUB.RT[_a]


\get_kal_norm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Pobiera informacje o dobowej normie czasu pracy dla pelnego wymiaru zatrudnienia
::   WE: _a -P.ref
::       _b - data sprawdzania
::       _c - czy zwracac norme czy tebele
::   WY: Norma lub tabela z rekordami R_WZCZ
::  OLD: \get_kal_norm/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null) || return(0) ?};
{? var_pres('_b')<>type_of(date) || return(0) ?};
_retTab:={? var_pres('_c')=type_of(0) || _c || 0 ?};
_ret_val:=0;
_od:=_b;
{? _od=date(0,0,0) || return(0) ?};
{? _retTab
|| _sql:='select R_WZCZ.P, R_WZCZ.OD, KAL_NAZW.NORMA from R_WZCZ join KAL_NAZW using(KAL_NAZW.REFERENCE,R_WZCZ.KAL) '+
         'where R_WZCZ.P=\':_a\' and R_WZCZ.UKRYTY=\'N\' and R_WZCZ.OD<=to_date(:_b) and KAL_NAZW.CZESC=\'N\' '+
         'order by OD';
   sql(_sql,$_a,_od)
||
   R_WZCZ.cntx_psh();
   R_WZCZ.index('R_WZWND');
   R_WZCZ.prefix(form(8+$_a),#_a,'N','N');
   {? R_WZCZ.find_le(_od)
   || _ret_val:=R_WZCZ.KAL().NORMA
   ?};
   R_WZCZ.cntx_pop();
   _ret_val
?}


\lock_A_OKR
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Zakłada blokadę dla rekordu tabeli A_OKR
::   WE: _a [REFERENCE] - wskazanie na rekord tabeli A_OKR
::   WY:    [STRING]    - pusty napis w razie powodzenia, lub komunikat błędu
::  OLD: \lock_A_OKR/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
_res:='';
_blk_sid:=exec('blk_lock','#table','A_OKR',_ref,,2);
{? _blk_sid<>A_OKR.ses_id()
|| A_OKR.cntx_psh();
   A_OKR.clear();
   {? A_OKR.seek(_ref)
   || _res:='Okres rozliczeniowy jest właśnie '+{? A_OKR.S_PLAN='Z' || 'otwierany' || 'zamykany' ?}+' do planowania'+
            ' przez użytkownika \''+A_OKR.ses_info(_blk_sid,'log_name')+'\' '+
              'na terminalu \''+A_OKR.ses_info(_blk_sid,'log_tty')+'\'.'+
              {? cli_ver()='mbasic'
              || ' Należy odświeżyć dane i spróbować ponownie.'
              || ''
              ?}
   ?};
   A_OKR.cntx_pop()
?};
_res


\unlock_A_OKR
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Zdejmuje blokadę dla rekordu tabeli A_OKR
::   WE: _a [REFERENCE] - wskazanie na rekord tabeli A_OKRM
::  OLD: \unlock_A_OKR/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_pres('_a')=type_of(null) || _a || return(~~) ?};
exec('blk_unlock','#table','A_OKR',_ref);
~~


\save2kal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
::  MOD: MicKoc [22.26]
:: OPIS: Przepisuje modyfikacje z brudnopisu do kalendarza pracownika
::   WE:  _a - [REFERENCE] - P.ref
::        _b - [DATE] - DATA_OD
::        _c - [DATE] - DATA_DO
::        _d - [INTEGER] - KOREKTA, (0 - normlnie, 1 - korekta)
::        _e - [REFERENCE] - A_OKR.ref,ref okresu rozliczeniowego
::        _f - [STRING] - osoba dokonujaca zapisu
::        _g - [INTEGER] - rok
::        _h - [INTEGER] - miesiąc
::   WY: 0 lub 1
::  OLD: \save2kal/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
  _p_ref:={? var_pres('_a')=type_of(null()) || _a || return(0)             ?};
     _od:={? var_pres('_b')=type_of(#0)     || _b || return(0)             ?};
     _do:={? var_pres('_c')=type_of(#0)     || _c || return(0)             ?};
_korekta:={? var_pres('_d')=type_of(1)      || _d || 0                     ?};
_okr_ref:={? var_pres('_e')=type_of(null)   || _e || null()                ?};
 _os_ref:={? var_pres('_f')=type_of(null()) || _f || OPERATOR.USER().OSOBA ?};
    _rok:={? var_pres('_g')=type_of(0)      || _g || _od~1                 ?};
    _msc:={? var_pres('_h')=type_of(0)      || _h || 0                     ?};

_ret_val:=1;
_kal_rok:=null();
_nowy_grafik:=0;
_dzien:=_od;
{? _msc || {? date(_rok,_msc,0)<_do || _do:=date(_rok,_msc,0) ?} ?};
_buf:=obj_new(9);
_lata:='';

{? var_pres('_buffer')>100 || obj_del(_buffer) ?};
_buffer:=exec('buffer','kal_korh');
_zerowa:=0;
_przerwy:=exec('isEnabled','prc_przerwy');

KAL_BUFF.cntx_psh();
P.cntx_psh();
P.clear();
{? P.seek(_p_ref) & P.GRAFIK='T'
|| do();
   _tab:={? _zerowa || KAL_BUFF || KAL_DEF ?};
   __KAL.set_cal(P.KAL, _rok);
   {!
   |?
::    ta część wywoływana jest tylko w przypdku braku KAL_ROK lub zmiany roku w pętli
      {? (_rok<>_dzien~1) | (_kal_rok=null())
      || _rok:=_dzien~1;
         _lata+=$_rok+';';
         _jest_grafik:=exec('jest_grafik','grafik',_p_ref,_od);
         {? _jest_grafik
         || _graf_wzor:=exec('get_graf_wzor','grafik',_p_ref,_dzien);
            _kal_rok:=exec('jest_rok','kaledit',P.KAL,_dzien,_graf_wzor)
         ?};

         {? ~_jest_grafik
         || _nowy_grafik:=exec('new_grafik','grafik',_p_ref,_dzien);
             {? _nowy_grafik
             || _graf_wzor:=exec('get_graf_wzor','grafik',_p_ref,_dzien);
                _kal_rok:=exec('jest_rok','kaledit',P.KAL,_dzien,_graf_wzor)
             ?}
         ?};
         __KAL.set_cal(P.KAL, _rok)
      ?};
::    kopiuj dzień kalendarza z brudnopisu do częściowego kalendarza współpracownika
      P.get();
      KAL_BUFF.index('PRZNODT');
      KAL_BUFF.prefix(_p_ref,'P','T',_dzien);
      {? KAL_BUFF.first()
      || {? __KAL.get_day(_dzien) & __KAL.grafik(_dzien)='T'
         || KAL_BUFF.STATUS:='P';
            KAL_BUFF.put(1);
:: dla korekty zapisujemy starą wartość dnia kalendarza
            {? _korekta
            || _mod:=
                  {? KAL_DEF.CZAS<>KAL_BUFF.CZAS
                     |
                     KAL_DEF.DATA<>KAL_BUFF.DATA
                     |
                     KAL_DEF.DATAW<>KAL_BUFF.DATAW
                     |
                     KAL_DEF.KONIEC<>KAL_BUFF.KONIEC
                     |
                     KAL_DEF.OPIS<>KAL_BUFF.OPIS
                     |
                     KAL_DEF.POCZATEK<>KAL_BUFF.POCZATEK
                     |
                     KAL_DEF.RODZAJ<>KAL_BUFF.RODZAJ
                     |
                     KAL_DEF.TYP<>KAL_BUFF.TYP
                     |
                     KAL_DEF.TYPWS<>KAL_BUFF.TYPWS
                  || 1
                  || 0
                  ?};
               {? _przerwy
               || _mod:=_mod + (
                  KAL_DEF.P_DATA<>KAL_BUFF.P_DATA |
                  KAL_DEF.P_START<>KAL_BUFF.P_START |
                  KAL_DEF.P_CZAS<>KAL_BUFF.P_CZAS)
               ?};
               {? _mod
               || _buffer.blank(_buffer);
                  _buffer.STATUS:=_tab.STATUS;
                  _buffer.CZAS:=_tab.CZAS;
                  _buffer.DATA:=_tab.DATA;
                  _buffer.DATAW:=_tab.DATAW;
                  _buffer.KONIEC:=_tab.KONIEC;
                  _buffer.OPIS:=_tab.OPIS;
                  _buffer.POCZATEK:=_tab.POCZATEK;
                  _buffer.RODZAJ:=_tab.RODZAJ;
                  _buffer.TYP:=_tab.TYP;
                  _buffer.TYPWS:=_tab.TYPWS;
                  {? _przerwy
                  || _buffer.P_DATA:=_tab.P_DATA;
                     _buffer.P_START:=_tab.P_START;
                     _buffer.P_CZAS:=_tab.P_CZAS
                  ?};
                  exec('add','kal_korh',_p_ref,_okr_ref,_buffer,_zerowa,_os_ref)
               ?}
            ?};
:: zmodyfikowanie kalendarza
            KAL_DEF.STATUS:='P';
            KAL_DEF.CZAS:=KAL_BUFF.CZAS;
            KAL_DEF.DATA:=KAL_BUFF.DATA;
            KAL_DEF.DATAW:=KAL_BUFF.DATAW;
            KAL_DEF.KONIEC:=KAL_BUFF.KONIEC;
            KAL_DEF.OPIS:=KAL_BUFF.OPIS;
            KAL_DEF.POCZATEK:=KAL_BUFF.POCZATEK;
            KAL_DEF.RODZAJ:=KAL_BUFF.RODZAJ;
            KAL_DEF.TYP:=KAL_BUFF.TYP;
            KAL_DEF.TYPWS:=KAL_BUFF.TYPWS;
            {? _przerwy
            || KAL_DEF.P_DATA:=KAL_BUFF.P_DATA;
               KAL_DEF.P_START:=KAL_BUFF.P_START;
               KAL_DEF.P_CZAS:=KAL_BUFF.P_CZAS
            ?};
            _ret_val:=_ret_val*KAL_DEF.put()
         ?}
      ?};
     _dzien+=1;
     _dzien<=_do
   !};
:: w przypadku niepowodzenia cofnij zmiany
   {? _ret_val=0
   || undo()
   || {? _korekta
      || exec('korekta_koniec','kal_korn',_p_ref,_okr_ref,_zerowa)
      ?}
   ?};
   _ret_val:=end();
   {? _ret_val
   || {? _korekta
      || exec('ponow_kwal_wewy','grafik',_p_ref,_od,_do, _os_ref)
      ?};
:: po modyfikacji zaktualizuj lata
      STR.split(_lata,';');
      {!
      |? _rok:=#STR.get_word();
         {? _rok
         || exec('akt_rok','kaledit',P.KAL,_rok)
         ?};
         STR.next()
      !};
      exec('plan_aktual','nieobecnosc',_p_ref,_od,_do);
      exec('urlPlan_aktual','grafik',_p_ref,_od,_do)
   ?}
?};
P.cntx_pop();
KAL_BUFF.cntx_pop();
_ret_val


\del_plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Usuwa modyfikacje z brudnopisu w zakresie podanych dat
::   WE:  _a - P.ref           ref
::        _b - DATA_OD        date
::        _c - DATA_DO        date
::        _d - maska p(Plan)/g(Grafik)/w(Wykonanie)
::        _e - okres ref
::   WY: -1/0/1
::  OLD: \del_plan/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
  _p_ref:={? var_pres('_a')<>type_of(null) || return(0) || _a   ?};
     _od:={? var_pres('_b')<>type_of(date) || return(0) || _b   ?};
     _do:={? var_pres('_c')<>type_of(date) || return(0) || _c   ?};
    _gpw:={? var_pres('_d')<>type_of('_d') || return(0) || ~-_d ?};
_okr_ref:={? var_pres('_e')<>type_of(null) || return(0) || _e   ?};
{? _gpw = 'P' | _gpw = 'G' | _gpw = 'W'
|| 1
|| return(0)
?};
_ret_val:=1;
_dzien:=_od;
_rok:=_dzien~1;
_ile:=0;
KAL_BUFF.cntx_psh();
KAL_BUFF.index('PROKRDT');
{? _od=_do
|| KAL_BUFF.prefix(_gpw,_p_ref,_okr_ref,_dzien)
|| KAL_BUFF.prefix(_gpw,_p_ref,_okr_ref)
?};
_mydo:=do_state()=0;
{? _mydo || do() ?};
{? KAL_BUFF.first()
|| {!
   |? {? (KAL_BUFF.DATA>=_od) & (KAL_BUFF.DATA<=_do)
      || {? _gpw='P' & (+KAL_BUFF.NH) & (exec('czy_nieob_lt','prc_graf',KAL_BUFF.P,KAL_BUFF.DATA)=2)
         || _val:=-1
         || _val:=KAL_BUFF.del(1,1)
         ?};
         _ret_val*=_val;
         {? _ret_val>0 || _ret_val:=1 ?};
         _ile+=1;
         {? _val=-1
         || 0
         || ~(_val=0 | _val=1)
         ?}
      || KAL_BUFF.next()
      ?}
   !}
?};
{? (_gpw<>'W') & (_ile=0) || _ret_val:=0 ?};
:: jezeli jest to wykonanie to zmien zatwierdzenie w grafiku
{? (_gpw='W') & _ile>0
||
   KAL_BUFF.cntx_psh();
   KAL_BUFF.index('PRZNODT');
   KAL_BUFF.prefix(_p_ref,'G','T',_dzien);
   {? KAL_BUFF.first()
   || KAL_BUFF.STATUS:='M';
      KAL_BUFF.put(1)
   ?};
   KAL_BUFF.cntx_pop()
?};
{? _ret_val<0 || undo() ?};
{? _mydo || end() ?};
KAL_BUFF.cntx_pop();
_ret_val


\mod_kal_rodz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Modyfikuje pole RODZAJ KAL_DEF-a
::   WE: _a - P.ref (ref pracownika)
::       _b - data
::       _c - wartosc pola RODZAJ
::   WY: 0 lub 1
::  OLD: \mod_kal_rodz/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')<>type_of(null) || return(0) || _a ?};
_dzien:={? var_pres('_b')<>type_of(date) || return(0) || _b ?};
 _rodz:={? var_pres('_c')<>type_of('')   || return(0) || _c ?};
{? _rodz <> 'W' & _rodz <> 'G' || return(0) ?};
_ret_val:=0;
KAL_DEF.cntx_psh();
P.cntx_psh();
P.clear();
{? P.seek(_p_ref)
|| __KAL.set_cal(P.KAL,_dzien~1);
   {? __KAL.get_day(_dzien)
   || {? KAL_DEF.RODZAJ <> _rodz
      || KAL_DEF.RODZAJ:=_rodz;
         _ret_val:=KAL_DEF.put(1)
      || _ret_val:=1
      ?}
   ?}
?};
KAL_DEF.cntx_pop();
P.cntx_pop();
_ret_val


\korekta_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Funkcja uruchamiana przed rozpoczeciem korekty planowania
::   WE: _a - [STRING] - osoba, ktora robi korekte
::       _b - P.ref - wskazanie na pracownika, ktorego dotyczy korekta
::       _c - A_OKR.ref - wskazanie na okres rozliczeniowy
::       _d - [STRING] - powód korekty
::       _e - [INTEGER]    - rok
::       _f - [INTEGER]    - miesiac
::   WY: 0 / 1
::  OLD: \korekta_start/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_os_szef:={? var_pres('_a')<>type_of('')   || ''        || _a ?};
  _p_ref:={? var_pres('_b')<>type_of(null) || return(0) || _b ?};
_okr_ref:={? var_pres('_c')<>type_of(null) || return(0) || _c ?};
  _powod:={? var_pres('_d')<>type_of('')   || ''        || _d ?};
    _rok:={? var_pres('_e')<>type_of(0)    || 0         || _e ?};
    _msc:={? var_pres('_f')<>type_of(0)    || 0         || _f ?};

_ret_val:=0;
_kor_ver:=exec('get_kor_ver','grafik',_p_ref,_okr_ref)+1;
_trans:=do_state()=1;
{? ~_trans || do() ?};
:: zapisz informacje o rozpoczeciu i powodzie korekty
_ret_val:=1;
:: zapisz aktualny bufor planowania jako wersje archiwalna
KAL_BUFF.cntx_psh();
KAL_BUFF.index('PROKRDT');
KAL_BUFF.prefix('P',_p_ref,_okr_ref);
_file:=exec('open_log_file','grafik',_p_ref,_okr_ref,1);
exec('to_file','grafik',_file,$_kor_ver,_os_szef+'|@|otwarcie planowania do korekty|@|'+_powod,KAL_BUFF,1);
KAL_BUFF.cntx_pop();
:: ustaw aktualny numer wersji planu
{? _ret_val=0 || undo() ?};
{? ~_trans || end() ?};
_ret_val


\korekta_koniec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Funkcja uruchamiana na zakonczenie korekty planowania
::   WE: _a - [STRING] - osoba, ktora robi korekte
::       _b - P.ref - wskazanie na pracownika, ktorego dotyczy korekta
::       _c - A_OKR.ref - wskazanie na okres rozliczeniowy
::       _d - [INTEGER]    - rok
::       _e - [INTEGER]    - miesiac
::   WY: 0 / 1
::  OLD: \korekta_koniec/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_os_szef:={? var_pres('_a')<>type_of('')   || ''        || _a ?};
  _p_ref:={? var_pres('_b')<>type_of(null) || return(0) || _b ?};
_okr_ref:={? var_pres('_c')<>type_of(null) || return(0) || _c ?};
    _rok:={? var_pres('_d')<>type_of(0)    || 0         || _d ?};
    _msc:={? var_pres('_e')<>type_of(0)    || 0         || _e ?};

_ret_val:=0;
_kor_ver:=exec('get_kor_ver','grafik',_p_ref,_okr_ref);
:: zapisz informacje o zakonczeniu korekty
_file:=exec('open_log_file','grafik',_p_ref,_okr_ref,1);
exec('to_file','grafik',_file,$_kor_ver,_os_szef+'|@|zakończenie korekty planowania|@|');
_ret_val


\get_kor_ver
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Funkcja zwracajaca wersje korekty planowania
::   WE: _a - P.ref - wskazanie na pracownika, ktorego dotyczy korekta
::       _b - A_OKR.ref - wskazanie na okres rozliczeniowy
::   WY: [STRING] wersja korekty
::  OLD: \get_kor_ver/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
  _p_ref:={? var_pres('_a')<>type_of(null) || null() || _a ?};
_okr_ref:={? var_pres('_b')<>type_of(null) || null() || _b ?};

_file:=exec('open_log_file','grafik',_p_ref,_okr_ref,0);
_ver:=0;
{? (type_of(_file)<>0) & _file.is_open()
|| {!
   |? (_wiersz:=_file.fread())<>'\n'
   |! {? _wiersz*'<kor_ver='
      || _ver_tmp:=#((9-_wiersz)-1);
         {? _ver_tmp > _ver || _ver:=_ver_tmp ?}
      ?}
   !};
   _file.fclose()
?};
_ver


\open_log_file
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Funkcja otwierajaca plik logujacy dla korekt planu
::   WE: _a - P.ref - wskazanie na pracownika, ktorego dotyczy korekta
::       _b - A_OKR.ref - wskazanie na okres rozliczeniowy
::       _c - tryb otwarcia 0 czytanie 1 dopisywanie
::   WY: obiekt FILE lub ~~ w razie niepowodzenia
::  OLD: \open_log_file/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
  _p_ref:={? var_pres('_a')<>type_of(null) || null() || _a ?};
_okr_ref:={? var_pres('_b')<>type_of(null) || null() || _b ?};
   _tryb:={? var_pres('_c')<>type_of(0)    || 0      || _c ?};
_mode:={? _tryb=0 || 'ur' || 'ua'?};
_file:=~~;
:: ustalenie polozenia katalogu IMEX
_imex:=pth_dir('a.imp');
:: sprawdzenie czy istnieje podkatalog dla korekt planownaia KRP
{? (_d_name:=fmkdir(_imex,'krp'))<>''
|| _f_name:=_f_name:=$_okr_ref+'_'+$_p_ref+'.krp';
   _f_name:=_d_name + '\\' + _f_name;
   _file:=fopen(_f_name,_mode, 0, 0, 1)
?};
_file


\to_file
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: zrzuca do pliku wartosci podanych parametrow
::   WE: [_a] - obiekt typu FILE
::       [_b] - numer korekty
::       [_c] - info
::       [_d,_e] - _d - co zapisac,
::                 _e - opcja zapisu (dla tabeli [0] - czy wszystkie rekordy z dziedziny(1), czy tylko biezacy(0)?)
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::  OLD: \to_file/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_file:=_a;
_ver:=_b;
_info:=form(_c);
{? (type_of(_file)<>0) & _file.is_open()
|| _tm_stamp:=19+tm_form(SYSLOG.tm_stamp());
   _file.fwrite('<session start='+_tm_stamp+'>');
   {? _<3
   || _file.fwrite('<error> BŁĘDNA LICZBA PARAMETRÓW: '+$_+', a powinna być większa od 3.</error>')
   || _file.fwrite('<kor_ver='+_ver+'>');
      _file.fwrite('<info='+_info+'>');
      {! __:=4//2.._
      |!
         {? type_of(_[__])=type_of(SYSLOG)
         ||
            _file.fwrite('<var nr='+form(__,-3)+' type=table'+{? _[__+1]=1 || ' param=prefix' || '' ?}+'>');
            _[__].cntx_psh();
            {? _[__+1]=0
            || _file.fwrite(exec('to_string','grafik',_[__],';','',''))
            |? _[__].first()
            || {!
               |?
                  _file.fwrite(exec('to_string','grafik',_[__],';','',''));
                  _[__].next()
               !}
            ?};
            _[__].cntx_pop();
            _file.fwrite('</var>')

         |? type_of(_[__])>100
         || _file.fwrite('<var nr='+form(__,-3)+' type=object>');
            _file.fwrite(exec('to_string','grafik',_[__],';','',''));
            _file.fwrite('</var>')

         || _file.fwrite('<var nr='+form(__,-3)+' type=simple>');
            _file.fwrite(exec('to_string','grafik',_[__],';','',''));
            _file.fwrite('</var>')
         ?}
      !}
   ?};
   _file.fwrite('</session>\n');
   _file.fclose()
?}


\to_string
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.20]
:: OPIS: Zwraca (za)wartosc parametru przekonwertowana do STRING'a
::   WE: ANY     _a - cos, co chcemy rozpisac do STRING'a
::       STRING [_b]- separator, domyslnie ', '
::       STRING [_c]- lewy nawias, domyślnie '{'
::       STRING [_d]- prawy nawias, domyslnie '}'
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::  OLD: \to_string/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_simple:=0;
{? var_pres('_a')>100 || _arr:=_a || _simple:=1; _arr:=obj_new(1); _arr[1]:=_a ?};
_txt:='';
_sep:={? var_pres('_b')=2 || _b || ', ' ?};
_lbra:={? var_pres('_c')=2 || _c || '{' ?};
_rbra:={? var_pres('_d')=2 || _d || '}' ?};
:: sprawdzam czy tablica czy tabela
{? type_of(_arr)=type_of(SYSLOG)
||
   {! _ff:=1.._arr.fld_num()
   |! _type:=var_pres(_arr.fld_acr(_ff),_arr,'diff_blob');
      _txt+={? _type=20 || form(_arr[_ff],,,'9.')
            |? _type=21 || '['+form(_arr[_ff])+']'
            |? _type=22 || form(_arr[_ff],,,'99')
            |? _type=24 || '<HEAD>'
            |? _type=25 || '<MEMO>'
            |? _type=26 || {? _arr[_ff]<>null() || $_arr[_ff] || 'null()' ?}
            |? _type=27 || ''''+_arr[_ff]+''''
::            |? _type=28 || '?'
            |? _type=29 || '['+form(_arr[_ff],,3)+']'
            |? _type=30 || 'R'+$_arr[_ff]
            |? _type=32 || form(_arr[_ff],,,'99')
            |? _type=33 || '<BLOBRAW>'
            |? _type=36 || '<SYS_MEMO>'
            |? _type=37 || '<BLOBIMAGE>'
                        || '<'+$_type+'>'
            ?}+_sep
   !}
||
   {! _pp:=1..obj_len(_arr)
   |! _type:=var_pres('['+form(_pp,,,'99')+']',_arr);
      _txt+={? _type=0 || '~~'
            |? _type=1 || form(_arr[_pp],,,'9.')
            |? _type=2 || ''''+form(_arr[_pp])+''''
            |? _type=3 || '"'+form(_arr[_pp])+'"'
            |? _type=4 || '['+form(_arr[_pp])+']'
            |? _type=5 || '['+form(_arr[_pp],,3)+']'
            |? _type=7 || {? _arr[_pp]<>null() || $_arr[_pp] || 'null()' ?}
            |? _type<0 || '###'
                       || '<'+$_type+'>'
            ?}+_sep
   !}
?};
{? _simple || (_txt-(+_sep)) || _lbra+(_txt-(+_sep))+_rbra ?}


\KAL_cpsh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.28]
:: OPIS: Zapamiętuje kontekst tabel związanych z kalendarzem
::   WE:
::   WY:
::  OLD: \KAL_cpsh/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
KAL_NAZW.cntx_psh();
KAL_ROK.cntx_psh();
KAL_DEF.cntx_psh();
KAL_OPIS.cntx_psh();
~~


\KAL_cpop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.28]
:: OPIS: Odtwarza kontekst tabel związanych z kalendarzem
::   WE:
::   WY:
::  OLD: \KAL_cpop/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
KAL_NAZW.cntx_pop();
KAL_ROK.cntx_pop();
KAL_DEF.cntx_pop();
KAL_OPIS.cntx_pop();
~~


\nieo_typ
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.28]
:: OPIS: Zwraca typ rubryki
::   WE:  _a - [INTEGER] - nr rubryki
::   WY: string - typ rubryki
::  OLD: \nieo_typ/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(0) | _a=0 || return('') ?};
{? __RUB.sys_attr(_a,111) || 'UW'
|? __RUB.sys_attr(_a,1161) || 'UO'
|? __RUB.sys_attr(_a,1162) | __RUB.sys_attr(_a,1225) || 'OP'
|? __RUB.sys_attr(_a,112) || 'UB'
|? __RUB.sys_attr(_a,114) || 'UC'
|? __RUB.sys_attr(_a,115) || 'UM'
|? __RUB.sys_attr(_a,124) || 'ZN'
|? __RUB.sys_attr(_a,126) || 'CH'
|? __RUB.sys_attr(_a,1321) || 'NN'
|? __RUB.sys_attr(_a,1323) || 'SW'
|| 'NU'
?}


\nieo_ah_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Dodaje nieobecność ad-hoc we wskazanym dniu
::   WE: _a  [REFERENCE] - P.ref pracownika rejestrujacego nieobecnosc
::       _b  [REFERENCE] - P.ref pracownika, którego nieobecność dotyczy
::       _c  [DATE]      - Data nieobecności
::      [_d] [NUMER]     - Numer rubryki
::   WY: 0/1 - niepowodzenie/powodzenie
::  OLD: \nieo_ah_add/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
 _p_kto:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
 _p_ref:={? var_pres('_b')=type_of(null) || _b || return(0) ?};
  _data:={? var_pres('_c')=type_of(date) || _c || return(0) ?};
_nr_rub:={? var_pres('_d')=type_of(0)    || _d || 0         ?};
{? _data=date(0,0,0) || return(0) ?};
_rub:=null();
_ret_val:=0;
{? _nr_rub<>0
|| R.cntx_psh();
   R.index('RUBKOD');
   R.prefix(_nr_rub);
   {? R.first()
   || _rub:=R.ref()
   ?};
   R.cntx_pop()
?};
N_AH.cntx_psh();
N_AH.index('PRACDATA');
N_AH.prefix(_p_ref,_data);
N_AH.DATA:=_data;
{? N_AH.first()
|| _put:=1
|| _put:=0
?};
N_AH.prefix();
N_AH.blank(1);
N_AH.P:=_p_ref;
N_AH.KTO:=_p_kto;
N_AH.DATA:=_data;
N_AH.DD:=date();
N_AH.TYP:=_rub;
_ret_val:={? _put || N_AH.put() || N_AH.add() ?};
N_AH.cntx_pop();
_ret_val


\nieo_ah_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Usuwa nieobecność ad-hoc we wskazanym dniu
::   WE: _a [REFERENCE] - P.ref pracownika, którego nieobecność dotyczy
::       _b [DATE]      - Data nieobecności
::   WY: 0/1 - niepowodzenie/powodzenie
::  OLD: \nieo_ah_del/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
 _data:={? var_pres('_b')=type_of(date) || _b || return(0) ?};
_ret_val:=0;
N_AH.cntx_psh();
N_AH.index('PRACDATA');
N_AH.prefix(_p_ref,_data);
{? N_AH.first()
|| _ret_val:=N_AH.del(,1)
?};
N_AH.cntx_pop();
_ret_val


\nieo_ah_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Wyszukuje nieobecność ad-hoc dla pracownika na wskazaną datę
::   WE:  _a  [REFERENCE] - P.ref pracownika, którego nieobecność dotyczy
::        _b  [DATE]      - Data nieobecności
::       [_c] [DATE]      - Data, do której zbieramy informacje o nieobecnościach ad-hoc
::   WY: 0 lub nr rubryki lub w przypadku podania daty do - tabela tymczasowa
::  OLD: \nieo_ah_find/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
  _p_ref:={? var_pres('_a')=type_of(null) || _a || return(0)   ?};
   _data:={? var_pres('_b')=type_of(date) || _b || return(0)   ?};
_data_do:={? var_pres('_c')=type_of(date) || _c || date(0,0,0) ?};
{? _data_do<>date(0,0,0)
|| _sql:='select DATA, R.RN as KOD from N_AH join R where P=:_a and DATA between to_date(:_b) and to_date(:_c)';
   sql(_sql,_p_ref,_data,_data_do)
|| _ret_val:=0;
   N_AH.cntx_psh();
   N_AH.index('PRACDATA');
   N_AH.prefix(_p_ref,_data);
   {? N_AH.first()
   || {? N_AH.TYP<>null()
      || _ret_val:=N_AH.TYP().RN
      || _rubs:=__RUB.sys_rub(1311);
         {? _rubs.first()
         || _ret_val:=_rubs.RN
         || _ret_val:=24
         ?}
      ?}
   ?};
   N_AH.cntx_pop();
   _ret_val
?}


\spr_odb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK & TMR [12.30]
:: OPIS: Akcja przed usuń dla we/wy w grafikach sprawdzająca czy istnieje na dany dzień zakwalifikowane wykonanie
::       powiązane z odbiorem nadgodzin
::   WE: _a  - [REFERENCE] - wskazanie na pracownika
::       _b  - [DATE]      - data badania
::       _c  - [INTEGER]   - czy wyświetlać komunikaty (domyślnie nie wyświetla)
::      [_d] - [INTEGER]   - czy sprawdzać dzień poprzedni (domyślnie tak)
::   WY: 0 lub 1
::  OLD: \spr_odb/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_odb:=obj_new('jestOdb','data');
_odb.jestOdb:=0;
_odb.data:='';
  _p_ref:={? var_pres('_a')=type_of(null) || _a || return(_odb) ?};
   _data:={? var_pres('_b')=type_of(date) || _b || return(_odb) ?};
    _msg:={? var_pres('_c')=type_of(0)    || _c || 0            ?};
_chkPrev:={? var_pres('_d')=type_of(0)    || _d || 1            ?};

R_KWGODZ.cntx_psh();
R_WYK.cntx_psh();
R_WYK.use('r_wyk');
R_WYK.index('R_WYKDN');
_dalej:=0;
_prev:=0;
_jestWyk:=0;
:: jeżeli są zapisy w tabeli odbiorów na sprawdzaną datę
R_WYK.prefix(_p_ref,_data);
{? R_WYK.first()
|| _jestWyk:=1;
   _data:=_data+1
:: jeżeli nie ma zapisów w tabeli odbiorów na sprawdzaną datę, to sprawdzamy dzień wcześniej
|? R_WYK.prefix(_p_ref,_data-1);
   _chkPrev & R_WYK.first()
|| _jestWyk:=1;
   _prev:=1
?};
{? _jestWyk
|| _g_wyk:=time(0,0,0);
   _g_kwal:=time(0,0,0);
   _pocz:=time(0,0,0);
   _kon:=time(0,0,0);
   _czas_d:=time(0,0,0);
   {!
   |? _g_wyk+=R_WYK.G;
      MASK.Use('R_KWGODZ',R_WYK.DN~1,R_WYK.DN~2);
      R_KWGODZ.index('DATA_RUB');
      R_KWGODZ.prefix(_p_ref,R_WYK.DN,R_WYK.R().RN);
      {? R_KWGODZ.first()
      || _g_kwal+=R_KWGODZ.GODZ
      ?};
      _odb.data+={? +_odb.data ||', ' || '' ?}+$R_WYK.DO;
      R_WYK.next()
   !};

:: wyliczenie zakwalifikowanych godzin ze statusu "D" pochodzących z dnia następnego
   {? _prev
   || R_REJ_WW.cntx_psh();
      MASK.Use('R_REJ_WW',(_data)~1,(_data)~2);
      R_REJ_WW.index('R_REJ_ST');
      R_REJ_WW.prefix(_p_ref,_data,3,'D');
      {? R_REJ_WW.first()
      || _kon:=R_REJ_WW.GD;
         R_REJ_WW.prefix(_p_ref,_data,2,'D');
         {? R_REJ_WW.first()
         || _pocz:=R_REJ_WW.GD;
            _czas_d:=_kon-_pocz
         ?}
      ?};
      R_REJ_WW.cntx_pop()
   ?};

   {? _prev
   || {? (*_czas_d) & (*_g_kwal) & (*_g_wyk) & (*_czas_d>(*_g_kwal-*_g_wyk))
::       sprawdzamy czy w przypadku nadgodzin powstałych z pracy w dobie poprzedniej ("D")
::       odbiór dotyczy choćby w części tych nadgodzin
      || _dalej:=0;
         _odb.jestOdb:=1
      ?}
   || {? (*_g_kwal) & (*_g_wyk)
      || _dalej:=0;
         _odb.jestOdb:=1
      ?}
   ?}
?};
{? _msg & _odb.jestOdb
|| FUN.emsg('%1\n%2\n%3'
      ['Istnieją zapisy w odebranych godzinach, które korzystają z tej kwalifikacji.'@,
      'Prosze sprawdzić kartotekę odbioru godzin w dniu %1.'@[$_odb.data],
      'Redakcja niemożliwa.'@]
   )
?};
R_WYK.cntx_pop();
R_KWGODZ.cntx_pop();
_odb


\kwal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Wykonuje kwalifikację rejestracji
::   WE:  _a - [REFERENCE] - Wskazanie na współpracownika
::        _b - [DATE] - Data początkowa
::        _c - [DATE] - Data końcowa
::        _d - NUMBER - czy sprawdzać okresy rozliczeniowe? (0 / 1*)
::   WY: 0 lub 1
::  OLD: \kwal/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
exec('__HARM','object');
{? ~__HARM.KW_AUTO || return(0) ?};

  _p_ref:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
_data_od:={? var_pres('_b')=type_of(date) || _b || return(0) ?};
_data_do:={? var_pres('_c')=type_of(date) || _c || return(0) ?};
_chk_okr:={? var_pres('_d')=type_of(0)    || _d || 1         ?};
_ret_val:=0;

{? _chk_okr
|| _tab_okr:=exec('is_prac_in_okrp','grafik',_p_ref,_data_od,_data_do,,'O');
   {? _tab_okr.first()
   || {!
      |? _ret_val+=exec('kwal','grafik',_p_ref,_tab_okr.OD,_tab_okr.DO,0);
         _tab_okr.next()
      !}
   ?};
   return(_ret_val>0)
?};

:: powołanie tabeli potrzebnej do kwalifikacji
_KWAL:=exec('tab_create','prc_rozlicz');
_KWKK:=exec('kwkk_create','prc_rozlicz');
_PZD:=exec('pzd_create','prc_rozlicz');
VAR_EDIT.cntx_psh();
VAR_EDIT.FLAGA:=2;
P.cntx_psh();
P.clear();
params_set('KWAL',_KWAL,'KWKK',_KWKK,'PZD',_PZD);
{? P.seek(_p_ref)
|| _ret_val:=exec('kwal_zdalnie','prc_rozlicz',_data_od,_data_do);
   _popokr:=exec('prz_okr','prc_rozlicz',_data_od-1);
   {? _popokr
   || A_OKRP.cntx_psh();
      A_OKRP.index('A_OKRDP');
      A_OKRP.prefix(P.ref());
:: dzień należy do poprzedniego okresu rozliczeniowego
      {? A_OKRP.find_le(_data_od-1)
      || _tab_tmp:=_KWAL;
         _kwkk_tmp:=_KWKK;
         _pzd_tmp:=_PZD;
         {? var_pres('_KWAL')>100 || &_KWAL ?};
         {? var_pres('_KWKK')>100 || &_KWKK ?};
         {? var_pres('_PZD')>100 || &_PZD ?};
         _PZD:=exec('pzd_create','prc_rozlicz');
         _KWAL:=exec('tab_create','prc_rozlicz');
         _KWKK:=exec('kwkk_create','prc_rozlicz');
         params_set('KWAL',_KWAL,'KWKK',_KWKK,'PZD',_PZD);
:: weryfikacja na ostatni dzień poprzedniego okresu
         exec('kwal_zdalnie','prc_rozlicz',_data_od-1, _data_od-1, _data_od-1);
         {? var_pres('_KWAL')>100 || &_KWAL ?};
         {? var_pres('_KWKK')>100 || &_KWKK ?};
         {? var_pres('_PZD')>100 || &_PZD ?};
         _PZD:=_pzd_tmp;
         _KWAL:=_tab_tmp;
         _KWKK:=_kwkk_tmp;
         params_set('KWAL',_KWAL,'KWKK',_KWKK,'PZD',_PZD)
      ?};
      A_OKRP.cntx_pop()
   ?}
?};
P.cntx_pop();
VAR_EDIT.cntx_pop();
_ret_val


\ponow_kwal_wewy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
::  MOD: MicKoc [22.26]
:: OPIS: Funkcja ponownie zapisująca we/wy i ponownie je kwalifikująca w zakresie podanych dat
::   WE: _a   [REFERENCE] - P.ref
::       _b   [DATE]      - początek
::       _c   [DATE]      - koniec
::       [_d] [REFERENCE] - OSOBA.ref - ref osoby zapisujacej dane
::       [_e] [INTEGER]   - czy usuwa kwalifikacje z dnia bez wewy
::       [_f] [INTEGER]   - nie będzie sprawdzać odbiory
::       [_g] [INTEGER]   - uwzględnienie zablokowania miesiąca dla pracownika znacznik X
::   WY:
::  OLD: \ponow_kwal_wewy/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? ~__HARM.KW_AUTO || return(0) ?};
_p_ref:={? var_pres('_a')=type_of(null()) || _a || return(0) ?};
_start:={? var_pres('_b')=type_of(#0) || _b || return(0) ?};
_end:={? var_pres('_c')=type_of(#0) || _c || return(0) ?};
_szef:={? var_pres('_d')=type_of(null()) || _d || null () ?};
_delKw:={? var_pres('_e')=type_of(0) || _e || 0 ?};
_odbior:={? var_pres('_f')=type_of(0) || _f || 0 ?};
_mc_prac:={? var_pres('_g')=type_of(0) || _g || 0 ?};

_dzien:=_end;
_ok:=0;
{!
|? (_dzien>=_start)
|!
:: sprawdzenie statusu rozliczeniowego miesiąca - czy można modyfikować wykonanie
   {? {? _mc_prac || __HARM.mc_otw(_dzien,0) || exec('get_msc_status','grafik',_dzien)<>'Z' ?}
   ||
:: sprawdzenie czy istnieje zapis wykonania w rejestrze we/wy
      _wewy:=exec('get_wewy','prc_wewy',_dzien,_p_ref);
      {? _wewy.last()
      || _PRZ:=exec('get_wewy_przerwy','prc_wewy',_p_ref,_wewy.DWE,_wewy.GWE,_wewy.DWY,_wewy.GWY);
:: sprawdzenie czy istnieje blokada na zarejestrowanym wykonaniu
         _isBlokada:=exec('isBlokada','prc_rozlicz',_p_ref,_dzien)>0;
         _isCzytnik:=exec('isCzytnikOK','grafik',_wewy.PORTAL);
         _blokada:=_isBlokada | _PRZ.first();
         &_PRZ;
:: ponownie kwalifikujemy tylko we/wy z typem PORTAL i przy braku blokady
         {? _isCzytnik & (~_blokada)
         ||
:: sprawdzenie statusu we/wy - czy nie ma powiazań z odbiorem
            {? _odbior | exec('get_wewy_status','prc_wewy',_p_ref,_dzien,0)<>'O'
            || exec('mod_kal_rodz','grafik',_p_ref,_dzien-1,'G');
               exec('mod_kal_rodz','grafik',_p_ref,_dzien,'G');
               _kod_czyt:=exec('getKodCzytnika','grafik',_wewy.TYP);
               _typ:={? _wewy.DWE>_dzien || 'X' || '' ?};
               _ok+=exec('save2wewy','prc_wewy',_p_ref,_wewy.DWE,_wewy.GWE,_wewy.DWY,_wewy.GWY
                                               ,,_typ,_szef,_kod_czyt,_wewy.PD,_wewy.PS,_wewy.PC)
            ?}
         |? ~_isBlokada & _isCzytnik
         || _ok:=1
         ?}
      || {? _delKw
         || _ok+=exec('save2wewy','prc_wewy',_p_ref,_dzien,time(0,0,0),_dzien,time(0,0,0),,,_szef)
         ?}
      ?};
      &_wewy
   ?};
   _dzien-=1
!};
:: rozszerzamy zakres kwalifikacji o dodatkowy dzień przed i po
{? _ok
|| exec('kwal','grafik',_p_ref,_start-1,_end+1)
?};
_ok


\getKodCzytnika
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Zwraca kod czytnika dla podanego opisu
::   WE: _a - [STRING] - nazwa czytnika
::   WY: kod czytnika lub ''
::  OLD: \getKodCzytnika/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_czytnik:={? var_pres('_a')=2 || _a || return(_result) ?};

R_OPCZYT.cntx_psh();
R_OPCZYT.prefix();
{? R_OPCZYT.find_tab(,'O',,'like',_czytnik)
|| _result:=R_OPCZYT.K
?};
R_OPCZYT.cntx_pop();
_result


\isCzytnikOK
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Sprawdza czy typ czytnika jest odpowiedni do ponownej kwalifikacji we/wy
::   WE: _a - [STRING] - czy możliwa edycja na portalu
::   WY: 0/1
::  OLD: \isCzytnikOK/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_portal:={? var_pres('_a')=2 || _a || return(_result) ?};

{? _portal='T'
|| _result:=1
?};
_result


\get_msc_status
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Pobiera status rozliczeniowy miesiąca
::   WE:  _a - DATA   data sprawdzenia
::   WY: status okresu ('O' - otwarty / 'Z' - zamkniety / '' - brak informacji)
::  OLD: \get_msc_status/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_data:={? var_pres('_a')<>type_of(#0) || return('') || _a ?};
_rok:=_data~1;
_msc:=_data~2;
_r_nast:=_rok;
_m_nast:={? _msc=12 || _r_nast+=1; 1 || _msc+1 ?};
_status:='';
_nastZam:=0;
A_OKRM.cntx_psh();
A_OKRM.index('A_OKRMR');
:: sprawdzenie czy następny miesąc jest zamknięty
A_OKRM.prefix(_r_nast,_m_nast);
{? A_OKRM.first()
|| _nastZam:=(A_OKRM.S='Z')
?};
A_OKRM.prefix(_rok,_msc);
{? A_OKRM.first()
|| {? var_pres('__HARM')>100 & __HARM.ZAMK_MIE
   || _status:='O'
   || _status:={? A_OKRM.S='Z' & {? A_OKRM.DZ<>#0 || _nastZam | _data<=A_OKRM.DZ || 1 ?} || 'Z' || 'O' ?}
   ?}
?};
A_OKRM.cntx_pop();
_status


\urlWnPl_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Wyszukuje wnioski urlopowe lub pozycje planu urlopowego pracownika w zakresie podanych dat
::   WE: _a [REFERENCE] - P.ref pracownika, ktorego nieobecnosc dotyczy
::       _b [DATE]      - Data badania od
::       _c [DATE]      - Data badania do
::   WY:    [TABLE]     - Tabela z informacjami na poszczegolne dni
::  OLD: \urlWnPl_find/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
   _od:={? var_pres('_b')=type_of(date) || _b || return(0) ?};
   _do:={? var_pres('_c')=type_of(date) || _c || return(0) ?};
_tab:=tab_tmp(1,'DATA','DATE','Data wniosku lub pozycji planu'
               ,'N_WP','STRING[1]','W-wniosek; P-plan urlopowy'
               ,'KOD','INTEGER','Numer rubryki');
:: (1) wyszukanie pozycji planu urlopowego
URL_POZ.cntx_psh();
URL_POZ.index('URL_POZ');
URL_PLAN.cntx_psh();
URL_PLAN.index('ROK');
:: szukamy planow we wszystkich latach pomiedzy _od i _do
{! _rok:=_od~1.._do~1
|!
   URL_PLAN.prefix(_p_ref,'A',_rok);
   {? URL_PLAN.first()
   || URL_POZ.prefix(URL_PLAN.ref());
      {? URL_POZ.find_le(_od) | URL_POZ.first()
      || {!
         |? {? URL_POZ.OD<=_do & URL_POZ.DO>=_od
            || {! _ind:=#URL_POZ.OD..#URL_POZ.DO
               |!
                  _add:={? _tab.find_key(#_ind) || 0 || 1 ?};
                  _tab.blank(1);
                  _tab.DATA:=#_ind;
                  _tab.N_WP:='P';
                  _tab.KOD:=11;
                  {? _add || _tab.add() || _tab.put() ?}
               !}
            ?};
            URL_POZ.next()
         !}
      ?}
   ?}
!};
URL_PLAN.cntx_pop();
URL_POZ.cntx_pop();
:: (2) wyszukanie zaakceptowanych wnioskow urlopowych i nadpisanie już istniejacych danych w tabeli tymczasowej
NWU.cntx_psh();
NWU.index('OD');
NWU.prefix(_p_ref);
{? NWU.find_le(_od) | NWU.first()
|| {!
   |? {? NWU.AZ='T' & NWU.OD<=_do & NWU.DO>=_od
      || {! _ind:=#NWU.OD..#NWU.DO
         |!
            _add:={? _tab.find_key(#_ind) || 0 || 1 ?};
            _tab.blank(1);
            _tab.DATA:=#_ind;
            _tab.N_WP:='W';
            _tab.KOD:=NWU.R().RN;
            {? _add || _tab.add() || _tab.put() ?}
         !}
      ?};
      NWU.next()
   !}
?};
NWU.cntx_pop();
_tab


\urlPlan_aktual
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Aktualizacja pozycji planu urlopowego w zakresie wskazanych dat
::   WE: _a [REFERENCE] - P.ref pracownika, ktorego nieobecnosc dotyczy
::       _b [DATE]      - Data badania od
::       _c [DATE]      - Data badania do
::   WY:
::  OLD: \urlPlan_aktual/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
   _od:={? var_pres('_b')=type_of(date) || _b || return(0) ?};
   _do:={? var_pres('_c')=type_of(date) || _c || return(0) ?};
P.cntx_psh();
KAL_DEF.cntx_psh();
URL_PLAN.cntx_psh();
_ndx:=URL_PLAN.ndx_tmp(,1,'P',,,'ROK',,);
URL_PLAN.index(_ndx);
URL_POZ.cntx_psh();
URL_POZ.index('URL_POZ');
{! _rok:=_od~1.._do~1
|!
   URL_PLAN.prefix(_p_ref,_rok);
   {? URL_PLAN.first()
   || {? __KAL.set_cal(URL_PLAN.P().KAL,_rok)
      || {!
         |? {? URL_PLAN.ST='A' | URL_PLAN.ST='K' | URL_PLAN.ST='U'
            ||
               URL_POZ.prefix(URL_PLAN.ref());
               {? URL_POZ.find_le(_od) | URL_POZ.first()
               || {!
                  |? {? URL_POZ.OD<=_do & URL_POZ.DO>=_od
                     || _status:=exec('getPlanStat4Pr','grafik',_p_ref,URL_POZ.OD);
                        {? _status<>'Z' & _status<>'X'
                        || URL_POZ.NR:=__KAL.w_days(URL_POZ.OD,URL_POZ.DO);
                           URL_POZ.NG:=exec('nominal','godziny',URL_POZ.OD,URL_POZ.DO);
                           URL_POZ.put()
                        ?}
                     ?};
                     URL_POZ.next()
                  !}
               ?}
            ?};
            URL_PLAN.next()
         !}
      ?}
   ?}
!};
URL_POZ.cntx_pop();
URL_PLAN.ndx_drop(_ndx);
URL_PLAN.cntx_pop();
KAL_DEF.cntx_pop();
P.cntx_pop()


\dodaj_do_buff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [mk] [12.10]
::  MOD: MicKoc [22.26]
:: OPIS: Tworzy i aktualizuje KAL_BUFF, bufor P i A_OKR ustawiony
::   WE: _a - 'P'/'G'/'W' - planowanie, grafik, wykonanie
::       _b - P.ref
::       _c - A_OKR.ref
::       _d - data od (poczatek przypisania do okresu)
::       _e - data do (koniec przypisania do okresu)
::       _f - (0) - na podstawie kalendarza pracownika,
::            (1) - na podstawie wzorca kalendarza (domyślnie),
::            (2) - na podstawie dnia z KAL_BUFFa - o ile istnieje
::       _g - (0) - nie uwzglednia P.DZA i P.DZ
::            (1) - uwzlednia P.DZA i P.DZ (domyslnie)
::            (2) - uwzlednia P.DZA ale nie P.DZ
::       _h - data od (poczatek zakresu aktualizacji bufora)
::       _i - data do (koniec zakresu aktualizacji bufora)
::   WY: ilosc_zmian
::  OLD: \dodaj_do_buff/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('') || return(0) ?};
{? var_pres('_b')<>type_of(null()) || return(0) ?};
{? var_pres('_c')<>type_of(null()) || return(0) ?};

A_OKR.cntx_psh();
A_OKR.prefix();
{? A_OKR.seek(_c)
|| _tmp:=A_OKR.OD-A_OKR.OD~3;
   _beg:=date(_tmp~1,_tmp~2,1);
   _tmp:=A_OKR.DO;
   _end:=date(_tmp~1,_tmp~2,0)
|| A_OKR.cntx_pop();
   return(0)
?};
{? var_pres('_d')<>type_of(#0) || _d:=_beg ?};
{? var_pres('_e')<>type_of(#0) || _e:=_end ?};
{? var_pres('_f')<>type_of(0) || _f:=1 ?};
{? var_pres('_g')<>type_of(0) || _g:=1 ?};
_akt_od:={? var_pres('_h')=type_of(#0) || _h || _beg ?};
_akt_do:={? var_pres('_i')=type_of(#0) || _i || _end ?};

_buff:=exec('oBuff','prc_plan');

_p_ref:=_b;
_ret_val:=0;
_zdate:=date(0,0,0);

P.cntx_psh();
P.prefix();
{? P.seek(_p_ref)
||
:: czy sprawdzać datę zatrudnienia i zwolnienia
   _pdza_dz:={? _g<>0 & _g<>1 & _g<>2 || 1 || _g ?};
:: sprawdzenie daty zatrudnienia i zwolnienia pracownika
   {? _pdza_dz>0 & (_beg < P.DZA)
   || _beg:=P.DZA
   ?};
   {? _pdza_dz=1 & (P.DZ<>_zdate) & (_end>P.DZ)
   || _end:=P.DZ
   ?};
   _pob:=~-_a;
   _czy_p:=_d;
   _czy_k:=_e;
   _wzorzec:={? _f<>0 & _f<>1 & _f<>2 || 1 || _f ?};
   _czy_okr:=
      "  {? _a>=_b & _a<=_c
         || 1
         || 0
         ?}
      ";
:: określenie zakresu aktualizacji bufora
   _akt_od:={? _akt_od<_beg || _beg || _akt_od ?};
   _akt_do:={? _akt_do>_end || _end || _akt_do ?};
:: sprawdzenie czy jest rok dla grafiku - sprawdzany jest początek i koniec okresu dodawania do bufora
   exec('jest_grafik_rok','grafik',_p_ref,_beg,0);
   exec('jest_grafik_rok','grafik',_p_ref,_end,0);

   A_SCPP.cntx_psh();
   A_SCPP.use('x_scpi');
   A_SCPP.index('POD');
   R.cntx_psh();
   R_WZCZ.cntx_psh();
   R_WZCZ.use('r_wzczas');
   R_WZCZ.index('R_WZWND');
   R_WZCZ.prefix(P.name(),P.ref(),'N','N');
   N.cntx_psh();
   N.index('NIEOBECN');
   N.prefix('N',P.ref);
   H.cntx_psh();
   H.index('_HISTKOD');
   H_UM.cntx_psh();
   A_OKR.clear();

   KAL_BUFF.cntx_psh();
   {? _pob='W'
   || KAL_BUFF.index('PRACDATA');
      KAL_BUFF.prefix(_p_ref)
   || KAL_BUFF.index('PROKRDT');
      KAL_BUFF.prefix(_a,_b,_c)
   ?};

   _wym_do:=_or_do:=_nie_do:=date(1,1,1);
   _wymiar:=
      "  {? var_pres('_b')<>type_of(0) || _b:=0 ?};
         _wym:=1;
         _h_ref:=null();
         H.prefix(P.ref(),'Z');
         {? H.find_le(_a)
         || _h_ref:=H.ref();
            _wym:=H.WYL/H.WYM
         ?};
         {? _b = 1 || _h_ref || _wym ?}
      ";

   __KAL.set_cal(P.KAL,_akt_od~1);
   _kal_nazw:=__KAL.kal_nazw;
   _dzien:=_akt_od;
   _last_nazw:=P.KAL().NAZWA;
   _last_kal_nazw:=_kal_nazw;
::   ustal wymiar zatrudnienia
   _wym_prac:=_wymiar(_dzien);
   _h_ref:=_wymiar(_dzien,1);
::   ustal system czasu pracy
   A_SCPP.prefix(P.ref());
:: wyszukanie ruchomego czasu pracy
   {? var_pres('_tabRuch')>100 || obj_del(_tabRuch) ?};
   _tabRuch:=exec('ruchomy_find','grafik',_p_ref,_akt_od,_akt_do);
:: niepłatne przerwy
   _przerwy:=exec('isEnabled','prc_przerwy');
   {? _przerwy
   || {? var_pres('_tabPrz')>100 || obj_del(_tabPrz) ?};
      _tabPrz:=exec('get4Prac','prc_przerwy',_p_ref,_akt_od,_akt_do)
   ?};

   {!
   |? _dzien<=_akt_do
   |!
:: jeżeli na podstawie wzorca kalendarza to ustaw się na niego
      {? _wzorzec
      || _nazwa:=exec('get_graf_wzor','grafik',P.ref(),_dzien);
         {? __KAL.except(_dzien)
         || __KAL.kal_nazw:=_kal_nazw
         || {? _nazwa<>_last_nazw | __KAL.kal_nazw<>_last_kal_nazw
            || _last_nazw:=_nazwa;
               __KAL.set_cal(_nazwa,_dzien~1);
               _last_kal_nazw:=__KAL.kal_nazw
            ?}
         ?}
      ?};
      {? __KAL.get_day(_dzien)
         &
         {? _pdza_dz || _dzien>=P.DZA || _dzien>=_d ?}
         &
         {? _pdza_dz || _dzien<=P.DZ | P.DZ=#0 || 1 ?}
      || _kal_def:=KAL_DEF.ref();
         _czas_old:=KAL_DEF.CZAS;
         {? _wym_do<>#0 & _dzien>_wym_do
         || _wym_prac:=_wymiar(_dzien);
            _h_ref:=_wymiar(_dzien,1)
         ?};
         {? _dzien>_or_do
         || _or_ref:=exec('find_okr','grafik',P.ref(),_dzien,'okr');
            A_OKRP.cntx_psh();
            A_OKRP.index('A_OKRPR');
            A_OKRP.prefix(_or_ref,_p_ref);
            _do:={? A_OKRP.first()
                 || A_OKRP.DO
                 || _dzien
                 ?};
            A_OKRP.cntx_pop();
            _or_do:={? _or_ref || _do || _or_do ?}
         ?};
         {? (_pob*'P') | (_pob*'G')
         || _add:=~KAL_BUFF.find_key(_dzien);
            {? _add
            || KAL_BUFF.blank();
:: wykorzystanie pola GR do przechowywania normy kalendarza dla pełnego wymiaru zatrudnienia
               KAL_BUFF.GR:=exec('get_kal_norm','grafik',_p_ref,KAL_BUFF.DATA);
               _status:=KAL_DEF.STATUS;
               {? _pob*'G'
               || KAL_BUFF.cntx_psh();
                  KAL_BUFF.index('PRACDATA');
                  KAL_BUFF.prefix(_p_ref,_dzien);
::                sprawdzenie czy jest wykonanie w danym dniu
                  _dalej:=1;
                  {? KAL_BUFF.first()
                  || {!
                     |? {? KAL_BUFF.GPW='W' | KAL_BUFF.GPW='Z'
                        || _dalej:=0; _status:='Z'
                        ?};
                        _dalej & KAL_BUFF.next()
                     !}
                  ?};
                  KAL_BUFF.cntx_pop()
               ?};
               KAL_BUFF.STATUS:=_status;
:: ustawia rodzaj rozliczenia jako godzinowy
               KAL_BUFF.RODZAJ:='G';
:: nadpisujemy rozpoczęcie dnia i zakończenie zgodnie z ruchomym czasem pracy
               {? _tabRuch.find_key(_dzien)
               || {? _tabRuch.DET='T' & KAL_BUFF.TYP='R'
                  || KAL_BUFF.POCZATEK:=_tabRuch.GOD;
                     _czas_do:=_tabRuch.GOD+KAL_BUFF.CZAS;
                     {? _czas_do>=time(24,0,0)
                     || _czas_do-=time(24,0,0);
                        KAL_BUFF.DATAW:=(KAL_BUFF.DATA+1)
                     ?};
                     KAL_BUFF.KONIEC:=(_czas_do)
                  ?}
               ?};
               KAL_BUFF.TYPWS:=_buff.spr_tws(_dzien,KAL_DEF.TYP,KAL_DEF.TYPWS);
               {? _wzorzec=2
               || KAL_BUFF.cntx_psh();
:: dodaje dzień do okresu na podstawie już istniejacych danych o tym dniu w innych okresach
                  KAL_BUFF.index('PRZNODT');
                  KAL_BUFF.prefix(_p_ref,_pob,'T');
                  _jest_b:=KAL_BUFF.find_key(_dzien);
                  {? _jest_b
                  || _buff.push(_dzien)
                  ?};
                  KAL_BUFF.cntx_pop();
:: przepisz informacje z powrotem do bufora
                  {? _jest_b
                  || _buff.pop()
                  ?}
               ?};
               {? _wzorzec=1 | (_wzorzec=2 & ~_jest_b)
               || {? _wym_prac<>1 & __KAL.p_kin(KAL_BUFF.DATA)<>'T'
                  || _czas_new:=*(*_czas_old*_wym_prac);
                     _delta:=_czas_old - _czas_new;
                     KAL_BUFF.KONIEC:=KAL_BUFF.KONIEC-_delta;
                     _nd:=KAL_BUFF.DATAW>KAL_BUFF.DATA;
                     KAL_BUFF.CZAS:=_czas_new;
                     {? (KAL_BUFF.KONIEC + *(_nd*(*time(24,0,0)))) < KAL_BUFF.POCZATEK
                     || KAL_BUFF.KONIEC:=KAL_BUFF.POCZATEK;
                        KAL_BUFF.CZAS:=time(0,0,0)
                     ?}
                  ?}
               ?};
:: przerwy
               {? _przerwy & KAL_DEF.TYP='R' &
                  _tabPrz.find_tab(,
                     'GR_OD',,'<=',_dzien           ,'GR_DO',,'>=',_dzien,
                     'ZM_OD',,'<=',KAL_BUFF.POCZATEK,'ZM_DO',,'>=',KAL_BUFF.POCZATEK,
                     'ZM_OD',,'<=',KAL_BUFF.KONIEC  ,'ZM_DO',,'>=',KAL_BUFF.KONIEC
                  )
               || _p_data:=KAL_BUFF.DATA+(_tabPrz.OD_ND*'T');
                  _prz_od:=exec('create','#tm_stamp',_p_data,_tabPrz.GODZ_OD);
                  _p_do:=_tabPrz.GODZ_OD+_tabPrz.CZAS;
                  _p_nd:=_p_do>time(24,0,0);
                  {? _p_nd || _p_do-=time(24,0,0) ?};
                  _prz_do:=exec('create','#tm_stamp',_p_data+_p_nd,_p_do);
                  _k_od:=exec('create','#tm_stamp',KAL_BUFF.DATA,KAL_BUFF.POCZATEK);
                  _k_do:=exec('create','#tm_stamp',KAL_BUFF.DATAW,KAL_BUFF.KONIEC);
                  {? _prz_od>=_k_od & _prz_do<=_k_do
                  || KAL_BUFF.P_DATA:=_p_data;
                     KAL_BUFF.P_START:=_tabPrz.GODZ_OD;
                     KAL_BUFF.P_CZAS:=_tabPrz.CZAS
                  ?};
                  {? R_ZMIANY.seek(_tabPrz.ZM,,1) || KAL_BUFF.ZMIANA:=R_ZMIANY.ref() ?}
               || _prz_od:=KAL_DEF.P_START+*((KAL_DEF.P_DATA-KAL_DEF.DATA)*(*time(24,0,0)));
                  _zawiera:=exec('zawiera','prc_przerwy',
                     KAL_BUFF.POCZATEK,KAL_BUFF.CZAS+KAL_DEF.P_CZAS,_prz_od,KAL_DEF.P_CZAS);
                  {? _zawiera=1
                  || KAL_BUFF.P_DATA:=KAL_DEF.P_DATA;
                     KAL_BUFF.P_START:=KAL_DEF.P_START;
                     KAL_BUFF.P_CZAS:=KAL_DEF.P_CZAS
                  |? KAL_BUFF.POCZATEK+KAL_BUFF.CZAS<=_prz_od
                  || KAL_BUFF.KONIEC-=KAL_DEF.P_CZAS;
                     KAL_BUFF.P_DATA:=#0;
                     KAL_BUFF.P_START:=KAL_BUFF.P_CZAS:=*0
                  || KAL_BUFF.P_DATA:=#0;
                     KAL_BUFF.P_START:=KAL_BUFF.P_CZAS:=*0
                  ?}
               ?}
            ?};
            KAL_BUFF.GPW:=_pob;
            KAL_BUFF.CZY_OKR:={? _h_ref & _c=_or_ref & _czy_okr(_dzien,_czy_p,_czy_k) || 'T' || 'N' ?};
:: usunięcie informacji o sekundach
            _sek_p:=KAL_BUFF.POCZATEK~3;
            _sek_k:=KAL_BUFF.KONIEC~3;
            _sek_cz:=0;
            {? _sek_p>0 || KAL_BUFF.POCZATEK-=time(0,0,_sek_p); _sek_cz-=_sek_p ?};
            {? _sek_k>0 || KAL_BUFF.KONIEC-=time(0,0,_sek_k); _sek_cz+=_sek_k ?};
            {? _sek_cz<>0  || KAL_BUFF.CZAS-=time(0,0,_sek_cz) ?};

:: wnioski o pracę w nadgodzinach
            {? _add & KAL_BUFF.GPW='G' & _wzorzec<>2
            || _godz:=exec('ile_nadg','prc_nadg',_p_ref,KAL_BUFF.DATA,KAL_BUFF.CZAS);
               {? _godz.ALL>*0
               || {? KAL_BUFF.TYP<>'R' | KAL_BUFF.CZAS=*0
                  || KAL_BUFF.POCZATEK:=_godz.GSTART;
                     KAL_BUFF.KONIEC:=KAL_BUFF.POCZATEK+_godz.ALL
                  || KAL_BUFF.POCZATEK-=_godz.POCZATEK;
                     KAL_BUFF.KONIEC+=_godz.KONIEC
                  ?};
                  {? KAL_BUFF.KONIEC>=time(24,0,0)
                  || KAL_BUFF.DATAW+=1;
                     KAL_BUFF.KONIEC-=time(24,0,0)
                  ?};
                  KAL_BUFF.CZAS+=_godz.ALL;
                  KAL_BUFF.TYPWS:='';
                  KAL_BUFF.TYP:='R'
                ?};
                obj_del(_godz); &_godz
            ?};

:: zapamiętujemy aktualne wartości
            _buff.push(_dzien);

:: jeżeli dzień nie należy do okresu to sprawdzamy czy dzień należy do innego okresu i przepisujemy informację
            {? KAL_BUFF.CZY_OKR='N'
            || KAL_BUFF.cntx_psh();
               KAL_BUFF.index('PRZNODT');
               KAL_BUFF.prefix(_p_ref,_pob,'T');
:: czy jest jakiś zapis na dany dzień należący do innego okresu
               {? KAL_BUFF.find_key(_dzien)
               || _buff.push(_dzien)
               ?};
               KAL_BUFF.cntx_pop();
:: przepisz informacje z powrotem do bufora
               _buff.pop()
            ||
               _status:=KAL_BUFF.STATUS;
:: zmodyfikuj zapisy dla dnia w innych okresach rozliczeniowych
               KAL_BUFF.cntx_psh();
               KAL_BUFF.index('PRACDATA');
               KAL_BUFF.prefix(_p_ref,_dzien);
               {? KAL_BUFF.first()
               || {!
                  |? {? (KAL_BUFF.GPW=_pob)
                     || _buff.pop();
                        KAL_BUFF.STATUS:=_status;
                        KAL_BUFF.CZY_OKR:='N';
                        KAL_BUFF.TM_P:=KAL_BUFF.tm_stamp();
                        KAL_BUFF.put(1)
                     ?};
                     KAL_BUFF.next()
                  !}
               ?};
               KAL_BUFF.cntx_pop()
            ?};
            KAL_BUFF.A_SCP:={? _h_ref & A_SCPP.find_le(_dzien) || A_SCPP.A_SCP || null() ?};
            KAL_BUFF.H:={? _h_ref || H.ref() || null() ?};
            KAL_BUFF.DOP_NADG:=H.DOP_NADG;
            KAL_BUFF.WY:={? _h_ref || H.WYL/H.WYM || 0 ?};
            KAL_BUFF.WYL:={? _h_ref || H.WYL || 0 ?};
            KAL_BUFF.WYM:={? _h_ref || H.WYM || 0 ?};
            KAL_BUFF.GRAFIK:={? _h_ref & R_WZCZ.find_le(_dzien) || R_WZCZ.GRAFIK || 'N' ?};
            KAL_BUFF.TYPWS:=_buff.typws;
            KAL_BUFF.ZMIANA:={? KAL_BUFF.TYP='R' || _buff.zmiana || null() ?};
:: nieobecności
            {? _dzien>_nie_do
            || _kod:=_ref_nh:='';
               {? N.find_le(_dzien) & N.OD<=_dzien & N.DO>=_dzien
               ||
:: pominięcie dodawania nieobecności: macierzyński praca i rodzicielski praca oraz opieki (art 188)
                  _kod_mac:=__RUB.sys_rub(11522,_dzien).RN;
                  _kod_rod:=__RUB.sys_rub(11542,_dzien).RN;
                  _kod_188:=__RUB.sys_rub(1162,_dzien).RN;
                  _kod_n:=N.NB().RN;
                  {? _kod_mac<>_kod_n & _kod_rod<>_kod_n & _kod_188<>_kod_n
                  || _kod:=$_kod_n;
                     _ref_nh:=$N.ref();
                     _nie_do:=N.DO
                  ?}
               ?}
            ?};
            KAL_BUFF.NB:=_kod;
            KAL_BUFF.NH:=_ref_nh;
            _ret_val+={? _add || KAL_BUFF.add() || KAL_BUFF.put() ?}

         |? _pob*'W'
         || KAL_BUFF.prefix(_p_ref,_dzien);
            {? KAL_BUFF.first()
            || {!
               |? {? KAL_BUFF.GPW='W'
                  || KAL_BUFF.A_OKR:=_or_ref;
                     KAL_BUFF.CZY_OKR:='T';
                     _ret_val+=KAL_BUFF.put()
                  ?};
                  KAL_BUFF.next()
               !}
            ?}

         || _ret_val:=0
         ?}
      ?};
      _dzien+=1
   !};
   KAL_BUFF.cntx_pop();
   A_SCPP.cntx_pop();
   R_WZCZ.cntx_pop();
   R.cntx_pop();
   N.cntx_pop();
   H.cntx_pop();
   H_UM.cntx_pop()
?};
P.cntx_pop();
A_OKR.cntx_pop();
_ret_val


\del_A_OKRP
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Kasuje podany rekord tabeli A_OKRP (wykonywane w transakcji!!!)
::   WE: _a - A_OKRP.ref()
::   WY: >0 - wyczyszczone,
::       <=0 - niewyczyszczone
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystapić błąd.
::  OLD: \del_A_OKRP/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_ref:=_a;
_result:=0;
_can_continue:=1;
:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;
{? _mydo || do() ?};
A_OKRP.cntx_psh();
A_OKRP.clear();
{? A_OKRP.seek(_ref)
|| {? exec('clean_A_OKRP','grafik',_ref)>0
   || {? A_OKRP.del(,1)>0
      || _result:=1
      || undo();
         _result:=-3
      ?}
   || _result:=-2
   ?}
|| _result:=0
?};
{? _result<0|| undo() ?};
A_OKRP.cntx_pop();
{? _mydo || end() ?};
_result


\clean_A_OKRP
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Czyści powiązania do rekordu tabeli A_OKRP
::   WE: _a - A_OKRP.ref()
::   WY: >0 - wyczyszczone,
::       <=0 - niewyczyszczone
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::  OLD: \clean_A_OKRP/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? do_state()=2 || return(-100) ?};
{? var_pres('A_OKRP_M')<100 || return(1) ?};
_ref:=_a;
_result:=0;
_can_continue:=1;
_mydo:=do_state()=0;
{? _mydo || do() ?};
:: powiązania do miesiecy pracownika w okresie rozliczeniowym
A_OKRP_M.cntx_psh();
A_OKRP_M.index('A_OKRPM');
A_OKRP_M.prefix(_ref);
{? A_OKRP_M.first()
|| {!
   |? _can_continue:=exec('del_A_OKRP_M','grafik',A_OKRP_M.ref());
      _can_continue>0 & A_OKRP_M.first()
   !}
?};
A_OKRP_M.cntx_pop();
:: powiązania do korekt w okresie rozliczeniowym
{? _can_continue
|| A_OKRP.cntx_psh();
   A_OKRP.prefix();
   {? A_OKRP.seek(_ref)
   || _can_continue:=exec('delAllKor4Prac','kal_korn',A_OKRP.P,A_OKRP.OKR)
   ?};
   A_OKRP.cntx_pop()
?};
:: powiązania do zapisów o błędach planowania
{? _can_continue
|| A_OKRP.cntx_psh();
   A_OKRP.prefix();
   {? A_OKRP.seek(_ref)
   || _can_continue:=exec('del_R_ER','grafik',A_OKRP.ref())
   ?};
   A_OKRP.cntx_pop()
?};
:: dla pozostawionych rekordów KAL_BUFFa wskazujących na okres rozliczeniowy z którego usuwamy właśnie pracownika
:: ustawiamy pole CZY_OKR na N
{? _can_continue
|| A_OKRP.cntx_psh();
   A_OKRP.prefix();
   {? A_OKRP.seek(_ref)
   || _can_continue:=1;
      KAL_BUFF.cntx_psh();
      _ndx:=KAL_BUFF.ndx_tmp('',1,'A_OKR',,0,'P',,0);
      KAL_BUFF.index(_ndx);
      KAL_BUFF.prefix(A_OKRP.OKR,A_OKRP.P);
      {? KAL_BUFF.first()
      || {!
         |? {? KAL_BUFF.GPW<>'W'
            || KAL_BUFF.CZY_OKR:='N';
               _can_continue*=KAL_BUFF.put(1)
            ?};
            KAL_BUFF.next()
         !}
      ?};
      KAL_BUFF.cntx_pop();
      KAL_BUFF.ndx_drop(_ndx)
   ?};
   A_OKRP.cntx_pop()
?};
{? _can_continue>0
|| _result:=1
|| undo()
?};
{? _mydo || end() ?};
_result


\del_A_OKRP_M
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Kasuje podany rekord tabeli A_OKRP_M (wykonywane w transakcji!!!)
::   WE: _a - A_OKRP_M.ref()
::   WY: >0 - wyczyszczone,
::       <=0 - niewyczyszczone
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::  OLD: \del_A_OKRP_M/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_ref:=_a;
_result:=0;
_can_continue:=1;
:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;
{? _mydo || do() ?};
A_OKRP_M.cntx_psh();
A_OKRP_M.clear();
{? A_OKRP_M.seek(_ref)
|| {? A_OKRP_M.del(,1)>0
   || _result:=1
   || undo();
      _result:=-3
   ?}
|| _result:=0
?};
{? _result<0 || undo() ?};
A_OKRP_M.cntx_pop();
{? _mydo || end() ?};
_result


\del_R_ER
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKG [12.41]
:: OPIS: Kasuje zapisy z R_ERRCMS powiązane z podanym rekordem tabeli A_OKRP.ref (wykonywane w transakcji!!!)
::   WE: _a - A_OKRP.ref()
::   WY: >0 -wyczyszczone,
::      <=0 -niewyczyszczone
::----------------------------------------------------------------------------------------------------------------------
:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=0;
_can_continue:=1;

:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;
{? _mydo || do() ?};
A_OKRP.cntx_psh();
A_OKRP.clear();
R_ERRCMS.cntx_psh();
R_ERRCMS.index('R_ERRCMR');
{? A_OKRP.seek(_ref)
|| R_ERRCMS.prefix(_ref);
   {? R_ERRCMS.first()
   || {!|? R_ERRCMS.del() !}
   ?};
   {? R_ERRCMS.size()=0
   || _result:=1
   || undo();
      _result:=-3
   ?}
|| _result:=0
?};

{? _result<0
|| undo()
?};

A_OKRP.cntx_pop();
R_ERRCMS.cntx_pop();
{? _mydo || end() ?};
_result


\ruchomy_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Wyszukuje informacje o ruchomym czasie pracy dla pracownika w zakresie podanych dat
::   WE: _a [REFERENCE] - P.ref pracownika, ktorego nieobecnosc dotyczy
::       _b [DATE]      - Data badania od
::       _c [DATE]      - Data badania do
::   WY:    [TABLE]     - Tabela z informacjami na poszczegolne dni
::  OLD: \ruchomy_find/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(1,'DATA','DATE','Data'
               ,'P','STRING[1]','P-pracownik, F-firma'
               ,'DET','STRING[1]','Czy szczegóły dnia określone'
               ,'W','STRING[1]','T-widełkowy, N-godzinowy'
               ,'GOD','TIME','Godzina od'
               ,'GDO','TIME','Godzina do');
_p_ref:={? var_pres('_a')=type_of(null) || _a || return(_tab) ?};
   _od:={? var_pres('_b')=type_of(date) || _b || return(_tab) ?};
   _do:={? var_pres('_c')=type_of(date) || _c || return(_tab) ?};
{? var_pres('A_RWN')<100 || return(_tab) ?};
::
_sqlWN:='select P,OD,DO,WP,A_RWN.A_RWN,REFERENCE as REF from A_RWN where P=:_a and '+
      'A_RWN.OD<=to_date(:_c) and A_RWN.DO>=to_date(:_b) and A_RWN.WP=\':_d\'';

_sqlWP:=''+"select * from A_RWP where A_RWP.A_RWN=':_a'";

: wyszukanie wniosków indywidualnych
_tabWNI:=sql(_sqlWN,_p_ref,_od,_do,'T');
{? _tabWNI.first()
|| {!
   |? {? var_pres('_tabWPI')>100 || obj_del(_tabWPI) ?};
      _tabWPI:=sql(_sqlWP,_tabWNI.REF);
      _ndx:=_tabWPI.ndx_tmp(,1,'ND',,);
      _tabWPI.index(_ndx);
      _chk_od:={? _tabWNI.OD>_od || _tabWNI.OD || _od ?};
      _chk_do:={? _tabWNI.DO<_do || _tabWNI.DO || _do ?};
      {! _ind:=#_chk_od..#_chk_do
      |! _data:=#_ind;
         _tab.blank(1);
         _tab.DATA:=_data;
         _tab.P:='T';
         _tab.DET:='N';
         _tabWPI.prefix(_data~4);
         {? _tabWPI.first()
         || _tab.GOD:=_tabWPI.GOD;
            _tab.GDO:=_tabWPI.GDO;
            _tab.DET:='T';
            _tab.W:=_tabWPI.W
         ?};
         _tab.add()
      !};
      _tabWPI.ndx_drop(_ndx);
      _tabWNI.next()
   !}
?};
: wyszukanie wniosków grupowych
_tabWNG:=sql(_sqlWN,_p_ref,_od,_do,'N');
{? _tabWNG.first()
|| {!
   |? {? var_pres('_tabWPG')>100 || obj_del(_tabWPG) ?};
      _ref:=null();
      A_RWN.cntx_psh();
      A_RWN.prefix();
      {? A_RWN.seek(_tabWNG.A_RWN,)
      || _ref:=A_RWN.ref()
      ?};
      A_RWN.cntx_pop();
      _tabWPG:=sql(_sqlWP,$_ref);
      _ndx:=_tabWPG.ndx_tmp(,1,'ND',,);
      _tabWPG.index(_ndx);
      _chk_od:={? _tabWNG.OD>_od || _tabWNG.OD || _od ?};
      _chk_do:={? _tabWNG.DO<_do || _tabWNG.DO || _do ?};
      {! _ind:=#_chk_od..#_chk_do
      |! _data:=#_ind;
         _tab.prefix(_data);
         {? ~_tab.first()
         || _tab.blank(1);
            _tab.DATA:=_data;
            _tab.P:='N';
            _tab.DET:='N';
            _tabWPG.prefix(_data~4);
            {? _tabWPG.first()
            || _tab.GOD:=_tabWPG.GOD;
               _tab.GDO:=_tabWPG.GDO;
               _tab.DET:='T';
               _tab.W:=_tabWPG.W
            ?};
            _tab.prefix();
            _tab.add()
         ?}
      !};
      _tabWPG.ndx_drop(_ndx);
      _tabWNG.next()
   !}
?};
_tab.prefix();
_tab


\get_aokrd_do
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Pobiera datę zmiany domyślnego okresu rozliczeniowego wg przekazanej daty
::   WE: _a - P.ref
::       _a - data badania
::       _b - A_OKRN.ref
::   WY: data max
::  OLD: \get_aokrd_do/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')<>type_of(null) || return(0) || _a ?};
_pocz:={? var_pres('_b')<>type_of(#0) || return(0) || _b ?};
_okrnRef:={? var_pres('_c')<>type_of(null) || return(0) || _c ?};
_ret_val:=date(0,0,0);
A_OKRD.cntx_psh();
A_OKRD.index('POD');
A_OKRD.prefix(_p_ref);
{? A_OKRD.find_le(_pocz)
|| _dalej:=1;
   {!
   |? {? A_OKRD.A_OKRN<>_okrnRef
      || _dalej:=0;
         _ret_val:=A_OKRD.OD-1
      ?};
      _dalej & A_OKRD.next()
   !}
?};
A_OKRD.cntx_pop();
_ret_val


\getOkrFromDate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja zwracająca okresy rozliczeniowe od wskazanej daty
::   WE: _a -   [REFERENCE] - P.ref
::       [_b] - [DATE] data - jeżeli data jest datą zerową to zbierane są wszystkie okresy
::       [_c] - [TABLE]     - tabela
::       [_d] - [REFERENCE] - wskazanie na A_OKRN
::       [_e] - [STRING]    - status planowania
::       [_f] - [STRING]    - status okresu
::   WY: tabela z okresami A_OKR
::  OLD: \getOkrFromDate/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_data:={? var_pres('_b')=type_of(#0)  || _b || date(0,0,0) ?};
{? var_pres('_c')=type_of(SYSLOG)
|| _TAB:=_c
|| _TAB:=tab_tmp(1,
      'OD','DATE','Data od',
      'NR','INTEGER','Ref',
      'MASK','STRING[8]','Maska'
   )
?};
_okrn:={? var_pres('_d')=type_of(null()) || _d || null() ?};
_stat_p:={? var_pres('_e')=type_of('_e') || _e || '' ?};
_stat_o:={? var_pres('_f')=type_of('_f') || _f || '' ?};
A_OKR.cntx_psh();
{? _okrn=null()
|| A_OKR.index('A_OKR');
   A_OKR.prefix()
|| A_OKR.index('A_OKRNN');
   A_OKR.prefix(_okrn)
?};
{? A_OKR.first()
|| {!
   |? {? A_OKR.DO>=_data
         &
         (_okrn=null() | A_OKR.NAZ=_okrn)
         &
         (_stat_o='' | _stat_o=A_OKR.S)
         &
         (_stat_p='' | _stat_p=A_OKR.S_PLAN)
      || _TAB.OD:=A_OKR.OD;
         _TAB.NR:=#A_OKR.ref();
         _TAB.MASK:=A_OKR.name();
         _TAB.add()
      ?};
      A_OKR.next()
   !}
?};
A_OKR.cntx_pop();
_TAB


\getOkrpFromDate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja zwracajaca okresy do ktorych przypisany jest pracownik od wskazanej daty
::   WE: _a -   [REFERENCE] - P.ref
::       [_b] - [DATE] data - jeżeli data jest data zerowa to zbierane sa wszystkie okresy
::       [_c] - [TABLE] - tabela
::       [_d] - [REFERENCE] - wskazanie na A_OKRN
::       [_e] - [STRING]    - status planowania
::       [_f] - [STRING]    - status okresu
::       [_g] - [STRING]    - określenie indexu dla zwracanej tabeli (domyslnie 'NR')
::   WY: tabela z okresami A_OKRP
::  OLD: \getOkrpFromDate/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')=type_of(null()) || _a || null() ?};
_data:={? var_pres('_b')=type_of(#0) || _b || date(0,0,0) ?};
_okrn:={? var_pres('_d')=type_of(null()) || _d || null() ?};
_stat_p:={? var_pres('_e')=type_of('_e') || _e || '' ?};
_stat_o:={? var_pres('_f')=type_of('_f') || _f || '' ?};
_index:={? var_pres('_g')=type_of('_g') || _g || '' ?};

{? var_pres('_c')=type_of(SYSLOG)
|| _TAB:=_c
|? _index='OD'
|| _TAB:=tab_tmp(1,
      'OD','DATE','Data od',
      'DO','DATE','Data do',
      'NR','INTEGER','Ref',
      'MASK','STRING[8]','Maska'
   )
|| _TAB:=tab_tmp(1,
      'NR','INTEGER','Ref',
      'MASK','STRING[8]','Maska',
      'OD','DATE','Data od',
      'DO','DATE','Data do'
   )
?};
A_OKR.cntx_psh();
A_OKRP.cntx_psh();
A_OKRP.use('x_okrpi');
A_OKRP.index('A_OKRDP');
{? _p_ref<>null()
|| A_OKRP.prefix(_p_ref);
   {? A_OKRP.first()
   || {!
      |? {? A_OKRP.OKR().DO>=_data
            &
            (_okrn=null() | A_OKRP.OKR().NAZ=_okrn)
            &
            (_stat_o='' | _stat_o=A_OKR.S)
            &
            (_stat_p='' | _stat_p=A_OKRP.S_PLAN)
         || _TAB.NR:=#A_OKRP.ref();
            _TAB.MASK:=A_OKRP.name();
            _TAB.OD:=A_OKRP.OD;
            _TAB.DO:=A_OKRP.DO;
            _TAB.add()
         ?};
         A_OKRP.next()
      !}
   ?}
?};
A_OKRP.cntx_pop();
A_OKR.cntx_pop();
_TAB


\aktKalBuff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Funkcja aktualizuje bufor planowania i grafików dla przekazanych okresów
::   WE: _a - [REFERENCE] - wskazanie na pracownika
::       _b - [DATE]      - data od domyślnego okresu
::       _c - [DATE]      - data do domyślnego okresu
::       _d - [TABLE]     - tabela z okresami do aktualizowania
::       _e - [REFERENCE] - wkazanie na A_OKRN
::       _f - [DATE]      - data informująca do kiedy pracownik jest przypisany obecnie do jakiegokolwiek okresu
::  OLD: \aktKalBuff/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
  _p_ref:={? var_pres('_a')=type_of(null()) || _a || return(0) ?};
_data_od:={? var_pres('_b')=type_of(#0)     || _b || return(0) ?};
_data_do:={? var_pres('_c')=type_of(#0)     || _c || return(0) ?};
  _t_okr:={? var_pres('_d')=type_of(SYSLOG) || _d || return(0) ?};
   _okrn:={? var_pres('_e')=type_of(null()) || _e || return(0) ?};
_okrp_do:={? var_pres('_f')=type_of(#0)     || _f || return(0) ?};

P.cntx_psh();
OSOBA.cntx_psh();
_d_zatr:=_d_zwol:=date(0,0,0);
{? P.seek(_p_ref,,1)
|| _osoba:=P.OSOBA;
   _d_zatr:=P.DZA;
   _d_zwol:=P.DZ
|| OSOBA.cntx_pop();
   P.cntx_pop();
   return(0)
?};

_zdate:=date(0,0,0);

A_OKRP.cntx_psh();
A_OKRP.use('x_okrpi');
A_OKRP.index('A_OKPP');
{? _t_okr.first()
|| A_OKR.cntx_psh();
   {!
   |? {? A_OKR.seek(_t_okr.NR,_t_okr.MASK,1) & A_OKR.S='O' & A_OKR.S_PLAN='O'
      ||
:: dla okresów zgodnych z nazwą domyślnego okresu dodaj odpowiednie zapisy
         {? A_OKR.NAZ=_okrn
         || {? (_data_od<=A_OKR.OD & A_OKR.OD<=_okrp_do) | (_data_od>A_OKR.OD & _data_od<=A_OKR.DO)
            || A_OKRP.prefix(A_OKR.ref(),_p_ref);
               _jest:=_mod:=0;
               {? ~A_OKRP.first()
               || A_OKRP.blank(1);
                  A_OKRP.OKR:=A_OKR.ref();
                  A_OKRP.OD:={? A_OKR.OD<_d_zatr || _d_zatr || A_OKR.OD ?};
                  A_OKRP.DO:={? (_d_zwol=_zdate | _d_zwol>A_OKR.DO) || A_OKR.DO || _d_zwol ?};
                  A_OKRP.P:=_p_ref;
                  A_OKRP.S_PLAN:='O';
                  A_OKRP.OSOBA:=_osoba
               || _b_od:=A_OKRP.OD;
                  _b_do:=A_OKRP.DO;
                  _jest:=1
               ?};
:: ustalenie daty rozpoczęcia okresu
               {? A_OKR.OD<=_data_od & A_OKR.DO>=_data_od
               || A_OKRP.OD:=_data_od
               |? A_OKR.OD>_data_od
               || A_OKRP.OD:=A_OKR.OD
               ?};
:: ustalenie datY zakończenia okresu
               {? _data_do<>#0 & _data_do<=A_OKR.DO
               || _new_do:=_data_do
               || _new_do:=A_OKR.DO
               ?};
               A_OKRP.DO:={? _d_zwol=_zdate | _d_zwol>_new_do || _new_do || A_OKRP.DO ?};

               _add:=_put:=0;
               {? A_OKRP.DO>=A_OKRP.OD
               || {? _jest
                  || {? ((_b_od<>A_OKRP.OD) | (_b_do<>A_OKRP.DO)) & (_data_od<=_b_do)
                     || {? _mod:=A_OKRP.put() || exec('oblicz','okres',0); _put:=1 ?}
                     ?}
                  || {? P.DZA<=A_OKRP.DO & (P.DZ=#0 | P.DZ>=A_OKRP.OD)
                     || {? A_OKRP.add()
                        || exec('oblicz','okres',0);
                           _add:=1
                        ?}
                     ?}
                  ?}
               ?};
:: zaktualizacja buforów planowania na podstawie istniejących zapisow w KAL_BUFF lub na podstawie wzorca
               {? _add | (_put &_mod)
               || exec('dodaj_do_buff','grafik','P',A_OKRP.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,2,2);
                  exec('dodaj_do_buff','grafik','G',A_OKRP.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,2,2);
                  exec('dodaj_do_buff','grafik','W',A_OKRP.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,2,2)
               ?}
            ?}
         ||
:: dla okresów niezgodnych z nazwą domyślnego okresu przytnij lub usuń odpowiednie zapisy
            A_OKRP.prefix(A_OKR.ref(),_p_ref);
            _mod:=0;
            {? A_OKRP.first() & (_data_od<=A_OKRP.OKR().OD | (_data_od>A_OKRP.OKR().OD & _data_od<=A_OKRP.OKR().DO))
            || _b_od:=A_OKRP.OD;
               _b_do:=A_OKRP.DO;
               {? (A_OKRP.OD>=_data_od & (A_OKRP.DO<=_data_do | _data_do=_zdate ))
               || exec('usun_z_buff','grafik','P',_p_ref,A_OKRP.OKR);
                  exec('usun_z_buff','grafik','G',_p_ref,A_OKRP.OKR);
                  exec('del_A_OKRP','grafik',A_OKRP.ref())
               || {? _data_do>=A_OKRP.OD & _data_do<A_OKRP.DO
                  || A_OKRP.OD:=_data_do+1
                  ?};
                  {? _data_od>=A_OKRP.OD & _data_od<A_OKRP.DO
                  || A_OKRP.DO:=_data_od-1
                  ?};
                  {? A_OKRP.DO>=A_OKRP.OD
                  || {? _b_od<>A_OKRP.OD | _b_do<>A_OKRP.DO
                     || {? A_OKRP.put()
                        ||
:: aktualizacja buforów planowania i grafików
                           exec('dodaj_do_buff','grafik','P',A_OKRP.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,2,2);
                           exec('dodaj_do_buff','grafik','G',A_OKRP.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,2,2);
                           exec('dodaj_do_buff','grafik','W',A_OKRP.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,2,2)
                        ?}
                     ?}
                  || exec('usun_z_buff','grafik','P',_p_ref,A_OKRP.OKR);
                     exec('usun_z_buff','grafik','G',_p_ref,A_OKRP.OKR);
                     exec('del_A_OKRP','grafik',A_OKRP.ref())
                  ?}
               ?}
            ?}
         ?}
      ?};
      _t_okr.next()
   !};
   A_OKR.cntx_pop()
?};
A_OKRP.cntx_pop();
OSOBA.cntx_pop();
P.cntx_pop();
1


\usun_z_buff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [mk] [12.10]
:: OPIS: Usuwanie danych z KAL_BUFF w całym okresie rozliczeniowym
::   WE: _a  [STRING]     'P'/'G'/'W' - planowanie, grafik, wykonanie
::       _b  [REFERENCE]  wskazanie na pracownika - P.ref
::       _c  [REFERENCE]  wskazanie na okres rozliczeniowy - A_OKR.ref
::      [_d] [NUMBER]     0/1 - czy wymusić usuwanie?
::      [_e] [DATE]      - usuń od - dodatkowe ograniczenie usuwania danych
::      [_f] [DATE]      - usuń do - dodatkowe ograniczenie usuwania danych
::   WY: liczba usuniętych rekordów
::  OLD: \usun_z_buff/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_warstwa:={? var_pres('_a')=type_of('')   || _a || return(0) ?};
  _p_ref:={? var_pres('_b')=type_of(null) || _b || return(0) ?};
_okr_ref:={? var_pres('_c')=type_of(null) || _c || return(0) ?};
  _force:={? var_pres('_d')=type_of(0)    || _d || 0         ?};
 _del_od:={? var_pres('_e')=type_of(#0)   || _e || #0        ?};
 _del_do:={? var_pres('_f')=type_of(#0)   || _f || #0        ?};

_ret_val:=0;
_z_date:=#0;
_od:=_do:=_z_date;
A_OKRP.cntx_psh();
A_OKRP.index('A_OKPP');
A_OKRP.prefix(_okr_ref,_p_ref);
{? A_OKRP.first()
|| _od:=A_OKRP.OD;
   _do:=A_OKRP.DO
?};
A_OKRP.cntx_pop();

KAL_BUFF.index('PROKRDT');
KAL_BUFF.prefix(_warstwa,_p_ref,_okr_ref);
{? KAL_BUFF.first()
|| _sql:=''+"select * from KAL_BUFF where GPW=':_a' and P=:_b and DATA=to_date(:_c)";
   {!
   |? _data:=KAL_BUFF.DATA;
::    jeżeli nie ma wymuszenia usunięcia, to zostawiamy jeden rekord na dzień, żeby można było odtworzyć planowanie
::    po usunięciu pracownika z okresu rozliczeniowego - te nadmiarowe rekordy będą usuwane podczas zamykania okresu
      _toDel:=_force | (sql(_sql,_warstwa,_p_ref,_data).size()>1);
::    jeżeli mamy zawężenie okresu usuwania danych to usuwamy tylko te zapisy
      {? _del_od<>_z_date & _del_do<>_z_date
      || _toDel:=_toDel*(_data>=_del_od & _data<=_del_do)
      ?};
      _ret_val+={? _toDel || ((_val:=KAL_BUFF.del(,1))<>0) ?};
      {? _toDel || ~(_val=0 | _val=1) || KAL_BUFF.next() ?}
   !}
?};
:: jeżeli jest wymuszone usunięcie danych i znajdziemy jeszcze zapisu osierocone to również je usuwamy
{? _force & _od<>_z_date & _do<>_z_date
|| _sql:=''+"select distinct A_OKR from KAL_BUFF where GPW=':_a' and P=:_b and
             data>=to_date(:_c) and data<=to_date(:_d)";
   _OKR:=sql(_sql,_warstwa,_p_ref,_od,_do);

   {? _OKR.first()
   || {!
      |? _okr_ref:=exec('FindAndGet','#table',A_OKR,_OKR.A_OKR,,,null());
         exec('usun_z_buff_ORP','grafik',_okr_ref,_p_ref,_warstwa,_od,_do);
         _OKR.next()
      !}
   ?}
?};
_ret_val


\usun_z_buff_ORP
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51]
:: OPIS: Usuwanie rekordów KAL_BUFF w calym okresie rozliczeniowym, dla których nie ma pracownika z A_OKRP
::       (ORP - orphant)
::   WE: _a  [REFERENCE] - wskazanie na okres rozliczeniowy
::      [_b] [REFERENCE] - wskazanie na pracownika
::      [_c] [STRING]    - 'P'/'G'/'W' - planowanie, grafik, wykonanie
::      [_d] [DATE]      - usuń od - dodatkowe ograniczenie usuwania danych
::      [_e] [DATE]      - usuń do - dodatkowe ograniczenie usuwania danych
::   WY: liczba usuniętych rekordów
::  OLD: \usun_z_buff_ORP/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_okr_ref:={? var_pres('_a')=type_of(null) || _a || return(_result) ?};
  _p_ref:={? var_pres('_b')=type_of(null) || _b || null()          ?};
_warstwa:={? var_pres('_c')=type_of('')   || _c || ''              ?};
 _del_od:={? var_pres('_d')=type_of(#0)   || _d || #0              ?};
 _del_do:={? var_pres('_e')=type_of(#0)   || _e || #0              ?};

:: powrot w przypadku zerwanej transakcji
{? do_state()=2 || return(_result) ?};

:: zalozenie transakcji
_mydo:=do_state()=0;
{? _mydo || do() ?};

:: pobieramy wszystkich pracowników, którzy mają w KAL_BUFFie zapisy dla wskazanego okresu rozliczeniowego
_sql:=''+"
   select distinct P from KAL_BUFF where KAL_BUFF.A_OKR=:_a
";
{? _p_ref
|| _sql+=" and KAL_BUFF.P=:_b"
?};

_tabPrac:={? _p_ref || sql(_sql,_okr_ref,_p_ref) || sql(_sql,_okr_ref) ?};

{? _tabPrac.first()
|| A_OKRP.cntx_psh();
   A_OKRP.use('x_okrpi');
   A_OKRP.index('A_OKPP');
   {!
   |? _p_ref:=exec('FindAndGet','#table',P,_tabPrac.P,,,null());
::    sprawdzamy czy pracownik jest jeszcze w okresie rozliczeniowym
::    jeżeli go już nie ma, to usuwamy już niepotrzebne rekordy KAL_BUFFa
      {? _p_ref<>null()
      || A_OKRP.prefix(_okr_ref,_p_ref);
         {? A_OKRP.size()=0
         || {? _warstwa='' | _warstwa='P'
            || _result+=exec('usun_z_buff','grafik','P',_p_ref,_okr_ref,1,_del_od,_del_do)
            ?};
            {? _warstwa='' | _warstwa='G'
            || _result+=exec('usun_z_buff','grafik','G',_p_ref,_okr_ref,1,_del_od,_del_do)
            ?};
            {? _warstwa='' | _warstwa='W'
            || _result+=exec('usun_z_buff','grafik','W',_p_ref,_okr_ref,1,_del_od,_del_do)
            ?}
         ?}
      ?};
      _tabPrac.next()
   !};
   A_OKRP.cntx_pop()
?};

{? _mydo || end() ?};
_result


\nadmiar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.10]
:: OPIS: Pobranie tabeli o nadmiarach w okresie rozliczeniowym
::   WE: _a - P.ref
::       _b - A_OKR.ref
::   WY: tabela zwracajaca pola:
::       [DT] DATE - Data
::       [RN] INTEGER - Nr rubryki
::       [RT]  STRING - Tresc rubryki
::       [WORK] - INTEGER <0,1> Czy dzien roboczy
::       [TYP] STRING - Rodzaj godzin R,W,S
::       [G] TIME - ilość godzin
::       [KK] STRING - Symbol konta kosztow
::       [REF_K] STRING - Ref konta kosztow
::  OLD: \nadmiar/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
{? P.seek(_a) & A_OKR.seek(_b) & A_OKR.S='O'
|| A_OKRP.index('A_OKRPR');
   A_OKRP.prefix();
   {? A_OKRP.find_key(A_OKR.ref(),P.ref())
   || _roznica:=exec('roznica','prc_rozlicz',A_OKRP.OD,A_OKRP.DO);
      _poc:=A_OKRP.OD;
      _kon:=A_OKRP.DO;
      __KAL.set_cal(P.KAL,_poc~1);
      _TAB:=sql('select DT, RN, RT, WORK, TYP, G, KK, REF_K from :_a',
         exec('mozliwe_odbiory','prc_rozlicz',_poc,_kon,_roznica)
      )
   ?}
?};
{? var_pres('_TAB')>100
|| _TAB
|| _TAB:=tab_tmp(1,'DT','DATE','Data',
      'RN','INTEGER','Numer',
      'RT','STRING[20]','Opis',
      'WORK','INTEGER','Roboczy',
      'TYP','STRING[1]','Typ',
      'G','TIME','Godziny',
      'KK','STRING[35]','Konto kosztów',
      'REF_K','STRING[16]','Ref konta kosztów'
   )
?};
_TAB


\nieobecnosc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [17.42]
:: OPIS: Zwraca kod nieobecności na podany dzień.
::   WE:  _a - [REFERENCE] - P.ref, wskazanie na pracownika
::        _b - [DATE] - data, data badania
::   WY: 0 - brak nieobecności
::       int - numer rubryki określajacej kod nieobecności
::  OLD: \nieobecnosc/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')<>type_of(null()) || return(0) || _a ?};
{? var_pres('_b')<>type_of(date()) || return(0) ?};
_niebecn:=0;

N.index('NIEOBECN');
N.prefix('N',_p_ref);
{? N.find_le(_b) & N.DO>=_b
|| _niebecn:=N.NB().RN
?};
_niebecn


\getMscCloseDate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.41]
:: OPIS: Pobiera datę zamknięcia miesiąca do rozliczenia
::   WE:  _a [DATA]    - data sprawdzenia
::        _b [INTEGER] - czy uwzględniać zamknięcie następnego miesiąca
::   WY: data zamknięcia miesiąca lub data zerowa
::  OLD: \getMscCloseDate/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_data:={? var_pres('_a')=type_of(#0) || _a || return('') ?};
_chkNMC:={? var_pres('_b')=type_of(0) || _b || 0 ?};
{? var_pres('__HARM')<100 || exec('__HARM','object') ?};
_rok:=_data~1;
_msc:=_data~2;
_r_nast:=_rok;
_m_nast:={? _msc=12 || _r_nast+=1; 1 || _msc+1 ?};
_closeD:=date(0,0,0);

A_OKRM.cntx_psh();
A_OKRM.index('A_OKRMR');
A_OKRM.prefix(_rok,_msc);
{? A_OKRM.first() & A_OKRM.S='Z'
|| _closeD:=A_OKRM.DZ;
:: Sprawdzenie czy następny miesąc jest zamknięty
   _lastDay:=date(_rok,_msc,0);
   {? _chkNMC
   || A_OKRM.prefix(_r_nast,_m_nast);
      {? A_OKRM.first() & A_OKRM.S='Z' & __HARM.ZAMK_MIE<>#A_OKRM.ref()
      || _closeD:=_lastDay
      ?}
   ?}
?};
A_OKRM.cntx_pop();
_closeD


\is_prac_in_okrp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51]
:: OPIS: Funkcja zwracajaca informację, czy w podanym zakresie dat pracownik jest przypisany do okresu rozliczeniowego
::   WE:  _a  - [REFERENCE] - wskazanie na pracownika
::       [_b] - [DATE] data od - początek zakresu
::       [_c] - [DATE] data do - koniec zakresu
::       [_d] - [STRING]    - status planowania
::       [_e] - [STRING]    - status okresu
::   WY: tabela z informacjami o datach, w których pracownik znajduje się w otwartych okresach rozliczeniowych
::       w ramach badanego zakresu dat (np. okres trwania nieobecności)
::  OLD: \is_prac_in_okrp/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
  _p_ref:={? var_pres('_a')=type_of(null) || _a || null() ?};
_data_od:={? var_pres('_b')=type_of(date) || _b || #0     ?};
_data_do:={? var_pres('_c')=type_of(date) || _c || #0     ?};
 _stat_p:={? var_pres('_d')=type_of('_d') || _d || ''     ?};
 _stat_o:={? var_pres('_e')=type_of('_e') || _e || ''     ?};

:: pobieram wszystkie okresy pracownika od wskazanej daty otwarte do rozliczenia
_t_okrp:=exec('getOkrpFromDate','grafik',_p_ref,_data_od,,,_stat_p,_stat_o);

_res:=tab_tmp(1,'OD','DATE','Data od','DO','DATE','Data do');

:: sprawdzenie czy w podanym zakresie dat mamy jakiś okres z otwartym rozliczeniem
{? _t_okrp.first()
|| {!
   |? {? _t_okrp.OD<=_data_do & _t_okrp.DO>=_data_od
      || _res.OD:={? _t_okrp.OD<_data_od || _data_od || _t_okrp.OD ?};
         {? _res.OD>_t_okrp.DO || _res.OD:=_t_okrp.DO ?};
         _res.DO:={? _t_okrp.DO>_data_do || _data_do || _t_okrp.OD ?};
         {? _res.DO<_t_okrp.OD || _res.OD:=_t_okrp.OD ?};
         _res.add()
      ?};
      _t_okrp.next()
   !}
?};
_res

:Sign Version 2.0 jowisz:1045 2024/01/25 09:29:08 52ce944615cb26a43a07eeaf848d3baeffb7a4c9592e29c09f959c9bd4cd1b682d16c0e697a961e0df627fcb005e3b4d45c003ca85eed8781a477a081b18f47339c0004a6fe218557d770f01fbec57b57800213991c4fa0b0797ef1e20991e7e5e3629ae29cb1cbb3ae7fba4286172958a883bedbcdba834ea46e196b48aa9d6
