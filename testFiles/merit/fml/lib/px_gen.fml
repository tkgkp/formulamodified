:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku:  px_gen.fml [12.10]
:: Utworzony: 2011-06-30
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Generowanie pojemnikow do wielowymiarowego planu pojemnosciowego
::======================================================================================================================


\cup_generator
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Glowna funkcja generujaca pojemniki kontenera. Wywoluje formule na pojemnik kontenera
::       co krok okreslony w parametrze 50351 (rozdzielczosc planu)
::   WE: _a - PX_KONT.ref()
::       [_b] - STARTD - Data poczatku przetwarzania (domyslnie dzis)
::       [_c] - ENDD - Data konca przetwarzania  (domyslnie dzis+horyzont)
::       [_d] - 0 / 1 - widocznosc progressa (domyslnie 0)
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
{? _<1
|| return()
?};
exec('opernast_init','px_init');
{? var_pres('KAL')<100
|| exec('declare','kalendarz');
   KAL:=obj_new(@.CLASS.KALEND)
?};

::parametry poczatkowe
_kont_real:=_a;
_minute_stamp:=exec('minute','#tm_stamp');
_step:=exec('get','#params',500351);
_days_max:=exec('get','#params',500350);

_startd:=date();

_endd:=date()+_days_max;
_prog_vis:=0;

{? var_pres('_b')=type_of(date())
|| _startd:=_b
?};
{? var_pres('_c')=type_of(date())
|| _endd:=_c
?};
{? var_pres('_d')=type_of(1)
|| _prog_vis:=_d
?};

_ok:=0;
_can_continue:=1;
_all_ok:=1;
PX_KONT.cntx_psh();
PX_KONT.index('UID');
PX_KONT.clear();
{? PX_KONT.seek(_kont_real)
|| _offset:=PX_KONT.OFFSET;
   _startt:=_offset;
   _endt:=_offset;

   _msg:='Generowanie pojemników dla zasobu: %1'@[PX_KONT.SYMBOL+' '+PX_KONT.NAZWA];
   _lp_msg1:=KOMM.sect_beg(_msg);
   _step_stamp:=_minute_stamp*_step;
   _start_stamp:=tm_stamp(_startd~1,_startd~2,_startd~3,_startt~1,_startt~2,_startt~3,0);
   _end_stamp:=tm_stamp(_endd~1,_endd~2,_endd~3,_endt~1,_endt~2,_endt~3,0);

   _cur_stamp:=_start_stamp;
   _cup_form:=$('
      _kont:=_a; _begin:=_b; _end:=_c; _rozdz:=_d;
      _ok:='+PX_KONT.CUPEQ().RULE+';
      {? type_of(_ok)=type_of(0) || _ok || 0 ?}
   ');
   {? PX_VAR.NAST_ALG=2 & PX_KONT.KAL<>null()
   || KAL.no_err(1);
::    Sprawdzam czy jest kalendarz na początku i na koncu okresu w którym będę generował
      _cal_ok:=KAL.set_cal(PX_KONT.KAL,_startd~1);
      _rok:='';
      {? _cal_ok=0
      || _rok:=$(_startd~1)
      ?};
      {? _cal_ok>0
      || _cal_ok:=KAL.set_cal(PX_KONT.KAL,_endd~1);
         {? _cal_ok=0
         || _rok:=$(_endd~1)
         ?}
      ?};
      {? _cal_ok=0
      || _can_continue:=0;
         _all_ok:=0;
         KOMM.add('Brak kalendarza dla zasobu: %1 w roku: %2, pojemniki nie zostały wygenerowane.'@[PX_KONT.SYMBOL,_rok],2,,1)
      ?}
   ?};

   {? _can_continue>0
   ||
::    GLOWNA PETLA GENERUJACA
      {!
      |?
         {? PX_VAR.NAST_ALG=2
         ||
::          Algorytm następstwa czasowego metodą proporcji czasowej
::          pojemniki są generowane zawsze wg kalendarza
            _ok:=exec('gen_calend','px_gen',_kont_real,_cur_stamp,_cur_stamp+_step_stamp,_step_stamp)

         ||
::          wykonuje formule na pojemnik dla kontenera rzeczywistego
            _ok:=_cup_form(_kont_real,_cur_stamp,_cur_stamp+_step_stamp,_step_stamp)
         ?};

         {? _ok<=0
         || _all_ok:=0
         ?};
         _cur_stamp+=_step_stamp;

         _cur_stamp<=_end_stamp
      !};
::    inicjalizacja pojemnosci dla kontenera widokowego - musi byc po wygenerowaniu wszystkich pojemnikow
::    rzeczywistych bo pojemnosci widokowe wynikaja z ilorazu pojemnosci rzeczywistych przez liczbe pojemnikow
::    widokowych wskazujacych na ten sam kontener rzeczywisty
      exec('capacity_init','px_gen',PX_KONT.ref(),_start_stamp,_end_stamp);

::    po wygenerowaniu pojemnikow nawijam wersji do ktorej nalezal kontener nowe granice czasowe
      exec('dates_recreate','px_ver',PX_KONT.PX_VER)
   ?};

   KOMM.sect_end();

:: Jesli wszystko przebieglo w porzadku to usuwam sekcje komunikatu
   {? _all_ok>0
   || KOMM.del(_lp_msg1)
   ?}
?};
PX_KONT.cntx_pop();
_all_ok


\gen_4resolution
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Generuje pojemniki zgodne z rodzielczoscia planu
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - Poczatek przetwarzania
::       _c - tm_stamp() - Koniec przetwarzania
::       _d - tm_stamp() - Globalna rozdzielczosc planu
::   WY: 0 - porazka
::       REAL - tm_stamp() konca ostatniego wygenerowanego pojemnika
::----------------------------------------------------------------------------------------------------------------------
{? _<4 || return() ?};
_kont:=_a;

::przeksztalcam tm_stampy na daty i czas
_form1:=tm_form(_b);
_form2:=tm_form(_c);
_rozdzielczosc:=_d;

_result:=0;

_date1:=date(  #(4+_form1),
               #(2 + (5-_form1)),
               #(2 + (8-_form1)));

_time1:=time(  #(2 + (11-_form1)),
               #(2 + (14-_form1)),
               #(2 + (17-_form1)));

_date2:=date(  #(4+_form2),
               #(2 + (5-_form2)),
               #(2 + (8-_form2)));

_time2:=time(  #(2 + (11-_form2)),
               #(2 + (14-_form2)),
               #(2 + (17-_form2)));

:: granice czasowe pojemnika
_start:=tm_stamp(_date1~1,_date1~2,_date1~3,_time1~1,_time1~2,_time1~3,0);
_end:=tm_stamp(_date2~1,_date2~2,_date2~3,_time2~1,_time2~2,_time2~3,0);

:: dodaje pojemnik
_ok:=exec('cup_add','px_gen',_kont,_start,_end,$_date1+' - '+$_time1,(($_date1)+5)+' '+(2+($_time1)),_rozdzielczosc);
_ok


\gen_2zmiany
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Generuje 2 zmianowe pojemniki na dzien (dni wszystkie)
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - Poczatek przetwarzania
::       _c - tm_stamp() - Koniec przetwarzania (parametr obowiazkowy - w tej formule nie jest uzywany!)
::       _d - tm_stamp() - Globalna rozdzielczosc planu
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
{? _<4 || return() ?};
_kont:=_a;
_offset:=PX_KONT.OFFSET;

::przeksztalcam tm_stampy na daty i czas
_tm_start:=_b;
_rozdzielczosc:=_d;

_ok1:=_ok2:=0;
_result:=0;

_date_zero:=exec('tm_stamp2date','#tm_stamp',_tm_start);
_startd:=_date_zero;
_endd:=_date_zero;
::--------------------------------------zmiana 1
_t1:=_offset;
_t2:=_offset+time(8,0,0);

{? _t2>=time(24,0,0)
|| _endd:=_date_zero+1;
   _t2:=_t2-time(24,0,0)
?};

::granice czasowe pojemnika
_start:=exec('create','#tm_stamp',_startd,_t1);
_end:=exec('create','#tm_stamp',_endd,_t2);

::dodaje pojemnik
_ok1:=exec('cup_add','px_gen',_kont,_start,_end,'Zmiana 1 ('+$_startd+')',(($_startd)+5)+'-1',_rozdzielczosc);

::--------------------------------------zmiana 1

{? _ok1>0
||
:: --------------------------------------zmiana 2
   _t1:=_offset+time(8,0,0);
   _t2:=_offset+time(16,0,0);

   {? _t1>=time(24,0,0)
   || _startd:=_date_zero+1;
      _t1:=_t1-time(24,0,0)
   ?};
   {? _t2>=time(24,0,0)
   || _endd:=_date_zero+1;
      _t2:=_t2-time(24,0,0)
   ?};

:: granice czasowe pojemnika
   _start:=exec('create','#tm_stamp',_startd,_t1);
   _end:=exec('create','#tm_stamp',_endd,_t2);

:: dodaje pojemnik
   _ok2:=exec('cup_add','px_gen',_kont,_start,_end,'Zmiana 2 ('+$_startd+')',(($_startd)+5)+'-2',_rozdzielczosc)
:: --------------------------------------zmiana 2
?};

{? _ok1>0 & _ok2>0
|| _result:=1
?};
_result


\gen_2zmiany_wrk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Generuje 2 zmianowe pojemniki na dzien (dni robocze)
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - Poczatek przetwarzania
::       _c - tm_stamp() - Koniec przetwarzania (parametr obowiazkowy - w tej formule nie jest uzywany!)
::       _d - tm_stamp() - Globalna rozdzielczosc planu
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
{? _<4 || return() ?};
_kont:=_a;
_offset:=PX_KONT.OFFSET;

::przeksztalcam tm_stampy na daty i czas
_tm_start:=_b;
_rozdzielczosc:=_d;

_ok1:=_ok2:=1;
_result:=0;

_date_zero:=exec('tm_stamp2date','#tm_stamp',_tm_start);
_startd:=_date_zero;
_endd:=_date_zero;

::--------------------------------------zmiana 1
_t1:=_offset;
_t2:=_offset+time(8,0,0);

{? _t2>=time(24,0,0)
|| _endd:=_date_zero+1;
   _t2:=_t2-time(24,0,0)
?};

::dzien tygodnia - dni robocze to te od poniedzialku do piatku
_dzien_tygodnia:=_date_zero~4;

::badam czy _date1 jest swietem (sprawdzam zapis w tabelce DATYW)
_swieto:=0;
DATYW.cntx_psh();
DATYW.index('DATA');
DATYW.prefix('pl_PL',_startd);
{? DATYW.first()
|| {? DATYW.KIND='S'
   || _swieto:=1
   ?}
?};
DATYW.cntx_pop();

:: jesli dzien tygodnia mniejszy od soboty i dzien nie jest swietem to go dodaje do kontenera
{? _dzien_tygodnia<6 & _swieto=0
||
:: granice czasowe pojemnika
   _start:=exec('create','#tm_stamp',_startd,_t1);
   _end:=exec('create','#tm_stamp',_endd,_t2);

:: dodaje pojemnik
   _ok1:=exec('cup_add','px_gen',_kont,_start,_end,'Zmiana 1 ('+$_startd+')',(($_startd)+5)+'-1',_rozdzielczosc);

::--------------------------------------zmiana 1

   {? _ok1>0
   ||
:: --------------------------------------zmiana 2
      _t1:=_offset+time(8,0,0);
      _t2:=_offset+time(16,0,0);

      {? _t1>=time(24,0,0)
      || _startd:=_date_zero+1;
         _t1:=_t1-time(24,0,0)
      ?};
      {? _t2>=time(24,0,0)
      || _endd:=_date_zero+1;
         _t2:=_t2-time(24,0,0)
      ?};

::    granice czasowe pojemnika
      _start:=exec('create','#tm_stamp',_startd,_t1);
      _end:=exec('create','#tm_stamp',_endd,_t2);

::    dodaje pojemnik
      _ok2:=exec('cup_add','px_gen',_kont,_start,_end,'Zmiana 2 ('+$_startd+')',(($_startd)+5)+'-2',_rozdzielczosc)
:: --------------------------------------zmiana 2
   ?}
?};

{? _ok1>0 & _ok2>0
|| _result:=1
?};
_result


\gen_3zmiany
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Generuje 3 zmianowe pojemniki na dzien (dni wszystkie)
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - Poczatek przetwarzania
::       _c - tm_stamp() - Koniec przetwarzania (parametr obowiazkowy - w tej formule nie jest uzywany!)
::       _d - tm_stamp() - Globalna rozdzielczosc planu
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
{? _<4 || return() ?};
_kont:=_a;
_offset:=PX_KONT.OFFSET;

::przeksztalcam tm_stampy na daty i czas
_tm_start:=_b;
_rozdzielczosc:=_d;

_ok1:=_ok2:=_ok3:=0;
_result:=0;

_date_zero:=exec('tm_stamp2date','#tm_stamp',_tm_start);
_startd:=_date_zero;
_endd:=_date_zero;

::--------------------------------------zmiana 1
_t1:=_offset;
_t2:=_offset+time(8,0,0);

{? _t2>=time(24,0,0)
|| _endd:=_date_zero+1;
   _t2:=_t2-time(24,0,0)
?};

::granice czasowe pojemnika
_start:=exec('create','#tm_stamp',_startd,_t1);
_end:=exec('create','#tm_stamp',_endd,_t2);

::dodaje pojemnik
_ok1:=exec('cup_add','px_gen',_kont,_start,_end,'Zmiana 1 ('+$_startd+')',(($_startd)+5)+'-1',_rozdzielczosc);
::--------------------------------------zmiana 1

{? _ok1>0
||
:: --------------------------------------zmiana 2
   _t1:=_offset+time(8,0,0);
   _t2:=_offset+time(16,0,0);

   {? _t1>=time(24,0,0)
   || _startd:=_date_zero+1;
      _t1:=_t1-time(24,0,0)
   ?};
   {? _t2>=time(24,0,0)
   || _endd:=_date_zero+1;
      _t2:=_t2-time(24,0,0)
   ?};

:: granice czasowe pojemnika
   _start:=exec('create','#tm_stamp',_startd,_t1);
   _end:=exec('create','#tm_stamp',_endd,_t2);

:: dodaje pojemnik
   _ok2:=exec('cup_add','px_gen',_kont,_start,_end,'Zmiana 2 ('+$_startd+')',(($_startd)+5)+'-2',_rozdzielczosc);
:: --------------------------------------zmiana 2

::--------------------------------------zmiana 3
   {? _ok2>0
   ||
      _t1:=_offset+time(16,0,0);
      _t2:=_offset+time(24,0,0);

      {? _t1>=time(24,0,0)
      || _startd:=_date_zero+1;
         _t1:=_t1-time(24,0,0)
      ?};
      {? _t2>=time(24,0,0)
      || _endd:=_date_zero+1;
         _t2:=_t2-time(24,0,0)
      ?};

::    granice czasowe pojemnika
      _start:=exec('create','#tm_stamp',_startd,_t1);
      _end:=exec('create','#tm_stamp',_endd,_t2);

::    dodaje pojemnik
      _ok3:=exec('cup_add','px_gen',_kont,_start,_end,'Zmiana 3 ('+$_startd+')',(($_startd)+5)+'-3',_rozdzielczosc)
::    --------------------------------------zmiana 3
   ?}
?};

{? _ok1>0 & _ok2>0 & _ok3
|| _result:=1
?};
_result


\gen_3zmiany_wrk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Generuje 3 zmianowe pojemniki na dzien (dni robocze)
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - Poczatek przetwarzania
::       _c - tm_stamp() - Koniec przetwarzania (parametr obowiazkowy - w tej formule nie jest uzywany!)
::       _d - tm_stamp() - Globalna rozdzielczosc planu
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
{? _<4 || return() ?};
_kont:=_a;
_offset:=PX_KONT.OFFSET;

::przeksztalcam tm_stampy na daty i czas
_tm_start:=_b;
_rozdzielczosc:=_d;

_ok1:=_ok2:=_ok3:=1;
_result:=0;

_date_zero:=exec('tm_stamp2date','#tm_stamp',_tm_start);
_startd:=_date_zero;
_endd:=_date_zero;

::--------------------------------------zmiana 1
_t1:=_offset;
_t2:=_offset+time(8,0,0);

{? _t2>=time(24,0,0)
|| _endd:=_date_zero+1;
   _t2:=_t2-time(24,0,0)
?};

::dzien tygodnia - dni robocze to te od poniedzialku do piatku
_dzien_tygodnia:=_date_zero~4;

::badam czy _date1 jest swietem (sprawdzam zapis w tabelce DATYW)
_swieto:=0;
DATYW.cntx_psh();
DATYW.index('DATA');
DATYW.prefix('pl_PL',_startd);
{? DATYW.first()
|| {? DATYW.KIND='S'
   || _swieto:=1
   ?}
?};
DATYW.cntx_pop();

:: jesli dzien tygodnia mniejszy od soboty i dzien nie jest swietem to go dodaje do kontenera
{? _dzien_tygodnia<6 & _swieto=0
||
:: granice czasowe pojemnika
   _start:=exec('create','#tm_stamp',_startd,_t1);
   _end:=exec('create','#tm_stamp',_endd,_t2);
:: dodaje pojemnik
   _ok1:=exec('cup_add','px_gen',_kont,_start,_end,'Zmiana 1 ('+$_startd+')',(($_startd)+5)+'-1',_rozdzielczosc);
::--------------------------------------zmiana 1

   {? _ok1>0
   ||
::    --------------------------------------zmiana 2
      _t1:=_offset+time(8,0,0);
      _t2:=_offset+time(16,0,0);

      {? _t1>=time(24,0,0)
      || _startd:=_date_zero+1;
         _t1:=_t1-time(24,0,0)
      ?};
      {? _t2>=time(24,0,0)
      || _endd:=_date_zero+1;
         _t2:=_t2-time(24,0,0)
      ?};

::    granice czasowe pojemnika
      _start:=exec('create','#tm_stamp',_startd,_t1);
      _end:=exec('create','#tm_stamp',_endd,_t2);

::    dodaje pojemnik
      _ok2:=exec('cup_add','px_gen',_kont,_start,_end,'Zmiana 2 ('+$_startd+')',(($_startd)+5)+'-2',_rozdzielczosc);
:: --------------------------------------zmiana 2

::--------------------------------------zmiana 3
      {? _ok2>0
      ||
         _t1:=_offset+time(16,0,0);
         _t2:=_offset+time(24,0,0);

         {? _t1>=time(24,0,0)
         || _startd:=_date_zero+1;
            _t1:=_t1-time(24,0,0)
         ?};
         {? _t2>=time(24,0,0)
         || _endd:=_date_zero+1;
            _t2:=_t2-time(24,0,0)
         ?};

         _start:=exec('create','#tm_stamp',_startd,_t1);
         _end:=exec('create','#tm_stamp',_endd,_t2);

::       dodaje pojemnik
         _ok3:=exec('cup_add','px_gen',_kont,_start,_end,'Zmiana 3 ('+$_startd+')',(($_startd)+5)+'-3',_rozdzielczosc)
::    --------------------------------------zmiana 3
      ?}
   ?}
?};

{? _ok1>0 & _ok2>0 & _ok3
|| _result:=1
?};
_result


\gen_dni_all
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Generuje pojemniki dla wszystkich dni
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - Poczatek przetwarzania
::       _c - tm_stamp() - Koniec przetwarzania (parametr obowiazkowy - w tej formule nie jest uzywany!)
::       _d - tm_stamp() - Globalna rozdzielczosc planu
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
{? _<4 || return() ?};
_kont:=_a;
_offset:=PX_KONT.OFFSET;

_dni:=obj_new(7);
_dni[1]:='Pn'@;
_dni[2]:='Wt'@;
_dni[3]:='Śr'@;
_dni[4]:='Czw'@;
_dni[5]:='Pt'@;
_dni[6]:='Sb'@;
_dni[7]:='Nd'@;

::przeksztalcam tm_stampy na daty i czas
_form1:=tm_form(_b);
_rozdzielczosc:=_d;

_result:=1;

_date1:=date(  #(4+_form1),
               #(2 + (5-_form1)),
               #(2 + (8-_form1)));

_t1:=_offset;
_t2:=_offset;

::granice czasowe pojemnika
_start:=tm_stamp(_date1~1,_date1~2,_date1~3,_t1~1,_t1~2,_t1~3,0);
_end:=tm_stamp((_date1+1)~1,(_date1+1)~2,(_date1+1)~3,_t2~1,_t2~2,_t2~3,0);

::dodaje pojemnik
_symbol:=$_date1+' - '+_dni[_date1~4];
_label:=($_date1)+5;
_result:=exec('cup_add','px_gen',_kont,_start,_end,_symbol,_label,_rozdzielczosc);
_result


\gen_dni_work
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Generuje pojemniki dla dni roboczych
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - Poczatek przetwarzania
::       _c - tm_stamp() - Koniec przetwarzania (parametr obowiazkowy - w tej formule nie jest uzywany!)
::       _d - tm_stamp() - Globalna rozdzielczosc planu
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
{? _<4 || return() ?};
_kont:=_a;
_offset:=PX_KONT.OFFSET;

_dni:=obj_new(7);
_dni[1]:='Pn';
_dni[2]:='Wt';
_dni[3]:='Śr';
_dni[4]:='Czw';
_dni[5]:='Pt';
_dni[6]:='Sb';
_dni[7]:='Nd';

::przeksztalcam tm_stampy na daty i czas
_form1:=tm_form(_b);
_rozdzielczosc:=_d;

_result:=1;

_date1:=date(  #(4+_form1),
               #(2 + (5-_form1)),
               #(2 + (8-_form1)));

_t1:=_offset;
_t2:=_offset;

::granice czasowe pojemnika
_start:=tm_stamp(_date1~1,_date1~2,_date1~3,_t1~1,_t1~2,_t1~3,0);
_end:=tm_stamp((_date1+1)~1,(_date1+1)~2,(_date1+1)~3,_t2~1,_t2~2,_t2~3,0);

::dzien tygodnia - dni robocze to te od poniedzialku do piatku
_dzien_tygodnia:=_date1~4;

::badam czy _date1 jest swietem (sprawdzam zapis w tabelce DATYW)
_swieto:=0;
DATYW.cntx_psh();
DATYW.index('DATA');
DATYW.prefix('pl_PL',_date1);
{? DATYW.first()
|| {? DATYW.KIND='S'
   || _swieto:=1
   ?}
?};
DATYW.cntx_pop();

::jesli dzien tygodnia mniejszy od soboty i dzien nie jest swietem to go dodaje do kontenera
{? _dzien_tygodnia<6 & _swieto=0
||
:: dodaje pojemnik
   _symbol:=$_date1+' - '+_dni[_date1~4];
   _label:=($_date1)+5;
   _result:=exec('cup_add','px_gen',_kont,_start,_end,_symbol,_label,_rozdzielczosc)
?};
_result


\gen_tygodnie
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Generuje pojemniki tygodniowe
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - Poczatek przetwarzania
::       _c - tm_stamp() - Koniec przetwarzania (parametr obowiazkowy - w tej formule nie jest uzywany!)
::       _d - tm_stamp() - Globalna rozdzielczosc planu
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
{? _<4 || return() ?};
_kont:=_a;
_offset:=PX_KONT.OFFSET;

::przeksztalcam tm_stampy na daty i czas
_form1:=tm_form(_b);
_rozdzielczosc:=_d;

_result:=0;

_date1:=date(  #(4+_form1),
               #(2 + (5-_form1)),
               #(2 + (8-_form1)));

_t1:=_offset;
_t2:=_offset;

_week_start:=_date1-(_date1~4-1);
_week_end:=_week_start+7;

::granice czasowe pojemnika
_start:=tm_stamp(_week_start~1,_week_start~2,_week_start~3,_t1~1,_t1~2,_t1~3,0);
_end:=tm_stamp(_week_end~1,_week_end~2,_week_end~3,_t2~1,_t2~2,_t2~3,0);

::numer tygodnia ciagne z tabeli DATY
_nr:=exec('get','daty',_week_start,'$DATY.TYDZIEN','???');

::dodaje pojemnik
_symbol:='Tydzień '+_nr;
_label:=_nr;
_result:=exec('cup_add','px_gen',_kont,_start,_end,_symbol,_label,_rozdzielczosc);
_result


\gen_miesiace
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Generuje pojemniki miesieczne
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - Poczatek przetwarzania
::       _c - tm_stamp() - Koniec przetwarzania (parametr obowiazkowy - w tej formule nie jest uzywany!)
::       _d - tm_stamp() - Globalna rozdzielczosc planu
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
{? _<4 || return() ?};
_kont:=_a;
_offset:=PX_KONT.OFFSET;

::przeksztalcam tm_stampy na daty i czas
_form1:=tm_form(_b);
_rozdzielczosc:=_d;

_result:=0;

_date1:=date(  #(4+_form1),
               #(2 + (5-_form1)),
               #(2 + (8-_form1)));

_t1:=_offset;
_t2:=_offset;

_month_start:=date(_date1~1,_date1~2,1);
_month_end:=_month_start+(date(_month_start~1,_month_start~2,0)-date(_month_start~1,_month_start~2,1)+1);

::granice czasowe pojemnika
_start:=tm_stamp(_month_start~1,_month_start~2,_month_start~3,_t1~1,_t1~2,_t1~3,0);
_end:=tm_stamp(_month_end~1,_month_end~2,_month_end~3,_t2~1,_t2~2,_t2~3,0);

::dodaje pojemnik
_symbol:=form(_month_start,,8);
_label:=$(_month_start~1)+'/'+form(_month_start~2,-2);
_result:=exec('cup_add','px_gen',_kont,_start,_end,_symbol,_label,_rozdzielczosc);
_result


\cup_add
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Dodaje pojemnik do kontenera w przypadku, gdy nie ma pojemnika, ktory interferuje z nowym
::       pod wzgledem okresu trwania
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - Poczatek pojemnika
::       _c - tm_stamp() - Koniec pojemnika
::       _d - STRING - Symbol pojemnika
::       _e - STRING - Etykieta pojemnika
::       _f - REAL - globalna rozdzielczosc planowania w nomenklaturze tm_stamp
::       [_g] - 0 / [1] - czy sprawdzac czy istnieje juz taki pojemnik w kontenerze czy nie - domyslnie tak
::       [_h] - 0 / [1] - czy inicjowac pojemnosc nowego pojemnika - domyslnie tak
::       [_i] - INTEGER - ilość poziomów kalendarza - domyślnie 1
::   WY: 0 - porazka - nie dodano pojemnika
::       1 - sukces  - dodano nowy pojemnik
::       2 - sukces - pojemnik o takim czasie juz istnieje
::----------------------------------------------------------------------------------------------------------------------
{? _<6
|| return(0)
?};
::inicjalizacja zmiennych
_kont:=_a;
_start:=_b;
_end:=_c;
_symbol:=_d;
_label:=_e;
_resolution:=_f;

_result:=0;
_exist:=0;
_overwrite_chk:=1;
_init_cap:=1;

{? _>6
|| _overwrite_chk:=_g
?};

{? _>7
|| _init_cap:=_h
?};
_cal_lvl:=1;
{? var_pres('_i')=type_of(0)
|| _cal_lvl:=_i
?};

_duration:=_end-_start;
{? _duration<=0
|| _msg:='Próba dodania pojemnika o zerowym lub ujemnym czasie trwania.';
   KOMM.error(_msg,0,1);
   return(0)
?};
{? _resolution>0 & _duration<_resolution
||
   _msg:='Próba dodania pojemnika o czasie trwania mniejszym niż rozdzielczość planu: %1 - %2.'@[(19+tm_form(_start)),(19+tm_form(_end))];
   KOMM.error(_msg,0,1);
   return(0)
?};
{? _resolution>0 & _duration%*_resolution<>0
||
   _msg:='Próba dodania pojemnika o czasie trwania, który nie jest wielokrotnością rozdzielczości planu: %1 - %2.'@[(19+tm_form(_start)),(19+tm_form(_end))];
   KOMM.error(_msg,0,1);
   return(0)
?};
{? PX_KONT.seek(_kont)
||
:: Sprawdzam czy dlugosc pojemnika nie przekracza zadeklarowanej na kontenerze dlugosci
   {? exec('chk_max_dur','px_cup',_duration,PX_KONT.MAX_CDUR)=0
   || _str_s:=19+tm_form(_start);
      _str_e:=19+tm_form(_end);
      _hours:=(_end-_start)/exec('hour','#tm_stamp');
      _str_l:=form(_hours,,2);
      _msg:='Próba dodania pojemnika(od: %1 do: %2) o czasie trwania (%3h) dłuższym niż maksimum dla kontenera.'@[_str_s,_str_e,_str_l];
      KOMM.error(_msg,0,1);
      return(0)
   ?};

:: sprawdzam czy jest juz taki pojemnik w tym kontenerze
   {? _overwrite_chk>0
   || _int_s:=0;
      _int_e:=0;
::    najpierw sprawdzam czy znajdzie sie taki pojemnik ktory interferuje z poczatkiem
      _int_s:=exec('cup_point_check','px_plan',_kont,_start);
::    jesli nie znalazl sie taki ktory interferuje z poczatkiem to sprawdzam czy jest taki
::    ktory interferuje z koncem
      {? _int_s=0
      || _int_e:=exec('cup_point_check','px_plan',_kont,_end)
      ?};

      {? _int_s>0 | _int_e>0
      ||
::       oprocz sprawdzenia czy okres nowego pojemnika przecina sie z jakims pojemnikiem
::       sprawdzam rowniez czy dlugosc tego przeciecia jest wieksza od zera, bo moze
::       tylko nowy pojemnik bedzie sie nakladal na poprzedni w punkcie startu/konca co jest
::       normalnym zjawiskiem
         _sum:=exec('intervals_sum','px_plan',  PX_CUP.TM_START,
                                                PX_CUP.TM_END,
                                                _start,
                                                _end);
         _sum_len:=exec('interval_len','px_plan',_sum);
         {? _sum_len=0
         || _exist:=0
         || _exist:=1
         ?}
      || _exist:=0
      ?};

      {? _exist=0
      || {? exec('cup_time_check','px_plan',_kont,_start,_end)>0
         || _interval:=exec('interval','#interval');
            _interval.START:=_start;
            _interval.END:=_end;

            _interval_cup:=exec('interval','#interval');
            _interval_cup.START:=PX_CUP.TM_START;
            _interval_cup.END:=PX_CUP.TM_END;

            _interval_and:=exec('intervals_and','#interval',_interval,_interval_cup);

            {? exec('interval_dur','#interval',_interval_and)>0
            || _exist:=1
            ?}
         ?}
      ?}
   ?};

:: jesli w ogole nie ma pojemnika ktory przecina zadany okres to zakladam nowy pojemnik
   {? _exist=0
   ||
::    przeksztalcam tm_stampy na daty i czas
      _form1:=tm_form(_start);
      _form2:=tm_form(_end);

      _date1:=date(  #(4+_form1),
                     #(2 + (5-_form1)),
                     #(2 + (8-_form1)));

      _time1:=time(  #(2 + (11-_form1)),
                     #(2 + (14-_form1)),
                     #(2 + (17-_form1)));

      _date2:=date(  #(4+_form2),
                     #(2 + (5-_form2)),
                     #(2 + (8-_form2)));

      _time2:=time(  #(2 + (11-_form2)),
                     #(2 + (14-_form2)),
                     #(2 + (17-_form2)));

::    Sprawdzam czy data poczatkowa i koncowa ma swoje odpowiedniki w tabeli dat - jesli
::    nie to nie dodaje pojemnika, tylko odpowiedni komunikat
      _daty1:=exec('get','daty',_date1);
      _daty2:=exec('get','daty',_date2);

      {? _daty1=null()
      ||
         _msg:='Próba dodania pojemnika, którego data początkowa(%1) nie ma swojego odpowiednika w tabeli DATY.'@[$_date1];
         KOMM.error(_msg,0,1);
         ~~
      |? _daty2=null()
      ||
         _msg:='Próba dodania pojemnika, którego data końcowa(%1) nie ma swojego odpowiednika w tabeli DATY.'@[$_date2];
         KOMM.error(_msg,0,1);
         ~~
      || _result:=exec('cup_add_raw','px_gen', PX_KONT.PX_VER,
                                               PX_KONT.ref(),
                                               _symbol,
                                               _label,
                                               _date1,
                                               _time1,
                                               _date2,
                                               _time2,
                                               _cal_lvl)
      ?}
   || _result:=2
   ?}
?};

{? _result=1
||
:: UWAGA - tylko w przypadku gdy pojemnik został dodany
:: --------------------PX_CUP.TM_WALLx
::
::                                   PX_CUP
:: .----------------------------------------------------------------------------.
:: |                |                                         |                 |
:: |PX_CUP.TM_WALL1 |                                         | PX_CUP.TM_WALL2 |
:: |                |                                         |                 |
:: '----------------------------------------------------------------------------'
::
:: Dla algorytmu planowania ustawiam punkty czasowe PX_CUP.TM_WALLx
:: sa one uzywane podczas wyznaczania pierwszego pojemnika w planie na danym kontenerze
:: Dysponujac punktem czasowym w ktorym zakonczyl sie plan na poprzednim kontenerze
:: algorytm musi znalezc pierwszy pojemnik w aktualnie planowanym kontenerze
:: TM_WALL1 i TM_WALL2 okreslaja granice czasowe na pojemniku po przekroczeniu ktorych algorytm powinien
:: znalezc kolejny pojemnik zgodnie ze zwrotem planowania
::
:: Domyslna implementacja zaklada ustawienie TM_WALLx na kazdym pojemniku zgodnie z parametrem 500352
:: ktory okresla procentowo zaleznosc miedzy TM_WALLx a TM_START i TM_END
:: Mozna ja zmienic i ustawiac TM_WALL tylko na niektorych pojemnikach (np tylko w kazdy piatek, na 14:00)
::
:: Jesli ktorys z TM_WALLx nie zostanie ustawiony to trigger tabeli PX_CUP ustawi go tak samo jak pola
:: TM_START i TM_END
   _duration:=_end-_start;
   _percent:=exec('get','#params',500352)/100;
   {? _duration>0 & _percent>=0 & _percent<1
   || PX_CUP.TM_WALL1:=PX_CUP.TM_END-(_duration*_percent);
      PX_CUP.TM_WALL2:=PX_CUP.TM_START+(_duration*_percent);
      PX_CUP.put()
   ?}
?};

{? _result=1 & _init_cap>0
||
:: inicjuje pojemnosc pojemnika
   exec('cup_cap','px_gen')
?};
_result


\cup_add_raw
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Dodaje do tabeli PX_CUP 1 rekord
::   WE: _a - PX_VER.ref()
::       _b - PX_KON.ref()
::       _c - STRING - SYMBOL
::       _d - STRING - LABEL
::       _e - DATE - STARTD
::       _f - TIME - STARTT
::       _g - DATE - ENDD
::       _h - TIME - ENDT
::       _i - INTEGER - ilość poziomów kalendarza
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

_can_continue:=1;

_startd:=exec('get','daty',_e);
_endd:=exec('get','daty',_g);

{? _startd=null() | _endd=null()
|| _can_continue:=0
?};
{? _can_continue>0
||
   PX_CUP.blank();
   PX_CUP.PX_VER:=_a;
   PX_CUP.PX_KONT:=_b;
   PX_CUP.SYMBOL:=_c;
   PX_CUP.LABEL:=_d;
   PX_CUP.STARTD:=_startd;
   PX_CUP.STARTT:=_f;
   PX_CUP.ENDD:=_endd;
   PX_CUP.ENDT:=_h;
   PX_CUP.TM_START:=tm_stamp(_e~1,_e~2,_e~3,_f~1,_f~2,_f~3,0);
   PX_CUP.TM_END:=tm_stamp(_g~1,_g~2,_g~3,_h~1,_h~2,_h~3,0);
   PX_CUP.TM_WALL1:=PX_CUP.TM_START;
   PX_CUP.TM_WALL2:=PX_CUP.TM_END;
   PX_CUP.KOLOR:=exec('cup_color','px_gen',PX_CUP.TM_START);
   PX_CUP.CAL_LVL:=_i;
   {? PX_CUP.add()
   || _result:=1
   ?}
?};
_result


\cup_del
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Usuwa pojemnik z kontenera w przypadku, gdy pojemnik nie ma zadnych pozycji planu
::   WE: _a - PX_CUP.ref()
::       [_b] 0 / 1 - 0= komunikaty na ekran, 1=komunikaty do obiektu KOMM (domyslnie na ekran)
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
{? _<1
|| return(0)
?};
::inicjalizacja zmiennych
_cup:=_a;
_koms:=0;

{? _>1
|| _koms:=_b
?};

_result:=0;
_can_delete:=1;

::szukam pojemnika
PX_CUP.cntx_psh();
PX_CUP.clear();
{? PX_CUP.seek(_cup)
||
:: sprawdzam czy pojemnik ma jakies pozycje planu
   PX_POZ.cntx_psh();
   PX_POZ.index('LP');
   PX_POZ.prefix(PX_CUP.ref());
   {? PX_POZ.size()>0
   || _msg:='Usunięcie pojemnika: %1 niemożliwe - pojemnik posiada pozycje planu.'@[PX_CUP.SYMBOL];
      {? _koms=0
      || FUN.emsg(_msg)
      ?};
      {? _koms=1
      || KOMM.add(_msg,2,'128:0:0',1)
      ?};
      _can_delete:=0
   ?};
   PX_POZ.cntx_pop();
   _can_continue:=1;
:: 2. Usuwam komunikaty
   {? _can_continue>0
   || _can_continue:=exec('del_cup','px_komm',PX_CUP.ref())
   ?};

:: 3. Usuwam zapisy kalendarza
   {? _can_continue>0
   || _can_continue:=exec('delete4cup','px_cal',PX_CUP.ref())
   ?};

:: jesli moge to usuwam pojemnik
   {? _can_delete>0 & _can_continue>0
   || _result:=PX_CUP.del(,1)
   ?}
?};
PX_CUP.cntx_pop();
_result


\gen_view
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Generuje pojemnik dla kontenera widokowego, dziala w kontekscie kontenera widokowego
::   WE: _a - tm_stamp() - Poczatek pojemnika
::       _b - tm_stamp() - Koniec pojemnika
::       _c - REAL - globalna rozdzielczosc planowania w nomenklaturze tm_stamp
::       _d - PX_KONT.ref() - kontener rzeczywisty
::   WY: 0 - porazka - nie dodano pojemnika
::       1 - sukces  - dodano nowy pojemnik
::       2 - sukces - pojemnik o takim czasie juz istnieje
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_start:=_a;
_end:=_b;
_resolution:=_c;
_kont_real:=_d;

{? PX_KONT.KIND='W'
|| _symbol:=(19+tm_form(_start));
   _label:=(8+(5-tm_form(_start)));
   _result:=exec('cup_add','px_gen',PX_KONT.ref(),_start,_end,_symbol,_label,_resolution,1,0)
?};
:: spinam tak utworzony pojemnik widokowy z pojemnikiem rzeczywistym
{? _result>0
|| _uid_real:='';
   _kolor_real:='';
   PX_CUP.cntx_psh();
   _check:=exec('cup_point_check','px_plan',_kont_real,PX_CUP.TM_START);
   {? _check>0
   || _uid_real:=PX_CUP.UID;
      _kolor_real:=PX_CUP.KOLOR
   ?};
   PX_CUP.cntx_pop();
   {? _uid_real<>''
   || PX_CUP.UID_PAR:=_uid_real;
      PX_CUP.KOLOR:=_kolor_real;
      PX_CUP.UID_SRC:='';
      PX_CUP.put()
   ?}
?};
_result


\capacity_init
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Inicjuje pojemnosc pojemnikow kontenera (wywoluje skojarzona z kontenerem formule na pojemnosc)
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - Poczatek przetwarzania
::       _c - tm_stamp() - Koniec przetwarzania
::       [_d] - 0 / 1 - wyswietlac progress? (domyslnie nie)
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
_kont:=_a;
_start:=_b;
_end:=_c;
_prog:=0;
{? _>3
|| _prog:=_d
?};
_result:=1;
exec('opernast_init','px_init');
{? var_pres('KAL')<100
|| exec('declare','kalendarz');
   KAL:=obj_new(@.CLASS.KALEND)
?};

PX_KONT.cntx_psh();
PX_CUP.cntx_psh();
{? PX_KONT.seek(_kont)
||
:: znajduje najblizszy pojemnik o podanego poczatku przetwarzania
   _check:=exec('cup_closest','px_plan',PX_KONT.ref(),_start,1);
:: jesli wynik wiekszy od zera to znak ze stoje na pierwszym pojemniku ktory trzeba zainicjowac
   {? _check>0
   ||
      {!
      |?
         _result:=exec('cup_cap','px_gen',PX_VAR.P500380,PX_VAR.P500381);
         {? _result>0 & PX_VAR.NAST_ALG=2 & exec('is_koop','px_kont')=0
         ||
::          Jeśli następstwo czasowe operacji algorytmem proporcji czasowej to trzeba wygenerować
::          na pojemnikach kalendarz
            _result:=exec('rebuild4cup','px_cal',,0)
         ?};
         _result>0 & PX_CUP.next() & PX_CUP.TM_START<_end & PX_CUP.TM_END<=_end
      !}
   ?}
?};
PX_CUP.cntx_pop();
PX_KONT.cntx_pop();
_result


\cup_cap
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Inicjuje pojemnosc pojemnika we wszystkich wymiarach, pracuje w kontekscie PX_CUP
::   WE: [_a] - STRING - wartość parametru 500380
::       [_b] - STRING - wartość parametru 500381
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_capacity:=0;

{? var_pres('_a')=type_of('')
|| _par500380:=_a
|| _par500380:=exec('get','#params',500380,type_of(''))
?};
{? var_pres('_b')=type_of('')
|| _par500381:=_b
|| _par500381:=exec('get','#params',500381,type_of(''))
?};
:: uruchamiam tylko dla kontenerow skonczonych (niezbiorczych)
{? PX_CUP.PX_KONT().ENDLESS=0
||
:: jesli kontener widokowy to pobieram pojemnosc pojemnika rzeczywistego na ktory wskazuje pojemnik widokowy
:: we wszystkich wymiarach
   _dziel:=1;
   {? PX_CUP.PX_KONT().KIND='W'
   || {? PX_CUP.UID_PAR<>''
      ||
::       badam ile jest takich pojemnikow widokowych ktore wskazuja na ten sam pojemnik rzeczywisty
         PX_CUP.cntx_psh();
         PX_CUP.index('PARENT');
         PX_CUP.prefix(PX_CUP.UID_PAR);
         {? PX_CUP.size()>1
         || _dziel:=PX_CUP.size()
         ?};

::       pobieram pojemnosc pojemnika rzeczywistego
         PX_CUP.index('UID');
         PX_CUP.prefix(PX_CUP.UID_PAR);
         {? PX_CUP.first()
         || _eaten:=exec('cap_eaten','px_cup');
            _wyk:=exec('cap_wyk','px_cup');
            _real_max:=exec('cap_max','px_cup');
            _real_min:=exec('cap_min','px_cup')
         ?};
         PX_CUP.cntx_pop()
      ?}
   ||
::    obliczam zjedzona pojemnosc pojemnika we wszystkich wymiarach
      _eaten:=exec('cap_eaten','px_cup');
::    obliczam wykonana pojemnosc pojemnika we wszystkich wymiarach
      _wyk:=exec('cap_wyk','px_cup')
   ?};

:: iteruje po wszystkich wymiarach kontenera
   {! _it:=1..PX_CUP.PX_KONT().IL_WYM
   |!
::    jesli kontener jest rzeczywisty to do okreslenia pojemnosci w danym wymiarze korzystam z formuly na pojemnosc
      {? PX_CUP.PX_KONT().KIND='R'
      ||
::       nawijam pojemnosci z formul kontenera pod warunkiem ze pojemnik nie byl recznie modyfikowany
         {? PX_CUP.MANUAL='N'
         ||
::          !!!MAX!!!
::          z kontenera pobieram formule na pojemnosc maksymalna
            _jm:=($('PX_KONT.JM'+$_it+'().KOD'))();
            {? PX_VAR.NAST_ALG=2 & (_jm=_par500380|_jm=_par500381)
            ||
::             Następstwo czasowe metodą proporcji czasowej ignoruje formułę na pojemność
::             i robi pojemność wg kalendarza dla jednostek miary zgodnych
::             z parametrem 500380 lub 500381
               _formula:="exec('cap_kalend','px_gen',_a)"
            || _formula:=$($('PX_CUP.PX_KONT().MAXEQ'+$_it+'().RULE'))()
            ?};

            _capacity:=_formula(PX_CUP.ref());

::          uaktualniam kafelek
            {? type_of(_capacity)=type_of(0)
            ||
               _update:=$('_cap:=_a; PX_CUP.CAP_MAX'+$_it+':=_cap');
               _update(_capacity)
            ?};

::          !!!MIN!!!
::          z kontenera pobieram formule na pojemnosc minimalna
            _formula:=$($('PX_CUP.PX_KONT().MINEQ'+$_it+'().RULE'))();
::          uruchamiam formule
            _capacity:=_formula(PX_CUP.ref());
::          uaktualniam kafelek
            {? type_of(_capacity)=type_of(0)
            ||
               _update:=$('_cap:=_a; PX_CUP.CAP_MIN'+$_it+':=_cap');
               _update(_capacity)
            ?}
         ?};

::       uaktualniam zjedzona pojemnosc
         _update:=$('_eaten:=_a;PX_CUP.CAP_USE'+$_it+':=_eaten['+$_it+']');
         _update(_eaten);
::       uaktualniam wykonana pojemnosc
         _update:=$('_wyk:=_a;PX_CUP.CAP_WYK'+$_it+':=_wyk['+$_it+']');
         _update(_wyk)
      ?};
::    jesli kontener jest widokowy to do okreslenia pojemnosci w danym wymiarze korzystam z pojemnikow rzeczywistych
      {? PX_CUP.PX_KONT().KIND='W' & PX_CUP.UID_PAR<>''
      ||
         {? var_pres('_real_max')>0 & var_pres('_real_min')>0
         || _view_max:=_real_max[_it]/_dziel;
            _view_min:=_real_min[_it]/_dziel;
::          uaktualniam kafelek
            _update:=$('_view_max:=_a;PX_CUP.CAP_MAX'+$_it+':=_view_max');
            _update(_view_max);
            _update:=$('_view_min:=_a;PX_CUP.CAP_MIN'+$_it+':=_view_min');
            _update(_view_min);

::          pojemnikowi widokowemu ustawiam dzielnik (zeby latwiej bylo ilosci na niego nanosic)
            _divider:=1/_dziel;
::          zera nigdy nie wpisuje bo pozniej przez ten dzielnik jest dzielone a przez zero nie dzielimy
            {? _divider>0
            || PX_CUP.DIVIDER:=_divider
            ?};
::          uaktualniam zjedzona pojemnosc
            _update:=$('_eaten:=_a;_dziel:=_b;PX_CUP.CAP_USE'+$_it+':=_eaten['+$_it+']/_dziel');
            _update(_eaten,_dziel);
::          uaktualniam wykonana pojemnosc
            _update:=$('_wyk:=_a;_dziel:=_b;PX_CUP.CAP_WYK'+$_it+':=_wyk['+$_it+']/_dziel');
            _update(_wyk,_dziel)
         ?}
      ?};
      _can_continue:=PX_CUP.put();
      {? _can_continue<=0
      || _result:=0
      ?}
   !}
?};
_result


\cup_color
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca losowy kolor dla pojemnika
::       _a - tm_stamp (nie jest sprawdzany typ argumentu)
::   WY: STRING[23] - kolor w formacie '128:128:128,128:128:128'
::----------------------------------------------------------------------------------------------------------------------
_stamp:=_a;

_wyn:='';

_czarny:='0:0:0';
_bialy:='255:255:255';

_tekst:=_czarny;

::kolor tla zalezy od poczatku startu i jest wybierany ze zdefiniowanej ilosci kombinacji
_rr:=144+_stamp%*111;
_gg:=178+_stamp%*77;
_bb:=154+_stamp%*101;
_tlo:=$_rr+':'+$_gg+':'+$_bb;

::kolor kontrastowy tekstu (czarny lub bialy)
:: NIE ZMIENIAC TYCH ULAMKOW - ZNALEZIONE NA GOOGLE
_brightness:=sqrt(0.241*(_rr*_rr)+0.691*(_gg*_gg)+0.068*(_bb*_bb));

{? _brightness<130
|| _tekst:=_bialy
|| _tekst:=_czarny
?};

_wyn+=_tekst+','+_tlo;
_wyn


\cap_kalend
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ustala pojemnosc zgodna z kalendarzem zasobu - zalozenie, ze pojemniki sa dzienne
::   WE: _a - PX_CUP.ref()
::   WY: pojemnosc w godzinach
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
PX_CUP.cntx_psh();
PX_CUP.clear();
{? PX_CUP.seek(_a)
||
   {? var_pres('KAL')<100
   || exec('declare','kalendarz');
      KAL:=obj_new(@.CLASS.KALEND)
   ?};
   _startd:=PX_CUP.STARTD().DATA;
   _starty:=DATY.ROK;

   {? PX_KONT.PL_RES().FROM_GNI<>null() & PX_VAR.NAST_ALG=2 & exec('is_koop','px_kont')=0
   ||
::    Specjalna obsługa dla gniazd
      TWRKZBR.cntx_psh();
      TWRKZPO.cntx_psh();
      TWRKPLC.cntx_psh();
      PX_KONT.PL_RES().FROM_GNI();

      TWRKZPO.index('GRUPA');
      TWRKZPO.prefix(PX_KONT.PL_RES().FROM_GNI);
      {? TWRKZPO.first()
      || PX_CUP.CAL_LVL:=0;
         {!
         |?
            {? TWRKZPO.ELEMENT<>null()
            ||
               {? TWRKZPO.ELEMENT().KAL<>null()
               ||
                  {? KAL.set_cal(TWRKZPO.ELEMENT().KAL,_starty)>0
                  ||
                     _work_hours:=KAL.w_hours(_startd,_startd);
                     _res+=_work_hours;
                     {? _work_hours>0
                     || PX_CUP.CAL_LVL+=1;
                        PX_CUP.put();
                        _duration:=PX_CUP.TM_END-PX_CUP.TM_START;
                        _duration:=_duration/exec('hour','#tm_stamp');
                        {? _work_hours>_duration
                        || KOMM.add('Kalendarz na dzień %1 stanowiska jest dłuższy niż kalendarz gniazda.'@[$_startd],1,1)
                        ?}
                     ?}
                  || KOMM.add('Brak kalendarza na rok: %1, pojemność nie została zainicjowana.'@[$_starty],2,,1)
                  ?}
               || _res+=24
               ?}
            ?};
            TWRKZPO.next()
         !}
      ?};
      TWRKPLC.cntx_pop();
      TWRKZPO.cntx_pop();
      TWRKZBR.cntx_pop();
      ~~

   || {? PX_CUP.PX_KONT().KAL<>null()
      || {? KAL.set_cal(PX_CUP.PX_KONT().KAL,_starty)>0
         || _res:=KAL.w_hours(_startd,_startd)
         || KOMM.add('Brak kalendarza na rok: %1, pojemność nie została zainicjowana.'@[$_starty],2,,1)
         ?}
      || _res:=24
      ?}
   ?}
?};

PX_CUP.cntx_pop();
PX_CUP.get();
_res


\px_cup_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zadanie do generowania pojemnikow wg horyzontu planowania
::   WE: _a - dialog (1), bez dialogu (0 - domyślnie)
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(0) || _ask:=0 || _ask:=_a ?};

:: Srodowisko
exec('declare','kalendarz');
{? var_pres('KAL')<0 || KAL:=obj_new(@.CLASS.KALEND) ?};
KOMM.init(,,'');

_mainver:=exec('get_mainversion','px_ver');

_can_continue:=1;
_result:=1;
{? ~_ask | FUN.ask('Czy generować pojemniki planu?'@)
||
   PX_KONT.index('ACT');
   PX_KONT.prefix('T',_mainver);
   {? PX_KONT.first()
   || {!
      |? _can_continue:=exec('cup_generator','px_gen',PX_KONT.ref());
         {? _can_continue=0 || _result:=0 ?};
         PX_KONT.next() & _can_continue>0
      !}
   ?}
?};
_result


\gen_calend
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Generuje pojemniki wg kalendarza
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - Poczatek przetwarzania
::       _c - tm_stamp() - Koniec przetwarzania (parametr obowiazkowy - w tej formule nie jest uzywany!)
::       _d - tm_stamp() - Globalna rozdzielczosc planu
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
{? _<4 || return() ?};
_kont:=_a;
_tm_stamp:=_b;
_tm_end:=_c;

_rozdzielczosc:=_d;
_offset:=PX_KONT.OFFSET;
_kal:=PX_KONT.KAL;

_dni:=obj_new(7);
_dni[1]:='Pn'@;
_dni[2]:='Wt'@;
_dni[3]:='Śr'@;
_dni[4]:='Czw'@;
_dni[5]:='Pt'@;
_dni[6]:='Sb'@;
_dni[7]:='Nd'@;

_result:=1;
{? _kal<>null()
||
   _date1:=exec('tm_stamp2date','#tm_stamp',_tm_stamp);
   _can_continue:=KAL.set_cal(PX_KONT.KAL,_date1~1);
   {? _can_continue>0 & KAL.get_day(_date1)<>null()
   ||
::    granice czasowe pojemnika
      _start:=KAL_DEF.TM_START;
      _end:=KAL_DEF.TM_END;

      _duration:=_end-_start;

      {? _duration>0
      ||
::       dodaje pojemnik
         _symbol:=$_date1+' - '+_dni[_date1~4];
         _label:=($_date1)+5;
         _result:=exec('cup_add','px_gen',_kont,_start,_end,_symbol,_label,0);

         {? _result=2
         ||
::          Jeżeli znalazłem pojemnik interferujący z przekazanym czasem i czasy się różnią
::          to znaczy że mógł się zmienić kalendarz i znalezionemu pojemnikowi ustalam nowy czas
::          startu i końca
            {? PX_CUP.TM_START<>_start | PX_CUP.TM_END<>_end
            || _result:=exec('put_time','px_cup',,_start,_end)
            ?}
         ?}
      ?}
   ?};

   {? _can_continue=0
   || _result:=0
   ?}
||
:: Nie ma kalendarza, dodaję pojemnik dzienny
   _result:=exec('gen_dni_all','px_gen',_kont,_tm_stamp,_tm_end,_rozdzielczosc)
?};
_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:37 46d46d6d39c2fadc8ad35f7cbe49d0cbf2b0c23b5fbce29e5be8794322d3186c3cfb913a65af349a88534ec9b424998bd555b170a24fe98002a9abe5d440c317d1da9c9d9ade4d8c056e0b95152cfe8fbe9fc812c98a566234566dd3c3695f2e15f95c1998de51f161a84db625aec33028cbcb3b68a2dc309558179d2bd99e05
