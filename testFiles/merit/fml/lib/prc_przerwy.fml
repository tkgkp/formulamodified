:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: prc_przerwy.fml
:: Utworzony: 2018/12/04
:: MOD: MicKoc 11.01.2022
:: Autor: TMR
::======================================================================================================================
:: Zawartosc: Formuły do obsługi tabeli z definicją niepłatnych przerw.
::======================================================================================================================


\isEnabled
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51_24]
:: OPIS: Czy wlaczone jest korzystanie z niepłatnych przerw
::   WY: 0/1
::  OLD: \isEnabled/r_przer.fml
::----------------------------------------------------------------------------------------------------------------------
exec('get_par','#parametr',321,2)='T'


\r_przer_czas_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51_24]
:: OPIS: Formuła po edycji pola DO_ND w tabeli R_PRZER.
::   WE:
::   WY:
::  OLD: \r_przer_czas_ae/r_przer.fml
::----------------------------------------------------------------------------------------------------------------------
_od_nd:=R_PRZER.OD_ND='T';
_godz_do:=R_PRZER.GODZ_OD+R_PRZER.CZAS;
R_PRZER.GODZ_DO:={? ~_od_nd & _godz_do<time(24,0,0)
                 || R_PRZER.DO_ND:='N';
                    _godz_do
                 || R_PRZER.DO_ND:='T';
                    {? _od_nd
                    || _godz_do
                    || _godz_do-time(24,0,0)
                    ?}
                 ?}


\r_przer_wer_ar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51_24]
:: OPIS: Formuła "rekord po" w oknie WER tabeli R_PRZER.
::   WE:
::   WY: '' / akronim pola
::  OLD: \r_przer_wer_ar/r_przer.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=__CHK.record(R_PRZER,,'R_ZMIANY','GRUPA');
{? _result='' & __CHK.index(R_PRZER,-menu_txt()='popraw')<>''
|| _result:='GRUPA'
?};
{? _result=''
|| R_PRZER.CZAS:=(R_PRZER.GODZ_DO-R_PRZER.GODZ_OD)+
                 {? R_PRZER.OD_ND='N'
                 || *((R_PRZER.DO_ND*'T')*(*time(24,0,0)))
                 || *0
                 ?};
   {? R_PRZER.CZAS<=*0
   || FUN.info('Należy określić czas trwania przerwy.'@);
      _result:='GODZ_OD'
   |? R_PRZER.CZAS>*60
   || FUN.info('Czas trwania przerwy nie może przekraczać jednej godziny.'@);
      _result:='GODZ_OD'
   || _zm_od:=R_PRZER.R_ZMIANY().GODZ_OD;
      _zm_do:=_zm_od+R_PRZER.R_ZMIANY().CZAS+R_ZMIANY.P_CZAS;
      _prz_od:=R_PRZER.GODZ_OD+*((R_PRZER.OD_ND*'T')*(*time(24,0,0)));
      _prz_do:=_prz_od+R_PRZER.CZAS;
      {? ~(_prz_od>=_zm_od & _prz_od<=_zm_do &
           _prz_do>=_zm_od & _prz_do<=_zm_do)
      || FUN.info('Rozpoczęcie i zakończenie przerwy musi zawierać się w czasie trwania zmiany (%1 - %2)'@
                  [$R_ZMIANY.GODZ_OD,$R_ZMIANY.GODZ_DO]);
         _result:='GODZ_OD'
      ?}
   ?}
?};
_result


\kalopis_czas_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51_24]
:: OPIS: Po redagowaniu pola KAL_OPIS.P_OD
::   WE:
::   WY:
::  OLD: \kalopis_czas_ae/r_przer.fml
::----------------------------------------------------------------------------------------------------------------------
exec('poczspr','kaledit',KAL_OPIS)


\przesun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51_24]
:: OPIS: Przesuwa przerwę, jeżeli leży poza godzinami zmiany
::   WE: _a [REFERENCE] - wskazanie na zmianę
::       _b [TIME]      - godzina rozpoczęcia zmiany
::       _c [TIME]      - czas trwania zmiany
::       _d [TIME]      - czas trwania przerwy
::   WY: -1/0/1
::  OLD: \przesun/r_przer.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=-1;
 _zmiana:={? var_pres('_a')=type_of(null) || _a || return(_result) ?};
  _zm_od:={? var_pres('_b')=type_of(time) || _b || return(_result) ?};
_zm_czas:={? var_pres('_c')=type_of(time) || _c || return(_result) ?};
 _p_czas:={? var_pres('_d')=type_of(time) || _d || return(_result) ?};
_result:=0;

_t_24:=time(24,0,0);
R_ZMIANY.cntx_psh();
R_ZMIANY.prefix();
{? R_ZMIANY.seek(_zmiana)
|| R_PRZER.cntx_psh();
   R_PRZER.index('UNIQUE');
   R_PRZER.prefix(_zmiana);
   {? R_PRZER.first()
   || {!
      |? _czas:=R_PRZER.CZAS:=_p_czas;
         R_PRZER.GODZ_DO:=R_PRZER.GODZ_OD+_czas;
         {!
         |? _prz_od:=R_PRZER.GODZ_OD+*((R_PRZER.OD_ND*'T')*(*time(24,0,0)));
            {? ~exec('zawiera','prc_przerwy',_zm_od,_zm_czas,_prz_od,R_PRZER.CZAS)
::             modyfikujemy godzinę rozpoczęcia i zakończenia przerwy
            || R_PRZER.OD_ND:='N';
               R_PRZER.DO_ND:='N';
               R_PRZER.GODZ_OD:=_zm_od;
               R_PRZER.CZAS:=_czas;
               R_PRZER.GODZ_DO:=_zm_od+_czas;
               {? R_PRZER.GODZ_DO>_t_24
               || R_PRZER.GODZ_DO-=_t_24;
                  R_PRZER.DO_ND:='T'
               ?};
               R_PRZER.put();
               _result:=1;
               _czas-=1;
               _czas>=*0
            ?}
         !};
         R_PRZER.next()
      !}
   ?};
   R_PRZER.cntx_pop()
?};
R_ZMIANY.cntx_pop();
_result


\zawiera
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [22.26]
::  MOD: MicKoc [22.26]
:: OPIS: Formuła sprawdzająca czy czas drugiego okresu zawiera się w trakcie pierwszego okresu
::       dla _e=1 czy zazębia się
::   WE: _a [TIME] - godzina rozpoczęcia pierwszego okresu
::       _b [TIME] - czas trwania pierwszego okresu
::       _c [TIME] - godzina rozpoczęcia drugiego okresu
::       _d [TIME] - czas trwania drugiego okresu
::       _e [INTEGER] - czy zazębia się, domyślnie nie=0
::   WY: -1/0/1
::  OLD: \zawiera/r_przer.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=-1;
    _od:={? var_pres('_a')=type_of(time) || _a || return(_result) ?};
  _czas:={? var_pres('_b')=type_of(time) || _b || return(_result) ?};
  _od_2:={? var_pres('_c')=type_of(time) || _c || return(_result) ?};
_czas_2:={? var_pres('_d')=type_of(time) || _d || return(_result) ?};
   _zaz:={? var_pres('_e')=type_of(0) & _e || 1 || 0 ?};

_do:=_od+_czas;
_do_2:=_od_2+_czas_2;
{? _zaz
|| _od_2<_do & _do_2>_od
|| (_od_2>=_od & _od_2<=_do & _do_2>=_od & _do_2<=_do)
?}


\timeOf2Period
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51_24]
:: OPIS: Zwraca informacje o czasie drugiego okresu zawartego w pierwszym okresie czasu
::   WE: _a [TIMESTAMP] - rozpoczęcie pierwszego okresu
::       _b [TIMESTAMP] - zakończenie pierwszego okresu
::       _b [TIMESTAMP] - rozpoczęcie drugiego okresu
::       _b [TIMESTAMP] - zakończenie drugiego okresu
::   WY:
::  OLD: \timeOf2Period/r_przer.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_start:={? var_pres('_a')=type_of(0) || _a || return(_result) ?};
  _end:={? var_pres('_b')=type_of(0) || _b || return(_result) ?};
 _from:={? var_pres('_c')=type_of(0) || _c || return(_result) ?};
   _to:={? var_pres('_d')=type_of(0) || _d || return(_result) ?};

_sTime:={? _from<_start || _start || _from ?};
_eTime:={? _to>_end || _end || _to ?};
{? _eTime>_sTime
|| _result:=exec('tm_stamp2time','#tm_stamp',_eTime-_sTime)
?};
_result


\get4Prac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [19.02]
:: OPIS: Zwraca tabelę z informacjami o przerwach, które zawierają się w przekazanym przedziale dat.
::       Uwzględniane jest powiązanie pomiędzy grupami pracownika i przerwami.
::   WE: _a [REFERENCE] - wskazanie na praconika
::       _b [DATE]      - od
::       _c [DATE]      - do
::   WY: tabela
::  OLD: \get4Prac/r_przer.fml
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')=type_of(null()) || _a || null() ?};
   _od:={? var_pres('_b')=type_of(date()) || _b || #0     ?};
   _do:={? var_pres('_c')=type_of(date()) || _c || #0     ?};

:: wyszukujemy grupy praconika w podanym zakresie dat
_sql:=''+"
   select
      GRUPPRAC.GR, GRUPPRAC.OD as GR_OD, GRUPPRAC.DO as GR_DO
   from
      GRUPPRAC
   where
      GRUPPRAC.P=:_a and
      GRUPPRAC.OD<=to_date(:_c) and
      (GRUPPRAC.DO>=to_date(:_b) or GRUPPRAC.DO IS NULL)
";
_tabGR:=sql(_sql,_p_ref,_od,_do);

:: wyszukujemy przerwy dla grup
_sql:=''+"
   select
      :_a.GR_OD,
      :_a.GR_DO,
      R_ZMIANY.GODZ_OD as ZM_OD,
      R_ZMIANY.GODZ_DO as ZM_DO,
      R_ZMIANY.REFERENCE as ZM,
      R_PRZER.*
   from R_PRZER join R_ZMIANY join :_a using(R_PRZER.GRUPA,:_a.GR)
";
_tab:=sql(_sql,_tabGR);

:: uzupełniamy zerową "datę do" dla grupy dużą wartością w celu nałożenia warunku dla .find_tab()
{? _tab.first()
|| {!
   |? {? _tab.GR_DO=#0
      || _tab.GR_DO:=date(9999,12,31);
         _tab.put(1)
      ?};
      _tab.next()
   !}
?};
_tab


\delete4
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51_24]
:: OPIS: Kasuje rekordy tabeli R_PRZER (wykonywane w transakcji!!!) dla wskaznego rekordu _ref
::   WE: _a - R_ZMIANY.ref()
::   WY: >0 -wyczyszczone,
::      <=0 -niewyczyszczone
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::  OLD: \delete4/r_przer.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_ref:={? var_pres('_a')=type_of(null) || _a || return(_result) ?};

_can_continue:=1;

:: powrot w przypadku zerwanej transakcji
{? do_state()=2 || return(-100) ?};

:: zalozenie transakcji
_mydo:=do_state()=0;
{? _mydo || do() ?};

R_PRZER.cntx_psh();
R_PRZER.index('UNIQUE');
R_PRZER.prefix(_ref);
{? R_PRZER.first()
|| {!
   |? _can_continue:=exec('delete','prc_przerwy',R_PRZER.ref());
      _can_continue>0 & R_PRZER.first()
   !}
?};
R_PRZER.cntx_pop();

{? _can_continue>0
|| _result:=1
|| undo()
?};
{? _mydo || end() ?};
_result


\delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51_24]
:: OPIS: Kasuje podany rekord tabeli R_PRZER (wykonywane w transakcji!!!)
::   WE: _a - R_PRZER.ref()
::   WY: >0 -wyczyszczone,
::      <=0 -niewyczyszczone
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::  OLD: \delete/r_przer.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_ref:={? var_pres('_a')=type_of(null) || _a || return(_result) ?};

:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_can_continue:=1;

:: założenie transakcji
_mydo:=do_state()=0;
{? _mydo || do() ?};

R_PRZER.cntx_psh();
R_PRZER.clear();
{? R_PRZER.seek(_ref)
|| {? R_PRZER.del(,1)>0
   || _result:=1
   || undo();
      _result:=-3
   ?}
|| _result:=0
?};
R_PRZER.cntx_pop();

{? _result<0
|| undo()
?};
{? _mydo || end() ?};
_result


\ret_val
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [mk] [12.10]
:: OPIS: Zwraca wartosc z parametru
::   WE: wartosc
::   WY: wartosc
::  OLD: \ret_val/graf_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_a


\r_zmiany_ar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MicKoc [22.26]
:: OPIS: Odśwież po tabeli R_PRZER
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
R_PRZER.index('ZMIANOD');
R_PRZER.prefix(R_ZMIANY.ref());
grp_disp(R_PRZER,'WER')


\r_przer_bs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MicKoc [22.26]
:: OPIS: Przed obsługą okna R_PRZER
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? grp_empty(R_ZMIANY,'WER')
|| return('#disable')
?}


\r_przer_aput
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MicKoc [22.26]
:: OPIS: Akcja po put R_PRZER
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('czyAktBuff4Zm','prc_zmiany',R_PRZER.R_ZMIANY,R_PRZER.ref())


\r_przer_grupa_pt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MicKoc [22.26]
:: OPIS: Wzorzec dla pola GRUPA
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_slo_kod:=exec('kod','ext_slo','GRUPPRAC','PRZERWY');
SLO_KOD.prefix();
SLO_KOD.f_set('KOD','join GRUPRODZ using (GRUPRODZ.GR,SLO_KOD.reference)','GRUPRODZ.RODZ=:_a',_slo_kod);
''


\r_przer_aw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MicKoc [22.26]
:: OPIS: Akcja okno po
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
SLO_KOD.f_clear();
1


\r_przer_prac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MicKoc [22.26]
:: OPIS: Przeglądanie pracowników w grupie
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
GRUPPRAC.index('PGROD');
GRUPPRAC.prefix();
GRUPPRAC.f_set(
   'OSOBA(NAZWISKO), OSOBA(PIERWSZE), P(T), OD, DO',
   'join P using (GRUPPRAC.P,P.REFERENCE) join OSOBA using(P.OSOBA,OSOBA.REFERENCE)',
   'GRUPPRAC.GR=:_a and P.FIRMA=:_b',
   R_PRZER.GRUPA,
   exec('ref_firma','ustawienia')
);
GRUPPRAC.win_sel('SLO');
GRUPPRAC.select()


\ustaw_buff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MicKoc [22.26]
:: OPIS: Ustawia KAL_BUFF zgodnie ze zdefiniowaną zmianą przy zmianie wymiaru zatrudnienia "w górę"
::   WE: _a [TABELA] - tabela z przerwami, wynik \get4Prac/prc_przerwy.fml
::       _b [INTEGER] - brak lub 0 - wszystko, 1 - część ustawiająca przerwy, 2 - część ustawiająca kalendarz ze wzorca
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
_ret:=0;
_co:={? var_pres('_b')=type_of(0) & _b || _b ?};
_jestTab:=0;
{? var_pres('_a')>100 & var_pres('CZAS',_a)
|| _tabPrz:=_a;
   _jestTab:=1
?};
{? ~__KAL.get_day(KAL_BUFF.DATA) || return(_ret) ?};
{? _co=1 | _co=0
|| {? _jestTab & _tabPrz.find_tab(,
         'GR_OD',,'<=',KAL_BUFF.DATA    ,'GR_DO',,'>=',KAL_BUFF.DATA,
         'ZM_OD',,'<=',KAL_BUFF.POCZATEK,'ZM_DO',,'>=',KAL_BUFF.POCZATEK,
         'ZM_OD',,'<=',KAL_BUFF.KONIEC  ,'ZM_DO',,'>=',KAL_BUFF.KONIEC
      )
   || _p_data:=KAL_BUFF.DATA+(_tabPrz.OD_ND*'T');
      _prz_od:=exec('create','#tm_stamp',_p_data,_tabPrz.GODZ_OD);
      _p_do:=_tabPrz.GODZ_OD+_tabPrz.CZAS;
      _p_nd:=_p_do>time(24,0,0);
      {? _p_nd || _p_do-=time(24,0,0) ?};
      _prz_do:=exec('create','#tm_stamp',_p_data+_p_nd,_p_do);
      _k_od:=exec('create','#tm_stamp',KAL_BUFF.DATA,KAL_BUFF.POCZATEK);
      _k_do:=exec('create','#tm_stamp',KAL_BUFF.DATAW,KAL_BUFF.KONIEC);
      {? _prz_od<_k_do & _prz_do>_k_od
      || KAL_BUFF.P_DATA:=_p_data;
         KAL_BUFF.P_START:=_tabPrz.GODZ_OD;
         KAL_BUFF.P_CZAS:=_tabPrz.CZAS
      ?};
      {? KAL_BUFF.TYP='R' & R_ZMIANY.seek(_tabPrz.ZM,,1) || KAL_BUFF.ZMIANA:=R_ZMIANY.ref() ?}
   || _prz_od:=KAL_DEF.P_START+*((KAL_DEF.P_DATA-KAL_DEF.DATA)*(*time(24,0,0)));
      _zawiera:=exec('zawiera','prc_przerwy',KAL_BUFF.POCZATEK,KAL_BUFF.CZAS+KAL_DEF.P_CZAS,_prz_od,KAL_DEF.P_CZAS,1);
      {? _zawiera=1
      || KAL_BUFF.P_DATA:=KAL_DEF.P_DATA;
         KAL_BUFF.P_START:=KAL_DEF.P_START;
         KAL_BUFF.P_CZAS:=KAL_DEF.P_CZAS
      |? KAL_BUFF.POCZATEK+KAL_BUFF.CZAS<=_prz_od
      || KAL_BUFF.KONIEC-=KAL_DEF.P_CZAS;
         KAL_BUFF.P_DATA:=#0;
         KAL_BUFF.P_START:=KAL_BUFF.P_CZAS:=*0
      || KAL_BUFF.P_DATA:=#0;
         KAL_BUFF.P_START:=KAL_BUFF.P_CZAS:=*0
      ?}
   ?}
?};
{? _co=2 | _co=0
|| Cntx.psh(KAL_OPIS,KAL_WZOR);
   KAL_OPIS.index('KAL_OPIS');
   KAL_WZOR.index('KAL_WZOR');
   KAL_WZOR.prefix(exec('firma','ustawienia'),__KAL.wzo_name(KAL_BUFF.DATA),);
   {? KAL_BUFF.POCZATEK=KAL_DEF.POCZATEK
   || {? KAL_WZOR.first()
      || KAL_OPIS.prefix(KAL_WZOR.ref(),KAL_DEF.DATA~1,KAL_DEF.DATA~4);
         {? KAL_OPIS.first()
         || KAL_BUFF.KONIEC:=KAL_OPIS.KONIEC;
            KAL_BUFF.CZAS:=KAL_OPIS.CZAS;
            _ret:=1
         ?}
      ?}
   ?};
   Cntx.pop(KAL_OPIS,KAL_WZOR)
?};
_ret

:Sign Version 2.0 jowisz:1045 2022/06/30 14:23:22 734d29ba83eef450ee96d014d2aa160c218251096c14deed8b20c0773e722e995692aae065b2fa9e280d08c3fb6e8c988d915e77e3ec397be6b17e414a9c2dfb83600a6fd0ca93aa33662f47078692a350281ddb27d7a8205c5b085702f87140c7ca6929024422cbeafb2ec8a3e43c7ca8e5dd04b8981f28199dbf774cece719
