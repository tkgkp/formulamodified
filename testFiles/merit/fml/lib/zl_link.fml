:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: zl_link.fml
:: Utworzony: 29.06.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Obsługa powiązań między zleceniami (dla zleceń złożonych z półfabrykatami albo złożonych niezależnie)
::            Plik biblioteczny - wspólna obsługa dla czynności obszaru roboczego TTE_PZL
::======================================================================================================================


\is_main_podzlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Sprawdza, czy zlecenie jest głównym podzleceniem (albo zleceniem prostym)
::   WE: [_a] - ZL.ref() lub bieżący rekord
::   WY: 0 / 1
::  OLD: \is_main_podzlec/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _result:=(ZL.TREE_TYP='M' | ZL.TREE_TYP='P')
?};
ZL.cntx_pop();
_result


\main_podzlec
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca zlecenie na którym powstaje produkt. Możliwe są następujące przypadki:
::       1. _a:      zlecenie złożone
::          _result: podzlecenie montażowe
::
::       2. _a:      zlecnie proste, ale składnik zlecenia złożonego
::          _result: podzlecenie montażowe, zlecenia zlożonego z najwyższego poziomu
::
::       3. _a:      zlecenie proste, niebędące składnikiem złożonego
::          _result: _a
::
::       4. _a:      zlecenie niezależne
::          _result: _a
::   WE: _a - ZL.ref
::   WY: ZL.ref() lub null()
::  OLD: \main_podzlec/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=~~;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| _result:=_ref;
   ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
|| _result:=ZL.ref()
?};

{? _can_continue>0
||
   {? ZL.RODZAJ='Z'
   ||
::    Zlecenie zlożone
      _result:=null();
      _ktm_zlozone:=ZL.KTM;
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? {? ZL.KTM=_ktm_zlozone
            || _result:=ZL.ref()
            ?};
            ZL.next() & _result=null()
         !}
      ?}
   |? ZL.RODZAJ='P'
   ||
      {? ZL.NRNZL<>0
      ||
::       Znajduje zlecenie na saaaamej górze
         _top:=exec('top_level','zl_link',ZL.ref());
         {? _top<>null()
         ||
            ZL.cntx_psh(); ZL.clear();
            {? ZL.seek(_top)
            ||
               {? ZL.RODZAJ='N'
               ||
::                Jeśli na samej górze jest zlecenie ze zleceniami niezależnymi to na każdym z nich powstaje
::                produkt
                  _result:=_ref
               ||
::                Zwracam podzlecenie montażowe zlecenia na saaaaamej górze
::                !!! REKURENCJA !!!
                  _result:=exec('main_podzlec','zl_link',_top)
               ?}
            ?};
            ZL.cntx_pop()
         ?}
      ?}
   |? ZL.RODZAJ='N'
   ||
::    Ta funkcja nie powinna być nigdy używana dla zlecenia niezależnego
::    Zgłaszam komunikat dla wdrożeniowca i zwracam null
      FUN.wdrerror('Błąd wywołania main_podzlec\\zl_common.fml - wywołano dla zlecenia niezależnego');
      _result:=null()
   ?}
?};
ZL.cntx_pop();
_result


\party_first
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Zwraca pierwsze zlecenie wyższego lub bieżącego poziomu na którym powstają partie
::   WE: [_a] - ZL.ref - dowolne zlecenie w strukturze
::       [_b] - ref_table - tablica odwiedzonych zleceń dla rekurencji
::   WY: ZL.ref lub null - najbliższe zlecenie z partią
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_visited:=~~;
{? var_pres('_b')>100
|| _visited:=_b
|| _visited:=exec('ref_table','#table')
?};

_result:=null();
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? _visited.r_find(ZL.ref())=0
   ||
      _visited.add(ZL.ref());

      {? ZL.RODZAJ='Z'
      ||
::       Jeżeli stoję na zleceniu najwyższego poziomu to przechodzę na montażowe
         _main:=exec('main_podzlec','zl_link',ZL.ref());
         {? _main<>null()
         ||
::          !!! REKURENCJA !!!
            _result:=exec('party_first','zl_link',_main,_visited)
         ?}
      ||
         _mat_part:=exec('material_party','material',ZL.KTM);
         {? ZL.RP='T' & _mat_part>0
         || _result:=ZL.ref()
         || {? ZL.TREE<>null()
            || ZL.cntx_psh();
               ZL.prefix();
               {? ZL.seek(ZL.TREE,)
               ||
::             !!! REKURENCJA !!!
                  _result:=exec('party_first','zl_link',,_visited)
               ?};
               ZL.cntx_pop()
            ?}
         ?}
      ?}
   ?}
?};
ZL.cntx_pop();
_result


\party_down
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Sprawdza czy poniżej w strukturze drzewa zleceń znajdują się zlecenia partiowane i pokazuje selektor z tymi
::       zleceniami do wyboru - jeżeli jest tylko jedno partyjne zlecenie to jest od razu zwracane bez selektora
::   WE: [_a] - ZL.ref lub bieżący rekord
::       [_b] - ref_table - tablica odwiedzonych zleceń dla rekurencji

::   WY: ~~ - użytkownik zrezygnował
::       ZL.ref() -  wybrane zlecenie z partią
::       null - brak partii
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=null();
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _tab:=exec('party_down_tab','zl_link');
   {? _tab.first()
   ||
      {? _tab.size()=1
      || _result:=exec('FindAndGet','#table',ZL,_tab.REF,,,null())
      |? _tab.size()>1
      || _title:='Wybór zlecenia'@;
         _sel:=_tab.mk_sel(_title,'P',,('#selzlpart'),,,,,'U');
         _tab.win_fld(_sel,,'SYM',,,20,,1,'Symbol'@,,'Symbol zlecenia'@);
         _tab.win_fld(_sel,,'OPIS',,,20,,1,'Opis'@,,'Opis zlecenia'@);
         _tab.win_fld(_sel,,'KTM',,,20,,1,'Indeks'@,,'Indeks materiałowy zlecenia'@);
         _tab.win_fld(_sel,,'KTM_NAZ',,,50,,1,'Nazwa materiału'@,,'Nazwa wyrobu zlecenia'@);
         _fb:="
            sel_exit()
         ";
         _tab.win_act(_sel,0,'Formuła','&Wybierz'@@,,,_fb,,1,,,,'W');
         _tab.win_btn(_sel,'text=%1,btn_label_align=center,panel=right,align=begin'['&Wybierz'@],'menu:W',,,,,,'noempty');

         _tab.win_sel(_sel);
         {? _tab.select(,1,5)
         || _result:=exec('FindAndGet','#table',ZL,_tab.REF,,,null())
         || _result:=~~
         ?}
      ?}
   ?}
?};
ZL.cntx_pop();
_result


\party_down_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Tworzy i wypełnia tabelę tymczasową ze zleceniami partiowanymi
::   WE: [_a] - ZL.ref lub bieżący rekord
::       [_b] - tab_tmp - tabelka którą zasilić, jeżeli nie podana to tworzę własną
::       [_b] - ref_table - tablica odwiedzonych zleceń dla rekurencji
::   WY: tab_tmp - zasilona tabelka ze zleceniami
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_tab:=~~;
{? var_pres('_b')>100
|| _tab:=_b
|| _tab:=tab_tmp(1
::    'POLE','TYP','Nazwa w oknie',
      ,'REF','STRING[16]','Nazwa pola 1'
      ,'SYM','STRING[20]','Nazwa pola 1'
      ,'OPIS','STRING[200]','Nazwa pola 2'
      ,'KTM','STRING[50]','Indeks materiałowy'
      ,'KTM_NAZ','STRING[100]','Nazwa materiału'
   )
?};

_visited:=~~;
{? var_pres('_c')>100
|| _visited:=_c
|| _visited:=exec('ref_table','#table')
?};

_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? _visited.r_find(ZL.ref())=0
   ||
      _visited.add(ZL.ref());
      _mat_part:=exec('material_party','material',ZL.KTM);
      {? ZL.RP='T' & _mat_part>0
      || _tab.prefix($ZL.ref(),);
         {? _tab.first()=0
         ||
            _tab.blank();
            _tab.REF:=$ZL.ref();
            _tab.SYM:=ZL.SYM;
            _tab.OPIS:=ZL.OPIS;
            _tab.KTM:=ZL.KTM().KTM;
            _tab.KTM_NAZ:=ZL.KTM().N;
            _tab.add()
         ?}
      ?};

      ZL.cntx_psh();
      ZL.index('TREEMTU');
      ZL.prefix(ZL.ref());
      {? ZL.first()
      || {!
         |?
::          !!! REKURENCJA !!!
            exec('party_down_tab','zl_link',,_tab,_visited);
            ZL.next()
         !}
      ?};
      ZL.cntx_pop()
   ?}
?};
ZL.cntx_pop();
_tab.prefix();
_tab


\top_level
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dla zlecenia podrzędnego zwraca zlecenie nadrzędne na najwyzszym poziomie lub przekazany w argumencie _a ref
::       jeśli zlecenie nie ma nadrzędnego
::   WE: _a - ZL.ref()
::   WY: ZL.ref() nadrzednego lub _a
::  OLD: \top_level/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_zl_pod:=_a;

_result:=null();
ZL.cntx_psh(); ZL.clear();
{? ZL.seek(_zl_pod)
|| _result:=ZL.ref();
   {? ZL.NRNZL>0
   ||
      ZL.cntx_psh();
      ZL.index('UNRZL');
      ZL.prefix(ZL.NRNZL);
      {? ZL.first()
      ||
::       !!! REKURENCJA !!!
         _result:=exec('top_level','zl_link',ZL.ref())
      ?};
      ZL.cntx_pop()
   ?}
?};
ZL.cntx_pop();
_result


\is_separate_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Sprawdza, czy zlecenie jest podzleceniem niezależnym
::   WE: _a - ZL.ref()
::   WY: 0 / 1
::  OLD: \is_separate_zl/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=0;
ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
|| {? ZL.RODZAJ='P' & ZL.NRNZL<>0
   || ZL.index('UNRZL');
      ZL.prefix(ZL.NRNZL);
      {? ZL.first()
      || _result:=(ZL.RODZAJ='N')
      ?}
   ?}
?};
ZL.cntx_pop();

_result


\sprawdz_podzlecenia
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: sprawdza, czy zostały już wygenerowane zlecenia potomne
::   WE: _a - ZL.ref()
::   WY: 1 - ok, czyli brak zleceń, 0 - są zlecenia podrzędne
::  OLD: \sprawdz/zl_zktl.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

ZL.cntx_psh();
_top_level:=exec('top_level','zl_link',_zl);
ZL.index('NRNZL');
ZL.prefix(exec('FindAndGet','#table',ZL,_zl,,"UNRZL",0));
{? ZL.size()>0 || _ok:=0 || _ok:=1 ?};
ZL.cntx_pop();
_ok


\subzlec_exist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Sprawdza, czy są podzlecenia do wskazanego zlecenia
::   WE: _a - ZL.ref()
::   WY: 0 - brak podzleceń
::       1 - są podzlecenia
::  OLD: \subzlec_exist/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_res:=0;
ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
|| ZL.index('NRNZL');
   ZL.prefix(ZL.UNRZL);
   {? ZL.size()>0
   || _res:=1
   ?}
?};
ZL.cntx_pop();
_res


\subsubzlec_exist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Sprawdza, czy są podzlecenia do wskazanego podzlecenia
::   WE: _a - ZL.ref()
::   WY: 0 - brak podzleceń
::       1 - są podzlecenia
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_res:=0;
ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
|| ZL.index('NRPZL');
   ZL.prefix(ZL.UNRZL);
   {? ZL.size()>0
   || _res:=1
   ?}
?};
ZL.cntx_pop();
_res


\check_tktl_arch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Sprawdza, czy dla dowolnego podzlecenia jest przypisana jako źródłowa archiwalna karta technologiczna
::   WE: _a - ZL.ref() (zlecenie nadrzędne)
::   WY: 1 - jeżeli co najmniej jedno podzlecenie ma archiwalną technologię, wpp 0
::  OLD: \check_tktl_arch/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_res:=0;
ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
|| ZL.index('NRNZL');
   ZL.prefix(ZL.UNRZL);
   {? ZL.first()
   || {!
      |? {? ZL.RKTL<>''
         || _arch:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,"ARCH",'N');
            {? _arch='T'
            || _res:=1
            ?}
         ?};
         ZL.next() & _res=0
      !}
   ?}
?};
ZL.cntx_pop();
_res


\get_nadzlec
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Zwraca zlecenie nadrzędne względem przekazanego, lub null jeśli() nie ma
::   WE: _a - ZL.ref()
::   WY: ZL.ref() lub null()
::  OLD: \get_nadzlec/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_zl_pod:=_a;

_result:=null();
ZL.cntx_psh(); ZL.clear();
{? ZL.seek(_zl_pod)
|| {? ZL.NRPZL>0
   || ZL.cntx_psh();
      ZL.index('UNRZL');
      ZL.prefix(ZL.NRPZL);
      {? ZL.first()
      || _result:=ZL.ref()
      ?};
      ZL.cntx_pop()
   |? ZL.LEVEL=1
   || _result:=exec('main_podzlec','zl_link',ZL.ref())
   ?}
?};
ZL.cntx_pop();
_result


\top_rodzaj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Dla zlecenia podrzędnego zwraca rodzaj zlecenia nadrzędnego na najwyższym poziomie lub rodzaj przekazanego w
::       argumencie _a jeśli zlecenie nie ma nadrzędnego
::   WE: _a - ZL.ref() - zlecenie
::   WY: STRING - ZL.RODZAJ lub ''
::  OLD: \top_rodzaj/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_result:='';
ZL.cntx_psh();
_top_level:=exec('top_level','zl_link',_zl);
{? _top_level<>_zl
||
   ZL.clear();
   {? ZL.seek(_top_level)
   || _result:=ZL.RODZAJ
   ?}
?};
ZL.cntx_pop();
_result


\root_zlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Zlecenie root
::   WE: _a - ZL.ref()
::   WY: ZL.ref()
::  OLD: \root_zlec/zlec5.fml
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_a)
|| {? ZL.TREE
   || _wyn:={? ZL.seek(ZL.TREE,) || exec('root_zlec','zl_link',ZL.ref()) || null() ?}
   || _wyn:=ZL.ref()
   ?}
|| _wyn:=null()
?};
ZL.cntx_pop();
_wyn


\is_podzlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy zlecenie jest podzleceniem
::   WE: [_a] - ZL.ref lub bieżący rekord
::   WY: 0/1
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? ZL.NRNZL>0
   || _result:=1
   ?}
?};
ZL.cntx_pop();
_result


\is_podzlec4mag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Sprawdza czy zlecenie jest podzleceniem raportowanym na magazyn
::   WE: [_a] - ZL.ref lub bieżący rekord
::   WY: 0/1
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _mag:=exec('FindAndGet','#table','TMAT',ZL.RTMATSRC,,"MAG",'');
   {? _mag='P'
   || _result:=1
   ?}
?};
ZL.cntx_pop();
_result


\subzlec_count
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Oblicza ile zlecenie powinno mieć podzleceń na podstawie technologii swojej i wszystkich półfabrykatów
::       poniżej
::       Jeżeli nie ma półfabrykatów to zwraca 1
::   WE: [_a] - ZL.ref lub bieżący rekord
::   WY: REAL - liczba podzleceń która powinna zostać utworzona lub -1 jeśli nie ma technologii
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||

:: Jeśli zlecenie nadrzędne to przeskakuję na podzlecenie montażowe
   {? ZL.RODZAJ='Z'
   || _mainpodzlec:=exec('main_podzlec','zl_link',ZL.ref());
      {? _mainpodzlec<>null()
      || ZL.prefix();
         _can_continue:=ZL.seek(_mainpodzlec)
      ?}
   ?};

   {? _can_continue>0
   ||
      _tech:=ZL.TYP().TECH;
      _ktl:=null();
      {? ZL.RTKTL<>''
      || _ktl:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,"ref()",null())
      |? ZL.RKTL<>''
      || _ktl:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,"ref()",null())
      ?};

      {? _ktl=null()
      || _can_continue:=0;
         _result:=-1
      ?};

      exec('tktl_cntx_psh','tech_common');
      {? _can_continue>0
      ||
::       Najpierw sprawdzam swoje półfabrykaty
         _msk:=(8+ref_name(_ktl))+3;
         exec('tktl_use','tech_common',_msk);
         TMAT.index('NNL');
         TMAT.prefix(_ktl);
         {? TMAT.first()
         || {!
            |? {? (TMAT.RKTL<>'' | TMAT.DFLT_KTL='T') & TMAT.LIMIT='T' & TMAT.MAG<>'T'
               || _result+=1
               ?};
               TMAT.next() & _can_continue>0
            !}
         ?}
      ?};

      {? _can_continue>0
      ||
::       Następnie iteruję po swoich podzleceniach
         ZL.index('NRPZL');
         ZL.prefix(ZL.UNRZL);
         {? ZL.first()
         || {!
            |?
::             !!! REKURENCJA !!!
               _res_rec:=exec('subzlec_count','zl_link');
               {? _res_rec>=0
               || _result+=_res_rec
               ?};
               ZL.next() & _can_continue>0
            !}
         ?}
      ?};
      exec('tktl_cntx_pop','tech_common')
   ?};
   ~~
?};
ZL.cntx_pop();
_result


\subzlec_generated
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy zlecenie ma wygenerowane podzlecenia do wszystkich swoich półfabrykatów
::       Jeżeli nie ma półfabrykatów to zwraca 1
::   WE: [_a] - ZL.ref lub bieżący rekord
::   WY: -1 - brak technologii
::       0 - nie wszystkie podzlecenia zostały wygenerowane
::       1 - wszystkie podzlecenia zostały wygenerowane
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||

:: Jeśli zlecenie nadrzędne to przeskakuję na podzlecenie montażowe
   {? ZL.RODZAJ='Z'
   || _mainpodzlec:=exec('main_podzlec','zl_link',ZL.ref());
      {? _mainpodzlec<>null()
      || ZL.prefix();
         _can_continue:=ZL.seek(_mainpodzlec)
      ?}
   ?};

   _tech:=ZL.TYP().TECH;
   _ktl:=null();
   {? ZL.RTKTL<>''
   || _ktl:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,"ref()",null())
   |? ZL.RKTL<>''
   || _ktl:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,"ref()",null())
   ?};

   {? _ktl=null()
   || _can_continue:=0;
      _result:=-1
   ?};

   {? _can_continue>0
   ||
::    Najpierw sprawdzam swoje półfabrykaty
      exec('tktl_cntx_psh','tech_common');
      _msk:=(8+ref_name(_ktl))+3;
      exec('tktl_use','tech_common',_msk);
      TMAT.index('NNL');
      TMAT.prefix(_ktl);
      {? TMAT.first()
      || {!
         |? {? (TMAT.RKTL<>'' | TMAT.DFLT_KTL='T') & TMAT.LIMIT='T' & TMAT.MAG<>'T'
            ||
               ZL.index('TMAT_SRC');
               ZL.prefix(ZL.UNRZL,TMAT.ref());
               {? ZL.size()=0
               || _can_continue:=0
               ?}
            ?};
            TMAT.next() & _can_continue>0
         !}
      ?};

      {? _can_continue>0
      ||
::       Następnie iteruję po swoich podzleceniach
         ZL.index('NRPZL');
         ZL.prefix(ZL.UNRZL);
         {? ZL.first()
         || {!
            |?
::             !!! REKURENCJA !!!
               _can_continue:=exec('subzlec_generated','zl_link');
               ZL.next() & _can_continue>0
            !}
         ?}
      ?};
      exec('tktl_cntx_pop','tech_common');
      ~~
   ?};
   ~~
?};
ZL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\ile_podzlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Zwraca liczbę wszystkich podzleceń danego zlecenia
::   WE: [_a] - ZL.ref() lub bieżące zlecenie
::   WY: REAL
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   ZL.cntx_psh();
   ZL.index('TREEMTU');
   ZL.prefix(ZL.ref());
   _result+=ZL.size();

   {? ZL.first()
   || {!
      |?
::       !!! REKURENCJA !!!
         _result+=exec('ile_podzlec','zl_link');
         ZL.next()
      !}
   ?};
   ZL.cntx_pop();
   ~~
?};
ZL.cntx_pop();
_result


\is_zl4tmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza, czy jest zlecenie półfabrykatowe powiązane z surowcem technologii zlecenia
::   WE: _a - TMAT.ref()
::   WY: ZL.ref() / null()
::----------------------------------------------------------------------------------------------------------------------
_tmat:=_a;
_result:=null();

ZL.cntx_psh();
_unrzl:=exec('FindAndGet','#table',TMAT,_tmat,,"NRK().ZL().UNRZL",0);
{? _unrzl
|| ZL.index('TMAT_SRC');
   ZL.prefix(_unrzl,_tmat);
   {? ZL.first()
   || _result:=ZL.ref()
   ?}
?};
ZL.cntx_pop();

_result


\comp_podzlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [17.00]
:: OPIS: Sprawdza, czy zlecenie jest podzleceniem drugiego
::   WE: _a - kandydat na podzlecenie
::       _b - zlecenie do porównania
::   WY: 1-tak 0-nie
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_comp:=_b;

ZL.cntx_psh();
ZL.prefix();
{? _a<>null() & _comp<>null() & ZL.seek(_a)
|| {!
   |? _result:=_comp=ZL.ref();
      ~_result & ZL.TREE & ZL.seek(ZL.TREE,)
   !}
?};
ZL.cntx_pop();
_result


\has_closed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Sprawdza czy zlecenie jest zamknięte i czy ma jakieś podzlecenia które są zamknięte
::   WE: [_a] - ZL.ref lub bieżący rekord
::   WY: 0 - zlecenie nie zamknięte i brak zamkniętych podzleceń
::       1 - zlecenie zamknięte lub są jakieś zamknięte podzlecenia
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? ZL.STAN='Z'
   || _result:=1
   ?};
   {? _result=0
   || ZL.cntx_psh();
      ZL.index('TREEMTU');
      ZL.prefix(ZL.ref());
      {? ZL.first()
      || {!
         |?
::          !!! REKURENCJA !!!
            _result:=exec('has_closed','zl_link');
            ZL.next() & _result=0
         !}
      ?};
      ZL.cntx_pop()
   ?};
   ~~
?};
ZL.cntx_pop();
_result


\check_tktl_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Sprawdza, czy dla dowolnego podzlecenia jest przypisana jako źródłowa nieaktywna karta technologiczna
::   WE: _a - ZL.ref() (zlecenie nadrzędne)
::   WY: 1 - jeżeli co najmniej jedno podzlecenie ma nieaktualną technologię
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_res:=0;
ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
|| ZL.index('NRNZL');
   ZL.prefix(ZL.UNRZL);
   {? ZL.first()
   || {!
      |?
         _act:=exec('tktl_act','tech_head',0);
         {? _act=0
         || _res:=1
         ?};
         ZL.next() & _res=0
      !}
   ?}
?};
ZL.cntx_pop();
_res

:Sign Version 2.0 jowisz:1048 2020/10/16 15:23:00 87e8ff8f8cc99f999e777ee86449085f54ca5e8fc13b95bfae6b612eda7e3ab1d385074286985afe822e5931515814396f91debefc9eeb07216c0c7fddeb4bfd2d86d468827b5a6f0cd300e2097fb4db88039797227b533dfe86df2d05a7f6fff98cc941cabae3e289e19eef5ae82847c46b1304985a60763856da492efc1716
