:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: harmonogramy.fml
:: Utworzony: 19-01-2015
:: Autor: RWR
::======================================================================================================================
:: Zawartość:  Formuły obsługi harmonogramowania czasu pracy.
::======================================================================================================================


\harm_decl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.10]
:: OPIS: Definicja struktury i metod obiektu __HARM.
::       opis metod: ustaw_okres - ustawia pole OKRES jeśli okres został wybrany.
::   WE:
::   WY:
::  OLD: \obj_decl_HARM/okres.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('HARM',@.CLASS)>0 || return() ?};

obj_decl('HARM',
:: Czy wybrany jest okres
   obj_fld('WYBRANY',0),
   obj_fld('OKR_REF',null()),
:: Czy istnieje okres
   obj_fld('OKRES',0),
:: godzina rozpoczęcia doby w niedziele
   obj_fld('GRDN',time(6,0,0)),
:: Ruchomy czas pracy pracownika czy określone sś szczegóły dnia
   obj_fld('RCP_DET',0),
:: Ruchomy czas pracy pracownika czy widelki
   obj_fld('RCP_W',''),
:: Ruchomy czas pracy pracownika rozpoczęcie pracy
   obj_fld('RCP_GOD',time(0,0,0)),
:: Ruchomy czas pracy pracownika zakończenie widełek
   obj_fld('RCP_GDO',time(0,0,0)),
: Ustawienie flagi podczas operacji zamknięcia miesiąca
   obj_fld('ZAMK_MIE',0),
:: automatyczna kwalifikacja zapisów WE/WY dla poprzedniej doby roboczej
   obj_fld('POP_DOBA',1),
:: Automatyczna kwalifikacja danych o godzinach przepracowanych na podstawie WE/WE
   obj_fld('KW_AUTO',1),

:: metody
   obj_meth('__init',
      "  .jest_okr();
         .set_par();
         .sunday(date())
      "
   ),
:: Czy miesiac do rozliczen jest otwarty
   obj_meth('mc_otw',
      "  .set_par(); .mc_otw(_a,_b,0,0)
      ",type_of(date),type_of(0)
   ),
   obj_meth('mc_otw',
      "  .mc_otw(_a,_b,_c,0)
      ",type_of(date()),type_of(0),type_of(0)
   ),
   obj_meth('mc_zam_prac',
      "  _wyn:=0;
         A_OKRP_M.cntx_psh();
         A_OKRP.cntx_psh();
         A_OKRP_M.index('A_OKRPM');
         A_OKRP.index('A_OKRDP');
         A_OKRP.prefix(P.ref());
         {? A_OKRP.find_le(_a)
         || {!
            |? {? _a<=A_OKRP.DO & _a>=A_OKRP.OD
               || A_OKRP_M.prefix(A_OKRP.ref(),_a~1,_a~2);
                  {? A_OKRP_M.first()
                  || _wyn:=A_OKRP_M.STATUS='X'
                  ?}
               ?};
               ~_wyn & A_OKRP.next()
            !}
         ?};
         A_OKRP_M.cntx_pop();
         A_OKRP.cntx_pop();
         _wyn
      ",type_of(date())
   ),
   obj_meth('mc_otw',
      "  _wyn:=1;
         A_OKRM.cntx_psh();
         A_OKRM.index('A_OKRMR');
         A_OKRM.prefix(_a~1,_a~2);
         {? A_OKRM.first()
:: Do daty
         || {? ~_c
               &
               ((~_d & .mc_zam_prac(_a))
               |
               ( .ZAMK_MIE<>#A_OKRM.ref() & A_OKRM.S<>'O'
               &
               ({? A_OKRM.DZ<>#0
                || {? _a<=A_OKRM.DZ
                   || 1
                   || _closeD:=exec('getMscCloseDate','grafik',_a,1);
                      {? _closeD<>#0 || _a<=_closeD || 1 ?}
                   ?}
                || 1
                ?})
               ))
            || {? _b
               || FUN.emsg('%1\n%2'['Miesiąc %1 został przesłany do rozliczenia.'@[_a$8],'Modyfikacja zablokowana.'@])
               ?};
               _wyn:=0
            ?}
         ?};
         A_OKRM.cntx_pop();
         _wyn
      ",type_of(date),type_of(0),type_of(0),type_of(0)
   ),
   obj_meth('jest_okr',
      "  .set_par();
         A_OKR.cntx_psh();
         A_OKR.prefix();
         _jest_okres:=A_OKR.size();
         A_OKR.cntx_pop();
         .OKRES:=_jest_okres>0;
         _jest_okres
      "
   ),
   obj_meth('ustaw_okres',
      "  {? A_OKR.OD<>#0 & A_OKR.DO<>#0
         || .WYBRANY:=1;
            .OKR_REF:=A_OKR.ref()
         || .WYBRANY:=0;
            .OKR_REF:=null()
         ?}
      "
   ),
   obj_meth('wylacz_okres',
      "  .WYBRANY:=0;
         .OKR_REF:=null()
      "
   ),
   obj_meth('sunday',
      "  KST_DEF.index('SYMBOL');
         KST_DEF.prefix('KST.GRDN','KST.GRDN');
         {? KST_DEF.first()
         || KST_WAR.index('KST_DEF');
            KST_WAR.prefix(REF.S_FIRMA,KST_DEF.ref());
            {? KST_WAR.find_le(_a)
            || .GRDN:=($KST_WAR.WARTOSC)()
            ?}
         ?};
         .GRDN
      ",type_of(date())
   ),
   obj_meth('sunday',"
      _handel:=0;
      {? exec('get_par','#parametr',320,2)='T' & _a>=date(2018,3,1)
      || _handel:=1;
         _slo_kod:=exec('kod','ext_slo','GRUPPRAC','PR_NIEDZ');
         {? _slo_kod<>null
         || GRUPPRAC.cntx_psh();
            GRUPPRAC.index('GRPOD');
            GRUPPRAC.prefix(_slo_kod,_b);
            {? GRUPPRAC.find_le(_a) & (GRUPPRAC.DO>=_a | GRUPPRAC.DO=#0)
            || _handel:=0
            ?};
            GRUPPRAC.cntx_pop()
         ?}
      ?};
      {? _handel
      || *0
      || KST_DEF.index('SYMBOL');
         KST_DEF.prefix('KST.GRDN','KST.GRDN');
         {? KST_DEF.first()
         || KST_WAR.index('KST_DEF');
            KST_WAR.prefix(REF.S_FIRMA, KST_DEF.ref());
            {? KST_WAR.find_le(_a)
            || .GRDN:=($KST_WAR.WARTOSC)()
            ?}
         ?};
         .GRDN
      ?}",type_of(date),type_of(null)),
   obj_meth('sunday',".GRDN"),
: Sprawdzenie czy ustalony pracownik objęty jest ruchomym czasem pracy
: Wypełnienie pól: RCP_W, RCP_GOD, RCP_GDO, RCP_DET
: parametr: data weryfikacji
   obj_meth('RCP',
      "  _wyn:=0;
         .RCP_DET:=0;
         .RCP_W:='';
         .RCP_GOD:=.RCP_GDO:=*0;
         A_RWN.cntx_psh();
         A_RWN.index('WN_PRAC');
         A_RWN.prefix('T',P.ref());
         {? A_RWN.find_le(_a) & (A_RWN.DO>=_a | A_RWN.DO=#0)
         || _wyn:=1
         || _wyn:=0
         ?};
         {? ~_wyn
         || A_RWN.prefix('N',P.ref());
            {? A_RWN.find_le(_a) & (A_RWN.DO>=_a | A_RWN.DO=#0)
            || _wyn:=1
            || _wyn:=0
            ?}
         ?};
         {? _wyn
         || {? A_RWN.A_RWN
            || A_RWN.prefix();
               {? ~A_RWN.seek(A_RWN.A_RWN,) || _wyn:=0 ?}
            ?};
            {? _wyn
            || A_RWP.index('A_RWP');
               A_RWP.prefix(A_RWN.ref(),_a~4);
               {? A_RWP.first()
               || .RCP_W:=A_RWP.W;
                  .RCP_GOD:=A_RWP.GOD;
                  .RCP_GDO:=A_RWP.GDO;
                  .RCP_DET:=1
               ?}
            ?}
         ?};
         A_RWN.cntx_pop();
         _wyn
      ",type_of(date())
   ),
:: pobranie ustawień z parametrów globalnych systemu
   obj_meth('set_par',
      "  .POP_DOBA:=exec('test_par','parametr',255,'T');
         .KW_AUTO:=exec('test_par','parametr',254,'T')
      "
   ),
:: wprowadzenie zapisu do historii WE/WY na podstawie podstawowego zapisu sprzed wstępnej kwalifikacji
:: Wymagany jest ustalony bufor tabeli R_REJ_WW.
:: Bufor powinien zawierać informacje wprowadzane do tabeli roboczej.
   obj_meth('add_hist',"
     _wyn:=0;
      R_REJ_WW.cntx_psh;
      {? R_REJ_WW.use('r_hw'+(($(R_REJ_WW.DZ~1))+2)+(('0'+$(R_REJ_WW.DZ~2))+2))
      || R_REJ_WW.index('R_REJ_WW');
         R_REJ_WW.prefix();
         R_REJ_WW.cntx_psh;
         R_REJ_WW.prefix(R_REJ_WW.P,R_REJ_WW.DZ);
         {? R_REJ_WW.find_key(R_REJ_WW.GD,R_REJ_WW.ST)
         || R_REJ_WW.del
         ?};
         R_REJ_WW.cntx_pop;
         _wyn:=R_REJ_WW.add(1)
      ?};
      R_REJ_WW.cntx_pop();
      _wyn
      "
   ),
:: pobranie indywidualnej godziny od i godziny do dla pracy w porze nocnej
   obj_meth('pn_time',"
      _time:={? _c='OD' || KST.R_PNOD || KST.R_PNDO ?};
      GDPN.cntx_psh();
      GDPN.index('GDPNPD');
      GDPN.prefix(_a);
      {? GDPN.find_ge(_b) & (GDPN.DDO=date(0,0,0) | GDPN.DDO>=_b)
      || _time:={? _c='OD' || GDPN.GOD || GDPN.GDO ?}
      ?};
      GDPN.cntx_pop();
      _time
      ",type_of(null),type_of(date()),type_of('')
   )
)


\mask_decl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK 2006
:: OPIS: Definicja struktury i metod obiektu MASK.
::  OLD: \obj_decl/obszar.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('MASK',@.CLASS)>0 || return() ?};

obj_decl('MASK',
   obj_fld('P','pracowni'),
   obj_fld('R_KWGODZ',''),
   obj_fld('R_PRACDN',''),
   obj_fld('R_POR_WW',''),
   obj_fld('R_REJ_WW',''),
   obj_fld('R_ERRKAL',''),
   obj_fld('R_ERRMAX',''),
   obj_fld('R_KARHIS',''),
   obj_fld('R_SPEC',''),
   obj_fld('R_WYK',''),
   obj_fld('R_WO',''),
   obj_fld('R_WZCZ',''),
   obj_fld('R_ERRKAR','r_xa'),
   obj_fld('A_OKRP',''),
   obj_fld('A_OKRD',''),
   obj_fld('A_SCPP',''),
   obj_fld('R_MARG',''),
   obj_fld('BASE',''),
   obj_meth('__init'," _a.Init() "),

:: Init - ustawienie nazw stalych odpowiadajacych nazwie maski reprezentowanej
::        przez nazwe pola obiektu
   obj_meth('Init',
   "
      .R_KWGODZ:='r_kg';
      .R_PRACDN:='r_pd';
      .R_POR_WW:='r_ph';
      .R_REJ_WW:='r_ww';
      .R_ERRKAL:='r_xb';
      .R_ERRMAX:='r_xc';
      .R_KARHIS:='r_karhis';  R_KARHIS.use('r_karhis');
      .R_SPEC:='r_spec';      R_SPEC.use('r_spec');
      .R_WYK:='r_wyk';        R_WYK.use('r_wyk');
      .R_WO:='r_woi';         R_WO.use('r_woi');
      .R_WZCZ:='r_wzczas';    R_WZCZ.use('r_wzczas');
      .A_OKRP:='x_okrpi';     A_OKRP.use('x_okrpi');
      .R_MARG:='r_margi';     R_MARG.use('r_margi');
      .A_SCPP:='x_scpi';      A_SCPP.use('x_scpi');
      .A_OKRD:='x_okrdi';     A_OKRD.use('x_okrdi');
      .BASE:='P'
   "),

:: Use  - Otwarcie odpowiedniej maski tabeli przekazanej jako akronim w postaci stringu.
::        Metoda przeciazona - wywolana z jednym parametrem otwiera maske dla kontekstu tabeli _P
   obj_meth('Use',
   "
      ($_a)().use(($('.'+_a))())

   ",type_of('')),

::        Wywolana z trzema parametrami dodatkowo otwiera maske dla roku i miesiaca przekazanych jako odpowiednio
::        drugi i trzeci parametr.
   obj_meth('Use',
   "
      ($_a)().use(($('.'+_a))()+.MaskZbio(_b,_c))

   ",type_of(''),type_of(0),type_of(0)),



:: Name - Wynikiem jest biezaca maska dla tabeli przekazanej jako akronim w postaci stringu.
::        Metoda przeciazona - wywolana z jednym parametrem, wynik odpowiednia maska dla kontekstu tabeli _P
   obj_meth('Name',"

      ($('.'+_a))()

   ",type_of('')),

::        Wywolana z trzema parametrami daje w wyniku maskę dla roku i miesiaca przekazanych jako odpowiednio
::        drugi i trzeci parametr.
   obj_meth('Name',"

      ($('.'+_a))()+.MaskZbio(_b,_c)

   ",type_of(''),type_of(0),type_of(0)),

:: MaskZbio - tworzy część nazwy zbiorów maskowalnych zależną od określonej daty
::            pierwszy argument musi określać rok, drugi miesiąc.
::            W przypadku wywołania z nieprawidłowymi argumentami wyświetla komunikat i zwraca "____".
   obj_meth('MaskZbio',
   "
      {? var_pres('_a')=1 | var_pres('_b')=1
      || ('00'+($_a)+2)+('00'+($_b)+2)
      || FUN.emsg('Funkcja MaskZbio','Błędny argument wywołania.');
         4*'_'
      ?}

   ",type_of(0),type_of(0))
)

:Sign Version 2.0 jowisz:1045 2021/09/17 15:17:07 7f17056b86e0a817479283c8f4648b463a498640058c52f2e8d5af641887d803618446acb80bef013cf9ab8dfb60edaafa7ab3728fdda7ea27179a309feb6700daec4cda2b7c3127cbb7f0974d1609223422b93777d1f203607ff5be48224913e2b28fcdd8c6b7193562fc362ff20e3dd1c649a14d285dc6b22b2ae54c91ac54
