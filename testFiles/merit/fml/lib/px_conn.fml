:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku:  px_conn.fml [12.10]
:: Utworzony: 2011-07-20
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Polaczenia grupujace (spinaja PX_OBJ z PX_GRP) w planie strategicznym
::            (wielowymiarowym planie pojemnosciowym)
::======================================================================================================================


\clone_current
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Klonuje polaczenie grupujace i dodaje je do nowej wersji planu
::       Kontekst pracy - polaczenie grupujace ktore ma byc sklonowane
::   WE: _a - PX_VER.ref() - wersja docelowa
::       _b - PX_GRP.ref() - obiekt grupujacy docelowy
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

PX_OBJ.cntx_psh();
PX_GRP.cntx_psh();
_what:='obiekt planowania: '+PX_CONN.PX_OBJ().SYMBOL+' ---> '+'obiekt grupujący: '+PX_CONN.PX_GRP().SYMBOL;
_msg:='Duplikowanie połączenia grupującego: '+_what;

{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

pxkomm.sect_beg(_msg,,1);
PX_CONN.cntx_psh();
PX_CONN.clear();

PX_CONN.PX_VER:=_a;
PX_CONN.PX_GRP:=_b;
_result:=PX_CONN.add();
{? _result=0
|| _msg:='Nie udało się dodanie połączenia grupującego: '+_what;
   pxkomm.error(_msg)
||
:: jesli sie udalo dodac to odswiezam ilosc i termin zaplanowane w planie glownym
   {? PX_CONN.PX_VER=exec('get_mainversion','px_ver')
   || exec('il_plan_refresh','px_obj',PX_CONN.PX_OBJ);
      exec('planend_refresh','px_obj',PX_CONN.PX_OBJ)
   ?};
:: aktualizuje pole materiału
   exec('update_m','px_grp',PX_CONN.PX_GRP)
?};
PX_CONN.cntx_pop();
PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
pxkomm.sect_end();
_result


\buffer
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Bufor dla tabeli PX_CONN
::   WY: obj_new - tablica nazwana reprezentujaca rekord tabeli PX_CONN
::----------------------------------------------------------------------------------------------------------------------
_buffer:=$("obj_new('Ref'
::  _PX_VER      Wersja
                   ,'PX_VER'
::  REAL         Ilość
                   ,'ILOSC'
::  INTEGER      Lp w obiekcie grupującym
                   ,'LP_GRP'
::  _PX_OBJ      Obiekt planowany
                   ,'PX_OBJ'
::  _PX_GRP      Obiekt grupujący
                   ,'PX_GRP'
::  STRING[1]    Komunikaty planu - ostrzeżenia
                   ,'KOM_WARN'
::  STRING[1]    Komunikaty planu - błędy
                   ,'KOM_ERR'
::  STRING[1]    Komunikaty planu - informacje
                   ,'KOM_INFO'
::  _M           Materiał
                   ,'M'
::  metoda          czyszczenie bufora blank(), gdy podany parametr ~~, to bl_void()
                   ,'blank'
::  metoda          czyszczenie bufora typem pustym bl_void()
                   ,'bl_void'
::  metoda          czyszczenie bufora za pomocą bufora tabeli bl_table()
                   ,'bl_table'
::  metoda          _buffer.get() - pobieranie zawartości bufora
                   ,'get'
::  metoda          _buffer.set() - pola<>~~ nanoszone do tabeli
                   ,'set'
::  metoda          _buffer.setf() - wszystkie pola nanoszone do tabeli
                   ,'setf'
::  metoda          _buffer.cntx_get(ref()/#ref()[,maska]) - wczytuje bufor podanych parametrów
                   ,'cntx_get'
::  metoda          _buffer.ref() - zwraca wartosc .Ref
                   ,'ref'
                   "+{? var_pres('_a')=3 & form(_a)<>'' || ","+_a || "" ?}+"
                   )");
_buffer:=_buffer();

:: metody - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

_buffer.blank:="
                {? var_pres('_a')=0   || .bl_void()
                |? var_pres('_a')>100 || .bl_table(_a)
                || .bl_table(PX_CONN)
                ?}
               ";

_buffer.bl_void:="
                  .PX_VER:=~~;
                  .ILOSC:=~~;
                  .LP_GRP:=~~;
                  .PX_OBJ:=~~;
                  .PX_GRP:=~~;
                  .KOM_WARN:=~~;
                  .KOM_ERR:=~~;
                  .KOM_INFO:=~~;
                  .M:=~~;
                  .Ref:=null();
                  1
                 ";

_buffer.bl_table:="
                  _tab:=PX_CONN;
                  _tab.cntx_psh();
                  _tab.blank(1);
                  .get(_tab);
                  _tab.cntx_pop();
                  _tab.get();
                  .Ref:=null();
                   1
                  ";

_buffer.get:="
              .PX_VER:=PX_CONN.PX_VER;
              .ILOSC:=PX_CONN.ILOSC;
              .LP_GRP:=PX_CONN.LP_GRP;
              .PX_OBJ:=PX_CONN.PX_OBJ;
              .PX_GRP:=PX_CONN.PX_GRP;
              .KOM_WARN:=PX_CONN.KOM_WARN;
              .KOM_ERR:=PX_CONN.KOM_ERR;
              .KOM_INFO:=PX_CONN.KOM_INFO;
              .M:=PX_CONN.M;
              .Ref:=PX_CONN.ref();
              (.)
             ";

_buffer.set:="
              {? .PX_VER<>~~     || PX_CONN.PX_VER:=.PX_VER ?};
              {? .ILOSC<>~~      || PX_CONN.ILOSC:=.ILOSC ?};
              {? .LP_GRP<>~~     || PX_CONN.LP_GRP:=.LP_GRP ?};
              {? .PX_OBJ<>~~     || PX_CONN.PX_OBJ:=.PX_OBJ ?};
              {? .PX_GRP<>~~     || PX_CONN.PX_GRP:=.PX_GRP ?};
              {? .KOM_WARN<>~~   || PX_CONN.KOM_WARN:=.KOM_WARN ?};
              {? .KOM_ERR<>~~    || PX_CONN.KOM_ERR:=.KOM_ERR ?};
              {? .KOM_INFO<>~~   || PX_CONN.KOM_INFO:=.KOM_INFO ?};
              {? .M<>~~          || PX_CONN.M:=.M ?};
              ~~
             ";

_buffer.setf:="
               PX_CONN.PX_VER:=.PX_VER;
               PX_CONN.ILOSC:=.ILOSC;
               PX_CONN.LP_GRP:=.LP_GRP;
               PX_CONN.PX_OBJ:=.PX_OBJ;
               PX_CONN.PX_GRP:=.PX_GRP;
               PX_CONN.KOM_WARN:=.KOM_WARN;
               PX_CONN.KOM_ERR:=.KOM_ERR;
               PX_CONN.KOM_INFO:=.KOM_INFO;
               PX_CONN.M:=.M;
               ~~
              ";

_buffer.cntx_get:="
                   _tab:=PX_CONN;
                   {? type_of(_a)=7 || _ref:=#_a; _mask:=ref_name(_a)
                   |? type_of(_a)=1 || _ref:=_a;  _mask:={? var_pres('_b')=2 || _b || _tab.name() ?}
                   || .blank(~~); return(.)
                   ?};
                   _tab.cntx_psh();
                   {? {? _tab.name()<>_mask
                      || _tab.use(_mask)
                      || 1
                      ?}
                   || _tab.prefix();
                      {? _tab.seek(_ref,)
                      || .get()
                      || .blank(~~)
                      ?}
                   || .blank(~~)
                   ?};
                   _tab.cntx_pop();
                   (.)
                  ";

_buffer.ref:=".Ref";
:: czyszczenie bufora
_buffer.blank(~~);

:: zwracam bufor
_buffer


\add
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Dodaje rekord do tabeli PX_CONN
::   WE: _a - _args - bufor tabeli PX_CONN - exec('buffer','px_conn')
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

_buffer:=_a;

PX_CONN.blank();

:: Sprawdzam czy mozna dodac

_buffer.set();


_result:=PX_CONN.add();
{? _result>0
||
:: jesli sie udalo dodac to odswiezam ilosc i termin zaplanowane w planie glownym
   {? PX_CONN.PX_VER=exec('get_mainversion','px_ver')
   || exec('il_plan_refresh','px_obj',PX_CONN.PX_OBJ);
      exec('planend_refresh','px_obj',PX_CONN.PX_OBJ)
   ?};
:: aktualizuje pole materiału
   exec('update_m','px_grp',PX_CONN.PX_GRP)
?};
_result


\can_add
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy mozna dodac danego PX_CONN do kolejki
::   WE: _a - _args - tablica nazwana - exec('blank_a','px_grp')
::       [_b]   - INTEGER - tryb dialogów:   0 - brak,
::                                           1 - komunikaty na ekran
::                                           2 - komunikaty do KOMMa,
::                                           3 - komunikaty do PX_KOMM
::       [_c] - INTEGER - [0]/1 - czy podczas sprawdzania obiektu porownywac zestaw startowy z obecnym
::       [_d] - INTEGER - 0/[1] - czy podczas sprawdzania obiektu dokonywać sprawdzeń powiązań zamówienia i zlecenia
::   WY: 0 - nie mozna dodac takiego PX_CONN
::       1 - wszystko jest ok - mozna dodawac
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_dialog:=2;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_set_chk:=1;
{? var_pres('_c')=type_of(0)
|| _set_chk:=_c
?};

_tie_chk:=1;
{? var_pres('_d')=type_of(0)
|| _tie_chk:=_d
?};

_result:=0;
_can_continue:=1;
_symbol:=exec('FindAndGet','#table',PX_OBJ,_args.PX_OBJ,,"SYMBOL",'');
_msg:='Nie można dodać do kolejki obiektu: '+_symbol+'. Powód: ';

:: 1. Sprawdzam czy powiazania sa poprawne
_can_continue:=exec('can_plan','px_obj',_args.PX_OBJ,_dialog,,_set_chk,_tie_chk);

{? _can_continue>0
|| _result:=1
?};
_result


\del_grp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Usuwa wszystkie polaczenia powiazane z danym PX_GRP
::   WE: _a - PX_GRP.ref() - obiekt grupujacy
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------

_result:=1;
_obj_grp:=_a;
::jesli w buforze ten sam obiekt grupujacy co przekazany w argumencie to nie robie seeka
_cntx_set:=1;
{? $_obj_grp<>$PX_GRP.ref()
|| _cntx_set:=0;
   PX_GRP.clear();
   {? PX_GRP.seek(_obj_grp)
   || _cntx_set:=1
   ?}
?};

{? _cntx_set>0
|| PX_CONN.cntx_psh();
   PX_CONN.index('PX_GRP');
   PX_CONN.prefix(PX_GRP.ref());
   _can_continue:=1;
:: ROZPOCZECIE TRANSAKCJI!!!
   do();
   {? PX_CONN.first()
   || {!
      |? _can_continue:=exec('delete','px_conn',PX_CONN.ref());
         PX_CONN.first() & _can_continue
      !}
   ?};
:: WYCOFANIE TRANSAKCJI!!!
   {? _can_continue>0
   || _result:=1
   || undo()
   ?};
:: ZAKONCZENIE TRANSAKCJI!!!
   end();
   PX_CONN.cntx_pop()
?};
_result


\delete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Usuwa polaczenie grupujace
::   WE: _a - PX_CONN.ref()
::   WY: 0 - porazka
::      >0 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_px_conn:=_a;

{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

PX_CONN.cntx_psh();
PX_CONN.clear();
{? PX_CONN.seek(_px_conn)
|| _ver:=PX_CONN.PX_VER;
   _obj:=PX_CONN.PX_OBJ;
   PX_OBJ.cntx_psh();
   PX_OBJ.clear();
   {? PX_CONN.PX_OBJ<>null()
   || PX_OBJ.use(8+$PX_CONN.PX_OBJ)
   ?};
   _what:='obiekt planowania: '+PX_CONN.PX_OBJ().SYMBOL+' ---> '+'obiekt grupujący: '+PX_CONN.PX_GRP().SYMBOL;
   PX_OBJ.cntx_pop();
   _msg:='Usuwanie połączenia grupującego: '+_what;
   pxkomm.sect_beg(_msg);
   _result:=PX_CONN.del(,1);
   {? _result=0
   || _msg:='Nie udało się usunięcie połączenia grupującego: '+_what;
      pxkomm.error(_msg)
   ||
::    Stempluje kolejke czasem i userem modyfikacji
      exec('mod_stamp_queue','px_ver',_ver);

::    jesli sie udalo usunac to odswiezam ilosc i termin zaplanowane w planie glownym
      {? _ver=exec('get_mainversion','px_ver')
      || exec('il_plan_refresh','px_obj',_obj);
         exec('planend_refresh','px_obj',_obj)
      ?}
   ?};
   pxkomm.sect_end()
?};
PX_CONN.cntx_pop();
_result


\panel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Definicja panelu polaczen grupujacych
::----------------------------------------------------------------------------------------------------------------------
PxSelect.Pxconn:=obj_new('WER');
PxSelect.Pxconn.WER:=exec('wer','px_conn');

_ff:="
   {? ~-cur_nfld()='SYMBOL'
   || _tab:=obj_new('CMP','KOM_ERR','KOM_WARN','KOM_INFO');
      _tab.CMP:='';
      _tab.KOM_ERR:=PX_CONN.KOM_ERR;
      _tab.KOM_WARN:=PX_CONN.KOM_WARN;
      _tab.KOM_INFO:=PX_CONN.KOM_INFO;
      exec('txt_bd','px_grp',_tab)
   || ''
   ?}
";
PX_CONN.fld_fml('PX_OBJ','BEFORE_DISPLAY',_ff);

~~


\wer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [17.00]
:: OPIS: Okno wertowania wer tabeli PX_CONN
::   WY: Akronim okna
::----------------------------------------------------------------------------------------------------------------------
_is_px_set:=exec('is_px_set','px_param')>0;

_wer:=PX_CONN.mk_sel('Składowe elementu kolejki'@,,,'tdkfeniownvckvd');
PX_CONN.win_fld(_wer,,'LP_GRP',,,2,,,'Lp.'@);
{? _is_px_set
|| PX_CONN.win_fld(_wer,,'PX_OBJ','SYMBOL',,44,,,'Symbol'@)
|| PX_CONN.win_fld(_wer,,'PX_OBJ','SYMBOL',,24,,,'Symbol'@)
?};
PX_CONN.win_fld(_wer,,'ILOSC',,,10,ST.DOKL,,'Ilość'@);
PX_CONN.win_fld(_wer,PX_VAR1,'JM',,,5,,,'jm'@);
PX_CONN.win_fld(_wer,PX_VAR1,'T_REAL',,,-11,,,'Termin realizacji'@);
PX_CONN.win_fld(_wer,PX_VAR1,'ZNACZNIK',,,5,,,'Zwrot'@);

_fb:="exec('px_grp_correct','px_grp',!PxSelect.Pxgrp)";
PX_CONN.win_act(_wer,,'Formuła','&Popraw'@@,,,_fb,,,,,,'P');
task_attach('TPP_PPS_DPLA');

_fgb:="exec('usu_gb','px_grp')";
_fga:="exec('usu_ga','px_grp')";
_fb:="exec('usu','px_grp')";
PX_CONN.win_act(_wer,,'Formuła','&Usuń'@@,,,_fb,,,1,_fgb,_fga,'U');
task_attach('TPP_PPS_DPLA');

_fb:="exec('go_obj_date','px_grp')";
PX_CONN.win_act(_wer,,'Formuła','Do da&ty'@@,,,_fb,,,,,,'T');

_fb:="exec('wer_komm','px_conn')";
PX_CONN.win_act(_wer,0,'Formuła','Komu&nikaty'@@,,,_fb,,0,,,,'N');

_fb:="exec('select_obj','px_poz')";
PX_CONN.win_act(_wer,0,'Formuła','Po&zycje'@@,,,_fb,,,,,,'Z');

_fb:="exec('px_grp_legenda','px_grp')";
PX_CONN.win_act(_wer,,'Formuła','&Legenda'@@,,,_fb,,,,,,'L');

_fb:="exec('px_grp_display','px_grp')";
PX_CONN.win_act(_wer,,'Wyświetl',,,,_fb);

_fb:="exec('px_grp_rkprz','px_grp')";
PX_CONN.win_act(_wer,,'Rekord',,,,_fb);

_wer


\wer_komm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AWI [12.41]
:: OPIS: Okno wertowania wer tabeli PX_CONN - Komunikaty
::----------------------------------------------------------------------------------------------------------------------
PX_CONN.PX_OBJ();
exec('select_obj','px_komm')


\actions
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Ustawia akcje w oknie PX_CONN
::----------------------------------------------------------------------------------------------------------------------
_wer:=PxSelect.Pxconn.WER;
_is_px_set:=exec('is_px_set','px_param');
{? PX_VAR.EDIT &
   (   ~_is_px_set |
       ( _is_px_set & (PX_VAR.PX_SET<>null() | exec('get','#params',8062,,OPERATOR.USER)='T'))
   )
|| PX_CONN.actions(_wer,'',,1)
|| PX_CONN.actions(_wer,'PU',,1)
?};
~~


\dnd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Ustawia d'n'd w oknie PX_CONN
::----------------------------------------------------------------------------------------------------------------------
_wer:=PxSelect.Pxconn.WER;
_is_px_set:=exec('is_px_set','px_param');
{? PX_VAR.EDIT &
   (   ~_is_px_set |
       ( _is_px_set & (PX_VAR.PX_SET<>null() | exec('get','#params',8062,,OPERATOR.USER)='T'))
   )
|| PX_CONN.dnd_sel(_wer,,'records.PX_CONN',"exec('dnd_renum','px_conn')")
|| PX_CONN.dnd_sel(_wer,,'records.PX_CONN',"")
?};
~~


\dnd_renum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Akcja renumerujaca drzewa (dnd albo akcja w oknie wertowania tabeli PX_CONN->PX_CONN)
::----------------------------------------------------------------------------------------------------------------------
_pos:=dnd_info('src_pos_in_window');

:: co przeciagamy
_records:=dnd_info('dropped_records');

:: na co upuszczamy
_dest_rec:=dnd_info('dest_record');

:: Obsluga blokowania
_can_continue:=1;

:: Blokowanie grupy na ktorej operuje
{? exec('lock','px_grp',PX_CONN.PX_GRP)=0
|| _can_continue:=0
?};

{? _can_continue>0
||
   PX_CONN.cntx_psh();
   {? PX_CONN.seek(_dest_rec)
   || exec('zmien_lp','#dragdrop','LP_GRP','PX_GRP',_records)
   ?};
   PX_CONN.cntx_pop();
   exec('mod_stamp_queue','px_ver',PX_CONN.PX_VER)
?};

:: Odblokowanie grupy na ktorej operuje
exec('unlock','px_grp',PX_CONN.PX_GRP);

:: Aktualizuje przyciski dot przeliczania jednej wersji planu
{? exec('is_one_version','px_param')>0
|| exec('przelicz_btn','px_plan')
?};
~~

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:38 8c32d070a4a1f341028ff41a1298b2f406b00ce93c7f99ebe6056552d771889c7625e63719d8d16afa33f9ac807f77aac386568488e4721ad5d4e3d7c0649205abffb78d7c94e1a916c6fd7bc63ae099015c13ffd1be814cbcb1a4e9a6423c644abbb6c50d5cb4a420eeb11978d413ff3ae13b90e89fc274b92023fc09dec7b2
