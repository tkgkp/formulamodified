:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: ppk.fml [12.51]
:: Utworzony: 2019/02/19
:: Autor: jaws
:: Systemy: PPK
::======================================================================================================================
:: Zawartość: Formuły (wspólne, ogólnego przeznaczenia) oraz obszary robocze dziedziny PPK.
::======================================================================================================================


\init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.22]
:: OPIS: Formuła inicjująca dla dziedziny PPK.
::   WE: [_a] [NUMBER] - Wyświetlać komunikaty? [0*/1].
::   WY: [1/0]
::----------------------------------------------------------------------------------------------------------------------
_msg:=var_pres('_a')=type_of(0) & _a;

{? ~exec('dostepny_u','f_zatr',,,'P') & ~exec('dostepny_u','f_zatr',,,'Z')
|| {? _msg
   || FUN.emsg('Brak dostępu do formy współpracy "P" lub "Z".'@)
   ?};
   return(0)
?};

_mask:=$exec('ref_firma','ustawienia')+1;
PPK_RAP.use('ppk_rap'+_mask);
PPK_RDA.use('ppk_rda'+_mask);

BPMN.SYM_DOM:='PPK';

:: Zmienna optymalizująca dostęp do parametru 188.
__PAR188:=PAR_SKID.get(188)='T';

:: Przeglądanie osób (czynność z dziedziny PKD), może odbywać się na rzecz procesu związanego np. z logistyką.
:: Tylko jawne wskazanie w procesie pozwala na jego identyfikację jako "personelowego".
:: Zmienna poniżej służy optymalizacji dostępu do tej informacji.
{? var_pres('__PERSONEL')<>type_of(0)
|| __PERSONEL:=0
?};

exec('czytaj','#stalesys',,KST,KST_PPK);
exec('__KAL','object');
exec('__RUB','object');
exec('__F_ZATR','object');

1


\grp_access
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.42]
:: OPIS: Formuła sprawdzająca, czy możliwe jest uruchomienie czynności "grupowych", tzn. wymagających dostępu do:
::        - wszystkich jednostek organizacyjnych;
::        - form współpracy: P i Z.
::   WE:
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
exec('no_limit','schemat','PPK') & exec('dostepny_u','f_zatr',,,'P',1) & exec('dostepny_u','f_zatr',,,'Z',1)


\ppk_ewi
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.22]
:: OPIS: Główna formuła obszaru roboczego PPK_EWI - Ewidencja PPK.
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: wspólne dla całej dziedziny
{? ~exec('init','ppk',1)
|| return()
?};

:: wyświetl obszar roboczy
exec('select','ppk_ucz');
~~


\ppk_dzb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.22]
:: OPIS: Główna formuła obszaru roboczego PPK_DZB - Dane zbiorcze PPK.
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: wspólne dla całej dziedziny
{? ~exec('init','ppk',1)
|| return()
?};

:: ustal kontekst działania
{? exec('pre_sel','ppk')=0
|| return()
?};

:: obszar roboczy konstruowany dla tabeli PPK_WNU
_wnd:=PPK_WNU.grp_make('Dane zbiorcze'@,
:: przed otwarciem
   "  PPK_WNU.cntx_psh();
      PPK_WPW.cntx_psh();
      PPK_KOM.cntx_psh();
      PPK_KWN.cntx_psh();
      OSOBA.cntx_psh();
      OSOBA.clear();
::    ukryj zakładki niedostępnych czynności
      _usr:=OPERATOR.USER;
::    zakładki 1,2 - deklaracje i wnioski
      {? exec('chk_role','#b__box',_usr,'PPK_EWI_PWNU')=0 &
         exec('chk_role','#b__box',_usr,'PPK_EWI_RWNU')=0
      || tab_hide(1);
         tab_hide(2)
      ?};
::    zakładki 3,4 - komunikaty
      {? exec('chk_role','#b__box',_usr,'PPK_EWI_PKOM')=0 &
         exec('chk_role','#b__box',_usr,'PPK_EWI_RKOM')=0
      || tab_hide(3);
         tab_hide(4)
      ?};
::    zakładka 5 - zwroty wpłat
      {? exec('chk_role','#b__box',_usr,'PPK_EWI_PKWZ')=0 &
         exec('chk_role','#b__box',_usr,'PPK_EWI_RKWZ')=0
      || tab_hide(5)
      ?};
::    zakładka 6 - naliczone wpłaty
      {? exec('chk_role','#b__box',_usr,'PPK_DZB_PWPL')=0 |
         exec('no_limit','schemat','PPK',0)=0
      || tab_hide(6)
      ?};
      1
   ",
:: identyfikator
   '#ppk_dzb',,,
:: podczas zamykania
   "  _val:=exec('exit','zws');
      {? _val
      || exec('sel_a','ppk_wnu');
         exec('sel_a','ppk_kom');
         PPK_WNU.cntx_pop();
         PPK_WPW.cntx_pop();
         PPK_KOM.cntx_pop();
         PPK_KWN.cntx_pop();
         OSOBA.cntx_pop();
         1
      ?}
   "
);

exec('ppk_dzb','ppk_wnu',PPK_WNU,_wnd);
exec('ppk_dzb','ppk_kom',PPK_WNU,_wnd);
exec('ppk_dzb','ppk_kwn',PPK_WNU,_wnd);
:: podtrzymanie przy życiu tabeli wpłat
_wpl:=exec('wpl_nal','ppk',PPK_WNU,_wnd);

:: wyświetl obszar roboczy
PPK_WNU.cntx_psh();
PPK_WNU.win_sel(_wnd);
PPK_WNU.select();
PPK_WNU.cntx_pop();
~~


\konf_sys
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Wprowadza zmiany w obsłudze tabel ze względu na PPK
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: obsługa znacznika aktywności uczestnika
_nw:='wer_akt';
P.trig_a('add',"{? P.ZA='T' || exec('wer_akt','ppk_ucz',P.OSOBA) ?}; ~~",_nw);
P.trig_a('put',"{? P.ZA<>bfld('ZA') || exec('wer_akt','ppk_ucz',P.OSOBA) ?}; ~~",_nw);
P.trig_a('del',"exec('wer_akt','ppk_ucz',bfld('OSOBA')); ~~",_nw);

:: podpowiedzi dla pola OSOBA.OBYWATEL na potrzeby kodowania obywatelstwa zgodnie ze standardem ISO
OSOBA.fld_fml('OBYWATEL','F3',"exec('lista','ext_slo','OBYWATEL',SLO_KOD,'KOD',$'SLO_KOD.NAZWA')");
~~


\jest
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Sprawdza, czy aplikacja PPK jest dostępna.
::   WE:
::   WY: 0 - brak licencji na aplikacje PPK, 1 - aplikacja jest dostępna
::----------------------------------------------------------------------------------------------------------------------
:: app_list().find_tab(,'APP_IDEN',,'=','PPK');
1


\pre_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Formuła warunkująca otwarcie okna.
::   WE:
::   WY: 0/1 - nie można wyświetlić okna/okno może być wyświetlone
::----------------------------------------------------------------------------------------------------------------------
:: utwórz i ustaw dedykowane okienko wyboru osoby
OSOBA.win_dict(exec('sel_osoba','ppk_ucz'));
OSOBA.win_patt('WZO');

:: sprawdź, czy są jakiekolwiek umowy
PPK_UMO.cntx_psh();
PPK_UMO.index('F_OD');
PPK_UMO.prefix(exec('ref_firma','#firma'));
_stop:=(PPK_UMO.size()=0);
PPK_UMO.cntx_pop();

{? _stop<>0
:: zakończ
|| FUN.emsg('Nie zarejestrowano żadnej umowy o prowadzenie programu.'@);
   exec('title','ppk');
   return(0)
?};

{? PPK_UMO.seek(KST_PPK.PPK_UMO,,1,1)
:: kontekst został już ustalony
|| return(1)
|| KST_PPK.PPK_UMO:=null
?};

:: ustal kontekst działania
{? exec('init','ppk_umo')=null
|| {? exec('choose','ppk_umo')=0
   || FUN.emsg('Umowa o prowadzenie programu musi być określona.'@);
      return(0)
   ?}
|| exec('title','ppk')
?};

KST_PPK.PPK_UMO<>null


\wyb_umo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Formuła przed akcją "Wybierz umowę" okienek tabel PPK_*.
::   WE:
::   WY: 0/1 - umowa nie została wskazana/wybrano inną umowę
::----------------------------------------------------------------------------------------------------------------------
_umowa:=KST_PPK.PPK_UMO;
exec('choose','ppk_umo')<>null & KST_PPK.PPK_UMO<>_umowa


\kwota
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Po redakcji pól z kwotami. Formuła utworzona ze względu na brak stosownej w pliku war_tech.fml
::   WE:
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
{? fld()>0
|| fld(fld()$2)
|| fld(0)
?};
1


\osoba_wz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Formuła "wzorzec" pól typu OSOBA.
::   WE:
::   WY: ''
::----------------------------------------------------------------------------------------------------------------------
OSOBA.f_set(
   'NAZWISKO,PIERWSZE,PESEL',,
   'OSOBA.REFERENCE in ('+exec('osoba_qr','ppk')+')',
:: argumenty zapytania ograniczającego zakres danych
   exec('ref_firma','ustawienia'),
   exec('szukaj_udb_sys','schemat','PPK','PODZORG'),
   OPERATOR.USER,
   exec('domyslny','schemat','PODZORG'),
   '\'%\''
);
''


\osoba_qr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Zwraca treść zapytania o listę wskazań dostępnych dla użytkownika osób.
::   WY: treść zapytania
::----------------------------------------------------------------------------------------------------------------------
'select distinct P.OSOBA as REF from P where '+
exec('filtr_p','schemat',exec('kody','f_zatr',,'P,Z'),,'*')+
'order by REF'


\ucz_qr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Zwraca treść zapytania o listę wskazań uczestników.
::   WE: _a [STRING] - oznaczenie argumentu określającego wskazanie umowy (domyślnie '_a')
::   WY: treść zapytania
::----------------------------------------------------------------------------------------------------------------------
_arg:={? var_pres('_a')<>type_of('') | _a='' || '_a' || _a ?};

'select Q.OSOBA as REF '+
'from PPK_UCZ as Q '+
'where Q.PPK_UMO=:'+_arg+' '+
'order by REF '


\x_r_pa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Formuła na wzorzec dla pól typu _R.
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
R.prefix();
R.f_set('RN',,'RN in (:_a)',__RUB.sys_sql(71,PPK_PWP.OD));
''


\x_st
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Procent wpłaty określony w stałych systemu.
::   WE: _a INTEGER - kod rubryki
::       _b [DATE] - data ustalenia wartości, domyślnie bieżąca data
::   WY: procent wpłaty
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_rub:=_a;
_od:={? var_pres('_b')<>type_of(date) || date() || _b ?};

{? _rub=__RUB.sys_kod(710,_od)
:: wpłata podstawowa (zatrudniający)
|| exec('czytaj','#stalesys',_od,KST_PPK,'SK_PF');
   KST_PPK.SK_PF

|? _rub=__RUB.sys_kod(711,_od)
:: wpłata dodatkowa (zatrudniający)
|| exec('czytaj','#stalesys',_od,KST_PPK,'SK_DOMDF');
   KST_PPK.SK_DOMDF

|? _rub=__RUB.sys_kod(712,_od)
:: wpłata podstawowa (zatrudniony)
|| exec('czytaj','#stalesys',_od,KST_PPK,'SK_MAXPU');
   KST_PPK.SK_MAXPU

?}


\licz_pod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Wylicza podstawę składek na PPK.
::       Art. 2. pkt 1. ustawy z dnia 4 października 2018 r. o pracowniczych planach kapitałowych.
::       Wynagrodzenie – podstawa wymiaru składek na ubezpieczenie emerytalne i rentowe uczestnika PPK, o której mowa w
::       ustawie z dnia 13 października 1998 r. o systemie ubezpieczeń społecznych, z wyłączeniem podstawy wymiaru
::       składek na ubezpieczenia emerytalne i rentowe osób przebywających na urlopie wychowawczym oraz pobierających
::       zasiłek macierzyński lub zasiłek w wysokości zasiłku macierzyńskiego.
::   WE: _a [STRING] - określenie wyliczeń dla: 'p' (domyślnie) - pracownika, 'z' - zleceniobiorcy
::   WY: kwota podstawy składek
::----------------------------------------------------------------------------------------------------------------------
:: ustal kontekst naliczania (_lz=0 - naliczana lista płac)
_lz:=(var_pres('_a')=type_of('') & -_a='z');
_zd:=date(0,0,0);

:: nie naliczaj składek przed określoną w stałych datą
{? {? _lz=0 || {? O.D<>_zd || O.D || date(O.RU,O.MU,0) ?} || RH.DWY ?}<KST_PPK.LICZ_OD
|| return(0)
?};

:: wartość zwracana
_kw:=0;
_podstPar:=exec('podstawa_par','oddelegowanie',1,100743);
{? _lz=0
:: wylicz dla listy płac i uwzględnij korektę
|| _podstawaSk:=exec('podstawa_sk','oddelegowanie','.ZUS',7087,,_podstPar);
   _kw:=_podstawaSk.podstawa+FUNKCJE.L_SYS(750)
|| ZC_INFO.cntx_psh();
   {? RH.ZC_INFO().ZUS='T'
::    wylicz dla rachunku do umowy i uwzględnij korektę
   || _podstawaSk:=exec('podstawa_sk','oddelegowanie','.ZUS',7087,1,_podstPar);
      _kw:=_podstawaSk.podstawa+FUNKCJE.Z_SYS(750)
   ?};
   ZC_INFO.cntx_pop()
?};
obj_del(_podstPar);

_od:={? _lz=0 || {? O.D<>_zd || O.D || date(O.RU,O.MU,0) ?} || RH.DWY ?};
exec('czytaj','#stalesys',_od,KST_PPK);

{? _kw=0 | KST_PPK.LICZ_OD=_zd
|| _kw:=0;
   {? _lz=0
   || "{! _ai:=1.._ |! {? FUNKCJE.L_SYS(_[_ai])<>0 || FUNKCJE.LK_SYS(_[_ai],,0) ?} !}"
   || "{! _ai:=1.._ |! {? FUNKCJE.Z_SYS(_[_ai])<>0 || FUNKCJE.ZK(__RUB.sys_kod(_[_ai]),,0) ?} !}"
   ?}(710,711,712,713);
   {? var_pres('_podstawaSk')=117
   || _diety:=_podstawaSk.diety;
      _zwroty:=_podstawaSk.zwrotyDoDol
   || _diety:=_zwroty:=0
   ?};
   {? _lz=0
   || FUNKCJE.LK_SYS(90101,,_diety);
      FUNKCJE.LK_SYS(901115,,_zwroty)
   || FUNKCJE.ZK(7196,,_diety);
      FUNKCJE.ZK(7249,,_zwroty)
   ?}

|? (_rpw:=__RUB.sys_kod(70,_od))<>0 & __RUB.MAP[_rpw]<>0
|| _wpu:=__RUB.sys_kod(712,_od);

   _spw:=
      {? _lz=0
      || "  _kw:=0;
            {! _ai:=4.._
            |! _rub:=__RUB.sys_kod(_[_ai],_a);
               _pwp:=exec('licz_pwp','ppk',P.ref(),_rub,_a,'-O');
               {? _rub=_b
               || _pwp:=exec('akt_wpl','ppk_pwp',0,_pwp,_c)
               ?};
               FUNKCJE.LK(_rub,,_pwp);
               _kw+=_pwp
            !};
            _kw
         "
      || "  _kw:=0;
            {! _ai:=4.._
            |! _rub:=__RUB.sys_kod(_[_ai],_a);
               _pwp:=exec('licz_pwp','ppk',RH.ZLE,_rub,_a,'-O');
               {? _rub=_b
               || _pwp:=exec('akt_wpl','ppk_pwp',1,_pwp,_c)
               ?};
               FUNKCJE.ZK(_rub,,_pwp);
               _kw+=_pwp
            !};
            _kw
         "
      ?}(_od,_wpu,_kw,710,711,712,713);

   {? _spw=0
   || _kw:=0;
:: 90101 Kwota diet pomniejszająca podstawę PPK --> 7196 OZ: Pom. podst. PPK
:: 901115 Kwota zwrotów powiększająca podst. PPK --> 7249 OZ: Pow. podst. PPK
      {? _lz=0
      || FUNKCJE.LK_SYS(90101,,0);
         FUNKCJE.LK_SYS(901115,,0)
      || FUNKCJE.ZK(7196,,0);
         FUNKCJE.ZK(7249,,0)
      ?}
   || {? var_pres('_podstawaSk')=117
      || _diety:=_podstawaSk.diety;
         _zwroty:=_podstawaSk.zwrotyDoDol
      || _diety:=_zwroty:=0
      ?};
      {? _lz=0
      || FUNKCJE.LK_SYS(90101,,_diety);
         FUNKCJE.LK_SYS(901115,,_zwroty)
      || FUNKCJE.ZK(7196,,_diety);
         FUNKCJE.ZK(7249,,_zwroty)
      ?}
   ?}
?};

{? var_pres('_podstawaSk')=117
|| obj_del(_podstawaSk)
?};

:: Czy podstawa PPK jest ujemna:
{? _kw<0
|| _param:=exec('get_par','#parametr',273);
:: Czy parametr każe zerować ujemną podstawę:
   {? type_of(_param)=type_of('') & _param='T'
   || _brutto:={? _lz || FUNKCJE.Z(200) || FUNKCJE.L_SYS(45) ?};
::    Czy kwota rachunku lub płaca zasadnicza jest ujemna:
      {? _brutto<0
      || _kw:=0
      ?}
   ?}
?};

_kw


\licz_pwp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Ustala procent wpłaty.
::   WE: _a [REFERENCE] - wskazanie: ZC, P, OSOBA
::       _b [INTEGER]   - kod rubryki właściwy dla wpłaty
::       _c [DATE]      - data, na którą ma być ustalony procent
::       _d [STRING] - lista uwzględnianych(+)/pomijanych(-) sposobów rejestracji
::      [_e][INTEGER]   - 0/1, czy pominąć sprawdzanie blokady z art. 25, domyślnie 0 - sprawdzamy blokadę
::   WY: procent wpłaty
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_ref:=_a;
_rub:=_b;
_od:=_c;
_mod:='';
{? var_pres('_d')=type_of('') & form(_d)<>''
|| _mod:=form(_d);
   {? 1+_mod<>'+' & 1+_mod<>'-'
   || _mod:=''
   ?}
?};
:: Jeśli jest parametr i mówi "pomiń srawdzanie blokady":
_blkChk:={? var_pres('_e')=type_of(0) & _e=1 || 0 || 1 ?};
:: wartość zwracana
_pwp:=0;

:: osoba
{? $_ref*ZC.name()=1
|| P.cntx_psh();
   P.prefix();
   _osoba:=ZC.P().OSOBA;
   P.cntx_pop()
|? $_ref*P.name()=1
|| _osoba:=P.OSOBA
|| _osoba:=_ref
?};

:: Sprawdzamy blokadę z art. 25:
{? _blkChk
|| _d0:=date(0,0,0);
   _dtWB25B:=exec('spr_wnu','ppk_wnu',_osoba,,_od,'WB25B',1);
:: Jeśli była blokada z art. 25 i nie było po niej wznowienia:
   {? _dtWB25B<>_d0 & ~exec('spr_wnu','ppk_wnu',_osoba,_dtWB25B,_od,'WB25W',0)
::    Sprawdzam czy jest to kod rubryki związanej ze składkami pracodawcy
::    lub czy osoba nie ma złożonego wniosku o dobrowolne opłacanie podczas blokady z art. 25.:
   || {? (_rub=__RUB.sys_kod(710,_od) | _rub=__RUB.sys_kod(711,_od))
         |
         ~exec('spr_wnu','ppk_wnu',_osoba,_dtWB25B,_od,'DOWU25',0)
::    Jeśli jest to rubryka związana z wpłatami pracodawcy, lub osoba nie ma wniosku o dobrowolne opłacanie:
      || _pwp:=0;
         return(_pwp)
      ?}
   ?}
?};

PPK_PWP.cntx_psh();
PPK_PWP.index('RNOD');
PPK_PWP.prefix(exec('ref_firma','ustawienia'),$_ref,_rub);
{? PPK_PWP.find_le(_od)
|| {? _mod<>''
   || {? (1+_mod='+' & (1-_mod)*PPK_PWP.SR=0) | (1+_mod='-' & (1-_mod)*PPK_PWP.SR<>0)
      || _pwp:=exec('licz_pwp','ppk',_ref,_rub,PPK_PWP.OD-1,_mod,1);
         PPK_PWP.cntx_pop();
         return(_pwp)
      ?}
   ?};

   _pwp:=
      {? PPK_PWP.BLOKADA='T'         || 0
      |? PPK_PWP.ZMIANA='T'          || PPK_PWP.STAWKA
      |? _rub=__RUB.sys_kod(710,_od) || KST_PPK.SK_PF
      |? _rub=__RUB.sys_kod(711,_od) || KST_PPK.SK_DOMDF
      |? _rub=__RUB.sys_kod(712,_od) || KST_PPK.SK_MAXPU
      ?}

|? $_ref*ZC.name()=1 & KST_PPK.PWP_NUD<>'T'
|| _pwp:=exec('licz_pwp','ppk',ZC.P,_rub,_od,_mod,1)
|? $_ref*P.name()=1 & KST_PPK.PWP_NUD<>'T'
|| _pwp:=exec('licz_pwp','ppk',_osoba,_rub,_od,_mod,1)
?};
PPK_PWP.cntx_pop();

_pwp


\licz_skl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Wylicza kwotę składki na PPK.
::   WE: _a [INTEGER] - kod składnika właściwy dla procentu wpłaty
::       _b [INTEGER] - kod składnika właściwy dla kwoty wpłaty
::       _c [STRING] - określenie wyliczeń dla: 'p' (domyślnie) - pracownika, 'z' - zleceniobiorcy
::       _d [INTEGER] - kod składnika właściwy dla kwoty korekty, brak lub wartość 0 spowoduje pominięcie w wyliczeniach
::          składnika korygującego występującego na wyliczanej liście/rachunku
::   WY: kwota wpłaty
::----------------------------------------------------------------------------------------------------------------------
:: ustal kontekst naliczania (_lz=0 - naliczana lista płac)
_lz:=(var_pres('_c')=type_of('') & -_c='z');

:: rubryki procentu i wpłaty
_rp:=_a;
_rs:=_b;
:: referencja do prefiksu lista/rachunek
_xr:={? _lz=0 || O.ref() || RH.ref() ?};
:: kwota i rubryka korekty wpłaty
_kk:=0;
_rk:={? var_pres('_d')=type_of(0) & _d>0 || _d ?};

_usun_prz:="
   _prz:=exec('szukaj','ppk_pod',_a,_b);
   PPK_POD.cntx_psh();
   PPK_POD.prefix();
   {? PPK_POD.seek(_prz) & PPK_POD.REJ_TRYB='A'
   || PPK_POD.del()
   ?};
   PPK_POD.cntx_pop()
";

{? KST_PPK.LICZ_OD=date(0,0,0)
|| _usun_prz(P.ref(),_xr);
   return(0)
?};

:: nie naliczaj składek przed określoną w stałych datą
{? {? _lz=0 || {? O.D<>date(0,0,0) || O.D || date(O.RU,O.MU,0) ?} || RH.DWY ?}<KST_PPK.LICZ_OD
|| _usun_prz(P.ref(),_xr);
   return(0)
?};

{? var_pres('_a')<>type_of(0) | _a<0 | _a>__RUB.max() |
   var_pres('_b')<>type_of(0) | _b<0 | _b>__RUB.max()
|| return(0)
?};

:: uwaga, na liście pomimo braku podstawy lub stawki mogą wystąpić korekty składnika,
:: dlatego, żeby niepotrzebnie nie komplikować kodu pobrane zostaną w tym miejscu (co
:: i tak trzeba by prędzej, czy później zrobić)
{? _rk>0
:: kwota korekty składnika listy/rachunku
|| _kk:={? _lz=0 || FUNKCJE.L(_rk) || FUNKCJE.Z(_rk) ?}
?};

_podstawa:={? _lz=0 || FUNKCJE.L_SYS(70) || FUNKCJE.Z_SYS(70) ?};
{? _podstawa=0
:: możliwe, że jest tylko korekta
|| exec('zap_prz','ppk',P.ref(),_xr,_rs,_kk);
   return(_kk)
?};

_dt:={? _lz || RH.DWY || date(O.RU,O.MU,0) ?};

_stawka:={? _lz=0 || FUNKCJE.L(_rp) || FUNKCJE.Z(_rp) ?};
{? _stawka=0
:: usuń informacje o zwiększeniu przychodu z tytułu wpłat,
:: ale honoruj wartość pochodzącą z ewentualnej korekty
|| exec('zap_prz','ppk',P.ref(),_xr,_rs,_kk);
   return(_kk)
?};

_rub_pod:=__RUB.sys_kod(70);
_wplp_u:=__RUB.sys_kod(712,_dt);
_sum_pod:=_sum_skl:=_sum_kor:=0;
_miesiac:=1;

:: Sprawdzenie wpłaty podstawowej uczestnika.
_spr_wpu:=
   "  _result:=0;
      PPK_PWP.cntx_psh();
      PPK_PWP.index('RNOD');
      PPK_PWP.prefix(exec('ref_firma','ustawienia'),_a,_b);
      _dt:=_c;
      _findLe:=PPK_PWP.find_le(_dt);
      {? _findLe
      || {! |? PPK_PWP.SR<>'O' & PPK_PWP.OD=_dt & _findLe
         |! _dt+=1;
            _findLe:=PPK_PWP.find_le(_dt)
         !};
         _result:=PPK_PWP.SR='O'
      ?};
      PPK_PWP.cntx_pop();
      _result
   ";

_O_ref:=O.ref();
_P_ref:=P.ref();
_R_ref:={? _lz<>0 || RH.ref() || null ?};
_firma:=exec('ref_firma','ustawienia');

LS.cntx_psh();
RH.cntx_psh();
P.cntx_psh();
P.index('OSOBA');
P.prefix(P.OSOBA,_firma);
O.cntx_psh();
O.index('LISTYUBZ');
O.prefix(_firma,O.RU,O.MU);
_loop:=O.first();
{!
|? _loop & _miesiac<>0
|! LS.use(O.LT);
   LS.index('PRACNRRU');
   {? O.F_ZATR().KOD<>'Z' & FUNKCJE.CZY_POD()
   || _loop:=P.first();
      {!
      |? _loop
      |! {? O.ref()<>_O_ref | P.ref()<>_P_ref
         || LS.prefix(P.ref());
            {? LS.find_key(_rub_pod)
            || _sum_pod+=LS.KW;
               {? LS.find_key(_rp)
                  &
                  {? _rp=_wplp_u & LS.KW<>_stawka
                  || _spr_wpu($P.OSOBA,_rp,date(O.RU,O.MU,0))
                  || LS.KW=_stawka
                  ?}

               || {? LS.find_key(_rs)
                  || _sum_skl+=LS.KW
                  ?};
                  LS.prefix(P.ref(),_rk);
                  _loop:=LS.first();
                  {!
                  |? _loop
                  |! _sum_kor+=LS.KW;
                     _loop:=LS.next()
                  !}
               || _miesiac:=0
               ?}
            ?}
         ?};
         _loop:=P.next()
      !}
   || _loop:=P.first();
      {!
      |? _loop
      |! LS.prefix(P.ref(),_rub_pod);
         _loop:=LS.first();
         {!
         |? _loop & _miesiac<>0
         |! {? LS.RH<>_R_ref
            || _sum_pod+=LS.KW;
               LS.cntx_psh();
               LS.index('ZLEC');
               LS.prefix(LS.RH);
               {? LS.find_key(_rp)
                  &
                  {? _rp=_wplp_u & LS.KW<>_stawka
                  || _spr_wpu($P.OSOBA,_rp,LS.RH().DWY)
                  || LS.KW=_stawka
                  ?}

               || {? LS.find_key(_rs)
                  || _sum_skl+=LS.KW
                  ?};
                  LS.prefix(LS.RH,_rk);
                  _loop:=LS.first();
                  {!
                  |? _loop
                  |! _sum_kor+=LS.KW;
                     _loop:=LS.next()
                  !}
               || _miesiac:=0
               ?};
               LS.cntx_pop()
            ?};
            _loop:=LS.next()
         !};
         _loop:=P.next()
      !}
   ?};
   _loop:=O.next()
!};
P.cntx_pop();
O.cntx_pop();
RH.cntx_pop();
LS.cntx_pop();

_kw:=
   {? _miesiac<>0
::    oblicz składkę u ujęciu miesięcznym
   || ((_podstawa+_sum_pod)*_stawka*0.01)$2-(_sum_skl-_sum_kor)
   || _podstawa*_stawka*0.01
   ?}$2;

:: Zerowy przychód i świadczenia niepieniężne:
:: "W sytuacji przyznania uczestnikowi PPK przez pracodawcę świadczenia niepieniężnego, które stanowi podstawę wymiaru
:: składek na ubezpieczenia emerytalne i rentowe, gdy w miesiącu otrzymania tego świadczenia uczestnik PPK nie otrzymał
:: żadnego innego wynagrodzenia, z którego można dokonać potrącenia wpłat do PPK finansowanych przez tego uczestnika,
:: podmiot zatrudniający jest zobowiązany do naliczenia i dokonania wpłat do PPK tylko tych finansowanych przez siebie."
:: PPK w praktyce:Poradnik PPK dla kadr i płac
{? _kw<>0 & (_rp=__RUB.sys_kod(712,_dt) | _rp=__RUB.sys_kod(713,_dt))
:: Suma powiększenia podstawy o świadczenia i stałe składniki niepieniężne:
|| _snpSumP:=0;
   {? _lz=0 & ((FUNKCJE.L_SYS(76)>0) | (FUNKCJE.L_SYS(76,0)>0))
   || {? (FUNKCJE.L_SYS(761)>0) | (FUNKCJE.L_SYS(761,0)>0)
::    Tablica z rubrykami należącymi do atrybutu świadczeń niepieniężnych:
      || _SNP:=__RUB.sys_rub(761,_dt);
         {? _SNP.first()
         || {!
            |? {? FUNKCJE.L(_SNP.RN) | FUNKCJE.L(_SNP.RN,_SNP.RN,0)
               || _snpSumP+=exec('wartosc_p_u','lista_licz',P.OSOBA,O.RU,O.MU,'U',_SNP.RN,P.ref())
               ?};

               _SNP.next()
            !}
         ?}
      ?};

::    Dodanie sum z rubryk należących do atrybutu stałych składników niepieniężnych:
      _snpSumP+=FUNKCJE.L_SYS(762)+FUNKCJE.L_SYS(762,0);

::    Jeżeli suma świadczeń i stałych składników niepieniężnych podwyższających podstawę jest równa podstawie PPK,
::    wyzeruj składkę PPK pracownika:
      {? _snpSumP=FUNKCJE.L_SYS(70)+FUNKCJE.L_SYS(70,0)
      || _kw:=0
      ?}

:: Zleceniobiorca:
   |? _lz=1
::    Pobranie sum z rubryk należących do atrybutu stałych składników niepieniężnych:
   || _snpSumP+=FUNKCJE.Z_SYS(762)+FUNKCJE.Z_SYS(762,0);
::    Jeżeli suma stałych składników niepieniężnych podwyższających podstawę jest równa podstawie PPK,
::    wyzeruj składkę PPK zleceniobiorcy:
      {? (_snpSumP<>0) & (_snpSumP=FUNKCJE.Z_SYS(70)+FUNKCJE.Z_SYS(70,0))
      || _kw:=0
      ?}
   ?}
?};

:: korekta
_kw+=_kk;

:: aktualizuj informację o zwiększeniu przychodu
exec('zap_prz','ppk',P.ref(),_xr,_rs,_kw);

_kw


\suma_skl_prac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: pk [12.51]
:: OPIS: Wylicza sume kwot składek na PPK dla konkretnego etatu bądź zleceniobiorcy. Bufor PPK_KWN musi być ustalony.
::   WE: _a [INTEGER] - kod składnika właściwy dla kwoty składki
::       _b [INTEGER] - rok ubezpieczeniowy
::       _c [INTEGER] - miesiąc ubezpieczeniowy
::   WY: _wyliczona suma dla składnika
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(0) | _a<0 | _a>__RUB.max() |
   var_pres('_b')<>type_of(0) | var_pres('_c')<>type_of(0)
|| return(0)
?};

_rubryka:=_a;
_rok:=_b;
_mc:=_c;
_wynik:=0;

LS.cntx_psh();
O.cntx_psh();
O.index('LISTYUBZ');

O.prefix(exec('ref_firma','ustawienia'),_rok,_mc);
_loop:=O.first();
{!
|? _loop
|! LS.use(O.LT);
   LS.index('PRACNRRU');
   LS.prefix(PPK_KWN.P,_rubryka);
   _loop:=LS.first();
   {!
   |? _loop
   |! _wynik+=LS.KW;
      _loop:=LS.next()
   !};
   _loop:=O.next()
!};
O.cntx_pop();
LS.cntx_pop();
_wynik


\funpom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.51]
:: OPIS: Menu obsługi funkcji pomocniczych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
FUN.info('Funkcje pomocnicze nie zostały zdefiniowane.'@)


\zlicz_zwrot
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.51]
:: OPIS: Zliczenie wartości zwrotu składek firmy. Bufor listy płac musi być ustalony.
::   WE: _a - rodzaj korekty
::       _b - atrybut
::   WY: wartość zwrotu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') || _typ:=_a || return(0) ?};
{? var_pres('_b')=type_of(0) || _attr:=_b || return(0) ?};
{? ~exec('add_O_RH','ppk_kwn',_typ)
|| return(0)
?};
_rr:=O.ref();
_lz:=O.F_ZATR().KOD;
{? _lz='Z'
|| _rh:=RH.ref;
   _dt:=RH.DWY;
   _rr:=_rh
|| _rh:=null;
   _dt:=O.D
?};
_wynik:=0;
PPK_KWN.cntx_psh();
PPK_KWN.index('ORH');
PPK_KWN.prefix(P.ref,O.ref,_rh,_typ);
{? PPK_KWN.first()
|| {!
   |? _wynik+=exec('zlicz_skl_kor','ppk_kwk',_attr,_dt,_typ);
      PPK_KWN.next()
   !}
?};
PPK_KWN.cntx_pop();

PPK_POK.cntx_psh();
PPK_POK.index('RN');
PPK_POD.cntx_psh();
PPK_POD.index({? _lz='Z' || 'POD_RH' || 'POD_O' ?});
:: pomiń w kwocie nadpłaty pracodawcy te przychody, które
:: oznaczono jako pomijane przy wyliczaniu przychodu
PPK_POD.prefix(_rr,P.ref(),'N',O.RP);
_loop:=PPK_POD.first();
{!
|? _loop
|! {? date(PPK_POD.WYL_R,PPK_POD.WYL_M,0)<date(PPK_POD.POD_R,PPK_POD.POD_M,0)
::    uwzględniaj tylko te przychody, które nie mogły być rozliczone
   || PPK_POK.prefix(PPK_POD.ref());
      _loop:=PPK_POK.first();
      {!
      |? _loop
      |! {? __RUB.sys_attr(PPK_POK.R().RN,_attr,_dt)
         || _wynik-=PPK_POK.KW
         ?};
         _loop:=PPK_POK.next()
      !}
   ?};
   _loop:=PPK_POD.next()
!};
PPK_POD.cntx_pop();
PPK_POK.cntx_pop();

_wynik


\fun_perm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [12.51]
:: OPIS: Pozwolenie na używanie niektórych funkcji.
::   WE:
::   WY: (1/0) - dostęp do pełnej funkcjonalności.
::----------------------------------------------------------------------------------------------------------------------
1


\title
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.51]
:: OPIS: Formuła odpowiedzialna za tytuł okna głównego aplikacji.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
AreaTitle.setTitle()


\wpl_nal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Wstawia do okna obszaru panel zawierający kwoty naliczonych wpłat.
::   WE: _b TABLE - alias tabeli obszaru roboczego
::       _a STRING - akronim okienka obszaru roboczego
::   WY: alias tabeli naliczonych wpłat
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_TAB:=_a;
_wnd:=_b;

_BUF:=exec('wpl_buf','ppk');
_BUF.win_sel(exec('wpl_wer','ppk',_BUF));
_BUF.win_edit(exec('wpl_red','ppk',_BUF));

_mode:='maximized_with_title';
:: panel zawierający kwoty naliczonych wpłat
_TAB.grp_sel(_wnd,_BUF,_BUF.win_sel('?'),'Naliczone wpłaty'@,,,,,
:: przed obsługą
   "  _BUF:=cur_tab(1,1);
      {? _a=0 | _BUF.size()<>0
      || return()
      ?};
      _MSC:=exec('wpl_mco','ppk');
      {? _MSC.find_key(date()~1,date()~2) | _MSC.first()
::       pobierz kwoty wpłat z ustalonego miesiąca
      || exec('wpl_pob','ppk',_BUF,_MSC.R,_MSC.M);
         exec('wpl_tyt','ppk',_BUF,_MSC.R,_MSC.M)
      ?}
   ",,,,
:: tryb
   _mode
);
_BUF


\wpl_buf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Tworzy tabelę zawierającą kwoty naliczonych wpłat.
::   WE:
::   WY: alias tabeli
::----------------------------------------------------------------------------------------------------------------------
_BUF:=tab_tmp(3,
   'NAZWISKO','STRING['+$MS.fld_len(OSOBA,'NAZWISKO')+']',MS.name(OSOBA,'NAZWISKO'),
   'PIERWSZE','STRING['+$MS.fld_len(OSOBA,'PIERWSZE')+']',MS.name(OSOBA,'PIERWSZE'),
   'PESEL','STRING['+$MS.fld_len(OSOBA,'PESEL')+']',MS.name(OSOBA,'PESEL'),
   'OSOBA','INTEGER','Osoba',
   'PW','REAL','Podstawa naliczenia wpłat'@,
   'PF','REAL','Wpłata podstawowa pracodawcy'@,
   'DF','REAL','Wpłata dodatkowa pracodawcy'@,
   'PU','REAL','Wpłata podstawowa uczestnika'@,
   'DU','REAL','Wpłata dodatkowa uczestnika'@,
   'WPF','REAL','Wyrównanie wpł. podst. pracodawcy'@,
   'WDF','REAL','Wyrównanie wpł. dod. pracodawcy'@,
   'WPU','REAL','Wyrównanie wpł. podst. uczestnika'@,
   'WDU','REAL','Wyrównanie wpł. dod. uczestnika'@,
   'ZPF','REAL','Zwrot wpł. pod. pracodawcy'@,
   'ZDF','REAL','Zwrot wpł. dod. pracodawcy'@,
   'SW','REAL','Suma wpłat'@
);

:: zablokuj możliwość dodania kolumn technicznych do widoku
_BUF.fld_attr('OSOBA',2);
_BUF.fld_attr('PW',,2);

_BUF


\wpl_tyt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Ustala tytuł okienka naliczonych wpłat.
::   WE: _a TABLE - alias tabeli naliczonych wpłat
::       _b INTEGER - rok kalendarzowy
::       _c INTEGER - miesiąc kalendarzowy
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_BUF:=_a;
_rok:=_b;
_msc:=_c;

_BUF.hdr_sel();
{? _rok<>0 & _msc<>0
|| _BUF.hdr_sel(': '+date(_rok,_msc,0)$8)
?};
~~


\wpl_wer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Tworzy interfejs użytkownika (okno wertowania) dla tabeli naliczonych wpłat.
::   WE: _a TABLE - alias tabeli naliczonych wpłat
::   WY: akronim okienka
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_BUF:=_a;

_mob:='mobile_visible=1';
_wnd:=_BUF.mk_sel('Naliczone wpłaty'@,'P',,'#ppk_wpl_nal',,,,,,,,,,,,'on');
:: podstawowe dane uczestnika planu kapitałowego
_BUF.win_fld(_wnd,,'NAZWISKO',,,-20,,,'Nazwisko'@,,MS.name(_BUF,'NAZWISKO'),,,,,,_mob);
_BUF.win_fld(_wnd,,'PIERWSZE',,,-20,,,'Imię'@,,MS.name(_BUF,'PIERWSZE'),,,,,,_mob);
_BUF.win_fld(_wnd,,'PESEL',,,-11,,,'PESEL'@,,MS.name(_BUF,'PESEL'));
:: podstawa, wpłaty i ich podsumowanie
_BUF.win_fld(_wnd,,'PW',,,-12,2,,,,MS.name(_BUF,'PW'),,,,,,_mob);
_BUF.win_fld(_wnd,,'PF',,,-12,2,,'Wpł. pod. firma'@,,MS.name(_BUF,'PF'));
_BUF.win_fld(_wnd,,'DF',,,-12,2,,'Wpł. dod. firma'@,,MS.name(_BUF,'DF'));
_BUF.win_fld(_wnd,,'PU',,,-12,2,,'Wpł. pod. ucz.'@,,MS.name(_BUF,'PU'));
_BUF.win_fld(_wnd,,'DU',,,-12,2,,'Wpł. dod. ucz.'@,,MS.name(_BUF,'DU'));
_BUF.win_fld(_wnd,,'WPF',,,-12,2,,'Wyr. wpł. pod. firma'@,,MS.name(_BUF,'WPF'));
_BUF.win_fld(_wnd,,'WDF',,,-12,2,,'Wyr. wpł. dod. firma'@,,MS.name(_BUF,'WDF'));
_BUF.win_fld(_wnd,,'WPU',,,-12,2,,'Wyr. wpł. pod. ucz.'@,,MS.name(_BUF,'WPU'));
_BUF.win_fld(_wnd,,'WDU',,,-12,2,,'Wyr. wpł. dod. ucz.'@,,MS.name(_BUF,'WDU'));
_BUF.win_fld(_wnd,,'ZPF',,,-12,2,,'Zwr. wpł. pod. firma'@,,MS.name(_BUF,'ZPF'));
_BUF.win_fld(_wnd,,'ZDF',,,-12,2,,'Zwr. wpł. dod. firma'@,,MS.name(_BUF,'ZDF'));
_BUF.win_fld(_wnd,,'SW',,,-12,2,,,,MS.name(_BUF,'SW'),,,,,,_mob);
:: akcje
_fml:="exec('wpl_msc','ppk',cur_tab(1,1))";
_BUF.win_act(_wnd,1,'Formuła','Miesiąc'@@,,,,_fml,1);
_BUF.win_act(_wnd,0,'Formuła','Miesiąc'@@,,,,_fml,1,,,,,,'target=window');
_BUF.win_act(_wnd,0,'Szukaj');
_BUF.win_act(_wnd,0,'Kolejność');

_wnd


\wpl_red
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Tworzy interfejs użytkownika (okno edycji) dla tabeli naliczonych wpłat.
::   WE: _a TABLE - alias tabeli naliczonych wpłat
::   WY: akronim okienka
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_BUF:=_a;

:: pomijane pola
_pomin:=',OSOBA,';

_wnd:=_BUF.mk_edit('Naliczona wpłata'@,0,'#ppk_wpl_nal',10,10);
_num:=_BUF.fld_num();
{! _ii:=1.._num
|! _acr:=_BUF.fld_acr(_ii);
   {? _pomin*(','+_acr+',')=0
   || _BUF.win_efld(_wnd,,_acr,,,32)
   ?}
!};

_wnd


\wpl_mco
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Pobiera listę miesięcy, za które mogły być naliczone wpłaty.
::   WE:
::   WY: alias tabeli
::----------------------------------------------------------------------------------------------------------------------
sql(
   'select distinct O.RU as R, O.MU as M from O where O.FIRMA=:_a order by R desc, M desc',
   exec('ref_firma','ustawienia')
)


\wpl_msc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Akcja "Miesiąc" okienka naliczonych wpłat.
::   WE: _a TABLE - alias tabeli naliczonych wpłat
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_BUF:=_a;

:: pobierz listę miesięcy
_MSC:=exec('wpl_mco','ppk');

:: okienko wyboru miesiąca
_wnd:=_MSC.mk_sel('Miesiące'@,'P',,'#ppk_wpl_msc',10,10,15,,'U');
_MSC.win_fld(_wnd,,'R',,,,,,'Rok'@);
_MSC.win_fld(_wnd,,'M',,,,,,'Miesiąc'@);
_MSC.win_act(_wnd,,'Formuła','Wybierz'@@,,,,"sel_exit()",1);
_MSC.win_act(_wnd,,'Szukaj');
_MSC.win_act(_wnd,,'Kolejność');
_MSC.win_sel(_wnd);

:: okienko dla wyświetlenia i wyszukiwania
_wnd:=_MSC.mk_edit('Miesiąc'@,,'#ppk_wpl_msc',10,20);
_MSC.win_efld(_wnd,,'R',,,5,,,'Rok'@);
_MSC.win_efld(_wnd,,'M',,,5,,,'Miesiąc'@);
_MSC.win_edit(_wnd);

{? _MSC.select()
:: pobierz dane z wybranego miesiąca
|| exec('wpl_pob','ppk',_BUF,_MSC.R,_MSC.M);
   exec('wpl_tyt','ppk',_BUF,_MSC.R,_MSC.M)
?};

:: porządki
obj_del(_MSC);
~~


\wpl_pob
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Pobiera kwoty naliczonych wpłat.
::   WE: _a TABLE - alias tabeli naliczonych wpłat
::       _b INTEGER - rok kalendarzowy
::       _c INTEGER - miesiąc kalendarzowy
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_BUF:=_a;
_rok:=_b;
_msc:=_c;

_BUF.erase();

_od:=date(_rok,_msc,0);
_pw:=__RUB.sys_kod(70,_od,1);
_pf:=__RUB.sys_kod(720,_od,1);
_df:=__RUB.sys_kod(721,_od,1);
_pu:=__RUB.sys_kod(722,_od,1);
_du:=__RUB.sys_kod(723,_od,1);
_zPf:=__RUB.sys_kod(7721,_od,1);
_zDf:=__RUB.sys_kod(7722,_od,1);
_ls:="
   _sum:=0;
   LS.index('OSOBAKOD');
   LS.prefix(exec('ref_firma','ustawienia'),OSOBA.ref(),_a);
   _loop:=LS.first();
   {!
   |? _loop
   |! _sum+=LS.KW;
      _loop:=LS.next()
   !};
   _sum
";

F_ZATR.cntx_psh();
F_ZATR.prefix();
_fz_p:={? F_ZATR.find_tab(,'KOD',,'=','P') || F_ZATR.ref() || null ?};
_fz_z:={? F_ZATR.find_tab(,'KOD',,'=','Z') || F_ZATR.ref() || null ?};
F_ZATR.cntx_pop();

OSOBA.cntx_psh();
OSOBA.prefix();
OSOBA.f_set(,,
:: ogranicz listę osób tylko do pracowników i zleceniobiorców aktualnej firmy
   'REFERENCE in (select P.OSOBA from P where P.FIRMA=:_a and (P.F_ZATR=:_b or P.F_ZATR=:_c))',
   exec('ref_firma','ustawienia'),_fz_p,_fz_z
);
PPK_KWN.cntx_psh();
PPK_KWN.index('O_MSC_T');
PPK_KWK.cntx_psh();
PPK_KWK.index('RN');
LS.cntx_psh();
O.cntx_psh();
O.index('LISTYUBZ');
_loop:=OSOBA.f_first();
_size:=OSOBA.f_size();
_cnt:=0;
{!
|? _loop
|! _cnt+=1;
   _BUF.blank();
   progress(int(100*_cnt/_size),'Proszę czekać. Trwa pobieranie danych...'@,FUN.TYT);
   O.prefix(exec('ref_firma','ustawienia'),_rok,_msc);
   _loop:=O.first();
   {!
   |? _loop
   |! LS.use(-O.LT);
      _BUF.PW+=_ls(_pw);
      _BUF.PF+=_ls(_pf);
      _BUF.DF+=_ls(_df);
      _BUF.PU+=_ls(_pu);
      _BUF.DU+=_ls(_du);
      _loop:=O.next()
   !};
   {? _BUF.PW<>0 | _BUF.PF<>0 | _BUF.DF<>0 | _BUF.PU<>0 | _BUF.DU<>0
   || _BUF.SW+=(_BUF.PF+_BUF.DF+_BUF.PU+_BUF.DU);
      _BUF.NAZWISKO:=OSOBA.NAZWISKO;
      _BUF.PIERWSZE:=OSOBA.PIERWSZE;
      _BUF.PESEL:=OSOBA.PESEL;
      _BUF.OSOBA:=#OSOBA.ref();
      _BUF.add()
   ?};

:: pobierz kwoty wyrównań/zwrotów dokonanych przez pracodawcę
:: pomiń kwoty z korekt/zwrotów dla/z instytucji finansowej
   PPK_KWN.prefix(exec('ref_firma','ustawienia'),OSOBA.ref(),_rok,_msc,'Z');
   _loop:=PPK_KWN.first();
   {!
   |? _loop
   |! {? PPK_KWN.RODZAJ='P'
::          uwzględniaj tylko zwroty pracodawcy
      || _mul:={? PPK_KWN.TYTUL='-' || -1 || 1 ?};
         _put:=_BUF.find_tab(,'OSOBA',,'=',#PPK_KWN.OSOBA);
         {? ~_put
         || _BUF.blank(1);
            _BUF.NAZWISKO:=OSOBA.NAZWISKO;
            _BUF.PIERWSZE:=OSOBA.PIERWSZE;
            _BUF.PESEL:=OSOBA.PESEL;
            _BUF.OSOBA:=#OSOBA.ref()
         ?};
::          pobierz kwoty zwrotu/wyrównania
         PPK_KWK.prefix(PPK_KWN.ref());
         _loop:=PPK_KWK.first();
         {!
         |? _loop
         |! _rn:=PPK_KWK.R().RN;
            _kw:=PPK_KWK.KW*_mul;
            {? _rn=_pf || _BUF.WPF+=_kw; _BUF.SW+=_kw ?};
            {? _rn=_df || _BUF.WDF+=_kw; _BUF.SW+=_kw ?};
            {? _rn=_pu || _BUF.WPU+=_kw; _BUF.SW+=_kw ?};
            {? _rn=_du || _BUF.WDU+=_kw; _BUF.SW+=_kw ?};
            {? _rn=_zPf || _BUF.ZPF+=_kw; _BUF.SW+=_kw ?};
            {? _rn=_zDf || _BUF.ZDF+=_kw; _BUF.SW+=_kw ?};
            _loop:=PPK_KWK.next()
         !};
         {? _put
         || _BUF.put()
         || _BUF.add()
         ?}
      ?};
      _loop:=PPK_KWN.next()
   !};

   _loop:=OSOBA.f_next()
!};
prgs_clr();
O.cntx_pop();
LS.cntx_pop();
PPK_KWK.cntx_pop();
PPK_KWN.cntx_pop();
OSOBA.f_clear();
OSOBA.cntx_pop();
~~


\import_if
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [19.22]
:: OPIS: Funkcja do importu instytucji finansowych prowadzących i zarządzających PPK z pliku ppk_if.dfg
::   WE: [_a] [STRING] - Lista instytucji finansowych do zaimportowania, jeżeli brak parametru lub parametr pusty
::                      import wszystkich instytucji.
::   WY: Treść komunikatu.
::----------------------------------------------------------------------------------------------------------------------
_key:={? var_pres('_a')=type_of('') || _a+',' || '' ?};
_plik:='ppk_if.dfg';
_info:='';
_sep:=';';
_size:=12;

_handle:=fopen(_plik,'r',1,0);
{? _handle
|| _line:=fread(_handle);
   {? +_line
   || _fields:=spli_str(_line,_sep);
      _lenght:=obj_len(_fields);

:: Zdefiniowanie tabeli tymczasowej do zapisania danych z pliku.
      {? _lenght=_size
      || _tab:='_TAB:=tab_tmp(1';
         {! _ii:=1 .. _lenght
         |! _tab+=',\'%1\',\'STRING[100]\',\'%1\''[_fields[_ii]]
         !};
         _tab+=')';
         _TAB:=($_tab)();

:: Zapisanie danych z pliku do tabeli tymczasowej.
         {!
         |? {? (_line:=fread(_handle))<>'\n'
            || {? var_pres('_fields')>100
               || obj_del(_fields)
               ?};
               _fields:=spli_str(_line,_sep);
               _lenght:=obj_len(_fields);
               {? _lenght=_size
               || {? _key='' | (+_key & _key*_fields[1])
                  || {! _ii:=1 .. _lenght
                     |! _TAB[_ii]:=_fields[_ii]
                     !};
                     _TAB.add()
                  ?};
                  1
               || _info:='Błędna struktura pliku.'@;
                  fclose(_handle);
                  return(_info)
               ?}
            ?}
         !};

:: Zapisanie danych do tabeli ADRES
         {? _TAB.first()
         || SLO_TYP.cntx_psh();
            _slo_typ:=exec('slo_typ','ext_slo','PPK_IF');
            {? _slo_typ
            || ADRES.cntx_psh();
               ADRES.index('ADRES');
               ADRES.prefix(_slo_typ);
               _info:='';
               {!
               |? {? ~ADRES.find_key(_TAB.NAZWA)
                  || ADRES.blank(1);
                     {! _ii:=1 .. obj_len(_TAB)
                     |! _acr:=_TAB.fld_acr(_ii);
                        ($('ADRES.'+_acr+':=_a.'+_acr))(_TAB)
                     !};
                     ADRES.TYP:=_slo_typ;
                     {? ADRES.add(1)
                     || _info+=_TAB.SYMBOL+','
                     ?}
                  ?};
                  _TAB.next()
               !};
               {? +_info
               || _info:='Do słownika instytucji finansowych prowadzących PPK dodano nowe: '@+(_info-1)
               || _info:='Do słownika instytucji finansowych prowadzących PPK nie dodano nowych zapisów.'@
               ?};
               ADRES.cntx_pop()
            || _info:='Brak wskazania na rodzaj zapisu.'@
            ?};
            SLO_TYP.cntx_pop()
         ?}
      || _info:='Błędna struktura pliku.'@
      ?}
   || 'Plik bez zawartości.'@
   ?};
   fclose(_handle)
|| _info:='Brak dostępu do pliku.'@

?};

_info


\zap_prz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Aktualizuje zawartość tabeli PPK_POD (przychód z tytułu wpłat na PPK)
::   WE: _a _P - wskazanie pracownika
::       _b _O/_RH - wskazanie listy płac/rachunku
::       _c INTEGER - numer składnika płacowego
::       _d [REAL] - kwota przychodu z tytułu danej wpłaty, domyślnie 0.00
::       _e [INTEGER] - ignoruj znacznik rejestracji danych, domyślnie 0
::   WY: ~~
::UWAGA: poprawność argumentów wywołania nie jest weryfikowana
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_pref:=_a;
_xref:=_b;
_r_rn:=_c;
_kprz:={? var_pres('_d')=type_of(0) || _d ?};
_wymz:={? var_pres('_e')=type_of(0) || _e<>0 ?};

{? __RUB.sys_attr(_r_rn,726)=0
:: wpłata nie zwiększa przychodu
|| return()
?};

PPK_POD.cntx_psh();
PPK_POD.prefix();
:: utwórz informację nagłówkową, jeśli nie istnieje
_ppod:=exec('zapisz','ppk_pod',_pref,_xref);
{? _ppod=null | ~PPK_POD.seek(_ppod)
:: to nie powinno się przytrafić
|| PPK_POD.cntx_pop();
   return()
?};

{? _wymz=0 & PPK_POD.REJ_TRYB<>'A'
:: honoruj blokadę aktualizacji
|| PPK_POD.cntx_pop();
   return()
?};

:: dodaj/aktualizuj informację o przychodzie
_ret:=exec('zapisz','ppk_pok',_ppod,_r_rn,_kprz);
{? _ret.MOD & PPK_POD.POD_O<>null &
   {? $_xref*RH.name() || PPK_POD.POD_RH || PPK_POD.POD_O ?}<>_xref
:: zmiana przychodu już opodatkowanego na liście/rachunku innych niż bieżące
|| P.cntx_psh();
   OSOBA.cntx_psh();
   PPK_POD.P().OSOBA();
   RAPLS.msg(
      P.T,OSOBA.NAZWISKO,OSOBA.PIERWSZE,
      'Przychód z tytułu wpłat na PPK został już rozliczony.\n'+
      'Należy zweryfikować wyliczenia na liście '+PPK_POD.POD_LT+'.'
   );
   OSOBA.cntx_pop();
   P.cntx_pop()
?};

PPK_POD.prefix();
:: podczytaj bufor po zmianach przy zapisie
{? PPK_POD.seek(_ppod) & PPK_POD.WYL_KW=0
:: brak zwiększenia przychodu
|| PPK_POD.del()
?};

PPK_POD.cntx_pop();
~~


\licz_prz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.51]
:: OPIS: Wyliczenie przychodu z tytułu wpłat na PPK
::   WE: _a [STRING] - określenie wyliczeń dla: 'p' (domyślnie) - pracownika, 'z' - zleceniobiorcy
::   WY: kwota przychodu z tytułu wpłat na PPK
::----------------------------------------------------------------------------------------------------------------------
:: ustal kontekst naliczania (_lz='l' - naliczana lista płac)
_lz:={? var_pres('_a')=type_of('') & -_a='z' || 'z' || 'l' ?};

:: sprawdź czy nie jest naliczana wypłata zasiłku:
{? _lz='z' & RH.ZAS='T'
|| return(0)
?};

_pod_d:=
   {? _lz='l'
   || {? O.D=date(0,0,0)
      || date(O.RP,O.MP,0)
      || O.D
      ?}
   || RH.DWY
   ?};

:: przychód z tytułu wpłat PPK
_prz:=0;

:: zabezpieczenie przed uwzględnieniem przychodu po usunięciu danych z listy
:: aby przychód został wyliczony na liście musi istnieć jakikolwiek składnik
{? FUNKCJE.buff.IsEmpty()<>0
|| return(_prz)
?};

PPK_POD.cntx_psh();
PPK_POD.prefix();

:: ustal kryterium filtrowania
_nval:='';
{? _lz='l'
:: przychody bez wskazanej listy
|| _nval:='PPK_POD.POD_O is null'
|? _lz='z'
:: przychody bez wskazanego rachunku
|| _nval:='PPK_POD.POD_RH is null'
?};

:: pobierz przychody do rozliczenia w roku podatkowym właściwym dla listy/rachunku
:: a nie oznaczone jeszcze jako rozliczone (odpowiednio POD_O lub POD_RH są puste)
PPK_POD.f_set(,,
   'PPK_POD.P=:_a and PPK_POD.POD_R=:_b and PPK_POD.POD_LICZ=\'T\' and '+_nval,
   P.ref(),_pod_d~1
);
:: Parametr 288 "Przychód - wpł. PPK nierozliczony na liście płac w miesiącu wpłaty składek do instytucji finansowej
:: kwalifikować do rozliczenia na PIT 11"
:: Data przelewu PPK_POD musi być mniejsza od daty wypłaty listy i data wypłaty listy musi być z tego samego miesiąca...
_p288:=exec('get_par','#parametr',288);
{? type_of(_p288)<>type_of('') || _p288:='N' ?};

_loop:=PPK_POD.f_first();
{!
|? _loop
|! {? -PPK_POD.POD_LT=-O.LT |
      (PPK_POD.POD_LT='' &
       PPK_POD.PRZ_DATA<=_pod_d &
       (_p288='N' | (PPK_POD.PRZ_DATA~1=_pod_d~1 & PPK_POD.PRZ_DATA~2=_pod_d~2))
      )
::    oznacz przychód jako rozliczany bieżącą listą lub rachunkiem
   || {? _lz='l'
      || PPK_POD.POD_O:=O.ref()

      |? _lz='z'
      || ZC.cntx_psh();
         RH.cntx_psh();
         _rh:=RH.ref();
         _ru:=RH.ZLE().RU;
         {? PPK_POD.WYL_RH().ZLE().RU=_ru
::          rozlicz rachunkiem umowy tego samego rodzaju
         || PPK_POD.POD_RH:=_rh
         ?};
         RH.cntx_pop();
         ZC.cntx_pop()
      ?};
      PPK_POD.put()
   ?};
   _loop:=PPK_POD.f_next()
!};
PPK_POD.f_clear();

:: ustal zakres przeglądania
_ref:=null;
{? _lz='l'
:: przeglądaj wpłaty podlegające opodatkowaniu na bieżącej liście płac
|| PPK_POD.index('POD_O');
   _ref:=O.ref()
|? _lz='z'
:: przeglądaj wpłaty podlegające opodatkowaniu na bieżącym rachunku
|| PPK_POD.index('POD_RH');
   _ref:=RH.ref()
?};

PPK_POD.prefix(_ref,P.ref(),'T');
_loop:=PPK_POD.first();
{!
|? _loop
|! _prz+=PPK_POD.WYL_KW$2;
   _loop:=PPK_POD.next()
!};

:: porządki
PPK_POD.cntx_pop();

:: wyliczony przychów
_prz$2


\jest_a11
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [20.14_11]
:: OPIS: Sprawdza, czy definicja zawiera elementy aktualizacji 20.14_11.
::   WE:
::   WY: 0 - brak aktualizacji, 1 - definicja zaktualizowana
::----------------------------------------------------------------------------------------------------------------------
var_pres('DWT_OKR',KST_PPK)=22


\jest_a05
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [20.42]
:: OPIS: Sprawdza, czy definicja zawiera elementy aktualizacji 20.42_05.
::   WE:
::   WY: 0 - brak aktualizacji, 1 - definicja zaktualizowana
::----------------------------------------------------------------------------------------------------------------------
var_pres('PRZEJ_DO',KST_PPK)=21


\ucz_xfl_ustaw_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.14]
:: OPIS: Obsługa akcji "Rozszerzony filtr" listy uczestników PPK.
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
params_exec('x_grp_ustaw_a','xfilter')


\ucz_xfl_wyczysc_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.14]
:: OPIS: Przed akcją "Wyczyść filtr" listy uczestników PPK.
::   WE:
::   WY: 0/1 - zasadnicza akcja zablokowana/dostępna
::----------------------------------------------------------------------------------------------------------------------
params_exec('x_grp_wyczysc_b','xfilter')


\ucz_xfl_wyczysc_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.14]
:: OPIS: Akcja "Wyczyść filtr" listy uczestników PPK.
::   WE:
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
params_exec('x_grp_wyczysc_a','xfilter')


\chars_swap
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Podmienia znaki na ich odpowiedniki. Definicja znaków, które należy podmieniać oraz ich odpowiedników
::       pobierana jest Parametrów raportów (umowy PPK).
::   WE: _a [STRING] - tekst do zamiany
::   WY: _ret [STRING] - tekst po zmianach
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('')
|| FUN.error('Błąd parametru wejściowego'@);
   return('')
?};
_ret:=_a;
{? ~exec('jest','ppk')
|| FUN.emsg('Brak aplikacji PPK'@);
   return(_ret)
?};

PPK_UZA.cntx_psh();
PPK_UMO.cntx_psh();
exec('czytaj','#stalesys',date(),KST_PPK,'PPK_UMO');
{? KST_PPK.PPK_UMO=null()
|| exec('init','ppk_umo')
?};
{? var_pres('PARRAP',PPK_UZA)=36 & PPK_UZA.seek(KST_PPK.PPK_UMO().PPK_UZA,,1)
|| _TAB:=exec('parrap_b','ppk_uza',1);
   {? _TAB.CHARS='T'
   || _charsJson:=base64('decode',_TAB.memo_txt(,0,'CHR_JSON'));
      {? +_charsJson
      || _chars:=json_parse(_charsJson);
         {? type_of(_chars)=117 & var_pres('in',_chars)=117 & var_pres('out',_chars)=117
         || _ret:=gsub(_ret,_chars.in,_chars.out)
         ?};
         obj_del(_chars)
      ?}
   ?}
?};
PPK_UMO.cntx_pop();
PPK_UZA.cntx_pop();

_ret


\chars_swap_def
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [22.26]
:: OPIS: Domyślny zestaw znaków do podmiany. Wygenerowany na podstawie supp_chr().
::   WE: [_a] [OBJ] - tablica elementów nazwanych zgodna z wyjściową. Parametru można użyć do przywrócenia domyślnej
::                    zawartości istniejącej już tablicy.
::       [_b] [INTEGER] - 0/1 czy wygenerować jedynie pustą strukturę (obiekt), gdzie .in=.out=null [domyślnie 0 - nie]
::   WY: _charsDef [OBJ] - tablica elementów nazwanych:
::             * in  [OBJ/NULL] - tablica ze znakami, które należy zamienić (ogonki itp)
::             * out [OBJ/NULL] - tablica z odpowiadającymi znakami, na które należy zamienić.
::             Jeśli coś poszło nie tak (zapytanie SQL nie zwróciło żadnego rekordu) oba elementy (in oraz out)
::             mogą przyjąć wartość null().
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=117
|| _charsDef:=_a;
   {? var_pres('in',_charsDef)=117
   || obj_del(_charsDef.in)
   ?};
   {? var_pres('out',_charsDef)=117
   || obj_del(_charsDef.out)
   ?}
|| _charsDef:=obj_new('in','out')
?};
_empty:={? var_pres('_b')=type_of(0) || _b || 0 ?};

_charsDef.in:=_charsDef.out:=null();
{? _empty || return(_charsDef) ?};

:: Pobieram tabelę z supp_char gdzie nazwa ma w sobie LATIN *** LETTER i conajmniej 3 znaki po letter (eliminuję
:: tym sposobem "zwykłe" litery typu A, B, C...
_CHR:=sql('select CODE, NAME from :_a '
          'where NAME like \'LATIN _% LETTER___%\' '
          'order by 1',supp_chr());

:: Odejmuję dozwolone znaki znajdujące się w "Rozporządzenie Ministra Sprawiedliwości z dnia 24 czerwca 2021 r.
:: zmieniające rozporządzenie w sprawie szczegółowego sposobu prowadzenia rejestrów wchodzących w skład Krajowego
:: Rejestru Sądowego oraz szczegółowej treści wpisów w tych rejestrach" (Dz.U. 2021 poz. 1174, załącznik
:: „Tablica znaków pisarskich”):
{? _CHR.first()
|| _tzp:=
      'AÁÂÃÄÅĀĂĄBCÇĆĈĊČƇDÐĎĐƉƊEÈÉÊËĒĔĖĘĚFGĜĞĠĢHĤIĨĪĮİÌÍÎÏJĴKĶĸLĹĻĽĿŁMNÑŃŅŇŊOÒÓÔÕÖŌŎŐØPQ'
      'RŔŖŘSŚŜŞŠŠTŢŤŦUÙÚÛÜŨŪŬŮŰŲVWŴXYŸÝŶŸ¥ZŽŹŻŽ0123456789¼½¾²³<=>?@!„#$%&()*+,-.ŒÆßƆƎ|'
      ']^_`{}~€‚ƒ„…†:;¡¢£¤¦‡ˆ‰[‹/\‘’“„•–—˜™š›¿×§¨©ª«¬®¯°±´µ¶·¸¹º»Ħ÷ƁƂƂƋƌƍ';
   {!
   |? _del:=0;
      {? _tzp*(~-(^(_CHR.CODE)))
      || _del:=_CHR.del(,1)
      ?};

      _del | _CHR.next()
   !}
?};

:: Właściwa zamiana na literę "bez ogonka":
{? _CHR.first()
|| _iter:=1;
   _size:=_CHR.size();
   _charsDef.in:=obj_new(_size);
   _charsDef.out:=obj_new(_size);
   {!
   |? _name:=spli_str(_CHR.NAME,' ');
      _charsDef.in[_iter]:=^(_CHR.CODE);
      {? obj_len(_name)>=4
      || _charsDef.out[_iter]:=1+_name[4];
         {? _name[2]='SMALL'
         || _charsDef.out[_iter]:=-_charsDef.out[_iter]
         ?}
::    Mniejsza od czteroczłonowej nazwa znaku (nie powinno mieć miejsca):
      || _charsDef.out[_iter]:=' '
      ?};
      obj_del(_name);
      _iter+=1;

      _CHR.next()
   !};
   obj_del(_CHR)
?};

_charsDef

:Sign Version 2.0 jowisz:1045 2023/10/02 15:32:31 9e94881d15f0209eda2aa1f79ba3fba7edba18f1e56d5ddac922d03d122dc6b74b61ec5938cc86d7d889c4f6d8a4cba59a550ce8044ea17cae067ccf12b04d266bf86a13455cd5e386d19e7f35bc0fa8d470480e51c3497e7f79ac8f85ad4db2785c23739d0f34ebcd08a53a577eed20906a8025c23e738e54f472e8a2b993ac
