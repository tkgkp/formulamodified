:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku:  po_ogr.fml [17.00]
:: Utworzony: 15-10-2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Zbiór różnych funkcji dla planu operacyjnego - grupy operacji
::======================================================================================================================


\zgp_utilization
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wykorzystanie pozycji przewodnika w grupach operacji
::   WE: _a - 0 - wyświetlanie
::            1 - sprawdza, czy jest wykorzystanie
::       _b - ZGP.ref()
::       Nie jest sprawdzana obecność i typy parametrów wejściowych
::   WY: dla _a=0: ~~
::       dla _a=1: 1 - wykorzystany, 0 - brak zapisów
::  OLD: \zgp_utilization/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
GROPP.cntx_psh();

GROPP.index('ZGP');
GROPP.prefix(_b);
{? _a
|| _res:=GROPP.first()
|| _wer:=GROPP.mk_sel('Grupy operacji'@,,,'zgpgropp');
   GROPP.win_fld(_wer,,'GROP','KOD');
   GROPP.win_fld(_wer,,'GROP','DATA',,,,,'Data'@);
   GROPP.win_fld(_wer,,'IL',,,15,,,'Ilość'@);
   GROPP.win_sel(_wer);
   GROPP.select();
   _res:=~~
?};

GROPP.cntx_pop();
_res


\zgp_planned_il
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca ilosc dla ZGPa zaplanowana w grupach operacji
::   WE: _a - ZGP.ref()
::   WY: REAL - ilosc danego zgp'a w planie operacyjnym we wszystkich zaplanowanych grupach
::              ilosc ta uwzglednia to ze dany zgp moze byc w kilku grupach, a te grupy moga byc w
::              kilku czesciach w planie
::  OLD: \zgp_planned_il/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

:: Ilosc ZGPa zaplanowana w grupach operacji
_il_planned:=0;

GROP.cntx_psh();
GROPP.cntx_psh();
PL_OGR.cntx_psh();
PL_OGR.index('GROP');
ZGP.cntx_psh(); ZGP.clear();
{? ZGP.seek(_zgp)
|| GROPP.index('ZGP');
   GROPP.prefix(ZGP.ref());
   {? GROPP.first()
   || {!
      |?
::       Ilosc zgrupowana - ilosc w grupie podana jest na jedno uruchomienie wiec
::       obliczam ilosc dla wszystkich uruchomien
         _il_groped:=GROPP.IL*GROPP.GROP().IL;

::       obliczam ilosc uruchomien w planie
         _il_plogrs:=0;
         PL_OGR.prefix(GROPP.GROP);
         {? PL_OGR.first()
         || {!
            |? _il_plogrs+=PL_OGR.ILOSC;
               PL_OGR.next()
            !}
         ?};

::       obliczam proporcje ilosci uruchomien do ilosci w planie
         _prop:=_il_plogrs/GROPP.GROP().IL;
         {? _prop>1
         || _prop:=1
         |? _prop<0
         || _prop:=0
         ?};

::       dodaje do ilosci zaplanowanej
         _il_planned+=_il_groped*_prop;
         GROPP.next()
      !}
   ?}
?};
GROP.cntx_pop();
ZGP.cntx_pop();
GROPP.cntx_pop();
PL_OGR.cntx_pop();
_il_planned


\zgp_plan_start
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca poczatek planu ZGPa w grupach operacji
::   WE: _a - ZGP.ref
::   WY: REAL - tm_stamp
::  OLD: \zgp_plan_start/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_result:=0;

GROP.cntx_psh();
GROPP.cntx_psh();
PL_OGR.cntx_psh();
PL_OGR.index('GROP');
ZGP.cntx_psh(); ZGP.clear();
{? ZGP.seek(_zgp)
|| GROPP.index('ZGP');
   GROPP.prefix(ZGP.ref());
   {? GROPP.first()
   || {!
      |? PL_OGR.prefix(GROPP.GROP);
         {? PL_OGR.first()
         || {? _result=0 | (PL_OGR.TM_START>0 & PL_OGR.TM_START<_result)
            || _result:=PL_OGR.TM_START
            ?}
         ?};
         GROPP.next()
      !}
   ?}
?};
GROP.cntx_pop();
ZGP.cntx_pop();
GROPP.cntx_pop();
PL_OGR.cntx_pop();
_result


\zgp_plan_end
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca koniec planu ZGPa w grupach operacji
::   WE: _a - ZGP.ref
::   WY: REAL - tm_stamp
::  OLD: \zgp_plan_end/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_result:=0;

GROP.cntx_psh();
GROPP.cntx_psh();
PL_OGR.cntx_psh();
PL_OGR.index('GROP2');
ZGP.cntx_psh(); ZGP.clear();
{? ZGP.seek(_zgp)
|| GROPP.index('ZGP');
   GROPP.prefix(ZGP.ref());
   {? GROPP.first()
   || {!
      |? PL_OGR.prefix(GROPP.GROP);
         {? PL_OGR.last()
         || {? _result=0 | (PL_OGR.TM_END>0 & PL_OGR.TM_END>_result)
            || _result:=PL_OGR.TM_END
            ?}
         ?};
         GROPP.next()
      !}
   ?}
?};
GROP.cntx_pop();
ZGP.cntx_pop();
GROPP.cntx_pop();
PL_OGR.cntx_pop();
_result


\has_grop_zl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy zlecenie ma operacje grupowalna
::   WE: _a - ZL.ref()
::   WY: 0 - brak operacji grupowalnej
::       1 - sa operacje grupowalne
::  OLD: \has_grop_zl/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=0;
_can_continue:=1;

ZL.cntx_psh(); ZL.clear();
ZGH.cntx_psh(); ZGH.clear();
ZGP.cntx_psh(); ZGP.clear();

ZGP.index('PNRPP');
ZGH.index('ZLNR');

{? ZL.seek(_zl)
||
:: Jesli zlecenie zlozone to rekurencyjnie sprawdzam zlecenia
   {? ZL.RODZAJ<>'P'
   || ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? _result:=exec('has_grop_zl','po_ogr',ZL.ref());
            ZL.next() & _result=0
         !}
      ?}
   || ZGH.prefix(_zl);
      {? ZGH.first()
      || {!
         |? ZGP.prefix(ZGH.ref());
            {? ZGP.first()
            || {!
               |? {? ZGP.PL_GRP='T'
                  || _result:=1;
                     _can_continue:=0
                  ?};
                  ZGP.next() & _can_continue>0
               !}
            ?};
            ZGH.next() & _can_continue>0
         !}
      ?}
   ?}
?};
ZL.cntx_pop();
ZGP.cntx_pop();
ZGH.cntx_pop();
_result


\can_plan
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy mozna zaplanowac zlecenie - tzn czy wszystkie grupy operacji do ktorych nalezy zlecenie
::       sa zaplanowane na pelne ilosci
::   WE: _a - ZL.ref()
::   WY: 0 - nie mozna zaplanowac zlecenia - grupy nie sa w pelni zaplanowane
::       1 - mozna zaplanowac zlecenie
::  OLD: \can_plan/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=1;

_can_continue:=1;

ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
||
:: Jesli zlecenie zlozone to rekurencyjnie sprawdzam
   {? ZL.RODZAJ<>'P'
   ||
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? _result:=exec('can_plan','po_ogr',ZL.ref());
            ZL.next() & _result=1
         !}
      ?}
   ||
      GROP.cntx_psh();
      GROPP.cntx_psh();
      GROPP.index('ZL');
      GROPP.prefix(ZL.ref());
      {? GROPP.first()
      || _result:=1;
         {!
         |? GROPP.GROP();
            _il:=GROP.IL;
            _il_planned:=exec('grop_plan_il','po_ogr',GROPP.GROP);

            {? _il_planned<_il
            || _result:=0;
               _what1:=exec('GROP','#to_string');
               _what2:=exec('ZL','#to_string');
               _left:=_il-_il_planned;
               _left:=exec('max','#math',_left,0);
               _msg:='Grupa operacji: %1 w której znajduje się zlecenie: %2 nie została w całości zaplanowana. Pozostało do zaplanowania: %3'@[_what1,_what2,$_left];
               KOMM.add(_msg,2,,1)
            ?};
            GROPP.next() & _can_continue>0
         !}
      ?};
      GROPP.cntx_pop();
      GROP.cntx_pop()
   ?}
?};
ZL.cntx_pop();
_result


\can_plan2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy mozna zaplanowac zlecenie - tzn czy wszystkie pozycje przewodnikow
::       ktore sa grupowalne znajduja sie w grupach w pelnych ilosciach
::   WE: _a - ZL.ref()
::   WY: 0 - nie mozna zaplanowac zlecenia - przewodniki nie sa w calosci zgrupowane
::       1 - mozna zaplanowac zlecenie
::  OLD: \can_plan2/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=1;

_can_continue:=1;

ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
||
:: Jesli zlecenie zlozone to rekurencyjnie sprawdzam
   {? ZL.RODZAJ<>'P'
   ||
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? _result:=exec('can_plan2','po_ogr',ZL.ref());
            ZL.next() & _result=1
         !}
      ?}
   ||
      GROPP.cntx_psh(); GROP.cntx_psh();
      GROPP.index('ZGP');
      ZGP.cntx_psh();
      ZGP.index('PNRPP');
      ZGH.cntx_psh();
      ZGH.index('ZLNR');
      ZGH.prefix(ZL.ref());
      {? ZGH.first()
      || {!
         |?
            ZGP.prefix(ZGH.ref());
            {? ZGP.first()
            || {!
               |?
                  {? ZGP.PL_GRP='T'
                  ||
                     _il_gropped:=0;
                     GROPP.prefix(ZGP.ref());
                     {? GROPP.first()
                     || {!
                        |? _il_gropped+=GROPP.IL*GROPP.GROP().IL;
                           GROPP.next()
                        !}
                     ?};

                     {? _il_gropped<ZGP.ILOSC
                     || _result:=0;
                        _what1:=exec('ZGP','#to_string',1);
                        _what2:=exec('ZL','#to_string');
                        _left:=ZGP.ILOSC-_il_gropped;
                        _left:=exec('max','#math',_left,0);
                        _msg:='Pozycja przewodnika: %1 zlecenia: %2 nie została w całości umieszczona w grupach operacji. Pozostało do zgrupowania: %3'@[_what1,_what2,$_left];
                        KOMM.add(_msg,2,,1)
                     ?}
                  ?};
                  ZGP.next() & _can_continue>0
               !}
            ?};
            ZGH.next() & _can_continue>0
         !}
      ?};
      ZGH.cntx_pop();
      ZGP.cntx_pop();
      GROPP.cntx_pop(); GROP.cntx_pop();
      ~~
   ?}
?};
ZL.cntx_pop();
_result


\grop_plan_il
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca ilosc zaplanowana dla danej grupy
::   WE: _a - GROP.ref()
::   WY: REAL - zaplanowana ilosc
::  OLD: \grop_plan_il/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;

_result:=0;

GROP.cntx_psh(); GROP.clear();
PL_OGR.cntx_psh();

{? GROP.seek(_grop)
|| PL_OGR.index('GROP');
   PL_OGR.prefix(GROP.ref());
   {? PL_OGR.first()
   || {!
      |? _result+=PL_OGR.ILOSC;
         PL_OGR.next()
      !}
   ?}
?};
PL_OGR.cntx_pop();
GROP.cntx_pop();
_result


\update_grop_ilp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Uaktualnia ilosc zaplanowana na grupie operacji (GROP) na podstawie rekorow w planie (PL_OGR)
::   WE: _a - GROP.ref()
::   WY: 0 - porazka
::       1 - sukces
::  OLD: \update_grop_ilp/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;

_result:=0;

GROP.cntx_psh(); GROP.clear();
PL_OGR.cntx_psh();
{? GROP.seek(_grop)
|| GROP.PLAN_PO:='N';
   PL_OGR.index('GROP');
   PL_OGR.prefix(GROP.ref());
   _ilp:=0;
   {? PL_OGR.first()
   || {!
      |? _ilp+=PL_OGR.ILOSC;
         PL_OGR.next()
      !}
   ?};
   GROP.ILP:=_ilp;
   {? _ilp>0
   || GROP.PLAN_PO:='T'
   ?};
   _result:=GROP.put()
?};
PL_OGR.cntx_pop();
GROP.cntx_pop();
_result


\delete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Usuwa PL_OGRa
::   WE: _a - PL_OGR.ref()
::   WY: 0 - porazka
::       1 - sukces
::  OLD: \delete/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_pl_ogr:=_a;

_result:=0;
_can_del:=exec('can_delete','po_ogr',_pl_ogr);
{? _can_del=''
|| _clear:=exec('clear','po_ogr',_pl_ogr);
   {? _clear>0
   || PL_OGR.cntx_psh();
      PL_OGR.clear();
      {? PL_OGR.seek(_pl_ogr)
      || _grop:=PL_OGR.GROP;
         _result:=PL_OGR.del(,1);

::       Uaktualniam ilosci zaplanowane na GROP
         {? _result>0 & _grop<>null()
         || exec('update_grop_ilp','po_ogr',_grop)
         ?}
      ?};
      PL_OGR.cntx_pop()
   ?}
|| KOMM.add(_can_del,'xwin16.png:2',,1)
?};
_result


\can_delete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy mozna usunac PL_OGRa
::   WE: _a - PL_OGR.ref()
::   WY: '' lub STRING z przyczyna przez ktora nie mozna usunac
::  OLD: \can_delete/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_pl_ogr:=_a;

_result:='';
_can_continue:=1;

PL_OGR.cntx_psh();
PL_OGR.clear();
{? PL_OGR.seek(_pl_ogr)
||
:: 1. Sprawdzam czy sa wykonania w planie operacyjnym
   {? exec('has_wyk_plogr','po_wyk',PL_OGR.ref())>0
   || _result:='Pozycja planu grupy: %1 posiada zarejestrowane wykonania (plan operacyjny).'@[PL_OGR.SYMBOL]
   ?};
   {? _result=''
   ||
::    2. Sprawdzam czy sa wykonania w planie stragtegicznym
      PX_POZ.cntx_psh();
      PX_POZ.index('PL_OGR2');
      PX_POZ.prefix(PL_OGR.ref());
      {? PX_POZ.first()
      || {!
         |?
            {? exec('has_wyki','px_poz',PX_POZ.ref())>0
            || _can_continue:=0;
               _result:='Pozycja planu grupy: %1 posiada zarejestrowane wykonania (plan strategiczny).'@[PL_OGR.SYMBOL]
            ?};
            PX_POZ.next() & _can_continue>0
         !}
      ?};
      PX_POZ.cntx_pop();
      ~~
   ?};
   {? _result=''
   ||
::    3. Sprawdzam czy zostaly zaplanowane powiazane zlecenia
      GROPP.cntx_psh();
      GROPP.index('GROP');
      GROPP.prefix(PL_OGR.GROP);
      {? GROPP.first()
      || {!
         |?
            ZL.cntx_psh();
::          Podczytanie zlecenia
            GROPP.ZL();

::          Sprawdzam czy zlecenie jest w planie
            {? exec('zlec_planned','po_plan',$ZL.ref())>0
            || _can_continue:=0
            ?};

            {? _can_continue>0
            ||
               {? ZL.NRNZL>0
               ||
::                Jezeli zlecenie ma nadrzedne, to sprawdzam czy nadrzedne na samej gorze zostalo zaplanowane
                  _top:=exec('top_level','zl_link',ZL.ref());
                  {? exec('zlec_planned','po_plan',$_top)>0
                  || _can_continue:=0
                  ?}
               ?}
            ?};
            {? _can_continue<=0
            || _result:='W oparciu o plan grupy: %1 zostały zaplanowane zlecenia.'@[PL_OGR.SYMBOL]
            ?};
            ZL.cntx_pop();
            GROPP.next() & _can_continue>0
         !}
      ?};
      GROPP.cntx_pop()
   ?};
   ~~
?};
PL_OGR.cntx_pop();
_result


\clear
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Czysci powiazania przed usunieciem PL_OGRa
::   WE: _a - PL_OGR.ref()
::   WY: 0 - porazka
::       1 - sukces
::  OLD: \clear/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_pl_ogr:=_a;

_result:=0;
_can_continue:=1;

PL_OGR.cntx_psh();
PL_OGR.clear();
{? PL_OGR.seek(_pl_ogr)
||
:: 1. Usuwam PX_POZy w planie strategicznym
   exec('plogr_clear','px_poz',PL_OGR.ref());

:: 2. Usuwam PL_NEXTy
   PL_NEXT.cntx_psh();
   PL_NEXT.index('PL_OGR');
   PL_NEXT.prefix(PL_OGR.ref());
   {? PL_NEXT.first()
   || {!
      |? _can_continue:=exec('del_plnext','po_plan',$PL_NEXT.ref());
         PL_NEXT.first() & _can_continue>0
      !}
   ?};
   PL_NEXT.index('NEXT_OGR');
   PL_NEXT.prefix(PL_OGR.ref());
   {? PL_NEXT.first()
   || {!
      |? _can_continue:=exec('del_plnext','po_plan',$PL_NEXT.ref());
         PL_NEXT.first() & _can_continue>0
      !}
   ?};
   PL_NEXT.cntx_pop();

:: 3. Usuwam wykonania PL_WYK
   PL_WYK.cntx_psh();
   PL_WYK.index('PL_OGR');
   PL_WYK.prefix(PL_OGR.ref());
   {? PL_WYK.first()
   || {!
      |? _can_continue:=PL_WYK.del(,1);
         PL_WYK.first() & _can_continue>0
      !}
   ?};
   PL_WYK.cntx_pop()
?};
PL_OGR.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\grop_tm_start
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca tm_stamp poczatku planu danej grupy
::   WE: _a - GROP.ref()
::   WY: REAL - tm_stamp
::  OLD: \grop_tm_start/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;

_result:=0;

GROP.cntx_psh();GROP.clear();
PL_OGR.cntx_psh();
{? GROP.seek(_grop)
|| PL_OGR.index('GROP');
   PL_OGR.prefix(GROP.ref());
   {? PL_OGR.first()
   || _result:=PL_OGR.TM_START
   ?}
?};
PL_OGR.cntx_pop();
GROP.cntx_pop();
_result


\grop_tm_end
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca tm_stamp poczatku planu danej grupy
::   WE: _a - GROP.ref()
::   WY: REAL - tm_stamp
::  OLD: \grop_tm_end/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;

_result:=0;

GROP.cntx_psh();GROP.clear();
PL_OGR.cntx_psh();
{? GROP.seek(_grop)
|| PL_OGR.index('GROP2');
   PL_OGR.prefix(GROP.ref());
   {? PL_OGR.last()
   || _result:=PL_OGR.TM_END
   ?}
?};
PL_OGR.cntx_pop();
GROP.cntx_pop();
_result


\get_min_start
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca minimalny start dla grupy operacji uwzgledniajac kooperacje
::   WE: _a - GROP.ref
::   WY: REAL - tm_stamp
::  OLD: \get_min_start/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;

_result:=0;

GROP.cntx_psh();
GROPP.cntx_psh();
ZGP.cntx_psh();
NASZGP.cntx_psh();

NASZGP.index('NASTOP');

GROP.clear();
{? GROP.seek(_grop)
|| GROPP.index('GROP');
   GROPP.prefix(GROP.ref());
   {? GROPP.first()
   || {!
      |? {? GROPP.ZGP<>null()
         ||
::          Zwracam minimalny start dla pozycji przewodnika
            _zgp_min:=exec('zgp_min_start','po_plan',GROPP.ZGP);
            {? _result=0 | (_zgp_min>0 & _zgp_min>_result)
            ||
::             Biore maksimum z: _result i _zgp_min
               _result:=_zgp_min
            ?}
         ?};
         GROPP.next()
      !}
   ?}
?};

NASZGP.cntx_pop();
ZGP.cntx_pop();
GROPP.cntx_pop();
GROP.cntx_pop();
_result


\get_max_end
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca maksymalny koniec dla grupy operacji uwzgledniajac kooperacje
::   WE: _a - GROP.ref
::   WY: REAL - tm_stamp
::  OLD: \get_max_end/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;

_result:=0;

GROP.cntx_psh();
GROPP.cntx_psh();
ZGP.cntx_psh();
NASZGP.cntx_psh();

NASZGP.index('OPNAST');

GROP.clear();
{? GROP.seek(_grop)
|| GROPP.index('GROP');
   GROPP.prefix(GROP.ref());
   {? GROPP.first()
   || {!
      |? {? GROPP.ZGP<>null()
         ||
::          Zwracam maksymalny koniec dla pozycji przewodnika
            _zgp_max:=exec('zgp_max_end','po_plan',GROPP.ZGP);
            {? _result=0 | (_zgp_max>0 & _zgp_max<_result)
            ||
::             Biore minimum z: _result i _zgp_max
               _result:=_zgp_max
            ?}
         ?};
         GROPP.next()
      !}
   ?}
?};

NASZGP.cntx_pop();
ZGP.cntx_pop();
GROPP.cntx_pop();
GROP.cntx_pop();
_result


\plogr2rs
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Wypelnia RSa wartosciami na podstawie biezacego rekordu tabeli PL_OGR
::   WE: _a - ResultSet - tablica zwracana do javy reprezentujaca PL_OGR
::  OLD: \plogr2rs/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_rs:=_a;

_rs.REF:=$PL_OGR.ref();
_rs.PLOPER:='';
_rs.PLRES:=$PL_OGR.PL_RES;
_rs.PLRESSYM:=PL_OGR.PL_RES().SYM;
_rs.PLRESNAZ:=PL_OGR.PL_RES().NAZ;
_rs.GROP:=$PL_OGR.GROP;
_rs.DURATION:=PL_OGR.DURATION;
_rs.ILOSC:=PL_OGR.ILOSC;
_rs.PL_START:=exec('to_string','#tm_stamp',PL_OGR.TM_START);
_rs.PL_END:=exec('to_string','#tm_stamp',PL_OGR.TM_END);
_rs.SYMBOL:=PL_OGR.SYMBOL;
_rs.OPIS:=PL_OGR.OPIS;
_rs.KOLOR:=PL_OGR.KOLOR;
_rs.GROP_IL:=PL_OGR.GROP().IL;
_rs.PREVS:=exec('count_prevs_ogr','po_plan',PL_OGR.ref());
_rs.NEXTS:=exec('count_nexts_ogr','po_plan',PL_OGR.ref());
_rs.TM_MIN:=exec('to_string','#tm_stamp',PL_OGR.TM_MIN);
_rs.TM_MAX:=exec('to_string','#tm_stamp',PL_OGR.TM_MAX);
_rs.SYM_MIN:=PL_OGR.SYM_MIN;
_rs.SYM_MAX:=PL_OGR.SYM_MAX;
_rs.KOLOR_T:=GROP.TTOPER().KOLOR;
_rs.KOLOR_M:='';
_rs.KOLOR_G:='';
~~


\grop_first4zgp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca najwczesniej zaplanowanego GROPa ktory zawiera danego ZGP
::   WE: _a - ZGP.ref()
::   WY: GROP.ref() - najwczesniej zaplanowany GROP
::       null() - jesli ZGP nie znajduje sie w zadnej grupie, lub jest ona niezaplanowana
::  OLD: \grop_first4zgp/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_tm_start:=0;
_result:=null();

PL_OGR.cntx_psh();
PL_OGR.index('GROP');
GROP.cntx_psh();
GROPP.cntx_psh();
GROPP.index('ZGP');
ZGP.cntx_psh(); ZGP.clear();
{? ZGP.seek(_zgp)
|| GROPP.prefix(ZGP.ref());
   {? GROPP.first()
   || {!
      |? PL_OGR.prefix(GROPP.GROP);
         {? PL_OGR.first()
         || {? _tm_start=0 | _tm_start>PL_OGR.TM_START
            || _tm_start:=PL_OGR.TM_START;
               _result:=GROPP.GROP
            ?}
         ?};
         GROPP.next()
      !}
   ?};
:: jesli nie ma plogrow to zwracam pierwszego lepszego gropa - po to by wyswietlic komunikat w javie
   {? _result=null()
   ||
      GROPP.prefix(ZGP.ref());
      {? GROPP.first()
      || _result:=GROPP.GROP
      ?}
   ?}
?};
ZGP.cntx_pop();
GROPP.cntx_pop();
GROP.cntx_pop();
PL_OGR.cntx_pop();
_result


\grop_last4zgp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca najwczesniej zaplanowanego GROPa ktory zawiera danego ZGP
::   WE: _a - ZGP.ref()
::   WY: GROP.ref() - najwczesniej zaplanowany GROP
::       null() - jesli ZGP nie znajduje sie w zadnej grupie, lub jest ona niezaplanowana
::  OLD: \grop_last4zgp/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_tm_end:=0;
_result:=null;

PL_OGR.cntx_psh();
PL_OGR.index('GROP2');
GROP.cntx_psh();
GROPP.cntx_psh();
GROPP.index('ZGP');
ZGP.cntx_psh(); ZGP.clear();
{? ZGP.seek(_zgp)
|| GROPP.prefix(ZGP.ref());
   {? GROPP.first()
   || {!
      |? PL_OGR.prefix(GROPP.GROP);
         {? PL_OGR.last()
         || {? _tm_end=0 | _tm_end<PL_OGR.TM_END
            || _tm_end:=PL_OGR.TM_END;
               _result:=GROPP.GROP
            ?}
         ?};
         GROPP.next()
      !}
   ?};
   {? _result=null()
   ||
      GROPP.prefix(ZGP.ref());
      {? GROPP.first()
      || _result:=GROPP.GROP
      ?}
   ?}
?};
ZGP.cntx_pop();
GROPP.cntx_pop();
GROP.cntx_pop();
PL_OGR.cntx_pop();
_result


\zgp_planned
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy ZGP jest zaplanowany w planie operacyjnym
::   WE: _a - ZGP.ref()
::   WY: REAL - ilosc na PL_OGRach dla ZGP
::  OLD: \zgp_planned/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;

_result:=0;

ZGP.cntx_psh(); ZGP.clear();
ZGH.cntx_psh();
{? ZGP.seek(_zgp)
||
   GROP.cntx_psh();
   GROPP.cntx_psh();
   GROPP.index('ZGP');
   GROPP.prefix(ZGP.ref());
   {? GROPP.first()
   ||
      {!
      |? GROPP.GROP();
         {? GROP.AKC='T'
         ||
            _il:=GROP.IL;
            _il_planned:=exec('grop_plan_il','po_ogr',GROPP.GROP);
            _result+=_il_planned
         ?};
         GROPP.next()
      !}
   ?};
   GROPP.cntx_pop();
   GROP.cntx_pop()
?};
ZGH.cntx_pop();
ZGP.cntx_pop();
_result


\grops_planned
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.20]
:: OPIS: Sprawdza, czy zasob do grupy operacji ujety jest w planie
::       Kontekst wywolania - rekord tabeli GROPS
::   WY: 0/1
::  OLD: \grops_planned/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
PL_OGR.cntx_psh();
PL_OGR.index('PL_RES');
PL_OGR.prefix(GROPS.GROP,GROPS.PL_RES);
_res:=PL_OGR.size()>0;
PL_OGR.cntx_pop();
_res


\grop_utl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Pokazuje obciążenie w planie dla grupy obiektów
::  OLD: \grop_utl/pl_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_wer:=PL_OGR.mk_sel('Wykorzystanie zasobów w planie operacyjnym'@,,,'plogrwer',20,20,10,,'U');
PL_OGR.win_fld(_wer,,'PL_RES','SYM',,20,,,'Zasób'@);
PL_OGR.win_fld(_wer,,'OPIS',,,40,,,'Opis'@);
PL_OGR.win_fld(_wer,,'ILOSC',,,15,4,,'Ilość'@);
PL_OGR.win_fld(_wer,,'STARTD');
PL_OGR.win_fld(_wer,,'STARTT');
PL_OGR.win_fld(_wer,,'ENDD');
PL_OGR.win_fld(_wer,,'ENDT');
PL_OGR.win_sel(_wer);

PL_OGR.index('GROP');
PL_OGR.prefix(GROP.ref());

PL_OGR.select();
~~


\grop_icon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Symbol ikony w oknie wertowania GROP, pole GROP.KOD - informacja czy grupa jest w planie
::  OLD: \grop_icon/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? GROP.ILP<>0
|| exec('pl_plan','icon')
|? GROP.PLAN_PX='T'
|| exec('px_plan','icon')
|? GROP.PLAN_PX='Q'
|| exec('px_queue','icon')
|| exec('pusta','#icon')
?}


\trig_add_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger tabeli PL_OGR (przed add)
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_OGR='T'
|| return(1)
?};
PL_OGR.TM_START:=tm_stamp( PL_OGR.STARTD~1,
                           PL_OGR.STARTD~2,
                           PL_OGR.STARTD~3,
                           PL_OGR.STARTT~1,
                           PL_OGR.STARTT~2,
                           PL_OGR.STARTT~3,
                           0);

PL_OGR.TM_END:=tm_stamp(   PL_OGR.ENDD~1,
                           PL_OGR.ENDD~2,
                           PL_OGR.ENDD~3,
                           PL_OGR.ENDT~1,
                           PL_OGR.ENDT~2,
                           PL_OGR.ENDT~3,
                           0);

1


\trig_add_after
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger tabeli PL_OGR (po add)
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_OGR='T'
|| return()
?};
exec('pl_ogr_trig_a','po_ogr','add');
~~


\trig_put_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger tabeli PL_OGR (przed put)
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_OGR='T'
|| return(1)
?};
PL_OGR.TM_START:=tm_stamp( PL_OGR.STARTD~1,
                           PL_OGR.STARTD~2,
                           PL_OGR.STARTD~3,
                           PL_OGR.STARTT~1,
                           PL_OGR.STARTT~2,
                           PL_OGR.STARTT~3,
                           0);

PL_OGR.TM_END:=tm_stamp(   PL_OGR.ENDD~1,
                           PL_OGR.ENDD~2,
                           PL_OGR.ENDD~3,
                           PL_OGR.ENDT~1,
                           PL_OGR.ENDT~2,
                           PL_OGR.ENDT~3,
                           0);

1


\trig_put_after
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger tabeli PL_OGR (przed add)
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_OGR='T'
|| return()
?};
exec('pl_ogr_trig_a','po_ogr','put');
~~


\trig_del_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger tabeli PL_OGR (przed del)
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_OGR='T'
|| return(1)
?};
1


\trig_del_after
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger tabeli PL_OGR (po del)
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? TRIG_OFF.PL_OGR='T'
|| return()
?};
{? _a || exec('pl_ogr_trig_a','po_ogr','del') || ~~ ?}


\pl_ogr_trig_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Aktualizacja tabeli GROP na podstawie zmian w tabeli PL_OGR (przeniesienie wykonan) - trigger po
::   WE: _a - rodzaj triggera: 'add', 'put', 'del'
::  OLD: \pl_ogr_trig_a/gr_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a='add' | _a='put' || _grop:=PL_OGR.GROP
|? _a='del'            || _grop:=bfld('GROP')
                       || return()
?};

Cntx.psh(PL_OGR,GROP);
Cntx.clr(GROP);

{? GROP.seek(_grop)
||
   _il_wyk:=0;
   _il_potw:=0;
   PL_OGR.index('GROP');
   PL_OGR.prefix(_grop);
   {? PL_OGR.first()
   || {!
      |? _il_wyk+=PL_OGR.IL_WYK;
         _il_potw+=PL_OGR.IL_POTW;
         PL_OGR.next()
      !}
   ?};

   GROP.ILW:=_il_wyk;
   GROP.CZY_WYK:={? GROP.ILW>=GROP.IL || 'T' || 'N' ?};
   GROP.ILPOTW:=_il_potw;
   GROP.CZY_POTW:={? GROP.ILPOTW>=GROP.IL || 'T' || 'N' ?};
   GROP.put()
?};

Cntx.pop(PL_OGR,GROP);
~~

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:35 0142238644df3bc5f593fb7b95370cf1f8f2b8cd0f4f05bd1b514dca9626f3a7380749c16e1a835ae7eca0967ca107e292fe6aba83458f2d592936856586fccc5b00d1fe1a23008c6a1074ee3fc8491229abab0288600093f517ffe6595cc996665ae6eed31d90196c7f34e8478f14918e5848ad6f9b12d960afac1d61bee9a5
