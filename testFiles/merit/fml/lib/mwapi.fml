:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: mwapi.fml
:: Utworzony: 18.10.2018
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły ogólne do obsługi MacroWebAPI
::======================================================================================================================


\serialize_res
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Formuła pomocnicza do otrzymania błędów w postaci xmla
::   WE: _a - obiekt MWA
::       _b - JSON z błędami
::       [_c] - typ komunikatu - (domyślnie: 'ERROR' = 0), _c>=1 = 'OK'
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_c')=type_of(0) || _typ:=_c || _typ:=0 ?};

_resp:=fopen(null(),'Uw',,1,1);

_result:="
   json_tparse(params_get().json).json_tconvert(params_get().resp,,,,'result','p',,'noheader=1,nodata=1,indentation=1');
   ''
";
params_set('json',_b,'resp',_resp);
_tab:=tab_tmp(,'STATUS','STRING[20]','');
_tab.STATUS:={? _typ=0 || 'ERROR' || 'OK' ?};
_tab.add();
_tab.xml_records(_resp,_a.METHOD+'Response',,'p',_a.OUTNSPC,'norecord=1'
   ,'STATUS:status',
   ,'',_result
);

_resp


\set_fields
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [PS] [17.14]
:: OPIS: Formuła pomocnicza wypełniająca pola w rekordzie w oparciu o string przekazywany przez web service.
::       Oczekiwany format to: TAB`sep`pole1`sep`wartość1`sep`pole2`sep`wartość2 (...)
::
::   WE: _a - STRING - String z nazwą tabeli i jej polami
::   WY: INTEGER - liczba pól o nierozpoznanym typie.
::  OLD: \set_fields/#webservice.fml
::----------------------------------------------------------------------------------------------------------------------
_wsenv:=exec('wsenv','#mwapi');

_arr:=spli_str(_a,'`sep`');
_tab:=_arr[1];

_unknown:=0;
{! _it:=2..obj_len(_arr)
|!
:: Indeksy parzyste to pola, z których należy odczytać typ
   {? ~(_it %* 2)
   || _type:=($('var_pres(\''+~-_arr[_it]+'\','+_tab+')'))();
      _field:=~-_arr[_it]
:: Indeksy nieparzyste (z wyłączeniem 1 - tabeli) to wartości, które należy przypisać
   || _value:=_arr[_it];
::    Wartości puste są reprezentowane jako `null`
      _value:=gsub(_value,'`null`','');

::    INTEGER i REAL
      {? _type=20 | _type=22
      || {? +_value & exec('allDigit','#valid',_value)
         || ($(_tab+'.'+_field+':=#\''+_value+'\''))()
         || _wsenv.add_error(
               'Nieprawidłowy format wartości (%1) przypisywanej do pola numerycznego %2.'@
               [_value,_field]
            )
         ?}
::    STRING
      |? _type=27
      || ($(_tab+'.'+_field+':=\''+_value+'\''))()
::    DATE
      |? _type=21
      || ($(_tab+'.'+_field+':=exec(\'str2date\',\'#convert\',_a)'))(_value)
::    REFERENCE
      |? _type=26
      || {? (_id:=exec('acr_no','#table',($(_tab))(),_field))>0
::       Szukam nazwy tabeli złączeniowej
         || _jointable:=($(_tab+'.fld_join(_a)'))(_id);
::          Szukam rekordu, jeżeli zostanie znaleziony, to przypisuję refa
            ($(_jointable+'.cntx_psh()'))();
            ($(_jointable+'.prefix()'))();
            _mask:=($(_jointable+'.name(1)'))(_value);
            _mask:=gsub(_mask,'?','');
            {? ~(+_value=16 & BB.sqlint(_value)>0 & ((+_mask)+_value)=_mask) & _value<>''
            || _wsenv.add_error(
               'Nieprawidłowy format wartości (%1) przypisywanej do pola złączeniowego %2.'@
               [_value,_field]
               )
            |? ($(_jointable+'.seek(_a)'))(_value) | _value=''
            || ($(_tab+'.'+_field+':='+_jointable+'.ref()'))()
            || _wsenv.add_error(
               'Nie znaleziono wartości (%1) przeznaczonej dla pola %2.'@
               [_value,_field]
               )
            ?};
            ($(_jointable+'.cntx_pop()'))()
         ?}
::    TIME
      |? _type=29
      || ($(_tab+'.'+_field+':=exec(\'str2time\',\'#convert\',_a)'))(_value)
::    MEMO i SYS_MEMO
      |? _type=25 | _type=36
      || ($(_tab+'.memo_set(\''+_value+'\',\''+_field+'\')'))()
      ?}
   ?}
!};
_unknown


\set_field
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Ustala wartość pola tablicy buforowej
::   WE: _a - tabela ze sparsowanym XML (aktualny rekord zawiera akronim i wartość pola)
::       _b - alias tabeli (pozwala odczytać docelowy typ pola)
::       _c - tablica buforowa (do zapisu wartości)
::----------------------------------------------------------------------------------------------------------------------
_acr:=_a.NAME;
_val:=_a.VAL;
_tab:=_b;
_buffer:=_c;
_type:=var_pres(_acr,_tab);
:: STRING, MEMO, SYSMEMO
{? _type=25
|| ($('_a.%1:=_b'[_acr]))(_buffer,_val)
:: MEMO, SYSMEMO
|? _type=27 | _type=36
|| {? var_pres('VTRUNC',_a) & _a.VTRUNC='T'
   ||
      _blob:= fopen(_a.BVAL, 'ur');
      {? _blob
      ||
         {!|? (_wiersz:= fread(_blob)) <> '\n' |!
         ($('_a.%1+=_b'[_acr]))(_buffer,_wiersz)
         !};
         fclose(_blob)
      ?}
   ||
      ($('_a.%1:=_b'[_acr]))(_buffer,_val)
   ?}
:: INTEGER, REAL
|? _type=20 | _type=22
|| ($('_a.%1:=#_b'[_acr]))(_buffer,_val)
:: DATE
|? _type=21
|| ($('_a.%1:=exec(''str2date'',''#convert'',_b)'[_acr]))(_buffer,_val)
:: TIME
|? _type=29
|| ($('_a.%1:=exec(''str2time'',''#convert'',_b)'[_acr]))(_buffer,_val)
:: REFERENCE
|? _type=26
|| _id:=exec('acr_no','#table',_tab,_acr);
   {? _id>0
   || _jointable_acr:=_tab.fld_join(_id);
      _jointable:=($_jointable_acr)();
      _jointable.cntx_psh();
      _jointable.prefix();
      {? _jointable.seek(_val)
      || ($('_a.%1:=_b'[_acr]))(_buffer,_jointable.ref())
      ?};
      _jointable.cntx_pop()
   ?}
:: nie ma namierzonego typu pola - uznajemy, że jest to STRING, o ile znajduje się w tablicy buforowej (dodane pole)
|| {? var_pres(_acr,_buffer)>=0
   || ($('_a.%1:=_b'[_acr]))(_buffer,_val)
   ?}
?};
~~


\get_option
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Pobranie opcji wywołania
::   WE: _a - parametr
::       _b - element do wyciągnięcia
::       [_c] - czy zwracać wartość pustą (~~) jak nie ma podanego elementu (_b) w danych: [0] - nie, 1 - tak
::----------------------------------------------------------------------------------------------------------------------
_empty:={? var_press('_c')=type_of(0) || _c || 0 ?};
_T:=xml_tparse(_a.DATA,,,0);
_result:=obj_new('fields','value'); _result.fields:=_result.value:='';
{? _empty || _result.value:=~~ ?};
_tree:=spli_str(_b,'.');
_level:=obj_len(_tree);
{? _T.find_tab(,'NAME',,'=',_a.METHOD+'Request')
||
   {? _T.find_tab(,'NAME',,'=',_tree[1],'TREE',,'=',#_T.ref())
   ||
      _T.prefix(_T.ref());
      {? _T.first()
      || {!
         |? _result.fields+='`sep`'+_T.NAME+'`sep`'+{? _T.VTRUNC='T' || exec('blob2txt','mwapi',_T.BVAL) || _T.VAL ?};
            {? _level=2 & _tree[2]=_T.NAME
            ||
               _result.value:={? _T.VTRUNC='T' || exec('blob2txt','mwapi',_T.BVAL) || _T.VAL ?}
            ?};
            _T.next()
         !}
      |? _level=1 & _tree[1]=_T.NAME
      ||
         _result.value:={? _T.VTRUNC='T' || exec('blob2txt','mwapi',_T.BVAL) || _T.VAL ?}
      ?}
   ?}
?};
_result


\blob2txt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.22]
:: OPIS: Zamienia wartość BLOBRAW na odpowiadającą mu zawartość z pliku tekstowego
::   WE: _a - pole BLOBRAW
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_file:=fopen(_a,'Ur',,,1);
{? _file.is_open()
|| {!
   |? _line:=_file.fread();
      _line<>'\n'
   |! _result+=_line+'\n'
   !}
?};
_result


\chk_oddz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Sprawdza prawidłowość wypełnienia oddziału i uprawnienia
::   WE: _a - oddział
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_oddzial:=_a;
_result:=1;
_wsenv:=exec('wsenv','#mwapi');
{? _oddzial<>''
|| {? +_oddzial=1
   || ODDZ.cntx_psh();
      ODDZ.index('KOD');
      ODDZ.prefix(_oddzial,);
      {? ODDZ.first()
      || {? ~exec('usr_upr','b_perm','ODDZ',exec('FindInSet','#table','ODDZ','KOD',_oddzial,,,1),OPERATOR.USER)
         || _wsenv.add_error('Brak uprawnień do oddziału %1.'@[_oddzial])
         ?}
      || _wsenv.add_error('Należy podać prawidłowy kod oddziału.'@)
      ?};
      ODDZ.cntx_pop()
   || _wsenv.add_error('Kod oddziału musi mieć jeden znak.'@)
   ?}
|| _wsenv.add_error('Kod oddziału musi być podany.'@)
?};
~_wsenv.has_errors()


\prolog
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [19.22]
:: OPIS: Formuła używana w formułach początkowych usługi sieciowej
::   WE: _a - parametry
::----------------------------------------------------------------------------------------------------------------------
VAR_DEL.delete('WS_User');
WS_User:=OPERATOR.USER;
OPERATOR.USER:=null;
_usr_str:={? var_pres('USER',_a)>0 || _a.USER || '' ?};
{? _usr_str<>''
|| OPERATOR.USER:=exec('users','#users',_usr_str);
:: Zapamiętanie bieżącego trybu pracy, ustawienie wskazanego użytkownika, przygotowanie dla niego parametrów sesji i
:: przełączenie na nie. W przypadku problemów - odtworzenie zapamiętanego trybu pracy.
   __PARSES.pushEnv();
   __PARSES.setUser(OPERATOR.USER);
   __PARSES.setMode('U');
   __PARSES.pushEnv();
   _id:=__PARSES.clone('S','U');
   {? _id<>''
   || {? ~__PARSES.setMode('S',_id)
      || __PARSES.popEnv();
         __PARSES.popEnv();
         mwa_fault('Uruchomienie sesji nie powiodło się.'@)
      ?}
   || __PARSES.popEnv();
      __PARSES.popEnv();
      mwa_fault('Przygotowanie parametrów sesji nie powiodło się.'@)
   ?}
|| mwa_fault('Nie ustalono nazwy użytkownika.'@)
?};
~~


\epilog
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MB [19.22]
:: OPIS: Formuła używana w formułach końcowych usługi sieciowej
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('WS_User')=type_of(null) & 5+$WS_User='users'
|| OPERATOR.USER:=WS_User;
   VAR_DEL.delete('WS_User');

::Odtworzenie zapamiętanego trybu pracy.
   _id:=__PARSES.getBID();
   __PARSES.popEnv();
   __PARSES.del(_id);
   _id:=__PARSES.getBID();
   __PARSES.popEnv();
   __PARSES.del(_id)

?};
~~


\get_value
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PD [23.25]
:: OPIS: Pobiera wartość ze stringa powstającego z formuły get_option fields
::   WE: _a - string z polami
::       _b - wartośc do wyciągnięcia
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of('') | var_pres('_b')<>type_of('') | _a='' | _b=''
|| return('')
?};
{? _a*'`sep`%1`sep`'[_b]
|| {? ((_a*'`sep`%1`sep`'[_b]+(+'`sep`%1`sep`'[_b])-_a)*'`sep`')=0
   || (_a*'`sep`%1`sep`'[_b]+(+'`sep`%1`sep`'[_b]-1)-_a)
   || ((_a*'`sep`%1`sep`'[_b]+(+'`sep`%1`sep`'[_b])-_a)*'`sep`')+(_a*'`sep`%1`sep`'[_b]+(+'`sep`%1`sep`'[_b]-1)-_a)
   ?}
|| ''
?}

:Sign Version 2.0 jowisz:1045 2023/11/23 12:59:24 dcb3d536bc28f357c3ef37567fc24a4244cc6ece864ad062eddbc2a6ab4ff0a555689f57e8ba96abe4736675c4cbaad43a3c5d7748550669ef7bd4520fde993257e27356b496522d228ccaffe5b3b01152fe3a7e513f461841d7bfef11a31f409893f93373cea832446586c8478a146ebd900bea14944a5cc201a4ac7ead2e5a
