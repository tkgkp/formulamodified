:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: zl_grop.fml
:: Utworzony: 16.10.2017
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły do obsługi grup operacji - biblioteczna dla tabel: GROP, GROPS, GROPP
::======================================================================================================================


\setGropsInfo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: ustawia zmienne VGROP podczas edycji nagłówka operacji grupowej
::  OLD: \setGropsInfo/gr_oper.fml
::  OLD: \setGropsInfo/!tpp_gop_dred.fml
::----------------------------------------------------------------------------------------------------------------------
VGROP.GR_CZAS:=time(0,0,0);
VGROP.GR_RES:=null();
VGROP.GR_KOD:='';
VGROP.GR_OPIS:='';
GROPS.cntx_psh();
GROPS.index('GROP');
GROPS.prefix(GROP.ref());
VGROP.IL_STAN:=GROPS.size();
{? GROPS.size()=1
|| GROPS.first();
   VGROP.GR_CZAS:=GROPS.CZAS;
   VGROP.GR_KOD:=GROPS.KOD;
   VGROP.GR_RES:=GROPS.PL_RES;
   VGROP.GR_OPIS:=GROPS.OPIS
?};
GROPS.cntx_pop()


\grop_efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Opcje pól w oknie redagowania GROP
::  OLD: \grop_efld_opt/!tpp_gop_dred.fml
::----------------------------------------------------------------------------------------------------------------------
_enable:={? VGROP.IL_STAN<2 || 'enable=1' || 'enable=0' ?};
GROP.efld_opt('RED',_enable,VGROP,'GR_RES');
GROP.efld_opt('RED',_enable,VGROP,'GR_KOD');
GROP.efld_opt('RED',_enable,VGROP,'GR_CZAS');
GROP.efld_opt('RED',_enable,VGROP,'GR_OPIS');
~~


\gropp_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Selekcja pozycji grupy operacji (wołane z przycisku w oknie wyświetlającym jedną grupę operacji)
::----------------------------------------------------------------------------------------------------------------------
GROPP.cntx_psh();
GROPP.win_sel('WER');
GROPP.index('GROP');
GROPP.prefix(GROP.ref());
GROPP.select(,,,'Dpu:D');
GROPP.cntx_pop();
''


\grops_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Selekcja zasobów grupy operacji (wołane z przycisku w oknie wyświetlającym jedną grupę operacji)
::----------------------------------------------------------------------------------------------------------------------
GROPS.cntx_psh();
GROPS.win_sel('WER');
GROPS.index('GROP');
GROPS.prefix(GROP.ref());
GROPS.select(,,,'DPUAW:D');
GROPS.cntx_pop();
''


\rej_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Obsługa przycisku 'Rejestracje' w oknie rejestracji wykonań - grupa operacji
::   WE: _a - czy zapis jest zablokowany przez innego operatora (zabrane akcje redakcyjne)
::       [_b] - dodatkowe akcje zabrane z menu (niepusta dziedzina)
::       Kontekst pracy: PROD_REJ
::----------------------------------------------------------------------------------------------------------------------
_hidden:={? var_pres('_b')=type_of('') || _b || '' ?};

PROD_REJ.GROP(); PROD_REJ.GROPS();
_grop_godz:=exec('grop_godz','zl_grop',0);
::exec('grop_godz','zl_grop',0,_grop_godz.TAB);
_grop_godz.TAB.win_sel(_grop_godz.GRP);
_grop_godz.TAB.hdr_sel();
_grop_godz.TAB.hdr_sel({? _a || ' — '+'PODGLĄD'@ || '' ?});
_grop_godz.TAB.select(,,,{? _a || 'PUIO' || '' ?}+_hidden);
~~


\grop_godz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Wyświetla rejestracje do grupy operacji
::   WE: _a - sposob pracy: 1 (domyslnie) selekcja, 0 - brak selekcji, TAB - brak selekcji, odswieza przekazana tabele
::       [_b] - [0]-w kontekście GROPS, 1-w kontekście GROP
::----------------------------------------------------------------------------------------------------------------------
_context:={? var_pres('_b')=type_of(0) || _b || 0 ?};

_res:=obj_new('TAB','WER','GRP','WERR');

{? var_pres('_a')=type_of(0)
|| _select:=_a
|? var_pres('_a')=type_of(SYSLOG)
|| _select:=0
|| _select:=1
?};

{? var_pres('_a')=type_of(SYSLOG)
|| _res.TAB:=_a
|| _res.TAB:=tab_tmp(2,
      'END','STRING[1]','Zakończona'@,
      'DT','DATE','Data'@,
      'ILOSC','REAL','Ilość'@,
      'OPERATOR','STRING[255]','Operator'@,
      'POTW','STRING[1]','Potwierdzony'@,
      'OK','STRING[1]','Zapis zamykający operację'@,
      'ZLGD','STRING[16]','$ZLGD.ref()',
      'STARTD','DATE','Data początkowa'@,
      'STARTT','TIME','Godzina początkowa'@,
      'ENDD','DATE','Data końcowa'@,
      'ENDT','TIME','Godzina końcowa'@,
      'TIME','REAL','Czas rzeczywisty'@,
      'TIME_P','REAL','Czas kalkulowany'@,
      'F','INTEGER',''
   )
?};
_res.GRP:=_res.TAB.grp_make('Rejestracje do grup operacji'@,,'grp_godz',,,,,'normal');
_res.WER:=_res.TAB.mk_sel('Rejestracje do grup operacji'@,,,'zl_grop',,10,,,'U');
_res.TAB.win_fld(_res.WER,,'DT',,,,,,'Data'@);
_res.TAB.win_fld(_res.WER,,'OPERATOR',,,40,,,'Wykonawca'@);
_res.TAB.win_fld(_res.WER,,'ILOSC',,,15,ST.DOKL_P,,'Ilość'@);
_res.TAB.win_fld(_res.WER,,'POTW',,,3,,,'Potwierdzony'@,,'Zapis został potwierdzony'@,2,1,"'T'","'N'");
:: Okno z rozpoczętymi operacjami (z e-kiosku)
_res.WERR:=_res.TAB.mk_sel('Rozpoczęte operacje'@ ,,,'grop_rozp',,10,,,'U');
_res.TAB.win_fld(_res.WERR,,'STARTD',,,,,,'Data'@);
_res.TAB.win_fld(_res.WERR,,'STARTT',,,,,,'Godzina'@);
_res.TAB.win_fld(_res.WERR,,'OPERATOR',,,40,,,'Wykonawca'@);

::_fb:="
::   {? var_pres('ProdRej')<0
::   || FUN.info('Funkcja dostępna tylko od strony modułu rejestracji wykonań.'@)
::   || ZLGD.cntx_psh();
::      ZLGD.use(8+cur_tab(1,1).ZLGD);
::      ZLGD.prefix();
::      {? ZLGD.seek(cur_tab(1,1).ZLGD)
::      || exec('zlgd_popraw','zl_grop')
::      ?};
::      ZLGD.cntx_pop()
::   ?}
::";
::_res.TAB.win_act(_res.WER,,'Formuła','Popraw'@@,,,_fb,,,,,,'P');
::task_attach('TTE_WYK_DWZL');
_fb:="
   exec('end_zlgd_ek','zl_wyk',2)
";
_res.TAB.win_act(_res.WERR,,'Formuła','&Zakończ'@@,,,_fb,,,,,,'Z');

task_attach('TTE_WYK_DWZL');
_fb:="
   {? var_pres('ProdRej')<0
   || FUN.info('Funkcja dostępna tylko od strony modułu rejestracji wykonań.'@)
   || ZLGD.cntx_psh(); ZLGB.cntx_psh();
      ZLGD.use(8+cur_tab(1,1).ZLGD);
      ZLGB.use((5+ZLGB.name())+(ZLGD.name()+3));
      ZLGD.prefix();
      {? ZLGD.seek(cur_tab(1,1).ZLGD)
      || {? exec('zlgd_usun','zl_grop')
         || cur_tab(1,1).del()
         ?}
      ?};
      ZLGD.cntx_pop(); ZLGB.cntx_pop()
   ?}
";
_res.TAB.win_act(_res.WER,,'Formuła','Usuń'@@,,,_fb,,,,,,'U');
task_attach('TTE_WYK_DWZL');
_res.TAB.win_act(_res.WERR,,'Formuła','Usuń'@@,,,_fb,,,,,,'U');
task_attach('TTE_WYK_DWZL');
_fb:="
   {? var_pres('ProdRej')<0
   || FUN.info('Funkcja dostępna tylko od strony modułu rejestracji wykonań.'@)
   || {? PROD_REJ.A<>'T'
      || FUN.info('Zapis nieaktywny — nie można potwierdzić wykonania.'@)
      |? ((8+cur_tab(1,1).ZLGD)+2)<>(2-form(ST.AR,-4,,'99'))
      || FUN.info(
            'Aby potwierdzić wykonanie grupy operacji należy wybrać okres z roku %1.'@
            ['20%1'[((8+cur_tab(1,1).ZLGD)+2)]]
         )
      || ZLGD.cntx_psh(); ZLGB.cntx_psh();
         ZLGD.use(8+cur_tab(1,1).ZLGD);
         ZLGB.use((5+ZLGB.name())+(ZLGD.name()+3));
         ZLGD.prefix();
         {? ZLGD.seek(cur_tab(1,1).ZLGD)
         || {? exec('zlgd_potw','zl_grop')
            || cur_tab(1,1).POTW:='T';
               cur_tab(1,1).put()
            ?}
         ?};
         ZLGD.cntx_pop(); ZLGB.cntx_pop()
      ?}
   ?}
";
_res.TAB.win_act(_res.WER,,'Formuła','Potw&ierdź'@@,,,_fb,,,,,,'I');
task_attach('TTE_WYK_DWZL');
_fb:="
   {? var_pres('ProdRej')<0
   || FUN.info('Funkcja dostępna tylko od strony modułu rejestracji wykonań.'@)
   || ZLGD.cntx_psh(); ZLGB.cntx_psh();
      ZLGD.use(8+cur_tab(1,1).ZLGD);
      ZLGB.use((5+ZLGB.name())+(ZLGD.name()+3));
      ZLGD.prefix();
      {? ZLGD.seek(cur_tab(1,1).ZLGD)
      || {? exec('zlgd_xpotw','zl_grop')
         || cur_tab(1,1).POTW:='N';
            cur_tab(1,1).put()
         ?}
      ?};
      ZLGD.cntx_pop(); ZLGB.cntx_pop()
   ?}
";
_res.TAB.win_act(_res.WER,,'Formuła','Odrzuć'@@,,,_fb,,,,,,'O');
task_attach('TTE_WYK_DWZL');
_fb:="
   ZLGD.cntx_psh(); ZLGB.cntx_psh();
   ZLGD.use(8+cur_tab(1,1).ZLGD);
   ZLGB.use((5+ZLGB.name())+(ZLGD.name()+3));
   ZLGD.prefix();
   {? ZLGD.seek(cur_tab(1,1).ZLGD)
   || exec('zlgd_ties','zl_grop')
   ?};
   ZLGD.cntx_pop(); ZLGB.cntx_pop()
";
_res.TAB.win_act(_res.WER,,'Formuła','Powią&zania'@@,,,_fb,,,,,,'Z');
task_attach('TTE_WYK_DWZL');
::_fb:="
::   _tab:=cur_tab(1,1);
::   _zlgd:=_tab.ZLGD;
::   ZLGD.cntx_psh();
::   ZLGD.use(8+_tab.ZLGD);
::   ZLGD.prefix();
::   {? ZLGD.seek(BIT.sqlint(_tab.ZLGD),)
::   || exec('action_zlgd_generate','zl_wyk')
::   ?};
::   ZLGD.cntx_pop()
::";
::_res.TAB.win_act(_res.WER,,'Formuła','Generuj dokumenty'@@,,,_fb,,,,,,'G');
::task_attach('TTE_WYK_DGRP');
::_fb:="
::   _tab:=cur_tab(1,1);
::   _zlgd:=_tab.ZLGD;
::   ZLGD.cntx_psh();
::   ZLGD.use(8+_tab.ZLGD);
::   ZLGD.prefix();
::   {? ZLGD.seek(BIT.sqlint(_tab.ZLGD),)
::   || exec('zlnd_sel','magdok_prod')
::   ?};
::   ZLGD.cntx_pop()
::";
::_res.TAB.win_act(_res.WER,,'Formuła','Dokumenty &magazynowe'@@,,,_fb,,,,,,'M');
_res.TAB.win_act(_res.WER,,'Menu','Fu&nkcje'@@,,,,,,,,,'N');
_fb:="
   ZLGD.cntx_psh();
   ZLGD.use(8+cur_tab(1,1).ZLGD);
   ZLGD.prefix();
   {? ZLGD.seek(cur_tab(1,1).ZLGD)
   || exec('zmiany','#syslog',ZLGD)
   ?};
   ZLGD.cntx_pop()
";
_res.TAB.win_act(_res.WER,,'Formuła','Zmiany — &wykonanie'@@,'#N',,_fb,,,,,,'W');
_fb:="
   ZLGD.cntx_psh();
   ZLGD.use(8+cur_tab(1,1).ZLGD);
   ZLGD.prefix();
   {? ZLGD.seek(cur_tab(1,1).ZLGD)
   || exec('zlgd_wyswietl','zl_grop')
   ?};
   ZLGD.cntx_pop()
";
_res.TAB.win_act(_res.WER,,'Wyświetl',,,,_fb);
_res.TAB.win_act(_res.WERR,,'Wyświetl',,,,_fb);
_fb:="
   {? _a
   || ZLGD.cntx_psh();
      ZLGD.use(8+cur_tab(1,1).ZLGD);
      ZLGD.prefix();
      {? ZLGD.seek(cur_tab(1,1).ZLGD)
      || _grayed:={? ZLGD.POTW='T' || 'I' || 'O' ?}
      || _grayed:=''
      ?};
      ZLGD.cntx_pop();
      cur_tab(1,1).actions_grayed(cur_win(1,1),_grayed)
   ?};
   ~~
";
_res.TAB.win_act(_res.WER,,'Rekord',,,,_fb);

_res.TAB.grp_sel(_res.GRP,,_res.WER,'Rejestracje'@,,,,,"cur_tab(1,1).prefix('T');~~",,,,'maximized',,1);
{? exec('get','#params',8715,2,OPERATOR.USER)='T'
|| _res.TAB.grp_sel(_res.GRP,,_res.WERR,'Rozpoczęte operacje'@,,,,,"cur_tab(1,1).prefix('N');~~",,,,'maximized')
?};
_res.TAB.win_sel(_res.GRP);

_tab:=sql('
   select
      ZLGD.ZAK as "END",
      ZLGD.DT as DT,
      ZLGD.IL as ILOSC,
      case when ZLGD.BP=\'B\' then \':_b\' || \' \' || ZLBR.KOD || \' \' || ZLBR.NAZ
      else \':_c\' || \' \' || OSOBA.NAZWISKO || \' \' || OSOBA.PIERWSZE || \' \' || OSOBA.DRUGIE
      end as OPERATOR,
      ZLGD.POTW as POTW,
      ZLGD.OK as OK,
      to_string(ZLGD.REFERENCE) as ZLGD,
      DATYS.DATA as STARD,
      ZLGD.STARTT as STARTT,
      DATYE.DATA as ENDD,
      ZLGD.ENDT as ENDT,
      ZLGD.TIME as TIME,
      ZLGD.TIME_P as TIME_P
   from @ZLGD
      left join ZLBR using(ZLGD.B,ZLBR.REFERENCE)
      left join P using(ZLGD.P,P.REFERENCE) left join OSOBA using(P.OSOBA,OSOBA.REFERENCE)
      left join DATY as DATYS using(ZLGD.STARTD,DATYS.REFERENCE)
      left join DATY as DATYE using(ZLGD.ENDD,DATYE.REFERENCE)
   where ZLGD.GROPS=:_a or ZLGD.GROP=:_a
',{? _context=1 || GROP.ref() || GROPS.ref() ?},'Brygada:'@,'Pracownik:'@);

{? type_of(_tab)=type_of(~~) || exec('err_sql','#sql'); return(_res) ?};

exec('tab2tab','#table',_tab,_res.TAB);

{? _select || _res.TAB.select() ?};
_res


\zlgd_ties
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Wyświetla powiązania zarejestrowanej operacji z rejestracjami źródłowymi i wynikowymi
::----------------------------------------------------------------------------------------------------------------------
ZLGD.cntx_psh(); ZLGB.cntx_psh();

:: Wynikowe ZLGD/ZLGB
ZLGD.index('ZLGD_SRC');
ZLGD.prefix($ZLGD.ref());
_zlgd:=ZLGD.first();

:: Selekcja
ZLGD.actions('WER','dPUCAO:dCA');
{? _zlgd
|| ZLGD.win_sel('WER');
   ZLGD.select()
|| FUN.info('Brak zapisów wynikowych.'@)
?};
ZLGD.actions('WER');

ZLGD.cntx_pop(); ZLGB.cntx_pop();
~~


\load_one4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Ładuje dane do rejestracji wykonań dla jednej grupy operacji
::   WE: _a - GROP.ref()
::----------------------------------------------------------------------------------------------------------------------
GROP.cntx_psh(); GROPS.cntx_psh(); GROPP.cntx_psh();
GROP.prefix();

{? GROP.seek(_a)
|| _il_grop:=GROP.IL;
   _il_grops:=0;

:: Iteracja po tabeli GROPS
   GROPS.index('GROP');
   GROPS.prefix(GROP.ref());
   {? GROPS.first()
   || {!
      |? {? GROPS.PLAN='P' | GROPS.PLAN='T'
         || PROD_REJ.blank(1);
            PROD_REJ.SRODZ:='ZL';
            PROD_REJ.SOURCE:=$GROPS.ref();
            PROD_REJ.GROP:=GROP.ref();
            PROD_REJ.GROPS:=GROPS.ref();
            PROD_REJ.A:={? GROP.STATUS='O' & GROPS.AKC='T' || 'T' || 'N' ?};
            PROD_REJ.DOREJ:={? GROP.STATUS='O' & GROPS.AKC='T' || 'T' || 'N' ?};
            PROD_REJ.STARTD:=GROP.DATA;
            {? GROPS.PLAN='T'
            || PROD_REJ.RES_SYM:=GROPS.PL_RES().SYM;
               PROD_REJ.RES_NAZ:=GROPS.PL_RES().NAZ;
               PROD_REJ.WYD:=exec('res_wyd','zl_grop',GROPS.PL_RES)
            || PROD_REJ.RES_SYM:='';
               PROD_REJ.RES_NAZ:='';
               PROD_REJ.WYD:=null()
            ?};

::          Zlicz ilości z rejestracji źródłowych
            ZLGD.cntx_psh();
            _oddzial:='_';
            GROPP.index('GROP');
            GROPP.prefix(GROP.ref());
            {? GROPP.first() || _oddzial:=GROPP.ZGP().NRZLP().ZLEC().ODDZ ?};
            _rok1:=GROP.DATA~1;
            _rok2:=date()~1;
::          ustalenie, czy wogóle są rekordy ZLGD
            PROD_REJ.POTW:='N';
            {! _it:=_rok1.._rok2
            |! _rok:=form(_it,-4,,'0')+2;
               ZLGD.use('zlgd_'+_oddzial+_rok);
               ZLGD.index('GROPS');
               ZLGD.prefix(GROPS.ref());
               {? ZLGD.first()
               || {!
                  |? PROD_REJ.POTW:='T';
                     PROD_REJ.POTW='N' & ZLGD.next()
                  !}
               ?}
            !};
            PROD_REJ.OK:='N';
            {! _it:=_rok1.._rok2
            |! _rok:=form(_it,-4,,'0')+2;
               ZLGD.use('zlgd_'+_oddzial+_rok);
               ZLGD.index('GROPS');
               ZLGD.prefix(GROPS.ref());
               {? ZLGD.first()
               || {!
                  |? {? ZLGD.POTW<>'T' || PROD_REJ.POTW:='N' ?};
                     {? ZLGD.OK='T' || PROD_REJ.OK:='T' ?};
                     ZLGD.next()
                  !}
               ?}
            !};
            ZLGD.cntx_pop();

            PROD_REJ.ILC:=GROPS.IL;
            PROD_REJ.ILW:=GROPS.ILW;
            PROD_REJ.IL:=PROD_REJ.ILC-PROD_REJ.ILW;
            {? PROD_REJ.IL<=0 || PROD_REJ.IL:=0; PROD_REJ.OK:='T' ?};
            PROD_REJ.PROBLEM:=GROP.PROBLEM;
            PROD_REJ.PROBKLAS:=GROP.PROBKLAS;
            PROD_REJ.KOOP:='N';
            PROD_REJ.RP:='N';
            PROD_REJ.START:={? exec('czyStartProdRej','ekioski',0) || 'T' || 'N' ?};
            exec('fields_4rej','zl_grop');

::          Po dodaniu rekordu PROD_REJ - odtworzenie następników
::          na podstawie następników powiązanych pozycji przewodników
            {? PROD_REJ.add()
            || _il_grops+=GROPS.IL;
               _prod_rej:=PROD_REJ.ref();
               GROPP.index('GROP');
               GROPP.prefix(GROP.ref());
               {? GROPP.first()
               || {!
                  |?
::                   Następniki
                     PROD_REJ.cntx_psh();
                     _next:=exec('tab_zgp_next','zl_guide',GROPP.ZGP);
                     {? _next.first()
                     || {!
                        |? PROD_REJ.index('ZGP');
                           PROD_REJ.prefix('ZL',_next.REF);
                           {? PROD_REJ.first()
                           || PROD_NXT.PROD_REJ:=_prod_rej;
                              PROD_NXT.NEXT:=PROD_REJ.ref();
                              PROD_NXT.add(1)
                           ?};
                           _next.next()
                        !}
                     ?};
                     obj_del(_next);
                     PROD_REJ.cntx_pop();

::                   Poprzedniki
                     PROD_REJ.cntx_psh();
                     _prev:=exec('tab_zgp_prev','zl_guide',GROPP.ZGP);
                     {? _prev.first()
                     || {!
                        |? PROD_REJ.index('ZGP');
                           PROD_REJ.prefix('ZL',_prev.REF);
                           {? PROD_REJ.first()
                           || PROD_NXT.PROD_REJ:=PROD_REJ.ref();
                              PROD_NXT.NEXT:=_prod_rej;
                              PROD_NXT.add(1)
                           ?};
                           _prev.next()
                        !}
                     ?};
                     obj_del(_prev);
                     PROD_REJ.cntx_pop();

                     GROPP.next()
                  !}
               ?}
            ?}
         ?};
         GROPS.next()
      !}
   ?};

:: Jeszcze GROP (dla ewentualnego zapisu bez zasobu)
   {? _il_grops<_il_grop
   || PROD_REJ.blank(1);
      PROD_REJ.SRODZ:='ZL';
      PROD_REJ.SOURCE:=$GROP.ref();
      PROD_REJ.GROP:=GROP.ref();
      PROD_REJ.GROPS:=null();
      PROD_REJ.A:='T';
      PROD_REJ.DOREJ:='N';
      PROD_REJ.STARTD:=GROP.DATA;
      PROD_REJ.RES_SYM:='';
      PROD_REJ.RES_NAZ:='';
      PROD_REJ.WYD:=null();
      PROD_REJ.ILC:=_il_grop-_il_grops;
      PROD_REJ.ILW:=0;
      PROD_REJ.IL:=PROD_REJ.ILC-PROD_REJ.ILW;
      PROD_REJ.OK:='N';
      PROD_REJ.PROBLEM:=GROP.PROBLEM;
      PROD_REJ.PROBKLAS:=GROP.PROBKLAS;
      PROD_REJ.KOOP:='N';
      PROD_REJ.RP:='N';
      PROD_REJ.START:={? exec('czyStartProdRej','ekioski',0) || 'T' || 'N' ?};
      exec('fields_4rej','zl_grop');

::    Po dodaniu rekordu PROD_REJ - odtworzenie następników na podstawie następników powiązanych pozycji przewodników
      {? PROD_REJ.add()
      || _prod_rej:=PROD_REJ.ref();
         GROPP.index('GROP');
         GROPP.prefix(GROP.ref());
         {? GROPP.first()
         || {!
            |?
::             Następniki
               PROD_REJ.cntx_psh();
               _next:=exec('tab_zgp_next','zl_guide',GROPP.ZGP);
               {? _next.first()
               || {!
                  |? PROD_REJ.index('ZGP');
                     PROD_REJ.prefix('ZL',_next.REF);
                     {? PROD_REJ.first()
                     || PROD_NXT.PROD_REJ:=_prod_rej;
                        PROD_NXT.NEXT:=PROD_REJ.ref();
                        PROD_NXT.add(1)
                     ?};
                     _next.next()
                  !}
               ?};
               obj_del(_next);
               PROD_REJ.cntx_pop();

::             Poprzedniki
               PROD_REJ.cntx_psh();
               _prev:=exec('tab_zgp_prev','zl_guide',GROPP.ZGP);
               {? _prev.first()
               || {!
                  |? PROD_REJ.index('ZGP');
                     PROD_REJ.prefix('ZL',_prev.REF);
                     {? PROD_REJ.first()
                     || PROD_NXT.PROD_REJ:=PROD_REJ.ref();
                        PROD_NXT.NEXT:=_prod_rej;
                        PROD_NXT.add(1)
                     ?};
                     _prev.next()
                  !}
               ?};
               obj_del(_prev);
               PROD_REJ.cntx_pop();

               GROPP.next()
            !}
         ?}
      ?}
   ?}
?};

GROP.cntx_pop(); GROPS.cntx_pop(); GROPP.cntx_pop();
~~


\del_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Kasuje dane z tabeli do rejestracji wykonań - zapisy dotyczące rejestracji grup operacji (ZL)
::   WE: _a - GROP.ref() kasuje dla wskazanej grupy operacji
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null()) || _zlec:=_a || return() ?};

Cntx.psh(PROD_REJ,PROD_NXT,GROP);
Cntx.clr(PROD_REJ,PROD_NXT,GROP);

{? GROP.seek(_a)
|| PROD_REJ.index('GROP');
   PROD_REJ.prefix('ZL',GROP.ref());
   {? PROD_REJ.first()
   || {!
      |? PROD_NXT.index('PROD_REJ');
         PROD_NXT.prefix(PROD_REJ.ref());
         {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};
         PROD_NXT.index('NEXT');
         PROD_NXT.prefix(PROD_REJ.ref());
         {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};
         PROD_REJ.del()
      !}
   ?}
?};

Cntx.pop(PROD_REJ,PROD_NXT,GROP);
~~


\load_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Ładuje dane do tabeli do rejestracji wykonań
::       Funkcja służy tylko do zainicjowania danych - na bieżąco działają triggery
::   WE: [_a] - czy dialogi: 1 [domyslnie tak] / 0
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _dialog:=_a || _dialog:=1 ?};

_result:=obj_new('RESULT','IL');
_result.RESULT:=0; _result.IL:=0;

GROP.cntx_psh(); GROPS.cntx_psh();

{? _dialog=0 | FUN.ask('Czy zainicjować ponownie tabelę do rejestracji produkcji dla grup operacji?'@)
|| GROP.prefix();
   {? GROP.first()
   || FUN.prg_start(GROP.size(),'Aktualizacja tabeli do rejestracji wykonań dla grup operacji.'@,,,1);
      {!
      |? FUN.prg_next();
         exec('del_4rej','zl_grop',GROP.ref());
         exec('load_one4rej','zl_grop',GROP.ref());
         _result.IL+=1;
         GROP.next()
      !};
      FUN.prg_stop()
   ?};

   {? _dialog
   || FUN.info('Zainicjowano tabelę do rejestracji produkcji dla grup operacji.'@)
   ?};
   _result.RESULT:=1
?};

GROP.cntx_pop(); GROPS.cntx_pop();
_result


\fields_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Ustala wartości pól PROD_REJ zależne od innych pól
::       Do użycia w formułach exec('update_4rej','zl_wyk'), exec('load_4rej','zl_grop')
::----------------------------------------------------------------------------------------------------------------------
:: Pobrany symbol grupy
PROD_REJ.OPIS:=GROP.KOD+' (Grupa operacji) '+GROP.OPIS;
PROD_REJ.OPER:='['+$PROD_REJ.STARTD+' '+$PROD_REJ.STARTT+'] '+PROD_REJ.OPIS;
~~


\rej_grop_pr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Rejestracja wykonan - z poziomu grup operacji (akcja przed)
::----------------------------------------------------------------------------------------------------------------------
{? exec('get','#params',500621,2)='Z'
|| exec('rej_grop_pr','zl_wyk')
|| exec('rej_grop_pr','po_wyk')
?}


\rej_grop_po
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Rejestracja wykonan - z poziomu grup operacji (akcja po)
::----------------------------------------------------------------------------------------------------------------------
{? exec('get','#params',500621,2)='Z'
|| exec('rej_grop_po','zl_wyk')
|| exec('rej_grop_po','po_wyk')
?}


\rej_grop_gpr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Rejestracja wykonan - z poziomu grup operacji (akcja przed grupa rekordow)
::----------------------------------------------------------------------------------------------------------------------
{? exec('get','#params',500621,2)='Z'
|| exec('rej_grop_gpr','zl_wyk')
|| exec('rej_grop_gpr','po_wyk')
?}


\rej_grop_gpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Rejestracja wykonań - z poziomu grup operacji (akcja po grupie rekordoów)
::----------------------------------------------------------------------------------------------------------------------
{? exec('get','#params',500621,2)='Z'
|| exec('rej_grop_gpo','zl_wyk')
|| exec('rej_grop_gpo','po_wyk')
?}


\zlgd_wyswietl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Wyswietla dane rejestracji wykonania dla grupy operacji (rekord ZLGD)
::----------------------------------------------------------------------------------------------------------------------
ZLGD.win_edit('RED_GROP');
VAR1.IL:=ZLGD.IL;
ZLGD.display();
~~


\zlgd_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Usunięcie zapisu wykonania dla grupy operacji (rekord ZLGD + ewentualne ZLGB)
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

{? ZLGD.POTW='T'
|| FUN.info('Zapis potwierdzony — nie można usunąć.'@);
   return(_result)
?};

:: Sprawdzenie podczas usuwania innego zapisu niz 'zamykajacego operacje'
{? ZLGD.OK='N'
|| _usun:=1;
   ZLGD.cntx_psh();
   ZLGD.index('GROP');
   ZLGD.prefix(ZLGD.GROP);
   {? ZLGD.first()
   || {!
      |? {? ZLGD.OK='T' || _usun:=0 ?};
         ZLGD.next()
      !}
   ?};
   ZLGD.cntx_pop();
   {? ~_usun
   || FUN.info('Najpierw należy usunąć zapis kończący wykonywanie operacji.'@);
      return(_result)
   ?}
?};

{? FUN.ask('Czy usunąć zapis?'@)
|| ZLGB.index('ZLGD');
   ZLGB.prefix(ZLGD.ref());
   {? ZLGB.first()
   || {!
      |? ZLGB.del()
      !}
   ?};
   exec('del4ZLGD','zl_limit');
::   exec('del4ZLGD','zl_wyr');
   _result:=ZLGD.del(,1)
?};
_result


\update_4rej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Aktualizacja tabel PROD_REJ i PROD_NXT
::       na podstawie zmian w tabelach GROP, GROPS, GROPP (obsługa triggerów)
::   WE: _a - rodzaj triggera: 'add', 'put', 'del'
::       _b - tabela: GROP, GROPS, GROPP
::   WY: wynik sterujacy dla triggera, czyli ~~ albo 0/1
::----------------------------------------------------------------------------------------------------------------------
{? _b=GROP
|| {? _a='add' | (_a='put' & bfld('ILPS')>=bfld('IL') & GROP.ILPS<GROP.IL & bfld('IL')=GROP.IL)
   || PROD_REJ.cntx_psh();
      PROD_REJ.index('GROP');
      PROD_REJ.prefix('ZL',GROP.ref(),null());
      PROD_REJ.blank(1);
      PROD_REJ.SRODZ:='ZL';
      PROD_REJ.SOURCE:=$GROP.ref();
      PROD_REJ.GROP:=GROP.ref();
      PROD_REJ.GROPS:=null();
      PROD_REJ.A:={? GROP.STATUS='O' & GROP.AKC='T' || 'T' || 'N' ?};
      PROD_REJ.DOREJ:='N';
      PROD_REJ.OK:='N';
      PROD_REJ.STARTD:=GROP.DATA;
      PROD_REJ.RES_SYM:='';
      PROD_REJ.RES_NAZ:='';
      PROD_REJ.IL:=GROP.IL-GROP.ILPS;
      PROD_REJ.ILC:=GROP.IL-GROP.ILPS;
      PROD_REJ.PROBLEM:='N';
      PROD_REJ.PROBKLAS:='';
      PROD_REJ.KOOP:='N';
      PROD_REJ.POTW:='N';
      exec('fields_4rej','zl_grop');
      {? PROD_REJ.add()
      || PROD_NXT.cntx_psh(); PROD_NXT.prefix();

         _prod_rej:=PROD_REJ.ref();
         GROPP.index('GROP');
         GROPP.prefix(GROP.ref());
         {? GROPP.first()
         || {!
            |?
::             Następniki
               PROD_REJ.cntx_psh();
               _next:=exec('tab_zgp_next','zl_guide',GROPP.ZGP);
               {? _next.first()
               || {!
                  |? PROD_REJ.index('ZGP');
                     PROD_REJ.prefix('ZL',_next.REF);
                     {? PROD_REJ.first()
                     || PROD_NXT.PROD_REJ:=_prod_rej;
                        PROD_NXT.NEXT:=PROD_REJ.ref();
                        PROD_NXT.add(1)
                     ?};
                     _next.next()
                  !}
               ?};
               obj_del(_next);
               PROD_REJ.cntx_pop();

::             Poprzedniki
               PROD_REJ.cntx_psh();
               _prev:=exec('tab_zgp_prev','zl_guide',GROPP.ZGP);
               {? _prev.first()
               || {!
                  |? PROD_REJ.index('ZGP');
                     PROD_REJ.prefix('ZL',_prev.REF);
                     {? PROD_REJ.first()
                     || PROD_NXT.PROD_REJ:=PROD_REJ.ref();
                        PROD_NXT.NEXT:=_prod_rej;
                        PROD_NXT.add(1)
                     ?};
                     _prev.next()
                  !}
               ?};
               obj_del(_prev);
               PROD_REJ.cntx_pop();

               GROPP.next()
            !}
         ?};
         PROD_NXT.cntx_pop()
      ?};
      PROD_REJ.cntx_pop();
      ~~
   |? _a='put' & GROP.ILPS<GROP.IL
   || PROD_REJ.cntx_psh(); GROPS.cntx_psh();
      PROD_REJ.index('GROP');
      PROD_REJ.prefix('ZL',GROP.ref(),null());
      {? PROD_REJ.first()
      || PROD_REJ.A:={? GROP.STATUS='O' & GROP.AKC='T' || 'T' || 'N' ?};
         PROD_REJ.DOREJ:='N';
         PROD_REJ.STARTD:=GROP.DATA;
         PROD_REJ.IL:=GROP.IL-GROP.ILPS;
         PROD_REJ.ILC:=GROP.IL-GROP.ILPS;
         PROD_REJ.PROBLEM:=GROP.PROBLEM;
         PROD_REJ.PROBKLAS:=GROP.PROBKLAS;
         exec('fields_4rej','zl_grop');
::       Aktualizacja znacznika START (czy operacja rozpoczęta na e-kiosku)
         PROD_REJ.START:={? exec('czyStartProdRej','ekioski',0) || 'T' || 'N' ?};
         PROD_REJ.put()
      ?};
      PROD_REJ.prefix('ZL',GROP.ref());
      {? PROD_REJ.first()
      || {!
         |? PROD_REJ.PROBLEM:=GROP.PROBLEM;
            PROD_REJ.PROBKLAS:=GROP.PROBKLAS;
            PROD_REJ.put();
            PROD_REJ.next()
         !}
      ?};
      PROD_REJ.cntx_pop(); GROPS.cntx_pop();
      ~~
   |? _a='del' | (_a='put' & GROP.ILPS>=GROP.IL)
   || PROD_REJ.cntx_psh();
      PROD_REJ.index('GROP');
      PROD_REJ.prefix('ZL',GROP.ref(),null());
      {? PROD_REJ.first()
      || PROD_NXT.index('PROD_REJ');
         PROD_NXT.prefix(PROD_REJ.ref());
         {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};
         PROD_NXT.index('NEXT');
         PROD_NXT.prefix(PROD_REJ.ref());
         {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};
         PROD_REJ.del()
      ?};
      _res:=~PROD_REJ.first();
      PROD_REJ.prefix('ZL',GROP.ref());
      {? PROD_REJ.first()
      || {!
         |? PROD_REJ.PROBLEM:=GROP.PROBLEM;
            PROD_REJ.PROBKLAS:=GROP.PROBKLAS;
            PROD_REJ.put();
            PROD_REJ.next()
         !}
      ?};
      PROD_REJ.cntx_pop();
      {? _a='del' || _res || ~~ ?}
   ?}

|? _b=GROPP
|| {? _a='add'
   || PROD_REJ.cntx_psh(); PROD_NXT.cntx_psh();
      PROD_NXT.prefix();

      PROD_REJ.index('GROP');
      PROD_REJ.prefix('ZL',GROPP.GROP);
      {? PROD_REJ.first()
      || {!
         |? _prod_rej:=PROD_REJ.ref();

            _next:=exec('tab_zgp_next','zl_guide',GROPP.ZGP);
            {? _next.first()
            || {!
               |? PROD_REJ.index('ZGP');
                  PROD_REJ.prefix('ZL',_next.REF);
                  {? PROD_REJ.first()
                  || PROD_NXT.PROD_REJ:=_prod_rej;
                     PROD_NXT.NEXT:=PROD_REJ.ref();
                     PROD_NXT.add(1)
                  ?};
                  _next.next()
               !}
            ?};
            obj_del(_next);

            _prev:=exec('tab_zgp_prev','zl_guide',GROPP.ZGP);
            {? _prev.first()
            || {!
               |? PROD_REJ.index('ZGP');
                  PROD_REJ.prefix('ZL',_prev.REF);
                  {? PROD_REJ.first()
                  || PROD_NXT.PROD_REJ:=PROD_REJ.ref();
                     PROD_NXT.NEXT:=_prod_rej;
                     PROD_NXT.add(1)
                  ?};
                  _prev.next()
               !}
            ?};
            obj_del(_prev);

            PROD_REJ.next()
         !}
      ?};
      PROD_REJ.cntx_pop(); PROD_NXT.cntx_pop();
      ~~

   |? _a='del'
   || PROD_REJ.cntx_psh(); PROD_NXT.cntx_psh();

      PROD_REJ.index('GROP');
      PROD_REJ.prefix('ZL',GROPP.GROP);
      {? PROD_REJ.first()
      || {!
         |? _prod_rej:=PROD_REJ.ref();

            _prev:=exec('tab_zgp_prev','zl_guide',GROPP.ZGP);
            {? _prev.first()
            || {!
               |? PROD_REJ.index('ZGP');
                  PROD_REJ.prefix('ZL',_prev.REF);
                  {? PROD_REJ.first()
                  || PROD_NXT.index('PROD_REJ');
                     PROD_NXT.prefix(PROD_REJ.ref(),_prod_rej);
                     {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?}
                  ?};
                  _prev.next()
               !}
            ?};
            obj_del(_prev);

            _next:=exec('tab_zgp_next','zl_guide',GROPP.ZGP);
            {? _next.first()
            || {!
               |? PROD_REJ.index('ZGP');
                  PROD_REJ.prefix('ZL',_next.REF);
                  {? PROD_REJ.first()
                  || PROD_NXT.index('NEXT');
                     PROD_NXT.prefix(PROD_REJ.ref(),_prod_rej);
                     {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?}
                  ?};
                  _next.next()
               !}
            ?};
            obj_del(_next);

            PROD_REJ.next()
         !}
      ?};
      PROD_REJ.cntx_pop(); PROD_NXT.cntx_pop();
      1
   ?}

|? _b=GROPS
|| {? _a='add' | (_a='put' & bfld('PLAN')='N' & GROPS.PLAN='T')
   || {? GROPS.PLAN='T'
      || GROPS.GROP();
         PROD_REJ.cntx_psh();
         PROD_REJ.index('GROPS');
         PROD_REJ.prefix('ZL',GROPS.ref());
         PROD_REJ.blank(1);
         PROD_REJ.SRODZ:='ZL';
         PROD_REJ.SOURCE:=$GROPS.ref();
         PROD_REJ.GROPS:=GROPS.ref();
         PROD_REJ.GROP:=GROPS.GROP;
         PROD_REJ.A:={? GROP.STATUS='O' & GROPS.AKC='T' || 'T' || 'N' ?};
         PROD_REJ.DOREJ:={? GROP.STATUS='O' & GROPS.AKC='T' || 'T' || 'N' ?};
         PROD_REJ.OK:='N';
         PROD_REJ.STARTD:=GROP.DATA;
         PROD_REJ.RES_SYM:=GROPS.PL_RES().SYM;
         PROD_REJ.RES_NAZ:=GROPS.PL_RES().NAZ;
         PROD_REJ.WYD:=exec('res_wyd','zl_grop',GROPS.PL_RES);
         PROD_REJ.IL:=GROPS.IL;
         PROD_REJ.ILC:=GROPS.IL;
         PROD_REJ.PROBLEM:='N';
         PROD_REJ.PROBKLAS:='';
         PROD_REJ.KOOP:='N';
         PROD_REJ.POTW:='N';
         PROD_REJ.RP:='N';
         exec('fields_4rej','zl_grop');
         {? PROD_REJ.add()
         || PROD_NXT.cntx_psh(); PROD_NXT.prefix();

            _prod_rej:=PROD_REJ.ref();
            GROPP.index('GROP');
            GROPP.prefix(GROP.ref());
            {? GROPP.first()
            || {!
               |?
::                Następniki
                  PROD_REJ.cntx_psh();
                  _next:=exec('tab_zgp_next','zl_guide',GROPP.ZGP);
                  {? _next.first()
                  || {!
                     |? PROD_REJ.index('ZGP');
                        PROD_REJ.prefix('ZL',_next.REF);
                        {? PROD_REJ.first()
                        || PROD_NXT.PROD_REJ:=_prod_rej;
                           PROD_NXT.NEXT:=PROD_REJ.ref();
                           PROD_NXT.add(1)
                        ?};
                        _next.next()
                     !}
                  ?};
                  obj_del(_next);
                  PROD_REJ.cntx_pop();

::                Poprzedniki
                  PROD_REJ.cntx_psh();
                  _prev:=exec('tab_zgp_prev','zl_guide',GROPP.ZGP);
                  {? _prev.first()
                  || {!
                     |? PROD_REJ.index('ZGP');
                        PROD_REJ.prefix('ZL',_prev.REF);
                        {? PROD_REJ.first()
                        || PROD_NXT.PROD_REJ:=PROD_REJ.ref();
                           PROD_NXT.NEXT:=_prod_rej;
                           PROD_NXT.add(1)
                        ?};
                        _prev.next()
                     !}
                  ?};
                  obj_del(_prev);
                  PROD_REJ.cntx_pop();

                  GROPP.next()
               !}
            ?};
            PROD_NXT.cntx_pop()
         ?};
         PROD_REJ.cntx_pop()
      ?};
      ~~

   |? _a='put' & bfld('PLAN')='T' & GROPS.PLAN='T'
   || GROPS.GROP();
      PROD_REJ.cntx_psh();
      PROD_REJ.index('GROPS');
      PROD_REJ.prefix('ZL',GROPS.ref());
      {? PROD_REJ.first()
      || PROD_REJ.A:={? GROP.STATUS='O' & GROPS.AKC='T' || 'T' || 'N' ?};
         PROD_REJ.DOREJ:={? GROP.STATUS='O' & GROPS.AKC='T' || 'T' || 'N' ?};
         PROD_REJ.OK:={? GROPS.ILW>=GROPS.IL || 'T' || 'N' ?};
         PROD_REJ.STARTD:=GROP.DATA;
         PROD_REJ.RES_SYM:=GROPS.PL_RES().SYM;
         PROD_REJ.RES_NAZ:=GROPS.PL_RES().NAZ;
         PROD_REJ.WYD:=exec('res_wyd','zl_grop',GROPS.PL_RES);
         PROD_REJ.IL+=GROPS.IL-bfld('IL');
         PROD_REJ.ILC:=GROPS.IL;
         PROD_REJ.PROBLEM:=GROP.PROBLEM;
         PROD_REJ.PROBKLAS:=GROP.PROBKLAS;
         exec('fields_4rej','zl_grop');
::       Aktualizacja znacznika START (czy operacja rozpoczęta na e-kiosku)
         PROD_REJ.START:={? exec('czyStartProdRej','ekioski',0) || 'T' || 'N' ?};
         PROD_REJ.put()
      ?};
      PROD_REJ.cntx_pop();
      ~~

   |? _a='del' | (_a='put' & bfld('PLAN')='T' & GROPS.PLAN='N')
   || PROD_REJ.cntx_psh();
      PROD_REJ.index('GROPS');
      PROD_REJ.prefix('ZL',GROPS.ref());
      {? PROD_REJ.first()
      || PROD_NXT.index('PROD_REJ');
         PROD_NXT.prefix(PROD_REJ.ref());
         {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};
         PROD_NXT.index('NEXT');
         PROD_NXT.prefix(PROD_REJ.ref());
         {? PROD_NXT.first() || {! |? PROD_NXT.del() !} ?};
         PROD_REJ.del()
      ?};
      _res:=~PROD_REJ.first();
      PROD_REJ.cntx_pop();
      {? _a='del' || _res || ~~ ?}

   || ~~
   ?}
?}


\zlgd_potw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Potwierdzenie bieżącego wykonania
::       Kontekst pracy - rekord ZLGD
::   WY: 0 / 1 - czy nastąpiło potwierdzenie
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

Cntx.psh(GROPP,ZLGD);
{? ZLGD.r_lock(1,1,1)
||
   {? ZLGD.GROP=null()
   || FUN.info('Potwierdzenie wykonania dostępne tylko dla grup operacji.'@)
   |? ZLGD.ZAK='N'
   || FUN.info('Operacja nie została zakończona.'@)

   |? ZLGD.POTW='N'
   ||
::    Ilość grup z bieżącej rejestracji
      _ilosc:=ZLGD.IL;

::    Potwierdzenie (zawsze z rozpisaniem)
      ProdRej.GROPP.TAB.clear();
      ProdRej.GROPP.TAB.erase();
      ProdRej.GROPP.TAB.index(ProdRej.GROPP.NdxOpis);

      GROPP.index('GROP');
      GROPP.prefix(ZLGD.GROP);

::    Suma czasów grupy wg przewodników (planowany czas technologiczny grupy)
      _czasm:=0;
      {? GROPP.first()
      || {!
         |? _czasm+=GROPP.CZASM;
            GROPP.next()
         !}
      ?};

::    Współczynnik przeliczenia czasu (czas ogółem skalowany do czasu planowanego poszczególnych operacji)
      {? ZLGD.TIME<>0
      || _coef:={? _czasm=0 || 1 || ZLGD.TIME*60/_czasm ?}
      || _coef:=1
      ?};

      {? GROPP.first()
      || {!
         |? ProdRej.GROPP.TAB.GROPP:=#GROPP.ref();
            ProdRej.GROPP.TAB.ZGP_REF:=#GROPP.ZGP;
            ProdRej.GROPP.TAB.ZL_WYR:=#GROPP.ZL_WYR;
            ProdRej.GROPP.TAB.ZGP_OPIS:='%1 poz. %2'@[GROPP.ZGP().NRZLP().NRPRZ,$ZGP.NRP];
            ProdRej.GROPP.TAB.IL:=GROPP.IL*_ilosc;
            ProdRej.GROPP.TAB.IL_WYK:=GROPP.IL*_ilosc;
            ProdRej.GROPP.TAB.IL_BRAK:=0;
            ProdRej.GROPP.TAB.CZASM:=GROPP.CZASM*_coef*{? _ilosc=0 & ZLGD.TIME<>0 || 1 || _ilosc ?};
::            ProdRej.GROPP.TAB.DOKL:=GROPP.ZGP().NRZLP().ZLEC().KTM().DOKL;
            ProdRej.GROPP.TAB.DOKL:=GROPP.M().DOKL;
            ProdRej.GROPP.TAB.JM:=M.J().KOD;
            ProdRej.GROPP.TAB.KTM:=M.KTM;
            {? ProdRej.GROPP.TAB.ZL_WYR<>0
            || ProdRej.GROPP.TAB.MAG:=GROPP.ZL_WYR().MG().SYM;
               ProdRej.GROPP.TAB.LOK:=GROPP.ZL_WYR().EANL().KOD
            ?};
            ProdRej.GROPP.TAB.BRAKI_R:='';
::          Dla grup z zerową ilością nie wypełniam partii
            ProdRej.GROPP.TAB.PARTY:=
               {? _ilosc=0
               || 0
               || exec('zlec_party','zl_common',exec('FindAndGet','#table',ZGP,GROPP.ZGP,,"ZGP.ZL",null))
               ?};
            {? ProdRej.GROPP.TAB.PARTY
            ||
::             Sprawdzam czy przewodnik posiada dokładnie jedną partię, wtedy mogę ją przypisać
               ZPARN.cntx_psh();
               ZPARN.index('ZGH');
               ZPARN.prefix(GROPP.ZGP().NRZLP);
               {? ZPARN.size()=1
               || {? ZPARN.first()
                  || ProdRej.GROPP.TAB.ZPARN:=#ZPARN.ref();
                     ProdRej.GROPP.TAB.PARSYM:=ZPARN.SYM
                  ?}
               || ProdRej.GROPP.TAB.ZPARN:=-1;
                  ProdRej.GROPP.TAB.PARSYM:=''
               ?};
               ZPARN.cntx_pop()
            || ProdRej.GROPP.TAB.ZPARN:=-1;
               ProdRej.GROPP.TAB.PARSYM:=''
            ?};
            ProdRej.GROPP.TAB.add();
            GROPP.next()
         !}
      ?};
      {? _ilosc=0
      ||
::       Automatyczne (bezdialogowe) potwierdzenia dla zerowej ilości
         do();
         ZLGD.POTW:='T';
         {? ZLGD.put()
         || exec('add_akord_4grop','zl_grop',ZLGD.ref());
            exec('end_akord_4grop','zl_grop',ZLGD.ref());
            {? do_state()=1 || _result:=1 ?}
         ?};
         end()
      |? VEK.TERM='T'
      || _result:=exec('grop_potw','ekioski')

      || _wer:=ProdRej.GROPP.TAB.mk_sel('Potwierdzenie wykonania grupy operacji'@,,0,'rozpiszgropp',20,10,,,'U',
            ,,,,'html_maximized');
         ProdRej.GROPP.TAB.win_fld(_wer,,'ZGP_OPIS',,,40,,1,'Pozycja przewodnika'@);
         ProdRej.GROPP.TAB.win_fld(_wer,,'KTM',,,30,,1,'Produkt'@);
         ProdRej.GROPP.TAB.win_fld(_wer,,'JM',,,5,,1,'jm'@);
         ProdRej.GROPP.TAB.win_fld(_wer,,'IL',,,15,ST.DOKL_P,1,'Ilość planowana'@);
         ProdRej.GROPP.TAB.win_fld(_wer,,'IL_WYK',,,15,ST.DOKL_P,,'Ilość wykonana'@);
         ProdRej.GROPP.TAB.win_fld(_wer,,'IL_BRAK',,,15,ST.DOKL_P,1,'Ilość braków'@);
         ProdRej.GROPP.TAB.win_fld(_wer,,'BRAKI_R',,,15,,,'Rodzaj braku'@);
         ProdRej.GROPP.TAB.win_fld(_wer,,'PARSYM',,,25,,,'Partia'@);
         ProdRej.GROPP.TAB.win_fld(_wer,,'CZASM',,,15,4,1,'Czas [min]'@);
         ProdRej.GROPP.TAB.win_act(_wer,,'Popraw',,,,,,1);
         _ok:="
            _result:=1;
            _msg:='';
            {? ProdRej.GROPP.TAB.first()
            || {!
               |?
                  {? ProdRej.GROPP.TAB.PARTY>0 &  ProdRej.GROPP.TAB.PARSYM=''
                  || _result:=0;
                     _msg:='Do przewodnika %1 nie przypisano partii.'@[ProdRej.GROPP.TAB.ZGP_OPIS]
                  |? ProdRej.GROPP.TAB.PARTY>0 & exec('FindInSet','#table','ZPARN','ZL2', ProdRej.GROPP.TAB.PARSYM,
                     exec('FindAndGet','#table',ZGP,ProdRej.GROPP.TAB.ZGP_REF,,\"ZGP.ZL\",'')
                     ,\"ZPARN.ref()\",1,,null)=null()
                  || _result:=0;
                     _msg:='Do przewodnika %1 przypisano niepoprawną partię.'@[ProdRej.GROPP.TAB.ZGP_OPIS]
                  |? ProdRej.GROPP.TAB.IL_BRAK>0 & ProdRej.GROPP.TAB.BRAKI_R='' & exec('get','#params',500635,2)='T'
                  || _result:=0;
                     _msg:='Do przewodnika %1 nie przypisano rodzaju braku.'@[ProdRej.GROPP.TAB.ZGP_OPIS]
                  |? ProdRej.GROPP.TAB.IL_BRAK>0 & ProdRej.GROPP.TAB.BRAKI_R<>''
                     & exec('FindInSet','#table','BRAKI_R','KOD',ProdRej.GROPP.TAB.BRAKI_R,,,1,,null)=null
                  || _result:=0;
                     _msg:='Do przewodnika %1 przypisano niepoprawny rodzaj braku.'@[ProdRej.GROPP.TAB.ZGP_OPIS]
                  ?};
                  _result & ProdRej.GROPP.TAB.next()
               !}
            ?};
            {? _result
            || sel_exit()
            || FUN.emsg(_msg)
            ?}
         ";
         ProdRej.GROPP.TAB.win_act(_wer,,'Formuła','Akceptuj'@@,,,_ok,,,,,,'A',,'target=window');
         _valid:="
            {? ProdRej.GROPP.TAB.IL_WYK<0
            || FUN.emsg('Ilość nie może być ujemna.'@);
               0
            |? ProdRej.GROPP.TAB.IL_WYK>ProdRej.GROPP.TAB.IL
            || FUN.emsg('Ilość wykonana nie może być większa niż planowana.'@);
               0
            |? ProdRej.GROPP.TAB.PARTY>0 & ProdRej.GROPP.TAB.PARSYM=''
            || FUN.emsg('Zlecenie jest partiowane. Należy wskazać partię.'@);
               0
            |? ProdRej.GROPP.TAB.PARTY>0 & exec('FindInSet','#table','ZPARN','ZL2', ProdRej.GROPP.TAB.PARSYM,
               exec('FindAndGet','#table',ZGP,ProdRej.GROPP.TAB.ZGP_REF,,\"ZGP.ZL\",''),\"ZPARN.ref()\",1,,null)=null
            || FUN.emsg('Nie odnaleziono partii o wskazanym symbolu.'@);
               0
            |? ProdRej.GROPP.TAB.IL_BRAK>0 & ProdRej.GROPP.TAB.BRAKI_R='' & exec('get','#params',500635,2)='T'
            || FUN.emsg('Rodzaj braku musi być określony.'@);
               0
            |? ProdRej.GROPP.TAB.IL_BRAK>0 & ProdRej.GROPP.TAB.BRAKI_R<>''
               & exec('FindInSet','#table','BRAKI_R','KOD',ProdRej.GROPP.TAB.BRAKI_R,,,1,,null)=null
            || FUN.emsg('Nie odnaleziono rodzaju braku o podanym kodzie.'@);
               0
            || 1
            ?}
         ";
         ProdRej.GROPP.TAB.win_act(_wer,,'Rekord',,,,,_valid);
         ProdRej.GROPP.TAB.win_btn(_wer,'text=%1,panel=bottom'['&Akceptuj'@],'menu:A');
         ProdRej.GROPP.TAB.win_btn(_wer,'text=%1,panel=bottom'['&Zamknij'@],'key:Esc');
         ProdRej.GROPP.TAB.win_sel(_wer);
::       Ustawienie filtru na rodzaje braków
         GROP.cntx_psh();
         _ref:=ZLGD.GROP().TTOPER;
         GROP.cntx_pop();
         exec('braki_r_filter','braki',,'T',$_ref);
         {? ProdRej.GROPP.TAB.select()
         || do();
            ZLGD.POTW:='T';
            {? ZLGD.put()
            || exec('add_akord_4grop','zl_grop',ZLGD.ref());
               exec('end_akord_4grop','zl_grop',ZLGD.ref());
               {? do_state()=1 || _result:=1 ?}
            ?};
            end()
         ?}
      ?}
   ||
:: Odrzucenie - nic nie robię, nie powinno tutaj dojść
      ~~
   ?};
   ZLGD.r_unlock()
|| FUN.emsg('Rekord modyfikowany przez innego użytkownika.'@)
?};

Cntx.pop(GROPP,ZLGD);
_result


\zlgd_xpotw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Odrzucenie bieżącego wykonania
::       Kontekst pracy - rekord ZLGD
::   WY: 0 / 1 - czy nastąpiło wycofanie potwierdzenia
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

{? ZLGD.GROP=null()
|| FUN.info('Odrzucenie wykonania dostępne tylko dla grup operacji.'@)
|? ZLGD.ZAK='N'
|| FUN.info('Operacja nie została zakończona.'@)

|? ZLGD.POTW='N'
||
:: Potwierdzenie - nic nie robię, nie powinno tutaj dojść
   ~~
||
:: Odrzucenie
   ZLGD.cntx_psh();
   ZLGD.index('ZLGD_SRC');
   ZLGD.prefix($ZLGD.ref());
   _txt:='Czy odrzucić potwierdzenie bieżącego zapisu?'@;
   {? ZLGD.size()>0
   || _txt+='\n\n'+'Wycofane zostaną również zapisy powiązane z zarejestrowanymi ilościami do przewodników zleceń.'@
   ?};
   ZLGD.cntx_pop();

   {? FUN.ask(_txt)
   || do();
      ZLGD.POTW:='N';
      {? ZLGD.put()
      || _res:=exec('del_akord_4grop','zl_grop',ZLGD.ref());
         _result:=(_res>0);
         {? _result=0
         ||
::          Szczegółowe opisy błędów w razie potrzeby nanieść na podstawie formuły \zlgd_usun/zl_wyk.fml
            _msg:=
               {? _res=-5
               || 'przewodnik oddany'@
               |? _res=-10
               || 'zarejestrowano wykonania do kolejnych operacji'@
               || 'błąd %1'@[$_res]
               ?};
            undo('Nie można odrzucić potwierdzenia (%1).'@[_msg])
         ?}
      ?};
      end()
   ?}
?};
_result


\end_akord_4grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Uruchamia proces dla zapisów akordowych wygenerowanych dla zapisów rejestracji do grup operacji
::   WE: _a - ZLGD.ref()
::----------------------------------------------------------------------------------------------------------------------
_zlgd:=_a;

ZLGD.cntx_psh();
ZLGD.index('ZLGD_SRC');
ZLGD.prefix($_zlgd,);
{? ZLGD.first()
|| {!
   |?
::    Obsługa procesowości
      {? ZLGD.KJ_DONE='T'
      || _zl_ref:=ZLGD.ZL;
         _zl_uid:=exec('FindAndGet','#table',ZL,_zl_ref,,"uidref()",'');

         _args:=exec('mp_run_a','#b__box');
         _args.ACT_UID:='TTE_WYK_DWZL';
         _args.UIDREF:=_zl_uid;
         _args.AKCJA:='ZAKOŃCZ';
         _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
         _args.PROC_START:='T';
         _args.CONTEXT:=obj_new('ZLGD','ZGP','ILOSC','BRAKI');
            _args.CONTEXT.ZLGD:=ZLGD.ref();
            _args.CONTEXT.ZGP:=ZLGD.ZGP;
            _args.CONTEXT.ILOSC:=ZLGD.IL;
            _args.CONTEXT.BRAKI:=ZLGD.IL_BRAK;

         exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',_zl_ref);

         exec('mp_run','#b__box',_args);

         obj_del(_args)
      ?};
      ZLGD.next()
   !}
?};
ZLGD.cntx_pop();
~~


\add_akord_4grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Dodaje zapisy akordowe do rejestracji dla grupy operacji (w funkcji Potwierdź)
::   WE: _a - ZLGD.ref()
::----------------------------------------------------------------------------------------------------------------------
_zlgd:=_a;

Cntx.psh(ZLGD,GROP,GROPP);
Cntx.clr(ZLGD,GROP,GROPP);

{? ZLGD.seek(_a)
|| _timedok:=exec('get','#params',500604,1);

   _args:=exec('add_akord_a','zl_wyk');

   ProdRej.GROPP.TAB.clear();
   ProdRej.GROPP.TAB.index(ProdRej.GROPP.NdxPoz);
:: Tabela obsłużonych operacji (ZGP) przy rejestracji w rozbiciu na wyroby
   _refs:=tab_tmp(1,'REF','INTEGER','#ZGP.ref9()');
:: Podczytanie powiazanych rekordow
   ZLGD.GROP();

   GROPP.index('GROP');
   GROPP.prefix(GROP.ref());
   {? GROPP.first()
   || {!
      |?
::       Podczytanie powiazanych rekordow
         GROPP.ZGP().NRZLP();
::       Jeżeli dana operacja (ZGP) była już obsłużona (utworzono ZLGD) to ją pomijam (wiele wyrobów)
         {? ~_refs.find_key(#ZGP.ref())
         ||
::          Walidacja
            {? ZGP.PROBLEM='T'
            || undo('Do powiązanej operacji przewodnika (%1 - %2) zgłoszono problem.'@[ZGH.NRPRZ,$ZGP.NRP])
            |? ZGP.STATUS=exec('status_end','zl_guide')
            || undo('Powiązana operacja przewodnika (%1 - %2) oznaczona jako zakończona.'@[ZGH.NRPRZ,$ZGP.NRP])
            |? ZGH.ZLEC().STAN<>'O'
            || undo('Powiązana operacja przewodnika (%1 - %2) nie dotyczy otwartego zlecenia.'@[ZGH.NRPRZ,$ZGP.NRP])
            ?};

            ProdRej.GROPP.TAB.prefix(#GROPP.ref());
            {? ProdRej.GROPP.TAB.first()
            ||
               _args.ZGP:=GROPP.ZGP;
               _args.P:=ZLGD.P;
               _args.ZLBR:=ZLGD.B;
               _args.DT:=ZLGD.DT;
               _args.STARTD:=ZLGD.STARTD().DATA;
               _args.STARTT:=ZLGD.STARTT;
               _args.ENDD:=ZLGD.ENDD().DATA;
               _args.ENDT:=ZLGD.ENDT;
               _args.ZMIANA:=ZLGD.ZMIANA;
               {? ProdRej.GROPP.TAB.ZL_WYR=0
               || _args.IL:=ProdRej.GROPP.TAB.IL_WYK;
                  _args.IL_BRAK:=ProdRej.GROPP.TAB.IL-ProdRej.GROPP.TAB.IL_WYK;
                  _args.TIME:=(ProdRej.GROPP.TAB.CZASM/60)$_timedok
::                     (PL_WYK.TM_END-PL_WYK.TM_START)/exec('minute','#tm_stamp')/60
               ||
::                Potwierdzenie rejestracji grupy operacji z rozbiciem na różne wyroby
                  ProdRej.GROPP.TAB.cntx_psh();
                  ProdRej.GROPP.TAB.index(ProdRej.GROPP.NdxEkiosk);
                  ProdRej.GROPP.TAB.prefix(#ZGP.ref());
                  {? ProdRej.GROPP.TAB.first()
                  || VAR1.REJ_WYR:='T';
                     exec('fill_env','zl_wyr',ZGP.ref(),,,,ProdRej.GROPP.TAB);
                     _args.IL:=_args.IL_BRAK:=_args.TIME:=0;
                     {!
                     |?
::                      Dla operacji rozbitej wg produktów sumuje ilości ze wszystkich rekordów dotyczących danego ZGP
                        _args.IL+=ProdRej.GROPP.TAB.IL_WYK;
                        _args.IL_BRAK+=ProdRej.GROPP.TAB.IL-ProdRej.GROPP.TAB.IL_WYK;
                        _args.TIME+=(ProdRej.GROPP.TAB.CZASM/60)$_timedok;
                        ProdRej.GROPP.TAB.next()
                     !}
                  ?};
                  ProdRej.GROPP.TAB.cntx_pop()
               ?};

               _args.AUTO:='T';
               _args.R:=ZLGD.R;
               _args.ZLGD_SRC:=$ZLGD.ref();
::            _args.OK:=ZLGD.OK;
               _args.ZPARN:=null;
               _args.PLACE:=ZLGD.PLACE;
               _args.BRAKI_R:=exec('FindInSet','#table','BRAKI_R','KOD',ProdRej.GROPP.TAB.BRAKI_R,,,1,,null);
::             Sprawdzam czy pole z partią musi być wypełnione
               _party_req:=ZLGD.IL>0 & exec('party_req','zl_wyk',GROPP.ZL);
               {? _party_req>0
               ||
::                Przypisuje partię z rozpiski (jeżeli była)
                  {? ProdRej.GROPP.TAB.ZPARN>0
                  || _args.ZPARN:=exec('FindAndGet','#table',ZPARN,ProdRej.GROPP.TAB.ZPARN,,"ZPARN.ref",null())
                  ||
::                   Sprawdzam czy przewodnik posiada dokladnie jedna partie, wtedy moge
::                   przekazac dalej ta partie i nie pytac o nia podczas rejestracji dokumentu
                     ZPARN.cntx_psh();
                     ZPARN.index('ZGH');
                     _zgh:=GROPP.ZGP().NRZLP;

                     {? _zgh<>null()
                     || _party_zgh:=exec('party_first_zgh','zl_guide',_zgh);
                        {? _party_zgh<>null()
                        || ZPARN.prefix(_party_zgh);
                           {? ZPARN.size()=1
                           || _args.ZPARN:=ZPARN.ref()
                           ?}
                        ?}
                     ?};
                     ZPARN.cntx_pop();
                     ~~
                  ?}
               ?};
               ZLGD.cntx_psh();
               ZLGD.index('PL_WYK');
               ZLGD.prefix($_zlgd,GROPP.ZGP);
               {? ZLGD.first()
               || exec('update_akord','zl_wyk',_args)
               || VPRODREJ.AUTO:='T';
                  exec('add_akord','zl_wyk',_args)
               ?};
               ZLGD.cntx_pop();
               VAR1.REJ_WYR:='N';
::             Oznaczam operację jako przetworzoną
               _refs.REF:=#GROPP.ZGP;
               _refs.add()
            ?}
         ?};
         GROPP.next()
      !}
   ?}
?};
Cntx.pop(ZLGD,GROP,GROPP);
~~


\del_akord_4grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Usuwa zapisy akordowe do rejestracji dla grupy operacji (w funkcji Odrzuć)
::   WE: _a - ZLGD.ref()
::   WY: 1 - zapis został usunięty, 0 i wartości ujemne - zapisy nie zostały usunięte
::----------------------------------------------------------------------------------------------------------------------
_zlgd:=_a;
_res:=0;
_can_continue:=1;
ZLGD.cntx_psh();
ZLGD.index('ZLGD_SRC');
ZLGD.prefix($_zlgd,);
{? ZLGD.first()
|| {!
   |? ZLGD.cntx_psh();
      _can_continue:=exec('zlgd_usun','zl_wyk',0,1);
      ZLGD.cntx_pop();
      _can_continue>0 & ZLGD.next()
   !}
?};
{? _can_continue>0 || _res:=1 || _res:=_can_continue ?};
ZLGD.cntx_pop();
_res


\res_wyd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Ustala wydział dla wskazanego zasobu
::   WE: _a - PL_RES.ref()
::   WY: UD_SKL.ref()
::----------------------------------------------------------------------------------------------------------------------
_result:=null();
_kod:=exec('FindAndGet','#table',TWRKPLC,PL_RES.FROM_STA,,"WYD().KOD",'');
{? _kod<>''
|| _sch:=exec('domyslny','schemat','PODZORG');
   UD_DEF.cntx_psh();
   UD_DEF.index('SCHSYM');
   UD_DEF.prefix(_sch,_kod,);
   {? UD_DEF.first()
   || _result:=UD_DEF.UD_SKL
   || FUN.info(
         'Nie znaleziono elementu \'%1\' struktury organizacyjnej — '
         'należy sprawdzić konfigurację słownika wydziałów.'@
         [_kod]
      )
   ?};
   UD_DEF.cntx_pop()
?};
_result


\grop_bryg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Czy GROP ma operacje pracownicze czy brygadowe
::   WE: _a - GROP.ref()
::   WY: 'T' albo 'N'
::  OLD: \grop_bryg/gr_oper.fml
::  OLD: \grop_bryg/po_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;

_pb:='N';

GROP.cntx_psh();
GROP.clear();
{? GROP.seek(_grop)
||
   GROPP.index('GROP');
   GROPP.prefix(GROP.ref());
   {? GROPP.first()
   || _pb:=GROPP.ZGP().BRYG
   ?}
?};

GROP.cntx_pop();

_pb


\filtrPlResGr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: ustawia filtr na zasoby planistyczne dla operacji grupowych
::  OLD: \filtrPlResGr/gr_oper.fml
::  OLD: \filtrPlResGr/po_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
PL_RES.win_sel('WER');
PL_RES.prefix();
PL_RES.f_set('SYM');
~~


\odtworz_ilw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Odtwarza ilość wykonaną/potwierdoną na grupach operacji
::   WE: [_a] - czy wyświetlać dialog [1]/0
::       [_b] - GROP.ref() - jeżeli podany to aktualizowana wyłącznie podana grupa operacji
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _dialog:=_a || _dialog:=1 ?};
{? var_pres('_b')=type_of(null()) || _ref:=_b || _ref:=null() ?};
_prg:={? _ref=null() || 1 || 0 ?};

{? ~_dialog | FUN.ask('Czy odtwarzać dane?'@)
|| GROP.cntx_psh(); GROPS.cntx_psh(); GROPP.cntx_psh(); ZLGD.cntx_psh();
   GROP.index('KOD');
   GROP.prefix();
   {? {? _ref=null() || GROP.first() || GROP.seek(_ref) ?}
   || {? _prg>0 || FUN.prg_start(GROP.size(),'Aktualizacja grup operacji.'@,,,1) ?};
      {!
      |? {? _prg>0 || FUN.prg_next() ?};
::       Zlicz ilości z rejestracji źródłowych
         _oddzial:='_';
         GROPP.index('GROP');
         GROPP.prefix(GROP.ref());
         {? GROPP.first() || _oddzial:=GROPP.ZGP().NRZLP().ZLEC().ODDZ ?};
         _rok1:=GROP.DATA~1;
         _rok2:=date()~1;
         _ilw:=0;
         _ilpotw:=0;
         {! _it:=_rok1.._rok2
         |! _rok:=form(_it,-4,,'0')+2;
            ZLGD.use('zlgd_'+_oddzial+_rok);
            ZLGD.index('GROP');
            ZLGD.prefix(GROP.ref());
            {? ZLGD.first()
            || {!
               |? _ilw+=ZLGD.IL;
                  {? ZLGD.POTW='T'
                  || _ilpotw+=ZLGD.IL
                  ?};
                  ZLGD.next()
               !}
            ?}
         !};
         GROP.ILW:=_ilw;
         GROP.ILPOTW:=_ilpotw;
         GROP.CZY_WYK:={? GROP.ILW>=GROP.IL || 'T' || 'N' ?};
         GROP.CZY_POTW:={? GROP.ILPOTW>=GROP.IL || 'T' || 'N' ?};
         GROP.put();
::       Jeszcze GROPS
         GROPS.index('GROP');
         GROPS.prefix(GROP.ref());
         {? GROPS.first()
         || {!
            |? _ilw:=0;
               {! _it:=_rok1.._rok2
               |! _rok:=form(_it,-4,,'0')+2;
                  ZLGD.use('zlgd_'+_oddzial+_rok);
                  ZLGD.index('GROPS');
                  ZLGD.prefix(GROPS.ref());
                  {? ZLGD.first()
                  || {!
                     |? _ilw+=ZLGD.IL;
                        ZLGD.next()
                     !}
                  ?}
               !};
               GROPS.ILW:=_ilw;
               GROPS.put();
               GROPS.next()
            !}
         ?};
         {? _ref=null() || GROP.next() || 0 ?}
      !};
      {? _prg>0 || FUN.prg_stop() ?}
   ?};
   GROP.cntx_pop(); GROPS.cntx_pop(); GROPP.cntx_pop(); ZLGD.cntx_pop()
?};
1


\update_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Trigery obsługujące pola tabeli GROP na podstawie ZLGD
::   WE: _a - rodzaj trigera: 'add', 'put', 'del'
::----------------------------------------------------------------------------------------------------------------------
{? _a='add'
|| _before:=0; _after:=ZLGD.IL; _grop:=ZLGD.GROP; _potw:=ZLGD.POTW='T'; _ilpotw:=_after
|? _a='put'
|| _before:=bfld('IL'); _after:=ZLGD.IL; _grop:=ZLGD.GROP; _potw:=bfld('POTW')<>ZLGD.POTW;
   _ilpotw:={? ZLGD.POTW='T' || 1 || -1 ?}*_after
|? _a='del'
|| _before:=bfld('IL'); _after:=0; _grop:=bfld('GROP'); _potw:=bfld('POTW')='T'; _ilpotw:=_before*(-1)
?};
{? _grop
|| GROP.cntx_psh();
   GROP.prefix();
   {? GROP.seek(_grop)
   ||
::    Jeżeli grupa operacyjna umieszczona w planie operacyjnym to pola będą nawijane w trigerach dla PL_OGR
      {? GROP.ILP=0
      || GROP.ILW+=_after-_before;
         GROP.CZY_WYK:={? GROP.ILW>=GROP.IL || 'T' || 'N' ?};
         {? _potw>0
         || GROP.ILPOTW+=_ilpotw;
            GROP.CZY_POTW:={? GROP.ILPOTW>=GROP.IL || 'T' || 'N' ?}
         ?}
      ?};
      GROP.put()
   ?};
   GROP.cntx_pop()
?};
~~


\doc_4zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Informacja o dokumentach wyswietlana z poziomu grupy operacji
::       Kontekst pracy: GROP
::----------------------------------------------------------------------------------------------------------------------
exec('GROP','tech_doc');
~~


\env
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Środowisko selektora GROP
::----------------------------------------------------------------------------------------------------------------------
_env:=obj_new('GROP_IL');
_env.GROP_IL:=0;
_env


\clFiltrGrOp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.30]
:: OPIS: wyczyszczenie filtra operacji grupowych
::  OLD: \clFiltrGrOp/gr_oper.fml
::  OLD: \clFiltrGrOp/po_ogr.fml
::----------------------------------------------------------------------------------------------------------------------
VGROP.FLTR_RES:=null();
VGROP.USERS:=null();
VGROP.TTOPER:=null();
VGROP.STATUS:='O';
~~


\update_grops
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Trigery obsługujące pola tabeli GROPS na podstawie ZLGD
::   WE: _a - rodzaj trigera: 'add', 'put', 'del'
::----------------------------------------------------------------------------------------------------------------------
{? _a='add'
|| _before:=0; _after:=ZLGD.IL; _grops:=ZLGD.GROPS
|? _a='put'
|| _before:=bfld('IL'); _after:=ZLGD.IL; _grops:=ZLGD.GROPS
|? _a='del'
|| _before:=bfld('IL'); _after:=0; _grops:=bfld('GROPS')
?};
{? _grops
|| GROPS.cntx_psh();
   GROPS.prefix();
   {? GROPS.seek(_grops)
   || GROPS.ILW+=_after-_before;
      GROPS.put()
   ?};
   GROPS.cntx_pop()
?};
~~


\plan_grop_prodrej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Akcja planowania grup operacji wołana z poziomu rejestracji wykonań (PROD_REJ)
::----------------------------------------------------------------------------------------------------------------------
{? PROD_REJ.GROP=null()
|| FUN.info('Funkcja dostępna tylko dla grup operacji.'@)
|| _grop:=PROD_REJ.GROP;
   _grops:=PROD_REJ.GROPS;
   {? exec('plan_grop','zl_grop',PROD_REJ.GROP)
   ||
::    Trochę kombinacji, żeby kursor stanął na tym samym rekordzie,
::    a jak go nie ma, to na rekordzie dot. tej samej grupy
      PROD_REJ.f_rfresh();

::      GROPS.cntx_psh();
::      GROPS.index('GROP');
::      GROPS.prefix(PROD_REJ.GROP);
::      {? GROPS.first()
::      || {!
::         |? PROD_REJ.blank(1);
::            PROD_REJ.GROPS:=GROPS.ref();
::            {? PROD_REJ.find_rec() || PROD_REJ.f_add() ?};
::            GROPS.next()
::         !}
::      ?};
::      GROPS.cntx_pop();

      PROD_REJ.blank(1);
      PROD_REJ.GROPS:=PROD_REJ.GROPS;
      {? ~PROD_REJ.find_rec()
      || PROD_REJ.GROPS:=null();
         PROD_REJ.GROP:=PROD_REJ.GROP;
         PROD_REJ.find_rec()
      ?}
   ?}
?}


\plan_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Akcja planowania grup operacji wołana z poziomu GROP
::   WE: _a - GROP.ref()
::   WY: 0/1 - czy potwierdzono planowanie
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null()) & _a<>null() || _grop:=_a || return() ?};

_result:=0;

GROP.cntx_psh();
{? GROP.seek(_grop)
|| {? GROP.AKC<>'T'
   || {? VAR.GRUPA='T'
      || KOMM.add('Grupa operacji \'%1\' nie jest zaakceptowana — nie można planować.'@[GROP.KOD])
      || FUN.info('Grupa operacji nie jest zaakceptowana — nie można planować.'@)
      ?}
   |? exec('get','#params',500390,type_of(''))='T'
   ||
      _args:=exec('mp_run_a','#b__box');
      _args.ACT_UID:='TPP_PPS_DOPL';

      _args.CONTEXT:=obj_new('RESULT','ZK_P','DEST','TRANSFORMED','VER_QUE');
      _args.CONTEXT.RESULT:=0;
      _args.CONTEXT.ZK_P:=null();
      _args.CONTEXT.DEST:=null();
      _args.CONTEXT.TRANSFORMED:=0;
      _args.CONTEXT.VER_QUE:=null();
      _args.GRUPA:=VAR.GRUPA;
      PX_VAR.VER_QUE:=exec('get_mainversion','px_ver');
      {? exec('is_one_version','px_param')=0
      || _args.CONTEXT.VER_QUE:=exec('get_mainversion','px_ver')
      ?};
      _args.AKCJA:='PLANUJ_GROP';

      _args.UIDREF:=GROP.uidref();
      _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
      exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'GROP',GROP.ref);
      exec('mp_run','#b__box',_args)
   |? VAR.GRUPA='T' & GROP.CZY_PLAN='T'
   || KOMM.add('Grupa operacji \'%1\' została już w całości zaplanowana.'@[GROP.KOD])
   ||
::    Rozpisanie ilości uruchomień na wskazane stanowiska
      GROPS.cntx_psh();
      _tab:=tab_tmp(1
         ,'KOD','STRING[10]','Kod'@
         ,'REF','STRING[16]','$GROPS.ref()'
         ,'CZAS','TIME','Czas'
         ,'OPIS','STRING[60]','Opis'@
         ,'IL','INTEGER','Ilość uruchomień'@
         ,'ILW','INTEGER','Ilość wykonana'@
         ,'PL_RES','STRING[60]','Zasób'@
      );
::    UWAGA: miała być podsuma ilości na "dzień dobry" ale się nie da, bo pole IL nie jest typu REAL
::    ’on’ - podsumowania będą dostępne w okienku.
::    Jeśli nie ma wcześniej odpisanej informacji o sumowanych polach w pliku *.ini,
::    to sumowane będą wszystkie pola typu REAL będące w definicji okienka.
      {? VAR.GRUPA<>'T'
      ||
         _wer:=_tab.mk_sel('Planowanie operacji grupowych'@,'P',,'plangrops1',,,,,'U',,,,,,,'on');
         _tab.win_fld(_wer,,'KOD');
         _tab.win_fld(_wer,,'PL_RES','SYM',,30,,,'Zasób'@);
         _tab.win_fld(_wer,,'CZAS',,,12);
         _tab.win_fld(_wer,,'IL',,,-11);
         _tab.win_fld(_wer,,'ILW',,,-11);
         _formula:="
            _tab:=cur_tab(1,1);
            _valid:=\"1\";
            _value:=exec('edit_number','#edit',_tab.IL,'Ilość uruchomień'@,0,_tab.ILW,,_valid);
            {? type_of(_value)=type_of(0)
            || _tab.IL:=_value;
               _tab.put()
            ?}
         ";
         _tab.win_act(_wer,,'Formuła','Popraw'@@,,,_formula,,1,,,,'P');
         _formula:="
            _suma:=0;
            _tab:=cur_tab(1,1);
            _tab.cntx_psh();
            {? _tab.first()
            || {!
               |? _suma+=_tab.IL;
                  _tab.next()
               !}
            ?};
            _tab.cntx_pop();
            {? _suma>GROP.IL
            || FUN.info(
                  'Suma ilości uruchomień na poszczególnych zasobach (%1)\n'
                  'nie może być większa niż planowana dla grupy operacji (%2).'@
                  [$_suma,$GROP.IL]
               )
            || sel_exit()
            ?};
            ~~
         ";
         _tab.win_act(_wer,,'Formuła','Zatwierdź'@@,,,_formula,,,,,,'Z',,'target=window');
         _tab.win_btn(_wer,'text=%1,panel=bottom,align=end'['Zatwierdź'@],'menu:Z');
         _tab.win_btn(_wer,'text=%1,panel=bottom,align=end'['Anuluj'@],'key:Esc');
         _tab.win_sel(_wer)
      ?};

      GROPS.index('GROP');
      GROPS.prefix(GROP.ref());
      {? GROPS.size()<2
      || {? VAR.GRUPA='T'
         || KOMM.add('Do grupy operacji \'%1\' przypisane jest tylko jedno stanowisko — nie ma potrzeby planowania.'@
               [GROP.KOD])
         || FUN.info('Do grupy operacji przypisane jest tylko jedno stanowisko — nie ma potrzeby planowania.'@)
         ?}
      ||
::       Czy dany zasób jest przypisany do grupy (grupowe planowanie)
         _jest:={? VAR.GRUPA='T' || 0 || 1 ?};
         {? GROPS.first()
         || {!
            |? _tab.KOD:=GROPS.KOD;
               _tab.REF:=$GROPS.ref();
               _tab.OPIS:=GROPS.OPIS;
               _tab.CZAS:=GROPS.CZAS;
               _tab.IL:={? GROPS.PLAN='T' || GROPS.IL || 0 ?};
               _tab.ILW:=GROPS.ILW;
               _tab.PL_RES:=GROPS.PL_RES().SYM;
               {? GROPS.PL_RES=VGROP.PLAN_RES
               || _jest:=1;
                  {? VAR.GRUPA='T'
                  ||
::                   Przy grupowym planowaniu przypisywana jest pozostała ilość do zaplanowania
                     _tab.IL+=GROP.IL-GROP.ILPS
                  ?}
               ?};
               _tab.add();
               GROPS.next()
            !}
         ?};
         {? _jest>0
         ||
            {? VAR.GRUPA='T' | _tab.select()
            || _result:=1;
               _plan:=0;
               _ilps:=0;
               {? _tab.first()
               || {!
                  |? {? GROPS.seek(_tab.REF)
                     || GROPS.IL:=_tab.IL;
                        _ilps+=_tab.IL;
                        {? _tab.IL=0 || GROPS.PLAN:='N' || GROPS.PLAN:='T'; _plan:=1 ?};
                        GROPS.put()
                     ?};
                     _tab.next()
                  !}
               ?};
               {? _plan=0
               || {? GROPS.first()
                  || GROPS.PLAN:='N';
                     GROPS.IL:=GROP.IL;
                     GROPS.put()
                  ?}
               ?};
               GROP.ILPS:=_ilps;
               GROP.CZY_PLAN:={? GROP.ILPS>=GROP.IL || 'T' || 'N' ?};
               GROP.put()
            ?}
         || {? VAR.GRUPA='T'
            || KOMM.add('Grupa operacji \'%1\' nie ma przypisanego zasobu \'%2\''@[GROP.KOD,VGROP.PLAN_RES().SYM])
            || FUN.info('Grupa operacji nie ma przypisanego zasobu \'%1\'.'@[VGROP.PLAN_RES().SYM])
            ?}
         ?}
      ?};

      GROPS.cntx_pop()
   ?}
?};

GROP.cntx_pop();
_result


\plan_grop_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja planowania grup operacji wołana z poziomu GROP - przed grupą rekordów
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_can_continue:=1;

{? exec('get','#params',500390,type_of(''))='T'
||
   PX_VAR.GROP:=null();
   PX_VAR.GROPS:=null();
   PX_VAR.PL_RESGG:=null();
   KOMM.init(255,,'Planowanie operacji grupowych'@);
   VAR.GRUPA:='T';
   sel_nchk();
   _to_que:=tab_tmp(1,
      'REF','INTEGER','Ref',
      'CRC','INTEGER','Crc');
   _grop:=GROP.sel_aget();
   GROP.cntx_psh(); GROP.prefix();
   {? _grop.first()
   || {!
      |? {? GROP.seek(_grop.REF,)
         || _px_obj:=exec('get_grop_object','px_obj',GROP.ref());
            {? _px_obj<>null()
            || _to_que.blank();
               _to_que.REF:=#_px_obj;
               _to_que.add()
            ?}
         ?};
         _grop.next()
      !}
   ?};
   GROP.cntx_pop();

   _predivision_tab:=exec('predivision_group','px_grop',_to_que);
   {? type_of(_predivision_tab)>0
   || _ndx:=_predivision_tab.ndx_tmp(,,'SELECTED',,);
      _predivision_tab.index(_ndx);
      _predivision_tab.prefix('T');
      {? _predivision_tab.first()
      || PX_VAR.PL_RESGG:=exec('FindAndGet','#table',PL_RES,_predivision_tab.PL_RES,,,null())
      ?};
      _predivision_tab.ndx_drop(_ndx)
   || _can_continue:=0
   ?};

   _mainver:=exec('get_mainversion','px_ver');
   {? _can_continue>0
   || _can_continue:=exec('to_queue_ctrl','px_grp',_to_que,_mainver,null(),1,,2)
   ?};

   {? _can_continue>0
   || _can_continue:=exec('to_queue_edit','px_grp',_to_que,_mainver,null(),1)
   ?};

   {? PX_VAR.AGR='T'
   || PX_VAR.AGR_UID:=exec('uid','#blank')
   ?};
   {? _can_continue>0
   || _result:=1
   || VAR.GRUPA:='N';
      KOMM.select()
   ?}
||
   _win:=VGROP.mk_edit('Planowanie operacji grupowych'@);
   VGROP.win_efld(_win,,'PLAN_RES','SYM','*',30,,0,'Zasób'@);
   VGROP.win_efld(_win,,'PLAN_RES','NAZ',,30,,1,' ');
   VGROP.efld_opt(_win,'mark=1',VGROP,'PLAN_RES','SYM');
   exec('ok_esc','#window',VGROP,_win);
   VGROP.win_edit(_win);

:: Zebranie refów zaznaczonych grup operacji
   GROP.cntx_psh();
   GROP.clear();
   _tab_sel:=GROP.sel_aget();
   _refs:=tab_tmp(,'REF','STRING[16]','GROP.ref()');
   {? _tab_sel.first()
   || {!
      |?
         {? GROP.seek(_tab_sel.REF)
         || _refs.REF:=$GROP.ref();
            _refs.add()
         ?};
         _tab_sel.next()
      !}
   ?};
   GROP.cntx_pop();

:: Ustawienie filtru na zasoby planistyczne
   _sort:='SYM';
   _from:='join GROPS using (GROPS.PL_RES,PL_RES.REFERENCE) join GROP using (GROPS.GROP,GROP.REFERENCE)';
   _where:='GROP.REFERENCE in (select REF from :_a)';
   PL_RES.f_set(_sort,_from,_where,_refs);

   {? PL_RES.f_size()=0
   || FUN.info('Nie przypisano żadnych zasobów do wybranych grup operacji.'@)
   || {? PL_RES.f_size()=1
      || PL_RES.f_first();
         VGROP.PLAN_RES:=PL_RES.ref()
      || VGROP.PLAN_RES:=null()
      ?};
      _valid:="
         _res:=__CHK.record2(VGROP,'PLAN_RES','Zasób'@);
         _res
      ";
      {? VGROP.edit(_valid)
      || sel_nchk();
         VAR.GRUPA:='T';
         KOMM.init(255,,'Planowanie operacji grupowych'@);
         _result:=1
      ?}
   ?};
:: Przywrócenie filtru na PL_RES
   exec('filtrPlResGr','zl_grop')
?};
_result


\plan_grop_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja planowania grup operacji wołana z poziomu GROP - po grupie rekordów
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
PX_VAR.GROP:=null();
PX_VAR.GROPS:=null();
PX_VAR.PL_RESGG:=null();
KOMM.select();
~~


\dir_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Aktualizuje zwrot planowania dla grupy
::   WE: [_a] - GROP.ref() lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(GROP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

GROP.cntx_psh();
{? _ref<>null()
|| GROP.prefix();
   {? GROP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| GROPP.cntx_psh();
   GROPP.index('GROP');
   GROPP.prefix(GROP.ref());
   _dir:=0;
   {? GROPP.first()
   || {!
      |? {? GROPP.ZL<>null()
         || _dir:=GROPP.ZL().PL_DIR
         ?};
         GROPP.next() & _dir=0
      !}
   ?};

   {? _dir<>0
   || GROP.DIR:=_dir;
      _can_continue:=GROP.put()
   ?};
   GROPP.cntx_pop()
?};
GROP.cntx_pop();
GROP.get();
{? _can_continue>0
|| _result:=1
?};
_result


\termin_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Aktualizuje termin realizacji dla grupy
::   WE: [_a] - GROP.ref() lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(GROP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

GROP.cntx_psh();
{? _ref<>null()
|| GROP.prefix();
   {? GROP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| GROPP.cntx_psh();
   GROPP.index('GROP');
   GROPP.prefix(GROP.ref());
   _tm_rea:=0;
   {? GROPP.first()
   || {!
      |? {? GROPP.ZL<>null()
         || _pl_time:=exec('create','#tm_stamp',GROPP.ZL().PL_DATA,ZL.PL_TIME);

            {? _tm_rea=0 | _tm_rea>_pl_time
            || _tm_rea:=_pl_time
            ?}
         ?};
         GROPP.next()
      !}
   ?};
   {? _tm_rea<>0
   || GROP.TM_REA:=_tm_rea;
      GROP.PL_DATA:=exec('tm_stamp2date','#tm_stamp',_tm_rea);
      GROP.PL_TIME:=exec('tm_stamp2time','#tm_stamp',_tm_rea);
      _can_continue:=GROP.put();
      {? _can_continue>0
      || exec('zlim_dates_upd','zl_limit',null(),GROP.ref())
      ?};
      {? _can_continue>0 & exec('get','#params',500390,type_of(''))='T'
      || exec('grop2obj','px_obj')
      ?}
   ?};
   GROPP.cntx_pop()
?};
GROP.cntx_pop();
GROP.get();
{? _can_continue>0
|| _result:=1
?};
_result


\grop_deleted_in_proc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Obsługa sytuacji że jest czynność na liście todo a grupa została usunięta
::   WE: _a - obj_new - obiekt Menadżera Procesów
::       [_b] - INTEGER - 0/[1] - czy errorować proces, jeżeli 0 to jest robiony .done()
::       [_c] - INTEGER - 0 - zamknięte, [1] - usunięte
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_mp:=_a;

_error:=1;
{? var_pres('_b')=type_of(0)
|| _error:=_b
?};
_deleted:=1;
{? var_pres('_c')=type_of(0)
|| _deleted:=_c
?};

{? _deleted>0
|| _msg:=exec('grop_deleted_msg','zl_grop')
|| _msg:=exec('grop_closed_msg','zl_grop')
?};
{? _mp.isService()=0 & _mp.CLEANER=0
|| FUN.emsg(_msg)
?};
{? _error>0
|| _mp.error(_msg)
|| _mp.done()
?};
~~


\grop_deleted_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Komunikat o usunięciu grupy operacji
::----------------------------------------------------------------------------------------------------------------------
'Grupa operacji nie została odnaleziona, prawdopodobnie została usunięta.'@@


\grop_closed_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Komunikat o zamknięciu grupy operacji
::----------------------------------------------------------------------------------------------------------------------
'Grupa operacji jest zamknięta — czynność zostanie zakończona.'@@


\chk_grop_oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy grupa operacji we wszystkich składowych zleceniach znajduje się na
::       początku czy końcu procesu technologicznego
::   WE: [_a] - GROP.ref() grupa operacji lub bieżący rekord
::   WY: 'P' - początek procesu technologicznego
::       'K' - koniec procesu technologicznego
::       'PK' - początek i koniec procesu technologicznego, czyli operacja grupowa jest jedyna w procesie
::       'X' - środek procesu technologicznego
::       'Z' - raz początek, raz koniec procesu technologicznego
::             (kilka zleceń z różną tech. w których grupowa jest raz na końcu raz na początku)
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(GROP.ref())
|| _ref:=_a
?};

_result:='';
_can_continue:=1;

GROP.cntx_psh();
{? _ref<>null()
|| GROP.prefix();
   {? GROP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| GROPP.cntx_psh();
   NASZGP.cntx_psh();
   ZGP.cntx_psh();
   GROPP.index('GROP');
   GROPP.prefix(GROP.ref());
   {? GROPP.first()
   || {!
      |? {? GROPP.ZGP<>null()
         ||
::          Sprawdzam czy przewodnik ma poprzedniki
            _poprzedniki:=0;
             NASZGP.index('NASTOP');
             NASZGP.prefix(GROPP.ZGP);
             {? NASZGP.first()
             || _poprzedniki:=1
             ?};

             _nastepniki:=0;
             NASZGP.index('OPNAST');
             NASZGP.prefix(GROPP.ZGP);
             {? NASZGP.first()
             || _nastepniki:=1
             ?};

             {? _poprzedniki=0 & _nastepniki>0
             || {? _result='' | _result*'P'>0
                || _result:='P'
                || _result:='Z'
                ?}
             |? _poprzedniki>0 & _nastepniki=0
             || {? _result='' | _result*'K'>0
                || _result:='K'
                || _result:='Z'
                ?}
             |? _poprzedniki=0 & _nastepniki=0
             || {? _result=''
                || _result:='PK'
                ?}
             |? _poprzedniki>0 & _nastepniki>0
             || _result:='X'
             ?}
         ?};
         GROPP.next() & _result<>'X' & _result<>'Z'
      !}
   ?};
   ZGP.cntx_pop();
   GROPP.cntx_pop();
   NASZGP.cntx_pop();
   ~~
?};
GROP.cntx_pop();
_result


\is_grop_member
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy zlecenie ma jakąś operację która została zgrupowana
::   WE: [_a] - ZL.ref() lub bieżący rekord
::   WY: 0 - zlecenie nie zostało zgrupowane
::       1 - zlecenie jest w przynajmniej jednej grupie
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: jesli zlecenie zlozone to rekurencyjnie sprawdzam podzlecenia
   {? ZL.RODZAJ<>'P'
   || ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |?
::          !!! REKURENCJA !!!
            _result:=exec('is_grop_member','zl_grop');
            ZL.next() & _result=0
         !}
      ?}
   || GROP.cntx_psh();
      GROPP.cntx_psh();
      GROPP.index('ZGP');
      ZGH.cntx_psh();
      ZGP.cntx_psh();
      ZGP.index('PNRPP');
      ZGH.index('ZLNR');
      ZGH.prefix(ZL.ref());
      {? ZGH.first()
      || {!
         |? ZGP.prefix(ZGH.ref());
            {? ZGP.first()
            || {!
               |? GROPP.prefix(ZGP.ref());
                  {? GROPP.first() & GROPP.GROP().AKC='T'
                  || _result:=1;
                     _can_continue:=0
                  ?};
                  ZGP.next() & _can_continue>0
               !}
            ?};
            ZGH.next() & _can_continue>0
         !}
      ?};
      ZGP.cntx_pop();
      ZGH.cntx_pop();
      GROPP.cntx_pop();
      GROP.cntx_pop();
      ~~
   ?}

?};
ZL.cntx_pop();
_result


\is_grop_member_planned
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy zlecenie ma jakąś operację która została zgrupowana i ta grupa jest w planie
::   WE: [_a] - ZL.ref() lub bieżący rekord
::   WY: 0 - zlecenie nie zostało zaplanowane w grupach
::       1 - zlecenie jest zaplanowane w przynajmniej jednej grupie
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: jesli zlecenie zlozone to rekurencyjnie sprawdzam podzlecenia
   {? ZL.RODZAJ<>'P'
   || ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |?
::          !!! REKURENCJA !!!
            _result:=exec('is_grop_member_planned','zl_grop');
            ZL.next() & _result=0
         !}
      ?}
   || GROP.cntx_psh();
      GROPP.cntx_psh();
      GROPP.index('ZL');
      GROPP.prefix(ZL.ref());
      {? GROPP.first()
      || {!
         |? {? GROPP.GROP().PLAN_PX='T'
            || _result:=1;
               _can_continue:=0
            ?};
            GROPP.next() & _can_continue>0
         !}
      ?};
      GROPP.cntx_pop();
      GROP.cntx_pop();
      ~~
   ?}
?};
ZL.cntx_pop();
_result


\get_times_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Wypełnia czasy minimalnego startu/maksymalnego końca dla ZGP w oparciu o plan grup operacji
::       w których znajduje się ten ZGP
::   WE: [_a] - ZGP.ref() lub bieżący rekord
::       _b - INTEGER - 1: wyznaczyć czasy końca planu grup
::                      2: wyznaczyć czasy początków planu grup
::       _c - tab_tmp - tabelka którą wypełnić
::       _d - PX_VER.ref() - wersja planu
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};
_mode:=_b;
_times:=_c;
_px_ver:=_d;

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
{? _ref<>null()
|| ZGP.prefix();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_GRP.cntx_psh();
   PX_GRP.index('GROPS');
   GROPP.cntx_psh();
   GROPP.index('ZGP');
   GROP.cntx_psh();
   GROPS.cntx_psh();
   GROPS.index('GROP');

   GROPP.prefix(ZGP.ref());
   {? GROPP.first()
   || {!
      |? GROPS.prefix(GROPP.GROP);
         {? GROPS.first()
         || {!
            |? PX_GRP.prefix(_px_ver,GROPS.ref());
               {? PX_GRP.first()
               || {!
                  |? {? _mode=1
                     || _tm_stamp:=exec('get_plan_end','px_grp');
                        {? _tm_stamp>0
                        || _times.blank();
                           _times.TM:=_tm_stamp;
                           _times.add()
                        ?}
                     |? _mode=2
                     || _tm_stamp:=exec('get_plan_start','px_grp');
                        {? _tm_stamp>0
                        || _times.blank();
                           _times.TM:=_tm_stamp;
                           _times.add()
                        ?}
                     ?};
                     PX_GRP.next()
                  !}
               ?};
               GROPS.next()
            !}
         ?};
         GROPP.next()
      !}
   ?};
   GROPS.cntx_pop();
   GROP.cntx_pop();
   GROPP.cntx_pop();
   PX_GRP.cntx_pop();
   ~~
?};
ZGP.cntx_pop();
_times.prefix();
~~


\plan_restore_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Odtwarza ilości planowane na GROPS w danym GROP na podstawie zapisów w planie strategicznym
::       UWAGA: nie może być mniej niż aktualnie wykonane
::   WE: _a - GROP.ref()
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;

GROP.cntx_psh(); GROPS.cntx_psh(); PX_GRP.cntx_psh();
GROP.prefix();
{? GROP.seek(_grop)
|| _ilps:=0;
   GROPS.index('GROP');
   GROPS.prefix(GROP.ref());
   {? GROPS.first()
   || {!
      |? _il:=0;
         PX_GRP.index('GROPS');
         PX_GRP.prefix(exec('get_mainversion','px_ver'),GROPS.ref());
         {? PX_GRP.first()
         || {!
            |? _il+=PX_GRP.ILOSC;
               PX_GRP.next()
            !}
         ?};

         _il:={? _il<GROPS.ILW || GROPS.ILW || _il ?};
         _ilps+=_il;

         {? _il=0
         || GROPS.IL:=0;
            GROPS.PLAN:='N'
         || GROPS.IL:=_il;
            GROPS.PLAN:='T'
         ?};
         GROPS.put();
         GROPS.next()
      !}
   ?};
   GROP.ILPS:=_ilps;
   GROP.put()
?};
GROP.cntx_pop(); GROPS.cntx_pop(); PX_GRP.cntx_pop();
~~


\delete_grop_plan_when_close
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Próbuje usunąć wszystkie grupy z planów produkcji w którym występuje zamykane zlecenie
::   WE: [_a] - ZL.ref() lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? ZL.RODZAJ<>'P'
   || ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |?
::          !!! REKURENCJA !!!
            _result:=exec('delete_grop_plan_when_close','zl_grop');
            ZL.next() & _result=0
         !}
      ?}
   ||
      _del_plan:=exec('get','#params',500391)='T';
      {? _del_plan>0
      ||
         _ref_table:=exec('ref_table','#table');
         GROPP.cntx_psh();
         GROPP.index('ZL');
         GROPP.prefix(ZL.ref());
         {? GROPP.first()
         || {!
            |? _ref_table.add(GROPP.GROP);
               GROPP.next()
            !}
         ?};
         GROPP.cntx_pop();

         GROP.cntx_psh();
         _tab:=_ref_table.tab;
         _tab.prefix();
         {? _tab.first()
         || {!
            |? GROP.prefix();
               {? GROP.seek(_tab.SQL)
               || _can_continue:=exec('delete_plan','px_grop',,1,1,0)
               ?};
               _tab.next()
            !}
         ?};
         GROP.cntx_pop()
      ?}
   ?}
?};
ZL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\parses
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Parametry pracy w obszarze roboczym grup operacji
::----------------------------------------------------------------------------------------------------------------------
__PARSES.editPar('OkresRok','OddzialLogProd','Magazyn');
exec('grop_f_set','zl_grop');
AreaTitle.setTitle();
~~


\grop_f_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Przeładowanie filtra operacji grupowych
::----------------------------------------------------------------------------------------------------------------------
_where:=
   '1=1'+
   {? VGROP.STATUS<>'W' || ' and GROP.STATUS=\':_a\'' || '' ?}+
   {? VGROP.FLTR_RES<>null() || ' and GROPS.PL_RES=:_b' || '' ?}+
   {? VGROP.USERS<>null() || ' and GROP.USERS=:_c' || '' ?}+
   {? VGROP.TTOPER<>null() || ' and GROP.TTOPER=:_d' || '' ?}+
   ' and GROP.ODDZ=\':_e\'';

GROP.f_set('STATUS,DATA,KOD','left join GROPS using(GROP.REFERENCE,GROPS.GROP)',_where,
   VGROP.STATUS,VGROP.FLTR_RES,VGROP.USERS,VGROP.TTOPER,ST.ODDZ
)


\find_zlgd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Wyszukuje wykonania produkcji do grupy operacji w celu ustalenia listy surowców/odpadów do rozliczenia
::----------------------------------------------------------------------------------------------------------------------
_env_gen:=__ENV_GEN;
params_set('env_gen',_env_gen);
_gen:=_env_gen.GEN;

_buf_matr:=~~;
{? _gen='ODP_GROP'
|| _buf_matr:=exec('buffer','mat_atr')
?};

{? _gen='NLI_GROP' & ~exec('czy_sa_nielimity_grop','zl_nlimit',GROP.ref(),0)
|| KOMM.add('Grupa operacji %1 nie ma zdefiniowanych surowców nielimitowanych.'@[GROP.KOD]);
   return()
|? _gen='ODP_GROP' & ~exec('czy_sa_odpady_grop','zl_nlimit',GROP.ref())
|| KOMM.add('Grupa operacji %1 nie ma zdefiniowanych odpadów/koproduktów.'@[GROP.KOD]);
   return()
?};

_dk:=_env_gen.DK.TAB;
_dk_ndxref:=_env_gen.DK.NDXREF;
_dk_ndxzl:=_env_gen.DK.NDXZL;
_sur_ndxscean:=_env_gen.SUR.NDXSCEAN;
_sur:=_env_gen.SUR.TAB;
_sur.cntx_psh();
_sur.index(_sur_ndxscean);
_sur.prefix();

:: ZASILENIE
:: - załadowanie tabeli _dk (do czego rozliczamy)
:: - załadowanie tabeli _sur (co rozliczamy)
ZLGD.cntx_psh(); ZLIM.cntx_psh();
ZLGD.index('GROP');
ZLGD.prefix(GROP.ref());
{? ZLGD.first()
|| {!
   |? {? (_gen='NLI_GROP' & ~exec('rozliczone','zl_grop',ZLGD.ref(),'N')) |
         (_gen='ODP_GROP' & ~exec('rozliczone','zl_grop',ZLGD.ref(),'T'))
      ||
         _dk.index(_dk_ndxref);
         _dk.prefix($ZLGD.ref());
         {? ~_dk.first()
         || _dk.blank(1);
            _dk.ZLEC:=GROP.KOD;
            _dk.IL:=ZLGD.IL+ZLGD.IL_BRAK+ZLGD.DEK_IL+ZLGD.DEK_BR;
            _dk.DT:=ZLGD.DT;
            _dk.REF:=$ZLGD.ref();
            _dk.O:=GROP.OPIS;
            _dk.PRAC:={? ZLGD.BP='B' || ZLGD.B().KOD || ZLGD.P().OSOBA().NAZWISKO + ' ' + ZLGD.P().OSOBA().PIERWSZE ?};
            _dk.GROP_REF:=$GROP.ref();
            _dk.add()
         ?};
         exec('sur_ra','zl_grop',GROP.ref())
      ?};

      ZLGD.next()
   !}
?};
ZLGD.cntx_pop(); ZLIM.cntx_pop();
_sur.cntx_pop();
~~


\dok_mag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Wyświetla dokumenty magazynowe wystawione do grupy operacji
::----------------------------------------------------------------------------------------------------------------------
VAR.A_GROP:=GROP.ref();
exec('zlst_dok','magdok_prod',1);
~~


\rozliczone
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Sprawdza, czy do danego wykonania dla grupy operacji zostały już wygenerowane dokumenty rozliczające (DK)
::   WE: _a - ZLGD.ref()
::       _b - przychodowe 'T', rozchodowe 'N'
::   WY: 0 (brak dokumentów rozliczających) / 1 (są dokumenty rozliczające)
::----------------------------------------------------------------------------------------------------------------------
_zlgd:=_a;
_name:=ref_name(_a)+3;

_rozliczone:=0;

DK.cntx_psh();
DK.use('dokma%1'[_name]);
DK.index('DOKGROP');
DK.prefix(exec('FindAndGet','#table',ZLGD,_zlgd,,"ZLGD.GROP",null()));
{? DK.first()
|| {!
   |? {? DK.PLUS=_b & DK.ZLGD=_zlgd
      || _rozliczone:=1
      ?};
      DK.next()
   !}
?};
DK.cntx_pop();

_rozliczone


\grop_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Wyświetla dane grupy operacji
::----------------------------------------------------------------------------------------------------------------------
exec('setGropsInfo','zl_grop');
exec('grop_efld_opt','zl_grop');

GROP.win_edit('RED');
GROP.display();
~~


\chk_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Sprawdza, czy dla danego zlecenia są powiązane pozycje w grupach operacji
::   WE: _a - ZL.ref()
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_res:=0;

GROPP.cntx_psh();
GROPP.index('ZL');
GROPP.prefix(_a);
_res:=GROPP.first();
GROPP.cntx_pop();

_res


\find_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Wyszukuje surowce do rozliczenia dla grupy.
::       Kontekst wywołania - rekord tabeli GROP
::----------------------------------------------------------------------------------------------------------------------
_env_gen:=__ENV_GEN;
params_set('env_gen',_env_gen);
_gen:=_env_gen.GEN;

{? _gen='NLI_ZGROP' & ~exec('czy_sa_nielimity_grop','zl_nlimit',GROP.ref(),0)
|| KOMM.add('Grupa operacji %1 nie ma zdefiniowanych surowców nielimitowanych.'@[GROP.KOD]);
   return()
|? _gen='ODP_ZGROP' & ~exec('czy_sa_odpady_grop','zl_nlimit',GROP.ref())
|| KOMM.add('Grupa operacji %1 nie ma zdefiniowanych odpadów/koproduktów.'@[GROP.KOD]);
   return()
|? _gen='ZWR_GROP'
|| {? ~exec('grop_chk4lim','zl_limit',GROP.ref())
   || KOMM.add('Grupa %1 nie ma zdefiniowanych surowców limitowanych.'@[GROP.KOD]);
      return()
   |? exec('zl_chk4zw','magdok_prod',GROP.ref())
   || KOMM.add(
         'Do grupy %1 przypisane są niezaakceptowane dokumenty zwrotu surowców. '
         'Zalecana jest ich wcześniejsza obsługa.'@[GROP.KOD])
   ?}
?};

_ok:=1;

_dk:=_env_gen.DK.TAB;
_dk_ndxsym:=_env_gen.DK.NDXSYM;
_dk_ndxzl:=_env_gen.DK.NDXZL;
_sur:=_env_gen.SUR.TAB;
_top:=GROP.ref();
_top_sym:=GROP.KOD;

:: Dodanie rekordu nagłówka
_dk.blank(1);
_dk.ZLEC:=GROP.KOD;
_dk.IL:=GROP.IL;
_dk.ILWYK:=GROP.ILW;
_dk.DT:=GROP.DATA;
_dk.GROP_REF:=$GROP.ref();
_dk.O:=GROP.OPIS;
_dk.add();

:: ZASILENIE
{? _gen='ZWR_GROP'
||
:: Zwroty
   _ok:=exec('sur_ra_zwr','zl_nlimit',_top);
   {? _ok<=0
   ||
::    Brak surowców do zwrotu, usunięcie nagłówka zlecenia
      _dk.del()
   ?}
||
:: Odpady/nielimity
   _ok:=exec('sur_ra','zl_grop',GROP.ref());
   {? _ok<=0 || _dk.del() ?}
?};
~~


\sur_ra
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Surowce do generowania
::   WE: _a - GROP.ref()
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_env_gen:=params_get().env_gen;
_gen:=_env_gen.GEN;
_dk:=_env_gen.DK.TAB;
_sur:=_env_gen.SUR.TAB;
_gen:=_env_gen.GEN;
_zlim_tab:=_env_gen.ZLIM;
_chk_zlim:={? var_pres('_zlim_tab')>100 & _zlim_tab.size()>0 || 1 || 0 ?};
_grop:=_a;

_result:=0;

_mode_nlim:=(_gen*'NLI');
_mode_odp:=(_gen*'ODP');

_buf_matr:=~~;
{? _mode_odp>0
|| _buf_matr:=exec('buffer','mat_atr')
?};

GROP.cntx_psh();
GROP.clear();
{? _grop<>null() & GROP.seek(_grop)
|| ZLIM.cntx_psh();
   VAR.cntx_psh();
   VAR.A_GROP:=_grop;
   exec('openmask','zl_common',null(),GROP.ref());
   {? _mode_odp>0
   || ZLIM.index('GROPLSK');
      ZLIM.prefix(GROP.ref(),'T','O')
   || ZLIM.index('GROPKM');
      ZLIM.prefix(GROP.ref(),'N')
   ?};

   {? ZLIM.first()
   || {!
      |? {? (_mode_nlim>0 |  (ZLIM.SO='O' & ZLIM.KOR=0))
            & (_chk_zlim=0 | _zlim_tab.find_tab(,'REF',,'=',$ZLIM.ref()))
         || _result:=1;
            _sur.blank(1);
            _sur.REFDK:=#_dk.ref();
            _sur.MAT:=#ZLIM.KTM;
            _sur.ZLIM:=$ZLIM.ref();
            _sur.KTM:=ZLIM.KTM().KTM;
            _sur.NAZ:=M.N;
            _sur.JM:=M.J().KOD;
            _sur.ZPARN:=$ZLGD.ZPARN;
            _sur.PARSYM:=ZLGD.ZPARN().SYM;
            _sur.REJ_MAT:='N';
            _sur.ZL:=0;
            _sur.ZL_SYM:='';
            _sur.ZL_REF:='';
            _sur.WYD:=0;
            _sur.DK_C:=$ZLIM.DK_C;
            _sur.ZLEC:=0;
            _sur.ZLDOD:=0;
            _sur.MAG:=#ZLIM.MG;
            _sur.MAGNAME:=ZLIM.MG().NAZ;
            _sur.MAGSYM:=ZLIM.MG().SYM;
            _sur.AUTO:='T';
            _sur.ZGP:=0;
            _sur.ZGP_NAME:='';
            _sur.ZGP_OPIS:='';
            _sur.ZGH_IL:=0;
            _sur.RAP_IL:=0;
            _sur.RSC:='';
            _sur.SCEAN:='';
            _sur.EANL:='';
            _sur.GROP:=#GROP.ref();
            _sur.GROP_KOD:=GROP.KOD;
            _sur.GROP_OP:=GROP.OPIS;
            _dokl:=exec('jaka_dok_m','jm',ZLIM.KTM);
            _lil:={? _mode_odp>0 || exec('sum_il','zl_limit',ZLIM.ref()) || ZLIM.LIL ?};
            {? _gen*'ZGROP'>0
            || _il:=0
            || _ilosc:=GROP.IL;
               _il:={? _dokl>0
                    || (_lil*_dk.IL/_ilosc)$ _dokl
                    || ceil((_lil*_dk.IL/_ilosc))
                    ?}
            ?};
            _sur.ILOSC:=_il;
            _sur.ILL:=ZLIM.LIL;
            _sur.ILP:=ZLIM.IL_RW-ZLIM.IL_ZW;
            _sur.ILZ:=ZLIM.IL_ZW;
            _sur.ILR:=_sur.ILL-_sur.ILP;
            {? _sur.ILR<0 || _sur.ILR:=0 ?};
            _sur.M_ATR:={? _mode_odp>0 || $ZLIM.KTM().M_ATR || '' ?};
            _sur.ALL_SET:=1;
            {? _mode_odp>0
            ||
::             Obsługa cech dostaw dla odpadów
               _buf_matr.blank();
               {? _sur.M_ATR<>''
               || M_ATR.cntx_psh();
                  M_ATR.clear();
                  ZLIM.KTM().M_ATR();
                  _buf_matr.get_matr();
                  M_ATR.cntx_pop();

                  {? ZLIM.DK_C<>null()
                  || DK_C.cntx_psh();
                     DK_C.use(ref_name(ZLIM.DK_C));
                     ZLIM.DK_C();
                     _buf_matr.get_dkc();
                     DK_C.cntx_pop()
                  ?};
                  _buf_matr.set_tab(_sur);
                  _sur.ALL_SET:=_buf_matr.all_set()
               || _buf_matr.set_tab(_sur)
               ?}
            ||
::             Sprawdzenie, czy do surowca istnieją rezerwacje dedykowana do nielimitów
               {? exec('zlim_il_rez','zl_nlimit',$ZLIM.ref())>0
               || _sur.CZY_REZ:=1
               ?}
            ?};
            _sur.add()
         ?};
         ZLIM.next()
      !}
   ?};
   VAR.cntx_pop();
   ZLIM.cntx_pop()
?};
GROP.cntx_pop();
_result


\kontr_ilo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: kontrola rejestracji ilości na zasobach grupy operacji
::       Kontekst wywołania - ustawione VAR.A_GROP = GROP.ref()
::   WE: _a - T: analizować, N: nic nie robić
::       [_b] - parametr wywołania 'A','R','S'
::       [_c] - tabela z niezgodnościami w rejestracji, jeżeli podana to aktualizowane dane
::   WY: 0: ok, _tab: sa niezgodności w rejestracji
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')=type_of('') || _param:=_b || _param:='S' ?};
{? var_pres('_c')>100 || _aktu:=1; _tab_rob:=_c || _aktu:=0; _tab_rob:=~~ ?};

{? _a='T'
||
::----------------------------------------------------------------------------------------------------------------------
:: _tab - dane z przewodników
::----------------------------------------------------------------------------------------------------------------------
   _tab:=tab_tmp(2,
      'KOD','STRING[20]','Zasób grupy',
      'ZAS','STRING[60]','Zasób planistyczny',
      'IL','REAL','Ilość planowana',
      'ILW','REAL','Ilość zarejestrowana',
      'ZAK','STRING[1]','Zakończono wykonania',
      'POTW','STRING[1]','Potwierdzono wykonania',
      'DX','STRING[1]','Za dużo',
      'MX','STRING[1]','Za mało',
      'SX','STRING[1]','Status',
      'OX','STRING[20]','Status opisowo',
      'REF','STRING[16]','$GROPS.ref()'
   );
   GROPS.cntx_psh();
   GROPS.index('GROP');
   GROPS.prefix(VAR.A_GROP);
   {? GROPS.first()
   || PL_RES.cntx_psh();
      {!
      |?
         _tab.blank();
         _tab.REF:=$GROPS.ref();
         _tab.KOD:=GROPS.KOD;
         _tab.ZAS:=GROPS.PL_RES().SYM;
         _tab.IL:=GROPS.IL;
         _tab.ILW:=GROPS.ILW;
         {? var_pres('_grops_chk')>100 || obj_del(_grops_chk) ?};
         _grops_chk:=exec('grops_chk_zlgd','zl_grop',GROPS.ref());
         _tab.POTW:={? _grops_chk.POTW || 'T' || 'N' ?};
         _tab.ZAK:={? _grops_chk.ZAK || 'T' || 'N' ?};
         {? _tab.IL<>_tab.ILW | _tab.POTW='N' | _tab.ZAK='N'
         || {? _tab.IL<_tab.ILW
            || _tab.DX:='X';
               _tab.SX:='D';
               _tab.OX:='Przekroczenie'@
            |? _tab.IL>_tab.ILW
            || _tab.MX:='X';
               _tab.SX:='M';
               _tab.OX:='Niedobór'@
            || _tab.SX:='N';
               _tab.OX:='Zgodnie z planem'@
            ?};
            _tab.add()
         ?};
         {? var_pres('_grops_chk')>100 || obj_del(_grops_chk) ?};
         GROPS.next()
      !};
      PL_RES.cntx_pop()
   ?};
   GROPS.cntx_pop();
:: Przepisanie danych do tabeli docelowej w przypadku aktualizacji danych
   {? _aktu>0
   ||
::    Zapamiętanie refa, do którego ZGP wrócić
      _grops:=_tab_rob.REF;
      exec('tab2tab','#table',_tab,_tab_rob,0,1);
      _tab_rob.find_tab(,'REF',,'=',_grops)
   ?};
::----------------------------------------------------------------------------------------------------------------------
   {? _tab.first() & _aktu=0
   ||
      _wer:=_tab.mk_sel('Niezgodności rejestracji ilości wg zasobów grupy'@,'N',0,'grop2_ilo_sel',,,,,'U');
      _tab.win_fld(_wer,,'KOD',,,,,,'Zasób grupy'@);
      _tab.win_fld(_wer,,'ZAS',,,,,,'Zasób planistyczny'@);
      _tab.win_fld(_wer,,'IL',,,-15,4,,'Ilość planowana'@);
      _tab.win_fld(_wer,,'ILW',,,-15,4,,'Ilość zarejestrowana'@);
      _tab.win_fld(_wer,,'ZAK',,,-3,,,'Zakończone?'@,,'Czy zostały zakończone wszystkie wykonania',2,,"'T'","'N'");
      _tab.win_fld(_wer,,'POTW',,,-3,,,'Potwierdzone?'@,
         ,'Czy zostały potwierdzone wszystkie wykonania'@,2,,"'T'","'N'");
      _tab.win_fld(_wer,,'OX',,,20,,,'Status'@);
      _tab.win_act(_wer,0,'Rekord',,,,
         "{? cur_tab(1,1).IL=0 || Color.rekprzed('__TABX#02#01') || '' ?}"
      );
      {? _param='R'
      || _tab.win_act(_wer,,'Formuła','Zamknij grupę'@@,,'Zamknij grupę mimo niezgodności'@,"sel_exit()"
            ,,1,,,,'Z',,'target=window')
      ?};
      _before:="exec('rej_grop_pr','zl_grop')";
      _after:="exec('rej_grop_po','zl_grop'); exec('kontr_ilo','zl_grop','T',,cur_tab(1,1))";
      _tab.win_act(_wer,,'Formuła','Rejestracja wykonań'@@,,'Rejestracja wykonań produkcji'@
         ,_before,_after,,,,,'R',,'target=window');
      task_attach('TTE_WYK_DWZL');
      _formula:="params_set(params_get()); rep_exec('tte_rapzmkgr',,1)";
      _tab.win_act(_wer,,'Formuła','Druku&j'@@,,,_formula
         ,,{? _param='R' || 0 || 1 ?},,,,'J',,'target=window,icon=print');
      _tab.win_act(_wer,,'Formuła','Legenda'@@,,,"exec('legenda','color','__TABX#02#01')",,,,,,'L',,'target=window');
      _tab.win_btn(_wer,'text=%1,panel=bottom,align=begin'['Druku&j'@],'menu:J');
      {? _param='R'
      || _tab.win_btn(_wer,'text=%1,panel=bottom,align=end'['Zamknij grupę'@],'menu:Z')
      ?};
      _tab.win_sel(_wer);
      _red:=_tab.mk_edit('Ilości na zasobie grupy'@,0,'grop2_ilo_edit');
      _tab.win_esep(_red,'Zasób grupy'@);
      _tab.win_efld(_red,,'KOD',,,30,,,'Kod'@);
      _tab.win_efld(_red,,'ZAS',,,30,,,'Zasób planistyczny'@);
      _tab.win_esep(_red,'Rozliczenie'@);
      _tab.win_efld(_red,,'IL',,,,4,,'Ilość planowana'@);
      _tab.win_efld(_red,,'ILW',,,,4,,'Ilość zarejestrowana'@);
      _tab.win_efld(_red,,'SX',,,,,,'Status'@,,,'radio-buttons',,
         'Przekroczenie'@,"'D'",
::         'Zgodnie z planem'@,"'N'",
         'Niedobór'@,"'M'"
      );
      _tab.win_efld(_red,,'ZAK',,,,,,'Zakończone?'@,,,'check-box',
            'check_label="%1"'['Wszystkie rozpoczęte operacje zostały zakończone'@],"'T'","'N'"
         );
      _tab.win_efld(_red,,'POTW',,,,,,'Potwierdzone?'@,,,'check-box',
         'check_label="%1"'['Wszystkie rejestracje zostały potwierdzone'@],"'T'","'N'"
      );
      _tab.win_edit(_red);
::----------------------------------------------------------------------------------------------------------------------
:: Wynik formuły - jeśli są jakieś rekordy, to niedobrze
::----------------------------------------------------------------------------------------------------------------------
      _res:=obj_new(2);
      _res[1]:=_tab;
      _res[2]:=_wer;
      _res
   || 0
   ?}
|| 0
?}


\grops_chk_zlgd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Sprawdza czy do zasobu grupy operacji (GROPS) potwierdzono i zakończono wszystkie rejestracje wykonań prod.
::   WE: _a - GROPS.ref()
::   WY: obiekt _res z polami 'POTW' (potwierdzono) oraz 'ZAK' (zakończono), które przyjmują wartości 1/0,
::       gdzie 1 - ok, 0 - są niepotwierdzone/niezakończone rejestracje
::----------------------------------------------------------------------------------------------------------------------
_grops:={? var_pres('_a')=type_of(null()) || _a || null() ?};
_res:=obj_new('POTW','ZAK');
_res.POTW:=1;
_res.ZAK:=1;
GROPS.cntx_psh();
GROPS.prefix();
{? GROPS.seek(_grops)
||
:: Podczytanie GROP
   GROPS.GROP();
   _oddzial:=GROP.ODDZ;
   _rok1:=GROP.DATA~1;
   _rok2:=date()~1;
   _arok:=_rok1;
   ZLGD.cntx_psh();
   {!
   |?
      _rok:=form(_arok,-4,,'0')+2;
      ZLGD.use('zlgd_'+_oddzial+_rok);
      ZLGD.index('GROPS');
      ZLGD.prefix(GROPS.ref());
      {? ZLGD.first()
      || {!
         |?
            {? ZLGD.POTW='N'
            || _res.POTW:=0
            ?};
            {? ZLGD.ZAK='N'
            || _res.ZAK:=0
            ?};
            (_res.POTW>0 | _res.ZAK>0) & ZLGD.next()
         !}
      ?};
      _arok+=1;
      (_res.POTW>0 | _res.ZAK>0) & _arok<=_rok2
   !};
   ZLGD.cntx_pop()
?};
GROPS.cntx_pop();
_res


\grop_display_red_full
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Tworzy okienko redagowania zlecenia z przyciskami na pełny podgląd grupy operacji
::   WE: [_a] - czy dołączać dodatkowe przyciski dot. zamknięcia/kontroli grupy: [0]/1
::       [_b] - czy wywołane jako okno na wyświetl (display): [0]/1
::   WY: akronim okna
::----------------------------------------------------------------------------------------------------------------------
_add_zam:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_display:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_red:=GROP.mk_edit('Grupa operacji'@);

GROP.win_ewin(_red,,'RED');
GROP.win_ebtn(_red,'text=%1,align=begin,display=1'['Pozycje'@],"exec('gropp_select','zl_grop')");
GROP.win_ebtn(_red,'text=%1,align=begin,display=1'['Zasoby'@],"exec('grops_select','zl_grop')");
GROP.win_edit(_red);

{? _add_zam>0
|| GROP.win_ebtn(_red,'text=%1,align=begin,display=1'['Kontrola'@],"exec('view_control','!tpp_gop_ezam')");
   task_attach('TPP_GOP_EZAM');
   {? _display>0
   || _form:="'key:Esc'"
   || _form:="exec('action_close','!tpp_gop_ezam'); 'key:Esc'"
   ?};
   _btn:=GROP.win_ebtn(_red,'text=%1,align=end,display=1'['Zamknij'@],_form);
   task_attach('TPP_GOP_EZAM');
   GROP.btn_eopt(_red,_btn,'default=1')
?};

_red


\godz_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Selekcja zarejestrowanych godzin do grupy operacji
::       Kontekst wywołania: rekord tabeli GROP
::----------------------------------------------------------------------------------------------------------------------
exec('grop_godz','zl_grop',1,1);
~~

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:35 b83528909f139b996a59b9ba6b371ebc1400c9dfe811a66dda65f5fa4623f5b8c26cc7b79abdde22240079ba5e4f5fc47026da047d1325f55caeb443e50e04c742f961a94e078e52776f16aa268bacfd3473d9fd7cda6c9cee24df9a738d9f16fc0408a282e04a61d335021595781e08c179bab754e993d653f0f30dc4dd912f
