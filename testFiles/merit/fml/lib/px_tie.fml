:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: px_tie.fml [12.30]
:: Utworzony: 16.02.2012
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Formuly pomocnicze do spiecia planu strategicznego z planem operacyjnym
::======================================================================================================================


\zkp_pxed
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy pozycja zamowienia zostala zaplanowana w planie strategicznym
::   WE: _a - ZK_P.ref() - ref pozycji zamowienia do sprawdzenia
::   WY: 0 - w wersji glownej planu nie ma takiej pozycji zamowienia
::       1 - w wersji glownej planu znajduje sie taka pozycja zamowienia
::----------------------------------------------------------------------------------------------------------------------
_zkp:=_a;
_result:=0;

PX_OBJ.cntx_psh();
PX_POZ.cntx_psh();

PX_OBJ.index('ZK_P');
PX_OBJ.prefix(ref_name(_zkp),_zkp);
{? PX_OBJ.first()
|| _mainver:=exec('get_mainversion','px_ver');
   PX_POZ.index('TM_VOBJ');
   PX_POZ.prefix(_mainver,PX_OBJ.ref());
   {? PX_POZ.first()
   || _result:=1
   ?}
?};
PX_POZ.cntx_pop();
PX_OBJ.cntx_pop();
_result


\zkp_pxed_sql
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy pozycja zamowienia zostala zaplanowana w planie strategicznym
::   WE: _a - $ZK_P.ref() - SQL ref pozycji zamowienia do sprawdzenia
::   WY: 0 - w wersji glownej planu nie ma takiej pozycji zamowienia
::       1 - w wersji glownej planu znajduje sie taka pozycja zamowienia
::----------------------------------------------------------------------------------------------------------------------
_zkp_sql:=_a;
_result:=0;

_zkp_ref:=exec('FindAndGet','#table',ZK_P,_zkp_sql,,,null());
{? _zkp_ref<>null()
|| _result:=exec('zkp_pxed','px_tie',_zkp_ref)
?};
_result


\obj_start
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca punkt czasu startu obiektu w planie strategicznym
::   WE: _a - PX_OBJ.ref() - obiekt planowany
::       _b - PX_VER.ref() - wersja planu
::   WY: REAL - start planu danego obiektu w formacie tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_px_obj:=_a;
_ver:=_b;

_result:=0;

PX_OBJ.cntx_psh();
PX_POZ.cntx_psh();

PX_OBJ.clear();
{? PX_OBJ.seek(_px_obj)
|| PX_POZ.index('TM_VOBJ');
   PX_POZ.prefix(_ver,PX_OBJ.ref());
   {? PX_POZ.first()
   || _result:=PX_POZ.TM_START
   ?}
?};
PX_POZ.cntx_pop();
PX_OBJ.cntx_pop();
_result


\obj_end
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca punkt czasu konca obiektu w planie strategicznym
::   WE: _a - PX_OBJ.ref() - obiekt planowany
::       _b - PX_VER.ref() - wersja planu
::   WY: REAL - koniec planu danego obiektu w formacie tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_px_obj:=_a;
_ver:=_b;

_result:=0;

PX_OBJ.cntx_psh();
PX_POZ.cntx_psh();

PX_OBJ.clear();
{? PX_OBJ.seek(_px_obj)
|| PX_POZ.index('TM_VOBJ2');
   PX_POZ.prefix(_ver,PX_OBJ.ref());
   {? PX_POZ.last()
   || _result:=PX_POZ.TM_END
   ?}
?};
PX_POZ.cntx_pop();
PX_OBJ.cntx_pop();
_result


\zlec_start
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca punkt czasu startu zlecenia w planie strategicznym
::   WE: _a - ZL.ref()
::       [_b] - ZL.ref - top_level - zlecenie na samej górze (optymalizacja)
::   WY: REAL - tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_zlec:=_a;
_top_level:=null;
{? var_pres('_b')=type_of(ZL.ref())
|| _top_level:=_b
?};

_result:=0;
_mainver:=exec('get_mainversion','px_ver');

ZL.cntx_psh(); ZL.clear();
PX_OBJ.cntx_psh();
PX_POZ.cntx_psh();

PX_OBJ.index('ZL');

{? ZL.seek(_zlec)
||
   {? ZL.RODZAJ<>'P' & ZL.RODZ_TEX<>'Z'
   ||
::    Dla zlecenia zlozonego rekurencja
      _pod_start:=0;
      ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? _pod_start:=exec('zlec_start','px_tie',ZL.ref());
            {? _result=0 | (_pod_start>0 & _pod_start<_result)
            || _result:=_pod_start
            ?};
            ZL.next()
         !}
      ?};
      ZL.cntx_pop()
   ||
      PX_OBJ.prefix(ZL.ref());
      {? PX_OBJ.first()
      || _result:=exec('obj_start','px_tie',PX_OBJ.ref(),_mainver)
      ?};

      {? _result=0 & ZL.RODZ_TEX='Z'
      ||
::       Jeżeli podzlecenie nie zostało zaplanowane, to sprawdzam czy zlecenie na samej górze
::       zostało zaplanowane
         {? _top_level=null()
         || _top_level:=exec('top_level','zl_link',_zlec)
         ?};
         {? _top_level<>_zlec
         ||
            _top_rodz_tex:=exec('FindAndGet','#table',ZL,_top_level,,"RODZ_TEX",'');
            {? _top_rodz_tex='Z'
            || _result:=exec('zlec_start','px_tie',_top_level)
            ?}
         ?};
         ~~
      ?}
   ?}
?};
PX_POZ.cntx_pop();
PX_OBJ.cntx_pop();
ZL.cntx_pop();
_result


\zlec_start_sql
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca punkt czasu startu zlecenia w planie strategicznym
::   WE: _a - $ZL.ref() - SQL ref zlecenia
::   WY: REAL - tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_zlec_sql:=_a;
_result:=0;

_zlec_ref:=exec('FindAndGet','#table',ZL,_zlec_sql,,,null());
{? _zlec_ref<>null()
|| _result:=exec('zlec_start','px_tie',_zlec_ref)
?};
_result


\zlec_end
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca punkt czasu konca zlecenia w planie strategicznym
::   WE: _a - ZL.ref()
::       [_b] - ZL.ref - top_level - zlecenie na samej górze (optymalizacja)
::   WY: REAL - tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_zlec:=_a;
_top_level:=null;
{? var_pres('_b')=type_of(ZL.ref())
|| _top_level:=_b
?};

_result:=0;

_mainver:=exec('get_mainversion','px_ver');

ZL.cntx_psh(); ZL.clear();
PX_OBJ.cntx_psh();
PX_POZ.cntx_psh();

PX_OBJ.index('ZL');

{? ZL.seek(_zlec)
||
   {? ZL.RODZAJ<>'P' & ZL.RODZ_TEX<>'Z'
   ||
::    Dla zlecenia zlozonego rekurencja
      _pod_start:=0;
      ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? _pod_end:=exec('zlec_end','px_tie',ZL.ref());
            {? _result=0 | (_pod_end>0 & _pod_end>_result)
            || _result:=_pod_end
            ?};
            ZL.next()
         !}
      ?};
      ZL.cntx_pop()
   ||
      PX_OBJ.prefix(_zlec);
      {? PX_OBJ.first()
      || _result:=exec('obj_end','px_tie',PX_OBJ.ref(),_mainver)
      ?};
      {? _result=0 & ZL.RODZ_TEX='Z'
      ||
::       Jeżeli podzlecenie nie zostało zaplanowane, to sprawdzam czy zlecenie na samej górze
::       zostało zaplanowane
         {? _top_level=null()
         || _top_level:=exec('top_level','zl_link',_zlec)
         ?};
         {? _top_level<>_zlec
         || _top_rodz_tex:=exec('FindAndGet','#table',ZL,_top_level,,"RODZ_TEX",'');
            {? _top_rodz_tex='Z'
            || _result:=exec('zlec_end','px_tie',_top_level)
            ?}
         ?};
         ~~
      ?}
   ?}
?};
ZL.cntx_pop();
PX_POZ.cntx_pop();
PX_OBJ.cntx_pop();
_result


\zlec_end_sql
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca punkt czasu konca zlecenia w planie strategicznym
::   WE: _a - $ZL.ref() - SQL ref zlecenia
::   WY: REAL - tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_zlec_sql:=_a;
_result:=0;

_zlec_ref:=exec('FindAndGet','#table',ZL,_zlec_sql,,,null());
{? _zlec_ref<>null()
|| _result:=exec('zlec_end','px_tie',_zlec_ref)
?};
_result


\zkp_start
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca punkt czasu startu pozycji zamowienia w planie strategicznym
::   WE: _a - ZK_P.ref()
::   WY: REAL - tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_zkp:=_a;
_result:=0;

PX_OBJ.cntx_psh();
PX_POZ.cntx_psh();

PX_OBJ.index('ZK_P');
PX_OBJ.prefix(ref_name(_zkp),_zkp);
{? PX_OBJ.first()
|| _mainver:=exec('get_mainversion','px_ver');
   _result:=exec('obj_start','px_tie',PX_OBJ.ref(),_mainver)
?};
PX_POZ.cntx_pop();
PX_OBJ.cntx_pop();
_result


\zkp_start_sql
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca punkt czasu startu pozycji zamowienia w planie strategicznym
::   WE: _a - $ZK_P.ref() - SQL ref pozycji zamowienia
::   WY: REAL - tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_zkp_sql:=_a;
_result:=0;

_zkp_ref:=exec('FindAndGet','#table',ZK_P,_zkp_sql,,,null());
{? _zkp_ref<>null()
|| _result:=exec('zkp_start','px_tie',_zkp_ref)
?};
_result


\zkp_end
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca punkt czasu konca pozycji zamowienia w planie strategicznym
::   WE: _a - ZK_P.ref()
::   WY: STRING - punkt czasu w formacie 'YYYY/MM/DD HH:MM:SS'
::----------------------------------------------------------------------------------------------------------------------
_zkp:=_a;
_result:=0;

PX_OBJ.cntx_psh();
PX_POZ.cntx_psh();

PX_OBJ.index('ZK_P');
PX_OBJ.prefix(ref_name(_zkp),_zkp);
{? PX_OBJ.first()
|| _mainver:=exec('get_mainversion','px_ver');
   _result:=exec('obj_end','px_tie',PX_OBJ.ref(),_mainver)
?};
PX_POZ.cntx_pop();
PX_OBJ.cntx_pop();
_result


\zkp_end_sql
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca punkt czasu konca pozycji zamowienia w planie strategicznym
::   WE: _a - $ZK_P.ref() - SQL ref pozycji zamowienia
::   WY: STRING - punkt czasu w formacie 'YYYY/MM/DD HH:MM:SS'
::----------------------------------------------------------------------------------------------------------------------
_zkp_sql:=_a;
_result:='';

_zkp_ref:=exec('FindAndGet','#table',ZK_P,_zkp_sql,,,null());
{? _zkp_ref<>null()
|| _result:=exec('zkp_end','px_tie',_zkp_ref)
?};
_result


\grop_start
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [23.25]
:: OPIS: Zwraca punkt czasu startu pozycji grupy operacji w planie strategicznym
::   WE: _a - GROP.ref()
::   WY: REAL - tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;
_result:=0;

PX_OBJ.cntx_psh();
PX_POZ.cntx_psh();

PX_OBJ.index('GROP');
PX_OBJ.prefix(_grop);
{? PX_OBJ.first()
|| _mainver:=exec('get_mainversion','px_ver');
   _result:=exec('obj_start','px_tie',PX_OBJ.ref(),_mainver)
?};
PX_POZ.cntx_pop();
PX_OBJ.cntx_pop();
_result


\grop_end
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [23.25]
:: OPIS: Zwraca punkt czasu końca pozycji grupy operacji w planie strategicznym
::   WE: _a - GROP.ref()
::   WY: REAL - tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;
_result:=0;

PX_OBJ.cntx_psh();
PX_POZ.cntx_psh();

PX_OBJ.index('GROP');
PX_OBJ.prefix(_grop);
{? PX_OBJ.first()
|| _mainver:=exec('get_mainversion','px_ver');
   _result:=exec('obj_end','px_tie',PX_OBJ.ref(),_mainver)
?};
PX_POZ.cntx_pop();
PX_OBJ.cntx_pop();
_result


\zlzam2plan
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Po utworzenia zlecen z pozycji zamowienia wyjmuje z kolejki pozycje zamowienia i wklada zlecenia
::       (zlecenia moga byc proste albo zlozone)
::       UWAGA znajduje i przeksztalcam tylko pierwszego PX_CONNa danej pozycji zamowienia. Jesli zamowienie jest w kilku
::       kawalkach w planie to powinno z niego powstac kilka zlecen i ta funkcja powinna sie wykonac kilka razy
::   WE: _a - ZLZAM.ref()
::       [_b] - PX_CONN.ref() - kawalek planu zamowienia ktory przeksztalcic
::       [_c] - PX_VER.ref()  - wersja na której dokonywać przekształcenia
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_zlzam:=_a;

_px_conn:=null();
{? var_pres('_b')=type_of(PX_CONN.ref())
|| _px_conn:=_b
?};

_result:=0;

_can_continue:=0;
_mainver:=exec('get_mainversion','px_ver');
{? var_pres('_c')=type_of(PX_VER.ref())
|| _mainver:=_c
?};

_obj_old:=null();
_obj_zl:=null();
PX_OBJ.cntx_psh();
PX_GRP.cntx_psh();
PX_GRP.clear();
ZLZAM.cntx_psh();
ZL.cntx_psh();
exec('trigger_on','px_grp');

ZLZAM.clear();
{? ZLZAM.seek(_zlzam)
||
:: 1. Odnajduje obiekt planowany
   _zkp:=exec('FindAndGet','#table',ZK_P,ZLZAM.ZAMPOZ,,,null());
   PX_OBJ.cntx_psh();
   PX_OBJ.index('ZK_P');
   PX_OBJ.prefix(ref_name(_zkp),_zkp);
   {? PX_OBJ.first()
   || _obj_old:=PX_OBJ.ref()
   ?};
   PX_OBJ.index('ZL');
   PX_OBJ.prefix(ZLZAM.ZL);
   {? PX_OBJ.first()
   || _obj_zl:=PX_OBJ.ref()
   ?};
   PX_OBJ.cntx_pop();

   {? _obj_old<>null()
   ||
::    2. Sprawdzam czy obiekt znajduje sie w kolejce planu glownego
      PX_CONN.cntx_psh();
      PX_CONN.index('VER');
      {? _px_conn=null()
      || PX_CONN.prefix(_mainver,_obj_old);
         _can_continue:=PX_CONN.first()
      || PX_CONN.clear();
         _can_continue:=PX_CONN.seek(_px_conn)
      ?};

      {? _can_continue>0
      ||
         _args:=exec('blank_a','px_grp');
::       Znalazlem pierwsza zamowienie w planie
::       1. Zapamietuje informacje z px_grp
         _grp:=PX_CONN.PX_GRP;
         _conn:=PX_CONN.ref();
         _grp_lp:=PX_CONN.PX_GRP().LP_Q;
         _grp_tex:=PX_CONN.PX_GRP().PX_TEX;
         _grp_dir:=PX_CONN.PX_GRP().DIR;
         _startd:=PX_CONN.PX_GRP().STARTD().DATA;
         _startt:=PX_CONN.PX_GRP().STARTT;
         _endd:=PX_CONN.PX_GRP().ENDD().DATA;
         _endt:=PX_CONN.PX_GRP().ENDT;
         _conn_il:=ZLZAM.ILZL;
         _old_conn_il:=PX_CONN.ILOSC;
         _set_src:=PX_CONN.PX_GRP().SET_SRC;

::       2. Jezeli zlecenie zlozone i przepisy proste, to pobieram podzlecenie na produkt
         {? ZL.RODZ_TEX='P'
         ||
            ZL.index('NRNZL');
            ZL.prefix(ZLZAM.ZL().UNRZL);
            {? ZL.first()
            || _zl:=ZL.ref()
            || ZLZAM.ZL();
               _zl:=ZLZAM.ZL
            ?}
         ||
::          zlecenie z przepisem zintegrowanym
            ZLZAM.ZL();
            _zl:=ZLZAM.ZL
         ?};
         _lck_grp:=null();
         _lck_ver:=null();

::       3. Blokuje grupe i wersje na czas zamiany
         {? exec('lock','px_grp',_grp)>0
         || _can_continue:=1;
            _lck_grp:=_grp
         || _can_continue:=0
         ?};

         {? _can_continue>0
         || {? exec('lock','px_ver',_mainver)
            || _can_continue:=1;
               _lck_ver:=_mainver
            || _can_continue:=0
            ?}
         ?};

::       4. Tworze PX_OBJ na podstawie zlecenia
         {? _can_continue>0
         || _can_continue:=exec('zl2obj','px_obj')
         ?};
         {? _can_continue>0
         ||
            _grp_new:=null();

::          Odnajduje nowo utworzonego PX_OBJ
            PX_OBJ.index('ZL');
            PX_OBJ.prefix(_zl);
            {? PX_OBJ.first()
            ||
::             Sprawdzam czy obiekt nie jest już przypadkiem w kolejce, jeśli jest to go nie dodaję
::             kolejny raz
               _queue_add:=1;
               _que_il:=exec('get_ilosc_que','px_obj',_mainver,PX_OBJ.ref());
               {? _que_il>0
               || _queue_add:=0;
                  _conn_il:=_que_il-_old_conn_il;
                  _grp_new:=exec('get_first_grp','px_obj',_mainver,PX_OBJ.ref());

                  {? _grp_new<>null()
                  || _px_conn:=exec('get_first_conn','px_obj',_grp_new,PX_OBJ.ref());
::                   Szukam konkretnego PX_CONNa w której obiekt już jest i zwiększam mu ilosc
                     PX_CONN.cntx_psh(); PX_CONN.prefix();
                     {? PX_CONN.seek(_px_conn)
                     || PX_CONN.ILOSC+=_old_conn_il;
                        _conn_il:=_old_conn_il;
                        PX_CONN.put()
                     ?};
                     PX_CONN.cntx_pop()
                  ?}
               ?};

               {? _queue_add>0
               ||
::                4. Tworze PX_GRP z jednym PX_CONN na podstawie zlecenia
                  _args.PX_VER:=_mainver;
                  _args.ILOSC:=_conn_il;

::                Generuje przepis dla zlecenia
                  {? exec('AutoPX4PX_OBJ','px_auto',PX_OBJ.ref())>0
                  || _args.PX_TEX:=exec('get_tex_zl','px_tex',_zl)
                  || _args.PX_TEX:=_grp_tex
                  ?};
                  _args.SYMBOL:=exec('get_symbol','px_grp',_args.PX_TEX);
                  _args.NAZWA:=exec('get_nazwa','px_grp',_args.PX_TEX);
                  _args.DIR:=_grp_dir;
::                nowy obiekt wrzucam 'tuz tuz' przed grupa w ktorej oryginalnie byl
                  _args.LP_Q:=(_grp_lp-0.01);
                  _args.STARTD:=_startd;
                  _args.STARTT:=_startt;
                  _args.ENDD:=_endd;
                  _args.ENDT:=_endt;
                  _args.SET_SRC:=_set_src;

::                dodaje nowy obiekt do kolejki
                  _can_continue:=exec('add','px_grp',_args,PX_OBJ.ref(),,0);
                  {? _can_continue>0
                  || _grp_new:=PX_GRP.ref()
                  ?}
               ?};

               {? _can_continue>0
               ||
::                Uzupelnia powiazania miedzy grupami obiektow, czyli podzlecenia
                  {? var_pres('_grps')>100
                  || obj_del(_grps)
                  ?};
                  _grps:=exec('ref_table','#table');
                  _can_continue:=exec('UpdatePX_GRP','px_con_g',_grp_new,_grps,1,0,0);


::                Odejmuję od zamówienia ilość na którą utworzyłem zlecenie
                  PX_CONN.cntx_psh(); PX_CONN.prefix();
                  {? PX_CONN.seek(_conn)
                  || PX_CONN.ILOSC-=_conn_il;
                     _old_conn_il:=PX_CONN.ILOSC;
                     PX_CONN.put()
                  ?};
                  PX_CONN.cntx_pop();

                  {? _can_continue>0
                  ||
::                   Przenumerowuje kolejke zeby sie pozbyc ulamkowych LP
                     exec('prenumber','px_grp',_mainver)
                  ?};

                  {? _can_continue>0
                  ||
::                   Regeneruje LP w kolejce, poniewaz mogly powstac nowe grupy majace 'dziwna' kolejnosc
                     _can_continue:=exec('reorder_px_ver','px_con_g',_mainver)
                  ?};

                  {? _can_continue>0
                  ||
                     {? _old_conn_il<=0
                     ||
::                      jesli sie udalo dodac nowy obiekt i polaczenie to usuwam stare polaczenie i grupe jesli pusta
                        _can_continue:=exec('delete','px_conn',_conn);
                        {? _can_continue>0
                        || exec('delete_ifempty','px_grp',_grp)
                        ?};

::                      Stary PX_OBJ usuwam z wersji modyfikujac plan - robie dziury
                        _can_continue:=exec('clean_from_plan','px_obj',_obj_old,_args.PX_VER,_grp)
                     ||
::                      Jeżeli coś zostało to musze to przeplanować to co zostało
                        _argsfast_old:=exec('fast_replan_a','px_logix');
                        _argsfast_old.PX_GRP:=_grp;
                        _can_continue:=exec('grp_fast_replan','px_logix',_argsfast_old)
                     ?}
                  ?};

                  {? _can_continue>0
                  ||
                     {? _grps.tab.size()=0
                     ||
::                      ZLECENIE POJEDYNCZE
::                      Nowe PX_OBJ dodaje do planu w miejsce powstalych dziur
::                      Przetwarzamy _grp_new
                        _argsfast:=exec('fast_replan_a','px_logix');
                        _argsfast.PX_GRP:=_grp_new;

                        _can_replan:=exec('queue_update_core','px_logix',_argsfast.PX_GRP);
                        {? _can_replan>0
                        || _can_replan:=exec('queue_check_one','px_logix',_argsfast.PX_GRP)
                        ?};

                        {? _can_replan>0
                        || _can_continue:=exec('grp_fast_replan','px_logix',_argsfast)
                        ?};
                        ~~
                     ||
::                      ZLECENIE ZLOZONE
::                      Planowane sa wszystkie zlecenia podrzedne
                        {? var_pres('_tm_range')>100
                        || obj_del(_tm_range)
                        ?};
                        _tm_range:=exec('tm_range_create','px_logix');

::                      Nadaje kolejnosc rekordom w tabelce _grps
                        _grps.tab.clear();
                        {? _grps.tab.first()
                        || {!
                           |? _lp:=exec('FindAndGet','#table',PX_GRP,_grps.tab.REF,,"LP_Q",0);
                              _grps.tab.LP:=_lp;
                              _can_continue:=_grps.tab.put();
                              _grps.tab.next() & _can_continue>0
                           !}
                        ?};

::                      Planuje po kolei PX_GRPy (zlecenia podrzedne)
                        _grps.tab.index(_grps.ndxLp);
                        _grps.tab.clear();
                        {? _grps.tab.first() & _can_continue>0
                        || _argsfast:=exec('fast_replan_a','px_logix');
                           _argsfast.TM_RANGE:=_tm_range;
                           {!
                           |? _px_grp:=exec('FindAndGet','#table',PX_GRP,_grps.tab.REF,,,null());

                              _argsfast.PX_GRP:=_px_grp;

                              _can_replan:=exec('queue_update_core','px_logix',_argsfast.PX_GRP);
                              {? _can_replan>0
                              || _can_replan:=exec('queue_check_one','px_logix',_argsfast.PX_GRP)
                              ?};

                              {? _can_replan>0
                              || _can_continue:=exec('grp_fast_replan','px_logix',_argsfast)
                              ?};
                              _grps.tab.next() & _can_continue>0
                           !}
                        ?}
                     ?}
                  ?}
               ?}
            ?}
         ?};
::       Odblokowuje wersje i grupe, ktore wczesniej zablokowalem
         {? _lck_grp<>null()
         || exec('unlock','px_grp',_lck_grp)
         ?};
         {? _lck_ver<>null()
         || exec('unlock','px_ver',_lck_ver)
         ?}
      ?};
      PX_CONN.cntx_pop()
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
exec('trigger_off','px_grp');
ZLZAM.cntx_pop();
PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
ZL.cntx_pop();
_result


\interval2pxpoz
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Dodaje PX_POZa na pojemnik na podstawie interwalu czasowego
::       Kontekst pracy:
::                         PX_CUP na ktory dodac pozycje planu
::                         PX_VER do ktorej dodawac pozycje planu
::                         KAL_DEF na podstawie ktorego okreslic czas pracy zasobu w planie operacyjnym
::   WE: _a - tablica nazwana - interwal na podstawie ktorego utworzyc pozycje planu w pojemniku
::                              wynik dzialania exec('interval','px_utils')
::       _b - INTEGER - zwrot planowania: 1 - do przodu, -1 - wstecz
::       _c - KAL_NAZW.ref() - kalendarz zasobu ktory ma zostac uwzgledniony podczas wyliczania proporcji
::       [_d] - PL_OPER.ref() - opcjonalnie - PL_OPER z ktorym powiazac utworzone PX_POZy
::       [_e] - PX_OBJ.ref() - opcjonalnie - PX_OBJ z ktorym powiazac utworzone PX_POZy
::       [_f] - PL_OGR.ref() - opcjonalnie - PL_OGR z ktorym powiazac utworzone PX_POZy
::       [_g] - REAL - opcjonalnie - proporcja wejsciowa ktora dodatkowo uwzglednic podczas liczenia zuzycia
::                                   Moze byc podana np w przypadku gdy w planie operacyjnym interwal jest na
::                                   stanowisku, a w planie strategicznym bedzie na gniezdzie ktore ma 3 stanowiska
::       [_h] - TABLE - tabela z pojemnikami/kalendarzami w pojemnikach (domyślnie PX_CUP)
::       [_i] - REM_PLAN.ref - opcjonalnie - REM_PLAN który jest planowany
::   WY: 0 - na podany kafelek nie udalo sie dodac pozycji planu
::       1 - na podany kafelek dodano pozycje planu
::----------------------------------------------------------------------------------------------------------------------
_ti_oporg:=_a;
_dir:=_b;
_kal_nazw:=_c;

_pl_oper:=null();
_px_obj:=null();
_pl_ogr:=null();
_pr_init:=1;

{? var_pres('_d')=type_of(PL_OPER.ref())
|| _pl_oper:=_d
?};

{? var_pres('_e')=type_of(PX_OBJ.ref())
|| _px_obj:=_e
?};

{? var_pres('_f')=type_of(PL_OGR.ref())
|| _pl_ogr:=_f
?};

{? var_pres('_g')=type_of(1)
|| _pr_init:=_g
?};

_rem_plan:=null();
{? var_pres('_i')=type_of(REM_PLAN.ref())
|| _rem_plan:=_i
?};

_tab:=~~;
{? var_pres('_h')>0
|| _tab:=_h
|| _tab:=PX_CUP
?};

_result:=0;
_proporcja:=0;

PX_POZ.cntx_psh();PX_POZ.clear();
PX_KONT.cntx_psh();

_argscup:=exec('plan_add_cup_a','px_logix');
_argscup.PX_GRP:=null();
_argscup.PL_OPER:=_pl_oper;
_argscup.PL_OGR:=_pl_ogr;
_argscup.PX_OBJ:=_px_obj;
_argscup.REM_PLAN:=_rem_plan;
_argscup.DIR:=_dir;
_argscup.SKIP_PLO:=2;

:: Dla interwalu pojemnika w Planie strategicznym wykonuje formule dla kazdego okresu pracy
:: w planie operacyjnym (na podstawie kalendarza)

:: Tabica argumentow dla formuly
_argsrule:=obj_new('INTERVAL','ARGSCUP','PR_INIT','TAB','PR_CALC');
_argsrule.INTERVAL:=_ti_oporg;
_argsrule.ARGSCUP:=_argscup;
_argsrule.PR_INIT:=_pr_init;
_argsrule.TAB:=_tab;
_argsrule.PR_CALC:=1;
::{? _rem_zgl<>null()
::|| _argsrule.PR_CALC:=0
::?};

_rule:="
   _args:=_a;

   _result:=1;
:: Obliczam proporcje
   {? _args.PR_CALC>0
   || _proporcja:=exec('proporcja4px','px_tie',_args.INTERVAL,_args.PR_INIT,_args.TAB)
   || _proporcja:=_args.PR_INIT
   ?};

:: Uruchamiam dodawanie pozycji planu w Planie strategicznym
   {? _proporcja>0
   || _result:=exec('add_pxpoz','px_tie',_args.ARGSCUP,_proporcja)
   ?};
   _result
";

_result:=exec('rule4kaldef','po_plan',_kal_nazw,_tab.TM_START,_tab.TM_END,_rule,0,_argsrule);

PX_POZ.cntx_pop();
PX_KONT.cntx_pop();
_result


\add_pxpoz
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Dodaje PX_POZa na podstawie przekazanych argumentow
::       Kontekst pracy:
::                         PX_CUP na ktory dodac pozycje planu
::   WE: _a - obj_new() - tablica nazwana z argumentami dla funkcji dodajacej PX_POZa - exec('plan_add_cup_a','px_logix')
::       _b - REAL - proporcja wg ktorej tworzyc pozycje planu
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_argscup:=_a;
_proporcja:=_b;

_result:=0;

{? _argscup.REM_PLAN<>null()
|| REM_ZGL.cntx_psh();
   REM_PLAN.cntx_psh(); REM_PLAN.prefix();
   {? REM_PLAN.seek(_argscup.REM_PLAN)
   ||
      REM_PLAN.REM_ZGL();
      _tm1:=exec('create','#tm_stamp',REM_ZGL.DT_PST,REM_ZGL.TM_PST);
      _tm2:=exec('create','#tm_stamp',REM_ZGL.DT_PUA,REM_ZGL.TM_PUA);

      _int_cup:=exec('interval','#interval');
      _int_cup.START:=PX_CUP.TM_START;
      _int_cup.END:=PX_CUP.TM_END;

      _usable:=REM_PLAN.USABLE;

      {? REM_ZGL.PL_DOST='C'
      || _usable:=0
      |? REM_ZGL.PL_DOST='B'
      || _usable:=100
      ?};

      _rem_prop:=1-(_usable/100);
      {? _rem_prop>0 & _rem_prop<1
      || _proporcja:=_proporcja*_rem_prop
      ?}
   ?};
   REM_ZGL.cntx_pop();
   REM_PLAN.cntx_pop()
?};

_argscup.PROP:=_proporcja;

:: Pobieram maksymalne pojemnosci pojemnika we wszystkich wymiarach
_cap_max:=exec('cap_max','px_cup');

:: Mnoze maksymalne pojemnosci pojemnika przez proporcje - otrzymuje zuzycie dla pozycji planu
exec('array_multiply','#array',_cap_max,_proporcja);

:: Obsluga pojemnosci nieskonczonych
_il_wym:=PX_CUP.PX_KONT().IL_WYM;
_endless:=1;
_infinity:=exec('infinity_array','px_kont');
{! _it:=1.._il_wym
|? _endless=1
|! _endless:=_infinity[_it];
   {? _endless>0
   ||
::    Zeruje nieskonczone pojemnosci, bo mogly tam znalezc sie jakies smieci
      _cap_max[_it]:=0
   ?}
!};
{! _it:=1.._il_wym
|! {? _infinity[_it]>0
   ||
::    Zeruje nieskonczone pojemnosci, bo mogly tam znalezc sie jakies smieci
      _cap_max[_it]:=0
   ?}
!};

:: Jesli wszystkie wymiary nieskonczone to jest ryzyko ze wszedzie w _cap_max sa zera
:: w tym przypadku trzeba tam wpisac cokolwiek aby pozycja planu zostala utworzona
{? _endless=1
|| {? exec('array_sum','#array',_cap_max)=0
   || _cap_max[1]:=1
   ?}
?};

_typ:='';
_ti_new_ploper:=exec('interval','#interval');
{? _argscup.PL_OPER<>null()
|| PL_OPER.cntx_psh(); PL_OPER.prefix();
   {? PL_OPER.seek(_argscup.PL_OPER)
   || _ti_new_ploper.START:=PL_OPER.TM_START;
      _ti_new_ploper.END:=PL_OPER.TM_END;
      _typ:=PL_OPER.TYP
   ?};
   PL_OPER.cntx_pop()
|? _argscup.PL_OGR<>null()
|| PL_OGR.cntx_psh(); PL_OGR.prefix();
   {? PL_OGR.seek(_argscup.PL_OGR)
   || _ti_new_ploper.START:=PL_OGR.TM_START;
      _ti_new_ploper.END:=PL_OGR.TM_END
   ?};
   PL_OGR.cntx_pop()
?};
{? _typ<>'T'
||
   PX_POZ.cntx_psh();
   PX_POZ.index('LP');
   PX_POZ.prefix(PX_CUP.ref());
   {? PX_POZ.first()
   ||
      _remonty:=obj_new(_il_wym);
      _ti_remont:=exec('interval','#interval');
      {! _it:=1.._il_wym
      |! _remonty[_it]:=0
      !};
      {!
      |? {? PX_POZ.PL_OPER<>null()
         || {? PX_POZ.PL_OPER().TYP='T'
            ||
               _proporcja:=0;
::             Liczę część wspólną remontu i utworzonej pozycji planu
               _ti_remont.START:=PX_POZ.PL_OPER().TM_START;
               _ti_remont.END:=PX_POZ.PL_OPER().TM_END;

               _rem_dur:=exec('interval_dur','#interval',_ti_remont);
               {? var_pres('_rem_and')>100
               || obj_del(_rem_and)
               ?};
               _rem_and:=exec('intervals_and','#interval',_ti_remont,_ti_new_ploper);
               _dur_and:=exec('interval_dur','#interval',_rem_and);
               {? _dur_and>0 & _rem_dur>0
               || _proporcja:=_dur_and/_rem_dur;
                  {? _proporcja>1
                  || _proporcja:=1
                  ?}
               ?};

               {? _proporcja>0
               ||
                  {! _it:=1.._il_wym
                  |! _rule:='_remonty:=_a;_prop:=_b;_remonty['+$_it+']+=(PX_POZ.CAP_EAT'+$_it+'*_prop)';
                     ($_rule)(_remonty,_proporcja)
                  !}
               ?}
            ?}
         ?};
         PX_POZ.next()
      !};

::   Operacje typu remont zmniejszają dostępny kalendarz a więc dla nowo utworzonej pozycji
::   planu powinny odejmować zajętą pojemność
     {! _it:=1.._il_wym
     |! _cap_max[_it]-=_remonty[_it];
        {? _cap_max[_it]<0
        || _cap_max[_it]:=0
        ?}
     !}
   ?};
   PX_POZ.cntx_pop()
?};

{? var_pres('CAPS',_argscup)>100
|| obj_del(_argscup.CAPS)
?};
_argscup.CAPS:=_cap_max;

_argscup.REASON:=exec('reason_ploper','px_param');
:: Tworze pozycje planu
_added:=exec('plan_add_cup','px_logix',_argscup);

{? exec('array_sum','#array',_added)>0
|| _result:=1;

:: Aktualizuje utworzona pozycje - byc moze trzeba ja od razu opoznic
   exec('status_update','px_poz',PX_POZ.ref());
   ~~
?};
_result


\proporcja4px
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Zwraca proporcje wg ktorej maja zostac utworzone pozycje w planie strategicznym
::       Kontekst pracy:
::                         PX_CUP na ktory dodac pozycje planu (wazny jest czas trwania)
::                         PX_VER do ktorej dodawac pozycje planu
::                         KAL_DEF na podstawie ktorego okreslic czas pracy zasobu w planie operacyjnym
::   WE: _a - tablica nazwana - interwal na podstawie ktorego utworzyc pozycje planu w pojemniku
::                              wynik dzialania exec('interval','#interval')
::       [_b] - REAL - opcjonalnie - proporcja wejsciowa ktora dodatkowo uwzglednic podczas liczenia zuzycia
::                                   Moze byc podana np w przypadku gdy w planie operacyjnym interwal jest na
::                                   stanowisku, a w planie strategicznym bedzie na gniezdzie ktore ma 3 stanowiska
::       [_c] - TABLE - tabela z pojemnikami/kalendarzami w pojemniku (domyślnie PX_CUP)
::   WY: REAL - proporcja wyjsciowa (zawsze z przedzialu 0..1)
::----------------------------------------------------------------------------------------------------------------------
_ti_oporg:=_a;
_pr_init:=1;

{? var_pres('_b')=type_of(1)
|| _pr_init:=_b
?};
_tab:=~~;
{? var_pres('_c')>0
|| _tab:=_c
|| _tab:=PX_CUP
?};

_result:=0;

_ti_ver:=exec('interval','#interval');
_ti_ver.START:=PX_VER.TM_START;
_ti_ver.END:=PX_VER.TM_END;

:: Wyznaczam czesc wspolna dla wersji i podanego interwalu
_ti_oper:=exec('intervals_and','#interval',_ti_ver,_ti_oporg);
_dur_oper:=exec('interval_dur','#interval',_ti_oper);

:: Interwal pojemnika
_ti_cup:=exec('interval','#interval');
_ti_cup.START:=_tab.TM_START;
_ti_cup.END:=_tab.TM_END;

:: Interwal KAL_DEFa - okresu pracy w kalendarzu
_ti_cal:=exec('interval','#interval');
_ti_cal.START:=KAL_DEF.TM_START;
_ti_cal.END:=KAL_DEF.TM_END;

:: Obliczam czesc wspolna interwalu operacji wejsciowej z interwalem pojemnika
_ti_opcup:=exec('intervals_and','#interval',_ti_oper,_ti_cup);

:: Obliczam czesc wspolna interwalu kalendarza z interwalem operacji*interwal pojemnika
_ti_final:=exec('intervals_and','#interval',_ti_opcup,_ti_cal);

:: Obliczam czesc wspolna interwalu pojemnika i interwalu kalendarza
_ti_cupcal:=exec('intervals_and','#interval',_ti_cal,_ti_cup);

_dur_final:=exec('interval_dur','#interval',_ti_final);
_d_cupcal:=exec('interval_dur','#interval',_ti_cupcal);
{? _dur_final>0
||
   _result:=(_dur_final/_d_cupcal)*_pr_init;
   {? _result>1
   || _result:=1
   |? _result<0
   || _result:=0
   ?}
?};
_result


\ploper2pxpoz
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: W Planie strategicznym tworzy PX_POZy na podstawie PL_OPERa, usuwajac stare pozycje jesli istnialy
::   WE: _a - PL_OPER.ref()
::       _b - PX_VER.ref() - wersja w ktorej tworzyc
::       _c - INTEGER      - 0/1 - czy ustalać wartość zmiennej PX_VAR.NAST_ALG
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_pl_oper:=_a;
_px_ver:=_b;
_nast_alg:=1;
{? var_pres('_c')=type_of(0)
|| _nast_alg:=_c
?};
{? _nast_alg>0
|| exec('opernast_init','px_init')
?};

_result:=0;
_can_continue:=1;

PX_VAR.P500380:=exec('get','#params',500380,type_of(''));
PX_VAR.P500381:=exec('get','#params',500381,type_of(''));
PX_CAL.cntx_psh();
PX_CUP.cntx_psh();
PX_OBJ.cntx_psh();
PX_KONT.cntx_psh();
PL_OPER.cntx_psh(); PL_OPER.clear();
PL_PART.cntx_psh();
PL_RES.cntx_psh();
PX_VER.cntx_psh(); PX_VER.clear();
ZL.cntx_psh();
ZK_P.cntx_psh();
{? PX_VER.seek(_px_ver) & PL_OPER.seek(_pl_oper)
||
:: Na razie PL_OPERy planuje zawsze do przodu
   _dir:=1;
:: Wyszukiwanie lub zakladanie PX_OBJ
   _px_obj:=null();
   {? PL_OPER.PL_PART<>null()
   || {? PL_OPER.PL_PART().ZL<>null()
      ||
         PL_OPER.PL_PART().ZL();
         _px_obj:=exec('get_zl_object','px_obj',PL_OPER.PL_PART().ZL);

::       Jezeli nie ma jeszcze PX_OBJ to go tworze
         {? _px_obj=null()
         || {? exec('zl2obj','px_obj')>0
            || _px_obj:=exec('get_zl_object','px_obj',PL_OPER.PL_PART().ZL)
            ?}
         ?}
      ?};
      {? _px_obj=null()
      || {? PL_OPER.PL_PART().ZK_P<>null()
         ||
            _mask_needed:=ref_name(PL_OPER.PL_PART().ZK_P);
            {? ZK_P.name()<>_mask_needed
            || ZK_P.use(_mask_needed)
            ?};
            PL_OPER.PL_PART().ZK_P();
            _px_obj:=exec('get_zkp_object','px_obj',PL_OPER.PL_PART().ZK_P);

::          Jezeli nie ma jeszcze PX_OBJ to go tworze
            {? _px_obj=null()
            || {? exec('zkp2obj','px_obj')>0
               || _px_obj:=exec('get_zkp_object','px_obj',PL_OPER.PL_PART().ZK_P)
               ?}
            ?}
         ?}
      ?}
   |? PL_OPER.REM_PLAN<>null()
   || REM_PLAN.cntx_psh();
      REM_ZGL.cntx_psh();
      PL_OPER.REM_PLAN();
::    Wyszukiwanie lub zakladanie PX_OBJ
      _px_obj:=exec('get_rem_object','px_obj',REM_PLAN.REM_ZGL);
      {? _px_obj=null()
      || REM_PLAN.REM_ZGL();
         exec('rem2obj','px_obj');
         _px_obj:=exec('get_rem_object','px_obj',REM_PLAN.REM_ZGL)
      ?};
      REM_PLAN.cntx_pop();
      REM_ZGL.cntx_pop()
   ?};
   _ti_ver:=exec('interval','#interval');
   _ti_ver.START:=PX_VER.TM_START;
   _ti_ver.END:=PX_VER.TM_END;
:: Najpierw usuwam z wersji wszystkie PX_POZy powiazane z tym ploperem, jesli jakies istnialy
   _can_continue:=exec('ploper_clear','px_poz',_pl_oper,_px_ver);
   {? _can_continue>0
   ||
      _ti_oporg:=exec('interval','#interval');
      _ti_oporg.START:=PL_OPER.TM_START;
      _ti_oporg.END:=PL_OPER.TM_END;
      _dur_oporg:=exec('interval_dur','#interval',_ti_oporg);

::    Musze zaplanowac tylko takie operacje ktore przecinaja zakres wersji
::    i tylko w zakresie w ktorym operacja i wersja sie przecinaja
      _ti_oper:=exec('intervals_and','#interval',_ti_ver,_ti_oporg);
      _dur_oper:=exec('interval_dur','#interval',_ti_oper);
      {? _dur_oper>0
      ||
::       Iteruje po plozach
         PL_OZ.cntx_psh();
         PL_OZ.index('PL_OPER');
         PL_OZ.prefix(PL_OPER.ref());
         {? PL_OZ.first()
         || {!
            |?
               _kal_nazw:=PL_OZ.PL_RES().KAL_NAZW;
::             Przechodze z PL_RESa na PX_KONTa
::             Znajduje kontenery w wersji glownej planu strategicznego
               {? var_pres('_konty')>100
               || obj_del(_konty)
               ?};
               _konty:=exec('res_pl2px','px_wyk',PL_OZ.ref(),PL_OPER.ref(),_px_ver);

               {? type_of(_konty)>0 & _konty.first()
               ||
                  {!
                  |?
                     PX_KONT.clear();
                     {? PX_KONT.seek(_konty.REF,_konty.NAME)
                     ||
::                      Znajduje kontener w wersji docelowej
                        PX_KONT.index('ACT');
                        PX_KONT.prefix('T',_px_ver,PX_KONT.SYMBOL,);
                        {? PX_KONT.first()
                        ||
::                         Jestem na docelowym kontenerze
::                         Szukam pierwszego pojemnika od ktorego bede planowal

                           _start:=0;
                           {? _dir>0
                           || _start:=_ti_oper.START
                           || _start:=_ti_oper.END
                           ?};
                           {? var_pres('_tab')>100
                           || obj_del(_tab)
                           ?};
                           _tab:=~~;
                           {? PX_VAR.NAST_ALG=2
                           ||
::                            Algorytm nakładkowania metodą proporcji czasowej działa w oparciu o PX_CAL
                              _tab:=PX_CAL
                           ||
::                            Standardowe planowanie działa w oparciu o PX_CUP
                              _tab:=PX_CUP
                           ?};

                           {? exec('cup_point_check','px_plan',PX_KONT.ref(),_start,_dir,_tab,PL_OZ.PL_RES)>0
                           ||
                              {? _tab=PX_CAL
                              ||
::                               Jeżeli operuję na PX_CAL to i tak muszę ustawić indeks na PX_CUP
                                 exec('cup_point_check','px_plan',PX_KONT.ref(),_start,_dir,PX_CUP,PL_OZ.PL_RES);
                                 PX_CAL.PX_CUP()
                              ?};

::                            Wyznaczam ilosc pojemnikow w ktorych powinienem zaplanowac operacje
                              _cups_count:=exec('cups_count','px_tie',_ti_oper);
                              _next_cup:=1;

::                            Wyznaczam proporcje miedzy zasobami
                              _plres_prop:=exec('plres_prop','px_tie',PX_KONT.PL_RES,PL_OZ.PL_RES);
                              {? _plres_prop<=0
                              || _plres_prop:=1
                              ?};
::                            W petli po pojemnikach dodaje wyliczone pojemnosci
                              {! _it:=1.._cups_count
                              |?
                                 _next_cup>0
                              |!

                                 {? PX_VAR.NAST_ALG=2 & _it>1
                                 || exec('cup_point_check','px_plan',PX_KONT.ref(),PX_CUP.TM_START,_dir,PX_CAL,PL_OZ.PL_RES)>0
                                 ?};
                                 _can_continue:=exec('interval2pxpoz','px_tie',_ti_oporg,_dir,_kal_nazw,_pl_oper,_px_obj,,_plres_prop);

                                 {? _can_continue>0
                                 || _next_cup:=PX_CUP.next()
                                 || _next_cup:=0
                                 ?}
                              !}
                           ||
                              {? _tab=PX_CAL
                              || _nast_alg:=PX_VAR.NAST_ALG;
                                 PX_VAR.NAST_ALG:=3;
::                               Jeżeli nie znalazłem kalendarza to pewnie dlatego że w PX coś zaplanowane w tym czasie
::                               zmieniam algorytm następstwa i planuję tam ponownie na siłę
                                 exec('ploper2pxpoz','px_tie',_pl_oper,_px_ver,0);
                                 PX_VAR.NAST_ALG:=_nast_alg;
                                 ~~
                              ||
                                 _msg:='Nie powiodła się synchronizacja: Plan operacyjny->Plan strategiczny. ';
                                 {? _tab=PX_CUP
                                 || _msg+='Nie znaleziono pojemnika o czasie: '+exec('to_string','#tm_stamp',_start)
                                 |? _tab=PX_CAL
                                 || _msg+='Nie znaleziono wolnego zapisu kalendarza o czasie: '+exec('to_string','#tm_stamp',_start)+' na zasobie: '+PX_KONT.SYMBOL
                                 ?};
                                 KOMM.error(_msg,0,1)
                              ?};
                              ~~
                           ?}
                        || _msg:='Nie powiodła się synchronizacja: Plan operacyjny->Plan strategiczny. ';
                           _msg+='Nie znaleziono aktywnego zasobu rzeczywistego: '+PX_KONT.SYMBOL+' '+PX_KONT.NAZWA;
                           pxkomm.error(_msg);
                           KOMM.error(_msg,0,1)
                        ?}
                     || _msg:='Nie powiodła się synchronizacja: Plan operacyjny->Plan strategiczny. ';
                        _msg+='Nie znaleziono w Planie strategicznym zasobu odpowiadającemu zasobowi Planu operacyjnego: '+PL_OZ.PL_RES().SYM;
                        pxkomm.error(_msg);
                        KOMM.error(_msg,0,1)
                     ?};
                     _konty.next() & _can_continue>0
                  !}
               || _can_continue:=0
               ?};
               PL_OZ.next()
            !}
         ?};
         PL_OZ.cntx_pop()
      ?}
   ?}
?};

{? _can_continue>0
|| _result:=1
?};

PX_OBJ.cntx_pop();
ZL.cntx_pop();
ZK_P.cntx_pop();
PL_PART.cntx_pop();
PX_KONT.cntx_pop();
PX_CUP.cntx_pop();
PX_VER.cntx_pop();
PL_OPER.cntx_pop();
PL_RES.cntx_pop();
PX_CAL.cntx_pop();
_result


\plogr2pxpoz
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: W Planie strategicznym tworzy PX_POZy na podstawie PL_OGRa, usuwajac stare pozycje jesli istnialy
::   WE: _a - PL_OGR.ref()
::       _b - PX_VER.ref() - wersja w ktorej tworzyc
::       _c - INTEGER      - 0/1 - czy ustalać wartość zmiennej PX_VAR.NAST_ALG
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_pl_ogr:=_a;
_px_ver:=_b;
_nast_alg:=1;
{? var_pres('_c')=type_of(0)
|| _nast_alg:=_c
?};
{? _nast_alg>0
|| exec('opernast_init','px_init')
?};

_result:=0;
_can_continue:=0;
PX_VAR.P500380:=exec('get','#params',500380,type_of(''));
PX_VAR.P500381:=exec('get','#params',500381,type_of(''));
PX_CAL.cntx_psh();
PX_CUP.cntx_psh();
PX_KONT.cntx_psh();
PL_OGR.cntx_psh(); PL_OGR.clear();
PX_VER.cntx_psh(); PX_VER.clear();
PX_OBJ.cntx_psh();
GROP.cntx_psh();

{? PX_VER.seek(_px_ver) & PL_OGR.seek(_pl_ogr)
||
:: Na razie PL_OPERy planuje zawsze do przodu
   _dir:=1;

   _kal_nazw:=PL_OGR.PL_RES().KAL_NAZW;

:: Wyszukiwanie lub zakladanie PX_OBJ
   _px_obj:=null();
   {? PL_OGR.GROP<>null()
   || _px_obj:=exec('get_grop_object','px_obj',PL_OGR.GROP);
      {? _px_obj=null()
      || PL_OGR.GROP();
         exec('grop2obj','px_obj');
         _px_obj:=exec('get_grop_object','px_obj',PL_OGR.GROP)
      ?}
   ?};

   _ti_ver:=exec('interval','#interval');
   _ti_ver.START:=PX_VER.TM_START;
   _ti_ver.END:=PX_VER.TM_END;

:: Najpierw usuwam z wersji wszystkie PX_POZy powiazane z tym plogrem, jesli jakies istnialy
   _can_continue:=exec('plogr_clear','px_poz',_pl_ogr,_px_ver);

   {? _can_continue>0
   ||
      _ti_oporg:=exec('interval','#interval');
      _ti_oporg.START:=PL_OGR.TM_START;
      _ti_oporg.END:=PL_OGR.TM_END;
      _dur_oporg:=exec('interval_dur','#interval',_ti_oporg);

::    Musze zaplanowac tylko takie operacje ktore przecinaja zakres wersji
::    i tylko w zakresie w ktorym operacja i wersja sie przecinaja
      _ti_oper:=exec('intervals_and','#interval',_ti_ver,_ti_oporg);
      _dur_oper:=exec('interval_dur','#interval',_ti_oper);
      {? _dur_oper>0
      ||
::       Przechodze z PL_RESa na PX_KONTa
::       Znajduje kontener w wersji glownej planu strategicznego
         {? var_pres('_konty')>100
         || obj_del(_konty)
         ?};
         _konty:=exec('plres2pxkont','px_tie',PL_OGR.PL_RES,_px_ver);

         {? type_of(_konty)>0 & _konty.first()
         ||
            {!
            |?
               PX_KONT.clear();
               {? PX_KONT.seek(_konty.REF,_konty.NAME)
               ||
::                Znajduje kontener w wersji docelowej
                  PX_KONT.index('ACT');
                  PX_KONT.prefix('T',_px_ver,PX_KONT.SYMBOL,);
                  {? PX_KONT.first()
                  ||
::                   Jestem na docelowym kontenerze
::                   Szukam pierwszego pojemnika od ktorego bede planowal
                     {? var_pres('_tab')>100
                     || obj_del(_tab)
                     ?};
                     _tab:=~~;
                     {? PX_VAR.NAST_ALG=2
                     ||
::                      Algorytm nakładkowania metodą proporcji czasowej działa w oparciu o PX_CAL
                        _tab:=PX_CAL
                     ||
::                      Standardowe planowanie działa w oparciu o PX_CUP
                        _tab:=PX_CUP
                     ?};
                     _start:=0;
                     {? _dir>0
                     || _start:=_ti_oper.START
                     || _start:=_ti_oper.END
                     ?};

                     {? exec('cup_point_check','px_plan',PX_KONT.ref(),_start,_dir,_tab,PL_OGR.PL_RES)>0
                     ||
                        {? _tab=PX_CAL
                        ||
::                         Jeżeli operuję na PX_CAL to i tak muszę ustawić indeks na PX_CUP
                           exec('cup_point_check','px_plan',PX_KONT.ref(),_start,_dir,PX_CUP,PL_OZ.PL_RES);
                           PX_CAL.PX_CUP()
                        ?};

::                      Wyznaczam ilosc pojemnikow w ktorych powinienem zaplanowac operacje
                        _cups_count:=exec('cups_count','px_tie',_ti_oper);
                        _next_cup:=1;

::                      Wyznaczam proporcje miedzy zasobami
                        _plres_prop:=exec('plres_prop','px_tie',PX_KONT.PL_RES,PL_OGR.PL_RES);
                        {? _plres_prop<=0
                        || _plres_prop:=1
                        ?};

::                      W petli po pojemnikach dodaje wyliczone pojemnosci
                        {! _it:=1.._cups_count
                        |?
                           _next_cup>0
                        |!
                           {? PX_VAR.NAST_ALG=2 & _it>1
                           || exec('cup_point_check','px_plan',PX_KONT.ref(),PX_CUP.TM_START,_dir,PX_CAL,PL_OZ.PL_RES)>0
                           ?};

                           _can_continue:=exec('interval2pxpoz','px_tie',_ti_oporg,_dir,_kal_nazw,null(),_px_obj,_pl_ogr,_plres_prop);

                           {? _can_continue>0
                           || _next_cup:=PX_CUP.next()
                           || _next_cup:=0
                           ?}
                        !}
                     ||
                        {? _tab=PX_CAL
                        || _nast_alg:=PX_VAR.NAST_ALG;
                           PX_VAR.NAST_ALG:=3;
::                         Jeżeli nie znalazłem kalendarza to pewnie dlatego że w PX coś zaplanowane w tym czasie
::                         zmieniam algorytm następstwa i planuję tam ponownie na siłę
                           exec('plogr2pxpoz','px_tie',_pl_ogr,_px_ver,0);
                           PX_VAR.NAST_ALG:=_nast_alg;
                           ~~
                        || _msg:='Nie powiodła się synchronizacja: Plan operacyjny->Plan strategiczny. ';
                           {? _tab=PX_CUP
                           || _msg+='Nie znaleziono pojemnika o czasie: '+exec('to_string','#tm_stamp',_start)
                           |? _tab=PX_CAL
                           || _msg+='Nie znaleziono wolnego zapisu kalendarza o czasie: '+exec('to_string','#tm_stamp',_start)+' na zasobie: '+PX_KONT.SYMBOL
                           ?};
                           KOMM.error(_msg,0,1)
                        ?}
                     ?}
                  || _msg:='Nie powiodła się synchronizacja: Plan operacyjny->Plan strategiczny. ';
                     _msg+='Nie znaleziono aktywnego zasobu rzeczywistego: '+PX_KONT.SYMBOL+' '+PX_KONT.NAZWA;
                     pxkomm.error(_msg);
                     KOMM.error(_msg,0,1)
                  ?}
               || _msg:='Nie powiodła się synchronizacja: Plan operacyjny->Plan strategiczny. ';
                  _msg+='Nie znaleziono w Planie strategicznym zasobu odpowiadającemu zasobowi Planu operacyjnego: '+PL_OGR.PL_RES().SYM;
                  pxkomm.error(_msg);
                  KOMM.error(_msg,0,1)
               ?};
               _konty.next() & _can_continue>0
            !}
         ?}
      ?}
   ?}
?};

{? _can_continue>0
|| _result:=1
?};
GROP.cntx_pop();
PX_OBJ.cntx_pop();
PX_KONT.cntx_pop();
PX_CUP.cntx_pop();
PX_CAL.cntx_pop();
PX_VER.cntx_pop();
PL_OGR.cntx_pop();
_result


\cups_count
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Wyznacza ilosc pojemnikow potrzebna do tego aby zmiescic operacje w planie reprezentowana
::       przez interwal czasu
::       KONTEKST PRACY - Pojemnik od ktorego zaczac
::   WE: _a - obj_new() - interwal czasu reprezentowany przez operacje
::       [_b] - TABLE - tabela w której będą iterowane rekordy (domyślnie PX_CUP)
::   WY: INTEGER - liczba pojemnikow ktore zajmie
::----------------------------------------------------------------------------------------------------------------------
_ti_oper:=_a;

_tab:=~~;
{? var_pres('_b')>0
|| _tab:=_b
|| _tab:=PX_CUP
?};

_result:=0;

_tab.cntx_psh();
_can_continue:=1;
{!
|? {? _tab.TM_START>_ti_oper.END
   || _can_continue:=0
   || _result+=1;
      _can_continue:=_tab.next()
   ?};
   _can_continue>0
!};
_tab.cntx_pop();
_result


\count_oper_kor
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Oblicza jakie ilosci w WPP nalezy odjac z paczki poniewaz zostaly zaplanowane na podstawie planu operacyjnego
::   WE: _a - PX_GRP.ref
::   WY: REAL - 0..1 - proporcja przez ktora nalezy przemnozyc paczke technologiczna aby skorygowac ilosci do planu
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

_result:=1;

PX_GRP.cntx_psh(); PX_GRP.clear();
PX_CONN.cntx_psh();
PX_OBJ.cntx_psh();
{? PX_GRP.seek(_px_grp) & PX_GRP.ILOSC>0
||
   _il_oper:=exec('px_grp_oper','px_tie',PX_GRP.ref());
:: Obliczanie wyniku
   _result:=1-(_il_oper/PX_GRP.ILOSC);
   {? _result>1
   || _result:=1
   ?};
   {? _result<0
   || _result:=0
   ?}
?};
PX_OBJ.cntx_pop();
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
_result


\bound_sym_mps
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca nazwe granicy czasowej wynikajacej z planu strategicznego dla PL_OPERow
::       UWAGA!!! - modyfikacja tej nazwy wymaga tez modyfikacji nazwy tej granicy w java
::       w pliku PlozConflictBounds.java
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'Plan strategiczny'


\zlec_cmplx
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy podane zlecenie jest zleceniem zlozonym lub jest skladnikiem zlecenia zlozonego
::   WE: _a - ZL.ref
::   WY: 0 - zlecenie jest proste
::       1 - zlecenie jest zlozone, lub jest skladnikiem zlozonego
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=0;

ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
|| {? ZL.RODZAJ='Z'
   || _result:=1
   || {? ZL.NRNZL<>0
      || _result:=1
      ?}
   ?}
?};
ZL.cntx_pop();
_result


\zlec_cmplx_sql
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy podane zlecenie jest zleceniem zlozonym lub jest skladnikiem zlecenia zlozonego
::   WE: _a - $ZL.ref
::   WY: 0 - zlecenie jest proste
::       1 - zlecenie jest zlozone, lub jest skladnikiem zlozonego
::----------------------------------------------------------------------------------------------------------------------
_zl_sql:=_a;

_result:=0;
_zl:=exec('FindAndGet','#table',ZL,_zl_sql,,,null());
{? _zl<>null()
|| _result:=exec('zlec_cmplx','px_tie',_zl)
?};
_result


\zkp_termin
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca termin realizacji podanego zamowienia
::   WE: _a - $ZK_P.ref()
::   WY: STRING - termin realizacji w formacie 'YYYY/MM/DD HH:MM:SS'
::----------------------------------------------------------------------------------------------------------------------
_zkp_sql:=_a;

_result:='';
ZK_P.cntx_psh();
ZK_P.clear();
{? _zkp_sql<>''
|| {? ZK_P.seek(_zkp_sql,ref_name(_zkp_sql))
   || _tm_termin:=0;
      {? ZK_P.PL_DATA<>date(0,0,0)
      || _tm_termin:=exec('create','#tm_stamp',ZK_P.PL_DATA,ZK_P.PL_TIME)
      || _tm_termin:=exec('create','#tm_stamp',ZK_P.DT,time(0,0,0))
      ?};
      {? _tm_termin>0
      || _result:=exec('to_string','#tm_stamp',_tm_termin)
      ?}
   ?}
?};
ZK_P.cntx_pop();
_result


\zlec_termin
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca termin realizacji podanego zlecenia
::   WE: _a - $ZL.ref()
::   WY: STRING - termin realizacji w formacie 'YYYY/MM/DD HH:MM:SS'
::----------------------------------------------------------------------------------------------------------------------
_zl_sql:=_a;

_result:='';
ZL.cntx_psh();
ZL.clear();
_zl:=exec('FindAndGet','#table',ZL,_zl_sql,,,null());
{? _zl<>null()
|| {? ZL.seek(_zl)
   || _result:=exec('zlec_termin2','px_tie')
   ?}
?};
ZL.cntx_pop();
_result


\zlec_termin2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca termin realizacji aktualnego zlecenia
::       Kontekst pracy - zlecenie
::   WY: STRING - termin realizacji w formacie 'YYYY/MM/DD HH:MM:SS'
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_tm_termin:=0;
{? ZL.PL_DATA<>date(0,0,0)
|| _tm_termin:=exec('create','#tm_stamp',ZL.PL_DATA,ZL.PL_TIME)
|| _tm_termin:=exec('create','#tm_stamp',ZL.DTR,time(0,0,0))
?};
{? _tm_termin>0
|| _result:=exec('to_string','#tm_stamp',_tm_termin)
?};
_result


\grop_termin
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [23.25]
:: OPIS: Zwraca termin realizacji grupy operacji
::   WE: [_a] - GROP.ref - grupa operacji
::   WY: STRING - termin realizacji w formacie 'YYYY/MM/DD HH:MM:SS'
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(GROP.ref())
|| _ref:=_a
?};

_result:='';
_tm_termin:=0;
_can_continue:=1;

GROP.cntx_psh();
{? _ref<>null()
|| GROP.prefix();
   {? GROP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? GROP.PL_DATA<>date(0,0,0)
   || _tm_termin:=exec('create','#tm_stamp',GROP.PL_DATA,GROP.PL_TIME)
   ?};
   {? _tm_termin>0
   || _result:=exec('to_string','#tm_stamp',_tm_termin)
   ?}
?};
GROP.cntx_pop();
_result


\oper_bounds_upd
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Aktualizuje daty graniczne na ploperach na podstawie planu strategicznego
::   WE: _a - PX_VER.ref() - na podstawie jakiej wersji aktualizowac daty
::       [_b] - _args - argumenty dla funkcji raportujacej progress
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ver:=_a;
_argsprog:={?_>=2 || _b || exec('plan_progress_a','px_logix') ?};

_result:=0;
_can_continue:=1;

PX_VER.cntx_psh(); PX_VER.clear();
PX_CONN.cntx_psh();
PX_OBJ.cntx_psh();
PL_PART.cntx_psh();
PL_OPER.cntx_psh();
PL_PART.index('PX_OBJ');
PL_OPER.index('PL_PART');
{? PX_VER.seek(_ver)
|| PX_CONN.index('VER');
   PX_CONN.prefix(PX_VER.ref());
   {? PX_CONN.first()
   || _argsprog.SIZELOC:=PX_CONN.size();
      {!
      |? PL_PART.prefix(PX_CONN.PX_OBJ);
         _mps_start:=exec('obj_start','px_tie',PX_CONN.PX_OBJ,_ver);
         _mps_end:=exec('obj_end','px_tie',PX_CONN.PX_OBJ,_ver);

         {? PL_PART.first()
         || {!
            |? PL_OPER.prefix(PL_PART.ref());
               {? PL_OPER.first()
               || {!
                  |?
::                   Nanosze zmiany na granice czasowe plopera tylko wynikajace z planu stateg
                     {? PL_OPER.SYM_MIN=exec('bound_sym_mps','px_tie')
                     || {? _mps_start>0
                        || PL_OPER.MINDATE:=exec('tm_stamp2date','#tm_stamp',_mps_start);
                           PL_OPER.MINTIME:=exec('tm_stamp2time','#tm_stamp',_mps_start)
                        || PL_OPER.MINDATE=date(0,0,0);
                           PL_OPER.MINTIME=time(0,0,0)
                        ?}
                     ?};
                     {? PL_OPER.SYM_MAX=exec('bound_sym_mps','px_tie')
                     || {? _mps_end>0
                        || PL_OPER.MAXDATE:=exec('tm_stamp2date','#tm_stamp',_mps_end);
                           PL_OPER.MAXTIME:=exec('tm_stamp2time','#tm_stamp',_mps_end)
                        || PL_OPER.MAXDATE=date(0,0,0);
                           PL_OPER.MAXTIME=time(0,0,0)
                        ?}
                     ?};
                     _can_continue:=PL_OPER.put();
                     PL_OPER.next() & _can_continue>0
                  !}
               ?};
               PL_PART.next() & _can_continue>0
            !}
         ?};
::       raportuje progress
         {? _can_continue>0
         || _argsprog.PROGLOC+=1;
            _can_continue:=exec('plan_progress','px_logix',_argsprog,1)
         ?};
         PX_CONN.next() & _can_continue>0
      !}
   ?}
?};
PL_OPER.cntx_pop();
PL_PART.cntx_pop();
PX_OBJ.cntx_pop();
PX_CONN.cntx_pop();
PX_VER.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result


\plopers2px
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Inicjuje wersje glowna planu strategicznego wszystkimi ploperami z planu operacyjnego
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_mainver:=exec('get_mainversion','px_ver');

_can_continue:=1;
_result:=0;

PL_OPER.cntx_psh();
PL_OPER.index('TM_START');
PL_OPER.clear();
{? PL_OPER.first()
|| {!
   |? _can_continue:=exec('ploper2pxpoz','px_tie',PL_OPER.ref(),_mainver);
      PL_OPER.next() & _can_continue>0
   !}
?};
PL_OPER.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result


\plres2pxkont
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca powiazanego z PL_RESem PX_KONTa
::   WE: _a - PL_RES.ref
::       _b - PX_VER.ref - wersja planu z ktorej kontener zwrocic
::   WY: tab_tmp - tabela tymczasowa z refami PX_KONTow powiazanych z PL_RESEM o strukturze:
::            REF - INTEGER - #PX_KONT.ref
::            NAME - STRING[8] - nazwa maski
::            SQL_REF - STRING[16] - $PX_KONT.ref()
::----------------------------------------------------------------------------------------------------------------------
_plres:=_a;
_px_ver:=_b;

_result:=exec('px_kont_tab_ref','px_tie');
_can_continue:=1;

PL_RES.cntx_psh(); PL_RES.clear();
PX_KONT.cntx_psh();
PX_KONT.index('PL_RES');

{? PL_RES.seek(_plres)
||
   PX_KONT.prefix(_px_ver,_plres);
   {? PX_KONT.first()
   || {? PX_KONT.A='T'
      || _result.blank();
         _result.REF:=#PX_KONT.ref();
         _result.NAME:=ref_name(PX_KONT.ref());
         _result.SQL_REF:=$PX_KONT.ref();
         _result.add();
         _can_continue:=0
      ?}
   ?};

:: Jesli nie znalazlo bezposredniego polaczenia to musze kombinowac
   {? _can_continue>0
   ||
::    Sprawdzam czy PL_RES jest stanowiskiem, bo jesli tak to moze byc skladnikiem gniazda badz linii
      {? PL_RES.FROM_STA<>null()
      ||
::       1. Sprawdzam czy jest skladnikiem gniazda
         TWRKZPO.cntx_psh();
         TWRKZPO.index('ELEMENTG');
         TWRKZPO.prefix(PL_RES.FROM_STA);
         {? TWRKZPO.first()
         ||
            _size:=TWRKZPO.size();
            {!
            |?
::             Szukam PL_RESa gniazda
               _gniazdo:=exec('get_plres','po_plan','G',TWRKZPO.GRUPA);

               {? _gniazdo<>null()
               ||
::                Przechodze z PL_RESa gniazda na PX_KONT
::                !!! REKURENCJA !!!
                  {? var_pres('_res_gn')>100
                  || obj_del(_res_gn)
                  ?};
                  _res_gn:=exec('plres2pxkont','px_tie',_gniazdo,_px_ver);

                  {? _res_gn.first()
                  || {!
                     |? _result.blank();
                        _result.REF:=_res_gn.REF;
                        _result.NAME:=_res_gn.NAME;
                        _result.SQL_REF:=_res_gn.SQL_REF;
                        _can_continue:=_result.add();
                        _res_gn.next() & _can_continue>0
                     !}
                  ?}
               ?};
               TWRKZPO.next()
            !}
         ?};
         TWRKZPO.cntx_pop();

::       2. Sprawdzam czy jest skladnikiem linii
         {? _can_continue>0
         ||
            LPRODP.cntx_psh();
            LPRODP.index('SREF');
            LPRODP.prefix(PL_RES.FROM_STA);
            {? LPRODP.first()
            ||
               {!
               |?
::                Szukam PL_RESa linii
                  _linia:=exec('get_plres','po_plan','L',LPRODP.LPROD);

                  {? _linia<>null()
                  ||
::                   Przechodze z PL_RESa linii na PX_KONT
::                   !!! REKURENCJA !!!
                     {? var_pres('_res_ln')>100
                     || obj_del(_res_ln)
                     ?};
                     _res_ln:=exec('plres2pxkont','px_tie',_linia,_px_ver);

                     {? _res_ln.first()
                     || {!
                        |? _result.blank();
                           _result.REF:=_res_ln.REF;
                           _result.NAME:=_res_ln.NAME;
                           _result.SQL_REF:=_res_ln.SQL_REF;
                           _can_continue:=_result.add();
                           _res_ln.next() & _can_continue>0
                        !}
                     ?}
                  ?};
                  LPRODP.next()
               !}
            ?};
            LPRODP.cntx_pop()
         ?}
      ?};
::    Sprawdzam czy PL_RES jest pracownikiem bo jesli tak to moze byc czlonkiem brygady
      {? _can_continue>0
      ||
         {? PL_RES.FROM_PRA<>null()
         ||
::          Sprawdzam czy pracownik jest czlonkiem brygady
            ZLBS.cntx_psh();
            ZLBS.index('PODB');
            ZLBS.prefix(PL_RES.FROM_PRA);
            {? ZLBS.first()
            ||
               {!
               |?
::                Szukam PL_RESa brygady
                  _brygada:=exec('get_plres','po_plan','B',ZLBS.BR);
                  {? _brygada<>null()
                  ||
::                   Przechodze z PL_RESa brygady na PX_KONT
::                   !!! REKURENCJA !!!
                     {? var_pres('_res_br')>100
                     || obj_del(_res_br)
                     ?};
                     _res_br:=exec('plres2pxkont','px_tie',_brygada,_px_ver);

                     {? _res_br.first()
                     || {!
                        |? _result.blank();
                           _result.REF:=_res_br.REF;
                           _result.NAME:=_res_br.NAME;
                           _result.SQL_REF:=_res_br.SQL_REF;
                           _can_continue:=_result.add();
                           _res_br.next() & _can_continue>0
                        !}
                     ?}
                  ?};
                  ZLBS.next()
               !}
            ?};
            ZLBS.cntx_pop()
         ?}
      ?}
   ?}
?};
PL_RES.cntx_pop();
PX_KONT.cntx_pop();
_result


\px_kont_tab_ref
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=tab_tmp(   ,'REF','INTEGER','ref'
                  ,'NAME','STRING[8]','maska'
                  ,'SQL_REF','STRING[16]','SQL ref');
_result


\px_grp_oper
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zlicza ilosc w jakiej PX_GRP (wszystkie jego PX_CONNy) zostaly zaplanowane w Planie operacyjnym
::   WE: _a - PX_GRP.ref()
::   WY: REAL - ilosc w Planie operacyjnym
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

_il_oper:=0;

PX_GRP.cntx_psh(); PX_GRP.clear();
PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');

{? PX_GRP.seek(_px_grp)
|| PX_CONN.prefix(PX_GRP.ref());
:: Zbieram ilosci dla calej grupy w planie operacyjnym
   {? PX_CONN.first()
   || {!
      |? _prop_il:=PX_CONN.ILOSC/PX_GRP.ILOSC;
         {? _prop_il>1
         || _prop_il:=1
         ?};
         {? _prop_il<0
         || _prop_il:=0
         ?};

::       Podczytanie PX_OBJ
         PX_CONN.PX_OBJ();

         _il_obj:=0;
         {? PX_OBJ.ZL<>null()
         || _il_obj:=exec('zlec_planned','po_plan',$PX_OBJ.ZL)
         |? PX_OBJ.ZK_P<>null()
         || _il_obj:=exec('zam_planned','po_plan',$PX_OBJ.ZK_P)
         |? PX_OBJ.GROP<>null()
         || _il_obj:=exec('grop_plan_il','po_ogr',PX_OBJ.GROP)
         ?};

::       Ilosci w planie operacyjnym dla obiektu sumuje dla grupy uwzgledniajac proporcje
         _il_oper+=_il_obj*_prop_il;

         PX_CONN.next()
      !}
   ?}
?};
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
_il_oper


\plres_prop
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Zwraca proporcje pomiedzy dwoma plresami, np pomiedzy gniazdem a stanowiskiem
::       Tylko jeden z podanych zasobow powinien byc zasobem zlozonym, dodatkowo zasoby powinny byc
::       ze soba powiazane w relacji zespol -> skladowa. Jezeli zasoby nie sa ze soba powiazane
::       to zostanie zwrocone 0
::   WE: _a - PL_RES.ref() - zasob1
::       _b - PL_RES.ref() - zasob2
::   WY: REAL
::----------------------------------------------------------------------------------------------------------------------
_plres1:=_a;
_plres2:=_b;

_result:=0;
_can_continue:=1;

_parent:=null();
_child:=null();

_cmpx1:=exec('plres_cmplx','po_plan',_plres1);
_cmpx2:=exec('plres_cmplx','po_plan',_plres2);
{? _cmpx1>0 & _cmpx2=0
|| _parent:=_plres1;
   _child:=_plres2
?};
{? _cmpx1=0 & _cmpx2>0
|| _parent:=_plres2;
   _child:=_plres1
?};

PL_RES.cntx_psh(); PL_RES.clear();
{? _parent<>null & _child<>null()
||
   {? PL_RES.seek(_parent)
   ||
::    Stoje na nadrzednym
      _gni:=PL_RES.FROM_GNI;
      _lin:=PL_RES.FROM_LIN;
      _bry:=PL_RES.FROM_BRY;

::    1. Jesli nadrzedny jest jest gniazdem
      {? _gni<>null()
      ||
         PL_RES.cntx_psh();
         PL_RES.clear();
         {? PL_RES.seek(_child)
         ||
::          Jesli podrzedny jest stanowiskiem to sprawdzam czy nalezy do tego gniazda
            {? PL_RES.FROM_STA<>null()
            ||
               TWRKZPO.cntx_psh();
               TWRKZPO.index('ELEMENTG');
               TWRKZPO.prefix(PL_RES.FROM_STA);
               {? TWRKZPO.first()
               ||
                  {!
                  |? {? TWRKZPO.GRUPA<>null() & TWRKZPO.GRUPA=_gni
                     ||
::                      Pobieram rozmiar gniazda
                        TWRKZPO.index('GRUPA');
                        TWRKZPO.prefix(TWRKZPO.GRUPA);
                        _size:=TWRKZPO.size();
                        _result:=1/_size;
                        _can_continue:=0
                     ?};
                     TWRKZPO.next() & _can_continue>0
                  !}
               ?};
               TWRKZPO.cntx_pop()
            ?}
         ?};
         PL_RES.cntx_pop()
      ?};

::    2. Jesli nadrzedny jest jest linia
      {? _lin<>null()
      ||
         PL_RES.cntx_psh();
         PL_RES.clear();
         {? PL_RES.seek(_child)
         ||
::          Jesli podrzedny jest stanowiskiem to sprawdzam czy nalezy do tej linii
            {? PL_RES.FROM_STA<>null()
            ||
               LPRODP.cntx_psh();
               LPRODP.index('SREF');
               LPRODP.prefix(PL_RES.FROM_STA);
               {? LPRODP.first()
               ||
                  {!
                  |?
                     {? LPRODP.LPROD<>null() & LPRODP.LPROD=_lin
                     ||
::                      Pobieram rozmiar linii
                        LPRODP.index('LL');
                        LPRODP.prefix(LPRODP.LPROD);
                        _size:=LPRODP.size();
                        _result:=1/_size;
                        _can_continue:=0
                     ?};
                     LPRODP.next() & _can_continue>0
                  !}
               ?};
               LPRODP.cntx_pop()
            ?}
         ?};
         PL_RES.cntx_pop()
      ?};

::    3. Jesli nadrzedny jest jest brygada
      {? _bry<>null()
      ||
         PL_RES.cntx_psh();
         PL_RES.clear();
         {? PL_RES.seek(_child)
         ||
::          Jesli podrzedny jest pracownikiem to sprawdzam czy nalezy do tej brygady
            {? PL_RES.FROM_PRA<>null()
            ||
               ZLBS.cntx_psh();
               ZLBS.index('PODB');
               ZLBS.prefix(PL_RES.FROM_PRA);
               {? ZLBS.first()
               ||
                  {!
                  |? {? ZLBS.BR<>null() & ZLBS.BR=_bry
                     ||
::                      Pobieram rozmiar brygady
                        ZLBS.index('BPOD');
                        ZLBS.prefix(ZLBS.BR);
                        _size:=ZLBS.size();
                        _result:=1/_size;
                        _can_continue:=0
                     ?};
                     ZLBS.next() & _can_continue>0
                  !}
               ?};
               ZLBS.cntx_pop()
            ?}
         ?};
         PL_RES.cntx_pop()
      ?}
   ?}
?};
PL_RES.cntx_pop();
_result


\can_move_ploper
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy dana pozycja planu operacyjnego mozna bezpiecznie przesunac - czy pozwalaja na to wykonania
::   WE: _a - PL_OPER.ref()
::       [_b] - PX_VER.ref() - wersja w ktorej sprawdzac, jesli nie podane to sprawdzac w glownej
::   WY: 0 - nie mozna przesuwac - przyczyna nieznana
::       1 - sukces
::       -3 - nie mozna przesuwac - w planie strategicznym istnieja wykonania
::       -4 - nie mozna przesuwac - w planie operacyjnym istnieja wykonania
::----------------------------------------------------------------------------------------------------------------------
_pl_oper:=_a;

_px_ver:=exec('get_mainversion','px_ver');
{? var_pres('_b')=type_of(PX_VER.ref())
|| _px_ver:=_b
?};

_result:=1;
_can_continue:=1;

{? exec('get','#params',8080,type_of(''),OPERATOR.USER)<>'T'
||
:: Sprawdzam czy istnieja PL_WYKI do PL_OPERa
   {? exec('has_wyk_ploper','po_wyk',_pl_oper)>0
   || _can_continue:=0;
      _result:=-4
   ?};

:: Sprawdzam czy istnieja PX_WYKi do PL_OPERa
   {? _can_continue>0
   ||
      PX_POZ.cntx_psh();
      PX_POZ.index('PL_OPER2');
      PX_POZ.prefix(_pl_oper,_px_ver);
      {? PX_POZ.first()
      || {!
         |?
::          Jezeli do PX_POZa powiazanego z PL_OPERem istnieja wykonania to nie pozwalam przesuwac
            {? exec('has_wyki','px_poz',PX_POZ.ref())>0
            || _can_continue:=0;
               _result:=-3
            ?};
            PX_POZ.next() & _can_continue>0
         !}
      ?};
      PX_POZ.cntx_pop()
   ?}
?};
_result


\can_move_plogr
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy dana pozycja planu operacyjnego mozna bezpiecznie przesunac - czy pozwalaja na to wykonania
::   WE: _a - PL_OGR.ref()
::       [_b] - PX_VER.ref() - wersja w ktorej sprawdzac, jesli nie podane to sprawdzac w glownej
::   WY: 0 - nie mozna przesuwac - przyczyna nieznana
::       1 - sukces
::       -3 - nie mozna przesuwac - w planie strategicznym istnieja wykonania
::       -4 - nie mozna przesuwac - w planie operacyjnym istnieja wykonania
::----------------------------------------------------------------------------------------------------------------------
_pl_ogr:=_a;

_px_ver:=exec('get_mainversion','px_ver');
{? var_pres('_b')=type_of(PX_VER.ref())
|| _px_ver:=_b
?};

_result:=1;
_can_continue:=1;

{? exec('get','#params',8080,type_of(''),OPERATOR.USER)<>'T'
||
:: Sprawdzam czy istnieja PL_WYKI do PL_OGRa
   {? exec('has_wyk_plogr','po_wyk',_pl_ogr)>0
   || _can_continue:=0;
      _result:=-4
   ?};

:: Sprawdzam czy istnieja PX_WYKi do PL_OGRa
   {? _can_continue>0
   ||
      PX_POZ.cntx_psh();
      PX_POZ.index('PL_OGR2');
      PX_POZ.prefix(_pl_ogr,_px_ver);
      {? PX_POZ.first()
      || {!
         |?
::          Jezeli do PX_POZa powiazanego z PL_OGRem istnieja wykonania to nie pozwalam przesuwac
            {? exec('has_wyki','px_poz',PX_POZ.ref())>0
            || _can_continue:=0;
               _result:=-3
            ?};
            PX_POZ.next() & _can_continue>0
         !}
      ?};
      PX_POZ.cntx_pop()
   ?}
?};
_result


\px_poz_oper_tie
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Wiaze pozycje planu powstale na podstawie planu operacyjnego z obiektem PX_GRP
::   WE: [_a] - PX_GRP.ref()
::       [_b] - INTEGER - [1] - wiazac pozycje z grupa
::                        0 - usuwac powiazanie
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};
_tie:=1;
{? var_pres('_b')=type_of(0)
|| _tie:=_b
?};

_result:=0;
_can_continue:=1;

_mainver:=exec('get_mainversion','px_ver');
PX_POZ.cntx_psh();
PX_POZ.index('TM_VOBJ');
PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');
PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.clear();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_CONN.prefix(PX_GRP.ref());
   {? PX_CONN.first()
   || {!
      |?
         PX_POZ.prefix(_mainver,PX_CONN.PX_OBJ);
         {? PX_POZ.first()
         || {!
            |? {? _tie>0
               ||
                  {? PX_POZ.SRC_OPER='T' & PX_POZ.PX_GRP=null()
                  || PX_POZ.PX_GRP:=PX_GRP.ref();
                     _can_continue:=PX_POZ.put()
                  ?}
               || {? PX_POZ.SRC_OPER='T' & PX_POZ.PX_GRP<>null()
                  || PX_POZ.PX_GRP:=null();
                     _can_continue:=PX_POZ.put()
                  ?}
               ?};
               PX_POZ.next() & _can_continue>0
            !}
         ?};
         PX_CONN.next() & _can_continue>0
      !}
   ?}
?};
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
PX_POZ.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\conn_to_rs
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Dodaje do RSa element w kolejce
::   WE: _a - :RS
::       _b - STRING - filtr
::       _c - PX_CONN.ref
::       _d - ZK_P.ref()
::       _e - ZL.ref()
::       _f - GROP.ref()
::       _g - STRING - czy pobierac obiekty zaplanowane czy nie: A - wszystkie, P - zaplanowane, N - niezaplanowane
::       _h - STRING - indeks tymczasowy RSa: REF
::       _i - STRING - indeks tymczasowy RSa: ID
::   WY: 0 - obiekt nie zostal dodane do RSa
::       INTEGER>0 - ID w RS dodanego obiektu
::----------------------------------------------------------------------------------------------------------------------
_rs:=_a;
_filter:=_b;
_px_conn:=_c;
_zk_p:=_d;
_zl:=_e;
_grop:=_f;
_plan_mode:=_g;
_ndx_ref:=_h;
_ndx_id:=_i;

_add:=1;
_result:=0;
_can_continue:=1;

_mainver:=exec('get_mainversion','px_ver');

_rs.cntx_psh();
_rs.index(_ndx_ref);
M.cntx_psh();
PX_GRP.cntx_psh();
PX_CONN.cntx_psh(); PX_CONN.clear();
ZK_P.cntx_psh();
ZK_N.cntx_psh();
ZL.cntx_psh(); ZL.clear();
ZTP.cntx_psh();
GROP.cntx_psh();
GROP.prefix();

{? _filter<>''
|| _fil_lower:=-(_filter);
   {? (-PX_OBJ.SYMBOL)*_fil_lower>0
      | (-PX_OBJ.NAZWA)*_fil_lower>0
      | (-PX_OBJ.M().KTM)*_fil_lower>0
      | (-PX_OBJ.M().N)*_fil_lower>0
      | (-PX_OBJ.KH().KOD)*_fil_lower>0
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _px_obj:=null();
   _planned:=0;
   _ilosc:=0;
   {? _px_conn<>null()
   || _can_continue:=PX_CONN.seek(_px_conn);
      {? _can_continue>0
      || _ilosc:=PX_CONN.PX_OBJ().IL;
         _px_obj:=PX_CONN.PX_OBJ
      ?}
   ?};

   {? _can_continue>0 & _zk_p<>null()
   || ZK_P.use(ref_name(_zk_p));
      ZK_P.clear();
      _can_continue:=ZK_P.seek(_zk_p);
      {? _can_continue>0
      || _planned:=exec('zam_planned','po_plan',$_zk_p);
         _px_obj:=exec('get_zkp_object','px_obj',_zk_p);
         _ilosc:=ZK_P.ILZ;
         ZK_P.M();
         ZK_N.use(ref_name(ZK_P.N));
         ZK_P.N()
      ?}
   ?};

   {? _can_continue>0 & _zl<>null()
   || _can_continue:=ZL.seek(_zl);
      {? _can_continue>0
      || _planned:=exec('zlec_planned','po_plan',$ZL.ref());
         _px_obj:=exec('get_zl_object','px_obj',_zl);
         _ilosc:=ZL.IL;
         ZL.KTM();
         {? ZL.TYP().WP='W'
         ||
::          Warsztatowe póki co nie obsługiwane w planie
            _can_continue:=0
         ?}
      ?}
   ?};
   {? _can_continue>0 & _grop<>null()
   || _can_continue:=GROP.seek(_grop);
      {? _can_continue>0
      || _planned:=exec('grop_plan_il','po_ogr',GROP.ref());
         _px_obj:=exec('get_grop_object','px_obj',_grop);
         _ilosc:=GROP.IL
      ?}
   ?};

   {? _can_continue>0
   ||
      _can_continue:=0;
      {? _plan_mode='A'
      || _can_continue:=1
      |? _plan_mode='P'
      || {? _planned>0
         || _can_continue:=1
         ?}
      |? _plan_mode='N'
      || {? _planned<_ilosc
         || _can_continue:=1
         ?}
      ?}
   ?};

   {? _can_continue>0
   ||
      _parent:=0;
      _rs.blank();
      {? _zl<>null() & ZL.NRNZL<>0
      ||
::       Najpierw dodaje zlecenie nadrzedne
         ZL.cntx_psh();
         ZL.index('UNRZL');
         ZL.prefix(ZL.NRNZL);
         {? ZL.first()
         ||
::          !!! REKURENCJA !!!
            _parent:=exec('conn_to_rs','px_tie' ,_rs
                                                ,_filter
                                                ,null()
                                                ,null()
                                                ,ZL.ref()
                                                ,null()
                                                ,_plan_mode
                                                ,_ndx_ref
                                                ,_ndx_id
                                                );
            {? _parent=0
            ||
               _rs.cntx_psh();
               _rs.index(_ndx_ref);
               _rs.prefix($ZL.ref());
               {? _rs.first()
               || _parent:=_rs.ID
               ?};
               _rs.cntx_pop()
            ?}
         ?};
         ZL.cntx_pop();
         _rs.LEVEL:=2
      || _rs.LEVEL:=1
      ?};
      _rs.PAR:=_parent;

      {? _zl<>null()
      || _rs.REF:=$_zl
      |? _zk_p<>null()
      || _rs.REF:=$_zk_p
      |? _px_conn<>null()
      || _rs.REF:=$_px_conn
      ?};

::    Symbol i nazwa i ref
      {? _px_conn<>null()
      || _rs.SYM:=PX_CONN.PX_OBJ().SYMBOL;
         _rs.NAZWA:=PX_CONN.PX_OBJ().NAZWA
      |? _zl<>null()
      || _rs.SYM:=ZL.SYM;
         _rs.NAZWA:=ZL.OPIS
      |? _zk_p<>null()
      || _rs.SYM:=ZK_N.SYM+' poz. '+$ZK_P.POZ+' ('+M.KTM+')';
         _rs.NAZWA:=M.N
      ?};
      {? _grop<>null()
      || _rs.SYM:=PX_CONN.PX_OBJ().SYMBOL;
         _rs.NAZWA:=GROP.KOD;
         _rs.ILW:=GROP.ILW
      ?};

::    ID
      _rs.cntx_psh();
      _rs.clear();
      _id:=_rs.size()+1;
      _rs.cntx_pop();

      _rs.ID:=_id
   ?};

   _rs.prefix(_rs.REF);
   {? _rs.size()>0
   ||
::    Jesli juz taki jest to nie dodaje ponownie
      _can_continue:=0
   ?};

   {? _can_continue>0
   ||
::    Typ
      {? _zl<>null()
      ||
         {? exec('zl_single_plan','po_plan',_zl)>0
         || _rs.SINGLE:='T'
         || _rs.SINGLE:='N'
         ?};
         {? exec('has_grop_zl','po_ogr',_zl)>0
         || _rs.PL_GROP:='T';
            _rs.GROP_OK:=exec('can_plan','po_ogr',ZL.ref());
            _rs.GROP_OK2:=exec('can_plan2','po_ogr',ZL.ref())
         || _rs.PL_GROP:='N'
         ?};
         _ile:=exec('count_zlec_pod','po_plan',$_zl);
         {? _ile>0
         || _rs.TYP:='ZL_N'
         || _rs.TYP:='ZL_P'
         ?}
      |? _zk_p<>null()
      || _rs.TYP:='ZK_P'
      |? _grop<>null()
      || _rs.TYP:='GROP'
      ?};

::    Kolor i ilosci w planie
      _kolor:='255:255:255';
      {? _zl<>null()
      || _rs.INTERZL:=exec('interzlec_conns','po_plan',$_zl);
         _rs.PLPARTS:=exec('count_plparts','po_plan','ZL',$_zl);
         ZLZAM.cntx_psh();
         ZLZAM.index('ZLZM');
         ZLZAM.prefix(_zl);
         ZK_N.cntx_psh();
         _maskzkn:=ZK_N.name();
         {? ZLZAM.first()
         || {!
            |?
               {? 5+ZLZAM.ZAMPOZ='zkpoz'
               || ZK_P.clear();
                  {? ZK_P.seek(ZLZAM.ZAMPOZ,8+ZLZAM.ZAMPOZ)
                  || ZK_N.use((5+_maskzkn)+((8+ZLZAM.ZAMPOZ)+3));
                     _kolor:=ZK_P.N().KOLOR
                  ?}
               ?};
               ZLZAM.next()
            !}
         ?};
         ZK_N.cntx_pop();
         ZLZAM.cntx_pop()
      |? _zk_p<>null()
      || _rs.PLPARTS:=exec('count_plparts','po_plan','ZM',$_zk_p);
         _kolor:=ZK_P.N().KOLOR;

::       Dla zamówień sprawdzamy czy zostaly juz na ich podstawie wygenerowane zlecenia
         ZLZAM.cntx_psh();
         ZLZAM.clear();
         ZLZAM.index('ZMZL');
         ZLZAM.prefix($_zk_p);
         _rs.ZLECENIA:=ZLZAM.size();
         ZLZAM.cntx_pop()
      ?};
      _rs.KOLOR_B:=_kolor;

::    Ilosci i zwroty
      _rs.ILOSC_PL:=_planned;
      _rs.ILOSC:=_ilosc;
      {? _zl<>null()
      || _rs.IL_QUE:=exec('get_ilosc_que','px_obj',_mainver,_px_obj);
         _rs.MPS:=_rs.IL_QUE;
         _rs.DIR:=1
      |? _zk_p<>null()
      || _rs.IL_QUE:=exec('get_ilosc_que','px_obj',_mainver,_px_obj);
         _rs.MPS:=_rs.IL_QUE;
         _rs.DIR:=1
      |? _grop<>null()
      || _rs.IL_QUE:=exec('get_ilosc_que','px_obj',_mainver,_px_obj);
         _rs.MPS:=_rs.IL_QUE;
         _rs.DIR:=1
      |? _px_conn<>null()
      || _rs.IL_QUE:=PX_CONN.ILOSC;
         _rs.MPS:=PX_CONN.ILOSC;
         _rs.DIR:=PX_CONN.PX_GRP().DIR
      ?};
      {? ZL.RODZAJ='P' & ZL.RODZ_TEX='Z'
      ||
         _rs.IL_QUE:=_ilosc;
         _rs.MPS:=_rs.IL_QUE;
         _rs.DIR:=1
      ?};
      _ktm:=null();
      {? _zl<>null()
      ||
::       Zlecen warsztatowych nie pozwalamy poki co planowac w planie operacyjnym
::       bo nie maja technologii
         {? ZL.TYP().WP='W'
         || _add:=0
         ?};
         _mps_start:=exec('zlec_start','px_tie',_zl);
         _mps_end:=exec('zlec_end','px_tie',_zl);
         {? _mps_start>0 & _rs.MPSSTART=''
         || _rs.MPSSTART:=exec('to_string','#tm_stamp',_mps_start)
         ?};
         {? _mps_end>0 & _rs.MPSEND=''
         || _rs.MPSEND:=exec('to_string','#tm_stamp',_mps_end)
         ?};
         _pl_start:=exec('tm_start_zl','po_plan',$_zl);
         _pl_end:=exec('tm_end_zl','po_plan',$_zl);
         {? _pl_start>0
         || _rs.PL_START:=exec('to_string','#tm_stamp',_pl_start)
         ?};
         {? _pl_end>0
         || _rs.PL_END:=exec('to_string','#tm_stamp',_pl_end)
         ?};
         _complex:=exec('zlec_cmplx_sql','px_tie',$_zl);
         {? _complex>0
         || _rs.SAVE_B:=1
         ?};
         _rs.TERMIN:=exec('zlec_termin','px_tie',$_zl);
         _ktm:=exec('FindAndGet','#table',ZL,_zl,,"KTM",null())
      |? _zk_p<>null()
      || _mps_start:=exec('zkp_start','px_tie',_zk_p);
         _mps_end:=exec('zkp_end','px_tie',_zk_p);
         {? _mps_start>0 & _rs.MPSSTART=''
         || _rs.MPSSTART:=exec('to_string','#tm_stamp',_mps_start)
         ?};
         {? _mps_end>0 & _rs.MPSEND=''
         || _rs.MPSEND:=exec('to_string','#tm_stamp',_mps_end)
         ?};
         _pl_start:=exec('tm_start_zkp','po_plan',$_zk_p);
         _pl_end:=exec('tm_end_zkp','po_plan',$_zk_p);
         {? _pl_start>0
         || _rs.PL_START:=exec('to_string','#tm_stamp',_pl_start)
         ?};
         {? _pl_end>0
         || _rs.PL_END:=exec('to_string','#tm_stamp',_pl_end)
         ?};
         _rs.TERMIN:=exec('zkp_termin','px_tie',$_zk_p);
         _ktm:=exec('FindAndGet','#table',ZK_P,_zk_p,,"M",null())
      |? _grop<>null()
      || _mps_start:=exec('grop_start','px_tie',_grop);
         _mps_end:=exec('grop_end','px_tie',_grop);
         {? _mps_start>0 & _rs.MPSSTART=''
         || _rs.MPSSTART:=exec('to_string','#tm_stamp',_mps_start)
         ?};
         {? _mps_end>0 & _rs.MPSEND=''
         || _rs.MPSEND:=exec('to_string','#tm_stamp',_mps_end)
         ?};
         _pl_start:=exec('grop_tm_start','po_ogr',_grop);
         _pl_end:=exec('grop_tm_end','po_ogr',_grop);
         {? _pl_start>0
         || _rs.PL_START:=exec('to_string','#tm_stamp',_pl_start)
         ?};
         {? _pl_end>0
         || _rs.PL_END:=exec('to_string','#tm_stamp',_pl_end)
         ?};
         _rs.TERMIN:=exec('grop_termin','px_tie',_grop);
         _ktm:=null()
      ?};
      {? _parent>0
      ||
         _plparts:=_rs.PLPARTS;
         _mps:=_rs.MPS;
         _rs.cntx_psh();
         _rs.index(_ndx_id);
         _rs.prefix(_parent);
         {? _rs.first()
         ||
::          Nanosze terminy z planu stateg. na nadzlecenie
            {? _mps_start>0
            ||
               _nad_s:=exec('str2tm_stamp','libfml',_rs.MPSSTART);
               {? _nad_s=0 | _mps_start<_nad_s
               || _rs.MPSSTART:=exec('to_string','#tm_stamp',_mps_start)
               ?}
            ?};
            {? _mps_end>0
            ||
               _nad_e:=exec('str2tm_stamp','libfml',_rs.MPSEND);
               {? _nad_e=0 | _mps_end>_nad_e
               || _rs.MPSEND:=exec('to_string','#tm_stamp',_mps_end)
               ?}
            ?};

::          Nanosze terminy z planu oper. na nadzlecenie
            {? _pl_start>0
            ||
               _nad_s:=exec('str2tm_stamp','libfml',_rs.PL_START);
               {? _nad_s=0 | _pl_start<_nad_s
               || _rs.PL_START:=exec('to_string','#tm_stamp',_pl_start)
               ?}
            ?};
            {? _pl_end>0
            ||
               _nad_e:=exec('str2tm_stamp','libfml',_rs.PL_END);
               {? _nad_e=0 | _pl_end>_nad_e
               || _rs.PL_END:=exec('to_string','#tm_stamp',_pl_end)
               ?}
            ?};

::          Nanosze ilosci w planie na nadzlecenie
            _rs.PLPARTS+=_plparts;
            _rs.MPS+=_mps;

            _rs.put()
         ?};
         _rs.cntx_pop()
      ?};

      _rs.REF_M:=$_ktm;
      _rs.JM:=exec('FindAndGet','#table',M,_ktm,,"J().KOD",'');
      _rs.KTM:=exec('FindAndGet','#table',M,_ktm,,"KTM",'');
      _rs.DOKL:=exec('FindAndGet','#table',M,_ktm,,"DOKL",0);
      {? _add>0
      || {? _rs.add()
         || _result:=_rs.ID
         || _result:=0
         ?};

         {? _zl<>null() & ZL.RODZAJ<>'P' & ZL.RODZ_TEX='Z'
         ||
::          Jeżeli zlecenie złożone zaplanowane w planie strategicznym z przepisem zintegrowanym
::          to dodaję wszystkie podzlecenia żeby się mogło to zaplanować w planie operacyjnym
            ZL.cntx_psh();
            ZL.index('NRNZL');
            ZL.prefix(ZL.UNRZL);
            {? ZL.first()
            || {!
               |?
                  exec('conn_to_rs','px_tie' ,_rs
                                                ,_filter
                                                ,null()
                                                ,null()
                                                ,ZL.ref()
                                                ,null()
                                                ,_plan_mode
                                                ,_ndx_ref
                                                ,_ndx_id
                                                );
                  ZL.next()
               !}
            ?};
            ZL.cntx_pop()
         ?}
      ?}
   ?}
?};
_rs.cntx_pop();
GROP.cntx_pop();
M.cntx_pop();
PX_GRP.cntx_pop();
PX_CONN.cntx_pop();
ZK_P.cntx_pop();
ZK_N.cntx_pop();
ZL.cntx_pop();
ZTP.cntx_pop();
_result


\zgp_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Zwraca punkt czasu startu pozycji przewodnika w planie strategicznym
::   WE: _a - ZGP.ref
::   WY: REAL - tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
{? _ref<>null()
|| ZGP.clear();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? ZGP.PX_STAGE<>null()
   ||
      _px_obj:=exec('get_zl_object','px_obj',ZGP.NRZLP().ZLEC);
      _mainver:=exec('get_mainversion','px_ver');
      PX_POZ.cntx_psh();
      PX_POZ.index('PX_STAG5');
      PX_POZ.prefix(_mainver,_px_obj,ZGP.PX_STAGE);
      {? PX_POZ.first()
      || _result:=PX_POZ.TM_START
      ?};
      PX_POZ.cntx_pop()
   ?}
?};
ZGP.cntx_pop();
_result


\zgp_end
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Zwraca punkt czasu końca pozycji przewodnika w planie strategicznym
::   WE: _a - ZGP.ref
::   WY: REAL - tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
{? _ref<>null()
|| ZGP.clear();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? ZGP.PX_STAGE<>null()
   || _px_obj:=exec('get_zl_object','px_obj',ZGP.NRZLP().ZLEC);
      _mainver:=exec('get_mainversion','px_ver');
      PX_POZ.cntx_psh();
      PX_POZ.index('PX_STAG6');
      PX_POZ.prefix(_mainver,_px_obj,ZGP.PX_STAGE);
      {? PX_POZ.last()
      || _result:=PX_POZ.TM_END
      ?};
      PX_POZ.cntx_pop()
   ?}
?};
ZGP.cntx_pop();
_result


\zgp_start_sql
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Zwraca punkt czasu startu pozycji przewodnika w planie strategicznym
::   WE: _a - STRING - $ZGP.ref
::   WY: REAL - tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;
_result:=0;
ZGP.cntx_psh();
ZGP.clear();
{? ZGP.seek(_ref)
|| _result:=exec('zgp_start','px_tie')
?};
ZGP.cntx_pop();
_result


\zgp_end_sql
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Zwraca punkt czasu końca pozycji przewodnika w planie strategicznym
::   WE: _a - STRING - $ZGP.ref
::   WY: REAL - tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;
_result:=0;
ZGP.cntx_psh();
ZGP.clear();
{? ZGP.seek(_ref)
|| _result:=exec('zgp_end','px_tie')
?};
ZGP.cntx_pop();
_result


\zl_from_zam_planned
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy zlecenie powstało na podstawie zamówienia i to zamówienie jest w planie
::   WE: _a - ZL.ref() - zlecenie
::   WY: 0 - zlecenie nie powstało z zamówienia które jest w planie
::       1 - powstało
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_top:=exec('top_level','zl_link',_zl);
_mainver:=exec('get_mainversion','px_ver');

_can_continue:=1;
_result:=0;

ZK_P.cntx_psh();
ZLZAM.cntx_psh();
ZLZAM.index('ZLZM');
ZLZAM.prefix(_top);
{? ZLZAM.first()
|| {!
   |?
      {? (5+ZLZAM.ZAMPOZ)=(5+ZK_P.name())
      || ZK_P.use(8+ZLZAM.ZAMPOZ);
         ZK_P.clear();
         {? ZK_P.seek(ZLZAM.ZAMPOZ,8+ZLZAM.ZAMPOZ)
         || _zkp_obj:=exec('get_zkp_object','px_obj',ZK_P.ref());
            PX_CONN.cntx_psh();
            PX_CONN.index('VER');
            PX_CONN.prefix(_mainver,_zkp_obj);
            {? PX_CONN.first()
            || _can_continue:=0;
               _result:=1
            ?};
            PX_CONN.cntx_pop()
         ?}
      ?};
      ZLZAM.next() & _can_continue>0
   !}
?};
ZK_P.cntx_pop();
ZLZAM.cntx_pop();
_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:35 b181cdc1b963e9560a77f4953a7fbcb345e4da435a9213acfee8ddfcb921991631dbf548d8bbd68b4b092ed6848c5aa255dc383fd3ceaaa8ddd157e18fd873444f8bc58a05ebfc02e4eee080d97539e731ab0d5a0995793332466c45f071d5f57aae342ff591a37e2fe9ef793917df1fcaf96941fa14ea7cc6391e80ffaac4e6
