:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: zl_gen.fml
:: Utworzony: 25.06.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Obsługa generowania zleceń - część biblioteczna czynności TTE_PZL_DZWE, TTE_PZL_DZLG
::            Wyświetlanie i aktualizacja powiązań ze źródłem (tabela ZLZAM)
::            Plik biblioteczny - wspólna obsługa dla czynności obszaru roboczego TTE_PZL
::======================================================================================================================


\zzam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Lista źródeł (np. zamówień, planów) z jakich zostało utworzone zlecenie
::   WE: _a - rodzaj okna: 0 - tylko podgląd (bez akcji modyfikujących), 1 - dostępne wszystkie akcje
::  OLD: \zzam/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_can_modify:={? var_pres('_a')=type_of(0) || _a || 1 ?};

_zl_ref:=$ZL.ref();
_zl_sym:=ZL.SYM;

_nrn:=ZL.UNRZL;
_ktm:=ZL.KTM;
_dokl:=exec('jaka_dok_m','jm',ZL.KTM);

{? ZL.RODZAJ='P' & ZL.NRNZL<>0
|| ZL.cntx_psh();
   ZL.index('UNRZL');
   ZL.prefix(ZL.NRNZL);
   {? ZL.first()
   || {? ZL.RODZAJ<>'N' & ZL.RODZAJ<>'O' || _zl_ref:=$ZL.ref(); _zl_sym:=ZL.SYM ?}
   ?};
   ZL.cntx_pop()
?};

_tab:=sql('
   select
      cast (null as TREE_REF_TYPE) as PARENT,
      case
         when ZLZAM.SRC=\'Z\' then \':_c\'
         when ZLZAM.SRC=\'S\' then \':_d\'
         when ZLZAM.SRC=\'R\' then \':_e\'
         when ZLZAM.SRC=\'D\' then \':_f\'
      end as SOURCE,
      ZLZAM.SRC as STYP,
      space(40) as TREE_LAB,
      \'N\' as GL,
      POW.ZL,
      ZLZAM.ZL as ZZL,
      ZL.SYM as ZLSYM,
      ZL.DTR as DTR,
      ZL.KTM as KTM,
      M_Z.KTM as M_Z_KTM,
      M_Z.N as M_Z_NAZ,
      POW.ZAMPOZ,
      POW.POZPLAN,
      case
         when ZLZAM.SRC=\'Z\' then ZK_P.ILZ
         when ZLZAM.SRC=\'S\' then PSP.IL
         when ZLZAM.SRC=\'R\' then ZLZAM.ILZL
         when ZLZAM.SRC=\'D\' then PD_K.IL
      end as IL_ZAM,
      POW.ILZL as ILZL,
      case
         when ZLZAM.SRC=\'Z\' then ZK_N.SYM || \':_g\' || ZK_P.POZ
         when ZLZAM.SRC=\'S\' then PS.S
         when ZLZAM.SRC=\'D\' then PD_N.SYM
         else \'~bez źródła\'
      end as SYM,
      case
         when ZLZAM.SRC=\'Z\' then KH.KOD
         when ZLZAM.SRC=\'S\' then KH1.KOD
         else \'\'
      end as KH_KOD,
      case
         when ZLZAM.SRC=\'Z\' then KH.NAZ
         when ZLZAM.SRC=\'S\' then KH1.NAZ
         else \'\'
      end as KH_NAZ,
      case
         when ZLZAM.SRC=\'Z\' then ZK_P.DT
         when ZLZAM.SRC=\'S\' then PSOKR.DO
         when ZLZAM.SRC=\'D\' then PD_K.DD
         else TO_DATE(\'0000/00/00\')
      end as DPLANREA,
      case
         when ZLZAM.SRC=\'Z\' then M.KTM
         when ZLZAM.SRC=\'S\' then M1.KTM
         when ZLZAM.SRC=\'D\' then M2.KTM
         else \'\'
      end as M_S_KTM,
      MG_S.SYM as MG_S_SYM,
      MG_Z.SYM as MG_Z_SYM
   from ZLZAM
      left join @ZK_P using(ZLZAM.ZAMPOZ,ZK_P.REFERENCE)
       left join @ZK_N using(ZK_P.N,ZK_N.REFERENCE)
        left join KH using(ZK_N.KH,KH.REFERENCE)
         left join MG as MG_S using(ZK_P.MG,MG_S.REFERENCE)
          left join M using(ZK_P.M,M.REFERENCE)
      left join  @PSP using(ZLZAM.ZAMPOZ,PSP.REFERENCE)
       left join @PS
        left join PSOKR
         left join KH as KH1 using(PSP.KH,KH1.REFERENCE)
          left join M as M1 using(PSP.M,M1.REFERENCE)
      join ZLZAM as POW using(ZLZAM.ZAMPOZ,POW.ZAMPOZ)
       left join ZL using(POW.ZL,ZL.REFERENCE)
        left join MG as MG_Z using(ZL.MG,MG_Z.REFERENCE)
         left join M as M_Z using(ZL.KTM,M_Z.REFERENCE)
      left join PD_K using(ZLZAM.ZAMPOZ,PD_K.REFERENCE)
       left join PD_N using (PD_K.PD_N,PD_N.REFERENCE)
        left join M as M2 using(PD_K.M,M2.REFERENCE)
   where
      (not(POW.ZAMPOZ='''') or (POW.ZL=ZLZAM.ZL and ZLZAM.ZL=\':_a\'))
         and
      (ZLZAM.ZL=\':_a\' or (ZLZAM.ZL in (select ZL.REFERENCE from ZL where ZL.NRNZL=\':_b\')))
         and
      (ZL.RODZAJ=\'P\' or ZL.RODZAJ=\'Z\')
   order by 1,2,DPLANREA
',_zl_ref,_nrn,'Zamówienie'@,'Plan sprzedaży'@,'Ręcznie'@,'Plan dostaw'@,' poz. '@);

{? type_of(_tab)=type_of(~~) || exec('err_sql','#sql'); return() ?};

_ndx:=_tab.ndx_tmp(,1,'GL',,,'ZAMPOZ',,);
_ndx1:=_tab.index('?');
_tab.index(_ndx);
_tab.prefix('N');
{? _tab.first()
|| _ref:=0;
   _zampoz:='';
   _pozplan:='';
   {!
   |? {? (_tab.ZZL=_zl_ref | _tab.ZL=_tab.ZZL | _tab.ZL='')
      ||
         {? _zampoz<>_tab.ZAMPOZ
         || _zampoz:=_tab.ZAMPOZ;
            _tab.cntx_psh();
            exec('add_zam','zl_gen',_tab);
            _ref:=#_tab.ref();
            _tab.cntx_pop();
            _tab.cntx_psh();
            ZL.cntx_psh();
            ZL.prefix();
            _tab.index(_ndx);
            _tab.prefix('N',_zampoz);
            {? _tab.first()
            || {!
               |? _tab.PARENT:=_ref;
:                  _tab.KH_KOD:='';
                  {? (5+_tab.ZAMPOZ)='plprd'
                  || {? ZL.seek(_tab.ZZL,8+_tab.ZZL)
                     || {? $ZL.KTM<>_tab.KTM
                        || _tab.del()
                        || _tab.SOURCE:='Zlecono'@;
                           _tab.DPLANREA:=_tab.DTR;
                           _tab.TREE_LAB:=_tab.ZLSYM;
                           _tab.put();
                           _tab.next()
                        ?}
                     ?}
                  |? _tab.ZLSYM<>''
                  || _tab.SOURCE:='Zlecono'@;
                     _tab.DPLANREA:=_tab.DTR;
                     _tab.TREE_LAB:=_tab.ZLSYM;
                     _tab.put();
                     _tab.next()
                  || {? _pozplan*_tab.POZPLAN=0
                     || _tab.SOURCE:='W planie';
                        PL_POZ.cntx_psh();
                        PL_POZ.prefix();
                        {? PL_POZ.seek(_tab.POZPLAN,8+_tab.POZPLAN)
                        || _tab.DPLANREA:=PL_POZ.NAGL().STARTD;
                           _tab.TREE_LAB:=PL_POZ.NAGL().NAZWA
                        ?};
                        PL_POZ.cntx_pop();
                        _pozplan+=' '+_tab.POZPLAN;
                        _tab.put();
                        _tab.next()
                     || _tab.del()
                     ?}
                  ?}
               !}
            ?};
            ZL.cntx_pop();
            _tab.cntx_pop()
         ?};
         _tab.next()
      || _tab.del()
      ?}
   !}
?};
_tab.index(_ndx1);
_tab.prefix();
::_tab.fld_attr(,2);
_wer:=_tab.mk_sel('Lista źródeł, z których powstało zlecenie %1'@[_zl_sym],'P',0,'#zlzam_wer',,7,27,1);
_tab.win_fld(_wer,,'TREE_LAB',,,35,,,'Źródło'@);
_tab.win_fld(_wer,,'SOURCE',,,15,,,'Opis'@);
_tab.win_fld(_wer,,'KH_KOD',,,-8,,,'Kontrahent'@);
_tab.win_fld(_wer,@.VAR,'STRING2',,,-20,,,'Indeks materiałowy'@);
_tab.win_fld(_wer,@.VAR,'REAL',,,-20,_dokl,,'Ilość zamówiona/zlecona'@);
_tab.win_fld(_wer,@.VAR,'STRING',,,-10,,,'Na magazyn'@);
_tab.win_fld(_wer,,'DPLANREA',,,-10,,,'Data realizacji'@);
_fb:="
   _tab:=cur_tab(1,1);
   _ask:=
      {? _tab.STYP='Z'
      || FUN.ask('Czy usunąć powiązanie zlecenia %1 ze źródłową pozycją zamówienia?'@[_tab.ZLSYM])
      |? _tab.STYP='S'
      || FUN.ask('Czy usunąć powiązanie zlecenia %1 ze źródłową pozycją zamówienia sprzedaży?'@[_tab.ZLSYM])
      |? _tab.STYP='D'
      || FUN.ask('Czy usunąć powiązanie zlecenia %1 ze źródłową pozycją koszyka dostaw?'@[_tab.ZLSYM])
      ?};
   {? _ask
   || _il:=_tab.ILZL;
      ZLZAM.cntx_psh();
      ZLZAM.index('ZLPD');
::    Usunięcie bieżącego zapisu
      ZLZAM.prefix(ZL.ref(),_tab.STYP,_tab.ZAMPOZ);
      {? ZLZAM.first()
      || {? _tab.STYP='Z'
         || exec('zlzam2Rez','zamsiw_wspolne',_tab.ZAMPOZ,-1,0)
         |? _tab.STYP='D'
         || {? PD_K.seek(_tab.ZAMPOZ)
            || PD_K.ILP-=_b;
               PD_K.put()
            ?}
         |? _tab.STYP='S'
         || _obj:=obj_new('IL'); _obj.IL:=_b;
            exec('FindAndGet','#table',PSP,_tab.ZAMPOZ,,\"PSP.ILZL-=_b.IL;PSP.put()\",~~,_obj)
         ?};
         ZLZAM.del();
         _tab.del()
      ?};
::    Aktualizacja albo dopisanie ręcznego
      ZLZAM.prefix(ZL.ref(),'R');
      {? ZLZAM.first()
      || ZLZAM.ILZL+=_il;
         ZLZAM.put();
         {? _tab.find_key(0,'R')
         || _tab.ILZL+=_il;
            _tab.put()
         ?}
      || ZLZAM.blank();
         ZLZAM.ILZL:=_il;
         ZLZAM.add()
      ?};
      ZLZAM.cntx_pop()
   ?};
   ~~
";
{? _can_modify>0
|| _tab.win_act(_wer,,'Formuła','Usuń'@@,,,_fb,,,,,,'U')
?};
_tab.win_act(_wer,,'Kolejność');
_tab.win_act(_wer,,'Formuła','Legenda'@@,,,"exec('legenda','color','ZLZAM#01','__ZLZAM#01')");
_fb:="
   _tab:=cur_tab(1,1);
   {? _tab.PARENT=0 & _tab.STYP='Z'
   || ZK_P.cntx_psh(); ZL.cntx_psh();
      ZK_P.prefix();
      {? ZK_P.seek(_tab.ZAMPOZ)
      || exec('wys_pozy','zamsiw_poz',1)
      ?};
      ZK_P.cntx_pop(); ZL.cntx_pop()
   |? _tab.PARENT=0 & _tab.STYP='D'
   || PD_K.cntx_psh();
      PD_K.prefix();
      {? PD_K.seek(_tab.ZAMPOZ)
      || {? exec('tte_lic','tte')='T'
         || PD_K.win_edit('RED_PROD')
         || PD_K.win_edit('RED')
         ?};
         ATR.MJS:='PD_K';
         PD_K.display()
      ?};
      PD_K.cntx_pop()
   || _tab.display()
   ?};
   ~~
";
_tab.win_act(_wer,,'Wyświetl',,,,_fb);
_fb:="
   _tab:=cur_tab(1,1);
   _wer:=cur_win(1,1);
   _tab.actions_grayed(_wer,{? _tab.ZLSYM=ZL.SYM || '' || 'U' ?});
   {? _tab.PARENT=0
   || VAR.REAL:=_tab.IL_ZAM;
      VAR.STRING:=_tab.MG_S_SYM;
      VAR.STRING2:=_tab.M_S_KTM;
      Color.rekprzed('ZLZAM#01#01')
   || VAR.REAL:=_tab.ILZL;
      VAR.STRING:=_tab.MG_Z_SYM;
      VAR.STRING2:=_tab.M_Z_KTM;
      {? _tab.ZLSYM=ZL.SYM
      || Color.rekprzed('__ZLZAM#01#01')
      || ''
      ?}
   ?}
";
_tab.win_act(_wer,,'Rekord',,,,_fb);
_tab.tr_fml(_wer,,"1");
_tab.win_sel(_wer);
_red:=_tab.mk_edit('Źródło, z którego powstało zlecenie %1'@[_zl_sym],0,'#zlzam_red');
_tab.win_efld(_red,,'SOURCE',,,60,,,'Źródło'@);
_tab.win_efld(_red,,'SYM',,,60,,,'Symbol źródła'@);
_tab.win_efld(_red,,'M_Z_KTM',,,60,,,'Indeks materiałowy'@);
_tab.win_efld(_red,,'M_Z_NAZ',,,60,,,' ');
_tab.win_efld(_red,,'KH_KOD',,,60,,,'Kontrahent'@);
_tab.win_efld(_red,,'KH_NAZ',,,60,,,' ');
_tab.win_efld(_red,AH,'H',,,,,,'');
_tab.win_efld(_red,,'IL_ZAM',,,15,_dokl,,'Ilość wymagana'@);
_tab.win_efld(_red,,'MG_S_SYM',,,15,,,'Na magazyn'@);
_tab.win_efld(_red,,'ILZL',,,15,_dokl,,'Ilość na zleceniu'@);
_tab.win_efld(_red,,'MG_Z_SYM',,,15,,,'Na magazyn'@);
_tab.win_efld(_red,AH,'H',,,,,,'');
_tab.win_efld(_red,,'DPLANREA',,,12,,,'Realizacja do'@);
_tab.win_edit(_red);
_tab.select();
~~


\add_zam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Formuła działa w kontekście ustawionego ZLZAM.
::   WE: _a - tabela tymczasowa ZLZAMów
::  OLD: \add_zam/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_sym:=_tab.SYM;
_source:=_tab.SOURCE;
_styp:=_tab.STYP;
_zampoz:=_tab.ZAMPOZ;
_ilz:=_tab.IL_ZAM;
_khk:=_tab.KH_KOD;
_khn:=_tab.KH_NAZ;
_dpl:=_tab.DPLANREA;
_mg_s_sym:=_tab.MG_S_SYM;
_mg_z_sym:=_tab.MG_Z_SYM;
_m_s_ktm:=_tab.M_S_KTM;
_m_z_ktm:=_tab.M_Z_KTM;
_tab.blank();
_tab.PARENT:=0;
_tab.SOURCE:=_source;
_tab.STYP:=_styp;
_tab.TREE_LAB:=_sym;
_tab.GL:='T';
_tab.ZL:='';
_tab.SYM:=_sym;
_tab.ZLSYM:='';
_tab.ZAMPOZ:=_zampoz;
_tab.IL_ZAM:=_ilz;
_tab.ILZL:=0;
_tab.KH_KOD:=_khk;
_tab.KH_NAZ:=_khn;
_tab.DPLANREA:=_dpl;
_tab.MG_S_SYM:=_mg_s_sym;
_tab.MG_Z_SYM:=_mg_z_sym;
_tab.M_S_KTM:=_m_s_ktm;
_tab.M_Z_KTM:=_m_z_ktm;
_tab.prefix();
_tab.add();
~~


\zlzam_rec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: 'Przed rekord' zamówienia źródłowego (kolorowanie zaległych)
::   WY: Schemat kolorowania
::  OLD: \zlzam_rec/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
{? 1+_tab.SYM='~'
|| 'ZLZAM#01#02'
|? _tab.DPLANREA<date() & _tab.DPLANREA<>date(0,0,0)
|| 'ZLZAM#01#01'
|| ''
?}


\add_zleczam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Dodaje/modyfikuje dla zlecenia zapis w ZLZAM
::   WE: _a - ZL.ref()
::       _b - ilość do wykonania
::       [_c] - $ZK_P.ref() albo $ref() innego źrodła danych
::       [_d] - $PL_POZ.ref()
::  OLD: \add_zleczam/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
{? _<3 || _zampoz:='' || _zampoz:=_c ?};
{? _<4 || _plpoz:=''  || _plpoz:=_d ?};
{? type_of(_a)=1
|| ZL.cntx_psh();
   ZL.clear();
   {? ZL.seek(_a,)
   || _zlec:=ZL.ref()
   || _zlec:=null()
   ?};
   ZL.cntx_pop()
|| _zlec:=_a
?};

_can_continue:=0;
ZLZAM.cntx_psh();
ZLZAM.index('ZMZL0');
ZLZAM.prefix(_zampoz,_zlec,_plpoz);
{? ZLZAM.first()
|| ZLZAM.ILZL+=_b;
   ZLZAM.ILPOZ+=_b;
   {? ZLZAM.put()
   || {? ZLZAM.SRC='Z'
      || exec('zlzam2Rez','zamsiw_wspolne',_zampoz,1,ZLZAM.ILZL,,,0)
      |? ZLZAM.SRC='D'
      || {? PD_K.seek(ZLZAM.ZAMPOZ)
         || PD_K.ILP-=_b;
            PD_K.put
         ?}
      ?}
   ?}
|| ZLZAM.blank();
   ZLZAM.ZL:=_zlec;
   ZLZAM.ILZL:=ZLZAM.ILPOZ:=_b;
   ZLZAM.ZAMPOZ:=_zampoz;
   ZLZAM.POZPLAN:=_plpoz;
   {? _zampoz<>'' & ref_tab(_zampoz)=ZK_P
   || ZLZAM.PL_DATA:=exec('FindAndGet','#table',ZK_P,_zampoz,,"PL_DATA",date(0,0,0));
      ZLZAM.PL_TIME:=exec('FindAndGet','#table',ZK_P,_zampoz,,"PL_TIME",time(0,0,0));
      ZLZAM.SRC:='Z'
   |? _zampoz<>'' & ref_tab(_zampoz)=PD_K
   || ZLZAM.SRC:='D'
   |? _zampoz<>'' & ref_tab(_zampoz)=PSP
   || ZLZAM.SRC:='S'
   ?};
   {? ZLZAM.add()
   || {? ZLZAM.SRC='Z'
      || exec('zlzam2Rez','zamsiw_wspolne',_zampoz,0,ZLZAM.ILZL,,,0)
      |? ZLZAM.SRC='D'
      || {? PD_K.seek(ZLZAM.ZAMPOZ)
         || PD_K.ILP-=ZLZAM.ILZL;
            PD_K.put
         ?}
      ?}
   ?}
?};
ZLZAM.cntx_pop();
~~


\zlzam_decrease
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Po korekcie ilości na zleceniu na minus koryguje zapisy na ZLZAMach
::   WE: [_a] - ZL.ref lub bieżący rekord
::        _b - REAL - nowa ilość na zleceniu po zmniejszeniu
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};
_il_zl:=_b;

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
{? _can_continue>0
||
   ZLZAM.cntx_psh();
   ZLZAM.index('PL_DTTM');
   ZLZAM.prefix(ZL.ref());

:: Najpierw obliczam całkowitą ilość na zlzamach
   _ilosc:=0;
   {? ZLZAM.first()
   || {!
      |? _ilosc+=ZLZAM.ILZL;
         ZLZAM.next()
      !}
   ?};

   {? _ilosc>0
   ||
::    Uruchamiam korygowanie
      _pop:=tab_tmp(2,
         'ZAMPOZ','STRING[16]','',
         'ILE','REAL','',
         'WSK','INTEGER','',
         'ZLZAM','STRING[16]','',
         'ILEZM','REAL',''
      );
      ZLZAM.index('SRC');

::    1. Najpierw koryguję ZLZAMy ręczne
      ZLZAM.prefix(ZL.ref(),'R');
      _kor_res:=exec('correction_decrease_zlzam','zl_gen',_ilosc,_il_zl,_pop);

      {? _kor_res.RESULT>0
      || _ilosc:=_kor_res.LEFT;
         _can_continue:=1
      || _can_continue:=0
      ?};

      {? _can_continue>0 & _ilosc>0
      ||
::       2. Następnie korygujemy ZLZAMy powiązane z zamówieniami
         ZLZAM.prefix(ZL.ref(),'Z');
         {? var_pres('_kor_res')>100
         || obj_del(_kor_res)
         ?};
         _kor_res:=exec('correction_decrease_zlzam','zl_gen',_ilosc,_il_zl,_pop);
         {? _kor_res.RESULT>0
         || _ilosc:=_kor_res.LEFT;
            _can_continue:=1
         || _can_continue:=0
         ?}
      ?};

      {? _can_continue>0 & _ilosc>0
      ||
::       3. Następnie korygujemy ZLZAMy powiązane z planem dostaw
         ZLZAM.prefix(ZL.ref(),'D');
         {? var_pres('_kor_res')>100
         || obj_del(_kor_res)
         ?};
         _kor_res:=exec('correction_decrease_zlzam','zl_gen',_ilosc,_il_zl,_pop);
         {? _kor_res.RESULT>0
         || _ilosc:=_kor_res.LEFT;
            _can_continue:=1
         || _can_continue:=0
         ?}
      ?};

      {? _can_continue>0 & _ilosc>0
      ||
::       4. Następnie korygujemy ZLZAMy powiązane z planem sprzedaży
         ZLZAM.prefix(ZL.ref(),'S');
         {? var_pres('_kor_res')>100
         || obj_del(_kor_res)
         ?};
         _kor_res:=exec('correction_decrease_zlzam','zl_gen',_ilosc,_il_zl,_pop);
         {? _kor_res.RESULT>0
         || _ilosc:=_kor_res.LEFT;
            _can_continue:=1
         || _can_continue:=0
         ?}
      ?};

      {? _can_continue>0 & (_pop.clear(); _pop.first())
      || {!
         |?
::          Aktualizacja rezerwacji
            {? _pop.ZLZAM<>'' & ref_tab(_pop.ZLZAM)=ZK_P
            || exec('zlzam2Rez','zamsiw_wspolne',
                _pop.ZAMPOZ,_pop.WSK,_pop.ILE,exec('FindAndGet','#table',ZLZAM,_pop.ZLZAM,,"ref()",null()),_pop.ILEZM)
::          Aktualizacja planu dostaw
            |? _pop.ZLZAM<>'' & ref_tab(_pop.ZLZAM)=PD_K
            || PD_K.cntx_psh();
               PD_K.prefix();
               {? PD_K.seek(_pop.ZAMPOZ)
               || PD_K.ILP-=_pop.ILEZM;
                  PD_K.put()
               ?};
               PD_K.cntx_pop()
::          Aktualizacja planu sprzedaży
            |? _pop.ZAMPOZ<>'' & ref_tab(_pop.ZAMPOZ)=PSP
            || exec('FindAndGet','#table',PSP,_pop.ZAMPOZ,,"PSP.ILZL+=_b.ILEZM;PSP.put()",~~,_pop)
            ?};
            _pop.next()
         !}
      ?};
      obj_del(_pop)
   ?};
   ZLZAM.cntx_pop()
?};
ZL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\correction_decrease_zlzam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Koryguje ilości na bieżącej dziedzinie ZLZAMów idąc od końca po aktualnym indeksie
::   WE: _a - REAL - całkowita ilość na zlzamach
::       _b - REAL - nowa ilość na zleceniu po zmniejszeniu
::       _c - tab_tmp - tabelka tymczasowa do zasilenia aktualizacji rezerwacji
::   WY: obj_new - obiekt z wynikiem:
::                   _result.RESULT - INTEGER 0/1 - sukces czy porażka
::                   _result.LEFT - ile ilości jeszcze zostało do korekty na pozostałych
::                                  zlzamach
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ilosc:=_a;
_zl_new:=_b;
_pop:=_c;

_can_continue:=1;
_result:=obj_new('RESULT','LEFT');
_result.RESULT:=0;
_result.LEFT:=_ilosc;

{? ZLZAM.last()
|| {!
   |? _next:=0;
      _ref_nxt:=null();
      _il_zlzam:=ZLZAM.ILZL;
      ZLZAM.cntx_psh();
      {? ZLZAM.prev()
      || _ref_nxt:=ZLZAM.ref()
      ?};
      ZLZAM.cntx_pop();

      {? ZLZAM.ILZL>_ilosc-_zl_new
      || ZLZAM.ILZL:=ZLZAM.ILZL-(_ilosc-_zl_new);
         _can_continue:=ZLZAM.put();
         {? _can_continue>0
         || _pop.blank();
            _pop.ZAMPOZ:=ZLZAM.ZAMPOZ;
            _pop.ILE:=ZLZAM.ILZL;
            _pop.WSK:=1;
            _pop.ZLZAM:=$ZLZAM.ref();
            _pop.ILEZM:=-(_ilosc-_zl_new);
            _pop.add(1)
         ?}
      || _pop.blank();
         _pop.ZAMPOZ:=ZLZAM.ZAMPOZ;
         _pop.ILE:=0;
         _pop.WSK:=-1;
         _pop.ZLZAM:='';
         _pop.ILEZM:=-ZLZAM.ILZL;
         _pop.add(1);
         exec('zlzam2Rez','zamsiw_wspolne',_pop.ZAMPOZ,_pop.WSK,_pop.ILE,ZLZAM.ref(),_pop.ILEZM);
         _can_continue:=ZLZAM.del(,1)
      ?};

      {? _ref_nxt<>null()
      || _next:=ZLZAM.seek(_ref_nxt)
      ?};
      _ilosc-=_il_zlzam;
      _next>0 & _can_continue>0 & _ilosc>_zl_new
   !}
?};
{? _can_continue>0
|| _result.RESULT:=1;
   _result.LEFT:=_ilosc
|| _result.RESULT:=0;
   _result.LEFT:=0
?};
_result


\auto_args
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Tablica parametrów dla funkcji automatycznie generujących zlecenia
::   WY: _args
::  OLD: \auto_args/zl.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
::             Czy akcja grupowa? (0/1)
               'GRUPA'
::             Czy wyświetlać dialogi? 0/1
               ,'DIALOG'
::             Ref SQL pozycji zamówienia
               ,'SRC_REF'
::             Ref SQL materiału
               ,'M'
::             Indeks materiałowy
               ,'KTM'
::             Symbol zamówienia
               ,'SYMBOL'
::             Nr pozycji
               ,'POZ'
::             Ilość na jaką utworzyć zlecenie
               ,'ILOSC'
::             Ilość zamówiona
               ,'IL_ZAM'
::             Ilość do wytworzenia
               ,'IL_WYTW'
::             Ilość zlecona
               ,'IL_ZL'
::             Ilość zarezerwowana na magazynie
               ,'IL_REZ'
::             Ref SQL kontrahenta
               ,'KH_REF'
::             Nazwa kontrahenta
               ,'KH_NAZ'
::             Kod kontrahenta
               ,'KH_KOD'
::             Data realizacji zamówienia
               ,'DTR'
::             Wewnętrzny termin realizacji
               ,'PL_DATA'
               ,'PL_TIME'
::             REAL - kierunek planowania (-1, 0, 1, domyślnie -10, co oznacza pobranie z typu zlecenia)
               ,'PL_DIR'
::             STRING - T/N - kontynuuj planowanie po przekroczeniu terminu
               ,'PL_FORCE'
::             Ref SQL cechy na pozycji zamówienia
               ,'DK_C'
::             Symbol jednostki miary na pozycji zamówienia
               ,'JM_SYM'
::             Technologia wg której powołać zlecenie
               ,'TKTL'
::             Typ zlecenia który powołać
               ,'ZTP'
::             Zlecenie nadrzędne do którego dołaczyć zlecenie
               ,'ZL_NAD'
::             Pozycja w kolejce planu strategicznego
               ,'PX_CONN'
::             Czy mozliwe jest scalanie do innego zlecenia
               ,'MERGE'
::             Zlecenie, do którego scalamy
               ,'ZL_MERGE'
::             Czy możliwe jest dzielenie ILOSCI na jeszcze mniejsze kawałki w celu
::             utworzenia kilku zleceń hurtem
               ,'SPLIT'
::             Czy możliwe jest tworzenie zlecen złożonych, jeśli technologia ma półfabrykaty
::             'N' - nie, bez pytania
::             'P' - z pytaniem
::             'T' - tak, bez pytania
               ,'COMPLEX'
::             Klucz grupujący - wykorzystywany w procesie, gdy w pętli generowana jest seria zleceń
               ,'GRP_KEY'
::             Obiekt z tablicą tymczasową zawierający refy utworzonych zleceń (RESULT.tab)
               ,'RESULT'
::             Wskazanie na projekt
               ,'PROJEKTY'
::             Opis zlecenia
               ,'OPIS'
::             Wydział
               ,'JORG'
::             Magazyn
               ,'MG'
::             Uwagi zlecenia
               ,'UWAGI'
::             Opis dodatkowy zlecenia
               ,'OPIS_DOD'
::             Czy generować ZLZAMy
               ,'GEN_ZLZAM'
::             Wzorzec atrybutów dostaw
               ,'M_ATR'
              );
_args.GRUPA:=0;
_args.DIALOG:=1;
_args.SRC_REF:='';
_args.M:='';
_args.KTM:='';
_args.SYMBOL:='';
_args.POZ:=0;
_args.ILOSC:=0;
_args.IL_ZAM:=0;
_args.IL_WYTW:=0;
_args.IL_ZL:=0;
_args.IL_REZ:=0;
_args.KH_REF:='';
_args.KH_NAZ:='';
_args.KH_KOD:='';
_args.DTR:=date(0,0,0);
_args.PL_DATA:=date(0,0,0);
_args.PL_TIME:=time(0,0,0);
_args.PL_DIR:=-10;
_args.PL_FORCE:='N';
_args.DK_C:='';
_args.JM_SYM:='';
_args.TKTL:=null();
_args.ZTP:=null();
_args.ZL_NAD:=null();
_args.PX_CONN:=null();
_args.MERGE:=0;
_args.ZL_MERGE:=null();
_args.SPLIT:=1;
_args.COMPLEX:='P';
_args.GRP_KEY:='';
_args.RESULT:=exec('ref_table','#table');
_args.PROJEKTY:=null();
_args.OPIS:='';
_args.UWAGI:='';
_args.OPIS_DOD:='';
_args.JORG:=null();
_args.MG:=null();
_args.GEN_ZLZAM:=1;
_args.M_ATR:=null();
_args


\auto_zl_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Jądro generowania jednego lub wielu zleceń na podstawie 'czegoś'
::       Funkcja bardziej szczegółowa, zapewnia wymagane kontrole i wyświetla okna, jeśli nie
::       przekazano wartości niektórych potrzebnych argumentów
::   WE: _args - argumenty dla funkcji generującej, wynik działania exec('auto_args','zl_gen')
::  OLD: \auto_zl_core/zl.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('auto_args','zl_gen')
?};
{? _args.GRUPA=0 || KOMM.init(,,'Generowanie zlecenia'@,'') ?};

ZLZAM.cntx_psh();
ZL.cntx_psh();
M.cntx_psh();
M.clear();

_can_continue:=1;

_dziel:=0;
_il:=0;
_dalej:=1;

_can_continue:=1;

{? ~M.seek(_args.M)
|| _msg:='Nie można powołać zlecenia.\nBrak materiału \'%1\' w słowniku.'@[_args.KTM];
   {? _args.GRUPA>0
   || KOMM.add(_msg,2)
   || FUN.emsg(_msg)
   ?}
||
:: Środowisko dla okna redagowania generatora
   _env_gen:=exec('env_gen','zl_gen');
   _env_gen.edit_ZTP:=(_args.ZTP=null());
   _env_gen.edit_IL:=(_args.SPLIT=1);
   _env_gen.edit_TKTL:=(_args.TKTL=null());
   _env_gen.edit_COMPLEX:=(_args.COMPLEX='P');
   _env_gen.edit_MERGE:=(_args.MERGE=1);
   params_set('args',_args,'env_gen',_env_gen);

   VAR.A_T:=M.ref();
   ZLEC.DK_C:=exec('FindAndGet','#table',DK_C,_args.DK_C,,"ref()",null());
   ZLEC.ZTP:=_args.ZTP;
   ZLEC.ZK_P:=exec('FindAndGet','#table',ZK_P,_args.SRC_REF,,"ref()",null());
   ZLEC.KH:=exec('FindAndGet','#table',KH,_args.KH_REF,,"ref()",null());

   {? _args.ILOSC>0
   || _il:=_args.ILOSC
   || _il:=_args.IL_WYTW-_args.IL_ZL
   ?};
   {? _il<0
   || _il:=0
   ?};

   {? _args.MG<>null()
   || _typ_mg:=exec('FindAndGet','#table',MG,_args.MG,,"TYP",'');
      {? exec('material_party','material',_args.M)>0
      || {? ~(_typ_mg*'DOST')
         || _msg:='Produkt \'%3\' jest partiowany. '
                  'Magazyn przypisany do zlecenia musi być typu: \'\'%1\'\' lub \'\'%2\'\'.'@
                  ['DOSTAWY','DOSTEWI',_args.KTM];
            {? _args.GRUPA>0
            || KOMM.add(_msg,2)
            || FUN.emsg(_msg)
            ?};
            _can_continue:=0
         ?}
      ?}
   ?};

   {? _can_continue=0
   || ~~
   |? _il=0
   || {? _args.GRUPA>0
      || KOMM.add('Nie można powołać zlecenia. Do pozycji %1 została już zlecona cała ilość.'@
                  [_args.SYMBOL+' poz.'+$_args.POZ],2)
      || FUN.emsg('Nie można powołać zlecenia.\nDo tej pozycji została już zlecona cała ilość.'@)
      ?}
   ||
      ZLEC.IL_ALL:=_il;
      ZLEC.IL_2DIV:=ZLEC.IL_ALL;
      ZLEC.IL_ZLEC:=ZLEC.IL_ALL;
      ZLEC.TKTL:={? _args.TKTL<>~~ & _args.TKTL<>null() || _args.TKTL || exec('wyb_ktl','zl_gen',0) ?};
      ZLEC.COMPLEX:={? _args.COMPLEX='P'
                    || {? exec('czy_pf','tech_mater',ZLEC.TKTL) || 'T' || 'N' ?}
                    || _args.COMPLEX
                    ?};
      ZLEC.ZL_MERGE:=_args.ZL_MERGE;

      ZTP.f_clear();
      _typy:=exec('typy_zlecen','zl_head','P');
      ZTP.f_set('TYP',,'ZTP.REFERENCE in (select :_a.REF from :_a)',_typy);
      obj_del(_typy);
      ZTP.win_dict('SLO');

      ZLEC.btn_eopt('ZL_GEN','MERGE','state='+{? _env_gen.edit_MERGE || 'normal' || 'grayed' ?});
      ZLEC.btn_eopt('ZL_GEN','UNMERGE','state=grayed');
      ZLEC.win_edit('ZL_GEN');
      {? {? _args.GRUPA=0 & _args.DIALOG>0
         || ZLEC.edit("
               _result:='';
               {? ZLEC.ZL_MERGE<>null & ZLEC.IL_2DIV<>ZLEC.IL_ZLEC
               || FUN.info(
                     'Nie można dokonywać podziału ilości na wiele zleceń i jednocześnie wiązać zleceń ze sobą.\n\n'
                     'W przypadku powiązania z innym zleceniem ilość na jednym zleceniu '
                     'musi być równa ilości do podziału.'@
                  );
                  _result:='IL_2DIV'
               || _result:=__CHK.record(ZLEC,,'ZTP','IL_2DIV','IL_ZLEC','RED_KTL');
                  {? _result=''
                  || {? params_get().args.SPLIT>0
                     || {? ZLEC.IL_2DIV<0
                        || FUN.info('Ilość do podziału nie może być ujemna.'@);
                           _result:='IL_2DIV'
                        |? ZLEC.IL_ZLEC<0
                        || FUN.info('Ilość na zleceniu nie może być ujemna.'@);
                           _result:='IL_ZLEC'
                        |? ZLEC.IL_2DIV>ZLEC.IL_ALL
                        || FUN.info('Ilość do podziału nie może być większa niż %1.'@[$ZLEC.IL_ALL]);
                           _result:='IL_2DIV'
                        |? ZLEC.IL_ZLEC>ZLEC.IL_2DIV
                        || FUN.info('Ilość na jednym zleceniu nie może być większa niż ilość do podziału.'@);
                           _result:='IL_ZLEC'
                        ?}
                     ?}
                  ?}
               ?};
               {? _result='' & ZLEC.COMPLEX='T' & exec('czy_pf','tech_mater',ZLEC.TKTL)=0
               || FUN.info('Technologia nie zawiera półfabrykatu. Nie można utworzyć zlecenia złożonego.'@);
                  _result:='RED_KTL'
               ?};
               _result
            ")
         || 1
         ?}
      || _args.ZTP:=ZLEC.ZTP;
         _args.TKTL:=ZLEC.TKTL;
         _il:=ZLEC.IL_2DIV;
         _ilnzl:=ZLEC.IL_ZLEC;
         _args.COMPLEX:=ZLEC.COMPLEX;
         _args.ZL_MERGE:=ZLEC.ZL_MERGE;
         exec('add_ref','zl_gen');

         {? _ilnzl<>_il
         || _dziel:=1
         ?};
         _ok:=1;

::       Sprawdzam, czy przy generowaniu zleceń złożonych podano technologię z półfabrykatami
         {? ~(_args.GRUPA=0 & _args.DIALOG>0) & _args.COMPLEX='T' & _args.TKTL<>~~ & _args.TKTL<>null()
            & exec('czy_pf','tech_mater',_args.TKTL)=0
         || _ok:=0;
            _what:=exec('FindAndGet','#table',TKTL,_args.TKTL,,"exec('TKTL','#to_string')",'');
            _msg:='Technologia %1 nie zawiera półfabrykatu. '
                  'Nie można utworzyć zlecenia złożonego.'@[_what];
            {? _args.GRUPA>0
            || KOMM.add(_msg,2)
            || FUN.emsg(_msg)
            ?}
         ?};

         {? _ok>0 & _args.DIALOG>0
         || {? _dziel=0
            || {? _args.COMPLEX='T' & _args.ZL_MERGE=null()
               || _msg:='Zostanie utworzone zlecenie złożone na ilość %1 %2.'@[form(_ilnzl,,,'9.'),_args.JM_SYM]+
                        '\n\n'+'Czy kontynuować?'@
               |? _args.COMPLEX='N' & _args.ZL_MERGE=null()
               || _msg:='Zostanie utworzone zlecenie proste na ilość %1 %2.'@[form(_ilnzl,,,'9.'),_args.JM_SYM]+
                        '\n\n'+'Czy kontynuować?'@
               |? _args.COMPLEX='T' & _args.ZL_MERGE<>null()
               || _msg:='Ilość %1 %2 zostanie dołączona do zlecenia złożonego %3.'@
                        [form(_ilnzl,,,'9.'),_args.JM_SYM,exec('FindAndGet','#table',ZL,_args.ZL_MERGE,,"SYM",'')]+
                        '\n\n'+'Czy kontynuować?'@
               |? _args.COMPLEX='N' & _args.ZL_MERGE<>null()
               || _msg:='Ilość %1 %2 zostanie dołączona do zlecenia prostego %3.'@
                        [form(_ilnzl,,,'9.'),_args.JM_SYM,exec('FindAndGet','#table',ZL,_args.ZL_MERGE,,"SYM",'')]+
                        '\n\n'+'Czy kontynuować?'@
               || _msg:=''
               ?};
               _ok:=FUN.ask(_msg)
            || {? _args.COMPLEX='T'
               || _msg:='Zostanie utworzonych %1 zleceń złożonych.'@[form(ceil(_il/_ilnzl))]+
                        '\n\n'+'Czy kontynuować?'@
               |? _args.COMPLEX='N'
               || _msg:='Zostanie utworzonych %1 zleceń prostych.'@[form(ceil(_il/_ilnzl))]+
                        '\n\n'+'Czy kontynuować?'@
               || _msg:=''
               ?};
               _ok:=FUN.ask(_msg)
            ?}
         ?};

         {? _ok
         ||
            {? _args.GEN_ZLZAM>0
            || __REF.ZAMPOZ:=_args.SRC_REF;
               __REF.T:=BIT.sqlint(_args.M);
               __REF.IL:=_args.IL_WYTW;
               __REF.ILZL:=_args.IL_ZL;
               __REF.SYM:=_args.SYMBOL;
               __REF.add()
            ?};

            {? _dziel=0
            || {!
               |?
                  _wynik:=1;
                  _opcja:={? _args.ZL_MERGE=null() || 1 || 2 ?};
                  {? _opcja=1
                  ||
                     _args_gen:=exec('gen_zlec_a','zl_gen');
                     _args_gen.KTM:=_args.KTM;
                     _args_gen.DTR:=_args.DTR;
                     _args_gen.ILOSC:=_ilnzl;
                     _args_gen.KH:=_args.KH_REF;
                     _args_gen.TKTL:=_args.TKTL;
                     _args_gen.PL_DATA:=_args.PL_DATA;
                     _args_gen.PL_TIME:=_args.PL_TIME;
                     _args_gen.PL_DIR:=_args.PL_DIR;
                     _args_gen.PL_FORCE:=_args.PL_FORCE;
                     _args_gen.DK_C:=_args.DK_C;
                     _args_gen.ZTP:=_args.ZTP;
                     _args_gen.ZL_NAD:=_args.ZL_NAD;
                     _args_gen.COMPLEX:=_args.COMPLEX;
                     _args_gen.GRP_KEY:=_args.GRP_KEY;
                     _args_gen.PROJEKTY:=_args.PROJEKTY;
                     _args_gen.OPIS:=_args.OPIS;
                     _args_gen.UWAGI:=_args.UWAGI;
                     _args_gen.OPIS_DOD:=_args.OPIS_DOD;
                     _args_gen.DIALOG:=_args.DIALOG;
                     _args_gen.DIALOG_WOL_NR:={? _args.GRUPA<>1 & _args.DIALOG>0 || 1 || 0 ?};
                     _args_gen.MG:=_args.MG;

                     _zl:=exec('gen_zlec','zl_gen',_args_gen);
                     {? _zl<>null()
                     ||
::                      Dodaje utworzone zlecenie do tabeli wynikowej
                        _args.RESULT.add(_zl)
                     ?}
                  |? _opcja=2
                  || _opis_dod:=ZLEC.ZK_P().N().SYM;
                     {? _args.SRC_REF<>'' & ref_tab(_args.SRC_REF)=PD_K
                     || {? PD_K.seek(_args.SRC_REF)
                        || _opis_dod:=PD_K.PD_N().SYM
                        ?}
                     ?};
                     _zl:=exec('mod_zlec','zl_gen',_args.ZL_MERGE,_ilnzl,_opis_dod);
                     {? _zl<>null()
                     || _wynik:=1;
::                      Dodaje zmodyfikowane zlecenie do tabeli wynikowej
                        _args.RESULT.add(_zl)
                     || _wynik:=0
                     ?}
                  || _wynik:=1
                  ?};
                  _wynik=0
               !}
            || _licznik:=0;
               _ktl:=null();
               _ilopt:=0;

::             Ustalenie karty technologicznej
               {? _args.TKTL=null()
               || M.clear();
                  {? exec('enabled','zl_uslugi')
                  || M.index('MATKTM');
                     M.prefix(_args.KTM,)
                  || M.index('RODZ');
                     M.prefix('T',_args.KTM,)
                  ?};
                  {? M.first()
                  || _ktl:=exec('wyb_ktl','zl_gen');
                     {? _ktl<>null()
                     || _ilopt:=TKTL.SERIA
                     ?}
                  ?}
               || TKTL.clear();
                  {? TKTL.seek(_args.TKTL)
                  || _ktl:=TKTL.ref();
                     _ilopt:=TKTL.SERIA
                  ?}
               ?};

               _pf:=0;
               {? _args.COMPLEX<>'N'
               || _pf:=exec('czy_pf','tech_mater',_ktl);
                  {? _pf=1
                  || {? _args.COMPLEX='T'
                     || _opcja:=1
                     || _opcja:=FUN.ask(
                           'Technologia %1 wer. %2 na wyrób %3 zawiera półfabrykaty.\n'
                           'Czy utworzyć zlecenie złożone?'@[TKTL.NRK,TKTL.WER,M.KTM]
                        )
                     ?}
                  || _opcja:=0
                  ?}
               || _opcja:=0
               ?};
               {? _opcja=1
               || _arch:=exec('chk_pf_arch','zl_head',_ktl,1);
                  {? _arch>0
                  || _opcja:=0
                  ?}
               ?};
               {? _opcja=1
               || _rodzaj:='Z'
               || _rodzaj:='P'
               ?};
               {!
               |?
                  _licznik+=_ilnzl;

                  {? var_pres('_args_gen')>100
                  || obj_del(_args_gen)
                  ?};
                  _args_gen:=exec('gen_zlec_a','zl_gen');
                  _args_gen.KTM:=_args.KTM;
                  _args_gen.DTR:=_args.DTR;
                  _args_gen.ILOSC:={? _licznik>_il || _il-(_licznik-_ilnzl) || _ilnzl ?};
                  _args_gen.KH:=_args.KH_REF;
                  _args_gen.TKTL:=_ktl;
                  _args_gen.PL_DATA:=_args.PL_DATA;
                  _args_gen.PL_TIME:=_args.PL_TIME;
                  _args_gen.PL_DIR:=_args.PL_DIR;
                  _args_gen.PL_FORCE:=_args.PL_FORCE;
                  _args_gen.DK_C:=_args.DK_C;
                  _args_gen.ZTP:=_args.ZTP;
                  _args_gen.ZL_NAD:=_args.ZL_NAD;
                  _args_gen.COMPLEX:=_args.COMPLEX;
                  _args_gen.GRP_KEY:=_args.GRP_KEY;
                  _args_gen.RODZAJ:=_rodzaj;
                  _args_gen.PROJEKTY:=_args.PROJEKTY;
                  _args_gen.OPIS:=_args.OPIS;
                  _args_gen.UWAGI:=_args.UWAGI;
                  _args_gen.OPIS_DOD:=_args.OPIS_DOD;
                  _args_gen.DIALOG:=_args.DIALOG;
                  _args_gen.DIALOG_WOL_NR:={? _args.GRUPA<>1 & _args.DIALOG>0 || 1 || 0 ?};
                  _args_gen.MG:=_args.MG;

                  _args_gen.SERIA:=0;
                  _zl:=exec('gen_zlec','zl_gen',_args_gen);
                  {? _zl<>null()
                  ||
::                   Dodaje utworzone zlecenie do tabeli wynikowej
                     _args.RESULT.add(_zl)
                  ?};
                  _licznik<_il
               !}
            ?};
            {? _args.SRC_REF<>'' & ref_tab(_args.SRC_REF)=ZK_P
            || ZK_N.cntx_psh();
               ZK_P.cntx_psh();
               ZK_P.prefix();
               {? ZK_P.seek(_args.SRC_REF)
               || exec('aktznzkp','zamsiw_poz',ZK_P.ref(),1,1);
                  exec('aktznzkn','zamsiw_nag',ZK_P.N,1)
               ?};
               ZK_N.cntx_pop();
               ZK_P.cntx_pop()
            ?};
            {? _args.GRUPA=0 || KOMM.select() ?}
         ?};
         exec('clean_ref','zl_gen')
      ?}
   ?}
?};

ZLZAM.cntx_pop();
ZL.cntx_pop();
M.cntx_pop();
~~


\gen_zlec_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Tablica parametrów dla gen_zlec
::   WY: _args
::  OLD: \gen_zlec_a/zl.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
::             STRING - M.KTM - indeks materialu
               'KTM'
::             DATE - Termin realizacji
               ,'DTR'
::             REAL - ilosc produktu jaka wytworzyc na zleceniu
               ,'ILOSC'
::             INTEGER - 0/1 - Czy ustalac wielkosc zlecenia na optymalna serie
               ,'SERIA'
::             ZTP.ref() - Typ zlecenia
               ,'ZTP'
::             ZL.ref() - Zlecenie nadrzędne
               ,'ZL_NAD'
::             $KH.ref() - SQL ref kontrahenta
               ,'KH'
::             TKTL.ref() -  technologia wg ktorej powolac zlecenie
               ,'TKTL'
::             STRING - rodzaj zlecenia (zlozone,proste,niezalezne)
               ,'RODZAJ'
::             DATE - Wewnetrzny termin realizacji (data) - jesli nie podany to rowny DTR
               ,'PL_DATA'
::             TIME - Wewnetrzny termin realizacji (godzina)
               ,'PL_TIME'
::             REAL - kierunek planowania (-1, 0, 1, domyślnie -10, co oznacza pobranie z typu zlecenia)
               ,'PL_DIR'
::             STRING - T/N - kontynuuj planowanie po przekroczeniu terminu
               ,'PL_FORCE'
::             $DK_C.ref() - SQL ref cechy
               ,'DK_C'
::             MG.ref() - magazyn na zleceniu
               ,'MG'
::             Czy możliwe jest tworzenie zleceń złożonych, jeśli technologia ma półfabrykaty
::             'N' - nie, bez pytania
::             'P' - z pytaniem
::             'T' - tak, bez pytania
               ,'COMPLEX'
::             Klucz grupujący - wykorzystywany w procesie, gdy w pętli generowana jest seria zleceń
               ,'GRP_KEY'
::             Wskazanie na projekt
               ,'PROJEKTY'
::             Opis zlecenia
               ,'OPIS'
::             Uwagi zlecenia
               ,'UWAGI'
::             Dodatkowy opis zlecenia
               ,'OPIS_DOD'
::             Czy wyświetlać dialogi (pytania)? 0/1
               ,'DIALOG'
::             Czy wyświetlać dialog związany z wykorzystaniem wolnej numeracji dokumentów? 0/1
               ,'DIALOG_WOL_NR'
              );
_args.KTM:='';
_args.DTR:=date(0,0,0);
_args.ILOSC:=-1;
_args.SERIA:=0;
_args.ZTP:=null();
_args.ZL_NAD:=null();
_args.KH:='';
_args.TKTL:=null();
_args.RODZAJ:='';
_args.PL_DATA:=date(0,0,0);
_args.PL_TIME:=time(0,0,0);
_args.PL_DIR:=-10;
_args.PL_FORCE:='N';
_args.DK_C:='';
_args.MG:=null();
_args.COMPLEX:='P';
_args.GRP_KEY:='';
_args.PROJEKTY:=null();
_args.OPIS:='';
_args.UWAGI:='';
_args.OPIS_DOD:='';
_args.DIALOG:=1;
_args.DIALOG_WOL_NR:=0;
_args


\gen_zlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Uniwersalna formuła generująca zlecenie na podstawie przekazanych parametrów
::   WE: _args
::   WY: null() - porażka, zlecenia nie udało się dodać
::       ZL.ref - sukces, dodano zlecenie
::  OLD: \gen_zlec/zl.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('gen_zlec_a','zl_gen')
?};

:: Sprawdzam czy wymagane parametry zostały przekazane
{? _args.KTM=''
|| FUN.wdrerror('Argument: %1 nie został przekazany do formuły: %2.'@['KTM','gen_zlec\\zl_gen.fml']);
   return(null())
?};
::{? _args.DTR=date(0,0,0)
::|| FUN.wdrerror('Argument: %1 nie został przekazany do formuły: %2.'@['DTR','gen_zlec\\zl_gen.fml']);
::   return(null())
::?};
{? _args.ILOSC=-1
|| FUN.wdrerror('Argument: %1 nie został przekazany do formuły: %2.'@['ILOSC','gen_zlec\\zl_gen.fml']);
   return(null())
?};
{? _args.ZTP=null()
|| FUN.wdrerror('Argument: %1 nie został przekazany do formuły: %2.'@['ZTP','gen_zlec\\zl_gen.fml']);
   return(null())
?};

{? _args.PL_DATA=date(0,0,0)
|| _args.PL_DATA:=_args.DTR
?};

_ok:=1;
_result:=null();
_can_continue:=1;

PROJEKTY.cntx_psh();
M.cntx_psh();
M.clear();

ZL.clear();
::ZL.last();
ZL.blank();

:: Przypisanie typu zlecenia
ZL.TYP:=_args.ZTP;
{? _args.PL_DIR=-10
|| _args.PL_DIR:=ZL.TYP().PL_DIR
?};

{? ZL.TYP().KOD_ZLC='' | ZL.TYP().KOD_ZLP=''
|| {? VAR.GRUPA='T'
   || KOMM.add('Funkcja niedostępna — typ zlecenia \'%1\' nie ma określonego sposobu numeracji.'@[ZL.TYP().TYP],2)
   || FUN.emsg('Funkcja niedostępna — typ zlecenia nie ma określonego sposobu numeracji.'@)
   ?};
   M.cntx_pop();
   PROJEKTY.cntx_pop();
   return(null())
?};

:: Przypisanie ilości na zleceniu
ZL.IL:=_args.ILOSC;
ZL.IL0:=ZL.IL;

:: W zależności, czy generowanie w strukturze zlecenia niezależnego
{? _args.ZL_NAD=null()
|| ZL.NRNZL:=0;
   ZL.NRPZL:=0;
   ZL.LEVEL:=0;
   ZL.TREE:=0
|| ZL.NRNZL:=exec('FindAndGet','#table',ZL,_args.ZL_NAD,,"UNRZL",0);
   ZL.NRPZL:=ZL.NRNZL;
   ZL.LEVEL:=1;
   ZL.TREE:=#exec('FindAndGet','#table',ZL,_args.ZL_NAD)
?};
ZL.NODE:=exec('node','zl_head');

ZL.OPIS:=_args.OPIS;
{? _args.OPIS*'Generowane z analizy wykonania'>0
|| _txt:='~analiza wykonania'
|? _args.OPIS*'Generowane z zam'>0
|| _txt:='~zamówienie'
|? _args.OPIS*'Generowane z planu sprzedaży'>0
|| _txt:='~plan sprzedaży'
|? _args.OPIS*'Generowane z planu dostaw'>0
|| _txt:='~plan dostaw'
|? _args.OPIS*'Generowane ze stanów magazynowych'>0
|| _txt:=exec('zpwyd_sm','zl_gen')
|| _txt:='~plan produkcji'
?};
ZL.UWAGI:=_args.UWAGI;

ZPWYD.prefix();
ZPWYD.index('ZPWYD_PW');
{? ZPWYD.find_key(_txt)
|| ZL.PWYD:=ZPWYD.ref()
|| ZPWYD.PWYD:=_txt;
   ZPWYD.add();
   ZL.PWYD:=ZPWYD.ref()
?};

ZL.OD:=date();
ZL.STAN:='N';
ZL.NSTAN:=ZL.STAN+'_';
::ZL.GENRP:={? ZL.RODZAJ<>'N' & ZL.RODZAJ<>'O' || 'T'||'N' ?};

POM.TAB:='ZL';
exec('add_grnr','numery','ZLC');
exec('add_grnr','numery','ZLP');
POM.TYPDOK:={? ZL.NRNZL=0 || ZL.TYP().KOD_ZLC || ZL.TYP().KOD_ZLP ?};

ZL.SYM:='~'+$ZL.tm_stamp();
exec('ust_znac','zl_head');
exec('set_rodz_tex','zl_head');
{? ZL.add() & ZL.r_lock(1,1,1)
||
   ZL.SYM:='';
   ZL.memo_set(_args.OPIS_DOD,'OPIS_DOD');
   ZL.memo_put(,'OPIS_DOD')

|| _can_continue:=0
?};

{? _can_continue>0
||
   {? ZL.TREE=0 || ZL.NODE:=exec('node','zl_head'); ZL.put() ?};
   ZL.NR:=0;
   ZL.NR:=exec('numer_new','numery',{? _args.DIALOG_WOL_NR || 'N' || 'PACZKA' ?});
   exec('znak','numery','ZL',1);

   {? exec('enabled','zl_uslugi')
   || M.index('MATKTM');
      M.prefix(_args.KTM,)
   || M.index('RODZ');
      M.prefix('T',_args.KTM,)
   ?};
   {? M.first()
   || ZL.KTM:=M.ref();
      ZL.POWOL:=OPERATOR.USER;
      ZL.SCEAN:=exec('blzl_sce','kody_kresk');
      ZL.ZLEAN:=exec('blzl2sce','kody_kresk');

::    Ustawienie kontrahenta na zleceniu
      {? _args.KH=''
      || ZL.KH:=null()
      || ZL.KH:=exec('FindAndGet','#table','KH',_args.KH,,,null())
      ?};

::    Terminy realizacji
      ZL.DTR:=_args.DTR;
      ZL.PL_DATA:=_args.PL_DATA;
      ZL.PL_TIME:=_args.PL_TIME;
      ZL.NSTAN:=ZL.STAN+'_';

::    Zasady planowania
      ZL.PL_DIR:=_args.PL_DIR;
      ZL.PL_FORCE:=_args.PL_FORCE;

::    Karta technologiczna
      {? _args.TKTL=null()
      || ZL.KTL:=exec('wyb_ktl','zl_gen',1,1)
      || ZL.KTL:=_args.TKTL
      ?};
      {? ZL.KTL=null()
      || ZL.SRCTECH:='N'
      || ZL.SRCTECH:='T'
      ?};

::    Cecha na produkcie zlecenia (zlecenie będzie produkowało wyroby z tą cechą)
      {? _args.DK_C<>''
      || ZL.DK_C:=exec('FindAndGet','#table',DK_C,_args.DK_C,,,null())
      ?};

::    Ilość do optymalnej serii
      {? _args.SERIA>0
      || ZL.IL:=ceil(ZL.IL/ZL.KTL().SERIA)*ZL.KTL().SERIA;
         ZL.IL0:=ZL.IL
      ?};

      _pf:=0;
      {? _args.COMPLEX<>'N' & _args.RODZAJ=''
      || _pf:=exec('czy_pf','tech_mater',ZL.KTL)
      ?};

      ZL.GRP_KEY:=_args.GRP_KEY;

::    Projekt
      {? _args.PROJEKTY<>null() & exec('zl_proj_inherit','zl_gen',_args.PROJEKTY)
      || ZL.PROJEKTY:=_args.PROJEKTY
      ?};

      {?
::         VAR.A_ZLNAD=null() &
         _pf>0 & VAR.GRUPA<>'T' & _args.RODZAJ='' & _args.COMPLEX='P'
      || {? _args.DIALOG>0
         || _cmplx:=FUN.ask(
                  'Technologia %1 wer. %2 na wyrób %3'
                  ' zawiera półfabrykaty.\nCzy utworzyć zlecenie złożone?'@[ZL.KTL().NRK,ZL.KTL().WER,ZL.KTM().KTM]
               )
         || _cmplx:=0
         ?};
         {? _cmplx>0
         || _arch:=exec('chk_pf_arch','zl_head',ZL.KTL,_args.DIALOG);
            {? _arch>0
            || _cmplx:=0
            ?}
         ?};

         {? _cmplx>0
         || ZL.RODZAJ:='Z';
            ZL.TREE_TYP:='Z';
            ZL.GENLIM:='P';
            ZL.GENPRZEW:='P';
            ZL.AUTGENZL:='T'
         || ZL.RODZAJ:='P';
            ZL.TREE_TYP:='P';
            ZL.GENLIM:='N';
            ZL.GENPRZEW:='N';
            ZL.AUTGENZL:='N'
         ?}
      |?
::         VAR.A_ZLNAD=null() &
         _args.RODZAJ='Z' | _args.COMPLEX='T'
      || ZL.RODZAJ:='Z';
         ZL.TREE_TYP:='Z';
         ZL.GENLIM:='P';
         ZL.GENPRZEW:='P';
         ZL.AUTGENZL:='T'
      || ZL.RODZAJ:='P';
         ZL.TREE_TYP:='P';
         ZL.GENLIM:='P';
         ZL.GENPRZEW:='P';
         ZL.AUTGENZL:='N'
      ?};

::    Obsługa pola ZL.RP
      {? M.RODZ='T' & (exec('is_podzlec4mag','zl_link')>0 | exec('is_main_podzlec','zl_link'))>0
      || ZL.RP:='T'
      ?};

      SLO.index('KOD');

::    Przypisywanie wydziału
      {? ZL.PROJEKTY<>null() & ZL.PROJEKTY().UD_SKL<>null()
      ||
         UD_SKL.cntx_psh();
         SLO.cntx_psh();
         SLO.index('SL');
         SLO.prefix(XINFO.SLWYDZIA,PROJEKTY.UD_SKL().SYMBOL,);
         {? SLO.first()
         || ZL.JORG:=SLO.ref()
         || _msg:='Błąd konfiguracji systemu.'@+'\n\n'+'Nie znaleziono wydziału: %1.'@[PROJEKTY.UD_SKL().SYMBOL];
            {? VAR.GRUPA='T'
            || KOMM.add(_msg)
            || FUN.emsg(_msg)
            ?}
         ?};
         SLO.cntx_pop();
         UD_SKL.cntx_pop()
      ||
         {? ZL.TYP().WYD<>null()
         || ZL.JORG:=ZL.TYP().WYD
         ||
            _wydzial:=exec('wydzialy','tech_common',_args.TKTL);
            _ii:=obj_len(_wydzial);
            {? _ii=0
            || ZL.JORG:=ST.A_WYD
            |? _ii=1
            || ZL.JORG:=_wydzial[1]
            || ZL.JORG:=null()
            ?};
            {? ZL.JORG=null() & ZL.KTL<>null() || ZL.JORG:=ZL.KTL().JORG ?};
            {? ZL.JORG=null() || ZL.JORG:=ST.A_WYD ?}
         ?}
      ?};
      _mg:=_args.MG;
::    Jeżeli wtyczka zwróci niepuste złączenie, to ma większą moc niż standardowa obsługa
      {? Plugin.runnable('ZL_MG_ZLEC_001')
      || _res:=Plugin.run('ZL_MG_ZLEC_001',ZL.ODDZ,ZL.KTM,ZL.JORG);
         {? type_of(_res)=type_of(MG.ref()) & _res<>null()
         || {? ZL.ODDZ=exec('FindAndGet','#table',MG,_res,,"MG.ODDZ",'')
            || _mg:=_res
            ?}
         ?}
      ?};
      ZL.MG:=_mg;
      {? ZL.MG=null() || ZL.MG:={? ZL.ODDZ=ZL.TYP().MG().ODDZ || ZL.TYP().MG || null() ?} ?};
      {? ZL.MG=null() || ZL.MG:=exec('ustmwyd','zl_common',ZL.ODDZ,ZL.JORG,0) ?};
      exec('ust_znac','zl_head');
      exec('set_rodz_tex','zl_head');
::    Wtyczka na wypełnienie konta kosztowego
      {? Plugin.runnable('ZL_KONTO_001')
      || _kk:=Plugin.run('ZL_KONTO_001',ZL.ODDZ,ZL.JORG);
         {? type_of(_kk)=type_of(KK.ref()) & _kk<>null()
         || ZL.KK:=_kk
         ?}
      ?};
      {? _can_continue>0
      || {? ZL.put()
         || VAR.A_ZLEC:=ZL.ref();
            {? VAR.GRUPA='T' | _args.DIALOG>0
            || _kind:='????';
               {? ZL.RODZAJ='P'
               || _kind:='pojedyncze'@
               |? ZL.RODZAJ='Z'
               || _kind:='z podzleceniami na półfabrykaty'@
               |? ZL.RODZAJ='N'
               || _kind:='z podzleceniami niezależnymi'@
               ?};
               KOMM.add('Wygenerowano zlecenie %1 o symbolu: %2'@[_kind,ZL.SYM],13)
            ?};
            {? ZL.f_active()>1
            || {? VAR.GRUPA='T' | _args.DIALOG>0
               || KOMM.add(' '+'Uwaga. W celu podglądu zlecenia należy odświeżyć filtr.'@,3)
               ?}
            |? ZL.f_active()>0
            || ZL.f_add()
            ?};
            {? ZAKR.ZTP_WP<>'' & ~exec('ctrl_zl','zl_view',ZL.ref())
            || {? VAR.GRUPA='T' | _args.DIALOG>0
               || KOMM.add(' '+'Uwaga. W celu podglądu zlecenia należy zmienić aktualny zakres zleceń.'@,3)
               ?}
            ?};
            exec('zl2obj','px_obj');
            exec('add_zwar_pos','zl_common','_n',0)
         || _can_continue:=0
         ?}
      ?}
   || _msg:='Materiał: %1. Brak w słowniku materiału o podanym identyfikatorze'@[_args.KTM];
      {? VAR.GRUPA='T'
      || KOMM.add(_msg,14)
      || FUN.emsg(_msg)
      ?};
      _can_continue:=0
   ?}
?};
{? _can_continue>0
||
   {? ZL.SCEAN<>'' & ZL.KTM().IDMOB='Z' || exec('mkodkadd','kody_kresk',ZL.KTM,ZL.SCEAN,$ZL.ref()) ?};

:: Dodałem zlecenie - odblokowuję rekord
   {? ZL.STAN='O' || exec('ZK_N_4_ZL_aKC','zamsiw_nag',ZL.ref(),'T') ?};
   ZL.r_unlock()
||
:: Nie udało sie dodać zlecenia - sprzątam
   POM.TAB:='ZL';
   exec('add_grnr','numery','ZLC');
   exec('add_grnr','numery','ZLP');
   POM.TYPDOK:={? ZL.NRNZL=0 || ZL.TYP().KOD_ZLC || ZL.TYP().KOD_ZLP ?};

   numer:=ZL.NR;
   oldnumer:=1;
   ZL.del();
   exec('nr_old','numery')
?};

{? _can_continue>0
|| _zlec:=ZL.ref();
   {? exec('zl_lock','zl_common',,,1)
   || exec('add_zlzam','zl_gen',_zlec,_args.ILOSC,#ZL.KTM);
      _il_manual:=ZL.IL-_args.ILOSC;
      {? _il_manual>0 || exec('add_zleczam','zl_gen',ZL.ref(),_il_manual) ?};
      exec('openmask','zl_common',ZL.ref());
      exec('zl_unlock','zl_common')
   ?}
?};
M.cntx_pop();
PROJEKTY.cntx_pop();

{? _can_continue>0
|| _result:=ZL.ref()
?};
_result


\sel_tpzl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Ustawia typ zlecenia (np. generowanie zleceń z zamówień).
::   WY: null() - nie wybrano typu
::       ZTP.ref() - wybrany typ zlecenia
::  OLD: \sel_tpzl/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=null();
ZTP.win_sel('WER_SEL');
ZTP.actions('WER_SEL','s','W');
ZTP.clear();
_typy:=exec('typy_zlecen','zl_head','P');
ZTP.f_set('TYP',,'ZTP.REFERENCE in (select :_a.REF from :_a) and ZTP.WP=\'P\'',_typy);
{? ZTP.f_first()
|| _result:=exec('zl_b_dod1','zl_gen')
?};
_result


\zl_b_dod1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Wybór typu zlecenia - przed dodaj zlecenie
::   WY: null() lub ZTP.ref
::  OLD: \zl_b_dod1/zlecenia.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=null();

{? ZTP.f_size()>1
|| {? ZTP.select(,,,'s')
   || _result:=ZTP.ref()
   ?}
|| _result:=ZTP.ref()
?};
_result


\add_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Utworzenie tabeli tymczasowej z ref do pozycji zamówienia
::  OLD: \add_ref/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
VAR_DEL.delete('__REF');
__REF:=tab_tmp(2,
   'T','INTEGER','#M.ref()',
   'ZAMPOZ','STRING[16]','$ZK_P.ref()',
   'IL','REAL','Do wykonania',
   'ILZL','REAL','Zlecone',
   'SYM','STRING[20]','Symbol');
~~


\del_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Usunięcie tabeli tymczasowej __REF z ref() do pozycji zamówienia
::  OLD: \del_ref/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
obj_del(__REF);
~~


\clean_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Usunięcie zawartości tabeli tymczasowej __REF z ref() do pozycji zamówienia
::----------------------------------------------------------------------------------------------------------------------
__REF.erase();
~~


\mod_zlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2006]
:: OPIS: Dodaje ilość do zlecenia i tworzy powiązania z pozycją zamówienia
::       Zakłada się, że zlecenie, do którego dołączane jest zamówienie nie ma przewodników ani limitów
::   WE: _a - ZL.ref()
::       _b - Ilość na zleceniu
::       _c - dodatkowy opis
::   WY: null() lub ZL.ref() zlecenia do którego dodano ilość
::  OLD: \mod_zl/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
:: UWAGA: brak kontroli obecnosci i typow parametrow!
_zlec:=_a;
_il:=_b;
_opis:=_c;

ZL.cntx_psh();
ZL.prefix();

{? ZL.seek(_zlec)
|| _wynik:=ZL.ref();
   {? exec('zl_lock','zl_common',_zlec,,1)
   ||
      _eat_free:=exec('get','#params',500113,2);
      {? _eat_free='T'
      ||
::       Najpierw wykorzystana wolna ilość (ręcznie dodana), potem dopiero zwiększenie ilości na zleceniu
         _il_free:=exec('zl_il_free','zl_gen',_zlec)
      || _il_free:=0
      ?};
      {? _il>_il_free || _il_plus:=_il-_il_free; _il_dec:=_il_free || _il_plus:=0; _il_dec:=_il ?};
      ZL.IL+=_il_plus;
::    Dodatkowy opis nie jest dodawany, gdy już taki ciąg znaków istnieje
      {? ZL.OPIS*_opis=0 || ZL.OPIS+='+'+_opis ?};
      {? ZL.put()
      || exec('zl2obj','px_obj');
         exec('add_zlzam','zl_gen',_zlec,_il,#ZL.KTM);
         exec('zl_dec_free','zl_gen',_zlec,_il_dec)
      ?};
      exec('zl_unlock','zl_common')
   ?}
|| _wynik:=null()
?};

ZL.cntx_pop();
_wynik


\wyb_ktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2010]
:: OPIS: Zwraca domyslna karte technologicznym dla zlecenia
::   WE: [_a] - INTEGER - 0/[1] - czy wyswietlac dialogi
::       [_b] - INTEGER - [0]/1 - czy pytac przed zamknieciem okna czy na pewno zrezygnowac
::   WY: TKTL.ref()
::  OLD: \wyb_ktl/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_ktl:=null();

_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};

_esc_confirm:=1;
{? var_pres('_b')=type_of(0)
|| _esc_confirm:=_b
?};

TKTLW.clear();
TKTLW.index('KSN');
::TKTLW.prefix('T',M.ref(),'T','N');
TKTLW.f_set(,'join TKTL using (TKTLW.TKTL,TKTL.REFERENCE)'
            ,'
            TKTL.TORW=\'T\'
            and TKTLW.KTM=:_a
            and TKTL.STAN=\'T\'
            and TKTL.ARCH=\'N\'
            and ((TKTL.TERM_OD<=to_date(:_b) and TKTL.TERM_OD IS NOT NULL)
            or TKTL.TERM_OD IS NULL)
            and ((TKTL.TERM_DO>=to_date(:_b) and TKTL.TERM_DO IS NOT NULL)
            or TKTL.TERM_DO IS NULL)
            '
            ,M.ref(),date());
{? TKTLW.f_first()
|| {? TKTLW.f_size() > 1
   || {? _dialog>0
      ||
::       Tworze okno grupowe
         _close:="";

         {? _esc_confirm>0
         || _close:="
              _context:=_a;

              _result:=1;
              {? _context<>'sel_exit'
              || _result:=FUN.ask('Czy na pewno pozostawić kartę technologiczną na zleceniu pustą?'@)
              ?};
               _result
            "
         ?};

         _grp:=TKTLW.grp_make('Karty technologiczne'@,,'#tktlw_wyb_ktl',1,1,_close,,'normal');
         TKTLW.grp_sel(_grp,,'WER_P',,,,,,,,,,'maximized');
         TKTLW.win_sel(_grp);
         TKTLW.hdr_sel(' - wybór do zlecenia'@);
         {!
         |? {? TKTLW.TKTL().DEFAULT='T'
            || _ktl:=TKTLW.TKTL;
               0
            || TKTLW.f_next()
            ?}
         !};
         {? _ktl=null() || TKTLW.first() ?};
         _ktl:=null();
         {? TKTLW.select(0,1)<>0
         || _ktl:=TKTLW.TKTL
         ?}
      || {!
         |? {? TKTLW.TKTL().DEFAULT='T'
            || _ktl:=TKTLW.TKTL;
               0
            || TKTLW.f_next()
            ?}
         !};
         {? _ktl=null()
         || _ktl:=TKTLW.TKTL
         ?}
      ?}
   || _ktl:=TKTLW.TKTL
   ?}
|| _txt:='Brak karty technologicznej dla produktu: %1'@[M.KTM];
   {? ~KOMM.find_msg(_txt) || KOMM.add(_txt,4) ?}
?};
TKTLW.f_clear();
_ktl


\add_zlzam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Dodaje pozycje do tabeli ZLZAM (Generowanie zleceń z listy pozycji zamówień)
::       Kontekst wywołania: tabele __REF
::   WE: _a: ZL.ref()
::       _b: Ilość
::       _c: #M.ref()
::  OLD: \chk_zampoz/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
_zlec:=_a;
_il:=_b;
_kontr:=0;

__REF.clear();
::__REF.prefix(_c);
{? __REF.first()
|| {!
   |? _ilp:=__REF.IL-__REF.ILZL;
      {? _kontr<_il & __REF.IL-__REF.ILZL>0
      || {? _ilp<=_il
         || _kontr+=_ilp; __REF.IL-=_ilp
         || _kontr+=_il; __REF.IL-=_il
         ?};
         __REF.put();
         {? _ilp<=_il
         || exec('add_zleczam','zl_gen',_zlec,{? _il<_ilp || _il || _ilp ?},__REF.ZAMPOZ);
            _il-=_ilp;
            _kontr-=_ilp
         || exec('add_zleczam','zl_gen',_zlec,{? _il<_ilp || _il || _ilp ?},__REF.ZAMPOZ)
         ?}
      ?};
      __REF.next()
   !}
?};
~~


\zl_il_free
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca ilosc dopisana 'recznie' do zlecenia - ilosc wolna
::   WE: _a - ZL.ref()
::  OLD: \zl_il_free/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
_il:=0;
ZLZAM.cntx_psh();
ZLZAM.index('ZMZL0');
ZLZAM.prefix('',_a);
:: Jest najwyzej jeden wolny rekord
{? ZLZAM.first() || _il+=ZLZAM.ILZL ?};
ZLZAM.cntx_pop();
_il


\zl_il_zam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.42]
:: OPIS: Zwraca ilosc ze zlecenia która została wygenerowana na podstawie zamówień
::   WE: _a - ZL.ref()
::   WY: REAL
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_result:=0;
ZLZAM.cntx_psh();
ZLZAM.index('SRC');
ZLZAM.prefix(_zl,'Z');
{? ZLZAM.first()
|| {!
   |? _result+=ZLZAM.ILZL;
      ZLZAM.next()
   !}
?};
ZLZAM.cntx_pop();
_result


\zl_dec_free
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zmiejsza ilość dopisaną 'ręcznie' do zlecenia - ilość wolna
::   WE: _a - ZL.ref()
::       _b - ilość do zmiejszenia
::  OLD: \zl_dec_free/zlec3.fml
::----------------------------------------------------------------------------------------------------------------------
ZLZAM.cntx_psh();
ZLZAM.index('ZMZL0');
ZLZAM.prefix('',_a);
:: Jest najwyżej jeden wolny rekord
{? ZLZAM.first()
|| {? _b>=ZLZAM.ILZL
   || exec('zlzam2Rez','zamsiw_wspolne',ZLZAM.ZAMPOZ,-1,0);
      ZLZAM.del()
   || ZLZAM.ILZL-=_b;
      {? ZLZAM.put() || exec('zlzam2Rez','zamsiw_wspolne',ZLZAM.ZAMPOZ,1,ZLZAM.ILZL) ?}
   ?}
?};
ZLZAM.cntx_pop();
~~


\red_ktl_xx
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: wspólna treść formuł dla pola ZLEC.RED_KTL
::----------------------------------------------------------------------------------------------------------------------
:: znaleźć TKTL...
ZLEC.RED_KTL:=ZLEC.TKTL().NRK;
ZLEC.RED_WER:=TKTL.WER;
ZLEC.SERIA:=TKTL.SERIA;
~~


\red_ktl_pw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: przed wyświetl ZLEC.RED_KTL
::   WY: 0 / 1 / kolor
::----------------------------------------------------------------------------------------------------------------------
exec('red_ktl_xx','zl_gen');
1


\red_ktl_pr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: przed redakcją ZLEC.RED_KTL
::----------------------------------------------------------------------------------------------------------------------
_edit:=params_get().env_gen.edit_TKTL;

{? ~_edit
|| 0
|| exec('red_ktl_xx','zl_gen');
   1
?}


\red_ktl_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: na F3 dla ZLEC.RED_KTL
::----------------------------------------------------------------------------------------------------------------------
TKTLW.win_sel('WER_P');
TKTLW.index('KSN');
::TKTLW.prefix('T',VAR.A_T,'T','N');
TKTLW.prefix();
TKTLW.f_set('TKTL(NRK),TKTL(WER)','join TKTL using (TKTLW.TKTL,TKTL.REFERENCE)'
            ,'
            TKTL.TORW=\'T\'
            and TKTLW.KTM=:_a
            and TKTL.STAN=\'T\'
            and TKTL.ARCH=\'N\'
            and ((TKTL.TERM_OD<=to_date(:_b) and TKTL.TERM_OD IS NOT NULL)
            or TKTL.TERM_OD IS NULL)
            and ((TKTL.TERM_DO>=to_date(:_b) and TKTL.TERM_DO IS NOT NULL)
            or TKTL.TERM_DO IS NULL)
            '
            ,VAR.A_T,date());

{? TKTLW.f_first()
|| TKTLW.f_find(ZLEC.RED_KTL,ZLEC.RED_WER);
   {? TKTLW.select(,1,10)
   ||
      _tktl:=ZLEC.TKTL;
      ZLEC.TKTL:=TKTLW.TKTL;
      ZLEC.RED_KTL:=TKTLW.TKTL().NRK;
      ZLEC.RED_WER:=TKTL.WER;
      _edi_complex:=params_get().env_gen.edit_COMPLEX;
::    Jeżeli możliwa modyfikacja kategorii zlecenia, to podpowiadam na podstawie technologii
      {? _tktl<>ZLEC.TKTL & _edi_complex>0
      || {? VAR.GRUPA<>'T'
         || ZLEC.COMPLEX:={? exec('czy_pf','tech_mater',ZLEC.TKTL) || 'T' || 'N' ?}
         || {? VAR.A_ZLNAD=null()
            || {? exec('czy_pf','tech_mater',ZLEC.TKTL)
               || ZLEC.RODZAJ:='Z';ZLEC.COMPLEX:='T'
               || ZLEC.RODZAJ:='P';ZLEC.COMPLEX:='N'
               ?}
            || ZLEC.RODZAJ:='P';ZLEC.COMPLEX:='N'
            ?}
         ?}
      ?}
   ?}
||
   FUN.info('Wskazany produkt nie ma technologii.'@)
?};
TKTLW.f_clear();
ZLEC.RED_KTL


\red_ktl_po
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: po redakcji ZLEC.RED_KTL
::----------------------------------------------------------------------------------------------------------------------
_complex:=params_get().args.COMPLEX;
_edi_complex:=params_get().env_gen.edit_COMPLEX;
_tktl:=ZLEC.TKTL().NRK;
_wer:=ZLEC.TKTL().WER;
_ret:=1;
TKTLW.cntx_psh();
{? chk_fld(1)
|| TKTLW.index('KSN');
   TKTLW.prefix('T',VAR.A_T,'T','N',ZLEC.RED_KTL,ZLEC.RED_WER);
   {? TKTLW.first()
   ||
::      _ret:=exec('spr1_tech','zl_head')
      _tktl_ref:=ZLEC.TKTL;
      ZLEC.TKTL:=TKTLW.TKTL;

      {? _tktl_ref<>ZLEC.TKTL & _edi_complex>0
      || {? VAR.GRUPA<>'T'
         || ZLEC.COMPLEX:={? exec('czy_pf','tech_mater',ZLEC.TKTL) || 'T' || 'N' ?}
         || {? VAR.A_ZLNAD=null()
            || {? exec('czy_pf','tech_mater',ZLEC.TKTL)
               || ZLEC.RODZAJ:='Z'
               || ZLEC.RODZAJ:='P'
               ?}
            || ZLEC.RODZAJ:='P'
            ?}
         ?}
      ?};
      1
   || _wyb:=choice('Brak pozycji w słowniku.'@,FUN.TYT,'EXCLAM',1,0,,'Powtórzenie'@,'Rezygnacja'@);
      {? _wyb=1
      || ZLEC.RED_KTL:=_tktl;
         ~~
      ?};
      _ret:=0
   ?}
||
::   _ret:=exec('valid_tech','zl_head')
   ZLEC.TKTL:=null();
   _ret:=1
?};
TKTLW.cntx_pop();
win_disp();
_ret


\zl_gen_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Formuła na format wyświetlania pól zmiennej ZLEC: IL_ZKP, IL_ZLEC, IL_2DIV, IL_ZLEC, IL_ALL, IL_1ZL
::   WY: STRING
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_dokl:=exec('jaka_dok_m','jm',VAR.A_T);
_result:='out_prec='+$_dokl;
_result


\zl_gen_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Formuła na format redagowania pól zmiennej ZLEC: IL_ZKP, IL_ZLEC, IL_2DIV, IL_ZLEC, IL_ALL, IL_1ZL
::   WY: STRING
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_dokl:=exec('jaka_dok_m','jm',VAR.A_T);
_result:='in_prec='+$_dokl;
_result


\zl_gen_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed redagowaniem pól zmiennej ZLEC: ZTP, COMPLEX, RODZAJ, IL_2DIV, IL_ZLEC
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
{? cur_afld()='ZTP'
|| _result:=params_get().env_gen.edit_ZTP;
   {? _result>0
   || ZLEC.efld_opt(cur_win(1,1),'mark=1',,'ZTP')
   || ZLEC.efld_opt(cur_win(1,1),'mark=0',,'ZTP')
   ?}
|? cur_afld()='COMPLEX'
|| _result:=params_get().env_gen.edit_COMPLEX;
   {? _result>0 & ZLEC.TKTL<>null()
   || _result:=exec('czy_pf','tech_mater',ZLEC.TKTL)
   ?}
|? cur_afld()='RODZAJ'
|| _result:=VAR.A_ZLNAD=null() & exec('czy_pf','tech_mater',ZLEC.TKTL)
|? cur_afld()='IL_2DIV' | cur_afld()='IL_ZLEC'
|| _result:=params_get().env_gen.edit_IL
?};
_result


\zl_gen_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Po redagowaniu pól zmiennej ZLEC: L_ZL, IL_1ZL
::----------------------------------------------------------------------------------------------------------------------
{? cur_afld()='L_ZL' | cur_afld()='IL_1ZL'
|| ZLEC.IL_ALL:=ZLEC.L_ZL*ZLEC.IL_1ZL
?};
1


\env_gen
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Środowisko generatora zleceń z pozycji zamówień
::----------------------------------------------------------------------------------------------------------------------
_env_gen:=obj_new('edit_ZTP','edit_IL','edit_TKTL','edit_COMPLEX','edit_MERGE');

:: redagowanie typu zlecenia
_env_gen.edit_ZTP:=1;
:: redagowanie ilości
_env_gen.edit_IL:=1;
:: redagowanie karty technologicznej
_env_gen.edit_TKTL:=1;
:: redagowanie znacznika, czy zlecenie złożone
_env_gen.edit_COMPLEX:=1;
:: redagowanie zlecenia do którego się łaczymy
_env_gen.edit_MERGE:=1;

_env_gen


\utwzlec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Tworzy nowe zlecenie półfabrykatowe.
::       Kontekst wywołania - rekord tabeli ZL (zlecenie, do którego będzie podpinane zlecenie podrzędne)
::   WE: _a - M.ref() - półfabrykat
::       _b - TKTL.ref() - karta technologiczna
::       _c - ilość na jaką ma być zlecenie
::       _d - poziom
::       _e - numer podzlecenia nadrzędnego
::       _f - czy funkcja wywołana z poziomu analizy zleceń (1 - tak, 0 - nie)
::       _g - wydział którego dotyczy zlecenie
::       [_h] - ('T' - z dialogami - domyślnie, 'N'- bez dialogów)
::       [_i] - DK_C.ref() - cecha (domyślnie pusta)
::       [_j] - magazyn
::       _k - klucz grupujący
::       _l - TMAT.ref() - źródłowe zapotrzebowanie półfabrykatowe które spowodowało wygenerowanie podzlecenia
::       [_m] - PROJEKTY.ref() - wskazanie na projekts
::   WY: ZL.ref() / null()
::  OLD: \utwzlec/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_h')=type_of('')         || _dialog:=_h || _dialog:='T'  ?};
{? var_pres('_i')=type_of(DK_C.ref()) || _dk_c:=_i   || _dk_c:=null() ?};
{? var_pres('_j')=type_of(null())     || _mg:=_j     || _mg:=null()   ?};
{? var_pres('_k')=type_of('') || _grp_key:=_k || FUN.error('Parametr \'klucz grupujący\' jest wymagany.'@); return() ?};
{? var_pres('_l')=type_of(TMAT.ref()) || _tmat:=_l || FUN.error('Parametr \'TMAT\' jest wymagany.'@); return() ?};
{? var_pres('_m')=type_of(null())     || _projekty:=_m     || _projekty:=null()   ?};

_tktl:=_b;
_ilosc:=_c;

_new_order:=null();

:: Część danych "odtwarzam" bezpośrednio ze zlecenia nadrzędnego
_opis:=ZL.OPIS;
::_rodzaj:=ZL.RODZAJ;
_genlim:=ZL.GENLIM;
_genrp:=ZL.GENRP;
_autogenzl:=ZL.AUTGENZL;
_unnr:=ZL.NRNZL;
_nstan:=ZL.NSTAN;
_tree:=#ZL.ref();
_dtr:=ZL.DTR;
_pl_data:=ZL.PL_DATA;
_ilp:=exec('get','#params',500205,1);

ZL.RODZAJ:='P';
ZL.TREE_TYP:='F';
ZL.LEVEL:=_d;
ZL.NRPZL:=_e;
ZL.NRNZL:=_unnr;
ZL.GENPRZEW:='P';
ZL.GENLIM:=_genlim;
ZL.AUTGENZL:=_autogenzl;
::ZL.GENRP:=_genrp;
ZL.KTM:=_a;
ZL.KTL:=_tktl;
ZL.RKTL:='';
ZL.OPIS:='Półfabrykat: '+ZL.KTM().KTM;
ZL.OD:=date();
ZL.DO:=date(0,0,0);
ZL.TKTL:=null();
ZL.RTKTL:='';
ZL.POWOL:=OPERATOR.USER;
ZL.DZATW:=date(0,0,0);
ZL.ZATW:=null();
ZL.CLOSED:=null();
ZL.HIDDEN:='T';
ZL.ZMASK:=20*'1';
ZL.DTR:=(_dtr-_ilp);
ZL.PL_DATA:=(_pl_data-_ilp);
ZL.MASKA:='____';
ZL.ILWYK:=0;
ZL.ILWYK_D:=0;
ZL.NSTAN:=_nstan;
ZL.TREE:=_tree;

ZL.STAT_N:='N';
ZL.STAT_T:='N';
ZL.STAN:='N';

ZL.GRP_KEY:=_grp_key;
ZL.TMAT_SRC:=_tmat;
ZL.RTMATSRC:=$_tmat;
{? exec('is_podzlec4mag','zl_link')>0
|| ZL.RP:='T'
|| ZL.RP:='N'
?};

{? _>=7
|| ZL.JORG:=_g
?};

:: Jeżeli wtyczka zwróci niepuste złączenie, to ma większą moc niż standardowa obsługa
_res:=Plugin.run('ZL_MG_PODZLEC_001',ZL.ODDZ,ZL.KTM,ZL.JORG);

{? type_of(_res)=type_of(MG.ref()) & _res<>null()
|| _mg:=_res
?};

ZL.MG:=_mg;
ZL.PROJEKTY:=_projekty;

{? ZL.PROJEKTY<>null()
|| PROJEKTY.cntx_psh();
   {? ZL.PROJEKTY().UD_SKL<>null()
   || ZL.PROJEKTY();
      UD_SKL.cntx_psh();
      SLO.cntx_psh();
      SLO.index('SL');
      SLO.prefix(XINFO.SLWYDZIA,PROJEKTY.UD_SKL().SYMBOL,);
      {? SLO.first()
      || ZL.JORG:=SLO.ref()
      || KOMM.add('Błąd konfiguracji systemu.'@+'\n\n'+'Nie znaleziono wydziału: %1.'@[PROJEKTY.UD_SKL().SYMBOL])
      ?};
      SLO.cntx_pop();
      UD_SKL.cntx_pop()
   ?};
   PROJEKTY.cntx_pop();
   ~~
?};

{? ZL.MG=null() || ZL.MG:=exec('ustmwyd','zl_common',ZL.ODDZ,ZL.JORG,0) ?};
{? _f=1 | _dialog='N'
|| ZL.IL:=_ilosc
|| ZL.IL:=exec('sprtdost','zl_gen',ZL.KTM,_ilosc)$exec('jaka_dok_m','jm',ZL.KTM)
?};
ZL.IL0:=ZL.IL;
ZL.DK_C:=_dk_c;
ZL.SCEAN:=exec('blzl_sce','kody_kresk');
ZL.ZLEAN:=exec('blzl2sce','kody_kresk');
ZL.ID_KSG:=exec('zl_idksg_bl','zl_head');
:: Wtyczka na wypełnienie konta kosztowego
{? Plugin.runnable('ZL_KONTO_001')
|| _kk:=Plugin.run('ZL_KONTO_001',ZL.ODDZ,ZL.KTM,ZL.JORG);
   {? type_of(_kk)=type_of(KK.ref()) & _kk<>null()
   || ZL.KK:=_kk
   ?}
?};
exec('ust_znac','zl_head');
{? ZL.IL>0
|| {? ZL.TREE || ZL.NODE:=exec('node','zl_head') ?};
   ZL.cntx_psh();
   ZL.clear();
   ZL.SYM:='~'+$ZL.tm_stamp();
   ZL.memo_get(,'OPIS_DOD',0);
   _ok:=ZL.add(1);
   {? _ok
   || POM.TAB:='ZL';
      exec('add_grnr','numery','ZLP');
      POM.TYPDOK:=ZL.TYP().KOD_ZLP;
      ZL.NR:=0;
      ZL.NR:=exec('numer_new','numery','PACZKA');
      exec('znak','numery','ZL',1);
      ZL.memo_put(,'OPIS_DOD');
      {? ZL.TREE=0 || ZL.NODE:=exec('node','zl_head') ?};
      ZL.put();
      {? ZL.SCEAN<>'' & ZL.KTM().IDMOB='Z' || exec('mkodkadd','kody_kresk',ZL.KTM,ZL.SCEAN,$ZL.ref()) ?};
      exec('openmask','zl_common',ZL.ref());
      exec('zl2obj','px_obj');
      exec('add_zleczam','zl_gen',ZL.ref(),ZL.IL);

      KOMM.add('Wygenerowano podzlecenie %1'@[ZL.SYM]);
      _new_order:=ZL.ref()

   ?};
   _zl:=VAR.A_ZLEC;
   VAR.A_ZLEC:=ZL.ref();
   exec('add_zwar_pos','zl_common','_n',0);
   VAR.A_ZLEC:=_zl;
   ZL.cntx_pop()
?};
_new_order


\podzlec_il_upd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Aktualizuje ilość na wszystkich bezpośrednich podzleceniach przekazanego zlecenia
::       mnożąc tę ilość przez przekazaną proporcję. Do chodzenia po drzewie zleceń korzysta z pola
::       ZL.NRPZL
::   WE: _a - INTEGER - unikalny numer zlecenia, któremu zaktualizować podzlecenia
:;       _b - REAL - proporcja przez ktorą pomnożyć aktualną ilość aby otrzymać nową ilość
::   WY: 0 - porazka
::       1 - sukces
::  OLD: \podzlec_il_upd/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_unrzl:=_a;
_prop:=_b;

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
ZL.index('NRPZL');
ZL.prefix(_unrzl);
{? ZL.first()
|| {!
   |?
::    Obliczam nową ilość
      _il:=ZL.IL*_prop;

::    Skaluję ją do dokładności magazynowej
      _dokl:=exec('jaka_dok_m','jm',ZL.KTM);

      _il:=_il$_dokl;

      ZL.IL:=_il;
      _can_continue:=ZL.put();

      {? _can_continue>0
      ||
::       !!! REKURENCJA !!!
         _can_continue:=exec('podzlec_il_upd','zl_gen',ZL.UNRZL,_prop)
      ?};
      ZL.next() & _can_continue>0
   !}
?};
ZL.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result


\sprtdost
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Sprawdza aktualne ilości dostępne i proponuje ilość, na którą warto powołać zlecenie
::   WE: _a - M.ref()
::       _b - propozycja ilości
::   WY: _wynik - ilość na jaką ma być utworzone zlecenie
::  OLD: \sprtdost/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_wynik:=0;

_tab:=tab_tmp(1,
   'ILOSC','REAL','Ilość',
   'CALOSC','REAL','Całość',
   'CZESC','REAL','Część',
   'DOSTEPNE','REAL','Dostępne',
   'KTM','STRING[50]','KTM'
);
_tab.fld_fml('CALOSC','BEFORE_EDIT',"0");
_tab.fld_fml('CZESC','BEFORE_EDIT',"0");
_tab.fld_fml('DOSTEPNE','BEFORE_EDIT',"0");
_tab.fld_fml('KTM','BEFORE_EDIT',"0");

M.cntx_psh();
M.prefix();
{? M.seek(_a)
||
   _result:=exec('stan_ktr_one','zl_limit',M.ref(),_b);
   _tab.CALOSC:=_b;
   _tab.KTM:=M.KTM;

:: Nie ma nic na stanie i nie będzie - przyjmujemy produkcję wszystkiego
   {? _result[4]<0 & _result[4]=-_b
   || _wynik:=_b

:: Jest część na stanie lub będzie - sugestia zmniejszenia ilości
:: Jest całość na stanie lub będzie - sugestia, żeby nic nie robić
   || _tab.ILOSC:=_tab.CZESC:=-_result[4];
      {? _tab.ILOSC<0 || _tab.ILOSC:=0 ?};
      _tab.DOSTEPNE:=_tab.CALOSC-_tab.CZESC;
      _red:=_tab.mk_edit('Zlecenie półfabrykatowe'@);
      _tab.win_efld(_red,,'KTM',,,,,,'Półfabrykat'@);
      _tab.win_efld(_red,,'CALOSC',,,15,,,'Zapotrzebowanie'@);
      _tab.win_efld(_red,,'DOSTEPNE',,,15,,,'Stan dostępny'@);
      _tab.win_efld(_red,,'ILOSC',,,15,,,'Ilość na podzleceniu'@);
      _btn:=_tab.win_ebtn(_red,'text=%1,align=begin'['Całość'@],
         "cur_tab(1,1).ILOSC:=cur_tab(1,1).CALOSC; ''"
      );
      _tab.btn_eopt(_red,_btn,'tooltip='+'Przepisuje całe zapotrzebowanie do pola \'Ilość na podzleceniu\'.'@);
      _btn:=_tab.win_ebtn(_red,'text=%1,align=begin'['Wg stanów'@],
         "cur_tab(1,1).ILOSC:=cur_tab(1,1).CZESC; {? cur_tab(1,1).ILOSC<0 || cur_tab(1,1).ILOSC:=0 ?}; ''"
      );
      _tab.btn_eopt(_red,_btn,'tooltip='+'Przepisuje wyliczoną ilość wg stanów do pola \'ilość na podzleceniu\'.'@);
      _tab.win_ebtn(_red,'text=%1,align=end'['&Zapisz'@],'key:F2');
      _tab.win_ebtn(_red,'text=%1,align=end'['&Anuluj'@],'key:Esc');
      _tab.win_edit(_red);
      {? _tab.edit("exec('itsPositive','#field',1,'T',cur_tab.ILOSC)")
      || _wynik:=_tab.ILOSC
      ?}
   ?}
?};
M.cntx_pop();
_wynik


\gen_zl4tmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Generuje jedno zlecenie podrzędne na półfabrykat wg podanego TMAT,
::       podpięte pod zlecenie i na ilość wg podanego ZL
::   WE: _a - ZL.ref()
::       _b - TMAT.ref()
::       [_c] - STRING - 'T'/'N' - czy pokazywać dialogi (domyslnie 'T')
::       _d - STRING - klucz grupujący, którym będą ostemplowane generowane zlecenia
::   WY: ZL.ref() utworzonego zlecenia
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_tmat:=_b;
{? var_pres('_c')=type_of('') || _dialog:=_c || _dialog:='T' ?};
_grp_key:=_d;

_new_order:=null();

:: Kontekst (maski) tabel technologicznych jest ustawiony przed wywołaniem tej formuły

ZL.cntx_psh(); TMAT.cntx_psh();
ZL.prefix(); TMAT.prefix();

{? ZL.seek(_zl) & TMAT.seek(_tmat)
|| {? (TMAT.RKTL<>'' | TMAT.DFLT_KTL='T') & TMAT.LIMIT='T' & TMAT.MAG<>'T'
   || {? exec('zl_lock','zl_common',#ZL.ref(),'T',1)
      || {? TMAT.GRKTM='G'
         || _ktm:=TMAT.TGDFLT().PT;
            _mktm:=TMAT.TGDFLT().PT().KTM
         || _ktm:=TMAT.PT;
            _mktm:=TMAT.PT().KTM
         ?};
         _can_continue:=1;
         ZLIM.index('RTMAT2');
         ZLIM.prefix($TMAT.ref(),ZL.ref);

         {? TMAT.MAG<>'P'
         ||
::          Dla zleceń nieraportowanych do magazynu i niepobieranych z magazynu sprawdzam czy są już limity na ten
::          polfabrykat
            {? ZLIM.first()
            ||
::             Powiązany limit, nie generuję podzlecenia
               _msg:='Do surowca %1 wygenerowano limit. Zlecenie podrzędne nie powstało.'@[_mktm];
               KOMM.add(_msg,'xwin16.png:2');
               _can_continue:=0
            ?}
         ?};
         {? _can_continue>0
         || _tktl_id:='';
            {? TMAT.DFLT_KTL='T'
            || _ktlz:=exec('dflt_ktl','tech_prod',_ktm,,1);
               TKTL.cntx_psh();
               TKTL.clear();
               {? TKTL.seek(_ktlz)
               || _jorg:=TKTL.JORG
               || _jorg:=null()
               ?};
               TKTL.cntx_pop()
            || TKTL.cntx_psh();
               _msk_old:=TKTL.name();
               _msk_new:=form(8+TMAT.RKTL);
               {? _msk_new<>_msk_old
               || TKTL.use(_msk_new)
               ?};
               TKTL.clear();
               {? TKTL.seek(TMAT.RKTL)
               || _ktlz:=TKTL.ref();
                  _jorg:=TKTL.JORG;
                  _tktl_id:=exec('record','#to_string',TKTL.ref())
               || _ktlz:=null();
                  _jorg:=null()
               ?};
               TKTL.cntx_pop()
            ?};

            {? _ktlz=null()
            ||
::             Brak karty (domyślnej), nie generuję podzlecenia
               _msg:='Brak technologii dla półfabrykatu: %1. Zlecenie podrzędne nie powstało.'@[_mktm];
               KOMM.add(_msg,'xwin16.png:2')
            ||
::             Sprawdzam czy karta technologiczna zlecenia jest w archiwum
               _arch:=exec('FindAndGet','#table',TKTL,_ktlz,,"ARCH",'N');
               _xjm:=exec('FindAndGet','#table',TKTL,TMAT.NRK,,"XJM",0);

               {? _arch='N'
               ||
                  {? ZL.TYP().TECH='N' & ~exec('tktl_act','tech_head',,$_ktlz)
                  ||
::                   Karta jest nieaktualna, nie generuję podzlecenia (tylko dla zleceń bez własnej technologii)
                     _msg:='Technologia półfabrykatu: %1 jest nieaktualna. Zlecenie podrzędne nie powstało.'@[_tktl_id];
                     KOMM.add(_msg,'xwin16.png:2')
                  ||
::                   Karta nie jest w archiwum więc tworzę podzlecenie
                     _dokl:=exec('jaka_dok_m','jm',_ktm);
                     _il:={? _dokl>0
                          || ((TMAT.WARB*ZL.IL)/_xjm)$_dokl
                          || exec('ceil','#math',((TMAT.WARB*ZL.IL)/_xjm))
                          ?};
                     {? _il<>0
                     || _wyd:={? _jorg=null() || ST.A_WYD || _jorg ?};
::                      Tworzę cechę dla podzlecenia w taki sam sposób jak dla limitu
                        _dk_c:=exec('create_dkc','zl_common',ZL.DK_C,TMAT.DK_C,TMAT.ATR_MASK,_ktm);
::                      Dla zlecenia montażowego inaczej wyliczany LEVEL zleceń podrzędnych (są na tym samym poziomie)
                        _main_podzlec:=exec('is_main_podzlec','zl_link',ZL.ref());
                        ZL.cntx_psh();
                        _new_order:=exec('utwzlec','zl_gen',
                           _ktm,
                           _ktlz,
                           _il,
                           ZL.LEVEL+{? _main_podzlec || 0 || 1 ?},
                           ZL.UNRZL,
                           0,
                           _wyd,
                           _dialog,
                           _dk_c,
                           ZL.MG,
                           _grp_key,
                           TMAT.ref(),
                           ZL.PROJEKTY
                        );
                        ZL.cntx_pop()
                     ?}
                  ?}
               ||
::                Karta jest w archiwum, nie generuję podzlecenia
                  _msg:='Technologia półfabrykatu: %1 jest w archiwum. Zlecenie podrzędne nie powstało.'@[_tktl_id];
                  KOMM.add(_msg,'xwin16.png:2')
               ?}
            ?}
         ?};
         exec('zl_unlock','zl_common',#ZL.ref(),'T')
      ||
::       Karta blokowana przez innego operatora, nie generuję podzlecenia
         _msg:='Karta technologiczna zlecenia jest redagowana przez innego operatora.'@;
         KOMM.add(_msg,'xwin16.png:2')
      ?}
   ?}
?};

ZL.cntx_pop(); TMAT.cntx_pop();

_new_order


\zl_proj_inherit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.14]
:: OPIS: Sprawdza czy zlecenie może odziedziczyć projekt przekazany w argumencie
::       Kontekst działania - rekord ZL
::   WE: _a - PROJEKTY.ref() - wskazanie na projekt
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_projekty:=_a;

_result:=0;
PROJEKTY.cntx_psh(); PROJEKTY.prefix();
{? PROJEKTY.seek(_projekty)
|| {? ZL.TYP().PROJZAKR<>exec('projzakr_nie_dotyczy','projekty')
   ||
      {? ZTP.PROJZAKR=exec('projzakr_wszystkie','projekty')
      ||
::       Typ zlecenia projektowy akceptujący każdy rodzaj projektu
         _result:=1
      ||
::       Typ zlecenia projektowy, sprawdzam jeszcze czy się rodzaj projektu zgadza
         {? (PROJEKTY.T().R-1)=(ZL.TYP().PROJZAKR-1)
         || _result:=1
         ?}
      ?}
   ?}
?};
PROJEKTY.cntx_pop();
_result


\zl_to_merge
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.42]
:: OPIS: Wybór zlecenia, którego ilość będzie zwiększana zamiast generowania nowego zlecenia z pozycji zamówienia
::   WE: _a - M.ref()
::       _b - DK_C.ref()
::       _c - data
::       _d - ZTP.ref()
::       _e - KH.ref()
::       _f - TKTL.ref()
::       _g - PROJEKTY.ref()
::       _h - zlecenie złożone
::       _i - ZL.ref()/null() - zlecenie, które było wcześniej wybrane
::   WY: obj_new(): ZL - ZL.ref()/null(); selected - czy zatwierdzony wybór
::----------------------------------------------------------------------------------------------------------------------
_ktm:=_a;
_dk_c:=_b;
_data:=_c;
_ztp:=_d;
_kh:=_e; _kh_ref:=$_kh; _kh_skr:=exec('FindAndGet','#table',KH,_kh,,"SKR",'');
_tktl:=_f;
_projekty:=_g;
_complex:=_h;

_result:=obj_new('ZL','selected');
_result.ZL:=_i; _result.selected:=0;

_env_gen:=params_get().env_gen;

ZL.cntx_psh();
ZL.clear();

_tab:=sql('
   select
      ZL.SYM as SYMBOL,
      ZL.OPIS as OPIS,
      ZL.DTR as DATA,
      ZL.PL_DATA as PL_DATA,
      ZL.PL_TIME as PL_TIME,
      ZL.IL,
      TKTL.SERIA,
      KH.KOD as KH,
      KH.REFERENCE as KH_REF,
      TKTL.NRK,
      TKTL.WER,
      ZL.REFERENCE as ZL_REF,
      DK_C.REFERENCE as DKC_REF,
      ZTP.REFERENCE as ZL_TYP,
      ZTP.TYP as TYP_SYM
   from ZL
     left join TKTL using(ZL.KTL, TKTL.REFERENCE)
      left join KH using(ZL.KH, KH.REFERENCE)
       left join DK_C using(ZL.DK_C, DK_C.REFERENCE)
        left join ZTP using(ZL.TYP, ZTP.REFERENCE)
   where ZL.KTM=:_a
    and (ZL.DTR<=to_date(:_b) and ZL.DTR is not null or :_b=\'0000-0-0\')
    and ZL.STAN=''N'' and ZL.NRNZL=0 and ZL.RODZAJ=\':_g\'
    and ZL.PLAN_PX<>''T''
    and ZL.PLAN_PO<>''T''
    and (:_c=\'\' or ZL.DK_C=:_c)
    and (:_d=\'\' or ZL.TYP=:_d)
    and (:_e=\'\' or ZL.KTL=:_e)
    and (:_f=\'\' or ZL.PROJEKTY=:_f)
',_ktm,_data,_dk_c,_ztp,_tktl,_projekty,{? _complex='T' || 'Z' || 'P' ?});

{? type_of(_tab)=type_of(~~) || exec('err_sql','#sql'); ZL.cntx_pop(); return(null()) ?};

:: Usunięcie zleceń z przewodnikami
_tab.prefix();
{? _tab.first()
|| {!
   |? {? exec('has_zgh','zl_common',exec('FindAndGet','#table',ZL,_tab.ZL_REF,,"ref()",null()))
      || _tab.del()
      || _tab.next()
      ?}
   !}
?};

_tab.index(_tab.ndx_tmp(,,'DATA',,,'SYMBOL',,));
_wer:=_tab.mk_sel('Wybierz zlecenie do powiązania'@,'P',,'mod_zl_wer',,5,,,'U');
_tab.win_fld(_wer,,'SYMBOL',,,20,,,'Symbol'@);
_tab.win_fld(_wer,,'OPIS',,,30,,,'Opis'@);
_tab.win_fld(_wer,,'DATA',,,10,,,'Termin real.'@);
_tab.win_fld(_wer,,'IL',,,15,4,,'Ilość'@);
_tab.win_fld(_wer,,'SERIA',,,15,4,,'Optymalna seria'@);
_tab.win_fld(_wer,,'KH',,,8,,,'Kontrahent'@);
_tab.win_fld(_wer,,'NRK',,,20,,,'Technologia'@);
_tab.win_fld(_wer,,'WER',,,6,,,'Wersja'@);
_tab.win_act(_wer,0,'Formuła','Wybierz'@@,,,$("
   _result:=params_get().result;
   {? ~ZL.seek(cur_tab(1,1).ZL_REF)
   || FUN.emsg('Zlecenie skasowane.'@)
   |? ZL.KH=null() | $ZL.KH='"+_kh_ref+"'
   || {? exec('zl_lock','zl_common',,,0)
      || exec('zl_unlock','zl_common');
         _result.selected:=1;
         _result.ZL:=ZL.ref();
         sel_exit()
      ?}
   || {? FUN.ask(
            'Czy pozycję zamówienia dla kontrahenta %1 dołączyć do zlecenia dla kontrahenta %2?'
            '\n'
            'UWAGA: w danych zlecenia nadal będzie figurował kontrahent %2.'@[\'"+_kh_skr+"\',ZL.KH().SKR]
         )
      || {? exec('zl_lock','zl_common',,,0)
         || exec('zl_unlock','zl_common');
            _result.selected:=1;
            _result.ZL:=ZL.ref();
            sel_exit()
         ?}
      ?}
   ?};
   1
"),,1,,,,'W');
_btn:=_tab.win_btn(_wer,'text=%1,panel=right,align=begin'['Wybierz'@],'menu:W');
_tab.btn_sopt(_wer,_btn,'default=1');
::_fb:="
::   _result:=params_get().result;
::   _result.selected:=1;
::   _result.ZL:=null();
::   sel_exit()
::";
::_tab.win_act(_wer,,'Formuła','Usuń powiązanie'@@,,,_fb,,,,,,'U');
::_tab.win_btn(_wer,'text=%1,panel=bottom,align=begin'['Usuń powiązanie'@],'menu:U');
_tab.win_act(_wer,,'Kolejność');
_tab.win_act(_wer,,'Formuła','Legenda'@@,,,"exec('legenda','color','#ZL#01')");
_fb:="
   ZL.cntx_psh();
   ZL.clear();
   {? ZL.seek(cur_tab(1,1).ZL_REF) || exec('zl_display','zl_head') ?};
   ZL.cntx_pop()
";
_tab.win_act(_wer,,'Wyświetl',,,,_fb);
_tab.win_sel(_wer);

_tab.win_fml(_wer,,'SYMBOL',,'ICON_BEFORE',"
   {? ~ZL.seek(cur_tab(1,1).ZL_REF)
   || 'xwin16.png:14'
   |? exec('zl_lock','zl_common',,,1)
   || exec('zl_unlock','zl_common');
      'xwin16.png:110'
   || 'xwin16.png:52'
   ?}
");

params_set('result',_result);
_tab.blank(1);
_tab.ZL_REF:=$_result.ZL;
{? ~_tab.find_rec() || _tab.first() ?};
{? _tab.select(,1,5)
|| {? _result.ZL<>null()
   || _env_gen.edit_ZTP:=0;
      _env_gen.edit_TKTL:=0;
      _env_gen.edit_COMPLEX:=0;
      ZLEC.btn_eopt('ZL_GEN','UNMERGE','state=normal')
   || _env_gen.edit_ZTP:=1;
      _env_gen.edit_TKTL:=1;
      _env_gen.edit_COMPLEX:=1;
      ZLEC.btn_eopt('ZL_GEN','UNMERGE','state=grayed')
   ?}
?};

ZL.cntx_pop();

_result


\zk_p_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: lista zleceń do wybranej pozycji zamówienia
::       wołane z okna ZK_P.ZAM
::  OLD: \zk_p_zl/produkt.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZK_P.M().RODZ='U'
|| FUN.info('Dla usług nie można wystawiać zleceń.'@); return()
?};

{? ~(ZK_P.M().R='W' | ZK_P.M().R='P')
|| FUN.info('Zlecenia można wystawiać tylko dla wyrobów lub półproduktów.'@); return()
?};

:: teraz przygotujemy listę typów
::_typydok:=exec('get','#params',500701,2,null());
::{? _typydok=''
::|| FUN.info(
::      'Brak zdefiniowanych typów dokumentów raportujących produkcję.\n'
::      'Należy uzupełnić parametr aplikacyjny %1.'@['500701']
::   );
::   return()
::?};

:: Sprawdzam czy typ zamówienia jest na liście typów z których można powoływać zlecenia
{? exec('chk_type','zl_gen')=0
|| return()
?};

exec('select_zlzam2src','zl_gen',$ZK_P.ref());
~~


\action_zkp_generate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Akcja 'Generuj' w oknie ZLZAM wołanym z pozycji zamówienia
::       Kontekst wywołania: rekord ZK_P
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
ZK_P.cntx_psh();
ZL.f_clear();
ZAKR.ZTP_WP:='';
VAR.A_ZLNAD:=null();
{? ZK_P.M().R='W' | M.R='P'
|| _args:=exec('mp_run_a','#b__box');
   _args.ACT_UID:='TTE_PZL_DZWE';
   _args.UIDREF:=ZK_P.N().uidref();
   _args.AKCJA:='GENERUJ';
   _args.PROC_START:='T';
   _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);

   exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZK_P',ZK_P.ref());
   exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZK_N',ZK_P.N);

   exec('mp_run','#b__box',_args)

|| FUN.info('Zlecenie można powołać tylko dla produktu.'@)
?};
ZK_P.cntx_pop();
~~


\pd_k_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: lista zleceń do wybranej pozycji koszyka planu dostaw
::----------------------------------------------------------------------------------------------------------------------
{? ~(PD_K.M().R='W' | PD_K.M().R='P')
|| FUN.info('Dla produktów nie będących wyrobem lub półproduktem nie można wystawiać zleceń.'@); return()
?};

exec('select_zlzam2src','zl_gen',$PD_K.ref());
~~


\chk_zl4zlim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.37]
:: OPIS: Sprawdza, czy są wygenerowane zlecenia do zamówień limitowych zlecenia
::   WE: _a - ZL.ref()
::   WY: 0-brak powiązań, 1-są powiązane zlecenia
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=0;
ZLIM.cntx_psh(); ZLZAM.cntx_psh();

exec('openmask','zl_common',_zl);
ZLIM.index('ZKK');
ZLIM.prefix(_zl,'T',0);
{? ZLIM.first()
|| {!
   |? _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit',,0,0);
      {? _zk_p<>null()
      || ZLZAM.index('ZMZL');
         ZLZAM.prefix($_zk_p);
         {? ZLZAM.first()
         || _result:=1
         ?}
      ?};
      _result=0 & ZLIM.next()
   !}
?};

ZLIM.cntx_pop(); ZLZAM.cntx_pop();
_result


\zpwyd_sm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Zwraca podstawę powołania zlecenia generowanego na podsatwie stanów magazynowych
::   WE: [_a] - INTEGER - typ zwracanej wartości: [0] - string, [1] - ref()
::   WY: Podstawa powołania zlecenia w postaci łańcucha znaków lub refa, w zależności od parametru _a
::----------------------------------------------------------------------------------------------------------------------
_type:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_str:='~stany magazynowe';
{? _type=0
|| _result:=_str
|| _result:=null();
   ZPWYD.cntx_psh();
   ZPWYD.index('ZPWYD_PW');
   ZPWYD.prefix(_str,);
   {? ZPWYD.first()
   || _result:=ZPWYD.ref()
   ?};
   ZPWYD.cntx_pop()
?};
_result


\zl_il_src
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Ilość zlecona do pozycji rekordu źródłowego
::   _a: $ref() rekordu źródłowego
::----------------------------------------------------------------------------------------------------------------------
_src:=_a;

_result:=0;

ZLZAM.cntx_psh();
ZLZAM.index('ZMZL');
ZLZAM.prefix(_a,);
{? ZLZAM.first()
|| {!
   |? _result+=ZLZAM.ILZL;
      ZLZAM.next()
   !}
?};
ZLZAM.cntx_pop();

_result


\action_psp_generuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Akcja 'Generuj zlecenie' z okna pozycji planu sprzedaży __plps
::----------------------------------------------------------------------------------------------------------------------
_zlnad:=VAR.A_ZLNAD;
{? __plps.REF<>''
|| PSP.cntx_psh();
   PSP.prefix();
   {? PSP.seek(__plps.REF)
   || {? PSP.M=null()
      || KOMM.info('Nie można powołać zlecenia do pozycji, która nie dotyczy konkretnego materiału.'@,VAR.GRUPA<>'T')
      ||
         {? VAR.GRUPA='T'
         || {? exec('psp_gen_valid','zl_gen')>0
            || _args:=exec('psp2args','zl_gen');
               params_exec('dodaj_zampoz','zl_gen',_args)
            ?}
         || {? PSP.PS().A='N'
            || KOMM.add('Plan: %1 nie jest aktywny'@[PS.S],3)
            |? PSP.PS().OK='N'
            || KOMM.add('Plan: %1 nie jest zaakceptowany'@[PS.S],3)
            |? PSP.IL=0
            || KOMM.add('Zerowa ilość na pozycji planu dla materiału %1'@[PSP.M().KTM],3)
            || ZLEC.ZTP:=null();
               _args:=exec('mp_run_a','#b__box');
               _args.ACT_UID:='TTE_PZL_DZPS';
               _args.UIDREF:=PSP.uidref();
               _args.AKCJA:='GENERUJ';
               _args.PROC_START:='T';
               _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
               exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'PSP',PSP.ref());
               exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL_NAD',VAR.A_ZLNAD);
               exec('mp_run','#b__box',_args);

::             Odtworzenie ilości wykonanej w __plps
               __plps.ILZL:=exec('FindAndGet','#table',PSP,__plps.REF,,"PSP.ILZL",0);
               __plps.put()
            ?}
         ?}
      ?}
   ?};
   PSP.cntx_pop()
|| {? VAR.GRUPA<>'T'
   || FUN.info('Nie można powołać zlecenia do pozycji agregującej.'@)
   ?}
?};
VAR.A_ZLNAD:=_zlnad;
~~


\action_psp_generuj_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Akcja 'Generuj zlecenie' z okna pozycji planu sprzedaży __plps
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_result:=exec('zl_gen_bg','zl_gen',2);
_result


\action_psp_generuj_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Akcja 'Generuj zlecenie' z okna pozycji planu sprzedaży __plps
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
exec('zl_gen_ag','zl_gen',2);

:: Odtworzenie ilości wykonanej w __plps (cały plan)
__plps.cntx_psh();
__plps.prefix();
{? __plps.first()
|| {!
   |? {? __plps.REF<>''
      || __plps.ILZL:=exec('FindAndGet','#table',PSP,__plps.REF,,"PSP.ILZL",0);
         __plps.put()
      ?};
      __plps.next()
   !}
?};
__plps.cntx_pop();
~~


\select_zlzam2src
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Wyświetla zlecenia powołane do źródłowego zapisu
::       (pozycja zamówienie, pozycja koszyka dostaw, pozycja planu sprzedaży, ...)
::   WE: _a - $ref() źródłowego zapisu
::----------------------------------------------------------------------------------------------------------------------
_src:=_a;

ZLZAM.cntx_psh();

_title:=
   {? ref_tab(_src)=ZK_P
   || 'Zlecenia do pozycji zamówienia'@
   |? ref_tab(_src)=PD_K
   || 'Zlecenia do pozycji koszyka planu dostaw'@
   |? ref_tab(_src)=PSP
   || 'Zlecenia do pozycji planu sprzedaży'@
   || 'Zlecenia do …'@
   ?};
_wer:=ZLZAM.mk_sel(_title,'P',,'zlzampoz',20,10,10,,'U');
ZLZAM.win_fld(_wer,VAR,'TYMCZAS',,,10,,,'Stan'@);
ZLZAM.win_fld(_wer,VAR,'STRING',,,15,,,'Symbol'@);
ZLZAM.win_fld(_wer,VAR,'STRING2',,,37,,,'Opis'@);
ZLZAM.win_fld(_wer,VAR,'DATE',,,-10,,,'Termin realizacji'@);
ZLZAM.win_fld(_wer,,'ZL','STAN',,-2,,,'Stan'@,,'Stan zlecenia: N-w przygotowaniu, Otwarte, Zamknięte'@);
ZLZAM.win_fld(_wer,VAR1,'STAT_PL',,,-2,,,'Plan'@,,'Status planowania zlecenia'@);
ZLZAM.win_fld(_wer,,'ILZL',,,10,2,,'Zlecono'@);
ZLZAM.win_fld(_wer,,'ZL','ILWYK',,-15,2,,'Wykonano (rejestracja)'@);
ZLZAM.win_fld(_wer,,'ZL','ILDOK',,-15,2,,'Wykonano (dokumenty)'@);
{? ref_tab(_src)=ZK_P
|| ZLZAM.win_act(_wer,0,'Formuła','Generuj'@@,,,"exec('action_zkp_generate','zl_gen')",,1,,,,'G');
   task_attach('TTE_PZL_DZWE');
   ZLZAM.win_btn(_wer,'text=%1,panel=right,align=begin'['Generuj'@],'menu:G');
   ZLZAM.win_act(_wer,1,'Formuła','Generuj'@@,,,"exec('action_zkp_generate','zl_gen')",,1,,,,'G');
   task_attach('TTE_PZL_DZWE')
?};
ZLZAM.win_act(_wer,,'Formuła','Limit&y'@@,,,"exec('kart_lim','zl_limit',1,ZL.ref())",,,,,,'Y');
task_attach('TTE_PZL_DLIM');
ZLZAM.win_act(_wer,,'Formuła','Nielimito&wane'@@,,,"exec('sur_nlim','zl_limit',1,ZL.ref(),,,1)",,,,,,'W');
task_attach('TTE_PZL_DLIM');
_formula:="
   _tab:=tab_tmp(1,'REF','INTEGER','#Zl.ref()');
   _tab.REF:=ZLZAM.ZL;
   _tab.add();
   exec('zl_simulation_core','px_logix',_tab);
   ~~
";
_formula_bg:="
   _sel:=ZLZAM.sel_aget();
   _tab:=tab_tmp(1,'REF','INTEGER','#ZL.ref()');
   {? _sel.first()
   || {!
      |? _tab.REF:=exec('FindAndGet','#table',ZLZAM,_sel.REF,,\"#ZL\",0);
         _tab.add();
         _sel.next()
      !}
   ?};
   exec('zl_simulation_core','px_logix',_tab);
   ZLZAM.sel_adel();
   0
";
ZLZAM.win_act(_wer,,'Formuła','Symuluj &zlecenie'@@,,,_formula,,,1,_formula_bg,,'Z');
ZLZAM.win_btn(_wer,'text=%1,panel=right,align=begin'['Symuluj &zlecenie'@],'menu:Z');
ZLZAM.win_act(_wer,,'Menu','P&odgląd planu'@,,,,,,,,,'O');
_btn:=ZLZAM.win_btn(_wer,'text=%1,panel=right,align=begin'['P&odgląd planu'@],'Menu');
_formula_bg:="
   _sel:=ZLZAM.sel_aget();
   _tab:=tab_tmp(1,'REF','INTEGER','#ZL.ref()');
   {? _sel.first()
   || {!
      |? _tab.REF:=exec('FindAndGet','#table',ZLZAM,_sel.REF,,\"#ZL\",0);
         _tab.add();
         _sel.next()
      !}
   ?};
   exec('select_any_core','px_plan',,ZL,_tab);
   ZLZAM.sel_adel();
   0
";
ZLZAM.win_act(_wer,,'Formuła','Plan strategiczny'@@,'#O',,"exec('select_zl','px_plan')",,,1,_formula_bg,,'P');
ZLZAM.btn_menu(_wer,_btn,'menu:OP');
task_attach('TPP_PPS_PPLA');
task_attach('TPP_PPS_DPLA');
_formula:="
   exec('zl_utilization','po_plan',0,ZLZAM.ZL)
";
ZLZAM.win_act(_wer,,'Formuła','Plan &operacyjny'@@,'#O',,_formula,,,,,,'O');
ZLZAM.btn_menu(_wer,_btn,'menu:OO');
task_attach('TPP_PPO_PPPL');
task_attach('TPP_PPO_DPPL');
_formula:="exec('todo_select','#b__box',exec('FindAndGet','#table',ZL,ZLZAM.ZL,,\"uidref()\",''))";
ZLZAM.win_act(_wer,,'Formuła','Zadan&ia'@@,,,_formula,,,,,,'I');
ZLZAM.win_act(_wer,,'Kolejność');
ZLZAM.win_act(_wer,,'Formuła','Legenda'@@,,,"exec('legenda','color','#ZL#02','#ZL#03','#ZL#05')",,,,,,'L');
ZLZAM.win_act(_wer,,'Rekord',,,,"
   {? ZLZAM.ZL=null()
   || VAR.A_ZLEC:=null();
      VAR.TYMCZAS:='<>';
      VAR.STRING:='<>';
      VAR.STRING2:='<>';
      VAR.DATE:=date(0,0,0)
   || VAR.A_ZLEC:=ZLZAM.ZL;
      VAR.TYMCZAS:='Zlecono'@;
      VAR.STRING:=ZLZAM.ZL().SYM;
      VAR.STRING2:=ZLZAM.ZL().OPIS;
      VAR.DATE:=ZL.DTR;
      {? _a
      || _grayed:=':';
         {? ZL.PLAN_PO='N'
         || _grayed:='O(O)'+_grayed
         ?};
         {? ZL.PLAN_PX='N'
         || {? ZLZAM.sel_size()=0 || _grayed:='O(P)'+_grayed ?}
         || {? ZLZAM.sel_size()=0 || _grayed:='Z'+_grayed ?}
         ?};
         ZLZAM.actions_grayed(cur_win(1,1),_grayed)
      ?}
   ?};
   ~~
",,0);
ZLZAM.win_act(_wer,,'Wyświetl',,,,"
   {? ZLZAM.ZL<>null()
   || exec('zl_display','zl_head')
   ?};
   ~~
");
_fi:="exec('icon_stan','zl_head')";
ZLZAM.win_fml(_wer,,'ZL','STAN','ICON_BEFORE',_fi);
_fi:="params_exec('icon_stat_pl','zl_head')";
ZLZAM.win_fml(_wer,VAR1,'STAT_PL',,'ICON_BEFORE',_fi);
_fi:="exec('icon_ktm','zl_head')";
ZLZAM.win_fml(_wer,VAR,'STRING2',,'ICON_BEFORE',_fi);
ZLZAM.win_sel(_wer);
_ztp_wp:=ZAKR.ZTP_WP;
ZAKR.ZTP_WP:='P';
ZLZAM.index('ZMZL');
ZLZAM.prefix(_src);
ZLZAM.first();
ZLZAM.select();
ZAKR.ZTP_WP:=_ztp_wp;
ZLZAM.cntx_pop();
~~


\psp_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Wyświetla zlecenia wygenerowane do pozycji planu sprzedaży
::----------------------------------------------------------------------------------------------------------------------
{? __plps.REF<>''
|| exec('select_zlzam2src','zl_gen',__plps.REF)
|| FUN.info('Nie można wyświetlać zleceń do pozycji agregującej.'@)
?};
~~


\zl_gen_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Wspólna formuła Grupa przed podczas grupowego generowania zleceń na podstawie zamówienia, planu dostaw,
::       planu sprzedaży
::  WE: _a - INTEGER - miejsce wywołania: 0 - zamówienia sprzedaży
::                                        1 - plan dostaw
::                                        2 - plan sprzedaży
::----------------------------------------------------------------------------------------------------------------------
_where:={? var_pres('_a')=type_of(0) || _a || return() ?};
_env_zlisty:=params_get().env_zlisty;
_tab:=_env_zlisty.TAB;
_tabsel:=_env_zlisty.TABSEL;
_tabref:=_env_zlisty.TABREF;

VAR.GRUPA:='T';
KOMM.init(,,'Generowanie zleceń'@);

_result:=1;

_env_zlisty.GRP:=0;

{? exec('sprdt','zl_head')
|| ZL.cntx_psh();
   ZK_P.cntx_psh();

:: Więcej niż jedna pozycja
   {? {? _where=1 || _tab.size>1 || _tab.sel_size()>1 ?}
   ||
::    Blokada grupowego powoływania jeśli któryś z ZK_P jest już w planie stategicznym lub operacyjnym
      _planned:=0;
      _blocked:=0;
      _tab.cntx_psh();
      {? _where=0
      || _sel:=_tab.sel_aget();
         {? _sel.first()
         ||
            {!
            |? {? _tab.seek(_sel.REF,)
               ||
                  {? ~exec('blk_lock','#table','ZK_P',8+_tab.REF,BIT.sqlint(_tab.REF))
                  || _blocked:=1
                  ?};
                  {? _tab.PLAN_OP='T' | _tab.PLAN_ST='T'
                  || _planned:=1
                  ?}
               ?};
               _sel.next() & _planned=0 & _blocked=0
            !}
         ?}
      |? _where=1
      || {? _tab.first()
         || {!
            |? {? PD_K.seek(_tab.SRC_REF,)
               ||
                  {? ~exec('blk_lock','#table','PD_K',8+_tab.SRC_REF)
                  || _blocked:=1
                  ?}
               ?};
               _tab.next() & _blocked=0
            !}
         ?}
      |? _where=2
      || _sel:=_tab.sel_aget();
         {? _sel.first()
         ||
            {!
            |? {? _tab.seek(_sel.REF,)
               ||
::                Blokowane wyłącznie rekordy, na podstawie których można generować zlecenia
                  {? _tab.REF<>'' & exec('psp_gen_valid','zl_gen',_tab.REF)>0
                  || {? ~exec('blk_lock','#table','PSP',8+_tab.REF,BIT.sqlint(_tab.REF))
                     || _blocked:=1
                     ?}
                  ?}
               ?};
               _sel.next() & _blocked=0
            !}
         ?}
      ?};
      {? _blocked>0
      || _msg:='Jedna z zaznaczonych pozycji jest zablokowana przez innego użytkownika.'
               '\nGrupowe powoływanie zleceń w takim przypadku niedozwolone.'@;
         FUN.emsg(_msg);
         _result:=0
      ?};
      {? _planned>0
      || _msg:='Jedna z zaznaczonych pozycji jest zaplanowana w Planie operacyjnym lub strategicznym.'
               '\nGrupowe powoływanie zleceń w takim przypadku niedozwolone.'@;
         FUN.emsg(_msg);
         _result:=0
      ?};
      _tab.cntx_pop();

      {? _planned=0 & _blocked=0
      || _env_gen:=exec('env_gen','zl_gen');
         _env_gen.edit_ZTP:={? _where=1 || 1 || {? VAR.A_ZLNAD=null() || 1 || 0 ?} ?};
         params_set('env_gen',_env_gen);

         ZLEC.ZTP:={? VAR.A_ZLNAD=null() || null() || VAR.A_ZLNAD().TYP ?};
         _param_nr:={? _where=2 || 500226 |? _where=1 || 500225 || 500224 ?};
         _param_val:=exec('get','#params',_param_nr,type_of(''));
         _czy_edit:=_param_val='';
         {? _czy_edit>0
         || ZLEC.GRP:=3
         || ZLEC.GRP:=exec('grp_param_convert','zl_gen',_param_val)
         ?};
         ZLEC.TKTL:=null();
::         ZLEC.ZTP:=null();
         ZLEC.COMPLEX:={? _where=1 || 'N' || 'T' ?};

::       Dodatkowe określenie typu/kategorii zlecenia wg danych z pozycji koszyka planu dostaw
         {? _where=1
         || _size:=_tabref.size();
            _tabref.cntx_psh();
            {? _tabref.first()
            || _ndx1:=_tabref.ndx_tmp(,,'ZTP',,);
               _ndx2:=_tabref.ndx_tmp(,,'RODZAJ',,);
               _tabref.index(_ndx1);
               _tabref.prefix(_tabref.ZTP);
               {? _tabref.size()=_size
               || ZLEC.ZTP:=exec('FindAndGet','#table',PD_K,_tabref.SRC_REF,,"PD_K.ZTP",null)
               ?};
               _tabref.index(_ndx2);
               _tabref.prefix(_tabref.RODZAJ);
               {? _tabref.size()=_size
               || ZLEC.COMPLEX:=_tabref.RODZAJ
               ?};
               _tabref.ndx_drop(_ndx1);
               _tabref.ndx_drop(_ndx2)
            ?};
            _tabref.cntx_pop()
         ?};

         ZTP.f_clear();
         _typy:=exec('typy_zlecen','zl_head','P');
         ZTP.f_set('TYP',,'ZTP.REFERENCE in (select :_a.REF from :_a)',_typy);
         obj_del(_typy);
         ZTP.win_dict('SLO');

::         ZLEC.win_edit('ZL_GEN_G');
         ZLEC.win_edit(exec('zl_gen_win_grp','zl_gen',_where));
         {? ~_czy_edit | ZLEC.edit()
         || _env_zlisty.GRP:=ZLEC.GRP
::            VAR.A_TPZL:=ZLEC.ZTP
         || _env_zlisty.GRP:=0;
            VAR.A_TPZL:=null()
         ?}
      ?};

      {? _env_zlisty.GRP<>0
      || {? _where<>1
         || _tabsel.erase();
            _tabref.erase()
         ?};
         _result:=1
      || VAR.GRUPA:='N';
         _result:=0
      ?}

:: Tylko jedna pozycja
   || VAR.GRUPA:='N';
      _result:=1
   ?};

   ZL.cntx_pop();
   ZK_P.cntx_pop()

|| _result:=0
?};
{? _result=0 & _where<>1 & _tab.sel_size()>1
||
:: Odblokowanie rekordów (np. po wycofaniu się z okna redakcji z parametrami generowania)
   _tab.cntx_psh();
   {? var_press('_sel')>100 || obj_del(_sel) ?};
   _sel:=_tab.sel_aget();
   {? _sel.first()
   || {!
      |?
         {? _tab.seek(_sel.REF,)
         || exec('blk_unlock','#table',{? _where=0 || 'ZK_P' || 'PSP' ?},8+_tab.REF,BIT.sqlint(_tab.REF))
         ?};
         _sel.next()

      !}
   ?};
   _tab.cntx_pop()
?};
_result


\zl_gen_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Wspólna formuła Grupa po podczas grupowego generowania zleceń na podstawie zamówienia, planu dostaw,
::       planu sprzedaży
::  WE: _a - INTEGER - miejsce wywołania: 0 - zamówienia sprzedaży
::                                        1 - plan dostaw
::                                        2 - plan sprzedaży
::----------------------------------------------------------------------------------------------------------------------
__WHERE:={? var_pres('_a')=type_of(0) || _a || return() ?};
{? VAR.GRUPA='N' || return() ?};

_env_zlisty:=params_get().env_zlisty;
_grp:=_env_zlisty.GRP;
_tab:=_env_zlisty.TAB;
_tabsel:=_env_zlisty.TABSEL;
_tabref:=_env_zlisty.TABREF;

params_set(params_get());

{? __WHERE=1
||
:: Jeżeli na pozycji koszyka przypisano, że ma zostać utworzone zlecenie złożone, to sprawdzane jest
:: czy wybarna technologia ma półfabrykaty
    _tabref.for_each("
      _tabref:=params_get().env_zlisty.TABREF;
      {? _tabref.RODZAJ='T'
      || {? TKTL.seek(_tabref.TKTL)
         || {? exec('czy_pf','tech_mater',TKTL.ref())
            || _tabref.RODZAJ:='T'
            || _tabref.RODZAJ:='N'
            ?}
         ||  _tabref.RODZAJ:='N'
         ?};
         _tabref.put()
      ?};
      ~~
   ");
   params_exec('grupuj_pdk','zl_gen',_grp)
?};

_tab.cntx_psh();

_tabsel.prefix();
{? _tabsel.size()>0
:: | _grp<>3
|| TKTL.cntx_psh();
   TKTL.clear();
   _wer:=_tabsel.mk_sel('Opcje generowania zleceń'@,,,'zlcopc'+$__WHERE,,,,,'U');
   _tabsel.win_fld(_wer,,'TOWAR',,,25,,1,'Kod produktu'@);
   _tabsel.win_fld(_wer,,'M_N',,,25,,1,'Nazwa produktu'@);
   _tabsel.win_fld(_wer,,'DATA',,,10,,1,'Data'@);
   _tabsel.win_fld(_wer,,'ILOSC',,,12,,1,'Ilość'@);
   {? __WHERE=0
   || _tabsel.win_fld(_wer,,'KH_N',,,30,,1,'Nazwa kontrahenta'@)
   ?};
   _tabsel.win_fld(_wer,ZLEC,'RED_KTL',,,15,,,'Technologia'@);
   _tabsel.win_fld(_wer,ZLEC,'RED_WER',,,6,,1,'Wersja'@);
::   _tabsel.win_fld(_wer,ZLEC,'RODZAJ',,,5,,,'Zlecenie złożone'@,,
::                                             'Zlecenie złożone - Z, zlecenie proste - P'@,2,,"'Z'","'P'"
::   );
   {? __WHERE=1
   || _tabsel.win_fld(_wer,ZLEC,'RODZAJ',,,5,,,'Zlecenie złożone'@,,
                                                'Zlecenie złożone - T, zlecenie proste - N'@,2,,"'T'","'N'"
      )
   ?};

   _fb:="
      _tabsel:=params_get().env_zlisty.TABSEL;
      _grp:=params_get().env_zlisty.GRP;
      VAR.A_T:=exec('FindAndGet','#table',M,_tabsel.REFT,,,null());
      {? _tabsel.TKTL<>''
      || {? TKTL.seek(_tabsel.TKTL)
         || ZLEC.TKTL:=TKTL.ref();
            ZLEC.RED_KTL:=TKTL.NRK;
            ZLEC.RED_WER:=TKTL.WER
         || ZLEC.TKTL:=null();
            ZLEC.RED_KTL:='';
            ZLEC.RED_WER:=''
         ?}
      || ZLEC.TKTL:=null();
         ZLEC.RED_KTL:='';
         ZLEC.RED_WER:=''
      ?};
      ZLEC.RODZAJ:=_tabsel.RODZAJ;
      {? __WHERE=0
      || _args:=params_get().args;
         _env_gen:=params_get().env_gen;
         ZK_P.cntx_psh();
         ZK_P.clear();
         {? ZK_P.seek(_tabsel.SRC_REF)
         || exec('zkp2args','zl_gen',_args)
         ?};
         ZK_P.cntx_pop();

         _env_gen.edit_TKTL:=(_args.TKTL=null());
         _env_gen.edit_COMPLEX:=(_args.COMPLEX='P')
      |? __WHERE=1
      || _grayed:='';
         {? _grp=4 & exec('czy_pf','tech_mater',exec('FindAndGet','#table',TKTL,_tabsel.TKTL,,,null()))=0
         || _grayed:='P'
         ?};
         _tabsel.actions_grayed(_tabsel.win_sel('?'),_grayed)
      |? __WHERE=2
      || _args:=params_get().args;
         _env_gen:=params_get().env_gen;
         PSP.cntx_psh();
         PSP.clear();
         {? PSP.seek(_tabsel.SRC_REF)
         || exec('psp2args','zl_gen',_args)
         ?};
         PSP.cntx_pop()
      ?};
      ~~
   ";
   _fa:="
      _tabsel:=params_get().env_zlisty.TABSEL;
      _tabsel.RODZAJ:=ZLEC.RODZAJ;
      {? ZLEC.TKTL<>null()
      || _tabsel.TKTL:=$ZLEC.TKTL
      || _tabsel.TKTL:='';
         _tabsel.RODZAJ:={? __WHERE=1 || 'N' || 'P' ?}
      ?};
      _tabsel.put();
      ~~
   ";
   _tabsel.win_act(_wer,,'Rekord',,,,_fb,_fa);
   {? __WHERE=1 | _grp<>4
   || _tabsel.win_act(_wer,,'Popraw',,,,,,1)
   ?};
   _formula:="
      _ok:=1;
      _env_zlisty:=params_get().env_zlisty;
      _tabsel:=_env_zlisty.TABSEL;
      _tabref:=_env_zlisty.TABREF;
      _grp:=_env_zlisty.GRP;
      {? _grp=4
      ||
::       Komunikat, gdy technologia ma zdefiniowane parametry i pozycje pochodzą z różnych indeksów
         _found:=0;
         _tabsel.cntx_psh();
         _tabsel.prefix();
         {? _tabsel.first()
         || _tabref.cntx_psh();
            _tabref.index(_env_zlisty.NDX_REF1);
            {!
            |?
               _is_param:=exec('is_param','tech_head',exec('FindAndGet','#table',TKTL,_tabsel.TKTL,,,null()));
               {? _is_param>0
               || _tabref.prefix(_tabsel.TKTL,_tabsel.M_ATR,);
                  {? _tabref.first()
                  || _ktm:=_tabref.TOWAR;
                     {!
                     |?
                        {? _ktm<>_tabref.TOWAR
                        || _found:=1
                        ?};
                        _tabref.next()
                     !}

                  ?}
               ?};
               _found=0 & _tabsel.next()
            !};
            _tabref.cntx_pop()
         ?};
         _tabsel.cntx_pop();
         {? _found>0
         || _txt:='Uwaga!\n'
                  'Przynajmniej jedno ze zleceń złożone jest z pozycji o różnych indeksach materiałowych '
                  'z przypisaną technologią parametryzowaną. Jako domyślne zostaną oznaczone wartości'
                  ' parametrów produktu głównego zlecenia.\n\n'
                  'Kontynuować?'@;
            _ok:=FUN.ask(_txt)
         ?}
      ?};
      {? _ok>0
      || sel_exit()
      ?}
   ";
   _tabsel.win_act(_wer,,'Formuła','Akceptuj'@@,,,_formula,,,,,,'A');
   _tabsel.win_act(_wer,,'Formuła','Szcz&egóły'@@,,,"
      _env_zlisty:=params_get().env_zlisty;
      _tabsel:=_env_zlisty.TABSEL;
      _tabref:=_env_zlisty.TABREF;
      _grp:=_env_zlisty.GRP;
      {? _grp=4
      || _tabref.index(_env_zlisty.NDX_REF1)
      || _tabref.index(_env_zlisty.NDX_REF)
      ?};
      {? _grp=1
      || _tabref.prefix(_tabsel.TOWAR,_tabsel.DK_C,_tabsel.DATA)
      |? _grp=2
      || _tabref.prefix(_tabsel.TOWAR,_tabsel.DK_C,)
      |? _grp=3
      || _tabref.prefix(_tabsel.TOWAR,_tabsel.DK_C,_tabsel.DATA,_tabsel.SRC_REF)
      |? _grp=4
      || _tabref.prefix(_tabsel.TKTL,_tabsel.M_ATR,)
      ?};
      _tabref.select();
      ~~
   ",,{? __WHERE<>1 & _grp=4 || 1 || 0 ?});
   _tabsel.win_btn(_wer,'text=%1'['Popraw'@],'menu:P');
   _tabsel.win_btn(_wer,'text=%1,panel=bottom,align=end'['Akceptuj'@],'menu:A');
   _tabsel.win_sel(_wer);

:: Ustalenie produktu głównego zleceń w przypadku grupowanie wg technologii
   {? _grp=4
   || _tabsel.cntx_psh();
      _tabsel.prefix();
      {? _tabsel.first()
      || _tabref.cntx_psh();
         _tabref.index(_env_zlisty.NDX_REF1);
::       Tabela, do której zbierane są łączne ilości materiału
         _tab_ktm:=tab_tmp(,'M','STRING[16]','M.ref()','IL','REAL','Ilość');
         {!
         |?
            _tab_ktm.erase();
            _tabref.prefix(_tabsel.TKTL,_tabsel.M_ATR,);
::          Zebranie ilości
            {? _tabref.first()
            || {!
               |?
                  {? _tab_ktm.find_key(_tabref.M)
                  || _tab_ktm.IL+=_tabref.IL;
                     _tab_ktm.put()
                  || _tab_ktm.M:=_tabref.M;
                     _tab_ktm.IL:=_tabref.IL;
                     _tab_ktm.add()
                  ?};
                  _tabref.next()
               !};
               _mref:=_tabsel.REFT;
               _ilmax:=0;
::             Określenie produktu o największej ilości
               {? _tab_ktm.first()
               || _mref:=_tab_ktm.M;
                  _ilmax:=_tab_ktm.IL;
                  {!
                  |?
                     {? _tab_ktm.IL>_ilmax
                     || _ilmax:=_tab_ktm.IL;
                        _mref:=_tab_ktm.M
                     ?};
                     _tab_ktm.next()
                  !}
               ?};
::             Jeżeli inny produkt niż aktualnie przypisany to podmieniam
               {? _mref<>_tabsel.REFT
               || _tabsel.REFT:=_mref;
                  _tabsel.TOWAR:=exec('FindAndGet','#table',M,_mref,,"KTM",'');
                  _tabsel.M_N:=exec('FindAndGet','#table',M,_mref,,"N",'');
                  _tabsel.put()
               ?}
            ?};
            _tabsel.next()
         !};
         _tabref.cntx_pop()
      ?};
      _tabsel.cntx_pop()
   ?};

   _args_gen:=exec('auto_args','zl_gen');
   _env_gen:=exec('env_gen','zl_gen');
   params_set('args',_args_gen,'env_gen',_env_gen,'env_zlisty',_env_zlisty);

   {!
   |?
      {? _tabsel.select()
      || _dalej:=1
      || _dalej:=-1
      ?};
      {? _dalej=0
      || FUN.error('Wszystkie pozycje muszą mieć przypisaną technologię.'@)
      |? _dalej=-1 & __WHERE<>1
      ||
::       Odblokowanie rekordów
         _tabref.cntx_psh();
         _tabref.prefix();
         {? _tabref.first()
         || {!
            |?
               {? __WHERE=0
               || exec('blk_unlock','#table','ZK_P',8+_tabref.ZAMPOZ,BIT.sqlint(_tabref.ZAMPOZ))
               |? __WHERE=2
               || exec('blk_unlock','#table','PSP',8+_tabref.ZAMPOZ,BIT.sqlint(_tabref.ZAMPOZ))
               ?};
               _tabref.next()
            !}
         ?};
         _tabref.cntx_pop()
      |? _dalej>0
      || {? _tabsel.first()
         ||
::          Czyszczenie parametrów
            _complex:=ZLEC.COMPLEX;
            _chk1:=ZLEC.CHK1;
            _chk2:=ZLEC.CHK2;
            ZLEC.CHK1:='';
            {? __WHERE<>1
            || ZLEC.COMPLEX:='N';
               ZLEC.CHK2:=''
            ?};
            _b_prel:=null();
            _zlnad:=VAR.A_ZLNAD;
            {? _grp=4
            || _tabref.index(_env_zlisty.NDX_REF1)
            || _tabref.index(_env_zlisty.NDX_REF)
            ?};
            {!
            |?
               {? _grp=1
               || _tabref.prefix(_tabsel.TOWAR,_tabsel.DK_C,_tabsel.DATA)
               |? _grp=2
               || _tabref.prefix(_tabsel.TOWAR,_tabsel.DK_C,)
               |? _grp=3
               || _tabref.prefix(_tabsel.TOWAR,_tabsel.DK_C,_tabsel.DATA,_tabsel.SRC_REF)
               |? _grp=4
               || _tabref.prefix(_tabsel.TKTL,_tabsel.M_ATR,)
               ?};
               _new_zl:=null();
               {? _tabref.first()
               || {? var_pres('_tab1')>100 || obj_del(_tab1) ?};
                  {? var_pres('_tab2')>100 || obj_del(_tab2) ?};
                  {? __WHERE=0
                  || _tab1:=ZK_P;
                     _tab2:=ZK_N
                  |? __WHERE=1
                  || _tab1:=PD_K;
                     _tab2:=~~
                  |? __WHERE=2
                  || _tab1:=PSP;
                     _tab2:=PS
                  ?};
                  {!
                  |?
                     {? __WHERE=0 | __WHERE=2
                     || _ref:=_tabref.ZAMPOZ
                     |? __WHERE=1
                     || _ref:=_tabref.SRC_REF
                     ?};
                     _tab1.cntx_psh();
                     _tab1.prefix();
                     {? _tab1.seek(_ref)
                     || {? __WHERE<>1
                        || _tab2.cntx_psh();
                           _tab2.prefix()
                        ?};
                        {? __WHERE=1 | __WHERE=0 & _tab2.seek(ZK_P.N) | __WHERE=2 & _tab2.seek(PSP.PS)
                        || {? __WHERE=1 | _tab2.r_lock(1,1,1)
                           || {? var_pres('_args')>100 || obj_del(_args) ?};
                              _args:=exec('mp_run_a','#b__box');
                              _act_uid:=uidref:=_zlozone:=_opis:='';
                              _ilosc:=0;
                              {? __WHERE=0
                              || _act_uid:='TTE_PZL_DZWE';
                                 _uidref:=ZK_N.uidref();
                                 _zlozone:={? _tabsel.RODZAJ='Z' || 'T' || 'P' ?};
                                 _ilosc:=_tabref.IL-_tabref.ILZL;
                                 _opis:='Generowane z zam.: '+ZK_N.SYM;
                                 _merge_size:=_tabref.size()
                              |? __WHERE=1
                              || _act_uid:='TTE_PZL_DZPD';
                                 _uidref:=PD_K.uidref();
                                 _zlozone:=_tabsel.RODZAJ;
                                 _ilosc:=PD_K.ILP;
                                 _opis:='Generowane z planu dostaw: '+PD_K.PD_N().SYM;
                                 _merge_size:=0
                              |? __WHERE=2
                              || _act_uid:='TTE_PZL_DZPS';
                                 _uidref:=PSP.uidref();
                                 _zlozone:={? _tabsel.RODZAJ='Z' || 'T' || 'P' ?};
                                 _ilosc:=_tabref.IL-_tabref.ILZL;
                                 _opis:='Generowane z planu sprzedaży: '+PSP.PS().S;
                                 _merge_size:=_tabref.size()
                              ?};
                              _args.ACT_UID:=_act_uid;
                              _args.UIDREF:=_uidref;
                              _args.AKCJA:={? _new_zl=null() || 'GENERUJ_W_GRUPIE' || 'POWIĄŻ_W_GRUPIE' ?};
                              _args.PROC_START:='T';

                              _args.CONTEXT:=obj_new('ZTP','ZL_NAD','ZLOZONE','TKTL','ILOSC','ZL','OPIS'
                                 ,'MERGE_SIZE','DK_C','KTM');
::                              _args.CONTEXT.ZTP:=VAR.A_TPZL;
                              _args.CONTEXT.ZTP:=null();
                              _args.CONTEXT.ZL_NAD:=_zlnad;
                              _args.CONTEXT.ZLOZONE:=_zlozone;
                              _args.CONTEXT.TKTL:=exec('FindAndGet','#table',TKTL,_tabsel.TKTL);
                              _args.CONTEXT.ILOSC:=_ilosc;
                              _args.CONTEXT.ZL:=_new_zl;
                              _args.CONTEXT.OPIS:=_opis;
                              _args.CONTEXT.MERGE_SIZE:=_merge_size;
                              {? _grp=4
                              || _args.CONTEXT.DK_C:=_tabsel.DK_C;
                                 _args.CONTEXT.KTM:=_tabsel.REFT
                              ?};
                              _args.GRUPA:='T';
                              _args.B_PREL:=_b_prel;
                              _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
                              {? __WHERE=0
                              || exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZK_P',ZK_P.ref());
                                 exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZK_N',ZK_N.ref())
                              |? __WHERE=1
                              || exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'PD_K',PD_K.ref())
                              |? __WHERE=2
                              || exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'PSP',PSP.ref())
                              ?};

                              exec('mp_run','#b__box',_args);
                              VAR.A_ZLNAD:=_zlnad;
                              _b_prel:=_args.B_PREL;
                              _new_zl:=_args.CONTEXT.ZL;
                              {? __WHERE<>1
                              || _tab2.r_unlock()
                              ?}

                           || {? __WHERE=0
                              || KOMM.add('Nie można generować zlecenia — zamówienie %1 redagowane '
                                          'przez innego użytkownika.'@[ZK_N.SYM])
                              |? __WHERE=2
                              || KOMM.add('Nie można generować zlecenia — plan sprzedaz %1 redagowany '
                                          'przez innego użytkownika.'@[PS.S])
                              ?}
                           ?}
                        ?};
                        {? __WHERE<>1
                        || _tab2.cntx_pop()
                        ?}
                     ?};
                     _tab1.cntx_pop();
                     {? __WHERE=0
                     || exec('blk_unlock','#table','ZK_P',8+_tabref.ZAMPOZ,BIT.sqlint(_tabref.ZAMPOZ));
                        _tab.index(_env_zlisty.NDX1);
                        _tab.prefix(_tabref.ZAMPOZ);
                        {? _tab.first() & __WHERE=0
                        || exec('zmp_reload','zl_gen')
                        ?}
                     |? __WHERE=2
                     || exec('blk_unlock','#table','PSP',8+_tabref.ZAMPOZ,BIT.sqlint(_tabref.ZAMPOZ))
                     ?};
                     _tabref.next()
                  !};
                  {? _new_zl<>null()
                  || exec('FindAndGet','#table',ZL,_new_zl,,"IL0:=IL; put()",~~);
::                   W przypadku grupowania wg technologii utworzenie listy produktów do zlecenia
                     {? _grp=4
                     || exec('zlzam2zlwyr','zl_wyr',_new_zl,
                           {? __WHERE=0 || 'Z' |? __WHERE=1 || 'D' |? __WHERE=2 || 'S' ?})
                     ?}
                  ?}
               ?};
               _tabsel.next()
            !};
::          Przywrócenie wartości parametrów
            ZLEC.COMPLEX:=_complex;
            ZLEC.CHK1:=_chk1;
            ZLEC.CHK2:=_chk2
         ?}
      ?};
      _dalej=0
   !};
   TKTL.cntx_pop()
|| {? __WHERE=2
   || KOMM.add('Na podstawie wybranych pozycji nie można powołać zleceń.'@)
   ?}
?};
_tab.cntx_pop();
VAR.GRUPA:='N';
KOMM.select();
~~


\psp2args
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Generuję/aktualizuję tablicę z argumentami dla funkcji generujących zlecenie na postawie
::       aktualnego rekordu pozycji planu sprzedaży PSP
::   WE: [_a] - wynik działania exec('auto_args','zl_gen')
::   WY: _args - argumenty dla funkcji generującej, wynik działania exec('auto_args','zl_gen')
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('auto_args','zl_gen')
?};

_args.GRUPA:=0;
_args.DIALOG:=1;
_args.SRC_REF:=$PSP.ref();
_args.M:=$PSP.M;
_args.KTM:=PSP.M().KTM;
_args.M_ATR:=M.M_ATR;
_args.SYMBOL:=PSP.PS().S;
_args.ILOSC:=PSP.IL-PSP.ILZL;
_args.IL_WYTW:=PSP.IL;
_args.IL_ZL:=PSP.ILZL;
_args.DK_C:='';
_args.JM_SYM:=M.J().KOD;
_args.KH_REF:=$PSP.KH;
_args.TKTL:=null();
{? ZLEC.GRP=4
|| _args.TKTL:=exec('wyb_ktl','zl_gen',0)
?};
_args.ZTP:=null();
{? PSP.PSOKR<>null()
|| _date:=PSP.PSOKR().DO-exec('get','#params',500103,1);
   {? _date<date() || _date:=date() ?}
|| _date:=date()
?};
_args.DTR:=_date;
_args.PL_DATA:=_date;
_args.MERGE:=1;
_args.COMPLEX:='P';
_args.GRP_KEY:='';
_args.OPIS:='Generowane z planu sprzedaży: '+PSP.PS().S;
_args


\dodaj_zampoz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Dodaje/aktualizuje rekord w tabeli "__ZAMPOZ", dodaje rekord do tabeli "__REF"
::       Kontekst wywołania - ustawiona zmienna _env_zlisty.GRP określa sposób kumulowania pozycji
::       1 - indeks+cecha+data, 2 - indeks+cecha, 3 - bez kumulowania, 4 - technologia + wzorzec atrybutów dostaw
::   WE: _a - wynik formuły exec('auto_args','zl_gen')
::       [_b] - INTEGER - miejsce wywołania: [0] - zamówienia sprzedaży
::                                            1 - plan dostaw (nieobsługiwany)
::                                            2 - plan sprzedaży
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_where:={? var_pres('_b')=type_of(0) || _b || 0 ?};

_env_zlisty:=params_get.env_zlisty;
_tabsel:=_env_zlisty.TABSEL;
_tabref:=_env_zlisty.TABREF;
_grp:=_env_zlisty.GRP;

_can_continue:=1;

{? _args.ZTP=null()
|| _args.ZTP:=VAR.A_TPZL
?};

M.cntx_psh();
M.clear();
{? _where=0
|| _il:=_args.IL_WYTW-_args.IL_ZL
|| _il:=_args.IL
?};

{? _il<0 || _il:=0 ?};

{? _il=0
|| KOMM.add('Nie można powołać zlecenia, do %1 została już zlecona cała ilość.'@[_args.SYMBOL],4);
   _can_continue:=0
?};

{? ~M.seek(_args.M)
|| KOMM.add('Brak materiału w słowniku.'@,4);
   _can_continue:=0
?};

{? _can_continue>0
|| _tabref.prefix();
   _tabref.ZAMPOZ:=_args.SRC_REF;
   {? _where=0
   || _tabref.POZ:=exec('FindAndGet','#table',ZK_P,_args.SRC_REF,,"POZ",0)
   ?};
   _tabref.M:=_args.M;
   _tabref.DK_C:=_args.DK_C;
   _tabref.DATA:=_args.DTR;
   _tabref.IL:=_args.IL_WYTW;
   _tabref.ILZL:=_args.IL_ZL;
   _tabref.SYM:=_args.SYMBOL;
   _tabref.MG:=exec('FindAndGet','#table',MG,_args.MG,,"SYM",'');
   _tabref.TKTL:=$_args.TKTL;
   _tabref.TOWAR:=exec('FindAndGet','#table',M,_args.M,,"KTM",'');
   _tabref.M_ATR:=exec('FindAndGet','#table',M,_args.M,,"$M_ATR",'');
   _tabref.add();

   {? _grp=4
   || _tabsel.index(_env_zlisty.NDX_SEL1)
   || _tabsel.index(_env_zlisty.NDX_SEL)
   ?};

:: Agregowanie wg materiału, cechy i daty
   {? _grp=1
   || _tabsel.prefix(_args.KTM,_args.DK_C,$_args.PROJEKTY,_args.DTR);
      {? _tabsel.first()
      || _tabsel.ILOSC+=_args.IL_WYTW-_args.IL_ZL;
         _tabsel.SYM:='';
         _tabsel.put()
      || params_exec('add_zampoz','zl_gen',_args)
      ?};
      _tabsel.prefix()

:: Agregowanie wg materiału i cechy
   |? _grp=2
   || _tabsel.prefix(_args.KTM,_args.DK_C,$_args.PROJEKTY);
      {? _tabsel.first()
      || _tabsel.ILOSC+=_args.IL_WYTW-_args.IL_ZL;
         {? _tabsel.DATA>_args.DTR
         || _tabsel.DATA:=_args.DTR
         ?};
         _tabsel.SYM:='';
         _tabsel.put()
      || params_exec('add_zampoz','zl_gen',_args)
      ?};
      _tabsel.prefix()
:: Agregowanie wg technologii domyślnej i wzorca atrybutów dostaw
   |? _grp=4
   || _tabsel.prefix($_args.TKTL,$_args.M_ATR,$_args.PROJEKTY,);
      {? _tabsel.first()
      || _tabsel.ILOSC+=_args.IL_WYTW-_args.IL_ZL;
         _tabsel.SYM:='';
         {? _tabsel.DATA>_args.DTR
         || _tabsel.DATA:=_args.DTR
         ?};
::       Jeżeli dwie pozycje o różnych cechach do czyszczę cechę
         {? _tabsel.DK_C<>'' & _tabsel.DK_C<>_args.DK_C
         || _tabsel.DK_C:=''
         ?};
         _tabsel.put()
      || params_exec('add_zampoz','zl_gen',_args)
      ?};
      _tabsel.prefix()
:: Bez agregacji
   |? _grp=3
   || params_exec('add_zampoz','zl_gen',_args)
   ?}
?};
M.cntx_pop();
~~


\add_zampoz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Dodaje do tabeli tymczasowej rekord z informacjami potrzebnymi do utworzenia zlecenia
::   WE: [_a] - _args - argumenty dla funkcji generującej, wynik działania exec('auto_args','zl_gen')
::       [_b] - INTEGER - miejsce wywołania: [0] - zamówienia sprzedaży
::                                            1 - plan dostaw
::                                            2 - plan sprzedaży
::   WY: 0/1
::  OLD: \add_zampoz/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('auto_args','zl_gen')
?};
_where:={? var_pres('_b')=type_of(0) || _b || 0 ?};

_tabsel:=params_get().env_zlisty.TABSEL;
_tabref:=params_get().env_zlisty.TABREF;

{? _where=1
|| _tabsel.blank();
   _tabsel.SRC_REF:=_tabref.SRC_REF;
   _tabsel.TOWAR:=_tabref.TOWAR;
   _tabsel.M_N:=_tabref.M_N;
   _tabsel.DATA:=_tabref.DATA;
   _tabsel.ILOSC:=_tabref.IL;
   _tabsel.KH_N:=_tabref.KH_N;
   _tabsel.TKTL:=_tabref.TKTL;
   _tabsel.RODZAJ:=_tabref.RODZAJ;
   _tabsel.DK_C:=_tabref.DK_C;
   _tabsel.REFT:=_tabref.M;
   _tabsel.ZTP:=_tabref.ZTP;
   _tabsel.M_ATR:=_tabref.M_ATR;
   _tabsel.add()
|| _tabsel.blank();
   _tabsel.TOWAR:=_args.KTM;
   _tabsel.M_N:=exec('FindAndGet','#table',M,_args.M,,"N",'');
   _tabsel.PROJEKTY:=$_args.PROJEKTY;
   _tabsel.DATA:=_args.DTR;
   _tabsel.ILOSC:=_args.IL_WYTW-_args.IL_ZL;
   _tabsel.SYM:=_args.SYMBOL;
   _tabsel.KH:=_args.KH_KOD;
   _tabsel.KH_N:=_args.KH_NAZ;
   _tabsel.KH_REF:=_args.KH_REF;
   _tabsel.REFT:=_args.M;
   _tabsel.DK_C:=_args.DK_C;
   _tabsel.SRC_REF:=_args.SRC_REF;
   {? _args.TKTL=null()
   || _tabsel.TKTL:=$exec('wyb_ktl','zl_gen',0)
   || _tabsel.TKTL:=$_args.TKTL
   ?};
   _tabsel.M_ATR:=$_args.M_ATR;
   TKTL.cntx_psh();
   TKTL.clear();
   {? VAR.A_ZLNAD<>null()
   || _tabsel.RODZAJ:='P'
   || {? TKTL.seek(_tabsel.TKTL)
      || {? VAR.GRUPA='T' & ZLEC.COMPLEX='T' | VAR.GRUPA<>'T'
         || {? exec('czy_pf','tech_mater',TKTL.ref())
            || _tabsel.RODZAJ:='Z'
            || _tabsel.RODZAJ:='P'
            ?}
         || _tabsel.RODZAJ:='P'
         ?}
      ?}
   ?};
   TKTL.cntx_pop();
   _tabsel.add()
?}


\tabsel_create
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2010]
:: OPIS: Generuje tabelę pomocniczą przy powoływaniu zleceń: "__ZAMPOZ"
::   WE: [_a] - INTEGER - miejsce wywołania: [0] - zamówienia sprzedaży
::                                            1 - plan dostaw
::                                            2 - plan sprzedaży
::  OLD: \gen_pom/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
_where:={? var_pres('_a')=type_of(0) || _a || 0 ?};
{? _where=1
|| _tab:=tab_tmp(5,
      'SRC_REF','INTEGER','#Ref PD_K',
      'TOWAR','STRING[50]','Kod produktu',
      'M_N','STRING[100]','Nazwa produktu',
      'KH_N','STRING[60]','Nazwa kontrahenta',
      'DATA','DATE','Data realizacji',
      'ILOSC','REAL','Ilość',
      'TKTL','STRING[16]','$Ref do technologii',
      'RODZAJ','STRING[1]','Rodzaj zlecenia - proste/złożone',
      'DK_C','STRING[16]','$Ref DK_C',
      'REFT','STRING[16]','$REF M',
      'ZTP','STRING[3]','Typ zlecenia',
      'M_ATR','STRING[16]','$M_ATR.ref()'
   )
|| _tab:=tab_tmp(4,
      'TOWAR','STRING[50]','Kod produktu',
      'DK_C','STRING[16]','Ref SQL cechy',
      'PROJEKTY','STRING[16]','$PROJEKTY.ref()',
      'DATA','DATE','Data',
      'ILOSC','REAL','Ilość',
      'STAN','STRING[1]','Stan',
      'SYM','STRING[20]','Symbol',
      'KH','STRING[10]','Kontrahent',
      'KH_N','STRING[60]','Kontrahent',
      'KH_REF','STRING[16]','$KH.ref()',
      'TKTL','STRING[16]','$TKTL.ref()',
      'REFT','STRING[16]','$M.ref()',
      'RODZAJ','STRING[1]','Rodzaj zlecenia',
      'SRC_REF','STRING[16]','$ZK_P.ref() źródłowej pozycji zamówienia',
      'M_N','STRING[100]','Nazwa produktu',
      'M_ATR','STRING[16]','$M_ATR.ref()'
   )
?};
_tab


\tabref_create
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.42]
:: OPIS: Generuje tabelę pomocniczą przy powoływaniu zleceń: "__REF"
::   WE: [_a] - INTEGER - miejsce wywołania: [0] - zamówienia sprzedaży
::                                            1 - plan dostaw (nieobsługiwany)
::                                            2 - plan sprzedaży
::----------------------------------------------------------------------------------------------------------------------
_where:={? var_pres('_a')=type_of(0) || _a || 0 ?};
{? _where=1
|| _tab:=tab_tmp(5,
      'SRC_REF','INTEGER','#Ref PD_K',
      'TOWAR','STRING[50]','Kod produktu',
      'M_N','STRING[100]','Nazwa produktu',
      'KH_N','STRING[60]','Nazwa kontrahenta',
      'DATA','DATE','Data realizacji',
      'IL','REAL','Ilość',
      'TKTL','STRING[16]','$Ref do technologii',
      'RODZAJ','STRING[1]','Rodzaj zlecenia - proste/złożone',
      'DK_C','STRING[16]','$Ref DK_C',
      'M','STRING[16]','$REF M',
      'ZTP','STRING[3]','Typ zlecenia',
      'M_ATR','STRING[16]','$M_ATR.ref()'
   )
|| _tab:=tab_tmp(4,
      'TOWAR','STRING[50]','Indeks materiałowy',
      'DK_C','STRING[16]','$DK_C.ref()',
      'DATA','DATE','Data',
      'ZAMPOZ','STRING[16]','$ZK_P.ref()',
      'POZ','INTEGER','Pozycja',
      'IL','REAL','Do wykonania',
      'ILZL','REAL','Zlecone',
      'SYM','STRING[20]','Symbol',
      'MG','STRING[8]','Magazyn',
      'TKTL','STRING[16]','$TKTL.ref()',
      'M','STRING[16]','$M.ref()',
      'M_ATR','STRING[16]','$M_ATR.ref()'
   )
?};

_title:={? _where=2 || 'Pozycje planu sprzedaży'@ |? _where=1 || 'Pozycje koszyka'@ || 'Pozycje zamówień'@ ?};
_wer:=_tab.mk_sel(_title,,,'reftabwer'+$_where,10,10,10,,'U');

{? _where=2
|| _tab.win_fld(_wer,,'TOWAR',,,,,,'Indeks materiałowy'@);
   _tab.win_fld(_wer,,'DATA',,,,,,'Data'@);
   _tab.win_fld(_wer,,'IL',,,12,,,'Do wykonania'@);
   _tab.win_fld(_wer,,'ILZL',,,12,,,'Zlecone'@)
|? _where=1
|| _tab.win_fld(_wer,,'TOWAR',,,25,,1,'Kod produktu'@);
   _tab.win_fld(_wer,,'M_N',,,25,,1,'Nazwa produktu'@);
   _tab.win_fld(_wer,,'DATA',,,10,,1,'Data'@);
   _tab.win_fld(_wer,,'IL',,,12,,1,'Ilość'@);
   _tab.win_fld(_wer,,'KH_N',,,30,,1,'Nazwa kontrahenta'@)
|| _tab.win_fld(_wer,,'SYM',,,,,,'Zamówienie'@);
   _tab.win_fld(_wer,,'POZ',,,7,,,'Pozycja'@);
   _tab.win_fld(_wer,,'DATA',,,,,,'Data'@);
   _tab.win_fld(_wer,,'IL',,,12,,,'Do wykonania'@);
   _tab.win_fld(_wer,,'MG',,,,,,'Na magazyn'@);
   _tab.win_fld(_wer,,'ILZL',,,12,,,'Zlecone'@)
?};

{? _where=0
|| _formula:="
      ZK_N.cntx_psh(); ZK_P.cntx_psh();
      ZK_P.prefix();
      {? ZK_P.seek(cur_tab(1,1).ZAMPOZ)
      || exec('wys_pozy','zamsiw_poz',1)
      ?};
      ZK_N.cntx_pop(); ZK_P.cntx_pop();
      ~~
   "
|| _formula:=""
?};
_tab.win_act(_wer,,'Wyświetl',,,,_formula);
_tab.win_sel(_wer);
_tab


\tabsum_create
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Tworzy tabelę "__ZMPSUM"
::   WY: _tab
::  OLD: \zmpsum_tab/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(1,
   'JM','STRING[10]','Jm',
   'IL_ZAM','REAL','Zamówione',
   'IL_POZ','REAL','Do realizacji',
   'IL_WYTW','REAL','Do wytworzenia',
   'IL_ZL','REAL','Zlecone'
);
_wer:=_tab.mk_sel('Sumy dla zaznaczonych pozycji zamówień'@,,,'zmpsumwer',,20);

_tab.win_fld(_wer,,'JM',,,,,,'jm'@);
_tab.win_fld(_wer,,'IL_ZAM',,,12,4,,'Zamówione'@);
_tab.win_fld(_wer,,'IL_POZ',,,12,4,,'Do realizacji'@);
_tab.win_fld(_wer,,'IL_WYTW',,,12,4,,'Do wytworzenia'@);
_tab.win_fld(_wer,,'IL_ZL',,,12,4,,'Zlecone'@);

_tab.win_sel(_wer);

_tab


\zmp_reload
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2010]
:: OPIS: Przeładowuje/usuwa aktualną zawartość rekordu tabeli tymczasowej "__ZMP"
::  OLD: \zmp_reload/zlec4.fml
::  OLD: \zmp_reload/zl_gen.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=params_get().env_zlisty.TAB;
ZLZAM.cntx_psh();
ZLZAM.index('ZMZL');
ZLZAM.prefix(_tab.REF);
_tab.IL_ZL:=0;
{? ZLZAM.first()
|| {!
   |? _tab.IL_ZL+=ZLZAM.ILZL;
      ZLZAM.next()
   !}
?};
ZLZAM.cntx_pop();
{? _tab.IL_ZAM<=_tab.IL_ZL
|| _tab.del()
|| _tab.put()
?};
~~


\zl_gen_win_grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Tworzy okno tymczasowe z parametrami generowania zleceń podczas grupowego generowania zleceń na podstawie
::       zamówienia, planu dostaw, planu sprzedaży
::   WE: [_a] - INTEGER - miejsce wywołania: [0] - zamówienia sprzedaży
::                                            1 - plan dostaw
::                                            2 - plan sprzedaży
::       [_b] - czy uruchamiane z poziomu ustawień i parametryzacji (ustawienie domyślnego sposobu grupowania): [0]/1
::   WY: utworzone okno
::----------------------------------------------------------------------------------------------------------------------
_where:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_is_param:={? var_pres('_b')=type_of(0) || _b || 0 ?};

_win:=ZLEC.mk_edit('Parametry generowania zleceń'@,0,'zlecqzl_gen_g'+$_where,1,1,'normal');
ZLEC.win_esep(_win,'Parametry'@);
_form:="ZLEC.win_efld('"+_win+"',ZLEC,'GRP',,,29,4,0,'Sposób grupowania pozycji',0,'','radio-buttons','left_label=1',"+
   {? _is_param>0
   || "'Decyzja podczas generowania'@,\"exec('num_0_','#blank')\","
   || ""
   ?}+
   {? _where<>2
   || "'Materiały i data ważności'@,\"exec('num_1_','#blank')\","
   || ""
   ?}+
   "'Materiały'@,\"exec('num_2_','#blank')\",'Technologia'@,\"exec('num_4_','#blank')\"
      ,'Osobno'@,\"exec('num_3_','#blank')\")
";
($_form)();
exec('ok_esc','#window',ZLEC,_win);

_win


\zkp2args
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Generuję/aktualizuję tablicę z argumentami dla funkcji generujących zlecenie na postawie
::       aktualnego rekordu pozycji zamówienia ZK_P
::   WE: [_a] - wynik działania exec('auto_args','zl_gen')
::   WY: _args - argumenty dla funkcji generującej, wynik działania exec('auto_args','zl_gen')
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('auto_args','zl_gen')
?};

_args.GRUPA:=0;
_args.DIALOG:=1;
_args.SRC_REF:=$ZK_P.ref();
_args.M:=$ZK_P.M;
_args.KTM:=ZK_P.M().KTM;
_args.M_ATR:=ZK_P.M().M_ATR;
_args.SYMBOL:=ZK_P.N().SYM;
_args.POZ:=ZK_P.POZ;
_args.IL_ZAM:=ZK_P.ILZ;
_args.IL_WYTW:=ZK_P.ILP-ZK_P.ILRB;
{? exec('get','#params',500223)='T' || _args.MG:=ZK_P.MG ?};
ZLZAM.index('ZMZL');
ZLZAM.prefix($ZK_P.ref());
_args.IL_ZL:=0;
{? ZLZAM.first()
|| {!
   |? _args.IL_ZL+=ZLZAM.ILZL;
      REZ.index('ZLZAM');
      REZ.prefix(ZLZAM.ref(),'B');
      {? REZ.first()
      || {!
         |? _args.IL_WYTW+=REZ.ILR;
            REZ.next()
         !}
      ?};
      ZLZAM.next()
   !}
?};
_args.IL_REZ:=ZK_P.ILRB;
_args.KH_REF:=$ZK_P.N().KH;
_args.KH_NAZ:=ZK_N.KH().NAZ;
_args.KH_KOD:=KH.KOD;
_args.DTR:=ZK_P.DT;
_args.PL_DATA:=ZK_P.PL_DATA;
_args.PL_TIME:=ZK_P.PL_TIME;
_args.PL_DIR:={? ZK_P.PL_DIR=0 || -10 || ZK_P.PL_DIR ?};
_args.PL_FORCE:=ZK_P.PL_FORCE;
_args.DK_C:=$ZK_P.DK_C;
_args.JM_SYM:=M.J().KOD;
_args.TKTL:=null();
{? ZLEC.GRP=4
|| _args.TKTL:=exec('wyb_ktl','zl_gen',0)
?};
_args.ZTP:=null();
::exec('FindAndGet','#table',ZL,VAR.A_ZLNAD,,"TYP",null());
_args.MERGE:=1;
::(VAR.A_ZLNAD=null());
_args.COMPLEX:='P';
::(VAR.A_ZLNAD=null());
_args.GRP_KEY:='';
_args.PROJEKTY:=ZK_P.PROJEKTY;
_args.OPIS:='Generowane z zam.: '+ZK_N.SYM;
_args.UWAGI:=ZK_P.U;
{? var_press('OPIS_DOD',_args)>100 || obj_del(_args.OPIS_DOD) ?};
_args.OPIS_DOD:='';

_par:=exec('get','#params',500222,2);
{? (_par+1='T' & +ZK_P.N().memo_txt(,1,'UW')>0 ) | (1+_par='T' & +ZK_P.N().OP>0)
|| _args.OPIS_DOD:=fopen(null,'uw',,,1)
?};

{? 1+_par='T' & +ZK_P.N().OP>0
|| {?  var_press('OPIS_DOD',_args)>100
   || _str:='Uwagi z nagłówka zamówienia:\n'+ZK_P.N().OP;
      _args.OPIS_DOD.fwrite(_str)
   || _args.OPIS_DOD:='Uwagi z nagłówka zamówienia:\n'+ZK_P.N().OP
   ?}
?};

{? _par+1='T' & +ZK_P.N().memo_txt(,1,'UW')>0
|| _str:='Dodatkowy opis z nagłówka zamówienia:';
   _args.OPIS_DOD.fwrite(_str);
   {? +ZK_P.N().memo_txt(,1,'UW')>255
   || _tmp:=ZK_P.N().memo_get('r','UW',0);
      {!
      |? (_txt:=fread(_tmp))<>'\n'
      |! _args.OPIS_DOD.fwrite(_txt)
      !}
   || _args.OPIS_DOD.fwrite(ZK_P.N().memo_txt(,1,'UW'))
   ?}
?};
_args


\grupuj_pdk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Grupuje pozycje koszyka planu dostaw według wskazanego sposobu kumulowania
::   WE: _a - NUMBER - sposób grupowania: 1 - indeks+cecha+data, 2 - indeks+cecha, 3 - bez kumulowania
::                                        4 - technologia+wzorzec cech
::----------------------------------------------------------------------------------------------------------------------
_env_zlisty:=params_get().env_zlisty;
_tabsel:=_env_zlisty.TABSEL;
_tabref:=_env_zlisty.TABREF;
_grp:={? var_press('_a')=type_of(0) || _a || 0 ?};

{? _grp<>0
||
   {? _tabref.first()
   || _tabsel.cntx_psh();
      {? _grp=4
      || _tabsel.index(_env_zlisty.NDX_SEL1)
      || _tabsel.index(_env_zlisty.NDX_SEL)
      ?};
      {!
      |?
::       Agregowanie wg materiału, cechy i daty
         {? _grp=1
         || _tabsel.prefix(_tabref.TOWAR,_tabref.DK_C,_tabref.DATA);
            {? _tabsel.first()
            || _tabsel.ILOSC+=_tabref.IL;
               _tabsel.put()
            || params_exec('add_zampoz','zl_gen',,1)
            ?};
            _tabsel.prefix()
::       Agregowanie wg materiału i cechy
         |? _grp=2
         || _tabsel.prefix(_tabref.TOWAR,_tabref.DK_C,);
            {? _tabsel.first()
            || _tabsel.ILOSC+=_tabref.IL;
               {? _tabsel.DATA>_tabref.DATA
               || _tabsel.DATA:=_tabref.DATA
               ?};
               _tabsel.put()
            || params_exec('add_zampoz','zl_gen',,1)
            ?};
            _tabsel.prefix()
::       Bez agregacji
         |? _grp=3
         || params_exec('add_zampoz','zl_gen',,1)
::       Agregowanie wg technologii i wzorca indeksu
         |? _grp=4
         || _tabsel.prefix(_tabref.TKTL,_tabref.M_ATR,);
            {? _tabsel.first()
            || _tabsel.ILOSC+=_tabref.IL;
               {? _tabsel.DATA>_tabref.DATA
               || _tabsel.DATA:=_tabref.DATA
               ?};
::             Jeżeli dwie pozycje o różnych cechach do czyszczę cechę
               {? _tabsel.DK_C<>'' & _tabsel.DK_C<>_tabref.DK_C
               || _tabsel.DK_C:=''
               ?};
               _tabsel.put()
            || params_exec('add_zampoz','zl_gen',,1)
            ?};
            _tabsel.prefix()
         ?};
         _tabref.next()
      !};
      _tabsel.cntx_pop()
   ?}
?};
~~


\env_zlisty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.42]
:: OPIS: Środowisko generatora z listy pozycji zamówień
::   WE: [_a] - INTEGER - miejsce wywołania: [0] - zamówienia sprzedaży
::                                            1 - plan dostaw
::                                            2 - plan sprzedaży
::       [_b] - tabela robocza - pozycje zamówień/planu (wymagane dla _a<>1)
::       [_c] - ZK_N.ref() (wymagane dla _a=0)

::----------------------------------------------------------------------------------------------------------------------
_where:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_tab:={? var_pres('_b')>100 || _b || ~~ ?};
_zk_n:={? var_pres('_c')=type_of(null()) || _c || null() ?};

_env_zlisty:=obj_new('GRP','TAB','NDX','NDX1','TABSUM','TABSEL','TABREF','ZK_N','NDX_SEL','NDX_SEL1'
   ,'NDX_REF','NDX_REF1');

:: Sposób grupowania (agregowania) pozycji
:: (1 - materiał i cecha; 2 - materiał, cecha i data; 3 - bez grupowania; 4 - technologia)
_env_zlisty.GRP:=0;

:: Główna tabela robocza - pozycje zamówień/planu
_env_zlisty.TAB:=_tab;
{? _where=0
||
:: Indeks: KOD, PL_DATA, PL_TIME
   _env_zlisty.NDX:=_tab.index('?');
:: Indeks: REF
   _env_zlisty.NDX1:=_tab.ndx_tmp(,1,'REF',,)
?};

:: Pomocnicze tabele robocze
:: - podsumowania
_env_zlisty.TABSUM:={? _where=0 || exec('tabsum_create','zl_gen') || ~~ ?};
:: - zaznaczone pozycje (ew. pogrupowane)
_env_zlisty.TABSEL:=exec('tabsel_create','zl_gen',_where);
{? _where=1
|| _env_zlisty.NDX_SEL:=_env_zlisty.TABSEL.ndx_tmp(,,'TOWAR',,,'DK_C',,,'DATA',,);
   _env_zlisty.NDX_SEL1:=_env_zlisty.TABSEL.ndx_tmp(,,'TKTL',,,'M_ATR',,)
|| _env_zlisty.NDX_SEL:=_env_zlisty.TABSEL.index('?');
   _env_zlisty.NDX_SEL1:=_env_zlisty.TABSEL.ndx_tmp(,1,'TKTL',,,'M_ATR',,,'PROJEKTY',,,'DATA',,)
?};
:: - szczegóły zaznaczonych pozycji
_env_zlisty.TABREF:=exec('tabref_create','zl_gen',_where);
{? _where=1
|| _env_zlisty.NDX_REF:=_env_zlisty.TABREF.ndx_tmp(,,'TOWAR',,,'DK_C',,,'DATA',,,'SRC_REF',,);
   _env_zlisty.NDX_REF1:=_env_zlisty.TABREF.ndx_tmp(,,'TKTL',,,'M_ATR',,,'DATA',,1)
|| _env_zlisty.NDX_REF:=_env_zlisty.TABREF.index('?');
   _env_zlisty.NDX_REF1:=_env_zlisty.TABREF.ndx_tmp(,1,'TKTL',,,'M_ATR',,,'DATA',,)
?};

{? _where=1
|| _env_zlisty.TAB:=_env_zlisty.TABREF
?};

:: Pomocniczo ZK_N.ref()
_env_zlisty.ZK_N:={? _where=0 || _zk_n || null() ?};

_env_zlisty


\psp_gen_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Sprawdza, czy na podsatawie podanej pozycji planu sprzedaży można generować zlecenie
::       (formuła wywoływana podczas grupowego generowania zleceń)
::   WE: [_a] - $PSP.ref() - jak nie podany to aktualny rekord
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_pres('_a')=type_of('') || _a || $PSP.ref() ?};
_res:=0;
{? _ref<>''
|| PSP.cntx_psh();
   PS.cntx_psh();
   PSP.prefix();
   {? PSP.seek(_ref,ref_name(_ref),1)
   || {? ~(PSP.PS().A='N' | PSP.PS().OK='N' | PSP.IL=0)
      || _res:=1
      ?}
   ?};
   PSP.cntx_pop();
   PS.cntx_pop()
?};
_res


\chk_type
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy typ zamówienia i parametryzacja umożliwiają generowanie zleceń produkcyjnych
::       Kontekst działania - rekord ZK_N
::   WE:
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=1;

TYPYZAM.cntx_psh();
{? ZK_N.T().R='Z'
||
:: Zamówienia sprzedaży
   _typyzam:=exec('get','#params',500213);
   {? _typyzam=''
   ||
      FUN.info(
         'Brak zdefiniowanych typów zamówień sprzedaży, z których można powoływać zlecenia.\n'
         'Należy uzupełnić parametr aplikacyjny %1.'@['500213']
      );
      _result:=0
   ||
::    Sprawdzam czy typ zamówienia znajduje się na liście
      {? _typyzam*(ZK_N.T().T+' ')=0
      || FUN.info(
            'Zamówienie nie znajduje się na liście typów zamówień sprzedaży, z których można powoływać zlecenia.\n'
            'Należy uzupełnić parametr aplikacyjny %1.'@['500213']
         );
         _result:=0
      ?}
   ?}
|? ZK_N.T().R='W'
||
:: Zamówienia wewnętrzne
   _typyzam:=exec('get','#params',500215);
   {? _typyzam=''
   ||
      FUN.info(
         'Brak zdefiniowanych typów zamówień wewnętrznych, z których można powoływać zlecenia.\n'
         'Należy uzupełnić parametr aplikacyjny %1.'@['500215']
      );
      _result:=0
   ||
::    Sprawdzam czy typ zamówienia znajduje się na liście
      {? _typyzam*(ZK_N.T().T+' ')=0
      || FUN.info(
            'Zamówienie nie znajduje się na liście typów zamówień wewnętrznych, z których można powoływać zlecenia.\n'
            'Należy uzupełnić parametr aplikacyjny %1.'@['500215']
         );
         _result:=0
      ?}
   ?}
?};
TYPYZAM.cntx_pop();
_result


\grp_param_convert
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Konwertuje wartość parametrów 500224-500226 (domyślny sposób grupowania zleceń)
::       z typu STRING na NUMBER lub na odwrót.
::   WE: _a - wartość parametru w postaci STRING lub NUMBER
::   WY: przekonwertowana wartość parametru (STRING lub NUMBER)
::----------------------------------------------------------------------------------------------------------------------
_val:=_a;
_kierunek:={? var_pres('_val')=type_of(0) || 0 |? var_pres('_val')=type_of('') || 1 || return(~~) ?};
:: Domyślne wartości
_res:={? _kierunek=0 || '' || 3 ?};
{? _kierunek=0
||
:: NUMBER->STRING
   {? _val=0
   || _res:=''
   |? _val=1
   || _res:='D'
   |? _val=2
   || _res:='M'
   |? _val=3
   || _res:='O'
   |? _val=4
   || _res:='T'
   ?}
||
:: STRING->NUMBER
   {? _val=''
   || _res:=0
   |? _val='D'
   || _res:=1
   |? _val='M'
   || _res:=2
   |? _val='O'
   || _res:=3
   |? _val='T'
   || _res:=4
   ?}
?};
_res

:Sign Version 2.0 jowisz:1045 2023/10/25 11:20:42 8fd608134c3a2b4c3633a9288196b3f11b50929afde74fd10749607ad23d6ca16212726a6eb6fe7c78db61c4d883ae7fdedfcc584d194074d408a48ecdd295ae4f65fdcdbf47fdc8b7474fc801ff2ed1e8eda1b0f91c42ce3e99d90b4d16bda7b7da4009713233c5d6ad614e09c1ac6864f25662fde9276311773c0ea9b34c8c
