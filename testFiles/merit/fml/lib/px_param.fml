:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku:  px_param.fml [12.10]
:: Utworzony: 2011-06-13
:: Autor: WH
::======================================================================================================================
:: Zawartość: Zbiór funkcji do parametryzacji planu strategicznego
::======================================================================================================================


\il_wym
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca maksymalna liczbe wymiarow. Zwykle ta informacja jest pobierana z PX_KONT,
::       ale zdarzaja sie sytuacje kiedy nie mozna pobrac ilosci wymiarow z kontenera a trzeba znac ile ich maksymalnie
::       moze byc
::----------------------------------------------------------------------------------------------------------------------
5


\create_kon_tree
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Tworzy drzewo z zasobami do zaimportowania do tabeli PX_KONT
::----------------------------------------------------------------------------------------------------------------------
VAR_DEL.delete('KONT_TREE','WERK_TREE');
KONT_TREE:=tab_tmp(4,   'PARENT','TREE_REF','Z',
                        'TYP','STRING[2]','Typ'@,
                        'BRANCH','STRING[1]','Czy jest gałęzią',
                        'SYMBOL','STRING[40]','Symbol'@,
                        'WYD','STRING[20]','Wydział'@,
                        'REF','STRING[16]','REF',
                        'NAZWA','STRING[50]','Nazwa'@,
                        'KAL_NAZW','STRING[20]','Kalendarz'@,
                        'KAL_REF','STRING[16]','Ref kalendarza',
                        'PL_RES','STRING[16]','Ref zasobu planistycznego'
                 );

KONT_TREE.fld_attr(,2);

WERK_TREE:=KONT_TREE.mk_sel('Dostępne elementy możliwe do importu (za pomocą drag&drop)'@,'P',,'#kont_tree',,,,1);
KONT_TREE.win_sel(WERK_TREE);
KONT_TREE.win_fld(WERK_TREE,,'SYMBOL',,,30);
KONT_TREE.win_fld(WERK_TREE,,'NAZWA',,,30);
KONT_TREE.win_fld(WERK_TREE,,'WYD',,,10);

_fml:="exec('pxkont_create','px_param',KONT_TREE.ref())";
_fml_gr1:="
   _sel:=KONT_TREE.sel_aget();
   sel_nchk();

   exec('pxkont_dnd_drop','px_kont',_sel);
   grp_disp(PX_KONT,'WER');
   grp_disp(KONT_TREE,WERK_TREE);
   0
";
_fml_gr2:="

   ~~
";
KONT_TREE.win_act(WERK_TREE,,'Formuła','Utwórz zasób'@,,,_fml,,1,1,_fml_gr1,_fml_gr2,'U');

KONT_TREE.win_act(WERK_TREE,,'Formuła','Miesiąc pracy'@,,,"exec('start_res','kal_mies',KONT_TREE.TYP,KONT_TREE.REF)");
KONT_TREE.win_act(WERK_TREE,,'Formuła','Zwiń/roz&wiń'@@,,'Zwiń/rozwiń wszystkie rekordy'@,
   "exec('zwrw_all','#tree',KONT_TREE,'PARENT')",,,,,,'W');
KONT_TREE.win_act(WERK_TREE,,'Rekord',,,,"
   {? KONT_TREE.BRANCH='T'
   || KONT_TREE.actions_grayed(WERK_TREE,'M')
   || KONT_TREE.actions_grayed(WERK_TREE,'')
   ?}
");
KONT_TREE.win_fml(WERK_TREE,,'SYMBOL',,'ICON_BEFORE', "
   _nr:=1;
   {? KONT_TREE.BRANCH='T'
   || {? KONT_TREE.tr_state()=0
      || _nr:=74
      |? KONT_TREE.tr_state()=1
      || _nr:=75
      ?}
   || _nr:=exec('ikona_res','po_plan',KONT_TREE.TYP)
   ?};
   'xwin16.png:'+$_nr
");

exec('fill_kon_tree','px_param');
~~


\fill_kon_tree
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Dodaje do tabeli KONT_TREE mozliwe elementy ktore sie moga stac kontenerami
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('KONT_TREE')
||
:: dodaje do drzewa linie produkcyjne
   exec('tree_add_lprod','px_param');
:: dodaje do drzewa stanowiska produkcyjne
   exec('tree_add_place','px_param');
:: dodaje do drzewa gniazda produkcyjne
   exec('tree_add_socket','px_param');
:: dodaje do drzewa brygady robocze
   exec('tree_add_bryg','px_param');
:: dodaje do drzewa pracownikow
   exec('tree_add_prac','px_param');
:: dodaje do drzewa wydzialy
   exec('tree_add_wydz','px_param')
?};
KONT_TREE.tr_set(0,,,0);
KONT_TREE.first();
~~


\tree_add_branch
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Dodaje do tabeli KONT_TREE rekord bedacy galezia danego typu
::   WE: _a: typ galezi
::   WY: KONT_TREE.ref() - ref dodanej galezi
::----------------------------------------------------------------------------------------------------------------------
KONT_TREE.clear();
_typ:=_a;
_nazwa:='';
_wyn:=null();
{? _typ='L'
|| _nazwa:='Linie produkcyjne'@
|? _typ='S'
|| _nazwa:='Stanowiska produkcyjne'@
|? _typ='G'
|| _nazwa:='Gniazda produkcyjne'@
|? _typ='B'
|| _nazwa:='Brygady robocze'@
|? _typ='P'
|| _nazwa:='Pracownicy'@
|? _typ='W'
|| _nazwa:='Wydziały'@
?};
KONT_TREE.blank();
KONT_TREE.TYP:=_typ;
KONT_TREE.BRANCH:='T';
KONT_TREE.SYMBOL:=_nazwa;
{? KONT_TREE.add()
|| _wyn:=KONT_TREE.ref()
?};
_wyn


\tree_add
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Dodaje rekord do tabeli KONT_TREE
::   WE: _a: KONT_TREE.TYP
::       _b: KONT_TREE.REF
::       _c: KONT_TREE.PARENT
::       _d: KONT_TREE.SYM
::       _e: KONT_TREE.NAZ
::       _f: KONT_TREE.KAL_NAZW
::       _g: KONT_TREE.KAL_REF
::       _h: KONT_TREE.WYD
::       _i: KONT_TREE.PLRES
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
{? var_pres('KONT_TREE')
|| KONT_TREE.clear();
   KONT_TREE.blank();
   KONT_TREE.TYP:=_a;
   KONT_TREE.REF:=_b;
   KONT_TREE.PARENT:=_c;
   KONT_TREE.SYMBOL:=_d;
   KONT_TREE.NAZWA:=_e;
   KONT_TREE.KAL_NAZW:=_f;
   KONT_TREE.KAL_REF:=_g;
   KONT_TREE.WYD:=_h;
   KONT_TREE.PL_RES:=_i;
   _wyn:=KONT_TREE.add()
?};
_wyn


\tree_add_lprod
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Dodaje do tabeli KONT_TREE linie produkcyjne
::----------------------------------------------------------------------------------------------------------------------
_mainver:=exec('get_mainversion','px_ver');
LPROD.cntx_psh();
PX_KONT.cntx_psh();
PX_KONT.index('LPROD');
LPROD.index('KOD');
_added:=0;
LPROD.clear();
{? LPROD.first()
|| _parent:=exec('tree_add_branch','px_param','L');
   {!
   |? PX_KONT.prefix(_mainver,LPROD.ref());
::    dodaje tylko jesli w tabeli PX_KONT nie ma takiego
      {? PX_KONT.first()=0
      || _kal:=exec('get_kal_nazwa','po_plan',$LPROD.ref(),'L');
         _plres:=exec('get_plres','po_plan','L',LPROD.ref());
         _ok:=exec('tree_add','px_param', 'L',
                                          $LPROD.ref(),
                                          _parent,
                                          LPROD.KOD,
                                          LPROD.OPIS,
                                          _kal[1],
                                          _kal[2],
                                          LPROD.WYD().KOD,
                                          $_plres);
         &_kal;
         {? _ok
         || _added+=1
         ?}
      ?};
      LPROD.next()
   !};
:: jesli nic nie dodalem to usuwam rodzica
   {? _added=0
   || KONT_TREE.del()
   ?}
?};
LPROD.cntx_pop();
PX_KONT.cntx_pop();
~~


\tree_add_place
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Dodaje do tabeli KONT_TREE stanowiska produkcyjne
::----------------------------------------------------------------------------------------------------------------------
_mainver:=exec('get_mainversion','px_ver');
TWRKPLC.cntx_psh();
PX_KONT.cntx_psh();
PX_KONT.index('TWRKPLC');
TWRKPLC.index('KOD');
TWRKPLC.clear();
_added:=0;
{? TWRKPLC.first()
|| _parent:=exec('tree_add_branch','px_param','S');
   {!
   |? PX_KONT.prefix(_mainver,TWRKPLC.ref());
::    dodaje tylko jesli w tabeli PX_KONT nie ma takiego
      {? PX_KONT.first()=0
      || _kal:=exec('get_kal_nazwa','po_plan',$TWRKPLC.ref(),'S');
         _plres:=exec('get_plres','po_plan','S',TWRKPLC.ref());
         _ok:=exec('tree_add','px_param', 'S',
                                          $TWRKPLC.ref(),
                                          _parent,
                                          TWRKPLC.KOD,
                                          TWRKPLC.NA,
                                          _kal[1],
                                          _kal[2],
                                          TWRKPLC.WYD().KOD,
                                          $_plres);
         &_kal;
         {? _ok
         || _added+=1
         ?}
      ?};
      TWRKPLC.next()
   !};
:: jesli nic nie dodalem to usuwam rodzica
   {? _added=0
   || KONT_TREE.del()
   ?}
?};
TWRKPLC.cntx_pop();
PX_KONT.cntx_pop();
~~


\tree_add_socket
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Dodaje do tabeli KONT_TREE gniazda produkcyjne
::----------------------------------------------------------------------------------------------------------------------
_mainver:=exec('get_mainversion','px_ver');
TWRKZBR.cntx_psh();
PX_KONT.cntx_psh();
PX_KONT.index('TWRKZBR');
TWRKZBR.index('WYD');
TWRKZBR.clear();
_added:=0;
{? TWRKZBR.first()
|| _parent:=exec('tree_add_branch','px_param','G');
   {!
   |? PX_KONT.prefix(_mainver,TWRKZBR.ref());
::    dodaje tylko jesli w tabeli PX_KONT nie ma takiego
      {? PX_KONT.first()=0
      || _kal:=exec('get_kal_nazwa','po_plan',$TWRKZBR.ref(),'G');
         _plres:=exec('get_plres','po_plan','G',TWRKZBR.ref());
         _ok:=exec('tree_add','px_param', 'G',
                                          $TWRKZBR.ref(),
                                          _parent,
                                          TWRKZBR.SYMBOL,
                                          TWRKZBR.NAZWA,
                                          _kal[1],
                                          _kal[2],
                                          TWRKZBR.WYD().KOD,
                                          $_plres);
         &_kal;
         {? _ok
         || _added+=1
         ?}
      ?};
      TWRKZBR.next()
   !};
:: jesli nic nie dodalem to usuwam rodzica
   {? _added=0
   || KONT_TREE.del()
   ?}
?};
TWRKZBR.cntx_pop();
PX_KONT.cntx_pop();
~~


\tree_add_bryg
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Dodaje do tabeli KONT_TREE brygady robocze
::----------------------------------------------------------------------------------------------------------------------
_mainver:=exec('get_mainversion','px_ver');
ZLBR.cntx_psh();
PX_KONT.cntx_psh();
PX_KONT.index('ZLBR');
ZLBR.index('KOD');
ZLBR.clear();
_added:=0;
{? ZLBR.first()
|| _parent:=exec('tree_add_branch','px_param','B');
   {!
   |? PX_KONT.prefix(_mainver,ZLBR.ref());
::    dodaje tylko jesli w tabeli PX_KONT nie ma takiego
      {? PX_KONT.first()=0
      || _kal:=exec('get_kal_nazwa','po_plan',$ZLBR.ref(),'B');
         _plres:=exec('get_plres','po_plan','B',ZLBR.ref());
         _ok:=exec('tree_add','px_param', 'B',
                                          $ZLBR.ref(),
                                          _parent,
                                          ZLBR.KOD,
                                          ZLBR.NAZ,
                                          _kal[1],
                                          _kal[2],
                                          '',
                                          $_plres);
         &_kal;
         {? _ok
         || _added+=1
         ?}
      ?};
      ZLBR.next()
   !};
:: jesli nic nie dodalem to usuwam rodzica
   {? _added=0
   || KONT_TREE.del()
   ?}
?};
ZLBR.cntx_pop();
PX_KONT.cntx_pop();
~~


\tree_add_prac
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Dodaje do tabeli KONT_TREE pracownikow
::----------------------------------------------------------------------------------------------------------------------
_mainver:=exec('get_mainversion','px_ver');
P.cntx_psh();
exec('__F_ZATR','object');
P.index('PRACONAZ');
P.prefix(exec('ref_firma','#firma'),__F_ZATR.P);
PX_KONT.cntx_psh();
PX_KONT.index('P');
_added:=0;
{? P.first()
|| _parent:=exec('tree_add_branch','px_param','P');
   {!
   |? PX_KONT.prefix(_mainver,P.ref());
::    dodaje tylko jesli w tabeli PX_KONT nie ma takiego
      {? PX_KONT.first()=0
      || {? P.ZA='T'
         || _kal:=exec('get_kal_nazwa','po_plan',$P.ref(),'P');
            _plres:=exec('get_plres','po_plan','P',P.ref());
            _ok:=exec('tree_add','px_param', 'P',
                                             $P.ref(),
                                             _parent,
                                             P.OSOBA().NAZWISKO+' '+P.OSOBA().PIERWSZE,
                                             P.ST().ST,
                                             _kal[1],
                                             _kal[2],
                                             P.WYDZIAL().SYMBOL,
                                             $_plres);
            &_kal;
            {? _ok
            || _added+=1
            ?}
         ?}
      ?};
      P.next()
   !};
:: jesli nic nie dodalem to usuwam rodzica
   {? _added=0
   || KONT_TREE.del()
   ?}
?};
P.cntx_pop();
PX_KONT.cntx_pop();
~~


\tree_add_wydz
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Dodaje do tabeli KONT_TREE wydzialy
::----------------------------------------------------------------------------------------------------------------------
_mainver:=exec('get_mainversion','px_ver');
UD_SKL.cntx_psh();
UD_TYP.cntx_psh();
PX_KONT.cntx_psh();
PX_KONT.index('WYD');
UD_SKL.index('AKTYWNY');
UD_TYP.index('SYMBOL');
UD_TYP.prefix('PODZORG');

_added:=0;
{? UD_TYP.first()
|| UD_SKL.prefix(UD_TYP.ref(),'T');
   {? UD_SKL.first()
   || _parent:=exec('tree_add_branch','px_param','W');
      {!
      |? PX_KONT.prefix(_mainver,UD_SKL.ref());
::       dodaje tylko jesli w tabeli PX_KONT nie ma takiego
         {? PX_KONT.first()=0
         || _kal:=exec('get_kal_nazwa','po_plan',$UD_SKL.ref(),'W');
            _plres:=exec('get_plres','po_plan','W',UD_SKL.ref());
            _ok:=exec('tree_add','px_param', 'W',
                                             $UD_SKL.ref(),
                                             _parent,
                                             UD_SKL.SYMBOL,
                                             UD_SKL.OPIS,
                                             _kal[1],
                                             _kal[2],
                                             UD_SKL.SYMBOL,
                                             $_plres);
            &_kal;
            {? _ok
            || _added+=1
            ?}
         ?};
         UD_SKL.next()
      !};
::    jesli nic nie dodalem to usuwam rodzica
      {? _added=0
      || KONT_TREE.del()
      ?}
   ?}
?};
UD_SKL.cntx_pop();
PX_KONT.cntx_pop();
UD_TYP.cntx_pop();
~~


\color_noavail
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca szary nieaktywny kolor
::   WY: Kolor w formacie MBASE - STRING[23]
::----------------------------------------------------------------------------------------------------------------------
PX_VAR.GREY


\px_cup_gen
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.10]
:: OPIS: Akcja generuj pojemniki w oknie WER tabeli PX_KONT
::   WE: [_a] 0 / 1 - akcja grupowa (nadpisuje istnienie zmiennej __group)
::----------------------------------------------------------------------------------------------------------------------
{? PX_KONT.CUPEQ=null()
|| FUN.emsg('Brak formuły na pojemnik. Generowanie pojemników niemożliwe.'@);
   return()
?};
_group:=0;
::jesli nie akcja grupowa to musze zapytac o zakres
{? var_pres('__group')>0
|| _group:=1
|| _group:=0
?};
{? _>0
|| _group:=_a
?};

{? _group=0
|| exec('def_zakres_smpl','px_param');
:: deklaracje obiektow dla komunikatow
   exec('JCQ_decl','#message');
   {? var_pres('KOMM')<100 || KOMM:=obj_new(@.CLASS.JCQ) ?};
   KOMM.init(200,,'Generator pojemników'@,'',,,0)
?};

::uruchamiam globalna petle generujaca pojemniki
{? var_pres('__startd')>0 & var_pres('__endd')>0
|| exec('cup_generator','px_gen',PX_KONT.ref(),__startd,__endd)
?};

::jesli nie jest akcja grupowa to musze posprzatac
{? _group=0
|| exec('gen_cleanup','px_param')
?};
~~


\px_cup_gen_gr1
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.10]
:: OPIS: Akcja grupa przed generuj pojemniki w oknie WER tabeli PX_KONT
::----------------------------------------------------------------------------------------------------------------------
exec('def_zakres_smpl','px_param');
__group:=1;
:: deklaracje obiektow dla komunikatow
exec('JCQ_decl','#message');
{? var_pres('KOMM')<100 || KOMM:=obj_new(@.CLASS.JCQ) ?};
KOMM.init(200,,'Generator pojemników'@,'',,,0);
~~


\gen_cleanup
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER/PRIVATE
::  UTW: WH [12.10]
:: OPIS: Sprzatam po generowaniu pojemnikow
::       Akcja grupa po generuj pojemniki w oknie WER tabeli PX_KONT
::----------------------------------------------------------------------------------------------------------------------
VAR_DEL.delete('__group','__startd','__startt','__endd','__endt');
KOMM.select();
~~


\px_def_zakres
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Wyswietla dialog z zapytaniem o zakres czasu, pobrane wartosci przechowuje w zmiennych
::       globalnych __startd,__startt,__endd,__endt
::   WE: [_a] - STARTD  - wartosc poczatkowa w oknie redagowania (domyslnie date())
::       [_b] - STARTT  - wartosc poczatkowa w oknie redagowania (domyslnie time(0,0,0))
::       [_c] - ENDD    - wartosc poczatkowa w oknie redagowania (domyslnie date()+exec('get','#params',500350,1))
::       [_d] - ENDT    - wartosc poczatkowa w oknie redagowania (domyslnie time(0,0,0))
::----------------------------------------------------------------------------------------------------------------------
::inicjuje zmienna PX_VAR przekazanymi argumentami
{? _>0
|| PX_VAR.STARTD:=_a
?};
{? _>1
|| PX_VAR.STARTT:=_b
?};
{? _>2
|| PX_VAR.ENDD:=_c
?};
{? _>3
|| PX_VAR.ENDT:=_d
?};
::ustawiam okno edycyjne
_valid:="
   {? PX_VAR.STARTT>time(24,0,0) || FUN.emsg('Proszę podać poprawną godzinę.'@); 'STARTT'
   |? PX_VAR.ENDT>time(24,0,0) || FUN.emsg('Proszę podać poprawną godzinę.'@); 'ENDT'
   || 1
   ?}
";
PX_VAR.win_edit('ZAKRES');
{? PX_VAR.edit(_valid)>0
|| __startd:=PX_VAR.STARTD;
   __startt:=PX_VAR.STARTT;
   __endd:=PX_VAR.ENDD;
   __endt:=PX_VAR.ENDT
::jesli zrezygnowalem z edycji to na wszelki wypadek usuwam zmienne globalne
::po to zeby nie zostaly jakies smieci z poprzednich wywolan
|| VAR_DEL.delete('__startd','__startt','__endd','__endt')
?};
~~


\def_zakres_smpl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Wyswietla dialog z zapytaniem o zakres czasu - ale pyta tylko o daty.
::       Pobrane wartosci przechowuje w globalnych zmiennych __startd, __endd
::   WE: [_a] - STARTD  - wartosc poczatkowa w oknie redagowania (domyslnie date())
::       [_b] - ENDD  - wartosc poczatkowa w oknie redagowania (domyslnie date()+exec('get','#params',500350,1))
::       [_c] - czy kontrolowac poczatek wczesniejszy niz date() - 1 / 0 (domyslnie nie=0)
::----------------------------------------------------------------------------------------------------------------------
_days_max:=exec('get','#params',500350,1);
undefine();
_startd:=date();
_endd:=_startd+_days_max;
_cstart:=0;
{? var_pres('_a')=type_of(date())
|| {? _a=date(0,0,0) || _startd:=date() || _startd:=_a ?};
   _endd:=_startd+_days_max
?};
{? var_pres('_b')=type_of(date())
|| _endd:=_b
?};
{? var_pres('_c')=type_of(0)
|| _cstart:=_c
?};
_red:=PX_VAR.mk_edit('|--|'+'Redagowanie zakresu czasowego'@,,'px_var_'+'defzak2');
PX_VAR.win_efld(_red,,'STARTD',,,10,,,'Początek zakresu:'@);
PX_VAR.win_efld(_red,,'ENDD',,,10,,,'Koniec zakresu:'@);
PX_VAR.win_ebtn(_red,'text=%1'['&Zapisz'@],'key:F2');
PX_VAR.win_ebtn(_red,'text=%1'['&Anuluj'@],'key:Esc');
PX_VAR.win_edit(_red);
{? _cstart
||
   _valid:="
      _startd:=exec('startd','daty');
      {? PX_VAR.STARTD<_startd
      || FUN.emsg('Początek nie może być wcześniej niż %1.'@[$_startd]); PX_VAR.STARTD:=_startd; 'STARTD'
      |? PX_VAR.STARTD<date()
      || FUN.emsg('Początek nie może być wcześniej niż dzisiaj.'@); 'STARTD'
      |? PX_VAR.STARTD>PX_VAR.ENDD
      || FUN.emsg('Koniec nie może być wcześniej niż początek.'@); 'STARTD'
      || 1
      ?}
   "
||
   _valid:="
      _startd:=exec('startd','daty');
      {? PX_VAR.STARTD<_startd
      || FUN.emsg('Początek nie może być wcześniej niż %1.'@[$_startd]); PX_VAR.STARTD:=_startd; 'STARTD'
      |? PX_VAR.STARTD>PX_VAR.ENDD
      || FUN.emsg('Koniec nie może być wcześniej niż początek.'@); 'STARTD'
      || 1
      ?}
  "
?};
PX_VAR.STARTD:=_startd;
PX_VAR.ENDD:=_endd;
{? PX_VAR.edit(_valid)>0
|| __startd:=PX_VAR.STARTD;
   __endd:=PX_VAR.ENDD
::jesli zrezygnowalem z edycji to na wszelki wypadek usuwam zmienne globalne
::po to zeby nie zostaly jakies smieci z poprzednich wywolan
|| VAR_DEL.delete('__startd','__startt','__endd','__endt')
?};
~~


\px_date_now
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.10]
:: OPIS: Zwraca aktualna date
::   WY: DATE
::----------------------------------------------------------------------------------------------------------------------
date()


\px_time_zero
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.10]
:: OPIS: Zwraca polnoc (czas 00:00)
::   WY: TIME
::----------------------------------------------------------------------------------------------------------------------
time(0,0,0)


\px_date_max
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.10]
:: OPIS: Zwraca maksymalna date (horyzont planowania)
::   WY: DATE
::----------------------------------------------------------------------------------------------------------------------
_days_max:=exec('get','#params',500350,1);
_result:=date()+_days_max+1;
_result


\px_var2px_kont
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Przenosi wlasciwosci ze zmiennej PX_VAR do tabeli PX_KONT
::       Pracuje w aktualnym kontekscie zmiennej PX_VAR i tabeli PX_KONT
::----------------------------------------------------------------------------------------------------------------------
PX_KONT.CUPEQ:=PX_VAR.CUPEQ;
PX_KONT.CUP_IN:=PX_VAR.CUP_IN;
PX_KONT.CUP_OUT:=PX_VAR.CUP_OUT;
PX_KONT.IL_WYM:=PX_VAR.IL_WYM;
PX_KONT.MINEQ1:=PX_VAR.MINEQ1;
PX_KONT.MINEQ2:=PX_VAR.MINEQ2;
PX_KONT.MINEQ3:=PX_VAR.MINEQ3;
PX_KONT.MINEQ4:=PX_VAR.MINEQ4;
PX_KONT.MINEQ5:=PX_VAR.MINEQ5;
PX_KONT.MAXEQ1:=PX_VAR.MAXEQ1;
PX_KONT.MAXEQ2:=PX_VAR.MAXEQ2;
PX_KONT.MAXEQ3:=PX_VAR.MAXEQ3;
PX_KONT.MAXEQ4:=PX_VAR.MAXEQ4;
PX_KONT.MAXEQ5:=PX_VAR.MAXEQ5;
PX_KONT.JM1:=PX_VAR.JM1;
PX_KONT.JM2:=PX_VAR.JM2;
PX_KONT.JM3:=PX_VAR.JM3;
PX_KONT.JM4:=PX_VAR.JM4;
PX_KONT.JM5:=PX_VAR.JM5;
PX_KONT.PREC1:=PX_VAR.PREC1;
PX_KONT.PREC2:=PX_VAR.PREC2;
PX_KONT.PREC3:=PX_VAR.PREC3;
PX_KONT.PREC4:=PX_VAR.PREC4;
PX_KONT.PREC5:=PX_VAR.PREC5;
PX_KONT.CAP_INF1:=PX_VAR.CAP_INF1;
PX_KONT.CAP_INF2:=PX_VAR.CAP_INF2;
PX_KONT.CAP_INF3:=PX_VAR.CAP_INF3;
PX_KONT.CAP_INF4:=PX_VAR.CAP_INF4;
PX_KONT.CAP_INF5:=PX_VAR.CAP_INF5;
PX_KONT.GRP_MODE:=PX_VAR.GRP_MODE;
PX_KONT.A:=PX_VAR.A;
PX_KONT.NAKL_PRC:=PX_VAR.NAKL_PRC;
PX_KONT.MAX_CDUR:=PX_VAR.MAX_CDUR;
PX_KONT.OFFSET:=PX_VAR.OFFSET;
PX_KONT.PX_SET:=PX_VAR.RED_SET;
PX_KONT.PARALLEL:=PX_VAR.PARALLEL;
PX_KONT.put()


\px_kont2px_var
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Przenosi wlasciwosci z rekordu tabeli PX_KONT do zmiennej PX_VAR
::       Pracuje w aktualnym kontekscie zmiennej PX_VAR i tabeli PX_KONT
::----------------------------------------------------------------------------------------------------------------------
PX_VAR.CUPEQ:=PX_KONT.CUPEQ;
PX_VAR.CUP_IN:=PX_KONT.CUP_IN;
PX_VAR.CUP_OUT:=PX_KONT.CUP_OUT;
PX_VAR.IL_WYM:=PX_KONT.IL_WYM;
PX_VAR.MINEQ1:=PX_KONT.MINEQ1;
PX_VAR.MINEQ2:=PX_KONT.MINEQ2;
PX_VAR.MINEQ3:=PX_KONT.MINEQ3;
PX_VAR.MINEQ4:=PX_KONT.MINEQ4;
PX_VAR.MINEQ5:=PX_KONT.MINEQ5;
PX_VAR.MAXEQ1:=PX_KONT.MAXEQ1;
PX_VAR.MAXEQ2:=PX_KONT.MAXEQ2;
PX_VAR.MAXEQ3:=PX_KONT.MAXEQ3;
PX_VAR.MAXEQ4:=PX_KONT.MAXEQ4;
PX_VAR.MAXEQ5:=PX_KONT.MAXEQ5;
PX_VAR.JM1:=PX_KONT.JM1;
PX_VAR.JM2:=PX_KONT.JM2;
PX_VAR.JM3:=PX_KONT.JM3;
PX_VAR.JM4:=PX_KONT.JM4;
PX_VAR.JM5:=PX_KONT.JM5;
PX_VAR.PREC1:=PX_KONT.PREC1;
PX_VAR.PREC2:=PX_KONT.PREC2;
PX_VAR.PREC3:=PX_KONT.PREC3;
PX_VAR.PREC4:=PX_KONT.PREC4;
PX_VAR.PREC5:=PX_KONT.PREC5;
PX_VAR.CAP_INF1:=PX_KONT.CAP_INF1;
PX_VAR.CAP_INF2:=PX_KONT.CAP_INF2;
PX_VAR.CAP_INF3:=PX_KONT.CAP_INF3;
PX_VAR.CAP_INF4:=PX_KONT.CAP_INF4;
PX_VAR.CAP_INF5:=PX_KONT.CAP_INF5;
PX_VAR.GRP_MODE:=PX_KONT.GRP_MODE;
PX_VAR.A:=PX_KONT.A;
PX_VAR.NAKL_PRC:=PX_KONT.NAKL_PRC;
PX_VAR.MAX_CDUR:=PX_KONT.MAX_CDUR;
PX_VAR.RED_SET:=PX_KONT.PX_SET;
PX_VAR.PARALLEL:=PX_KONT.PARALLEL;
~~


\px_rule_cup
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.10]
:: OPIS: Typ formuly - formula na pojemnik
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'CUP'


\px_rule_in
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.10]
:: OPIS: Typ formuly - formula po wlaniu
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'IN'


\px_rule_out
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.10]
:: OPIS: Typ formuly - formula po wylaniu
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'OUT'


\px_rule_cap
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.10]
:: OPIS: Typ formuly - formula na pojemnosc
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'CAP'


\px_rule_tex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Typ formuly - formula na generowanie przepisu
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'TEX'


\px_rule_tex_tex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Formula na generowanie przepisu - nazwa domyslna dla technol
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'~Technologia'


\px_rule_tex_own
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Formula na generowanie przepisu - nazwa domyslna dla przepisu wlasnego
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'~Przepis własny'


\px_rules_prfx
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Prefiksuje slownik PX_RULES metoda na wartosc poczatkowa - zmienna PX_VAR.RULE_TYP jest uzywana
::       w blanku pola PX_RULES.TYP, dzieki czemu slownik sie prefiksuje
::   WE: _a - STRING - PX_RULES.TYP
::----------------------------------------------------------------------------------------------------------------------
_typ:='';
{? _<0
|| return()
?};
_typ:=_a;

PX_VAR.RULE_TYP:=_typ;
~~


\px_rules_typ_bl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.10]
:: OPIS: Blank pola tabeli PX_RULES.TYP
::----------------------------------------------------------------------------------------------------------------------
::ustawiam blank wg zmiennej PX_VAR.RULE_TYP - uzywane do prefiksowania slownika podczas edycji
::wlasciwosci kontenera (okna redagowania PX_KONT>RED_FULL, PX_KONT>RED_SMPL, PX_VAR>KONT_PAR)

PX_RULES.TYP:=PX_VAR.RULE_TYP;
~~


\px_rules_typ_be
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.10]
:: OPIS: Przed edycja pola tabeli PX_RULES.TYP
::----------------------------------------------------------------------------------------------------------------------
::jesli jest ustawiona zmienna PX_VAR.RULE_TYP to znak ze dodawanie rekordu jest robione
::z poziomu w ktorym tabela PX_RULES zostala zaprefiksowana metoda 'blankowania'
::w takim przypadku redagowanie pola PX_RULES.TYP powinno byc niedostepne, bo user moze dodac rekord
::spoza dziedziny
_result:=1;
{? PX_VAR.RULE_TYP<>''
|| _result:=0
?};
_result


\delays_plan
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca wartosc parametru formul systemu: 500356
::----------------------------------------------------------------------------------------------------------------------
'PRZEPLANUJ'


\delays_move
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca wartosc parametru formul systemu: 500356
::----------------------------------------------------------------------------------------------------------------------
'PRZESUŃ'


\px_tab_params
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy tablice nazwana z parametrami podczytanymi z tabel PX_
::   WY: Uchwyt do tablicy
::----------------------------------------------------------------------------------------------------------------------
_array:=obj_new('il_wym'
               ,'PX_CUP'
               ,'PX_KONT'
               ,'PX_OPER'
               ,'PX_POZ'
               ,'PX_WYK'
::               ,'PX_VAR'
               );

:: liczba wymiarow
_array.il_wym:=exec('il_wym','px_param');

:: wspolrzedne pierwszych pol w tabeli PX_CUP
_array.PX_CUP:=obj_new('CAP_MAX','CAP_MIN','CAP_USE','CAP_WYK');
{! _ff:=1..PX_CUP.fld_num()
|! {? PX_CUP.fld_acr(_ff)='CAP_MAX1' || _array.PX_CUP.CAP_MAX:=_ff
   |? PX_CUP.fld_acr(_ff)='CAP_MIN1' || _array.PX_CUP.CAP_MIN:=_ff
   |? PX_CUP.fld_acr(_ff)='CAP_USE1' || _array.PX_CUP.CAP_USE:=_ff
   |? PX_CUP.fld_acr(_ff)='CAP_WYK1' || _array.PX_CUP.CAP_WYK:=_ff
   ?}
!};

:: wspolrzedne pierwszych pol w tabeli PX_KONT
_array.PX_KONT:=obj_new('JM','MINEQ','MAXEQ','PREC','CAP_INF');
{! _ff:=1..PX_KONT.fld_num()
|! {? PX_KONT.fld_acr(_ff)='JM1'      || _array.PX_KONT.JM:=_ff
   |? PX_KONT.fld_acr(_ff)='MINEQ1'   || _array.PX_KONT.MINEQ:=_ff
   |? PX_KONT.fld_acr(_ff)='MAXEQ1'   || _array.PX_KONT.MAXEQ:=_ff
   |? PX_KONT.fld_acr(_ff)='PREC1'     || _array.PX_KONT.PREC:=_ff
   |? PX_KONT.fld_acr(_ff)='CAP_INF1' || _array.PX_KONT.CAP_INF:=_ff
   ?}
!};

:: wpolrzedne pierwszych pol w tabeli PX_OPER
_array.PX_OPER:=obj_new('CAP_MAX','CAP_MIN','CAP_USE','CAPFMAX','CAPFMIN','CAPFUSE');
{! _ff:=1..PX_OPER.fld_num()
|! {? PX_OPER.fld_acr(_ff)='CAP_MAX1' || _array.PX_OPER.CAP_MAX:=_ff
   |? PX_OPER.fld_acr(_ff)='CAP_MIN1' || _array.PX_OPER.CAP_MIN:=_ff
   |? PX_OPER.fld_acr(_ff)='CAP_USE1' || _array.PX_OPER.CAP_USE:=_ff
   |? PX_OPER.fld_acr(_ff)='CAPFMAX1' || _array.PX_OPER.CAPFMAX:=_ff
   |? PX_OPER.fld_acr(_ff)='CAPFMIN1' || _array.PX_OPER.CAPFMIN:=_ff
   |? PX_OPER.fld_acr(_ff)='CAPFUSE1' || _array.PX_OPER.CAPFUSE:=_ff
   ?}
!};

:: wspolrzedne pierwszych pol w tabeli PX_POZ
_array.PX_POZ:=obj_new('CAP_MAX','CAP_MIN','CAP_EAT','CAP_WYK');
{! _ff:=1..PX_POZ.fld_num()
|! {? PX_POZ.fld_acr(_ff)='CAP_MAX1' || _array.PX_POZ.CAP_MAX:=_ff
   |? PX_POZ.fld_acr(_ff)='CAP_MIN1' || _array.PX_POZ.CAP_MIN:=_ff
   |? PX_POZ.fld_acr(_ff)='CAP_EAT1' || _array.PX_POZ.CAP_EAT:=_ff
   |? PX_POZ.fld_acr(_ff)='CAP_WYK1' || _array.PX_POZ.CAP_WYK:=_ff
   ?}
!};

:: wspolrzedne pierwszych pol w zmiennej PX_VAR
:: trzeba dopisac gdy bedzie potrzebne

_array


\can_res_change
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Sprawdza czy mozliwa jest modyfikacja parametru 500351 - rozdzielczosc planu
::   WY: 0 - sa juz wygenerowane pojemniki wiec nie mozna zmienic rozdzielczosci
::       1 - mozna zmienic rozdzielczosc
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
PX_VER.cntx_psh();
PX_KONT.cntx_psh();
PX_CUP.cntx_psh();
_mainver:=exec('get_mainversion','px_ver');
PX_CUP.index('START');
PX_KONT.index('ACT');
PX_KONT.prefix('T',_mainver);
{? PX_KONT.first()
|| {!
   |? PX_CUP.prefix(PX_KONT.ref());
      {? PX_CUP.size>0
      || _result:=0
      ?};
      PX_KONT.next() & _result>0
   !}
?};
PX_CUP.cntx_pop();
PX_KONT.cntx_pop();
PX_VER.cntx_pop();
_result


\get_px_rule_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Zwraca PX_RULE.ref() dla podanego rodzaju i symbolu reguly
::   WE: STRING _a - PX_RULE.TYP
::       STRING _b - PX_RULE.SYMBOL
::   WY: PX_RULE.ref()
::UWAGA: Brak kontroli parametrow
::----------------------------------------------------------------------------------------------------------------------
_px_rules:=null();
PX_RULES.cntx_psh();
PX_RULES.index('TYP');
PX_RULES.prefix(_a,_b);
{? PX_RULES.first() || _px_rules:=PX_RULES.ref() ?};
PX_RULES.cntx_pop();
_px_rules


\txt_plan_fwd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca tekst oznaczajacy zaplanowany przedzial czasowy (planowany do przodu)
::----------------------------------------------------------------------------------------------------------------------
'►►►►►'


\txt_plan_bck
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca tekst oznaczajacy zaplanowany przedzial czasowy (planowany wstecz)
::----------------------------------------------------------------------------------------------------------------------
'◄◄◄◄◄'


\txt_plan_nul
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca tekst oznaczajacy zaplanowany przedzial czasowy (kierunek nieokreslony)
::----------------------------------------------------------------------------------------------------------------------
'▓▓▓▓▓▓▓▓▓▓'


\txt_free
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Zwraca tekst oznaczajacy wolny przedzial czasowy
::----------------------------------------------------------------------------------------------------------------------
'☼'


\txt_point
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca tekst oznaczajacy istnienie punktu czasowego dla pozycji planu
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'↓↓↓↓↓'


\txt_point_sin
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca pojedynczy znak oznaczajacy istnienie punktu czasowego
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'↓'


\txt_point_min
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca tekst oznaczajacy istnienie punktu czasowego dla etapu - minimalny czas poczatku
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'↓→'


\txt_point_max
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca tekst oznaczajacy istnienie punktu czasowego dla etapu - maksymalny czas konca
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'←↓'


\txt_err_sin
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca pojedynczy znak oznaczajacy istnienie bledu
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'!'


\txt_error
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca tekst oznaczajacy istnienie bledu
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'!!!!!!!'


\overfill_stop
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca wartosc dla parametru nr 500357
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'PRZERWIJ PLANOWANIE'


\overfill_cont
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca wartosc dla parametru nr 500357
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'KONTYNUUJ Z PRZEPEŁNIENIAMI'


\start_nextcup
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca wartosc dla parametru nr 500358
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'NASTĘPNY POJEMNIK'


\start_curcup
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca wartosc dla parametru nr 500358
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'BIEŻĄCY POJEMNIK'


\zl_tex_mode_aut
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sposób generowania przepisów dla zleceń
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'AUTOMATYCZNIE'


\zl_tex_mode_man
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sposób generowania przepisów dla zleceń
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'RĘCZNIE'


\is_one_version
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy zostal wlaczony parametr pracy na jednej wersji planu
::   WY: 0/1
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_par:=exec('get','#params',500365,2);
{? _par='T'
|| _result:=1
?};
_result


\is_grps_static
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Czy widok kolejki oparty na tabeli stalej (PX_GRPS)
::   WY: kolejka w widoku tymczasowym (0), kolejka w tabeli PX_GRPS (1)
::----------------------------------------------------------------------------------------------------------------------
exec('is_one_version','px_param')


\is_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy zostal wlaczony parametr planowania grup operacji
::   WY: 0/1
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
PX_VAR.PL_GROP


\tree_kont
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Czy kontenery wyswietlane sa w widoku drzewa
::----------------------------------------------------------------------------------------------------------------------
exec('get','#params',8058,2,OPERATOR.USER)='T' & ~exec('is_px_set','px_param')


\queue_in_tabs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Czy kolejka i obiekty do planowania w zakladakach
::----------------------------------------------------------------------------------------------------------------------
exec('get','#params',8061,2,OPERATOR.USER)='T'


\is_px_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Sprawdza, czy jest zdefiniowany co najmniej jeden PX_SET (o ile pracuje na jednej wersji),
::       a co za tym idzie jest mozliwa praca na zestawach planistycznych
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
{? exec('is_one_version','px_param')
|| PX_SET.cntx_psh();
   PX_SET.prefix();
   _res:=PX_SET.size()>0;
   PX_SET.cntx_pop()
?};
_res


\oper_nast_standard
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Algorytm nakładkowania operacji
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
'BRAK'


\oper_nast_il
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Algorytm nakładkowania operacji
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
'PROPORCJA ILOŚCIOWA'


\oper_nast_time
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Algorytm nakładkowania operacji
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
'PROPORCJA CZASOWA'


\is_oper_nast_il
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Sprawdza czy jest włączone następstwo operacji ilościowe
::   WY: 0/1
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_par:=exec('get','#params',500370);
{? _par=exec('oper_nast_il','px_param')
|| _result:=1
?};
_result


\is_oper_nast_time
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Sprawdza czy jest włączone następstwo operacji czasowe
::   WY: 0/1
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_par:=exec('get','#params',500370);
{? _par=exec('oper_nast_time','px_param')
|| _result:=1
?};
_result


\pxkont_create
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Akcja utwórz zasób w oknie
::   WE: _a - ref rekordu w tabeli KONT_TREE
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;
_tab:=tab_tmp(3,
   'POS','INTEGER','Nazwa pola 1',
   'REF','INTEGER','Nazwa pola 2',
   'CRC','INTEGER','Nazwa pola 2'
);

_tab.blank();
_tab.REF:=#_ref;
_tab.add();
exec('pxkont_dnd_drop','px_kont',_tab);
grp_disp(PX_KONT,'WER');
grp_disp(KONT_TREE,WERK_TREE);
~~


\reason_plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca wartość pola REASON - wg planu
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
'WG. PLANU'


\reason_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca wartość pola REASON - wg grupy operacji
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
'GR.OPER'


\reason_point
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca wartość pola REASON - wg punktu czasowego
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
'PKT.CZAS.'


\reason_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca wartość pola REASON - wg planu dostaw
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
'SUROWCE'


\reason_ploper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca wartość pola REASON - wg planu dostaw
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
'PLAN OPER.'

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:38 2a2a3e4868f7bf09b8cf666c768f9c9c62e538f637daa68ce45a5ae3ab09e8c67bba378e6dfbb696387944651b09239dcf5fbdfbee2e824d93cec4404a7526258207612e0f2ab20df2c2d48594266d21aa0fa4669ceab4619f585944d35b132ca97a30ea834baca256e4158727806e786b1ef13b7dfa52fc9f0375ff104f8b53
