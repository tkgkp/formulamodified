:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: rubryki.fml
:: Utworzony: 21.01.2015
:: Autor: RWR
::======================================================================================================================
:: Zawartość: Formuły wspólne obsługi rubryk płacowych.
::======================================================================================================================


\_std_kod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.02]
:: OPIS: Lista kodów standardowych rubryk.
::   WE: [_a] [NUMBER] - Czy pomijać analizę tabeli R [0*/1]?
::   WY: lista kodów oddzielonych przecinkami
::----------------------------------------------------------------------------------------------------------------------
_pomin:=var_pres('_a')=type_of(0) & _a;

:: lista standardowych rubryk
_std:=
:: 1-99
   '1,2,3,4,5,6,7,8,9,'
   '10,11,12,13,14,15,16,17,18,19,'
   '20,21,22,23,24,25,26,27,28,29,'
   '30,31,32,33,'
   '48,49,'
   '51,52,53,54,55,56,57,58,59,'
   '60,61,62,63,64,65,66,67,68,69,'
   '71,72,73,'
   '90,91,92,93,94,99,'
:: 100-199
   '100,101,102,103,105,106,107,108,'
   '110,111,'
   '120,121,122,123,124,125,126,'
   '135,'
   '150,151,152,153,154,'
   '170,175,177,'
:: 200-299
   '200,'
:: 300-399
:: 400-499
   '436,437,438,439,'
   '440,442,443,444,'
   '465,467,468,469,'
   '470,'
   '499,'
:: 500-599
   '500,'
   '510,511,512,513,514,515,516,517,'
   '520,521,523,524,528,529,'
   '530,531,532,533,534,535,536,537,538,539,'
   '540,541,542,543,544,'
:: 600-699
   '650,655,'
:: 700-799
   '701,'
   '710,711,712,713,714,715,716,717,718,719,'
   '730,731,732,733,734,735,'
   '740,744,745,746,747,'
   '750,751,752,753,754,755,756,'
   '765,766,767,769,'
   '771,772,779,'
   '780,784,785,788,789,'
   '790,791,792,793,794,795,797,798,799,'
:: 800-899
   '800,810,811,812,'
   '820,821,822,823,824,825,826,827,'
   '949,'
   '950,951,958,959,'
   '960,961,962,963,'
   '970,971,972,973,974,975,976,977,'
   '980,981,982,983,984,985,986,'
   '990,994,995,996,999';

{? _pomin
|| return(_std)
?};

:: Dopisz kody standardowe
R.cntx_psh();
R.index('RUBKOD');
R.prefix();
_loop:=R.find_ge(7000);
{!
|? _loop
|! _std+=','+$R.RN;
   _loop:=R.next()
!};
R.cntx_pop();

_std


\_std_mod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.02]
:: OPIS: Tworzy i wypełnia tablicę standardowej konfiguracji dostępnych do edycji pól
::   WE:
::   WY: tablica zawierająca konfigurację
::----------------------------------------------------------------------------------------------------------------------
:: domyślnie pusta tablica
_len:=9999;
_mod:=obj_new(_len);
{! _ii:=1.._len
|! _mod[_ii]:=~~
!};

:: dla standardowych rubryk przypisz domyślne ustawienia
_rub:=spli_str(exec('_std_kod','rubryki'),',');
_acc:=exec('_std_acc','rubryki');
_len:=obj_len(_rub);
{! _ii:=1.._len
|! _mod[#_rub[_ii]]:=_acc
!};

:: wyjątki od domyślnych ustawień
_mod[99]:=~~;

_mod


\_all_mod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.02]
:: OPIS: Zwraca listę wszystkich pól, dla których może być włączona/wyłączona blokada modyfikacji.
::       Kolejność ma znacznienie, ponieważ zgodnie z nią będzie budowane okienko wyświetlania konfiguracji, ponieważ
::       przeglądanie struktury daje układ pól niezgodny z okienkiem redakcji.
::   WE:
::   WY: lista akronimów pól oddzielonych przecinkami
::----------------------------------------------------------------------------------------------------------------------
'LP,RN,RT,RK,KDL,KDZ,KDR,RSKZ,RSKP,RSKU,ROLAP,URL,EKW,CHO,ZUS,POD,UBZ,OPIS,NOTA'


\_std_lck
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.02]
:: OPIS: Zwraca listę pól, które nie mogą być modyfikowane w przypadku rubryki standardowej - wyłączenie z konfiguracji.
::   WE:
::   WY: lista akronimów pól oddzielonych przecinkami
::----------------------------------------------------------------------------------------------------------------------
'LP,RN,RK,RSKZ,RSKP,RSKU'


\_std_acc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.02]
:: OPIS: Zwraca listę pól, które domyślnie w przypadku rubryki standardowej są dostępne do modyfikacji.
::   WE:
::   WY: lista akronimów pól oddzielonych przecinkami
::----------------------------------------------------------------------------------------------------------------------
'RT,KDL,KDZ,KDR,ROLAP,OPIS,NOTA'


\r_adda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Wyzwalacz "Dołącz - po" dla tabeli R.
::   WE: _a [INTEGER] - Wynik właściwej operacji.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? ~_a | do_state()<>1
|| return()
?};
exec('r_moda','rubryki');
~~


\r_puta
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła wyzwalacza "popraw po" tabeli R.
::   WE: zgodne ze specyfikacją narzędzi
::   WY: zgodna ze specyfikacją narzędzi
::----------------------------------------------------------------------------------------------------------------------
: Zakończ, jeśli nie zmieniono rekordu.
{? ~_a | do_state()<>1 || return() ?};

{? bfld('RN')<>R.RN | bfld('RT')<>R.RT
:: Obsługa anomalii w tabeli PAR_POKR.
:: Tabela R jest wspólna dla wszyskich firm, a w PAR_POKR jest relacja do FIRMA.
:: Zmiana kodu lub nazwy rubryki (w nadmiarowych polach tabeli PAR_POKR) musi być naniesiona we wszystkich firmach.
|| PAR_POKR.cntx_psh();
   PAR_POKR.index('R0');
   PAR_POKR.prefix(R.ref());
   {? PAR_POKR.first()
   || {!
      |? PAR_POKR.put();
         PAR_POKR.next()
      !}
   ?};
   PAR_POKR.cntx_pop();

:: Obsługa anomalii w tabeli ZRPP.
   ZRPP.cntx_psh();
   ZRPP.index('R');
   ZRPP.prefix(R.ref());
   {? ZRPP.first()
   || {!
      |? ZRPP.put();
         ZRPP.next()
      !}
   ?};
   ZRPP.cntx_pop();

   exec('r_moda','rubryki')
?};
~~


\r_delb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.02]
:: OPIS: Formuła wyzwalacza "usuń przed" tabeli R.
::   WE:
::   WY: zgodna ze specyfikacją narzędzi
::----------------------------------------------------------------------------------------------------------------------
exec('del_ndx','#table',RUB_MOD,'RUB_MOD',R.ref()) &
exec('del_ndx','#table',RUB_LOG,'CZAS',R.ref())


\r_dela
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Wyzwalacz "Usuń - po" dla tabeli R.
::   WE: _a [INTEGER] - Wynik właściwej operacji.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? ~_a | do_state()<>1
|| return()
?};
exec('r_moda','rubryki');
~~


\r_moda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Po modyfikacji rekordu.
::       Formuła wywoływana z wyzwalaczy typu "po" dla tabeli R.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: Wymuszenie odtworzenia mapy nieobecnosci na portalu (jeżeli istnieje).
{? ~exec('_map_erase','portal_nieobecnosci')
|| undo('Aktualizacja mapy nieobecności na portalu nie powiodła się.'@)
?};
~~


\rub_mod_adda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.02]
:: OPIS: Formuła wyzwalacza "dołącz po" tabeli RUB_MOD.
::   WE: zgodne ze specyfikacją narzędzi
::   WY: zgodna ze specyfikacją narzędzi
::----------------------------------------------------------------------------------------------------------------------
: Zakończ, jeśli nie dołączono rekordu.
{? ~_a | do_state()<>1 || return() ?};

: Odpisz informację o zmianie ustawień
exec('rub_log','rubryki',RUB_MOD.R,RUB_MOD.POLE,'T','N');
~~


\rub_mod_dela
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.02]
:: OPIS: Formuła wyzwalacza "usuń po" tabeli RUB_MOD.
::   WE: zgodne ze specyfikacją narzędzi
::   WY: zgodna ze specyfikacją narzędzi
::----------------------------------------------------------------------------------------------------------------------
: Zakończ, jeśli nie zmieniono rekordu.
{? ~_a | do_state()<>1 || return() ?};

: Odpisz informację o zmianie ustawień
exec('rub_log','rubryki',bfld('R'),bfld('POLE'),'N','T');
~~


\rub_log
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.02]
:: OPIS: Zapisuje informacje o zmianie wartości pola w tabeli RUB_MOD.
::   WE: _a [_R] - wskazanie opisu składnika listy płac
::       _b [STRING] - akronim zmienianego pola
::       _c [STRING] - poprzednia wartość
::       _d [STRING] - nowa wartość
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? _c=_d || return() ?};

RUB_LOG.blank(1);
RUB_LOG.R:=_a;
RUB_LOG.POLE:=_b;
RUB_LOG.MOD_KTO:=OPERATOR.USER;
RUB_LOG.MOD_DATA:=date();
RUB_LOG.MOD_CZAS:=time();
RUB_LOG.WART_P:=_c;
RUB_LOG.WART_N:=_d;
RUB_LOG.add();
~~


\lp_add_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła porządkująca kolejność obliczeń (LP) składników płacowych, wywoływana po dołączeniu rekordu
::       (w szczególności w trakcie importu).
::   WE:
::   WY:
::  OLD: \r_dod_po/formuly.fml
::----------------------------------------------------------------------------------------------------------------------
R.cntx_psh();
R.clear();
R.index('RUBLP');
{? R.LP>R.size()
|| R.LP:=R.size();
   R.put()
|? R.LP<R.size()
|| _ref:=R.ref();
   _lp:=R.LP;
   _loop:=R.last();
   {!
   |? _loop & _lp<=R.LP
   |! {? R.ref()<>_ref
      || R.LP+=1;
         R.put()
      ?};
      _loop:=R.prev()
   !}
?};
R.cntx_pop()


\klasa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Definicja dostępnych klas rubryk.
::   WE:
::   WY: Tablica z uchwytem do utworzonej tabeli tymczasowej i jej indeksami.
::----------------------------------------------------------------------------------------------------------------------
_klasa:=obj_new('TAB','NDX');

_klasa.TAB:=tab_tmp(1,
   'LP','INTEGER','Lp.',
   'RK','STRING[1]','Klasa',
   'O','STRING[30]','Opis'
);
_klasa.NDX:=obj_new('LP','RK');
_klasa.NDX.LP:=_klasa.TAB.index('?');
_klasa.NDX.RK:=_klasa.TAB.ndx_tmp(,,'RK',,);

_add:="_a.blank(); _a.LP:=_a.size()+1; _a.RK:=_b; _a.O:=_c; _a.add()";

_add(_klasa.TAB,'S','składnik stały'@);
_add(_klasa.TAB,'N','nieobecność'@);
_add(_klasa.TAB,'R','zarejestrowany czas pracy'@);
_add(_klasa.TAB,'D','rozliczenie delagacji'@);
_add(_klasa.TAB,'B','polecenie przelewu'@);
_add(_klasa.TAB,'K','rata kredytu / składka'@);
_add(_klasa.TAB,'Z','świadczenie ZFŚS'@);
_add(_klasa.TAB,'-','');
_add(_klasa.TAB,'T','zamykający kolumnę wydruku'@);
_add(_klasa.TAB,'G','grupujący składniki listy'@);
_add(_klasa.TAB,'#','zawsze przeliczany'@);
_add(_klasa.TAB,'-','');
_add(_klasa.TAB,'*','ukryty dla kartotek'@);

_klasa.TAB.first();

_klasa


\rk_opis
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła ustala opis klasy na podstawie wartości i przypisuje go do zmiennej EDIT_VAR.RK_OPIS.
::   WE: _a - Uchwyt do tablicy dostępnych klas rubryk (patrz formuła: rubryki.fml\klasa). Poprawność argumentu nie jest
::            weryfikowana.
::       _b - Klasa [DOMYŚLNIE: R.RK]
::       _c - Czy z komunikatem dla błędnego kodu:
::             0 - Nie [DOMYŚLNIE].
::             1 - Tak.
::   WY: 1 - Klasa poprawna - opis ustawiony.
::       0 - Brak klasy (pusta) lub niepoprawna - opisu nie udało się ustawić.
::----------------------------------------------------------------------------------------------------------------------
EDIT_VAR.RK_OPIS:='';

_klasa:=_a;
_kod:={? var_pres('_b')=type_of('') & +_b<=1 || _b || R.RK ?};

_ret:=1;

{? _kod<>''
|| _klasa.TAB.index(_klasa.NDX.RK);
   _ret:=_klasa.TAB.find_key(_kod,);
   {? _ret
   || EDIT_VAR.RK_OPIS:=_klasa.TAB.O
   |? var_pres('_c')=type_of(0) & _c
   || FUN.info('Wpisana wartość nie jest obsługiwana. Skorzystaj ze słownika.'@)
   ?}
?};
_ret


\imex_cfg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.41]
:: OPIS: Formuła konfigurująca import i eksport rubryk.
::   WE: [_a] [STRING] - Kod miejsca położenia plików:
::                         'g' - Pliki globalne - wspólne w ramach wszystkich firm (*.dfk)
::                         'l' - Pliki lokalne - związane z konkretną firmą (*.txt) [DOMYŚLNIE].
::            [ARRAY]  - Tablica z trzema elementami:
::                         1. '1'
::                         2. Pełna ścieżka dostępu do pliku z rubrykami.
::                         3. Pełna ścieżka dostępu do pliku z polem SYS_MEMO.
::   WY: Tablica z konfiguracją.
::  OLD: \r_cfg/formuly.fml
::----------------------------------------------------------------------------------------------------------------------
_cfg:=obj_new('fnl','echo','sep','opt','STRU');
_cfg.fnl:=obj_new(2);

{? var_pres('_a')>100 & obj_len(_a)=3 & _a[1]='1'
|| _cfg.fnl[1]:=_a[2];
   _cfg.fnl[2]:=_a[3]

|| {? var_pres('_a')<>type_of('')
   || _a:='l'
   ?};
   _ext:='.'+{? _a='g' || 'dfg' || 'txt' ?};
   _fn:=obj_new(2);
   _fn[1]:='rubryki'+_ext;
   _fn[2]:='r_memo'+_ext;
   {! _lp:=1 .. 2
   |! _cfg.fnl[_lp]:=pth_dir(_fn[_lp])+exec('sep','#file',1)+_fn[_lp]
   !}
?};

_cfg.echo:=1;
:Tylko pliki CSV obsługują pola typu SYS_MEMO - zmiana separatora spowoduje błędy.
_cfg.sep:=%1+';';
_cfg.opt:='UTF-8,nopth,header';

:Definicja struktury tabeli R (i pól w importowanym/eksportowanym pliku).
_cfg.STRU:=tab_tmp(2,
   'NRF','INTEGER','Nr pliku',
   'LP','INTEGER','Lp.',
   'AKR','STRING[8]','Akronim',
   'TYP','STRING[16]','Typ',
   'NAZWA','STRING[60]','Nazwa',
   'IMEX','INTEGER','Czy pole będzie importowane/eksportowane?'
);
_add:="
   _a.prefix(_b); _lp:=_a.size()+1; _a.prefix();
   _a.blank();
   _a.NRF:=_b;
   _a.LP:=_lp;
   _a.AKR:=_c;
   _a.TYP:=_d;
   _a.NAZWA:=_e;
   _a.IMEX:={? var_pres('_f')=type_of(0) || _f || 1 ?};
   _a.add()
";

:Podstawowy plik parametryzujący rubryki - bez pól typu SYS_MEMO.
_add(_cfg.STRU,1,'RN','INTEGER','Kod');
_add(_cfg.STRU,1,'RT','STRING[20]','Nazwa');
_add(_cfg.STRU,1,'RK','STRING[1]','Klasa');
_add(_cfg.STRU,1,'RSKZ','INTEGER','Karta zarobkowa');
_add(_cfg.STRU,1,'RSKP','INTEGER','Karta podatkowa');
_add(_cfg.STRU,1,'RSKU','INTEGER','Karta ubezpiecz.');
::_add(_cfg.STRU,1,'KD','STRING[1]','Wydruk składników');
_add(_cfg.STRU,1,'KDR','STRING[1]','Wydruk - rachunek');
_add(_cfg.STRU,1,'URL','STRING[1]','Do urlopu');
_add(_cfg.STRU,1,'CHO','STRING[1]','Do zasiłku');
_add(_cfg.STRU,1,'ZUS','STRING[1]','Do ubezp.');
_add(_cfg.STRU,1,'POD','STRING[1]','Do podatku');
_add(_cfg.STRU,1,'UBZ','STRING[1]','Do ub. zdrow.');
_add(_cfg.STRU,1,'EKW','STRING[1]','Do ekwiwalentu');
_add(_cfg.STRU,1,'OPIS','STRING[100]','Komentarz');
_add(_cfg.STRU,1,'KDL','STRING[1]','Wydruk - lista');
_add(_cfg.STRU,1,'KDZ','STRING[1]','Wydruk - zbiorówka');
:Pole LP nie jest importowane/eksportowane.
_add(_cfg.STRU,1,'LP','INTEGER','Numer',0);

:Dodatkowy plik parametryzujący rubryki z KOD-em i polami typu SYS_MEMO.
_add(_cfg.STRU,2,'RN','INTEGER','Kod');
_add(_cfg.STRU,2,'NOTA','SYS_MEMO','Opis');

_cfg


\_r_export1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.41]
:: OPIS: Formuła eksportująca tabelę rubryk w formacie wersji 1 (zostawiona historycznie).
::   WE: [_a] [STRING] - Kod miejsca położenia plików:
::                         'g' - Pliki globalne - wspólne w ramach wszystkich firm (*.dfk)
::                         'l' - Pliki lokalne - związane z konkretną firmą (*.txt) [DOMYŚLNIE].
::            [ARRAY]  - Tablica z trzema elementami:
::                         1. '1'
::                         2. Pełna ścieżka dostępu do pliku z rubrykami.
::                         3. Pełna ścieżka dostępu do pliku z polem SYS_MEMO.
::       [_b] [NUMBER] - Informacja o zapisanych plikach?
::                         0 - Nie [DOMYŚLNIE].
::                         1 - Tak.
::       [_c] [TABLE]  - Uchwyt eksportowanej tabeli [domyślnie: R]. Poporawność struktury NIE jest sprawdzana.
::   WY: '' lub przyczyna niepowodzenia
::  OLD: \r_exp/formuly.fml
::----------------------------------------------------------------------------------------------------------------------
:: Pełna analiza parametru _a dokonywana jest w \imex_cfg/rubryki.fml. Tutaj zadbajmy jedynie by nie był to ~~.
_loc:={? var_pres('_a')=type_of(~~) || 'l' || _a ?};
_info:=var_pres('_b')=type_of(0) & _b;
_R:={? var_pres('_c')=type_of(R) || _c || R ?};

_cfg:=exec('imex_cfg','rubryki',_loc);

_ndx:=_R.ndx_tmp(,,'LP',,);
_R.cntx_psh();
_R.index(_ndx);
_R.prefix();
{? ~_R.first()
|| _ret:='Eksportu nie można wykonać, dopóki rubryki płacowe nie zostaną zdefiniowane.'@;
   FUN.info(_ret)

|? _R.LP=0
|| _ret:='Eksportu nie można wykonać, dopóki w tabeli rubryk są pozycje z polem Numer równym zero.'@;
   FUN.info(_ret)

|| _ret:='';
:  Budowa formuł eksportujących
   _sexp:=obj_new(2);
   {! _nrf:=1 .. 2
   |? {? ~fexists(_cfg.fnl[_nrf])
      || ~~
      |? ~FUN.ask('Plik [%1] istnieje.\nCzy na pewno chcesz go nadpisać?'@ [_cfg.fnl[_nrf]])
      || _ret:='Rezygnacja'@
      |? ~ferase(_cfg.fnl[_nrf])
      || _ret:='Zapis do pliku [%1] nie jest możliwy.'@ [_cfg.fnl[_nrf]];
         FUN.info(_ret)
      ?};
      _ret=''
   |! _cfg.STRU.prefix(_nrf);
      {? _cfg.STRU.first()
      || _nrp:=0;
         _sexp[_nrf]:='_a.export(\'%1\',%2,\'%3\',\'%4\','[gsub(_cfg.fnl[_nrf],'\\','/'),$_cfg.echo,_cfg.sep,_cfg.opt];
         {!
         |? {? _cfg.STRU.IMEX
            || _nrp+=1;
               _sexp[_nrf]+=',\''+_cfg.STRU.AKR+'\',,'+$_nrp+','
            ?};
            _cfg.STRU.next()
         !};
         _sexp[_nrf]+=')'
      ?}
   !};
   {? _ret=''
   || _msg:='';
      _ok:=1;
      {! _nrf:=1 .. 2
      |! {? ($_sexp[_nrf])(_R)
         || _msg+='Plik [%1] został zapisany poprawnie.'@ [_cfg.fnl[_nrf]]+'\n'
         || _ok:=0;
            _msg+='Plik [%1] nie został zapisany poprawnie.'@ [_cfg.fnl[_nrf]]+'\n'
         ?}
      !};
      {? _ok
      || {? _info || FUN.info(_msg) ?}
      || _ret:='Eksport nie został wykonany.'@;
         FUN.info(_ret)
      ?}
   ?}

?};
_R.cntx_pop();
_R.ndx_drop(_ndx);

echo();

_ret


\_r_export2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.41]
:: OPIS: Formuła eksportująca tabelę rubryk w formacie wersji 2 (XML).
::   WE: [_a] [STRING] - Kod miejsca położenia plików:
::                         'g' - Pliki globalne - wspólne w ramach wszystkich firm (*.dfk)
::                         'l' - Pliki lokalne - związane z konkretną firmą (*.txt) [DOMYŚLNIE].
::            [ARRAY]  - Tablica z dwoma elementami:
::                         1. '2'
::                         2. Pełna ścieżka dostępu do pliku z rubrykami.
::       [_b] [NUMBER] - Informacja o zapisanych plikach?
::                         0 - Nie [DOMYŚLNIE].
::                         1 - Tak.
::       [_c] [TABLE]  - Uchwyt eksportowanej tabeli [domyślnie: R]. Poporawność struktury NIE jest sprawdzana.
::   WY: '' lub przyczyna niepowodzenia
::  OLD: \r_exp/formuly.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100 & obj_len(_a)=2 & _a[1]='2'
|| _fnl:=_a[2]
|| {? var_pres('_a')<>type_of('')
   || _a:='l'
   ?};
   _base:='rubryki_placowe';
   _fn:={? _a='g' || 'std_%1.dfg'[_base] || '%1.txt'[_base] ?};
   _ds:=exec('sep','#file',1);
   _fnl:=pth_dir(_fn)+_ds+_fn
?};

_info:=var_pres('_b')=type_of(0) & _b;
_R:={? var_pres('_c')=type_of(R) || _c || R ?};

_ndx:=_R.ndx_tmp(,,'LP',,);
_R.cntx_psh();
_R.index(_ndx);
_R.prefix();
{? ~_R.first()
|| _ret:='Eksportu nie można wykonać, dopóki rubryki płacowe nie zostaną zdefiniowane.'@;
   FUN.info(_ret)

|? _R.LP=0
|| _ret:='Eksportu nie można wykonać, dopóki w tabeli rubryk są pozycje z polem Numer równym zero.'@;
   FUN.info(_ret)

|? _ret:='';
   {? ~fexists(_fnl)
   || ~~
   |? ~FUN.ask('Plik [%1] istnieje.\nCzy na pewno chcesz go nadpisać?'@ [_fnl])
   || _ret:='Rezygnacja'@
   |? ~ferase(_fnl)
   || _ret:='Zapis do pliku [%1] nie jest możliwy.'@ [_fnl];
      FUN.info(_ret)
   ?};
   _ret=''
|| exec('xml_t_decl','#xml_t');
   _xml:=obj_new(@.CLASS.XML_T);
   _root:=_xml.addElement('dane');
      _xml.addAttr('opis','Definicja rubryk płacowych');

   {!
   |? echo('%1 - %2 ...'[$_R.RN,_R.RT]);
      _rub:=_xml.addElement('R',,_root);

::       Analiza struktury tabeli dla każdego eksportowanego rekordu nie jest najbardziej optymalna, ale kod czyni
::       bardziej przejrzystym. Alternatywą byłoby dynamiczne przygotowanie formuły przed pętlą po wszystkich
::       rekordach i wywołanie jej w pętli. Jednak profilowanie oby podejść wskazało jedynie nieznaczną przewagę czasową
::       tego drugiego podejścia. Zwyciężyła więc przejrzystość kodu (zwłaszcza, że eksport rubryk nie jest czasowo
::       newralgiczną funkcjonalnością).
::       Analizowana jest struktura tabeli R - nawet, jeżeli formuła zostanie wywołana z inną tabela do eksportu.
::       Zapewni to odpowiednią kolejność pól w pliku.
         {! _lp:=1 .. R.fld_num()
         |! _ok:=0;
            _acr:=R.fld_acr(_lp);
            _vp:=var_pres(_acr,_R,'diff_blob');
            {? _vp=var_pres(_acr,R,'diff_blob')
            || {? _acr=_R.idadd_acr() | _acr=_R.idput_acr() | _acr='LP' | _acr='SYSTEM'
               || 'Niektórych pól nie eksportujemy'
               |? _vp=22 | _vp=27
::                INTEGER lub STRING
               || _ok+=_xml.addElement(_acr,($('_a.%1'[_acr]))(_R),_rub)>0
               |? _vp=36
::                SYS_MEMO
               || _ok+=_xml.addElement(_acr,_R.memo_txt(0,1,_acr),_rub)>0
               ?};
               {? _ok
               || {? _acr<>'RN'
                  || _xml.addAttr('rn',_R.RN)
                  ?}
               ?}
            ?}
         !};

      _R.next()
   !};

   _xml.write(_fnl);
   obj_del(_xml);
   &_xml
?};
_R.cntx_pop();
_R.ndx_drop(_ndx);

_ret


\export
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Formuła eksportująca rubryki płacowe.
::   WE: [_a] [STRING] - Kod miejsca położenia plików [domyślnie: 'l2']:
::                      'gx' - Pliki globalne - wspólne w ramach wszystkich firm (*.dfk)
::                      'lx' - Pliki lokalne - związane z konkretną firmą (*.txt)
::                      gdzie x oznacza numer wersji piku z danymi.
::                         1 - Pliki rubryki.dfg + r_memo.dfg (rubryki.txt + r_memo.txt) w formacie CSV.
::                         2 - Plik std_rubryki_placowe.dfg (rubryki_placowe.txt) w formacie XML.
::            [ARRAY]  - Tablica z pełnymi ścieżkami dostępu do importowanych plików. Zawartość i rozmiar tablicy
::                       określa wersję tworzonego(-ch) pliku(-ów).
::   WY: '' lub przyczyna niepowodzenia
::----------------------------------------------------------------------------------------------------------------------
_ret:='Nieprawidłowy typ/wartość parametru wejściowego'@;
{? _<1
|| _a:='l2'
?};
{? var_pres('_a')=type_of('') & (+_a=1 | +_a=2) & (1+_a='g' | 1+_a='l')
|| _loc:=_a+{? +_a=1 || '2' || '' ?};
   {? _loc+1='1'
   || _ret:=exec('_r_export1','rubryki',1+_loc)
   |? _loc+1='2'
   || _ret:=exec('_r_export2','rubryki',1+_loc)
   ?}
|? var_pres('_a')>100 & _a[1]='1' & obj_len(_a)=3
|| _ret:=exec('_r_export1','rubryki',_a)
|? var_pres('_a')>100 & _a[1]='2' & obj_len(_a)=2
|| _ret:=exec('_r_export2','rubryki',_a)
?};
_ret


\_r_import1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Formuła importująca rubryki płacowe z plików w wersji 1.
::   WE: [_a] [STRING] - Kod miejsca położenia plików [domyślnie: 'l']:
::                      'g' - Pliki globalne - wspólne w ramach wszystkich firm (*.dfk)
::                      'l' - Pliki lokalne - związane z konkretną firmą (*.txt)
::            [ARRAY]  - Tablica z trzema elementami:
::                         1. '1'
::                         2. Pełna ścieżka dostępu do pliku z rubrykami.
::                         3. Pełna ścieżka dostępu do pliku z polem SYS_MEMO.
::   WY: Tablica elementów nazwanych lub komunikat z przyczyną niepowodzenia.
::----------------------------------------------------------------------------------------------------------------------
:: Pełna analiza parametru _a dokonywana jest w \imex_cfg/rubryki.fml. Tutaj zadbajmy jedynie by nie był to ~~.
_loc:={? var_pres('_a')=type_of(~~) || 'l' || _a ?};

_cfg:=exec('imex_cfg','rubryki',_loc);

{? ~fexists(_cfg.fnl[1])
|| return('Brak dostępu do pliku [%1].'@ [_cfg.fnl[1]])
?};

_jfn2:=fexists(_cfg.fnl[2]);
{? ~_jfn2 & ~FUN.ask('Brak dostępu do pliku z dodatkowymi polami [%1].\nKontynuować?'@ [_cfg.fnl[2]])
|| return('Brak dostępu do pliku [%1].'@ [_cfg.fnl[2]])
?};

_STRU:=obj_new(2);

_flds:=',';
_stab:=obj_new(2);
_simp:=obj_new(2);
_set:='';
{! _nrf:=1 .. 2
|! _cfg.STRU.prefix(_nrf);
   {? _cfg.STRU.first()
   || _nrp:=0;
      _stab[_nrf]:='tab_tmp(1';
      _simp[_nrf]:='_a.import(\'%1\',1,%2,\'%3\',\'%4\',' [gsub(_cfg.fnl[_nrf],'\\','/'),$_cfg.echo,_cfg.sep,_cfg.opt];
      {!
      |? _akr:=_cfg.STRU.AKR;
         _typ:=_cfg.STRU.TYP;

         _fld:=',\''+_akr+'\',\''+_typ+'\',\''+_cfg.STRU.NAZWA+'\'';
         {? _flds*',%1,'[_akr]=0
         || _flds+='%1,'[_akr];
            _stab[1]+=_fld
         ?};
         {? _nrf=2
         || _stab[2]+=_fld;
            _set+=
               {? _typ='SYS_MEMO'
               || '_fh:=_b.memo_get(\'r\',\'%1\',0); '
                  '{? _fh.is_open() '
                  '|| _a.memo_put(_fh,\'%1\'); '
                     '_fh.fclose() '
                  '?}; '
                  'obj_del(_fh); '[_akr]
               || '_a.%1:=_b.%1; '[_akr]
               ?}
         ?};

         {? _cfg.STRU.IMEX
         || _nrp+=1;
            _simp[_nrf]+=',\''+_akr+'\',,'+$_nrp+','
         ?};

         _cfg.STRU.next()
      !}
   ?}
!};
_ndx:=obj_new('RN','LP');
{! _nrf:=1 .. 2
|! _stab[_nrf]+=')';
   _STRU[_nrf]:=($_stab[_nrf])();
   {? _nrf=1
   || _ndx.RN:=_STRU[1].index('?');
      _ndx.LP:=_STRU[1].ndx_tmp(,,'LP',,)
   ?};
   _simp[_nrf]+=')';
   {? (_nrf=1 | _jfn2) & ($_simp[_nrf])(_STRU[_nrf])=0
   || return('Import pliku [%1] nie zakończył się sukcesem.'[_cfg.fnl[_nrf]])
   ?}
!};
{? _jfn2
|| _set+='1';
   {? _STRU[2].first()
   || {!
      |? {? _STRU[1].find_key(_STRU[2].RN)
         || ($_set)(_STRU[1],_STRU[2])
         ?};
         _STRU[2].next()
      !}
   ?}
?};

_SRC:=obj_new('fnl','TAB','ndx');
_SRC.fnl:=obj_new(1+_jfn2);
{! _lp:=1 .. obj_len(_SRC.fnl)
|! _SRC.fnl[_lp]:=_cfg.fnl[_lp]
!};
_SRC.TAB:=_STRU[1];
_SRC.ndx:=_ndx;

{? _SRC.TAB.first()
:: Bieżący indeks po RN - możemy uzupełnić LP.
|| {!
   |? _SRC.TAB.LP:=#_SRC.TAB.ref();
      _SRC.TAB.put();
      _SRC.TAB.next()
   !}
?};

_SRC


\_r_import2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Formuła importująca rubryki płacowe z pliku w wersji 2.
::   WE: [_a] [STRING] - Kod miejsca położenia pliku [domyślnie: 'l']:
::                         'g' - Pliki globalne - wspólne w ramach wszystkich firm (*.dfk)
::                         'l' - Pliki lokalne - związane z konkretną firmą (*.txt)
::            [ARRAY]  - Tablica z dwoma elementami:
::                         1. '2'
::                         2. Pełna ścieżka dostępu do pliku z rubrykami.
::   WY: Tablica elementów nazwanych lub komunikat z przyczyną niepowodzenia.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100 & obj_len(_a)=2 & _a[1]='2'
|| _fnl:=_a[2]
|| {? var_pres('_a')<>type_of('')
   || _a:='l'
   ?};
   _base:='rubryki_placowe';
   _fn:={? _a='g' || 'std_%1.dfg'[_base] || '%1.txt'[_base] ?};
   _ds:=exec('sep','#file',1);
   _fnl:=pth_dir(_fn)+_ds+_fn
?};

{? ~fexists(_fnl)
|| return('Brak dostępu do pliku [%1].'@[_fnl])
?};

_fh:=fopen(_fnl,'ur',0,0,1,1);
{? ~_fh.is_open()
|| return('Otwarcie pliku [%1] nie powiódło się.'@[_fnl])
|? _XML:=xml_tparse(_fh);
   type_of(_XML)=type_of(~~)
|| return('Niepoprawny format pliku [%1].'@[_fnl])
?};

_SRC:=obj_new('fnl','TAB','ndx');

_SRC.fnl:=obj_new(1);
_SRC.fnl[1]:=_fnl;

_SRC.TAB:=tab_tmp(1
   ,'RN','INTEGER','Kod'
   ,'RT','STRING[%1]'[$MS.fld_len(R,'RT')],'Nazwa'
   ,'RK','STRING[%1]'[$MS.fld_len(R,'RK')],'Klasa'
   ,'RSKZ','INTEGER','Karta zarobkowa'
   ,'RSKP','INTEGER','Karta podatkowa'
   ,'RSKU','INTEGER','Karta ubezpiecz.'
   ,'KDR','STRING[%1]'[$MS.fld_len(R,'KDR')],'Wydruk - rachunek'
   ,'URL','STRING[%1]'[$MS.fld_len(R,'URL')],'Do urlopu'
   ,'CHO','STRING[%1]'[$MS.fld_len(R,'CHO')],'Do zasiłku'
   ,'ZUS','STRING[%1]'[$MS.fld_len(R,'ZUS')],'Do ubezp.'
   ,'POD','STRING[%1]'[$MS.fld_len(R,'POD')],'Do podatku'
   ,'UBZ','STRING[%1]'[$MS.fld_len(R,'UBZ')],'Do ub. zdrow.'
   ,'EKW','STRING[%1]'[$MS.fld_len(R,'EKW')],'Do ekwiwalentu'
   ,'OPIS','STRING[%1]'[$MS.fld_len(R,'OPIS')],'Komentarz'
   ,'KDL','STRING[%1]'[$MS.fld_len(R,'KDL')],'Wydruk - lista'
   ,'KDZ','STRING[%1]'[$MS.fld_len(R,'KDZ')],'Wydruk - zbiorówka'
   ,'NOTA','SYS_MEMO','Opis'
:: Pole LP nie jest importowane.
   ,'LP','INTEGER','Numer'
);

_SRC.ndx:=obj_new('RN','LP');
_SRC.ndx.RN:=_SRC.TAB.index('?');
_SRC.ndx.LP:=_SRC.TAB.ndx_tmp(,,'LP',,);

_XML.prefix(1);
{? _XML.first()
|| _BVAL:=obj_new('TAB','add');
   _BVAL.TAB:=tab_tmp(1
      ,'ACR','STRING[8]','Akronim'
      ,'TYPE','STRING[9]','Typ'
      ,'BVAL','BLOBRAW','Wartość - plik'
      ,'VAL','STRING[255]','Wartość - tekst'
   );
   _BVAL.add:=".TAB.blank(); .TAB.ACR:=_a; .TAB.TYPE:=_b; .TAB.BVAL:=_c; .TAB.VAL:=_d; .TAB.add()";

   {!
   |? {? _XML.TYPE='E' & _XML.NAME='R'
      || exec('_r_import2_r','rubryki',_XML,#_XML.ref(),_SRC.TAB,_BVAL)
      ?};
      _XML.next()
   !}
?};

_fh.fclose();
obj_del(_fh);
&_fh;

_SRC


\_r_import2_r
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [22.26]
:: OPIS: Właściwa formuła importująca elementy typu R w ramach importu składników płacowych w wersji 2.
::   WE: _a [OBJECT] - Uchwyt obiektu klasy XML_T.
::       _b [NUMBER] - Numer rekordu rodzica w strukturze XML.
::       _c [TABLE]  - Uchwyt tabeli tymczasowej, w której zapisywane będą importowane rekordy.
::       _d [ARRAY]  - Tablica elementów nazzwanych do obsługi pól typu BLOB* i SYS_MEMO.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_XML:=_a;
_parentXML:=_b;
_R:=_c;
_BVAL:=_d;

_XML.cntx_psh();
_XML.prefix(_parentXML);
{? _XML.first()
|| {? _BVAL.TAB.first()
::    Import może być wykonywany w transakcji, w której metoda erase() nie jest dostępna.
   || {!
      |? _BVAL.TAB.del()
      !}
   ?};
   _lp:=_R.size()+1;
   _R.blank();
   _R.LP:=_lp;
   {!
   |? {? _XML.TYPE='E' & (_vp:=var_pres(_XML.NAME,_R))>0
      || {? _vp=22
::          INTEGER
         || ($('_a.%1:=_b'[_XML.NAME]))(_R,#_XML.VAL)
         |? _vp=27
::          STRING
         || ($('_a.%1:=_b'[_XML.NAME]))(_R,_XML.VAL)
         |? _vp=36 & (_XML.BVAL<>null() | _XML.VAL<>'')
         || _BVAL.add(_XML.NAME,'SYS_MEMO',_XML.BVAL,_XML.VAL)
         ?}
      ?};
      _XML.next()
   !};
   _R.add();
   {? _BVAL.TAB.first()
   || {!
      |? {? _BVAL.TAB.TYPE='SYS_MEMO'
         || {? _BVAL.TAB.BVAL<>null()
            || _fh:=fopen(_BVAL.TAB.BVAL,'ur',0,0,1);
               {? _fh.is_open()
               || _R.memo_put(_fh,_BVAL.TAB.ACR);
                  _fh.fclose()
               ?};
               obj_del(_fh);
               &_fh
            || _R.memo_set(_BVAL.TAB.VAL,_BVAL.TAB.ACR);
               _R.memo_put(,_BVAL.TAB.ACR)
            ?}
         ?};
         _BVAL.TAB.next()
      !}
   ?}
?};
_XML.cntx_pop();
~~


\import
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.41]
:: OPIS: Formuła importująca tabelę rubryk.
::   WE: [_a] [STRING] - Kod miejsca położenia plików [domyślnie: 'l2']:
::                      'gx' - Pliki globalne - wspólne w ramach wszystkich firm (*.dfk)
::                      'lx' - Pliki lokalne - związane z konkretną firmą (*.txt)
::                      gdzie x oznacza numer wersji piku z danymi.
::                         1 - Pliki rubryki.dfg + r_memo.dfg (rubryki.txt + r_memo.txt) w formacie CSV.
::                         2 - Plik std_rubryki_placowe.dfg (rubryki_placowe.txt) w formacie XML.
::            [ARRAY]  - Tablica z pełnymi ścieżkami dostępu do importowanych plików. Zawartość i rozmiar tablicy
::                       określa wersję pliku(-ów) do importu.
::        _b  [STRING] - Napis z listą (oddzieloną przecinkami) rubryk do zaimportowania (może być *, która oznacza
::                       wszystkie rubryki). Jeżeli tabela R jest pusta - lista nie ma znaczenia (również może być
::                       pusta) - zaimportowane zostaną wszystkie rubryki (start zerowy systemu). Parametr obowiązkowy.
::       [_c] [NUMBER] - Aktualizacja [domyślnie:0]
::                       0 - Nie. Jeżeli rubryka z listy zostanie znaleziona w tabeli rubryk, i jej definicja jest inna
::                           niż w importowanym pliku, to jest to traktowane jako konflikt i zgłaszane jako błąd.
::                       1 - Tak. Jeżeli rubryka z listy zostanie znaleziona w tabeli rubryk, to jej definicja zostanie
::                           zaktualizowana definicją z importowanego pliku.
::                       2 - Tak, z potwierdzeniem. Aktualizacja następuje po potwierdzeniu przez operatora.
::       [_d] [NUMBER] - Poziom wyświetlania komunikatów [domyślnie:1]
::                       0 - Brak komunikatów.
::                       1 - Informacja podsumowująca.
::                       2 - Informacja o zaimportowanych plikach (ścieżki).
::       [_e] [STRING] - Lista wykluczeń komunikatów do wyświetlania. Elementami listy są kody komunikatów, które
::                       będą pomijane przy wyświetlaniu raportu. Dostępne kody:
::                            wrng_par_val
::                            mis_rub_def
::                            nreq_rub_akt
::                            req_rub_akt
::                            nakt_rub_uniq
::                            akt_rub_lst
::                            nakt_rub_tech
::                            nakt_rub_oper
::                            order
::   WY: '' lub przyczyna niepowodzenia
::  OLD: \r_imp/formuly.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(~~)
|| _a:='l2'
?};
{? var_pres('_a')=type_of('') & (+_a=1 | +_a=2) & (1+_a='g' | 1+_a='l')
|| _loc:=_a+{? +_a=1 || '2' || '' ?};
   {? _loc+1='1'
   || _imp:=exec('_r_import1','rubryki',1+_loc)
   |? _loc+1='2'
   || _imp:=exec('_r_import2','rubryki',1+_loc)
   ?}
|? var_pres('_a')>100 & _a[1]='1' & obj_len(_a)=3
|| _imp:=exec('_r_import1','rubryki',_a)
|? var_pres('_a')>100 & _a[1]='2' & obj_len(_a)=2
|| _imp:=exec('_r_import2','rubryki',_a)
?};
{? var_pres('_imp')<0
|| _imp:='Nieprawidłowe wskazanie źródła importu.'@
?};
{? var_pres('_b')=type_of('')
|| _lista:=_b
|| return('Brak listy rubryk do zaimportowania.'@)
?};
_aktualizacja:={? var_pres('_c')=type_of(0) & 0<=_c & _c<=2 || _c ?};
_info:={? var_pres('_d')=type_of(0) ||  _d || 1 ?};

_excl:={? var_pres('_e')=type_of('') || _e || '' ?};
:: Funkcja check sprawdza, czy komunikat podanym kodzie (_a) może być wyświetlony.
:: Dokładniej: czy podany kod (_a) NIE znajduje się na liście wykluczeń.
{? _excl=''
|| _check:="1"
|| {? 1+_excl<>','
   || _excl:=','+_excl
   ?};
   {? _excl+1<>','
   || _excl:=_excl+','
   ?};
   _check:=$("'"+_excl+"'*(','+_a+',')=0")
?};

{? type_of(_imp)=type_of('')
|| {? _info || FUN.info(_imp) ?};
   return(_imp)
?};
_SRC:=_imp.TAB;
_ndx:=_imp.ndx;
_set:='';
_setm:='';
_update:='_zmiana:=\'\'; ';

_std:=',%1,'[exec('_std_kod','rubryki',1)];

:: Zakładamy, że importowane są wyłącznie pola typu INTEGER, STRING i SYS_MEMO.
{! _lp:=1 .. _SRC.fld_num()
|! _akr:=_SRC.fld_acr(_lp);
   {? _akr<>'LP'
::    Pole LP mimo występowania w strukturze nie podlega porównywaniu, przepisywaniu, ...
   || _vp:=var_pres(_akr,_SRC,'diff_blob');
      {? _vp=36
::       SYS_MEMO
      || _setm+=
            '_fh:=_b.memo_get(\'r\',\'%1\',0); '
            '{? _fh.is_open() '
            '|| _a.memo_put(_fh,\'%1\'); '
            '   _fh.fclose() '
            '?}; '
            'obj_del(_fh); '
            '&_fh; '[_akr];
         _update+=
            '_fhd:=_a.memo_get(\'r\',\'%1\',0); '
            '_fhs:=_b.memo_get(\'r\',\'%1\',0); '
            '{? hash(_fhd)<>hash(_fhs) || _zmiana+=\'%1,\' ?}; '
            'obj_del(_fhs); &_fhs; obj_del(_fhd); &_fhd; '[_akr]
      || _set+='_a.%1:=_b.%1; '[_akr];
         _update+='{? _a.%1<>_b.%1 || _zmiana+=\'%1,\' ?}; '[_akr]
      ?}
   ?}
!};
_set+=' 1';
_setm+=' 1';
_update+=' _zmiana';

{? _SRC.size()<2
:  Na podstawie jednego rekordu nie ustalimy miejsca obliczeń.
|| _ret:='Dane wejściowe nie zawierają poprawnych informacji o rubrykach.'@;
   {? _info || FUN.info(_ret) ?};
   return(_ret)
?};

:: Zacznijmy od uporządkowania LP.
_ok:=1;
R.cntx_psh();
R.prefix();
R.f_set('LP');
{? R.f_first()
|| _lp:=1;
   {!
   |? {? R.LP<>_lp
      || R.LP:=_lp;
         _ok:=R.put()
      ?};
      _lp+=1;
      _ok & R.f_next()
   !}
?};
R.f_clear();
R.cntx_pop();
{? ~_ok
|| _ret:='Uporządkowanie numerów składników płacowych nie powiodło się. Import nie jest możliwy.';
   {? _info || FUN.info(_ret) ?};
   return(_ret)
?};

_ret:='';
R.cntx_psh();
R.index('RUBKOD');
R.prefix();

:Do testów można użyć tabeli tymczasowej, poza przenumerowaniem LP powinno dobrze symulować tabelę R.
:_DEST:=sql('select * from R where RN<10000 order by RN');
_DEST:=R;

{? ~_DEST.first()
:  Start zerowy - tabela rubryk jest pusta - wczytujemy wszystkie.
|| _SRC.index(_ndx.LP);
   {? _SRC.first()
   || {!
      |? _DEST.blank();
         _DEST.LP:=_DEST.size()+1;
         ($_set)(_DEST,_SRC);
         _DEST.add();
         ($_setm)(_DEST,_SRC);
         _SRC.next()
      !}
   ?}

:  Aktualizacja tabeli rubryk.
|| {? _lista='*'
   || _SRC.cntx_psh();
      _SRC.index(_ndx.LP);
      _SRC.prefix();
:     Tabela _SRC jest tymczasowa - istnienie rekordów zostało potwierdzone wyżej.
      _trub:=obj_new(_SRC.size());
      _SRC.first();
      _nrr:=0;
      {! |? _trub[_nrr+=1]:=$_SRC.RN; _SRC.next() !};
      _SRC.cntx_pop()
   || _trub:=spli_str(_lista,',')
   ?};
   _dl:=obj_len(_trub);
   {? _dl
   || _err:=0;
      _ikona:=obj_new('ok','err');
      _ikona.ok:=13;
      _ikona.err:='xwin16.png:3';
      exec('JCQ_decl','#message');
      _kri:=obj_new(@.CLASS.JCQ);
      _kri.init(120,,{? _aktualizacja || 'Aktualizacja rubryk płacowych'@ || 'Import rubryk płacowych'@ ?});
      {! _nrr:=1 .. _dl
:        Pętla po wszystkich rubrykach z listy.
      |! _rub:=#_trub[_nrr];
         {? _rub=0 & _trub[_nrr]<>'0'
         || {? _check('wrng_par_val')
            || _err+=1;
               _h1:=_kri.set_root('Błędy listy rubryk'@);
               _h2:=_kri.set_root('Niepoprawne wartości parametrów listy'@);
               _kri.add('Element nr %1 [%2]'@ [$_nrr,_trub[_nrr]],_ikona.err);
               _kri.chngroot(_h2,_h1)
            ?}

         |? ~_SRC.find_key(_rub)
:           Na liście mamy rubrykę, której nie ma w importowanym pliku.
         || {? _check('miss_rub_def')
            || _err+=1;
               _h1:=_kri.set_root('Błędy listy rubryk'@);
               _h2:=_kri.set_root('Brak definicji rubryk w importowanym pliku.'@);
               _kri.add('Element nr %1 [%2]'@ [$_nrr,_trub[_nrr]],_ikona.err);
               _kri.chngroot(_h2,_h1)
            ?}

         |? _DEST.find_key(_rub)
:           Rubryka z listy występuje już w tabeli _DEST - dalsze działanie zależy od tego, czy jest to aktualizacja,
:           czy import.
         || {? _check('order')
            || _DEST.cntx_psh();
               _SRC.cntx_psh();
               _SRC.index(_ndx.LP);
               _blp_dest:=_DEST.LP;
               _kolejnosc:='';
               {!
               |? {? _SRC.next()
::                   Sprawdzam kolejną (wg. LP) rubrykę spośród importowanych.
                  || {? _DEST.find_key(_SRC.RN)
::                      Jeżeli istnieje, to mam drugi punkt odniesienia. Jego LP powinno być większe niż LP pierwszego
::                      punktu. W każdym razie nie musimy dalej sprawdzać.
                     || {? _DEST.LP<_blp_dest
                        || _kolejnosc+=
                              'W importowanym pliku rubryka o kodzie %1  występuje PRZED rubryką o kodzie %2, '
                              'a w danych występuje PO.'@[$_rub,$_SRC.RN]
                        ?};
                        0
::                      Nie znaleziono tej rubryki - spróbujmy szukać dalej.
                     || 1
                     ?}

::                   Jeżeli nie znaleźliśmy żadnego następnika (brak jest punktów odniesienia, to nie jesteśmy w stanie
::                   stwierdzić błędów w kolejności (najprawdopodobniej wszystko jest OK).
                  ?}
               !};
               _SRC.cntx_pop();
               _DEST.cntx_pop();
               {? +_kolejnosc
::                A może staliśmy na ostatnim rekordzie ...
               || _kri.set_root('Różnice w kolejności obliczeń'@);
                  _kri.add(_kolejnosc)
               ?}
            ?};

            _zmiana:=($_update)(_DEST,_SRC)-1;
:           W _zmiana znajdują się akronimy pól, których wartości są inne w pliku i inne w tabeli.
            {? _zmiana='' & _aktualizacja & _check('nreq_rub_akt')
            || _kri.set_root('Rubryki niewymagające aktualizacji'@);
               _kri.add(_trub[_nrr]+' - '+_DEST.RT,_ikona.ok)

            |? _zmiana<>'' & ~_aktualizacja
:              Są różnice, ale my importujemy a nie aktualizujemy. Różnice są tylko sygnalizowane.
            || {? _check('req_rub_akt')
               || _err+=1;
                  _kri.set_root('Rubryki wymagające aktualizacji'@);
                  _kri.sect_beg(_trub[_nrr]+' - '+_DEST.RT,_ikona.err);
                  _kri.add('Akronimy niezgodnych pól: %1'@ [_zmiana])
               ?}

            |? _zmiana<>'' & _aktualizacja
:              Są różnice i pracujemy w trybie aktualizacji.
            || {? _aktualizacja=1 |
                  FUN.ask('Rubryka płacowa\n%1 - %2\nnie jest standardowa.\n(%3)\nAktualizować?'@
                     [_trub[_nrr],_DEST.RT,_zmiana]
                  )
               || ($_set)(_DEST,_SRC);
                  _uniq:=__CHK.index(_DEST,1,1);
                  {? _uniq<>'' & _check('nakt_rub_uniq')
                  || _err+=1;
                     _h1:=_kri.set_root('Rubryki, które nie zostały zaaktualizowane'@);
                     _h2:=_kri.set_root('- z powodu braku unikalności rekordu'@);
                     _kri.sect_beg(_trub[_nrr]+' - '+_DEST.RT,_ikona.err);
                     _kri.add('Indeks: %1'@ [_uniq]);
                     _kri.add('Akronimy niezgodnych pól: %1'@ [_zmiana]);
                     _kri.chngroot(_h2,_h1)
                  |? _DEST.put()
                  || ($_setm)(_DEST,_SRC);
                     {? _check('akt_rub_lst')
                     || _kri.set_root('Rubryki zaktualizowane'@);
                        _kri.sect_beg(_trub[_nrr]+' - '+_DEST.RT,_ikona.ok);
                        _kri.add('Akronimy zmienionych pól: %1'@ [_zmiana])
                     ?}
                  || {? _check('nakt_rub_tech')
                     || _err+=1;
                        _h1:=_kri.set_root('Rubryki, które nie zostały zaaktualizowane'@);
                        _h2:=_kri.set_root('- z przyczyn technicznych'@);
                        _kri.sect_beg(_trub[_nrr]+' - '+_DEST.RT,_ikona.err);
                        _kri.add('Akronimy niezgodnych pól: %1'@ [_zmiana]);
                        _kri.chngroot(_h2,_h1)
                     ?}
                  ?}
               || {? _check('nakt_rub_oper')
                  || _err+=1;
                     _h1:=_kri.set_root('Rubryki, które nie zostały zaaktualizowane'@);
                     _h2:=_kri.set_root('- z powodu rezygnacji operatora'@);
                     _kri.sect_beg(_trub[_nrr]+' - '+_DEST.RT,_ikona.err);
                     _kri.add('Akronimy niezgodnych pól: %1'@ [_zmiana]);
                     _kri.chngroot(_h2,_h1)
                  ?}
               ?}
            ?}

:           Importowanej rubryki nie ma w tabeli docelowej. Zarówno dla importu jak i aktualizacji działanie jest takie
:           samo - rubryka ma zostać dodana.
         || _SRC.index(_ndx.LP);

            _SRC.cntx_psh();
:           Flaga: konieczne przenumerowanie?
            _renum:=0;
            _lp:=0;
:           Szukamy punktu odniesienia - rubryki, która jest zarówno w _SRC jak i w _DEST oraz występuje po "bieżącej"
:           (w kolejności obliczeń).
            {? _SRC.next()
:              Dodawana rubryka nie jest ostatnia (w kolejności obliczeń).
            || {!
               |? {? _DEST.find_key(_SRC.RN) & _DEST.LP
:                    Znaleźliśmy wspólną rubrykę. Nowa, ponieważ ma być dołączona przed nią - otrzyma jej LP,
:                    a wszystkie następne w _DEST zostaną przenumerowane.
:                    Druga część warunku eliminuje rubryki, które nie są jeszcze wypozycjonowane - mają LP=0.
:                    Taka sytuacja ma miejsce dla R po synchronizacji z RG - rubryka globalna dodawana do tabeli
:                    lokalnej otrzymuje LP=0.
                  || _renum:=1;
                     _lp:=_DEST.LP;
                     0

                  |? _SRC.next()
:                    Jeszcze nie znaleźliśmy punktu odniesienia - ale nie poddajemy się.
                  || 1

:                    Doszliśmy do końca _SRC. Żadna z rubryk nie występuje w _DEST, a więc wszystkie są nowe i zostały
:                    dodane na końcu.
                  || _lp:=_DEST.size()+1;
                     0
                  ?}
               !}

:              Nie ma następnej rubryki w _SRC? Czyli dodajemy na końcu.
            || _lp:=_DEST.size()+1
            ?};
            _SRC.cntx_pop();

            _DEST.blank();
            _DEST.LP:=_lp;
            ($_set)(_DEST,_SRC);
            _DEST.SYSTEM:={? _DEST.RN>=7000 | _std*',%1,'[$_DEST.RN] || 'T' || 'N' ?};
            _uniq:=__CHK.index(_DEST,0,1);
            {? _uniq<>'' & _check('nakt_rub_uniq')
            || _err+=1;
               _h1:=_kri.set_root('Rubryki, które nie zostały dodane'@);
               _h2:=_kri.set_root('- z powodu braku unikalności rekordu'@);
               _kri.sect_beg(_trub[_nrr]+' - '+_DEST.RT,_ikona.err);
               _kri.add('Indeks: %1'@ [_uniq]);
               _kri.chngroot(_h2,_h1)
            |? _DEST.add()
            || ($_setm)(_DEST,_SRC);
               {? _DEST=R & _renum || exec('lp_add_a','rubryki') ?}
            || {? _check('nakt_rub_tech')
               || _err+=1;
                  _h1:=_kri.set_root('Rubryki, które nie zostały dodane'@);
                  _h2:=_kri.set_root('- z przyczyn technicznych'@);
                  _kri.add(_trub[_nrr]+' - '+_DEST.RT,_ikona.err);
                  _kri.chngroot(_h2,_h1)
               ?}
            ?};

            _SRC.index(_ndx.RN)
         ?}
      !};

      {? _info
      || _kri.select()
      ?};
      obj_del(_kri); &_kri;
      {? _err
      || _ret:='Aktualizacja zakończona niepowodzeniem.'@;
         {? _info || FUN.info(_ret) ?}
      ?}
   || _ret:='Niepoprawna lista rubryk do zaimportowania.'@;
      {? _info || FUN.info(_ret) ?}
   ?}
?};

R.cntx_pop();

:Jeżeli zdefiniowany jest obiekt __RUB, to należy go przeładować.
{? var_pres('RUB',@.CLASS)>0 & var_pres('__RUB')=type_of(@.CLASS.RUB)
|| __RUB.fill()
?};

{? _info>1 & _ret=''
|| _msg:='';
   _size:=obj_len(_imp.fnl);
   {? _size=1
   || _msg+='Zaimportowany plik:'@
   || _msg+='Lista zaimportowanych plików:'@
   ?};
   {! _lp:=1 .. obj_len(_imp.fnl)
   |! _msg+='\n'+_imp.fnl[_lp]
   !};
   FUN.info(_msg)
?};

echo();

_ret


\r_validate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła sprawdzająca merytoryczną poprawność słownika rubryk płacowych.
::   WE: _a - Komunikować błędy?
::             1 - Tak [domyślnie].
::             0 - Nie.
::   WY: Opis błędu parametryzacji, lub
::       '' - jeżeli parametryzacja jest poprawna.
::----------------------------------------------------------------------------------------------------------------------
_msg:={? var_pres('_a')=type_of(0) || _a || 1 ?};

R.cntx_psh();
R.index('RUBLP');
R.prefix();
{? ~R.first()
|| _err:='Brak definicji rubryk płacowych.'@
|? R.LP=0
|| _err:='Istnieją rubryki bez określonej kolejności obliczania.'@
|? R.last() & 'TG'*R.RK=0
|| _err:='Ostatnia rubryka (w kolejności obliczeń) powinna być klasy T lub G.'@
|| _err:=''
?};
R.cntx_pop();
{? _err<>'' & _msg
|| FUN.info(
      'Słownik rubryk płacowych nie jest sparametryzowany poprawnie.'@+'\n'+
      _err+'\n'+
      'Tworzenie wydruków list płac, zestawień zbiorczych, itp. nie będzie możliwe.\n'
      'Należy uzupełnić lub poprawić definicje rubryk płacowych.'@
   )
?};
_err


\slownik
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła przypisuje wartość zmiennej VAR.KLASA, używanej do prefiksowania słownika składników płacowych.
::       Formuła wykorzystywana jako formuła na wzorzec.
::   WE: _a - Klasa składnika płacowego.
::   WY:
::  OLD: \_klasa_s/war_tech.fml
::  OLD: \KLASA_N/war_tech.fml
::  OLD: \KLASA_R/war_tech.fml
::  OLD: \KLASA_B/war_tech.fml
::  OLD: \KLASA_K/war_tech.fml
::  OLD: \klasa/isplac.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.KLASA:={? var_pres('_a')=type_of('') & +_a=1 || _a || '?' ?}; ''


\slownik_atr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Nakłada na tabelę R filtr uwzględniający atrybut rubryki.
::   WE: _a [INTEGER] - numer atrybutu
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('__RUB','object');
R.clear();
R.f_set('RN',,'RN in (:_a)',__RUB.sys_sql(_a));
~~


\r_slo_ls_okienko_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Zmiana domyślnej kolejności koniecznej dla wyboru kodu w polu złączeniowym - działa z filtrem.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
R.index('RUBLP')


\fm_fm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Formuła zwraca tablicę nazwaną z elementami opisującymi formułę bazową.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_fm:=obj_new('OK','REF','R','TP','F','W','FNL','FIRMA');
_fm.OK:=0;
_fm.REF:=null;
_fm.R:=null;
_fm.TP:='';
_fm.F:='';
_fm.W:='';
_fm.FNL:='';
_fm.FIRMA:=null;

{? FM.FM
|| FM.cntx_psh();
   FM.clear();
   {? FM.seek(FM.FM,)
   || _fm.OK:=1;
      _fm.REF:=FM.ref();
      _fm.R:=FM.R;
      _fm.TP:=FM.TP;
      _fm.F:=FM.memo_txt(,1,'F');
      _fm.W:=FM.W;
      _fm.FNL:=FM.FNL;
      _fm.FIRMA:=FM.FIRMA
   ?};
   FM.cntx_pop()
?};

_fm


\synch_fm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [12.10]
:: OPIS: Aktualizuje zawartość lokalnej tabeli formuł na podstawie formuł globalnych
::   WE: _a - typ formuł
::  OLD: \synch_fm/formuly.fml
::----------------------------------------------------------------------------------------------------------------------
FM.cntx_psh();
FM.clear();

FM.index('FORMFM');
_loop:=(FM.last() & FM.FM<>0);
{!
|? _loop
|! {? FM.FM
:     może wymagać aktualizacji
   || _fm:=exec('fm_fm','rubryki');
      {? _fm.OK
      || _fg:=_fm.F;
         _fl:=FM.memo_txt(,1,'F');
         {? (_fm.FNL='N' | FM.FNL<>'T') & _fl<>_fg
         || FM.memo_set(_fg,'F');
            FM.memo_put(,'F')
         ?}
      || FM.FM:=0;
         FM.FNL:='';
         FM.put()
      ?};
      obj_del(_fm)
   ?};
   _loop:=(FM.prev() & FM.FM<>0)
!};

FM.cntx_pop();
~~


\wer_mod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.02]
:: OPIS: Weryfikuje ustawienia blokady modyfikacji rubryk.
::   WE: _a [INTEGER] - opcjonalnie kod rubryki, pominięcie spowoduje aktualizację wszystkich rubryk.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_std:=exec('_std_kod','rubryki');
_mod:=exec('_std_mod','rubryki');
_fld:=spli_str(exec('_all_mod','rubryki'),',');
_len:=obj_len(_fld);

RUB_MOD.cntx_psh();
RUB_MOD.index('RUB_MOD');
RUB_MOD.prefix();

R.cntx_psh();
R.index('RUBKOD');
{? var_pres('_a')=type_of(0)
|| R.prefix(_a)
|| R.prefix()
?};

_loop:=R.first();
{!
|? _loop
|! {? R.SYSTEM<>'X' & (','+_std+',')*(','+$R.RN+',')=0
::    rubryka użytkownika
   || {? R.SYSTEM<>'N'
      || R.SYSTEM:='N';
         R.put()
      ?};
::    usuń niepotrzebne informacje
      exec('del_ndx','#table',RUB_MOD,'RUB_MOD',R.ref())
   ?};
   _loop:=R.next()
!};

R.cntx_pop();
RUB_MOD.cntx_pop();
~~


\buf_std_rub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.02]
:: OPIS: Tworzy i wypełnia tabelę tymczasową zawierającą definicje standardowych rubryk.
::   WE:
::   WY: alias tabeli tymczasowej
::----------------------------------------------------------------------------------------------------------------------
:: wczytaj rubryki standardowe
_SRC:=exec('_r_import2','rubryki','g');
{? type_of(_SRC)=type_of('')
|| sql('select * from R where 1=0')
|| _SRC.TAB
?}


\wer_std_rub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.02]
:: OPIS: Weryfikacja definicji rubryk.
::   WE:
::   WY: 0/1 - transferu nie można kontynuować/transfer może być wykonany
::  OLD: \wer_rub/skid_trn.fml
::----------------------------------------------------------------------------------------------------------------------
_SRC:=tab_tmp(1,
   'RNS','INTEGER',MS.name(R,'RN')+' (standard)',
   'RTS','STRING['+$MS.fld_len(R,'RT')+']',MS.name(R,'RT')+' (standard)',
   'RND','INTEGER',MS.name(R,'RN')+' (klient)',
   'RTD','STRING['+$MS.fld_len(R,'RT')+']',MS.name(R,'RT')+' (klient)',
   'OK','STRING[1]','Weryfikacja [T/N]',
   'ST','SYS_MEMO','Opis'
);

exec('spr_std_rub','rubryki',_SRC);

{? _SRC.first()=0
|| FUN.info('Nie znaleziono rubryk niezgodnych ze standardową definicją.');
   return(0)
?};

_wnd:=_SRC.mk_sel('Wynik porównania rubryk'@,,0,,,,,,'U');
_SRC.win_fld(_wnd,,'RNS',,,-10);
_SRC.win_fld(_wnd,,'RTS',,,-20);
_SRC.win_fld(_wnd,,'RND',,,-10);
_SRC.win_fld(_wnd,,'RTD',,,-20);
_SRC.win_fld(_wnd,,'OK',,,-10);
_SRC.win_fld(_wnd,,'ST');
_SRC.win_act(_wnd,,'Formuła','Kontynuuj'@,,,"sel_exit()");
_SRC.win_act(_wnd,,'Formuła','Aktualizuj'@,,,
   "  _TAB:=cur_tab(1,1);
      _rn:=_TAB.RNS;
      {? var_pres('__R_SEL')<>type_of('')
      || __R_SEL:=''
      ?};
      __R_SEL+=$_rn+',';
      {? _TAB.sel_size()<=1
      || __R_SEL:=__R_SEL-1;
         exec('import','rubryki','g',__R_SEL,0);
         exec('spr_std_rub','rubryki',_TAB);
         _TAB.first();
         &__R_SEL
      ?}
   ",,
   1,1
);

_SRC.win_sel(_wnd);
_SRC.first();
{!
|? {? _SRC.select()
   || {? _SRC.find_tab(,'OK',,'=','N') | _SRC.find_tab(,'OK',,'=','!')
      || ~FUN.ask(
            'Znaleziono rubryki niezgodne ze standardową definicją.\n'
            'Czy na pewno zakończyć działanie?'@
         )
      ?}
   ?}
!};
1


\spr_std_rub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.02]
:: OPIS: Ustala znaczniki zgodności kodów i nazw rubryk ze standardowymi.
::   WE: _a [TABLE] - alias tabeli przechowującej wyniki porównania
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_SRC:=_a;
_SRC.erase();

_ret:=exec('_r_import2','rubryki','g');
{? type_of(_ret)>100
|| _TAB:=_ret.TAB;
   {? _TAB.first()
   || {!
      |? _SRC.blank();
         _SRC.RNS:=_TAB.RNS;
         _SRC.RTS:=_TAB.RTS;
         _SRC.add();
         _TAB.next()
      !}
   ?}
?};

:: porównaj standard z definicjami klienta
_exc:=',LP,NOTA,IDADD,IDPUT,';
_len:=R.fld_num();
R.cntx_psh();
R.index('RUBKOD');
{? _SRC.first()
|| {!
   |? {? ~R.find_key(_SRC.RNS)
::       rubryka nie istnieje
      || _SRC.del()

      |? R.SYSTEM='T'
::       rubryka standardowa
      || _SRC.del()

      || _SRC.RND:=R.RN;
         _SRC.RTD:=R.RT;
         _SRC.OK:='T';
         _msg:='';
         {! _ii:=1.._len
         |! _acr:=R.fld_acr(_ii);
            {? _exc*(','+_acr+',')=0
            || {? var_pres(_acr,_SRC)=var_pres(_acr,R)
               || {? ($'_a.%1'[_acr])(_SRC)<>($'_a.%1'[_acr])(R)
                  || _msg+=' '+R.fld_name(_ii);
                     _SRC.OK:='N'
                  ?}
               ?}
            ?}
         !};
         {? _SRC.OK='T'
::          zgodna ze standardem
         || R.SYSTEM:='T';
            R.put();
            _SRC.del()

         || _SRC.put();
            _SRC.memo_set('Ze standardem niezgodne są wartości pól: %1'[_msg],'ST');
            _SRC.memo_put(,'ST');
            _SRC.next()
         ?}
      ?}
   !}
?};
R.cntx_pop();
~~


\formuly_import
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [19.22]
:: OPIS: Funkcja do aktualizacji formuł płacowych.
::   WE: _a [ARRAY] - Tablica aktualizowanych typów formuł płacowych.
::       _b [ARRAY] - Tablica kodów aktualizowanych składników płacowych.
::       _c [STRING] - Nazwa formuły do importu formuł płacowych.
::       _d [STRING] - Nazwa pliku z formułą do importu.
::   WY: _err [ARRAY] (counter) - Liczba błędów, które wystąpiły podczas importu, (msg) - treść informacji.
::----------------------------------------------------------------------------------------------------------------------
_tp:=_a;
_rn:=_b;
_formula:=_c;
_file:={? _d+2='.m' || _d-2 || _d ?};
_err:=obj_new('counter','TAB');
_err.counter:=0;
_err.TAB:=tab_tmp(,'MSG','STRING[255]','Komunikat');

FM.cntx_psh();
{! _ni:=1..obj_len(_tp)
|! FM.index('FORMNAZ');
   FM.prefix(exec('ref_firma','ustawienia'),_tp[_ni]);
   {? FM.size()>0
   || {! _mi:=1..obj_len(_rn)
      |! _fmE:=exec(_formula,_file,_tp[_ni],#_rn[_mi]);
::       Umożliwienie usunięcia formuły płacowej gdy zwrócona wartość formuły będzie równa 0 (typu liczbowego):
         {? type_of(_fmE)=type_of(0) & _fmE=0
         || {? FM.find_tab(,'R','RN','=',#_rn[_mi])
            || {? FM.del(,1)
               || _err.TAB.MSG:='Usunięto formułę typu "%1" dla składnika %2.'[_tp[_ni],_rn[_mi]]
               || _err.TAB.MSG:='Usunięcie formuły typu "%1" dla składnika %2 nie powiodło się.'[_tp[_ni],_rn[_mi]];
                  _err.counter+=1
               ?}
            || _err.TAB.MSG:='Usunięcie formuły typu "%1" dla składnika %2 niewymagane (brak formuły).'
                             [_tp[_ni],_rn[_mi]]
            ?};
            _err.TAB.add()
         || _fm:=form(_fmE);
            {? _fm<>''
            || _ok:=1;
               _org:='';
               _found:=FM.find_tab(,'R','RN','=',#_rn[_mi]);
               {? _found
               || _org:=FM.memo_txt(,1,'F')
               || FM.blank();
                  FM.TP:=_tp[_ni];
                  FM.R:=__RUB.ref(#_rn[_mi]);
                  FM.W:={? 'U,F,D'*_tp[_ni] || 'T' || 'N' ?};
                  {? ~FM.add()
                  || _err.TAB.MSG:='Utworzenie formuły typu "%1" dla składnika %2 nie powiodło się.'[_tp[_ni],_rn[_mi]];
                     _err.TAB.add();
                     _ok:=0
                  ?}
               ?};
               {? _found & _fm=_org
               || _err.TAB.MSG:='Formuła typu "%1" dla składnika %2 nie wymaga aktualizacji.'[_tp[_ni],_rn[_mi]];
                  _err.TAB.add()
               |? _ok
               || FM.memo_set(_fm,'F');
                  {? FM.memo_put(,'F')
                  || {? _found
                     || _err.TAB.MSG:='Zaktualizowano formułę typu "%1" dla składnika %2.'[_tp[_ni],_rn[_mi]]
                     || _err.TAB.MSG:='Utworzono formułę typu "%1" dla składnika %2.'[_tp[_ni],_rn[_mi]]
                     ?};
                     _err.TAB.add()
                  |? _found
                  || _err.TAB.MSG:='Aktualizacja formuły typu "%1" dla składnika %2 nie powiodła się.'[_tp[_ni],_rn[_mi]];
                     _err.TAB.add();
                     _err.counter+=1
                  ?}
               ?}
            ?}
         ?}
      !}
   ?}
!};
FM.cntx_pop();
_err

:Sign Version 2.0 jowisz:1045 2023/10/23 14:39:58 add59409b6826915396fa3b105665424d7ae18178d451a533e8e39e33d423d103756b8b12a865528d185bb8fa55931cfa1a73f7796db8071bcb6f241496895065c26515e8f59088017c4be865b0b2650628ce6a5d25185766793ce5ab78d53898f00174428a390a625794d10f1dbe5b3dd196979aed73a19b89ae500f2cd662b
