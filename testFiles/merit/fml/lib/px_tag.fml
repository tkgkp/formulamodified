:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku:  px_tag.fml
:: Utworzony: 01.02.2023
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Formuły do obsługi tabeli PX_TAG - Zgupowane obiekty planistyczne
::======================================================================================================================

\add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Dodaje rekord PX_TAG
::   WE: _a - STRING - identyfikator grupujący
::       _b - PX_OBJ.ref - dodawany obiekt planistyczny
::       _c - PX_SET.ref() - zestaw planistyczny
::   WY: ref utworzonego lub znalezionego już rekordu lub null jeśli porażka
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_id:=_a;
_px_obj:=_b;
_px_set:=_c;

_result:=null();

PX_TAG.cntx_psh();
PX_TAG.index('CREATE');
{? _px_set<>null()
|| PX_TAG.prefix(_id,_px_set)
|| PX_TAG.prefix(_id,)
?};
{? PX_TAG.first()
|| {!
   |? {? exec('can_add','px_tag',,_px_obj)>0
      || _result:=PX_TAG.ref()
      ?};
      PX_TAG.next() & _result=0
   !}
?};
{? _result=null()
|| PX_TAG.blank();
   PX_TAG.ID:=_id;
   PX_TAG.KIND:='N';
   PX_TAG.PX_SET:=_px_set;
   {? PX_TAG.add()
   || _result:=PX_TAG.ref()
   ?}
?};
PX_TAG.cntx_pop();
_result


\can_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy do PX_TAGa można dołączyć obiekt planistyczny
::   WE: [_a] - PX_TAG.ref lub bieżący rekord
::       _b - PX_OBJ.ref - obiekt
::   WY: 0 - nie można
::       1 - można
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_TAG.ref())
|| _ref:=_a
?};
_px_obj:=_b;

_result:=0;
_can_continue:=1;

PX_TAG.cntx_psh();
{? _ref<>null()
|| PX_TAG.prefix();
   {? PX_TAG.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};
_tech:=exec('tech_table','px_tag');

{? _can_continue>0
||
   PX_OBJ.cntx_psh(); PX_OBJ.prefix();
   {? PX_OBJ.seek(_px_obj)
   || {? PX_OBJ.M<>null()
      ||
         _mat:=PX_OBJ.M;

         PX_OBJ.index('PX_TAG2');
         PX_OBJ.prefix(PX_TAG.ref(),PX_OBJ.M);
         {? PX_OBJ.first()
         ||
::          Jeżeli jest już taki materiał w grupie to można zawsze dodawać
            _result:=1
         ?};

         {? _result=0
         ||
            {? PX_OBJ.M().M_ATR<>PX_TAG.M_ATR
            || _can_continue:=0
            ?};
            {? PX_OBJ.M().J<>PX_TAG.JM
            || _can_continue:=0
            ?};

            {? _can_continue>0
            ||
::             Nie ma jeszcze takiego materiału, sprawdzam czy jest wspólna technologia na realizację wszystkich
::             materiałów w grupie
               exec('tech_table_fill','px_tag',PX_OBJ.M,_tech);

               PX_OBJ.index('PX_TAG');
               PX_OBJ.prefix(PX_TAG.ref());
               {? PX_OBJ.first()
               || _common_tktl:=exec('get_common_tktl','px_tag',,_tech,1);
                  {? _common_tktl<>null()
                  || _result:=1
                  ?}
               || _result:=1
               ?}
            ?}
         ?}
      ?}
   ?};
   PX_OBJ.cntx_pop()
?};
PX_TAG.cntx_pop();
_result


\get_common_tktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca wspólną kartę technologiczną którą można wykonać wszystkie elementy
::       grupy obiektów
::   WE: [_a] - PX_TAG.ref() lub bieżący rekord
::       [_b] - tab_tmp - tabelka tymczasowa zawierająca technologie
::       [_c] - INTEGER - modyfikator ilości (jeżeli _b zostało już wcześniej załadowane)
::   WY: TKTL.ref() lub null
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_TAG.ref())
|| _ref:=_a
?};
{? var_pres('_b')>100
|| _tech:=_b
|| _tech:=exec('tech_table','px_tag')
?};
_mod:=0;
{? var_pres('_c')=type_of(0)
|| _mod:=_c
?};

_result:=0;
_can_continue:=1;

PX_TAG.cntx_psh();
{? _ref<>null()
|| PX_TAG.prefix();
   {? PX_TAG.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_OBJ.cntx_psh();
   PX_OBJ.index('PX_TAG');
   PX_OBJ.prefix(PX_TAG.ref());
   {? PX_OBJ.first()
   || _size:=PX_OBJ.size();
      {!
      |? exec('tech_table_fill','px_tag',PX_OBJ.M,_tech);
         PX_OBJ.next()
      !};

      _i2:=_tech.ndx_tmp(,,'COUNT',,,'DEFAULT',,,'NRK',,,'WER',,);
      _tech.index(_i2);
      _tech.prefix(_size+_mod);
      {? _tech.last()
      || {!
         |? _tktl:=exec('FindAndGet','#table',TKTL,_tech.TKTL,,,null());
            {? _tktl<>null()
            || PX_TEX.cntx_psh();
               PX_TEX.index('TKTLMSYM');
               PX_TEX.prefix($_tktl);
               {? PX_TEX.first()
               || _result:=_tktl
               ?};
               PX_TEX.cntx_pop()
            ?};
            _tech.prev() & _result=null()
         !}
      ?}
   ?};
   PX_OBJ.cntx_pop()
?};
PX_TAG.cntx_pop();
_result


\get_common_tktl_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca wspólną kartę technologiczną którą można wykonać wszystkie elementy
::       grupy obiektów
::   WE: [_a] - PX_TAG.ref() lub bieżący rekord
::       [_b] - tab_tmp - tabelka tymczasowa zawierająca technologie
::       [_c] - INTEGER - modyfikator ilości (jeżeli _b zostało już wcześniej załadowane)
::   WY: tab_tmp - tabelka tymczasowa wspólnych technologii
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_TAG.ref())
|| _ref:=_a
?};
{? var_pres('_b')>100
|| _tech:=_b
|| _tech:=exec('tech_table','px_tag')
?};
_mod:=0;
{? var_pres('_c')=type_of(0)
|| _mod:=_c
?};

_result:=exec('tech_table','px_tag');
_can_continue:=1;

PX_TAG.cntx_psh();
{? _ref<>null()
|| PX_TAG.prefix();
   {? PX_TAG.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| PX_OBJ.cntx_psh();
   PX_OBJ.index('PX_TAG');
   PX_OBJ.prefix(PX_TAG.ref());
   {? PX_OBJ.first()
   || _size:=PX_OBJ.size();
      {!
      |? exec('tech_table_fill','px_tag',PX_OBJ.M,_tech);
         PX_OBJ.next()
      !};
      _i2:=_tech.ndx_tmp(,,'COUNT',,,'DEFAULT',,,'NRK',,,'WER',,);
      _tech.index(_i2);
      _tech.prefix(_size+_mod);
      {? _tech.first()
      || {!
         |? _result.blank();
            _result.TKTL:=_tech.TKTL;
            _result.NRK:=_tech.NRK;
            _result.WER:=_tech.WER;
            _result.add();
            _tech.next()
         !}
      ?}
   ?};
   PX_OBJ.cntx_pop()
?};
PX_TAG.cntx_pop();
_result


\tech_table
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca tabelkę tymczasową zawierającą technologie z licznikiem ich wystąpień
::   WY: tab_tmp
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_tech:=tab_tmp(1,
   'TKTL','STRING[16]','Ref karty',
   'COUNT','INTEGER','Liczba wystąpień',
   'DEFAULT','INTEGER','Liczba domyślnych wystąpień danej karty',
   'NRK','STRING[50]','Numer karty',
   'WER','STRING[50]','Wersja karty'
);
_tech


\tech_table_fill
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Wypełnia tabelkę tymczasową kartami technologicznymi dla podanego materiału
::   WE: _a - M.ref()
::       _b - tab_tmp()
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ktm:=_a;
_tab:=_b;

TKTL.cntx_psh();
TKTLW.cntx_psh();
TKTLW.index('KSN');
TKTLW.prefix('T',_ktm,'T','N');
{? TKTLW.first()
|| {!
   |? _tab.prefix($TKTLW.TKTL);
      {? _tab.first()
      || _tab.COUNT+=1;
         {? TKTLW.DEFAULT='T'
         || _tab.DEFAULT+=1
         ?};
         _tab.put()
      || _tab.blank();
         _tab.COUNT:=1;
         {? TKTLW.DEFAULT='T'
         || _tab.DEFAULT:=1
         ?};
         _tab.TKTL:=$TKTLW.TKTL;
         _tab.NRK:=TKTLW.TKTL().NRK;
         _tab.WER:=TKTLW.TKTL().WER;
         _tab.add()
      ?};
      TKTLW.next()
   !}
?};
TKTLW.cntx_pop();
TKTL.cntx_pop();
~~


\delete_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja w oknie - usunięcie rekordu
::   WE: [_a] - INTEGER - 0/[1] - czy wyświetlać dialogi
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRIVATE><AKCJA><DEL>
::----------------------------------------------------------------------------------------------------------------------
_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};

_result:=0;
_can_continue:=1;

_tab:=cur_tab(1,1);

_group:=0;
{? _tab.sel_size()>0
|| _group:=1;
   _dialog:=0
?};

:: Sprawdzam czy można usunąć
{? _group>0
|| _can_continue:=exec('can_delete','px_tag',,2)
|| _can_continue:=exec('can_delete','px_tag',,1)
?};


{? _dialog>0 & _can_continue>0
|| {? _can_continue=2
   || ~~
   || _can_continue:=FUN.ask('Usunąć grupę obiektów: %1?'@[PX_TAG.ID])
   ?}
?};
{? _can_continue>0
|| _result:=exec('delete','px_tag',_tab.ref())
?};
_result


\delete_act_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja usuń grupa przed w oknie wertowania tabeli PX_TAG
::   WY: 0 - porazka
::       1 - sukces
::  TAG: <PRIVATE><AKCJA><GRUPA><DEL>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_tab:=cur_tab(1,1);
{? FUN.ask('Zaznaczono: %1 rekordów. Czy usunąć je wszystkie?'@[$_tab.sel_size()])
|| _result:=1;
   sel_nchk();
   KOMM.init(200,,'Usuwanie zgrupowanych obiektów'@,'')
?};
_result


\delete_act_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja usuń grupa po w oknie wertowania tabeli PX_TAG
::  TAG: <PRIVATE><AKCJA><GRUPA><DEL>
::----------------------------------------------------------------------------------------------------------------------
KOMM.select(,,,,,0);
~~


\can_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza możliwość usunięcia rekordu PX_TAG
::   WE: [_a] - PX_TAG.ref, jeśli nie podany to aktualny rekord
::       [_b] - INTEGER - czy wyswietlac komunikaty:  0  - nie
::                                                   [1] - wyskakujący komunikat
::                                                    2  - w KOMM
::   WY: 0 - nie można usunąć rekordu
::       1 - można usuwać
::       2 - można usuwać i już nie trzeba dialogu wyświetlać
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();

_display:=1;
{? var_pres('_b')=type_of(0)
|| _display:=_b
?};

_result:=0;
_can_continue:=1;


PX_TAG.cntx_psh();
{? var_pres('_a')=type_of(PX_TAG.ref())
|| _ref:=_a;
   _can_continue:=0;
   PX_TAG.clear();
   {? PX_TAG.seek(_ref)
   || _can_continue:=1
   ?}
?};

{? _can_continue>0
|| {? PX_TAG.KIND<>'N'
   || _can_continue:=0;
      _msg:='Grupa obiektów: %1 jest grupą specjalną. Nie można jej usuwać.'@[exec('PX_TAG','#to_string')];
      {? _display=1
      || FUN.emsg(_msg)
      |? _display=2
      || KOMM.add(_msg,2,,1)
      ?}
   ?}
?};

{? _can_continue>0
|| {? _display=1 & exec('get_ilosc_que','px_tag',exec('get_mainversion','px_ver'))>0
   || _msg:='Grupa obiektów: %1 znajduje się w kolejce planu. '
            'Jej usunięcie nie spowoduje usunięcia powiazanego elementu z kolejki. Kontynuować?'@[exec('PX_TAG','#to_string')];
      {? FUN.ask(_msg)>0
      || _can_continue:=2
      ?}
   ?}
?};

_result:=_can_continue;

PX_TAG.cntx_pop();
_result


\delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Kasuje podany rekord tabeli PX_TAG (wykonywane w transakcji!!!)
::   WE: _a - PX_TAG.ref()
::   WY: >0 -wyczyszczone,
::       <=0 -niewyczyszczone
::  TAG: <PUBLICZNA><DEL>
::UWAGA: Parametry bez [] są wymagane, formula może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=0;
_can_continue:=1;

:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;
{? _mydo || do() ?};
PX_TAG.cntx_psh(); PX_TAG.clear();
{? PX_TAG.seek(_ref)
|| {? exec('clean','px_tag',_ref)>0
   || {? PX_TAG.del(,1)>0
      || _result:=1
      || undo();
         _result:=-3
      ?}
   || _result:=-2
   ?}
|| _result:=0
?};

{? _result<0
|| undo()
?};

PX_TAG.cntx_pop();
{? _mydo || end() ?};
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Czyści powiązania do rekordu tabeli PX_TAG
::   WE: _a - PX_TAG.ref()
::   WY: >0  -wyczyszczone,
::       <=0 -niewyczyszczone
::  TAG: <PRYWATNA><CLEAN>
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=0;
_can_continue:=1;

_mydo:=do_state()=0;
{? _mydo || do() ?};
:: --- powiązania do ---

PX_OBJ.cntx_psh();
PX_OBJ.index('PX_TAG');
PX_OBJ.prefix(_ref);
{? PX_OBJ.first()
|| {!
   |? PX_OBJ.cntx_psh();
      PX_OBJ.prefix();
      PX_OBJ.PX_TAG:=null();
      PX_OBJ.HAS_TAG:='N';
      _can_continue:=PX_OBJ.put();
      PX_OBJ.cntx_pop();
      PX_OBJ.first() & _can_continue>0
   !}
?};
PX_OBJ.cntx_pop();

PX_GRP.cntx_psh();
PX_GRP.index('PX_TAG');
PX_GRP.prefix(_ref);
{? PX_GRP.first()
|| {!
   |? PX_GRP.cntx_psh();
      PX_GRP.prefix();
      PX_GRP.PX_TAG:=null();
      _can_continue:=PX_GRP.put();
      PX_GRP.cntx_pop();
      PX_GRP.first() & _can_continue>0
   !}
?};
PX_GRP.cntx_pop();

:: --- wszystkie powiazania usuniete? ---

{? _can_continue>0
|| _result:=1
|| undo()
?};

{? _mydo || end() ?};

_result


\icon_id
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Obsluga ikony w polu PX_TAG.ID
::   WY: STRING - identyfikator ikonki lub ''
::----------------------------------------------------------------------------------------------------------------------
_result:='';
{? exec('planned_mainver','px_tag')>0
|| _result:='xwin16.png:38'
|| _result:='xwin16.png:110'
?};
_result


\planned_mainver
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy grupa jest zaplanowana w planie głównym
::   WE: [_a] - PX_TAG.ref() lub bieżący rekord
::   WY: REAL - ilość zaplanowana
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_TAG.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

_mainver:=exec('get_mainversion','px_ver');

PX_TAG.cntx_psh();
{? _ref<>null()
|| PX_TAG.prefix();
   {? PX_TAG.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _result:=exec('get_ilosc_que','px_tag',_mainver)
?};
PX_TAG.cntx_pop();
_result


\add_system_notag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Dodaje specjalny 'systemowy' PX_TAG który będzie funkcjonował w widokach do prefiksowania
::       po wszystkich px_obj
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
PX_TAG.cntx_psh();
PX_TAG.index('KIND');
PX_TAG.prefix('S',);
{? PX_TAG.first()=0
|| PX_TAG.blank();
   PX_TAG.KIND:='S';
   PX_TAG.ID:=' ~Wszystkie obiekty';
   _result:=PX_TAG.add()
|| PX_TAG.ID:=' ~Wszystkie obiekty';
   _result:=PX_TAG.put()
?};
PX_TAG.cntx_pop();
_result


\after_refresh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Formuła na after_refresh w widokach planu
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
PX_VAR.PX_TAG:=null();

{? PX_TAG.KIND<>'S'
|| PX_VAR.PX_TAG:=PX_TAG.ref()
?};

_px_obj_filter:=exec('get','#params',8064,type_of(''),OPERATOR.USER);
{? _px_obj_filter<>''
|| exec('px_obj_run_filter','px_obj',_px_obj_filter)
|| exec('filter_all_act','px_obj')
?};
~~


\update_after_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Aktualizuje termin, zwrot itp na PX_TAG po dodaniu do niego PX_OBJ
::   WE: [_a] - PX_TAG.ref() lub bieżący rekord
::       [_b] - INTEGER - 0/1 - 0 - odtwarzać na czysto, 1- odtwarzać tylko jeśli są różnice
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_TAG.ref())
|| _ref:=_a
?};
_mode:=1;
{? var_pres('_b')=type_of(0)
|| _mode:=_b
?};

_result:=0;
_can_continue:=1;

PX_TAG.cntx_psh();
{? _ref<>null()
|| PX_TAG.prefix();
   {? PX_TAG.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _dir:=0;
   _px_set:=null();
   _tm_rea:=0;
   _ilosc:=0;
   _m_atr:=null();
   _jm:=null();

   {? _mode=1
   || _dir:=PX_TAG.DIR;
      _px_set:=PX_TAG.PX_SET;
      _tm_rea:=PX_TAG.TM_REA;
      _ilosc:=PX_TAG.ILOSC;
      _m_atr:=PX_TAG.M_ATR;
      _jm:=PX_TAG.JM
   ?};

   _tktl:=PX_TAG.TKTL;

   _ilosc_obj:=0;
   _put:=0;

   PX_OBJ.cntx_psh();
   PX_OBJ.index('PX_TAG');
   PX_OBJ.prefix(PX_TAG.ref());
   {? PX_OBJ.first()
   || {!
      |? {? _tm_rea=0 | PX_OBJ.TM_REA<_tm_rea
         || _tm_rea:=PX_OBJ.TM_REA
         ?};
         {? _dir=0
         || _dir:=PX_OBJ.DIR
         ?};
         {? _px_set=null()
         || _px_set:=PX_OBJ.PX_SET
         ?};
         {? _m_atr=null()
         || _m_atr:=PX_OBJ.M().M_ATR
         ?};
         {? _jm=null()
         || _jm:=PX_OBJ.M().J
         ?};
         _ilosc_obj+=PX_OBJ.IL;
         PX_OBJ.next()
      !}
   ?};
   {? _tm_rea>0 & _tm_rea<>PX_TAG.TM_REA
   || PX_TAG.TM_REA:=_tm_rea;
      PX_TAG.ENDD:=exec('tm_stamp2date','#tm_stamp',_tm_rea);
      PX_TAG.ENDT:=exec('tm_stamp2time','#tm_stamp',_tm_rea);
      _put:=1
   ?};
   {? _dir<>0 & PX_TAG.DIR<>_dir
   || PX_TAG.DIR:=_dir;
      _put:=1
   ?};
   {? _px_set<>null() & PX_TAG.PX_SET<>_px_set
   || PX_TAG.PX_SET:=_px_set;
      _put:=1
   ?};
   _new_tktl:=exec('get_common_tktl','px_tag');
   {? _new_tktl<>_tktl
   || PX_TAG.TKTL:=_new_tktl;
      PX_TAG.RTKTL:=$_new_tktl;
      _put:=1
   ?};
   {? _ilosc<>_ilosc_obj
   || PX_TAG.ILOSC:=_ilosc_obj;
      _put:=1
   ?};
   {? _m_atr<>null() & _m_atr<>PX_TAG.M_ATR
   || PX_TAG.M_ATR:=_m_atr;
      _put:=1
   ?};
   {? _jm<>null() & _jm<>PX_TAG.JM
   || PX_TAG.JM:=_jm;
      _put:=1
   ?};
   {? _put>0
   || _can_continue:=PX_TAG.put()
   ?};
   PX_OBJ.cntx_pop()
?};
PX_TAG.cntx_pop();
PX_TAG.get();
{? _can_continue>0
|| _result:=1
?};
_result


\get_default_tex
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [23.25]
:: OPIS: Zwraca domyslna technologie PX dla grupy obiektów
::   WE: _a - PX_TAG.ref() - grupa obiektów
::   WY: PX_TEX.ref() lub null
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_TAG.ref())
|| _ref:=_a
?};
:: Obiekt do obslugi przepisow
{? var_pres('PXoTEX')<100 || exec('PXoTEX','px_tex') ?};

_result:=null();
_can_continue:=1;

PX_TAG.cntx_psh();
{? _ref<>null()
|| PX_TAG.prefix();
   {? PX_TAG.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? PX_TAG.TKTL<>null()
   || PX_TEX.cntx_psh();
      PX_TEX.index('TKTL');
      PX_TEX.prefix('T',PXoTEX.kind.table('TKTL'),PX_TAG.TKTL);
      {? PX_TEX.first()
      || _result:=PX_TEX.ref()
      ?};
      PX_TEX.cntx_pop()
   ?}
?};
PX_TAG.cntx_pop();
_result


\rec_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Rekord przed dla PX_TAG - wywołanie w defie
::   WE: _a - INTEGER - czy ostatnie odrysowanie
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_last:=_a;
_keys:=':';
{? _last>0 & PX_TAG.sel_size()=0
|| {? PX_TAG.KIND<>'N'
   || _keys:='D'+_keys
   ?}
?};
PX_TAG.actions_grayed(cur_win(1,1),_keys);
exec('rekprzed','color','PX_TAG#01#')


\rec_before2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Rekord przed dla PX_TAG - faktyczna implementacja
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
PX_VAR.OBJ_IL:=exec('get_ilosc_que','px_tag',PX_VAR.VER_QUE);

_result:='';
{? exec('mainversion_vie','px_ver')
|| {? exec('get_ilosc_plan','px_tag',,1)>0
   || _result:='PX_TAG#01#02'
   ?}
|| _result:='PX_TAG#01#01'
?};
_result


\get_ilosc_que
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca ilosc w kolejce dla danej grupy obiektów
::   WE: _a - PX_VER.ref - wersja planu
::       [_b] - PX_TAG.ref lub bieżący rekord
::   WY: REAL - ilosc
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ver:=_a;
_ref:=null();
{? var_pres('_b')=type_of(PX_TAG.ref())
|| _ref:=_b
?};

_result:=0;
_can_continue:=1;

PX_TAG.cntx_psh();
{? _ref<>null()
|| PX_TAG.prefix();
   {? PX_TAG.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_GRP.cntx_psh();
   PX_GRP.index('PX_TAG');
   PX_GRP.prefix(PX_TAG.ref(),_ver);
   {? PX_GRP.first()
   || {!
      |? _result+=PX_GRP.ILOSC;
         PX_GRP.next()
      !}
   ?};
   PX_GRP.cntx_pop()
?};
PX_TAG.cntx_pop();
_result


\get_ilosc_plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca ilosc w planie dla danej grupy obiektów
::   WE: [_a] - PX_TAG.ref lub bieżący rekord
::       [_b] - INTEGER - przerywaj jak chociaż jeden rekord jest w planie
::   WY: REAL - ilosc
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_TAG.ref())
|| _ref:=_a
?};
_break:=1;
{? var_pres('_b')=type_of(0)
|| _break:=_b
?};

_result:=0;
_can_continue:=1;

PX_TAG.cntx_psh();
{? _ref<>null()
|| PX_TAG.prefix();
   {? PX_TAG.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_OBJ.cntx_psh();
   PX_OBJ.index('PX_TAG');
   PX_OBJ.prefix(PX_TAG.ref());
   {? PX_OBJ.first()
   || _can_continue:=1;
      {!
      |? _result+=PX_OBJ.IL_PLAN;
         {? _result>0 & _break>0
         || _can_continue:=0
         ?};
         PX_OBJ.next() & _can_continue>0
      !}
   ?};
   PX_OBJ.cntx_pop();
   ~~
?};
PX_TAG.cntx_pop();
_result


\find_match
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Szuka w kolejce PX_GRPa powiązanego z przekazanym PX_TAGiem ale takiego
::       do którego można doplanować jakieś nowe elementy których jeszcze nie zaplanowano w całości
::   WE: _a - PX_VER.ref() - wersja planu
::       _b - PX_TAG.ref() - grupa obiektów
::   WY: PX_GRP.ref() lub null
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_px_tag:=_b;

_result:=null();

PX_GRP.cntx_psh();
PX_GRP.index('PX_TAG');
PX_GRP.prefix(_px_tag,_px_ver);
{? PX_GRP.first()
|| {!
   |?
      _can_match:=1;
      {? exec('is_blocked','px_grp')>0
      || _can_match:=0
      ?};
      {? PX_GRP.STATUS=exec('status_wyk1','px_grp')
      || _can_match:=0
      ?};
      {? PX_GRP.STATUS=exec('status_wyk2','px_grp')
      || _can_match:=0
      ?};

      {? _can_match>0
      || _result:=PX_GRP.ref()
      ?};
      PX_GRP.next() & _result=null
   !}
?};
PX_GRP.cntx_pop();
_result


\fields_blank
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Formuły na wartość początkową dla pól w tabeli PX_TAG
::   WY:
::  TAG: <MBUILDER><BL><TAB:PX_TAG>
::----------------------------------------------------------------------------------------------------------------------
_result:=~~;
{? cur_afld()='KIND'
|| _result:='N'
?};
_result


\fields_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Formuły przed wyświetleniem dla pól w tabeli PX_TAG
::   WY:
::  TAG: <MBUILDER><BD><TAB:PX_TAG>
::----------------------------------------------------------------------------------------------------------------------
''


\fields_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Formuły przed redkacją dla pól w tabeli PX_TAG
::   WY:
::  TAG: <MBUILDER><BE><TAB:PX_TAG>
::----------------------------------------------------------------------------------------------------------------------
1


\fields_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Formuły po redakcji dla pól w tabeli PX_TAG
::   WY:
::  TAG: <MBUILDER><AE><TAB:PX_TAG>
::----------------------------------------------------------------------------------------------------------------------
1

\fields_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Formuły obsługi na F3 dla pól w tabeli PX_TAG
::   WY:
::  TAG: <MBUILDER><F3><TAB:PX_TAG>
::----------------------------------------------------------------------------------------------------------------------
~~


\fields_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Formuły na format wyświetlania dla pól w tabeli PX_TAG
::   WY:
::  TAG: <MBUILDER><FD><TAB:PX_TAG>
::----------------------------------------------------------------------------------------------------------------------
_result:='';
{? cur_afld()='ILOSC'
|| _result:='out_prec='+$ST.DOKL+{? fld()=0 || ',empty=1' || ',empty=0' ?}
?};
_result


\fields_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Formuły na format redagowania dla pól w tabeli PX_TAG
::   WY:
::  TAG: <MBUILDER><FE><TAB:PX_TAG>
::----------------------------------------------------------------------------------------------------------------------
''


\legenda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Legenda w oknie PX_TAG
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','PX_TAG#01#','#PX_TAG#01');
~~


\delete_auto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Automatyczny usuwator PX_TAG
::   WE: [_a] - PX_TAG.ref() lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_TAG.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_TAG.cntx_psh();
{? _ref<>null()
|| PX_TAG.prefix();
   {? PX_TAG.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _can_delete:=1;
   PX_GRP.cntx_psh();
   PX_GRP.index('PX_TAG');
   PX_GRP.prefix(PX_TAG.ref(),exec('get_mainversion','px_ver'));
   {? PX_GRP.first()
   || {!
      |? {? PX_GRP.STATUS<>exec('status_wyk2','px_grp')
         || _can_delete:=0
         ?};
         PX_GRP.next() & _can_delete>0
      !}
   ?};
   PX_GRP.cntx_pop();

   {? _can_delete>0
   || _can_continue:=exec('delete','px_tag',PX_TAG.ref())
   ?};
   ~~
?};
PX_TAG.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\to_string
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca tekstową reprezentację rekordu
::   WE: [_a] - PX_TAG.ref() lub bieżący rekord
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_TAG.ref())
|| _ref:=_a
?};

_result:='';
_can_continue:=1;

PX_TAG.cntx_psh();
{? _ref<>null()
|| PX_TAG.prefix();
   {? PX_TAG.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _result:=exec('PX_TAG','#to_string')
?};
PX_TAG.cntx_pop();
_result


\popraw_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja w oknie - poprawienie rekordu
::       Kontekst pracy - rekord PX_TAG
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRIVATE><AKCJA><DEL>
::----------------------------------------------------------------------------------------------------------------------

_result:=0;
_can_continue:=1;
{? PX_TAG.KIND<>'N'
|| _can_continue:=0;
   _msg:='Zapis systemowy nie może być poprawiany.'@;
   FUN.emsg(_msg)
?};

{? _can_continue>0
||
   _tab:=exec('tab_edit','px_tag');
   _edit:=exec('win_edit','px_tag',_tab);

   _tab.win_edit(_edit);

   _valid:="
      _tab:=cur_tab(1,1);
      _result:='';
      {? __CHK.record(_tab,,'NRK')<>''
      || _result:='NRK'
      ?};

      _tktl:=exec('FindAndGet','#table',TKTL,_tab.REF_TEC,,,null());
      {? _result='' & _tktl<>null() & _tktl<>PX_TAG.TKTL
      || {? _tab.TAG_QUE>0
         || _msg:='Grupa obiektów: %1 znajduje się w kolejce planu. Modyfikowanie technologii niedostępne.'@[_tab.TAG_SYM];
            FUN.emsg(_msg);
            _result:='NRK'
         ?}
      ?};
      _result
   ";

   {? _tab.edit(_valid)
   ||
      {? _tab.REF_TEC<>''
      || _tktl:=exec('FindAndGet','#table',TKTL,_tab.REF_TEC,,,null());
         {? _tktl<>null() & PX_TAG.TKTL<>_tktl
         || PX_TAG.TKTL:=_tktl;
            PX_TAG.RTKTL:=$_tktl;
            _result:=PX_TAG.put()
         ?}
      ?}
   ?}
?};
_result


\tab_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca tabelkę tymczasową do obsługi edycji
::       Kontekst pracy - bieżący rekord PX_TAG
::   WY: tab_tmp
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(2,
   'NRK','STRING[100]','Numer karty technologicznej',
   'WER','STRING[40]','Wersja karty technologicznej',
   'REF_TEC','STRING[16]','Ref karty technologicznej',
   'TAG_SYM','STRING[100]','Symbol grupy',
   'TAG_DIR','INTEGER','Zwrot',
   'TAG_IL','REAL','Ilość',
   'TAG_QUE','REAL','W kolejce'
);
_tab.blank();
_tab.NRK:=PX_TAG.TKTL().NRK;
_tab.WER:=PX_TAG.TKTL().WER;
_tab.REF_TEC:=$PX_TAG.TKTL;
_tab.TAG_SYM:=PX_TAG.ID;
_tab.TAG_DIR:=PX_TAG.DIR;
_tab.TAG_IL:=PX_TAG.ILOSC;
_tab.TAG_QUE:=exec('get_ilosc_que','px_tag',exec('get_mainversion','px_ver'));
_tab.add();
_tab


\win_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca okienko edycyjne
::   WE: _a - tab_tmp - tabelka tymczasowa
::   WY: STRING - identyfikator okienka
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_fml:="
   _tab:=cur_tab(1,1);
   _result:=_tab.NRK;
   _common_tech:=exec('get_common_tktl_tab','px_tag');
::   exec('select','#table',_common_tech);
   TKTL.win_sel('SLO');
   TKTL.index('NRK');
   TKTL.prefix();
   TKTL.f_set('NRK,WER',
               ,'
               (TKTL.TORW=\'\'T\'\'
               and TKTL.STAN=\'\'T\'\'
               and TKTL.ARCH=\'\'N\'\'
               and ((TKTL.TERM_OD<=to_date(:_a) and TKTL.TERM_OD IS NOT NULL)
               or TKTL.TERM_OD IS NULL)
               and ((TKTL.TERM_DO>=to_date(:_a) and TKTL.TERM_DO IS NOT NULL)
               or TKTL.TERM_DO IS NULL))
               and TKTL.REFERENCE in (select :_b.TKTL from :_b)
               '
               ,date(),_common_tech);

   {? TKTL.f_first()
   || TKTL.f_find(_tab.NRK,_tab.WER);
      {? TKTL.select(,1,10)
      ||
         _result:=TKTL.NRK;
         _tab.REF_TEC:=$TKTL.ref();
         _tab.WER:=TKTL.WER
      ?}
   ||
      FUN.info('Nie znaleziono wspólnej technologii dla elementów grupy obiektów'@)
   ?};
   TKTL.f_clear();
   _result
";

_tab.fld_fml('NRK','F3',_fml);

_fml:="
   _tab:=cur_tab(1,1);
   TKTL.cntx_psh();
   TKTL.index('NRK');
   TKTL.prefix('T',_tab.NRK,_tab.WER,);
   {? TKTL.first()
   || _tab.REF_TEC:=$TKTL.ref()
   || _tab.REF_TEC:='';
      _tab.NRK:='';
      _tab.WER:=''
   ?};
   TKTL.cntx_pop();
   ~~
";
_tab.fld_fml('NRK','AFTER_EDIT',_fml);

_edit:=_tab.mk_edit('Grupa obiektów'@,0,'#pxtagedit');
_tab.win_esep(_edit,'Dane podstawowe'@);
_tab.win_efld(_edit,,'TAG_SYM',,,40,,1,'Symbol'@);
_tab.win_efld(_edit,,'TAG_IL',,,40,,1,'Ilość'@);
_tab.win_efld(_edit,,'TAG_QUE',,,40,,1,'W kolejce'@);
_tab.win_efld(_edit,,'TAG_DIR',,,40,,1,'Zwrot'@,,,'radio-buttons',,'Do przodu'@,"1",'Wstecz'@,"-1",'Nieokreślony'@,"0");

_tab.win_esep(_edit,'Karta technologiczna'@);
_tab.win_efld(_edit,,'NRK',,,40,,,'Numer karty'@);
_tab.efld_opt(_edit,'mark=1',,'NRK');
_tab.win_efld(_edit,,'WER',,,40,,1,'Wersja'@);
exec('ok_esc','#window',_tab,_edit);
_edit


\display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja wyświetl w PX_TAG
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_tab:=exec('tab_edit','px_tag');
_edit:=exec('win_edit','px_tag',_tab);

_tab.win_edit(_edit);
_tab.display();
~~


\find_px_grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Wyszukuje pierwszą grupę w kolejce powiązaną z danym PX_TAG - nie wykonaną, do której jeszcze
::       nie wygenerowano zleceń
::   WE: _a - PX_TAG.ref
::   WY: PX_GRP.ref() lub null
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_px_tag:=_a;

_result:=null();

PX_GRP.cntx_psh();
PX_ZL.cntx_psh();
PX_ZL.index('PX_GRP');
PX_GRP.index('PX_TAG');
PX_GRP.prefix(_px_tag,exec('get_mainversion','px_ver'));
{? PX_GRP.first()
|| {!
   |? _can_return:=1;
      {? PX_GRP.STATUS=exec('status_wyk1','px_grp')
      || _can_return:=0
      ?};
      {? PX_GRP.STATUS=exec('status_wyk2','px_grp')
      || _can_return:=0
      ?};
      {? exec('is_blocked','px_grp')
      || _can_return:=0
      ?};
      {? _can_return>0
      || PX_ZL.prefix(PX_GRP.ref());
         {? PX_ZL.first()
         || _can_return:=0
         ?}
      ?};
      {? _can_return>0
      || _result:=PX_GRP.ref()
      ?};
      PX_GRP.next() & _result=null
   !}
?};
PX_GRP.cntx_pop();
PX_ZL.cntx_pop();
_result


:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:35 29e393897e4917434c287ebe9fcc65e7b11e90e104792b4232f92b50c573e01a3f1a0477ff76e6f88398a9d230798c2522e5e7ac604511ba7daae5b26601cca00aa33fac190dd1f712629ad7f41837536603b8e1f315d39a32b94ab54b57faae98310ed1c35d08ca39b431727262fba9ad3701caafa252a9ee2ff142c54556d4
