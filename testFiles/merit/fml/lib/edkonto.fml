:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: edkonto.fml
:: Utworzony: 25.02.2002
:: Autor: AMA
::======================================================================================================================
:: Zawartosc:  Formuly obslugi redakcji symbolu konta analitycznego
::======================================================================================================================

:: UWAGA: NIE PRENIESIONE FORMUŁY ml*.fml (wywołania) - do zrobienia


\be_konto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [7.53]
:: OPIS: Formula przed redakcja symbolu konta.
::       Ustala wzorzec dla pola (zmienna ROZNE.WZ_KON).
::       Uruchamia dodatkowa formule przed redakcja (opcjonalnie).
::   WE: _a: akronim zmiennej lub formula do wykonania przed redagowaniem
::       _b: akronim pola
::       _c: formula do wykonania przed redagowaniem dla zmiennej
::           innej niz KONTO
::  OLD: \be_konto/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
ROZNE.ROKKON:={? var_pres('anal_rok')>0 & #anal_rok<>0
                 || anal_rok
                 |? SSTALE.AR
                 || SSTALE.AR
                 || null
                 ?};
{? PAR_SKID.get(18)<>'N'
|| KH.win_sel('WER');
   SKID_RBK.win_sel('SLO_SLR'); SKID_RBK.win_edit('RED_RACH');
   ROZNE.KKBAN:=1;
   {? ROZNE.ROKKON=null || return(1) ?};
   ROZNE.SZUK:=0;
   _vk:=fld();
   ROZNE.WZ_KON:=exec('ust_wz','edkonto',_vk);
   {? _>1 & _a='KONTO' & 1+_b='K'
   || _vf:='{? KONTO.K'+(_b+1)+'_BE<>\'\''
          +'|| ($(KONTO.K'+(_b+1)+'_BE))()'
          +'|| 1 ?}'; ($(_vf))()
   |? _=3 & (_a='PAR_SQL' | _a='SER_KOR' | _a='KOSZTY') & type_of(_c)=3
   || (_c)()
   |? type_of(_a)=3
   || (_a)()
   || 1
   ?}
|| {? type_of(_a)=3
   || (_a)()
   || 1
   ?}
?}


\wz_konto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [7.53]
:: OPIS: Formula na wzorzec dla symbolu konta.
::   WE: _a: akronim tabeli, _b: akronim pola
::  OLD: \wz_konto/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
:: [rr] UWAGA. Dla pol zlaczeniowych typu KK wzorzec jest '' inaczej nie da sie wyzerowac juz wprowadzonego konta
_v:='';
{? ~(_a='KK' & cur_tab().name()<>'kontakos' & cur_tab().name()<>'zeskont') & PAR_SKID.get(18)<>'N' &
   ~(_a='KK' & (cur_tab().name()='kontakos' | cur_tab().name()='zeskont') & KK.ROK_F=null)
|| {? ROZNE.SZUK
   || ROZNE.ROKKON:={? var_pres('anal_rok')>0 & #anal_rok<>0
                    || anal_rok
                    |? SSTALE.AR
                    || SSTALE.AR
                    || ROK_F.ref()
                    ?};
      ''
   || _f:='konto:='+_a+'.'+_b; ($(_f))();
      _vsynt:=ROZNE.ROKKON().SYNT;
      _v:=ROZNE.WZ_KON;
      {? +konto>=_vsynt & (get_cpos()<=_vsynt+1 | var_pres('wb_knt')>0)
      || _vks:=_vsynt+konto;
         _vks:=form(_vks);
         _v:=exec('ust_wz','edkonto',_vks)
      ?};
      {? _v<>ROZNE.WZ_KON
      || _pos1:=konto*' ';
         _pos2:=konto*'?';
         {? _pos1<>0 & ROZNE.ROKKON().SEP<>' '|| konto:=(_pos1-1)+konto ?};
         {? _pos2<>0 & ~(get_cpos()=2 & 1+konto='?' & _v<>ROZNE.WZ_KON) || konto:=(_pos2-1)+konto ?};
         {? _pos1 | _pos2
         || _f:=_a+'.'+_b+':=konto'; ($(_f))()
         ?};
         ROZNE.WZ_KON:=_v
      ?};
      &konto; VAR_DEL.delete('wb_knt');
      _v
   ?}
|| ''
?}


\f3_konto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [7.53]
:: OPIS: Formula na F3, wyswietla odpowiedni slownik.
::   WE: _a: akronim tabeli, _b: akronim pola
::       [_c: 0 - wymuszone redagowanie przez drzewo, 1 - wymuszone redagowanie przez slowniki]
:: OPIS: gedk1 - sposob redakcji konta (trzeci parametr dla \f3konto):
::          0 - redagowanie przez drzewo;
::          1 - redagowanie przez slowniki
::       gedk2 - pozycja kursora
::  OLD: \f3_konto/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a<>'KK' | (_a='KK' & KK.ROK_F<>null)
|| _vsynt:=ROZNE.ROKKON().SYNT; _vsep:=ROZNE.ROKKON().SEP;
   gedk2:=get_cpos();
:: Jezeli redakcja bez drzewa
:: lub pozycja kursora na analityce i niewymuszone redagowanie przez drzewo
:: lub wymuszone redagowanie przez slowniki
   _f:='konto:='+_a+'.'+_b; ($(_f))();
   _hasA:=exec('isan','edkonto',konto);
   {? PAR_WYDR.REDANTRE=0 | ((gedk2>_vsynt & _hasA) & (_<3 | _c=1)) | (_>2 & _c=1)
   || gedk1:=1
:: Jezeli redakcja przez drzewo
   || gedk1:=0
   ?};
   {? _vsep=' ' || konto+=' ' ?};
   {! |?
      _f3konto:=exec('f3konto','edkonto',_a,_b,gedk1,konto);
      {? _f3konto
      || {? _f3konto=1
         || _f:=_a+'.'+_b+':=konto'; ($(_f))();
            set_cpos(gedk2)
         ?}; 0
      || 1
      ?}
   !}
?};
VAR_DEL.delete('gedk1','gedk2','konto');
1


\f3konto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [7.53]
:: OPIS: Formula na F3, wyswietla odpowiedni slownik.
::   WE: _a: akronim tabeli, _b: akronim pola
::       [_c: 0 - wymuszone redagowanie przez drzewo, 1 - wymuszone redagowanie przez slowniki]
::       [_d: symbol konta do ustawienia kursora]
::  OLD: \f3konto/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
_vsynt:=ROZNE.ROKKON().SYNT; _vsep:=ROZNE.ROKKON().SEP;
_interm:={? exec('interm','#system') | PAR_SKID.get(18)='S' || 1 || 0 ?};
:: Ustalenie zmiennej konto
:: Jezeli podano 4 parametr (symbol konta) to ustawia kursor na koncu pola
{? _>3 & +_d
|| konto:=_d
|| _f:='konto:='+_a+'.'+_b; ($(_f))()
?};
:: Jezeli redakcja bez drzewa
:: lub pozycja kursora na analityce i niewymuszone redagowanie przez drzewo
:: lub wymuszone redagowanie przez slowniki
{? gedk1
|| _vs:=0;
   KS.clear(); KS.index('SYM'); KS.prefix(ROZNE.ROKKON);
   KOM.index('ROK'); KOM.prefix(ROZNE.ROKKON);
   KOM.win_sel('SLO'); KOM.hdr_sel(); KOM.hdr_sel(' (%1)'@[ROZNE.ROKKON().NAZ]);
   BUD.clear(); BUD.index('KS');
   _va:=obj_new(10); {! _i:=1..10 |! _va[_i]:=0 !};
   _i:=0;
:: Jezeli kursor jest w obrebie znakow syntetyki lub konto nie ma analityki
   {? gedk2<={? _vsep=',' || _vsynt || _vsynt+1 ?} | (gedk2>_vsynt & ~exec('isan','edkonto',konto))
   || KOM.find_key(_vsynt+konto);
:: Jezeli redakcja przez slownik
      {? KOM.select(,1,,{? PAR_WYDR.REDANTRE=0 || 'R' || '' ?})
:: Jezeli zatwierdzono wybor
      || {? gedk1
         || konto:=KOM.KS().SYM;
            {? _interm & exec('isan','edkonto',konto) & konto+1<>_vsep & _vsep<>',' || konto+=_vsep ?};
            gedk2:=_vsynt+1;
            {? _vsep<>',' || gedk2+=1 ?};
            return(1)
:: Jezeli zmiana prezentacji
         || konto:=KOM.KS().SYM;
            {? _interm & exec('isan','edkonto',konto) & konto+1<>_vsep & _vsep<>',' || konto+=_vsep ?};
            ROZNE.ED:=1;
            return(0)
         ?}
:: Jezeli rezygnacja z redagowania
      || return(2)
      ?}
:: Jezeli kursor jest w obrebie analityki
   || KS.prefix(ROZNE.ROKKON,_vsynt+konto);
      {? KS.first()
      || BUD.prefix(KS.ref);
         {? BUD.first()
         || {! |?
               _i+=1;
               {? _i=1
               || {? _vsep=','
                  || _va[1]:=_vsynt+1+BUD.SLU().SLU().DL
                  || _va[1]:=_vsynt+2+BUD.SLU().SLU().DL
                  ?}
               || {? _vsep=','
                  || _va[_i]:=_va[_i-1]+BUD.SLU().SLU().DL
                  || _va[_i]:=_va[_i-1]+BUD.SLU().SLU().DL+1
                  ?}
               ?};
               BUD.next()
            !};
            _i:=0;
            _cpos:=gedk2;
            {! |?
               _i+=1; _i<10 & _va[_i+1]<>0 & _cpos>{? _vsep=',' || _va[_i]-1 || _va[_i] ?}
            !};
            BUD.first();
            _ii:=0;
            {! |? _ii+=1; _ii<_i & BUD.next() !};
            UDT.cntx_psh(); ZL.cntx_psh(); hdr_slo:='Analityka '+$BUD.POZ+' poziomu';
            BUD.SLU().SLU();
            SLO.clear();
            SLO.index('SL_TR'); SLO.prefix(SLU.ref);
            SLO.index('SL'); SLO.prefix(SLU.ref);
            SLO.win_sel('EDKON');
            SLO.hdr_sel();
            SLO.hdr_sel('Analityka %1 poziomu'@[$BUD.POZ]);
            {? (_i>1 & _i<10 & (_va[_i+1]=0 | (_interm & +konto<_va[_i]))) | _i=10
            || _vfk:=konto+(+konto-(_va[_i-1]-{? _vsep=',' || 1 || 0 ?}))
            |? _i=1 & (_va[_i+1]=0 | (_interm & +konto<_vsynt+2+BUD.SLU().SLU().DL))
            || _vfk:=konto+(+konto-_vsynt-1)
            || _vfk:=((_va[_i]-1)+konto)+BUD.SLU().SLU().DL
            ?};
            {? _vpos:=_vfk*' '; _vpos>0 || _vfk:=_vpos+_vfk ?};
::Poczatek modyfikacji dla Maclex Fiks 04-10-2009 AK [1120]
            __refslo:={? SLO.find_key(form(_vfk)) || SLO.ref || null ?};
::Koniec modyfikacji dla Maclex Fiks
            {? SLO.select(,1,,{? PAR_WYDR.REDANTRE=0 || 'R' || '' ?})
            || {? _i=1
               || {? _va[_i+1]=0
                  || {? _vsep=','
                     || _v1:=_vsynt+konto
                     || _v1:=(_vsynt+1)+konto
                     ?};
                     konto:=_v1+SLO.KOD;
                     {? gedk1 || gedk2:=_va[_i] ?}
                  || {? _vsep=','
                     || _v1:=_vsynt+konto;
                        {? gedk1 || gedk2:=_va[_i] ?}
                     || _v1:=(_vsynt+1)+konto;
                        {? gedk1 || gedk2:=_va[_i]+1 ?}
                     ?};
                     _v2:=(_va[_i]-1)-konto;
                     konto:=_v1+SLO.KOD+_v2
                  ?}
               || {? _i=10 | _i<10 & _va[_i+1]=0
                  || {? _vsep=','
                     || _v1:=(_va[_i-1]-1)+konto
                     || _v1:=(_va[_i-1])+konto
                     ?};
                     konto:=_v1+SLO.KOD;
                     {? gedk1 || gedk2:=_va[_i] ?}
                  || {? _vsep=','
                     || _v1:=(_va[_i-1]-1)+konto;
                        {? gedk1 || gedk2:=_va[_i] ?}
                     || _v1:=(_va[_i-1])+konto;
                        {? gedk1 || gedk2:=_va[_i]+1 ?}
                     ?};
                     _v2:=(_va[_i]-1)-konto;
                     konto:=_v1+SLO.KOD+_v2
                  ?}
               ?};
               {? _interm & _va[_i+1]<>0 & konto+1<>_vsep & _v2='' & _vsep<>',' || konto+=_vsep ?};
:: Jezeli zatwierdzono wybor
               {? gedk1
               || UDT.cntx_pop(); ZL.cntx_pop(); &hdr_slo;
                  {? _vs || ROZNE.ED:=1 ?};
                  &__refslo;
                  {? SLO.f_active()>0 || SLO.f_clear(1) ?};
                  return(1)
:: Jezeli zmiana prezentacji
               || UDT.cntx_pop(); ZL.cntx_pop(); &hdr_slo;
                  &__refslo;
                  {? SLO.f_active()>0 || SLO.f_clear(1) ?};
                  return(0)
               ?}
:: Jezeli rezygnacja z redagowania
            || UDT.cntx_pop(); ZL.cntx_pop(); &hdr_slo;
               &__refslo;
               {? SLO.f_active()>0 || SLO.f_clear(1) ?};
               return(2)
            ?}
         ?}
      ?}
   ?}
:: Jezeli redakcja z drzewem
|| exec('tt_plkon','edkonto',_a,_b,konto)
?}


\next_bud
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MP [22.26]
:: OPIS: Sprawdza, czy dla wpisanego konta istnieje dalsza analityka
::   WE:  _a - zmienna _vsynt
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_ret:=0;
_vsynt:=_a;
KS.prefix(ROZNE.ROKKON,_vsynt+konto);
{? KS.first()
|| BUD.prefix(KS.ref);
   {? BUD.first()
   || _ret:=1
   ?}
?};
_ret


\ae_konto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [7.53]
:: OPIS: Po redakcji konta.
::   WE: _a: parametr przekazany do formuly po redakcji przez runtime,
::           czy zakonczono redagowanie: 1 - tak, 0 - nie
::       _b: akronim tabeli, _c: akronim pola
::       _d: tryb wypelniania: 0 - niewymagane wypelnienie pola;
::           1 - wymagane wypelnienie pola
::       _e: tryb wypelniania: 1 - wymagany pelny symbol konta;
::           2 - maska konta; 3 - prefix konta
::       _f: tryb wypelniania: 1 - wymagana syntetyka,
::           0 - niewymagana syntetyka
::       _g: formula do wykonania po redakcji (opcjonalny)
::       Podanie parametrow od _d do _f nie jest wymagane tylko dla
::       obslugi redakcji konta przez zmienna PAR_SQL.
::  OLD: \ae_konto/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
{? _b<>'KK' | (_b='KK' & KK.ROK_F<>null)
|| _vsep:=ROZNE.ROKKON().SEP;
   {? KS.index('SYM'); KS.prefix(ROZNE.ROKKON); ~KS.first()
   || {? ROZNE.ROKKON=SSTALE.AR
      || FUN.info('Nie zdefiniowano planu kont w bieżącym roku bilansowym.'@)
      || ROK_F.cntx_psh(); ROZNE.ROKKON();
         {? ROK_F.get()
         || FUN.info('Nie zdefiniowano planu kont w roku bilansowym %1.'@[ROK_F.NAZ])
         || FUN.info('Brak roku obrachunkowego.'@)
         ?};
         ROK_F.cntx_pop()
      ?};
      _a:=0
   |? _a & _b<>'PAR_SQL'
   || {? _b='KONTO' & 1+_c='K'
      || _vf:='KONTO.K'+(_c+1)+'_WYM'; _d:=($(_vf))();
         _vf:='KONTO.K'+(_c+1)+'_RODZ'; _e:=($(_vf))();
         _vf:='KONTO.K'+(_c+1)+'_SYNT'; _f:=($(_vf))()
      || {? _>3 & type_of(_d)=0 || _d:=0 ?};
         {? _>4 & type_of(_e)=0 || _e:=1 ?};
         {? _>5 & type_of(_f)=0 || _f:=0 ?}
      ?};
      _v_msg1:='Nie podano symbolu konta syntetycznego.'@;
      _v_msg2:='Błędny symbol konta syntetycznego.'@;
      _v_msg3:='Brak konta syntetycznego o podanych początkowych znakach.'@;
      _v_msg4:='Błędny symbol konta analitycznego.'@;
      _v_msg5:='Błędna budowa konta dla budżetu.'@;
      _vsynt:=ROZNE.ROKKON().SYNT;
      konto:=fld();
      {? konto='' & _d
      || FUN.info('Nie podano symbolu konta analitycznego.'@); _a:=0
      ?};
      {? _e=1
      || {? konto<>''
         || {? _vs:=form(_vsynt+konto); +_vs=_vsynt
            || {? KS.index('SYM'); KS.prefix(ROZNE.ROKKON,_vs); KS.first()
               || {? +konto>_vsynt
                  || konto:=exec('uzup_kon','edkonto',konto)
                  ?};
                  {? ~exec('akc_kont','edkonto',konto)
                  || _vf:=_b+'.'+_c+':=konto'; ($(_vf))()
                  || FUN.info(_v_msg4); _a:=0
                  ?}
               || FUN.info(_v_msg2); _a:=0
               ?}
            || FUN.info(_v_msg1); _a:=0
            ?}
         ?}
      |? _e=2
      || {? konto=''
         || {? ~_d
            || konto:=35*'?';
               _vf:=_b+'.'+_c+':=konto'; ($(_vf))()
            ?}
         || {? _vs:=form(_vsynt+konto); +_vs=_vsynt & _vs*'?'=0
            || {? KS.index('SYM'); KS.prefix(ROZNE.ROKKON,_vs); KS.first()
               || {? PAR_SKID.get(18)<>'T' | (PAR_SKID.get(18)='T' & exec('interm','#system'))
                  || BUD.prefix(KS.ref);
                     {? BUD.first()
                     || BUD.first();
                        _ii:=0;
                        _lng:=+konto;
                        {! _j:=1.._vsynt
                        |! {? _ii+_j>_lng || konto+=' ' ?}
                        !};
                        _ii+=_vsynt;
                        {!
                        |? {? _ii+1>_lng & _vsep<>',' || konto+=_vsep ?};
                           {! _j:=1..BUD.SLU().SLU().DL
                           |! {? _ii+{? _vsep<>',' || 1 || 0 ?}+_j>_lng || konto+=' ' ?}
                           !};
                           _ii+=BUD.SLU().SLU().DL+{? _vsep<>',' || 1 || 0 ?};
                           BUD.next()
                        !}
                     ?}
                  ?};
                  _vk:='';
                  {! _i:=1..(+konto)
                  |! {? 1+konto=' ' || _vk+='?' || _vk+=1+konto ?};
                     konto:=1-konto;
                     _i+=1
                  !};
                  KS.prefix(ROZNE.ROKKON,_vsynt+_vk);
                  {? KS.first() & +form(_vsynt+_vk)=_vsynt
                  || BUD.prefix(KS.ref);
                     {? _vsep=','
                     || _ii:=0;
                        {? BUD.first()
                        || _ii:=_vsynt;
                           {! |? _ii+=BUD.SLU().SLU().DL; BUD.next() !}
                        ?};
                        _vk+=(_ii-+_vk)*'?'
                     || {? BUD.last()
                        || {? +_vk=_vsynt
                           || BUD.first();
                              {! |? _vk+=_vsep+BUD.SLU().SLU().DL*'?'; BUD.next()!}
                           || {? _vk+1=_vsep
                              || BUD.first();
                                 _ii:=_vsynt;
                                 {! |? _ii+=BUD.SLU().SLU().DL+1; BUD.next() !};
                                 BUD.last();
                                 {? +_vk<_ii || {! _jj:=1.._ii-+_vk |! _vk+='?' !} ?}
                              || _ii:=0; _vk1:=_vk;
                                 {! _i:=1..BUD.POZ
                                 |! _pos:=_vk1*_vsep;
                                    _ii+=_pos;
                                    _vk1:=_pos-_vk1
                                 !};
                                 _vk+=(BUD.SLU().SLU().DL-(+_vk)+_ii)*'?'
                              ?}
                           ?}
                        ?}
                     ?};
                     {? ~(_vk*'?') & exec('akc_kont','edkonto',_vk)
                     || FUN.info(_v_msg4); _a:=0
                     ?}
                  || _vk+=(35-+_vk)*'?'
                  ?};
                  {? _a
                  || {? ~exec('isan','edkonto',_vk) || _vk:=_vsynt+_vk ?};
                     konto:=_vk;
                     _vf:=_b+'.'+_c+':=konto'; ($(_vf))()
                  ?}
               || FUN.info(_v_msg2); _a:=0
               ?}
            |? _vs:=form(_vsynt+konto);
               {? _vs*'?'<>0 || _vs:=((_vs*'?')-1)+_vs ?}; +_vs<_vsynt & ~_f
            || KS.index('SYM'); KS.prefix(ROZNE.ROKKON);
               {? KS.find_key(_vs)
               || konto+=(35-+konto)*'?';
                  _vf:=_b+'.'+_c+':=konto'; ($(_vf))()
               || FUN.info(_v_msg3); _a:=0
               ?}
            || {? _f
               || FUN.info(_v_msg1); _a:=0
               || konto+=(35-+konto)*'?';
                  _vf:=_b+'.'+_c+':=konto'; ($(_vf))()
               ?}
            ?}
         ?}
      |? _e=3
      || {? konto<>''
         || {? _vs:=form(_vsynt+konto); +_vs=_vsynt
            || {? KS.index('SYM'); KS.prefix(ROZNE.ROKKON,_vs); KS.first()
               || {? konto:=form(konto); konto+1=_vsep
                  || {! |? konto:=konto-1; konto+1=_vsep | konto+1=' ' !}
                  ?};
                  {? ~exec('isan','edkonto',konto) || konto:=_vsynt+konto ?};
                  _vf:=_b+'.'+_c+':=konto'; ($(_vf))()
               || FUN.info(_v_msg2); _a:=0
               ?}
            |? _vs:=form(_vsynt+konto); +_vs<_vsynt & ~_f
            || KS.index('SYM'); KS.prefix(ROZNE.ROKKON);
               {? KS.find_key(_vs)
               || _vf:=_b+'.'+_c+':=konto'; ($(_vf))()
               || FUN.info(_v_msg3); _a:=0
               ?}
            || {? _f || FUN.info(_v_msg1); _a:=0 ?}
            ?}
         ?}
      ?};
      {? _a
      || {? _b='KONTO' & 1+_c='K'
         || _vf:='{? KONTO.K'+(_c+1)+'_AE<>\'\''
                +'|| ($(KONTO.K'+(_c+1)+'_AE))()'
                +'|| 1 ?}';
               _a:=($(_vf))()
         || {? _=7 & type_of(_g)=3 || _a:=(_g)() ?}
         ?}
      || _a:=0
      ?}
   |? _a & _b='PAR_SQL'
   || {? _vsep<>','
      || _vf:='_str:=PAR_SQL.'+_c+';'+
              '{! _i:=1..+PAR_SQL.'+_c+
              '|? (_str+1)=\' \' | (_str+1)=_a'+
              '|! _str:=_str-1'+
              '!}; '+
              'PAR_SQL.'+_c+':=_str';
         ($(_vf))(_vsep)
      ?};
      _vf:='{? PAR_SQL.'+_c+'+1<>\'%\' || PAR_SQL.'+_c+'+=\'%\' ?}'; ($(_vf))();
      _a:=1
   || _a:=0
   ?};
   {? var_pres('konto')>=0 || &konto ?};
   _a
|| {? _b<>'KK'
   || 1
   || {? (_b='KK' & KK.ROK_F=null) || _a ?}
   ?}
?}


\ust_wz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [7.53]
:: OPIS: Formula ustala wzorzec konta.
::   WE: _a: symbol konta.
::   WY: wzorzec dla konta.
::  OLD: \ust_wz/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
_vsynt:=ROZNE.ROKKON().SYNT;
_interm:={? exec('interm','#system') | PAR_SKID.get(18)='S' || 1 || 0 ?};
_v:=_vsynt*'x'+ {? _interm || '' || '$' ?};
{? +_a
|| _vks:=_vsynt+_a;
   {? KS.index('SYM'); KS.prefix(ROZNE.ROKKON,_vks); _interm=0 & KS.first() & _vks=KS.SYM
   || {? BUD.index('KS'); BUD.prefix(KS.ref); BUD.first()
      || _vsep:=ROZNE.ROKKON().SEP;
         {? _vsep=',' || _vsep:='|'
         |? _vsep='\\' || _vsep:='\\\\'
         || _vsep:='\\'+_vsep
         ?};
         _v:=_vsynt*'x';
         {! |? _v+=_vsep+BUD.SLU().SLU().DL*'x'; BUD.next() !};
         _v+='$'
      ?}
   ?}
?};
_v


\uzup_kon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [7.53]
:: OPIS: Formula uzupelnia symbol analityki ostatniego poziomu.
::   WE: _a: symbol konta.
::   WY: pelny symbol konta.
::  OLD: \uzup_kon/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
_vsynt:=ROZNE.ROKKON().SYNT;
_vsep:=ROZNE.ROKKON().SEP;
KS.prefix(ROZNE.ROKKON,_vsynt+_a);
{? KS.first() ||
   _vl:=_vsynt;
   BUD.prefix(KS.ref);
   {? BUD.first() ||
      {! |? _vl+=BUD.SLU().SLU().DL;
            {? _vsep<>',' || _vl+=1 ?};
            BUD.next()
      !}
   ?};
   {? +_a<>_vl & +_a>(_vl-BUD.SLU().SLU().DL) & +_a<_vl ||
      BUD.SLU().SLU();
      SLO.clear(); SLO.index('SL'); SLO.prefix(BUD.SLU().SLU);
      {? SLO.find_key(_a+(+_a-_vl+BUD.SLU().SLU().DL)) ||
         _a:=(_vl-BUD.SLU().SLU().DL)+_a;
         _a+=SLO.KOD
      ?}
   ?}
?};
_a


\cutkon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [7.53]
:: OPIS: Formula usuwa z konca znaki stale wzorca, spacje lub znaki maski '?' lub odcina czesc
::       od pierwszego wystapienia spacji lub znaku maski '?'
::   WE: _a: symbol konta lub jego fragment
::       _b: czy usuwac znaki maski: 0 - nie, 1 - tak
::       _c: czy usunac od pierwszego wystapienia spacji lub znaku maski '?': 1 - tak (opcjonalny)
::   WY: symbol konta.
::  OLD: \cutkon/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
_vsep:=ROZNE.ROKKON().SEP;
{? _vsep=',' || _vsep:=' ' ?};
{! |? _a+1=' ' | (_a+1=_vsep & _a+2<>2*_vsep) | {? _b & _a+1='?' || 1 || 0 ?} |! _a:=_a-1 !};
{? _>2 & _c
|| {? ROZNE.ROKKON().SEP<>' '
   || {? _a*' ' | _a*'?'
      || _p:=_a*' '; {? _p || _a:=(_p-1)+_a ?};
         _p:=_a*'?'; {? _p || _a:=(_p-1)+_a ?}
      ?}
   || {? _a*'?'
      || _p:=_a*'?'; {? _p || _a:=(_p-1)+_a ?};
         _a:=form(_a)
      ?}
   ?}
?}; _a


\isan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [7.53]
:: OPIS: Formula sprawdza, czy podane konto syntetyczne ma analityke
::   WE: _a: symbol konta
::   WY: 0 - nie ma analityki, 1 - ma analityke
::  OLD: \isan/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
_v:=0;
_vsynt:=ROZNE.ROKKON().SYNT;
{? +_a>=_vsynt
|| _vs:=_vsynt+_a;
   {? KS.index('SYM'); KS.prefix(ROZNE.ROKKON,_vs); KS.first()
   || {? BUD.index('KS'); BUD.prefix(KS.ref); BUD.first() || _v:=1 ?}
   ?}
?};
_v


\bs_konto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [7.62]
:: OPIS: Formula przed Szukaj dla okienek z kontem
::  OLD: \bs_konto/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
ROZNE.SZUK:=1; 1


\akc_kont
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [8.50]
:: OPIS: Sprawdza, czy analityka konta zostala poprawnie wypelniona.
::   WE: _a: konto do sprawdzenia
::   WY: 0 - nie znaleziono, SLO.ref()
::  OLD: \akc_kont/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
ROZNE.ROKKON:={? var_pres('anal_rok')>0 & #anal_rok<>0
              || anal_rok
              |? SSTALE.AR
              || SSTALE.AR
              || ROK_F.ref()
              ?};
_vsynt:=ROZNE.ROKKON().SYNT;
_vsep:=ROZNE.ROKKON().SEP;
{? form(_a)<>'' & _a*'?'=0 &
      {? (_a*_vsep) & (_vsep<>',') || (_a*_vsep-1)+_a=_vsynt+_a
      |? _vsep=',' || +(_vsynt+_a)<=+_a || (_a=_vsynt+_a) & (+_a=_vsynt) ?}
|| _syntet:=_vsynt+_a;
   KS.index('SYM'); KS.prefix(ROZNE.ROKKON);
   {? KS.find_key(_syntet) & (+_syntet=_vsynt)
   || _blad:=_g:=0;
      BUD.index('KS'); BUD.prefix(KS.ref);
      {? BUD.first
      || {!|? _g+=BUD.SLU().SLU().DL; BUD.next() !}
      || _g:=0
      ?};
      _f:={? _vsep=',' || 0 || BUD.size() ?};
      _h:=_f+_g+(+_syntet);
      {? +_h<>+_a || _blad:=1 ?};
      {? ~_blad & BUD.first()
      || _k:=_a; _for:=_vsynt; _k1:=_a;
         {! |?
             _l:=BUD.SLU().SLU().DL;
             {? _vsep=',' || _i:=_for || _i:=_for+1 ?};
             _for:=_l;
             {? _i>0
             || _k:=_i-_k; _aa:=_l+_k;
                {? _vsep<>',' & ~(_k1*_vsep) || return(1) || _k1:=(_k1*_vsep)-_k1 ?};
                {? ~exec('ana_find','edkonto',_aa) || _blad:=1 ?}
             || _blad:=1
             ?};
             {? ~_blad
             || {? BUD.next || 1 || {? +_k>_l || _blad:=1 ?}; 0 ?}
             || 0
             ?}
         !}
      |? +_a>_vsynt
      || _blad:=1
      || _blad
      ?}
   || _blad:=1
   ?};
   _blad>0
|| 1
?}


\ana_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [8.50]
:: OPIS: Odnajduje SLO.ref() dla _a-tego poziomu analityki konta.
::   WE: _a: kod poziomu analityki
::   WY: 0 - nie znaleziono, 1 - SLO.ref()
::  OLD: \ana_find/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
SLO.index('SL'); SLO.prefix(BUD.SLU().SLU);
{? +_a & SLO.find_key(_a) & (_a=SLO.KOD) || SLO.ref() || 0 ?}


\rok_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [8.50]
:: OPIS: Odnajduje ROK_F.ref().
::   WE: _a: data
::   WY: 0 - nie znaleziono, 1 - ROK_F.ref()
::  OLD: \rok_find/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
OKRO_F.cntx_psh();
OKRO_F.index('KON'); OKRO_F.prefix(REF.FIRMA);
_r:={? _a<>date(0,0,0) & OKRO_F.find_ge(_a) & _a>=OKRO_F.POCZ & _a<=OKRO_F.KON
    || OKRO_F.ROK
    || null
    ?};
OKRO_F.cntx_pop();
_r


\wart_an
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [8.50]
:: OPIS: Wyswietla wartosci analityk konta
::  OLD: \wart_an/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
BUD.get(); BUD.SLU().SLU();
SLO.index('SL'); SLO.prefix(SLUAPPL.SLU);
SLO.hdr_sel(); SLO.hdr_sel(SLUAPPL.SLU().NAZ);
SLO.select();
SLO.hdr_sel()


\tt_plkon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [2006]
:: OPIS: Tworzy tabele tymczasowa do obslugi redagowania konta za pomoca struktury hierarchicznej
::   WE: _a: akronim tabeli; _b: akronim pola
::       [_c: symbol konta do ustawienia kursora]
::  OLD: \tt_plkon/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
TT_PLKON:=tab_tmp(2,'TREE_REF','TREE_REF',,'AN','STRING[35]',,'KONTO','STRING[60]','Konto','KS',
   'STRING[6]',,'POZ','INTEGER',,'OP','STRING[60]','Opis','ROZR','INTEGER',);
tt_ndx1:=TT_PLKON.index('?');
tt_ndx2:=TT_PLKON.ndx_tmp(,0,'TREE_REF',,,'KONTO',,);
{? ~ROZNE.ROKKON || ROZNE.ROKKON:=SSTALE.AR ?};
KS.index('SYM'); KS.prefix(ROZNE.ROKKON);
{? KS.first()
|| {! |?
      TT_PLKON.TREE_REF:=0;
      TT_PLKON.AN:=TT_PLKON.KS:=KS.SYM;
      TT_PLKON.ROZR:={? KS.ROZR='Z' || 0 || 1 ?};
      TT_PLKON.KONTO:=KS.SYM;
      TT_PLKON.POZ:=0; TT_PLKON.OP:=KS.NAZ;
      TT_PLKON.add();
      KS.next()
   !}
?};
_wsel:=TT_PLKON.mk_sel('Plan kont (%1)'@[ROZNE.ROKKON().NAZ],'P',0,'tt_plan_kont',,,,1);
TT_PLKON.win_fld(_wsel,,'KONTO',,,20);
TT_PLKON.win_fld(_wsel,,'OP');
TT_PLKON.win_sel(_wsel);
TT_PLKON.tr_fml(_wsel,"exec('zr','edkonto',_a)","exec('is_ntlev','edkonto',TT_PLKON.ref())",
   "exec('is_n_lev','edkonto',TT_PLKON.POZ,TT_PLKON.KS)");
TT_PLKON.win_act(_wsel,,'Formuła','Wybierz'@@,,,"konto:=wb_knt:=TT_PLKON.AN; gedk2:=+konto+1; sel_exit()",,1,,,,'W');
TT_PLKON.win_act(_wsel,,'Formuła','Zmiana p&rezentacji'@@,,'Zmiana sposobu prezentacji na słowniki'@,
   "konto:=TT_PLKON.AN; gedk2:=+konto+1; gedk1:=1; sel_exit()",,,,,,'R');
TT_PLKON.win_act(_wsel,,'Rekord',,,,"
   {? KS.prefix(ROZNE.ROKKON,TT_PLKON.KS); KS.first()
   || exec('op_konta','konto',TT_PLKON.AN,KS.ref(),40); exec('ka_opis','konto')
   ?}; 0");
TT_PLKON.win_act(_wsel,,'Kolejność');
TT_PLKON.first();
{? _>2 & +_c
|| _vk:=_c
|| _f:=_a+'.'+_b; _vk:=($(_f))()
?};
{? +_vk || exec('pos_kon','edkonto',_vk) ?};
TT_PLKON.index(tt_ndx2);
{? ~TT_PLKON.select(,1) || _f:='konto:='+_a+'.'+_b; ($(_f))() ?};
VAR_DEL.delete('TT_PLKON','tt_ndx1','tt_ndx2');
~gedk1


\pos_kon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [2006]
:: OPIS: Rozwija analityki konta do poziomu wynikajacego z budowy symbolu konta, ustawia w tabeli
::       tymczasowej rekord biezacy zgodnie z symbolem konta
::   WE: _a: symbol konta
::  OLD: \pos_kon/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
{? +_a
|| {? +_a<=(ROZNE.ROKKON().SYNT+1)
   || TT_PLKON.find_key(0,ROZNE.ROKKON().SYNT+_a)
   || {? TT_PLKON.find_key(0,ROZNE.ROKKON().SYNT+_a)
      || TT_PLKON.index(tt_ndx1);
         _k:=_a:=exec('cutkon','edkonto',_a,1,1);
         _poz:=_pozg:=ROZNE.ROKKON().SYNT;
         {? ROZNE.ROKKON().SEP<>',' || _poz+=1 ?};
         _i:=0;
         {! |? _poz |!
            _treeref:=#TT_PLKON.ref();
            exec('zr','edkonto',1);
            _k:=_poz-_k;
            {? ROZNE.ROKKON().SEP<>','
            || _poz:=_k*ROZNE.ROKKON().SEP
            || _poz:=exec('is_n_lev','edkonto',_i,ROZNE.ROKKON().SYNT+_a); _i+=1;
               {? _pozg+_poz>=+_a || _poz:=0 ?}
            ?};
            {? _poz
            || _pozg+=_poz
            || _pozg:=+_a
            ?};
            TT_PLKON.find_key(_treeref,_pozg+_a)
         !}
      ?}
   ?}
?}


\zr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [2006]
:: OPIS: Rozwija analityki konta (dodaje rekordy do tabeli tymczasowej) do kolejnego poziomu
::   WE: _a: tryb pracy: 0 - zwijanie; 1 - rozwijanie
::  OLD: \zr/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a
|| {? ~exec('is_ntlev','edkonto',TT_PLKON.ref())
   || exec('fill_an','edkonto',TT_PLKON.KS,TT_PLKON.POZ+1)
   ?}
|| exec('del_an','edkonto',TT_PLKON.ref(),TT_PLKON.POZ+1)
?}


\fill_an
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [2006]
:: OPIS: Dodaje do tabeli tymczasowej rekordy dla kolejnego poziomu
::   WE: _a: symbol konta syntetycznego
::       _b: numer dodawanego poziomu
::  OLD: \fill_an/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
_van:=TT_PLKON.AN; _vkon:=TT_PLKON.KONTO; _vref:=TT_PLKON.ref();
_vsep:=ROZNE.ROKKON().SEP; {? _vsep=',' || _vsep:='' ?};
KS.cntx_psh(); BUD.cntx_psh(); KS.index('SYM'); KS.prefix(ROZNE.ROKKON,_a);
{? KS.first()
|| BUD.index('KS');
   _wzp:='';
   {? MLEX.FIKSB & _b>1
   || BUD.prefix(KS.ref(),_b-1);
      {? BUD.first || _wzp:=BUD.SLU().SLU().WZ ?}
   ?};
   BUD.prefix(KS.ref(),_b);
   {? BUD.first()
   || SLO.index('SL'); SLO.prefix(BUD.SLU().SLU);
      {? SLO.first()
      || {! |?
            TT_PLKON.TREE_REF:=#_vref;
            TT_PLKON.KS:=_a;
            TT_PLKON.AN:=_van+_vsep+SLO.KOD; TT_PLKON.KONTO:=form(_vkon+_vsep+SLO.KOD);
            TT_PLKON.POZ:=_b;
            TT_PLKON.ROZR:={? KS.ROZR='Z' || 1 || 0 ?};
            TT_PLKON.OP:=SLO.TR;
            TT_PLKON.add();
            SLO.next()
         !}
      ?}
   ?}
?};
KS.cntx_pop(); BUD.cntx_pop(); TT_PLKON.seek(_vref)


\del_an
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [2006]
:: OPIS: Usuwa z tabeli tymczasowej rekordy dla kolejnego poziomu
::   WE: _a: numer rekordu wezla, ktorego elementy usunac
::       _b: numer usuwanego poziomu
::  OLD: \del_an/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
TT_PLKON.cntx_psh();
TT_PLKON.index(tt_ndx1);
TT_PLKON.prefix(_a);
{? TT_PLKON.first()
|| {! |?
      {? TT_PLKON.POZ=_b
      || {? exec('is_ntlev','edkonto',TT_PLKON.ref())
         || exec('del_an','edkonto',TT_PLKON.ref(),_b+1); TT_PLKON.del()
         || TT_PLKON.del()
         ?}
      || TT_PLKON.next()
      ?}
   !}
?};
TT_PLKON.cntx_pop()


\is_n_lev
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [2006]
:: OPIS: Sprawdza czy jest nastepny poziom w budowie konta po poziomie przekazanym jako _a
::   WE: _a: poziom; _b: symbol konta
::   WY: 0 - brak nastepnego poziomu, liczba - dlugosc nastepnego poziomu
::  OLD: \is_n_lev/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
_ret:=0; BUD.cntx_psh(); KS.cntx_psh();
KS.index('SYM'); KS.prefix(ROZNE.ROKKON,_b);
{? KS.first()
|| BUD.index('KS');
   {? _a
   || BUD.prefix(KS.ref(),_a+1);
      {? BUD.first()
      || SLO.cntx_psh(); SLO.index('SL'); SLO.prefix(BUD.SLU().SLU);
         {? SLO.first() || _ret:=BUD.SLU().SLU().DL ?};
         SLO.cntx_pop()
      ?}
   || BUD.prefix(KS.ref);
      {? BUD.first()
      || SLO.cntx_psh(); SLO.index('SL'); SLO.prefix(BUD.SLU().SLU);
         {? SLO.first() || _ret:=BUD.SLU().SLU().DL ?};
         SLO.cntx_pop()
      ?}
   ?}
?};
BUD.cntx_pop(); KS.cntx_pop(); _ret


\edk_tree
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [2006]
:: OPIS: Zmienia sposob redagowania konta (drzewo/slowniki)
::  OLD: \edk_tree/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
sel_exit(); gedk1:=0


\is_ntlev
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [AMA] [2006]
:: OPIS: Sprawdza czy jest nastepny poziom w drzewie dla elementu przekazanego jako _a
::   WE: _a: element drzewa (reference)
::  OLD: \is_ntlev/skid_edk.fml
::----------------------------------------------------------------------------------------------------------------------
TT_PLKON.cntx_psh();
TT_PLKON.index(tt_ndx1);
TT_PLKON.prefix(_a);
_ret:=TT_PLKON.first();
TT_PLKON.cntx_pop(); _ret

:Sign Version 2.0 jowisz:1045 2023/11/28 09:39:57 02435385e38889954f6d917b0c4620d746c390e981059f4de4be96522e72357331b74ae18887803ba1b510d0a558038d74f9a29a0b68e90c6fb92b70ab530182d087ae18272f3a4d93d271bd9892288584bac295699016045ee5fe01aee3ae747dad047f3ed77908ad489a2bbf66769034b623aac69c29bc29cbfe03257745b0
