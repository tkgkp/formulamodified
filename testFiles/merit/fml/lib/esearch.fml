:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: search.fml
:: Utworzony: 22.08.2018
:: Autor: [mk] Michal Kocot
:: Systemy: Xpertis, Merit
::======================================================================================================================
:: Zawartość: Obsluga ElasicSearch
::======================================================================================================================


\load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [trocek] [20.42]
:: OPIS: Wyslanie danych w formacie json z SYNCHRO
::   WE: _a - url
::       _b - firma
::       _c - symbol przeznaczenia danych
::       _d - akronim tabeli
::       _e - ilosc rekordow
::       _f - 'T' czy kasowac sync
::       _g - 'T' czy tworzyć log
::       _h - mcl.erp
::       _i - 0 - ladowanie przyrostowe z generowanie zapisow dla tabel powiazanych,
::            1 - pelny load tego co jest w synchro
::       _j [INTEGER] - czy tworzyć plik trace
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_es:=exec('elastic','elastic');
_es.LOGTAB.erase();
_synctab:=exec('synctab','esearch','ELASTIC');
__es_usecache:=1;
exec('tabhelper','esearch');
_a:={? var_pres('_a')=type_of('') || _a || _es.ADDR ?};
_b:={? var_pres('_b')=type_of('') || _b || '___' ?};
_c:={? var_pres('_c')=type_of('') || _c || _es.SYNCHRO ?};
_d:={? var_pres('_d')=type_of('') || _d || '' ?};
_e:={? var_pres('_e')=type_of(0) & _e>0 || _e || 100 ?};
_f:={? var_pres('_f')=type_of('') || _f || 'N' ?};
_g:={? var_pres('_g')=type_of('') || _g || 'N' ?};
_h:={? var_pres('_h')=type_of('') || _h || 'mcl.erp.' ?};
{? var_pres('__sync0')>0 || obj_del(__sync0) ?};
{? var_pres('__sync1')>0 || obj_del(__sync1) ?};
{? var_pres('__sync2')>0 || obj_del(__sync2) ?};
_trace:={? var_pres('_j')=type_of(0) || _j || 1 ?};
__escache_hits:=0;
_batchSize:=50000;
_firma:=
   {? var_pres('__System')=type_of('')
   || {? __System='FIKS' | __System='IF' | __System='HOMEBANK' | __System='KASA' | __System='ESTRA' | __System='EMAG'
         | __System='PRODUKCJA' | __System='REMONTY' | __System='PROJEKTY' | __System='OBIEGI'
      || -XINFO.NAZ
      |? __System='KALI' | __System='RCP'
      || -KST.NAZWA
      |? __System='PRODUKCJA'
      || -PINFO.NAZ
      ?}
   || KST.NAZWA
   ?};
_system:={? var_pres('__Pakiet')>0 & -__Pakiet*'xpertis' || 'xpertis' || 'merit' ?};
SYNC_PD.index('SYM');
SYNC_PD.prefix();
{? SYNC_PD.find_key(_c) || _ref_pd:=SYNC_PD.ref() || return('ERROR: brak ELASTIC w definicji') ?};
_nag:=_poz:=_json:='';
_il:=0;
_logfile:='ElasticSearch_'+$SYNC_PD.tm_stamp()+'.es';
_logjfile:='TmpElasticSearch_json_'+$SYNC_PD.tm_stamp()+'.es';
_jsonfile:='LastElasticSearch_json.es';
_tracefile:='es_load_trace.es';
_logzapis:=0;
_idsync:='';
exec('init_labels','esearch');

{? var_pres('__escache')>0
|| __escache.erase()
|| __escache:=tab_tmp(1,
      'REF','STRING[16]','REF',
      'TAB','STRING[8]','TAB',
      'JSON','SYS_MEMO','JSON');
   __escache.index(__escache.ndx_tmp(,,'REF',,))
?};
{? _trace
|| {? var_pres('__estrace')>0 & _b=''
   || &__estrace;
      __estrace:=fopen(_tracefile,'bw',1,,1)
   |? var_pres('__estrace')<0
   || __estrace:=fopen(_tracefile,'bw',1,,1)
   ?}
?};
_log:=
   {? _g='T'
   || fopen(_logfile,'bw',1,,1)
   || null()
   ?};
_logj:=
   {? _g='T'
   || fopen(_logjfile,'bw',1,,1)
   || null()
   ?};
{? _trace || exec('trace','esearch','*** firma: '+ _b) ?};
_sql:='select distinct ACR_TAB from SYNC_DEF join SYNC_PD where SYNC_DEF.AKT=\'T\' and SYNC_PD.SYM=\'%1\''
   [_es.SYNCHRO];
{? _es.SEL_TAB<>''
|| _sql:=_sql+' and ACR_TAB=\'%1\''[_es.SEL_TAB]
?};
_tbList:=sql(_sql);

{? _tbList.size()=0 || return('ERROR: brak aktywnych tabel') ?};
_tbList.first();
::inicjalizacja indeksu jesli go nie ma elasticu
_es.index_info(0);
{! |?
   {? _b<>'' & exec('czy_tab_glob','#table', _tbList.ACR_TAB,1)
   || 0
   || _idStart:='';
      {! |?
         _idx:=-_tbList.ACR_TAB+'s';
         {? _es.INDEXES.find_key(_idx) & (_es.INDEXES.INDEX=_idx)
         || ''
         || _es.init_index(_idx)
         ?};
         {? _trace || exec('trace','esearch','proc_exe(new_sync):'+ _tbList.ACR_TAB) ?};
         _tbsync:=
            {? _es.isRok()
            || proc_exe('new_sync_es@synchro',
                  _es.SYNCHRO,
                  0,
                  _tbList.ACR_TAB,
                  _batchSize,
                  _b,
                  _es.getRokOd(),
                  _es.getRokDo(),
                  _idStart
               )
            || proc_exe('new_sync@synchro',_es.SYNCHRO,0,_tbList.ACR_TAB,_batchSize,_b)
            ?};
         {? _trace || exec('trace','esearch','new_sync -> tabela:'+_tbList.ACR_TAB+' ilosc rek:'+$_tbsync.size()) ?};
         _acr:='';
         {? _tbsync.first()
         || _idsync:=_tbsync.IDSYNC;
            {? var_pres('_fjson')>0 || &_fjson ?};
            _fjson:=fopen(_jsonfile,'uw!',1,,1);
            _sum:=0;
            {! |?
               _tbsync.get();
               {? var_pres('_fjson')<0 || _fjson:=fopen(_jsonfile,'uw!',1,,1) ?};
               {? _acr<>_tbsync.ACR
               || {? var_pres('_conn')>100 || obj_del(_conn) ?};
                  {? var_pres('_conn')>0 || &_conn ?};
                  {? var_pres('_conndel')>100 || obj_del(_conndel) ?};
                  {? var_pres('_conndel')>0 || &_conndel ?};
                  _conn:=inet_get(_a+_h+(-_tbsync.ACR)+'s/_bulk');
                  _conndel:=inet_get(_a+_h+(-_tbsync.ACR)+'s/_doc/');
                  _conn.append_header('Content-Type:application/json; charset:UTF-8');
                  {? _acr<>''
                  || ($('%1.cntx_pop(); %2.cntx_psh()'[_acr,_tbsync.ACR]))()
                  || ($('%1.cntx_psh()'[_tbsync.ACR]))()
                  ?};
                  _acr:=_tbsync.ACR
               ?};
               {? _tbsync.RODZ='del'
               || _conndel.url_reset();
                  _param:=_conndel.url_encode( {? _es.INST<>'' || _es.INST+'.' || '' ?} + _tbsync.REF);
                  _conndel.url_append(_param);
                  _conndel.http_delete();
                  _status:=_conndel.get_status();
                  {? _status>0
                  || _result:=_conndel.get_data();
                     {? _g='T'
                     || fwrite(_log,_result);
                        fwrite(_logj,maz_utf8(_json));
                        _logzapis:=1
                     ?};
                     {? var_pres('_jsonres')>-1 || &_jsonres ?};
                     _jsonres:=json_parse(_result);
:usuwanie z synchro wyslanych pozycji
                     {? type_of(_jsonres)=117
                     || 1
                     || {? _acr<>'' || ($('%1.cntx_pop()'[_acr]))() ?}; return('ERROR')
                     ?}
                  ?};
                  _next:=
                     {? _f='T'
                     || _idsync:=_tbsync.IDSYNC;
                        _synctab.add(_tbsync.ID);
                        {? _f='T' || _synctab.del() ?};
                        _tbsync.next()
                     || _tbsync.next()
                     ?};
                  _idStart:=_tbsync.R_IDPUT;
                  _next
               || {? _tbsync.LP=1
                  ||
:dodanie zapisow w synchro dotyczacych rekordów powiązanych
                     {? _i=0 ||  exec('load_ref','esearch', _tbsync.ACR, _tbsync.REF) ?};
                     _sum:=0;
                     _nag:='{"INDEX":{"_INDEX":"'+_tbsync.ACR+'s","_TYPE":"_doc","_ID":"'+
                        {? _es.INST<>'' || _es.INST+'.' || '' ?} +_tbsync.R_IDADD+_tbsync.REF+'"}}\n'
                  || _sum:=1
                  ?};
                  {? _sum
                  || _poz+=_tbsync.TR1+_tbsync.TR2+_tbsync.TR3+_tbsync.TR4+_tbsync.TR5+_tbsync.TR6+_tbsync.TR7+
                        _tbsync.TR8+_tbsync.TR9
                  || _poz:=_tbsync.TR1+_tbsync.TR2+_tbsync.TR3+_tbsync.TR4+_tbsync.TR5+_tbsync.TR6+_tbsync.TR7+
                        _tbsync.TR8+_tbsync.TR9
                  ?};
                  _opis:=exec('get_lbltab','esearch',_tbsync.ACR, _tbsync.REF);
                  {? _opis='' || _opis:=($(_tbsync.ACR+'.comment'))() ?};
                  _sync_acr:=_tbsync.ACR;
                  _sync_ref:=_tbsync.REF;
                  _next:=
                     {? _f='T'
                     || _idsync:=_tbsync.IDSYNC;
                        _synctab.add(_tbsync.ID);
                        _tbsync.next()
                     || _tbsync.next()
                     ?};
                  _idStart:=_tbsync.R_IDPUT;
                  {? _tbsync.LP=1 | ~_next
                  || _fjson.fwrite(-_nag);
                     {? _poz<>''
                     || _obj:=exec('get_reftabs','esearch',_sync_acr,_sync_ref,,1);
::uprawnienia
                        _obj2:=exec('get_reftabs','esearch',_sync_acr,_sync_ref,_obj,2);
                        _reftabs:=
                           {? var_pres('_obj2')=117
                           || gsub(1-json_obj(_obj2)-1,'UPR_','UPR.')
                           || ''
                           ?};
                        _json:=exec('jsons','esearch',_poz,_firma,_system,_opis,_sync_acr,_reftabs,,_fjson,_sync_ref);
                        _blpos:=_json*'$$BLOB';
::wstrzyknięcie do ostatecznego pliku jsona plików memo oraz blobów
                        {? _blpos>0
                        || {! |?
                              _lstr:=(_blpos-1)+_json;
                              _fjson.fwrite(_lstr);
                              _blobid:=16+((_blpos+5)-_json);
::kopiowanie pliku z blobem
                              exec('inject_blob','esearch',_fjson,_blobid);
                              _json:=(_blpos+21)-_json;
                              _blpos:=_json*'$$BLOB'
                           !};
                           _fjson.fwrite(_json);
                           _fjson.fwrite('\n')
                        || _fjson.fwrite(_json);
                           _fjson.fwrite('\n')
                        ?};
                        &_obj;
                        &_obj2
                     ?}
                  ?};
                  _il+=1;
                  {? (_il>_e & _tbsync.LP=1) | ~_next
                  ||
:wyslanie pliku json do ES
                     _result:='';
                     _fjson.fclose();
                     &_fjson;
                     _fjson:=fopen(_jsonfile,'br',1,,1);
                     _conn.http_post(,_fjson);
                     _fjson.fclose();
                     &_fjson;
                     _status:=_conn.get_status();
                     {? _status>0
                     || _result:=_conn.get_data();
                        {? _g='T'
                        || {?   var_pres('_result')=-1
                           || fwrite(_log,'status = ' + $_status + ', result=null')
                           || fwrite(_log,_result);
                              fwrite(_logj,maz_utf8(_json))
                           ?};
                           _logzapis:=1
                        ?};
                        {? var_pres('_result')=-1
                        || {? _acr<>'' || ($('%1.cntx_pop()'[_acr]))() ?};
                           return('ERROR: null response')
                        || {? var_pres('_jsonres')>-1 || &_jsonres ?};
                           _jsonres:=json_parse(_result);
                           {?   type_of(_jsonres)=117 & var_pres('errors',_jsonres)>0 & _jsonres.errors=0
                           ||
:usuwanie z synchro wyslanych pozycji
                              {? _f='T' || _synctab.del() ?};
                              1
                           || {? _acr<>'' || ($('%1.cntx_pop()'[_acr]))() ?};
                              return('ERROR')
                           ?};
                           &_jsonres;
                           _json:='';
                           _il:=0
                        ?}
                     || {? _acr<>'' || ($('%1.cntx_pop()'[_acr]))() ?};
                        return('ERROR: status='+$_status)
                     ?}
                  ?};
                  _next
               ?}
            !};
            {? _acr<>'' || ($('%1.cntx_pop()'[_acr]))(); _acr:='' ?}
         ||
:brak danych w SYNC
            0
         ?};
         {? _f='T' & _idsync<>''
         || {? _trace || exec('trace','esearch','proc_exec(del) -> idsync='+_idsync) ?};
            proc_exec('new_sync_id_del@synchro','ELASTIC',0,_tbList.ACR_TAB,'', _idsync)
         ?};
         _fetched:=_tbsync.size();
         &_tbsync;
         _fetched
      !}
   ?};
   {? _trace || exec('trace','esearch',_tbList.ACR_TAB + ' --> koniec.\n') ?};
   _tbList.next()
!};
{? _g='T'
|| fclose(_log);
   fclose(_logj);
   {? ~_logzapis
   || ferase(_logfile,1);
      ferase(_logjfile,1)
   ?}
?};
__escache.prefix;
{? _trace || exec('trace','esearch','zapisy w __escache: ' + $__escache.size) ?};
{? _trace || exec('trace','esearch','odczyty z __escache: ' + $__escache_hits) ?};
obj_del(__escache);
&__escache;
'OK'


\get_synctabmemo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [20.42]
:: OPIS: lista pol memo dla tabeli z definicji w synchro
::   WE: _a - nazwa synchro
::       _b - nazwa tabeli
::   WY: tabela tymczasowa
::----------------------------------------------------------------------------------------------------------------------
_sql:='select SYNC_DEF.ACR_FLD, SYNC_DEF.TYP
   from SYNC_DEF join SYNC_PD
   where SYNC_PD.SYM=\':_a\' and SYNC_DEF.ACR_TAB=\':_b\'
      and SYNC_DEF.AKT=\'T\' and (SYNC_DEF.TYP=\'M\' or SYNC_DEF.TYP=\'B\')';
_tbmemo:=sql(_sql,_a,_b);
return(_tbmemo)


\jsons
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [trocek] - modyfikacja [19.42]
:: OPIS: Parsuj z tresci json zamienia daty na stringi rozdzialane ".", zapisuje liczby jako stringi + escapowanie \"
::   WE: _a - tresc z synchro
::       _b - nazwa firmy
::       _c - nazwa systemu
::       _d - opis, nazwa tabeli
::       _e - akronim tabeli
::       _f - dołączone tabele (json)
::       _g - opcjonalny firma_symbol (jesli podany to nie jest odczytywana wartosc z FIRMA
::       _h - plik do zapisu jsona
::   WY: json
::----------------------------------------------------------------------------------------------------------------------
_es:=exec('elastic','elastic');
_fjson:=_h;
{? _a<>'' ||  _a:=1-exec('escape_json','esearch',_a)-1  ?};
_firsym:='';
_wielefirm:=exec('czy_tab_glob','#table',_e,1);
_lnkfirmset:=0;
{?  _wielefirm
||
   _firsym:=Elastic.FIRMY;
   _firma:='Wiele firm'
?};
_pola:=spli_str(_a,';');

_tekst:=obj_new('ACR','WAR','TR','test');
_ilePol:=obj_len(_pola);
_tekst.ACR:=obj_new(_ilePol);
_tekst.WAR:=obj_new(_ilePol);
_tekst.TR:=obj_new(_ilePol);
_tekst.test:='';
_dodaj:="
   {? ~(_a.test*(';'+_c+','+_d+';'))
   || _a.test+=(';'+_c+','+_d+';');
      _a.ACR[_b]:=form(_c);
      _a.WAR[_b]:=form(_d);
      _a.TR[_b]:=form(_e)
   ?}
";

_war:='';
{! _licz:=1.._ilePol
|!
   {? var_pres('_dane')>0 || &_dane ?};
   _dane:=spli_str(_pola[_licz],':');
   {? obj_len(_dane)>1
   ||
      {? var_pres('_pars')>0 || &_pars ?};
      _pars:=spli_str(_dane[1],'.');
      {? obj_len(_pars)>1
      ||  _txt:='';
          {? obj_len(_dane)>2
          || {! _il:=2..obj_len(_dane)
             |!
               _txt+=_dane[_il]+';'
             !}
          || _txt:=_dane[2]
          ?};
          {? _pars[1]='SLNK' & _pars[2]='FIRM'
          ||
             _firsym:=_txt;
             _lnkfirmset:=_firsym<>'';
             _firma:='Firma '+_firsym
          |? _pars[1]='SUPR'
          ||
::specjalne potraktowanie pól UPR.
             0
          || _dodaj(_tekst,_licz,_pars[1],_pars[2],_txt)
          ?}
      ||
         _nr:=(1+_dane[1])='N'; _dt:=(1+_dane[1])='D';
         _war+='"'+_e+'.'+(1-_dane[1])+'":'+ {? _nr || '"' || '"' ?};
         {? obj_len(_dane)>2
         ||
            _txt:='';
            {! _il:=2..obj_len(_dane) |!
               _txt+=_dane[_il]+';'
            !};
            _war+=_txt
         ||
::BLOB - w tresci jest ref do pliku bloba
            {? 1+_dane[1]='B' & _dane[2]<>''
            ||
               _tmpfile:='!tmptika.es';
               _blobfile:='!tmp%1.es'[_dane[2]];
               _res:=exec('send_tika','esearch',_dane[2],_tmpfile);

               {? _res>0
               ||
:odczyt pliku,
                  _file:=fopen(_tmpfile,'ur',1,,1);
                  _fblob:=fopen(_blobfile,'uw!',1,,1);
                  _ile:=0;
                  {! |? (_wiersz:=_file.fread(300000))<>'\n' & _ile<2000000
                  |!
                     _ile:=_ile+(+_wiersz);
                     _data:=_wiersz + ' ';
                     {? _data<>'' || _data:=exec('escape_json','esearch',_data) ?};
                     _fblob.fwrite(_data)
                  !};
                  _file.fclose();
                  _fblob.fclose();
                  &_file;
                  &_fblob;
                  _war+='$$BLOB%1'[_dane[2]]
               ?}
:SYSMEMO - w formule jest nazwa pola SYSMEMO
            |? 1+_dane[1]='M'
            ||
               _ref:=_i;
               _fld:=1-_dane[1];
:ustawiam rekord tabeli wg refa i sprawdzam czy ma wartosc w polu memo
               _fun:='
                  %1.cntx_psh();
                  %1.prefix();
                  _mask:=gsub(_a-8,\' \',\'\');
                  %1.use(_mask);
                  %1.seek(_a);
                  %1.cntx_pop();
                  %1.%2'[_e,_fld];
               _errorFlag:=0;
               _hasmemo:=($(_fun))(_ref);
::SYSMEMO
               {? _hasmemo
               ||
                  _tmpfile:='!tmpmemo.es';
                  _blobfile:='!tmp%1.es'[_ref];
                  _file:=($('%1.memo_get(''r'',_a)'[_e]))(_fld);
                  _fblob:=fopen(_blobfile,'uw!',1,,1);
                  {! |? (_wiersz:=_file.fread())<>'\n'
                  |!
                     _data:=_wiersz + ' ';
                     {? _data<>'' || _data:=exec('escape_json','esearch',_data) ?};
                     _fblob.fwrite(_data)
                  !};
                  _file.fclose();
                  _fblob.fclose();
                  &_file;
                  &_fblob;
                  ($('%1.cntx_pop()'[_e]))();
                  _war+='$$BLOB%1'[_ref]
               ?}
            ||
               _war+=_dane[2]
            ?}
         ?};
         _war+={? _nr || '"' || '"' ?}+','
      ?}
   ?}
!};
_ret:=',';
_acr:='';
_jest:=0;
_ilePol:=obj_len(_tekst);
{! _licz:=1.._ilePol |!
   {? var_pres('[%1]'[$_licz],_tekst.ACR)=type_of('')
   || {? _acr<>(1-_tekst.ACR[_licz])
      || {? _jest || _ret-=1; _ret+='},' ?};
         _ret+='"'+(1-_tekst.ACR[_licz])+'":{';
         _acr:=(1-_tekst.ACR[_licz]);
         _jest:=0
      ?};
      _nr:=(1+_tekst.ACR[_licz])='N';
      _memo:=_tekst.TR[_licz];
      _dt:=(1+_tekst.ACR[_licz])='D';
      _ret+='"'+_tekst.WAR[_licz]+'":'+{? _nr || '"' || '"' ?};
      _ret+=_memo;
      _ret+={? _nr || '"' || '"' ?}+',';
      _jest:=1
   ?}
!};
{? _ret<>','
|| _ret-=1;
   {? +_ret || _ret+='}' ?}
|| _ret:=''
?};

_war-=1;
{? ~_wielefirm & ~_lnkfirmset
||
   _tb:=exec('get_firmarec','elastic',_firsym);
   {? _tb.first() & _tb.size()>0
   ||
      _firsym:=_tb.SYMBOL;
      _firma:=gsub(_tb.OPIS,'"',%92+'"')
   ?}
?};
_result:='{'+ _war;
_result:=_result + {? _f<>'' || ',' + _f || '' ?};
_result:=_result+',"metadane":{';
{? _es.INST<>'' || _result:=_result+' "instancja":"'+_es.INST+'",' ?};
_result:=_result + ' "firma_symbol":"'+_firsym+'", "firma":"'+_firma+'","system":"'+_c+'","tabela":"'+_d+'"}'+_ret+'}';
_result


\escape_json
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [20.42]
:: OPIS: zamienia znaki crlf i tab na spacje, eskejpuje cudzysłowy
::   WE: _a - treść do korekty
::   WY: string
::----------------------------------------------------------------------------------------------------------------------
return(json_value(_a))


\cache_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [21.14]
:: OPIS: dopisuje obiekt do cache
::   WE: _a - ref obiektu
::       _b - obiekt
::   WY: _b
::----------------------------------------------------------------------------------------------------------------------
__escache.prefix(_a);
{? __escache.first
||
   0
||
   __escache.prefix;
   __escache.REF:=_a;
   __escache.TAB:='';
   __escache.add;
:   exec('trace','esearch','cache_add : ' + _a);
   _file:=fopen('obj.json','w',1,1,1);
   json_obj(_b, _file);
   __escache.memo_set(_file,'JSON');
   __escache.memo_put(,'JSON');
   fclose(_file);
   &_file
?};
_b


\get_reftabs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: generuje jsona dla tabel powiazanych dla podanej tabeli
::   WE: _a - tabela do dołączenia
::       _b - ref rekordu
::       _c - tabela tymczasowa
::       _d - root 1/0 lub 2 - tylko pola UPR. z podanej tabeli
::       _e - nazwa tabeli w synchro
::       _f - ref do SYNC_PD
::   WY: string json
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_e')<0 || _e:=_a ?};
{? type_of(_b)<>type_of('') || _ref:=$_b || _ref:=_b ?};

{? _d<>2 & _ref='' || return(~~) ?};
{? _d<>2 & _ref<>'' & __es_usecache
||
      __escache.prefix(_ref);
   {? __escache.first()
   ||
      _memo:=__escache.memo_get('r','JSON',0);
      on_error(3);
      _err:=errno();
      _obj:=json_parse(_memo);
      {? type_of(_obj)=0 || _err:=1111 ?};
      {? _err<>0
      ||
         0
      ?};
      fclose(_memo);
      &_memo;
      __escache_hits+=1;
:      exec('trace','esearch','cache hit: ' + _ref);
      return(_obj)
   ?}
?};

{? _d=1
|| _war:='SYNC_DEF.REF_TAB<>'''' and SUBSTR(SYNC_DEF.ACR_FLD,1,4)<>''UPR.'' and '
|? _d=2 || _war:='SYNC_DEF.ACR_FLD LIKE ''UPR.%'' and '
|| _war:='' ?};
_sql:='select * from SYNC_DEF join SYNC_PD  where SYNC_DEF.AKT=''T''
          and position(''LNK.'' in SYNC_DEF.ACR_FLD)=0 and %1
          SYNC_PD.SYM=''ELASTIC'' order by SYNC_DEF.REF_TAB'[_war];
{? _d=1
||
   {? var_pres('__sync1')<=0
   ||
      __sync1:=sql(_sql);
      __sync1.index(__sync1.ndx_tmp(,,'ACR_TAB',,))
   ?};
   _sync:=__sync1
|? _d=2
||
   {? var_pres('__sync2')<=0
   ||
      __sync2:=sql(_sql);
      __sync2.index(__sync2.ndx_tmp(,,'ACR_TAB',,))
   ?};
   _sync:=__sync2
||
   {? var_pres('__sync0')<=0
   ||
      __sync0:=sql(_sql);
      __sync0.index(__sync0.ndx_tmp(,,'ACR_TAB',,))

   ?};
   _sync:=__sync0
?};
_sync.prefix(_a);
_reftab:=($(_a))();
{? _ref=''
||
:zamiast nulla wysylam pusty rekord, zeby dzialaly nadal uprawnienia
    _reftab.blank()
||
   _reftab.use(gsub(_ref-8,%32,''));
:     exec('delspace','#string',exec('delspace','#string',_ref-8)));
   _reftab.prefix();
   _reftab.seek(_ref)
?};
_flds:='';
_jestc:=var_pres('_c')>0;
{? _sync.first() & _sync.ACR_TAB=_a
|| {! |?
      _acrfld:=gsub(_sync.ACR_FLD,'UPR.','UPR_');
      {? (_jestc & ($('var_pres(''%1'',_a)=-1'[_acrfld]))(_c)) | ~_jestc
      ||
         _flds+='\''+ _acrfld +'\','
      ?};
      _sync.next & _sync.ACR_TAB=_a
   !};
   _sync.first();
   {? var_pres('_c')>0 & _flds<>''
   ||
      _obj:=($('obj_ntab_add(_a,%1)'[_flds-1]))(_c)
   |? _flds<>''
   ||
      _obj:=($('obj_new(%1)'[_flds-1]))()
   ?};
   {? var_pres('_obj')=117
   ||
      {! |?
         {? _sync.REF_TAB<>''
         ||
            _ref:=($(_sync.REF_FLD))();
            _sync.cntx_psh();
            ($('_a.%1'[_sync.ACR_FLD]))(_obj):=exec('get_reftabs','esearch',_sync.REF_TAB, _ref, , 0, _sync.ACR_FLD);
            _sync.cntx_pop()
         ||
::wypelniamy wartosci pol tabeli dołączonej
            {? (_sync.ACR_FLD*'LNK.'=0)
            ||
               _wart:=($(_sync.FORM))(_reftab);
               {? _d=2
               ||
:jesli wartosc ma przecinki to tworze tablice
                  {? _wart*','>0
                  ||
                     {? ((+_wart)-1)-_wart=',' || _wart:=_wart-1 ?};
                     _arr:=spli_str(_wart,',');
                     ($('_a.%1'[gsub(_sync.ACR_FLD,'UPR.','UPR_')]))(_obj):=_arr;
                     &_arr
                  ||
                     ($('_a.%1'[gsub(_sync.ACR_FLD,'UPR.','UPR_')]))(_obj):=_wart
                  ?}
               ||
                  ($('_a.%1'[gsub(_sync.ACR_FLD,'UPR.','UPR_')]))(_obj):=_wart
               ?}
            ?}
         ?};
         _sync.next() & _sync.ACR_TAB=_a
      !}
   ?}
?};
:_reftab.cntx_pop();
{? var_pres('_obj')>0
||
   {? __es_usecache & _d=0 & obj_len(_obj)>0
   || _strref:=exec('tostr','esearch',_ref);
      {? _strref<>'' || exec('cache_add','esearch',_strref,_obj) ?}
   ?};
   _obj
||
   {? _jestc || _c || ~~  ?}
?}


\tostr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [20.42]
:: OPIS: zamienia wartosc na string z escapowaniem, w liczbach zamienia "," na "."
::   WE: _a - wartość do zmiany
::   WY: string
::----------------------------------------------------------------------------------------------------------------------
{? type_of(_a)=2
||
   {? _a='' || return('') ?};
   _a:=gsub(_a,%92,%92+%92);
   _a:=gsub(_a,'"',%92+'"');
   return(_a)
?};
{? type_of(_a)=1 || return(gsub($_a,',','.')) ?};
{? type_of(_a)=0 || return('') ?};
{? type_of(_a)=4 || return($_a) ?};
{? type_of(_a)=7 || return($_a) ?}


\get_lbltab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [19.42]
:: OPIS: zwraca opis do tabeli w synchro z pola LBL_TAB
::   WE: _a - nazwa tabeli
::       _b - ref rekordu z synchro
::   WY: string opis
::----------------------------------------------------------------------------------------------------------------------
:_sql:='select * from SYNC_DEF join SYNC_PD where SYNC_PD.SYM=\'ELASTIC\' and SYNC_DEF.ACR_TAB=\'%1\''[_a];
:_tb:=sql(_sql);
_res:='';
__tbesdef.prefix(_a);
{? __tbesdef.first()
||
   _form:=__tbesdef.LBL_TAB;
   {? _form<>''
   ||
       _tab:=($(_a))();
       _tab.cntx_psh();
       _tab.prefix();
       _tab.use(gsub(_b-8,%32,''));
       _tab.seek(_b);
       _res:=($(_form))();
       _tab.cntx_pop()
   ?}
?};
_res


\init_labels
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [21.14]
:: OPIS: inicjalizuje tabelę cache etykiet
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__tbesdef')>0
||
  &__tbesdef
?};
_sql:='select LBL_TAB,ACR_TAB from SYNC_DEF join SYNC_PD where SYNC_PD.SYM=\'ELASTIC\'';
__tbesdef:=sql(_sql);
__tbesdef.index( __tbesdef.ndx_tmp(,,'ACR_TAB',,))


\synctab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [20.14]
:: OPIS: tabela pomocnicza to zapamietywania rekordow do usuniecia z synchro
::   WE: _a - symbol definicji danych
::   WY: obiekt  - metody .add(ref) .del()
::----------------------------------------------------------------------------------------------------------------------
_synctab:=obj_new('add','del','tb','synchro');
_synctab.tb:=tab_tmp(1,'REF','STRING[16]','REF','ID','STRING[20]','ID');
_synctab.synchro:=_a;
_synctab.del:="
   {? .tb.first() ||
      {! |?
         proc_exe('sync_del@synchro', .tb.ID, .synchro);
         .tb.del()
      !}
   ?}
";
_synctab.add:="
   .tb.ID:=_a;
   .tb.add()
";
_synctab


\load_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [20.42]
:: OPIS: wysyła do synchro zapisy z tabel połączonych
::   WE: _a - akronim tabeli
::       _b - REFSQL rekordu z tabeli _a
::----------------------------------------------------------------------------------------------------------------------
::lista tabel w ktorych tabela wystepuje jako dołączona
_sql:='select SYNC_DEF.ACR_TAB, SYNC_DEF.SYNC_PD
   from SYNC_DEF join SYNC_PD
   where SYNC_DEF.AKT=''T'' and SYNC_PD.SYM=\'ELASTIC\' and SYNC_DEF.REF_TAB=''%1'''[_a];
_pow_tab:=sql(_sql);
_cur_tab:=_a;
{? _pow_tab.first()
||
   {! |?
:nazwa pola w tabeli dołączonej zawierającego refa do _cur_tab
      _reffld:=exec('get_reffld','esearch',_pow_tab.ACR_TAB,_cur_tab);
      {? _reffld<>''
      ||
:rekordy powiązane
         _sql:='select REFERENCE as REF from @%1 where %2=''%3'''[_pow_tab.ACR_TAB,_reffld,_b];
         {? var_pres('_ref_tab')>0 || &_ref_tab ?};
         _ref_tab:=sql(_sql);
         SYNC_PD.prefix; SYNC_PD.seek(_pow_tab.SYNC_PD); _ref_pd:=SYNC_PD.ref;
         exec('wysl_tab_ref','synchro', _pow_tab.ACR_TAB, _ref_tab, _ref_pd)
      ?};
      _pow_tab.next()
   !}
?}


\get_reffld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [20.14]
:: OPIS: zwraca nazwe pola zawierającego złączeni do podanej tabeli
::   WE: _a - akronim tabeli przeszukiwana
::       _b - tabela do której refa szukamy
::   WY: [STRING] nazwa pola zawierajacego złączenie do tabeli
::----------------------------------------------------------------------------------------------------------------------
_tab:=($(_a))();
_max:=_tab.fld_num();
{! _idx:=1 .. _max
|!
  _fldname:=_tab.fld_acr(_idx);
  _tbname:=_tab.fld_join(_idx);
  {? _tbname=_b || return(_fldname) ?}
!};
''


\send_tika
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [20.14]
:: OPIS: wysyła dokument z BLOBA do serwera apache-tika
::   WE: _a - BLOB do wysłania
::       _b - nazwa pliku wyjsciowego
::   WY: string
::----------------------------------------------------------------------------------------------------------------------
:return(0);
exec('elastic','elastic');
SYSBLOB.cntx_psh();
SYSBLOB.prefix();
SYSBLOB.seek(_a);
_ref:=SYSBLOB.ref();
SYSBLOB.cntx_pop();
_blob:=fopen(_ref,'br',,,1);
_blobsize:=_blob.fgetsize();
_res:=fopen(_b,'bw',1,,1);
_conn:=inet_get(Elastic.TIKA+'tika');
_err:=errno();
on_error(3);
no_msg(1);
_status:=_conn.http_get();
_version:=_conn.get_data();
_lasterr:=errno();
on_error();
{? _lasterr<>0 | _status<>200
||
  choice('Brak połączenia z serwerem Apache-Tika'@,'Błąd'@,'ERROR');
  return(-1)
?};
_conn.http_put(_res,_blob);
_status:=_conn.get_status();
_header:=_conn.get_header();
_hf:=fopen('!tikaheader.es','bw',1,,1);
_hf.fwrite(_header);
_hf.fclose();
_total:=0;
_res.fclose();
_status:=_conn.get_status();
obj_del(_conn);
{? _status<>200 || _status:=0 ?};
on_error(0);
no_msg(0);
_status


\inject_blob
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [20.14]
:: OPIS: zapis bloba do pliku wyjsciowego json
::   WE: _a - obiekt FILE
::       _b - id bloba
::----------------------------------------------------------------------------------------------------------------------
_fblob:=fopen('!tmp%1.es'[_b],'ur',1,,1);
{! |? (_wiersz:=_fblob.fread())<>'\n' |!
   _a.fwrite(_wiersz)
!};
_fblob.fclose();
ferase('!tmp%1.es'[_b],1)


\tabhelper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [20.42]
:: OPIS: pomocniczy obiekt do pobierania nazwy/komentarza tabeli na podstawie podanej maski
::       działa prawidłowo dla tabel maskowanych
::        __tabhelper.comment('doku0101000000ca'-8)
::        __tabhelper.acr('doku0101000000ca'-8)
::       exec('tabhelper','esearch','doku0101000000ca'-8,'comment');
::----------------------------------------------------------------------------------------------------------------------
_fld:="31+form(_a)";
_mth:="31+form(_a)";
{? var_pres('__tabhelper')=-1
||
   __tabhelper:=obj_new(
    _fld('TABLES','lista tabel i masek'),
    _mth('acr','zwraca akronim tabeli po podaniu maski'),
    _mth('comment','zwraca komentarz tabeli po podaniu maski')
    );

   _tables:=tab_tmp(1,'ACR_TAB','STRING[8]','ACR_TAB', 'MASK','STRING[8]','MASK', 'COMMENT','STRING[80]','COMMENT');
   _idx:=_tables.ndx_tmp('',0,'MASK',,0);
   _tables.index(_idx);
   {! _tt:=1..tab_num()
   |!
      _acr:=tab_acr(_tt);
      {? tab_real(_tt)
      ||
         _names:=($_acr)().names;
         _names.first();
         {! |?
            _tables.blank();
            _tables.ACR_TAB:=-_acr;
            _tables.MASK:=_names.NAME;
            _tables.COMMENT:=($_acr)().comment();
            _tables.add();
            _names.next()
         !};
         &_names
      ?}
   !};
   __tabhelper.TABLES:=_tables;
   __tabhelper.acr:="{? .TABLES.find_key(_a) || .TABLES.TAB_ACR || '' ?}";
   __tabhelper.comment:="{? .TABLES.find_key(_a) || .TABLES.COMMENT || '' ?}";
   {? var_pres('_a')=2 || ($('__tabhelper.%1(_a)'[_b]))(_a)  || __tabhelper ?}
||
   {? var_pres('_a')=2 || ($('__tabhelper.%1(_a)'[_b]))(_a)  || __tabhelper ?}
?}


\dt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [21.14]
:: OPIS: data i czas do logu
::   WY: string
::----------------------------------------------------------------------------------------------------------------------
$date+ ' ' +$(time~1) + ':' + $(time~2) + ':' + $(time~3)


\trace
::----------------------------------------------------------------------------------------------------------------------
::  UTW: trocek [21.14]
:: OPIS: zapis w pliku trace
::   WE: _a - tresc wpisu
::----------------------------------------------------------------------------------------------------------------------
fwrite(__estrace,exec('dt','esearch')+%9);
fwrite(__estrace,_a+'\n')

:Sign Version 2.0 jowisz:1045 2023/10/11 15:21:20 85aab80c447a89cab749c9115ae51662123c6aa402cfe731d9221f90ad15cb2a18625bdd79e39e66313b4a421444844fa24de92a719eec1edc9fcdcb5113f48d8107c1c22d2c1ffd20e16e8042ae9636452d09ed015f8d6659c3d48832dc7ef17bc31b4af6969f5f7e35e3f632f80248a1e7418c1d265a7ec41b87c2fbda6db7
