:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku:  px_logix.fml [12.10]
:: Utworzony: 2011-07-19
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Logika wielowymiarowego planu pojemnosciowego
::======================================================================================================================


\plan_grp_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Tablica parametrów dla plan_grp
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
::             PX_VER.ref() - wersja w ktorej bede planowal
               'VER_DST',
::             PX_GRP.ref() - obiekt grupujacy ktory planuje
               'PX_GRP',
::             obj_new -  paczka technologiczna ktora mowi mi jak zaplanowac i gdzie
::                         struktra paczki w funkcji exec('PxPack_declare','px_tex')
               'PxPack',
::             Czy robic korekte opoznionych
               'KOR_DLAY',
::             Czy robic korekte wykonywanych
               'KOR_WYK1',
::             Czy robic korekte wykonanych
               'KOR_WYK2',
::             Czy robic korekte zablokowanych
               'KOR_BLK',
::             Czy robic korekte porzuconych
               'KOR_SKIP',
::             Czy robic korekte zaplanowanych na biezacym pojemniku
               'KOR_TODAY',
::             Tabela, w ktorej bedzie odpisywany przedzial zaplanowania grupy
::             obj_new('SQLREF','TM_START','TM_END')
               'TM_RANGE',
::             Czas poczatku nowej wersji planu
               'TM_ZERO',
::             _overmode
               'overmode',
::             Czy podczas dodawania pozycji na pojemnik wykonywac renumeracje pozycji?
               'RENUMERATE',
::             Status pozycji planu jaki jej ustawic od razu po utworzeniu
               'STATUS',
::             Tabela tymczasowa z końcami zaplanowanych etapów
               'TIMES',
::             Obiekt do planowania na podstawie planu dostaw
               'PD_OBJ'
               );
:: zwracamy deklaracje argumentow

_args.VER_DST:=null();
_args.PX_GRP:=null();
_args.PxPack:=obj_new('dummy');
_args.KOR_DLAY:=1;
_args.KOR_WYK1:=1;
_args.KOR_WYK2:=1;
_args.KOR_BLK:=1;
_args.KOR_SKIP:=1;
_args.KOR_TODAY:=1;
_args.TM_RANGE:=null();
_args.TM_ZERO:=null();
_args.overmode:=exec('get','#params',500357,2);
_args.RENUMERATE:=1;
_args.STATUS:='';
_args.TIMES:=~~;
_args.PD_OBJ:=~~;
_args


\plan_grp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Planuje jeden obiekt grupujacy
::   WE: _args - wynik formuly exec('plan_grp_a','px_logix')
::   WY: obj_new: RESULT, REPLAN
::----------------------------------------------------------------------------------------------------------------------
_args:={? _=1 || _a || exec('plan_grp_a','px_logix') ?};

_paczka:=_args.PxPack.Paczka;
:: jezeli nie podano zewnetrznej tabeli zakresow (np. planowanie tylko jednej grupy), to tworze nowa
_tm_range:={? type_of(_args.TM_RANGE)>100
           || _args.TM_RANGE
           || _args.TM_RANGE:=exec('tm_range_create','px_logix');
              _args.TM_RANGE
           ?};
_result:=obj_new('RESULT','REPLAN');
_result.RESULT:=1;
_result.REPLAN:=0;

_can_continue:=1;

PX_POZ.cntx_psh();
PX_VER.cntx_psh();
PX_GRP.cntx_psh();
PX_GRP.clear();
PX_VER.clear();
:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};
_msg:='plan_grp\px_logix - Planowanie obiektu grupujacego';
pxkomm.sect_beg(_msg);

_old_problems:='';

::ustawiam kontekst na wersje
{? PX_VER.seek(_args.VER_DST)
||
:: ustawiam kontekst na obiekt grupujacy
   {? PX_GRP.seek(_args.PX_GRP)
   ||
::    KOREKTA ILOSCI KTORE ZOSTALY ZAPLANOWANE NA PODSTAWIE PLANU OPERACYJNEGO
      _kor_prop:=exec('count_oper_kor','px_tie',PX_GRP.ref());
      exec('paczka_kor_prop','px_tex',_paczka,_kor_prop);
::    Jesli po korekcie paczka jest pusta, to znak ze cala grupa zostala zaplanowana
::    na podstawie planu operacyjnego i trzeba ja tak osteplowac

      {? exec('pck_not_empty','px_tex',_paczka)=0
      ||
         {? _kor_prop<1
         ||
::          Jesli paczka pusta i nastapila korekta na podstawie planu operacyjnego
::          to oznaczam grupe ze zostala zaplanowana na podstawie planu operacyjnego
            exec('set_plan_opr','px_grp',PX_GRP.ref(),'T');
            _result.RESULT:=1
         ?}
      ||
         _max_replan:=10;
         _replan_count:=0;
         {!
         |?
            _replan_count+=1;
            _result.REPLAN:=0;

::          Usuwam problemy z PX_GRP, jesli jakies byly
            _old_problems:=PX_GRP.PROBLEMS;
            PX_GRP.PROBLEMS:=exec('problem_none','px_grp');
            PX_GRP.put();

::          Usuwam komunikaty zwiazane z planowaniem dot PX_GRP
            _src_kom:=exec('src_plan_prefix','px_komm');
            _typ1:=exec('type_error','px_komm');
            _typ2:=exec('type_warning','px_komm');
            _typ3:=exec('type_info','px_komm');
            exec('del_kommy','px_komm','PX_GRP',PX_GRP.ref(),_typ1,_src_kom);
            exec('del_kommy','px_komm','PX_GRP',PX_GRP.ref(),_typ2,_src_kom);
            exec('del_kommy','px_komm','PX_GRP',PX_GRP.ref(),_typ3,_src_kom);

            exec('set_plan_opr','px_grp',PX_GRP.ref(),'N');

::          !!! Uruchamiam odpowiedni algortym planujacy paczke !!!
            {? _args.PxPack.HASPOINT>0
            || {? var_pres('_res_plan_pack')>100
               || obj_del(_res_plan_pack)
               ?};
               _res_plan_pack:=exec('plan_pack2','px_logix',_args);
               {? _res_plan_pack.REPLAN>0
               || _result.REPLAN:=1
               ?};
               {? _res_plan_pack.RESULT<=0
               || _result.RESULT:=0
               ?}
            || {? var_pres('_res_plan_pack')>100
               || obj_del(_res_plan_pack)
               ?};
               _res_plan_pack:=exec('plan_pack3','px_logix',_args);
               {? _res_plan_pack.REPLAN>0
               || _result.REPLAN:=1
               ?};
               {? _res_plan_pack.RESULT<=0
               || _result.RESULT:=0
               ?}
            ?};

            {? _result.RESULT>0 & _result.REPLAN>0
            ||
::             Musi nastąpić przeplanowanie całości, więc usuwam PX_GRP z planu i zaczynam jeszcze raz
               _can_continue:=exec('clean_from_plan','px_grp',PX_GRP.ref(),0,1,0,0);

               {? _can_continue>0
               || _paczka.cntx_psh();
                  _paczka.prefix();
                  {? _paczka.first()
                  || {!
                     |? _paczka.PLANNED:='N';
                        _il_wym:=exec('il_wym','px_param');
                        {! _it:=1.._il_wym
                        |! _rule:=$('
                                       _paczka:=_a;
                                       _paczka.DID_DIM'+$_it+':=0
                                    ');
                           _rule(_paczka)
                        !};
                        _can_continue:=_paczka.put();

                        {? _can_continue>0 & PX_VAR.PD>0
                        || {? _paczka.TYP='O' & _paczka.PX_STAGE<>''
                           || _args.PD_OBJ.plan_cancel($PX_GRP.ref()+' - '+_paczka.PX_STAGE)
                           ?}
                        ?};
                        _paczka.next() & _can_continue>0
                     !}
                  ?};
                  _paczka.cntx_pop()
               ?}
            ?};
            _result.REPLAN>0 & _replan_count<_max_replan
         !};

::       wiazanie pozycji planu z obiektami planowanymi
         exec('poz_conn_obj','px_logix',_args.PX_GRP,_args.PxPack);

         {? _result.RESULT=0
         ||
::          jesli nie udalo sie zaplanowac to przywracam stare problemy
            PX_GRP.PROBLEMS:=_old_problems;
            PX_GRP.put()
         ||
::          jezeli udalo sie zaplanowac, to trzeba naniesc informacje o poczatku i koncu PX_GRP do TM_RANGE
            PX_POZ.cntx_psh();
            PX_POZ.index('TM_GRP');
            PX_POZ.prefix(_args.PX_GRP);
::          szukamy pierwszego i ostatniego PX_POZ'a i na tej podstawie okreslim przedzial PX_GRP'a
            {? PX_POZ.first()
            ||
               {? ~_tm_range.find_key($_args.PX_GRP,)
               || _tm_range.SQLREF:=$_args.PX_GRP;
                  _tm_range.add()
               ?};
               {? _tm_range.find_key($_args.PX_GRP,)
               || _tm_range.TM_START:=PX_POZ.TM_START;
                  PX_POZ.last();
                  _tm_range.TM_END:=PX_POZ.TM_END;
                  _tm_range.put()
               ?}
            ?};

::          Aktualizuje status grupy
            exec('status_rebuild','px_grp',PX_GRP.ref());

::          Aktualizuje datę rozpoczęcia i zakończenia wyliczoną przez plan
            exec('plan_times_upd','px_grp');

            PX_POZ.cntx_pop()
         ?}
      ?}
   || _msg:='Planowanie obiektu grupujacego - nie znaleziono obiektu grupujacego: '+$_args.PX_GRP;
      pxkomm.error(_msg)
   ?}
|| _msg:='Planowanie obiektu grupujacego - nie znaleziono wersji: '+$_args.VER_DST;
   pxkomm.error(_msg)
?};

pxkomm.sect_end();
PX_POZ.cntx_pop();
PX_VER.cntx_pop();
PX_GRP.cntx_pop();
PX_GRP.get();
_result


\plan_pack
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Planuje paczke technologiczna - algorytm standardowy
::   WE: _a - _args - wynik formuly exec('plan_grp_a','px_logix')
::       KONTEKST PRACY - PX_GRP, PX_VER
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_args:={? var_pres('_a')>100
       || _a
       || exec('plan_grp_a','px_logix')
       ?};

_result:=0;

:: jezeli nie podano zewnetrznej tabeli zakresow (np. planowanie tylko jednej grupy), to tworze nowa
_tm_range:={? type_of(_args.TM_RANGE)>100 || _args.TM_RANGE || exec('tm_range_create','px_logix') ?};

::tabela tymczasowa dzieki ktorej bede mogl pobierac koniec planu poprzedniego etapu
_times:=tab_tmp(2,'NUM','INTEGER','Numer w procesie',
                  'TIME','REAL','Czas konczacy plan');

_ndx_up:=_times.ndx_tmp(,,'NUM',,0,'TIME',,0);
_ndx_down:=_times.ndx_tmp(,,'NUM',,1,'TIME',,1);

_paczka:=_args.PxPack.Paczka;

:: tworze indeks tymczasowy i sortuje paczke po polu NUM
:: pole to okresla sekwencje operacji (rownolegle operacje maja ten sam NUM)
:: indeks jest zorientowany wg kolejnosci planowania
_ndx_num:={? PX_GRP.DIR>0 || _args.PxPack.Ndx_fwd || _args.PxPack.Ndx_bck ?};
_paczka.index(_ndx_num);
_paczka.prefix('K');

:: GLOWNA PETLA PO KONTENERACH
{? _paczka.first()
||
   _can_continue:=1;
   _overmode:=_args.overmode;

   _argskont:=exec('plan_add_kont_a','px_logix');
   obj_del(_argskont.PACZKA);
   _argskont.PX_VER:=PX_VER.ref();
   _argskont.PACZKA:=_paczka;
   _argskont.PX_GRP:=PX_GRP.ref();
   _argskont.DIR:=PX_GRP.DIR;
   _argskont.RENUMERATE:=_args.RENUMERATE;
   _argskont.PD_OBJ:=_args.PD_OBJ;
   _argskont.STATUS:=_args.STATUS;
   _time_zero:=0;
:: pobieram widelki czasowe wynikajace z PX_GRP.TM_*, a jesli puste, to poprzednikow i nastepnikow
:: _time_zero bedzie pobierany wlasnie na podstawie tej tablicy
   _envrange:=exec('get_env_range','px_con_g',_args.PX_GRP,_tm_range);

   {? PX_GRP.DIR>0
   || _time_zero:=_envrange.TM_START;
      _times.index(_ndx_up)
   || _time_zero:=_envrange.TM_END;
      _times.index(_ndx_down)
   ?};

   _argskont.KOR_DLAY:=_args.KOR_DLAY;
   _argskont.KOR_WYK1:=_args.KOR_WYK1;
   _argskont.KOR_WYK2:=_args.KOR_WYK2;
   _argskont.KOR_BLK:=_args.KOR_BLK;
   _argskont.KOR_SKIP:=_args.KOR_SKIP;
   _argskont.KOR_TODAY:=_args.KOR_TODAY;

   _argskont.TMGSTART:=_envrange.TM_START;
   {? _args.TM_ZERO>0
   ||
::    Normalizacja punktu poczatkowego do przekazanego punktu poczatku planu
::    nie moge planowac wczesniej niz przekazano
      _time_zero:=exec('max','#math',_args.TM_ZERO,_time_zero);
::    Jesli czas poczatku planu podany to granica nieprzekraczalna lewa
::    dla grupy nie moze byc wczesniej
      _argskont.TMGSTART:=exec('max','#math',_args.TM_ZERO,_argskont.TMGSTART)
   ?};
   _argskont.TMGEND:=_envrange.TM_END;

   {!
   |?
      {? _paczka.PLANNED='N'
      ||
         _msg:='Planowanie rekordu paczki: '+_paczka.SYMBOL;
         pxkomm.sect_beg(_msg);
::       czas biezacego etapu jest zalezny od etapu poprzednio zaplanowanego
::       etapy moga byc rownologle dlatego aby pobrac najmniejszy lub najwiekszy czas konczacy
::       plan poprzedniego etapu potrzebuje tabelki _times
         _argskont.TM_START:=_time_zero;
         _times.cntx_psh();
         {? PX_GRP.DIR>0
         || _times.prefix(_paczka.NUM_PREV)
         || _times.prefix(_paczka.NUM_NEXT)
         ?};
         {? _times.last()
         || _argskont.TM_START:=_times.TIME
         ?};
         _times.cntx_pop();
         {? var_pres('_plan_interval')>100
         || obj_del(_plan_interval)
         ?};
         _plan_interval:=exec('plan_add_kont','px_logix',_argskont);
         {? _plan_interval.END>0
         ||
            _times.blank();
            _times.NUM:=_paczka.NUM;
            _times.TIME:=_plan_interval.END;
            _times.add();
::       jesli cokolwiek sie udalo zaplanowac to wynik=1
            _result:=1
         || _msg:='Planowanie nieudane';
            pxkomm.error(_msg)
         ?};
         pxkomm.sect_end();
         ~~
      ?};

      _can_continue:={? _overmode=exec('overfill_stop','px_param') & PX_GRP.PL_FORCE<>'T'
                     ||
::                      Tryb planowania - zatrzymaj przetwarzanie kolejnych etapow jesli wystapilo przepelnienie
::                      poprzedniego etapu
                        _przepL:=exec('get_kom','px_komm','PX_GRP',PX_GRP.ref()
                                                                  ,exec('type_error','px_komm')
                                                                  ,exec('src_plan_termL','px_komm'));
                        _przepR:=exec('get_kom','px_komm','PX_GRP',PX_GRP.ref()
                                                                  ,exec('type_error','px_komm')
                                                                  ,exec('src_plan_termR','px_komm'));
                        {? _przepL=null() & _przepR=null()
                        || _paczka.next()
                        ||
::                         jesli petla zostala przerwana znaczy to ze plan jest niepelny
                           PX_GRP.PROBLEMS:=exec('problem_half','px_grp');
                           PX_GRP.put();

::                         Dodawanie komunikatu o niepełnym planie
                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=PX_VER.ref();
                           _komm_args.PX_GRP:=PX_GRP.ref();
                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.SRC_KIND:=exec('src_plan_half','px_komm');
                           _msg:='Przerwano planowanie dla %1 %2'[PX_GRP.SYMBOL,PX_GRP.NAZWA];
                           _msg+=' (nastąpiło przekroczenie mocy, parametr 500357 spowodował przerwanie planowania)';
                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args);
                           0
                        ?}
                     |? _overmode=exec('overfill_cont','px_param') | PX_GRP.PL_FORCE='T'
                     ||
::                       Tryb planowania - kontunuuj planowanie kolejnych etapow mimo wszystko
                        _paczka.next()
                     ?};
      _can_continue>0
   !}
?};
_result


\plan_pack2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Planuje paczke technologiczna - algorytm drzewiasty dla paczek ktore maja punkty czasowe
::       KONTEKST PRACY - PX_VER, PX_GRP
::   WE: _a - _args - wynik formuly exec('plan_grp_a','px_logix')
::   WY: obj_new - RESULT, REPLAN
::----------------------------------------------------------------------------------------------------------------------
_args:={? var_pres('_a')>100
       || _a
       || exec('plan_grp_a','px_logix')
       ?};

_result:=obj_new('RESULT','REPLAN');
_result.RESULT:=1;
_result.REPLAN:=0;

:: jezeli nie podano zewnetrznej tabeli zakresow (np. planowanie tylko jednej grupy), to tworze nowa
_tm_range:={? type_of(_args.TM_RANGE)>100
           || _args.TM_RANGE
           || exec('tm_range_create','px_logix')
           ?};

_paczka:=_args.PxPack.Paczka;

:: tworze indeks tymczasowy i sortuje paczke po polu NUM
:: pole to okresla sekwencje operacji (rownolegle operacje maja ten sam NUM)
:: indeks jest zorientowany wg kolejnosci planowania
_ndx_fwd:=_args.PxPack.Ndx_fwd;
_ndx_bck:=_args.PxPack.Ndx_bck;

:: Planowanie drzewiaste zawsze do przodu analizuje paczke
_paczka.index(_ndx_fwd);
::{? PX_GRP.DIR>0
::|| _paczka.index(_ndx_fwd)
::|| _paczka.index(_ndx_bck)
::?};

_paczka.prefix('K');
_envrange:=exec('get_env_range','px_con_g',_args.PX_GRP,_tm_range);

:: Szukam pierwszego rekordu paczki z punktami czasowymi i od niego rozpoczynam drzewiaste planowanie

{? _paczka.first()
||
   _argskont:=exec('plan_add_kont_a','px_logix');
   obj_del(_argskont.PACZKA);
   obj_del(_argskont.PXPACK);
   _argskont.PACZKA:=_paczka;
   _argskont.PXPACK:=_args.PxPack;
   _argskont.PX_VER:=PX_VER.ref();
   _argskont.PX_GRP:=PX_GRP.ref();
   _argskont.DIR:=PX_GRP.DIR;
   _argskont.RENUMERATE:=_args.RENUMERATE;
   _argskont.PD_OBJ:=_args.PD_OBJ;
   _argskont.STATUS:=_args.STATUS;
   _argskont.KOR_DLAY:=_args.KOR_DLAY;
   _argskont.KOR_WYK1:=_args.KOR_WYK1;
   _argskont.KOR_WYK2:=_args.KOR_WYK2;
   _argskont.KOR_BLK:=_args.KOR_BLK;
   _argskont.KOR_SKIP:=_args.KOR_SKIP;
   _argskont.KOR_TODAY:=_args.KOR_TODAY;

   _argstree:=exec('plan_pack_a','px_logix');
   _argstree.VER_DST:=PX_VER.ref();
   _argstree.PX_GRP:=PX_GRP.ref();
   obj_del(_argstree.PxPack);
   _argstree.PxPack:=_args.PxPack;
   _argstree.ENVRANGE:=_envrange;
   _argstree.pck_fwd:=_ndx_fwd;
   _argstree.pck_bck:=_ndx_bck;
   _argstree.pck_uid:=_args.PxPack.Ndx_uid;
   _argstree.pck_nast_fwd:=_args.PxPack.Ndx_nast_fwd;
   _argstree.pck_nast_bck:=_args.PxPack.Ndx_nast_bck;
   _argstree.DIR:=PX_GRP.DIR;
   _argstree.TM_ZERO:=_args.TM_ZERO;

   {!
   |?
      _time_zero:=0;

      {? _paczka.TM_MIN>0 | _paczka.TM_MAX>0
      ||
::       Znalazlem rekord paczki z punktem czasowym

::       Planuje najpierw siebie czyli operacje z podanym punktem czasowym
         {? var_pres('_rec_res')>100
         || obj_del(_rec_res)
         ?};
         _rec_res:=exec('plan_pack_tree','px_logix',_argstree,_argskont);

         {? _rec_res.REPLAN>0
         || _result.REPLAN:=1
         ?};
         {? _rec_res.RESULT<=0
         || _result.RESULT:=0
         ?}
      ?};
      _paczka.next() & _result.RESULT>0 & _result.REPLAN=0
   !};

   _args.TIMES:=tab_tmp(2,'UID','REAL','UID etapu na zasobie w procesie',
                        'TM_START','REAL','Czas rozpoczecia planu',
                        'TM_END','REAL','Czas zakonczenia planu');
   _tab_tree:=_argstree.TIMES;

   _tab_tree.cntx_psh();
   _tab_tree.clear();
   {? _tab_tree.first()
   || {!
      |? _args.TIMES.prefix(_tab_tree.UID);
         {? _args.TIMES.size()=0
         || _args.TIMES.blank();
            _args.TIMES.UID:=_tab_tree.UID;
            _args.TIMES.TM_START:=_tab_tree.TM_START;
            _args.TIMES.TM_END:=_tab_tree.TM_END;
            _args.TIMES.add(1)
         ?};
         _tab_tree.next()
      !}
   ?};
   _tab_tree.cntx_pop();
   _args.TIMES.prefix();

   {? _result.RESULT>0 & _result.REPLAN=0
   ||
::    Uruchamiam standardowy algorytm planujacy dla rekordow paczki ktore nie zostaly jeszcze zaplanowane
      _res_others:=exec('plan_pack3','px_logix',_args);
      {? _res_others.REPLAN>0
      || _result.REPLAN:=1
      ?};
      {? _res_others.RESULT<=0
      || _result.RESULT:=0
      ?}
   ?};

   {? _result.RESULT>0 & _result.REPLAN=0
   ||
::    Po zaplanowaniu paczki sprawdzam zazebienia
      exec('verify_zaz','px_logix',_args.PxPack,PX_VER.ref(),PX_GRP.ref())
   ?};
   ~~
?};
_result


\plan_pack3
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Planuje paczke technologiczna - algorytm standardowy z uwzględnieniem równoległości
::   WE: _a - _args - wynik formuly exec('plan_grp_a','px_logix')
::       KONTEKST PRACY - PX_GRP, PX_VER
::   WY: obj_new - RESULT, REPLAN
::----------------------------------------------------------------------------------------------------------------------
_args:={? var_pres('_a')>100
       || _a
       || exec('plan_grp_a','px_logix')
       ?};

_result:=obj_new('RESULT','REPLAN');
_result.RESULT:=1;
_result.REPLAN:=0;

:: jezeli nie podano zewnetrznej tabeli zakresow (np. planowanie tylko jednej grupy), to tworze nowa
_tm_range:={? type_of(_args.TM_RANGE)>100 || _args.TM_RANGE || exec('tm_range_create','px_logix') ?};

_paczka:=_args.PxPack.Paczka;

:: tworze indeks tymczasowy i sortuje paczke po polu NUM
:: pole to okresla sekwencje operacji (rownolegle operacje maja ten sam NUM)
:: indeks jest zorientowany wg kolejnosci planowania
_ndx_num:={? PX_GRP.DIR>0 || _args.PxPack.Ndx_fwd || _args.PxPack.Ndx_bck ?};
_paczka.index(_ndx_num);
_paczka.prefix('K');

:: GLOWNA PETLA PO KONTENERACH
{? exec('oper_first','px_logix',_args.PxPack,PX_GRP.DIR)
||
   _can_continue:=1;
   _overmode:=_args.overmode;

   _argskont:=exec('plan_add_kont_a','px_logix');
   obj_del(_argskont.PACZKA);
   obj_del(_argskont.PXPACK);
   _argskont.PX_VER:=PX_VER.ref();
   _argskont.PACZKA:=_paczka;
   _argskont.PXPACK:=_args.PxPack;
   _argskont.PX_GRP:=PX_GRP.ref();
   _argskont.DIR:=PX_GRP.DIR;
   _argskont.RENUMERATE:=_args.RENUMERATE;
   _argskont.STATUS:=_args.STATUS;
   _argskont.PD_OBJ:=_args.PD_OBJ;
   _time_zero:=0;
:: pobieram widelki czasowe wynikajace z PX_GRP.TM_*, a jesli puste, to poprzednikow i nastepnikow
:: _time_zero bedzie pobierany wlasnie na podstawie tej tablicy
   _envrange:=exec('get_env_range','px_con_g',_args.PX_GRP,_tm_range);

   {? PX_GRP.DIR>0
   || _time_zero:=_envrange.TM_START
   || _time_zero:=_envrange.TM_END
   ?};

   _argskont.KOR_DLAY:=_args.KOR_DLAY;
   _argskont.KOR_WYK1:=_args.KOR_WYK1;
   _argskont.KOR_WYK2:=_args.KOR_WYK2;
   _argskont.KOR_BLK:=_args.KOR_BLK;
   _argskont.KOR_SKIP:=_args.KOR_SKIP;
   _argskont.KOR_TODAY:=_args.KOR_TODAY;

   _argskont.TMGSTART:=_envrange.TM_START;
   {? _args.TM_ZERO>0
   ||
::    Normalizacja punktu poczatkowego do przekazanego punktu poczatku planu
::    nie moge planowac wczesniej niz przekazano
      _time_zero:=exec('max','#math',_args.TM_ZERO,_time_zero);
::    Jesli czas poczatku planu podany to granica nieprzekraczalna lewa
::    dla grupy nie moze byc wczesniej
      _argskont.TMGSTART:=exec('max','#math',_args.TM_ZERO,_argskont.TMGSTART)
   ?};
   _argskont.TMGEND:=_envrange.TM_END;

   _argstree:=exec('plan_pack_a','px_logix');
   _argstree.VER_DST:=PX_VER.ref();
   _argstree.PX_GRP:=PX_GRP.ref();
   obj_del(_argstree.PxPack);
   _argstree.PxPack:=_args.PxPack;
   _argstree.ENVRANGE:=_envrange;
   _argstree.pck_fwd:=_args.PxPack.Ndx_fwd;
   _argstree.pck_bck:=_args.PxPack.Ndx_bck;
   _argstree.pck_uid:=_args.PxPack.Ndx_uid;
   _argstree.pck_src:=_args.PxPack.Ndx_src;
   _argstree.pck_nast_fwd:=_args.PxPack.Ndx_nast_fwd;
   _argstree.pck_nast_bck:=_args.PxPack.Ndx_nast_bck;
   _argstree.DIR:=PX_GRP.DIR;
   _argstree.TM_ZERO:=_args.TM_ZERO;
   _argstree.CAN_NEXT:=0;
   _argstree.CAN_PREV:=0;
   {? var_pres('TIMES',_args)>100
   || obj_del(_argstree.TIMES);
      _argstree.TIMES:=_args.TIMES
   ?};
   {? _argstree.DIR>0
   || _argstree.CAN_NEXT:=1
   |? _argstree.DIR<0
   || _argstree.CAN_PREV:=1
   ?};

   {!
   |?
      {? _paczka.PLANNED='N'
      || {? var_pres('_rec_res')>100
         || obj_del(_rec_res)
         ?};
         _rec_res:=exec('plan_pack_tree','px_logix',_argstree,_argskont);
         {? _rec_res.REPLAN>0
         || _result.REPLAN:=1
         ?};
         {? _rec_res.RESULT<=0
         || _result.RESULT:=0
         ?}
      ?};

      _can_continue:={? _overmode=exec('overfill_stop','px_param') & PX_GRP.PL_FORCE<>'T'
                     ||
::                      Tryb planowania - zatrzymaj przetwarzanie kolejnych etapow jesli wystapilo przepelnienie
::                      poprzedniego etapu
                        _przepL:=exec('get_kom','px_komm','PX_GRP',PX_GRP.ref()
                                                                  ,exec('type_error','px_komm')
                                                                  ,exec('src_plan_termL','px_komm'));
                        _przepR:=exec('get_kom','px_komm','PX_GRP',PX_GRP.ref()
                                                                  ,exec('type_error','px_komm')
                                                                  ,exec('src_plan_termR','px_komm'));
                        {? _przepL=null() & _przepR=null()
                        || exec('oper_first','px_logix',_args.PxPack,PX_GRP.DIR)
                        ||
::                         jesli petla zostala przerwana znaczy to ze plan jest niepelny
                           PX_GRP.PROBLEMS:=exec('problem_half','px_grp');
                           PX_GRP.put();

::                         Dodawanie komunikatu o niepełnym planie
                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=PX_VER.ref();
                           _komm_args.PX_GRP:=PX_GRP.ref();
                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.SRC_KIND:=exec('src_plan_half','px_komm');
                           _msg:='Przerwano planowanie dla '+PX_GRP.SYMBOL+' '+PX_GRP.NAZWA;
                           _msg+=' (nastąpiło przekroczenie mocy, parametr 500357 spowodował przerwanie planowania)';
                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args);
                           0
                        ?}
                     |? _overmode=exec('overfill_cont','px_param') | PX_GRP.PL_FORCE='T'
                     ||
::                       Tryb planowania - kontunuuj planowanie kolejnych etapow mimo wszystko
                        exec('oper_first','px_logix',_args.PxPack,PX_GRP.DIR)
                     ?};
      _can_continue>0 & _result.RESULT>0 & _result.REPLAN=0
   !}
||
:: Nie znaleziono żadnej operacji od której można zacząć planowanie, sprawdzam czy cokolwiek zostało zaplanowane
   _paczka.cntx_psh();
   _paczka.index(_ndx_num);
   _paczka.prefix('K');
   _empty:=1;
   {? _paczka.first()
   || {!
      |? {? exec('pck_oper_planned','px_tex',_paczka)>0
         || _empty:=0
         ?};
         _paczka.next() & _empty>0
      !}
   ?};
   _paczka.cntx_pop();

   {? _empty>0
   ||
::    Nic nie zaplanowano, zgłaszam komunikat
      {? var_pres('_komm_args')>100
      || obj_del(_komm_args)
      ?};
      _komm_args:=exec('add_komm_a','px_komm');
      _komm_args.PX_VER:=PX_VER.ref();
      _komm_args.PX_GRP:=PX_GRP.ref();
      _komm_args.TYP:=exec('type_error','px_komm');
      _komm_args.SRC_KIND:=exec('src_plan_half','px_komm');
      _msg:='Nie udało się zaplanować %1 na żaden zasób. Prawdopodobnie przepis planistyczny jest błędnie zdefiniowany.'@[PX_GRP.SYMBOL+' '+PX_GRP.NAZWA];
      _komm_args.MESSAGE:=_msg;
      exec('add_komm','px_komm',_komm_args)
   ?}
?};
_result


\plan_pack_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tablica parametrów dla \plan_pack_tree
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
::             PX_VER.ref() - wersja w ktorej bede planowal
               'VER_DST',
::             PX_GRP.ref() - obiekt grupujacy ktory planuje
               'PX_GRP',
::             obj_new -  paczka technologiczna ktora mowi mi jak zaplanowac i gdzie
::                         struktra paczki w funkcji exec('PxPack_declare','px_tex')
               'PxPack',

::             Kierunek planowania aktualnego rekordu paczki
               'DIR',

::             Kierunek planowania nastepnych rekordow paczki
               'DIR_NEXT',
::             Czas poczatku nowej wersji planu
               'TM_ZERO',

::             Czy można planować następne operacje
               'CAN_NEXT',

::             Czy można planować poprzednie operacje
               'CAN_PREV',

::             Tabela, w ktorej bedzie odpisywany przedzial zaplanowania grupy
::             obj_new('SQLREF','TM_START','TM_END')
               'ENVRANGE',
::             Tabela w ktorej bede trzymal konce planu kazdego z zaplanowanych juz etapow
               'TIMES',
::             Indeksy tabeli TIMES
               'ndx_up',
               'ndx_down',

::             Indeksy tymczasowe paczki
               'pck_fwd',
               'pck_bck',
               'pck_uid',
               'pck_src',
               'pck_nast_fwd',
               'pck_nast_bck',
::             _overmode
               'overmode'
               );
:: zwracamy deklaracje argumentow

_args.VER_DST:=null();
_args.PX_GRP:=null();
_args.PxPack:=obj_new('dummy');
_args.overmode:=exec('get','#params',500357,2);
_args.TIMES:=tab_tmp(2,'UID','REAL','UID etapu na zasobie w procesie',
                        'TM_START','REAL','Czas rozpoczecia planu',
                        'TM_END','REAL','Czas zakonczenia planu');
::_args.ndx_up:=_args.TIMES.ndx_tmp(,,'NUM',,0,'TM_START',,0);
::_args.ndx_down:=_args.TIMES.ndx_tmp(,,'NUM',,1,'TM_START',,1);
_args.DIR:=0;
_args.DIR_NEXT:=0;
_args.CAN_NEXT:=1;
_args.CAN_PREV:=1;
_args


\plan_pack_tree
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Planuje aktualny rekord paczki technologicznej, a nastepnie wszystkie poprzedniki
::       lub nastepniki
::   WE: _a - _args - tablica argumentow, wynik funkcji exec('plan_pack_a','px_logix')
::       _b - _argskont - tablica argumentow, wynik funkcji exec('plan_add_kont_a','px_logix')
::       [_c] - obj_new - tablica refów dla wywołań rekurencyjnych
::   WY: obj_new - RESULT, REPLAN
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('plan_pack_a','px_logix')
?};
{? var_pres('_b')>100
|| _argskont:=_b
|| _argskont:=exec('plan_add_kont_a','px_logix')
?};
{? var_pres('_c')>100
|| _visited:=_c
|| _visited:=exec('ref_table','#table')
?};

_paczka:=_args.PxPack.Paczka;
_result:=obj_new('RESULT','REPLAN');
_result.RESULT:=1;
_result.REPLAN:=0;
_can_continue:=1;

:: Określam kierunek planowania
_dir:=_args.DIR;
_argskont.DIR:=_args.DIR;

_paczka.cntx_psh();

:: pobieram widelki czasowe wynikajace z PX_GRP.TM_*, a jesli puste, to poprzednikow i nastepnikow
:: _time_zero bedzie pobierany wlasnie na podstawie tej tablicy
_envrange:=_args.ENVRANGE;
_times:=_args.TIMES;

{? PX_GRP.DIR>0
|| _time_zero:=_envrange.TM_START
|| _time_zero:=_envrange.TM_END
?};

_argskont.TMGSTART:=_envrange.TM_START;
{? _args.TM_ZERO>0
||
:: Normalizacja punktu poczatkowego do przekazanego punktu poczatku planu
:: nie moge planowac wczesniej niz przekazano
   _time_zero:=exec('max','#math',_args.TM_ZERO,_time_zero);

:: Jesli czas poczatku planu podany to granica nieprzekraczalna lewa
:: dla grupy nie moze byc wczesniej
   _argskont.TMGSTART:=exec('max','#math',_args.TM_ZERO,_argskont.TMGSTART)
?};

_argskont.TMGEND:=_envrange.TM_END;

{? _paczka.PLANNED='N' & exec('oper_nast_chk','px_logix',_args.PxPack,_dir)>0
||
   _result.RESULT:=0;
   _paczka.PLANNED:='T';
   _paczka.put();
:: Planuje tylko te rekordy ktore jeszcze nie zostaly zaplanowane
   _overmode:=_args.overmode;

   _dir:=_args.DIR;
   _tm_override:=0;
   _has_point:=0;
   {? _paczka.TM_MIN>0 & _paczka.TM_MAX>0
   || _has_point:=1;
::    Jeśli punkt czasowy zawiera obydwa czasy, to planowanie zgodnie z kierunkiem grupy
      _dir:=PX_GRP.DIR
   |? _paczka.TM_MIN>0 & _paczka.TM_MAX=0
   || _has_point:=1;
::    Podany jest minimalny czas startu - planuje do przodu
      _dir:=1
   |? _paczka.TM_MIN=0 & _paczka.TM_MAX>0
   || _has_point:=1;
::    Podany jest maksymalny czas konca - planuje wstecz
      _dir:=-1
   ?};

   {? _has_point>0
   ||
      {? _dir>0
      ||
::       Planowanie do przodu - punktem startowym planu bedzie wiekszy ze zbioru:
::          - granica obiektu 'OD'
::          - minimalny czas startu etapu
         _tm_override:=exec('max','#math',_paczka.TM_MIN,_envrange.TM_START)
      ||
::       Planowanie wstecz - punktem startowym bedzie mniejszy ze zbioru
::          - granica obiektu 'DO'
::          - maksymalny czas konca etapu
         _tm_override:=exec('min','#math',_paczka.TM_MAX,_envrange.TM_END)
      ?}
   ?};
   _msg:='Planowanie rekordu paczki: '+_paczka.SYMBOL;
   pxkomm.sect_beg(_msg);
:: czas biezacego etapu jest zalezny od etapu poprzednio zaplanowanego
:: etapy moga byc rownologle dlatego aby pobrac najmniejszy lub najwiekszy czas konczacy
:: plan poprzedniego etapu potrzebuje tabelki _times

   _last:=_time_zero;
   _last:=exec('oper_start','px_logix',_args.PxPack,_dir,_times,,1);
   {? _last=0
   || _last:=_time_zero
   ?};

   {? _tm_override>0
   ||
::    Czas z punktu czasowego jest podany, ale musze uwzglednic czas ostatniej operacji tez, zeby sie nie nalozylo
      {? _dir>0
      || _argskont.TM_START:=exec('max','#math',_envrange.TM_START,_tm_override)
      || _argskont.TM_START:=exec('min','#math',_envrange.TM_END,_tm_override)
      ?}
   ||
::    Czas z punktu czasowego nie jest podany - korzystam albo z czasu startowego dla calej
::    grupy albo z czasu zakonczenia ostatniego etapu
      _argskont.TM_START:=_last
   ?};

   _argskont.DIR:=_dir;

   _plan_interval:=exec('plan_add_kont','px_logix',_argskont);
   _result.REPLAN:=_plan_interval.REPLAN;
   {? _plan_interval.END>0
   ||
      _times.blank();
      _times.UID:=_paczka.UID;
      _times.TM_START:=exec('min','#math',_plan_interval.START,_plan_interval.END);
      _times.TM_END:=exec('max','#math',_plan_interval.START,_plan_interval.END);
      _times.add();
::    jesli cokolwiek sie udalo zaplanowac to wynik=1
      _result.RESULT:=1
   || _msg:='Planowanie nieudane';
      pxkomm.error(_msg);
      _result.RESULT:=0;
      _can_continue:=0
   ?};

   {? _plan_interval.REPLAN>0
   || _can_continue:=0
   ?};

   pxkomm.sect_end();

   {? _can_continue>0
   ||
::    Sprawdzam czy jest sens dalej planowac
      _can_continue:={? _overmode=exec('overfill_stop','px_param') & PX_GRP.PL_FORCE<>'T'
                     ||
::                      Tryb planowania - zatrzymaj przetwarzanie kolejnych etapow jesli wystapilo przepelnienie
::                      poprzedniego etapu
                        _przepL:=exec('get_kom','px_komm','PX_GRP',PX_GRP.ref()
                                                                  ,exec('type_error','px_komm')
                                                                  ,exec('src_plan_termL','px_komm'));
                        _przepR:=exec('get_kom','px_komm','PX_GRP',PX_GRP.ref()
                                                                  ,exec('type_error','px_komm')
                                                                  ,exec('src_plan_termR','px_komm'));
                        {? _przepL<>null() & _przepR<>null()
                        ||
::                         jesli petla zostala przerwana znaczy to ze plan jest niepelny
                           PX_GRP.PROBLEMS:=exec('problem_half','px_grp');
                           PX_GRP.put();

::                         Dodawanie komunikatu o niepełnym planie
                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=PX_VER.ref();
                           _komm_args.PX_GRP:=PX_GRP.ref();
                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.SRC_KIND:=exec('src_plan_half','px_komm');
                           _msg:='Przerwano planowanie dla %1 %2'[PX_GRP.SYMBOL,PX_GRP.NAZWA];
                           _msg+=' (nastąpiło przekroczenie mocy, parametr 500357 spowodował przerwanie planowania)';
                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args);
                           0
                        || 1
                        ?}
                     || 1
                     ?}
   ?};
   {? _can_continue>0
   ||
::    PLANOWANIE OPERACJI O TYM SAMYM NUMERZE (ten sam, etap ale inny zasob)
      _paczka.cntx_psh();
      _paczka.index(_args.pck_fwd);
      _paczka.prefix('K',_paczka.NUM);
      {? _paczka.first()
      || {!
         |?
            {? _paczka.PLANNED='N'
            ||
::             !!! REKURENCJA !!!
               {? var_pres('_rec_res')>100
               || obj_del(_rec_res)
               ?};
               _rec_res:=exec('plan_pack_tree','px_logix',_args,_argskont);
               {? _rec_res.REPLAN>0
               || _result.REPLAN:=1
               ?};
               {? _rec_res.RESULT<=0
               || _result.RESULT:=0
               ?}
            ?};
            _paczka.next() & _result.RESULT>0 & _result.REPLAN=0
         !}
      ?};
      _paczka.cntx_pop()
   ?}
?};

_prev_before:=_args.CAN_PREV;
_next_before:=_args.CAN_NEXT;

{? _can_continue>0
||
:: PLANOWANIE SAMYCH MOICH POPRZEDNIKOW
   {? _args.CAN_PREV>0
   ||
      _args.CAN_PREV:=0;
      _args.CAN_NEXT:=0;
      _paczka.cntx_psh();
      {? _dir>0
      || _paczka.index(_args.pck_nast_fwd)
      || _paczka.index(_args.pck_nast_bck)
      ?};
      _paczka.prefix('P',_paczka.NUM);
      {? _paczka.first()
      || {!
         |?
::          Stoję na rekordzie paczki typu 'Poprzednik' - muszę przejść na operację którą
::          wkazuje
            _paczka.cntx_psh();
            _paczka.index(_args.pck_uid);
            _paczka.prefix(_paczka.UID_SRC);
            {? _paczka.first()
            ||
               {? _paczka.PLANNED='N'
               ||
                  _args.DIR:=-1;
::                !!! REKURENCJA !!!
                  {? var_pres('_rec_res')>100
                  || obj_del(_rec_res)
                  ?};
                  _rec_res:=exec('plan_pack_tree','px_logix',_args,_argskont);
                  {? _rec_res.REPLAN>0
                  || _result.REPLAN:=1
                  ?};
                  {? _rec_res.RESULT<=0
                  || _result.RESULT:=0
                  ?}
               ?}
            ?};
            _paczka.cntx_pop();
            _paczka.next() & _result.RESULT>0 & _result.REPLAN=0
         !}
      ?};
      _paczka.cntx_pop();
      _args.CAN_PREV:=_prev_before;
      _args.CAN_NEXT:=_next_before;
      ~~
   ?};

:: PLANOWANIE SAMYCH MOICH NASTEPNIKOW
   {? _args.CAN_NEXT>0
   || _args.CAN_NEXT:=0;
      _args.CAN_PREV:=0;
      _paczka.cntx_psh();
      {? _dir>0
      || _paczka.index(_args.pck_nast_fwd)
      || _paczka.index(_args.pck_nast_bck)
      ?};
      _paczka.prefix('N',_paczka.NUM);
      {? _paczka.first()
      || {!
         |?
::          Stoję na rekordzie paczki typu 'Następnik' - muszę przejść na operację którą
::          wkazuje
            _paczka.cntx_psh();
            _paczka.index(_args.pck_uid);
            _paczka.prefix(_paczka.UID_SRC);
            {? _paczka.first()
            ||
               {? _paczka.PLANNED='N'
               ||
                  _args.DIR:=1;
::                !!! REKURENCJA !!!
                  {? var_pres('_rec_res')>100
                  || obj_del(_rec_res)
                  ?};
                  _rec_res:=exec('plan_pack_tree','px_logix',_args,_argskont);
                  {? _rec_res.REPLAN>0
                  || _result.REPLAN:=1
                  ?};
                  {? _rec_res.RESULT<=0
                  || _result.RESULT:=0
                  ?}
               ?}
            ?};
            _paczka.cntx_pop();
            _paczka.next() & _result.RESULT>0 & _result.REPLAN=0
         !}
      ?};
      _paczka.cntx_pop();
      _args.CAN_NEXT:=_next_before;
      _args.CAN_PREV:=_prev_before;
      ~~
   ?}
?};

{? _can_continue>0
||
:: PLANOWANIE ŚCIEŻEK POPRZEDNIKOW
   {? _args.CAN_PREV>0
   ||
      _paczka.cntx_psh();
      {? _dir>0
      || _paczka.index(_args.pck_nast_fwd)
      || _paczka.index(_args.pck_nast_bck)
      ?};
      _paczka.prefix('P',_paczka.NUM);
      {? _paczka.first()
      || {!
         |?
::          Stoję na rekordzie paczki typu 'Poprzednik' - muszę przejść na operację którą
::          wkazuje
            _paczka.cntx_psh();
            _paczka.index(_args.pck_uid);
            _paczka.prefix(_paczka.UID_SRC);
            {? _paczka.first()
            ||
               {? _visited.r_find(_paczka.ref())=0
               || _visited.add(_paczka.ref());
                  _args.DIR:=-1;
::                !!! REKURENCJA !!!
                  {? var_pres('_rec_res')>100
                  || obj_del(_rec_res)
                  ?};
                  _rec_res:=exec('plan_pack_tree','px_logix',_args,_argskont,_visited);
                  {? _rec_res.REPLAN>0
                  || _result.REPLAN:=1
                  ?};
                  {? _rec_res.RESULT<=0
                  || _result.RESULT:=0
                  ?}
               ?}
            ?};
            _paczka.cntx_pop();
            _paczka.next() & _result.RESULT>0 & _result.REPLAN=0
         !}
      ?};
      _paczka.cntx_pop();
      ~~
   ?};

:: PLANOWANIE ŚCIEŻEK NASTEPNIKOW
   {? _args.CAN_NEXT>0
   ||
      _paczka.cntx_psh();
      {? _dir>0
      || _paczka.index(_args.pck_nast_fwd)
      || _paczka.index(_args.pck_nast_bck)
      ?};
      _paczka.prefix('N',_paczka.NUM);
      {? _paczka.first()
      || {!
         |?
::          Stoję na rekordzie paczki typu 'Następnik' - muszę przejść na operację którą
::          wkazuje
            _paczka.cntx_psh();
            _paczka.index(_args.pck_uid);
            _paczka.prefix(_paczka.UID_SRC);
            {? _paczka.first()
            ||
               {? _visited.r_find(_paczka.ref())=0
               || _visited.add(_paczka.ref());
                  _args.DIR:=1;
::                !!! REKURENCJA !!!
                  {? var_pres('_rec_res')>100
                  || obj_del(_rec_res)
                  ?};
                  _rec_res:=exec('plan_pack_tree','px_logix',_args,_argskont,_visited);
                  {? _rec_res.REPLAN>0
                  || _result.REPLAN:=1
                  ?};
                  {? _rec_res.RESULT<=0
                  || _result.RESULT:=0
                  ?}
               ?}
            ?};
            _paczka.cntx_pop();
            _paczka.next() & _result.RESULT>0 & _result.REPLAN=0
         !}
      ?};
      _paczka.cntx_pop();
      ~~
   ?}
?};


{? _can_continue<=0 & _result.REPLAN=0
|| _result.RESULT:=0
?};
_paczka.cntx_pop();
_paczka.get();
_result


\plan_add_kont_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Tablica parametrów dla plan_to_kont
::   WE: --
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PX_VER',
               'PACZKA',
               'PXPACK',
               'PX_GRP',
               'TM_START',
               'DIR',
::             Czy robic korekte opoznionych
               'KOR_DLAY',
::             Czy robic korekte wykonywanych
               'KOR_WYK1',
::             Czy robic korekte wykonanych
               'KOR_WYK2',
::             Czy robic korekte zablokowanych
               'KOR_BLK',
::             Czy robic korekte porzuconych
               'KOR_SKIP',
::             Czy robic korekte zaplanowanych na podstawie planu operacyjnego
               'KOR_OPER',
::             Czy robic korekte zaplanowanych na bizacym pojemniku
               'KOR_TODAY',
::             Lewy margines planowania grupy
               'TMGSTART',
::             Prawy margines planowania grupy
               'TMGEND',
::             _overmode
               'overmode',
::             Czy podczas dodawania pozycji na pojemnik wykonywac renumeracje pozycji?
               'RENUMERATE',
::             Status pozycji planu jaki jej ustawic od razu po utworzeniu
               'STATUS',
::             Obiekt do planowania na podstawie planu dostaw
               'PD_OBJ'
               );
::argumenty domyslne
_args.PX_VER:=null();
_pxpack:=exec('PxPack_declare','px_tex');
_args.PACZKA:=_pxpack.Paczka;
_args.PXPACK:=_pxpack;
_args.PX_GRP:=null();
_args.DIR:=-1;
_args.TM_START:=0;
_args.KOR_DLAY:=1;
_args.KOR_WYK1:=1;
_args.KOR_WYK2:=1;
_args.KOR_BLK:=1;
_args.KOR_TODAY:=1;
_args.KOR_SKIP:=1;
_args.KOR_OPER:=1;
_args.TMGSTART:=0;
_args.TMGEND:=0;
_args.overmode:=exec('get','#params',500357,2);
_args.RENUMERATE:=1;
_args.STATUS:='';
_args.PD_OBJ:=~~;
:: zwracamy argumenty
_args


\plan_add_kont_result
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Tablica nazwana - wynik formuły exec('plan_add_kont','px_logix')
::   WY: obj_new()
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new(  'START',
                'END',
                'REPLAN');
_obj.START:=0;
_obj.END:=0;
_obj.REPLAN:=0;
_obj


\plan_add_kont
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Planuje biezacy rekord paczki technologicznej na dany kontener
::   WE: _a - _args
::   WY: exec('interval','#interval') - interwal czasu zawierajacy od kiedy sie zaczyna i kiedy sie konczy utworzony plan
::----------------------------------------------------------------------------------------------------------------------
_args:={?_>=1 || _a || exec('plan_add_kont_a','px_logix') ?};

_result:=exec('plan_add_kont_result','px_logix');
_paczka:=_args.PACZKA;
PX_KONT.cntx_psh();
PX_KONT.index('ACT');
PX_KONT.clear();
PX_GRP.cntx_psh();
PX_GRP.clear();
PX_STAGE.cntx_psh();
PX_STAGE.clear();

_overmode:=_args.overmode;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

_msg:='plan_add_kont\px_logix - Planowanie na kontenerze';
pxkomm.sect_beg(_msg);

{? PX_GRP.seek(_args.PX_GRP)
|| {? PX_STAGE.seek(_paczka.PX_STAGE)
   ||
::    ustawiam sie na kontenerze w planie glownym ktory jest podany jako docelowy do zaplanowania w paczce
      {? PX_KONT.seek(_paczka.REF_KONT)
      ||
::       szukam takiego kontenera rzeczywistego i aktywnego w wersji na ktora planuje, ktory ma taki sam symbol i nazwe
         PX_KONT.prefix('T',_args.PX_VER,PX_KONT.SYMBOL,);
         {? PX_KONT.first()
         ||
            _start_found:=0;
            _tm_start:=_args.TM_START;
::          Obsluga kooperacji - sprawdzam czy operacja jest kooperacyjna - jesli tak to start
::          jest ustawiony na podstawie kooperacji
            {? _paczka.COOP>0
            ||
               {? _args.DIR>0
               ||
::                Planowanie w przod
                  _tm_start:=_paczka.TM_START;

::                Jesli poczatek wynikajacy z kooperacji wczesniej niz wynikajacy z PX_GRP
::                lub nastepstwa operacji to powstaje konflikt kooperacyjny
                  {? _paczka.TM_START<_args.TM_START
                  ||
                     PX_GRP.PROBLEMS:=exec('problem_coop','px_grp');
                     PX_GRP.put();

::                   Dodawanie komunikatu o problemie z kooperacja
                     {? var_pres('_komm_args')>100
                     || obj_del(_komm_args)
                     ?};
                     _komm_args:=exec('add_komm_a','px_komm');
                     _komm_args.PX_VER:=_args.PX_VER;
                     _komm_args.PX_GRP:=PX_GRP.ref();
                     _komm_args.TYP:=exec('type_error','px_komm');
                     _komm_args.SRC_KIND:=exec('src_plan_coop','px_komm');
                     _msg:='Plan grupy: %1 narusza ustalony początek kooperacji'[PX_GRP.SYMBOL];
                     _msg+=' (należy ustalić inne granice czasowe kooperacji, lub grupy)';
                     _komm_args.MESSAGE:=_msg;
                     exec('add_komm','px_komm',_komm_args)
                  ?}
               ||
::                Planowanie w tyl
                  _tm_start:=_paczka.TM_END;

::                Jesli koniec wynikajacy z kooperacji pozniej niz wynikajacy z PX_GRP
::                lub nastepstwa operacji to powstaje konflikt kooperacyjny
                  {? _paczka.TM_END>_args.TM_START
                  ||
                     PX_GRP.PROBLEMS:=exec('problem_coop','px_grp');
                     PX_GRP.put();

::                   Dodawanie komunikatu o problemie z kooperacja
                     {? var_pres('_komm_args')>100
                     || obj_del(_komm_args)
                     ?};
                     _komm_args:=exec('add_komm_a','px_komm');
                     _komm_args.PX_VER:=_args.PX_VER;
                     _komm_args.PX_GRP:=PX_GRP.ref();
                     _komm_args.TYP:=exec('type_error','px_komm');
                     _komm_args.SRC_KIND:=exec('src_plan_coop','px_komm');
                     _msg:='Plan grupy: %1 narusza ustalony koniec kooperacji'[PX_GRP.SYMBOL];
                     _msg+=' (należy ustalić inne granice czasowe kooperacji, lub grupy)';
                     _komm_args.MESSAGE:=_msg;
                     exec('add_komm','px_komm',_komm_args)
                  ?}
               ?}
            ||
::             Operacje niekooperacyjną może mieć przesunięty start/koniec ze względu
::             na czas nakładkowania albo transportu
               {? PX_VAR.NAST_ALG=2
               || _tm_start:=exec('oper_offset','px_logix',_args.PXPACK,_tm_start,_args.DIR)
               ?}
            ?};

            _mainver:=exec('get_mainversion','px_ver');
::          KOREKTA ILOSCI WYKONYWANYCH
            _kor:=obj_new(1);
            {? _args.KOR_WYK1>0
            ||
               obj_del(_kor);
               {? _args.PX_VER=_mainver
               || _kor:=exec('count_status','px_poz', PX_GRP.UID,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID,
                                                      exec('status_wyk1','px_poz'))
               || _kor:=exec('count_status','px_poz', PX_GRP.UID_SRC,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID_SRC,
                                                      exec('status_wyk1','px_poz'))
               ?};

               exec('paczka_korekta','px_tex',_paczka,_kor,-1)
            ?};

::          KOREKTA ILOSCI WYKONANYCH
            {? _args.KOR_WYK2>0
            ||
               obj_del(_kor);
               {? _args.PX_VER=_mainver
               || _kor:=exec('count_status','px_poz', PX_GRP.UID,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID,
                                                      exec('status_wyk2','px_poz'))
               || _kor:=exec('count_status','px_poz', PX_GRP.UID_SRC,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID_SRC,
                                                      exec('status_wyk2','px_poz'))
               ?};
               exec('paczka_korekta','px_tex',_paczka,_kor,-1)
            ?};

::          KOREKTA ILOSCI OPÓŹNIONYCH
            {? _args.KOR_DLAY>0
            ||
               obj_del(_kor);
               {? _args.PX_VER=_mainver
               || _kor:=exec('count_status','px_poz', PX_GRP.UID,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID,
                                                      exec('status_delay','px_poz'))
               || _kor:=exec('count_status','px_poz', PX_GRP.UID_SRC,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID_SRC,
                                                      exec('status_delay','px_poz'))
               ?};
               exec('paczka_korekta','px_tex',_paczka,_kor,-1)
            ?};

::          KOREKTA ILOSCI ZABLOKOWANYCH
            {? _args.KOR_BLK>0
            ||
               obj_del(_kor);
               {? _args.PX_VER=_mainver
               || _kor:=exec('count_blk','px_poz',    PX_GRP.UID,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID)
               || _kor:=exec('count_blk','px_poz',    PX_GRP.UID_SRC,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID_SRC)
               ?};
               exec('paczka_korekta','px_tex',_paczka,_kor,-1)
            ?};

::          KOREKTA ILOSCI PORZUCONYCH
            {? _args.KOR_SKIP>0
            ||
               obj_del(_kor);
               {? _args.PX_VER=_mainver
               || _kor:=exec('count_status','px_poz', PX_GRP.UID,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID,
                                                      exec('status_skipped','px_poz'))
               || _kor:=exec('count_status','px_poz', PX_GRP.UID_SRC,
                                                      PX_STAGE.ref(),
                                                      PX_KONT.UID_SRC,
                                                      exec('status_skipped','px_poz'))
               ?};
               exec('paczka_korekta','px_tex',_paczka,_kor,-1)
            ?};

::          Jesli po korektach cos zostalo to planuje, jesli nie to jako wynik zwracam moment startu wejsciowy
            {? exec('pck_oper_empty','px_tex',_paczka)>0
            ||
               _paczka.EMPTY:='N';
               _paczka.put();
               _tab:=~~;
               _lane:=~~;
               {? PX_VAR.NAST_ALG=2
               ||
::                Algorytm nakładkowania metodą proporcji czasowej działa w oparciu o PX_CAL
                  _tab:=PX_CAL;
                  {? _paczka.WEW='N'
                  || _lane:=_paczka.LANE
                  ?}
               ||
::                Standardowe planowanie działa w oparciu o PX_CUP
                  _tab:=PX_CUP
               ?};
::             szukam pierwszego niezablokowanego pojemnika w kontenerze od granicy planowania podanej na PX_GRP
::             zgodnie ze zwrotem planowania
               {? exec('first_cup','px_logix',_tm_start,_args.DIR,_args.PXPACK,PX_GRP.TM_START,PX_GRP.TM_END,_tab,_lane)>0
               || _start_found:=1
               ||
::                jesli parametr 500357 mowi ze w razie przekroczen zawsze planuje to odwracam
::                zwrot planowania i szukam najblizszego pojemnika wzgledem punktu czasowego docelowego
                  {? _overmode=exec('overfill_cont','px_param')
                  || _dir_negative:=-1*_args.DIR;
                     {? exec('cup_closest','px_plan',PX_KONT.ref(),_args.TM_START,_dir_negative)>0
                     || _start_found:=1;

::                      Raportuje problem na PX_GRP - przepełnienie
                        {? _args.DIR>0
                        || PX_GRP.PROBLEMS:=exec('problem_termR','px_grp');
                           PX_GRP.put();

::                         Dodawanie komunikatu o problemie
                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=_args.PX_VER;
                           _komm_args.PX_GRP:=PX_GRP.ref();
                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.PX_CUP:=PX_CUP.ref();
                           _komm_args.SRC_KIND:=exec('src_plan_termR','px_komm');
                           _msg:='Nie znaleziono żądanego pojemnika początkowego podczas planowania grupy: %1'[PX_GRP.SYMBOL];
                           _msg+=' (nowym pojemnikiem początkowym jest: %1, ale spowodowało to zazębienie się planu).'[PX_CUP.SYMBOL];
                           _msg+=' Zasób: %1.'[PX_KONT.SYMBOL];
                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args)

                        || PX_GRP.PROBLEMS:=exec('problem_termL','px_grp');
                           PX_GRP.put();

::                         Dodawanie komunikatu o problemie
                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=_args.PX_VER;
                           _komm_args.PX_GRP:=PX_GRP.ref();
                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.PX_CUP:=PX_CUP.ref();
                           _komm_args.SRC_KIND:=exec('src_plan_termL','px_komm');
                           _msg:='Nie znaleziono żądanego pojemnika początkowego podczas planowania grupy: %1'[PX_GRP.SYMBOL];
                           _msg+=' (nowym pojemnikiem początkowym jest: %1, ale spowodowało to zazębienie się planu).'[PX_CUP.SYMBOL];
                           _msg+=' Zasób: %1.'[PX_KONT.SYMBOL];
                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args)
                        ?}
                     ?}
                  ?}
               ?};
               {? _start_found>0
               ||
::                tutaj mam juz kontekst ustawiony na odpowiedniego PX_CUP lub PX_CAL
::                tabela PX_CUP/PX_CAL ma tez odpowiedni indeks ustawiony zgodny ze zwrotem planowania
::                GLOWNA PETLA PLANUJACA NA KONTENERZE
::                wrzucam na kolejne pojemniki az wykorzystam cala ilosc z wymiaru podstawowego
                  _left:=1;
                  _last_il:=_paczka.CAP_DIM1;
                  _last_start:=0;
                  _last_end:=0;
                  _first_cup:=PX_CUP.ref();

                  _can_continue:=1;

                  _argscup:=exec('plan_add_cup_a','px_logix');
                  _argscup.PACZKA:=_args.PACZKA;
                  _argscup.PXPACK:=_args.PXPACK;
                  _argscup.PX_GRP:=PX_GRP.ref();
                  _argscup.PX_STAGE:=PX_STAGE.ref();
                  _argscup.DIR:=_args.DIR;
                  _argscup.TM_END:=_args.TMGEND;
                  _argscup.RENUMERATE:=_args.RENUMERATE;
                  _argscup.STATUS:=_args.STATUS;
                  _argscup.OPER_START:=_tm_start;

::                Kontrola czy pierwszy pojemnik nie przekracza terminu
                  _first_chk:=exec('termin_chk','px_logix',_args.TMGSTART,_args.TMGEND,_args.DIR,_paczka,_tab);
                  {? _first_chk<=0
                  || _can_continue:=0
                  ?};
                  _il_wym:=exec('il_wym','px_param');
                  _added:=obj_new(_il_wym);
                  {! _it:=1.._il_wym
                  |! _added[_it]:=0
                  !};
::                PETLA PO KOLEJNYCH POJEMNIKACH
                  {? _first_chk>0
                  || _last_start:=_tab.TM_START;
                     _last_end:=_tab.TM_END;
                     {!
                     |?
::                      zapamietuje ostatni pojemnik do ktorego moge cos wsypac w razie brutalizacji
                        _next:=0;
                        _ref_nxt:=null();
                        _tab.cntx_psh();
                        {? _args.DIR>0
                        ||
                           {? _tab.next()
                           || _ref_nxt:=_tab.ref()
                           ?}
                        || {? _tab.prev()
                           || _ref_nxt:=_tab.ref()
                           ?}
                        ?};
                        _tab.cntx_pop();

                        _can_plan:=1;

                        {? PX_VAR.NAST_ALG=2 & _paczka.LANE>-1
                        ||
::                         Jeżeli operacja w paczce ma określony poziom kalendarza
::                         to żeby zaplanować, muszę być na PX_CAL o tym poziomie
                           {? PX_CAL.LEVEL<>_paczka.LANE
                           || _can_plan:=0
                           ?}
                        ?};

::                      !!! Właściwe planowanie !!!
                        {? _can_plan>0
                        ||
                           {? PX_CUP.STATUS=exec('status_normal','px_cup')
                           || _last_start:=PX_CUP.TM_START;
                              _last_end:=PX_CUP.TM_END
                           ?};

                           {? var_pres('_added')>0
                           || obj_del(_added)
                           ?};
                           _added:=exec('plan_add_cup','px_logix',_argscup);

                           {? exec('array_sum','#array',_added)>0
                           ||
                              {? PX_VAR.NAST_ALG=2 & _argscup.LANE>-1
                              || _paczka.LANE:=_argscup.LANE;
                                 _paczka.put()
                              ?};
::                            Jesli cos zaplanowalem to ustawiam punkt poczatkowy planu
                              {? _result.START=0
                              || {? _tab=PX_CAL
                                 ||
                                    {? _args.DIR>0
                                    || _result.START:=_argscup.POZSTART
                                    || _result.START:=_argscup.POZEND
                                    ?}
                                 ||
                                    {? _args.DIR>0
                                    || _result.START:=_tab.TM_START
                                    || _result.START:=_tab.TM_END
                                    ?}
                                 ?}
                              ?}
                           || _msg:='Nie udało się nic zaplanować w pojemniku: '+PX_CUP.SYMBOL;
                              pxkomm.error(_msg)
                           ?}
                        ?};
::                      !!! Właściwe planowanie !!!

::                      przeskakuje na nastepny pojemnik zgodnie z kierunkiem
                        {? _ref_nxt<>null()
                        || _can_continue:=_tab.seek(_ref_nxt)
                        || _can_continue:=0
                        ?};
                        {? _can_continue>0 & _tab=PX_CAL
                        ||
::                         Podczytanie PX_CUP
                           _tab.PX_CUP();
                           _last_start:=_argscup.POZSTART;
                           _last_end:=_argscup.POZEND
                        ?};
                        {? _first_cup<>PX_CUP.ref()
                        || _argscup.OPER_START:=0
                        ?};

                        _left:=exec('czyplanowaczka','px_logix',_paczka,_args.DIR);

::                      jesli jest nastepny pojemnik w dziedzinie to sprawdzam czy nie przekroczylem granic planowania
                        {? _can_continue>0 & _left>0
                        || _can_continue:=exec('termin_chk','px_logix',_args.TMGSTART,_args.TMGEND,_args.DIR,_paczka,_tab)
                        ?};
                        _left>0 & _can_continue>0
                     !}
                  || _last_start:=_args.TMGSTART;
                     _last_end:=_args.TMGEND
                  ?};

                  obj_del(_added);

::                jesli cos zostalo to znaczy ze albo przekroczylem termin, albo nie ma juz wiecej pojemnikow
::                w dziedzinie. W tym przypadku odwracam kierunek i znajduje pierwszy kafelek niezablokowany
::                na ktorego zrzuce cala pozostala ilosc - jak to jerry mowi, zrobie na nim fure
                  {? _left>0
                  ||
                     _argscup.OPER_START:=0;
                     _msg:='Planowane są resztki...';
                     pxkomm.error(_msg);
                     _new_dir:=_args.DIR*(-1);
                     {? _new_dir>0
                     || _new_start:=_last_start
                     || _new_start:=_last_end
                     ?};
                     {? exec('first_cup','px_logix',_new_start,_new_dir,,PX_GRP.TM_START,PX_GRP.TM_END,PX_CUP)>0
                     ||
::                      Sprawdzam czy nowo znaleziony pojemnik dla resztek miesci sie w terminie okreslonym dla obiektu
                        _first_chk:=exec('termin_chk','px_logix',_args.TMGSTART,_args.TMGEND,_new_dir,_paczka,_tab);

                        {? _first_chk>0
                        ||
                           _argscup.BRUTAL:=1;
                           {? var_pres('_added')>0
                           || obj_del(_added)
                           ?};
                           _added:=exec('plan_add_cup','px_logix',_argscup);

                           {? exec('array_sum','#array',_added)=0
                           || _msg:='Nie udało się zaplanować resztek';
                              pxkomm.error(_msg);
::                            Raportuje problem na PX_GRP - niepelny plan
                              PX_GRP.PROBLEMS:=exec('problem_half','px_grp');
                              PX_GRP.put();

::                            Dodawanie komunikatu o problemie
                              {? var_pres('_komm_args')>100
                              || obj_del(_komm_args)
                              ?};
                              _komm_args:=exec('add_komm_a','px_komm');
                              _komm_args.PX_VER:=_args.PX_VER;
                              _komm_args.PX_GRP:=PX_GRP.ref();
                              _komm_args.TYP:=exec('type_error','px_komm');
                              _komm_args.PX_CUP:=PX_CUP.ref();
                              _komm_args.SRC_KIND:=exec('src_plan_half','px_komm');
                              _msg:='Niepełny plan grupy: %1'[PX_GRP.SYMBOL];
                              _msg+=' (nie udało się zaplanować na pojemniku: %1 pozostałych pojemności - być może przekroczono max. dla operacji w przepisie planistycznym)'[PX_CUP.SYMBOL];
                              _komm_args.MESSAGE:=_msg;
                              exec('add_komm','px_komm',_komm_args)
                           ||
::                            Jesli cos zaplanowalem to ustawiam punkt poczatkowy planu
                              {? _result.START=0
                              || {? _args.DIR>0
                                 || _result.START:=_tab.TM_START
                                 || _result.START:=_tab.TM_END
                                 ?}
                              ?};
::                            Raportuje problem na PX_GRP - przepełnienie
                              {? _args.DIR>0
                              || PX_GRP.PROBLEMS:=exec('problem_termR','px_grp');
                                 PX_GRP.put();

::                               Dodawanie komunikatu o problemie
                                 {? var_pres('_komm_args')>100
                                 || obj_del(_komm_args)
                                 ?};
                                 _komm_args:=exec('add_komm_a','px_komm');
                                 _komm_args.PX_VER:=_args.PX_VER;
                                 _komm_args.PX_GRP:=PX_GRP.ref();
                                 _komm_args.TYP:=exec('type_error','px_komm');
                                 _komm_args.PX_CUP:=PX_CUP.ref();
                                 _komm_args.SRC_KIND:=exec('src_plan_termR','px_komm');
                                 _msg:='Przekroczenie mocy podczas planowania grupy: %1'[PX_GRP.SYMBOL];
                                 _msg+=' (pojemnik, na którym przekroczono moce: %1. Zasób: %2)'[PX_CUP.SYMBOL,PX_KONT.SYMBOL];
                                 _komm_args.MESSAGE:=_msg;
                                 exec('add_komm','px_komm',_komm_args)

                              || PX_GRP.PROBLEMS:=exec('problem_termL','px_grp');
                                 PX_GRP.put();

::                               Dodawanie komunikatu o problemie
                                 {? var_pres('_komm_args')>100
                                 || obj_del(_komm_args)
                                 ?};
                                 _komm_args:=exec('add_komm_a','px_komm');
                                 _komm_args.PX_VER:=_args.PX_VER;
                                 _komm_args.PX_GRP:=PX_GRP.ref();
                                 _komm_args.TYP:=exec('type_error','px_komm');
                                 _komm_args.PX_CUP:=PX_CUP.ref();
                                 _komm_args.SRC_KIND:=exec('src_plan_termL','px_komm');
                                 _msg:='Przekroczenie mocy podczas planowania grupy: %1'[PX_GRP.SYMBOL];
                                 _msg+=' (pojemnik, na którym przekroczono moce: %1. Zasób: %2)'[PX_CUP.SYMBOL,PX_KONT.SYMBOL];
                                 _komm_args.MESSAGE:=_msg;
                                 exec('add_komm','px_komm',_komm_args)
                              ?}
                           ?};
::                         Jesli nastapilo przekroczenie, jako wynik zwracam poczatek pojemnika w ktorym nastapilo
::                         przekroczenie, po to by kolejne planowane etapy zaczynaly tez od tego pojemnika, a nie
::                         przekraczaly jeszcze bardziej ustawiona granice
                           {? _args.DIR>0
                           || _last_start:=_tab.TM_START;
                              _last_end:=_tab.TM_START
                           ||
                              _last_start:=_tab.TM_END;
                              _last_end:=_tab.TM_END
                           ?}
                        ||
::                         Dodawanie komunikatu o problemie
                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=_args.PX_VER;
                           _komm_args.PX_GRP:=PX_GRP.ref();
                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.PX_CUP:=PX_CUP.ref();
                           _komm_args.SRC_KIND:=exec('src_plan_half','px_komm');
                           _msg:='Niepełny plan grupy: %1'[PX_GRP.SYMBOL];
                           _msg+=' (nie udało się zaplanować na pojemniku: %1 pozostałych pojemności - przekroczono granice czasowe elementu kolejki)'[PX_CUP.SYMBOL];
                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args)
                        ?}
                     || _msg:='Nie znaleziono pojemnika dla resztek (czas: '+(19+tm_form(_last_start))+')';
                        pxkomm.error(_msg);
                        _last_start:=0;
                        _last_end:=0;

                        _msg:='Nie znaleziono pojemnika, od którego miał się zacząć plan pozostałych pojemności.'
                              ' (być może termin realizacji obiektu w przeszłości).';
                              ' Zasób: %1. '[PX_KONT.SYMBOL];
                        {? _new_dir>0
                        || _msg+='Zwrot: W przód';
                           _msg+='Szukany start pojemnika: %1'[(19+tm_form(_new_start))]
                        || _msg+='Zwrot: W tył';
                           _msg+='Szukany koniec pojemnika: %1'[(19+tm_form(_new_start))]
                        ?};

::                      Dodawanie komunikatu o problemie do tabeli komunikatow
                        {? var_pres('_komm_args')>100
                        || obj_del(_komm_args)
                        ?};
                        _komm_args:=exec('add_komm_a','px_komm');
                        _komm_args.PX_VER:=_args.PX_VER;
                        _komm_args.PX_GRP:=PX_GRP.ref();
                        _komm_args.TYP:=exec('type_error','px_komm');
                        _komm_args.SRC_KIND:=exec('src_plan_nocup','px_komm');
                        _komm_args.MESSAGE:=_msg;
                        exec('add_komm','px_komm',_komm_args);

                        pxkomm.error(_komm_args.MESSAGE);

::                      Ustawiam problem na PX_GRP ze nie wszystko zaplanowane
                        PX_GRP.PROBLEMS:=exec('problem_half','px_grp');
                        PX_GRP.put()

                     ?}
                  ?};
::                USTAWIAM WYNIK - punkt czasu w ktorym sie skonczylo planowanie
                  {? _args.DIR>0
                  || _result.END:=_last_end
                  || _result.END:=_last_start
                  ?};

                  _paczka.LSTSTART:=_last_start;
                  _paczka.LSTEND:=_last_end;
::                rekordowi paczki ustawiam ref kontenera rzeczywistego na ktorym zostalo zaplanowane
                  _paczka.KONTREAL:=$PX_KONT.ref();
                  _paczka.put()

               || _msg:='Nie znaleziono pojemnika, od którego miał się zacząć plan.'
                        ' (być może termin realizacji obiektu w przeszłości).';
                        ' Zasób: %1. '[PX_KONT.SYMBOL];
                  {? _args.DIR>0
                  || _msg+='Zwrot: W przód';
                     _msg+='Szukany start pojemnika: %1'[(19+tm_form(_tm_start))]
                  || _msg+='Zwrot: W tył';
                     _msg+='Szukany koniec pojemnika: %1'[(19+tm_form(_tm_start))]
                  ?};

::                Dodawanie komunikatu o problemie do tabeli komunikatow
                  {? var_pres('_komm_args')>100
                  || obj_del(_komm_args)
                  ?};
                  _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=_args.PX_VER;
                  _komm_args.PX_GRP:=PX_GRP.ref();
                  _komm_args.TYP:=exec('type_error','px_komm');
                  _komm_args.SRC_KIND:=exec('src_plan_nocup','px_komm');
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args);

                  pxkomm.error(_komm_args.MESSAGE);

::                Ustawiam problem na PX_GRP ze nie wszystko zaplanowane
                  PX_GRP.PROBLEMS:=exec('problem_half','px_grp');
                  PX_GRP.put()
               ?}
            ||
               _msg:='Operacja paczki po korektach nie zawierała żadnych ilości do zaplanowania: '+_paczka.SYMBOL;
               pxkomm.error(_msg);

               _has_pozy:=0;
               PX_POZ.cntx_psh();
               PX_POZ.index('BLK2');
               PX_POZ.prefix(PX_GRP.ref(),PX_KONT.ref(),PX_STAGE.ref());
               PX_POZ.prefix(PX_GRP.ref(),PX_KONT.ref(),PX_STAGE.ref());
               {? PX_POZ.first()
               || _has_pozy:=1;
                  _result.START:=PX_POZ.TM_START;
                  {? PX_POZ.last()
                  || _result.END:=PX_POZ.TM_END
                  ?}
               ?};
               PX_POZ.index('STATUS2');
               PX_POZ.prefix(PX_GRP.ref(),PX_KONT.ref(),PX_STAGE.ref(),exec('status_wyk1','px_poz'));
               {? PX_POZ.first()
               || _has_pozy:=1;
                  {? _result.START=0 | PX_POZ.TM_START<_result.START
                  || _result.START:=PX_POZ.TM_START
                  ?};
                  {? PX_POZ.last()
                  || {? _result.END=0 | PX_POZ.TM_END>_result.END
                     || _result.END:=PX_POZ.TM_END
                     ?}
                  ?}
               ?};
               PX_POZ.cntx_pop();
               {? _has_pozy=0
               || _result.START:=_args.TM_START;
                  _result.END:=_args.TM_START
               ?};
               _paczka.EMPTY:='T';
               _paczka.put()
            ?}
         || _msg:='Nie znaleziono aktywnego zasobu rzeczywistego: '+PX_KONT.SYMBOL+' '+PX_KONT.NAZWA;

::          Dodawanie komunikatu o problemie do tabeli komunikatow
            {? var_pres('_komm_args')>100
            || obj_del(_komm_args)
            ?};
            _komm_args:=exec('add_komm_a','px_komm');
            _komm_args.PX_VER:=_args.PX_VER;
            _komm_args.PX_GRP:=PX_GRP.ref();
            _komm_args.TYP:=exec('type_error','px_komm');
            _komm_args.SRC_KIND:=exec('src_plan_nozas','px_komm');
            _komm_args.MESSAGE:=_msg;
            exec('add_komm','px_komm',_komm_args);

            pxkomm.error(_komm_args.MESSAGE)
         ?}
      || _msg:='Nie znaleziono zasobu technologicznego: '+_paczka.REF_KONT;
         pxkomm.error(_msg)
      ?}
   || _msg:='Nie znaleziono etapu w przepisie: '+_paczka.PX_STAGE;
      pxkomm.error(_msg)
   ?}
|| _msg:='Nie znaleziono obiektu grupujacego: '+$_args.PX_GRP;
   pxkomm.error(_msg)
?};
:: Paczce ustawiam daty poczatku i konca planu
_paczka.PL_START:=exec('min','#math',_result.START,_result.END);
_paczka.PL_END:=exec('max','#math',_result.START,_result.END);
_paczka.put();

{? PX_VAR.PD>0
||
:: Sprawdzam czy na podany początek operacji mam surowce wg planu dostaw
   _pd_result:=exec('plan','px_pd',_args.PD_OBJ,_args.PXPACK);
   {? type_of(_pd_result)>0
   ||
      _start_oper:=exec('tm_stamp2date','#tm_stamp',_paczka.PL_START);
      {? _pd_result.STATUS=0
      ||
::       Nie ma i nie będzie
         _msg:='Brak surowca potrzebnego do wykonania operacji: %1 na termin: %2'@[_paczka.NAZWA,exec('to_string','#tm_stamp',_paczka.PL_START)];
         {? var_pres('_komm_args')>100
         || obj_del(_komm_args)
         ?};
         _komm_args:=exec('add_komm_a','px_komm');
         _komm_args.PX_VER:=_args.PX_VER;
         _komm_args.PX_GRP:=PX_GRP.ref();
         _komm_args.TYP:=exec('type_error','px_komm');
         _komm_args.SRC_KIND:=exec('src_plan_nosur','px_komm');
         _komm_args.MESSAGE:=_msg;
         exec('add_komm','px_komm',_komm_args)
      |? _pd_result.STATUS>0 & _pd_result.DATA<>date(0,0,0) & _pd_result.DATA<>_start_oper
      ||
::       Mogą być na podany przez plan dostaw termin
         _result.REPLAN:=1;
         _paczka.TM_MIN:=exec('create','#tm_stamp',_pd_result.DATA,time(0,0,0));
         _paczka.REASON:=exec('reason_sur','px_param');
         _paczka.put();
         _args.PXPACK.HASPOINT:=1;
         ~~
      ?}
   ?};
   ~~
?};

pxkomm.sect_end();
PX_GRP.cntx_pop();
PX_GRP.get();
PX_KONT.cntx_pop();
PX_STAGE.cntx_pop();
_result


\plan_add_cup_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Tablica parametrow dla plan_on_cup
::   WE: --
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PACZKA',
               'PXPACK',
               'PX_GRP',
               'BRUTAL',
               'CAPS',
               'PROP',
               'PX_STAGE',
               'DIR',
               'PL_OPER',
               'PL_OGR',
               'REM_PLAN',
               'PX_OBJ',
               'SKIP_PLO',
               'BLK',
               'TM_END',
::             Czy podczas dodawania pozycji na pojemnik wykonywac renumeracje pozycji?
               'RENUMERATE',
::             Status pozycji planu jaki jej ustawic od razu po utworzeniu
               'STATUS',
::             wynik działania - start i koniec pozycji planu która została utworzona (tm_stamp)
               'POZSTART',
               'POZEND',
::             czas startu operacji, wypełniony tylko dla pierwszego pojemnika
               'OPER_START',
::             Poziom kalendarza na którym została zaplanowana operacja
               'LANE',
::             Powód umieszczenia w czasie
               'REASON'
               );
_args.PACZKA:=~~;
_args.PXPACK:=~~;
_args.PX_GRP:=null();
_args.BRUTAL:=0;
_args.PROP:=0;
:: tablica z pojemnosciami w kolejnych wymiarach
_args.CAPS:=~~;
_args.PX_STAGE:=null();
_args.DIR:=1;
_args.PL_OPER:=null();
_args.PL_OGR:=null();
_args.PX_OBJ:=null();
_args.REM_PLAN:=null();

:: specjalny przelacznik dla planowania na podstawie PL_OPEROW
:: 1 - oznacza ze jesli w pojemninku jest juz PL_OPER to nie dodaje pozycji planu ani nie scalam
:: 2 - oznacza ze jesli w pojemniku jest juz PL_OPER to scalam z ta pozycja
_args.SKIP_PLO:=1;

:: czy po utworzeniu pozycji planu zablokowac ja od razu
_args.BLK:='N';

:: granica czasowa dla elementu kolejki
_args.TM_END:=0;

_args.RENUMERATE:=1;
_args.STATUS:='';
_args.POZSTART:=0;
_args.POZEND:=0;
_args.OPER_START:=0;
_args.LANE:=-1;
_args.REASON:='';
:: zwracamy deklaracje
_args


\plan_add_cup
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Dodaje do pojemnika pozycje planu
::       Kontekst pracy - PX_CUP, rekord paczki
::   WE: _a - _args - moje argumenty
::   WY: DICT - tablica - ile pojemnosci zostalo dodane w poszczegolnych wymiarach
::----------------------------------------------------------------------------------------------------------------------
_args:=~~;
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('plan_add_cup_a','px_logix')
?};

_il_wym:=PX_CUP.PX_KONT().IL_WYM;
_prec:=exec('precision_array','px_kont',PX_CUP.PX_KONT);

:: inicjalizacja wyniku
_result:=obj_new(_il_wym);
{! _it:=1.._il_wym
|! _result[_it]:=0
!};

_can_continue:=1;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};
_msg:='plan_add_cup\px_logix - Planowanie na pojemniku: '+PX_CUP.SYMBOL;
pxkomm.sect_beg(_msg);

_paczka:=_args.PACZKA;

_planuj:=exec('cup_ready','px_logix',_paczka);
{? _planuj=0
|| _msg:='Pojemnik nie gotowy: '+PX_CUP.SYMBOL;
   pxkomm.info(_msg)
?};

{? _planuj>0 | _args.BRUTAL>0
||
   _tab:=~~;
   {? PX_VAR.NAST_ALG=2
   || _tab:=PX_CAL
   || _tab:=PX_CUP
   ?};
   _argspoz:=exec('blank_a','px_poz');
   {? type_of(_paczka)>100
   || _argspoz.REASON:=_paczka.REASON
   || {? _args.REASON<>''
      || _argspoz.REASON:=_args.REASON
      ?}
   ?};

:: biegne po wymiarach i znajduje najmniejsza proporcje ktora pozwoli okreslic ile moge maksymalnie
:: wlac do pojemnika we wszystkich wymiarach wzgledem tego co bylo wymagane
   _proporcja:=1;
   _planuj:=0;
   _max_pck:=obj_new(_il_wym);
   _max_kor:=obj_new(_il_wym);
   _alg_nast:=obj_new(_il_wym);
   _cal_lvl:=obj_new(_il_wym);
   {! _it:=1.._il_wym
   |! {? type_of(_paczka)>100
      || _max_pck[_it]:=($('_paczka:=_a;_paczka.CAP_MAX'+$_it))(_paczka)
      || _max_pck[_it]:=0
      ?};
      _max_kor[_it]:=0;
      _alg_nast[_it]:=-1;
      _cal_lvl[_it]:=-1;
      ~~
   !};

:: Wyznaczanie czasów rozpoczęcia i zakończenia dla pozycji planu
   _argspoz.STARTD:=PX_CUP.STARTD;
   _argspoz.ENDD:=PX_CUP.ENDD;

   {? _args.PL_OPER<>null()
   || PL_OPER.cntx_psh(); PL_OPER.prefix();
      {? PL_OPER.seek(_args.PL_OPER)
      ||
         {? _args.DIR>0
         || _args.OPER_START:=PL_OPER.TM_START
         || _args.OPER_START:=PL_OPER.TM_END
         ?};
         _argspoz.TM_END:=PL_OPER.TM_END
      ?};
      PL_OPER.cntx_pop()
   ?};
   {? _args.PL_OGR<>null()
   || PL_OGR.cntx_psh(); PL_OGR.prefix();
      {? PL_OGR.seek(_args.PL_OGR)
      || {? _args.DIR>0
         || _args.OPER_START:=PL_OGR.TM_START
         || _args.OPER_START:=PL_OGR.TM_END
         ?};
         _argspoz.TM_END:=PL_OGR.TM_END
      ?};
      PL_OGR.cntx_pop()
   ?};
   {? _args.REM_PLAN<>null()
   || REM_ZGL.cntx_psh();
      REM_PLAN.cntx_psh(); REM_PLAN.prefix();
      {? REM_PLAN.seek(_args.REM_PLAN)
      ||
         REM_PLAN.REM_ZGL();

         _tm1:=exec('create','#tm_stamp',REM_ZGL.DT_PST,REM_ZGL.TM_PST);
         _tm2:=exec('create','#tm_stamp',REM_ZGL.DT_PUA,REM_ZGL.TM_PUA);

         _cup_dur:=PX_CUP.TM_END-PX_CUP.TM_START;
         _poz_dur:=_cup_dur*_args.PROP;

         _int_cup:=exec('interval','#interval');
         _int_cup.START:=PX_CUP.TM_START;
         _int_cup.END:=PX_CUP.TM_END;

         _int_chk:=exec('interval','#interval');
         _int_chk.START:=_tm2;
         _int_chk.END:=_tm2;

         {? exec('intervals_chk','#interval',_int_cup,_int_chk)=2
         ||
::          Jeżeli jestem w ostatnim pojemniku kończącym remont to planuję pozycję od
::          końca terminu usunięcia awarii, żeby godziny się zgadzały
            _args.DIR:=-1;
            _args.OPER_START:=_tm2;
            _tm_start:=_tm2-_poz_dur;

            _argspoz.TM_START:=exec('max','#math',_tm_start,PX_CUP.TM_START)
         ||
            _args.OPER_START:=_tm1;
            _tm_end:=exec('max','#math',PX_CUP.TM_START,_args.OPER_START)+_poz_dur;
            _argspoz.TM_END:=exec('min','#math',_tm_end,_tm2)
         ?}
      ?};
      REM_ZGL.cntx_pop();
      REM_PLAN.cntx_pop()
   ?};

   _argspoz.LANE:=1;
   _coop_with_times:=0;
   {? PX_VAR.NAST_ALG=2 & type_of(_paczka)>100 & _paczka.COOP>0 & _paczka.TM_START>0 & _paczka.TM_END>0
   || _coop_with_times:=1;
::    Obsługa kooperacji z podanymi granicami kooperacji
      {? _args.DIR>0
      || _args.OPER_START:=_paczka.TM_START
      || _args.OPER_START:=_paczka.TM_END
      ?};
      _argspoz.TM_END:=_paczka.TM_END
   ?};

   {? (PX_VAR.NAST_ALG=2 | PX_VAR.NAST_ALG=3) & _args.BRUTAL=0
   ||
::    Algorytm nakładkowania metodą proporcji czasowej wyznaczam począki i końce operacji

      {? _args.PL_OPER<>null() | _args.PL_OGR<>null() | _args.REM_PLAN<>null()
      ||
::       jeżeli PX_POZ na podstawie planu operacyjnego to do wyznaczenia granic czaowych
::       używam zawsze pojemnika, bo plan operacyjny ignoruje kalendarze na pojemniki
         {? var_pres('_tab')>100
         || obj_del(_tab)
         ?};
         _tab:=PX_CUP
      ?};

      {? _args.DIR>0
      || {? _args.OPER_START>0
         || _argspoz.TM_START:=exec('max','#math',_args.OPER_START,_tab.TM_START)
         || _argspoz.TM_START:=_tab.TM_START
         ?};
         {? _argspoz.TM_END>0
         || _argspoz.TM_END:=exec('min','#math',_argspoz.TM_END,_tab.TM_END)
         || _argspoz.TM_END:=_tab.TM_END
         ?}
      ||
         {? _args.OPER_START>0
         || _argspoz.TM_END:=exec('min','#math',_args.OPER_START,_tab.TM_END)
         || _argspoz.TM_END:=_tab.TM_END
         ?};
         {? _argspoz.TM_START>0
         || _argspoz.TM_START:=exec('max','#math',_argspoz.TM_START,_tab.TM_START)
         || _argspoz.TM_START:=_tab.TM_START
         ?}
      ?};

      {? _args.PL_OPER<>null() | _args.PL_OGR<>null() | _args.REM_PLAN<>null()
      ||
::       Przywracam nadpisaną tabelę
         {? var_pres('_tab')>100
         || obj_del(_tab)
         ?};
         {? PX_VAR.NAST_ALG=2
         || _tab:=PX_CAL
         || _tab:=PX_CUP
         ?}
      ?};
      {? PX_VAR.NAST_ALG=2
      || _argspoz.LANE:=PX_CAL.LEVEL;
         _args.LANE:=PX_CAL.LEVEL
      ?}
   || _argspoz.TM_START:=PX_CUP.TM_START;
      _argspoz.TM_END:=PX_CUP.TM_END
   ?};

   {? _coop_with_times>0
   || _dur_poz:=_argspoz.TM_END-_argspoz.TM_START;
      _max_kor[1]:=(_dur_poz/exec('hour','#tm_stamp'))$PX_KONT.PREC1
   ?};

:: Jesli proporcja jest podana w argumentach wejsciowych to nie wyliczam jej tylko uzywam
   {? _args.PROP<>0
   || _proporcja:=_args.PROP;
      _planuj:=1
   ||
::    Koryguje maksymalne zuzycie okreslone w przepisie - chocby nie wiem co nie moge wrzucic do pojemnika
::    pozycji planu ktora spowoduje przekroczenie zuzycia maksymalnego podanego w przepisie
::    dlatego podane maksimum koryguje, uwzgledniajac pozycje planu ktore juz sa w pojemniku
      {? _coop_with_times=0 & exec('array_sum','#array',_max_pck)>0
      || obj_del(_max_kor);
         _max_kor:=exec('cap_max_correct','px_poz',_args.PX_GRP,_args.PX_STAGE,_max_pck)
      ?};

      {? PX_VAR.NAST_ALG=1 & _args.OPER_START>0 & _paczka.TM_MIN=0 & _paczka.TM_MAX=0
      ||
::       Następstwo operacji - proporcja ilościowa. Tylko dla pierwszej pozycji planu
::       i tylko jeżeli nie ma punktu czasowego
         {? exec('cup_structure_chk','px_logix',_args.PXPACK,_args.DIR)>0
         ||
::          Jeśli ostatnia operacja skończyła się na pojemniku zgodnym pod względem
::          czasu z pierwszym pojemnikiem kolejnej operacji to robię proporcję ilościową
            _last_coef:=exec('last_coef_use','px_logix',_args.PXPACK,_args.DIR);

            {! _it:=1.._il_wym
            |! _alg_nast[_it]:=_last_coef[_it]
            !}
         ||
::          Tu powinno wejść tylko w przypadku gdy struktura pojemników na zasobach się różni
::          zwracam proporcję ilościową 0, co spowoduje że ten pojemnik zostanie pominięty i plan
::          przeskoczy dalej, czyli nie wykona nakładkowania z proporcją ilościową
            _can_continue:=0;
            {! _it:=1.._il_wym
            |! _alg_nast[_it]:=0
            !}
         ?}
      ?};
      {? PX_VAR.NAST_ALG=2 & PX_CUP.CAL_LVL>1
      || {! _it:=1.._il_wym
         |! _cal_lvl[_it]:=1/PX_CUP.CAL_LVL
         !}
      ?};
      _infinity:=exec('infinity_array','px_kont',PX_CUP.PX_KONT);
::    Wyliczanie proporcji ktora wyznaczy ilosci dla pozycji planu we wszystkich wymiarach
      {! _it:=1.._il_wym
      |? _can_continue>0
      |!
         {? type_of(_paczka)>100
         || _il_left:=($('_paczka:=_a;_paczka.CAP_DIM'+$_it+'-_paczka.DID_DIM'+$_it))(_paczka)
         || _il_left:=0
         ?};
         _cup_left:=($('PX_CUP.CAP_MAX'+$_it+'-PX_CUP.CAP_USE'+$_it))();

         _max:=_max_kor[_it];

         {? _alg_nast[_it]>-1 & _max>-1
         || {? _max>0
            || _max:=exec('min','#math',_max,_alg_nast[_it])
            || _max:=_alg_nast[_it]
            ?};
            {? _max=0
            ||
::             Jeżeli tutaj _max jest zerem to znaczy że z nakładkowania wynikło
::             że już w tym pojemniku nie można nic zaplanować i trzeba iść dalej
::             Zadziała to tak jeżeli ustawimy tą zmienną na -1
               _max:=-1
            ?}
         ?};
         _wym_endless:=_infinity[_it];
         {? _cal_lvl[_it]>-1 & _max>-1 & _wym_endless=0
         || _cup_max:=($('PX_CUP.CAP_MAX'+$_it))();
            _lvl_max:=(_cup_max*_cal_lvl[_it]);
            {? _max>0
            || _max:=exec('min','#math',_max,_lvl_max)
            || _max:=_lvl_max
            ?}
         ?};

::       Jesli z korekty maksimow wynika ze jakies maksimum jest mniejsze od zera
::       oznacza to ze przekroczono maksimum technologiczne na pojemniku, co z kolei oznacza
::       ze nie mozna zaplanowac tego etapu na ten pojemnik, wiec musze przerwac planowanie
         {? _max<0
         || _can_continue:=0;
            _planuj:=0
         ?};

         {? _il_left>0 & _can_continue>0
         ||
            _planuj:=1;
            _rule:=$('
                        _il_left:=_a;
                        _cup_left:=_b;
                        _max:=_c;
                        _wym_endless:=_d;
                        _result:=1;

                        {? PX_CUP.PX_KONT().ENDLESS=0 & _wym_endless=0
                        ||
                           {? _cup_left>0
                           || {? _max<>0 & _cup_left>_max
                              || _cup_left:=_max
                              ?};
                              {? _il_left>_cup_left
                              || _result:=_cup_left/_il_left
                              ?}
                           || _result:=0
                           ?}
                        || {? _max<>0
                           || {? _il_left>_max
                              || _result:=_max/_il_left
                              ?}
                           ?}
                        ?};
                        _result
                     ');

::          formula oblicza proporcje wyznaczajaca ilosc w pojemniku w danym wymiarze
            _pr:=_rule(_il_left,_cup_left,_max,_infinity[_it]);
            {? _pr>=0 & _pr<_proporcja
            || _proporcja:=_pr
            ?}
         ?}
      !}
   ?};

:: jeśli planowanie brutalne, to nieważna wyliczona proporcja - i tak wrzucam całość
   {? _args.BRUTAL>0
   || _proporcja:=1;
      _planuj:=1;
       _msg:='Brutalizacja planu na pojemniku: '+PX_CUP.SYMBOL+' na kontenerze: '+PX_CUP.PX_KONT().SYMBOL;
      pxkomm.info(_msg)
   ?};

   _msg:='Proporcja dla pozycji planu we wszystkich wymiarach: '+$_proporcja;
   pxkomm.info(_msg);

   {? _proporcja>0 & _planuj>0
   ||

::    przypisuje argumenty dla funkcji tworzacej pozycje planu
      _argspoz.PX_VER:=PX_CUP.PX_VER;
      _argspoz.PX_GRP:=_args.PX_GRP;

::    przypisuje pozycji planu PX_OBJ tylko jesli w paczce byl okreslony PX_OBJ
::    paczka mogla zostac przygotowana w taki sposob aby powstalych pozycji planu z rekordu paczki
::    nie musiec szatkowac (przypadek planowania opoznien)
::    jesli paczka nie ma podanego PX_OBJ to po zaplanowaniu pozycjom planu PX_OBJ zostanie
::    przypisany przez szatkownice (patrz exec('poz_conn_obj','px_logix'))
      _pxobj:=null();
      {? type_of(_paczka)>100 & _paczka.PX_OBJ<>''
      || PX_OBJ.cntx_psh();
         PX_OBJ.clear();
         {? PX_OBJ.seek(_paczka.PX_OBJ,8+_paczka.PX_OBJ)
         || _pxobj:=PX_OBJ.ref()
         ?};
         PX_OBJ.cntx_pop()
      ?};
      _argspoz.PX_OBJ:=_pxobj;
      _argspoz.PX_CUP:=PX_CUP.ref();
      _argspoz.PX_KONT:=PX_CUP.PX_KONT;
      _argspoz.PX_SET:=PX_CUP.PX_KONT().PX_SET;
      _argspoz.PX_STAGE:=_args.PX_STAGE;
      _argspoz.DIR:=_args.DIR;
      _argspoz.PL_OPER:=_args.PL_OPER;
      _argspoz.PL_OGR:=_args.PL_OGR;
      _argspoz.PX_OBJ:=_args.PX_OBJ;
      _argspoz.BLK:=_args.BLK;
      {? _args.STATUS<>''
      || _can_stat:=1;
         {? _args.STATUS=exec('status_delay','px_poz') & _args.BLK='T'
         || _can_stat:=0
         ?};
         {? _can_stat>0
         || _argspoz.STATUS:=_args.STATUS
         ?}
      ?};

::    Obsluga kooperacji - pozycjom planu zaznaczam ze powstaly na podstawie kooperacji
      {? type_of(_paczka)>100
      || {? _paczka.WEW='N'
         || _argspoz.KOOP:='T'
         ?}
      ?};

      {? _args.PL_OPER<>null() | _args.PL_OGR<>null()
      || _argspoz.SRC_OPER:='T'
      ?};

::    przypisuje ilosci w kolejnych wymiarach - ZAOKRAGLONE DO DOKLADNOSCI KONTENERA
      {! _it:=1.._il_wym
      |! _rule:=$('
                     _argspoz:=_a;
                     _paczka:=_b;
                     _proporcja:=_c;
                     _precision:=_d;
                     _caps:=_e;

                     {? type_of(_caps)>100
                     ||
::                      Jesli zuzycia podane to ich nie wyliczam tylko przepisuje
                        _argspoz.CAP_EAT'+$_it+':=_caps['+$_it+']$_precision
                     ||
::                      Wyliczam pojemnosci
                        {? type_of(_paczka)>100
                        || _il_left:=_paczka.CAP_DIM'+$_it+'-_paczka.DID_DIM'+$_it+';
                           _argspoz.CAP_EAT'+$_it+':=_il_left*_proporcja$_precision
                        ?}
                     ?};

                     {? type_of(_paczka)>100
                     || _argspoz.CAP_MIN'+$_it+':=_paczka.CAP_MIN'+$_it+'$_precision;
                        _argspoz.CAP_MAX'+$_it+':=_paczka.CAP_MAX'+$_it+'$_precision
                     ?};
                     ~~
                  ');
         _rule(_argspoz,_paczka,_proporcja,_prec[_it],_args.CAPS)
      !};

      _cal_eat:=0;
      _cal_correct:=0;
      {? PX_VAR.NAST_ALG=2 & _args.PL_OPER=null() & _args.PL_OGR=null() & _args.REM_PLAN=null() & _args.BRUTAL=0
      || _pr_time:=1;

::       Algorytm nakładkowania metodą proporcji czasowej
         _dur_poz:=0;
         {? type_of(_paczka)>100 & _paczka.COOP>0 & _paczka.TM_START>0 & _paczka.TM_END>0
         ||
::          Obsługa kooperacji z podanymi granicami kooperacji
            _dur_poz:=_argspoz.TM_END-_argspoz.TM_START
         ||
            _time_value:=0;
            _time_wym:=0;
            {! _it:=1.._il_wym
            |! _jm:=($('PX_KONT.JM'+$_it+'().KOD'))();
               {? _jm=PX_VAR.P500380 | _jm=PX_VAR.P500381
               || _time_wym:=($('_argspoz:=_a;_argspoz.CAP_EAT'+$_it))(_argspoz);
                  {? _time_value=0 | (_time_value<_time_wym)
                  ||
::                   Wyznaczam maksymalny czas trwania
                     _time_value:=_time_wym
                  ?}
               ?}
            !};

::          Obliczam czas trwania pozycji
            _dur_poz:=(_time_value*exec('hour','#tm_stamp'))
         ?};
         _cal_fit:=0;

         {? _args.DIR>0
         ||
::          Planowanie do przodu
            _tm_end:=_argspoz.TM_START+_dur_poz;

            {? _tm_end<_tab.TM_END
            ||
::             Mieszczę się w kalendarzu
               _argspoz.TM_END:=_tm_end

            |? _tm_end>_tab.TM_END
            || _argspoz.TM_END:=_tab.TM_END;
               _cal_fit:=1
            ?}
         ||
::          Planowanie do tyłu
            _tm_start:=_argspoz.TM_END-_dur_poz;

            {? _tm_start>_tab.TM_START
            ||
::              Mieszczę się w kalendarzu
               _argspoz.TM_START:=_tm_start

            |? _tm_start<_tab.TM_START
            || _argspoz.TM_START:=_tab.TM_START;
               _cal_fit:=1
            ?}
         ?};
         {? _cal_fit>0
         ||
::          Przekroczyłem dostępny kalendarz, więc robię dopasowanie do czasu kalendarza
            _dur_poz_new:=_argspoz.TM_END-_argspoz.TM_START;
            _prop_corr:=_dur_poz_new/_dur_poz;
            {! _it:=1.._il_wym
            |! _rule:=$('
                           _argspoz:=_a;
                           _proporcja:=_b;
                           _precision:=_c;
                           _argspoz.CAP_EAT'+$_it+':=_argspoz.CAP_EAT'+$_it+'*_proporcja$_precision;
                           ~~
                        ');
               _rule(_argspoz,_prop_corr,_prec[_it])
            !}
         ?};

         {? _argspoz.TM_START<=PX_CAL.TM_START & _argspoz.TM_END>=PX_CAL.TM_END
         ||
::          Pozycja planu zje cały dostępny kalendarz
            _cal_eat:=1
         ||
::          Pozycja planu nie zje całego dostępnego kalendarza
            _cal_correct:=1
         ?}
      ?};
      _argspoz.DATE_MIN:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_START);
      _argspoz.TIME_MIN:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_START);
      _argspoz.DATE_MAX:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_END);
      _argspoz.TIME_MAX:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_END);

      {? _args.PL_OPER<>null()
      ||
         _rem_plan:=exec('FindAndGet','#table',PL_OPER,_args.PL_OPER,,"REM_PLAN",null());
         {? _rem_plan<>null()
         ||
            REM_PLAN.cntx_psh(); REM_PLAN.prefix();
            REM_ZGL.cntx_psh();
            {? REM_PLAN.seek(_rem_plan)
            ||
               {? REM_PLAN.REM_ZGL().PL_TRYB<>'R'
               ||
::                Planowanie operacyjne remontów. Przed utworzeniem pozycji planu z operacyjnego
::                usuwam z pojemnika pozycje planu strategicznego, żeby się ten sam remont nie
::                zdublował w pojemniku
                  _rem_obj:=exec('get_rem_object','px_obj',REM_PLAN.REM_ZGL);
                  {? _rem_obj<>null()
                  || _args_del:=exec('plan_del_cup_a','px_logix');
                     _args_del.PX_OBJ:=_rem_obj;
                     exec('plan_del_cup','px_logix',_args_del)
                  ?}
               ?}
            ?};
            REM_PLAN.cntx_pop();
            REM_ZGL.cntx_pop()
         ?}
      ?};

      _merge:=0;
      _add:=0;
      _skip:=0;

::    Badam jaka operacje wykonac w biezacym pojemniku. Mozliwe sa nastepujace opcje
::       * _add=1
::             W pojemniku jest tworzona nowa pozycja planu. Jako wynik zwracane sa ilosci
::             utworzonej pozycji planu
::       * _merge=1
::             W pojemniku znajduje sie juz pozycja planu odpowiadajaca kryteriom grupowania
::             wiec ilosci ktore mialy powstac na nowej pozycji planu sa dopisywane do istniejacej
::             Jako wynik zwracane sa ilosci ktore zostaly scalone
::       * _skip=1
::             W pojemniku znajduje sie juz pozycja planu odpowiadajaca kryteriom grupowania
::             ale ilosci nie sa scalane. W praktyce nic nie jest robione, ale jako wynik
::             zwracane sa ilosci ktore mialy powstac na nowej pozycji planu.
::             W praktyce ta sciezka jest uzywana tylko podczas tworzenia planu na podstawie
::             planu operacyjnego. Wykorzystywane jest to po to by nie zwielokratniac ilosci
::             gdy jeden PL_OPER w planie zasobow jest zaplanowany na kilku PL_OZach i te kilka
::             plozow jest powiazane z PL_RESami ktore w planie WPP spotykaja sie na jednym PX_KONT
      {? _args.REM_PLAN<>null & _args.PL_OPER=null()
      || _add:=1;
         _argspoz.BLK:='T';
::       Planowanie remontów - sprawdzam, czy w pojemniku ten remont nie jest już zaplanowany
::       operacyjnie. Jeżeli jest, to nie planuję go strategicznie
         PL_OPER.cntx_psh();
         PL_OPER.index('REM_PLAN');
         PL_OPER.prefix(_args.REM_PLAN);
         {? PL_OPER.first()
         || {!
            |? {? exec('ploper_in_cup','px_logix',_args.PL_OPER)>0
               || _add:=0;
                  _skip:=1
               ?};
               PL_OPER.next()
            !}
         ?};
         PL_OPER.cntx_pop()
      |? _args.PL_OPER<>null()
      || {? exec('ploper_in_cup','px_logix',_args.PL_OPER)>0
         || {? _args.SKIP_PLO=1
            || _skip:=1
            |? _args.SKIP_PLO=2
            || _merge:=1
            ?}
         || _add:=1
         ?}
      |? _args.PL_OGR<>null()
      || {? exec('plogr_in_cup','px_logix',_args.PL_OGR)>0
         || _merge:=1
         || _add:=1
         ?}
      || {? type_of(_paczka)>100
         ||
            {? PX_VAR.NAST_ALG=2 & _args.BRUTAL=0
            ||
::             Algorytm nakładkowania metodą proporcji czasowej
               PX_POZ.index('PX_STAGE');
               PX_POZ.prefix(PX_CUP.ref());
               _add:=1
            ||
               {? exec('pxstage_in_cup','px_logix',_args.PX_GRP,_args.PX_STAGE,_paczka)>0
               || _merge:=1
               || _add:=1
               ?}
            ?}
         || _add:=1
         ?}
      ?};
      {? _add>0
      ||
         _msg:='Tworzenie pozycji planu';
         pxkomm.sect_beg(_msg);
::       !!!TWORZE POZYCJE PLANU!!!
::       zaokraglanie ilosci PX_POZa do prezycji PX_KONTa jest robione przed samym addem rekordu
::       w formulce exec('args2record','px_poz')
         {? exec('add','px_poz',_argspoz)>0
         ||
            _args.POZSTART:=PX_POZ.TM_START;
            _args.POZEND:=PX_POZ.TM_END;
::          Jesli utworzona pozycja planu przekracza dozwolona granice czasowa, to dodaje
::          komunikat dla niej
            {? _args.TM_END>0 & PX_POZ.TM_START>_args.TM_END
            ||
               PX_GRP.cntx_psh();
               PX_OBJ.cntx_psh();
               _argskom:=exec('add_komm_a','px_komm');
               _argskom.TYP:=exec('type_error','px_komm');
               _argskom.SRC_KIND:=exec('src_plan_termR','px_komm');
               _argskom.PX_VER:=PX_POZ.PX_VER;
               _argskom.PX_GRP:=PX_POZ.PX_GRP;
               _argskom.PX_CUP:=PX_CUP.ref();
               _argskom.PX_POZ:=PX_POZ.ref();

               _tm_str:=19+tm_form(_args.TM_END);
               _src:='';
               {? PX_POZ.PX_GRP<>null()
               || _src:=PX_POZ.PX_GRP().SYMBOL
               |? PX_POZ.PX_OBJ<>null()
               || _src:=PX_POZ.PX_OBJ().SYMBOL
               || _src:='<brak źródła>'
               ?};
               _msg:='Pozycja planu dla: '+_src;
               _msg+=' na pojemniku: '+PX_CUP.SYMBOL;
               _msg+=' przekracza dozwoloną w kolejce granicę czasową ('+_tm_str+')';
               _argskom.MESSAGE:=_msg;
               exec('add_komm','px_komm',_argskom);
               PX_GRP.cntx_pop();
               PX_OBJ.cntx_pop()
            ?};

            {! _it:=1.._il_wym
            |!
::             przypisuje wynik
               _rule:=$('_result:=_a;_result['+$_it+']:=PX_POZ.CAP_EAT'+$_it);
               _res:=_rule(_result);
               _msg:='Wynik formuly w wymiarze: '+$_it+'='+$_result[_it];
               pxkomm.info(_msg);

::             aktualizuje rekord w paczce
               {? type_of(_paczka)>100
               ||
                  _rule:=$('_paczka:=_a;_paczka.DID_DIM'+$_it+'+=PX_POZ.CAP_EAT'+$_it);
                  _rule(_paczka)
               ?}
            !};
::          uruchamiam formule po wlaniu
            exec('po_wlaniu','px_logix',PX_CUP.ref(),_argspoz,_args.RENUMERATE);

::          Modyfikacja kalendarzy w pojemniku po utworzeniu pozycji planu
            {? (PX_VAR.NAST_ALG=2 | PX_VAR.NAST_ALG=3) & (_argspoz.PL_OPER<>null() | _argspoz.PL_OGR<>null())
            ||
::             Jeżeli plan na podstawie operacyjnego to zawsze odtwarzam kalendarze w pojemniku
               exec('rebuild4cup','px_cal',,0)
            |? PX_VAR.NAST_ALG=2
            ||
               {? _cal_correct=0 & _cal_eat=0
               ||
::                Jeżeli do tej pory nie było decyzji co zrobić z kalendarzem to ją podejmuję
                  _cal_correct:=1;

                  {? _args.BRUTAL>0
                  || _cal_correct:=0;

                     _new_start:=0;
                     {? _args.DIR>0
                     || _new_start:=_argspoz.TM_START
                     || _new_start:=_argspoz.TM_END
                     ?};

                     {? exec('first_cup','px_logix',_new_start,_args.DIR,,PX_GRP.TM_START,PX_GRP.TM_END,PX_CAL)>0
                     || _cal_eat:=1
                     ?}
                  ?}
               ?};

::             Algorytm nakładkowania metodą proporcji czasowej
               {? PX_CUP.PX_KONT().PARALLEL<>'1'
               ||
                  {? _cal_correct>0
                  ||
::                   Modyfikuję kalendarz
                     _interval_poz:=exec('interval','#interval');
                     _interval_poz.START:=_argspoz.TM_START;
                     _interval_poz.END:=_argspoz.TM_END;

                     exec('split','px_cal',_interval_poz,_argspoz.LANE)
                  ?};
                  {? _cal_eat>0
                  ||
::                   Usuwam rekord kalendarza
                     exec('delete','px_cal',PX_CAL.ref())
                  ?}
               ?}
            ?}

         || _msg:='Utworzenie pozycji planu zakończone niepowodzeniem.';
            pxkomm.error(_msg)
         ?};
         pxkomm.sect_end()
      |? _merge>0
      ||
         _msg:='Scalanie pozycji planu, podczas planowania';
         pxkomm.sect_beg(_msg);
::       !!!SCALANIE POZYCJI PLANU!!!
         _control:=1;
         {? _args.BRUTAL=1
         || _control:=0
         ?};
         _res_m:=exec('merge_core','px_poz',PX_POZ.ref(),_argspoz,_control,_paczka);
         _sum_m:=exec('array_sum','#array',_res_m);
         {? _sum_m>0
         || obj_del(_result);
            {? _args.BLK='T'
            || exec('block','px_poz',PX_POZ.ref())
            ?};
            _result:=_res_m
         || _msg:='Scalenie pozycji planu zakonczone niepowodzeniem';
            pxkomm.error(_msg)
         ?};
         pxkomm.sect_end()
      |? _skip>0
      ||
::       NIE DODAJE ANI NIE SCALAM - OSZUKUJE ZE COS ZROBILEM
         {! _it:=1.._il_wym
         |!
::          przypisuje wynik
            _rule:=$('_result:=_a;_argspoz:=_b;_result['+$_it+']:=_argspoz.CAP_EAT'+$_it);
            _res:=_rule(_result,_argspoz)
         !}
      ?}
   ?}
?};
{? PX_VAR.NAST_ALG=1
|| exec('last_coef_save','px_logix',_result,_paczka)
?};

pxkomm.sect_end();
_result


\plan_del_cup_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Tablica parametrów dla plan_del_cup
::   WE: --
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PX_OBJ',
               'PX_GRP');
:: zwracamy deklaracje parametrow
_args.PX_OBJ:=null();
_args.PX_GRP:=null();
_args


\plan_del_cup
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Usuwa plan z biezacego pojemnika
::   WE: _args
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
_args:=~~;
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('plan_del_cup_a','px_logix')
?};

_can_continue:=1;
_result:=0;

_il_wym:=PX_CUP.PX_KONT().IL_WYM;

PX_POZ.cntx_psh();
PX_POZ.clear();
{? _args.PX_OBJ<>null()
|| PX_POZ.index('PX_OBJ');
   PX_POZ.prefix(PX_CUP.ref(),_args.PX_OBJ)
?};
{? _args.PX_GRP<>null()
|| PX_POZ.index('PX_GRP');
   PX_POZ.prefix(PX_CUP.ref(),_args.PX_GRP)
?};
{? PX_POZ.first()
|| {!
   |? _can_continue:=exec('delete','px_poz',PX_POZ.ref());
      PX_POZ.first() & _can_continue>0
   !}
?};
{? _can_continue>0
|| _result:=1
?};
PX_POZ.cntx_pop();
_result


\px_obj_plan_del
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.10]
:: OPIS: Usuwa plan danego obiektu planowanego z biezaco wyswietlanej wersji
::       Kontekst pracy - PX_OBJ
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
PX_CUP.cntx_psh();
PX_CUP.clear();
PX_POZ.cntx_psh();
PX_POZ.index('PX_POZ');


_argsdel:=exec('plan_del_cup_a','px_logix');
_argsdel.PX_OBJ:=PX_OBJ.ref();

PX_POZ.prefix(PX_VAR.VIE_VER,PX_OBJ.ref());
_can_continue:=1;
{? PX_POZ.first()
|| {!
   |? {? PX_POZ.PX_CUP<>null()
      || PX_POZ.PX_CUP();
         _can_continue:=exec('plan_del_cup','px_logix',_argsdel)
      ?};
      PX_POZ.first() & _can_continue>0
   !}
?};

{? _can_continue>0
|| PX_OBJ.IL_PLAN:=0;
   PX_OBJ.put()
?};

PX_POZ.cntx_pop();
PX_CUP.cntx_pop();
~~


\cup_ready
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Sprawdza czy moge zaplanowac biezacy rekord paczki na kafelku
::       Kontekst pracy - PX_CUP, rekord paczki
::       _a - tab_tmp() - paczka technologiczna
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_paczka:=_a;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

_msg:='cup_ready\px_logix - Sprawdzanie czy pojemnik gotowy na plan: '+PX_CUP.SYMBOL;
pxkomm.sect_beg(_msg);

_result:=0;
{? PX_CUP.STATUS=exec('status_normal','px_cup')
|| _result:=1
|| _msg:='Status pojemnika niezgodny z oczekiwanym: '+PX_CUP.STATUS;
   pxkomm.error(_msg)
?};

:: ------------  Sprawdzam ilości minimalne
{? _result>0 & type_of(_paczka)>100
|| _il_wym:=PX_CUP.PX_KONT().IL_WYM;

:: obliczam zajeta pojemnosc na kafelku
   _cap_eaten:=exec('cap_eaten','px_cup',0);
   _infinity:=exec('infinity_array','px_kont',PX_CUP.PX_KONT);
   {! _it:=1.._il_wym
   |? _result>0
   |! _rule:=$('
                  _result:=1;
                  _wym_endless:=_c;
                  {? PX_CUP.PX_KONT().ENDLESS=0 & _wym_endless=0
                  ||
                     _paczka:=_a;_cap_eaten:=_b;
                     _il_needed:=_paczka.CAP_MIN'+$_it+';
                     _il_left:=PX_CUP.CAP_MAX'+$_it+'-_cap_eaten['+$_it+'];

                     {? _il_needed>0 & _il_needed>_il_left
                     || _result:=0
                     ?}
                  ?};
                  _result
               ');
      _result:=_rule(_paczka,_cap_eaten,_infinity[_it])
   !};
   {? _result
   || _msg:='Pojemnik: '+PX_CUP.SYMBOL+' ma zbyt małą pojemność aby pomieścić minimum paczki';
      pxkomm.error(_msg)
   ?}
?};
pxkomm.sect_end();
_result


\first_cup
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Szuka pierwszego niezablokowanego pojemnika w kontenerze, od ktorego zaczynamy plan
::       Kontekst pracy - rekord PX_KONT, rekord paczki technologicznej
::   WE: _a - REAL - tm_stamp() - zadany poczatek planowania
::       _b - INTEGER - zwrot planowania (-1/1)
::       [_c] - obj_new - obiekt PxPack - paczka technologiczna z obudowa
::       [_d] - REAL - tm_stamp() - granica planowania 'Od' pochodzaca z obiektu grupujacego
::                                 nie moge jej przekroczyc robiac nakladkowanie
::       [_e] - REAL - tm_stamp() - granica planowania 'Do' pochodzaca z obiektu grupujacego
::                                  nie moge jej przekroczyc robiac nakladkowanie
::       [_f] - TABLE - uchwyt do tabeli w której szukać: PX_CUP lub PX_CAL. Jeśli nie podane
::                      to PX_CUP
::       [_g] - INTEGER - poziom kalendarza. Tylko dla tabeli PX_CAL, jeżeli jest podany to prefiksuję PX_CALe
::                             tym poziomem
::   WY: 0 / 1 - udalo sie znalezc pojemnik czy nie
::----------------------------------------------------------------------------------------------------------------------
_start:=_a;
_dir:=_b;
_pxpack:=~~;
{? var_pres('_c')>100
|| _pxpack:=_c
?};
_tm_od:=0;
{? var_pres('_d')=type_of(0)
|| _tm_od:=_d
?};
_tm_do:=0;
{? var_pres('_e')=type_of(0)
|| _tm_do:=_e
?};

_tab:=~~;
{? var_pres('_f')=type_of(PX_CAL)
|| _tab:=_f
|| _tab:=PX_CUP
?};

_lane:=0;
{? var_pres('_g')=type_of(0)
|| _lane:=_g
?};

_result:=0;
_continue:=1;

{? _tab=PX_CAL
||
:: Algorytm nakładkowania metodą proporcji czasowej
   {? exec('cup_closest','px_plan',PX_KONT.ref(),_start,_dir,PX_CAL,_lane)>0
   || PX_CAL.PX_CUP();
      _result:=1
   ?}
||
   {? exec('cup_closest','px_plan',PX_KONT.ref(),_start,_dir)>0
   ||
      {? PX_VAR.NAST_ALG=2 & exec('is_koop','px_kont',PX_KONT.ref())
      || return(1)
      ?};

::    -------------------- Obsluga PX_CUP.TM_WALLx
::
::                                      PX_CUP
::    .----------------------------------------------------------------------------.
::    |                |                                         |                 |
::    |PX_CUP.TM_WALL1 |                                         | PX_CUP.TM_WALL2 |
::    |                |                                         |                 |
::    '----------------------------------------------------------------------------'
::
::    Punkty czasowe PX_CUP.TM_WALLx sa uzywane podczas wyznaczania pierwszego pojemnika w planie na danym kontenerze
::    Dysponujac punktem czasowym w ktorym zakonczyl sie plan na poprzednim kontenerze
::    algorytm planujacy musi znalezc pierwszy pojemnik w aktualnie planowanym kontenerze
::    TM_WALL1 i TM_WALL2 okreslaja granice czasowe na pojemniku po przekroczeniu ktorych algorytm powinien
::    znalezc kolejny pojemnik zgodnie ze zwrotem planowania
::
::    Jesli ktorys z TM_WALLx nie zostanie ustawiony to trigger tabeli PX_CUP ustawi go tak samo jak pola
::    TM_START i TM_END
      _result:=0;
      {!
      |? {? PX_CUP.STATUS=exec('status_normal','px_cup')
         || {? _dir>0
            || {? _start<=PX_CUP.TM_WALL2
               || _result:=1
               ?}
            || {? _start>=PX_CUP.TM_WALL1
               || _result:=1
               ?}
            ?}
         ?};
         _continue:={? _result=0
                    || {? _dir>0
                       || PX_CUP.next() & _result=0
                       || PX_CUP.prev() & _result=0
                       ?}
                    || 0
                    ?};
         _continue
      !};
::    -------------------- Obsluga nakladkowania na poprzedni pojemnik
      {? _result>0 & type_of(_pxpack)>100
      ||
         _paczka:=_pxpack.Paczka;
         _continue:=1;
::       jesli etap nie ma poprzednika - tzn. zaczyna sie od momentu poczatku planu to nie ma nakladkowania
::       bo nakladkowanie wystepuje tylko wzgledem poprzedniej operacji a nie poczatku planu
::       dodatkowo jesli etap ma okreslone punkty czasowe to tez nakladkowanie nie ma sensu
         _nakladkowac:=0;
         {? _dir>0
         || _has_prev:=exec('oper_has_prev','px_logix',_pxpack,1);
            {? _has_prev>0 & (_paczka.TM_MIN=0 & _paczka.TM_MAX=0) & (_paczka.TM_START=0 & _paczka.TM_END=0)
            || _nakladkowac:=1
            ?}
         ||
            _has_next:=exec('oper_has_next','px_logix',_pxpack,1);
            {? _has_next>0 & (_paczka.TM_MIN=0 & _paczka.TM_MAX=0) & (_paczka.TM_START=0 & _paczka.TM_END=0)
            || _nakladkowac:=1
            ?}
         ?};

         {? _nakladkowac>0
         ||
            _beforenakl:=PX_CUP.ref();
            _naklprc:=exec('nakl_prc','px_logix',_paczka);

            {? PX_VAR.NAST_ALG=1
            || _naklprc:=0
            ?};

            {? _naklprc<>100
            ||
::             Nakładkowanie nie będzie robione jesli z powodu roznicy w strukturze
::             pojemnikow pierwszy znaleziony pojemnik juz spowodowal ze etapy zostana na siebie
::             nalozone - po co poglebiac jeszcze to nalozenie
               {? _dir>0
               || {? PX_CUP.TM_START<_start
                  || _continue:=0
                  ?}
               || {? PX_CUP.TM_END>_start
                  || _continue:=0
                  ?}
               ?};
               _res_nakl:=0;
               {? _continue>0
               ||
::                ustawiam sie na poprzednim lub nastepnym pojemniku zgodnie ze zwrotem

                  _cur_time:=0;
                  {? _dir>0
                  || _cur_time:=PX_CUP.TM_START
                  || _cur_time:=PX_CUP.TM_END
                  ?};

                  _continue:={? _dir>0
                             || PX_CUP.prev()
                             || PX_CUP.next()
                             ?};
                  {? _continue>0
                  ||
::                   Sprawdzam czy pojemnik na ktorym chce nakladkowac nie jest wczesniej niz
::                   granica czasowa 'Od' i później niż 'Do' obiektu w kolejce. Jesli tak to nie robie nakladkowania
::                   bo zaplanuje mi sie wczesniej niz mialo sie zaplanowac, albo przekroczę termin realizacji
                     {? _tm_od>0 & PX_CUP.TM_START<_tm_od
                     || _continue:=0
                     ?};
                     {? _tm_do>0 & PX_CUP.TM_END>_tm_do
                     || _continue:=0
                     ?}
                  ?};

                  {? PX_VAR.NAST_ALG=1
                  || _continue:=0;
                     _res_nakl:=1
                  ?};

                  {? _continue>0 & PX_CUP.STATUS=exec('status_normal','px_cup')
                  ||

::                   obliczam zjedzona pojemnosc danego pojemnika
                     _eaten:=exec('cap_eaten','px_cup');

::                   jesli pojemnik nie mial nic zjedzone to nie musze juz sprawdzac proporcji, wiem ze on
::                   moze stac sie pierwszym pojemnikiem
                     {? exec('array_sum','#array',_eaten)=0
                     || _res_nakl:=1
                     ||
::                      obliczam dostepna maksymalna pojemnosc danego pojemnika
                        _max:=exec('cap_max','px_cup');

::                      w petli po wymiarach okreslam minimalna proporcje zjedzonego do dostepnego
::                      proporcja nigdy nie bedzie zerowa bo wczesniej sprawdzilem czy w ktorymkolwiek wymiarze
::                      cos zostalo zjedzone
                        _eaten_prop:=1;
                        {! _it:=1..PX_KONT.IL_WYM
                        |! {? _max[_it]>0
                           ||
                              _c_prop:=_eaten[_it]/_max[_it];
                              {? _c_prop>0
                              || {? _c_prop<_eaten_prop
                                 || _eaten_prop:=_c_prop
                                 ?}
                              ?}
                           ?}
                        !};
::                      tyle procent wolnego mam
                        _free_prc:=(1-_eaten_prop)*100;
::                      a tyle procent wolnego potrzebuje
                        _demand_prc:=_naklprc;

                        {? _free_prc>=_demand_prc
                        || _res_nakl:=1
                        ?}
                     ?}
                  ?};
                  {? _res_nakl=0
                  ||
::                   Jesli nakladkowanie z jakiegos powodu sie nie powiodlo to do bufora przywracam pojemnik
::                   znaleziony bez nakladkowania
                     {? PX_CUP.seek(_beforenakl)
                     || _result:=1
                     || _result:=0
                     ?}
                  ||
::                   Jesli nakladkowanie zostalo zrobione to w rekordzie paczki zapamietuje
::                   roznice czasu wynikajaca z nakladkowania po to by pozniej ta roznice uwzglednic
::                   podczas kontrolowania czy etapy sie ze soba zazebiaja
                     _diff:=0;
                     {? _dir>0
                     || _diff:=_cur_time-PX_CUP.TM_START
                     || _diff:=_cur_time-PX_CUP.TM_END
                     ?};
                     {? _diff<0
                     || _diff:=_diff*(-1)
                     ?};
                     _paczka.NAKLDIFF:=_diff;
                     _paczka.put()
                  ?}
               ?}
            ?}
         ?}
      ?}
   ?}
?};
_result


\pxstage_in_cup
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Sprawdza w aktualnym kafelku jest juz pozycja planu powiazana z PX_GRP i z PX_STAGE
::       Kontekst pracy - rekord paczki technologicznej
::       UWAGA! Zmienia kontekst i indeks tabeli PX_POZ!
::   WE: _a - PX_GRP.ref()
::       _b - PX_STAGE.ref()
::       _c - tab_tmp - paczka technologiczna
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------

_result:=0;
_px_grp:=_a;
_px_stage:=_b;
_paczka:=_c;

_can_continue:=1;
PX_POZ.index('PX_STAGE');

:: Pozycje planu o statusie roznym pod wzgledem opoznienia, nie sa scalane,
:: w kazdym innym przypadku status nie gra roli
_status:=exec('status_normal','px_poz');
_px_obj:=null();
{? _paczka.PX_OBJ<>''
|| _px_obj:=exec('FindAndGet','#table',PX_OBJ,_paczka.PX_OBJ)

?};

{? _paczka.STATUS=exec('status_pck_dlay','px_tex')
||
:: jesli planuje opoznienia to musze sprawdzic czy w pojemniku znajduja sie pozycje planu
:: powiazane z PX_GRP i PX_STAGE o statusie opoznionym
   _status:=exec('status_delay','px_poz');
   _result:=exec('find_in_cup','px_poz',_px_grp,_px_stage,,_status,_px_obj,0)
||
:: jesli planuje wszystko poza opoznieniami to  musze sprawdzic czy w pojemniku znajduja sie pozycje planu
:: powiazane z PX_GRP i PX_STAGE o nastepujacych statusach:
::    - normalnym
::    - wykonywanym
::    - wykonanym
:: Generalnie koncepcja jest taka ze moge scalac ze wszystkim, byle nie z pozycjami opoznionymi

:: Status normalny
   _status:=exec('status_normal','px_poz');
   _result:=exec('find_in_cup','px_poz',_px_grp,_px_stage,,_status,_px_obj,0);

:: Status 'wykonywany'
   {? _result=0
   || _status:=exec('status_wyk1','px_poz');
      _result:=exec('find_in_cup','px_poz',_px_grp,_px_stage,,_status,_px_obj,0)
   ?};
:: Status 'wykonany'
   {? _result=0
   || _status:=exec('status_wyk2','px_poz');
      _result:=exec('find_in_cup','px_poz',_px_grp,_px_stage,,_status,_px_obj,0)
   ?}
?};
_result


\ploper_in_cup
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy w aktualnym pojemniku jest juz pozycja planu powiazana z PL_OPERem
::       UWAGA! Zmienia kontekst i indeks tabeli PX_POZ!
::   WE: _a - PL_OPER.ref()
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_pl_oper:=_a;

_result:=0;
PX_POZ.index('PL_OPER');
PX_POZ.prefix(PX_CUP.ref(),_pl_oper);
{? PX_POZ.first()
|| _result:=1
?};
PX_POZ.clear();
_result


\plogr_in_cup
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy w aktualnym pojemniku jest juz pozycja planu powiazana z PL_OGRem
::       UWAGA! Zmienia kontekst i indeks tabeli PX_POZ!
::   WE: _a - PL_OGR.ref()
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_pl_ogr:=_a;

_result:=0;
PX_POZ.index('PL_OGR');
PX_POZ.prefix(PX_CUP.ref(),_pl_ogr);
{? PX_POZ.size()>0
|| _result:=1
?};
PX_POZ.clear();
_result


\poz_conn_obj
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Wiaze pozycje planu z obiektami planowanymi
::       Algorytm planujacy gdy wrzuca pozycje do pojemnika to nie wiaze pozycji z obiektami planowanymi
::       Ta funkcja ma za zadanie to zrobic - jesli jest potrzeba (tzn jeden obiekt grupujacy zawiera wiecej niz
::       jeden obiekt planowany) to pozycje planu na pojemniku musza byc poszatkowane
::   WE: _a - PX_GRP.ref()
::       _b - PxPack zawierajaca tab_tmp() -  paczka technologiczna ktora mowi mi jak zaplanowac i gdzie
::            oraz odpowiednie indeksy
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_PxPack:=_b;
_paczka:=_PxPack.Paczka;

_result:=0;
_can_continue:=1;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};
_msg:='poz_conn_obj\px_logix - wiazanie pozycji planu z obiektami planowanymi.';
pxkomm.sect_beg(_msg);

PX_GRP.cntx_psh();
PX_OBJ.cntx_psh();
PX_POZ.cntx_psh();
PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');
PX_CONN.clear();
PX_GRP.clear();
PX_OBJ.clear();

{? PX_GRP.seek(_px_grp)
||
:: sprawdzam czy trzeba uruchomic szatkownice - jesli w PX_GRP jest tylko jeden PX_CONN, to nie trzeba szatkowac,
:: wystarczy powiazac wszystkie PX_POZy z odpowiednim PX_OBJ na ktorego wskazuje PX_CONN
   PX_CONN.prefix(PX_GRP.ref());
   {? PX_CONN.size()>1
   ||
      _msg:='Start szatkownicy';
      pxkomm.sect_beg(_msg);
::    ---------------------------------- SZATKOWNICA START
::    Szatkowanie pozycji planu - kazda pozycja planu w pierwszym przebiegu algorytmu planowania jest powiazana tylko
::    z PX_GRP. Ale PX_GRP moze miec w sobie kilka PX_OBJ, a docelowo pozycje planu nalezy powiazac z PX_OBJ
::    W tym celu rozbijam pozycje planu nalezaca do PX_GRP na kawalki. Ilosci dzielone sa proporcjonalnie
::    wg tego jak PX_OBJ sa rozdzielone w PX_GRP
      PX_KONT.cntx_psh();
      PX_KONT.clear();
      PX_STAGE.cntx_psh();
      PX_STAGE.clear();
      _paczka.index(_PxPack.Ndx_fwd);
      _paczka.prefix('K');
      {? _paczka.first()
      || _argszat:=exec('szatkownica_a','px_logix');
         _argszat.PX_GRP:=PX_GRP.ref();
         _argszat.DIR:=PX_GRP.DIR;
         {!
         |?
::          jesli pozycja w paczce miala przypisanego PX_OBJ to nie szatkuje, bo najwyrazniej
::          ilosci zostaly juz poszatkowane w paczce (przypadek planowania opoznien za pomoca
::          funkcji exec('delays_mode1','px_logix'))
            {? _paczka.PX_OBJ=''
            || PX_KONT.clear();
               {? PX_KONT.seek(_paczka.KONTREAL)
               || PX_STAGE.clear();
                  {? PX_STAGE.seek(_paczka.PX_STAGE)
                  ||
                     _argszat.PX_KONT:=PX_KONT.ref();
                     _argszat.PX_STAGE:=PX_STAGE.ref();
::                   okreslam ilosc pozycji planu ktore beda szatkowane
                     PX_POZ.cntx_psh();
                     PX_POZ.index('GRPFORW') ;
                     PX_POZ.prefix(PX_GRP.ref(),PX_KONT.ref(),PX_STAGE.ref());
                     _poz_size:=PX_POZ.size();
                     PX_POZ.cntx_pop();

::                   szatkownica sekwencyja tylko jesli ilosc pozycji planu do poszatkowania wieksza od 1
::                   w przeciwnym razie nie ma co szatkowac sekwencyjnie
                     {? PX_KONT.GRP_MODE=exec('grp_mode_seq','px_kont') & _poz_size>1
                     || exec('szatkownica_seq','px_logix',_argszat)
                     ?};
                     {? PX_KONT.GRP_MODE=exec('grp_mode_row','px_kont') | _poz_size=1
                     || exec('szatkownica_row','px_logix',_argszat)
                     ?}
                  || _msg:='Nie znaleziono etapu dla szatkownicy: '+_paczka.PX_STAGE;
                     pxkomm.error(_msg)
                  ?}
               || _msg:='Nie znaleziono kontenera dla szatkownicy: '+_paczka.KONTREAL;
                  pxkomm.error(_msg)
               ?}
            ?};
            _paczka.next()
         !}
      ?};
      PX_KONT.cntx_pop();
      PX_STAGE.cntx_pop();
      pxkomm.sect_end()
::    ---------------------------------- SZATKOWNICA END
   ||
::    SZATKOWNICA OFF - proste wiazanie pozycji planu
      {? PX_CONN.first()
      ||
         PX_POZ.index('PX_GRP2');
         PX_POZ.prefix(PX_GRP.ref(),null());
         {? PX_POZ.first()
         || {!
            |? PX_POZ.cntx_psh();
               PX_POZ.clear();
               PX_POZ.PX_OBJ:=PX_CONN.PX_OBJ;
               _can_continue:=PX_POZ.put();
               PX_POZ.cntx_pop();

               PX_POZ.first() & _can_continue>0
            !}
         ?}
      ?}
   ?};
:: odswiezam ilosc w planie glownym dla wszystkich PX_OBJ wchodzacych w sklad PX_GRP
   {? PX_GRP.PX_VER=exec('get_mainversion','px_ver')
   || PX_CONN.prefix(_px_grp);
      {? PX_CONN.first()
      || {!
         |? exec('il_plan_refresh','px_obj',PX_CONN.PX_OBJ);
            exec('planend_refresh','px_obj',PX_CONN.PX_OBJ);
            PX_CONN.next()
         !}
      ?}
   ?}
|| _msg:='Nie znaleziono obiektu grupujacego: '+$_px_grp;
   pxkomm.error(_msg)
?};

pxkomm.sect_end();

PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
PX_CONN.cntx_pop();
PX_POZ.cntx_pop();
~~


\czyplanowaczka
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Sprawdza czy zostalo jeszcze cos do zaplanowania z paczki
::       Kontekst pracy:   PX_KONT - kontener
::                         PX_CUP/PX_CAL - pojemnik
::   WE: _a - rekord paczki technologicznej exec('paczka_declare','px_tex')
::       _b - zwrot planowania - 1: w przod, -1: w tyl
::       [_c] - TABLE - tabela w której będzie poszukiwany rekord (domyślnie PX_CUP)
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------

_paczka:=_a;
_dir:=_b;

_tab:=~~;
{? var_pres('_c')>0
|| _tab:=_c
|| _tab:=PX_CUP
?};

_result:=0;

_il_wym:=PX_KONT.IL_WYM;

:: Specjalna obsluga dla kooperacji
{? _paczka.COOP>0
||
   {? _dir>0
   ||
::    Planowanie w przod
      {? _tab.TM_START<_paczka.TM_END
      || _result:=1
      ?}
   ||
::    Planowanie w tyl
      {? _tab.TM_END>_paczka.TM_START
      || _result:=1
      ?}
   ?}
||
   {! _it:=1.._il_wym
   |! _rule:=$('_paczka:=_a;_paczka.CAP_DIM'+$_it+'-_paczka.DID_DIM'+$_it);
      _il:=_rule(_paczka);
      {? _il>0
      || _result:=1
      ?}
   !}
?};
_result


\po_wlaniu
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Formula uruchamiana zawsze gdy do pojemnika dodano nowa pozycje planu
::   WE: _a - PX_CUP.ref() - kafelek do ktorego wlewam
::       _b - obj_new() - tablica nazwana - exec('blank_a','px_poz') - co dodalem
::       [_c] - INTEGER - 0/[1] - czy wykonywac renumeracje pozycji
::----------------------------------------------------------------------------------------------------------------------
_px_cup:=_a;
_px_poz:=_b;

_renumerate:=1;
{? var_pres('_c')=type_of(0)
|| _renumerate:=_c
?};

PX_CUP.cntx_psh();
PX_CUP.clear();
{? PX_CUP.seek(_px_cup)
||
:: aktualizuje ilosci zajete na pojemniku rzeczywistym
   _il_wym:=PX_CUP.PX_KONT().IL_WYM;
   {! _it:=1.._il_wym
   |! _rule:=$('_px_poz:=_a;PX_CUP.CAP_USE'+$_it+'+=_px_poz.CAP_EAT'+$_it);
      _rule(_px_poz)
   !};
   _ok:=PX_CUP.put();

:: FUNKCJA PO WLANIU (UZYTKOWNIKA)
   {? PX_CUP.PX_KONT().CUP_IN().RULE<>''
   ||
::    pobieram formule z kontenera po wlaniu
      _rule:=$PX_CUP.PX_KONT().CUP_IN().RULE;
::    uruchamiam formule po wlaniu z kontenera
      _rule(_px_cup,_px_poz)
   ?};

:: OBSLUGA KONTENEROW NIESKONCZONYCH
   {? PX_CUP.PX_KONT().ENDLESS>0
   || {! _it:=1.._il_wym
      |! _rule:=$('_px_poz:=_a;PX_CUP.CAP_MAX'+$_it+'+=_px_poz.CAP_EAT'+$_it);
         _rule(_px_poz)
      !};
      _ok:=PX_CUP.put()
   ?};

   {? _renumerate>0
   ||
::    RENUMERACJA POZYCJI PLANU
      exec('renumerate','px_poz',PX_CUP.ref())
   ?}
?};
PX_CUP.cntx_pop();
~~


\po_wylaniu
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Formula uruchamiana zawsze gdy z pojemnika usunieto nowa pozycję planu
::   WE: _a - PX_CUP.ref() - kafelek z ktorego wylewam
::       _b - obj_new() - tablica nazwana - exec('blank_a','px_poz') - co usunalem
::       [_c] - INTEGER - 0/[1] - czy wykonywac renumeracje pozycji planu
::----------------------------------------------------------------------------------------------------------------------
_px_cup:=_a;
_px_poz:=_b;
_renumerate:=1;
{? var_pres('_c')=type_of(0)
|| _renumerate:=_c
?};

PX_CUP.cntx_psh();
PX_CUP.clear();
{? PX_CUP.seek(_px_cup)
||
:: aktualizuje ilosci zajete na pojemniku
   _il_wym:=PX_CUP.PX_KONT().IL_WYM;
   {! _it:=1.._il_wym
   |! _rule:=$('_px_poz:=_a;PX_CUP.CAP_USE'+$_it+'-=_px_poz.CAP_EAT'+$_it);
      _rule(_px_poz)
   !};
   _ok:=PX_CUP.put();

:: Usuniecie komunikatow informujacych o pozycjach planu przesunietych z przyszlosci na skutek nadwykonan
:: 1. sprawdzenie, czy jest podpiety komunikat
   _komm:=exec('get_kom','px_komm','PX_CUP',PX_CUP.ref(),exec('type_info','px_komm'),exec('src_nadwykon_mv','px_komm'));
   {? _komm<>null()
   ||
:: 2. sprawdzenie czy ktorakolwiek pozycja jest przesunieta z przyszlosci na skutek nadwykonania
      _nadwyk:=0;
      PX_POZ.cntx_psh();
      PX_POZ.index('LP');
      PX_POZ.prefix(PX_CUP.ref());
      {? PX_POZ.first()
      || {!
         |? {? exec('nadwykon_moved','px_poz')
            || _nadwyk:=1
            ?};
            _nadwyk=0 & PX_POZ.next()
         !}
      ?};
      PX_POZ.cntx_pop();
:: 3. wlasciwe usuwanie
      {? ~_nadwyk
      || exec('del_kommy','px_komm','PX_CUP',PX_CUP.ref(),exec('type_info','px_komm'),exec('src_nadwykon_mv','px_komm'))
      ?}
   ?};

:: FUNKCJA PO WYLANIU (UZYTKOWNIKA)
   {? PX_CUP.PX_KONT().CUP_OUT().RULE<>''
   ||
::    pobieram formule z kontenera po wylaniu
      _rule:=$PX_CUP.PX_KONT().CUP_OUT().RULE;
::    uruchamiam formule po wylaniu z kontenera
      _rule(_px_cup,_px_poz)
   ?};

:: OBSLUGA KONTENEROW NIESKONCZONYCH
   {? PX_CUP.PX_KONT().ENDLESS>0
   || {! _it:=1.._il_wym
      |! _rule:=$('_px_poz:=_a;PX_CUP.CAP_MAX'+$_it+'-=_px_poz.CAP_EAT'+$_it);
         _rule(_px_poz)
      !};
      _ok:=PX_CUP.put()
   ?};
   {? _renumerate>0
   ||
::    RENUMERACJA POZYCJI PLANU
      exec('renumerate','px_poz',PX_CUP.ref())
   ?}
?};
PX_CUP.cntx_pop();
~~


\px_ver_plan_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Argumenty dla formuly planujacej wersje - px_ver_plan
::   WY: obj_new
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
::             Wesja ktora planowac - PX_VER.ref
               'DEST'
::             Tryb wyswietlania:
::                0 - tryb cichy bez progressow na ekran (watek alerta)
::                1 - tryb polcichy - w biezacej sesji, z progressami ale bez pokazywania planu po zakonczeniu
::                2 - tryb glosny - w biezacej sesji, z progressami i komunikatami, po zakonczeniu pokazuje plan
               ,'VIEW_MODE'
::             Tryb klonowania:
::                0  - klonowanie bez pozycji planu
::               [1] - klonowanie tylko zablokowanych pozycji planu (DOMYSLNE)
::                2  - klonowanie wszystykich pozycji planu
               ,'CLONE_MODE'
::             Czy dostepna edycja, czy tylko podglad:
::                -1  - podglad, panel zaawansowania przeliczania pozwala tylko zaakceptowac symulacje
::                 0  - podglad, bez panelu zaawansowania przeliczania
::                [1] - redagowanie planu
               ,'EDIT'
::             Czy po zamknieciu czyscic kolejke:
::                [1] - po zamknieciu podgladu bez akceptacji czyszcze kolejke
::                     (uzywane po przeliczeniu planu w biezacej sesji)
::                 0  - po zamknieciu podgladu bez akceptacji wersji nie czyszcze kolejki
::                     (uzywane podczas symulacji zamowienia lub zlecenia)
               ,'CLEAN_Q'
::             Konteskt wywolania:
::                [PX] - plan (domylsnie)
::                ZAM  - symulacja zamowienia
::                ZL   - symulacja zlecenia
               ,'CONTEXT'

::             Czy przed przeliczeniem wykonywac aktualizacje kolejki?
::                [1] - tak
::                 0  - nie
               ,'UPDATE_Q'
::             Czy przed przeliczeniem sprawdzic kolejke?
::                [1] - tak
::                 0  - nie
               ,'VERIFY_Q'
              );
_args.DEST:=null();
_args.VIEW_MODE:=1;
_args.CLONE_MODE:=1;
_args.EDIT:=1;
_args.CLEAN_Q:=1;
_args.CONTEXT:='PX';
_args.UPDATE_Q:=1;
_args.VERIFY_Q:=1;
_args


\px_ver_plan
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Glowny algorytm planowania - planuje wersje planu
::   WE: _a - PX_VER.ref() - wersja planu ktora planuje
::       _b - 0: tryb cichy bez progressow na ekran (watek alerta)
::            1: tryb polcichy - w biezacej sesji, z progressami ale bez pokazywania planu po zakonczeniu
::            2: tryb glosny - w biezacej sesji, z progressami i komunikatami, po zakonczeniu pokazuje plan
::       [_c] -   0: tryb klonowania - klonowanie bez pozycji planu
::                [1]: tryb klonowania - klonowanie tylko zablokowanych pozycji planu (DOMYSLNE)
::                2: tryb klonowania - klonowanie wszystykich pozycji planu
::       [_d] - -1: podglad, panel zaawansowania przeliczania pozwala tylko zaakceptowac symulacje
::               0: podglad, bez panelu zaawansowania przeliczania
::              [1]: redagowanie planu
::       [_e] - [1] - po zamknieciu podgladu bez akceptacji czyszcze kolejke
::                    (uzywane po przeliczeniu planu w biezacej sesji)
::               0  - po zamknieciu podgladu bez akceptacji wersji nie czyszcze kolejki
::                    (uzywane podczas symulacji zamowienia lub zlecenia)
::       [_f] - konteskt wywolania: plan (PX), symulacja zamowienia (ZAM), symulacja zlecenia (ZL), domyslnie 'PX'
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_source:=exec('get_mainversion','px_ver');
_can_continue:=1;
_result:=0;
_delays_mode:=exec('get','#params',500356,2);

{? _source=_args.DEST
|| FUN.emsg('Przeliczanie planu zakończone niepowodzeniem.\nWersja docelowa i źródłowa nie mogą być tożsame.'@);
   return(0)
?};
PX_GRP.cntx_psh();
PX_GRP.index('PLAN');
PX_VER.cntx_psh();
PX_VER.clear();
PX_GRP.clear();
PX_OBJ.cntx_psh();

:: inicjalizacja obiektu KOMM
exec('pxkomm_init','px_logix');

exec('opernast_init','px_init');

_argsprog:=exec('plan_progress_a','px_logix');
_argsprog.PX_VER:=_args.DEST;

:: Aby wylaczyc multiprogress nalezy ustawic _prog_mode:=1
_prog_mode:=2;
_argsprog.MODE:={? _args.VIEW_MODE=0 || 0 |? _args.VIEW_MODE>0 || _prog_mode ?};

_argsprog.SIZEALL:=1000;

_komm_size:=exec('clean4plan_size','px_komm',_args.DEST);
_clean_size:=exec('task_size_clean','px_logix',_args.DEST);
_clone_size:=exec('task_size_clone','px_logix',_source);
_delay_size:=exec('task_size_delay','px_logix',_args.DEST);
_queue_size:=exec('task_size_queue','px_logix',_args.DEST);
_pxpoz_size:=exec('task_size_pxpoz','px_logix',_source);
_cal_size:=0;
{? PX_VAR.NAST_ALG=2
|| _cal_size:=exec('task_size_cal','px_logix',_source)
?};
_verified:=1;

{? _argsprog.MODE=1
|| FUN.prg_start(100,,50)
|? _argsprog.MODE=2
||
:: Inicjuje multiprogress
   {? _args.UPDATE_Q>0 & _queue_size>0
   || _argsprog.MULTI.add_progress('Aktualizacja elementów kolejki'@,_queue_size)
   ?};
   {? _args.VERIFY_Q>0 & _queue_size>0
   || _argsprog.MULTI.add_progress('Weryfikacja elementów kolejki'@,_queue_size)
   ?};
   {? _komm_size>0
   || _argsprog.MULTI.add_progress('Kasowanie komunikatów dot. przeliczania planu'@,_komm_size)
   ?};
   {? _clean_size>0
   || _argsprog.MULTI.add_progress('Wstępne czyszczenie wersji'@,_clean_size)
   ?};
   {? _clone_size>0
   || _argsprog.MULTI.add_progress('Przygotowywanie wersji planu'@,_clone_size)
   ?};
   {? _cal_size>0
   || _argsprog.MULTI.add_progress('Odtwarzanie kalendarzy w pojemnikach'@,_cal_size)
   ?};

:: Tryb przeplanuj opoznienia - najpierw progress opoznien, pozniej kolejki
   {? _delays_mode=exec('delays_plan','px_param')
   || {? _delay_size>0
      || _argsprog.MULTI.add_progress('Planowanie opóźnień'@,_delay_size)
      ?};
      {? _queue_size>0
      || _argsprog.MULTI.add_progress('Planowanie kolejki'@,_queue_size)
      ?}
   ?};
:: Tryb przesun opoznienia - najpierw progress kolejki, pozniej opoznien
   {? _delays_mode=exec('delays_move','px_param')
   || {? _queue_size>0
      || _argsprog.MULTI.add_progress('Planowanie kolejki'@,_queue_size)
      ?};
      {? _delay_size>0
      || _argsprog.MULTI.add_progress('Planowanie opóźnień'@,_delay_size)
      ?}
   ?};
   _argsprog.MULTI.add_progress('Nanoszenie zapotrzebowań na surowce'@,_pxpoz_size);
   exec('start','#progress',_argsprog.MULTI)
?};

_msg:='Uruchomienie algorytmu planowania wersji (ref wersji: '+$_args.DEST+')';
pxkomm.sect_beg(_msg);
_current_px_grp:='';
{? PX_VER.seek(_args.DEST)
||
   _msg:='Blokowanie wersji: '+PX_VER.SYMBOL;
   pxkomm.sect_beg(_msg);
:: blokuje wersje
   {? exec('lock','px_ver',PX_VER.ref())
   ||
      _argsprog.PHASES:=3;
::    Inicjuję obiekt w którym będę przechowywał refy zablokowanych przepisów na czas przeliczania
      _locked_tex:=exec('ref_table','#table');

::    -------------------- 1. Aktualizacja kolejki ---------------------
      {? _can_continue>0 & _args.UPDATE_Q>0 & _queue_size>0
      || {? _argsprog.MODE=2
         || _argsprog.MULTI.next_phase()
         ?};
         _can_continue:=exec('queue_update','px_logix',,_argsprog)
      ?};
::    -------------------- 2. Weryfikacja kolejki ---------------------
      {? _can_continue>0 & _args.VERIFY_Q>0 & _queue_size>0
      || {? _argsprog.MODE=2
         || _argsprog.MULTI.next_phase()
         ?};
         _can_continue:=exec('queue_check','px_logix',,_argsprog,,_locked_tex);
         {? _can_continue<=0
         || _verified:=0
         ?}
      ?};
::    -------------------- 3. Czyszczenie komunikatow ---------------------
      {? _can_continue>0 & _komm_size>0
      || {? _argsprog.MODE=2
         || _argsprog.MULTI.next_phase()
         ?};
         _can_continue:=exec('clean4plan','px_komm',,_argsprog)
      ?};
::    -------------------- 4. Czyszczenie planu ---------------------
      _argsprog.PHASE:=1;
      _argsprog.PROGLOC:=0;
      {? _can_continue>0 & _clean_size>0
      || {? _argsprog.MODE=2
         || _argsprog.MULTI.next_phase()
         ?};
         _can_continue:=exec('clean','px_ver',PX_VER.ref(),_argsprog)
      ?};

      {? _can_continue>0
      || PX_VER.STATUS:=exec('status_pending','px_ver');
         PX_VER.SYMBOL:=exec('symbol_real','px_ver',PX_VER.ref());
         PX_VER.put()
      ?};

::    -------------------- 5. Klonowanie planu ---------------------
      {? _can_continue>0 & _clone_size>0
      ||
         {? _argsprog.MODE=2
         || _argsprog.MULTI.next_phase()
         ?};
         _argsprog.PHASE:=2;
         _argsprog.PROGLOC:=0;
::       okreslam granice czasowe klonowania
         _start:=PX_GRP.tm_stamp();
         _end:=0;

::       Przetwarzam tylko nie wykonane i niezablokowane obiekty kolejki - wykonane nie musza miec wplywu na granice
         PX_GRP.prefix(_args.DEST,'N','N','Z');
         {? PX_GRP.first()
         || _can_continue:=1;
            {!
            |? {? PX_GRP.TM_END>_end & PX_GRP.TM_END>PX_GRP.tm_stamp()
               || _end:=PX_GRP.TM_END
               ?};
::             jesli ktorykolwiek element kolejki nie ma daty koncowej lub jest planowany do przodu
::             i pozwalamy na przekroczenie terminu realizacji
::             to znak ze cala wersja nie moze miec daty koncowej bo nie wiadomo
::             kiedy ma sie skonczyc ten element bez konca - to dopiero sie okaze po zaplanowaniu
               {? PX_GRP.TM_END<=0 | (PX_GRP.DIR>0 & PX_GRP.PL_FORCE='T')
               || _end:=0;
                  _can_continue:=0
               ?};
               PX_GRP.next() & _can_continue>0
            !}
         ?};

::       uruchamiam klonowanie wersji
         _argsclone:=exec('clone_a','px_ver');
         _argsclone.SOURCE:=_source;
         _argsclone.DEST:=_args.DEST;
         _argsclone.TM_START:=_start;
         _argsclone.TM_END:=_end;
         _argsclone.MODE:=_args.CLONE_MODE;
         _argsclone.STARTMOD:=exec('start_curcup','px_param');

         _can_continue:=exec('clone','px_ver',_argsclone,_argsprog)
      ?};
::    -------------------- 6. Odtwarzanie kalendarzy ---------------------
      {? _can_continue>0 & _cal_size>0
      || {? _argsprog.MODE=2
         || _argsprog.MULTI.next_phase()
         ?};
         _update_pxcup:=1;
         {? _args.CONTEXT='ZL' | _args.CONTEXT='ZAM'
         || _update_pxcup:=0
         ?};
         _can_continue:=exec('rebuild4all','px_cal',0,2,PX_CUP.tm_stamp(),_argsprog,_args.DEST,_update_pxcup)
      ?};

::    -------------------- 7. Planowanie opoznien tryb 'PRZEPLANUJ' ---------------------
      {? _can_continue>0 & _delay_size>0
      || {? _delays_mode=exec('delays_plan','px_param')
         || {? _argsprog.MODE=2
            || _argsprog.MULTI.next_phase()
            ?};
            _can_continue:=exec('delays_mode1','px_logix',_source,_args.DEST,_argsprog)
         ?}
      ?};
::    -------------------- 8. Planowanie kolejki ---------------------
      {? _can_continue>0
      || {? _argsprog.MODE=2
         || _argsprog.MULTI.next_phase()
         ?};
         _argsprog.PHASE:=3;
         _argsprog.PROGLOC:=0;

::       Przetwarzam tylko nie wykonane i niezablokowane obiekty kolejki
         PX_GRP.prefix(_args.DEST,'N','N');
         _argsprog.SIZELOC:=PX_GRP.size();

         _argsgrp:=exec('plan_grp_a','px_logix');
         _argsgrp.VER_DST:=_args.DEST;
         _argsgrp.TM_RANGE:=exec('tm_range_create','px_logix');

         {? PX_GRP.first()
         ||
            _it:=0;
            _pxpack:=obj_new(1);
            {!
            |?
               _current_px_grp:=exec('PX_GRP','#to_string');
::             raportuje progress
               _argsprog.PROGLOC+=1;
               _argsprog.STRING:='Planowanie: '+PX_GRP.SYMBOL;

               _can_continue:=exec('plan_progress','px_logix',_argsprog,1);

               {? _can_continue>0
               || obj_del(_pxpack);
::                pobieram paczke technologiczna
                  _pxpack:=exec('trzepaczka','px_tex',PX_GRP.PX_TEX,PX_GRP.ILOSC,PX_GRP.ref());

                  _argsgrp.PX_GRP:=PX_GRP.ref();
                  obj_del(_argsgrp.PxPack);
                  _argsgrp.PxPack:=_pxpack;
::                uruchamiam algorytm planujacy
                  _can_continue:=exec('plan_grp','px_logix',_argsgrp).RESULT
               ?};
               PX_GRP.next() & _can_continue>0
            !}
         ?};
         {? _can_continue>0
         ||
::         Jeśli nic się nie wywaliło to czyszczę symbol grupy
            _current_px_grp:=''
         ?}
      ?};

::    -------------------- 10. Planowanie opoznien tryb 'PRZESUN' ---------------------
      {? _can_continue>0 & _delay_size>0
      || {? _delays_mode=exec('delays_move','px_param')
         || {? _argsprog.MODE=2
            || _argsprog.MULTI.next_phase()
            ?};
            _can_continue:=exec('delays_mode2','px_logix',_source,_args.DEST,_argsprog)
         ?}
      ?};

      {? _argsprog.MODE=2
      || _pxpoz_size:=exec('task_size_pxpoz','px_logix',_source);
         _argsprog.MULTI.next_phase();
         _argsprog.MULTI.ph_ssize(,_pxpoz_size)
      ?};

::    ponowne generowanie zapisow do planu zamowien dostaw
      {? _can_continue>0
      || exec('generuj_ver','px_sur',_args.DEST,_argsprog)
      ?};

::    oblokowuje wersje planu
      exec('unlock','px_ver',PX_VER.ref());

::    Odblokowywuje wszystkie zablokowane przepisy
      _tab:=_locked_tex.tab;
      _tab.cntx_psh();
      _tab.clear();
      _unlock_res:=exec('lock_result','px_tex');
      {? _tab.first()
      || {!
         |? {? var_pres('_alias')>100
            || obj_del(_alias)
            ?};
            _alias:=ref_tab(_tab.SQL);
            {? type_of(_alias)>100
            || _unlock_res.TAB:=2-!_alias
            || _unlock_res.TAB:=''
            ?};
            _unlock_res.NAME:=_tab.NAME;
            _unlock_res.REF:=_tab.REF;
            exec('unlock','px_tex',_unlock_res);
            _tab.next()
         !}
      ?};
      _tab.cntx_pop();

      {? _argsprog.MODE=1
      || FUN.prg_stop()
      |? _argsprog.MODE=2
      || exec('stop','#progress',_argsprog.MULTI)
      ?};

::    -------------------- 9. Czynnosci po planowaniu  ---------------------
      {? _can_continue>0
      ||
::       oznaczam wersje jako przeliczona
         PX_VER.STATUS:=exec('status_ready','px_ver');
         PX_VER.PROGRESS:=100;
         PX_VER.put();

::       oznaczam zadanie jako przeliczone
         exec('done','px_task',PX_VER.ref());

::       wykonuje formule wdrozeniowa, po przeliczeniu wersji planu
         exec('ver_processed','px_prepq',PX_VER.ref());

         _one_version:=exec('is_one_version','px_param');

::       pokazuje wygenerowany plan
::       zapamietuje biezace ustawienia okna - tablice ktora ma wszystkie tymczasowe tabelki i okna
         {? _args.VIEW_MODE=2
         ||

            {? var_pres('PxSelect')>100
            || _pxselect:=PxSelect
            || _pxselect:=exec('pxselect','px_plan')
            ?};

            _selres:=exec('select','px_plan' ,PX_VER.ref()
                                             ,
                                             ,_args.EDIT
                                             ,_args.CONTEXT
                                             ,_one_version);
::          przywracam poprzednie ustawienia okna - tablice ktora ma wszystkie tymczasowe tabelki i okna
            {? var_pres('_pxselect')>100
            || VAR_DEL.delete('PxSelect');
               PxSelect:=_pxselect
            ?};
            {? _selres>0
            ||
::             OKNO ZAMKNIETE sel_exit()
::             generuje nowa wersje tymczasowa do pokazywania w kolejce po to by od razu po zatwierdzeniu
::             moc od nowa modyfikowac kolejke - nie dotyczy symulacji zamowienia/zlecenia
               {? var_pres('PxSelect')>0
               || _ver_tmp:=exec('px_ver_temp','px_ver');

                  PxSelect.VER_QUE:=_ver_tmp;
                  PX_VAR.VER_QUE:=_ver_tmp;
                  {? var_pres('Pxgrp',PxSelect)>100
                  || exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp)
                  ?};

                  {? _one_version=0
                  ||
::                   blokuje ogladana wersje po to zeby mi jej ktos nie usunal przypadkiem
                     exec('lock','px_ver',_ver_tmp)
                  ?}
               ?};

               _start:=PX_VER.TM_START;
               {? _start>0
               ||
::                Odtwarzam zmienna PX_VAR.VIE_CUP, bo po akceptacji moze nie byc w wersji glownej pojemnika
::                na ktory wskazuje zmienna PX_VAR.VIE_CUP
                  _vie_date:=exec('tm_stamp2date','#tm_stamp',_start);
                  exec('go_cup_date','px_plan',_vie_date);
                  ~~
               ?}
            ||
::             OKNO ZAMKNIETE Z KRZYŻA LUB ESC
::             jesli zamknalem okno bez akceptacji to status wersji oznaczam z powrotem jako
::             tymczasowy gotowy do ponownego przeliczenia
               {? PX_VER.STATUS=exec('status_ready','px_ver')
               ||
                  PX_VER.STATUS:=exec('status_temp','px_ver');
                  PX_VER.PROGRESS:=0;
                  PX_VER.put();

::                elementom kolejki czyszcze powiazania po to aby moc je z powrotem usuwac
                  {? _args.CLEAN_Q>0
                  || exec('clean_queue','px_ver',PX_VER.ref(),0);

::                   Regeneruje widok kolejki
                     exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp)
                  ?};

                  {? _one_version=0
                  ||
::                   blokuje ogladana wersje po to zeby mi jej ktos nie usunal przypadkiem
                     exec('lock','px_ver',PX_VER.ref())
                  ?}
               ?}
            ?};
::          Odswiezam okno, bo widok mogl sie zmienic
            {? _args.CONTEXT='PX' & PxSelect.Context*'|MENU'=0
            ||
               exec('set_col_names','px_plan');
               grp_disp(PX_KONT,{? exec('tree_kont','px_param') || 'PX_WERT' || 'PX_WER' ?},1,1);
               grp_disp(PxSelect.Tab_OBJ.TAB,PxSelect.Tab_OBJ.WER,1,1);
               grp_disp(PxSelect.Tab_KONT.TAB,PxSelect.Tab_KONT.WER,1,1)
            ?};

::          generuje nowe zadanie do wyswietlenia w oknie z progressem przeliczenia
            exec('add','px_task',PX_VAR.VER_QUE)
         ?}
      ?}
   || _msg:='Nie udało się zablokować wersji planu.';
      pxkomm.error(_msg)
   ?};
   pxkomm.sect_end()
|| _msg:='Nie znaleziono wersji do zaplanowania.';
   pxkomm.error(_msg)
?};

{? _can_continue>0
|| _result:=1
|| _result:=0;

   {? _argsprog.MODE>0
   || {? _verified>0
      || {? _current_px_grp=''
         || FUN.info('Przeliczenie planu zakończone niepowodzeniem.'@)
         || FUN.info('Przeliczenie planu zakończone niepowodzeniem podczas planowania: %1.'@[_current_px_grp])
         ?}
      |? _verified=0
      || _msg:='Weryfikacja kolejki planu zakończona niepowodzeniem.\n'
               'Plan nie został przeliczony.'@;
         FUN.info(_msg)
      ?}
   ?};

:: przywracam status tymczasowy wersji docelowej
   exec('status_set','px_ver',_args.DEST,exec('status_temp','px_ver'),0);

   {? _argsprog.MODE>0 & exec('debug','px_logix')>0
   || KOMM.select()
   ?}
?};
pxkomm.sect_end();

exec('pxkomm_delete','px_logix');

:: nawijam tabelke PX_TASK - pozytywne zakonczenie w trybie nie-cichym zeruje progres
{? _args.VIEW_MODE>0 & _result>0
||
   PX_TASK.cntx_psh();
   PX_TASK.index('PX_VER');
   PX_TASK.prefix(_args.DEST);
   {? PX_TASK.first()
   ||
      PX_TASK.PROGRESS:=0;
      PX_TASK.put()
   ?};
   PX_TASK.cntx_pop()
?};

PX_GRP.cntx_pop();
PX_VER.cntx_pop();
PX_OBJ.cntx_pop();
_result


\plan_progress_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Tablica parametrow dla plan_progress
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PX_VER',
               'MODE',
               'STRING',
               'SIZEALL',
               'SIZELOC',
               'PROGALL',
               'PROGLOC',
               'PHASES',
               'PHASE',
               'MULTI',
               'ML_PHASE'
               );
_args.PX_VER:=null();
:: MODE=0 - tryb cichy, uaktualniam tylko procent przeliczenia na wersji
:: MODE=1 - tryb z progressem na ekranie [zwykly progress macroBASE]
:: MODE=2 - tryb z progressem na ekranie [multiprogress]
_args.MODE:=0;
_args.STRING:='';
_args.SIZEALL:=100;
_args.SIZELOC:=100;
_args.PROGALL:=0;
_args.PROGLOC:=0;
_args.PHASES:=1;
_args.PHASE:=1;
_args.MULTI:=exec('init','#progress');
_args.MULTI.HEIGHT:=30;
_args.MULTI.TITLE:='Przeliczanie planu'@;

_args


\plan_progress
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Raportuje progress przeliczania planu, w zaleznosci od trybu
::   WE: _a - _args  - argumenty funkcji wynik dzialania exec('plan_progress_a','px_logix')
::       [_b] - INTEGER - Multiprogress - o ile zwiekszyc progress podanego etapu
::       0 - user recznie przerwal progress
::       1 - progress moze byc kontynuowany
::----------------------------------------------------------------------------------------------------------------------
_args:={? _>=1 || _a || exec('plan_progress_a','px_logix') ?};

_ml_step:=1;
{? var_pres('_b')=type_of(0)
|| _ml_step:=_b
?};

_result:=1;
:: obliczam procent zaawansowania lokalny
_size:=_args.SIZELOC;
{? _size<=0 || _size:=1 ?};
_prc_loc:=_args.PROGLOC/_size*100;

:: obliczam procent zaawansowania globalny
_size:=_args.SIZEALL;
_phase_div:=(_args.PHASE-1)/_args.PHASES;
{? _size<=0 || _size:=1 ?};
_prc_global:=(_phase_div+(1/_args.PHASES*(_prc_loc/100)))*100;

:: pokazuje na ekran
{? _args.MODE=1
|| _krok:=_prc_global-_args.PROGALL;
   _result:=FUN.prg_next(_krok,_args.STRING)
|? _args.MODE=2
||
:: Multiprogress
:: _result:=exec('update','skid_prg',_args.MULTI)
   {? _ml_step>0
   || _result:=exec('next_step','#progress',_args.MULTI,,_ml_step)
   ?}
?};

_args.PROGALL:=_prc_global;

:: nawijam na wersje
PX_VER.cntx_psh();
PX_VER.clear();
{? PX_VER.seek(_args.PX_VER)
|| PX_VER.PROGRESS:=_prc_global;
   PX_VER.put()
?};
PX_VER.cntx_pop();

:: nawijam tabelke PX_TASK
PX_TASK.cntx_psh();
PX_TASK.index('PX_VER');
PX_TASK.prefix(_args.PX_VER);
{? PX_TASK.first()
||
   PX_TASK.PROGRESS:=_prc_global;
:: jesli tryb cichy to pole PX_TASK.BREAK steruje tym czy przerwac przetwarzanie planu
   {? _args.MODE=0
   || {? PX_TASK.BREAK='T'
      || _result:=0
      ?}
   ?};
   PX_TASK.put()
?};
PX_TASK.cntx_pop();
_result


\szatkownica_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Tablica parametrow dla szatkownica_row i szatkownica_seq
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PX_GRP',
               'DIR',
               'PX_KONT',
               'PX_STAGE'
               );
_args.PX_GRP:=null();
_args.DIR:=1;
_args.PX_KONT:=null();
_args.PX_STAGE:=null();
:: zwracamy deklaracje argumentow
_args


\szatkownica_row
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Szatkownica rownolegla
::   WE: _a - _args - wynik formuly exec('szatkownica_a','px_logix')
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_args:={?_=1 || _a || exec('szatkownica_a','px_logix') ?};

PX_POZ.cntx_psh();
PX_CONN.cntx_psh();

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};
_msg:='szatkownica_row\px_logix - szatkownica rownolegla';
pxkomm.sect_beg(_msg);

PX_CONN.index('PX_GRP');
{? _args.DIR>0
||
:: indeks rosnacy posortowany po PX_POZ.TM_START
   PX_POZ.index('GRPFORW')
||
:: indeks malejacy posortowany po PX_POZ.TM_END
   PX_POZ.index('GRPBACK')
?};

PX_POZ.prefix(_args.PX_GRP,_args.PX_KONT,_args.PX_STAGE,null());
{? PX_POZ.first()
|| {!
   |?
      _poz_src:=PX_POZ.ref();
      PX_CONN.prefix(_args.PX_GRP);
      _duration:=PX_POZ.TM_END-PX_POZ.TM_START;
      _poz_start:=PX_POZ.TM_START;
      _poz_end:=PX_POZ.TM_END;
::    _il_diff zostanie zainicjowane ilosciami PX_POZA oryginalnego, po czym bede odejmowal od nich
::    ilosci tworzonych PX_POZow, az na koncu pozostanie tutaj roznica wynikajaca z zaokraglen ktora
::    trzeba dodac do pierwszego lub ostatniego utworzonego PX_POZA szatkowego
      _il_wym:=PX_POZ.PX_KONT().IL_WYM;
      {? var_pres('_il_diff')>0
      || obj_del(_il_diff)
      ?};
      _il_diff:=obj_new(_il_wym);
      {! _it:=1.._il_wym
      |!  _rule:=$('PX_POZ.CAP_EAT'+$_it);
          _il_diff[_it]:=_rule()
      !};

      _last_added:=null();
      _last_end:=0;
::    inicjuje argumenty dla funkcji dodajacej PX_POZ
      {? var_pres('_argspoz')>0
      || obj_del(_argspoz)
      ?};
      _argspoz:=exec('blank_a','px_poz');
      exec('record2args','px_poz',_argspoz);
      {? PX_CONN.first()
      || _size:=PX_CONN.size();
         _index:=0;
         {!
         |? _index+=1;
            _div:=PX_CONN.ILOSC/PX_GRP.ILOSC;

            {? PX_VAR.NAST_ALG=2
            ||
               _argspoz.TM_START:=_poz_start;
               _argspoz.TM_END:=_poz_end;
::             Jeżeli następstwo operacji metodą proporcji czasowej, to trzeba
::             zadbać aby poszatkowane pozycje miały dobry czas startu i czas końca
               {? _index=1
               ||
::                Pierwszy element - modyfikuję tylko czas końca
                  _new_duration:=(_duration*_div)$1;
                  _argspoz.TM_END:=_poz_start+_new_duration
               |? _index=_size
               ||
::                Ostatni element - modyfikuję czas początku
                  _argspoz.TM_START:=_last_end
               ||
::                Środkowe elementy
                  _argspoz.TM_START:=_last_end;
                  _new_duration:=(_duration*_div)$1;
                  _argspoz.TM_END:=_argspoz.TM_START+_new_duration
               ?};
               _last_end:=_argspoz.TM_END;

               _argspoz.DATE_MIN:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_START);
               _argspoz.TIME_MIN:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_START);
               _argspoz.DATE_MAX:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_END);
               _argspoz.TIME_MAX:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_END);
               ~~
            ?};
::          obliczam ilosci nowego PX_POZa szatkowego proporcjonalnie w kazdym wymiarze
::          UWAGA!!! - od razu je zaokraglam do precyzji kontenera
            {! _it:=1.._il_wym
            |!  _rule:=$('_argspoz:=_a;_div:=_b;_ildiv:=PX_POZ.CAP_EAT'+$_it+'*_div$PX_POZ.PX_KONT().PREC'+$_it+';_ildiv');
               _ildiv:=_rule(_argspoz,_div);

::             przypisuje nowa ilosc do argumentow funkcji tworzacej PX_POZ
               _rule:=$('_argspoz:=_a;_il:=_b;_argspoz.CAP_EAT'+$_it+':=_il');
               _rule(_argspoz,_ildiv);

::             odejmuje ilosc PX_POZa szatkowego od ilosci PX_POZa oryginalnego
               _il_diff[_it]-=_ildiv
            !};

::          TWORZE PX_POZa szatkowego
            PX_POZ.cntx_psh();
            PX_POZ.clear();
            _argspoz.PX_OBJ:=PX_CONN.PX_OBJ;
            _can_continue:=exec('add','px_poz',_argspoz);
            {? _can_continue>0
            || _last_added:=PX_POZ.ref();

::             Klonuje komunikaty
               {? var_pres('_argskomm')>100
               || obj_del(_argskomm)
               ?};
               _argskomm:=exec('clone_a','px_komm');
               _argskomm.PX_VER:=PX_POZ.PX_VER;
               _argskomm.PX_GRP:=PX_POZ.PX_GRP;
               _argskomm.PX_OBJ:=PX_POZ.PX_OBJ;
               _argskomm.PX_CUP:=PX_POZ.PX_CUP;
               _argskomm.PX_POZ:=PX_POZ.ref();
               exec('clone_poz','px_komm',_poz_src,_argskomm)
            ?};
            PX_POZ.cntx_pop();
            PX_CONN.next() & _can_continue>0
         !}
      ?};

::    reszte z zaokraglen dodaje do ostatniego PX_POZa szatkowego
      {? _can_continue>0
      || PX_POZ.cntx_psh();
         PX_POZ.clear();
         {? PX_POZ.seek(_last_added)
         || {! _it:=1.._il_wym
            |! _rule:=$('_il_diff:=_a;PX_POZ.CAP_EAT'+$_it+'+=_il_diff['+$_it+']');
               _rule(_il_diff)
            !};
            _can_continue:=PX_POZ.put()
         ?};
         PX_POZ.cntx_pop()
      ?};

::    jesli udalo mi sie utworzyc px_pozy szatkowe to usuwam PX_POZA oryginalnego
      {? _can_continue>0
      || _can_continue:=exec('delete','px_poz',PX_POZ.ref(),0)
      ?};
      PX_POZ.first() & _can_continue>0
   !}
?};
pxkomm.sect_end();
PX_POZ.cntx_pop();
PX_CONN.cntx_pop();
~~


\szatkownica_seq
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Szatkownica sekwencyjna
::   WE: _a - _args - wynik formuly exec('szatkownica_a','px_logix')
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_args:={?_=1 || _a || exec('szatkownica_a','px_logix') ?};

_can_continue:=1;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

_msg:='szatkownica_seq\px_logix - szatkownica sekwencyjna';
pxkomm.sect_beg(_msg);

PX_POZ.cntx_psh();
PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');

PX_KONT.cntx_psh();
PX_KONT.clear();
{? _args.DIR>0
||
:: indeks rosnacy posortowany po PX_POZ.TM_START
   PX_POZ.index('GRPFORW')
||
:: indeks malejacy posortowany po PX_POZ.TM_END
   PX_POZ.index('GRPBACK')
?};

{? PX_KONT.seek(_args.PX_KONT)
||
   _il_wym:=PX_KONT.IL_WYM;
:: zbieram ilosci ze wszystkich pozycji planu nalezacych do danego kontenera i do danego obiektu grupujacego

   _il_all:=obj_new(_il_wym);

:: inicjuje _ilosci zerami
   {! _it:=1.._il_wym
   |! _il_all[_it]:=0
   !};

   _short_tpz:=0;
   _tpz:=obj_new(_il_wym);
   {! _it:=1.._il_wym
   |! _tpz[_it]:=0
   !};
   PX_STAGE.cntx_psh(); PX_STAGE.prefix();
   {? PX_STAGE.seek(_args.PX_STAGE)
   || {? PX_STAGE.TPZ>0
      ||
         _tpz_jm:=exec('get','#params',500380,type_of(''));

         {? _tpz_jm<>''
         || {! _it:=1.._il_wym
            |!
               _rule:=$('PX_KONT.JM'+$_it+'().KOD');
               {? _rule()=_tpz_jm
               || _tpz[_it]:=PX_STAGE.TPZ
               ?}
            !}
         ?}
      ?}
   ?};
   PX_STAGE.cntx_pop();

:: nawijam _ilosci z PX_POZow
   PX_POZ.prefix(_args.PX_GRP,_args.PX_KONT,_args.PX_STAGE,null());
   {? PX_POZ.first()
   ||
::    Sprawdzam czy można włączyć obsługę krótkich TPZtów
::    czyli takich, które trwają mniej niż pierwsza pozycja planu
::    Wtedy czas TPZta nie będzie szatkowany łącznie i nie będą powstawały ułamki
      {! _it:=1.._il_wym
      |!
         _rule:=$('PX_POZ.CAP_EAT'+$_it);
         {? _tpz[_it]>0 & _tpz[_it]<_rule()
         || _short_tpz:=1
         ?}
      !};
      {!
      |?
         {! _it:=1.._il_wym
         |!
            _rule:=$('PX_POZ.CAP_EAT'+$_it);
            _il_all[_it]+=_rule()
         !};
         PX_POZ.next()
      !}
   ?};

   {? _short_tpz>0
   ||
::    TPZta trzeba odjąc od sumy całości bo nie może brać udział w liczeniu proporcji
::    bo powstaną ułamki
      {! _it:=1.._il_wym
      |! _il_all[_it]-=_tpz[_it]
      !}
   ?};

:: w _il_diff bede trzymal roznice pomiedzy tym co bylo oryginalnie a tym co zostalo utworzone
:: w procesie szatkowania - ta roznice trzeba bedzie dodac do pierwszej lub ostatniej pozycji
:: planu poszatkowanej
   {? var_pres('_il_diff')>0
   || obj_del(_il_diff)
   ?};
   _il_diff:=obj_new(_il_wym);
   {! _it:=1.._il_wym
   |! _il_diff[_it]:=_il_all[_it];
      {? _short_tpz>0
      || _il_diff[_it]+=_tpz[_it]
      ?}
   !};
   _last_poz:=null();
   _last_end:=0;

   PX_CONN.prefix(_args.PX_GRP);
   {? {? _args.DIR>0
      || PX_CONN.first()
      || PX_CONN.last()
      ?}
   || _lp:=0;
      {!
      |?
         _lp+=1;
::       obliczam proporcje dla PX_CONNa
         _div_conn:=PX_CONN.ILOSC/PX_GRP.ILOSC;

::       w _il_nara bede trzymal narastajace ilosci na kolejnych px_pozach
         {? var_pres('_il_nara')>0
         || obj_del(_il_nara)
         ?};
         _il_nara:=obj_new(_il_wym);

::       obliczam ilosci jakie powinny byc na PX_POZach powiazanych z konkretnym PX_OBJ
::       ilosci te zaokraglam do precyzji kontenera - roznice zostana dodane do pierwszej lub
::       ostatniej pozycji planu powiazanej z tym PX_GRP
         {? var_pres('_il_conn')>0
         || obj_del(_il_conn)
         ?};
         _il_conn:=obj_new(_il_wym);

         {! _it:=1.._il_wym
         |! _rule:=$('_il_all:=_a;_div_conn:=_b;_il_all['+$_it+']*_div_conn$PX_KONT.PREC'+$_it);
            _il_conn[_it]:=_rule(_il_all,_div_conn);
            _il_nara[_it]:=0
         !};

         PX_POZ.prefix(_args.PX_GRP,_args.PX_KONT,_args.PX_STAGE,null());
         {? PX_POZ.first()
         ||
            {!
            |?
               {? var_pres('_argspoz')>100
               || obj_del(_argspoz)
               ?};
               _argspoz:=exec('blank_a','px_poz');
               exec('record2args','px_poz',_argspoz);
               _argspoz.DIR:=_args.DIR;
               _szast_prast:=0;
               _next_conn:=0;
               {? _last_end=0
               || _last_end:=PX_POZ.TM_START
               ?};

::             jesli narastajaca ilosc na px_pozach przekroczy ilosc dla px_conn to znak ze
::             albo trzeba zrobic szast prast i rozciac pozycje planu na dwa kawalki albo przejsc do
::             nastepnego px_conna
               {! _it:=1.._il_wym
               |! _pxpoz:=($('PX_POZ.CAP_EAT'+$_it))();
                  _il_nara[_it]+=_pxpoz;

                  {? _szast_prast=0 & _next_conn=0
                  ||
                     {? _il_nara[_it]>_il_conn[_it]
                     || _diff:=_il_nara[_it]-_il_conn[_it];
::                      jesli sie okazuje ze biezacego px_poza trzeba rozciac to robie szast prast
::                      w kazdym innym przypadku przechodze w petli do nastepnego px_conna
                        {? _diff<_pxpoz
                        || _szast_prast:=1
                        || _next_conn:=1
                        ?}
                     ?}
                  ?}
               !};

               {? _szast_prast>0
               ||
::                inicjuje tablice w ktorej bede trzymal ilosci w wymiarach dla poszatkowanej pozycji planu
                  {? var_pres('_il_new')>0
                  || obj_del(_il_new)
                  ?};
                  _il_new:=obj_new(_il_wym);
                  {! _it:=1.._il_wym
                  |! _il_new[_it]:=0
                  !};
::                1. Tworze nowego px_poza ktory bedzie powiazany z PX_OBJ w nastepnym przebiegu petli
::                nowy PX_POZ jest tworzony tylko wtedy, jesli w dziedzinie zostal wiecej niz jeden
::                PX_POZ. W przeciwnym razie nie wykonaloby sie powiazanie nowego PX_POZa z PX_OBJ
::                ktore jest robione w kolejnym przebiegu
::                  {? PX_POZ.size()>1
                  {? 1
                  ||
                     PX_POZ.cntx_psh();


::                   obliczam ilosci dla nowej pozycji planu
                     {! _it:=1.._il_wym
                     |! _il_new[_it]:=_il_nara[_it]-_il_conn[_it];

::                      Do pierwszej nowej pozycji planu odejmuję TPZta, którego muszę dodać na starą pozycję
::                      robię tu odjęcie, żeby sumarycznie nie przekroczyć tego co było oryginalnie na pozycji
                        {? _short_tpz>0 & _lp=1 & exec('array_sum','#array',_tpz)>0
                        || _il_new[_it]-=_tpz[_it]
                        ?};

                        _rule:=$('_argspoz:=_a;_il:=_b;_argspoz.CAP_EAT'+$_it+':=_il');
                        _rule(_argspoz,_il_new[_it])
                     !};

                     {? PX_VAR.NAST_ALG=2
                     ||
::                      Jeżeli następstwo operacji metodą proporcji czasowej, to trzeba
::                      zadbać aby poszatkowane pozycje miały dobry czas startu i czas końca
                        _duration:=_argspoz.TM_END-_argspoz.TM_START;
                        _argspoz.TM_START:=PX_POZ.PX_CUP().TM_START;
                        _div_time:=_il_new[1]/PX_POZ.CAP_EAT1;
                        _new_duration:=(_duration*_div_time)$1;
                        _argspoz.TM_END:=_argspoz.TM_START+_new_duration;

                        _argspoz.DATE_MIN:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_START);
                        _argspoz.TIME_MIN:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_START);
                        _argspoz.DATE_MAX:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_END);
                        _argspoz.TIME_MAX:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_END);
                        ~~
                     ?};

                     {? exec('array_sum','#array',_il_new)>0
                     || _can_continue:=exec('add','px_poz',_argspoz)
                     ?};
                     PX_POZ.cntx_pop()
                  ?};

::                2. Modyfikuje ilosc aktualnego px_poza i przypinam go do aktualnego PX_OBJ
                  {? _can_continue>0
                  || exec('record2args','px_poz',_argspoz);
                     PX_POZ.cntx_psh();
                     PX_POZ.clear();
                     {? var_pres('_il_mod')>0
                     || obj_del(_il_mod)
                     ?};
                     _il_mod:=obj_new(_il_wym);

                     _div_time:=1;

                     {! _it:=1.._il_wym
                     |! _rule:=$('_il_new:=_a;PX_POZ.CAP_EAT'+$_it+'-_il_new['+$_it+']');
                        _il_mod[_it]:=_rule(_il_new);

                        {? _it=1
                        || _div_time:=_il_mod[_it]/_argspoz.CAP_EAT1
                        ?};

                        _rule:=$('_argspoz:=_a;_il:=_b;_argspoz.CAP_EAT'+$_it+':=_il');
                        _rule(_argspoz,_il_mod[_it])
                     !};

::                   badam czy po modyfikacji ilosci px_poz nie bedzie sie nadawal do usuniecia
::                   jesli ilosci we wszystkich wymiarach beda zerowe to nalezy go usunac
                     _todel:=1;
                     {! _it:=1.._il_wym
                     |? _todel=1
                     |! _rule:=$('_argspoz:=_a;_result:=_argspoz.CAP_EAT'+$_it+'=0;_result');
                        _todel:=_rule(_argspoz)
                     !};
                     {? _todel=1
                     ||
::                      USUWAM PX_POZA z zerowymi ilosciami
                        _can_continue:=exec('delete','px_poz',PX_POZ.ref())
                     ||
::                      MODYFIKUJE PX_POZA
                        _argspoz.PX_OBJ:=PX_CONN.PX_OBJ;

                        {? PX_VAR.NAST_ALG=2
                        ||
::                         Jeżeli następstwo operacji metodą proporcji czasowej, to trzeba
::                         zadbać aby poszatkowane pozycje miały dobry czas startu i czas końca
                           _duration:=_argspoz.TM_END-_argspoz.TM_START;
                           _argspoz.TM_START:=_last_end;
                           _new_duration:=(_duration*_div_time)$1;
                           _argspoz.TM_END:=_argspoz.TM_START+_new_duration;

                           _last_end:=_argspoz.TM_END;

                           _argspoz.DATE_MIN:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_START);
                           _argspoz.TIME_MIN:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_START);
                           _argspoz.DATE_MAX:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_END);
                           _argspoz.TIME_MAX:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_END);
                           ~~
                        ?};
                        _can_continue:=exec('update','px_poz',_argspoz);

                        {? _can_continue>0
                        ||
::                         jesli sie udalo zmodyfikowac to pomniejszam ilosci ktore zostaly do przetrawienia
                           {! _it:=1.._il_wym
                           |! _rule:=$('_il_diff:=_a;_argspoz:=_b;_il_diff['+$_it+']-=_argspoz.CAP_EAT'+$_it);
                              _rule(_il_diff,_argspoz)
                           !}
                        ?}
                     ?};

                     PX_POZ.cntx_pop()
                  ?};
::                jesli szatkowanie przebieglo ok, to przestaje przetwarzac px_pozy i ide do nastepnego
::                px_conna
                  {? _can_continue>0
                  || _next_conn:=1
                  ?}
               || {? _next_conn=0
                  ||
::                   BEZ SZATKOWANIA POZYCJI - po prostu wiaze ja z aktualnym px_obj
                     PX_POZ.cntx_psh();
                     PX_POZ.clear();
                     _argspoz.PX_OBJ:=PX_CONN.PX_OBJ;
                     {? PX_VAR.NAST_ALG=2
                     ||
::                      Jeżeli następstwo operacji metodą proporcji czasowej, to trzeba
::                      zadbać aby poszatkowane pozycje miały dobry czas startu i czas końca
                        {? _last_end>0
                        ||
                           _duration:=_argspoz.TM_END-_argspoz.TM_START;
                           {? _argspoz.TM_START<>_last_end
                           ||
                              _argspoz.TM_START:=_last_end;
                              _argspoz.TM_END:=_argspoz.TM_START+_duration;
                              _argspoz.DATE_MIN:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_START);
                              _argspoz.TIME_MIN:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_START);
                              _argspoz.DATE_MAX:=exec('tm_stamp2date','#tm_stamp',_argspoz.TM_END);
                              _argspoz.TIME_MAX:=exec('tm_stamp2time','#tm_stamp',_argspoz.TM_END);
                              ~~
                           ?};
                           _last_end:=0;
                           ~~
                        ?}
                     ?};
                     _can_continue:=exec('update','px_poz',_argspoz);

                     {? _can_continue>0
                     ||
::                      jesli sie udalo zmodyfikowac to pomniejszam ilosci ktore zostaly do przetrawienia
                        {! _it:=1.._il_wym
                        |! _rule:=$('_il_diff:=_a;_il_diff['+$_it+']-=PX_POZ.CAP_EAT'+$_it);
                           _rule(_il_diff)
                        !}
                     ?};
                     PX_POZ.cntx_pop()
                  ?}
               ?};
               PX_POZ.first() & _next_conn=0 & _can_continue>0
            !}
         ?};
         {? _args.DIR>0
         || PX_CONN.next()
         || PX_CONN.prev()
         ?} & _can_continue>0
      !}
   ?};
:: do ostatniej lub pierwszej pozycji planu dodaje roznice ilosci ktora mogla wyniknac z zaokraglen
   _argskor:=exec('szatkorekta_a','px_logix');
   _argskor.PX_GRP:=_args.PX_GRP;
   _argskor.PX_KONT:=_args.PX_KONT;
   _argskor.PX_STAGE:=_args.PX_STAGE;
   obj_del(_argskor.IL_DIFF);
   _argskor.IL_DIFF:=_il_diff;
   _argskor.DIR:=_args.DIR;
   _argskor.IL_WYM:=PX_KONT.IL_WYM;
   exec('szatkorekta','px_logix',_argskor)
?};
pxkomm.sect_end();
PX_POZ.cntx_pop();
PX_CONN.cntx_pop();
PX_KONT.cntx_pop();
~~


\szatkorekta_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Tablica parametrow dla szatkorekta
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PX_GRP',
               'PX_KONT',
               'PX_STAGE',
               'IL_DIFF',
               'DIR',
               'IL_WYM');
_args.PX_GRP:=null();
_args.PX_KONT:=null();
_args.PX_STAGE:=null();
_args.IL_DIFF:=obj_new(1);
_args.DIR:=1;
_args.IL_WYM:=1;
:: zwracamy deklaracje argumentow
_args


\szatkorekta
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Korekta po dzialaniu szatkownicy rownoleglej - poniewaz pozycje planu sa zaokraglane, po przetworzeniu
::       wszystkich pozycji planu moze powstac roznica z ktora nalezy cos zrobic - dodac  na koniec lub na poczatek
::       Poniewaz roznica ta moze byc czasami bardzo duza i moze byc ujemna nalezy przewidziec ze spowoduje ona usuniecie
::       niektorych pozycji planu z poczatku lub konca
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_args:={?_=1 || _a || exec('szatkorekta_a','px_logix') ?};

PX_CONN.cntx_psh();
PX_POZ.cntx_psh();
{? _args.DIR>0
||
:: indeks rosnacy posortowany po PX_POZ.TM_START
   PX_POZ.index('GRPFORW')
||
:: indeks malejacy posortowany po PX_POZ.TM_END
   PX_POZ.index('GRPBACK')
?};
_il_wym:=_args.IL_WYM;

PX_CONN.prefix(_args.PX_GRP);
{? _args.DIR>0
|| {? PX_CONN.last()
   || PX_POZ.prefix(_args.PX_GRP,_args.PX_KONT,_args.PX_STAGE,PX_CONN.PX_OBJ);
      {? PX_POZ.last()
      || {? var_pres('_argspoz')>100
         || obj_del(_argspoz)
         ?};
         _argspoz:=exec('blank_a','px_poz');
         {!
         |?
            exec('record2args','px_poz',_argspoz);
            {! _it:=1.._il_wym
            |! _rule:=$('
                           _argspoz:=_a;
                           _il_diff:=_b;
                           _argspoz.CAP_EAT'+$_it+'+=_il_diff['+$_it+'];
                           {? _argspoz.CAP_EAT'+$_it+'<0
                           || _il_diff['+$_it+']:=(-1)*_argspoz.CAP_EAT'+$_it+';
                              _argspoz.CAP_EAT'+$_it+':=0
                           || _il_diff['+$_it+']:=0
                           ?}
                        ');
               _rule(_argspoz,_args.IL_DIFF)
            !};
::          sprawdzam czy pozycja planu kwalifikuje sie do usuniecia czy do poprawienia
            _todel:=1;
            {! _it:=1.._il_wym
            |? _todel=1
            |! _rule:=$('
                           _argspoz:=_a;
                           _res:=0;
                           {? _argspoz.CAP_EAT'+$_it+'=0
                           || _res:=1
                           ?};
                           _res
                        ');
               _todel:=_rule(_argspoz)
            !};
::          jesli trzeba usunac to oznaczam pozycje jako 'do usuniecia'
            {? _todel>0
            || _argspoz.STATUS:=exec('status_todel','px_poz');
               exec('update','px_poz',_argspoz)
            ||
               {? exec('update','px_poz',_argspoz)>0
               ||
::                po dodaniu roznicy ilosci, mogla sie zmienic zajeta pojemnosc kafelka - aktualizuje ja
                  PX_CUP.cntx_psh();
                  PX_CUP.clear();
                  {? PX_CUP.seek(PX_POZ.PX_CUP)
                  || exec('cup_cap','px_gen')
                  ?};
                  PX_CUP.cntx_pop()
               ?}
            ?};
            PX_POZ.prev()
         !}
      ?}
   ?}
|? _args.DIR<0
|| {? PX_CONN.first()
   || PX_POZ.prefix(_args.PX_GRP,_args.PX_KONT,_args.PX_STAGE,PX_CONN.PX_OBJ);
      {? PX_POZ.first()
      || {? var_pres('_argspoz')>100
         || obj_del(_argspoz)
         ?};
         _argspoz:=exec('blank_a','px_poz');
         {!
         |?
            exec('record2args','px_poz',_argspoz);
            {! _it:=1.._il_wym
            |! _rule:=$('
                           _argspoz:=_a;
                           _il_diff:=_b;
                           _argspoz.CAP_EAT'+$_it+'+=_il_diff['+$_it+'];
                           {? _argspoz.CAP_EAT'+$_it+'<0
                           || _il_diff['+$_it+']:=(-1)*_argspoz.CAP_EAT'+$_it+';
                              _argspoz.CAP_EAT'+$_it+':=0
                           || _il_diff['+$_it+']:=0
                           ?}
                        ');
               _rule(_argspoz,_args.IL_DIFF)
            !};
::          sprawdzam czy pozycja planu kwalifikuje sie do usuniecia czy do poprawienia
            _todel:=1;
            {! _it:=1.._il_wym
            |? _todel=1
            |! _rule:=$('
                           _argspoz:=_a;
                           _res:=0;
                           {? _argspoz.CAP_EAT'+$_it+'=0
                           || _res:=1
                           ?};
                           _res
                        ');
               _todel:=_rule(_argspoz)
            !};
::          jesli trzeba usunac to oznaczam pozycje jako 'do usuniecia'
            {? _todel>0
            || _argspoz.STATUS:=exec('status_todel','px_poz');
               exec('update','px_poz',_argspoz)
            ||
               {? exec('update','px_poz',_argspoz)>0
               ||
::                po dodaniu roznicy ilosci, mogla sie zmienic zajeta pojemnosc kafelka - aktualizuje ja
                  PX_CUP.cntx_psh();
                  PX_CUP.clear();
                  {? PX_CUP.seek(PX_POZ.PX_CUP)
                  || exec('cup_cap','px_gen')
                  ?};
                  PX_CUP.cntx_pop()
               ?}
            ?};
            PX_POZ.next()
         !}
      ?}
   ?}
?};
PX_POZ.index('STATUS2');
PX_POZ.prefix(_args.PX_GRP,_args.PX_KONT,_args.PX_STAGE,exec('status_todel','px_poz'));
{? PX_POZ.first()
|| {!
   |? exec('delete','px_poz',PX_POZ.ref());
      PX_POZ.first()
   !}
?};
PX_CONN.cntx_pop();
PX_POZ.cntx_pop();
~~


\pxkomm_init
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca tablice nazwana ktora jest interfejsem do obiektu KOMM - umozliwia zapis komunikatow gdy
::       funkcja exec('debug','px_logix') zwroci 1. Gdy debug=0 nie obciaza algorytmow planujacych niepotrzebnymi
::       operacjami
::   WY: obj_new() - tablica nazwana
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('pxkomm')>100
|| obj_del(pxkomm)
?};

:: deklaracje obiektow dla komentarzy
exec('JCQ_decl','#message');
{? var_pres('KOMM')<100 || KOMM:=obj_new(@.CLASS.JCQ) ?};

::KOMM.init(200,,'Algorytm planujący'@,'');

pxkomm:=obj_new(  'sect_beg',
                  'sect_end',
                  'error',
                  'info');
{? exec('debug','px_logix')>0
|| pxkomm.sect_beg:="KOMM.sect_beg(_a,,1)";
   pxkomm.sect_end:="KOMM.sect_end()";
   pxkomm.error:="KOMM.error(_a,0)";
   pxkomm.info:="KOMM.info(_a,0)"
|| pxkomm.sect_beg:="";
   pxkomm.sect_end:="";
   pxkomm.error:="";
   pxkomm.info:=""
?};
pxkomm


\pxkomm_delete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Usuwa interfejs do obiektu KOMM i usuwa z niego wszystkie komunikaty
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('pxkomm')>100
|| obj_del(pxkomm)
?};
KOMM.init(200,,'','');
~~


\debug
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca informacje czy wersja 'testowa' - czyli czy podczas planowania informacje o przebiegu ladowac do KOMM
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
0


\zkp_simulation
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Dla zamowien szybkie planowanie - okreslenie albo sprawdzenie terminu realizacji
::       KONTEKST PRACY: rekord ZK_N
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

:: Sprawdzam konfiguracje programu
{? ~exec('chk_sim','px_logix') || return(_result) ?};
exec('opernast_init','px_init');
PX_VER.cntx_psh();
ZK_N.cntx_psh();
ZK_P.cntx_psh();
ZK_P.index('NAG');

PX_VER.clear();
PX_VAR.VER_QUE:=null();
_can_continue:=1;

:: 1. Przygotowuje tymczasowa wersje planu do ktorej bede planowal
_ver_tmp:=exec('px_ver_temp','px_ver',0);
:: Sprawdzam czy mozna wykonac symulacje - czy na zamowieniu sa wyroby lub polprodukty
_ready:=0;
ZK_P.prefix(ZK_N.ref());
{? ZK_P.first()
|| {!
   |?
      {? 'PW'*ZK_P.M().R>0
      || _ready:=1
      ?};
      ZK_P.next()
   !}
?};

{? _ready>0
||
:: Ide dalej tylko jesli wersja nie zostala jeszcze zaplanowana (w przypadku akcji grupowej, kolejne
:: wywolania tej funkcji nie spelnia tego warunku, bo juz pierwsze wywolanie wykona cala symulacje)

:: deklaracje obiektow dla komunikatow
   exec('JCQ_decl','#message');
   {? var_pres('KOMM')<100 || KOMM:=obj_new(@.CLASS.JCQ) ?};
   KOMM.init(200,,'Symulacja zamówienia'@,'',,,0);
   _err:='Pozycje zamówienia pominięte w symulacji'@;
   _errS:='Z powodu rodzaju materiału (surowiec)'@;
   _errH:='Z powodu rodzaju materiału (wyrób zewnętrzny)'@;
   _errD:='Z powodu nieokreślenia zwrotu planowania'@;
   _errP:='Z powodu umieszczenia w planie'@;

   {? PX_VER.seek(_ver_tmp)
   ||
      {? PX_VER.STATUS=exec('status_temp','px_ver')
      ||
::       2. Przygotowuje 'kolejke' tymczasowa
::          Zawsze symuluje cale zamowienie - wszystkie pozycje

         _errlp:=KOMM.sect_beg('Przygotowywanie danych do symulacji planu.'@);

         _tab:=tab_tmp(1,'REF','INTEGER','#ZK_P.ref()');

         ZK_P.prefix(ZK_N.ref());
         {? ZK_P.first()
         ||
            {!
            |?
               _what:=$ZK_P.POZ+'. '+ZK_P.M().KTM+' '+ZK_P.M().N;
               _mainver:=exec('get_mainversion','px_ver');
               _planwpp:=exec('zkp_planned','px_obj',ZK_P.ref(),_mainver);
               {? _planwpp>0
               || _can_continue:=0;
                  _msg:='Nie można symulować: %1. Powód: obiekt znajduje się już w planie.'@[_what];
                  KOMM.add(_msg,'xwin16.png:2')
               |? ZK_P.M().RODZ='U'
               || _can_continue:=0;
                  _msg:='Nie można symulować: %1. Powód: indeks materiałowy to usługa.'@[_what];
                  KOMM.add(_msg,'xwin16.png:2')
               |? 'PW'*ZK_P.M().R>0
               || _tab.REF:=#ZK_P.ref();
                  _tab.add();

                  _ilz:=ZK_P.ILZ;
                  _il_to_plan:=ZK_P.ILZ;
                  ZLZAM.index('ZMZL');
                  ZLZAM.prefix($ZK_P.ref());
                  {? ZLZAM.first()
                  ||
                     {!
                     |?
                        {? ZLZAM.ZL<>null()
                        || ZL.cntx_psh();
                           PX_OBJ.cntx_psh();
                           PX_OBJ.index('ZL');
                           ZL.clear();
                           {? ZL.seek(ZLZAM.ZL)
                           || _can_continue:=exec('zl2obj','px_obj');
                              PX_OBJ.prefix(ZL.ref());
                              {? _can_continue>0 & PX_OBJ.first()
                              ||
::                               Weryfikuję ilość w kolejce głównej
                                 _il_que:=exec('get_ilosc_que','px_obj',exec('get_mainversion','px_ver'),PX_OBJ.ref());
                                 _il_to_plan-=_il_que;
                                 {? _il_que>0 & _il_que>=PX_OBJ.IL
                                 || _can_continue:=0;
                                    _txt:='Na podstawie: %1 utworzono już zlecenia produkcyjne które są w planie.'@[_what];
                                    KOMM.add(_txt,14)
                                 ?}
                              ?}
                           ?};
                           PX_OBJ.cntx_pop();
                           ZL.cntx_pop()
                        ?};

                        _ilz-=ZLZAM.ILZL;
                        {? _can_continue>0
                        ||
                           _prep_ok:=exec('zl_prepare','px_logix',ZLZAM.ZL,_ver_tmp,ZK_P.PL_DIR);
                           {? _prep_ok=0
                           || _can_continue:=0
                           ?}
                        ?};

                        ZLZAM.next()
                     !}
                  ?};
                  {? _ilz>0
                  ||
                     _prep_ok:=exec('zkp_prepare','px_logix',ZK_P.ref(),_ver_tmp,_ilz,ZK_P.PL_DIR);
                     {? _prep_ok=0
                     || _can_continue:=0
                     ?}
                  || {? _il_to_plan>0
                     || _can_continue:=0;
                        _msg:='Na podstawie: %1 utworzono zlecenia produkcyjne na całą ilość. Symulowane będą te zlecenia.'@[_what];
                        KOMM.add(_msg,'xwin16.png:2')
                     ?}
                  ?}
               |? 'S'*ZK_P.M().R
               || _can_continue:=0;
                  _msg:='Nie można symulować: %1. Powód: rodzaj materiału obiektu to surowiec.'@[_what];
                  KOMM.add(_msg,'xwin16.png:2')
               |? 'H'*ZK_P.M().R
               || _can_continue:=0;
                  _msg:='Nie można symulować: %1. Powód: rodzaj materiału obiektu to wyrób zewnętrzny.'@[_what];
                  KOMM.add(_msg,'xwin16.png:2')
               ?};
               ZK_P.next()
            !}
         ?};

         KOMM.sect_end();

::       Jesli nie bylo problemow to usuwam galaz komunikatow
         {? _can_continue>0
         || KOMM.del(_errlp)
         ?};

::       Sprawdzam czy symulowana wersja zawiera jakies grupy, jesli tak to kontynuuje, jesli nie przerywam
         PX_GRP.cntx_psh();
         PX_GRP.index('LP');
         PX_GRP.prefix(_ver_tmp,'Z');
         {? PX_GRP.size()>0
         || _can_continue:=1
         || _can_continue:=0
         ?};
         PX_GRP.cntx_pop();

::       3. URUCHAMIAM ALGORYTM PLANUJACY
         {? _can_continue>0
         ||
::          Pokazuje KOMMa z wykluczeniami
            KOMM.select();
            _choice:=FUN.choice(
                  'Wyświetlanie symulacji.\n'
                  'Dostępne opcje widoku:'@+'\n\n'
                  '● '+'Widok szczegółowy — całość\n'
                  '  (pełny widok planu wraz z innymi zamówieniami, zleceniami)'@+'\n\n'
                  '● '+'Widok szczegółowy — symulacja\n'
                  '  (pełny widok planu, ale tylko z symulowanym zamówieniem)'@+'\n\n'
                  '● '+'Bez widoku szczegółowego\n'
                  '  (symulacja planu możliwa do podglądu w dolnej części okna)'@+'\n\n'@,,
                  'Szczegóły — &całość'@,'Szczegóły — &symulacja'@,'&Bez szczegółów'@
               );
            {? _choice>0
            ||
               _opt_view:=1;
               _opt_clone:=0;
               {? _choice=1
               || _opt_view:=2;
                  _opt_clone:=2
               |? _choice=2
               || _opt_view:=2;
                  _opt_clone:=0
               |? _choice=3
               || _opt_view:=1;
                  _opt_clone:=0
               ?};
               _argsplan:=exec('px_ver_plan_a','px_logix');
               _argsplan.DEST:=_ver_tmp;
               _argsplan.VIEW_MODE:=_opt_view;
               _argsplan.CLONE_MODE:=_opt_clone;
               _argsplan.EDIT:=0;
               _argsplan.CLEAN_Q:=0;
               {? PX_VAR.NAST_ALG=2
               || _argsplan.UPDATE_Q:=1
               || _argsplan.UPDATE_Q:=0
               ?};
               _argsplan.VERIFY_Q:=0;
               _argsplan.CONTEXT:='ZAM';
               _result:=exec('px_ver_plan','px_logix',_argsplan);

               {? _result=0
               ||
::                  FUN.emsg('Symulacja planu zakończona niepowodzeniem.')
                  ~~
               ||
::                po wykonaniu symulacji zmieniam status wersji
                  exec('status_set','px_ver',_ver_tmp,exec('status_sim_zkp','px_ver'));

::                po wykonaniu symulacji ustawiam zmienna PX_VAR.VIE_VER, wg ktorej bedzie odswiezone okno z planem
                  PX_VAR.VIE_VER:=_ver_tmp;

::                wyswietlenie i potwierdzenie terminu/terminow realizacji zamowienia/pozycji zamowienia
                  exec('terminy_zkn','px_plan',_ver_tmp,_tab)
               ?}
            ?}
         || KOMM.add('Przygotowanie symulacji zakończone niepowodzeniem.'@,2,,1);
            KOMM.select()
         ?}
      ?}
   ?}
|| FUN.emsg('Zamówienie nie zawiera ani wyrobów, ani półfabrykatów, aby przygotować symulację.'@)
?};
{? _result=0
||
   {? exec('is_one_version','px_param')>0
   ||
::    Jeśli praca na jednej wersji i zymulacja zakonczona niepowodzeniem to usuwam tą symulowaną wersję
      {? _ver_tmp<>null()
      || {? exec('delete','px_ver',_ver_tmp,0)=0
         || FUN.emsg('Usunięcie symulacji planu zamówienia zakończone niepowodzeniem.'@)
         ?}
      ?}
   ?}
?};

VAR_DEL.delete('PxSelect');
PX_VER.cntx_pop();
ZK_P.cntx_pop();
ZK_N.cntx_pop();
_result


\zkp_sim_grp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Symulacja planu dla zamówienia - akcja grupa przed w tabeli tymczasowej XPLAN
::----------------------------------------------------------------------------------------------------------------------
PX_VAR.VER_TMP:=exec('px_ver_temp','px_ver',0);
~~


\zkp_prepare
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Tworzy obiekty planowane, obiekty grupujace i polaczenia grupujace na podstawie pozycji zamowienia
::   WE: _a - ZK_P.ref()
::       _b - PX_VER.ref() - wersja docelowa
::       _c - ilosc jaka utworzyc na PX_GRP
::       _d - kierunek planowania (-1) wstecz od terminu realizacji (domyslnie), (1) do przodu od dzis
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_zkp:=_a;
_ver:=_b;
_ilosc:=_c;
{? var_pres('_d')=type_of(0) || _dir:=_d || _dir:=-1 ?};

exec('trigger_on','px_grp');
::_ver_que:=PX_VAR.VER_QUE;
::PX_VAR.VER_QUE:=null();
PX_OBJ.cntx_psh();
PX_GRP.cntx_psh();
PX_CONN.cntx_psh();
PX_VER.cntx_psh();
ZK_P.cntx_psh();

PX_GRP.clear();
PX_VER.clear();
ZK_P.clear();

PX_OBJ.index('ZK_P');

_can_continue:=1;
_result:=0;

{? ZK_P.seek(_zkp) & PX_VER.seek(_ver)
||
:: 1. Tworze obiekt planowany, jesli jeszcze takiego nie ma
   _can_continue:=exec('zkp2obj','px_obj');

:: 2. Tworze obiekt grupujacy i polaczenie grupujace - w buforze mam utworzony wlasnie PX_OBJ
   {? _can_continue>0
   || PX_OBJ.prefix(ref_name(ZK_P.ref()),ZK_P.ref());
      {? PX_OBJ.first()
      ||
         {? _can_continue>0
         ||
::          Sprawdzam czy obiekt ma ustawiony domyślny zwrot planowania
            {? PX_OBJ.DIR=0
            || _msg:='Nie można symulować: %1. Obiekt nie posiada domyślnego zwrotu planowania.'@[PX_OBJ.SYMBOL];
               KOMM.add(_msg,'xwin16.png:2');
               _can_continue:=0
            ?}
         ?};

         {? _can_continue>0
         ||
            {? PX_OBJ.DIR<0 & PX_OBJ.TM_REA<PX_OBJ.tm_stamp()
            || _msg:='Nie można symulować: %1. Obiekt jest planowany wstecz i ma termin realizacji w przeszłości.'@[PX_OBJ.SYMBOL];
               KOMM.add(_msg,'xwin16.png:2');
               _can_continue:=0
            ?}
         ?};

         {? _can_continue>0
         ||
            _argsgrp:=exec('blank_a','px_grp');
            _argsgrp.PX_VER:=PX_VER.ref();
            _argsgrp.SYMBOL:=PX_OBJ.SYMBOL;
            _argsgrp.NAZWA:=PX_OBJ.NAZWA;
            _argsgrp.ILOSC:=_ilosc;
            _px_tex:=exec('get_default_tex','px_tex',PX_OBJ.ref());
            {? _px_tex<>null()
            ||
::             Znalazlem domyslny przepis - sprawdzam czy mozna go uzyc do symulacji
               {? exec('is_empty','px_tex',_px_tex)>0
               || _msg:='Nie można symulować: %1. Domyślny przepis planistyczny obiektu jest pusty (nie zawiera etapów).'@[PX_OBJ.SYMBOL];
                  KOMM.add(_msg,'xwin16.png:2');
                  _can_continue:=0
               ?};
               {? _can_continue>0
               ||
::                Weryfikuje przepis
                  _verify:=exec('verify','px_tex',_px_tex,_argsgrp.ILOSC);
                  {? _verify<>''
                  || _msg:='Nie można symulować: %1. Weryfikacja przepisu planistycznego zakończona niepowodzeniem.'@[PX_OBJ.SYMBOL];
                     _msg+=' '+'Powód: %1.'@[_verify];
                     KOMM.add(_msg,'xwin16.png:2');
                     _can_continue:=0
                  ?}
               ?};
               {? _can_continue>0
               || _argsgrp.PX_TEX:=_px_tex
               ?}
            ||
               _msg:='Nie można symulować: %1. Nie znaleziono żadnego przepisu planistycznego, który mógłby być użyty w symulacji.'@[PX_OBJ.SYMBOL];
               KOMM.add(_msg,'xwin16.png:2');
               _can_continue:=0
            ?};

            {? _can_continue>0
            ||
               {? PX_OBJ.DIR=-1
               || _argsgrp.DIR:=PX_OBJ.DIR;
                  _argsgrp.STARTD:=date();
                  _argsgrp.STARTT:=time();
                  _argsgrp.ENDD:=ZK_P.PL_DATA;
                  _argsgrp.ENDT:=ZK_P.PL_TIME
               |? PX_OBJ.DIR>0
               || _argsgrp.DIR:=PX_OBJ.DIR;
                  _argsgrp.STARTD:=date();
                  _argsgrp.STARTT:=time();
                  _argsgrp.ENDD:=date(0,0,0);
                  _argsgrp.ENDT:=time(0,0,0)
               ?};
               _can_continue:=exec('add','px_grp',_argsgrp,PX_OBJ.ref())
            ?}
         ?}
      ?}
   ?}
?};

{? _can_continue>0
|| _result:=1
?};
::PX_VAR.VER_QUE:=_ver_que;
ZK_P.cntx_pop();
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
PX_OBJ.cntx_pop();
PX_VER.cntx_pop();
_result


\delays_mode1
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Planuje opoznienia metoda kulturalna ze zrodlowej wersji planu do docelowej
::   WE: _a - PX_VER.ref() - zrodlowa wersja planu
::       _b - PX_VER.ref() - docelowa wersja planu
::       [_c] - obj_new - obiekt pokazujacy progress
::       [_d] - INTEGER - [0]/1 - czy utworzyc czas poczatku planu na podstawie paczki i czasu
::                                aktualnego
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_source:=_a;
_dest:=_b;
_argsprog:={? _>=3 || _c || exec('plan_progress_a','px_logix') ?};

_zero_create:=0;
{? var_pres('_d')=type_of(0)
|| _zero_create:=_d
?};

_result:=0;
_can_continue:=1;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

_msg:='delays_mode1\px_logix - Planowanie opóźnień';
pxkomm.sect_beg(_msg);

PX_VER.cntx_psh();
PX_GRP.cntx_psh();
PX_VER.clear();
PX_GRP.clear();
{? PX_VER.seek(_source)
|| PX_GRP.index('STATUS');
   PX_GRP.prefix(_source,exec('status_delay','px_grp'));
   {? PX_GRP.first()
   || {!
      |?
         _grp_src:=PX_GRP.ref();
         _uid_src:=PX_GRP.UID;
         _grp_dst:=null();

         {? PX_GRP.PX_VER<>_dest
         ||
::          szukam w docelowej wersji takiego samego obiektu grupujacego do ktorego przypne pozycje planu
::          ktore powstaly z opoznien
            PX_GRP.cntx_psh();
            PX_GRP.index('UID_SRC');
            PX_GRP.prefix(_dest,_uid_src);
            {? PX_GRP.first()
            || _grp_dst:=PX_GRP.ref()
            ?};
            PX_GRP.cntx_pop()
         || _grp_dst:=PX_GRP.ref()
         ?};

         {? _grp_dst<>null()
         ||
            {? var_pres('_pxpack')>0
            || obj_del(_pxpack)
            ?};
            _pxpack:=exec('PxPack_declare','px_tex');

            exec('pck_delays','px_whisk',_pxpack,_grp_src,_grp_dst);
::          Planuje tylko jesli paczka zawiera jakies ilosci do zaplanowania
            {? exec('pck_not_empty','px_tex',_pxpack.Paczka)>0
            ||
::             pokazuje paczke opoznieniowa
::             exec('paczka_select','px_tex',_pxpack);

               {? var_pres('_argsgrp')>100
               || obj_del(_argsgrp)
               ?};
               _argsgrp:=exec('plan_grp_a','px_logix');
               _argsgrp.VER_DST:=_dest;
               _argsgrp.PX_GRP:=_grp_dst;
               obj_del(_argsgrp.PxPack);
               _argsgrp.PxPack:=_pxpack;
               _argsgrp.KOR_DLAY:=0;
               _argsgrp.KOR_WYK1:=0;
               _argsgrp.KOR_WYK2:=0;
               _argsgrp.KOR_BLK:=0;
               _argsgrp.KOR_SKIP:=0;
               _argsgrp.KOR_TODAY:=0;
               _argsgrp.STATUS:=exec('status_todelay','px_poz');
               {? _zero_create>0
               || _argsgrp.TM_ZERO:=exec('round_start_pck','px_tex',_pxpack.Paczka)
               ?};
               {? exec('is_one_version','px_param')>0
               ||
::                Jesli praca na jednej wersji to po uzyskaniu paczki opoznieniowej
::                usuwam istniejace pozycje opoznione zeby ich nie powielac
                  PX_POZ.cntx_psh();
                  PX_POZ.index('STATUS3');
                  PX_POZ.prefix(_grp_dst,exec('status_delay','px_poz'));
                  {? PX_POZ.first()
                  || {!
                     |? _can_continue:=exec('delete','px_poz',PX_POZ.ref(),,0);
                        PX_POZ.first() & _can_continue>0
                     !}
                  ?};
                  PX_POZ.cntx_pop()
               ?};

::             planowanie opoznien
               _msg:='planowanie opóźnień dla obiektu grupującego: '+PX_GRP.SYMBOL;
               pxkomm.sect_beg(_msg);

               _can_continue:=exec('plan_grp','px_logix',_argsgrp).RESULT;
               {? _can_continue=0
               || _msg:='Planowanie opóźnień zakończone niepowodzeniem';
                  pxkomm.error(_msg)
               ?};
               pxkomm.sect_end();

::             po utworzeniu pozycji planu z opoznien nadaje im status opozniony
               PX_POZ.cntx_psh();
               PX_POZ.index('TM_GRP');
               PX_POZ.prefix(_grp_dst);
               {? PX_POZ.first()
               || {!
                  |?
::                   zmieniam status na opozniony tylko pozycjom 'normalnym' i niezablokowanym
                     {? PX_POZ.STATUS=exec('status_todelay','px_poz') & PX_POZ.BLK='N' & PX_POZ.SRC_OPER<>'T'
                     || exec('status_set','px_poz',PX_POZ.ref(),exec('status_delay','px_poz'))
                     ?};
                     PX_POZ.next()
                  !}
               ?};
               PX_POZ.cntx_pop()
            ?};
::          Aktualizuje status grupy
            exec('status_rebuild','px_grp',_grp_dst);

::          raportuje progress
            {? _can_continue>0
            || _can_continue:=exec('plan_progress','px_logix',_argsprog,1)
            ?};
            PX_GRP.next() & _can_continue>0
         ?}
      !}
   ?}
|| _msg:='Nie znaleziono wersji źródłowej.';
   pxkomm.error(_msg)
?};
{? _can_continue>0
|| _result:=1
?};
pxkomm.sect_end();

PX_GRP.cntx_pop();
PX_VER.cntx_pop();
_result


\delays_mode2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Planuje opoznienia metoda brutalna ze zrodlowej wersji planu do docelowej
::   WE: _a - PX_VER.ref() - zrodlowa wersja planu
::       _b - PX_VER.ref() - docelowa wersja planu
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_source:=_a;
_dest:=_b;
_argsprog:={?_>=3 || _c || exec('plan_progress_a','px_logix') ?};

_result:=0;
_can_continue:=1;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

PX_VER.cntx_psh();
PX_GRP.cntx_psh();
PX_CUP.cntx_psh();
PX_CUP.index('TM_START');
PX_POZ.cntx_psh();

PX_VER.clear();
PX_GRP.clear();

PX_POZ.index('STATUS3');
_msg:='delays_mode1\px_logix - Planowanie opóźnień';
pxkomm.sect_beg(_msg);
{? PX_VER.seek(_source)
|| PX_GRP.index('STATUS');
   PX_GRP.prefix(_source,exec('status_delay','px_grp'));
   _argsclone:=exec('clone_a','px_poz');
   _ref_table:=exec('ref_table','#table');
   {? PX_GRP.first()
   ||
      {!
      |?
         _grp_src:=PX_GRP.ref();
         _uid_src:=PX_GRP.UID;
         _grp_dst:=null();

         {? PX_GRP.PX_VER<>_dest
         ||
::          szukam w docelowej wersji takiego samego obiektu grupujacego do ktorego przypne pozycje planu
::          ktore powstaly z opoznien
            PX_GRP.cntx_psh();
            PX_GRP.index('UID_SRC');
            PX_GRP.prefix(_dest,_uid_src);
            {? PX_GRP.first()
            || _grp_dst:=PX_GRP.ref()
            ?};
            PX_GRP.cntx_pop()
         || _grp_dst:=PX_GRP.ref()
         ?};

         {? _grp_dst<>null()
         ||
            PX_POZ.prefix(PX_GRP.ref(),exec('status_delay','px_poz'));
            _one_ver:=exec('is_one_version','px_param');
            {? PX_POZ.first()
            ||
               {!
               |?
                  _nxt_poz:=null();
::                Znajduje nastepna pozycje planu na ktora przejsc pod koniec petli
::                poniewaz w trakcie przesuwania, klonowania moze zmienic sie kolejnosc
::                rekordow i zostanie przesuniety np co drugi rekord
                  PX_POZ.cntx_psh();
                  {? PX_POZ.next()>0
                  || _nxt_poz:=PX_POZ.ref()
                  ?};
                  PX_POZ.cntx_pop();

::                Sprawdzam czy juz przerabialem taka pozycje planu
                  {? _ref_table.r_find(PX_POZ.ref())=0
                  || _ref_table.r_add(PX_POZ.ref());
                     {? _one_ver>0
                     || _tm_now:=PX_POZ.tm_stamp();
                        _mode:='START';
                        _tm_start:=exec('round_time','px_kont',PX_POZ.PX_KONT,_tm_now,_mode);
                        PX_CUP.cntx_psh();
                        {? exec('first_cup','px_logix',_tm_start,1)>0
                        ||
                           _poz_moved:=exec('move','px_poz',PX_POZ.ref(),PX_CUP.ref(),,0);
                           {? _poz_moved<>null()
                           || _can_continue:=1
                           || _can_continue:=0
                           ?}
                        || _can_continue:=0
                        ?};
                        PX_CUP.cntx_pop();
                        ~~
                     ||
::                      szukam pierwszego pojemnika od teraz w planowanej wersji
                        PX_KONT.cntx_psh();
                        PX_KONT.index('ACT');
                        PX_KONT.prefix('T',_dest,PX_POZ.PX_KONT().SYMBOL,);
                        {? PX_KONT.first()
                        ||
                           PX_CUP.prefix(PX_KONT.ref());
                           {? PX_CUP.first()
                           ||
                              _argsclone.SOURCE:=PX_POZ.ref;
                              _argsclone.PX_VER:=_dest;
                              _argsclone.PX_GRP:=_grp_dst;
                              _argsclone.PX_CUP:=PX_CUP.ref();
                              _argsclone.PX_KONT:=PX_KONT.ref();

                              _can_continue:=exec('clone','px_poz',_argsclone);
                              {? _can_continue>0
                              ||
::                               po sklonowaniu wywoluje formule po wlaniu na pojemniku
                                 {? var_pres('_argspoz')>100
                                 || obj_del(_argspoz)
                                 ?};
                                 _argspoz:=exec('blank_a','px_poz');
                                 exec('record2args','px_poz',_argspoz);
                                 exec('po_wlaniu','px_logix',PX_CUP.ref(),_argspoz)
                              || _msg:='Nie udalo sie klonowanie opóźnionej pozycji planu: '+$PX_POZ.ref();
                                 pxkomm.error(_msg)
                              ?}
                           || _msg:='Nie znaleziono nowego domku dla opóźnionej pozycji planu: '+$PX_POZ.ref();
                              pxkomm.error(_msg)
                           ?}
                        ?};
                        PX_KONT.cntx_pop()
                     ?}
                  ?};
                  _next:=0;
                  {? _nxt_poz<>null()
                  || _next:=PX_POZ.seek(_nxt_poz)
                  || _next:=0
                  ?};
                  _next>0 & _can_continue>0
               !}
            ?}
         ?};
::       Aktualizuje status grupy
         exec('status_rebuild','px_grp',_grp_dst);

::       raportuje progress
         {? _can_continue>0
         || _can_continue:=exec('plan_progress','px_logix',_argsprog,1)
         ?};
         PX_GRP.next() & _can_continue>0
      !}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
pxkomm.sect_end();

PX_POZ.cntx_pop();
PX_CUP.cntx_pop();
PX_GRP.cntx_pop();
PX_VER.cntx_pop();
_result


\zl_simulation
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Symulacja zlecenia
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(1,'REF','INTEGER','#Zl.ref()');
_tab.REF:=#VAR.A_ZLEC;
_tab.add();
exec('zl_simulation_core','px_logix',_tab);
VAR_DEL.delete('PxSelect');
~~


\zl_prepare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Tworzy obiekty planowane, obiekty grupujace i polaczenia grupujace na podstawie zlecen
::   WE: _a - ZL.ref()
::       _b - PX_VER.ref() - wersja docelowa
::       _c - kierunek planowania (-1) wstecz od terminu realizacji (domyslnie), (1) do przodu od dzis
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_zl:=_a;
_ver:=_b;
{? var_pres('_c')=type_of(0)
|| _dir:=_c
|| _dir:=-1
?};

exec('trigger_on','px_grp');
::_ver_que:=PX_VAR.VER_QUE;
::PX_VAR.VER_QUE:=null();

PX_OBJ.cntx_psh();
PX_GRP.cntx_psh();
PX_CONN.cntx_psh();
PX_VER.cntx_psh();
ZL.cntx_psh();

PX_GRP.clear();
PX_VER.clear();
ZL.clear();

PX_OBJ.index('ZL');
_grps:=exec('ref_table','#table');
_can_continue:=1;
_result:=0;

{? ZL.seek(_zl) & PX_VER.seek(_ver)
||
:: 1. Tworze obiekt planowany, jesli jeszcze takiego nie ma
   _can_continue:=exec('zl2obj','px_obj');

:: 2. Tworze obiekt grupujacy i polaczenie grupujace - w buforze mam utworzony wlasnie PX_OBJ
   {? _can_continue>0
   || PX_OBJ.prefix(ZL.ref());
      {? PX_OBJ.first()
      ||
         {? _can_continue>0
         ||
::          Sprawdzam czy obiekt ma ustawiony domyślny zwrot planowania
            {? PX_OBJ.DIR=0
            || _msg:='Nie można symulować: %1. Obiekt nie posiada domyślnego zwrotu planowania.'@[PX_OBJ.SYMBOL];
               KOMM.add(_msg,'xwin16.png:2');
               _can_continue:=0
            ?}
         ?};

         {? _can_continue>0
         ||
            {? PX_OBJ.DIR<0 & PX_OBJ.TM_REA<PX_OBJ.tm_stamp()
            || _msg:='Nie można symulować: %1. Obiekt jest planowany wstecz i ma termin realizacji w przeszłości.'@[PX_OBJ.SYMBOL];
               KOMM.add(_msg,'xwin16.png:2');
               _can_continue:=0
            ?}
         ?};

         {? _can_continue>0
         ||
            _argsgrp:=exec('blank_a','px_grp');
            _argsgrp.PX_VER:=PX_VER.ref();
            _argsgrp.SYMBOL:=PX_OBJ.SYMBOL;
            _argsgrp.NAZWA:=PX_OBJ.NAZWA;
            _argsgrp.ILOSC:=PX_OBJ.IL;
            _px_tex:=exec('get_default_tex','px_tex',PX_OBJ.ref());
            {? _px_tex<>null()
            ||
::             Znalazlem domyslny przepis - sprawdzam czy mozna go uzyc do symulacji
               {? exec('is_empty','px_tex',_px_tex)>0
               || _msg:='Nie można symulować: %1. Domyślny przepis planistyczny obiektu '
                        'jest pusty (nie zawiera etapów).'@[PX_OBJ.SYMBOL];
                  KOMM.add(_msg,'xwin16.png:2');
                  _can_continue:=0
               ?};
               {? _can_continue>0
               ||
::                Weryfikuje przepis
                  _verify:=exec('verify','px_tex',_px_tex,_argsgrp.ILOSC);
                  {? _verify<>''
                  || _msg:='Nie można symulować: %1. Weryfikacja przepisu planistycznego '
                           'zakończona niepowodzeniem.'@[PX_OBJ.SYMBOL];
                     _msg+=' '+'Powód: %1.'@[_verify];
                     KOMM.add(_msg,'xwin16.png:2');
                     _can_continue:=0
                  ?}
               ?};

               {? _can_continue>0
               || _verify:=exec('verifycoop','px_tex',_px_tex,_argsgrp.ILOSC);
                  {? _verify<>''
                  || _msg:='Nie można symulować: %1. Weryfikacja przepisu planistycznego '
                           'zakończona niepowodzeniem.'@[PX_OBJ.SYMBOL];
                     _msg+=' '+'Powód: %1.'@[_verify];
                     KOMM.add(_msg,'xwin16.png:2');
                     _can_continue:=0
                  ?}
               ?};

               {? _can_continue>0
               || _argsgrp.PX_TEX:=_px_tex
               ?}
            ||
               _msg:='Nie można symulować: %1. Nie znaleziono żadnego przepisu planistycznego, '
                     'który mógłby być użyty w symulacji.'@[PX_OBJ.SYMBOL];
               KOMM.add(_msg,'xwin16.png:2');
               _can_continue:=0
            ?};
            {? _can_continue>0
            || _can_continue:=exec('can_plan','px_obj',PX_OBJ.ref(),2,0,0,1,1)
            ?};

            {? _can_continue>0
            ||
               {? PX_OBJ.DIR=-1
               || _argsgrp.DIR:=PX_OBJ.DIR;
                  _argsgrp.STARTD:=date();
                  _argsgrp.STARTT:=time();
                  _argsgrp.ENDD:=ZL.PL_DATA;
                  _argsgrp.ENDT:=ZL.PL_TIME
               |? PX_OBJ.DIR>0
               || _argsgrp.DIR:=PX_OBJ.DIR;
                  _argsgrp.STARTD:=date();
                  _argsgrp.STARTT:=time();
                  _argsgrp.ENDD:=date(0,0,0);
                  _argsgrp.ENDT:=time(0,0,0)
               ?};
               _can_continue:=exec('add','px_grp',_argsgrp,PX_OBJ.ref())
            ?}
         ?}
      ?}
   ?}
?};

{? _can_continue>0
|| _result:=1
?};
::PX_VAR.VER_QUE:=_ver_que;
ZL.cntx_pop();
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
PX_OBJ.cntx_pop();
PX_VER.cntx_pop();
_result


\nakl_prc
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Zwraca procent wymaganego luzu dla nakladkowania na podstawie kontenera lub paczki technologicznej
::       (zwraca wiekszy procent)
::       Kontekst pracy - PX_KONT, paczka technologiczna
::   WE: _a - tab_tmp - paczka technologiczna
::   WY: REAL
::----------------------------------------------------------------------------------------------------------------------
_paczka:=_a;
_result:=0;

_result:=PX_KONT.NAKL_PRC;
{? _paczka.NAKL_PRC>_result
|| _result:=_paczka.NAKL_PRC
?};
_result


\fast_replan_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Argumenty dla funkcji grp_fast_replan
::   WY: obj_new - tablica nazwana z argumentami
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
::             Grupa ktora zaplanowac
               'PX_GRP',
::             Tabela tymczasowa z przedzialami dla grup
               'TM_RANGE',
::             Czy granica czasowa 'Od' obiektu grupujacego zostanie
::             zmodyfikowana na 'teraz' (ewentualnie plus jeden pojemnik
::             na pierwszym zasobie pierwszego etapu)
               'MOD_START',
::             Czas poczatku nowej wersji planu
               'TM_ZERO',
::             Czy utworzyc czas poczatku nowej wersji planu na podstawie paczki i czasu
::             aktualnego
               'ZERO_CREATE',
::             Czy przed planowaniem czyscic plan
               'CLEAN',
::             Czy po zaplanowaniu oznaczyc kolejke czasem modyfikacji
               'MOD_QUEUE',
::             Czy podczas dodawania pozycji na pojemnik wykonywac renumeracje pozycji?
               'RENUMERATE',
::             Czy po zaplanowaniu wygenerowac zapisy do planu dostaw
               'SUR_UPD',
::             Obiekt do planowania na podstawie planu dostaw
               'PD_OBJ'
               );
_args.PX_GRP:=null();
_args.TM_RANGE:=~~;
_args.MOD_START:=0;
_args.TM_ZERO:=0;
_args.ZERO_CREATE:=0;
_args.CLEAN:=1;
_args.MOD_QUEUE:=1;
_args.RENUMERATE:=1;
_args.SUR_UPD:=1;
_args.PD_OBJ:=~~;
_args


\grp_fast_replan
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Przeplanowuje 'na szybko' podanego w argumencie PX_GRP
::   WE: _args - argumenty funkcji szybkiego przeplanowania - wynik dzialania exec('fast_replan_a','px_logix')
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mainver:=exec('get_replan_version','px_ver');

PX_CUP.cntx_psh();
PX_POZ.cntx_psh();
PX_POZ.index('TM_GRP');
PX_GRP.cntx_psh(); PX_GRP.clear();
{? PX_GRP.seek(_args.PX_GRP)
||
:: Na czas przeliczania grupy blokuje ja, ale jesli blokada sie nie udala
:: to i tak kontynuuje
   exec('lock','px_grp',,0);

   {? exec('is_blocked','px_grp')>0
   ||
::    Jesli grupa byla zablokowana to musze odblokowac te pozycje planu ktore
::    byly przesuwane w wyniku nadwykonan
      PX_POZ.prefix(PX_GRP.ref());
      {? PX_POZ.first()
      || {!
         |? {? exec('nadwykon_moved','px_poz')>0
            || {? PX_POZ.BLK='T'
               || PX_POZ.BLK:='N';
                  _can_continue:=PX_POZ.put()
               ?}
            ?};
            PX_POZ.next() & _can_continue>0
         !}
      ?}
   ?};
   {? _args.CLEAN>0
   ||
::    usuwam PX_GRP z planu - robie dziury po to by od nowa zaplanowac
      _can_continue:=exec('clean_from_plan','px_grp',PX_GRP.ref(),0)
   ?};

   {? _can_continue>0
   ||
::    sprawdzam czy psotek powolany, jesli nie to powoluje
      exec('PXoTEX_chk','px_tex');

::    pobieram paczke technologiczna
      {? PX_GRP.GROPS<>null()
      || _pxpack:=exec('trzepaczka_grop','px_tex',PX_GRP.GROPS,PX_GRP.ILOSC,PX_GRP.ref())
      || _pxpack:=exec('trzepaczka','px_tex',PX_GRP.PX_TEX,PX_GRP.ILOSC,PX_GRP.ref())
      ?};

      _argsgrp:=exec('plan_grp_a','px_logix');
      _argsgrp.VER_DST:=PX_GRP.PX_VER;
      _argsgrp.PX_GRP:=PX_GRP.ref();
      _argsgrp.RENUMERATE:=_args.RENUMERATE;
      obj_del(_argsgrp.PxPack);
      _argsgrp.PxPack:=_pxpack;
      {? type_of(_args.TM_RANGE)>0
      || _argsgrp.TM_RANGE:=_args.TM_RANGE
      ?};
      _argsgrp.PD_OBJ:=_args.PD_OBJ;

      _tm_start:=exec('round_start_pck','px_tex',_pxpack.Paczka);
      {? _args.MOD_START>0
      || {? _tm_start>0
         ||
            PX_GRP.STARTD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',_tm_start));
            PX_GRP.STARTT:=exec('tm_stamp2time','#tm_stamp',_tm_start);
            _can_continue:=PX_GRP.put()
         || _can_continue:=0
         ?}
      ?};

      {? _args.TM_ZERO>0
      ||
::       Jesli poczatek planu podany w argumencie to go wykorzystuje
         _argsgrp.TM_ZERO:=_args.TM_ZERO
      |? _args.ZERO_CREATE>0
      ||  _argsgrp.TM_ZERO:=_tm_start
      ?};

::    uruchamiam algorytm planujacy
      _can_continue:=exec('plan_grp','px_logix',_argsgrp).RESULT;

::    jesli sie udalo zaplanowac, to odwiezam termin i ilosc zaplanowana
::    na obiektach nalezacych do grupy
      {? _can_continue>0
      || {? PX_GRP.PX_VER=_mainver
         || PX_CONN.cntx_psh();
            PX_CONN.index('PX_GRP');
            PX_CONN.prefix(PX_GRP.ref());
            {? PX_CONN.first()
            || {!
               |? exec('il_plan_refresh','px_obj',PX_CONN.PX_OBJ);
                  exec('planend_refresh','px_obj',PX_CONN.PX_OBJ);
                  PX_CONN.next()
               !}
            ?};
            PX_CONN.cntx_pop()
         ?}
      ?};

      {? _can_continue>0 & _args.MOD_QUEUE>0
      ||
::       Stempluje kolejke czasem i userem modyfikacji - przeplanowanie obiektu moze wymagac
::       przeliczenia kolejki
         exec('mod_stamp_queue','px_ver',PX_GRP.PX_VER)
      ?};

      {? exec('is_blocked','px_grp')>0
      ||
::       Jesli grupa byla zablokowana to musze zablokowac te pozycje planu ktore
::       byc moze powstaly w wyniku przeplanowania i nie sa jeszcze zablokowane
         PX_POZ.prefix(PX_GRP.ref());
         {? PX_POZ.first()
         || {!
            |? {? PX_POZ.BLK='N'
               || PX_POZ.BLK:='T';
                  _can_continue:=PX_POZ.put();

                  {? _can_continue>0
                  ||
::                   Jezeli zmienilem stan blokady to byc moze musze scalic te pozycje z inna pozycja
::                   ktora pasuje do kryteriow scalania - wykorzystuje do tego celu funkcje
::                   przesuwania - przesuwam do tego samego pojemnika
                     exec('move','px_poz',PX_POZ.ref(),PX_POZ.PX_CUP)
                  ?}
               ?};
               PX_POZ.next() & _can_continue>0
            !}
         ?}
      ?};

::    Generuje zapisy do planu dostaw
      {? _can_continue>0 & _args.SUR_UPD>0
      || exec('generuj_grp','px_sur',PX_GRP.PX_VER,PX_GRP.ref())
      ?}

   ?};
:: Zdejmuje blokade z grupy
   exec('unlock','px_grp',_args.PX_GRP)
?};
{? _can_continue>0
|| _result:=1
?};
PX_GRP.cntx_pop();
PX_POZ.cntx_pop();
PX_CUP.cntx_pop();
_result


\tm_range_create
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Tworzy tabele dla przedzialow zaplanowania grup
::   WY: TABLE
::----------------------------------------------------------------------------------------------------------------------
tab_tmp(1
       ,'SQLREF'  ,'STRING[16]','$PX_GRP.ref()'
       ,'TM_START','REAL'      ,'Start'
       ,'TM_END'  ,'REAL'      ,'Stop'
       )


\termin_chk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy aktualny pojemnik nie przekracza nieprzekraczalnych granic planowania
::       Kontekst pracy - PX_CUP, rekord paczki planistycznej
::   WE: _a - REAL - TM_START - nieprzekraczalna granica lewa
::       _b - REAL - TM_END - nieprzekraczalna granica prawa
::       _c - INTEGER - zwrot planowania
::       _d - tab_tmp - paczka planistyczna
::       [_e] - TABLE - tabela w której będzie poszukiwany rekord (domyślnie PX_CUP)
::   WY: 1 - pojemnik nie przekracza terminu
::       0 - pojemnik przekracza termin
::----------------------------------------------------------------------------------------------------------------------
_tm_start:=_a;
_tm_end:=_b;
_dir:=_c;
_paczka:=_d;

_tab:=~~;
{? var_pres('_e')>0
|| _tab:=_e
|| _tab:=PX_CUP
?};

_result:=1;


{? _dir<0
||
   {? _tm_start>0
   || {? _tab.TM_START<=_tm_start
      ||
         _what:=exec('PX_GRP','#to_string');
         _result:=0;
::       jesli cos zostalo do zaplanowania, ale przerywam plan z powodu przekroczenia
::       granic na obiekcie grupujacym to wyswietlam komunikat
         _msg:='Podczas planowania elementu kolejki: %1'
               ' nastąpiło przekroczenie dozwolonego terminu: %2 (początkowa granica czasowa elementu kolejki).'
               ' Spowodowało to przepełnienie na pojemniku przed dozwolonym terminem.'[_what,(19+tm_form(_tm_start))];

::       Dodawanie komunikatu o problemie do tabeli komunikatow
         {? var_pres('_komm_args')>100
         || obj_del(_komm_args)
         ?};
         _komm_args:=exec('add_komm_a','px_komm');
         _komm_args.PX_VER:=PX_VER.ref();
         _komm_args.PX_GRP:=PX_GRP.ref();
         _komm_args.PX_CUP:=PX_CUP.ref();
         _komm_args.TYP:=exec('type_error','px_komm');
         _komm_args.SRC_KIND:=exec('src_plan_cupter','px_komm');
         _komm_args.MESSAGE:=_msg;
         exec('add_komm','px_komm',_komm_args);

         pxkomm.error(_komm_args.MESSAGE)
      ?}
   ?}
?};
{? _dir>0
||
   {? _tm_end>0
   || {? _tab.TM_END>_tm_end
      ||
         {? _paczka.PL_FORCE='T'
         ||
            _what:=exec('PX_GRP','#to_string');
::          Umozliwiam planowanie poza termin, nie przerywam, tylko dodaje odpowiedni komunikat
            _msg:='Podczas planowania elementu kolejki: %1'
                  ' nastąpiło przekroczenie dozwolonego terminu: %2 (końcowa granica czasowa elementu kolejki).'
                  ' Plan jest kontynuowany mimo przekroczenia na pojemniku: %3.'[_what,(19+tm_form(_tm_end)),PX_CUP.SYMBOL];
            {? var_pres('_komm_args')>100
            || obj_del(_komm_args)
            ?};
            _komm_args:=exec('add_komm_a','px_komm');
            _komm_args.PX_VER:=PX_VER.ref();
            _komm_args.PX_GRP:=PX_GRP.ref();
            _komm_args.PX_CUP:=PX_CUP.ref();
            _komm_args.TYP:=exec('type_error','px_komm');
            _komm_args.SRC_KIND:=exec('src_plan_force','px_komm');
            _komm_args.MESSAGE:=_msg;
            exec('add_komm','px_komm',_komm_args);

            pxkomm.error(_komm_args.MESSAGE)
         ||
            _what:=exec('PX_GRP','#to_string');
            _result:=0;
::          jesli cos zostalo do zaplanowania, ale przerywam plan z powodu przekroczenia
::          granic na obiekcie grupujacym to wyswietlam komunikat
            _msg:='Podczas planowania elementu kolejki: %1'
                  ' nastąpiło przekroczenie dozwolonego terminu: %2 (końcowa granica czasowa elementu kolejki).'
                  ' Spowodowało to przepełnienie na pojemniku przed dozwolonym terminem.'[_what,(19+tm_form(_tm_end))];

::          Dodawanie komunikatu o problemie do tabeli komunikatow
            {? var_pres('_komm_args')>100
            || obj_del(_komm_args)
            ?};
            _komm_args:=exec('add_komm_a','px_komm');
            _komm_args.PX_VER:=PX_VER.ref();
            _komm_args.PX_GRP:=PX_GRP.ref();
            _komm_args.PX_CUP:=PX_CUP.ref();
            _komm_args.TYP:=exec('type_error','px_komm');
            _komm_args.SRC_KIND:=exec('src_plan_cupter','px_komm');
            _komm_args.MESSAGE:=_msg;
            exec('add_komm','px_komm',_komm_args);

            pxkomm.error(_komm_args.MESSAGE)
         ?}
      ?}
   ?}
?};
_result


\task_size_clean
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Zwraca wielkosc zadania - czyszczenie wersji planu
::   WE: _a - PX_VER.ref() - wersja planu
::   WY: REAL - wielkosc zadania
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_result:=0;

PX_KONT.cntx_psh();
PX_KONT.index('ACT');
PX_KONT.prefix('T',_px_ver);
_result:=PX_KONT.size();
PX_KONT.cntx_pop();
_result


\task_size_clone
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Zwraca wielkosc zadania - klonowanie pojemnikow
::   WE: _a - PX_VER.ref() - wersja planu
::   WY: REAL - wielkosc zadania
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_result:=0;

PX_KONT.cntx_psh();
PX_KONT.index('ACT');
PX_KONT.prefix('T',_px_ver);
_result:=PX_KONT.size();
PX_KONT.cntx_pop();
_result


\task_size_delay
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Zwraca wielkosc zadania - planowanie opoznien
::   WE: _a - PX_VER.ref() - wersja planu
::   WY: REAL - wielkosc zadania
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_result:=0;

PX_GRP.cntx_psh();
PX_GRP.index('STATUS');
PX_GRP.prefix(_px_ver,exec('status_delay','px_grp'));
_result:=PX_GRP.size();
PX_GRP.cntx_pop();
_result


\task_size_queue
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Zwraca wielkosc zadania - planowanie kolejki
::   WE: _a - PX_VER.ref() - wersja planu
::   WY: REAL - wielkosc zadania
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_result:=0;

PX_GRP.cntx_psh();
PX_GRP.index('PLAN');
PX_GRP.prefix(_px_ver,'N','N','Z');
_result:=PX_GRP.size();
PX_GRP.cntx_pop();
_result


\task_size_grop1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zwraca wielkosc zadania - planowanie grup operacji - sekwencja przed zleceniami i zamówieniami
::   WE: _a - PX_VER.ref() - wersja planu
::   WY: REAL - wielkosc zadania
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_result:=0;

PX_GRP.cntx_psh();
PX_GRP.index('PLAN_G');
PX_GRP.prefix(_px_ver,'N','N','G','P');
_result:=PX_GRP.size();
PX_GRP.cntx_pop();
_result


\task_size_grop2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Zwraca wielkosc zadania - planowanie grup operacji - sekwencja po zleceniach i zamówieniach
::   WE: _a - PX_VER.ref() - wersja planu
::   WY: REAL - wielkosc zadania
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_result:=0;

PX_GRP.cntx_psh();
PX_GRP.index('PLAN_G');
PX_GRP.prefix(_px_ver,'N','N','G','K');
_result:=PX_GRP.size();
PX_GRP.cntx_pop();
_result


\task_size_pxpoz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca wielkosc zadania - ilosc pozycji planu w wersji
::   WE: _a - PX_VER.ref() - wersja planu
::   WY: REAL - wielkosc zadania
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_result:=0;

PX_POZ.cntx_psh();
PX_POZ.index('PX_STAG4');
PX_POZ.prefix(_px_ver,'N');
_result:=PX_POZ.size();
PX_POZ.cntx_pop();
_result


\task_size_pxcon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca wielkosc zadania - ilosc powiazan planu w wersji
::   WE: _a - PX_VER.ref() - wersja planu
::   WY: REAL - wielkosc zadania
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_result:=0;

PX_CONN.cntx_psh();
PX_CONN.index('VER');
PX_CONN.prefix(_px_ver);
_result:=PX_CONN.size();
PX_CONN.cntx_pop();
_result


\task_size_grpnw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Zwraca wielkosc zadania - ilosc niewykonanych grup w wersji planu
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_result:=0;

PX_GRP.cntx_psh();
PX_GRP.index('STATWYK2');
PX_GRP.prefix(_px_ver,'N');
_result:=PX_GRP.size();
PX_GRP.cntx_pop();
_result


\task_size_cal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Zwraca wielkosc zadania - odtwarzanie kalendarzy
::   WE: _a - PX_VER.ref() - wersja planu
::   WY: REAL - wielkosc zadania
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_result:=0;

PX_CUP.cntx_psh();
PX_CUP.index('VER2');
PX_CUP.prefix(_px_ver);
{? PX_CUP.find_ge(PX_CUP.tm_stamp())
|| {!
   |? _result+=1;
      PX_CUP.next()
   !}
?};
PX_CUP.cntx_pop();
_result


\verify_zaz
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Weryfikuje czy plan kolejnych rekordow paczki nie naklada sie na siebie
::       Problemy z nakladaniem sie etapow moga pojawic sie w wyniku uzywania punktow czasowych
::   WE: _a - obj_new - paczka technologiczna
::       _b - PX_VER.ref() - wersja planu
::       _c - PX_GRP.ref() - grupa ktora byla planowana (w razie problemow do tej grupy zostana dodane komunikaty)
::   WY: 0 - wystapily problemy
::       1 - brak problemow z nakladaniem sie etapow
::----------------------------------------------------------------------------------------------------------------------
_pxpack:=_a;
_px_ver:=_b;
_px_grp:=_c;

_paczka:=_pxpack.Paczka;

_result:=1;

:: Najpierw kasuje istniejace komunikaty
_typ_e:=exec('type_error','px_komm');
_src_zaz:=exec('src_plan_zaz','px_komm');
exec('del_kommy','px_komm','PX_GRP',_px_grp,_typ_e,_src_zaz);

_typ_w:=exec('type_warning','px_komm');
_src_offset:=exec('src_plan_poioff','px_komm');
exec('del_kommy','px_komm','PX_GRP',_px_grp,_typ_w,_src_offset);

_add_warn:=exec('get','#params',500364);

_paczka.cntx_psh();
_paczka.index(_pxpack.Ndx_fwd);
_paczka.prefix('K');
{? _paczka.first()
|| {!
   |?
::    Sprawdzam tylko etapy ktore maja okreslone punkty czasowe, bo tylko one moga sie zazebiac
      {? _paczka.TM_MIN>0 | _paczka.TM_MAX>0
      ||
         _prev_end:=0;
         _prev_sym:='';
         _prev_nakl:=0;
         _next_start:=0;
         _next_sym:='';
         _next_nakl:=0;

         _cur_sym:=exec('record','#to_string',_paczka.PX_STAGE);
::       Sprawdzam czy podany punkt czasowy zostal spelniony, jesli nie to dodaje ostrzezenie
         {? _add_warn='T'
         ||
            {? _paczka.EMPTY<>'T' & _paczka.TM_MIN>0 & _paczka.PL_START>0
            ||
               {? _paczka.PL_START<>_paczka.TM_MIN
               ||
::                Wykryto ze podany punkt czasowy nie jest spelniony w planie - dodaje ostrzezenie
                  {? var_pres('_komm_args')>100
                  || obj_del(_komm_args)
                  ?};
                  _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=_px_ver;
                  _komm_args.PX_GRP:=_px_grp;
                  _komm_args.TYP:=_typ_w;
                  _komm_args.SRC_KIND:=_src_offset;

                  _str_poi:=19+tm_form(_paczka.TM_MIN);
                  _str_plan:=19+tm_form(_paczka.PL_START);
                  _msg:='Zgodnie z punktem czasowym etapu: %1 plan miał zacząć się: %2, a zaczyna się: %3'[_cur_sym,_str_poi,_str_plan];
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args)
               ?}
            ?};
            {? _paczka.EMPTY<>'T' & _paczka.TM_MAX>0 & _paczka.PL_END>0
            ||
               {? _paczka.PL_END<>_paczka.TM_MAX
               ||
::                Wykryto ze podany punkt czasowy nie jest spelniony w planie - dodaje ostrzezenie
                  {? var_pres('_komm_args')>100
                  || obj_del(_komm_args)
                  ?};
                  _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=_px_ver;
                  _komm_args.PX_GRP:=_px_grp;
                  _komm_args.TYP:=_typ_w;
                  _komm_args.SRC_KIND:=_src_offset;

                  _str_poi:=19+tm_form(_paczka.TM_MAX);
                  _str_plan:=19+tm_form(_paczka.PL_END);

                  _msg:='Zgodnie z punktem czasowym etapu: %1 plan miał skończyć się: %2, a kończy się: %3'[_cur_sym,_str_poi,_str_plan];
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args)
               ?}
            ?}
         ?};
::       Pobieram czas zakończenia poprzedniego etapu
         _prev_uid:=exec('oper_start','px_logix',_pxpack,1,,2);
         {? _prev_uid>0
         || _paczka.cntx_psh();
            _paczka.index(_pxpack.Ndx_uid);
            _paczka.prefix(_prev_uid);
            {? _paczka.first()
            || _prev_end:=_paczka.PL_END;

               {? _prev_end=0 & _paczka.GROPED='T'
               || _px_stage:=exec('FindAndGet','#table',PX_STAGE,_paczka.PX_STAGE,,,null());
                  {? _px_stage<>null()
                  || _prev_end:=exec('get_time_zl','px_grop',_px_grp,_px_stage,1)
                  ?}
               ?};
               _prev_sym:=exec('record','#to_string',_paczka.PX_STAGE);
               _prev_nakl:=_paczka.NAKLDIFF
            ?};
            _paczka.cntx_pop()
         ?};

::       Pobieram czas rozpoczęcia następnego etapu
         _next_uid:=exec('oper_start','px_logix',_pxpack,-1,,2);
         {? _next_uid>0
         || _paczka.cntx_psh();
            _paczka.index(_pxpack.Ndx_uid);
            _paczka.prefix(_next_uid);
            {? _paczka.first()
            || _next_start:=_paczka.PL_START;

               {? _next_start=0 & _paczka.GROPED='T'
               || _px_stage:=exec('FindAndGet','#table',PX_STAGE,_paczka.PX_STAGE,,,null());
                  {? _px_stage<>null()
                  || _next_start:=exec('get_time_zl','px_grop',_px_grp,_px_stage,-1)
                  ?}
               ?};
               _next_sym:=exec('record','#to_string',_paczka.PX_STAGE);
               _next_nakl:=_paczka.NAKLDIFF
            ?};
            _paczka.cntx_pop()
         ?};
         {? _prev_end>0
         ||
::          Sprawdzam czy poprzedni koniec nie jest pozniej niz moj poczatek (uwzględnia nakladkowanie)
            {? (_prev_end-_prev_nakl)>_paczka.PL_START
            ||
               _result:=0;
::             Wykryto zazebienie - dodaje komunikat
               {? var_pres('_komm_args')>100
               || obj_del(_komm_args)
               ?};
               _komm_args:=exec('add_komm_a','px_komm');
               _komm_args.PX_VER:=_px_ver;
               _komm_args.PX_GRP:=_px_grp;
               _komm_args.TYP:=_typ_e;
               _komm_args.SRC_KIND:=_src_zaz;
               _msg:='Początek etapu: %1 zazębia się z końcem etapu: %2 lub została naruszona kolejnośc operacji w planie.'[_cur_sym,_prev_sym];
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args)
            ?}
         ?};

         {? _next_start>0
         ||
::          Sprawdzam czy nastepny start nie jest wczesniej niz moj koniec (uwzglednia nakladkowanie)
            {? (_next_start+_next_nakl)<_paczka.PL_END
            ||
               _result:=0;
::             Wykryto zazebienie - dodaje komunikat
               {? var_pres('_komm_args')>100
               || obj_del(_komm_args)
               ?};
               _komm_args:=exec('add_komm_a','px_komm');
               _komm_args.PX_VER:=_px_ver;
               _komm_args.PX_GRP:=_px_grp;
               _komm_args.TYP:=_typ_e;
               _komm_args.SRC_KIND:=_src_zaz;
               _msg:='Koniec etapu: %1 zazębia się z początkiem etapu: %2 lub została naruszona kolejność operacji w planie.'[_cur_sym,_next_sym];
               _komm_args.MESSAGE:=_msg;
               exec('add_komm','px_komm',_komm_args)
            ?}
         ?}
      ?};
      _paczka.next()
   !}
?};
_paczka.cntx_pop();
_paczka.get();
_result


\mainver_replan
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Funkcja planujaca glowna wersje planu - przelicza wyswietlana wersje planu
::       Dziala tylko w przypadku kiedy parametr 500365 ma wartosc 'T'
::   WE: [_a] - INTEGER - 0/[1] - czy odswiezac glowne okno planu po przeliczeniu
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_refresh:=1;
{? var_pres('_a')=type_of(0)
|| _refresh:=_a
?};

_dest:=exec('get_replan_version','px_ver');
_delays_mode:=exec('get','#params',500356,2);
exec('opernast_init','px_init');

PX_VAR.PD:=exec('is_plan_dost','px_pd');

_result:=0;
_can_continue:=1;

PX_KONT.cntx_psh();
PX_GRP.cntx_psh();
PX_VER.cntx_psh();
PX_VER.clear();
PX_GRP.clear();
PX_OBJ.cntx_psh();
:: inicjalizacja obiektu KOMM
exec('pxkomm_init','px_logix');

_argsprog:=exec('plan_progress_a','px_logix');
_argsprog.PX_VER:=_dest;

:: Aby wylaczyc multiprogress nalezy ustawic _prog_mode:=1
_argsprog.MODE:=2;

_argsprog.SIZEALL:=1000;
_delay_size:=exec('task_size_delay','px_logix',_dest);
_queue_size:=exec('task_size_queue','px_logix',_dest);
_queue_grop1:=0;
_queue_grop2:=0;
{? exec('is_grop','px_param')
|| _queue_grop1:=exec('task_size_grop1','px_logix',_dest);
   _queue_grop2:=exec('task_size_grop2','px_logix',_dest);
   ~~
?};
_pxpoz_size:=exec('task_size_pxpoz','px_logix',_dest);
_pxcon_size:=exec('task_size_pxcon','px_logix',_dest);
_renum_size:=exec('task_size_renum','px_logix',_dest);
_pxgrp_size:=exec('task_size_grpnw','px_logix',_dest);
_pd_size:=0;
{? PX_VAR.PD>0
|| _pd_size:=exec('task_size_prepare','px_pd',_dest)
?};
_total_queue_size:=_queue_size+_queue_grop1+_queue_grop2;
_cal_size:=0;
{? PX_VAR.NAST_ALG=2
|| _cal_size:=exec('task_size_cal','px_logix',_dest)
?};

{? _argsprog.MODE=1
|| FUN.prg_start(100,,50)
|? _argsprog.MODE=2
|| _argsprog.MULTI.BREAK_ON:='N';
:: Inicjuje multiprogress
   {? _total_queue_size>0
   || _argsprog.MULTI.add_progress('Aktualizacja i weryfikacja elementów kolejki'@,7)
   ?};

   {? _pd_size>0
   || _argsprog.MULTI.add_progress('Wstępne zasilenie planu dostaw'@,_pd_size)
   ?};

   {? _queue_size>0
   || _argsprog.MULTI.add_progress('Usuwanie kolejki z planu'@,_queue_size)
   ?};
   {? _cal_size>0
   || _argsprog.MULTI.add_progress('Odtwarzanie kalendarzy w pojemnikach'@,_cal_size)
   ?};

:: Tryb przeplanuj opoznienia - najpierw progress opoznien, pozniej kolejki
   {? _delays_mode=exec('delays_plan','px_param')
   ||
      {? _delay_size>0
      || _argsprog.MULTI.add_progress('Planowanie opóźnień'@,_delay_size)
      ?};
      {? _queue_grop1>0
      || _argsprog.MULTI.add_progress('Planowanie grup operacji - krok 1'@,_queue_grop1)
      ?};
      {? _queue_size>0
      || _argsprog.MULTI.add_progress('Planowanie kolejki'@,_queue_size)
      ?};
      {? _queue_grop2>0
      || _argsprog.MULTI.add_progress('Planowanie grup operacji - krok 2'@,_queue_grop2)
      ?};
      ~~
   ?};
:: Tryb przesun opoznienia - najpierw progress kolejki, pozniej opoznien
   {? _delays_mode=exec('delays_move','px_param')
   || {? _queue_grop1>0
      || _argsprog.MULTI.add_progress('Planowanie grup operacji - krok 1'@,_queue_grop1)
      ?};
      {? _queue_size>0
      || _argsprog.MULTI.add_progress('Planowanie kolejki'@,_queue_size)
      ?};
      {? _queue_grop2>0
      || _argsprog.MULTI.add_progress('Planowanie grup operacji - krok 2'@,_queue_grop2)
      ?};
      {? _delay_size>0
      || _argsprog.MULTI.add_progress('Planowanie opóźnień'@,_delay_size)
      ?};
      ~~
   ?};

   {? _renum_size>0
   || _argsprog.MULTI.add_progress('Sortowanie planu'@,_renum_size)
   ?};

   _argsprog.MULTI.add_progress('Nanoszenie zapotrzebowań do bufora planu dostaw'@,1);
   _argsprog.MULTI.add_progress('Nanoszenie terminów na obiekty źródłowe'@,_pxcon_size)

?};

_msg:='Uruchomienie algorytmu przeplanowania wersji głównej';
pxkomm.sect_beg(_msg);
_verified:=1;
_current_px_grp:='';
{? PX_VER.seek(_dest)
||
   _msg:='Blokowanie wersji: '+PX_VER.SYMBOL;
   pxkomm.sect_beg(_msg);

:: blokuje wersje
   {? exec('lock','px_ver',_dest)
   ||
::    Pokazuje multiprogress
      exec('start','#progress',_argsprog.MULTI);

      _argsprog.PHASES:=6;

::    Inicjuję obiekt w którym będę przechowywał refy zablokowanych przepisów na czas przeliczania
      _locked_tex:=exec('ref_table','#table');

      {? _can_continue>0
      ||
::       Kasowanie komunikatów dot sprawdzania
         _type:=exec('type_error','px_komm');
         _src:=exec('src_act_prefix','px_komm');
         exec('del_kommy','px_komm','PX_VER',PX_VER.ref(),_type,_src);

         {? _total_queue_size>0
         ||
::          1. Aktualizacja i weryfikacja kolejki
            {? _argsprog.MODE=2
            || _argsprog.MULTI.next_phase()
            ?};

            {? exec('queue_check','px_logix',,_argsprog,,_locked_tex)>0
            || _can_continue:=1;
               _verified:=1
            || _can_continue:=0;
               _verified:=0
            ?}
         ?};

         {? _can_continue>0 & _verified>0
         ||
::          Stempluje wersje czasem modyfikacji
            exec('mod_stamp','px_ver',_dest);

::          Oznaczam wersje jako przeliczaną
            PX_VER.get();
            PX_VER.STATUS:=exec('status_pending','px_ver');
            _can_continue:=PX_VER.put()
         ?};

::       2. Przygotowanie planu dostaw
         _pdprod:=~~;
         {? PX_VAR.PD>0
         || _pdprod:=exec('pdprod','plan_dostaw_prod',PX_VER.PD_N,ST.ODDZ)
         ?};

         {? PX_VAR.PD>0 & PX_VER.PD_N=null()
         ||
::          Tworzę nagłówek planu dostaw powiązanego z wersją planu
            _can_continue:=_pdprod.pd_create('Plan strategiczny','Plan strategiczny');
            {? _can_continue>0 & _pdprod.PD_N<>null()
            || PX_VER.PD_N:=_pdprod.PD_N;
               _can_continue:=PX_VER.put()
            ?}
         ?};

         {? _can_continue>0 & PX_VAR.PD>0 & PX_VER.PD_N<>null() & _pd_size>0
         ||
            {? _argsprog.MODE=2
            || _argsprog.MULTI.next_phase()
            ?};

::          Zasilam plan dostaw indeksami i buduję dla nich historię stanów
            _can_continue:=exec('prepare','px_pd',_pdprod,_dest,_argsprog)
         ?};


::       2. Usuwanie kolejki z planu
         {? _can_continue>0
         ||
            {? _total_queue_size>0
            ||
               {? _argsprog.MODE=2
               || _argsprog.MULTI.next_phase()
               ?};

               PX_GRP.index('COOP');
               PX_GRP.prefix(_dest,'N','N','T');
               PX_VAR.COOP_QUE:=PX_GRP.size();

::             Przetwarzam tylko nie wykonane i niezablokowane obiekty kolejki
               PX_GRP.index('PLAN');
               PX_GRP.prefix(_dest,'N','N');
               _argsprog.SIZELOC:=PX_GRP.size();

               _lp:=0;
               _step:=10;
               {? PX_GRP.first()
               ||
                  {!
                  |?
                     _current_px_grp:='Czyszczenie: %1'@[exec('PX_GRP','#to_string')];
                     _lp+=1;
::                   Usuwam komunikaty zwiazane z planowaniem dot PX_GRPa
                     _src_kom:=exec('src_plan_prefix','px_komm');
                     _typ1:=exec('type_error','px_komm');
                     _typ2:=exec('type_warning','px_komm');
                     _typ3:=exec('type_info','px_komm');
                     exec('del_kommy','px_komm','PX_GRP',PX_GRP.ref(),_typ1);
                     exec('del_kommy','px_komm','PX_GRP',PX_GRP.ref(),_typ2);
                     exec('del_kommy','px_komm','PX_GRP',PX_GRP.ref(),_typ3);

                     {? _lp%*_step=0
                     ||
::                      raportuje progress
                        _argsprog.PROGLOC+=1;
                        _argsprog.STRING:='Usuwanie z planu: %1'@[PX_GRP.SYMBOL];
                        _can_continue:=exec('plan_progress','px_logix',_argsprog,_step)
                     ?};

::                   usuwam PX_GRP z planu - robie dziury po to by od nowa zaplanowac
                     _can_continue:=exec('clean_from_plan','px_grp',PX_GRP.ref(),0,1,0,0);
                     PX_GRP.next() & _can_continue>0
                  !}
               ?};
               {? _can_continue>0
               ||
::                Jeśli nic się nie wywaliło to czyszczę symbol grupy
                  _current_px_grp:=''
               ?}
            ?}
         ?};
         {? _can_continue>0 & _cal_size>0
         ||
            {? _argsprog.MODE=2
            || _argsprog.MULTI.next_phase()
            ?};
            _tm_start:=PX_CUP.tm_stamp()-(exec('day','#tm_stamp'));
            _can_continue:=exec('rebuild4all','px_cal',0,2,_tm_start,_argsprog)
         ?};

::       3. Planowanie opóźnien - tryb 'PRZEPLANUJ'
         {? _can_continue>0 & _delay_size>0
         || {? _delays_mode=exec('delays_plan','px_param')
            ||
               {? _argsprog.MODE=2
               || _argsprog.MULTI.next_phase()
               ?};
               _can_continue:=exec('delays_mode1','px_logix',_dest,_dest,_argsprog,1)
            ?}
         ?};

         _tm_range:=exec('tm_range_create','px_logix');
::       4. Planowanie grup operacji - krok 1
         {? _queue_grop1>0
         ||
::          Przetwarzam tylko nie wykonane i niezablokowane obiekty kolejki
            PX_GRP.index('PLAN_G');
            PX_GRP.prefix(_dest,'N','N','G','P',);
            _argsprog.SIZELOC:=PX_GRP.size();

            _lp:=0;
            _step:=10;
            {? PX_GRP.first()
            ||
               {? _argsprog.MODE=2
               || _argsprog.MULTI.next_phase()
               ?};

               _it:=0;
               {? var_pres('_argsfast')>100
               || obj_del(_argsfast)
               ?};
               _argsfast:=exec('fast_replan_a','px_logix');
               _argsfast.TM_RANGE:=_tm_range;
               _argsfast.CLEAN:=0;
               _argsfast.MOD_QUEUE:=0;
               _argsfast.RENUMERATE:=0;
               _argsfast.SUR_UPD:=0;
               _argsfast.PD_OBJ:=_pdprod;
               _what:='';
               {!
               |? _current_px_grp:='Planowanie: %1'@[exec('PX_GRP','#to_string')];
                  _lp+=1;
                  {? _lp%*_step=0
                  ||
::                   raportuje progress
                     _argsprog.PROGLOC+=1;
                     _argsprog.STRING:='Planowanie: %1'@[PX_GRP.SYMBOL];
                     _can_continue:=exec('plan_progress','px_logix',_argsprog,_step)
                  ?};

::                planuje tylko:
::                1. Niezablokowane obiekty grupujace - zablokowane nie sa przeliczane
                  {? _can_continue>0
                  ||
::                   uruchamiam algorytm przeplanowujacy grupe w biezacej wersji
                     _argsfast.PX_GRP:=PX_GRP.ref();
                     _what:=exec('PX_GRP','#to_string');
                     _can_continue:=exec('grp_fast_replan','px_logix',_argsfast)
                  ?};

                  PX_GRP.next() & _can_continue>0
               !};
               {? _argsprog.MODE=2
               || {? _can_continue>0
                  || _argsprog.MULTI.ph_sname(,'Planowanie grup operacji zakończone powodzeniem.'@)
                  || _argsprog.MULTI.ph_sname(,'Planowanie grup operacji zakończone niepowodzeniem (przerwano na: %1).'@[_what])
                  ?}
               ?};
               {? _can_continue>0
               ||
::                Jeśli nic się nie wywaliło to czyszczę symbol grupy
                  _current_px_grp:=''
               ?}
            ?}
         ?};

::       5. Planowanie kolejki
         {? _can_continue>0 & _queue_size>0
         ||
            {? _argsprog.MODE=2
            || _argsprog.MULTI.next_phase()
            ?};

::          Przetwarzam tylko nie wykonane i niezablokowane obiekty kolejki
            {? exec('is_whatif','px_ver',_dest)>0
            || PX_GRP.index('PLAN_S');
               PX_GRP.prefix(_dest,'N','N','N','Z')
            ||
               PX_GRP.index('PLAN');
               PX_GRP.prefix(_dest,'N','N','Z')
            ?};
            _argsprog.SIZELOC:=PX_GRP.size();

            _lp:=0;
            _step:=10;
            {? PX_GRP.first()
            ||
               _it:=0;
               {? var_pres('_argsfast')>100
               || obj_del(_argsfast)
               ?};
               _argsfast:=exec('fast_replan_a','px_logix');
               _argsfast.TM_RANGE:=_tm_range;
               _argsfast.CLEAN:=0;
               _argsfast.MOD_QUEUE:=0;
               _argsfast.RENUMERATE:=0;
               _argsfast.SUR_UPD:=0;
               _argsfast.PD_OBJ:=_pdprod;
               _what:='';
               {!
               |? _current_px_grp:='Planowanie: %1'@[exec('PX_GRP','#to_string')];
                  _lp+=1;
                  {? _lp%*_step=0
                  ||
::                   raportuje progress
                     _argsprog.PROGLOC+=1;
                     _argsprog.STRING:='Planowanie: %1'@[PX_GRP.SYMBOL];
                     _can_continue:=exec('plan_progress','px_logix',_argsprog,_step)
                  ?};

::                planuje tylko:
::                1. Niezablokowane obiekty grupujace - zablokowane nie sa przeliczane
                  {? _can_continue>0
                  ||
::                   uruchamiam algorytm przeplanowujacy grupe w biezacej wersji
                     _argsfast.PX_GRP:=PX_GRP.ref();
                     _what:=exec('PX_GRP','#to_string');
                     _can_continue:=exec('grp_fast_replan','px_logix',_argsfast)
                  ?};

                  PX_GRP.next() & _can_continue>0
               !};
               {? _argsprog.MODE=2
               || {? _can_continue>0
                  || _argsprog.MULTI.ph_sname(,'Planowanie kolejki zakończone powodzeniem.'@)
                  || _argsprog.MULTI.ph_sname(,'Planowanie kolejki zakończone niepowodzeniem (przerwano na: %1).'@[_what])
                  ?}
               ?};
               {? _can_continue>0
               ||
::                Jeśli nic się nie wywaliło to czyszczę symbol grupy
                  _current_px_grp:=''
               ?}
            ?}
         ?};

::       6. Planowanie grup operacji - krok 2
         {? _queue_grop2>0
         ||
::          Przetwarzam tylko nie wykonane i niezablokowane obiekty kolejki
            PX_GRP.index('PLAN_G');
            PX_GRP.prefix(_dest,'N','N','G','K',);
            _argsprog.SIZELOC:=PX_GRP.size();

            _lp:=0;
            _step:=10;
            {? PX_GRP.first()
            ||
               {? _argsprog.MODE=2
               || _argsprog.MULTI.next_phase()
               ?};

               _it:=0;
               {? var_pres('_argsfast')>100
               || obj_del(_argsfast)
               ?};
               _argsfast:=exec('fast_replan_a','px_logix');
               _argsfast.TM_RANGE:=_tm_range;
               _argsfast.CLEAN:=0;
               _argsfast.MOD_QUEUE:=0;
               _argsfast.RENUMERATE:=0;
               _argsfast.SUR_UPD:=0;
               _argsfast.PD_OBJ:=_pdprod;
               _what:='';
               {!
               |? _current_px_grp:='Planowanie: %1'@[exec('PX_GRP','#to_string')];
                  _lp+=1;
                  {? _lp%*_step=0
                  ||
::                   raportuje progress
                     _argsprog.PROGLOC+=1;
                     _argsprog.STRING:='Planowanie: %1'@[PX_GRP.SYMBOL];
                     _can_continue:=exec('plan_progress','px_logix',_argsprog,_step)
                  ?};

::                planuje tylko:
::                1. Niezablokowane obiekty grupujace - zablokowane nie sa przeliczane
                  {? _can_continue>0
                  ||
::                   uruchamiam algorytm przeplanowujacy grupe w biezacej wersji
                     _argsfast.PX_GRP:=PX_GRP.ref();
                     _what:=exec('PX_GRP','#to_string');
                     _can_continue:=exec('grp_fast_replan','px_logix',_argsfast)
                  ?};

                  PX_GRP.next() & _can_continue>0
               !};
               {? _argsprog.MODE=2
               || {? _can_continue>0
                  || _argsprog.MULTI.ph_sname(,'Planowanie grup operacji zakończone powodzeniem.'@)
                  || _argsprog.MULTI.ph_sname(,'Planowanie grup operacji zakończone niepowodzeniem (przerwano na: %1).'@[_what])
                  ?}
               ?};
               {? _can_continue>0
               ||
::                Jeśli nic się nie wywaliło to czyszczę symbol grupy
                  _current_px_grp:=''
               ?}
            ?}
         ?};

::       7. Planowanie opoznien tryb 'PRZESUN'
         {? _delay_size>0
         ||
            {? _delays_mode=exec('delays_move','px_param')
            ||
               {? _argsprog.MODE=2
               || _argsprog.MULTI.next_phase()
               ?};
               {? _can_continue>0
               || _can_continue:=exec('delays_mode2','px_logix',_dest,_dest,_argsprog)
               ?}
            ?}
         ?};

::       8. Sortowanie planu
         {? _renum_size>0
         ||
            {? _argsprog.MODE=2
            || _argsprog.MULTI.next_phase()
            ?};
            {? _can_continue>0
            || exec('renumerate_cups','px_logix',_dest,_argsprog)
            ?}
         ?};

::       9. Sprawdzenie statusu planu dostaw
         {? PX_VAR.PD>0
         || exec('verify','px_pd',_pdprod)
         ?};

::       10. Generowanie zapisow do planu zamowien dostaw
         {? _argsprog.MODE=2
         || _argsprog.MULTI.next_phase()
         ?};
         {? _can_continue>0
         || exec('generuj_ver','px_sur',_dest,_argsprog)
         ?};

         {? _argsprog.MODE=2
         || _argsprog.MULTI.next_phase()
         ?};

::       11. Aktualizacja terminow na obiektach zrodlowych
         exec('src_obj_act','px_plan',_dest,_argsprog)
      ?};

::    Odblokowuje wersje
      exec('unlock','px_ver',_dest);

::    Odblokowywuje wszystkie zablokowane przepisy
      _tab:=_locked_tex.tab;
      _tab.cntx_psh();
      _tab.clear();
      _unlock_res:=exec('lock_result','px_tex');
      {? _tab.first()
      || {!
         |? {? var_pres('_alias')>100
            || obj_del(_alias)
            ?};
            _alias:=ref_tab(_tab.SQL);
            {? type_of(_alias)>100
            || _unlock_res.TAB:=2-!_alias
            || _unlock_res.TAB:=''
            ?};
            _unlock_res.NAME:=_tab.NAME;
            _unlock_res.REF:=_tab.REF;
            exec('unlock','px_tex',_unlock_res);
            _tab.next()
         !}
      ?};
      _tab.cntx_pop();

::    Zatrzymuje progressa
      {? _argsprog.MODE=1
      || FUN.prg_stop()
      |? _argsprog.MODE=2
      || exec('stop','#progress',_argsprog.MULTI)
      ?};

::    jesli przeliczenie planu zakonczone niepowodzeniem to sprzatam na wszelki wypadek
::    pozostalosci po multiprogressie
      {? _can_continue=0
      || clr_sel()
      ?};

::    warunek, czy odswiezac zawartosc zakladek 'Obiekty' i 'Zasoby'
      {? exec('get','#params',8059,2,OPERATOR.USER)='T' & var_pres('PxSelect')>100
      || PxSelect.Tab_OBJ.reload(0);
         PxSelect.Tab_KONT.reload(0)
      ?};

::    warunek, czy odswiezac zakladke glownego panelu planowania
      {? _refresh>0
      || {? exec('tree_kont','px_param')
         || grp_disp(PX_KONT,'PX_WERT',1)
         || grp_disp(PX_KONT,'PX_WER',1)
         ?}
      ?};

::    Czynnosci po planowaniu
      {? _can_continue>0
      ||
::       oznaczam wersje jako zatwierdzona
         PX_VER.get();
         {? exec('is_whatif','px_ver')
         || PX_VER.STATUS:=exec('status_ready','px_ver')
         || PX_VER.STATUS:=exec('status_accepted','px_ver')
         ?};
         PX_VER.PROGRESS:=100;
         PX_VER.put();

::       wykonuje formule wdrozeniowa, po przeliczeniu wersji planu
         exec('ver_processed','px_prepq',PX_VER.ref());

::       Odswiezam kolejke
         {? var_pres('PxSelect')>100 & var_pres('Pxgrp',PxSelect)>100
         || exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp)
         ?};

::       Aktualizuje przyciski dot przeliczania jednej wersji planu
         {? var_pres('PxSelect')>100 || exec('przelicz_btn','px_plan') ?}
      ?}

   || _can_continue:=0
   ?}
|| FUN.wdrerror('Nie znaleziono wersji planu: %1'@[$_dest])
?};
PX_GRP.cntx_pop();
PX_VER.cntx_pop();
PX_OBJ.cntx_pop();
PX_KONT.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
{? _can_continue<=0 & _verified>0
|| _result:=0;
   {? _current_px_grp=''
   || FUN.info('Przeliczenie planu zakończone niepowodzeniem.'@)
   || FUN.info('Przeliczenie planu zakończone niepowodzeniem podczas planowania: %1.'@[_current_px_grp])
   ?}
|? _verified=0
|| _msg:='Weryfikacja kolejki planu zakończona niepowodzeniem.\n'
         'Plan nie został przeliczony.'@;
   FUN.info(_msg)
?};
_result


\queue_update
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Przed przeliczeniem planu dokonuje niezbednych aktualizacji elementow w kolejce
::   WE: [_a] - PX_VER.ref()
::       [_b] - _args - argumenty dla funkcji raportujacej progress
::                      wynik dzialania exec('plan_progress_a','px_logix')
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};
_progress:=0;
_argsprog:=~~;
{? var_pres('_b')>100
|| _argsprog:=_b;
   _progress:=1
?};

_result:=0;
_can_continue:=1;

PX_VER.cntx_psh();
{? _ref<>null()
|| PX_VER.clear();
   {? PX_VER.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_GRP.cntx_psh();
   {? exec('is_whatif','px_ver')>0
   || PX_GRP.index('PLAN_S');
      PX_GRP.prefix(PX_VER.ref(),'N','N','N')
   || PX_GRP.index('PLAN');
      PX_GRP.prefix(PX_VER.ref(),'N','N')
   ?};
   _lp_coop:=0;
   {? PX_GRP.first()
   || {? _progress>0
      || _argsprog.SIZELOC:=PX_GRP.size()
      ?};
      {!
      |?
         _can_continue:=exec('queue_update_core','px_logix',,0);

::       raportuje progress
         {? _can_continue>0 & _progress>0
         || _argsprog.PROGLOC+=1;
            _can_continue:=exec('plan_progress','px_logix',_argsprog,1)
         ?};

         {? PX_GRP.COOP='T'
         || _lp_coop+=1;
            PX_GRP.COOP_LP:=_lp_coop;
            _can_continue:=PX_GRP.put()
         ?};
         PX_GRP.next() & _can_continue>0
      !}
   ?};

   {? _argsprog.MODE=2 & _progress>0
   || {? _can_continue>0
      || _argsprog.MULTI.ph_sname(,'Aktualizacja kolejki zakończona powodzeniem.'@)
      || _argsprog.MULTI.ph_sname(,'Aktualizacja kolejki zakończona niepowodzeniem.'@)
      ?}
   ?};
   PX_GRP.cntx_pop()
?};
PX_VER.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\queue_update_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przed przeliczeniem planu dokonuje niezbednych aktualizacji podanego elementu w kolejce
::   WE: [_a] - PX_GRP.ref() - lub bieżący rekord
::       [_b] - INTEGER - 0/[1] - czy wykonywać aktualizację pola COOP_LP dla wszystkich elementów kolejki
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};
_coop_lp:=1;
{? var_pres('_b')=type_of(0)
|| _coop_lp:=_b
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: 1. Usuwam automatyczne punkty czasowe jesli praca na zestawach wylaczona
   {? exec('is_px_set','px_param')=0
   || _can_continue:=exec('auto_point_del','px_point')
   ?};

:: 2. Aktualizuje czas startu w oparciu o biezacy czas
   {? _can_continue>0
   || _can_continue:=exec('update_tm_start','px_grp')
   ?};

:: 3. Aktualizuje informację czy grupa posiada kooperację
   {? _can_continue>0
   || _can_continue:=exec('update_coop','px_grp',,_coop_lp)
   ?}
?};
PX_GRP.cntx_pop();
PX_GRP.get();
{? _can_continue>0
|| _result:=1
?};
_result


\queue_check
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Przed przystapieniem do planowania wykonuje kontrole elementow w kolejce
::   WE: [_a] - PX_VER.ref() - wersja ktorej kolejke kontrolowac lub biezacy rekord
::       [_b] - _args - argumenty dla funkcji raportujacej progress
::                      wynik dzialania exec('plan_progress_a','px_logix')
::       [_c] - INTEGER - 0/[1] - czy porownywac czas modyfikacji kontrolowanej wersji
::                                z planem glownym
::       [_d] - obj_new - tablica refów z zablokowanymi przepisami, jeżeli nie podana, to blokowanie nie będzie robione
::   WY: 0 - porazka - kolejka nie nadaje sie do planowania
::       1 - sukces - mozna planowac kolejke
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

{? var_pres('_b')>100
|| _argsprog:=_b
|| _argsprog:=exec('plan_progress_a','px_logix')
?};

_mod_compare:=1;
{? var_pres('_c')=type_of(0)
|| _mod_compare:=_c
?};
_locked:=~~;
{? var_pres('_d')>100
|| _locked:=_d
?};

_result:=1;
_can_continue:=1;

_txtOneV:=
   {? exec('is_one_version','px_param')
   || '\n\n'+
      'Problem może dotyczyć kolejki innego zestawu.\n'
      'Wybierz opcję -- brak -- w polu Zestaw.'@
   || ''
   ?};

PX_VER.cntx_psh();
PX_KONT.cntx_psh();
{? _ref<>null()
|| PX_VER.clear();
   {? PX_VER.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _argsprog.SIZELOC:=7;
   {? _argsprog.MODE=2
   || _argsprog.MULTI.ph_ssize(,7)
   ?};
:: Sprawdzam czy w miedzy czasie ktos inny nie zaakceptowal planu
   {? _mod_compare>0
   ||
      {? _argsprog.MODE=2
      || _argsprog.MULTI.ph_sname(,'Porównywanie czasu modyfikacji kolejki...'@)
      ?};
      _argsprog.SIZELOC:=8;
      {? _argsprog.MODE=2
      || _argsprog.MULTI.ph_ssize(,8)
      ?};
      _mainver:=exec('get_replan_version','px_ver');
      _can_continue:=1;
      _mod_chk:=exec('mod_chk','px_ver',_mainver,PX_VER.ref());
      {? _mod_chk>0
      || _can_continue:=1
      |? _mod_chk=0
      || _can_continue:=exec('mod_warn','px_ver',_mainver,PX_VER.ref());
         {? _can_continue=0
         || _result:=0
         ?}
      |? _mod_chk<0
      || _can_continue:=0;
         FUN.emsg('Porównanie czasu modyfikacji wersji zakończone niepowodzeniem. Przerwanie planowania.'@)
      ?};
::    raportuje progress
      exec('plan_progress','px_logix',_argsprog,1)
   ?};

:: aktualizacja elementów kolejki
   {? _can_continue>0
   || {? _argsprog.MODE=2
      || _argsprog.MULTI.ph_sname(,'Aktualizacja elementów kolejki...'@)
      ?};
      _can_continue:=exec('queue_update','px_logix',PX_VER.ref(),_argsprog);
::    raportuje progress
      exec('plan_progress','px_logix',_argsprog,1)
   ?};

:: kontrola zaleznosci pomiedzy grupami
   {? _can_continue>0
   ||
      {? _argsprog.MODE=2
      || _argsprog.MULTI.ph_sname(,'Kontrola zależności pomiędzy obiektami grupującymi w kolejce...'@)
      ?};
      KOMM.init(200,,'Kontrola zależności pomiędzy obiektami grupujacymi w kolecje.'@);
      _can_continue:=exec('UpdatePX_VER','px_con_g',PX_VER.ref());

      {? _can_continue>0
      || {? exec('verify_grp_conn','px_grp',PX_VER.ref())=0
         || _result:=0;
            _msg:='W kolejce istnieją elementy powiązane między sobą z niepoprawnie ustawionymi zwrotami.\n'
                  'Szczegółowe informacje dostępne są z poziomu funkcji \'Komunikaty\'.\n %1'@[_txtOneV];
            FUN.emsg(_msg)
         ?}
      ?};

::    raportuje progress
      exec('plan_progress','px_logix',_argsprog,1);

      {? var_pres('PxSelect')>100 || exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp) ?};

      {? _can_continue<=0
      || KOMM.select()
      ?};
::   {? FUN.ask('Wygenerowano dodakowe obiekty do planu, czy chcesz podejrzeć kolejkę?') || return() ?};
      ~~
   ?};
:: kontrola poprawnosci przepisow planistycznych - czy korzystaja z nieaktywnych kontenerow i takietam
   {? _can_continue>0
   ||
      {? _argsprog.MODE=2
      || _argsprog.MULTI.ph_sname(,'Weryfikacja przepisów planistycznych...'@)
      ?};
      _chk_tex:=exec('verify_grp_tex','px_grp',PX_VER.ref(),_locked);
      {? _chk_tex<>''
      || _msg:='W następujących grupach występują nieprawidłowości w przepisach:\n %1.\n\n'
               'Szczegółowe informacje dostępne są z poziomu funkcji \'Komunikaty\'.\n\n %2'@[_chk_tex-2,_txtOneV];
         FUN.emsg(_msg);
         _result:=0;
         ~~
      ?};

::    raportuje progress
      exec('plan_progress','px_logix',_argsprog,1);

      {? _argsprog.MODE=2
      || _argsprog.MULTI.ph_sname(,'Kontrola ilości do zaplanowania...'@)
      ?};

      _chk_il:=exec('verify_grp_il','px_grp',PX_VER.ref());
      {? _chk_il=0
      || _result:=0;
         _msg:='W kolejce istnieją przekroczenia ilości, które można było zaplanować.\n';
               'Szczegółowe informacje dostępne są z poziomu funkcji \'Komunikaty\'. %1'@[_txtOneV];
         FUN.emsg(_msg);
         ~~
      ?};
::    raportuje progress
      exec('plan_progress','px_logix',_argsprog,1)
   ?};
   {? _can_continue>0
   ||
      {? _argsprog.MODE=2
      || _argsprog.MULTI.ph_sname(,'Weryfikacja powiązań grup operacji...'@)
      ?};

::    Kontrola czy kolejka zawiera obiekty ktore maja operacje w grupie operacji, ale same nie sa w calosci zaplanowane
::    w planie operacyjnym - w takim przypadku nastapi rozjazd miedzy planem strategicznym
::    a operacyjnym (operacje w grupie beda w zupelnie innym miejscu niz plan strategiczny)
      _groper:=exec('verify_groper','px_grp',PX_VER.ref());
      {? _groper=0
      || _result:=0;
         _msg:='W kolejce istnieją zlecenia, które w Planie operacyjnym mają tylko operację grupową.\n'
               'Szczegółowe informacje dostępne są z poziomu funkcji \'Komunikaty\'. %1'@[_txtOneV];
         FUN.emsg(_msg);
         ~~
      |? _groper=-1
      || _result:=0;
         _msg:='W kolejce istnieją grupy operacji z niezgodnymi zwrotami względem zleceń które zawierają.\n'
               'Szczegółowe informacje dostępne są z poziomu funkcji \'Komunikaty\'. %1'@[_txtOneV];
         FUN.emsg(_msg);
         ~~
      ?};


::    raportuje progress
      exec('plan_progress','px_logix',_argsprog,1)
   ?};
   {? _can_continue>0
   ||
      {? _argsprog.MODE=2
      || _argsprog.MULTI.ph_sname(,'Weryfikacja punktów czasowych...'@)
      ?};

::    Kontrola poprawnosci punktow czasowych - czy sie nie zazebiaja na siebie itp
      {? exec('verify_grp_poi','px_grp',PX_VER.ref())=0
      || _result:=0;
         _msg:='W kolejce istnieją grupy posiadające nieprawidłowe punkty czasowe.\n'
               'Szczegółowe informacje dostępne są z poziomu funkcji \'Komunikaty\'.%1'@[_txtOneV];
         FUN.emsg(_msg);
         ~~
      ?}
   ?};

   {? _can_continue>0
   ||
      {? _argsprog.MODE=2
      || _argsprog.MULTI.ph_sname(,'Weryfikacja zwrotów...'@)
      ?};

::    Kontrola poprawnosci punktow zwrotow - czy nie ma konfliktu z opcja kontynuowania planu
::    poza termin realizacji
      {? exec('verify_grp_zwr','px_grp',PX_VER.ref())=0
      || _result:=0;
         _msg:='W kolejce istnieją grupy posiadające nieprawidłowe zwroty.\n'
               'Szczegółowe informacje dostępne są z poziomu funkcji \'Komunikaty\'.%1'@[_txtOneV];
         FUN.emsg(_msg);
         ~~
      ?};
::    raportuje progress
      exec('plan_progress','px_logix',_argsprog,1)
   ?};
   {? _can_continue>0
   ||
      {? _argsprog.MODE=2
      || _argsprog.MULTI.ph_sname(,'Weryfikacja terminów \'Planuj do\'...'@)
      ?};

::    Kontrola poprawnosci punktow zwrotow - czy nie ma konfliktu z opcja kontynuowania planu
::    poza termin realizacji
      {? exec('verify_grp_end','px_grp',PX_VER.ref())=0
      || _result:=0;
         _msg:='W kolejce istnieją grupy posiadające terminy \'Planuj do\' w przeszłości.\n'
               'Szczegółowe informacje dostępne są z poziomu funkcji \'Komunikaty\'.%1'@[_txtOneV];
         FUN.emsg(_msg);
         ~~
      ?};
::    raportuje progress
      exec('plan_progress','px_logix',_argsprog,1)
   ?};

   {? _argsprog.MODE=2
   || {? _can_continue>0
      || _argsprog.MULTI.ph_sname(,'Aktualizacja i weryfikacja kolejki zakończona powodzeniem.'@)
      || _argsprog.MULTI.ph_sname(,'Aktualizacja i weryfikacja kolejki zakończona niepowodzeniem.'@)
      ?}
   ?}
?};
PX_VER.cntx_pop();
PX_KONT.cntx_pop();
_result


\queue_check_one
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Przed przystapieniem do planowania wykonuje kontrole elementu w kolejce
::   WE: [_a] - PX_GRP.ref - lub bieżący rekord
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _grps:=exec('ref_table','#table');

:: Aktualizacja powiazań dla elementu kolejki
   _can_continue:=exec('UpdatePX_GRP','px_con_g',PX_GRP.ref(),_grps,,1);
   {? _can_continue>0
   || exec('reorder_px_ver','px_con_g',PX_GRP.PX_VER)
   ?};

:: Weryfikacja powiązań dla elementu kolejki
   {? _can_continue>0
   || _can_continue:=exec('verify','px_con_g')
   ?};

:: Weryfikacja poprawności przepisu
   {? _can_continue>0 & PX_GRP.PX_TEX<>null()
   || _verify:=exec('verify_grp_tex_core','px_grp');
      {? _verify<>''
      || _can_continue:=0
      ?}
   ?};

:: Weryfikacja ilości w kolejce
   {? _can_continue>0
   || _can_continue:=exec('verify_grp_il_core','px_grp')
   ?};

:: Weryfikacja powiązań z planem operacyjnym
   {? _can_continue>0
   || _can_continue:=exec('verify_groper_core','px_grp')
   ?};

:: Weryfikacja punktów czasowych
   {? _can_continue>0
   || _can_continue:=exec('verify','px_point',PX_GRP.ref())
   ?};

:: Weryfikacja zwrotów
   {? _can_continue>0
   || _can_continue:=exec('verify_grp_zwr_core','px_grp')
   ?};

:: Weryfikacja granicy czasowej 'do'
   {? _can_continue>0
   || _can_continue:=exec('verify_grp_end_core','px_grp')
   ?};
   ~~
?};
PX_GRP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\przelicz_action
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PULPIT (.DSK)
::  UTW: WH [12.41]
:: OPIS: Akcja 'Przelicz plan' w glownym oknie planu
::   WE: _a - czy odswiezac glowne okno planu po przeliczeniu
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_refresh:=_a;
_ver:=PX_VAR.VER_QUE;

_result:=0;
_can_continue:=1;

_one_ver:=exec('is_one_version','px_param');
{? _one_ver>0
||
   {? exec('is_whatif','px_ver',_ver)>0
   || _msg:='Czy uruchomić przeliczenie symulacji?'@
   || _msg:='Czy uruchomić przeliczenie planu?\n'
            'Plan podczas przeliczania będzie niedostępny do edycji dla innych użytkowników.'@
   ?};
   _choice:=FUN.ask(_msg);

   {? _choice=1
   ||
::    Zatrzymuje okresowe uruchamianie akcji na czas przeliczenia zeby okno nie mrugalo
      exec('stop_timers','#desktop','','nawigacja');

::    Uruchamiam przeliczenie planu
      _can_continue:=exec('mainver_replan','px_logix',_refresh);

::    Uruchamiam okresowe uruchamianie akcji
      exec('start_timers','#desktop','','nawigacja')
   ?}
|| _can_continue:=0;
   FUN.info('Akcja dostępna tylko jeśli parametr \'Praca na jednej wersji planu\' włączony.'@)
?};
{? _can_continue>0
|| _result:=1
?};
_result


\chk_sim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Sprawdza, czy mozna wykonac wymulacje planu
::----------------------------------------------------------------------------------------------------------------------
_version:=exec('get_mainversion','px_ver');
_one_ver:=exec('is_one_version','px_param');

:: Sprawdzam, czy wszystkie kontenery (zasoby) wersji glownej planu sa przypisane do zestawow planistycznych
:: (potrzebne gdy praca na jednej wersji)
{? _one_ver & exec('chk_set','px_kont',_version)=0
|| _msg:='Nie wszystkie zasoby są przypisane do \'Zestawów planistycznych\'.\n'
         'Aby wykonać symulację należy ustawić wszystkim zasobom ten parametr\n'
         '(Ustawienia i parametryzacja ->Zasoby planu strategicznego).'@;
   FUN.emsg(_msg);
   return(0)
?};

:: Sprawdzam, czy wszystkie kontenery (zasoby) wersji glownej planu NIE sa przypisane do zestawow planistycznyc
:: (potrzebne gdy praca na wielu wersjach)
{? ~_one_ver & exec('chk_set1','px_kont',_version)=0
|| _msg:='Niektóre zasoby są przypisane do \'Zestawów planistycznych\'.\n'
         'Aby wykonać symulację należy usunąć wszystkim zasobom ten parametr\n'
         '(Ustawienia i parametryzacja ->Zasoby planu strategicznego).\n\n'
         'Uwaga: do redagowania powiązań z zestawami należy parametr 500365 ustawić na wartość \'T\'.'@;
   FUN.emsg(_msg);
   return(0)
?};
1


\renumerate_cups
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Wykonuje renumeracje na wszystkich pojemnikach wersji poczawszy od dzis
::   WE: _a - PX_VER.ref
::       _b - _args - argumenty dla funkcji raportujacej progress
::                     wynik dzialania exec('plan_progress_a','px_logix')
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_argsprog:=_b;

PX_GRP.cntx_psh();
PX_GRP.index('PLAN2');
PX_CUP.cntx_psh();
PX_CUP.index('TM_END');
PX_KONT.cntx_psh();
PX_KONT.index('ACT');
PX_KONT.prefix('T',_px_ver);
{? PX_KONT.first()
||
   _tm_start:=PX_CUP.tm_stamp();

:: Wyznaczam termin od ktorego bede sortowal na podstawie kolejki - biore 'Planuj od' pierwszego
:: elementu
   PX_GRP.prefix(_px_ver,'N','N');
   {? PX_GRP.first()
   || _tm_start:=PX_GRP.TM_START
   ?};

   {!
   |?
      PX_CUP.prefix(PX_KONT.ref());
      {? PX_CUP.find_ge(_tm_start)
      ||
         {!
         |? exec('renumerate','px_poz',PX_CUP.ref());
            PX_CUP.next()
         !}
      ?};
      {? _argsprog.MODE=2
      || _argsprog.MULTI.ph_sname(,'Sortowanie planu na zasobie: %1'@[PX_KONT.SYMBOL])
      ?};

      exec('plan_progress','px_logix',_argsprog,1);
      PX_KONT.next()
   !};

   {? _argsprog.MODE=2
   || _argsprog.MULTI.ph_sname(,'Sortowanie planu zakończone powodzeniem.'@)
   ?}
?};
PX_CUP.cntx_pop();
PX_KONT.cntx_pop();
PX_GRP.cntx_pop();
~~


\task_size_renum
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Zwraca wielkosc zadania - sortowanie planu
::   WE: _a - PX_VER.ref
::   WY: REAL - rozmiar zadania
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;

_result:=0;

PX_KONT.cntx_psh();
PX_KONT.index('ACT');
PX_KONT.prefix('T',_px_ver);
_result:=PX_KONT.size();
PX_KONT.cntx_pop();
_result


\oper_first
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Bada czy jest jeszcze jakaś operacja paczki bez poprzedników/następników która nie została
::       jeszcze zaplanowana - ustawia kontekst paczki na ten rekord, zmienia indeks paczki
::   WE: _a - obj_new() - obiekt paczki
::       _b - INTEGER - kierunek planowania
::   WY: 0 - nie znaleziono operacji bez poprzedników/następników która byłaby niezaplanowana
::       1 - znaleziono niezaplanowaną operację bez poprzedników następników
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_pxpack:=_a;
_dir:=_b;

_paczka:=_pxpack.Paczka;

_result:=0;

_paczka.index(_pxpack.Ndx_fwd);
_paczka.prefix('K');
{? _dir>0
||

:: Planowanie do przodu - sprawdzam czy są poprzedniki
   {? _paczka.first()
   || {!
      |? {? _paczka.PLANNED<>'T'
         ||
            _paczka.cntx_psh();
            _paczka.prefix('P',_paczka.NUM);
            {? _paczka.size()=0
            || _result:=1
            ?};
            _paczka.cntx_pop()
         ?};
         _result=0 & _paczka.next()
      !}
   ?}
|? _dir<0
||
:: Planowanie wstecz - sprawdzam następniki

   {? _paczka.last()
   || {!
      |? {? _paczka.PLANNED<>'T'
         ||
            _paczka.cntx_psh();
            _paczka.prefix('N',_paczka.NUM);
            {? _paczka.size()=0
            || _result:=1
            ?};
            _paczka.cntx_pop()
         ?};
         _result=0 & _paczka.prev()
      !}
   ?}
?};
_result


\oper_nast_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Sprawdza czy można zaplanować operację - aktualny rekord paczki. Przydatne dla algorytmu rekurencyjnego
::       bo musi sprawdzić czy wszystkie poprzedniki/następniki danej operacji zostały już zaplanowane
::   WE: _a - obj_new() - obiekt paczki
::       _b - INTEGER - kierunek planowania
::   WY: 0 - nie można planować bo nie wszystkie poprzednie/następne są zaplanowane
::       1 - można planować
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_pxpack:=_a;
_dir:=_b;

_paczka:=_pxpack.Paczka;

_result:=1;

{? _paczka.TM_MIN>0 | _paczka.TM_MAX>0
||
:: Jeżeli paczka ma punkt czasowy to nie sprawdzam czy ma zaplanowane poprzedniki, następniki, tylko zawsze planuję
   _result:=1
||
   _paczka.cntx_psh();
   _paczka.index(_pxpack.Ndx_fwd);
   {? _dir>0
   ||
::    Planowanie do przodu - sprawdzam poprzedniki
      _paczka.prefix('P',_paczka.NUM);
      {? _paczka.first()
      || {!
         |? {? _paczka.UID_SRC>0
            || _paczka.cntx_psh();
               _paczka.index(_pxpack.Ndx_uid);
               _paczka.prefix(_paczka.UID_SRC);
               {? _paczka.first()
               ||  {? _paczka.PLANNED<>'T'
                   || _result:=0
                   ?}
               ?};
               _paczka.cntx_pop()
            ?};
            _paczka.next() & _result>0
         !}
      ?}
   |? _dir<0
   ||
::    Planowanie wstecz - sprawdzam następniki
      _paczka.prefix('N',_paczka.NUM);
      {? _paczka.first()
      || {!
         |? {? _paczka.UID_SRC>0
            || _paczka.cntx_psh();
               _paczka.index(_pxpack.Ndx_uid);
               _paczka.prefix(_paczka.UID_SRC);
               {? _paczka.first()
               ||  {? _paczka.PLANNED<>'T'
                   || _result:=0
                   ?}
               ?};
               _paczka.cntx_pop()
            ?};
            _paczka.next() & _result>0
         !}
      ?}
   ?};
   _paczka.cntx_pop()
?};
_result


\oper_has_next
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Sprawdza czy operacja ma następniki
::   WE: _a - obj_new() - obiekt paczki
::       [_b] - INTEGER - [0]/1 - czy omijać wykonane w całości operacje
::       [_c] - tab_tmp - dla wywołań rekurencyjnych: tablica z odwiedzonymi już rekordami
::   WY: 0 - brak następników
::       1 - są następniki
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_pxpack:=_a;
_omit_wyk:=0;
{? var_pres('_b')=type_of(0)
|| _omit_wyk:=_b
?};

_visted:=1;
{? var_pres('_c')>100
|| _visted:=_c
|| _visted:=exec('ref_table','#table')
?};

_paczka:=_pxpack.Paczka;

_result:=0;

_paczka.cntx_psh();
_paczka.index(_pxpack.Ndx_fwd);
_paczka.prefix('N',_paczka.NUM);
{? _paczka.first()
|| {!
   |? {? _paczka.UID_SRC>0
      || _paczka.cntx_psh();
         _paczka.index(_pxpack.Ndx_uid);
         _paczka.prefix(_paczka.UID_SRC);
         {? _paczka.first()
         ||
            _can_continue:=1;
            {? _omit_wyk>0
            || {? exec('pck_oper_empty','px_tex',_paczka)=0
               || _can_continue:=0
               ?};
               {? _can_continue>0
               || _result:=1
               |? _can_continue=0
               || {? _visted.r_find(_paczka.ref())=0
                  || _visted.add(_paczka.ref());
::                   !!! REKURENCJA !!!
                     _result:=exec('oper_has_next','px_logix',_pxpack,_omit_wyk,_visted)
                  ?}
               ?}
            || _result:=1
            ?}
         ?};
         _paczka.cntx_pop()
      ?};
      _paczka.next() & _result>0
   !}
?};
_paczka.cntx_pop();
_result


\oper_has_prev
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Sprawdza czy operacja ma poprzedniki
::   WE: _a - obj_new() - obiekt paczki
::       [_b] - INTEGER - [0]/1 - czy omijać wykonane w całości operacje
::       [_c] - tab_tmp - dla wywołań rekurencyjnych: tablica z odwiedzonymi już rekordami
::   WY: 0 - brak poprzedników
::       1 - są poprzedniki
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_pxpack:=_a;
_omit_wyk:=0;
{? var_pres('_b')=type_of(0)
|| _omit_wyk:=_b
?};

_visted:=1;
{? var_pres('_c')>100
|| _visted:=_c
|| _visted:=exec('ref_table','#table')
?};

_paczka:=_pxpack.Paczka;

_result:=0;

_paczka.cntx_psh();
_paczka.index(_pxpack.Ndx_fwd);
_paczka.prefix('P',_paczka.NUM);
{? _paczka.first()
|| {!
   |? {? _paczka.UID_SRC>0
      || _paczka.cntx_psh();
         _paczka.index(_pxpack.Ndx_uid);
         _paczka.prefix(_paczka.UID_SRC);
         {? _paczka.first()
         || _can_continue:=1;
            {? _omit_wyk>0
            || {? exec('pck_oper_empty','px_tex',_paczka)=0
               || _can_continue:=0
               ?};
               {? _can_continue>0
               || _result:=1
               |? _can_continue=0
               || {? _visted.r_find(_paczka.ref())=0
                  || _visted.add(_paczka.ref());
::                   !!! REKURENCJA !!!
                     _result:=exec('oper_has_prev','px_logix',_pxpack,_omit_wyk,_visted)
                  ?}
               ?}
            || _result:=1
            ?}
         ?};
         _paczka.cntx_pop()
      ?};
      _paczka.next() & _result>0
   !}
?};
_paczka.cntx_pop();
_result


\oper_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Z wszystkich poprzedników lub następników aktualnego rekordu paczki pobiera czas
::       od którego powinna zacząć się aktualna operacja paczki
::       KONTEKST PRACY - rekord paczki
::   WE: _a - obj_new() - obiekt paczki
::       _b - INTEGER - kierunek planowania
::       [_c] - tab_tmp - tabelka tymczasowa zawierająca czasy w planie poszczególnych etapów
::       [_d] - INTEGER - rodzaj wyniku: [1] - zwraca czas
::                                        2  - zwraca _paczka.UID
::       [_e] - INTEGER - [0]/1 - czy omijać wykonane w całości operacje
::       [_f] - tab_tmp - dla wywołań rekurencyjnych: tablica z odwiedzonymi już rekordami
::   WY: REAL - możliwy czas startu lub UID rekordu paczki z którego można odczytać ten czas startu
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_pxpack:=_a;
_dir:=_b;
_times:=~~;
{? var_pres('_c')>100
|| _times:=_c
?};
_res_typ:=1;
{? var_pres('_d')=type_of(0)
|| _res_typ:=_d
?};
_omit_wyk:=0;
{? var_pres('_e')=type_of(0)
|| _omit_wyk:=_e
?};

_visted:=1;
{? var_pres('_f')>100
|| _visted:=_f
|| _visted:=exec('ref_table','#table')
?};

_paczka:=_pxpack.Paczka;

_result:=0;

{? type_of(_times)>100
|| _times.cntx_psh()
?};
_paczka.cntx_psh();
_paczka.index(_pxpack.Ndx_fwd);
_res_time:=0;
_res_uid:=0;

{? _dir>0
||
:: Planowanie do przodu - szukam czasu w poprzednikach
   _paczka.prefix('P',_paczka.NUM);
   {? _paczka.first()
   || {!
      |?
         {? type_of(_times)>100
         ||
::          Jeśli tabelka z czasami podana to biorę z niej
            _paczka.cntx_psh();
            _num:=-1;
            _paczka.index(_pxpack.Ndx_uid);
            _paczka.prefix(_paczka.UID_SRC);
            {? _paczka.first()
            || _num:=_paczka.NUM
            ?};

            {? _num>=0
            ||
               _paczka.index(_pxpack.Ndx_fwd);
               _paczka.prefix('K',_num);
               {? _paczka.first()
               ||
                  _can_continue:=1;
                  {? _omit_wyk>0
                  || {? exec('pck_oper_empty','px_tex',_paczka)=0
                     || _can_continue:=0
                     ?};
                     {? _can_continue=0
                     || {? _visted.r_find(_paczka.ref())=0
                        || _visted.add(_paczka.ref());
::                         !!! REKURENCJA !!!
                           _res_rec:=exec('oper_start','px_logix',_pxpack,_dir,_times,_res_typ,_omit_wyk,_visted);
                           {? _res_time=0 | _res_time<_res_rec
                           || _res_time:=_res_rec
                           ?}
                        ?}
                     ?}
                  ?};
                  {? _can_continue>0
                  ||
::                   Przeszedłem z rekordu typu 'Poprzednik' na prawdziwy rekord operacji
::                   iteruję po zasobach które ta operacja zużywa
                     {!
                     |?
                        _times.prefix(_paczka.UID);
                        {? _times.first()
                        || {? _res_time=0 | _res_time<_times.TM_END
                           || _res_time:=_times.TM_END;
                              _res_uid:=_paczka.UID_SRC
                           ?}
                        ?};
                        _paczka.next()
                     !}
                  ?}
               ?}
            ?};
            _paczka.cntx_pop()
         ||
::          Tabelka z czasami nie została podana, więc opieram się na tym co znajduje się w paczce
            _paczka.cntx_psh();
            _paczka.index(_pxpack.Ndx_uid);
            _paczka.prefix(_paczka.UID_SRC);
::          Przechodzę z rekordu paczki typu Poprzednik na właściwy rekord który był planowany
            {? _paczka.first()
            || {? _res_time=0 | _res_time<_paczka.PL_END
               || _res_time:=_paczka.PL_END;
                  _res_uid:=_paczka.UID
               ?}
            ?};
            _paczka.cntx_pop()
         ?};
         _paczka.next()
      !}
   ?}
|? _dir<0
||
:: Planowanie wstecz - szukam czasu w następnikach
   _paczka.prefix('N',_paczka.NUM);
   {? _paczka.first()
   || {!
      |?
         {? type_of(_times)>100
         ||
::          Jeśli tabelka z czasami podana to biorę z niej
            _paczka.cntx_psh();
            _num:=-1;
            _paczka.index(_pxpack.Ndx_uid);
            _paczka.prefix(_paczka.UID_SRC);
            {? _paczka.first()
            || _num:=_paczka.NUM
            ?};

            {? _num>=0
            ||
               _paczka.index(_pxpack.Ndx_fwd);
               _paczka.prefix('K',_num);
               {? _paczka.first()
               ||
                  _can_continue:=1;
                  {? _omit_wyk>0
                  || {? exec('pck_oper_empty','px_tex',_paczka)=0
                     || _can_continue:=0
                     ?};
                     {? _can_continue=0
                     || {? _visted.r_find(_paczka.ref())=0
                        || _visted.add(_paczka.ref());
::                         !!! REKURENCJA !!!
                           _res_rec:=exec('oper_start','px_logix',_pxpack,_dir,_times,_res_typ,_omit_wyk,_visted);
                           {? _res_time=0 | _res_time>_res_rec
                           || _res_time:=_res_rec
                           ?}
                        ?}
                     ?}
                  ?};
                  {? _can_continue>0
                  ||
::                   Przeszedłem z rekordu typu 'Poprzednik' na prawdziwy rekord operacji
::                   iteruję po zasobach które ta operacja zużywa
                     {!
                     |?
                        _times.prefix(_paczka.UID);
                        {? _times.first()
                        || {? _res_time=0 | _res_time>_times.TM_START
                           || _res_time:=_times.TM_START;
                              _res_uid:=_paczka.UID_SRC
                           ?}
                        ?};
                        _paczka.next()
                     !}
                  ?}
               ?}
            ?};
            _paczka.cntx_pop()
         ||
::          Tabelka z czasami nie została podana, więc opieram się na tym co znajduje się w paczce
            _paczka.cntx_psh();
            _paczka.index(_pxpack.Ndx_uid);
            _paczka.prefix(_paczka.UID_SRC);
::          Przechodzę z rekordu paczki typu Następnik na właściwy rekord który był planowany
            {? _paczka.first()
            || {? _res_time=0 | _res_time>_paczka.PL_START
               || _res_time:=_paczka.PL_START;
                  _res_uid:=_paczka.UID
               ?}
            ?};
            _paczka.cntx_pop()
         ?};
         _paczka.next()
      !}
   ?}
?};
{? type_of(_times)>100
|| _times.cntx_pop()
?};
{? _res_typ=1
|| _result:=_res_time
|? _res_typ=2
|| _result:=_res_uid
?};
_paczka.cntx_pop();
_result


\last_coef_save
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Zapamiętuje dla ostatniej pozycji planu proporcję jaką ta pozycja zeżarła w pojemniku
::       do którego trafiła
::       Dla funkcji polepszających następstwo operacji
::       Kontekst pracy - PX_CUP
::   WE: _a - obj_new() - tablica zeżartych pojemności przez pozycję planu
::       _b - tab_tmp() - paczka planistyczna
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_eaten:=_a;

_paczka:=_b;

{? type_of(_paczka)>100
|| _il_wym:=PX_CUP.PX_KONT().IL_WYM;
   _infinity:=exec('infinity_array','px_kont');
   {! _it:=1.._il_wym
   |! _max:=($('_paczka:=_a;_paczka.CAP_MAX'+$_it))(_paczka);
      _coef:=0;
      {? _max=0
      ||
::       Jeśli w paczce nie ma maksimum to biorę pojemność maksymalną pojemnika

         {? _infinity[_it]>0
         ||
::          Pojemność nieskończona
            _coef:=1
         ||
::          Pojemność skończona
            _max:=($('PX_CUP.CAP_MAX'+$_it))()
         ?}
      ?};

      _rule:=$('_paczka:=_a;_paczka.LSTCOEF'+$_it+':=_b');

      {? _coef<>1 & _max>0
      || _coef:=1-(_eaten[_it]/_max);
         _coef:=exec('min','#math',_coef,1);
         _coef:=exec('max','#math',_coef,0)
      ?};
      _rule(_paczka,_coef)
   !};
   _paczka.put()
?};
~~


\last_coef_use
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Używając proporcji z ostatniej pozycji planu poprzednich operacji wyznaczam maksimum jakie mogę zaplanować
::       dla bieżącej operacji
::       Dla funkcji polepszających następstwo operacji
::       Kontekst pracy - PX_CUP
::   WE: _a - paczka planistyczna
::       _b - INTEGER - zwrot planowania
::   WY: obj_new() - tablica maksimów
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_pxpack:=_a;
_dir:=_b;
_il_wym:=PX_CUP.PX_KONT().IL_WYM;

_result:=obj_new(_il_wym);
_last_coefs:=obj_new(_il_wym);
{! _it:=1.._il_wym
|! _last_coefs[_it]:=-1;
   _result[_it]:=-1
!};

{? type_of(_pxpack)>100
||
   _paczka:=_pxpack.Paczka;

   _paczka.cntx_psh();
   {? _dir>0
   || _paczka.index(_pxpack.Ndx_nast_bck);
      _paczka.prefix('P',_paczka.NUM)
   || _paczka.index(_pxpack.Ndx_nast_fwd);
      _paczka.prefix('N',_paczka.NUM)
   ?};

   {? _paczka.first()
   || {!
      |?
::       Stoję na rekordzie paczki typu 'Poprzednik' lub 'Nastepnik - muszę przejść na operację którą
::       wkazuje
         _paczka.cntx_psh();
         _paczka.index(_pxpack.Ndx_uid);
         _paczka.prefix(_paczka.UID_SRC);
         {? _paczka.first()
         ||
            {! _it:=1.._il_wym
            |! _last:=($('_paczka:=_a;_paczka.LSTCOEF'+$_it))(_paczka);
               {? _last>-1
               ||
::                Ze współczynników poprzednich operacji wybieram minimum
                  {? _last_coefs[_it]=-1 | _last_coefs[_it]>_last
                  || _last_coefs[_it]:=_last
                  ?}
               ?}
            !}
         ?};
         _paczka.cntx_pop();
         _paczka.next()
      !}
   ?};
   _paczka.cntx_pop();
   _infinity:=exec('infinity_array','px_kont',PX_CUP.PX_KONT);
   {! _it:=1.._il_wym
   |! _max:=($('_paczka:=_a;_paczka.CAP_MAX'+$_it))(_paczka);
      {? _max=0
      ||
         {? _infinity[_it]>0
         ||
::          Pojemność nieskończona
            _result[_it]:=-2
         ||
::          Jeśli w paczce nie ma maksimum to biorę pojemność maksymalną pojemnika
            _max:=($('PX_CUP.CAP_MAX'+$_it))()
         ?}
      ?};

::    Obliczam wynik czyli nową wartość maksymalną jaką będę mógł umieścić w pojemniku
      {? _result[_it]>-2 & _last_coefs[_it]>-1
      || _result[_it]:=_last_coefs[_it]*_max
      |? _result[_it]=-2
      || _result[_it]:=-1
      ?};
      ~~
   !};
   ~~
?};
_result


\cup_structure_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Sprawdza czy aktualny pojemnik (dla pierwszej pozycji planu operacji) ma takie
::       same granice czasowe jak ostatni pojemnik poprzedniej operacji
::       Kontekst pracy - rekord PX_CUP
::       Dla funkcji polepszających następstwo operacji - metoda proporcji ilościowej
::   WE: _a - obj_new - obiekt paczki planistycznej
::       _b - INTEGER - kierunek planowania
::   WY: 0 - porażka, struktura inna, trzeba olać nakładkowanie i iść do następnego pojemnika
::       1 - sukces, można planować
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_pxpack:=_a;
_dir:=_b;

_paczka:=_pxpack.Paczka;
_result:=1;

{? _paczka.TM_MIN=0 & _paczka.TM_MAX=0
||
:: Sprawdzam tylko jeżeli paczka nie ma punktu czasowego
   _paczka.cntx_psh();
   {? _dir>0
   || _paczka.index(_pxpack.Ndx_nast_bck);
      _paczka.prefix('P',_paczka.NUM)
   || _paczka.index(_pxpack.Ndx_nast_fwd);
      _paczka.prefix('N',_paczka.NUM)
   ?};

   {? _paczka.first()
   ||
      {!
      |?
::    Stoję na rekordzie paczki typu 'Poprzednik' lub 'Nastepnik - muszę przejść na operację którą
::    wkazuje
         _paczka.cntx_psh();
         _paczka.index(_pxpack.Ndx_uid);
         _paczka.prefix(_paczka.UID_SRC);
         {? _paczka.first() & _paczka.LSTSTART>0 & _paczka.LSTEND>0
         || {? PX_CUP.TM_START<>_paczka.LSTSTART | PX_CUP.TM_END<>_paczka.LSTEND
            || _result:=0
            ?}
         ?};
         _paczka.cntx_pop();
         _paczka.next() & _result>0
      !}
   ?};
   _paczka.cntx_pop()
?};
_result


\oper_offset
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Przesuwa start operacji w oparciu o czas nakładkowania lub czas odczekania
::   WE: _a - PxPack - obiekt paczki
::       _b - REAL - czas wejściowy
::       _c - INTEGER - kierunek planowania
::   WY: REAL - nowy czas startu dla operacji
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_pxpack:=_a;
_paczka:=_pxpack.Paczka;
_tm_stamp:=_b;
_dir:=_c;


{? _dir>0
||
   {? _paczka.HAS_PREV='T'
   ||
::    Żeby zmienić czas startu operacji z powodu zdefiniowanego czasu nakładkowania
::    lub czasu transportu międzuoperacyjnego to operacja musi mieć poprzednika
::    Jeżeli nie ma poprzednika to znaczy że jest pierwsza w procesie i nie powinniśmy
::    modyfikować jej czasu startu, bo wynika on np z granic czasowych w kolejce
      {? _paczka.TTM>0
      ||
::       Czas odczekania dodajemy do czasu startu
         _tm_stamp+=_paczka.TTM
      ?};
      {? _paczka.NKO>0
      ||
::       Czas nakładkowania odejmujemy od czasu startu
         _tm_stamp-=_paczka.NKO
      ?}
   ?}
|? _dir<0
||
   {? _paczka.HAS_NEXT='T'
   ||
::    Żeby zmienić czas startu operacji z powodu zdefiniowanego czasu nakładkowania
::    lub czasu transportu międzuoperacyjnego to operacja musi mieć następnika
::    Jeżeli nie ma następnika to znaczy że jest ostatnia w procesie i nie powinniśmy
::    modyfikować jej czasu startu, bo wynika on np z granic czasowych w kolejce

::    Przy planowaniu w tył trzeba spojrzeć na czas nakładkowania i transportu następnych
::    operacji i wybrać maksymalne czasy nakładkowania
      _ttm:=0;
      _nko:=0;
      _paczka.cntx_psh();
      _num:=_paczka.NUM;
      _paczka.index(_pxpack.Ndx_fwd);
      _paczka.prefix('N',_num);
      _my_end:=0;

::    Wyliczam maksimum dla nakładkowania
      _max:=0;
      {? _paczka.first()
      || {!
         |? _paczka.cntx_psh();
            _paczka.index(_pxpack.Ndx_uid);
            _paczka.prefix(_paczka.UID_SRC);
            {? _paczka.first()
            || _offset:=_paczka.NKO-_paczka.TTM;
               _next:=_paczka.PL_START+_offset;
               {? _max=0 | _max>_next
               || _max:=_next
               ?}
            ?};
            _paczka.cntx_pop();
            _paczka.next()
         !}
      ?};

      {? _paczka.first()
      || {!
         |? _paczka.cntx_psh();
            _paczka.index(_pxpack.Ndx_uid);
            _paczka.prefix(_paczka.UID_SRC);
            {? _paczka.first()
            ||
               _offset:=_paczka.NKO-_paczka.TTM;
               _end:=_paczka.PL_START+_offset;

               {? _offset<>0
               ||
::                Przesuwam tylko jeżeli jest o co przesunąć
                  {? _offset<0
                  ||
::                   Przesunięcie w lewo - czas odczekania górą więc odsuwam od siebie operacje
                     {? _my_end=0 | _end<_my_end
                     || _my_end:=_end;
                        _tm_stamp:=exec('min','#math',_my_end,_tm_stamp)
                     ?}
                  |? _offset>0
                  ||
::                   Przesunięcie w prawo - czas nakładkowania górą więc nakładkuję, ale tylko w dozwolonych
::                   granicach

                     {? _my_end=0 | _end>_my_end
                     || _my_end:=_end;
                        {? _paczka.PL_START=_tm_stamp
                        ||
::                         Nakładkowuję tylko jeżeli operacja z czasem nakładkowania
::                         jest oryginalnym źródłem czasu dla operacji
                           _new_stamp:=exec('max','#math',_my_end,_tm_stamp);

::                         Nie mogę przekroczyć maksimum ze wszystkich następników
::                         bo wtedy zacznie nakładkować się za bardzo
                           {? _new_stamp>_max
                           || _tm_stamp:=_max
                           || _tm_stamp:=_new_stamp
                           ?}
                        ?}
                     ?}
                  ?}
               ?}
            ?};
            _paczka.cntx_pop();
            _paczka.next()
         !}
      ?};
      _paczka.cntx_pop();
      ~~
   ?}
?};
_tm_stamp


\zkp_simulation2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Dla pozycji zamowien szybkie planowanie - okreslenie albo sprawdzenie terminu realizacji
::   WE: _a - tabela tymczasowa z refami (analogiczna do ZK_P.sel_aget())
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_result:=0;

:: Sprawdzam konfiguracje programu
{? ~exec('chk_sim','px_logix') || return(_result) ?};
exec('opernast_init','px_init');
PX_VER.cntx_psh();
ZK_N.cntx_psh(); ZK_N.clear();
ZK_P.cntx_psh(); ZK_P.clear();

PX_VER.clear();
PX_VAR.VER_QUE:=null();
_can_continue:=1;

:: 1. Przygotowuje tymczasowa wersje planu do ktorej bede planowal
_ver_tmp:=exec('px_ver_temp','px_ver',0);

:: Sprawdzam czy mozna wykonac symulacje - czy są pozycje na wyroby lub polprodukty
_ready:=0;
ZK_P.prefix();
{? _tab.first()
|| {!
   |? {? ZK_P.seek(_tab.REF) & 'PW'*ZK_P.M().R>0
      || _ready:=1
      ?};
      _tab.next()
   !}
?};

{? _ready>0
||
:: Ide dalej tylko jesli wersja nie zostala jeszcze zaplanowana (w przypadku akcji grupowej, kolejne
:: wywolania tej funkcji nie spelnia tego warunku, bo juz pierwsze wywolanie wykona cala symulacje)

:: deklaracje obiektow dla komunikatow
   exec('JCQ_decl','#message');
   {? var_pres('KOMM')<100 || KOMM:=obj_new(@.CLASS.JCQ) ?};
   KOMM.init(200,,'Symulacja zamówienia'@,'',,,0);
   _err:='Pozycje zamówienia pominięte w symulacji'@;
   _errS:='Z powodu rodzaju materiału (surowiec)'@;
   _errH:='Z powodu rodzaju materiału (wyrób zewnętrzny)'@;
   _errD:='Z powodu nieokreślenia zwrotu planowania'@;
   _errP:='Z powodu umieszczenia w planie'@;

   {? PX_VER.seek(_ver_tmp)
   || PX_VAR.VER_QUE:=PX_VER.ref();
      {? PX_VER.STATUS=exec('status_temp','px_ver')
      ||
::       2. Przygotowuje 'kolejke' tymczasowa
::          Zawsze symuluje cale zamowienie - wszystkie pozycje

         _errlp:=KOMM.sect_beg('Przygotowywanie danych do symulacji planu.'@);

         ZK_P.prefix();
         {? _tab.first()
         ||
            {!
            |? {? ZK_P.seek(_tab.REF)
               ||
                  _what:=ZK_P.N().SYM+' '+'poz.'@+$ZK_P.POZ+'. '+ZK_P.M().KTM+' '+ZK_P.M().N;
                  _mainver:=exec('get_mainversion','px_ver');
                  _planwpp:=exec('zkp_planned','px_obj',ZK_P.ref(),_mainver);
                  {? _planwpp>0
                  || _can_continue:=0;
                     _msg:='Nie można symulować: %1. Powód: obiekt znajduje się już w planie.'@[_what];
                     KOMM.add(_msg,'xwin16.png:2')
                  |? ZK_P.M().RODZ='U'
                  || _can_continue:=0;
                     _msg:='Nie można symulować: %1. Powód: indeks materiałowy to usługa.'@[_what];
                     KOMM.add(_msg,'xwin16.png:2')
                  |? 'PW'*ZK_P.M().R>0
                  ||
                     _ilz:=ZK_P.ILZ;
                     _il_to_plan:=ZK_P.ILZ;
                     ZLZAM.index('ZMZL');
                     ZLZAM.prefix($ZK_P.ref());
                     {? ZLZAM.first()
                     ||
                        {!
                        |?
                           {? ZLZAM.ZL<>null()
                           || ZL.cntx_psh();
                              PX_OBJ.cntx_psh();
                              PX_OBJ.index('ZL');
                              ZL.clear();
                              {? ZL.seek(ZLZAM.ZL)
                              || _can_continue:=exec('zl2obj','px_obj');
                                 PX_OBJ.prefix(ZL.ref());
                                 {? _can_continue>0 & PX_OBJ.first()
                                 ||
::                                  Weryfikuję ilość w kolejce głównej
                                    _il_que:=exec('get_ilosc_que','px_obj',exec('get_mainversion','px_ver'),PX_OBJ.ref());
                                    _il_to_plan-=_il_que;
                                    {? _il_que>0 & _il_que>=PX_OBJ.IL
                                    || _can_continue:=0;
                                       _txt:='Na podstawie: %1 utworzono już zlecenia produkcyjne które są w planie.'@[_what];
                                       KOMM.add(_txt,14)
                                    ?}
                                 ?}
                              ?};
                              PX_OBJ.cntx_pop();
                              ZL.cntx_pop()
                           ?};

                           _ilz-=ZLZAM.ILZL;
::                           {? _can_continue>0
::                           ||
::                              _prep_ok:=exec('zl_prepare','px_logix',ZLZAM.ZL,_ver_tmp,ZK_P.PL_DIR);
::                              {? _prep_ok=0
::                              || _can_continue:=0
::                              ?}
::                           ?};

                           ZLZAM.next()
                        !}
                     ?};

                     {? _ilz>0
                     ||
                        _prep_ok:=exec('zkp_prepare','px_logix',ZK_P.ref(),_ver_tmp,_ilz,ZK_P.PL_DIR);
                        {? _prep_ok=0
                        || _can_continue:=0
                        ?}
                     || {? _il_to_plan>0
                        || _can_continue:=0;
                           _msg:='Na podstawie: %1 utworzono zlecenia produkcyjne na całą ilość. Symulacja zamówienia niemożliwa.'@[_what];
                           KOMM.add(_msg,'xwin16.png:2')
                        ?}
                     ?}
                  |? 'S'*ZK_P.M().R
                  || _can_continue:=0;
                     _msg:='Nie można symulować: %1. Powód: rodzaj materiału obiektu to surowiec.'@[_what];
                     KOMM.add(_msg,'xwin16.png:2')
                  |? 'H'*ZK_P.M().R
                  || _can_continue:=0;
                     _msg:='Nie można symulować: %1. Powód: rodzaj materiału obiektu to wyrób zewnętrzny.'@[_what];
                     KOMM.add(_msg,'xwin16.png:2')
                  ?}
               ?};
               _tab.next()
            !}
         ?};

         KOMM.sect_end();

::       Jesli nie bylo problemow to usuwam galaz komunikatow
         {? _can_continue>0
         || KOMM.del(_errlp)
         ?};

::       Sprawdzam czy symulowana wersja zawiera jakies grupy, jesli tak to kontynuuje, jesli nie przerywam
         PX_GRP.cntx_psh();
         PX_GRP.index('LP');
         PX_GRP.prefix(_ver_tmp,'Z');
         {? PX_GRP.size()>0
         || _can_continue:=1
         || _can_continue:=0
         ?};
         PX_GRP.cntx_pop();

::       3. URUCHAMIAM ALGORYTM PLANUJACY
         {? _can_continue>0
         ||
::          Pokazuje KOMMa z wykluczeniami
            KOMM.select();
            _choice:=FUN.choice(
                  'Wyświetlanie symulacji.\n'
                  'Dostępne opcje widoku:'@+'\n\n'
                  '● '+'Widok szczegółowy — całość\n'
                  '  (pełny widok planu wraz z innymi zamówieniami, zleceniami)'@+'\n\n'
                  '● '+'Widok szczegółowy — symulacja\n'
                  '  (pełny widok planu, ale tylko z symulowanymi pozycjami)'@+'\n\n'
                  '● '+'Bez widoku szczegółowego\n'
                  '  (wyłącznie symulacja planu w uproszczonym widoku)'@+'\n\n',,
                  'Szczegóły — &całość'@,'Szczegóły — &symulacja'@,'&Bez szczegółów'@
               );
            {? _choice>0
            ||
               _opt_view:=1;
               _opt_clone:=0;
               {? _choice=1
               || _opt_view:=2;
                  _opt_clone:=2
               |? _choice=2
               || _opt_view:=2;
                  _opt_clone:=0
               |? _choice=3
               || _opt_view:=1;
                  _opt_clone:=0
               ?};
               _argsplan:=exec('px_ver_plan_a','px_logix');
               _argsplan.DEST:=_ver_tmp;
               _argsplan.VIEW_MODE:=_opt_view;
               _argsplan.CLONE_MODE:=_opt_clone;
               _argsplan.EDIT:=0;
               _argsplan.CLEAN_Q:=0;
               {? PX_VAR.NAST_ALG=2
               || _argsplan.UPDATE_Q:=1
               || _argsplan.UPDATE_Q:=0
               ?};
               _argsplan.VERIFY_Q:=0;
               _argsplan.CONTEXT:='ZAM';
               _result:=exec('px_ver_plan','px_logix',_argsplan);

               {? _result=0
               ||
::                  FUN.emsg('Symulacja planu zakończona niepowodzeniem.')
                  ~~
               ||
::                po wykonaniu symulacji zmieniam status wersji
                  exec('status_set','px_ver',_ver_tmp,exec('status_sim_zkp','px_ver'));

::                po wykonaniu symulacji ustawiam zmienna PX_VAR.VIE_VER, wg ktorej bedzie odswiezone okno z planem
                  PX_VAR.VIE_VER:=_ver_tmp;

::                wyswietlenie uproszczonej wersji symulacji
                  {? _choice=3
                  || exec('select_any_core','px_plan',_ver_tmp,ZK_P,_tab)
                  ?};

::                wyswietlenie i potwierdzenie terminu/terminow realizacji zamowienia/pozycji zamowienia
                  exec('terminy_zkn','px_plan',_ver_tmp,_tab)
               ?}
            ?}
         || KOMM.add('Przygotowanie symulacji zakończone niepowodzeniem.'@,2,,1);
            KOMM.select()
         ?}
      ?}
   ?}
|| FUN.emsg('Pozycje nie zawierają ani wyrobów, ani półfabrykatów, aby przygotować symulację.'@)
?};
{? _result=0
||
   {? exec('is_one_version','px_param')>0
   ||
::    Jeśli praca na jednej wersji i zymulacja zakonczona niepowodzeniem to usuwam tą symulowaną wersję
      {? _ver_tmp<>null()
      || {? exec('delete','px_ver',_ver_tmp,0)=0
         || FUN.emsg('Usunięcie symulacji planu zamówienia zakończone niepowodzeniem.'@)
         ?}
      ?}
   ?}
?};

VAR_DEL.delete('PxSelect');
PX_VER.cntx_pop();
ZK_P.cntx_pop();
ZK_N.cntx_pop();
_result


\zl_simulation_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Symulacja zlecenia/zleceń
::   WE: _a - tabela tymczasowa zgodna z ZL.sel_aget()
::----------------------------------------------------------------------------------------------------------------------
_sel:=_a;

_result:=0;

:: Sprawdzam konfiguracje programu
{? ~exec('chk_sim','px_logix') || return(_result) ?};
exec('opernast_init','px_init');
PX_VER.cntx_psh();
ZL.cntx_psh();
ZK_P.cntx_psh();
VAR.cntx_psh();
ZK_P.index('NAG');

PX_VER.clear();

_can_continue:=1;

:: 1. Przygotowuje tymczasowa wersje planu do ktorej bede planowal
_ver_tmp:=exec('px_ver_temp','px_ver',0);
:: Sprawdzam czy mozna wykonac symulacje - czy na zleceniu sa wyroby lub polprodukty (a sa, wiec zawsze ok)
_ready:=1;

{? _ready>0
||
:: Ide dalej tylko jesli wersja nie zostala jeszcze zaplanowana (w przypadku akcji grupowej, kolejne
:: wywolania tej funkcji nie spelnia tego warunku, bo juz pierwsze wywolanie wykona cala symulacje)

:: deklaracje obiektow dla komunikatow
   exec('JCQ_decl','#message');
   {? var_pres('KOMM')<100 || KOMM:=obj_new(@.CLASS.JCQ) ?};
   KOMM.init(200,,'Symulacja zlecenia'@,'',,,0);

   {? PX_VER.seek(_ver_tmp)
   ||
      PX_VAR.VER_QUE:=PX_VER.ref();
      {? PX_VER.STATUS=exec('status_temp','px_ver')
      ||
         _err:='Przygotowywanie danych do symulacji planu.'@;
         _errlp:=KOMM.sect_beg(_err);
         _errors:=0;

::       2. Przygotowuje 'kolejke' tymczasowa
::          Zawsze symuluje cale zlecenie - wszystkie podzlecenia
         _prepared:=0;

         ZL.cntx_psh();

         {? _sel.first()
         || {!
            |? _can_continue:=1;
               ZL.prefix();
               {? ZL.seek(_sel.REF)
               ||
                  _ready:=1;
                  _top_rodzaj:=exec('top_rodzaj','zl_link',ZL.ref());

                  {? _top_rodzaj='Z' & exec('is_podzlec','zl_link',ZL.ref()) & ZL.RODZ_TEX='Z'
                  || _top_symbol:=exec('FindAndGet','#table',ZL,exec('top_level','zl_link',ZL.ref()),,"SYM",'');
::                   Stoję na zleceniu podrzędnym, którego nadrzędne ma przepis zintegrowany
::                   Symulacja takiego podzlecenia jest niemożliwa, bo nie ma przepisu
                     _ready:=0;
                     _msg:='Nie można symulować zlecenia: %1 ponieważ jest składnikiem zlecenia z przepisem zintegrowanym.\n'
                           'Należy symulować zlecenie nadrzędne: %2'@[ZL.SYM,_top_symbol];
                     KOMM.add(_msg,'xwin16.png:9');
                     _can_continue:=0
                  ?};

                  {? exec('subzlec_exist','zl_link',ZL.ref())=0 & ZL.RODZAJ<>'P'
                  || KOMM.add('Nie można symulować: %1. Zlecenie złożone bez zleceń podrzędnych.'@[ZL.SYM],
                              'xwin16.png:9'
                     );
                     _can_continue:=0
                  ?};

                  {? _can_continue>0 & ZL.PLAN_PX='T'
                  || KOMM.add('Nie można symulować: %1. Zlecenie jest już w planie strategicznym.'@[ZL.SYM],
                              'xwin16.png:9'
                     );
                     _can_continue:=0
                  ?};

                  {? _can_continue>0
                  || {? ZL.RODZAJ='P' | ZL.RODZ_TEX='Z'
                     || {? ZL.PL_DIR=0
                        || KOMM.add('Nie można symulować: %1. Nie określono zwrotu planowania.'@[ZL.SYM],
                              'xwin16.png:9'
                           );
                           _can_continue:=0
                        || {? exec('zl_prepare','px_logix',ZL.ref(),_ver_tmp,ZL.PL_DIR)=0
                           || _can_continue:=0
                           ?}
                        ?}
                     || ZL.cntx_psh();
                        ZL.index('NRNZL');
                        ZL.prefix(ZL.UNRZL);
                        {? ZL.first()
                        || {!
                           |? {? ZL.PL_DIR=0
                              || KOMM.add('Nie można symulować: %1. Nie określono zwrotu planowania.'@[ZL.SYM],
                                    'xwin16.png:9'
                                 );
                                 _can_continue:=0
                              || {? exec('zl_prepare','px_logix',ZL.ref(),_ver_tmp,ZL.PL_DIR)=0
                                 || _can_continue:=0
                                 ?}
                              ?};
                              ZL.next()
                           !}
                        ?};
                        ZL.cntx_pop()
                     ?}
                  ?}
               ?};
               {? _can_continue>0
               || _sel.next()
               || _errors:=1;
                  _sel.del(,1)=2
               ?}
            !}
         ?};
         ZL.cntx_pop();

         KOMM.sect_end();

::       Jesli nie bylo problemow to usuwam galaz komunikatow
         {? _errors=0
         || KOMM.del(_errlp)
         ?};

::       Sprawdzam czy symulowana wersja zawiera jakies grupy, jesli tak to kontynuuje, jesli nie przerywam
::       (ponowne ustalenie _can_continue)
         PX_GRP.cntx_psh();
         PX_GRP.index('LP');
         PX_GRP.prefix(_ver_tmp,'Z');
         {? PX_GRP.size()>0
         || _can_continue:=1
         || _can_continue:=0
         ?};
         PX_GRP.cntx_pop();

::       3. URUCHAMIAM ALGORYTM PLANUJACY
         {? _can_continue>0
         ||
::          Pokazuje KOMMa z wykluczeniami
            KOMM.select();

            _choice:=0;
            {? exec('interm','#system')
            || {? FUN.ask('Rozpocząć symulację zlecenia w planie strategicznym?'@)
               || _choice:=3
               ?}
            || _choice:=FUN.choice(
                  'Wyświetlanie symulacji.\n\n\n'
                  'Dostępne opcje widoku:'@+'\n\n'+
                  '● '+'Widok szczegółowy — całość\n'
                  '  (pełny widok planu wraz z innymi zamówieniami, zleceniami)'@+'\n\n'+
                  '● '+'Widok szczegółowy — symulacja\n'
                  '  (pełny widok planu, ale tylko z symulowanym zleceniem)'@+'\n\n'
                  '● '+'Bez widoku szczegółowego\n'
                  '  (wyłącznie symulacja planu w uproszczonym widoku)'@+'\n\n',,
                  'Szczegóły — &całość'@,'Szczegóły — &symulacja'@,'&Bez szczegółów'@
               )
            ?};
            {? _choice>0
            ||
               _opt_view:=1;
               _opt_clone:=0;
               {? _choice=1
               || _opt_view:=2;
                  _opt_clone:=2
               |? _choice=2
               || _opt_view:=2;
                  _opt_clone:=0
               |? _choice=3
               || _opt_view:=1;
                  _opt_clone:=0
               ?};

::             kontrola zaleznosci pomiedzy grupami
               KOMM.init(250,,'Kontrola zależności pomiędzy grupami'@);
               _continue:=exec('UpdatePX_VER','px_con_g',_ver_tmp);

               {? _continue
               || _argsplan:=exec('px_ver_plan_a','px_logix');
                  _argsplan.DEST:=_ver_tmp;
                  _argsplan.VIEW_MODE:=_opt_view;
                  _argsplan.CLONE_MODE:=_opt_clone;
                  _argsplan.EDIT:=0;
                  _argsplan.CLEAN_Q:=0;
                  {? PX_VAR.NAST_ALG=2
                  || _argsplan.UPDATE_Q:=1
                  || _argsplan.UPDATE_Q:=0
                  ?};
                  _argsplan.VERIFY_Q:=0;
                  _argsplan.CONTEXT:='ZL';
                  _result:=exec('px_ver_plan','px_logix',_argsplan)
               || _choice:=FUN.choice('Kontrola zależności między grupami zakończona niepowodzeniem.'@,,'Szczegóły'@);
                  _result:=0;
                  {? _choice=1
                  || KOMM.select()
                  ?}
               ?};

               {? _result=0
               ||
::                  FUN.emsg('Symulacja planu zakończona niepowodzeniem.')
                  ~~
               ||
::                po wykonaniu symulacji zmieniam status wersji
                  exec('status_set','px_ver',_ver_tmp,exec('status_sim_zl','px_ver'));

::                po wykonaniu symulacji ustawiam zmienna PX_VAR.VIE_VER, wg ktorej bedzie odswiezone okno z planem
                  PX_VAR.VIE_VER:=_ver_tmp;

::                wyswietlenie uproszczonej wersji symulacji
                  {? _choice=3
                  || exec('select_any_core','px_plan',_ver_tmp,ZL,_sel)
                  ?};

::                wyswietlenie i potwierdzenie terminu/terminow realizacji zamowienia/pozycji zamowienia
                  exec('terminy_zl','px_plan',_ver_tmp,_sel)
               ?}
            ?}
         || KOMM.add('Przygotowanie symulacji zakończone niepowodzeniem.'@,2,,1);
            KOMM.select()
         ?}
      ?}
   ?}
?};
{? exec('is_one_version','px_param')>0
||
:: Jeśli praca na jednej wersji to usuwam tę symulowaną wersję
   {? _ver_tmp<>null()
   || {? exec('delete','px_ver',_ver_tmp,0)=0
      || FUN.emsg('Usunięcie symulacji planu zlecenia zakończone niepowodzeniem.'@)
      ?}
   ?}
?};

PX_VER.cntx_pop();
ZL.cntx_pop();
ZK_P.cntx_pop();
VAR.cntx_pop();
_result


\zl_simulation_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Symulacja zleceń - akcja dla grupy rekordów
::----------------------------------------------------------------------------------------------------------------------
exec('zl_simulation_core','px_logix',ZL.sel_aget());
ZL.sel_adel();
VAR_DEL.delete('PxSelect');
0

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:39 29e925b66257bdeffa6719ef3f1d417042f6d31a4efc6f5a8c8510cba2f038e814ef557f0f826f7cb552c07a7bef69093eb3a7a6ef2ad34b89bf91ecf26720e40bc143b414b8e188308ea6c0730158e9d10462c85bf88aae280b5f32d5d98ae997e7098e1b04a2c1f0d4e6f864eb5f06740a3a46019f5695f145f9c24e5e065d
