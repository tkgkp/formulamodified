:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: remonty_cykliczne.fml
:: Utworzony: 27.06.2019
:: Autor: TS
::======================================================================================================================
:: Zawartość: Obsługa cykliczności remontów
::======================================================================================================================


\env
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Środowisko definiowania zdarzeń cyklicznych/wzorcowych
::----------------------------------------------------------------------------------------------------------------------
_env:=obj_new('PATTERN','PATT_REF');
:: Tryb pracy - zdarzenie=0, wzorzec=1
_env.PATTERN:=0;
:: REM_CYKL.ref() wybranego wzorca
_env.PATT_REF:=null();
_env


\rem_cykl_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Wyświetla własności zdarzenia cyklicznego
::       Kontekst wywołania - ustawiony rekord REM_CYKL
::   WE: _a - dostępna zakładka danych podstawowych
::       _b - dostępna zakładka harmonogramu
::       _c - dostępna zakładka przebiegów
::       _d - tekst doklejony do tytułu okna
::----------------------------------------------------------------------------------------------------------------------
_tabo:=_a;
_tabh:=_b;
_tabp:=_c;
_tail:=_d;

_env_rem_cykl:=params_get().env_rem_cykl;

exec('rem_cykl_set_red_opt','remonty_cykliczne');
_red:=REM_CYKL.mk_edit(
   {? _env_rem_cykl.PATTERN || 'Wzorzec zdarzenia cyklicznego'@ || 'Zdarzenie cykliczne'@ ?}+_tail,,
   '#displaycykl'+(-REM_CYKL.TRIGGER)+(-REM_CYKL.TRYB),10,5
);

{? _tabo
|| REM_CYKL.win_etab(_red,'Dane podstawowe'@);
   REM_CYKL.win_ewin(_red,,'RED'+{? _env_rem_cykl.PATTERN || 'W' || '' ?})
?};

{? _tabh & REM_CYKL.TRIG_HAR='T'
|| REM_CYKL.win_etab(_red,'Harmonogram'@);
   {? REM_CYKL.TRYB='N'
   || REM_CYKL.win_ewin(_red,,'WIN1')
   || REM_CYKL.win_ewin(_red,,'WIN2'+REM_CYKL.TRYB)
   ?}
?};

{? _tabp & REM_CYKL.TRIG_PRZ='T'
|| REM_CYKL.win_etab(_red,'Przebiegi'@);
   {? REM_CYKL.TRYBP='N'
   || REM_CYKL.win_ewin(_red,,'WIN1')
   || REM_CYKL.win_ewin(_red,,'PRZ2'+REM_CYKL.TRYBP)
   ?}
?};

REM_CYKL.win_ebtn(_red,'text=%1,display=1,align=begin'['P&lan prac cyklicznych'@],
   "exec('rem_cykl_plan','remonty_cykliczne',REM_CYKL.ref()); ''"
);
exec('ok_esc','#window',REM_CYKL,_red,,,,0,1);

REM_CYKL.win_edit(_red);
{? REM_CYKL.TRIG_HAR='T'
||
::   exec('dtm_load','remonty_cykliczne');
   exec('desc_m_load','remonty_cykliczne');
   exec('desc_t_load','remonty_cykliczne');
   exec('desc_d_load','remonty_cykliczne')
?};
REM_CYKL.memo_get(,'OPIS',);
REM_CYKL.display();
~~


\rem_cykl_set_red_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Ustawia opcje pól: DTE w oknach redagowania
::----------------------------------------------------------------------------------------------------------------------
{? REM_CYKL.EXPIRES='T' || _option:='enable=1' || _option:='enable=0' ?};
REM_CYKL.efld_opt('RED2D',_option,,'DTE');
REM_CYKL.efld_opt('RED2M',_option,,'DTE');
REM_CYKL.efld_opt('RED2T',_option,,'DTE');
REM_CYKL.efld_opt('WIN2D',_option,,'DTE');
REM_CYKL.efld_opt('WIN2M',_option,,'DTE');
REM_CYKL.efld_opt('WIN2T',_option,,'DTE');

{? REM_CYKL.SERV_INF='T' || _option:='enable=1' || _option:='enable=0' ?};
REM_CYKL.efld_opt('PRZ',_option,,'PRZB_INF');
REM_CYKL.efld_opt('RED2D',_option,,'DAYB_INF');
REM_CYKL.efld_opt('RED2M',_option,,'DAYB_INF');
REM_CYKL.efld_opt('RED2R',_option,,'DAYB_INF');
REM_CYKL.efld_opt('RED2T',_option,,'DAYB_INF');
REM_CYKL.efld_opt('WIN2D',_option,,'DAYB_INF');
REM_CYKL.efld_opt('WIN2M',_option,,'DAYB_INF');
REM_CYKL.efld_opt('WIN2R',_option,,'DAYB_INF');
REM_CYKL.efld_opt('WIN2T',_option,,'DAYB_INF');

{? REM_CYKL.SERV_GEN='T' || _option:='enable=1' || _option:='enable=0' ?};
REM_CYKL.efld_opt('PRZ',_option,,'PRZB_GEN');
REM_CYKL.efld_opt('RED2D',_option,,'DAYB_GEN');
REM_CYKL.efld_opt('RED2M',_option,,'DAYB_GEN');
REM_CYKL.efld_opt('RED2R',_option,,'DAYB_GEN');
REM_CYKL.efld_opt('RED2T',_option,,'DAYB_GEN');
REM_CYKL.efld_opt('WIN2D',_option,,'DAYB_GEN');
REM_CYKL.efld_opt('WIN2M',_option,,'DAYB_GEN');
REM_CYKL.efld_opt('WIN2R',_option,,'DAYB_GEN');
REM_CYKL.efld_opt('WIN2T',_option,,'DAYB_GEN');

{? REM_CYKL.TRYBP='R' || _option:='enable=0' || _option:='enable=1' ?};
REM_CYKL.efld_opt('PRZ',_option,,'PRZS');
REM_CYKL.efld_opt('PRZ',_option,,'PRZE');

_option:='editable=grayed';
REM_CYKL.efld_opt('RED2D',_option,,'TRYB');
REM_CYKL.efld_opt('RED2M',_option,,'TRYB');
REM_CYKL.efld_opt('RED2R',_option,,'TRYB');
REM_CYKL.efld_opt('RED2T',_option,,'TRYB');
REM_CYKL.efld_opt('WIN2D',_option,,'TRYB');
REM_CYKL.efld_opt('WIN2M',_option,,'TRYB');
REM_CYKL.efld_opt('WIN2R',_option,,'TRYB');
REM_CYKL.efld_opt('WIN2T',_option,,'TRYB');
REM_CYKL.efld_opt('PRZ2C',_option,,'TRYBP');
REM_CYKL.efld_opt('PRZ2R',_option,,'TRYBP');

{? REM_CYKL.TRIGGER='TT' || _option:='editable=grayed' || _option:='editable=1' ?};
REM_CYKL.efld_opt('PRZ2C',_option,,'OP_PLAN');
REM_CYKL.efld_opt('RED2D',_option,,'OP_PLAN');
REM_CYKL.efld_opt('RED2M',_option,,'OP_PLAN');
REM_CYKL.efld_opt('RED2T',_option,,'OP_PLAN');
REM_CYKL.efld_opt('WIN2D',_option,,'OP_PLAN');
REM_CYKL.efld_opt('WIN2M',_option,,'OP_PLAN');
REM_CYKL.efld_opt('WIN2T',_option,,'OP_PLAN');
~~


\dtm_load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Ładuje D, T i M z rekordu REM_CYKL do zmiennej POCZTAV
::----------------------------------------------------------------------------------------------------------------------
exec('dtm_load','#field',REM_CYKL);
~~


\desc_m_load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Ładuje opis z pola REM_CYKL do pola BPMN.M
::----------------------------------------------------------------------------------------------------------------------
exec('desc_m_load','#field',REM_CYKL.M);
~~


\desc_t_load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Ładuje opis z pola REM_CYKL do pola BPMN.T
::----------------------------------------------------------------------------------------------------------------------
exec('desc_t_load','#field',REM_CYKL.T);
~~


\desc_d_load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Ładuje opis z rekordu REM_CYKL do pola BPMN.D
::----------------------------------------------------------------------------------------------------------------------
exec('desc_d_load','#field',REM_CYKL.D);
~~


\dtm_save
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Zachowuje D, T i M ze zmiennej POCZTAV do rekordu REM_CYKL
::----------------------------------------------------------------------------------------------------------------------
exec('dtm_save','#field',REM_CYKL);
~~


\rem_cykl_plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Plan (harmonogram) dla definicji zdarzenia cyklicznego
::----------------------------------------------------------------------------------------------------------------------
REM_HARM.cntx_psh();
{? REM_CYKL.TRIGGER='TT'
|| REM_HARM.index('REM_CYKX');
   REM_HARM.prefix(REM_CYKL.ref(),'T','T',);
   REM_HARM.win_sel('WER_X');
   REM_HARM.actions('WER_X')
|? REM_CYKL.TRIG_HAR='T'
|| REM_HARM.index('REM_CYKH');
   REM_HARM.prefix(REM_CYKL.ref(),'T',);
   REM_HARM.win_sel('WER_H');
   REM_HARM.actions('WER_H')
|? REM_CYKL.TRIG_PRZ='T'
|| REM_HARM.index('REM_CYKP');
   REM_HARM.prefix(REM_CYKL.ref(),'T',);
   REM_HARM.win_sel('WER_P');
   REM_HARM.actions('WER_P')
::|| _before:="
::      grp_disp(REM_HARM,'WER_P');
::      ~~
::   ";
::   _grp:=REM_HARM.grp_make('Planowane zdarzenia'@,_before,'rem_cykl_plan',,,,,'normal');
::   _before:="
::      REM_HARM.index('REM_CYKH');
::      REM_HARM.prefix(REM_CYKL.ref(),'T',);
::      ~~
::   ";
::   REM_HARM.grp_sel(_grp,,'WER_H',,,,,,_before,,,,'maximized_with_title');
::   REM_HARM.grp_splt(_grp,,'horizontal','prz',20);
::   _before:="
::      REM_HARM.index('REM_CYKP');
::      REM_HARM.prefix(REM_CYKL.ref(),'T',);
::      ~~
::   ";
::   REM_HARM.grp_sel(_grp,,'WER_P',,,,,,_before,,,,'maximized_with_title');
::   REM_HARM.win_sel(_grp);
::   REM_HARM.select()
?};
REM_HARM.select();
REM_HARM.cntx_pop();
~~


\update_przebiegi
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Usuwanie i generowanie zapisów planowanu na podstawie definicji przebiegów
::   WE: _a - REM_CYKL.ref()
::       [_b] - czy wyświetlać progress (0/1, domyślnie 1-tak)
::----------------------------------------------------------------------------------------------------------------------
_rem_cykl:=_a;
{? var_pres('_b')=type_of(0) || _progress:=_b || _progress:=1 ?};

REM_CYKL.cntx_psh();
REM_CYKL.prefix();
{? REM_CYKL.seek(_rem_cykl)
|| REM_HARM.cntx_psh();
   REM_HARM.index('REM_CYKP');
   REM_HARM.prefix(REM_CYKL.ref(),'T',);

:: Kasowanie wszystkiego (oprócz elementów obsłużonych)
   {? REM_HARM.first()
   || {!
      |? {? REM_HARM.GEN_INF='T' | REM_HARM.GEN_GEN='T'
         || REM_HARM.next()
         || REM_HARM.del()
         ?}
      !}
   ?};

:: Jednorazowo - jeden zapis
   {? REM_CYKL.TRYBP='R'
   || REM_HARM.blank();
      REM_HARM.REM_CYKL:=REM_CYKL.ref();
      REM_HARM.H:='N';
      REM_HARM.P:='T';
      REM_HARM.PRZ:=REM_CYKL.PRZ;
      REM_HARM.PRZ_INF:=REM_CYKL.PRZ-REM_CYKL.PRZB_INF;
      REM_HARM.PRZ_GEN:=REM_CYKL.PRZ-REM_CYKL.PRZB_GEN;
      REM_HARM.prefix(REM_CYKL.ref(),'T',REM_HARM.PRZ);
      {? ~REM_HARM.first() || REM_HARM.add() ?}

:: Cyklicznie - zakres ważności albo 100 powtórek
   |? REM_CYKL.TRYBP='C'
   || _prz_start:=REM_CYKL.PRZS;
      _prz_end:={? REM_CYKL.PRZE=0 || REM_CYKL.PRZS+100*REM_CYKL.PRZ || REM_CYKL.PRZE ?};
      {? _progress>0 || FUN.prg_start(_prz_end-_prz_start,'Trwa generowanie planu wg przebiegów.'@,,,1) ?};
      _prz:=REM_CYKL.PRZS+REM_CYKL.PRZ;
      {!
      |? REM_HARM.blank();
         REM_HARM.REM_CYKL:=REM_CYKL.ref();
         REM_HARM.H:='N';
         REM_HARM.P:='T';
         REM_HARM.PRZ:=_prz;
         REM_HARM.PRZ_INF:=REM_HARM.PRZ-REM_CYKL.PRZB_INF;
         REM_HARM.PRZ_GEN:=REM_HARM.PRZ-REM_CYKL.PRZB_GEN;
         REM_HARM.prefix(REM_CYKL.ref(),'T',REM_HARM.PRZ);
         {? ~REM_HARM.first() || REM_HARM.add() ?};

         {? _progress>0 || FUN.prg_next(REM_CYKL.PRZ) ?};
         _prz+=REM_CYKL.PRZ;
         REM_CYKL.TRIGGER<>'TT' & REM_CYKL.OP_PLAN<>'P' & _prz<=_prz_end
      !};
      {? _progress>0 || FUN.prg_stop() ?}

   ?};
   REM_HARM.cntx_pop()
?};

REM_CYKL.cntx_pop();
~~


\update_harmonogram
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Usuwanie i generowanie zapisów planu na podstawie definicji harmonogramu
::   WE: _a - REM_CYKL.ref()
::       [_b] - czy wyświetlać progress (0/1, domyślnie 1-tak)
::----------------------------------------------------------------------------------------------------------------------
_rem_cykl:=_a;
{? var_pres('_b')=type_of(0) || _progress:=_b || _progress:=1 ?};

REM_CYKL.cntx_psh();
REM_CYKL.prefix();
{? REM_CYKL.seek(_rem_cykl)
|| REM_HARM.cntx_psh();
   REM_HARM.index('REM_CYKH');
   REM_HARM.prefix(REM_CYKL.ref(),'T',);

:: Kasowanie wszystkiego (oprócz elementów obsłużonych)
   {? REM_HARM.first()
   || {!
      |? {? REM_HARM.GEN_INF='T' | REM_HARM.GEN_GEN='T'
         || REM_HARM.next()
         || REM_HARM.del()
         ?}
      !}
   ?};

:: Jednorazowo - jeden zapis
   {? REM_CYKL.TRYB='R'
   || REM_HARM.blank();
      REM_HARM.REM_CYKL:=REM_CYKL.ref();
      REM_HARM.H:='T';
      REM_HARM.P:='N';
      REM_HARM.DATE:=REM_CYKL.DT;
      REM_HARM.DATE_INF:=REM_CYKL.DT-REM_CYKL.DAYB_INF;
      REM_HARM.DATE_GEN:=REM_CYKL.DT-REM_CYKL.DAYB_GEN;
      REM_HARM.prefix(REM_CYKL.ref(),'T',REM_HARM.DATE);
      {? ~REM_HARM.first() || REM_HARM.add() ?}

:: Codziennie - zakres ważności albo 366 dni do przodu (rok)
   |? REM_CYKL.TRYB='D'
   || _date:={? REM_CYKL.DT=date(0,0,0) || date() || REM_CYKL.DT ?};
      _date_end:={? REM_CYKL.DTE=date(0,0,0) || date()+366 || REM_CYKL.DTE ?};
      {? _progress>0 || FUN.prg_start(_date_end-_date,'Trwa generowanie planu wg harmonogramu.'@,,,1) ?};
      {!
      |? REM_HARM.blank();
         REM_HARM.REM_CYKL:=REM_CYKL.ref();
         REM_HARM.H:='T';
         REM_HARM.P:='N';
         REM_HARM.DATE:=_date;
         REM_HARM.DATE_INF:=REM_HARM.DATE-REM_CYKL.DAYB_INF;
         REM_HARM.DATE_GEN:=REM_HARM.DATE-REM_CYKL.DAYB_GEN;
         REM_HARM.prefix(REM_CYKL.ref(),'T',REM_HARM.DATE);
         {? ~REM_HARM.first() || REM_HARM.add() ?};

         {? _progress>0 || FUN.prg_next(REM_CYKL.REPLY) ?};
         _date+=REM_CYKL.REPLY;
         REM_CYKL.TRIGGER<>'TT' & REM_CYKL.OP_PLAN<>'P' & _date<=_date_end
      !};
      {? _progress>0 || FUN.prg_stop() ?}

:: Cotygodniowo - zakres ważności albo 366 dni do przodu (rok)
   |? REM_CYKL.TRYB='T'
   || _date:={? REM_CYKL.DT=date(0,0,0) || date() || REM_CYKL.DT ?};
      _date_end:={? REM_CYKL.DTE=date(0,0,0) || date()+366 || REM_CYKL.DTE ?};
      {? _progress>0 || FUN.prg_start(_date_end-_date,'Trwa generowanie planu wg harmonogramu.'@,,,1) ?};
      {!
      |? REM_HARM.blank();
         REM_HARM.REM_CYKL:=REM_CYKL.ref();
         REM_HARM.H:='T';
         REM_HARM.P:='N';
         REM_HARM.DATE:=exec('near_day_of_week','#b_harm',_date,REM_CYKL.T);
         REM_HARM.DATE_INF:=REM_HARM.DATE-REM_CYKL.DAYB_INF;
         REM_HARM.DATE_GEN:=REM_HARM.DATE-REM_CYKL.DAYB_GEN;
         REM_HARM.prefix(REM_CYKL.ref(),'T',REM_HARM.DATE);
         {? ~REM_HARM.first() || REM_HARM.add() ?};

         {? _progress>0 || FUN.prg_next(REM_HARM.DATE+1-_date) ?};
         _date:=REM_HARM.DATE+1;
         REM_CYKL.TRIGGER<>'TT' & REM_CYKL.OP_PLAN<>'P' & _date<=_date_end
      !};
      {? _progress>0 || FUN.prg_stop() ?}

:: Comiesięcznie - zakres ważności albo 366 dni do przodu (rok)
   |? REM_CYKL.TRYB='M'
   || _date:={? REM_CYKL.DT=date(0,0,0) || date() || REM_CYKL.DT ?};
      _date_end:={? REM_CYKL.DTE=date(0,0,0) || date()+366 || REM_CYKL.DTE ?};
      {? _progress>0 || FUN.prg_start(_date_end-_date,'Trwa generowanie planu wg harmonogramu.'@,,,1) ?};
      {!
      |? REM_HARM.blank();
         REM_HARM.REM_CYKL:=REM_CYKL.ref();
         REM_HARM.H:='T';
         REM_HARM.P:='N';
         REM_HARM.DATE:=exec('near_day_of_month','#b_harm',_date,REM_CYKL.M,REM_CYKL.D);
         REM_HARM.DATE_INF:=REM_HARM.DATE-REM_CYKL.DAYB_INF;
         REM_HARM.DATE_GEN:=REM_HARM.DATE-REM_CYKL.DAYB_GEN;
         REM_HARM.prefix(REM_CYKL.ref(),'T',REM_HARM.DATE);
         {? ~REM_HARM.first() || REM_HARM.add() ?};

         {? _progress>0 || FUN.prg_next(REM_HARM.DATE+1-_date) ?};
         _date:=REM_HARM.DATE+1;
         REM_CYKL.TRIGGER<>'TT' & REM_CYKL.OP_PLAN<>'P' & _date<=_date_end
      !};
      {? _progress>0 || FUN.prg_stop() ?}

   ?};
   REM_HARM.cntx_pop()
?};

REM_CYKL.cntx_pop();
~~


\update_h_plus_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Usuwanie i generowanie zapisów planu na podstawie definicji harmonogramu i przebiegów
::   WE: _a - REM_CYKL.ref()
::       [_b] - czy wyświetlać progress (0/1, domyślnie 1-tak)
::----------------------------------------------------------------------------------------------------------------------
_rem_cykl:=_a;
{? var_pres('_b')=type_of(0) || _progress:=_b || _progress:=1 ?};

REM_CYKL.cntx_psh();
REM_CYKL.prefix();
{? REM_CYKL.seek(_rem_cykl)
|| REM_HARM.cntx_psh();
   REM_HARM.index('REM_CYKX');
   REM_HARM.prefix(REM_CYKL.ref(),'T','T');

:: Kasowanie wszystkiego (oprócz elementów obsłużonych)
   {? REM_HARM.first()
   || {!
      |? {? REM_HARM.GEN_INF='T' | REM_HARM.GEN_GEN='T'
         || REM_HARM.next()
         || REM_HARM.del()
         ?}
      !}
   ?};

   _ref:=null();

:: Harmonogram

:: Jednorazowo - jeden zapis
   {? REM_CYKL.TRYB='R'
   || REM_HARM.blank();
      REM_HARM.REM_CYKL:=REM_CYKL.ref();
      REM_HARM.H:='T';
      REM_HARM.P:='T';
      REM_HARM.DATE:=REM_CYKL.DT;
      REM_HARM.DATE_INF:=REM_CYKL.DT-REM_CYKL.DAYB_INF;
      REM_HARM.DATE_GEN:=REM_CYKL.DT-REM_CYKL.DAYB_GEN;
      REM_HARM.prefix(REM_CYKL.ref(),'T','T',REM_HARM.DATE);
      {? REM_HARM.first()
      || _ref:=REM_HARM.ref()
      |? REM_HARM.add()
      || _ref:=REM_HARM.ref()
      ?}

:: Codziennie - pierwszy zapis
   |? REM_CYKL.TRYB='D'
   || _date:={? REM_CYKL.DT=date(0,0,0) || date() || REM_CYKL.DT ?};
      REM_HARM.blank();
      REM_HARM.REM_CYKL:=REM_CYKL.ref();
      REM_HARM.H:='T';
      REM_HARM.P:='T';
      REM_HARM.DATE:=_date;
      REM_HARM.DATE_INF:=REM_HARM.DATE-REM_CYKL.DAYB_INF;
      REM_HARM.DATE_GEN:=REM_HARM.DATE-REM_CYKL.DAYB_GEN;
      REM_HARM.prefix(REM_CYKL.ref(),'T','T',REM_HARM.DATE);
      {? REM_HARM.first()
      || _ref:=REM_HARM.ref()
      |? REM_HARM.add()
      || _ref:=REM_HARM.ref()
      ?}

:: Cotygodniowo - pierwszy zapis
   |? REM_CYKL.TRYB='T'
   || _date:={? REM_CYKL.DT=date(0,0,0) || date() || REM_CYKL.DT ?};
      REM_HARM.blank();
      REM_HARM.REM_CYKL:=REM_CYKL.ref();
      REM_HARM.H:='T';
      REM_HARM.P:='T';
      REM_HARM.DATE:=exec('near_day_of_week','#b_harm',_date,REM_CYKL.T);
      REM_HARM.DATE_INF:=REM_HARM.DATE-REM_CYKL.DAYB_INF;
      REM_HARM.DATE_GEN:=REM_HARM.DATE-REM_CYKL.DAYB_GEN;
      REM_HARM.prefix(REM_CYKL.ref(),'T','T',REM_HARM.DATE);
      {? REM_HARM.first()
      || _ref:=REM_HARM.ref()
      |? REM_HARM.add()
      || _ref:=REM_HARM.ref()
      ?}

:: Comiesięcznie - pierwszy zapis
   |? REM_CYKL.TRYB='M'
   || _date:={? REM_CYKL.DT=date(0,0,0) || date() || REM_CYKL.DT ?};
      REM_HARM.blank();
      REM_HARM.REM_CYKL:=REM_CYKL.ref();
      REM_HARM.H:='T';
      REM_HARM.P:='T';
      REM_HARM.DATE:=exec('near_day_of_month','#b_harm',_date,REM_CYKL.M,REM_CYKL.D);
      REM_HARM.DATE_INF:=REM_HARM.DATE-REM_CYKL.DAYB_INF;
      REM_HARM.DATE_GEN:=REM_HARM.DATE-REM_CYKL.DAYB_GEN;
      REM_HARM.prefix(REM_CYKL.ref(),'T','T',REM_HARM.DATE);
      {? REM_HARM.first()
      || _ref:=REM_HARM.ref()
      |? REM_HARM.add()
      || _ref:=REM_HARM.ref()
      ?}

   ?};

:: Przebiegi

   {? _ref<>null() & REM_HARM.seek(_ref)
   ||
::    Jednorazowo - jeden zapis
      {? REM_CYKL.TRYBP='R'
      || REM_HARM.PRZ:=REM_CYKL.PRZ;
         REM_HARM.PRZ_INF:=REM_CYKL.PRZ-REM_CYKL.PRZB_INF;
         REM_HARM.PRZ_GEN:=REM_CYKL.PRZ-REM_CYKL.PRZB_GEN;
         REM_HARM.put()

::    Cyklicznie
      |? REM_CYKL.TRYBP='C'
      || _prz:=REM_CYKL.PRZS+REM_CYKL.PRZ;
         REM_HARM.PRZ:=_prz;
         REM_HARM.PRZ_INF:=REM_HARM.PRZ-REM_CYKL.PRZB_INF;
         REM_HARM.PRZ_GEN:=REM_HARM.PRZ-REM_CYKL.PRZB_GEN;
         REM_HARM.put()

      ?}
   ?};

   REM_HARM.cntx_pop()

?};

REM_CYKL.cntx_pop();
~~


\find_rem_harm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Znajduje pozycję harmonogramu dla zadanych warunków zdarzenia cyklicznego
::   WE: _a - REM_CYKL.ref()
::       _b - sprawdzenie warunku dla informacji (1), dla generowania zgłoszenia (2)
::   WY: obj_new('REM_HARM','HP'), gdzie REM_HARM - REM_HARM.ref() / null(); HP - 'H', 'P' źródło spełnienia warunku
::----------------------------------------------------------------------------------------------------------------------
_rem_cykl:=_a;
_ver:=_b;

_result:=obj_new('REM_HARM','HP');
_result.REM_HARM:=null();
_result.HP:='';

REM_CYKL.cntx_psh();
REM_CYKL.prefix();
{? REM_CYKL.seek(_rem_cykl) & REM_CYKL.ACT='T'
||
:: Harmonogram
   {? _result.REM_HARM=null()
   || REM_HARM.index('REM_CYKH');
      REM_HARM.prefix(REM_CYKL.ref(),'T',);
      {? REM_HARM.first()
      || {!
         |? _gen:={? _ver=1 || REM_HARM.GEN_INF='T' || REM_HARM.GEN_GEN='T' ?};
            _date:={? _ver=1 || REM_HARM.DATE_INF || REM_HARM.DATE_GEN ?};
            {? _gen=0
            || {? _date<=date() || _result.REM_HARM:=REM_HARM.ref(); _result.HP:='H' ?}
            ?};
            _result.REM_HARM=null() & REM_HARM.next()
         !}
      ?}
   ?};

:: Przebieg
   {? _result.REM_HARM=null()
   || REM_HARM.index('REM_CYKP');
      REM_HARM.prefix(REM_CYKL.ref(),'T',);
      {? REM_HARM.first()
      || {!
         |? _gen:={? _ver=1 || REM_HARM.GEN_INF='T' || REM_HARM.GEN_GEN='T' ?};
            _prz:={? _ver=1 || REM_HARM.PRZ_INF || REM_HARM.PRZ_GEN ?};
            {? _gen=0
            || {? _prz<=REM_CYKL.REM_ZAS().PRZ || _result.REM_HARM:=REM_HARM.ref(); _result.HP:='P' ?}
            ?};
            _result.REM_HARM=null() & REM_HARM.next()
         !}
      ?}
   ?}

?};
REM_CYKL.cntx_pop();

_result


\rem_zas_plan_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MW [19.42]
:: OPIS: Plan (harmonogram) dla zdarzeń cyklicznych zasobu
::   WE: _a - H - harmonogram, P - przebiegi
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
{? var_pres('_a')<>type_of('') | (_a<>'H' & _a<>'P')
|| _a:='H'
?};
REM_HARM.index('REM_ZAS'+_a);
REM_HARM.prefix(REM_ZAS.ref(),'T',);
~~


\icon_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Ustala ikony w oknie wertowania zdarzeń cyklicznych
::   WE: _a - akronim okna wertowania
::----------------------------------------------------------------------------------------------------------------------
_wer:=_a;

_icon_before:="
   {? REM_CYKL.PATTERN<>''
   || 'xwin16.png:190'
   || exec('pusta','#icon')
   ?}
";
REM_CYKL.win_fml(_wer,,'NAZ',,'ICON_BEFORE',_icon_before,2);
~~


\action_plan_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Dodanie zapisu w tabeli REM_HARM (plan dla definicji zdarzenia cyklicznego)
::       Kontekst wywołania - rekord tabeli REM_CYKL
::----------------------------------------------------------------------------------------------------------------------
_buffer:=exec('REM_HARM','buffer1');

:: Ustalenie ostatniego rekordu w planie, pobranie danych do bufora
REM_HARM.cntx_psh();
{? REM_CYKL.TRIGGER='TT'
|| REM_HARM.index('REM_CYKX')
|? REM_CYKL.TRIG_HAR='T'
|| REM_HARM.index('REM_CYKH')
|| REM_HARM.index('REM_CYKP')
?};
{? REM_HARM.last() || _buffer.get() ?};
REM_HARM.cntx_pop();

{? REM_CYKL.OP_PLAN='S'
|| {? REM_CYKL.TRIG_HAR='T'
   || FUN.info(
         'Zapisy w planie zostały automatycznie wygenerowane na podstawie definicji harmonogramu\n'
         'przy zaznaczonej opcji: Generowanie planu — seria zapisów.\n\n'
         'W takim przypadku nie można dołączać nowych pozycji.'@
      )
   || FUN.info(
         'Zapisy w planie zostały automatycznie wygenerowane na podstawie definicji przebiegów\n'
         'przy zaznaczonej opcji: Generowanie planu — seria zapisów.\n\n'
         'W takim przypadku nie można dołączać nowych pozycji.'@
      )
   ?}
:: Niepotrzebne sprawdzenie - akcja wyłączona dla pustej dziedziny
::|? _first=null()
::|| FUN.info('Aby dołączyć, w planie musi być automatycznie wygenerowany zapis startowy.'@)
|? (REM_CYKL.TRIG_HAR='T' & REM_CYKL.TRYB='R') | (REM_CYKL.TRIG_PRZ='T' & REM_CYKL.TRYBP='R')
|| {? REM_CYKL.TRIG_HAR='T'
   || FUN.info(
         'Zapis w planie został automatycznie wygenerowany na podstawie definicji harmonogramu\n'
         'przy zaznaczonym wariancie: \'jeden raz\'.\n\n'
         'W takim przypadku nie można dołączać nowych pozycji.'@
      )
   || FUN.info(
         'Zapis w planie został automatycznie wygenerowany na podstawie definicji przebiegów\n'
         'przy zaznaczonym wariancie: \'jednorazowo — przy przebiegu\'.\n\n'
         'W takim przypadku nie można dołączać nowych pozycji.'@
      )
   ?}
|? (REM_CYKL.TRIG_HAR='T' & REM_CYKL.TRYB='N') | (REM_CYKL.TRIG_PRZ='T' & REM_CYKL.TRYBP='N')
|| FUN.info(
      'Nie można dołączać zapisów do nie skonfigurowanego harmonogramu.'@
   )
|| {? REM_CYKL.TRIG_HAR='T' & REM_CYKL.TRIG_PRZ='T'
   || REM_HARM.win_edit('RED_X')
   |? REM_CYKL.TRIG_HAR='T'
   || REM_HARM.win_edit('RED_H')
   || REM_HARM.win_edit('RED_P')
   ?};
   REM_HARM.blank();
   REM_HARM.REM_CYKL:=REM_CYKL.ref();
   REM_HARM.H:=REM_CYKL.TRIG_HAR;
   REM_HARM.P:=REM_CYKL.TRIG_PRZ;
   {? REM_HARM.H='T'
   || {? REM_CYKL.TRYB='D'
      || REM_HARM.DATE:=_buffer.DATE+REM_CYKL.REPLY
      |? REM_CYKL.TRYB='T'
      || REM_HARM.DATE:=exec('near_day_of_week','#b_harm',_buffer.DATE+1,REM_CYKL.T)
      |? REM_CYKL.TRYB='M'
      || REM_HARM.DATE:=exec('near_day_of_month','#b_harm',_buffer.DATE+1,REM_CYKL.M,REM_CYKL.D)
      ?};
      REMONTY.DAYB_INF:=REM_CYKL.DAYB_INF;
      REMONTY.DAYB_GEN:=REM_CYKL.DAYB_GEN
   ?};
   {? REM_HARM.P='T'
   || REM_HARM.PRZ:={? REM_CYKL.TRYBP='C' || _buffer.PRZ+REM_CYKL.PRZ || _buffer.PRZ ?};
      REMONTY.PRZB_INF:=REM_CYKL.PRZB_INF;
      REMONTY.PRZB_GEN:=REM_CYKL.PRZB_GEN
   ?};
   {? REM_HARM.edit("exec('rem_harm_valid','remonty_cykliczne',0)")
   || {? REM_HARM.H='T'
      || REM_HARM.DATE_INF:=REM_HARM.DATE-REMONTY.DAYB_INF;
         REM_HARM.DATE_GEN:=REM_HARM.DATE-REMONTY.DAYB_GEN
      ?};
      {? REM_HARM.P='T'
      || REM_HARM.PRZ_INF:=REM_HARM.PRZ-REMONTY.PRZB_INF;
         REM_HARM.PRZ_GEN:=REM_HARM.PRZ-REMONTY.PRZB_GEN
      ?};
      REM_HARM.add()
   ?}
?};
~~


\action_plan_modify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Modyfikacja zapisu w tabeli REM_HARM (plan dla definicji zdarzenia cyklicznego)
::----------------------------------------------------------------------------------------------------------------------
REM_HARM.REM_CYKL();

:: Ustalenie pierwszego rekordu w planie
REM_HARM.cntx_psh();
{? REM_CYKL.TRIGGER='TT'
|| REM_HARM.index('REM_CYKX')
|? REM_CYKL.TRIG_HAR='T'
|| REM_HARM.index('REM_CYKH')
|| REM_HARM.index('REM_CYKP')
?};
_first:=null();
{? REM_HARM.first() || _first:=REM_HARM.ref() ?};
REM_HARM.cntx_pop();

{? REM_CYKL.OP_PLAN='S'
|| {? REM_CYKL.TRIG_HAR='T'
   || FUN.info(
         'Zapisy w planie zostały automatycznie wygenerowane na podstawie definicji harmonogramu\n'
         'przy zaznaczonej opcji: Generowanie planu — seria zapisów.\n\n'
         'W takim przypadku nie można modyfikować pozycji.'@
      )
   || FUN.info(
         'Zapisy w planie zostały automatycznie wygenerowane na podstawie definicji przebiegów\n'
         'przy zaznaczonej opcji: Generowanie planu — seria zapisów.\n\n'
         'W takim przypadku nie można modyfikować pozycji.'@
      )
   ?}
|? REM_HARM.ref()=_first
|| {? REM_CYKL.TRIG_HAR='T'
   || FUN.info(
         'Pierwszy zapis w planie został automatycznie wygenerowany na podstawie definicji harmonogramu\n'
         'przy zaznaczonej opcji: Generowanie planu — pierwszy zapis.\n\n'
         'W takim przypadku nie można modyfikować tej pozycji.'@
      )
   || FUN.info(
         'Pierwszy zapis w planie został automatycznie wygenerowany na podstawie definicji przebiegów\n'
         'przy zaznaczonej opcji: Generowanie planu — pierwszy zapis.\n\n'
         'W takim przypadku nie można modyfikować tej pozycji.'@
      )
   ?}
|? REM_HARM.GEN_GEN='T'
|| FUN.info(
      'Zapisu, do którego już zostało wygenerowane zgłoszenie nie można poprawić.'@
   )
|| {? REM_CYKL.TRIGGER='TT'
   || REM_HARM.win_edit('RED_X')
   |? REM_CYKL.TRIG_HAR='T'
   || REM_HARM.win_edit('RED_H')
   || REM_HARM.win_edit('RED_P')
   ?};
   {? REM_HARM.H='T'
   || REMONTY.DAYB_INF:=REM_HARM.DATE-REM_HARM.DATE_INF;
      REMONTY.DAYB_GEN:=REM_HARM.DATE-REM_HARM.DATE_GEN
   ?};
   {? REM_HARM.P='T'
   || REMONTY.PRZB_INF:=REM_HARM.PRZ-REM_HARM.PRZ_INF;
      REMONTY.PRZB_GEN:=REM_HARM.PRZ-REM_HARM.PRZ_GEN
   ?};
   {? REM_HARM.edit("exec('rem_harm_valid','remonty_cykliczne',1)")
   || {? REM_HARM.H='T'
      || REM_HARM.DATE_INF:=REM_HARM.DATE-REMONTY.DAYB_INF;
         REM_HARM.DATE_GEN:=REM_HARM.DATE-REMONTY.DAYB_GEN
      ?};
      {? REM_HARM.P='T'
      || REM_HARM.PRZ_INF:=REM_HARM.PRZ-REMONTY.PRZB_INF;
         REM_HARM.PRZ_GEN:=REM_HARM.PRZ-REMONTY.PRZB_GEN
      ?};
      REM_HARM.put()
   ?}
?};
~~


\action_plan_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Usunięcie zapisu z tabeli REM_HARM (plan dla definicji zdarzenia cyklicznego)
::----------------------------------------------------------------------------------------------------------------------
REM_HARM.REM_CYKL();

:: Ustalenie pierwszego rekordu w planie
REM_HARM.cntx_psh();
{? REM_CYKL.TRIGGER='TT'
|| REM_HARM.index('REM_CYKX')
|? REM_CYKL.TRIG_HAR='T'
|| REM_HARM.index('REM_CYKH')
|| REM_HARM.index('REM_CYKP')
?};
_first:=null();
{? REM_HARM.first() || _first:=REM_HARM.ref() ?};
REM_HARM.cntx_pop();

{? REM_CYKL.OP_PLAN='S'
|| FUN.info('Nie można usuwać zapisów z planu generowanego automatycznie.'@)
|? REM_HARM.ref()=_first
|| FUN.info('Nie można usuwać pierwszego zapisu w planie (generowany jest automatycznie na podstawie definicji).'@)
|? REM_HARM.GEN_GEN='T'
|| FUN.info('Zapisu, do którego już zostało wygenerowane zgłoszenie nie można usunąć z planu.'@)
|| {? FUN.ask('Czy usunąć zapis z planu zdarzenia?'@)
   || REM_HARM.del()
   ?}
?};
~~


\action_plan_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Wyświetlenie zapisu REM_HARM (plan dla definicji zdarzenia cyklicznego)
::----------------------------------------------------------------------------------------------------------------------
REM_HARM.REM_CYKL();
{? REM_CYKL.TRIGGER='TT'
|| REM_HARM.win_edit('RED_X')
|? REM_CYKL.TRIG_HAR='T'
|| REM_HARM.win_edit('RED_H')
|| REM_HARM.win_edit('RED_P')
?};
{? REM_HARM.H='T'
|| REMONTY.DAYB_INF:=REM_HARM.DATE-REM_HARM.DATE_INF;
   REMONTY.DAYB_GEN:=REM_HARM.DATE-REM_HARM.DATE_GEN
?};
{? REM_HARM.P='T'
|| REMONTY.PRZB_INF:=REM_HARM.PRZ-REM_HARM.PRZ_INF;
   REMONTY.PRZB_GEN:=REM_HARM.PRZ-REM_HARM.PRZ_GEN
?};
REM_HARM.display();
~~


\rem_harm_fld_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Przed redakcją pól w tabeli REM_HARM (plan dla definicji zdarzenia cyklicznego)
::----------------------------------------------------------------------------------------------------------------------
1


\rem_harm_fld_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Po redakcji pól w tabeli REM_HARM (plan dla definicji zdarzenia cyklicznego)
::----------------------------------------------------------------------------------------------------------------------
1


\rem_harm_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Walidacja zapisu w tabeli REM_HARM (plan dla definicji zdarzenia cyklicznego)
::   WE: _a - kontekst wywołania: poprawianie (1), dołączanie (0)
::----------------------------------------------------------------------------------------------------------------------
_context:=_a;

REM_HARM.REM_CYKL();

_buffer:=exec('REM_HARM','buffer1');

:: Ustalenie poprzedniego (przy poprawianiu) albo ostatniego (przy dołączaniu) rekordu w planie,
:: pobranie danych do bufora
REM_HARM.cntx_psh();
{? REM_CYKL.TRIGGER='TT'
|| REM_HARM.index('REM_CYKX')
|? REM_CYKL.TRIG_HAR='T'
|| REM_HARM.index('REM_CYKH')
|| REM_HARM.index('REM_CYKP')
?};
{? {? _context>0 || REM_HARM.prev() || REM_HARM.last() ?} || _buffer.get() ?};
REM_HARM.cntx_pop();

_result:='';

{? _result='' & REM_CYKL.TRIG_HAR='T'
|| {? REM_HARM.DATE<=_buffer.DATE
   || FUN.info('Data dla kolejnego zdarzenia musi być późniejsza od poprzedniego.'@);
      _result:='DATE'
   |? REM_CYKL.DTE<>date(0,0,0) & REM_HARM.DATE>REM_CYKL.DTE
   || FUN.info('Data dla kolejnego zdarzenia nie może być późniejsza od daty końcowej (%1).'@[$REM_CYKL.DTE]);
      _result:='DATE'
   ?}
?};

{? _result='' & REM_CYKL.TRIG_PRZ='T'
|| {? REM_HARM.PRZ<=_buffer.PRZ
   || FUN.info('Przebieg dla kolejnego zdarzenia musi być większy od poprzedniego.'@);
      _result:='PRZ'
   |? REM_CYKL.PRZE<>0 & REM_HARM.PRZ>REM_CYKL.PRZE
   || FUN.info('Przebieg dla kolejnego zdarzenia nie może być większy od końcowego (%1)'@[$REM_CYKL.PRZE]);
      _result:='PRZ'
   ?}
?};

_result


\rem_zgl_rea_plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Plan (harmonogram) dla definicji zdarzenia cyklicznego, z którego wygenerowano zgłoszenie
::----------------------------------------------------------------------------------------------------------------------
{? REM_ZGL.REM_CYKL<>null()
|| REM_ZGL.REM_CYKL();
   exec('rem_cykl_plan','remonty_cykliczne')
|| FUN.info(
      'Zgłoszenie nie zostało wygenerowanie na podstawie definicji cyklicznej.\n'
      'Nie można wyświetlić planu dla zdarzenia.'@
   )
?};
''


\rem_harm_trig_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.42]
:: OPIS: Trigger 'przed' dla tabeli REM_HARM
::----------------------------------------------------------------------------------------------------------------------
{? REM_HARM.GENP_INF='T' | REM_HARM.GENH_INF='T' || REM_HARM.GEN_INF:='T' || REM_HARM.GEN_INF:='N' ?};
{? REM_HARM.GENP_GEN='T' | REM_HARM.GENH_GEN='T' || REM_HARM.GEN_GEN:='T' || REM_HARM.GEN_GEN:='N' ?};
1

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:39 abcb66d98416882598a1c31d13151d4a5483ed7d75f6687095fecf07607029495fd545c950ebaffca13c27c2c532276ba569231a61a3093700526fcaa8126e315bcc87476332d306ef5ac1500dec30403fb72f6d3ebeacc238c05f079c631993e48f9b94b0525cbbc53850c377377096f85ef0fdf01a62a433231eb53bd5db1e
