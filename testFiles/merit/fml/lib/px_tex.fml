:!UTF-8
::(c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: px_tex.fml [12.10]
:: Utworzony: 2011/06/10
:: Autor: jerry
::======================================================================================================================
:: Zawartosc: Obsluga technologii/marszruty dla planow strategicznych (WielowymiarowychPlanowPojemnosciowych - WWPP)
::======================================================================================================================


\px_tex_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Inicjacja przepisow systemowych
::----------------------------------------------------------------------------------------------------------------------
PX_RULES.cntx_psh();
PX_RULES.index('TYP');
PX_RULES.clear();

PX_TEX.cntx_psh();
PX_TEX.clear();
_ndx:=PX_TEX.ndx_tmp(,
                    ,'KIND',,
                    ,'SYMBOL',,
                    );

PX_TEX.index(_ndx);

_add_args:=obj_new('KIND','SYMBOL','AKT','RULE_TYP','RULE_SYM');
_add_tex:="_args:=_a;
   _rule:={? PX_RULES.find_key(_args.RULE_TYP,_args.RULE_SYM,) || PX_RULES.ref() || null() ?};
   {? _rule<>null()
    & ~PX_TEX.find_key(_args.KIND,_args.SYMBOL,)
   || PX_TEX.blank(1);
      PX_TEX.KIND:=_args.KIND;
      PX_TEX.SYMBOL:=_args.SYMBOL;
      PX_TEX.AKT:=_args.AKT;
      PX_TEX.PX_RULES:=_rule;
      PX_TEX.XJM:=1;
      PX_TEX.add()
   ?}
";

_rul_tex:=exec('px_rule_tex','px_param');
_rtexown:=exec('px_rule_tex_own','px_param');

:: uniwersalny przepis - domyslnie nieaktywny
_add_args.KIND:='SYSTEM';
_add_args.SYMBOL:='~Uniwersalny';
_add_args.AKT:='N';
_add_args.RULE_TYP:=_rul_tex;
_add_args.RULE_SYM:=_rtexown;
_add_tex(_add_args);

:: jeszcze conieco z wdrozenia
exec('px_tex_init','px_prepq', _add_tex, _add_args);

PX_TEX.cntx_pop();
PX_TEX.ndx_drop(_ndx);

PX_RULES.cntx_pop();
~~


\PxTex_Create
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy struktury do wyswietlania i zarzadzania technologia dla WWPP
::----------------------------------------------------------------------------------------------------------------------
_ExtraCol:={? _>0 & type_of(_a)=1 || _a || 20 ?};
_CellType:={? _>1 & type_of(_b)=2 || _b || 'STRING[8]' ?};

::UWAGA: _fld, i _mth to formulki pomocnicze, zeby wygodniej tworzyc tablice i komentowac poszczegolne jej elementy
::       powiedzmy, ze to bedzie pole
         _fld:="31+form(_a)";
::       powiedzmy, ze to bedzie metoda
         _mth:="31+form(_a)";
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:: jeszcze wywolamy elementy niezbedne
PX_VAR.GREY:=exec('findfnv','#color');
:: tworzymy tablice zmiennych
_pxtex:=obj_new(_fld('CellType','Typ wartosci komorki - domyslnie STRING[1]')
               ,_fld('ViewOnly','Tylko podglad - np. gdy ktos inny redaguje: 0/1/2')
               ,_fld('DEVELOP' ,'Wersja w trakcie tworzenia - conieco więcej do pokazania')
               ,_fld('DimX'    ,'Wymiar poziomy - liczba kolumn do planowania')
               ,_fld('DimE'    ,'Wymiar poziomy - liczba kolumn z kolejnymi procesami')
               ,_fld('MaxKontD','Wymiar pionowy - maksymalna liczba wymiarow kontenerów')
               ,_fld('MaxCol'  ,'Maksymalny indeks COLxxx')
               ,_fld('MaxWCol' ,'Maksymalna liczba pol w okienku')
               ,_fld('Result'  ,'Ewentualny wynik na zewnatrz')

               ,_fld('fml4BD'  ,'Formula przed wyswietl dla pola wartosci w Grid i Row')
               ,_fld('fml4BDE' ,'Formula przed wyswietl dla pola wartosci w Etapy i Row')
::             parametry mechanizmu - globalne?
               ,_fld('RootRef' ,'Ref do tego czegos, co jest nadrzedne')
               ,_fld('TKTL'    ,'TKTL.ref() technologii, ktora jest wczytywana')
               ,_fld('PX_TEX'  ,'PX_TEX.ref() przepisu, ktory jest wczytywany')
               ,_fld('ZL'      ,'ZL.ref() zlecenia ktorego przepis jest wczytywany')

::             identyfikatory okienek
               ,_fld('wid_Grid' ,'ID okienka tabeli GridTab')
               ,_fld('wid_Row'  ,'ID okienka tabeli RowTab')
               ,_fld('wid_Fun'  ,'ID okienka tabeli FunTab')
               ,_fld('wid_Oper' ,'ID okienka tabeli OperTab')
               ,_fld('wid_Mater','ID okienka tabeli MaterTab')
               ,_fld('wid_PxTx' ,'ID okienka grupow.PxTex')
               ,_fld('wid_TieN' ,'ID okienka tabeli powiązań - nastepniki')
               ,_fld('wid_TieP' ,'ID okienka tabeli powiązań - poprzedniki')
               ,_fld('wid_Pop'  ,'ID okienka tabeli NastTab poprzedniki')
               ,_fld('wid_Etap' ,'ID okienka tabeli EtapTab')

::             Tabela Kontenery/Operacje
               ,_fld('GridTab' ,'Tabela siatki... najpierw kolumny, potem opisy i techniczne')
               ,_fld('GridSel' ,'Okienko selekcji siatki')
               ,_fld('GridNd__','Podstawowy indeks GridTab - Wszystkie')
               ,_fld('GridNdU_','Podstawowy indeks GridTab - Uzycie')
               ,_fld('GridNdA_','Podstawowy indeks GridTab - Aktwyność')
               ,_fld('GridNdAU','Podstawowy indeks GridTab - Aktywność, Uzycie')

               ,_fld('GridUsed','Zakres w oknie GridTab','użycie')
               ,_fld('GridAkt' ,'Zakres w oknie GridTab','aktywność')

               ,_fld('EtapTab' ,'Tabela siatki... najpierw kolumny, potem opisy i techniczne')
               ,_fld('EtapSel' ,'Okienko selekcji procesów')
               ,_fld('EtapNd__','Podstawowy indeks EtapTab - Wszystkie')
               ,_fld('EtapNdU_','Podstawowy indeks EtapTab - Uzycie')
               ,_fld('EtapNdA_','Podstawowy indeks EtapTab - Aktwyność')
               ,_fld('EtapNdAU','Podstawowy indeks EtapTab - Aktywność, Uzycie')
               ,_fld('EtapUsed','Zakres w oknie GridTab','użycie')
               ,_fld('EtapAkt' ,'Zakres w oknie GridTab','aktywność')

::             Tabela Operacje w Kontenerze
               ,_fld('RowTab'  ,'Tabela wiersza...tylko wiersze kolumnowe')

::             Tabela Funkcji
               ,_fld('FunTab'  ,'Tabela funkcji')
               ,_fld('FunSel'  ,'Okienko selekcji funkcji')

::             Tabela etapow
               ,_fld('StageTab','Tabela etapow')

::             Tabela Operacji (drzewko)
               ,_fld('OperTab' ,'Tabela operacji')
               ,_fld('OperSel' ,'Okienko selekcji operacji')
               ,_fld('OperNdxO','Indeks NROP,OPER_NAM,OPER_REF')

::             Tabela materialow
               ,_fld('MaterTab' ,'Tabela materialow')
               ,_fld('MaterSel' ,'Okienko selekcji materialow')

::             Tabela powiazan z TOPER/ZOPER
               ,_fld('TieTabP' ,'Tabela powiazan - poprzedniki')
               ,_fld('TieSelP' ,'Okienko z powiazaniami poprzedniki')
               ,_fld('TieVar'  ,'Zmienna pomocnicza przy nastepniach')
               ,_fld('TieTabN' ,'Tabela powiazan - nastepniki')
               ,_fld('TieSelN' ,'Okienko z powiazaniami następników')

::             Okienko z operacjami technologicznymi
               ,_fld('TexopSel','Okienko z operacjami')

::             Teraz do kupy
               ,_fld('PxTexTab','Tabela głowna całego mechanizmu')
               ,_fld('PxTexSel','Okienko grupowe technologii uproszczonej')

::             Tytuly w okienkach selekcji
               ,_fld('TitTab'  ,'Tabela tytulow do wykorzystania w okienkach selekcji')

::             METODY
               ,_mth('make_row2col','Tworzy formule row2col')
               ,_mth('row2col' ,'Konwersja danych z wiersza do kolumny')
               ,_mth('col2row' ,'Konwersja danych z kolumny do wiersza')

               ,_mth('load'    ,'Ładuje struktury na podstawie podanej technologii', '.load(TKTL.ref(), M.ref())')
               ,_mth('save'    ,'Zapisuje struktury do podanej technologii', '.save(TKTL.ref())')

               ,_mth('refresh' ,'Odswieza informacje w obiekcie')
               ,_mth('grp_disp','Odswieza informacje w oknie')

               ,_mth('select'  ,'Wyswietla GridTab')
               );
:: tablica utworzona, wiec kasujemy zbedne zmienne i przechodzimy do przypisania wartosci podstawowych
&_mth; &_fld;
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_pxtex.ViewOnly:=0;
_pxtex.DEVELOP:=0 & sec_superuser()>0;
_pxtex.MaxCol:=0;
_pxtex.MaxWCol:=67;
_pxtex.DimX:=_ExtraCol;
_pxtex.CellType:=_CellType;
_pxtex.MaxKontD:=0;

_pxtex.fml4BD:="
   _fld:=fld();
    {? _fld<>''
    || '192:168:100,192:168:100'
    || ~~
    ?}
";
_pxtex.fml4BDE:="
   _fld:=fld();
   {? _fld<>''
   || '0:0:0,192:168:100'
   || ~~
   ?}
";


_pxtex.RootRef:=null();
_pxtex.TKTL:=null();
_pxtex.PX_TEX:=null();
_pxtex.ZL:=null();

_pxtex.wid_Grid:='#pxtex_sel_grid';
_pxtex.wid_Row:='#pxtex_sel_row_';
_pxtex.wid_Fun:='#pxtex_sel_fun_';
_pxtex.wid_Oper:='#pxtex_sel_oper';
_pxtex.wid_Mater:='#pxtex_sel_mate';
_pxtex.wid_PxTx:='#pxtex_grp_pxtx';
_pxtex.wid_TieN:='#pxtex_sel_tien';
_pxtex.wid_TieP:='#pxtex_sel_tiep';
_pxtex.wid_Etap:='#pxtex_sel_etap';

_pxtex.GridSel:='';
_pxtex.FunSel:='';
_pxtex.OperSel:='';
_pxtex.MaterSel:='';
_pxtex.PxTexSel:='';
_pxtex.TieSelP:='';
_pxtex.TieSelN:='';
_pxtex.TexopSel:='';

_pxtex.TieVar:=obj_new('rsql','nr');
_pxtex.TieVar.rsql:='';
_pxtex.TieVar.nr:=0;
_pxtex.EtapSel:='';

_pxtex.GridUsed:='W';
_pxtex.GridAkt:='W';

_pxtex.EtapUsed:='W';
_pxtex.EtapAkt:='W';

_pxtex.TitTab:=tab_tmp(1
::                    jakies pole musi byc wiec, niech bedzie rodzaj, moze kiedys bedzie wykorzystane do czegos
                      ,'KIND','INTEGER',''
                      );
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_pxtex.make_row2col:="

   {? .DimX>.MaxCol || .DimX:=.MaxCol ?};
   .row2col:='_row:=.RowTab; _row.erase(); _grid:=.GridTab; _stage:=.StageTab;';
   .row2col+='_grid.cntx_psh();\n';
   {! _col:=1.. .DimX
   |! .row2col+='\n
         _row.COL_NR:='+form(_col,,,'99')+';
         {? _stage.find_key('+$_col+')
         || _row.COL_NAM:=_stage.NAZ; _row.AKT:=\'\'T\'\'
         || _row.COL_NAM:=\'\'\'\';
            _row.AKT:=\'\'N\'\'
         ?};
         _grid.get();
         _row.VALUE:=_grid.COL'+form(_col,-3,0,'99')+';
         _row.add();
      '
   !};
   .row2col+='_grid.cntx_pop();\n';
   .row2col:=$(.row2col+'~~');
   ~~
";
_pxtex.make_row2col();

_pxtex.col2row:="
   _row:=.RowTab;
   _grid:=.GridTab;
   {? _row.first()
   || {!
      |? _row[_col.COL_NR]:=_col.VALUE;
         _row.next()
      !};
      _grid.put()
   ?};
   ~~
";
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_pxtex.load:="
:: najpierw struktury
   exec('PxTexCGridTab' ,'px_tex',.); .PxTexTab:=.GridTab;
   exec('PxTexCEtapTab' ,'px_tex',.);
   exec('PxTexCRowTab'  ,'px_tex',.);
   exec('PxTexCFunTab'  ,'px_tex',.);
   exec('PxTexCStageTab','px_tex',.);
   exec('PxTexCOperTab' ,'px_tex',.);
   exec('PxTexCMaterTab','px_tex',.);
   exec('PxTexCTieTab'  ,'px_tex',.);
:: struktury gotowe mozna isc dalej

   exec('Load_Px_Kont','px_tex');

   _px_oper:=exec('Load_Px_Oper_a','px_oper');
   _px_oper.PxTex:=.;
   _px_oper.ZL:=.ZL;
   .RootRef:={? .TKTL<>null()   || _px_oper.TKTL:=.TKTL
             |? .PX_TEX<>null() || _px_oper.PX_TEX:=.PX_TEX
                                || null()
             ?};
   exec('Load_Px_Oper','px_oper',_px_oper);

:: ladowanie widoku operacji technologicznych
   {? .TKTL<>null()
   || exec('PxTexCTexopLoad','px_tex',.)
   ?};
   ~~
";

_pxtex.save:="";
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_pxtex.refresh:="exec('PxTex_Refresh','px_tex',.)";
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_pxtex.grp_disp:="
   grp_disp(.GridTab,.GridSel);
   grp_disp(.OperTab,.OperSel,1);
::   grp_disp(.FunTab ,.FunSel );
   ~~
";

:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
_pxtex.select:="
   _env_oper:=exec('env_oper','tech_oper');
   _env_oper.used:=1;
   params_set('env_oper',_env_oper);

   exec('PxTexCPxTexSel','px_tex',.);
   .PxTexTab.win_sel(.PxTexSel);
   TKTL.cntx_psh();
   PX_VAR.PX_STAGE:=null();

   .PxTexTab.select();
:: Usuwanie zmiennych globalnych wykorzystywanych w widoku operacji
   {? .TKTL<>null()
   || VAR_DEL.delete('XZTREE'
:      ,'Obj',
,'XTTREE'
:,'Objt'
)
   ?};
   TKTL.cntx_pop();
   ~~
";
:: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

:: Koniec - zwracamy tablice swiatu
_pxtex


\PxTexCPxTexSel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy okienka dla PxTex
::   WE: _a wskazanie na PxTex
::   WY: --
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;

:: najpierw okienka skladowe
{? _pxtex.GridSel='' || exec('PxTexCGridSel' ,'px_tex',_pxtex) ?};
{? _pxtex.FunSel=''  || exec('PxTexCFunSel'  ,'px_tex',_pxtex) ?};
{? _pxtex.OperSel='' || exec('PxTexCOperSel' ,'px_tex',_pxtex) ?};
{? _pxtex.MaterSel=''|| exec('PxTexCMaterSel','px_tex',_pxtex) ?};
{? _pxtex.TieSelP='' || exec('PxTexCNastSel' ,'px_tex',_pxtex,'P') ?};
{? _pxtex.TieSelN='' || exec('PxTexCNastSel' ,'px_tex',_pxtex,'N') ?};
{? _pxtex.TexopSel=''|| exec('PxTexCTexopSel','px_tex',_pxtex) ?};
{? _pxtex.EtapSel='' || exec('PxTexCEtapSel' ,'px_tex',_pxtex) ?};

:: teraz glowne okno
{? _pxtex.PxTexSel=''
|| _tab:=_pxtex.PxTexTab;

   _grpbefor:="
      params_set(params_get());
      _pxtex:=PxTex;
      _pxtex.GridTab.first(); grp_disp(_pxtex.GridTab,_pxtex.GridSel);
      _pxtex.OperTab.first(); grp_disp(_pxtex.OperTab,_pxtex.OperSel,1);
::      _pxtex.FunTab.first(); grp_disp(_pxtex.FunTab ,_pxtex.FunSel );
      ~~
   ";

:: Ustawiam header w oknie
   _hdr_txt:='Przepis planistyczny';
   {? _pxtex.TKTL<>null()
   || TKTL.cntx_psh(); TKTL.clear();
      {? TKTL.seek(_pxtex.TKTL)
      || _hdr_txt+=' karty tech.: '+TKTL.NRK+' wersja: '+TKTL.WER
      ?};
      TKTL.cntx_pop()
   |? _pxtex.PX_TEX<>null()
   || PX_TEX.cntx_psh(); PX_TEX.clear();
      {? PX_TEX.seek(_pxtex.PX_TEX)
      || ZL.cntx_psh();
         {? PX_TEX.ZL<>null()
         || _hdr_txt+=' zlecenia: '+PX_TEX.ZL().SYM
         ?};
         ZL.cntx_pop()
      ?};
      PX_TEX.cntx_pop()
   ?};
   {? _pxtex.ViewOnly>0
   || _hdr_txt+=' [PODGLĄD]'
   || _hdr_txt+=' [EDYCJA]'
   ?};
   PX_MAT.prefix(null());
   _close:="
      _result:=1;
      {? exec('is_px_set','px_param')>0 & PxTex.ViewOnly=0
      || KOMM.init(250,,'Weryfikacja zestawów planistycznych w przepisie.'@);
::       Sprawdzam czy przepis jest uzywany w kolejce planu glownego
         _used:=0;
         _mainver:=exec('get_mainversion','px_ver');
         {? PxTex.PX_TEX<>null()
         || _used:=exec('used_in_queue','px_tex',PxTex.PX_TEX,_mainver);

::          Jesli przepis jest aktywny to aktualizuje zestawy startowe na obiektach
::          ktore uzywaja tego przepisu jako domyslnego
            _act:=exec('FindAndGet','#table',PX_TEX,#PxTex.PX_TEX,ref_name(PxTex.PX_TEX),\"AKT\",'');
            {? _act='T' & exec('get','#params',500366,2)=exec('kind_pxtex','px_set')
            || exec('update_px_set','px_tex',PxTex.PX_TEX)
            ?}
         |? PxTex.TKTL<>null()
         ||
            PX_TEX.cntx_psh();
            PX_TEX.index('TKTLMSYM');
            PX_TEX.prefix($PxTex.TKTL);
            {? PX_TEX.first()
            || {!
               |? {? _used=0 & exec('used_in_queue','px_tex',PX_TEX.ref(),_mainver)>0
                  || _used:=1
                  ?};
::                Jesli przepis jest aktywny to aktualizuje zestawy startowe na obiektach
::                ktore uzywaja tego przepisu jako domyslnego
                  {? PX_TEX.AKT='T' & exec('get','#params',500366,2)=exec('kind_pxtex','px_set')
                  || exec('update_px_set','px_tex',PX_TEX.ref())
                  ?};
                  PX_TEX.next()
               !}
            ?};
            PX_TEX.cntx_pop()
         ?};

         {? _used>0
         ||
::          Sprawdzam czy przepis zawiera wymagane zestawy źródlowe
            _src_chk:=1;
            {? PxTex.PX_TEX<>null()
            || _src_chk:=exec('has_start_sets','px_tex',PxTex.PX_TEX)
            |? PxTex.TKTL<>null()
            ||
               PX_TEX.cntx_psh();
               PX_TEX.index('TKTLMSYM');
               PX_TEX.prefix($PxTex.TKTL);
               {? PX_TEX.first()
               || {!
                  |? _src_chk:=exec('has_start_sets','px_tex',PxTex.PX_TEX);
                     PX_TEX.next() & _src_chk>0
                  !}
               ?};
               PX_TEX.cntx_pop()
            ?};

            {? _src_chk=0
            ||
               _loop:=1;
               {!
               |?
                  _msg0:='';
                  _msg1:='Przepis jest używany w kolejce planu głównego, ale nie zawiera wszystkich źródłowych zestawów'@;
                  _msg2:='planistycznych, które są wskazane na elementach kolejki.'@;
                  _msg3:='Przeliczenie planu zakończy się niepowodzeniem, dlatego wymagane jest poprawienie zestawów w przepisie'@;
                  _msg4:='lub usunięcie z kolejki elementów używajacych tego przepisu'@;
                  _msg_glued:=exec('form','#string','L',_msg1
                                                      ,_msg2
                                                      ,_msg0
                                                      ,_msg3
                                                      ,_msg4);
                  _choice:=FUN.choice(_msg_glued,,'Szczegóły'@,'Zakończ edycję'@,,,'Powrót do edycji przepisu'@);
                  {? _choice=1
                  || KOMM.select()
                  |? _choice=0
                  || _result:=0;
                     _loop:=0
                  |? _choice=2
                  || _loop:=0
                  ?};
                  _loop>0
               !}
            ?}
         ?}
      ?};
      _result
   ";
   _grp:=_tab.grp_make(_hdr_txt,_grpbefor,_pxtex.wid_PxTx,1,1,_close);
   _tab.grp_sel(_grp,_pxtex.GridTab,_pxtex.GridSel,'Zasoby'@,,,,,,,,,'maximized');
   _pxtex.GridTab.win_sel(_pxtex.GridSel);
   _pxtex.GridTab.hdr_sel('Zakres widocznych zasobów: użycie — wszystkie / aktywność — wszystkie'@);
   _tab.grp_sel(_grp,_pxtex.EtapTab,_pxtex.EtapSel,'Procesy'@,,,,,,,,,'maximized');
   _tab.grp_splt(_grp,'panel0','horizontal','dolny_fun_stage','9,34%');
::   _tab.grp_sel(_grp,_pxtex.FunTab,_pxtex.FunSel,,,,,,,,,,'maximized');
   _tab.grp_sel(_grp,_pxtex.OperTab,_pxtex.OperSel,,$("exec('aft_rfr_oper','px_tex',"+{? (!_pxtex)<>'' || !_pxtex || 'PxTex' ?}+")"),,,,,,,,'maximized_with_title');

::   _tab.grp_splt(_grp,'dolny','vertical','dolny_fun_stage',);
::  Zakładki Surowce/Poprzedniki/Następniki
   _tab.grp_splt(_grp,'dolny_fun_stage','horizontal','material','7,50%');
   _tab.grp_sel(_grp,_pxtex.MaterTab,_pxtex.MaterSel,'Surowce'@,,,,,,,,,'maximized');
::   _tab.grp_splt(_grp,'dolny_fun_stage','horizontal','dolny_tie',14);
   _tab.grp_sel(_grp,_pxtex.TieTabP,_pxtex.TieSelP,'Poprzedniki'@,,,,,,,,,'maximized');
::   _tab.grp_splt(_grp,'dolny_tie','horizontal','dolny_tie_nas',5);
   _tab.grp_sel(_grp,_pxtex.TieTabN,_pxtex.TieSelN,'Następniki'@,,,,,,,,,'maximized');

   _pxtex.PxTexSel:=_grp;
   ~~
?};
~~


\PxTexCGridTab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy tabele .GridTab
::   WE: PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_pxtex.MaxCol:=255-8;
{? _pxtex.DimX>_pxtex.MaxCol || _pxtex.DimX:=_pxtex.MaxCol ?};
:: formula na utworzenie tabeli
_fml:="tab_tmp(1";
:: dodawane sa kolumny
{! _col:=1.._pxtex.MaxCol |! _fml+="\n,'COL"+form(_col,-3,0,'99')+"','"+_pxtex.CellType+"','"+form(_col,,0,'99')+"'" !};
:: pozostaly pola opisowe i techniczne
_fml+="
      ,'KONT_N'   ,'STRING[100]','Nazwa'
      ,'KIND'     ,'STRING[1]' ,'Rodzaj'
      ,'COLOR'    ,'STRING[23]','Kolor wiersza'
      ,'ICON'     ,'STRING[16]','Ikona'
      ,'TAB_REF'  ,'INTEGER'   ,'#TAB.ref()'
      ,'TAB_NAM'  ,'STRING[8]' ,'TAB.name()'
      ,'USED'     ,'STRING[1]' ,'Używany'
      ,'A'        ,'STRING[1]' ,'Aktywny'
)";
:: formula gotowa, wiec czas ja wykonac i skasowac
_pxtex.GridTab:=($_fml)(); &_fml;

_pxtex.GridNd__:=_pxtex.GridTab.ndx_tmp(,
                                       ,'KIND'  ,,
                                       ,'KONT_N',,
                                       );

_pxtex.GridNdU_:=_pxtex.GridTab.ndx_tmp(,
                                       ,'USED'  ,,1
                                       ,'KIND'  ,,
                                       ,'KONT_N',,
                                       );

_pxtex.GridNdA_:=_pxtex.GridTab.ndx_tmp(,
                                       ,'A'     ,,1
                                       ,'KIND'  ,,
                                       ,'KONT_N',,
                                       );

_pxtex.GridNdAU:=_pxtex.GridTab.ndx_tmp(,
                                       ,'A'     ,,1
                                       ,'USED'  ,,
                                       ,'KIND'  ,,
                                       ,'KONT_N',,
                                       );

_pxtex.GridTab.index(_pxtex.GridNd__);

:: formuly pol

_pxtex.GridTab.fld_fml('USED'    ,'BEFORE_DISPLAY',"{? fld()='T' || Color.fnd_kol('PX_TEX#01#01') || ~~ ?}");
_pxtex.GridTab.fld_fml('A'       ,'BEFORE_DISPLAY',"{? fld()='N' || Color.fnd_kol('PX_TEX#01#02') || ~~ ?}");
_pxtex.GridTab.fld_fml('KONT_N'  ,'BEFORE_DISPLAY',"{? cur_tab(1,1).A='N' || Color.fnd_kol('PX_TEX#01#02') || ~~ ?}");

_pxtex.GridTab.fld_fml('USED'    ,'DISPLAY_FORMAT',{? _pxtex.DEVELOP=0 || "'empty=1'" || "{? fld()='' || 'empty=1' || 'empty=0' ?}" ?});
_pxtex.GridTab.fld_fml('A'       ,'DISPLAY_FORMAT',{? _pxtex.DEVELOP=0 || "'empty=1'" || "{? fld()='' || 'empty=1' || 'empty=0' ?}" ?});

::{! _col:=1.._pxtex.MaxCol
::|! _fld_acr:='COL'+form(_col,-3,0,'99');
::   _pxtex.GridTab.fld_fml(_fld_acr, 'DISPLAY_FORMAT',
::   {? _pxtex.DEVELOP=0 || "'empty=1'" || "{? fld()='' || 'empty=1' || 'empty=0' ?}" ?}
::   );
::   _pxtex.GridTab.fld_fml(_fld_acr, 'BEFORE_DISPLAY',$("exec('grid_color_zasoby','px_tex',"+{? (!_pxtex)<>'' || !_pxtex || 'PxTex' ?}+")"));
::   _pxtex.GridTab.fld_fml('COL'+form(_col,-3,0,'99'), 'BEFORE_DISPLAY',_pxtex.fml4BD);
::   ~~
::!};

~~


\grid_color_zasoby
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przed wyswietl pol w PxTex.GridTab. Zwraca kolor komórki w widoku.
::       UWAGA: Formuła niewykorzystywana - kolorowanie wg ikon
::   WE: PxTex
::   WY: Wynik dla przed wyswietl
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;

_result:=~~;
_fld:=cur_afld();
_nr:={? 3+_fld='COL' || #(3-_fld) || 0 ?};
{? _nr>0
||
   {? _pxtex.StageTab.find_key(_nr)
   || {? _pxtex.StageTab.STGCOLOR<>''
      || {? fld()<>''
         || _result:=_pxtex.StageTab.STGCOLOR+','+_pxtex.StageTab.STGCOLOR;
            {? fld()=1+exec('txt_plan_fwd','px_param')
            || fld():='!'
            || fld():=1+exec('txt_plan_fwd','px_param')
            ?}
         ?}
      || _result:=_pxtex.fml4BD()
      ?}
   || _kolor:=Color.fnd_kol('PX_TEX#01#03');
      _result:=_kolor+(_kolor-1)
   ?}
?};

_result


\grid_icon_zasoby
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Ikona przed dla kolumn w PxTex.GridTab. Zwraca ikonę komórki w widoku
::   WE: PxTex
::   WY: STRING - ikona
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
::_result:=exec('pusta','#icon');
_result:='';
_fld:=cur_afld();
_nr:={? 3+_fld='COL' || #(3-_fld) || 0 ?};
{? _nr>0
|| {? _pxtex.StageTab.find_key(_nr)
   || {? _pxtex.StageTab.STGCOLOR<>''
      || {? fld()<>''
         || _result:='%1,%2'[exec('px_tex_grid','icon'),_pxtex.StageTab.STGCOLOR];
            fld():=''
         ?}
      ?}
   || _result:='%1,%2'[exec('px_tex_grayed','icon'),Color.fnd_kol('PX_TEX#01#03')-1]
   ?}
?};

_result


\grid_color_procesy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [1246]
:: OPIS: Przed wyswietl pol w PxTex.EtapTab
::       UWAGA: Formuła niewykorzystywana - kolorowanie wg ikon
::   WE: PxTex
::   WY: Wynik dla przed wyswietl
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_fld:=cur_afld();
_tab:=cur_tab(1,1);
_nr:={? 3+_fld='COL' || #(3-_fld) || 0 ?};
_result:=~~;
{? _nr>0
||
   {? _pxtex.DimE>=_nr
   || {? fld()<>''
      ||
::       Wyciągam kolor
         {? _tab.TREE=0
         ||
::          Węzeł drzewa, wyciągam kolor z pierwszego liścia
            _tab.cntx_psh();
            _tab.prefix(_tab.ref());
            _selected:=0;
            {? _tab.first()
            || {!
               |?
                  _fml:='_tab:=_a;_tab.'+'COL'+form(_nr,-3,0,'99');
                  _value:=($_fml)(_tab);
                  {? _value<>''
                  || {? type_of(_result)=0
                     || _result:=exec('grid_color_find','px_tex',2)
                     ?};
                     {? exec('grid_etap_selected','px_tex')
                     || _selected:=1
                     ?}
                  ?};
                  _tab.next()
               !}
            ?};
            _tab.cntx_pop();
            {? _selected>0
            || fld()+='*'
            ?};
            ~~
         ||
::          Liść drzewa, wyciągam kolor z etapu
            {? exec('grid_etap_selected','px_tex')
            || fld():='*';
               _result:=exec('grid_color_find','px_tex',2)
            || fld():=1+exec('txt_plan_fwd','px_param');
               _result:=exec('grid_color_find','px_tex')
            ?};
            ~~
         ?}
      ?}
   || _kolor:=Color.fnd_kol('PX_TEX#01#03');
      _result:=_kolor+(_kolor-1)
   ?}
?};
_result


\grid_icon_procesy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Ikona przed dla kolumn w PxTex.EtapTab. Zwraca ikonę komórki w widoku PxTex.EtapTab
::   WE: PxTex
::   WY: STRING - ikona
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_fld:=cur_afld();
_tab:=cur_tab(1,1);
_nr:={? 3+_fld='COL' || #(3-_fld) || 0 ?};
::_result:=exec('pusta','#icon');
_result:='';
{? _nr>0
||
   {? _pxtex.DimE>=_nr
   || {? fld()<>''
      ||
::       Wyciągam kolor
         {? _tab.TREE=0
         || _color:=~~;
::          Węzeł drzewa, wyciągam kolor z pierwszego liścia
            _tab.cntx_psh();
            _tab.prefix(_tab.ref());
            _selected:=0;
            {? _tab.first()
            || {!
               |?
                  _fml:='_tab:=_a;_tab.'+'COL'+form(_nr,-3,0,'99');
                  _value:=($_fml)(_tab);
                  {? _value<>''
                  || {? type_of(_color)=0
                     || _color:=exec('grid_color_find','px_tex',,2)
                     ?};
                     {? exec('grid_etap_selected','px_tex')
                     || _selected:=1
                     ?}
                  ?};
                  _tab.next()
               !}
            ?};
            _tab.cntx_pop();
            {? type_of(_color)<>0
            || {? _selected>0
               || _result:='%1,%2'[exec('px_tex_selected','icon'),_color]
               || _result:='%1,%2'[exec('px_tex_grid','icon'),_color]
               ?}
            ?};
            ~~
         ||
::          Liść drzewa, wyciągam kolor z etapu
            {? exec('grid_etap_selected','px_tex')
            || _result:='%1,%2'[exec('px_tex_selected','icon'),exec('grid_color_find','px_tex',,2)]
            || _result:='%1,%2'[exec('px_tex_grid','icon'),exec('grid_color_find','px_tex',,2)]
            ?};
            ~~
         ?}
      ?}
   || _result:='%1,%2'[exec('px_tex_grayed','icon'),Color.fnd_kol('PX_TEX#01#03')-1]
   ?}
?};
_result


\grid_color_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Dla widoku procesów wyciąga kolor dla komórki w Grid z PX_STAGE
::   WE: [_a] - INTEGER - tryb kolorowania: 1 - tekst i tło takie samo
::                                          2 - tekst kontrastowy w stosunku do tła
::       [_b] - zwracany format koloru: [1] - kolor tekstu + tła (STRING w postaci: 'kolor,kolor')
::                                       2  - tylko kolor tła (STRING w postaci: 'kolor')
::   WY: STRING - kolor
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_mode:=1;
{? var_pres('_a')=type_of(0)
|| _mode:=_a
?};
_format:=1;
{? var_pres('_b')=type_of(0)
|| _format:=_b
?};

_tab:=cur_tab(1,1);
_result:=~~;
PX_STAGE.cntx_psh();
PX_STAGE.prefix();
{? PX_STAGE.seek(_tab.TAB_REF,_tab.TAB_NAM)
|| {? _format=1
   || {? _mode=1
      || _result:=PX_STAGE.KOLOR+','+PX_STAGE.KOLOR
      |? _mode=2
      || _result:=exec('contrast','#color',PX_STAGE.KOLOR,1)+','+PX_STAGE.KOLOR
      ?}
   |? _format=2
   || _result:=PX_STAGE.KOLOR
   ?}
?};
PX_STAGE.cntx_pop();
_result


\grid_etap_selected
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Dla widoku procesów wyciąga kolor dla komórki w Grid z PX_STAGE
::   WY: 0/1
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------

_tab:=cur_tab(1,1);
_result:=0;
PX_STAGE.cntx_psh();
PX_STAGE.prefix();
{? PX_STAGE.seek(_tab.TAB_REF,_tab.TAB_NAM)
|| {? PX_VAR.PX_STAGE=PX_STAGE.ref()
   || _result:=1
   ?}
?};
PX_STAGE.cntx_pop();
_result


\PxTexCGridSel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy okienko .GridSel - okienko z 'trybikami'
::   WE: PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_tab:=_pxtex.GridTab;

_win_ident:='#pxtexgridsel';
_wer:=_tab.mk_sel(,'P',0,_pxtex.wid_Grid,1,1,{? _tab.size()>30 || 30 || _tab.size() ?},,,,,,1);
_tab.win_fld(_wer,,'USED'  ,,,-7,,,'Używany'@,,'Zasób jest używany w przepisie.'@,2,,"'T'","'N'");
_tab.win_fld(_wer,,'A'     ,,,-7,,,'Aktywny'@,,'Zasób jest aktywny.'@,2,,"'T'","'N'");
_tab.win_fld(_wer,,'KONT_N',,,40,,,,,'Nazwa zasobu'@);

_def_cols:=exec('get','#params',8055,1,OPERATOR.USER);
_maxwfld:={? _pxtex.DimX>_pxtex.MaxWCol-3
          || _pxtex.MaxWCol-3
          || {? _pxtex.DimX>_def_cols
             || _pxtex.DimX
             || _def_cols
             ?}
          ?};
_maxwfld:=exec('min','#math',_pxtex.MaxWCol-3,_maxwfld);
{! _col:=1.._maxwfld
|! _tab.win_fld(_wer,,'COL'+form(_col,-3,0,'99'),,,3)
!};

_tab.win_fml(_wer,,'KONT_N',,'ICON_BEFORE',"{?cur_tab(1,1).ICON<>'' || cur_tab(1,1).ICON ||'xwin16.png:110'?}",2);

:: Ikonki w Grid
::_fml:="
::   {? fld()<>''
::   ||'xwin16.png:188'
::   ||'xwin16.png:110'
::   ?}
::";
::{! _col:=1.._pxtex.MaxCol
::|! _tab.win_fml(_wer,,'COL'+form(_col,-3,0,'99'),_fml,'ICON_BEFORE',"",2)
::!};

_fml:=$("exec('grid_icon_zasoby','px_tex',"+{? (!_pxtex)<>'' || !_pxtex || 'PxTex' ?}+")");
{! _col:=1.._pxtex.MaxCol
|! _tab.win_fml(_wer,,'COL'+form(_col,-3,0,'99'),,'ICON_BEFORE',_fml,2)
!};

_tab.win_act(_wer,,'Wyświetl',,,,
   "
     {? cur_tab(1,1).TAB_REF>0
     || PX_KONT.cntx_psh(); PX_KONT.prefix();
        {? PX_KONT.seek(cur_tab(1,1).TAB_REF,cur_tab(1,1).TAB_NAM)
        || PX_KONT.win_edit('DISP');
           PX_KONT.display()
        ?};
        PX_KONT.cntx_pop()
     ?};
     ~~
   ");

_tab.win_act(_wer,,'Rekord',,,,"exec('PxTexGridTabrek','px_tex',PxTex)");
_tab.win_act(_wer,0,'Formuła','&Zakres'@@,,,"exec('PxTexGridZakres','px_tex',PxTex)",,1,,,,'Z');
_tab.win_act(_wer,1,'Formuła','&Zakres'@@,,,"exec('PxTexGridZakres','px_tex',PxTex)",,1,,,,'Z');
{? _pxtex.ViewOnly=0
||
   _tab.dnd_sel(_wer,,'records.'+_pxtex.wid_Grid,"exec('PxTex_dnd_Grid','px_tex',PxTex,'Grid')");
::   _tab.dnd_sel(_wer,,'records.'+_pxtex.wid_Row ,"exec('PxTex_dnd_Grid','px_tex',PxTex,'Row' )");
   _tab.dnd_sel(_wer,,'records.'+_pxtex.wid_Fun ,"exec('PxTex_dnd_Grid','px_tex',PxTex,'Fun' )");
::   _tab.dnd_sel(_wer,,'records.'+_pxtex.wid_Oper,"exec('PxTex_dnd_Grid','px_tex',PxTex,'Oper')");
   ~~
?};

_formula:="exec('legenda','color','@PX_TEX#01','#PX_KONT#01','#PX_GRID#01')";
_tab.win_act(_wer,,'Formuła','&Legenda'@@,,,_formula,,,,,,'L');
_pxtex.GridSel:=_wer;
~~


\PxTexCRowTab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy tabele .RowTab
::   WE: PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;

_pxtex.RowTab:=tab_tmp(2
                      ,'COL_NR','INTEGER',''
                      ,'COL_NAM','STRING[60]',''
                      ,'VALUE' ,_pxtex.CellType,''
                      ,'AKT'   ,'STRING[1]',''
                      );
_pos:=PX_VAR.GREY*',';
_color:={? _pos || ','+(_pos-PX_VAR.GREY) || ','+_color ?};
_pxtex.RowTab.fld_fml('COL_NR','BEFORE_DISPLAY',$("'"+_color+"'"));
_pxtex.RowTab.fld_fml('VALUE' ,'BEFORE_DISPLAY',_pxtex.fml4BD);
_pxtex.RowTab.fld_fml('VALUE' ,'DISPLAY_FORMAT',
   {? _pxtex.DEVELOP=0 || "'empty=1'" || "{? fld()=0 || 'empty=1' || 'empty=0' ?}" ?}
   );

~~


\PxTexCFunTab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy tabele .FunTab
::   WE: PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;

_pxtex.FunTab:=tab_tmp(2
                      ,'LP'   ,'INTEGER'   ,'Lp'
                      ,'NAM'  ,'STRING[20]','Funkcja'
                      ,'FUNID','STRING[20]','Identyfikator'
                      ,'COLOR','STRING[25]','Kolor'
                      ,'ICON' ,'STRING[20]','Ikona'
                      );
::_pxtex.FunTab.fld_fml('NAM','BEFORE_DISPLAY',"',200:255:200'");

{? _pxtex.DEVELOP=0 || _pxtex.FunTab.fld_attr(,2) ?};
exec('PxTexCFunTabL','px_tex',_pxtex);
~~


\PxTexCFunSel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy okienko .FunSel - tabelka z akcjami do d'n'd
::   WE: _a - PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_tab:=_pxtex.FunTab;

_wer:=_tab.mk_sel('Dostępne funkcje'@,'P',0,_pxtex.wid_Fun,1,1,{? _tab.size()>30 || 30 || _tab.size() ?});
_tab.win_fld(_wer,,'NAM' ,,,20,,,' '@,1);

_tab.win_act(_wer,,'Rekord',,,,"{? cur_tab(1,1).COLOR<>'' || cur_tab(1,1).COLOR || ~~ ?}");
{? _pxtex.ViewOnly=0
||
::   _tab.dnd_sel(_wer,,'records.'+_pxtex.wid_Grid,"exec('PxTex_dnd_Fun','px_tex',PxTex,'Grid')");
::   _tab.dnd_sel(_wer,,'records.'+_pxtex.wid_Row ,"exec('PxTex_dnd_Fun','px_tex',PxTex,'Row' )");
::   _tab.dnd_sel(_wer,,'records.'+_pxtex.wid_Fun ,"exec('PxTex_dnd_Fun','px_tex',PxTex,'Fun' )");
::   _tab.dnd_sel(_wer,,'records.'+_pxtex.wid_Oper,"exec('PxTex_dnd_Fun','px_tex',PxTex,'Oper')");
   ~~
?};

_pxtex.FunTab.win_sel(_wer);
_pxtex.FunSel:=_wer;
~~


\PxTexCStageTab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy tabele .StageTab
::   WE: PxTex
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;

_pxtex.StageTab:=tab_tmp(1
                        ,'NR'      ,'INTEGER'    ,''
                        ,'NAZ'     ,'STRING[60]' ,''
                        ,'NAME'    ,'STRING[8]'  ,''
                        ,'REF'     ,'INTEGER'    ,''
                        ,'STGCOLOR','STRING[25]' ,'Kolor etapu'
                        );
~~


\PxTexCOperTab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy tabele .OperTab
::   WE: _a - PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;

_pxtex.OperTab:=tab_tmp(2
                      ,'PARENT'  ,'TREE_REF'   ,'Rodzic'
                      ,'NAM'     ,'STRING[100]','Pozycja'
                      ,'CAP_USE1','REAL'       ,'Wymiar 1'
                      ,'CAP_USE2','REAL'       ,'Wymiar 2'
                      ,'CAP_USE3','REAL'       ,'Wymiar 3'
                      ,'CAP_USE4','REAL'       ,'Wymiar 4'
                      ,'CAP_USE5','REAL'       ,'Wymiar 5'

                      ,'JM1'     ,'STRING[10]' ,'jm 1'
                      ,'JM2'     ,'STRING[10]' ,'jm 2'
                      ,'JM3'     ,'STRING[10]' ,'jm 3'
                      ,'JM4'     ,'STRING[10]' ,'jm 4'
                      ,'JM5'     ,'STRING[10]' ,'jm 5'

                      ,'STAGE_NR','INTEGER'    ,'Nr operacji'
                      ,'NAST',    'STRING[80]' ,'Następniki etapu'
                      ,'COLOR'   ,'STRING[25]' ,'Kolor rekordu w oknie'
                      ,'STGCOLOR','STRING[25]' ,'Kolor etapu'
                      ,'COLORCOL','STRING[5]'  ,'Kolumna wyświetlająca kolor'
                      ,'PX_SET'  ,'STRING[16]' ,'$PX_SET.ref'
                      ,'SET_SYM' ,'STRING[100]','Zestaw'
                      ,'SET_OK'  ,'STRING[1]'  ,'Czy zestaw ok?'
                      ,'ICON'    ,'STRING[20]' ,'Ikona'
                      ,'STAGENAM','STRING[8]'  ,''
                      ,'STAGEREF','INTEGER'    ,''
                      ,'OPER_NAM','STRING[8]'  ,''
                      ,'OPER_REF','INTEGER'    ,''
                      ,'KONT_NAM','STRING[8]'  ,''
                      ,'KONT_REF','INTEGER'    ,''
                      ,'REC_KIND','STRING[1]'  ,''
                      ,'KONT_DIM','INTEGER'    ,''
                      ,'CONN_OK' ,'STRING[1]'  ,''
                      );

{? _pxtex.DEVELOP=0 || _pxtex.OperTab.fld_attr(,2) ?};

_pxtex.OperNdxO:=_pxtex.OperTab.ndx_tmp(,
                                       ,'STAGE_NR',,
                                       ,'KONT_NAM',,
                                       ,'KONT_REF',,
                                       );


{! _cc:=1..5
|! _pxtex.OperTab.fld_fml('CAP_USE'+form(_cc),'DISPLAY_FORMAT'
                         ,$("{? cur_tab(1,1).KONT_DIM<"+$_cc+"
                              | cur_tab(1,1).REC_KIND='S'
                             ||'empty=1'
                             ||'empty=0'
                             ?}
                            "
                           )
                         )
!};
~~


\PxTexCOperSel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy okienko .OperSel - drzewo z etapami i px_operami
::   WE: _a - PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_tab:=_pxtex.OperTab;

_wer:=_tab.mk_sel('Etapy przepisu planistycznego'@,'P',0,_pxtex.wid_Oper,1,1,{? _tab.size()>30 || 30 || _tab.size() ?},1,,,,,1);
_tab.win_fld(_wer,,'NAM' ,,,60,,,'Etap'@,,'Nazwa etapu przepisu planistycznego'@);
{? exec('is_px_set','px_param')>0
|| _tab.win_fld(_wer,,'SET_SYM' ,,,20,,,'Zestaw'@);
   _fml:="
      _result:='';
      {? cur_tab(1,1).SET_OK='N'
      || _result:=Color.fnd_kol('PX_STAGE#01#03')
      ?};
      _result
   ";
   _tab.fld_fml('SET_SYM','BEFORE_DISPLAY',_fml)
?};

:: Kolumna z kolorem
_tab.win_fld(_wer,,'COLORCOL',,,5,,,'Kolor'@,,'Kolor etapu'@);
::_fml:="
::   _result:='';
::   {? cur_tab(1,1).STGCOLOR<>''
::   || _result:=cur_tab(1,1).STGCOLOR+','+cur_tab(1,1).STGCOLOR
::   ?}
::";
::_tab.fld_fml('COLORCOL','BEFORE_DISPLAY',_fml);
_formula:="
   _result:=exec('pusta','#icon');
   {? cur_tab(1,1).STGCOLOR<>''
   || _result:='%1,%2'[exec('px_tex_color','icon'),cur_tab(1,1).STGCOLOR]
   ?};
   _result
";
_tab.win_fml(_wer,,'COLORCOL',,'ICON_BEFORE',_formula);

::{? _pxtex.DEVELOP=0
::|| _fml:="'empty=1'"
::|| _fml:="
::      {? fld()<>''
::      || 'empty=1'
::      || 'empty=0'
::      ?}"
::?};
::_tab.fld_fml('STGCOLOR','DISPLAY_FORMAT',_fml);
_tab.win_fld(_wer,,'NAST',,,10,,,'Następniki'@,,'Następniki etapu'@);

{! _cc:=1.._pxtex.MaxKontD
|! _tab.win_fld(_wer,,'CAP_USE'+form(_cc) ,,,,5,,,,'Obciażenie w wymiarze'@);
   _tab.win_fld(_wer,,'JM'+form(_cc) ,,,,,,,,'Jednostka miary'@)
!};

_formula:=" {? cur_tab(1,1).tr_state()
            || 'xwin16.png:75'
            || 'xwin16.png:74'
            ?}";

_tab.win_act(_wer,,'Rekord',,,,$("exec('PxTexOperbrek','px_oper',"+{? (!_pxtex)<>'' || !_pxtex || 'PxTex' ?}+")"));
_tab.win_act(_wer,,'Wyświetl',,,,"
   _tab:=cur_tab(1,1);
   {? _tab.OPER_REF
   || _px_oper:=exec('FindAndGet','#table',PX_OPER,_tab.OPER_REF,_tab.OPER_NAM,\"ref()\",null());
      {? _px_oper<>null() || exec('PX_OPER_view','px_oper',_px_oper) ?}
   |? _tab.STAGEREF
   || _px_stage:=exec('FindAndGet','#table',PX_STAGE,_tab.STAGEREF,_tab.STAGENAM,\"ref()\",null());
      {? _px_stage<>null() || exec('PX_STAGE_view','px_stage',_px_stage) ?}
   ?}
");

{? _pxtex.ViewOnly=0
||
   _formula:=$("exec('PxTexOperTabadd','px_tex',"+{? (!_pxtex)<>'' || !_pxtex || 'PxTex' ?}+",0);0");
   _tab.win_act(_wer,0,'Formuła','&Dołącz'@@,,,_formula,,,,,,'D');

   _formula:=$("exec('PxTexOperTabadd','px_tex',"+{? (!_pxtex)<>'' || !_pxtex || 'PxTex' ?}+",1);0");
   _tab.win_act(_wer,0,'DołączS',,,,_formula);

   _formula:=$("exec('PxTexOperTabadd','px_tex',"+{? (!_pxtex)<>'' || !_pxtex || 'PxTex' ?}+",1);0");
   _tab.win_act(_wer,1,'Formuła','&Dołącz'@@,,,_formula,,1,,,,'D');

   _formula:=$("exec('PxTexOperTabput','px_tex',"+{? (!_pxtex)<>'' || !_pxtex || 'PxTex' ?}+");0");
   _tab.win_act(_wer,,'Formuła' ,'&Popraw'@@,,,_formula,,,,,,'P');

   _formula:=$("exec('PxTexOperTabdel','px_tex',"+{? (!_pxtex)<>'' || !_pxtex || 'PxTex' ?}+");0");
   _gr1:=$("exec('PxTexOperDelGr1','px_tex',"+{? (!_pxtex)<>'' || !_pxtex || 'PxTex' ?}+")");
   _gr2:=$("exec('PxTexOperDelGr2','px_tex',"+{? (!_pxtex)<>'' || !_pxtex || 'PxTex' ?}+")");
   _tab.win_act(_wer,,'Formuła' ,'&Usuń'@@,,,_formula,,,1,_gr1,_gr2,'U');


::   _tab.dnd_sel(_wer,,'records.'+_pxtex.wid_Grid,"exec('PxTex_dnd_Oper','px_tex',PxTex,'Grid')");
::   _tab.dnd_sel(_wer,,'records.'+_pxtex.wid_Row ,"exec('PxTex_dnd_Oper','px_tex',PxTex,'Row' )");
::   _tab.dnd_sel(_wer,,'records.'+_pxtex.wid_Fun ,"exec('PxTex_dnd_Oper','px_tex',PxTex,'Fun' )");
::   _tab.dnd_sel(_wer,,'records.'+_pxtex.wid_Oper,"exec('PxTex_dnd_Oper','px_tex',PxTex,'Oper')");
   ~~
|? _pxtex.ViewOnly=1
||
:: Jesli sa popsute powiazania to udostepniam funkcje popraw
   {? exec('conns_ok','px_tex',_pxtex.RootRef)=0
   ||
      _formula:=$("exec('PxTexOperTabput','px_tex',"+{? (!_pxtex)<>'' || !_pxtex || 'PxTex' ?}+");0");
      _tab.win_act(_wer,,'Formuła','&Popraw'@@,,,_formula,,,,,,'P')
   ?}
?};
_tab.win_act(_wer,,'Formuła','Z&wiń/rozwiń'@@,,,"exec('zwrw_all','#tree',cur_tab(1,1),'PARENT')",,1,,,,'W');

_formula:="exec('legenda','color','@PX_STAGE#01')";
_tab.win_act(_wer,,'Formuła','&Legenda'@@,,,_formula,,,,,,'L');

_formula:=" _result:='';
            {? PxTex.OperTab.CONN_OK='N'
            ||
::             Ikona wykrzyknik
               _result:='xwin16.png:4'
            ||
::             Ikona folderek otwarty/zamkniety
               {? cur_tab(1,1).PARENT=0
               ||
                  {? cur_tab(1,1).tr_state()
                  || _result:='xwin16.png:75'
                  || _result:='xwin16.png:74'
                  ?}
               ?}
            ?};
            _result";
_tab.win_fml(_wer,,'NAM',,'ICON_BEFORE',_formula);

::{? _pxtex.ViewOnly=0
::||
::   _ttree:=exec('oper_treeview','px_tex');
::   {? type_of(_ttree)<>~~
::   || {? _pxtex.TKTL<>null()
::      || _pxtex.OperTab.dnd_sel(_wer,,'records.#tree_wert',"exec('dnd_tie_toper2','px_tex')")
::      ?}
::   ?}
::?};

_pxtex.OperTab.win_sel(_wer);
_pxtex.OperSel:=_wer;
~~


\aft_rfr_oper
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Formula po odswiezeniu .OperSel - drzewo z etapami i px_operami
::   WE: _a - PxTex
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PxTex');
_args.PxTex:=_a;

_loc:=obj_new('Tab');
_loc.Tab:=_args.PxTex.OperTab;

PX_STAGE.cntx_psh();
PX_STAGE.clear();
{? PX_STAGE.seek(_loc.Tab.STAGEREF,_loc.Tab.STAGENAM)
||
   PX_VAR.PX_STAGE:=PX_STAGE.ref();
   {? _args.PxTex.TKTL<>null()
   ||
::    Ladowanie tabelki powiazan operacji technologicznych z etapami przepisu
      exec('load_tie_toper','px_tex',_args.PxTex,PX_STAGE.ref());
::    Okna TieSel nie ma w grupie jesli TKTL jest nullem
      grp_disp(_args.PxTex.TieTabP,_args.PxTex.TieSelP);
      grp_disp(_args.PxTex.TieTabN,_args.PxTex.TieSelN);

::    Doklejanie do tytulu okna nazwy etapu
      _args.PxTex.TieTabP.hdr_sel();
      _args.PxTex.TieTabP.hdr_sel(PX_STAGE.NAZWA);

      _args.PxTex.TieTabN.hdr_sel();
      _args.PxTex.TieTabN.hdr_sel(PX_STAGE.NAZWA)
   ?};
   exec('prefix_tmat','px_mat',PX_STAGE.ref());
:: Doklejanie do tytulu okna nazwy etapu
   _args.PxTex.MaterTab.hdr_sel();
   _args.PxTex.MaterTab.hdr_sel(' powiązane z etapem: %1'@[PX_STAGE.NAZWA])
||
   PX_VAR.PX_STAGE:=null();
   exec('load_tie_toper','px_tex',_args.PxTex,null());
   ~~
?};
grp_disp(_args.PxTex.MaterTab,_args.PxTex.MaterSel);
grp_disp(_args.PxTex.EtapTab,_args.PxTex.EtapSel);
PX_STAGE.cntx_pop();

~~


\PxTexCTieTab
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Tworzy tabele .TieTab - powiazania TOPER/ZOPER z PX_STAGE
::   WE: _a - PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_pxtex.TieTabN:=tab_tmp( 2
                        ,'SQL_REF'  ,'STRING[16]','Ref. SQL'
                        ,'R'        ,'STRING[1]' ,'N/P'
                        ,'TYP'      ,'STRING[8]' ,'Typ - ZOPER/TOPER'
                        ,'NR'       ,'INTEGER'   ,'Nr'
                        ,'SYMBOL'   ,'STRING[10]','Symbol'
                        ,'NAZWA'    ,'STRING[50]','Nazwa'
                        ,'NSQL_REF' ,'STRING[16]','Ref. SQL nastepnik'
                        ,'SQL_TKTL' ,'STRING[16]','Ref SQL TKTL'
                        ,'SQL_TEX'  ,'STRING[16]','Ref SQL PX_TEX'
                        ,'SQL_ZL'   ,'STRING[16]','Ref SQL ZL'
                        ,'SQL_STAG' ,'STRING[16]','PX_NAST.PX_STAGE'
                        ,'SQL_NEXT' ,'STRING[16]','PX_NAST.PX_NEXT'
                        ,'SCIEZKA'  ,'STRING[40]','PX_NAST.SCIEZKA'
                        );
_pxtex.TieTabN.fld_attr('NR',,2);
_pxtex.TieTabP:=tab_tmp( 2
                        ,'SQL_REF'  ,'STRING[16]','Ref. SQL'
                        ,'R'        ,'STRING[1]' ,'N/P'
                        ,'TYP'      ,'STRING[8]' ,'Typ - ZOPER/TOPER'
                        ,'NR'       ,'INTEGER'   ,'Nr'
                        ,'SYMBOL'   ,'STRING[10]','Symbol'
                        ,'NAZWA'    ,'STRING[50]','Nazwa'
                        ,'SQL_TKTL' ,'STRING[16]','Ref SQL TKTL'
                        ,'SQL_TEX'  ,'STRING[16]','Ref SQL PX_TEX'
                        ,'SQL_ZL'   ,'STRING[16]','Ref SQL ZL'
                        ,'SQL_STAG' ,'STRING[16]','PX_NAST.PX_STAGE'
                        ,'SQL_NEXT' ,'STRING[16]','PX_NAST.PX_NEXT'
                        ,'SCIEZKA'  ,'STRING[40]','PX_NAST.SCIEZKA'
                        );
_pxtex.TieTabP.fld_attr('NR',,2);
~~


\PxTexCNastSel
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Tworzy okienko .TieTabN lub TieTabP  - poprzedniki/następniki etapu
::   WE: _a - PxTex
::       _b - STRING - 'N'/'P' nastepnik/poprzednik
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_tab:={? _b='N' || _pxtex.TieTabN || _pxtex.TieTabP ?};

{? _b='N'
|| _txt:='Następniki etapu: '
|| _txt:='Poprzedniki etapu: '
?};
_wer:=_tab.mk_sel(_txt,'P',0,{? _b='N' || _pxtex.wid_TieN || _pxtex.wid_TieP ?},1,1,{? _tab.size()>30 || 30 || _tab.size() ?});
_tab.win_fld(_wer,,'NR' ,,,5,,0,'Nr'@,0,'Numer operacji'@);
_tab.win_fld(_wer,,'NAZWA' ,,,50,,1,'Operacja'@,0,'Nazwa operacji'@);

_tab.win_sel(_wer);
{? _b='N'
|| _tab.fld_fml('NR','F3',"exec('nastlist','px_nast',VAR.A_KTL)");
   {? _pxtex.ViewOnly=0
   ||
      _tab.win_act(_wer,1,'Formuła','Dołącz'@@,,,"exec('tieadd','px_nast',PxTex)",,1);
      _tab.win_act(_wer,,'Formuła','Dołącz'@@,,,"exec('tieadd','px_nast',PxTex)",,1);
      _tab.win_act(_wer,,'Popraw',,,,"exec('tieup','px_nast',PxTex)","exec('tieupae','px_nast',PxTex)",);
      _tab.win_act(_wer,,'Formuła' ,'Usuń'@@,,,"exec('tie_del','px_nast',PxTex,cur_tab(1,1).SQL_REF,cur_tab(1,1).NSQL_REF)");
      ~~
   ?};
   _pxtex.TieSelN:=_wer
|| _pxtex.TieSelP:=_wer
?};
~~


\PxTexCTexopSel
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Tworzy okienko .TexopSel - operacje technologiczne
::   WE: _a - PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_ttree:=exec('oper_treeview','px_tex');
{? type_of(_ttree)<>~~
|| _ttree.TAB.win_sel(_ttree.WERT);
   _pxtex.TexopSel:=_ttree.WERT;
   _ttree.TAB.hdr_sel(' — '+'Operacje karty technologicznej'@)
?};
~~


\PxTexCTexopLoad
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Laduje zawartosc .TexopSel - operacje technologiczne
::   WE: _a - PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
~~


\PxTexOperTabadd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Dolacz w PxTex.OperTab
::   WE: _a - PxTex
::       _b - NUMBER - o ile zwiekszyc aktualny nr etapu
::   WY:
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_nradd:=_b;
_tab:=cur_tab(1,1);
_cbd:='';
{? _tab.REC_KIND='S'
 & _tab.STAGEREF
|| _szto:=FUN.choice('Typ dołączanego elementu'@,1,'Etap'@,'Powiązanie z zasobem'@);
   {? _szto=1 || _cbd:='STAGE'
   |? _szto=2 || _cbd:='OPER'
   ?}
|? _tab.REC_KIND='O'
 & _tab.OPER_REF
|| _cbd:='OPER'
|| _cbd:='STAGE'
?};
_stage:=exec('FindAndGet','#table',PX_STAGE,_tab.STAGEREF,,"ref()",0);
_nr:={? _tab.STAGEREF>0 || exec('FindAndGet','#table',PX_STAGE,_tab.STAGEREF,,"NR",0) || 0 ?};
{? {? _cbd='STAGE' || exec('PX_STAGE_add','px_stage', _pxtex.RootRef,_nr+_nradd)
   |? _cbd='OPER'  || exec('PX_OPER_add','px_oper',_stage,_pxtex)
   ?}
|| _pxtex.refresh()
?};
~~


\PxTexOperTabput
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Popraw w PxTex.OperTab
::   WE: PxTex
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_tab:=cur_tab(1,1);

{? _tab.OPER_REF
|| _px_oper:=exec('FindAndGet','#table',PX_OPER,_tab.OPER_REF,_tab.OPER_NAM,"ref()",null());
   {? _px_oper<>null() || exec('PX_OPER_edit','px_oper',_px_oper,"PX_OPER.put()") ?}
|? _tab.STAGEREF
|| _px_stage:=exec('FindAndGet','#table',PX_STAGE,_tab.STAGEREF,_tab.STAGENAM,"ref()",null());
   {? _px_stage<>null()
   ||
::    Przed edycja zapamietuje rekord w ktorym stalem
      _before:=_tab.ref();
      {? exec('PX_STAGE_put','px_stage',_px_stage)
      || _pxtex.refresh();

::       Po odtworzeniu widoku szukam rekordu na ktorym stalem
         _tab.seek(_before)
      ?}
   ?}
?}


\PxTexOperTabdel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Usuń w PxTex.OperTab
::   WE: PxTex
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_tab:=cur_tab(1,1);

_group:=0;
_can_continue:=1;
{? _tab.sel_size()>0
|| _group:=1
?};

{? _tab.REC_KIND='S' & _tab.STAGEREF
||
:: Dla akcji nie grupowej pytam czy na pewno usunac
   {? _group=0
   || _can_continue:=FUN.ask('Czy na pewno usunąć: %1?'@[_pxtex.OperTab.NAM])
   ?};

   {? _can_continue>0
   || _stage:=exec('FindAndGet','#table',PX_STAGE,_tab.STAGEREF,,"ref()",0);
      {? exec('PX_STAGE_del','px_stage',_stage)
      || exec('PX_STAGE_renum','px_stage',_pxtex.RootRef);

::       Dla akcji nie grupowej odswiezam widok
         {? _group=0
         || _pxtex.refresh()
         ?}
      || FUN.info('Usunięcie etapu zakończone niepowodzeniem.'@)
      ?}
   ?}

|? _tab.REC_KIND='O' & _tab.OPER_REF
||
:: Dla akcji nie grupowej pytam czy na pewno usunac
   {? _group=0
   || _can_continue:=FUN.ask('Czy na pewno usunąć powiązanie etapu z %1?'@[_pxtex.OperTab.NAM])
   ?};

   {? _can_continue>0
   || _oper:=exec('FindAndGet','#table',PX_OPER,_tab.OPER_REF,,"ref()",null());
      {? _oper<>null()
      || {? exec('PX_OPER_del','px_oper',_oper)
         ||
::          Dla akcji nie grupowej odswiezam widok
            {? _group=0
            || _pxtex.refresh()
            ?}
         || FUN.info('Usunięcie powiązania z zasobem zakończone niepowodzeniem.'@)
         ?}
      ?}
   ?}
?};
~~


\PxTexOperDelGr1
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Grupa przed Usun w PxTex.OperTab
::   WE: _a - PxTex
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_tab:=cur_tab(1,1);
_result:=FUN.ask('Zaznaczonych rekordów: '+$_tab.sel_size()+'\nCzy na pewno usunąć zaznaczone rekordy?');
_result


\PxTexOperDelGr2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Grupa po Usun w PxTex.OperTab
::   WE: _a - PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_pxtex.refresh();
~~


\PxTexRow_brek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przed rekord dla PxTex.RowTab
::   WE: PxTex
::   WY:
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
{? _tab.AKT='N'
|| PX_VAR.GREY
|| ~~
?}


\PxTex_dnd_Grid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Obsluga d'n'd dla GridTab w PxTex
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PxTex','Way');
_args.PxTex:=_a;
_args.Way:=_b;
:{? _args.PxTex.DEVELOP=1 || FUN.info(exec('dnd_info','#dragdrop')) ?};

_loc:=obj_new('dnd_info','Src','Dst','dropsize');
_dstsrc:="_ds:=obj_new('PX_KONT','PX_OPER','PX_STAGE','OperRef','GridRef','RowRef','FunRef');
          {!_cc:=1..obj_len(_ds)|!_ds[_cc]:=null()!};
          _ds
         ";
_loc.Src:=_dstsrc();
_loc.Dst:=_dstsrc();
_loc.dnd_info:=exec('get_dnd_info','#dragdrop');
_loc.dropsize:=_loc.dnd_info.source.records.size();
:: najpierw docelowo, bo to wiadomo co to jest
Cntx.psh(PX_OPER, PX_KONT, _args.PxTex.GridTab, _args.PxTex.OperTab);
Cntx.clr(PX_OPER, PX_KONT, _args.PxTex.GridTab, _args.PxTex.OperTab);

_loc.Dst.PX_STAGE:={? 3+_loc.dnd_info.dest.fld_acr='COL'
                    & _args.PxTex.StageTab.find_key(#(3-_loc.dnd_info.dest.fld_acr))
                   || exec('FindAndGet','#table',PX_STAGE,_args.PxTex.StageTab.REF,_args.PxTex.StageTab.NAME,"ref()",null())
                   || null()
                   ?};

_loc.Dst.PX_KONT:={? _args.PxTex.GridTab.seek(_loc.dnd_info.dest.record)
                  || _loc.Dst.GridRef:=_args.PxTex.GridTab.ref();
                     exec('FindAndGet','#table',PX_KONT,_args.PxTex.GridTab.TAB_REF,_args.PxTex.GridTab.TAB_NAM)
                  || null()
                  ?};

:: szukam teraz PX_OPER dla zadanego PX_KONT i PX_STAGE
_loc.Dst.PX_OPER:=exec('getPX_OPER_StKo','px_oper',_loc.Dst.PX_STAGE,_loc.Dst.PX_KONT);

Cntx.pop(PX_OPER, PX_KONT, _args.PxTex.GridTab, _args.PxTex.OperTab);

:: teraz akcja dla zrodlowych
{? _args.PxTex.ViewOnly
 | _loc.dropsize<1
|| ~~
|? _args.Way='Grid'
|| 'Grid';
   Cntx.psh(PX_OPER, PX_KONT, _args.PxTex.GridTab, _args.PxTex.OperTab);
   Cntx.clr(PX_OPER, PX_KONT, _args.PxTex.GridTab, _args.PxTex.OperTab);

:: Zastanawiamy sie nad przenosinami jezeli wystapily one tylko w ramach kolumn
:: dodatkowo przenosiny w ramach Grida mozliwe sa w nastepujacych przypadkach
:: dla _loc.dropsize=1
::    zmiana kolumny: tak
::    zmiana wiersza: tak
::
:: dla _loc.dropsize>1
::    zmiana kolumny: tak
::    zmiana wiersza: nie
::
:: czyli... gdy zmienily sie kolumny lub jest tylko jeden rekord
   _loc.Src.PX_STAGE:={? 3+_loc.dnd_info.source.fld_acr='COL'
                       & _args.PxTex.StageTab.find_key(#(3-_loc.dnd_info.source.fld_acr))
                      || exec('FindAndGet','#table',PX_STAGE,_args.PxTex.StageTab.REF,_args.PxTex.StageTab.NAME,"ref()",null())
                      || null()
                      ?};
   {? ( _loc.Src.PX_STAGE<>null() & _loc.Dst.PX_STAGE<>null() )
    & ( _loc.Src.PX_STAGE<>_loc.Dst.PX_STAGE
      | _loc.dropsize=1
      )
   ||
::    mamy operacje docelowa, to patrzymy, co jest przenoszone
      {!
      |?
         _loc.Src.PX_STAGE:=null();
         _loc.Src.PX_KONT:=null();
         _loc.Src.PX_OPER:=null();

         {? _args.PxTex.GridTab.seek(_loc.dnd_info.source.records.REF,)
         ||
            _loc.Src.PX_STAGE:={? 3+_loc.dnd_info.source.fld_acr='COL'
                                & _args.PxTex.StageTab.find_key(#(3-_loc.dnd_info.source.fld_acr))
                               || exec('FindAndGet','#table',PX_STAGE,_args.PxTex.StageTab.REF,_args.PxTex.StageTab.NAME,"ref()",null())
                               || null()
                               ?};


            _loc.Src.PX_KONT:=exec('FindAndGet','#table'
                                  ,PX_KONT
                                  ,_args.PxTex.GridTab.TAB_REF
                                  ,_args.PxTex.GridTab.TAB_NAM
                                  ,"ref()"
                                  ,null()
                                  ,0
                                  );

            {? _loc.Src.PX_KONT<>null()
             & _loc.Src.PX_STAGE<>null()
            || _loc.Src.PX_OPER:=exec('getPX_OPER_StKo','px_oper',_loc.Src.PX_STAGE,_loc.Src.PX_KONT);

::             jezeli mamy wiecej rekodow, to znaczy ze przenosimy kolumny - zrodlowy rekord pozostaje bez zmian
               {? _loc.dropsize>1
               || _loc.Dst.PX_KONT:=_loc.Src.PX_KONT;
                  ~~
               ?};
::             ok, sprawdzamy czy wystapila jakas zmiana i jesli tak, to przenosimy
               {? ( _loc.Dst.PX_STAGE<>_loc.Src.PX_STAGE
                  | _loc.Dst.PX_KONT<>_loc.Src.PX_KONT
                  )
                  & _loc.Dst.PX_KONT<>null()
                  & _loc.Dst.PX_STAGE<>null()
               ||
::                kontrola zgodnosci wymiarow - nie moge przeniesc operacji pomiedzy
::                kontenerami o roznych wymiarach
                  _dim_chk:=exec('dimensions_chk','px_kont',_loc.Src.PX_KONT,_loc.Dst.PX_KONT);

::                kontrola zgodnosci zestawow planistycznych
                  _set_chk:=1;
                  {? exec('is_px_set','px_param')>0
                  ||
::                   Jesli zmienil sie kontener przeciaganego trybika to PX_SET etapu
::                   nie biore z rekordu tylko wyznaczam na nowo
                     {? _loc.Src.PX_KONT<>_loc.Dst.PX_KONT
                     || _set_stg:=exec('px_set_get','px_stage',_loc.Dst.PX_STAGE,_loc.Src.PX_KONT)
                     ||
                        _set_stg:=exec('FindAndGet','#table',PX_STAGE
                                                         ,#_loc.Dst.PX_STAGE
                                                         ,ref_name(_loc.Dst.PX_STAGE)
                                                         ,"PX_SET"
                                                         ,null())
                     ?};
                     _set_kont:=exec('FindAndGet','#table',PX_KONT
                                                         ,#_loc.Dst.PX_KONT
                                                         ,ref_name(_loc.Dst.PX_KONT)
                                                         ,"PX_SET"
                                                         ,null());
                     {? _set_stg<>null() & $_set_stg<>$_set_kont
                     ||
::                      Zestaw etapu i kontenera sie roznia - pytam czy na pewno przepiac
                        _msg0:='';
                        _msg1:='Zestawy planistyczne etapu i zasobu są różne.';
                        _msg2:='Czy na pewno wykonać powiązanie?';
                        _msg3:='Zestaw etapu: '+exec('FindAndGet','#table',PX_SET
                                                                          ,#_set_stg
                                                                          ,ref_name(_set_stg)
                                                                          ,"SYMBOL"
                                                                          ,'<brak>');
                        _msg4:='Zestaw zasobu: '+exec('FindAndGet','#table',PX_SET
                                                                          ,#_set_kont
                                                                          ,ref_name(_set_kont)
                                                                          ,"SYMBOL"
                                                                          ,'<brak>');
                        _msg_glued:=exec('form','#string','L',_msg1
                                                            ,_msg2
                                                            ,_msg0
                                                            ,_msg3
                                                            ,_msg4);
                        _set_chk:=FUN.ask(_msg_glued)
                     ?}
                  ?};

                  {? _dim_chk=1 & _set_chk>0
                  || exec('PX_OPER_move','px_oper',_loc.Src.PX_OPER
                                               ,_loc.Src.PX_STAGE
                                               ,_loc.Src.PX_KONT
                                               ,_loc.Dst.PX_STAGE
                                               ,_loc.Dst.PX_KONT)
                  |? _dim_chk=-1
                  || FUN.emsg('Niedozwolone jest przenoszenie operacji pomiędzy zasobami o różnej ilości wymiarów.'@)
                  |? _dim_chk=-2
                  || FUN.emsg('Niedozwolone jest przenoszenie operacji pomiędzy zasobami o różnych wymiarach.'@)
                  ?}
               ?};
               ~~
            ?}
         ?};
         _loc.dnd_info.source.records.next()
      !};
      _args.PxTex.refresh();
      ~~
   ?};
   Cntx.pop(PX_OPER, PX_KONT, _args.PxTex.GridTab, _args.PxTex.OperTab);
   ~~

|? _args.Way='Row'
|| 'Row'

|? _args.Way='Fun'
||
   {? _loc.dropsize=1
    & _loc.dnd_info.source.records.first()
   ||
      _pars:=exec('PxTexExeFunID_a','px_tex',0);
      _pars.PxTex:=_args.PxTex;
      _pars.FunID:=exec('FindAndGet','#table',_args.PxTex.FunTab
                                             ,_loc.dnd_info.source.records.REF
                                             ,_args.PxTex.FunTab.name()
                                             ,"FUNID"
                                             ,''
                                             ,''
                       );
      _pars.object:=_loc.Dst;

::    kontrola zgodnosci zestawow planistycznych
      _set_chk:=1;

      {? exec('is_px_set','px_param')>0
      || _set_stg:=exec('FindAndGet','#table',PX_STAGE
                                             ,#_loc.Dst.PX_STAGE
                                             ,ref_name(_loc.Dst.PX_STAGE)
                                             ,"PX_SET"
                                             ,null());
         _stg_opers:=exec('FindAndGet','#table',PX_STAGE
                                             ,#_loc.Dst.PX_STAGE
                                             ,ref_name(_loc.Dst.PX_STAGE)
                                             ," _result:=0;
                                                PX_OPER.cntx_psh();
                                                PX_OPER.index('UNIQALL');
                                                PX_OPER.prefix(PX_STAGE.ref());
                                                _result:=PX_OPER.size();
                                                PX_OPER.cntx_pop();
                                                _result"
                                             ,null());
         _set_kont:=exec('FindAndGet','#table',PX_KONT
                                             ,#_loc.Dst.PX_KONT
                                             ,ref_name(_loc.Dst.PX_KONT)
                                             ,"PX_SET"
                                             ,null());
         {? _stg_opers>0 & $_set_stg<>$_set_kont
         ||
::          Zestaw etapu i kontenera sie roznia - pytam czy na pewno przepiac
            _msg0:='';
            _msg1:='Zestawy planistyczne etapu i zasobu są różne.';
            _msg2:='Czy na pewno wykonać powiązanie?';
            _msg3:='Zestaw etapu: '+exec('FindAndGet','#table',PX_SET
                                                              ,#_set_stg
                                                              ,ref_name(_set_stg)
                                                              ,"SYMBOL"
                                                              ,'<brak>');
            _msg4:='Zestaw zasobu: '+exec('FindAndGet','#table',PX_SET
                                                              ,#_set_kont
                                                              ,ref_name(_set_kont)
                                                              ,"SYMBOL"
                                                              ,'<brak>');
            _msg_glued:=exec('form','#string','L',_msg1
                                                ,_msg2
                                                ,_msg0
                                                ,_msg3
                                                ,_msg4);
            _set_chk:=FUN.ask(_msg_glued)
         ?}
      ?};
      {? _set_chk>0
      || exec('PxTexExeFunID','px_tex',_pars)
      ?}
   ?}

|? _args.Way='Oper'
|| 'Oper'
?};
~~


\PxTex_dnd_Row
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Obsluga d'n'd dla RowTab w PxTex
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PxTex','Way');
_args.PxTex:=_a;
_args.Way:=_b;
{? _args.PxTex.DEVELOP=1 || FUN.info(exec('dnd_info','#dragdrop')) ?};

_loc:=obj_new('dnd_info');
_loc.dnd_info:=exec('get_dnd_info','#dragdrop');

{? _args.PxTex.ViewOnly
|| ~~
|? _args.Way='Grid'
|| 'Grid'
|? _args.Way='Row'
|| 'Row'
|? _args.Way='Fun'
|| 'Fun'
|? _args.Way='Oper'
|| 'Oper'
?};
~~


\PxTex_dnd_Fun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Obsluga d'n'd dla FunTab w PxTex
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PxTex','Way');
_args.PxTex:=_a;
_args.Way:=_b;
{? _args.PxTex.DEVELOP=1 || FUN.info(exec('dnd_info','#dragdrop')) ?};

_loc:=obj_new('dnd_info');
_loc.dnd_info:=exec('get_dnd_info','#dragdrop');

{? _args.PxTex.ViewOnly
|| ~~
|? _args.Way='Grid'
|| 'Grid'
|? _args.Way='Row'
|| 'Row'
|? _args.Way='Fun'
|| 'Fun'
|? _args.Way='Oper'
|| 'Oper'
?};
~~


\PxTex_dnd_Oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Obsluga d'n'd dla OperTab w PxTex
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PxTex','Way');
_args.PxTex:=_a;
_args.Way:=_b;
{? _args.PxTex.DEVELOP=1 || FUN.info(exec('dnd_info','#dragdrop')) ?};

_loc:=obj_new('dnd_info');
_loc.dnd_info:=exec('get_dnd_info','#dragdrop');

{? _args.PxTex.ViewOnly
|| ~~
|? _args.Way='Grid'
|| 'Grid'
|? _args.Way='Row'
|| 'Row'
|? _args.Way='Fun'
|| {? _loc.dnd_info.source.records.size()=1
   || {? _args.PxTex.OperTab.seek(_loc.dnd_info.dest.record)
      || 1
      ?}
   || FUN.wdrerror('Przenoszenie grupy funkcji nie jest obsługiwane.')
   ?}
|? _args.Way='Oper'
|| 'Oper'
?};
~~


\Select_A_KTL
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Udostepnia do edycji operacje WPP
::   WE: _a - 'EDIT'/'VIEW'/'VIEW!'
::   WY: 1 - OK, ujemna wartosc - kolejna wartosc bledu
::----------------------------------------------------------------------------------------------------------------------
{? VAR.A_KTL().KTM=null()
|| FUN.emsg('Karta prototypowa — brak dostępu do przepisu planistycznego.'@);
   return(0)
?};

_selargs:=exec('Select_PxTex_a','px_tex');
_selargs.TKTL:=VAR.A_KTL;
_selargs.EditView:=-_a;
_corobim:=1;
_locked:=0;

{? exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPPL')=0
|| _selargs.EditView:='view'
?};

_result:=0;

{? _selargs.EditView='edit'
|| {? VAR.A_KTL().STAN='T' & exec('get','#params',8050,2,OPERATOR.USER)='N'
   || FUN.info(
         'Technologia źródłowa jest całkowicie zatwierdzona.\n\n'
         'Edycja nie jest możliwa — zostanie uruchomiony podgląd.'@
      );
      _selargs.EditView:='view'
   || {? VAR.A_KTL().STAN='P'
      || _corobim:=FUN.choice(
            'Technologia źródłowa jest częściowo zatwierdzona.\n\n'
            'Uwaga: zmodyfikowany przepis może się różnić od źródłowego.'@,,'Edytuj'@,'Podgląd'@
         );
         {? _corobim=2
         || _selargs.EditView:='view'
         ?}
      |? VAR.A_KTL().STAN='T'
      || _corobim:=FUN.choice(
            'Technologia źródłowa jest całkowicie zatwierdzona.\n\n'
            'Uwaga: zmodyfikowany przepis może się różnić od źródłowego.'@,,'Edytuj'@,'Podgląd'@
         );
         {? _corobim=2
         || _selargs.EditView:='view'
         ?}
      ?}
   ?};
   {? VAR.A_KTL().TORW='Z' & VAR.A_KTL().PLRELWYR<>null()
   || _selargs.EditView:='view'
   ?}
?};
{? _corobim>0
||
   {? _selargs.EditView='edit'
   ||
::    Sprawdzam czy zawartosc przepisu jest uzywana w wersji glownej planu
      _used:=0;
      _mainver:=exec('get_mainversion','px_ver');
      PX_TEX.cntx_psh();
      PX_TEX.index('TKTLMSYM');
      PX_TEX.prefix($_selargs.TKTL);
      {? PX_TEX.first()
      || {!
         |? _used:=exec('used_in_queue','px_tex',PX_TEX.ref(),_mainver);
            PX_TEX.next() & _used=0
         !}
      ?};
      PX_TEX.cntx_pop();

      {? _used>0
      ||
::       Jezeli zawartosc przepisu uzywana w planie glownym to ostrzezenie
         _msg:='Przepis jest używany w głównej wersji planu\n\n'
               'Jego modyfikacja może wpłynąć na plan podczas następnego przeliczenia.';
         FUN.info(_msg)
      ?}
   ?};
   _result:=exec('Select_PxTex','px_tex',_selargs)
?};
_result


\Select_A_ZL
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Udostepnia do edycji operacje WPP - dla aktywnego zlecenia
::   WY: 1 - OK, ujemna wartosc - kolejna wartosc bledu
::----------------------------------------------------------------------------------------------------------------------
_selargs:=exec('Select_PxTex_a','px_tex');

_selargs.EditView:='view';

{? exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPPL')=0
|| _selargs.EditView:='view'
?};

:: Jesli nie ma psotka to go powoluje
exec('PXoTEX_chk','px_tex');

_selargs.ZL:=VAR.A_ZLEC;

_result:=0;
:: szukam PX_OBJ dla zlecenia
_px_obj:=exec('get_zl_object','px_obj',VAR.A_ZLEC);
_show:=1;
ZL.cntx_psh();
{? VAR.A_ZLEC().RODZAJ='Z' & VAR.A_ZLEC().RODZ_TEX='P'
||
:: Jeśli zlecenie złożone i przepis prosty to nic nie wyświetlam, bo to zlecenie nie ma takiego
:: przepisu
   _show:=0;
   FUN.info('Zlecenie złożone nie posiada przepisu, jego wyświetlenie jest niemożliwe.'@)
?};
ZL.cntx_pop();
{? _show>0 & _px_obj<>null()
||
   _px_tex:=exec('get_tex_zl','px_tex',VAR.A_ZLEC);

   PX_TEX.cntx_psh();
   PX_TEX.clear();
   {? PX_TEX.seek(_px_tex)
   ||
      {? PX_TEX.PX_RULES=PXoTEX.Rules.tex_tex
      ||
         {? PX_TEX.TKTL<>null()
         || _selargs.TKTL:=PX_TEX.TKTL
         |? PX_TEX.RTKTL<>''
         || _selargs.TKTL:=exec('FindAndGet','#table',TKTL,PX_TEX.RTKTL,,,null())
         ?};
::       Jesli zawarosc przepisu z TKTL to blokuje redakcje
         _selargs.EditView:='view'
      |? PX_TEX.PX_RULES=PXoTEX.Rules.tex_own
      || _selargs.PX_TEX:=PX_TEX.ref()
      ?}
   || _msg:='Brak przepisu planistycznego dla zlecenia: %1.\n'
            'Najpierw należy go utworzyć za pomocą czynności \'Generowanie przepisu planistycznego\''@[ZL.SYM];
      FUN.info(_msg);
      _show:=0
   ?};
   PX_TEX.cntx_pop();

   {? _show>0
   ||
      {? _selargs.EditView='edit'
      ||
::       Sprawdzam czy przepis jest uzywany w wersji glownej planu
         _mainver:=exec('get_mainversion','px_ver');
         _used:=exec('used_in_queue','px_tex',_selargs.PX_TEX,_mainver);
         {? _used>0
         ||
            _msg:='Przepis jest używany w głównej wersji planu\n\n';
            _msg+='Jego modyfikacja może wpłynąć na plan podczas następnego przeliczenia.';
            FUN.info(_msg)
         ?}
      ?};
      _result:=exec('Select_PxTex','px_tex',_selargs)
   ?}
?};
_result


\Select_PxTex_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tablica parametrów dla Select_PxTex
::   WE: [_defaults] - [1] - wszystkie
::                      0  - typy proste (nr typu ponizej 100)
::                     -1  - brak
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('EditView','TKTL','M','MGR','PX_TEX','ZL');

:: - - - - ponizej ustawienie wartosci domyslnych
_args.EditView:='view';
_args.TKTL:=null();
_args.M:=null();
_args.MGR:=null();
_args.PX_TEX:=null();
_args.ZL:=null();
:: - - - - koniec ustalania wartosci domyslnych
_args


\Select_PxTex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Udostepnia do edycji operacje WWPP
::   WE: _args
::   WY: 1 - OK, ujemna wartosc - kolejna wartosc bledu
::----------------------------------------------------------------------------------------------------------------------
{? _=1
|| _args:=_a
|| _args:=exec('Select_PxTex_a','px_tex')
?};

:: kontrola poprawności argumentow
{? _args.TKTL<>null()
 & _args.M=null()
|| _args.M:=exec('FindAndGet','#table',TKTL,#_args.TKTL,,"KTM")
?};
{? _args.TKTL<>null()
|| VAR.A_KTL:=_args.TKTL
?};

VAR_DEL.delete('PxTex');
PxTex:=exec('PxTex_Create','px_tex',exec('get','#params',8055,1,OPERATOR.USER));
{? var_pres('PxTex')<100 || return(-1) ?};

TKTL.cntx_psh(); TKTL.clear();
TPKTL.cntx_psh();

PxTex.ViewOnly:={? _args.EditView='edit' || 0 |? _args.EditView='view!' || 2 || 1 ?};
{? _args.EditView='edit'
|| set_help(exec('set_help','#help','TPP_PPS_DPPL'))
|| set_help(exec('set_help','#help','TPP_PPS_PPPL'))
?};

{? _args.PX_TEX<>null()
|| PxTex.PX_TEX:=_args.PX_TEX;
   {? PxTex.ViewOnly=0
   ||
      {? exec('blk_lock','#table','PX_TEX',8+ref_name(_args.PX_TEX),#_args.PX_TEX)
      ||
         _unlock:="exec('blk_unlock','#table','PX_TEX',8+ref_name(_a.PX_TEX),#_a.PX_TEX)"
      ||
         _ses_id:=exec('blk_lock','#table','ZK_P',8+ref_name(_args.PX_TEX),#_args.PX_TEX,2);
         FUN.info('Przepis jest dostępny w trybie podglądu, ponieważ jest redagowany przez użytkownika \''+SYSLOG.ses_info(_ses_id,'log_name')+'\' '+
                  'na terminalu \''+SYSLOG.ses_info(_ses_id,'log_tty')+'\'.'
         );
         PxTex.ViewOnly:=1;
         _unlock:=""
      ?}
   || _unlock:=""
   ?}

|? _args.TKTL<>null()
|| PxTex.TKTL:=_args.TKTL;
   {? PxTex.ViewOnly=0
   ||
      {? exec('blk_lock','#table','TKTL',8+ref_name(_args.TKTL),#_args.TKTL)
      ||
         _unlock:="exec('blk_unlock','#table','TKTL',8+ref_name(_a.TKTL),#_a.TKTL)"
      ||
         _ses_id:=exec('blk_lock','#table','TKTL',8+ref_name(_args.TKTL),#_args.TKTL,2);
         FUN.info('Przepis jest dostępny w trybie podglądu, ponieważ jest redagowany przez użytkownika \''+SYSLOG.ses_info(_ses_id,'log_name')+'\' '+
                  'na terminalu \''+SYSLOG.ses_info(_ses_id,'log_tty')+'\'.'
         );
         PxTex.ViewOnly:=1;
         _unlock:=""
      ?}
   || _unlock:=""
   ?};

   exec('start_tpar','tech_param',_args.M,_args.TKTL);

:: Ustawiam sie w kontekscie TKTL bo formuly przed wyswietleniem, przed rekord itp moga wymagac takiego
:: kontekstu
   {? TKTL.seek(_args.TKTL)=0
   || FUN.wdrerror('Nie znaleziono karty tech. powiązanej z przepisem: '+&_args.TKTL)
   ?}
?};
{? _args.ZL<>null()
|| PxTex.ZL:=_args.ZL
?};

PxTex.load();
PxTex.select(PxTex);
_result:=PxTex.Result;
VAR_DEL.delete('PxTex');

{? var_pres('_unlock')>0
|| _unlock(_args)
?};

TKTL.cntx_pop();
TPKTL.cntx_pop();
_result


\px_tex_m_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.10]
:: DOST: MBUILDER
:: OPIS: Blank pola tabeli PX_TEX.M
::----------------------------------------------------------------------------------------------------------------------

::ustawiam blank wg zmiennej PX_VAR.TEX_M - uzywane do prefiksowania slownika technologii podczas wskazywania technologi

PX_TEX.M:=PX_VAR.TEX_M;
~~


\PxPack_declare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy strukture do podawania papki do algorytmu planujacego
::   WE:
::   WY: PxPacket
::----------------------------------------------------------------------------------------------------------------------
_pxpack:=obj_new( 'ErrCode'
                  ,'Paczka'
                  ,'Ndx_tree'
                  ,'Ndx_fwd'
                  ,'Ndx_bck'
                  ,'Ndx_uid'
                  ,'Ndx_src'
                  ,'Ndx_nast_fwd'
                  ,'Ndx_nast_bck'
                  ,'add'
                  ,'add_a'
                  ,'blank'
                  ,'tabpar'
                  ,'PxMat'
                  ,'HASPOINT'
                  ,'PX_TEX'
                  ,'PX_GRP');
:: ErrCode: 0 - brak bledow
::         -1 - nie zaladowane
::         -2 - ???
_pxpack.ErrCode:=-1;
_pxpack.HASPOINT:=0;
_pxpack.PX_TEX:=null();
_pxpack.PX_GRP:=null();
_pxpack.Paczka:=tab_tmp(3
                       ,'PARENT',   'TREE_REF',    'Z'
                       ,'BRANCH',   'STRING[1]',   'Czy jest gałęzią'
                       ,'SYMBOL',   'STRING[50]',  'Symbol'
                       ,'NAZWA',    'STRING[100]', 'Nazwa'
                       ,'TYP',      'STRING[1]',   'Typ elementu'
                       ,'LEVEL',    'INTEGER',     'Poziom elementu w drzewie'
                       ,'ILOSC',    'REAL',        'Ilość rzeczywista'
                       ,'COOP',     'INTEGER',     'Kooperacja?'
                       ,'COOP_AKC', 'INTEGER',     'Dane do planu kooperacji zatwierdzone?'
                       ,'WEW',      'STRING[1]',   'Operacja wewnetrzna?'
                       ,'STARTD',   'DATE',        'Zadany start operacji (data)'
                       ,'STARTT',   'TIME',        'Zadany start operacji (godzina)'
                       ,'TM_START', 'REAL',        'Zadany start operacji (tm_stamp)'
                       ,'ENDD',     'DATE',        'Zadany koniec operacji (data)'
                       ,'ENDT',     'TIME',        'Zadany koniec operacji (godzina)'
                       ,'TM_END',   'REAL',        'Zadany koniec operacji (tm_stamp)'
                       ,'OFFSET_P', 'REAL',        'Przesunięcie od początku planu w minutach'
                       ,'OFFSET_O', 'REAL',        'Przesunięcie względem poprz. op. w minutach'
                       ,'TM_MIN'  , 'REAL',        'PUNKTY CZASOWE - minimalny czas rozpoczecia'
                       ,'TM_MAX'  , 'REAL',        'PUNKTY CZASOWE - maksymalny czas zakonczenia'
::                     Miekkie refy
                       ,'PX_STAGE', 'STRING[16]',  'SQL ref etapu przepisu'
                       ,'PX_STAGM', 'STRING[8]',   'Maska etapu przepisu'
                       ,'PX_STAGR', 'INTEGER',     'Rekord etapu przepisu'

                       ,'REF_KONT', 'STRING[16]',  'SQL ref kontenera technologicznego'
                       ,'REF_KONM', 'STRING[8]',   'Maska kontenera rzeczywistego'
                       ,'REF_KONR', 'INTEGER',     'Rekord kontenera rzeczywistego'

                       ,'KONTREAL', 'STRING[16]',  'SQL ref kontenera rzeczywistego na ktorego zaplanowano'
                       ,'KONTREAM', 'STRING[8]',   'Maska kontenera rzeczywistego'
                       ,'KONTREAR', 'INTEGER',     'Rekord kontenera rzeczywistego'

                       ,'MATERIAL', 'STRING[16]',  'SQL ref materialu'
                       ,'NORMA',    'REAL',        'Norma materialu'
                       ,'GROPS',    'STRING[16]',  'SQL ref zasobu grupy operacji'
                       ,'GROPED',   'STRING[1]',   'Czy operacja zlecenia jest zaplanowana w grupie operacji'

                       ,'NUM',      'INTEGER',     'Kolejność w procesie lub kolejność planowania'
                       ,'NUM_PREV', 'INTEGER',     'Nr etapu poprzedniego (powiazania etapow)'
                       ,'NUM_NEXT', 'INTEGER',     'Nr etapu nastepnego (powiazania etapow)'
                       ,'NUM_STAG', 'INTEGER',     'Nr etapu w przepisie'

                       ,'HAS_PREV' , 'STRING[1]',   'Czy etap ma poprzedniki'
                       ,'HAS_NEXT' , 'STRING[1]',   'Czy etap ma następniki'

                       ,'DIR',      'INTEGER',     '+1 – planowanie wprzód, -1 planowanie w tył'
                       ,'ALIGNMEN', 'STRING[1]',   'L,R, :planowanie elementow wspolny start, stop, dowolnie'
                       ,'NAKL_PRC', 'REAL',        'Procent nakladkowania [z etapu]'
                       ,'NAKLDIFF', 'REAL',        'Roznica czasu wynikajaca z nakladkowania'
                       ,'NKO'     , 'REAL',        'Czas nakladkowania [z etapu]'
                       ,'TTM'     , 'REAL',        'Czas odczekania [z etapu]'
                       ,'STATUS'  , 'STRING[20]',  'Status rekordu paczki np. opozniony'
                       ,'PX_OBJ'  , 'STRING[16]',  'SQL ref obiektu planowanego'
                       ,'CAP_DIM1', 'REAL',        'Pojemność zużywana przez operację w wymiarze 1'
                       ,'CAP_DIM2', 'REAL',        'Pojemność zużywana przez operację w wymiarze 2'
                       ,'CAP_DIM3', 'REAL',        'Pojemność zużywana przez operację w wymiarze 3'
                       ,'CAP_DIM4', 'REAL',        'Pojemność zużywana przez operację w wymiarze 4'
                       ,'CAP_DIM5', 'REAL',        'Pojemność zużywana przez operację w wymiarze 5'
                       ,'DID_DIM1', 'REAL',        'DLA ALG. PLANUJACEGO - Pojemność zaplanowana w wymiarze 1'
                       ,'DID_DIM2', 'REAL',        'DLA ALG. PLANUJACEGO - Pojemność zaplanowana w wymiarze 2'
                       ,'DID_DIM3', 'REAL',        'DLA ALG. PLANUJACEGO - Pojemność zaplanowana w wymiarze 3'
                       ,'DID_DIM4', 'REAL',        'DLA ALG. PLANUJACEGO - Pojemność zaplanowana w wymiarze 4'
                       ,'DID_DIM5', 'REAL',        'DLA ALG. PLANUJACEGO - Pojemność zaplanowana w wymiarze 5'

                       ,'LSTCOEF1','REAL',         'DLA ALG. PLANUJACEGO - proporcja ostatniej pozycji 1'
                       ,'LSTCOEF2','REAL',         'DLA ALG. PLANUJACEGO - proporcja ostatniej pozycji 2'
                       ,'LSTCOEF3','REAL',         'DLA ALG. PLANUJACEGO - proporcja ostatniej pozycji 3'
                       ,'LSTCOEF4','REAL',         'DLA ALG. PLANUJACEGO - proporcja ostatniej pozycji 4'
                       ,'LSTCOEF5','REAL',         'DLA ALG. PLANUJACEGO - proporcja ostatniej pozycji 5'
                       ,'LSTSTART','REAL',         'DLA ALG. PLANUJACEGO - start ost. pojemnika dla operacji'
                       ,'LSTEND'  ,'REAL',         'DLA ALG. PLANUJACEGO - koniec ost. pojemnika dla operacji'
                       ,'LANE'    ,'REAL',         'Poziom kalendarza'
                       ,'CAP_MAX1', 'REAL',        'Pojemność maksymalna w wymiarze 1'
                       ,'CAP_MAX2', 'REAL',        'Pojemność maksymalna w wymiarze 2'
                       ,'CAP_MAX3', 'REAL',        'Pojemność maksymalna w wymiarze 3'
                       ,'CAP_MAX4', 'REAL',        'Pojemność maksymalna w wymiarze 4'
                       ,'CAP_MAX5', 'REAL',        'Pojemność maksymalna w wymiarze 5'
                       ,'CAP_MIN1', 'REAL',        'Pojemność minimalna w wymiarze 1'
                       ,'CAP_MIN2', 'REAL',        'Pojemność minimalna w wymiarze 2'
                       ,'CAP_MIN3', 'REAL',        'Pojemność minimalna w wymiarze 3'
                       ,'CAP_MIN4', 'REAL',        'Pojemność minimalna w wymiarze 4'
                       ,'CAP_MIN5', 'REAL',        'Pojemność minimalna w wymiarze 5'
                       ,'CAP_TP1',  'REAL',        'Zużywana pojemność przygotowawcza dla operacji w wymiarze 1'
                       ,'CAP_TP2',  'REAL',        'Zużywana pojemność przygotowawcza dla operacji w wymiarze 2'
                       ,'CAP_TP3',  'REAL',        'Zużywana pojemność przygotowawcza dla operacji w wymiarze 3'
                       ,'CAP_TP4',  'REAL',        'Zużywana pojemność przygotowawcza dla operacji w wymiarze 4'
                       ,'CAP_TP5',  'REAL',        'Zużywana pojemność przygotowawcza dla operacji w wymiarze 5'
                       ,'CAP_TZ1',  'REAL',        'Zużywana pojemność zakończeniowa dla operacji w wymiarze 1'
                       ,'CAP_TZ2',  'REAL',        'Zużywana pojemność zakończeniowa dla operacji w wymiarze 2'
                       ,'CAP_TZ3',  'REAL',        'Zużywana pojemność zakończeniowa dla operacji w wymiarze 3'
                       ,'CAP_TZ4',  'REAL',        'Zużywana pojemność zakończeniowa dla operacji w wymiarze 4'
                       ,'CAP_TZ5',  'REAL',        'Zużywana pojemność zakończeniowa dla operacji w wymiarze 5'
                       ,'JM_DIM1',  'STRING[16]',  'Ref SQL jednostki miary w wymiarze 1'
                       ,'JM_DIM2',  'STRING[16]',  'Ref SQL jednostki miary w wymiarze 2'
                       ,'JM_DIM3',  'STRING[16]',  'Ref SQL jednostki miary w wymiarze 3'
                       ,'JM_DIM4',  'STRING[16]',  'Ref SQL jednostki miary w wymiarze 4'
                       ,'JM_DIM5',  'STRING[16]',  'Ref SQL jednostki miary w wymiarze 5'
                       ,'PLANNED',  'STRING[1]' ,   'Znacznik czy rekord paczki zostal juz zaplanowany T/N'
                       ,'PL_START',  'REAL'     ,   'Dla zaplanowanego rekordu - poczatek planu'
                       ,'PL_END'  ,  'REAL'     ,   'Dla zaplanowanego rekordu - koniec planu'
                       ,'PL_FORCE', 'STRING[1]' ,   'Znacznik czy możliwe jest planowanie poza termin realizacji'
                       ,'EMPTY'   , 'STRING[1]' ,   'Czy rekord zostal skorygowany do zera i nie byl planowany'
                       ,'UID'     , 'REAL'      ,  'Identyfikator etapu'
                       ,'UID_SRC' , 'REAL'      ,  'Identyfikator etapu - zródł.( P - poprzednik, N- nastepnik)'
                       ,'REASON'  , 'STRING[10]',  'Powód umieszczenia pozycji planu w czasie'
::                     --- ponizej pola na razie nie uzywane
                       ,'ID',       'INTEGER',     'Identyfikator elementu'
                       ,'PAR_ID',   'INTEGER',     'Identyfikator elementu nadrzędnego'
                       ,'REF_TEX',  'STRING[16]',  'SQL ref przepisu'
                       );

_pxpack.Ndx_tree:=_pxpack.Paczka.index('?');
_pxpack.Ndx_fwd:=_pxpack.Paczka.ndx_tmp(,,'TYP',,,'NUM',,0);
_pxpack.Ndx_bck:=_pxpack.Paczka.ndx_tmp(,,'TYP',,,'NUM',,1);

_pxpack.Ndx_nast_fwd:=_pxpack.Paczka.ndx_tmp(,,'TYP',,,'NUM',,,'NUM_STAG',,0);
_pxpack.Ndx_nast_bck:=_pxpack.Paczka.ndx_tmp(,,'TYP',,,'NUM',,,'NUM_STAG',,1);

_pxpack.Ndx_uid:=_pxpack.Paczka.ndx_tmp(,,'UID',,);
_pxpack.Ndx_src:=_pxpack.Paczka.ndx_tmp(,,'UID_SRC',,,'NUM',,);

_pxpack.Paczka.fld_fml('ILOSC','DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
_pxpack.Paczka.fld_fml('NORMA','DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
{! _dim:=1.. exec('il_wym','px_param')
|! _pxpack.Paczka.fld_fml('CAP_DIM'+$_dim,'DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
   _pxpack.Paczka.fld_fml('CAP_MIN'+$_dim,'DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}");
   _pxpack.Paczka.fld_fml('CAP_MAX'+$_dim,'DISPLAY_FORMAT',"{? fld()=0 || 'empty=1' || 'empty=0' ?}")
!};

_pxpack.add:="
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Dodaje do paczki jeden rekord
::   WE: _b - _args - argumenty funkcji (tablica nazwana) - wynik funkcji PxPack.add_a()
::   WY: _paczka.ref() lub null() - ref dodanego rekordu lub null() jesli dodanie sie nie powiodlo
::----------------------------------------------------------------------------------------------------------------------
   _paczka:=.Paczka;
   _args:={?_>0 || _a || .add_a() ?};

   _result:=null();
   _paczka.blank();
   _paczka.PARENT:=_args.PARENT;
   _paczka.BRANCH:=_args.BRANCH;
   _paczka.SYMBOL:=_args.SYMBOL;
   _paczka.NAZWA:=_args.NAZWA;
   _paczka.TYP:=_args.TYP;
   _paczka.ID:=_args.ID;
   _paczka.PAR_ID:=_args.PAR_ID;
   _paczka.LEVEL:=_args.LEVEL;
   _paczka.ILOSC:=_args.ILOSC;
   _paczka.COOP:=_args.COOP;
   _paczka.COOP_AKC:=_args.COOP_AKC;
   _paczka.WEW:=_args.WEW;
   _paczka.STARTD:=_args.STARTD;
   _paczka.STARTT:=_args.STARTT;
   _paczka.TM_START:=_args.TM_START;
   _paczka.ENDD:=_args.ENDD;
   _paczka.ENDT:=_args.ENDT;
   _paczka.TM_END:=_args.TM_END;
   _paczka.OFFSET_P:=_args.OFFSET_P;
   _paczka.OFFSET_O:=_args.OFFSET_O;
   _paczka.TM_MIN:=_args.TM_MIN;
   _paczka.TM_MAX:=_args.TM_MAX;

   _paczka.PX_STAGE:=_args.PX_STAGE;
   _paczka.PX_STAGM:=_args.PX_STAGM;
   _paczka.PX_STAGR:=_args.PX_STAGR;

   _paczka.HAS_PREV:=_args.HAS_PREV;
   _paczka.HAS_NEXT:=_args.HAS_NEXT;

   _paczka.REF_KONT:=_args.REF_KONT;
   _paczka.REF_KONM:=_args.REF_KONM;
   _paczka.REF_KONR:=_args.REF_KONR;

   _paczka.MATERIAL:=_args.MATERIAL;
   _paczka.NORMA:=_args.NORMA;
   _paczka.GROPS:=_args.GROPS;
   _paczka.GROPED:=_args.GROPED;

   _paczka.KONTREAL:=_args.KONTREAL;
   _paczka.KONTREAM:=_args.KONTREAM;
   _paczka.KONTREAR:=_args.KONTREAR;

   _paczka.REF_TEX:=_args.REF_TEX;
   _paczka.NUM:=_args.NUM;
   _paczka.NUM_PREV:=_args.NUM_PREV;
   _paczka.NUM_NEXT:=_args.NUM_NEXT;
   _paczka.NUM_STAG:=_args.NUM_STAG;
   _paczka.DIR:=_args.DIR;
   _paczka.ALIGNMEN:=_args.ALIGNMEN;
   _paczka.NAKL_PRC:=_args.NAKL_PRC;
   _paczka.NAKLDIFF:=_args.NAKLDIFF;
   _paczka.NKO:=_args.NKO;
   _paczka.TTM:=_args.TTM;
   _paczka.STATUS:=_args.STATUS;
   _paczka.PX_OBJ:=_args.PX_OBJ;

   _paczka.CAP_DIM1:=_args.CAP_DIM1;
   _paczka.CAP_DIM2:=_args.CAP_DIM2;
   _paczka.CAP_DIM3:=_args.CAP_DIM3;
   _paczka.CAP_DIM4:=_args.CAP_DIM4;
   _paczka.CAP_DIM5:=_args.CAP_DIM5;
   _paczka.CAP_MAX1:=_args.CAP_MAX1;
   _paczka.CAP_MAX2:=_args.CAP_MAX2;
   _paczka.CAP_MAX3:=_args.CAP_MAX3;
   _paczka.CAP_MAX4:=_args.CAP_MAX4;
   _paczka.CAP_MAX5:=_args.CAP_MAX5;
   _paczka.CAP_MIN1:=_args.CAP_MIN1;
   _paczka.CAP_MIN2:=_args.CAP_MIN2;
   _paczka.CAP_MIN3:=_args.CAP_MIN3;
   _paczka.CAP_MIN4:=_args.CAP_MIN4;
   _paczka.CAP_MIN5:=_args.CAP_MIN5;
   _paczka.CAP_TP1:=_args.CAP_TP1;
   _paczka.CAP_TP2:=_args.CAP_TP2;
   _paczka.CAP_TP3:=_args.CAP_TP3;
   _paczka.CAP_TP4:=_args.CAP_TP4;
   _paczka.CAP_TP5:=_args.CAP_TP5;
   _paczka.CAP_TZ1:=_args.CAP_TZ1;
   _paczka.CAP_TZ2:=_args.CAP_TZ2;
   _paczka.CAP_TZ3:=_args.CAP_TZ3;
   _paczka.CAP_TZ4:=_args.CAP_TZ4;
   _paczka.CAP_TZ5:=_args.CAP_TZ5;
   _paczka.JM_DIM1:=_args.JM_DIM1;
   _paczka.JM_DIM2:=_args.JM_DIM2;
   _paczka.JM_DIM3:=_args.JM_DIM3;
   _paczka.JM_DIM4:=_args.JM_DIM4;
   _paczka.JM_DIM5:=_args.JM_DIM5;
   _paczka.PL_START:=0;
   _paczka.PL_END:=0;
   _paczka.UID:=_paczka.tm_stamp();
   _paczka.UID_SRC:=_args.UID;
   _paczka.PL_FORCE:=_args.PL_FORCE;
   _paczka.EMPTY:=_args.EMPTY;
   _paczka.LANE:=_args.LANE;
   _paczka.LSTCOEF1:=-1;
   _paczka.LSTCOEF2:=-1;
   _paczka.LSTCOEF3:=-1;
   _paczka.LSTCOEF4:=-1;
   _paczka.LSTCOEF5:=-1;
   _paczka.PLANNED:=_args.PLANNED;
   _paczka.REASON:=_args.REASON;

   {? _paczka.add()>0
   || _result:=_paczka.ref()
   ?};
   _result
";

_pxpack.add_a:="
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Tablica argumentow funkcji PxPack.add()
::   WY: tablica nazwana do uzycia w PxPack.add()
::----------------------------------------------------------------------------------------------------------------------
   _args:=obj_new('PARENT'
                 ,'BRANCH'
                 ,'SYMBOL'
                 ,'NAZWA'
                 ,'TYP'
                 ,'ID'
                 ,'PAR_ID'
                 ,'LEVEL'
                 ,'ILOSC'
                 ,'COOP'
                 ,'COOP_AKC'
                 ,'WEW'
                 ,'STARTD'
                 ,'STARTT'
                 ,'TM_START'
                 ,'ENDD'
                 ,'ENDT'
                 ,'TM_END'
::               OFFSET_P - przesuniecie od poczatku planu w minutach - glowny klucz planowania przy sortowaniu
                 ,'OFFSET_P'
::               OFFSET_O - przesuniecie wzgledem poprzedniej operacji w minutach
                 ,'OFFSET_O'
                 ,'TM_MIN'
                 ,'TM_MAX'

                 ,'PX_STAGE'
                 ,'PX_STAGM'
                 ,'PX_STAGR'

                 ,'HAS_PREV'
                 ,'HAS_NEXT'

                 ,'REF_KONT'
                 ,'REF_KONM'
                 ,'REF_KONR'

                 ,'KONTREAL'
                 ,'KONTREAM'
                 ,'KONTREAR'

                 ,'MATERIAL'
                 ,'NORMA'
                 ,'GROPS'
                 ,'GROPED'

::               NUM - numer operacji (bloku)
                 ,'NUM'
::               NUM_PREV - numer operacji (etapu) poprzedniego
                 ,'NUM_PREV'
::               NUM_NEXT - numer operacji (etapu) poprzedniego
                 ,'NUM_NEXT'
                 ,'NUM_STAG'
                 ,'DIR'
                 ,'ALIGNMEN'
                 ,'NAKL_PRC'
                 ,'NAKLDIFF'
                 ,'NKO'
                 ,'TTM'
                 ,'STATUS'
                 ,'PX_OBJ'
::               50
                 ,'CAP_DIM1'
                 ,'CAP_DIM2'
                 ,'CAP_DIM3'
                 ,'CAP_DIM4'
                 ,'CAP_DIM5'
::               55
                 ,'CAP_MAX1'
                 ,'CAP_MAX2'
                 ,'CAP_MAX3'
                 ,'CAP_MAX4'
                 ,'CAP_MAX5'
::               60
                 ,'CAP_MIN1'
                 ,'CAP_MIN2'
                 ,'CAP_MIN3'
                 ,'CAP_MIN4'
                 ,'CAP_MIN5'
::               65
                 ,'CAP_TP1'
                 ,'CAP_TP2'
                 ,'CAP_TP3'
                 ,'CAP_TP4'
                 ,'CAP_TP5'
::               70
                 ,'CAP_TZ1'
                 ,'CAP_TZ2'
                 ,'CAP_TZ3'
                 ,'CAP_TZ4'
                 ,'CAP_TZ5'
::               75
                 ,'JM_DIM1'
                 ,'JM_DIM2'
                 ,'JM_DIM3'
                 ,'JM_DIM4'
                 ,'JM_DIM5'
                 ,'PL_FORCE'
                 ,'EMPTY'
                 ,'UID'
                 ,'UID_SRC'
                 ,'LANE'
                 ,'PLANNED'
                 ,'REASON'
::               nie uzywane
                 ,'REF_TEX'
                 );
   .blank(_args);
   _args
";

_pxpack.blank:="
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: 'Zeruje' tablice argumentow funkcji PxPack.add()
::   WE: _a - _args - argumenty funkcji (tablica nazwana) - wynik funkcji PxPack.add_a()
::----------------------------------------------------------------------------------------------------------------------
   _args:=_a;
   _args.PARENT:=null();
   _args.BRANCH:='N';
   _args.SYMBOL:='Symbol domyślny';
   _args.NAZWA:='Nazwa domyślna';
   _args.TYP:='X';
   _args.ID:=0;
   _args.PAR_ID:=0;
   _args.LEVEL:=0;
   _args.ILOSC:=0;
   _args.COOP:=0;
   _args.COOP_AKC:=0;
   _args.WEW:='T';
   _args.STARTD:=date(0,0,0);
   _args.STARTT:=time(0,0,0);
   _args.TM_START:=0;
   _args.ENDD:=date(0,0,0);
   _args.ENDT:=time(0,0,0);
   _args.TM_END:=0;
   _args.OFFSET_P:=0;
   _args.OFFSET_O:=0;
   _args.TM_MIN:=0;
   _args.TM_MAX:=0;

   _args.HAS_PREV:='N';
   _args.HAS_NEXT:='N';

   _args.PX_STAGE:='';
   _args.PX_STAGM:='';
   _args.PX_STAGR:=0;

   _args.REF_KONT:='';
   _args.REF_KONM:='';
   _args.REF_KONR:=0;

   _args.KONTREAL:='';
   _args.KONTREAM:='';
   _args.KONTREAR:=0;

   _args.MATERIAL:='';
   _args.NORMA:=0;
   _args.GROPS:='';
   _args.GROPED:='N';

   _args.REF_TEX:='';
   _args.NUM:=0;
   _args.NUM_PREV:=0;
   _args.NUM_NEXT:=0;
   _args.NUM_STAG:=0;
   _args.DIR:=-1;
   _args.ALIGNMEN:='';
   _args.NAKL_PRC:=100;
   _args.NAKLDIFF:=0;
   _args.NKO:=0;
   _args.TTM:=0;
   _args.STATUS:=exec('status_pck_norm','px_tex');
   _args.PX_OBJ:='';

   _args.CAP_DIM1:=0;
   _args.CAP_DIM2:=0;
   _args.CAP_DIM3:=0;
   _args.CAP_DIM4:=0;
   _args.CAP_DIM5:=0;
   _args.CAP_MAX1:=0;
   _args.CAP_MAX2:=0;
   _args.CAP_MAX3:=0;
   _args.CAP_MAX4:=0;
   _args.CAP_MAX5:=0;
   _args.CAP_MIN1:=0;
   _args.CAP_MIN2:=0;
   _args.CAP_MIN3:=0;
   _args.CAP_MIN4:=0;
   _args.CAP_MIN5:=0;
   _args.CAP_TP1:=0;
   _args.CAP_TP2:=0;
   _args.CAP_TP3:=0;
   _args.CAP_TP4:=0;
   _args.CAP_TP5:=0;
   _args.CAP_TZ1:=0;
   _args.CAP_TZ2:=0;
   _args.CAP_TZ3:=0;
   _args.CAP_TZ4:=0;
   _args.CAP_TZ5:=0;
   _args.JM_DIM1:='';
   _args.JM_DIM2:='';
   _args.JM_DIM3:='';
   _args.JM_DIM4:='';
   _args.JM_DIM5:='';
   _args.PL_FORCE:='N';
   _args.EMPTY:='N';
   _args.UID:=0;
   _args.UID_SRC:=0;
   _args.LANE:=-1;
   _args.PLANNED:='N';
   _args.REASON:=exec('reason_plan','px_param');
   ~~
";

_pxpack.tabpar:=obj_new('CAP_DIM','CAP_MAX','CAP_MIN','CAP_TP','CAP_TZ','JM_DIM');
_pxpack.tabpar.CAP_DIM:=50;
_pxpack.tabpar.CAP_MAX:=55;
_pxpack.tabpar.CAP_MIN:=60;
_pxpack.tabpar.CAP_TP:=65;
_pxpack.tabpar.CAP_TZ:=70;
_pxpack.tabpar.JM_DIM:=75;

_pxpack


\paczka_select
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Przykładowy widok planu 'w drzewie'
::   WE: _a - obiekt PxPack - paczka do wyświetlenia
::----------------------------------------------------------------------------------------------------------------------
PX_KONT.cntx_psh();

VAR_DEL.delete('PxPack');
{? var_pres('_a')>=type_of(100)
|| _PxPack:=_a
|| _PxPack:=exec('PxPack_declare','px_tex')
?};

_paczka:=_PxPack.Paczka;
_paczka.cntx_psh();
_paczka.index(_PxPack.Ndx_tree);

:: Okno wertowania
_wer_paczka:=_paczka.mk_sel('Przepis źródłowy'@,'P',,'#paczka_tree',1,,,1,,,,,1);
_paczka.win_sel(_wer_paczka);
_paczka.win_fld(_wer_paczka,,'SYMBOL',,,20);
_paczka.win_fld(_wer_paczka,,'NAZWA',,,20);
_paczka.win_fld(_wer_paczka,,'ILOSC',,,10,ST.DOKL,,'Ilość'@);
_paczka.win_fld(_wer_paczka,,'NORMA',,,10,ST.DOKL,,'Norma'@);
_paczka.win_fld(_wer_paczka,PX_VAR,'JM','KOD',,5,,,'jm'@);
_paczka.win_fld(_wer_paczka,,'CAP_DIM1',,,10,ST.DOKL,,'Wymiar %1'@['1']);
_paczka.win_fld(_wer_paczka,PX_VAR,'JM1','KOD',,5,,,'jm'@);
_paczka.win_fld(_wer_paczka,,'CAP_DIM2',,,10,ST.DOKL,,'Wymiar %1'@['2']);
_paczka.win_fld(_wer_paczka,PX_VAR,'JM2','KOD',,5,,,'jm'@);
_paczka.win_fld(_wer_paczka,,'CAP_DIM3',,,10,ST.DOKL,,'Wymiar %1'@['3']);
_paczka.win_fld(_wer_paczka,PX_VAR,'JM3','KOD',,5,,,'jm'@);
_paczka.win_fld(_wer_paczka,,'CAP_DIM4',,,10,ST.DOKL,,'Wymiar %1'@['4']);
_paczka.win_fld(_wer_paczka,PX_VAR,'JM4','KOD',,5,,,'jm'@);
_paczka.win_fld(_wer_paczka,,'CAP_DIM5',,,10,ST.DOKL,,'Wymiar %1'@['5']);
_paczka.win_fld(_wer_paczka,PX_VAR,'JM5','KOD',,5,,,'jm'@);

:: Akcje
_formula:=$("exec('zwrw_all','#tree',cur_tab(1,1),'PARENT','"+_wer_paczka+"')");
_paczka.win_act(_wer_paczka,,'Formuła','Z&wiń/rozwiń'@@,,,_formula,,,,,,'W');

_formula:="
   exec('FindAndGet','#table',M,cur_tab(1,1).MATERIAL,,\"exec('info_zam','magazyn_stan',5,ref())\",null());
   ~~
";
_paczka.win_act(_wer_paczka,,'Formuła','Szcz&egóły'@@,,'Szczegóły indeksu'@,_formula,,,,,,'E');

_paczka.win_act(_wer_paczka,,'Formuła','Analiza'@@,,'Analiza dostępności materiałów w czasie'@,
   "params_exec('px_analiza_b','px_tex')","params_exec('px_analiza_a','px_tex')",,1,
   "params_exec('px_analiza_bg','px_tex')","params_exec('px_analiza_ag','px_tex')",'A'
);

_formula:="
   _paczka:=cur_tab(1,1);
   PX_VAR.IL_WYM:=0;
   {! _dim:=1..exec('il_wym','px_param') |! ($('PX_VAR.JM'+$_dim+':=null()'))() !};
   {? _paczka.BRANCH='N' &  _paczka.REF_KONR<>0
   ||
      PX_KONT.clear();
      {? PX_KONT.seek(_paczka.REF_KONR,_paczka.REF_KONM)
      ||
         PX_VAR.IL_WYM:=PX_KONT.IL_WYM;
         {! _dim:=1..exec('il_wym','px_param') |! ($('PX_VAR.JM'+$_dim+':=PX_KONT.JM'+$_dim))() !}
      ?}
   ?};
   PX_VAR.JM:=exec('FindAndGet','#table',M,_paczka.MATERIAL,,\"J\",null());
   _grayed:=':';
   {? _paczka.TYP<>'M' || _grayed:='E'+_grayed ?};
   {? _paczka.TYP<>'M' & _paczka.sel_size()=0 || _grayed:='A'+_grayed ?};
   _paczka.actions_grayed(cur_win(1,1),_grayed);
   ~~
";
_paczka.win_act(_wer_paczka,,'Rekord',,,,_formula);

:: Przyciski
_btnSzcz:=_paczka.win_btn(_wer_paczka,'text=%1'['Szcz&egóły'@],'menu:E');
_paczka.btn_sopt(_wer_paczka,_btnSzcz,'tooltip='+'Szczegóły indeksu'@);
_btnAnal:=_paczka.win_btn(_wer_paczka,'text=%1'['Analiza'@],'menu:A');
_paczka.btn_sopt(_wer_paczka,_btnAnal,'tooltip='+'Analiza dostępności materiałów w czasie'@);

:: Ikony
_formula:="
   _paczka:=cur_tab(1,1);
   _nr:=0;
   _wyn:='';
   {? _paczka.BRANCH='T'
   || {? _paczka.tr_state()=0
      || _nr:=74
      |? _paczka.tr_state()=1
      || _nr:=75
      ?}
   ?};
   {? _paczka.TYP='T'
   || _nr:=131
   ?};
   {? _nr>0
   || _wyn:='xwin16.png:'+$_nr
   ?};
   _wyn
";
_paczka.win_fml(_wer_paczka,,'SYMBOL',,'ICON_BEFORE',_formula);

:: Okno redakcyjne
{? sec_superuser()>0
|| _edit:=_paczka.mk_edit('Element przepisu źródłowego'@);
   _paczka.win_efld(_edit,        ,'SYMBOL'  ,     ,,50);
   _paczka.win_efld(_edit,        ,'NAZWA'   ,     ,,100);
   _paczka.win_efld(_edit,        ,'ILOSC'   ,     ,, 15,ST.DOKL);
   _paczka.win_efld(_edit,AH      ,'H'       ,     ,,   ,,,'');
   _paczka.win_efld(_edit,        ,'NORMA'   ,     ,, 15,ST.DOKL);
   _paczka.win_efld(_edit,AH      ,'H'       ,     ,,   ,,,'');
   _paczka.win_efld(_edit,PX_VAR  ,'JM1'     ,'KOD',, 12,,,'Wymiar %1'@['1']);
   _paczka.win_efld(_edit,        ,'CAP_DIM1',     ,, 15,ST.DOKL,,'zużycie'@);
   _paczka.win_efld(_edit,        ,'CAP_MIN1',     ,, 15,ST.DOKL,,'minimum'@);
   _paczka.win_efld(_edit,        ,'CAP_MAX1',     ,, 15,ST.DOKL,,'maksimum'@);
   _paczka.win_efld(_edit,AH      ,'H'       ,     ,,   ,,,'');
   _paczka.win_efld(_edit,PX_VAR  ,'JM2'     ,'KOD',, 12,,,'Wymiar %1'@['2']);
   _paczka.win_efld(_edit,        ,'CAP_DIM2',     ,, 15,ST.DOKL,,'zużycie'@);
   _paczka.win_efld(_edit,        ,'CAP_MIN2',     ,, 15,ST.DOKL,,'minimum'@);
   _paczka.win_efld(_edit,        ,'CAP_MAX2',     ,, 15,ST.DOKL,,'maksimum'@);
   _paczka.win_efld(_edit,AH      ,'H'       ,     ,,   ,,,'');
   _paczka.win_efld(_edit,PX_VAR  ,'JM3'     ,'KOD',, 12,,,'Wymiar %1'@['3']);
   _paczka.win_efld(_edit,        ,'CAP_DIM3',     ,, 15,ST.DOKL,,'zużycie'@);
   _paczka.win_efld(_edit,        ,'CAP_MIN3',     ,, 15,ST.DOKL,,'minimum'@);
   _paczka.win_efld(_edit,        ,'CAP_MAX3',     ,, 15,ST.DOKL,,'maksimum'@);
   _paczka.win_efld(_edit,AH      ,'H'       ,     ,,   ,,,'');
   _paczka.win_efld(_edit,PX_VAR  ,'JM4'     ,'KOD',, 12,,,'Wymiar %1'@['4']);
   _paczka.win_efld(_edit,        ,'CAP_DIM4',     ,, 15,ST.DOKL,,'zużycie'@);
   _paczka.win_efld(_edit,        ,'CAP_MIN4',     ,, 15,ST.DOKL,,'minimum'@);
   _paczka.win_efld(_edit,        ,'CAP_MAX4',     ,, 15,ST.DOKL,,'maksimum'@);
   _paczka.win_efld(_edit,AH      ,'H'       ,     ,,   ,,,'');
   _paczka.win_efld(_edit,PX_VAR  ,'JM5'     ,'KOD',, 12,,,'Wymiar %1'@['5']);
   _paczka.win_efld(_edit,        ,'CAP_DIM5',     ,, 15,ST.DOKL,,'zużycie'@);
   _paczka.win_efld(_edit,        ,'CAP_MIN5',     ,, 15,ST.DOKL,,'minimum'@);
   _paczka.win_efld(_edit,        ,'CAP_MAX5',     ,, 15,ST.DOKL,,'maksimum'@);
   _paczka.win_edit(_edit);
   ~~
?};

params_set('PxPack',_PxPack);
_paczka.select();
_paczka.cntx_pop();

PX_KONT.cntx_pop();
~~


\trzepaczka
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Przeksztalca technologie do planowania (PX_TEX) na paczke technologiczna dla algorytmu planujacego
::   WE: _a - PX_TEX.ref() - technologia do planu na podstawie ktorej ma zostac utworzona paczka
::       _b - REAL - ilosc rzeczywista dla ktorej wygenerowac paczke
::       [_c] - PX_GRP.ref() - obiekt grupujacy ktory utworzyl paczke
::       [_d] - PX_OBJ.ref() - wskazanie na obiekt planistyczny
::       [_e] - PX_STAGE.ref() - wskazanie na etap planistyczny, jezeli tylko ten jest obrabiany
::       [_f] - INTEGER - czy obrabiane sa zasoby (0/1)
::       [_g] - INTEGER - czy obrabiane sa surowce (0/1)
::   WY: obj_new - paczka technologiczna obudowana (PxPack)
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PX_TEX','PX_OBJ','ILOSC','PX_STAGE','PxOPER','PxMAT','PX_GRP');

{? var_pres('_a')=type_of(SYSLOG.ref()) || _args.PX_TEX:=_a   || _args.PX_TEX:=null()   ?};
{? var_pres('_b')=type_of(0)            || _args.ILOSC:=_b    || _args.ILOSC:=0         ?};
{? var_pres('_c')=type_of(SYSLOG.ref()) || _args.PX_GRP:=_c   || _args.PX_GRP:=null()   ?};
{? var_pres('_d')=type_of(SYSLOG.ref()) || _args.PX_OBJ:=_d   || _args.PX_OBJ:=null()   ?};
{? var_pres('_e')=type_of(SYSLOG.ref()) || _args.PX_STAGE:=_e || _args.PX_STAGE:=null() ?};
{? var_pres('_f')=type_of(0)            || _args.PxOPER:=_f   || _args.PxOPER:=1        ?};
{? var_pres('_g')=type_of(0)            || _args.PxMAT:=_g    || _args.PxMAT:=1         ?};

{? _args.PX_GRP<>null()
|| PX_GRP.cntx_psh(); PX_GRP.prefix();
   {? PX_GRP.seek(_args.PX_GRP) & PX_GRP.GROPS<>null()
   || PX_GRP.cntx_pop();
      return(exec('trzepaczka_grop','px_tex',PX_GRP.GROPS,_args.ILOSC,PX_GRP.ref(),_args.PX_OBJ))
   ?};
   PX_GRP.cntx_pop()
?};

_loc:=obj_new('PxPack');
_loc.PxPack:=exec('PxPack_declare','px_tex');
:: dorzucenie do paczki przekazanych parametrów (informacyjnie)
_loc.PxPack.PX_TEX:=_args.PX_TEX;
_loc.PxPack.PX_GRP:=_args.PX_GRP;

:: Jesli jeszcze nie jest psotek powolany to go powoluje
exec('PXoTEX_chk','px_tex');

::{? _args.PX_TEX=null() || _args.PX_TEX:=exec('get_PX_TEX','px_tex',_args.PX_OBJ, _args.PX_GRP) ?};

{? _args.PX_TEX<>null()
|| PX_TEX.cntx_psh();
   PX_TEX.clear();
   {? PX_TEX.seek(_args.PX_TEX)
   ||
::    teraz sprawdzamy, czy przepis jest automatyczny, jezeli jest to trzeba go zaktualizowac
      {? (+PXoTEX.kind.auto(''))+PX_TEX.KIND=PXoTEX.kind.auto('')
      || exec('PX_TEX_autoupd','px_auto',PX_TEX.ref())
      ?};
      {? PX_TEX.PX_RULES().RULE<>''
      || _eggs:=exec('pck_params','px_whisk');
         _eggs.Formula:=PX_TEX.PX_RULES().RULE;
         _eggs.PxPack:=_loc.PxPack;
         {? PX_TEX.TKTL<>null()
         || _eggs.TKTL:=PX_TEX.TKTL
         |? PX_TEX.RTKTL<>''
         || _eggs.TKTL:=exec('FindAndGet','#table',TKTL,PX_TEX.RTKTL,,,null())
         ?};
         _eggs.PX_TEX:=_args.PX_TEX;
         _eggs.PX_OBJ:=_args.PX_OBJ;
         _eggs.PX_GRP:=_args.PX_GRP;
         {? _args.PX_GRP<>null()
         || _eggs.PL_FORCE:=exec('FindAndGet','#table',PX_GRP
                                                      ,#_args.PX_GRP
                                                      ,ref_name(_args.PX_GRP)
                                                      ,"PL_FORCE"
                                                      ,'N')
         ?};
         _eggs.Quantity:=_args.ILOSC;
         _eggs.PX_STAGE:=_args.PX_STAGE;
         _eggs.PxOPER:=_args.PxOPER;
         _eggs.PxMAT:=_args.PxMAT;
         ($('_eggs:=_a; '+PX_TEX.PX_RULES().RULE))(_eggs)
      ?}
   || FUN.wdrerror('Podano PX_technologię, ale nie można jej znaleźć ('+$_args.PX_TEX+').');
      0
   ?};
   PX_TEX.cntx_pop()
||
   PX_TEX.cntx_psh(); PX_TEX.clear(); _tex:={? PX_TEX.seek(_args.PX_TEX) || PX_TEX.SYMBOL || '<brak>' ?}; PX_TEX.cntx_pop();
   PX_OBJ.cntx_psh(); PX_OBJ.clear(); _obj:={? PX_OBJ.seek(_args.PX_OBJ) || PX_OBJ.SYMBOL || '<brak>' ?}; PX_OBJ.cntx_pop();
   PX_GRP.cntx_psh(); PX_GRP.prefix();
   _grp:='<brak>';
   {? PX_GRP.seek()
   || _grp:=PX_GRP.SYMBOL
   ?};
   PX_GRP.cntx_pop();

   _msg:='Nie podano i nie znaleziono przepisu planistycznego dla podanych parametrów:\n\n'
         'Technologia: %1\n'
         'Obiekt: %2\n'
         'Element kolejki: %3\n'
         'Ilość: %4'@[_tex,_obj,_grp,$_args.ILOSC];
   FUN.emsg(_msg);
   FUN.wdrerror('Nie podano i nie znaleziono PX_technologii dla podanych parametrów:'
      +'\nPX_TEX: '+$_args.PX_TEX
      +'\nPX_OBJ: '+$_args.PX_OBJ
      +'\nILOSC: '+$_args.ILOSC
   );
   0
?};
::{? _args.PX_TEX=null() | _loc.PxPack.ErrCode=-1 || exec('paczka_demo','px_tex',_loc.PxPack) ?};
_loc.PxPack


\trzepaczka_grop
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [23.25]
:: OPIS: Tworzy paczke technologiczna dla grupy operacji, która nie ma przepisu planistycznego
::   WE: _a - GROPS.ref() - stanowisko z grupy operacji dla ktorej ma zostac utworzona paczka
::       _b - REAL - ilosc rzeczywista dla ktorej wygenerowac paczke
::       [_c] - PX_GRP.ref() - obiekt grupujacy ktory utworzyl paczke
::       [_d] - PX_OBJ.ref() - wskazanie na obiekt planistyczny
::   WY: obj_new - paczka technologiczna obudowana (PxPack)
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('GROPS','PX_OBJ','ILOSC','PX_STAGE','PxOPER','PxMAT','PX_GRP');
_args.PX_STAGE:=null();
_args.PxOPER:=1;
_args.PxMAT:=1;

{? var_pres('_a')=type_of(SYSLOG.ref()) || _args.GROPS:=_a   || _args.GROPS:=null()   ?};
{? var_pres('_b')=type_of(0)            || _args.ILOSC:=_b    || _args.ILOSC:=0         ?};
{? var_pres('_c')=type_of(SYSLOG.ref()) || _args.PX_GRP:=_c   || _args.PX_GRP:=null()   ?};
{? var_pres('_d')=type_of(SYSLOG.ref()) || _args.PX_OBJ:=_d   || _args.PX_OBJ:=null()   ?};

_loc:=obj_new('PxPack');
_loc.PxPack:=exec('PxPack_declare','px_tex');
:: dorzucenie do paczki przekazanych parametrów (informacyjnie)
_loc.PxPack.PX_GRP:=_args.PX_GRP;

:: Jesli jeszcze nie jest psotek powolany to go powoluje
exec('PXoTEX_chk','px_tex');

GROPS.cntx_psh();
GROPS.prefix();
GROP.cntx_psh();
{? GROPS.seek(_args.GROPS)
||
   _eggs:=exec('pck_params','px_whisk');
   _eggs.GROPS:=_args.GROPS;
   _eggs.Formula:='';
   _eggs.PxPack:=_loc.PxPack;
   _eggs.PX_OBJ:=_args.PX_OBJ;
   _eggs.PX_GRP:=_args.PX_GRP;
   {? _args.PX_GRP<>null()
   || _eggs.PL_FORCE:=exec('FindAndGet','#table',PX_GRP
                                                ,#_args.PX_GRP
                                                ,ref_name(_args.PX_GRP)
                                                ,"PL_FORCE"
                                                ,'N')
   ?};
   _eggs.Quantity:=_args.ILOSC;
   _eggs.PxOPER:=_args.PxOPER;
   _eggs.PxMAT:=_args.PxMAT;
   _eggs.Directio:=exec('FindAndGet','#table',PX_GRP,_eggs.PX_GRP,,"DIR",-1);

   exec('Grops2PxPack','px_whisk',_eggs)
|| FUN.wdrerror('Nie podano i nie znaleziono zasobu grupy operacji dla podanych parametrów:'
      +'\nGROPS: '+$_args.GROPS
      +'\nPX_OBJ: '+$_args.PX_OBJ
      +'\nILOSC: '+$_args.ILOSC
   )
?};
GROP.cntx_pop();
GROPS.cntx_pop();
_loc.PxPack


\paczka_demo
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca demonstracyjna paczke, lub wypelnia danymi demo przekazana paczke
::   WE: [_a] - paczka technologiczna - exec('PxPack_declare','px_tex');
::----------------------------------------------------------------------------------------------------------------------
PX_OPER.cntx_psh();
PX_KONT.cntx_psh();
PX_KONT.index('ACT');
PX_KONT.prefix('T',exec('get_mainversion','px_ver'));
{? var_pres('_a')>100 & type_of(_a)=type_of(exec('PxPack_declare','px_tex'))
|| _PxPack:=_a
|| _PxPack:=exec('PxPack_declare','px_tex')
?};

_cntx_set:=1;
::_obj_grp:=_a;
::jesli w buforze ten sam obiekt grupujacy co przekazany w argumencie to nie robie seeka

::{? $_obj_grp<>$PX_GRP.ref()
::|| _cntx_set:=0;
::   PX_GRP.clear();
::   {? PX_GRP.seek(_obj_grp)
::   || _cntx_set:=1
::   ?}
::?};

{? _cntx_set>0
||

   _args:=_PxPack.add_a();

:: operacja 1
   PX_STAGE.first();
   _args.PARENT:=null();
   _args.SYMBOL:=PX_STAGE.NAZWA;
   _args.NAZWA:='';
   _args.BRANCH:='T';
   _args.TYP:='O';
   _args.ID:=1;
   _args.PAR_ID:=0;
   _args.LEVEL:=0;
   _args.ILOSC:=300;
   _args.NUM:=1;
   _args.CAP_DIM1:=100;
   _args.PX_STAGE:=$PX_STAGE.ref();
   _args.PX_STAGM:=PX_STAGE.name();
   _args.PX_STAGR:=#PX_STAGE.ref();

   _op1:=_PxPack.add(_args);

::    kontener 1
   PX_KONT.first();
   _args.PARENT:=_op1;
   _args.SYMBOL:=PX_KONT.SYMBOL;
   _args.NAZWA:=PX_KONT.NAZWA;
   _args.REF_KONT:=$PX_KONT.ref();
   _args.BRANCH:='N';
   _args.TYP:='K';
   _args.ID:=100;
   _args.PAR_ID:=1;
   _args.LEVEL:=1;
   _args.ILOSC:=300;
   _args.NUM:=1;
   _args.CAP_DIM1:=100;
   _args.PX_STAGE:=$PX_STAGE.ref();
   _args.PX_STAGM:=PX_STAGE.name();
   _args.PX_STAGR:=#PX_STAGE.ref();

   _kont11:=_PxPack.add(_args);

:: operacja 2
   PX_STAGE.next();
   _args.PARENT:=null();
   _args.SYMBOL:=PX_STAGE.NAZWA;
   _args.NAZWA:='';
   _args.BRANCH:='T';
   _args.TYP:='O';
   _args.ID:=2;
   _args.PAR_ID:=0;
   _args.LEVEL:=0;
   _args.ILOSC:=50;
   _args.NUM:=2;
   _args.CAP_DIM1:=200;
   _args.PX_STAGE:=$PX_STAGE.ref();
   _args.PX_STAGM:=PX_STAGE.name();
   _args.PX_STAGR:=#PX_STAGE.ref();

   _op2:=_PxPack.add(_args);


::    kontener 1
      PX_KONT.first();
      _args.PARENT:=_op2;
      _args.SYMBOL:=PX_KONT.SYMBOL;
      _args.NAZWA:=PX_KONT.NAZWA;
      _args.REF_KONT:=$PX_KONT.ref();
      _args.BRANCH:='N';
      _args.TYP:='K';
      _args.ID:=101;
      _args.PAR_ID:=2;
      _args.LEVEL:=1;
      _args.ILOSC:=50;
      _args.NUM:=2;
      _args.CAP_DIM1:=50;
      _args.PX_STAGE:=$PX_STAGE.ref();
      _args.PX_STAGM:=PX_STAGE.name();
      _args.PX_STAGR:=#PX_STAGE.ref();

      _kont21:=_PxPack.add(_args);

::    kontener 2
      PX_KONT.next();
      _args.PARENT:=_op2;
      _args.SYMBOL:=PX_KONT.SYMBOL;
      _args.NAZWA:=PX_KONT.NAZWA;
      _args.REF_KONT:=$PX_KONT.ref();
      _args.BRANCH:='N';
      _args.TYP:='K';
      _args.ID:=102;
      _args.PAR_ID:=2;
      _args.LEVEL:=1;
      _args.ILOSC:=50;
      _args.NUM:=2;
      _args.CAP_DIM1:=150;
      _args.PX_STAGE:=$PX_STAGE.ref();
      _args.PX_STAGM:=PX_STAGE.name();
      _args.PX_STAGR:=#PX_STAGE.ref();

      _kont22:=_PxPack.add(_args);

:: operacja 3
   PX_STAGE.next();
   _args.PARENT:=null();
   _args.SYMBOL:=PX_STAGE.NAZWA;
   _args.NAZWA:='';
   _args.BRANCH:='T';
   _args.TYP:='O';
   _args.ID:=3;
   _args.PAR_ID:=0;
   _args.LEVEL:=0;
   _args.ILOSC:=70;
   _args.NUM:=3;
   _args.CAP_DIM1:=450;
   _args.PX_STAGE:=$PX_STAGE.ref();
   _args.PX_STAGM:=PX_STAGE.name();
   _args.PX_STAGR:=#PX_STAGE.ref();

   _op3:=_PxPack.add(_args);

::    kontener 1
      PX_KONT.next();
      _args.PARENT:=_op3;
      _args.SYMBOL:=PX_KONT.SYMBOL;
      _args.NAZWA:=PX_KONT.NAZWA;
      _args.REF_KONT:=$PX_KONT.ref();
      _args.BRANCH:='N';
      _args.TYP:='K';
      _args.ID:=103;
      _args.PAR_ID:=3;
      _args.LEVEL:=1;
      _args.ILOSC:=70;
      _args.NUM:=3;
      _args.CAP_DIM1:=250;
      _args.PX_STAGE:=$PX_STAGE.ref();
      _args.PX_STAGM:=PX_STAGE.name();
      _args.PX_STAGR:=#PX_STAGE.ref();

      _kont31:=_PxPack.add(_args);

::    kontener 2
      PX_KONT.next();
      _args.PARENT:=_op3;
      _args.SYMBOL:=PX_KONT.SYMBOL;
      _args.NAZWA:=PX_KONT.NAZWA;
      _args.REF_KONT:=$PX_KONT.ref();
      _args.BRANCH:='N';
      _args.TYP:='K';
      _args.ID:=104;
      _args.PAR_ID:=3;
      _args.LEVEL:=1;
      _args.ILOSC:=70;
      _args.NUM:=3;
      _args.CAP_DIM1:=250;
      _args.PX_STAGE:=$PX_STAGE.ref();
      _args.PX_STAGM:=PX_STAGE.name();
      _args.PX_STAGR:=#PX_STAGE.ref();

      _kont32:=_PxPack.add(_args);

:: operacja 4
   PX_STAGE.next();
   _args.PARENT:=null();
   _args.SYMBOL:=PX_STAGE.NAZWA;
   _args.NAZWA:='';
   _args.BRANCH:='T';
   _args.TYP:='O';
   _args.ID:=4;
   _args.PAR_ID:=0;
   _args.LEVEL:=0;
   _args.ILOSC:=20;
   _args.NUM:=4;
   _args.CAP_DIM1:=40;
   _args.PX_STAGE:=$PX_STAGE.ref();
   _args.PX_STAGM:=PX_STAGE.name();
   _args.PX_STAGR:=#PX_STAGE.ref();

   _op4:=_PxPack.add(_args);

::    kontener 1
      PX_KONT.next();
      _args.PARENT:=_op4;
      _args.SYMBOL:=PX_KONT.SYMBOL;
      _args.NAZWA:=PX_KONT.NAZWA;
      _args.REF_KONT:=$PX_KONT.ref();
      _args.BRANCH:='N';
      _args.TYP:='K';
      _args.ID:=104;
      _args.PAR_ID:=4;
      _args.LEVEL:=1;
      _args.ILOSC:=20;
      _args.NUM:=4;
      _args.CAP_DIM1:=40;
      _args.PX_STAGE:=$PX_STAGE.ref();
      _args.PX_STAGM:=PX_STAGE.name();
      _args.PX_STAGR:=#PX_STAGE.ref();

      _kont41:=_PxPack.add(_args)
?};
PX_KONT.cntx_pop();
PX_OPER.cntx_pop();
_PxPack


\PX_TEX_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Wyświetla PX_TEXy dla podanych warunków
::   WE: STRING _a - sposob ograniczenia dziedziny
::                   'A' - wg aktywnosci
::                   'R' - wg symbolu reguły
::                   'K' - wg rodzaju
::                   'M' - wg materialu
::                   'G' - wg grupy materialowej
::                   inne - bez ograniczen - wszystkie
::          ANY _b - wartość do ograniczenia dziedziny
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('sposob','wartosc');
_args.sposob:=_a;
_args.wartosc:=_b;
PX_VAR.STRING:=_a+'|'+_b;

:: przygotujemy zmienna do prefiksow i blankowania
{? var_pres('PXoTEX')<100 || exec('PXoTEX','px_tex') ?};
PXoTEX.KIND:='';
PXoTEX.PrfxVal:=null();
PX_TEX.cntx_psh();
M.cntx_psh();
PX_TEX.clear();

PX_TEX.win_sel('WER');
PX_TEX.win_edit('RED');
_actions:=obj_new('empty','notempty','default');
exec('array_blank','#array',_actions,'');

{? {? _args.sposob='R'
   || PX_TEX.index('R_ASYM');
      _actions.notempty:='DU';
      _actions.empty:='D';
      PX_TEX.win_sel('WER_ALL');
      1
   |? _args.sposob='A'
   || PX_TEX.index('ASYM');
      _actions.notempty:='DU';
      _actions.empty:='D';
      PX_TEX.win_sel('WER_ALL');
      1
   |? _args.sposob='K'
   || PX_TEX.index('KASYM');
      {? _args.wartosc=PXoTEX.kind.table('M')
      || PXoTEX.KIND:=PXoTEX.kind.table('M');
         PX_TEX.win_sel('WER_M');
         PX_TEX.win_edit('RED_M')
      |? _args.wartosc=PXoTEX.kind.table('MGR')
      || PXoTEX.KIND:=PXoTEX.kind.table('MGR');
         PX_TEX.win_sel('WER_MGR');
         PX_TEX.win_edit('RED_MGR')
      |? _args.wartosc='SYSTEM'
      || PXoTEX.KIND:=PXoTEX.kind.system();
         _actions.notempty:='DU';
         _actions.empty:='D';
         PX_TEX.win_sel('WER_ALL');
         PX_TEX.win_edit('RED')
      |? _args.wartosc=PXoTEX.kind.auto('ZL')
      || PXoTEX.KIND:=PXoTEX.kind.auto('ZL');
         _actions.notempty:='DU';
         _actions.empty:='D';
         PX_TEX.win_sel('WER_ALL');
         PX_TEX.win_edit('RED')

      || PX_TEX.win_sel('WER_ALL')
      ?};
      1
   |? _args.sposob='M' || PX_TEX.index('MASYM'   ); PX_TEX.win_sel('WER'     ); 1
   |? _args.sposob='G' || PX_TEX.index('MGRASYM' ); PX_TEX.win_sel('WER'     ); 1
   ?}

|| PX_TEX.prefix(_args.wartosc,);
   PX_TEX.first();
   {? _actions.empty<>''
    | _actions.notempty<>''
    | _actions.default<>''
   || PX_TEX.actions(PX_TEX.win_sel('?'),_actions.notempty+':'+_actions.empty,_actions.default,1)
   ?};

:: Ustawienie okien dla M
   exec('slo_m_ok','material','T',1,,'W');

:: Filtrowanie kartoteki M
   exec('filter','material','WP');

:: Header w oknie wertowania M
   exec('wpm_opis','material','WP',' — '+exec('zakr_naz','material',ZAKR.MATU));

   PX_TEX.select()
?};
:: Przywracam tytul i akcje w slowniku materialow
exec('filter_clear','material');
M.cntx_pop();
M.hdr_sel();
PX_TEX.cntx_pop();
~~


\PX_TEX_list4
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: zwraca PX_TEX.ref() dla podanego... czegos
::   WE: _a - cos dla czego szukamy PXa
::      [_b] - aktywna ['T']
::      [_c] - tabela wynikowa - wowczas nie jest tworzona
::      [_d] - ranking technologii dla obiektu
::      [_e] - poziom technologii
::   WY: tab_tmp[PX_TEX.name(), #PX_TEX.ref()]
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac, czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_cos:=_a;
_akt:={?_>1 & type_of(_b)=2 || _b || 'T' ?};
_px_texy:={?_>2 & type_of(_c)>100 || _c || exec('px_texy_tab','px_tex') ?};
_px_level:={?_>3 & type_of(_d)=1 || _d || 1 ?};
_level_name:={?_>4 & type_of(_e)=type_of('') || _e || '' ?};

PX_TEX.cntx_psh();
PX_TEX.clear();
:: sprawdzam czy dostepny jest PXoTEX, jesli nie to powoluje
exec('PXoTEX_chk','px_tex');
:: najpierw dajmy szanse wdrozeniowcowi
{? exec('PX_TEX_list4','px_prepq',_cos,_px_texy)=0
|| _ndx:='';
:: 'wdrozeniowiec nie ustalil, wiec standardowa obsluga'
   _material:=0;
   {? {? type_of(_cos)=2 || PXoTEX.index(_cos)
      |? type_of(_cos)=7
      || {? ref_name(_cos)=M.name()
         || _material:=1;
            PXoTEX.index(PXoTEX.kind.table('M')  )
         |? ref_name(_cos)=MGR.name()
         || PXoTEX.index(PXoTEX.kind.table('MGR'))
         |? ref_name(_cos)=ZL.name()
         || PXoTEX.index(PXoTEX.kind.auto('ZL')  )
         ?}
      ?}
   ||
      PX_TEX.prefix(_cos,_akt);
      {? PX_TEX.first()
      || {!
         |? _px_texy.PX_TEXN:=PX_TEX.name();
            _px_texy.PX_TEXR:=#PX_TEX.ref();
            _px_texy.PX_TEXQ:=$PX_TEX.ref();

            {? _material>0 & PX_TEX.TKTL<>null()
            ||
::             Sprawdzam czy karta domyślna i jeśli tak to odejmuje 1 od rankingu
               {? exec('is_default_tech','tech_common',PX_TEX.TKTL,_cos)
               || _px_texy.LEVEL:=_px_level-1
               || _px_texy.LEVEL:=_px_level
               ?}
            || _px_texy.LEVEL:=_px_level
            ?};
            _px_texy.LEV_NAME:=_level_name;
            _px_texy.add();
            PX_TEX.next()
         !}
      ?}
   ?};
:: jezeli zostal ustalony indeks tymczasowy to go zwalniamy
   {? _ndx<>'' || PX_TEX.ndx_drop(_ndx) ?}
?};
PX_TEX.cntx_pop();
_px_texy


\PxObjLst_make
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tworzy strukture listy PX_OBJow
::   WY: PxObjLst
::----------------------------------------------------------------------------------------------------------------------
_PxObjLst:=obj_new('PX_GRP','PX_OBJs','COUNT','add');
_PxObjLst.PX_GRP:=null();
_PxObjLst.PX_OBJs:=tab_tmp(2
                          ,'MASKA'   ,'STRING[8]'  ,'PX_OBJ.name()'
                          ,'REF'     ,'INTEGER'    ,'#PX_OBJ.ref()'
                          ,'REFSQL'  ,'STRING[16]' ,'$PX_OBJ.ref()'
                          ,'SYMBOL'  ,'STRING[60]' ,'Symbol'
                          ,'NAZWA'   ,'STRING[60]' ,'Nazwa'
                          ,'KIND'    ,'STRING[10]' ,'Rodzaj'
                          );
_PxObjLst.COUNT:=0;
_PxObjLst.add:="
   _px_obj:=_a;
   _tab:=.PX_OBJs;
   _result:=0;
   PX_OBJ.cntx_psh(); PX_OBJ.clear();
   {? PX_OBJ.seek(_px_obj)
   || {? ~_tab.find_key(PX_OBJ.name(), #PX_OBJ.ref())
      || _tab.MASKA:=PX_OBJ.name();
         _tab.REF:=PX_OBJ.ref();
         _tab.REFSQL:=$PX_OBJ.ref();
         _tab.SYMBOL:=PX_OBJ.SYMBOL;
         _tab.NAZWA:=PX_OBJ.NAZWA;
         _tab.KIND:=PX_OBJ.KIND;
         {? _tab.add()
         || .COUNT+=1;
            _result:=1
         ?}
      || _result:=1
      ?}
   ?};
   PX_OBJ.cntx_pop();
   _result
";
_PxObjLst


\PX_TEX_filter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przygotowuje filtr dla PX_TEX na podstawie podanych px
::   WE: _a - PxObjLst
::      [_b]- [1 - Filtrować], 0 - tabela tymczasowa z lista technologii w rankingu
::   WY: gdy _b=1  -  wynik PX_TEX.f_set()
::       gdy _b=2  -
::----------------------------------------------------------------------------------------------------------------------
_PxObjLst:=_a;
_filterek:={?_>1 & type_of(_b)=1 || _b || 1 ?};
_loc:=obj_new('px_tex','tex_obj','px_obj');
:: px_tex - lista technologii wspolnych dla podanego zestawu obiektow
:: tex_obj - lista technologii dla podanego obiektu
:: px_obj - wskazanie na aktualny PX_OBJ
{? _filterek
|| PX_TEX.clear();
   PX_TEX.f_clear(0)
?};
PX_TEX.cntx_psh(); PX_TEX.clear();
:: zakladam tabelke tymczasowa w ktorej bede trzymal wspolne technologie
_loc.px_tex:=exec('px_texy_tab','px_tex');
_loc.px_tex.index(_loc.px_tex.ndx_tmp(,1,'PX_TEXQ',,));

::{? sec_superuser()>0 || _loc.px_tex.win_sel(_loc.px_tex.mk_sel(,,1)) ?};
{? ~_PxObjLst.PX_OBJs.first()
 & _PxObjLst.PX_GRP<>null()
:: utworzenie listy na podstawie skladnikow PX_GRP
|| PX_GRP.cntx_psh(); PX_GRP.clear();
   PX_OBJ.cntx_psh(); PX_OBJ.clear();
   PX_CONN.cntx_psh();PX_CONN.clear();

   {? PX_GRP.seek(_PxObjLst.PX_GRP)
   || PX_CONN.index('PX_GRP');
      PX_CONN.prefix(_PxObjLst.PX_GRP);
      {? PX_CONN.first()
      || {!
         |?
            _PxObjLst.add(PX_CONN.PX_OBJ);
            PX_CONN.next()
         !}
      ?}
   ?};
   PX_CONN.cntx_pop();
   PX_OBJ.cntx_pop();
   PX_GRP.cntx_pop();
   ~~
?};
:: _PxObjLst.COUNT - zawiera liczbe PX_OBJ dla ktorych bede szukal wspolnej technologii
:: _loc.px_tex.COUNT -  licznik wystapien technologii we wszystkich badanych px_obj
::                      przy czym 0 oznacza ze technologia wystepuje we wszystkich PX_OBJ

{? _PxObjLst.COUNT>0
 & _PxObjLst.PX_OBJs.first()
|| _loc.tex_obj:=obj_new(1);
   {!
   |?
      obj_del(_loc.tex_obj);
      _loc.px_obj:=exec('FindAndGet','#table',PX_OBJ,_PxObjLst.PX_OBJs.REF,_PxObjLst.PX_OBJs.MASKA,'ref()',null());
      {? _loc.px_obj<>null()
      || _loc.tex_obj:=exec('PX_OBJ_get_texy','px_obj',_loc.px_obj,'T');
         {? _loc.tex_obj.first()
         || {!
            |?
               {? ~_loc.px_tex.find_key(_loc.tex_obj.PX_TEXQ)
               || _loc.px_tex.PX_TEXQ:=_loc.tex_obj.PX_TEXQ;
                  _loc.px_tex.PX_TEXN:=_loc.tex_obj.PX_TEXN;
                  _loc.px_tex.PX_TEXR:=_loc.tex_obj.PX_TEXR;
                  _loc.px_tex.LEVEL:=_loc.tex_obj.LEVEL;
                  _loc.px_tex.LEV_NAME:=_loc.tex_obj.LEV_NAME;
                  _loc.px_tex.COUNT:=_PxObjLst.COUNT-1;
                  _loc.px_tex.add();
                  ~~
               || _loc.px_tex.COUNT-=1;
                  _loc.px_tex.LEVEL+=_loc.tex_obj.LEVEL;
                  _loc.px_tex.put();
                  ~~
               ?};
               _loc.tex_obj.next()
            !}
         ?}
      ?};
      _PxObjLst.PX_OBJs.next()
   !};
:: jezeli mamy jakas liste technologii, to wycinamy wszystkie, ktore
   {? _loc.px_tex.first()
   || {!
      |? {? _loc.px_tex.COUNT>0
         || _loc.px_tex.del()
         || _loc.px_tex.next()
         ?}
      !}
::      {? sec_superuser()>0 || _loc.px_tex.select() ?}
   ?}
?};
PX_TEX.cntx_pop();
{? _filterek=1
|| PX_TEX.f_set('SYMBOL',,'PX_TEX.REFERENCE IN (select tab.PX_TEXQ from :_a tab)',_loc.px_tex )
|| _loc.px_tex.index(_loc.px_tex.ndx_tmp(,1
                                        ,'COUNT',,
                                        ,'LEVEL',,
                                        )
                    );
   _loc.px_tex
?}


\get_PX_TEX
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: zwraca PX_TEX.ref() dla podanego... czegos
::   WE: _a - cos dla czego szukamy PXa
::      [_b] - aktywna ['T']
::   WY: cResult.Result= PX_TEX.ref() lub null()
::----------------------------------------------------------------------------------------------------------------------
_result:=obj_new(@.Class.cResult);
_result.Result:=null();
_cos:={?_>0 || _a || _result.State:=-1; _result.WdrMsg:='Brak parametrów.' ?};
_result


\PXoTEX_chk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Sprawdza czy jest powolany PXoTEX, a jesli nie to powoluje
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('PXoTEX',@)<100
|| exec('PXoTEX','px_tex',1)
?}


\PXoTEX
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Zwraca strukture pomocna przy wyswietlaniu i obsludze tabeli PX_TEX
::   WE: [_a] - tworzyc PXoTEX? (1-tak-domyslnie, 0-nie)
::   WY: wskazanie na obiekt
::----------------------------------------------------------------------------------------------------------------------
_array:=obj_new('KIND','PrfxVal','KindTab','index','prefix','kind','kind_add','rules','Rules');

:: ostatnio ustalony rodzaj
_array.KIND:='';

:: ostatnio ustalona wartosc do prefix'u
_array.PrfxVal:=~~;

:: tabela rodzajow PX_TEXow
_array.KindTab:=tab_tmp(2
                     ,'KIND'    ,'STRING[20]' ,'Rodzaj'
                     ,'PX_TEX_B','STRING[8]'  ,'Index dla PX_TEX - mbuilder'
                     ,'PX_TEX_T','STRING[255]','Index dla PX_TEX - tymczasowy - formula'
                     );

:: metoda dodajaca do KindTab
_array.kind_add:="
   .KindTab.KIND:=~-_a;
   .KindTab.PX_TEX_B:=form(_b);
   .KindTab.PX_TEX_T:=form(_c);
   .KindTab.add()";

:: metoda ustalajaca indeks dla PX_TEX na podstawie _rodaj
_array.index:="
   _kind:=_a;
   _zonk:=\"PX_TEX.index('KASYM');0\";
   {? _kind<>'' || .KIND:=_kind ?};
   {? _kind<>''
    & .KindTab.find_key(_kind,)
   || {? {? .KindTab.PX_TEX_B<>'' || PX_TEX.index(.KindTab.PX_TEX_B); 1
         |? .KindTab.PX_TEX_T<>'' || ($('PX_TEX.'+.KindTab.PX_TEX_T))(); 1
         ?}
      || 1
      || _zonk()
      ?}
   || _zonk()
   ?}
";

:: metoda prefixujaca PX_TEX na podstawie _rodzaj, _wartosc
_array.prefix:="
   _kind:=_a;
   _what:=_b;
   _zonk:=\"PX_TEX.index('KASYM'); PX_TEX.prefix('','','',);~~\";
   {? _what<>~~ || .PrfxVal:=_what ?};
   {? .index(_kind)
    & _what<>~~
   || PX_TEX.prefix(_what,)
   || _zonk()
   ?};
   PX_TEX.first()
";

:: generatory rodzajow przepisow
_array.kind:=obj_new('table','auto','system');
:: zwraca typ dla podanego akronimu tabeli
_array.kind.table:="'TABELA '+_a";
_array.kind.auto:="'AUTOPX '+_a";
_array.kind.system:="'SYSTEM'";
:: podstawowe rodzaje technologii - powiazan
_array.kind_add(_array.kind.table('M'),  'MASYM'  ,'');
_array.kind_add(_array.kind.table('MGR'),'MGRASYM','');
_array.kind_add(_array.kind.auto('ZL')  ,'ZLASYM' ,'');
_array.kind_add(_array.kind.system()    ,'KASYM'  ,'');
:: dodanie rodzajow wdrozeniowych - zmiana zachowania
exec('PX_TEX_Kinds','px_prepq',_array);
:: wylaczamy mozliwosc dodawania rodzajow technologii
_array.kind_add:="0";

:: przydatne przy obsudze regul w przepisach
:: teksty
_array.rules:=obj_new('tex','tex_tex','tex_own');
_array.rules.tex:=exec('px_rule_tex','px_param');
_array.rules.tex_tex:=exec('px_rule_tex_tex','px_param');
_array.rules.tex_own:=exec('px_rule_tex_own','px_param');
:: wskazania
_array.Rules:=obj_new('tex_tex','tex_own');
_array.Rules.tex_tex:=exec('get_px_rule_ref','px_param',_array.rules.tex,_array.rules.tex_tex);
_array.Rules.tex_own:=exec('get_px_rule_ref','px_param',_array.rules.tex,_array.rules.tex_own);

:: jezeli mamy powolac do zmiennej globalnej to przypisujemy
{? {?_>0 & type_of(_a)=1 || _a || 1 ?}
|| {? var_pres('PXoTEX')>100 || obj_del('PXoTEX') ?};
   PXoTEX:=_array
?};
_array


\PX_TEX_prefix
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Ustawia prefix na PX_TEX dla podanego zestawu parametrów
::   WE: _a - co to bedzie
::       _b - wartość prefiksu
::   WY: --
::----------------------------------------------------------------------------------------------------------------------
_coto:={? _>0 & type_of(_a)=2  || _a || '' ?};
_what:={? _>1 & type_of(_b)>-1 || _b || ~~ ?};
exec('PXoTEX_chk','px_tex');
PXoTEX.prefix(_coto,_what);
~~


\Load_Px_Kont_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tablica parametrow dla Load_Px_Kont
::   WE: --
::   WY: tablica parametrow
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PxTex','Version','KontKind');
:: obiekt w ktorym jest Grid do ktorego ladujemy kontenery - domyslnie PxTex jezeli jest
_args.PxTex:={? var_pres('PxTex')>100 || PxTex || ~~ ?};
:: wersja dla ktorej ladujemy kontenery - domyslnie glowna
_args.Version:=exec('get_mainversion','px_ver');
:: rodzaj kontenera do zaladowania - domyslnie [R]zeczywisty
_args.KontKind:='R';
:: zwracamy tablice parametrow
_args


\Load_Px_Kont
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Laduje liste kontenerow do obiektu
::   WE: _a - _args
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
_args:={? _=1 || _a || exec('Load_Px_Kont_a','px_tex') ?};
{? type_of(_args.PxTex)<100 || FUN.wdrerror('Błędny typ argumentu .object w Load_Px_Kont/px_tex.'); return(0) ?};

:: tablica zmiennych lokalnych
_loc:=obj_new('Grid','GKind_n','GKind_e','GridNdx','MaxKontD','Etap','EtapNdx','add');
:: Tabela do ktorej wrzucimy kontenery
_loc.Grid:=_args.PxTex.GridTab;
:: Rodzaj jaki bedzie mial kontener normalny
_loc.GKind_n:='N';
:: Rodzaj jaki bedzie mial kontener nieskonczony
_loc.GKind_e:='E';
:: maksymalny wymiar kontenera
_loc.MaxKontD:=0;
:: Tabela etapow do ktorej wrzucimy kontenery
_loc.Etap:=_args.PxTex.EtapTab;

PX_KONT.cntx_psh();
PX_KONT.index('SYM');
PX_KONT.prefix(_args.Version);
{? PX_KONT.first()
||
   _loc.GridNdx:=_loc.Grid.ndx_tmp(,
                                  ,'KIND',,
                                  ,'TAB_NAM',,
                                  ,'TAB_REF',,
                                  );
   _loc.EtapNdx:=_loc.Etap.ndx_tmp(,
                                  ,'KIND',,
                                  ,'TAB_NAM',,
                                  ,'TAB_REF',,
                                  );

  _loc.add:=" _tab:=_a;
              _ndx:=_b;
              _tab.index(_ndx);
              _tab.clear();
              {!
              |? {? ~_tab.find_key({? PX_KONT.ENDLESS || .GKind_e || .GKind_n ?},PX_KONT.name(),#PX_KONT.ref())
                 || _tab.blank();
                    _tab.KONT_N:=PX_KONT.NAZWA+' ('+PX_KONT.SYMBOL+')';
                    _tab.KIND:={? PX_KONT.ENDLESS || .GKind_e || .GKind_n ?};
                    _tab.ICON:={? PX_KONT.PL_RES<>null()
                               || 'xwin16.png:'+$exec('ikona_res','po_plan',PX_KONT.PL_RES().TYP)
                               || ''
                               ?};
                    _tab.TAB_NAM:=PX_KONT.name();
                    _tab.TAB_REF:=#PX_KONT.ref();
                    _tab.USED:='N';
                    _tab.A:=PX_KONT.A;
                    {? PX_KONT.IL_WYM>.MaxKontD || .MaxKontD:=PX_KONT.IL_WYM ?};
                    _tab.add()
                 ?};
                 PX_KONT.next()
              !};
              ~~
            ";
   _loc.Grid.cntx_psh();
   _loc.add(_loc.Grid,_loc.GridNdx);
   _loc.Grid.cntx_pop();
   PX_KONT.first();
   _loc.Etap.cntx_psh();
   _loc.add(_loc.Etap,_loc.EtapNdx);
   _loc.Etap.cntx_pop();
   _loc.Grid.ndx_drop(_loc.GridNdx);
   _loc.Etap.ndx_drop(_loc.EtapNdx);
   _args.PxTex.MaxKontD:=_loc.MaxKontD;
   ~~
?};
exec('PxTexGridZakres','px_tex',_args.PxTex,0);
PX_KONT.cntx_pop();
1


\PxTexCFunTabL
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Laduje funkcje do .FunTab
::   WE: _a - wskazanie na PxTex
::   WY: --
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_add:="_a.LP:=_b; _a.NAM:=_c; _a.FUNID:=_d; _a.COLOR:=_e; _a.ICON:=_f; _a.add()";
_lp:=0;
{? _pxtex.ViewOnly=0
|| _add(_pxtex.FunTab, _lp+=1, 'Edycja'              ,'xFUN_ConnectionEdt'  ,',200:200:255','');
   _add(_pxtex.FunTab, _lp+=1, 'Powiązanie'          ,'xFUN_ConnectionAdd'  ,',200:255:200','');
   _add(_pxtex.FunTab, _lp+=1, 'Wstaw pusty etap'    ,'xFUN_EtapInsert'     ,',200:255:200','');
::   _add(_pxtex.FunTab, _lp+=1, 'Usuń powiązanie'     ,'xFUN_ConnectionDel'  ,',255:200:200','');
   ~~
?};
~~


\PxTexExeFunID_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tablica parametrow dla PxTexExeFunID i WYNIK !!! Decode_* !!!
::   WE: [_defaults] - [1] - wszystkie
::                      0  - typy proste
::                     -1  - brak
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_defaults:={?_>0 & type_of(_a)=1 || _a || 1 ?};
_args:=obj_new('PxTex','FunID','object');
{? _defaults>0
||
:: PxTex
   _args.PxTex:={? var_pres('PxTex')>0 || PxTex || ~~ ?};
   ~~
?};
{? _defaults>-1
||
:: Identyfikator funkcji do wykonania
   _args.FunID:='';
:: Wskazanie na zdekodowane wartosci src/dst
   _args.object:=~~;
   ~~
?};
:: zwracamy formule
_args


\PxTexExeFunID
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Obsluga tabeli funkcji
::   WE: _args - tablica parametrow - wynik formuly: exec('PxTexExeFunID_a','px_tex')
::----------------------------------------------------------------------------------------------------------------------
_args:={?_=1 || _a || exec('PxTexExeFunID_a','px_tex') ?};
:: tablica zmiennych lokalnych
_loc:=obj_new('dummy');
{? _args.FunID='xFUN_ConnectionEdt'
|| {? type_of(_args.object)>100
   || {? _args.object.PX_OPER<>null()
       & exec('PX_OPER_edit','px_oper',_args.object.PX_OPER,"PX_OPER.put(1)")
      || _args.PxTex.refresh()
      ?}
   ?}
|? _args.FunID='xFUN_ConnectionAdd'
|| {? type_of(_args.object)>100
   || {? _args.object.PX_OPER=null()
       & _args.object.PX_KONT<>null()
       & _args.object.PX_STAGE<>null()
      || PX_OPER.clear();
         PX_OPER.blank();
         PX_OPER.PX_KONT:=_args.object.PX_KONT;
         PX_OPER.PX_STAGE:=_args.object.PX_STAGE;

         {? PX_OPER.add(1)
         || _args.object.PX_OPER:=PX_OPER.ref();
            {? exec('PX_OPER_edit','px_oper',_args.object.PX_OPER,"exec('PX_OPER_put','px_oper')")
            || _args.PxTex.refresh()
            || exec('PX_OPER_del','px_oper',_args.object.PX_OPER)
            ?}
         ?}
      ?}
   ?}
|? _args.FunID='xFUN_EtapInsert'
|| {? type_of(_args.object)>100
   || _stagenr:={? _args.object.PX_STAGE<>null() || exec('FindAndGet','#table',PX_STAGE,#_args.object.PX_STAGE,,"NR",0)
                                                 || exec('GetLastNr','px_stage',_args.PxTex.RootRef)+1
                ?};
      {? exec('PX_STAGE_add','px_stage',_args.PxTex.RootRef,_stagenr)
      || _args.PxTex.refresh()
      ?}
   ?}

?};
~~


\PxTech_move
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przenosi Src do Dst
::   WE: _a - wskazanie na PxTex
::       _b - material zrodlowy
::       _c - material docelowy
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PxTex','Src','Dst');
_args.PxTex:=_a;
_args.Src:=_b;
_args.Dst:=_c;

_loc:=obj_new('JMsrc','JMdst');

{? _args.Dst.PX_STAGE<>null() & _args.Dst.PX_OPER=null()
||
:: wiemy gdzie przenosimy, ale pytanie... co przenosimy i skad?
   {? _args.Src.PX_OPER<>null()
   || {? _args.Src.PX_KONT<>_args.Dst.PX_KONT
      || _chkfml:="_sep:='```';_sep+JM1().KOD+_sep+JM2().KOD+_sep+JM3().KOD+_sep+JM4().KOD+_sep+JM5().KOD+_sep";
         _loc.JMsrc:=exec('FindAndGet','#table',PX_KONT,#_args.Src.PX_KONT,ref_name(_args.Src.PX_KONT),_chkfml,"~~");
         _loc.JMdst:=exec('FindAndGet','#table',PX_KONT,#_args.Dst.PX_KONT,ref_name(_args.Dst.PX_KONT),_chkfml,"~~");
         &_chkfml
      || _loc.JMsrc:=_loc.JMdst:=''
      ?};

      {? _args.Src.PX_STAGE=_args.Dst.PX_STAGE
       & _args.Src.PX_KONT<>_args.Dst.PX_KONT
      || 'przenosimy w pionie - miedzy kontenerami';
::       sprawdzamy czy takie same zestawy wymiarow
         {? _loc.JMsrc=_loc.JMdst
         || exec('FindAndGet','#table',PX_OPER,#_args.Src.PX_OPER,ref_name(_args.Src.PX_OPER)
                                  ,"PX_KONT:=_param.PX_KONT; put(1)","0",_args.Dst)
         ?};
         ~~
      |? _args.Src.PX_STAGE<>_args.Dst.PX_STAGE
       & _args.Src.PX_KONT=_args.Dst.PX_KONT
      || 'przenosimy w poziomie - miedzy operacjami';
         exec('FindAndGet','#table',PX_OPER,#_args.Src.PX_OPER,ref_name(_args.Src.PX_OPER)
                                  ,"PX_STAGE:=_params.PX_STAGE; put(1)"
                                  ,"0"
                                  ,_args.Dst
                                  )
      |? _args.Src.PX_STAGE<>_args.Dst.PX_STAGE
       & _args.Src.PX_KONT<>_args.Dst.PX_KONT
      || 'przenosiny po skosie';
         exec('FindAndGet','#table',PX_OPER,#_args.Src.PX_OPER,ref_name(_args.Src.PX_OPER)
                                  ,"PX_STAGE:=_params.PX_STAGE; PX_KONT:=_params.PX_KONT; put()"
                                  ,"0"
                                  ,_args.Dst
                                  )
      || 1
      ?}
::    jezeli puste, to znaczy, ze tworzymy nowy?
::   || msg('Dodajemy pozycję')
   ?}

:: |? _args.Dst.PX_STAGE=-200 & _args.Src.PX_STAGE<>null()
:: ||
:: kasowanie pozycji
::   msg('Kasowanie pozycji')

:: Nie ma czego i gdzie przenosic
::|| msg('Nie ma gdzie przenosic')
?};
~~


\PxTex_Refresh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Odswieza zawartosc tabel w PxTex
::   WE: _a - wskazanie na PxTex
::            wskazanie na elementy, ktore prawdopodobnie ulegly zmianie
::   WY: --
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PxTex');
_args.PxTex:=_a;

_px_oper:=exec('Load_Px_Oper_a','px_oper');
_px_oper.PxTex:=_args.PxTex;
_px_oper.TKTL:=_args.PxTex.TKTL;
_px_oper.PX_TEX:=_args.PxTex.PX_TEX;
_px_oper.ZL:=_args.PxTex.ZL;

_args.PxTex.GridTab.erase();
_args.PxTex.EtapTab.erase();
exec('Load_Px_Kont','px_tex');

_args.PxTex.OperTab.erase();
_args.PxTex.StageTab.erase();
exec('Load_Px_Oper','px_oper',_px_oper);

exec('reload_procesy','px_tex');

_args.PxTex.grp_disp();
~~


\f3_px_tex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Obsluga dla przycisku wyszukiwania technologii
::----------------------------------------------------------------------------------------------------------------------
_res:='';
PX_TEX.cntx_psh();
PX_TEX.seek(PX_VAR.ADD_TX);
PX_TEX.win_sel('SLO');
{? PX_TEX.select(,1)
|| PX_VAR.ADD_TX:=PX_TEX.ref();
   PX_GRP.PX_TEX:=PX_TEX.ref();
   win_disp();
   _res:=PX_TEX.SYMBOL
|| _res:=''
?};
PX_TEX.cntx_pop();
_res


\PxTexGridTabrek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przed rekord w GridTab w PxTex
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
~~


\PxTexGridZakres
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Zmiana zakresu dla GridTab w PxTex
::   WE: _a   - PxTex
::       [_b] - czy wyświetlać okno z edycją parametrów, czy tylko zapamiętać te
::----------------------------------------------------------------------------------------------------------------------
_PxTex:=_a;
_edit:=1;
{? var_pres('_b')=type_of(0)
|| _edit:=_b
?};

_tab:=tab_tmp(1,'USED','STRING[1]','Użycie'@,'A','STRING[1]','Aktywność'@);
_edt:=_tab.mk_edit('Zakres'@);
_tab.win_edit(_edt);
_tab.win_esep(_edt,'Parametry zakresu'@);
_tab.win_efld(_edt,,'USED',,,,,,,,,'radio-buttons',,
   'Wszystkie'@,"'W'",
   'Używane'@,"'T'",
   'Nieużywane'@,"'N'");
_tab.win_efld(_edt,,'A',,,,,,,,,'radio-buttons',,
   'Wszystkie'@,"'W'",
   'Aktywne'@,"'T'",
   'Nieaktywne'@,"'N'");
_tab.win_ebtn(_edt,'text='+'&Zapisz'@,'key:F2');
_tab.win_ebtn(_edt,'text='+'&Anuluj'@,'key:Esc');

_tab.A:=exec('get','#params',8065,type_of(''),OPERATOR.USER);
_tab.USED:=exec('get','#params',8066,type_of(''),OPERATOR.USER);

_can_continue:=1;
{? _edit>0
|| _can_continue:=_tab.edit()
?};
{? _can_continue>0
||
   exec('set','#params',8065,_tab.A,OPERATOR.USER);
   exec('set','#params',8066,_tab.USED,OPERATOR.USER);

   _PxTex.GridUsed:=_tab.USED;
   _PxTex.GridAkt:=_tab.A;

   {? _PxTex.GridUsed='W'  & _PxTex.GridAkt='W'  || _PxTex.GridTab.index(_PxTex.GridNd__);
                                                    _PxTex.GridTab.prefix()
   |? _PxTex.GridUsed='W'  & _PxTex.GridAkt<>'W' || _PxTex.GridTab.index(_PxTex.GridNdA_);
                                                    _PxTex.GridTab.prefix(_PxTex.GridAkt)

   |? _PxTex.GridUsed<>'W' & _PxTex.GridAkt='W'  || _PxTex.GridTab.index(_PxTex.GridNdU_);
                                                    _PxTex.GridTab.prefix(_PxTex.GridUsed)
   |? _PxTex.GridUsed<>'W' & _PxTex.GridAkt<>'W' || _PxTex.GridTab.index(_PxTex.GridNdAU);
                                                    _PxTex.GridTab.prefix(_PxTex.GridAkt,_PxTex.GridUsed)
   ?};

   _PxTex.GridTab.win_sel(_PxTex.GridSel);
   _PxTex.GridTab.hdr_sel();
   _PxTex.GridTab.hdr_sel(
      'Zakres widocznych zasobów: użycie — '+
      {? _PxTex.GridUsed='W' || 'wszystkie' |? _PxTex.GridUsed='T' || 'używane' || 'nieużywane' ?}+
      ' / aktywność — '+
      {? _PxTex.GridAkt='W' || 'wszystkie' |? _PxTex.GridAkt='T' || 'aktywne' || 'nieaktywne' ?}
   );
   ~~
?};
~~


\get_default_tex
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca domyslna technologie PX dla obiektu planistycznego
::   WE: _a - PX_OBJ.ref() - obiekt planistyczny
::       [_b] - co zwracac?
::            1 - pierwszy rekord z rankingu - domyslnie
::            2 - tabela _px_texy
::       [_c] - exec('px_texy_tab','px_tex') - tab_tmp - tabelka ktora ma zawierac ranking przepisow dla podanego PX_OBJ
::   WY: PX_TEX.ref()
::       lub
::       _px_texy:=exec('px_texy_tab','px_tex') - tab_tmp - tabelka zawierajaca ranking przepisow dla podanego PX_OBJ
::----------------------------------------------------------------------------------------------------------------------
_PX_OBJ:=_a;
_whkores:={? var_pres('_b')=1 || _b || 1 ?};
{? var_pres('_c')>100
|| _px_texy:=_c
|| _px_texy:=exec('px_texy_tab','px_tex')
?};

:: sprawdzam czy dostepny jest PXoTEX, jesli nie to powoluje
{? var_pres('PXoTEX')<100 || exec('PXoTEX','px_tex') ?};

PX_OBJ.cntx_psh(); PX_OBJ.clear();
{? PX_OBJ.seek(_PX_OBJ)
|| _nl:=1;
   {? PX_OBJ.KIND=exec('kind_zl_prod','px_obj')
   ||
::    Dla zlecen zawsze tworze ich wlasny przepis i inicjuje go
      exec('AutoPX4PX_OBJ','px_auto',PX_OBJ.ref());
      _nl*=2; exec('PX_TEX_list4','px_tex',PX_OBJ.ZL      ,'T',_px_texy,_nl,exec('level_zl','px_tex'));
      _nl*=2; exec('PX_TEX_list4','px_tex',PX_OBJ.M       ,'T',_px_texy,_nl,exec('level_material','px_tex'));
      _nl*=2; exec('PX_TEX_list4','px_tex',PX_OBJ.M().MGR ,'T',_px_texy,_nl,exec('level_mgrp','px_tex'));
      1

   |? PX_OBJ.KIND=exec('kind_zam_poz','px_obj') | PX_OBJ.KIND=exec('kind_plan_sprze','px_obj')
   ||
      _nl*=2; exec('PX_TEX_list4','px_tex',PX_OBJ.M       ,'T',_px_texy,_nl,exec('level_material','px_tex'));
      _nl*=2; exec('PX_TEX_list4','px_tex',PX_OBJ.M().MGR ,'T',_px_texy,_nl,exec('level_mgrp','px_tex'));
      1

   |? PX_OBJ.KIND=exec('kind_proj_zad','px_obj')
   ||
      _nl*=2; exec('PX_TEX_list4','px_tex',PX_OBJ.ZL      ,'T',_px_texy,_nl,exec('level_zl','px_tex'));
      1

   |? PX_OBJ.KIND=exec('kind_zl_warszt','px_obj')
   ||
::    Dla zlecen zawsze tworze ich wlasny przepis i inicjuje go
      exec('AutoPX4PX_OBJ','px_auto',PX_OBJ.ref());
      _nl*=2; exec('PX_TEX_list4','px_tex',PX_OBJ.ZL      ,'T',_px_texy,_nl,exec('level_zl','px_tex'));
      _nl*=2; exec('PX_TEX_list4','px_tex',PX_OBJ.ZL().TYP,'T',_px_texy,_nl,exec('level_zl','px_tex'));
      1

   ?};
   _nl*=2; exec('PX_TEX_list4','px_tex',PXoTEX.kind.system(),'T',_px_texy,_nl,exec('level_universal','px_tex'))
?};
PX_OBJ.cntx_pop();

_px_texy.index(_px_texy.ndx_tmp(,
                               ,'LEVEL',,
                               ,'PX_TEXN',,
                               ,'PX_TEXR',,
                               ,'PX_TEXQ',,
                               )
              );
{? _whkores=1
||
   _result:=null();
   PX_TEX.cntx_psh();
   PX_TEX.clear();
   {? _px_texy.first()
    & PX_TEX.seek(_px_texy.PX_TEXR, _px_texy.PX_TEXN)
   || _result:=PX_TEX.ref()
   ?};
   PX_TEX.cntx_pop();
   _result

|? _whkores=2
|| _px_texy
?}


\PX_TEX_blank
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_PXoTEX:={? var_pres('PXoTEX')<100 || exec('PXoTEX','px_tex') || PXoTEX ?};
{? _fld='SYMBOL'  || ''
|? _fld='AKT'     || 'T'
|? _fld='TKTL'    || null()
|? _fld='KIND'    || _PXoTEX.KIND
|? _fld='M'       || {? _PXoTEX.KIND=_PXoTEX.kind.table('M')   || _PXoTEX.PrfxVal || null() ?}
|? _fld='MGR'     || {? _PXoTEX.KIND=_PXoTEX.kind.table('MGR') || _PXoTEX.PrfxVal || null() ?}
|? _fld='ZTP'     || {? _PXoTEX.KIND=_PXoTEX.kind.table('ZTP') || _PXoTEX.PrfxVal || null() ?}
|? _fld='ZL'      || {? _PXoTEX.KIND=_PXoTEX.kind.auto('ZL')   || _PXoTEX.PrfxVal || null() ?}
|? _fld='PX_RULES'|| exec('get_px_rule_ref','px_param',exec('px_rule_tex','px_param'),exec('px_rule_tex_tex','px_param'))
|? _fld='XJM'     || 1
                  || ~~
?}


\PX_TEX_bD
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS:
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
{? _fld='SYMBOL'  || ''
|? _fld='AKT'     || 'N'
|? _fld='TKTL'    || null()
|? _fld='KIND'    || ''
|? _fld='M'       || null()
|? _fld='MGR'     || null()
|? _fld='ZTP'     || null()
|? _fld='PX_RULES'|| ''
|? _fld='XJM'     || ''
                  || ~~
?};
1


\PX_TEX_bFE
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przed redakcja pol PX_TEX
::   WE: [_a] - STRING - akronim pola ktore badac
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_fld:='';
{? var_pres('_a')=type_of('')
|| _fld:=_a
|| _fld:=cur_afld()
?};

{? _fld='SYMBOL'  || fld(form(fld())); 1+fld()<>'~'
|? _fld='VER'     || 1
|? _fld='AKT'     || 0
|? _fld='TKTL'    || {? cur_tab(1,1).PX_RULES().SYMBOL=exec('px_rule_tex_tex','px_param')
                     || exec('FilterTKTL','px_tex')
                     || fld(null());
                        0
                     ?}
|? _fld='KIND'    || ''
|? _fld='M'       || 1
|? _fld='MGR'     || 1
|? _fld='ZTP'     || 0
|? _fld='PX_RULES'|| PX_VAR.RULE_TYP:=exec('px_rule_tex','px_param');
                     {? PX_VAR.STRING='R|'+exec('px_rule_tex_tex','px_param') || 0 || 1 ?}
|? _fld='XJM'     || {? cur_tab(1,1).PX_RULES().SYMBOL=exec('px_rule_tex_tex','px_param')
                     || 0
                     || 1
                     ?}
|| 0
?}


\PX_TEX_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Obluga na F3 dla pol w tabeli PX_TEX
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
{? _fld='SYMBOL'  || _txt:='';
                     {? fld()=''
                     || _txt:=exec('gen_px_tex_sym','px_tex');
                        {? +_txt || fld(_txt); set_cpos((+_txt)+1) ?}
                     ?};
                     0
|? _fld='AKT'     || 0
|? _fld='TKTL'    || 0
|? _fld='KIND'    || 0
|? _fld='M'       || 0
|? _fld='MGR'     || 0
|? _fld='ZTP'     || 0
|? _fld='PX_RULES'|| 0
|? _fld='XJM'     || 0
                  || ~~
?}


\PX_TEX_aFE
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Po redakcji pól PX_TEX
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_res:=1;

{? _fld='SYMBOL'  || fld(form(fld()));
                     {? 1+fld()='~'
                     || FUN.info('Symbol przepisu nie może zaczynać się od znaku tyldy (~).'@);
                        _res:=0
                     || {? PX_TEX.VER=''
                        || PX_TEX.VER:=exec('get_ver_nxt','px_tex',fld())
                        ?}
                     ?}
|? _fld='VER'     || {? fld()=''
                     || FUN.emsg('Symbol wersji nie może być pusty.'@);
                        _res:=0
                     ?}
|? _fld='AKT'     || _res:=0
|? _fld='TKTL'    || {? fld()<>null()
                     || PX_STAGE.index('TKTL_NR');
                        PX_STAGE.prefix($fld());
                        {? ~PX_STAGE.first()
                        || FUN.emsg('Wybrana technologia nie ma zbudowanego przepisu planistycznego.'@)
                        ?};
                        cur_tab(1,1).XJM:=cur_tab(1,1).TKTL().XJM
                     ?};
                     {? TKTL.f_active() || TKTL.f_clear(0) ?}
|? _fld='KIND'    || _res:=0
|? _fld='M'       || {? fld()=null()
                     || FUN.info('Należy wybrać materiał.'@);
                        _res:=0
                     |? 'WP'*cur_tab(1,1).M().R
                     || {? PX_TEX.SYMBOL=''
                        || PX_TEX.SYMBOL:=exec('gen_px_tex_sym','px_tex')
                        ?}
                     || FUN.info('Należy wybrać półprodukt lub wyrób.'@);
                        _res:=0
                     ?}
|? _fld='MGR'     || {? fld()=null()
                     || FUN.info('Należy wybrać grupę.'@);
                        _res:=0
                     || {? PX_TEX.SYMBOL=''
                        || PX_TEX.SYMBOL:=exec('gen_px_tex_sym','px_tex')
                        ?}
                     ?}
|? _fld='ZTP'     || null()
|? _fld='PX_RULES'|| 1
|? _fld='XJM'     || {? fld()<=0
                     || FUN.emsg('Należy podać ilość większą od zera.'@);
                        _res:=0
                     ?}
                  || ~~
?};

{? _res
|| exec('efld_opt','px_tex')
?};

_res


\PX_TEX_fD
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Format wyświetlania pól PX_TEX
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();

_res:='';

{? _fld='XJM'
|| {? PX_TEX.KIND=PXoTEX.kind.table('M')
   || _res:='out_prec='+$PX_TEX.M().DOKL
   |? PX_TEX.KIND=PXoTEX.kind.table('MGR')
   || _res:='out_prec='+$PX_TEX.MGR().DOKL
   || _res:='out_prec='+$ST.DOKL
   ?}
?};

_res


\PX_TEX_fE
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Format redagowania pól PX_TEX
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();

_res:='';

{? _fld='XJM'
|| {? PX_TEX.KIND=PXoTEX.kind.table('M')
   || _res:='in_prec='+$PX_TEX.M().DOKL
   |? PX_TEX.KIND=PXoTEX.kind.table('MGR')
   || _res:='in_prec='+$PX_TEX.MGR().DOKL
   || _res:='in_prec='+$ST.DOKL
   ?}
?};

_res


\efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Opcje pól w oknach redagowania PX_TEX
::----------------------------------------------------------------------------------------------------------------------
{? PX_TEX.PX_RULES().SYMBOL=exec('px_rule_tex_tex','px_param')
|| _mark:=1; _enable:=1
|| _mark:=0; _enable:=0
?};
PX_TEX.efld_opt('RED','mark='+$_mark+',enable='+$_enable,,'TKTL');
PX_TEX.efld_opt('RED_M','mark='+$_mark+',enable='+$_enable,,'TKTL');
PX_TEX.efld_opt('RED_MGR','mark='+$_mark+',enable='+$_enable,,'TKTL');
~~


\PX_TEX_WER_br
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Obsluga przed rekord w tabeli PX_TEX
::----------------------------------------------------------------------------------------------------------------------
:: Ustawiam pola zmiennych wyświetlanych w niektórych oknach wertowania:
:: PX_TEX: SEL
PX_VAR.STRING:='';
VAR.STRING:='';
{? var_pres('pxtexy')>100
|| pxtexy.prefix(ref_name(PX_TEX.ref()),#PX_TEX.ref());
   {? pxtexy.first()
   || PX_VAR.STRING:=$pxtexy.LEVEL;
      VAR.STRING:=pxtexy.LEV_NAME
   ?}
?};
~~


\PX_TEX_WER_bGs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Podglad w okienku PX_TEX.WER
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------

:: Robie cntx_psh wszystkich tabel technologicznych, bo bede zmienial maski
exec('tktl_cntx_psh','tech_common');

_argsel:=exec('Select_PxTex_a','px_tex');
{? PX_TEX.PX_RULES().SYMBOL=exec('px_rule_tex_tex','px_param')
|| _argsel.EditView:='view';

   {? PX_TEX.TKTL<>null()
   || _argsel.TKTL:=PX_TEX.TKTL
   ||
::    Wymyslam maske na podstawie pola z sql_refem
      _msk:=form((8+PX_TEX.RTKTL)+3);

::    Otwieram maske technologii
      exec('tktl_use','tech_common',_msk);

      _argsel.TKTL:=exec('FindAndGet','#table',TKTL,PX_TEX.RTKTL,,,null())
   ?};

   {? PX_TEX.M<>null() || _argsel.M:=PX_TEX.M ?};
   {? PX_TEX.ZL<>null() || _argsel.ZL:=PX_TEX.ZL ?};
   exec('Select_PxTex','px_tex',_argsel)

|? PX_TEX.PX_RULES().SYMBOL=exec('px_rule_tex_own','px_param')
|| _argsel.EditView:='view';
   _argsel.PX_TEX:=PX_TEX.ref();
   exec('Select_PxTex','px_tex',_argsel)

|| FUN.info('Przepis nie jest generowany na podstawie technologii.'@)
?};

:: Przywracam kontekst wszystkim tabelom technologicznym
exec('tktl_cntx_pop','tech_common');
~~


\PX_TEX_WER_bE
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Edycja w okienku PX_TEX.WER
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_argsel:=exec('Select_PxTex_a','px_tex');

_can_continue:=1;

:: Robie cntx_psh wszystkich tabel technologicznych, bo bede zmienial maski
exec('tktl_cntx_psh','tech_common');

{? PX_TEX.PX_RULES().SYMBOL=exec('px_rule_tex_tex','px_param')
|| _argsel.EditView:='edit';
   {? PX_TEX.TKTL<>null()
   || _argsel.TKTL:=PX_TEX.TKTL
   ||
::    Wymyslam maske na podstawie pola z sql_refem
      _msk:=form((8+PX_TEX.RTKTL)+3);

::    Otwieram maske technologii
      exec('tktl_use','tech_common',_msk);

      _argsel.TKTL:=exec('FindAndGet','#table',TKTL,PX_TEX.RTKTL,,,null())
   ?};

   {? PX_TEX.ZL<>null()
   || _msg:='Przepisy zleceń powstają automatycznie. \n\n'@;
      _msg+='Edycja nie jest możliwa.'@;
      FUN.info(_msg);
      _can_continue:=0
   ?};

   {? _can_continue>0
   || _what:=PX_TEX.TKTL().NRK+' (wersja: '+TKTL.WER+')';
      {? PX_TEX.TKTL().STAN='T' & exec('get','#params',8050,2,OPERATOR.USER)='N'
      || FUN.info('Technologia źródłowa: %1 jest całkowicie zatwierdzona.\n\n'
                  'Edycja nie jest możliwa.'@[_what]
         );
         _can_continue:=0
      || {? PX_TEX.TKTL().STAN='P'
         || FUN.info('Technologia źródłowa: %1 jest częściowo zatwierdzona.\n\n'
                     'Uwaga: zmodyfikowany przepis może się różnić od źródłowego.'@[_what]
            )
         |? PX_TEX.TKTL().STAN='T'
         || FUN.info('Technologia źródłowa: %1 jest całkowicie zatwierdzona.\n\n'
                     'Uwaga: zmodyfikowany przepis może się różnić od źródłowego.'@[_what]
            )
         ?};
         {? PX_TEX.M<>null() || _argsel.M:=PX_TEX.M ?}
      ?}
   ?};

   {? _can_continue>0
   || _mainver:=exec('get_mainversion','px_ver');
      {? exec('used_in_queue','px_tex',PX_TEX.ref(),_mainver)>0
      || _msg:='Przepis jest używany w głównej wersji planu\n\n'@;
         _msg+='Jego modyfikacja może wpłynąć na plan podczas następnego przeliczenia.'@;
         FUN.info(_msg)
      ?}
   ?};

   {? _can_continue>0
   || exec('Select_PxTex','px_tex',_argsel)
   ?}
|? PX_TEX.PX_RULES().SYMBOL=exec('px_rule_tex_own','px_param')
|| _argsel.EditView:='edit';
   _argsel.PX_TEX:=PX_TEX.ref();

   {? PX_TEX.ZL<>null()
   || _msg:='Przepis zlecenia powstaje automatycznie.\n\n'@;
      _msg+='Edycja nie jest możliwa.'@;
      FUN.info(_msg);
      _can_continue:=0
   ?};

   {? _can_continue>0
   || _mainver:=exec('get_mainversion','px_ver');
      {? exec('used_in_queue','px_tex',PX_TEX.ref(),_mainver)>0
      || _msg:='Przepis jest używany w głównej wersji planu\n\n'@;
         _msg+='Jego modyfikacja może wpłynąć na plan podczas następnego przeliczenia.'@;
         FUN.info(_msg)
      ?}
   ?};

   {? _can_continue>0
   || exec('Select_PxTex','px_tex',_argsel)
   ?}
|| FUN.info('Przepis nie jest generowany na podstawie technologii.'@)
?};
:: Przywracam kontekst wszystkim tabelom technologicznym
exec('tktl_cntx_pop','tech_common');

{? exec('is_px_set','px_param')>0
||
:: Zestawy startowe na obiektach mogly zostac zaktualizowane wiec odswiezem zakladke
:: obiekty do kolejki
   {? var_pres('PxSelect')>100
   || {? PX_OBJ.f_active()>0
      || PX_OBJ.f_rfresh()
      ?};
      grp_disp(PX_OBJ,'WER')
   ?}
?}


\PX_TEX_WER_bAs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Aktywacja/dezaktywacja PX_TEXa
::   WE: _a - INTEGER - 0/[1] - dezaktywować, czy aktywować
::----------------------------------------------------------------------------------------------------------------------
_activate:=1;
{? var_pres('_a')=type_of(0)
|| _activate:=_a
?};

_group:=0;
{? PX_TEX.sel_size()>0
|| _group:=1
?};

:: tutaj kontrola, czy PX_TEX moze byc aktywowany lub dezaktywowany
_powod:='';
_stan_old:='<nieznany>';
_stan_new:='<nieznany>';


{? _activate>0
|| _stan_old:='Nieaktywny';
   _stan_new:='Aktywny'
||
   _stan_old:='Aktywny';
   _stan_new:='Nieaktywny'
?};
_ask:=1;
{? _group=0
|| _ask:=FUN.ask('Czy zmienić stan przepisu z \'%1\' na \'%2\'?'@[_stan_old,_stan_new])
?};
_ok:=1;
{? _ask>0
||
   _ok:={? _activate>0
        || _powod:=exec('canbe_active','px_tex',PX_TEX.ref());
           _powod=''
        || _powod:=exec('canbe_inactive','px_tex',PX_TEX.ref());
           _powod=''
        ?}
?};
:: teraz faktyczna zmiana



{? _ok>0
|| {? _ask>0
   ||
      PX_TEX.AKT:={? PX_TEX.AKT='T' || 'N' || 'T' ?};
      PX_TEX.cntx_psh();
      PX_TEX.clear();
      PX_TEX.put();

      {? exec('get','#params',500366,2)=exec('kind_pxtex','px_set')
      ||
         {? PX_TEX.AKT='N'
         ||
::          Jesli przepis stal sie nieaktywny to trzeba usunac powiazanie z obiektami
::          oraz odswiezyc zestawy startowe na obiektach ktore do tej pory uzywaly tego przepisu jako domyslnego
            exec('clean_obj','px_tex',PX_TEX.ref(),1)

         |? PX_TEX.AKT='T' & exec('is_px_set','px_param')>0
         ||
::          Jesli przepis stal sie aktywny to wyswietlam komunikat o potrzebie aktualizacji
::          obiektow planistycznych dla ktorych aktywowany przepis moze stac sie domyslnym przepisem
::          i moze zmienic zestaw startowy na obiekcie
            _msg:='Po aktywacji przepisu: %1 (wersja: %2)zalecane jest uruchomienie aktualizacji obiektów planistycznych\n'
                  'ponieważ mogą zmienić się zestawy startowe na obiektach do kolejki.'@[PX_TEX.SYMBOL,PX_TEX.VER];
            {? _group>0
            || KOMM.add(_msg,7,,1)
            || FUN.info(_msg)
            ?}
         ?}
      ?};
      PX_TEX.cntx_pop()
   ?}
|? _ok=0
|| _msg:='Zmiana stanu przepisu: %1 (wersja: %2) nie jest możliwa.'@[PX_TEX.SYMBOL,PX_TEX.VER];
   {? _powod<>''
   || {? _group>0
      || _msg+=' Powód: %1'@[_powod]
      || _msg+='\nPowód: %1'@[_powod]
      ?}
   ?};
   {? _group>0
   || KOMM.add(_msg,2)
   || FUN.emsg(_msg)
   ?}
?};

{? exec('is_px_set','px_param')>0
||
:: Zestawy startowe na obiektach mogly zostac zaktualizowane wiec odswiezem zakladke
:: obiekty do kolejki
   {? var_pres('PxSelect')>100
   || {? PX_OBJ.f_active()>0
      || PX_OBJ.f_rfresh()
      ?};
      grp_disp(PX_OBJ,'WER')
   ?}
?}


\canbe_active
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Sprawdza czy podany przepis moze byc aktywowany
::   WE: PX_TEX.ref()
::   WY: '' - moze byc aktywowany, <>'' - komunikat dlaczego nie moze
::----------------------------------------------------------------------------------------------------------------------
_PX_TEX:=_a;
_result:='';
PX_TEX.cntx_psh();
PX_TEX.clear();
{? PX_TEX.seek(_PX_TEX)
||
   {? PX_TEX.AKT='T'
   || _result:='Przepis jest już aktywny\n'
   ?};

:: sprawdzamy czy jest technologia
   {? PX_TEX.PX_RULES().SYMBOL=exec('px_rule_tex_tex','px_param')
    & PX_TEX.TKTL=null()
   || _result+='Nie podano technologii dla reguły: '+exec('px_rule_tex_tex','px_param')+'\n';
      0

   |? PX_TEX.PX_RULES().SYMBOL=exec('px_rule_tex_own','px_param')
   || PX_STAGE.cntx_psh();
      PX_STAGE.index('TEX_NR');
      PX_STAGE.prefix(PX_TEX.ref());
      {? PX_STAGE.first()
      || _oper_num:=0;
         PX_OPER.cntx_psh();
         PX_OPER.index('UNIQALL');
         {!
         |? PX_OPER.prefix(PX_STAGE.ref());
            {? PX_OPER.first()
            || _oper_num+=PX_OPER.size()
            ?};
            PX_STAGE.next()
         !};
         PX_OPER.cntx_pop();
         {? _oper_num=0
         || _result+='Przepis nie zawiera odnośników do zasobów planistycznych\n'
         ?}
      || _result+='Przepis nie zawiera zdefiniowanych etapów\n'
      ?};
      PX_STAGE.cntx_pop()
   ?}
?};
PX_TEX.cntx_pop();
_result


\canbe_inactive
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Sprawdza czy podany przepis moze byc dezaktywowany
::   WE: PX_TEX.ref()
::   WY: '' - moze byc dezaktywowany, <>'' - komunikat dlaczego nie moze
::----------------------------------------------------------------------------------------------------------------------
_PX_TEX:=_a;
_result:='';
PX_TEX.cntx_psh();
PX_TEX.clear();
{? PX_TEX.seek(_PX_TEX)
||
   {? PX_TEX.AKT='N'
   || _result:='Przepis jest już nieaktywny\n'
   ?}
?};
PX_TEX.cntx_pop();
_result


\FilterTKTL
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Filtruje TKTL w sposob 'zjadliwy' dla aktualnego rekordu PX_TEX
::   WE: [_a] - INTEGER - 0/[1] - brać pod uwagę materiał i grupę materiałową czy nie
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_fmat:=1;
{? var_pres('_a')=type_of(0)
|| _fmat:=_a
?};

PX_TEX.cntx_psh();
_join:=''+"
            left outer join TPKTL using(TKTL.TYP,TPKTL.REFERENCE)
            left outer join TKTLW using(TKTLW.TKTL,TKTL.REFERENCE)
            left outer join M using(TKTLW.KTM,M.REFERENCE)
            join PX_STAGE using(PX_STAGE.TKTL,TKTL.REFERENCE)
          ";
_where:=''+"TKTL.ARCH='N' and TKTL.STAN='T' and TKTL.TORW='T' and TPKTL.CZAPLA='T'";

{? _fmat>0
|| {? PX_TEX.M<>null()   || _join+=""; _where+=" and M.REFERENCE=:_a"; 1 ?};
   {? PX_TEX.MGR<>null() || _join+=""; _where+=" and M.MGR=:_b"; 1       ?}
?};

_fset:=TKTL.f_set('NRK,WER',_join,_where,PX_TEX.M,PX_TEX.MGR);
PX_TEX.cntx_pop();
_fset


\PX_TEX_WER_bD
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Dolacz w okienkach wertowania PX_TEX
::----------------------------------------------------------------------------------------------------------------------
M.cntx_psh();

TKTL.win_dict('SLO');
TKTL.actions('SLO','W');

PX_TEX.blank();
{? PX_TEX.edit("exec('PX_TEX_WER_ar','px_tex')")
|| PX_TEX.add()
?};
TKTL.actions('SLO');
M.cntx_pop();
0


\PX_TEX_WER_bP
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Popraw w okienkach wertowania PX_TEX
::----------------------------------------------------------------------------------------------------------------------
{? PX_TEX.KIND=PXoTEX.kind.table('ZL') | PX_TEX.KIND=PXoTEX.kind.auto('ZL')
|| FUN.info('Przepis zlecenia — nie można modyfikować.'@);
   return(0)
?};

M.cntx_psh();
_lock_res:=exec('lock','px_tex');
{? _lock_res.LOCKED>0
||
   exec('efld_opt','px_tex');

   _xjm_bef:=PX_TEX.XJM;
   TKTL.win_dict('SLO');
   TKTL.actions('SLO','W');
   {? PX_TEX.get()
    & PX_TEX.edit("exec('PX_TEX_WER_ar','px_tex')")
   || PX_TEX.put()
   ?};
   TKTL.actions('SLO');

   _xjm_aft:=PX_TEX.XJM;
   {? _xjm_bef<>_xjm_aft
   || _choice:=FUN.ask(
         'Krotność jednostki miary (Ilość) zmieniła się.\nCzy przeliczyć zużycia na operacjach?'@);
      {? _choice>0
      || exec('recalculate_use','px_tex',PX_TEX.ref(),_xjm_aft/_xjm_bef)
      ?}
   ?}
?};
exec('unlock','px_tex',_lock_res);
M.cntx_pop();
0


\delete_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja w oknie - usunięcie rekordu
::   WE: [_a] - INTEGER - 0/[1] - czy wyświetlać dialogi
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRIVATE><AKCJA><DEL>
::----------------------------------------------------------------------------------------------------------------------
_dialog:=1;
{? var_pres('_a')=type_of(0)
|| _dialog:=_a
?};

_result:=0;
_can_continue:=1;

_tab:=cur_tab(1,1);

_group:=0;
{? _tab.sel_size()>0
|| _group:=1;
   _dialog:=0
?};
_lock_res:=exec('lock','px_tex');
{? _lock_res.LOCKED>0
||
:: Sprawdzam czy można usunąć
   {? _group>0
   || _can_continue:=exec('can_delete','px_tex',,2)
   || _can_continue:=exec('can_delete','px_tex',,1)
   ?};
   _tab.get();
   {? _dialog>0 & _can_continue>0
   || _can_continue:=FUN.ask('Czy usunąć przepis %1?'@[exec('PX_TEX','#to_string',_tab.ref())])
   ?};
   {? _can_continue>0
   || _result:=exec('PX_TEX_delete','px_tex',_tab.ref())
   ?}
?};
exec('unlock','px_tex',_lock_res);
_result


\delete_act_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja usuń grupa przed w oknie wertowania tabeli PX_TEX
::   WY: 0 - porazka
::       1 - sukces
::  TAG: <PRIVATE><AKCJA><GRUPA><DEL>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_tab:=cur_tab(1,1);
{? FUN.ask('Zaznaczono: %1 przepisów. Czy usunąć je wszystkie?'@[$_tab.sel_size()])
|| _result:=1;
   sel_nchk();
   KOMM.init(250,,'Usuwanie przepisów planistycznych'@,'')
?};
_result


\delete_act_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja usuń grupa po w oknie wertowania tabeli PX_TEX
::  TAG: <PRIVATE><AKCJA><GRUPA><DEL>
::----------------------------------------------------------------------------------------------------------------------
KOMM.select(,,,,,0);
~~


\can_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy można usunąć dany przepis planistyczny
::   WE: [_a] - PX_TEX.ref lub bieżący rekord
::       [_b] - INTEGER - czy wyswietlac komunikaty:  0  - nie
::                                                   [1] - wyskakujący komunikat
::                                                    2  - w KOMM
::   WY: 0 - nie można usunąć, można usunąć
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_TEX.ref())
|| _ref:=_a
?};

_display:=1;
{? var_pres('_b')=type_of(0)
|| _display:=_b
?};

_result:=0;
_can_continue:=1;

PX_TEX.cntx_psh();
{? _ref<>null()
|| PX_TEX.prefix();
   {? PX_TEX.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? 1+PX_TEX.SYMBOL='~'
   || _can_continue:=0;
      _msg:='Nie można usunąć przepisu systemowego: %1'@[exec('PX_TEX','#to_string',PX_TEX.ref)];
      {? _display=2
      || KOMM.add(_msg,2,,1)
      |? _display=1
      || FUN.emsg(_msg)
      ?}
   ?};
   {? _can_continue>0
   || {? PX_TEX.AKT='T'
      || _can_continue:=0;
         _msg:='Nie można usunąć aktywnego przepisu planistycznego: %1'@[exec('PX_TEX','#to_string',PX_TEX.ref())];
         {? _display=2
         || KOMM.add(_msg,2,,1)
         |? _display=1
         || FUN.emsg(_msg)
         ?}
      ?}
   ?};
   {? _can_continue>0
   || {? PX_TEX.KIND=PXoTEX.kind.table('ZL') & PX_TEX.KIND=PXoTEX.kind.auto('ZL')
      || _can_continue:=0;
         _msg:='Nie można usunąć przepisu należącego do zlecenia: %1'@[exec('PX_TEX','#to_string',PX_TEX.ref())];
         {? _display=2
         || KOMM.add(_msg,2,,1)
         |? _display=1
         || FUN.emsg(_msg)
         ?}
      ?}
   ?}
?};
PX_TEX.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\PX_TEX_WER_ar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Po rekord PX_TEX
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=~~;
{? PX_TEX.SYMBOL=''
|| FUN.info('Należy podać symbol.'@);
   _result:='SYMBOL'
|? PX_TEX.VER=''
|| FUN.info('Należy podać symbol wersji.'@);
   _result:='VER'
|? PX_TEX.PX_RULES=null()
|| FUN.info('Należy podać metodę generowania przepisu dla algorytmu planowania.'@);
   _result:='PX_RULES'
|? PX_TEX.PX_RULES().SYMBOL=exec('px_rule_tex_tex','px_param') & PX_TEX.TKTL=null()
|| FUN.info('Należy wybrać technologię dla algorytmu planowania.'@);
   _result:='TKTL'
|? PX_TEX.XJM=0
|| FUN.info('Ilość nie może być zerowa.'@);
   {? exec('PX_TEX_bFE','px_tex','XJM')>0
   || _result:='XJM'
   ?}
?};
_result


\px_texy_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Definiuje tabele _px_texy
::   WY: tabela
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(2
             ,'PX_TEXN' ,'STRING[8]' ,''
             ,'PX_TEXR' ,'INTEGER'   ,''
             ,'PX_TEXQ' ,'STRING[16]',''
             ,'LEVEL'   ,'INTEGER'   ,'Poziom w rankingu'
             ,'COUNT'   ,'INTEGER'   ,'Licznik wystapien'
             ,'LEV_NAME','STRING[20]','Nazwa poziomu'
             );
{? sec_superuser()>0 || _tab.win_sel(_tab.mk_sel(,,1)) ?};
_tab


\gen_px_tex_sym
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Generuje SYMBOL dla biezacego PX_TEXa
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
_symbol:='';
{? _symbol='' || _symbol:=exec('gen_px_tex_sym','px_prepq') ?};
{? _symbol=''
 & ('# TABELA # AUTOPX #'*(6+PX_TEX.KIND)>0)
|| {? PX_TEX.M<>null()   || _symbol:='Indeks: '+PX_TEX.M().KTM
   |? PX_TEX.MGR<>null() || _symbol:='Grupa: '+PX_TEX.MGR().KOD
   |? PX_TEX.ZL<>null()  || _symbol:='Z: '+PX_TEX.ZL().SYM+{? PX_TEX.ZL().SYMZ<>'' || ' ('+PX_TEX.ZL().SYMZ+')' || '' ?}
   ?}
?};
_symbol


\PX_TEXWER4GRPbr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przed rekord w PX_TEX.WER4GRP
::----------------------------------------------------------------------------------------------------------------------
{? PX_VAR.EDIT=0
|| PX_TEX.actions('WER4GRP','DPUAE:D',,1)
|| PX_TEX.actions('WER4GRP','D:D',,1)
?};
~~


\PX_TEXWER4GRPbD
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przed dolacz w PX_TEX WER4GRP
::----------------------------------------------------------------------------------------------------------------------
PX_TEX.cntx_psh();
{? PX_OBJ.get()
|| exec('PX_TEX_WER_bD','px_tex')
?};
PX_TEX.cntx_pop();
~~


\PX_TEXWER4GRPbP
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przed popraw w PX_TEX WER4GRP
::----------------------------------------------------------------------------------------------------------------------
exec('PX_TEX_WER_bP','px_tex')


\PX_TEXWER4GRPbU
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przed usun w PX_TEX WER4GRP
::----------------------------------------------------------------------------------------------------------------------
exec('delete_act','px_tex')


\PX_TEXWER4GRPbG
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Przed podglad w PX_TEX.WER4GRP
::----------------------------------------------------------------------------------------------------------------------
PX_KONT.cntx_psh();
PX_VAR.cntx_psh();
exec('PX_TEX_WER_bGs','px_tex');
PX_VAR.cntx_pop();
PX_KONT.cntx_pop();
~~


\PX_TEXWER4GRPbE
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Edycja w PX_TEX WER4GRP
::----------------------------------------------------------------------------------------------------------------------
exec('PX_TEX_WER_bE','px_tex')


\paczka_korekta
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Koryguje pojemnosci na paczce ktore maja obciazyc plan - uzywane do tego aby nie planowac ponownie ilosci
::       wykonanych, opoznien itp
::       Kontekst pracy - rekord paczki
::   WE: _a - tab_tmp - paczka technologiczna
::       _b - obj_new(exec('il_wym','px_param')) - tablica z ilosciami do korekty
::       _c - INTEGER - 1/-1 - znak czy korekta na minus czy na plus
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_paczka:=_a;
_kor:=_b;
_sign:=_c;
{? _sign>1
|| _sign:=1
|? _sign<-1
|| _sign:=-1
?};

_il_wym:=exec('il_wym','px_param');
{! _it:=1.._il_wym
|! _rule:=$('
               _paczka:=_a;
               _kor:=_b;
               _sign:=_c;

               _new_dim:=_paczka.CAP_DIM'+$_it+'+(_kor['+$_it+']*_sign);
               {? _new_dim<0
               || _new_dim:=0
               ?};
               _paczka.CAP_DIM'+$_it+':=_new_dim;
               _paczka.put()
            ');
   _rule(_paczka,_kor,_sign)
!};
~~


\paczka_kor_prop
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Koryguje pojemnosci na paczce ktore maja obciazyc plan - uzywane do tego aby nie planowac ponownie ilosci
::       wykonanych, opoznien itp
::   WE: _a - tab_tmp - paczka technologiczna
::       _b - obj_new(exec('il_wym','px_param')) - tablica z ilosciami do korekty
::       _c - INTEGER - 1/-1 - znak czy korekta na minus czy na plus
::   WY:
::----------------------------------------------------------------------------------------------------------------------

_paczka:=_a;
_proporcja:=_b;
_il_wym:=exec('il_wym','px_param');

_paczka.cntx_psh();
_paczka.clear();
{? _paczka.first()
|| {!
   |? {! _it:=1.._il_wym
      |! _rule:=$('
                     _paczka:=_a;
                     _proporcja:=_b;
                     _paczka.CAP_DIM'+$_it+'*=_proporcja;
                     _paczka.put()
                  ');
         _rule(_paczka,_proporcja)
      !};
      _paczka.next()
   !}
?};
_paczka.cntx_pop();
_paczka.get();
~~


\PX_TEX_copy_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Tablica parametrów dla PX_TEX_copy
::   WE: [_defaults] - [1] - wszystkie
::                      0  - typy proste (nr typu ponizej 100)
::                     -1  - brak
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('DefaultResult','PX_TEX_s','TKTL_s','PX_TEX_d','TKTL_d');

:: - - - - ponizej ustawienie wartosci domyslnych
_args.DefaultResult:=0;
:: PX_TEX.ref() przepisu zrodlowego
_args.PX_TEX_s:=null();
:: TKTL.ref() technologia definicji przepisu zrodlowego
_args.TKTL_s:=null();
:: PX_TEX.ref() przepisu docelowego
_args.PX_TEX_d:=null();
:: TKTL.ref() technologia docelowa przepisu docelowego
_args.TKTL_d:=null();
:: - - - - koniec ustalania wartosci domyslnych
_args


\PX_TEX_copy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Kopiuje PX_TEX zrodlowe na PX_TEX docelowe - interakcja z uzytkownikiem poza formula
::   WE: _args
::   WY: 1/0 - sukces/porazka
::UWAGA: brak kontroli parametrow !!!
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_result:=_args.DefaultResult;
PX_STAGE.cntx_psh(); PX_STAGE.clear();
PX_OPER.cntx_psh();  PX_OPER.index('UNIQALL'); PX_OPER.clear();
PX_NAST.cntx_psh();  PX_NAST.index('PX');
_PXorTKTL:=exec('PX_STAGE_prefix','px_stage',{?_args.TKTL_s<>null() || _args.TKTL_s || _args.PX_TEX_s ?});
{? _PXorTKTL<>''
 & PX_STAGE.first()
|| {? var_pres('PxTabPar')<100 || exec('PxTabPar','px_init') ?};
:: jezeli kopiujemy z technologii do technologii przechodza parametry
:: jezeli kopiujemy z technologii do przepisu to wyliczamy wartosci i dajemy do PX_OPER
   _pars:=~~;
   _do_calc:={? ( _args.TKTL_d=null()
                | exec('FindAndGet','#table',TKTL,#_args.TKTL_d,,"TYP().PAR<>'T'",1)
                )
              & _args.PX_TEX_d<>null()
             ||
                {? exec('FindAndGet','#table',PX_TEX,#_args.PX_TEX_s,,"TKTL().TYP().PAR='T'",0)
                || exec('start_xpar','tech_param',_args.PX_TEX_s);
                   _pars:=xpar; 1

                |? exec('FindAndGet','#table',TKTL,#_args.TKTL_s,,"TYP().PAR='T'",0)
                || exec('start_tpar','tech_param',null(),_args.TKTL_s);
                   _pars:=tpar; 1

                || _pars:=null();
                   0
                ?}
             ?};
:: ustalamy wspolczynnik do potraktowania norm
   _coef:=1;
   _xjm_src:=1;
   _xjm_dst:=1;
   {? _args.PX_TEX_s<>null()
   || _xjm_src:=exec('FindAndGet','#table',PX_TEX,$_args.PX_TEX_s,,"XJM",1)
   |? _args.TKTL_s<>null()
   || _xjm_src:=exec('FindAndGet','#table',TKTL,$_args.TKTL_s,,"XJM",1)
   ?};
   {? _args.PX_TEX_d<>null()
   || _xjm_dst:=exec('FindAndGet','#table',PX_TEX,$_args.PX_TEX_d,,"XJM",1)
   |? _args.TKTL_d<>null()
   || _xjm_dst:=exec('FindAndGet','#table',TKTL,$_args.TKTL_d,,"XJM",1)
   ?};
   _coef:=_xjm_dst/_xjm_src;

   _fcoef:={? _coef<>1 || form(_coef,,,'9.') || '' ?};
   _result:=1;

   _map:=tab_tmp(1,
      'REF_OLD','STRING[16]','Ref PX_STAGE.ref starego',
      'REF_NEW','STRING[16]','Ref PX_STAGE.ref nowego'
   );

   {!
   |? _new_ref:=null();
      _old_ref:=PX_STAGE.ref();
      PX_STAGE.cntx_psh();
      PX_STAGE.clear();
      PX_STAGE.TKTL:=null();
      PX_STAGE.RTKTL:='';
      PX_STAGE.PX_TEX:=null();

      {? _args.TKTL_d<>null()
      || PX_STAGE.TKTL:=_args.TKTL_d;
         PX_STAGE.RTKTL:=$_args.TKTL_d
      |? _args.PX_TEX_d<>null()
      || PX_STAGE.PX_TEX:=_args.PX_TEX_d
      ?};
      {? PX_STAGE.add()
      || _new_ref:=PX_STAGE.ref();

         _map.prefix();
         _map.blank();
         _map.REF_OLD:=$_old_ref;
         _map.REF_NEW:=$_new_ref;
         _map.add()
      ?};
      PX_STAGE.cntx_pop();
::    PX_STAGE przekopiowany, teraz kopiujemy PX_OPERy
      PX_OPER.prefix(PX_STAGE.ref());
      {? _new_ref<>null()
       & PX_OPER.first()
      ||
         {!
         |?

            PX_OPER.cntx_psh();
            PX_OPER.clear();
            PX_OPER.PX_STAGE:=_new_ref;
            {? PX_OPER.add()
            ||
::             przeliczenie zuzyc normatywnych
               {? _coef<>1
               || exec('recalculate_use','px_oper',PX_OPER.ref(),_coef,_pars,_do_calc)
               ?};
               {? _do_calc>0
               ||
::                Przeliczenie zuzyc min
                  exec('recalculate_min','px_oper',PX_OPER.ref(),_pars,1);
::                Przeliczenie zuzyc max
                  exec('recalculate_max','px_oper',PX_OPER.ref(),_pars,1)
               ?}
            ?};
            PX_OPER.cntx_pop();
            PX_OPER.next()
         !}
      ?};
      PX_STAGE.next()
   !};

:: Kopiowanie PX_NEXT
   {? PX_STAGE.first()
   || {!
      |?
         PX_STAGE.cntx_psh();
         PX_NAST.prefix(PX_STAGE.ref());
         {? PX_NAST.first()
         || {!
            |?
               _new_stage:=null();
               _new_next:=null();

               _map.prefix($PX_NAST.PX_STAGE);
               {? _map.first()
               || _new_stage:=exec('FindAndGet','#table',PX_STAGE,_map.REF_NEW,,,null())
               ?};
               _map.prefix($PX_NAST.PX_NEXT);
               {? _map.first()
               || _new_next:=exec('FindAndGet','#table',PX_STAGE,_map.REF_NEW,,,null())
               ?};
               {? _new_stage<>null() & _new_next<>null()
               || PX_NAST.cntx_psh();
                  PX_NAST.prefix();
                  PX_NAST.PX_STAGE:=_new_stage;
                  PX_NAST.PX_NEXT:=_new_next;
                  PX_NAST.TKTL:=null();
                  PX_NAST.RTKTL:='';
                  PX_NAST.PX_TEX:=null();

                  {? _args.TKTL_d<>null()
                  || PX_NAST.TKTL:=_args.TKTL_d;
                     PX_NAST.RTKTL:=$_args.TKTL_d
                  |? _args.PX_TEX_d<>null()
                  || PX_NAST.PX_TEX:=_args.PX_TEX_d
                  ?};
                  PX_NAST.add();
                  PX_NAST.cntx_pop()
               ?};
               PX_NAST.next()
            !}
         ?};
         PX_STAGE.cntx_pop();
         PX_STAGE.next()
      !}
   ?}
|? _PXorTKTL=''
|| _result:=0
?};
PX_STAGE.cntx_pop();
PX_OPER.cntx_pop();
PX_NAST.cntx_pop();
_result


\PX_TEX_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Kasuje podany PX_TEX i jezeli byly do niego bezposrednio przypisane PX_STAGE'e to je rowniez wycina
::   WE: PX_TEX.ref()
::   WY: 1-udalo sie/ 0-nie udalo sie
::----------------------------------------------------------------------------------------------------------------------
_PX_TEX:=_a;
_result:=1;
_mydo:=do_state()=0;
{? _mydo || do() ?};
PX_TEX.cntx_psh();
PX_TEX.clear();
{? PX_TEX.seek(_PX_TEX)
|| result:=exec('clean','px_tex',PX_TEX.ref())
|| _result:=0
?};
:: wlasciwe usuniecie PX_TEX
{? _result>0
 & PX_TEX.del(,1)
|| _result:=1
|| _result:=0; undo()
?};
{? _mydo || end() ?};
PX_TEX.cntx_pop();
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Czysci powiazania dla przepisu PX_TEX
::   WE: _a - PX_TEX.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;

_result:=0;
:: 1. Czyszczenie etapow i operacji
_can_continue:=exec('clean_stages','px_tex',_px_tex);

:: 2. Czyszczenie parametrow
{? _can_continue>0
|| _can_continue:=exec('clean_pars','px_tex',_px_tex)
?};
:: 3. Czyszczenie powiazan z PX_OBJ
{? _can_continue>0
|| _can_continue:=exec('clean_obj','px_tex',_px_tex)
?};

{? _can_continue>0
|| _result:=1
?};
_result


\clean_stages
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Usuwa dla PX_TEX wszystkie PX_STAGE
::   WE: _a - PX_TEX.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _px_tex:=_a
?};

_result:=0;
_can_continue:=1;

PX_TEX.cntx_psh();
PX_STAGE.cntx_psh();
PX_STAGE.clear();
PX_STAGE.index('TEX_NR');
PX_STAGE.prefix(_px_tex);
{? PX_STAGE.first()
|| {!
   |? _can_continue:=exec('PX_STAGE_del','px_stage',PX_STAGE.ref());
      PX_STAGE.first() & _can_continue>0
   !};
   _result:=~PX_STAGE.first()
?};
PX_STAGE.cntx_pop();
PX_TEX.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\clean_stages_tk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Usuwa dla PX_TEX wszystkie PX_STAGE
::   WE: _a - TKTL.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_tktl:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _tktl:=_a
?};

_result:=0;
_can_continue:=1;

PX_TEX.cntx_psh();
PX_STAGE.cntx_psh();
PX_STAGE.clear();
PX_STAGE.index('TKTL_NR');
PX_STAGE.prefix($_tktl);
{? PX_STAGE.first()
|| {!
   |? _can_continue:=exec('PX_STAGE_del','px_stage',PX_STAGE.ref());
      PX_STAGE.first() & _can_continue>0
   !};
   _result:=~PX_STAGE.first()
?};
PX_STAGE.cntx_pop();
PX_TEX.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\clean_pars
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Usuwa dla PX_TEX wszystkie PX_TPAR
::   WE: _a - PX_TEX.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;

_result:=1;

PX_TPAR.cntx_psh();
PX_TPAR.clear();
PX_TPAR.index('TEXPAR');
PX_TPAR.prefix(_px_tex);
{? PX_TPAR.first()
|| {!
   |? PX_TPAR.del()
   !};
   _result:=~(PX_TPAR.size()>0)
?};
PX_TPAR.cntx_pop();
_result


\clean_obj
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Czysci powiazania na PX_OBJ dla podanego przepisu
::   WE: _a - PX_TEX.ref()
::       [_b] - INTEGER - [0]/1 czy wykonywac aktualizacje zestawu startowego na obiekcie?
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;

_update_set:=0;
{? var_pres('_b')=type_of(0)
|| _update_set:=_b
?};

_result:=0;
_can_continue:=1;

PX_OBJ.cntx_psh();
PX_OBJ.index('PX_TEX');
PX_OBJ.prefix(_px_tex);
{? PX_OBJ.first()
|| {!
   |? _next:=0;
      _ref_nxt:=null();

      PX_OBJ.cntx_psh();
      {? PX_OBJ.next()
      || _ref_nxt:=PX_OBJ.ref()
      ?};
      PX_OBJ.cntx_pop();

      PX_OBJ.cntx_psh();
      PX_OBJ.clear();
      PX_OBJ.PX_TEX:=null();
      _can_continue:=PX_OBJ.put();
      PX_OBJ.cntx_pop();

      PX_OBJ.get();
      {? exec('is_px_set','px_param')>0 & _can_continue>0 & _update_set>0
      || exec('update_px_set','px_obj',PX_OBJ.ref(),,1)
      ?};

      {? _ref_nxt<>null()
      || _next:=PX_OBJ.seek(_ref_nxt)
      ?};
      _next>0 & _can_continue>0
   !}
?};
PX_OBJ.cntx_pop();
PX_OBJ.get();
{? _can_continue>0
|| _result:=1
?};
_result


\PX_TEX_posbsrc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Zwraca tabele z mozliwymi przepisami planistycznymi
::   WY: tabela tymczasowa
::----------------------------------------------------------------------------------------------------------------------
_tabela:=tab_tmp(2
                ,'KIND'    ,'STRING[11]' ,'Rodzaj'
                ,'SYMBOL'  ,'STRING[50]' ,'Symbol'
                ,'WERSJA'  ,'STRING[20]' ,'Wersja'
                ,'OPIS'    ,'STRING[100]','Opis'
                ,'KTM'     ,'STRING[50]' ,'Produkt'

                ,'SRC'     ,'STRING[8]'  ,''
                ,'REF_NAME','STRING[8]'  ,''
                ,'REF_NUMB','INTEGER'    ,''

                );

_can_continue:=1;
M.cntx_psh();
MGR.cntx_psh();
PX_STAGE.cntx_psh();
PX_STAGE.clear();
PX_STAGE.index('TKTL_NR');
PX_STAGE.prefix('',1);
{? PX_STAGE.first()
|| {!
   |?
      _tabela.KIND:='Przepis';
      _tabela.SYMBOL:=PX_STAGE.PX_TEX().SYMBOL;
      _tabela.OPIS:=exec('get_TexSubjDesc','px_tex',PX_STAGE.PX_TEX);
      _tabela.WERSJA:=PX_TEX.VER;
      _tabela.KTM:=PX_TEX.M().KTM;
      _tabela.SRC:='PX_TEX';
      _tabela.REF_NAME:=ref_name(PX_STAGE.PX_TEX);
      _tabela.REF_NUMB:=#PX_STAGE.PX_TEX;
      _tabela.add();
      PX_STAGE.next()
   !}
?};
PX_STAGE.index('TEX_NR');
PX_STAGE.prefix(null(),1);
{? PX_STAGE.first()
|| {!
   |?
::    Sprawdzam czy jest taki PX_TEX powiazany z tym TKTL - jesli jest to dodaje
      {? PX_STAGE.TKTL<>null()
      ||
         PX_TEX.cntx_psh();
         PX_TEX.index('TKTLMSYM');
         PX_TEX.prefix($PX_STAGE.TKTL);
         {? PX_TEX.first()
         || {!
            |? _tabela.blank();
               _tabela.KIND:='Przepis';
               _tabela.SYMBOL:=PX_TEX.SYMBOL;
               _tabela.OPIS:=exec('get_TexSubjDesc','px_tex',PX_TEX.ref());
               _tabela.WERSJA:=PX_TEX.VER;
               _tabela.KTM:=PX_TEX.M().KTM;
               _tabela.SRC:='TKTL';
               _tabela.REF_NAME:=ref_name(PX_STAGE.TKTL);
               _tabela.REF_NUMB:=#PX_STAGE.TKTL;
               _tabela.add();
               PX_TEX.next()
            !}
         ?};
         PX_TEX.cntx_pop()
      ?};
      _tabela.blank();
      _tabela.KIND:='Technologia';
      _tktl:=PX_STAGE.PX_TEX().TKTL;
      {? _tktl=null()
      || _tktl:=exec('FindAndGet','#table',TKTL,PX_STAGE.RTKTL,,,null())
      ?};
      {? _tktl<>null()
      ||
         TKTL.cntx_psh();
         TKTL.use(ref_name(_tktl));
         TKTL.prefix();
         {? TKTL.seek(_tktl)
         || _tabela.SYMBOL:=TKTL.NRK+' wersja: '+TKTL.WER;
            _tabela.OPIS:=TKTL.OPIS;
            _tabela.KTM:=TKTL.KTM().KTM
         ?};
         TKTL.cntx_pop()
      ?};
      _tabela.SRC:='TKTL';
      _tabela.REF_NAME:=ref_name(PX_STAGE.TKTL);
      _tabela.REF_NUMB:=#PX_STAGE.TKTL;
      _tabela.add();
      PX_STAGE.next()
   !}
?};
PX_STAGE.cntx_pop();
MGR.cntx_pop();
M.cntx_pop();
{? sec_superuser()<=0 || _tabela.fld_attr(,2) ?};
_win:=_tabela.mk_sel('Dostępne przepisy'@,,,,,,,,'U');
_tabela.win_sel(_win);
_tabela.win_act(_win,,'Formuła','&Wybierz'@@,,,"sel_exit()",,1,,,,'W');
_tabela.win_act(_win,,'Kolejność');

_tabela.win_fld(_win,,'KIND');
_tabela.win_fld(_win,,'SYMBOL',,,30);
_tabela.win_fld(_win,,'WERSJA',,,20);
_tabela.win_fld(_win,,'KTM',,,30);
_tabela.win_fld(_win,,'OPIS'  ,,,50);

_tabela


\px_tex_akt_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Zastepuje lub przywraca standardowa obsluge na blank pola PX_TEX.AKT
::   WE: _a - 0 = standardowa obsluga
::            1 = blank litera 'T'
::----------------------------------------------------------------------------------------------------------------------
{? _a
|| PX_TEX.fld_fml('AKT','BLANK',"'T'")
|| PX_TEX.fld_fml('AKT','BLANK',"*")
?}


\get_TexSubjDesc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca opis dla podmiotu podanego przepisu
::   WE: PX_TEX.ref()
::   WY: STRING opis
::----------------------------------------------------------------------------------------------------------------------
_PX_TEX:=_a;
_opis:='<podmiot nieznany>';

PX_TEX.cntx_psh(); PX_TEX.clear();
{? PX_TEX.seek(_PX_TEX)
|| exec('PXoTEX_chk','px_tex');
   {? PX_TEX.KIND=PXoTEX.kind.table('M')
   || _opis:='Materiał: ('+PX_TEX.M().KTM+') '+M.N

   |? PX_TEX.KIND=PXoTEX.kind.table('MGR')
   || _opis:='Grupa: ('+PX_TEX.MGR().KOD+') '+MGR.NAZ

   |? PX_TEX.KIND=PXoTEX.kind.auto('ZL')
   || {? PX_TEX.ZL().PROJEKTY<>null()
      || _opis:='Zadanie: ('+PX_TEX.ZL().SYMZ+')'+ZL.OPIS
      ?}
   |? PX_TEX.KIND=PXoTEX.kind.table('ZL')
   || _opis:='Zlecenie:('+PX_TEX.ZL().SYM+')'+ZL.OPIS

   |? PX_TEX.KIND=PXoTEX.kind.system()
   || _opis:='Przepis systemowy'

   ?}
?};
PX_TEX.cntx_pop();
_opis


\pck_not_empty
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy paczka zawiera jakiekolwiek ilosci w ktorymkolwiek wymiarze
::       Jednym slowem sprawdza czy paczka jest pusta czy nie
::   WE: _a - tab_tmp() - paczka technologiczna
::   WY: 1 - paczka nie jest zerowa, oplaca sie z nia cos robic
::       0 - paczka jest pusta
::----------------------------------------------------------------------------------------------------------------------
_paczka:=_a;
_result:=0;
_can_continue:=1;

_paczka.cntx_psh();
_paczka.clear();
{? _paczka.first()
|| {!
   |? _result:=exec('pck_oper_empty','px_tex',_paczka);
      {? _result>0
      || _can_continue:=0
      ?};
      _paczka.next() & _can_continue>0
   !}
?};
_paczka.cntx_pop();
_result


\pck_oper_empty
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy aktualny rekord w paczce planistycznej ma ilosci do planu rozne od zera
::   WE: _a - tab_tmp() - paczka technologiczna
::   WY: 1 - operacja w paczce nie jest zerowa, oplaca sie z nia cos robic
::       0 - operacja w paczce nie ma zadnych ilosci do zaplanowania
::----------------------------------------------------------------------------------------------------------------------
_paczka:=_a;
_result:=0;
_can_continue:=1;

_il_wym:=exec('il_wym','px_param');
{! _it:=1.._il_wym
|? _can_continue>0
|!
   _rule:=$('
               _paczka:=_a;
               _result:=0;
               {? _paczka.CAP_DIM'+$_it+'>0
               || _result:=1
               ?};
               _result
            ');
   _result:=_rule(_paczka);
   {? _result>0
   || _can_continue:=0
   ?}
!};
_result


\pck_oper_planned
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy aktualny rekord w paczce planistycznej ma jakąś ilość zaplanowaną
::   WE: _a - tab_tmp() - paczka technologiczna
::   WY: 1 - operacja w paczce nie jest zerowa, oplaca sie z nia cos robic
::       0 - operacja w paczce nie ma zadnych ilosci do zaplanowania
::----------------------------------------------------------------------------------------------------------------------
_paczka:=_a;
_result:=0;
_can_continue:=1;

_il_wym:=exec('il_wym','px_param');
{! _it:=1.._il_wym
|? _can_continue>0
|!
   _rule:=$('
               _paczka:=_a;
               _result:=0;
               {? _paczka.DID_DIM'+$_it+'>0
               || _result:=1
               ?};
               _result
            ');
   _result:=_rule(_paczka);
   {? _result>0
   || _can_continue:=0
   ?}
!};
_result


\tex_f_set1
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Ustawia filtr w tabeli PX_TEX
::   WE: _a - PX_OBJ.ref()
::   WY: 0 - porazka
::       1 - filtr zostal zalozony ale nie udalo sie ustawic na domyslnym przepisie
::       2 - filtr zostal zalozony i w buforze tabeli PX_TEX jest domyslny przepis
::----------------------------------------------------------------------------------------------------------------------
_pxobj:=_a;
_result:=0;
PX_TEX.clear();
PX_OBJ.cntx_psh();
PX_OBJ.clear();

VAR_DEL.delete('pxtexy');

_can_continue:=0;
{? PX_OBJ.seek(_pxobj)
|| pxtexy:=exec('get_default_tex','px_tex',PX_OBJ.ref(),2);
   {? type_of(pxtexy)>100
   || _where:='PX_TEX.REFERENCE in (select :_a.PX_TEXQ from :_a) and PX_TEX.AKT=\'T\'';
      _can_continue:=PX_TEX.f_set('SYMBOL',,_where,pxtexy);
      {? _can_continue>0
      || _result:=1;
         {? pxtexy.first()
         ||
::          ustawiam sie na domyslnej technologii
            {? PX_TEX.f_seek(pxtexy.PX_TEXR,pxtexy.PX_TEXN)
            || _result:=2
            ?}
         ?}
      ?};
::    ustawiam indeks w pxtexy
      _ndx_texy:=pxtexy.ndx_tmp(,,'PX_TEXN',,,'PX_TEXR',,);
      pxtexy.index(_ndx_texy)
   ?}
?};
PX_OBJ.cntx_pop();
_result


\tex_f_set2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Ustawia filtr w tabeli PX_TEX
::   WE: _a - PX_GRP.ref()
::   WY: 0 - porazka
::       1 - filtr zostal zalozony ale nie udalo sie ustawic na domyslnym przepisie
::       2 - filtr zostal zalozony i w buforze tabeli PX_TEX jest domyslny przepis
::----------------------------------------------------------------------------------------------------------------------
_pxgrp:=_a;
_result:=0;
PX_TEX.clear();
PX_GRP.cntx_psh();
PX_GRP.clear();

VAR_DEL.delete('pxtexy');

_can_continue:=0;
{? PX_GRP.seek(_pxgrp)
||
:: tworze strukture argumentow do funkcji filtrujacej przepisy
   _args:=exec('PxObjLst_make','px_tex');
   _args.PX_GRP:=PX_GRP.ref();

   pxtexy:=exec('PX_TEX_filter','px_tex',_args,0);
   {? type_of(pxtexy)>100
   || _where:='PX_TEX.REFERENCE in (select :_a.PX_TEXQ from :_a) and PX_TEX.AKT=\'T\'';
      _can_continue:=PX_TEX.f_set('SYMBOL',,_where,pxtexy);
      {? _can_continue>0
      || _result:=1;
         {? pxtexy.first()
         ||
::          ustawiam sie na technologii przypisanej do PX_GRP
            {? PX_TEX.f_seek(#PX_GRP.PX_TEX,ref_name(PX_GRP.PX_TEX))
            || _result:=2
            ?}
         ?}
      ?};
::    ustawiam indeks w pxtexy
      _ndx_texy:=pxtexy.ndx_tmp(,,'PX_TEXN',,,'PX_TEXR',,);
      pxtexy.index(_ndx_texy)
   ?}
?};
PX_GRP.cntx_pop();
_result


\tex_f_clear
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Zdejmuje filtr z tabeli PX_TEX
::----------------------------------------------------------------------------------------------------------------------
PX_TEX.f_clear();
VAR_DEL.delete('pxtexy');
~~


\dict_wer
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Tworzy tymczasowe okno wertowania tabeli PX_TEX z obsluga filtrow
::       Zrobione jako tymczasowe, aby nie modyfikowac defa w wersji wyemitowanej
::   WY: STRING - akronim okna
::----------------------------------------------------------------------------------------------------------------------
_wer:=PX_TEX.mk_sel('Przepisy planistyczne'@,,,'pxtexdictf',10,,,,'P');
PX_TEX.win_fld(_wer,PX_TEX,'SYMBOL',,,25,,,'Symbol'@);
PX_TEX.win_fld(_wer,PX_TEX,'PX_RULES','SYMBOL',,25,,,'Metoda'@);
PX_TEX.win_fld(_wer,PX_TEX,'TKTL','NRK',,25,,,'Technologia'@);
PX_TEX.win_fld(_wer,PX_TEX,'TKTL','WER',,6,,,'Wersja'@);
PX_TEX.win_fld(_wer,PX_VAR,'STRING',,,6,,,'Ranking'@);
PX_TEX.win_fld(_wer,VAR,'STRING',,,20,,,'Rodzaj'@);
PX_TEX.win_act(_wer,0,'Rekord','Wybierz'@@,,,"
                                          PX_VAR.STRING:='';
                                          VAR.STRING:='';
                                          {? var_pres('pxtexy')>100
                                          || pxtexy.prefix(ref_name(PX_TEX.ref()),#PX_TEX.ref());
                                             {? pxtexy.first()
                                             || PX_VAR.STRING:=$pxtexy.LEVEL;
                                                VAR.STRING:=pxtexy.LEV_NAME
                                             ?}
                                          ?}
                                          ",,1);
PX_TEX.win_act(_wer,,'Formuła','podGląd'@@,,'Podgląd definicji wskazanego przepisu',"exec('PX_TEX_WER_bGs','px_tex')");
_wer


\status_pck_norm
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Status rekordu w paczce technologicznej - normalny
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'NORMALNY'


\status_pck_dlay
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Status rekordu w paczce technologicznej - opozniony
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'OPÓŹNIONY'


\level_zl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca poziom przepisu technologicznego - zlecenie (lub projekt)
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'ZLECENIE'


\level_universal
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca poziom przepisu technologicznego - uniwersalny
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'UNIWERSALNY'


\level_mgrp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca poziom przepisu technologicznego - grupa materialowa
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'GR.MATERIAŁOWA'


\level_material
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca poziom przepisu technologicznego - material
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'MATERIAŁ'


\tie_toper2stage
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Wiaze ze soba operacje w technologii z etapem w przepisie WPP
::   WE: _a - TOPER.ref() - operacja technologii
::       _b - PX_STAGE.ref() - etap w przepisie
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_toper:=_a;
_px_stage:=_b;
_result:=0;

TOPER.cntx_psh();
TOPER.clear();
{? TOPER.seek(_toper)
|| TOPER.PX_STAGE:=_px_stage;
   _result:=TOPER.put()
?};
TOPER.cntx_pop();
TOPER.get();
_result


\tie_zoper2stage
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Wiaze ze soba operacje w technologii zlecenia z etapem w przepisie WPP
::   WE: _a - ZOPER.ref() - operacja technologii zlecenia
::       _b - PX_STAGE.ref() - etap w przepisie
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_zoper:=_a;
_px_stage:=_b;
_result:=0;

ZOPER.cntx_psh();
ZOPER.clear();
{? ZOPER.seek(_zoper)
|| ZOPER.PX_STAGE:=_px_stage;
   _result:=ZOPER.put()
?};
ZOPER.cntx_pop();
ZOPER.get();
_result


\tie_zgp2stage
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Wiaze ze soba pozycje przewodnika z etapem w przepisie WPP
::   WE: _a - ZGP.ref() - pozycja przewodnika zlecenia
::       _b - PX_STAGE.ref() - etap w przepisie
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;
_px_stage:=_b;
_result:=0;

ZGP.cntx_psh();
ZGP.clear();
{? ZGP.seek(_zgp)
|| ZGP.PX_STAGE:=_px_stage;
   _result:=ZGP.put()
?};
ZGP.cntx_pop();
ZGP.get();
_result


\load_tie_toper
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Wypelnia tabele z następnikami/poprzednikami do podanego etapu
::   WE: _a - PxTex
::       _b - PX_STAGE.ref()
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_pxstage:=_b;
_nast:='';
_pxtex.TieTabP.erase();
_pxtex.TieTabN.erase();
PX_STAGE.cntx_psh();
PX_STAGE.clear();
PX_NAST.cntx_psh();
PX_NAST.clear();

{? PX_STAGE.seek(_pxstage)
||
   PX_NAST.index('PX');
:: najpierw nastepniki
   PX_NAST.prefix(_pxstage);
   {? PX_NAST.first()
   || {!
      |?
         _pxtex.TieTabN.blank();
         _pxtex.TieTabN.R:='N';
         _pxtex.TieTabN.SQL_REF:=$_pxstage;
         _pxtex.TieTabN.NR:=PX_NAST.PX_NEXT().NR;
         _pxtex.TieTabN.SYMBOL:=PX_NAST.PX_NEXT().NAZWA;
         _pxtex.TieTabN.NAZWA:=PX_NAST.PX_NEXT().NAZWA;
         _pxtex.TieTabN.NSQL_REF:=$PX_NAST.PX_NEXT;
         _pxtex.TieTabN.SQL_TKTL:=$PX_NAST.TKTL;
         _pxtex.TieTabN.SQL_TEX:=$PX_NAST.PX_TEX;
         _pxtex.TieTabN.SQL_ZL:=$PX_NAST.ZL;
         _pxtex.TieTabN.SQL_STAG:=$PX_NAST.PX_STAGE;
         _pxtex.TieTabN.SQL_NEXT:=$PX_NAST.PX_NEXT;
         _pxtex.TieTabN.SCIEZKA:=PX_NAST.SCIEZKA;
         _pxtex.TieTabN.add();
         _nast+=$PX_NAST.PX_NEXT().NR+',';
         PX_NAST.next()
      !}
   ?};
   PX_NAST.index('NEXT');
:: teraz poprzedniki
   PX_NAST.prefix(_pxstage);
   {? PX_NAST.first()
   || {!
      |? _pxtex.TieTabP.blank();
         _pxtex.TieTabP.R:='P';
         _pxtex.TieTabP.SQL_REF:=$_pxstage;
         _pxtex.TieTabP.NR:=PX_NAST.PX_STAGE().NR;
         _pxtex.TieTabP.SYMBOL:=PX_NAST.PX_STAGE().NAZWA;
         _pxtex.TieTabP.NAZWA:=PX_NAST.PX_STAGE().NAZWA;
         _pxtex.TieTabP.SQL_TKTL:=$PX_NAST.TKTL;
         _pxtex.TieTabP.SQL_TEX:=$PX_NAST.PX_TEX;
         _pxtex.TieTabP.SQL_ZL:=$PX_NAST.ZL;
         _pxtex.TieTabP.SQL_STAG:=$PX_NAST.PX_STAGE;
         _pxtex.TieTabP.SQL_NEXT:=$PX_NAST.PX_NEXT;
         _pxtex.TieTabP.SCIEZKA:=PX_NAST.SCIEZKA;
         _pxtex.TieTabP.add();
         PX_NAST.next()
      !}
   ?};
   _pxtex.TieTabP.first();
   _pxtex.TieTabN.first()
|| _pxtex.TieTabP.erase();
   _pxtex.TieTabN.first()
?};
_nast:=_nast-1;
:: Aktualizacja listy następników etapu
_pxtex.OperTab.cntx_psh();
_pxtex.OperTab.prefix();
{? _pxtex.OperTab.find_tab(,'STAGEREF',,'=',exec('FindAndGet','#table',PX_STAGE,_pxstage,,"#PX_STAGE.ref()",0)
      ,'PARENT',,'=',0)
|| {? _pxtex.OperTab.NAST<>_nast
   || _pxtex.OperTab.NAST:=_nast;
      _pxtex.OperTab.put()
   ?}
?};
_pxtex.OperTab.cntx_pop();
PX_NAST.cntx_pop();
PX_STAGE.cntx_pop();
~~


\oper_treeview
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Zwraca obiekt klasy @.CLASS.TREEVIEW - drzewo
::   WY: Klasa zawierajaca widok operacji
::----------------------------------------------------------------------------------------------------------------------
_result:=~~;
{? var_pres('XTTREE')>100
|| _result:=XTTREE
||
:: buduje obiekt klasy treeview - tylko podgląd
   exec('declare','tech_tree');
   exec('tree','tech_oper',2,0);
   _result:=XTTREE
?};
XTTREE.TAB.win_fml(XTTREE.WERT,,'TXT',,'ICON_BEFORE',XTTREE.win_fml());
_result


\dnd_tie_toper1
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Obsluga d'n'd w tabeli .TieTab z tabeli TTREE (operacje technologii)
::----------------------------------------------------------------------------------------------------------------------
_dropped:=dnd_info('dropped_records');
_ttree:=exec('oper_treeview','px_tex');
{? type_of(_ttree)<>~~
|| _tab:=_ttree.TAB;
   _tab.cntx_psh();
   _tab.clear();
   {? _dropped.first()
   || {!
      |? {? _tab.seek(_dropped.REF,)
         || TOPER.cntx_psh();
            TOPER.clear();
            {? TOPER.seek(_tab.REF,)
            || exec('dnd_add_tie','px_tex')
            ?};
            TOPER.cntx_pop()
         ?};
         _dropped.next()
      !};
::    Po zrobieniu nowych powiazan musze odbudowac tabelke wyswietlajaca powiazania
      exec('load_tie_toper','px_tex',PxTex,PX_VAR.PX_STAGE)
   ?};
   _tab.cntx_pop()
?};
~~


\dnd_add_tie
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Dodaje TOPERa do tabeli .TieTab
::----------------------------------------------------------------------------------------------------------------------

TOPER.cntx_psh();
{? TOPER.PZ='Z'
||
:: Jesli popuscilem operacje zlozona to wiaze operacje proste nalezace do niej
   TOPER.cntx_psh();
   TOPER.index('NNK');
   TOPER.prefix(TOPER.NRK,TOPER.UNROP);
   {? TOPER.first()
   || {!
      |?
         {? TOPER.TPZ<>'T'
         ||
            {? TOPER.PZ='P'
            ||
::          pole zmiennej PX_VAR.PX_STAGE jest nawijane w funkcji rekord przed
::          w tabeli PxTex.OperTab exec('PxTexOperbrek','px_oper')
               exec('tie_toper2stage','px_tex',TOPER.ref(),PX_VAR.PX_STAGE)
            |? TOPER.PZ='Z'
            ||
::          !!! REKURENCJA !!!
               exec('dnd_add_tie','px_tex')
            ?}
         ?};
         TOPER.next()
      !}
   ?};
   TOPER.cntx_pop()
|? TOPER.PZ='P'
||
:: pole zmiennej PX_VAR.PX_STAGE jest nawijane w funkcji rekord przed
:: w tabeli PxTex.OperTab exec('PxTexOperbrek','px_oper')
   exec('tie_toper2stage','px_tex',TOPER.ref(),PX_VAR.PX_STAGE)
?};
TOPER.cntx_pop();
~~


\dnd_tie_toper2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Obsluga d'n'd w tabeli .OperTab z tabeli TTREE (operacje technologii)
::----------------------------------------------------------------------------------------------------------------------
_dropped:=dnd_info('dropped_records');
_dest:=dnd_info('dest_record');
_ttree:=exec('oper_treeview','px_tex');
{? type_of(_ttree)<>~~
|| PxTex.OperTab.cntx_psh();
   PxTex.OperTab.clear();
   _tab:=_ttree.TAB;
   _tab.cntx_psh();
   _tab.clear();

   {? PxTex.OperTab.seek(_dest)
   ||
      PX_STAGE.cntx_psh();
      PX_STAGE.clear();
      {? PX_STAGE.seek(PxTex.OperTab.STAGEREF,PxTex.OperTab.STAGENAM)
      ||
         {? _dropped.first()
         || {!
            |? {? _tab.seek(_dropped.REF,)
               || TOPER.cntx_psh();
                  TOPER.clear();
                  {? TOPER.seek(_tab.REF,)
                  || exec('dnd_add_tie','px_tex')
                  ?};
                  TOPER.cntx_pop()
               ?};
               _dropped.next()
            !};
::          Po zrobieniu nowych powiazan musze odbudowac tabelke wyswietlajaca powiazania
            exec('load_tie_toper','px_tex',PxTex,PX_VAR.PX_STAGE)
         ?}
      ?};
      PX_STAGE.cntx_pop()
   ?};
   _tab.cntx_pop();
   PxTex.OperTab.cntx_pop()
?};
~~


\tie_del
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Akcja usuniecia powiazania operacji z etapem w oknie PxTex.TieSel
::----------------------------------------------------------------------------------------------------------------------
_tab:=PxTex.TieTab;

_ref:=null();
{? _tab.TYP='TOPER'
|| _ref:=exec('FindAndGet','#table',TOPER,_tab.SQL_REF,,,null());
   exec('tie_toper2stage','px_tex',_ref,null())
|? _tab.TYP='ZOPER'
|| _ref:=exec('FindAndGet','#table',ZOPER,_tab.SQL_REF,,,null());
   exec('tie_zoper2stage','px_tex',_ref,null())
?};
:: Po usunieciu powiazania musze odbudowac tabelke wyswietlajaca powiazania
exec('load_tie_toper','px_tex',PxTex,PX_VAR.PX_STAGE);
~~


\verify
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Weryfikuje podany przepis
::   WE: _a - PX_TEX.ref()
::       _b - REAL - ilosc jaka ma byc umieszczona w planie
::   WY: STRING - tekst bledu lub '' jesli wszystko ok
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;
_ilosc:=_b;

_verify:='';
:: Sprawdza czy przepis nie jest pusty
{? exec('is_empty','px_tex',_px_tex)
|| _verify:='jest pusty (nie zawiera etapów)'@
?};
:: Sprawdzam aktywnosc zasobow uzytych w przepisie
{? _verify=''
|| _verify:=exec('verifyzasoby','px_tex',_px_tex)
?};

:: Sprawdzam czy ilosci uzyte w przepisie nie sa zerowe
{? _verify=''
|| _verify:=exec('verifyilosc','px_tex',_px_tex,_ilosc)
?};

:: Sprawdzam poprawność następników
{? _verify=''
|| _verify:=exec('verifynast','px_tex',_px_tex)
?};

:: Sprawdzam poprawnosc naleznosci do zestawow planistycznych
{? exec('is_px_set','px_param')>0
|| {? _verify=''
   || _verify:=exec('verifysets','px_tex',_px_tex)
   ?};
   {? _verify=''
   || {? exec('has_start_sets','px_tex',_px_tex,2)=0
      || _verify:='nie zawiera zestawów planistycznych, które w kolejce występują jako źródłowe'@
      ?}
   ?}
?};
_verify


\verifyzasoby
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Sprawdza poprawnosc podanej PX_TEX
::   WE: PX_TEX.ref()
::   WY: tekst bledu
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_result:='';
PX_TEX.cntx_psh(); PX_TEX.clear();
{? PX_TEX.seek(_a)
|| {? (+PXoTEX.kind.auto(''))+PX_TEX.KIND=PXoTEX.kind.auto('')
   || exec('PX_TEX_autoupd','px_auto',PX_TEX.ref())
   ?};
   PX_OPER.cntx_psh(); PX_OPER.clear();

:: 1. Sprawdzana jest aktywnosc uzytych zasobow
   _deactive:=0;
   PX_OPER.index('PXTEXKON');
   PX_OPER.prefix(PX_TEX.ref(),'N');
   {? PX_OPER.size()>0
   || _deactive:=1
   ?};
   {? PX_TEX.RTKTL<>''
   || PX_OPER.index('TKTLAKT');
      _tktl:=exec('FindAndGet','#table',TKTL,PX_TEX.RTKTL,,,null());
      {? _tktl<>null()
      ||
         PX_OPER.prefix(_tktl,'N');
         {? PX_OPER.size()>0
         || _deactive:=1
         ?}
      ?}
   ?};
   {? _deactive>0
   || _result:='korzysta z nieaktywnych zasobów'@
   ?};

   {? _result=''
   ||
::    2. Sprawdzane jest czy operacja ma w ogole przypiety zasob
      _empty:=0;
      PX_OPER.index('PXTEXKON');
      PX_OPER.prefix(PX_TEX.ref(),'T');
      {? PX_OPER.size()=0
      ||
         _empty:=1;
::       jesli nie ma PX_OPERow powiazanych z PX_TEX to sprawdzam czy sa powiazane z TKTL
         {? PX_TEX.RTKTL<>''
         || PX_OPER.index('TKTLAKT');
            _tktl:=exec('FindAndGet','#table',TKTL,PX_TEX.RTKTL,,,null());
            {? _tktl<>null()
            ||
               PX_OPER.prefix(_tktl,'T');
               {? PX_OPER.size()>0
               || _empty:=0
               ?}
            ?}
         ?}
      ?};
      {? _empty>0
      || _result:='nie ma określonych zasobów'@
      ?}
   ?};
   PX_OPER.cntx_pop();
   ~~
?};
PX_TEX.cntx_pop();
_result


\verifyconns
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Sprawdza poprawnosc podanej PX_TEX
::   WE: PX_TEX.ref()
::   WY: tekst bledu
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_result:='';
PX_TEX.cntx_psh(); PX_TEX.clear();
{? PX_TEX.seek(_a)
|| {? (+PXoTEX.kind.auto(''))+PX_TEX.KIND=PXoTEX.kind.auto('')
   || exec('PX_TEX_autoupd','px_auto',PX_TEX.ref())
   ?};
   PX_STAGE.cntx_psh(); PX_STAGE.clear();

   _can_continue:=1;
   PX_STAGE.index('TEX_NR');
   PX_STAGE.prefix(PX_TEX.ref());
   _px_stages:=0;
   {? PX_STAGE.first()
   || _px_stages:=1;
      {!
      |? {? PX_STAGE.CONN_OK='N'
         || _result:='ma niepoprawne powiązania między etapami';
            _can_continue:=0
         ?};
         PX_STAGE.next() & _can_continue>0
      !}
   ?};
:: Jesli przepis ma zawartosc w TKTL to badam tamte etapy
   {? _result='' & PX_TEX.TKTL<>null() & _px_stages=0
   ||
      PX_STAGE.index('TKTL_NR');
      PX_STAGE.prefix($PX_TEX.TKTL);
      {? PX_STAGE.first()
      || {!
         |? {? PX_STAGE.CONN_OK='N'
            || _result:='ma niepoprawne powiązania między etapami';
               _can_continue:=0
            ?};
            PX_STAGE.next() & _can_continue>0
         !}
      ?}
   ?};

   PX_STAGE.cntx_pop();
   ~~
?};
PX_TEX.cntx_pop();
_result


\verifyilosc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Sprawdza poprawnosc podanej PX_TEX pod wzgledem zerowych ilosci w operacjach
::   WE: _a - PX_TEX.ref()
::       _b - REAL - ilosc jaka bedzie umieszczana w planie
::   WY: tekst bledu
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;
_ilosc:=_b;

_result:='';
TKTL.cntx_psh();
PX_TEX.cntx_psh(); PX_TEX.clear();
{? PX_TEX.seek(_px_tex)
|| {? (+PXoTEX.kind.auto(''))+PX_TEX.KIND=PXoTEX.kind.auto('')
   || exec('PX_TEX_autoupd','px_auto',PX_TEX.ref())
   ?};
   PX_OPER.cntx_psh(); PX_OPER.clear();

:: 1. Sprawdzam PX_OPERy przypiete do PX_TEX
   PX_OPER.index('PXTEXKON');
   PX_OPER.prefix(PX_TEX.ref(),'T');
   {? PX_OPER.first()
   || _coef:=_ilosc/PX_TEX.XJM;
      {!
      |?
         _result:=exec('veryfyilosc','px_oper',PX_OPER.ref(),_coef);
         PX_OPER.next() & _result=''
      !}
   ?};

:: 2. Sprawdzam PX_OPERy przypiete do TKTL
   {? PX_TEX.TKTL<>null()
   || PX_OPER.index('TKTLAKT');
      PX_OPER.prefix(PX_TEX.TKTL,'T');
      {? PX_OPER.first()
      || _coef:=_ilosc/exec('FindAndGet','#table',TKTL,PX_TEX.TKTL,,"XJM",1);
         {!
         |? _result:=exec('veryfyilosc','px_oper',PX_OPER.ref(),_coef);
            PX_OPER.next()
         !}
      ?}
   ?};
   PX_OPER.cntx_pop();
   ~~
?};
PX_TEX.cntx_pop();
TKTL.cntx_pop();
_result


\verifysets
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Sprawdza poprawnosc etapow pod wzledem przypisania do zestawow planistycznych
::   WE: PX_TEX.ref()
::   WY: tekst bledu lub '' jesli wszystko ok
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::----------------------------------------------------------------------------------------------------------------------
_result:='';
PX_TEX.cntx_psh(); PX_TEX.clear();
{? PX_TEX.seek(_a)
|| {? (+PXoTEX.kind.auto(''))+PX_TEX.KIND=PXoTEX.kind.auto('')
   || exec('PX_TEX_autoupd','px_auto',PX_TEX.ref())
   ?};
   PX_STAGE.cntx_psh(); PX_STAGE.clear();

   _can_continue:=1;
   PX_STAGE.index('TEX_NR');
   PX_STAGE.prefix(PX_TEX.ref());
   _px_stages:=0;
   {? PX_STAGE.first()
   || _px_stages:=1;
      {!
      |? _stg_ver:=exec('px_set_verify','px_stage',,0);
         {? _stg_ver=0
         || _result:='ma etapy z zasobami należącymi do różnych zestawów planistycznych; szczegóły dostępne przez akcję \'przepis podGląd\''@;
            _can_continue:=0
         |? _stg_ver=-1
         || _result:='ma etapy nieprzypisane do zestawów planistycznych; szczegóły dostępne przez akcję \'przepis podGląd\''@;
            _can_continue:=0
         ?};
         PX_STAGE.next() & _can_continue>0
      !}
   ?};
:: Jesli przepis ma zawartosc w TKTL to badam tamte etapy
   {? _result='' & PX_TEX.TKTL<>null() & _px_stages=0
   ||
      PX_STAGE.index('TKTL_NR');
      PX_STAGE.prefix($PX_TEX.TKTL);
      {? PX_STAGE.first()
      || {!
         |? _stg_ver:=exec('px_set_verify','px_stage',,0);
            {? _stg_ver=0
            || _result:='ma etapy z zasobami należącymi do różnych zestawów planistycznych; szczegóły dostępne przez akcję \'przepis podGląd\''@;
               _can_continue:=0
            |? _stg_ver=-1
            || _result:='ma etapy nieprzypisane do zestawów planistycznych; szczegóły dostępne przez akcję \'przepis podGląd\''@;
               _can_continue:=0
            ?};
            PX_STAGE.next() & _can_continue>0
         !}
      ?}
   ?};
   PX_STAGE.cntx_pop();
   ~~
?};
PX_TEX.cntx_pop();
_result


\verifynast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Sprawdza poprawnosc etapow pod wzledem kolejności operacji i następników
::   WE: PX_TEX.ref()
::   WY: tekst bledu lub '' jesli wszystko ok
::----------------------------------------------------------------------------------------------------------------------
_result:='';
PX_TEX.cntx_psh(); PX_TEX.clear();
{? PX_TEX.seek(_a)
||
   _can_continue:=1;
   PX_NAST.cntx_psh(); PX_NAST.clear();

   PX_STAGE.cntx_psh();
   PX_STAGE.index('TEX_NR');
   PX_STAGE.prefix(PX_TEX.ref());
   _px_stages:=0;
   _nast_ok:=1;
   {? PX_STAGE.first()
   || _px_stages:=1;

      {? PX_STAGE.size()>1
      ||
::       Jeśli etapów więcej niż 1 to sprawdzam czy każdy ma przynajmniej jednego poprzednika lub następnika
         {!
         |?
            {? exec('px_nast_chk_required','px_stage')>0
            ||
               _has_nast:=0;
               PX_NAST.index('PX');
               PX_NAST.prefix(PX_STAGE.ref());
               {? PX_NAST.size()>0
               || _has_nast:=1
               ?};
               {? _has_nast=0
               || PX_NAST.index('NEXT');
                  PX_NAST.prefix(PX_STAGE.ref());
                  {? PX_NAST.size()>0
                  || _has_nast:=1
                  ?}
               ?};
               {? _has_nast=0
               || _nast_ok:=0
               ?}
            ?};
            PX_STAGE.next() & _nast_ok>0
         !}
      ?}
   ?};
:: Jesli przepis ma zawartosc w TKTL to badam tamte etapy
   {? _result='' & PX_TEX.TKTL<>null() & _px_stages=0
   ||
      PX_STAGE.index('TKTL_NR');
      PX_STAGE.prefix($PX_TEX.TKTL);
      {? PX_STAGE.first() & PX_STAGE.size()>1
      || {!
         |?
::          Jeśli etapów więcej niż 1 to sprawdzam czy każdy ma przynajmniej jednego poprzednika lub następnika
            _has_nast:=0;
            PX_NAST.index('PX');
            PX_NAST.prefix(PX_STAGE.ref());
            {? PX_NAST.size()>0
            || _has_nast:=1
            ?};
            {? _has_nast=0
            || PX_NAST.index('NEXT');
               PX_NAST.prefix(PX_STAGE.ref());
               {? PX_NAST.size()>0
               || _has_nast:=1
               ?}
            ?};
            {? _has_nast=0
            || _nast_ok:=0
            ?};
            PX_STAGE.next() & _nast_ok>0
         !}
      ?}
   ?};
   PX_STAGE.cntx_pop();

   {? _nast_ok=0
   || _can_continue:=0;
      _result:='ma nieprawidłowe powiązania etapów — etapy nie mają wymaganych poprzedników/następników'@
   ?};

   {? _can_continue>0
   ||
      PX_NAST.index('PXON');
      PX_NAST.prefix(PX_TEX.ref());
      _px_nast:=0;
      {? PX_NAST.first()
      || _px_nast:=1;
         {!
         |?
            _ver:=exec('verify','px_nast');
            {? _ver=-1
            || _can_continue:=0;
               _result:='ma nieprawidłowe powiązania etapów — nie zawierają źródła lub celu'@
            |? _ver=0
            || _can_continue:=0;
               _result:='ma nieprawidłowe powiązania etapów — występują niedozwolone nawroty; etapy powinny być powiązane zgodnie z rosnącą kolejnością etapów'@
            ?};
            PX_NAST.next() & _can_continue>0
         !}
      ?};
::    Jesli przepis ma zawartosc w TKTL to badam tamte etapy
      {? _result='' & PX_TEX.TKTL<>null() & _px_nast=0
      ||
         PX_NAST.index('TKON');
         PX_NAST.prefix($PX_TEX.TKTL);
         {? PX_NAST.first()
         || {!
            |?
               _ver:=exec('verify','px_nast');
               {? _ver=-1
               || _can_continue:=0;
                  _result:='ma nieprawidłowe powiązania etapów — nie zawierają źródła lub celu'@
               |? _ver=0
               || _can_continue:=0;
                  _result:='ma nieprawidłowe powiązania etapów — występują niedozwolone nawroty; etapy powinny być powiązane zgodnie z rosnącą kolejnością etapów'@
               ?};
               PX_NAST.next() & _can_continue>0
            !}
         ?}
      ?}
   ?};
   PX_NAST.cntx_pop();
   ~~
?};
PX_TEX.cntx_pop();
_result


\verifycoop
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [18.42]
:: OPIS: Weryfikuje podany przepis pod dat dla kooperacji. Póki co używane tylko w ścieżce
::       symulacji zlecenia
::   WE: _a - PX_TEX.ref()
::       _b - REAL - ilość
::       _c - PX_GRP.ref
::   WY: STRING - tekst bledu lub '' jesli wszystko ok
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;
_ilosc:=_b;

_result:='';
_pxpack:=exec('trzepaczka','px_tex',_px_tex,_ilosc);

_paczka:=_pxpack.Paczka;
_paczka.index(_pxpack.Ndx_fwd);
_paczka.prefix('K');
{? _paczka.first()
|| {!
   |?
::    Jeśli kooperacja i czasy na kooperacji podane to badam czy nie są w przeszłości
      {? _paczka.COOP>0 & _paczka.TM_START>0 & _paczka.TM_END>0
      || {? _paczka.TM_START<SYSLOG.tm_stamp() | _paczka.TM_END<SYSLOG.tm_stamp()
         || _result:='ma nieprawidłowe daty dla kooperacji (w przeszłości)'
         ?}
      ?};
      _paczka.next() & _result=''
   !}
?};
_result


\is_empty
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy podany przepis planistyczny jest pusty, czy nie
::   WE: _a - PX_TEX.ref()
::   WY: 0 - pelny
::       1 - pusty
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;

_result:=1;

PX_TEX.cntx_psh(); PX_TEX.clear();
{? PX_TEX.seek(_px_tex)
|| PX_STAGE.cntx_psh();
   _src:=exec('content_src','px_tex',PX_TEX.ref());
   {? _src=exec('content_tktl','px_tex')
   || PX_STAGE.index('TKTL_NR');
      PX_STAGE.prefix(PX_TEX.RTKTL);
      {? PX_STAGE.size()>0
      || _result:=0
      ?}
   |? _src=exec('content_own','px_tex')
   || PX_STAGE.index('TEX_NR');
      PX_STAGE.prefix(PX_TEX.ref());
      {? PX_STAGE.size()>0
      || _result:=0
      ?}
   ?};
   PX_STAGE.cntx_pop()
?};
PX_TEX.cntx_pop();
_result


\content_src
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza pochodzenie PX_TEX
::   WE: _a - PX_TEX.ref()
::   WY: STRING - exec('content_*','px_tex')
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;

_result:='';
PX_TEX.cntx_psh(); PX_TEX.clear();
{? PX_TEX.seek(_px_tex)
|| {? PX_TEX.RTKTL<>''
   || _result:=exec('content_tktl','px_tex')
   || _result:=exec('content_own','px_tex')
   ?}
?};
PX_TEX.cntx_pop();
_result


\content_own
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Pochodzenie PX_TEX - powstal normalnie, powinien zawierac PX_STAGEe
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'OWN'


\content_tktl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Pochodzenie PX_TEX - powstal na podstawie TKTL i sam nie zawiera zadnych PX_STAGEow
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'TKTL'


\zl_tex_update
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Uaktualnia (generuje od nowa zawartosc) przepisu planistycznego dla technologii
::   WE: _a - ZL.ref()
::       _b - INTEGER - [1]/2 - komunikaty o niepowodzeniu: 1 - na ekran
::                                                          2 - do KOMMa
::       _c - INTEGER - [1]/2   - tryb aktualizacji: 1 - wycina wszystko i robi od nowa
::                                                   2 - dodaje do przepisu wyłącznie brakujące ZGPy
::                                                       (przydatne na zleceniu częściowo wykonanym)
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_kom:=1;
{? var_pres('_b')=type_of(0)
|| _kom:=_b
?};

_mode:=1;
{? var_pres('_c')=type_of(0)
|| _mode:=_c
?};

_rodzaj:='P';
_result:=0;
_can_continue:=1;
_mainver:=exec('get_mainversion','px_ver');
_old_tex:=null();

:: Obiekt do obslugi przepisow
{? var_pres('PxTex')<100
|| PxTex:=exec('PxTex_Create','px_tex',exec('get','#params',8055,,OPERATOR.USER))
?};

:: Jesli nie ma psotka to go powoluje
exec('PXoTEX_chk','px_tex');
PX_TEX.cntx_psh();
ZL.cntx_psh(); ZL.clear();
{? ZL.seek(_zl)
||
   ZL.TEX_SRC:='';
   _can_continue:=ZL.put();

:: w przypadku zlecenia zlozonego moze byc iny sosob generowania przepisu, co jest istotne dlej
   {? ZL.RODZAJ='Z' || _rodzaj:=ZL.RODZ_TEX ?};

   _px_obj:=exec('get_zl_object','px_obj',ZL.ref());

:: Jesli nie ma obiektu planistycznego dla zlecenia to go generuje
   {? _px_obj=null()
   || {? exec('zl2obj','px_obj')>0
      || _px_obj:=exec('get_zl_object','px_obj',ZL.ref())
      ?}
   ?};

:: jak nie powstal obiekt to nie do czego generowac
:: oraz nie wolno generowac do naglowka zlecenia zlozonego gdy przeisy proste
   {? (_px_obj<>null()) & (~((ZL.RODZAJ='Z') & (ZL.RODZ_TEX='P')))
   ||
      {? _mode=1
      ||
::       Jesli zlecenie jest w planie glownym to sprawdzam czy sa jakies wykonania i jesli sa to nie aktualizuje
         PX_WYK.cntx_psh();
         PX_WYK.index('PX_OBJ');
         PX_GRP.cntx_psh();
         PX_GRP.clear();
         PX_CONN.cntx_psh();
         PX_CONN.index('VER');
         PX_CONN.prefix(_mainver,_px_obj);
         {? PX_CONN.first()
         || {!
            |?
               PX_WYK.prefix(_mainver,PX_CONN.PX_OBJ);
               {? PX_WYK.size()>0
               || _can_continue:=0;
                  _msg:='Aktualizacja przepisu planistycznego dla zlecenia: %1 zakończona niepowodzeniem: zarejestrowano wykonania.'@[ZL.SYM];
                  {? _kom=1
                  || FUN.emsg(_msg)
                  |? _kom=2
                  || KOMM.add(_msg,2,,1)
                  ?}
               ?};
               PX_CONN.next() & _can_continue>0
            !}
         ?};
         PX_CONN.cntx_pop();
         PX_GRP.cntx_pop();
         PX_WYK.cntx_pop()
      ?};

      {? _can_continue>0
      ||
         PX_TEX.index('ZLASYM');
         PX_TEX.prefix(_zl,'T');

         {? PX_TEX.first()
         ||
            {? _mode=1
            ||
::             Jesli jest przepis dla zlecenia to sprawdzam czy jest powiazany w planie
::             jesli jest powiazany, to zamiast usuwac przepisu, trzeba go dezaktywowac i wygenerowac nowy ale pusty
               _used:=exec('used_in_plan','px_tex',PX_TEX.ref(),_px_obj);
               {? _used
               ||
::                Ustawiam przepisowi nieaktywnosc
                  {? exec('set_active','px_tex',PX_TEX.ref(),'N')>0
                  ||
::                   Zapamietuje przepis ktory zdezaktywowalem
                     _old_tex:=PX_TEX.ref();
::                   Generuje nowy aktywny przepis
                     PX_TEX.cntx_psh();
                     PX_TEX.clear();
                     exec('AutoPX4PX_OBJ','px_auto',_px_obj,0);
                     PX_TEX.cntx_pop()
                  ?}
               ?}
            ?}
         ||
::          Jesli nie ma PX_TEX dla zlecenia to go generuje
            PX_TEX.cntx_psh();
            PX_TEX.clear();
            exec('AutoPX4PX_OBJ','px_auto',_px_obj,0);
            PX_TEX.cntx_pop()
         ?};

         {? PX_TEX.first()
         ||
            _zl_tex:=PX_TEX.ref();
::          Jesli dezaktywowalem przepis i tworzylem nowy to musze podmienic na ten nowy we wszystkich
::          grupach w kolejce ktore uzywaly starego przepisu
            {? _old_tex<>null() & _old_tex<>PX_TEX.ref()
            || PX_GRP.cntx_psh();
               PX_GRP.index('PX_TEX');
               PX_GRP.prefix(_old_tex);
               {? PX_GRP.first()
               || {!
                  |? PX_GRP.cntx_psh();
                     PX_GRP.clear();
                     PX_GRP.PX_TEX:=PX_TEX.ref();
                     _can_continue:=PX_GRP.put();
                     PX_GRP.cntx_pop();
                     PX_GRP.first() & _can_continue>0
                  !}
               ?};
               PX_GRP.cntx_pop()
            ?};

            {? _mode=1
            ||
::             Jesli zlecenie jest w planie glownym to musze usunac plan na podstawie starego przepisu
::             i wygenerowac plan w tym samym miejscu wg nowego przepisu
               PX_GRP.cntx_psh();
               PX_GRP.clear();
               PX_CONN.cntx_psh();
               PX_CONN.index('VER');
               PX_CONN.prefix(_mainver,_px_obj);
               {? PX_CONN.first()
               || {!
                  |? _can_continue:=exec('clean_from_plan','px_grp',PX_CONN.PX_GRP,2);
                     {? _can_continue>0
                     || _can_continue:=exec('clean_from_plan','px_obj',PX_CONN.PX_OBJ,_mainver,,2)
                     ?};
                     PX_CONN.next() & _can_continue>0
                  !}
               ?};
               PX_CONN.cntx_pop();
               PX_GRP.cntx_pop();

::             Usuwam dotychczasowa zawartosc przepisu
               exec('clean_stages','px_tex',_zl_tex)
            ?};
::          Sprawdzam na podstawie czego wygenerowac przepis planistyczny, kolejnosc okresla waznosc
            _tex_src:='';
::          1. Generowanie przepisu na podstawie przewodnikow zlecenia
            {? _tex_src=''
            ||
::             sprawdzenie czy sa przewodniki jezeli nie sa generowane do naglowka
               _zgh_present:=exec('chk_zgh4update','px_tex');
               ZGH.cntx_psh();
               ZGH.index('ZLNR');
               ZGH.prefix(ZL.ref());
               {? _zgh_present>0
               ||
::                Import PX_STAGE i PX_OPER na podstawie ZGP
                  {? var_pres('_argsimp')>100
                  || obj_del(_argsimp)
                  ?};
                  _argsimp:=exec('import_zgp_a','px_oper');
                  _argsimp.ZLsrc:=ZL.ref();
                  _argsimp.PX_TEXd:=_zl_tex;
                  _argsimp.MODE:=_mode;
                  _argsimp.KIND:=_rodzaj;
                  _can_continue:=exec('import_zgp','px_oper',_argsimp);
                  {? _can_continue>0
                  || PX_TEX.PX_RULES:=PXoTEX.Rules.tex_own;
                     {? ZL.IL<>0
                     || PX_TEX.XJM:=ZL.IL
                     ?};
                     PX_TEX.TKTL:=null();
                     _can_continue:=PX_TEX.put();
                     {? _can_continue>0
                     || _interzlec:=0;
                        {? ZL.RODZ_TEX='Z'
                        || _interzlec:=1
                        ?};
                        _can_continue:=exec('zgp2stage','px_nast',ZL.ref,_interzlec);
                        {? _can_continue>0
                        || _tex_src:='ZGH';
                           ZL.TEX_SRC:=_tex_src;
                           _can_continue:=ZL.put()
                        ?}
                     ?}
                  ?}
               ?};
               ZGH.cntx_pop()
            ?};

::          2. Generowanie przepisu na podstawie technologii zlecenia
            {? _tex_src=''
            ||
::             jezeli generowany jest przepis zintegrowany, to trzeba go budowac na karcie 1 podzlecenia
               ZL.cntx_psh();
               {? _rodzaj='Z'
               || _rzlp:=exec('main_podzlec','zl_link',ZL.ref());
                  {? _rzlp<>null() || ZL.prefix(); ZL.seek(_rzlp) ?}
               ?};
               {? ZL.TYP().TECH='T'
               ||
                  TOPER.cntx_psh();
                  TOPER.index('NNN');
                  TOPER.prefix(ZL.TKTL);
                  {? TOPER.size()>0
                  ||
::                   Sa juz TOPERy zlecenia wiec generuje na ich podstawie
                     {? var_pres('_argsimp')>100
                     || obj_del(_argsimp)
                     ?};
                     _nast:=exec('pxnasttab','px_nast');
                     _argsimp:=exec('import_toper_a','px_oper');
                     _argsimp.Complex:='N';
                     _argsimp.TKTLsrc:=ZL.TKTL;
                     {? _rodzaj='Z' || _argsimp.Complex:='T' ?};
                     _argsimp.PX_TEXd:=_zl_tex;
                     _can_continue:=exec('import_toper','px_oper',_argsimp,_nast);
                     {? _can_continue>0
                     || _can_continue:=exec('importtoper','px_nast',_nast)
                     ?};
                     _nast.drop();
                     {? _can_continue>0
                     || PX_TEX.PX_RULES:=PXoTEX.Rules.tex_own;
                        PX_TEX.XJM:=exec('FindAndGet','#table',TKTL,ZL.TKTL,,"XJM",1);
                        PX_TEX.TKTL:=null();
                        _can_continue:=PX_TEX.put();
                        {? _can_continue>0
                        || _tex_src:='TKTL_ZL';
                           ZL.TEX_SRC:=_tex_src;
                           _can_continue:=ZL.put()
                        ?}
                     ?}
                  ||
                     PX_TEX.PX_RULES:=PXoTEX.Rules.tex_tex;
                     PX_TEX.XJM:=exec('FindAndGet','#table',TKTL,ZL.KTL,,"XJM",1);
                     PX_TEX.TKTL:=ZL.KTL;
                     _can_continue:=PX_TEX.put();
                     {? _can_continue>0
                     || _tex_src:='PROTOTYP';
                        ZL.TEX_SRC:=_tex_src;
                        _can_continue:=ZL.put()
                     ?}
                  ?};
                  TOPER.cntx_pop()
               ?};
               ZL.cntx_pop()
            ?};

::          3. Generowanie przepisu na podstawie technologii zwyklej (zlecenie bez technologii wlasnej)
            {? _tex_src=''
            || {? ZL.TYP().TECH='N' & ZL.KTL<>null() & ~exec('tktl_act','tech_head',1)
               || PX_TEX.PX_RULES:=PXoTEX.Rules.tex_tex;
                  PX_TEX.XJM:=exec('FindAndGet','#table',TKTL,ZL.KTL,,"XJM",1);
                  PX_TEX.TKTL:=ZL.KTL;
                  _can_continue:=PX_TEX.put();
                  {? _can_continue>0
                  || _tex_src:='TKTL';
                     ZL.TEX_SRC:=_tex_src;
                     _can_continue:=ZL.put()
                  ?}
               ?}
            ?};

            {? exec('is_px_set','px_param')>0
            ||
::             Ponowne ustalenie planistycznego zestawu startowego
               exec('update_px_set','px_obj',_px_obj);
::             Aktualizacja PX_GRPsow
               PX_GRP.cntx_psh();
               PX_CONN.cntx_psh();
               PX_CONN.index('VER');
               PX_CONN.prefix(_mainver,_px_obj);
               {? PX_CONN.first()
               ||
                  {!
                  |?
                     PX_CONN.PX_GRP();
                     _can_continue:=exec('refresh','px_grps',0);
                     PX_CONN.next() & _can_continue>0
                  !}
               ?};
               PX_CONN.cntx_pop();
               PX_GRP.cntx_pop()
            ?};


::          Po wygenerowaniu nowego przepisu musze przeplanowac wszystkie grupy w ktorych bylo zlecenie
            {? _can_continue>0
            || PX_GRP.cntx_psh();
               PX_CONN.cntx_psh();
               PX_CONN.index('VER');
               PX_CONN.prefix(_mainver,_px_obj);
               {? PX_CONN.first()
               || _argsfast:=exec('fast_replan_a','px_logix');
                  {!
                  |?
                     _argsfast.PX_GRP:=PX_CONN.PX_GRP;

::                   Usuwam komunikaty
                     _typ1:=exec('type_error','px_komm');
                     _typ2:=exec('type_warning','px_komm');
                     _typ3:=exec('type_info','px_komm');
                     exec('del_kommy','px_komm','PX_GRP',PX_CONN.PX_GRP,_typ1);
                     exec('del_kommy','px_komm','PX_GRP',PX_CONN.PX_GRP,_typ2);
                     exec('del_kommy','px_komm','PX_GRP',PX_CONN.PX_GRP,_typ3);

                     _can_continue:=exec('grp_fast_replan','px_logix',_argsfast);
                     PX_CONN.next() & _can_continue>0
                  !}
               ?};
               {? _can_continue>0 || exec('one_conn_act','px_plan',_px_obj,_mainver) ?};
               PX_CONN.cntx_pop();
               PX_GRP.cntx_pop()
            ?}

         || FUN.wdrerror('Próba aktualizacji na zleceniu przepisu planistycznego, którego nie ma, lub jest nieaktywny.')
         ?}
      ?}
   ?}
?};
PX_TEX.cntx_pop();
PX_TEX.get();
ZL.cntx_pop();
ZL.get();
{? _can_continue>0
|| _result:=1
?};
_result


\zl_tex_simply
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Generowanie prostych przepisow dla kazdego podzlecenia
::   WE: [_a] - ZL.ref() lub VAR.A_ZLEC
::       [_b] - INTEGER - 0/[1] - czy wyświetlać dialogi
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_zl:=VAR.A_ZLEC;
{? var_pres('_a')=type_of(ZL.ref())
|| _zl:=_a
?};
_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_result:=0;
_can_continue:=1;

_what:=exec('record','#to_string',_zl);
{? _dialog>0
|| _msg:='Aktualizować przepis zlecenia: %1?\n\n'
         'Przepis zostanie wygenerowany od nowa, nadpisując wszystkie dotychczasowe zmiany.'@[_what];
   _can_continue:=FUN.ask(_msg)
?};

{? _can_continue>0 & _dialog>0
||
   _zgh_check:=exec('chk_zgh4update','px_tex',_zl);
   ZL.cntx_psh(); ZL.prefix();
   {? ZL.seek(_zl)
   || {? ZL.TYP().TECH='T' & ZL.TKTL=null() & _zgh_check=0
      || _msg:='Zlecenie %1 nie ma jeszcze własnej technologii ani przewodników.\n\n'
               'Przepis zostanie skopiowany ze źródłowej karty technologicznej.'@[_what];
         FUN.info(_msg)
      ?}
   ?};
   ZL.cntx_pop();
   ~~
?};

{? _can_continue>0
||
   Cntx.psh(ZL,VAR,TKTL,TOPER,TMAT,NASTOPER,ZGH,ZGP,PX_TEX,PX_OPER,PX_NAST,PX_OBJ,PX_STAGE,PX_GRP,PX_GRPS);
   ZL.clear();
   {? ZL.seek(_zl)
   ||
      {? _dialog>0 || KOMM.init(250,,'Aktualizacja przepisów planistycznych zlecenia: %1'@[exec('ZL','#to_string')]) ?};

      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      VAR.cntx_psh();

      _locked:=exec('ref_table','#table');
::    W pierwszym przebiegu sprawdzam czy ktorys przepis nie zostal zablokowany przez innego usera
      _px_tex:=exec('get_tex_zl','px_tex',ZL.ref());

      {? _px_tex<>null()
      ||
::       Jeśli przepis istnieje to go blokuje do redakcji
         _lock_res:=exec('lock','px_tex',_px_tex,1);
         _can_continue:=_lock_res.LOCKED;
         {? _lock_res.PX_TEX<>null()
         || _locked.add(_lock_res.PX_TEX)
         ?};
         {? _lock_res.TKTL<>null()
         || _locked.add(_lock_res.TKTL)
         ?};
         ~~
      ?};

      {? _can_continue>0
      || {? exec('warn_zgh_akc','px_tex',ZL.ref(),{? _dialog>0 || 1 || 2 ?})=0
         || _can_continue:=0
         ?}
      ?};
      {? _can_continue>0
      || {? exec('warn_str_akc','px_tex',ZL.ref(),{? _dialog>0 || 1 || 2 ?})=0
         || _can_continue:=0
         ?}
      ?};

::    W drugim przebiegu aktualizuje przepisy
      {? _can_continue>0
      ||
         {? exec('zl_tex_update','px_tex',ZL.ref(),{? _dialog || 1 || 2 ?})=0
         || _can_continue:=0
         ?}
      ?};

::    dodajemy przebieg by nakrecic powiazania
      {? _can_continue>0
      ||
         ZGH.cntx_psh(); ZGH.index('ZLNR');
         ZGH.prefix(ZL.ref());
         {? ZGH.first() || exec('zgp2stage','px_nast',ZL.ref,0) ?};
         ZGH.cntx_pop()
      ?};

      VAR.cntx_pop();

::    W ostatnim przebiegu odblokowuje zablokowane przepisy
      _unlock_res:=exec('lock_result','px_tex');
      _locked.tab.clear();
      {? _locked.tab.first()
      || {!
         |?
            {? var_pres('_alias')>100
            || obj_del(_alias)
            ?};
            _alias:=ref_tab(_locked.tab.SQL);
            {? type_of(_alias)>100
            || _unlock_res.TAB:=2-!_alias
            || _unlock_res.TAB:=''
            ?};
            _unlock_res.NAME:=_locked.tab.NAME;
            _unlock_res.REF:=_locked.tab.REF;
            exec('unlock','px_tex',_unlock_res);
            _locked.tab.next()
         !}
      ?};
      ~~
   ?};
   Cntx.pop(ZL,VAR,TKTL,TOPER,TMAT,NASTOPER,ZGH,ZGP,PX_TEX,PX_OPER,PX_NAST,PX_OBJ,PX_STAGE,PX_GRP,PX_GRPS)
?};
{? _can_continue>0
|| _result:=1
|| {? _dialog>0 || KOMM.select() ?}
?};
_result


\zl_tex_complex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Wygenerowanie pojedynczego przepisu zintegrowanego dla rodzaju Z
::   WE: [_a] - ZL.ref() lub VAR.A_ZLEC
::       [_b] - INTEGER - 0/[1] - czy wyświetlać dialogi
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_zl:=VAR.A_ZLEC;
{? var_pres('_a')=type_of(ZL.ref())
|| _zl:=_a
?};
_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_result:=0;
_can_continue:=1;

{? _dialog>0
|| _what:=exec('record','#to_string',_zl);
   _msg:='Aktualizować przepis zlecenia: %1?\n\n'
         'Przepis zostanie wygenerowany od nowa, nadpisując wszystkie dotychczasowe zmiany.'@[_what];
   _can_continue:=FUN.ask(_msg)
?};

{? _can_continue>0
||
   Cntx.psh(ZL,VAR,TKTL,TOPER,TMAT,NASTOPER,ZGH,ZGP,PX_TEX,PX_OPER,PX_NAST,PX_OBJ,PX_STAGE,PX_GRP,PX_GRPS);
   ZL.clear();
   {? ZL.seek(_zl)
   ||
      {? _dialog>0 || KOMM.init(250,,'Aktualizacja przepisu zintegrowanego zlecenia: %1'@[exec('ZL','#to_string')]) ?};

::    W pierwszym przebiegu sprawdzam czy przepis nie zostal zablokowany przez innego usera
      _px_tex:=exec('get_tex_zl','px_tex',_zl);
      _tktl:=exec('FindAndGet','#table',PX_TEX,_px_tex,,"TKTL",null());
      VAR.cntx_psh();
      _lock_res:=~~;

      {? _px_tex<>null()
      ||
::       Jeśli przepis istnieje to go blokuje do redakcji
         _lock_res:=exec('lock','px_tex',_px_tex,1);
         _can_continue:=_lock_res.LOCKED;
         ~~
      ?};
      {? _can_continue>0
      ||
         {? exec('warn_zgh_akc','px_tex',_zl,{? _dialog>0 || 1 || 2 ?})=0
         || _can_continue:=0
         ?};
         {? exec('warn_str_akc','px_tex',_zl,{? _dialog>0 || 1 || 2 ?})=0
         || _can_continue:=0
         ?};

::       W drugim przebiegu aktualizuje przepis
         {? _can_continue>0
         || {? exec('zl_tex_update','px_tex',_zl,{? _dialog>0 || 1 || 2 ?})=0
            || _can_continue:=0
            ?}
         ?};

::       dodajemy przebieg by nakrecic powiazania

         ZL.cntx_psh();
         ZL.index('NRNZL');
         ZL.prefix(ZL.UNRZL);
         {? _can_continue>0
         || ZGH.cntx_psh(); ZGH.index('ZLNR');
            {? ZL.first()
            ||
               {!
               |?
                  ZGH.prefix(ZL.ref());
                  {? ZGH.first() || exec('zgp2stage','px_nast',ZL.ref) ?};
                  ZL.next()
               !}
            ?};
            ZGH.cntx_pop()
         ?};
         ZL.cntx_pop();

         {? ZL.TEX_SRC='ZGH'
         || exec('renall_complex','px_stage',_zl)
         ?};
         ~~
      ?};
      VAR.cntx_pop();
::    Pod koniec odblokowanie przepisu
      {? _px_tex<>null()
      || exec('unlock','px_tex',_lock_res)
      ?};
      ~~
   ?};
   Cntx.pop(ZL,VAR,TKTL,TOPER,TMAT,NASTOPER,ZGH,ZGP,PX_TEX,PX_OPER,PX_NAST,PX_OBJ,PX_STAGE,PX_GRP,PX_GRPS);

   {? _can_continue>0
   || _result:=1
   || {? _dialog>0 || KOMM.select() ?}
   ?}
?};
_result


\get_tex_zl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca najbardziej aktualny przepis planistyczny dla zlecenia
::   WE: _a - ZL.ref()
::   WY: PX_TEX.ref() lub null()
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=null();
PX_TEX.cntx_psh();
PX_TEX.index('ZLASYM');
PX_TEX.prefix(_zl,'T');
{? PX_TEX.last()
|| _result:=PX_TEX.ref()
?};
PX_TEX.cntx_pop();
_result


\get_tex_tktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Zwraca najbardziej aktualny przepis planistyczny dla technologii
::   WE: _a - $TKTL.ref()
::   WY: PX_TEX.ref() lub null()
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

_result:=null();
PX_TEX.cntx_psh();
PX_TEX.index('TKTLMSYM');
PX_TEX.prefix(_tktl,);
{? PX_TEX.last()
|| _result:=PX_TEX.ref()
?};
PX_TEX.cntx_pop();
_result


\get_tex_obj
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca pierwszy przepis uzyty w planie dla podanego obiektu
::   WE: _a - PX_OBJ.ref()
::   WY: PX_TEX.ref() lub null()
::----------------------------------------------------------------------------------------------------------------------
_px_obj:=_a;

_result:=null();

_mainver:=exec('get_mainversion','px_ver');
PX_GRP.cntx_psh();
PX_CONN.cntx_psh();
PX_CONN.index('VER');
PX_CONN.prefix(_mainver,_px_obj);
{? PX_CONN.first()
||
:: Zwracam przepis z pierwszego PX_GRPa do ktorego nalezy PX_OBJ
   _result:=PX_CONN.PX_GRP().PX_TEX
?};
PX_CONN.cntx_pop();
PX_GRP.cntx_pop();
_result


\used_in_plan
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy do podanego przepisu istnieja powiazania w planie
::   WE: [_a] - PX_TEX.ref() - przepis lub bieżący rekord
::       [_b] - PX_OBJ.ref() - obiekt planistyczny, jeśli nie podany to sprawdza dla wszystkich
::   WY: 0 - brak powiazan
::       1 - sa powiazania
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_TEX.ref())
|| _ref:=_a
?};

_px_obj:=null();
{? var_pres('_b')=type_of(PX_OBJ.ref())
|| _px_obj:=_b
?};

_result:=0;
_can_continue:=1;

PX_TEX.cntx_psh();
{? _ref<>null()
|| PX_TEX.prefix();
   {? PX_TEX.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_STAGE.cntx_psh();
   {? PX_TEX.TKTL<>null()
   || PX_STAGE.index('TKTL_NR');
      PX_STAGE.prefix($PX_TEX.TKTL)
   || PX_STAGE.index('TEX_NR');
      PX_STAGE.prefix(PX_TEX.ref())
   ?};

   PX_POZ.cntx_psh();
   {? _px_obj<>null()
   || PX_POZ.index('PX_STAG1')
   || PX_POZ.index('PX_STAG2')
   ?};
   {? PX_STAGE.first()
   || {!
      |? {? _px_obj<>null()
         || PX_POZ.prefix(_px_obj,PX_STAGE.ref())
         || PX_POZ.prefix(PX_STAGE.ref())
         ?};
         {? PX_POZ.size()>0
         || _result:=1;
            _can_continue:=0
         ?};
         PX_STAGE.next() & _can_continue>0
      !}
   ?};
   PX_POZ.cntx_pop();
   PX_STAGE.cntx_pop();
   ~~
?};
PX_TEX.cntx_pop();
_result


\used_in_queue
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy podany przepis jest uzywany w kolejce planu w danej wersji
::   WE: _a - PX_TEX.ref()
::       _b - PX_VER.ref()
::   WY: 0 - brak powiazan
::       1 - sa powiazania
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;
_px_ver:=_b;

_result:=0;
_can_continue:=1;

PX_TEX.cntx_psh(); PX_TEX.clear();
PX_POZ.cntx_psh();
PX_GRP.cntx_psh();
PX_GRP.index('PX_TEX2');
{? PX_TEX.seek(_px_tex)
|| PX_GRP.prefix(_px_ver,PX_TEX.ref());
   {? PX_GRP.size()>0
   || _result:=1
   ?}
?};
PX_GRP.cntx_pop();
PX_POZ.cntx_pop();
PX_TEX.cntx_pop();
_result


\set_active
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Ustawia aktywnosc dla podanego przepisu
::   WE: _a - PX_TEX.ref()
::       _b - STRING - ustawiany stan aktywnosci przepisu: 'T' lub 'N'
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;
_status:=_b;

_result:=0;

PX_TEX.cntx_psh(); PX_TEX.clear();
PX_TEX.index('SYMBOL');
{? PX_TEX.seek(_px_tex)
|| PX_TEX.AKT:=_status;
   _result:=PX_TEX.put()
?};
PX_TEX.cntx_pop();
PX_TEX.get();
_result


\conns_ok
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy w danym przepisie znajduja sie PX_STAGE ktore maja niepoprawnie zaimportowane powiazania
::       Poniewaz podczas importu przepisu z technologii powiazania (nastepniki) na PX_STAGE mogly sie nie dodac
::       z powodu tego ze przepis nie obsluguje rownoleglosci operacji, niektore PX_STAGE maja informacje o tym
::       ze import powiazan sie nie udal i takiego przepisu nie mozna uzyc w planie
::   WE: _a - TKTL.ref() lub PX_TEX.ref()
::   WY: 1 - w przepisie nie ma PX_STAGE o niepoprawnych powiazaniach
::       0 - w przepisie sa PX_STAGE ktorym nie zaimportowaly sie powiazania
::----------------------------------------------------------------------------------------------------------------------
_RootRef:=_a;

_result:=1;

_PXorTKTL:=exec('PX_STAGE_prefix','px_stage',_RootRef);
{? _PXorTKTL<>''
|| {? PX_STAGE.first()
   || {!
      |? {? PX_STAGE.CONN_OK='N'
         || _result:=0
         ?};
         PX_STAGE.next() & _result>0
      !}
   ?}
?};
_result


\pars_init
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Zwraca zadeklarowany i wypelniony obiekt klasy do obslugi parametrow technologii dla
::       przekazanego przepisu lub technologii
::   WE: _a - TKTL.ref() lub PX_TEX.ref()
::   WY: CLASS - obiekt do obslugi parametrow technologii
::----------------------------------------------------------------------------------------------------------------------
_RootRef:=_a;

_result:=~~;
{? ref_name(_RootRef)=TKTL.name()
|| {? exec('FindAndGet','#table',TKTL,#_RootRef,,"TYP().PAR='T'",0)
   || exec('start_tpar','tech_param',null(),_RootRef);
      _result:=tpar
   ?}
|? ref_name(_RootRef)=PX_TEX.name()
|| {? exec('FindAndGet','#table',PX_TEX,#_RootRef,,"TKTL().TYP().PAR='T'",0)
   || exec('start_xpar','tech_param',_RootRef);
      _result:=xpar
   ?}
?};
_result


\xjm_set
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Aktualizuje wspolczynnik xjm na PX_TEX
::   WE: _a - PX_TEX.ref()
::       _b - REAL - nowy XJM
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;
_xjm:=_b;

_result:=0;

PX_TEX.cntx_psh();
PX_TEX.clear();
{? PX_TEX.seek(_px_tex)
|| PX_TEX.XJM:=_xjm;
   _result:=PX_TEX.put()
?};
PX_TEX.cntx_pop();
_result


\recalculate_use
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Przelicza zuzycia normatywne na podstawie podanego przelicznika
::   WE: _a - PX_TEX.ref()
::       _b - REAL - mnoznik norm
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;
_coef:=_b;

_result:=0;
_can_continue:=1;

PX_TEX.cntx_psh(); PX_TEX.clear();
PX_OPER.cntx_psh();

{? PX_TEX.seek(_px_tex)
|| PX_OPER.index('UNIQALL');

   PX_STAGE.cntx_psh();
   PX_STAGE.index('TEX_NR');
   PX_STAGE.prefix(PX_TEX.ref());
   {? PX_STAGE.first()
   || {!
      |? PX_OPER.prefix(PX_STAGE.ref());
         {? PX_OPER.first()
         || {!
            |? _can_continue:=exec('recalculate_use','px_oper',PX_OPER.ref(),_coef);
               PX_OPER.next() & _can_continue>0
            !}
         ?};
         PX_STAGE.next() & _can_continue>0
      !}
   ?};
   PX_STAGE.cntx_pop()
?};
PX_OPER.cntx_pop();
PX_TEX.cntx_pop();
_result


\get_ver_nxt
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca kolejny numer wersji dla podanego PX_TEX
::   WE: _a - STRING - symbol PX_TEX dla ktorego numer wersji wygenerowac
::       [_b] - INTEGER - o ile powiekszac numer kolejnej wersji wzgledem rozmiaru dziedziny
::                        (domyslnie=1)
::   WY: STRING - kolejny numer wersji np. 2.0
::----------------------------------------------------------------------------------------------------------------------
_tex_sym:=_a;
_increment:=1;
{? var_pres('_b')=type_of(0)
|| _increment:=_b
?};

_result:='';

PX_TEX.cntx_psh();
PX_TEX.clear();
PX_TEX.index('SYMBOL');
PX_TEX.prefix(_tex_sym,_tex_sym);
_new_num:=PX_TEX.size()+_increment;
_can_continue:=1;
{!
|? _new_symbol:=form(_new_num,,1,'9.');
   PX_TEX.prefix(_tex_sym,_tex_sym,_new_symbol);
   {? PX_TEX.size()>0
   ||
::    Jesli taki symbol i wersja juz jest to kontyynuuje petle, szukam kolejnego numeru wersji
      _can_continue:=1
   ||
::    nie ma takiego jeszcze wiec zwracam
      _can_continue:=0;
      _result:=_new_symbol
   ?};
   _new_num+=1;
   _can_continue>0
!};
PX_TEX.cntx_pop();
_result


\zl_tex_upd_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Akcja - ręczna aktualizacja przepisu z menu użytkownika
::       Kontekst pracy - VAR.A_ZLEC
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
::funkcji nie wolno uruchomic dla podzlecenia, ktore jest podzleceniem zlecenia zlozonego rodzaju Z
_top_level:=exec('top_level','zl_link',VAR.A_ZLEC);
_top_rodzaj:=exec('top_rodzaj','zl_link',VAR.A_ZLEC);
_top_rodz_tex:=exec('FindAndGet','#table',ZL,_top_level,,"RODZ_TEX",'');
{? _top_level<>VAR.A_ZLEC & _top_rodzaj<>'P' & _top_rodz_tex='Z'
|| FUN.emsg('Aktualizacja przepisu możliwa tylko od strony zlecenia nadrzędnego.'@)
||
   _msg:='Aktualizować przepis zlecenia?\n\n'
         'Przepis zostanie wygenerowany od nowa, nadpisując wszystkie dotychczasowe zmiany.';
   _ask:=FUN.ask(_msg);
   {? _ask>0
   || _ask:=exec('warn_zgh_akc','px_tex',VAR.A_ZLEC);
      {? _ask>0
      || _ask:=exec('warn_str_akc','px_tex',VAR.A_ZLEC)
      ?};
      {? _ask>0
      ||_result:=exec('zl_tex_update','px_tex',VAR.A_ZLEC)
      ?}
   ?}
?};
_result


\zl_tex_upd_cplx
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Akcja - reczna aktualizacja przepisu z menu uzytkownika dla zlecenia zlozonego
::       Kontekst pracy - VAR.A_ZLEC - zlecenie zlozone
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
Cntx.psh(ZL,VAR,TKTL,TOPER,TMAT,NASTOPER,ZGH,ZGP,PX_TEX,PX_OPER,PX_NAST,PX_OBJ,PX_STAGE,PX_GRP,PX_GRPS);
ZL.prefix();
{? ZL.seek(VAR.A_ZLEC)
||
   {? ZL.RODZAJ='Z'
   ||
::    ustalenie statusu ewentualnego poprzedniego przepisu
      _what:=exec('stat_tex_pop','px_tex',ZL.ref());
      _jaki:=1+_what; _czyrej:=_what+1;
      {? _czyrej='N'
      ||
         {? _jaki='Z'
         ||
::          generowanie przepisu zbiorczego
            _result:=exec('zl_tex_complex','px_tex')
         ||
::          generowanie serii przepisow prostych
            _result:=exec('zl_tex_simply','px_tex')
         ?}
      || FUN.emsg('Do przepisu zarejestrowano wykonania. Aktualizacja przepisu niemożliwa.'@)
      ?}
   ||
::    generacja tradycyjna - wiele pojedynczych przepisow
      _result:=exec('zl_tex_simply','px_tex')
   ?}
?};
Cntx.pop(ZL,VAR,TKTL,TOPER,TMAT,NASTOPER,ZGH,ZGP,PX_TEX,PX_OPER,PX_NAST,PX_OBJ,PX_STAGE,PX_GRP,PX_GRPS);
{? _result || '#RELOAD#' || _result ?}


\tktl_tex_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Akcja - tworzenie przepisów strategicznych na podstawie TKTL
::   WE: [_a] - TKTL.ref
::       [_b] - INTEGER - 0/[1] czy wyświetlać ostrzeżenia o niezaakceptowanej technologii
::----------------------------------------------------------------------------------------------------------------------
_tktl:=TKTL.ref();
{? var_pres('_a')=type_of(TKTL.ref())
|| _tktl:=_a
?};
{? exec('blk_lock','#table','TKTL',TKTL.ref(),,,'Przepis karty: %1 jest redagowany '@[exec('record','#to_string',TKTL.ref())])

||
   _args_mp:=exec('mp_run_a','#b__box');
   _args_mp.AKCJA:='AKCJA';
   _args_mp.ACT_UID:='TPP_PPS_DGPL';
   _args_mp.UIDREF:=exec('FindAndGet','#table',TKTL,_tktl,,"uidref()",null());
   _args_mp.PROC_START:='N';
   _args_mp.PORTS_IN:=exec('portsIn','#b__box',_args_mp.ACT_UID);
   exec('portsInSet','#b__box',_args_mp.PORTS_IN,_args_mp.ACT_UID,'TKTL',_tktl);
   exec('mp_run','#b__box',_args_mp);
   exec('blk_unlock','#table','TKTL',TKTL.ref())
?};
~~


\tktl_tex_update
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Na podstawie karty technologicznej tworzy zestaw przepisow do planowania
::   WE: _a - TKTL.ref()
::       _b - INTEGER - 0/[1] czy wyswietlac ostrzezenia o niezaakceptowanej technologii
::       [_c] - INTEGER - 0/[1] - czy dialogi do KOMM, czy na ekran
::       [_d] - INTEGER - [-1]/0/1 - czy generować przepisy zintegrowane (złożone), jeśli nie podane to pyta
::       [_e] - INTEGER - [-1]/0/1 - czy generować dla wszystkich produktów karty, dla niedomyślnych, domyślnych
::       [_f] - INTEGER - 0/[1] - czy aktualizować zawartość przepisu, jeśli nie to będą zakładane tylko rekordy PX_TEX
::       [_g] - INTEGER - 0/[1] - czy można rekurencyjnie aktualizować
::       [_h] - INTEGER - [0]/1 - czy wywołanie rekurencyjne
::       [_i] - obj_new - dla wywołań rekurencyjnych, tablica odwiedzonych technologii
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

_warn:=1;
{? var_pres('_b')=type_of(0)
|| _warn:=_b
?};

_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};

_complex:=-1;
{? var_pres('_d')=type_of(0)
|| _complex:=_d
?};

_default:=-1;
{? var_pres('_e')=type_of(0)
|| _default:=_e
?};

_refresh:=1;
{? var_pres('_f')=type_of(0)
|| _refresh:=_f
?};

_can_rec:=1;
{? var_pres('_g')=type_of(0)
|| _can_rec:=_g
?};

_rec:=0;
{? var_pres('_h')=type_of(0)
|| _rec:=_h
?};
{? var_pres('_i')>100
|| _visited:=_i
|| _visited:=exec('ref_table','#table')
?};

:: jesli nie ma psotka to go tworze
exec('PXoTEX_chk','px_tex');

:: PxTex potrzebny do importu - jesli nie ma to tworze
{? var_pres('PxTex')<100
|| PxTex:=exec('PxTex_Create','px_tex',exec('get','#params',8055,1,OPERATOR.USER))
?};

_result:=0;
_can_continue:=1;

TKTL.cntx_psh();
TPKTL.cntx_psh();
TKTL.clear();
TKTLW.cntx_psh();
PX_TEX.cntx_psh();
PX_TEX.index('UNIQALL');

{? _visited.r_find(_tktl)=0
||
   _visited.add(_tktl);
   _collection:=exec('ref_table','#table');
   {? TKTL.seek(_tktl)
   ||
      _what:=exec('record','#to_string',_tktl);
::    Sprawdzam na typie karty czy moze byc uzywana w planie strateg
      {? TKTL.TYP().CZAPLA<>'T'
      || _can_continue:=0;
         _msg:='Karta technologiczna: %1 typu: %2 '
               '\nnie moze być używana jako przepis w Planie strategicznym'@[_what,TKTL.TYP().TYP];
         {? _dialog=1
         || FUN.emsg(_msg)
         |? _dialog=2
         || exec('tktl_tex_komm','px_tex',_what,_msg)
         ?}
      ?};

::    Sprawdzam czy karta ma operacje
      TOPER.cntx_psh();
      TOPER.index('NNN');
      TOPER.prefix(TKTL.ref());
      {? TOPER.size()=0
      || _can_continue:=0;
         _msg:='Karta technologiczna: %1 '
               '\nnie zawiera żadnych operacji — utworzenie przepisów planistycznych niemożliwe.'@[TKTL.NRK];
         {? _dialog=1
         || FUN.emsg(_msg)
         |? _dialog=2
         || exec('tktl_tex_komm','px_tex',_what,_msg)
         ?}
      ?};
      TOPER.cntx_pop();

      {? _can_continue>0 & _warn>0
      || _can_continue:=exec('warn_not_akc','px_tex')
      ?};

::    Sprawdzam czy można zablokować rekord
      _locked:=0;
      _can_continue:=exec('blk_lock','#table','TKTL',_tktl,,,'Przepis karty: %1 jest redagowany '@[_what],,_dialog);

      {? _can_continue>0
      || _locked:=1
      ?};

      {? _can_continue>0
      ||
         {? _refresh>0
         ||
::          Jesli TKTL nie mial zadnych PX_STAGE to je po cichu importuje na podstawie toperow
            PX_STAGE.cntx_psh();
            PX_STAGE.index('TKTL_NR');
            PX_STAGE.prefix($TKTL.ref());
            {? PX_STAGE.size()=0
            ||
               _nast:=exec('pxnasttab','px_nast');
               _impargs:=exec('import_toper_a','px_oper');

               _impargs.TKTLsrc:=TKTL.ref();
               _impargs.TKTLdest:=TKTL.ref();

               {? _complex=0
               || _impargs.Complex:='N'
               |? _complex=1
               || _impargs.Complex:='T'
               ?};

               _can_continue:=exec('import_toper','px_oper',_impargs,_nast);

               {? _can_continue>0
               || _can_continue:=exec('importtoper','px_nast',_nast)
               ?};

               _nast.drop()
            ||
::             Jesli sa jakies PX_STAGE to sprawdzam czy mają nawinięte wykonania w planie głównym
               _mainver:=exec('get_mainversion','px_ver');

               {? _complex>0 & _can_rec>0
               || exec('tktl_tex_update_collect','px_tex',,_collection)
               ?};
               _collection.add(TKTL.ref());

               _can_update:=exec('tktl_tex_can_update','px_tex',_collection,_dialog);

               {? _can_update>0
               ||

::                Jesli PX_STAGow nie ma w wykonaniach to je usuwam i importuje od nowa - zeby sie zaktualizowalo
                  {? PX_STAGE.first()
                  || {!
                     |? _can_continue:=exec('clean_from_plan','px_stage',PX_STAGE.ref());
                        PX_STAGE.next() & _can_continue>0
                     !}
                  ?};

                  {? _can_continue>0
                  || _can_continue:=exec('clean_stages_tk','px_tex',TKTL.ref())
                  ?};

                  {? _can_continue & _can_update=2
                  || exec('mod_stamp_queue','px_ver',_mainver)
                  ?};

                  _nast:=exec('pxnasttab','px_nast');
                  {? _can_continue>0
                  ||
                     _impargs:=exec('import_toper_a','px_oper');

                     {? _complex=0
                     || _impargs.Complex:='N'
                     |? _complex=1
                     || _impargs.Complex:='T'
                     ?};

                     _impargs.TKTLsrc:=TKTL.ref();
                     _impargs.TKTLdest:=TKTL.ref();
                     _can_continue:=exec('import_toper','px_oper',_impargs,_nast)
                  ?};
                  {? _can_continue>0
                  || _can_continue:=exec('importtoper','px_nast',_nast,TKTL.ref())
                  ?};

                  _nast.drop()
               ?};
               ~~
            ?};
            PX_STAGE.cntx_pop()
         ?}
      ?};

      {? _can_continue>0
      ||

         TKTLW.index('REF');
         TKTLW.prefix(TKTL.ref());
         {? TKTLW.first()
         ||
::          Zakładam PX_TEX dla nagłówka karty jeżeli jeszcze nie było
            exec('create4tktl','px_tex');
            {!
            |?
               _create:=1;
               {? _default=0
               || _create:=TKTLW.DEFAULT='N' | TKTLW.DEFAULT=''
               |? _default=1
               || _create:=TKTLW.DEFAULT='T'
               ?};
               {? _create>0
               ||
::                Dla kazdego wyrobu karty zakladamy przepis o ile jeszcze go nie ma
                  PX_TEX.prefix($TKTL.ref(),PXoTEX.kind.table('M'),TKTLW.KTM);
                  {? PX_TEX.size()=0
                  ||
                     PX_TEX.blank();
                     PX_TEX.M:=TKTLW.KTM;
                     PX_TEX.AKT:='T';
                     PX_TEX.KIND:=PXoTEX.kind.table('M');
                     PX_TEX.SYMBOL:=exec('gen_px_tex_sym','px_tex');
                     PX_TEX.VER:=exec('get_ver_nxt','px_tex',PX_TEX.SYMBOL);
                     PX_TEX.PX_RULES:=PXoTEX.Rules.tex_tex;
                     PX_TEX.XJM:=TKTL.XJM;
                     PX_TEX.TKTL:=TKTL.ref();

                     _can_continue:=PX_TEX.add()
                  ?}
               ?};
               TKTLW.next() & _can_continue>0
            !}
         || _can_continue:=0;
            _msg:='Karta technologiczna: %1'
                  '\nnie jest związana z żadnymi wyrobami — utworzenie przepisów planistycznych niemożliwe.'@[TKTL.NRK];
            {? _dialog=1
            || FUN.emsg(_msg)
            |? _dialog=2
            || exec('tktl_tex_komm','px_tex',_what,_msg)
            ?}
         ?}
      ?};

      {? _locked>0
      || exec('blk_unlock','#table','TKTL',_tktl)
      ?};

      {? _can_continue>0 & _refresh>0 & _complex>0 & _can_rec>0
      || _tab:=_collection.tab;
         _collection.r_del(_tktl);
         _tab.index(_collection.ndxLp);
         _tab.prefix();
         {? _tab.first()
         ||
            {? _dialog>0
            || FUN.prg_start(_tab.size(),'Aktualizacja powiązanych przepisów kart technologicznych'@)
            ?};
            {!
            |?
               _tktl_rec:=exec('FindAndGet','#table',TKTL,_tab.SQL,,,null());
               {? _tktl_rec<>null()
               || _what_rec:=exec('record','#to_string',_tktl_rec);
                  {? _dialog>0
                  || _can_continue:=FUN.prg_next(1,'Aktualizacja powiązanego przepisu w: %1'@[_what_rec])
                  ?};
                  {? _can_continue>0
                  ||
::                   !!! REKURENCJA !!!
                     _rec_res:=exec('tktl_tex_update','px_tex',_tktl_rec,_warn,_dialog,_complex,_default,_refresh,0,1,_visited)
                  ?}
               ?};
               _tab.next() & _can_continue>0
            !};
            {? _dialog>0
            || FUN.prg_stop()
            ?}
         ?}
      ?}
   ?};
   _what:=exec('record','#to_string',_tktl);
   {? _rec>0 & _dialog=2
   || {? _can_continue>0
      || _msg:='Zaktualizowano powiazany przepis karty'@;
         exec('tktl_tex_komm','px_tex',_what,_msg)
      || _msg:='Nie udała się aktualizacja powiązanego przepisu karty'@;
         exec('tktl_tex_komm','px_tex',_what,_msg,5)
      ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
TKTLW.cntx_pop();
TKTL.cntx_pop();
TPKTL.cntx_pop();
PX_TEX.cntx_pop();
_result


\tktl_tex_update_collect
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Zbiera karty w których karta występuje jako karta dla półfabrykatu
::   WE: [_a] - TKTL.ref lub bieżąca karta
::       [_b] - obj_new - wynik działania
::       [_b] - obj_new - tablica odwiedzonych technologii
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(TKTL.ref())
|| _ref:=_a
?};
{? var_pres('_b')>100
|| _result:=_b
|| _result:=exec('ref_table','#table')
?};

{? var_pres('_c')>100
|| _visited:=_c
|| _visited:=exec('ref_table','#table')
?};

_can_continue:=1;

TKTL.cntx_psh();
{? _ref<>null()
|| TKTL.prefix();
   {? TKTL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? _visited.r_find(TKTL.ref())=0
   || _visited.add(TKTL.ref());
      TKTLW.cntx_psh();
      TMAT.cntx_psh();
      TKTLW.index('REF');
      TKTLW.prefix(TKTL.ref());
      {? TKTLW.first()
      || {!
         |? {? TKTLW.DEFAULT='T'
            ||
::             Karta domyślna
               TMAT.index('KTAN');
               TMAT.prefix(TKTLW.KTM,'T');
               {? TMAT.first()
               ||
::                Normalne surowce
                  {!
                  |? TKTL.cntx_psh();
                     {? TMAT.DFLT_KTL='T' &  TMAT.MAG<>'T'
                     || {? TMAT.NRK().TORW='T' & TKTL.STAN='T'
                        ||
                           _result.add(TMAT.NRK);

::                         !!! REKURENCJA !!!
                           exec('tktl_tex_update_collect','px_tex',TMAT.NRK,_result,_visited)
                        ?}
                     ?};
                     TKTL.cntx_pop();
                     TMAT.next()
                  !}
               ?};
               TMAT.index('KTAN2');
               TMAT.prefix(TKTLW.KTM,'T');
               {? TMAT.first()
               ||
::                Przez grupę technologiczną
                  {!
                  |? TKTL.cntx_psh();
                     {? TMAT.DFLT_KTL='T' &  TMAT.MAG<>'T'
                     || {? TMAT.NRK().TORW='T' & TKTL.STAN='T'
                        ||
                           _result.add(TMAT.NRK);

::                         !!! REKURENCJA !!!
                           exec('tktl_tex_update_collect','px_tex',TMAT.NRK,_result,_visited)
                        ?}
                     ?};
                     TKTL.cntx_pop();
                     TMAT.next()
                  !}
               ?}
            ?};
            TMAT.index('KTL');
            TMAT.prefix('T',TKTL.ref());
            {? TMAT.first()
            ||
::             Karta wskazana na surowcu
               {!
               |? TKTL.cntx_psh();
                  {? TMAT.NRK().TORW='T' & TKTL.STAN='T'
                  ||
                     _result.add(TMAT.NRK);
::                   !!! REKURENCJA !!!
                     exec('tktl_tex_update_collect','px_tex',TMAT.NRK,_result,_visited)
                  ?};
                  TKTL.cntx_pop();
                  TMAT.next()
               !}
            ?};
            TKTLW.next()
         !}
      ?};
      TKTLW.cntx_pop();
      TMAT.cntx_pop();
      ~~
   ?};
   ~~
?};
TKTL.cntx_pop();
_result


\tktl_tex_can_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy można zaktualizować przepis planistyczny dla WSZYSTKICH podanych kart technologicznych
::   WE: _a - obj_new - tablica kart - wynik exec('ref_table','#table')
::       _b - INTEGER - 0/1 - czy wyświetlać dialogi
::   WY: 0 - nie można
::       1 - można
::       2 - można, ale przynajmniej jedna jest w planie
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref_table:=_a;
_dialog:=_b;

_tab:=_ref_table.tab;
_result:=0;
_can_continue:=1;

_tab.prefix();
{? _tab.first()
|| {!
   |? _res:=exec('tktl_tex_can_update_core','px_tex',_tab.SQL);
      {? _res=0
      || _result:=0;
         _can_continue:=0;
::       Jesli są wykonania to komunikat że aktualizacja przepisu nie może się zrobić
         _what:=exec('TKTL','#to_string');
         _msg:='Przepis technologii: %1 ma już wykonania w planie strategicznym.'
               '\nNależy usunąć obiekty z planu używające tego przepisu, lub skopiować technologię na nową wersję wysyłając starą do archiwum.'@[_what];
         {? _dialog=1
         || FUN.emsg(_msg)
         |? _dialog=2
         || exec('tktl_tex_komm','px_tex',_what,_msg)
         ?}
      ?};
      _result:=exec('max','#math',_res,_result);
      _tab.next() & _can_continue>0
   !}
?};
_result


\tktl_tex_can_update_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Sprawdza czy można zaktualizować przepis planistyczny dla karty tech
::   WE: [_a] - TKTL.ref() lub bieżący rekord
::   WY: 0 - nie można
::       1 - można
::       2 - można, ale jest w planie
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(TKTL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

TKTL.cntx_psh();
{? _ref<>null()
|| TKTL.prefix();
   {? TKTL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

_used_in_plan:=0;
_wyk_in_plan:=0;
{? _can_continue>0
||
   _mainver:=exec('get_mainversion','px_ver');
   PX_POZ.cntx_psh();
   PX_POZ.index('VSTAGE');
   PX_STAGE.cntx_psh();
   PX_STAGE.index('TKTL_NR');
   PX_STAGE.prefix($TKTL.ref());
   {? PX_STAGE.first()
   || {!
      |? PX_POZ.prefix(_mainver,PX_STAGE.ref());
         {? PX_POZ.first()
         || _used_in_plan:=1;
            {!
            |?
               {? exec('array_sum','#array',exec('count_wyk','px_poz',PX_POZ.ref()))>0
               || _wyk_in_plan:=1
               ?};
               PX_POZ.next() & _wyk_in_plan=0
            !}
         ?};
         PX_STAGE.next() & (_used_in_plan=0 | _wyk_in_plan=0)
      !}
   ?};
   PX_POZ.cntx_pop();

   PX_STAGE.cntx_pop();
   ~~
?};
TKTL.cntx_pop();
{? _can_continue>0
|| {? _wyk_in_plan>0
   || _result:=0
   |? _used_in_plan>0
   || _result:=2
   || _result:=1
   ?}
?};
_result


\tktl_tex_create_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS:
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
TKTL.cntx_psh();
TKTL.index('NRK');
exec('init','tte');
_msg:='Zostaną wygenerowane brakujące przepisy planistyczne dla wszystkich niearchiwalnych kart technologicznych.\n'
      'Jeżeli to możliwe, istniejące przepisy zostaną zaktualizowane.'@;
_choice:=FUN.choice(_msg,,'Generuj przepisy proste'@,'Generuj przepisy zintegrowane'@);

{? _choice>0
||
   _complex:=0;
   {? _choice=2
   || _complex:=1
   ?};

   TKTL.prefix('T');

   KOMM.init(250,'Generowanie przepisów planistycznych');
:: Najpierw generujemy dla kart domyślnych
   {? TKTL.first()
   || {!
      |? exec('tktl_tex_update','px_tex',TKTL.ref(),0,0,_complex,1,1,0);
         TKTL.next()
      !}
   ?};

:: Następnie generujemy dla kart niedomyślnych
   {? TKTL.first()
   || {!
      |? exec('tktl_tex_update','px_tex',TKTL.ref(),0,0,_complex,0,0,0);
         TKTL.next()
      !}
   ?};
   KOMM.select()
?};
TKTL.cntx_pop();
''


\tktl_tex_komm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Dodaje komunikat do KOMMa
::   WE:  _a  - STRING - symbol karty
::        _b  - STRING - treść komunikatu
::       [_c] - INTEGER - nr ikony, domyślnie 2
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_sect:=_a;
_msg:=_b;

_icon:=2;
{? var_pres('_c')=type_of(0) | var_pres('_c')=type_of('')
|| _icon:=_c
?};

_sect_nr:=0;
_nr_root:=0;

_sect_nr:=KOMM.find_msg(_sect,_nr_root);
{? _sect_nr
|| KOMM.set_root(_sect,_nr_root)
|| _sect_nr:=KOMM.sect_beg(_sect)
?};

{? _sect<>''
|| {? KOMM.find_msg(_msg,_sect_nr)=0
   || KOMM.add(_msg,_icon,,1)
   ?};
   KOMM.sect_end()
|| {? KOMM.find_msg(_msg)=0
   || KOMM.add(_msg,_icon,,1)
   ?}
?};
~~


\PxTexCMaterTab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Tworzy tabele .MaterTab
::   WE: _a - PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_pxtex.MaterTab:=PX_MAT;
~~


\PxTexCMaterSel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Tworzy okienko .MaterSel - materialy
::   WE: _a - PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
{? _pxtex.MaterTab<>PX_MAT || return() ?};
_tab:=_pxtex.MaterTab;

_wer:=exec('win_sel','px_mat',~_pxtex.ViewOnly,_pxtex.wid_Mater);

_tab.win_sel(_wer);
_pxtex.MaterSel:=_wer;
~~


\px_analiza_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'przed' dla tabeli _paczka
::----------------------------------------------------------------------------------------------------------------------
{? exec('is_pdbuf','plan_dostaw')
||
   _PxPack:=params_get().PxPack;
   _paczka:=_PxPack.Paczka;
   _zl:=null();
   {? _PxPack.PX_TEX<>null()
   || _zl:=exec('FindAndGet','#table',PX_TEX,_PxPack.PX_TEX,,"ZL",null())
   ?};

   {? _paczka.sel_size()=0
   ||
      exec('env_create','plan_dostaw');
      exec('env_ustaw_il','plan_dostaw',_paczka.ILOSC)
   ?};

   {? _paczka.MATERIAL<>''
   ||
      {? _paczka.sel_size()=0
      || _dalej:=exec('env_edit_il','plan_dostaw',,0)
      || _dalej:=1
      ?};

      {? _dalej
      || M.cntx_psh();
         M.clear();
         {? M.seek(_paczka.MATERIAL)
         ||
            _coef:=exec('env_il','plan_dostaw')/_paczka.ILOSC;

            _args:=exec('pda_a','plan_dostaw');
            _args.M:=M.ref();
            _args.TM_STAMP:=SYSLOG.tm_stamp();
::            _args.DK:=
::            _args.TK:=
            _args.IL:=_paczka.NORMA*_coef;
            _args.DW:=exec('env_date','plan_dostaw');
            _args.TW:=exec('env_time','plan_dostaw');
            _args.DISP:=0;
            exec('openmask','zl_common',_zl);
            ZLIM.index('ZMW');
            ZLIM.prefix(_zl,_args.M);
            {? ZLIM.first()
            || {!
               |? _args.skip_add($ZLIM.ref());
                  _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit');
                  {? _zk_p<>null() || _args.skip_add($_zk_p) ?};
                  ZLIM.next()
               !}
            ?};
            {? exec('FindAndGet','#table',ZL,_zl,,"RODZAJ='Z'",0)
            || ZL.cntx_psh();
               ZL.index('NRNZL');
               ZL.prefix(exec('FindAndGet','#table',ZL,_zl,,"UNRZL",0));
               {? ZL.first()
               || {!
                  |? ZLIM.index('ZMW');
                     ZLIM.prefix(ZL.ref(),_args.M);
                     {? ZLIM.first()
                     || {!
                        |? _args.skip_add($ZLIM.ref());
                           _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit');
                           {? _zk_p<>null() || _args.skip_add($_zk_p) ?};
                           ZLIM.next()
                        !}
                     ?};
                     ZL.next()
                  !}
               ?};
               ZL.cntx_pop()
            ?};
            _used:=exec('env_used_sum','plan_dostaw',_args.M);
            {? _used>0 || _args.insert_add($_args.M,_args.DW,_args.TW,_used) ?};
            _res:=exec('pda','plan_dostaw',_args);

            _argse:=exec('an_add_a','plan_dostaw');
            _argse.M:=_args.M;
            _argse.IL:=_args.IL;
            _argse.DW:=_args.DW;
            _argse.TW:=_args.TW;
            _argse.DOSTEPNY:=_res.DOSTEPNY;
            _argse.IL_DOST:=_res.IL_DOST;
            _argse.DM:=_res.NA_KIEDY;
            ZLIM.index('ZMW');
            ZLIM.prefix(_zl,_argse.M);
            {? ZLIM.first()
            || {!
               |? _argse.skip_add($ZLIM.ref());
                  _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit');
                  {? _zk_p<>null() || _argse.skip_add($_zk_p) ?};
                  ZLIM.next()
               !}
            ?};
            {? exec('FindAndGet','#table',ZL,_zl,,"RODZAJ='Z'",0)
            || ZL.cntx_psh();
               ZL.index('NRNZL');
               ZL.prefix(exec('FindAndGet','#table',ZL,_zl,,"UNRZL",0));
               {? ZL.first()
               || {!
                  |? ZLIM.index('ZMW');
                     ZLIM.prefix(ZL.ref(),_argse.M);
                     {? ZLIM.first()
                     || {!
                        |? _argse.skip_add($ZLIM.ref());
                           _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit');
                           {? _zk_p<>null() || _argse.skip_add($_zk_p) ?};
                           ZLIM.next()
                        !}
                     ?};
                     ZL.next()
                  !}
               ?};
               ZL.cntx_pop()
            ?};
            {? _used>0 || _args.insert_add($_args.M,_args.DW,_args.TW,_used) ?};
            exec('an_add','plan_dostaw',_argse);
            exec('env_used_add','plan_dostaw',_args.M,_args.DW,_args.TW,_args.IL)
         ?};
         M.cntx_pop()
      ?}
   ?};

   {? _paczka.sel_size()=0
   ||
      exec('an_select','plan_dostaw');
      exec('env_delete','plan_dostaw')
   ?}
?};
~~


\px_analiza_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'po' dla tabeli _paczka
::----------------------------------------------------------------------------------------------------------------------
~~


\px_analiza_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'przed grupą' dla tabeli _paczka
::----------------------------------------------------------------------------------------------------------------------
{? exec('is_pdbuf','plan_dostaw')
|| _paczka:=cur_tab(1,1);

   exec('env_create','plan_dostaw');
   {? exec('env_edit_il','plan_dostaw',,0)
   || exec('env_ustaw_il','plan_dostaw',_paczka.ILOSC);
      1
   || 0
   ?}
||
   0
?}


\px_analiza_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'po grupie' dla tabeli _paczka
::----------------------------------------------------------------------------------------------------------------------
exec('an_select','plan_dostaw');
exec('env_delete','plan_dostaw')


\px_tex_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Akcja na wyswietl w oknach wertowania tabeli PX_TEX
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_win_edit:=PX_TEX.win_edit('?');
:: przygotujemy zmienna do prefiksow i blankowania
{? var_pres('PXoTEX')<100 || exec('PXoTEX','px_tex') ?};

{? PX_TEX.KIND=PXoTEX.kind.table('M')
|| PX_TEX.win_edit('DISP_M')
|? PX_TEX.KIND=PXoTEX.kind.table('MGR')
|| PX_TEX.win_edit('DISP_MGR')
|| PX_TEX.win_edit('DISP')
?};

{? PX_TEX.RTKTL<>''
|| exec('display_vars','tech_common',PX_TEX.RTKTL)
|| VAR.TKTL_NRK:='';
   VAR.TKTL_WER:=''
?};
PX_TEX.display();

:: Przywracam poprzednie okno
PX_TEX.win_edit(_win_edit);
~~


\round_start_pck
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Zwraca aktualny czas jako czas startu planu biorac pod uwage:
::          - strukture pojemnikow na pierwszym zasobie w paczce (start jest zaokraglany do poczatku pojemnika)
::   WE: _a - tab_tmp - paczka
::       [_b] - REAL - tm_stamp - czas ktory zaokraglac - jesli nie podane to czas aktualny
::   WY: REAL - zaokraglony aktualny czas lub 0 jesli sie cos nie powiodlo
::----------------------------------------------------------------------------------------------------------------------
_paczka:=_a;
_tm_now:=PX_KONT.tm_stamp();
{? var_pres('_b')=type_of(0)
|| {? _b>0
   || _tm_now:=_b
   ?}
?};

_result:=0;

_paczka.cntx_psh();
_ndx_num:=_paczka.ndx_tmp(,,'TYP',,,'NUM',,);
_paczka.index(_ndx_num);

PX_KONT.cntx_psh(); PX_KONT.clear();
_paczka.prefix('K');
{? _paczka.first()
|| {? PX_KONT.seek(_paczka.REF_KONT)
   ||
      _mode:='START';
      _result:=exec('round_time','px_kont',PX_KONT.ref(),_tm_now,_mode)
   ?}
?};
PX_KONT.cntx_pop();
_paczka.cntx_pop();
_result


\formula4stages
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Wykonuje przekazana formule dla kazdego etapu planistycznego z przepisu
::       Przekazana formula dziala w kontekscie rekordu PX_STAGE
::   WE: _a - PX_TEX.ref()
::       _b - FORMULA - formula do wykonania dla kazdego etapu
::       [_c] - ANY - oczekiwana wartosc ktora powinna zwrocic formula _b - jesl zwrocona wartosc
::              bedzie inna to petla po etapach jest przerywana i w wyniku bedzie 0
::       [_d] - ANY - argumenty przekazane do formuly jako parametr _a
::   WY: -1 - porazka, wystapil jakis blad (np nieudany seek)
::       0 - porazka - przekazana formula zwrocila wynik<=0 dla ktoregos rekordu, lub zwrocila
::                     wynik rozny od _c (jesli _c podane)
::       1 - sukces - przekazana formula zwrocila wynik>0 dla kazdego rekordu lub wynik zgodny z _c (jesli podane)
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;
_fml:=_b;

_expected:={? var_pres('_c')>0 || _c || ~~ ?};

_args:={? var_pres('_d')>0 || _d || ~~ ?};

_result:=1;
_can_continue:=1;

PX_STAGE.cntx_psh();
PX_TEX.cntx_psh(); PX_TEX.clear();

{? PX_TEX.seek(_px_tex)
||
   PX_STAGE.index('TEX_NR');
   PX_STAGE.prefix(PX_TEX.ref());
   {? PX_STAGE.first()
   ||
::    Etapy naleza do przepisu
      {!
      |?
::       Wykonuje formule
         _wynik:=_fml(_args);

         {? type_of(_expected)>0
         ||
::          Porownuje wynik formuly z oczekiwana wartoscia
            _can_continue:={? _wynik=_expected
                           || 1
                           || 0
                           ?}
         ||
::          Oczekiwana wartosc nie podana, wiec jesli wynik formuly mniejszy rowny zero
::          modyfikuje wynik calej formuly
            {? _wynik<=0
            || _result:=0
            ?}
         ?};
         PX_STAGE.next() & _can_continue>0
      !}
   ||
::    Jesli brak etapow w przepisie to sprawdzam czy sa podpiete do karty technologicznej
      {? PX_TEX.RTKTL<>''
      || PX_STAGE.index('TKTL_NR');
         PX_STAGE.prefix(PX_TEX.RTKTL);
         {? PX_STAGE.first()
         || {!
            |?
::             Wykonuje formule
               _wynik:=_fml(_args);

               {? type_of(_expected)>0
               ||
::                Porownuje wynik formuly z oczekiwana wartoscia
                  _can_continue:={? _wynik=_expected
                                 || 1
                                 || 0
                                 ?}
               ||
::                Oczekiwana wartosc nie podana, wiec jesli wynik formuly mniejszy rowny zero
::                modyfikuje wynik calej formuly
                  {? _wynik<=0
                  || _result:=0
                  ?}
               ?};
               PX_STAGE.next() & _can_continue>0
            !}
         ?}
      ?}
   ?}
|| _result:=-1
?};
:: Jesli petla przerwana w wyniku tego ze formula nie zwrocila oczekiwanej wartosci
:: to ogolny wynik=0
{? _can_continue=0
|| _result:=0
?};

PX_TEX.cntx_pop();
PX_STAGE.cntx_pop();
_result


\has_set
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy podany przepis zawiera jakikolwiek etap przypisany do podanego zestawu
::   WE: _a - PX_TEX.ref() - przepis
::       _b - PX_SET.ref() - zestaw
::   WY: 0 - brak zestawu w przepisie
::       1 - jest zestaw w przepisie
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;
_px_set:=_b;

_result:=0;

_fml:='{? $PX_STAGE.PX_SET<>\''+$_px_set+'\' || 0 || 1 ?}';
_fml:=$_fml;

{? exec('formula4stages','px_tex',_px_tex,_fml,0)=0
|| _result:=1
?};
_result


\has_coop
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [18.42]
:: OPIS: Sprawdza czy podany przepis zawiera jakikolwiek etap będący kooperacją
::   WE: _a - PX_TEX.ref() - przepis
::   WY: 0 - brak kooperacji w przepisie
::       1 - jest kooperacja w przepisie
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;

_result:=0;

_fml:="{? exec('is_wew','px_stage',PX_STAGE.ref())='T' || 1 || 0 ?}";

{? exec('formula4stages','px_tex',_px_tex,_fml,1)=0
|| _result:=1
?};
_result


\stages_loc
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza gdzie szukac etapow dla podanego przepisu
::   WE: _a - PX_TEX.ref()
::   WY: STRING - '' - wystapil jakis blad
::                'PX_TEX' - etapy sa w przepisie planistycznym
::                'TKTL'   - etapy sa w karcie technologicznej
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;

_result:='';

PX_STAGE.cntx_psh();
PX_TEX.cntx_psh(); PX_TEX.clear();

{? PX_TEX.seek(_px_tex)
||
   PX_STAGE.index('TEX_NR');
   PX_STAGE.prefix(PX_TEX.ref());
   {? PX_STAGE.size()>0
   ||
::    Etapy naleza do przepisu
      _result:='PX_TEX'
   ||
::    Jesli brak etapow w przepisie to sprawdzam czy sa podpiete do karty technologicznej
      {? PX_TEX.RTKTL<>''
      || PX_STAGE.index('TKTL_NR');
         PX_STAGE.prefix(PX_TEX.RTKTL);
         {? PX_STAGE.size()>0
         || _result:='TKTL'
         ?}
      ?}
   ?}
?};
PX_TEX.cntx_pop();
PX_STAGE.cntx_pop();
_result


\has_start_sets
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy podany przepis zawiera wszystkie zestawy startowe ktore sa uzywane w kolejce
::       Dodaje do KOMMa info ktorych zestawow brakuje
::   WE: [_a] - PX_TEX.ref()
::       [_b] - INTEGER - 1 - dodawac komunikaty do KOMMa
::                        2 - dodawac komunikaty do PX_KOMM
::   WY: 0 - nie ma wymaganych zestawow w przepisie
::       1 - ok
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};
_komm:=1;
{? var_pres('_b')=type_of(0)
|| _komm:=_b
?};

_result:=1;
_can_continue:=1;

PX_TEX.cntx_psh();
{? _ref<>null()
|| PX_TEX.clear();
   {? PX_TEX.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _mainver:=exec('get_mainversion','px_ver');
   PX_GRP.cntx_psh();
   PX_SET.cntx_psh();
   PX_GRP.index('PX_TEX2');
   PX_GRP.prefix(_mainver,PX_TEX.ref());
   {? PX_GRP.first()
   ||
      _komm_args:=exec('add_komm_a','px_komm');
      _komm_args.PX_VER:=_mainver;
      {!
      |?
         {? PX_GRP.SET_SRC<>null()
         ||
            {? exec('has_set','px_tex',PX_TEX.ref(),PX_GRP.SET_SRC)=0
            || _result:=0;

               {? _komm=1
               ||
                  _sect:='Przepis: '+PX_TEX.SYMBOL+' (wersja: '+PX_TEX.VER+') powinien zawierać przynajmniej jeden etap na zestawach:';
                  {? KOMM.find_msg(_sect) || KOMM.set_root(_sect) || KOMM.sect_beg(_sect) ?};
                  _msg:=PX_GRP.SET_SRC().SYMBOL;
                  {? KOMM.find_msg(_msg)=0
                  || KOMM.add(_msg,'xwin16.png:50')
                  ?};
                  KOMM.sect_end()
               |? _komm=2
               ||
                  _komm_args.PX_GRP:=PX_GRP.ref();
                  _komm_args.MESSAGE:='Przepis grupy: '+$PX_GRP.LP_Q+'. '+PX_GRP.SYMBOL;
                  _komm_args.MESSAGE+=' powinien zawierać przynajmniej jeden etap na zestawie: '+PX_GRP.SET_SRC().SYMBOL;
                  _komm_args.TYP:=exec('type_error','px_komm');
                  _komm_args.SRC_KIND:=exec('src_tex_verify','px_komm');
                  exec('add_komm','px_komm',_komm_args)
               ?}
            ?}
         ?};
         PX_GRP.next()
      !}
   ?};
   PX_SET.cntx_pop();
   PX_GRP.cntx_pop();
   ~~
?};
PX_TEX.cntx_pop();
_result


\update_px_set
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Aktualizuje zestawy startowe na obiektach ktore uzywaja podanego przepisu
::       jako domyslny
::   WE: _a - PX_TEX.ref
::----------------------------------------------------------------------------------------------------------------------
_px_tex:=_a;

PX_OBJ.cntx_psh();
PX_OBJ.index('PX_TEX');
PX_OBJ.prefix(_px_tex);
{? PX_OBJ.first()
|| {!
   |? _next:=0;
      _ref_nxt:=null();
      PX_OBJ.cntx_psh();
      {? PX_OBJ.next()
      || _ref_nxt:=PX_OBJ.ref()
      ?};
      PX_OBJ.cntx_pop();

      exec('update_px_set','px_obj',PX_OBJ.ref(),,1);

      {? _ref_nxt<>null()
      || _next:=PX_OBJ.seek(_ref_nxt)
      ?};
      _next>0
   !}
?};
PX_OBJ.cntx_pop();
~~


\warn_not_akc
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Jesli karta technologiczna jest niezaakceptowana i na jej podstawie jest wykonywany import
::       kopiowanie lub generowanie przepisu to wyswietlam ostrzezenie
::       KONTEKST PRACY - rekord TKTL
::   WY: 0/1 - czy uzytkownik wyrazil zgode na kontunuowanie lub 1 jesli komunikat sie nie pojawil
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
{? TKTL.STAN='N'
|| _msg0:='';
   _msg1:='Źródłowa karta technologiczna: '+TKTL.NRK+' (wersja: '+TKTL.WER+') jest niezaakceptowana.';
   _msg2:='Utworzony na jej podstawie przepis planistyczny może być różny od źródłowej zaakceptowanej technologii.';
   _msg3:='Szczególnie należy zwrócić uwagę, czy źródłowa technologia ma wygenerowane następniki operacji,';
   _msg4:='ponieważ może to prowadzić do nieprawidłowego planowania (operacje w planie zostaną ułożone równolegle).';
   _msg5:='Czy kontynuować?';
   _msg_glued:=exec('form','#string','L',_msg1
                                       ,_msg0
                                       ,_msg2
                                       ,_msg0
                                       ,_msg3
                                       ,_msg4
                                       ,_msg0
                                       ,_msg5);
   _result:=FUN.ask(_msg_glued)
?};
_result


\warn_zgh_akc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Jeśli zlecenie ma przewodniki ale są one niezaakceptowane to wyświetlam ostrzeżenie przy aktualizacji
::       przepisu zlecenia
::   WE: _a - ZL.ref()
::       _b - INTEGER - 0/[1]/2 - czy wyświetać dialogi, czy dodawać do KOMMa
::   WY: 0/1 - czy użytkownik wyraził zgodę na kontunuowanie lub 1 jeśli komunikat się nie pojawił
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_result:=1;
_can_continue:=1;

ZL.cntx_psh(); ZL.clear();
ZGH.cntx_psh();
ZGH.index('ZLNR');

{? ZL.seek(_zl)
|| ZGH.prefix(ZL.ref());
   {? ZGH.first()
   || {!
      |? {? ZGH.STAT_REJ='N'
         || _can_continue:=0;
            {? _dialog=1
            || _msg:='Zlecenie: %1 ma przewodniki ale są one niezaakceptowane.\n\n'
                     'Utworzony na ich podstawie przepis planistyczny może mieć nieprawidłowe powiązania na etapach,\n'
                     'jeżeli pozycje przewodników nie mają następników.\n\n'
                     'Może to prowadzić do nieprawidłowego zaplanowania zlecenia\n'
                     '(etapy w planie zostaną ułożone równolegle lub w nieprawidłowej kolejności).\n\n'
                     'Czy kontynuować?'@[ZL.SYM];
               _result:=FUN.ask(_msg)
            |? _dialog=2
            || _result:=0;
               _msg:='Zlecenie: %1 ma niezaakceptowane przewodniki, bezdialogowe generowanie przepisu niedozwolone.'@[ZL.SYM];
               KOMM.add(_msg,2)
            || _result:=0
            ?}
         ?};
         _can_continue & ZGH.next()
      !}
   ?}
?};
ZGH.cntx_pop();
ZL.cntx_pop();
_result


\warn_str_akc
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Jesli zlecenie ma operacje technologiczne ale nie zatwierdzona jest ich struktura to wyswietlam ostrzezenie przy aktualizacji
::       przepisu zlecenia
::   WE: _a - ZL.ref()
::       _b - INTEGER - 0/[1]/2 - czy wyswietac dialogi, czy dodawac do KOMMa
::   WY: 0/1 - czy uzytkownik wyrazil zgode na kontunuowanie lub 1 jesli komunikat sie nie pojawil
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_result:=1;
ZL.cntx_psh(); ZL.clear();
TKTL.cntx_psh();
TOPER.cntx_psh();
TOPER.index('NNN');

{? ZL.seek(_zl)
||
   {? ZL.TKTL<>null()
   ||
      TOPER.prefix(ZL.TKTL);
      {? TOPER.size()>0
      ||
         {? ZL.TKTL().STAN<>'T'
         ||
            {? _dialog=1
            || _msg:='Zlecenie: %1 ma niezaakceptowaną technologię.\n\n'
                     'Utworzony przepis planistyczny może mieć nieprawidłowe powiązania na etapach,\n'
                     'jeżeli operacje technologiczne nie mają następników.\n'
                     'Może to prowadzić do nieprawidłowego zaplanowania zlecenia (etapy w planie zostaną ułożone równolegle\n'
                     'lub w nieprawidłowej kolejności).\n\n'
                     'Czy kontynuować?'@[ZL.SYM];
               _result:=FUN.ask(_msg)
            |? _dialog=2
            || _result:=0;
               _msg:='Zlecenie: %1 ma niezaakceptowaną technologię, bezdialogowe generowanie przepisu niedozwolone.'@[ZL.SYM];
               KOMM.add(_msg,2)
            || _result:=1
            ?}
         ?}
      ?}
   ?}
?};
ZL.cntx_pop();
TKTL.cntx_pop();
TOPER.cntx_pop();
_result


\tktl_tex_view
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja Przepis planistyczny dla karty technologicznej
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
exec('icon_before','px_plan');
exec('Select_A_KTL','px_tex',{? TKTL.ARCH='T' | ~exec('tktl_act','tech_head',0) || 'VIEW!' || 'EDIT' ?});
~~


\trigger_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger przed put i przed add tabeli PX_TEX
::   WY: 1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? PX_TEX.TKTL<>null()
|| PX_TEX.RTKTL:=$PX_TEX.TKTL
?};
1


\zl_tex_view
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja przepis planistyczny dla zlecenia
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_can_continue:=1;

ZL.cntx_psh();
ZL.clear();
{? ZL.seek(VAR.A_ZLEC)
|| _what:=exec('record','#to_string',ZL.ref());
   {? (ZL.RKTL<>'' & exec('FindAndGet','#table',TKTL,ZL.RKTL,,"TYP().CZAPLA",'N')='N')
   || _can_continue:=0;
      FUN.emsg('Technologia źródłowa zlecenia: %1 nie umożliwia generowania przepisów planistycznych.'@[_what])
   ?};

   {? exec('is_podzlec','zl_link',ZL.ref())>0
   || {? ZL.RODZ_TEX='Z'
      || _can_continue:=0;
         FUN.emsg('Podglad przepisu zlecenia: %1 możliwy tylko od strony zlecenia nadrzędnego.'@[_what])
      ?}
   ?};

   {? _can_continue>0
   || exec('Select_A_ZL','px_tex')
   ?}
?};
ZL.cntx_pop();
~~


\delete4tktl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Kasuje PX_TEXy nalezace do TKTL
::   WE: _a - TKTL.ref
::   WY: -1 - porazka
::       1 - sukces
::  OLD: \px_tex/tkasuj.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

_result:=-1;
_can_continue:=1;

PX_TEX.cntx_psh();
PX_TEX.index('RTKTL');
PX_TEX.prefix($_tktl);
{? PX_TEX.first()
|| {!
   |? _can_continue:=exec('PX_TEX_delete','px_tex',PX_TEX.ref());
      PX_TEX.first() & _can_continue>0
   !}
?};
{? _can_continue>0
|| _result:=1
?};
PX_TEX.cntx_pop();
_result


\szukaj_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja przed szukaj w oknach wertowania PX_TEX
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
exec('FilterTKTL','px_tex',0);
PX_TEX.win_patt('SZUK');
PX_VAR.RULE_TYP:=exec('px_rule_tex','px_param');
PX_TEX.efld_opt('SZUK','enable=0',,'TKTL','WER');
TKTL.win_dict('SLO');
TKTL.actions('SLO','W');
VAR.A_TORW:='T';
~~


\szukaj_after
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja po szukaj w oknach wertowania PX_TEX
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
PX_TEX.efld_opt('SZUK','enable=1',,'TKTL','WER');
TKTL.actions('SLO');
~~


\px_tex_deactivate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja 'Dezaktywuj' w oknach wertowania PX_TEX
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_lock_res:=exec('lock','px_tex');
{? _lock_res.LOCKED>0
|| exec('PX_TEX_WER_bAs','px_tex',0)
?};
exec('unlock','px_tex',_lock_res);
~~


\px_tex_deactivate_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja 'Dezaktywuj' grupa przed w oknach wertowania PX_TEX
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_ok:=0;
{? FUN.ask('Zaznaczono: %1 przepisów. Czy dezaktywować je wszystkie?'@[$PX_TEX.sel_size()])
|| _ok:=1;
   KOMM.init(250,,'Dezaktywacja przepisów planistycznych'@,'')
?};
_ok


\px_tex_deactivate_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja 'Dezaktywuj' grupa po w oknach wertowania PX_TEX
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
KOMM.select(,,,,,0);
~~


\px_tex_activate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja 'Aktywuj' w oknach wertowania PX_TEX
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_lock_res:=exec('lock','px_tex');
{? _lock_res.LOCKED>0
|| exec('PX_TEX_WER_bAs','px_tex',1)
?};
exec('unlock','px_tex',_lock_res);
~~


\px_tex_activate_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja 'Dezaktywuj' grupa przed w oknach wertowania PX_TEX
::   WY: 0/1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_ok:=0;
{? FUN.ask('Zaznaczono: %1 przepisów. Czy aktywować je wszystkie?'@[$PX_TEX.sel_size()])
|| _ok:=1;
   KOMM.init(250,,'Aktywacja przepisów planistycznych'@,'')
?};
_ok


\px_tex_activate_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Akcja 'Dezaktywuj' grupa po w oknach wertowania PX_TEX
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
KOMM.select(,,,,,0);
~~


\zl_tex_upd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Akcja 'Funkcje->Aktualizuj przepisy' w oknie zleceń
::----------------------------------------------------------------------------------------------------------------------
_args_mp:=exec('mp_run_a','#b__box');
_args_mp.AKCJA:='AKCJA';
_args_mp.ACT_UID:='TPP_PPS_DGPL';
_args_mp.UIDREF:=exec('FindAndGet','#table',ZL,VAR.A_ZLEC,,"uidref()",null());
_args_mp.PROC_START:='N';
_args_mp.PORTS_IN:=exec('portsIn','#b__box',_args_mp.ACT_UID);
exec('portsInSet','#b__box',_args_mp.PORTS_IN,_args_mp.ACT_UID,'ZL',VAR.A_ZLEC);
exec('mp_run','#b__box',_args_mp);
~~


\grayed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wyszarzanie akcji w oknie PX_TEX
::   WE: _a - akronim okna
::----------------------------------------------------------------------------------------------------------------------
_grayed:=':';
{? PX_TEX.AKT='T'
|| _grayed:='PU'+_grayed
|? PX_TEX.KIND=PXoTEX.kind.table('ZL') | PX_TEX.KIND=PXoTEX.kind.auto('ZL')
|| _grayed:='PU'+_grayed
?};
PX_TEX.actions_grayed(_a,_grayed);
~~


\PxTexCEtapSel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: aj [12.46]
:: OPIS: Tworzy okienko .EtapSel - okienko z procesami
::   WE: PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_tab:=_pxtex.EtapTab;

_win_ident:='#pxtexetapsel';
_wer:=_tab.mk_sel('Zrównoleglenie procesów'@,'P',0,_pxtex.wid_Etap,1,1,{? _tab.size()>30 || 30 || _tab.size() ?},1,,,,1);
_tab.win_fld(_wer,,'USED'  ,,,-7,,,'Używany'@,,'Zasób jest używany w przepisie.'@,2,,"'T'","'N'");
_tab.win_fld(_wer,,'A'     ,,,-7,,,'Aktywny'@,,'Zasób jest aktywny.'@,2,,"'T'","'N'");
_tab.win_fld(_wer,,'KONT_N',,,40,,,,,'Nazwa zasobu'@);

_def_cols:=exec('get','#params',8055,,OPERATOR.USER);

_maxwfld:={? _pxtex.DimE>_pxtex.MaxWCol-3
          || _pxtex.MaxWCol-3
          || {? _pxtex.DimE>_def_cols
             || _pxtex.DimE
             || _def_cols
             ?}
          ?};
_maxwfld:=exec('min','#math',_pxtex.MaxWCol-3,_maxwfld);
{! _col:=1.._maxwfld
|! _tab.win_fld(_wer,,'COL'+form(_col,-3,0,'99'),,,3)
!};

_tab.win_act(_wer,,'Rekord',,,,"{? cur_tab(1,1).COLOR<>'' || cur_tab(1,1).COLOR || ~~ ?}");

_tab.win_fml(_wer,,'KONT_N',,'ICON_BEFORE',"{?cur_tab(1,1).ICON<>'' || cur_tab(1,1).ICON ||'xwin16.png:110'?}",2);

:: Ikonki w Grid
::{! _col:=1.._pxtex.MaxCol
::|! _tab.win_fml(_wer,,'COL'+form(_col,-3,0,'99'),,'ICON_BEFORE',"{? fld()<>'' || 'xwin16.png:188' || 'xwin16.png:110' ?}",2)
::!};

_fml:=$("exec('grid_icon_procesy','px_tex',"+{? (!_pxtex)<>'' || !_pxtex || 'PxTex' ?}+")");
{! _col:=1.._pxtex.MaxCol
|! _tab.win_fml(_wer,,'COL'+form(_col,-3,0,'99'),,'ICON_BEFORE',_fml,2)
!};

::_tab.win_act(_wer,0,'Formuła','Zakres',,,"exec('PxTexEtapZakres','px_tex',PxTex)",,1);
::_tab.win_act(_wer,1,'Formuła','Zakres',,,"exec('PxTexEtapZakres','px_tex',PxTex)",,1);
_tab.win_act(_wer,,'Formuła','Zwiń/roz&wiń'@@,,,"exec('zwrw_all','#tree',PxTex.EtapTab,'TREE',PxTex.EtapSel)",,1,,,,'W');

_formula:="exec('legenda','color','@PX_TEX#01','#PX_KONT#01','#PX_GRID#01','#PX_GRID#02')";
_tab.win_act(_wer,,'Formuła','Legenda'@@,,,_formula,,,,,,'L');
_pxtex.EtapSel:=_wer;

exec('load_procesy','px_tex',_pxtex);

_tab.first();
~~


\load_procesy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Ładuje Grid na zakładce Procesów
::   WE: _a - PxTex
::       [_b] - tab_tmp - tabela z procesami, jeśli nie podana to tworzona nowa
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;

_can_continue:=1;
_tab:=_pxtex.EtapTab;
{? var_pres('_b')>100
|| _procesy:=_b
|| _procesy:=exec('ilprocesow','px_nast',_pxtex)
?};

_pxtex.DimE:=0;
{? _procesy.first()
|| {!
   |? {? _procesy.IP>_pxtex.DimE
      || _pxtex.DimE:=_procesy.IP
      ?};
      _procesy.next()
   !};
   _pxtex.DimE+=1
?};

_var:=obj_new('tree','put','add');

_var.tree:="
   _tab:=_a;
   _ndx:=_tab.ndx_tmp(,,'TAB_REF',,);
   _tab.cntx_psh();
   _tab.index(_ndx);
   _tab.prefix(_b);
   _tree:={? _tab.first() || #_tab.ref() || 0 ?};
   _tab.cntx_pop();
   _tab.ndx_drop();
   _tree
";

_var.put:="

:: Operujemy na węźle drzewa
   _ref:=_a;
   _col:=_b;
   _kolor:='';
   {? var_pres('_c')=type_of('')
   || _kolor:=_c
   ?};

   _tab:=PxTex.EtapTab;
   _tab.cntx_psh();
   _tab.clear();
   {? _tab.seek(_ref,)
   || _tab.USED:='T';
      _tab.A:='T';
      _fml:='PxTex.EtapTab.'+'COL'+form(_col,-3,0,'99');
      _ile_bylo:=#($_fml)();
      _ile_bylo+=1;
      ($_fml)():=$_ile_bylo;
      _tab.put()
   ?};
   _tab.cntx_pop()
";

_var.add:="
:: Dodaje liść drzewa
   _tab:=_a;
   _nazwa:=_b;
   _tree:=_c;
   _ref:=_d;
   _pole:=_e;
   _kolor:='';
   {? var_pres('_f')=type_of('')
   || _kolor:=_f
   ?};
   _tab.prefix(_tree,'',_nazwa,);
   {? ~_tab.first()
   || _tab.blank();
      _tab.clear();
      _tab.TREE:=_tree;
      _tab.KONT_N:=_nazwa;
      _tab.KIND:='';
      _tab.ICON:='';
      _tab.TAB_NAM:=8+$_ref;
      _tab.TAB_REF:=#_ref;
      _fml:='PxTex.EtapTab.'+'COL'+form(_pole,-3,0,'99');
      ($_fml)():='1';
      _tab.USED:='T';
      _tab.A:='T';
      {? _tab.add()
      || .put(_tree,_pole,_kolor)
      ?}
   ?};
   _tab.prefix()
";
_procesy.prefix();
_max:=0;

{? _procesy.last()
|| _max:=_procesy.IP;

:: Najpierw ładujemy tylko powiązane
   {!
   |?
      _lp:=(_max-_procesy.IP+1);
      _px_start:=exec('FindAndGet','#table',PX_STAGE,_procesy.START,,,null());
      {? _procesy.IP>0
      || exec('pxnast2pxkont','px_nast',_pxtex,_px_start,_var,_lp)
      ?};
      _procesy.prev()
   !};

:: Nastepnie ładujemy niepowiazane
   _procesy.first();
   {!
   |?
      _px_start:=exec('FindAndGet','#table',PX_STAGE,_procesy.START,,,null());
      {? _procesy.IP=0
      || exec('pxnast2pxkont','px_nast',_pxtex,_px_start,_var,1)
      ?};
      _procesy.next()
   !}
?};
_tab.first();
~~


\reload_procesy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS:
::   WE:
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=PxTex;
_tab:=_pxtex.EtapTab;
:: Czyścimy dotychczasowa zawartość
_tab.cntx_psh();
_tab.index(_pxtex.EtapNd__);
_tab.prefix(0);
{? _tab.first()
|| {!
   |? _can_continue:=exec('tree_del','#tree',_tab,0);
      _tab.first() & _can_continue>0
   !}
?};
_tab.cntx_pop();

exec('Load_Px_Kont','px_tex');
exec('load_procesy','px_tex',PxTex);
grp_disp(PxTex.EtapTab,PxTex.EtapSel);
grp_disp(PxTex.OperTab,PxTex.OperSel,0);
~~


\PxTexCEtapTab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.46]
:: OPIS: Tworzy tabele .EtapTab
::   WE: PxTex
::----------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_pxtex.MaxCol:=255-9;
{? _pxtex.DimE>_pxtex.MaxCol || _pxtex.DimE:=_pxtex.MaxCol ?};
:: formula na utworzenie tabeli
_fml:="tab_tmp(2";
:: pozostaly pola opisowe i techniczne
_fml+="
      ,'TREE'    ,'TREE_REF'   ,'TREE'
      ,'KONT_N'  ,'STRING[100]','Nazwa'
      ,'KIND'    ,'STRING[1]'  ,'Rodzaj'
      ,'COLOR'   ,'STRING[20]' ,'Kolor rekordu'
      ,'PARIL'   ,'INTEGER'    ,'Ilość etapów równoległych'
      ,'ICON'    ,'STRING[16]' ,'Ikona'
      ,'TAB_REF' ,'INTEGER'    ,'#TAB.ref()'
      ,'TAB_NAM' ,'STRING[8]'  ,'TAB.name()'
      ,'USED'    ,'STRING[1]'  ,'Używany'
      ,'A'       ,'STRING[1]'  ,'Aktywny'";
:: dodawane sa kolumny
{! _col:=1.._pxtex.MaxCol |! _fml+="\n,'COL"+form(_col,-3,0,'99')+"','"+_pxtex.CellType+"','"+form(_col,,0,'99')+"'" !};
_fml+=")";
:: formula gotowa, wiec czas ja wykonac i skasowac
_pxtex.EtapTab:=($_fml)(); &_fml;

_pxtex.EtapNd__:=_pxtex.EtapTab.ndx_tmp(,
                                       ,'TREE'  ,,
                                       ,'KIND'  ,,
                                       ,'KONT_N',,
                                       );

_pxtex.EtapNdU_:=_pxtex.EtapTab.ndx_tmp(,
                                       ,'USED'  ,,1
                                       ,'TREE'  ,,
                                       ,'KIND'  ,,
                                       ,'KONT_N',,
                                       );

_pxtex.EtapNdA_:=_pxtex.EtapTab.ndx_tmp(,
                                       ,'A'     ,,1
                                       ,'TREE'  ,,
                                       ,'KIND'  ,,
                                       ,'KONT_N',,
                                       );

_pxtex.EtapNdAU:=_pxtex.EtapTab.ndx_tmp(,
                                       ,'A'     ,,1
                                       ,'USED'  ,,
                                       ,'TREE'  ,,
                                       ,'KIND'  ,,
                                       ,'KONT_N',,
                                       );

_pxtex.EtapTab.index(_pxtex.EtapNd__);

:: formuly pol

_pxtex.EtapTab.fld_fml('USED'    ,'BEFORE_DISPLAY',"{? fld()='T' || Color.fnd_kol('PX_TEX#01#01') || ~~ ?}");
_pxtex.EtapTab.fld_fml('A'       ,'BEFORE_DISPLAY',"{? fld()='N' || Color.fnd_kol('PX_TEX#01#02') || ~~ ?}");
_pxtex.EtapTab.fld_fml('KONT_N'  ,'BEFORE_DISPLAY',"{? cur_tab(1,1).A='N' || Color.fnd_kol('PX_TEX#01#02') || ~~ ?}");

_pxtex.EtapTab.fld_fml('USED'    ,'DISPLAY_FORMAT',{? _pxtex.DEVELOP=0 || "'empty=1'" || "{? fld()='' || 'empty=1' || 'empty=0' ?}" ?});
_pxtex.EtapTab.fld_fml('A'       ,'DISPLAY_FORMAT',{? _pxtex.DEVELOP=0 || "'empty=1'" || "{? fld()='' || 'empty=1' || 'empty=0' ?}" ?});

::{! _col:=1.._pxtex.MaxCol
::|! _fld_acr:='COL'+form(_col,-3,0,'99');
::   _pxtex.EtapTab.fld_fml(_fld_acr, 'DISPLAY_FORMAT',
::                          {? _pxtex.DEVELOP=0 || "'empty=1'" || "{? fld()='' || 'empty=1' || 'empty=0' ?}" ?}
::                         );
::   _pxtex.EtapTab.fld_fml(_fld_acr, 'BEFORE_DISPLAY',$("exec('grid_color_procesy','px_tex',"+{? (!_pxtex)<>'' || !_pxtex || 'PxTex' ?}+")"));
::   ~~
::!};
~~


\PxTexEtapZakres
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.46]
:: OPIS: Zmiana zakresu dla EtapTab w PxTex
::   WE: _a - PxTex
::----------------------------------------------------------------------------------------------------------------------
_PxTex:=_a;

_tab:=tab_tmp(1,'USED','STRING[1]','Użycie','A','STRING[1]','Aktywność');
_edt:=_tab.mk_edit('Zakres');
_tab.win_edit(_edt);
_tab.win_efld(_edt,AH,'H',,,,,,'Proszę określić zakres wg'@);
_tab.win_efld(_edt,AH,'H');
_tab.win_efld(_edt,,'USED',,,,,,,,,'radio-buttons',,
   'Wszystkie'@,"'W'",
   'Używane'@,"'T'",
   'Nieużywane'@, "'N'");
_tab.win_efld(_edt,AH,'H');
_tab.win_efld(_edt,,'A',,,,,,,,,'radio-buttons',,
   'Wszystkie'@,"'W'",
   'Aktywne'@,"'T'",
   'Nieaktywne'@, "'N'");
_tab.win_efld(_edt,AH,'H');
_tab.win_ebtn(_edt,'text=%1'['&Zapisz'@],'key:F2');
_tab.win_ebtn(_edt,'text=%1'['&Anuluj'@],'key:Esc');

_tab.USED:=_PxTex.EtapUsed;
_tab.A:=_PxTex.EtapAkt;

{? _tab.edit()
|| _PxTex.EtapUsed:=_tab.USED;
   _PxTex.EtapAkt:=_tab.A;

   {? _PxTex.EtapUsed='W'  & _PxTex.EtapAkt='W'  || _PxTex.EtapTab.index(_PxTex.EtapNd__);
                                                    _PxTex.EtapTab.prefix()
   |? _PxTex.EtapUsed='W'  & _PxTex.EtapAkt<>'W' || _PxTex.EtapTab.index(_PxTex.EtapNdA_);
                                                    _PxTex.EtapTab.prefix(_PxTex.EtapAkt)

   |? _PxTex.EtapUsed<>'W' & _PxTex.EtapAkt='W'  || _PxTex.EtapTab.index(_PxTex.EtapNdU_);
                                                    _PxTex.EtapTab.prefix(_PxTex.EtapUsed)
   |? _PxTex.EtapUsed<>'W' & _PxTex.EtapAkt<>'W' || _PxTex.EtapTab.index(_PxTex.EtapNdAU);
                                                    _PxTex.EtapTab.prefix(_PxTex.EtapAkt,_PxTex.EtapUsed)
   ?};

   _PxTex.EtapTab.win_sel(_PxTex.EtapSel);
   _PxTex.EtapTab.hdr_sel();
   _PxTex.EtapTab.hdr_sel(
      'Zakres widocznych zasobów: użycie — '+
      {? _PxTex.EtapUsed='W' || 'wszystkie' |? _PxTex.EtapUsed='T' || 'używane' || 'nieużywane' ?}+
      ' / aktywność — '+
      {? _PxTex.EtapAkt='W' || 'wszystkie' |? _PxTex.EtapAkt='T' || 'aktywne' || 'nieaktywne' ?}
   );
   ~~
?};
~~


\get_rodz_tex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Podanie wartosci dla pola ZL.RODZ_TEX
::       Działa w kontekście bieżącego ZL
::   WY: ['P'] lub 'Z'
::----------------------------------------------------------------------------------------------------------------------
_opc:='N';
{? ZL.RODZAJ='Z'
|| _opc:=exec('get','#params',500368)
|? (ZL.RODZAJ='P') & (ZL.NRNZL<>0)
|| ZL.cntx_psh();
   ZL.index('UNRZL');
   ZL.prefix(ZL.NRNZL);
   {? ZL.first() & (ZL.RODZAJ='Z')
   || _opc:={? ZL.RODZ_TEX='Z'
            || 'T'
            || 'N'
            ?}
   ?};
   ZL.cntx_pop()
?};
{? _opc='T'
|| 'Z'
|| 'P'
?}


\stat_tex_pop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Ustalenie warunkow generowania przepisu z tego poziomu
::   WE: [_a] - ZL.ref, jeśli nie podane to VAR.A_ZLEC
::   WY: dwuznakopwy string
::       1 znak: 'Z' - zintegrowany, 'P' - prosty
::       2 znak: 'T' - byly wykonania, 'N' - nie bylo wykonan
::----------------------------------------------------------------------------------------------------------------------

_zl:=VAR.A_ZLEC;
{? var_pres('_a')=type_of(ZL.ref())
|| _zl:=_a
?};

_rodzaj:=exec('FindAndGet','#table',ZL,_zl,,"RODZAJ",'');
{? _rodzaj='Z'
||
:: zlecenie rodzaju Z, sprawdzenie jaki rodzaj przepisu
   _what:=exec('what_tex_prior','px_tex',_zl)
||
:: ewentualna mozliwosc tworzenia wylacznie przepisow prostych
:: sprawdzenie, czy wolno w tej sytuacji generowac przepis
   _what:='P';
   {? exec('get_tex_zl','px_tex',_zl)<>null
   || _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
      {? exec('has_wyki','px_wyk',_px_obj)>0
      || _what+='T'
      || _what+='N'
      ?}
   || _what+='N'
   ?}
?};
_what


\what_tex_prior
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Ustalenie rodzaju i statusu poprzedniego przepisu
::   WE: [_a] - ZL.ref - [VAR.A_ZLEC]
::   WY: dwuznakopwy string
::       1 znak: 'Z' - zintegrowany, 'P' - prosty
::       2 znak: 'T' - byly wykonania, 'N' - nie bylo wykonan
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null()) || _a:=VAR.A_ZLEC ?};

_zlecd:=_a;
_odp1:='P';
_odp2:='N';

_can_continue:=1;

ZL.cntx_psh(); ZL.prefix();
{? ZL.seek(_zlecd)
||
   _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
   _odp1:=ZL.RODZ_TEX;
:: sprawdzenie czy sa wykonania
   {? ZL.RODZAJ='Z' & ZL.RODZ_TEX='Z'
   ||
::    Zlecenie złożone, przepis zintegrowany
      _odp2:={? exec('has_wyki','px_wyk',_px_obj)>0 || 'T' || 'N' ?}
   |? ZL.RODZAJ='P' & ZL.RODZ_TEX='Z'
   ||
::    Podzlecenie, przepis zintegrowany
      _top_obj:=exec('get_zl_object','px_obj',exec('top_level','zl_link',ZL.ref()));
      _odp2:={? exec('has_wyki','px_wyk',_top_obj)>0 || 'T' || 'N' ?}
   |?  ZL.RODZAJ='Z' & ZL.RODZ_TEX='P'
   ||
::    Zlecenie złożone, przepis prosty
      ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || _lwyk:=0;
         {!
         |? _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
            {? exec('has_wyki','px_wyk',_px_obj)>0
            || _odp2:='T';
               _can_continue:=0
            ?};
            ZL.next() & _can_continue>0
         !}
      ?};
      ZL.cntx_pop()
   |? ZL.RODZAJ='P' & ZL.RODZ_TEX='P'
   ||
::    Zleecnie proste, przepis prosty
      _odp2:={? exec('has_wyki','px_wyk',_px_obj) || 'T' || 'N' ?}
   ?}
?};
ZL.cntx_pop();
_odp1+_odp2


\lock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Blokuje podany przepis planistyczny
::   WE: [_a] - PX_TEX.ref - przepis który zablokować, lub bieżący rekord
::       [_b] - INTEGER - czy akcja grupowa, jeżeli nie podane to określane na podstawie cur_tab(1,1).sel_size()
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_TEX.ref())
|| _ref:=_a
?};
_grupa:=0;
{? var_pres('_b')=type_of(0)
|| _grupa:=_b
|| {? cur_tab(1,1).sel_size()>0
   || _grupa:=1
   ?}
?};

_result:=exec('lock_result','px_tex');
_can_continue:=1;

TKTL.cntx_psh();
PX_TEX.cntx_psh();
{? _ref<>null()
|| PX_TEX.prefix();
   {? PX_TEX.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _what:=exec('PX_TEX','#to_string');
   _can_continue:=exec('blk_lock','#table','PX_TEX',PX_TEX.ref(),,,'Przepis: %1 jest redagowany '@[_what],,_grupa);
   {? _can_continue>0
   || _result.PX_TEX:=PX_TEX.ref()
   ?}
?};

{? _can_continue>0
|| {? PX_TEX.TKTL<>null()
   ||
      _what:=exec('FindAndGet','#table',TKTL,PX_TEX.TKTL,,"exec('TKTL','#to_string')",'');
      _can_continue:=exec('blk_lock','#table','TKTL',PX_TEX.TKTL,,,'Przepis karty: %1 jest redagowany '@[_what],,_grupa);
      {? _can_continue>0
      || _result.TKTL:=PX_TEX.TKTL
      ?}
   ?}
?};

{? _can_continue>0
|| _result.LOCKED:=1
?};

PX_TEX.cntx_pop();
TKTL.cntx_pop();
_result


\unlock
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Oblokowuje podany przepis planistyczny
::   WE: _a - obj_new - obiekt zawierający wynik blokowania
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

{? var_pres('_obj')>100
||
   {? _obj.PX_TEX<>null()
   || exec('blk_unlock','#table','PX_TEX',_obj.PX_TEX)
   ?};
   {? _obj.TKTL<>null()
   || exec('blk_unlock','#table','TKTL',_obj.TKTL)
   ?};
   {? _obj.TAB<>'' & _obj.NAME<>'' & _obj.REF<>0
   || exec('blk_unlock','#table',_obj.TAB,_obj.NAME,_obj.REF)
   ?}
?};
~~


\lock_result
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.14]
:: OPIS: Obiekt zawierający resultat zablokowania PX_TEX
::   WY: obj_new()
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new('LOCKED'
               ,'PX_TEX'
               ,'TKTL'
               ,'TAB'
               ,'NAME'
               ,'REF');
_obj.LOCKED:=0;
_obj.PX_TEX:=null();
_obj.TKTL:=null();
_obj.TAB:='';
_obj.NAME:='';
_obj.REF:=0;
_obj


\chk_zgh4update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Sprawdza czy przepis może być generowany na podstawie przewodników
::   WE: [_a] - ZL.ref lub bieżący rekord
::   WY: 0 - nie może
::       1 - może
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
{? _ref<>null()
|| ZL.prefix();
   {? ZL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _zgh_present:=0;
   _zgh_all:=1;
   {? ZL.RODZAJ<>'P'
   || _zgh:=0;
::    jezeli jest chociaz jeden przewodnik to generacja wylacznie wg przewodnikow
      Cntx.psh(ZL,ZGH);
      _nrnzl:=ZL.UNRZL; ZL.index('NRNZL'); ZL.prefix(_nrnzl);
      {? ZL.first()
      || ZGH.index('ZLNR');
         {!
         |? ZGH.prefix(ZL.ref());
            {? ZGH.first()
            || _zgh_present:=1
            || _zgh_all:=0
            ?};
            ZL.next()
         !}
      ?};
      Cntx.pop(ZL,ZGH)
   ?};
   ZGH.cntx_psh();
   ZGH.index('ZLNR');
   ZGH.prefix(ZL.ref());
   {? (_zgh_present & _zgh_all) | (ZGH.size()>0)
   || _result:=1
   ?};
   ZGH.cntx_pop()
?};
ZL.cntx_pop();
_result


\create4tktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Tworzy rekord PX_TEX dla nagłówka technologii
::   WE: [_a] - TKTL.ref() lub bieżący rekord
::   WY: PX_TEX.ref lub null
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(TKTL.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

TKTL.cntx_psh();
{? _ref<>null()
|| TKTL.prefix();
   {? TKTL.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_TEX.cntx_psh();
   PX_TEX.index('TKTL');
   PX_TEX.prefix('T',PXoTEX.kind.table('TKTL'),TKTL.ref());
   {? PX_TEX.first()
   || _result:=PX_TEX.ref()
   || PX_TEX.blank();
      PX_TEX.AKT:='T';
      PX_TEX.KIND:=PXoTEX.kind.table('TKTL');
      PX_TEX.SYMBOL:=TKTL.NRK;
      PX_TEX.VER:=TKTL.WER;
      PX_TEX.PX_RULES:=PXoTEX.Rules.tex_tex;
      PX_TEX.XJM:=TKTL.XJM;
      PX_TEX.TKTL:=TKTL.ref();
      PX_TEX.RTKTL:=$TKTL.ref();
      _can_continue:=PX_TEX.add();
      {? _can_continue>0
      || _result:=PX_TEX.ref()
      ?}
   ?};
   PX_TEX.cntx_pop();
   ~~
?};
TKTL.cntx_pop();
_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:37 b225d42d78f94147f9491487055e8f1d09f433a9e3313db621baca6d19301080a6992994e153342770f9b93629cfb53e0030d654de8f1018fd1627f51adb631cd499430207a0eb6924de7344996f2522be74047d537bae1f3abb28442e2c545ce4ada65208dfe327568804f992f82aa2b595b3ca73bfc0c2e828c6614a46146e
