:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: tech_mater.fml
:: Utworzony: 11.03.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły do obsługi surowców kart technologicznych, wzorców, technologii zlecenia
::            (biblioteka wspólna dla TTE_TEC, TTE_WTE, TTE_PZL)
::            Obsługa tebel:
::            - TMAT - surowce technologiczne
::            - TCHMAT - zamienniki surowców
::            - TTG - grupy technologiczne
::            - TTGP - pozycje grup technologicznych
::======================================================================================================================


:: UWAGA: komentarze 'Metoda nieaktywna: %1.' są do usunięcia wraz z fragmentami kodu, o ile nie pojawią się wywołania


\buffer_tmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca obiekt nazwany - bufor tabeli TMAT
::   WY: obj_new()
::----------------------------------------------------------------------------------------------------------------------
exec('TMAT','buffer')


\buffer_tchmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca obiekt nazwany - bufor tabeli TCHMAT
::   WY: obj_new()
::----------------------------------------------------------------------------------------------------------------------
exec('TCHMAT','buffer')


\tmat_main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Podstawowa formuła wyświetlająca surowce
::   WE: _a - TKTL.ref()
::       _b - TOPER.ref()
::       _c - INTEGER - tryb wyświetlania, wszystkie surowce, albo danej operacji:
::                         0 prefiksowane operacją VAR.A_OP - redakcja na wybranym poziomie
::                         1 nie prefiksowane operacją - podgląd listy na najwyższym poziomie
::       _d - INTEGER - inicjowanie środowiska (1), brak inicjowania (0)
::       _e - INTEGER - karta używana na wyższym poziomie wywołania (np. operacje)
::       _f - INTEGER - sposób selekcji okna z operacjami (o ile ma znaczenie)
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_tktl:=_a;
VAR.A_OP:=_b;
_disp_all:=_c;
_init:=_d;
_used:=_e;
_zakl:=_f;

{? VAR.A_OP<>null() & VAR.A_OP().PZ='Z'
|| FUN.emsg('Do operacji złożonej nie można przypisać surowców.'@)
|| TKTL.cntx_psh();
   TKTL.clear();
   {? TKTL.seek(_tktl)
   || _stan:=TKTL.STAT_S;
      {? _init || exec('menu_start','tech_head') ?};
      exec('surowce','tech_mater',_disp_all,_used);
      {? _init || exec('menu_stop','tech_head') ?};
      TKTL.get();
      {? VAR.A_OP<>null() & _stan<>TKTL.STAT_S & _zakl=4 || sel_exit() ?}
   ?};
   TKTL.cntx_pop()
?};
~~


\env_mater
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca zmienną środowiskową do obsługi listy surowców technologicznych
::----------------------------------------------------------------------------------------------------------------------
_env:=obj_new('used','wins','buffer_tmat','buffer_tmat_grp','buffer_tchmat','fields');
_env.used:=0;
_env.wins:=obj_new('WERMG','WERMM','WERCG','WERCM');
_env.buffer_tmat:=exec('buffer_tmat','tech_mater');
_env.buffer_tchmat:=exec('buffer_tchmat','tech_mater');
_env.buffer_tmat_grp:=exec('buffer_tmat','tech_mater');
_env.fields:=obj_new('PT','TGDFLT','GRKTM','KTL','MAT','KTLMAT','DJM','NROP','TOPER');
_env


\surowce
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Surowce do karty technologicznej
::   WE: _a - INTEGER - tryb wyświetlania, wszystkie surowce, albo danej operacji:
::                         0 prefiksowane operacją VAR.A_OP - redakcja na wybranym poziomie
::                         1 nie prefiksowane operacją - podgląd listy na najwyższym poziomie
::       _b - karta używana na wyższym poziomie wywołania (np. operacje)
::  OLD: \surowce/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_disp_all:=_a;
_used_oper:=_b;

_komplet:=(TKTL.TYP().TYP=exec('k_res_string','tech_head'));
_hdr:=': '+'%1 wersja: %2'@[TKTL.NRK,TKTL.WER];

_locked:=exec('tktl_lock','tech_common',,'S');
_used:=~_locked | _used_oper;

:: Ustawienie zmiennych środowiska w oknie wertowania
_env_mater:=exec('env_mater','tech_mater');
_env_mater.used:=_used;
_wins:=_env_mater.wins;
:: Jeżeli jest zmienna środowiskowa env, to ją przepycham (plus info, żeby wyłączyć niektóre funkcje jak jej nie ma)
_params:=params_get();
{? var_pres('_params')>100 & var_pres('env',_params)>100
|| params_set('env',_params.env,'env_mater',_env_mater);
   _info_env:=1
|| params_set('env_mater',_env_mater);
   _info_env:=0
?};

_interm:=exec('interm','#system');
_atrmjs:=ATR.MJS;
ATR.MJS:='TMAT';
VAR.TOW_USL:='T';
ZAKR.MATU:='';
{? _disp_all || VAR.A_OP:=null() ?};
_act:={? VAR.A_OP=null() || 1 || VAR.A_OP().ACT='T' ?};
_arc:=(TKTL.ARCH='T');
_m_ref:=M.ref();
M.cntx_psh();
TKTL.cntx_psh();
_wer:={? ~_komplet || {? _disp_all || 'WERO_'+TKTL.TORW || 'WER_'+TKTL.TORW ?} || 'WER_S' ?};

{? ((TKTL.TORW='T' & exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRTS')) |
    (TKTL.TORW='W' & exec('chk_role','#b__box',OPERATOR.USER,'TTE_WTE_DRTS')) |
    (TKTL.TORW='Z' & exec('chk_role','#b__box',OPERATOR.USER,'TTE_PZL_DTEC'))
   )
      &
   ~_arc & TKTL.STAT_S='N' & ~_used & (TKTL.STAT_N='T' | TKTL.TORW='Z')
|| _fb:="
      {? exec('get','#params',500740,2)='N'
      || M.index('ARODZ'); M.prefix('T','T')
      || M.index('R_KOMP'); M.prefix('T','T','T')
      ?}
   ";
   _grp:=TMAT.grp_make('Surowce technologiczne'@+_hdr,_fb,'#tmat_grp',,10,,,'html_maximized');

   _after_refresh:="";
   {? _interm=0
   || _after_refresh:="grp_disp(TTG,params_get().env_mater.wins.WERMG); grp_disp(M,params_get().env_mater.wins.WERMM)"
   ?};
   TMAT.grp_sel(_grp,,_wer,,_after_refresh,,,,,,,,'maximized');

   {? _interm=0
   || TMAT.grp_splt(_grp,,'vertical','slowniki',',67%');
      _wins.WERMM:=M.mk_sel('Materiały'@,'P',0,'material_wer',,,,,'U');
      M.win_fld(_wins.WERMM,,'KTM',,,10);
      M.win_fld(_wins.WERMM,,'N',,,20);
      _action:="exec('info_zam','magazyn_stan',5,M.ref())";
      M.win_act(_wins.WERMM,,'Formuła','Szcz&egóły'@@,,,_action,,1);
      M.win_act(_wins.WERMM,,'Kolejność');
      M.win_fml(_wins.WERMM,,'KTM',,'ICON_BEFORE',"exec('m_tktl_icon','tech_common')");
      M.win_act(_wins.WERMM,,'Formuła','Legenda'@,,,"exec('legenda','color','KTM#')",,,,,,'L');
      TMAT.grp_sel(_grp,M,_wins.WERMM,'Materiały'@,,,,,,,,,'maximized');
      _wins.WERMG:=TTG.mk_sel('Grupy technologiczne'@,'P',0,'ttechgr_wer',,,,,'U');
      TTG.win_fld(_wins.WERMG,,'GR',,,10);
      TTG.win_fld(_wins.WERMG,,'OPIS',,,20);
      {? (exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRTS') |
          exec('chk_role','#b__box',OPERATOR.USER,'TTE_WTE_DRTS') |
          exec('chk_role','#b__box',OPERATOR.USER,'TTE_PZL_DTEC'))
      || TTG.win_act(_wins.WERMG,0,'Dołącz');
         TTG.win_act(_wins.WERMG,1,'Dołącz');
         TTG.win_act(_wins.WERMG,,'Popraw');
         TTG.win_act(_wins.WERMG,,'Formuła','Usuń'@@,,,"exec('ttg_usun','tech_mater')")
      ?};
      TTG.win_act(_wins.WERMG,,'Formuła','P&ozycje'@@,,,"exec('ttg_pos','tech_mater')",,1);
      TTG.win_act(_wins.WERMG,,'Szukaj');
      TTG.win_act(_wins.WERMG,,'Kolejność');
      TTG.win_act(_wins.WERMG,,'Rekord',,,,,"exec('ttg_arec','tech_mater')");
      TMAT.grp_sel(_grp,TTG,_wins.WERMG,'Grupy technologicze'@,,,,,,,,,'maximized')
   ?};
   TMAT.win_sel(_grp)
||
   TMAT.win_sel(_wer)
?};

_keys:=':';
:: Ukrycie akcji wynikające z kontekstu programu
_uprDelSur:=0;
{? TKTL.TORW='Z'
|| _uprDelSur:=exec('uprDelSurZatwZl','tech_mater')
?};

{? TKTL.TORW<>'Z' || _keys:='WY'+_keys ?};
{? _used | _arc | ~_act | TKTL.STAN='N' & TKTL.TORW<>'Z' | TKTL.STAN='P' & TKTL.STAT_S='T' || _keys:='dPUWOZFŚ'+_keys+'dZF' ?};
{? TKTL.STAT_S='T' || _keys:='OZ'+_keys+'Z' ?};
::{? _disp_all || _keys:='d'+_keys+'d' ?};
{? exec('is_k_res','tech_head',VAR.A_TPKTL) | exec('is_t_res','tech_head',VAR.A_TPKTL) || _keys:='CR'+_keys+'' ?};
{? TKTL.TYP().PAR<>'T' || _keys:='R'+_keys ?};
{? ~(TKTL.STAN='T' & ~_arc & ~_used) || _keys:='Ó'+_keys ?};
{? TKTL.STAN='T' & (TKTL.TORW='W' | TKTL.TORW='Z' | ~exec('can_modify','tech_common'))
|| _keys:='dP'+{? _uprDelSur || '' || 'U' ?}+'ÓW'+_keys+'d'
?};
{? (TKTL.TORW='Z' & TKTL.STAN<>'T') | _arc || _keys:='F(DPWTU)'+_keys+'F(D)' ?};
{? TKTL.TORW='Z' & (exec('FindAndGet','#table',ZL,TKTL.ZL,,"NRNZL",0)=0 | _info_env=0) || _keys:='F(Z)'+_keys ?};
{? (TKTL.STAT_S='T' | TKTL.TORW='W' | _used | TKTL.ARCH='T' | TKTL.STAT_N='N' & TKTL.TORW<>'Z')
|| _keys:={? TKTL.TORW='Z' || 'J(WT)'+_keys+'J(WT)' || 'F(WT)'+_keys+'F(WT)' ?}
?};

::{? TKTL.TYP().SUR='K' || _keys:='Ś'+_keys ?};
TMAT.actions(_wer,_keys);
TMAT.hdr_sel();
{? _used
|| TMAT.hdr_sel(_hdr+' — '+'PODGLĄD'@)
|? TKTL.ARCH='T'
|| TMAT.hdr_sel(_hdr+' — '+'ARCHIWALNE'@)
|? TKTL.STAT_S='T'
|| TMAT.hdr_sel(_hdr+' — '+'ZATWIERDZONE'@)
?};
_red:={? ~_komplet || 'RED_'+TKTL.TYP().PAR || 'REDS' ?};
TMAT.win_edit(_red);
TMAT.index('NNL');
{? _disp_all
|| TMAT.prefix(VAR.A_KTL)
|| TMAT.prefix(VAR.A_KTL,VAR.A_OP)
?};
TMAT.first();
VAR.P_NKTM:='';
{? exec('get','#params',500740,2)='N'
|| exec('filter_clear','material')
|| exec('filter','material','PS')
?};

:: Renumeracja i dołączanie rekordów za pomocą d'n'd
_dnd:=1;
{? TKTL.TORW='Z' & TKTL.PLRELWYR<>null()
|| _dnd:=0
|? ~(exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRTS') & TKTL.TORW='T' |
     exec('chk_role','#b__box',OPERATOR.USER,'TTE_WTE_DRTS') & TKTL.TORW='W' |
     exec('chk_role','#b__box',OPERATOR.USER,'TTE_PZL_DTEC') & TKTL.TORW='Z')
|| _dnd:=0
?};

{? ~_used & ~_arc & TKTL.STAT_S='N' & _dnd>0
||
   TMAT.dnd_sel(_wer,,'records.TMAT',"
      _copy:=0;
      {? dnd_info('src_pos_in_window')=0
      || _copy:=1
      ?};
      {? _copy=0
      ||
::       Zmiana LP w oknie surowców
         TMAT.cntx_psh();
         _ref:=dnd_info('dest_record');
         {? TMAT.seek(_ref)
         || exec('zmien_lp','#dragdrop','LP','NNL')
         ?};
         TMAT.cntx_pop()
      ||
::       Kopiowanie surowca z innego miejsca (innej zakładki Merita)
         _records:=dnd_info('dropped_records');
         {? _records.first()
         || exec('insert_tbox_s','tech_arch',0,_records)
         ?}
      ?}
  ");

   TMAT.dnd_sel(_wer,,'records.TTG',"
      params_set(params_get());
      _records:=dnd_info('dropped_records');
      {? _records.size()>1
      || FUN.info('Dołączać można tylko pojedynczą pozycję.'@)
      || M.cntx_psh();
         {? exec('get','#params',500740,2)='N'
         || exec('filter_clear','material')
         || exec('filter','material','PS')
         ?};
         exec('TMATWERD','tech_mater');
         TMAT.blank();
         TMAT.GRKTM:='G';
         TTGP.clear();
         {? _records.first() & TTG.seek(_records.REF,)
         ||
            TMAT.TGRP:=TTG.ref();
            TTGP.index('GS');
            TTGP.prefix(TTG.ref());
            {? TTGP.size()=1
            ||
               {? TTGP.first()
               || VAR.A_T:=TTGP.PT;
                  VAR1.KTM:=TTGP.PT().KTM;
                  TMAT.TGDFLT:=TTGP.ref()
               ?}
            ||
               VAR.A_T:=null();
               VAR1.KTM:='';
               TMAT.TGDFLT:=null()
            ?};
            exec('TxMAT_PRZEL','tech_mater',TMAT,0,1);
            exec('TxMAT_UZYSK','tech_mater',TMAT);
            {? VAR.A_T().R='S' | M.R='H' || TMAT.DFLT_KTL:='N' ?};
            ATR.MJS:='TMAT';
            ATR.M_ATR:={? TMAT.PT<>null() || TMAT.PT().M_ATR
                       |? TMAT.TGDFLT<>null() || TMAT.TGDFLT().PT().M_ATR || null() ?};
            ATR.FLAG_ED:=ATR.CZY_ATR & ATR.M_ATR().EDIT;
            ATR.FLAG:={? ATR.FLAG_ED & ATR.M_ATR<>null() || 2 || 0 ?};
            {? ATR.FLAG_ED || {? ATR.M_ATR<>null() || ATR.FLAG_ED:=2 ?} ?};
            {? TMAT.DK_C<>null() & TMAT.DK_C().M_ATR<>null()
            || TMAT.DK_C().M_ATR().SYM;
               {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=($('TMAT.DK_C().WAR'+form(_i,-2,,'99')))() !}
            || ATR.M_ATR().SYM;
               {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !}
            ?};
            {! _i:=1..10
            |! _ch:=1+((_i-1)-TMAT.ATR_MASK);
               ($('ATR.ZL_WAR'+form(_i,-2,,'99')))():={? _ch='T' || 'T' || 'N' ?}
            !};

            exec('efld_opt','tech_mater',TMAT);
            {? TMAT.edit(\"params_exec('tchm_edt','tech_mater',TMAT)\")
            || {? TMAT.add()
               || exec('tmattpar','tech_mater');
                  win_set('cur_row_pos=-1')
               ?}
            ?}
         ?};
         M.cntx_pop()
      ?}
   ");

   TMAT.dnd_sel(_wer,,'records.M',"
      params_set(params_get());
      _records:=dnd_info('dropped_records');
      {? _records.size()>1
      || FUN.info('Dołączać można tylko pojedynczą pozycję.'@)
      || M.cntx_psh();
         {? exec('get','#params',500740,2)='N'
         || exec('filter_clear','material')
         || exec('filter','material','PS')
         ?};
         exec('TMATWERD','tech_mater');
         TMAT.blank();
         TMAT.GRKTM:='K';
         M.clear();
         {? _records.first() & M.seek(_records.REF,)
         ||
            params_get().env_mater.fields.MAT:=null();
            params_get().env_mater.fields.TOPER:=null();
            {? VAR.A_OP=null() | (VAR.A_OP<>null() & exec('sprktm','tech_mater',TMAT,M.ref()))
            ||
               TMAT.PT:=M.ref();
               VAR.A_T:=M.ref();
               VAR1.KTM:=M.KTM;
               exec('TxMAT_PRZEL','tech_mater',TMAT,0,1);
               exec('TxMAT_UZYSK','tech_mater',TMAT);
               {? VAR.A_T().R='S' | M.R='H' || TMAT.DFLT_KTL:='N' ?};
               ATR.MJS:='TMAT';
               ATR.M_ATR:={? TMAT.PT<>null() || TMAT.PT().M_ATR
                          |? TMAT.TGDFLT<>null() || TMAT.TGDFLT().PT().M_ATR || null() ?};
               ATR.FLAG_ED:=ATR.CZY_ATR & ATR.M_ATR().EDIT;
               ATR.FLAG:={? ATR.FLAG_ED & ATR.M_ATR<>null() || 2 || 0 ?};
               {? ATR.FLAG_ED || {? ATR.M_ATR<>null() || ATR.FLAG_ED:=2 ?} ?};
               {? TMAT.DK_C<>null() & TMAT.DK_C().M_ATR<>null()
               || TMAT.DK_C().M_ATR().SYM;
                  {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=($('TMAT.DK_C().WAR'+form(_i,-2,,'99')))() !}
               || ATR.M_ATR().SYM;
                  {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !}
               ?};
               {! _i:=1..10
               |! _ch:=1+((_i-1)-TMAT.ATR_MASK);
                  ($('ATR.ZL_WAR'+form(_i,-2,,'99')))():={? _ch='T' || 'T' || 'N' ?}
               !};

               exec('efld_opt','tech_mater',TMAT);
               {? TMAT.edit(\"params_exec('tchm_edt','tech_mater',TMAT)\")
               || {? TMAT.add()
                  || exec('tmattpar','tech_mater');
                     win_set('cur_row_pos=-1')
                  ?}
               ?}
            ?};
            VAR_DEL.delete('mat')
         ?};
         M.cntx_pop()
      ?}
   ")
||
   TMAT.dnd_sel(_wer,,'records.TMAT',"");
   TMAT.dnd_sel(_wer,,'records.TTG',"");
   TMAT.dnd_sel(_wer,,'records.M',"")
?};

_formikon:="
   TCHMAT.cntx_psh();
   TCHMAT.index('NSL');
   TCHMAT.prefix(VAR.A_KTL,TMAT.ref());
   {? TCHMAT.first()
   || _ico:='xwin16.png:92'
   || _ico:='xwin16.png:110'
   ?};
   TCHMAT.cntx_pop();
   _ico
";
TMAT.win_fml(_wer,VAR,'K_NKTM',,'ICON_BEFORE',_formikon,1);

TMAT.select();
TKTL.cntx_pop();
M.cntx_pop();
exec('filter','material','WP');
M.seek(_m_ref);
ATR.MJS:=_atrmjs;
VAR.KOR:=0;
{? JM.f_active()>0 || JM.f_clear() ?};

:: Oznaczenie karty jako 'Ulepszenie' - uzupełniane tylko dla kart (TKTL.TORW='T')
{? ~_used & ~_komplet & TKTL.TORW='T'
|| _improve:=TKTL.IMPROVE;
   {? exec('is_improvement','tech_head',TKTL.ref())
   || TKTL.IMPROVE:='T'
   || TKTL.IMPROVE:='N'
   ?};
   {? _improve<>TKTL.IMPROVE || TKTL.put() ?}
?};

{? _locked || exec('tktl_unlock','tech_common',,'S') ?};
~~


\blnrsrc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RS [2004.09.07]
:: OPIS: Blank liczby porządkowej surowca
::  OLD: \blnrsrc/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.DJ:=TMAT.NRK().TYP().DJ;
TMAT.cntx_psh();
TMAT.clear();
TMAT.index('NNL');
TMAT.prefix(VAR.A_KTL,VAR.A_OP);
{? TMAT.last()
|| _res:=TMAT.LP+1
|| _res:=1
?};
TMAT.cntx_pop();
_res


\tch_blnr
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Blank liczby porządkowej zamiennika surowca
::  OLD: \tch_blnr/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
TCHMAT.cntx_psh();
TCHMAT.clear();
TCHMAT.index('NSL');
TCHMAT.prefix(VAR.A_KTL,TMAT.ref());
{? TCHMAT.last()
|| _res:=TCHMAT.LP+1
|| _res:=1
?};
TCHMAT.cntx_pop();
_res


\tm_shead
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Przed redakcją pola TMAT.LP, TMAT.EXIST
::   WY: 0 / 1
::  OLD: \tm_shead/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
TKTL.STAT_S='N' | VAR.KOR


\tm_chngm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Przed redakcją pola TCHMAT.LP, TCHMAT.EXIST
::   WY: 0 / 1
::  OLD: \tm_chngm/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
TKTL.STAT_S='N' | VAR.KOR


\get_tmat_grktm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Zwraca znacznik czy grupa technologiczna czy pojedynczy surowiec (blank pola TCHMAT.GRKTM)
::   WY: TMAT.GRKTM
::----------------------------------------------------------------------------------------------------------------------
TMAT.GRKTM


\be_m_grktm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Przed redakcją pola TMAT.GRKTM
::   WY: 0 / 1
::  OLD: \be_m_grktm/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
params_get().env_mater.fields.GRKTM:=fld();
TKTL.STAT_S='N' | VAR.KOR | VAR.GRP_MOD='P'


\be_c_grktm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Przed redakcją pola TCHMAT.GRKTM
::   WY: 0 / 1
::  OLD: \be_c_grktm/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
params_get().env_mater.fields.GRKTM:=fld();
TKTL.STAT_S='N' | VAR.KOR


\ae_m_grktm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Po redakcji pola TMAT.GRKTM
::   WY: 1
::  OLD: \ae_m_grktm/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? params_get().env_mater.fields.GRKTM<>fld()
|| TMAT.TGRP:=null();
   TMAT.TGDFLT:=null();
   TMAT.PT:=null();
   VAR.A_T:=null();
   VAR1.KTM:='';
   win_disp()
?};
exec('efld_opt','tech_mater',TMAT);
1


\tchmat_grktm_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Po redakcji pola TCHMAT.GRKTM
::   WY: 1
::  OLD: \tchmat_grktm_ae/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? params_get().env_mater.fields.GRKTM<>fld()
|| TCHMAT.TGRP:=null();
   TCHMAT.TGDFLT:=null();
   TCHMAT.PT:=null();
   VAR.A_T:=null();
   VAR1.KTM:='';
   win_disp()
?};
exec('efld_opt','tech_mater',TCHMAT);
1


\efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Opcje pól w oknach redagowania tabel TMAT, TCHMAT
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
{? VAR.GRP_MOD='P'
|| _mark:={? _tab.TGRP<>null() || '1' || '0' ?};
   _tab.efld_opt(_tab.win_edit('?'),{? _tab.GRKTM='G' || 'mark='+_mark+',enable=1' || 'mark=0,enable=0' ?},,'TGRP');
   _tab.efld_opt(_tab.win_edit('?'),{? _tab.GRKTM='G' || 'mark='+_mark || 'mark=0' ?},VAR1,'KTM')
|| _tab.efld_opt(_tab.win_edit('?'),{? _tab.GRKTM='G' || 'mark=1,enable=1' || 'mark=0,enable=0' ?},,'TGRP');
   _tab.efld_opt(_tab.win_edit('?'),'mark=1',VAR1,'KTM')
?};
{? _tab=TMAT
||
::   TMAT.efld_opt(TMAT.win_edit('?'),{? TKTL.TYP().SUR='K' || 'mark=0,enable=0' || 'mark=0,enable=1' ?},VAR,'STRING');
   TMAT.efld_opt(TMAT.win_edit('?'),{? TMAT.LIMIT='T' || 'enable=0' || 'enable=1' ?},,'ROZ')
?};
_dj:=TKTL.TYP().DJ;
_par:=TKTL.TYP().PAR;
_so:={? _tab=TMAT || _tab.SO || 'S' ?};
_tab.efld_opt(_tab.win_edit('?'),{? _dj='P' || 'mark=0' || 'mark=1' ?},,'DJM');
_tab.efld_opt(_tab.win_edit('?'),{? _dj='P' & _so='S' || 'mark=1' || 'mark=0' ?},,{? _par='T' || 'FORMB' || 'WARB' ?});
_tab.efld_opt(_tab.win_edit('?'),{? _dj<>'P' & _so='S' || 'mark=1' || 'mark=0' ?},,{? _par='T' || 'DFORMB' || 'DWARB' ?});
TKTLW.cntx_psh();
TKTLW.use((TKTLW.name()-3)+'___');
TKTLW.index('KARC');
TKTLW.prefix();
::TKTLW.prefix('T',VAR.A_T,'N');
TKTLW.f_set(,'join TKTL using(TKTLW.TKTL,TKTL.REFERENCE)'
            ,'
            TKTL.TORW=\'T\'
            and TKTLW.KTM=:_a
            and TKTL.ARCH=\'N\'
            and ((TKTL.TERM_OD<=to_date(:_b) and TKTL.TERM_OD IS NOT NULL)
            or TKTL.TERM_OD IS NULL)
            and ((TKTL.TERM_DO>=to_date(:_b) and TKTL.TERM_DO IS NOT NULL)
            or TKTL.TERM_DO IS NULL)
            '
            ,VAR.A_T,date());
_wazna:=TKTLW.f_first();
TKTLW.f_set(,,'TKTLW.KTM=:_b and TKTLW.TKTL=:_a',_tab.NRK,VAR.A_T);
_prod:=TKTLW.f_first();
TKTLW.f_clear();
TKTLW.cntx_pop();
{?  _wazna & ~_prod & _tab.DFLT_KTL<>'T' & TMAT.LIMIT='T'
|| _tab.efld_opt(_tab.win_edit('?'),'enable=1',VAR,'TRED_KTL');
   _tab.efld_opt(_tab.win_edit('?'),'enable=1',VAR,'RED_WER')
|| _tab.efld_opt(_tab.win_edit('?'),'enable=0',VAR,'TRED_KTL');
   _tab.efld_opt(_tab.win_edit('?'),'enable=0',VAR,'RED_WER')
?};
{? _prod
|| _tab.efld_opt(_tab.win_edit('?'),'enable=0',,'DFLT_KTL')
|| _tab.efld_opt(_tab.win_edit('?'),'enable=1',,'DFLT_KTL')
?};
_tab.efld_opt(_tab.win_edit('?'),{? VAR.KOR || 'mark=1' || 'mark=0' ?},,'CAUSE');

{? _tab=TMAT
|| _win:={? TMAT.NRK().TYP().PAR='T' || 'RED_T' || 'RED_N' ?}
|| _win:={? TCHMAT.NRK().TYP().PAR='T' || 'RED_TN' || 'RED_NN' ?}
?};
{? _tab.PT<>null & _tab.PT().J().KOD=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.JM().KOD",'')
   & exec('czy_xjmp','tech_mater',_tab.PT().J().KOD)
|| {? _tab.FORMN<>''
   || _tab.efld_opt(_win,'editable=grayed',,'XJMP')
   || _tab.efld_opt(_win,'editable=1',,'XJMP')
   ?}
|| _tab.efld_opt(_win,'editable=grayed',,'XJMP')
::      TMAT.XJMP:=0
?};
{? _tab.PT<>null & _tab.DJM<>null() &  _tab.DJM().KOD=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.JM().KOD",'')
   & exec('czy_xjmp','tech_mater',_tab.DJM().KOD)
|| {? _tab.DFORMN<>''
   || _tab.efld_opt(_win,'editable=grayed',,'DXJMP')
   || _tab.efld_opt(_win,'editable=1',,'DXJMP')
   ?}
|| _tab.efld_opt(_win,'editable=grayed',,'DXJMP');
   _tab.DXJMP:=0
?};
~~


\bd_tmatg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Przed wyświetleniem pola TMAT.TGRP
::  OLD: \bd_tmatg/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\bd_tchmatg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Przed wyświetleniem pola TCHMAT.TGRP
::  OLD: \bd_tchmatg/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\be_tmatg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Przed redakcją pola TMAT.TGRP
::   WY: 0 / 1
::  OLD: \be_tmatg/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? TMAT.GRKTM='G'
|| TMAT.PT:=null();
   TKTL.STAT_S='N' | VAR.KOR | VAR.GRP_MOD='P'
|| TMAT.TGRP:=null();
   TMAT.TGDFLT:=null();
   0
?}


\be_tchmatg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Przed redakcją pola TCHMAT.TGRP
::   WY: 0 / 1
::  OLD: \be_tchmatg/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? TCHMAT.GRKTM='G'
|| TCHMAT.PT:=null();
   TKTL.STAT_S='N' | VAR.KOR
|| TCHMAT.TGRP:=null();
   TCHMAT.TGDFLT:=null();
   0
?}


\ae_tmatg
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Po redakcji pola TMAT.TGRP
::  OLD: \ae_tmatg/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? chk_fld(1)
|| {? TMAT.TGRP<>TMAT.TGDFLT().GR || TMAT.TGDFLT:=null() ?}
?};
{? VAR.GRP_MOD='P'
|| exec('efld_opt','tech_mater',TMAT)
?};
1


\ae_tchmatg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Po redakcji pola TCHMAT.TGRP
::  OLD: \ae_tchmatg/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? chk_fld(1)
|| {? TCHMAT.TGRP<>TCHMAT.TGDFLT().GR || TCHMAT.TGDFLT:=null() ?}
?};
1


\bd_tmagp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Przed wyświetleniem pola TMAT.TGDFLT
::  OLD: \bd_tmagp/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\tch_bdgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Przed wyświetleniem pola TCHMAT.TGDFLT
::  OLD: \tch_bdgp/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\aegdeflt
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Po redakcji T(CH)MAT.TGDFLT
::   WE: _a - MUSI BYĆ albo TMAT albo TCHMAT
::   WY: 0 / 1
::  OLD: \aegdeflt/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
{? VAR.GRP_MOD='T' | chk_fld(1)
:: czy zamiennik nie jest tym samym surowcem
|| {? _tab=TCHMAT
   || {? TCHMAT.GRKTM='G' || _tchpt:=TCHMAT.TGDFLT().PT || _tchpt:=TCHMAT.PT ?};
      {? TMAT.GRKTM='G' || _tmpt:=TMAT.TGDFLT().PT || _tmpt:=TMAT.PT ?};
      {? _tchpt=_tmpt
      || {? VAR.GRUPA<>'T' & ~FUN.ask(
               'Indeks zamiennika jest taki sam jak indeks surowca.\n'
               'Czy kontynuujesz wprowadzanie danych?'@
            )
         || return(0)
         ?}
      ?}
   ?};

   _mat:={? _tab.GRKTM='G' || _tab.TGDFLT().PT || _tab.PT ?};

:: czy nie zapętla produktu (czy produkt nie staje się surowcem)
:: Sprawdzenie wyłączone, obecnie można utworzyć kartę, której surowcem jest jej produkt
   _tab.cntx_psh();
::   _res:={? (_tab.TGDFLT().PT<>VAR.A_KTL().KTM)|((_tab.TGDFLT().PT=null())&(VAR.A_KTL().KTM=null()))
::         || {? params_get().env_mater.fields.MAT<>_tab.TGDFLT().PT || _change:=1 || _change:=0 ?};
::            exec('tchm_rec','tech_mater',_tab);
::            1
::         ||
::            FUN.emsg('KOD wprowadzonego surowca\n'
::               'jest taki sam jak KOD produktu karty technologicznej\n\n'
::               'Takie przypisanie nie jest możliwe do wykonania.\n'@
::            );
::            _change:=0;
::            0
::         ?};
   _res:=1;
   {? params_get().env_mater.fields.MAT<>_tab.TGDFLT().PT || _change:=1 || _change:=0 ?};
   exec('tchm_rec','tech_mater',_tab);
   _tab.cntx_pop();

:: Zeruje cechę jeśli materiał nie ma jej przypisanej
   _m_atr:=_tab.TGDFLT().PT().M_ATR;
   {? _m_atr=null()
   || _tab.DK_C:=null()
   ||
::    Zeruje ceche jeśli M_ATR materiału różny od M_ATR wybranej cechy
      {? _m_atr<>_tab.DK_C().M_ATR
      || _tab.DK_C:=null()
      ?}
   ?};

   {? _change
   || VAR.TRED_KTL:='';
      VAR.RED_WER:='';
      _tab.RKTL:='';
      _tab.KTL:=null();

      _tab.cntx_psh();
      M.cntx_psh();
      {? _tab=TMAT
      || _tab.index('NNL');
         _tab.prefix(TMAT.NRK,TMAT.NROP)
      || _tab.index('SL');
         _tab.prefix(TCHMAT.SRC)
      ?};
      _is_it:=0;
      {? _tab.first()
      || {!
         |? {? _tab.PT=_mat | _tab.TGDFLT().PT=_mat
            || {? _tab=TMAT & TMAT.win_edit('?')='REDS'
               || FUN.emsg(
                     'Ten materiał występuje już na liście składowych.\n\n'
                     'Takie przypisanie nie jest możliwe do wykonania.'@
                  );
                  _tab.cntx_pop();
                  M.cntx_pop();
                  return(0)
               || {? _tab=TMAT
                  || _msg:=
                        {? _tab.GRKTM='G'
                        || 'Ten materiał występuje już na liście surowców'
                           ' jako domyślny element grupy technologicznej.'@
                        || 'Ten materiał występuje już na liście surowców.'@
                        ?}+
                        {? TMAT.NROP<>null()
                        || '\n'+'(operacja %1)'@[exec('get_oper_nr','tech_oper',TMAT.NROP().UNROP)]
                        || ''
                        ?};
                     {? VAR.GRUPA='T'
                     || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
                     || FUN.info(_msg)
                     ?};
                     _tab.cntx_pop();
                     M.cntx_pop();
                     return(0)
                  || {? ~FUN.ask(
                           {? _tab.GRKTM='G'
                           || 'Ten materiał występuje już na liście zamienników surowca'
                              ' jako domyślny element grupy technologicznej.\n\n'
                              'Czy chcesz wpisać taką pozycję?'@
                           || 'Ten materiał występuje już na liście zamienników surowca.\n\n'
                              'Czy chcesz wpisać taką pozycję?'@
                           ?}
                        )
                     || _tab.cntx_pop();
                        M.cntx_pop();
                        return(0)
                     || _mat:=null()
                     ?}
                  ?}
               ?}
            ?};
            _tab.next()
         !}
      ?};
      _tab.cntx_pop();
      M.cntx_pop()
   ?};

   {? _change & _tab.NRK().TYP().DJ<>'P'
   || {? _tab.DJM<>null()
      || MJM.cntx_psh();
         MJM.index('JM');
         MJM.prefix({? _tab.GRKTM='G' || _tab.TGDFLT().PT || _tab.PT ?},_tab.DJM);
         {? MJM.first()
         || _tab.DJM:=MJM.JM;
            _tab.PRZ:=MJM.PRZ
         || _tab.DJM:=null();
            _tab.PRZ:=0
         ?};
         MJM.cntx_pop()
      || MJM.cntx_psh();
         MJM.index('JM');
         MJM.prefix({? _tab.GRKTM='G' || _tab.TGDFLT().PT || _tab.PT ?});
         {? MJM.size()=1
         || {? MJM.first()
            || _tab.DJM:=MJM.JM;
               _tab.PRZ:=MJM.PRZ
            ?}
         || _tab.DJM:=null();
            _tab.PRZ:=0
         ?};
         MJM.cntx_pop()
      ?}
   ?};
   {? _res & (_tab.TGDFLT().PT().R='S' | _tab.TGDFLT().PT().R='H') || _tab.DFLT_KTL:='N' ?};

   {? _res
   || _m_atr:=_tab.TGDFLT().PT().M_ATR;
      ATR.MJS:={? _tab=TMAT || 'TMAT' || 'TCHMAT' ?};
      {? #_m_atr<>#ATR.M_ATR
      || {! _i..10 |! ($('ATR.WAR'+form(_i,-2,0,'99')))():='' !};
         _tab.DK_C:=null()
      ?};
      ATR.M_ATR:=_m_atr;
      ATR.FLAG_ED:=ATR.CZY_ATR & ATR.M_ATR().EDIT;
      ATR.FLAG:={? ATR.FLAG_ED & _m_atr<>null() || 2 || 0 ?};
      {? ATR.FLAG_ED || {? _m_atr<>null() || ATR.FLAG_ED:=2 ?} ?};
      {? VAR.GRP_MOD<>'T'
      || win_disp()
      ?}
   ?};
   _res
|| 1
?}


\tma_bdktm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Przed wyświetleniem pola TMAT.PT
::  OLD: \tma_bdktm/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\tch_bdktm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Przed wyświetleniem pola TCHMAT.PT
::  OLD: \tch_bdktm/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\tma_bektm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Przed redakcją pola TMAT.PT
::   WY: 0 / 1
::  OLD: \tma_bektm/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? TMAT.GRKTM='K'
|| exec('slo_m_ok','material','T',1);
   exec('wpm_opis','material',,' — '+exec('zakr_naz','material',ZAKR.MATU));
   TMAT.TGRP:=null();
   TMAT.TGDFLT:=null();
   {? TKTL.STAT_S='N' | VAR.KOR
   || 1
   || 0
   ?}
|| fld(null());
   0
?}


\aektm_tma
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Po redakcji pola TMAT.PT
::      [_a] - INTEGER - 0/[1] - czy kontrolować rodzaj materiału
::   WY: 1 / 0
::  OLD: \aektm_tma/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_ctrl_rodz:=1;
{? var_pres('_a')=type_of(0)
|| _ctrl_rodz:=_a
?};

{? menu_txt()='Popraw'
|| {? TMAT.GRKTM='G' || _tmpt:=TMAT.TGDFLT().PT || _tmpt:=TMAT.PT ?};
   TCHMAT.index('SL');
   TCHMAT.prefix(TMAT.ref());
   _repeated:=0;
   {? TCHMAT.first()
   || {!
      |? {? TCHMAT.GRKTM='G' || _tchpt:=TCHMAT.TGDFLT().PT || _tchpt:=TCHMAT.PT ?};
         {? _tchpt=_tmpt
         || _repeated:=1
         ?};
         _repeated=0 & TCHMAT.next()
      !}
   ?};

   {? _repeated
   || {? ~FUN.ask('Indeks surowca jest taki sam jak indeks zamiennika.\nCzy kontynuujesz wprowadzanie danych?'@)
      || return(0)
      ?}
   ?}
?};
ATR.MJS:='TMAT';

{? exec('aektm','tech_mater',TMAT,_ctrl_rodz)
||
:: Zeruje ceche jeśli materiał nie ma jej przypisanej
   _m_atr:=TMAT.PT().M_ATR;
   {? #_m_atr<>#ATR.M_ATR
   || {! _i..10 |! ($('ATR.WAR'+form(_i,-2,0,'99')))():='' !};
      TMAT.DK_C:=null()
   ?};
   ATR.M_ATR:=_m_atr;
   ATR.FLAG_ED:=ATR.CZY_ATR & ATR.M_ATR().EDIT;
   ATR.FLAG:={? ATR.FLAG_ED & _m_atr<>null() || 2 || 0 ?};
   {? ATR.FLAG_ED || {? _m_atr<>null() || ATR.FLAG_ED:=2 ?} ?};
   ATR.FLAG_TEX:=ATR.FLAG_ED=2;
   {? VAR.GRP_MOD<>'T'
   || win_disp()
   ?};

   VAR.A_T:=TMAT.PT;
   VAR1.KTM:=TMAT.PT().KTM;
   {? TMAT.PT().R='S' | TMAT.PT().R='H' || TMAT.DFLT_KTL:='N' ?};
   1
|| 0
?}


\aektm_tch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Po redakcji pola TCHMAT.PT
::   WY: 1 / 0
::  OLD: \aektm_tch/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

{? TCHMAT.GRKTM='G' || _tchpt:=TCHMAT.TGDFLT().PT || _tchpt:=TCHMAT.PT ?};
{? TMAT.GRKTM='G' || _tmpt:=TMAT.TGDFLT().PT || _tmpt:=TMAT.PT ?};
{? _tchpt=_tmpt
|| {? ~FUN.ask('Indeks zamiennika jest taki sam jak indeks surowca.\nCzy kontynuujesz wprowadzanie danych?'@)
   || return(0)
   ?}
?};
ATR.MJS:='TCHMAT';

{? exec('aektm','tech_mater',TCHMAT)
||
:: Zeruje cechę jeśli materiał nie ma jej przypisanej
   _m_atr:=TCHMAT.PT().M_ATR;
   {? #_m_atr<>#ATR.M_ATR
   || {! _i..10 |! ($('ATR.WAR'+form(_i,-2,0,'99')))():='' !};
      TCHMAT.DK_C:=null()
   ?};
   ATR.M_ATR:=_m_atr;
   ATR.FLAG_ED:=ATR.CZY_ATR & ATR.M_ATR().EDIT;
   ATR.FLAG:={? ATR.FLAG_ED & _m_atr<>null() || 2 || 0 ?};
   {? ATR.FLAG_ED || {? _m_atr<>null() || ATR.FLAG_ED:=2 ?} ?};
   win_disp();

   VAR.A_T:=TCHMAT.PT;
   VAR1.KTM:=TCHMAT.PT().KTM;
   {? TCHMAT.PT().R='S' | TCHMAT.PT().R='H' || TCHMAT.DFLT_KTL:='N' ?};
   1
|| 0
?}


\aektm
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Po redakcji T(CH)MAT.PT
::   WE: _a - Alias tabeli TMAT albo TCHMAT
::      [_b] - INTEGER - 0/[1] - czy kontrolować rodzaj materiału
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_ctrl_rodz:=1;
{? var_pres('_b')=type_of(0)
|| _ctrl_rodz:=_b
?};

{? VAR.GRP_MOD='T' | chk_fld(1)
|| _wynik:=exec('sprktm','tech_mater',_a,_a.PT,VAR.GRP_MOD<>'T',_ctrl_rodz);
   M.hdr_sel();
   _wynik
|| 1
?}


\warn_be
::----------------------------------------------------------------------------------------------------------------------
::  MOD: TS [8.60] Modyfikacje MacroBASE
:: OPIS: Przed redakcją pola WARN
::   WE: _a - alias tabeli - TMAT, TCHMAT
::   WY: 0 / 1
::  OLD: \warn_be/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

roundmet(2);
_ok:=(TKTL.STAT_S='N' | VAR.KOR);
VAR.REAL3:=_tab.WARN;
{? _ok
|| {? VAR.DJ='P'
   || {? _tab.FORMN=''
      || 1
      || fld(tpar.calc(_tab.FORMN));
         _tab.WARN:=_tab.WARN $ exec('round_abe','tech_mater',_tab,1);
         0
      ?}
   || _tab.WARN:=_tab.DWARN*_tab.PRZ;
      _tab.WARN:=_tab.WARN $ exec('round_abe','tech_mater',_tab,1);
      0
   ?}
|| 0
?}


\warn_po
::----------------------------------------------------------------------------------------------------------------------
::  MOD: MKO [8.60]
:: OPIS: Po redakcji pola TCHMAT.WARN/TMAT.WARN
::   WE: _a - Alias tabeli
::   WY: Zaokrąglona wartość pola
::  OLD: \warn_po/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

roundmet(2);
_wynik:=1;
_dokl:={? _tab.GRKTM='K'
       || exec('jaka_dok_m','jm',_tab.PT)
       || exec('jaka_dok_m','jm',_tab.TGDFLT().PT)
       ?};
_cal:=int(_tab.WARN);
{? _tab.WARN<0
|| FUN.info('Norma nie może być ujemna.'@); _tab.WARN:=0; _wynik:=0
|| {? _dokl=0 & _cal<>_tab.WARN
   || FUN.info('Jednostka miary nie jest podzielna. Wprowadź liczbę całkowitą.'@); _wynik:=0
   || _tab.WARN:=_tab.WARN $ _dokl;
::    Uzupełnienie %XJM i normy brutto (jeśli nie wypełniona)
      {? _tab.WARN<>VAR.REAL3 & _tab.PT<>null
         & _tab.PT().J().KOD=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.JM().KOD",'')
         & exec('czy_xjmp','tech_mater',_tab.PT().J().KOD)
      || _tab.XJMP:=((_tab.WARN/_tab.NRK().XJM)*100)
      ?};

      {? _tab.WARB=0 || _tab.WARB:=_tab.WARN/{? _tab.UNB || _tab.UNB || 1 ?} ?};
::    Uzupełnienie danych na jednostce dodatkowej
      {? _tab.WARN<>VAR.REAL3
      || exec('normy_aktu','tech_mater',1,1,_tab,{? _tab.DJM<>null() || 0 || 2 ?} )
      ?}
   ?}
?};
_wynik


\warb_be
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed redakcją pola WARB
::   WE: _a - Alias tabeli - TMAT, TCHMAT
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

roundmet(2);
_ok:=(TKTL.STAT_S='N' | VAR.KOR);
VAR.REAL4:=_tab.WARB;
{? _ok
|| {? VAR.DJ='P'
   || {? _tab.FORMB=''
      || {? _tab.WARB=0
         || _tab.WARB:=_tab.WARN/{? _tab.UNB || _tab.UNB || 1 ?}
         ?};
         _tab.WARB:=_tab.WARB $ exec('round_abe','tech_mater',_tab,1);
         1
      || fld(tpar.calc(_tab.FORMB));
         _tab.WARB:=_tab.WARB $ exec('round_abe','tech_mater',_tab,1);
         0
      ?}
   || _tab.WARB:=_tab.DWARB*_tab.PRZ;
      _tab.WARB:=_tab.WARB $ exec('round_abe','tech_mater',_tab,1);
      0
   ?}
|| 0
?}


\warb_po
::----------------------------------------------------------------------------------------------------------------------
::  MOD: MKO [8.60]
:: OPIS: Po redakcji pola TCHMAT.WARB/TMAT.WARB
::   WE: _a -  Alias tabeli
::   WY: Zaokrąglona wartość pola
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

roundmet(2);
_wynik:=1;
_dokl:={? _tab.GRKTM='K'
       || exec('jaka_dok_m','jm',_tab.PT)
       || exec('jaka_dok_m','jm',_tab.TGDFLT().PT)
       ?};
_cal:=int(_tab.WARB);
{? _tab.WARB<0
|| FUN.info('Norma nie może być ujemna.'@); _tab.WARB:=0; _wynik:=0
|| {? _dokl=0 & _cal<>_tab.WARB
   || FUN.info('Jednostka miary nie jest podzielna. Wprowadź liczbę całkowitą.'@); _wynik:=0
   || _tab.WARB:=_tab.WARB $ _dokl;
::    Uzupełnienie danych na jednostce dodatkowej
      {? _tab.DJM<>null() & _tab.WARB<>VAR.REAL4
      ||  exec('normy_aktu','tech_mater',1,1,_tab,2)
      ?}
   ?}
?};
_wynik


\bd_podst
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Przed wyświetleniem pola TMAT.PODST
::   WY: 0 / 1
::  OLD: \bd_podst/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? TMAT.SO='O' || 0 || 1 ?}


\be_podst
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.10]
:: OPIS: przed redagowaniem znacznika TMAT.PODST
::  OLD: \be_podst/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? TMAT.SO='O' || 0 || 1 ?}


\TM_xMAT
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RS [8.50]
:: OPIS: Przed redakcją podstawowej formuły do jednostki miary
::   WE: _a - Alias tabeli - TMAT, TCHMAT
::  OLD: \TM_xMAT/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
VAR.REAL3:=_tab.WARN;
VAR.REAL4:=_tab.WARB;
{? VAR.DJ='P'
|| TKTL.STAT_S='N' | VAR.KOR
|| {? _tab.FORMN=''
   || {? _tab.DFORMN<>''
      || _tab.FORMN:='('+_tab.DFORMN+')*'+form(_tab.PRZ,,,'9.')
      ?}
   ?};
   {? _tab.FORMB=''
   || {? _tab.DFORMB<>''
      || _tab.FORMB:='('+_tab.DFORMB+')*'+form(_tab.PRZ,,,'9.')
      ?}
   ?};
   0
?}


\formn_ae
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: po redakcji formuły na wartość netto
::   WE: _a - Alias tabeli - TMAT, TCHMAT
::       [_b] - wartość pola (do walidacji podczas grupowego poprawnia), jak nie podana to fld()
::   WY: 0 / 1
::  OLD: \formn_ae/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_fld:={? var_pres('_a')=type_of('') || _b || fld() ?};
roundmet(2);
_ok:=(TKTL.STAT_S='N' | VAR.KOR);
{? _fld=''
|| 1
|| {? tpar.chk(_fld)
   || {? _ok
      || _tab.WARN:=tpar.RESULT;
         _tab.WARN:=_tab.WARN $ exec('round_abe','tech_mater',_tab,1);
         {? _tab.WARN<>VAR.REAL3 & _tab.PT<>null
            & _tab.PT().J().KOD=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.JM().KOD",'')
            & exec('czy_xjmp','tech_mater',_tab.PT().J().KOD)
         || _tab.XJMP:=((_tab.WARN/_tab.NRK().XJM)*100)
         ?};
         _ok:=exec('ae_netto','tech_mater',_tab);
::       Uzupełnienie danych na jednostce dodatkowej
         {? _ok & _tab.WARN<>VAR.REAL3
         ||  exec('normy_aktu','tech_mater',1,VAR.GRUPA<>'T',_tab,{? _tab.DJM<>null() || 0 || 2 ?} )
         ?}
      ?}
   || _ok:=0
   ?}
?};
exec('efld_opt','tech_mater',_tab);
_ok


\round_abe
::----------------------------------------------------------------------------------------------------------------------
::  MOD:  MKO [8.60]
:: OPIS: Ustala zaokrąglenie
::   WE: _a - Alias tabeli (TMAT, TCHMAT)
::       _b - wg jednostki miary normalnej (1) lub przeliczeniowej - dodatkowej (0)
::   WY: Dokładność zaokrąglenia
::  OLD: \round_abe/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_wyn:=5;
{? _tab.GRKTM='K'
|| {? _b=1
   || _wyn:=exec('jaka_dok_m','jm',_tab.PT)
   || _wyn:=exec('jaka_dok_mjm','jm',_tab.PT,_tab.DJM,_tab.PT().J)
   ?}
|| {? _b=1
   || _wyn:=exec('jaka_dok_m','jm',_tab.TGDFLT().PT)
   || _wyn:=exec('jaka_dok_mjm','jm',_tab.TGDFLT().PT,_tab.DJM,_tab.TGDFLT().PT().J)
   ?}
?};
{? _wyn=-1
|| FUN.info('Brak zdefiniowanego przelicznika jednostki dodatkowej.'@);
   _wyn:=5
?};
_wyn


\formb_ae
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: po redakcji formuły na wartość brutto
::   WE: _a - Alias tabeli - TMAT, TCHMAT
::       [_b] - wartość pola (do walidacji podczas grupowego poprawnia), jak nie podana to fld()
::   WY: 0 / 1
::  OLD: \formb_ae/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_fld:={? var_pres('_a')=type_of('') || _b || fld() ?};
roundmet(2);
_ok:=(TKTL.STAT_S='N' | VAR.KOR);
{? _fld=''
|| 1
|| {? tpar.chk(_fld)
   || {? _ok
      || _tab.WARB:=tpar.RESULT;
         _tab.WARB:=_tab.WARB $ exec('round_abe','tech_mater',_tab,1);
         {? _tab.WARB<0
         || _msg:='Norma nie może być ujemna.'@;
            {? VAR.GRUPA='T'
            || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
            || FUN.emsg(_msg)
            ?};
            _ok:=0
         ?};
::       Uzupełnienie danych na jednostce dodatkowej
         {? _ok &_tab.DJM<>null() & _tab.WARB<>VAR.REAL4
         ||  exec('normy_aktu','tech_mater',1,VAR.GRUPA<>'T',_tab,2)
         ?}
      ?}
   || _ok:=0
   ?}
?};
_ok


\ae_brutto
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Po redakcji brutto we wszelkich tabelach
::   WE: _a - alias tabeli (TMAT, TCHMAT)
::       [_b] - czy import przez Excele: [0]/1
::  OLD: \ae_brutto/tech.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_import:={? var_pres('_b')=type_of(0) || _b || 0 ?};

_wyn:=1;
{? _tab.WARB<0
|| FUN.emsg('Norma nie może być ujemna.'@);
   _wyn:=0
|| {? ~_import & _tab.WARN>_tab.WARB
   || _wyn:=~FUN.ask('Norma materiałowa netto jest większa od normy brutto.\nCzy ponownie edytować pole?'@)
   ?}
?};
_wyn


\ae_dbrutto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2010]
:: OPIS: Po redakcji pola 'dodatkowe brutto' we wszelkich tabelach
::   WE: _a - alias tabeli (TMAT, TCHMAT)
::       [_b] - czy import przez Excele: [0]/1
::  OLD: \ae_dbrutto/tech.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_import:={? var_pres('_b')=type_of(0) || _b || 0 ?};

_wyn:=1;
{? _tab.DWARB<0
|| FUN.emsg('Norma nie może być ujemna.'@);
   _wyn:=0
|| {? ~_import & _tab.DWARN>_tab.DWARB
   || _wyn:=~FUN.ask('Dodatkowa norma materiałowa netto jest większa od normy brutto.\nCzy ponownie edytować pole?'@)
   ?}
?};
_wyn


\ae_netto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Po redakcji pola 'netto' we wszelkich tabelach
::   WE: _a - alias tabeli (TMAT, TCHMAT)
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_wyn:=1;
{? _tab.WARN<0
|| _msg:='Norma nie może być ujemna.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
   || FUN.emsg(_msg)
   ?};
   _wyn:=0
::|| {? _tab.WARN>_tab.WARB
::   || _wyn:=~FUN.ask('Norma materiałowa netto jest większa od normy brutto.\nCzy ponownie edytować pole?'@)
::   ?}
?};
_wyn


\ae_dnetto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Po redakcji pola 'dodatkowe netto' we wszelkich tabelach
::   WE: _a - alias tabeli (TMAT, TCHMAT)
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_wyn:=1;
{? _tab.DWARN<0
|| FUN.emsg('Norma nie może być ujemna.'@);
   _wyn:=0
::|| {? _tab.DWARN>_tab.DWARB
::   || _wyn:=~FUN.ask('Dodatkowa norma materiałowa netto jest większa od normy brutto.\nCzy ponownie edytować pole?'@)
::   ?}
?};
_wyn


\bd_limit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Przed wyświetleniem pola TMAT.LIMIT
::   WY: 0 / 1
::  OLD: \bd_limit/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
TMAT.efld_opt(TMAT.win_edit('?'),{? TMAT.LIMIT='T' || 'enable=0' || 'enable=1' ?},,'ROZ');
{? TMAT.SO='O' || 0 || 1 ?}


\be_limit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [10.11]
:: OPIS: Przed redakcją pola TMAT.LIMIT
::  OLD: \be_limit/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? TMAT.SO='O' || 0 || 1 ?}


\ae_limit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [10.11]
:: OPIS: Po redakcji pola TMAT.LIMIT
::  OLD: \ae_limit/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? TMAT.LIMIT='N'
|| TMAT.SO:='S';
   TMAT.DFLT_KTL:='N';
   TMAT.KTL:=null()
|| TMAT.ROZ:='N';
   {? TMAT.MG<>null()
   ||
::    W przypadku surowców limitowanych sprawdzenie czy przypisany magazyn obsługuje realizację zamówień wewnętrznych
      {? TMAT.SO='S'
      || {? ~exec('czyMgUprZam','zamsiw_wspolne',TMAT.MG,-1)
         || TMAT.MG:=null()
         ?}
      ?}
   ?}
?};
exec('efld_opt','tech_mater',TMAT);
{? VAR.GRP_MOD<>'T'
|| win_disp()
?};
1


\surspr
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed redakcją pola TMAT.PFAZ
::   WY: 0 / 1
::  OLD: \surspr/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? TMAT.NROP<>null()
|| 0
|| FILTER.PFAZ:=0;
   PFAZ.f_set('KOD', '',
              'PFAZ.WYD='':_a'' or '':_a''=''''',
               $VAR.A_KTL().JORG);
   1
?}


\ae_pfaz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Po redakcji pola TMAT.PFAZ
::   WY: 1
::  OLD: \ae_pfaz/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_PFAZ:=fld();
VAR.A_WYD:=VAR.A_PFAZ().WYD;
{? VAR.A_WYD<>null() || TMAT.WYD:=VAR.A_WYD ?};
1


\filtr_djm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2010]
:: OPIS: Obsługa na wzorzec pola TMAT.DJM - służy do ustawiania filtra na tabeli JM
::   WE: [_a] - STRING - tabela, dla której uruchamiana 'TMAT'/'TCHMAT'. Jak nie podany to wg cur_tab
::   WY: ''
::  OLD: \filtr_djm/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') & ',TMAT,TCHMAT,'*_a>0
|| BEER.TAB:=_a
|| {? cur_tab(1,1)=TMAT || BEER.TAB:='TMAT' |? cur_tab(1,1)=TCHMAT || BEER.TAB:='TCHMAT' || return('') ?}
?};
{| ($BEER.TAB)()
|!
   {? GRKTM='G'
   || _mat:=TGDFLT().PT
   |? GRKTM='K'
   || _mat:=PT
   || _mat:=null()
   ?}
|};
_mjm:=sql('select JM.REFERENCE as REF from MJM join JM using(MJM.JM,JM.REFERENCE) where MJM.M=:_a',_mat);
{? ~JM.f_set('KOD',,'JM.REFERENCE in (select :_a.REF from :_a)',_mjm)
||
   exec('err_psql','#sql');
   exec('empty_f_set','#table',JM)
?};
::JM.win_dict('WERF');
JM.win_dict(exec('jm_win4tmat','tech_mater'));
''


\TxMAT_DJM3
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: przed redakcja pola T(CH)MAT.DJM
::   WE: _a - alias tabeli
::  OLD: \TxMAT_DJM3/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

params_get().env_mater.fields.DJM:=fld();

_ok:=(TKTL.STAT_S='N' | VAR.KOR);
_ok


\TxMAT_DJM5
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: po redakcji pola T(CH)MAT.DJM
::   WE: _a - alias tabeli
::  OLD: \TxMAT_DJM5/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

JM.f_clear();
{? _tab.DJM<>null()
||
   {? _tab.GRKTM='K'
   || _wyn:=exec('jaka_dok_mjm','jm',_tab.PT,_tab.DJM,_tab.PT().J)
   || _wyn:=exec('jaka_dok_mjm','jm',_tab.TGDFLT().PT,_tab.DJM,_tab.TGDFLT().PT().J)
   ?};
   {? _wyn=-1
   || FUN.info('Brak zdefiniowanego przelicznika jednostki dodatkowej.'@);
      return(0)
   |? _wyn=0
   || fld():=null()
   || {? params_get().env_mater.fields.DJM<>fld()
      || _tab.PRZ:=exec('MJM_COEF','tech_mater',{? _tab.GRKTM='K' || _tab.PT || _tab.TGDFLT().PT ?}, _tab.DJM,1)
      ?}
   ?};
   {? fld()=null()
   || _tab.DFORMN:=_tab.DFORMB:='';
      _tab.DWARN:=_tab.DWARB:=0;
      {? TMAT.NRK().TYP().DJ='D'
      || _tab.WARN:=0;
         _tab.WARB:=0
      ?};
      1
   || 1
   ?}
|| 1
?}


\TxMAT_DWARN3
::----------------------------------------------------------------------------------------------------------------------
::  MOD: MKO [8.60]
:: OPIS: Przed redakcją dodatkowej wart. netto
::   WE: _a - alias tabeli
::   WY: 0 - redakcja zabroniona
::       1 - redakcja dozwolona
::  OLD: \TxMAT_DWARN3/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

roundmet(2);
_ok:=(TKTL.STAT_S='N' | VAR.KOR);
VAR.REAL3:=_tab.DWARN;
{? _ok
|| {? _tab.DJM<>null()
   ||
      {? _tab.DFORMN=''
      ||
         _coef:={? _tab.PRZ=0 || 1 || 1/_tab.PRZ ?};
         _dziel:={? _tab.DJM<>null()
                 || exec('dziel','tech_mater',_tab)
                 || 1
                 ?};
         fld({? _dziel
             || {? VAR.DJ='P'
                || {? ~_tab.DWARN || (_tab.WARN*_coef) || _tab.DWARN ?}
                || _tab.DWARN
                ?}
             || ceil({? VAR.DJ='P'
                     || {? ~_tab.DWARN || (_tab.WARN*_coef) || _tab.DWARN ?}
                     || _tab.DWARN
                     ?})
             ?});
         1
      || {? tpar.chk(_tab.DFORMN)
         || fld(tpar.RESULT $ exec('round_abe','tech_mater',_tab,0));
            0
         || 1
         ?}
      ?}
   || 0
   ?}
?}


\TxMAT_DWARN5
::----------------------------------------------------------------------------------------------------------------------
::  MOD: MKO [8.60]
:: OPIS: Po redakcji dodatkowej wart. netto
::   WE: _a - alias tabeli
::   WY: 0 / 1
::  OLD: \TxMAT_DWARN5/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

roundmet(2);
_wynik:=1;
_bb:={? _tab.DJM<>null()
     || exec('podz','tech_mater',_tab)
     || 'T'
     ?};
_cc:=int(_tab.DWARN);
{? _tab.DWARN<0
||
   FUN.info('Norma nie może być ujemna.'@); _tab.DWARN:=0; _wynik:=0
||
   {? _bb='N' & _cc<>_tab.DWARN
   || FUN.info('Jednostka miary nie jest podzielna. Wprowadź liczbę całkowitą.'@); _wynik:=0
   || _tab.DWARN:=_tab.DWARN $ exec('round_abe','tech_mater',_tab,0);
::    Uzupełnienie %XJM i normy brutto (jeśli nie wypełniona)
      {? _tab.DWARN<>VAR.REAL3 & _tab.PT<>null & _tab.DJM<>null()
         &  _tab.DJM().KOD=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.JM().KOD",'')
         & exec('czy_xjmp','tech_mater',_tab.DJM().KOD)
      || _tab.DXJMP:=(((_tab.DWARN)/_tab.NRK().XJM)*100)
      ?};
      {? _tab.DWARB=0 || _tab.DWARB:=_tab.DWARN/{? _tab.UNB || _tab.UNB || 1 ?} ?};
::    Uzupełnienie danych na jednostce podstawowej
      {? _tab.DJM<>null() & _tab.DWARN<>VAR.REAL3
      || exec('normy_aktu','tech_mater',0,1,_tab,0)
      ?}
   ?}
?};
::{? VAR.DJ='D'
::|| _tab.WARN:=_tab.DWARN*_tab.PRZ;
::   _tab.WARN:=_tab.WARN $ exec('round_abe','tech_mater',_tab,1)
::?};
win_disp();
_wynik


\TxMAT_DWARB3
::----------------------------------------------------------------------------------------------------------------------
::  MOD: MKO [8.60]
:: OPIS: Przed redakcją  dodatkowej wart. brutto
::   WE: _a - alias tabeli
::   WY: 0 - redakcja zabroniona
::       1 - redakcja dozwolona
::  OLD: \TxMAT_DWARB3/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

roundmet(2);
_ok:=(TKTL.STAT_S='N' | VAR.KOR);
VAR.REAL4:=_tab.DWARB;
{? _ok
|| {? _tab.DJM<>null()
   ||
      {? _tab.DFORMB=''
      ||
         _coef:={? _tab.PRZ=0 || 1 || 1/_tab.PRZ ?};
         _dziel:={? _tab.DJM<>null()
                 || exec('dziel','tech_mater',_tab)
                 || 1
                 ?};
         _wyn:=(_tab.WARB*_coef);
         _dwarb:={? _tab.DWARB<>0
                 || _tab.DWARB
                 || {? _tab.UNB<>0 || _tab.DWARN/_tab.UNB || 0 ?}
                 ?};
         fld({? _dziel
             || {? VAR.DJ='P'
                || {? ~_tab.DWARB || (_tab.WARB*_coef) || _tab.DWARB ?}
                || _dwarb
                ?}$ exec('round_abe','tech_mater',_tab,0)
             || ceil({? VAR.DJ='P'
                     || {? ~_tab.DWARB || (_tab.WARB*_coef) || _tab.DWARB ?}
                     || _dwarb
                     ?})
             ?});
         1
      || {? tpar.chk(_tab.DFORMB)
         || fld(tpar.RESULT $ exec('round_abe','tech_mater',_tab,0));
            0
         || 1
         ?}
      ?}
   || 0
   ?}
?}


\TxMAT_DWARB5
::----------------------------------------------------------------------------------------------------------------------
::  MOD: MKO [8.60]
:: OPIS: Po redakcji dodatkowej wart. brutto
::   WE: _a - alias tabeli
::   WY: 0 / 1
::  OLD: \TxMAT_DWARB5/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

roundmet(2);
_wynik:=1;
_bb:={? _tab.DJM<>null()
     || exec('podz','tech_mater',_tab)
     || 'T'
     ?};
_cc:=int(_tab.DWARB);
{? _tab.DWARB<0
||
   FUN.info('Norma nie może być ujemna.'@); _tab.DWARB:=0; _wynik:=0
||
   {? _bb='N' & _cc<>_tab.DWARB
   || FUN.info('Jednostka miary nie jest podzielna. Wprowadź liczbę całkowitą.'@); _wynik:=0
   || _tab.DWARB:=_tab.DWARB $ exec('round_abe','tech_mater',_tab,0)
   ?};
::    Uzupełnienie danych na jednostce podstawowej
      {? _tab.DJM<>null() & _tab.DWARB<>VAR.REAL4
      || exec('normy_aktu','tech_mater',0,1,_tab,2)
      ?}
::   {? VAR.DJ='D'
::   || _tab.WARB:=_tab.DWARB*_tab.PRZ;
::      _tab.WARB:=_tab.WARB $ exec('round_abe','tech_mater',_tab,1)
::   ?}
?};
win_disp();
_wynik


\TxMAT_DFORMN3
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed redakcją formuły na dodatkową wartość netto
::   WE: _a - alias tabeli TMAT, TCHMAT
::   WY:  0 - redakcja zabroniona
::        1 - redakcja dozwolona
::  OLD: \TxMAT_DFORMN3/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

roundmet(2);
_ok:=(TKTL.STAT_S='N' | VAR.KOR);
VAR.REAL3:=_tab.DWARN;
{? _ok
|| {? (_tab.DJM<>null())
   || {? _tab.DFORMN=''
      ||
         _coef:={? _tab.GRKTM='G' || 1/exec('MJM_COEF','tech_mater',_tab.TGDFLT().PT,_tab.DJM,1)
                |? _tab.GRKTM='K' || 1/exec('MJM_COEF','tech_mater',_tab.PT,_tab.DJM,1)
                || 0
                ?};
:: muszę określić czy zmiana jednostki dodatkowej w stosunku do PT
         _dokl:={? _tab.GRKTM='G' || exec('MJM_COEF','tech_mater',_tab.TGDFLT().PT,_tab.DJM,2)
                |? _tab.GRKTM='K' || exec('MJM_COEF','tech_mater',_tab.PT,_tab.DJM,2)
                || 0
                ?};
         _coef:=_coef$_dokl;
         {? _tab.FORMN<>'' & _tab.DWARN=0
         || fld( '('+_tab.FORMN+')*'+form(_coef,,,'9.'))
         ?}
      ?};
      1
   || 0
   ?}
?}


\TxMAT_DFORMN5
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: po redakcji formuły na dodatkową wartość netto
::   WE: _a - alias tabeli TMAT, TCHMAT
::   WY: (0/1)
::  OLD: \TxMAT_DFORMN5/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

roundmet(2);
_res:=1;
{? fld()<>''
|| {? tpar.chk(fld())
   || _tab.DWARN:=tpar.RESULT;
      _tab.DWARN:=_tab.DWARN $ exec('round_abe','tech_mater',_tab,0);
       {? _tab.DWARN<>VAR.REAL3 & _tab.PT<>null & _tab.DJM<>null()
          & _tab.DJM().KOD=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.JM().KOD",'')
          & exec('czy_xjmp','tech_mater',_tab.DJM().KOD)
       || _tab.DXJMP:=(((_tab.DWARN)/_tab.NRK().XJM)*100)
       ?};
::      {? VAR.DJ='D'
::      || {? _tab.DFORMN<>''
::         || _tab.FORMN:='('+_tab.DFORMN+')*'+form(_tab.PRZ,,,'9.')
::         ?};
::         _tab.WARN:=_tab.DWARN*_tab.PRZ;
::         _tab.WARN:=_tab.WARN $ exec('round_abe','tech_mater',_tab,1)
::      ?};
::    Uzupełnienie danych na jednostce podstawowej
      {? _tab.DJM<>null() & _tab.DWARN<>VAR.REAL3
      || exec('normy_aktu','tech_mater',0,1,_tab,0);
         {? VAR.DJ='D'
         || {? _tab.DFORMN<>''
            || _tab.FORMN:='('+_tab.DFORMN+')*'+form(_tab.PRZ,,,'9.')
            ?}
         ?}
      ?};
      win_disp()
   || _res:=0
   ?}
|| exec('efld_opt','tech_mater',_tab)
?};
_res


\TxMAT_DFORMB3
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed redakcją formuły na dodatkową wartość brutto
::   WE: _a - alias tabeli TMAT, TCHMAT
::   WY: 0 - redakcja zabroniona
::       1 - redakcja dozwolona
::  OLD: \TxMAT_DFORMB3/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

roundmet(2);
_ok:=(TKTL.STAT_S='N' | VAR.KOR);
VAR.REAL4:=_tab.DWARB;
{? _ok
|| {? (_tab.DJM<>null())
   || {? _tab.DFORMB=''
      ||
         _coef:={? _tab.GRKTM='G' || 1/exec('MJM_COEF','tech_mater',_tab.TGDFLT().PT,_tab.DJM,1)
                |? _tab.GRKTM='K' || 1/exec('MJM_COEF','tech_mater',_tab.PT,_tab.DJM,1)
                || 0 ?};
         _dokl:={? _tab.GRKTM='G' || exec('MJM_COEF','tech_mater',_tab.TGDFLT().PT,_tab.DJM,2)
                |? _tab.GRKTM='K' || exec('MJM_COEF','tech_mater',_tab.PT,_tab.DJM,2)
                || 0
                ?};
         _coef:=_coef$_dokl;
         {? _tab.FORMB<>'' & _tab.DWARB=0
         || fld( '('+_tab.FORMB+')*'+form(_coef,,,'9.'))
         ?}
      ?};
      1
   || 0
   ?}
?}


\TxMAT_DFORMB5
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: po redakcji formuły na dodatkową wartość brutto
::   WE: _a - alias tabeli TMAT, TCHMAT
::   WY: 0 - redakcja ponowiona
::       1 - redakcja zakończona
::  OLD: \TxMAT_DFORMB5/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

roundmet(2);
_res:=1;
{? fld()<>''
|| {? tpar.chk(fld())
   || _tab.DWARB:=tpar.RESULT;
      _tab.DWARB:=_tab.DWARB $ exec('round_abe','tech_mater',_tab,0);
::      {? VAR.DJ='D'
::      || {? _tab.DFORMB<>''
::         || _tab.FORMB:='('+_tab.DFORMB+')*'+form(_tab.PRZ,,,'9.')
::         ?};
::         _tab.WARB:=_tab.DWARB*_tab.PRZ;
::         _tab.WARB:=_tab.WARB $ exec('round_abe','tech_mater',_tab,1)
::      ?}
::    Uzupełnienie danych na jednostce podstawowej
      {? _tab.DJM<>null() & _tab.DWARB<>VAR.REAL4
      || exec('normy_aktu','tech_mater',0,1,_tab,2);
         {? VAR.DJ='D'
         || {? _tab.DFORMB<>''
            || _tab.FORMB:='('+_tab.DFORMB+')*'+form(_tab.PRZ,,,'9.')
            ?}
         ?}
      ?}
   || _res:=0
   ?}
?};
{? _res>0
|| {? _tab.DWARB<0
   || FUN.emsg('Norma nie może być ujemna.'@);
      _res:=0
   ?}
?};
win_disp();
_res


\MJM_COEF
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [1210]
:: OPIS: zwraca przelicznik dla jednostki dodatkowej
::   WE: _a: wskazanie na materiał
::       _b: wskazanie na jednostkę
::       _c: 1 przelicznik, 2 dokładność, 0 jednoska miary
::   WY: {? _c || przelicznik | dokladność | jm ?}
::  OLD: \MJM_COEF/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_prz:=0;
_dokl:=0;
_jm:=null;
MJM.cntx_psh();
MJM.index('JM');
MJM.prefix(_a,_b);
{? MJM.first()
|| _prz:=MJM.PRZ;
   _dokl:=MJM.DOKL;
   _jm:=MJM.JM
?};
MJM.cntx_pop();
{? _c=1 || _prz
|? _c=2 || _dokl
|| _jm ?}


\dziel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Sprawdza warunek podzielności jednostki
::   WE: _a - alias tabeli (TMAT, TCHMAT)
::   WY: 0 - jednostka nie jest podzielna
::       1 - jednostka jest podzielna
::  OLD: \dziel/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

{? _tab.GRKTM='K'
|| exec('jaka_dok_m','jm',_tab.PT)<>0
|| exec('jaka_dok_m','jm',_tab.TGDFLT().PT)<>0
?}


\podz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Określa podzielność jednostki
::   WE: _a - alias tabeli (TMAT, TCHMAT)
::   WY: 'N'- jednostka nie jest podzielna
::       'T'- jednostka jest podzielna
::  OLD: \podz/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

{? _tab.GRKTM='K'
|| {? exec('jaka_dok_m','jm',_tab.PT)=0 || 'N' || 'T' ?}
|| {? exec('jaka_dok_m','jm',_tab.TGDFLT().PT)=0 || 'N' || 'T' ?}
?}


\get_tmat_pow
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Zwraca wartość pola TMAT.POW
::   WY: TMAT.POW
::  OLD: \get_tmat_pow/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
TMAT.POW


\bd_so
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Przed wyświetleniem pola TMAT.SO
::   WY: 0 / 1
::  OLD: \bd_so/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
1


\ae_so
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.10]
:: OPIS: po redagowaniu znacznika TMAT.SO
::  OLD: \ae_so/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
{? TMAT.SO='O'
|| {? -menu_txt()='popraw'
   || TCHMAT.cntx_psh();
      TCHMAT.index('SL');
      TCHMAT.prefix(TMAT.ref());
      {? TCHMAT.first() & VAR.GRP_MOD<>'P'
      || _msg:='Do pozycji przypisane są zamienniki — nie można zmienić na odpad/koprodukt.'@;
         {? VAR.GRUPA='T'
         || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg);
            _result:=0
         || FUN.info(_msg)
         ?};
         TMAT.SO:='S'
      || TMAT.PARTIA:='N';
         TMAT.LIMIT:='T'
      ?};
      TCHMAT.cntx_pop()
   ?}
|| {? TMAT.MG<>null()
   ||
::    W przypadku surowców limitowanych sprawdzenie czy przypisany magazyn obsługuje realizację zamówień wewnętrznych
      {? TMAT.LIMIT='T'
      || {? ~exec('czyMgUprZam','zamsiw_wspolne',TMAT.MG,-1)
         || TMAT.MG:=null()
         ?}
      ?}
   ?}
?};
{? VAR.GRP_MOD<>'T'
|| win_disp()
?};
_result


\bd_pow
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Przed wyświetleniem pola TMAT.POW
::   WY: 0 / 1
::  OLD: \bd_pow/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? TMAT.SO='O' || 0 || 1 ?}


\bd_pow_c
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Przed wyświetleniem pola TCHMAT.POW
::   WY: 0 / 1
::  OLD: \bd_pow_c/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
1


\be_pow
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.50]
:: OPIS: przed redagowaniem znacznika TMAT.POW
::  OLD: \be_pow/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? TMAT.SO='O' || 0 || 1 ?}


\TxMAT_PRZEL
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RS [8.50]
:: OPIS: Przepisuje przelicznik jednostek z M do TMAT albo TCHMAT
::       KONTEKST:
::       - przed redakcją pola PRZ w tabelach TMAT i TCHMAT (steruje też redagowalnością pola)
::       - po redakcji indeksu materiału
::       - przy tworzeniu nowego surowca za pomocą d-n-d
::   WE: _a - alias tabeli - TMAT albo TCHMAT
::       [_b] - 0 - bez odświeżenia okienka, 1 - z odświeżeniem okienka (domyślnie)
::       [_c] - 0 - bez przeliczenia jak jest już wartość (domyślnie), 1 - z przeliczeniem
::   WY: 0 / 1
::  OLD: \TxMAT_PRZEL/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_okno:={? var_pres('_b')=type_of(0) || _b || 1 ?};
_overwrite:={? var_pres('_c')=type_of(0) || _c || 0 ?};

_edit:=1;

{? _tab.PRZ=0 | _overwrite
|| {? _tab.DJM<>null()
   || MJM.cntx_psh();
      MJM.index('JM');
      MJM.prefix({? _tab.GRKTM='G' || _tab.TGDFLT().PT || _tab.PT ?},_tab.DJM);
      {? MJM.first()
      || _tab.DJM:=MJM.JM;
         _tab.PRZ:=MJM.PRZ
      || _tab.DJM:=null();
         _tab.PRZ:=0
      ?};
      MJM.cntx_pop()
   || MJM.cntx_psh();
      MJM.index('JM');
      MJM.prefix({? _tab.GRKTM='G' || _tab.TGDFLT().PT || _tab.PT ?});
      {? MJM.size=1
      || {? MJM.first()
         || _tab.DJM:=MJM.JM;
            _tab.PRZ:=MJM.PRZ
         ?}
      || _tab.DJM:=null();
         _tab.PRZ:=0;
         _edit:=0
      ?};
      MJM.cntx_pop()
   ?}
?};

{? _okno || win_disp() ?};

_edit


\TxMAT_UZYSK
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RS [8.50]
:: OPIS: przepisuje uzysk norm netto/brutto z M do TMAT/TCHMAT
::       KONTEKST:
::       - przed redakcja pola UNB w tabelach TMAT i TCHMAT
::       - po redakcji indeksu materiału
::       - przy tworzeniu nowego surowca za pomocą d-n-d
::   WE: _a - Alias tabeli - TMAT, TCHMAT
::  OLD: \TxMAT_UZYSK/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

{? _tab.PT<>null()
|| {? _tab.UNB=0
   || _tab.UNB:=_tab.PT().UNB
   ?}
|? _tab.TGDFLT<>null()
|| {? _tab.UNB=0
   || _tab.UNB:=_tab.TGDFLT().PT().UNB
   ?}
|| _tab.UNB:=0
?};
~~


\tmat_opis_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Obsługa na F3 dla pola TMAT.OPIS
::  OLD: \tmat_opis_f3/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=sql('
   select distinct
      TMAT.OPIS
   from TMAT
   where TMAT.OPIS<>\'\' and TMAT.OPIS like \':_a%\'
   order by OPIS
',fld());

{? type_of(_tab)=type_of(~~) || exec('err_sql','#sql'); return() ?};

_wer:=_tab.mk_sel('Opisy'@,,0,'tmatopisy',40,10,20);
_tab.win_sel(_wer);
_tab.win_fld(_wer,,'OPIS',,,100,,,' ');
_tab.win_act(_wer,,'Formuła','Wybierz'@@,,,"sel_exit()",,1);

{? _tab.select()
|| fld():=_tab.OPIS;
   set_cpos(255)
?};
~~


\bd_partia
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Przed wyświetleniem pola TMAT.PARTIA
::   WY: 0 / 1
::  OLD: \bd_partia/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? TMAT.SO='S' || 1 || 0 ?}


\bd_partia_c
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Przed wyświetleniem pola TCHMAT.PARTIA
::   WY: 0 / 1
::  OLD: \bd_partia_c/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
1


\be_partia
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Przed redakcją pola TMAT.PARTIA
::   WY: 1 / 0
::  OLD: \be_partia/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? TMAT.SO='S' || 1 || 0 ?}


\bl_wyd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Wartość początkowa pola TMAT.WYD
::   WY: 0 / 1
::  OLD: \bl_wyd/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? TMAT.PFAZ<>null() || TMAT.PFAZ().WYD || TKTL.JORG ?}


\be_wyd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Przed redakcją pola TMAT.WYD
::   WY: 0 / 1
::  OLD: \be_wyd/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('jakislw','wzorce');
{? VAR.A_WYD<>null() || 0 || 1 ?}


\cre_time_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Wartość początkowa pola *.CRE_TIME (w tabelach TMAT, TCHMAT)
::  OLD: \cre_time_bl/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.KOR || TKTL.tm_stamp() || 0 ?}


\user_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Wartość początkowa pola *.USER (w tabalach TMAT, TCHMAT)
::  OLD: \user_bl/tech1.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.KOR || OPERATOR.USER || null() ?}


\tmag_pw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Przed wyświetleniem/redakcją pola TMAT.MAG
::   WY: 0 / 1
::  OLD: \tmag_pw/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? menu_txt()='Popraw' | menu_txt()='Dołącz'
||
   {? TKTL.STAT_S='N' | VAR.KOR
   || {? (TMAT.KTL<>null() | TMAT.DFLT_KTL='T') & TMAT.LIMIT='T'
      || {? VAR.A_T().R='P' | VAR.A_T().R='W' || 1 || 0 ?}
      ?}
   || 0
   ?}
|| {? (TMAT.KTL<>null() | TMAT.DFLT_KTL='T') & TMAT.LIMIT='T'
   || {? VAR.A_T().R='P' | VAR.A_T().R='W' || 1 || 0 ?}
   ?}
?}


\tchmagpw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Przed wyświetleniem/redakcją pola TCHMAT.MAG
::   WY: 0 / 1
::  OLD: \tchmagpw/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? menu_txt()='Popraw' | menu_txt()='Dołącz'
||
   {? TKTL.STAT_S='N' | VAR.KOR
   || {? (TCHMAT.KTL<>null() | TCHMAT.DFLT_KTL='T') & TMAT.LIMIT='T'
      || {? VAR.A_T().R='P' | VAR.A_T().R='W' || 1 || 0 ?}
      ?}
   || 0
   ?}
|| {? (TCHMAT.KTL<>null() | TCHMAT.DFLT_KTL='T') & TMAT.LIMIT='T'
   || {? VAR.A_T().R='P' | VAR.A_T().R='W' || 1 || 0 ?}
   ?}
?}


\bldef_kt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wartość początkowa pola T(CH)MAT.DFLT_KTL
::   WE: _a - Alias tabeli - TMAT albo TCHMAT
::  OLD: \bldef_kt/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

{? exec('is_k_res','tech_head',exec('FindAndGet','#table',TKTL,_tab.NRK,,"TYP",null()))
|| _dflt:='N'
|| _param:=exec('FindAndGet','#table',TKTL,_tab.NRK,,"TYP().PAR",'N');
   {? _param='T'
   || _dflt:='N'
   || _dflt:=exec('get','#params',500013,2)
   ?}
?};
_dflt


\pwdef_kt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Przed wyświetleniem pola T(CH)MAT.DFLT_KTL
::   WY: 0/1
::  OLD: \pwdef_kt/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? (cur_tab(1,1).NRK().TYP().PAR='T' & exec('is_param','tech_head',cur_tab(1,1).NRK)) | TMAT.LIMIT='N'
|| 0
|| {? VAR.A_T().R='P' | VAR.A_T().R='W' || 1 || 0 ?}
?}


\prdef_kt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Przed redakcją pola T(CH)MAT.DFLT_KTL
::   WY: 0 / 1
::  OLD: \prdef_kt/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
:: Tak obsługujemy wskaźnik domyślnosci karty półfabrykatowej, może w przyszłosci zostanie dorobiony algorytm walidacyjny
:: pozwalający sprawdzić tlanslacje parametrów, teraz jeśli karta ma parametry to nie może mieć znacznika domyślnosci
:: ER/WRT/XP/11.21/1010/0006
{? VAR.A_KTL().TYP().PAR='T' & exec('is_param','tech_head',VAR.A_KTL)
|| TMAT.DFLT_KTL:='N';
   0
|| {? TKTL.STAT_S='N' | VAR.KOR
   ||
      {? VAR.A_T().R='P' | VAR.A_T().R='W' || 1 || 0 ?}
   || 0
   ?}
?}


\podef_kt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Po redakcji pola T(CH)MAT.DFLT_KTL
::   WY: 0 / 1
::  OLD: \podef_kt/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
{? _tab.DFLT_KTL='T'
|| _tab.KTL:=null();
   _tab.RKTL:='';
   VAR.TRED_KTL:='';
   VAR.RED_WER:=''
?};
exec('efld_opt','tech_mater',_tab);
win_disp();
1


\tech_cecha_bl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Blank pola DK_C tabeli: TMAT
::  OLD: \tech_cecha_bl/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\tech_cecha_bd
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Przed wyświetl pola DK_C tabeli: TMAT
::  OLD: \tech_cecha_bd/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\tech_cecha_be
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Przed redakcją pola DK_C tabeli: TMAT
::  OLD: \tech_cecha_be/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
ATR.MJS:=2-!cur_tab(1,1);

_mat:={? ATR.MJS<>'' || exec('acr2acr','mat_atr') || 'M' ?};

VAR_DEL.delete('BEF_ATR');
ATR.FLAG_TEX:=0;
_result:=0;
_atr:=($(ATR.MJS+'.'+_mat+'().M_ATR'))();
{? _atr<>null()
 & {? exec('rozm_atr','mat_atr',_atr)=1 || ($(ATR.MJS+'.'+_mat+'().M_ATR().SL_01().TYP'))()<>'P' || 1 ?}
|| _result:=1;
   exec('dk_atr_dict','mat_atr');

   {? ATR.MJS='TMAT' | ATR.MJS='TCHMAT'
   ||
::    Tworzę bufor maski atrybutów i wypełniam zmienną ATR tym co jest w polu
      _rule:=$(ATR.MJS+'.ATR_MASK');
      _buffer:=exec('atr_mask_buffer','tech_mater');
      _buffer.from_msk(_rule());
      _buffer.set_atr()
   ?};

   _rule:=$(ATR.MJS+'.DK_C');
   {? _rule()<>null()
   ||
      _rule:=$(ATR.MJS+'.DK_C()');
      DK_C.cntx_psh();

::    Podczytanie DK_C
      _rule();

::    Tworzę bufor atrybutów na podstawie DK_C i przypisuje go do zmiennej globalnej celem porównania w formule po redakcji
      BEF_ATR:=exec('buffer','mat_atr');
      BEF_ATR.get_dkc();
      DK_C.cntx_pop();
      ~~
   ||
::    Tworze pusty bufor atrybutów i przypisuje go do zmiennej globalnej celem porównania w formule po redakcji
      BEF_ATR:=exec('buffer','mat_atr')
   ?};
   ~~
?};
{? _result || _result:=ATR.FLAG_ED<>2 ?};
_result


\tech_cecha_ae
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Po redakcji pola DK_C tabeli: TMAT
::  OLD: \tech_cecha_ae/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_aft_atr:=exec('buffer','mat_atr');
_aft_atr.get_dkc();
{? var_pres('BEF_ATR')>100 & ATR.FLAG_TEX>0
||
:: Pokazuje okno redagowania tylko jeżeli cecha przed redakcją różni się od tej która jest po redakcji
   {? _aft_atr.compare(BEF_ATR)<0 & ATR.FLAG_TEX=0
   || _result:=exec('matr_tmat','mat_atr')
   ?};
   ~~
?};

{? _result>0
||
:: Sprawdzam czy atrybut zawiera partie - jeśli tak to ponawiam redagowanie
:: Partia na surowcach technologicznych nie ma sensu, dopiero na limicie może mieć jakiś sens
   {? ($(ATR.MJS+'.DK_C'))()<>null() & _aft_atr.has_part()>0
   || FUN.emsg('Cecha surowca technologicznego nie może zawierać wartości typu: \'Partia\'.'@);
      _result:=0
   ?}
?};

ATR.FLAG_TEX:=0;
{? ($(ATR.MJS+'.DK_C'))()<>null() & ($(ATR.MJS+'.DK_C().M_ATR'))()<>null()
|| {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=($(ATR.MJS+'.DK_C().WAR'+form(_i,-2,,'99')))() !}
|| {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !}
?};
win_disp();
_result


\mode_dst_bl_zam
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Blank na pole MODE_DST w tabeli TCHMAT
::  OLD: \mode_dst_bl_zam/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
VAR1.MODE_DST


\TMATWERD
::----------------------------------------------------------------------------------------------------------------------
::  MOD: TS [8.60]
:: OPIS: TMAT przed dołącz
::   WY: 1
::  OLD: \TMATWERD/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
:---VAR.DJ:=TMAT.NRK().TYP().DJ;
VAR.A_T:=null();
VAR1.KTM:='';
ATR.MJS:='TMAT';
M.blank(1);
{? VAR.A_OP<>null()
|| _unrop:=exec('FindAndGet','#table',TOPER,VAR.A_OP,,"UNROP",0);
   _nrop:=exec('get_oper_nr','tech_oper',_unrop,'\\','n');
   VAR.STRING:=VAR1.TOPER:=_nrop
|| VAR.STRING:=VAR1.TOPER:=''
?};
params_get().env_mater.fields.MAT:=null();
params_get().env_mater.fields.TOPER:=null();
ATR.FLAG_ED:=0;
ATR.FLAG:=0;
M_ATR.blank(0);
{! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !};
ATR.FLAG:=0;
TMAT.GRKTM:='K';
exec('efld_opt','tech_mater',TMAT);
{? VAR.A_KTL().STAN<>'T'
|| VAR.KOR:=0;
   TMAT.hdr_edit();
   params_get().env_mater.buffer_tmat.blank()
|| VAR.KOR:=1;
   TMAT.hdr_edit(' — '+'MODYFIKACJA ZATWIERDZONEJ KARTY'@);
   params_get().env_mater.buffer_tmat.get()
?};
1


\tchm_edt
::----------------------------------------------------------------------------------------------------------------------
::  MOD: MKO [8.60]
:: OPIS: Obsługa po Dołącz/Popraw dla TMAT/TCHMAT (wykorzystywana również jako formuła walidacyjna podczas importu)
::   WE: _a - Alias  tabeli
::       [_b] - tryb pracy: [1] - dołącz, 0 - popraw
::       [_c] - czy import przez Excele: [0]/1
::   WY: Wynik działania funkcji chk_rec
::  OLD: \tchm_edt/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_tab:=_a;
_add:={? var_pres('_b')=type_of(0) || _b || 1 ?};
_import:={? var_pres('_c')=type_of(0) || _c || 0 ?};
{? _import>0
|| VAR.GRUPA:=VAR.GRP_MOD:='N';
   VAR.KOR:=0
?};
{? VAR.KOR & ~_import
|| {? _tab=TMAT
   || _buffer:=exec('buffer_tmat','tech_mater');
      _buffer.get();
      _cmp:=exec('compare','#table',_buffer,params_get().env_mater.buffer_tmat,1,'OD','USER','CAUSE','MOD_TIME')
   || _buffer:=exec('buffer_tchmat','tech_mater');
      _buffer.get();
      _cmp:=exec('compare','#table',_buffer,params_get().env_mater.buffer_tchmat,1,'OD','USER','CAUSE','MOD_TIME')
   ?};

   {? _cmp
   || _msg:='Nic nie zostało zmienione.\nNie można zatwierdzić zmian.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
      || FUN.emsg(_msg)
      ?};
      return(0)
   ?}
?};

:: Tak obsługujemy wskaźnik domyślnosci karty półfabrykatowej, może w przyszłości zostanie dorobiony algorytm walidacyjny
:: pozwalający sprawdzić tlanslacje parametrów, teraz jeśli karta ma parametry to nie może mieć znacznika domyślnosci
:: ER/WRT/XP/11.21/1010/0006
{? _import
||
:: Jeśli karta ma parametry to nie może mieć znacznika domyślnosci
   {? _tab.NRK().TYP().PAR='T' & exec('is_param','tech_head',_tab.NRK) & _tab.DFLT_KTL='T'
   || FUN.emsg('Znacznik \'Karty domyślnej\' dla półfabrykatu nie może być aktywny jeżeli '
               'karta technologiczna posiada parametry.'@);
      return('DFLT_KTL')
   ?}
|| {? VAR.A_KTL().TYP().PAR='T' & exec('is_param','tech_head',VAR.A_KTL) & TMAT.DFLT_KTL='T'
   || TMAT.DFLT_KTL:='N';
      {? FUN.ask('Ustawiono znacznik Karty domyślnej dla półfabrykatu, dla karty która posiada parametry'
                 '\nmoże to doprowadzić do błędnego działania programu.'
                 '\nNależy podać konkretną technologię dla półfabrykatu.\nCzy chcesz powrócić i ją teraz wskazać?'@)
      || return('TRED_KTL')
      ?}
   ?}
?};

:: Sprawdzenie, czy nie powstaną błędy związane z dokładnością półfabrykatu.
{? _tab.KTL<>null()
|| {? _import
   || _xjm:=_tab.NRK().XJM;
      _dokl:=exec('jaka_dok_m','jm',_tab.PT)
   || _xjm:=VAR.A_KTL().XJM;
      _dokl:=exec('jaka_dok_m','jm',VAR.A_T)
   ?};
   {? _dokl=0 & (_tab.WARB/_xjm$_dokl <> _tab.WARB/_xjm)
   || _msg:='Dokładność miary półfabrykatu ustawiona jest na %1 miejsc po przecinku.\n'
            'Natomiast wprowadzona norma brutto powoduje, że na sztukę produktu przypada %2'
            ' półfabrykatu.\nMoże to spowodować błędy w programie.'@[$_dokl,$(_tab.WARB/_xjm)];
      {? _import
      || FUN.info(_msg)
      || _msg+=' Czy kontynuować?'@;
         {? ~FUN.ask()
         || return('TRED_KTL')
         ?}
      ?}
   ?}
?};

{? _tab.POW='T' & (_tab.DFLT_KTL='T' | _tab.KTL<>null())
|| _msg:='Powierzony surowiec nie może mieć wskazanej technologii.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
   || FUN.emsg(_msg)
   ?};
   return('POW')
|? _tab=TMAT & _tab.SO='O' & (_tab.DFLT_KTL='T' | _tab.KTL<>null())
|| _msg:='Odpad/koprodukt nie może mieć wskazanej technologii.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
   || FUN.emsg(_msg)
   ?};
   return('SO')
?};

roundmet(2);
_check:='';

{? ~_import
|| {? _tab.FORMB<>''
   || _tab.WARB:=tpar.calc(_tab.FORMB);
      _tab.WARB:=_tab.WARB $ exec('round_abe','tech_mater',_tab,1)
   ?};
   {? _tab.FORMN<>''
   || _tab.WARN:=tpar.calc(_tab.FORMN);
      _tab.WARN:=_tab.WARN $ exec('round_abe','tech_mater',_tab,1)
   ?};
   {? _tab.DFORMB<>''
   || _tab.DWARB:=tpar.calc(_tab.DFORMB);
      _tab.DWARB:=_tab.DWARB $ exec('round_abe','tech_mater',_tab,0)
   ?};
   {? _tab.DFORMN<>''
   || _tab.DWARN:=tpar.calc(_tab.DFORMN);
      _tab.DWARN:=_tab.DWARN $ exec('round_abe','tech_mater',_tab,0)
   ?}
?};
{? _tab.GRKTM='G'
|| {? _tab.TGRP=null()
   || _msg:='Proszę wypełnić pole \'Grupa\'.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
      || FUN.emsg(_msg)
      ?};
      _check:='TGRP'
   |? _tab.TGDFLT=null()
   || _msg:='Proszę wypełnić pole \'Indeks\'.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
      || FUN.emsg(_msg)
      ?};
      _check:='KTM'
   ?}
|| {? _tab.PT=null()
   || _msg:='Proszę wypełnić pole \'Indeks\'.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
      || FUN.emsg(_msg)
      ?};
      _check:='KTM'
   ?}
?};
{? ~_import & _tab<>TCHMAT
|| {? _tab.SO='O' || _tab.LIMIT:='T' ?}
?};
_ctrl_rodz:=1;
{? ~_import & cur_win(1,1)='REDS'
|| _ctrl_rodz:=0
?};

{? _import
|| _dj:=_tab.NRK().TYP().DJ
|| _dj:=VAR.DJ
?};

{? ~_import & VAR.A_T<>null() & ~exec('sprktm','tech_mater',_tab,VAR.A_T,VAR.GRUPA<>'T',_ctrl_rodz)
|| _check:='KTM'
?};

{? _check='' & _dj='P'
|| _check:={? exec('ae_brutto','tech_mater',_tab,_import) || '' || {? _tab.FORMB<>'' || 'FORMB' || 'WARB' ?} ?}
?};

{? _check='' & _dj='P'
|| _check:={? exec('ae_netto','tech_mater',_tab) || '' || {? _tab.FORMN<>'' || 'FORMN' || 'WARN' ?} ?}
?};

{? _check='' & _dj='D'
|| _check:={? exec('ae_dbrutto','tech_mater',_tab,_import) || '' || {? _tab.DFORMB<>'' || 'DFORMB' || 'DWARB' ?} ?}
?};

{? _check='' & _dj='D'
|| _check:={? exec('ae_dnetto','tech_mater',_tab) || '' || {? _tab.DFORMN<>'' || 'DFORMN' || 'DWARN' ?} ?}
?};

{? _check='' & _dj='D'
|| _ok:=(TKTL.STAT_S='N' | VAR.KOR);
   {? _ok
   || _coef:=_tab.PRZ;
      {? _tab.DJM=null()
      || _msg:='Należy podać jednostkę miary.'@;
         {? VAR.GRUPA='T'
         || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
         || FUN.emsg(_msg)
         ?};
         _check:='DJM'
      |? _coef=0
      || _msg:='Należy podać przelicznik.'@;
         {? VAR.GRUPA='T'
         || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
         || FUN.emsg(_msg)
         ?};
         _check:='PRZ'
      ?};
      {? ~_import
      || _dokl:=exec('round_abe','tech_mater',_tab,1);
         {? _check=''
         || _tab.WARN:=(_tab.DWARN*_coef) $ _dokl;
            _tab.WARB:=(_tab.DWARB*_coef) $ _dokl
         || _tab.WARN:=0;
            _tab.WARB:=0
         ?}
      ?}
   ?}
?};

{? _check=''
|| _txt:=
      {? _tab=TMAT & TMAT.win_edit('?')='REDS'
      || 'ilość'@
      || 'Norma brutto'@
      ?};
   {? _dj='P'
   || {? _tab.WARB=0
      || {? _tab.FORMB='' & _tab.SO='S'
         || FUN.emsg('Proszę wypełnić pole \'%1\'.'@[_txt]);
            _check:='WARB'
         || {? ~_import & FUN.ask('Wartość pola \'%1\' wynosi zero.\nCzy kontynuować?'@[_txt])=0
            ||  _check:={? _tab.FORMB<>'' || 'FORMB' || 'WARB' ?}
            ?}
         ?}
      ?}
   || {? _tab.DWARB=0
      || {? _tab.DFORMB='' & _tab.SO='S'
         || FUN.emsg('Proszę wypełnić pole \'%1\'.'@[_txt]);
            _check:='DWARB'
         || {? ~_import & FUN.ask('Wartość pola \'%1\' wynosi zero.\nCzy kontynuować?'@[_txt])=0
            || _check:={? _tab.DFORMB<>'' || 'DFORMB' || 'DWARB' ?}
            ?}
         ?}
      ?}
   ?}
?};

{? _check='' & _tab=TMAT & _tab.MG<>null()
||
:: W przypadku surowców limitowanych sprawdzenie czy przypisany magazyn paletowy
::(jeżeli tak to wszystkie surowce muszą być z paletowego)
   {? TMAT.LIMIT='T' & TMAT.SO='S'
   || {? exec('chk_mg','tech_mater',_add)=0
      || {? TMAT.MG().PAL='T'
         || _msg:='Surowiec nie może być przypisany do magazynu z obsługą palet.'@
         || _msg:='Surowiec musi być przypisany do magazynu z obsługą palet.'@
         ?};
         {? VAR.GRUPA='T'
         || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
         || FUN.emsg(_msg)
         ?};
         _check:='MG'
      ?}
   ?};

:: Sprawdzam czy magazyn jest typu z obsługą dostaw jeżeli przypięta jest cecha
   {? _check='' & TMAT.DK_C<>null()
   || {? ~(TMAT.MG().TYP*'DOST')
      || _msg:='Surowiec posiada cechę, przypisany magazyn musi być typu: \'%1\''@['DOSTAWY lub DOSTEWI'];
         {? VAR.GRUPA='T'
         || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
         || FUN.emsg(_msg)
         ?};
         _check:='MG'
      ?}
   ?};
:: W przypadku surowców limitowanych sprawdzenie czy przypisany magazyn obsługuje realizację zamówień wewnętrznych
   {? _check='' & TMAT.LIMIT='T' & TMAT.SO='S'
   || {? ~exec('czyMgUprZam','zamsiw_wspolne',TMAT.MG,-1)
      || _msg:='Wybrany magazyn nie jest uprawniony do realizacji zamówień wewnętrznych'@;
         {? VAR.GRUPA='T'
         || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
         || FUN.emsg(_msg)
         ?};
         _check:='MG'
      ?}
   ?}
?};

{? _check='' & _tab=TMAT
||
:: Sprawdzam czy istnieje ten sam surowiec który ma włączone inne 'Ręczne śledzenie dostaw w partii'
:: Nie jest dozwolone istnienie dwóch takich samych surowców z tą własnościa ponieważ
:: podczas rozliczania partii takie same surowce są scalane w jeden zapis
   _mat:=null();
   _my_ref:='';
   {? ~_import & menu_txt()*'P'>0
   || _my_ref:=$TMAT.ref()
   ?};
   _mode_dst:=TMAT.MODE_DST;

   TMAT.cntx_psh();
   M.cntx_psh();
   TMAT.index('NNL');
   TMAT.prefix(TMAT.NRK);
   _mat:=TMAT.PT;

   {? TMAT.first()
   || {!
      |? _msg:='Na liście surowców występuje już ten sam materiał, ale o innym znaczniku: '
               '\'Ręczne śledzenie dostaw w partii\'.'@;
         {? TMAT.PT=_mat & _my_ref<>$TMAT.ref()
         || {? TMAT.MODE_DST<>_mode_dst
            || {? VAR.GRUPA='T'
               || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
               || FUN.emsg(_msg)
               ?};
               _check:='MODE_DST'
            ?}
         ?};
         TMAT.next() & _check=''
      !}
   ?};
   M.cntx_pop();
   TMAT.cntx_pop();
   ~~
?};

:: Dodatkowe kontrole tylko przy modyfikacji zatwierdzonej karty
:: (w innym przypadku kotrola jest podczas zatwierdzania surowców technologii).
{? _check='' & (VAR.KOR | (_tab=TMAT & _import))
|| _mat:=null();
   _my_ref:='';
   {? ~_import & menu_txt()*'P'>0
   || _my_ref:=$TMAT.ref()
   ?};
   _limit:=TMAT.LIMIT;
   _so:=TMAT.SO;

   TMAT.cntx_psh();
   M.cntx_psh();
   TMAT.index('NNL');
   TMAT.prefix(TMAT.NRK);
   _mat:=TMAT.PT;

   {? TMAT.first()
   || {!
      |? {? TMAT.PT=_mat & _my_ref<>$TMAT.ref()
         || {? TMAT.LIMIT<>_limit
            || _msg:='Na liście surowców występuje już ten sam materiał, ale o innym znaczniku: '
                     '\'Jest surowcem limitowanym\'.'@;
               {? VAR.GRUPA='T'
               || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
               || FUN.emsg(_msg)
               ?};
               _check:='LIMIT'
            |? TMAT.SO<>_so
            || _msg:='Na liście surowców występuje już ten sam materiał, ale o innym znaczniku: '
                     '\'Jest odpadem/koproduktem technologicznym\'.'@;
               {? VAR.GRUPA='T'
               || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
               || FUN.emsg(_msg)
               ?};
               _check:='SO'
            ?}
         ?};
         TMAT.next() & _check=''
      !}
   ?};
   M.cntx_pop();
   TMAT.cntx_pop();
   ~~
?};

{? _check='' & ~_import & VAR.KOR
|| {? _tab.CAUSE=null()
   || {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_mater')+'Nie podano przyczyny zmiany.'@)
      || FUN.emsg('Podaj przyczynę zmiany.'@)
      ?};
      return('CAUSE')
   ?}
?};

{? _check='' & _tab=TMAT
||
:: Obsługa usług
   _check:=exec('valid_tmat','zl_uslugi')
?};

{? _check='' & _tab=TMAT
||
:: Sprawdzam, czy surowiec przypisany do operacji wariantowej. Dla takiego przypadku nie można dołączać surowców, dla
:: których będzie generowane podzlecenie
   {? _tab.NROP<>null() & (_tab.RKTL<>'' | _tab.DFLT_KTL='T') & _tab.MAG<>'T'
   || _where:=exec('FindAndGet','#table',TOPER,_tab.NROP,,"WHERE",'');
      {? _where<>'W'
      || _check:='MAG';
         FUN.emsg('Surowiec, dla którego ma zostać wygenerowane podzlecenie nie może być przypisany '
                  'do operacji wariantowej, występującej wyłącznie na pierwszym/ostatnim przewodniku zlecenia.'@)
      ?}
   ?}
?};

{? _check='' & ~_import
|| {? ATR.FLAG_ED & ATR.FLAG<>1
   || exec('akcepatr','mat_atr',0,1)
   ?}
?};

_check


\ptmatpop
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed popraw TMAT
::   WE: [_a] - czy uruchomione w ramach modyfikacji technologii zlecenia (czynności TTE_PLZ_DTSZ): [0]/1
::  OLD: \ptmatpop/tex_tpar.fml
::----------------------------------------------------------------------------------------------------------------------
_dtsz:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_ok:=1;
_grp_msg:='';
{? VAR.GRP_MOD='' ||  VAR.GRP_MOD:='N' ?};
{? TMAT.DK_C<>null() & 1+((8+$TMAT.DK_C)+3)<>ST.ODDZ_KOD
|| _msg:=
      'Nie można redagować surowca.\n\n'
      'Surowiec z atrybutem powiązanym z oddziałem \'%1\'.\n'
      'Aktualnie ustawiony jest oddział \'%2\'.'
      ''@[1+((8+$TMAT.DK_C)+3),ST.ODDZ_KOD];
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
   || FUN.info(_msg)
   ?};
   _ok:=0
|? TMAT.ACT='N'
|| _msg:='Element nieaktywny — nie można modyfikować.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
   || FUN.info(_msg)
   ?};
   _ok:=0
|? _dtsz=0 & params_exec('can_modify','tech_mater')=0
|| _msg:='Stan technologii lub surowca nie pozwala na modyfikację elementu.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
   || FUN.info(_msg)
   ?};
   _ok:=0
|? TMAT.NRK().ZL<>null()
||
   _rodzaj:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT().R || TMAT.PT().R ?};
   _ktm:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};
   _ktm_sym:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT().KTM || TMAT.PT().KTM ?};
   {? (_rodzaj='P' | _rodzaj='W') & (TMAT.DFLT_KTL='T' | TMAT.RKTL<>'') & TMAT.MAG<>'T'
   || {? ZL.NRNZL<>0
      || _zl:=exec('is_zl4tmat','zl_link',TMAT.ref());
         _sym:=exec('FindAndGet','#table',ZL,_zl,,"SYM",'');
         {? _zl
         || KOMM.init(,,'Poprawianie surowca zlecenia %1'@[_sym]);
            {? exec('zl_usun_chk','zl_head',_zl,0,0)
            || _txt:='Po zamianie półfabrykatu %1, zostanie usunięte zlecenie półfabrykatowe %2.'@[_ktm_sym,_sym];
               {? VAR.GRUPA='T'
               || KOMM.add(_txt,4);
                  _ok:=0
               || _ok:=FUN.ask(_txt+'\n\n'+'Czy mimo tego chcesz zmodyfikować dane wskazanego surowca?'@)
               ?}
            || KOMM.select();
               _ok:=0
            ?}
         || _ok:=1
         ?}
      || _ok:=1
      ?}
   || _ok:=1
   ?}
?};

{? _ok>0
||
   VAR.DJ:=TMAT.NRK().TYP().DJ;
   params_get().env_mater.fields.KTLMAT:=TMAT.KTL;
   params_get().env_mater.fields.MAT:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};
   params_get().env_mater.fields.TOPER:=TMAT.NROP;
   ATR.MJS:='TMAT';
   ATR.M_ATR:={? TMAT.PT<>null() || TMAT.PT().M_ATR |? TMAT.TGDFLT<>null() || TMAT.TGDFLT().PT().M_ATR || null() ?};
   ATR.FLAG_ED:=ATR.CZY_ATR & ATR.M_ATR().EDIT;
   ATR.FLAG:={? ATR.FLAG_ED & ATR.M_ATR<>null() || 2 || 0 ?};
   {? ATR.FLAG_ED || {? ATR.M_ATR<>null() || ATR.FLAG_ED:=2 ?} ?};
   {? TMAT.DK_C<>null() & TMAT.DK_C().M_ATR<>null()
   || TMAT.DK_C().M_ATR().SYM;
      {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=($('TMAT.DK_C().WAR'+form(_i,-2,,'99')))() !}
   || ATR.M_ATR().SYM;
      {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !}
   ?};
   {! _i:=1..10
   |! _ch:=1+((_i-1)-TMAT.ATR_MASK);
      ($('ATR.ZL_WAR'+form(_i,-2,,'99')))():={? _ch='T' || 'T' || 'N' ?}
   !};
   {? TKTL.STAN<>'T'
   || VAR.KOR:=0;
      TMAT.hdr_edit()
   || VAR.KOR:=1;
      TMAT.USER:=OPERATOR.USER;
      TMAT.MOD_TIME:=TKTL.tm_stamp();
      TMAT.CAUSE:=exec('ttxcause_default','tech_common');
      TMAT.hdr_edit(' — '+'MODYFIKACJA ZATWIERDZONEJ KARTY'@)
   ?};
   exec('efld_opt','tech_mater',TMAT);
   params_get().env_mater.buffer_tmat.get()
?};
_ok


\ptchparpop
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Popraw przed zamiennika surowca (TCHMAT okienko WER)
::  OLD: \ptchparpop/tex_tpar.fml
::----------------------------------------------------------------------------------------------------------------------
_ok:=1;

{? TCHMAT.DK_C<>null() & 1+((8+$TCHMAT.DK_C)+3)<>ST.ODDZ_KOD
|| FUN.info(
      'Nie można redagować zamiennika.\n\n'
      'Zamiennik z atrybutem powiązanym z oddziałem \'%1\'.\n'
      'Aktualnie ustawiony jest oddział \'%2\'.'
      ''@[1+((8+$TCHMAT.DK_C)+3),ST.ODDZ_KOD]);
   _ok:=0
|? TCHMAT.ACT='N'
|| FUN.info('Element nieaktywny — nie można modyfikować.'@);
   _ok:=0
?};

{? _ok>0
|| VAR.DJ:=TMAT.NRK().TYP().DJ;
   params_get().env_mater.fields.KTLMAT:=TCHMAT.KTL;
   params_get().env_mater.fields.MAT:={? TCHMAT.GRKTM='G' || TCHMAT.TGDFLT().PT || TCHMAT.PT ?};
   ATR.MJS:='TCHMAT';
   ATR.M_ATR:={? TCHMAT.PT<>null()
              || TCHMAT.PT().M_ATR
              |? TCHMAT.TGDFLT<>null()
              || TCHMAT.TGDFLT().PT().M_ATR
              || null()
              ?};
   ATR.FLAG_ED:=ATR.CZY_ATR & ATR.M_ATR().EDIT;
   ATR.FLAG:={? ATR.FLAG_ED & ATR.M_ATR<>null() || 2 || 0 ?};
   {? ATR.FLAG_ED || {? ATR.M_ATR<>null() || ATR.FLAG_ED:=2 ?} ?};
   {? TCHMAT.DK_C<>null() & TCHMAT.DK_C().M_ATR<>null()
   || TCHMAT.DK_C().M_ATR().SYM;
      {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=($('TCHMAT.DK_C().WAR'+form(_i,-2,,'99')))() !}
   || ATR.M_ATR().SYM;
      {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !}
   ?};
   {! _i:=1..10
   |! _ch:=1+((_i-1)-TCHMAT.ATR_MASK);
      ($('ATR.ZL_WAR'+form(_i,-2,,'99')))():={? _ch='T' || 'T' || 'N' ?}
   !};
   {? TKTL.STAN<>'T'
   || VAR.KOR:=0;
      TCHMAT.hdr_edit()
   || VAR.KOR:=1;
      TCHMAT.USER:=OPERATOR.USER;
      TCHMAT.MOD_TIME:=TKTL.tm_stamp();
      TCHMAT.CAUSE:=exec('ttxcause_default','tech_common');
      TCHMAT.hdr_edit(' — '+'MODYFIKACJA ZATWIERDZONEJ KARTY'@)
   ?};
   exec('efld_opt','tech_mater',TCHMAT);
   params_get().env_mater.buffer_tchmat.get()
?};
_ok


\tmattpop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Po akcji popraw dla okna wertowania tabeli TMAT
::  OLD: \tmattpop/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
:: Aktualizuje dla TMAT pola MODE_DST, NROP na zamiennikach
TCHMAT.cntx_psh();
TCHMAT.index('NSL');
TCHMAT.prefix(VAR.A_KTL,TMAT.ref());
{? TCHMAT.first()
|| {!
   |?
      TCHMAT.MODE_DST:=TMAT.MODE_DST;
::    W przypadku modyfikacji operacji na TMAT, przepisanie na TCHMAT
      TCHMAT.NROP:=TMAT.NROP;
      TCHMAT.put();
      TCHMAT.next()
   !}
?};
TCHMAT.cntx_pop();
{? params_get().env_mater.fields.MAT<>VAR.A_T | params_get().env_mater.fields.KTLMAT<>TMAT.KTL
|| exec('tparpop','tech_param')
?};
:: W przypadku technologii zlecenia usunięcie zlecenia półfabrykatowego albo limitu,
:: gdy zmiana surowca lub usunięcie karty technologicznej
{? params_get().env_mater.fields.MAT<>VAR.A_T & TMAT.NRK().ZL<>null() | (TMAT.KTL=null() & TMAT.DFLT_KTL='N')
||
:: Próbuję usunąć limity
   ZLIM.cntx_psh();
   exec('openmask','zl_common',ZL.ref());
   ZLIM.index('RTMAT');
   ZLIM.prefix($TMAT.ref());
   {? ZLIM.first()
   || {!
      |? ZLIM.cntx_psh(); {? ZLIM.next() || _next:=ZLIM.ref() || _next:=null() ?}; ZLIM.cntx_pop();
         _ok:=exec('ZLIM_del_brut','zl_limit',1,0);
         ZLIM.seek(_next) & _ok>0
      !}
   ?};
   ZLIM.cntx_pop();

   _zl:=exec('is_zl4tmat','zl_link',TMAT.ref());
   {? _zl || exec('zl_usun','zl_head',_zl,,0) ?}
?};
exec('faztchmat','tech_mater');
~~


\tchmattpop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Po akcji popraw dla okna wertowania tabeli TCHMAT
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
{? params_get().env_mater.fields.MAT<>VAR.A_T | params_get().env_mater.fields.KTLMAT<>TCHMAT.KTL
|| exec('tchparpop','tech_param')
?};
~~


\faztchmat
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Zmiania fazę na TCHMAT po modyfikacji TMAT
::  OLD: \faztchmat/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\usuntmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.50]
:: OPIS: Usunięcie surowca (albo dezaktywacja, gdy na zatwierdzonej karcie)
::   WE: [_a] - INTEGER - 0/[1] - czy zadawać pytania (0 / 1) - domyślnie 1
::       [_b] - INTEGER - [0]/1 - czy usuwać limity skojarzone z TMATem
::  OLD: \usuntmat/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _askDel:=_a || _askDel:=1 ?};

_del_zlim:=0;
{? var_pres('_b')=type_of(0)
|| _del_zlim:=_b
?};

_ok:=1;
_uprDelSur:=0;


_zl2del:=null();

_info:='';
{? _askDel>0
|| _info:='Surowiec: %1 jest redagowany'@[exec('record','#to_string',TMAT.ref())]
|| _info:='Surowiec: %1 jest redagowany przez innego użytkownika. Usunięcie niemożliwe.'@[exec('record','#to_string',TMAT.ref())]
?};
_ref:=TMAT.ref();
{? exec('blk_lock','#table','TMAT',_ref,,1,_info)
||
:: Sprawdzenie czy z surowcem nie jest związane zlecenie półfabrykatowe (dla technologii zlecenia)
   {? TMAT.NRK().ZL<>null()
   ||
      KOMM.init(250,,'Usuwanie surowca zlecenia %1'@[ZL.SYM]);
::    Bufor ZL jest podczytany

      _sym:='';
      _uprDelSur:=exec('uprDelSurZatwZl','tech_mater');
      {? ZL.STAT_T='T' & ~_uprDelSur
      || FUN.info('Brak uprawnień do usuwania surowców zatwierdzonej technologii zlecenia.'@);
         _ok:=0
      || _rodzaj:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT().R || TMAT.PT().R ?};
         _ktm:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};
         _ktm_sym:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT().KTM || TMAT.PT().KTM ?};
         {? (_rodzaj='P' | _rodzaj='W') & (TMAT.DFLT_KTL='T' | TMAT.RKTL<>'') & TMAT.MAG<>'T'
         || {? ZL.NRNZL<>0
            || _zl2del:=exec('is_zl4tmat','zl_link',TMAT.ref());
               _sym:=exec('FindAndGet','#table',ZL,_zl2del,,"SYM",'');
               {? ~_zl2del
               || _ok:=1
               || KOMM.init(,,'Usuwanie surowca zlecenia %1'@[_sym]);
                  {? exec('zl_usun_chk','zl_head',_zl2del,0,0)
                  || _txt:='Po usunięciu półfabrykatu %1, zostanie usunięte zlecenie półfabrykatowe %2.'@[_ktm_sym,_sym];
                     {? VAR.GRUPA='T'
                     || KOMM.add(_txt,4);
                        _ok:=0
                     || _del_zlim:=0;
                        _ok:=FUN.ask(_txt+'\n\n'+'Czy usunąć zlecenie i wskazany surowiec?'@);
                        _askDel:=0;
                        {? _ok>0
                        || _del_zlim:=1
                        ?}
                     ?}
                  || KOMM.select();
                     _ok:=0
                  ?}
               ?}
            || _ok:=1
            ?}
         || _ok:=1
         ?}
      ?}
   ?};

   {? _ok>0 & TMAT.NRK().ZL<>null()
   ||
      ZLIM.cntx_psh();
      exec('openmask','zl_common',ZL.ref());
      ZLIM.index('RTMAT');
      ZLIM.prefix($TMAT.ref());
      {? _del_zlim>0
      ||
::       Próbuję usunąć limity
         {? ZLIM.first()
         || {!
            |? ZLIM.cntx_psh(); {? ZLIM.next() || _next:=ZLIM.ref() || _next:=null() ?}; ZLIM.cntx_pop();
               _ok:=exec('ZLIM_del_brut','zl_limit',1,0);
               ZLIM.seek(_next) & _ok>0
            !}
         ?}
      ?};
::    Sprawdzenie czy z surowcem nie jest związany limit (dla technologii zlecenia)
      {? ZLIM.first()
      || FUN.info('Do wskazanego surowca zostały już wygenerowane zapotrzebowania.\n'
                  'W pierwszej kolejności należy usunąć zapotrzebowania.'@);
         _ok:=0
      ?};
      ZLIM.cntx_pop()
   ?};

:: Usunięcie zlecenia półfabrykatowego, gdy wymagane
   {? _ok>0 & TMAT.NRK().ZL<>null() & _zl2del<>null()
   || _ok:=exec('zl_usun','zl_head',_zl2del,,0)
   ?};

:: Zasadnicze usuwanie - wspólna część dla technologii i technologii zlecenia
   {? _ok>0
   || {? TKTL.STAN<>'T' | _uprDelSur
      || TCHMAT.index('SL');
         TCHMAT.prefix(TMAT.ref());
         _tch:=TCHMAT.first();
         {? VAR.GRUPA='T' |
            ({? ~_askDel
             || 1
             || FUN.ask('Czy usunąć bieżący wiersz?'@+
                    {? _tch || '\n\n'+'Usunięta zostanie również lista zamienników.'@ || '' ?}
                )
             ?}
            )
         || exec('usuntpar','tech_param');
            {? TCHMAT.first()
            || {! |? exec('usuntchpar','tech_param'); DocLib.del('TCHMAT',TCHMAT.ref()); TCHMAT.del() !}
            ?};
            DocLib.del('TMAT',TMAT.ref());
            TMAT.del()
         ?}
      || exec('zm_m_usun','tech_mater',_askDel)
      ?}
   ?};
   exec('blk_unlock','#table','TMAT',_ref)
|| {? _askDel=0
   || KOMM.add(_info,2,,1)
   ?}
?};
~~


\przywrtmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przywrócenie nieaktywnego surowca
::----------------------------------------------------------------------------------------------------------------------
{? TKTL.STAN='T'
|| exec('zm_m_usun','tech_mater',3)
?}


\zm_m_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Zmiana - usunięcie (dezaktualizacja)/przywrócenie surowca na zatwierdzonej technologii;
::        usuwane (dezaktualizowane) są również zamienniki
::   WE: _a - usuwanie-czy z dialogiem (1/0), przywracanie-czy z dialogiem (3/2)
::      [_b] - data
::      [_c] - przyczyna TTXCAUSE.ref()
::      [_d] - ustawiany znacznik czasowy
::      [_e] - znacznik czasowy przywracanych elementów
::  OLD: \zm_m_usun/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
:: czy tryb przywracania
_przywr:=_a>1;
:: czy z oknem dialogowym
_bDialog:=_a-2*_przywr;

{? var_pres('_b')=type_of(date()) || _dData:=_b || _dData:=date() ?};
{? var_pres('_c')=type_of(null()) || _rCause:=_c || _rCause:=null() ?};
{? var_pres('_d')=type_of(0) || _tmstamp:=_d || _tmstamp:=TKTL.tm_stamp() ?};
{? var_pres('_e')=type_of(0) || _oldstamp:=_e || _oldstamp:=TMAT.MOD_TIME ?};

{? _przywr
||
   {? TMAT.ACT='T'
   || {? _bDialog || FUN.emsg('Element aktywny — nie można go przywracać.'@) ?};
      return()
   |? TMAT.ACT='N' & TMAT.KTL<>null() & TMAT.KTL().ARCH='T'
   || {? _bDialog || FUN.emsg('Karta technologiczna elementu znajduje się w archiwum — nie można go przywracać.'@) ?};
      return()
   ?}
||
   {? TMAT.ACT='N'
   || {? _bDialog || FUN.emsg('Element usunięty — nie można modyfikować.'@) ?};
      return()
   ?}
?};
VAR.KOR:=1;
_win_edit:=TMAT.win_edit('?');

{? _przywr
|| TMAT.win_edit('PRZYWR')
|| TMAT.win_edit('USUN')
?};

{? ~_bDialog
      |
   FUN.ask(
      {? _przywr
      || 'Modyfikacja zatwierdzonej karty technologicznej.'@+'\n\n'+
         'Czy na pewno przywrócić element?'@
      || 'Modyfikacja zatwierdzonej karty technologicznej.'@+'\n\n'+
         'Czy na pewno usunąć (dezaktywować) element?'@
      ?}
   )
|| TTXCAUSE.win_sel('WER');
   TTXCAUSE.actions('WER','','T:d');
   TMAT.OD:=_dData;
   {? _rCause<>null()
   || TMAT.CAUSE:=_rCause
   || TMAT.CAUSE:=exec('ttxcause_default','tech_common')
   ?};
   {? ~_bDialog | TMAT.edit(
         "{? TMAT.CAUSE=null()
          || FUN.info('Podaj przyczynę zmiany.'@);
             'CAUSE'
          || ''
          ?}
         ")
   ||
      {? _bDialog | ~_przywr | TMAT.MOD_TIME=_oldstamp
      || _dData:=TMAT.OD;
         TMAT.ACT:={? _przywr || 'T' || 'N' ?};
::       Sprawdzenie czy po przywróceniu %skład nie przekroczy 100, jeżeli tak to zeruje %skład danego surowca
::         {? _przywr
::         || {? (exec('sum_xjmp','tech_mater',TMAT.NRK)+TMAT.XJMP)>100
::            || TMAT.XJMP:=0;
::               TMAT.DXJMP:=0
::            ?}
::         ?};
         TMAT.USER:=OPERATOR.USER;
         TMAT.MOD_TIME:=_tmstamp;
         {? TMAT.put()
         || _rCause:=TTXCAUSE.ref();
            TCHMAT.index('SL');
            TCHMAT.prefix(TMAT.ref());
            {? TCHMAT.first()
            || {!
               |? exec('zm_c_usun','tech_mater',{? _przywr || 2 || 0 ?},_dData,_rCause,_tmstamp,_oldstamp);
                  TCHMAT.next()
               !}
            ?}
         ?}
      ?}
   ?}
?};
TMAT.win_edit(_win_edit);
VAR.KOR:=0;
~~


\usuntchmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.50]
:: OPIS: Usunięcie zamiennika surowca (albo dezaktywacja, gdy na zatwierdzonej karcie)
::  OLD: \usuntchmat/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? TKTL.STAN<>'T'
|| {? VAR.GRUPA='T' | FUN.ask('Czy usunąć bieżący wiersz?'@)
   || exec('usuntchpar','tech_param');
      DocLib.del('TCHMAT',TCHMAT.ref());
      TCHMAT.del()
   ?}
|| exec('zm_c_usun','tech_mater',1)
?}


\przywrtchmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przywrócenie nieaktywnego zamiennika surowca
::----------------------------------------------------------------------------------------------------------------------
{? TKTL.STAN='T'
|| exec('zm_c_usun','tech_mater',3)
?}


\zm_c_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Zmiana - usunięcie (dezaktualizacja)/przywrócenie zamiennika surowca na zatwierdzonej technologii
::   WE: _a - _a - usuwanie-czy z dialogiem (1/0), przywracanie-czy z dialogiem (3/2)
::      [_b] - data
::      [_c] - przyczyna TTXCAUSE.ref()
::      [_d] - ustawiany znacznik czasowy
::      [_e] - znacznik czasowy przywracanych elementów
::  OLD: \zm_c_usun/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
:: czy tryb przywracania
_przywr:=_a>1;
:: czy z oknem dialogowym
_bDialog:=_a-2*_przywr;

{? var_pres('_b')=type_of(date()) || _dData:=_b || _dData:=date() ?};
{? var_pres('_c')=type_of(null()) || _rCause:=_c || _rCause:=null() ?};
{? var_pres('_d')=type_of(0) || _tmstamp:=_d || _tmstamp:=TKTL.tm_stamp() ?};
{? var_pres('_e')=type_of(0) || _oldstamp:=_e || _oldstamp:=TCHMAT.MOD_TIME ?};

{? _przywr
|| {? TCHMAT.ACT='T'
   || {? _bDialog || FUN.emsg('Element aktywny — nie można go przywracać.'@) ?};
      return()
   ?}
|| {? TCHMAT.ACT='N' & TCHMAT.OD<=date()
   || {? _bDialog || FUN.emsg('Element usunięty — nie można już modyfikować.'@) ?};
      return()
   ?}
?};
VAR.KOR:=1;
_win_edit:=TCHMAT.win_edit('?');

{? _przywr
|| TCHMAT.win_edit('PRZYWR')
|| TCHMAT.win_edit('USUN')
?};

{? ~_bDialog
      |
   FUN.ask(
      {? _przywr
      || 'Modyfikacja zatwierdzonej karty technologicznej.'@+'\n\n'+
         'Czy na pewno przywrócić element?'@
      || 'Modyfikacja zatwierdzonej karty technologicznej.'@+'\n\n'+
         'Czy na pewno usunąć (dezaktywować) element?'@
      ?}
   )
|| TTXCAUSE.win_sel('WER');
   TTXCAUSE.actions('WER','','T:d');
   TCHMAT.OD:=_dData;
   {? _rCause<>null()
   || TCHMAT.CAUSE:=_rCause
   || TCHMAT.CAUSE:=exec('ttxcause_default','tech_common')
   ?};
   {? ~_bDialog | TCHMAT.edit("
         {? TCHMAT.CAUSE=null()
         || FUN.info('Podaj przyczynę zmiany.'@);
            'CAUSE'
         || ''
         ?} ")
   ||
      {? _bDialog | ~_przywr | TCHMAT.MOD_TIME=_oldstamp
      || TCHMAT.ACT:={? _przywr || 'T' || 'N' ?};
         TCHMAT.USER:=OPERATOR.USER;
         TCHMAT.MOD_TIME:=_tmstamp;
         TCHMAT.put()
      ?}
   ?}
?};
TCHMAT.win_edit(_win_edit);
VAR.KOR:=0;
~~


\ustmat_gpr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Obsługa 'przed grupą' dla usuwania surowców
::   WY: 0 / 1
::  OLD: \ustmat_gpr/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? TKTL.STAN='T'
|| FUN.info('Na zaakceptowanej karcie usuwać (dezaktywować) można tylko pojedyncze pozycje.'@);
   0
|? FUN.ask('Ilość zaznaczonych surowców: %1. Czy usuwać?'@[form(TMAT.sel_size())])
|| VAR.GRUPA:='T';
   KOMM.init();
   1
|| 0
?}


\ustmat_gpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Obsługa 'po grupie' dla usuwania surowców
::   WY: ~~
::  OLD: \ustmat_gpo/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\ustchmat_gpr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obsługa 'przed grupą' dla usuwania zamienników surowca
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
{? TKTL.STAN='T'
|| FUN.info('Na zaakceptowanej karcie usuwać (dezaktywować) można tylko pojedyncze pozycje.'@);
   0
|? FUN.ask('Ilość zaznaczonych zamienników surowca: %1. Czy usuwać?'@[form(TCHMAT.sel_size())])
|| VAR.GRUPA:='T';
   KOMM.init();
   1
|| 0
?}


\ustchmat_gpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obsługa 'po grupie' dla usuwania zamienników surowca
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\tmat_powiel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Powielenie pozycji na liście surowców technologii
::  OLD: \tmat_powiel/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

TMAT.LP:=exec('blnrsrc','tech_mater');
TMAT.ACT:='T';
TMAT.CRE_TIME:=exec('cre_time_bl','tech_mater');
TMAT.OD:=date(0,0,0);
TMAT.USER:=exec('user_bl','tech_mater');
TMAT.CAUSE:=null();
TMAT.MOD_TIME:=0;
VAR.A_T:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};
VAR1.KTM:=VAR.A_T().KTM;
params_get().env_mater.fields.MAT:=null();
params_get().env_mater.fields.TOPER:=null();
ATR.MJS:='TMAT';
ATR.M_ATR:=VAR.A_T().M_ATR;
ATR.FLAG_ED:=ATR.CZY_ATR & ATR.M_ATR().EDIT;
ATR.FLAG:={? ATR.FLAG_ED & ATR.M_ATR<>null() || 2 || 0 ?};
{? ATR.FLAG_ED || {? ATR.M_ATR<>null() || ATR.FLAG_ED:=2 ?} ?};
{? TMAT.DK_C<>null() & TMAT.DK_C().M_ATR<>null()
|| TMAT.DK_C().M_ATR().SYM;
   {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=($('TMAT.DK_C().WAR'+form(_i,-2,,'99')))() !}
|| ATR.M_ATR().SYM;
   {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !}
?};
exec('efld_opt','tech_mater',TMAT);
{? TMAT.edit("params_exec('tchm_edt','tech_mater',TMAT)",,'PT')
|| {? TMAT.add()
   || exec('tmattpar','tech_mater')
   ?}
?};
~~


\tmatwerz
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Zamienniki surowca
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_used:=params_get().env_mater.used;
_wins:=params_get().env_mater.wins;

{? TMAT.SO='O'
|| FUN.info('Dla odpadu/koproduktu nie można definiować zamienników.'@);
   return()
?};

_act:=(TMAT.ACT='T');
_arc:=(TKTL.ARCH='T');

_interm:=exec('interm','#system');
TMAT.cntx_psh();
_wer:='WER_'+TKTL.TORW;

{? exec('tch_edit_attr','tech_mater')
|| TCHMAT.fld_attr('DK_C',1);
   TCHMAT.fld_attr('RDKC',1);
   TCHMAT.fld_attr('ATR_MASK',1)
|| TCHMAT.fld_attr('DK_C',2);
   TCHMAT.fld_attr('RDKC',2);
   TCHMAT.fld_attr('ATR_MASK',2)
?};

{? ~_used & ~_arc & _act & TKTL.STAT_S='N' & (TKTL.STAT_N='T' | TKTL.TORW='Z')
|| _fb:="
      {? exec('get','#params',500740,2)='N'
      || M.index('ARODZ'); M.prefix('T','T')
      || M.index('R_KOMP'); M.prefix('T','T','T')
      ?}
   ";
   _grp:=TCHMAT.grp_make('Zamienniki surowca'@,_fb,'tchmat_grp',,15,,,'html_maximized');
   _after_refresh:="";
   {? _interm=0
   || _after_refresh:="grp_disp(TTG,params_get().env_mater.wins.WERCG); grp_disp(M,params_get().env_mater.wins.WERCM)"
   ?};
   TCHMAT.grp_sel(_grp,,_wer,,_after_refresh,,,,,,,,'maximized');
   {? _interm=0
   ||
      TCHMAT.grp_splt(_grp,,'vertical','slowniki',',67%');
      _wins.WERCM:=M.mk_sel('Materiały'@,'P',0,'material_wer',,,,,'U');
      M.win_fld(_wins.WERCM,,'KTM',,,10);
      M.win_fld(_wins.WERCM,,'N',,,20);
      _action:="exec('info_zam','magazyn_stan',5,M.ref())";
      M.win_act(_wins.WERCM,,'Formuła','Szcz&egóły'@@,,,_action,,1,,,,'E');
      M.win_act(_wins.WERCM,,'Kolejność');
      TCHMAT.grp_sel(_grp,M,_wins.WERCM,'Materiały'@,,,,,,,,,'maximized');
      _wins.WERCG:=TTG.mk_sel('Grupy technologiczne'@,'P',0,'ttechgr_wer',,,,,'U');
      TTG.win_fld(_wins.WERCG,,'GR',,,10);
      TTG.win_fld(_wins.WERCG,,'OPIS',,,20);
      {? (exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRTS') |
          exec('chk_role','#b__box',OPERATOR.USER,'TTE_WTE_DRTS') |
          exec('chk_role','#b__box',OPERATOR.USER,'TTE_PZL_DTEC'))
      || TTG.win_act(_wins.WERCG,0,'Dołącz');
         TTG.win_act(_wins.WERCG,1,'Dołącz');
         TTG.win_act(_wins.WERCG,,'Popraw');
         TTG.win_act(_wins.WERCG,,'Formuła','Usuń'@@,,,"exec('ttg_usun','tech_mater')",,,,,,'U')
      ?};
      TTG.win_act(_wins.WERCG,,'Formuła','P&ozycje'@@,,,"exec('ttg_pos','tech_mater')",,1,,,,'O');
      TTG.win_act(_wins.WERCG,,'Szukaj');
      TTG.win_act(_wins.WERCG,,'Kolejność');
      TTG.win_act(_wins.WERCG,,'Rekord',,,,,"exec('ttg_arec','tech_mater')");
      TCHMAT.grp_sel(_grp,TTG,_wins.WERCG,'Grupy technologicze'@,,,,,,,,,'maximized')
   ?};
   TCHMAT.win_sel(_grp)
||
   TCHMAT.win_sel(_wer)
?};

_keys:=':';
:: Ukrycie akcji wynikające z kontekstu programu
{? _used | _arc | ~_act | TKTL.STAN='N' & TKTL.TORW<>'Z' | TKTL.STAN='P' & TKTL.STAT_S='T' || _keys:='dpU'+_keys+'d' ?};
{? exec('is_k_res','tech_head',VAR.A_TPKTL) | exec('is_t_res','tech_head',VAR.A_TPKTL) || _keys:='R'+_keys+'' ?};
{? TKTL.TYP().PAR<>'T' || _keys:='R'+_keys ?};
{? ~(TKTL.STAN='T' & ~_arc & ~_used & _act) || _keys:='Ó'+_keys ?};
{? TKTL.STAN='T' & (TKTL.TORW='W' | TKTL.TORW='Z' | ~exec('can_modify','tech_common'))
|| _keys:='dpUÓ'+_keys+'d'
?};

TCHMAT.actions(_wer,_keys);
{? _used
|| TCHMAT.hdr_sel();
   TCHMAT.hdr_sel(' — '+'PODGLĄD'@)
|? TKTL.STAT_S='T'
|| TCHMAT.hdr_sel();
   TCHMAT.hdr_sel(' — '+'ZATWIERDZONE'@)
|? TKTL.ARCH='T'
|| TCHMAT.hdr_sel();
   TCHMAT.hdr_sel(' — '+'ARCHIWALNE'@)
?};
TCHMAT.win_edit('RED_'+VAR.A_KTL().TYP().PAR+exec('tch_edit_sufix','tech_mater'));
TCHMAT.clear();
TCHMAT.index('NSL');
TCHMAT.prefix(VAR.A_KTL,TMAT.ref());
TCHMAT.first();
VAR.P_NKTM:='';

:: Renumeracja i dołączanie rekordów za pomocą d'n'd
_dnd:=1;
{? ~(exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRTS') & TKTL.TORW='T' |
     exec('chk_role','#b__box',OPERATOR.USER,'TTE_WTE_DRTS') & TKTL.TORW='W' |
     exec('chk_role','#b__box',OPERATOR.USER,'TTE_PZL_DTEC') & TKTL.TORW='Z')
|| _dnd:=0
?};

{? ~_used & ~_arc & _act & TKTL.STAT_S='N' & _dnd>0
||
   TCHMAT.dnd_sel(_wer,,'records.TCHMAT',"
      TCHMAT.cntx_psh();
      _ref:=dnd_info('dest_record');
      {? TCHMAT.seek(_ref)
      || exec('zmien_lp','#dragdrop','LP','NSL')
      ?};
      TCHMAT.cntx_pop()
   ");

   TCHMAT.dnd_sel(_wer,,'records.TTG',"
      params_set(params_get());
      _records:=dnd_info('dropped_records');
      {? _records.size()>1
      || FUN.info('Dołączać można tylko pojedynczą pozycję.'@)
      || M.cntx_psh();
         {? exec('get','#params',500740,2)='N'
         || exec('filter_clear','material')
         || exec('filter','material','PS')
         ?};
         exec('TCATWERD','tech_mater');
         TCHMAT.blank();
         TCHMAT.GRKTM:='G';
         TTGP.clear();
         {? _records.first() & TTG.seek(_records.REF,)
         ||
            TCHMAT.TGRP:=TTG.ref();
            TTGP.index('GS');
            TTGP.prefix(TTG.first());
            {? TTGP.size()=1
            ||
               {? TTGP.first()
               || VAR.A_T:=TTGP.PT;
                  VAR1.KTM:=TTGP.PT().KTM;
                  TCHMAT.TGDFLT:=TTGP.ref()
               ?}
            ||
               VAR.A_T:=null();
               VAR1.KTM:=''
            ?};
            exec('TxMAT_PRZEL','tech_mater',TCHMAT,0,1);
            exec('TxMAT_UZYSK','tech_mater',TCHMAT);
            {? VAR.A_T().R='S' | M.R='H' || TCHMAT.DFLT_KTL:='N' ?};
            ATR.MJS:='TCHMAT';
            ATR.M_ATR:={? TCHMAT.PT<>null()
                       || TCHMAT.PT().M_ATR
                       |? TCHMAT.TGDFLT<>null()
                       || TCHMAT.TGDFLT().PT().M_ATR
                       || null()
                       ?};
            ATR.FLAG_ED:=ATR.CZY_ATR & ATR.M_ATR().EDIT;
            ATR.FLAG:={? ATR.FLAG_ED & ATR.M_ATR<>null() || 2 || 0 ?};
            {? ATR.FLAG_ED || {? ATR.M_ATR<>null() || ATR.FLAG_ED:=2 ?} ?};
            {? TCHMAT.DK_C<>null() & TCHMAT.DK_C().M_ATR<>null()
            || TCHMAT.DK_C().M_ATR().SYM;
               {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=($('TCHMAT.DK_C().WAR'+form(_i,-2,,'99')))() !}
            || ATR.M_ATR().SYM;
               {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !}
            ?};
            {! _i:=1..10
            |! _ch:=1+((_i-1)-TCHMAT.ATR_MASK);
               ($('ATR.ZL_WAR'+form(_i,-2,,'99')))():={? _ch='T' || 'T' || 'N' ?}
            !};

            exec('efld_opt','tech_mater',TCHMAT);
            {? TCHMAT.edit(\"params_exec('tchm_edt','tech_mater',TCHMAT)\")
            || {? TCHMAT.add()
               || exec('tchmattpar','tech_mater');
                  win_set('cur_row_pos=-1')
               ?}
            ?}
         ?};
         M.cntx_pop()
      ?}
  ");

  TCHMAT.dnd_sel(_wer,,'records.M',"
      params_set(params_get());
      _records:=dnd_info('dropped_records');
      {? _records.size()>1
      || FUN.info('Dołączać można tylko pojedynczą pozycję.'@)
      ||
         exec('TCATWERD','tech_mater');
         TCHMAT.blank();
         TCHMAT.GRKTM:='K';
         M.cntx_psh();
         M.prefix();
         {? _records.first() & M.seek(_records.REF,)
         ||
            params_get().env_mater.fields.MAT:=null();
            {? exec('sprktm','tech_mater',TCHMAT,M.ref())
            || _can_continue:=1;
               {? TMAT.GRKTM='G' || _tmpt:=TMAT.TGDFLT().PT || _tmpt:=TMAT.PT ?};
               {? M.ref()=_tmpt
               || {? ~FUN.ask('Indeks zamiennika jest taki sam jak indeks surowca.\nCzy kontynuujesz wprowadzanie danych?'@)
                  || _can_continue:=0
                  ?}
               ?};
               {? _can_continue
               || TCHMAT.PT:=M.ref();
                  VAR.A_T:=M.ref();
                  VAR1.KTM:=M.KTM;
                  exec('TxMAT_PRZEL','tech_mater',TCHMAT,0,1);
                  exec('TxMAT_UZYSK','tech_mater',TCHMAT);
                  {? VAR.A_T().R='S' | M.R='H' || TCHMAT.DFLT_KTL:='N' ?};
                  ATR.MJS:='TCHMAT';
                  ATR.M_ATR:={? TCHMAT.PT<>null()
                             || TCHMAT.PT().M_ATR
                             |? TCHMAT.TGDFLT<>null()
                             || TCHMAT.TGDFLT().PT().M_ATR
                             || null()
                             ?};
                  ATR.FLAG_ED:=ATR.CZY_ATR & ATR.M_ATR().EDIT;
                  ATR.FLAG:={? ATR.FLAG_ED & ATR.M_ATR<>null() || 2 || 0 ?};
                  {? ATR.FLAG_ED || {? ATR.M_ATR<>null() || ATR.FLAG_ED:=2 ?} ?};
                  {? TCHMAT.DK_C<>null() & TCHMAT.DK_C().M_ATR<>null()
                  || TCHMAT.DK_C().M_ATR().SYM;
                     {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=($('TCHMAT.DK_C().WAR'+form(_i,-2,,'99')))() !}
                  || ATR.M_ATR().SYM;
                     {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !}
                  ?};
                  {! _i:=1..10
                  |! _ch:=1+((_i-1)-TCHMAT.ATR_MASK);
                     ($('ATR.ZL_WAR'+form(_i,-2,,'99')))():={? _ch='T' || 'T' || 'N' ?}
                  !};

                  exec('efld_opt','tech_mater',TCHMAT);
                  {? TCHMAT.edit(\"params_exec('tchm_edt','tech_mater',TCHMAT)\")
                  || {? TCHMAT.add()
                     || exec('tchmattpar','tech_mater');
                        win_set('cur_row_pos=-1')
                     ?}
                  ?}
               ?}
            ?};
            VAR_DEL.delete('mat')
         ?};
         M.cntx_pop()
      ?}
  ")
||
   TCHMAT.dnd_sel(_wer,,'records.TCHMAT',"");
   TCHMAT.dnd_sel(_wer,,'records.TTG',"");
   TCHMAT.dnd_sel(_wer,,'records.M',"")
?};

TCHMAT.select();
TMAT.cntx_pop();
VAR.KOR:=0;
~~


\tch_edit_attr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Czy dostępne redagowanie cechy na zamiennikach (wersja rozwojowa)
::  OLD: \tch_edit_attr/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
0


\tch_edit_sufix
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Sufiks akronimu okna redakcyjnego zamienników surowca
::  OLD: \tch_edit_sufix/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('tch_edit_attr','tech_mater') || '' || 'N' ?}


\TCATWERD
::----------------------------------------------------------------------------------------------------------------------
::  MOD: TS [8.60]
:: OPIS: TCHMAT.WER przed dołącz
::   WY: 1
::  OLD: \TCATWERD/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.DJ:=TMAT.NRK().TYP().DJ;
VAR.A_T:=null();
VAR1.KTM:='';
ATR.MJS:='TCHMAT';
M.blank(1);
VAR.STRING:='';
params_get().env_mater.fields.MAT:=null();
ATR.FLAG_ED:=0;
ATR.FLAG:=0;
M_ATR.blank(0);
{! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=''; ($('ATR.ZL_WAR'+form(_i,-2,,'99')))():='N' !};
ATR.FLAG:=0;
TCHMAT.GRKTM:=exec('get_tmat_grktm','tech_mater');
exec('efld_opt','tech_mater',TCHMAT);
{? VAR.A_KTL().STAN<>'T'
|| VAR.KOR:=0;
   TCHMAT.hdr_edit();
   params_get().env_mater.buffer_tchmat.blank()
|| VAR.KOR:=1;
   TCHMAT.CAUSE:=exec('ttxcause_default','tech_common');
   TCHMAT.hdr_edit(' — '+'MODYFIKACJA ZATWIERDZONEJ KARTY'@);
   params_get().env_mater.buffer_tchmat.get()
?};
:: Ustawiam zmienną do blankowania pola TCHMAT.MODE_DST - na zamienniku dziedziczę zawsze z materiału
VAR1.MODE_DST:=TMAT.MODE_DST;
1


\tmat_cause_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Blank pola TCHMAT.CAUSE
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? VAR.KOR || exec('ttxcause_default','tech_common') || null() ?}


\tmat_szukaj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Szukanie w tabeli TMAT
::   WE: _a - 0 - szukanie dokładne
::          - 1 - szukanie kontekstowe
::          - 2 - ponowienie szukania
::  OLD: \tmat_szukaj/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? _a=2 || exec('tmat_szuk_next','tech_mater'); return() ?};
{? var_pres('__TM_TAB') > 0 || obj_del(__TM_TAB) ?};
:VAR.SZUK_KTM:=TMAT.PT().KTM;
:VAR.SZUK_NAZ:=TMAT.PT().N;
_red:=VAR.mk_edit('Wzorzec wyszukiwania'@,0,'tmatszukaj');
VAR.win_esep(_red,'Surowiec'@);
VAR.win_efld(_red,,'SZUK_KTM',,,50,,,'Indeks'@);
VAR.win_efld(_red,,'SZUK_NAZ',,,50,,,'Nazwa'@);
VAR.win_ebtn(_red,'text=%1,btn_label_align=center,panel=bottom,align=end'['Szukaj'@],"'key:F2'");
VAR.win_ebtn(_red,'text=%1,btn_label_align=center,panel=bottom,align=end'['Anuluj'@],"'key:Esc'");
VAR.win_edit(_red);
{? VAR.edit()
|| _prefix:={? _a || '%' || '' ?};
   _sufix:='%';
   _ktm:=_prefix+VAR.SZUK_KTM+_sufix;
   _naz:=_prefix+VAR.SZUK_NAZ+_sufix;
   __TM_TAB:=sql('
      select
         TMAT.REFERENCE as REF,
         M.KTM as KTM,
         M.N as N,
         TMAT.LP as LP
      from TMAT
         join M
      where
         M.KTM like \':_a\'
         and M.N like \':_b\'
         and TMAT.NRK=:_c

      union all

      select
         TMAT.REFERENCE as REF,
         M.KTM as KTM,
         M.N as N,
         TMAT.LP as LP
      from TMAT
         join TTGP
         join M using(TTGP.PT,M.REFERENCE)
      where
         M.KTM like \':_a\'
         and M.N like \':_b\'
         and TMAT.NRK=:_c

      order by LP
   ',_ktm,_naz,TMAT.NRK);

   {? __TM_TAB.first()
   || TMAT.seek(__TM_TAB.REF)
   || FUN.info('Brak rekordów spełniających kryterium wyszukiwania.'@)
   ?}
?};
~~


\tmat_szuk_next
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Ponowienie szukania w tabeli TMAT
::   WE: bieżący kontekst tabeli tymczasowej __TM_TAB
::  OLD: \tmat_szuk_next/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__TM_TAB')<=0 || return() ?};
{? __TM_TAB.next()
|| TMAT.seek(__TM_TAB.REF)
|| FUN.info('Nie ma więcej rekordów spełniających kryterium wyszukiwania.'@)
?};
~~


\tchm_rec
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed wyświetleniem wiersza w okienkach selekcji
::   WE: _a - MUSI BYĆ albo TMAT albo TCHMAT ('TMAT' albo 'TCHMAT')
::   WY: '' lub kod miejsca kolorowania
::----------------------------------------------------------------------------------------------------------------------
{? type_of(_a)=type_of('')
|| _tab:=($_a)(); _acr:=_a
|| _tab:=_a;
   {? _a=TMAT
   || _acr:='TMAT'
   |? _a=TCHMAT
   || _acr:='TCHMAT'
   || _acr:=''
   ?}
?};

{? var_pres('__ZLIM2ZAM')>0 & __ZLIM2ZAM=2 & _tab=TCHMAT
|| VAR.A_T()
|? (_tab=TMAT) | (_tab=TCHMAT)
|| {? _tab.GRKTM='K'
   || VAR.A_T:=_tab.PT;
      VAR1.KTM:=_tab.PT().KTM
   || _tab.TGRP;
      VAR.A_T:=_tab.TGDFLT().PT;
      VAR1.KTM:=_tab.TGDFLT().PT().KTM
   ?};
::   {? _tab=TMAT || VAR.A_PFAZ:=_tab.PFAZ ?};
   {? 1+cur_kwin()='s' & cur_tab(1,1)=_tab
   || _grayed:={? _tab=TMAT & VAR.A_TORW='Z' & TMAT.SRC='' || 'N' || '' ?}+
         {? _tab.ACT='T' || 'Ó' || {? _tab=TMAT & _tab.sel_size()>0 || 'U' || 'UP' ?} ?};
      _tab.actions_grayed(cur_win(1,1),_grayed)
   ?};
   VAR.A_T().KTM;
   _unrop:=exec('FindAndGet','#table',TOPER,TMAT.NROP,,"UNROP",0);
   _nrop:=exec('get_oper_nr','tech_oper',_unrop,'\\','n');
   VAR.STRING:=VAR1.TOPER:=_nrop;
   {? _tab.ACT='N'
   || _acr+'#01#02'
   |? _tab.RKTL<>''
   || _acr+'#01#01'
   |? _tab.DFLT_KTL='T'
   || _acr+'#01#03'
   || ''
   ?}
||
   ''
?}


\test4loop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Sprawdza, czy dana pozycja nie powoduje 'zapętlenia' składowych
::   WE: _a - M.ref() składowej
::       _b - TKTL.ref() karty kompletacyjnej
::   WY: 0 (powoduje zapętlenie) / 1 (nie powoduje zapętlenia, czyli ok)
::  OLD: \test4loop/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
TKTL.cntx_psh();
TMAT.cntx_psh();

TKTL.clear();
{? TKTL.seek(_b)
|| {? _a=TKTL.KTM
   || TKTL.cntx_pop();
      TMAT.cntx_pop();
      return(0)
   ?};

   _tpktl:=exec('ref_k_res','tech_head');

   _tmat_ndx:=TMAT.ndx_tmp(,,'NRK','TYP',,'PT',,);
   TMAT.index(_tmat_ndx);

   TMAT.prefix(_tpktl,TKTL.KTM);
   {? TMAT.first()
   || {!
      |?
         {? ~exec('test4loop','tech_mater',_a,TMAT.NRK) || TMAT.ndx_drop(_tmat_ndx); TMAT.cntx_pop(); TKTL.cntx_pop(); return(0) ?};

         TMAT.next()
      !}
   ?};
   TMAT.ndx_drop(_tmat_ndx)
?};

TMAT.cntx_pop();
TKTL.cntx_pop();

1


\test4depend
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Sprawdza, czy dana pozycja nie powoduje 'zapętlenia' surowców.
::   WE: _a - M.ref() surowca
::       _b - TKTL.ref() karty półfabrykatowej
::       _c - TKTL.ref() poszukiwanej karty produktu.
::   WY: 0 (powoduje zapętlenie) / 1 (nie powoduje zapętlenia, czyli ok)
::  OLD: \test4depend/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
TKTL.cntx_psh();
TMAT.cntx_psh();
TCHMAT.cntx_psh();
_res:=1;

TKTL.clear();
{? TKTL.seek(_b)
||
:: znajdź surowce
   TMAT.index('NL');
   TMAT.prefix(TKTL.ref());
   {? TMAT.first()
   || {!
:: tylko półfabrykaty
      |? {? TMAT.KTL<>null
:: jak natrafisz na modyfikowaną technologię i produkt, to na pewno spotkasz zapętlający surowiec
         || {? TMAT.KTL=_c
            || _res:=0
            || _res:=exec('test4depend','tech_mater',_a,TMAT.KTL,_c)
            ?}
         ?};
         TMAT.next() & _res
      !}
   ?};
   {? _res
   || TCHMAT.index('NSL');
      TCHMAT.prefix(TKTL.ref());
      {? TCHMAT.first()
      || {!
:: tylko półfabrykaty
         |? {? TCHMAT.KTL<>null
:: jak natrafisz na modyfikowaną technologię i produkt, to na pewno spotkasz zapętlający surowiec
            || {? TCHMAT.KTL=_c
               || _res:=0
               || _res:=exec('test4depend','tech_mater',_a,TCHMAT.KTL,_c)
               ?}
            ?};
            TCHMAT.next() & _res
         !}
      ?}
   ?}
?};

TMAT.cntx_pop();
TCHMAT.cntx_pop();
TKTL.cntx_pop();
_res


\tmat_display
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Wyświetla okno informacyjne w TMAT
::   WE: [_a] - czy dodawać panel z nagłówkiem karty technologicznej/wzorca (0/1)
::  OLD: \tmat_display/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? TMAT.DK_C<>null() & 1+((8+$TMAT.DK_C)+3)<>ST.ODDZ_KOD
|| FUN.info(
      'Nie można wyświetlić surowca.\n\n'
      'Surowiec z atrybutem powiązanym z oddziałem \'%1\'.\n'
      'Aktualnie ustawiony jest oddział \'%2\'.'
      ''@[1+((8+$TMAT.DK_C)+3),ST.ODDZ_KOD]);
   return()
?};

{? var_pres('_a')=type_of(0) || _display_head:=_a || _display_head:=0 ?};

::===
:: Fragment analogiczny jak w obsłudze 'przed rekord', żeby display mogło działać niezależnie od selekcji
{? TMAT.GRKTM='K'
|| VAR.A_T:=TMAT.PT;
   VAR1.KTM:=TMAT.PT().KTM
|| TMAT.TGRP;
   VAR.A_T:=TMAT.TGDFLT().PT;
   VAR1.KTM:=TMAT.TGDFLT().PT().KTM
?};
VAR.A_T().KTM;
_unrop:=exec('FindAndGet','#table',TOPER,TMAT.NROP,,"UNROP",0);
_nrop:=exec('get_oper_nr','tech_oper',_unrop,'\\','n');
VAR.STRING:=VAR1.TOPER:=_nrop;
::===

_atrm_atr:=ATR.M_ATR;
ATR.M_ATR:=TMAT.DK_C().M_ATR;
ATR.MJS:='TMAT';

ATR.SYMDK_C:='';
DK_C.cntx_psh();
{? TMAT.DK_C<>null() & ref_name(TMAT.DK_C)<>DK_C.name() || DK_C.use(ref_name(TMAT.DK_C)) ?};
:: Czyszczę wartości w DK_C
DK_C.clear();
DK_C.blank();

:: Czyszczę wartości w ATR
_buf_atr:=exec('buffer','mat_atr');
_buf_atr.set_atr();

_atrmjs:=ATR.MJS;
ATR.MJS:='TMAT';

_atryb:=exec('czytadkc','mat_atr',TMAT.DK_C,TMAT.RDKC);

:: Ustawiam bufor dziedziczenia atrybutów
_buffer:=exec('atr_mask_buffer','tech_mater');
_buffer.from_msk(TMAT.ATR_MASK);

:: Ustawiam zmienne potrzebne gdyby karta na półfabrykat była w archiwum
{? TMAT.RKTL<>''
|| exec('display_vars','tech_common',TMAT.RKTL)
?};

ATR.cntx_psh();
:: Sprawdzam czy surowiec ma atrybuty lub czy maska dziedziczenia atrybutów zawiera coś
:: Jest możliwe że surowiec nie ma DK_C, ale dziedziczy coś z produktu, wtedy okno inne trzeba pokazać
{? _atryb>0 | TMAT.ATR_MASK*'T'>0
||
:: Podczytuje M_ATR
   {? TMAT.TGDFLT<>null()
   || TMAT.TGDFLT().PT().M_ATR()
   || TMAT.PT().M_ATR()
   ?};

   _buffer.set_atr();
   ~~
?};
:: Wyświetlam okno
exec('efld_opt','tech_mater',TMAT);

{? _display_head
|| _par:=TMAT.NRK().TYP().PAR;
   _red:=TMAT.mk_edit('Surowiec technologiczny'@,,'grpdsp'+(-_par));
   TMAT.win_etab(_red,'Dane podstawowe'@);
   TMAT.win_ewin(_red,,'REDG_'+_par);
   TMAT.win_etab(_red,'Dane dodatkowe'@);
   TMAT.win_ewin(_red,,'ADDITION');
   TMAT.win_etab(_red,'Informacje o materiale'@);
   TMAT.win_ewin(_red,,'MATERIAL');
   TMAT.win_etab(_red,'Karta technologiczna'@);
   TMAT.win_ewin(_red,TKTL,'DISP');
   TMAT.win_edit(_red);
   TMAT.display()
|| TMAT.display()
?};
ATR.cntx_pop();

ATR.M_ATR:=_atrm_atr;
DK_C.cntx_pop();
ATR.MJS:=_atrmjs;
~~


\tchmat_display
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Akcja na wyświetl w oknach wertowania tabeli TCHMAT
::  OLD: \tchmat_display/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? TCHMAT.DK_C<>null() & 1+((8+$TCHMAT.DK_C)+3)<>ST.ODDZ_KOD
|| FUN.info(
      'Nie można wyświetlić zamiennika.\n\n'
      'Zamiennik z atrybutem powiązanym z oddziałem \'%1\'.\n'
      'Aktualnie ustawiony jest oddział \'%2\'.'
      ''@[1+((8+$TCHMAT.DK_C)+3),ST.ODDZ_KOD]);
   return()
?};

::===
:: Fragment analogiczny jak w obsłudze 'przed rekord', żeby display mogło działać niezależnie od selekcji
{? TCHMAT.GRKTM='K'
|| VAR.A_T:=TCHMAT.PT;
   VAR1.KTM:=TCHMAT.PT().KTM
|| TCHMAT.TGRP;
   VAR.A_T:=TCHMAT.TGDFLT().PT;
   VAR1.KTM:=TCHMAT.TGDFLT().PT().KTM
?};
VAR.A_T().KTM;
_unrop:=exec('FindAndGet','#table',TOPER,TMAT.NROP,,"UNROP",0);
VAR.STRING:=exec('get_oper_nr','tech_oper',_unrop,'\\','n');

::===

_win_ed:=TCHMAT.win_edit('?');

::{? TKTL.TYP().PAR='T'
::|| TCHMAT.win_edit('DISP_T'+exec('tch_edit_sufix','tech_mater'))
::|| TCHMAT.win_edit('DISP_N'+exec('tch_edit_sufix','tech_mater'))
::?};

_atrmjs:=ATR.MJS;
ATR.MJS:='TCHMAT';
ATR.M_ATR:=($('TCHMAT.'+exec('acr2acr','mat_atr','M')+'().M_ATR'))();
exec('czytadkc','mat_atr',TCHMAT.DK_C,TCHMAT.RDKC);
_mask:=($(ATR.MJS+'.ATR_MASK'));
_mask():='';
{! _i:=1..10 |! _mask()+={? ($('ATR.ZL_WAR'+form(_i,-2,,'99')))()='T' || 'T' || 'N' ?} !};

{? TCHMAT.RKTL<>''
|| exec('display_vars','tech_common',TCHMAT.RKTL)
?};
exec('efld_opt','tech_mater',TCHMAT);
TCHMAT.display();
ATR.MJS:=_atrmjs;
TCHMAT.win_edit(_win_ed);
~~


\atr_mask_buffer
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Bufor maski dziedziczenia atrybutow na surowcach technologii
::   WY: obj_new()
::
::       ----- Pola -------
::       ZL_WAR01..ZL_WAR10 - wartość parametrów
::
::       ----- Metody -----
::       .blank() - inicjuje wartości pól ZL_WARxx
::       .get_atr() - pobiera wartości atrybutów ze zmiennej ATR
::       .set_atr() - ustawia wartości atrybutów do zmiennej ATR
::       .from_msk('TNTNTNTNTN') - pobiera wartości atrybutów z przekazanego stringa
::       .to_msk() - z ustawionych wartości tworzy stringa
::       .shdw_atr(M_ATR.ref) - z ustawionych wartości tworzy stringa, nakładając maskę dla wartości
::                              które nie muszą być wypełnione wg M_ATR
::                              (niepotrzebne wartości mają znak '-' w wynikowym stringu)
::----------------------------------------------------------------------------------------------------------------------
_buffer:=obj_new( 'NUM_MAX'
::                POLA
                  ,'ZL_WAR01'
                  ,'ZL_WAR02'
                  ,'ZL_WAR03'
                  ,'ZL_WAR04'
                  ,'ZL_WAR05'
                  ,'ZL_WAR06'
                  ,'ZL_WAR07'
                  ,'ZL_WAR08'
                  ,'ZL_WAR09'
                  ,'ZL_WAR10'

::                METODY
                  ,'blank'
                  ,'get_atr'
                  ,'set_atr'
                  ,'from_msk'
                  ,'to_msk'
                  ,'shdw_atr'
                );

_max:=10;

_buffer.blank:='';
{! _it:=1.._max
|! _fit:=form(_it,-2,0,'99');
   _buffer.blank+='.ZL_WAR'+_fit+':=\'\';\n'
!};
_buffer.blank:=$(_buffer.blank+'~~');

_buffer.get_atr:='';
{! _it:=1.._max
|! _fit:=form(_it,-2,0,'99');
   _buffer.get_atr+='.ZL_WAR'+_fit+':=ATR.ZL_WAR'+_fit+';\n'
!};
_buffer.get_atr:=$(_buffer.get_atr+'~~');

_buffer.set_atr:='';
{! _it:=1.._max
|! _fit:=form(_it,-2,0,'99');
   _buffer.set_atr+='ATR.ZL_WAR'+_fit+':=.ZL_WAR'+_fit+';\n'
!};
_buffer.set_atr:=$(_buffer.set_atr+'~~');

_buffer.from_msk:='';
_buffer.from_msk+='_field:=_a;\n';
{! _it:=1.._max
|! _fit:=form(_it,-2,0,'99');
   _fit2:=form(_it-1,-2,0,'99');
   _buffer.from_msk+='_val:=1+('+_fit2+'-_field);\n';
   _buffer.from_msk+='.ZL_WAR'+_fit+':=_val;\n'
!};
_buffer.from_msk:=$(_buffer.from_msk+'~~');

_buffer.to_msk:='';
_buffer.to_msk+='_result:=\'\';\n';
{! _it:=1.._max
|! _fit:=form(_it,-2,0,'99');
   _buffer.to_msk+='_result+=.ZL_WAR'+_fit+';\n'
!};
_buffer.to_msk:=$(_buffer.to_msk+'_result');

_buffer.shdw_atr:='M_ATR.cntx_psh(); M_ATR.clear();\n';
_buffer.shdw_atr+='_result:=\'\';\n';
_buffer.shdw_atr+='{? M_ATR.seek(_a)\n';
_buffer.shdw_atr+='||\n';
{! _it:=1.._max
|! _fit:=form(_it,-2,0,'99');
   _buffer.shdw_atr+='\t{? M_ATR.SL_'+_fit+'=null()\n';
   _buffer.shdw_atr+='\t|| _result+=\'-\'\n';
   _buffer.shdw_atr+='\t|| _result+=.ZL_WAR'+_fit+'\n';
   _buffer.shdw_atr+='\t?};\n';
   ~~
!};
_buffer.shdw_atr+='~~?};\n';
_buffer.shdw_atr+='M_ATR.cntx_pop();\n';
_buffer.shdw_atr:=$(_buffer.shdw_atr+'_result');

_buffer


\leg_tmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Legenda w oknie surowców technologii (tabela TMAT)
::  OLD: \leg_tmat/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','TMAT#01#','#TMAT#01')


\leg_tchmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Legenda w oknie zamienników surowców technologii (tabela TCHMAT)
::  OLD: \leg_tchmat/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','TCHMAT#01#')


\sprktm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2011]
:: OPIS: Sprawdza czy można uzyć materiału jako surowca (albo zamiennika) w karcie
::   WE: _a - TMAT, TCHMAT
::       _b - M.ref()
::      [_c] - czy wyświetlać komunikaty (domyślnie 1), czy ładować do KOMMa (0)
::              (dotyczy tylko wybranych komunikatów)
::      [_d] - INTEGER - 0/[1] - czy kontrolować rodzaj materiału
::   WY: 0 / 1
::  OLD: \sprktm/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
{? var_pres('_c')=type_of(0) || _display:=_c || _display:=1 ?};

_ctrl_rodz:=1;
{? var_pres('_d')=type_of(0)
|| _ctrl_rodz:=_d
?};

M.cntx_psh();
M.clear();
M.seek(_b);

{? _ctrl_rodz>0
|| {? exec('get','#params',500740,2)<>'N' & M.R<>'S' & M.R<>'P'
   || FUN.emsg('Wprowadzony materiał musi być surowcem lub półfabrykatem.'@);
      M.cntx_pop();
      return(0)
   ?}
?};

{? M.A='N'
|| {? _tab=TMAT & TMAT.win_edit('?')='REDS'
   || FUN.emsg('Wprowadzony materiał nie jest aktywny.\n\nPozycji nie można przypisać jako składowej.'@);
      M.cntx_pop();
      return(0)
   || FUN.info('Wprowadzony materiał nie jest aktywny.\n\nKarty nie będzie można zaakceptować.'@)
   ?}
?};
{? params_get().env_mater.fields.MAT<>M.ref() | (_tab=TMAT & params_get().env_mater.fields.TOPER<>TMAT.NROP)
||
   _mat:=M.ref();
   _add:={? params_get().env_mater.fields.MAT=null() || 1 || 0 ?};
   _ref:={? _add>0 || null() || _tab.ref() ?};
   M.cntx_psh();
:: Pierwsze obrót pętli sprawdza, czy do danej operacji jest przypisany dany surowiec
:: Drugi obrót sprawdza, czy ten sam surowiec nie jest jednocześnie surowcem do operacji i bez operacji
   {! _it:=1..2
   |! _tab.cntx_psh();
      _is_null:=0;
      {? _tab=TMAT
      || _tab.index('NNL');
         {? _it=1
         || _tab.prefix(TMAT.NRK,TMAT.NROP)
         || {? _tab.NROP=null()
            || _is_null:=1;
               _tab.prefix(TMAT.NRK)
            || _tab.prefix(TMAT.NRK,null())
            ?}
         ?}
      || _tab.index('SL');
         _tab.prefix(TCHMAT.SRC)
      ?};
      _is_it:=0;
      {? _tab.first()
      || {!
         |? {? (_tab.PT=_mat | _tab.TGDFLT().PT=_mat) & _tab.ref()<>_ref
            || {? _tab=TMAT & TMAT.win_edit('?')='REDS'
               || {? _it=1
                  || _msg:='Ten materiał występuje już na liście składowych.\n\n'
                           'Takie przypisanie nie jest możliwe do wykonania.'@
                  || {? _is_null>0
                     || _msg:='Ten materiał występuje już na liście składowych jako surowiec '
                              'przypisany do operacji.\n\n'@
                     || _msg:='Ten materiał występuje już na liście składowych jako surowiec '
                              'bez przypisanej operacji.\n\n'@
                     ?};
                     _msg+='Ten sam surowiec nie może występować jednocześnie jako surowiec z przypisaną operacją'
                           ' i surowiec bez przypisanej operacji.'@
                  ?};
                  FUN.emsg(_msg);
                  _tab.cntx_pop();
                  M.cntx_pop();
                  M.cntx_pop();
                  return(0)
               || {? _tab=TMAT
                  || {? _display
                     || {? _it=1
                        || _msg:={? _tab.GRKTM='G'
                                 || 'Ten materiał występuje już na liście surowców'
                                    ' jako domyślny element grupy technologicznej.'@
                                 || 'Ten materiał występuje już na liście surowców.'@
                                 ?}+
                                 {? TMAT.NROP<>null()
                                 || '\n'+'(operacja %1)'@[exec('get_oper_nr','tech_oper',TMAT.NROP().UNROP)]
                                 || ''
                                 ?}
                        || {? _is_null>0
                           || _msg:='Ten materiał występuje już na liście składowych jako surowiec '
                                    'przypisany do operacji.\n\n'@
                           || _msg:='Ten materiał występuje już na liście składowych jako surowiec '
                                    'bez przypisanej operacji.\n\n'@
                           ?};
                           _msg+='Ten sam surowiec nie może występować jednocześnie jako surowiec z przypisaną operacją'
                                 ' i surowiec bez przypisanej operacji.'@
                        ?};
                        FUN.info(_msg)
                     || _msg:='';
                        {? VAR.GRUPA='T'
                        || _msg:=exec('grp_mod_msg','tech_mater',0)
                        ?};
                        {? _it=1
                        || _msg+='Materiał %1 występuje już na liście surowców.'@[M.KTM]
                        || {? _is_null>0
                           || _msg+='Materiał %1 występuje już na liście surowców jako surowiec '
                                    'przypisany do operacji.\n\n'@[M.KTM]
                           || _msg+='Materiał %1 występuje już na liście surowców jako surowiec '
                                    'bez przypisanej operacji.\n\n'@[M.KTM]
                           ?}
                        ?};
                        KOMM.add(_msg,,,1)
                     ?};
                     _tab.cntx_pop();
                     M.cntx_pop();
                     M.cntx_pop();
                     return(0)
                  || {? ~FUN.ask(
                           {? _tab.GRKTM='G'
                           || 'Ten materiał występuje już na liście zamienników surowca'
                              ' jako domyślny element grupy technologicznej.\n\n'
                              'Czy chcesz wpisać taką pozycję?'@
                           || 'Ten materiał występuje już na liście zamienników surowca.\n\n'
                              'Czy chcesz wpisać taką pozycję?'@
                           ?}
                        )
                     || _tab.cntx_pop();
                        M.cntx_pop();
                        M.cntx_pop();
                        return(0)
                     || _mat:=null()
                     ?}
                  ?}
               ?}
            ?};
            _tab.next()
         !}
      ?};
      _tab.cntx_pop();
      {? _tab=TMAT
      || _it+=1
      ||
::       Wyjście z pętli
         _it:=2
      ?}
   !};
   M.cntx_pop()
?};

_tab.cntx_psh();
_res:=sql('
   select
      TKTL.KTM
   from TKTL
   where
      TKTL.REFERENCE=\':_a\'
      and TKTL.KTM=\':_b\'
   union all
   select
      TKTLW.KTM
   from TKTLW
   where
      TKTLW.TKTL=\':_a\'
      and TKTLW.KTM=\':_b\'
', $VAR.A_KTL, $M.ref());

{? type_of(_res)=type_of(~~)
|| exec('err_sql','#sql');
   _tab.cntx_pop();
   M.cntx_pop();
   return(0)
?};

_wynik:=
   {? _res.clear(); ~_res.first()
   || {? _tab=TMAT & TMAT.win_edit('?')='REDS'
      || {? exec('test4loop','tech_mater',M.ref(),VAR.A_KTL)
         || {? VAR.A_T<>M.ref() || _change:=1 || _change:=0 ?};
            exec('tchm_rec','tech_mater',_tab);
            1
         || _msg:='Indeks wprowadzonej składowej\n'
                  'jest taki sam jak indeks produktu (kompletu) wyższego poziomu.\n\n'
                  'Takie przypisanie nie jest możliwe do wykonania.'@;
            {? VAR.GRUPA='T'
            || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
            || FUN.emsg(_msg)
            ?};
            _change:=0;
            0
         ?}
      || {? exec('test4depend','tech_mater',M.ref(),_tab.KTL,_tab.NRK)
         || {? VAR.A_T<>M.ref() || _change:=1 || _change:=0 ?};
            exec('tchm_rec','tech_mater',_tab);
            1
         || _msg:='Indeks wprowadzonego surowca\n'
                  'jest taki sam jak indeks surowca wyższego poziomu.\n\n'
                  'Takie przypisanie nie jest możliwe do wykonania.'@;
            {? VAR.GRUPA='T'
            || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
            || FUN.emsg(_msg)
            ?};
            _change:=0;
            0
         ?}
      ?}
   || {? _tab=TMAT & TMAT.win_edit('?')='REDS'
      || FUN.emsg('Indeks wprowadzonej składowej\n'
            'jest taki sam jak indeks produktu (kompletu).\n\n'
            'Takie przypisanie nie jest możliwe do wykonania.'@
         );
         _change:=0;
         0
      ||
::       Komunikat wyłączony, obecnie można utworzyć kartę, której surowcem jest jej produkt
::         FUN.emsg('Indeks wprowadzonego surowca\n'
::            'jest taki sam jak indeks produktu karty technologicznej.\n\n'
::            'Takie przypisanie nie jest możliwe do wykonania.'@
::         );
         {? VAR.A_T<>M.ref() || _change:=1 || _change:=0 ?};
         1
      ?}
   ?};
_tab.cntx_pop();

{? _change & _tab.NRK().TYP().DJ<>'P'
|| {? _tab.DJM<>null()
   || MJM.cntx_psh();
      MJM.index('JM');
      MJM.prefix({? _tab.GRKTM='G' || _tab.TGDFLT().PT || _tab.PT ?},_tab.DJM);
      {? MJM.first()
      || _tab.DJM:=MJM.JM;
         _tab.PRZ:=MJM.PRZ
      || _tab.DJM:=null();
         _tab.PRZ:=0
      ?};
      MJM.cntx_pop()
   || MJM.cntx_psh();
      MJM.index('JM');
      MJM.prefix({? _tab.GRKTM='G' || _tab.TGDFLT().PT || _tab.PT ?});
      {? MJM.size=1
      || {? MJM.first()
         || _tab.DJM:=MJM.JM;
            _tab.PRZ:=MJM.PRZ
         ?}
      || _tab.DJM:=null();
         _tab.PRZ:=0
      ?};
      MJM.cntx_pop()
   ?}
?};
M.cntx_pop();
_wynik


\zl_war_bl
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Blank pól zmiennej ATR.ZL_WARxx
::  OLD: \zl_war_bl/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
'N'


\zl_war_bd
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Przed wyświetl pól zmiennej ATR.ZL_WARxx
::  OLD: \zl_war_bd/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_acr:='SL_'+(cur_afld+2);
{? ($('M_ATR.'+_acr))()=null
|| _result:=0
?};
_result


\zl_war_be
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Przed redakcją pól zmiennej ATR.ZL_WARxx
::  OLD: \zl_war_be/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_wyn:=0;
_field:=cur_afld();
{? ATR.FLAG | ATR.FLAG=2 | (ATR.FLAG=0 &($(ATR.MJS+'.'+exec('acr2acr','mat_atr')+'().M_ATR'))()<>null())
|| _acr:='SL_'+(_field+2);
   _wyn:=($('M_ATR.'+_acr))()<>null();

:: Zapamiętuję wartość przed redakcją
   _fld_num:=_field+2;
   _fml:='__before_war'+(_fld_num)+':=_a';
   _value:=($('ATR.ZL_WAR'+_fld_num))();
   ($_fml)(_value);
   ~~
?};
_wyn


\zl_war_ae
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.30]
:: OPIS: Po redakcji pól zmiennej ATR.ZL_WARxx
::  OLD: \zl_war_ae/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_fld_num:=cur_afld()+2;
_val_before:='';
{? var_pres('__before_war'+(_fld_num))=type_of('')
|| _val_before:=($('__before_war'+(_fld_num)))()
?};

{? ($('ATR.ZL_WAR'+_fld_num))()<>_val_before || ($('ATR.WAR'+_fld_num))():='' ?};
:: Zeruje wartosc atrybutu
::_rule_chk:=$('ATR.ZL_WAR'+_fld_num);
::_rule_set:=$('ATR.WAR'+_fld_num+':=\'\'');
::{? _rule_chk()='T'
::|| _rule_set()
::?};
_mask:=($(ATR.MJS+'.ATR_MASK'));
_mask():='';
{! _i:=1..10 |! _mask()+={? ($('ATR.ZL_WAR'+form(_i,-2,,'99')))()='T' || 'T' || 'N' ?} !};
win_disp();
~~


\tred_ktl_xx
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: wspólna treść
::  OLD: \tred_ktl_xx/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
TKTL.cntx_psh();
{? cur_tab(1,1)=TMAT | cur_tab(1,1)=TCHMAT
||
   _rktl:=cur_tab(1,1).RKTL;
   _ktl:=cur_tab(1,1).KTL;
   {? _rktl<>'' & _ktl=null()
   ||
      TKTL.use(form(8+_rktl));
      TKTL.clear();
      {? TKTL.seek(_rktl)
      || VAR.TRED_KTL:=TKTL.NRK;
         VAR.RED_WER:=TKTL.WER
      ?}
   || {? cur_tab(1,1).KTL<>null()
      ||
         _mask:=TKTL.name();
         _ref_msk:=ref_name(cur_tab(1,1).KTL);
         {? _mask<>_ref_msk
         || TKTL.use(_ref_msk)
         ?}
      ?};
      VAR.TRED_KTL:=cur_tab(1,1).KTL().NRK;
      VAR.RED_WER:=TKTL.WER
   ?}
|| {? cur_tab(1,1).KTL<>null()
   ||
      _mask:=TKTL.name();
      _ref_msk:=ref_name(cur_tab(1,1).KTL);
      {? _mask<>_ref_msk
      || TKTL.use(_ref_msk)
      ?}
   ?};
   VAR.TRED_KTL:=cur_tab(1,1).KTL().NRK;
   VAR.RED_WER:=TKTL.WER
?};
TKTL.cntx_pop()


\tred_ktl_pw
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: przed wyświetl VAR.TRED_KTL
::  OLD: \tred_ktl_pw/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('tred_ktl_xx','tech_mater');
''


\tred_wer_pw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: przed wyświetl VAR.RED_WER
::  OLD: \tred_wer_pw/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? cur_tab(1,1)=TKTL || exec('tred_ktl_pw','tech_mater') || ~~ ?}


\tred_ktl_pr
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: przed redakcją VAR.TRED_KTL
::  OLD: \tred_ktl_pr/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? TKTL.STAT_S='N' | VAR.KOR
|| exec('tred_ktl_px','tech_mater')
|| 0
?}


\tred_ktl_px
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Wspólna część formuł przed redakcją i wyświetlaniem VAR.TRED_KTL
::  OLD: \tred_ktl_px/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
TKTLW.cntx_psh();
TKTLW.clear();
TKTLW.index('KARC');
TKTLW.prefix('T',VAR.A_T,'N');
{? TKTLW.first() & cur_tab(1,1).DFLT_KTL<>'T'
|| _res:=1
|| fld('');
   _res:=0
?};
TKTLW.cntx_pop();
_res


\tred_ktl_f3
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: na F3 dla VAR.TRED_KTL
::  OLD: \tred_ktl_f3/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
_stan:=TKTL.STAN;
_result:=VAR.TRED_KTL;

TKTL.cntx_psh();
TKTLW.cntx_psh();
TKTLW.index('KARC');
TKTLW.prefix();
::TKTLW.prefix('T',VAR.A_T,'N');
::TKTLW.find_key(VAR.TRED_KTL,VAR.RED_WER);
TKTLW.f_set(,'join TKTL using (TKTLW.TKTL,TKTL.REFERENCE)'
            ,'
            TKTL.TORW=\'T\'
            and TKTLW.KTM=:_a
            and TKTL.ARCH=\'N\'
            and ((TKTL.TERM_OD<=to_date(:_b) and TKTL.TERM_OD IS NOT NULL)
            or TKTL.TERM_OD IS NULL)
            and ((TKTL.TERM_DO>=to_date(:_b) and TKTL.TERM_DO IS NOT NULL)
            or TKTL.TERM_DO IS NULL)
            '
            ,VAR.A_T,date());
TKTLW.f_find('T',VAR.A_T,'N',VAR.TRED_KTL,VAR.RED_WER);
TKTLW.win_sel('WER_P');
{? TKTLW.select(,1,10)
|| {? _stan='T'
   || {? TKTLW.TKTL().STAN<>'T'
      || FUN.emsg('Wskazana technologia półfabrykatu nie jest zatwierdzona.'@);
         _result:=0
      || cur_tab(1,1).KTL:=TKTLW.TKTL;
         exec('tred_ktl_xx','tech_mater');
         _result:=VAR.TRED_KTL
      ?}
   || {? TKTLW.TKTL().STAN<>'T'
      || FUN.info('Wskazana technologia półfabrykatu nie jest zatwierdzona.'@)
      ?};
      cur_tab(1,1).KTL:=TKTLW.TKTL;
      exec('tred_ktl_xx','tech_mater');
      _result:=VAR.TRED_KTL
   ?}
?};
TKTLW.f_clear();
TKTL.cntx_pop();
TKTLW.cntx_pop();
_result


\tred_ktl_po
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: po redakcji VAR.TRED_KTL
::       Kontekst wywołania - bufor tabeli TMAT albo TCHMAT
::  OLD: \tred_ktl_po/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
TKTL.cntx_psh();
TKTLW.cntx_psh();

_tab:=cur_tab(1,1);
_par:=_tab.NRK().TYP().PAR;
_xjm:=_tab.NRK().XJM;
_tktl:=_tab.KTL().NRK;
_stan:=_tab.NRK().STAN;

_res:=0;
{? chk_fld(1)
||
   TKTLW.index('KARC');
   TKTLW.clear;
   TKTLW.f_set(,'join TKTL using (TKTLW.TKTL,TKTL.REFERENCE)'
            ,'
            TKTL.TORW=\'T\'
            and TKTLW.KTM=:_a
            and TKTL.ARCH=\'N\'
            and TKTL.NRK=\':_c\'
            and TKTL.WER=\':_d\'
            and ((TKTL.TERM_OD<=to_date(:_b) and TKTL.TERM_OD IS NOT NULL)
            or TKTL.TERM_OD IS NULL)
            and ((TKTL.TERM_DO>=to_date(:_b) and TKTL.TERM_DO IS NOT NULL)
            or TKTL.TERM_DO IS NULL)
            '
            ,VAR.A_T,date(),VAR.TRED_KTL,VAR.RED_WER);
   TKTLW.prefix();
::   TKTLW.prefix('T',VAR.A_T,'N',VAR.TRED_KTL,VAR.RED_WER);
   {? TKTLW.f_first()
   ||
      {? _stan='T' & TKTLW.TKTL().STAN<>'T'
      || FUN.emsg('Wskazana technologia półfabrykatu nie jest zatwierdzona.'@)
      |? TKTLW.TKTL().TYP().PAR=_par | TKTLW.TKTL().TYP().PAR='N'
      || _tab.KTL:=TKTLW.TKTL;
         _depend:=exec('test4depend','tech_mater',VAR.A_T,_tab.KTL,_tab.NRK);
         {? _depend
         || _res:=1
         || FUN.emsg('Technologia wprowadzonego surowca powoduje,\n'
               'że jest on taki sam jak surowiec wyższego poziomu.\n\n'
               'Takie przypisanie nie jest możliwe do wykonania.\n'
               'Należy wprowadzić inną technologię surowca, albo zmienić surowiec.'@)
         ?}
      || FUN.emsg({? _par='N'
                  || 'Technologia półfabrykatu musi być nieparametryzowana.'@
                  || 'Technologia półfabrykatu musi być parametryzowana.'@
                  ?})
      ?}
   || _wyb:=FUN.choice('Brak pozycji w słowniku.'@,1,'Powtórz'@,'Wyświetl &słownik'@);
      {? _wyb=0
      || VAR.TRED_KTL:=_tktl
      |? _wyb=2
      || exec('tred_ktl_f3','tech_mater');
         _res:=VAR.TRED_KTL
      ?}
   ?};
   TKTLW.f_clear()
|| _tab.KTL:=null();
   _tab.RKTL:='';
   VAR.RED_WER:='';
   _res:=1
?};
TKTL.cntx_pop();
TKTLW.cntx_pop();
win_disp();
_res


\get_tmat_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Zwraca ref aktualnego surowca
::   WY: TMAT.ref()
::  OLD: \get_tmat_ref/tex_tmat.ref
::----------------------------------------------------------------------------------------------------------------------
TMAT.ref()


\pw_k_nktm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.50]
:: OPIS: przed wyświetl pola VAR.K_NKTM w oknach TMAT, TCHMAT
::   WE: kontekst programu
::   WY: 1
::UWAGA: w tej formule następuje podczytanie bufora tabeli M, więc to pole musi być pierwsze w oknie
::----------------------------------------------------------------------------------------------------------------------
VAR.A_T();
VAR.K_NKTM:=M.KTM;
VAR.P_NKTM:=M.N;
1


\var1_ktm_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obsługa przed redagowaniem pola VAR1.KTM (w oknach redagowania TMAT, TCHMAT)
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);

_fields:=params_get().env_mater.fields;
_fields.PT:=_tab.PT;
_fields.TGDFLT:=_tab.TGDFLT;
_fields.KTL:=_tab.KTL;
1


\var1_ktm_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obsługa F3 dla pola VAR1.KTM (w oknach redagowania tabel TMAT, TCHMAT)
::   WY: wartość pola
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);

_t_wpm:=FILTER.T_WPM;
_r_prod:=ZAKR.R_PROD;
_r_komp:=ZAKR.R_KOMP;
_r_own:=ZAKR.R_OWN;
_rodz:=POMOC.RODZ;
_matu:=ZAKR.MATU;
_ktm:='';
{? _tab.GRKTM='G'
|| {? _tab.TGRP=null()
   || FUN.info('Należy wypełnić pole \'Grupa\'.')
   || TTGP.cntx_psh();
      TTGP.index('GS');
      TTGP.prefix(_tab.TGRP);
      TTGP.seek(_tab.TGDFLT);
      TTGP.win_sel('WER');
      TTGP.actions('WER','du:d','W');
      {? TTGP.select(,1,10)
      || _ktm:=TTGP.PT().KTM
      ?};
      TTGP.actions('WER');
      TTGP.cntx_pop()
   ?}
|| M.cntx_psh();
   {? cur_win(1,1)='REDS'
   ||
::    Okienko kompletacji (składowe w słowniku materiałów), inna obsługa parametru sterującym filtrowaniem
      {? exec('get','#params',500741,2)='N'
      || M.index('ARODZ');
         M.prefix('T','T',fld()); M.first(); M.prefix('T','T');
         FILTER.T_WPM:='';
         ZAKR.R_PROD:='';
         ZAKR.R_KOMP:='';
         POMOC.RODZ:='T';
         ZAKR.MATU:='A'
      |? exec('get','#params',500741,2)='T'
      || M.index('R_KOMP');
         M.prefix('T','T','T',fld()); M.first(); M.prefix('T','T','T');
         FILTER.T_WPM:='PS';
         ZAKR.R_PROD:='N';
         ZAKR.R_KOMP:='T';
         POMOC.RODZ:='T';
         ZAKR.MATU:='A'
      |? exec('get','#params',500741,2)='W'
      || M.index('R_OWN');
         M.prefix('T','T','T',fld()); M.first(); M.prefix('T','T','T');
         FILTER.T_WPM:='WPS';
         ZAKR.R_PROD:='';
         ZAKR.R_KOMP:='';
         ZAKR.R_OWN:='T';
         POMOC.RODZ:='T';
         ZAKR.MATU:='A'
      ?}
   ||
      {? exec('get','#params',500740,2)='N'
      || M.index('ARODZ');
         M.prefix('T','T',fld()); M.first(); M.prefix('T','T');
         FILTER.T_WPM:='';
         ZAKR.R_PROD:='';
         ZAKR.R_KOMP:='';
         POMOC.RODZ:='T';
         ZAKR.MATU:='A'
      || M.index('R_KOMP');
         M.prefix('T','T','T',fld()); M.first(); M.prefix('T','T','T');
         FILTER.T_WPM:='PS';
         ZAKR.R_PROD:='N';
         ZAKR.R_KOMP:='T';
         POMOC.RODZ:='T';
         ZAKR.MATU:='A'
      ?}
   ?};
   M.seek(_tab.PT);
   POMOC.M_ZAKR_T:='T';
   POMOC.M_ZAKR_U:='T';
   exec('slo_m_ok','material','T',(+form(ST.ODDZ))<>1,,{? cur_win(1,1)='REDS' || 'N(S)' || '' ?},'W');
   exec('wpm_opis','material');
   {? M.select(,1,10)
   || _ktm:=M.KTM
   ?};
   M.cntx_pop()
?};
FILTER.T_WPM:=_t_wpm;
ZAKR.R_PROD:=_r_prod;
ZAKR.R_KOMP:=_r_komp;
ZAKR.R_OWN:=_r_own;
POMOC.RODZ:=_rodz;
ZAKR.MATU:=_matu;
_ktm


\var1_ktm_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obsługa po redakcji pola VAR1.KTM (w oknach redagowania tabel TMAT, TCHMAT).
::       Formuła wykorzystywana również do walidacji podczas grupowego poprawnia surowców.
::   WE: [_a] - tabela, której dotyczy (TMAT/TCHMAT), jak nie podana to aktywna tabela
::       [_b] - miejsce wywołania: [0] - po redakcji pola, 1 - grupowe popraw (jako dodatkowa walidacja)
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_tab:={? var_pres('_a')=type_of(TMAT) || _a || cur_tab(1,1) ?};
_where:={? var_pres('_b')=type_of(0) || _b || 0 ?};

params_set(params_get());
_fields:=params_get().env_mater.fields;
{? _where=0
|| _fld:=fld();
   {? _fld=''
   || {? _tab.GRKTM='G'
      || _tab.TGDFLT:=null()
      || _tab.PT:=null()
      ?};
      VAR.A_T:=null()
   || {? _tab.GRKTM='G'
      || {? _tab.TGRP=null()
         || FUN.info('Należy wypełnić pole \'Grupa\'.'@)
         || TTGP.index('GS');
            TTGP.prefix(_tab.TGRP,_fld); TTGP.last();
            TTGP.blank(1);
            TTGP.SRC_:=_fld;
            {? TTGP.find_rec()
            || _tab.TGDFLT:=TTGP.ref();
               VAR.A_T:=_tab.TGDFLT().PT;
               VAR1.KTM:=VAR.A_T().KTM;
               {? _tab.TGDFLT<>_fields.TGDFLT
               || VAR.TRED_KTL:='';
                  VAR.RED_WER:='';
                  _tab.RKTL:='';
                  _tab.KTL:=null()
               ?}
            || _choice:=FUN.choice('Brak pozycji w słowniku.'@,1,'Powtórz'@,'Wyświetl &słownik'@);
               {? _choice=1
               || return(0)
               |? _choice=2
               || _ktm:=exec('var1_ktm_f3','tech_mater');
                  {? _ktm<>''
                  || VAR1.KTM:=_ktm;
                     exec('var1_ktm_ae','tech_mater')
                  ?}
               || _tab.TGDFLT:=_fields.TGDFLT;
                  VAR.A_T:=_tab.TGDFLT().PT;
                  VAR1.KTM:=VAR.A_T().KTM;
                  {? _tab.TGDFLT<>_fields.TGDFLT
                  || VAR.TRED_KTL:='';
                     VAR.RED_WER:='';
                     _tab.RKTL:='';
                     _tab.KTL:=null()
                  ?};
                  return(1)
               ?}
            ?}
         ?}
      || M.cntx_psh();
         M.index('ARODZ');
         M.prefix('N','T',_fld,);
         {? M.first()
         || FUN.info('Surowcem technologii może być tylko aktywny materiał.'@);
            M.cntx_pop();
            return(0)
         ?};
         {? cur_win(1,1)='REDS'
         ||
            {? exec('get','#params',500741,2)='N'
            || M.index('ARODZ');
               M.prefix('T','T',_fld)
            |? exec('get','#params',500741,2)='T'
            || M.index('R_KOMP');
               M.prefix('T','T','T',_fld)
            |? exec('get','#params',500741,2)='W'
            || M.index('R_OWN');
               M.prefix('T','T','T',_fld)
            ?}
         || {? exec('get','#params',500740,2)='N'
            || M.index('ARODZ');
               M.prefix('T','T',_fld)
            || M.index('R_KOMP');
               M.prefix('T','T','T',_fld)
            ?}
         ?};
         {? M.first()
         || _tab.PT:=M.ref();
            VAR.A_T:=_tab.PT;
            VAR1.KTM:=VAR.A_T().KTM;
            {? _tab.PT<>_fields.PT
            || VAR.TRED_KTL:='';
               VAR.RED_WER:='';
               _tab.RKTL:='';
               _tab.KTL:=null()
            ?}
         || _choice:=FUN.choice('Brak pozycji w słowniku.'@,1,'Powtórz'@,'Wyświetl &słownik'@);
            {? _choice=1
            || M.cntx_pop();
               return(0)
            |? _choice=2
            || _ktm:=exec('var1_ktm_f3','tech_mater');
               {? _ktm<>''
               || VAR1.KTM:=_ktm;
                  exec('var1_ktm_ae','tech_mater')
               ?}
            || _tab.PT:=_fields.PT;
               VAR.A_T:=_tab.PT;
               VAR1.KTM:=VAR.A_T().KTM;
               {? _tab.PT<>_fields.PT
               || VAR.TRED_KTL:='';
                  VAR.RED_WER:='';
                  _tab.RKTL:='';
                  _tab.KTL:=null()
               ?};
               M.cntx_pop();
               return(1)
            ?}
         ?};
         M.cntx_pop()
      ?}
   ?}
?};
{? _tab.GRKTM='G'
|| _res:=exec('aegdeflt','tech_mater',_tab)
|| {? _tab=TMAT
   || _ctrl_rodz:=1;
      {? cur_win(1,1)='REDS'
      || _ctrl_rodz:=0
      ?};
      _res:=exec('aektm_tma','tech_mater',_ctrl_rodz)
   || _res:=exec('aektm_tch','tech_mater')
   ?}
?};
exec('TxMAT_PRZEL','tech_mater',_tab,VAR.GRP_MOD<>'T',_fields.MAT<>VAR.A_T);
exec('TxMAT_UZYSK','tech_mater',_tab);
exec('efld_opt','tech_mater',_tab);
{? VAR.GRP_MOD<>'T'
|| win_disp()
?};
_res


\TMAT_kasuj
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: kasuje wszystkie surowce do karty
::   WE: TKTL.ref()
::  OLD: \TMAT/tkasuj.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
TMAT.cntx_psh();
TMAT.index('NNL');
TMAT.prefix(_tktl);
{? TMAT.first()
|| {!
   |? exec('usuntpar','tech_param');
      DocLib.del('TMAT',TMAT.ref());
      TMAT.del()
   !}
?};
TMAT.cntx_pop();
1


\can_TMAT_kasuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza możliwość usunięcia surowców karty
::   WE: TKTL.ref()
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

_result:=1;

TMAT.cntx_psh();
TMAT.index('NNL');
TMAT.prefix(_tktl);
{? TMAT.first()
|| {!
   |? ZL.cntx_psh(); TKTL.cntx_psh();
      ZL.index('TMAT_SRC');
      ZL.prefix(TMAT.NRK().ZL().UNRZL,TMAT.ref());
      {? ZL.first() || _result:=0 ?};
      ZL.cntx_pop(); TKTL.cntx_pop();
      _result=1 & TMAT.next()
   !}
?};
TMAT.cntx_pop();
_result


\TCHMAT_kasuj
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: kasuje wszystkie zamienniki wszystkich surowców do karty
::   WE: TKTL.ref()
::  OLD: \TCHMAT/tkasuj.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
TCHMAT.cntx_psh();
TCHMAT.index('NSL');
TCHMAT.prefix(_tktl);
{? TCHMAT.first()
|| {!
   |? exec('usuntchpar','tech_param');
      DocLib.del('TCHMAT',TCHMAT.ref());
      TCHMAT.del()
   !}
?};
TCHMAT.cntx_pop();
1


\valid_mat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Walidacja listy surowców
::   WE: _a - TKTL.ref()
::   WY: <>0 - ok
::       =0 - błędy
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
VAR.A_KTL:=_tktl;

{? _wyn:=exec('chk_fantom','tech_mater',_tktl,TMAT); _wyn<>''
|| FUN.emsg('Zatwierdzenie nie jest możliwe. %1 nie jest aktywnym materiałem.'@[_wyn]);
   _ok:=0
|? _wyn:=exec('chk_lim','tech_mater'); _wyn<>''
|| FUN.emsg('Zatwierdzenie nie jest możliwe. %1 występuje jako surowiec limitowny i nielimitowany.'@[_wyn]);
   _ok:=0
|? _wyn:=exec('chk_pow','tech_mater'); _wyn<>''
|| FUN.emsg('Zatwierdzenie nie jest możliwe. %1 występuje jako surowiec powierzony i własny.'@[_wyn]);
   _ok:=0
|? _wyn:=exec('chk_so','tech_mater'); _wyn<>''
|| FUN.emsg('Zatwierdzenie nie jest możliwe. %1 występuje jako surowiec i odpad/koprodukt.'@[_wyn]);
   _ok:=0
|? _wyn:=exec('chk_polsur','tech_mater',_tktl,TMAT); _wyn<>''
|| FUN.emsg('Zatwierdzenie nie jest możliwe. Półfabrykat %1 nie ma zatwierdzonej karty technologicznej.'@[_wyn]);
   _ok:=0
|? _wyn:=exec('chk_fantom','tech_mater',_tktl,TCHMAT); _wyn<>''
|| FUN.emsg('Zatwierdzenie nie jest możliwe. %1 nie jest aktywnym materiałem.'@[_wyn]);
   _ok:=0
|? _wyn:=exec('chk_polsur','tech_mater',_tktl,TCHMAT); _wyn<>''
|| FUN.emsg('Zatwierdzenie nie jest możliwe. Półfabrykat %1 nie ma zatwierdzonej karty technologicznej.'@[_wyn]);
   _ok:=0
|? exec('czy_xjmp','tech_mater',VAR.A_KTL().JM().KOD) & ((_il:=exec('sum_xjmp','tech_mater',_tktl)); (_il>0 & _il<>100))
|| {? FUN.ask('Aktualnie lista surowców definiuje %1\% składu procentowego produktu.\n'
              'Czy mimo to zakończyć rejestrację surowców dla całej karty technologicznej?'@[$_il])
   || _ok:=2
   || _ok:=0
   ?}
|| _ok:=1
?};

_ok


\chk_fantom
::----------------------------------------------------------------------------------------------------------------------
::  MOD: TS [8.60]
:: OPIS: Sprawdza czy surowce i zamienniki _a są aktywnymi materialami
::   WE: _a - TKTL.ref()
::       _b - alias tabeli (TMAT, TCHMAT)
::   WY: [STRING] miejsce wystąpienia lub pusty
::  OLD: \chk_fantom/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
_tab:=_b;
_wynik:='';

_tab.cntx_psh();
_tab.index({? _tab=TMAT || 'NL' || 'NSL' ?});
_tab.prefix(_tktl);
{? _tab.first()
|| {!
   |? VAR.A_T:={? _tab.GRKTM='K' || _tab.PT || _tab.TGDFLT().PT ?};
      {? VAR.A_T().A<>'T'
      || _wynik:={? _tab=TMAT
                 || exec('get_src_way','tech_mater',_tab.ref())
                 || exec('get_chm_way','tech_mater',_tab.ref())
                 ?}
      ?};
      _tab.next() & (_wynik='')
   !}
?};
_tab.cntx_pop();
_wynik


\chk_xxx
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.50]
:: OPIS: część wspólna formuł chk_*
::   WE: _a - _tab
::       _b, _c - porównywane stany pierwszej kolumny
::   WY: [STRING] miejsce wystąpienia lub pusty
::  OLD: \chk_xxx/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_tab.prefix(_b);
{? _tab.first()
|| {!
   |? _pt:=_tab.PT;
      _grp:=_tab.GRP;
      _tab.cntx_psh();
      _tab.prefix(_c,_grp,_pt);
      {? _tab.first()
      || {? _grp<>''
         || TTG.clear();
            {? TTG.seek(_grp)
            || _tab.cntx_pop();
               return('Grupa: %1'@[TTG.GR])
            ?}
         |? _pt<>''
         || M.clear();
            {? M.seek(_pt)
            || _tab.cntx_pop();
               return('Materiał: %1'@[M.KTM])
            ?}
         ?}
      ?};
      _tab.cntx_pop();
      _tab.next()
   !}
?};
''


\chk_lim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.50]
:: OPIS: sprawdza, czy wystąpi ten sam surowiec jako limitowany i nielimitowany
::       KONTEKST: VAR.A_KTL
::   WY: [STRING] miejsce wystąpienia lub pusty
::  OLD: \chk_lim/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=sql('
   select
      TMAT.LIMIT as LIM,
      TMAT.TGRP as GRP,
      TMAT.PT as PT
   from TMAT
   where TMAT.NRK=:_a
      and TMAT.ACT=\'T\'
   order by LIM, GRP, PT
',VAR.A_KTL);

{? type_of(_tab)=type_of(~~) || exec('err_sql','#sql'); return('') ?};

exec('chk_xxx','tech_mater',_tab,'T','N')


\chk_pow
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.50]
:: OPIS: sprawdza, czy wystąpi ten sam surowiec jako powierzony i własny
::       KONTEKST: VAR.A_KTL
::   WY: [STRING] miejsce wystąpienia lub pusty
::  OLD: \chk_pow/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=sql('
   select
      TMAT.POW as POW,
      TMAT.TGRP as GRP,
      TMAT.PT as PT
   from TMAT
      where TMAT.NRK=:_a
      and TMAT.ACT=\'T\'
   union all
   select
      TCHMAT.POW as POW,
      TCHMAT.TGRP as GRP,
      TCHMAT.PT as PT
   from TCHMAT
   where TCHMAT.NRK=:_a
      and TCHMAT.ACT=\'T\'
   order by POW, GRP, PT
',VAR.A_KTL);

{? type_of(_tab)=type_of(~~) || exec('err_sql','#sql'); return('') ?};

exec('chk_xxx','tech_mater',_tab,'T','N')


\chk_so
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.50]
:: OPIS: sprawdza, czy wystąpi ten sam surowiec jako surowiec i odpad
::       KONTEKST: VAR.A_KTL
::   WY: [STRING] miejsce wystąpienia lub pusty
::  OLD: \chk_so/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=sql('
   select
      TMAT.SO as SO,
      TMAT.TGRP as GRP,
      TMAT.PT as PT
   from TMAT
   where TMAT.NRK=:_a
      and TMAT.ACT=\'T\'
   order by SO, GRP, PT
',VAR.A_KTL);

{? type_of(_tab)=type_of(~~) || exec('err_sql','#sql'); return('') ?};

exec('chk_xxx','tech_mater',_tab,'S','O')


\chk_polsur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Sprawdza, czy półfabrykaty mają zatwierdzone karty technologiczne
::   WE: _a - TKTL.ref()
::       _b - TMAT, TCHMAT (tabela)
::   WY: [STRING] miejsce wystąpienia lub pusty
::  OLD: \chk_polsur/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
_tab:=_b;

_wynik:='';
TKTL.cntx_psh(); _tab.cntx_psh();
_tab.clear();
_tab.index({? _tab=TMAT || 'NL' || 'NSL' ?});
_tab.prefix(_tktl);
{? _tab.first()
|| {!
   |? {? _tab.KTL<>null()
      || TKTL.use(ref_name(_tab.KTL));
         {? _tab.KTL().STAN<>'T'
         || _wynik:={? _tab.GRKTM='G' || _tab.TGDFLT().PT().KTM || _tab.PT().KTM ?}
         ?}
      ?};
      _tab.next() & (_wynik='')
   !}
?};
TKTL.cntx_pop(); _tab.cntx_pop();
_wynik


\get_src_way
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: podaje ścieżkę do surowca w karcie
::   WE: _a - TMAT.ref()
::   WY: scieżka do surowca [STRING]
::  OLD: \get_src_way/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tmat:=_a;
_way:='';
TMAT.cntx_psh(); TOPER.cntx_psh();
TMAT.prefix();
{? TMAT.seek(_tmat)
|| _way:=_way+{? TMAT.NROP<>null() || 'Operacja: %1 -> (Parametry)'@[exec('get_oper_nr','tech_oper',TMAT.NROP().UNROP)]+' ' ?};
   _way:=_way+'Surowiec: %1 %2'@[$TMAT.LP,TMAT.PT().KTM]
?};
TMAT.cntx_pop(); TOPER.cntx_pop();
_way


\get_chm_way
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: podaje ścieżkę do zamiennika surowca w karcie
::   WE: _a - TCHMAT.ref()
::   WY: scieżka do zamiennika w karcie [STRING]
::  OLD: \get_chm_way/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tchmat:=_a;
_way:='';
TCHMAT.cntx_psh();
TCHMAT.prefix();
{? TCHMAT.seek(_a)
|| _way:=_way+exec('get_src_way','tech_mater',TCHMAT.SRC)+' -> '+'Zamiennik: %1 %2'@[$TCHMAT.LP,TCHMAT.PT().KTM]
?};
TCHMAT.cntx_pop();
_way


\chk_polfabr_def
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy karta ma jakieś półfabrykaty z domyślną kartą technologiczną
::   WE: _a - TKTL.ref() - karta technologiczna
::       _b - TMAT lub TCHMAT - alias tabeli w której sprawdzać
::   WY: '' - brak półfabrykatu z domyślną kartą technologiczną
::       STRING - KTM pierwszego półfabrykatu z domyślną kartą technologiczną
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
_tab:=_b;

_wynik:='';
TKTL.cntx_psh();
_tab.clear();
_tab.index({? _tab=TMAT ||'NL' ||'NSL' ?});
_tab.prefix(_tktl);
{? _tab.first()
|| {!
   |? {? _tab.DFLT_KTL='T'
      || _ktm:='';
         {? _tab.GRKTM='G'
         || _ktm:=_tab.TGDFLT().PT().KTM
         || _ktm:=_tab.PT().KTM
         ?};
         _wynik:=_ktm
      ?};
      _b.next() & (_wynik='')
   !}
?};
TKTL.cntx_pop();
_wynik


\TMAT_trigger
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Triggery dla tabeli TMAT
::  OLD: \TMAT/trigger.fml
::----------------------------------------------------------------------------------------------------------------------
:: Aktualizacja pola KTM (odwołanie do powiązanego materiału)
{? TMAT.GRKTM='G'
|| TMAT.KTM:=exec('FindAndGet','#table',TTGP,TMAT.TGDFLT,,"PT",null())
|| TMAT.KTM:=TMAT.PT
?};
:: Aktualizacja refa technologii półfabrykatu
{? TMAT.KTL<>null()
|| TMAT.RKTL:=$TMAT.KTL
?};
1


\tmat_trig_add_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Trigger przed add dla tabeli TMAT
::----------------------------------------------------------------------------------------------------------------------
exec('TMAT_trigger','tech_mater')


\tmat_trig_put_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Trigger przed put dla tabeli TMAT
::----------------------------------------------------------------------------------------------------------------------
exec('TMAT_trigger','tech_mater')


\TCHMAT_trigger
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Triggery dla tabeli TCHMAT
::  OLD: \TCHMAT/trigger.fml
::----------------------------------------------------------------------------------------------------------------------
{? TCHMAT.KTL<>null()
|| TCHMAT.RKTL:=$TCHMAT.KTL
?};
1


\tchmat_trig_add_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Trigger przed add dla tabeli TCHMAT
::----------------------------------------------------------------------------------------------------------------------
exec('TCHMAT_trigger','tech_mater')


\tchmat_trig_put_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Trigger przed put dla tabeli TCHMAT
::----------------------------------------------------------------------------------------------------------------------
exec('TCHMAT_trigger','tech_mater')


\elgrup
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Wyświetla elementy grupy technologicznej
::  OLD: \elgrup/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? TMAT.GRKTM<>'G'
|| FUN.info('Surowiec nie jest przypisany do grupy.'@)
|| TMAT.cntx_psh();
   TTGP.index('GRS');
   TTGP.prefix(TMAT.TGRP);
   TTGP.win_sel('WERG');
   TTGP.select();
   TMAT.cntx_pop()
?};
~~


\tmattpar
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Dołącz po w tabeli TMAT. Realizuje następujace funkcje:
::          1. Dołączenie tabeli translacji parametrów do bieżącego surowca
::          2. Ustawienie dodawanego rekordu na ostatniej pozycji w oknie
::          3. Generowanie podzlecenia jeśli został dołączony półfabrykat na technologii zlecenia
::  OLD: \tmattpar/tex_tpar.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

win_set('cur_row_pos=-1');
{? TMAT.KTL<>null() || exec('trpardol','tech_param') ?}


\tchmattpar
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Dołącz po w tabeli TCHMAT. Realizuje następujące funkcje:
::       1. Dołączenie tabeli translacji parametrów do bieżącego zamiennika surowca
::       2. Ustawienie dodawanego rekordu na ostatniej pozycji w oknie
::  OLD: \tchmattpar/tex_tpar.fml
::----------------------------------------------------------------------------------------------------------------------
win_set('cur_row_pos=-1');
{? TCHMAT.KTL<>null() || exec('tchpardol','tech_param') ?}


\tmat_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wyświetla szczegóły dla surowca karty technologicznej
::  OLD: \tmat_info/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('info_zam','magazyn_stan',5,{? TMAT.GRKTM='K' || TMAT.PT || TMAT.TGDFLT().PT ?});
~~


\tchmat_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wyświetla szczegóły dla zamiennika surowca karty technologicznej
::  OLD: \tchmat_info/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('info_zam','magazyn_stan',5,{? TCHMAT.GRKTM='K' || TCHMAT.PT || TCHMAT.TGDFLT().PT ?});
~~


::======================================================================================================================
:: Obsługa kartoteki TTG
::======================================================================================================================


\czyrzam
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed redakcją i przed wyświetleniem pola TTG.ZAMIENN
::  OLD: \czyrzam/polap.fml
::----------------------------------------------------------------------------------------------------------------------
_par:=exec('get','#params',500001,2);
_par='P'


\ttg_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Usunięcie zapisu TTG
::  OLD: \ttg_usun/slownik1.fml
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy usunąć bieżący wiersz?'@)
|| TTGP.clear();
   TTGP.index('GS');
   TTGP.prefix(TTG.ref());
   {? TTGP.first()
   || {!
      |? TTGP.del()
      !}
   ?};
   TTG.del()
?};
~~


\ttg_prt
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: drukowanie TTG
::  OLD: \ttg_prt/slownik1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('rep_exec','#b_report','TTE_TEC_XXXX','tte_ttg_*','Wydruki grup technologicznych',1);
~~


\ttg_arec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Rekord po dla TTG
::  OLD: \ttg_arec/slownik1.fml
::----------------------------------------------------------------------------------------------------------------------
__CHK.record(TTG,,'GR','OPIS')


\a_gr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Zwraca VAR.A_GR
::   WY: VAR.A_GR
::  OLD: \a_gr/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_GR


::======================================================================================================================
:: Obsługa kartoteki TTGP
::======================================================================================================================


\ttg_pos
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: pozycje grupy technologicznej
::  OLD: \ttg_pos/tech.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_GR:=TTG.ref();
TTGP.clear();
TTGP.index('GS');
TTGP.prefix(VAR.A_GR);
TTGP.first();
TTGP.win_sel('WER');
TTGP.actions('WER','W','E:d');
TTGP.select();
TTGP.actions('WER');
1


\be_ttgp_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Przed redakcją pola TTGP.PT
::   WY: 1
::  OLD: \be_ttgp_sur/ptowary.fml
::----------------------------------------------------------------------------------------------------------------------
exec('slo_m_ok','material','T',0,,'W');
exec('wpm_opis','material','PS');
1


\ae_ttgp_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Po redakcji pola TTGP.PT
::   WY: 0 / 1
::  OLD: \ae_ttgp_sur/ptowary.fml
::----------------------------------------------------------------------------------------------------------------------
{? chk_fld(1)
|| {? exec('get','#params',500740,2)='N' | M.R='S' | M.R='P'
   || TTGP.SRC_:=M.KTM;
      1
   || FUN.emsg('Pozycja grupy technologicznej może być tylko surowcem lub półfabrykatem.'@);
      0
   ?}
|| 0
?}


\ttgp_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Usunięcie zapisu TTGP
::  OLD: \ttgp_usun/ptowary.fml
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy usunąć bieżący wiersz?'@) || TTGP.del() ?};
~~


\show_ptowary
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: pokazuje dane rekordu M dla TTGP.PT
::  OLD: \show_ptowary/ptowary.fml
::----------------------------------------------------------------------------------------------------------------------
M.cntx_psh();
M.clear();
{? M.seek(TTGP.PT) || M.display() ?};
M.cntx_pop();
~~


\ttgp_brek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Przed rekord dla pozycji grupy technologicznej
::  OLD: \ttgp_brek/ptowary.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\ttgp_info
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wyświetla szczegóły dla pozycji grupy technologicznej
::  OLD: \ttgp_info/slownik1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('info_zam','magazyn_stan',5,TTGP.PT);
~~


::======================================================================================================================
:: Obsługa zamienników
::======================================================================================================================


\pokaz_zam_mech
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JM
:: OPIS: Pokazuje zamienniki materialu.
::   WE: _a: 0 - Obsluga zamiany surowca w karcie technologicznej zlecenia.
::               'TECHNOLOGIA_ZLECENIA'
::           1 - Obsluga zamiany surowca w karcie technologicznej zlecenia - funkcja kontroli ilosci
::               'KONTROLA_ILOŚCI'
::           2 - Wywolywane z poziomu surowcow pozycji analizy wykonania.
::               'ANALIZA_WYKONANIA'
::           3 - Wywolywane z poziomu: Technologia->Kalkulacje...->Porownanie->Zmieniony algorytm->Surowce->Zamienniki
::               'KALKULACJA_TECHNOLOGII'
::           4 - Wywolywane z poziomu: Zlecenia->Kalkulacje...->Porownanie->Zmieniony algorytm->Surowce->Zamienniki
::               'KALKULACJA_ZLECENIA'
::           6 - Dziala jak 3, ale z poziomu limitow zlecenia (jak limit z technologii zlecenia)
::               'LIMITY'
::           8 - Gdy wywolywane z poziomu korekt limitow podczas pobran
::               'DOKUMENT_MAGAZYNOWY'
::       _b: (nieistotne)
::       [_c]: 1 - nie wyswietla okna i nie usuwa __ZAMEL za to zwraca akronim okna selekcji
::       [_d]: 1 - dołączyć zakładkę z zamiennikiami materiałowymi, [0] - nie dodawać
::   WY: 0 / 1 - czy nastąpiła zamiana
::       dodatkowo gdy c=1, to zwracana (nie niszczona) zmienna __ZAMEL
::  OLD: \pokaz_zam_mech/tmp_obj.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

{? _a=0
|| _opcja:='TECHNOLOGIA_ZLECENIA'
|? _a=1
|| _opcja:='KONTROLA_ILOŚCI'
|? _a=2
|| _opcja:='ANALIZA_WYKONANIA'
|? _a=3
|| _opcja:='KALKULACJA_TECHNOLOGII'
|? _a=4
|| _opcja:='KALKULACJA_ZLECENIA'
|? _a=6
|| _opcja:='LIMITY'
|? _a=8
|| _opcja:='DOKUMENT_MAGAZYNOWY'
|| FUN.emsg('Błędna wartość parametru _a formuły pokaz_zam_mech/tmp_obj.'@);
   return()
?};
_czy_grp:={? var_pres('_d')=type_of(0) || _d || 0 ?};

_result:=0;

M.cntx_psh();

{? var_pres('_b')<>type_of(0) || _jest:=0 || _jest:=_b ?};
{? var_pres('_c')<>type_of(0) || _no_disp:=0 || _no_disp:=_c ?};

{? var_pres('__MASKI')<=0
|| __MASKI:=ZLIM.names();
   _maski:=1
|| _maski:=0
?};

_par:=exec('get','#params',500001,2);

VAR_DEL.delete('__ZAMEL');
__ZAMEL:=tab_tmp(2,
   'LP','INTEGER','Lp',
   'KOD','STRING[50]','Kod surowca',
   'NAZWA','STRING[100]','Nazwa surowca',
   'JM','STRING[10]','jm',
   'T','STRING[16]','$M.ref()',
   'ZE','STRING[1]','Zamiennik/element grupy technologicznej',
   'TMAT','STRING[16]','$TMAT.ref()',
   'TCHMAT','STRING[16]','$TCHMAT.ref()',
   'TTG','STRING[16]','$TTG.ref()',
   'GR','STRING[10]','TTG.GR',
   'TTGP','STRING[16]','$TTGP.ref()',
   'SRC','STRING[16]','$TMAT.ref() - pozycja źródłowa',
   'SRCTECH','STRING[1]','Czy element ze źródłowej technologii',
   'S','REAL','Stan',
   'SD','REAL','Stan dostępny',
   'SRT','REAL','Rezerwacje tymczasowe',
   'SRR','REAL','Rezerwacje do zamówień',
   'SSZ','REAL','Zamówienia',
   'WDR','REAL','W drodze',
   'DEL','STRING[1]','Do debugowania - oznaczenie usuwanego elementu',
   'TYP','STRING[1]','T - technologiczne, M - materiałowe',
   'IL','REAL','Ilość'
);
::__ZAMEL.fld_attr(,2);
__ZAMEL.fld_attr('S',3);
__ZAMEL.fld_attr('SD',3);
__ZAMEL.fld_attr('SRT',3);
__ZAMEL.fld_attr('SSZ',3);
__ZAMEL.fld_attr('WDR',3);
{? _a<>6
|| __ZAMEL.fld_attr('IL',2)
?};

_wer:=__ZAMEL.mk_sel('Dostępne surowce'@,,0,'zamech_wer',,10,23,,'U',,,,,'html_maximized');
__ZAMEL.win_fld(_wer,,'GR',,,10,,,'Grupa'@);
__ZAMEL.win_fld(_wer,,'KOD',,,20,,,'Indeks'@);
__ZAMEL.win_fld(_wer,,'NAZWA',,,40,,,'Nazwa'@);
__ZAMEL.win_fld(_wer,,'ZE',,,-3,,,'Zamiennik/element'@,,'Zamiennik/element grupy technologicznej'@);
__ZAMEL.win_fld(_wer,,'SD',,,15,ST.DOKL,,'Dostępne'@);
__ZAMEL.win_fld(_wer,,'JM',,,5,,,'jm'@);
__ZAMEL.win_fml(_wer,,'ZE',,'ICON_BEFORE',"
   {? __ZAMEL.ZE='Z'
   || 'xwin16.png:70'
   |? __ZAMEL.ZE='E'
   || 'xwin16.png:143'
   || ''
   ?}
");
__ZAMEL.fld_fml('ZE','DISPLAY_FORMAT',"'empty=1'");

:: Okno z zamiennikami materiałowymi
_wer2:=__ZAMEL.mk_sel('Dostępne surowce'@,,0,'zamech_wer2',,10,23,,'U');
__ZAMEL.win_fld(_wer2,,'KOD',,,20,,,'Indeks'@);
__ZAMEL.win_fld(_wer2,,'NAZWA',,,40,,,'Nazwa'@);
__ZAMEL.win_fld(_wer2,,'SD',,,15,ST.DOKL,,'Dostępne'@);
__ZAMEL.win_fld(_wer2,,'JM',,,5,,,'jm'@);

{? _czy_grp>0
||  _ndxtyp:=__ZAMEL.ndx_tmp(,1,'TYP',,,'LP',,,'KOD',,);
   __ZAMEL.index(_ndxtyp);
   _grp:=__ZAMEL.grp_make('Dostępne surowce'@,,'zamech_grp',,,,,'html_maximized');
   _fb:="
      __ZAMEL.prefix('T');
      __ZAMEL.first();
      ~~
   ";
   __ZAMEL.grp_sel(_grp,,_wer,'Zamienniki technologiczne'@,,,,,_fb,,,,'maximized','zamech_grpt');
   _fb:="
      __ZAMEL.prefix('M');
      __ZAMEL.first();
      ~~
   ";
   __ZAMEL.grp_sel(_grp,,_wer2,'Zamienniki materiałowe'@,,,,,_fb,,,,'maximized','zamech_grpm')
?};

_mark:=0;
{? _opcja='TECHNOLOGIA_ZLECENIA' | _opcja='KONTROLA_ILOŚCI' | 10+_opcja='KALKULACJA' | _opcja='ANALIZA_WYKONANIA'
|| _formula:="M.cntx_psh(); M.clear(); M.seek(__ZAMEL.T); VAR.A_T:=M.ref(); M.cntx_pop(); sel_exit()";
   __ZAMEL.win_act(_wer,0,'Formuła','Wybierz'@@,,,_formula,,1);
   _mark:=1
|? _opcja='DOKUMENT_MAGAZYNOWY'
|| __ZAMEL.win_act(_wer,0,'Formuła','Wybierz'@@,,,"exec('dk_exit','magdok_poz')",,1);
   _mark:=1
?};

__ZAMEL.win_act(_wer,0,'Wyświetl',,,,"
   Cntx.psh(M,TMAT,TCHMAT);
   Cntx.clr(M,TMAT,TCHMAT);
   {? M.seek(__ZAMEL.T)
   || {? {? __ZAMEL.ZE='Z'
         || _tz:='Z';
            TCHMAT.seek(__ZAMEL.TCHMAT,8+__ZAMEL.TCHMAT)
         || _tz:='M';
            TMAT.seek(__ZAMEL.TMAT,8+__ZAMEL.TMAT)
         ?}
      || {? _tz='Z'
         || TCHMAT.win_edit('NOR');
            TCHMAT.hdr_edit('Normy zamiennika'@);
            TCHMAT.display()
         || TMAT.win_edit('NOR');
            TMAT.hdr_edit('Normy surowca'@);
            TMAT.display()
         ?}
      ?}
   ?};
   Cntx.pop(M,TMAT,TCHMAT);
   ~~
");

{? _a=3
|| __ZAMEL.win_act(_wer,0,'Formuła','Stany'@@,,,"exec('stan_tmat_obj','tech_mater')",,~_mark)
|? _a=1 | _a=2 | _a=4 | _a=6
|| __ZAMEL.win_act(_wer,0,'Formuła','Stany'@@,,,$("exec('stan_zmat_obj','tech_mater',"+$_a+")"),,~_mark);
   {? _a=6
   || __ZAMEL.win_act(_wer2,0,'Formuła','Stany'@@,,,$("exec('stan_zmat_obj','tech_mater',"+$_a+")"),,~_mark)
   ?}
?};
__ZAMEL.win_act(_wer,0,'Formuła','Druku&j'@@,,,"exec('drk_zam','tech_mater')",,,,,,,,'icon=print');
__ZAMEL.win_act(_wer,,'Formuła','Legenda'@@,,,"exec('legenda','color','__ZAMECH#01#','#__ZAMECH#01')");
__ZAMEL.win_act(_wer,0,'Rekord',,,,"{? __ZAMEL.T=ktm || Color.rekprzed('__ZAMECH#01#01') || '' ?}");
{? _czy_grp>0
|| __ZAMEL.win_sel(_grp)
|| __ZAMEL.win_sel(_wer)
?};

exec('tktl_cntx_psh','tech_common');

_can_continue:=1;

_licznik:=obj_new(2);
_licznik[1]:=0;
_licznik[2]:=0;

_il:=0;
{? _a=6
|| _il:=ZLIM.LIL
?};

::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
:: 1. ZASILENIE
::----------------------------------------------------------------------------------------------------------------------
:: 1.1. Ustawienie kontekstu tabeli TMAT
::----------------------------------------------------------------------------------------------------------------------
:: Zasilenie na podstawie tabeli __TMAT (biezacy rekord)
{? _opcja='KALKULACJA_TECHNOLOGII' | _opcja='KALKULACJA_ZLECENIA' | _opcja='LIMITY'
|| _msk:=(8+__TMAT.REF)+3;
   exec('tktl_use','tech_common',_msk);
   TMAT.clear();
   {? ~TMAT.seek(__TMAT.REF,8+__TMAT.REF)
   || _can_continue:=0
   ?}

:: Zasilenie na podstawie tabeli __TAC (biezacy rekord)
|? _opcja='KONTROLA_ILOŚCI'
|| _msk:=(8+__TAC.TMAT)+3;
   exec('tktl_use','tech_common',_msk);
   TMAT.clear();
   {? ~TMAT.seek(__TAC.TMAT,8+__TAC.TMAT)
   || _can_continue:=0
   ?}

:: Zasilenie na podstawie tabeli TMAT (biezacy rekord)
|| ~~
?};

::----------------------------------------------------------------------------------------------------------------------
:: 1.2. Ustalenie zrodlowego TMATa i grupy technologicznej - ustawiane zmienne: src, ktm
::----------------------------------------------------------------------------------------------------------------------
{? _can_continue>0
|| {? _opcja='DOKUMENT_MAGAZYNOWY'
   || src:=null();
      ktm:=''
   || src:=TMAT.ref();
      {? _a=6
      || ktm:=$ZLIM.KTM
      || ktm:={? TMAT.GRKTM='K'
              || $TMAT.PT
              || $TMAT.TGDFLT().PT
              ?}
      ?}
   ?}
?};
::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
:: 2. Generowanie rekordow tabeli __ZAMEL - zapisy pierwotne, grupa technologiczna i jej elementy
:: Uwaga: kontekst tabeli TMAT ustawiony w sekcji 1.
{? _can_continue>0 & _opcja<>'DOKUMENT_MAGAZYNOWY'
||
:: TMAT biezacy (jest zawsze)
   {? _opcja='KALKULACJA_TECHNOLOGII' |
      _opcja='KALKULACJA_ZLECENIA' |
      _opcja='LIMITY' |
      _opcja='TECHNOLOGIA_ZLECENIA' |
      _opcja='KONTROLA_ILOŚCI'
   || _licznik[1]+=1;
      __ZAMEL.LP:=_licznik[1];
      __ZAMEL.NAZWA:={? TMAT.GRKTM='K' || TMAT.PT().N || TMAT.TGDFLT().PT().N ?};
      __ZAMEL.KOD:=M.KTM;
      __ZAMEL.JM:=M.J().KOD;
      __ZAMEL.T:=$M.ref();
      __ZAMEL.ZE:={? TMAT.GRKTM='K' || '' || '' ?};
      __ZAMEL.TMAT:=$TMAT.ref();
      __ZAMEL.TCHMAT:='';
      __ZAMEL.TTG:=$TMAT.TGRP;
      __ZAMEL.GR:=TMAT.TGRP().GR;
      __ZAMEL.TTGP:=$TMAT.TGDFLT;
      __ZAMEL.SRC:=$TMAT.ref();
      __ZAMEL.SRCTECH:='N';
      __ZAMEL.TYP:='T';
      __ZAMEL.add();
      {? _par='T' | _par='P' & TMAT.TGRP().ZAMIENN='T'
      || TTGP.index('GS');
         TTGP.prefix(TMAT.TGRP);
         {? TTGP.first()
         || {!
            |? {? TTGP.PT<>exec('FindAndGet','#table',TTGP,TMAT.TGDFLT,,"PT",null())
               || _licznik[1]+=1;
                  __ZAMEL.LP:=_licznik[1];
                  __ZAMEL.NAZWA:=TTGP.PT().N;
                  __ZAMEL.KOD:=M.KTM;
                  __ZAMEL.JM:=M.J().KOD;
                  __ZAMEL.T:=$TTGP.PT;
                  __ZAMEL.ZE:='E';
                  __ZAMEL.TMAT:=$TMAT.ref();
                  __ZAMEL.TCHMAT:='';
                  __ZAMEL.SRC:=$TMAT.ref();
                  __ZAMEL.TTG:=$TMAT.TGRP;
                  __ZAMEL.GR:=TMAT.TGRP().GR;
                  __ZAMEL.TTGP:=$TTGP.ref();
                  __ZAMEL.SRCTECH:='N';
                  __ZAMEL.TYP:='T';
                  __ZAMEL.add()
               ?};
               TTGP.next()
            !}
         ?}
      ?}
   ?};
:: TMAT zrodlowy (jezeli jest TMAT.SRC)
   {? _a<>3 & _a<>6 & TMAT.SRC<>''
   || exec('FindAndGet','#table',TMAT,TMAT.SRC,,"
         _par:=exec('get','#params',500001,2);
         _licznik:=_b;
         _licznik[1]+=1;
         __ZAMEL.LP:=_licznik[1];
         __ZAMEL.NAZWA:={? TMAT.GRKTM='K' || TMAT.PT().N || TMAT.TGDFLT().PT().N ?};
         __ZAMEL.KOD:=M.KTM;
         __ZAMEL.JM:=M.J().KOD;
         __ZAMEL.T:=$M.ref();
         __ZAMEL.ZE:={? TMAT.GRKTM='K' || '' || '' ?};
         __ZAMEL.TMAT:=$TMAT.ref();
         __ZAMEL.TCHMAT:='';
         __ZAMEL.TTG:=$TMAT.TGRP;
         __ZAMEL.GR:=TMAT.TGRP().GR;
         __ZAMEL.TTGP:=$TMAT.TGDFLT;
         __ZAMEL.SRC:=$TMAT.ref();
         __ZAMEL.SRCTECH:='T';
         __ZAMEL.TYP:='T';
         __ZAMEL.add();
         {? _par='T' | _par='P' & TMAT.TGRP().ZAMIENN='T'
         || TTGP.index('GS');
            TTGP.prefix(TMAT.TGRP);
            {? TTGP.first()
            || {!
               |? {? TTGP.PT<>exec('FindAndGet','#table',TTGP,TMAT.TGDFLT,,\"PT\",null())
                  || _licznik[1]+=1;
                     __ZAMEL.LP:=_licznik[1];
                     __ZAMEL.NAZWA:=TTGP.PT().N;
                     __ZAMEL.KOD:=M.KTM;
                     __ZAMEL.JM:=M.J().KOD;
                     __ZAMEL.T:=$TTGP.PT;
                     __ZAMEL.ZE:='E';
                     __ZAMEL.TMAT:=$TMAT.ref();
                     __ZAMEL.TCHMAT:='';
                     __ZAMEL.SRC:=$TMAT.ref();
                     __ZAMEL.TTG:=$TMAT.TGRP;
                     __ZAMEL.GR:=TMAT.TGRP().GR;
                     __ZAMEL.TTGP:=$TTGP.ref();
                     __ZAMEL.SRCTECH:='T';
                     __ZAMEL.TYP:='T';
                     __ZAMEL.add()
                  ?};
                  TTGP.next()
               !}
            ?}
         ?}
      ",~~,_licznik)
   ?}
?};
::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

::{? _a<>8 || VAR_DEL.delete('__tab'); __tab:=tab_tmp(1,'TMAT','STRING[16]',''); __tab.TMAT:=$TMAT.ref(); __tab.add() ?};
:: teraz ujednolicenie mechanizmu, jezeli nie ma _a=8, to stworzymy __tab kompatybilne z zewnetrznym
{? _opcja<>'DOKUMENT_MAGAZYNOWY'
|| VAR_DEL.delete('__tab'); __tab:=sql('select distinct tab.SRC as TMAT, tab.SRCTECH from :_a as tab',__ZAMEL)
?};

::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
:: 3. Uzupelnienie z listy zamiennikow i ewentualnie elementow grupy technologicznej (w zaleznosci od parametru 500001)
__tab.clear();
{? __tab.first()
|| _ndxmat:=__ZAMEL.ndx_tmp(,1,'SRC',,,'TCHMAT',,);
   _ndxgrp:=__ZAMEL.ndx_tmp(,1,'SRC',,,'TTG',,,'TTGP',,);
   {!
   |? _msk:=(8+__tab.TMAT)+3;
      exec('tktl_cntx_psh','tech_common');
      exec('tktl_use','tech_common',_msk);
      TCHMAT.index('SL');
      TCHMAT.prefix(BIT.sqlint(__tab.TMAT));
      {? TCHMAT.first()
      || {!
         |? {? TCHMAT.ACT='T'
            || {? TCHMAT.PT<>null()
               || __ZAMEL.cntx_psh();
                  __ZAMEL.index(_ndxmat);
                  __ZAMEL.prefix(__tab.TMAT,$TCHMAT.ref());
                  {? __ZAMEL.first()
                  || __ZAMEL.cntx_pop()
                  || __ZAMEL.cntx_pop();
                     _licznik[1]+=1;
                     __ZAMEL.LP:=_licznik[1];
                     __ZAMEL.NAZWA:=TCHMAT.PT().N;
                     __ZAMEL.KOD:=M.KTM;
                     __ZAMEL.JM:=M.J().KOD;
                     __ZAMEL.T:=$TCHMAT.PT;
                     __ZAMEL.ZE:='Z';
                     __ZAMEL.TMAT:='';
                     __ZAMEL.TCHMAT:=$TCHMAT.ref();
                     __ZAMEL.TTG:='';
                     __ZAMEL.GR:='';
                     __ZAMEL.TTGP:='';
                     __ZAMEL.SRC:=__tab.TMAT;
                     __ZAMEL.SRCTECH:=__tab.SRCTECH;
                     __ZAMEL.TYP:='T';
                     __ZAMEL.add()
                   ?}

               |? _par='T' | _par='P' & TCHMAT.TGRP().ZAMIENN='T'
               || TTGP.clear();
                  TTGP.index('GS');
                  TTGP.prefix(TCHMAT.TGRP);
                  {? TTGP.first()
                  || {!
                     |? __ZAMEL.cntx_psh();
                        __ZAMEL.index(_ndxgrp);
                        __ZAMEL.prefix(__tab.TMAT,$TCHMAT.TGRP,$TTGP.ref());
                        {? __ZAMEL.first()
                        || __ZAMEL.cntx_pop()
                        || __ZAMEL.cntx_pop();
                           _licznik[1]+=1;
                           __ZAMEL.LP:=_licznik[1];
                           __ZAMEL.NAZWA:=TTGP.PT().N;
                           __ZAMEL.KOD:=M.KTM;
                           __ZAMEL.JM:=M.J().KOD;
                           __ZAMEL.T:=$TTGP.PT;
                           __ZAMEL.ZE:='Z';
                           __ZAMEL.TMAT:='';
                           __ZAMEL.TCHMAT:=$TCHMAT.ref();
                           __ZAMEL.TTG:=$TCHMAT.TGRP;
                           __ZAMEL.GR:=TCHMAT.TGRP().GR;
                           __ZAMEL.TTGP:=$TTGP.ref();
                           __ZAMEL.SRC:=__tab.TMAT;
                           __ZAMEL.SRCTECH:=__tab.SRCTECH;
                           __ZAMEL.TYP:='T';
                           __ZAMEL.add()
                        ?};
                        TTGP.next()
                     !}
                  ?}

               || __ZAMEL.cntx_psh();
                  __ZAMEL.index(_ndxmat);
                  __ZAMEL.prefix(__tab.TMAT,$TCHMAT.ref());
                  {? __ZAMEL.first()
                  || __ZAMEL.cntx_pop()
                  || __ZAMEL.cntx_pop();
                     _licznik[1]+=1;
                     __ZAMEL.LP:=_licznik[1];
                     __ZAMEL.NAZWA:=TCHMAT.TGDFLT().PT().N;
                     __ZAMEL.KOD:=M.KTM;
                     __ZAMEL.JM:=M.J().KOD;
                     __ZAMEL.T:=$TCHMAT.TGDFLT().PT;
                     __ZAMEL.ZE:='Z';
                     __ZAMEL.TMAT:='';
                     __ZAMEL.TCHMAT:=$TCHMAT.ref();
                     __ZAMEL.TTG:=$TCHMAT.TGRP;
                     __ZAMEL.GR:=TCHMAT.TGRP().GR;
                     __ZAMEL.TTGP:=$TCHMAT.TGDFLT;
                     __ZAMEL.SRC:=__tab.TMAT;
                     __ZAMEL.SRCTECH:=__tab.SRCTECH;
                     __ZAMEL.TYP:='T';
                     __ZAMEL.add()
                  ?}
               ?}
            ?};
            TCHMAT.next()
         !}
      ?};
      exec('tktl_cntx_pop','tech_common');
      __tab.next()
   !}
?};
{? _opcja<>'DOKUMENT_MAGAZYNOWY' || VAR_DEL.delete('__tab') ?};
::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

TCHMAT.clear();

::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
:: 3a. Uzupelnienie z listy zamiennikow materiałowych
{? _czy_grp>0
|| {? ktm<>''
   || M.cntx_psh();
      M.prefix();
      {? M.seek(ktm)
      || _ndxtyp:=__ZAMEL.ndx_tmp(,1,'SRC',,,'TYP',,);
         MZ.cntx_psh();
         MZ.index('MZ');
         MZ.prefix(M.ref());
         {? MZ.first()
         || {!
            |?
               __ZAMEL.cntx_psh();
               __ZAMEL.index(_ndxtyp);
               __ZAMEL.prefix($MZ.ref(),'M');
               {? __ZAMEL.first()
               || __ZAMEL.cntx_pop()
               || __ZAMEL.cntx_pop();
                  _licznik[2]+=1;
                  __ZAMEL.LP:=_licznik[2];
                  __ZAMEL.NAZWA:=MZ.MZ().N;
                  __ZAMEL.KOD:=M.KTM;
                  __ZAMEL.JM:=M.J().KOD;
                  __ZAMEL.T:=$MZ.MZ;
                  __ZAMEL.ZE:='Z';
                  __ZAMEL.TMAT:='';
                  __ZAMEL.TCHMAT:='';
                  __ZAMEL.TTG:='';
                  __ZAMEL.GR:='';
                  __ZAMEL.TTGP:='';
                  __ZAMEL.SRC:=$MZ.ref();
                  __ZAMEL.TYP:='M';
                  __ZAMEL.IL:=_il;
                  __ZAMEL.add()
                ?};
               MZ.next()
            !}
         ?};
         MZ.cntx_pop()
      ?};
      M.cntx_pop()
   ?}
?};

::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
:: 4.   Usunięcie zbędnych wierszy
:: 4.1. Wyjściowy element technologii zlecenia, jeżeli nie jest zamiennikiem ani elementem grupy
{? _opcja='TECHNOLOGIA_ZLECENIA' | _opcja='KONTROLA_ILOŚCI' | _opcja='KALKULACJA_ZLECENIA'
|| __ZAMEL.prefix();
   {? __ZAMEL.first()
   || {!
      |? {? __ZAMEL.ZE='' & __ZAMEL.SRCTECH='N'
         || __ZAMEL.del()
         || __ZAMEL.next()
         ?}
      !}
   ?}
?};
:: 4.2. Jeżeli są elementy zamienne z technologii zlecenia, to usuwane są elementy z technologii źródłowej
{? _opcja='TECHNOLOGIA_ZLECENIA' | _opcja='KONTROLA_ILOŚCI' | _opcja='KALKULACJA_ZLECENIA'
|| __ZAMEL.cntx_psh();
   __ZAMEL.index(__ZAMEL.ndx_tmp(,,'SRCTECH',,));
   __ZAMEL.prefix('N');
   {? __ZAMEL.size()>0
   || __ZAMEL.prefix('T');
      {? __ZAMEL.first()
      || {!
         |? {? __ZAMEL.ZE='Z' | __ZAMEL.ZE='E'
            || __ZAMEL.del()
            || __ZAMEL.next()
            ?}
         !}
      ?}
   ?};
   __ZAMEL.cntx_pop()
?};
::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
:: 5. Uzupelnienie kolumn ze stanami (magazynowe, rezerwacje...)
__ZAMEL.prefix();
{? __ZAMEL.first()
|| {!
   |? M.clear();
      {? M.seek(__ZAMEL.T)
      || exec('obl_stan','magazyn_stan',M.ref(),{? _opcja='DOKUMENT_MAGAZYNOWY' || 1 || 6 ?});
         __ZAMEL.S:=BEER.S;
         __ZAMEL.SD:=BEER.SD;
         __ZAMEL.SRT:=BEER.SRT;
         __ZAMEL.SRR:=BEER.SRR;
         __ZAMEL.SSZ:=BEER.SSZ;
         __ZAMEL.WDR:=BEER.WDR;
         __ZAMEL.put()
      ?};
      __ZAMEL.next()
   !}
?};
::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

exec('tktl_cntx_pop','tech_common');

::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
:: 6. Automatyczna zamiana
{? _no_disp=0 & __ZAMEL.select()
||
   _result:=1;

::   exec('start_tpar','tex_tpar',TMAT.PT);
   mat:={? TMAT.GRKTM='K' || TMAT.PT || TMAT.TGDFLT().PT ?};

:: Zastosowanie zamiennika (TCHMAT -> TMAT)
   {? __ZAMEL.ZE='Z'
   ||
      M.clear();
      TCHMAT.cntx_psh();
      {? M.seek(__ZAMEL.T) & params_exec('sprktm','tech_mater',TMAT,M.ref())
      || TCHMAT.clear();
         {? TCHMAT.seek(__ZAMEL.TCHMAT,8+__ZAMEL.TCHMAT)
         ||
            {? _opcja='KONTROLA_ILOŚCI'
            ||
::             norma brutto surowca na xjm wg technologii
               _warb:={? TCHMAT.FORMB<>''
                      || tpar.calc(TCHMAT.FORMB)$ exec('round_abe','tech_mater',TCHMAT,1)
                      || TCHMAT.WARB
                      ?};
::             xjm, czyli na ile wyrobow definiowana technologia
               _xjm:=exec('FindAndGet','#table',TKTL,$TMAT.NRK,,"XJM",1);
::             ilosc wyrobow do wyprodukowania na zlecenie
               _il:=VAR.A_ZLEC().IL;
::             zapotrzebowanie na surowiec
               _dokl:=exec('jaka_dok_m','jm',M.ref());
               _zap:={? _dokl>0
                     || (_warb*_il/_xjm) $ _dokl
                     || ceil(_warb*_il/_xjm)
                     ?};
               _result:=exec('stan_ktr_one','zl_limit',M.ref(),_zap);

               {? _result[4]>=0 | FUN.ask('Zamiennik nie pokrywa potrzeb zlecenia.\n\nCzy zastosować mimo to?'@)
               || _warn:={? TCHMAT.FORMN<>''
                         || tpar.calc(TCHMAT.FORMN)$ exec('round_abe','tech_mater',TCHMAT,1)
                         || TCHMAT.WARN
                         ?};
                  _dwarn:={? TCHMAT.DFORMN<>''
                          || tpar.calc(TCHMAT.DFORMN)$ exec('round_abe','tech_mater',TCHMAT,1)
                          || TCHMAT.DWARN
                          ?};
                  _dwarb:={? TCHMAT.DFORMB<>''
                          || tpar.calc(TCHMAT.DFORMB)$ exec('round_abe','tech_mater',TCHMAT,1)
                          || TCHMAT.DWARB
                          ?};
                  TMAT.FORMN:=TCHMAT.FORMN;
                  TMAT.WARN:=_warn;
                  TMAT.FORMB:=TCHMAT.FORMB;
                  TMAT.WARB:=_warb;
                  TMAT.DFORMN:=TCHMAT.DFORMN;
                  TMAT.DWARN:=_dwarn;
                  TMAT.DFORMB:=TCHMAT.DFORMB;
                  TMAT.DWARB:=_dwarb;
                  TMAT.EXIST:=TCHMAT.EXIST;
                  TMAT.OPIS:=TCHMAT.OPIS;

::                Obsługa atrybutów - jesli wzorzec atrybutow dostaw oryginalu i zamiennika rozni sie
::                to czyszcze ceche na oryginale
                  _matr_new:=M.M_ATR;
                  {? TMAT.DK_C<>null()
                  ||
                     M.cntx_psh();
                     _m_atr:={? TMAT.PT<>null() || TMAT.PT().M_ATR || TMAT.TGDFLT().PT().M_ATR ?};
                     {? _m_atr<>_matr_new
                     || _msg:='Wzorzec atrybutów dostaw zamiennika jest różny od wzorca oryginału.'
                              '\nPrzypisana cecha do surowca zostanie usunięta.'@;
                        FUN.info(_msg);
                        TMAT.ATR_MASK:='';
                        TMAT.DK_C:=null()
                     ?};
                     M.cntx_pop()
                  ?};

                  {? TCHMAT.GRKTM='G'
                  || TMAT.GRKTM:='G';
                     TMAT.PT:=null();
                     TMAT.TGRP:=exec('FindAndGet','#table',TTG,__ZAMEL.TTG,,"ref()",null());
                     TMAT.TGDFLT:=exec('FindAndGet','#table',TTGP,__ZAMEL.TTGP,,"ref()",null())
                  || TMAT.GRKTM:='K';
                     TMAT.PT:=M.ref();
                     TMAT.TGRP:=null();
                     TMAT.TGDFLT:=null()
                  ?};
                  TMAT.DFLT_KTL:=TCHMAT.DFLT_KTL;
::                Obsluga technologii dla polfabrykatu - jezeli _ktl nie jest przypisany do M, to czyszcze
                  _ktl:=TCHMAT.KTL;
                  _rktl:=TCHMAT.RKTL;
                  {? _rktl<>''
                  || exec('tktl_cntx_psh','tech_common');
                     _msk:=(8+_rktl)+3;
                     exec('tktl_use','tech_common',_msk);
                     TKTLW.index('REF');
                     TKTLW.prefix(BIT.sqlint(_rktl),M.ref());
                     {? TKTLW.first()
                     || _rktl:=$TKTLW.TKTL;
                        _ktl:={? _msk='___' || TKTLW.TKTL || null() ?}
                     || FUN.info(
                           'Element grupy technologicznej nie ma technologii takiej jak element domyślny.\n'
                           'Karta technologiczna nie zostanie przypisana do surowca.'@
                        );
                        _rktl:='';
                        _ktl:=null()
                     ?};
                     exec('tktl_cntx_pop','tech_common');
                     TMAT.KTL:=_ktl;
                     TMAT.RKTL:=_rktl
                  || TMAT.KTL:=null();
                     TMAT.RKTL:=''
                  ?};
                  TMAT.MAG:=TCHMAT.MAG;
                  TMAT.put();
                  FUN.info('Wybrany został zamiennik, wymagana jest kontrola karty przez technologa.'@)
               ?};
               obj_del(_result)

            |? _opcja='TECHNOLOGIA_ZLECENIA'
            || _warb:={? TCHMAT.FORMB<>''
                      || tpar.calc(TCHMAT.FORMB)$ exec('round_abe','tech_mater',TCHMAT,1)
                      || TCHMAT.WARB
                      ?};
               _warn:={? TCHMAT.FORMN<>''
                      || tpar.calc(TCHMAT.FORMN)$ exec('round_abe','tech_mater',TCHMAT,1)
                      || TCHMAT.WARN
                      ?};
               _dwarb:={? TCHMAT.DFORMB<>''
                       || tpar.calc(TCHMAT.DFORMB)$ exec('round_abe','tech_mater',TCHMAT,1)
                       || TCHMAT.DWARB
                       ?};
               _dwarn:={? TCHMAT.DFORMN<>''
                       || tpar.calc(TCHMAT.DFORMN)$ exec('round_abe','tech_mater',TCHMAT,1)
                       || TCHMAT.DWARN
                       ?};
               TMAT.FORMN:=TCHMAT.FORMN;
               TMAT.WARN:=_warn;
               TMAT.FORMB:=TCHMAT.FORMB;
               TMAT.WARB:=_warb;
               TMAT.DFORMN:=TCHMAT.DFORMN;
               TMAT.DWARN:=_dwarn;
               TMAT.DFORMB:=TCHMAT.DFORMB;
               TMAT.DWARB:=_dwarb;
               TMAT.EXIST:=TCHMAT.EXIST;
               TMAT.OPIS:=TCHMAT.OPIS;

::             Obsługa atrybutów - jesli wzorzec atrybutow dostaw oryginalu i zamiennika rozni sie
::             to czyszcze ceche na oryginale
               _matr_new:=M.M_ATR;
               {? TMAT.DK_C<>null()
               ||
                  M.cntx_psh();
                  _m_atr:={? TMAT.PT<>null() || TMAT.PT().M_ATR || TMAT.TGDFLT().PT().M_ATR ?};
                  {? _m_atr<>_matr_new
                  || _msg:='Wzorzec atrybutów dostaw zamiennika jest różny od wzorca oryginału.'
                           '\nPrzypisana cecha do surowca zostanie usunięta.'@;
                     FUN.info(_msg);
                     TMAT.ATR_MASK:='';
                     TMAT.DK_C:=null()
                  ?};
                  M.cntx_pop()
               ?};

               {? TCHMAT.GRKTM='G'
               || TMAT.GRKTM:='G';
                  TMAT.PT:=null();
                  TMAT.TGRP:=exec('FindAndGet','#table',TTG,__ZAMEL.TTG,,"ref()",null());
                  TMAT.TGDFLT:=exec('FindAndGet','#table',TTGP,__ZAMEL.TTGP,,"ref()",null())
               || TMAT.GRKTM:='K';
                  TMAT.PT:=M.ref();
                  TMAT.TGRP:=null();
                  TMAT.TGDFLT:=null()
               ?};
               TMAT.DFLT_KTL:=TCHMAT.DFLT_KTL;
::             Obsluga technologii dla polfabrykatu - jezeli _ktl nie jest przypisany do M, to czyszcze
               _ktl:=TCHMAT.KTL;
               _rktl:=TCHMAT.RKTL;
               {? _rktl<>''
               || exec('tktl_cntx_psh','tech_common');
                  _msk:=(8+_rktl)+3;
                  exec('tktl_use','tech_common',_msk);
                  TKTLW.index('REF');
                  TKTLW.prefix(BIT.sqlint(_rktl),M.ref());
                  {? TKTLW.first()
                  || _rktl:=$TKTLW.TKTL;
                     _ktl:={? _msk='___' || TKTLW.TKTL || null() ?}
                  || FUN.info(
                        'Element grupy technologicznej nie ma technologii takiej jak element domyślny.\n'
                        'Karta technologiczna nie zostanie przypisana do surowca.'@
                     );
                     _rktl:='';
                     _ktl:=null()
                  ?};
                  exec('tktl_cntx_pop','tech_common');
                  TMAT.KTL:=_ktl;
                  TMAT.RKTL:=_rktl
               || TMAT.KTL:=null();
                  TMAT.RKTL:=''
               ?};
               TMAT.MAG:=TCHMAT.MAG;
               TMAT.put();
               ~~

            |? _opcja='ANALIZA_WYKONANIA'
            || _warb:={? TCHMAT.FORMB<>''
                      || zpar.calc(TCHMAT.FORMB)$ exec('round_abe','tech_mater',TCHMAT,1)
                      || TCHMAT.WARB
                      ?};
::             xjm, czyli na ile wyrobow definiowana technologia
               _xjm:=exec('FindAndGet','#table',TKTL,$TMAT.NRK,,"XJM",1);
::             ilosc wyrobow do wyprodukowania
               _il:=PLRELWYR.ILOSC;
::             zapotrzebowanie na surowiec
               _dokl:=exec('jaka_dok_m','jm',M.ref());
               _zap:={? _dokl>0
                     || (_warb*_il/_xjm)$ _dokl
                     || ceil(_warb*_il/_xjm)
                     ?};
               VAR.A_T:=M.ref();
               _dostepne:=exec('stan_surx','magazyn_stan');
::             dostepne nie moze byc ujemne
               {? _dostepne<0 || _dostepne:=0 ?};
               _brakuje:=_dostepne-_zap;
               {? _brakuje>=0 | FUN.ask('Zamiennik nie pokrywa potrzeb produkcji.\n\nCzy zastosować mimo to?'@)
               || _warn:={? TCHMAT.FORMN<>''
                         || zpar.calc(TCHMAT.FORMN)$ exec('round_abe','tech_mater',TCHMAT,1)
                         || TCHMAT.WARN
                         ?};
                  _dwarn:={? TCHMAT.DFORMN<>''
                          || zpar.calc(TCHMAT.DFORMN)$ exec('round_abe','tech_mater',TCHMAT,1)
                          || TCHMAT.DWARN
                          ?};
                  _dwarb:={? TCHMAT.DFORMB<>''
                          || zpar.calc(TCHMAT.DFORMB)$ exec('round_abe','tech_mater',TCHMAT,1)
                          || TCHMAT.DWARB
                          ?};
                  TMAT.FORMN:=TCHMAT.FORMN;
                  TMAT.WARN:=_warn;
                  TMAT.FORMB:=TCHMAT.FORMB;
                  TMAT.WARB:=_warb;
                  TMAT.DFORMN:=TCHMAT.DFORMN;
                  TMAT.DWARN:=_dwarn;
                  TMAT.DFORMB:=TCHMAT.DFORMB;
                  TMAT.DWARB:=_dwarb;
                  TMAT.EXIST:=TCHMAT.EXIST;
                  TMAT.OPIS:=TCHMAT.OPIS;

::                Obsługa atrybutów - jesli wzorzec atrybutow dostaw oryginalu i zamiennika rozni sie
::                to czyszcze ceche na oryginale
                  _matr_new:=M.M_ATR;
                  {? TMAT.DK_C<>null()
                  ||
                     M.cntx_psh();
                     _m_atr:={? TMAT.PT<>null() || TMAT.PT().M_ATR || TMAT.TGDFLT().PT().M_ATR ?};
                     {? _m_atr<>_matr_new
                     || _msg:='Wzorzec atrybutów dostaw zamiennika jest różny od wzorca oryginału.'
                              '\nPrzypisana cecha do surowca zostanie usunięta.'@;
                        FUN.info(_msg);
                        TMAT.ATR_MASK:='';
                        TMAT.DK_C:=null()
                     ?};
                     M.cntx_pop()
                  ?};

                  {? TCHMAT.GRKTM='G'
                  || TMAT.GRKTM:='G';
                     TMAT.PT:=null();
                     TMAT.TGRP:=exec('FindAndGet','#table',TTG,__ZAMEL.TTG,,"ref()",null());
                     TMAT.TGDFLT:=exec('FindAndGet','#table',TTGP,__ZAMEL.TTGP,,"ref()",null())
                  || TMAT.GRKTM:='K';
                     TMAT.PT:=M.ref();
                     TMAT.TGRP:=null();
                     TMAT.TGDFLT:=null()
                  ?};
                  TMAT.DFLT_KTL:=TCHMAT.DFLT_KTL;
::                Obsluga technologii dla polfabrykatu - jezeli _ktl nie jest przypisany do M, to czyszcze
                  _ktl:=TCHMAT.KTL;
                  _rktl:=TCHMAT.RKTL;
                  {? _rktl<>''
                  || exec('tktl_cntx_psh','tech_common');
                     _msk:=(8+_rktl)+3;
                     exec('tktl_use','tech_common',_msk);
                     TKTLW.index('REF');
                     TKTLW.prefix(BIT.sqlint(_rktl),M.ref());
                     {? TKTLW.first()
                     || _rktl:=$TKTLW.TKTL;
                        _ktl:={? _msk='___' || TKTLW.TKTL || null() ?}
                     || FUN.info(
                           'Element grupy technologicznej nie ma technologii takiej jak element domyślny.\n'
                           'Karta technologiczna nie zostanie przypisana do surowca.'@
                        );
                        _rktl:='';
                        _ktl:=null()
                     ?};
                     exec('tktl_cntx_pop','tech_common');
                     TMAT.KTL:=_ktl;
                     TMAT.RKTL:=_rktl
                  || TMAT.KTL:=null();
                     TMAT.RKTL:=''
                  ?};
                  TMAT.MAG:=TCHMAT.MAG;
                  TMAT.put();
                  __TAC.TMAT:=$TMAT.ref();
                  __TAC.T:=#M.ref();
                  __TAC.KOD:=M.KTM;
                  __TAC.NAZ:=M.N;
                  __TAC.ZAP:=_zap;
                  __TAC.DOST:=_dostepne;
                  __TAC.BRAK:=-_brakuje;
                  __TAC.put()
               ?}

            |? _opcja='KALKULACJA_TECHNOLOGII' | _opcja='KALKULACJA_ZLECENIA'
            || __TMAT.TCHMAT:=$TCHMAT.ref();
               __TMAT.PTREF:=#M.ref();
               __TMAT.KOD:=M.KTM;
               __TMAT.NAZ:=M.N;
               __TMAT.WPM:=M.R;
               __TMAT.TKTL:=$TCHMAT.KTL;
               __TMAT.put()
            ?}
         ?}
      ?};
      TCHMAT.cntx_pop()

:: Zastosowanie elementu grupy technologicznej albo TMATa zrodlowego
   ||
      M.clear();
      {? M.seek(__ZAMEL.T) & params_exec('sprktm','tech_mater',TMAT,M.ref())
      ||
         {? _opcja='KONTROLA_ILOŚCI'
         || exec('tktl_cntx_psh','tech_common');
            _src:={? TMAT.SRC='' || $TMAT.ref() || TMAT.SRC ?};
            _msk:=(8+_src)+3;
            exec('tktl_use','tech_common',_msk);
            TMAT.clear();
            {? TMAT.seek(_src)
            ||
               _formn:=TMAT.FORMN;
               _warn:={? TMAT.FORMN<>''
                      || tpar.calc(TMAT.FORMN)$ exec('round_abe','tech_mater',TMAT,1)
                      || TMAT.WARN
                      ?};
               _formb:=TMAT.FORMB;
               _warb:={? TMAT.FORMB<>''
                      || tpar.calc(TMAT.FORMB)$ exec('round_abe','tech_mater',TMAT,1)
                      || TMAT.WARB
                      ?};
               _dformn:=TMAT.DFORMN;
               _dwarn:={? TMAT.DFORMN<>''
                       || tpar.calc(TMAT.DFORMN)$ exec('round_abe','tech_mater',TMAT,1)
                       || TMAT.DWARN
                       ?};
               _dformb:=TMAT.DFORMB;
               _dwarb:={? TMAT.DFORMB<>''
                       || tpar.calc(TMAT.DFORMB)$ exec('round_abe','tech_mater',TMAT,1)
                       || TMAT.DWARB
                       ?};
               _exist:=TMAT.EXIST;
               _opis:=TMAT.OPIS;
               _dfltktl:=TMAT.DFLT_KTL;
               _ktl:=TMAT.KTL;
               _rktl:=TMAT.RKTL;
               _mag:=TMAT.MAG;
::             xjm, czyli na ile wyrobow definiowana technologia
               _xjm:=exec('FindAndGet','#table',TKTL,$TMAT.NRK,,"XJM",1);
::             ilosc wyrobow do wyprodukowania na zlecenie
               _il:=TMAT.NRK().ZL().IL;
::             zapotrzebowanie na surowiec
               _dokl:=exec('jaka_dok_m','jm',M.ref());
               _zap:={? _dokl>0
                     || (_warb*_il/_xjm) $ _dokl
                     || ceil(_warb*_il/_xjm)
                     ?};
               M.cntx_psh();
               _result:=exec('stan_ktr_one','zl_limit',M.ref(),_zap);
               M.cntx_pop()
            || _formn:='';
               _warn:=0;
               _formb:='';
               _warb:=0;
               _dformn:='';
               _dwarn:=0;
               _dformb:='';
               _dwarb:=0;
               _exist:='';
               _opis:='';
               _dfltktl:='N';
               _ktl:=null();
               _rktl:='';
               _mag:='N';
               M.cntx_psh();
               _result:=exec('stan_ktr_one','zl_limit',M.ref(),0);
               M.cntx_pop()
            ?};
            exec('tktl_cntx_pop','tech_common');

            {? _result[4]>=0 | FUN.ask('Zamiennik nie pokrywa potrzeb zlecenia.\n\nCzy zastosować mimo to?'@)
            ||
               TMAT.FORMN:=_formn;
               TMAT.WARN:=_warn;
               TMAT.FORMB:=_formb;
               TMAT.WARB:=_warb;
               TMAT.DFORMN:=_dformn;
               TMAT.DWARN:=_dwarn;
               TMAT.DFORMB:=_dformb;
               TMAT.DWARB:=_dwarb;
               TMAT.EXIST:=_exist;
               TMAT.OPIS:=_opis;

::             Obsługa atrybutów - jesli wzorzec atrybutow dostaw oryginalu i zamiennika rozni sie
::             to czyszcze ceche na oryginale
               _matr_new:=M.M_ATR;
               {? TMAT.DK_C<>null()
               ||
                  M.cntx_psh();
                  {? TMAT.PT().M_ATR<>_matr_new
                  || _msg:='Wzorzec atrybutów dostaw zamiennika jest różny od wzorca oryginału.'
                           '\nPrzypisana cecha do surowca zostanie usunięta.'@;
                     FUN.info(_msg);
                     TMAT.ATR_MASK:='';
                     TMAT.DK_C:=null()
                  ?};
                  M.cntx_pop()
               ?};

               {? exec('FindAndGet','#table',TMAT,__ZAMEL.SRC,,"GRKTM",'K')='G'
               || TMAT.GRKTM:='G';
                  TMAT.TGRP:=exec('FindAndGet','#table',TTG,__ZAMEL.TTG,,"ref()",null());
                  TMAT.TGDFLT:=exec('FindAndGet','#table',TTGP,__ZAMEL.TTGP,,"ref()",null());
                  TMAT.PT:=null()
               || TMAT.GRKTM:='K';
                  TMAT.TGRP:=null();
                  TMAT.TGDFLT:=null();
                  TMAT.PT:=M.ref()
               ?};
               TMAT.DFLT_KTL:=_dfltktl;
::             Obsluga technologii dla polfabrykatu - jezeli _ktl nie jest przypisany do M, to czyszcze
               {? _rktl<>''
               || exec('tktl_cntx_psh','tech_common');
                  _msk:=(8+_rktl)+3;
                  exec('tktl_use','tech_common',_msk);
                  TKTLW.index('REF');
                  TKTLW.prefix(BIT.sqlint(_rktl),M.ref());
                  {? TKTLW.first()
                  || _rktl:=$TKTLW.TKTL;
                     _ktl:={? _msk='___' || TKTLW.TKTL || null() ?}
                  || FUN.info(
                        'Element grupy technologicznej nie ma technologii takiej jak element domyślny.\n'
                        'Karta technologiczna nie zostanie przypisana do surowca.'@
                     );
                     _rktl:='';
                     _ktl:=null()
                  ?};
                  exec('tktl_cntx_pop','tech_common')
               || _ktl:=null();
                  _rktl:=''
               ?};
               TMAT.KTL:=_ktl;
               TMAT.RKTL:=_rktl;
               TMAT.MAG:=_mag;
               TMAT.put()
            ?};
            obj_del(_result)

         |? _opcja='TECHNOLOGIA_ZLECENIA'
         || exec('tktl_cntx_psh','tech_common');
            _src:={? TMAT.SRC='' || $TMAT.ref() || TMAT.SRC ?};
            _msk:=(8+_src)+3;
            exec('tktl_use','tech_common',_msk);
            TMAT.clear();
            {? TMAT.seek(_src)
            || _formn:=TMAT.FORMN;
               _warn:={? TMAT.FORMN<>''
                      || tpar.calc(TMAT.FORMN)$ exec('round_abe','tech_mater',TMAT,1)
                      || TMAT.WARN
                      ?};
               _formb:=TMAT.FORMB;
               _warb:={? TMAT.FORMB<>''
                      || tpar.calc(TMAT.FORMB)$ exec('round_abe','tech_mater',TMAT,1)
                      || TMAT.WARB
                      ?};
               _dformn:=TMAT.DFORMN;
               _dwarn:={? TMAT.DFORMN<>''
                       || tpar.calc(TMAT.DFORMN)$ exec('round_abe','tech_mater',TMAT,1)
                       || TMAT.DWARN
                       ?};
               _dformb:=TMAT.DFORMB;
               _dwarb:={? TMAT.DFORMB<>''
                       || tpar.calc(TMAT.DFORMB)$ exec('round_abe','tech_mater',TMAT,1)
                       || TMAT.DWARB
                       ?};
               _exist:=TMAT.EXIST;
               _opis:=TMAT.OPIS;
               _dfltktl:=TMAT.DFLT_KTL;
               _dkc:=TMAT.DK_C;
               _atrmask:=TMAT.ATR_MASK;

::             Obsluga technologii dla polfabrykatu - jezeli _ktl nie jest przypisany do M, to czyszcze
               _ktl:=TMAT.KTL;
               _rktl:=TMAT.RKTL;
               {? _rktl<>''
               || exec('tktl_cntx_psh','tech_common');
                  _msk:=(8+_rktl)+3;
                  exec('tktl_use','tech_common',_msk);
                  TKTLW.index('REF');
                  TKTLW.prefix(BIT.sqlint(_rktl),M.ref());
                  {? TKTLW.first()
                  || _rktl:=$TKTLW.TKTL;
                     _ktl:={? _msk='___' || TKTLW.TKTL || null() ?}
                  || FUN.info(
                        'Element grupy technologicznej nie ma technologii takiej jak element domyślny.\n'
                        'Karta technologiczna nie zostanie przypisana do surowca.'@
                     );
                     _rktl:='';
                     _ktl:=null()
                  ?};
                  exec('tktl_cntx_pop','tech_common')
               || _ktl:=null();
                  _rktl:=''
               ?};
               _mag:=TMAT.MAG
            || _formn:='';
               _warn:=0;
               _formb:='';
               _warb:=0;
               _dformn:='';
               _dwarn:=0;
               _dformb:='';
               _dwarb:=0;
               _exist:='';
               _opis:='';
               _dfltktl:='N';
               _ktl:=null();
               _rktl:='';
               _mag:='N';
               _dkc:=null();
               _atrmask:=''
            ?};
            exec('tktl_cntx_pop','tech_common');

            TMAT.FORMN:=_formn;
            TMAT.WARN:=_warn;
            TMAT.FORMB:=_formb;
            TMAT.WARB:=_warb;
            TMAT.DFORMN:=_dformn;
            TMAT.DWARN:=_dwarn;
            TMAT.DFORMB:=_dformb;
            TMAT.DWARB:=_dwarb;
            TMAT.EXIST:=_exist;
            TMAT.OPIS:=_opis;

::          Obsługa atrybutów - jesli wzorzec atrybutow dostaw oryginalu i zamiennika rozni sie
::          to czyszcze ceche na oryginale
            _matr_new:=M.M_ATR;
            {? TMAT.DK_C<>null()
            || M.cntx_psh();
               _m_atr:={? TMAT.PT<>null() || TMAT.PT().M_ATR || TMAT.TGDFLT().PT().M_ATR ?};
               {? _m_atr<>_matr_new
               || _msg:='Wzorzec atrybutów dostaw zamiennika jest różny od wzorca oryginału.'
                        '\nPrzypisana cecha do surowca zostanie usunięta.'@;
                  FUN.info(_msg);
                  TMAT.ATR_MASK:='';
                  TMAT.DK_C:=null()
               ?};
               M.cntx_pop()
            || TMAT.DK_C:=_dkc;
               TMAT.ATR_MASK:=_atrmask
            ?};

            {? exec('FindAndGet','#table',TMAT,__ZAMEL.SRC,,"GRKTM",'K')='G'
            || TMAT.GRKTM:='G';
               TMAT.TGRP:=exec('FindAndGet','#table',TTG,__ZAMEL.TTG,,"ref()",null());
               TMAT.TGDFLT:=exec('FindAndGet','#table',TTGP,__ZAMEL.TTGP,,"ref()",null());
               TMAT.PT:=null()
            || TMAT.GRKTM:='K';
               TMAT.TGRP:=null();
               TMAT.TGDFLT:=null();
               TMAT.PT:=M.ref()
            ?};
            TMAT.DFLT_KTL:=_dfltktl;
            TMAT.KTL:=_ktl;
            TMAT.RKTL:=_rktl;
            TMAT.MAG:=_mag;
            TMAT.put();
            ~~

         |? _opcja='ANALIZA_WYKONANIA'
         || exec('tktl_cntx_psh','tech_common');
            _src:={? TMAT.SRC='' || $TMAT.ref() || TMAT.SRC ?};
            _msk:=(8+_src)+3;
            exec('tktl_use','tech_common',_msk);
            TMAT.clear();
            {? TMAT.seek(_src)
            || _formn:=TMAT.FORMN;
               _warn:={? TMAT.FORMN<>''
                      || zpar.calc(TMAT.FORMN)$ exec('round_abe','tech_mater',TMAT,1)
                      || TMAT.WARN
                      ?};
               _formb:=TMAT.FORMB;
               _warb:={? TMAT.FORMB<>''
                      || zpar.calc(TMAT.FORMB)$ exec('round_abe','tech_mater',TMAT,1)
                      || TMAT.WARB
                      ?};
               _dformn:=TMAT.DFORMN;
               _dwarn:={? TMAT.DFORMN<>''
                       || zpar.calc(TMAT.DFORMN)$ exec('round_abe','tech_mater',TMAT,1)
                       || TMAT.DWARN
                       ?};
               _dformb:=TMAT.DFORMB;
               _dwarb:={? TMAT.DFORMB<>''
                       || zpar.calc(TMAT.DFORMB)$ exec('round_abe','tech_mater',TMAT,1)
                       || TMAT.DWARB
                       ?};
               _exist:=TMAT.EXIST;
               _opis:=TMAT.OPIS;
               _dfltktl:=TMAT.DFLT_KTL;
               _ktl:=TMAT.KTL;
               _mag:=TMAT.MAG;
               _xjm:=exec('FindAndGet','#table',TKTL,$TMAT.NRK,,"XJM",1)
            || _formn:='';
               _warn:=0;
               _formb:='';
               _warb:=0;
               _dformn:='';
               _dwarn:=0;
               _dformb:='';
               _dwarb:=0;
               _exist:='';
               _opis:='';
               _dfltktl:='N';
               _ktl:=null();
               _mag:='N';
               _xjm:=1
            ?};
            exec('tktl_cntx_pop','tech_common');
::          ilosc wyrobow do wyprodukowania
            _il:=PLRELWYR.ILOSC;
::          zapotrzebowanie na surowiec
            _dokl:=exec('jaka_dok_m','jm',M.ref());
            _zap:={? _dokl>0
                  || (_warb*_il/_xjm)$ _dokl
                  || ceil(_warb*_il/_xjm)
                  ?};
            VAR.A_T:=M.ref();
            _dostepne:=exec('stan_surx','magazyn_stan');
::          dostepne nie moze byc ujemne
            {? _dostepne<0 || _dostepne:=0 ?};
            _brakuje:=_dostepne-_zap;
            {? _brakuje>=0 | _brakuje<0 &
               FUN.ask('Zamiennik nie pokrywa potrzeb produkcji.\n\nCzy zastosować mimo to?'@)
            || TMAT.FORMN:=_formn;
               TMAT.WARN:=_warn;
               TMAT.FORMB:=_formb;
               TMAT.WARB:=_warb;
               TMAT.DFORMN:=_dformn;
               TMAT.DWARN:=_dwarn;
               TMAT.DFORMB:=_dformb;
               TMAT.DWARB:=_dwarb;
               TMAT.EXIST:=_exist;
               TMAT.OPIS:=_opis;

::             Obsługa atrybutów - jesli wzorzec atrybutow dostaw oryginalu i zamiennika rozni sie
::             to czyszcze ceche na oryginale
               _matr_new:=M.M_ATR;
               {? TMAT.DK_C<>null()
               ||
                  M.cntx_psh();
                  _m_atr:={? TMAT.PT<>null() || TMAT.PT().M_ATR || TMAT.TGDFLT().PT().M_ATR ?};
                  {? _m_atr<>_matr_new
                  || _msg:='Wzorzec atrybutów dostaw zamiennika jest różny od wzorca oryginału.'
                           '\nPrzypisana cecha do surowca zostanie usunięta.'@;
                     FUN.info(_msg);
                     TMAT.ATR_MASK:='';
                     TMAT.DK_C:=null()
                  ?};
                  M.cntx_pop()
               ?};
               {? __ZAMEL.TTG<>''
               || TMAT.GRKTM:='G';
                  TMAT.PT:=null();
                  TMAT.TGRP:=exec('FindAndGet','#table',TTG,__ZAMEL.TTG,,"ref()",null());
                  TMAT.TGDFLT:=exec('FindAndGet','#table',TTGP,__ZAMEL.TTGP,,"ref()",null())
               || TMAT.GRKTM:='K';
                  TMAT.PT:=M.ref();
                  TMAT.TGRP:=null();
                  TMAT.TGDFLT:=null()
               ?};
               TMAT.DFLT_KTL:=_dfltktl;
::             Obsluga technologii dla polfabrykatu - jezeli _ktl nie jest przypisany do M, to czyszcze
               _ktl:=exec('FindAndGet','#table',TMAT,_src,,"KTL",null());
               _rktl:=exec('FindAndGet','#table',TMAT,_src,,"RKTL",'');
               {? _rktl<>''
               || exec('tktl_cntx_psh','tech_common');
                  _msk:=(8+_rktl)+3;
                  exec('tktl_use','tech_common',_msk);
                  TKTLW.index('REF');
                  TKTLW.prefix(BIT.sqlint(_rktl),M.ref());
                  {? TKTLW.first()
                  || _rktl:=$TKTLW.TKTL;
                     _ktl:={? _msk='___' || TKTLW.TKTL || null() ?}
                  || FUN.info(
                        'Element grupy technologicznej nie ma technologii takiej jak element domyślny.\n'
                        'Karta technologiczna nie zostanie przypisana do surowca.'@
                     );
                     _rktl:='';
                     _ktl:=null()
                  ?};
                  exec('tktl_cntx_pop','tech_common')
               || _ktl:=null();
                  _rktl:=''
               ?};
               TMAT.KTL:=_ktl;
               TMAT.RKTL:=_rktl;
               TMAT.MAG:=_mag;
               TMAT.put();
               __TAC.TMAT:=$TMAT.ref();
               __TAC.T:=#M.ref();
               __TAC.KOD:=M.KTM;
               __TAC.NAZ:=M.N;
               __TAC.ZAP:=_zap;
               __TAC.DOST:=_dostepne;
               __TAC.BRAK:=-_brakuje;
               __TAC.put()
            ?}

         |? _opcja='KALKULACJA_TECHNOLOGII' | _opcja='KALKULACJA_ZLECENIA'
         || TMAT.seek(__TMAT.REF,8+__TMAT.REF);
            __TMAT.TCHMAT:='';
            __TMAT.PTREF:=#M.ref();
            __TMAT.KOD:=M.KTM;
            __TMAT.NAZ:=M.N;
            __TMAT.WPM:=M.R;
            __TMAT.TKTL:='';
            __TMAT.put()
         ?}
      || _result:=0
      ?}
   ?};
::   exec('stop_tpar','tex_tpar')
   ~~
?};
::=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

VAR.TYMCZAS:='';
{? _no_disp=0 || obj_del(__ZAMEL) ?};
{? _maski || obj_del(__MASKI) ?};
M.cntx_pop();
&src;
_result


\stan_tmat_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MK [8.10]
:: OPIS: wyświetla listę stanów dla danej pozycji
::  OLD: \stan_zmat_obj/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
TMAT.seek(src);
exec('start_tpar','tech_param',null());
_wsp:=0;
_warb:=0;
M.clear();
{? __ZAMEL.ZE='Z'
|| {? M.seek(__ZAMEL.T)
   || TCHMAT.seek(__ZAMEL.TCHMAT);
      _warb:={? TCHMAT.FORMB<>'' || tpar.calc(TCHMAT.FORMB) || TCHMAT.WARB ?}
   ?}
|| {? M.seek(__ZAMEL.T)
   || _warb:={? TMAT.FORMB<>'' || tpar.calc(TMAT.FORMB) || TMAT.WARB ?}
   ?}
?};
exec('stop_tpar','tech_param');
VAR.REAL:=_warb;
VAR.A_T:=M.ref();
exec('stan_surx','magazyn_stan');
SM.cntx_psh();
SM.index('SMM');
SM.prefix(VAR.A_T);
SM.win_sel('STANY');
SM.select();
SM.cntx_pop();
~~


\stan_zmat_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.10]
:: OPIS: Wyświetla listę stanów dla danej pozycji
::       Wywołane z formuły pokaz_zam_mech/tmp_obj (opis cytowany):
::   WE: _a: 0 - Obsluga zamiany surowca w karcie technologicznej zlecenia.
::               'TECHNOLOGIA_ZLECENIA'
::           1 - Obsluga zamiany surowca w karcie technologicznej zlecenia - funkcja kontroli ilosci
::               'KONTROLA_ILOŚCI'
::           2 - Wywolywane z poziomu surowcow pozycji analizy wykonania.
::               'ANALIZA_WYKONANIA'
::           3 - Wywolywane z poziomu: Technologia->Kalkulacje...->Porownanie->Zmieniony algorytm->Surowce->Zamienniki
::               'KALKULACJA_TECHNOLOGII'
::           4 - Wywolywane z poziomu: Zlecenia->Kalkulacje...->Porownanie->Zmieniony algorytm->Surowce->Zamienniki
::               'KALKULACJA_ZLECENIA'
::           6 - Dziala jak 3, ale z poziomu limitow zlecenia (jak limit z technologii zlecenia)
::               'LIMITY'
::           8 - Gdy wywolywane z poziomu korekt limitow podczas pobran
::               'DOKUMENT_MAGAZYNOWY'
::   WE: _a - przekazana ww wartosc parametru (obsluzone: 2, 4, 6)
::  OLD: \stan_zmat_obj/zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? _<1 || FUN.error('Formuła stan_zmat_obj/tech_mater - brak parametru.'@); return() ?};

_mask:=ref_name(src)+3;
exec('tktl_use','tech_common',_mask);

{? _a=4
|| VAR.A_KTL:=VAR.A_ANZH().ZLEC().TKTL;
   TMAT.clear();
   {? TMAT.seek(src)
   || exec('start_tpar','tech_param',exec('FindAndGet','#table',M,__ZAMEL.T,,"ref()",null()))
   || return()
   ?}
|? _a=6
|| ZTP.cntx_psh();
   {? VAR.A_ZLEC().TYP().TECH='T'
   || VAR.A_KTL:=VAR.A_ZLEC().TKTL
   || VAR.A_KTL:=VAR.A_ZLEC().KTL
   ?};
   ZTP.cntx_pop();
   TMAT.clear();
   {? TMAT.seek(src)
   || exec('start_tpar','tech_param',exec('FindAndGet','#table',M,__ZAMEL.T,,"ref()",null()))
   || return()
   ?}
|? _a=2
|| TMAT.clear();
   {? TMAT.seek(src)
   || exec('start_tpar','tech_param',exec('FindAndGet','#table',M,__ZAMEL.T,,"ref()",null()))
   || return()
   ?}
|? _a=1
|| TMAT.clear();
   {? ~TMAT.seek(src)
   || return()
   ?}
||
   FUN.error('Formuła stan_zmat_obj/tech_mater - błędna wartość parametru.'@); return()
?};

M.clear();
_wsp:=0;
_warb:=0;
{? __ZAMEL.TYP='M'
|| {? M.seek(__ZAMEL.T)
   || _wsp:=1;
      _warb:=__ZAMEL.IL
   ?}
|? __ZAMEL.ZE='Z'
|| {? M.seek(__ZAMEL.T)
   ||
      TCHMAT.clear();
      {? TCHMAT.seek(__ZAMEL.TCHMAT,8+__ZAMEL.TCHMAT)
      ||
         _xjm:=exec('FindAndGet','#table',TKTL,#TCHMAT.NRK,ref_name(TCHMAT.NRK),"XJM",1);
         {? _a=1 | _a=6
         || _wsp:=VAR.A_ZLEC().IL/_xjm
         || _wsp:=VAR.A_ANZH().ZLEC().IL/_xjm
         ?};
         _warb:={? TCHMAT.FORMB<>''
                || tpar.calc(TCHMAT.FORMB)$exec('round_abe','tech_mater',TCHMAT,1)
                || TCHMAT.WARB
                ?}
      ||
         return()
      ?}
   ?}
|| {? M.seek(__ZAMEL.T)
   ||
      TMAT.clear();
      {? TMAT.seek(__ZAMEL.TMAT,8+__ZAMEL.TMAT)
      ||
         _xjm:=exec('FindAndGet','#table',TKTL,#TMAT.NRK,ref_name(TMAT.NRK),"XJM",1);
         {? _a=1 | _a=6
         || _wsp:=VAR.A_ZLEC().IL/_xjm
         || _wsp:=VAR.A_ANZH().ZLEC().IL/_xjm
         ?};
         _warb:={? TMAT.FORMB<>''
                || tpar.calc(TMAT.FORMB)$exec('round_abe','tech_mater',TCHMAT,1)
                || TMAT.WARB
                ?}
      ||
         return()
      ?}
   ?}
?};
{? _a<>1 || exec('stop_tpar','tech_param') ?};
VAR.REAL:=_wsp*_warb;
VAR.A_T:=M.ref();
exec('lim_rez','zl_limit',M.ref());
exec('stan_surx','magazyn_stan');
SM.cntx_psh();
SM.index('SMM');
SM.prefix(VAR.A_T);
{? _a=2
|| SM.win_sel('STANY')
|| SM.win_sel('STANYP')
?};
SM.select();
SM.cntx_pop();
~~


\whohasme
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.53] Uwaga_63
::       AJ PR/WRT/PRODUKCJ/10.20/0015
:: OPIS: "kto mnie ma"
::   WE: _a:
::        - w której technologii użyta jest dana technologia w pozycjach materiałowych?
::          (brak pierwszego param. albo _a=0) praca w kontekście TKTL (VAR.A_KTL)
::        - w której technologii użyty jest dany indeks materiałowy w pozycjach materiałowych?
::          (_a=1) praca w kontekście M albo HELP.REFMAT (ze zleceniami)
::        - w której technologii użyty jest dany indeks materiałowy w pozycjach materiałowych?
::          (_a=2) praca w kontekście M albo HELP.REFMAT (bez zleceń)
::        - w której technologii użyta jest dana technologia w pozycjach materiałowych?
::          (_a=3) bada tylko technologie niearchiwalne, praca w kontekscie TKTL (VAR.A_KTL)
::        - w której technologii użyty jest dany indeks materiałowy w pozycjach materiałowych?
::          (_a=4) praca w kontekście M albo HELP.REFMAT, bez wyświetlania okna wyników
::        - w której technologii użyta jest dana technologia w pozycjach materiałowych?
::          (_a=5) bada tylko technologie niearchiwalne,
::          praca w kontekscie M albo HELP.REFMAT, bez wyswietlania okna wynikow
::        - jak (_a=2) ale wynik przechowany w tabeli __who_t, okno __who_w (_a=6)
::       [_b] - dla _a=6: 1 zwraca strukture - uchwyt tabeli i uchwyt okienka selekcji 0-nie (domyślnie)
::       [_c] - lista akcji, które ukryć
::       [_d] - uwzględnić niepowiązane z technologią limity zlecenia: [0] - nie , 1 - tak (dla _a=6)
::       [_e] - uwzględnić wykorzystanie w zgłoszeniach remontowych: [0] - nie , 1 - tak (dla _a=6)
::   WY: 1 - są powiązania (ważne i badane dla _a=2, _a=3, _a=4, _a=5, _a=6)
::  OLD: \whohasme/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0 || _a:=0 ?};
{? _>=2 || {? type_of(_b)<>1 || _b:=0 ?} || _b:=0 ?};
_chk_lim:={? var_pres('_d')=type_of(0) || _d || 0 ?};
_chk_rem:={? var_pres('_e')=type_of(0) || _e || 0 ?};
M.cntx_psh(); ZL.cntx_psh();
exec('tktl_cntx_psh','tech_common');
exec('tktl_use','tech_common');
{? HELP.REFMAT<>null() || M.seek(HELP.REFMAT) ?};

_res:=0;
{? _>0
|| {? _a=2 | _a=3 | _a=6 | _a=5
::      _a=1 | _a=2 | _a=3 | _a=4 | _a=5 | _a=6
   || _dalej:=1
   || FUN.error('Błędna wartość parametru formuły \whohasme/tech_mater.'@);
      _dalej:=0
   ?}
|| _dalej:=1
?};
{? _dalej
|| TKTL.cntx_psh(); M.cntx_psh();
   VAR_DEL.delete('TAB1','TAB2','TAB3','__actions');
   __actions:={? var_pres('_c')=type_of('') || _c || '' ?};
   TAB1:=tab_tmp(2,
      'NRK','STRING[50]','Karta technologiczna',
      'WER','STRING[6]','Wersja',
      'TYP','STRING[3]','Typ karty',
      'PKTM','STRING[50]','Indeks produktu',
      'PNAZ','STRING[100]','Nazwa produktu',
      'PJM','STRING[10]','Jednostka miary produktu',
      'OPIS','STRING[60]','Opis',
      'TORW','STRING[1]','Technologia(komplet)/wzorzec/zlecenie(analiza)',
      'TORW_SYM','STRING[20]','Źródło',
      'PFAZ','STRING[10]','Faza produkcji',
      'TMATREF','INTEGER','#TMAT.ref()/#TCHMAT.ref()',
      'TMAT','STRING[16]','$TMAT.ref()/$TCHMAT.ref()',
      'SU','STRING[10]','Sposób użycia',
      'ACT','STRING[1]','Aktywny',
      'WARN','REAL','Norma netto',
      'WARB','REAL','Norma brutto\Ilość',
      'ZXJM','REAL','Zużycie na serię',
      'ZH','REAL','Zużycie na godzinę',
      'DFLT_KTL','STRING[1]','Technologia domyślna',
      'P_NRK','STRING[50]','Technologia półfabrykatu',
      'P_WER','STRING[6]','Wersja',
      'GR','STRING[1]','Element grupy',
      'ZL_SYM','STRING[20]','Zlecenie',
      'ZL_STAN','STRING[1]','Stan zlecenia',
      'KTL_STAN','STRING[1]','Stan karty',
      'KTL_ARCH','STRING[1]','Karta technologiczna archiwalna',
      'STATUS','STRING[20]','Status opisowo (dla karty archiwalna, dla zlecenia stan)'
   );
   TAB1.fld_attr(,2);
   TAB1.fld_attr('WARN',3);

   TAB1.fld_fml('ZL_STAN','BEFORE_DISPLAY',"{? cur_tab(1,1).ZL_SYM='' || 0 || 1 ?}");
   TAB1.fld_fml('WARN','DISPLAY_FORMAT',"'out_prec=5'");

:: okna
   _wer1:=TAB1.mk_sel(
      {? _a=0 | _a=3 | _a=5
      || 'Wykorzystanie karty technologicznej w kompletach, kartach, wzorcach, zleceniach'@
      || 'Wykorzystanie surowca w kompletach, kartach, wzorcach, zleceniach'@
      ?},'P',0,'#whohasme_tksl'+$_a,20,10,20,,'U'
   );
::   TAB1.win_fld(_wer1,,'TORW',,,-2,,1,'Technologia/wzorzec/zlecenie'@,,'Technologia/wzorzec/zlecenie(analiza)'@);
   TAB1.win_fld(_wer1,,'TORW_SYM',,,12,,,'Źródło'@);
   TAB1.win_fld(_wer1,,'STATUS',,,-10,,,'Status'@);
   TAB1.win_fld(_wer1,,'NRK',,,-20,,,'Komplet / karta / wzorzec / zlecenie'@+{? _chk_rem>0 || ' / zgłoszenie'@ || ''?});
   TAB1.win_fld(_wer1,,'WER',,,6,,,'Wersja'@);
   TAB1.win_fld(_wer1,,'PNAZ',,,50,,,'Nazwa produktu'@+{? _chk_rem>0 || ' / zasobu'@ || '' ?});
   TAB1.win_fld(_wer1,,'PJM',,,5,,,'jm'@);
   TAB1.win_fld(_wer1,VAR,'STRING',,,20,,,'Nr operacji'@,,,,1);
   TAB1.win_fld(_wer1,,'PFAZ',,,-10,,,'Faza produkcji'@);
   TAB1.win_fld(_wer1,,'SU',,,-10,,,'Sposób użycia'@);
   TAB1.win_fld(_wer1,,'GR',,,-3,,,'Element grupy technologicznej'@,,'Element grupy technologicznej'@,2,,"'T'","'N'");
   TAB1.win_fld(_wer1,,'WARB',,,15,4,,'Norma brutto / ilość'@);
   TAB1.win_fld(_wer1,,'DFLT_KTL',,,-3,,,'Technologia domyślna'@,,'Technologia domyślna'@,2,,"'T'","'N'");
   TAB1.win_act(_wer1,,'Formuła','Ustaw &technologię domyślną'@@,,'Ustawia domyślną technologię dla półfabrykatu'@,
      "exec('set_default','tech_mater')",,,1,"exec('set_default_bg','tech_mater')","exec('set_default_ag','tech_mater')"
   );
   task_attach('TTE_TEC_DRTS');
   task_attach('TTE_WTE_DRTS');
   TAB1.win_act(_wer1,,'Kolejność');
   TAB1.win_act(_wer1,,'Formuła','Legenda'@@,,,"exec('legenda','color','__TKTL#01#')",,1);
   TAB1.win_act(_wer1,,'Wyświetl',,,,"
      exec('display','tech_mater')
   ");
   TAB1.win_act(_wer1,0,'Rekord',,,,"
      _actions:={? var_pres('__actions')=type_of('') || __actions || '' ?};
      {? M.R='S' || _actions+='TZ' ?};
      cur_tab(1,1).actions(cur_win(1,1),_actions,,1);
      _grayed:='';
      TOPER.cntx_psh();
      TMAT.cntx_psh();
      TACTTLS.cntx_psh();
      {? cur_tab(1,1).SU='N-P-U'@
      || _tmat:=cur_tab(1,1).TMAT;
         TACTTLS.use(form(8+_tmat));
         TACTTLS.clear();
         {? TACTTLS.seek(_tmat)
         || {? TACTTLS.NROP<>null()
            ||
               TOPER.use(ref_name(TACTTLS.NROP));
               {? TACTTLS.NROP().UNROP<>0
               || VAR.STRING:=exec('get_oper_nr','tech_oper',TACTTLS.NROP().UNROP,'\\\\','n')
               ?}
            || VAR.STRING:='-'
            ?}
         ?}
      |? cur_tab(1,1).SU='Surowiec'@
      || _tmat:=cur_tab(1,1).TMAT;
         {? _tmat*'rmgrm'>0
         || VAR.STRING:=''
         |? _tmat*'zlim'>0
         || ZLIM.cntx_psh();
            ZLIM.use(form(8+_tmat));
            ZLIM.clear();
            {? ZLIM.seek(_tmat)
            || {? ZLIM.ZGP<>null()
               || ZGP.cntx_psh();
                  VAR.STRING:=$ZLIM.ZGP().NRP;
                  ZGP.cntx_pop()
               || VAR.STRING:='-'
               ?}
            ?};
            ZLIM.cntx_pop()
         || TMAT.use(form(8+_tmat));
            TMAT.clear();
            {? TMAT.seek(_tmat)
            || {? TMAT.NROP<>null()
               ||
                  TOPER.use(ref_name(TMAT.NROP));
                  {? TMAT.NROP().UNROP<>0
                  || VAR.STRING:=exec('get_oper_nr','tech_oper',TMAT.NROP().UNROP,'\\\\','n')
                  ?}
               || VAR.STRING:='-'
               ?}
            ?}
         ?}
      |? cur_tab(1,1).SU='Zamiennik'@
      || _tchmat:=cur_tab(1,1).TMAT;
         TCHMAT.use(form(8+_tchmat));
         TCHMAT.clear();
         {? TCHMAT.seek(_tchmat)
         || {? TCHMAT.NROP<>null()
            ||
               TOPER.use(ref_name(TCHMAT.NROP));
               {? TCHMAT.NROP().UNROP<>0
               || VAR.STRING:=exec('get_oper_nr','tech_oper',TCHMAT.NROP().UNROP,'\\\\','n')
               ?}
            || VAR.STRING:='-'
            ?}
         ?}
      ?};
      {? cur_tab(1,1).sel_size()<1 & (cur_tab(1,1).TORW<>'T' | cur_tab(1,1).SU='N-P-U')
      || _grayed:='T:T'
      ?};
      cur_tab(1,1).actions_grayed(cur_win(1,1),_grayed);
      TMAT.cntx_pop();
      TACTTLS.cntx_pop();
      TOPER.cntx_pop();
      {? cur_tab(1,1).ACT='N'
      || Color.rekprzed('__TKTL#01#02')
      || ''
      ?}
   ");

   TAB1.win_sel(_wer1);

:: indeksy, prefiksy:
   {? _a=0 | _a=3
   || _tktl:=VAR.A_KTL;
      _tktl_s:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.NRK+' / '+TKTL.WER",'');
      _default:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.DEFAULT",'N');
      _ktm:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.KTM",null());

::      TMAT.index('KTAN');
::      TMAT.prefix(_ktm,'T');
      TMAT.index('PAN');
      TMAT.prefix($VAR.A_KTL,'T');
::      TCHMAT.index('KTAN');
::      TCHMAT.prefix(_ktm,'T');
      TCHMAT.index('PAN');
      TCHMAT.prefix($VAR.A_KTL,'T');
      TAB1.hdr_sel(': '+_tktl_s);

::    przetwarzanie
      {? TMAT.first()
      || {!
         |? {? TMAT.NRK().ARCH='N' & (TMAT.RKTL=$_tktl | (_default='T' & TMAT.DFLT_KTL='T'))
            || TAB1.SU:='Surowiec'@;
               TAB1.GR:={? TMAT.GRKTM='G' || 'T' || 'N' ?};
               TAB1.ACT:=TMAT.ACT;
               TAB1.NRK:=TMAT.NRK().NRK;
               TAB1.WER:=TMAT.NRK().WER;
               TAB1.TYP:=TMAT.NRK().TYP().TYP;
               TAB1.PKTM:=TMAT.NRK().KTM().KTM;
               TAB1.PNAZ:=M.N;
               TAB1.PJM:=M.J().KOD;
               TAB1.OPIS:=TMAT.NRK().OPIS;
               TAB1.TORW:=TMAT.NRK().TORW;
               TAB1.TORW_SYM:=exec('torw_sym','tech_mater',TAB1.TORW,TAB1.TYP);
               {? TMAT.PFAZ<>null() || TAB1.PFAZ:=TMAT.PFAZ().KOD || TAB1.PFAZ:='' ?};
               TAB1.TMATREF:=#TMAT.ref();
               TAB1.TMAT:=$TMAT.ref();
               TAB1.WARN:=TMAT.WARN;
               TAB1.WARB:=TMAT.WARB;
               TAB1.DFLT_KTL:=TMAT.DFLT_KTL;
               {? TMAT.RKTL<>''
               || TAB1.P_NRK:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,"NRK",'');
                  TAB1.P_WER:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,"WER",'')
               || TAB1.P_NRK:='';
                  TAB1.P_WER:=''
               ?};
               TAB1.KTL_STAN:=TMAT.NRK().STAN;
               TAB1.KTL_ARCH:=TMAT.NRK().ARCH;
               {? TMAT.NRK().ZL<>null()
               || TAB1.ZL_SYM:=TMAT.NRK().ZL().SYM;
                  TAB1.ZL_STAN:=TMAT.NRK().ZL().STAN
               || TAB1.ZL_SYM:='';
                  TAB1.ZL_STAN:=''
               ?};
               TAB1.STATUS:=exec('status','tech_mater',TAB1.ZL_STAN,TAB1.KTL_STAN,TAB1.TORW);
               TAB1.add()
            ?};
            TMAT.next()
         !}
      ?};
      {? TCHMAT.first()
      || {!
         |? {? TCHMAT.NRK().ARCH='N' & (TCHMAT.RKTL=$_tktl | (_default='T' & TCHMAT.DFLT_KTL='T'))
            || TAB1.SU:='Zamiennik'@;
               TAB1.GR:={? TCHMAT.GRKTM='G' || 'T' || 'N' ?};
               TAB1.ACT:=TCHMAT.ACT;
               TAB1.NRK:=TCHMAT.NRK().NRK;
               TAB1.WER:=TCHMAT.NRK().WER;
               TAB1.TYP:=TCHMAT.NRK().TYP().TYP;
               TAB1.PKTM:=TCHMAT.NRK().KTM().KTM;
               TAB1.PNAZ:=M.N;
               TAB1.PJM:=M.J().KOD;
               TAB1.OPIS:=TCHMAT.NRK().OPIS;
               TAB1.TORW:=TCHMAT.NRK().TORW;
               TAB1.TORW_SYM:=exec('torw_sym','tech_mater',TAB1.TORW,TAB1.TYP);
               {? TCHMAT.SRC().PFAZ<>null() || TAB1.PFAZ:=TCHMAT.SRC().PFAZ().KOD || TAB1.PFAZ:='' ?};
               TAB1.TMATREF:=#TCHMAT.ref();
               TAB1.TMAT:=$TCHMAT.ref();
               TAB1.WARN:=TCHMAT.WARN;
               TAB1.WARB:=TCHMAT.WARB;
               TAB1.DFLT_KTL:=TCHMAT.DFLT_KTL;
               {? TCHMAT.RKTL<>''
               || TAB1.P_NRK:=exec('FindAndGet','#table',TKTL,TCHMAT.RKTL,,"NRK",'');
                  TAB1.P_WER:=exec('FindAndGet','#table',TKTL,TCHMAT.RKTL,,"WER",'')
               || TAB1.P_NRK:='';
                  TAB1.P_WER:=''
               ?};
               TAB1.KTL_STAN:=TCHMAT.NRK().STAN;
               TAB1.KTL_ARCH:=TCHMAT.NRK().ARCH;
               {? TCHMAT.NRK().ZL<>null()
               || TAB1.ZL_SYM:=TCHMAT.NRK().ZL().SYM;
                  TAB1.ZL_STAN:=TCHMAT.NRK().ZL().STAN
               || TAB1.ZL_SYM:='';
                  TAB1.ZL_STAN:=''
               ?};
               TAB1.STATUS:=exec('status','tech_mater',TAB1.ZL_STAN,TAB1.KTL_STAN,TAB1.TORW);
               TAB1.add()
            ?};
            TCHMAT.next()
         !}
      ?}
   |? _a>0
   || _pt:=M.ref();
      TMAT.index('KTAN');
      TMAT.prefix(_pt,'T');
      TCHMAT.index('KTAN');
      TCHMAT.prefix(_pt,'T');
      TACTTLS.index('KTAN');
      TACTTLS.prefix(_pt,'T');
      TAB1.hdr_sel(': '+M.KTM);

::    przetwarzanie
      {? TMAT.first()
      || {!
         |? {? (_a<>3 & _a<>5) | TMAT.NRK().ARCH='N'
            || TAB1.SU:='Surowiec'@;
               TAB1.GR:='N';
               TAB1.ACT:=TMAT.ACT;
               TAB1.NRK:=TMAT.NRK().NRK;
               TAB1.WER:=TMAT.NRK().WER;
               TAB1.TYP:=TMAT.NRK().TYP().TYP;
               TAB1.PKTM:=TMAT.NRK().KTM().KTM;
               TAB1.PNAZ:=M.N;
               TAB1.PJM:=M.J().KOD;
               TAB1.OPIS:=TMAT.NRK().OPIS;
               TAB1.TORW:=TMAT.NRK().TORW;
               TAB1.TORW_SYM:=exec('torw_sym','tech_mater',TAB1.TORW,TAB1.TYP);
               {? TMAT.PFAZ<>null() || TAB1.PFAZ:=TMAT.PFAZ().KOD || TAB1.PFAZ:='' ?};
               TAB1.TMATREF:=#TMAT.ref();
               TAB1.TMAT:=$TMAT.ref();
               TAB1.WARN:=TMAT.WARN;
               TAB1.WARB:=TMAT.WARB;
               TAB1.DFLT_KTL:=TMAT.DFLT_KTL;
               {? TMAT.RKTL<>''
               || TAB1.P_NRK:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,"NRK",'');
                  TAB1.P_WER:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,"WER",'')
               || TAB1.P_NRK:='';
                  TAB1.P_WER:=''
               ?};
               TAB1.KTL_STAN:=TMAT.NRK().STAN;
               TAB1.KTL_ARCH:=TMAT.NRK().ARCH;
               {? TMAT.NRK().ZL<>null()
               || TAB1.ZL_SYM:=TMAT.NRK().ZL().SYM;
                  TAB1.ZL_STAN:=TMAT.NRK().ZL().STAN
               || TAB1.ZL_SYM:='';
                  TAB1.ZL_STAN:=''
               ?};
               TAB1.STATUS:=exec('status','tech_mater',TAB1.ZL_STAN,TAB1.KTL_STAN,TAB1.TORW);
               TAB1.add()
            ?};
            TMAT.next()
         !}
      ?};
      {? TCHMAT.first()
      || {!
         |? {? (_a<>3 & _a<>5) | TCHMAT.NRK().ARCH='N'
            || TAB1.SU:='Zamiennik'@;
               TAB1.GR:='N';
               TAB1.ACT:=TCHMAT.ACT;
               TAB1.NRK:=TCHMAT.NRK().NRK;
               TAB1.WER:=TCHMAT.NRK().WER;
               TAB1.TYP:=TCHMAT.NRK().TYP().TYP;
               TAB1.PKTM:=TCHMAT.NRK().KTM().KTM;
               TAB1.PNAZ:=M.N;
               TAB1.PJM:=M.J().KOD;
               TAB1.OPIS:=TCHMAT.NRK().OPIS;
               TAB1.TORW:=TCHMAT.NRK().TORW;
               TAB1.TORW_SYM:=exec('torw_sym','tech_mater',TAB1.TORW,TAB1.TYP);
               {? TCHMAT.SRC().PFAZ<>null() || TAB1.PFAZ:=TCHMAT.SRC().PFAZ().KOD || TAB1.PFAZ:='' ?};
               TAB1.TMATREF:=#TCHMAT.ref();
               TAB1.TMAT:=$TCHMAT.ref();
               TAB1.WARN:=TCHMAT.WARN;
               TAB1.WARB:=TCHMAT.WARB;
               TAB1.DFLT_KTL:=TCHMAT.DFLT_KTL;
               {? TCHMAT.RKTL<>''
               || TAB1.P_NRK:=exec('FindAndGet','#table',TKTL,TCHMAT.RKTL,,"NRK",'');
                  TAB1.P_WER:=exec('FindAndGet','#table',TKTL,TCHMAT.RKTL,,"WER",'')
               || TAB1.P_NRK:='';
                  TAB1.P_WER:=''
               ?};
               TAB1.KTL_STAN:=TCHMAT.NRK().STAN;
               TAB1.KTL_ARCH:=TCHMAT.NRK().ARCH;
               {? TCHMAT.NRK().ZL<>null()
               || TAB1.ZL_SYM:=TCHMAT.NRK().ZL().SYM;
                  TAB1.ZL_STAN:=TCHMAT.NRK().ZL().STAN
               || TAB1.ZL_SYM:='';
                  TAB1.ZL_STAN:=''
               ?};
               TAB1.STATUS:=exec('status','tech_mater',TAB1.ZL_STAN,TAB1.KTL_STAN,TAB1.TORW);
               TAB1.add()
            ?};
            TCHMAT.next()
         !}
      ?};
      {? TACTTLS.first()
      || {!
         |? {? (_a<>3 & _a<>5) | TACTTLS.NRK().ARCH='N'
            || TAB1.SU:='N-P-U'@;
               TAB1.GR:='N';
               TAB1.ACT:=TACTTLS.ACT;
               TAB1.NRK:=TACTTLS.NRK().NRK;
               TAB1.WER:=TACTTLS.NRK().WER;
               TAB1.TYP:=TACTTLS.NRK().TYP().TYP;
               TAB1.PKTM:=TACTTLS.NRK().KTM().KTM;
               TAB1.PNAZ:=M.N;
               TAB1.PJM:=M.J().KOD;
               TAB1.OPIS:=TACTTLS.NRK().OPIS;
               TAB1.TORW:=TACTTLS.NRK().TORW;
               TAB1.TORW_SYM:=exec('torw_sym','tech_mater',TAB1.TORW,TAB1.TYP);
               {? TACTTLS.PFAZ<>null() || TAB1.PFAZ:=TACTTLS.PFAZ().KOD || TAB1.PFAZ:='' ?};
               TAB1.TMATREF:=#TACTTLS.ref();
               TAB1.TMAT:=$TACTTLS.ref();
               TAB1.WARB:=TACTTLS.ILE;
               TAB1.WARN:=TACTTLS.ILE;
               TAB1.ZH:=TACTTLS.ZH;
               TAB1.ZXJM:=TACTTLS.ZXJM;
               TAB1.DFLT_KTL:='N';

               TAB1.P_NRK:='';
               TAB1.P_WER:='';

               TAB1.KTL_STAN:=TACTTLS.NRK().STAN;
               TAB1.KTL_ARCH:=TACTTLS.NRK().ARCH;
               {? TACTTLS.NRK().ZL<>null()
               || TAB1.ZL_SYM:=TACTTLS.NRK().ZL().SYM;
                  TAB1.ZL_STAN:=TACTTLS.NRK().ZL().STAN
               || TAB1.ZL_SYM:='';
                  TAB1.ZL_STAN:=''
               ?};
               TAB1.STATUS:=exec('status','tech_mater',TAB1.ZL_STAN,TAB1.KTL_STAN,TAB1.TORW);
               TAB1.add()
            ?};
            TACTTLS.next()
         !}
      ?};
      {? _a=6 & _chk_lim>0
      ||
::       Surowce do zleceń bez powiązania z technologią
::       Przetwarzane surowce do zleceń niezamkniętych, niepowiązanych z surowcem technologicznym lub będących korekatmi
         _sql:=
            'select
               M.KTM as KTM,
               M.N as N,
               JM.KOD as JM,
               ZL.OPIS as OPIS,
               PFAZ.KOD as PFAZ,
               ZLIM.LIL as LIL,
               ZL.SYM as ZL_SYM,
               ZL.STAN as ZL_STAN,
               ZLIM.REFERENCE as REF,
               ZLIM.KOR2 as KOR2
            from @ZLIM
               join ZL using (ZLIM.ZLEC, ZL.REFERENCE)
               left join M using (ZL.KTM, M.REFERENCE)
               left join PFAZ using (ZLIM.PFAZ, PFAZ.REFERENCE)
               join JM using (M.J, JM.REFERENCE)
            where
               ZLIM.KTM=:_a
               and ZL.STAN<>\'Z\'
               and (ZLIM.TMAT is null or (ZLIM.KOR2<>0 and ZLIM.KOR=0))
         ';
         {? var_pres('_zlim_tab')>100 || obj_del(_zlim_tab) ?};
         _zlim_tab:=sql(_sql,_pt);
         {? _zlim_tab.first()
         || {!
            |?
               TAB1.SU:='Surowiec'@;
               TAB1.GR:='N';
               TAB1.ACT:='T';
               TAB1.NRK:=_zlim_tab.ZL_SYM;
               TAB1.WER:='';
               TAB1.TYP:='';
               TAB1.PKTM:=_zlim_tab.KTM;
               TAB1.PNAZ:=_zlim_tab.N;
               TAB1.PJM:=_zlim_tab.JM;
               TAB1.OPIS:=_zlim_tab.OPIS;
               TAB1.TORW:='Z';
               TAB1.TORW_SYM:=exec('torw_sym','tech_mater',TAB1.TORW,TAB1.TYP);
               TAB1.PFAZ:=_zlim_tab.PFAZ;
               TAB1.TMAT:=_zlim_tab.REF;
               TAB1.TMATREF:=exec('FindAndGet','#table',ZLIM,TAB1.TMAT,,"#ref",0);
               _ilosc:={? _zlim_tab.KOR2<>0 || exec('sum_il','zl_limit',TAB1.TMAT) || _zlim_tab.LIL ?};
               TAB1.WARN:=_ilosc;
               TAB1.WARB:=_ilosc;
               TAB1.DFLT_KTL:='';
               TAB1.P_NRK:='';
               TAB1.P_WER:='';
               TAB1.KTL_STAN:='';
               TAB1.KTL_ARCH:='';
               TAB1.ZL_SYM:=_zlim_tab.ZL_SYM;
               TAB1.ZL_STAN:=_zlim_tab.ZL_STAN;
               TAB1.STATUS:=exec('status','tech_mater',TAB1.ZL_STAN,TAB1.KTL_STAN,TAB1.TORW);
               TAB1.add();
               _zlim_tab.next()
            !}
         ?}
      ?};
::
      {? _a=6 & _chk_rem>0
      ||
::       Surowce do zgłoszeń remontowych
         {? var_pres('_rem_tab')>100 || obj_del(_rem_tab) ?};
         _rem_tab:=exec('chk_m4rem','material',_pt);
         {? var_pres('_rem_tab')>100 & _rem_tab.first()
         || {!
            |?
               TAB1.SU:='Surowiec'@;
               TAB1.GR:='N';
               TAB1.ACT:='T';
               TAB1.NRK:=_rem_tab.REM_SYM;
               TAB1.WER:='';
               TAB1.TYP:='';
               TAB1.PKTM:=_rem_tab.ZAS_SYM;
               TAB1.PNAZ:=_rem_tab.ZAS_NAZ;
               TAB1.PJM:='';
               TAB1.OPIS:=_rem_tab.TYTUL;
               TAB1.TORW:='R';
               TAB1.TORW_SYM:='Zgłoszenie remontowe'@;
               TAB1.PFAZ:='';
               TAB1.TMAT:=_rem_tab.REF;
               TAB1.TMATREF:=exec('FindAndGet','#table',REM_GRM,TAB1.TMAT,,"#ref",0);
               _ilosc:=_rem_tab.IL;
               TAB1.WARN:=_ilosc;
               TAB1.WARB:=_ilosc;
               TAB1.DFLT_KTL:='';
               TAB1.P_NRK:='';
               TAB1.P_WER:='';
               TAB1.KTL_STAN:='';
               TAB1.KTL_ARCH:='';
               TAB1.ZL_SYM:=_rem_tab.REM_SYM;
               TAB1.ZL_STAN:='';
               TAB1.STATUS:=_rem_tab.REM_STAN;
               TAB1.add();
               _rem_tab.next()
            !}
         ?}
      ?}
   ?};

   {? _a>0 & _a<>3
   || _gr:=sql('select TTGP.GR as TTG from TTGP where TTGP.PT=\':_a\'', $_pt);

      {? type_of(_gr)=type_of(~~)
      || exec('err_sql','#sql');
         TKTL.cntx_pop(); M.cntx_pop();
         exec('tktl_cntx_pop','tech_common');
         ZL.cntx_pop(); M.cntx_pop();
         return(0)
      ?};

      TMAT.index('GN');
      TCHMAT.index('GN');
      {? _gr.first()
      || {!
         |?
            TMAT.prefix(BIT.sqlint(_gr.TTG));
            {? TMAT.first()
            || {!
               |? TAB1.SU:='Surowiec'@;
                  TAB1.GR:='T';
                  TAB1.ACT:=TMAT.ACT;
                  TAB1.NRK:=TMAT.NRK().NRK;
                  TAB1.WER:=TMAT.NRK().WER;
                  TAB1.TYP:=TMAT.NRK().TYP().TYP;
                  TAB1.PKTM:=TMAT.NRK().KTM().KTM;
                  TAB1.PNAZ:=M.N;
                  TAB1.PJM:=M.J().KOD;
                  TAB1.TORW:=TKTL.TORW;
                  TAB1.TORW_SYM:=
                     {? TAB1.TORW='T' & TAB1.TYP=exec('k_res_string','tech_head')
                     || 'Komplet'@
                     |? TAB1.TORW='T'
                     || 'Technologia'@
                     |? TAB1.TORW='W'
                     || 'Wzorzec'@
                     || 'Zlecenie'@
                     ?};
                  {? TMAT.PFAZ<>null() || TAB1.PFAZ:=TMAT.PFAZ().KOD || TAB1.PFAZ:='' ?};
                  TAB1.TMATREF:=#TMAT.ref();
                  TAB1.TMAT:=$TMAT.ref();
                  TAB1.WARN:=TMAT.WARN;
                  TAB1.WARB:=TMAT.WARB;
                  TAB1.DFLT_KTL:=TMAT.DFLT_KTL;
                  {? TMAT.RKTL<>''
                  || TAB1.P_NRK:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,"NRK",'');
                     TAB1.P_WER:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,"WER",'')
                  || TAB1.P_NRK:='';
                     TAB1.P_WER:=''
                  ?};
                  TAB1.add();
                  TMAT.next()
               !}
            ?};
            TCHMAT.prefix(BIT.sqlint(_gr.TTG));
            {? TCHMAT.first()
            || {!
               |? TAB1.SU:='Zamiennik'@;
                  TAB1.GR:='T';
                  TAB1.ACT:=TCHMAT.ACT;
                  TAB1.NRK:=TCHMAT.NRK().NRK;
                  TAB1.WER:=TCHMAT.NRK().WER;
                  TAB1.TYP:=TCHMAT.NRK().TYP().TYP;
                  TAB1.PKTM:=TCHMAT.NRK().KTM().KTM;
                  TAB1.PNAZ:=M.N;
                  TAB1.PJM:=M.J().KOD;
                  TAB1.TORW:=TKTL.TORW;
                  TAB1.TORW_SYM:=
                     {? TAB1.TORW='T' & TAB1.TYP=exec('k_res_string','tech_head')
                     || 'Komplet'@
                     |? TAB1.TORW='T'
                     || 'Technologia'@
                     |? TAB1.TORW='W'
                     || 'Wzorzec'@
                     || 'Zlecenie'@
                     ?};
                  {? TCHMAT.SRC().PFAZ<>null() || TAB1.PFAZ:=TCHMAT.SRC().PFAZ().KOD || TAB1.PFAZ:='' ?};
                  TAB1.TMATREF:=#TCHMAT.ref();
                  TAB1.TMAT:=$TCHMAT.ref();
                  TAB1.WARN:=TCHMAT.WARN;
                  TAB1.WARB:=TCHMAT.WARB;
                  TAB1.DFLT_KTL:=TCHMAT.DFLT_KTL;
                  {? TCHMAT.RKTL<>''
                  || TAB1.P_NRK:=exec('FindAndGet','#table',TKTL,TCHMAT.RKTL,,"NRK",'');
                     TAB1.P_WER:=exec('FindAndGet','#table',TKTL,TCHMAT.RKTL,,"WER",'')
                  || TAB1.P_NRK:='';
                     TAB1.P_WER:=''
                  ?};
                  TAB1.add();
                  TCHMAT.next()
               !}
            ?};
            _gr.next()
         !}
      ?}
   ?};

   {? _a=3
   ||
      {? VAR.GRUPA='T'
      || {? TAB1.first()
         || {!
            |? KOMM.add('Technologia: %1 jest używana w: %2 / %3'@[_tktl_s,TAB1.NRK,TAB1.WER],14);
               TAB1.next()
            !}
         ?}
      || {? TAB1.first()
         ||
            _msg:='Karta jest używana jako karta półfabrykatowa w innych technologiach.\n'
                  'Czy na pewno przesunąć ją do archiwum?\n\n'
                  'Karty na produkty, które używają archiwalnych kart półfabrykatowych nie mogą\n'
                  'być używane do tworzenia zleceń złożonych.'@;
            _choice:=FUN.choice(_msg,,'Szczegóły'@,'Przesuń do archiwum'@);
            {? _choice=1
            || TAB1.select()
            |? _choice=2
            ||
::             Jesli na sile chce przesunac do archiwum to czyszcze tabele powiazan
::             zeby reszta kodu myslala ze brak powiazan
               TAB1.erase()
            ?}
         ?}
      ?}

   |? _a=6
   ||
      {? _b || __who_t:=TAB1 || exec('tab2tab','#table',TAB1,'__who_t') ?};
      {? _b || __who_w:=_wer1 ?}
   |? (_a<>4 & _a<>5)
   ||
      {? TAB1.first()
      || TAB1.select()
      ||
::       Uwaga: w przypadku konieczności wyłączenia komunikatu powołać się na zadanie: 1509100617000000
         FUN.info('Brak powiązań z technologią, wzorcem, zleceniem lub kompletem.'@)
      ?}
   ?};
::   _res:={? _a<>5 || TAB1.first() ?};
   _res:=TAB1.first();
   obj_del(TAB1);
   TMAT.clear(); TCHMAT.clear(); TACTTLS.clear();
   TKTL.cntx_pop(); M.cntx_pop();
   VAR_DEL.delete('TAB1','TAB2','TAB3','__actions')
?};

M.cntx_pop(); ZL.cntx_pop();
exec('tktl_cntx_pop','tech_common');
_res


\used_tktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: GDZIE UŻYTA KARTA
::       Karty wykorzystujące tę technologię:
::       - W jakich technologiach użyto tej karty na pozycjach surowców (kontekst VAR.A_KTL)
::----------------------------------------------------------------------------------------------------------------------
exec('whohasme','tech_mater');
~~


\used_m
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: GDZIE UŻYTY PRODUKT
::       Karty wykorzystujące ten produkt:
::       - W jakich technologiach użyto produktu głównego tej karty na pozycjach surowców
::----------------------------------------------------------------------------------------------------------------------
HELP.REFMAT:=TKTL.KTM;
exec('whohasme','tech_mater',2);
~~


\used_mw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: GDZIE UŻYTY PRODUKT karty produktu
::       Karty wykorzystujące ten produkt:
::       - W jakich technologiach użyto produktu tej karty na pozycjach surowców
::----------------------------------------------------------------------------------------------------------------------
HELP.REFMAT:=TKTLW.KTM;
exec('whohasme','tech_mater',2);
~~


\surnakt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [2009] PR/WRT/PRODUKCJ/10.20/0015
:: OPIS: Procedura pokazujaca listę nieaktywnych indeksów, które są surowcami technologii przywracanej z archiwum
::   WE: _a - rodzaj kontroli
::           = 1 - kontrola nieaktywnosci indeksów karty technologicznej
::           = 3 - kontrola nieaktywnosci indeksów kart limitowych zlecenia
::       _b - ref karty technologicznej - TKTL.ref() / ref zlecenia - ZL.ref()
::       _c - maska zlecenia dla limitu
::       _d - czy komunikaty
::   WY: 1 - ok, 0 - są nieaktywne indeksy
::  OLD: \surnakt/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? _<4 || _d:=1 ?};
_SURNAKT:={? _a=1
          ||
               sql('select M.KTM, M.N
                  from M
                  left join @TMAT using(TMAT.PT,M.REFERENCE)
                  left join @TACTTLS using(TACTTLS.M,M.REFERENCE)
                  where (TMAT.NRK=:_a and M.A=\'N\')
                  or (TACTTLS.NRK=:_a and M.A=\'N\') ',_b)
          |? _a=3
          || sql('select M.KTM, M.N
                  from @ZLIM
                  join M using(ZLIM.KTM,M.REFERENCE)
                  where ZLIM.REFERENCE like \'%:_b%\' and ZLIM.ZLEC=:_a and M.A=\'N\' ',_b,_c)
          ?};

{? type_of(_SURNAKT)=type_of(~~) || exec('err_sql','#sql'); return(0) ?};

{? _SURNAKT.first()
|| {? _d=1
   || _wer:=_SURNAKT.mk_sel('Lista nieaktywnych surowców — dokonaj aktywacji indeksów KTM'@,'P',,'surnakt',10,10);
      _SURNAKT.win_fld(_wer,,'KTM',,,30,,,'KTM'@);
      _SURNAKT.win_fld(_wer,,'N',,,50,,,'Nazwa'@);
      _SURNAKT.win_sel(_wer);
      _SURNAKT.select()
   || KOMM.add('Istnieją nieaktywne indeksy — dokonaj aktywacji.'@);
      KOMM.sect_beg('Lista nieaktywnych indeksów.'@);
      _SURNAKT.first();
      {!
      |? KOMM.add(_SURNAKT.KTM+' - '+_SURNAKT.N);
         _SURNAKT.next()
      !};
      KOMM.sect_end()
   ?};
   0
|| 1
?}


\set_default
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ustawia domyślną technologię wytworzenia półfabrykatu w tabeli TMAT lub TCHMAT
::       Działa w kontekście rekordu cur_tab(1,1) w formule exec('whohasme','tech_mater')
::  OLD: \set_default/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab1:=cur_tab(1,1);

{? _tab1.TORW='Z'
|| {? _tab1.SU<>'N-P-U'@
   || _txt:='Karta zlecenia: %1 — nie można modyfikować surowca technologii zlecenia.'@
            [_tab1.NRK]
   || _txt:='Karta zlecenia: %1 — nie można modyfikować materiału wykorzystanego jako N-P-U w technologii zlecenia.'@
            [_tab1.NRK]
   ?};
   {? VAR.GRUPA='T'
   || KOMM.add(_txt)
   || FUN.emsg(_txt)
   ?};
   return()
|? _tab1.TORW='R'
|| _txt:='Zgłoszenie remontowe: %1 — funkcja nie dotyczy zapisów pochodzących ze zgłoszeń remontowych.'@[_tab1.NRK];
   {? VAR.GRUPA='T'
   || KOMM.add(_txt)
   || FUN.emsg(_txt)
   ?};
   return()
|? _tab1.TYP=exec('k_res_string','tech_head')
|| _txt:='Karta kompletacyjna: %1 — funkcja nie dotyczy składowej.'@
         [_tab1.NRK];
   {? VAR.GRUPA='T'
   || KOMM.add(_txt)
   || FUN.emsg(_txt)
   ?};
   return()
|? _tab1.SU='N-P-U'@
|| _txt:='Karta: %1 wersja: %2 — materiał wykorzystywany jako N-P-U nie może mieć przypisanej technologii domyślnej.'@
         [_tab1.NRK,_tab1.WER];
   {? VAR.GRUPA='T'
   || KOMM.add(_txt)
   || FUN.emsg(_txt)
   ?};
   return()
?};

exec('tktl_cntx_psh','tech_common');
TMAT.clear(); TCHMAT.clear(); TKTL.clear();

{? _tab1.SU='Surowiec'@ || _tab:=TMAT || _tab:=TCHMAT ?};

{? _tab.seek(_tab1.TMATREF,)
|| _tab.NRK();
::   exec('set_tmask','trights',TKTL.TMASK);
   {? TKTL.TYP().PAR='T' & exec('is_param','tech_head',TKTL.ref())
   || _txt:={? _tab1.TORW='T'
            || 'Karta: %1 wersja: %2 — jest parametryzowana.'@[_tab1.NRK,_tab1.WER]
            || 'Wzorzec: %1 wersja: %2 — jest parametryzowany.'@[_tab1.NRK,_tab1.WER]
            ?};
      {? VAR.GRUPA='T'
      || KOMM.add(_txt)
      || FUN.emsg(_txt)
      ?}
   |? _tab.DFLT_KTL='T'
   || _txt:={? _tab1.TORW='T'
            || 'Karta: %1 wersja: %2 — surowiec już ma wskazaną technologię domyślną.'@[_tab1.NRK,_tab1.WER]
            || 'Wzorzec: %1 wersja: %2 — surowiec już ma wskazaną technologię domyślną.'@[_tab1.NRK,_tab1.WER]
            ?};
      {? VAR.GRUPA='T'
      || KOMM.add(_txt)
      || FUN.emsg(_txt)
      ?}
   |? TKTL.STAN='T' & exec('can_modify','tech_common')=0
   || _txt:={? _tab1.TORW='T'
            || 'Karta: %1 wersja: %2 — zaakceptowana.'@[_tab1.NRK,_tab1.WER]
            || 'Wzorzec: %1 wersja: %2 — zaakceptowany.'@[_tab1.NRK,_tab1.WER]
            ?};
      {? VAR.GRUPA='T'
      || KOMM.add(_txt)
      || FUN.emsg(_txt)
      ?}
   |? TKTL.STAN<>'T' & TKTL.STAT_S='T'
   || _txt:={? _tab1.TORW='T'
            || 'Karta: %1 wersja: %2 — ma zatwierdzoną listę surowców.'@[_tab1.NRK,_tab1.WER]
            || 'Wzorzec: %1 wersja: %2 — ma zatwierdzoną listę surowców.'@[_tab1.NRK,_tab1.WER]
            ?};
      {? VAR.GRUPA='T'
      || KOMM.add(_txt)
      || FUN.emsg(_txt)
      ?}
   |? ~TKTL.r_lock(1,1,1)
   || _txt:={? _tab1.TORW='T'
            || 'Karta: %1 wersja: %2 — jest redagowana przez innego użytkownika.'@[_tab1.NRK,_tab1.WER]
            || 'Wzorzec: %1 wersja: %2 — jest redagowany przez innego użytkownika.'@[_tab1.NRK,_tab1.WER]
            ?};
      {? VAR.GRUPA='T'
      || KOMM.add(_txt)
      || FUN.emsg(_txt)
      ?}
   || {? {? VAR.GRUPA='T'
         || 1
         || FUN.ask(
               'Czy ustawić domyślną technologię dla półfabrykatu?\n\n'
               'Uwaga: zostanie usunięte bezpośrednie odwołanie do karty wykonawczej półfabrykatu.'@
            )
         ?}
      || _tab.DFLT_KTL:='T';
         _tab.KTL:=null();
         _tab.RKTL:='';
         {? _tab.put()
         || _tab1.DFLT_KTL:='T';
            _tab1.P_NRK:='';
            _tab1.P_WER:='';
            _tab1.put()
         ?}
      ?};
      TKTL.r_unlock()
   ?}
?};

exec('tktl_cntx_pop','tech_common');
~~


\set_default_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ustawia domyślną technologię wytworzenia półfabrykatu w tabeli TMAT lub TCHMAT - przed grupą rekordów
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask(
      'Czy ustawić domyślną technologię dla zaznaczonych\n'
      'wystąpień półfabrykatu w kartach technologicznych/wzorcach?\n\n'
      'Uwagi:\n'
      '• Usunięte zostaną bezpośrednie odwołania do kart wykonawczych półfabrykatów.'@
   )
|| KOMM.init(,,'Ustawianie domyślnej technologii dla półfabrykatów'@);
   VAR.GRUPA:='T';
   1
|| 0
?}


\set_default_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Ustawia domyslną technologię wytworzenia półfabrykatu w tabeli TMAT lub TCHMAT - po grupie rekordów
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\tmatchng
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Obsługa zamiany surowca w karcie technologicznej zlecenia
::  OLD: \zmatchng/zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_rodzaj:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT().R || TMAT.PT().R ?};
_ktm_sym:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT().KTM || TMAT.PT().KTM ?};
{? (_rodzaj='P' | _rodzaj='W') & (TMAT.DFLT_KTL='T' | TMAT.RKTL<>'') & TMAT.MAG<>'T'
|| {? TMAT.NRK().ZL().NRNZL<>0
   || _zl2del:=exec('is_zl4tmat','zl_link',TMAT.ref());
      _sym:=exec('FindAndGet','#table',ZL,_zl2del,,"SYM",'');
      {? _zl2del
      || KOMM.init(,,'Zamiana surowca zlecenia %1'@[_sym]);
         {? exec('zl_usun_chk','zl_head',_zl2del,0,0)
         || _txt:='Po zamianie półfabrykatu %1, zostanie usunięte zlecenie półfabrykatowe %2.'@[_ktm_sym,_sym];
            _ok:=FUN.ask(_txt+'\n\n'+'Czy mimo tego chcesz zmodyfikować wskazany surowiec?'@)
         || KOMM.select();
            _ok:=0
         ?}
      || _ok:=1
      ?}
   || _ok:=1
   ?}
|| _ok:=1
?};

{? _ok
|| _result:=exec('pokaz_zam_mech','tech_mater',0);
   {? _result
   ||
::    Próbuję usunąć limity
      ZLIM.cntx_psh();
      exec('openmask','zl_common',ZL.ref());
      ZLIM.index('RTMAT');
      ZLIM.prefix($TMAT.ref());
      {? ZLIM.first()
      || {!
         |? ZLIM.cntx_psh(); {? ZLIM.next() || _next:=ZLIM.ref() || _next:=null() ?}; ZLIM.cntx_pop();
            _ok:=exec('ZLIM_del_brut','zl_limit',1,0);
            ZLIM.seek(_next) & _ok>0
         !}
      ?};
      ZLIM.cntx_pop();

      _zl2del:=exec('is_zl4tmat','zl_link',TMAT.ref());
      {? _zl2del || exec('zl_usun','zl_head',_zl2del,,0) ?}
   ?}
|| _result:=0
?};
_result


\drk_zam
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Zamienniki surowców w analizie wykonania
::  OLD: \drk_zam/drukujp.fml
::----------------------------------------------------------------------------------------------------------------------
rep_exec('tte_drukzam',,1);
1


\tmatpoz
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: wyświetla pozycje z jakich składa się surowiec użyty w technologii
::  OLD: \tmatpoz/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_env_mater:=exec('env_mater','tech_mater');
_env_mater.used:=1;
params_set('env_mater',_env_mater);

{? TMAT.DFLT_KTL='T'
|| _ktl:=exec('dflt_ktl','tech_prod',{? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?})
|| _ktl:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,,null())
?};
:: brak domyslnej albo wskazanej - brana jest pierwsza wg alfabetu karta zatwierdzona
{? _ktl=null()
|| _ktl:=exec('first_akc_ktl','tech_prod',TMAT.PT)
?};
:: brak zatwierdzonej - brana jest pierwsza wg alfabetu karta
{? _ktl=null()
|| _ktl:=exec('first_any_ktl','tech_prod',TMAT.PT)
?};

{? _ktl=null()
|| FUN.emsg('Surowiec nie posiada karty technologicznej.'@)
||
   TKTL.cntx_psh();
   TKTL.use(ref_name(_ktl));
   TKTL.clear();
   {? TKTL.seek(_ktl) || _xjm:=TKTL.XJM || _xjm:=1 ?};
   TKTL.cntx_pop();

   TMAT.cntx_psh();
   exec('surx_decl','tech_mater');
::-------------------------------------------------------------------------
:: inicjowanie obiektu klasy SURX i selekcja listy surowców technologii
::-------------------------------------------------------------------------
   VAR_DEL.delete('__S');
   _fazy:=FUN.ask('Czy wyświetlać z rozbiciem na fazy produkcji?'@);
   __S:=obj_new(@.CLASS.SURX,_ktl,'T',_fazy,,_xjm);
:: Można zamienić na __S.tree(), ale trzeba zdefiniować metodę wirtualną!
   __S.select();
   obj_del(__S);
   TMAT.cntx_pop();
   TMAT.KTL<>null()
?}


\surx_decl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [TS] - 2001/10/23 - [7.53] OWwPR011/5.7
:: OPIS: Obiekt klasy SURX uzywa tabeli tymczasowej do wyswietlenia
::       listy wszystkich surowcow eliminujac powtorzenia.
::       Pozwala rekurencyjnie wyswietlac liste surowcow skladowych.
::   WE: _b - ref() odpowiednio karty technologicznej lub wykonawczej
::               dla zlecenia (patrz arg. _c).
::       _c - Zastosowanie dla listy surowcow do karty technologicznej
::               (_c='T') lub karty wykonawczej zlecenia (_c='Z').
::  OLD: \surx_decl/sur_obj.fml
::----------------------------------------------------------------------------------------------------------------------
:: deklaracja klasy 'SURX'
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('SURX',@.CLASS) < 0
|| obj_decl('SURX',
::     czy Technologia, czy Zlecenie
obj_fld('TZ',''),
obj_fld('TZZ',''),
::     wskazanie na obiekt - sam na siebie
obj_fld('ME',null()),
::     tabela tymczasowa
obj_fld('TAB',null()),
obj_fld('TAB1',null()),
obj_fld('NODS',null()),
::     indeksy tabeli tymczasowej
obj_fld('NDX1',''),
obj_fld('NDXT1',''),
obj_fld('NDXT3',''),
obj_fld('NDX2',''),
obj_fld('NDX3',''),
obj_fld('NDX3a',''),
obj_fld('NDX4',''),
obj_fld('NDX5',''),
obj_fld('NDX6',''),
::     okna tabeli tymczasowej
obj_fld('RED',''),
obj_fld('RED1',''),
obj_fld('WER1',''),
obj_fld('WER2',''),
::     roboczy nr węzła i up-node
obj_fld('NODE',0),
obj_fld('UPNODE',0),
::     roboczy kod towaru, którego lista surowców jest rozpisywana
obj_fld('UP_T',0),
::     roboczy kod technologii, której lista surowców jest rozpisywana
obj_fld('UP_KTL',0),
::     aktualne przeliczniki dla normy netto i brutto
obj_fld('RTKTL',''),
obj_fld('COEFN',1),
obj_fld('COEFB',1),
obj_fld('ILOSC',1),
obj_fld('DIV',0),
::     czy wyświetlanie z rozbiciem na fazy
obj_fld('FAZ',1),
::     czy uwzględniać datę (ma znaczenie przy doborze wersji składowych)
obj_fld('DATE',date()),

obj_meth('__init',"
::---------------------------------------------------------------------------------------------------------------------"

:: Wszystkim tabelom zwiazanym z technologiami robie cntx_psh
   exec('tktl_cntx_psh','tech_common');
   PLRELWYR.cntx_psh();

   TKTL.clear();
   PFAZ.cntx_psh();
   M.cntx_psh();
   M.clear();
   .ME:=_a;
   {? var_pres('ppar',@)<=0 || ppar:=obj_new(@.CLASS.TPAr) ?};
   .TZ:=_c;
   {? _>5 || .ILOSC:=_f || .ILOSC:=1 ?};
   {? var_pres('_g')=type_of(date()) || .DATE:=_g || .DATE:=date() ?};
   .cr_tab();
   .indeksy();
   {? .TZ='T' | .TZ='W' | .TZ='Z' | .TZ='#'
   ||
      {? .TZ='#' || .TZ:='T'; .DIV:=1 ?};

      _msk:=((8+ref_name(_b))+3);

::    Wszystkim tabelom zwiazanym z technologiami otwieram odpowiednią maskę
      exec('tktl_use','tech_common',_msk);
      .RTKTL:=$_b;

      .t_load(_b);
      .FAZ:=_d
   |? .TZ='P'
   || FUN.info('Metoda nieaktywna: %1.'@['p_load()']);
      .p_load(_b,_d)
   |? .TZ='K'
   ||
      _msk:=((8+ref_name(_b))+3);

::    Wszystkim tabelom zwiazanym z technologiami otwieram odpowiednią maskę
      exec('tktl_use','tech_common',_msk);

      FUN.info('Metoda nieaktywna: %1.'@['k_load()']);
      .k_load(_b,0)
   |? .TZ='A'
   ||
      .FAZ:=_d;
      _msk:=((8+ref_name(_b))+3);

::    Wszystkim tabelom zwiazanym z technologiami otwieram odpowiednią maskę
      exec('tktl_use','tech_common',_msk);
      .RTKTL:=$_b;

      .a_load()
   ?};
   {? 'PKA'*.TZ=0 || .count(0) ?};
   ~~
"),

obj_meth('cr_tab',"PRIVATE";"
   .TAB:=tab_tmp(2,
       'UPNODE','TREE_REF','Up-node',
       'PT_S','STRING[50]','Materiał M.KTM',
       'NODE','INTEGER','Node',
       'LP','INTEGER','Lp',
       'PT','INTEGER','Materiał #M.ref()',
       'TMAT','INTEGER','Surowiec #TMAT.ref()',
       'RTMAT','STRING[16]','Surowiec $TMAT.ref()',
       'SCIEZKA','STRING[20]','Ścieżka',
       'GR','INTEGER','Grupa',
       'PT_N','STRING[100]','Nazwa M.N',
       'PT_JM','STRING[10]','jm M.J().KOD',
       'PFAZ','INTEGER','Faza #PFAZ.ref()',
       'PFAZ_S','STRING[10]','Faza PFAZ.KOD',
       'WARN','REAL','Norma netto',
       'WARB','REAL','Norma brutto',
       'RKTL','STRING[16]','Karta technologiczna $TKTL.ref()',
       'KTL_NRK','STRING[50]','Nr karty technologicznej półfabrykatu',
       'KTL_WER','STRING[6]','Wersja karty technologicznej półfabrykatu',
       'UP_T','INTEGER','Uptow',
       'ILOSC','INTEGER','Ilość',
       'UP_KTL','INTEGER','Up-KTL',
       'WPM','STRING[1]','WPM',
       'SO','STRING[1]','SO',
       'POW','STRING[1]','Powierzony',
       'ZAM','STRING[1]','Zamiennik',
       'GRE','STRING[1]','Element grupy',
       'STAN','REAL','Stan bieżący',
       'PAR','STRING[1]','Prametry',
       'SUR','STRING[1]','Surowce do operacji',
       'XJM','REAL','XJM karty technologicznej'
   );
::   .TAB.fld_attr(,2);
   .TAB.fld_attr('WARN',3);
   .TAB.fld_attr('WARB',3);

   .TAB1:=tab_tmp(2,
       'UPNODE','TREE_REF','Up-node',
       'PT_S','STRING[50]','Materiał M.KTM',
       'PT_N','STRING[100]','Materiał M.N',
       'PT_JM','STRING[10]','jm M.J().KOD',
       'LP','INTEGER','Lp.',
       'PFAZ','INTEGER','Faza #PFAZ.ref()',
       'PFAZ_S','STRING[10]','Faza PFAZ.KOD',
       'PT','INTEGER','Materiał #M.ref()',
       'WARB','REAL','Norma netto',
       'ILD','REAL','Dostępne',
       'UP_T','INTEGER','Uptow',
       'UP_KTL','INTEGER','Up-KTL',
       'WPM','STRING[1]','WPM',
       'TT','REAL','Tt',
       'KIEDY','DATE','Nk',
       'WDR','REAL','W drodze',
       'SO','STRING[1]','SO',
       'POW','STRING[1]','Powierzony',
       'RKTL','STRING[16]','Karta technologiczna $TKTL.ref()',
       'KTL_NRK','STRING[50]','Nr karty technologicznej półfabrykatu',
       'KTL_WER','STRING[6]','Wersja karty technologicznej półfabrykatu',
       'NODE','INTEGER','Node'
   );
::   .TAB1.fld_attr(,2);
   .TAB1.fld_attr('WARB',3);

   .NODS:=tab_tmp(1,
       'OLD','INTEGER','stare',
       'NEW','INTEGER','nowe'
   );
   ~~
"),

obj_meth('__done',"

:: Wszystkim tabelom zwiazanym z technologiami robię cntx_pop
   exec('tktl_cntx_pop','tech_common');
   PFAZ.cntx_pop();
   M.cntx_pop();
   PLRELWYR.cntx_pop();
   VAR_DEL.delete('ppar');
:  .TAB.ndx_drop();
   ~~
"),

obj_meth('indeksy',"
:  .NDX1:=.TAB.ndx_tmp('L.p.',0,'UPNODE',,,'PT_S',,);
   .NDX1:=.TAB.index('?');
   .NDX2:=.TAB.ndx_tmp('Faza+Materiał',1,'UPNODE',,,'PFAZ',,,'PT',,,'UP_T',,,'RKTL',,);
   .NDX3:=.TAB.ndx_tmp('KTL+Faza+Materiał',1,'RKTL',,,'PFAZ_S',,,'PT_S',,);
   .NDX3a:=.TAB.ndx_tmp('KTL+Materiał',1,'RKTL',,,'PT_S',,);
   .NDX4:=.TAB.ndx_tmp('PT_S',0,'PT_S',,,'PFAZ',,);
   .NDX5:=.TAB.ndx_tmp('NODE',0,'NODE',,);
   .NDX6:=.TAB.ndx_tmp('+KTL+Faza+Materiał',1,'UPNODE',,,'RKTL',,,'PFAZ',,,'PT',,);
:  .NDXT1:=.TAB1.ndx_tmp('L.p.',0,'UPNODE',,,'LP',,);
   .NDXT1:=.TAB1.index('?');
   .NDXT3:=.TAB1.ndx_tmp('KTL+Faza+Materiał',1,'RKTL',,,'PFAZ_S',,,'PT_S',,);
   ~~
"),


obj_meth('t_load',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Metoda prywatna, ładuje dane z karty technologicznej
::       (opcjonalnie na wybraną datę, opcjonalnie na zadaną ilość)
::   WE: _a - TKTL.ref()
::       [_b] - obj_new - obiekt klasy @.CLASS.TPAr zawierajacy przeliczone
::                        wartosci parametrow na wyzszym poziomie. Jesli nie podane
::                        to parametry inicjuje na podstawie _a
::       [_c] - REAL - XJM karty technologicznej
::----------------------------------------------------------------------------------------------------------------------
   Cntx.psh(TKTL,TMAT,TOPER);

   _tktl:=_a;
   _tpar_parent:=~~;
   {? var_pres('_b')>100
   || _tpar_parent:=_b
   ?};
   _xjm:=0;
   {? var_pres('_c')=type_of(0)
   || _xjm:=_c
   ?};

   {? _tktl<>null()
   ||
::    Otwieramy odpowiednia maske TKTL, TMAT, TOPER
      _mask:=ref_name(_tktl);
      {? TKTL.name()<>_mask
      || TKTL.use(_mask);

         _msk_tmat:=form((TMAT.name()-3)+(_mask+3));
         TMAT.use(_msk_tmat);

         _msk_toper:=form((TOPER.name()-3)+(_mask+3));
         TOPER.use(_msk_toper)
      ?};
      Cntx.clr(TKTL);

      {? TKTL.seek(_tktl)
      ||
::       Jesli argument _b nie zostal podany to inicjuje TPAr wyzszego poziomu z
::       biezacej technologii pobierajac wartosci domyslne dla karty
         {? type_of(_tpar_parent)<100 & TKTL.TYP().PAR='T'
         || _tpar_parent:=obj_new(@.CLASS.TPAr);
            _tpar_parent.TABLE:=TPAR;
            _tpar_parent.INDEX:='NN';
            _tpar_parent.PREFIX:=TKTL.ref();
::          Ładuje domyślne wartości
            _tpar_parent.loadp(ref_name(TKTL.ref())+3)
         ?};

         TMAT.index('NNL');
         TMAT.prefix(TKTL.ref());
         .UP_T:=TKTL.KTM;
         .TZZ:=.TZ;
         .UP_KTL:=TKTL.ref();
         {? TMAT.first()
         || _i:=0;
            {!
            |?
::             Sprawdzam czy w ogole dodawac TMATa
               _tmat_exist:=1;
               {? _tmat_exist>0 & TMAT.SO='O'
               || {? .TZ*'I'=1
                  || _tmat_exist:=0
                  ?}
               ?};

               {? _tmat_exist>0 & TMAT.ACT='N'
               || _tmat_exist:=0
               ?};

               {? _tmat_exist>0 & TKTL.TYP().PAR='T' & _tpar_parent.calc(TMAT.EXIST)<=0
               || _tmat_exist:=0
               ?};

               {? _tmat_exist>0 & TKTL.TYP().PAR='T' & TMAT.NROP<>null()
               || {? _tpar_parent.calc(TMAT.NROP().EXIST)<=0
                  || _tmat_exist:=0
                  ?}
               ?};

               {? _tmat_exist>0
               ||
                  .tabprefix();
                  _i+=1;
                  .TAB.LP:=_i;
                  .TAB.TMAT:=#TMAT.ref();
                  .TAB.RTMAT:=$TMAT.ref();
                  .TAB.PAR:=TMAT.NRK().TYP().PAR;
                  .TAB.SUR:=TMAT.NRK().TYP().SUR;
::
                  _ktl:=null();
                  _mag:='N';
                  _added:=0;
                  _arch:='N';
                  {? var_pres('__ENV_STR')>0 & var_pres('TAB_ZAM',__ENV_STR.CHECK)>0 & __ENV_STR.CHECK.TAB_ZAM.find_tab(,'TMAT',,'=',$TMAT.ref)
                  || _ktl:=exec('FindAndGet','#table',TKTL,__ENV_STR.CHECK.TAB_ZAM.KTLW,,,null());
                     _mag:=TMAT.MAG
                  ||
                     {? .TZ<>'P' & exec('is_k_res','tech_head',exec('FindAndGet','#table',TKTL,TMAT.NRK,,\"TYP\",null()))
                     || _ktl:=exec('skl_ktl','material',TMAT.PT,.DATE);
                        _mag:=TMAT.MAG
                     |? TMAT.DFLT_KTL='T'
                     || _ktl:=exec('dflt_ktl','tech_prod',{? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?},,1);
                        _mag:=TMAT.MAG;
                        {? _ktl=null()
                        || _txt:='Brak karty domyślnej'@;
                           _added:=1
                        |? ~exec('tktl_act','tech_head',,$_ktl)
                        || _txt:='Karta domyślna nieaktualna'@;
                           _added:=1
                        ?}
                     || _ktl:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,,null());
                        _mag:=TMAT.MAG;
                        {? _ktl<> null
                        || _arch:=exec('FindAndGet','#table',TKTL,_ktl,,'ARCH','N');
                           {? _arch<>'N'
                           || _txt:='Karta archiwalna'@;
                              _added:=1
                           |? ~exec('tktl_act','tech_head',4)
                           || _txt:='Karta nieaktualna'@;
                              _added:=1
                           ?}
                        ?}
                     ?}
                  ?};
                  {? _added=1
                  || exec('tktl_chck_add','tech_structure',$_ktl,$TMAT.ref,_txt,TMAT.PT().N,
                           exec('FindAndGet','#table',TKTL,_ktl,,'NRK',''),exec('FindAndGet','#table',TKTL,_ktl,,'WER',''),
                           $TMAT.PT,{? _arch<>'N' || 'T' || 'N' ?})
                  ?};

                  {? var_pres('_tpar_my')>100
                  || obj_del(_tpar_my)
                  ?};

                  {? TKTL.TYP().PAR='T'
                  ||
::                   Obsluga translacji parametrow
::                   Tworze obiekt z parametrami na moim poziomie
                     _tpar_my:=obj_new(@.CLASS.TPAr,TMAT.PT);
                     _tpar_my.TABLE:=TPAR;
                     _tpar_my.INDEX:='NN';
::                   Ładuje obiekt z parametrami na moim poziomie
                     _tpar_my.PREFIX:=_ktl;
                     _tpar_my.loadp(ref_name(_ktl)+3);
::                   Przeliczam wartosci uwzgledniajac translacje
                     _tpar_my.mod_tra(TMAT.ref(),,_tpar_parent,ref_name(TMAT.ref())+3)
                  || _tpar_my:=~~
                  ?};

::                Przekazuje do funkcji dodajacej rekord obiekt z przeliczonymi
::                parametrami wyzszego poziomu
                  .tab_add(_tpar_parent);

                  {? .TAB.put()
                  ||
                     {? _ktl<>null() & (_mag='N' | _mag='P')
                     ||
                        .TAB.cntx_psh();
                        TMAT.cntx_psh();
                        .UPNODE:=.NODE;
                        _t:=.UP_T;

::                      !!! REKURENCJA !!!
                        {? _added=0 || .t_load(_ktl,_tpar_my) ?};

                        TMAT.cntx_pop();
                        .TAB.cntx_pop();
                        .UPNODE:=.TAB.UPNODE;
                        .UP_T:=_t
                     ?}
                  ?}
               ?};
               TMAT.next()
            !}
         ?}
      ?}
   ?};

   Cntx.pop(TKTL,TMAT,TOPER);
   ~~
"),

obj_meth('tabprefix',"
   {? .TZ<>'A'
   ||
      .TAB.index(.NDX2);
      _mag:='N';
      _added:=0;
      _arch:='N';
      {? var_pres('__ENV_STR')>0 & var_pres('TAB_ZAM',__ENV_STR.CHECK)>0 & __ENV_STR.CHECK.TAB_ZAM.find_tab(,'TMAT',,'=',$TMAT.ref)
      || _ktl:=exec('FindAndGet','#table',TKTL,__ENV_STR.CHECK.TAB_ZAM.KTLW,,,null());
         _mag:=TMAT.MAG
      ||
         {? .TZ<>'P' & exec('is_k_res','tech_head',exec('FindAndGet','#table',TKTL,TMAT.NRK,,\"TYP\",null()))
         || _ktl:=exec('skl_ktl','material',TMAT.PT,.DATE);
            _mag:=TMAT.MAG
         |? TMAT.DFLT_KTL='T'
         || _ktl:=exec('dflt_ktl','tech_prod',{? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?},,1);
            _mag:=TMAT.MAG;
            {? _ktl=null()
            || _txt:='Brak karty domyślnej'@;
               _added:=1
            |? ~exec('tktl_act','tech_head',,$_ktl)
            || _txt:='Karta domyślna nieaktualna'@;
               _added:=1
            ?}
         || _ktl:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,,null());
            _mag:=TMAT.MAG;
            {? _ktl<> null
            || _arch:=exec('FindAndGet','#table',TKTL,_ktl,,'ARCH','N');
               {? _arch<>'N'
               || _txt:='Karta archiwalna'@;
                  _added:=1
               |? ~exec('tktl_act','tech_head',4)
               || _txt:='Karta nieaktualna'@;
                  _added:=1
               ?}
            ?}
         ?}
      ?};
      {? _added=1
      || exec('tktl_chck_add','tech_structure',$_ktl,$TMAT.ref,_txt,TMAT.PT().N,
            exec('FindAndGet','#table',TKTL,_ktl,,'NRK',''),exec('FindAndGet','#table',TKTL,_ktl,,'WER',''),
            $TMAT.PT,{? _arch<>'N' || 'T' || 'N' ?})
      ?};
      {? .FAZ=1
      || .TAB.prefix(.UPNODE,#TMAT.PFAZ,{? TMAT.GRKTM='G'|| #TMAT.TGDFLT().PT || #TMAT.PT ?},#.UP_T,{? _mag='T' || '' || $_ktl ?},)
      || .TAB.prefix(.UPNODE,0,{? TMAT.GRKTM='G'|| #TMAT.TGDFLT().PT || #TMAT.PT ?},#.UP_T,{? _mag='T'|| '' || $_ktl ?},)
      ?}
   ||
      .TAB.index(.NDX6);
      {? .FAZ=1
      || .TAB.prefix(.UPNODE,$TMAT.KTL,#TMAT.PFAZ,{? TMAT.GRKTM='G'|| #TMAT.TGDFLT().PT || #TMAT.PT ?})
      || .TAB.prefix(.UPNODE,$TMAT.KTL,0,{? TMAT.GRKTM='G'|| #TMAT.TGDFLT().PT || #TMAT.PT ?})
      ?}
   ?};
   ~~
"),


obj_meth('tab_add',"
:: Obiekt TPAr zawierajacy przeliczone wartosci parametrow z wyzszego poziomu
   _tpar:=_a;
   _xjm:=0;
   {? var_pres('_b')=type_of(0)
   || _xjm:=_b
   ?};

   TMAT.cntx_psh();
   .TAB.clear();

   .NODE+=1;
   .TAB.UPNODE:=.UPNODE;
   .TAB.NODE:=.NODE;
   .TAB.ILOSC:=.ILOSC;
   .TAB.SCIEZKA:=exec('get_oper_nr','tech_oper',TMAT.NROP().UNROP,'\\\\','n');
   {? TMAT.GRKTM='G'
   ||.TAB.PT:=#TMAT.TGDFLT().PT;
     .TAB.PT_S:=TMAT.TGDFLT().PT().KTM;
     .TAB.PT_N:=M.N;
     .TAB.PT_JM:=M.J().KOD
   ||.TAB.PT:=#TMAT.PT;
     .TAB.PT_S:=TMAT.PT().KTM;
     .TAB.PT_N:=M.N;
     .TAB.PT_JM:=M.J().KOD
   ?};
   .TAB.PFAZ:={? .FAZ=1 || #TMAT.PFAZ || 0 ?};
   .TAB.PFAZ_S:={? .FAZ=1 || TMAT.PFAZ().KOD || '' ?};
   .TAB.GR:=#TMAT.TGRP;
   _added:=0;
   _arch:='N';
   {? var_pres('__ENV_STR')>0 & var_pres('TAB_ZAM',__ENV_STR.CHECK)>0 & __ENV_STR.CHECK.TAB_ZAM.find_tab(,'TMAT',,'=',$TMAT.ref)
   || _ktl:=exec('FindAndGet','#table',TKTL,__ENV_STR.CHECK.TAB_ZAM.KTLW,,,null());
      _mag:=TMAT.MAG
   ||
      {? .TZ<>'P' & exec('is_k_res','tech_head',exec('FindAndGet','#table',TKTL,TMAT.NRK,,\"TYP\",null()))
      || _ktl:=exec('skl_ktl','material',TMAT.PT,.DATE);
         _mag:=TMAT.MAG
      |? TMAT.DFLT_KTL='T'
      || _ktl:=exec('dflt_ktl','tech_prod',{? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?},,1);
         _mag:=TMAT.MAG;
         {? _ktl=null()
         || _txt:='Brak karty domyślnej'@;
            _added:=1
         |? ~exec('tktl_act','tech_head',,$_ktl)
         || _txt:='Karta domyślna nieaktualna'@;
            _added:=1
         ?}
      || _ktl:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,,null());
         _mag:=TMAT.MAG;
         {? _ktl<> null
         || _arch:=exec('FindAndGet','#table',TKTL,_ktl,,'ARCH','N');
            {? _arch<>'N'
            || _txt:='Karta archiwalna'@;
               _added:=1
            |? ~exec('tktl_act','tech_head',4)
            || _txt:='Karta nieaktualna'@;
               _added:=1
            ?}
         ?}
      ?}
   ?};
   {? _added=1
   || exec('tktl_chck_add','tech_structure',$_ktl,$TMAT.ref,_txt,TMAT.PT().N,
         exec('FindAndGet','#table',TKTL,_ktl,,'NRK',''),exec('FindAndGet','#table',TKTL,_ktl,,'WER',''),
         $TMAT.PT,{? _arch<>'N' || 'T' || 'N' ?})
   ?};
   .TAB.RKTL:={? _mag='N' || $_ktl || '' ?};
   .TAB.KTL_NRK:='';
   .TAB.KTL_WER:='';
   {? .TAB.RKTL<>''
   || TKTL.cntx_psh();
      TKTL.use(form(8+.TAB.RKTL));
      TKTL.clear();
      {? TKTL.seek(.TAB.RKTL)
      || .TAB.KTL_NRK:=TKTL.NRK;
         .TAB.KTL_WER:=TKTL.WER
      ?};
      TKTL.cntx_pop();
      ~~
   ?};
   {? _xjm>0
   || .TAB.XJM:=_xjm
   |? .TAB.RKTL<>''
   || .TAB.XJM:=exec('FindAndGet','#table',TKTL,.TAB.RKTL,,,\"XJM\",1)
   || .TAB.XJM:=TMAT.NRK().XJM
   ?};
   _mag:='N';

   {? TMAT.RKTL<>'' | TMAT.DFLT_KTL='T' || .TAB.WPM:='P' || .TAB.WPM:='M' ?};
   .TAB.UP_T:=#.UP_T;
   .TAB.UP_KTL:=#.UP_KTL;
   .TAB.SO:=TMAT.SO;
   .TAB.POW:=TMAT.POW;

   _znak:={? TMAT.SO='O'
          || -1
          || 1
          ?};
   {? TMAT.FORMN<>''
   || .TAB.WARN:=_tpar.calc(TMAT.FORMN)*_znak
   || .TAB.WARN:=TMAT.WARN*_znak
   ?};
   {? TMAT.FORMB<>''
   || .TAB.WARB:=_tpar.calc(TMAT.FORMB)*_znak
   || .TAB.WARB:=TMAT.WARB*_znak
   ?};

   _dokl:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT().DOKL || TMAT.PT().DOKL ?};
   {? _dokl=0
   || .TAB.WARB:=ceil(.TAB.WARB);
      .TAB.WARN:=ceil(.TAB.WARN)
   || .TAB.WARB:=.TAB.WARB$_dokl;
      .TAB.WARN:=.TAB.WARN$_dokl
   ?};
   .TAB.add();

   TMAT.cntx_pop();
   ~~
"),

obj_meth('p_load',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Metoda prywatna.
::       To samo, co t_load(), ale dla analizy wykonania produkcji -
::       dalej rekurencyjnie wola t_load() - uzyta w __init()
::----------------------------------------------------------------------------------------------------------------------
   FUN.info('Metoda nieaktywna: %1.'@['p_load()']);
   PLRELWYR.first();
   .TZZ:=.TZ;
   .UP_T:=PLRELWYR.TOWAR;
   .UP_KTL:=PLRELWYR.TECH;
   {? PLRELWYR.first()
   || _i:=0;
      _ok:=.ltpar();

      {!
      |?
         .TAB.index(.NDX2);
         M.cntx_psh();
         M.clear();
         {? M.seek(PLRELWYR.TOWAR)
         || _pt:=M.ref();
            _pt_s:=M.KTM;
            _pt_n:=M.N;
            _pt_jm:=M.J().KOD
         || _pt:=null();
            _pt_s:=_pt_n:=_pt_jm:=''
         ?};
         M.cntx_pop();
         .TAB.prefix(.UPNODE,0,#_pt,#.UP_T,$PLRELWYR.TKTL);
         {? .TAB.first()
         || .TAB.WARN+=1;
            .TAB.WARB+=PLRELWYR.ILOSC;
            .TAB.put()
         || _i+=1;
            .NODE+=1;
            .TAB.UPNODE:=.UPNODE;
            .TAB.NODE:=.NODE;
            .TAB.LP:=_i;
            .TAB.SCIEZKA:='';
            .TAB.ILOSC:=.ILOSC;
            .TAB.PT:=#_pt;
            .TAB.PT_S:=_pt_s;
            .TAB.PT_N:=_pt_n;
            .TAB.PT_JM:=_pt_jm;
            .TAB.PFAZ:=0;
            .TAB.PFAZ_S:='';
            .RTKTL:=PLRELWYR.RTKTL;
            .TAB.RKTL:=PLRELWYR.RTKTL;
            .TAB.WARN:=PLRELWYR.ILOSC;
            .TAB.WARB:=PLRELWYR.ILOSC;
            .TAB.UP_T:=#.UP_T;
            .TAB.UP_KTL:=#.UP_KTL;
            {? _ok || .ltpar1() || _ok:=.ltpar() ?};
            {? .TAB.add()
            || {? PLRELWYR.RTKTL<>''
               || .TAB.cntx_psh();
                  PLRELWYR.cntx_psh();
                  .UPNODE:=.NODE;
                  TMAT.clear();
                  _tktl:=exec('FindAndGet','#table',TKTL,PLRELWYR.RTKTL,,,null());

::                Laduje parametry domyslne dla analizy
::                te parametry beda podstawa aby wyliczyc normy surowcow na poziomach nizej
                  {? var_pres('_tpar')>100
                  || obj_del(_tpar)
                  ?};
                  _tpar:=obj_new(@.CLASS.TPAr);
                  _tpar.TABLE:=TPAR;
                  _tpar.INDEX:='NN';
                  _tpar.PREFIX:=_tktl;
                  _tpar.loadp(ref_name(_tktl)+3);

                  .t_load(_tktl,_tpar);
                  .TAB.cntx_pop();
                  PLRELWYR.cntx_pop();
                  .UPNODE:=.TAB.UPNODE
               ?}
            ?}
         ?};
         PLRELWYR.next()
      !}
   ?};
   .count(0);
   {? _b=0
   ||
::    Surowce elemetarne
      .utworztab1()

   ||
::    Drzewo surowców
      .utwtab2();
      .save_node()
   ?};
   ~~
"),

obj_meth('ltpar',"

   _result:=0;
   {? PLRELWYR.RTKTL<>''
   ||
      TPAR.cntx_psh();
      _tktl:=exec('FindAndGet','#table',TKTL,PLRELWYR.RTKTL,,,null());
      {? _tktl<>null()
      || _tpar_msk:=(TPAR.name()-3)+(ref_name(_tktl)+3);
         TPAR.use(_tpar_msk);
         TPAR.index('NN');
         TPAR.clear();
         TPAR.prefix(_tktl);
         {? TPAR.size()>0
         || ppar.TABLE:=TPAR;
            ppar.INDEX:='NN';
            ppar.PREFIX:=_tktl;
            ppar.loadp(ref_name(_tktl)+3);
            _result:=1
         ?}
      ?};
      TPAR.cntx_pop()
   ?};
   _result
"),

obj_meth('ltpar1',"
   _result:=0;
   {? PLRELWYR.RTKTL<>''
   ||
      TPAR.cntx_psh();
      _tktl:=exec('FindAndGet','#table',TKTL,PLRELWYR.RTKTL,,,null());
      {? _tktl<>null()
      ||
         _tpar_msk:=(TPAR.name()-3)+(ref_name(_tktl)+3);
         TPAR.use(_tpar_msk);
         TPAR.index('NN');
         TPAR.clear();
         TPAR.prefix(_tktl);
         {? TPAR.size()>0
         || ppar.PREFIX:=_tktl;
            ppar.reloadp();
            _result:=1
         ?}
      ?};
      TPAR.cntx_pop()
   ?};
   _result
"),

obj_meth('k_load',"
   FUN.info('Metoda nieaktywna: %1'@['k_load()']);
   .TZZ:=.TZ;
   .UP_T:=PLRELWYR.TOWAR;
   .UP_KTL:=exec('FindAndGet','#table',TKTL,PLRELWYR.RTKTL,,,null);
   _i:=0;
   _ok:=.ltpar();
   .TAB.index(.NDX2);
   M.cntx_psh();
   M.clear();
   {? M.seek(PLRELWYR.TOWAR)
   || _pt:=M.ref();
      _pt_s:=M.KTM;
      _pt_n:=M.N
   || _pt:=null();
      _pt_s:=_pt_n:=''
   ?};
   M.cntx_pop();
   .TAB.prefix(.UPNODE,0,#_pt,#.UP_T,PLRELWYR.RTKTL);
   {? .TAB.first()
   || .TAB.WARN+=1;
      .TAB.WARB+=PLRELWYR.ILOSC;
      .TAB.put()
   || _i+=1;
      .NODE+=1;
      .TAB.UPNODE:=.UPNODE;
      .TAB.NODE:=.NODE;
      .TAB.LP:=_i;
      .TAB.SCIEZKA:='';
      .TAB.ILOSC:=PLRELWYR.ILOSC;
      .TAB.PT:=#_pt;
      .TAB.PT_S:=_pt_s;
      .TAB.PT_N:=_pt_n;
      .TAB.PFAZ:=null();
      .TAB.PFAZ_S:='';
      .TAB.RKTL:=PLRELWYR.RTKTL;
      .TAB.WARN:=PLRELWYR.ILOSC;
      .TAB.WARB:=PLRELWYR.ILOSC;
      .TAB.UP_T:=#.UP_T;
      .TAB.UP_KTL:=#.UP_KTL;
      {? _ok || .ltpar1() || _ok:=.ltpar() ?};
      {? .TAB.add()
      || {? PLRELWYR.RKTL<>''
         || .TAB.cntx_psh();
            PLRELWYR.cntx_psh();
            .UPNODE:=.NODE;
            TMAT.clear();
            _tktl:=exec('FindAndGet','#table',TKTL,PLRELWYR.RTKTL,,,null());
            .t_load(_tktl);
            .TAB.cntx_pop();
            PLRELWYR.cntx_pop();
            .UPNODE:=.TAB.UPNODE
         ?}
      ?}
   ?};
   .count(0);
   {? _b=0 || .utworztab1() || .utwtab2() ?};
 ~~
"),

obj_meth('utworztab1',"
   .TAB.index(.NDX4);
   .TAB.first();
   _zm:=.TAB.PT_S;
   _ilosc:=0;
   _pierwszy:=1;
  {!
  |? {? .TAB.RKTL=''
     || {? _zm<>.TAB.PT_S
        || {? _pierwszy=0
           || .TAB1.WARB:=|_ilosc;
              .TAB1.SO:={? _ilosc<0 || 'O' || 'S' ?};
              {? VAR.SR_ILG >0
              || .TAB1.KIEDY:=exec('term_dost','zamdst_wspolne',VAR.A_T,_ilosc)
              ?};
              .TAB1.TT:=.TAB1.ILD-_ilosc;
              {? .TAB1.TT>0
              || .TAB1.TT:=0;
                 .TAB1.WDR:=VAR.SR_ILG
              || .TAB1.TT:=-.TAB1.TT;
                 .TAB1.WDR:=VAR.SR_ILG;
                 {? .TAB1.TT>VAR.SR_ILG
                 || .TAB1.TT-=VAR.SR_ILG
                 || .TAB1.TT:=0
                 ?}
              ?};
              .TAB1.add()
           ?};
           _ilosc:=.TAB.WARB;
           _pierwszy:=1;
           _zm:=.TAB.PT_S
        || _ilosc+=.TAB.WARB
        ?};
        {? _pierwszy
        || .pola(0);
           _pierwszy:=0
        ?}
     ?};
     .TAB.next()
   !};
   {? _pierwszy=0
   || .TAB1.WARB:=|_ilosc;
      .TAB1.SO:={? _ilosc<0 || 'O' || 'S' ?};
      {? VAR.SR_ILG >0
      || .TAB1.KIEDY:=exec('term_dost','zamdst_wspolne',VAR.A_T,_ilosc)
      ?};
      .TAB1.TT:=.TAB1.ILD-_ilosc;
      {? .TAB1.TT>0
      || .TAB1.TT:=0;
         .TAB1.WDR:=VAR.SR_ILG
      || .TAB1.TT:=-.TAB1.TT;
         .TAB1.WDR:=VAR.SR_ILG;
         {? .TAB1.TT>VAR.SR_ILG
         || .TAB1.TT-=VAR.SR_ILG
         || .TAB1.TT:=0
         ?}
      ?};
      .TAB1.add()
   ?};~~
"),

obj_meth('utwtab2',"
   .TAB.index(.NDX6);
   .TAB.first();
   _zm:=.TAB.PT_S;
   _node:=1;
   _tn:=.TAB.NODE;
   _upn:=.TAB.UPNODE;
   _ktl:=.TAB.RKTL;
   _ilosc:=0;
   _first:=1;
   {!
   |? {? _zm<>.TAB.PT_S | _upn<>.TAB.UPNODE | _ktl<>.TAB.RKTL
      || {? _first=0
         || .TAB1.WARB:=|_ilosc;
            .TAB1.SO:={? _ilosc<0 || 'O' || 'S' ?};
            {? VAR.SR_ILG >0
            || .TAB1.KIEDY:=exec('term_dost','zamdst_wspolne',VAR.A_T,_ilosc)
            ?};
            .TAB1.TT:=.TAB1.ILD-_ilosc;
            {? .TAB1.TT>0
            || .TAB1.TT:=0;
               .TAB1.WDR:=VAR.SR_ILG
            || .TAB1.TT:=-.TAB1.TT;
               .TAB1.WDR:=VAR.SR_ILG;
               {? .TAB1.TT>VAR.SR_ILG
               || .TAB1.TT-=VAR.SR_ILG
               || .TAB1.TT:=0
               ?}
            ?};
            .TAB1.add();
            _node+=1
         ?};
         _ilosc:=.TAB.WARB;
         _first:=1;
         _zm:=.TAB.PT_S;
         _tn:=.TAB.NODE;
         _upn:=.TAB.UPNODE;
         _ktl:=.TAB.RKTL
      || _ilosc+=.TAB.WARB
      ?};
      {? _first
      || .TAB1.RKTL:=.TAB.RKTL;
         .TAB1.KTL_NRK:=.TAB.KTL_NRK;
         .TAB1.KTL_WER:=.TAB.KTL_WER;
         .pola(1);
         _first:=0
      ?};
      .NODS.OLD:=.TAB.NODE;
      .NODS.NEW:=_node;
      .NODS.add();
      .TAB.next()
   !};
   {? _first=0
   || .TAB1.WARB:=|_ilosc;
      .TAB1.SO:={? _ilosc<0 || 'O' || 'S' ?};
      {? VAR.SR_ILG >0
      || .TAB1.KIEDY:=exec('term_dost','zamdst_wspolne',VAR.A_T,_ilosc)
      ?};
      .TAB1.TT:=.TAB1.ILD-_ilosc;
      {? .TAB1.TT>0
      || .TAB1.TT:=0;
         .TAB1.WDR:=VAR.SR_ILG
      || .TAB1.TT:=-.TAB1.TT;
         .TAB1.WDR:=VAR.SR_ILG;
         {? .TAB1.TT>VAR.SR_ILG
         || .TAB1.TT-=VAR.SR_ILG
         || .TAB1.TT:=0
         ?}
      ?};
      .TAB1.add()
   ?};~~
"),

obj_meth('save_node',"
   .TAB1.index(.NDXT3);
   .TAB1.prefix();
   {? .TAB1.first()
   || {!
      |? .NODS.prefix(.TAB1.NODE);
         {? .NODS.first()
         || .TAB1.NODE:=.NODS.NEW
         ?};
         .NODS.prefix(.TAB1.UPNODE);
         {? .NODS.first()
         || .TAB1.UPNODE:=.NODS.NEW
         ?};
         .TAB1.put();
         .TAB1.next()
      !}
   ?};
   ~~
"),


obj_meth('pola',"
   .TAB1.LP:=.TAB.LP;
   .TAB1.PT:=.TAB.PT;
   .TAB1.NODE:=.TAB.NODE;
   .TAB1.UPNODE:={? _a=1 || .TAB.UPNODE || 0 ?};
   M.cntx_psh();
   M.clear();
   M.seek(.TAB.PT,'material');
   VAR.A_T:=M.ref();
   exec('stan_surx','magazyn_stan');
   M.cntx_pop();
   .TAB1.ILD:=VAR.SR_ILD;
   .TAB1.PT_S:=.TAB.PT_S;
   .TAB1.PT_N:=.TAB.PT_N;
   .TAB1.PT_JM:=.TAB.PT_JM;
   .TAB1.UP_T:=.TAB.UP_T;
   .TAB1.WPM:={? .TAB1.UPNODE=0 || 'W' || .TAB.WPM ?};
   .TAB1.UP_KTL:=.TAB.UP_KTL;
   ~~
"),


obj_meth('count',"
:----------------------------------------------------------
: PRIVATE
:    Metoda przelicza cale drzewo surowcow wg norm z kart
:    wyzszego rzedu - uzyta w __init()
: WEJSCIE: _a - up-node
:----------------------------------------------------------
   {? _a=0 || .COEFN:=.COEFB:=1 ?};
   .TAB.cntx_psh();
   .TAB.index(.NDX1);
   .TAB.prefix(_a);
   {? .TAB.first()
   || {!
      |?
         _ilosc:=.ILOSC;
         {? .TZ='A'
         || {? _a=0
            || _xjm:=.TAB.XJM
            || _xjm:=.TAB.ILOSC
            ?};
            _ilosc:=.TAB.ILOSC
         |? .TZ<>'P' & .TZ<>'O'
         || _xjm:=exec('FindAndGet','#table',TKTL,.RTKTL,,\"XJM\",1)
         || _xjm:=1
         ?};
         M.cntx_psh(); M.clear(); {? M.seek(.TAB.PT,) || _mat:=M.ref() || _mat:=null() ?}; M.cntx_pop();
         _dokl:=exec('jaka_dok_m','jm',_mat);
         .TAB.WARN:=(.TAB.WARN*.COEFN*_ilosc/_xjm)$_dokl;
         .TAB.WARB:=(.TAB.WARB*.COEFB*_ilosc/_xjm)$_dokl;
         .TAB.put();
         {? .TAB.RKTL<>''
         ||
            _xjm:=exec('FindAndGet','#table',TKTL,.TAB.RKTL,,\"XJM\",1);
            _cfn:=.COEFN;
            _cfb:=.COEFB;
            .COEFN:=.TAB.WARN/_xjm/{? .DIV || _ilosc || 1 ?};
            .COEFB:=.TAB.WARB/_xjm/{? .DIV || _ilosc || 1 ?};
            .count(.TAB.NODE);
            .COEFN:=_cfn;
            .COEFB:=_cfb
         ?};
         .TAB.next()
      !}
   ?};
   .TAB.cntx_pop();
   ~~
",1),

obj_meth('select',"
:----------------------------------------------------------
: PRIVATE
:     Metoda wyswietla cale drzewo surowcow od wezla _a
:     Uzywana w select()
: WEJSCIE: _a - up-node (numeryczny)
:----------------------------------------------------------
   params_set(params_get());
   {? .WER1=''
   || {? .TZ='T'
      || .win_se11(); .win_ac11(); .win_ed11()
      || .win_se12(); .win_ac12(); .win_ed12()
     ?}
   ?};
   .TAB.cntx_psh();
   .TAB.index(.NDX1);
   .TAB.prefix(_a);
   TKTL.cntx_psh();
   .TAB.select();
   TKTL.cntx_pop;
   .TAB.cntx_pop();
   ~~
",1),

obj_meth('select',"
:--------------------------------------------------------------
: PUBLIC
:     Metoda bez argumentu wyswietla cale drzewo surowcow
:     domyslnie od wezla "0"
:--------------------------------------------------------------
   params_set(params_get());
   {? .WER1=''
   || {? .TZ='T'
      || .win_se11(); .win_ac11(); .win_ed11()
      || .win_se12(); .win_ac12(); .win_ed12()
     ?}
   ?};
   .TAB.win_sel(.WER1);
   .select(0);
   ~~
",-1),

obj_meth('select',"
::----------------------------------------------------------------------------------------------------------------------
:: PUBLIC
::     Metoda z argumentem pustym wyswietla tylko liste surowcow
::     najbardziej pierwotnych, na ktore nie ma juz przepisu
::     w postaci karty technologicznej.
::     Kolejnosc wg (kod_fazy + kod_surowca) albo (kod_surowca)
::----------------------------------------------------------------------------------------------------------------------
   params_set(params_get());
   {? .WER2='' || .win_sel2(); .win_ed4() ?};
   {? .FAZ || .TAB.index(.NDX3) || .TAB.index(.NDX3a) ?};
   .TAB.prefix('',);
   .TAB.win_sel(.WER2);
   TKTL.cntx_psh();
   .TAB.select();
   TKTL.cntx_pop();
   ~~
",0),

obj_meth('select1',"
:--------------------------------------------------------------
: PUBLIC
:     Metoda bez argumentu wyswietla cale drzewo surowcow
:     domyslnie od wezla "0"
:--------------------------------------------------------------
   params_set(params_get());
   {? .WER2='' || .win_sel6();.win_ed6() ?};
   .TAB1.win_sel(.WER2);
   .select1(0);
   ~~
",-1),

obj_meth('select1',"
:----------------------------------------------------------
: PRIVATE
:     Metoda wyswietla cale drzewo surowcow od wezla _a
:     Uzywana w select()
: WEJSCIE: _a - up-node (numeryczny)
:----------------------------------------------------------
   params_set(params_get());
   {? .WER2='' || .win_sel6();.win_ed6();.TAB1.win_sel(.WER2) ?};
   .TAB1.cntx_psh();
   .TAB1.index(.NDXT1);
   .TAB1.prefix(_a);
   TKTL.cntx_psh();
   .TAB1.select();
   TKTL.cntx_pop;
   .TAB1.cntx_pop();
   ~~
",1),

obj_meth('select1',"
:---------------------------------------------------------------
: PUBLIC
:     Metoda z argumentem pustym wyswietla tylko liste surowcow
:     najbardziej elementarnych, na ktore nie ma juz przepisu
:     w postaci karty technologicznej.
:     Kolejnosc wg (kod_fazy + kod_surowca).
:---------------------------------------------------------------
   params_set(params_get());
   {? .WER2='' || .win_sel3(); .win_ed3() ?};
   .TAB1.prefix();
   .TAB1.win_sel(.WER2);
   .TAB1.index(.NDXT3);
   .TAB1.prefix('',);
   TKTL.cntx_psh();
   .TAB1.select();
   TKTL.cntx_pop();
   ~~
",0),

obj_meth('selinw',"
:---------------------------------------------------------------
: PUBLIC
:     Metoda z argumentem pustym wyswietla tylko liste surowcow
:     najbardziej elementarnych, na ktore nie ma juz przepisu
:     w postaci karty technologicznej.
:     Kolejnosc wg (kod_fazy + kod_surowca).
:---------------------------------------------------------------
   {? .WER2='' || .win_sel4(); .win_ed4() ?};
   .TAB1.prefix();
   .TAB1.win_sel(.WER2);
   .TAB1.select();
   ~~
",0),

obj_meth('win_ed11',"
:--------------------------------------------------------------
: PRIVATE
:     Metoda definiuje okno redakcyjne RED - uzyta w __init()
:--------------------------------------------------------------
   .RED:=.TAB.mk_edit('Surowiec karty technologicznej: '@,0,'tab_red_'+$.FAZ);
   .TAB.win_edit(.RED);
   .TAB.win_esep(.RED,'Operacja'@);
   .TAB.win_efld(.RED,,'SCIEZKA',,,50,,,'Operacja'@);
   .TAB.win_esep(.RED,'Surowiec'@);
   .TAB.win_efld(.RED,,'PT_S',,,50,,,'Kod surowca'@);
   .TAB.win_efld(.RED,,'PT_N',,,50,,,'Nazwa surowca'@);
   .TAB.win_efld(.RED,,'SO',,,3,,,'Odpad?'@,,,'check-box',,\"'O'\",\"'S'\");
   .TAB.win_efld(.RED,@.TTG,'GR',,,15,,,'Grupa'@);
   {? .FAZ
   || .TAB.win_efld(.RED,,'PFAZ_S',,,15,,,'Faza produkcji'@);
      .TAB.win_efld(.RED,@.PFAZ,'OPIS',,,50,,,' ')
   ?};
   .TAB.win_esep(.RED,'Normy'@);
   .TAB.win_efld(.RED,@.VAR,'REAL2',,,15,4,,'Norma netto'@);
   .TAB.win_efld(.RED,@.VAR,'REAL',,,15,4,,'Norma brutto'@);
   .TAB.win_efld(.RED,,'PT_JM',,,15,,,'Jednostka miary'@);
   .TAB.win_esep(.RED,'Technologia półfabrykatu'@);
   .TAB.win_efld(.RED,,'KTL_NRK',,,50,,,'Karta technologiczna'@);
   .TAB.win_efld(.RED,,'KTL_WER',,,50,,,'w wersji'@);
   ~~
"),

obj_meth('win_ed12',"
:--------------------------------------------------------------
: PRIVATE
:-------------------------------------------------------------
   .RED1:=.TAB.mk_edit('Surowiec zlecenia: '@,0,'tab_red12_'+$.FAZ);
   .TAB.win_edit(.RED1);
   .TAB.win_esep(.RED1,'Operacja'@);
   .TAB.win_efld(.RED1,,'SCIEZKA',,,50,,,'Operacja'@);
   .TAB.win_esep(.RED1,'Surowiec'@);
   .TAB.win_efld(.RED1,,'PT_S',,,50,,,'Surowiec'@);
   .TAB.win_efld(.RED1,,'PT_N',,,50,,,' '@);
   .TAB.win_efld(.RED,,'SO',,,3,,,'Odpad?'@,,,'check-box',,\"'O'\",\"'S'\");
   {? .FAZ
   || .TAB.win_efld(.RED1,,'PFAZ_S',,,15,,,'Faza produkcji'@);
      .TAB.win_efld(.RED1,@.PFAZ,'OPIS',,,50,,,' ')
   ?};
   .TAB.win_esep(.RED1,'Normy'@);
   .TAB.win_efld(.RED1,@.VAR,'REAL2',,,15,4,,'Norma netto'@);
   .TAB.win_efld(.RED1,@.VAR,'REAL',,,15,4,,'Norma brutto'@);
   .TAB.win_efld(.RED1,,'PT_JM',,,15,,,'Jednostka miary'@);
   .TAB.win_esep(.RED1,'Technologia półfabrykatu'@);
   .TAB.win_efld(.RED1,,'KTL_NRK',,,50,,,'Karta technologiczna'@);
   .TAB.win_efld(.RED1,,'KTL_WER',,,50,,,'w wersji'@);
   ~~
"),

obj_meth('win_se11',"
:--------------------------------------------------------------
: PRIVATE
:     Metoda definiuje okno wertowania WER1 - uzyta w __init()
:--------------------------------------------------------------
   .WER1:=.TAB.mk_sel(
   {? .TZ='T' || 'Struktura surowców karty: %1 wersja %2'@[TKTL.NRK,TKTL.WER]+
                 {? TKTL.STAN<>'T' || ' — '+'NIEZATWIERDZONA'@ || '' ?}
              || 'Struktura surowców zlecenia: %1'@[ZKTL.ZLEC().SYM]
   ?},'N',0,'#'+(-.TZ)+'_tab_wer11_'+$.FAZ);
:---------------------------------------------------------------
:>>>> UWAGA: node i up-node - tylko do testow
:.TAB.win_fld(.WER1,,'NODE',,,3,,,'Nod');
:.TAB.win_fld(.WER1,,'UPNODE',,,3,,,'U-n');
:---------------------------------------------------------------
   .TAB.win_fld(.WER1,,'PT_S',,,20,,,'Kod surowca'@);
   .TAB.win_fld(.WER1,,'PT_N',,,{? .FAZ || 35 || 40 ?},,,'Nazwa surowca'@);
   .TAB.win_fld(.WER1,,'SO',,,-3,,,'Odpad?'@,,'Znacznik, czy surowiec jest odpadem/koproduktem'@,2,,\"'O'\",\"'S'\");
   {? .FAZ || .TAB.win_fld(.WER1,,'PFAZ_S',,,-10,,,'Faza produkcji'@) ?};
   .TAB.win_fld(.WER1,@.VAR,'REAL',,,15,ST.DOKL,,'Norma brutto'@);
   .TAB.win_fld(.WER1,,'PT_JM',,,5,,,'jm'@);
   .TAB.win_fld(.WER1,,'KTL_NRK',,,-20,,,'Karta technologiczna'@);
   .TAB.win_fld(.WER1,,'KTL_WER',,,6,,,'Wersja'@);
   ~~
"),

obj_meth('win_se12',"
:--------------------------------------------------------------
: PRIVATE
:     Metoda definiuje okno wertowania WER1 - uzyta w __init()
:--------------------------------------------------------------
   .WER1:=.TAB.mk_sel(
   {? .TZ='T' || 'Struktura surowców karty: %1 wersja %2'@[TKTL.NRK,TKTL.WER]
              || 'Struktura surowców zlecenia: %1'@[ZKTL.ZLEC().SYM]
   ?},'N',0,'#'+(-.TZ)+'_tab_wer12_'+$.FAZ);
:---------------------------------------------------------------
:>>>> UWAGA: node i up-node - tylko do testow
:.TAB.win_fld(.WER1,,'NODE',,,3,,,'Nod');
:.TAB.win_fld(.WER1,,'UPNODE',,,3,,,'U-n');
:---------------------------------------------------------------
   .TAB.win_fld(.WER1,,'PT_S',,,20,,,'Kod surowca'@);
   .TAB.win_fld(.WER1,,'PT_N',,,{? .FAZ || 35 || 40 ?},,,'Nazwa surowca'@);
   .TAB.win_fld(.WER1,,'SO',,,-3,,,'Odpad?'@,,'Znacznik, czy surowiec jest odpadem/koproduktem'@,2,,\"'O'\",\"'S'\");
   {? .FAZ || .TAB.win_fld(.WER1,,'PFAZ_S',,,-10,,,'Faza produkcji'@) ?};
   .TAB.win_fld(.WER1,@.VAR,'REAL',,,15,ST.DOKL,,'Norma brutto'@);
   .TAB.win_fld(.WER1,,'PT_JM',,,5,,,'jm'@);
   .TAB.win_fld(.WER1,,'KTL_NRK',,,-20,,,'Karta technologiczna'@);
   .TAB.win_fld(.WER1,,'KTL_WER',,,6,,,'Wersja'@);
   ~~
"),

obj_meth('win_ac11',"
   .TAB.win_act(.WER1,0,'Rekord',,,,$(\"
      VAR.REAL:=|\"+!.ME+\".TAB.WARB;VAR.REAL2:=|\"+!.ME+\".TAB.WARN;
      {? ~M.seek(\"+!.ME+\".TAB.PT,) || M.KTM:=''; M.N:='' ?};
      {? ~PFAZ.seek(\"+!.ME+\".TAB.PFAZ,) || PFAZ.KOD:=''; PFAZ.OPIS:='' ?};
      {? ~TTG.seek(\"+!.ME+\".TAB.GR,) || TTG.GR:='' ?};
      {? \"+!.ME+\".TAB.RKTL<>'' || Color.fnd_kol('TMAT#01#01') || '' ?}
   \"));
   .TAB.win_act(.WER1,0,'Formuła','Grupa'@@,,,$(\"
      {? \"+!.ME+ \".TAB.GR=0
      || FUN.info('Surowiec określony jako pojedynczy w karcie technologicznej.'@)
      ||
         TTGP.index('GRS'); TTG.seek(\"+!.ME+ \".TAB.GR, 'ttechgr');
         TTGP.prefix(TTG.ref()); TTGP.win_sel('WERG'); TTGP.select()
      ?}; ~~
   \"),,1);
   .TAB.win_act(.WER1,0,'Formuła','Zamienniki'@@,,,$(\"
      params_set(params_get());
      TCHMAT.win_sel('WER_T');
      {? TKTL.TYP().PAR='T'
      || TCHMAT.win_edit('RED_T'+exec('tch_edit_sufix','tech_mater'))
      || TCHMAT.win_edit('RED_N'+exec('tch_edit_sufix','tech_mater'))
      ?};
      TCHMAT.clear();TMAT.prefix();
      {? \"+!.ME+\".TAB.RTMAT<>''
      || _tmat:=\"+!.ME+\".TAB.RTMAT;
         TMAT.cntx_psh();
         TMAT.use(form(8+_tmat));
         TMAT.clear();
         {? TMAT.seek(_tmat)
         ||
            TCHMAT.index('NSL');
            TCHMAT.prefix(TMAT.NRK,TMAT.ref());
            TCHMAT.first();
            VAR.P_NKTM:='';
            TCHMAT.select(,,,'dpUZ:dZ')
         || FUN.info('Nie znaleziono surowca, któremu miały zostać wyświetlone zamienniki.'@)
         ?};
         TMAT.cntx_pop()
      || FUN.info('Surowiec zliczony z kilku pozycji,\npodgląd zamienników nie jest możliwy.'@)
      ?}
   \"),,1);
   .TAB.win_act(.WER1,0,'Formuła','Dalsze surowce'@@,,,$(\"
      params_set(params_get());
      {? \"+!.ME+\".TAB.RKTL<>''
      || \"+!.ME+\".select(\"+!.ME+\".TAB.NODE)
      || FUN.info('Surowiec nie posiada karty technologicznej.'@)
      ?};~~
   \"),,1);
   .TAB.win_act(.WER1,,'Formuła','Legenda'@@,,,\"
      exec('legenda','color','TMAT#01#01')
   \")
"),

obj_meth('win_ac12',"
   .TAB.win_act(.WER1,0,'Rekord',,,,$(\"
      VAR.REAL:=|\"+!.ME+\".TAB.WARB;VAR.REAL2:=|\"+!.ME+\".TAB.WARN;
      {? ~M.seek(\"+!.ME+\".TAB.PT,) || M.KTM:='';M.N:='' ?};
      {? ~PFAZ.seek(\"+!.ME+\".TAB.PFAZ,) || PFAZ.KOD:='';PFAZ.OPIS:='' ?};
      {? \"+!.ME+\".TAB.UPNODE<>0 || \"+!.ME+\".win_ed11() || \"+!.ME+\".win_ed12() ?};
      {? \"+!.ME+\".TAB.RKTL<>'' || Color.fnd_kol('TMAT#01#01') || '' ?}
   \"));
   .TAB.win_act(.WER1,0,'Formuła','Grupa'@@,,,$(\"
      {? \"+!.ME+ \".TAB.UPNODE<>0
      || {? \"+!.ME+ \".TAB.GR=0
         || FUN.info('Surowiec określony jako pojedynczy w karcie technologicznej.'@)
         ||
            TTGP.index('GRS'); TTG.seek(\"+!.ME+ \".TAB.GR, 'ttechgr');
            TTGP.prefix(TTG.ref());TTGP.win_sel('WERG');TTGP.select()
         ?}
      ?}; ~~
   \"),,1);
   .TAB.win_act(.WER1,0,'Formuła','Zamienniki'@@,,,$(\"
      TCHMAT.win_sel('WER_T');
      {? TKTL.TYP().PAR='T'
      || TCHMAT.win_edit('RED_T'+exec('tch_edit_sufix','tech_mater'))
      || TCHMAT.win_edit('RED_N'+exec('tch_edit_sufix','tech_mater'))
      ?};
      TCHMAT.clear();
      TMAT.prefix();
      {? \"+!.ME+\".TAB.RTMAT<>''
      || _tmat:=\"+!.ME+\".TAB.RTMAT;
         TMAT.cntx_psh();
         TMAT.use(form(8+_tmat));
         TMAT.clear();
         {? TMAT.seek(_tmat)
         ||
            TCHMAT.index('NSL');
            TCHMAT.prefix(TMAT.NRK,TMAT.ref());
            TCHMAT.first();
            VAR.P_NKTM:='';
            TCHMAT.select(,,,'dpUZ:dZ')
         || FUN.info('Nie znaleziono surowca, któremu miały zostać wyświetlone zamienniki.'@)
         ?};
         TMAT.cntx_pop()
      || FUN.info('Surowiec zliczony z kilku pozycji,\n podgląd zamienników nie jest możliwy.'@)
      ?}
   \"),,1);
   .TAB.win_act(.WER1,0,'Formuła','Dalsze surowce'@@,,,$(\"
      {? \"+!.ME+\".TAB.RKTL<>''
      || \"+!.ME+\".TZZ:='T';\"+!.ME+\".select(\"+!.ME+\".TAB.NODE)
      || FUN.info('Surowiec nie posiada karty technologicznej.'@)
      ?};~~
   \"),,1);
   .TAB.win_act(.WER1,,'Formuła','Legenda'@@,,,\"
      exec('legenda','color','TMAT#01#01')
   \")
"),

obj_meth('win_sel3',"
:--------------------------------------------------------------
: PRIVATE
:     Metoda definiuje okno wertowania WER2 - uzyta w __init()
:--------------------------------------------------------------
   .WER2:=.TAB1.mk_sel('Wszystkie surowce elementarne:'@,'P',0,'tab1_wer23',,,,,'U');
:---------------------------------------------------------------
   .TAB1.win_fld(.WER2,,'PT_S',,,20,,,'Kod surowca'@);
   .TAB1.win_fld(.WER2,,'PT_N',,,30,,,'Nazwa surowca'@);
   .TAB1.win_fld(.WER2,,'PT_JM',,,6,,,'jm'@);
   .TAB1.win_fld(.WER2,,'SO',,,-3,,,'Odpad?'@,,'Znacznik, czy surowiec jest odpadem/koproduktem'@,2,,\"'O'\",\"'S'\");
   .TAB1.win_fld(.WER2,,'WARB',,,12,ST.DOKL,,'Zapotrz.'@);
   .TAB1.win_fld(.WER2,,'ILD',,,12,ST.DOKL,,'Dostępne'@);
   .TAB1.win_fld(.WER2,,'WDR',,,12,ST.DOKL,,'W drodze'@);
   .TAB1.win_fld(.WER2,,'TT',,,12,ST.DOKL,,'Do zam.'@);
   .TAB1.win_fld(.WER2,VAR,'STRING',,,10,,,'Na kiedy'@,,,,1);
   .TAB1.win_act(.WER2,0,'Formuła','Stany'@@,,,$(\"{? M.seek(\"+!.ME+\".TAB1.PT,'material')|| VAR.A_T:=M.ref(); exec('stan_x','magazyn_stan','')?};~~ \"),,1);
   .TAB1.win_act(.WER2,0,'Formuła','Druku&j'@@,,,\" exec('prn_plpr','tech_mater');~~ \");
   .TAB1.win_act(.WER2,0,'Formuła','Legenda'@@,,,\"exec('legenda','color','__SURWYR#01')\");
   .TAB1.win_act(.WER2,0,'Rekord',,,,$(\"
      {? ~M.seek(\"+!.ME+\".TAB1.PT, 'material') || M.KTM:='';M.N:='' ?};
      {? \"+!.ME+\".TAB1.WARB< \"+!.ME+\".TAB1.ILD
      || VAR.STRING:='OK'@
      |? \"+!.ME+\".TAB1.TT=0 & \"+!.ME+\".TAB1.WDR>0
      ||  VAR.STRING:=$(\"+!.ME+\".TAB1.KIEDY)
      || VAR.STRING:='BRAK'@
      ?};
      VAR.REAL2:={? \"+!.ME+\".TAB1.WARB > \"+!.ME+\".TAB1.ILD & \"+!.ME+\".TAB1.SO<>'O'
                 || \"+!.ME+\".TAB1.WARB - \"+!.ME+\".TAB1.ILD
                 || 0
                ?};
      {? \"+!.ME+\".TAB1.WARB> \"+!.ME+\".TAB1.ILD || Color.rekprzed('__SURWYR#01#') || '' ?}
     \"))
"),

obj_meth('win_sel6',"
:--------------------------------------------------------------
: PRIVATE
:     Metoda definiuje okno wertowania WER2 - uzyta w __init()
:--------------------------------------------------------------
   .WER2:=.TAB1.mk_sel('Drzewo surowców:'@,'N',0,'tab1_wer26');
:---------------------------------------------------------------
   .TAB1.win_fld(.WER2,,'PT_S',,,20,,,'Kod surowca'@);
:.TAB1.win_fld(.WER2,@.PT,'OPIS',,,20,,,'Nazwa surowca'@,,,,1);
   .TAB1.win_fld(.WER2,,'WARB',,,12,ST.DOKL,,'Zapotrz.'@);
   .TAB1.win_fld(.WER2,,'ILD',,,12,ST.DOKL,,'Dostępne'@);
   .TAB1.win_fld(.WER2,,'WDR',,,12,ST.DOKL,,'W drodze'@);
   .TAB1.win_fld(.WER2,,'TT',,,12,ST.DOKL,,'Do zam.'@);
   .TAB1.win_fld(.WER2,VAR,'STRING',,,10,,,'Na kiedy'@,,,,1);
   .TAB1.win_act(.WER2,0,'Formuła','Stany'@@,,,$(\"M.seek(\"+!.ME+\".TAB1.PT,'material');VAR.A_T:=M.ref();
       exec('stan_x','magazyn_stan','');~~ \"),,1);
   .TAB1.win_act(.WER2,0,'Rekord',,,,$(\"
      {? ~M.seek(\"+!.ME+\".TAB1.PT,) || M.KTM:='';M.N:='' ?};
      {? \"+!.ME+\".TAB1.WARB< \"+!.ME+\".TAB1.ILD || VAR.STRING:='OK'@
      |? \"+!.ME+\".TAB1.TT=0 & \"+!.ME+\".TAB1.WDR>0 || VAR.STRING:=$(\"+!.ME+\".TAB1.KIEDY)
      || VAR.STRING:='BRAK'@
      ?};
         VAR.REAL2:={? \"+!.ME+\".TAB1.WARB > \"+!.ME+\".TAB1.ILD
                    || \"+!.ME+\".TAB1.WARB - \"+!.ME+\".TAB1.ILD
                    || 0
                    ?};
        \"+!.ME+\".TAB1.RKTL<>'' \"));
   .TAB1.win_act(.WER2,0,'Formuła','Dalsze surowce'@@,,,$(\"
      {? \"+!.ME+\".TAB1.RKTL<>''
      || \"+!.ME+\".select1(\"+!.ME+\".TAB1.NODE)
      || FUN.emsg('Surowiec nie posiada karty technologicznej\n i nie składają się na niego inne produkty.'@)
      ?};
      ~~ \"),,1);
   ~~
"),

obj_meth('win_ed6',"
:--------------------------------------------------------------
: PRIVATE
:     Metoda definiuje okno redakcyjne RED - uzyta w __init()
:--------------------------------------------------------------
   .RED:=.TAB1.mk_edit('Surowiec karty technologicznej:'@,0,'tab1_red6');
   .TAB1.win_edit(.RED);
   .TAB1.win_efld(.RED,,'PT_S',,,50,,,'Kod surowca'@);
   .TAB1.win_efld(.RED,@.PT,'OPIS',,,50,,,'Nazwa surowca'@);
   .TAB1.win_efld(.RED,,'WARB',,,15,4,,'Norma brutto'@);
   .TAB1.win_efld(.RED,,'KTL_NRK',,,50,,,'Karta technologiczna'@);
   .TAB1.win_efld(.RED,,'KTL_WER',,,50,,,'w wersji'@);
   ~~
"),

obj_meth('win_ed3',"
:--------------------------------------------------------------
: PRIVATE
:     Metoda definiuje okno redakcyjne RED - uzyta w __init()
:--------------------------------------------------------------
   .RED:=.TAB1.mk_edit('Surowiec karty technologicznej:'@,0,'tab1_red');
   .TAB1.win_edit(.RED);
   .TAB1.win_efld(.RED,,'PT_S',,,50,,,'Kod surowca'@);
   .TAB1.win_efld(.RED,,'PT_N',,,50,,,'Nazwa surowca'@);
   .TAB1.win_efld(.RED,,'SO',,,-3,,,'Odpad?'@,
      ,'Znacznik, czy surowiec jest odpadem/koproduktem'@,'radio-buttons',,\"'O'\",\"'S'\");
   .TAB1.win_efld(.RED,,'WARB',,,15,4,,'Zapotrzebowanie'@);
   .TAB1.win_efld(.RED,,'ILD',,,15,4,,'Dostępne'@);
   .TAB1.win_efld(.RED,VAR,'REAL2',,,15,4,,'Brakuje'@);
   .TAB1.win_efld(.RED,,'WDR',,,15,4,,'W drodze'@);
   .TAB1.win_efld(.RED,,'KIEDY',,,15,,,'Na kiedy'@);
   .TAB1.win_efld(.RED,,'TT',,,15,4,,'Do zamówienia'@);
   .TAB1.win_efld(.RED,VAR,'STRING',,,15,,,'Na kiedy całość'@);
   ~~
"),

obj_meth('win_sel4',"
:--------------------------------------------------------------
: PRIVATE
:     Metoda definiuje okno wertowania WER2 - uzyta w __init()
:--------------------------------------------------------------
   .WER2:=.TAB1.mk_sel('Wszystkie surowce elementarne:'@,'P',0,'tab1_wer24',,,,,'U');
:---------------------------------------------------------------
   .TAB1.win_fld(.WER2,,'LP',,,3,,,'Lp.'@);
   .TAB1.win_fld(.WER2,,'PT_S',,,20,,,'Kod surowca'@);
   .TAB1.win_fld(.WER2,,'PT_N',,,40,,,'Nazwa surowca'@);
   .TAB1.win_fld(.WER2,,'TT',,,12,ST.DOKL_C,,'Cena surowca'@);
   .TAB1.win_fld(.WER2,,'WARB',,,12,ST.DOKL,,'Ilość'@);
   .TAB1.win_fld(.WER2,,'PT_JM',,,5,,,'jm'@);
   .TAB1.win_fld(.WER2,,'ILD',,,12,ST.DOKL_C,,'Wartość'@);
   .TAB1.win_fld(.WER2,,'SO',,,-3,,,'Odpad?'@,,'Znacznik, czy surowiec jest odpadem/koproduktem',2,,\"'O'\",\"'S'\");
   ~~
"),

obj_meth('win_ed4',"
:--------------------------------------------------------------
: PRIVATE
:-------------------------------------------------------------
   .RED1:=.TAB.mk_edit('Surowiec'@,0,'tab_red14_'+$.FAZ);
   .TAB.win_edit(.RED1);
   .TAB.win_efld(.RED1,,'PT_S',,,50,,,'Kod surowca'@);
   .TAB.win_efld(.RED1,,'PT_N',,,50,,,'Nazwa surowca'@);
   {? .FAZ
   || .TAB.win_efld(.RED1,,'PFAZ_S',,,15,,,'Faza produkcji'@);
      .TAB.win_efld(.RED1,@.PFAZ,'OPIS',,,50,,,' ')
   ?};
   .TAB.win_efld(.RED1,,'WARN',,,15,ST.DOKL,,'Norma netto'@);
   .TAB.win_efld(.RED1,,'WARB',,,15,ST.DOKL,,'Norma brutto'@);
   .TAB.win_efld(.RED1,,'PT_JM',,,15,,,'Jednostka miary'@);
   .TAB.win_efld(.RED1,,'SO',,,3,,,'Odpad?'@,
      ,'Znacznik, czy surowiec jest odpadem/koproduktem'@,'check-box',,\"'S'\",\"'O'\");
   .TAB.win_efld(.RED1,,'POW',,,2,,,'Powierzony'@);
   ~~
"),

obj_meth('win_ed5',"
:--------------------------------------------------------------
: PRIVATE
:-------------------------------------------------------------
   .RED1:=.TAB1.mk_edit('Surowiec'@,0,'tab1_red15_'+(-ZL.STAN)+$.FAZ);
   .TAB1.win_edit(.RED1);
   .TAB1.win_efld(.RED1,,'PT_S',,,50,,,'Kod surowca'@);
   .TAB1.win_efld(.RED1,,'PT_N',,,50,,,'Nazwa surowca'@);
   {? .FAZ=1
   || .TAB1.win_efld(.RED1,,'PFAZ_S',,,15,,,'Faza produkcji'@)
   ?};
   .TAB1.win_efld(.RED1,,'TT',,,15,ST.DOKL,,'Norma netto'@);
   .TAB1.win_efld(.RED1,,'WARB',,,15,ST.DOKL,,'Norma brutto'@);
   .TAB1.win_efld(.RED1,,'PT_JM',,,15,,,'Jednostka miary'@);
   .TAB1.win_efld(.RED1,,'ILD',,,15,ST.DOKL,,'Dostępne'@);
   .TAB1.win_efld(.RED1,VAR,'REAL2',,,15,ST.DOKL,,'Brakuje'@);
   .TAB1.win_efld(.RED1,,'WDR',,,15,ST.DOKL,,'W drodze'@);
   .TAB1.win_efld(.RED1,,'KIEDY',,,12,,,'Na kiedy'@);
   .TAB1.win_efld(.RED1,VAR,'REAL',,,15,ST.DOKL,,'Do zamówienia'@);
   .TAB1.win_efld(.RED1,VAR,'STRING',,,15,,,'Na kiedy całość'@);
   .TAB1.win_efld(.RED1,,'SO',,,3,,,'Odpad?'@,
      ,'Znacznik, czy surowiec jest odpadem/koproduktem'@,'check-box',,\"'O'\",\"'S'\");
   ~~
"),

obj_meth('win_sel2',"
:--------------------------------------------------------------
: PRIVATE
:     Metoda definiuje okno wertowania WER2 - uzyta w __init()
:--------------------------------------------------------------
   .WER2:=.TAB.mk_sel(
   {? .TZ='T'
   || 'Wszystkie surowce elementarne karty: %1 wersja: %2'@[VAR.A_KTL().NRK,VAR.A_KTL().WER]
   || 'Wszystkie surowce elementarne zlecenia: %1'@[ZKTL.ZLEC().SYM]
   ?},'P',0,'#'+(-.TZ)+'_tab_wer2_'+$.FAZ,,,,,'U');
:---------------------------------------------------------------
:>>>> UWAGA: node i up-node - tylko do testow
:.TAB.win_fld(.WER2,,'NODE',,,3,,,'Nod');
:.TAB.win_fld(.WER2,,'UPNODE',,,3,,,'U-n');
:---------------------------------------------------------------
   .TAB.win_fld(.WER2,,'PT_S',,,20,,,'Kod surowca'@);
   .TAB.win_fld(.WER2,,'PT_N',,,40,,,'Nazwa surowca'@,,,,1);
   {? .FAZ || .TAB.win_fld(.WER2,,'PFAZ_S',,,-10,,,'Faza produkcji'@) ?};
:   .TAB.win_fld(.WER2,@.VAR,'REAL',,,15,4,,'Norma brutto');
   .TAB.win_fld(.WER2,,'WARB',,,15,ST.DOKL,,'Norma brutto'@);
   .TAB.win_fld(.WER2,,'PT_JM',,,5,,,'jm'@);
   .TAB.win_fld(.WER2,VAR,'STRING',,,15,,,'Do czego?'@);
   .TAB.win_fld(.WER2,,'SO',,,-3,,,'Odpad?'@,,'Znacznik, czy surowiec jest odpadem/koproduktem'@,2,,\"'O'\",\"'S'\");
   .TAB.win_act(.WER2,0,'Rekord',,,,$(\"
      VAR.REAL:=|\"+!.ME+\".TAB.WARB;VAR.REAL2:=|\"+!.ME+\".TAB.WARN;
      {? ~M.seek(\"+!.ME+\".TAB.UP_T,) || VAR.STRING:='' || VAR.STRING:=M.KTM ?};
      {? ~M.seek(\"+!.ME+\".TAB.PT,) || M.KTM:=''; M.N:='' ?};
      {? ~PFAZ.seek(\"+!.ME+\".TAB.PFAZ,) || PFAZ.KOD:='';PFAZ.OPIS:='' ?};
      ~~
      \"));
   .TAB.win_act(.WER2,,'Kolejność');
   ~~
"),

obj_meth('a_load',"
::----------------------------------------------------------------------------------------------------------------------
::  MOD: TS [8.60] akcje dla grup rekordow
:: OPIS: przetwarzanie zaznaczonych rekordow w tabeli ZL
::   WE: zmienna globalna __GRUPA zawierajaca dane zaznaczonych rekordow
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
   ZL.cntx_psh();
   ZL.clear();
   __GRUPA.clear();
   {? __GRUPA.first()
   || {!
      |? {? ZL.seek(__GRUPA.REF,)
         || {? ZL.RODZAJ='Z' | ZL.RODZAJ='N'
            || _r:=ZL.RODZAJ;
               _il:=ZL.IL;
               _rtktl:=ZL.RTKTL;
               _rktl:=ZL.RKTL;
               ZL.cntx_psh();
               ZL.index('NRNZL');
               ZL.prefix(ZL.UNRZL);
               {? ZL.first()
               || {!
                  |? {? ZL.RTKTL<>''
                     || .ILOSC:=ZL.IL;
                        _xjm:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,\"XJM\",1);
                        .t_load(exec('FindAndGet','#table',TKTL,ZL.RTKTL),,_xjm)
                     |? ZL.RKTL<>''
                     || .ILOSC:=ZL.IL;
                        _xjm:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,\"XJM\",1);
                        .t_load(exec('FindAndGet','#table',TKTL,ZL.RKTL),,_xjm)
                     ?};
                     _r='N' & ZL.next()
                  !}
               || {? _rtktl<>''
                  || .ILOSC:=_il;
                     _xjm:=exec('FindAndGet','#table',TKTL,_rtktl,,\"XJM\",1);
                     .t_load(exec('FindAndGet','#table',TKTL,_rtktl),,_xjm)
                  |? _rktl<>''
                  || .ILOSC:=_il;
                     _xjm:=exec('FindAndGet','#table',TKTL,_rktl,,\"XJM\",1);
                     .t_load(exec('FindAndGet','#table',TKTL,_rktl),,_xjm)
                  ?}
               ?};
               ZL.cntx_pop()
            || {? ZL.TKTL<>null()
               || .ILOSC:=ZL.IL;
                  .t_load(ZL.TKTL)
               || .ILOSC:=ZL.IL;
                  .t_load(ZL.KTL)
               ?}
            ?}
         ?};
         __GRUPA.next()
      !};
      .count(0);
      {? .FAZ=1
      || .utworzltab1()
      || .utworbfzltab1()
      ?}
   ?};
   ZL.cntx_pop();
   ~~
"),

obj_meth('utworzltab1',"
   .TAB.index(.NDX4);
   {? .TAB.first()
   || _zm:=.TAB.PT_S;
      _pfaz:=.TAB.PFAZ;
      _ilosc:=0;
      _ilosc1:=0;
      _pierwszy:=1;
      {!
      |?
         {? .TAB.RKTL=''
         || {? _zm<>.TAB.PT_S | _pfaz<>.TAB.PFAZ
            || {? _pierwszy=0
               || .TAB1.WARB:=_ilosc;
                  .TAB1.SO:={? _ilosc<0 || 'O' || 'S' ?};
                  .TAB1.TT:=|_ilosc1;
                  {? VAR.SR_ILG>0
                  || .TAB1.KIEDY:=exec('term_dost','zamdst_wspolne',VAR.A_T,_ilosc)
                  ?};
                  .TAB1.WDR:=VAR.SR_ILG;
                  .TAB1.add
               ?};
               _ilosc:=.TAB.WARB;
               _ilosc1:=.TAB.WARN;
               _pierwszy:=1;
               _zm:=.TAB.PT_S;
               _pfaz:=.TAB.PFAZ
            || _ilosc+=.TAB.WARB;
               _ilosc1+=.TAB.WARN
            ?};
            {? _pierwszy
            || .TAB1.LP:=.TAB.LP;
               .TAB1.PT:=.TAB.PT;
               .TAB1.PT_S:=.TAB.PT_S;
               .TAB1.PT_N:=.TAB.PT_N;
               .TAB1.PT_JM:=.TAB.PT_JM;
               M.cntx_psh();
               M.clear();
               M.seek(.TAB.PT,'material');
               VAR.A_T:=M.ref();
               exec('stan_surx','magazyn_stan');
               M.cntx_pop();
               .TAB1.ILD:=VAR.SR_ILD;
               .TAB1.PFAZ:=.TAB.PFAZ;
               .TAB1.PFAZ_S:=.TAB.PFAZ_S;
               _pierwszy:=0
            ?}
         || _zm:=.TAB.PT_S;
            _pfaz:=.TAB.PFAZ
         ?};
         .TAB.next()
      !};
      {? _pierwszy=0
      || .TAB1.WARB:=_ilosc;
         .TAB1.SO:={? _ilosc<0 || 'O' || 'S' ?};
         .TAB1.TT:=|_ilosc1;
         {? VAR.SR_ILG >0
         || .TAB1.KIEDY:=exec('term_dost','zamdst_wspolne',VAR.A_T,_ilosc)
         ?};
         .TAB1.WDR:=VAR.SR_ILG;
         .TAB1.add
      ?}
   ?};
   ~~
"),

obj_meth('utworbfzltab1',"
   .TAB.index(.NDX4);
   {? .TAB.first()
   || _zm:=.TAB.PT_S;
      _ilosc:=0;
      _ilosc1:=0;
      _pierwszy:=1;
      {!
      |?
         {? .TAB.RKTL=''
         || {? _zm<>.TAB.PT_S
            || {? _pierwszy=0
               || .TAB1.WARB:=_ilosc;
                  .TAB1.SO:={? _ilosc<0 || 'O' || 'S' ?};
                  .TAB1.TT:=|_ilosc1;
                  {? VAR.SR_ILG>0
                  || .TAB1.KIEDY:=exec('term_dost','zamdst_wspolne',VAR.A_T,_ilosc)
                  ?};
                  .TAB1.WDR:=VAR.SR_ILG;
                  .TAB1.add
               ?};
               _ilosc:=.TAB.WARB;
               _ilosc1:=.TAB.WARN;
               _pierwszy:=1;
               _zm:=.TAB.PT_S
            || _ilosc+=.TAB.WARB;
               _ilosc1+=.TAB.WARN
            ?};
            {? _pierwszy
            || .TAB1.LP:=.TAB.LP;
               .TAB1.PT:=.TAB.PT;
               .TAB1.PT_S:=.TAB.PT_S;
               .TAB1.PT_N:=.TAB.PT_N;
               .TAB1.PT_JM:=.TAB.PT_JM;
               M.cntx_psh();
               M.clear();
               M.seek(.TAB.PT,'material');
               VAR.A_T:=M.ref();
               exec('stan_surx','magazyn_stan');
               M.cntx_pop();
               .TAB1.ILD:=VAR.SR_ILD;
               _pierwszy:=0
            ?}
         || _zm:=.TAB.PT_S
         ?};
         .TAB.next()
      !};
      {? _pierwszy=0
      || .TAB1.WARB:=_ilosc;
         .TAB1.SO:={? _ilosc<0 || 'O' || 'S' ?};
         .TAB1.TT:=|_ilosc1;
         {? VAR.SR_ILG>0
         || .TAB1.KIEDY:=exec('term_dost','zamdst_wspolne',VAR.A_T,_ilosc)
         ?};
         .TAB1.WDR:=VAR.SR_ILG;
         .TAB1.add
      ?}
   ?};
   ~~
"),

obj_virt('tree',"
   FUN.emsg('tree/sur_obj - brak metody wirtualnej.'@)
"),

obj_virt('f_displ',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Wyswietl zawartosc rekordu (na spacje)
::----------------------------------------------------------------------------------------------------------------------
   ~~
"),

obj_meth('obl_stan',"
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Nalicza kolumne .TAB.STAN wg zadanych kryteriow
::   WE: _a  1 - wg danego magazynu
::           2 - wg operatora zamowien
::           3 - wg wszystkich magazynow
::           4 - wg operatora magazynow produkcyjnych
::       [_b] wg magazynu tylko dla _b=1 (gdy nie wypelnione to biezacy magazyn)
::       [_c] czy uzupelniac tabele tymczasowa  __smmag  (0 - nie, 1 - tak)
::       [_d] czy uzupelniac tabele tymczasowa - ze stanami rezerwacji (0-nie, 1-tak)
::----------------------------------------------------------------------------------------------------------------------
   {? _>=1 || {? type_of(_a)<>1 || _a:=0 ?} || _a:=0 ?}; {? _a=0 || return() ?};
   {? _>=2 || {? type_of(_b)<>7 || _b:=null() ?} || _b:=null() ?};
   {? _>=3 || {? type_of(_c)<>1 || _c:=0 ?} || _c:=0 ?};
   {? _>=4 || {? type_of(_d)<>1 || _d:=0 ?} || _d:=0 ?};
   __SUR.TAB.prefix();
   {? __SUR.TAB.first()
   || {!
      |?
         M.clear();
         M.seek(__SUR.TAB.PT,);
         exec('obl_stan','magazyn_stan',M.ref(),_a,_b,_c,_d);
         __SUR.TAB.STAN:=BEER.SD;
         __SUR.TAB.put();
         __SUR.TAB.next()
      !}
   ?};
   ~~
")

)
?};
~~


\stan_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Wyświetla listę stanów danego surowca w poszczególnych magazynach
::       Uwzględnia dane z tabeli S_REZ + przeniesienie do stanymag.fml
::  OLD: \stan_sur/zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
exec('stan_p','magazyn_stan',{? cur_tab(1,1)=TCHMAT || 'TCHMAT' || 'TMAT' ?});
~~


\czy_pf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2010]
:: OPIS: Czy technologia z półfabrykatami
::   WE: TKTL.ref()
::  OLD: \czy_pf/zlec1.fml
::----------------------------------------------------------------------------------------------------------------------
_pf:=0;
TMAT.cntx_psh();
TMAT.index('NL');
TMAT.prefix(_a);
{? TMAT.first()
|| {!
   |? {? TMAT.ACT='T' & (TMAT.RKTL<>'' | TMAT.DFLT_KTL='T')
      || _pf:=1; 0
      || TMAT.next()
      ?}
   !}
?};
TMAT.cntx_pop();
_pf


\tmat_analiza_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'przed' dla tabeli TMAT
::  OLD: \tmat_analiza_b/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('is_pdbuf','plan_dostaw')
||
   M.cntx_psh();
   VAR_DEL.delete('ppar');
   ppar:=obj_new(@.CLASS.TPAr,null());
   ppar.TABLE:=TPAR;
   ppar.INDEX:='NN';
   ppar.PREFIX:=VAR.A_KTL;
   ppar.KTM:={? VAR.ACTION='3' || TKTLW.KTM || TKTL.KTM ?};
   ppar.loadp();

   _dokl:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"KTM().DOKL",0);
   _xjm:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"XJM",0);
   {? TMAT.sel_size()=0
   ||
      exec('env_create','plan_dostaw');
      exec('env_ustaw_dokl','plan_dostaw',_dokl);
      {? VAR.ACTION='Z'
      || _dalej:=1
      || _dalej:=exec('env_edit_il','plan_dostaw',_xjm)
      ?}
   ||
      _dalej:=1
   ?};

   {? _dalej
   ||
      {? VAR.ACTION='Z'
      || _coef:=VAR.A_ZLEC().IL/_xjm
      || _coef:=exec('env_il','plan_dostaw')/_xjm
      ?};

      _args:=exec('pda_a','plan_dostaw');
      {? TMAT.GRKTM='K'
      || _args.M:=TMAT.PT;
         _dokl:=TMAT.PT().DOKL
      || _args.M:=TMAT.TGDFLT().PT;
         _dokl:=TMAT.TGDFLT().PT().DOKL
      ?};
      _args.TM_STAMP:=SYSLOG.tm_stamp();
      {? VAR.ACTION='Z'
      || {? exec('create','#tm_stamp',VAR.A_ZLEC().PL_DATA,ZL.PL_TIME)>SYSLOG.tm_stamp()
         || _args.DK:=ZL.PL_DATA;
            _args.TK:=ZL.PL_TIME
         ?}
      ?};
      _il:={? TMAT.FORMB<>'' || ppar.calc(TMAT.FORMB) || TMAT.WARB ?}*_coef;
      _il:={? TMAT.SO='S' || _il || -_il ?};
      _args.IL:={? _dokl=0 || ceil(_il) || _il$_dokl ?};
      _args.DW:=exec('env_date','plan_dostaw');
      _args.TW:=exec('env_time','plan_dostaw');
      _args.DISP:=0;
      _used:=exec('env_used_sum','plan_dostaw',_args.M);
      {? _used>0 || _args.insert_add($_args.M,_args.DW,_args.TW,_used) ?};
      _res:=exec('pda','plan_dostaw',_args);

      _argse:=exec('an_add_a','plan_dostaw');
      _argse.M:=_args.M;
      _argse.IL:=_args.IL;
      _argse.DW:=_args.DW;
      _argse.TW:=_args.TW;
      _argse.DOSTEPNY:=_res.DOSTEPNY;
      _argse.IL_DOST:=_res.IL_DOST;
      _argse.DM:=_res.NA_KIEDY;
      {? VAR.ACTION='Z'
      || ZLIM.index('RTMAT');
         ZLIM.prefix($TMAT.ref());
         {? ZLIM.first()
         || {!
            |? _argse.skip_add($ZLIM.ref());
               _zk_p:=exec('ZK_P_4_ZLIM','zamsiw_limit');
               {? _zk_p<>null() || _argse.skip_add($_zk_p) ?};
               ZLIM.next()
            !}
         ?}
      ?};
      {? _used>0 || _argse.insert_add($_args.M,_args.DW,_args.TW,_used) ?};
      exec('an_add','plan_dostaw',_argse);
      exec('env_used_add','plan_dostaw',_args.M,_args.DW,_args.TW,_args.IL);

      {? TMAT.sel_size()=0
      ||
         exec('an_select','plan_dostaw')
      ?}
   ?};

   {? TMAT.sel_size()=0
   ||
      exec('env_delete','plan_dostaw')
   ?};
   M.cntx_pop();
   VAR_DEL.delete('ppar')
?};
~~


\tmat_analiza_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'po' dla tabeli TMAT
::  OLD: \tmat_analiza_a/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\tmat_analiza_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'przed grupą' dla tabeli TMAT
::  OLD: \tmat_analiza_bg/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('is_pdbuf','plan_dostaw')
||
   _dokl:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"KTM().DOKL",0);
   _xjm:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"XJM",0);
   exec('env_create','plan_dostaw');
   exec('env_ustaw_dokl','plan_dostaw',_dokl);
   {? VAR.ACTION='Z'
   || 1
   |? exec('env_edit_il','plan_dostaw',_xjm)
   || 1
   || exec('env_delete','plan_dostaw');
      0
   ?}
|| 0
?}


\tmat_analiza_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'po grupie' dla tabeli TMAT
::  OLD: \tmat_analiza_ag/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('an_select','plan_dostaw');
exec('env_delete','plan_dostaw')


\tchm_analiza_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'przed' dla tabeli TCHMAT
::  OLD: \tchm_analiza_b/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('is_pdbuf','plan_dostaw')
||
   VAR_DEL.delete('ppar');
   ppar:=obj_new(@.CLASS.TPAr,null());
   ppar.TABLE:=TPAR;
   ppar.INDEX:='NN';
   ppar.PREFIX:=VAR.A_KTL;
   ppar.KTM:={? VAR.ACTION='3' || TKTLW.KTM || TKTL.KTM ?};
   ppar.loadp();

   _dokl:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"KTM().DOKL",0);
   _xjm:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"XJM",0);
   {? TCHMAT.sel_size()=0
   ||
      exec('env_create','plan_dostaw');
      exec('env_ustaw_dokl','plan_dostaw',_dokl);
      {? VAR.ACTION='Z'
      || _dalej:=1
      || _dalej:=exec('env_edit_il','plan_dostaw',_xjm)
      ?}
   ||
      _dalej:=1
   ?};

   {? _dalej
   ||
      {? VAR.ACTION='Z'
      || _coef:=ZL.IL/_xjm
      || _coef:=exec('env_il','plan_dostaw')/_xjm
      ?};

      _args:=exec('pda_a','plan_dostaw');
      {? TCHMAT.GRKTM='K'
      || _args.M:=TCHMAT.PT;
         _dokl:=TCHMAT.PT().DOKL
      || _args.M:=TCHMAT.TGDFLT().PT;
         _dokl:=TCHMAT.TGDFLT().PT().DOKL
      ?};
      _args.TM_STAMP:=SYSLOG.tm_stamp();
      {? VAR.ACTION='Z'
      || {? exec('create','#tm_stamp',VAR.A_ZLEC().PL_DATA,ZL.PL_TIME)>=SYSLOG.tm_stamp()
         || _args.DK:=ZL.PL_DATA;
            _args.TK:=ZL.PL_TIME
         ?}
      ?};
      _il:={? TCHMAT.FORMB<>'' || ppar.calc(TCHMAT.FORMB) || TCHMAT.WARB ?}*_coef;
      _il:={? TCHMAT.SRC().SO='S' || _il || -_il ?};
      _args.IL:={? _dokl=0 || ceil(_il) || _il$_dokl ?};
      _args.DW:=exec('env_date','plan_dostaw');
      _args.TW:=exec('env_time','plan_dostaw');
      _args.DISP:=0;
      _res:=exec('pda','plan_dostaw',_args);

      _argse:=exec('an_add_a','plan_dostaw');
      _argse.M:=_args.M;
      _argse.IL:=_args.IL;
      _argse.DW:=_args.DW;
      _argse.TW:=_args.TW;
      _argse.DOSTEPNY:=_res.DOSTEPNY;
      _argse.IL_DOST:=_res.IL_DOST;
      _argse.DM:=_res.NA_KIEDY;
      exec('an_add','plan_dostaw',_argse);

      {? TCHMAT.sel_size()=0
      ||
         exec('an_select','plan_dostaw')
      ?}
   ?};

   {? TCHMAT.sel_size()=0
   ||
      exec('env_delete','plan_dostaw')
   ?};

   VAR_DEL.delete('ppar')
?};
~~


\tchm_analiza_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'po' dla tabeli TCHMAT
::  OLD: \tchm_analiza_a/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\tchm_analiza_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'przed grupą' dla tabeli TCHMAT
::  OLD: \tchm_analiza_bg/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('is_pdbuf','plan_dostaw')
||
   _dokl:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"KTM().DOKL",0);
   _xjm:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"XJM",0);
   exec('env_create','plan_dostaw');
   exec('env_ustaw_dokl','plan_dostaw',_dokl);
   {? VAR.ACTION='Z'
   || 1
   |? exec('env_edit_il','plan_dostaw',_xjm)
   || 1
   || exec('env_delete','plan_dostaw');
      0
   ?}
|| 0
?}


\tchm_analiza_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'po grupie' dla tabeli TCHMAT
::  OLD: \tchm_analiza_ag/tex_tma1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('an_select','plan_dostaw');
exec('env_delete','plan_dostaw')


\action_mater_button
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Rejestrowanie surowców dla karty technologicznej - obsługa przycisku w oknie redagowania TKTL w czynnościach
::----------------------------------------------------------------------------------------------------------------------
_disp_all:=0;
:: Wyświetlane zawsze wszystkie
{? 1
::   TKTL.TYP().SUR='O'
|| _disp_all:=1
?};
exec('tmat_main','tech_mater',TKTL.ref(),null(),_disp_all,1,1,0);
''


\action_all_mater
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Podgląd listy wszystkich surowców
::----------------------------------------------------------------------------------------------------------------------
_disp_all:=0;
:: Wyświetlane zawsze wszystkie
{? 1
::   TKTL.TYP().SUR='O'
|| _disp_all:=1
?};
exec('tmat_main','tech_mater',TKTL.ref(),null(),_disp_all,0,0,0);
~~


\action_oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Rejestrowanie surowców dla operacji wzorca/ karty technologicznej - akcja z menu oknie wertowania operacji
::       gdy surowce przypisane są do operaji (pełne możliwości redagowania)
::   WE: _a - karta używana na wyższym poziomie wywołania (operacje)
::       _b - sposób selekcji okna operacji - "zakładki"
::   WY: tekst sterujący menu użytkownika / ~~
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_used:=_a;
_zakl:=_b;

_action:={? TKTL.TORW='W' || 'TTE_WTE_DRTS' || 'TTE_TEC_DRTS' ?};

{? TKTL.STAT_N='N'
|| exec('tmat_main','tech_mater',TKTL.ref(),TOPER.ref(),0,0,_used,_zakl)

|? TKTL.ARCH='N' & TKTL.STAT_S='N' & exec('chk_role','#b__box',OPERATOR.USER,_action)
|| _args:=exec('mp_run_a','#b__box');
   _args.ACT_UID:=_action;
   _args.UIDREF:=TKTL.uidref();
   _args.AKCJA:='SEL_O';
   _args.CONTEXT:=obj_new('oper','used','zakl');
   _args.CONTEXT.oper:=TOPER.ref();
   _args.CONTEXT.used:=_used;
   _args.CONTEXT.zakl:=_zakl;

   _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
   exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'TKTL',TKTL.ref());

   exec('mp_run','#b__box',_args)

|| exec('tmat_main','tech_mater',TKTL.ref(),TOPER.ref(),0,0,_used,_zakl)
?}


\stan_ktr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.53]
:: OPIS: Kontrola stanow w magazynach, czy starczy na wybrana serie
::       Sprawdzenie surowcow w ramach biezacej dziedziny TMAT.
::       Uwzgledniane jest zlecenie ustawione w VAR.A_ZLEC
::   WE:  a=0 (funkcja wywolana podczas kontroli stanow surowcow)
::   WY:  0 - (nie mozna zatwierdzic zlecenia)
::        1 - (mozna zatwierdzic zlecenie)
::        ~~  - gdy funkcja nie wywol. z par _a=1
::  OLD: \stan_ktr/zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

{? VAR.A_KTL().TORW='Z' & TKTL.PLRELWYR<>null()
|| FUN.info('Funkcja niedostępna dla zleceń bez własnej technologii utworzonych na podstawie analizy wykonania.'@);
   return()
?};

{? _>0
|| _brak:='N';
   TMAT.cntx_psh();
   VAR_DEL.delete('__TAC');
   __TAC:=tab_tmp(1,
      'TMAT','STRING[16]','$TMAT.ref()',
      'T','INTEGER','#M.ref() - materiał',
      'ZAP','REAL','Zapotrzebowanie',
      'DOST','REAL','Dostępne',
      'ILE','REAL','Ile można wyprodukować',
      'LIMPRZY','REAL','Limity zleceń w przygotowaniu',
      'LIMOTW','REAL','Limity zleceń otwartych',
      'POBR','REAL','Pobrania do limitów',
      'POLF','REAL','Półfabrykaty',
      'BRAK','REAL','Brakuje',
      'ZLIM','STRING[1]','Zmzl');

:: Zlecenie proste
   {? VAR.A_ZLEC().RODZAJ='P'
   || _dostil:=ZL.IL;
      VAR.A_T:=null();
      {? TMAT.first()
      || {!
         |? {? TMAT.SO='S' & tpar.calc(TMAT.EXIST)
            || _result:=exec('stan_ktr_1','tech_mater',$TMAT.ref());
               __TAC.blank();
               __TAC.TMAT:=$TMAT.ref();
               __TAC.T:={? TMAT.GRKTM='G' || #TMAT.TGDFLT().PT || #TMAT.PT ?};
               __TAC.ZAP:=_result[2];
               __TAC.DOST:=_result[3];
               __TAC.BRAK:=-_result[4];
               __TAC.LIMPRZY:=_result[5];
               __TAC.LIMOTW:=_result[6];
               __TAC.POBR:=_result[7];
               __TAC.ILE:=_result[8];
               __TAC.POLF:=_result[9];
               __TAC.ZLIM:='M';
               __TAC.add();
               {? _result[4]<0
               || _brak:='T';
                  {? _dostil>_result[8]
                  || _dostil:=_result[8]
                  ?}
               ?};
               obj_del(_result)
            ?};
            TMAT.next()
         !}
      ?}

:: Zlecenie zlozone - tu nie powinno dojsc
   ||
      ZL.cntx_psh();
      _zl:=VAR.A_ZLEC;
      ZL.prefix();
      ZL.index('NRNZL');
      ZL.prefix(VAR.A_ZLEC().UNRZL);
      {? ZL.first()
      || {!
         |? VAR.A_ZLEC:=ZL.ref();
            _dostil:=ZL.IL;
            VAR.A_T:=null();
            {? TMAT.first()
            || {!
               |? {? TMAT.SO='S'
                  || _result:=exec('stan_ktr_1','tech_mater',$TMAT.ref());
                     __TAC.blank();
                     __TAC.TMAT:=$TMAT.ref();
                     __TAC.T:={? TMAT.GRKTM='G' || #TMAT.TGDFLT().PT || #TMAT.PT ?};
                     __TAC.ZAP:=_result[2];
                     __TAC.DOST:=_result[3];
                     __TAC.BRAK:=-_result[4];
                     __TAC.LIMPRZY:=_result[5];
                     __TAC.LIMOTW:=_result[6];
                     __TAC.POBR:=_result[7];
                     __TAC.ILE:=_result[8];
                     __TAC.POLF:=_result[9];
                     __TAC.ZLIM:='M';
                     __TAC.add();
                     {? _result[4]<0
                     || _brak:='T';
                        {? _dostil>_result[8]
                        || _dostil:=_result[8]
                        ?}
                     ?};
                     obj_del(_result)
                  ?};
                  TMAT.next()
               !}
            ?};
            ZL.next()
         !}
      ?};
      VAR.A_ZLEC:=_zl;
      ZL.cntx_pop()

   ?};

   _wer:=__TAC.mk_sel('Dostępność surowców w magazynach'@,'N',0,'stan_ktr_wer',,2);
   __TAC.win_fld(_wer,@.M,'KTM',,,,,,'Surowiec'@);
   __TAC.win_fld(_wer,,'ZAP',,,15,4,,'Zapotrz.'@);
   __TAC.win_fld(_wer,,'DOST',,,15,4,,'Dostępne'@);
   __TAC.win_fld(_wer,@.VAR,'REAL',,,15,4,,'Brakuje'@);
   __TAC.win_fml(_wer,@.VAR,'REAL',,'ICON_BEFORE',"
      {? __TAC.BRAK>0 || '' || 'xwin16.png:38' ?}
   ");
   __TAC.win_fld(_wer,,'POLF',,,15,4,,'Półfabrykaty'@);
   __TAC.win_act(_wer,0,'Rekord',,,,"
      VAR.A_T:=null();
      M.clear();
      {? ~M.seek(__TAC.T,'material') || M.KTM:='' ?};
      VAR.REAL:={? __TAC.BRAK>0 || __TAC.BRAK || 0 ?};
      {? __TAC.BRAK>0 || exec('findtmp','#color') || '' ?}
   ");
   __TAC.win_act(_wer,0,'Wyświetl',,,,"
      M.clear();
      _is:=M.seek(__TAC.T,'material');
      undefine();
      define('H0',~~);
      define('KTM',{? _is || M.KTM || '' ?},'Kod'@,,50);
      define('NAZ',{? _is || M.N || '' ?},'Nazwa'@,,100);
      define('H1',~~);
      define('ZAP',__TAC.ZAP,'Zapotrzebowanie'@,,,,4);
      define('DOST',__TAC.DOST,'Dostępne'@,,,,4);
      define('LIMPRZY',__TAC.LIMPRZY,'Limity dla zleceń w przygotowaniu'@,,,,4);
      define('LIMOTW',__TAC.LIMOTW,'Limity dla zleceń otwartych'@,,,,4);
      define('POLF',__TAC.POLF,'Półfabrykaty bieżącego zlecenia'@,,,,4);
      define('POBR',__TAC.POBR,'Pobrania'@,,,,4);
      define('ILE',__TAC.ILE,'Można wyprodukować'@,,,,4);
      define('H2',~~);
      {? __TAC.BRAK > 0
      || define('BRAK',__TAC.BRAK,'Brakuje'@,,,,4)
      || define('BRAK',~~,'Ilość surowca wystarczająca'@);
         define('BRAK1',~~,'do powołania produkcji'@)
      ?};
      define('H3',~~);
      def_disp('Dostępność surowca'@);
      ~~
   ");
   {? _a<>3
   || __TAC.win_act(_wer,0,'Formuła','Zamień surowiec'@@,,,"
         {? __TAC.POLF=0
               |
            __TAC.BRAK>__TAC.POLF
               |
            FUN.ask(
               'Ilość półfabrykatu na zleceniu półfabrykatowym wystarczająca do realizacji zlecenia.\n'+
               'Czy chcesz wprowadzić zmianę?'@
            )
         || params_exec('zamien','tech_mater')
         ?}","
         exec('change_sur','tech_mater',__TAC.TMAT,VAR.A_T);1",1);
      __TAC.win_act(_wer,0,'Formuła','S&tany'@@,,,"exec('stan_d','magazyn_stan',__TAC.T,__TAC.ZAP);~~",,0);
      _fb:="
         {? exec('is_pdbuf','plan_dostaw')
         ||
            M.cntx_psh();
            M.clear();
            {? M.seek(__TAC.T,)
            ||
               _args:=exec('pda_a','plan_dostaw');
               _args.M:=M.ref();
               _args.DK:=ZL.PL_DATA;
               _args.TK:=ZL.PL_TIME;
               _args.DISP:=1;
               _args.IL:=__TAC.ILE;
               _args.DW:=ZL.PL_DATA;
               _args.TW:=ZL.PL_TIME;
               exec('pda','plan_dostaw',_args)
            ?};
            M.cntx_pop()
         ?}
      ";
      __TAC.win_act(_wer,0,'Formuła','Analiza'@@,,'Analiza dostępności materiału w czasie'@,_fb)
   ?};
   __TAC.win_act(_wer,,'Formuła','Legenda'@@,,,"exec('legenda','color','$%1'['Brak surowca'@])");
   M.prefix();
   __TAC.win_sel(_wer);
   _wybor:=2;
   {? _brak='T' & _a=0
   || _wybor:=choice('Brak co najmniej jednego surowca.\nCzy dokonać zamiany brakujących surowców?'@,
                     FUN.TYT,'ASK',1,1,,'Ręcznie'@,'Automatycznie'@,'Anuluj'@);
      {? _wybor=0
      || __TAC.select()
      ?}
   |? _a=0 & _brak='N'
   || FUN.info('Aktualna ilość surowców wystarczająca do utworzenia zlecenia.'@)
   |? _a=3
   || __TAC.select()
   ?};
   {? _wybor=1
   || KOMM.init(150,,'Automatyczna zmiana surowców'@,'');
      _sect:=KOMM.sect_beg('init');
      do();
      _x_polf:=_x_sur:=0;
      {? __TAC.first()
      || {!
         |?
::          Pomijane sa surowce, na ktore powolane jest juz powiazane zlecenie polfabrykatowe
            {? __TAC.BRAK>0 & __TAC.POLF=0
            || TMAT.cntx_psh();
               TMAT.clear();
               {? TMAT.seek(__TAC.TMAT,8+__TAC.TMAT)
               || KOMM.sect_beg('Zamiana surowca: %1'@[{? TMAT.GRKTM='G' || TMAT.TGDFLT().PT().KTM || TMAT.PT().KTM ?}],,,1);
                  exec('zamsuraut','tech_mater',0);
                  KOMM.sect_end()
               ?};
               TMAT.cntx_pop();
               _x_sur+=1
            |? __TAC.BRAK>0
            || _x_polf+=1
            ?};
            __TAC.next()
         !}
      ?};
      {? ~end()
      || KOMM.update(_sect,'Automatyczna zamiana nie została zakończona prawidłowo:'@);
         KOMM.sect_end();
         KOMM.add('Niewystarczająca ilość materiału wśród zamienników — zmiany zostały wycofane i należy je wykonać ręcznie.'@)
      || {? _x_polf=0 & _x_sur>0
         || KOMM.update(_sect,'Zamiana dokonana prawidłowo:'@);
            KOMM.sect_end();
            KOMM.add('Iość zamienionych surowców: %1'@[$_x_sur])
         |? _x_polf>0 & _x_sur>0
         || KOMM.update(_sect,'Zamiana dokonana prawidłowo:');
            KOMM.sect_end();
            KOMM.add('Ilość zamienionych surowców: %1'@[$_x_sur]);
            KOMM.add('Ilość pominiętych półfabrykatów: %1'@[$_x_polf])
         || KOMM.update(_sect,'Automatyczna zamiana nie została dokonana, braki dotyczą wyłącznie zleconych półfabrykatów:'@);
            KOMM.sect_end();
            KOMM.add('Ilość pominiętych półfabrykatów: %1'@[$_x_polf])
         ?}
      ?};
      KOMM.select()
   ?};
   obj_del(__TAC);
   TMAT.cntx_pop();
   {? var_pres('__MASKI')>0 || obj_del(__MASKI) ?}
?}


\stan_ktr_1
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Wylicza zapotrzebownie materialu technologicznego
::   WE: _a - $TMAT.ref()
::   WY: tablica z wartosciami zapotrzebowania
::  OLD: \stan_ktr_1/zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
_tmat:=_a;

TMAT.cntx_psh(); TMAT.clear();
ZL.cntx_psh();
TMAT.seek(_tmat,8+_tmat);

_ktm:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};
:: norma brutto surowca na xjm wg technologii
_warb:={? TMAT.FORMB<>'' || tpar.calc(TMAT.FORMB) || TMAT.WARB ?};
:: xjm, czyli na ile wyrobow definiowana technologia
_xjm:=TMAT.NRK().XJM;
:: ilosc wyrobow do wyprodukowania na zlecenie
_il:=TMAT.NRK().ZL().IL;
:: zapotrzebowanie na surowiec
{? _xjm<>0
|| _dokl:=exec('jaka_dok_m','jm',_ktm);
   {? _dokl>0
   || _zap:=(_warb*_il/_xjm)$_dokl
   || _zap:=ceil(_warb*_il/_xjm)
   ?}
|| _zap:=0
?};
{? var_pres('__MASKI')<=0 || __MASKI:=ZLIM.names() ?};
_result:=exec('stan_ktr_one','zl_limit',_ktm,_zap,0);
{? _warb<>0 || _result[8]:=_xjm*_result[3]/_warb || _result[8]:=0 ?};
TMAT.cntx_pop(); ZL.cntx_pop();
_result


\zamien
::----------------------------------------------------------------------------------------------------------------------
::  MOD: MKO [8.60]
:: OPIS: Formula wywolywana z poziomu zatwierdzania limitow zlecenia dla akcji "Zamien surowiec"
::  OLD: \zamien/zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

TMAT.cntx_psh();
TMAT.clear();

{? TMAT.seek(__TAC.TMAT,8+__TAC.TMAT)
|| M.clear();
   {? VAR.A_T=null()
   || M.seek(__TAC.T,'material');
      VAR.A_T:=M.ref()
   ?};
   exec('zamsur','tech_mater',__TAC.TMAT,0);
   _ktm:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};
   _dokl:=exec('jaka_dok_m','jm',_ktm);
   __TAC.ZAP:={? _dokl>0
              || (TMAT.WARB*TMAT.NRK().ZL().IL/TMAT.NRK().XJM)$_dokl
              || ceil((TMAT.WARB*TMAT.NRK().ZL().IL/TMAT.NRK().XJM))
              ?};
   _result:=exec('stan_ktr_1','tech_mater',__TAC.TMAT);
   __TAC.T:=#_ktm;
   __TAC.ZAP:=_result[2];
   __TAC.DOST:=_result[3];
   __TAC.BRAK:=-_result[4];
   __TAC.LIMPRZY:=_result[5];
   __TAC.LIMOTW:=_result[6];
   __TAC.POBR:=_result[7];
   obj_del(_result);
   _ref:=__TAC.ref();
   __TAC.put();
   __TAC.cntx_psh();
   __TAC.first();
   {!
   |? {? __TAC.ref()<>_ref
      || _result:=exec('stan_ktr_1','tech_mater',__TAC.TMAT);
         __TAC.ZAP:=_result[2];
         __TAC.DOST:=_result[3];
         __TAC.BRAK:=-_result[4];
         __TAC.LIMPRZY:=_result[5];
         __TAC.LIMOTW:=_result[6];
         __TAC.POBR:=_result[7];
         obj_del(_result);
         __TAC.put()
      ?};
      __TAC.next()
   !};
   __TAC.cntx_pop()
?};

TMAT.cntx_pop();
~~


\change_sur
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Zamiana towaru na pozycjach limitow
::   WE: _a - $TMAT.ref()
::       _b - M.ref()
::  OLD: \change_sur/zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
TMAT.cntx_psh();
ZLIM.cntx_psh();
{? TMAT.seek(_a,8+_a)
||
:: sprawdzamy czy zostal zastosowany zamiennik, jezeli tak to zamieniamy tez towar w powiazanych limitach
:: Ze wzgledu na ten warunek formula... nic nie zrobi
   _ktm:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};
   {? _ktm<>_b
   ||
      ZLIM.index('ZKK');
      ZLIM.prefix(TMAT.NRK().ZL,'T',0,_b);
      {? ZLIM.first()
      || {!
         |? {? ZLIM.AKC='N'
            ||
               ZLIM.KTM:=_ktm;
               _dokl:=exec('jaka_dok_m','jm',_ktm);
               ZLIM.LIL:={? _dokl>0
                         || (TMAT.WARB*TMAT.NRK().ZL().IL/TMAT.NRK().XJM)$ _dokl
                         || ceil(TMAT.WARB*TMAT.NRK().ZL().IL/TMAT.NRK().XJM)
                         ?};
               ZLIM.prefix();
               ZLIM.put()
            ?};
            ZLIM.next()
         !}
      ?}
   ?}
?};
ZLIM.cntx_pop();
TMAT.cntx_pop();
~~


\zamsur
::----------------------------------------------------------------------------------------------------------------------
:: MOD: MKO [8.60]
:: OPIS: Funkcja wywoluje obiekt do obslugi zamiennikow
::   WE: _a: $TMAT.ref
::       _b: 1 - wywolywana z poziomu zatwierdzania kart limitowych.
::           0 - wywolywana z poziomu zatwierdzania limitow.
::  OLD: \zamsur/zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

TMAT.seek(_a,8+_a);
exec('pokaz_zam_mech','tech_mater',{? _b=1 || 7 || 1 ?});
~~


\zamsuraut
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [MLAK]
::  MOD: MLAK [2008]
:: OPIS: Automatyczna zamiana surowcow na zamienniki.
::       Uwzgledniany jest wylacznie surowiec zrodlowy oraz zamienniki wg technologii zlecenia.
::       W przypadku nieudanej podmiany funkcja zrywa transakcje.
::   WE: [_a] - czy wyswietlac komunikaty (domyslnie 1), czy ladowac do KOMMa (0)
::  OLD: \zamsuraut/zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

{? var_pres('_a')=type_of(0) || _display:=_a || _display:=1 ?};

_zamiana:=0;

VAR.A_T:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};

{? TMAT.GRKTM='G'
|| _old_kod:=TMAT.TGDFLT().PT().KTM
|| _old_kod:=TMAT.PT().KTM
?};

:: xjm, czyli na ile wyrobow definiowana technologia
_xjm:=TMAT.NRK().XJM;
:: ilosc wyrobow do wyprodukowania na zlecenie
_il:=TMAT.NRK().ZL().IL;

:: Sprawdzenie, czy starczy oryginalnego surowca
{? TMAT.SRC<>''
|| TMAT.cntx_psh();
   TMAT.prefix();
   {? TMAT.seek(TMAT.SRC,8+TMAT.SRC)
   || {? TMAT.GRKTM='G'
      || _ktm:=TMAT.TGDFLT().PT;
         _new_kod:=TMAT.TGDFLT().PT().KTM
      || _ktm:=TMAT.PT;
         _new_kod:=TMAT.PT().KTM
      ?};
      {? _ktm<>VAR.A_T
      || mat:=null();
         _formn:=TMAT.FORMN;
         _warn:={? TMAT.FORMN<>''
                || tpar.calc(TMAT.FORMN)$ exec('round_abe','tech_mater',TMAT,1)
                || TMAT.WARN
                ?};
         _formb:=TMAT.FORMB;
         _warb:={? TMAT.FORMB<>''
                || tpar.calc(TMAT.FORMB)$ exec('round_abe','tech_mater',TMAT,1)
                || TMAT.WARB
                ?};
         _dformn:=TMAT.DFORMN;
         _dwarn:={? TMAT.DFORMN<>''
                 || tpar.calc(TMAT.DFORMN)$ exec('round_abe','tech_mater',TMAT,1)
                 || TMAT.DWARN
                 ?};
         _dformb:=TMAT.DFORMB;
         _dwarb:={? TMAT.DFORMB<>''
                 || tpar.calc(TMAT.DFORMB)$ exec('round_abe','tech_mater',TMAT,1)
                 || TMAT.DWARB
                 ?};
         _exist:=TMAT.EXIST;
         _opis:=TMAT.OPIS;
         _dfltktl:=TMAT.DFLT_KTL;
         _ktl:=TMAT.KTL;
         _rktl:=TMAT.RKTL;
         _mag:=TMAT.MAG;
         _grktm:=TMAT.GRKTM;
         _pt:=TMAT.PT;
         _tgrp:=TMAT.TGRP;
         _tgdflt:=TMAT.TGDFLT;
         _dfltktl:=TMAT.DFLT_KTL;

::       zapotrzebowanie na surowiec
         _dokl:=exec('jaka_dok_m','jm',_ktm);
         _zap:={? _dokl>0
               || (_warb*_il/_xjm)$_dokl
               || ceil(_warb*_il/_xjm)
               ?};
         _result:=exec('stan_ktr_one','zl_limit',_ktm,_zap);

         {? _result[4]>=0
         || TMAT.cntx_pop();
            {? exec('sprktm','tech_mater',TMAT,_ktm,_display)
            || TMAT.FORMN:=_formn;
               TMAT.WARN:=_warn;
               TMAT.FORMB:=_formb;
               TMAT.WARB:=_warb;
               TMAT.DFORMB:=_dformb;
               TMAT.DWARB:=_dwarb;
               TMAT.DFORMN:=_dformn;
               TMAT.DWARN:=_dwarn;
               TMAT.EXIST:=_exist;
               TMAT.OPIS:=_opis;
               TMAT.GRKTM:=_grktm;
               TMAT.PT:=_pt;
               TMAT.TGRP:=_tgrp;
               TMAT.TGDFLT:=_tgdflt;
               TMAT.DFLT_KTL:=_dfltktl;
               TMAT.KTL:=_ktl;
               TMAT.RKTL:=_rktl;
               TMAT.MAG:=_mag;
               TMAT.put();
               _zamiana:=1;
               {? ~_display
               || KOMM.add('Zamieniono '+_old_kod+' -> '+_new_kod,,,1)
               ?}
            ?};
            TMAT.cntx_psh()
         ?};
         obj_del(_result);
         &mat
      ?}
   ?};
   TMAT.cntx_pop()
?};

TMAT.cntx_psh();
TCHMAT.cntx_psh();
{? _zamiana=0
|| TCHMAT.index('ASL');
   TCHMAT.prefix('T',TMAT.ref());
   {? TCHMAT.first()
   || {!
      |? {? TCHMAT.GRKTM='G'
         || _ktm:=TCHMAT.TGDFLT().PT;
            _new_kod:=TCHMAT.TGDFLT().PT().KTM
         || _ktm:=TCHMAT.PT;
            _new_kod:=TCHMAT.PT().KTM
         ?};

         {? _ktm<>VAR.A_T
         || mat:=null();
            {? exec('sprktm','tech_mater',TMAT,_ktm,_display)
            ||
::             norma brutto surowca na xjm wg technologii
               _warb:={? TCHMAT.FORMB<>''
                      || tpar.calc(TCHMAT.FORMB) $ exec('round_abe','tech_mater',TCHMAT,1)
                      || TCHMAT.WARB
                      ?};
::             zapotrzebowanie na surowiec
               _dokl:=exec('jaka_dok_m','jm',_ktm);
               _zap:={? _dokl>0
                     || (_warb*_il/_xjm)$_dokl
                     || ceil(_warb*_il/_xjm)
                     ?};
               _result:=exec('stan_ktr_one','zl_limit',_ktm,_zap);
               {? _result[4]>=0
               ||
                  _warn:={? TCHMAT.FORMN<>''
                         || tpar.calc(TCHMAT.FORMN) $ exec('round_abe','tech_mater',TCHMAT,1)
                         || TCHMAT.WARN
                         ?};
                  _dwarb:={? TCHMAT.DFORMB<>''
                          || tpar.calc(TCHMAT.DFORMB) $ exec('round_abe','tech_mater',TCHMAT,1)
                          || TCHMAT.DWARB
                          ?};
                  _dwarn:={? TCHMAT.DFORMN<>''
                          || tpar.calc(TCHMAT.DFORMN) $ exec('round_abe','tech_mater',TCHMAT,1)
                          || TCHMAT.DWARN
                          ?};
                  TMAT.FORMN:=TCHMAT.FORMN;
                  TMAT.WARN:=_warn;
                  TMAT.FORMB:=TCHMAT.FORMB;
                  TMAT.WARB:=_warb;
                  TMAT.DFORMB:=TCHMAT.DFORMB;
                  TMAT.DWARB:=_dwarb;
                  TMAT.DFORMN:=TCHMAT.DFORMN;
                  TMAT.DWARN:=_dwarn;
                  TMAT.EXIST:=TCHMAT.EXIST;
                  TMAT.OPIS:=TCHMAT.OPIS;
                  TMAT.GRKTM:=TCHMAT.GRKTM;
                  TMAT.PT:=TCHMAT.PT;
                  TMAT.TGRP:=TCHMAT.TGRP;
                  TMAT.TGDFLT:=TCHMAT.TGDFLT;
                  TMAT.DFLT_KTL:=TCHMAT.DFLT_KTL;
::                Obsluga technologii dla polfabrykatu - jezeli archiwalna, to czyszcze
                  {? TCHMAT.RKTL<>'' & TCHMAT.KTL=null()
                  || TMAT.KTL:=null();
                     TMAT.RKTL:=''
                  || TMAT.KTL:=TCHMAT.KTL;
                     TMAT.RKTL:=TCHMAT.RKTL
                  ?};
                  TMAT.MAG:=TCHMAT.MAG;
                  TMAT.put();
                  _zamiana:=1;
                  {? ~_display
                  || KOMM.add('Zamieniono %1 -> %2'@[_old_kod,_new_kod],,,1)
                  ?};
                  TCHMAT.last()
               ?};
               obj_del(_result)
            ?};
            &mat
         ?};
         TCHMAT.next()
      !}
   ?}
?};
TCHMAT.cntx_pop();
TMAT.cntx_pop();

{? _zamiana=0
|| {? ~_display
   || KOMM.add('Nie zamieniono %1'@[_old_kod],,,1)
   ?};
   undo()
?};
~~


\tmat4zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza, czy podany surowiec technologii nadaje się do powołania zlecenia półfabrykatowego
::       - jest półfabrykatem, z określoną technologią lub kartą domyślną, nie jest przeznaczony do pobrania z magazynu
::       - jest przypisany do technologii zlecenia, które jest zleceniem w strukturze zlecenia złożonego
::   WE: _a - TMAT.ref()
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_formula:="
   TKTL.cntx_psh();
   _result:=
      (TMAT.RKTL<>'' | TMAT.DFLT_KTL='T') &
      TMAT.MAG<>'T' &
      TMAT.NRK().ZL<>null() &
      exec('top_rodzaj','zl_link',TKTL.ZL)='Z';
   TKTL.cntx_pop();
   _result
";
exec('FindAndGet','#table',TMAT,_a,,_formula,0)


\uprDelSurZatwZl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [12.46]
:: OPIS: Sprawdzenie uprawnienia do usuwania surowców zleceń z zatwierdzonymi technologiami
::  OLD: \uprDelSurZatwZl/zlec6.fml
::----------------------------------------------------------------------------------------------------------------------
exec('get','#params',8903,2,OPERATOR.USER)='T'


\delTmatZl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: SZP [2015]
:: OPIS: Usuwa TMAT do zlecenia
::   WE: _a - ZL.ref() - zlecenie z którego usuwać
::       _b - M.ref()  - materiał który usuwać
::       [_c] - INTEGER  - 0/[1] - czy wyświetlać pytania
::       [_d] - INTEGER  - [0]/1 - czy usuwać limity skojarzone z TMATem
::       [_e] - INTEGER  - 0(domyślnie) - usunięcie 1-zmiana rezerwacji warunkowej na limicie na zwykłą
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_ktm:=_b;

_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};

_del_lim:=0;
{? var_pres('_d')=type_of(0)
|| _del_lim:=_d
?};

_noded:={? var_pres('_e')=type_of(0)  || _e || 0 ?};

_uprDelSur:=exec('uprDelSurZatwZl','tech_mater');
ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
|| _tech:=ZL.TKTL;
   TMAT.cntx_psh();
   TMAT.index('PT');
   TMAT.prefix(_tech);
   _ok:=0;
   {? TMAT.first()
   || {!
      |?
         _aktm:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};
         {? _aktm=_ktm
         || _ok:=1
         ?};
         ~_ok & TMAT.next()
      !}
   ?};

   {? _dialog>0
   || _ok:=FUN.ask('Usunąć półfabrykat ze zlecenia nadrzędnego: %1?'@[ZL.SYM])
   ?};
   {? _ok>0
   || {? ~_noded
      || exec('usuntmat','tech_mater',0,_del_lim)
      || {? TMAT.NRK().ZL<>null()
         || ZL.cntx_psh();
            ZLIM.cntx_psh();
            exec('openmask','zl_common',ZL.ref());
            ZLIM.index('RTMAT');
            ZLIM.prefix($TMAT.ref());
            {? ZLIM.first()
            || VAR_DEL.delete('__aktzkp');
               __aktzkp:=tab_tmp(1,'MAT','STRING[16]',''
                          ,'NRK','INTEGER',''
                          ,'ILR','REAL','');
               {!
               |? {? ZLIM.KTM=_ktm
                  || REZ.cntx_psh();
                     REZ.index('ZL');
                     REZ.prefix(ZLIM.ZLEC,'Z','W',ZLIM.KTM,'T');
                     {? REZ.first()
                     || {!
                        |? _ref:=REZ.ref(); _next:=REZ.next();
                           REZ.cntx_psh();
                           REZ.prefix();
                           {? REZ.seek(_ref)
                           || __aktzkp.clear();
                              {? __aktzkp.find_key($REZ.M)
                              || __aktzkp.ILR+=REZ.ILR;
                                 __aktzkp.put(1)
                              || __aktzkp.blank();
                                 __aktzkp.MAT:=$REZ.M;
                                 __aktzkp.ILR:=REZ.ILR;
                                 __aktzkp.NRK:=exec('FindInSet','#table','REZ','RODZ',REZ.M,'W',"REZ.NRK",,,0);
                                 __aktzkp.add(1)
                              ?};
                              REZ.RP_REZ:='N';
                              REZ.put(1)
                           ?};
                           REZ.cntx_pop();
                           _next
                        !}
                     ?};
                     REZ.cntx_pop()
                  ?};
                  ZLIM.next()
               !};
               __aktzkp.clear();
               {? __aktzkp.first()
               || {!
                  |? _refm:=exec('FindAndGet','#table','M',__aktzkp.MAT,,,null());
                     exec('aktu_rez','rezerwacje',_refm,__aktzkp.NRK,__aktzkp.ILR);
                     __aktzkp.next()
                  !}
               ?};
               VAR_DEL.delete('__aktzkp')
            ?};
            ZL.cntx_pop();
            ZLIM.cntx_pop()
         ?}
      ?}
   ?};
   TMAT.cntx_pop()
?};
ZL.cntx_pop();
~~


\struktura
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Struktura produktu w karcie technologicznej
::----------------------------------------------------------------------------------------------------------------------
exec('sur_all','tech_mater')


\sur_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.53] OWwPR011/5.7
:: OPIS: obiektem wszystko w jednej tmp_tab
::   WE: _=0           -> struktura surowców
::       _=1 & _[1]=~~ -> surowce elementarne
::  OLD: \sur_all/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? _=0 | _=1 & type_of(_[1])=0
||
::----------------------------------------------------------------------------------------------------------------------
:: deklaracja klasy SURX
::----------------------------------------------------------------------------------------------------------------------
   exec('surx_decl','tech_mater');
::----------------------------------------------------------------------------------------------------------------------
:: inicjowanie obiektu klasy SURX i selekcja listy surowcow technologii
::----------------------------------------------------------------------------------------------------------------------
   VAR_DEL.delete('__SUR');

   {? _=0
   || __Fazy:=0
   || __Fazy:=choice('Czy wyświetlać z rozbiciem na fazy produkcji?'@,FUN.TYT,'ASK',1,1,,'Tak'@,'Nie'@,'Anuluj'@)
   ?};
   {? __Fazy>1 || &__Fazy; return() || __Fazy:=~__Fazy ?};
   exec('env_create','tech_structure',1);
   _env:=__ENV_STR;
::  Rozpoczynam pętle
   _exit:=1;
   {!
   |?
      {? var_press('TAB',__ENV_STR.CHECK) > 0 || _env.CHECK.TAB.erase() ?};
      {? var_pres('__SUR') > 0 || obj_del(__SUR) ?};
      __SUR:=obj_new(@.CLASS.SURX,VAR.A_KTL,'T',__Fazy,,VAR.A_KTL().XJM);
::     Wyświetlam tabelę z problemami i uzupełniam tabelę zamienników
      _ok:=1;
      {? _env.CHECK.TAB.size()>0
      || _env.CHECK.TAB.win_sel(_env.CHECK.WERA);
         _ok:=exec('tktl_chck_sel','tech_structure'
               ,{? cur_tab(1,1).name(1)*'txktl' || 1 |? cur_tab(1,1).name(1)*'txktw' || 2  || 0 ?} );
         {? _ok=0 || _exit:=0 ?}
      || _exit:=0
      ?};
   _exit
   !};
::Koniec pętli
   {? _ok
   ||
      {? _=0
      || set_virt(__SUR,'tree',"
            _wer:=.TAB.mk_sel(
               'Struktura produktu dla ilości: %1 %2 — karta: %3 wersja: %4'@[$.ILOSC,TKTL.JM().KOD,TKTL.NRK,TKTL.WER],
               'N',,'#tree_tmater_st',,5,,1
            );
            .TAB.index(.NDX1);
            .TAB.win_fld(_wer,,'PT_S',,,20,,,'Kod'@);
            .TAB.win_fld(_wer,,'PT_N',,,36,,,'Nazwa'@);
            .TAB.win_fld(_wer,,'SO',,,-3,,,'Odpad?'@,
               ,'Znacznik, czy surowiec jest odpadem/koproduktem'@,2,,\"'O'\",\"'S'\");
            .TAB.win_fld(_wer,,'PFAZ_S',,,-10,,,'Faza produkcji'@);
            .TAB.win_fld(_wer,,'WARB',,,14,ST.DOKL,,'Norma brutto'@);
            .TAB.win_fld(_wer,,'PT_JM',,,5,,,'jm'@);
            .TAB.win_fld(_wer,,'KTL_NRK',,,-20,,,'Karta technologiczna'@);
            .TAB.win_fld(_wer,,'KTL_WER',,,6,,,'Wersja'@);
            .TAB.win_act(_wer,,'Formuła','Zwiń/roz&wiń'@@,,'Zwiń/rozwiń wszystkie rekordy'@,
               \"exec('zwrw_all','#tree','__SUR.TAB','UPNODE')\",,1);
            .TAB.win_act(_wer,,'Wyświetl',,,,$(!.ME+\".f_displ()\"));
            .TAB.win_act(_wer,,'Rekord',,,,\"
                                             ~~
                                           \");
            .TAB.win_sel(_wer);
            .TAB.win_act(_wer,,'Formuła','Druku&j'@@,,'',
               \"{? __SUR.TAB.UPNODE=0 || exec(\'rep_exec\',\'#b_report\',\'TTE_PZL_XXXX\',\'tte_an_tpl*\',\'Wydruki struktur produktu\',1) || FUN.info(\'Wydruk tylko dla najwyższego poziomu.\'@) ?}\",,,,,,,,\'icon=print\');
            .TAB.win_act(_wer,,'Formuła','Legenda'@@,,,\"exec('legenda','color','#STR#01')\",,,,,,'L');
            .TAB.win_fml(_wer,,'PT_S',,'ICON_BEFORE',\"
                                                       {? __SUR.TAB.WPM='M'
                                                       || 'xwin16.png:71'
                                                       |? __SUR.TAB.WPM='P'
                                                       || 'xwin16.png:158'
                                                       || ''
                                                       ?}
                                                     \");
            .TAB.select();
            ~~
         ");
         set_virt(__SUR,'f_displ',"
            {? __SUR.TAB.RTMAT<>''
            || _okno:=TMAT.win_edit('?');
               TKTL.cntx_psh();
               TMAT.cntx_psh();
               _msk_tmat:=form(8+__SUR.TAB.RTMAT);
               _msk_tktl:=(TKTL.name()-3)+(_msk_tmat+3);
               TMAT.use(_msk_tmat);
               TKTL.use(_msk_tktl);
               TMAT.clear();
               {? TMAT.seek(__SUR.TAB.RTMAT)
               ||
                  {? TMAT.GRKTM='K'
                  || VAR.A_T:=TMAT.PT
                  || VAR.A_T:=TMAT.TGDFLT().PT
                  ?};
                  {? __SUR.TAB.PAR='T'
                  ||
::                technologia parametryzowalna
                     TMAT.win_edit('RED_T')
                  || TMAT.win_edit('RED_N')
                  ?};
                  exec('tmat_display','tech_mater')
               ?};
               TMAT.win_edit(_okno);
               TMAT.cntx_pop();
               TKTL.cntx_pop()
            || FUN.info('Pozycja zsumowana z kilku operacji — nie można wyświetlić szczegółów.'@)
            ?};
            ~~
         ");
         __SUR.tree()
      || __SUR.select(~~)
      ?}
   ?};
   obj_del(__SUR);
   exec('env_delete','tech_structure')
|| FUN.emsg('Nieprawidłowe parametry wywołania funkcji sur_all/tex_tmat.'@)
?};
~~


\sur_zlec_cmplx
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wyświetla powiązania surowców dla zlecenia złożonego (struktura produktu)
::       Dla zlecenia prostego działanie takie, jak w technologii zlecenia
::  OLD: \sur_zlec_cmplx/zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
:: Dla zlecenia bez własnej technologii struktura bezpośrednio do karty
{? VAR.A_ZLEC().TYP().TECH='N'
|| VAR.A_KTL:=exec('FindAndGet','#table',TKTL,VAR.A_ZLEC().RKTL,,"ref()",null());
   _mask:=(8+ref_name(VAR.A_KTL))+3;
   exec('tktl_use','tech_common',_mask);
   {? VAR.A_KTL<>null()
   || exec('sur_all','tech_mater')
   || FUN.emsg('Nie można wyświetlić struktury produktu — brak technologii zlecenia.'@)
   ?}

:: Bierzemy technologię z nadrzędnego, ale jak się da to znajdujemy zlecenie montażowe (pierwsze podrzędne)
|? VAR.A_ZLEC().RODZAJ='Z'
|| VAR.A_KTL:=exec('FindAndGet','#table',TKTL,VAR.A_ZLEC().RKTL,,"ref()",null());
   ZL.cntx_psh();
   ZL.index('NRNZL');
   ZL.prefix(ZL.UNRZL);
   {? ZL.first()
   || VAR.A_KTL:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,"ref()",null())
   ?};
   _mask:=(8+ref_name(VAR.A_KTL))+3;
   exec('tktl_use','tech_common',_mask);
   {? VAR.A_KTL<>null()
   || exec('sur_all','tech_mater')
   || FUN.emsg('Nie można wyświetlić struktury produktu — brak technologii głównego zlecenia.'@)
   ?};
   VAR.A_KTL:=null();
   ZL.cntx_pop()

:: Formuła powinna być wołana z poziomu zlecenia nadrzędnego, w zmiennej VAR.A_KTL musi być wtedy null()
:: w przeciwnym wypadku działanie jak dla technologii zlecenia
|| VAR.A_KTL:=exec('FindAndGet','#table',TKTL,VAR.A_ZLEC().RTKTL,,"ref()",null());
   _mask:=(8+ref_name(VAR.A_KTL))+3;
   exec('tktl_use','tech_common',_mask);
   {? VAR.A_KTL<>null()
   || exec('sur_all','tech_mater')
   || FUN.emsg('Nie można wyświetlić struktury produktu — brak technologii zlecenia.'@)
   ?}

?};
~~


\prn_plpr
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Wykaz zapotrzebowania materiałów produkcyjnych
::  OLD: \prn_plpr/drukujp.fml
::----------------------------------------------------------------------------------------------------------------------
rep_exec('tte_drukplpr');
1


\torw_sym
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Ustala opisowo: Technologia(komplet)/wzorzec/zlecenie(analiza)
::   WE: _a - TKTL.TORW
::       _b - TKTL.TYP().TYP
::----------------------------------------------------------------------------------------------------------------------
_torw:=_a;
_typ:=_b;
{? _torw='T' & _typ=exec('k_res_string','tech_head')
|| 'Komplet'@
|? _torw='T'
|| 'Technologia'@
|? _torw='W'
|| 'Wzorzec'@
|| 'Zlecenie'@
?}


\status
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.02]
:: OPIS: Ustala opisowo: Stan zlecenia / Stan karty
::   WE: _a - ZL.STAN
::       _b - TKTL.STAN
::       _c - TKTL.TORW
::----------------------------------------------------------------------------------------------------------------------
_zl_stan:=_a;
_ktl_stan:=_b;
_torw:=_c;
{? _zl_stan=''
|| {? _ktl_stan='T'
   || {? _torw='T' || 'zatwierdzona'@ || 'zatwierdzony'@ ?}
   || 'w przygotowaniu'@
   ?}
|| {? _zl_stan='N'
   || 'w przygotowaniu'@
   |? _zl_stan='O'
   || 'otwarte'@
   |? _zl_stan='Z'
   || 'zamknięte'@
   || ''
   ?}
?}


\display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [19.42]
:: OPIS: Tworzy tymczasowe okienko redagowania dla wykorzystywanych w technologiach indeksów materiałowych.
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
_id:='';
{? _tab.SU<>'N-P-U' || _id:='whohasme_tk_eds' || _id:='whohasme_tk_edn' ?};
_red1:=_tab.mk_edit('Szczegóły karty'@,0,_id);
_tab.win_esep(_red1,'Dane podstawowe'@);
_tab.win_efld(_red1,,'NRK',,,50,,1,'Karta technologiczna'@);
_tab.win_efld(_red1,,'WER',,,50,,1,'Wersja'@);
_tab.win_efld(_red1,,'OPIS',,,50,,1,'Opis'@);
_tab.win_efld(_red1,,'PKTM',,,50,,1,'Indeks produktu'@);
_tab.win_efld(_red1,,'PNAZ',,,50,,1,'Nazwa produktu'@);
_tab.win_efld(_red1,,'PJM',,,10,,1,'jm'@);
_tab.win_efld(_red1,,'KTL_STAN',,,2,,1,'Zatwierdzona?'@,,,'check-box','check_label='+'Karta jest zatwierdzona'@,"'T'","'N'");
_tab.win_efld(_red1,,'KTL_ARCH',,,2,,1,'Archiwalna?'@,,,'check-box','check_label='+'Karta jest archiwalna'@,"'T'","'N'");
_tab.win_esep(_red1,'Zlecenie'@);
_tab.win_efld(_red1,,'ZL_SYM',,,50,,1,'Zlecenie'@);
_tab.win_efld(_red1,,'ZL_STAN',,,2,,1,'Stan zlecenia'@,,,'radio-buttons',,'W przygotowaniu'@,"'N'",'Otwarte'@,"'O'",'Zamknięte'@,"'Z'");
_tab.win_ecol(_red1);
_tab.win_esep(_red1,'Proces technologiczny'@);
_tab.win_efld(_red1,,'PFAZ',,,20,,1,'Faza produkcji'@);
_tab.win_efld(_red1,VAR,'STRING',,,20,,1,'Numer operacji'@);
{? _tab.SU<>'N-P-U'
|| _tab.win_esep(_red1,'Parametry'@);
   _tab.win_efld(_red1,,'SU',,,2,,1,'Zamiennik?'@,,,'check-box','check_label='+'Element jest zamiennikiem'@,"'Zamiennik'","''");
   _tab.win_efld(_red1,,'ACT',,,2,,1,'Aktywny?'@,,,'check-box','check_label='+'Element jest aktywny'@,"'T'","'N'");
   _tab.win_efld(_red1,,'GR',,,3,,1,'Element grupy?'@,,,'check-box','check_label='+'Jest elementem grupy technologicznej'@,"'T'","'N'");
   _tab.win_efld(_red1,TMAT,'LIMIT',,,2,,1,'Limitowany?'@,,,'check-box','check_label='+'Jest surowcem limitowanym'@,"'T'","'N'");
   _tab.win_esep(_red1,'Normy materiałowe'@);
   _tab.win_efld(_red1,,'WARB',,,15,4,1,'Norma materiałowa brutto'@);
   _tab.win_efld(_red1,,'WARN',,,15,4,1,'Norma materiałowa netto'@);
   _tab.win_esep(_red1,'Technologia półfabrykatu'@);
   _tab.win_efld(_red1,,'DFLT_KTL',,,2,,1,'Domyślna?'@,,,'check-box','check_label='+'Używaj domyślnej karty technologicznej'@,"'T'","'N'");
   _tab.win_efld(_red1,,'P_NRK',,,50,,1,'Karta technologiczna'@);
   _tab.win_efld(_red1,,'P_WER',,,50,,1,'Wersja'@)
|| _tab.win_esep(_red1,'Dane N-P-U'@);
   _tab.win_efld(_red1,,'ACT',,,2,,1,'Aktywny?'@,,,'check-box','check_label='+'Element jest aktywny'@,"'T'","'N'");
   _tab.win_efld(_red1,,'WARB',,,15,4,1,'Ilość sztuk'@);
   _tab.win_esep(_red1,'Zużycie N-P-U'@);
   _tab.win_efld(_red1,,'ZXJM',,,15,4,1,'Zużycie na serię produktu'@);
   _tab.win_efld(_red1,,'ZH',,,15,4,1,'Zużycie na godzinę'@)
?};
_tab.win_edit(_red1);
_tab.display();
_tab.win_edit('');
_tab.win_edel(_red1);
~~


\be_xjmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Przed redakcją pola TMAT.XJMP
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
_afld:=cur_afld();
{? _tab=TMAT | _tab=TCHMAT
|| {? _afld='XJMP'
   || VAR.REAL3:=_tab.WARN;
      VAR.REAL4:=_tab.WARB;
      VAR.REAL5:=_tab.XJMP
   |? _afld='DXJMP'
   || VAR.REAL3:=_tab.DWARN;
      VAR.REAL4:=_tab.DWARB;
      VAR.REAL5:=_tab.DXJMP
   ?}
?};
~~


\ae_xjmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Po redakcji pola TMAT.XJMP
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
{? _tab=TMAT | _tab=TCHMAT
||
   _fld:=fld();
   {? _fld<0
   || FUN.info('Wartość procentowa musi się być większa od zera'@);
      return(0)
   |? _fld>0
   || {? VAR.REAL5<>_tab.XJMP
      || _tab.WARN:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.XJM",0)*(_fld/100);
         {? _tab.WARB=0 || _tab.WARB:=_tab.WARN/{? _tab.UNB || _tab.UNB || 1 ?} ?};
::       Walidacje/zaokrąglania
         roundmet(2);
         _dokl:={? _tab.GRKTM='K'
                || exec('jaka_dok_m','jm',_tab.PT)
                || exec('jaka_dok_m','jm',_tab.TGDFLT().PT)
                ?};
::       Norma netto
         _cal:=int(_tab.WARN);
         {? _tab.WARN<0
         || FUN.info('Norma nie może być ujemna.'@);
            _tab.WARN:=0;
            return(0)
         || {? _dokl=0 & _cal<>_tab.WARN
            || FUN.info('Jednostka miary nie jest podzielna. Należy wprowadzić skład procentowy, '
                        'po przeliczeniu którego wartość normy netto będzie liczbą całkowitą.'@);
               _tab.WARN:=0;
               return(0)
            || _tab.WARN:=_tab.WARN $ _dokl
            ?}
         ?};
::       Norma brutto
         _cal:=int(_tab.WARB);
         {? _tab.WARB<0
         || FUN.info('Norma nie może być ujemna.'@);
            _tab.WARB:=0;
            return(0)
         || {? _dokl=0 & _cal<>_tab.WARB
            || FUN.info('Jednostka miary nie jest podzielna.  Należy wprowadzić skład procentowy, po przeliczeniu którego wartość normy brutto będzie liczbą całkowitą.'@);
               _tab.WARB:=0;
               return(0)
            || _tab.WARB:=_tab.WARB $ _dokl
            ?}
         ?};

         {? _tab.WARN<>VAR.REAL3 | (_tab.WARB<>VAR.REAL4)
         || exec('normy_aktu','tech_mater',1,1,_tab,{? _tab.DJM<>null() || 0 || 2 ?})
         ?}
      ?}
   ?};
   exec('efld_opt','tech_mater',_tab)
?};
~~


\bd_xjmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Przed wyświetleniem pola TMAT.XJMP
::----------------------------------------------------------------------------------------------------------------------
{? cur_tab(1,1)=TMAT
|| exec('efld_opt','tech_mater',TMAT)
|? cur_tab(1,1)=TCHMAT
|| exec('efld_opt','tech_mater',TCHMAT)
?};
~~


\sum_xjmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Wylicza sumę TMAT.XJMP dla danej karty technologicznej
::   WE: _a - TKTL.ref()
::   WY: suma TMAT.XJMP(REAL)
::----------------------------------------------------------------------------------------------------------------------
_res:=0.0;
TMAT.cntx_psh();
TMAT.index('ANL');
TMAT.prefix('T',_a);
{? TMAT.first()
|| {!
   |?
      _res+=TMAT.XJMP;
      TMAT.next()
   !}
?};
TMAT.cntx_pop();
_res


\fd_xjmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Format wyświetlania pola TMAT.XJMP
::----------------------------------------------------------------------------------------------------------------------
'out_prec=4'


\ae_dxjmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Po redakcji pola TMAT.DXJMP
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
{? _tab=TMAT | _tab=TCHMAT
||
   _fld:=fld();
   {? _fld<0
   || FUN.info('Wartość procentowa musi się być większa od zera'@);
      return(0)
   |? _fld>0
   || {? VAR.REAL5<>_tab.DXJMP
      || _tab.DWARN:=(exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.XJM",0)*(_fld/100));
         {? _tab.DWARB=0 || (_tab.DWARB:=_tab.DWARN/{? _tab.UNB || _tab.UNB || 1 ?}) ?};
::       Walidacje/zaokrąglania
         roundmet(2);
         _dokl:={? _tab.GRKTM='K'
                || exec('jaka_dok_m','jm',_tab.PT)
                || exec('jaka_dok_m','jm',_tab.TGDFLT().PT)
                ?};
::       Norma netto
         _cal:=int(_tab.DWARN);
         {? _tab.DWARN<0
         || FUN.info('Norma nie może być ujemna.'@);
            _tab.DWARN:=0;
            return(0)
         || {? _dokl=0 & _cal<>_tab.DWARN
            || FUN.info('Jednostka miary nie jest podzielna. Należy wprowadzić skład procentowy, po przeliczeniu którego wartość normy netto będzie liczbą całkowitą.'@);
               _tab.DWARN:=0;
               return(0)
            || _tab.DWARN:=_tab.DWARN $ _dokl
            ?}
         ?};
::       Norma brutto
         _cal:=int(_tab.DWARB);
         {? _tab.DWARB<0
         || FUN.info('Norma nie może być ujemna.'@);
            _tab.DWARB:=0;
            return(0)
         || {? _dokl=0 & _cal<>_tab.DWARB
            || FUN.info('Jednostka miary nie jest podzielna.  Należy wprowadzić skład procentowy, po przeliczeniu którego wartość normy brutto będzie liczbą całkowitą.'@);
               _tab.DWARB:=0;
               return(0)
            || _tab.DWARB:=_tab.DWARB $ _dokl
            ?}
         ?};

         {? _tab.DJM<>null() & (_tab.DWARN<>VAR.REAL3 | _tab.DWARB<>VAR.REAL4)
         || exec('normy_aktu','tech_mater',0,1,_tab,0)
         ?};
         _tab.XJMP:=_tab.DXJMP

      ?}
   ?};
   exec('efld_opt','tech_mater',_tab)
?};
~~


\normy_aktu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Aktualizuje normy netto/brutto po zmiane ilości w jednostce podstawowej/dodatkowej.
::   WE: _a - kierunek aktualizacji : [1] - jedn. podst -> jedn. dod, 0 - jedn.dod -> jedn. podst.
::       _b - zadać pytanie?: [1] - tak, 0 - nie
::       _c - tabela ([TMAT]/TCHMAT)
::       _d - aktualizowane pola: [0] - wszystkie , 1 - tylko netto, 2 - tylko brutto
::       _e - aktualizować normę brutto na jednostce bazowej: [1] - tak, 0 - nie
::----------------------------------------------------------------------------------------------------------------------
_kierunek:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_ask:={? var_pres('_b')=type_of(0) || _b || 1 ?};
_continue:=1;
_tab:={? var_pres('_c')=type_of(SYSLOG) || _c || TMAT ?};
_what:={? var_pres('_d')=type_of(0) || _d || 0 ?};
_czy_b:={? var_press('_e')=type_of(0) || _e || 1 ?};
_txt:={? _kierunek>0
      || {? _what<>2
         || 'Zmodyfikowano ilości w jednostce podstawowej. Przeliczyć ilości dla jednostki dodatkowej '
            'oraz normę brutto dla jednostki podstawowej?'@
         || 'Zmodyfikowano ilości w jednostce podstawowej. Przeliczyć ilości dla jednostki dodatkowej?'@
         ?}

      || {? _what<>2
         || 'Zmodyfikowano ilości w jednostce dodatkowej. Przeliczyć ilości dla jednostki podstawowej '
            'oraz normę brutto dla jednostki dodatkowej?'@
         || 'Zmodyfikowano ilości w jednostce dodatkowej. Przeliczyć ilości dla jednostki podstawowej?'@
         ?}
      ?};

{? _continue
|| {? _tab.DJM<>null() & _tab.PRZ<>0
   ||
      {? _kierunek>0
      ||
::       jedn. podst -> jedn. dod
::       Przeliczenie brutto na jednostce podstawowej (po zmianie netto)
         {? _what<>2 & _czy_b>0
         || {? _tab.FORMB<>''
            || _warb:=tpar.calc(_tab.FORMB)
            || _warb:=_tab.WARN/{? _tab.UNB || _tab.UNB || 1 ?}
            ?};
            _warb:=_warb $ exec('round_abe','tech_mater',_tab,1)
         || _warb:=_tab.WARB
         ?};
::       Wyliczenie nowych ilości
         _dwarn:={? _tab.DFORMN<>''
                 || tpar.calc(_tab.DFORMN)
                 || (_tab.WARN/_tab.PRZ)
                 ?};
         _dwarn:=_dwarn $ exec('round_abe','tech_mater',_tab,0);
         _dwarb:={? _tab.DFORMB<>''
                 || tpar.calc(_tab.DFORMB)
                 ||(_warb/_tab.PRZ)
                 ?};
::         _dwarb:={? _tab.UNB<>0 || _tab.DWARN/_tab.UNB || 0 ?};
         _dwarb:=_dwarb $ exec('round_abe','tech_mater',_tab,0);
::       Jak stare ilości były zerami to nadpisuje bez pytania
         {? (_what=1 &_tab.DWARN=0) | (_what=2 & _tab.DWARB=0) | (_what=0 & _tab.DWARB=0 & _tab.DWARN=0)
         || _ask:=0
         ?};
::       Jak nowe ilości różnią się od starych to pytam czy nadpisać
         {? ((_what<>2 & _dwarn<>_tab.DWARN) | (_what<>1 & _dwarb<>_tab.DWARB))
         || {? ~_ask | FUN.ask(_txt)
            || _tab.WARB:=_warb;
               {? _what<>2
               || _tab.DWARN:=_dwarn;
                  {? _tab.PT<>null & _tab.DJM<>null()
                     & _tab.DJM().KOD=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.JM().KOD",'')
                     & exec('czy_xjmp','tech_mater',_tab.DJM().KOD)
                  || _tab.DXJMP:=(((_tab.DWARN)/_tab.NRK().XJM)*100)
                  |? _tab.PT<>null & _tab.PT().J().KOD=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.JM().KOD",'')
                     & exec('czy_xjmp','tech_mater',_tab.PT().J().KOD)
                  || _tab.DXJMP:=(((_tab.DWARN*_tab.PRZ)/_tab.NRK().XJM)*100)
                  ?}
               ?};
               {? _what<>1
               || _tab.DWARB:=_dwarb
               ?}
            ?}
         ?}
      ||
::       jedn.dod -> jedn. podst.
::       Przeliczenie brutto na jednostce dodatkowej (po zmianie netto)
         {? _what<>2 & _czy_b>0
         || {? _tab.DFORMB<>''
            || _dwarb:=tpar.calc(_tab.DFORMB)
            || _dwarb:=_tab.DWARN/{? _tab.UNB || _tab.UNB || 1 ?}
            ?};
            _dwarb:=_dwarb $ exec('round_abe','tech_mater',_tab,0)
         || _dwarb:=_tab.DWARB
         ?};
::       Wyliczenie nowych ilości
         _warn:={? _tab.FORMN<>''
                || tpar.calc(_tab.FORMN)
                || (_tab.DWARN*_tab.PRZ)
                ?};
         _warn:=_warn $ exec('round_abe','tech_mater',_tab,1);
         _warb:={? _tab.FORMB<>''
                || tpar.calc(_tab.FORMB)
                || (_dwarb*_tab.PRZ)
                ?};
::         _warb:={? _tab.UNB<>0 || _tab.WARN/_tab.UNB || 0 ?};
         _warb:=_warb $ exec('round_abe','tech_mater',_tab,1);
::       Jak stare ilości był zerami to nadpisuje bez pytania
         {? (_what=1 &_tab.WARN=0) | (_what=2 & _tab.WARB=0) | (_what=0 & _tab.WARB=0 & _tab.WARN=0)
         || _ask:=0
         ?};
::       Jak nowe ilości różnią się od starych to pytam czy nadpisać
         {? (_what<>2 & _warn<>_tab.WARN) | (_what<>1 & _warb<>_tab.WARB)
         || {? ~_ask | FUN.ask(_txt)
            || _tab.DWARB:=_dwarb;
               {? _what<>2
               || _tab.WARN:=_warn;
                  {? _tab.PT<>null & _tab.DJM<>null()
                     & _tab.DJM().KOD=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.JM().KOD",'')
                     & exec('czy_xjmp','tech_mater',_tab.DJM().KOD)
                  || _tab.XJMP:=((_tab.WARN/_tab.PRZ/_tab.NRK().XJM)*100)
                  |? _tab.PT<>null & _tab.PT().J().KOD=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.JM().KOD",'')
                     & exec('czy_xjmp','tech_mater',_tab.PT().J().KOD)
                  || _tab.XJMP:=((_tab.WARN/_tab.NRK().XJM)*100)
                  ?}
               ?};
               {? _what<>1
               || _tab.WARB:=_warb
               ?}
            ?}
         ?}
      ?}
   |? _tab.DJM=null() & _kierunek>0 & _what=2
   ||
::    Przeliczenie brutto na jednostce podstawowej
      _txt:='Zmodyfikowano normę netto. Czy przeliczyć na jej podstawie normę brutto?';
      {?  VAR.REAL4=0 | ~_ask | FUN.ask(_txt)
      || _tab.WARB:=_tab.WARN/{? _tab.UNB || _tab.UNB || 1 ?};
         _tab.WARB:=_tab.WARB $ exec('round_abe','tech_mater',_tab,1)
      ?}
   || ~~
   ?}
?};
:: Przepisanie %ilości z jednostki dodatkowej na jednostkę podstawową
{? _tab.PT<>null & _tab.DJM<>null() &  _tab.DJM().KOD=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.JM().KOD",'')
   & exec('czy_xjmp','tech_mater',_tab.DJM().KOD)
|| _tab.XJMP:=_tab.DXJMP
::|? _tab.PT<>null & _tab.PT().J().KOD=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.JM().KOD",'')
::|| _tab.DXJMP:=_tab.XJMP
?};
:: Poprawienie zapisów wynikających z formuł
::{? _tab.FORMB<>'' || _tab.WARB:=tpar.calc(_tab.FORMB);  _tab.WARB:=_tab.WARB $ exec('round_abe','tech_mater',_tab,1) ?};
::{? _tab.FORMN<>'' || _tab.WARN:=tpar.calc(_tab.FORMN); _tab.WARN:=_tab.WARN $ exec('round_abe','tech_mater',_tab,1) ?};
::{? _tab.DFORMB<>'' || _tab.DWARB:=tpar.calc(_tab.DFORMB); _tab.DWARB:=_tab.DWARB $ exec('round_abe','tech_mater',_tab,0) ?};
::{? _tab.DFORMN<>'' || _tab.DWARN:=tpar.calc(_tab.DFORMN); _tab.DWARN:=_tab.DWARN $ exec('round_abe','tech_mater',_tab,0) ?};
~~


\unb_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.42]
:: OPIS: Przed redakcją pola TMAT.UNB, TCHMAT.UNB
::   WE: _a - TMAT, TCHMAT
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
params_exec('TxMAT_UZYSK','tech_mater',_tab);
_buffer:={? _tab=TCHMAT || params_get().env_mater.buffer_tchmat || params_get().env_mater.buffer_tmat ?};
_buffer.UNB:=_tab.UNB;
1


\unb_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [20.42]
:: OPIS: Po redakcji pola TMAT.UNB, TCHMAT.UNB
::   WE: _a - TMAT, TCHMAT
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_res:=exec('in_interval','#field',0,1);
{? _res
|| _buffer:={? _tab=TCHMAT || params_get().env_mater.buffer_tchmat || params_get().env_mater.buffer_tmat ?};
   {? _buffer.UNB<>_tab.UNB
   || {? FUN.ask('Zmieniono wartość uzysku, czy przeliczyć ponownie normę brutto?'@)
      || {? _tab.FORMB<>''
         || _tab.WARB:=tpar.calc(_tab.FORMB);
            _tab.WARB:=_tab.WARB $ exec('round_abe','tech_mater',_tab,1)
         || _tab.WARB:=_tab.WARN/{? _tab.UNB || _tab.UNB || 1 ?}
         ?}
      ?}
   ?}
?};
_res


\sur_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Aktualizacja ilości na surowcach/zamiennikach po zmianie ilości na nagłówku karty
::   WE: _a - TKTL.ref()
::----------------------------------------------------------------------------------------------------------------------
exec('tktl_cntx_psh','tech_common');
exec('tktl_use','tech_common',ref_name(_a)+3);

{? TKTL.seek(_a)
|| exec('start_tpar','tech_param',TKTL.KTM,TKTL.ref());
   {! _i:=1..2
   |!
      {? var_pres('_tab')>100 || obj_del(_tab) ?};
      {? _i=1
      ||
::       Surowce
         _tab:=TMAT;
         _tab.index('NL');
         _tab.prefix(TKTL.ref())
      ||
::       Zamienniki
         _tab:=TCHMAT;
         _tab.index('NSL');
         _tab.prefix(TKTL.ref())
      ?};
      {? _tab.first()
      || {!
         |?
            exec('sur_update_single','tech_mater',_tab);
::         {? _tab.PT<>null & _tab.PT().J().KOD=TKTL.JM().KOD
::         || _tab.XJMP:=((_tab.WARN/TKTL.XJM)*100);
::            _tab.put()
::         ?};

::         {? _tab.PT<>null & _tab.DJM<>null() &  _tab.DJM().KOD=TKTL.JM().KOD
::         || _tab.DXJMP:=(((_tab.DWARN)/TKTL.XJM)*100);
::            _tab.XJMP:=_tab.DXJMP;
::            _tab.put()
::         ?};
            _tab.next()
         !}
      ?}
   !}
?};
exec('tktl_cntx_pop','tech_common');
~~


\sur_update_single
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Aktualizacja ilości konkretnego surowcu/zamiennika. Działa na aktualnym rekordzie tabeli TMAT/TCHMAT oraz TKTL
::   WE: _a - której tabeli dotyczy - TMAT/TCHMAT
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_put:=0;
:: Przeliczenia z jednostki podstawowej
{? _tab.PT<>null & _tab.PT().J().KOD=TKTL.JM().KOD & exec('czy_xjmp','tech_mater',_tab.PT().J().KOD)
|| _put:=1;
   _unb:={? _tab.WARB || _tab.WARN/_tab.WARB || 0 ?};
   {? _tab.FORMN<>''
   || _tab.WARN:=tpar.calc(_tab.FORMN) $ exec('round_abe','tech_mater',_tab,1);
      _tab.XJMP:=((_tab.WARN/TKTL.XJM)*100)
   || _tab.WARN:=TKTL.XJM*(_tab.XJMP/100) $ exec('round_abe','tech_mater',_tab,1)
   ?};
   {? _tab.FORMB<>''
   || _tab.WARB:=tpar.calc(_tab.FORMB) $ exec('round_abe','tech_mater',_tab,1)
   || _tab.WARB:=(_tab.WARN/{? _unb || _unb || 1 ?}) $ exec('round_abe','tech_mater',_tab,1)
::   || _tab.WARB:={? _unb || (_tab.WARN/_unb) || 0 ?} $ exec('round_abe','tech_mater',_tab,1)
   ?};
   exec('normy_aktu','tech_mater',1,0,_tab,0,0)
?};
:: Przeliczenia z jednostki dodatkowej
{? _tab.PT<>null & _tab.DJM<>null() &  _tab.DJM().KOD=TKTL.JM().KOD & exec('czy_xjmp','tech_mater',_tab.DJM().KOD)
|| _put:=1;
   _dunb:={? _tab.DWARB || _tab.DWARN/_tab.DWARB || 0 ?};
   {? _tab.DFORMN<>''
   || _tab.DWARN:=tpar.calc(_tab.DFORMN) $ exec('round_abe','tech_mater',_tab,0);
      _tab.DXJMP:=((_tab.DWARN/TKTL.XJM)*100)
   || _tab.DWARN:=TKTL.XJM*(_tab.DXJMP/100) $ exec('round_abe','tech_mater',_tab,0)
   ?};
   {? _tab.DFORMB<>''
   || _tab.DWARB:=tpar.calc(_tab.DFORMB)$exec('round_abe','tech_mater',_tab,0)
   || _tab.DWARB:=(_tab.DWARN/{? _dunb || _dunb || 1 ?}) $ exec('round_abe','tech_mater',_tab,0)
   ?};
   exec('normy_aktu','tech_mater',0,0,_tab,0,0)
?};
{? _put>0
|| _tab.put()
?};
~~


\xjmp_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Sprawdza zgodność jednostki miary surowców/zamienników z nagłówkiem technolgoii i aktualizuje
::       pola z zawartością procentową.
::   WE: _a - TKTL.ref()
::       [_b] - praca w trybie przeliczania surowców (po zmianie ilość na nagłówku) [0] - nie , 1 - tak
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
_sur_update:={? var_pres('_b')=type_of(0) || _b || 0 ?};
:: surowce
TMAT.cntx_psh();
TMAT.index('NL');
TMAT.prefix(_tktl);
{? TMAT.first()
|| {!
   |?
      exec('xjmp_update_single','tech_mater',TMAT,_sur_update);
      TMAT.next()
   !}
?};
TMAT.cntx_pop();
:: zamienniki
TCHMAT.cntx_psh();
TCHMAT.index('NSL');
TCHMAT.prefix(_tktl);
{? TCHMAT.first()
|| {!
   |?
      exec('xjmp_update_single','tech_mater',TCHMAT,_sur_update);
      TCHMAT.next()
   !}
?};
TCHMAT.cntx_pop();
~~


\xjmp_update_single
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Sprawdza zgodność jednostki miary surowca/zamiennika z nagłówkiem technolgoii i aktualizuje
::       pola z zawartością procentową. Działa na aktualnym rekordzie tabeli TMAT/TCHMAT.
::   WE: _a - której tabeli dotyczy - TMAT/TCHMAT
::       [_b] - praca w trybie przeliczania surowców (po zmianie ilość na nagłówku) [0] - nie , 1 - tak
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_sur_update:={? var_pres('_b')=type_of(0) || _b || 0 ?};

_jm:=_tab.PT().J().KOD;
_djm:=_tab.DJM().KOD;
_tktl_jm:=exec('FindAndGet','#table',TKTL,_tab.NRK,,"TKTL.JM().KOD",'');
{? _tktl_jm=_jm & exec('czy_xjmp','tech_mater',_jm)
|| {? ~_sur_update | (_sur_update>0 & _tab.XJMP=0)
   || _tab.DXJMP:=0;
      _tab.XJMP:=((_tab.WARN/_tab.NRK().XJM)*100)
   ?}
|? _tktl_jm=_djm & exec('czy_xjmp','tech_mater',_djm)
|| {? ~_sur_update | ( _sur_update>0 & _tab.DXJMP=0)
   || {? _tab.XJMP<>0 & _sur_update>0
      || _tab.DXJMP:=_tab.XJMP
      || _tab.DXJMP:=((_tab.DWARN/_tab.NRK().XJM)*100);
         _tab.XJMP:=_tab.DXJMP
      ?}
   ?}
|| _tab.XJMP:=0;
   _tab.DXJMP:=0
?};
_tab.put();
~~


\improve_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Aktualizuje surowce i zamienniki - o ile mają ten sam KTM co produkt, to gasimy karty półfabrykatowe
::   WE: _a - TKTL.ref()
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
TMAT.cntx_psh(); TCHMAT.cntx_psh(); TKTLW.cntx_psh();
TKTLW.prefix();

TMAT.index('NL');
TMAT.prefix(_tktl);
{? TMAT.first()
|| {!
   |? TKTLW.f_set(,,'TKTLW.KTM=:_b and TKTLW.TKTL=:_a',
         TMAT.NRK,{? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?}
      );
      {? TKTLW.f_first() || TMAT.DFLT_KTL:='N'; TMAT.KTL:=null(); TMAT.put() ?};
      TKTLW.f_clear();
      TMAT.next()
   !}
?};

TCHMAT.index('NSL');
TCHMAT.prefix(_tktl);
{? TCHMAT.first()
|| {!
   |? TKTLW.f_set(,,'TKTLW.KTM=:_b and TKTLW.TKTL=:_a',
         TCHMAT.NRK,{? TCHMAT.GRKTM='G' || TCHMAT.TGDFLT().PT || TCHMAT.PT ?}
      );
      {? TKTLW.f_first() || TCHMAT.DFLT_KTL:='N'; TCHMAT.KTL:=null(); TCHMAT.put() ?};
      TKTLW.f_clear();
      TCHMAT.next()
   !}
?};

TMAT.cntx_pop(); TCHMAT.cntx_pop(); TKTLW.cntx_pop();
~~


\tmat_move
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Akcja Przesuń
::   WE: _a - STRING - kierunek przesuwania: 'U','D','N'
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_dir:='N';
{? var_pres('_a')=type_of('')
|| _dir:=_a
?};
exec('zmien_lpa','#dragdrop','LP','NNL',,,_dir);
~~


\tchmat_move
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Akcja Przesuń
::   WE: _a - STRING - kierunek przesuwania: 'U','D','N'
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_dir:='N';
{? var_pres('_a')=type_of('')
|| _dir:=_a
?};
exec('zmien_lpa','#dragdrop','LP','NSL',,,_dir);
~~


\set_filter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Ustawia filtr programowy dla okna tabeli TMAT (wszystkie surowce aktywnych technologii)
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_exit:="
   exec('err_psql','#sql');
   exec('empty_f_set','#table',TMAT)
";
:: Zdjęcie filtru użytkownika
TKTL.f_clear(2);
TKTLW.f_clear(2);
:: Ustawienie filtru na technologie
{? ZAKR.TKTL_A='W'
||
:: Aktywne i nieaktywne
   exec('set_afilter','tech_head')
|? ZAKR.TKTL_A='N'
||
:: Nieaktywne
   exec('set_nfilter','tech_head')
||
:: Aktywne (bieżące)
   exec('set_filter','tech_head')
?};

TMAT.clear();
TMAT.index('TKTL');
TMAT.f_clear(1);
_sort:='';
_from:='';
_where:='TMAT.NRK in (select T1.REFERENCE as REF from TKTL T1 join filter_of(TKTL) T2)';

{? ~TMAT.f_set(_sort,_from,_where)
|| _exit()
?};
~~


\tmat_all_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Operacje inicjujące dla okna ALL tabeli TMAT (wszystkie surowce technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_formikon:="
   TCHMAT.cntx_psh();
   TCHMAT.index('NSL');
   TCHMAT.prefix(VAR.A_KTL,TMAT.ref());
   {? TCHMAT.first()
   || _ico:='xwin16.png:92'
   || _ico:='xwin16.png:110'
   ?};
   TCHMAT.cntx_pop();
   _ico
";
TMAT.win_fml('ALL',TMAT,'KTM','KTM','ICON_BEFORE',_formikon,1)


\tmat_all_rec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Rekord przed dla okna ALL tabeli TMAT (wszystkie surowce technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_tab:=TMAT;
_result:='';
:: Ustawienie, podczytanie zmiennych
VAR.A_KTL:=TMAT.NRK;
{? _tab.GRKTM='K'
|| VAR.A_T:=_tab.PT;
   VAR1.KTM:=_tab.PT().KTM
|| _tab.TGRP;
   VAR.A_T:=_tab.TGDFLT().PT;
   VAR1.KTM:=_tab.TGDFLT().PT().KTM
?};
VAR.A_T().KTM;
ATR.MJS:='TMAT';
:: Wyszarzenie akcji
{? _a
|| TMAT.NRK();
   exec('s_tktl','tech_head');
   _locked:=exec('tktl_lock','tech_common',,'S');
   _used:=~_locked;
   VAR.TOW_USL:='T';
   VAR.A_OP:=TMAT.NROP;
   _act:={? VAR.A_OP=null() || 1 || VAR.A_OP().ACT='T' ?};
   {? 1+cur_kwin()='s' & cur_tab(1,1)=_tab
   || _sel_size:=_tab.sel_size();
      _grayed:=':';
      _grayed:={? _tab.ACT='T' || 'Ó' || {? _sel_size || '' || 'P' ?} ?}+_grayed;
      {? _used | ~_act | TKTL.STAN='N' | TKTL.STAN='P' & TKTL.STAT_S='T'
      || _grayed:={? _sel_size || '' || 'P' ?}+_grayed
      ?};
      {? exec('is_k_res','tech_head',VAR.A_TPKTL) | exec('is_t_res','tech_head',VAR.A_TPKTL) || _grayed:='CR'+_grayed ?};
      {? TKTL.TYP().PAR<>'T' || _grayed:='R'+_grayed ?};
      {? TKTL.STAN='T' & (TKTL.TORW='W' | ~exec('can_modify','tech_common'))
      || _grayed:={? _sel_size || '' || 'P' ?}+_grayed
      ?};
      _tab.actions_grayed(cur_win(1,1),_grayed)
   ?};
   {? _locked || exec('tktl_unlock','tech_common',,'S') ?}
?};
:: Kolorowanie
{? _tab.ACT='N'
|| _result:=Color.fnd_kol('TMAT#01#02')
|? _tab.RKTL<>''
|| _result:=Color.fnd_kol('TMAT#01#01')
|? _tab.DFLT_KTL='T'
|| _result:=Color.fnd_kol('TMAT#01#03')
?};
_result


\tmat_all_zakr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Zmień Zakres w oknie ALL tabeli TMAT (wszystkie surowce technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_win_red:=exec('zakr_win','tech_common');
ZAKR.win_edit(_win_red);
{? ZAKR.TKTL_A='' || ZAKR.TKTL_A:='A' ?};
{? ZAKR.edit()
|| exec('zakr_set','tech_common');
   exec('set_filter','tech_mater')
?};
~~


\tmat_all_zam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Zamienniki w oknie ALL tabeli TMAT (wszystkie surowce technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_locked:=exec('tmat_all_start','tech_mater');
_env_mater:=exec('env_mater','tech_mater');
_env_mater.used:=~_locked;
params_set('env_mater',_env_mater);
exec('tmatwerz','tech_mater');
{? _locked || exec('tmat_all_stop','tech_mater') ?}


\tmat_all_dok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Dokumentacja w oknie ALL tabeli TMAT (wszystkie surowce technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_locked:=exec('tmat_all_start','tech_mater');
_env_mater:=exec('env_mater','tech_mater');
_env_mater.used:=~_locked;
params_set('env_mater',_env_mater);
exec('TMAT','tech_doc');
{? _locked || exec('tmat_all_stop','tech_mater') ?}


\tmat_all_mod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Popraw w oknie ALL tabeli TMAT (wszystkie surowce technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_locked:=exec('tmat_all_start','tech_mater');
_env_mater:=exec('env_mater','tech_mater');
_env_mater.used:=~_locked;
{? VAR.GRP_MOD='' ||  VAR.GRP_MOD:='N' ?};
{? VAR.GRP_MOD='T'
|| {? var_pres('__BUFF_GRP')>100
   || {? var_pres('buffer_tmat_grp',_env_mater)>0
      || obj_del( _env_mater.buffer_tmat_grp)
      ?};
       _env_mater.buffer_tmat_grp:=__BUFF_GRP
   ?}
?};
params_set('env_mater',_env_mater);
_ok:=exec('ptmatpop','tech_mater');
{? _ok>0
|| {? VAR.GRP_MOD='T' | TMAT.edit("params_exec('tchm_edt','tech_mater',TMAT,0)")
   || _ok:=1;
::    Grupowe poprawnianie surowców, przepisanie danych z bufora
      {? VAR.GRP_MOD='T'
      || _ok:=exec('tmat_modify_frombfr','tech_mater')
      ?};
      {? _ok>0
      || {? TMAT.put()
         || exec('tmattpop','tech_mater')
         ?}
      ?}
   ?}
?};
{? _locked || exec('tmat_all_stop','tech_mater') ?}


\tmat_all_par
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Parametry w oknie ALL tabeli TMAT (wszystkie surowce technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_locked:=exec('tmat_all_start','tech_mater');
_env_mater:=exec('env_mater','tech_mater');
_env_mater.used:=~_locked;
params_set('env_mater',_env_mater);
exec('show_tmattpar','tech_param');
{? _locked || exec('tmat_all_stop','tech_mater') ?}


\tmat_all_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Formuła inicjująca dla akcji zawartych w oknie ALL tabeli TMAT (wszystkie surowce technologiczne) -
::       Blokowanie rekordów, inicjajca obiektu tpar
::   WY: 0/1 - czy udało się zablokować rekord
::----------------------------------------------------------------------------------------------------------------------
_locked:=0;
{? TKTL.ref()<>null()
|| _locked:=exec('tktl_lock','tech_common',,'S');
   exec('start_tpar','tech_param',TKTL.KTM)
?};
_used:=~_locked;
_locked


\tmat_all_stop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Formuła czyszcząca dla akcji zawartych w oknie ALL tabeli TMAT (wszystkie surowce technologiczne) -
::       Oblokowanie rekordów, zwolnienie obiektu tpar
::----------------------------------------------------------------------------------------------------------------------
exec('tktl_unlock','tech_common',,'S');
exec('stop_tpar','tech_param')


\tmat_transfer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Przenieś dla surowców technologicznych - przenosi surowiec do innej operacji technologicznej
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_ok:=1;
_ktm_sym:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT().KTM || TMAT.PT().KTM ?};
{? TMAT.ACT='N'
|| {? VAR.GRUPA='T'
   || KOMM.add('Surowiec \'%1\' nieaktywny — modyfikacja niemożliwa.'@[_ktm_sym])
   || FUN.info('Surowiec nieaktywny — modyfikacja niemożliwa.'@)
   ?};
   _ok:=0
|? exec('is_zl4tmat','zl_link',TMAT.ref())
|| {? VAR.GRUPA='T'
   || KOMM.add('Surowiec \'%1\' powiązany ze zleceniem — modyfikacja niemożliwa.'@[_ktm_sym])
   || FUN.info('Surowiec powiązany ze zleceniem — modyfikacja niemożliwa.'@)
   ?};
   _ok:=0
?};
{? VAR.GRUPA<>'T'
|| _a_op:=VAR.A_OP
?};
{? _ok>0 & (VAR.GRUPA='T' | exec('tree','tech_oper',7,0))
|| _toper:=VAR.TOPER;
   {? _toper<>null() & TMAT.NROP<>_toper
   || params_get().env_mater.fields.KTLMAT:=TMAT.KTL;
      params_get().env_mater.fields.MAT:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};
      params_get().env_mater.fields.TOPER:=TMAT.NROP;
::    Określenie LP
      TMAT.cntx_psh();
      TMAT.clear();
      TMAT.index('NNL');
      TMAT.prefix(VAR.A_KTL,_toper);
      {? TMAT.last()
      || _lp:=TMAT.LP+1
      || _lp:=1
      ?};
      TMAT.cntx_pop();
::    Przepisanie surowca do nowej operacji
      TMAT.LP:=_lp;
      TMAT.NROP:=_toper;
      {? params_exec('sprktm','tech_mater',TMAT,M.ref(),{? VAR.GRUPA<>'T' || 1 || 0 ?})
      || TMAT.cntx_psh();
         TMAT.prefix();
         {? TMAT.put()
         ||
::          Przepisanie nowej operacji na zamiennikach
            TCHMAT.cntx_psh();
            TCHMAT.index('NSL');
            TCHMAT.prefix(VAR.A_KTL,TMAT.ref());
            {? TCHMAT.first()
            || {!
               |?
                  TCHMAT.NROP:=_toper;
                  TCHMAT.put();
                  TCHMAT.next()
               !}
            ?};
            TCHMAT.cntx_pop()
         ?};
         TMAT.cntx_pop()
      ?}
   ?}
?};
{? VAR.GRUPA<>'T'
|| VAR.A_OP:=_a_op
?};
~~


\tmat_transfer_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Przenieś dla surowców technologicznych - przed grupą rekordów
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_a_op:=VAR.A_OP;
{? exec('tree','tech_oper',7,0)
|| sel_nchk();
   VAR.GRUPA:='T';
   KOMM.init(255,,'Przenoszenie surowców technologicznych'@);
   _result:=1
?};
VAR.A_OP:=_a_op;
_result


\tmat_transfer_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Przenieś dla surowców technologicznych - po grupie rekordów
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\czy_xjmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Sprawdza, czy obsługiwana jest funkcjonalność określania %składu produktu
::   WE: _a - kod jednostki miary do sprawdzenia
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_jm:=_a;
_res:=0;
_param:=exec('get','#params',500406,2)='T';
{? _param>0
|| _res:=1;
   {? Plugin.runnable('TKTL_XJMP_001')
   || _res:=Plugin.run('TKTL_XJMP_001',_jm);
      {? type_of(_res)<>type_of(0)
      || _res:=0
      ?}
   ?}
?};
_res


\var1_toper_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Obsługa przed redagowaniem pola VAR1.TOPER (w oknach redagowania TMAT, TACTTLS)
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
_tab:=cur_tab(1,1);
:: Jeżeli technologia bez operacji to blokowane pole
{? VAR.A_KTL().TYP().OPER='N'
|| _res:=0
:: Jeżeli edycja surowca od strony operacji, to blokowane pole, rejestracja wyłącznie do danej operacji
|? VAR.A_OP<>null()
|| _res:=0
|| {? _tab=TMAT
   || _fields:=params_get().env_mater.fields;
      _fields.NROP:=VAR1.TOPER;
      VAR.TOPER:=TMAT.NROP
   |? _tab=TACTTLS
   || _fields:=params_get().env_tool.fields;
      _fields.NROP:=VAR1.TOPER;
      VAR.TOPER:=TACTTLS.NROP
   ?}
?};
_res


\var1_toper_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Obsługa F3 dla pola VAR1.TOPER (w oknach redagowania tabel TMAT)
::   WY: wartość pola
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
_nrop:=fld();

TOPER.cntx_psh();
{? _tab=TACTTLS
|| TOPER.index('PZWEW');
   TOPER.prefix('T','N','P','T',VAR.A_KTL)
|| TOPER.index('PZ');
   TOPER.prefix('T','N','P',VAR.A_KTL)
?};
TOPER.win_sel('SEL');
{? TOPER.select()
|| _toper:=VAR.TOPER:=TOPER.ref();
   {? _toper<>null() & _tab.NROP<>_toper
   || _unrop:=exec('FindAndGet','#table',TOPER,_toper,,"TOPER.UNROP",0);
      _nrop:=exec('get_oper_nr','tech_oper',_unrop,'\\','n')
   ?}
?};
TOPER.cntx_pop();
_nrop


\var1_toper_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Obsługa po redakcji pola VAR1.TOPER (w oknach redagowania tabel TMAT)
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
_tab:=cur_tab(1,1);

params_set(params_get());
{? _tab=TACTTLS
|| _fields:=params_get().env_tool.fields
|| _fields:=params_get().env_mater.fields
?};

_fld:=fld();
{? _fld=''
|| _tab.NROP:=null()
||
:: Sprawdzenie, czy zmieniła się wartość pola
   {? _fields.NROP<>_fld
   ||
::    Sprawdzenie, czy zmienił się ref operacji
      {? _tab.NROP<>VAR.TOPER
      || _tab.NROP:=VAR.TOPER;
::       Określenie LP
         {? _tab=TMAT
         || TMAT.cntx_psh();
            TMAT.clear();
            TMAT.index('NNL');
            TMAT.prefix(TMAT.NRK,TMAT.NROP);
            {? TMAT.last()
            || _lp:=TMAT.LP+1
            || _lp:=1
            ?};
            TMAT.cntx_pop();
            TMAT.LP:=_lp
         ?}
      ||
::       Zmieniła się wartość, nie zmienił się ref - ręczna zmiana nr operacji
         FUN.emsg('Operację należy wybrać korzystając ze słownika (klawisz F3).'@);
         fld(_fields.NROP);
         _res:=0
      ?}
   ?}
?};
_res


\tmatpop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Akcja Popraw w oknach wertowania dla surowców technologicznych
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
{? exec('ptmatpop','tech_mater')
|| {? VAR.GRP_MOD='T' | TMAT.edit("params_exec('tchm_edt','tech_mater',TMAT,0)")
   || _ok:=1;
::    Grupowe poprawnianie surowców, przepisanie danych z bufora
      {? VAR.GRP_MOD='T'
      || _ok:=exec('tmat_modify_frombfr','tech_mater')
      ?};
      {? _ok>0
      || {? TMAT.put()
         || exec('tmattpop','tech_mater')
         ?}
      ?}
   ?}
?};
{? MG.f_active()>0 ||  MG.f_clear() ?};
~~


\tmatpop_gpr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Grupa przed dla akcji Popraw w oknach wertowania dla surowców technologicznych
::   WE: [_a] - miejsce uruchomienia: 1 - okno wszystkich surowców (okno ALL), [0] - pozostałe przypadki
::----------------------------------------------------------------------------------------------------------------------
_where:={? var_pres('_a')=type_of(0) || _a || 0 ?};
params_set(params_get());
_continue:=1;
TMAT.cntx_psh();
{? TMAT.sel_size()>1
|| _continue:=FUN.ask('Ilość zaznaczonych surowców: %1. Czy poprawić wybrane surowce technologiczne?'@
      [form(TMAT.sel_size())]);
   {? _continue>0
   ||
      TMAT.seek(null(),,,1);
      TMAT.blank(1);
::    Sprawdzenie czy są zaznaczone zatwierdzone surowce
      _tab_sel:=TMAT.sel_aget();
      _kor:=0;
      {? _tab_sel.first()
      || TMAT.cntx_psh();
         TKTL.cntx_psh();
         TMAT.prefix();
         {!
         |?
            {? TMAT.seek(_tab_sel.REF)
            ||
::             Sprawdzenie, czy modyfikowana zatwierdzona operacja
               {? _kor=0 & TMAT.NRK().STAN='T'
               || _kor:=1
               ?}
            ?};
            _kor=0 & _tab_sel.next()
         !};
         TMAT.cntx_pop();
         TKTL.cntx_pop()
      ?};
      _kor_bf:=VAR.KOR;
      VAR.KOR:=_kor;
      TMAT.GRKTM:='K';
      VAR.A_T:=null();
      VAR1.KTM:='';
      VAR.GRP_MOD:='P';
      _buffer:=exec('buffer_tmat','tech_mater');
      _buffer.get();
      params_set('env_mater',params_get().env_mater,'buffer',_buffer);
      TMAT.win_edit('GRP_POP');
      _valid:="
         _res:=1;
         params_set(params_get());
         _buffer:=exec('buffer_tmat','tech_mater');
         _buffer.get();
         {? exec('compare','#table',_buffer,params_get().buffer,0,'TGRP','PFAZ','WYD','MG','SO'
            ,'PODST','LIMIT','ROZ','POW','MODE_DST','PT','TGDFLT')
         || FUN.info('Przynajmniej jedno z pól musi zostać określone.'@);
            _res:=0
         ?};
         {? _res>0
         || _res:='';
            {? TMAT.TGRP<>null() & TMAT.TGDFLT=null()
            || FUN.emsg('Proszę wypełnić pole \\'Indeks materiału\\'.'@);
               _res:='KTM'
            ?};
            {? _res='' & VAR.KOR
            || {? TMAT.CAUSE=null()
               || FUN.emsg('Podaj przyczynę zmiany.'@);
                  _res:='CAUSE'
               ?}
            ?}
         ?};
         _res
      ";
      exec('efld_opt','tech_mater',TMAT);
      _continue:=TMAT.edit(_valid);
      {? _continue>0
      || params_get().env_mater.buffer_tmat_grp.get();
         {? _where=1
         || {? var_pres('__BUFF_GRP')>100
            || VAR_DEL.delete('__BUFF_GRP')
            ?};
            __BUFF_GRP:=params_get().env_mater.buffer_tmat_grp
         ?};
         sel_nchk();
         KOMM.init(255,,'Grupowa modyfikacja surowców technologicznych'@);
         VAR.GRP_MOD:='T';
         VAR.GRUPA:='T'
      || VAR.GRP_MOD:='N';
         VAR.GRUPA:='N';
         {? _where>0
         || {? var_pres('__BUFF_GRP')>100
            || VAR_DEL.delete('__BUFF_GRP')
            ?}
         ?}
      ?};
      VAR.KOR:=_kor_bf
   ?}
?};
TMAT.cntx_pop();
_continue


\tmatpop_gpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Grupa po dla akcji Popraw w oknach wertowania dla surowców technologicznych
::----------------------------------------------------------------------------------------------------------------------
{? VAR.GRP_MOD='T'
|| VAR.GRUPA:='N';
   VAR.GRP_MOD:='N';
   {? var_pres('__BUFF_GRP')>100
   || VAR_DEL.delete('__BUFF_GRP')
   ?};
   KOMM.select()
?};
{? MG.f_active()>0 ||  MG.f_clear() ?};
~~


\tmat_all_mod_gpr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Grupa przed dla akcji Popraw w oknie ALL tabeli TMAT (wszystkie surowce technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_env_mater:=exec('env_mater','tech_mater');
params_set('env_mater',_env_mater);
exec('tmatpop_gpr','tech_mater',1)


\tmat_all_mod_gpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Grupa po dla akcji Popraw w oknie ALL tabeli TMAT (wszystkie surowce technologiczne)
::----------------------------------------------------------------------------------------------------------------------
params_exec('tmatpop_gpo','tech_mater')


\grp_mod_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Zwraca informacje o technologii, operacji, surowcu, którego będzie dotyczył komunikat błędu.
::       Działa na aktualnym buforze tabeli TMAT
::   WE: [_a] - INTEGER - dodać informację o surowcu: [1] - tak, 0 -nie
::   WY: STRING z informacją o technologii, operacji, surowcu
::----------------------------------------------------------------------------------------------------------------------
_grp_msg:='';
_sur:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_nrk:=exec('FindAndGet','#table',TKTL,TMAT.NRK,,"NRK+' (wer.'+WER+')'",'');
_grp_msg:=
   'Technologia %1'@[_nrk]+
   {? TMAT.NROP<>null()
   || ', operacja: %1'@[exec('get_oper_nr','tech_oper',TMAT.NROP().UNROP)]
   || ''
   ?}+
   {? _sur>0
   || ', surowiec: %1'@[{? TMAT.GRKTM='G' || TMAT.TGDFLT().PT().KTM || TMAT.PT().KTM ?}]
   || ''
   ?}+' - ';
_grp_msg


\tmat_modify_frombfr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Modyfikuje aktualny bufor tabeli TMAT na podstawie innego bufora (podczas grupowej modyfikacji danych)
::   WY: 0 - wystąpił błędy, rekord nie zostanie zmodfikowany / 1 - ok
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_ok:=1;
_fields:=params_get().env_mater.fields;
_fields.GRKTM:=TMAT.GRKTM;
_fields.PT:=TMAT.PT;
_fields.TGDFLT:=TMAT.TGDFLT;
_fields.KTL:=TMAT.KTL;
_buffer_grp:=params_get().env_mater.buffer_tmat_grp;
:: Zmiana indeksu materiałowego surowca
{? (_buffer_grp.GRKTM='G' & _buffer_grp.TGRP<>null()  & _buffer_grp.TGDFLT<>null())
   | (_buffer_grp.GRKTM<>'G' & _buffer_grp.PT<>null())
|| {? TMAT.GRKTM='G'
   || _jm_old:=TMAT.TGDFLT().PT().J
   || _jm_old:=TMAT.PT().J
   ?};
   _djm_old:=TMAT.DJM;
   _djm_kod:=TMAT.DJM().KOD;
   TMAT.GRKTM:=_buffer_grp.GRKTM;
   TMAT.TGRP:=null();
   TMAT.TGDFLT:=null();
   TMAT.PT:=null();
   {? TMAT.GRKTM='G'
   || TMAT.TGRP:=_buffer_grp.TGRP;
      TMAT.TGDFLT:=_buffer_grp.TGDFLT;
      _jm_new:=TMAT.TGDFLT().PT().J;
      VAR.A_T:=TMAT.TGDFLT().PT;
      VAR1.KTM:=VAR.A_T().KTM;
      {? TMAT.TGDFLT<>_fields.TGDFLT
      || VAR.TRED_KTL:='';
         VAR.RED_WER:='';
         TMAT.RKTL:='';
         TMAT.KTL:=null()
      ?}
   || TMAT.PT:=_buffer_grp.PT;
      _jm_new:=TMAT.PT().J;
      VAR.A_T:=TMAT.PT;
      VAR1.KTM:=VAR.A_T().KTM;
      {? TMAT.PT<>_fields.PT
      || VAR.TRED_KTL:='';
         VAR.RED_WER:='';
         TMAT.RKTL:='';
         TMAT.KTL:=null()
      ?}
   ?};
   {? _jm_old<>_jm_new
   || _ok:=0;
      _msg:='Nie można przypisać indeksu materiałowego o innej jednostce miary.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
      || FUN.emsg(_msg)
      ?}
   || _ok:=exec('var1_ktm_ae','tech_mater',TMAT,1);
      {? _ok>0
      || {? TMAT.DJM<>_djm_old
         || _ok:=0;
            _msg:='Wybrany indeks materiałowy nie ma zdefiniowanego przelicznika dla dodatkowej jednostki miary (%1).'@
                  [_djm_kod];
            {? VAR.GRUPA='T'
            || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
            || FUN.emsg(_msg)
            ?}
         ?}
      ?}
   ?}
?};

:: Faza produkcji/Wydział
{? _ok>0
|| {? _buffer_grp.PFAZ<>null() & _buffer_grp.PFAZ<>TMAT.PFAZ
   || {? TMAT.NROP<>null()
      || _ok:=0;
         _msg:='Nie można modyfikować fazy produkcji surowcom przypisanym do operacji.'@;
         {? VAR.GRUPA='T'
         || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
         || FUN.emsg(_msg)
         ?}
      || TMAT.PFAZ:=_buffer_grp.PFAZ;
::         exec('ae_pfaz','tech_mater')
         {? _buffer_grp.WYD<>null() & _buffer_grp.WYD<>TMAT.WYD
         || TMAT.WYD:=_buffer_grp.WYD
         ?}
      ?}
   |? _buffer_grp.WYD<>null() & _buffer_grp.WYD<>TMAT.WYD
   || {? TMAT.PFAZ<>null() & TMAT.PFAZ().WYD<>null() & TMAT.PFAZ().WYD<>_buffer_grp.WYD
      || _ok:=0;
         _msg:='Surowiec przypisany do innego wydziału niż wybrana faza produkcji.'@;
         {? VAR.GRUPA='T'
         || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
         || FUN.emsg(_msg)
         ?}
      || TMAT.WYD:=_buffer_grp.WYD
      ?}
   ?}
?};
:: Magazyn
{? _ok>0
|| {? _buffer_grp.MG<>null() & _buffer_grp.MG<>TMAT.MG
   || TMAT.MG:=_buffer_grp.MG
   ?}
?};

:: Zmiana norm (na razie nie obsługiwane)
::_is_par:=exec('FindAndGet','#table',TKTL,TMAT.NRK,,"TKTL.TYP().PAR='T'",0);
:: Norma netto
::{? _ok>0
::|| {? _buffer_grp.FORMN<>'' | _buffer_grp.WARN<>0
::   || {? _buffer_grp.FORMN<>'' & _par=0
::      || _msg:='Technologia %1 jest nieparametryzowana - nie można ustalić norm na podstawie określonych formuł.'@
::               [exec('FindAndGet','#table',TKTL,TMAT.NRK,,"NRK+' (wer.'+WER+')'",'')];
::         KOMM.add(_msg)
::      |? _buffer_grp.FORMN<>''
::      || TMAT.FORMN:=_buffer_grp.FORMN;
::         exec('formn_ae','tech_mater',TMAT)
::      || TMAT.WARN:=_buffer_grp.WARN;
::         TMAT.FORMN:='';
::         _ok:=exec('warn_po','tech_mater',TMAT)
::      ?}
::   ?}
::?};
:: Norma brutto
::{? _ok>0
::|| {? _buffer_grp.FORMB<>'' | _buffer_grp.WARB<>0
::   || {? _buffer_grp.FORMB<>'' & _par=0
::      || _msg:='Technologia %1 jest nieparametryzowana - nie można ustalić norm na podstawie określonych formuł.'@
::               [exec('FindAndGet','#table',TKTL,TMAT.NRK,,"NRK+' (wer.'+WER+')'",'')];
::         KOMM.add(_msg)
::      |? _buffer_grp.FORMB<>''
::      || TMAT.FORMB:=_buffer_grp.FORMB;
::         exec('formb_ae','tech_mater',TMAT)
::      || TMAT.WARB:=_buffer_grp.WARB;
::         TMAT.FORMB:='';
::         _ok:=exec('warn_po','tech_mater',TMAT)
::      ?}
::   ?}
::?};

:: Parametry
_so_changed:=0;
_lim_changed:=0;
_fld_err:='';
:: Surowiec/Odpad
{? _ok>0 & _buffer_grp.SO<>''
|| _so_changed:=1;
   {? TMAT.SO<>_buffer_grp.SO
   || TMAT.SO:=_buffer_grp.SO;
      _ok:=exec('ae_so','tech_mater')
   ?}
?};
_so:=TMAT.SO;
{? _ok>0
||
:: Podstawowy
   {? _fld_err='' & _buffer_grp.PODST<>'' & TMAT.PODST<>_buffer_grp.PODST
   || {? _so='O' & _so_changed=0
      || _fld_err:='Wchodzi w skład produktu'@
      || TMAT.PODST:=_buffer_grp.PODST
      ?}
   ?};
:: Limitowany
   {? _fld_err='' & _buffer_grp.LIMIT<>''
   || _lim_changed:=1;
      {? TMAT.LIMIT<>_buffer_grp.LIMIT
      || {? _so='O' & _so_changed=0
         || _fld_err:='Jest surowcem limitowanym'@
         || TMAT.LIMIT:=_buffer_grp.LIMIT;
            exec('ae_limit','tech_mater')
         ?}
      ?}
   ?};
:: Rozliczany z operacją
   {? _fld_err='' & _buffer_grp.ROZ<>'' & TMAT.ROZ<>_buffer_grp.ROZ
   || {? (_so_changed=0 & _so='O') | (_lim_changed=0 & _so='S' & TMAT.LIMIT='T')
      || _fld_err:='Surowiec rozliczany podczas rejestracji operacji'@
      || TMAT.ROZ:=_buffer_grp.ROZ
      ?}
   ?};
:: Powierzony
   {? _fld_err='' & _buffer_grp.POW<>'' & TMAT.POW<>_buffer_grp.POW
   || {? _so='O' & _so_changed=0
      || _fld_err:='Jest surowcem powierzonym przez kontrahenta'@
      || TMAT.POW:=_buffer_grp.POW
      ?}
   ?};
:: Tryb śledzenia dostaw
   {? _fld_err='' & _buffer_grp.MODE_DST<>'' & TMAT.MODE_DST<>_buffer_grp.MODE_DST
   || TMAT.MODE_DST:=_buffer_grp.MODE_DST
   ?}
?};
{? _fld_err<>''
|| _ok:=0;
   _type:={? TMAT.SO='O' || 'odpadów/koproduktów technologicznych'@ || 'surowców limitowanych'@ ?};
   _msg:='Znacznik \'%1\' nie może być modyfikowany dla %2.'@[_fld_err,_type];
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','tech_mater')+_msg)
   || FUN.emsg(_msg)
   ?}
?};
:: Dla zatwierdzonych kart przypisanie przyczyny zmiany
_tktl_stan:=exec('FindAndGet','#table',TKTL,TMAT.NRK,,"TKTL.STAN",'');
{? _ok>0 & _tktl_stan='T'
|| TMAT.USER:=OPERATOR.USER;
   TMAT.MOD_TIME:=TKTL.tm_stamp();
   TMAT.CAUSE:=_buffer_grp.CAUSE
?};
{? _ok>0
||
:: Końcowa walidacja TMATA
   _res:=exec('tchm_edt','tech_mater',TMAT,0);
   {? (type_of(_res)=type_of(0) & _res=0) | (type_of(_res)=type_of('') & _res<>'')
   || _ok:=0
   ?}
?};
_ok


\can_modify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Sprawdza, czy surowiec może być modyfikowany.
::       Działa na aktualnym buforze tabeli TMAT oraz TKTL
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_res:=1;
_used:=params_get().env_mater.used;
_act:=(TMAT.ACT='T');
_arc:=(TKTL.ARCH='T');
::Dla technologii kompletacyjnych zawsze dostęna redakcja
{? ~exec('is_k_res','tech_head',TKTL.TYP)
|| {? (_used | _arc | ~_act | TKTL.STAN='N' & TKTL.TORW<>'Z' | TKTL.STAN='P' & TKTL.STAT_S='T')
      | (TKTL.STAN='T' & (TKTL.TORW='W' | TKTL.TORW='Z' | ~exec('can_modify','tech_common')))
   || _res:=0
   ?}
?};
_res


\be_mg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Przed redakcją pola TMAT.MG
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
:: Ustawienie filtra na magazyny wszystkie (surowce nielimitowane lub odpad),
:: albo magazyny do realizacji zamówień wewnętrznych
MG.clear();
{? TMAT.LIMIT='N' | TMAT.SO='O' | VAR.GRP_MOD='P'
|| MG.f_set('SYM',,'')
|| MG.f_set('SYM','join USERS_UP','USERS_UP.USERS is null and USERS_UP.AKR=\'ZAW\' ')
?};
_result


\ae_mg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Po redakcji pola TMAT.MG
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
:: Sprawdzam czy magazyn jest typu z obsługą dostaw jeżeli przypięta jest cecha
{? TMAT.DK_C<>null() & TMAT.MG<>null()
|| {? ~(TMAT.MG().TYP*'DOST')
   || _msg:='Surowiec posiada cechę, przypisany magazyn musi być typu: \'%1\''@['DOSTAWY lub DOSTEWI'];
      FUN.emsg(_msg);
      _result:=0
   ?}
?};
_result


\tmat_has_zam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Sprawdza, czy podany surowiec technologiczny posiada zdefiniowane zamienniki technoloiczne
::   WE: _a - $TMAT.ref()
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_tmat:={? var_pres('_a')=type_of('') || _a || '' ?};
_wyn:=0;
{? _tmat<>''
|| _mask:=ref_name(_tmat)+3;
   TMAT.cntx_psh();
   TMAT.use((5+TMAT.name())+_mask);
   TMAT.clear();
   {? TMAT.seek(_tmat)
   || TCHMAT.cntx_psh();
      TCHMAT.use((5+TCHMAT.name())+_mask);
      TCHMAT.index('SL');
      TCHMAT.prefix(TMAT.ref());
      {? TCHMAT.first()
      || _wyn:=1
      ?};
      TCHMAT.cntx_pop()
   ?};
   TMAT.cntx_pop()
?};
_wyn


\jm_win4tmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Tworzy okno wertowania jednostek miary dla okien surowców/zamienników technologicznych
::   WY: utworzone okno
::----------------------------------------------------------------------------------------------------------------------
_win:=JM.mk_sel('Jednostki miary - przeliczniki'@,'P',0,'jmqwerf',36,1,19,0,'U','T',0,0,0,'','wrapped','on');
JM.win_fld(_win,JM,'KOD',,,10,0,0,'',0,'Kod jednostki miary'@);
JM.win_fld(_win,JM,'NAZ',,,30,0,0,'',0,'Nazwa jednostki miary'@);
JM.win_fld(_win,BEER,'PRZ',,,12,6,1,'× Współczynnik'@@,0,'Przelicznik pomiędzy jednostkami miary'@);
JM.win_fld(_win,BEER,'IL2',,,15,3,1,'= Ilość'@@,0,'Wyliczona ilość w innej jednostce miary'@,,);
JM.win_act(_win,0,'Formuła','Dołącz'@,'','Dołącz nowy przelicznik miary',"exec('add_mjm4tmat','tech_mater')","",1);
task_attach('ZWS_PAR_KMTR');
JM.win_act(_win,1,'Formuła','Dołącz'@,'','Dołącz nowy przelicznik miary',"exec('add_mjm4tmat','tech_mater')","",1);
task_attach('ZWS_PAR_KMTR');
JM.win_act(_win,0,'Formuła','Popraw'@,'','Modyfikuj przelicznik miary',"exec('mod_mjm4tmat','tech_mater')","",1);
task_attach('ZWS_PAR_KMTR');
JM.win_act(_win,0,'Formuła','Usuń'@,'','Usuń przelicznik miary',"exec('del_mjm4tmat','tech_mater')","",1);
task_attach('ZWS_PAR_KMTR');
JM.win_act(_win,0,'Szukaj');
JM.win_act(_win,0,'Rekord',,,,"exec('rek_jm2','jm')","exec('chk_jm','!zws_par_kdjm')");
JM.win_act(_win,0,'Kolejność');
_win


\add_mjm4tmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Dodaje przelicznik (akcja Dołącz) dla dodatkowej jednostki miary z poziomu okien redagowania
::       surowców/zamienników technologicznych.
::----------------------------------------------------------------------------------------------------------------------
:: Ustalenie materiału
{| ($BEER.TAB)()
|! {? GRKTM='G'
   || _mat:=TGDFLT().PT
   |? GRKTM='K'
   || _mat:=PT
   || _mat:=null()
   ?}
|};
:: Podczytanie materiału
M.cntx_psh();
M.prefix();
{? M.seek(_mat)
|| BEER.MJM:=M.ref();
   _jm_ref:={? JM.size()>0 || JM.ref() || null() ?};
   JM.cntx_psh();
   JM.prefix();
   JM.win_dict('SLO');
   JM.f_clear(1);
   MJM.cntx_psh();
   MJM.index('JM');
   MJM.prefix(_mat);
   MJM.blank();
   {? exec('pr_mjm_dol','jm')
   || {? MJM.edit("exec('po_mjm','jm',0,'add')")
      || {? MJM.add()
         || exec('po_mjm_dol','jm');
            _jm_ref:=MJM.JM
         ?}
      ?}
   ?};
   MJM.cntx_pop();
   JM.cntx_pop();
:: Przywrócenie filtra na JM
   exec('filtr_djm','tech_mater',BEER.TAB);
   {? _jm_ref<>null() || {? JM.f_active() || JM.f_seek(_jm_ref) || JM.seek(_jm_ref) ?} ?}
|| FUN.emsg('Przed dołączeniem przeliczników należy określić indeks materiałowy surowca lub zamiennika technologii.'@)
?};
M.cntx_pop();
~~


\mod_mjm4tmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Modyfikuje przelicznik (akcja Popraw) dla dodatkowej jednostki miary z poziomu okien redagowania
::       surowców/zamienników technologicznych.
::----------------------------------------------------------------------------------------------------------------------
:: Ustalenie materiału
{| ($BEER.TAB)()
|! {? GRKTM='G'
   || _mat:=TGDFLT().PT
   |? GRKTM='K'
   || _mat:=PT
   || _mat:=null()
   ?}
|};
:: Podczytanie materiału
M.cntx_psh();
M.prefix();
{? M.seek(_mat)
|| BEER.MJM:=M.ref();
   _jm_ref:=JM.ref();
   JM.cntx_psh();
   JM.prefix();
   JM.win_dict('SLO');
   JM.f_clear(1);
:: Odnalezienie przelicznika
   MJM.cntx_psh();
   MJM.index('JM');
   MJM.prefix();
   {? MJM.find_key(_mat,_jm_ref)
   || {? exec('pr_mjm_mod','jm')
      || {? MJM.edit("exec('po_mjm','jm',0,'put')")
         || {? MJM.put()
            || exec('po_mjm_mod','jm')
            ?}
         ?}
      ?}
   ?};
   MJM.cntx_pop();
   JM.cntx_pop();
:: Przywrócenie filtra na JM
   exec('filtr_djm','tech_mater',BEER.TAB)
|| FUN.emsg('Nie udało się odnaleźć materiału.'@)
?};
M.cntx_pop();
~~


\del_mjm4tmat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Usuwa przelicznik (akcja Usuń) dla dodatkowej jednostki miary z poziomu okien redagowania
::       surowców/zamienników technologicznych.
::----------------------------------------------------------------------------------------------------------------------
:: Ustalenie materiału
{| ($BEER.TAB)()
|! {? GRKTM='G'
   || _mat:=TGDFLT().PT
   |? GRKTM='K'
   || _mat:=PT
   || _mat:=null()
   ?}
|};
:: Podczytanie materiału
M.cntx_psh();
M.prefix();
{? M.seek(_mat)
|| BEER.MJM:=M.ref();
   _jm_ref:=JM.ref();
   JM.cntx_psh();
   JM.prefix();
   JM.win_dict('SLO');
   JM.f_clear(1);
:: Odnalezienie przelicznika
   MJM.cntx_psh();
   MJM.index('JM');
   MJM.prefix();
   {? MJM.find_key(_mat,_jm_ref)
   || {? exec('del_mjm','jm')
      || {? FUN.ask('Usunąć wybrany przelicznik jednostki miary?'@)
         || MJM.del()
         ?}
      ?}
   ?};
   MJM.cntx_pop();
   JM.cntx_pop();
:: Przywrócenie filtra na JM
   exec('filtr_djm','tech_mater',BEER.TAB)
|| FUN.emsg('Nie udało się odnaleźć materiału.'@)
?};
M.cntx_pop();
~~


\chk_mg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Sprawdza, pobrawność wypełnienia pola TMAT.MG dla surowców limitowanych technologii -
::       czy do surowców przypisane są magazyny tego samego typu (paletowy/niepaletowy).
::       Pracuje na aktualnym buforze tabeli TMAT
::   WE: [_a] - tryb pracy: [1] - dołącz, 0 - popraw
::   WY: 1 - ok / 0 - błędny magazyn
::----------------------------------------------------------------------------------------------------------------------
_add:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_result:=1;
{? TMAT.LIMIT='T' & TMAT.SO='S' & TMAT.MG<>null()
|| _nrk:=TMAT.NRK;
   _pal:=TMAT.MG().PAL='T';
   _ref:={? _add>0 || null() || TMAT.ref() ?};
   TMAT.cntx_psh();
   TMAT.index('NRK_PAL');
   TMAT.prefix(_nrk,{? _pal || 'N' || 'T' ?},'T','S');
   {? TMAT.first()
   || _result:={? _ref=TMAT.ref() || ~TMAT.next() || 0 ?}
   ?};
   TMAT.cntx_pop()
?};
_result


\get_tmat_nrop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Zwraca operację surowca (blank pola TCHMAT.NROP)
::   WY: TOPER.ref()
::----------------------------------------------------------------------------------------------------------------------
_res:=null();
{? TMAT.NROP<>null()
|| _res:=TMAT.NROP
|| _res:=VAR.A_OP
?};
_res

:Sign Version 2.0 jowisz:1045 2023/10/26 08:53:19 72645757c961e482f7f5c021d015430b6c78df54c705f4641d8c0bdaa2b9085fc9558a8e89b3e4edfc093104bfb8e0ec8eacd761058ae7576a46ac9228d0a1025b40585358529a342a64f3e2968d14a710d9315bec3531542864439bba2f118bdefe8bb4198ccd6af5b5cd8255f280a810fd6f412dff02641216946fe62cb05f
