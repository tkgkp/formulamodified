:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: okres.fml [2005]
:: Utworzony: 2005/12/20
:: Autor: [mk] Michal Kocot
::======================================================================================================================
:: Zawartosc: Definicja okresów rozliczeniowych
::======================================================================================================================


\sel_okr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [mk] Michał Kocot [2006]
:: OPIS: Udostępnia okresy do edycji.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? P.name()<>'pracowni'
|| FUN.emsg('Opcja dostępna tylko dla pracowników etatowych.'@);
   return(0)
?};
{? __HARM.WYBRANY
|| A_OKR.seek(__HARM.OKR_REF);
   A_OKR.hdr_sel();
   A_OKR.hdr_sel(' Wybrano okres: %1'@[exec('record','#to_string',A_OKR.ref())])
|| A_OKR.index('A_OKR');
   A_OKR.clear();
   A_OKR.find_le(date())
?};
A_OKR.win_sel('WER');
A_OKR.win_edit('RED');
A_OKRN.actions('WER','W');
{? ~A_OKR.select(,1,,{? exec('chk_role','#b__box',OPERATOR.USER,'PRC_CZP_DOKR') || '' || 'dpuMBLR:d' ?})
|| {? ~A_OKR.seek(__HARM.OKR_REF)
   || A_OKR.clear();
      {? ~A_OKR.find_le(date()) || A_OKR.first() ?}
   ?}
?};
exec('wybierz_okres','okres');
{? __HARM.WYBRANY || A_OKR.seek(__HARM.OKR_REF) ?};
__HARM.WYBRANY


\wybierz_okres
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.10]
:: OPIS: Ustalenie aktywnego okresu.
::----------------------------------------------------------------------------------------------------------------------
__HARM.ustaw_okres();
_roznica:=exec('roznica','prc_rozlicz',A_OKR.OD,A_OKR.DO);
A_OKRM.index('A_OKRMR');
A_OKRM.prefix();
{! _ind:=0.._roznica
|! {? A_OKR.DO<>#0 &
      ~A_OKRM.find_key(date(A_OKR.DO~1,A_OKR.DO~2-_ind,1)~1,date(A_OKR.DO~1,A_OKR.DO~2-_ind,1)~2)
   || A_OKRM.blank();
      A_OKRM.R:=date(A_OKR.DO~1,A_OKR.DO~2-_ind,1)~1;
      A_OKRM.M:=date(A_OKR.DO~1,A_OKR.DO~2-_ind,1)~2;
      A_OKRM.add()
   ?}
!}


\wyczysc_wyb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.10]
:: OPIS: Czyści wybór okresu.
::----------------------------------------------------------------------------------------------------------------------
__HARM.wylacz_okres()


\kol_rek
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [17.28]
:: OPIS: Formuła na rekord, wyszarzanie akcji i przycisków oraz kolorowanie rekordów.
::   WE: _a [NUMBER] - Rekord bieżący? [0 - nie / 1 - tak]
::   WY:
::----------------------------------------------------------------------------------------------------------------------
POLA_GRP.TXT_1:=
   {? A_OKR.S_PLAN='O'
   || 'Odblokowany'
   || 'Zablokowany'
   ?};
POLA_GRP.TXT_2:=
   {? A_OKR.S='O'
   || 'Otwarty'
   || 'Zamknięty'
   ?};

{? _a
|| _grey:='';
   {? A_OKR.S_PLAN='O'
   || _grey+='ORT';
      {? A_OKR.ER='T'
      || _grey+='I(Z)'
      || _grey+='I(B)'
      ?};
      A_OKRP.cntx_psh();
      A_OKRP.index('A_OKRP');
      A_OKRP.prefix(A_OKR.ref());
      _grey+={? A_OKRP.first() || 'pu' || '' ?};
      A_OKRP.cntx_pop()
   |? A_OKR.S_PLAN='Z' & A_OKR.S='O'
   || _grey+='puI(B)I(Z)ZT'
   |? A_OKR.S='Z'
   || _grey+='puMI(B)I(Z)ZOR'
   |? ~exec('done_state','pkd','PRC_CZP_DOKR',A_OKR.uidref())
   || _grey+='WpuMI(B)I(Z)ZORT'
   ?};
   A_OKR.actions_grayed('WER',_grey)
?};

{? A_OKR.ref=__HARM.OKR_REF
|| Color.fnd_kol('PRC_OKR#01#01')
|? A_OKR.S='Z'
|| Color.fnd_kol('PRC_OKR#01#03')
|? A_OKR.S_PLAN='Z'
|| Color.fnd_kol('PRC_OKR#01#02')
|| ''
?}


\rekpookr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [mk] Michał Kocot [2006]
:: OPIS: weryfikacja zapisu w okresach.
::   WE:
::   WY: 1 prawidłowo, 0 nieprawidłowo
::----------------------------------------------------------------------------------------------------------------------
_ret:=__CHK.record2(A_OKR,'OD','Początek okresu'@,'DO','Koniec okresu'@,'NAZ','Nazwa'@);
{? _ret<>'' || return(_ret) ?};
{? -(menu_pth()+1)='d' || _add:=1 || _add:=0 ?};
 _ret:=1;
_naz:=A_OKR.NAZ;
_od:=A_OKR.OD;
_do:=A_OKR.DO;
_ref:=A_OKR.ref();
{? _do<=_od
|| FUN.emsg('Data DO musi być późniejsza niż OD'@);
   return('OD')
?};
A_OKR.cntx_psh();
A_OKR.index('A_OKRNN');
A_OKR.prefix(_naz);
{? A_OKR.last()
   || {!
      |? {? _ref<>A_OKR.ref() | _add
         || {? _do>=A_OKR.OD & _do<=A_OKR.DO || _ret:=0 ?};
            {? _od>=A_OKR.OD & _od<=A_OKR.DO || _ret:=0 ?};
            {? _od<=A_OKR.OD & _do>=A_OKR.DO || _ret:=0 ?}
         ?};
         _ret & A_OKR.prev()
      !};
      {? ~_ret || FUN.emsg('Daty okresów nachodzą na siebie'@) ?}
?};
A_OKR.cntx_pop();
:: dla włączonego parametru 320 sprawdzamy czy są wprowadzone niedziele handlowe w zakresie wprowadzanego
:: okresu rozliczeniowego ale dopiero po dacie 2018/03/01
{? _ret & exec('get_par','#parametr',320,2)='T' & A_OKR.DO>=date(2018,3,1)
|| _txt:='';
   _lata:='';
   _brak:=0;
   _rok_od:=A_OKR.OD~1;
   _rok_do:=A_OKR.DO~1;
   _tab:=sql(''+"select ROK from R_NDHAN where DATA>=to_date('2018/03/01') and (ROK>=:_a and ROK<=:_b) order by ROK",
             _rok_od,_rok_do);

   {! _rok:=_rok_od.._rok_do
   |! _tab.prefix(_rok);
      {? ~_tab.first()
      || _brak+=1;
         {? _txt=''
         || _txt:='Brak informacji o niedzielach handlowych w roku '@;
            _lata:=$_rok
         || _txt:='Brak informacji o niedzielach handlowych w latach '@;
            _lata+=', %1'[$_rok]
         ?}
      ?}
   !};
   {? _brak
   || _txt:='%1 %2.\n'[_txt, _lata]+
            'W celu poprawnego działania weryfikacji planowania należy uzupełnić brakujące informacje.'@;
      FUN.info(_txt)
   ?}
?};
_ret


\b_del_A_OKR
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.30]
:: OPIS: Przed usun dla tabeli A_OKR
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? exec('otwarty','okres')
||
:: zalozenie transakcji
   _mydo:=do_state()=0;
   {? _mydo || do() ?};
   exec('usun_z_buff_ORP','grafik',A_OKR.ref());
   _ok:=exec('testlink','#record',A_OKR,0)=0;
   {? ~_ok || undo() ?};
   {? _mydo || end() ?};

   {? ~_ok
   || exec('testlink','#record',A_OKR,1)=0
   || 1
   ?}
?}


\a_okr_legenda_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [17.28]
:: OPIS: Obsługa akcji "Legenda" w oknach tabeli A_OKR.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','PRC_OKR#01#')


\okres_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.10]
:: OPIS: Przed popraw w okienku okresow rozliczeniowych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? exec('otwarty','okres')
|| A_OKRP.cntx_psh;
   A_OKRP.index('A_OKRP');
   A_OKRP.prefix(A_OKR.ref());
   {? A_OKRP.first()
   || FUN.info('Istnieją przypisani pracownicy do okresu\nModyfikacja niemożliwa.'@);
      _wyn:=0
   || _wyn:=1
   ?};
   A_OKRP.cntx_pop;
   _wyn
?}


\otwarty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.10]
:: OPIS: Przed usuń w okresie i miesiącu.
::----------------------------------------------------------------------------------------------------------------------
{? A_OKR.S='Z'
|| FUN.emsg('Status jest ustawiony jako: "Zamknięty".\nWykonanie wybranej akcji jest niemożliwe.'@);
   0
|| 1
?}


\a_okr_wer_bfro
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [2006]
:: OPIS: Akcja otworzenie okresu rozliczeniowego.
::   WE: _a - [INTEGER] 1- wyświetlenie komunikatu, 0- bez wyświetlenia komunikatu
::   WY:
::  OLD: \zamk_okr/okres.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(0) || _a:=1 ?};
A_OKR.get();
{? A_OKR.S='Z'
   &
   {? _a || FUN.ask('Czy na pewno zmienić status zamkniętego okresu?'@) || 1 ?}
|| A_OKR.S:='O';
   A_OKR.put()
?};
~~


\a_okr_wer_bfrz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [2006]
:: OPIS: Akcja zamknięcie okresu rozliczeniowego. Przeniesienie danych o nadgodzinach oraz o odbiorze nadgodzin.
::   WE: [_a] - [STRING] Miesiąc rozliczenia przekroczeń średniotygodniowych, O-ostatni miesiąc okresu, N-następny m-c.
::   WY:
::  OLD: \zamk_okr/okres.fml
::----------------------------------------------------------------------------------------------------------------------
A_OKR.get();
{? A_OKR.S='Z'
|| return(~~)
?};

{? A_OKR.S_PLAN<>'Z'
|| FUN.info('Przed zamknięciem okresu do rozliczenia należy zablokować planowanie w okresie.'@);
   return(0)
?};

_roznica:=exec('roznica','prc_rozlicz',A_OKR.OD,A_OKR.DO);
A_OKRM.cntx_psh();
A_OKRM.index('A_OKRMR');
A_OKRM.prefix();
{! _ind:=0.._roznica
|! {? A_OKRM.find_key(date(A_OKR.DO~1,A_OKR.DO~2-_ind,1)~1,date(A_OKR.DO~1,A_OKR.DO~2-_ind,1)~2)
   || {? A_OKRM.S='O'
      || FUN.emsg('%1\n%2'
            [  'Nie zostały przeniesione dane miesięczne do rozliczenia.'@,
               'Należy wykonać zamknięcie miesięcy do rozliczenia przed zamknięciem okresu.'@
            ]
         );
         A_OKRM.cntx_pop();
         return(~~)
      ?}
   ?}
!};
A_OKRM.cntx_pop();

{? ~FUN.ask(
      'Zostanie zamknięty okres oraz przeniesione zostaną dane\n'
      'dotyczące godzin nadliczbowych i odbioru do obszaru: Płace.\n'
      'Kontynuować?'@
   )
|| return(~~)
?};

:: Weryfikacja odbiorów
_tab:=exec('zwrot_bufor','godziny');
exec('zwrot_odb_okres','godziny',_tab);
{? _tab.first()
|| FUN.emsg('%1\n%2'
      [  'W zamykanym okresie znajdują się pracownicy z odbiorem dni wolnych podczas nieobecności.'@,
         'Należy zweryfikować wykazane odbiory.'@
      ]
   );
   _wer:=_tab.mk_sel('Pracownicy z odbiorem w dzień wolny'@,,0,'zwrot_odbioru',,,,,'U',,,,,'maximized');
   _tab.win_fld(_wer,,'NAZWISKO',,,20,,1,'Nazwisko'@,,'Nazwisko współpracownika'@);
   _tab.win_fld(_wer,,'IMIE',,,15,,1,'Imię'@,,'Imię współpracownika'@);
   _tab.win_fld(_wer,,'WYDZIAL',,,10,,1,'Jednosta organizacyjna'@,,'Jednostka organizacyjna współpracownika'@);
   _tab.win_fld(_wer,,'T',,,9,,1,'Teczka'@,,'Nr teczki współpracownika'@);
   _tab.win_fld(_wer,,'DO',,,10,,1,'Data odbioru'@,,'Data odbioru w dzień wolny'@);
   _tab.win_fld(_wer,,'G',,,10,,1,'Ilość godzin'@,,'Ilość godzin odbioru'@);
   _tab.win_fld(_wer,,'NB',,,20,,1,'Nieobecność'@,,'Rodzaj nieobecności'@);
   _tab.win_fld(_wer,,'N_OD',,,10,,1,'Początek'@,,'Początek nieobecności'@);
   _tab.win_fld(_wer,,'N_DO',,,10,,1,'Koniec'@,,'Koniec nieobecności'@);
   _tab.win_sel(_wer);
   _tab.select();
   FUN.emsg('%1\n%2\n%3'
      [  'Istnieją odbiory w dni wolne.'@,
         'Należy zmienić dzień odbioru lub wykasować odbiór dnia wolnego w celu przeniesienia do wyplaty.'@,
         'Procedury zamknięcia okresu nie można kontynuować.'@
      ]
   );
   return(~~)
?};
obj_del(_tab);
&_tab;

P.cntx_psh();
A_OKRP.cntx_psh();
A_OKRP.index('A_OKRNI');
A_OKRP.prefix(A_OKR.ref());
: Częściowe zamykanie miesięcy
_res:=exec('rok_msc_rozl','godziny',A_OKR.DO,{? var_pres('_a')=type_of('') || _a || 0 ?});
{? _res.m_rozl<>_res.m
|| _res_r:=_res.r;
   _res_m:=_res.m
|| _res_r:=_res.r_nast;
   _res_m:=_res.m_nast
?};

G.cntx_psh();
G.use('godz'+$_res_r);
_tab:=sql('
   select distinct OSOBA.NAZWISKO, OSOBA.PIERWSZE, G.M M
   from A_OKR join A_OKRP join OSOBA join G using(A_OKRP.P,G.P)
   where A_OKR.REFERENCE=\':_a\' and G.M=:_c and G.F=\':_b\' and A_OKRP.S_PLAN<>\'X\'
   order by 1,2',
      $A_OKR.ref(),'RCP_'+$A_OKR.ref(),_res_m
);
G.cntx_pop();

{? _tab.first()
|| FUN.emsg('%1\n%2\n%3'
      [  'Zostały znalezione dane odnośnie zamknięcia wybranego okresu w innym miesiącu rozliczeniowym:'@,
         date(_res_r,_res_m,1)$8,
         'Po wyświetleniu szczegółowych danych operacja zamknięcia okresu zostanie zakończona.'@
      ]
   );
   _wer:=_tab.mk_sel('Pracownicy z danymi o godzinach w miesiącu rozliczenia: %1'@[$_res_m],,,,,,,,'U',,,,,'maximized');
   _tab.win_fld(_wer,,'NAZWISKO',,,30,,1,'Nazwisko'@,,'Nazwisko współpracownika'@);
   _tab.win_fld(_wer,,'PIERWSZE',,,30,,1,'Imię'@,,'Imię współpracownika'@);
   _tab.win_fld(_wer,,'M',,,20,,1,'Miesiąc rozliczeniowy'@,,'Miesiąc, w którym wystąpiły dane do rozliczenia'@);
   _tab.win_sel(_wer);
   _tab.select();
   {? FUN.ask('%1\n%2'
         [  'Czy zmienić status otwartego okresu na "Zamknięty"?'@,
            'Dane o godzinach pracy nie zostaną przeniesione do rozliczenia.'@
         ]
      )
   || A_OKR.S:='Z';
      A_OKR.put()
   ?};
   A_OKRP.cntx_pop();
   P.cntx_pop();
   return(~~)
?};

{? _res.wyb>0
   &
   exec('lista_sum_zamk','godziny',_res.r_rozl,_res.m_rozl,1)
|| {? FUN.ask('%1\n%2'
         [  'Czy zmienić status otwartego okresu na "Zamknięty"?'@,
            'Dane o godzinach pracy nie zostaną przeniesione do rozliczenia.'@
         ]
      )
   || A_OKR.S:='Z';
      A_OKR.put()
   ?};
   A_OKRP.cntx_pop();
   P.cntx_pop();
   return(~~)
?};

{? _res.wyb>0 & A_OKRP.first()
|| PROGRESS.set(A_OKRP.size(),'Trwa zamykanie okresu.'@);
   {!
   |? {? A_OKRP.S_PLAN<>'X' & P.seek(A_OKRP.P,,1)
      || {? P.KAL
         || __KAL.set_cal(P.KAL().NAZWA,A_OKRP.OD~1)
         || __KAL.set_cal('standard')
         ?};
         exec('zamk_okr_prac','godziny',0,_res)
      ?};
      PROGRESS.next();
      A_OKRP.next()
   !};
   PROGRESS.close()
?};
A_OKRP.cntx_pop();
P.cntx_pop();

{? _res.wyb>0
|| A_OKR.S:='Z';
   {? A_OKR.put()
   || exec('usun_z_buff_ORP','grafik',A_OKR.ref())
   ?}
?};
{? var_pres('_res')>0 || obj_del(_res) ?};
~~


\a_okr_wer_bflz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Akcja zablokowanie okresu rozliczeniowego do planowania.
::       Jeśli okres jest odblokowany akcja pozwala na zablokowanie okresu.
::       UWAGA - wymagane ustawienie kontekstu tabeli A_OKR.
:: OPIS: Formuła do zablokowania okresu rozliczeniowego.
::   WE: _a - [INTEGER] (1/0) wyświetlenie komunikatu o zablokowaniu planowania w miesiącu.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
A_OKR.get();
{? _a & A_OKR.S_PLAN='Z'
|| return(~~)
?};

_res:=exec('lock_A_OKR','grafik',A_OKR.ref());
{? +_res
|| FUN.emsg(_res)
|| _allMsc:=1;
   _allMsc:=exec('canClosePlanOkr','okres',A_OKR.ref());
   {? ~_allMsc
   || FUN.info('Nie wszystkie miesiące należące do okresu mają zablokowane planowanie.'@+'\n'
               'Nie można zablokować planowania okresu.'@);
      exec('unlock_A_OKR','grafik',A_OKR.ref());
      return(0)
   ?};
   _okr_ref:=A_OKR.ref();
:: Utworzenie tabeli współpracowników z odblokowanym planowaniem w okresie
:: (tylko współpracownicy zaznaczeni do planowania)
   _tab:=exec('getPracInOkr','okres',_okr_ref,'O','T');
   _ok:=0;
   {? _tab.first()
   || FUN.emsg('W okresie rozliczeniowym znajdują się współpracownicy z odblokowanym planowaniem.'@+'\n'+
               'Przed zablokowaniem okresu do planowania należy zablokować\n'
               'planowanie wszystkim współpracownikom z tego okresu.'@);
      _wer:=_tab.mk_sel('Współpracownicy z odblokowanym planowaniem'@,,0,'201207101133',,,,,'U',,,,,'maximized');
      _tab.win_fld(_wer,,'WYDZIAL',,,10,,1,'Wydział'@,,'Jednostka organizacyjna współpracownika'@);
      _tab.win_fld(_wer,,'T',,,9,,1,'Teczka'@,,'Nr teczki współpracownika'@);
      _tab.win_fld(_wer,,'NAZWISKO',,,20,,1,'Nazwisko'@,,'Nazwisko współpracownika'@);
      _tab.win_fld(_wer,,'IMIE',,,15,,1,'Imię'@,,'Imię współpracownika'@);
      _tab.win_fld(_wer,,'PLAN',,,6,,1,'Status'@,,'Status planowania \'O\'- odblokowany, \'Z\'- zablokowany'@);
      _tab.win_fld(_wer,POLA_GRP,'TXT_1',,,15,,1,'Opis statusu'@,,'Opis statusu planowania'@);
      _tab.win_fld(_wer,,'SZEF',,,30,,1,'Przełożony'@,,'Przełożony współpracownika'@);
      _tab.win_act(_wer,0,'Formuła','Zablokuj'@@,,
         'Zablokowanie planowania dla wybranych współpracowników',,
         "  _grupa:=0;
            {? cur_tab().sel_size()>0
            || _grupa:=1
            || {? ~FUN.ask('%1\n%2 %3?'
                     ['Czy zablokować planowanie dla współpracownika'@,cur_tab().NAZWISKO,cur_tab().IMIE]
                  )
               || return(0)
               ?}
            ?};
            {? ~_grupa
            || FUN.prg_start(2,'Trwa blokowanie okresu do planowania.'@,,,1);
               FUN.prg_next()
            ?};
            P.cntx_psh();
            A_OKRP.cntx_psh();
            A_OKRP.index('A_OKRPR');
            {? P.seek(cur_tab().P_REF,,1)
            || _maska:=form(8+cur_tab().A_OKRP);
               {? A_OKRP.seek(cur_tab().A_OKRP,_maska,1)
               || A_OKRP.S_PLAN:='Z';
                  {? exec('zam_msc_plan','okres',A_OKRP.ref(),0,0,1,'Z')
                  || cur_tab().del()
                  ?}
               ?}
            ?};
            A_OKRP.cntx_pop();
            P.cntx_pop();
            {? ~_grupa
            || FUN.prg_next();
               FUN.prg_stop()
            ?};
            {? cur_tab().size()=0 || sel_exit() ?};
            ~~
         ",,1,
         "  {? FUN.ask('Czy zablokować planowanie dla zaznaczonych współpracowników?'@) || 1 || 0 ?}
         ",
         "  {? cur_tab().size()=0 || sel_exit() ?}
         ",'Z'
      );
      _tab.win_act(_wer,0,'Formuła','Zablokuj &wszystkim'@@,,
         'Zablokowanie planowania dla wybranych współpracowników',,
         "  {? ~FUN.ask('Czy zablokować planowanie dla wszystich współpracowników?')
            || return(0)
            ?};
            FUN.prg_start(2,'Trwa blokowanie okresu do planowania.'@,,,1);
            P.cntx_psh();
            A_OKRP.cntx_psh();
            A_OKRP.index('A_OKRPR');
            cur_tab().first();
            {!
            |? {? P.seek(cur_tab().P_REF,,1)
               || _maska:=form(8+cur_tab().A_OKRP);
                  {? A_OKRP.seek(cur_tab().A_OKRP,_maska,1)
                  || A_OKRP.S_PLAN:='Z';
                     {? exec('zam_msc_plan','okres',A_OKRP.ref(),0,0,1,'Z')
                     || cur_tab().del()
                     ?}
                  ?}
               ?};
               FUN.prg_next();
               cur_tab().size()
            !};
            A_OKRP.cntx_pop();
            P.cntx_pop();
            FUN.prg_stop();
            {? cur_tab().size()=0 || sel_exit() ?};
            ~~
         ",,1,,,'W'
      );
      _tab.win_act(_wer,0,'Kolejność');
      _tab.win_act(_wer,,'Rekord',,,,
         " POLA_GRP.TXT_1:=
               {? cur_tab().PLAN='O'
               || 'odblokowany'
               || 'zablokowany'
               ?};
            cur_tab().actions_grayed(cur_win(),{? cur_tab().sel_size() || 'Z' || '' ?})
         "
      );
      _tab.win_btn(_wer,'text=%1,panel=right,align=begin'['Zablokuj'@],'menu:Z');
      _tab.win_btn(_wer,'text=%1,panel=bottom,align=begin'['Zablokuj &wszystikm'@],'menu:W');
      _tab.win_btn(_wer,'text=%1,icon=xwin16.png:14,panel=bottom,align=end'['Anuluj'@],'key:Esc');
      _tab.win_sel(_wer);
      _tab.select();
      _ok:=_tab.size()=0
   || _ok:=1
   ?};
   {? _ok
   || {? {? _a
         || FUN.ask('%1\n%2'['Wybrany okres zostanie zablokowany do planowania.'@,'Kontynuować?'@])
         || 1
         ?}
      ||
:: Utworzenie tabeli współpracowników z odblokowanym planowaniem w okresie
:: (tylko współpracownicy bez zaznaczenia do planowania)
         _tab_bez:=exec('getPracInOkr','okres',A_OKR.ref(),'O','N');
         {? _tab_bez.first()
         || A_OKRP.cntx_psh();
            A_OKRP.index('A_OKRPR');
            {!
            |? {? A_OKRP.seek(_tab_bez.A_OKRP,,1)
               || {? exec('setStatusM_Plan','okres',A_OKRP.ref(),,,'Z')
                  || A_OKRP.S_PLAN:='Z';
                     A_OKRP.put(1)
                  ?}
               ?};
               _tab_bez.next()
            !};
            A_OKRP.cntx_pop()
         ?};
         A_OKR.S_PLAN:='Z';
         A_OKR.put();
:: Dla wszystkich miesięcy należących do okresu sprawdzamy czy można zablokować miesiąc do planowania przy okazji
:: zamykania okresu
         _p_rok:=A_OKR.OD~1;
         _k_rok:=A_OKR.DO~1;
         _p_msc:=A_OKR.OD~2;
         _k_msc:=A_OKR.DO~2;
         _rok:=_p_rok;
         _msc:=_p_msc;
         {!
         |? {? exec('allPlanned4Msc','okres',_rok,_msc)
            || exec('setMscPlanStat','okres',_rok,_msc,'Z')
            ?};
            _msc+=1;
            {? _msc>12 || _rok+=1; _msc:=1 ?};
            (_rok<_k_rok) | (_rok=_k_rok & _msc<=_k_msc)
         !}
      ?}
   ?};
   &_okr_ref
?};
exec('unlock_A_OKR','grafik',A_OKR.ref());
~~


\a_okr_wer_bflo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Akcja odblokowanie okresu rozliczeniowego do planowania.
::       Jeśli okres jest zablokowany akcja pozwala na odblokowanie okresu.
::       UWAGA - wymagane ustawienie kontekstu tabeli A_OKR.
::   WE: _a - [INTEGER] (1/0) wyświetlenie komunikatu o odblokowaniu planowania w miesiącu.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
A_OKR.get();
{? _a & A_OKR.S_PLAN='O'
|| return(~~)
?};
_dalej:=1;
:: Sprawdzenie czy nie ma już wprowadzonego wykonania
P.cntx_psh();
A_OKRP.cntx_psh();
A_OKRP.index('A_OKPP');
A_OKRP.prefix(A_OKR.ref());
{? A_OKRP.first()
|| _p_ref:=A_OKRP.P;
   FUN.prg_start(A_OKRP.size(),'Trwa analiza danych w okresie rozliczeniowym.'@,,,1);
   {!
   |? _dalej:=exec('jestWyk','okres',_p_ref,A_OKRP.OD,A_OKRP.DO);
      FUN.prg_next();
      _dalej & A_OKRP.next()
   !};
   FUN.prg_stop()
?};
A_OKRP.cntx_pop();
P.cntx_pop();
{? ~_dalej
|| FUN.emsg('Współpracownicy mają zarejestrowane wykonanie w tym okresie.'@+'\n'+
            'Zmiana kalendarzy współpracowników po zarejestrowaniu wykonania nie wpłynie\n'
            'na dokonaną już kwalifikację godzin.'@+'\n'+
            'Do zmiany kalendarzy współpracowników zalecane jest użycie mechanizmu\n'
            'korekty planu dostępnego na portalu pracowniczym.'@)
?};

{? {? _a
   || FUN.ask('%1\n%2'['Wybrany okres zostanie odblokowany do planowania.'@,'Kontynuować?'@])
   || 1
   ?}
|| A_OKR.S_PLAN:='O';
   A_OKR.put()
?};
~~


\zamk_okr_plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.02]
:: OPIS: Akcja zablokowanie/odblokowanie okresu rozliczeniowego do planowania.
::   WE: _a - [INTEGER] (1/0) wyświetlenie komunikatu o zablokowaniu planowania w miesiącu.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? ~(var_pres('_a')=type_of(0)) || _a:=1 ?};

{? exec('otwarty','okres')
|| {? A_OKR.S_PLAN='Z'
   || exec('a_okr_wer_bflo','okres',_a)
   || exec('a_okr_wer_bflz','okres',_a)
   ?}
?}


\zam_msc_plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja zamykająca/otwierająca planowanie dla wybranego miesiąca okresu rozliczeniowego wskazanego pracownika.
::       Jeżeli nie będzie podanego roku i miesiąca to zostaną otwarte wszystkie miesiące w okresie rozliczeniowym.
::   WE: _a - [REFERENCE] - wskazanie na pracownika w okresie rozliczeniowym (A_OKRP)
::       _b - [NUMBER] - rok
::       _c - [NUMBER] - miesiąc
::       [_d] - [NUMBER] - czy akcja grupowa (domyślnie nie)
::       [_e] - [STRING] - status dla miesiąca
::       [_f] - [NUMBER] - czy wymuszone przepisywanie z bufora planowania do kalendarza (domyślnie nie)
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_a_okrp:={? var_pres('_a')=type_of(null()) || _a || return(0) ?};
_rok:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_msc:={? var_pres('_c')=type_of(0) || _c || 0 ?};
_grp:={? var_pres('_d')=type_of(0) || _d || 0 ?};
_status:={? var_pres('_e')=type_of('') || _e || '' ?};
_force:={? var_pres('_f')=type_of(0) || _f || 0 ?};
_res:=1;
P.cntx_psh();
A_OKR.cntx_psh();
A_OKRP_M.cntx_psh();
A_OKRP_M.index('A_OKRPM');
A_OKRP.cntx_psh();
A_OKRP.clear();
{? A_OKRP.seek(_a_okrp)
|| _dalej:=1;
   {? A_OKRP.S_PLAN='X'
   || _dalej:=0;
      {? ~_grp
      || FUN.info('Okres rozliczeniowy pracownika jest przeniesiony do rozliczenia.'@+'\n'
                  'Otwarcie planowania nie jest możliwe.'@)
      ?}
   ?};
   _p_ref:=A_OKRP.P;
   {? _rok=0 & _msc=0
   || A_OKRP_M.prefix(_a_okrp)
   || A_OKRP_M.prefix(_a_okrp,_rok,_msc)
   ?};
   {? _dalej & A_OKRP_M.first()
   || {!
      |? {? A_OKRP_M.STATUS<>'X'
         || _rok:=A_OKRP_M.ROK;
            _msc:=A_OKRP_M.MSC;
            _data_od:=date(_rok,_msc,1);
            _data_do:=date(_rok,_msc,0);
            {? _data_od<A_OKRP.OD || _data_od:=A_OKRP.OD ?};
            {? _data_do>A_OKRP.DO || _data_do:=A_OKRP.DO ?};
            {? (_status='' & A_OKRP_M.STATUS='Z') | _status='O'
            ||
::       otwieramy planowanie w miesiącu dla pracownika
::       sprawdzenie czy nie ma juz wprowadzonego wykonania
               _dalej:=exec('jestWyk','okres',_p_ref,_data_od,_data_do);
               {? ~_dalej & ~_grp
               || FUN.emsg('Pracownicy mają zarejestrowane wykonanie w tym miesiącu.\n\n'
                           'Zmiana kalendarzy pracowników po zarejestrowaniu wykonania,\n'
                           'nie wpłynie na dokonaną już kwalifikację godzin.\n\n'
                           'Do zmiany kalendarzy pracowników zalecane jest użycie mechanizmu\n'
                           'korekty planu, dostępnego na portalu pracowniczym.'@)
               ?};
               {? _grp | FUN.ask('Wybrany miesiąc pracownika zostanie otwarty do planowania.'@+'\n'+'Kontynuować?'@)
               ||
::          okreslenie statusu dla otwieranego miesiaca
                  {? _status=''
                  || _status:=exec('status4OpenPlan','okres',_rok,_msc);
                     {? _status='K'
                     || _powod:='Miesiąc odblokowany w aplikacji desktop przez użytkownika: '+OPERATOR.USER().KOD;
                        exec('korekta_start','kal_korn',,_p_ref,A_OKRP.OKR,_powod,,_rok,_msc)
                     ?}
                  ?};
                  {? exec('setStatusM_Plan','okres',A_OKRP.ref(),_rok,_msc,_status)
                  || A_OKRP.S_PLAN:='O';
                     A_OKRP.put();
                     _res:=1
                  || _res:=0
                  ?}
               || _res:=0
               ?}
            ||
::             zamykamy planowanie w miesiącu dla pracownika
               {? _grp | FUN.ask('Czy zakończyć planowanie pracownika w wybranym miesiącu?'@)
               || _korekta:=(A_OKRP_M.STATUS='K');
                  _open:=exec('getStatusM_Plan','okres',A_OKRP.ref(),_rok,_msc)<>'Z';
               {? _open | _force
                  || {? exec('save2kal','grafik',_p_ref,_data_od,_data_do,_korekta,A_OKRP.OKR)
                     || {? exec('setStatusM_Plan','okres',A_OKRP.ref(),_rok,_msc,'Z')
                        ||
::                         aktualizuj bufor grafikow
                           _mydo:=do_state()=0;
                           {? _mydo || do() ?};
                           {? A_OKRP.P().GRAFIK='T'
                           || exec('del_plan','grafik',_p_ref,_data_od, _data_do,'G',A_OKRP.OKR);
                              exec('dodaj_do_buff','grafik',
                                 'G',_p_ref,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,0,1,_data_od,_data_do
                              )
                           ?};
                           {? _mydo || end() ?};
                           _res:=1
                        || _res:=0
                        ?}
                     || _res:=0
                     ?}
                  || _res:=1
                  ?};
                  {? exec('canCloseOkrPrac','okres',A_OKRP.ref())
                  || {? A_OKRP.S_PLAN<>'X'
                     || A_OKRP.S_PLAN:='Z';
                        A_OKRP.put()
                     ?}
                  ?}
               || _res:=0
               ?}
            ?}
         ?};
         A_OKRP_M.next()
      !}
   ?}
?};
A_OKRP.cntx_pop();
A_OKRP_M.cntx_pop();
A_OKR.cntx_pop();
P.cntx_pop();
_res


\nad_norma_prac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.10]
:: OPIS: Wyliczenie normy okresowej dla pracownika.
::   WE: [_a] - wymiar
::       [_b] - dopelnienie
::       [_c] - poczatek
::       [_d] - koniec
::   WY: ponadnormatywny czas pracy [REAL]
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0)
|| _wym:=_a
|| _wym:=exec('zhist','okres','WY',A_OKRP.DO)
?};

{? var_pres('_b')=type_of(0)
|| _dop_st:=_b
|| _dop_st:=exec('zhist','okres','DOP_ST',A_OKRP.DO)
?};
_OD:={? var_pres('_c')=type_of(date) || _c || A_OKRP.OD ?};
_DO:={? var_pres('_d')=type_of(date) || _d || A_OKRP.DO ?};

_wyn:=0;
: od faktycznie przepracowanych w danym okresie rozliczeniowym godzin pracy odejmuje się liczbę godzin pracy
: planowanych na dany okres rozliczeniowy
_norma:=A_OKRP.NORMA-A_OKRP.P_NIEOB;
{? _norma<*0 || _norma:=*0 ?};

:: ustalenie liczby godzin wg normy dla pelnego zatrudnienia na podstawie kalendarza standard
_kal_naz:=__KAL.nazwa;
_kal_rok:=__KAL.rok;
__KAL.set_cal('standard',_DO);
_norma_w:=__KAL.w_hours(_OD,_DO);
__norm_s:=__KAL.w_hours(_OD,_DO)*_wym;
:: przywrocenie kalendarza pracownika
__KAL.set_cal(_kal_naz,_kal_rok);
__norm_p:=__KAL.w_hours(_OD,_DO);

{? A_OKRP.PRZEP-A_OKRP.N_DOBA>_norma
|| _praca:=A_OKRP.PRZEP-_norma;
:  od tak uzyskanego wyniku odejmuje się liczbę godzin, które powstały z tytułu pracy w godzinach nadliczbowych
:  wynikających z przekroczenia dobowego wymiaru czasu pracy (lub jego przedłużonego wymiaru),
   _praca:=_praca-A_OKRP.N_DOBA;
:  otrzymana w ten sposób liczba godzin pracy wyraża liczbę godzin nadliczbowych powstałych
:  z tytułu przekroczenia przeciętnie tygodniowych norm czasu pracy.
   {? _praca>*0
   || _praca:=*_praca/60$2; _godz:=0;
      {? _wym<>1 & _dop_st
      ||
::       wymiar czasu pracy – liczba godzin równa liczbie tygodni w okresie rozliczeniowym = limit godzin ponadwymiarowych,
::          którego przekroczenie uprawnia do dodatku 100% do wynagrodzenia
::
::          Przykład:
::       W okresie 3-miesięcznym wymiar czasu pracy wynosi 496 godzin i przypada 12 tygodni, a pracownik jest zatrudniony na ½ etatu.
::
::          496 godzin – 12 godzin = 484 godziny
::          ½ etatu = 248 godzin
::      Godziny od 249 do 484 płatne bez dodatku jako godziny ponadwymiarowe, a godziny od 485 do 496 płatne z dodatkiem 100%.
::          Powyżej 496 nadgodziny.

::          liczba dni kal w okresie
         _licz_dni_kal:=_DO-_OD+1;
::          liczba tygodni
         _licz_tyg:=_licz_dni_kal%7;
::          wyliczenie wartosci dopelnienia
         {? exec('test_par','parametr',316,'T')
         || _dop_ile:=_licz_tyg*_dop_st;
            _dop_st:={? _dop_ile>_praca || _praca || _dop_ile ?}
         ?};
         _norma_w:=_norma_w-(*A_OKRP.NORMA/60$2);
         {? _praca>_norma_w
         || _godz:=_praca-_norma_w;
            _praca-=_godz
         ?};
         {? _praca>_dop_st
         || __H_norm:=_praca-_dop_st;
            _praca-=__H_norm
         ?};
::       obsluga nadplanowania czasu pracy dla osoby zwolnionej
         {? A_OKRP.DO<A_OKR.DO
         || {? __norm_p>__norm_s
            || _64:=exec('zlicz_64','okres',_OD,_DO);
               _64:=(*_64/60$2);
               {? __H_norm>_64
               || __wyn_d:=__H_norm-_64;
                  __H_norm-=__wyn_d
               ?};
               _praca-=_64;
               {? _praca>0
               || __H_pnd:=_praca;
                  _praca:=0
               ?}
            ?}
         ?};
         {? _dop_st<=0
         || _godz:=_praca
         ?}
      |? _wym<>1
      || _norma_w:=_norma_w-(*A_OKRP.NORMA/60$2);
         {? _praca>_norma_w
         || _godz:=_praca-_norma_w
         ?}
      || _64:=exec('zlicz_64','okres',_OD,_DO,1);
         _64:=(*_64/60$2);
         {? _64>=_praca
         || __H_norm:=_praca;
            _praca:=0
         || __H_norm:=_64;
            _praca-=_64
         ?};
         _godz:=_praca
      ?};
      _wyn:=_godz
   ?}
|| __bez_n:=*(_norma-(A_OKRP.PRZEP-A_OKRP.N_DOBA))/60$2
?};
_wyn


\oblicz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [2006]
:: OPIS: Funkcja wylicza liczbę godzin przepracowanych przez współpracownika w danym okresie.
::       Doliczana jest rownież liczba godzin nieobecności. Akcja grupowa.
::   WE: _a - [INTEGER] - (1) funkcja wołana z formuły godziny.fml, (0) formuła wykorzystana do rozliczania czasu pracy
::       _b - [INTEGER] - dodatkowe wyliczenie podczas zamknięcia okresu
::       [_c] - [INTEGER] - dodatkowe wyliczenie podczas zamknięcia miesiąca
::       [_d] - [DATE] - data początku okresu - jeżeli nie jest podana to A_OKRP.OD
::       [_e] - [DATE] - data końca okresu - jeżeli nie jest podana to A_OKRP.DO
::       [_f] - [INTEGER] - (1*) wyliczanie norm wg podanego zakresu, (0) wyliczanie norm wg dat A_OKRP
::   WY: ilosć godzin 58 - potrzebne przy przeliczeniu 64 na 65 podczas zamknięcia miesiąca
::----------------------------------------------------------------------------------------------------------------------
_a:={? var_pres('_a')=1 || _a || 0 ?};
_b:={? var_pres('_b')=1 || _b || 0 ?};
_grupa:={? var_pres('grupa')>0 || 1 || 0 ?};
_zamk_mc:={? var_pres('_c')=1 || _c || 0 ?};
_od:={? var_pres('_d')=type_of(#0) || _d || A_OKRP.OD ?};
_do:={? var_pres('_e')=type_of(#0) || _e || A_OKRP.DO ?};
_normMode:={? var_pres('_f')=type_of(0) & _f=0 || _f || 1 ?};
:: Daty wykorzystywane do wyliczenia norm współpracownika (domyślnie wg podanego zakresu)
_normOd:={? _normMode || _od || A_OKRP.OD ?};
_normDo:={? _normMode || _do || A_OKRP.DO ?};

_wyn:=*0;
{? ~_grupa
|| R.index('RUBKOD');
   R.prefix();
   R_KWGODZ.cntx_psh();
   R_PRACDN.cntx_psh()
?};
P.cntx_psh();
P.clear();
P.seek(A_OKRP.P);
{? P.KAL
|| __KAL.set_cal(P.KAL().NAZWA,_normOd~1)
|| __KAL.set_cal('standard')
?};
_t_odb:=time(0,0,0);
{? ~_a
|| {? ~_grupa
   || _KWAL:=exec('tab_create','prc_rozlicz');
      _KWKK:=exec('kwkk_create','prc_rozlicz');
      _PZD:=exec('pzd_create','prc_rozlicz')
   ?};
   params_set('KWAL',_KWAL,'KWKK',_KWKK,'PZD',_PZD);
   exec('kwal_zdalnie','prc_rozlicz',_od,_do);
   _ODB:=sql('select OG from :_a where OG<>to_time(\'0:0:0\')',_KWAL);
   {? _ODB.first
   || {!
      |? _t_odb+=_ODB.OG;
         _ODB.next()
      !}
   ?};
   obj_del(_ODB);
   _data_od:=_od;
   _data_do:=_do;
   _popokr:=exec('prz_okr','prc_rozlicz',_data_od-1);
   {? _popokr
   || A_OKRP.cntx_psh();
      A_OKRP.index('A_OKRDP');
      A_OKRP.prefix(P.ref());
:: dzień należy do poprzedniego okresu rozliczeniowego
      {? A_OKRP.find_le(_data_od-1)
      || _tab_tmp:=_KWAL;
         {? var_pres('_KWAL')>100 || &_KWAL ?};
         {? var_pres('_KWKK')>100 || &_KWKK ?};
         {? var_pres('_PZD')>100 || &_PZD ?};
         _PZD:=exec('pzd_create','prc_rozlicz');
         _KWAL:=exec('tab_create','prc_rozlicz');
         _KWKK:=exec('kwkk_create','prc_rozlicz');
:: weryfikacja na ostatni dzień poprzedniego okresu
         params_set('KWAL',_KWAL,'KWKK',_KWKK,'PZD',_PZD);
         exec('kwal_zdalnie','prc_rozlicz',_data_od-1,_data_od-1,_data_od-1);
         {? var_pres('_KWAL')>100 || &_KWAL ?};
         _KWAL:=_tab_tmp
      ?};
      A_OKRP.cntx_pop()
   ?}
||
: wyliczenie odbiorów
   {? var_pres('_KWAL')<100
   || _KWAL:=exec('tab_create','prc_rozlicz');
      {? var_pres('_KWKK')>100 || &_KWKK ?};
      _KWKK:=exec('kwkk_create','prc_rozlicz');
      {? var_pres('_PZD')>100 || &_PZD ?};
      _PZD:=exec('pzd_create','prc_rozlicz');
      {? P.KAL
      || __KAL.set_cal(P.KAL().NAZWA,_od~1)
      || __KAL.set_cal('standard')
      ?};
      _par:=obj_new('rozn','od','do');
      _par.od:=_od;
      _par.do:=_do;
      _par.rozn:=exec('roznica','prc_rozlicz',_od,_do);
      params_set('KWAL',_KWAL,'KWKK',_KWKK,'PZD',_PZD,'par',_par);
      exec('licz_tab','prc_rozlicz',_od,1)
   ?};
   _ODB:=sql('select OG from :_a where OG<>to_time(\'0:0:0\')',_KWAL);
   {? _ODB.first()
   || {!
      |? _t_odb+=_ODB.OG;
         _ODB.next()
      !}
   ?};
   obj_del(_ODB)
?};
_nominal:=0;
_kal:=sql(
   'select H.OD OD, H.DO DO, H.WY WY, H.WYL WYL, H.WYM WYM '
   'from H_ZM join H join P '
   'where H.P=:_a and H.OD<=to_date(:_c) and (to_date(:_b)<=H.DO or H.DO is null) '
   'order by 1',
   P.ref(),_normOd,_normDo
);

{? _kal.first()
|| {!
   |? _wy:=_kal.WY;
      _kal_do:=_kal.DO;
      _kal.cntx_psh();
      {? _kal.next()
      || {? _kal.WY=_wy
         || _kal_do:=_kal.DO;
            _kal.del()
         ?}
      ?};
      _kal.cntx_pop();
      {? _kal.DO<>_kal_do
      || _kal.DO:=_kal_do;
         _kal.put();
         _kal.first()
      || _kal.next()
      ?}
   !}
?};

{? _kal.first()
|| {!
   |? _nominal+=
         exec('wymiar_prac','okres',
            {? _kal.OD<_normOd || _normOd || _kal.OD ?},
            {? _kal.DO>_normDo | _kal.DO=#0 || _normDo || _kal.DO ?},
            _kal.WYL,
            _kal.WYM
         );
      _kal.next()
   !}
?};
obj_del(_kal);

_NBS:=exec('nieobecnosc','prc_rozlicz',P.ref(),_normOd,_normDo);
_nieob:=_obniz:=0;
{? _NBS.first()
|| {!
   |? {? _NBS.RN=1
      || _obniz+=_NBS.G
      || _nieob+=_NBS.G
      ?};
      _NBS.next()
   !}
?};

R_ODP.index('PRAC');
_praca:=_nadg:=_swieto:=time(0,0,0);
_miesiace:=exec('roznica','prc_rozlicz',_normOd,_normDo);
{! _ind:=0.._miesiace
|! _rok:=date(_normDo~1,(_normDo~2)-_ind,1)~1;
   _msc:=date(_normDo~1,(_normDo~2)-_ind,1)~2;
   MASK.Use('R_PRACDN',_rok,_msc);
   MASK.Use('R_KWGODZ',_rok,_msc);
   R_WYK.cntx_psh();
   R_WYK.index('R_WYKDN');
   R_KWGODZ.clear();
   R_KWGODZ.index('DATA_RUB');
   R_PRACDN.clear();
   R_PRACDN.prefix(P.ref());
   {? R_PRACDN.first()
   || {!
      |? {? R_PRACDN.DT>=_normOd & R_PRACDN.DT<=_normDo
         || _ok:=1;
            _nadg1:=_odprac:=time(0,0,0);
            R_KWGODZ.prefix(P.ref(),R_PRACDN.DT);
            {? R_KWGODZ.first()
            || R_ODP.prefix(P.ref(),R_PRACDN.DT);
               {? R_ODP.first()
               || {!
                  |? _odprac+=R_ODP.GO;
                     R_ODP.next()
                  !}
               ?};
               {!
               |? {? '54,55,56,58,64,65,68,69'*($R_KWGODZ.KW().RN)
                  || {? R.RN=58
                     || R_WYK.prefix(P.ref,R_PRACDN.DT,R_KWGODZ.KW().RN,R_KWGODZ.KK);
                        _odb:=*0;
                        _odbo:=*0;
                        _wyn+=R_KWGODZ.GODZ;
                        {? R_WYK.first
                        || {!
                           |? _odb+=R_WYK.G;
                              _praca-=R_WYK.G;
                              _wyn-=R_WYK.G;
                              R_WYK.next
                           !}
                        ?};
                        {? _odb=*0 & __KAL.h_days(R_PRACDN.DT,R_PRACDN.DT) || _swieto+=R_KWGODZ.GODZ ?}
                     |? R.RN=65
                     || R_WYK.prefix(P.ref,R_PRACDN.DT,R_KWGODZ.KW().RN,R_KWGODZ.KK);
                        _odb:=*0;
                        _odbo:=*0;
                        {? R_WYK.first
                        || {!
                           |? _odb+=R_WYK.G;
                              _praca-=R_WYK.G;
                              R_WYK.next
                           !}
                        ?};
                        {? _odb=*0 & __KAL.h_days(R_PRACDN.DT,R_PRACDN.DT) || _swieto+=R_KWGODZ.GODZ ?}
                     ?};
                     {? '55,56'*($R_KWGODZ.KW().RN)
                     || R_WYK.prefix(P.ref(),R_PRACDN.DT,R_KWGODZ.KW().RN,R_KWGODZ.KK);
                        _odb:=time(0,0,0);
                        {? R_WYK.first()
                        || {!
                           |? _odb+=R_WYK.G;
                             _praca-=R_WYK.G;
                              R_WYK.next()
                           !}
                        ?};
                        _nadg1:={? R_KWGODZ.GODZ-_odb>*0 || R_KWGODZ.GODZ-_odb || time(0,0,0) ?};
                        {? _odprac>=_nadg1
                        || _odprac-=_nadg1;
                           _nadg1:=time(0,0,0)
                        || _nadg1-=_odprac;
                           _odprac:=time(0,0,0)
                        ?};
                        _nadg+=_nadg1
                     ?};
                     {? '68,69,64'*($R_KWGODZ.KW().RN)
                     || _nadg1:=R_KWGODZ.GODZ;
                        {? _odprac>=_nadg1
                        || _odprac-=_nadg1;
                           _nadg1:=time(0,0,0)
                        || _nadg1-=_odprac;
                           _odprac:=time(0,0,0)
                        ?};
                        {? R_KWGODZ.KW().RN<>64
                        || _nadg+=_nadg1
                        ?}
                     ?};
                     {? R.RN=54 ||_ok:=0 ?};
                     _praca+=R_KWGODZ.GODZ
                  ?};
                  R_KWGODZ.next()
               !}
            ?}
         ?};
         R_PRACDN.next()
      !}
   ?};
   R_WYK.cntx_pop()
!};
{? ~_grupa
|| R_KWGODZ.cntx_pop();
   R_PRACDN.cntx_pop()
?};
:: dodanie odbiorów
_praca+=_t_odb;
:: wyliczenia i normalizacja
_nieob:=*((_nieob*60)$2);
_nominal:=*((_nominal*60)$2);
{? _nominal~3>=30
|| _nominal:=time(_nominal~1,_nominal~2+1,0)
|| _nominal:=time(_nominal~1,_nominal~2,0)
?};
_obniz:=*((_obniz*60)$2);
:: konieczne podczytanie rekordu - mógł zostać zmodyfikowany z webTerma
A_OKRP.get();
:: sumowanie
A_OKRP.NORMA:=_nominal;
A_OKRP.NIEOB:=_obniz;
A_OKRP.PRZEP:=_praca;
_praca+=_nieob;
A_OKRP.NADM:={? _praca>_nominal || _praca-_nominal || time(0,0,0) ?};
A_OKRP.NIED:={? _praca<_nominal || _nominal-_praca || time(0,0,0) ?};
A_OKRP.N_DOBA:=_nadg;
A_OKRP.P_NIEOB:=_nieob;
A_OKRP.SWIETO:=_swieto;
{? ~_zamk_mc || A_OKRP.put() ?};
P.cntx_pop();
_wyn


\akt_plan_m_prac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.41]
:: OPIS: Procedura kasuje zalozone miesiace rozliczeniowe w planowaniu wybiegajace poza okres zatrudnienia pracownika.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
A_OKRP.cntx_psh();
A_OKRP.index('A_OKRDP');
A_OKRP_M.cntx_psh();
A_OKRP_M.index('A_OKRPM');
A_OKRP.prefix(P.ref());
_ok:=0;
{? P.DZ<>#0 & A_OKRP.last()
|| {!
   |? A_OKRP_M.prefix(A_OKRP.ref());
      {? A_OKRP_M.last()
      || {!
         |? {? date(A_OKRP_M.ROK,A_OKRP_M.MSC,0)>date(P.DZ~1,P.DZ~2,0)
            || _ok:=1; A_OKRP_M.del(,1)=3
            || {? A_OKRP_M.STATUS='Z' | A_OKRP_M.STATUS='X'
               || A_OKRP.S_PLAN:='Z'
               || A_OKRP.S_PLAN:='O'
               ?};
               A_OKRP.put(1); 0
            ?}
         !}
      ?};
      A_OKRP.prev() & _ok
   !}
?};
A_OKRP.cntx_pop();
A_OKRP_M.cntx_pop();
_ok


\jest_okres
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [2006]
:: OPIS: Sprawdzenie czy jest zalozony okres.
::   WY: ilosc zalozonych okresow
::----------------------------------------------------------------------------------------------------------------------
__HARM.OKRES


\jestWyk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja sprawdzająca czy jest wykonanie w zakresie podanych dat dla pracownika.
::   WE: _a - [REFERENCE] - wskazanie na pracownika
::       _b - [DATE]      - data poczatkowa
::       _c - [DATE]      - data koncowa
::   WY: 0/1 lub (-1) jeśli błędne parametry
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')=type_of(null()) || _a || return(-1) ?};
_data_od:={? var_pres('_b')=type_of(date()) || _b || return(-1) ?};
_data_do:={? var_pres('_c')=type_of(date()) || _c || return(-1) ?};

R_OPCZYT.cntx_psh();
R_REJ_WW.cntx_psh();
_dzien:=_data_od;
_end:=_data_do;
_dalej:=1;
{!
|? _dalej & (_dzien<=_end)
|! _wewy:=exec('get_wewy','prc_wewy',_dzien,_p_ref);
   {? _wewy.first()
   || _dalej:=0
   ?};
   &_wewy;
   _dzien+=1
!};
R_REJ_WW.cntx_pop();
R_OPCZYT.cntx_pop();
_dalej


\zlicz_64
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.41]
:: OPIS: Procedura ma za zadanie wyliczenie ilości godzin dla składników 64,65,58 w okresie dla pracownika.
::       Wymagany prawidłowy bufor dla A_OKRP oraz P.
::   WE: _a - [date] początek
::       _b - [date] - koniec
::       [_c] - [int] opcjonalnie - jeśli 1 wyliczenie tylko dla 64
::   WY: [time] - ilść godzin
::----------------------------------------------------------------------------------------------------------------------
_ok_64:=var_pres('_c')=type_of(1) & _c;
R_KWGODZ.cntx_psh();
R_WYK.cntx_psh();
R_ODP.cntx_psh();
R_ODP.index('PRAC');
R_WYK.index('R_WYKDN');
_wyn:=*0;
_od:=_a;
_do:=_b;
_m_rok:=_do~1;
_m_mc:=_do~2;
MASK.Use('R_KWGODZ',_m_rok,_m_mc);
R_KWGODZ.index('DATA_RUB');
_date:=_do;
{!
|? _od<=_date
|! _rok:=_date~1;
   _mc:=_date~2;
   {? _rok<>_m_rok | _mc<>_m_mc
   || MASK.Use('R_KWGODZ',_rok,_mc); _m_rok:=_rok; _m_mc:=_mc; R_KWGODZ.index('DATA_RUB')
   ?};
   _64:=*0;
   R_KWGODZ.prefix(P.ref,_date);
   {? R_KWGODZ.first()
   || {!
      |? {? _ok_64
         || {? R_KWGODZ.KW().RN=64
            || _64+=R_KWGODZ.GODZ
            ?}
         || {? R_KWGODZ.KW().RN=64 | R_KWGODZ.KW().RN=58 | R_KWGODZ.KW().RN=65
            || {? (R_KWGODZ.KW().RN=58 | R_KWGODZ.KW().RN=65)
               || _wyn+=R_KWGODZ.GODZ;
                  R_WYK.prefix(P.ref, R_KWGODZ.DZ, R_KWGODZ.KW().RN);
                  {? R_WYK.first()
                  || {! |? _wyn-=R_WYK.G; R_WYK.next() !}
                  ?}
               || _64+=R_KWGODZ.GODZ
               ?}
            ?}
         ?};
         R_KWGODZ.next()
      !};
      {? _64>*0 & var_pres('R_ODP')>100
      || R_ODP.prefix(P.ref,R_KWGODZ.DZ);
         {? R_ODP.first
         || {!
            |? _g_odp:=R_ODP.G;
               {? R_KWGODZ.first()
               || {!
                  |? _kod:=R_KWGODZ.KW().RN;
                     {? (_kod=55 | _kod=56 | _kod=64 | _kod=68 | _kod=69)
                     || {? R_ODP.R_ODN().DW<>R_ODP.DW
                        || {? _kod=64
                           || {? _64>=_g_odp
                              || _64-=_g_odp;
                                 _g_odp:=*0
                              || _g_odp-=_64;
                                 _64:=*0
                              ?}
                           || _czas:=R_KWGODZ.GODZ;
                              {? _czas>=_g_odp
                              || _czas-=_g_odp;
                                 _g_odp:=*0
                              || _g_odp-=_czas
                              ?}
                           ?}
                        ?}
                     ?};
                     R_KWGODZ.next()
                  !}
               ?};
               R_ODP.next()
            !}
         ?};
         {? _64>*0 || _wyn+=_64 ?}
      ?}
   ?};
   _date-=1
!};
R_KWGODZ.cntx_pop();
R_WYK.cntx_pop();
R_ODP.cntx_pop();
_wyn


\wymiar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [2006]
:: OPIS: Wyliczenie wymiaru czasu pracy dla okresu - akcja "wylicz wymiar".
::   WE:
::   WY: 1 - aktualizacja sie udała /0 - aktualizacja sie nie udała
::----------------------------------------------------------------------------------------------------------------------
{? ~exec('otwarty','okres') || return(0) ?};
exec('__KAL','object');

_oWymiar:=exec('wymiar_od_do','okres',A_OKR.OD,A_OKR.DO);
{? _oWymiar.ok
|| _wynik:=(_oWymiar.godz_tyg+_oWymiar.godz_poz_rob-_oWymiar.godz_swiat);
   A_OKR.WYMIAR:=time(_wynik,0,0);
   A_OKR.put()
?}


\wymiar_h
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.41]
:: OPIS: Zwraca tabele z rekordami określającymi zmiany w wymiarze zatrudnienia pracownika w zadanym okresie.
::       Bufor P musi być określony.
::   WE: _a [date]- początek badanego okresu
::       _b [date]- koniec badanego okresu
::   WY: tabela tymczasowa z polami OD, DO, WY, DOP_ST
::----------------------------------------------------------------------------------------------------------------------
_tab:=sql('
   select H.OD, H.DO, H.WY, H.DOP_ST
   from H where H.P=:_a and H.OD<=to_date(:_c) and (H.DO>=to_date(:_b) or H.DO is null)
   order by 1',
   A_OKRP.P,_a,_b);

{? _tab.first()
|| _wym:=0; _od:=_tab.OD;
   {!
   |?  {? _wym=_tab.WY
       || _do:=_tab.DO; _tab.prev(); _tab.DO:=_do; _tab.put(); _tab.next(); _tab.del(,1)=2
       || _wym:=_tab.WY; _tab.next()
       ?}
   !};
   {? _tab.size()=1 || _tab.del() ?}
?};
_tab


\wymiar_prac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.41]
:: OPIS: Wyliczenie wymiaru czasu pracy dla pracownika w okresie.
::   WE: _a - poczatek okresu
::       _b - koniec okresu
::       _c - wymiar etatu licznik
::       _d - wymiar etatu mianownik
::   WY: Wymiar dla podanego okresu
::----------------------------------------------------------------------------------------------------------------------
_norma:=exec('norma','godziny',_b);
_norma*=60;
_oWymiar:=exec('wymiar_od_do','okres',_a,_b,_norma);

: ostateczne wyliczenie
_wynik:=(_oWymiar.godz_tyg+_oWymiar.godz_poz_rob-_oWymiar.godz_swiat);
(_wynik*_c/_d)/60


\oWymiar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [18.02]
:: OPIS: Obiekt pomocniczy służący do wyliczeń w okresie rozliczeniowym
::   WE:
::   WY: obiekt pomocniczy
::----------------------------------------------------------------------------------------------------------------------
_result:=obj_new('ok','dni_kal','tyg','godz_tyg','dni_poz','dni_poz_rob','godz_poz_rob','dni_swiat','godz_swiat');
:: czy udało się wszystko obliczyć poprawnie?
_result.ok:=0;
:: dni kalendarzowe w okresie
_result.dni_kal:=0;
:: liczba tygodni w okresie
_result.tyg:=0;
:: liczba godzin w okresie
_result.godz_tyg:=0;
:: liczba dni wystających poza pełne tygodnie okresu
_result.dni_poz:=0;
:: liczba dni roboczych wystających poza pełne tygodnie okresu
_result.dni_poz_rob:=0;
:: liczba godzin roboczych wystających poza pełne tygodnie okresu
_result.godz_poz_rob:=0;
:: liczba świąt w okresie
_result.dni_swiat:=0;
:: liczba godzin świątecznych
_result.godz_swiat:=0;

_result


\wymiar_od_do
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [18.02]
:: OPIS: Wylicza wymiar pomiędzy datami
::   WE: _a  [DATE]    - data początku
::       _b  [DATE]    - data końca
::      [_c] [INTEGER] - norma dla pełnego wymiaru zatrudnienia
::   WY: obiekt pomocniczy
::----------------------------------------------------------------------------------------------------------------------
_result:=exec('oWymiar','okres');

  _pocz:={? var_pres('_a')=type_of(date) & _a<>#0 || _a || return(_result) ?};
_koniec:={? var_pres('_b')=type_of(date) & _b<>#0 || _b || return(_result) ?};
 _norma:={? var_pres('_c')=type_of(0)             || _c || 8               ?};

exec('__KAL','object');
:: liczba dni kalendarzowych w okresie
_result.dni_kal:=_koniec-_pocz+1;
:: liczba tygodni
_result.tyg:=_result.dni_kal%7;
:: liczba godzin w pełnych tygodniach okresu
_result.godz_tyg:=_result.tyg*5*_norma;
:: liczba pozostałych dni
_result.dni_poz:=_result.dni_kal%*7;
:: wylicz liczbę pozostałych dni i godzin w tygodniu od poniedziałku do piątku (roboczych)
_okresl:=_pocz+(_result.tyg*7);
_robocze:=0;
{!
|? _okresl<=_koniec
|! {? _okresl~4<6 || _robocze+=1 ?};
   _okresl+=1
!};
_result.dni_poz_rob:=_robocze;
:: liczba godzin w pozostałe dni robocze
_result.godz_poz_rob:=_robocze*_norma;

: szukaj swiat
_dzien:=_koniec;
_rok:=_dzien~1;
{? ~__KAL.set_cal('standard',_rok)
|| return(exec('oWymiar','okres'))
?};
_nr_tyg:=1;
_ile_w_tyg:=0;
_ile_swiat:=0;
{! .._result.dni_kal
|! {? _dzien~1<>_rok
   || _rok:=_dzien~1;
      {? ~__KAL.set_cal('standard',_rok)
      || return(exec('oWymiar','okres'))
      ?}
   ?};
   {? _dzien>=date(2014,1,1)
   || _swieto:=(__KAL.h_days(_dzien,_dzien) & _dzien~4<>7);
      _ile_swiat+=_swieto
   |? _dzien>=date(2011,1,1) & _dzien<=date(2013,12,31)
   || _swieto:=(__KAL.h_days(_dzien,_dzien) & _dzien~4<>7 & _dzien~4<>6);
      _ile_swiat+=_swieto
   || _swieto:=(__KAL.h_days(_dzien,_dzien) & _dzien~4<>7);
      {? _swieto
      || {? _ile_w_tyg<>_nr_tyg || _ile_swiat+=1 ?};
         _ile_w_tyg:=_nr_tyg;
         {? _dzien~4=7 || _nr_tyg+=1 ?}
      ?}
   ?};
   _dzien-=1
!};
_result.dni_swiat:=_ile_swiat;
: godziny swiateczne
_result.godz_swiat:=_ile_swiat*_norma;
_result.ok:=1;
_result


\zhist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO
:: OPIS:  Zwraca wartosc pola tabeli H dla pracownika z bufora na date podana argumentem _b.
::   WE: _a - pole tabeli H (np: 'WYDZIAL().SYMBOL')
::       _b - data
::----------------------------------------------------------------------------------------------------------------------
H.cntx_psh();
H.index('_HISTKOD');
H.prefix(P.ref(),'Z');
_wyn:=
   {? H.find_le(_b)
   || ($('H.'+_a))()
   || _num:=type_of(($('H.'+_a))());
      {? _num=5 || time(0,0,0)
      |? _num=4 || date(0,0,0)
      |? _num=3 || "~~"
      |? _num=2 || ''
      |? _num=1 || 0
      || ~~
      ?}
   ?};
H.cntx_pop();
_wyn


\getStatusM_Plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja zwracajaca status dla planowanego miesiaca dla pracownika w okresie (dla A_OKRP_M).
::   WE: _a - [REFERENCE]  - wskazanie na A_OKRP
::       _b - [INTEGER]    - rok
::       _c - [INTEGER]    - miesiac
::   WY:      [STRING]     - status
::----------------------------------------------------------------------------------------------------------------------
_a_okrp:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
   _rok:={? var_pres('_b')=type_of(0)    || _b || 0         ?};
   _msc:={? var_pres('_c')=type_of(0)    || _c || 0         ?};
_res:='';
A_OKRP_M.cntx_psh();
A_OKRP_M.index('A_OKRPM');
A_OKRP_M.prefix(_a_okrp,_rok,_msc);
{? A_OKRP_M.first()
|| _res:=A_OKRP_M.STATUS
?};
A_OKRP_M.cntx_pop();
_res


\setStatusM_Plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja nadająca status dla planowanych miesiecy dla pracownika w okresie (dla A_OKRP_M).
::   WE: _a - [REFERENCE]  - wskazanie na A_OKRP
::       _b - [INTEGER]    - rok
::       _c - [INTEGER]    - miesiac
::       _d - [STRING]     - status
::   WY: 0 lub 1
::----------------------------------------------------------------------------------------------------------------------
_a_okrp:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
   _rok:={? var_pres('_b')=type_of(0)    || _b || 0         ?};
   _msc:={? var_pres('_c')=type_of(0)    || _c || 0         ?};
_status:={? var_pres('_d')=type_of('')   || _d || ''        ?};
{? _status<>'O' & _status<>'Z' & _status<>'K' & _status<>'X' || return(0) ?};

_res:=0;
_loop:=0;
A_OKRP_M.cntx_psh();
A_OKRP_M.index('A_OKRPM');
{? _rok=0 & _msc=0
|| A_OKRP_M.prefix(_a_okrp)
|| A_OKRP_M.prefix(_a_okrp,_rok,_msc)
?};
{? A_OKRP_M.first()
|| {!
   |? {? A_OKRP_M.STATUS<>'X' || A_OKRP_M.STATUS:=_status ?};
      _loop+=1;
      _res+=A_OKRP_M.put();
      A_OKRP_M.next()
   !}
?};
A_OKRP_M.cntx_pop();
_res=_loop


\setMscPlanStat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja nadajaca status planowania dla wybranego miesiaca (dla A_OKRM).
::   WE: _a - [INTEGER] - roku
::       _b - [INTEGER] - miesiac
::       _c - [STRING]  - status planownaia
::   WY: 0/l
::----------------------------------------------------------------------------------------------------------------------
_rok:={? var_pres('_a')=type_of(0) || _a || return(0) ?};
_msc:={? var_pres('_b')=type_of(0) || _b || return(0) ?};
_status:={? var_pres('_c')=type_of('') || _c || '' ?};
_res:=0;
A_OKRM.cntx_psh();
A_OKRM.index('A_OKRMR');
A_OKRM.prefix(_rok,_msc);
{? A_OKRM.first()
|| A_OKRM.S_PLAN:=_status;
   _res:=A_OKRM.put()
?};
A_OKRM.cntx_pop();
_res


\getMscPlanStat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja pobierajaca status planowania dla wybranego miesiaca (dla A_OKRM).
::   WE: _a - [INTEGER] - roku
::       _b - [INTEGER] - miesiac
::   WY: status planowania miesiaml
::----------------------------------------------------------------------------------------------------------------------
_rok:={? var_pres('_a')=type_of(0) || _a || return(0) ?};
_msc:={? var_pres('_b')=type_of(0) || _b || return(0) ?};
_status:='';
A_OKRM.cntx_psh();
A_OKRM.index('A_OKRMR');
A_OKRM.prefix(_rok,_msc);
{? A_OKRM.first()
|| _status:=A_OKRM.S_PLAN
?};
A_OKRM.cntx_pop();
_status


\canClosePlanOkr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja sprawdzajaca czy mozna zamknac okres do planowania - czy wszystkie miesiące okresu są zaplanowane.
::   WE: _a - [REFERENCE] - wskazanie na okres rozliczeniowy A_OKR
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_a_okr:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
exec('isAllMscInOkr','okres',_a_okr,'Z')


\canOpenPlanOkr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja sprawdzajaca czy mozna otworzyc okres do planowania - czy wszystkie miesiące okresu są otwarte.
::   WE: _a - [REFERENCE] - wskazanie na okres rozliczeniowy A_OKR
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_a_okr:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
exec('isAllMscInOkr','okres',_a_okr,'O')


\canCloseOkrPrac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja sprawdzajaca czy mozna zamknac okres do planowania pracownika - czy wszystkie miesiace sa zaplanowane.
::   WE: _a - [REFERENCE]  - wskazanie na A_OKRP
::   WY: 0 lub 1
::----------------------------------------------------------------------------------------------------------------------
_a_okrp:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
_res:=1;
A_OKRP_M.cntx_psh();
A_OKRP_M.index('A_OKRPM');
A_OKRP_M.prefix(_a_okrp);
{? A_OKRP_M.first()
|| {!
   |? {? A_OKRP_M.STATUS<>'Z' & A_OKRP_M.STATUS<>'X'
      || _res:=0
      ?};
      A_OKRP_M.next()
   !}
?};
A_OKRP_M.cntx_pop();
_res


\allPlanned4Msc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja sprawdzajaca czy wszystkie okresy rozliczeniowe, do ktorych nalezy wybrany miesiac.
::       sa zamkniete do planowania.
::   WE: _a - [INTEGER] - rok
::       _b - [INTEGER] - msc
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_rok:={? var_pres('_a')=type_of(0) || _a || return(0) ?};
_msc:={? var_pres('_b')=type_of(0) || _b || return(0) ?};
_closed:=0;
_loop:=0;
_ndx_do:=A_OKR.ndx_tmp('',1,'DO',,);
_msc_od:=date(_rok,_msc,1);
_msc_do:=date(_rok,_msc,0);
A_OKR.cntx_psh();
A_OKR.index(_ndx_do);
A_OKR.prefix();
{? A_OKR.find_ge(_msc_od)
|| {!
   |?
::    sprawdzenie czy poczatek lub koniec miesiaca naleza do zamknietego okresu
      {? ((A_OKR.OD<=_msc_od & A_OKR.DO>=_msc_od) | (A_OKR.OD<=_msc_do & A_OKR.DO>=_msc_do))
      || _loop+=1;
         {? A_OKR.S_PLAN='Z' || _closed+=1 ?}
      ?};
      A_OKR.next()
   !}
?};
A_OKR.ndx_drop(_ndx_do);
A_OKR.cntx_pop();
_closed=_loop


\closeAllM_Plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja zamykajaca wszystkie miesiace do planownaia dla A_OKRP.
::   WE: _a - [REFERENCE]  - wskazanie na A_OKRP
::   WY: 0 lub 1
::----------------------------------------------------------------------------------------------------------------------
_a_okrp:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
exec('setStatusM_Plan','okres',_a_okrp,,,'Z')


\openAllM_Plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja otwierajaca wszystkie miesiace do planownaia dla A_OKRP.
::   WE: _a - [REFERENCE]  - wskazanie na A_OKRP
::   WY: 0 lub 1
::----------------------------------------------------------------------------------------------------------------------
_a_okrp:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
exec('setStatusM_Plan','okres',_a_okrp,,,'O')


\korAllM_Plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja otwierajaca wszystkie miesiace do korekty planownaia dla A_OKRP.
::   WE: _a - [REFERENCE]  - wskazanie na A_OKRP
::   WY: 0 lub l
::----------------------------------------------------------------------------------------------------------------------
_a_okrp:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
exec('setStatusM_Plan','okres',_a_okrp,,,'K')


\status4OpenPlan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja zwracajaca status dla otwieranego miesiaca.
::   WE: _a - [INTEGER] - rok
::       _b - [INTEGER] - miesiac
::   WY:    - [STRING]  - status 'O' (normalne otwarcie) lub 'K'(korekta)
::----------------------------------------------------------------------------------------------------------------------
_status:='O';
_rok:={? var_pres('_a')=type_of(0) || _a || return(_status) ?};
_msc:={? var_pres('_b')=type_of(0) || _b || return(_status) ?};
A_OKRM.cntx_psh();
A_OKRM.index('A_OKRMR');
A_OKRM.prefix(_rok,_msc);
{? A_OKRM.first()
|| {? A_OKRM.S_PLAN='Z' || _status:='K' ?}
?};
A_OKRM.cntx_pop();
_status


\isAllMscInOkr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja sprawdza czy wszystkie miesiaca w okresie rozliczeniowym maja odpowiedni status planowania.
::   WE: _a - [REFERENCE] - wskazanie na okres rozliczeniowy A_OKR
::       _b - [STRING]    - status planowania
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
 _a_okr:={? var_pres('_a')=type_of(null()) || _a || return(0) ?};
_status:={? var_pres('_b')=type_of('')     || _b || return(0) ?};
_loop:=0;
_equal:=0;
A_OKR.cntx_psh();
A_OKR.prefix();
{? A_OKR.seek(_a_okr)
|| A_OKRM.cntx_psh();
   A_OKRM.index('A_OKRMR');
:: sprawdzenie czy wszystkie miesiace dla okresu maja ten sam status
   _rok_od:=A_OKR.OD~1; _msc_od:=A_OKR.OD~2;
   _rok_do:=A_OKR.DO~1; _msc_do:=A_OKR.DO~2;
   _rok:=_rok_od;
   _msc:=_msc_od;
   _dalej:=1;
   {!
   |? _loop+=1;
      A_OKRM.prefix(_rok,_msc);
      {? A_OKRM.first()
      || {? A_OKRM.S_PLAN=_status || _equal+=1 || _dalej:=0 ?}
      ?};
      _msc+=1;
      {? _msc>12 || _rok+=1; _msc:=1 ?};
      _dalej & ((_rok<_rok_do) | (_rok=_rok_do & _msc<=_msc_do))
   !};
   A_OKRM.cntx_pop()
?};
A_OKR.cntx_pop();
_loop=_equal


\isStatMscInOkrp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja sprawdza czy istnieje miesiac w okresie rozliczeniowym pracownika z odpowiednim statusem planowania.
::   WE: _a - [REFERENCE] - wskazanie na okres rozliczeniowy A_OKRP
::       _b - [STRING]    - status planowania
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_a_okrp:={? var_pres('_a')=type_of(null()) || _a || return(0) ?};
_status:={? var_pres('_b')=type_of('')     || _b || return(0) ?};
_equal:=0;
A_OKRP.cntx_psh();
A_OKRP.prefix();
{? A_OKRP.seek(_a_okrp)
||
   A_OKRP_M.cntx_psh();
   A_OKRP_M.index('A_OKRPM');
:: sprawdzenie czy wszystkie miesiace dla okresu maja ten sam status
   _rok_od:=A_OKRP.OD~1; _msc_od:=A_OKRP.OD~2;
   _rok_do:=A_OKRP.DO~1; _msc_do:=A_OKRP.DO~2;
   _rok:=_rok_od;
   _msc:=_msc_od;
   _dalej:=1;
   {!
   |? A_OKRP_M.prefix(_a_okrp,_rok,_msc);
      {? A_OKRP_M.first()
      || {? A_OKRP_M.STATUS=_status || _equal+=1; _dalej:=0 ?}
      ?};
      _msc+=1;
      {? _msc>12 || _rok+=1; _msc:=1 ?};
      _dalej & ((_rok<_rok_do) | (_rok=_rok_do & _msc<=_msc_do))
   !};
   A_OKRP_M.cntx_pop()
?};
A_OKRP.cntx_pop();
_equal


\getPracInOkr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Funkcja zwraca tabelę z współpracownikami z podanym statusem planowania.
::   WE: _a - [REFERENCE] - ref okresu rozliczeniowego A_OKR.ref
::       _b - [STRING] - status z jakimi pracownicy mają być pobrani
::       _c - [STRING] - 'T' / 'N' / '' - zaznaczeni do planowania, nie zaznaczeni do planowania
::                       lub wszyscy (domyślnie wszyscy)
::       _d - [TABLE] - tabela z pracownikami - nie jest sprawdzana zgodność schematu tabeli
::   WY: tabela z listą pracowników
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_d')=type_of(SYSLOG)
|| _tab:=_d
|| _tab:=tab_tmp(2,
      'NAZWISKO','STRING[30]','Nazwisko pracownika',
      'IMIE','STRING[20]','Imię pracownika',
      'P_REF','STRING[16]','Wskazanie na pracownika',
      'A_OKRP','STRING[16]','Wskazanie na pracownika w okresie',
      'WYDZIAL','STRING[16]','Wydział',
      'T','STRING[9]','Nr teczki',
      'PLAN','STRING[1]', 'Status planowania',
      'OD','DATE', 'Od',
      'DO','DATE', 'Do',
      'SZEF','STRING[60]','Przełożony',
      'SZEF_REF','STRING[16]','Wskazanie na przełożonego'
   )
?};
_okr_ref:={? var_pres('_a')<>type_of(null()) || return(_tab) || _a ?};
_status:={? var_pres('_b')<>type_of('') || return(_tab) || _b ?};
_grafik:={? var_pres('_c')<>type_of('') || '' || _c ?};

A_OKR.cntx_psh();
A_OKR.clear();
A_OKRP.cntx_psh();
_ndx:=A_OKRP.ndx_tmp(,,'OKR',,,'S_PLAN',,,'S_PLAN',,);
{? _ndx<>''
|| A_OKRP.index(_ndx);
   {? A_OKR.seek(_okr_ref)
   || A_OKRP.prefix(_okr_ref,_status,_status);
      {? A_OKRP.first()
      || {!
         |? {? _grafik=A_OKRP.P().GRAFIK | _grafik=''
            || _tab.blank(1);
               _tab.WYDZIAL:=P.WYDZIAL().SYMBOL;
               _tab.T:=P.T;
               _tab.P_REF:=$P.ref();
               _tab.A_OKRP:=$A_OKRP.ref();
               _tab.NAZWISKO:=P.OSOBA().NAZWISKO;
               _tab.IMIE:=OSOBA.PIERWSZE;
               _tab.PLAN:=A_OKRP.S_PLAN;
               _tab.OD:=A_OKRP.OD;
               _tab.DO:=A_OKRP.DO;
               _szef:=exec('prac_nad','stanprac',P.ref(),0,'TYPPOZ','PLANCZP',,1);
               {? _szef.first()
               || _tab.SZEF:=_szef.IMIE + ' ' + _szef.NAZWISKO;
                  _tab.SZEF_REF:=_szef.P_SQL
               ?};
               {? var_pres('_szef')> 100 || obj_del(_szef) ?};
               _tab.add()
            ?};
            A_OKRP.next()
         !}
      ?}
   ?};
   A_OKRP.ndx_drop(_ndx)
?};
A_OKRP.cntx_pop();
A_OKR.cntx_pop();
_tab


\error_plan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.10]
:: OPIS: Akcja ustawienia statusu błędów planowania w okresie rozliczeniowym.
::   WE: _a - możliwe błędy [T/N]
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? A_OKR.S_PLAN='Z' | A_OKR.S='Z'
|| FUN.emsg('Status planu lub zamknięcia jest ustawiony jako: "Zamknięty".\n'@+
            'Wykonanie wybranej akcji jest niemożliwe.'@);
   return(0)
?};
_ok:=0;
{? _a='N'
|| {? FUN.ask('Czy na pewno zablokować możliwość akceptacji planu z błędami?'@)
   || _ok:=1;
      _error:='N'
   ?}
|| {? FUN.ask('Czy na pewno umożliwić akceptację planu z błędami?'@)
   || _ok:=1;
      _error:='T'
   ?}
?};
{? _ok || A_OKR.ER:=_error; A_OKR.put(1) ?}


\gen_tab_error
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.30]
:: OPIS: Tworzy tabelę _error.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
tab_tmp(2,
   'NAZWISKO','STRING[30]','Nazwisko',
   'IMIE','STRING[20]','Imię',
   'IP','INTEGER','Identyfikator',
   'OPIS','STRING[255]','Opis'
)


\spr_kal_rok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.10]
:: OPIS: Sprawdzenie wzorca kalendarza i zapisanie błędów do tabeli.
::   WE: _a - P.ref
::       _b - alias tabeli z błędami
::       _c - początek okresu
::       _d - koniec okresu
::   WY: 1 - ok
::       0 - błąd
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null()) || return(0) ?};
{? var_pres('_b')<>type_of(SYSLOG) || return(0) ?};
{? var_pres('_c')<>type_of(#0) || return(0) ?};
{? var_pres('_d')<>type_of(#0) || return(0) ?};
_od:=_c;
_do:=_d;
{? _od=#0 | _do=#0 || return(0) ?};
{? P.seek(_a) & P.DZA<=_d & (P.DZ=#0 | P.DZ>=_c)
|| _ret_val:=1;
   _nazwa:='';
   KAL_ROK.index('KAL_ROK');
   KAL_ROK.prefix();
   R_WZCZ.index('R_WZWND');
   R_WZCZ.prefix(form(8+$_a),#_a,'N','N');
   _ind:=0;
   {!
   |? {? R_WZCZ.find_le(_do)
      || {? _nazwa<>R_WZCZ.KAL().NAZWA
         || _nazwa:=R_WZCZ.KAL().NAZWA;
            {? ~KAL_ROK.find_key(R_WZCZ.KAL,_do~1)
            || _b.OPIS:='Brak kalendarza: "'+_nazwa+'" w roku: '+$(_do~1);
               _b.NAZWISKO:=P.OSOBA().NAZWISKO;
               _b.IMIE:=P.OSOBA().PIERWSZE;
               _b.IP:=P.IP;
               {? ~_b.find_rec()
               || _b.add()
               ?};
               _ret_val:=0
            ?}
         ?}
      ?};
      _ind+=1;
      _do:=_do-_ind;
      (_ret_val<>0) & (_do>=_od)
   !};
   _ret_val
|| 0
?}


\przypisz_prac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.10]
:: OPIS: Przypisanie pracownikow do okresu.
::   WE: _a - tabela z współpracownikami
::       _b - tabela błędów
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? _a.first()
|| A_OKRP.cntx_psh();
   A_OKRP.prefix();
   FUN.prg_start(_a.size(),,,,1);
   {!
   |? {? P.seek(_a.P,) & P.DZA<=_a.DO & (P.DZ=#0 | P.DZ>=_a.OD)
      || FUN.prg_next();
         A_OKRP.blank();
         A_OKRP.OKR:=__HARM.OKR_REF;
         A_OKRP.P:=P.ref();
         A_OKRP.OSOBA:=P.OSOBA;
         A_OKRP.OD:={? P.DZA<_a.OD || _a.OD || P.DZA ?};
         A_OKRP.DO:={? P.DZ<_a.DO || {? P.DZ=#0 || _a.DO || P.DZ ?} || _a.DO ?};
         A_OKRP.OKR().ref();
         {? exec('spr_a_okrp','okres',P.ref(),_b,A_OKRP.OD,A_OKRP.DO,A_OKRP.OKR) & A_OKRP.add(1)
         || exec('oblicz','okres',0);
            exec('dodaj_do_buff','grafik','P',A_OKRP.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,2);
            exec('dodaj_do_buff','grafik','G',A_OKRP.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,2);
            exec('dodaj_do_buff','grafik','W',A_OKRP.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,2);
            exec('endPl4ClMonth','okres',A_OKRP.ref())
         ?}
      ?};
      _a.next()
   !};
   A_OKRP.cntx_pop();
   FUN.prg_stop()
|| FUN.emsg('Brak rekordów spełniających kryteria.'@)
?}


\endPl4ClMonth
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Zapisuje do kalendarza bufor planowania dla zamkniętych miesięcy w okresie.
::   WE: _a - [REFERENCE] - wskazanie na A_OKRP
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_a_okrp:={? var_pres('_a')=type_of(null) || _a || return(_result) ?};
_a_okr:=null();
A_OKR.cntx_psh();
A_OKRP.cntx_psh();
A_OKRP.prefix();
{? A_OKRP.seek(_a_okrp)
|| _a_okr:=A_OKRP.OKR;
   {? var_pres('S_PLAN',A_OKRM)<0
   || {? A_OKRP.S_PLAN='Z'
      || _result:=exec('save2kal','grafik',A_OKRP.P,A_OKRP.OD,A_OKRP.DO,0,A_OKRP.OKR)
      ?}
   || _rok_od:=A_OKRP.OD~1;
      _msc_od:=A_OKRP.OD~2;
      _rok_do:=A_OKRP.DO~1;
      _msc_do:=A_OKRP.DO~2;
      _rok:=_rok_od;
      _msc:=_msc_od;
      _result:=1;
      A_OKRM.cntx_psh();
      A_OKRM.index('A_OKRMR');
      {!
      |? A_OKRM.prefix(_rok,_msc);
         {? A_OKRM.first()
         || {? A_OKRM.S_PLAN='Z'
            || _result*=exec('zam_msc_plan','okres',_a_okrp,_rok,_msc,1,'Z',1)
            ?}
         ?};
         _msc+=1;
         {? _msc>12 || _rok+=1; _msc:=1 ?};
         ((_rok<_rok_do) | (_rok=_rok_do & _msc<=_msc_do))
      !};
      A_OKRM.cntx_pop()
   ?}
?};
A_OKRP.cntx_pop();
A_OKR.cntx_pop();
_result


\spr_a_okrp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Sprawdza czy sią nakładają dni w okresach rozliczeniowych dla pracownika.
::   WE: _a - P.ref
::       _b - alias tabeli z błędami
::       _c - początek okresu
::       _d - koniec okresu
::       _e - A_OKR.ref
::   WY: 1 - ok
::       0 - błąd
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null()) || return(0) ?};
{? var_pres('_b')<>type_of(SYSLOG) || return(0) ?};
{? var_pres('_c')<>type_of(#0) || return(0) ?};
{? var_pres('_d')<>type_of(#0) || return(0) ?};
{? var_pres('_e')<>type_of(null()) || return(0) ?};
_od:=_c;
_do:=_d;
_or_ref:=_e;
_error:=0;
_ret_val:=0;
_text:='';
{? _od=#0 | _do=#0 || return(0) ?};
P.cntx_psh();
P.prefix();
{? P.seek(_a) & P.DZA<=_d & (P.DZ=#0 | P.DZ>=_c)
|| _ret_val:=1;
   A_OKR.cntx_psh();
   A_OKRP.cntx_psh();
   A_OKRP.index('A_OKRDP');
   A_OKRP.prefix(P.ref());
   {? A_OKRP.first()
   || _dalej:=1;
      {!
      |? {? A_OKRP.OKR<>_or_ref & (A_OKRP.DO>=_od) & (A_OKRP.OD<=_do)
         || _error:=1;
            _text:=A_OKRP.OKR().NAZ().NAZ+' od '+$A_OKRP.OD+' do '+$A_OKRP.DO;
            _dalej:=0
         ?};
         _dalej & A_OKRP.next()
      !}
   ?};
:: czy są błędy
   {? _error
   || _b.OPIS:='Pracownik przypisany jest już do okresu: '+_text;
      _b.NAZWISKO:=P.OSOBA().NAZWISKO;
      _b.IMIE:=P.OSOBA().PIERWSZE;
      _b.IP:=P.IP;
      {? ~_b.find_rec()
      || _b.add()
      ?};
      _ret_val:=0
   ?};

:: sprawdzenie czy sa założone kalendarze w zakresie przypisania do okresu
   {? ~_error
   || _errorobl:={? var_pres('errorobl')>0 || errorobl || ~~ ?};
      errorobl:=1;
      _rok:=_od~1;
      _graf_wzor:=exec('get_graf_wzor','grafik',P.ref(),_od);
      _ret_val:=__KAL.set_cal(_graf_wzor,_rok);
      {? _ret_val
      || _rok:=_do~1;
         _graf_wzor:=exec('get_graf_wzor','grafik',P.ref(),_do);
         _ret_val:=__KAL.set_cal(_graf_wzor,_rok)
      ?};
      {? _ret_val || _ret_val:=__KAL.filled(_od,_do) ?};

      {? var_pres('_errorobl')>0 || errorobl:=_errorobl || &errorobl ?};
      {? ~_ret_val
      || _b.OPIS:='Brak danych dla kalendarza wzorcowego "'+_graf_wzor+'" na rok '+$_rok+'.';
         _b.NAZWISKO:=P.OSOBA().NAZWISKO;
         _b.IMIE:=P.OSOBA().PIERWSZE;
         _b.IP:=P.IP;
         {? ~_b.find_rec()
         || _b.add()
         ?}
      ?}
   ?};

   A_OKRP.cntx_pop();
   A_OKR.cntx_pop()
?};
P.cntx_pop();
_ret_val


\a_okrp_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.28]
:: OPIS: Formuła przed usunięciem pracownika z okresu.
::   WE:
::   WY: 0 lub 1
::  OLD: \usun_p/okres.fml
::----------------------------------------------------------------------------------------------------------------------
_sel_size:=P.sel_size();

_choice:=$("FUN.multichoice('"+
   'Czy usunąć %1 z okresu rozliczeniowego?\n\n'
   'Podczas usuwania pracownika z okresu rozliczeniowego dodatkowo zostaną usunięte:'@
   [{? _sel_size>1 || 'pracowników'@ || 'pracownika'@ ?}]+"'
   ,'&Tak'@,'&Nie'@,,11
   ,'"+'text=%1;selected=N'['Dane z warstwy planowania'@]+"'
   ,'"+'text=%1;selected=N'['Dane z warstwy grafików'@]+"'
   ,'"+'text=%1;selected=N'['Niezatwierdzone wykonania'@]+"'
   ,'"+'text=%1;selected=N'['Dane dotyczące: wejść/wyjść, przepracowanych dni, kwalifikacji godzin'@]+"'
   ,'"+'text=%1;selected=N'['Dane dotyczące zapisów pierwotnych z czytników'@]+"'
   ,'"+'text=%1;selected=N'['Dane dotyczące zapisów z Portal HR (Start / Stop)'@]+"'
)");

_wyn:=0;

{? _sel_size
|| {? var_pres('__choice')<100 || __choice:=_choice() ?}
|| __choice:=_choice()
?};

{? var_pres('__choice')>100 & (+__choice[1]>0)
|| _del_plan:=+__choice[2]>0;
   _del_graf:=+__choice[3]>0;
   _del_wyk:=+__choice[4]>0;
   _del_kwal:=+__choice[5]>0;
   _del_zp:=+__choice[6]>0;
   _del_ss:=+__choice[7]>0;
   _p_ref:=P.ref();
:: usuwamy planowanie
   exec('usun_z_buff','grafik','P',_p_ref,A_OKRP.OKR,_del_plan);
:: usuwamy grafik
   exec('usun_z_buff','grafik','G',_p_ref,A_OKRP.OKR,_del_graf);
:: usuwamy wykonanie
   exec('usun_z_buff','grafik','W',_p_ref,A_OKRP.OKR,_del_wyk);
   _wyn:=1;
:: usuwamy: dane z czytników, dane z wejść/wyjść, dane z przepracowanych dni,
::          dane opisów błędnych zapisów, dane z kwalifikacji godzin
   {? _del_kwal
   || _wyn:=exec('delDaneRCP4Prac','okres',_p_ref,A_OKRP.OD,A_OKRP.DO,,_del_zp,_del_ss,1)
   ?};
:: na koniec usuwamy pracownika
   {? _wyn
   || exec('del_A_OKRP','grafik',A_OKRP.ref())
   ?}
?};

{? _sel_size=0 | _sel_size=1 || VAR_DEL.delete('__choice') ?};
{? ~_sel_size || P.f_rfresh() ?};
_wyn


\a_okrp_gad
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.28]
:: OPIS: Formuła po grupowym usunięciu pracownika z okresu.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? ~P.sel_size() || P.f_rfresh() ?};
~~


\a_okrp_ba
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [17.42]
:: OPIS: Formuła przed dołączeniem pracownika do okresu.
::   WE: _a - 1 - wświetlenie listy pracowników, 0 - bez wyświetlania listy pracowników (bieżący)
::   WY:
::  OLD: \dodaj_prac/okres.fml
::----------------------------------------------------------------------------------------------------------------------
A_OKR.seek(__HARM.OKR_REF,,1);
{? _<1 | var_pres('_a')<>type_of(0) || _a:=1 ?};
P.cntx_psh();
{? _a
|| _args:=exec('wybierz_args','pracownik');
   _args.DOMAIN:='PRC';
   _args.UD_SCH:=exec('domyslny','schemat','PODZORG');
   _args.UD_SKL:=__PARSES.getVal('JednostkaOrganizacyjna').REF;
   _args.F_ZATR:={? P_FILTER.F_ZATR().KOD='' || '*T' || P_FILTER.F_ZATR().KOD ?};
   _args.VIEW:=P_FILTER.STATUS;
   _args.SQL_WHERE:=
      'P.DZA<to_date(\'%1\') and (P.DZ is null or P.DZ>to_date(\'%2\')) '
      'and P.REFERENCE not in (select A_OKRP.P from A_OKRP where A_OKRP.OKR=\'%3\' order by 1)'
      [A_OKR.DO$1,A_OKR.OD$1,$A_OKR.ref()];
   _args.WIELU:=0;
   _pref:=exec('wybierz','pracownik',_args).P.SQL
|| _pref:=$P.ref()
?};

{? +_pref
|| {? P.seek(_pref)
   || _error:=exec('gen_tab_error','okres');
      {? P.DZA<=A_OKR.DO & (P.DZ=#0 | P.DZ>=A_OKR.OD)
      || _od:={? P.DZA<A_OKR.OD || A_OKR.OD || P.DZA ?};
         _do:=
            {? P.DZ<A_OKR.DO
            || {? P.DZ=#0 || A_OKR.DO || P.DZ ?}
            || A_OKR.DO
            ?};
:: pobranie możliwych dat przypisania do okresu
         _okrp:=exec('getOdDo4Okrp','okres',P.ref(),_od,_do,A_OKR.NAZ);
         {? _okrp.ok=0
         || FUN.emsg('Nie znaleziono zapisów w historii domyślnych okresów rozliczeniowych współpracownika, \n'
               'które byłyby zgodne z wybranym okresem.'@+
               '\n'+'Przyjęte zostaną daty początku i końca wybranego okresu rozliczeniowego.'@)
         ?};
:: podanie dat przypisania do okresu
         {? _okrp.ok>=0
         || VAR_EDIT.D_OD:=_okrp.od;
            VAR_EDIT.D_DO:=_okrp.do;
            VAR_EDIT.win_edit('ZAKR_DAT');
            VAR_EDIT.efld_opt('ZAKR_DAT','mark=1',,'D_OD');
            VAR_EDIT.efld_opt('ZAKR_DAT','mark=1',,'D_DO');
            _edit:=0;
            {!
            |? {? VAR_EDIT.edit("__CHK.record(VAR_EDIT,,'D_OD','D_DO')")
               || {? VAR_EDIT.D_OD>=A_OKR.OD & VAR_EDIT.D_OD<=A_OKR.DO
                     &
                     VAR_EDIT.D_DO>=A_OKR.OD & VAR_EDIT.D_DO<=A_OKR.DO
                  || _edit:=1;
                     0
                  || _text:='Błędna data ';
                     _err_p:=0;
                     {? VAR_EDIT.D_OD<A_OKR.OD | VAR_EDIT.D_OD>A_OKR.DO
                     || _text+='początku';
                        _err_p:=1
                     ?};
                     {? VAR_EDIT.D_DO<A_OKR.OD | VAR_EDIT.D_DO>A_OKR.DO
                     || _text+={? _err_p ||' i ' || ''?};
                        _text+='końca'
                     ?};
                     _text+=' przypisania pracownika do okresu.';
                     FUN.emsg(_text);
                     1
                  ?}
               || {? FUN.ask('Czy na pewno chcesz zrezygnować z wprowadzania danych?'@)
                  || 0
                  || 1
                  ?}
               ?}
            !};
            {? _edit
            || A_OKRP.cntx_psh();
               A_OKRP.index('A_OKPP');
               A_OKRP.prefix(__HARM.OKR_REF);
               A_OKRP.blank();
               A_OKRP.OKR:=A_OKR.ref();
               A_OKRP.P:=P.ref();
               A_OKRP.OSOBA:=P.OSOBA;
               A_OKRP.OD:={? _od<VAR_EDIT.D_OD || VAR_EDIT.D_OD || _od ?};
               A_OKRP.DO:={? VAR_EDIT.D_DO<_do || VAR_EDIT.D_DO || _do ?};
               {? exec('spr_a_okrp','okres',P.ref(),_error,A_OKRP.OD,A_OKRP.DO,A_OKRP.OKR)
               || {? A_OKRP.add(1)
                  || exec('dodaj_do_buff','grafik','P',A_OKRP.P,A_OKRP.OKR,,,2);
                     exec('dodaj_do_buff','grafik','G',A_OKRP.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,2);
                     exec('dodaj_do_buff','grafik','W',A_OKRP.P,A_OKRP.OKR,A_OKRP.OD,A_OKRP.DO,2);
                     exec('endPl4ClMonth','okres',A_OKRP.ref())
                  || FUN.emsg('%1\n%2'
                        ['Pracownik już jest przypisany do bieżącego okresu.'@,
                         'Dołączenie pracownika niemożliwe.'@])
                  ?}
               ?};
               A_OKRP.cntx_pop()
            ?}
         |? _okrp.ok=-1
         || FUN.error('Błędny typ argumentu.'@)
         ?}
      ?};
      {? _error.first()
      || _wer:=_error.mk_sel('Błędy przypisania pracowników do okresu rozliczeniowego.'@,,1,,,,,,'U',,,,,'maximized');
         _error.win_btn(_wer,'text=%1,icon=xwin16.png:14,panel=bottom,align=end'['Anuluj'@],'key:Esc');
         _error.win_sel(_wer);
         _error.select()
      ?}
   ?}
?};
P.cntx_pop();
{? _a
|| _par:=params_get();
   _par.cfg.nav.main:='PRC_HAR';
   params_exec('stdor_p_bs_har','prc',1);
   P.f_seek({? +_pref || _pref || _par.cfg.extra.REF_HAR ?})
?}


\a_okrp_tba
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Formuła triger przed dodaniem rekordu w tabeli A_OKRP.
::   WE:
::   WY:
::  OLD: \A_OKRP/okres.fml
::----------------------------------------------------------------------------------------------------------------------
A_OKR.cntx_psh();
{? (A_OKRP.OKR<>null()) & (A_OKRP.OKR().S_PLAN='Z')
|| A_OKRP.S_PLAN:='Z'
?};
A_OKR.cntx_pop();
1


\a_okrp_taa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja na trigger po dodaniu rekordu tabeli A_OKRP.
::   WE:
::   WY:
::  OLD: \a_okrp_a_add/okres.fml
::----------------------------------------------------------------------------------------------------------------------
_start:=A_OKRP.OD;
_rok:=_start~1;
_msc:=_start~2;
_end:=A_OKRP.DO;
_end_rok:=_end~1;
_end_msc:=_end~2;
A_OKR.cntx_psh();
A_OKRP.cntx_psh();
A_OKRP_M.cntx_psh();
A_OKRP_M.index('A_OKRPM');
{!
|? A_OKRP_M.prefix(A_OKRP.ref(),_rok,_msc);
   {? ~A_OKRP_M.first()
   || A_OKRP_M.A_OKRP:=A_OKRP.ref();
      A_OKRP_M.ROK:=_rok;
      A_OKRP_M.MSC:=_msc;
      _status:=A_OKRP.OKR().S_PLAN;
      {? _status<>'Z' || _status:=exec('getMscPlanStat','okres',_rok,_msc) ?};
      A_OKRP_M.STATUS:=_status;
      {? A_OKRP_M.add() & _status<>'Z'
      || A_OKRP_M.A_OKRP().S_PLAN:='O';
         A_OKRP.put()
      ?}
   ?};
   _msc+=1;
   {? _msc>12 || _rok+=1; _msc:=1 ?};
   (_rok<_end_rok) | ((_rok=_end_rok) & (_msc<=_end_msc))
!};
A_OKRP_M.cntx_pop();
A_OKRP.cntx_pop();
A_OKR.cntx_pop();
~~


\a_okrp_tap
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Formuła triger po poprawieniu rekordu w tabeli A_OKRP.
::   WE:
::   WY:
::  OLD: \A_OKRP/okres.fml
::----------------------------------------------------------------------------------------------------------------------
{? bfld('OD')<>A_OKRP.OD | bfld('DO')<>A_OKRP.DO
|| exec('a_okrp_taa','okres')
?};
~~


\a_okrp_tbd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja na trigger przed usunieciem rekordu tabeli A_OKRP.
::   WE:
::   WY:
::  OLD: \a_okrp_b_del/okres.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
A_OKRP_M.cntx_psh();
A_OKRP_M.index('A_OKRPM');
A_OKRP_M.prefix(A_OKRP.ref());
{? A_OKRP_M.first()
|| {!
   |? _del:=A_OKRP_M.del(1,1);
      {? _del=0
      || _res:=0
      || _del>1
      ?}
   !}
?};
A_OKRP_M.cntx_pop();
_res


\getOdDo4Okrp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja określająca daty możliwego początku i końca przypisania do okresu na podstawie historii domyślnych
::       okresów rozliczeniowych.
::   WE: _a - [REFERENCE] - wskazanie na pracownika P.ref
::       _b - [DATE]      - minimalny początek badanego okresu
::       _c - [DATE]      - maksymalny koniec badanego okresu
::       _d - [REFERENCE] - wskazanie na nazwę okresu rozliczeniowego A_OKRN
::   WY: obiekt z datami określajacymi możliwy poczatek i koniec przypisania do okresu. W polu 'ok' przekazywana jest
::       informacja czy zwracane daty ustalone są na podstawie historii domyślnych okresów
::----------------------------------------------------------------------------------------------------------------------
_res:=obj_new('od','do','ok');
_res.ok:=-1;
_res.od:=_res.do:=date(0,0,0);
_p_ref:={? var_pres('_a')=type_of(null()) || _a || return(_res) ?};
_pocz:={? var_pres('_b')=type_of(#0) || _b || return(_res) ?};
_kon:={? var_pres('_c')=type_of(#0) || _c || return(_res) ?};
_okrn:={? var_pres('_d')=type_of(null()) || _d || return(_res) ?};
_res.ok:=0;
A_OKRD.cntx_psh();
A_OKRD.index('POKR');
A_OKRD.prefix(_p_ref,_okrn);
{? A_OKRD.first()
|| _dalej:=1;
   {!
   |? _max_do:=exec('get_aokrd_do','grafik',_p_ref,A_OKRD.OD,_okrn);
      {? A_OKRD.OD<=_kon & (_max_do=#0 | (_max_do>=_pocz & _max_do<=_kon))
      || _res.od:={? A_OKRD.OD<_pocz || _pocz || A_OKRD.OD ?};
         _res.do:={? _max_do=#0 | _max_do>_kon || _kon || _max_do ?};
         {? _res.od<=_res.do || _res.ok:=1 ?};
         _dalej:=0
      ?};
      _dalej & A_OKRD.next()
   !}
?};
A_OKRD.cntx_pop();
{? _res.ok=0
|| _res.od:=_pocz;
   _res.do:=_kon
?};
_res


\norm_okrd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Funkcja normalizuje zapisy w tabeli historii okresów domyślnych.
::   WE:  _a  - [REFERENCE] - wskazanie na pracownika
::       [_b] - [NUMBER]    - czy wyświetlać komunikat o usuniętych zapisach
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')=type_of(null()) || _a || null() ?};
_msg:={? var_pres('_b')=type_of(0) || _b || 0 ?};
A_OKRD.cntx_psh();
A_OKRD.index('POD');
A_OKRD.prefix(_p_ref);
_okr_naz:=null();
_czy_del:=0;
{? A_OKRD.first()
|| _ref:=A_OKRD.ref();
   {!
   |? {? A_OKRD.ref<>_ref & A_OKRD.A_OKRN=_okr_naz
      || _del:=1
      || _okr_naz:=A_OKRD.A_OKRN;
         _ref:=A_OKRD.ref();
         _del:=0
      ?};
      {? _del
      || _czy_del+=A_OKRD.del()
      || A_OKRD.next()
      ?}
   !}
?};
{? _msg & _czy_del
|| FUN.info('Usunięto nadmiarowe zapisy.'@)
?};
A_OKRD.cntx_pop();
_czy_del


\aktBuffForOkr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Aktualizuje zapisy w A_OKRP i KAL_BUFF na podstawie wpisów w A_OKRD.
::   WE: _a - [REFERENCE] - wskazanie na pracownika P.ref
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')=type_of(null) || _a || return(0) ?};
_ret_val:=0;
:: (1) - ustal pierwszy wpis w A_OKRD
A_OKRD.cntx_psh();
A_OKRD.index('POD');
A_OKRD.prefix(_p_ref);
{? A_OKRD.first()
||
:: pobranie wszystkich okresów rozliczeniowych od wskazanej daty otwarte do planowania i rozliczenia
   _t_okr:=exec('getOkrFromDate','grafik',_p_ref,A_OKRD.OD,,,'O','O');
:: pobranie wszystkich okresów pracownika od wskazanej daty otwarte do planowania i rozliczenia
   _t_okrp:=exec('getOkrpFromDate','grafik',_p_ref,A_OKRD.OD,,,'O','O');
:: ustalenie maskymalnej daty DO przypisania pracownika do okresów rozliczeniowych
   _okrp_do:=date(0,0,0);
   {? _t_okrp.first()
   || {!
      |? {? _t_okrp.DO>_okrp_do
         || _okrp_do:=_t_okrp.DO
         ?};
         _t_okrp.next()
      !}
   ?};
   {!
   |?
:: ustalenie zakresu trwania okresu domyślnego
      _od:=A_OKRD.OD;
      _do:=exec('get_aokrd_do','grafik',_p_ref,_od,A_OKRD.A_OKRN);
::aktualizacja okresów
      {? _od<=_okrp_do
      || _ret_val:=exec('aktKalBuff','grafik',_p_ref,_od,_do,_t_okr,A_OKRD.A_OKRN,_okrp_do)
      ?};
      A_OKRD.next()
   !}
?};
A_OKRD.cntx_pop();
_ret_val


\a_okrd_aa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [17.28]
:: OPIS: Formuła po akcji dołącz w tabeli domyślnych rodzajów okresów rozliczeniowych.
::   WE: _a - [REFERENCE] - wskazanie na pracownika P.ref
::   WY:
::  OLD: \okres_d_prac/okres.fml
::----------------------------------------------------------------------------------------------------------------------
exec('norm_okrd','okres',A_OKRD.P,1);
exec('aktBuffForOkr','okres',A_OKRD.P);
0


\a_okrd_apd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [17.28]
:: OPIS: Formuła po akcji popraw i usuń w tabeli domyślnych rodzajów okresów rozliczeniowych.
::   WE: _a - [REFERENCE] - wskazanie na pracownika P.ref
::   WY:
::  OLD: \okres_d_prac/okres.fml
::----------------------------------------------------------------------------------------------------------------------
exec('norm_okrd','okres',A_OKRD.P,1);
exec('aktBuffForOkr','okres',A_OKRD.P)


\a_okrd_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [17.28]
:: OPIS: Formuła przed akcją usuń w tabeli domyślnych rodzajów okresów rozliczeniowych.
::   WE: _a - [REFERENCE] - wskazanie na pracownika P.ref
::   WY:
::  OLD: \okres_d_prac/okres.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('canBeDelOkrd','okres',A_OKRD.ref(),1)
|| {? FUN.ask('Czy usunąć bieżący wiersz?'@)
   || exec('delPracFromBuf','okres',A_OKRD.P,A_OKRD.OD,A_OKRD.A_OKRN);
      _wyn:=A_OKRD.del(,1);
      _prev:={? _wyn=1 | _wyn=4 | _wyn=5 || 0
             |? _wyn=2 || {? A_OKRD.size()>1 || A_OKRD.prev() ?}
             |? _wyn=3 || 1
             ?};
      {? ~_prev
      || FUN.emsg('%1\n%2'
            [  'Usunięto pierwszy zapis w historii domyślnych okresów.'@,
               'Należy sprawdzić poprawność przypisania pracownika do okresów rozliczeniowych.'@
            ]
         )
      ?};
      1
   ?}
?}


\a_okrd_are
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [17.28]
:: OPIS: Formuła po akcji rekord dla pustej dziedziny w tabeli domyślnych rodzajów okresów rozliczeniowych.
::   WE: _a - [REFERENCE] - wskazanie na pracownika P.ref
::   WY:
::  OLD: \okres_d_prac/okres.fml
::----------------------------------------------------------------------------------------------------------------------
_ret:=__CHK.record2(A_OKRD,'OD','Od daty','A_OKRN','Okres');
{? _ret=''
|| _min_od:=exec('minDataOdOkrd','okres',A_OKRD);
   {? A_OKRD.OD<A_OKRD.P().DZA
   || FUN.emsg('\'Data od\' nie może być wcześniejsza niż data zatrudnienia pracownika: %1.'@[$P.DZA]);
      A_OKRD.OD:=P.DZA;
      _ret:='OD'
   |? A_OKRD.OD<_min_od
   || FUN.emsg('Ze względu na zakończone planowanie w okresach rozliczeniowych,\n'+
               '"Data od" nie może być wcześniejsza niż: %1, dla wybranego typu okresu.'@[$_min_od]
      );
      A_OKRD.OD:=_min_od;
      _ret:='OD'
   || _data:=A_OKRD.OD;
      _idadd:=A_OKRD.IDADD;
      A_OKRD.cntx_psh();
      A_OKRD.index('POD');
      A_OKRD.prefix(P.ref());
      {? A_OKRD.find_key(_data) & _idadd<>A_OKRD.IDADD
      || FUN.emsg('%1\n%2'
            [  'Domyślny okres rozliczeniowy rozpoczynający się od podanej daty już istnieje.'@,
               'Proszę podać inną datę.'@
            ]
         );
         _ret:='OD'
      ?};
      A_OKRD.cntx_pop();
      _ret
   ?}
?};
_ret


\a_okrd_ar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [17.28]
:: OPIS: Formuła po akcji rekord dla niepustej dziedziny w tabeli domyślnych rodzajów okresów rozliczeniowych.
::   WE: _a - [REFERENCE] - wskazanie na pracownika P.ref
::   WY:
::  OLD: \okres_d_prac/okres.fml
::----------------------------------------------------------------------------------------------------------------------
exec('a_okrd_are','okres')


\minDataOdOkrd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Wylicza minimalną datę dla zmiany domyślego okresu.
::   WE: Bufor tabeli A_OKRD musi być ustalony
::   WY: [DATE] - data
::----------------------------------------------------------------------------------------------------------------------
_min_od:=date(0,0,0);
_min_odN:=date(0,0,0);
:: pobranie wszystkich okresów pracownika od wskazanej daty
_t_okr:=exec('getOkrFromDate','grafik',A_OKRD.P,A_OKRD.OD);
{? _t_okr.last()
|| A_OKR.cntx_psh();
   _brak_o:=_brak_oN:=1;
   {!
   |? {? A_OKR.seek(_t_okr.NR,_t_okr.MASK,1)
      || {? A_OKR.S_PLAN<>'Z' & A_OKR.S<>'Z'
         || _brak_o:=0;
            _min_od:={? A_OKR.OD<_min_od || A_OKR.OD || _min_od ?}
         || {? _brak_o & A_OKR.DO+1>_min_od
            || _min_od:=A_OKR.DO+1
            ?}
         ?};
:: sprawdzenie minimalnej daty dla dodawanego okresu (zgodnego z nazwą nowego okresu)
         {? A_OKR.NAZ=A_OKRD.A_OKRN
         || {? A_OKR.S_PLAN<>'Z' & A_OKR.S<>'Z'
            || _brak_oN:=0;
               _min_odN:={? A_OKR.OD<_min_od || A_OKR.OD || _min_od ?}
            || {? _brak_oN & A_OKR.DO+1>_min_odN
               || _min_odN:=A_OKR.DO+1
               ?}
            ?}
         ?}
      ?};
      _t_okr.prev()
   !};
   A_OKR.cntx_pop()
?};
{? _min_odN<_min_od
|| _min_odN
|| _min_od
?}


\canBeDelOkrd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Funkcja sprawdzająca czy można usunąć zapis w tabeli historii okresów domyślych.
::   WE: _a  - [REFERENCE] - wskazanie na okres A_OKRD
::      [_b] - [NUMBER]    - czy wyświetlać komunikaty
::   WY: 0 lub 1
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_pres('_a')=type_of(null()) || _a || return(0) ?};
_msg:={? var_pres('_b')<0 || 0 || 1 ?};
_ret_val:=0;
A_OKRD.cntx_psh();
A_OKRD.prefix();
{? A_OKRD.seek(_ref)
|| _p_ref:=A_OKRD.P;
   _od:=A_OKRD.OD;
:: pobranie wszystkich okresów pracownika od wskazanej daty ze wskazaną nazwą
   _t_okrp:=exec('getOkrpFromDate','grafik',_p_ref,_od,,A_OKRD.A_OKRN);
   {? _t_okrp.first()
   || A_OKRP.cntx_psh();
      _dalej:=1;
      {!
      |? {? A_OKRP.seek(_t_okrp.NR,_t_okrp.MASK,1)
         || {? (A_OKRP.OKR().S_PLAN<>'Z') & (A_OKRP.OKR().S<>'Z')
            || _ret_val:=1
            || _ret_val:=0;
               _dalej:=0
            ?}
         ?};
         _dalej & _t_okrp.next()
      !};
      A_OKRP.cntx_pop()
   || _ret_val:=1
   ?}
?};
A_OKRD.cntx_pop();
{? _msg & (_ret_val=0)
|| FUN.info('%1 %2'['Nie można modyfikować rekordu.'@,'Informacja wykorzystywana w harmonogramach.'@])
?};
_ret_val


\delPracFromBuf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Usuwa pracownika z okresów rozliczeniowych otwartych do planowania i rozliczenia.
::   WE: _a - [REFERENCE] - wskazanie na pracownika
::       _b - [DATE]      - data od
::       _c - [REFERENCE] - wskazanie na A_OKRN
::----------------------------------------------------------------------------------------------------------------------
_p_ref:={? var_pres('_a')=type_of(null()) || _a || return(0) ?};
_data:={? var_pres('_b')=type_of(#0) || _b || return(0) ?};
_okrn:={? var_pres('_c')=type_of(null()) || _c || return(0) ?};
_max_do:=exec('get_aokrd_do','grafik',_p_ref,_data,_okrn);

A_OKR.cntx_psh();
A_OKRP.cntx_psh();
A_OKRP.index('A_OKRDP');
A_OKRP.prefix(_p_ref);
{? A_OKRP.last()
|| {!
   |? {? A_OKRP.OKR().NAZ=_okrn & A_OKRP.OKR().S_PLAN<>'Z' & A_OKRP.OKR().S<>'Z'
      || {? A_OKRP.DO>=_data & (_max_do=#0 | _max_do<=A_OKRP.DO)
         ||
:: usunięcie pracownika z okresu
            exec('usun_z_buff','grafik','P',_p_ref,A_OKRP.OKR);
            exec('usun_z_buff','grafik','G',_p_ref,A_OKRP.OKR);
            exec('usun_z_buff','grafik','W',_p_ref,A_OKRP.OKR);
            exec('del_A_OKRP','grafik',A_OKRP.ref())
         || A_OKRP.prev()
         ?}
      || A_OKRP.prev()
      ?}
   !}
?};
A_OKRP.cntx_pop();
A_OKR.cntx_pop()


\kalendarz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [mk] Michał Kocot [2006]
:: OPIS: Edycja/podgląd listy kalendarzy przypisanych do okresu.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_okres:=cur_tab(1,1).name()='x_okr';
A_OKRKA.cntx_psh();
A_OKRKA.index('A_OKRKA');
A_OKRKA.prefix({? _okres || A_OKR.NAZ || A_OKRN.ref() ?});
A_OKRKA.win_edit('RED');
A_OKRKA.win_sel('WER');
A_OKRKA.hdr_sel();
A_OKRKA.hdr_sel(' '+{? _okres || A_OKR.NAZ().NAZ || A_OKRN.NAZ ?});
A_OKRKA.select(,,,{? _okres || 'dUp:d' || '' ?});
A_OKRKA.cntx_pop();
~~


\a_okrka_bl_naz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.28]
:: OPIS: Formula na blank pola A_OKRKA.NAZ.
::   WE:
::   WY:
::  OLD: \bl_a_okr_naz/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
A_OKRN.ref()


\a_okrn_ae_naz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [17.28]
:: OPIS: Weryfikacja wypełnienia pola po edycji definicji okresu rozliczeniowego.
::   WE:
::   WY:
::  OLD: \spr_okr/okres.fml
::----------------------------------------------------------------------------------------------------------------------
__CHK.record2(cur_tab(),cur_afld(),cur_nfld())=''


\openPlan4Msc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja otwiera planowanie w wybranym miesiącu.
::   WE: _a - [NUMBER] - wybrany rok
::       _b - [NUMBER] - wybrany miesiąc
::   WY: 0/1 - czy udało się zamknąć miesiąc
::----------------------------------------------------------------------------------------------------------------------
_rok:={? var_pres('_a')=type_of(0) || _a || return(0) ?};
_msc:={? var_pres('_b')=type_of(0) || _b || return(0) ?};
_mydo:=do_state()=0;
{? _mydo || do() ?};
{? exec('setMscPlanStat','okres',_rok,_msc,'O')
|| exec('planOkr4Msc','okres',_rok,_msc)
?};
{? _mydo || end() ?}


\endPlan4Msc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja zamykająca planowanie w wybranym miesiącu.
::   WE: _a - [NUMBER] - wybrany rok
::       _b - [NUMBER] - wybrany miesiąc
::   WY: 0/1 - czy udało się zamknąć miesiąc
::----------------------------------------------------------------------------------------------------------------------
_rok:={? var_pres('_a')=type_of(0) || _a || return(0) ?};
_msc:={? var_pres('_b')=type_of(0) || _b || return(0) ?};

{? exec('end_openPlan4M','okres',_rok,_msc,'Z')
|| _mydo:=do_state()=0;
   {? _mydo || do() ?};
   {? exec('setMscPlanStat','okres',_rok,_msc,'Z')
   || exec('planOkr4Msc','okres',_rok,_msc)
   ?};
   {? _mydo || end() ?}
?}


\getPracZeroMc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK[12.41]
:: OPIS: Procedura wyświetla pracowników z zerowym planowaniem w zamykanym miesiącu.
::   WE: _a - [INTEGER] - rok
::       _b - [INTEGER] - miesiąc
::   WY: tabela z listą pracowników
::----------------------------------------------------------------------------------------------------------------------
_rok:={? var_pres('_a')=type_of(0) || _a || return(0) ?};
_msc:={? var_pres('_b')=type_of(0) || _b || return(0) ?};
_tab:=tab_tmp(2,
   'NAZWISKO','STRING[30]','Nazwisko pracownika',
   'IMIE','STRING[20]','Imię pracownika',
   'WYDZIAL','STRING[16]','Wydział',
   'T','STRING[9]','Nr teczki',
   'OD','DATE','Od',
   'DO','DATE','Do',
   'SZEF','STRING[60]','Przełożony'
);

_msc_od:=date(_rok,_msc,1);
_msc_do:=date(_rok,_msc,0);
_ndx_do:=A_OKR.ndx_tmp('',1,'DO',,);
_size:=0;

P.cntx_psh();
OSOBA.cntx_psh();
UD_SKL.cntx_psh();
A_OKR.cntx_psh();
A_OKR.index(_ndx_do);
A_OKR.prefix();
{? A_OKR.find_ge(_msc_od)
|| {!
   |? {? A_OKR.OD<=_msc_do & A_OKR.DO>=_msc_od
      || _size:=0;
         A_OKRP.cntx_psh();
         A_OKRP.index('A_OKPP');
         A_OKRP.prefix(A_OKR.ref());
         {? A_OKRP.first()
         || _size:=A_OKRP.size();
            _tab_p:=sql('
               select
                  KAL_BUFF.P P_REF,
                  sum((EXTRACT(MINUTE FROM KAL_BUFF.CZAS)+(EXTRACT(HOUR FROM KAL_BUFF.CZAS)*60))/60) CZAS
               from
                  KAL_BUFF join A_OKRP using(KAL_BUFF.P, A_OKRP.P)
               where
                  A_OKRP.OKR=:_a and KAL_BUFF.GPW=\'P\' and KAL_BUFF.DATA>=A_OKRP.OD and KAL_BUFF.DATA<=A_OKRP.DO
               group by
                  KAL_BUFF.P
               order by 1',
               A_OKR.ref()
            );
            {!
            |? _p_od:={? A_OKRP.OD<_msc_od || _msc_od || A_OKRP.OD ?};
               _p_do:={? A_OKRP.DO>_msc_do || _msc_do || A_OKRP.DO ?};
               {? _tab_p.find_key($A_OKRP.P) & _tab_p.CZAS=0 & _p_od<=_msc_do & _p_do>=_msc_od
               || _tab.blank(1);
                  A_OKRP.P();
                  _tab.WYDZIAL:=P.WYDZIAL().SYMBOL;
                  _tab.T:=P.T;
                  _tab.NAZWISKO:=P.OSOBA().NAZWISKO;
                  _tab.IMIE:=OSOBA.PIERWSZE;
                  _tab.OD:=_p_od;
                  _tab.DO:=_p_do;
                  _szef:=exec('prac_nad','stanprac',P.ref(),0,'TYPPOZ','PLANCZP',,1);
                  {? _szef.first()
                  || _tab.SZEF:=_szef.IMIE+' '+_szef.NAZWISKO
                  ?};
                  obj_del(_szef);
                  _tab.add()
               ?};
               A_OKRP.next()
            !};
            obj_del(_tab_p)
         ?};
         A_OKRP.cntx_pop()
      ?};
      A_OKR.next()
   !}
?};
A_OKR.ndx_drop(_ndx_do);
A_OKR.cntx_pop();
UD_SKL.cntx_pop();
OSOBA.cntx_pop();
P.cntx_pop();
{? _tab.first()
|| _win:=_tab.mk_sel('Lista pracowników z zerową liczbą zaplanowanych godzin pracy'@,,,,,,,,'U',,,,,'maximized');
   _tab.win_sel(_win);
   _tab.win_fld(_win,,'T',,,9,,1,'Teczka'@,,'Nr teczki współpracownika'@);
   _tab.win_fld(_win,,'NAZWISKO',,,30,,1,'Nazwisko'@,,'Nazwisko współpracownika'@);
   _tab.win_fld(_win,,'IMIE',,,20,,1,'Imię'@,,'Imię współpracownika'@);
   _tab.win_fld(_win,,'WYDZIAL',,,15,,1,'Wydział'@,,'Jednostka organizacyjna'@);
   _tab.win_fld(_win,,'SZEF',,,50,,1,'Przełożony'@,,'Przełożony współpracownika'@);
   _tab.win_btn(_win,'text=%1,icon=xwin16.png:14,panel=bottom,align=end'['Anuluj'@],'key:Esc');
   _tab.select()
?};
1


\planOkr4Msc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja ustawiająca status okresu w zależności od statusu miesięcy.
::   WE: _a - [INTEGER] - rok
::       _b - [INTEGER] - miesiąc
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_rok:={? var_pres('_a')=type_of(0) || _a || return() ?};
_msc:={? var_pres('_b')=type_of(0) || _b || return() ?};

_status:='';
_msc_od:=date(_rok,_msc,1);
_msc_do:=date(_rok,_msc,0);
_ndx_do:=A_OKR.ndx_tmp('',1,'DO',,);

A_OKR.cntx_psh();
A_OKR.index(_ndx_do);
A_OKR.prefix();
{? A_OKR.find_ge(_msc_od)
|| {!
   |? {? (A_OKR.OD<=_msc_do) & (A_OKR.DO>=_msc_od)
      || _ok:=0;
         {? exec('canClosePlanOkr','okres',A_OKR.ref())
         || _status:='Z'
         || _status:='O'
         ?};
         {? _status<>''
         || A_OKR.S_PLAN:=_status;
            A_OKR.put()
         ?}
      ?};
      A_OKR.next()
   !}
?};
A_OKR.ndx_drop(_ndx_do);
A_OKR.cntx_pop();
~~


\end_openPlan4M
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Funkcja do zablokowania/odblokowania planowania w wybranym miesiącu.
::   WE: _a - [NUMBER] - wybrany rok
::       _b - [NUMBER] - wybrany miesiąc
::       _c - [STRING] - 'Z' (zablokowanie) lub 'O' (odblokowanie)
::   WY: 0/1 - czy udało się zablokować miesiąc
::----------------------------------------------------------------------------------------------------------------------
_rok:={? var_pres('_a')=type_of(0) || _a || return(0) ?};
_msc:={? var_pres('_b')=type_of(0) || _b || return(0) ?};
_status:={? var_pres('_c')=type_of('') || _c || return(0) ?};

_mProg:=exec('init','#progress');
_mProg.gl_smode('#');
_mProg.HEIGHT:=30;
_mProg.BREAK_ON:='N';
_mProg.TITLE:=
   {? _status='Z'
   || 'Zablokowanie planowania w miesiącu %1/%2'@[$_rok,$_msc]
   || 'Odblokowanie planowania w miesiącu %1/%2'@[$_rok,$_msc]
   ?};

_msc_od:=date(_rok,_msc,1);
_msc_do:=date(_rok,_msc,0);
_ndx_do:=A_OKR.ndx_tmp('',1,'DO',,);
_size:=0;
:: wyliczenie potrzebnych progresów dla poszczególnych okresów rozliczeniowych
:: oraz sprawdzenie czy wszyscy mają zablokowane planowanie
P.cntx_psh();
OSOBA.cntx_psh();
UD_SKL.cntx_psh();
A_OKR.cntx_psh();
A_OKR.index(_ndx_do);
A_OKR.prefix();
{? A_OKR.find_ge(_msc_od)
|| {!
   |? {? A_OKR.OD<=_msc_do & A_OKR.DO>=_msc_od
      || _size:=0;
         A_OKRP.cntx_psh();
         A_OKRP.index('A_OKPP');
         A_OKRP.prefix(A_OKR.ref());
         {? A_OKRP.first()
         || _size:=A_OKRP.size()
         ?};
         A_OKRP.cntx_pop();
         _txt:={? _status='Z'
               || 'Zablokowanie miesiąca: %1/%2 dla okresu rozliczeniowego: %3(%4 - %5)'@
                     [  $_rok,$_msc,A_OKR.NAZ().NAZ,$A_OKR.OD,$A_OKR.DO
                     ]
               || 'Odblokowanie miesiąca: %1/%2 dla okresu rozliczeniowego: %3(%4 - %5)'@
                     [  $_rok,$_msc,A_OKR.NAZ().NAZ,$A_OKR.OD,$A_OKR.DO
                     ]
               ?};
         {? _size
         || _mProg.add_progress(_txt,_size)
         ?}
      ?};
      A_OKR.next()
   !}
?};
:: wyświetlenie informacji o współpracownikach nie mających zamkniętego planowania w miesiącu
_par:=obj_new('ok','rok','msc');
_par.ok:=0;
_par.rok:=_rok;
_par.msc:=_msc;
params_set('par',_par);
_tab:=exec('getPracInMsc','okres',_rok,_msc,'KO');
{? _tab.first()
|| FUN.emsg('W zamykanym miesiącu znajdują się współpracownicy z otwartym planowaniem.'@+'\n'+
            'Należy zakończyć planowanie wszystkim współpracownikom przed zablokowaniem miesiąca do planowania.'@);
   _wer:=_tab.mk_sel('Pracownicy z otwartym planowaniem'@,,0,'201207101133',,,,,'U',,,,,'maximized');
   _tab.win_fld(_wer,,'NAZWISKO',,,20,,1,'Nazwisko'@,,'Nazwisko współpracownika'@);
   _tab.win_fld(_wer,,'IMIE',,,15,,1,'Imię'@,,'Imię współpracownika'@);
   _tab.win_fld(_wer,,'WYDZIAL',,,10,,1,'Wydział'@,,'Jednostka organizacyjna');
   _tab.win_fld(_wer,,'T',,,9,,1,'Teczka'@,,'Nr teczki współpracownika'@);
   _tab.win_fld(_wer,,'OD',,,10,,1,'Od'@,,'Data początku miesiąca do planowania'@);
   _tab.win_fld(_wer,,'DO',,,10,,1,'Do'@,,'Data końca miesiąca do planowania'@);
   _tab.win_fld(_wer,,'PLAN',,,3,,1,'Status - kod'@,,
      'Status planowania:O-odblokowany,Z-Zablokowany,X-dane przeniesione,K-korekta'@
   );
   _tab.win_fld(_wer,POLA_GRP,'TXT_1',,,25,,1,'Status - opis'@,,'Opis statusu planowania');
   _tab.win_fld(_wer,,'SZEF',,,30,,,'Przełożony'@,,'Przełożony współpracownika odpowiedzialny za planowanie'@);
   _tab.win_act(_wer,,'Rekord',,,,
      "  P.cntx_psh();
         A_OKRP.cntx_psh();
         A_OKRP.index('A_OKRPR');
         _error:=0;
         {? P.seek(cur_tab().P_REF,,1)
         || {? A_OKRP.seek(cur_tab().A_OKRP,ref_name(cur_tab().A_OKRP),1)
            || _error+=
                  {? exec('chk_err','prc_errcms', cur_tab().OD~1,cur_tab().OD~2)
                  || 1
                  || exec('chk_errl','prc_errcms', cur_tab().OD~1,cur_tab().OD~2)
                  ?}
            ?}
         ?};
         A_OKRP.cntx_pop();
         P.cntx_pop();
         _gray:={? cur_tab().sel_size() || 'W' || '' ?};
         cur_tab().actions_grayed(cur_win(),_gray);
         POLA_GRP.TXT_1:=
            {? cur_tab().PLAN='O'
            || 'Odblokowany'
            |? cur_tab().PLAN='K'
            || 'Odblokowany do korekty'
            || 'Zablokowany'
            ?};
         {? _error || Color.fnd_kol('ERR_CMS#01#01') ?}
      "
   );
   _tab.win_act(_wer,,'Formuła','Błędy planowania'@@,,'Wynik weryfikacji planowania po stronie CMS'@,,
      "  P.cntx_psh();
         A_OKRP.cntx_psh();
         A_OKRP.index('A_OKRPR');
         {? P.seek(cur_tab().P_REF,,1)
         || {? A_OKRP.seek(cur_tab().A_OKRP,ref_name(cur_tab().A_OKRP),1)
            || exec('wer_selm','prc_errcms',cur_tab().OD~1,cur_tab().OD~2,'P')
            ?}
         ?};
         A_OKRP.cntx_pop();
         P.cntx_pop()
      ",,,,,'A'
   );
   _tab.win_act(_wer,0,'Formuła','Zablokuj &wszystkim'@@,,,,
      "  _error:=0;
         cur_tab.cntx_psh();
         P.cntx_psh();
         A_OKRP.cntx_psh();
         A_OKRP.index('A_OKRPR');
         {? cur_tab().first()
         || {!
            |? {? P.seek(cur_tab().P_REF,,1)
               || {? A_OKRP.seek(cur_tab().A_OKRP,ref_name(cur_tab().A_OKRP),1)
                  || _error+=
                        {? exec('chk_err','prc_errcms', cur_tab().OD~1,cur_tab().OD~2)
                        || 1
                        || exec('chk_errl','prc_errcms', cur_tab().OD~1,cur_tab().OD~2)
                        ?}
                  ?}
               ?};
               ~_error & cur_tab().next()
            !}
         ?};
         A_OKRP.cntx_pop();
         P.cntx_pop();
         cur_tab().cntx_pop();
         _par:=params_get().par;
         {? _error
         || {? FUN.ask('%1\n%2'
                  [  'W wybranym zakresie współpracowników są tacy, '+
                     'dla których występują błędy w zaplanowanym czasie pracy.'@,
                     'Czy mimo to zablokować dla nich planowanie?'@
                  ]
               )
            || _par.ok:=1;
               sel_exit()
            || 0
            ?}
         || {? FUN.ask('Czy zablokować planowanie dla wszystkich współpracowników?'@)
            || _par.ok:=1;
               sel_exit()
            ?}
         ?}
      ",0,1,,,'W'
   );
   _tab.win_act(_wer,0,'Formuła','Zablokuj'@@,,,,
      "  _grupa:=0;
         _par:=params_get().par;
         {? cur_tab().sel_size()>0
         || _grupa:=1
         || _error:=0;
            P.cntx_psh();
            A_OKRP.cntx_psh();
            A_OKRP.index('A_OKRPR');
            {? P.seek(cur_tab().P_REF,,1)
            || {? A_OKRP.seek(cur_tab().A_OKRP,ref_name(cur_tab().A_OKRP),1)
               || _error:=
                     {? exec('chk_err','prc_errcms', cur_tab().OD~1,cur_tab().OD~2)
                     || 1
                     || exec('chk_errl','prc_errcms', cur_tab().OD~1,cur_tab().OD~2)
                     ?}
               ?}
            ?};
            A_OKRP.cntx_pop();
            P.cntx_pop();
            {? _error
            || {? ~FUN.ask('%1\n%2'
                     [  'W wybranym miesiącu współpracownik %1 %2 posiada błędy w zaplanowanym czasie pracy.'@
                        [cur_tab().NAZWISKO,cur_tab().IMIE],
                        'Czy mimo to zablokować planowanie w tym miesiącu?'@
                     ]
                  )
               || return(0)
               ?}
            |? ~FUN.ask('%1\n%2 %3?'
                  [  'Czy zablokować planowanie dla współpracownika'@,cur_tab().NAZWISKO,cur_tab().IMIE
                  ]
               )
            || return(0)
            ?}
         ?};
         {? ~_grupa
         || FUN.prg_start(2,'Trwa zablokowanie okresu do planowania'@,,,1);
            FUN.prg_next()
         ?};
         P.cntx_psh();
         A_OKRP.cntx_psh();
         A_OKRP.index('A_OKRPR');
         {? P.seek(cur_tab().P_REF,,1)
         || {? A_OKRP.seek(cur_tab().A_OKRP,ref_name(cur_tab().A_OKRP),1)
            || {? exec('zam_msc_plan','okres',A_OKRP.ref(),_par.rok,_par.msc,1,'Z')
               || cur_tab().del()
               ?}
            ?}
         ?};
         A_OKRP.cntx_pop();
         P.cntx_pop();
         {? ~_grupa
         || FUN.prg_next();
            FUN.prg_stop()
         ?};
         {? cur_tab().size()=0 || sel_exit() ?};
         ~~
      ",1,1,
      "  _sel:=cur_tab().sel_aget();
         _error:=0;
         {? _sel.first()
         || P.cntx_psh();
            A_OKRP.cntx_psh();
            A_OKRP.index('A_OKRPR');
            {!
            |? {? cur_tab().seek(_sel.REF,,1)
               || {? P.seek(cur_tab().P_REF,,1)
                  || {? A_OKRP.seek(cur_tab().A_OKRP,ref_name(cur_tab().A_OKRP),1)
                     || _error+=
                           {? exec('chk_err','prc_errcms', cur_tab().OD~1,cur_tab().OD~2)
                           || 1
                           || exec('chk_errl','prc_errcms', cur_tab().OD~1,cur_tab().OD~2)
                           ?}
                     ?}
                  ?}
               ?};
               ~_error & _sel.next()
            !};
            A_OKRP.cntx_pop();
            P.cntx_pop()
         ?};
         {? _error
         || {? FUN.ask('%1\n%2'
                  [  'W wybranym zakresie współpracowników są tacy, '+
                     'dla których występują błędy w zaplanowanym czasie pracy'@,
                     'Czy mimo to zablokować dla nich planowanie?'@
                  ]
               )
            || 1
            || 0
            ?}
         || {? FUN.ask('Czy zablokować planowanie dla zaznaczonych współpracowników?'@) || 1 || 0 ?}
         ?}
      ",
      "  {? cur_tab().size()=0 || sel_exit() ?}
      ",'Z'
   );
   _tab.win_act(_wer,0,'Formuła','Legenda'@@,,,"exec('legenda','color','ERR_CMS#01#')",,,,,,'L',,'target=window');
   _tab.win_act(_wer,0,'Kolejność');
   _tab.win_btn(_wer,'text=%1'['Zablokuj'@],'menu:Z',,,,,,'noempty');
   _tab.win_btn(_wer,'text=%1,panel=bottom,align=begin'['Zablokuj &wszystkim'@],'menu:W',,,,,,'noempty');
   _tab.win_btn(_wer,'text=%1,icon=xwin16.png:14,panel=bottom,align=end'['Anuluj'@],'key:Esc');
   _tab.win_sel(_wer);
   _tab.select();
   {? ~_par.ok || _par.ok:=_tab.size()=0 || 1 ?}
|| _par.ok:=1
?};
KOMM.init(200);
_ok:=0;
{? _par.ok
|| exec('start','#progress',_mProg);
:: właściwe zablokowanie miesiąca dla poszczególnych okresów rozliczeniowych
   _size:=0;
   {? A_OKR.find_ge(_msc_od)
   || {!
      |? {? A_OKR.OD<=_msc_do & A_OKR.DO>=_msc_od
         || A_OKRP.cntx_psh();
            A_OKRP.index('A_OKPP');
            A_OKRP.prefix(A_OKR.ref());
            _size+=A_OKRP.size();
            _res:=exec('lock_A_OKR','okres',A_OKR.ref());
            {? +_res
            || _txt:='Nie udało się zablokować planowania w miesiącu %1 dla okresu %2 - %3 %4.'@
                  [  _msc_od$8,$A_OKR.OD,$A_OKR.DO,A_OKR.NAZ().NAZ
                  ];
               {? KOMM.find_msg(_txt)=0
               || KOMM.sect_beg(_txt,4);
                  KOMM.add(_res);
                  KOMM.sect_end()
               ?}
            || {? A_OKRP.first()
               || _mProg.next_phase();
                  {!
                  |? _ok+=exec('zam_msc_plan','okres',A_OKRP.ref(),_rok,_msc,1,_status);
                     exec('update','#progress',_mProg,1);
                     A_OKRP.next()
                  !}
               ?}
            ?};
            A_OKRP.cntx_pop();
            exec('unlock_A_OKR','okres',A_OKR.ref())
         ?};
         A_OKR.next()
      !}
   ?};
   _mProg.ctr_stop();
   _ok:=_ok=_size
?};
obj_del(_par);
A_OKR.ndx_drop(_ndx_do);
A_OKR.cntx_pop();
UD_SKL.cntx_pop();
OSOBA.cntx_pop();
P.cntx_pop();
KOMM.select();
_ok


\getPracInMsc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR[12.30]
:: OPIS: Funkcja zwraca tabelę z pracownikami z podanym statusem planowania dla wskazanego miesiąca.
::   WE: _a - [INTEGER] - rok
::       _b - [INTEGER] - miesiąc
::       _c - [STRING] - status lub statusy z jakimi pracownicy mają być pobrani
::       _d - [STRING] - 'T'/'N'/'' - zaznaczeni do planowania, nie zaznaczeni do planowania
::                       lub wszyscy (domyślnie wszyscy)
::       _e - [TABLE] - tabela z pracownikami - nie jest sprawdzana zgodność schematu tabeli
::   WY: tabela z lista pracowników
::----------------------------------------------------------------------------------------------------------------------
_rok:={? var_pres('_a')=type_of(0) || _a || return(0) ?};
_msc:={? var_pres('_b')=type_of(0) || _b || return(0) ?};
_status:={? var_pres('_c')=type_of('') || _c || return(0) ?};
_grafik:={? var_pres('_d')=type_of('') || _d || '' ?};
{? var_pres('_e')=type_of(SYSLOG)
|| _tab:=_e
|| _tab:=tab_tmp(2,
      'NAZWISKO','STRING[30]','Nazwisko pracownika',
      'IMIE','STRING[20]','Imię pracownika',
      'P_REF','STRING[16]','Wskazanie na pracownika',
      'A_OKRP','STRING[16]','Wskazanie na pracownika w okresie',
      'WYDZIAL','STRING[16]','Wydział',
      'T','STRING[9]','Nr teczki',
      'PLAN','STRING[1]', 'Status planowania',
      'OD','DATE', 'Od',
      'DO','DATE', 'Do',
      'SZEF','STRING[60]','Przełożony',
      'SZEF_REF','STRING[16]','Wskazanie na przełożonego'
   )
?};

_msc_od:=date(_rok,_msc,1);
_msc_do:=date(_rok,_msc,0);
_ndx_do:=A_OKR.ndx_tmp('',1,'DO',,);
_size:=0;

P.cntx_psh();
OSOBA.cntx_psh();
UD_SKL.cntx_psh();
A_OKR.cntx_psh();
A_OKR.index(_ndx_do);
A_OKR.prefix();
{? A_OKR.find_ge(_msc_od)
|| {!
   |? {? (A_OKR.OD<=_msc_do) & (A_OKR.DO>=_msc_od)
      || _size:=0;
         A_OKRP.cntx_psh();
         A_OKRP.index('A_OKPP');
         A_OKRP.prefix(A_OKR.ref());
         {? A_OKRP.first()
         || _size:=A_OKRP.size();
            {!
            |? _p_od:={? A_OKRP.OD<_msc_od || _msc_od || A_OKRP.OD ?};
               _p_do:={? A_OKRP.DO>_msc_do || _msc_do || A_OKRP.DO ?};
               _m_status:=exec('getStatusM_Plan','okres',A_OKRP.ref(),_rok,_msc);
               {? _p_od<=_msc_do & _p_do>=_msc_od & _status*_m_status & (_grafik='' | A_OKRP.P().GRAFIK=_grafik)
               || _tab.blank(1);
                  A_OKRP.P();
                  _tab.WYDZIAL:=P.WYDZIAL().SYMBOL;
                  _tab.T:=P.T;
                  _tab.P_REF:=$P.ref();
                  _tab.A_OKRP:=$A_OKRP.ref();
                  _tab.NAZWISKO:=P.OSOBA().NAZWISKO;
                  _tab.IMIE:=OSOBA.PIERWSZE;
                  _tab.PLAN:=_m_status;
                  _tab.OD:=_p_od;
                  _tab.DO:=_p_do;
                  _szef:=exec('prac_nad','stanprac',P.ref(),0,'TYPPOZ','PLANCZP',,1);
                  {? _szef.first()
                  || _tab.SZEF:=_szef.IMIE+' '+_szef.NAZWISKO;
                     _tab.SZEF_REF:=_szef.P_SQL
                  ?};
                  obj_del(_szef);
                  _tab.add()
               ?};
               A_OKRP.next()
            !}
         ?};
         A_OKRP.cntx_pop()
      ?};
      A_OKR.next()
   !}
?};
A_OKR.ndx_drop(_ndx_do);
A_OKR.cntx_pop();
UD_SKL.cntx_pop();
OSOBA.cntx_pop();
P.cntx_pop();
_tab


\lock_A_OKR
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Zakłada blokadę dla rekordu tabeli A_OKR.
::   WE: _a [REFERENCE] - wskazanie na rekord tabeli A_OKR
::   WY:    [STRING]    - pusty napis w razie powodzenia, lub komunikat błędu
::  OLD: \lock_A_OKR/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_pres('_a')=type_of(null()) || _a || return(0) ?};
_res:='';
_blk_sid:=exec('blk_lock','#table','A_OKR',_ref,,2);
{? _blk_sid<>A_OKR.ses_id()
|| A_OKR.cntx_psh();
   A_OKR.clear();
   {? A_OKR.seek(_ref)
   || _res:='Okres rozliczeniowy jest właśnie '+{? A_OKR.S_PLAN='Z' || 'otwierany' || 'zamykany' ?}+' do planowania'+
            ' przez użytkownika \''+A_OKR.ses_info(_blk_sid,'log_name')+'\' '+
              'na terminalu \''+A_OKR.ses_info(_blk_sid,'log_tty')+'\'.'+
              {? cli_ver()='mbasic'
              || ' Należy odświeżyć dane i spróbować ponownie.'
              || ''
              ?}
   ?};
   A_OKR.cntx_pop()
?};
_res


\unlock_A_OKR
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30a]
:: OPIS: Zdejmuje blokadę dla rekordu tabeli A_OKR.
::   WE: _a [REFERENCE] - wskazanie na rekord tabeli A_OKRM
::   WY:
::  OLD: \unlock_A_OKR/plan_kal.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_pres('_a')=type_of(null()) || _a || return(~~) ?};
exec('blk_unlock','#table','A_OKR',_ref)


\a_okr_tba
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.02]
:: OPIS: Triggery dla tabeli A_OKR przed dodaniem pozycji.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
A_OKR.cntx_psh();
A_OKR.prefix();
1


\a_okr_taa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [17.42]
:: OPIS: Triggery dla tabeli A_OKR po dadaniu pozycji.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('wymiar','okres');
{? _a & do_state()=1 & exec('lic','#b_domain','POR')
|| A_OKRN.cntx_psh();
   A_OKRN.prefix();
   _value:='%1 - %2 %3'[$A_OKR.OD,$A_OKR.DO,A_OKR.NAZ().NAZ];
   A_OKRN.cntx_pop();
   exec('porsloit_oper','portal_slowniki','add',_value,,,,'OkresyRozliczeniowe')
?};
A_OKR.cntx_pop();
~~


\zadania_A_OKR
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.02]
:: OPIS: Zadania z okresów rozrachunkowych.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('todo_select','#b__box',A_OKR.uidref())


\a_okrp_werp_bfaz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.02]
:: OPIS: Zablokowanie planowania w okresie rozliczeniowym dla wybranego współpracownika.
::   WE:
::   WY:
::  OLD: \zamk_plan_prac/okres.fml
::----------------------------------------------------------------------------------------------------------------------
A_OKRP.get();
{? A_OKRP.S_PLAN<>'Z' & A_OKRP.S_PLAN<>'X'
|| {? ~FUN.ask('%1\n%2 %3?'['Czy zakończyć planowanie dla pracownika'@,A_OKRP.P().OSOBA().NAZWISKO,OSOBA.PIERWSZE])
   || return(0)
   ?}
|| FUN.emsg('%1\n%2'['Planowanie jest już zakończone.'@,'Przerwano działanie funkcji.'@]);
   return(0)
?};
A_OKRP.S_PLAN:='Z';
A_OKRP.put();
{? exec('zam_msc_plan','okres',A_OKRP.ref(),0,0,1,'Z')
|| FUN.info('Zamknięto planowanie.'@)
|| FUN.info('Planowanie nie zostało zamknięte.'@)
?};
~~


\a_okrp_werp_bfar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.02]
:: OPIS: Zamknięcie okresu rozliczeniowego dla wybranego współpracownika.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
A_OKRP.get();
:: Sprawdzenie czy miesiące w okresie rozliczeniowym zostały zamknięte.
A_OKRP_M.cntx_psh();
A_OKRP_M.index('A_OKRPM');
A_OKRP_M.prefix(A_OKRP.ref());
{? A_OKRP_M.first()
|| {!
   |? {? A_OKRP_M.STATUS<>'X' & exec('get_msc_status','grafik',date(A_OKRP_M.ROK,A_OKRP_M.MSC,1))<>'Z'
      || FUN.emsg('Przed zamknięciem rozliczenia w okresie należy zamknąć wszystkie miesiące rozliczeniowe.'@);
         A_OKRP_M.cntx_pop();
         return(~~)
      ?};
      A_OKRP_M.next()
   !}
?};
A_OKRP_M.cntx_pop();
:: Funkcja zamykająca okres pracownika.
exec('zamk_okr_prac','godziny',1);
~~


\a_okrp_werp_bfad
::----------------------------------------------------------------------------------------------------------------------
::  UTW: areKc [18.02]
:: OPIS: Otworzenie okresu rozliczeniowego dla wybranego współpracownika.
::   WE:
::   WY:
::  OLD: \odblokuj/okres.fml
::----------------------------------------------------------------------------------------------------------------------
A_OKRP.get();
{? A_OKRP.S_PLAN='X'
|| {? FUN.ask('Czy odblokować przenoszenie zbiorcze zamykania danych z okresu dla pracownika?'@)
   || A_OKRP.S_PLAN:='Z';
      A_OKRP.put()
   ?}
?};
~~


\opis_okr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [20.42]
:: OPIS: Elementy opisu dla wybranego okresu rozliczeniowego.
::   WE: _a - [REFERENCE] Wskazanie na wybrany okres rozliczeniowy
::   WY: tablica nazwana z elementami opisu zadania dla wybranego okresu rozliczeniowego
::----------------------------------------------------------------------------------------------------------------------
_tab:=obj_new('ZAW_DANE','A_OKRN_NAZWA','OD','DO');
:: inicjalizacja tablicy
{! _ii..obj_len(_tab) |! _tab[_ii]:='' !};

A_OKR.cntx_psh();
{? A_OKR.seek(_a,,1)
|| _tab.ZAW_DANE:='T';
   _tab.A_OKRN_NAZWA:=A_OKR.NAZ().NAZ;
   _tab.OD:=A_OKR.OD$1;
   _tab.DO:=A_OKR.DO$1
?};
A_OKR.cntx_pop();
_tab


\opis_mc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [20.42]
:: OPIS: Elementy opisu dla wybranego miesiąca rozliczeniowego.
::   WE: _a - [REFERENCE] Wskazanie na wybrany miesiąc rozliczeniowy.
::   WY: tablica nazwana z elementami opisu dla wybranego miesiąca rozliczeniowego
::----------------------------------------------------------------------------------------------------------------------
_tab:=obj_new('ZAW_DANE','R','M');
:: inicjalizacja tablicy
{! _ii..obj_len(_tab) |! _tab[_ii]:='' !};

A_OKRM.cntx_psh();
{? A_OKRM.seek(_a,,1)
|| _tab.ZAW_DANE:='T';
   _tab.R:=A_OKRM.R;
   _tab.M:=A_OKRM.M
?};
A_OKRM.cntx_pop();
_tab


\a_okr_tbd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [22.26]
:: OPIS: Trigger dla tabeli A_OKR przed usunięciem pozycji.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
{? exec('lic','#b_domain','POR')
|| {? A_OKR.S='O'
   || A_OKRN.cntx_psh();
      A_OKRN.prefix();
      _value:='%1 - %2 %3'[$A_OKR.OD,$A_OKR.DO,A_OKR.NAZ().NAZ];
      A_OKRN.cntx_pop();
      _result:=exec('porsloit_oper','portal_slowniki','del',_value,,,,'OkresyRozliczeniowe')
   ?}
?};
_result


\a_okr_tap
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [22.26]
:: OPIS: Trigger dla tabeli A_OKR po poprawieniu pozycji.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? ~_a | do_state()<>1 | ~exec('lic','#b_domain','POR') || return() ?};

_a_okrn:=obj_new('old','new');
_a_okrn.old:=bfld('NAZ');
_a_okrn.new:=A_OKR.NAZ;
_naz:=obj_new('old','new');
A_OKRN.cntx_psh();
A_OKRN.prefix();
_naz.old:={? A_OKRN.seek(_a_okrn.old,,1) || A_OKRN.NAZ || '' ?};
_naz.new:=A_OKR.NAZ().NAZ;
A_OKRN.cntx_pop();

_od:=obj_new('old','new');
_od.old:=bfld('OD');
_od.new:=A_OKR.OD;

_do:=obj_new('old','new');
_do.old:=bfld('DO');
_do.new:=A_OKR.DO;

_value_old:='%1 - %2 %3'[$_od.old,$_do.old,{? _naz.old<>'' || _naz.old || _naz.new ?}];
_value:='%1 - %2 %3'[$_od.new,$_do.new,_naz.new];

exec('czytaj','#stalesys',,XINFO,'POR_CONF');
_status_old:=bfld('S');
_status_new:=A_OKR.S;
{? XINFO.POR_CONF='J' & _status_old<>_status_new
:: sprawdzenie czy nie zmienił się status okresu rozliczeniowego (obsługujemy tylko po wgraniu 22.26_04)
|| {? _status_new='Z'
::    po zamknięciu okresu usuwamy wpis w słowniku
   || exec('porsloit_oper','portal_slowniki','del',_value_old,,,,'OkresyRozliczeniowe')
   |? _status_new='O'
::    po otwarciu okresu dodajemy wpis do słownika
   || exec('porsloit_oper','portal_slowniki','add',_value,,,,'OkresyRozliczeniowe')
   ?}
|? _od.old<>_od.new | _do.old<>_do.new | _a_okrn.old<>_a_okrn.new
:: sprawdzenie czy nie zmieniły się daty lub nazwa okresu
|| exec('porsloit_oper','portal_slowniki','put',_value_old,,_value,,'OkresyRozliczeniowe')
?};
~~


\delDaneRCP4Prac
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [23.25]
:: OPIS: Usuwa dane dot. rozliczeń czasu pracy
::   WE: _a  [REFERENCE] - wskazanie na pracownika
::       _b  [DATE]      - data od
::       _c  [DATE]      - data do
::      [_d] [REFERENCE] - wskazanie na okres rozliczeniowy - jeżeli podane to nastąpi przeliczenie okresu [null*/ref]
::      [_e] [NUMBER]    - czy kasować zapisy pierwotne z czytników? [0*/1]
::      [_f] [NUMBER]    - czy kasować start/stopy z Portalu HR? [0*/1]
::      [_g] [NUMBER]    - czy inicjować obiekt KOMM i odkładać konteksty czyszczonych tabel? [0*/1]
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
:: powrot w przypadku zerwanej transakcji
{? do_state()=2 || return(_result) ?};

 _p_ref:={? var_pres('_a')=type_of(null) & _a<>null() & ref_tab(_a)=P || _a || return(_result) ?};
    _od:={? var_pres('_b')=type_of(#0) || _b || return(_result) ?};
    _do:={? var_pres('_c')=type_of(#0) || _c || return(_result) ?};
   _okr:={? var_pres('_d')=type_of(null()) & _d<>null() & ref_tab(_d)=A_OKR || _d || null() ?};
_del_zp:={? var_pres('_e')=type_of(0)  || _e || 0 ?};
_del_ss:={? var_pres('_f')=type_of(0)  || _f || 0 ?};
  _init:={? var_pres('_g')=type_of(0)  || _g || 0 ?};

_rok:=_od~1;
_msc:=_od~2;

:: obiekt do zarządzania indeksami tabeli R_ERRKAL i przełączania się pomiędzy maskami tabel R_ERRKAL i R_ERRMAX
_obj:=obj_new('use','ndx_name','drop_ndx');
:: nazwa zapamiętanego indeksu tymczasowego
_obj.ndx_name:='';
:: formuła usuwająca indeks tymczasowy z tabeli R_ERRKAL
_obj.drop_ndx:="
   {? .ndx_name<>''
   || {? R_ERRKAL.ndx_drop(.ndx_name)
      || .ndx_name:='';
         1
      ?}
   || 1
   ?}
";
:: formuła na zmianę maski tabel R_ERRKAL i R_ERRMAX
_obj.use:="
   _rok:={? var_pres('_a')=type_of(0) || _a || return(0) ?};
   _msc:={? var_pres('_b')=type_of(0) || _b || return(0) ?};
   {? .drop_ndx()
   || MASK.Use('R_ERRKAL',_rok,_msc);
      .ndx_name:=R_ERRKAL.ndx_tmp(,1,'P',,,'D',,);
      R_ERRKAL.index(.ndx_name);
      MASK.Use('R_ERRMAX',_rok,_msc);
      R_ERRMAX.index('R_ER_DZ');
      1
   ?}
";

{? _init
|| KOMM.init(
      MS.fld_len('OSOBA','NAZWISKO')+MS.fld_len('OSOBA','PIERWSZE')+MS.fld_len('P','T')+15,,
      ' Uwagi po wykonaniu usunięcia danych.'@,''
   );
   A_OKRP.cntx_psh();
   A_OKRP.index('A_OKRPR');
   R_ERRKAL.cntx_psh();
   R_ERRMAX.cntx_psh();
   {? ~_obj.use(_rok,_msc) || undo() ?}
?};

:: zalozenie transakcji
_mydo:=do_state()=0;
{? _mydo || do() ?};

P.cntx_psh();
P.index('OSOBA');
P.prefix();
{? P.seek(_p_ref,,1)
|| _komm:=obj_new('lp','lpadd','locked','lempty','luse');
   _komm.lempty:=0;
   _komm.lp:=KOMM.sect_beg(
      ' %1 %2 %3:'[P.OSOBA().NAZWISKO,P.OSOBA().PIERWSZE,'[nr teczki - %1]'@[form(P.T)]],'xwin16.png:100',,1
   );
   KOMM.sect_end();
   _komm.locked:=KOMM.sect_beg(
      ' Dane zablokowane do rozliczenia, usunięcie niemożliwe'@,'xwin16.png:157',,1
   );
   KOMM.sect_end();
   _komm.luse:=KOMM.sect_beg(
      ' Błąd podczas zmiany maski tabeli - wszystkie zmiany zostaną wycofane'@,'xwin16.png:3',,1
   );
   KOMM.sect_end();
   _error:=0;

   {! _ii:=#_od..#_do
   |? _error=0
   |! _dt:=#_ii;

      {? exec('isBlokada','prc_rozlicz',_p_ref,_dt)
      || KOMM.chngroot(_komm.locked,_komm.lp);
         _komm.lpadd:=KOMM.add(' '+$_dt,'xwin16.png:83',,1);
         KOMM.chngroot(_komm.lpadd,_komm.locked);
         _komm.lempty+=1

      || _rok_new:=_dt~1;
         _msc_new:=_dt~2;
         {? _rok_new<>_rok | _msc_new<>_msc
         || _rok:=_rok_new;
            _msc:=_msc_new;
            {? ~_obj.use(_rok,_msc)
            || undo();
               KOMM.chngroot(_komm.luse,_komm.lp);
               _komm.lpadd:=KOMM.add(' '+$_dt,'xwin16.png:83',,1);
               KOMM.chngroot(_komm.lpadd,_komm.luse);
               _error+=1
            ?}
         ?};

         {? _error
         || _result:=0
         || R_ERRKAL.prefix(_p_ref,_dt);
:: Usunięcie zapisów z tabeli błędów kalendarza współpracownika
            {? R_ERRKAL.first()
            || {! |? R_ERRKAL.del() !}
            ?};

:: Usunięcie zapisów z tabeli błędów przekroczenia maksymalnego czasu pracy
            R_ERRMAX.prefix(_p_ref);
            {? R_ERRMAX.first()
            || {! |? R_ERRMAX.del() !}
            ?};

:: Usunięcie zapisów z tabel WE/WY, kwalifikacji czasu pracy, odbiorów za nadgodziny oraz tabeli przepracowanych dni
            exec('usun_wewy','prc_wewy',_p_ref,_rok,_msc,,_dt,_del_zp,,_del_ss);
            _result:=1
         ?}
      ?}
   !};
   {? _error=0 & _okr
   || A_OKRP.prefix(_okr,_p_ref);
      {? A_OKRP.first()
      || params_exec('oblicz','okres',1)
      ?}
   ?};
   {? ~_komm.lempty
   || KOMM.del(_komm.locked);
      KOMM.del(_komm.lp)
   ?};
   {? _error=0 || KOMM.del(_komm.luse) ?};
   obj_del(_komm)
?};
P.cntx_pop();

_obj.drop_ndx();
{? _mydo || end() ?};
obj_del(_obj);

{? _init
|| R_ERRMAX.cntx_pop();
   R_ERRKAL.cntx_pop();
   A_OKRP.cntx_pop();

   KOMM.select()
?};

_result

:Sign Version 2.0 jowisz:1045 2024/01/11 12:41:20 6c643dbde6eff4f36d05506e824e3df0cf7670812ae5d9cea00dde230f5e6d06e2b3f78ad445e1e19a518b1f01e169f0db955a9818a6e300f06705ea1d7e8936f2dfa16db676875205e2463ec0a67a84d2f8828f90ee6853c2375a582b1227b7bc7bc03ee72f5b2a9ffb40d9d7d40e39a812527dc347a04ec5368fdf2cbd426a
