:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: stanprac.fml
:: Utworzony: 23.03.2015
:: Autor: jaws
::======================================================================================================================
:: Zawartość: Plik zawiera formuły obsługi tabel opisujących stanowisko.
::======================================================================================================================


\szukaj_sto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Wyszukuje stanowisko w jednostce organizacyjnej.
::   WE: _a - wskazanie na jednostkę
::       _b - wskazanie na stanowisko
::   WY: wskazanie na stanowisko w jednostce lub null jeśli nie znaleziono zapisu
::  OLD: \ust_sto/stanprac.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null;
STO.cntx_psh;
STO.index('UNIQUE');
STO.prefix(_a);
{? STO.find_key(_b)
|| _ref:=STO.ref()
?};
STO.cntx_pop;
_ref


\szukaj_psto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Wyszukuje pozycję w organizacji dla danego stanowiska w jednostce organizacyjnej.
::   WE: _a - wskazanie na stanowisko w jednostce organizacyjnej
::       _b - wskazanie na opis pozycji w organizacji
::  OLD: \ust_psto/stanprac.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null;
PSTO.cntx_psh();
PSTO.index('PSTO');
PSTO.prefix(_a);
{? PSTO.find_key(_b)
|| _ref:=PSTO.ref()
?};
PSTO.cntx_pop();
_ref


\stn_addb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Wyzwalacz przed dołączeniem tabeli STN
::----------------------------------------------------------------------------------------------------------------------
exec('stn_modb','stanprac')


\stn_putb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Wyzwalacz przed poprawieniem tabeli STN
::----------------------------------------------------------------------------------------------------------------------
exec('stn_modb','stanprac')


\stn_modb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Aktualizacja pól tabeli STN
::----------------------------------------------------------------------------------------------------------------------
{? STN.SP='N'
|| STN.RP:=null;
   STN.S_ZUS:=null
?};
1


\stn_puta
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Wyzwalacz po poprawieniu tabeli STN
::   WE: _a [INTEGER] - Wynik właściwej operacji.
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? _a & do_state()=1 & STN.ST<>bfld('ST')
|| STO.cntx_psh;
   STO.index('UD_SKL');
   STO.prefix(STN.ref());
   _loop:=STO.first();
   {!
   |? _loop
   |! STO.put();
      _loop:=STO.next()
   !};
   STO.cntx_pop();
   exec('idput_ndx','#table',H,'STN',STN.ref())
?};
~~


\stn_delb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Wyzwalacz przed usunięciem tabeli STN
::----------------------------------------------------------------------------------------------------------------------
1


\stn_efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Formuła odpowiedzialna za dynamiczne ustawianie właściwości pól tabeli STN. Formuła wywoływana jest w dwóch
::       kontekstach pracy:
::          - Po redagowaniu konkretnego pola, które determinuje właściwości wyświetlania innych pól.
::          - Przed wyświetleniem okna redagowania (przed właściwymi akcjami Dołącz, Popraw, Wyświetl), ustawia
::            właściwości wszystkich pól (wymagających tego).
::       Kontekst pracy jest określany na podstawie argumentu wywołania.
::   WE: [_a] [STRING] - Kontekst pracy:
::             '1' - Obsługa jednego pola [domyślnie].
::             '*' - Obsługa wszystkich pól.
::       [_b] [TABLE]  - Uchwyt tabeli, w oknie redagowania której znajdują sie pola. Jeżeli _a='1', parametr jest
::             opcjonalny - zostanie przyjęta bieżąca tabela.
::       [_c] [STRING] - Akronim okna, w którym mają być ustawione właściwości pól. Jeżeli _a='1', parametr jest
::             opcjonalny - zostanie przyjęte bieżące okno.
::       [_d] [STRING] - Akronim pola, którego wartość determinuje właściwości wyświetlania innych pól. Parametr ma
::             znaczenie wyłącznie dla _a='1'. [Domyślnie: bieżące pole].
::   WY: 0 - Błąd argumentów wywołania.
::       1 - Argumenty poprawne (właściwości ustawione).
::----------------------------------------------------------------------------------------------------------------------
_tryb:={? var_pres('_a')=type_of('') & (_a='1' | _a='*') || _a || '1' ?};
{? var_pres('_b')=type_of(H)
|| _tab:=_b
|? _tryb='1'
|| _tab:=cur_tab(1,1)
|| return(0)
?};
{? var_pres('_c')=type_of('')
|| _we:=_c
|? _tryb='1'
|| _we:=cur_win(1,1)
|| return(0)
?};
{? var_pres('_d')=type_of('')
|| _fld:=_d
|? _tryb='1'
|| _fld:=cur_afld()
|| _fld:=''
?};

{? _fld='' | _fld='SP'
|| _sval:=$(STN.SP='T');
   _tab.efld_opt(_we,'enable='+_sval,,'RP');
   _tab.efld_opt(_we,'mark='+_sval,,'RP','KOD');
   _tab.efld_opt(_we,'enable='+_sval,,'S_ZUS');
   _tab.efld_opt(_we,'mark='+_sval,,'S_ZUS','KOD')
?};

1


\stn_sp_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Po redagowaniu pola STN.SP.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('stn_efld_opt','stanprac')


\stn_rp_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Przed redakcją pola RP tabeli STN
::  OLD: \stn_be_sp/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
STN.SP='T' & STN.S_ZUS=null


\stn_s_zus_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Przed redakcją pola S_ZUS tabeli STN
::  OLD: \stn_be_sp/kartprac.fml
::----------------------------------------------------------------------------------------------------------------------
STN.RP<>null


\stn_db
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Obsługa akcji "Dołącz - przed" dla tabeli STN.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
STN.blank();
exec('stn_efld_opt','stanprac','*',STN,'RED')


\stn_da
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.02]
:: OPIS: Obsługa akcji "Dołącz - po" dla tabeli STN.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? STN.f_active()
|| STN.f_add()
?};
~~


\stn_pb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Obsługa akcji "Popraw - przed" dla tabeli STN.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('stn_efld_opt','stanprac','*',STN,'RED')


\stn_ib
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Wyświetlenie załącznika dla tabeli STN
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? STN.ZAL<>null
|| exec('bl_view','#blob',STN,'ZAL')
|| FUN.info('Brak dokumentu opisu stanowiska.'@)
?}


\stn_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Rekord po okienek tabeli STN
::  OLD: \spr_stn/stanprac.fml
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.table(STN,-menu_txt='popraw',,'ST');

{? type_of(_chk)<>type_of(0) | ~_chk
|| return(_chk)
?};

{? STN.SP='T' & (_chk:=__CHK.record(STN,,'RP','S_ZUS'))<>''
|| return(_chk)
?};

1


\stn_bw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Obsługa akcji "Wyświetl - przed" dla tabeli STN.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('stn_efld_opt','stanprac','*',STN,'RED');
STN.display()


\sto_ref
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Wskazanie na stanowisko w jednostce organizacyjnej
::  OLD: \sto/war_tech.fml
::----------------------------------------------------------------------------------------------------------------------
STO.ref()


\sto_addb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Wyzwalacz przed dołączeniem tabeli STO
::----------------------------------------------------------------------------------------------------------------------
exec('sto_modb','stanprac')


\sto_putb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Wyzwalacz przed poprawieniem tabeli STO
::----------------------------------------------------------------------------------------------------------------------
exec('sto_modb','stanprac')


\sto_modb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Obsługa anomalii tabeli STO
::----------------------------------------------------------------------------------------------------------------------
STO.ST:=STO.STN().ST;
1


\sto_ib
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Wyświetlenie załącznika dla tabeli STO
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
{? STO.ZAL<>null
|| exec('bl_view','#blob',STO,'ZAL')
|| FUN.info('Brak dokumentu opisu stanowiska.'@)
?}


\sto_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Obsługa akcji "Rekord po" dla tabeli STO.
::  OLD: \spr_sto/stanprac.fml
::----------------------------------------------------------------------------------------------------------------------
__CHK.table(STO,-menu_txt='popraw',,'UD_SKL','STN')


\pozworg_puta
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Wyzwalacz po poprawieniu tabeli POZWORG
::   WE: _a [INTEGER] - Wynik właściwej operacji.
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? ~(_a & do_state()=1)
|| return()
?};

{? POZWORG.KOD<>bfld('KOD') | POZWORG.OPIS<>bfld('OPIS')
|| PSTO.cntx_psh;
   PSTO.index('POZWORG');
   PSTO.prefix(POZWORG.ref());
   _loop:=PSTO.first();
   {!
   |? _loop
   |! PSTO.put();
      _loop:=PSTO.next()
   !};
   PSTO.cntx_pop()
?};

{? POZWORG.KOD<>bfld('KOD') & exec('lic','#b_domain','POR')
|| _TAB:=sql('select H.REFERENCE as REF from H where H.POZWORG=:_a',POZWORG.ref());
:: Aktualizacja 22.26_04 dodała do DEF-a indeks POZWORG do tabeli H. Powyższe zapytanie będzie w stanie
:: wykorzystać go, co jest elementem optymalizacji. Jeżeli jednak definicja indeksu NIE została przeniesiona,
:: to zapytanie sql nadal będzie działało, tylko wolniej.
   {? _TAB.first()
   || H.cntx_psh();
      H.prefix();
      H.trig_off('*','*');
      {!
      |? {? H.seek(_TAB.REF) & H.put(,1)
         || _TAB.next()
         || undo();
            0
         ?}
      !};
      H.trig_on('*','*');
      H.cntx_pop()
   ?}
?};
~~


\pozworg_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Obsługa akcji "Rekord - po" dla tabeli POZWORG.
::----------------------------------------------------------------------------------------------------------------------
__CHK.table(POZWORG,-menu_txt='popraw',,'KOD','OPIS')


\psto_addb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Wyzwalacz przed dołączeniem tabeli PSTO
::----------------------------------------------------------------------------------------------------------------------
exec('psto_modb','stanprac')


\psto_putb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Wyzwalacz przed poprawieniem tabeli PSTO
::----------------------------------------------------------------------------------------------------------------------
exec('psto_modb','stanprac')


\psto_modb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Obsługa anomalii tabeli PSTO
::----------------------------------------------------------------------------------------------------------------------
PSTO.KOD:=PSTO.POZWORG().KOD;
PSTO.OPIS:=PSTO.POZWORG().OPIS;
PSTO.UD_SKL:=PSTO.STO().UD_SKL;
1


\psto_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [17.00]
:: OPIS: Obsługa ackji "Rekord po" dla tabeli PSTO.
::----------------------------------------------------------------------------------------------------------------------
__CHK.table(PSTO,-menu_txt='popraw',,'POZWORG')


\sto_puta
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PT [17.00]
:: OPIS: Wyzwalacz po poprawieniu tabeli STO
::   WE: _a [INTEGER] - Wynik właściwej operacji.
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
{? _a & do_state()=1 & STO.UD_SKL<>bfld('UD_SKL')
|| PSTO.cntx_psh;
   PSTO.index('PSTO');
   PSTO.prefix(STO.ref());
   _loop:=PSTO.first();
   {!
   |? _loop
   |! PSTO.put();
      _loop:=PSTO.next()
   !};
   PSTO.cntx_pop()
?};
~~


\tab_zal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Tworzy tabelę zawierąjacą informacje o podwładnych lub przełożonych pracownika.
::----------------------------------------------------------------------------------------------------------------------
tab_tmp(1,
   'L',       'INTEGER','Poziom'@,
   'NAZWISKO','STRING[%1]'[$MS.fld_len('OSOBA','NAZWISKO')],'Nazwisko'@,
   'IMIE',    'STRING[%1]'[$MS.fld_len('OSOBA','PIERWSZE')],'Imię'@,
   'T',       'STRING[%1]'[$MS.fld_len('P','T')],'Nr teczki'@,
   'WYDZIAL', 'STRING[%1]'[$MS.fld_len('UD_SKL','SYMBOL')],'Jednostka organizacyjna (pracownik)'@,
   'STN',     'STRING[%1]'[$MS.fld_len('STN','ST')],'Stanowisko'@,
   'POZWORG', 'STRING[%1]'[$MS.fld_len('POZWORG','KOD')],'Pozycja w organizacji'@,
   'ZA',      'STRING[%1]'[$MS.fld_len('P','ZA')],'Zatrudniony?'@,
   'ID',      'INTEGER','Identyfikator'@,
   'P',       'INTEGER','Pracownik'@,
   'P_SQL',   'STRING[16]','Pracownik (SQL REF)'@,
   'OSOBA',   'INTEGER','Osoba'@,
   'J',       'STRING[%1]'[$(_len:=MS.fld_len('UD_SKL','SYMBOL'); {? _len<20 || 30 || _len ?})],
              'Jednostka organizacyjna'@,
   'ZRODLO',  'STRING[30]','Źródło pochodzenia'@,
   'P_NAD',   'INTEGER','Przełożony'@,
   'F_ZATR',  'STRING[1]','Forma współpracy'@,
   'CZY_POD', 'STRING[1]','Czy podwładny?'@,
   'PATH',    'STRING[1]','Ścieżka'@,
   'P_ZAS',   'STRING[1]','Czy pracownik zastępowany?'@,
   'EDYCJA',  'STRING[1]','Edycja'@,
   'ZS_KOD',  'STRING[%1]'[$MS.fld_len('SLO_KOD','KOD')],'Kod typu zależności'@
)


\add_zal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Dodaje zapis do tabeli zależności służbowych współpracowników.
::   WE: _a - alias tabeli tymczasowej
::       _b - wskazanie współpracownika
::       _c - jednostka dla wnioskow
::       _d - poziom zależności
::       _e - źrodło pochodzenia
::       _f - przełożony
::       _g - określenie czy zapis dla podwładnego (0) czy przełożonego (1)
::       _h - określenie czy zapis dla współpracownika zastępowanego
::       _i - z czego wynika zleżność (Z - zastępstwa, O - obowiązki, B - bezposredni podwladni, P - przypisani)
::       _j - czy możliwa edycja (wykorzystywane w webTermie)
::       _k - kod typu zależności
::   WY: 1/0 - sukces/porażka
::----------------------------------------------------------------------------------------------------------------------
_a.blank();
{? exec('set_zal','stanprac',
      _a,_b,_c,_d,
      {? var_pres('_e')=type_of('') || _e || '' ?},
      {? var_pres('_f')=type_of(null) | var_pres('_f')=type_of(0) || _f ?},
      {? var_pres('_g')=type_of(0)  || _g || 0 ?},
      {? var_pres('_h')=type_of('') || _h || '' ?},
      {? var_pres('_i')=type_of('') || _i || 'B' ?},
      {? var_pres('_j')=type_of('') || _j || 'N' ?},
      {? var_pres('_k')=type_of('') || _k || '' ?}
   )
|| _a.add()
?}


\mod_zal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Modyfikuje zapis w tabeli zależności służbowych współpracowników.
::   WE: _a - alias tabeli tymczasowej
::       _b - wskazanie współpracownika
::       _c - jednostka dla wnioskow
::       _d - poziom zależności
::       _e - źrodło pochodzenia
::       _f - przełożony
::       _g - określenie czy zapis dla podwładnego (0) czy przełożonego (1)
::       _h - określenie czy zapis dla współpracownika zastępowanego
::       _i - z czego wynika zleżność (Z - zastępstwa, O - obowiązki, B - bezposredni podwladni, P - przypisani)
::       _j - czy możliwa edycja (wykorzystywane w webTermie)
::       _k - kod typu zależności
::   WY: 1/0 - sukces/porażka
::----------------------------------------------------------------------------------------------------------------------
{? exec('set_zal','stanprac',_a,_b,_c,_d,
      {? var_pres('_e')=type_of('') || _e || '' ?},
      {? var_pres('_f')=type_of(null) | var_pres('_f')=type_of(0) || _f ?},
      {? var_pres('_g')=type_of(0)  || _g || 0 ?},
      {? var_pres('_h')=type_of('') || _h || '' ?},
      {? var_pres('_i')=type_of('') || _i || 'B' ?},
      {? var_pres('_j')=type_of('') || _j || 'N' ?},
      {? var_pres('_k')=type_of('') || _k || '' ?}
   )
|| _a.put()
?}


\set_zal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Ustawia wartości w tabeli zależności służbowych współpracowników.
::   WE: _a - alias tabeli tymczasowej
::       _b - wskazanie współpracownika
::       _c - jednostka dla wnioskow
::       _d - poziom zależności
::       _e - źrodło pochodzenia
::       _f - przełożony
::       _g - określenie czy zapis dla podwładnego (0) czy przełożonego (1)
::       _h - określenie czy zapis dla współpracownika zastępowanego
::       _i - z czego wynika zleżność (Z - zastępstwa, O - obowiązki, B - bezposredni podwladni, P - przypisani)
::       _j - czy możliwa edycja (wykorzystywane w webTermie)
::       _k - kod typu zależności
::   WY: 1/0 - sukces/porażka
::----------------------------------------------------------------------------------------------------------------------
_test:=0;
P.cntx_psh();
{? P.seek(_b,,1)
|| _a.P:=#P.ref();
   _a.OSOBA:=#P.OSOBA;
   _a.NAZWISKO:=P.OSOBA().NAZWISKO;
   _a.IMIE:=OSOBA.PIERWSZE;
   _a.T:=form(P.T);
   _a.WYDZIAL:=P.WYDZIAL().SYMBOL;
   _a.STN:=P.ST().ST;
   _a.POZWORG:=P.POZWORG().KOD;
   _a.ZA:=P.ZA;
   _a.ID:=P.IP;
   _a.J:=_c;
   _a.L:=_d;
   _a.P_SQL:=$P.ref();
   _a.ZRODLO:=_e;
   _a.P_NAD:=_f;
   _a.F_ZATR:=P.F_ZATR().KOD;
   _a.P_ZAS:=_h;
   _a.PATH:=_i;
   _a.EDYCJA:=_j;
   _a.ZS_KOD:=_k;
   {? ~_a.find_rec()
   || _test:=1
   ?}
?};
P.cntx_pop();
_test


\lvl_zal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Normalizuje liczby porządkujące listy podwładnych/przełożonych.
::   WE: _a - alias tabeli tymczasowej
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_BUF:=_a;

{? _BUF.first()
|| {! _ii:=1
   |? {? _BUF.L<>_ii
      || _BUF.L:=_ii;
         _BUF.put()
      ?};
      _BUF.next()
   !}
?};
~~


\cln_zal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.37]
:: OPIS: Usuwa z tabeli powielone wystąpienia współpracownika na liście przełożonych/podwładnych.
::   WE: _a TABLE - alias tabeli zawierającej listę współpracowników
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_BUF:=_a;

_loop:=_BUF.first();
{!
|? _loop
|! _emp:=_BUF.P;
   _ref:=_BUF.ref();
   {? _BUF.find_tab(0,'P',,'=',_emp) & _BUF.ref()<>_ref
::    powielone wystąpienie
   || _BUF.del();
      _loop:=_BUF.seek(_ref)
   || _loop:=_BUF.next()
   ?}
!};
~~


\prac_zal_max
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Sprawdza, czy dany poziom miesci sie w dopuszczalym przez konfiguracje przedziale.
::   WE: _a - poziom
::   WY: 0/1 zaleznie od tego, czy podany poziom jest akceptowalnl
::----------------------------------------------------------------------------------------------------------------------
_max:=#PAR_SKID.get(235);
{? _max>0
|| _a<=_max
|| 1
?}


\prac_pod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Tworzy tabelę tymczasową zawierajacą listę podwładnych wskazanej osoby.
::   WE: _a OSOBA - wskazanie osoby, dla której mają być wyszukani podwładni
::       _b [STRING] - symbol typu słownika, jeśli pominięty lub inny niż napis, to przyjęty będzie domyślny
::       _c [STRING] - kodu zależności służbowych, jeśli pominięty lub inny niż napis, to przyjęty będzie domyślny
::       _d [TABLE] - alias do bufora danych
::       _e [INTEGER] - poziom zaleznosci
::       _f [STRING] - path
::       _g [INTEGER] - liczba wywołań rekurencyjnych
::UWAGA: argumenty _b, _e, _f pozostały na liście wyłącznie dla zgodności wywołań poprzedniej wersji
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_ref:=_a;
_slo:='TYPPOZ';
_a_c:={? var_pres('_c')=type_of('') & form(_c)<>'' || _c || ~~ ?};
_typ:=exec('ustal','zs_typ',_a_c);
_sub:=0;

:: tabela listy podwładnych
{? var_pres('_d')<>type_of(SYSLOG)
|| _BUF:=exec('tab_zal','stanprac');
   _BUF.index(_BUF.ndx_tmp(,,'L',,))
|| _BUF:=_d;
   _sub:=1
?};
:: głębokość zależności
_max:=#PAR_SKID.get(235);

:: głębokość rekurencji (maksymalnie jedno wywołanie)
_rcc:={? var_pres('_f')=type_of(0) || {? _f>0 || _f ?} ?};

:: osoba i typ muszą być określone
{? _ref=null | _typ.dane.REF=null | _rcc>1
|| return(_BUF)
?};

ZS_DEF.cntx_psh();
P.cntx_psh();
P.index('PRACOSOW');
P.prefix(exec('ref_firma','ustawienia'),_ref);
_loop:=P.first();
{!
|? _loop
:: osoba jako współpracownik
|! {? exec('szukaj','zs_def',P.ref(),_typ.dane.SLO_KOD,,1)
   || _poz_od:=ZS_DEF.POZIOM;
      _nad:=ZS_DEF.P;
      P.cntx_psh();
      ZS_DEF.index('SCIEZKA');
      ZS_DEF.prefix(ZS_DEF.SCIEZKA+ZS_DEF.TOKEN);
      _loop:=ZS_DEF.first();
      {!
      |? _loop
::       podwładni współpracownika
      |! _poziom:=ZS_DEF.POZIOM-_poz_od;
::       kontrola poziomu zagłębienia
         {? _max=0 | _poziom<=_max
         || ZS_DEF.P();
            exec('add_zal','stanprac',_BUF,
               P.ref(),
               P.WYDZIAL().SYMBOL,
               _poziom,
               exec('opis_zs','stanprac'),
               _nad,,,
               'P'
            )
         ?};
         _loop:=ZS_DEF.next()
      !};
      P.cntx_pop()
   ?};
   _loop:=P.next()
!};

{? _sub=0
:: =====================
:: uwzględnij zastępstwa
:: =====================
|| P_PZ.cntx_psh();
   P_PZ.index('PZ_OSO1');
   P_PZ.prefix('Z',_typ.lisc.SLO_KOD,_ref);
   _loop:=P_PZ.first();
   {!
   |? _loop
   |! _test:=(
         (P_PZ.CO='N' & P_PZ.OD<=date()) |
         (P_PZ.OD<=date() & date()<=P_PZ.DO)
      );
      {? _test & P_PZ.NB='T' & ~exec('czy_jest','nieobecnosc',P_PZ.P)
::       zastępowany współpracownik jest obecny
      || _test:=0
      ?};
      {? _test<>0
::       dodaj podwładnych zastępowanego współpracownika
      || exec('prac_pod','stanprac',P_PZ.P_OSO,,_typ.lisc.KOD_KOD,_BUF)
      ?};
      _loop:=P_PZ.next()
   !};
   P_PZ.cntx_pop();

   {!
   |? _BUF.blank(1);
      _BUF.OSOBA:=#_ref;
      _BUF.find_rec()
::    usuń "siebie"
   |! _BUF.del()
   !}
?};

P.cntx_pop();
ZS_DEF.cntx_pop();

:: ==================================
:: uzupełnij z zależności dodatkowych
:: ==================================
ZS_DOD.cntx_psh();
ZS_DOD.index('TYP_DOD');
ZS_DOD.prefix(_typ.dane.REF);
{? ZS_DOD.first()
|| _add:='_a.blank(1);';
   _num:=_BUF.fld_num();
   {! _ii:=1.._num
   |! _add+='_a[%1]:=_b[%1];'[$_ii]
   !};
   _add:=$(_add+'_a.add()');
   _TMP:=exec('tab_zal','stanprac');

   {!
::    pobierz dodatkowe zależności służbowe do oddzielnej tabeli
   |? exec('prac_pod','stanprac',_ref,,ZS_DOD.KOD_DOD().KOD,_TMP,,,_rcc+1);
::    skopij zależności do tabeli wyniku
      _loop:=_TMP.first();
      {!
      |? _loop
      |! _add(_BUF,_TMP);
         _loop:=_TMP.del()
      !};
      ZS_DOD.next()
   !};

:: usuń ewentualne powielenia
   exec('cln_zal','stanprac',_BUF);
   obj_del(_TMP)
?};
ZS_DOD.cntx_pop();


_par_393:=PAR_SKID.get(393);
{? type_of(_par_393)=type_of('') & _par_393<>'N'
:: pomijaj na liście podwładnych pracowników zwolnionych
|| _BUF.cntx_psh();
   {? _BUF.first()
   || {!
      |? {? _BUF.ZA='T'
         || _BUF.next()
         || _BUF.del()
         ?}
      !}
   ?};
   _BUF.cntx_pop()
?};

_BUF


\prac_pod_old
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2006]
:: OPIS: Tworzy tabele tymczasowa zawierajaca liste podwladnych osoby o podanym ref'ie.
::   WE: _a - ref osoby dla ktorej maja byc wyszukani podwladni
::       _b - symbol slownika kodow, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::       _c - symbol kodu zaleznosci sluzbowych, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::       _d - alias do bufora danych
::       _e - poziom zaleznosci
::       _f - path
::UWAGA: Poprawnosc argumentu wywolania nie jest weryfikowana.
::----------------------------------------------------------------------------------------------------------------------
_begin:=0;
{? var_pres('_b')<>type_of('') | |_b='' || _b:='NIEZNANY' ?};
{? var_pres('_c')<>type_of('') | |_c='' || _c:='NIEZNANY' ?};
{? var_pres('_d')<>type_of(SYSLOG)
|| _d:=exec('tab_zal','stanprac');
   _nad_ndx:=_d.ndx_tmp(,,'P_NAD',,);
   _d.index(_nad_ndx);
   _d.index(_d.ndx_tmp(,,'NAZWISKO',,,'IMIE',,,'T',,));
   _begin:=1
?};
{? var_pres('_e')<>type_of(0) | _e<0 || _e:=1 ?};
{? var_pres('_f')<>type_of('') | |_f='' || _f:='B' ?};
:: sprawdzenie czy pobieramy podwladnych dynamicznie czy na podstawie tabeli STP
{? exec('isSTPEnabled','stp')
|| P.cntx_psh();
   P.index('OSOBA');
   P.prefix(_a,exec('ref_firma','ustawienia'));
   {? P.first()
   || {!
      |? {? P.ZA='T'
         || exec('prac_pod','stp',P.ref(),_b,_c,_d,_e)
         ?};
         P.next()
      !}
   ?};
   P.cntx_pop();
   return(_d)
?};
{? _begin
|| {? PAR_SKID.get(313)<>'T'
   || __NDSTZ:=STZ.ndx_tmp(,,'FIRMA',,,'STZ',,,'STN','ST',)
   || __NDSTZ:=STZ.ndx_tmp(,,'FIRMA',,,'STZ',,,'STN','ST',,'POZWORG',,)
   ?}
?};

:: ustal podwladnych na podstawie
:: bezposrednio okreslonych zaleznosci sluzbowych
exec('prac_pod_zal','stanprac',_a,_b,_c,_d,_e);

{? PAR_SKID.get(232)='T'
:: jednostek org. dla zaleznosci sluzbowych
|| exec('prac_pod_stn','stanprac',_a,_b,_c,_d,_e,_f)
:: struktury organizacyjnej i zaleznosci stanowisk
|| exec('prac_pod_org','stanprac',_a,_b,_c,_d,_e,_f)
?};

{? _begin
|| _max:=#PAR_SKID.get(235);
   P.cntx_psh;
   P.index('PRACOSOW');
   P.prefix(exec('ref_firma','ustawienia'),_a);
   _loop:=P.first; _r:=#P.ref();
   {!
   |? _loop
   |! _d.blank(1);
      _d.P:=P.ref;
      {? _d.find_rec
      || _d.del
      ?};
      _nad:=exec('prac_nad_old','stanprac',P.ref,1,_b,_c,,_max);
      _loop:=_nad.first;
      {!
      |? _loop
      |! _d.blank(1);
         _d.P:=_nad.P;
         {? _d.find_rec & _nad.P=_r
         || _d.del
         ?};
         _loop:=_nad.next
      !};
      obj_del(_nad);
      _loop:=P.next
   !};

:  weryfikacja "rzeczywistej" podwladnosci
:  usuniecie podwladnych przeszeregowanych
:  kierownikow na nizszych poziomach
   _wer:="
      _a.cntx_psh;
      _a.prefix(_b);
      _loop:=_a.first;
      {!
      |? _loop
      |! _a.CZY_POD:='T';
         _a.put;
         _c(_a,_a.P,_c);
         _loop:=_a.next
      !};
      _a.cntx_pop
   ";
   _d.cntx_psh;
   _d.index(_nad_ndx);
   P.index('PRACOSOW');
   P.prefix(exec('ref_firma','ustawienia'),_a);
   _loop:=P.first;
   {!
   |? _loop
   |! _wer(_d,P.ref,_wer);
      _loop:=P.next
   !};
:  usuniecie podwladnych "podczepionych" przez
:  przeniesionego i kiedys podleglego kierownika
   {? _d.first
   || {!
      |? {? _d.CZY_POD='T'
         || _d.next
         || _d.del
         ?}
      !}
   ?};
   _d.cntx_pop;
:  koniec weryfikacji

:  Dla parametru 250='N' usunięcie pracownika zastępowanego dla typu TYPPOZ:DOSTINF
   exec('par250','stp',_b,_c,_d);

   {? _max>0
   || _d.clear;
      {? _d.first
      || _d.cntx_psh;
         _d.index(_nad_ndx);
         P.prefix(exec('ref_firma','ustawienia'),_a);
         _loop:=P.first;
         {!
         |? _loop
         |! exec('prac_pod_poz','stanprac',_d,#P.ref,1,_max);
            _loop:=P.next
         !};
         _d.cntx_pop
      ?};
      {? _d.first
      || P.clear;
         _d.cntx_psh;
         _d.index(_d.ndx_tmp(,,'P',,));
         _loop:=_d.first;
         {!
         |? _loop
         |! {? P.seek(_d.P,)
            || _nad:=exec('prac_nad_old','stanprac',P.ref,0,_b,_c,,1);
               {? _nad.first
               || _prev:=_d.ref;
                  _exists:=_d.find_key(_nad.P);
                  _d.seek(_prev);
                  {? ~_exists
                  || _loop:=_d.next
                  |? _exists | (P.seek(_nad.P,) & P.OSOBA=_a)
                  || _d.P_NAD:=_nad.P;
                     _d.put;
                     _loop:=_d.next
                  || _loop:=_d.del
                  ?}
               || _loop:=_d.del
               ?};
               obj_del(_nad)
            || _loop:=_d.del
            ?}
         !};
         _d.cntx_pop
      ?};
      {? _d.first
      || _d.cntx_psh;
         _d.index(_nad_ndx);
         P.prefix(_a);
         _loop:=P.first;
         {!
         |? _loop
         |! exec('prac_pod_poz','stanprac',_d,#P.ref,1,_max);
            _loop:=P.next
         !};
         _d.cntx_pop
      ?};
      _d.cntx_psh;
      _d.prefix();
      _loop:=_d.first;
      {!
      |? {? _d.L>_max
         || _del:=_d.del(,1);_del=2
         || _d.next
         ?}
      !};
      _d.cntx_pop()
   || _d.clear;
      {? _d.first
      || {!
         |? {? _d.L=0
            || _del:=_d.del(,1);_del=2
            || _d.next
            ?}
         !}
      ?}
   ?};
   P.cntx_pop
?};
{? _begin || STZ.ndx_drop(&__NDSTZ) ?};
_d


\prac_pod_zal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Zwraca w postaci tabeli liste pracownikow podleglych osobie
::   WE: _a - ref osoby
::       _b - symbol slownika kodow
::       _c - symbol kodu zaleznosci sluzbowych
::       _d - alias do bufora danych
::       _e - poziom zaleznosci
::   WY: alias do tabeli zawierajacej informacje o zaleznosciach
::UWAGA: poprawnosc argumentow wywolania nie jest weryfikowana
::----------------------------------------------------------------------------------------------------------------------
_typ:=exec('kod','ext_slo',_b,_c);
{? _typ=null || return(_d) ?};

_por:=exec('lic','#b_domain','POR');

P.cntx_psh;
P.index('PRACOSOW');
P.prefix(exec('ref_firma','ustawienia'),_a);
{? P.first
|| _REF:=tab_tmp(1,'OSOBA','INTEGER',,'POZIOM','INTEGER',);
   _zapisz:="
      {? ~_a.find_key(_b)
      || _a.OSOBA:=_b;
         _a.POZIOM:=_c;
         _a.add
      ?}
   ";
   P_PZ.cntx_psh;
   {!
   |? {? P.ZA='T'
      || _nad:=P.ref;
::       -------------------------------------
::       przegladanie przypisanych podwladnych
         P_PZ.index('UNIQUE');
::       zaleznosci czasowe
         P_PZ.prefix('P',_typ,_nad,'T');
         {? P_PZ.first
         || P.cntx_psh;
            {!
            |? P_PZ.PZ();
               {? P_PZ.OD<=date & {? ~_por | (_por & P_PZ.DO<>date(0,0,0)) || date<=P_PZ.DO || 1 ?}
               || {? exec('add_zal','stanprac',_d,P.ref,P.WYDZIAL().SYMBOL,_e,exec('opis_bp','stanprac'),_nad,,,'P')
                  || _zapisz(_REF,P.OSOBA,_e+1)
                  ?}
               ?};
               P_PZ.next
            !};
            P.cntx_pop
         ?};
::       zaleznosci domyslne
         P_PZ.prefix('P',_typ,_nad,'N');
         {? P_PZ.first
         || P.cntx_psh;
            {!
            |? P_PZ.PZ();
               {? P_PZ.OD<=date
               || {? exec('add_zal','stanprac',_d,P.ref,P.WYDZIAL().SYMBOL,_e,exec('opis_bp','stanprac'),_nad,,,'P')
               || _zapisz(_REF,P.OSOBA,_e+1)
                  ?}
               ?};
               P_PZ.next
            !};
            P.cntx_pop
         ?};
::       --------------------------------------
::       przegladanie podwladnych zastepowanego
         P_PZ.index('REVERT');
::       zaleznosci czasowe
         P_PZ.prefix('Z',_typ,_nad,'T');
         {? P_PZ.first
         || P.cntx_psh;
            {!
            |? P_PZ.P();
               {? P_PZ.OD<=date & {? ~_por | (_por & P_PZ.DO<>date(0,0,0)) || date<=P_PZ.DO || 1 ?}
               || {? (P_PZ.NB<>'T') | ((P_PZ.NB='T') & exec('czy_jest','nieobecnosc',P.ref))
                  || {? exec('add_zal','stanprac',
                           _d,P.ref,P.WYDZIAL().SYMBOL,_e-1,exec('opis_bp','stanprac'),_nad,,'T','Z'
                        )
                     || _zapisz(_REF,P.OSOBA,_e)
                     ?}
                  ?}
               ?};
               P_PZ.next
            !};
            P.cntx_pop
         ?};
::       zaleznosci domyslne
         P_PZ.prefix('Z',_typ,_nad,'N');
         {? P_PZ.first
         || P.cntx_psh;
            {!
            |? P_PZ.P();
::               _nad:=exec('prac_nad','stanprac',P.ref,1,_b,_c,,1).P;
               {? (P_PZ.NB<>'T') | ((P_PZ.NB='T') & exec('czy_jest','nieobecnosc',P.ref))
               || {? exec('add_zal','stanprac',
                        _d,P.ref,P.WYDZIAL().SYMBOL,_e-1,exec('opis_bp','stanprac'),_nad,,'T','Z'
                     )
                  || _zapisz(_REF,P.OSOBA,_e)
                  ?}
               ?};
               P_PZ.next
            !};
            P.cntx_pop
         ?}
      ?};
      P.next
   !};
   P_PZ.cntx_pop;
:  szukaj podwladnych na nizszych poziomach
:  (wlacznie z podwladnymi zastepowanych)
   _loop:=_REF.first;
   {!
   |? _loop
   |! exec('prac_pod_old','stanprac',_REF.OSOBA,_b,_c,_d,_REF.POZIOM,'Z');
      _loop:=_REF.next
   !}
?};
P.cntx_pop;

_d


\prac_pod_stn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Zwraca w postaci tabeli liste pracownikow podleglych osobie
::   WE: _a - ref osoby
::       _b - symbol slownika kodow
::       _c - symbol kodu zaleznosci sluzbowych
::       _d - alias do bufora danych
::       _e - poziom zaleznosci
::       _f - path
::   WY: alias do tabeli zawierajacej informacje o zaleznosciach
::UWAGA: poprawnosc argumentow wywolania nie jest weryfikowana
::----------------------------------------------------------------------------------------------------------------------
_typ:=exec('kod','ext_slo',_b,_c);
{? _typ=null || return(_d) ?};

_LWYD:=exec('lwyd_buff','stanprac');
_LSTN:=exec('lstn_buff','stanprac');

:: KO [12.30] - obsluga parametru 313 - pozycje w organizacji
_par313:=@.PAR_SKID.get(313)='T';
{? _par313
|| _LSTN.index(_LSTN.ndx_tmp(,,'STN',,,'POZWORG',,))
|| _LSTN.index(_LSTN.ndx_tmp(,,'STN',,))
?};

_lstwyd:=exec('lwyd_form','stanprac');
_lststn:=exec('lstn_form','stanprac');

_erase:="_a.clear; {? _a.first || {! |? _a.del !} ?}";

_sch:=exec('szukaj_ud_sch','schemat','PODZORG','STR_STAN');

UD_SKL.cntx_psh;
UD_SKL.clear;

P.cntx_psh;
P.index('PRACOSOW');
P.prefix(exec('ref_firma','ustawienia'),_a);
_loop:=P.first;
{!
|? _loop
|! {? P.ZA='T'
   || _nad:=_p_ref:=P.ref;
      STRST_P.index('P');
      STRST_P.prefix(P.ref);
      _loop:=STRST_P.first;
      {!
      |? _loop
      |! STRST_P.cntx_psh;
         {? STRST_P.ST().K<>'T'
         || _szef:=exec('prac_nad_old','stanprac',P.ref,0,_b,_c,,1);
            {? _szef.first & _szef.P<>#P.ref
            || _nad:=_szef.P
            ?};
            obj_del(_szef)
         ?};

::       dodanie zależności wynikających z pełnionych obowiązków
         _erase(_LWYD);
         _erase(_LSTN);

         P_PO.cntx_psh;
         P_PO.index('P_PO');
         P_PO.prefix(P.ref);
         _loop:=P_PO.first;
         {!
         |? _loop
         |! {? P_PO.TYP().KOD=_c & SLO_KOD.SLO_TYP().SYMBOL=_b &
               {? P_PO.CO='T' || P_PO.OD<=date & date<=P_PO.DO || 1 ?}
            || {? P_PO.NB='N'
               || _lststn(_LSTN,P_PO.ST,P_PO.POZWORG,_lststn,0,1);
                  _lstwyd(_LWYD,_sch,P_PO.WYDZIAL,_lstwyd,0,1)
               || P.cntx_psh();
                  P.index('PRACOWST');
                  P.prefix();
                  P.prefix(P_PO.WYDZIAL,P_PO.ST,'T');
                  {? P.first()
                  || {!
                     |? {? exec('czy_jest','nieobecnosc',P.ref())
                        || _lststn(_LSTN,P_PO.ST,P_PO.POZWORG,_lststn,0,1);
                           _lstwyd(_LWYD,_sch,P_PO.WYDZIAL,_lstwyd,0,1)
                        ?};
                        P.next()
                     !}
                  ?};
                  P.cntx_pop()
               ?}
            ?};
            _loop:=P_PO.next
         !};
         P_PO.cntx_pop;

         P.cntx_psh;
         _loop:=_LWYD.first;
         {!
         |? _loop
         |! STRST_P.index('UD_SKL_S');
            STRST_P.prefix(_LWYD.WYD);
            _loop:=STRST_P.first;
            {!
            |? _loop
            |! STRST_P.cntx_psh;
               {?
                  {? _par313
                  || _LSTN.find_key(#STRST_P.P().ST, #STRST_P.P().POZWORG)
                  || _LSTN.find_key(#STRST_P.P().ST)
                  ?}
               || _nad:={? _LSTN.P_PO || _p_ref || _nad ?};
                  {? exec('add_zal','stanprac',_d,P.ref,STRST_P.UD_SKL().SYMBOL,_e,,_nad,,,'O') & P.ZA='T'
                  || exec('prac_pod_old','stanprac',P.OSOBA,_b,_c,_d,_e+1,'O')
                  ?}
               ?};
               STRST_P.cntx_pop;
               _loop:=STRST_P.next
            !};
            _loop:=_LWYD.next
         !};
         P.cntx_pop;
         STRST_P.cntx_pop;

::       dodanie zależności wynikających z zajmowanego stanowiska
         _erase(_LWYD);
         _erase(_LSTN);
         _lststn(_LSTN,P.ST,P.POZWORG,_lststn,0);
         _lstwyd(_LWYD,_sch,STRST_P.UD_SKL,_lstwyd,0);

         STRST_P.cntx_psh;
         P.cntx_psh;
         _loop:=_LWYD.first;
         {!
         |? _loop
         |! STRST_P.index('UD_SKL_S');
            STRST_P.prefix(_LWYD.WYD);
            _loop:=STRST_P.first;
            {!
            |? _loop
            |! STRST_P.cntx_psh;
               {?
                  {? _par313
                  || _LSTN.find_key(#STRST_P.P().ST, #STRST_P.P().POZWORG)
                  || _LSTN.find_key(#STRST_P.P().ST)
                  ?}
               || _nad:={? _LSTN.P_PO || _p_ref || _nad ?};
                  {? exec('add_zal','stanprac',_d,P.ref,STRST_P.UD_SKL().SYMBOL,_e,,_nad,,,_f) & P.ZA='T'
                  || exec('prac_pod_old','stanprac',P.OSOBA,_b,_c,_d,_e+1,_f)
                  ?}
               ?};
               STRST_P.cntx_pop;
               _loop:=STRST_P.next
            !};
            _loop:=_LWYD.next
         !};
         P.cntx_pop;

         STRST_P.cntx_pop;
         _loop:=STRST_P.next
      !}
   ?};
   _loop:=P.next
!};

P.cntx_pop;
UD_SKL.cntx_pop;

_d


\prac_pod_org
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Zwraca w postaci tabeli liste pracownikow podleglych osobie
::   WE: _a - ref osoby
::       _b - symbol slownika kodow
::       _c - symbol kodu zaleznosci sluzbowych
::       _d - alias do bufora danych
::       _e - poziom zaleznosci
::       _f - path
::   WY: alias do tabeli zawierajacej informacje o zaleznosciach
::UWAGA: poprawnosc argumentow wywolania nie jest weryfikowana
::----------------------------------------------------------------------------------------------------------------------
_typ:=exec('kod','ext_slo',_b,_c);
{? _typ=null || return(_d) ?};

_LSTZ:=exec('lstz_buff','stanprac');

_lststz:=exec('lstz_form','stanprac');

_erase:="_a.clear; {? _a.first || {! |? _a.del !} ?}";

_sch:=exec('szukaj_ud_sch','schemat','PODZORG','STRORG');
_par313:=@.PAR_SKID.get(313)='T';

P.cntx_psh;
P.index('PRACOSOW');
P.prefix(exec('ref_firma','ustawienia'),_a);
{? P.first
||
   {!
   |? {? P.ZA='T'
      || _nad:=P.ref;
         _erase(_LSTZ);

::       dodanie zależności wynikających z pełnionych obowiązków
         P.cntx_psh;
         P_PO.cntx_psh;
         P_PO.index('P_PO');
         P_PO.prefix(P.ref);
         {? P_PO.first
         || {!
            |? {? P_PO.TYP().KOD=_c & SLO_KOD.SLO_TYP().SYMBOL=_b &
                  {? P_PO.CO='T' || P_PO.OD<=date & date<=P_PO.DO || 1 ?}
               || {? P_PO.NB='N'
                  || _lststz(_LSTZ,P_PO.WYDZIAL,P_PO.ST,P_PO.POZWORG,_lststz,0,exec('opis_po','stanprac'))
                  || P.cntx_psh();
                     P.index('PRACOWST');
                     P.prefix(P_PO.WYDZIAL,P_PO.ST,'T');
                     {? P.first()
                     || {!
                        |? {? exec('czy_jest','nieobecnosc',P.ref())
                           ||  _lststz(_LSTZ,P_PO.WYDZIAL,P_PO.ST,P_PO.POZWORG,_lststz,0,exec('opis_po','stanprac'))
                           ?};
                           P.next()
                        !}
                     ?};
                     P.cntx_pop()
                  ?}
               ?};
               P_PO.next
            !}
         ?};
         P_PO.cntx_pop;

         {? _LSTZ.first
         || {!
            |? P.cntx_psh;
               {? _b='TYPPOZ' & _c='PLANCZP'
               || {? _par313
                  || P.index('PRACOWSP');
                     P.prefix(_LSTZ.WYD,_LSTZ.STN,_LSTZ.POZWORG)
                  || P.index('PRACOWST');
                     P.prefix(_LSTZ.WYD,_LSTZ.STN)

                  ?}
               || {? _par313
                  || P.index('PRACOWSP');
                     P.prefix(_LSTZ.WYD,_LSTZ.STN,_LSTZ.POZWORG,'T')
                  || P.index('PRACOWST');
                     P.prefix(_LSTZ.WYD,_LSTZ.STN,'T')
                  ?}
               ?};
               {? P.first
               || {!
                  |? {? _a<>P.OSOBA &
                        exec('add_zal','stanprac',_d,P.ref,P.WYDZIAL().SYMBOL,_e,_LSTZ.ZRODLO,_nad,,,'O') & P.ZA='T'
                     || exec('prac_pod_old','stanprac',P.OSOBA,_b,_c,_d,_e+1,'O')
                     ?};
                     P.next
                  !}
               ?};
               P.cntx_pop;
               _LSTZ.next
            !}
         ?};
         P.cntx_pop;

::       dodanie zależności wynikających z zajmowanego stanowiska
         _erase(_LSTZ);
         _lststz(_LSTZ,P.WYDZIAL,P.ST,{? _par313 || P.POZWORG ?},_lststz,0,exec('opis_str','stanprac'));

         {? _LSTZ.first
         || {!
            |? P.cntx_psh;
               {? _b='TYPPOZ' & _c='PLANCZP'
               || {? _par313
                  || P.index('PRACOWSP');
                     P.prefix(_LSTZ.WYD,_LSTZ.STN,_LSTZ.POZWORG)
                  || P.index('PRACOWST');
                     P.prefix(_LSTZ.WYD,_LSTZ.STN)

                  ?}
               || {? _par313
                  || P.index('PRACOWSP');
                     P.prefix(_LSTZ.WYD,_LSTZ.STN,_LSTZ.POZWORG,'T')
                  || P.index('PRACOWST');
                     P.prefix(_LSTZ.WYD,_LSTZ.STN,'T')
                  ?}
               ?};
               {? P.first
               || {!
                  |? {? _a<>P.OSOBA &
                        exec('add_zal','stanprac',_d,P.ref,P.WYDZIAL().SYMBOL,_e,_LSTZ.ZRODLO,_nad,,,_f) & P.ZA='T'
                     || exec('prac_pod_old','stanprac',P.OSOBA,_b,_c,_d,_e+1,_f)
                     ?};
                     P.next
                  !}
               ?};
               P.cntx_pop;
               _LSTZ.next
            !}
         ?}
      ?};
      P.next
   !}
?};
P.cntx_pop;
_d


\prac_pod_poz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Ostatecznie ustala poziomy zaleznosci
::   WE: _a - alias do bufora danych
::       _b - ref przelozonego
::       _c - poziom zaleznosci
::       _d - maksymalny poziom
::----------------------------------------------------------------------------------------------------------------------
_a.cntx_psh;
_a.prefix(_b);
_loop:=_a.first;
{? _d>0 & _d<_c
|| {!
   |? _loop
   |! exec('prac_pod_poz','stanprac',_a,_a.P,_c+1,_d);
      _loop:=_a.del
   !}
|| {!
   |? _loop
   |! _poziom:=_c+1;
      {? _a.L=0
      || _poziom:=_c
      |? _a.L<>_c
      || _a.L:=_c;
         _a.put
      ?};
      exec('prac_pod_poz','stanprac',_a,_a.P,_poziom,_d);
      {? _a.L=0
      || _del:=_a.del(,1);_loop:=(_del=2)
      || _loop:=_a.next
      ?}
   !}
?};
_a.cntx_pop


\prac_nad
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.14]
:: OPIS: Tworzy listę przełożonych współpracownika. Lista zawiera oznaczenie poziomu tzn: bezpośredni przełożony
::       ma poziom 1, jego przełożony poziom 2 etc. oraz wskazanie na rekord opisujacy współpracownika (przełożonego).
::       Lista jest posortowana według poziomu i wskazania. Operacja first ustali rekord właściwy dla bezpośredniego
::       przełożonego, kolejne wywołania next dadzą zwierzchników wyższych szczebli.
::   WE: _a P - wskazanie pracownika
::       _b [INTEGER/STRING]
::          1 - pomiń nieobecnych współpracowników,
::          0 lub brak - uwzględnij wszystkich,
::          napis określający opcje działania:
::             dodatkowe=0/1* - uwzględniaj zależności dodatkowe,
::             zastępstwa=0/1* - uwzględniaj zastępstwa,
::             zastępstwa_co=T/N/''* - wartość znacznika CO (pomijany dla zastępstwa=0),
::             zastępstwa_nb=T/N/''* - wartość znacznika NB (pomijany dla zastępstwa=0),
::             zastępowani=0*/1 - pozostaw zastępowanych (pomijany dla zastępstwa=0),
::             nieobecni=0*/1 - pozostaw nieobecnych
::          dla przykładu 'dodatkowe=0,zastępstwa=0' da listę przełożonych wynikającą wyłącznie ze struktury zależności
::       _c [STRING] - symbol typu słownika, jeśli pominięty lub inny niż napis, to przyjęty będzie domyślny
::       _d [STRING] - kodu zależności służbowych z ewentualnym kodem zależności rozszerzanej, jeśli pominięty lub
::          inny niż napis, to przyjęty będzie domyślny
::       _e [TABLE] - alias do bufora danych
::       _f [INTEGER] - liczba wywołań rekurencyjnych
::       _g [INTEGER] - określenie, czy usuwać "siebie" z bufora
::   WY: alias tabeli z listą przełożonych
::UWAGA: argumenty _c, _e pozostały na liście wyłącznie dla zgodności wywołań poprzedniej wersji
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_ref:=_a;
_a_b:={? var_pres('_b')>type_of(~~) || _b || 0 ?};
_slo:='TYPPOZ';
_sep:='\t';
:: Argument _d może mieć postać SLO_KOD.KOD[_sep]SLO_KOD.KOD.
:: W takim przypadku drugi z kodów odnosi się do zależności uzupełnianych.
:: Taka sytuacja ma miejsce w przypadku, gdy stosowane są jednorodne zatępstwa.
:: To według drugiego kodu ustalani będą zastępcy przełożonych współpracownika.
_a_d:=~~;
_ext:='';
{? var_pres('_d')=type_of('') & form(_d)<>''
|| _a_d:=_d;
   {? (_a_d*_sep)<>0
::    jednorodne zastępstwa
   || _str:=spli_str(_a_d,_sep);
      _a_d:=_str[1];
      _ext:=_str[2]
   ?}
?};
_typ:=exec('ustal','zs_typ',_a_d);
_kod:=_typ.lisc.KOD_KOD;
{? _ext=''
|| _ext:=_kod
?};

:: tabela listy podwładnych
{? var_pres('_e')<>type_of(SYSLOG)
|| _BUF:=exec('tab_zal','stanprac');
   _BUF.index(_BUF.ndx_tmp(,,'L',,))
|| _BUF:=_e
?};

:: ustal opcje działania na podstawie _b
_opt:=exec('prac_xxx_opt','stanprac',_a_b);
{? _opt.err<>''
|| _fst:=form_stack(2);
   FUN.emsg(
      'Formuła %1 z pliku %2 wywołana przez formułę %3 z pliku %4.%5'@[
      _fst[1].name,_fst[1].file,_fst[2].name,_fst[2].file,_opt.err
   ]);
   return(_BUF)
?};

:: głębokość rekurencji (maksymalnie jedno wywołanie)
_rcc:={? var_pres('_f')=type_of(0) || {? _f>0 || _f ?} ?};

:: czy usuwać "siebie" z bufora
_del:={? var_pres('_g')=type_of(0) || _g || 1 ?};

:: głębokość zależności
_max:=#PAR_SKID.get(235);

:: współpracownik i typ muszą być określone
{? _ref=null | _typ.dane.REF=null | _rcc>1
|| return(_BUF)
?};

P.cntx_psh();
OSOBA.cntx_psh();
UD_SKL.cntx_psh();

:: ====================
:: pobierz z zależności
:: ====================
ZS_DEF.cntx_psh();
ZS_DEF.index('UNIQUE');
ZS_DEF.prefix(_typ.dane.REF);
{? ZS_DEF.find_key(_ref)
:: znaleziono zależność
|| {? ZS_DEF.ZS_DEF=0
   || ZS_DEF.P();
      exec('add_zal','stanprac',_BUF,
         P.ref(),
         P.WYDZIAL().SYMBOL,
         1,
         exec('opis_zs','stanprac'),,,,
         'P',,
         _kod
      )
   || _poz_od:=ZS_DEF.POZIOM;
      _poziom:=0;
      {!
      |? {? ZS_DEF.seek(ZS_DEF.ZS_DEF,)
::          jest bezpośredni przełożony
         || _poziom:=fabs(ZS_DEF.POZIOM-_poz_od);
::          kontrola głębokości struktury
            _max=0 | _poziom<=_max
         ?}
      |! ZS_DEF.P();
         exec('add_zal','stanprac',_BUF,
            P.ref(),
            P.WYDZIAL().SYMBOL,
            _poziom,
            exec('opis_zs','stanprac'),,,,
            'P',,
            _kod
         )
      !}
   ?}
?};
ZS_DEF.cntx_pop();

:: wymagana normalizacja
_norm:=0;

:: ====================
:: uwzględnij zastępców
:: ====================
_PZAS:=~~;
_many:=0;
_loop:=0;
{? _opt.zas<>0 & _BUF.first()
|| _PZAS:=tab_tmp(1,'REF','STRING[16]','Pracownik','L','INTEGER','Poziom');
   _many:=1;
   _loop:=1
?};
_nbco:='%1:%2'[
   {? _opt.znb='' || 'TN' || _opt.znb ?},
   {? _opt.zco='' || 'TN' || _opt.zco ?}
];
{!
|? _loop
|! {? P.seek(_BUF.P,,1)
   || _pzas:=null;
      _opis:='';
      _zast:='';
      {? _opt.zco='' | _opt.zco='N'
      || _pzas:=exec('prac_zas','stanprac',P.ref(),,_slo,_ext,_nbco,P.ref(),,_PZAS,,_BUF.L)
      ?};
      {? {? _many=0 || _pzas<>null || _PZAS.size() ?}
::       znaleziono stałego zastępcę współpracownika
      || _opis:=exec('opis_za','stanprac');
         _zast:='Z'

      |? (_opt.znb='' | _opt.znb='T') & exec('czy_jest','nieobecnosc',P.ref())
      || _pzas:=exec('prac_zas','stanprac',P.ref(),,_slo,_ext,_nbco,P.ref(),,_PZAS,,_BUF.L);
::       znaleziono zastępcę na czas nieobecności współpracownika
         {? {? _many=0 || _pzas<>null || _PZAS.size() ?}
         || _opis:=exec('opis_zan','stanprac');
            _zast:='Z'
         ?}
      ?};
      {? {? _many=0 || _pzas<>null || _PZAS.size()>0 ?}
::       znaleziono zastępcę stałego lub na czas nieobecności przełożonego
      || {? _many=0
         || exec('mod_zal','stanprac',_BUF,_pzas,P.WYDZIAL().SYMBOL,_BUF.L,_opis,,,,_zast,,_kod);
            _norm+=1
         || _norm+=exec('many_zal','stanprac',_BUF,_PZAS,~_opt.pzp,_opis,_zast,_kod);
::          ze względu na możliwe wykorzystanie w transakcji nie można użyć erase
            {! |? _PZAS.del() !}
         ?}
      ?}
   ?};
   _loop:=_BUF.next()
!};

{? _norm<>0
:: usuń ewentualne powielenia
|| exec('cln_zal','stanprac',_BUF)
?};

{? _del<>0
|| {!
   |? _BUF.blank(1);
      _BUF.P:=#_ref;
      _BUF.size()>1 & _BUF.find_rec()
::    usuń "siebie" z wielu zależności
   |! _BUF.del();
      _norm+=1
   !}
?};

{? _opt.nie=0 & _BUF.first()
:: pomiń nieobecnych
|| {!
   |? {? P.seek(_BUF.P,,1)
      || {? ~exec('czy_jest','nieobecnosc',P.ref())
         || _BUF.next()
         || _norm+=1;
            _BUF.del()
         ?}
      || _BUF.del()
      ?}
   !}
?};

{? _norm<>0 & _many=0
:: normalizuj listę zależności
|| exec('lvl_zal','stanprac',_BUF)
?};

UD_SKL.cntx_pop();
OSOBA.cntx_pop();
P.cntx_pop();

:: ==================================
:: uzupełnij z zależności dodatkowych
:: ==================================
{? _opt.dod<>0
|| ZS_DOD.cntx_psh();
   ZS_DOD.index('TYP_DOD');
   ZS_DOD.prefix(_typ.dane.REF);
   {? ZS_DOD.first()
   || _add:='_a.blank(1);';
      _num:=_BUF.fld_num();
      {! _ii:=1.._num
      |! _add+='_a[%1]:=_b[%1];'[$_ii]
      !};
      _add:=$(_add+'_a.add()');
      _TMP:=exec('tab_zal','stanprac');
      _kod:=
::       określ sposób ustalania zastępców
         {? exec('jednorodne_zas','zs_lib')<>0
         || "'%1%2%3'[ZS_DOD.KOD_DOD().KOD,_a,ZS_DOD.SLO_KOD().KOD]"
         || "ZS_DOD.KOD_DOD().KOD"
         ?};

      {!
::       pobierz dodatkowe zależności służbowe do oddzielnej tabeli
      |? exec('prac_nad','stanprac',_ref,_a_b,,_kod(_sep),_TMP,_rcc+1);
::       skopiuj zależności do tabeli wyniku
         _loop:=_TMP.first();
         {!
         |? _loop
         |! _add(_BUF,_TMP);
            _loop:=_TMP.del()
         !};
         ZS_DOD.next()
      !};

::    usuń ewentualne powielenia
      exec('cln_zal','stanprac',_BUF);
      obj_del(_TMP)
   ?};
   ZS_DOD.cntx_pop()
?};

_BUF.first();
_BUF


\prac_xxx_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.37]
:: OPIS: Tworzy tablicę nazwaną zawierająca opcje wywołania formuł prac_nad i prac_pod.
::   WE: _a [INTEGER/STRING]
::          1 - pomiń nieobecnych współpracowników,
::          0 lub brak - uwzględnij wszystkich,
::          napis określający opcje działania:
::          dodatkowe=0/1* - uwzględniaj zależności dodatkowe,
::          zastępstwa=0/1* - uwzględniaj zastępstwa,
::          zastępstwa_co=T/N/''* - wartość znacznika CO (pomijany dla zastępstwa=0),
::          zastępstwa_nb=T/N/''* - wartość znacznika NB (pomijany dla zastępstwa=0),
::          zastępowani=0*/1 - pozostaw zastępowanych (pomijany dla zastępstwa=0),
::          nieobecni=0*/1 - pozostaw nieobecnych
::   WY: tablica nazwana zawierająca odpowiednio dla ww opcji:
::       dod - wartość dodatkowe,
::       zas - wartość zastępstwa,
::       zco - wartość zastępstwa_co,
::       znb - wartość zastępstwa_nb,
::       pzp - zastępowani,
::       nie - wartość nieobecni
::----------------------------------------------------------------------------------------------------------------------
_ret:=obj_new('err','dod','zas','zco','znb','pzp','nie');
_ret.err:='';
_ret.dod:='1';
_ret.zas:='1';
_ret.zco:='';
_ret.znb:='';
_ret.pzp:='0';
_ret.nie:='0';

{? var_pres('_a')=type_of(0)
|| _ret.nie:=$~_a;
   _ret.pzp:=$~_a

|? var_pres('_a')=type_of('')
|| _str:=spli_str(_a,',');
   _len:=obj_len(_str);
   {! _ii:=1.._len
   |! {? _str[_ii]*'='<>0
      || _opt:=spli_str(_str[_ii],'=');
         _key:=_opt[1];
         _val:=~-_opt[2];
         {? _key='dodatkowe'
         || {? _val<>'0' & _val<>'1'
            || _ret.err+='\nBłędna wartość "%2" opcji "%1".\nOczekiwane 0 lub 1.'@[_key,_val]
            || _ret.dod:=_val
            ?}

         |? _key='zastępstwa'
         || {? _val<>'0' & _val<>'1'
            || _ret.err+='\nBłędna wartość "%2" opcji "%1".\nOczekiwane 0 lub 1.'@[_key,_val]
            || _ret.zas:=_val
            ?}

         |? _key='zastępstwa_co'
         || {? _val<>'T' & _val<>'N' & _val<>''
            || _ret.err+='\nBłędna wartość "%2" opcji "%1".\nOczekiwane T/N lub brak.'@[_key,_val]
            || _ret.zco:=_val
            ?}

         |? _key='zastępstwa_nb'
         || {? _val<>'T' & _val<>'N' & _val<>''
            || _ret.err+='\nBłędna wartość "%2" opcji "%1".\nOczekiwane T/N lub brak.'@[_key,_val]
            || _ret.znb:=_val
            ?}

         |? _key='zastępowani'
         || {? _val<>'0' & _val<>'1'
            || _ret.err+='\nBłędna wartość "%2" opcji "%1".\nOczekiwane 0 lub 1.'@[_key,_val]
            || _ret.pzp:=_val
            ?}

         |? _key='nieobecni'
         || {? _val<>'0' & _val<>'1'
            || _ret.err+='\nBłędna wartość "%2" opcji "%1".\nOczekiwane 0 lub 1.'@[_key,_val]
            || _ret.nie:=_val
            ?}

         || _ret.err+='\nBłędna opcja "%1".'@[_key]
         ?};
         obj_del(_opt)

      || _ret.err+='\nBrak określenia wartości dla "%1".'@[_str[_ii]]
      ?}
   !}

|| _ret.err+='\nBłędny typ argumentu _a.\nOczekiwana liczba lub ciąg znaków.'@
?};

_ret.dod:=#_ret.dod;
_ret.zas:=#_ret.zas;
_ret.pzp:=#_ret.pzp;
_ret.nie:=#_ret.nie;

_ret


\prac_opt_buff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.37]
:: OPIS: Tworzy tabelę tymczasową i okno edycji wykorzystywane do edycji opcji wywołania prac_nad
::   WE:
::   WY: alias tabeli tymaczasowej
::----------------------------------------------------------------------------------------------------------------------
_OPT:=tab_tmp(1,
   'DOD','STRING[1]','Zależności dodatkowe'@,
   'ZAS','STRING[1]','Zastępstwa'@,
   'ZCO','STRING[1]','Czas określony'@,
   'ZNB','STRING[1]','Podczas nieobecności'@,
   'PZP','STRING[1]','Zastępowani'@,
   'NIE','STRING[1]','Nieobecni'@,
   'STR','SYS_MEMO','Opcje'@
);

_fft:='AFTER_EDIT';
_fae:="
   _OPT:=cur_tab();
   _OPT.memo_set(exec('prac_opt_make','stanprac',_OPT),'STR');
   win_disp();
   1
";

_OPT.fld_fml('DOD',_fft,_fae);
_OPT.fld_fml('ZAS',_fft,"
   _OPT:=cur_tab();
   _opt:='enable=%1'[_OPT.ZAS];
   _OPT.efld_opt(cur_win(),_opt,,'ZCO');
   _OPT.efld_opt(cur_win(),_opt,,'ZNB');
   _OPT.efld_opt(cur_win(),_opt,,'PZP');
   _OPT.memo_set(exec('prac_opt_make','stanprac',_OPT),'STR');
   win_disp();
   1
");
_OPT.fld_fml('ZCO',_fft,_fae);
_OPT.fld_fml('ZNB',_fft,_fae);
_OPT.fld_fml('PZP',_fft,_fae);
_OPT.fld_fml('NIE',_fft,_fae);

_txt:='Uwzględniaj zależności dodatkowe'@;
_wnd:=_OPT.mk_edit('Parametry'@,0,'#prac_nad_opt',,,'html_maximized');
_OPT.win_esep(_wnd,'Dane podstawowe'@);
_OPT.win_efld(_wnd,,'DOD',,,,,,,,'%1 [0/1]'[_txt],'check-box',
   'check_label="%1"'[_txt],
   "'1'","'0'"
);
_txt:='Uwzględniaj zastępstwa'@;
_OPT.win_efld(_wnd,,'ZAS',,,,,,,,'%1 [0/1]'[_txt],'check-box',
   'check_label="%1"'[_txt],
   "'1'","'0'"
);
_OPT.win_efld(_wnd,,'ZCO',,,,,,,,,'radio-buttons',,
   'Wszystkie'@,"''",
   'Tymczasowe [T]'@,"'T'",
   'Bezterminowe [N]'@,"'N'"
);
_OPT.win_efld(_wnd,,'ZNB',,,,,,,,,'radio-buttons',,
   'Wszystkie'@,"''",
   'Na czas nieobecności [T]'@,"'T'",
   'Niezależne od nieobecności [N]'@,"'N'"
);
_txt:='Pozostaw zastępowanych'@;
_OPT.win_efld(_wnd,,'PZP',,,,,,,,'%1 [0/1]'[_txt],'check-box',
   'check_label="%1"'[_txt],
   "'1'","'0'"
);
_txt:='Pozostaw nieobecnych'@;
_OPT.win_efld(_wnd,,'NIE',,,,,,,,'%1 [0/1]'[_txt],'check-box',
   'check_label="%1"'@[_txt],
   "'1'","'0'"
);
_OPT.win_esep(_wnd,'Ustalanie przełożonych'@);
_OPT.win_efld(_wnd,,'STR',,,50,-3,1);
_OPT.win_edit(_wnd);
exec('ok_esc','#window',_OPT,_wnd);

:: wartości domyślne
_OPT.DOD:='1';
_OPT.ZAS:='1';
_OPT.ZCO:='';
_OPT.ZNB:='';
_OPT.PZP:='0';
_OPT.NIE:='0';
_OPT.memo_set(exec('prac_opt_make','stanprac',_OPT),'STR');

_OPT


\prac_opt_make
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.37]
:: OPIS: Tworzy napis zawierający opcje wywołania prac_nad na podstawie zawartości bufora.
::   WE: _a [TABLE] - alias tabeli bufora (patrz prac_opt_buff)
::   WY: ciąg znaków zawierający opcje
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_OPT:=_a;

'dodatkowe=%1,'
'zastępstwa=%2,'
'%3'
'%4'
'%5'
'nieobecni=%6'[
   _OPT.DOD,
   _OPT.ZAS,
   {? _OPT.ZAS='1' || 'zastępstwa_co=%1,'[_OPT.ZCO] || '' ?},
   {? _OPT.ZAS='1' || 'zastępstwa_nb=%1,'[_OPT.ZNB] || '' ?},
   {? _OPT.ZAS='1' || 'zastępowani=%1,'[_OPT.PZP] || '' ?},
   _OPT.NIE
]


\prac_opt_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.37]
:: OPIS: Edycja i pobranie opcji wywołania prac_nad.
::   WE: _a [TABLE] - alias tabeli bufora (patrz prac_opt_buff)
::   WY: tablica nazwana zawierająca
::       str - ciąg znaków zawierających opcje wywołania
::       ok - 0/1 wynik edycji: rezygnacja/zatwierdzenie
::----------------------------------------------------------------------------------------------------------------------
:: mapa argumentów
_OPT:=_a;

_ret:=obj_new('str','ok');
_ret.str:='';
_ret.ok:=0;

{? _OPT.edit()
|| _ret.str:=exec('prac_opt_make','stanprac',_OPT);
   _ret.ok:=1
?};

_ret


\test_heap
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [21.37]
:: OPIS: Poprawka ER/WRT/XP/21.37/2111/0028
::   WE: _a - wskazanie na pracownika
::   WY: 0/1 - wystąpiło przepełnienie/brak przepełnienia odwołań
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__heap')>=100
|| {? __heap.exc<>0 | __heap.pth*(','+$_a+',')<>0
   || __heap.exc:=1;
      return(0)
   ?};
   __heap.pth+=($_a+',')
?};
1


\prac_nad_old
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO  [2006]
::  MOD: KFI [2009]
:: OPIS: Tworzy liste przelozonych pracownikow pracujacych na wskazanym stanowisku w danej jednostce organizacyjnej.
::       Lista zawiera oznaczenie poziomu tzn: bezposredni przelozony ma poziom 1, jego przelozony poziom 2 etc. oraz
::       wskazanie na rekord opisujacy pracownika-przelozonego. Lista jest posortowana wedlug poziomu i wskazania zatem
::       operacja first ustali rekord wlasciwy dla bezposredniego przelozonego, kolejne wywolania next dadza zwierzchni-
::       kow wyzszych szczebli.
::   WE: _a - wskazanie na pracownika
::       _b - 1 - nie wybiera nieobecnych pracownikow, 0 - wybiera wszystkich
::       _c - symbol slownika kodow, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::       _d - symbol kodu zaleznosci sluzbowych, jesli pominiety lub inny niz napis, to przyjety zostanie NIEZNANY
::       _e - alias do bufora danych
::       _f - poziom zaleznosci
::       _g - path
::   WY: alias do listy przelozonych
::----------------------------------------------------------------------------------------------------------------------
_begin:=0;
{? var_pres('_b')<>type_of(0) || _b:=0 ?};
{? var_pres('_c')<>type_of('') | |_c='' || _c:='NIEZNANY' ?};
{? var_pres('_d')<>type_of('') | |_d='' || _d:='NIEZNANY' ?};
{? var_pres('_e')<>type_of(SYSLOG)
|| _e:=exec('tab_zal','stanprac');
   _e.index(_e.ndx_tmp(,,'L',,));
   _begin:=1
?};
{? var_pres('_f')<>type_of(0) | _f<0 || _f:=1 ?};
{? var_pres('_g')<>type_of('') | |_g='' || _g:='B' ?};
{? var_pres('__STP_A')<0 | (var_pres('__STP_A')>0 & __STP_A=0)
|| {? ~exec('prac_zal_max','stanprac',_f)
   || return(_e)
   ?}
?};
_stp:=exec('isSTPEnabled','stp');
{? _stp
|| exec('prac_nad','stp',_a,_b,_c,_d,_e,_f,_g)
||
:: ustal przelozonych na podstawie
:: bezposrednio okreslonych zaleznosci sluzbowych
   {? var_pres('__STP_A')<0 | (var_pres('__STP_A')>0 & __STP_A=0)
   || exec('prac_nad_zal','stanprac',_a,_b,_c,_d,_e,_f,_g)
   ?};
   {? PAR_SKID.get(232)='T'
:: jednostek org. dla zaleznosci sluzbowych
   || exec('prac_nad_stn','stanprac',_a,_b,_c,_d,_e,_f,_g)
:: struktury organizacyjnej i zaleznosci stanowisk
   || exec('prac_nad_org','stanprac',_a,_b,_c,_d,_e,_f,_g)
   ?}
?};

{? _begin & _e.first & (var_pres('__STP_A')<0 | (var_pres('__STP_A')>0 & __STP_A=0))
|| {? _e.size>1
   || _e.blank(1);
      _e.P:=#_a;
      {? _e.find_rec
      || _e.del
      ?};
      _e.first
   ?};
   _max:=#PAR_SKID.get(235);
   _tmp:=exec('tab_zal','stanprac');
   _tmp.index(_tmp.ndx_tmp(,,'L',,));
   _add:=$('_a.blank;{!_n:=1..'+$_e.fld_num+'|!_a[_n]:=_b[_n]!};_a.L:=_c;_a.add');
   {! _n:=1
   |? _add(_tmp,_e,_n);
      _e.next & {? _max || _n<_max || 1 ?}
   !};
   obj_del(_e);
   _e:=_tmp;

:: usuniecie pracownikow, ktorzy nie znajduja sie na stanowiskach kierowniczych (wykorzystanie pola P_NAD)
:: ER/WRT/XP/12.41/1501/0032
   {? _e.first
   || {!
      |? {? _e.P_NAD
         || _e.del
         || _e.next
         ?}
      !}
   ?};
:: usunięcie zastępstw kaskadowych
:: ER/WRT/XP/12.51/2003/0024
   {? _e.first() & _e.size()>1
   || P.cntx_psh();
      P.prefix();
      {!
      |? _zas:=_zas_N:=0;
         {? P.seek(_e.P,)
         || _zas:=exec('prac_zas_trn','stanprac',P.ref(),,_c,_d,'N',_a);
            _zas_N:=exec('prac_zas_trn','stanprac',P.ref(),,_c,_d,'T',_a)
         ?};
         {? (_zas=_a) | (_b<>0 & _zas_N=_a)
         || _e.del()
         || _e.next()
         ?}
      !};
      P.cntx_pop()
   ?};
:: koniec poprawki

   _e.first
?};

_e


\prac_nad_zal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Zwraca w postaci tabeli liste przelozonych pracownika.
::   WE: _a - ref pracownika
::       _b - 1 - nie wybiera nieobecnych pracownikow, 0 - wybiera wszystkich
::       _c - symbol slownika kodow
::       _d - symbol kodu zaleznosci sluzbowych
::       _e - alias do bufora danych
::       _f - poziom zaleznosci
::       _g - path
::   WY: alias do tabeli zawierajacej informacje o zaleznosciach
::UWAGA: poprawnosc argumentow wywolania nie jest weryfikowana
::----------------------------------------------------------------------------------------------------------------------
_typ:=exec('kod','ext_slo',_c,_d);
_noSTP:=~exec('isSTPEnabled','stp');
_por:=exec('lic','#b_domain','POR');
P.cntx_psh;
P_PZ.cntx_psh;
P_PZ.index('REVERT');
:: zaleznosci czasowe
P_PZ.prefix('P',_typ,_a,'T');
{? P_PZ.first & exec('test_heap','stanprac',_a)
|| {!
   |? P_PZ.P();
      {? P_PZ.OD<=date
      || {? {? ~_por | (_por & P_PZ.DO<>date(0,0,0)) || date<=P_PZ.DO || 1 ?}
         || {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'N'))<>null
            || _opis:=exec('opis_za','stanprac');
               {? exec('add_zal','stanprac',_e,_ref,P.WYDZIAL().SYMBOL,_f,_opis,,,,'P')
               || {? _noSTP || exec('prac_nad_old','stanprac',P.ref,_b,_c,_d,_e,_f+1,_g) ?}; 0
               ?}
            |? _b & exec('czy_jest','nieobecnosc',P.ref)
            || _opis:=exec('opis_zan','stanprac');
               {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'T'))=null
               || _opis:=exec('opis_pon','stanprac');
                  _ref:=exec('prac_pob_trn','stanprac',P.WYDZIAL,P.ST,,_c,_d)
               ?};
               {? _ref<>null
               || exec('add_zal','stanprac',_e,_ref,P.WYDZIAL().SYMBOL,_f,_opis,,,,'P')
               || {? _noSTP || exec('prac_nad_old','stanprac',P.ref,_b,_c,_d,_e,_f+1,_g) ?}; 0
               ?}
            || {? exec('add_zal','stanprac',_e,P.ref,P.WYDZIAL().SYMBOL,_f,exec('opis_bp','stanprac'),,,,'P')
               || {? _noSTP || exec('prac_nad_old','stanprac',P.ref,_b,_c,_d,_e,_f+1,_g) ?}; 0
               ?}
            ?}
         || 1
         ?}
      ?} & P_PZ.next
   !}
?};
:: zaleznosci domyslne
P_PZ.prefix('P',_typ,_a,'N');
{? P_PZ.first & exec('test_heap','stanprac',_a)
|| {!
   |? P_PZ.P();
      {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'N'))<>null
      || _opis:=exec('opis_za','stanprac');
         {? exec('add_zal','stanprac',_e,_ref,P.WYDZIAL().SYMBOL,_f,_opis,,,,'P')
         || {? _noSTP || exec('prac_nad_old','stanprac',P.ref,_b,_c,_d,_e,_f+1) ?}; 0
         ?}
      |? _b & exec('czy_jest','nieobecnosc',P.ref)
      || _opis:=exec('opis_zan','stanprac');
         {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d))=null
         || _opis:=exec('opis_pon','stanprac');
            _ref:=exec('prac_pob_trn','stanprac',P.WYDZIAL,P.ST,,_c,_d)
         ?};
         {? _ref<>null & _ref<>_a
         || exec('add_zal','stanprac',_e,_ref,P.WYDZIAL().SYMBOL,_f,_opis,,,,'P')
         || {? _noSTP || exec('prac_nad_old','stanprac',P.ref,_b,_c,_d,_e,_f+1) ?}; 0
         ?}
      || {? exec('add_zal','stanprac',_e,P.ref,P.WYDZIAL().SYMBOL,_f,exec('opis_bp','stanprac'),,,,'P')
         || {? _noSTP || exec('prac_nad_old','stanprac',P.ref,_b,_c,_d,_e,_f+1,_g) ?}; 0
         ?}
      ?} & P_PZ.next
   !}
?};
P_PZ.cntx_pop;
P.cntx_pop;

_e


\prac_nad_stn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Zwraca w postaci tabeli liste przelozonych pracownika.
::   WE: _a - ref pracownika
::       _b - 1 - nie wybiera nieobecnych pracownikow, 0 - wybiera wszystkich
::       _c - symbol slownika kodow
::       _d - symbol kodu zaleznosci sluzbowych
::       _e - alias do bufora danych
::       _f - poziom zaleznosci
::       _g - path
::   WY: alias do tabeli zawierajacej informacje o zaleznosciach
::UWAGA: poprawnosc argumentow wywolania nie jest weryfikowanl
::----------------------------------------------------------------------------------------------------------------------
_done:=0;
_par313:=@.PAR_SKID.get(313)='T';
P.cntx_psh;

UD_DEF.cntx_psh;
UD_DEF.index('PODTEC');
UD_DEF.prefix(exec('szukaj_ud_sch','schemat','PODZORG','STR_STAN'));

STZ.cntx_psh;
{? _par313
|| STZ.index('STNPOZ')
|| STZ.index('STN')
?};

STRST_P.cntx_psh();
STRST_P.index('P');
STRST_P.prefix(_a);
_loop:=STRST_P.first;
{!
|? _loop & UD_DEF.find_key(STRST_P.UD_SKL)
|!
:: KO [12.30] - obsluga parametru 313
   {? _par313
   || STZ.prefix(STRST_P.P().ST,STRST_P.P().POZWORG)
   || STZ.prefix(exec('ref_firma','ustawienia'),STRST_P.P().ST)
   ?};
   {!
   |? _loop:=STZ.first;
      {!
      |? _loop
      |! STZ.cntx_psh;
         STZ.prefix;
         {!
         |? {? STZ.seek(STZ.STZ,)
            || _brak_p:=1;
               {? (_ref:=exec('prac_pob_trn','stanprac',UD_DEF.UD_SKL,STZ.STN,,_c,_d,'N',STZ.POZWORG))<>null
:                 znaleziono pracownika pelniacego dane obowiazki na stale
               || {? exec('add_zal','stanprac',_e,_ref,UD_DEF.UD_SKL().SYMBOL,_f,exec('opis_po','stanprac'),,,,'O')
                  || {? _a<>_ref || exec('prac_nad_old','stanprac',_ref,_b,_c,_d,_e,_f+1,'O') ?};
                     _brak_p:=0;
                     _done:=1
                  ?}
               || _kier:=STZ.STN().K='T';
                  STRST_P.cntx_psh;
                  _ndx:=STRST_P.ndx_tmp('',1,'UD_SKL',,0, 'P','ST',0);
                  STRST_P.index(_ndx);
                  STRST_P.prefix(UD_DEF.UD_SKL,STZ.STN);
                  {? STRST_P.first
                  || {!
                     |? {? {? _par313
                           || STRST_P.P().POZWORG=STZ.POZWORG
                           || 1
                           ?}
                        || STRST_P.P();
                           _jest_prac:=exec('jest_prac','obiegi',,,1);
                           {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'N'))<>null & _kier
                           || _opis:=exec('opis_za','stanprac');
                              exec('add_zal','stanprac',_e,_ref,P.WYDZIAL().SYMBOL,_f,_opis)
                           |? _b & _jest_prac & exec('czy_jest','nieobecnosc',P.ref)
                           || _opis:=exec('opis_zan','stanprac');
                              {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'T'))=null
                              || _opis:=exec('opis_pon','stanprac');
                                 _ref:=exec('prac_pob_trn','stanprac',STRST_P.UD_SKL,P.ST,,_c,_d,'T',P.POZWORG)
                              ?};
                              {? _ref<>_a & _kier
                              || exec('add_zal','stanprac',_e,_ref,STRST_P.UD_SKL().SYMBOL,_f,_opis)
                              ?};
                              exec('prac_nad_old','stanprac',P.ref,_b,_c,_d,_e,_f+1)
                           |? _jest_prac
                           || {? exec('add_zal','stanprac',
                                    _e,P.ref,STRST_P.UD_SKL().SYMBOL,_f,exec('opis_stn','stanprac'),~_kier
                                 )
                              || exec('prac_nad_old','stanprac',P.ref,_b,_c,_d,_e,_f+1);
::                              podczas aktualizacji tabeli STP zbierz wszystkich przelozonych
                                {? var_pres('__STP_A')>0 & __STP_A=1
                                || _done:=0
                                || _brak_p:=0;
                                   _done:=1
                                ?}
                              ?}
                           ?}
                        ?};
                        ~_done & STRST_P.next
                     !}
                  ?};
                  STRST_P.cntx_pop;
                  STRST_P.ndx_drop(_ndx)
               ?};

               {? _brak_p & (_ref:=exec('prac_pob_trn','stanprac',UD_DEF.UD_SKL,STZ.STN,,_c,_d,,STZ.POZWORG))<>null
:                 brak pracownika stale pelniacego obowiazki i pracownika zatrudnionego,
:                 ale jest informacja o pelnionych obowiazkach z ustawiona flaga NB
               || {? exec('add_zal','stanprac',_e,_ref,UD_DEF.UD_SKL().SYMBOL,_f,exec('opis_pon','stanprac'),,,,'O')
                  || {? _a<>_ref || exec('prac_nad_old','stanprac',_ref,_b,_c,_d,_e,_f+1,'O') ?};
                     _done:=1
                  ?}
               ?};
::             zawsze zwracamy 1 aby w petli isc w gore drzewka zaleznosci sluzbowych
               1

            |? STZ.STZ=0 & STZ.STN=STRST_P.P().ST & STZ.STN().K<>'N'
            || _ref:=P.ref;
               _opis:=exec('opis_stn','stanprac');
               _jest_prac:=exec('jest_prac','obiegi',,,1);
               _path:=_g;
               {? (_ref_o:=exec('prac_pob_trn','stanprac',UD_DEF.UD_SKL,STZ.STN,,_c,_d,'N'))<>null
:                 znaleziono pracownika pelniacego dane obowiazki na stale
               || _opis:=exec('opis_po','stanprac');
                  _ref:=_ref_o;
                  _path:='O'
               |? (_ref_z:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'N'))<>null
               || _opis:=exec('opis_za','stanprac');
                  _ref:=_ref_z;
                  _path:='Z'
               |? _b & _jest_prac & exec('czy_jest','nieobecnosc',P.ref)
               || _opis:=exec('opis_zan','stanprac');
                  {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'T'))=null
                  || _opis:=exec('opis_pon','stanprac');
                     _ref:=exec('prac_pob_trn','stanprac',UD_DEF.UD_SKL,P.ST,,_c,_d,'T',P.POZWORG);
                     _path:='O'
                  ?}
               |? ~_jest_prac
               || _ref:=null
               ?};
               {? _ref<>null
               || exec('add_zal','stanprac',_e,_ref,UD_DEF.UD_SKL().SYMBOL,_f,_opis,,,,_path)
               ?};
::             podczas aktualizacji tabeli STP zbierz wszystkich przelozonych
               {? var_pres('__STP_A')>0 & __STP_A=1
               || _done:=0
               || _done:=1
               ?};
               0
            ?}
         !};
         STZ.cntx_pop;
         _loop:=(~_done & STZ.next)
      !};
      ~_done & UD_DEF.seek(UD_DEF.UD_DEF,)
   !};
   _loop:=(~_done & STRST_P.next)
!};

STRST_P.cntx_pop();
UD_DEF.cntx_pop;
STZ.cntx_pop;
P.cntx_pop;

_e


\prac_nad_org
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Zwraca w postaci tabeli liste przelozonych pracownika. Zaleznosci miedzy pracownikami ustalane sa na podstawie
::       podstawowego schematu struktury organizacyjnej oraz zaleznosci miedzy stanowiskami.
::   WE: _a - ref pracownika
::       _b - 1 - nie wybiera nieobecnych pracownikow, 0 - wybiera wszystkich
::       _c - symbol slownika kodow
::       _d - symbol kodu zaleznosci sluzbowych
::       _e - alias do bufora danych
::       _f - poziom zaleznosci
::       _g - path
::   WY: alias do tabeli zawierajacej informacje o zaleznosciach
::UWAGA: poprawnosc argumentow wywolania nie jest weryfikowaml
::----------------------------------------------------------------------------------------------------------------------
P.cntx_psh;
P.prefix;
{? ~P.seek(_a)
|| P.cntx_pop;
   return(_e)
?};
STZ.cntx_psh;
STZ.index('WYD_STN');
:: KO [12.30] - obsluga parametru 313
{? @.PAR_SKID.get(313)<>'T'
|| P.index('PRACOWST');
   STZ.prefix(P.WYDZIAL,P.ST)
|| P.index('PRACOWSP');
   STZ.prefix(P.WYDZIAL,P.ST,P.POZWORG)
?};

UD_DEF.cntx_psh;
UD_DEF.index('PODTEC');
UD_DEF.prefix(exec('szukaj_ud_sch','schemat','PODZORG','STRORG'));
UD_DEF.first;

{? STZ.first
|| _done:=0;
   {!
   |? STZ.cntx_psh;
      {!
      |? STZ.clear;
         {!
         |? {? STZ.seek(STZ.STZ,)
            || {? (_ref:=exec('prac_pob_trn','stanprac',STZ.UD_SKL,STZ.STN,,_c,_d,'N',STZ.POZWORG))<>null
:              znaleziono pracownika pelniacego dane obowiazki na stale
               || {? exec('add_zal','stanprac',_e,_ref,STZ.UD_SKL().SYMBOL,_f,exec('opis_po','stanprac'),,,,'O')
                  || {? _a<>_ref || exec('prac_nad_old','stanprac',_ref,_b,_c,_d,_e,_f+1,'O') ?};
                     _done:=1
                  ?};
                  ~_done

               |? {? @.PAR_SKID.get(313)<>'T'
                  || P.prefix(STZ.UD_SKL,STZ.STN,'T')
                  || P.prefix(STZ.UD_SKL,STZ.STN,STZ.POZWORG,'T')
                  ?};
                  P.first
:              brak informacji o stale pelnionych obowiazkach, ale udalo sie
:              odszukac pracownika zatrudnionego w komorce i na stanowisku
               || {!
                  |? _jest_prac:=exec('jest_prac','obiegi',,,1);
                     {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'N'))<>null
                     || _opis:=exec('opis_za','stanprac');
                        exec('add_zal','stanprac',_e,_ref,P.WYDZIAL().SYMBOL,_f,_opis)
                     |? _b & _jest_prac & exec('czy_jest','nieobecnosc',P.ref)
                     || _opis:=exec('opis_zan','stanprac');
                        {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'T'))=null
                        || _opis:=exec('opis_pon','stanprac');
                           _ref:=exec('prac_pob_trn','stanprac',STZ.UD_SKL,STZ.STN,,_c,_d,'T',STZ.POZWORG)
                        ?};
                        {? _ref<>null
                        || exec('add_zal','stanprac',_e,_ref,STZ.UD_SKL().SYMBOL,_f,_opis)
                        ?}
                     |? _jest_prac
                     || {? exec('add_zal','stanprac',_e,P.ref,STZ.UD_SKL().SYMBOL,_f,exec('opis_str','stanprac'))
                        || exec('prac_nad_old','stanprac',P.ref,_b,_c,_d,_e,_f+1);
::                         podczas aktualizacji tabeli STP zbierz wszystkich przelozonych
                           {? var_pres('__STP_A')>0 & __STP_A=1
                           || _done:=0
                           || _done:=1
                           ?}
                        ?}
                     ?};
                     ~_done & P.next
                  !}

               |? (_ref:=exec('prac_pob_trn','stanprac',STZ.UD_SKL,STZ.STN,,_c,_d,,STZ.POZWORG))<>null
:              brak pracownika stale pelniacego obowiazki i pracownika zatrudnionego,
:              ale jest informacja o pelnionych obowiazkach z ustawiona flaga NB
               || {? exec('add_zal','stanprac',_e,_ref,STZ.UD_SKL().SYMBOL,_f,exec('opis_pon','stanprac'),,,,'O')
                  || {? _a<>_ref || exec('prac_nad_old','stanprac',_ref,_b,_c,_d,_e,_f+1,'O') ?};
                     _done:=1
                  ?};
                  ~_done

               || 1
               ?}

            |? STZ.STZ=0 & STZ.STN=P.ST & STZ.STN().K='T' &
               {? @.PAR_SKID.get(313)='T'
               || STZ.POZWORG=P.POZWORG
               || 1
               ?}
            || _ref:=P.ref;
               _opis:=exec('opis_str','stanprac');
               _jest_prac:=exec('jest_prac','obiegi',,,1);
               _path:='B';
               {? (_ref_o:=exec('prac_pob_trn','stanprac',STZ.UD_SKL,STZ.STN,,_c,_d,'N'))<>null
:              znaleziono pracownika pelniacego dane obowiazki na stale
               || _opis:=exec('opis_po','stanprac');
                  _ref:=_ref_o;
                  _path:='O'
               |? (_ref_z:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'N'))<>null
               || _opis:=exec('opis_za','stanprac');
                  _ref:=_ref_z;
                  _path:='Z'
               |? _b & _jest_prac & exec('czy_jest','nieobecnosc',P.ref)
               || _opis:=exec('opis_zan','stanprac');
                  {? (_ref:=exec('prac_zas_trn','stanprac',P.ref,,_c,_d,'T'))=null
                  || _opis:=exec('opis_pon','stanprac');
                     _ref:=exec('prac_pob_trn','stanprac',STZ.UD_SKL,STZ.STN,,_c,_d,'T',STZ.POZWORG);
                     _path:='O'
                  ?}
               |? ~_jest_prac
               || _ref:=null
               ?};
               {? _ref<>null
               || {? exec('add_zal','stanprac',_e,_ref,STZ.UD_SKL().SYMBOL,_f+1,_opis,,,,_path)
                  || _done:=1
                  ?}
               ?};
               0
            ?}
         !};
         STZ.cntx_psh;
         _up:=STZ.seek(STZ.STZ,);
         STZ.cntx_pop;
         ~_done & _up
      !};
      STZ.cntx_pop();
      ~_done & STZ.next
   !}
?};

UD_DEF.cntx_pop;
STZ.cntx_pop;
P.cntx_pop;

_e


\prac_pob
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Funkcja wyznaczajaca zastepce pracownika na podstawie danych z P_PO.
::   WE: _a - jednostka organizacyjna
::       _b - stanowisko
::       _c - data (opcjonalnie), jesli pominieta, to przyjeta zostanie biezaca
::       _d - symbol slownika kodow
::       _e - symbol kodu zaleznosci sluzbowych
::       _f - uwzgledniaj wartosc znacznika NB (opcjonalny)
::       _g - pozycja w organizacji
::   WY: wskazanie na zastepce
::  OLD: \prac_pob/kart_poz.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null) || _a:=P.ref ?};
{? var_pres('_b')<>type_of(null) || _b:=P.ST ?};
{? var_pres('_g')<>type_of(null) || _g:=P.POZWORG ?};
_nb:={? var_pres('_f')=type_of('') || _f || '' ?};
_data:={? var_pres('_c')=type_of(date) || _c || date ?};
_zdate:=date(0,0,0);
_typ:=exec('kod','ext_slo',_d,_e);
_313:=(PAR_SKID.get(313)<>'T');

P_PO.cntx_psh();
P_PO.index('UNIQUE');

:: obowiązki pełnione na stałe
{? _313<>0
|| P_PO.prefix(_typ,_a,_b,0,'T')
|| P_PO.prefix(_typ,_a,_b,_g,'T')
?};
_loop:=P_PO.first();
{!
|? _loop
|! {? (P_PO.OD=_zdate & P_PO.DO=_zdate) |
      (_data<>_zdate & P_PO.OD<=_data & _data<=P_PO.DO)
   || {? {? _nb<>'' || -P_PO.NB=-_nb || 1 ?} &
         ~exec('czy_jest','nieobecnosc',P_PO.P,_data)
      || _val:=P_PO.P;
         P_PO.cntx_pop();
         return(_val)
      ?}
   ?};
   _loop:=(P_PO.next() & P_PZ.OD<=_data)
!};

:: obowiązki pełnione w czasie nieobecności
{? _313<>0
|| P_PO.prefix(_typ,_a,_b,0,'N')
|| P_PO.prefix(_typ,_a,_b,_g,'N')
?};
_loop:=P_PO.first();
{!
|? _loop
|! {? {? _nb<>'' || -P_PO.NB=-_nb || 1 ?} &
      ~exec('czy_jest','nieobecnosc',P_PO.P,_data)
   || _val:=P_PO.P;
      P_PO.cntx_pop();
      return(_val)
   ?};
   _loop:=P_PO.next()
!};

P_PO.cntx_pop();

null


\prac_pob_trn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Zredukowana wersja prac_pob utworzona na potrzeby transferu.
::   WE:
::   WY: null
::----------------------------------------------------------------------------------------------------------------------
null


\prac_zas
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Funkcja wyznaczająca zastępcę pracownika na podstawie danych z P_PZ.
::   WE: _a - wskazanie na pracownika (opcjonalnie), jeśli pominięty, to przyjęty będzie bieżący
::       _b - data (opcjonalnie), jeśli pominięta, to przyjęta zostanie bieżąca
::       _c - symbol słownika kodów
::       _d - symbol kodu zależności służbowych
::       _e - uwzględniaj wartość znaczników NB i CO (opcjonalny)
::       _f - sprawdź zastępstwa w dół, aż do przekazanego refa
::       _g - [niewykorzystywany]
::       _h - bufor ze wskazaniami zastępców wykorzystywany do odpisania informacji o wielu zastępcach
::       _i - [niewykorzystywany]
::       _j - aktualny poziom
::   WY:
::  OLD: \prac_zas/kart_poz.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null) | _a=null || _a:=P.ref() ?};
{? var_pres('_b')<>type_of(date) | _b=date(0,0,0) || _b:=date() ?};
_a_e:=~-{? var_pres('_e')=type_of('') || _e || '' ?};
:: ustal kontekst analizy według znaczników NB i CO
_nb:=_a_e;
_co:='TN';
{? _a_e*':'<>0
|| _str:=spli_str(_a_e,':');
   _nb:=_str[1];
   _co:=_str[2];
   obj_del(_str)
?};

:: kontrola cyklicznego wywołania
_wrap:="{? _a<>'' || ','+_a+',' || '' ?}";
_2ref:='';
{? var_pres('_f')=type_of('')
|| {? _f*_wrap($_a)<>0
::    wystąpił cykl
   || return(null)
   ?};
   _2ref:=_f
|| _2ref:=_wrap($_f)
?};
:: zapamiętaj bieżące wywołanie
_2ref+=_wrap(${? var_pres('_f')=type_of(null) || _f || _a ?});

_many:=0;
_PZAS:=~~;
{? var_pres('_h')=type_of(SYSLOG)
:: informacje o wielu zastępcach
|| _PZAS:=_h;
   _many:=1
?};
_lvl:={? var_pres('_j')=type_of(0) || _j || 0 ?};

_typ:=exec('kod','ext_slo',_c,_d);

P_PZ.cntx_psh();
P_PZ.index('UNIQUE');
{!
|? _co<>''
:: wyszukaj najpierw zastępstwa stałe,
:: potem ewentualnie na czas określony
|! P_PZ.prefix('Z',_typ,_a,1+_co);
   _loop:=P_PZ.first();
   {!
   |? _loop
   |! {? P_PZ.OD<=_b & (P_PZ.DO=date(0,0,0) | _b<=P_PZ.DO)
         &
         {? _nb<>''
         || {? _nb*'T' & P_PZ.NB='T'
            || exec('czy_jest','nieobecnosc',P_PZ.P,_b)
            |? _nb*'N' & P_PZ.NB='N'
            || 1
            ?}
         || 1
         ?}
      || _val:=P_PZ.PZ;
         {? exec('czy_jest','nieobecnosc',_val,_b)
         || _val:=exec('prac_zas','stanprac',_val,,_c,_d,_a_e,_2ref,,_PZAS,,_lvl)
         ?};
         {? _val<>null
         || {? _many<>0
            || _PZAS.blank(1);
               _PZAS.REF:=$_val;
               _PZAS.L:=_lvl;
               {? ~_PZAS.find_rec()
               || _PZAS.add(1)
               ?}
            || P_PZ.cntx_pop();
               return(_val)
            ?}
         ?}
      ?};
      _loop:=P_PZ.next()
   !};
   _co:=1-_co
!};
P_PZ.cntx_pop();

null


\prac_zas_trn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Zredukowana wersja prac_zas utworzona na potrzeby transferu.
::   WE:
::   WY: null
::----------------------------------------------------------------------------------------------------------------------
null


\opis_po
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DD [12.10]
:: OPIS: Opis dla: pełniopne obowiązki na stałe
::----------------------------------------------------------------------------------------------------------------------
'Obowiązki stałe'@


\opis_pon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DD [12.10]
:: OPIS: Opis dla: pełniopne obowiązki podczas nieobecności
::----------------------------------------------------------------------------------------------------------------------
'Obowiązki nieobecność'@


\opis_bp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DD [12.10]
:: OPIS: Opis dla: bezpośrednio podwładnl
::----------------------------------------------------------------------------------------------------------------------
'Bezpośrednio podwładny'@


\opis_za
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DD [12.10]
:: OPIS: Opis dla: zastępstwa staml
::----------------------------------------------------------------------------------------------------------------------
'Zastępstwo stałe'@


\opis_zan
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DD [12.10]
:: OPIS: Opis dla: zastępstwa podczas nieobecnofml
::----------------------------------------------------------------------------------------------------------------------
'Zastępstwo nieobecność'@


\opis_str
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DD [12.10]
:: OPIS: Opis dla zależności ze struk.fml
::----------------------------------------------------------------------------------------------------------------------
'Struktura organizacyjna'@


\opis_stn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DD [12.10]
:: OPIS: Opis dla zależności ze struktury dla wnic.fml
::----------------------------------------------------------------------------------------------------------------------
'Struktura organizacyjna - wnioski'@


\opis_pwo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.10]
:: OPIS: Opis dla zależności ze struktury pozycji w orgaac.fml
::----------------------------------------------------------------------------------------------------------------------
'Pozycja w organizacyji'@


\opis_zs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [20.42]
:: OPIS: Opis dla zależności z zależności służbowych.
::   WE:
::   WY: opis zależności
::----------------------------------------------------------------------------------------------------------------------
'Zależności służbowe'@


\lwyd_form
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Zwraca formule odpowiedzialna za wypelnienie tabeli tymczasowej informacji z tabeli UD_DEF.
::   WY: formula
::----------------------------------------------------------------------------------------------------------------------
"  _f:={? var_pres('_f')=type_of(0) || _f || 0 ?};
   UD_DEF.cntx_psh;
   {? $_c*UD_SKL.name
   || UD_DEF.index('PODTEC')
   |? $_c*UD_DEF.name
   || UD_DEF.index('SYMBOL')
   ?};
   UD_DEF.prefix(_b,_c);
   {? UD_DEF.first
   || {!
      |? _a.POZ:=_e+1;
         _a.WYD:=UD_DEF.UD_SKL;
         _a.P_PO:=_f;
         {? ~_a.find_rec & _a.add
         || _d(_a,_b,UD_DEF.ref,_d,_e+1,_f)
         ?};
         UD_DEF.next
      !}
   ?};
   UD_DEF.cntx_pop
"


\lwyd_buff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Tworzy pomocnicza tabele tymczasowa.
::   WY: alias do tabeli tymczasowej
::----------------------------------------------------------------------------------------------------------------------
tab_tmp(1,
   'POZ','INTEGER','Poziom',
   'WYD','INTEGER','Rekord',
   'P_PO','INTEGER','Wynika z pełnonych obowiązków'
)


\lstn_form
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Zwraca formule odpowiedzialna za wypelnienie tabeli tymczasowej informacji z tabeli STZ.
::   WY: formula
::----------------------------------------------------------------------------------------------------------------------
_par313:=PAR_SKID.get(313)='T';
_par232:=PAR_SKID.get(232)='T';

$("  _f:={? var_pres('_f')=type_of(0) || _f || 0 ?};
   STZ.cntx_psh;
   _add:=0;
   {? $_b*STN.name
   || "+
      {? _par313
      || "STZ.index('STNPOZ');STZ.prefix(_b,_c)"
      || "STZ.index('STN');STZ.prefix(exec('ref_firma','ustawienia'),_b)"
      ?}
      +"
   |? $_b*STZ.name
   || " + {? _par232
          || "STZ.index(__NDSTZ);"
          || "STZ.index('ST');"
          ?}
        +"
      STZ.prefix(exec('ref_firma','ustawienia'),_b);
      _add:=1
   ?};
   {? STZ.first
   || {!
      |? _a.POZ:=_e+1;
         _a.STN:=STZ.STN;
         _a.POZWORG:=STZ.POZWORG;
         _a.P_PO:=_f;
         {? ~_a.find_rec & {? _add || _a.add || 1 ?}
         || _d(_a,STZ.ref,,_d,_e+1,_f)
         ?};
         STZ.next
      !}
   ?};
   STZ.cntx_pop
")


\lstn_buff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2011]
:: OPIS: Tworzy pomocnicza tabele tymczasowa.
::   WY: alias do tabeli tymczasowml
::----------------------------------------------------------------------------------------------------------------------
:: KO [12.30] - dodanie pozycji w organizacji
tab_tmp(1,
   'POZ','INTEGER','Poziom',
   'STN','INTEGER','Rekord',
   'POZWORG','INTEGER','Pozycja',
   'P_PO','INTEGER','Wynika z pełnonych obowiązków'
)


\lstz_buff
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DD [$12.10]
:: OPIS: Tworzy pomocnicza tabele tymczasowa.
::   WY: alias do tabeli tymczasofml
::----------------------------------------------------------------------------------------------------------------------
:: KO [12.30] - dodanie pozycji w organizacji
tab_tmp(1,
   'POZ','INTEGER','Poziom',
   'WYD','INTEGER','Rekord',
   'STN','INTEGER','Rekord',
   'POZWORG','INTEGER','Rekord',
   'ZRODLO','STRING[30]',''
)


\lstz_form
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DD [$12.10]
:: OPIS: Zwraca formule odpowiedzialna za wypelnienie tabeli tymczasowej informacja z tabeli STZ.
::----------------------------------------------------------------------------------------------------------------------
: _a - tabela
: _b - wydzial
: _c - stanowisko
: _d - pozycja w organizacji
: _e - formula
: _f - poziom
: _g - zrodlo informacji

_par313:=PAR_SKID.get(313)='T';

$("STZ.cntx_psh;
   _add:=0;
   {? $_c*STN.name
   || STZ.index('WYD_STN');
:: KO [12.30] - jesli parametr 313 wlaczony to wtedy wyszukiwana jest pozycja w organizacji
      "+ {? _par313
         || "STZ.prefix(_b,_c,_d)"
         || "STZ.prefix(_b,_c)"
      ?}
      +"
   |? $_c*STZ.name
   ||
      STZ.index('ST');
      STZ.prefix(exec('ref_firma','ustawienia'),_c);
      _add:=1
   ?};
   {? STZ.first
   || {!
      |? _a.POZ:=_f+1;
         _a.WYD:=STZ.UD_SKL;
         _a.STN:=STZ.STN;
         _a.POZWORG:=STZ.POZWORG;
         _a.ZRODLO:={? var_pres('_g')=type_of('') || _g || '' ?};
         {? ~_a.find_rec & {? _add || _a.add || 1 ?}
         || _e(_a,null,STZ.ref,,_e,_f+1,_a.ZRODLO)
         ?};
         STZ.next
      !}
   ?};
   STZ.cntx_pop
")


\uruchom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [17.00]
:: OPIS: Uruchomienie czynności
::   WE: _a [STRING] - kod czynności
::       _b [STRING] - nazwa akcji
::       _c [_P] - wskazanie pracownika
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_params:=exec('mp_run_a','#b__box');
_params.ACT_UID:=_a;
_params.PROC_START:='N';
_params.AKCJA:=_b;
_params.GRUPA:='N';
_params.PORTS_IN:=exec('portsIn','#b__box',_params.ACT_UID);
exec('portsInSet','#b__box',_params.PORTS_IN,_params.ACT_UID,'P',_c);
exec('mp_run','#b__box',_params)


\zal_sluz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DD [2011]
:: OPIS: Obsługa (prezentacja) zależności służbowych.
::----------------------------------------------------------------------------------------------------------------------
{? PAR_SKID.get(232)='N' & exec('no_limit','schemat','PKD',0)=0
|| FUN.emsg(
      'Działanie funkcji nie będzie pełne ze względu na brak praw\n'
      'dostępu do wszystkich jednostek organizacyjnych przedsiębiorstwa.'@
   )
?};
VAR_DEL.delete('stz_tmp');
stz_tmp:=obj_new(10);
: okienko przegladania struktury - akronim w stz_tmp[1]
:: stz_tmp[10] tablica z dostępnymi pracownikami
{? @.PAR_SKID.get(232)<>'T'
|| stz_tmp[10]:=exec('dostepne_p','schemat','PKD','*T','*');
   stz_tmp[10].prefix()
|| stz_tmp[10]:=~~
?};

exec('mk_sto_h','stanprac');
exec('zal_tree','stanprac');
P.cntx_psh();
: obsluga parametru 313
{? @.PAR_SKID.get(313)<>'T'
|| P.index('PRACOWST');
   STZ.win_edit('REDP')
|| P.index('PRACOWSP');
   STZ.win_edit('REDPPOZ')
?};
{? PAR_SKID.get(232)='T'
|| STZ.win_edit(stz_tmp[7]);
   STZ.index(stz_tmp[8])
|| STZ.index('ST')
?};
STZ.prefix(exec('ref_firma','ustawienia'));
STO.actions('WER');
STZ.win_sel(stz_tmp[3]);
STZ.select;
P.cntx_pop();
{? PAR_SKID.get(232)='T'
|| STZ.ndx_drop(stz_tmp[8]);
   STZ.ndx_drop(stz_tmp[9])
|| {! _nx:=1..P.fld_num
   |! _acr:=P.fld_acr(_nx);
      P.fld_fml(_acr,'BEFORE_DISPLAY',"*")
   !}
?};
VAR_DEL.delete('stz_tmp');
exec('build_sto','stanprac');
1


\mk_sto_h
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DD [08.03.2011]
:: OPIS: Funkcja odbudowywuje przypisanie stanowisk do jednostek
::       na podstawie zapisow w przebiegu zatrudnienia
::----------------------------------------------------------------------------------------------------------------------
STO.cntx_psh();
H.cntx_psh();
STO.clear;
:: {? STO.first || {! |? STO.del !} ?};
H.clear();
_tab:=sql('select distinct H.WYDZIAL as WYD, STN.ST as ST '
          'from H join STN join P using (H.P,P.REFERENCE) '
          'where P.FIRMA=:_a '
          'order by 1,2',
          exec('ref_firma','ustawienia'));
UD_SKL.prefix();
STN.index('STANONAZ');
STN.prefix();
{? _tab.first
|| _oldw:='';
   {!
   |? {? _oldw<>_tab.WYD
      || UD_SKL.seek(_tab.WYD);
         _oldw:=_tab.WYD
      ?};
      {? STN.find_key(_tab.ST)
      || STO.UD_SKL:=UD_SKL.ref;
         STO.STN:=STN.ref;
         STO.ST:=STN.ST;
         STO.add(1)
      ?};
      _tab.next
   !}
?};
STO.cntx_pop();
H.cntx_pop();
1


\zal_tree
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DD [2011]
:: OPIS: Formula tworzaca okienko tymczasowe dla wyswietlania struktury
::       drzewiastej zaleznosci sluzbowych
::----------------------------------------------------------------------------------------------------------------------
: stz_tmp[1] - okienko struktury organizacyjnej
: stz_tmp[2] - okienko pracowników
: stz_tmp[3] - okienko grupowe
: stz_tmp[4] - 1 - jest okienko pracowników, 0 - okienko ze stanowiskami w jednostkach
:: stz_tmp[6] okienko redakcji dla PAR_SKID.get(232)='T'
:: stz_tmp[7] okienko redakcji na Popraw dla PAR_SKID.get(232)='T'
:: stz_tmp[8] indeks do prezentacji w oknie STZ bez jednostek
:: stz_tmp[9] indeks do sprawdzenia unikalnosci STZ bez jednostek
:: stz_tmp[10] formuła uzuchomienia czynności
stz_tmp[4]:=1;

stz_tmp[1]:=_wnd:=STZ.mk_sel('Zależności służbowe'@,'P',0,'stztree',,,,1);

{? PAR_SKID.get(232)<>'T'
|| {? @.PAR_SKID.get(313)<>'T'
   || STZ.win_fld(_wnd,UD_POM,'LST_SYM',,,80,,1,'Stanowisko (jednostka organizacyjna)'@)
   || STZ.win_fld(_wnd,UD_POM,'LST_SYM',,,80,,1,'Pozycja w organizacji (jednostka organizacyjna/stanowisko)'@)
   ?};
   STZ.win_fml(_wnd,UD_POM,'LST_SYM',,'ICON_BEFORE',"
               _ib:={? stz_tmp[4]
                    || _test:={? PAR_SKID.get(232)<>'T' || P.size || STRST_P.size ?};
                       'xwin16.png:'+{? ~_test || '81' || '38' ?}
                    || ''
                    ?};
               {? _icon:=exec('checkSTZIcon','stanprac',exec('checkSTZ','stanprac',STZ.ref()));+_icon || _icon || _ib ?}
               ")
|| STZ.win_fld(_wnd,STZ,'STN','ST',,80,,1,'Stanowisko'@);
   {? PAR_SKID.get(313)='T'
   || STZ.win_fld(_wnd,STZ,'POZWORG','KOD','KOD',,,,'Pozycja w organizacji'@)
   ?};
   STZ.win_fml(_wnd,STZ,'STN','ST','ICON_BEFORE',
               "exec('checkSTZIcon','stanprac',exec('checkSTZ','stanprac',STZ.ref()))")
?};
STZ.win_fld(_wnd,STZ,'STN','K',,-3,,1);

_chk_rec:="exec('spr_stz','stanprac')";

STZ.win_act(_wnd,1,'Rekord',,,,,_chk_rec);
{? PAR_SKID.get(232)<>'T'
|| STZ.win_act(_wnd,0,'Formuła','Dołącz'@@,,,
      "exec('add_st','stanprac')",
      "{? ~stz_tmp[4] || __stz_tab[5](); grp_disp(__stz_tab[1],__stz_tab[4]); grp_disp(P,__win2) ?}",
      1,,,,'D'
   );
   STZ.win_act(_wnd,1,'Formuła','Dołącz'@@,,,
      "exec('add_st','stanprac')",
      "{? ~stz_tmp[4] || __stz_tab[5](); grp_disp(__stz_tab[1],__stz_tab[4]); grp_disp(P,__win2) ?}",
      1,,,,'D'
   );
   STZ.win_act(_wnd,,'Popraw',,,,
      "{? PAR_SKID.get(313)<>'T' || STZ.win_edit('REDP') || STZ.win_edit('REDPPOZ') ?}",
      "{? ~stz_tmp[4] || __stz_tab[5](); grp_disp(__stz_tab[1],__stz_tab[4]); grp_disp(P,__win2) ?}"
   );
   STZ.win_act(_wnd,,'Formuła','Usuń'@@,,,"
      _ret:=exec('del_st','stanprac');
      {? stz_tmp[4]
      || {? ~STZ.get || P.prefix(-1,-1) ?}; grp_disp(P,stz_tmp[2])
      || __stz_tab[5](); grp_disp(__stz_tab[1],__stz_tab[4]); grp_disp(P,__win2)
      ?};
      _ret
   ",,,,,,'U')
|| STZ.win_act(_wnd,0,'Formuła','Dołącz'@@,,,"exec('add_st','stanprac')",,1,,,,'D');
   STZ.win_act(_wnd,1,'Formuła','Dołącz'@@,,,"exec('add_st','stanprac')",,1,,,,'D');
   STZ.win_act(_wnd,,'Popraw',,,,"STZ.win_edit(stz_tmp[7])");
   STZ.win_act(_wnd,,'Formuła','Usuń'@@,,,"_ret:=exec('del_st','stanprac');_ret",,,,,,'U');
   STZ.win_act(_wnd,,'Wyświetl',,,,"STZ.win_edit(stz_tmp[7]); STZ.display(0,0)");
   STZ.win_act(_wnd,,'Rekord',,,,"UD_POM.GLOWNY:={? STZ.STZ || 'N' || 'T' ?}",_chk_rec);
   STZ.win_act(_wnd,,'Szukaj',,,,"STZ.win_patt(STZ.win_edit(stz_tmp[7]))")
?};
STZ.win_act(_wnd,,'Formuła','Prz&esuń'@@,,,"exec('przes_st','stanprac')","0",,,,,'E');
STZ.win_act(_wnd,,'Formuła','Zwiń/rozwiń'@@,,'Zwinięcie/rozwinięcie wszystkich gałęzi'@,"exec('zwin_rozwin','#tree')"
   ,,,,,,'Z',,'target=window'
);
{? PAR_SKID.get(232)<>'T'
|| STZ.win_act(_wnd,,'DołączS',,,,"0");
   STZ.win_act(_wnd,0,'Formuła','Poza s&trukturą'@@,,,"exec('p_err_str','stanprac')",,,,,,'T');
   STZ.win_act(_wnd,1,'Formuła','Poza s&trukturą'@@,,,"exec('p_err_str','stanprac')",,,,,,'T');
   STZ.win_act(_wnd,,'Formuła','Z&najdź pracownika'@@,,,"
      _args:=exec('wybierz_args','pracownik');
      _args.DOMAIN:='PKD';
      _args.UD_SCH:=exec('domyslny','schemat','PODZORG');
      _args.UD_SKL:=exec('ud_skl_firma','schemat','PODZORG');
      _args.F_ZATR:='*T';
      _args.VIEW:='W';
      _args.WIELU:=0;
      _ret:=exec('wybierz','pracownik',_args);

      {? ~_ret.P.first()
      || return()
      ?};
      _loop:=_ret.P.first();
      P.cntx_psh();
      P.f_clear();
      P.clear();
      _jest:=0;
      {? P.seek(_ret.P.SQL)
      || STZ.cntx_psh();
         STZ.index('WYD_STN');
         {? PAR_SKID.get(313)<>'T'
         || STZ.prefix(P.WYDZIAL,P.ST)
         || STZ.prefix(P.WYDZIAL,P.ST,P.POZWORG)
         ?};
         _ref:={? STZ.first || STZ.ref || null ?};
         STZ.cntx_pop();
         _jest:=STZ.seek(_ref)
      ?};
      P.cntx_pop();
      _jest
   ",,,,,,'N');
   {? PAR_SKID.get(313)<>'T'
   || STZ.win_act(_wnd,,'Rekord',,,,"
         UD_POM.LST_SYM:=STZ.STN().ST+' ('+STZ.UD_SKL().SYMBOL+'/'+UD_SKL.OPIS+')';
         UD_POM.GLOWNY:={? STZ.STZ || 'N' || 'T' ?};
         {? stz_tmp[4]
         || P.prefix(STZ.UD_SKL,STZ.STN);
            grp_disp(P,stz_tmp[2])
         ?}
        ",
        _chk_rec)
   || STZ.win_act(_wnd,,'Rekord',,,,"
         UD_POM.LST_SYM:=
            {? STZ.POZWORG<>null || STZ.POZWORG().OPIS || 'Brak pozycji w organizacji!' ?}+
            ' ('+STZ.UD_SKL().SYMBOL+'/'+UD_SKL.OPIS+'/'+STZ.STN().ST+')';
         UD_POM.GLOWNY:={? STZ.STZ || 'N' || 'T' ?};
         {? stz_tmp[4]
         || {? STZ.POZWORG<>null
            || P.prefix(STZ.UD_SKL,STZ.STN,STZ.POZWORG)
            || P.prefix(STZ.UD_SKL,STZ.STN,-1)
            ?};
            grp_disp(P,stz_tmp[2])
         ?}
        ",
        _chk_rec)
   ?}
?};
STZ.win_act(_wnd,0,'Formuła','Wer&yfikuj'@@,,,"exec('checkSTZ','stanprac',,1,1)",,,,,,'Y');

stz_tmp[2]:=P.mk_sel('Pracownicy'@,'P',0,'ptmp01',,,,,'U');
P.win_fld(stz_tmp[2],,'T');
P.win_fld(stz_tmp[2],,'OSOBA','NAZWISKO',,20,,,'Nazwisko'@);
P.win_fld(stz_tmp[2],,'OSOBA','PIERWSZE',,15,,,'Imię'@);
P.win_fld(stz_tmp[2],,'WYDZIAL','SYMBOL',,-10,,,'Jednostka organizacyjna');
P.win_fld(stz_tmp[2],,'ZA',,,5,,,'Z',,,2,,"'T'","'N'");

stz_tmp[5]:=STRST_P.mk_sel('Pracownicy'@,'P',0,'ptmp02',,,,,'U');
STRST_P.win_fld(stz_tmp[5],,'P','T');
STRST_P.win_fld(stz_tmp[5],,'OSOBA','NAZWISKO',,20,,,'Nazwisko'@);
STRST_P.win_fld(stz_tmp[5],,'OSOBA','PIERWSZE',,15,,,'Imię'@);
STRST_P.win_fld(stz_tmp[5],,'WYDZIAL','SYMBOL',,10,,,'Jednostka organizacyjna'@);
STRST_P.win_fld(stz_tmp[5],,'P','ZA',,5,,,'Z');

{? PAR_SKID.get(232)<>'T'
|| {! _nx:=1..P.fld_num
   |! _acr:=P.fld_acr(_nx);
      P.fld_fml(_acr,'BEFORE_DISPLAY',"{? stz_tmp[10].find_key($P.ref()) || 1 || 0 ?}")
   !};
   P.win_act(stz_tmp[2],,'Rekord',,,,
     "{? stz_tmp[10].find_key($P.ref()) || _akc:='' || _akc:='POWDI(PZO):D' ?};
     P.actions_grayed(stz_tmp[2],_akc);
     REF.OSOBA:=P.OSOBA;REF.P:=P.ref
     "
   );
   P.win_act(stz_tmp[2],,'Formuła','Przełożeni'@@,,,
      "exec('show_kier','stanprac',P.ref)",,,,,,'P'
   );
   P.win_act(stz_tmp[2],,'Formuła','P&odwładni'@@,,,
      "exec('show_pod','stanprac',P.OSOBA)",,,,,,'O'
   );
   P.win_act(stz_tmp[2],,'Formuła','Weryfikujący wniosek'@@,,,
      "exec('show_kier','stanprac',P.ref,1,'TYPPOZ','AKCWNIO')",,,,,,'W'
   );
   P.win_act(stz_tmp[2],,'Wyświetl',,,,
      "{? stz_tmp[10].find_key($P.ref()) || 1 || 0 ?}","P.display()");
   _menu:='Inne akcje';
   P.win_act(stz_tmp[2],,'Menu','Inne akcje'@@,,,,,,,,,'I');
   P.win_act(stz_tmp[2],,'Formuła','Podwładni (kartoteka)'@@,_menu,,
      "exec('uruchom','stanprac','PKD_EZK_ORLP','VIEW',P.ref())",,,,,,'P'
   );
   P.win_act(stz_tmp[2],,'Formuła','Zastępstwa (kartoteka)'@@,_menu,,
      "exec('uruchom','stanprac','PKD_EZK_ORZS','VIEW',P.ref())",,,,,,'Z'
   );
   P.win_act(stz_tmp[2],,'Formuła','Pełnione &obowiązki (kartoteka)'@@,_menu,,
      "exec('uruchom','stanprac','PKD_EZK_OROB','VIEW',P.ref())",,,,,,'O'
   );
   P.win_act(stz_tmp[2],1,'Formuła','Drukuj'@@,,,
      "exec('wydr_zs','stanprac')",,,,,,'D'
   );
   P.win_act(stz_tmp[2],,'Formuła','Drukuj'@@,,,
      "exec('wydr_zs','stanprac')",,,,,,'D'
   );
   stz_tmp[3]:=STZ.grp_make('Zależności służbowe'@,
      "{? ~STZ.get || P.prefix(-1,-1) ?}",'grstztree'
   );
   STZ.grp_sel(stz_tmp[3], STZ, stz_tmp[1],,,,,,,,1,,'maximized');
   STZ.grp_sel(stz_tmp[3], P, stz_tmp[2],,,,,,,,,,'maximized')
|| stz_tmp[3]:=stz_tmp[1]
?};

STZ.dnd_sel(stz_tmp[1],,'records.STZ',"
   _mask:=dnd_info('table_name');
   _tab:=dnd_info('dropped_records');
   {? _tab.size=1
   || _ref:=dnd_info('dest_record');
      {? {? _ref=null
         || FUN.ask('Czy przenoszony rekord ma być elementem głównym?'@)
         || STZ.seek(_ref)
         ?}
      || _ref_ten:={? _ref || #STZ.ref || 0 ?};
         _stan:={? _ref || STZ.STN().ST || '' ?};
         STZ.prefix;
         {? _tab.first & STZ.seek(_tab.REF,_mask)
         || STZ.STZ:=_ref_ten;
            {? ~STZ.put(1)
            || FUN.emsg(
                  'Przypisanie stanowiska: %1 do stanowiska: %2\n'
                  'nie jest możliwe ze względu na istniejące między nimi powiązania.'@
                  [STZ.STN().ST,_stan]
               );
               {? (_pos:=dnd_info('src_pos_in_window'))<>0
               || win_set('cur_row_pos='+$_pos)
               ?}
            ?}
         ?}
      ?}
   || FUN.info('Można przenosić tylko jeden wiersz.'@)
   ?}
  ");

: obsluga drop-a z okienka z lista stanowisk w jednostkach
:: KO [12.30] - obsluga parametru 313
_drop:="
   _mask:=dnd_info('table_name');
   _tab:=dnd_info('dropped_records');
   _ref:=dnd_info('dest_record');
   _ctab:={? _mask='pracowni' || P || __stz_tab[1] ?};
   {? {? _ref=null
      || FUN.ask('Czy przenoszony rekord ma być elementem głównym?'@)
      || STZ.seek(_ref)
      ?}
   || _ref_ten:={? _ref || #STZ.ref || 0 ?};
      _stan:={? _ref || STZ.STN().ST || '' ?};
      _pozworg:={? _ref || STZ.POZWORG().KOD || '' ?};
      STZ.prefix;
      {? _tab.first
      || {!
         |? {? _ctab.seek(_tab.REF,_mask)
            || STZ.STZ:=_ref_ten;
               UD_SKL.cntx_psh(); UD_SKL.prefix();
               STN.cntx_psh(); STN.prefix();
               POZWORG.cntx_psh(); POZWORG.prefix();
               {? _ctab=P
               || _wyd:=P.WYDZIAL;
                  _st:=P.ST;
                  _pw:=P.POZWORG
               || _wyd:={? form(_ctab.WYDZIAL)<>'' & UD_SKL.seek(_ctab.WYDZIAL) || UD_SKL.ref || null ?};
                  _st:={? form(_ctab.ST_REF)<>'' & STN.seek(_ctab.ST_REF) || STN.ref || null ?};
                  _pw:={? form(_ctab.POZ_REF)<>'' & POZWORG.seek(_ctab.POZ_REF) || POZWORG.ref || null ?}
               ?};
               STZ.UD_SKL:=_wyd;
               STZ.STN:=_st;
               STZ.POZWORG:=_pw;
               {? ~STZ.add(1)
               || FUN.emsg(
                     'Przypisanie stanowiska: %1 do stanowiska: %2\n'
                     'nie jest możliwe ze względu na istniejące między nimi powiązania.'@
                     [STN.ST,_stan]
                  )
               || __stz_tab[1].cntx_psh();
                  {? __stz_tab[1].next | __stz_tab[1].prev || _ref:=__stz_tab[1].ref || _ref:=null ?};
                  __stz_tab[1].cntx_pop();

                  __stz_tab[1].cntx_psh();
                  __stz_tab[1].prefix();
                  __stz_tab[1].ZN:='T';
                  __stz_tab[1].put;
                  __stz_tab[1].cntx_pop();
                  {? {? _ref || __stz_tab[1].seek(_ref) ?}
                  || grp_disp(__stz_tab[1],__stz_tab[4])
                  ||
                     {? @.PAR_SKID.get(313)<>'T'
                     || P.prefix(-1,-1)
                     || P.prefix(-1,-1,-1)
                     ?};
                     grp_disp(__stz_tab[1],__stz_tab[4]);
                     grp_disp(P,__win2)
                  ?}
               ?};
               UD_SKL.cntx_pop(); STN.cntx_pop(); POZWORG.cntx_pop()
            ?};
            _tab.next
         !}
      ?}
   ?}
   ";
STZ.dnd_sel(stz_tmp[1],,'records.ppstz',_drop);

{? PAR_SKID.get(232)='T'
|| {? PAR_SKID.get(313)='T'
   || stz_tmp[6]:='REDPOZ';
      stz_tmp[7]:='REDPPOZ'
   || stz_tmp[6]:='RED';
      stz_tmp[7]:='REDP'
   ?};
   stz_tmp[8]:=STZ.ndx_tmp(,,'FIRMA',,,'STZ',,,'STN','ST',);
   stz_tmp[9]:=STZ.ndx_tmp(,,'FIRMA',,,'STZ',,,'STN',,)
|| stz_tmp[6]:=stz_tmp[7]:=stz_tmp[8]:=stz_tmp[9]:=''
?};

1


\build_sto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DD [08.03.2011]
:: OPIS: Funkcja odbudowywuje przypisanie stanowisk do jednostek w tabeli STO
::       na podstawie zapisow z tabeli STZ
::----------------------------------------------------------------------------------------------------------------------
_tmp:=sql('select STZ.UD_SKL, STZ.STN '
          'from STZ '
          'union '
          'select H.WYDZIAL as UD_SKL, H.ST as STN '
          'from H join P using (H.P,P.REFERENCE) '
          'where P.FIRMA=:_a '
          'order by 1,2',
          exec('ref_firma','ustawienia'));
STN.cntx_psh();
STN.prefix();
UD_SKL.cntx_psh();
UD_SKL.prefix();

STO.cntx_psh();
STO.index('UNIQUE');
STO.prefix();
: usuniecie zapisow nieaktualnych
: z tabeli STO usuwamy zapisy ktorych juz nie ma
: z tabeli _tmp usuwamy zapisy ktore juz sa w STO
{? STO.first
|| {!
   |? _tmp.prefix($STO.UD_SKL,$STO.STN);
      {? _tmp.first
      || _tmp.del; STO.next
::      || STO.del(1,1)=2
      ?}
   !}
?};
: w _tmp zostaly tylko nowe zapis - skopiowac do STO
{? _tmp.first
|| {!
   |? {? UD_SKL.seek(_tmp.UD_SKL) & STN.seek(_tmp.STN)
      || STO.UD_SKL:=UD_SKL.ref;
         STO.STN:=STN.ref;
         STO.ST:=STN.ST;
         STO.add(1)
      ?};
      _tmp.next
   !}
?};
STN.cntx_pop();
UD_SKL.cntx_pop();
STO.cntx_pop();
1


\spr_stz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ?? []
:: OPIS: Sprawdzenie rekordu dla zaleznosci slubowych
::----------------------------------------------------------------------------------------------------------------------
:: KO [12.30] - jesli parametr 313 wlaczony to wtedy sprawdzana dodatkowo jest pozycja w organizacji
_par232:=PAR_SKID.get(232);
_par313:=PAR_SKID.get(313);

{? _par232='T'
|| {? _par313<>'T'
   || _chk:=__CHK.record(STZ,,'STN')
   || _chk:=__CHK.record(STZ,,'STN','POZWORG')
   ?}
|| {? _par313<>'T'
   || _chk:=__CHK.record(STZ,,'UD_SKL','STN')
   || _chk:=__CHK.record(STZ,,'UD_SKL','STN','POZWORG')
   ?}
?};
{? _chk<>''
|| {? _par232<>'T'
   || {? _chk='STN' || _chk:='STZ_ST'
      |? _chk='UD_SKL' || _chk:='STZ_WYD'
      ?}
   ?};
   {? _par313='T' || {? _chk='POZWORG' || _chk:='STZ_PSTO' ?} ?};
   return(_chk)
?};
{? UD_POM.GLOWNY='T'
|| _chk:='';
   STZ.cntx_psh();
   STZ.index('UNIQUE');
   {? _par313='T'
   || STZ.prefix(0,STZ.UD_SKL,STZ.STN,STZ.POZWORG)
   || STZ.prefix(0,STZ.UD_SKL,STZ.STN)
   ?};
   {? STZ.first() & (-(1+menu_txt)='d')
   || FUN.emsg(
         'Dołączenie zapisu nie jest możliwe.\n'
         '(stanowisko już występuje w hierarchii)'@
      );
      {? _par313='T'
      || _chk:='STZ_PSTO'
      || _chk:='STZ_ST'
      ?}
   ?};
   STZ.cntx_pop();
   {? _chk<>'' || return(_chk) ?}

|| {? _par232='T' & (-(1+menu_txt)='d') & var_pres('__R_STZ')>0
   || {? UD_POM.GLOWNY='N'
      || {? UD_POM.POZIOM='N'
         || STZ.STZ:=#STZ.ref()
         || STZ.STZ:=__R_STZ
         ?}
      || STZ.STZ:=0
      ?};
      STZ.cntx_psh();
      STZ.index(stz_tmp[9]);
      STZ.prefix(STZ.STZ,STZ.STN);
      {? STZ.first()
      || FUN.emsg(
            'Dołączenie zapisu nie jest możliwe.\n'
            '(stanowisko już występuje w hierarchii)'@
         );
         STZ.cntx_pop();
         {? _par313='T'
         || return('STZ_PSTO')
         || return('STZ_ST')
         ?}
      ?};
      STZ.cntx_pop();
      _jedn:=STZ.UD_SKL;
      _stan:=STZ.STN;
      UD_SKL.cntx_psh();
      UD_TYP.cntx_psh();
      UD_TYP.index('SYMBOL');
      STZ.cntx_psh();
      STZ.index('WYD_STN');
      STZ.prefix(_jedn,_stan);
      {? STZ.first()
      || UD_TYP.prefix('PODZORG','PODZORG');
         UD_SKL.index('AKTYWNY');
         UD_SKL.prefix(UD_TYP.ref(),'T');
         _dalej:=1;
         {? UD_SKL.first()
         || {!
            |? {? _jedn<>UD_SKL.ref()
               || _jedn:=UD_SKL.ref();
                  _dalej:=0;
                  STZ.prefix(_jedn,_stan);
                  {? STZ.first()
                  || _dalej:=1
                  ?}
               ?};
               UD_SKL.next() & _dalej
            !}
         ?}
      ?};
      STZ.cntx_pop();
      UD_TYP.cntx_pop();
      UD_SKL.cntx_pop();
      STZ.UD_SKL:=_jedn
   ?}
?};
{? __CHK.index(STZ,-menu_txt='popraw')<>''
|| {? _par313='T'
   || return('STZ_PSTO')
   || return('STZ_ST')
   ?}
?};
{? UD_POM.GLOWNY='T' || STZ.STZ:=0 ?};
{? STZ.STZ
|| _stn:=STZ.STN;
   _ud_skl:=STZ.UD_SKL;
   _pozworg:=STZ.POZWORG;
   _chk:='';
   STZ.cntx_psh();
   {!
   |? STZ.seek(STZ.STZ,)
   |! {? STZ.STN=_stn & STZ.UD_SKL=_ud_skl & STZ.POZWORG=_pozworg
      || FUN.emsg('Modyfikacja danych nie jest możliwa.\n'
                  '(zapis już występuje w hierarchii)'@);
         {? _par313='T'
         || _chk:='STZ_PSTO'
         || _chk:='STZ_ST'
         ?}
      ?}
   !};
   STZ.cntx_pop();
   {? _chk<>'' || return(_chk) ?}
?};
''


\add_st
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KFI [2009]
:: OPIS: Akcja dodajaca stanowisko do struktury hierarchii stanowisk
::----------------------------------------------------------------------------------------------------------------------
UD_POM.GLOWNY:='N';
UD_POM.POZIOM:='N';
:: KO [12.30] - jesli parametr 313 wlaczony to wyswietlane jest inne okno do edycji struktury zaleznosci sluzbowych
{? PAR_SKID.get(232)='T'
|| STZ.win_edit(stz_tmp[6])
||{? PAR_SKID.get(313)<>'T'
  || STZ.win_edit('RED')
  || STZ.win_edit('REDPOZ')
  ?}
?};
_ref:=STZ.STZ;
VAR_DEL.delete('__R_STZ');
__R_STZ:=_ref;
STZ.blank;
_dodaj:=0;
{? STZ.edit("exec('spr_stz','stanprac')")
|| STZ.STN:=STN.ref;
   {? PAR_SKID.get(232)<>'T'
   || STZ.UD_SKL:=UD_SKL.ref
   ?};
   {? UD_POM.GLOWNY='N'
   || {? UD_POM.POZIOM='N'
      || STZ.STZ:=#STZ.ref
      || STZ.STZ:=_ref
      ?}
   || STZ.STZ:=0
   ?};
   {? __CHK.index(STZ,0)=''
   || _dodaj:=STZ.add
   ?}
?};
{? PAR_SKID.get(313)<>'T' || STZ.win_edit('REDP') || STZ.win_edit('REDPPOZ') ?};
VAR_DEL.delete('__R_STZ');
_dodaj


\del_st
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KFI [2009]
:: OPIS: Formula usuwa stanowiska w zaleznosciach sluzbowych. Formula dziala na
::       dwa sposoby: albo usuwa stanowisko razem ze stanowiskami podrzednymi, albo
::       usuwa stanowisko a stanowsika podrzedne przepina na poziom stanowiska
::       usuwanego
::----------------------------------------------------------------------------------------------------------------------
_do_del:=FUN.choice('Czy usunąć bieżący zapis?'@,,'Przesuń podrzędne'@,'Usuń podrzędne'@);
{? _do_del=1
|| STZ.cntx_psh;
   _rodzic:=STZ.STZ;
   STZ.index('UNIQUE');
   STZ.prefix(STZ.ref);
   _ref:=STZ.ref;
   _ok:=1;
   do;
   {? STZ.first
   || _ref:=STZ.ref;
      {!
      |? STZ.cntx_psh;
         STZ.prefix;
         STZ.STZ:=_rodzic;
         {? STZ.put(1)
         || STZ.cntx_pop;
            STZ.first
         || STZ.cntx_pop;
            undo;
            end;
            _ok:=0;
            0
         ?}
      !}
   ?};
   STZ.cntx_pop;
   {? _ok
   || STZ.del;
      end;
      STZ.seek(_ref)
   || FUN.emsg(
         'Stanowisko podrzędne już występuje w hierarchii.\n'
         'Usunięcie zapisu nie jest możliwe.'@
      )
   ?}
|? _do_del=2
|| exec('rekur_del','stanprac',STZ.ref);
   STZ.del
|| 0
?}


\rekur_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KFI [2009]
:: OPIS: Formula usuwajaca stanowisko wraz ze wszystkimi stanowiskami podrzednymi.
::   WE: _a - wskazanie na stanowisko w zaleznosciach sluzbowych
::----------------------------------------------------------------------------------------------------------------------
STZ.cntx_psh;
STZ.index('UNIQUE');
STZ.prefix(_a);
{? STZ.first
|| {!
   |? exec('rekur_del','stanprac',STZ.ref);
      STZ.del
   !}
?};
STZ.cntx_pop


\przes_st
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KFI [2009]
:: OPIS: Formula przesuwa stanowisko pod wskazane stanowisko (wraz ze stanowiskami)
::       podrzednymi.
::----------------------------------------------------------------------------------------------------------------------
:: KO [12.30] - obsluga poarametru 313 - pozycje w organizacji
STZ.cntx_psh;
_ref:=STZ.ref;
_rodzic:=STZ.STZ;
_wnd:=STZ.mk_sel('Stanowiska'@,'P',0,'stztree2',10,10,10,1);
{? PAR_SKID.get(232)='T'
|| STZ.win_fld(_wnd,STZ,'STN','ST',,80,,1,'Stanowisko'@);
   {? PAR_SKID.get(313)='T'
   || STZ.win_fld(_wnd,STZ,'POZWORG','KOD','KOD',,,,'Pozycja w organizacji'@)
   ?}
|| {? PAR_SKID.get(313)<>'T'
   || STZ.win_fld(_wnd,UD_POM,'LST_SYM',,,80,,1, 'Stanowisko (jednostka organizacyjna)'@);
      STZ.win_act(_wnd,,'Rekord',,,,
         "UD_POM.LST_SYM:=STZ.STN().ST+' ('+STZ.UD_SKL().SYMBOL+'/'+UD_SKL.OPIS+')'; ~~"
      );
      STZ.win_patt('WZO')
   || STZ.win_fld(_wnd,UD_POM,'LST_SYM',,,80,,1, 'Pozycja w organizacji (jednostka organizacyjna)'@);
      STZ.win_act(_wnd,,'Rekord',,,,
         "UD_POM.LST_SYM:=STZ.POZWORG().OPIS  + ' ('+STZ.UD_SKL().SYMBOL+'/'+UD_SKL.OPIS+'/'+STZ.STN().ST+')'; ~~"
      );
      STZ.win_patt('WZOP')
  ?}
?};
STZ.win_act(_wnd,,'Formuła','Wybierz'@@,,,"sel_exit","0",1,,,,'W');
STZ.win_act(_wnd,,'Formuła','Zwiń/rozwiń'@@,,'Zwinięcie/rozwinięcie wszystkich gałęzi'@,"exec('zwin_rozwin','#tree')"
   ,,,,,,'Z',,'target=window'
);
STZ.win_act(_wnd,,'Szukaj');
STZ.win_sel(_wnd);
STZ.index('ST');
STZ.prefix(exec('ref_firma','ustawienia'));
{? STZ.select
|| _ref_ten:=STZ.ref;
   _ret:=STZ.STN().ST;
   _ret2:=STZ.POZWORG().OPIS;
   STZ.clear;
   STZ.seek(_ref);
   STZ.STZ:=#_ref_ten;
   {? ~STZ.put(1)
   || {? @.PAR_SKID.get(313)<>'T'
      || FUN.emsg(
            'Przypisanie stanowiska: %1\ndo stanowiska: %2\n'
            'nie jest możliwe ze względu na istniejące między nimi powiązania.'@
            [STZ.STN().ST,_ret]
         )
      || FUN.emsg(
            'Przypisanie pozycji w organizacji: %1\ndo pozycji: %2\n'
            'nie jest możliwe ze względu na istniejące między nimi powiązania.'@
            [STZ.POZWORG().OPIS,_ret2]
         )
      ?}
   ?}
?};
STZ.win_patt('WZO');
STZ.cntx_pop


\p_err_str
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DD [08.03.2011]
:: OPIS: Funkcja wyswietla okienko z pracownikami poza struktura zaleznosci sluzbowych
::       i poza struktura jednostek organizacyjnych
::----------------------------------------------------------------------------------------------------------------------
: okresl liste stanowisk i wydzialow poza struktura na aktualny dzien
VAR_DEL.delete('__stz_tab');
__stz_tab:=obj_new(6);
: 1 - tabela, 2 - indeks WYDZIAL, ST , 3 - indeks ZN,ST,SYMBOL, 4 -
: 5 - formula aktualizacji znacznika, 6 - aktualizacja calej tabeli - po zmianie przebiegu

:: KO [12.30] - obsluga pozycji w organizacji
{? @.PAR_SKID.get(313)<>'T'
|| __stz_tab[1]:=sql(
      'select distinct '
      '  \'N\' as ZN, H.WYDZIAL, H.ST as ST_REF, \'                \' as POZ_REF, STN.ST, UD_SKL.SYMBOL '
      'from H join STN using(H.ST,STN.reference) join UD_SKL using(H.WYDZIAL, UD_SKL.reference) '
      'join P using (H.P,P.REFERENCE) '
      'where P.FIRMA=:_b and (H.DO is null or to_date(:_a)<=H.DO) '
      'order by 2,3',
      date(),exec('ref_firma','ustawienia')
   );
   __stz_tab[2]:=__stz_tab[1].index('?');
   __stz_tab[3]:=__stz_tab[1].ndx_tmp('Stanowisko, Jednostka organizacyjna'@,0,'ZN',,0,'ST',,0,'SYMBOL',,0);

: odswierzenie tabeli stanowisk w jednostkach do uzupelnienia - po modyfikacji w drzewie zaleznosci
   __stz_tab[5]:="
      _stz_tmp:=sql('select distinct UD_SKL, STN from STZ order by 1,2');
      'usuniecie zapisow ktore wystepuja w tabli STZ';
      __stz_tab[1].cntx_psh();
      __stz_tab[1].index(__stz_tab[2]);
      __stz_tab[1].prefix();
      {? __stz_tab[1].first
      || {!
         |? {? _stz_tmp.find_key(__stz_tab[1].WYDZIAL,__stz_tab[1].ST_REF)
            || __stz_tab[1].ZN:='T'
            || __stz_tab[1].ZN:='N'
            ?};
            __stz_tab[1].put();
            __stz_tab[1].next
         !}
      ?};
      __stz_tab[1].cntx_pop()
   ";
   __stz_tab[5]();

   __stz_tab[6]:="
      _tab:=sql(
         'select distinct '
         '  \\\'N\\\' as ZN, H.WYDZIAL, H.ST as ST_REF,  \\\'                \\\' as POZ_REF, STN.ST, UD_SKL.SYMBOL '
         'from H join STN using(H.ST,STN.reference) join UD_SKL using(H.WYDZIAL, UD_SKL.reference) '
         'join P using (H.P,P.REFERENCE) '
         'where P.FIRMA=:_b and (H.DO is null or to_date(:_a)<=H.DO) '
         'order by 2,3',
         date(),exec('ref_firma','ustawienia')
      );
      __stz_tab[1].cntx_psh();
      __stz_tab[1].clear();
      __stz_tab[1].erase();
      {? _tab.first
      || {!
         |? {! _i:=1.._tab.fld_num()
            |! __stz_tab[1][_i]:=_tab[_i]
            !};
            __stz_tab[1].add;
            _tab.next
         !}
      ?};
      __stz_tab[1].cntx_pop();
      __stz_tab[5]();
      __stz_tab[1].first
   "
|| __stz_tab[1]:=sql(
      'select distinct '
      '  \'N\' as ZN, H.WYDZIAL, H.ST as ST_REF, H.POZWORG as POZ_REF, STN.ST, POZWORG.OPIS as POZW, UD_SKL.SYMBOL '
      'from H join STN using(H.ST,STN.reference) join POZWORG using(H.POZWORG, POZWORG.reference) '
      '  join UD_SKL using(H.WYDZIAL, UD_SKL.reference) join P using (H.P,P.REFERENCE) '
      'where P.FIRMA=:_b and (H.DO is null or to_date(:_a)<=H.DO) '
      'order by 2,3,4',
      date(),exec('ref_firma','ustawienia')
   );
   __stz_tab[2]:=__stz_tab[1].index('?');
   __stz_tab[3]:=__stz_tab[1].ndx_tmp('Stanowisko, Jednostka organizacyjna'@,0,'ZN',,0,'ST',,0,'POZW',,0,'SYMBOL',,0);

: odswierzenie tabeli stanowisk w jednostkach do uzupelnienia - po modyfikacji w drzewie zaleznosci
   __stz_tab[5]:="
      _stz_tmp:=sql('select distinct UD_SKL, STN, POZWORG from STZ order by 1,2,3');
      'usuniecie zapisow ktore wystepuja w tabli STZ';
      __stz_tab[1].cntx_psh();
      __stz_tab[1].index(__stz_tab[2]);
      __stz_tab[1].prefix();
      {? __stz_tab[1].first
      || {!
         |? {? _stz_tmp.find_key(__stz_tab[1].WYDZIAL,__stz_tab[1].ST_REF,__stz_tab[1].POZ_REF)
            || __stz_tab[1].ZN:='T'
            || __stz_tab[1].ZN:='N'
            ?};
            __stz_tab[1].put();
            __stz_tab[1].next
         !}
      ?};
      __stz_tab[1].cntx_pop()
   ";
   __stz_tab[5]();

   __stz_tab[6]:="
      _tab:=sql(
         'select distinct '
         '  \\\'N\\\' as ZN, H.WYDZIAL, H.ST as ST_REF, H.POZWORG as POZ_REF, STN.ST, POZWORG.KOD as POZWORG, '
         '  UD_SKL.SYMBOL '
         'from H join STN using(H.ST,STN.reference) join POZWORG using(H.POZWORG, POZWORG.reference) '
         '  join UD_SKL using(H.WYDZIAL, UD_SKL.reference) '
         'where P.FIRMA=:_b and (H.DO is null or to_date(:_a)<=H.DO) '
         'order by 2,3,4',date(),exec('ref_firma','ustawienia')
      );
      __stz_tab[1].cntx_psh();
      __stz_tab[1].clear();
      __stz_tab[1].erase();
      {? _tab.first
      || {!
         |? {! _i:=1.._tab.fld_num()
            |! __stz_tab[1][_i]:=_tab[_i]
            !};
            __stz_tab[1].add;
            _tab.next
         !}
      ?};
      __stz_tab[1].cntx_pop();
      __stz_tab[5]();
      __stz_tab[1].first
   "
?};

__stz_tab[1].index(__stz_tab[3]);
__stz_tab[1].prefix('N');
OSOBA.cntx_psh();
OSOBA.prefix();
P.cntx_psh();
P.prefix();
__stz_tab[4]:=_win:=__stz_tab[1].mk_sel('Stanowiska / Pozycje w jednostkach'@,'P',0,'ppstz',,,,,'U');
{? @.PAR_SKID.get(313)<>'T'
|| __stz_tab[1].win_fld(_win,,'ST',,,44,,,'Stanowisko'@)
|| __stz_tab[1].win_fld(_win,,'ST',,,-22,,,'Stanowisko'@);
   __stz_tab[1].win_fld(_win,,'POZW',,,-21,,,'Pozycja w organizacji'@)
?};
__stz_tab[1].win_fld(_win,,'SYMBOL',,,-16,,,'Jednostka organizacyjna'@);
__stz_tab[1].win_act(_win,,'Rekord',,,,"
   UD_SKL.cntx_psh();
   UD_SKL.prefix();
   _wyd:={? UD_SKL.seek(cur_tab.WYDZIAL) || UD_SKL.ref || null ?};
   __cur_wyd:=_wyd;
   UD_SKL.cntx_pop();
   STN.cntx_psh();
   STN.prefix();
   _st:={? STN.seek(cur_tab.ST_REF) || STN.ref || null ?};
   STN.cntx_pop();
   {? @.PAR_SKID.get(313)<>'T'
   || P.prefix(_wyd,_st)
   || POZWORG.cntx_psh();
      POZWORG.prefix();
      _pozworg:={? POZWORG.seek(cur_tab.POZ_REF) || POZWORG.ref || null ?};
      POZWORG.cntx_pop();
      P.prefix(_wyd,_st,_pozworg)
   ?};
   grp_disp(P,__win2);
   ~~
");
__stz_tab[1].win_act(_win,,'Kolejność');

__win2:=P.mk_sel('Pracownicy'@,'P',0,'ppudskl',,,,,'U');
P.win_fld(__win2,P,'T',,,-9);
P.win_fld(__win2,P,'OSOBA','NAZWISKO',,30,,,'Nazwisko'@);
P.win_fld(__win2,P,'OSOBA','PIERWSZE',,20,,,'Imię'@);
P.win_act(__win2,,'Wyświetl',,,,"{? stz_tmp[10].find_key($P.ref()) || 1 || 0 ?}","P.display()");
P.win_act(__win2,,'Formuła','Przebieg zatrudnienia'@@,,,
   "exec('uruchom','stanprac','PKD_EZK_RPZA','VIEW',P.ref())",,,,,,'P'
);
P.win_act(__win2,0,'Formuła','Odśwież widok'@@,,,"__stz_tab[6]()",,,,,,'O');
P.win_act(__win2,1,'Formuła','Odśwież widok'@@,,,"__stz_tab[6]()",,,,,,'O');
P.win_act(__win2,,'Rekord',,,,"REF.OSOBA:=P.OSOBA;REF.P:=P.ref");

_wing:=__stz_tab[1].grp_make('Pracownicy poza stukturami'@,"
   grp_disp(P,__win2);
   grp_disp(STZ,stz_tmp[1])",
   'pozatmp01'
);
__stz_tab[1].grp_sel(_wing,__stz_tab[1],_win,,,,,10,,,,,'maximized');
__stz_tab[1].grp_splt(_wing,,'horizontal','bottom');
__stz_tab[1].grp_sel(_wing,P,__win2,,
   "  P.actions_grayed(__win2,{? P.F_ZATR().KOD<>'P' || 'P' || '' ?})
   ",,,,,,,,'maximized'
);
__stz_tab[1].grp_splt(_wing,,'vertical','left');
__stz_tab[1].grp_sel(_wing,STZ,stz_tmp[1],,,,,,,,,,'maximized');

__stz_tab[1].win_sel(_wing);

{? @.PAR_SKID.get(313)<>'T'
|| P.index('PRACOWST');
   P.prefix(-1,-1)
|| P.index('PRACOWSP');
   P.prefix(-1,-1,-1)
?};
STZ.actions(stz_tmp[1],'TW');
stz_tmp[4]:=0;
STZ.cntx_psh();
_sel:=__stz_tab[1].select();
STZ.cntx_pop();
stz_tmp[4]:=1;
STZ.actions(stz_tmp[1]);

&__win2;
VAR_DEL.delete('__stz_tab');

P.cntx_pop();
OSOBA.cntx_pop();
_sel


\show_kier
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Dla wskazanego pracownika formuła wyznacza przełożonych. Wynik prezentowany jest w oknie wertowania lub
::       zwracany w postaci tabeli tymczasowej (w zależnosci od parametru _f).
::       Uwaga: wartości zapisywane do pola_tmp.J są wykorzystywane przez zewnętrzne formuły.
::   WE: [_a] [REFERENCE] - Ref pracownika [domyślnie: ZS_DEF.P].
::       [_b] [NUMBER]    - Tryb pracy:
::                            0 - Wyznaczenie wszystkich przełożonych.
::                            1 - Symulacja wyszukiwania przełożonego dla wniosku urlopowego.
::       [_c] [STRING]    - Symbol słownika kodów [domyślnie: NIEZNANY].
::       [_d] [STRING]    - Symbol kodu zależności służbowych [domyślnie: NIEZNANY].
::       [_e] [STRING]    - Symbol czynności, do której weryfikowane są uprawnienia [domyślnie: PKW_POR_IWWU].
::                          Parametr wykorzystywany dla _b=1.
::       [_f] [NUMBER]    - Uwzględniać nieobecności?
::                            0 - Nie [domyślnie]. Wyszukiwany będzie bezpośredni przełożony - jego ewentualne
::                                nieobecności nie są analizowane.
::                            1 - Tak. Jeżeli przełożony jest nieobecny - wyszukiwany będzie zastępujący przełożonego.
::                          Uwaga: wartość domyślna jest zgodna z wartością parametru _b.
::       [_g] [NUMBER]    - Przetwarzanie wsadowe (bez okienka): 0/1 [domyślnie: 0].
::   WY: Tabela tymczasowa z wynikiem.
::----------------------------------------------------------------------------------------------------------------------
ZS_TYP.cntx_psh();
ZS_DEF.cntx_psh;
P.cntx_psh();
P.clear;

_slo:=~~;
_kod:=~~;
{? var_pres('_a')<>type_of(null)
|| _kod:=ZS_TYP.SLO_KOD().KOD;
   _slo:=SLO_TYP.SYMBOL;
   _a:=ZS_DEF.P
?};

{? var_pres('_b')<>type_of(1) || _b:=0 ?};
{? var_pres('_c')<>type_of('') | |_c='' || _c:='NIEZNANY' ?};
{? var_pres('_d')<>type_of('') | |_d='' || _d:='NIEZNANY' ?};
_uid_act:={? var_pres('_e')=type_of('') & |_e<>'' || _e || 'PKW_POR_IWWU' ?};
_nb:={? var_pres('_f')=type_of(1) || _f || _b ?};
_batch:=var_pres('_g')=type_of(1) & _g;

{? _b
|| _tmp:=exec('tab_zal','stanprac');
   _tmp.index(_tmp.ndx_tmp(,,'L',,));
   'dzialanie ponizszej procedury powinno byc zgodne z procedura mod z wnio_url.fml';
   _SZEF:=exec('prac_nad','stanprac',_a,_nb,_c,_d);
   _dalej:=1;
   {? _SZEF.first()
   || P.cntx_psh();
      P.prefix();
      {? _SZEF.P=#_a
      || _sam:=1;
         {! _ind:=1.._SZEF.fld_num() |! _tmp[_ind]:=_SZEF[_ind] !};
         _tmp.J:='Samoakceptacja'@;
         _tmp.add()

      || _dalej:=1;
         {!
         |? _dalej
         |! {? P.seek(_SZEF.P,)
            || USERS.cntx_psh();
               USERS.index('OSOBA');
               USERS.prefix(P.OSOBA);
               _em:=0;
               _akt_user:=0;
               _akt_role:=0;
               {? USERS.first()
               || {!
                  |? {? USERS.AKT='T'
                     || _akt_user:=1;
                        _em:=USERS.EMAIL<>'';
                        {? exec('chk_role','#b__box',USERS.ref(),_uid_act)
                        || _akt_role:=1;
                           _dalej:=1
                        ?}
                     ?};
                     _dalej & USERS.next()
                  !}
               ?};
               USERS.cntx_pop();

               {! _ind:=1.._SZEF.fld_num() |! _tmp[_ind]:=_SZEF[_ind] !};
               {? _akt_user & _akt_role
               || _tmp.J:='Akceptujący'@
               || {? ~_akt_user
                  || _tmp.J:='Brak użytkownika'@
                  |? ~_akt_role
                  || _tmp.J:='Brak czynności: %1'@[_uid_act]
                  ?}
               ?};
               {? ~_em
               || _tmp.J+={? +_tmp.J || ', b' || 'B' ?} + 'rak e-maila'
               ?};
               _tmp.add()
            ?};
            {? ~_SZEF.next()
            || _dalej:=0
            ?}
         !}
      ?};
      P.cntx_pop()
   ?}
|| _tmp:=exec('prac_nad','stanprac',_a,_nb,_slo,_kod)
?};

{? ~_batch
|| _wnd:=_tmp.mk_sel('Przełożony'@,'P',0,'prac_zs_def_nad',,,8,,'U');
   _tmp.win_fld(_wnd,,'L',,,-2);
   {? _b
   || _tmp.win_fld(_wnd,,'J',,,-15,,,'Test akceptacji'@);
      _tmp.win_act(_wnd,,'Rekord',,,,"cur_tab.J='Akceptujący'@ | cur_tab.J='Samoakceptacja'@")
   || _tmp.win_fld(_wnd,,'J',,,15)
   ?};
   _tmp.win_fld(_wnd,,'T',);
   _tmp.win_fld(_wnd,,'NAZWISKO',,,20);
   _tmp.win_fld(_wnd,,'IMIE',,,15);
   _tmp.win_fld(_wnd,,'STN',,,20);
   {? @.PAR_SKID.get(313)='T'
   || _tmp.win_fld(_wnd,,'POZWORG',,,10)
   ?};
   _tmp.win_fld(_wnd,,'WYDZIAL',,,-15);
   _tip:='Zmiana parametrów przy określaniu przełożonego'@;
   _tmp.win_act(_wnd,0,'Formuła','Zmień parametry'@@,,_tip,"sel_exit()",,1,,,,'Z');
   _tmp.win_act(_wnd,1,'Formuła','Zmień parametry'@@,,_tip,"sel_exit()",,1,,,,'Z');
   _tmp.win_btn(_wnd,'text=%1,panel=bottom'['Zmień parametry'@],'menu:Z');
   _tmp.win_sel(_wnd);

   _OPT:=exec('prac_opt_buff','stanprac');
   _num:=_tmp.fld_num();
   _done:=0;
   {!
   |? ~_done
   |! _done:=1;
      {? _tmp.select()
      || _opt:=exec('prac_opt_edit','stanprac',_OPT);
         {? _opt.ok<>0
         || _NAD:=exec('prac_nad','stanprac',_a,_opt.str,_slo,_kod);
            _tmp.erase();
            _loop:=_NAD.first();
            {!
            |? _loop
            |! _tmp.blank(1);
               {! _ii:=1.._num
               |! _tmp[_ii]:=_NAD[_ii]
               !};
               _tmp.add();
               _loop:=_NAD.next()
            !};
            obj_del(_NAD);
            _tmp.first();
            _done:=0
         ?};
         obj_del(_opt)
      ?}
   !}
?};

ZS_DEF.cntx_pop;
ZS_TYP.cntx_pop();
P.cntx_pop();

_tmp


\show_pod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Pokazuje okienko z pracownikami podwladnymi
::   WE: _a - ref osoby, jesli brak to ZS_DEF.P().OSOBA
::----------------------------------------------------------------------------------------------------------------------
ZS_TYP.cntx_psh();
ZS_DEF.cntx_psh();
P.cntx_psh();

_slo:=~~;
_kod:=~~;
{? var_pres('_a')<>type_of(null)
|| _kod:=ZS_TYP.SLO_KOD().KOD;
   _slo:=SLO_TYP.SYMBOL;
   _a:=ZS_DEF.OSOBA

?};
_podwlad:=exec('prac_pod','stanprac',_a,_slo,_kod);
_okienko:=_podwlad.mk_sel('Podwładni'@,'P',0,'prac_zs_def_pod',,,,,'U');
_podwlad.win_fld(_okienko,,'L',,,3);
_podwlad.win_fld(_okienko,,'J',,,-15);
_podwlad.win_fld(_okienko,,'T',);
_podwlad.win_fld(_okienko,,'NAZWISKO',,,20);
_podwlad.win_fld(_okienko,,'IMIE',,,15);
_podwlad.win_fld(_okienko,,'STN',,,20);
:: KO [12.30] - obsluga pozycji w organizacji
{? @.PAR_SKID.get(313)='T'
|| _podwlad.win_fld(_okienko,,'POZWORG',,,10)
?};
_podwlad.win_fld(_okienko,,'WYDZIAL',,,-15);
_podwlad.win_act(_okienko,,'Kolejność');
_podwlad.win_sel(_okienko);
_podwlad.select();

P.cntx_pop();
ZS_DEF.cntx_pop();
ZS_TYP.cntx_pop();
~~


\stz_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2006]
:: OPIS: Wartość początkowa pola STZ.STZ.
::----------------------------------------------------------------------------------------------------------------------
{? cur_tab(1,1)=STZ || #STZ.ref || STZ.ref ?}


\stn_lck
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2006]
:: OPIS: Przed redagowaniem pola EDIT_VAR.STZ_ST.
::----------------------------------------------------------------------------------------------------------------------
:: KO [12.30] - edycja stanowiska mozliwa gdy wypelniony jest wydzial i puste jest pole z poycja w organizacji
{? PAR_SKID.get(313)<>'T'
|| EDIT_VAR.STZ_WYD<>''
|| EDIT_VAR.STZ_WYD<>'' & EDIT_VAR.STZ_PSTO=null
?}


\wyd_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2006]
:: OPIS: Przed wyświetleniem pola EDIT_VAR.STZ_WYD.
::----------------------------------------------------------------------------------------------------------------------
EDIT_VAR.STZ_WYD:=STZ.UD_SKL().SYMBOL


\wyd_lck
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2006]
:: OPIS: Przed redagowaniem pola EDIT_VAR.STZ_WYD.
::----------------------------------------------------------------------------------------------------------------------
EDIT_VAR.STZ_ST=null


\wyd_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GS [2006]
:: OPIS: Obsługa klawisza F3 dla pola EDIT_VAR.STZ_WYD.
::----------------------------------------------------------------------------------------------------------------------
exec('ud_def_symbol_f3','schemat',
   'PODZORG',
   {? PAR_SKID.get(232)<>'T' || 'STRORG' || 'STR_STAN' ?},
   'PKD',
   1
)


\wyd_spr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2006]
:: OPIS: Po redagowaniu pola EDIT_VAR.STZ_WYD.
::----------------------------------------------------------------------------------------------------------------------
STZ.UD_SKL:=exec('ud_skl_symbol_ae','schemat','PODZORG','PKD',1)


\stn_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2006]
:: OPIS: Przed wyświetleniem pola EDIT_VAR.STZ_ST.
::----------------------------------------------------------------------------------------------------------------------
EDIT_VAR.STZ_ST:=exec('szukaj_sto','stanprac',STZ.UD_SKL,STZ.STN)


\stn_spr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [2006]
:: OPIS: Po redagowaniu pola EDIT_VAR.STZ_ST.
::----------------------------------------------------------------------------------------------------------------------
STZ.STN:=EDIT_VAR.STZ_ST().STN;
1


\pw_stzpsto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KO [12.30]
:: OPIS: Akcja przed wyświetleniem zmiennej EDIT_VAR.STZ_PSTO
::----------------------------------------------------------------------------------------------------------------------
_sto:=exec('szukaj_sto','stanprac',STZ.UD_SKL,STZ.STN);
EDIT_VAR.STZ_PSTO:=exec('szukaj_psto','stanprac',_sto,STZ.POZWORG)


\pr_stzpsto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KO [12.30]
:: OPIS: Akcja przed redkacja zmiennej EDIT_VAR.STZ_PSTO
::----------------------------------------------------------------------------------------------------------------------
EDIT_VAR.STZ_ST<>null


\po_stzpsto
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KO [12.30]
:: OPIS: Akcja po redkacji zmiennej EDIT_VAR.STZ_PSTO
::----------------------------------------------------------------------------------------------------------------------
STZ.POZWORG:=EDIT_VAR.STZ_PSTO().POZWORG;
1


\zal_strst_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Tworzy tabelke tymczasowa ze str. org. dla zaleznosci sluzbowych oraz okienko grupowe z ta
::       struktura oraz pracownikami podpietymi do danej struktury
::  OLD: \okienko/stanprac.fml
::----------------------------------------------------------------------------------------------------------------------
_typ:=exec('szukaj_ud_typ','schemat','PODZORG');
_sch:=exec('szukaj_ud_sch','schemat',_typ,'STR_STAN');
{? _sch=null
|| {? FUN.ask(
         'Nie zdefiniowano struktury organizacyjnej dla zależności służbowych.\n'
         'Czy utworzyć odpowiednią strukturę?'@
      )
   || {? FUN.ask(
            'Stworzenie struktury organizacyjnej dla zależności służbowych wymusza jej pielęgnowanie\n'
            'dla poprawnego działania funkcji ustalających zależności służbowe między pracownikami.\n'
            'Czy kontynuować?'@
         )
      || exec('stan_org','stanprac');
         exec('storg_p','stanprac');
         _sch:=exec('szukaj_ud_sch','schemat',_typ,'STR_STAN')
      || return()
      ?}
   || return()
   ?}
?};

_STR:=tab_tmp(2,
   'TREE',  'TREE_REF',,
   'SYMBOL','STRING[16]',,
   'OPIS','STRING[60]',,
   'UD_SKL','INTEGER',
);
exec('mk_tree','stanprac',_sch,null,null,_STR);

_TMP:=sql(
   'select distinct UD_SKL.SYMBOL, UD_SKL.OPIS, UD_SKL.REFERENCE as SKL_REF, 0 as UD_SKL '
   'from STRST_P join UD_SKL using(STRST_P.UD_SKL,UD_SKL.REFERENCE) '
   'where UD_SKL.SYMBOL not in (select :_a.SYMBOL from :_a)',
   _STR
);
_loop:=_TMP.first;
_jest:=_loop;
{!
|? _loop
|! _TMP.UD_SKL:=BIT.sqlint(_TMP.SKL_REF);
   _TMP.put;
   _loop:=_TMP.next
!};
_TMP.index(_TMP.ndx_tmp('Symbol',,'SYMBOL',,));

_refresh:="
   STRST_P.index('UD_SKL');
   STRST_P.prefix(cur_tab(1,1).UD_SKL);
   grp_disp(STRST_P,'WER',,1)";

: drzewko struktury dla zaleznosci sluzbowych
_tree:=_STR.mk_sel('Jednostki organizacyjne'@,'N',0,,,,,1);

_STR.win_fld(_tree,,'SYMBOL',,,31,,,'Symbol'@);
_STR.win_act(_tree,,'Formuła','Struktura stanowisk'@@,,'Wyświetlenie zależności między stanowiskami'@,
   "exec('zal_sluz','stanprac')",,,,,,'S'
);
_STR.win_act(_tree,,'Formuła','Zwiń/rozwiń'@@,,'Zwinięcie/rozwinięcie wszystkich gałęzi'@,
   "exec('zwin_rozwin','#tree')",,,,,,'Z',,'target=window');
_STR.win_act(_tree,0,'Formuła','Wer&yfikuj'@@,,,"exec('checkSTRST_P','stanprac',,1)",,,,,,'Y');
_STR.win_fml(_tree,,'SYMBOL','SYMBOL','ICON_BEFORE',"
   _TMP:=cur_tab(1,1);
   _ndx:={? _TMP.tr_state=1 || '5' || '4' ?};
   _TMP.cntx_psh;
   _TMP.prefix(#_TMP.ref);
   {? ~_TMP.first
   || _ndx:='6'
   ?};
   _TMP.cntx_pop;
   'xwin16.png:7'+_ndx
");

_list:=_TMP.mk_sel('Jednostki organizacyjne'@,'N',0,,,,,,'U');
_TMP.win_fld(_list,,'SYMBOL',,,10,,,'Symbol'@);
_TMP.win_fld(_list,,'OPIS',,,20,,,'Opis'@);

_grp:=_STR.grp_make('Struktura dla zależności służbowych'@,,'str_wnioskow');
{? _jest
|| _STR.grp_sel(_grp,_STR,_tree,'Struktura dla zależności'@,_refresh,,,,,,,,'maximized_with_title');
   _STR.tab_splt(_grp,,'vertical','right')
|| _STR.grp_sel(_grp,_STR,_tree,,_refresh,,,,,,,,'maximized_with_title');
   _STR.grp_splt(_grp,,'vertical','right')
?};
_STR.grp_sel(_grp,STRST_P,'WER',,,,,,"
   _hide:={? STRST_P.index('?')='UD_SKL' || 'C' || 'T' ?};
   STRST_P.actions('WER',_hide,'D:D',1)",,,,
   'maximized_with_title'
);
{? _jest
|| _STR.grp_sel(_grp,_TMP,_list,'Jednostki poza strukturą',_refresh,,,,,,,,'maximized_with_title');
   _STR.tab_splt(_grp,,'vertical','right');
   _STR.grp_sel(_grp,STRST_P,'WER',,,,,,"STRST_P.actions('WER','DWRCT:D','P:',1)",,,,
      'maximized_with_title'
   )
?};

TMP_SSP:=_STR;
okienko:=_tree;

_skl:=exec('ud_skl_firma','schemat','PODZORG');
_STR.blank(1);
_STR.UD_SKL:=#_skl;
{? _STR.find_rec
|| _STR.tr_root(_tree,1,_STR.TREE,#_STR.ref)
?};

STRST_P.actions('WER','C:',,1);
_STR.win_sel(_grp);
_STR.select;

&TMP_SSP;
&okienko;
obj_del(_STR);

0


\stan_org
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Tworzy schemat jednostek org. dla wnioskow STR_STAN i kopiuje do niego STRORG'a
::----------------------------------------------------------------------------------------------------------------------
_typ:=exec('szukaj_ud_typ','schemat','PODZORG');
_baza:=exec('domyslny','schemat',_typ);
_nowy:=exec('dodaj_ud_sch','schemat',_typ,'STR_STAN','Struktura organizacyjna dla zależności służbowych','T');

exec('kopiuj_str','stanprac',_baza,0,_nowy,0)


\kopiuj_str
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [12.10]
:: OPIS: Kopiuje strukture drzewa
::   WE: _a - wskazanie na schemat bazowy
::       _b - numer rekordu nadrzednego
::       _c - wskazanie na schemat docelowy
::       _d - numer rekordu nadrzednego
::----------------------------------------------------------------------------------------------------------------------
UD_DEF.cntx_psh;
UD_DEF.index('SYMBOL');
UD_DEF.prefix(_a,_b);
_loop:=UD_DEF.first;
{!
|? _loop
|! UD_DEF.UD_SCH:=_c;
   UD_DEF.UD_DEF:=_d;
   UD_DEF.UD_POZ:=exec('kopiuj_poz','stanprac',UD_DEF.UD_POZ,_c);
   UD_DEF.cntx_psh;
   UD_DEF.clear;
   _def:=0;
   {? UD_DEF.add(1)
   || _def:=#UD_DEF.ref
   ?};
   UD_DEF.cntx_pop;
   exec('kopiuj_str','stanprac',_a,#UD_DEF.ref,_c,_def);
   _loop:=UD_DEF.next
!};
UD_DEF.cntx_pop


\kopiuj_poz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DRO [12.10]
:: OPIS: Kopiuje opis poziomu drzewa
::   WE: _a - wskazanie rekord bazowy
::       _b - wskazanie na schemat docelowy
::----------------------------------------------------------------------------------------------------------------------
_ret:=null;
UD_POZ.cntx_psh;
UD_POZ.clear;
UD_POZ.index('NUMER');
{? UD_POZ.seek(_a)
|| {? {? ~UD_POZ.find_key(_b,UD_POZ.NUMER)
      || UD_POZ.UD_SCH:=_b;
         UD_POZ.add(1)
      || 1
      ?}
   || _ret:=UD_POZ.ref
   ?}
?};
UD_POZ.cntx_pop;
_ret


\storg_p
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Kasuje z tabeli STRST_P i przepisuje do niej pracownikow i ich jednostki org
::----------------------------------------------------------------------------------------------------------------------
STRST_P.clear;
STRST_P.erase;
P.cntx_psh();
P.clear;
P.for_each("
   STRST_P.WYDZIAL:=P.WYDZIAL;
   STRST_P.UD_SKL:=P.WYDZIAL;
   STRST_P.OSOBA:=P.OSOBA;
   STRST_P.ST:=P.ST;
   STRST_P.P:=P.ref;
   STRST_P.F_ZATR:=P.F_ZATR;
   STRST_P.add
",1);
P.cntx_pop()


\mk_tree
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Przepisuje do tabeli tymczasowej, strukture dla wnioskow urlopowych
::----------------------------------------------------------------------------------------------------------------------
_d.cntx_psh;
UD_DEF.cntx_psh;
UD_DEF.index('SYMBOL');
UD_DEF.prefix(_a,_b);
_loop:=UD_DEF.first;
{!
|? _loop
|! _d.SYMBOL:=UD_DEF.SYMBOL;
   _d.OPIS:=UD_DEF.OPIS;
   _d.UD_SKL:=UD_DEF.UD_SKL;
   _d.TREE:=_c;
   {? _d.add
   || exec('mk_tree','stanprac',_a,UD_DEF.ref,#_d.ref,_d)
   ?};
   _loop:=UD_DEF.next
!};
UD_DEF.cntx_pop;
_d.cntx_pop


\rek_rzed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Ukrywa/pokazuje akcje podWladni w okienku struktury dla wnioskow url.
::   WE: _a [NUMBER] - Rekord bieżący? [0 - nie / 1 - tak]
::----------------------------------------------------------------------------------------------------------------------
REF.P:=STRST_P.P;
0


\przesun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Przesuwa pracownika do wybranej jednostki organizacyjnej dla wnioskow
::----------------------------------------------------------------------------------------------------------------------
_SKL:=exec('ud_def_wybierz','schemat','PODZORG','STR_STAN','PKD',1,,1).UD_SKL;
{? _SKL<>null
|| _new:=_SKL;
   _old:=STRST_P.UD_SKL;
   STRST_P.P;
   STRST_P.cntx_psh;
   STRST_P.prefix;
::przesuwa wybranego pracownika w nicosc, zeby sprawdzic czy mozna go przesunac w cos
   STRST_P.UD_SKL:=null;
   STRST_P.put;
::sprawdza czy dany pracownik nie jest juz w galezi do ktorej chcemy go przeniesc
   {? exec('can_addP','stanprac')
   || STRST_P.UD_SKL:=_new
   || STRST_P.UD_SKL:=_old
   ?};
   STRST_P.put;
   STRST_P.cntx_pop
?}


\can_addP
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Sprawdza czy w galezi struktury jednostek dla wnioskow urlopowych, do ktorej chcemy dodac
::       pracownika, jest juz ten pracownik
::   WY: 1 - nie ma pracownika, mozna dodac
::       0 - jest pracownik, nie mozna dodac
::----------------------------------------------------------------------------------------------------------------------
STRST_P.cntx_psh;
STRST_P.index('P');
STRST_P.prefix(P.ref);
_ret:=1;
:: czy pracownik jest juz w strukturze wnioskow
{? STRST_P.first
|| UD_SKL.cntx_psh;
   UD_SKL.clear;
   UD_SCH.index('TECH');
   UD_SCH.prefix('PODZORG','STR_STAN',);
   {? UD_SCH.first & UD_SKL.seek(TMP_SSP.UD_SKL,)
   || _ref_skl:=#UD_SKL.ref;
      UD_DEF.index('PODTEC');
      UD_DEF.prefix(UD_SCH.ref, UD_SKL.ref);
:: pierwszy warunek, czy w jednostce do ktorej chcemy dopisac pracownika i w jednostkach nadrzednych
:: nie ma juz przypisanego tego pracownika
      {? UD_DEF.first
      || {? var_pres('JEDN')>100 || obj_del(JEDN) ?};
         JEDN:=tab_tmp(1,'UD_SKL','INTEGER',);
:: zapisuje do tabeli tymczasowej jednostke do ktorej chcemy dodac pracownika
         JEDN.UD_SKL:=#UD_DEF.UD_SKL;
         JEDN.add;
         UD_DEF.prefix;
:: zapisuje do tab. tym. wszystkie jednostki nadrzedne
         {!
         |? UD_DEF.UD_DEF
         |! UD_DEF.seek(UD_DEF.UD_DEF,);
            JEDN.UD_SKL:=#UD_DEF.UD_SKL;
            JEDN.add
         !};
:: sprawdza czy w tab. tym. znajduje sie jednostka w ktorej jest juz pracownik
         {!
         |? {? JEDN.find_key(#STRST_P.UD_SKL)
            || FUN.emsg(
                  'Wybrany pracownik jest w jednostce %1, która znajduje się w tej samej gałęzi drzewa.\n'
                  'Dodanie nie jest możliwe.'@
                  [STRST_P.UD_SKL().SYMBOL]
               );
               _ret:=0
            ?};
            _ret & STRST_P.next
         !};
:: drugi warunek, dla wszystkich jednostek w ktorych jest juz pracownik i jednostek dla nich nadrzednych
:: sprawdza czy nie ma jednostki do ktorej chcemy dodac pracownika
         {? STRST_P.first & _ret
         || {!
            |? UD_DEF.prefix(UD_SCH.ref, STRST_P.UD_SKL);
               {? UD_DEF.first
               || JEDN.erase;
:: dodaje jednostke w torej jest juz pracownik
                  _ref_jedn:=UD_DEF.UD_SKL;
                  JEDN.UD_SKL:=#UD_DEF.UD_SKL;
                  JEDN.add;
                  UD_DEF.prefix;
:: dodaje jednostki nadrzedne
                  {!
                  |? UD_DEF.UD_DEF
                  |! UD_DEF.seek(UD_DEF.UD_DEF,);
                     JEDN.UD_SKL:=#UD_DEF.UD_SKL;
                     JEDN.add
                  !};
:: sprawdza czy w tab. tym. jest jednostka do ktorej chcemy przypisac pracownika
                  {? JEDN.find_key(_ref_skl)
                  || UD_SKL.seek(_ref_jedn);
                     FUN.emsg(
                        'Wybrany pracownik jest w jednostce %1, która znajduje się w tej samej gałęzi drzewa.\n'
                        'Dodanie nie jest możliwe.'@
                        [STRST_P.UD_SKL().SYMBOL]
                     );
                     _ret:=0
                  ?}
               ?};
               _ret & STRST_P.next
            !}
         ?};
         obj_del(JEDN);
         &JEDN
      ?}
   ?};
   UD_SKL.cntx_pop
?};
STRST_P.cntx_pop;
_ret


\add_ssp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Dodaje do tabelki STRST_P wybranego pracownika
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('wybierz_args','pracownik');
_args.DOMAIN:='PKD';
_args.UD_SCH:=exec('domyslny','schemat','PODZORG');
_args.UD_SKL:=exec('ud_skl_firma','schemat','PODZORG');
_args.F_ZATR:='*T';
_args.VIEW:='W';
_ret:=exec('wybierz','pracownik',_args);

_loop:=_ret.P.first();
P.cntx_psh();
P.f_clear();
P.clear();
{!
|? _loop
|! {? P.seek(_ret.P.SQL) & exec('can_addP','stanprac')
   || UD_SKL.clear;
      UD_SKL.seek(TMP_SSP.UD_SKL,);
      STRST_P.UD_SKL:=UD_SKL.ref();
      STRST_P.P:=P.ref();
      STRST_P.F_ZATR:=P.F_ZATR;
      STRST_P.OSOBA:=P.OSOBA;
      STRST_P.ST:=P.ST;
      STRST_P.WYDZIAL:=P.WYDZIAL;
      STRST_P.POZWORG:=P.POZWORG;
      STRST_P.add()
   ?};
   _loop:=_ret.P.next()
!};
P.cntx_pop();
~~


\sz_dokl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Szukanie dokladne w tabeli STRST_P
::----------------------------------------------------------------------------------------------------------------------
exec('szukaj_s','stanprac',':*')


\sz_kont
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Szukanie kontekstowe w tabeli STRST_P
::----------------------------------------------------------------------------------------------------------------------
exec('szukaj_s','stanprac',':-')


\sz_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Szukanie na f3 (czyli kolejne wywolania tego samego wzorca) w tabeli STRST_l
::----------------------------------------------------------------------------------------------------------------------
exec('szukaj_s','stanprac',SZUKAJ.ST_RSZUK,0)


\szukaj_s
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Formula wyszukujaca rekordy w tabeli STRST_P
::  OLD: \szukaj_s/szukaj.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')<=type_of(~~)
|| SZUKAJ.win_edit('WZOSTRST');
   SZUKAJ.blank;
   _buf:=obj_new(@.CLASS.BUFFER,'SZUKAJ');
   {!
   |? _b:=SZUKAJ.edit();
      {? _buf.is_equal() & _b
      || FUN.info('Niewypełniony wzorzec.'@);
         1
      ?}
   !};
   obj_del(_buf)
?};
SZUKAJ.ST_RSZUK:=_a;
_ret:=cur_tab(1,1).find_tab(0,
   'P','FIRMA','=',exec('ref_firma','ustawienia'),
   'P','T',_a,{? _a=':*' || {? +SZUKAJ.T || form(SZUKAJ.T,-9) || '' ?} || SZUKAJ.T ?},
   'OSOBA','NAZWISKO',_a,SZUKAJ.NAZWISKO,
   'OSOBA','PIERWSZE',_a,SZUKAJ.IMIE,
   'P','ZA',_a,SZUKAJ.ZA,
   'WYDZIAL','SYMBOL',_a,SZUKAJ.WYDZIAL,
   'ST','ST',_a,SZUKAJ.ST,
   'ST','K',_a,SZUKAJ.K
);
{? ~_ret
|| SZUKAJ.ST_RSZUK:='';
   FUN.info('Nie znaleziono rekordu zgodnego ze wzorcem.'@)
?};
_ret


\wydr_zs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: KF [2009]
:: OPIS: Uruchamia wydruk zaleznosci sluzbowych
::----------------------------------------------------------------------------------------------------------------------
rep_exec('pkd_zaleznosci_sluzbowe')


\stn_stn_gr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jaws [18.02]
:: OPIS: Określa grupę stanowisk dla wskazanego stanowiska.
::   WE: _a [_STN] - wskazanie stanowiska
::   WY: wskazanie grupy stanowisk lub null
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null) | _a=null | ref_tab(_a)<>STN
|| return(null)
?};

_ret:=null;
STN_GRP.cntx_psh();
STN_GRP.index('UNIQUE');
STN_GRP.prefix(exec('ref_firma','ustawienia'));
{? STN_GRP.find_key(_a)
|| _ret:=STN_GRP.STN_GR
?};
STN_GRP.cntx_pop();
_ret


\checkSTZ
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51]
:: OPIS: Sprawdza czy nie wystąpiły problemy w definiowanej strukturze zależności stanowsik
::   WE: [_a] [REFERENCE] - wskazanie na STZ
::       [_b] [NUMBER]    - czy sprawdzać wszystkie poziomy?
::       [_c] [NUMBER]    - czy wyświetlać komunikaty?
::   WY: 0 - wszystko ok lub nr błędu (tylko dla wywołania z przekazanym pierwszym parametrem)
::----------------------------------------------------------------------------------------------------------------------
_stz_ref:={? var_pres('_a')=type_of(null()) || _a || null() ?};
 _chkAll:={? var_pres('_b')=type_of(0)      || _b || 0      ?};
    _msg:={? var_pres('_c')=type_of(0)      || _c || 0      ?};

_result:=0;

_obj:=obj_new('par232','par313','tab','isInPath','sameLevel','getOpis','show','skl_firma','wydzOk','firma');
:: czy jest włączona oddzielna struktura do zależności służbowych
_obj.par232:=PAR_SKID.get(232)='T';
:: czy są włączone pozycje w organizacji
_obj.par313:=PAR_SKID.get(313)='T';

_typ:=exec('szukaj_ud_typ','schemat','PODZORG');
_obj.skl_firma:=exec('ud_skl_firma','schemat',_typ);

_obj.firma:=exec('ref_firma','#firma');

:: funkcja sprawdzająca czy pole wydział jest poprawne
_obj.wydzOk:="
   _result:=1;
   {? .skl_firma<>null()
   || {? UD_SKL.SCIEZKA<>''
      || {? UD_SKL.SCIEZKA*($.skl_firma+8)=0
         || _result:=0
         ?}
      || _result:=0
      ?}
   ?};
   _result
";

:: tabela wynikowa
_obj.tab:=tab_tmp(1,
   'PARENT'   ,'INTEGER'     ,'Ref "rodzica"',
   'REF'      ,'INTEGER'     ,'Ref',
   'ST'       ,'STRING[80]'  ,'Stanowisko',
   'SYMBOL'   ,'STRING[80]'  ,'Symbol jednostki',
   'POZWORG'  ,'STRING[100]' ,'Pozycja w organizacji',
   'ERROR'    ,'INTEGER'     ,'Kod problemu',
   'OPIS'     ,'STRING[100]' ,'Opis problemu'
);

::Wyświetla okno ze znalezionymi problemami w strukturze STZ
_obj.show:="
   _win:=.tab.mk_sel('Wykryte problemy w zdefiniowanej strukturze zależności służbowych'@,,0,'#idstz20180521',,,,,'U');
   .tab.win_fld(_win,,'OPIS',,,-80,,,'Opis problemu'@);
   .tab.win_fld(_win,,'PARENT',,,-17,,,'Nr rekordu nadrzędnego'@);
   .tab.win_fld(_win,,'REF',,,-9,,,'Nr rekordu'@);
   .tab.win_fld(_win,,'ST',,,20,,,'Stanowisko'@);
   {? ~.par232
   || .tab.win_fld(_win,,'SYMBOL',,,40,,,'Symbol jednostki'@)
   ?};
   {? .par313
   || .tab.win_fld(_win,,'POZWORG',,,10,,,'Pozycja w organizacji'@)
   ?};
   .tab.win_fml(_win,.tab,'OPIS',,'ICON_BEFORE',\"exec('checkSTZIcon','stanprac',cur_tab().ERROR)\");
   .tab.win_act(_win,,'Kolejność');
   .tab.win_sel(_win);
   .tab.select();
   ~~
";

:: funkcja opisu błędu
_obj.getOpis:="
   _result:='';
   _error:={? var_pres('_a')=type_of(0) || _a || return(_result) ?};
   {? _error=1
   || _result:='Rekurencja - ponowne wystąpienie stanowiska w ścieżce'@
   |? _error=2
   || _result:='Brak wypełnionego pola \\'Jednostka organizacyjna\\''@
   |? _error=3
   || _result:='Błędna wartość pola \\'Jednostka organizacyjna\\''@
   |? _error=4
   || _result:='Brak wypełnionego pola \\'Pozycja w organizacji\\''@
   |? _error=5
   || _result:='Pozycja w organizacji nie występuje we wskazanej jednostce organizacyjnej'@
   |? _error=6
   || _result:='Ponowne wystąpienie stanowiska na tym samym poziomie'@
   |? _error=7
   || _result:='Ponowne wystąpienie stanowiska w strukturze zależności'@
   ?};
   _result
";

:: funkcja sprawdzająca czy dany STZ nie jest już dodany w ścieżce jego występowania
_obj.isInPath:="
   _stz:=_a; _ref:=_b; _stn:=_c; _ud_skl:=_d; _poz:=_e;
   _result:=0;
:: lecimy w górę drzewka i sprawdzamy czy nas tam nie ma po raz kolejny
   STZ.cntx_psh();
   STZ.prefix();
   {? STZ.seek(_stz,STZ.name()) | (_stz=0 & STZ.seek(_ref))
   ||
::    sprawdzenie czy badany STZ powinien mieć usupełnione pole UD_SKL
      _error:=~.par232 & _ud_skl=null();
      {? _error || _result:=2 ?};
::    sprawdzenie czy w przypadku gdy mamy wypenione pole UD_SKL to czy to wskazanie jest poprawne
      {? ~_error & ~.par232 & _ud_skl
      || UD_SKL.cntx_psh();
         UD_SKL.prefix();
         {? UD_SKL.seek(_ud_skl)
         || _error:=~.wydzOk();
            {? _error || _result:=3 ?}
         ?};
         UD_SKL.cntx_pop()
      ?};
::    sprawdzenie czy badany STZ powinien mieć wypełnione pole POZWORG
      {? ~_error
      || _error:=.par313 & _poz=null();
         {? _error || _result:=4 ?}
      ?};
::    sprawdzenie czy POZWORG istnieje również w PSTO
      {? ~_error & .par313 & ~.par232
      || _sto_ref:=exec('szukaj_sto','stanprac',_ud_skl,_stn);
         _psto_ref:=exec('szukaj_psto','stanprac',_sto_ref,_poz);
         {? _psto_ref=null()
         || _error:=1;
            _result:=5
         ?}
      ?};
::    sprawdzenie czy badany STZ nie jest taki sam jak już wcześniej dodany
      {? ~_error
      || _error:=STZ.STN=_stn & STZ.ref()<>_ref &
                 (.par232 | (~.par232 & STZ.UD_SKL=_ud_skl)) &
                 (~.par313 | (.par313 & STZ.POZWORG=_poz))
      ?};

      {? _error
      || {? ~_result || _result:=1 ?};
         STZ.cntx_psh();
         STZ.prefix();
         {? STZ.seek(_ref)
         || .tab.blank(1);
            {? .par313
            || .tab.POZWORG:={? +STZ.POZWORG().KOD | +POZWORG.OPIS || STZ.POZWORG().KOD+' / '+POZWORG.OPIS || '' ?}
            ?};
            .tab.ST:=STZ.STN().ST;
            .tab.SYMBOL:={? +STZ.UD_SKL().SYMBOL | +UD_SKL.OPIS || STZ.UD_SKL().SYMBOL+' / '+UD_SKL.OPIS || '' ?};
            .tab.PARENT:=STZ.STZ;
            .tab.REF:=#STZ.ref();
            {? ~.tab.find_rec()
            || .tab.ERROR:=_result;
               .tab.OPIS:=.getOpis(_result);
               .tab.add()
            ?}
         ?};
         STZ.cntx_pop()
      || {? _stz || _result:=.isInPath(STZ.STZ,_ref,_stn,_ud_skl,_poz) ?}
      ?}
   ?};
   STZ.cntx_pop();
   _result
";

:: funkcja sprawdzająca czy dany STZ nie jest już dodany na tym samym poziomie
:: funkcja wykorzystywana jest również do sprawdzania czy dwa razy w całej strukturze nie występuje to samo stanowisko
_obj.sameLevel:="
   _parent:=_a; _ref:=_b; _stn:=_c; _ud_skl:=_d; _poz:=_e; _chkAll:=_f;
   _result:=0;
:: lecimy w pętli po rekordach z naszego poziomu i sprawdzamy czy nas tam nie ma po raz kolejny
   STZ.cntx_psh();
   {? _chkAll
   || STZ.index('STN');
      STZ.prefix(.firma,_stn)
   || STZ.index('UNIQUE');
      STZ.prefix(_parent)
   ?};
   {? STZ.first()
   || _dalej:=1;
      {!
      |?
::       sprawdzenie czy badany STZ nie jest taki sam jak już wcześniej dodany
         _error:=STZ.STN=_stn & STZ.ref()<>_ref &
                 (.par232 | (~.par232 & STZ.UD_SKL=_ud_skl)) &
                 (~.par313 | (.par313 & STZ.POZWORG=_poz));

         {? _error
         || .tab.blank(1);
            {? .par313
            || .tab.POZWORG:={? +STZ.POZWORG().KOD | +POZWORG.OPIS || STZ.POZWORG().KOD+' / '+POZWORG.OPIS || '' ?}
            ?};
            .tab.ST:=STZ.STN().ST;
            .tab.SYMBOL:={? +STZ.UD_SKL().SYMBOL | +UD_SKL.OPIS || STZ.UD_SKL().SYMBOL+' / '+UD_SKL.OPIS || '' ?};
            .tab.PARENT:=STZ.STZ;
            .tab.REF:=#STZ.ref();
            {? ~.tab.find_rec()
            || _dalej:=0;
               _result:={? _chkAll || 7 || 6 ?};
               .tab.ERROR:=_result;
               .tab.OPIS:=.getOpis(_result);
               .tab.add()
            ?}
         ?};
         _dalej & STZ.next()
      !}
   ?};
   STZ.cntx_pop();
   _result
";


UD_SKL.cntx_psh();
POZWORG.cntx_psh();
STZ.cntx_psh();
STZ.index('UNIQUE');
STZ.prefix();
{? _stz_ref=null()
|| {? STZ.first()
   || _size:=3*STZ.size();
      {? _msg || PROGRESS.set(_size,'Trwa analiza danych...'@) ?};
      {!
      |? _obj.isInPath(STZ.STZ,STZ.ref(),STZ.STN,STZ.UD_SKL,STZ.POZWORG);
         {? _msg || PROGRESS.next() ?};
         STZ.next()
      !};
      STZ.first();
      {!
      |? _obj.sameLevel(STZ.STZ,STZ.ref(),STZ.STN,STZ.UD_SKL,STZ.POZWORG,0);
         {? _msg || PROGRESS.next() ?};
         STZ.next()
      !};
      STZ.first();
      {? _chkAll
      || {!
         |? _obj.sameLevel(STZ.STZ,STZ.ref(),STZ.STN,STZ.UD_SKL,STZ.POZWORG,1);
            {? _msg || PROGRESS.next() ?};
            STZ.next()
         !}
      ?};
      {? _msg || PROGRESS.close() ?}
   ?}
|? STZ.seek(_stz_ref)
|| _result:=_obj.isInPath(STZ.STZ,STZ.ref(),STZ.STN,STZ.UD_SKL,STZ.POZWORG);
   {? ~_result
   || _result:=_obj.sameLevel(STZ.STZ,STZ.ref(),STZ.STN,STZ.UD_SKL,STZ.POZWORG,0)
   ?}
?};
STZ.cntx_pop();
POZWORG.cntx_pop();
UD_SKL.cntx_pop();
{? _msg
|| {? _obj.tab.size()
   || _obj.show()
   || FUN.info('Nie wykryto błędnych zapisów w strukturze zależności służbowych.'@)
   ?}
?};
_result


\checkSTZIcon
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51]
:: OPIS: Zwraca napis określający ikonę
::   WE: _a [NUMBER] - numer błędu
::   WY: '' lub napis określający ikonę
::----------------------------------------------------------------------------------------------------------------------
_result:='';
_errorNr:={? var_pres('_a')=type_of(0) || _a || return(_result) ?};
{? _errorNr=1
|| _result:='xwin16.png:120'
|? _errorNr>=2 & _errorNr<=5
|| _result:='xwin16.png:4'
|? _errorNr=6
|| _result:='xwin16.png:15'
|? _errorNr=7
|| _result:='xwin16.png:110'
?};
_result


\checkSTRST_P
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51]
:: OPIS: Sprawdza poprawność danych w strukturze STRST_P
::   WE: [_a] [REFERENCE] - wskazanie na rekord STRST_P
::       [_b] [NUMBER]    - czy wyświetlać komunikaty
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_stz_ref:={? var_pres('_a')=type_of(null()) || _a || null() ?};
    _msg:={? var_pres('_b')=type_of(0)      || _b || 0      ?};

_obj:=obj_new('par232','tab','isMulti','show','osoba_bd');
:: czy jest włączona oddzielna struktura do zależności służbowych
_obj.par232:=PAR_SKID.get(232)='T';

:: tabela wynikowa
_obj.tab:=exec('tab_zal','stanprac');

:: formuła na przed wyświetleniem dla pól z danymi osobowymi
_obj.osoba_bd:="
   _result:=1;
   OSOBA.cntx_psh();
   P.cntx_psh();
   P.prefix();
   {? P.seek(cur_tab().P,P.name())
   || P.OSOBA();
      _result:=exec('osoba_x_bd','osoba')
   ?};
   P.cntx_pop();
   OSOBA.cntx_pop();
   _result
";

::Wyświetla okno ze znalezionymi problemami w strukturze STRST_P
_obj.show:="
   _win:=.tab.mk_sel('Podwojone zapisy w strukturze zależności służbowych'@,,0,'#idstrst_p20180',,,,,'U');
   .tab.fld_attr(,2);
   .tab.win_fld(_win,,'T');
   .tab.win_fld(_win,,'NAZWISKO');
   .tab.win_fld(_win,,'IMIE');
   .tab.win_fld(_win,,'J');
   .tab.win_fld(_win,,'WYDZIAL');
   .tab.win_fld(_win,,'STN');
   .tab.win_act(_win,,'Kolejność');
   .tab.fld_fml('NAZWISKO','BEFORE_DISPLAY',.osoba_bd);
   .tab.fld_fml('IMIE','BEFORE_DISPLAY',.osoba_bd);
   .tab.win_sel(_win);
   .tab.select();
   ~~
";

:: funkcja sprawdzająca
_obj.isMulti:="
   _multi:=sql('select distinct P from STRST_P ').size<>sql('select P from STRST_P ').size();
   {? _multi
   || P.cntx_psh();
      OSOBA.cntx_psh();
      UD_SKL.cntx_psh();
      STN.cntx_psh();
      STRST_P.cntx_psh();
      STRST_P.index('P');
      STRST_P.prefix();
      {? STRST_P.first()
      || PROGRESS.set(STRST_P.size(),'Trwa analiza danych...'@);
         {!
         |? STRST_P.cntx_psh();
            STRST_P.prefix(STRST_P.P);
            {? STRST_P.size()>1
            || {? STRST_P.first()
               || {!
                  |? STRST_P.P().OSOBA();
                     .tab.T:=P.T;
                     .tab.NAZWISKO:=OSOBA.NAZWISKO;
                     .tab.IMIE:=OSOBA.PIERWSZE;
                     .tab.J:=STRST_P.UD_SKL().SYMBOL;
                     .tab.WYDZIAL:=P.WYDZIAL().SYMBOL;
                     .tab.STN:=STRST_P.ST().ST;
                     .tab.P:=#STRST_P.P;
                     {? ~.tab.find_rec()
                     || .tab.add()
                     ?};
                     STRST_P.next()
                  !}
               ?}
            ?};
            STRST_P.cntx_pop();
            PROGRESS.next();
            STRST_P.next()
         !};
         PROGRESS.close()
      ?};
      STRST_P.cntx_pop();
      STN.cntx_pop();
      UD_SKL.cntx_pop();
      OSOBA.cntx_pop();
      P.cntx_pop()
   ?};
   _multi
";

_result:=_obj.isMulti();

{? _msg
|| {? _result
   || _obj.show()
   || FUN.info('Nie wykryto podwojonych zapisów w strukturze zależności służbowych.'@)
   ?}
?};
_result


\stn_filter_on
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.02]
:: OPIS: Obsługa akcji menu "Zmień zakres" w oknie WER tabeli STN. Formuła ustawia odpowiedni indeks i prefix.
::   WE: [_a] [STRING] - Kod zakresu danych, który ma być prezentowany:
::                         Z - stanowiska związane z zatrudnieniem [domyślnie];
::                         N - stanowiska niezwiązane z zatrudnieniem;
::                         W - stanowiska wszystkie
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
_kod:={? var_pres('_a')=type_of('') & (_a='N' | _a='W') || _a || 'Z' ?};
_ws:='WER';

:: Najpierw ustalenie wartości kilku zmiennych.
{? _kod='W'
|| _where:='';
   _tail:='wszystkie'@;
   _blank:="*"
|? _kod='Z'
|| _where:='"STN".Z=\'T\'';
   _tail:='związane z zatrudnieniem'@;
   _blank:="'T'"
|? _kod='N'
|| _where:='"STN".Z=\'N\'';
   _tail:='niezwiązane z zatrudnieniem'@;
   _blank:="'N'"
?};

:: Filtr
STN.prefix();
STN.f_set('ST',,_where);

:: Obsługa akcji menu (ikony, wyszarzenie).
_akcje:=spli_str('Z,N,W',',');
{! _lp:=1 .. obj_len(_akcje)
|! _icon:={? _akcje[_lp]=_kod || 'xwin16.png:13' || 'xwin16.png:110' ?};
   {! _empty:=0 .. 1
   |! STN.act_icn(_ws,_empty,'Z'+_akcje[_lp],_icon)
   !}
!};
STN.actions_grayed(_ws,'Z(%1):Z(%1)' [_kod]);

:: Ustawienie odpowiedniego tytułu okna.
:: Ponieważ formuła jest wywoływana jeszcze przed pojawieniem sie okna, to musimy mieć pewność, że tytuł będzie
:: ustawiony dla odpowiedniego okna.
_ows:=STN.win_sel('?');
STN.win_sel(_ws);
STN.hdr_sel();
STN.hdr_sel(' (%1)' [_tail]);
STN.win_sel(_ows);

:: Ustawienie wartości początkowej i dostępności do redakcji pola STN.Z.
STN.fld_fml('Z','BLANK',_blank);
STN.efld_opt('RED','editable=%1' [$(_kod='W')],,'Z');

1


\stn_filter_off
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.02]
:: OPIS: Wyłączenie filtrowania dla tabeli STN (sprzątanie po \stn_filter_on).
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
STN.f_clear();
STN.fld_fml('Z','BLANK',"*");
~~


\_stn_st_pa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.02]
:: OPIS: Wzorzec pól będących relacją do tabeli STN z reprezentantem ST.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('_stn_st_be','stanprac');
''


\_stn_st_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.02]
:: OPIS: Przed redagowaniem pól będących relacją do tabeli STN z reprezentantem ST.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_kod:='Z';

_stn:=fld();
{? _stn<>null()
|| STN.cntx_psh();
   STN.prefix();
   {? STN.seek(_stn) & STN.Z='N'
   || _kod:='W'
   ?};
   STN.cntx_pop()
?};
exec('stn_filter_on','stanprac',_kod)


\stn_ao
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [19.02]
:: OPIS: Obsługa akcji "Okienko po" tabeli STN.
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
exec('stn_filter_off','stanprac')


\many_zal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: achol [21.37]
:: OPIS: Wypełnia przekazany bufor odpowiednimi zapisami dot. przełożonych oraz zastępców. Formuła wywoływana dla
::       systemów z licencją POR oraz włączonym parametrem pozwalającym na obsługę wielu zastępców w \prac_nad/stanprac.
::   WE: _a [TABLE]   - alias tabeli zawierającej listę współpracowników (aktualny bufor)
::       _b [TABLE]   - alias tabeli zawierającej listę wyznaczonych zastępstw
::       _c [INTEGER] - 1 - pomiń nieobecnych współpracowników, 0 - uwzględnij wszystkich
::       _d [STRING]  - źrodło pochodzenia
::       _e [STRING]  - z czego wynika zależność
::                      (Z - zastępstwa, O - obowiązki, B - bezposredni podwladni, P - przypisani)
::       _f - kod typu zależności
::   WY: 1 - operacja zakończona sukcesem, wpp. 0
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
 _BUF:={? var_pres('_a')>100 & var_pres('L',_a)>0 || _a || return(_result) ?};
_PZAS:={? var_pres('_b')>100 & var_pres('L',_b)>0 || _b || return(_result) ?};
_skip:={? var_pres('_c')=type_of(0)               || _c || return(_result) ?};
_opis:={? var_pres('_d')=type_of('')              || _d || return(_result) ?};
_zast:={? var_pres('_e')=type_of('')              || _e || return(_result) ?};
_zkod:={? var_pres('_f')=type_of('')              || _f || '' ?};

{? _zloop:=_PZAS.first()
||
   {? var_pres('_operation')>100 || obj_del(_operation) ?};
   _operation:=obj_new(
:: Rodzaj wykonywanej operacji (dodanie/modyfikacja zapisu w _BUF)
      'type',
:: Wynik wykonywanej operacji (dodania/modyfikacji w _BUF)
      'result',
:: Czy przynajmniej raz doszło do modyfikacji w _BUF (zamiana przełożonego na zastępcę np. w wyniku nieobecności)
      'wasModified',
:: Czy zastępstwo dotyczy tego samego poziomu co główny przebieg pętli
      'sameLvl',
:: Ustawia nazwę operacji do wykonania (.type) na _BUF: 'add' - dołączenie, 'mod' - modyfikacja na podstawie
:: przekazanego parametru [0 - wykonanie z uwzględnieniem wszystkich, 1 - pomijanie nieobecnych pracowników]
      'setBy'
   );
   _operation.type:='';
   _operation.result:=0;
   _operation.wasModified:=0;
   _operation.sameLvl:=(_BUF.L=_PZAS.L);
   _operation.setBy:=".type:={? _a & ~.wasModified & .sameLvl || 'mod' || 'add' ?}";
   {!
   |? _zloop
   |!
      P.cntx_psh();
      P.prefix();
      _pzas:={? P.seek(_PZAS.REF,,1) || P.ref() || null ?};
      P.cntx_pop();
      _BUF.cntx_psh();
      _operation.setBy(_skip);
      _operation.result+=
         exec('%1_zal'[_operation.type],'stanprac',
            _BUF,_pzas,P.WYDZIAL().SYMBOL,_PZAS.L,_opis,,,,_zast,,_zkod
         );
      {? _operation.result & _operation.type='mod' || _operation.wasModified:=1 ?};
      _BUF.cntx_pop();
      _zloop:=_PZAS.next()
   !};
   _result:=(_operation.result>0)
?};

_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:39 93d563b0aba2d49a45ce4012adc5a516b9442407c5c723faecea68b9584eb312fca5d92748704e5a43916eaf09dd8a41a36a2a69fb07129b722fe9c5cf52ce8b1a0249723d1769121da9da1f3cf6b40671e74561ce0e7f73a667c1a0a0499cc4ce2c4d114aca7908ff67a5374c1af403ff9428ee7c431643e4dbd146af25db3a
