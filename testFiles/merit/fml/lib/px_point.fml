:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku: px_point.fml [12.41]
:: Utworzony: 10.06.2013
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Formuly do oblsugi tabeli z punktami czasowymi dla etapow - PX_POINT
::======================================================================================================================


\buffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: tablica buforowa dla tabeli PX_POINT
::----------------------------------------------------------------------------------------------------------------------
exec('PX_POINT','buffer1')


\clone
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Klonuje biezacy rekord PX_POINT i przypina go do podanego PX_GRPa
::   WE: _a - PX_GRP.ref
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

_result:=_a;

PX_POINT.cntx_psh();
PX_POINT.clear();
PX_POINT.PX_GRP:=_px_grp;
_result:=PX_POINT.add();
PX_POINT.cntx_pop();
_result


\add
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Dodaje jeden rekord do tabeli PX_POINT
::   WE: _a - obj_new - tablica nazwana bedaca buforem tabeli exec('buffer','px_point')
::       [_b] - INTEGER - [0]/1 - czy dodawac punkt czasowy do zrodlowego PX_GRPa (w wersji glownej)
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_buffer:={? var_pres('_a')>100
         || _a
         || exec('buffer','px_point')
         ?};
_tied:=0;
{? var_pres('_b')=type_of(0)
|| _tied:=_b
?};

_result:=0;

PX_POINT.cntx_psh(); PX_POINT.clear();
PX_POINT.blank();
_buffer.USERS:=OPERATOR.USER;
_buffer.TM_MOD:=PX_POINT.tm_stamp();
_buffer.set();
_result:=PX_POINT.add();

{? _result>0 & _tied>0
||
:: Dodaje punkt rowniez do zrodlowego PX_GRPa
   PX_GRP.cntx_psh();
   _uid_src:=PX_POINT.PX_GRP().UID_SRC;
   {? _uid_src<>''
   || PX_GRP.index('UID');
      PX_GRP.prefix(_uid_src);
      {? PX_GRP.first()
      || _buffer.PX_GRP:=PX_GRP.ref();
::       !!! REKURENCJA !!!
         exec('add','px_point',_buffer,_tied)
      ?}
   ?};
   PX_GRP.cntx_pop()
?};
PX_POINT.cntx_pop();
_result


\put
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Modyfikuje jeden rekord do tabeli PX_POINT
::   WE: _a - obj_new - tablica nazwana bedaca buforem tabeli exec('buffer','px_point')
::       _b - PX_POINT.ref - rekord ktory zmodyfikowac
::       [_c] - INTEGER - 0/[1] - czy zmieniac typ dla automatycznych punktow na automatyczne-poprawione
::       [_d] - INTEGER - [0]/1 - czy poprawiac punkt czasowy dla zrodlowego PX_GRPa (w wersji glownej)
::       [_e] - obj_new - bufor tabeli przed poprawieniem
::   WY: 0 - porazka
::       1 - sukces
::  OLD: \put/px_point.fml.xxx
::----------------------------------------------------------------------------------------------------------------------
_buffer:={? var_pres('_a')>100
         || _a
         || exec('buffer','px_point')
         ?};
_ref:=_b;

_type_change:=1;
{? var_pres('_c')=type_of(0)
|| _type_change:=_c
?};

_tied:=0;
{? var_pres('_d')=type_of(0)
|| _tied:=_d
?};

_before:=~~;
{? var_pres('_e')>100
|| _before:=_e
?};

_result:=0;

PX_POINT.cntx_psh(); PX_POINT.clear();
{? PX_POINT.seek(_ref)
||
:: Sprawdzam czy w wyniku redakcji punkt się zmienil
   _changed:=1;
   {? type_of(_before)>100
   || _changed:=0;
::    Jesli dostalem bufor rekordu przed akcja redagowania, to sprawdzam
::    czy redakcja cos faktycznie zmienila
      {? exec('compare','px_point',_buffer,_before)=0
      || _changed:=1
      ?}
   ?};

   {? _changed>0
   || _buffer.TM_MOD:=PX_POINT.tm_stamp();

::    Stempluje kolejke czasem modyfikacji
      exec('mod_stamp_queue','px_ver',PX_VAR.VER_QUE)
   ?};

:: Zmiana typu punktu czasowego
   {? _type_change>0 & _buffer.TYP='A' & _changed>0
   ||
::    Jesli punkt czasowy byl automatyczny i nastepuje jego faktyczna modyfikacja
::    to oznaczam go jako 'Automatyczny-poprawiony'
      _buffer.TYP:='P'
   ?};

   _buffer.set();
   _result:=PX_POINT.put();

   {? _result>0 & _tied>0
   ||
::    Poprawiam punkt rowniez dla zrodlowego PX_GRPa
      PX_GRP.cntx_psh();
      _uid_src:=PX_POINT.PX_GRP().UID_SRC;
      {? _uid_src<>''
      || PX_GRP.index('UID');
         PX_GRP.prefix(_uid_src);
         {? PX_GRP.first()
         || _buffer.PX_GRP:=PX_GRP.ref();
            PX_POINT.cntx_psh();
            PX_POINT.index('PX_GRP');
            PX_POINT.prefix(PX_GRP.ref(),PX_POINT.PX_STAGE);
            {? PX_POINT.first()
            ||
::             !!! REKURENCJA !!!
               exec('put','px_point',_buffer,PX_POINT.ref(),_type_change,_tied,_before)
            ?};
            PX_POINT.cntx_pop()
         ?}
      ?};
      PX_GRP.cntx_pop()
   ?};
   ~~
?};
PX_POINT.cntx_pop();
_result


\delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Kasuje podany rekord tabeli PX_POINT (wykonywane w transakcji!!!)
::   WE: _a - PX_POINT.ref()
::       [_b] - INTEGER - [0]/1 - czy usuwac punkt czasowy dla zrodlowego PX_GRPa (w wersji glownej)
::   WY: >0 -wyczyszczone,
::      <=0 -niewyczyszczone
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::  OLD: \delete/px_point.fml.xxx
::----------------------------------------------------------------------------------------------------------------------
:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};
_ref:=_a;

_tied:=0;
{? var_pres('_b')=type_of(0)
|| _tied:=_b
?};
_result:=0;

:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;
{? _mydo || do() ?};
PX_POINT.cntx_psh(); PX_POINT.clear();
PX_GRP.cntx_psh();
{? PX_POINT.seek(_ref)
|| _stage:=PX_POINT.PX_STAGE;
   _uid_src:=PX_POINT.PX_GRP().UID_SRC;
   {? exec('clean','px_point',_ref)>0
   || {? PX_POINT.del(,1)>0
      || _result:=1;

         {? _tied>0
         ||
::          Usuwam punkt rowniez dla zrodlowego PX_GRPa
            PX_GRP.cntx_psh();
            {? _uid_src<>''
            || PX_GRP.index('UID');
               PX_GRP.prefix(_uid_src);
               {? PX_GRP.first()
               || PX_POINT.cntx_psh();
                  PX_POINT.index('PX_GRP');
                  PX_POINT.prefix(PX_GRP.ref(),_stage);
                  {? PX_POINT.first()
                  ||
::                   !!! REKURENCJA !!!
                     exec('delete','px_point',PX_POINT.ref(),_tied)
                  ?};
                  PX_POINT.cntx_pop()
               ?}
            ?};
            PX_GRP.cntx_pop()
         ?}
      || undo();
         _result:=-3
      ?}
   || _result:=-2
   ?}
|| _result:=-1
?};
PX_GRP.cntx_pop();
PX_POINT.cntx_pop();
{? _mydo || end() ?};
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
:: UTW: WH [12.41]
:: OPIS: Czysci powiazania do rekordu tabeli PX_POINT
:: WE: _a - PX_POINT.ref()
:: WY: >0 -wyczyszczone,
:: <=0 -niewyczyszczone
::UWAGA: Parametry bez [] sa wymagane, formula moze nie sprawdzac czy zostaly podane i moze wystapic blad.
::  OLD: \clean/px_point.fml.xxx
::----------------------------------------------------------------------------------------------------------------------
{? do_state()=2 || return(-100) ?};
_result:=1;
_PX_POINT:=_a;

_mydo:=do_state()=0;
{? _mydo || do() ?};
:: --- powiązania do ---

:: --- wszystkie powiazania usuniete? ---
{? _mydo || _result:=end()?};
_result


\delete4grp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Usuwa wszystkie PX_POINTy powiazane z przekazanym PX_GRP
::   WE: _a - PX_GRP.ref()
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

_result:=0;
_can_continue:=1;

PX_POINT.cntx_psh();
:: Szukam PX_POINTow
PX_POINT.index('PX_GRP');
PX_POINT.prefix(_px_grp);
{? PX_POINT.first()
|| {!
   |?
      _can_continue:=exec('delete','px_point',PX_POINT.ref());
      PX_POINT.first() & _can_continue>0
   !}
?};
PX_POINT.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\delete4stage
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Usuwa wszystkie PX_POINTy powiazane z przekazanym PX_STAGE
::   WE: _a - PX_STAGE.ref()
::   WY: 0 - porazka
::       1 - sukces
::  TAG: <PUBLICZNA>
::  OLD: \delete4stage/px_point.fml.xxx
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:=0;
_can_continue:=1;

PX_POINT.cntx_psh();
:: Szukam PX_POINTow
PX_POINT.index('PX_STAGE');
PX_POINT.prefix(_px_stage);
{? PX_POINT.first()
|| {!
   |?
      _can_continue:=exec('delete','px_point',PX_POINT.ref());
      PX_POINT.first() & _can_continue>0
   !}
?};
PX_POINT.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\edit_action
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Akcja 'Punkt czasowy' w oknie wertowania etapow planistycznych
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_buffer:=exec('buffer','px_point');

PX_POINT.cntx_psh();
PX_POINT.index('PX_GRP');
PX_POINT.prefix(PX_GRP.ref(),PX_STAGE.ref());
PX_POINT.win_edit('RED');

_can_continue:=1;

:: Sprawdzam czy przypadkiem PX_STAGE nie jest kooperacyjny, kooperacje nie mogą mieć punktów czasowych
_coop:=exec('coop_zgp','px_stage',PX_STAGE.ref());
{? _coop>0
|| FUN.emsg('Etap: %1 jest kooperacją. Kooperacje nie mogą posiadać punktów czasowych.'@[PX_STAGE.NAZWA]);
   _can_continue:=0
?};

:: Sprawdzam czy kontekst wywołania nie jest z symulacji zamówienia czy zlecenia, bo tworzenie
:: punktów czasowych jest wtedy niepotrzebne
{? var_pres('PxSelect')>100
||
   {? PxSelect.Context*'ZL' | PxSelect.Context*'ZAM'
   || FUN.emsg('Redagowanie punktów czasowych z poziomu symulacji niedozwolone.'@);
      _can_continue:=0
   ?}
?};

:: Sprawdzam czy punkt czasowy zostal utworzony automatycznie i daje ostrzezenie o jego
:: modyfikacji
{? _can_continue>0
|| {? PX_POINT.first() & (PX_POINT.TYP='A' | PX_POINT.TYP='P')
   || _msg0:='';
      _msg:='Uwaga - punkt czasowy utworzony automatycznie.\n\n'
            'Jego modyfikacja spowoduje, że będzie on traktowany jak punt utworzony ręcznie\n'
            'i nie będzie podlegał automatycznym aktualizacjom (np w wyniku zmiany terminu\n'
            'realizacji obiektu w kolejce).'@;
      FUN.emsg(_msg)
   ?}
?};

{? _can_continue>0
||
   {? PX_POINT.first()=0
   ||
::    Nie ma rekordu - tworze nowy
      PX_POINT.blank();
      {? PX_POINT.edit("exec('validate','px_point','D')")
      || _buffer.get();
         _buffer.PX_STAGE:=PX_STAGE.ref();
         _buffer.PX_GRP:=PX_GRP.ref();
         {? exec('add','px_point',_buffer,1)=0
         || FUN.emsg('Dodawanie punktu czasowego zakończone niepowodzeniem.'@)
         ?}
      ?}
   ||
::    Zapamietuje jak wygladal punkt czasowy przed redakcja
      _before:=exec('buffer','px_point');
      _before.get();
::    Jest rekord - modyfikuje go
      {? PX_POINT.edit("exec('validate','px_point','P')")
      || _buffer.get();
         {? exec('put','px_point',_buffer,PX_POINT.ref(),1,1,_before)>0
         || exec('set_sim_mod','px_grp',,'T')
         || FUN.emsg('Modyfikacja punktu czasowego zakończona niepowodzeniem.'@)
         ?}
      ?}
   ?}
?};
PX_POINT.cntx_pop();
~~


\px_point_brec
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Rekord przed w oknie PX_POINT tabeli PX_STAGE
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_result:=~~;
USERS.cntx_psh();
PX_POINT.cntx_psh();
PX_POINT.index('PX_GRP');
PX_POINT.prefix(PX_GRP.ref(),PX_STAGE.ref());
{? PX_POINT.first()
||
   {? PX_POINT.TM_MAX>0
   || PX_VAR.IS_MAX:='T';
      PX_VAR.POI_MAX:=exec('to_string','#tm_stamp',PX_POINT.TM_MAX)
   || PX_VAR.IS_MAX:='N';
      PX_VAR.POI_MAX:=''
   ?};
   {? PX_POINT.TM_MIN>0
   || PX_VAR.IS_MIN:='T';
      PX_VAR.POI_MIN:=exec('to_string','#tm_stamp',PX_POINT.TM_MIN)
   || PX_VAR.IS_MIN:='N';
      PX_VAR.POI_MIN:=''
   ?};
   PX_VAR.POI_TYP:=PX_POINT.TYP;
   PX_VAR.OWNER:=PX_POINT.USERS().DANE;
   PX_VAR.MOD_DATE:=exec('tm_stamp2date','#tm_stamp',PX_POINT.TM_MOD);
   PX_VAR.MOD_TIME:=exec('tm_stamp2time','#tm_stamp',PX_POINT.TM_MOD);
   ~~
|| PX_VAR.IS_MAX:='N';
   PX_VAR.POI_MAX:='';
   PX_VAR.IS_MIN:='N';
   PX_VAR.POI_MIN:='';
   PX_VAR.POI_TYP:='';
   PX_VAR.OWNER:='';
   PX_VAR.MOD_DATE:=date(0,0,0);
   PX_VAR.MOD_TIME:=time(0,0,0);
   ~~
?};
PX_POINT.cntx_pop();
USERS.cntx_pop();
{? exec('is_px_set','px_param')>0
|| {? PX_VAR.PX_SET<>null() & PX_VAR.PX_SET<>PX_STAGE.PX_SET
   || _result:=Color.fnd_kol('PX_POINT#01#01')
   ?}
?};
_result


\select_action
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Akcja 'Punkty czasowe' w kolejce planu
::   WE: [_a] - PX_GRP.ref() - jesli nie podane to znajdowane na podstawie biezacego rekordu
::                             tabelki tymczasowej reprezentujacej kolejke
::       [_b] - PX_SET.ref() - opcjonalnie zestaw ktorym ograniczyc etapy
::       [_c] - INTEGER - 0/[1] - odswiezac okna grp_dispem czy nie
::       [_d] - INTEGER - 0/[1] - czy dostepna edycja
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
|| {? var_pres('PxSelect')>100 & var_pres('Pxgrp',PxSelect)>100
   || _ref:=exec('FindAndGet','#table',PX_GRP,PxSelect.Pxgrp.TAB.PX_GRPI,,,null())
   ?}
?};

_px_set:=null();
{? var_pres('_b')=type_of(PX_SET.ref())
|| _px_set:=_b
?};

_grp_disp:=1;
{? var_pres('_c')=type_of(0)
|| _grp_disp:=_c
?};

_editable:=1;
{? var_pres('_d')=type_of(0)
|| _editable:=_d
?};

:: Jesli praca na zestawach i zestaw nie podany to wylaczam edycje
{? exec('is_px_set','px_param')>0 & _px_set=null()
|| _editable:=0
?};

PX_VAR.POI_EDIT:=_editable;

PX_POINT.cntx_psh();
PX_TEX.cntx_psh();
PX_STAGE.cntx_psh();
PX_GRP.cntx_psh();
PX_GRP.clear();

{? _ref<>null()
||
   {? PX_GRP.seek(_ref)
   ||
      _locked:=null();
      {? exec('lock','px_grp')>0
      || _locked:=PX_GRP.ref();
         {? PX_GRP.PX_TEX<>null()
         ||
::          Jeśli grupa jest zablokowana, to daje ostrzeżenie
            {? exec('is_blocked','px_grp')>0
            || _msg:='Obiekt w kolejce: %1 '
                     'jest zablokowany i nie będzie przeplanowywany.\n\n'
                     'Punkty czasowe nie będą mieć wpływu na plan do momentu odblokowania obiektu.'@[PX_GRP.SYMBOL];
               FUN.info(_msg)
            ?};

::          Jeśli wyswietlam punkty czasowe z zoltej wersji to daje ostrzezenie ze
::          ewentualne zmiany zostana uwzglednione dopiero po przeliczeniu planu
            {? exec('mainversion_vie','px_ver')=0
            ||
               _msg:='Ewentualne zmiany w punktach czasowych będą miały odzwierciedlenie\n'
                     'w planie dopiero po jego ponownym przeliczeniu.'@;
               FUN.info(_msg)
            ?};

::          Podczytanie przepisu
            PX_GRP.PX_TEX();

            _RootRef:=null();
            {? PX_TEX.TKTL<>null()
            || _RootRef:=PX_TEX.TKTL
            || _RootRef:=PX_TEX.ref()
            ?};
            exec('PX_STAGE_prefix','px_stage',_RootRef);

            {? exec('is_px_set','px_param')>0
            || PX_STAGE.win_sel('PX_SET_G')
            || PX_STAGE.win_sel('PX_POINT')
            ?};

            PX_STAGE.select();

            {? _grp_disp>0 & exec('is_px_set','px_param')=0 & var_pres('PxSelect')>100 & var_pres('Pxgrp',PxSelect)>100
            ||
::             Po zamknieciu okna z punktami przeladowuje kolejke zeby uwzglednic zmiany ktore byc
::             moze zaszly z punktami czasowymi
               _ref:=PxSelect.Pxgrp.TAB.ref();
               exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp);

::             przywracam kursor na rekord na ktorym stalem przed wyswietleniem punktow czasowych
               PxSelect.Pxgrp.TAB.seek(_ref)
            ?};
::          Odswiezam zakladki Obiekty i zasoby
            {? _grp_disp>0 & PxSelect.Context<>'' & PxSelect.Context*'|MENU'=0
            ||
::             Jesli kontekst zawiera tekst menu to znak ze okno nie zawiera czesci okien
               {? exec('queue_in_tabs','px_param')=0
               ||
::                Odswiezam Obiekty i Zasoby tylko jesli kolejka nie jest na osobnej zakladce
                  grp_disp(PxSelect.Tab_OBJ.TAB,PxSelect.Tab_OBJ.WER,0);
                  grp_disp(PxSelect.Tab_KONT.TAB,PxSelect.Tab_KONT.WER,0)
               ?}
            ?};
            ~~
         ?};
         {? _locked<>null()
         || exec('unlock','px_grp',_locked)
         ?}
      ?}
   ?}
?};
PX_GRP.cntx_pop();
PX_STAGE.cntx_pop();
PX_TEX.cntx_pop();
PX_POINT.cntx_pop();
~~


\legenda
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Akcja legenda w oknie wertowania PX_POI tabeli PX_STAGE
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','@PX_POINT#01');
~~


\delete_all_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Akcja usun wszystkie punkty czasowe w oknie wertowania etapow: PX_POINT
::       KONTEKST PRACY - PX_GRP, PX_SET
::   WE:
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------

_result:=0;
_can_continue:=1;

PX_SET.cntx_psh();
PX_POINT.cntx_psh();
:: Szukam PX_POINTA
PX_POINT.index('PX_GRP');
PX_POINT.prefix(PX_GRP.ref());
{? PX_POINT.first()
||
   {? PX_VAR.PX_SET<>null()
   || _msg:='Czy na pewno usunąć wszystkie punkty czasowe na etapach powiązanych z bieżącym zestawem planistycznym?\n\n'
            'Obiekt w kolejce: %1\n'
            'Zestaw planistyczny: %2\n'@[PX_GRP.SYMBOL,PX_VAR.PX_SET().SYMBOL];
      _can_continue:=FUN.ask(_msg)
   || _msg:='Czy na pewno usunąć wszystkie punkty czasowe dla obiektu w kolejce: %1?'@[PX_GRP.SYMBOL];
      _can_continue:=FUN.ask(_msg)
   ?};
   {? _can_continue>0
   ||
      KOMM.init(250,,'Usuwanie punktów czasowych'@);
      {!
      |?
         _nxt_ref:=null();
         PX_POINT.cntx_psh();
         {? PX_POINT.next()
         || _nxt_ref:=PX_POINT.ref()
         ?};
         PX_POINT.cntx_pop();


         {? exec('can_delete','px_point',,2)>0
         || _can_continue:=exec('delete','px_point',PX_POINT.ref(),1)
         ?};

         _next:=0;
         {? _nxt_ref<>null()
         || _next:=PX_POINT.seek(_nxt_ref)
         ?};
         _next>0 & _can_continue>0
      !};
      KOMM.select()
   ?}
|| FUN.emsg('Nie znaleziono żadnego punktu czasowego do usunięcia.'@)
?};
PX_POINT.cntx_pop();
PX_SET.cntx_pop();
_result


\delete_action
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Akcja usun punkt czasowy w oknie wertowania etapow: PX_POINT
::       KONTEKST PRACY - PX_GRP, PX_STAGE
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------

_result:=0;
_can_continue:=1;

PX_POINT.cntx_psh();
:: Szukam PX_POINTA
PX_POINT.index('PX_GRP');
PX_POINT.prefix(PX_GRP.ref(),PX_STAGE.ref());
{? PX_POINT.first()
||
   {? exec('can_delete','px_point')>0
   || _can_continue:=FUN.ask('Czy na pewno usunąć punkt czasowy dla etapu: %1?'@[PX_STAGE.NAZWA]);
      {? _can_continue>0
      || _result:=exec('delete','px_point',PX_POINT.ref,1);
         {? _result>0
         || exec('set_sim_mod','px_grp',,'T')
         ?}
      ?}
   ?}
|| FUN.emsg('Nie znaleziono punktu czasowego do usunięcia.'@)
?};
PX_POINT.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\can_delete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy mozna usunac dany punkt czasowy
::   WE: [_a] - PX_POINT.ref()
::       [_b] - INTEGER - tryb wyswietlania komunikatow:  0  - w ogole nie wyświetlac
::                                                       [1] - wyswietlac w FUN
::                                                        2  - dodawac do KOMM
::   WY: 0 - nie mozna usuwac
::       1 - mozna usuwac
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_display:=1;
{? var_pres('_b')=type_of(0)
|| _display:=_b
?};

_result:=0;
_can_continue:=1;

PX_SET.cntx_psh();
PX_STAGE.cntx_psh();
PX_POINT.cntx_psh();
{? _ref<>null()
|| PX_POINT.clear();
   {? PX_POINT.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| _result:=1;
   _what:='dla etapu: \''+$PX_POINT.PX_STAGE().NR+'. '+PX_STAGE.NAZWA+'\'';
:: Sprawdzanie typu punktu czasowego
   {? PX_POINT.TYP='A'
   || _result:=0;
      _msg:='Punkt czasowy %1 utworzony automatycznie. Usuwanie niedozwolone.'@[_what];
      {? _display=1
      || FUN.emsg(_msg)
      |? _display=2
      || KOMM.add(_msg,2)
      ?}
   |? PX_POINT.TYP='P'
   || _result:=0;
      _msg:='Punkt czasowy %1 utworzony automatycznie i zmodyfikowany ręcznie. Usuwanie niedozwolone.'@[_what];
      {? _display=1
      || FUN.emsg(_msg)
      |? _display=2
      || KOMM.add(_msg,2)
      ?}
   ?};

:: Sprawdzanie czy etap nalezy do biezacego zestawu
   {? _result>0 & exec('is_px_set','px_param')>0
   || {? PX_VAR.PX_SET<>null()
      || {? PX_POINT.PX_STAGE().PX_SET<>PX_VAR.PX_SET
         || _result:=0
         ?}
      || _result:=0
      ?};
      {? _result=0
      ||
         _msg:='Aby usunąć punkt czasowy %1 należy pracować w zestawie: %2'@[_what,PX_POINT.PX_STAGE().PX_SET().SYMBOL];
         {? _display=1
         || FUN.emsg(_msg)
         |? _display=2
         || KOMM.add(_msg,2)
         ?}
      ?}
   ?}
?};
PX_POINT.cntx_pop();
PX_STAGE.cntx_pop();
PX_SET.cntx_pop();
_result


\aft_rfr_stage
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Po odswiez okna grupowego PX_POI w oknie grupowym PX_POINT
::----------------------------------------------------------------------------------------------------------------------
PX_POINT.cntx_psh();
PX_POINT.index('PX_GRP');
PX_POINT.prefix(PX_GRP.ref(),PX_STAGE.ref());
PX_VAR.MAX_DATE:=date(0,0,0);
PX_VAR.MAX_TIME:=time(0,0,0);
PX_VAR.MIN_DATE:=date(0,0,0);
PX_VAR.MIN_TIME:=time(0,0,0);
{? PX_POINT.first()
||
   {? PX_POINT.TM_MAX>0
   || PX_VAR.MAX_DATE:=PX_POINT.MAX_DATE;
      PX_VAR.MAX_TIME:=PX_POINT.MAX_TIME
   ?};
   {? PX_POINT.TM_MIN>0
   || PX_VAR.MIN_DATE:=PX_POINT.MIN_DATE;
      PX_VAR.MIN_TIME:=PX_POINT.MIN_TIME
   ?};
   ~~
?};
{? exec('is_px_set','px_param')>0
||
   _edit_poj:=0;
   _edit_gr:=0;

   {? PX_VAR.POI_EDIT>0
   ||
      {? PX_VAR.PX_SET<>null()
      || _edit_gr:=1;
         {? PX_STAGE.PX_SET=PX_VAR.PX_SET
         ||
::          Jesli zestaw etapu i biezacy zgodny to wlaczam edycje
            _edit_poj:=1
         ?}
      ?}
   ?};
   {? exec('is_px_set','px_param')>0
   ||
      PX_STAGE.actions_grayed(cur_win(1,1));
      {? _edit_poj=0
      || PX_STAGE.actions_grayed(cur_win(1,1),'EPU')
      ?};
      {? _edit_gr=0
      || PX_STAGE.actions_grayed(cur_win(1,1),'WR')
      ?}
   || _state:='';
      {? _edit_poj=0
      || PX_STAGE.actions_grayed(cur_win(1,1),'EU')
      ?}
   ?}
?};
PX_POINT.cntx_pop();
win_disp();
~~


\validate
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Walidacja rekordu PX_POINT
::   WE: _a - STRING - 'D' - obsluga podczas dolacz, 'P' - obsluga podczas popraw
::   WY: STRING - symbol pola do ktorego wrocic jesli walidacja zakonczy sie niepowodzeniem
::----------------------------------------------------------------------------------------------------------------------
_mode:=_a;

_result:='';
_can_continue:=1;

_tm_min:=exec('create','#tm_stamp',PX_POINT.MIN_DATE,PX_POINT.MIN_TIME);
_tm_max:=exec('create','#tm_stamp',PX_POINT.MAX_DATE,PX_POINT.MAX_TIME);
:: 1. Sprawdzam wypelnienie koniecznych pol
{? PX_POINT.MAX_DATE=date(0,0,0) & PX_POINT.MIN_DATE=date(0,0,0)
|| FUN.emsg('Punkt czasowy musi mieć podaną przynajmniej jedną datę.'@);
   _result:='MIN_DATE';
   _can_continue:=0
?};

{? _can_continue>0
||
:: 2. Sprawdzam czy poczatek nie jest wiekszy niz koniec
   {? _tm_max>0 & _tm_min>_tm_max
   || FUN.emsg('Minimum nie może być większe niż maksimum.'@);
      _result:='MIN_DATE';
      _can_continue:=0
   ?}
?};

:: 3. Sprawdzam poprawnosc godzin
{? _can_continue>0
||
   {? PX_POINT.MIN_TIME~1>=24
   || FUN.emsg('Podana godzina jest niepoprawna (dozwolone wartości: 00:00-23:59)'@);
      _result:='MIN_TIME';
      _can_continue:=0
   ?};
   {? PX_POINT.MAX_TIME~1>=24
   || FUN.emsg('Podana godzina jest niepoprawna (dozwolone wartości: 00:00-23:59)'@);
      _result:='MAX_TIME';
      _can_continue:=0
   ?}
?};

_result


\px_poi_trig
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Trigger dla tabeli PX_POINT
::   WY: 1
::----------------------------------------------------------------------------------------------------------------------
PX_POINT.TM_MAX:=exec('create','#tm_stamp',PX_POINT.MAX_DATE,PX_POINT.MAX_TIME);
PX_POINT.TM_MIN:=exec('create','#tm_stamp',PX_POINT.MIN_DATE,PX_POINT.MIN_TIME);
PX_POINT.MIN_DATY:=exec('get','daty',PX_POINT.MIN_DATE);
PX_POINT.MAX_DATY:=exec('get','daty',PX_POINT.MAX_DATE);
1


\edit_drop
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Akcja po upuszczeniu etapu na zakladce 'Obiekty', 'Zasoby'
::       Kontekst pracy - PX_VIEW
::   WE: _a - DATY.ref()
::       _b - PX_GRP.ref()
::       _c - PX_STAGE.ref()
::       [_d] - STRING - przeciagany tekst
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_data:=_a;
_px_grp:=_b;
_px_stage:=_c;
_dragged:=_d;

_result:=0;
_buffer:=exec('buffer','px_point');
_can_continue:=1;

PX_STAGE.cntx_psh();
PX_SET.cntx_psh();

:: Sprawdzam czy przypadkiem PX_STAGE nie jest kooperacyjny, kooperacje nie mogą mieć punktów czasowych
_coop:=exec('coop_zgp','px_stage',_px_stage);
{? _coop>0
|| FUN.emsg('Etap: %1 jest kooperacją. Kooperacje nie mogą posiadać punktów czasowych.'@[PX_STAGE.NAZWA]);
   _can_continue:=0
?};

{? _can_continue>0
||
   PX_POINT.cntx_psh();
   PX_POINT.index('PX_GRP');
   PX_POINT.prefix(_px_grp,_px_stage);

   _sym_grp:=exec('FindAndGet','#table',PX_GRP,#_px_grp,ref_name(_px_grp),"SYMBOL",'');
   _blk:=exec('FindAndGet','#table',PX_GRP,#_px_grp,ref_name(_px_grp),"BLK",'N');
   _sym_stg:=exec('record','#to_string',_px_stage);
   _grp_inh:=exec('get_inherited','px_grp',_px_grp,PX_VAR.VER_QUE);

   DATY.cntx_psh(); DATY.clear();
   {? DATY.seek(_data)
   ||
::    Jeśli grupa jest zablokowana, to daje ostrzeżenie
      {? _blk='T'
      || _msg:='Obiekt w kolejce: %1 '
               'jest zablokowany i nie będzie przeplanowywany.\n\n'
               'Punkty czasowe nie będą mieć wpływu na plan do momentu odblokowania obiektu.'@[PX_GRP.SYMBOL];
         FUN.info(_msg)
      ?};

      _daty_next:=null();
      _daty_prev:=null();
      DATY.cntx_psh();
      {? exec('find_next','daty',PX_VIEW.LEVEL,1)>0
      || _daty_next:=DATY.ref()
      ?};
      {? exec('find_next','daty',PX_VIEW.LEVEL,-1)>0
      || _daty_prev:=DATY.ref()
      ?};
      DATY.cntx_pop();

      _int_next:=exec('create_interval','daty',DATY.ref(),_daty_next,PX_VIEW.OFFSET);
      _int_prev:=exec('create_interval','daty',_daty_prev,DATY.ref(),PX_VIEW.OFFSET);

      {? PX_POINT.first()=0
      ||
         _buffer.bl_table();
::       Nie ma rekordu - tworze nowy
         _msg:='Grupa: %1\n'
               'Etap: %2\n'
               'Nie posiada punktu czasowego.\n\n'
               'Czy używając czasu: %3 utworzyć nowy punkt?'@[_sym_grp,_sym_stg,19+tm_form(_int_next.START)];
         _choice:=FUN.choice(_msg,,'Minimalny czas &początku'@,'Maksymalny czas &końca'@);

         {? _choice=1
         ||
::          Jeśli edytuje punkty czasowe w zoltej wersji to daje ostrzezenie ze
::          zmiany zostana uwzglednione dopiero po przeliczeniu planu
            {? exec('mainversion_vie','px_ver')=0
            ||
               _msg:='Dokonana zmiana punktu czasowego będzie miała odzwierciedlenie\n'
                     'w planie dopiero po jego ponownym przeliczeniu.'@;
               FUN.info(_msg)
            ?};

::          Minimalny czas poczatku
            _buffer.PX_GRP:=_px_grp;
            _buffer.PX_STAGE:=_px_stage;
            {? _int_next.START>0
            || _buffer.MIN_DATE:=exec('tm_stamp2date','#tm_stamp',_int_next.START);
               _buffer.MIN_TIME:=exec('tm_stamp2time','#tm_stamp',_int_next.START)
            ?};
            _buffer.TYP:='R';
            _result:=exec('add','px_point',_buffer,1);

            {? _result>0
            ||
::             Jesli udalo sie utworzyć punkt w oglądanej wersji, to tworze go również
::             dla grupy w kolejce tymczasowej
               {? _grp_inh<>null()
               || _buffer.PX_GRP:=_grp_inh;
                  exec('add','px_point',_buffer,0)
               ?}
            ?}
         |? _choice=2
         ||
::          Jeśli edytuje punkty czasowe w zoltej wersji to daje ostrzezenie ze
::          zmiany zostana uwzglednione dopiero po przeliczeniu planu
            {? exec('mainversion_vie','px_ver')=0
            ||
               _msg:='Dokonana zmiana punktu czasowego będzie miała odzwierciedlenie\n'
                     'w planie dopiero po jego ponownym przeliczeniu.'@;
               FUN.info(_msg)
            ?};

::          Maksymalny czas zakonczenia
            _buffer.PX_GRP:=_px_grp;
            _buffer.PX_STAGE:=_px_stage;
            {? _int_next.START>0
            || _buffer.MAX_DATE:=exec('tm_stamp2date','#tm_stamp',_int_next.START);
               _buffer.MAX_TIME:=exec('tm_stamp2time','#tm_stamp',_int_next.START)
            ?};
            _buffer.TYP:='R';
            _result:=exec('add','px_point',_buffer,1);
            {? _result>0
            ||
::             Jesli udalo sie utworzyć punkt w oglądanej wersji, to tworze go również
::             dla grupy w kolejce tymczasowej
               {? _grp_inh<>null()
               || _buffer.PX_GRP:=_grp_inh;
                  exec('add','px_point',_buffer,0)
               ?}
            ?}
         ?};
         ~~
      ||
         _buffer.get();
         _txt_min:=exec('txt_point_min','px_param');
         _txt_max:=exec('txt_point_max','px_param');
::       Jest juz punkt czasowy - modyfikuje go
         {? _dragged*_txt_min>0 | _dragged*_txt_max>0
         ||
::          Sprawdzam czy etap ma zestaw i czy ten zestaw jest biezacym
            {? (PX_POINT.TYP='A' | PX_POINT.TYP='P') & PX_POINT.PX_STAGE().PX_SET<>null()
            || {? PX_SET.ref()<>PX_VAR.PX_SET
               || _can_continue:=0;
                  _msg:='Aby przesunąć ten punkt czasowy należy pracować na zestawie planistycznym: %1.'@[PX_SET.SYMBOL];
                  FUN.info(_msg)
               ?}
            ?};

            {? _can_continue>0
            ||
               _msg:='Grupa: %1\n'
                     'Etap: %2\n'@[_sym_grp,_sym_stg];
               {? PX_POINT.TYP='A' | PX_POINT.TYP='P'
               || _msg+='Posiada automatyczny punkt czasowy:\n\n'@
               || _msg+='Posiada punkt czasowy:\n\n'@
               ?};

               {? PX_POINT.TM_MIN>0
               || _msg+='   '+'Minimalny czas początku: %1\n'@[19+tm_form(PX_POINT.TM_MIN)]
               ?};
               {? PX_POINT.TM_MAX>0
               || _msg+='   '+'Maksymalny czas końca: %1\n'@[19+tm_form(PX_POINT.TM_MAX)]
               ?};

::             Sprawdzam czy mozna przesunac:
::             1. Czy czasy w punkcie sie ze soba nie zazebia
               {? _dragged*_txt_min>0
               || {? _buffer.TM_MAX>0 & _buffer.TM_MAX<_int_next.START
                  || _msg+='Nie można przesunąć \'Minimalnego czasu początku\' później niż \'Maksymalny czas końca\'.'@;
                     _can_continue:=0
                  ?}
               |? _dragged*_txt_max>0
               || {? _buffer.TM_MIN>0 & _int_next.START<_buffer.TM_MIN
                  || _msg+='Nie można przesunąć \'Maksymalnego czasu końca\' wcześniej niż \'Minimalny czas początku\'.'@;
                     _can_continue:=0
                  ?}
               ?};

               {? _can_continue>0
               ||
                  {? _dragged*_txt_min>0
                  || _msg+='Czy używając czasu: %1 przesunąć \'Minimalny czas początku\'?\n'@[19+tm_form(_int_next.START)]
                  |? _dragged*_txt_max>0
                  || _msg+='Czy używając czasu: %1 przesunąć \'Maksymalny czas końca\'?\n'@[19+tm_form(_int_next.START)]
                  ?}
               ?};
               _choice:=0;
               {? _can_continue>0
               || _choice:=FUN.ask(_msg)
               || FUN.emsg(_msg)
               ?};

               {? _can_continue>0 & _choice>0 & _dragged*_txt_min>0
               ||
::                Jeśli edytuje punkty czasowe w zoltej wersji to daje ostrzezenie ze
::                zmiany zostana uwzglednione dopiero po przeliczeniu planu
                  {? exec('mainversion_vie','px_ver')=0
                  ||
                     _msg:='Dokonana zmiana punktu czasowego będzie miała odzwierciedlenie\n'
                           'w planie dopiero po jego ponownym przeliczeniu.'@;
                     FUN.info(_msg)
                  ?};

::                Minimalny czas poczatku
                  _buffer.PX_GRP:=_px_grp;
                  _buffer.PX_STAGE:=_px_stage;
                  {? _int_next.START>0
                  || _buffer.MIN_DATE:=exec('tm_stamp2date','#tm_stamp',_int_next.START);
                     _buffer.MIN_TIME:=exec('tm_stamp2time','#tm_stamp',_int_next.START)
                  ?};
                  _result:=exec('put','px_point',_buffer,PX_POINT.ref(),,1);

                  {? _result>0
                  ||
::                   Jesli udalo sie zmodyfikować punkt w oglądanej wersji, to modyfikuje go również
::                   dla grupy w kolejce tymczasowej
                     {? _grp_inh<>null()
                     || PX_POINT.cntx_psh();
                        PX_POINT.index('PX_GRP');
                        PX_POINT.prefix(_grp_inh,_px_stage);
                        {? PX_POINT.first()
                        || _buffer.PX_GRP:=_grp_inh;
                           exec('put','px_point',_buffer,PX_POINT.ref(),,0)
                        ?};
                        PX_POINT.cntx_pop()
                     ?}
                  ?}
               |? _can_continue>0 & _choice>0 & _dragged*_txt_max>0
               ||
::                Jeśli edytuje punkty czasowe w zoltej wersji to daje ostrzezenie ze
::                zmiany zostana uwzglednione dopiero po przeliczeniu planu
                  {? exec('mainversion_vie','px_ver')=0
                  ||
                     _msg:='Dokonana zmiana punktu czasowego będzie miała odzwierciedlenie\n'
                           'w planie dopiero po jego ponownym przeliczeniu.'@;
                     FUN.info(_msg)
                  ?};

::                Maksymalny czas zakonczenia
                  _buffer.PX_GRP:=_px_grp;
                  _buffer.PX_STAGE:=_px_stage;
                  {? _int_next.START>0
                  || _buffer.MAX_DATE:=exec('tm_stamp2date','#tm_stamp',_int_next.START);
                     _buffer.MAX_TIME:=exec('tm_stamp2time','#tm_stamp',_int_next.START)
                  ?};
                  _result:=exec('put','px_point',_buffer,PX_POINT.ref(),,1);
                  {? _result>0
                  ||
::                   Jesli udalo sie zmodyfikować punkt w oglądanej wersji, to modyfikuje go również
::                   dla grupy w kolejce tymczasowej
                     {? _grp_inh<>null()
                     || PX_POINT.cntx_psh();
                        PX_POINT.index('PX_GRP');
                        PX_POINT.prefix(_grp_inh,_px_stage);
                        {? PX_POINT.first()
                        || _buffer.PX_GRP:=_grp_inh;
                           exec('put','px_point',_buffer,PX_POINT.ref(),,0)
                        ?};
                        PX_POINT.cntx_pop()
                     ?}
                  ?}
               ?}
            ?}
         || FUN.emsg('Aby zmodyfikować punkt czasowy należy przeciągnąć znacznik: %1 lub %2'@[_txt_min,_txt_max])
         ?};
         ~~
      ?}
   ?};
   DATY.cntx_pop();
   PX_POINT.cntx_pop();
   ~~
?};

{? _result>0 & var_pres('PxSelect')>100
||
:: Jesli kontekst zawiera WIN to znak ze wyswietlane jest pojedyncze okno planu i nie mozna
:: robic grp_disp
   {? PxSelect.Context*'WIN'=0
   ||
::    Po utworzeniu lub modyfikacji istniejacego punktu przeladowuje kolejke zeby uwzglednic w niej zmiany
      _ref:=PxSelect.Pxgrp.TAB.ref();
      exec('Pxgrp_refresh','px_grp',PxSelect.Pxgrp);

::    przywracam kursor na rekord na ktorym stalem przed wyswietleniem punktow czasowych
      PxSelect.Pxgrp.TAB.seek(_ref);
      grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT)
   ?};
   ~~
?};
PX_STAGE.cntx_pop();
PX_SET.cntx_pop();

_result


\verify
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Weryfikuje poprawnosc punktow czasowych - czyli czy sie nie zazebiaja, nie nakladaja
::       nie sa odwrotnie niz kolejnosc etapow
::   WE: _a - PX_GRP.ref() - obiekt grupujacy ktorego przepis i punkty czasowe bede sprawdzal
::   WY: 0 - weryfikacja zakonczona niepowodzeniem
::       1 - wszystko ok
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;

_result:=1;
_can_continue:=1;

PX_KONT.cntx_psh();
PX_GRP.cntx_psh(); PX_GRP.clear();
PX_TEX.cntx_psh(); PX_TEX.clear();
PX_STAGE.cntx_psh();
PX_OPER.cntx_psh();
PX_OPER.index('UNIQALL');
PX_CONN.cntx_psh();
PX_CONN.index('PX_GRP');
PX_OBJ.cntx_psh();
PX_POINT.cntx_psh();
PX_POINT.index('PX_GRP');
_mainver:=PX_VAR.MAINVER;

{? PX_GRP.seek(_px_grp)
||
:: Najpierw czyszcze poprzednie komunikaty o ile jakies byly
   _typ:=exec('type_error','px_komm');
   _src_kind:=exec('src_poi_verify','px_komm');
   exec('del_kommy','px_komm','PX_GRP',PX_GRP.ref(),_typ,_src_kind);

:: Podczytuje przepis
   PX_GRP.PX_TEX();

   _RootRef:=null();
   {? PX_TEX.TKTL<>null()
   || _RootRef:=PX_TEX.TKTL
   || _RootRef:=PX_TEX.ref()
   ?};
   exec('PX_STAGE_prefix','px_stage',_RootRef);

   _ref_table:=exec('ref_table','#table');
:: Iteruje po etapach i szukam takich z punktami czasowymi
   {? PX_STAGE.first()
   || {!
      |?
         PX_POINT.prefix(PX_GRP.ref(),PX_STAGE.ref());
         {? PX_POINT.first()
         || {!
            |?
::             1. Sprawdzam czy punkt czasowy nie wykracza poza termin realizacji ktoregos z obiektow
::             wchodzacych w sklad grupy
               {? PX_GRP.PL_FORCE<>'T'
               ||
                  PX_CONN.prefix(PX_GRP.ref());
                  {? PX_CONN.first()
                  || {!
                     |?
::                      Podczytanie PX_OBJ
                        PX_CONN.PX_OBJ();
                        {? PX_POINT.TM_MAX>PX_OBJ.TM_REA
                        ||
                           _result:=0;
::                         Wykryto przekroczenie terminu - dodaje komunikat
                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=PX_GRP.PX_VER;
                           _komm_args.PX_GRP:=PX_GRP.ref();
                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.SRC_KIND:=_src_kind;

                           _stg_sym:=$PX_STAGE.NR+'. '+PX_STAGE.NAZWA;
                           _termin:=19+tm_form(PX_OBJ.TM_REA);
                           _msg:='Maksymalny czas końca etapu: \'%1\' przekracza termin realizacji obiektu: %2 (%3)'[_stg_sym,PX_OBJ.SYMBOL,_termin];
                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args)
                        ?};
                        {? PX_POINT.TM_MIN>PX_OBJ.TM_REA
                        ||
                           _result:=0;
::                         Wykryto przekroczenie terminu - dodaje komunikat
                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=PX_GRP.PX_VER;
                           _komm_args.PX_GRP:=PX_GRP.ref();
                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.SRC_KIND:=_src_kind;

                           _stg_sym:=$PX_STAGE.NR+'. '+PX_STAGE.NAZWA;
                           _termin:=19+tm_form(PX_OBJ.TM_REA);
                           _msg:='Minimalny czas rozpoczęcia etapu: \'%1\' przekracza termin realizacji obiektu: %2 (%3)'[_stg_sym,PX_OBJ.SYMBOL,_termin];
                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args)
                        ?};
                        PX_CONN.next()
                     !}
                  ?}
               ?};

::             2. Sprawdzam czy punkt czasowy sie nie zazebia z innymi
               {? var_pres('_int_poi')>100
               || obj_del(_int_poi)
               ?};
               _int_poi:=exec('interval','#interval');
               _int_poi.START:=PX_POINT.TM_MIN;
               _int_poi.END:=PX_POINT.TM_MAX;

               _stg_sym:=$PX_STAGE.NR+'. '+PX_STAGE.NAZWA;
               {? PX_STAGE.PX_SET<>null()
               || _stg_sym+=' (zestaw: '+PX_STAGE.PX_SET().SYMBOL+')'
               ?};

               _ver_nexts:=exec('point_verify','px_point',PX_GRP.PX_VER
                                                         ,PX_GRP.ref()
                                                         ,1
                                                         ,_RootRef
                                                         ,_int_poi
                                                         ,_stg_sym
                                                         ,_ref_table);
               _ver_prevs:=exec('point_verify','px_point',PX_GRP.PX_VER
                                                         ,PX_GRP.ref()
                                                         ,-1
                                                         ,_RootRef
                                                         ,_int_poi
                                                         ,_stg_sym
                                                         ,_ref_table);
               {? _ver_nexts=0 | _ver_prevs=0
               || _result:=0
               ?};

::             Badam czy punkty czasowe nie przekraczają teraz, bo na bank nie uda sie ich zaplanowac
::             bo nie bedzie pojemnikow
               _chk_now:=0;
               {? var_pres('_kor')>100
               || obj_del(_kor)
               ?};
               _kor:=obj_new(1);
               PX_OPER.prefix(PX_STAGE.ref());
               {? PX_OPER.first()
               ||
::                Obliczam czy jakas ilosc etapu bedzie planowana i czy jest sens sprawdzac
::                bo jezeli etap jest juz wykonywany albo wykonany w calosci to punkty czasowe
::                znajdujace sie w przeszlosci w niczym nie przeszkodza i sa normalnym zjawiskiem
                  {!
                  |?
                     {? var_pres('_cap_use')>100
                     || obj_del(_cap_use)
                     ?};
                     _cap_use:=exec('cap_use','px_oper');
                     {? PX_OPER.CONST<>'T'
                     ||
::                      Zuzycia mnoze przez proporcje wynikajaca z ilosci na PX_GRP i XJM
                        _prop:=PX_GRP.ILOSC/PX_TEX.XJM;
                        _prop:=exec('max','#math',_prop,0);
                        {? _prop>0
                        || exec('array_multiply','#array',_cap_use,_prop)
                        ?}
                     ?};

::                   Obliczam ilosci wykonywane, wykonane, opoznione, zablokowane, porzucone
                     {? var_pres('_kor')>100
                     || obj_del(_kor)
                     ?};

                     _uid_grp:='';
                     {? PX_GRP.PX_VER=_mainver
                     || _uid_grp:=PX_GRP.UID
                     || _uid_grp:=PX_GRP.UID_SRC
                     ?};

::                   Ilosci wykonywane
                     _kor:=exec('count_status','px_poz'  ,_uid_grp
                                                         ,PX_STAGE.ref()
                                                         ,PX_OPER.PX_KONT().UID
                                                         ,exec('status_wyk1','px_poz'));
                     exec('arrays_sub_mod','#array',_cap_use,_kor);

::                   Ilosci wykonane
                     {? var_pres('_kor')>100
                     || obj_del(_kor)
                     ?};
                     _kor:=exec('count_status','px_poz'  ,_uid_grp
                                                         ,PX_STAGE.ref()
                                                         ,PX_OPER.PX_KONT().UID
                                                         ,exec('status_wyk2','px_poz'));
                     exec('arrays_sub_mod','#array',_cap_use,_kor);

::                   Ilosci opoznione
                     {? var_pres('_kor')>100
                     || obj_del(_kor)
                     ?};
                     _kor:=exec('count_status','px_poz'  ,_uid_grp
                                                         ,PX_STAGE.ref()
                                                         ,PX_OPER.PX_KONT().UID
                                                         ,exec('status_delay','px_poz'));
                     exec('arrays_sub_mod','#array',_cap_use,_kor);

::                   Ilosci zablokowane
                     {? var_pres('_kor')>100
                     || obj_del(_kor)
                     ?};
                     _kor:=exec('count_blk','px_poz'  ,_uid_grp
                                                      ,PX_STAGE.ref()
                                                      ,PX_OPER.PX_KONT().UID);
                     exec('arrays_sub_mod','#array',_cap_use,_kor);

::                   Ilosci porzucone
                     {? var_pres('_kor')>100
                     || obj_del(_kor)
                     ?};
                     _kor:=exec('count_status','px_poz'  ,_uid_grp
                                                         ,PX_STAGE.ref()
                                                         ,PX_OPER.PX_KONT().UID
                                                         ,exec('status_skipped','px_poz'));
                     exec('arrays_sub_mod','#array',_cap_use,_kor);

::                   Ilosci aktualnie trwajace
                     {? var_pres('_kor')>100
                     || obj_del(_kor)
                     ?};
                     _kor:=exec('count_now','px_poz'  ,_uid_grp

                                                      ,PX_STAGE.ref()
                                                      ,PX_OPER.PX_KONT().UID);
                     exec('arrays_sub_mod','#array',_cap_use,_kor);

::                   Jesli po korektach cos zostalo to jest sens sprawdzac czy punkt czasowy nie jest
::                   w przeszlosci
                     {? exec('array_sum','#array',_cap_use)>0
                     || _chk_now:=1
                     ?};
                     PX_OPER.next() & _chk_now=0
                  !}
               ?};
               {? _chk_now>0
               ||

                  {? PX_POINT.TM_MIN>0 & exec('chk_past','px_point',,1)=0
                  ||
::                   Wykryto punkt w przeszlosci - dodaje komunikat
                     _result:=0;
                     {? var_pres('_komm_args')>100
                     || obj_del(_komm_args)
                     ?};
                     _komm_args:=exec('add_komm_a','px_komm');
                     _komm_args.PX_VER:=PX_GRP.PX_VER;
                     _komm_args.PX_GRP:=PX_GRP.ref();
                     _komm_args.TYP:=exec('type_error','px_komm');
                     _komm_args.SRC_KIND:=_src_kind;

                     _stg_sym:=$PX_STAGE.NR+'. '+PX_STAGE.NAZWA;
                     _termin:=19+tm_form(PX_OBJ.TM_REA);
                     _msg:='Minimalny czas rozpoczęcia etapu: \'%1\' znajduje się w przeszłości, zaplanowanie etapu się nie powiedzie.'[_stg_sym];
                     _komm_args.MESSAGE:=_msg;
                     exec('add_komm','px_komm',_komm_args)
                  ?};
                  {? PX_POINT.TM_MAX>0 & exec('chk_past','px_point',,2)=0
                  ||
::                   Wykryto punkt w przeszlosci - dodaje komunikat
                     _result:=0;
                     {? var_pres('_komm_args')>100
                     || obj_del(_komm_args)
                     ?};
                     _komm_args:=exec('add_komm_a','px_komm');
                     _komm_args.PX_VER:=PX_GRP.PX_VER;
                     _komm_args.PX_GRP:=PX_GRP.ref();
                     _komm_args.TYP:=exec('type_error','px_komm');
                     _komm_args.SRC_KIND:=_src_kind;

                     _stg_sym:=$PX_STAGE.NR+'. '+PX_STAGE.NAZWA;
                     _termin:=19+tm_form(PX_OBJ.TM_REA);
                     _msg:='Maksymalny czas zakończenia etapu: \'%1\' znajduje się w przeszłości, zaplanowanie etapu się nie powiedzie.'[_stg_sym];
                     _komm_args.MESSAGE:=_msg;
                     exec('add_komm','px_komm',_komm_args)
                  ?}
               ?};

::             Sprawdzam czy w podanym punkcie czasowym są pojemniki
               PX_OPER.cntx_psh();
               PX_OPER.index('UNIQALL');
               PX_OPER.prefix(PX_POINT.PX_STAGE);
               {? PX_OPER.first()
               || _has_cup:=1;
                  {!
                  |?
                     {? PX_POINT.TM_MIN>0
                     || {? exec('cup_point_check','px_plan',PX_OPER.PX_KONT,PX_POINT.TM_MIN,PX_GRP.DIR)=0
                        || _has_cup:=0
                        ?}
                     ?};
                     {? PX_POINT.TM_MAX>0
                     || {? exec('cup_point_check','px_plan',PX_OPER.PX_KONT,PX_POINT.TM_MAX,PX_GRP.DIR)=0
                        || _has_cup:=0
                        ?}
                     ?};
                     PX_OPER.next() & _has_cup>0
                  !};
                  {? _has_cup=0
                  ||
::                   Brak pojemnika w punkcie czasowym, dodaję komunikat
                     _result:=0;
                     {? var_pres('_komm_args')>100
                     || obj_del(_komm_args)
                     ?};
                     _komm_args:=exec('add_komm_a','px_komm');
                     _komm_args.PX_VER:=PX_GRP.PX_VER;
                     _komm_args.PX_GRP:=PX_GRP.ref();
                     _komm_args.TYP:=exec('type_error','px_komm');
                     _komm_args.SRC_KIND:=_src_kind;

                     _stg_sym:=$PX_STAGE.NR+'. '+PX_STAGE.NAZWA;
                     _termin:=19+tm_form(PX_OBJ.TM_REA);
                     _zas_sym:=PX_OPER.PX_KONT().NAZWA;
                     _msg:='Punkt czasowy etapu: \'%1\' na zasobie: \'%2\' nie znalazł pojemników. Należy wygenerować pojemniki lub przesunąć punkt czasowy.'[_stg_sym,_zas_sym];
                     _komm_args.MESSAGE:=_msg;
                     exec('add_komm','px_komm',_komm_args)
                  ?}
               ||
::                Etap z punktem nie ma żadnych operacji
                  _result:=0;
                  {? var_pres('_komm_args')>100
                  || obj_del(_komm_args)
                  ?};
                  _komm_args:=exec('add_komm_a','px_komm');
                  _komm_args.PX_VER:=PX_GRP.PX_VER;
                  _komm_args.PX_GRP:=PX_GRP.ref();
                  _komm_args.TYP:=exec('type_error','px_komm');
                  _komm_args.SRC_KIND:=_src_kind;

                  _stg_sym:=$PX_STAGE.NR+'. '+PX_STAGE.NAZWA;
                  _termin:=19+tm_form(PX_OBJ.TM_REA);
                  _msg:='Etap: %1 ma punkt czasowy, ale nie przypisano mu żadnego zasobu w planie. Należy skontrolować przepis planistyczny.'[_stg_sym];
                  _komm_args.MESSAGE:=_msg;
                  exec('add_komm','px_komm',_komm_args)
               ?};
               PX_OPER.cntx_pop();
               PX_POINT.next()
            !}
         ?};
         PX_STAGE.next()
      !}
   ?}
?};
PX_OPER.cntx_pop();
PX_CONN.cntx_pop();
PX_OBJ.cntx_pop();
PX_POINT.cntx_pop();
PX_STAGE.cntx_pop();
PX_TEX.cntx_pop();
PX_GRP.cntx_pop();
PX_KONT.cntx_pop();
_result


\point_verify
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Weryfikuje etap sprawdzajac czy sa jakies poprzednie/nastepne etapy ktore maja punkt czasowy ktory moze
::       kolidowac z punktem czasowym etapu weryfikowanego
::       Kontekst pracy - PX_STAGE
::   WE: _a - PX_VER.ref() - wersja planu do ktorej dodawac komunikaty o weryfikacji
::       _b - PX_GRP.ref() - obiekt grupujacy
::       _c - INTEGER - kierunek przetwarzania:  1 - sprawdzac nastepniki
::                                              -1 - sprawdzac poprzedniki
::       _d - TKTL.ref() lub PX_TEX.ref()
::       _e - obj_new - interwal czasu w ktorym siedza punkty czasowe dla etapu ktory weryfikuje - exec('interval','px_utils')
::       _f - STRING - nazwa etapu z punktem czasowym z ktorego wyszedlem
::       _g - obj_new - tablica refow PX_STAGE ktore powodowaly jakis konflikt exec('ref_table','#table');
::            zapamietuje te refy po to by nie dodawac ponownie komunikatow o tym samym skonfliktowanym etapie
::       [_h] - obj_new - tablica refow PX_STAGE dla przebiegu rekurencyjnego - tutaj odpisuje refy PX_STAGE ktore juz
::                        zbadalem, po to zeby sie nie zapetlilo w rekurencji
::       [_i] - INTEGER - tryb dodawania komunikatow: [1] - PX_KOMM
::                                                     2  - KOMM
::   WY: 0 - istnieja punkty czasowe ktore sie zazebiaja
::       1 - brak problemow z punktami czasowymi
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_px_grp:=_b;
_dir:=_c;
_RootRef:=_d;
_interval:=_e;
_src_sym:=_f;
_ref_table:=_g;

_rt_recur:=~~;
{? var_pres('_h')>100
|| _rt_recur:=_h
|| _rt_recur:=exec('ref_table','#table')
?};

_komm:=1;
{? var_pres('_i')=type_of(0)
|| _komm:=_i
?};

_result:=1;

PX_SET.cntx_psh();
PX_STAGE.cntx_psh();
PX_POINT.cntx_psh();
PX_POINT.index('PX_GRP');

{? _dir<0
||
:: Sprawdzam poprzedniki
   _stages_prev:=exec('stages_next','px_stage',,_dir);
   {? _stages_prev.first()
   || PX_STAGE.prefix();
      {!
      |? PX_STAGE.prefix();
         {? PX_STAGE.seek(_stages_prev.REF)
         ||
::          Sprawdzam czy badalem juz ten etap (sprawdzam po to zeby nie zapetlila sie rekurencja)
            {? _rt_recur.r_find(PX_STAGE.ref())=0
            ||
               _rt_recur.r_add(PX_STAGE.ref());
               PX_POINT.prefix(_px_grp,PX_STAGE.ref());
               {? PX_POINT.first()
               ||
::                Znalazlem punkt czasowy

::                Sprawdzam czy jego koniec nie przekracza poczatku okreslonego przez interwal
                  {? _interval.START>0 & PX_POINT.TM_MAX>0 & PX_POINT.TM_MAX>_interval.START
                  ||
                     _result:=0;
                     {? _ref_table.r_find(PX_STAGE.ref())=0
                     ||
                        _ref_table.r_add(PX_STAGE.ref());

                        _stg_sym:=$PX_STAGE.NR+'. '+PX_STAGE.NAZWA;
                        {? PX_STAGE.PX_SET<>null()
                        || _stg_sym+=' (zestaw: '+PX_STAGE.PX_SET().SYMBOL+')'
                        ?};
                        _msg:='Maksymalny czas końca etapu: %1 zazębia się z minimalnym początkiem etapu: %2'[_stg_sym,_src_sym];

::                      Wykryto zazebienie - dodaje komunikaty
                        {? _komm=1
                        ||

                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=_px_ver;
                           _komm_args.PX_GRP:=_px_grp;
                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.SRC_KIND:=exec('src_poi_verify','px_komm');

                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args)
                        |? _komm=2
                        || KOMM.add(_msg,2)
                        ?}
                     ?}
                  ?};
::                Sprawdzam czy jego poczatek nie przekracza konca okreslonego przez interwal
                  {? _interval.END>0 & PX_POINT.TM_MIN>0 & PX_POINT.TM_MIN>_interval.END
                  ||
                     _result:=0;
                     {? _ref_table.r_find(PX_STAGE.ref())=0
                     ||
                        _ref_table.r_add(PX_STAGE.ref());

                        _stg_sym:=$PX_STAGE.NR+'. '+PX_STAGE.NAZWA;
                        {? PX_STAGE.PX_SET<>null()
                        || _stg_sym+=' (zestaw: '+PX_STAGE.PX_SET().SYMBOL+')'
                        ?};
                        _msg:='Minimalny czas początku etapu: %1 zazębia się z maksymalnym końcem etapu: %2'[_stg_sym,_src_sym];

::                      Wykryto zazebienie - dodaje komunikaty
                        {? _komm=1
                        ||
                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=_px_ver;
                           _komm_args.PX_GRP:=_px_grp;
                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.SRC_KIND:=exec('src_poi_verify','px_komm');

                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args)
                        |? _komm=2
                        || KOMM.add(_msg,2)
                        ?}
                     ?}
                  ?}
               ?};

::             !!!REKURENCJA!!!
               _rec_res:=exec('point_verify','px_point'  ,_px_ver
                                                         ,_px_grp
                                                         ,_dir
                                                         ,_RootRef
                                                         ,_interval
                                                         ,_src_sym
                                                         ,_ref_table
                                                         ,_rt_recur
                                                         ,_komm
                                                         );
               {? _rec_res=0
               || _result:=0
               ?}
            ?}
         ?};
         _stages_prev.next()
      !}
   ?}
|? _dir>0
||
:: Sprawdzam nastepniki
   _stages_next:=exec('stages_next','px_stage',,_dir);

   {? _stages_next.first()
   ||
      {!
      |? PX_STAGE.prefix();
         {? PX_STAGE.seek(_stages_next.REF)
         ||
::          Sprawdzam czy badalem juz ten etap (sprawdzam po to zeby nie zapetlila sie rekurencja)
            {? _rt_recur.r_find(PX_STAGE.ref())=0
            ||
               _rt_recur.r_add(PX_STAGE.ref());

               PX_POINT.prefix(_px_grp,PX_STAGE.ref());
               {? PX_POINT.first()
               ||
::                Znalazlem punkt czasowy
                  _int_nast:=exec('interval','#interval');
                  _int_nast.START:=PX_POINT.TM_MIN;
                  _int_nast.END:=PX_POINT.TM_MAX;
::                Sprawdzam czy jego poczatek nie przekracza konca okreslonego przez interwal
                  {? _interval.END>0 & PX_POINT.TM_MIN>0 & PX_POINT.TM_MIN<_interval.END
                  ||
                     _result:=0;
                     {? _ref_table.r_find(PX_STAGE.ref())=0
                     ||
                        _ref_table.r_add(PX_STAGE.ref());

                        _stg_sym:=$PX_STAGE.NR+'. '+PX_STAGE.NAZWA;
                        {? PX_STAGE.PX_SET<>null()
                        || _stg_sym+=' (zestaw: '+PX_STAGE.PX_SET().SYMBOL+')'
                        ?};
                        _msg:='Minimalny czas początku etapu: %1 zazębia się z maksymalnym końcem etapu: %2'[_stg_sym,_src_sym];

::                      Wykryto zazebienie - dodaje komunikaty
                        {? _komm=1
                        ||

                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=_px_ver;
                           _komm_args.PX_GRP:=_px_grp;
                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.SRC_KIND:=exec('src_poi_verify','px_komm');

                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args)
                        |? _komm=2
                        || KOMM.add(_msg,2)
                        ?}
                     ?}
                  ?};

::                Sprawdzam czy jego koniec nie przekracza poczatku okreslonego przez interwal
                  {? _interval.START>0 & PX_POINT.TM_MAX>0 & PX_POINT.TM_MAX<_interval.START
                  ||
                     _result:=0;
                     {? _ref_table.r_find(PX_STAGE.ref())=0
                     ||
                        _ref_table.r_add(PX_STAGE.ref());

                        _stg_sym:=$PX_STAGE.NR+'. '+PX_STAGE.NAZWA;
                        {? PX_STAGE.PX_SET<>null()
                        || _stg_sym+=' (zestaw: '+PX_STAGE.PX_SET().SYMBOL+')'
                        ?};
                        _msg:='Maksymalny czas końca etapu: %1 zazębia się z minimalnym końcem etapu: %2'[_stg_sym,_src_sym];

::                      Wykryto zazebienie - dodaje komunikaty
                        {? _komm=1
                        ||

                           {? var_pres('_komm_args')>100
                           || obj_del(_komm_args)
                           ?};
                           _komm_args:=exec('add_komm_a','px_komm');
                           _komm_args.PX_VER:=_px_ver;
                           _komm_args.PX_GRP:=_px_grp;
                           _komm_args.TYP:=exec('type_error','px_komm');
                           _komm_args.SRC_KIND:=exec('src_poi_verify','px_komm');

                           _komm_args.MESSAGE:=_msg;
                           exec('add_komm','px_komm',_komm_args)
                        |? _komm=2
                        || KOMM.add(_msg,2)
                        ?}
                     ?}
                  ?}
               ?};

::             !!!REKURENCJA!!!
               _rec_res:=exec('point_verify','px_point'  ,_px_ver
                                                         ,_px_grp
                                                         ,_dir
                                                         ,_RootRef
                                                         ,_interval
                                                         ,_src_sym
                                                         ,_ref_table
                                                         ,_rt_recur
                                                         ,_komm
                                                         );
               {? _rec_res=0
               || _result:=0
               ?}
            ?}
         ?};
         _stages_next.next()
      !}
   ?}
?};
PX_POINT.cntx_pop();
PX_STAGE.cntx_pop();
PX_SET.cntx_pop();
_result


\view_chk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy dla podanej daty, obiektu grupujacego i etapu sa jakies punkty czasowe
::       Kontekst pracy:
::                         aktualny widok planu - PX_VIEW
::   WE: _a - PX_GRP.ref()
::       _b - PX_STAGE.ref()
::       _c - DATY.ref()
::   WY: STRING - jesli pusty to znak ze brak pozycji planu
::                jesli cos zawiera to znak ze sa pozycje planu
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_px_stage:=_b;
_daty:=_c;

_result:='';
_can_continue:=1;

_level:=PX_VIEW.LEVEL;

_txt_min:=exec('txt_point_min','px_param');
_txt_max:=exec('txt_point_max','px_param');

PX_POINT.cntx_psh();
DATY.cntx_psh(); DATY.clear();
{? DATY.seek(_daty)
||
   DATY.cntx_psh();
   _next:=null();
   {? exec('find_next','daty',_level)>0
   || _next:=DATY.ref()
   ?};
   DATY.cntx_pop();

   _int_daty:=exec('create_interval','daty',DATY.ref(),_next);

:: Minimalny czas poczatku
   _index:='LEV_S_'+_level;
   PX_POINT.index(_index);

   exec('level_prefix','px_point',_px_grp,_px_stage,_level);
   {? PX_POINT.first()
   || _result:=_txt_min;
      _can_continue:=0
   ?};

   {? _can_continue>0
   ||
::    Maksymalny czas konca
      _index:='LEV_E_'+_level;
      PX_POINT.index(_index);

      exec('level_prefix','px_point',_px_grp,_px_stage,_level);
      {? PX_POINT.first()
      || _result:=_txt_max;
         _can_continue:=0
      ?}
   ?};
   ~~
?};
DATY.cntx_pop();
PX_POINT.cntx_pop();
_result


\level_prefix
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Prefiksuje PX_POINTy na odpowiednim poziomie widoku
::   WE:  _a - PX_GRP.ref()
::        _b - PX_STAGE.ref()
::        _c - STRING - poziom widoku
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_px_stage:=_b;
_level:=_c;

{? _level='R'
|| PX_POINT.prefix(_px_grp,_px_stage,DATY.ROK)
|? _level='K'
|| PX_POINT.prefix(_px_grp,_px_stage,DATY.ROK,DATY.KWARTAL)
|? _level='M'
|| PX_POINT.prefix(_px_grp,_px_stage,DATY.ROK,DATY.MIESIAC)
|? _level='T'
|| PX_POINT.prefix(_px_grp,_px_stage,DATY.ROK,DATY.TYDZIEN)
|? _level='D'
|| PX_POINT.prefix(_px_grp,_px_stage,DATY.DATA)
?};
~~

\auto_point_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Argumenty dla funkcji tworzacej automatyczne punkty czasowe
::   WY: obj_new
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
::             Grupa ktorej tworzyc punkty czasowe
               'PX_GRP'
::             Przepis na podstawie ktorego szukac etapow
               ,'PX_TEX'
::             Zestaw ktory ogranicza dziedzine PX_STAGE
               ,'PX_SET'
::             Konkretny etap ktoremu tylko tworzyc punkt czasowy
               ,'PX_STAGE'
::             Zwrot planowania
               ,'DIR'
::             Data graniczna
               ,'GRN_DATA'
::             Czas graniczny
               ,'GRN_TIME'
::             Tryb prefiksowania PX_STAGE
               ,'PREFIX_MODE'
::             Tryb dzialania: 'CREATE' - tworzy punkty czasowe
::                             'FORMULA' - uruchamia podana formule, w kontekscie etapu
::                                         na ktorym mialby powstac automatyczny punkt czasowy
::                                         formula jako _a dostanie ten obiekt a jako _b pole ARGS
::                                         (przydatne do roznych weryfikacji itp)
               ,'MODE'
::             Formula dla trybu 'FORMULA'
               ,'FORMULA'
::             Argumenty dla FORMULA
               ,'ARGS'
::             Czy usuwac napotkane punkty reczne w miejscu w ktorym chcialbym zrobic automatyczne?
               ,'DEL_MANUAL'

::             Tablica z refami odwiedzonych etapow
               ,'VISITED'
::             Czy jestem na poczatku sciezki
               ,'PATH_START'
              );
_args.PX_GRP:=null();
_args.PX_SET:=null();
_args.PX_STAGE:=null();
_args.DIR:=0;
_args.GRN_DATA:=date(0,0,0);
_args.GRN_TIME:=time(0,0,0);
_args.PREFIX_MODE:='';
_args.MODE:='CREATE';
_args.FORMULA:="";
_args.ARGS:=~~;
_args.DEL_MANUAL:=0;
_args.VISITED:=exec('ref_table','#table');
_args.PATH_START:=0;
_args


\auto_point
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Tworzy automatyczne punkty czasowy na etapach nalezacych do zestawu zgodnie z przekazanym
::       zwrotem i czasem granicznym
::   WE: _args - argumenty dla funkcji, wynik dzialania exec('auto_point_a','px_point')
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=1;
_can_continue:=1;

PX_GRP.cntx_psh(); PX_GRP.clear();
PX_SET.cntx_psh();
PX_STAGE.cntx_psh();

_locked:=null();
{? _args.PX_GRP<>null()
||
   {? PX_GRP.seek(_args.PX_GRP)
   ||
::    Blokuje grupe do edycji
      {? exec('lock','px_grp')>0
      || _locked:=PX_GRP.ref();
         _can_continue:=1
      || _can_continue:=0
      ?}
   || _can_continue:=0
   ?}
?};
{? _can_continue>0
||
:: Znajduje etapy początkowe lub końcowe
   _etapy_start:=exec('stages_starting_ending','px_stage',_args.PX_TEX,,_args.DIR);

   {? _can_continue>0 & _args.MODE='CREATE' & _args.PX_GRP<>null()
   ||
::    Usuwam najpierw wszystkie dotychczasowe automatyczne punkty
      PX_POINT.cntx_psh();
      PX_POINT.index('PX_SET');
      {? _args.PX_STAGE<>null()
      || PX_POINT.prefix(_args.PX_SET,_args.PX_GRP,'A',_args.PX_STAGE)
      || PX_POINT.prefix(_args.PX_SET,_args.PX_GRP,'A')
      ?};
      {? PX_POINT.first()
      || {!
         |? _can_continue:=exec('delete','px_point',PX_POINT.ref(),1);
            PX_POINT.first() & _can_continue>0
         !}
      ?};
      PX_POINT.cntx_pop()
   ?};

   {? _can_continue>0
   ||
::    Uruchamiam tworzenie punktow na kazdej sciezce

      PX_STAGE.prefix();
      _etapy_start.prefix();
      {? _etapy_start.first() & _args.GRN_DATA<>date(0,0,0)
      || {!
         |? {? PX_STAGE.seek(_etapy_start.REF)
            ||
               _args.PATH_START:=1;
               {? exec('auto_point_core','px_point',_args)>0
               || _result:=1
               || _result:=0
               ?}
            ?};
            _etapy_start.next()
         !}
      ?}
   ?}
?};
{? _locked<>null()
||
:: Odblokowuje grupe
   exec('unlock','px_grp',_locked)
?};

PX_STAGE.cntx_pop();
PX_SET.cntx_pop();
PX_GRP.cntx_pop();
_result


\auto_point_core
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Tworzy punkt czasowy na etapie nalezacym do zestawu, idzie po sciezce nastepnikow/poprzednikow
::       rekurencyjnie zgodnie ze zwrotem i zatrzymuje sie jesli utworzy pierwszy punkt czasowy
::       Kontekst dzialania - PX_STAGE
::   WE: _args - argumenty dla funkcji, wynik dzialania exec('auto_point_a','px_point')
::   WY: 0 - porazka - nie utworzono punktu czasowego
::       1 - sukces - utworzono punkt czasowy
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_result:=0;

PX_STAGE.cntx_psh();

_can_continue:=1;

{? _can_continue>0
||
:: Sprawdzam czy zestaw jest zgodny
   _set_chk:=1;
   {? _args.PX_SET<>null()
   || {? $PX_STAGE.PX_SET=$_args.PX_SET
      || _set_chk:=1
      || _set_chk:=0
      ?}
   ?};

   {? _set_chk>0
   ||
      {? _args.PX_STAGE<>null & $_args.PX_STAGE<>$PX_STAGE.ref()
      ||
::       Jesli etap w argumentach przekazany i nie zgadza sie z tym na ktorym stoje to nie ide dalej
         _can_continue:=0
      ?};

      {? _can_continue>0
      ||
         {? _args.MODE='CREATE'
         ||
::          Zestaw zgodny - lub brak zestawu tworze automatyczny punkt czasowy o ile na tym etapie nie ma jeszcze
::          zadnego punktu czasowego

            PX_POINT.cntx_psh();
            PX_POINT.index('PX_GRP');
            PX_POINT.prefix(_args.PX_GRP,PX_STAGE.ref());
            {? PX_POINT.first() & PX_POINT.TYP='R' & _args.DEL_MANUAL>0
            ||
::             Tu gdzie chcialem zrobic punkt automatyczny spotkalem punkt reczny
::             wiec go usuwam
               _can_continue:=exec('delete','px_point',PX_POINT.ref())
            ?};
            {? PX_POINT.size()=0
            ||
               _buffer:=exec('buffer','px_point');
               _buffer.bl_table();
               _buffer.TYP:='A';
               _buffer.PX_GRP:=_args.PX_GRP;
               _buffer.PX_STAGE:=PX_STAGE.ref();
               {? _args.DIR>0
               || _buffer.MIN_DATE:=_args.GRN_DATA;
                  _buffer.MIN_TIME:=_args.GRN_TIME
               |? _args.DIR<0
               || _buffer.MAX_DATE:=_args.GRN_DATA;
                  _buffer.MAX_TIME:=_args.GRN_TIME
               ?};
               _result:=exec('add','px_point',_buffer,0)
            || _result:=1
            ?};
            PX_POINT.cntx_pop()
         |? _args.MODE='FORMULA'
         ||
::          Zestaw zgodny - lub brak zestawu, uruchamiam przekazana formule weryfikujaca
            _fml:=_args.FORMULA;
            _result:=_fml(_args,_args.ARGS)
         ?}
      ?}
   ||
::    Zestaw niezgodny - przechodze na kolejny etap i tam badam
      _stages_next:=exec('stages_next','px_stage',,_args.DIR);
      {? _stages_next.first()
      || {!
         |? PX_STAGE.prefix();
            {? PX_STAGE.seek(_stages_next.REF)
            || _args.PATH_START:=0;
::             !!! REKURENCJA !!!
               _result:=exec('auto_point_core','px_point',_args)
            ?};
            _stages_next.next()
         !}
      ?}
   ?}
?};
PX_STAGE.cntx_pop();
_result


\compare
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Porownuje ze soba dwa punkty czasowe
::   WE: _a - obj_new - tablica nazwana bedaca buforem tabeli exec('buffer','px_point')
::       _b - obj_new - tablica nazwana bedaca buforem tabeli exec('buffer','px_point')
::   WY: 0 - punkty czasowe roznia sie
::       1 - punkty czasowe sa identyczne
::  OLD: \compare/px_point.fml.xxx
::----------------------------------------------------------------------------------------------------------------------
_poi1:=_a;
_poi2:=_b;

_result:=1;

{? _poi1.MIN_DATE<>_poi2.MIN_DATE
|| _result:=0
?};
{? _poi1.MIN_TIME<>_poi2.MIN_TIME
|| _result:=0
?};
{? _poi1.MAX_DATE<>_poi2.MAX_DATE
|| _result:=0
?};
{? _poi1.MAX_TIME<>_poi2.MAX_TIME
|| _result:=0
?};
{? _poi1.TM_MIN<>_poi2.TM_MIN
|| _result:=0
?};
{? _poi1.TM_MAX<>_poi2.TM_MAX
|| _result:=0
?};
_result


\auto_point_upd
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Uaktualnia daty na automatycznych punktach czasowych na podstawie granic czasowych grupy w kolejce
::   WE: _a - PX_GRP.ref
::   WY: 0 - porazka
::       1 - sukces
::  OLD: \auto_point_upd/px_point.fml.xxx
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

{? exec('is_px_set','px_param')>0
||
   PX_GRP.cntx_psh();
   {? _ref<>null()
   || PX_GRP.clear();
      {? PX_GRP.seek(_ref)
      || _can_continue:=1
      || _can_continue:=0
      ?}
   ?};

   {? _can_continue>0
   ||
::    Pobieram granice czasowe z grupy
      _grp_start:=PX_GRP.TM_START;
      _grp_end:=PX_GRP.TM_END;

      PX_POINT.cntx_psh();
      PX_POINT.index('TYP');
      PX_POINT.prefix('A',PX_GRP.ref());
      {? PX_POINT.first()
      || {!
         |?
            {? var_pres('_buffer')>100
            || obj_del(_buffer)
            ?};
            _buffer:=exec('buffer','px_point');
            _buffer.get();
            _put:=0;
            {? _buffer.TM_MIN>0
            ||
::             Punkt czasowy - minimalny czas startu
               {? _buffer.TM_MIN<_grp_start
               ||
::                Punkt czasowy wczesniej niz czas startu na grupie
                  _buffer.TM_MIN:=_grp_start;
                  _put:=1
               ?};
               {? _buffer.TM_MIN>_grp_end
               ||
::                Punkt czasowy pozniej niz czas konca na grupie
                  _buffer.TM_MIN:=_grp_end;
                  _put:=1
               ?}
            ?};

            {? _buffer.TM_MAX>0
            ||
::             Punkt czasowy - maksymalny czas konca
               {? _buffer.TM_MAX>_grp_end
               ||
::                Punkt czasowy pozniej niz czas konca na grupie
                  _buffer.TM_MAX:=_grp_end;
                  _put:=1
               ?};
               {? _buffer.TM_MAX<_grp_start
               ||
::                Punkt czasowy wczesniej niz czas startu na grupie
                  _buffer.TM_MAX:=_grp_start
               ?}
            ?};

            {? _put>0
            ||
               {? _buffer.TM_MIN>0
               || _buffer.MIN_DATE:=exec('tm_stamp2date','#tm_stamp',_buffer.TM_MIN);
                  _buffer.MIN_TIME:=exec('tm_stamp2time','#tm_stamp',_buffer.TM_MIN)
               ?};
               {? _buffer.TM_MAX>0
               || _buffer.MAX_DATE:=exec('tm_stamp2date','#tm_stamp',_buffer.TM_MAX);
                  _buffer.MAX_TIME:=exec('tm_stamp2time','#tm_stamp',_buffer.TM_MAX)
               ?};

               _can_continue:=exec('put','px_point',_buffer,PX_POINT.ref(),0)
            ?};
            PX_POINT.next() & _can_continue>0
         !}
      ?};
      PX_POINT.cntx_pop();
      ~~
   ?};
   PX_GRP.cntx_pop()
?};
{? _can_continue>0
|| _result:=1
?};
_result


\auto_point_del
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Usuwa wszystkie punkty czasowe automatyczne i automatyczne-poprawiane dla podanego
::       PX_GRPa
::   WE: [_a] - PX_GRP.ref() lub biezacy rekord
::       [_b] - PX_STAGE.ref() - etap dla ktorego usunac punkty
::       [_c] - PX_SET.ref() - zestaw dla ktorego usuwac punkty
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_px_stage:=null();
{? var_pres('_b')=type_of(PX_STAGE.ref())
|| _px_stage:=_b
?};

_px_set:=null();
{? var_pres('_c')=type_of(PX_SET.ref())
|| _px_set:=_c
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.clear();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_POINT.cntx_psh();
   PX_POINT.index('TYP');

:: 1. Usuwam wszystkie automatyczne
   {? _px_stage<>null() & _px_set<>null()
   || PX_POINT.prefix('A',PX_GRP.ref(),_px_stage,_px_set)
   |? _px_stage<>null() & _px_set=null()
   || PX_POINT.prefix('A',PX_GRP.ref(),_px_stage)
   || PX_POINT.prefix('A',PX_GRP.ref())
   ?};
   {? PX_POINT.first()
   || {!
      |? _can_continue:=exec('delete','px_point',PX_POINT.ref());
         PX_POINT.first() & _can_continue>0
      !}
   ?};
:: 2. Usuwam wszystkie automatyczne-poprawiane
   {? _can_continue>0
   ||
      {? _px_stage<>null() & _px_set<>null()
      || PX_POINT.prefix('P',PX_GRP.ref(),_px_stage,_px_set)
      |? _px_stage<>null() & _px_set=null()
      || PX_POINT.prefix('P',PX_GRP.ref(),_px_stage)
      || PX_POINT.prefix('P',PX_GRP.ref())
      ?};
      {? PX_POINT.first()
      || {!
         |? _can_continue:=exec('delete','px_point',PX_POINT.ref());
            PX_POINT.first() & _can_continue>0
         !}
      ?}
   ?};
   PX_POINT.cntx_pop();
   ~~
?};
PX_GRP.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\get_auto_dir
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy sa jakies automatyczne punkty czasowe dla podanej grupy i zestawu
::       i zwraca zwrot planowania na podstawie tych punktow
::   WE: _a - PX_GRP.ref()
::       _b - PX_SET.ref()
::   WY: REAL: -1/0/1
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_px_set:=_b;

_dir:=0;

PX_POINT.cntx_psh();
PX_STAGE.cntx_psh();

PX_POINT.index('PX_SET');
PX_POINT.prefix(_px_set,_px_grp,'A');
{? PX_POINT.first()
||
:: Okreslam zwrot na podstawie pierwszego znalezionego punktu czasowego,
:: poniewaz pozostale punkty automatyczne powinny byc tego samego typu
   {? PX_POINT.TM_MAX>0 & PX_POINT.TM_MIN=0
   ||
::    Punkt okresla maksymalny czas konca
      _dir:=-1
   |? PX_POINT.TM_MIN>0 & PX_POINT.TM_MAX=0
   ||
::    Punkt okresla minimalny czas poczatku
      _dir:=1
   ?}
?};

PX_STAGE.cntx_pop();
PX_POINT.cntx_pop();
_dir


\get_auto_grn
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy sa jakies automatyczne punkty czasowe dla podanej grupy i zestawu
::       i zwraca granice planowania na podstawie tych punktow
::   WE: _a - PX_GRP.ref()
::       _b - PX_SET.ref()
::   WY: tm_stamp - granica czasowa okreslona na podstawie puntkow lub 0
::----------------------------------------------------------------------------------------------------------------------
_px_grp:=_a;
_px_set:=_b;

_tm_grn:=0;

PX_POINT.cntx_psh();
PX_STAGE.cntx_psh();

PX_POINT.index('PX_SET');
PX_POINT.prefix(_px_set,_px_grp,'A');
{? PX_POINT.first()
||
:: Okreslam zwrot na podstawie pierwszego znalezionego punktu czasowego,
:: poniewaz pozostale punkty automatyczne powinny byc tego samego typu
   {? PX_POINT.TM_MAX>0 & PX_POINT.TM_MIN=0
   ||
::    Punkt okresla maksymalny czas konca
      _tm_grn:=PX_POINT.TM_MAX
   |? PX_POINT.TM_MIN>0 & PX_POINT.TM_MAX=0
   ||
::    Punkt okresla minimalny czas poczatku
      _tm_grn:=PX_POINT.TM_MIN
   ?}
?};

PX_STAGE.cntx_pop();
PX_POINT.cntx_pop();
_tm_grn


\restore
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Odtwarza punkt czasowy dla biezacego etapu
::       Kontekst pracy - PX_STAGE, PX_GRPS, PX_GRP
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------

_result:=0;
_can_continue:=1;

{? PX_VAR.PX_SET<>null()
||
:: Usuwam isniejace punkty
   _can_continue:=exec('auto_point_del','px_point',,PX_STAGE.ref(),PX_VAR.PX_SET);

   {? _can_continue>0
   || _args_poi:=exec('auto_args_grps','px_point',PX_STAGE.ref());
      _result:=exec('auto_point','px_point',_args_poi)
   ?}
?};
_result


\restore_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Akcja 'Przywróc' w oknie etapów planistycznych
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------

_result:=0;
_can_continue:=1;

:: Sprawdzam czy biezacy etap ma punkt czasowy automatyczny lub automatyczny poprawiony
{? exec('has_point','px_point',PX_GRP.ref(),'AP',PX_STAGE.ref())=0
|| _can_continue:=0;
   _msg:='Etap: %1 nie posiada automatycznego punktu czasowego. Przywrócenie go zakończone niepowodzeniem.'@[PX_STAGE.NAZWA];
   {? VAR.GRUPA='T'
   || KOMM.add(_msg,2)
   || FUN.emsg(_msg)
   ?}
?};

:: Sprawdzam czy etap nalezy do wybranego zestawu
{? PX_VAR.PX_SET<>null()
||
   {? PX_STAGE.PX_SET<>PX_VAR.PX_SET
   ||
      _can_continue:=0;
      _msg:='Etap: %1 należy do zestawu: %2. Aby go przywrócić należy pracować w tym zestawie.'@[PX_STAGE.NAZWA,PX_STAGE.PX_SET().SYMBOL];
      {? VAR.GRUPA='T'
      || KOMM.add(_msg,2)
      || FUN.emsg(_msg)
      ?}
   ?}
|| _can_continue:=0
?};

{? _can_continue>0
||
   {? VAR.GRUPA<>'T'
   || _can_continue:=FUN.ask('Czy na pewno przywrócić automatyczny punkt czasowy dla etapu: %1?'@[PX_STAGE.NAZWA])
   ?};

   {? _can_continue>0
   || _result:=exec('restore','px_point')
   ?}
?};
_result


\restore_gr1
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Akcja grupa przed 'Przywróc' w oknie etapów planistycznych
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='T';
{? FUN.ask('Zaznaczonych etapów: %1. Czy przywrócić dla nich automatyczne punkty czasowe?'@[$PX_STAGE.sel_size()])
|| _result:=1;
   KOMM.init(200,,'Przywracanie automatycznych punktów czasowych.'@)
?};
_result


\restore_gr2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Akcja grupa po 'Przywróc' w oknie etapów planistycznych
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
KOMM.select(,,,,,0);
VAR.GRUPA:='N';
~~


\restore_all_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Akcja 'Przywróc wszystkie' w oknie etapów planistycznych
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_can_continue:=1;

PX_STAGE.cntx_psh();
PX_SET.cntx_psh();
PX_POINT.cntx_psh();
:: Sprawdzam czy sa punkty czasowe do przywrocenia
{? exec('has_point','px_point',PX_GRP.ref(),'P')
||
   {? PX_VAR.PX_SET<>null()
   || _msg:='Czy na pewno przywrócić wszystkie punkty czasowe na etapach powiązanych z bieżącym zestawem planistycznym?\n\n'
            'Obiekt w kolejce: %1\n'
            'Zestaw planistyczny: %2'@[PX_GRP.SYMBOL,PX_VAR.PX_SET().SYMBOL];
      _can_continue:=FUN.ask(_msg)
   || _msg:='Czy na pewno przywrócić wszystkie punkty czasowe dla obiektu w kolejce: %1?'@[PX_GRP.SYMBOL];
      _can_continue:=FUN.ask(_msg)
   ?};
   {? _can_continue>0
   ||
      KOMM.init(250,,'Przywracanie automatycznych punktów czasowych.'@);
      {? PX_STAGE.first()
      || VAR.GRUPA:='T';
         {!
         |?
            {? exec('has_point','px_point',PX_GRP.ref(),'P',PX_STAGE.ref())>0
            || _can_continue:=exec('restore_act','px_point')
            ?};
            PX_STAGE.next() & _can_continue>0
         !};
         VAR.GRUPA:='N'
      ?};
      KOMM.select()
   ?}
|| FUN.emsg('Nie znaleziono żadnego punktu czasowego do przywrócenia.'@)
?};
PX_POINT.cntx_pop();
PX_SET.cntx_pop();
PX_STAGE.cntx_pop();
_result


\has_point
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy wskazana grupa posiada punkt czasowy
::   WE: [_a] - PX_GRP.ref()
::       [_b] - STRING - typy sprawdzanych punktow: domyslnie 'RP'
::       [_c] - PX_STAGE.ref() - etap dla ktorego sprawdzac
::       [_d] - PX_SET.ref() - zestaw dla ktorego sprawdzac
::   WY: 0 - brak punktow czasowych
::       1 - jest co najmniej jeden punkt
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_typy:='RP';
{? var_pres('_b')=type_of('')
|| _typy:=_b
?};
_px_stage:=null();
{? var_pres('_c')=type_of(PX_STAGE.ref())
|| _px_stage:=_c
?};
_px_set:=null();
{? var_pres('_d')=type_of(PX_SET.ref())
|| _px_set:=_d
?};

_result:=0;
_can_continue:=1;

PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.clear();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_POINT.cntx_psh();
   PX_POINT.index('TYP');

:: Iteruje po przekazanych typach
   {? _typy<>''
   ||
      {! _it:=1..(+_typy)
      |? _result=0
      |!
         _typ:=(_it+_typy)+1;

::       Prefiksuje punkty po typie, grupie i ewentualnie etapie
         {? _px_stage<>null() & _px_set<>null()
         || PX_POINT.prefix(_typ,PX_GRP.ref(),_px_stage,_px_set)
         |? _px_stage<>null() & _px_set=null()
         || PX_POINT.prefix(_typ,PX_GRP.ref(),_px_stage)
         |? _px_stage=null() & _px_set<>null()
         || PX_POINT.index('PX_SET');
            PX_POINT.prefix(_px_set,PX_GRP.ref(),_typ)
         || PX_POINT.prefix(_typ,PX_GRP.ref())
         ?};
::       Jesli jest punkt czasowy to koncze petle i zwracam 1
         {? PX_POINT.size()>0
         || _result:=1
         ?}
      !}
   ?};
   PX_POINT.cntx_pop();
   ~~
?};
PX_GRP.cntx_pop();
_result


\has_point_obj
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy wskazany PX_OBJ znajduje sie w takich grupach
::       w wersji glownej planu ktore maja punkty czasowe
::   WE: [_a] - PX_OBJ.ref
::       [_b] - STRING - typy sprawdzanych punktow: domyslnie 'ARP'
::   WY: 0 - brak punktow czasowych
::       1 - jest co najmniej jeden punkt
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};
_typy:='ARP';
{? var_pres('_b')=type_of('')
|| _typy:=_b
?};

_result:=0;
_can_continue:=1;

PX_OBJ.cntx_psh();
PX_CONN.cntx_psh();
PX_CONN.index('VER');
{? _ref<>null()
|| PX_OBJ.clear();
   {? PX_OBJ.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _mainver:=exec('get_mainversion','px_ver');
   PX_CONN.prefix(_mainver,PX_OBJ.ref());
   {? PX_CONN.first()
   || {!
      |?
         _result:=exec('has_point','px_point',PX_CONN.PX_GRP,_typy);
         PX_CONN.next() & _result=0
      !}
   ?}
?};
PX_OBJ.cntx_pop();
PX_CONN.cntx_pop();
_result


\auto_args_grp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Tworzy argumenty dla formuly auto_point na podstawie biezacego PX_GRP
::       Kontekst pracy - PX_GRP.ref, PX_VAR.PX_SET
::   WE: [_a] - PX_STAGE.ref() - etap ktoremu tworzyc punkty
::       [_b] - REAL - tm_stamp - granica czasowa na podstawie ktorej tworzyc punkty
::   WY: obj_new
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=null();
{? var_pres('_a')=type_of(PX_STAGE.ref())
|| _px_stage:=_a
?};

_tm_grn:=-1;
{? var_pres('_b')=type_of(0)
|| _tm_grn:=_b
?};

:: Pobieram paczke planistyczna
_pxpack:=exec('trzepaczka','px_tex',PX_GRP.PX_TEX,PX_GRP.ILOSC,PX_GRP.ref());

:: Wyznaczam czas startowy jaki powinien byc na PX_GRP
{? _tm_grn=-1
|| _tm_start:=exec('round_start_pck','px_tex',_pxpack.Paczka)
|? _tm_grn>0
|| {? PX_GRP.DIR>0
   || _tm_start:=exec('round_start_pck','px_tex',_pxpack.Paczka,_tm_grn)
   || _tm_start:=_tm_grn
   ?}
|? _tm_grn=0
|| _tm_start:=0
?};

{? _tm_start>0
||
:: Czas startu nie moze przekraczac granic okreslonych na grupie
   _tm_start:=exec('min','#math',_tm_start,PX_GRP.TM_END);
   _tm_start:=exec('max','#math',_tm_start,PX_GRP.TM_START)
?};

_args_poi:=exec('auto_point_a','px_point');
_args_poi.PX_GRP:=PX_GRP.ref();
_args_poi.PX_SET:=PX_VAR.PX_SET;
_args_poi.DIR:=PX_GRP.DIR;
_args_poi.PX_STAGE:=_px_stage;
_args_poi.PX_TEX:=PX_GRP.PX_TEX;

{? _tm_grn>0
|| _args_poi.GRN_DATA:=exec('tm_stamp2date','#tm_stamp',_tm_start);
   _args_poi.GRN_TIME:=exec('tm_stamp2time','#tm_stamp',_tm_start)
|? _tm_grn=0
|| _args_poi.GRN_DATA:=date(0,0,0);
   _args_poi.GRN_TIME:=time(0,0,0)
|| {? PX_GRP.DIR>0
   || _args_poi.GRN_DATA:=exec('tm_stamp2date','#tm_stamp',_tm_start);
      _args_poi.GRN_TIME:=exec('tm_stamp2time','#tm_stamp',_tm_start)
   |? PX_GRP.DIR<0
   || _args_poi.GRN_DATA:=PX_GRP.ENDD().DATA;
      _args_poi.GRN_TIME:=PX_GRP.ENDT
   ?}
?};
_args_poi


\auto_args_grps
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Tworzy argumenty dla formuly auto_point na podstawie biezacego PX_GRPSa
::       Kontekst pracy - PX_GRPS.ref, PX_VAR.PX_SET
::   WE: [_a] - PX_STAGE.ref() - etap ktoremu tworzyc punkty
::       [_b] - REAL - tm_stamp - granica czasowa na podstawie ktorej tworzyc punkty
::   WY: obj_new
::----------------------------------------------------------------------------------------------------------------------
_px_stage:=null();
{? var_pres('_a')=type_of(PX_STAGE.ref())
|| _px_stage:=_a
?};

_tm_grn:=0;
{? var_pres('_b')=type_of(0)
|| _tm_grn:=_b
?};

_args_poi:=~~;

PX_GRP.cntx_psh();
{? PX_GRPS.PX_GRP<>null()
||
:: Podczytanie PX_GRP
   PX_GRPS.PX_GRP();
   _args_poi:=exec('auto_args_grp','px_point',_px_stage,_tm_grn);

   _args_poi.DIR:=PX_GRPS.DIR;

:: Pobieram paczke planistyczna
   _pxpack:=exec('trzepaczka','px_tex',PX_GRP.PX_TEX,PX_GRP.ILOSC,PX_GRP.ref());

:: Wyznaczam czas startowy jaki powinien byc na PX_GRP
   _tm_start:=exec('round_start_pck','px_tex',_pxpack.Paczka);

:: Czas startu nie moze przekraczac konca okreslonego na grupie
   _tm_start:=exec('min','#math',_tm_start,PX_GRP.TM_END);

   {? PX_GRPS.GRN_DATA<>date(0,0,0)
   ||
      _tm_grn:=exec('create','#tm_stamp',PX_GRPS.GRN_DATA,PX_GRPS.GRN_TIME);

::    Granica dla puntow nie moze byc mniejsza niz moment startu na PX_GRP
      _tm_grn:=exec('max','#math',_tm_grn,_tm_start);

::    Granica dla punktow nie moze byc wieksza niz koniec na PX_GRP\
      _tm_grn:=exec('min','#math',_tm_grn,PX_GRP.TM_END);

      _args_poi.GRN_DATA:=exec('tm_stamp2date','#tm_stamp',_tm_grn);
      _args_poi.GRN_TIME:=exec('tm_stamp2time','#tm_stamp',_tm_grn)
   ?}
?};
PX_GRP.cntx_pop();
_args_poi


\simulation_zaz
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy gdyby powstal punkt czasowy wg przekazanych wytycznych to
::       czy zazebil by sie z innymi istniejacymi juz punktami na innych etapach
::       Kontekst pracy - PX_STAGE
::   WE: _args - argumenty dla funkcji, wynik dzialania exec('auto_point_a','px_point')
::   WY: 0 - wystapi zazebienie
::       1 - wszystko ok
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=1;

PX_SET.cntx_psh();
_buffer:=exec('buffer','px_point');
_buffer.bl_table();
_buffer.TYP:='A';
_buffer.PX_GRP:=_args.PX_GRP;
_buffer.PX_STAGE:=PX_STAGE.ref();
{? _args.DIR>0
|| _buffer.MIN_DATE:=_args.GRN_DATA;
   _buffer.MIN_TIME:=_args.GRN_TIME
|? _args.DIR<0
|| _buffer.MAX_DATE:=_args.GRN_DATA;
   _buffer.MAX_TIME:=_args.GRN_TIME
?};
_int_poi:=exec('interval','#interval');
_int_poi.START:=exec('create','#tm_stamp',_buffer.MIN_DATE,_buffer.MIN_TIME);
_int_poi.END:=exec('create','#tm_stamp',_buffer.MAX_DATE,_buffer.MAX_TIME);

_stg_sym:=$PX_STAGE.NR+'. '+PX_STAGE.NAZWA;
{? PX_STAGE.PX_SET<>null()
|| _stg_sym+=' (zestaw: '+PX_STAGE.PX_SET().SYMBOL+')'
?};

_mainver:=exec('get_mainversion','px_ver');
_RootRef:=  {? PX_STAGE.PX_TEX<>null()
            || PX_STAGE.PX_TEX
            |? PX_STAGE.TKTL<>null()
            || PX_STAGE.TKTL
            ?};

_ver_nexts:=exec('point_verify','px_point',_mainver
                                          ,_args.PX_GRP
                                          ,1
                                          ,_RootRef
                                          ,_int_poi
                                          ,_stg_sym
                                          ,_args.VISITED
                                          ,
                                          ,2);
_ver_prevs:=exec('point_verify','px_point',_mainver
                                          ,_args.PX_GRP
                                          ,-1
                                          ,_RootRef
                                          ,_int_poi
                                          ,_stg_sym
                                          ,_args.VISITED
                                          ,
                                          ,2);
{? _ver_nexts=0 | _ver_prevs=0
|| _result:=0
|| _result:=1
?};
PX_SET.cntx_pop();
_result


\chk_start_poi
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Gyby powstal punkt czasowy wg przekazanych wytycznych to sprawdza czy:
::        - punkt powstanie na etapie innym niz pierwszy w sciezce
::        - punkt powstanie na startowym pojemniku planu
::       Jesli obydwa warunki okaza sie prawda, to znak ze najprawdopodobniej nie
::       uda sie zaplanowac elementu kolejki bo etapy wczesniejsze nie zmieszcza sie w planie
::   WE: _args - argumenty dla funkcji, wynik dzialania exec('auto_point_a','px_point')
::   WY: 0 - powstanie problem z zaplanowaniem poprzednich etapow
::       1 - wszystko ok
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_wew_args:=_b;

_result:=1;

PX_CUP.cntx_psh();
PX_KONT.cntx_psh();
PX_OPER.cntx_psh();
PX_OPER.index('PX_STAGE');
PX_OPER.prefix('T',PX_STAGE.ref());

:: Sprawdzam czy sa jakies poprzedniki
_args_walk:=exec('walk_a','px_stage');
_args_walk.FORMULA:="1";
_args_walk.DIR:=-1;
_args_walk.START:=PX_STAGE.ref();
_args_walk.ROOTREF:= {? PX_STAGE.PX_TEX<>null()
                     || PX_STAGE.PX_TEX
                     |? PX_STAGE.TKTL<>null()
                     || PX_STAGE.TKTL
                     ?};

exec('walk','px_stage',_args_walk);

{? _args_walk.DISTANCE>1
||
   {? PX_OPER.first()
   || {!
      |?
::       Podczytuje kontener
         PX_OPER.PX_KONT();

::       Zaokrąglam czas obecny
         _mode:='START';
         _tm_now:=exec('round_time','px_kont',PX_KONT.ref(),PX_KONT.tm_stamp(),_mode);

         _tm_grn:=exec('create','#tm_stamp',_args.GRN_DATA,_args.GRN_TIME);
         {? _args.DIR>0
         || _tm_grn:=exec('round_time','px_kont',PX_KONT.ref(),_tm_grn,_mode)
         |? _args.DIR<0
         || _tm_grn:=exec('round_time','px_kont',PX_KONT.ref(),_tm_grn,'END')
         ?};

::       Znajduje pojemnik z zaokrąglonego czasu
         _cup_now:=null();
         {? exec('first_cup','px_logix',_tm_now,_args.DIR)>0
         || _cup_now:=PX_CUP.ref()
         ?};

::       Znajduje pojemnik z granicy czasowej
         _cup_grn:=null();
         {? exec('first_cup','px_logix',_tm_grn,_args.DIR)>0
         || _cup_grn:=PX_CUP.ref()
         ?};

::       Jesli pojemnik startowy i wynikajacy z granicy to ten sam pojemnik
::       to oznacza tarapaty, poniewaz ten etap (ktory jest nty w procesie) jeszcze uda sie zaplanowac
::       ale wczesniejszych etapow juz na bank sie nie uda zaplanowac - beda konflikty
         {? _cup_now<>null() & _cup_grn<>null()
         || {? $_cup_grn=$_cup_now
            || _result:=0;
               _wew_args.STG_NAME:=$PX_STAGE.NR+'. '+PX_STAGE.NAZWA;
               _wew_args.STG_BEF:=_args_walk.DISTANCE-1
            ?}
         ?};
         PX_OPER.next() & _result>0
      !}
   ?}
?};
PX_OPER.cntx_pop();
PX_KONT.cntx_pop();
PX_CUP.cntx_pop();
_result


\fld_bd
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Przed wyswietl dla pol tabeli PX_POINT
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();

_result:=~~;
{? _fld='MIN_DATE'
||
:: Jesli punkt ma Maksymalny czas konca, to wyszarzam Minimalny czas poczatku
   {? PX_POINT.MAX_DATE<>date(0,0,0)
   || _result:=PX_VAR.GREY
   ?}
|? _fld='MIN_TIME'
||
:: Jesli punkt ma Maksymalny czas konca, to wyszarzam Minimalny czas poczatku
   {? PX_POINT.MAX_DATE<>date(0,0,0)
   || _result:=PX_VAR.GREY
   ?}
|? _fld='MAX_DATE'
||
:: Jesli punkt ma Minimalny czas poczatku, to wyszarzam Maksymalny czas konca
   {? PX_POINT.MIN_DATE<>date(0,0,0)
   || _result:=PX_VAR.GREY
   ?}
|? _fld='MAX_TIME'
||
:: Jesli punkt ma Minimalny czas poczatku, to wyszarzam Maksymalny czas konca
   {? PX_POINT.MIN_DATE<>date(0,0,0)
   || _result:=PX_VAR.GREY
   ?}
?};
_result


\fld_be
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Przed redakcja dla pol tabeli PX_POINT
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();

_result:=1;
{? _fld='MIN_DATE'
||
:: Jesli punkt ma Maksymalny czas konca, to blokuje redakcje Minimalny czas poczatku
   {? PX_POINT.MAX_DATE<>date(0,0,0)
   || _result:=0
   ?}
|? _fld='MIN_TIME'
||
:: Jesli punkt ma Maksymalny czas konca, to blokuje redakcje Minimalny czas poczatku
   {? PX_POINT.MAX_DATE<>date(0,0,0)
   || _result:=0
   ?}
|? _fld='MAX_DATE'
||
:: Jesli punkt automatyczny i ma Minimalny czas poczatku, to blokuje redakcje Maksymalny czas konca
   {? PX_POINT.MIN_DATE<>date(0,0,0)
   || _result:=0
   ?}
|? _fld='MAX_TIME'
||
:: Jesli punkt automatyczny i ma Minimalny czas poczatku, to blokuje redakcje Maksymalny czas konca
   {? PX_POINT.MIN_DATE<>date(0,0,0)
   || _result:=0
   ?}
?};
_result


\fld_f3
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Formula na F3 dla pol tabeli PX_POINT
::   WY:
::----------------------------------------------------------------------------------------------------------------------
~~


\fld_ae
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Po redakcji dla pol tabeli PX_POINT
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
{? _fld='MIN_TIME' | _fld='MIN_DATE'
||
:: Jesli data nie podana to czyszcze czas
   {? PX_POINT.MIN_DATE=date(0,0,0)
   || PX_POINT.MIN_TIME:=time(0,0,0)
   ?}
|? _fld='MAX_TIME' | _fld='MAX_DATE'
||
:: Jesli data nie podana to czyszcze czas
   {? PX_POINT.MAX_DATE=date(0,0,0)
   || PX_POINT.MAX_TIME:=time(0,0,0)
   ?}
?};
win_disp();
~~


\fld_fd
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Format wyswietlania dla pol tabeli PX_POINT
::   WY:
::----------------------------------------------------------------------------------------------------------------------
''


\fld_fe
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [12.41]
:: OPIS: Format redagowania dla pol tabeli PX_POINT
::   WY:
::----------------------------------------------------------------------------------------------------------------------
''


\chk_past
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Sprawdza czy podany punkt czasowy nie znajduje sie w przestrzeni ktora uniemozliwi
::       jego zaplanowanie (czyli np jest w przeszlosci i nie bedzie pojemnikow na jego zaplanowanie)
::   WE: [_a] - PX_POINT.ref()
::       _b - INTEGER - tryb sprawdzania:
::                                        1 - sprawdzic czy minimalny czas poczatku nie znajduje sie w przeszlosci
::                                        2 - sprawdzic czy maksymalny czas zakonczenia nie znajduje sie w przeszlosci
::   WY: 0 - punkt czasowy w przeszlosci w stosunku do startu planu
::       1 - punkt czasowy ok, lub nie mial minimalnego czasu rozpoczecia
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(SYSLOG.ref())
|| _ref:=_a
?};

_chk_mode:=_b;

_result:=1;
_can_continue:=1;

PX_OPER.cntx_psh();
PX_KONT.cntx_psh();
PX_STAGE.cntx_psh();
PX_POINT.cntx_psh();
{? _ref<>null()
|| PX_POINT.clear();
   {? PX_POINT.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
:: Sprawdzam czy jest co sprawdzac na danym punkcie czasowym
   {? _chk_mode=1
   || {? PX_POINT.TM_MIN=0
      || _can_continue:=0
      ?}
   ?};
   {? _chk_mode=2
   || {? PX_POINT.TM_MAX=0
      || _can_continue:=0
      ?}
   ?};

   {? _can_continue>0
   ||
::    Podczytuje PX_STAGE
      PX_POINT.PX_STAGE();

      PX_OPER.index('PX_STAGE');
      PX_OPER.prefix('T',PX_STAGE.ref());
      {? PX_OPER.first()
      || {!
         |?
::          Podczytuje kontener
            PX_OPER.PX_KONT();

::          Zaokrąglam czas obecny
            _mode:='START';
            _tm_now:=exec('round_time','px_kont',PX_KONT.ref(),PX_KONT.tm_stamp(),_mode);

            {? _chk_mode=1
            || _tm_grn:=exec('round_time','px_kont',PX_KONT.ref(),PX_POINT.TM_MIN,_mode)
            |? _chk_mode=2
            || _tm_grn:=exec('round_time','px_kont',PX_KONT.ref(),PX_POINT.TM_MAX,'END')
            ?};

            {? _tm_grn<_tm_now
            ||
::             Punkt czasowy wczesniej niz wersja planu sie rozpocznie wiec przerywam i zglaszam problem
               _result:=0
            ?};
            PX_OPER.next() & _result>0
         !}
      ?}
   ?}
?};
PX_STAGE.cntx_pop();
PX_POINT.cntx_pop();
PX_KONT.cntx_pop();
PX_OPER.cntx_pop();
_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:36 94eb6d0208dc988ae8ed38eb3cfb33f378b7d922a39cffd6451dcc3ab09920fab5d743e42c9510a9e2018f1b281736427fba7c2c43255ff03a23d03a80c530a2dc14b6d18c11068c1c6be4f377c2ce98180141e1ffc28d39b9d9ce0c362a0afdef7b2839f88bc9c3cdf9a572e41127a5e439f863c7f7a0d73470437a700bc0fc
