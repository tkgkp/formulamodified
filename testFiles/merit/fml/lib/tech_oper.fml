:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: tech_oper.fml
:: Utworzony: 03.03.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły do obsługi operacji kart technologicznych, wzorców, technologii zlecenia
::            (biblioteka wspólna dla TTE_TEC, TTE_WTE, TTE_PZL)
::            Obsługa tebel:
::            - TOPER - operacje technologiczne
::            - TECHZAMS - zamienniki stanowisk operacji
::            - NASTOPER - następniki operacji
::            - ZGP - pozycje przewodników (kilka pól zamiennych VAR, VAR1 w zakładce Tpz)
::======================================================================================================================


\buffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca obiekt nazwany - bufor tabeli TOPER
::   WY: obj_new()
::----------------------------------------------------------------------------------------------------------------------
exec('TOPER','buffer')


\toper_main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Podstawowa formuła wyświetlająca operacje
::   WE: _a - TKTL.ref()
::       [_b] - czy dostępne funkcje redakcyjne (1 - domyślnie), czy nie (0)
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());


_tktl:=_a;
_edit:={? var_pres('_b')=type_of(0) || _b || 1 ?};

TKTL.cntx_psh();
TKTL.clear();
{? TKTL.seek(_tktl) & TKTL.TYP().OPER='T'
|| VAR.A_KTL:=TKTL.ref();
   VAR.A_TORW:=TKTL.TORW;
   exec('menu_start','tech_head');
   exec('tree','tech_oper',1,_edit);
   exec('menu_stop','tech_head')
|| FUN.emsg(
     {? VAR.A_TORW='W'
     || 'Typ wzorca wyklucza redagowanie operacji.'@
     || 'Typ karty wyklucza redagowanie operacji.'@
     ?}
   )
?};
TKTL.cntx_pop();
~~


\env_oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Zwraca zmienną środowiskową do obsługi listy operacji
::----------------------------------------------------------------------------------------------------------------------
_env:=obj_new('used','zakl','obj');
_env.used:=0;
_env.zakl:=0;
_env.obj:=~~;
_env


\tree
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Struktura - drzewo operacji
::       !!! Działa w kontekście TKTL
::   WE: [_a] - sposób wywołania funkcji czy z poziomu zakładak czy z menu:
::              0 - zakładki zlecenia - technologia źródłowa [TTREE]
::              1 - menu okna wertowania TKTL albo lista ToDo (domyślnie) [TREE]
::              2 - przepis planistyczny [XTTREE]
::              3 - zakładki zlecenia - technologia zlecenia [ZTREE]
::              4 - lista ToDo dla surowców, gdy surowce do operacji [STREE]
::              5 - lista ToDo dla NPU, gdy NPU do operacji [NTREE]
::              6 - kartoteka materiałowa, zakładka Technologia domyślna
::              7 - akcja Przenieś lub F3 w oknie redakcji (tworzone okno selekcji) [SELTREE]
::       [_b] - dostępne redagowanie (1 - domyślnie), nie dostępne redagowanie (0)
::  OLD: \tree/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_zakl:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_edit:={? var_pres('_b')=type_of(0) || _b || 1 ?};

{? _zakl=3 || _torw:='Z' |? _zakl=0 || _torw:='T' || _torw:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TORW",'') ?};
_plrelwyr:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"PLRELWYR",'');

_locked:=0;
_result:=~~;
{? ~_edit
|| _locked:=0;
   _used:=1
|| {? TKTL.ref()<>null()
   || _locked:=exec('tktl_lock','tech_common',,'O')
   ?};
   _used:=~_locked
?};

:: Ustawienie okien dla słownika kontrahentów
exec('ustaw_okna','kontrahent');

_dia:=exec('dot_obj','#graph','toper');

{? _zakl=1 | _zakl=4 | _zakl=5 | _zakl=6 | _zakl=7
||
   TKTL.cntx_psh();
   {? _zakl=1
   || VAR_DEL.delete('TREE','Objt')
   |? _zakl=4
   || VAR_DEL.delete('STREE','Objt')
   |? _zakl=5
   || VAR_DEL.delete('NTREE','Objt')
   |? _zakl=6
   || VAR_DEL.delete('TTREE','Objt')
   |? _zakl=7
   || VAR_DEL.delete('SELTREE','Objt')
   ?};
   XINFO.SLWYDZIA();
   VAR.A_TORW:=_torw;

   _hide:=':';
:: Ukrycie akcji wynikające z kontekstu programu (UWAGA: w zakładkach zlecenia dodatkowo \technologia_load/zl_view.fml)
   {? _zakl=4
   || _hide:='DPUZE(ZNAD)F(NZUWER):DZF(WE)'
   |? _zakl=5
   || _hide:='DPUZE(ZSAD)F(NZUWER):DZF(WE)'
   |? _zakl=7
   || _hide:='DPUZEF:DZF'
   || {? TKTL.ARCH='T' | _used | (VAR.A_ZLEC<>null() & _torw='T') | (_torw='Z' & _plrelwyr<>null())
      || _hide:='DPUF(RZ):D'
      |? TKTL.STAN='T' & _torw='T' & exec('can_modify','tech_common')
      || _hide:=':'
      |? TKTL.STAT_O='T' | TKTL.STAT_N='N' & TKTL.TORW<>'Z'
      || _hide:='DPUF(ZR):D'
      || _hide:=':'
      ?}
   ?};
   {? TKTL.STAT_O='T' | TKTL.STAT_N='N' & TKTL.TORW<>'Z' | TKTL.ARCH='T' | _used
   || _hide:='Z'+_hide+'Z'
   ?};
   {? _dia.dot_cmd='' || _hide:='F(D)'+_hide ?};
   {? (TKTL.STAT_O='T' | _used | TKTL.ARCH='T' | TKTL.STAT_N='N' & TKTL.TORW<>'Z')
   || _hide:='F(N)'+_hide
   ?};
   {? (TKTL.STAT_O='T' | TKTL.TORW='W' | _used | TKTL.ARCH='T' | TKTL.STAT_N='N' & TKTL.TORW<>'Z')
   || _hide:='F(WE)'+_hide+'F(WE)'
   ?};
::   {? TKTL.TYP().SUR='K' || _hide:='E(S)'+_hide ?};
   {? TKTL.TYP().UTIL='N' || _hide:='E(N)'+_hide ?};
   {? ~(TKTL.STAN='T' & TKTL.ARCH='N' & ~_used) || _hide:='Ó'+_hide ?};
   {? TKTL.TORW='W' || _hide:='F(U)'+_hide ?};
   {? TKTL.TORW='W' | TKTL.TORW='T' || _hide:='F(Z)'+_hide ?};

:: Ukrycie akcji wynikające z uprawnień do czynności
   {? ~(exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRTO') & _torw='T' |
        exec('chk_role','#b__box',OPERATOR.USER,'TTE_WTE_DRTO') & _torw='W' |
        exec('chk_role','#b__box',OPERATOR.USER,'TTE_PZL_DTEC') & _torw='Z')
   || _hide:='DPUÓZF(NWER)'+_hide+'DZF(WE)'
   ?};

   TWRKZBR.actions('WER','H');

   PFAZ.clear();
   PFAZ.f_set('KOD', '',
                'PFAZ.WYD='':_a'' or '':_a''=''''',
               $TKTL.JORG);
   FILTER.PFAZ:=0;

   _debug:=0;
   {? _zakl=1
   || TREE:=obj_new(@.CLASS.TREEVIEW,_hide,_debug,'tree_oper'+(-TKTL.STAT_O)+$_zakl+$_used);
      TREE.SZEROK:=77;
      Objt:=TREE
   |? _zakl=4
   || STREE:=obj_new(@.CLASS.TREEVIEW,_hide,_debug,'tree_oper'+(-TKTL.STAT_O)+$_zakl+$_used);
      STREE.SZEROK:=77;
      Objt:=STREE
   |? _zakl=5
   || NTREE:=obj_new(@.CLASS.TREEVIEW,_hide,_debug,'tree_oper'+(-TKTL.STAT_O)+$_zakl+$_used);
      NTREE.SZEROK:=77;
      Objt:=NTREE
   |? _zakl=6
   || TTREE:=obj_new(@.CLASS.TREEVIEW,_hide,_debug,'tree_oper'+(-TKTL.STAT_O)+$_zakl+$_used);
      TTREE.SZEROK:=105;
      Objt:=TTREE
   |? _zakl=7
   || SELTREE:=obj_new(@.CLASS.TREEVIEW,_hide,_debug,'tree_oper'+(-TKTL.STAT_O)+$_zakl+$_used);
      SELTREE.SZEROK:=105;
      Objt:=SELTREE
   ?}
|? _zakl=0
||
   VAR_DEL.delete('TTREE','Objt');
   _hide:='';
   _debug:=0;
   TTREE:=obj_new(@.CLASS.TREEVIEW,_hide,_debug);
   Objt:=TTREE
|? _zakl=3
||
   VAR_DEL.delete('ZTREE','Objt');
   _hide:='';
   _debug:=0;
   ZTREE:=obj_new(@.CLASS.TREEVIEW,_hide,_debug);
   Objt:=ZTREE
|? _zakl=2
||
   VAR_DEL.delete('XTTREE','Objt');
   _hide:='DPUZF(NZWE):D';
   _debug:=0;
   XTTREE:=obj_new(@.CLASS.TREEVIEW,_hide,_debug);
   Objt:=XTTREE
?};
_timedok:=exec('get','#params',500604,1);
Objt.fld('NTIME','REAL','Norma czasowa'@,14,_timedok,0,1);
Objt.fld_fml('NTIME','DISPLAY_FORMAT','{? fld()=0 || \'empty=1\' || \'empty=0\' ?}');
Objt.fld('MTIME','REAL','Czas maszynowy'@,14,_timedok,0,1);
Objt.fld_fml('MTIME','DISPLAY_FORMAT','{? fld()=0 || \'empty=1\' || \'empty=0\' ?}');
Objt.fld('CENA','REAL','Kooperacja'@,10,2,0,1,'Wartość usług kooperacyjnych'@);
Objt.fld_fml('CENA','DISPLAY_FORMAT','{? fld()=0 || \'empty=1\' || \'empty=0\' ?}');
Objt.fld('WEW','STRING[1]','Wewnętrzna/kooperacja'@,2,0,1,0,'Operacja wewnętrzna/kooperacja'@);
Objt.fld('PZ','STRING[1]','Prosta/złożona'@,2,0,1,0,'Operacja prosta/złożona'@);
Objt.fld('PLACE','STRING[10]','Stanowisko'@,10,0,1,0,'Symbol stanowiska'@);
Objt.fld('PLACE_N','STRING[60]','Nazwa stanowiska'@,10,0,1,0);
Objt.fld('GRUPA','STRING[20]','Gniazdo'@,10,0,1,0);
Objt.fld('GRUPA_N','STRING[40]','Nazwa gniazda'@,10,0,1,0);
Objt.fld('OPER','STRING[10]','Operacja'@,10,0,1,0,'Kod operacji'@);
Objt.fld('OPER_N','STRING[50]','Nazwa operacji'@,10,0,1,0);
Objt.fld('ZAWOD','STRING[7]','Zawód'@,7,0,1,0);
Objt.fld('ZAWOD_N','STRING[30]','Opis zawodu'@,10,0,1,0);
Objt.fld('TPZ','STRING[1]','TPZ'@,2,0,1,0);
Objt.fld('TPZ_TIME','REAL','Czas TPZ'@,14,_timedok,1,1);
Objt.fld_fml('TPZ_TIME','DISPLAY_FORMAT','{? fld()=0 || \'empty=1\' || \'empty=0\' ?}');
Objt.fld('TPZ_ZAW','STRING[7]','Zawód TPZ'@,7,0,1,0);
Objt.fld('TPZ_ZAWN','STRING[30]','Opis zawodu TPZ'@,10,0,1,0);
Objt.fld('PFAZ','STRING[10]','Faza prod.'@,10,0,1,0);
Objt.fld('WYD','STRING[8]','Wydział'@,8,0,1,0);
Objt.fld('DOK','STRING[8]','Dokument'@,8,0,1,0);
Objt.fld('NAST','STRING[255]','Następne'@,20,0,1,0);
Objt.fld('ETAP','STRING[60]','Powiązany etap w planie strategicznym'@,20,0,1,0);
Objt.fld('DAYS_K','INTEGER','Szacunkowa ilość dni na kooperację'@,5,0,1,0);
Objt.fld('PX_KONT','STRING[60]','Zasób kooperacyjny'@,20,0,1,0);
Objt.fld('KONTRAH','STRING[8]','Kooperant'@,8,0,1,0);
Objt.fld('PL_GRP','STRING[1]','Grupowe planowanie'@,2,0,1,0);
Objt.fld('KONTROLA','STRING[1]','Operacja typu kontrola jakości'@,2,0,1,0);
Objt.fld('KJ_BAD','STRING[1]','Kontrola jakości - badania'@,2,0,1,0);
Objt.fld('OPIS','STRING[255]','Opis'@,20,0,1,0);
Objt.fld('FIX_NORM','STRING[1]','Stała norma czasowa'@,2,0,1,0);

{? _zakl=4 | _zakl=5 | _zakl=6 | _zakl=7
||
:: Dla okna do redagowania surowców albo NPU - zawsze bez bocznego panela
   ~~
|? ((TKTL.TORW='T' & exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRTO')) |
    (TKTL.TORW='W' & exec('chk_role','#b__box',OPERATOR.USER,'TTE_WTE_DRTO')) |
    (TKTL.TORW='Z' & exec('chk_role','#b__box',OPERATOR.USER,'TTE_PZL_DTEC'))
   )
      &
   TKTL.STAT_O='N' & (TKTL.STAT_N='T' | TKTL.TORW='Z') & TKTL.ARCH='N' & _zakl<>2
||
:: Możliwość wyłączenia dołączania z innych tabel
   _dnd:=~_used;
   {? _dnd;0
   ||
      _ttoper_wer:=TTOPER.mk_sel('Taryfikator operacji'@,'P',0,'ttoper_wer');
      TTOPER.win_fld(_ttoper_wer,,'KOD',,,10,,,'Kod'@);
      TTOPER.win_fld(_ttoper_wer,,'NA',,,20,,,'Nazwa operacji'@);
      TTOPER.win_act(_ttoper_wer,,'Kolejność');
      Objt.add_tab(!TTOPER,_ttoper_wer,,,,,11,,,0,'right','right1','maximized_with_title');

      _ttout_wer:=TTOUT.mk_sel('Taryfikator usług (w kooperacji)'@,'P',0,'ttout_wer');
      TTOUT.win_fld(_ttout_wer,,'KOD',,,10,,,'Kod'@);
      TTOUT.win_fld(_ttout_wer,,'NA',,,20,,,'Nazwa'@);
      TTOUT.win_act(_ttout_wer,,'Kolejność');
      Objt.add_tab(!TTOUT,_ttout_wer,,,,,11,,,0,'right1','right2','maximized_with_title');

      VAR_DEL.delete('__Fun');
      __Fun:=tab_tmp(1,'NAZ','STRING[30]','Nazwa');
      __Fun.NAZ:='1. <- '+'wstaw operację złożoną'@; __Fun.add();
::      __Fun.NAZ:='2. -> '+'usuń operację'@; __Fun.add();
      __Fun.first();
      _fun_wer:=__Fun.mk_sel('Funkcje dostępu'@,,0,'fun_wer_t');
      __Fun.dnd_sel(_fun_wer,,'records.#tree_wert',"
         FUN.info('Rekordy z: %1\nupuszczam na rekord: %2'@[dnd_info('table_name'),$dnd_info('dest_record')])
      ");
      __Fun.win_fld(_fun_wer,,'NAZ',,,31,,,'Nazwa'@);
      Objt.add_tab(!__Fun,_fun_wer,,,,,1,,,0,'right2',,'maximized_with_title')
   ?}
||
   {? _dia.dot_cmd<>'' || Objt.add_dia(TKTL,'DIAGRAM') ?}
?};

{? _zakl=2 | _zakl=6 | _zakl=7
|| ~~
|| Objt.add_tab(!NASTOPER,'SLOPOP',,,,0,3,'
      NASTOPER.index(''NASTOP'');
      NASTOPER.prefix(''T'',VAR.A_OP);
      NASTOPER.first();
      ~~','
      ~~',,'bottom','bottom1','maximized_with_title')
?};

{? _zakl=2 | _zakl=6 | _zakl=7
|| ~~
|| Objt.add_tab(!NASTOPER,{? _zakl=4 | _zakl=5 || 'SLO' || 'WER_'+_torw ?},,,,0,3,'
      NASTOPER.index(''OPNAST'');
      NASTOPER.prefix(''T'',VAR.A_OP);
      NASTOPER.first();
      {? VAR.A_OP=null() || NASTOPER.actions(''WER_'+_torw+''',''DPUG:DG'','''',1) ?};
      ~~','
      ~~',,'bottom1',,'maximized_with_title')
?};

set_virt(Objt,'f_record',$("
   _torw:='"+_torw+"';
   _used:=params_get().env_oper.used;
   _wer:='WER_'+_torw;
   TOPER.clear();
   {? TOPER.seek(cur_tab(1,1).REF,)
   || VAR.A_OP:=TOPER.ref();
      _res:=Color.rekprzed('TOPER#01#01');
      VAR.A_KTL();
::    Akcje dla NASTOPER
      _keys:=':'; _default:='D:D';
      {? TKTL.ARCH='T'
            |
         _used
            |
         _torw='Z' & TKTL.PLRELWYR<>null()
            |
         _torw='T' & VAR.A_ZLEC<>null()
            |
         TKTL.STAN='T' & _torw='T' & ~exec('can_modify','tech_common') & TOPER.ACT='T'
            |
         TKTL.STAN='T' & _torw='W'
            |
         TKTL.STAN='T' & _torw='Z'
      || _keys:='DPUG'+_keys+'DG'
      ?};
      {? TOPER.PZ='Z' || _keys:='D'+_keys+'D' ?};
      NASTOPER.actions(_wer,_keys,_default,1);
::    Akcje dla "TOPER" - wyszarzone w zależności od rekordu
      _keys:=':';
      {? TOPER.ACT='T' || _keys:='Ó'+_keys || {? .TAB.sel_size()>0 || _keys:='U'+_keys ||  _keys:='UPF(R)'+_keys ?} ?};
      {? TOPER.PZ='Z' || _keys:='BE(ZSN)F(R)'+_keys ?};
      {? TOPER.WEW='N' || _keys:='E(ZN)'+_keys ?};
      .TAB.actions_grayed(.WERT,_keys)
   || VAR.A_OP:=null();
      _res:=~~;
      NASTOPER.actions(_wer,'DPU:D','',1)
   ?};
   TKTL.index('NRK');
   TKTL.prefix(VAR.A_KTL().TORW,TKTL.NRK,TKTL.WER);
   TOPER.index('NNN');
   TOPER.prefix(TOPER.NRK,TOPER.NRNOP,'N');
   _res
"));

set_virt(Objt,'f_legend',"
   exec('legenda','tech_oper')
");

{? _zakl=0 | _zakl=3 | _zakl=6
|| set_virt(Objt,'title',"''")
|? _zakl=4
|| set_virt(Objt,'title',"
      'Operacje: %1 wersja: %2'@[TKTL.NRK,TKTL.WER]+
      {? .USED
      || ' — '+'PODGLĄD SUROWCÓW'@
      |? TKTL.ARCH='T'
      || ' — '+'ARCHIWALNE'@+' — '+'PODGLĄD SUROWCÓW'@
      |? TKTL.STAT_O='T'
      || ' — '+'ZATWIERDZONE'@+' — '+'REDAGOWANIE SUROWCÓW'@
      || ' — '+'REDAGOWANIE SUROWCÓW'@
      ?}
   ")
|? _zakl=5
|| set_virt(Objt,'title',"
      'Operacje: %1 wersja: %2'@[TKTL.NRK,TKTL.WER]+
      {? .USED
      || ' — '+'PODGLĄD N-P-U'@
      |? TKTL.ARCH='T'
      || ' — '+'ARCHIWALNE'@+' — '+'PODGLĄD N-P-U'@
      |? TKTL.STAT_O='T'
      || ' — '+'ZATWIERDZONE'@+' — '+'REDAGOWANIE N-P-U'@
      || ' — '+'REDAGOWANIE N-P-U'@
      ?}
   ")
|? _zakl=7
|| set_virt(Objt,'title',"
      'Operacje: %1 wersja: %2'@[TKTL.NRK,TKTL.WER]
   ")
|| set_virt(Objt,'title',"
      'Operacje: %1 wersja: %2'@[TKTL.NRK,TKTL.WER]+
      {? .USED
      || ' — '+'PODGLĄD'@
      |? TKTL.ARCH='T'
      || ' — '+'ARCHIWALNE'@
      |? TKTL.STAT_O='T'
      || ' — '+'ZATWIERDZONE'@
      || ''
      ?}
   ")
?};

set_virt(Objt,'hdr_1st',"
   'Operacja'
");

set_virt(Objt,'f_add',"
::----------------------------------------------------------------------------------------------------------------------
:: WE: _a - sposób dodawania operacji; 0: normalnie, 1: pusta dziedzina, 2: d'n'd
::     _b - PARAMETR NIEUŻYWANY
::     [_c] - jezeli _a=2, tabela źródłowa
::     [_d] - jezeli _a=2, ref zaznaczonego rekordu
::     [_e] - jezeli _a=2, ref rekordu na który zrzucamy
::----------------------------------------------------------------------------------------------------------------------
   params_set(params_get());

   {? _<1 || _a:=0 ?};
   VAR.KOR:=TKTL.STAT_O='T';

   {? _a=2
   || {? Objt.TAB.seek(_e)
      || Objt.f_record()
      || TOPER.blank(1)
      ?}
   ?};

   VAR.A_WYD:=TKTL.JORG;
   {? VAR.GRP_MOD='' ||  VAR.GRP_MOD:='N' ?};
   exec('toper_be','tech_oper');
   _bryg:='N';
   {? TOPER.PZ='Z' & (_a=0 | _a=2)
   || _ask:=choice('Dodawana operacja jest:'@,FUN.TYT,'ASK',1,0,,
         'Kolejna na tym poziomie'@,
         'Podrzędna do bieżącej'@,
         'Anuluj'@);
      {? _ask=2
      || return(0)
      |? _ask=1
      || {? TOPER.ACT='T'
         || _nrnop:=TOPER.UNROP;
            _bryg:=TOPER.BRYG;
            .expand(2)
         || FUN.info('Bieżąca operacja złożona jest nieaktywna — nie można do niej dodawać składowych.'@);
            return(0)
         ?}
      |? _ask=0
      || _nrnop:=TOPER.NRNOP
      ?}
   || _nrnop:=TOPER.NRNOP
   ?};

   VAR.A_UNROP:=_nrnop;

   {? _a=2
   || {? _c=TTOPER
      || _wariant:=0
      |? _c=TOPER
      || _wariant:=1
      |? _c=TTOUT
      || _wariant:=2
      ?}
   || _wariant:=3
   ?};

   {? VAR.KOR
   || TTXCAUSE.win_sel('WER');
      TTXCAUSE.actions('WER','T','d:d')
   ?};

   {? exec('toperp_d','tech_oper',_wariant)
   || _nrk:=TKTL.ref();
      TOPER.index('NNN');
      TOPER.prefix(_nrk,_nrnop,'N');
      TOPER.blank();
      {? _wariant=0
      || TOPER.OPER:=_d;
         exec('ae_ttoper','tech_oper',1)
      |? _wariant=2
      || TOPER.TTOUT:=_d;
         exec('ttout_ae','tech_oper',1)
      ?};
      TOPER.BRYG:=_bryg;
      TOPER.NRNOP:=_nrnop;
      TOPER.NRK:=_nrk;
      {? VAR.KOR
      || TOPER.OD:=date();
         TOPER.CRE_TIME:=TOPER.tm_stamp();
         TOPER.USER:=OPERATOR.USER;
         TOPER.CAUSE:=exec('ttxcause_default','tech_common')
      ?};
      {? TOPER.TTOUT<>null
      || TOPER.SRW:=TOPER.TTOUT().SRW
      ?};
      exec('efld_opt','tech_oper',TOPER);
      {? TOPER.memo_set('','OPISMEMO') & TOPER.edit(\"exec('topearec','tech_oper')\")
      || TOPER.clear();
         {? TOPER.add()
         || TOPER.memo_put(,'OPISMEMO');

            {? VAR.KOR
            || NASTOPER.index('OPER');
               NASTOPER.prefix('T',TOPER.NRK);
               {? NASTOPER.first()
               || {? FUN.choice('Należy zmodyfikować strukturę operacji.\nStrukturę można wygenerować automatycznie.'@,,
                                'Generuj'@)
                  || exec('er_tab','tech_oper',VAR.A_KTL);
                     exec('gen_pow','tech_oper',VAR.A_KTL);
                     exec('po_nast','tech_oper')
                  ?}
               || exec('er_tab','tech_oper',VAR.A_KTL);
                  exec('gen_pow','tech_oper',VAR.A_KTL);
                  exec('po_nast','tech_oper')
               ?}
            ?}
         ?};
         exec('toperd_a','tech_oper');
         _ref:=TOPER.ref();
         .TAB.cntx_psh();
         exec('level','tech_oper',.,0);
         .replica();
         .load();
         .update();
         .TAB.clear();
         {? .TAB.first()
         || {!
            |?
               .TAB1.blank();
               .TAB1.REF:=.TAB.REF;
               {? .TAB1.find_rec()
               || .TAB.HIDDEN:=.TAB1.HIDDEN;
                  .TAB.EXPANDED:=.TAB1.EXPANDED;
                  .tab_txt();
                  .TAB.put()
               ?};
               .TAB.next()
            !}
         ?};
         .TAB.cntx_pop();
         .TAB.blank();
         .TAB.REF:=_ref;
         .TAB.find_rec()
      ?}
   ?};
   VAR.KOR:=0;
   ~~
");

set_virt(Objt,'f_add_e',"
   .f_add(1)
");

set_virt(Objt,'f_delete',"
   params_set(params_get());
   {? TKTL.STAT_O='N'
   || .f_record();
      _ref:=TOPER.ref();
      TOPER.cntx_psh();
      TOPER.index('NNN');
      TOPER.prefix(TOPER.NRK,TOPER.NRNOP);
      {? TOPER.next()
      || _ref1:=#TOPER.ref()
      || {? TOPER.prev()
         || _ref1:=#TOPER.ref()
         || _ref1:=0
         ?}
      ?};
      TOPER.cntx_pop();
      exec('TOPER_TREE_kasuj','tech_oper');
      {? ~TOPER.seek(_ref)
      || .delete(.TAB.NODE);
         .update();
         .TAB.blank();
         .TAB.REF:=_ref1;
         .TAB.find_rec()
      ?}
   || .f_record();
      exec('zm_usun','tech_oper',1)
   ?};
   ~~
");

set_virt(Objt,'f_del_bg',"
   sel_nchk();
   {? TKTL.STAN='T'
   || FUN.info('Na zaakceptowanej karcie usuwać (dezaktywować) można tylko pojedyncze pozycje.'@);
      0
   |? FUN.ask('Ilość zaznaczonych operacji: %1. Czy usuwać?'@[form(.TAB.sel_size())])
   || VAR.GRUPA:='T';
      KOMM.init(,,'Usuwanie operacji'@,'');
      1
   || 0
   ?}
");

set_virt(Objt,'f_del_ag',"
   VAR.GRUPA:='N';
   KOMM.select();
   ~~
");

set_virt(Objt,'f_modify',"
   params_exec('toper_modify','tech_oper',,.)
");

set_virt(Objt,'f_displ',"
   exec('prep_ch','tech_oper');
   exec('efld_opt','tech_oper',TOPER);
   TOPER.display();
   ~~
");

{? _zakl<>4 & _zakl<>5 & _zakl<>7
|| set_virt(Objt,'chk_sel',"
      {? params_get().env_oper.used
      || 1
      || _torw:=VAR.A_KTL().TORW;
         _stan:=TKTL.STAN;
         {? (exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRTO') & _torw='T' |
             exec('chk_role','#b__box',OPERATOR.USER,'TTE_WTE_DRTO') & _torw='W')
         || exec('valid_op','tech_oper',VAR.A_KTL,0,0)
             &
            (_torw='W' | _stan<>'T' | exec('spr_pdok','magdok_prod','TOPER','DOK',VAR.A_KTL,'',1,1,1))
         || 1
         ?}
      ?}
   ")
?};

set_virt(Objt,'win_fml',"
  \"{? cur_tab(1,1).WEW='N'
    || 'xwin16.png:90'
    |? cur_tab(1,1).PZ='Z'
    || {? cur_tab(1,1).tr_state=0
       || 'xwin16.png:32'
       || 'xwin16.png:32'
       ?}
    |? cur_tab(1,1).PZ='P'
    || {? cur_tab(1,1).KJ_BAD='B'
       || 'xwin16.png:93'
       |? cur_tab(1,1).KJ_BAD='P'
       || 'xwin16.png:94'
       |? cur_tab(1,1).KONTROLA='T'
       || 'xwin16.png:95'
       || 'xwin16.png:33'
       ?}
    || ''
    ?}\"
");

:: Takie czary, żeby zadziałały tłumaczenia akcji poniżej (teksty MUSZĄ być identyczne)
'Przywróć&'@;
'D&efinicje'@;'Zamienniki'@;'Surowce'@;'Wszystkie surowce'@;'N-P-U'@;'Atrybuty operacji'@;'Dokumentacja'@;
'Operacje'@;'Generuj'@;
'Zakończ'@;
'Funkcje'@;'Diagram'@;'Numeruj'@;'Zamień'@;'Utwórz wzorzec'@;'Wstaw wzorzec'@;'Zmian&y'@;

set_virt(Objt,'f_akcje',"
:: Przywróć
   _akcja:=$(\"
      params_set(params_get());
      {? TKTL.STAT_O='T'
      || \"+!Objt+\".f_record();
         exec('zm_usun','tech_oper',3)
      ?};
      ~~
   \");
   .TAB.win_act(.WERT,,'Formuła','Przywróć&'@@,,,_akcja,,,1,,,'Ó');

:: Operacje
   {? .ZAKL=3
   || _akcja:=\"
         params_set(params_get());
         _env:=params_get().env;
         _used:=params_get().env_oper.used;

         {? _env.TKTL_ZL=null()
         || FUN.info('Brak technologii zlecenia.'@)
         || VAR.OPER:=exec('FindAndGet','#table',TKTL,_env.TKTL_ZL,,\"\"TYP().OPER\"\",'');
            {? VAR.OPER='T'
            || params_exec('tree','tech_oper',,~_used);
               ZTREE.reload()
            || FUN.info('Typ karty bez operacji technologicznych.'@)
            ?}
         ?}
      \";
      .TAB.win_act(.WERT,0,'Formuła','Operacje'@@,,,_akcja,,,,,,'O');
      .TAB.win_act(.WERT,1,'Formuła','Operacje'@@,,,_akcja,,,,,,'O')
   |? .ZAKL=0
   || _akcja:=\"
         params_set(params_get());
         _env:=params_get().env;

         _stan:=exec('FindAndGet','#table',ZL,_env.ZL,,\"\"STAN\"\",'');
         TKTL.cntx_psh();
         TKTL.prefix();
         {? TKTL.seek(_env.TKTL_SRC)
         ||
            VAR.OPER:=TKTL.TYP().OPER;
            {? VAR.OPER='T'
            || params_exec('tree','tech_oper',,0)
            || FUN.info('Typ karty bez operacji technologicznych.'@)
            ?}
         ?};
         TKTL.cntx_pop()
      \";
      .TAB.win_act(.WERT,0,'Formuła','Operacje'@@,,,_akcja,,,,,,'O');
      .TAB.win_act(.WERT,1,'Formuła','Operacje'@@,,,_akcja,,,,,,'O')
   ?};

:: Generuj
   {? .ZAKL=3
   || _akcja:=\"
         params_set(params_get());
         _env:=params_get().env;

         ZL.cntx_psh();
         ZL.prefix();
         {? ZL.seek(_env.ZL)
         ||
            _wp:=ZL.TYP().WP;
            _tech:=ZL.TYP().TECH;

            _wynik:={? _wp='P' & _tech='T'
                    || {? ZL.RODZAJ<>'P'
                       || 0
                       || 1
                       ?}
                    || 0
                    ?} & {? ZL.STAN<>'N' || ZL.KTLZ<>null() || 1 ?};
            {? _wynik=1
            || {? exec('action_gen','zl_view')
               || _env.TKTL_ZL:=VAR.A_KTL;
                  exec('start_tpar','tech_param',ZL.KTM,_env.TKTL_ZL);
                  ZTREE.reload()
               ?}
            || FUN.info('Funkcja niedostępna.'@)
            ?}
         ?};
         ZL.cntx_pop();
         ZTREE.ZRODLO:='';
         grp_disp(ZTREE.TAB,ZTREE.WERT,,1)
      \";
      .TAB.win_act(.WERT,1,'Formuła','Generuj'@@,,,_akcja,,,,,,'G')
   ?};

:: Definicje
   .TAB.win_act(.WERT,,'Menu','D&efinicje'@@,,,,,,,,,'E');

   _akcja:=\"params_exec('tech_zam','tech_oper')\";
   .TAB.win_act(.WERT,0,'Formuła','Zamienniki'@@,'#E','Selekcja zamienników stanowiska przypisanego do operacji',_akcja,,,,,,'Z');

   .TAB.win_act(.WERT,,'Formuła','--Y','#E');

   _akcja:=\"params_exec('action_oper','tech_mater',params_get().env_oper.used,params_get().env_oper.zakl)\";
   .TAB.win_act(.WERT,,'Formuła','Surowce'@@,'#E',,_akcja,,,,,,'S');

   {? .ZAKL=4
   || _akcja:=\"params_exec('action_all_mater','tech_mater')\";
      .TAB.win_act(.WERT,,'Formuła','Wszystkie surowce'@@,'#E',,_akcja,,,,,,'W')
   ?};

   _akcja:=\"exec('action_tools','tech_tool',0,'',params_get().env_oper.used)\";
   .TAB.win_act(.WERT,,'Formuła','N-P-U'@@,'#E',,_akcja,,,,,,'N');

   .TAB.win_act(.WERT,,'Formuła','--X','#E');

   _akcja:=\"params_exec('TOPER','tech_atr')\";
   .TAB.win_act(.WERT,,'Formuła','Atrybuty operacji'@@,'#E',,_akcja,,,,,,'A');

   _akcja:=\"params_exec('TOPER','tech_doc')\";
   .TAB.win_act(.WERT,,'Formuła','Dokumentacja'@@,'#E',,_akcja,,,,,,'D');

   _akcja:=\"exec('toper_dalej','tech_oper')\";
   {? TKTL.TORW<>'Z'
   || .TAB.win_act(.WERT,0,'Formuła','Zakończ'@@,,,_akcja,,,,,,'Z')
   ?};
   {? TKTL.TORW='W'
   || .TAB.win_act(.WERT,1,'Formuła','Zakończ'@@,,,_akcja,,,,,,'Z')
   ?};

:: Funkcje
   .TAB.win_act(.WERT,0,'Menu','Funkcje'@,,,,,,,,,'F');
   .TAB.win_act(.WERT,1,'Menu','Funkcje'@,,,,,,,,,'F');

   _akcja:=\"exec('graph_oper','tech_oper')\";
   .TAB.win_act(.WERT,0,'Formuła','Diagram'@@,'#F',,_akcja,,,,,,'D');

   _akcja:=$(\"{? ~exec('topernum','tech_oper') || \"+!Objt+\".reload() ?}\");
   .TAB.win_act(.WERT,0,'Formuła','Numeruj'@@,'#F','Przenumerowanie operacji'@,_akcja,,,,,,'N');

   _akcja:=$(\"exec('placechg','tech_oper'); \"+!Objt+\".reload()\");
   .TAB.win_act(.WERT,0,'Formuła','Zamień'@@,'#F','Użycie zamiennika stanowiska operacji'@,_akcja,,,,,,'Z');

   _akcja:=$(\"{? exec('toper_wew_change','tech_oper',,\"+!Objt+\") || \"+!Objt+\".reload() ?}\");
   .TAB.win_act(.WERT,0,'Formuła','Zmiana &rodzaju operacji'@@,'#F','Zmiana rodzaju operacji - wewnętrzna/zewnętrzna'@
      ,_akcja,,,,,,'R');

   .TAB.win_act(.WERT,,'Formuła','--X','#F');

   {? exec('chk_role','#b__box',OPERATOR.USER,'TTE_WTE_DRTE')
   || _akcja:=\"exec('action_pattern_4oper','tech_oper')\";
      .TAB.win_act(.WERT,0,'Formuła','Utwórz wzorzec'@@,'#F','Tworzenie wzorca operacji'@,_akcja,,,,,,'U')
   ?};

   _akcja:=$(\"{? ~exec('insert_tbox_o','tech_arch') || \"+!Objt+\".reload() ?}\");
   .TAB.win_act(.WERT,0,'Formuła','Wstaw wzorzec'@@,'#F','Wstawianie wzorca operacji'@,_akcja,,,,,,'W');
   .TAB.win_act(.WERT,1,'Formuła','Wstaw wzorzec'@@,'#F','Wstawianie wzorca operacji'@,_akcja,,,,,,'W');

   _akcja:=$(\"{? ~exec('insert_from_tktl','tech_arch',0) || \"+!Objt+\".reload() ?}\");
   .TAB.win_act(.WERT,0,'Formuła','Wstaw z t&echnologii'@@,'#F','Kopiuje operacje z innej technologii'@
      ,_akcja,,,,,,'E');
   .TAB.win_act(.WERT,1,'Formuła','Wstaw z t&echnologii'@@,'#F','Kopiuje operacje z innej technologii'@
      ,_akcja,,,,,,'E');

   .TAB.win_act(.WERT,,'Formuła','--Ć','#F');

   _akcja:=\"exec('zmiany','#syslog',TOPER)\";
   .TAB.win_act(.WERT,0,'Formuła','Zmian&y'@@,'#F','Historia modyfikacji'@,_akcja,,,,,,'Y');

   _akcja:=\"
      TOPER.cntx_psh();
      TOPER.index('TPZ');
      TOPER.prefix('T',TOPER.UNROP);
      {? TOPER.first()
      || exec('zmiany','#syslog',TOPER)
      || FUN.info('Brak operacji Tpz.'@)
      ?};
      TOPER.cntx_pop()
   \";
   .TAB.win_act(.WERT,0,'Formuła','Zmiany &Tpz'@@,'#F','Historia modyfikacji'@,_akcja,,,,,,'T');
   ~~
");

:: Takie czary, żeby zadziałały tłumaczenia przycisków poniżej (teksty MUSZĄ być identyczne)
'N-P-U'@;'Surowce'@;'Wszystkie surowce'@;'Operacje'@;'Generuj'@;
'Zam&ienniki'@;'Atrybuty'@;'Doku&mentacja'@;'Dia&gram'@;'Zakończ'@;

set_virt(Objt,'f_buttons',"
:: Okno dla NPU do operacji
   {? .ZAKL=5
   || .BTN:=obj_new('NPU');

      _btn:=.TAB.win_btn(.WERT,'text=%1,panel=right,align=begin'['N-P-U'@],'menu:EN',,,,,,'noempty');
      .TAB.btn_sopt(.WERT,_btn,'tooltip='+'Narzędzia/Przyrządy/Urządzenia - do wykonania operacji'@);
      .BTN.NPU:=_btn

:: Okno dla surowców do operacji
   |? .ZAKL=4
   || .BTN:=obj_new('SUROWCE','SUROWCE_ALL');

      _btn:=.TAB.win_btn(.WERT,'text=%1,panel=right,align=begin'['Surowce'@],'menu:ES',,,,,,'noempty');
      .TAB.btn_sopt(.WERT,_btn,'tooltip='+'Surowce potrzebne do wykonania operacji'@);
      .TAB.btn_sopt(.WERT,_btn,'default=1');
      .BTN.SUROWCE:=_btn;

      _btn:=.TAB.win_btn(.WERT,'text=%1,panel=bottom,align=begin'['Wszystkie surowce'@],'menu:EW',,,,,,'noempty');
      .TAB.btn_sopt(.WERT,_btn,'tooltip='+'Surowce potrzebne do wykonania produktu'@);
      .BTN.SUROWCE_ALL:=_btn

:: Okno dla technologii zlecenia (zakładka w widoku zleceń)
   |? .ZAKL=3
   || .BTN:=obj_new('OPERACJE','GENERUJ');

      .BTN.OPERACJE:=.TAB.win_btn(.WERT,'text='+'Operacje'@,'menu:O',,,,,,'');
      .TAB.btn_opt(.BTN.OPERACJE,'tooltip='+'Panel operacji dla zlecenia'@);

      .BTN.GENERUJ:=.TAB.win_btn(.WERT,'text='+'Generuj'@,'menu:G',,,,,,'empty');
      .TAB.btn_opt(.BTN.GENERUJ,'tooltip='+'Wygenerowanie technologii zlecenia'@)

:: Okno dla operacji karty technologicznej/ technologii zlecenia
   |? .ZAKL=1
   || .BTN:=obj_new('TECH_ZAM','SUROWCE','NPU','ATRYBUTY','DOK','DIAGRAM','DALEJ');

      _btn:=.TAB.win_btn(.WERT,'text=%1,panel=right,align=begin'['Zam&ienniki'@],'menu:EZ',,,,,,'noempty');
      .TAB.btn_sopt(.WERT,_btn,'tooltip='+'Selekcja zamienników stanowiska przypisanego do operacji'@);
      .BTN.TECH_ZAM:=_btn;

      _btn:=.TAB.win_btn(.WERT,'text=%1,panel=right,align=begin'['Surowce'@],'menu:ES',,,,,,'noempty');
      .TAB.btn_sopt(.WERT,_btn,'tooltip='+'Surowce potrzebne do wykonania operacji'@);
      .BTN.SUROWCE:=_btn;

      _btn:=.TAB.win_btn(.WERT,'text=%1,panel=right,align=begin'['N-P-U'@],'menu:EN',,,,,,'noempty');
      .TAB.btn_sopt(.WERT,_btn,'tooltip='+'Narzędzia/Przyrządy/Urządzenia - do wykonania operacji'@);
      .BTN.NPU:=_btn;

      _name:='text=%1,panel=right,align=begin'['Atrybuty'@];
      _btn:=.TAB.win_btn(.WERT,_name,'menu:EA',,,,,,'noempty');
      .TAB.btn_sopt(.WERT,_btn,'tooltip='+'Dodatkowe dane dotyczące operacji'@);
      .BTN.ATRYBUTY:=_btn;

      _name:='text=%1,panel=right,align=begin'['Doku&mentacja'@];
      _btn:=.TAB.win_btn(.WERT,_name,'menu:ED',,,,,,'noempty');
      .TAB.btn_sopt(.WERT,_btn,'tooltip='+'Dokumentacja elektroniczna przechowywana w bazie'@);
      .BTN.DOK:=_btn;

      _name:='text=%1,panel=bottom,align=begin'['Dia&gram'@];
      _btn:=.TAB.win_btn(.WERT,_name,'menu:FD',,,,,,'noempty');
      .BTN.DIAGRAM:=_btn;

      _name:='text=%1,panel=bottom,align=end'['Zakończ'@];
      _btn:=.TAB.win_btn(.WERT,_name,'menu:Z');
      .TAB.btn_sopt(.WERT,_btn,'tooltip='+'Zakończenie rejestracji operacji'@);
      .BTN.DALEJ:=_btn

:: Okno dla technologii wzorcowej (zakładka w widoku zleceń)
   |? .ZAKL=0
   || .BTN:=obj_new('OPERACJE');

      _btn:=TTREE.TAB.win_btn(TTREE.WERT,'text='+'Operacje'@,'menu:O',,,,,,'noempty');
      .TAB.btn_opt(_btn,'tooltip='+'Panel operacji dla zlecenia'@);
      .BTN.OPERACJE:=_btn

   ?};
   ~~
");

set_virt(Objt,'load',"
  .TAB.erase();
  exec('next_lev','tech_oper',.,0,0);
  ~~
");

Objt.USED:=_used;
Objt.ZAKL:=_zakl;
Objt.init();
Objt.update();

:: Renumeracja i dołączanie rekordów za pomocą d'n'd
_dnd:=~_used;
{? ~(exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRTO') & _torw='T' |
     exec('chk_role','#b__box',OPERATOR.USER,'TTE_WTE_DRTO') & _torw='W' |
     exec('chk_role','#b__box',OPERATOR.USER,'TTE_PZL_DTEC') & _torw='Z')
|| _dnd:=0
?};

{? (_torw='Z' | (TKTL.STAT_N='T' & TKTL.STAT_O='N' & ~_used)) & _dnd
||
   Objt.TAB.dnd_sel(Objt.WERT,,'records.#tree_wert',$("params_exec('dnd_renum','tech_oper',"+!Objt+")"));

   Objt.TAB.dnd_sel(Objt.WERT,,'records.TTOPER',"
::    Formuła na dodanie nowej operacji wewnętrznej prostej (analogicznie do 'Dołącz' z podpowiedzią pola 'Operacja')
      params_set(params_get());
      _records:=dnd_info('dropped_records');
      {? _records.size()>1
      || FUN.info('Dołączać można tylko pojedynczą pozycję.'@)
      || TTOPER.clear();
         TTOPER.seek(_records.REF,);
         {? Objt.TAB.seek(dnd_info('dest_record')) || TOPER.seek(Objt.TAB.REF,) ?};
         Objt.f_add(2,0,TTOPER,TTOPER.ref(),dnd_info('dest_record'))
      ?}

   ");
   Objt.TAB.dnd_sel(Objt.WERT,,'records.TTOUT',"
::    Formuła na dodanie nowej operacji zewnętrznej prostej (analogicznie do 'Dołącz' z podpowiedzią pola 'Operacja')
      params_set(params_get());
      _records:=dnd_info('dropped_records');
      {? _records.size()>1
      || FUN.info('Dołączać można tylko pojedynczą pozycję.'@)
      || TTOUT.clear();
         TTOUT.seek(_records.REF,);
         {? Objt.TAB.seek(dnd_info('dest_record')) || TOPER.seek(Objt.TAB.REF,) ?};
         Objt.f_add(2,0,TTOUT,TTOUT.ref(),dnd_info('dest_record'))
      ?}
   ");
   Objt.TAB.dnd_sel(Objt.WERT,,'records.fun_wer_t',"
::    Formuła na dodanie nowej operacji złożonej (analogicznie do 'Dołącz')
      params_set(params_get());
      _records:=dnd_info('dropped_records');
      {? _records.size()>1
      || FUN.info('Dołączać można tylko pojedynczą pozycję.'@)
      || {? Objt.TAB.seek(dnd_info('dest_record')) || TOPER.seek(Objt.TAB.REF,) ?};
         Objt.f_add(2,0,TOPER,null(),dnd_info('dest_record'))
      ?}
   ")

|| Objt.TAB.dnd_sel(Objt.WERT,,'records.#tree_wert',"");
   Objt.TAB.dnd_sel(Objt.WERT,,'records.TTOPER',"");
   Objt.TAB.dnd_sel(Objt.WERT,,'records.TTOUT',"");
   Objt.TAB.dnd_sel(Objt.WERT,,'records.fun_wer_t',"")
?};

:: widok wołany z menu technologii, z menu zlecenia
{? _zakl=1 | _zakl=4 | _zakl=5 | _zakl=7
||
   TTOPER.clear(); TTOPER.first();
   TTOUT.clear(); TTOUT.first();

   {? _zakl=7
   || _result:=Objt.select()
   || Objt.select()
   ?};
::   VAR_DEL.delete('TREE','__Fun','Objt');
::   {? var_pres('TTREE')>0
::   || Objt:=TTREE
::   ?};

   TWRKZBR.actions('WER','');

   PFAZ.f_clear();

   TKTL.cntx_pop()
|? _zakl=6
|| TKTL.cntx_pop()
?};

VAR_DEL.delete('Objt');
{? _locked || exec('tktl_unlock','tech_common',,'O') ?};
_result


\next_lev
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: kolejny poziom struktury operacji
::   WE: _a - obiekt TREE
::       _b - TOPER.UNROP (0 jak korzeń)
::       _c - up-node (w strukturze drzewa)
::  OLD: \next_lev/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.A_KTL=null() || return() ?};

_obj:=_a;
_unrop:=_b;
_upnode:=_c;

TOPER.cntx_psh();
TOPER.index('NNN');
TOPER.prefix(VAR.A_KTL,_unrop);
{? TOPER.first()
|| {!
   |?
      {? TOPER.TPZ<>'T' || exec('level','tech_oper',_obj,_upnode) ?};
      TOPER.next()
   !}
?};
TOPER.cntx_pop();
~~


\level
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: bieżący poziom struktury operacji - wołane w next_lev i .f_add
::   WE: _a - obiekt TREE
::       _b - up-node (w strukturze drzewa)
::
::       - kontekst tabeli TOPER (bieżący rekord)
::  OLD: \level/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_upnode:=_b;

_timedok:=exec('get','#params',500604,1);
_node:=_obj.add(#TOPER.ref(),'exec(''oper'',''tech_oper'','''+!_obj+''')',_upnode);
{? TOPER.PZ='P' & TOPER.WEW='T'
|| _obj.value(_node,'NTIME',TOPER.NTIME);
   _obj.value(_node,'MTIME',TOPER.MTIME);
   _obj.value(_node,'WEW',TOPER.WEW);
   _obj.value(_node,'PZ',TOPER.PZ);
   _obj.value(_node,'GRUPA',TOPER.GRUPA().SYMBOL);
   _obj.value(_node,'GRUPA_N',TOPER.GRUPA().NAZWA);
   {? TOPER.GRPOJ='S'
   || _obj.value(_node,'PLACE',TOPER.PLACE().KOD);
      _obj.value(_node,'PLACE_N',TOPER.PLACE().NA)
   || _obj.value(_node,'PLACE',TOPER.TWRKPLG().ELEMENT().KOD);
      _obj.value(_node,'PLACE_N',TOPER.TWRKPLG().ELEMENT().NA)
   ?};
   _obj.value(_node,'OPER',TOPER.OPER().KOD);
   _obj.value(_node,'OPER_N',TOPER.OPER().NA);
   _obj.value(_node,'ZAWOD',TOPER.OPER().ZAWOD().KOD);
   _obj.value(_node,'ZAWOD_N',TOPER.OPER().ZAWOD().ZD);
   _obj.value(_node,'ETAP',TOPER.PX_STAGE().NAZWA);
   TOPER.cntx_psh();
   TOPER.index('TPZ');
   TOPER.prefix('T',TOPER.UNROP);
   {? TOPER.first()
   ||
      _obj.value(_node,'TPZ','T');
      _obj.value(_node,'TPZ_TIME',TOPER.NTIME);
      _obj.value(_node,'TPZ_ZAW',TOPER.ZAW().KOD);
      _obj.value(_node,'TPZ_ZAWN',TOPER.ZAW().ZD)
   ||
      _obj.value(_node,'TPZ','N')
   ?};
   TOPER.cntx_pop();
   _obj.value(_node,'PFAZ',TOPER.PFAZ().KOD);
   _obj.value(_node,'WYD',TOPER.PFAZ().WYD().KOD);
   _obj.value(_node,'DOK',TOPER.DOK().T);
   _obj.value(_node,'NAST',exec('get_nast_nums','tech_oper',TOPER.ref()));
   _obj.value(_node,'PL_GRP',TOPER.PL_GRP);
   _obj.value(_node,'KONTROLA',TOPER.KONTROLA);
   _obj.value(_node,'KJ_BAD',TOPER.KJ_BAD);
   _obj.value(_node,'FIX_NORM',TOPER.FIX_NORM)
|? TOPER.PZ='P' & TOPER.WEW='N'
|| _obj.value(_node,'CENA',TOPER.CENA);
   _obj.value(_node,'WEW',TOPER.WEW);
   _obj.value(_node,'PZ',TOPER.PZ);
   _obj.value(_node,'PFAZ',TOPER.PFAZ().KOD);
   _obj.value(_node,'WYD',TOPER.PFAZ().WYD().KOD);
   _obj.value(_node,'DOK',TOPER.DOK().T);
   _obj.value(_node,'NAST',exec('get_nast_nums','tech_oper',TOPER.ref()));
   _obj.value(_node,'ETAP',TOPER.PX_STAGE().NAZWA);
   _obj.value(_node,'DAYS_K',TOPER.DAYS_K);
   _obj.value(_node,'PX_KONT',TOPER.PX_KONT().SYMBOL);
   _obj.value(_node,'KONTRAH',TOPER.KONTRAH().SKR)
|| _obj.value(_node,'WEW',TOPER.WEW);
   _obj.value(_node,'PZ',TOPER.PZ);
   _obj.value(_node,'PFAZ',TOPER.PFAZ().KOD);
   _obj.value(_node,'WYD',TOPER.PFAZ().WYD().KOD);
   _obj.value(_node,'DOK',TOPER.DOK().T);
   _obj.value(_node,'ETAP',TOPER.PX_STAGE().NAZWA)
?};
_obj.value(_node,'OPIS',TOPER.OPIS);
exec('next_lev','tech_oper',_obj,TOPER.UNROP,_node);
~~


\oper
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Określa dane operacji dodawanej do widoku drzewa
::   WE: _a = scieżka do obiektu TREE (z użyciem operatora !)
::   WY: Nazwa operacji [STRING]
::  OLD: \oper/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=($_a)();

TOPER.cntx_psh();
TOPER.clear();
{? TOPER.seek(_obj.TAB.REF,)
|| VAR.A_OP:=TOPER.ref();
   _res:=
      $TOPER.NROP+'. '+
      {? TOPER.PZ='P' & TOPER.WEW='T'
      || TOPER.OPER().NA
      |? TOPER.PZ='Z' & TOPER.WEW='T'
      || TOPER.NA
      |? TOPER.PZ='P' & TOPER.WEW='N'
      || TOPER.TTOUT().NA
      || ''
      ?}
|| VAR.A_OP:=null();
   _res:=''
?};
TOPER.cntx_pop();
_res


\valid_op
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Walidacja listy operacji - złożone muszą mieć podrzędne
::   WE: _a - TKTL.ref()
::       _b - numer operacji nadrzędnej
::       [_c] - zadawać pytanie, czy bezwarunkowo blokować wyjście? (0/1)
::   WY: <>0 - ok
::       =0 - błędy
::  OLD: \valid_op/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
_nrnop:=_b;
{? var_pres('_c')=type_of(0) || _block:=_c || _block:=1 ?};

_txt:={? VAR.A_TORW='W' || 'wzorca' || 'karty' ?};

TOPER.cntx_psh();
TOPER.index('ANNN');
TOPER.prefix('T','N',_tktl,_nrnop);
_kor:=exec('FindAndGet','#table',TKTL,_tktl,,"STAN='T'",0);
_nrop:=0;
{? TOPER.first()
||
   {!
   |?
::    Sprawdzenie powtarzających się numerów operacji
      {? _nrop=TOPER.NROP
      || _msg:=
            {? _kor
            || {? VAR.A_TORW='W'
               || 'Powtarza się numer operacji: %1.\n\n'
                  'Należy poprawić dane albo usunąć tę operację,\n'
                  'w przeciwnym wypadku użycie wzorca może powodować błędy.'@[$_nrop]
               || 'Powtarza się numer operacji: %1.\n\n'
                  'Należy poprawić dane albo usunąć tę operację,\n'
                  'w przeciwnym wypadku użycie karty może powodować błędy.'@[$_nrop]
               ?}
            || {? VAR.A_TORW='W'
               || 'Powtarza się numer operacji: %1.\n\n'
                  'Należy poprawić dane albo usunąć tę operację,\n'
                  'w przeciwnym wypadku nie będzie można zatwierdzić wzorca.'@[$_nrop]
               || 'Powtarza się numer operacji: %1.\n\n'
                  'Należy poprawić dane albo usunąć tę operację,\n'
                  'w przeciwnym wypadku nie będzie można zatwierdzić karty.'@[$_nrop]
               ?}
            ?};
         {? _block
         || FUN.emsg(_msg);
            TOPER.cntx_pop();
            return(0)
         || _choice:=
            FUN.choice(_msg,,'Powróć do redagowania'@,,,,'Anuluj'@);
            TOPER.cntx_pop();
            return(~_choice)
         ?}
      ?};
      _nrop:=TOPER.NROP;

::    Rekurencja dla złożonych
      {? TOPER.PZ='Z'
      || {? _res:=exec('valid_op','tech_oper',_tktl,TOPER.UNROP,_block);
            _res<>1
         || TOPER.cntx_pop();
            return(_res)
         ?}
      ?};
      TOPER.next()
   !}
||
:: Sprawdzenie, czy operacja złożona ma operacje podrzędne
   {? _nrnop<>0
   || _nrop:=exec('get_oper_nr','tech_oper',TOPER.UNROP,'\\\\');
      _msg:=
         {? _kor
         || {? VAR.A_TORW='W'
            || 'Operacja złożona: %1 musi mieć operacje składowe.\n\n'
               'Należy uzupełnić dane albo usunąć tę operację,\n'
               'w przeciwnym wypadku użycie wzorca może powodować błędy.'@[_nrop]
            || 'Operacja złożona: %1 musi mieć operacje składowe.\n\n'
               'Należy uzupełnić dane albo usunąć tę operację,\n'
               'w przeciwnym wypadku użycie karty może powodować błędy.'@[_nrop]
            ?}
         || {? VAR.A_TORW='W'
            || 'Operacja złożona: %1 musi mieć operacje składowe.\n\n'
               'Należy uzupełnić dane albo usunąć tę operację,\n'
               'w przeciwnym wypadku nie będzie można zatwierdzić wzorca.'@[_nrop]
            || 'Operacja złożona: %1 musi mieć operacje składowe.\n\n'
               'Należy uzupełnić dane albo usunąć tę operację,\n'
               'w przeciwnym wypadku nie będzie można zatwierdzić karty.'@[_nrop]
            ?}
         ?};
      {? _block
      || FUN.emsg(_msg);
         TOPER.cntx_pop();
         return(0)
      || _choice:=
         FUN.choice(_msg,,'Powróć do redagowania'@,,,,'Anuluj'@);
         TOPER.cntx_pop();
         return(~_choice)
      ?}
   ?}
?};
TOPER.cntx_pop();
1


\valid_op1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdza czy technologia zawiera co najmniej jedną operację (chyba że typ bez operacji albo wzorzec)
::   WE: _a - TKTL.ref
::       [_b] - INTEGER - 0/[1] - czy wyświetlać dialogi
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};

_res:=1;
_oper:=exec('FindAndGet','#table',TKTL,_tktl,,"TYP().OPER",'T');
_torw:=exec('FindAndGet','#table',TKTL,_tktl,,"TORW",'T');

{? _oper='T' & _torw<>'W'
|| TOPER.cntx_psh();
   TOPER.index('NNN');
   TOPER.prefix(_tktl);
   {? TOPER.first()
   || _res:=1
   || {? _dialog>0
      || FUN.emsg('Należy wprowadzić co najmniej jedną operację.'@)
      ?};
      _res:=0
   ?};
   TOPER.cntx_pop()
?};

_res


\get_oper_nr
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Zwraca string numeru operacji (1.2.3.4.5)
::   WE: _a - unikalny numer operacji
::       [_b] - separator (domyślnie "\")
::       [_c] - numerki/string ('numerki')
::       [_d] - dodawać dane dla _a (nie- dowolny parametr, tak-brak parametru)
::  OLD: \get_oper_nr/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_first:={? _>3 || 1 || 0 ?};
_number:={? _>2 || {? (1+_c)='n' || 'n' || 's' ?} || 'n' ?};
_kropka:={? _>1 || _b || '\\' ?};
TOPER.cntx_psh();
TOPER.clear();
TOPER.index('UNROP');
TOPER.prefix(_a);
{? TOPER.first()
|| _dodatek:={? _number='n'
             || $TOPER.NROP
             || {? TOPER.PZ='P'
                || {? TOPER.WEW='N'
                   || TTOUT.cntx_psh();
                      _tmp:=TOPER.TTOUT().NA;
                      TTOUT.cntx_pop();
                      _tmp
                   || TOPER.OPER().NA
                   ?}
                |? TOPER.PZ='Z'
                || TOPER.NA
                || ''
                ?}
             ?};
   {? TOPER.NRNOP<>0
   || _result:=exec('get_oper_nr','tech_oper',TOPER.NRNOP,_kropka,_number)+{? _first || '' || _kropka+_dodatek ?}
   || _result:=_dodatek
   ?}
|| _result:=''
?};
TOPER.cntx_pop();
_result


\zmien_stawke
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: zmienia stawkę w taryfikatorze
::  OLD: \zmien_stawke/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.GRUPA='T' |
   FUN.ask('Czy zaktualizować stawkę operacji w kartach technologicznych?'@)
|| exec('tktl_use','tech_common');
   TOPER.index('TAR');
   TOPER.prefix(TTOPER.ref());
   {? TOPER.first()
   || {? VAR.GRUPA<>'T'
      || _progress:=exec('init','#progress');
         _progress.HEIGHT:=10;
         _progress.gl_smode('#');
         _progress.add_progress('Aktualizacja operacji wg taryfikatora'@,TOPER.size());
         exec('start','#progress',_progress)
      ?};
      {!
      |? {? TOPER.NRK().ZL=null() & TOPER.NRK().PLRELWYR=null()
         || TOPER.PLNH:=(TTOPER.STAWKA*TOPER.COEF)$4;
            TOPER.PLNX:=(TOPER.PLNH*TOPER.NTIME)$4;
            TOPER.put()
         ?};
         {? VAR.GRUPA='T'
         || _can_continue:=1
         || _can_continue:=exec('next_step','#progress',_progress,1,1)
         ?};
         _can_continue & TOPER.next()
      !};
      {? VAR.GRUPA<>'T' || _progress.ctr_stop() ?}
   ?}
?}


\zm_stawke_gpr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Obsługa 'przed grupą' dla 'Aktualizuj' w TTOPER
::   WY: 0 / 1
::  OLD: \zm_stawke_gpr/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask(
      'Ilość zaznaczonych pozycji: %1.\n\n'
      'Czy zaktualizować stawki operacji w kartach technologicznych?'@[form(TTOPER.sel_size())]
   )
|| VAR.GRUPA:='T';
   KOMM.init();
   1
|| 0
?}


\zm_stawke_gpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Obsługa 'po grupie' dla 'Aktualizuj' w TTOPER
::   WY: ~~
::  OLD: \zm_stawke_gpo/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\zmien_stwrk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.60]
:: OPIS: zmienia koszty operacji
::  OLD: \zmien_stwrk/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.GRUPA='T' |
   FUN.ask('Czy zaktualizować koszty operacji w kartach technologicznych?'@)
|| exec('tktl_use','tech_common');
   TOPER.index('WRK');
   TOPER.prefix(TWRKPLC.ref());
   {? TOPER.first()
   || {? VAR.GRUPA<>'T'
      || _progress:=exec('init','#progress');
         _progress.HEIGHT:=10;
         _progress.gl_smode('#');
         _progress.add_progress('Aktualizacja operacji wg taryfikatora'@,TOPER.size());
         exec('start','#progress',_progress)
      ?};
      {!
      |? {? TOPER.NRK().ZL=null() & TOPER.NRK().PLRELWYR=null()
         || TOPER.KH:=TWRKPLC.KH;
            TOPER.KX:=(TOPER.KH*TOPER.MTIME)$4;
            TOPER.put()
         ?};
         {? VAR.GRUPA='T'
         || _can_continue:=1
         || _can_continue:=exec('next_step','#progress',_progress,1,1)
         ?};
         _can_continue & TOPER.next()
      !};
      {? VAR.GRUPA<>'T' || _progress.ctr_stop() ?}
   ?};
   TOPER.clear()
?};
~~


\zm_stwrk_gpr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Obsługa 'przed grupą' dla 'Aktualizuj' w TWRKPLC
::   WY: 0 / 1
::  OLD: \zm_stwrk_gpr/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='T';
{? FUN.ask(
      'Ilość zaznaczonych pozycji: %1.\n\n'
      'Czy zaktualizować koszty operacji w kartach technologicznych?'@[form(TWRKPLC.sel_size())]
   )
|| KOMM.init();
   1
|| 0
?}


\zm_stwrk_gpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Obsługa 'po grupie' dla 'Aktualizuj' w TWRKPLC
::  OLD: \zm_stwrk_gpo/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\zmien_cene
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.60]
:: OPIS: zmienia cenę w taryfikatorze
::  OLD: \zmien_cene/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.GRUPA='T' |
   FUN.ask('Czy zaktualizować cenę usługi w kartach technologicznych?'@)
|| exec('tktl_use','tech_common');
   TOPER.index('OUT');
   TOPER.prefix(TTOUT.ref());
   {? TOPER.first()
   || {? VAR.GRUPA<>'T'
      || _progress:=exec('init','#progress');
         _progress.HEIGHT:=10;
         _progress.gl_smode('#');
         _progress.autoclose(0);
         _progress.add_progress('Aktualizacja operacji wg taryfikatora'@,TOPER.size());
         exec('start','#progress',_progress)
      ?};
      {!
      |? {? TOPER.NRK().ZL=null() & TOPER.NRK().PLRELWYR=null()
         || TOPER.CENA:=(TTOUT.CENA*TOPER.COEF)$4;
            TOPER.put()
         ?};
         {? VAR.GRUPA='T'
         || _can_continue:=1
         || _can_continue:=exec('next_step','#progress',_progress,1,1)
         ?};
         _can_continue & TOPER.next()
      !};
      {? VAR.GRUPA<>'T' || _progress.ctr_stop() ?}
   ?}
?}


\zm_cene_gpr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Obsługa 'przed grupą' dla 'Aktualizuj' w TTOUT
::   WY: 0 / 1
::  OLD: \zm_cene_gpr/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask(
      'Ilość zaznaczonych pozycji: %1.\n\n'
      'Czy zaktualizować ceny usług w kartach technologicznych?'@[form(TTOUT.sel_size())]
   )
|| VAR.GRUPA:='T';
   KOMM.init();
   1
|| 0
?}


\zm_cene_gpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Obsługa 'po grupie' dla 'Aktualizuj' w TTOUT
::   WY: ~~
::  OLD: \zm_cene_gpo/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\toper_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Przed redakcja TOPER
::   WY: 1
::  OLD: \toper_be/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
exec('prep_ch','tech_oper');
PFAZ.clear();
PFAZ.f_set('KOD','','PFAZ.WYD='':_a'' or '':_a''=''''',$VAR.A_KTL().JORG);
1


\prep_ch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Przygotowanie zmiennych dla okna TOPER.
::  OLD: \prep_ch/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
TOPER.cntx_psh();
TOPER.index('TPZ');
TOPER.prefix('T',TOPER.UNROP);
{? TOPER.first() & TOPER.ACT='T' & VAR.ZM_ROPER<>'T'
|| VAR1.TPZ:='T';
   VAR1.ZAW:=TOPER.ZAW;
   VAR1.COEF1:=TOPER.COEF;
   VAR1.FCOEF1:=TOPER.FCOEF;
   VAR1.NTIME1:=TOPER.NTIME;
   VAR1.FNTIME1:=TOPER.FNTIME;
   VAR1.STAWKA1:=TOPER.KH;
   VAR1.PLNH1:=TOPER.PLNH;
   VAR1.PLNX:=TOPER.PLNX;
   VAR1.CIAGLA:=TOPER.CIAGLA
|| VAR1.TPZ:='N';
   VAR1.ZAW:=null();
   VAR1.COEF1:=0;
   VAR1.FCOEF1:='';
   VAR1.NTIME1:=0;
   VAR1.FNTIME1:='';
   VAR1.STAWKA1:=0;
   VAR1.PLNH1:=0;
   VAR1.PLNX:=0;
   VAR1.CIAGLA:='T'
?};
TOPER.cntx_pop();
~~


\toperp_d
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed dołączeniem rekordu w operacjach technologii
::       MUSI być ustawiony kontekst VAR.A_KTL
::   WE: _a - jeżeli jest, to bez pytania odpowiedni wariant
::   WY: 0 / 1
::  OLD: \toperp_d/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.A_KTL=null()
|| FUN.info('Brak wygenerowanej karty technologicznej — nie można dołączać operacji.'@);
   return(0)
?};

_ask:={? _>0 || _a || 3 ?};
_res:=0;
_par:=VAR.A_KTL().TYP().PAR;
_can_continue:=1;

{? ~VAR.KOR & ((TKTL.STAT_O='T')&(VAR.A_UNROP<>0))
|| FUN.emsg('W tej karcie nie można już dodawać operacji składowych.'@);
   _can_continue:=0
?};

:: Ustalenie aktywności operacji nadrzędnej
{? _can_continue>0
|| _act:=1;
   TOPER.cntx_psh();
   TOPER.index('UNROP');
   TOPER.prefix(TOPER.NRNOP);
   {? TOPER.first() || _act:=TOPER.ACT='T' ?};
   TOPER.cntx_pop();
   {? ~_act
   || FUN.info('Bieżąca operacja złożona jest nieaktywna — nie można do niej dodawać składowych.'@);
      _can_continue:=0
   ?}
?};

{? _can_continue>0
|| {? {? _ask=3
      || _ask:=choice(
            {? VAR.KOR || 'Modyfikacja zatwierdzonej karty technologicznej.'@+'\n\n' || '' ?}+
            'Dodawana operacja jest:'@,
            FUN.TYT,'ASK',1,0,,
            'Prosta'@,
            'Złożona'@,
            'Ze&wnętrzna'@,
            'Anuluj'@)
      ?};
      _ask=3
   || _res:=0
   |? _ask=0
   || VAR.A_PRZL:='P';
      VAR.A_WEW:='T';
      VAR1.TPZ:='N';
      VAR1.CIAGLA:='T';
      VAR1.ZAW:=null();
      VAR1.COEF1:=0;
      VAR1.FCOEF1:='';
      VAR1.NTIME1:=0;
      VAR1.FNTIME1:='';
      VAR1.STAWKA1:=0;
      VAR1.PLNH1:=0;
      VAR1.PLNX:=0;
      _win:='RED_SIM'+_par;
      _res:=1
   |? _ask=1
   || VAR.A_PRZL:='Z';
      VAR.A_WEW:='T';
      VAR1.TPZ:='N';
      _win:='RED_ADW'+_par;
      _res:=1
   |? _ask=2
   || VAR.A_PRZL:='P';
      VAR.A_WEW:='N';
      VAR1.TPZ:='N';
      _win:='RED_OUT'+_par;
      _res:=1
   ?}
|| _res:=0
?};

{? _res
|| TOPER.win_edit(_win);
   TOPER.hdr_edit({? VAR.KOR || ' — '+'MODYFIKACJA ZATWIERDZONEJ KARTY'@ || '' ?})
?};

_res


\bopernro
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: blank TOPER.NROP
::  OLD: \bopernro/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
TOPER.cntx_psh();
_res:={? TOPER.last()
      || TOPER.NROP+1
      || 1
      ?};
TOPER.cntx_pop();
_res


\tm_ohead
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Przed redakcją pól TOPER (NROP, EXIST, FCOEF, FCENA)
::   WY: 0 / 1
::  OLD: \tm_ohead/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
TKTL.STAT_O='N' | VAR.KOR | VAR.GRP_MOD='P'


\tm_onc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Przed redakcją pól TOPER (FNTIME, FMTIME, FTTM, FNKO)
::   WY: 0 / 1
::  OLD: \tm_onc/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
TKTL.STAT_O='N' | VAR.KOR


\boperunr
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: blank TOPER.UNROP
::  OLD: \boperunr/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
TOPER.tm_stamp()


\bopernnr
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: blank TOPER.NRNOP
::  OLD: \bopernnr/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_UNROP


\be_ttoper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Przed redakcją pola TOPER.TTOPER
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
VAR.TTOPER:=TOPER.OPER;
1

\ae_ttoper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Po redakcji pola TOPER.TTOPER
::   WE: [_a] - 1 - opcjonalnie NIE wyświetlać win_disp(), 0 - wyświetla (domyślnie)
::   WY: 1
::  OLD: \ae_ttoper/tex_oper.fml
::  TAG: <MBUILDER><AE>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _nodisp:=_a || _nodisp:=0 ?};

:: Modyfikacje tylko, gdy zmieniono wartość pola
{? VAR.TTOPER=TOPER.OPER || return(1) ?};

TOPER.PLNH:=(TOPER.COEF*TOPER.OPER().STAWKA)$4;
VAR1.STAWKA1:=(TOPER.OPER().STAWKA)$4;
{? VAR.GRP_MOD='N'
|| TOPER.KONTROLA:=TTOPER.KONTROLA;
   _kj_bad:=TTOPER.KJ_BAD;
:: Sprawdzenie, czy są utworzone dedykowane badania dla danej grupy materiałowej i operacji
   M.cntx_psh();
   _mgr:=TOPER.NRK().KTM().MGR;
   M.cntx_pop();
:: Badanie kontroli jakości
   _badseh:=exec('get_badseh4oper','statexam',TTOPER.ref(),_mgr,'T','N');
   {? _badseh=null()
   ||
:: Jak nie ma dedykowanego badania to przepisanie z definicji operacji (TTOPER)
      _badseh:=TTOPER.BADSEH
   || _kj_bad:='B'
   ?};
:: Badanie w trackie rejestracji wykonania produkcji
   _bad_op:=exec('get_badseh4oper','statexam',TTOPER.ref(),_mgr,'T','T');
   {? _bad_op=null()
   ||
:: Jak nie ma dedykowanego badania to przepisanie z definicji operacji (TTOPER)
      _bad_op:=TTOPER.BAD_OP
   ?};
   TOPER.KJ_BAD:=_kj_bad;
   TOPER.BADSEH:=_badseh;
   TOPER.BAD_OP:=_bad_op;
   TOPER.FIX_NORM:=TTOPER.FIX_NORM;
   TOPER.BRYG:=TTOPER.BRYG;
   TOPER.PL_GRP:=TTOPER.PL_GRP;
   TOPER.WYK_FAST:=TTOPER.WYK_FAST;
   TOPER.NO_START:=TTOPER.NO_START
?};
{? VAR.GRP_MOD<>'T'
|| {? TOPER.TWRKPLG=null() & TOPER.PLACE=null()
   || {? TOPER.OPER().GRPOJ='S' & TTOPER.PLACE<>null()
      || {? TOPER.OPER().GRPOJ='S' & TTOPER.PLACE<>null()
            | TTOPER.PLACE().WYD<>null() & TOPER.PFAZ<>null() & TTOPER.PLACE().WYD=TOPER.PFAZ().WYD
         || TOPER.GRPOJ:='S';
            TOPER.PLACE:=TTOPER.PLACE;
            TOPER.PL_GRP:=TOPER.PLACE().PL_GRP;
            TOPER.KH:=TOPER.PLACE().KH;
            TOPER.KX:=(TOPER.PLACE().KH*TOPER.MTIME)$4
         ?}
      |? TOPER.OPER().GRPOJ='G' & TTOPER.GRUPA<>null()
      || {? TTOPER.GRUPA().WYD=null() | TOPER.PFAZ=null()
            | TTOPER.GRUPA().WYD<>null() & TOPER.PFAZ<>null() & TTOPER.GRUPA().WYD=TOPER.PFAZ().WYD
         || TOPER.GRPOJ:='G';
            TOPER.GRUPA:=TTOPER.GRUPA;
            {? TTOPER.TWRKPLG<>null()
            || {? TTOPER.TWRKPLG().ELEMENT().WYD=null() | TOPER.PFAZ=null()
                | TTOPER.TWRKPLG().ELEMENT().WYD<>null() & TOPER.PFAZ<>null() & TTOPER.TWRKPLG().ELEMENT().WYD=TOPER.PFAZ().WYD
               || TOPER.TWRKPLG:=TTOPER.TWRKPLG;
                  TOPER.PL_GRP:=TOPER.TWRKPLG().ELEMENT().PL_GRP;
                  TOPER.KH:=TOPER.TWRKPLG().ELEMENT().KH;
                  TOPER.KX:=(TOPER.TWRKPLG().ELEMENT().KH*TOPER.MTIME)$4
               ?}
            ?}
         ?}
      ?}
   ?}
?};
exec('efld_opt','tech_oper',TOPER);
{? ~_nodisp || win_disp() ?};
1


\po_grpoj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Po redakcji pola GRPOJ
::   WE: _a - Alias tabeli (TOPER, TECHZAMS)
::  OLD: \po_grpoj/tex_ope1.fml
::  TAG: <MBUILDER><AE>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
{? _tab.GRPOJ='G'
|| _tab.PLACE:=null()
|| _tab.GRUPA:=null();
   _tab.TWRKPLG:=null();
   _tab.PLACE()
?};
win_disp();
exec('efld_opt','tech_oper',_tab);
1


\efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Ustawia opcje pól w oknach redagowania TOPER/TECHZAMS
::   WE: _a - Alias tabeli (TOPER, TECHZAMS)
::       [_b] - STRING - akronim pola które było redagowane (dla wywołań po redakcji)
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_fld:='';
{? var_pres('_b')=type_of('')
|| _fld:=_b
?};

{? _tab=TECHZAMS | _tab.PZ='P' & _tab.WEW='T'
|| {? VAR.GRP_MOD='P'
   || _tab.efld_opt(_tab.win_edit('?'),{? _tab.GRPOJ='G' || 'mark=0,enable=0' || 'mark=0,enable=1' ?},,'PLACE');
      _tab.efld_opt(_tab.win_edit('?'),{? _tab.GRPOJ='G' || 'mark=0,enable=0' || 'mark=0,enable=1' ?},TWRKPLC,'WYD');
      _mar:={? _tab.GRUPA<>null() || '1' || '0' ?};
      _tab.efld_opt(_tab.win_edit('?'),{? _tab.GRPOJ='G' || 'mark='+_mar+',enable=1' || 'mark=0,enable=0' ?},,'GRUPA');
      _tab.efld_opt(_tab.win_edit('?'),{? _tab.GRPOJ='G' || 'mark='+_mar+',enable=1' || 'mark=0,enable=0' ?},,'TWRKPLG')
   ||  _tab.efld_opt(_tab.win_edit('?'),{? _tab.GRPOJ='G' || 'mark=0,enable=0' || 'mark=1,enable=1' ?},,'PLACE');
      _tab.efld_opt(_tab.win_edit('?'),{? _tab.GRPOJ='G' || 'mark=0,enable=0' || 'mark=1,enable=1' ?},TWRKPLC,'WYD');
      _tab.efld_opt(_tab.win_edit('?'),{? _tab.GRPOJ='G' || 'mark=1,enable=1' || 'mark=0,enable=0' ?},,'GRUPA');
      _tab.efld_opt(_tab.win_edit('?'),{? _tab.GRPOJ='G' || 'mark=1,enable=1' || 'mark=0,enable=0' ?},,'TWRKPLG')
   ?};
   {? _tab=TOPER
   || _tab.efld_opt('RED_SIMN',
         {? _tab.NTIME<>0 & _tab.MTIME=0 | _tab.NTIME=0 & _tab.MTIME=0 | _tab.NTIME<>0 & _tab.MTIME<>0
         || 'mark=1'
         || 'mark=0'
         ?},,'NTIME');
      _tab.efld_opt('RED_SIMN',
         {? _tab.NTIME=0 & _tab.MTIME<>0 | _tab.NTIME=0 & _tab.MTIME=0 | _tab.NTIME<>0 & _tab.MTIME<>0
         || 'mark=1'
         || 'mark=0'
         ?},,'MTIME');
      _tab.efld_opt('RED_SIMT',
         {? _tab.NTIME<>0 & _tab.MTIME=0 | _tab.NTIME=0 & _tab.MTIME=0 | _tab.NTIME<>0 & _tab.MTIME<>0
         || 'mark=1'
         || 'mark=0'
         ?},,'FNTIME');
      _tab.efld_opt('RED_SIMT',
         {? _tab.NTIME=0 & _tab.MTIME<>0 | _tab.NTIME=0 & _tab.MTIME=0 | _tab.NTIME<>0 & _tab.MTIME<>0
         || 'mark=1'
         || 'mark=0'
         ?},,'FMTIME')
   || _tab.efld_opt('RED_N',
         {? _tab.NTIME<>0 & _tab.MTIME=0 | _tab.NTIME=0 & _tab.MTIME=0 | _tab.NTIME<>0 & _tab.MTIME<>0
         || 'mark=1'
         || 'mark=0'
         ?},,'NTIME');
      _tab.efld_opt('RED_N',
         {? _tab.NTIME=0 & _tab.MTIME<>0 | _tab.NTIME=0 & _tab.MTIME=0 | _tab.NTIME<>0 & _tab.MTIME<>0
         || 'mark=1'
         || 'mark=0'
         ?},,'MTIME');
      _tab.efld_opt('RED_T',
         {? _tab.NTIME<>0 & _tab.MTIME=0 | _tab.NTIME=0 & _tab.MTIME=0 | _tab.NTIME<>0 & _tab.MTIME<>0
         || 'mark=1'
         || 'mark=0'
         ?},,'FNTIME');
      _tab.efld_opt('RED_T',
         {? _tab.NTIME=0 & _tab.MTIME<>0 | _tab.NTIME=0 & _tab.MTIME=0 | _tab.NTIME<>0 & _tab.MTIME<>0
         || 'mark=1'
         || 'mark=0'
         ?},,'FMTIME')
   ?}
?};
{? _tab=TOPER & _tab.WEW='T' & _tab.PZ='P'
|| _tab.efld_opt(_tab.win_edit('?'),{? VAR1.TPZ='T' || 'enable=1' || 'enable=0' ?},VAR1,'ZAW');
   _tab.efld_opt('RED_SIMT',{? VAR1.TPZ='T' || 'mark=1,enable=1' || 'enable=0' ?},VAR1,'FCOEF1');
   _tab.efld_opt('RED_SIMT',{? VAR1.TPZ='T' || 'mark=0,enable=1' || 'mark=0,enable=0' ?},VAR1,'COEF1');
   _tab.efld_opt('RED_SIMN',{? VAR1.TPZ='T' || 'mark=1,enable=1' || 'mark=0,enable=0' ?},VAR1,'COEF1');
   _tab.efld_opt(_tab.win_edit('?'),{? VAR1.TPZ='T' || 'enable=1' || 'enable=0' ?},VAR1,'STAWKA1');
   _tab.efld_opt(_tab.win_edit('?'),{? VAR1.TPZ='T' || 'enable=1' || 'enable=0' ?},VAR1,'PLNH1');
   _tab.efld_opt('RED_SIMT',{? VAR1.TPZ='T' || 'mark=1,enable=1' || 'enable=0' ?},VAR1,'FNTIME1');
   _tab.efld_opt('RED_SIMT',{? VAR1.TPZ='T' || 'mark=0,enable=1' || 'mark=0,enable=0' ?},VAR1,'NTIME1');
   _tab.efld_opt('RED_SIMN',{? VAR1.TPZ='T' || 'mark=1,enable=1' || 'mark=0,enable=0' ?},VAR1,'NTIME1');
   _tab.efld_opt(_tab.win_edit('?'),{? VAR1.TPZ='T' || 'enable=1' || 'enable=0' ?},VAR1,'PLNX');
   ~~
?};
::{? _tab=TOPER & _tab.WEW='N'
::|| _tab.efld_opt(_tab.win_edit('?'),{? _tab.SRW='S' || 'enable=1' || 'enable=0' ?},,'DOK')
::?};
{? _tab=TOPER
|| _tab.efld_opt(_tab.win_edit('?'),{? VAR.KOR || 'mark=1' || 'mark=0' ?},,'CAUSE')
?};
{? _tab=TOPER & _fld<>''
|| {? _fld='NTIME' | _fld='MTIME' | _fld='TTM' | _fld='NKO'
   || _fld_time:=_fld+'_T';
      _value_time:=exec('fld_time_init','tech_oper',_fld_time);
      _value_real:=($('TOPER.'+_fld))();
      {? _value_time=time(0,0,0) & _value_real>0
      ||
::       Ma pozostać szare
         ~~
      ||
::       Trzeba odszarzyć pole czasowe
         _tab.efld_opt(_tab.win_edit('?'),'editable=1',,_fld_time)
      ?}
   ?}
?};
~~


\bd_twrkplc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Przed wyświetleniem pola PLACE
::   WE: _a - Alias tabeli (TOPER, TECHZAMS)
::  OLD: \bd_twrkplc/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
1


\be_twrkplc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Przed redakcją pola TOPER.PLACE
::   WE: _a - Alias tabeli (TOPER, TECHZAMS)
::   WY: 0 / 1
::  OLD: \be_twrkplc/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
{? _tab.GRPOJ='S'
|| {? ~exec('tm_ohead','tech_oper') || return(0) ?};
   exec('twrkplc_filter_wye','zasoby');
   1
|| 0
?}


\ae_twrkplc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Po redakcji pola *.PLACE
::   WE: _a - Alias tabeli (TOPER, TECHZAMS)
::   WY: 0/1
::  OLD: \ae_twrkplc/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
{? _tab=TOPER & _tab.PZ='Z'
|| 1
||
::   _pwyd:=TOPER.PFAZ().WYD;
::   _swyd:=_tab.PLACE().WYD;
::   {? _pwyd<>null() & _swyd<>null() & _pwyd<>_swyd
::   || FUN.emsg('Stanowisko jest przypisane do innego wydziału niż wybrana faza produkcji.'@)
::   ?};
   _tab.KH:=_tab.PLACE().KH;
   _tab.KX:=(_tab.PLACE().KH*_tab.MTIME)$4;
   {? VAR.GRP_MOD<>'T'
   || {? _tab=TOPER
      || {? VAR1.TPZ<>'T'
         || {? -menu_txt()='popraw' & TOPER.PLACE<>null() & TOPER.PL_GRP<>TOPER.PLACE().PL_GRP
            || {? TOPER.PLACE().PL_GRP='T'
               || {? FUN.ask(
                        'Stanowisko z możliwością planowania grupowego.\n'
                        'Czy zmienić w definicji operacji?'@
                     )
                  || TOPER.PL_GRP:='T'
                  ?}
               || {? FUN.ask(
                        'Stanowisko bez możliwości planowania grupowego.\n'
                        'Czy zmienić w definicji operacji?'@
                     )
                  || TOPER.PL_GRP:='N'
                  ?}
               ?}
            || TOPER.PL_GRP:=TOPER.PLACE().PL_GRP
            ?}
         ?}
      ?}
   ?};
   1
?}


\be_plnx
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Przed redagowaniem pól PLNX, PLNH tabeli TOPER
::   WY: 0 / 1
::  OLD: \be_plnx/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
0


\ae_plnxt
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: po redakcji TOPER.PLNX
::  OLD: \ae_plnxt/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
1


\ae_plnht
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: po redakcji TOPER.PLNH
::  OLD: \ae_plnht/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
1


\be_ntime
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: przed redakcją TOPER.NTIME
::  OLD: \be_ntime/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? TKTL.STAT_O='N' | VAR.KOR
|| {? TOPER.NRK().TYP().PAR='T' & TOPER.FNTIME<>''
   || fld(tpar.calc(TOPER.FNTIME));
      0
   || 1
   ?}
|| 0
?}


\ae_normc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: po redakcji TOPER.NTIME
::   WE: [_a] - REAL - wartość pola
::  OLD: \ae_normc/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0)
|| _value:=_a
|| _value:=fld();
   fld(_value$5);
   _value:=fld()
?};
{? _value>=0
|| TOPER.PLNX:=(TOPER.PLNH*TOPER.NTIME)$4
|| FUN.emsg('Norma czasowa nie może być ujemna.'@);
   return(0)
?};
_fld:=cur_afld();
{? _fld='NTIME'
|| _fld:='NTIME_T';
   exec('fld_time_init','tech_oper',_fld)
?};
exec('efld_opt','tech_oper',TOPER,'NTIME');
1


\be_topco
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: przed redakcją TOPER.COEF
::  OLD: \be_topco/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? TKTL.STAT_O='N' | VAR.KOR
|| {? _red:=TOPER.win_edit('?');
      _red='RED_OUTN' | _red='RED_SIMN'
   || 1
   || {? TOPER.NRK().TYP().PAR='T' & TOPER.FCOEF<>''
      || fld(tpar.calc(TOPER.FCOEF));
         0
      || 1
      ?}
   ?}
|| 0
?}


\ae_topco
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: po redakcji TOPER.COEF
::  OLD: \ae_topco/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? fld(fld()$5); (fld()<0)
|| {? TOPER.WEW='T'
   || FUN.emsg('Współczynnik musi być większy od zera.'@)
   || FUN.emsg('Przelicznik musi być większy od zera.'@)
   ?};
   0
|| {? TOPER.WEW='T' || TOPER.PLNH:=(fld()*TOPER.OPER().STAWKA)$4;
                       VAR1.STAWKA1:=TOPER.OPER().STAWKA$4
                    || TOPER.CENA:=(fld()*TOPER.TTOUT().CENA)$4
   ?};
   1
?}


\sprawdz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [7.53] OWwPR11/5.8
:: OPIS: sprawdzenie redagowalności pola TOPER.BRYG
::  OLD: \sprawdz/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
1


\form_coef
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: po redakcji TOPER.FCOEF
::  OLD: \form_coef/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
{? fld()<>''
|| {? tpar.chk(fld())
   || {? TKTL.STAT_O='N' | VAR.KOR
      || TOPER.COEF:=tpar.RESULT;
         {? TOPER.COEF>0
         ||
            {? TOPER.WEW='T' || TOPER.PLNH:=(TOPER.COEF*TOPER.OPER().STAWKA)$4;
                                VAR1.STAWKA1:=(TOPER.OPER().STAWKA)$4
                             || TOPER.CENA:=(TOPER.COEF*TOPER.TTOUT().CENA)$4
            ?}
         || exec('err_form_lgzero','tech_common');
            _res:=0
         ?}
      ?}
   || _res:=0
   ?}
?};
_res


\form_ntime
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: po redakcji TOPER.FNTIME
::  OLD: \form_ntime/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
{? fld()<>''
|| {? tpar.chk(fld())
   || {? TKTL.STAT_O='N' | VAR.KOR
      || TOPER.NTIME:=tpar.RESULT;
         {? TOPER.NTIME>=0
         || TOPER.PLNX:=(TOPER.PLNH*TOPER.NTIME)$4
         || exec('err_form_ltzero','tech_common');
            _res:=0
         ?};
         {? _res>0
         || _fld:='NTIME_T';
            exec('fld_time_init','tech_oper',_fld)
         ?}
      ?}
   || _res:=0
   ?}
?};
exec('efld_opt','tech_oper',TOPER,'NTIME');
_res


\sprpfaz
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Formuła przed redagowaniem pola TOPER.PFAZ,
::       blokująca możliwość edytowania faz produkcji dla operacji podrzędnych
::   WY: 0 / 1
::  OLD: \sprpfaz/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_wyd:=
   {? TOPER.PFAZ<>null() & TOPER.PFAZ().WYD<>null()
   || PFAZ.WYD
   || TKTL.JORG
   ?};
exec('set_a_wyd','tte',_wyd);
exec('pfaz_filter','fazy',1);
{? TOPER.NRNOP<>0 || 0 || 1 ?}


\toper_pfaz_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed wyświetleniem pola TOPER.PFAZ
::----------------------------------------------------------------------------------------------------------------------
_wyd:=
   {? TOPER.PFAZ<>null() & TOPER.PFAZ().WYD<>null()
   || PFAZ.WYD
   || TKTL.JORG
   ?};
exec('set_a_wyd','tte',_wyd);
~~


\toper_po_pfaz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Po redakcji pola TOPER.PFAZ
::  OLD: \toper_po_pfaz/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
{? TOPER.PZ='Z' & TOPER.PFAZ().WYD<>null() & TOPER.PFAZ().WYD<>VAR.A_WYD
|| TOPER.cntx_psh();
   TOPER.index('ANNN');
   TOPER.prefix('T','N',TOPER.NRK,TOPER.UNROP);
   _test:=TOPER.first();
   TOPER.cntx_pop();
   {? _test
   || FUN.info(
         'Dla operacji złożonej z wpisanymi podoperacjami\n'
         'nie można zmieniać fazy produkcji na związaną z innym wydziałem.'@
      );
      return(0)
   ?}
?};
_wyd:=
   {? PFAZ.WYD<>null()
   || PFAZ.WYD
   || TKTL.JORG
   ?};
exec('set_a_wyd','tte',_wyd);
1


\be_mtime
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: przed redakcją TOPER.MTIME
::  OLD: \be_mtime/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? TKTL.STAT_O='N' | VAR.KOR
|| {? TOPER.NRK().TYP().PAR='T' & TOPER.FMTIME<>''
   || fld(tpar.calc(TOPER.FMTIME));
      0
   || 1
   ?}
|| 0
?}


\ae_mtime
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: po redakcji TOPER.MTIME
::   WE: [_a] - REAL - wartość pola
::  OLD: \ae_mtime/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0)
|| _value:=_a
|| _value:=fld();
   fld(_value$5);
   _value:=fld()
?};
{? _value>=0
|| TOPER.KH:={? TOPER.GRPOJ='G'
             || TOPER.TWRKPLG().ELEMENT().KH
             || TOPER.PLACE().KH
             ?};
   TOPER.KX:=(TOPER.KH*TOPER.MTIME)$4
|| FUN.emsg('Czas maszynowy nie może być ujemny.'@);
   return(0)
?};
_fld:=cur_afld();
{? _fld='MTIME'
|| _fld:='MTIME_T';
   exec('fld_time_init','tech_oper',_fld)
?};
exec('efld_opt','tech_oper',TOPER,'MTIME');
1


\form_fmtime
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: po redakcji TOPER.FNTIME
::  OLD: \form_fmtime/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
{? fld()<>''
|| {? tpar.chk(fld())
   || {? TKTL.STAT_O='N' | VAR.KOR
      || TOPER.MTIME:=tpar.RESULT;
         {? TOPER.MTIME>=0
         || TOPER.KX:=(TOPER.KH*TOPER.MTIME)$4
         || exec('err_form_ltzero','tech_common');
            _res:=0
         ?};
         {? _res>0
         || _fld:='MTIME_T';
            exec('fld_time_init','tech_oper',_fld)
         ?}
      ?}
   || _res:=0
   ?}
?};
exec('efld_opt','tech_oper',TOPER,'MTIME');
_res


\toper_opis_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Obsługa na F3 dla pola TOPER.OPIS
::  OLD: \toper_opis_f3/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=sql('
   select distinct
      TOPER.OPIS
   from TOPER
   where TOPER.OPIS<>\'\' and TOPER.OPIS like \':_a%\'
   order by OPIS
',fld());

_wer:=_tab.mk_sel('Opisy'@,,0,'toperopisy',40,10,20);
_tab.win_sel(_wer);
_tab.win_fld(_wer,,'OPIS',,,100,,,' ');
_tab.win_act(_wer,,'Formuła','Wybierz'@@,,,"sel_exit()",,1,,,,'W');

{? _tab.select()
|| fld():=_tab.OPIS;
   set_cpos(255)
?};
~~


\ttout_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Po redagowaniu pola TOPER.TTOUT
::   WE: [_a] - 1 - opcjonalnie NIE wyświetlać win_disp(), 0 - wyświetla (domyślnie)
::  OLD: \ttout_ae/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _nodisp:=_a || _nodisp:=0 ?};

_res:=1;
{? VAR.GRP_MOD<>'P'
|| {? TOPER.TTOUT=null()
   || {? tpar.chk(TOPER.FCOEF)
      || {? TKTL.STAT_O='N' | VAR.KOR
         || TOPER.COEF:=tpar.RESULT;
            {? TOPER.COEF>=0
            || {? TOPER.WEW='T' || TOPER.PLNH:=(TOPER.COEF*TOPER.OPER().STAWKA)$4;
                                   VAR1.STAWKA1:=(TOPER.OPER().STAWKA)$4
                                || TOPER.CENA:=(TOPER.COEF*TOPER.TTOUT().CENA)$4
               ?}
            || exec('err_form_ltzero','tech_common');
               _res:=0
            ?}
         ?}
      ?}
   || {? TOPER.WEW='N'
      || {? -menu_txt()*'popraw'=0
         || TOPER.SRW:=TOPER.TTOUT().SRW
         ?};
         {? VAR.GRP_MOD<>'T'
         || {? TOPER.TTOUT().KONTRAH<>null() || TOPER.KONTRAH:=TOPER.TTOUT().KONTRAH ?}
         ?};
         {? TOPER.WEW='T' || TOPER.PLNH:=(TOPER.COEF*TOPER.OPER().STAWKA)$4;
                             VAR1.STAWKA1:=(TOPER.OPER().STAWKA)$4
                          || TOPER.CENA:=(TOPER.COEF*TOPER.TTOUT().CENA)$4
         ?};
         {? ~_nodisp || win_disp() ?}
      ?}
   ?}
?};
_res


\toper_dok_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Przed wyświetleniem pola TOPER.DOK
::  OLD: \toper_dok_bd/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
1


\toper_dok_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Przed redagowaniem pola TOPER.DOK
::  OLD: \toper_dok_be/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
1


\be_ttm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Przed redakcją pola czasu transportu międzyoperacyjnego.
::   WY: 0/1
::  OLD: \be_ttm/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? TKTL.STAT_O='N' | VAR.KOR
|| {? TOPER.NRK().TYP().PAR='T' & TOPER.FTTM<>''
   || fld(tpar.calc(TOPER.FTTM));
      0
   || 1
   ?}
|| 0
?}


\ae_ttm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Po redakcji pola czasu transportu międzyoperacyjnego.
::   WE: [_a] - REAL - wartość pola
::   WY: 0/1
::  OLD: \ae_ttm/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
{? var_pres('_a')=type_of(0)
|| _value:=_a
|| _value:=fld();
   fld(_value$5);
   _value:=fld()
?};
{? _value<0
|| FUN.emsg('Czas odczekania nie może być ujemny.'@);
   _result:=0
?};

{? _result>0
||
   _fld:=cur_afld();
   {? _fld='TTM'
   || _fld:='TTM_T';
      exec('fld_time_init','tech_oper',_fld)
   ?}
?};
exec('efld_opt','tech_oper',TOPER,'TTM');
_result


\form_ttm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Po redakcji pola TOPER.FTTM.
::   WY: 0 / 1
::  OLD: \form_ttm/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
{? fld()<>''
|| {? tpar.chk(fld())
   || {? TKTL.STAT_O='N' | VAR.KOR
      || TOPER.TTM:=tpar.RESULT;
         {? TOPER.TTM>=0
         || _res:=1
         || exec('err_form_ltzero','tech_common');
            _res:=0
         ?};
         {? _res>0
         || _fld:='TTM_T';
            exec('fld_time_init','tech_oper',_fld)
         ?}
      ?}
   || _res:=0
   ?}
?};
exec('efld_opt','tech_oper',TOPER,'TTM');
_res


\be_nko
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Przed redakcją pola czasu nakładkowania operacji.
::   WY: 0/1
::  OLD: \be_nko/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? TKTL.STAT_O='N' | VAR.KOR
|| {? TOPER.NRK().TYP().PAR='T' & TOPER.FNKO<>''
   || fld(tpar.calc(TOPER.FNKO));
      0
   || 1
   ?}
|| 0
?}


\ae_nko
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Po redakcji pola czasu nakładkowania operacji.
::   WE: [_a] - REAL - wartość pola
::   WY: 0/1
::  OLD: \ae_nko/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
{? var_pres('_a')=type_of(0)
|| _value:=_a
|| _value:=fld();
   fld(_value$5);
   _value:=fld()
?};

{? _value>TOPER.NTIME |
   _value>TOPER.MTIME
|| _msg:='';
   {? _value>TOPER.NTIME || _msg+='\n'+'Czas nakładkowania nie może być większy niż norma czasowa.'@ ?};
   {? _value>TOPER.MTIME || _msg+='\n'+'Czas nakładkowania nie może być większy niż czas maszynowy.'@ ?};
   FUN.emsg(_msg);
   _result:=0
|? _value<0
|| FUN.emsg('Czas nakładkowania nie może być ujemny.'@);
   _result:=0
?};

{? _result>0
||
   _fld:=cur_afld();
   {? _fld='NKO'
   || _fld:='NKO_T';
      exec('fld_time_init','tech_oper',_fld)
   ?}
?};
exec('efld_opt','tech_oper',TOPER,'NKO');
_result


\form_nko
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Po redakcji pola TOPER.FNKO.
::   WY: 0 / 1
::  OLD: \form_nko/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
{? fld()<>''
|| {? tpar.chk(fld())
   || {? TKTL.STAT_O='N' | VAR.KOR
      || TOPER.NKO:=tpar.RESULT;
         {? TOPER.NKO>=0
         || {? TOPER.NKO>TOPER.NTIME |
               TOPER.NKO>TOPER.MTIME
            || FUN.emsg('Czas nakładkowania nie może być większy niż norma czasowa lub czas maszynowy.'@);
               _res:=0
            ?};
            {? _res>0
            || _fld:='NKO_T';
               exec('fld_time_init','tech_oper',_fld)
            ?}
         || exec('err_form_ltzero','tech_common');
            _res:=0
         ?}
      ?}
   || _res:=0
   ?}
?};
exec('efld_opt','tech_oper',TOPER,'NKO');
_res


\bd_grupa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Przed wyświetleniem pola GRUPA
::   WE: _a - Alias tabeli (TECHZAMS, TOPER)
::  OLD: \bd_grupa/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
1


\be_twrkzbr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Przed redakcją pola TOPER.GRUPA
::   WE: _a - Alias tabeli (TECHZAMS, TOPER)
::   WY: 0 / 1
::  OLD: \be_twrkzbr/tech_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
{? _tab.GRPOJ='G'
|| {? ~exec('tm_ohead','tech_oper') || return(0) ?};
   exec('twrkzbr_filter_wye','zasoby');
   1
|| 0
?}


\ae_twrkzb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Po redakcji pola gniazdo produkcyjne
::   WE: Alias tabeli (TECHZAMS, TOPER)
::  OLD: \ae_twrkzb/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
TWRKZPO.clear();
{? _tab.TWRKPLG<>null() & _tab.TWRKPLG().GRUPA<>_tab.GRUPA
|| _tab.TWRKPLG:=null()
?};
{? _tab.TWRKPLG=null()
|| TWRKZPO.cntx_psh();
   TWRKZPO.index('DEFAULT');
   TWRKZPO.prefix(_tab.GRUPA,'T');
   {? TWRKZPO.first()
   || _tab.TWRKPLG:=TWRKZPO.ref()
   ?};
   TWRKZPO.cntx_pop()
?};
TWRKZBR.f_clear();
{? VAR.GRP_MOD='P'
|| exec('efld_opt','tech_oper',_tab)
?};
1


\bd_twrkplg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Przed wyświetleniem pola TWRKPLG
::   WE: _a - Alias tabeli (TOPER, TECHZAMS)
::  OLD: \bd_twrkplg/tex_op1.fml
::----------------------------------------------------------------------------------------------------------------------
1


\be_twrkzpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Przed redakcją pola TOPER.TWRKPLG
::   WE: _a - Alias tabeli (TOPER, TECHZAMS)
::   WY: 0 / 1
::  OLD: \be_twrkzpo/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
{? _tab.GRPOJ='G' & _tab.GRUPA<>null()
|| {? ~exec('tm_ohead','tech_oper') || return(0) ?};
   exec('twrkzpo_filter_all','zasoby');
   1
|| 0
?}


\ae_twzpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Po redakcji pola element domyślny gniazda
::   WE: _a - Alias tabeli (TOPER, TECHZAMS)
::  OLD: \ae_twzpo/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_tab.KH:=_tab.TWRKPLG().ELEMENT().KH;
_tab.KX:=(_tab.TWRKPLG().ELEMENT().KH*_tab.MTIME)$4;
{? VAR.GRP_MOD<>'T'
|| {? _tab=TOPER
   ||
      _pwyd:=TOPER.PFAZ().WYD;
      _swyd:=TOPER.TWRKPLG().ELEMENT().WYD;
      {? _pwyd<>null() & _swyd<>null() & _pwyd<>_swyd
      || FUN.emsg('Domyślne stanowisko jest przypisane do innego wydziału niż wybrana faza produkcji.'@)
      ?};

      {? VAR1.TPZ<>'T'
      ||
         _pl_grp:=_tab.TWRKPLG().ELEMENT().PL_GRP;
         {? _tab.TWRKPLG<>null() & _tab.PL_GRP<>_pl_grp
         || {? _pl_grp='T'
            || {? FUN.ask(
                     'Stanowisko domyślne z możliwością planowania grupowego.\n'@+
                     'Czy zmienić w definicji operacji?'@
                  )
               || _tab.PL_GRP:='T'
               ?}
            || {? FUN.ask(
                     'Stanowisko domyślne bez możliwości planowania grupowego.\n'@+
                     'Czy zmienić w definicji operacji?'@
                  )
               || _tab.PL_GRP:='N'
               ?}
            ?}
         ?}
      ?}
   ?}
?};
TWRKZPO.f_clear();
1


\toper_pxkont_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wartość początkowa pola TOPER.PX_KONT
::  OLD: \toper_pxkont_bl/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
{? TOPER.WEW='N'
|| exec('get_px_kont4ver','px_kont',exec('get_mainversion','px_ver'),exec('get','#params',500360,2,null()))
|| null()
?}


\toper_pxkont_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Przed wyświetleniem pola TOPER.PX_KONT
::  OLD: \toper_pxkont_bd/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
1


\toper_pxkont_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Przed redakcją pola TOPER.PX_KONT
::  OLD: \toper_pxkont_be/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
PX_KONT.fld_fml('A','BLANK',"'T'");
PX_KONT.fld_fml('PX_VER','BLANK',"exec('get_mainversion','px_ver')");
PX_KONT.fld_fml('KIND','BLANK',"'R'");
1


\toper_pxkont_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Po redagowaniu pola TOPER.PX_KONT
::  OLD: \toper_pxkont_ae/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
PX_KONT.fld_fml('A','BLANK',"*");
PX_KONT.fld_fml('PX_VER','BLANK',"*");
PX_KONT.fld_fml('KIND','BLANK',"*");
exec('kooperacyjny','px_kont',fld())


\plgrp_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Po redagowaniu pola TOPER/TTOPER.PL_GRP
::   WE: [_a] - tabela, dla której uruchamiana: [TOPER]/TTOPER
::   WY: 0 / 1
::  OLD: \plgrp_ae/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
_tab:={? var_pres('_a')=type_of(TOPER) || _a || TOPER ?};

{? (VAR.GRP_MOD='T' & _tab.PL_GRP='T') | (VAR.GRP_MOD<>'T' & fld()='T')
||
   {? _tab=TOPER & VAR1.TPZ='T' & VAR.GRP_MOD<>'P'
   || _msg:='Nie można ustawić operacji jako grupowej, gdy przypisany jest do niej Tpz.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
      || FUN.info(_msg)
      ?};
      {? VAR.GRP_MOD<>'T' || fld():='N' ?};
      _res:=0
   |? _tab.KONTROLA='T'
   || _msg:='Nie można ustawić operacji kontroli jakości jako grupowej.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
      || FUN.info(_msg)
      ?};
      {? VAR.GRP_MOD<>'T' || fld():='N' ?};
      _res:=0
   |? _tab.KJ_BAD<>'N' & VAR.GRP_MOD<>'P'
   || _msg:='Dla operacji grupowej nie można używać kontroli jakości przez moduł badań.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
      || FUN.info(_msg)
      ?};
      {? VAR.GRP_MOD<>'T' || fld():='N' ?};
      _res:=0
   |? _tab.BAD_OP<>null() & VAR.GRP_MOD<>'P'
   || _msg:='Dla operacji grupowej nie można używać badań przeprowadzanych w trakcie wykonywania operacji.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
      || FUN.info(_msg)
      ?};
      {? VAR.GRP_MOD<>'T' || fld():='N' ?};
      _res:=0
   ?}
?};
_res


\toper_srw_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Po redagowaniu pola TOPER.SRW
::  OLD: \toper_srw_ae/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
::{? TOPER.SRW='M'
::|| TOPER.DOK:=null()
::?};
::exec('efld_opt','tech_oper',TOPER);
~~


\be_coef
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Formuła przed wyświetleniem VAR1.COEF1
::  OLD: \be_coef/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
1


\pred_cef
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Przed redakcją VAR1.COEF1
::  OLD: \pred_cef/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
{? cur_tab(1,1)<>TOPER | exec('tm_ohead','tech_oper')
|| {? VAR1.TPZ='T'
   || {? VAR1.STAWKA1=0
      || VAR1.STAWKA1:=(TOPER.OPER().STAWKA)$4
      || VAR1.PLNX:=(VAR1.PLNH1*VAR1.NTIME1)$4
      ?};
      {? cur_tab(1,1)=TOPER
      || {? TOPER.NRK().TYP().PAR='T'
         || {? VAR1.FCOEF1<>''
            || fld(tpar.calc(VAR1.FCOEF1));
               0
            || 1
            ?}
         || 1
         ?}
      || 1
      ?}
   || 0
   ?}
?}


\po_coef
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Po redakcji VAR1.COEF1
::  OLD: \po_coef/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
{? fld(fld()$4);(fld()<=0)
|| FUN.emsg('Współczynnik musi większy od zera.'@);
   0
|| VAR1.PLNH1:=(fld()*VAR1.STAWKA1)$4;
   VAR1.PLNX:=(VAR1.PLNH1*VAR1.NTIME1)$4;
   1
?}


\be_tpz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Przed redakcją pola: VAR1.TPZ (umieszczanym w oknach redagowania TOPER albo ZGP)
::   WY: 0 / 1
::  OLD: \be_tpz/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? cur_tab(1,1)=TOPER
|| {? TOPER.PL_GRP='T'
   || 0
   || (TOPER.PZ='P') & (TKTL.STAT_O='N' | VAR.KOR)
   ?}
|? cur_tab(1,1)=ZGP
|| {? ZGP.PL_GRP='T'
   || 0
   || {? -menu_txt()='popraw'
      || _tpz_ref:=exec('tpz_ref','zl_guide',ZGP.ref());
         exec('spr_kap','zl_guide') & exec('spr_kap','zl_guide',_tpz_ref) &
         exec('spr_akord','zl_guide') & exec('spr_akord','zl_guide',_tpz_ref)
      || 1
      ?}
   ?}
|| 0
?}


\aftoperp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.10]
:: OPIS: Formuła po redakcji pola VAR1.TPZ na zakładce TPZ karty albo pozycji przewodnika
::  OLD: \aftoperp/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
{? cur_tab(1,1)=TOPER
|| {? VAR1.TPZ='T'
   || VAR1.COEF1:=1;
      VAR1.FCOEF1:='1';
      {? VAR1.STAWKA1=0
      || VAR1.STAWKA1:=TOPER.OPER().STAWKA;
         VAR1.PLNH1:=(VAR1.COEF1*VAR1.STAWKA1)$4
      ?}
   ?};
   exec('efld_opt','tech_oper',TOPER)
|? cur_tab(1,1)=ZGP
|| exec('zgp_efld_opt','zl_guide')
?};
1


\pred_tpz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Przed redakcją pól na zakładce TPZ karty albo pozycji przewodnika
::  OLD: \pred_tpz/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
{? cur_tab(1,1)=TOPER
|| {? ~exec('tm_ohead','tech_oper') || return(0) ?}
|? cur_tab(1,1)=ZGP
|| {? ZGP.TOPER=null()
   || VAR1.PLNX:=(VAR1.PLNH1*VAR1.NTIME1)$4
   ?}
?};
VAR1.TPZ='T'


\pred_fcf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Przed redakcją VAR1.FCOEF1
::  OLD: \pred_fcf/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('tm_ohead','tech_oper') & VAR1.TPZ='T'


\f3_fcf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Na F3 VAR1.FCOEF1
::  OLD: \f3_fcf/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('F3_TPAR','tech_param')


\po_fcf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Po redakcji VAR1.FCOEF1
::  OLD: \po_fcf/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
{? fld()<>''
|| {? tpar.chk(fld())
   || {? exec('tm_ohead','tech_oper')
      || VAR1.COEF1:=tpar.RESULT;
         {? VAR1.COEF1>0
         || VAR1.PLNH1:=(VAR1.COEF1*VAR1.STAWKA1)$4;
            VAR1.PLNX:=(VAR1.PLNH1*VAR1.NTIME1)$4
         || exec('err_form_lgzero','tech_common');
            _res:=0
         ?}
      ?}
   || _res
   ?}
?};
_res


\be_fcf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Formuła na wartość początkową VAR1.FCOEF1 ??? podpięta przed wyświetleniem!!!
::  OLD: \be_fcf/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
'1'


\pred_fnt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Przed redakcją VAR1.FNTIME1
::  OLD: \pred_fnt/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('tm_onc','tech_oper') & VAR1.TPZ='T'


\po_fnt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Po redakcji VAR1.FNTIME1
::  OLD: \po_fnt/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
{? fld()<>''
|| {? tpar.chk(fld())
   || {? exec('tm_onc','tech_oper')
      || VAR1.NTIME1:=tpar.RESULT;
         {? VAR1.NTIME1>0
         || VAR1.PLNH1:=VAR1.STAWKA1*VAR1.COEF1;
            VAR1.PLNX:=(VAR1.PLNH1*VAR1.NTIME1)$4;
            1
         || exec('err_form_lgzero','tech_common');
            _res:=0
         ?}
      ?}
   || _res:=0
   ?}
?};
_res


\f3_fnt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Na F3 VAR1.FNTIME1
::  OLD: \f3_fnt/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('F3_TPAR','tech_param')


\pred_nti
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Przed redakcją VAR1.NTIME1 (zakładka Tpz dla TOPER i ZGP)
::  OLD: \pred_nti/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('pred_tpz','tech_oper')
|| {? cur_tab(1,1)=TOPER
   || {? VAR1.FNTIME1<>''
      || fld(tpar.calc(VAR1.FNTIME1));
         0
      || 1
      ?}
   |? cur_tab(1,1)=ZGP
   || 1
   || 0
   ?}
|| 0
?}


\po_nti
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Po redakcji VAR1.NTIME1 (zakładka Tpz dla TOPER i ZGP)
::  OLD: \po_nti/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
{? fld()>0
|| {? cur_tab(1,1)=TOPER
   || VAR1.PLNH1:=(VAR1.STAWKA1*VAR1.COEF1)$4;
      VAR1.PLNX:=(VAR1.PLNH1*VAR1.NTIME1)$4
   |? cur_tab(1,1)=ZGP
   || VAR1.PLNX:=(VAR1.PLNH1*VAR1.NTIME1)$4
   ?};
   1
|| FUN.emsg('Wartość pola musi być większa od zera.'@);
   0
?}


\po_r_st
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Po redakcji pola VAR1.STAWKA1
::  OLD: \po_r_st/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
{? fld()>=0
|| VAR1.PLNH1:=(VAR1.STAWKA1*VAR1.COEF1)$4;
   VAR1.PLNX:=(VAR1.PLNH1*VAR1.NTIME1)$4;
   1
|| FUN.emsg('Wartość pola musi być nieujemna.'@);
   0
?}


\var1_plnh1_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JA [12.10]
:: OPIS: Po redakcji pola VAR1.PLNH1 (zakładka Tpz dla TOPER i ZGP)
::   WT: 0/1 uzupełnione albo nie
::  OLD: \zgpplnxbr/zl_akor1.fml
::----------------------------------------------------------------------------------------------------------------------
{? cur_tab(1,1)=ZGP
|| {? fld()>=0
   || VAR1.PLNX:=(VAR1.PLNH1*VAR1.NTIME1)$2;
      1
   || FUN.emsg('Wartość pola musi być nieujemna.'@);
      0
   ?}
|| 1
?}


\toper_fld_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Przed redagowaniem pól w tabeli TOPER (NTIME_T,MTIME_T,TTM_T,NKO_T)
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
VAR_DEL.delete('TOPER_BEFORE');
TOPER_BEFORE:=exec('obj_new','#buf','TOPER',);

_result:=1;

_fld:=cur_afld();
{? (_fld+2)='_T'
||
:: Sprawdzam czy mogę w ogóle redagować
   _fld_real:=_fld-2;
   _fld_formula:='F'+_fld_real;
   _formula:=($('TOPER.'+_fld_formula))();
   {? TOPER.NRK().TYP().PAR='T' & _formula<>''
   || _result:=0
   ?};

   _value_time:=exec('fld_time_init','tech_oper',_fld);
   _value_real:=($('TOPER.'+_fld_real))();
   {? _value_time=time(0,0,0) & _value_real>0
   || _result:=0;
      TOPER.efld_opt(cur_win(1,1),'editable=grayed',,_fld)
   ?}
?};
win_disp();
TOPER_BEFORE.get();
_result


\toper_fld_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Po redagowaniu pól w tabeli TOPER (NTIME_T,MTIME_T,TTM_T,NKO_T)
::   WE:
::   WY:
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_fld:=cur_afld();
{? var_pres('TOPER_BEFORE')>100 & (_fld+2)='_T'
||
   _value_before:=($('TOPER_BEFORE.'+_fld))();
   _value_current:=($('TOPER.'+_fld))();
   {? _value_before<>_value_current
   || exec('fld_time_calc','tech_oper',_fld)
   ?};
   win_disp()
?};
{? _fld='NTIME_T'
|| _result:=exec('ae_normc','tech_oper',TOPER.NTIME)
?};
{? _fld='MTIME_T'
|| _result:=exec('ae_mtime','tech_oper',TOPER.MTIME)
?};
{? _fld='TTM_T'
|| _result:=exec('ae_ttm','tech_oper',TOPER.TTM)
?};
{? _fld='NKO_T'
|| _result:=exec('ae_nko','tech_oper',TOPER.NKO)
?};
{? _result>0
|| VAR_DEL.delete('TOPER_BEFORE')
|| ($('TOPER_BEFORE.'+_fld+':=_a'))(time(-1,0,0))
?};
_result


\fld_time_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Nawija wartość pola TIME
::   WE: _a - STRING - akronim pola TIME
::   WY: TIME - nawinięta wartość
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_fld:=_a;
_fld_real:=_fld-2;
_value_real:=($('TOPER.'+_fld_real))();
_value_time:=exec('float2time','#convert',_value_real);
($('TOPER.'+_fld+':=_a'))(_value_time);
_value_time


\fld_time_calc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.14]
:: OPIS: Przelicza wartość pola TIME na czas techniczny i umieszcza go w odpowiednim polu
::   WE: _a - STRING - akronim pola TIME
::   WY: REAL - przeliczona wartość
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_fld:=_a;
_fld_real:=_fld-2;
_value_time:=($('TOPER.'+_fld))();
_value_real:=exec('time2float','#convert',_value_time);
($('TOPER.'+_fld_real+':=_a'))(_value_real);
_value_real


\toper_fld_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Format wyświetlania pól w tabeli TOPER (NTIME, MTIME, TTM, NKO)
::                               w zmiennej VAR1 (NTIME1) (zakładka Tpz dla TOPER i ZGP)
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:='';
{? _fld='NTIME' | _fld='MTIME' | _fld='TTM' | _fld='NKO' | _fld='NTIME1'
|| _result:='out_prec='+$exec('get','#params',500604,1)
|? (_fld+2)='_T'
|| _result:='hour_chars=3'
?};
_result


\toper_fld_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Format redagowania pól w tabeli TOPER (NTIME, MTIME, TTM, NKO)
::                               w zmiennej VAR1 (NTIME1) (zakładka Tpz dla TOPER i ZGP)
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_result:='';
{? _fld='NTIME' | _fld='MTIME' | _fld='TTM' | _fld='NKO' | _fld='NTIME1'
|| _result:='in_prec='+$exec('get','#params',500604,1)
|? (_fld+2)='_T'
|| _result:='hour_chars=3'
?};
_result


\a_oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Zwraca VAR.A_OP
::   WY: VAR.A_OP
::  OLD: \a_oper/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_OP


\a_op_oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: GZ [2010]
:: OPIS: Zwraca wskazanie na TTOPER operacji przechowyw. w VAR.A_OP
::   WY: VAR.A_OP().OPER
::  OLD: \a_op_oper/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_OP().OPER


\a_przl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Zwraca VAR.A_PRZL (operacja prosta "P" czy złożona "Z")
::   WY: VAR.A_PRZL
::  OLD: \a_przl/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_PRZL


\a_wew
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [2010]
:: OPIS: Zwraca VAR.A_WEW (operacja wewnętrzna "T", czy zewnętrzna "N")
::   WY: VAR.A_WEW
::  OLD: \a_wew/varget.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.A_WEW


\topearec
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Obsługa po redakcji okienka redakcji operacji
::       (wykorzystywana również jako formuła walidacyjna podczas importu)
::   WE: [_a] - czy import przez Excele: [0]/1
::  OLD: \topearec/tex_oper.fml
::  TAG: <CHK>
::----------------------------------------------------------------------------------------------------------------------
_import:={? var_pres('_a')=type_of(0) || _a || 0 ?};
{? _import>0
|| VAR.GRUPA:=VAR.GRP_MOD:='N';
   VAR.KOR:=0
?};
_par:=(TOPER.NRK().TYP().PAR='T');
{? VAR.GRP_MOD<>'P' & ~_import
|| {? _par & TOPER.FCOEF<>'' || TOPER.COEF:=tpar.calc(TOPER.FCOEF) ?};
   {? _par & TOPER.FNTIME<>'' || TOPER.NTIME:=tpar.calc(TOPER.FNTIME) ?};
   {? _par & (TOPER.FCOEF<>'') | (TOPER.FNTIME<>'')
   || TOPER.PLNH:=(TOPER.COEF*TOPER.OPER().STAWKA)$4;
      TOPER.PLNX:=(TOPER.PLNH*TOPER.NTIME)$4
   ?};
   {? _par & TOPER.FMTIME<>''
   || TOPER.MTIME:=tpar.calc(TOPER.FMTIME);
      TOPER.KX:=(TOPER.KH*TOPER.MTIME)$4
   ?};
   {? _par & TOPER.FCENA<>'' || TOPER.CENA:=tpar.calc(TOPER.FCENA) ?};
   {? _par & TOPER.FTTM<>'' || TOPER.TTM:=tpar.calc(TOPER.FTTM) ?};
   {? _par & TOPER.FNKO<>'' || TOPER.NKO:=tpar.calc(TOPER.FNKO) ?}
?};
_res:='';
_chk_rec:=0;
{? TOPER.PZ='P' & TOPER.WEW='T'
|| _pwyd:=TOPER.PFAZ().WYD;
   {? TOPER.GRPOJ='S' & TOPER.PLACE<>null() & _pwyd<>null() & TOPER.PLACE().WYD<>null() & _pwyd<>TOPER.PLACE().WYD
   || _msg:='Stanowisko jest przypisane do innego wydziału niż wybrana faza produkcji.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
      || FUN.emsg(_msg)
      ?};
      _res:='PLACE'
   |? TOPER.GRPOJ='G' & TOPER.GRUPA<>null() & _pwyd<>null() & TOPER.GRUPA().WYD<>null() & _pwyd<>TOPER.GRUPA().WYD
   || _msg:='Gniazdo jest przypisane do innego wydziału niż wybrana faza produkcji.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
      || FUN.emsg(_msg)
      ?};
      _res:='GRUPA'
   |? TOPER.GRPOJ='G' & TOPER.TWRKPLG<>null() & _pwyd<>null() & TOPER.TWRKPLG().ELEMENT().WYD<>null() & _pwyd<>TOPER.TWRKPLG().ELEMENT().WYD
   || _msg:='Domyślne stanowisko jest przypisane do innego wydziału niż wybrana faza produkcji.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
      || FUN.emsg(_msg)
      ?};
      _res:='TWRKPLG'
   || {? VAR.GRP_MOD<>'P'
      || {? TOPER.GRPOJ='S'
         || {? VAR.GRUPA='T'
            || _res:=__CHK.record(TOPER,0,'NROP','OPER','PLACE');
               {? _res<>'' || _chk_rec:=1 ?}
            || {? _import & TOPER.TPZ<>'N'
               || _res:=__CHK.record2(TOPER,'NROP','Numer operacji'@,'PLACE','Stanowisko'@)
               || _res:=__CHK.record2(TOPER,'NROP','Numer operacji'@,'OPER','Operacja'@,'PLACE','Stanowisko'@)
               ?}
            ?}
         || {? VAR.GRUPA='T'
            || _res:=__CHK.record(TOPER,0,'NROP','OPER','GRUPA','TWRKPLG');
               {? _res<>'' || _chk_rec:=1 ?}
            || {? _import & TOPER.TPZ<>'N'
               || _res:=__CHK.record2(TOPER,
                     'NROP','Numer operacji'@,'GRUPA','Gniazdo'@,'TWRKPLG','Domyślne stanowisko'@)
               || _res:=__CHK.record2(TOPER,
                     'NROP','Numer operacji'@,'OPER','Operacja'@,'GRUPA','Gniazdo'@,'TWRKPLG','Domyślne stanowisko'@)
               ?}
            ?}
         ?}
      || {? TOPER.GRPOJ='G' & TOPER.GRUPA<>null() & TOPER.TWRKPLG=null()
         || _res:=__CHK.record2(TOPER,'TWRKPLG','Domyślne stanowisko'@)
         ?}
      ?}
   ?}
|? TOPER.WEW='N'
|| {? VAR.GRP_MOD<>'P'
   || {? VAR.GRUPA='T'
      || _res:=__CHK.record(TOPER,0,'NROP','TTOUT','COEF');
         {? _res<>'' || _chk_rec:=1 ?}
      || {? _par
         || _res:=__CHK.record2(TOPER,'NROP','Numer'@,'TTOUT','Operacja'@,'COEF','Przelicznik'@);
            {? _res='COEF' || _res:='FCOEF' ?}
         || _res:=__CHK.record2(TOPER,'NROP','Numer'@,'TTOUT','Operacja'@,'COEF','Przelicznik'@)
         ?}
      ?}
   ?}
|? TOPER.PZ='Z'
|| {? VAR.GRP_MOD<>'P'
   || {? VAR.GRUPA='T'
      || _res:=__CHK.record(TOPER,0,'NROP','NA')
      || _res:=__CHK.record2(TOPER,'NROP','Numer'@,'NA','Nazwa'@)
      ?}
   ?}
|| {? VAR.GRP_MOD<>'P' & ~_import
   || _res:=chk_rec()
   ?}
?};
{? ~_import & VAR.GRUPA='T' & _chk_rec>0 & _res<>''
|| _fld:={? _res='NROP' || 'Numer operacji'@ |? _res='OPER' | _res='TTOUT' || 'Operacja'@
         |? _res='PLACE' || 'Stanowisko'@ |? _res='GRUPA' || 'Gniazdo'@ |? _res='TWRKPLG' || 'Domyślne stanowisko'@
         |? _res='COEF' || 'Przelicznik'@ |? _res='NA' || 'Nazwa'@ || '' ?};
   _msg:='Pole \'%1\' musi być wypełnione. Należy uzupełnić brakujące informacje.'@[_fld];
   KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
?};
{? VAR.GRP_MOD<>'P'
|| {? _res='' & TOPER.PZ='P' & TOPER.WEW='T' & TOPER.MTIME=0 & TOPER.NTIME=0
   || _msg:='Czas maszynowy lub norma czasowa musi być różna od zera.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
      || FUN.emsg(_msg)
      ?};
      _res:={? _par || {? TOPER.FNTIME<>'' || 'FNTIME' || 'NTIME' ?} || 'NTIME' ?}
   ?};
   {? _res='' & TOPER.PZ='P' & TOPER.WEW='T' & TOPER.NTIME<0
   ||  _msg:='Norma czasowa nie może być ujemna.'@;
       {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
      || FUN.emsg(_msg)
      ?};
      _res:={? _par || {? TOPER.FNTIME<>'' || 'FNTIME' || 'NTIME' ?} || 'NTIME' ?}
   ?};
   {? _res='' & TOPER.PZ='P' & TOPER.WEW='T' & TOPER.MTIME<0
   || _msg:='Czas maszynowy nie może być ujemny.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
      || FUN.emsg(_msg)
      ?};
      _res:={? _par || {? TOPER.FMTIME<>'' || 'FMTIME' || 'MTIME' ?} || 'MTIME' ?}
   ?};
   {? _res='' & TOPER.PZ='P' & TOPER.WEW='T' & TOPER.TTM<0
   || _msg:='Czas odczekania nie może być ujemny.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
      || FUN.emsg(_msg)
      ?};
      _res:={? _par || {? TOPER.FTTM<>'' || 'FTTM' || 'TTM' ?} || 'TTM' ?}
   ?};
   {? _res='' & TOPER.PZ='P' & TOPER.WEW='T' & TOPER.NKO<0
   || _msg:='Czas nakładkowania nie może być ujemny.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
      || FUN.emsg(_msg)
      ?};
      _res:={? _par || {? TOPER.FNKO<>'' || 'FNKO' || 'NKO' ?} || 'NKO' ?}
   ?};
   {? _res='' & TOPER.PZ='P' & TOPER.COEF<=0
   || {? TOPER.WEW='T'
      || _msg:='Współczynnik musi być większy od zera.'@;
         {? VAR.GRUPA='T'
         || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
         || FUN.emsg(_msg)
         ?}
      || _msg:='Przelicznik musi być większy od zera.'@;
         {? VAR.GRUPA='T'
         || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
         || FUN.emsg(_msg)
         ?}
      ?};
      {? _par || {? TOPER.FCOEF='' || _res:='COEF' || _res:='FCOEF' ?} || _res:='COEF' ?}
   ?};
   {? _import
   || {? _res='' & TOPER.TPZ='T' & (TOPER.NTIME<=0 | TOPER.COEF<=0)
      || FUN.emsg('Norma czasowa i współczynnik operacji TPZ muszą być większe od zera.'@);
         {? TOPER.COEF=0
         || _res:='COEF'
         || _res:={? _par || {? TOPER.FNTIME<>'' || 'FNTIME' || 'NTIME' ?} || 'NTIME' ?}
         ?}
      ?}
   || {? _res='' & VAR1.TPZ='T' & (VAR1.NTIME1<=0 | VAR1.COEF1<=0)
      || _msg:='Norma czasowa i współczynnik operacji TPZ muszą być większe od zera.'@;
         {? VAR.GRUPA='T'
         || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
         || FUN.emsg(_msg)
         ?};
         {? VAR1.COEF1=0
         || _res:='COEF1'
         || _res:={? _par || {? VAR1.FNTIME1<>'' || 'FNTIME1' || 'NTIME1' ?} || 'NTIME1' ?}
         ?}
      ?}
   ?};
   {? _res=''
   || {? TOPER.NTIME=0 & TOPER.BRYG='T'
      || _msg:='Dla operacji z samym czasem maszynowym nie można ustawić rozliczenia brygadowego.'@;
         {? VAR.GRUPA='T'
         || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
         || FUN.info(_msg)
         ?};
         _res:='BRYG'
      ?}
   ?}
?};
{? _res='' & ~_import & VAR.KOR
|| {? TOPER.CAUSE=null()
   || _msg:='Należy podać przyczynę zmiany.'@;
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
      || FUN.emsg(_msg)
      ?};
      _res:='CAUSE'
   ?}
?};

{? _res='' & ~_import & exec('tpp_lic','tpp')='T' & TOPER.WEW='N' & VAR.GRP_MOD='N'
|| _msg:='';
   {? TOPER.DAYS_K=0                                || _msg:='\n• '+'Szacunkowa ilość dni na kooperację'@ ?};
   {? TOPER.PX_KONT=null()
      & exec('get','#params',500361,1,null())=0 || _msg+='\n• '+'Zasób kooperacyjny lub parametr %1'@['500361'] ?};
   {? _msg<>''
   || FUN.info('Wskazane jest uzupełnienie danych, o ile będą wykorzystywane moduły planowania:'@+_msg)
   ?}
?};
::{? _res='' & TOPER.WEW='N' & TOPER.SRW='M' & TOPER.DOK<>null()
::|| FUN.emsg('Kooperacja z rejestracją magazynową nie może mieć przypisanego typu dokumentu.'@);
::   _res:='TTOUT'
::?};
{? _res='' & TOPER.KJ_BAD='B' & TOPER.BADSEH=null()
|| _msg:='Należy wybrać zestaw badań używany podczas kontroli jakości.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
   || FUN.emsg(_msg)
   ?};
   _res:='BADSEH'
?};
{? _res='' & ~_import & VAR.KOR & VAR.GRP_MOD<>'P'
|| {? TOPER.PL_GRP='T'
   || {? exec('valid_oper_plgr','tech_oper')=0
      || _res:='PL_GRP'
      ?}
   ?}
?};
{? _res='' & TOPER.PZ='P'
|| _res:=exec('valid_toper','zl_uslugi')
?};
{? _res='' & TOPER.WYK_FAST='T'
|| {? TOPER.KJ_BAD<>'N'
   || _res:='WYK_FAST';
      FUN.emsg('Operacja ze sposobem potwierdzania nie może być rejestrowana w szybki sposób.'@)
   |? TOPER.BRYG='T'
   || _res:='WYK_FAST';
      FUN.emsg('Operacja wykonywana przez brygadę nie może być rejestrowana w szybki sposób.'@)
   |? TOPER.PL_GRP='T'
   || _res:='WYK_FAST';
      FUN.emsg('Operacja planowana grupowo nie może być rejestrowana w szybki sposób.'@)
   ?}
?};
_res


\toperd_a
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Po dołączeniu rekordu w operacjach technologii
::  OLD: \toperd_a/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
{? TOPER.NTIME=0
|| TOPER.BRYG:='N';
   TOPER.put()
?};
{? TOPER.PZ='P'
|| {? VAR1.TPZ='T'
   || _unrop:=TOPER.UNROP;
      _nrop:=TOPER.NROP;
      _place:=TOPER.PLACE;
      _grpoj:=TOPER.GRPOJ;
      _grupa:=TOPER.GRUPA;
      _twrkplg:=TOPER.TWRKPLG;
      _kontrola:=TOPER.KONTROLA;
      _bryg:=TOPER.BRYG;
      _where:=TOPER.WHERE;
      TOPER.cntx_psh();
      TOPER.prefix();
      TOPER.blank();
      TOPER.PZ:='P';
      TOPER.WEW:='T';
      TOPER.NROP:=_nrop;
      TOPER.TPZ:='T';
      TOPER.BRYG:=_bryg;
      TOPER.ZAW:=VAR1.ZAW;
      TOPER.COEF:=VAR1.COEF1;
      TOPER.FCOEF:=VAR1.FCOEF1;
      TOPER.NTIME:=VAR1.NTIME1;
      TOPER.FNTIME:=VAR1.FNTIME1;
      TOPER.KH:=VAR1.STAWKA1;
      TOPER.PLNH:=(VAR1.STAWKA1*VAR1.COEF1)$4;
      TOPER.PLNX:=(TOPER.PLNH*VAR1.NTIME1)$4;
      TOPER.CIAGLA:=VAR1.CIAGLA;
      TOPER.TPZREF:=_unrop;
      TOPER.PLACE:=_place;
      TOPER.GRPOJ:=_grpoj;
      TOPER.GRUPA:=_grupa;
      TOPER.TWRKPLG:=_twrkplg;
      TOPER.KONTROLA:=_kontrola;
      TOPER.WHERE:=_where;
:: Wyłączony komunikat ze względu na swoją uciążliwość
::      _norma:=exec('ust_norm','tex_ope1',{? TOPER.PFAZ<>null()
::                                         || TOPER.PFAZ().WYD().KOD
::                                         |? TKTL.JORG<>null()
::                                         || TKTL.JORG().KOD
::                                         || ST.A_WYD().KOD
::                                         ?});
::      {? TOPER.NTIME>_norma
::      || FUN.info('Wprowadzony czas pracy dla operacji TPZ to: '+form(TOPER.NTIME)+
::         '. \n Jest to operacja niepodzielna, w przypadku tworzenia harmonogramu \n'+
::         ' należy zadbać, aby czas pracy kalendarza był większy od czasu TPZ.')
::      ?};
      TOPER.add();
      TOPER.cntx_pop()
   ?}
?};
::Aktualizacja przepisu planistycznego technologii (jeżeli istnieje)
_p500369:=exec('get','#params',500369,type_of(''));
{? _p500369='T' & TOPER.NRK<>null() & exec('get_tex_tktl','px_tex',$TOPER.NRK)
|| exec('tktl_tex_update','px_tex',TOPER.NRK,0,1,exec('get','#params',500367)='T',,1,1)
?};
0


\get_nast_nums
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: pobiera listę numerów operacji - następnikow
::   WE: _a - TOPER.ref()
::   WY: lista numerów operacji
::  OLD: \get_nast_nums/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_rTOPER:=_a;
_sRes:='';
TOPER.cntx_psh();
NASTOPER.cntx_psh();
NASTOPER.index('OPNAST');
NASTOPER.prefix('T',_rTOPER);
{? NASTOPER.first()
|| {!
   |? _bEmptyRes:=(+_sRes=0);
      _sRes+={? ~_bEmptyRes || '; ' || '' ?}+exec('get_oper_nr','tech_oper',NASTOPER.NRNAST().UNROP,'\\');
      NASTOPER.next()
   !}
?};
NASTOPER.cntx_pop();
TOPER.cntx_pop();
_sRes


\toperbre
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: przed rekord operacji
::  OLD: \toperbre/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_result:='';

{? VAR.A_KTL<>null()
|| {? TKTL.name()<>ref_name(VAR.A_KTL) || exec('tktl_use','tech_common',ref_name(VAR.A_KTL)+3) ?};
   _par:=VAR.A_KTL().TYP().PAR;
   {? TOPER.PZ='P' & TOPER.WEW='T'
   || TOPER.win_edit('RED_SIM'+_par);
      TECHZAMS.win_edit('RED_'+_par);
      VAR.STRING:=TOPER.OPER().NA;
      VAR.A_PFAZ:=TOPER.PFAZ;
      {? TOPER.ACT='N'
      || _result:='TOPER#02#02'
      || _result:='TOPER#01#03'
      ?}
   |? TOPER.PZ='Z' & TOPER.WEW='T'
   || TOPER.win_edit('RED_ADW'+_par);
      VAR.STRING:=TOPER.NA;
      VAR.A_PFAZ:=TOPER.PFAZ;
      {? TOPER.ACT='N'
      || _result:='TOPER#02#02'
      || _result:='TOPER#01#01'
      ?}
   |? TOPER.PZ='P' & TOPER.WEW='N'
   || TOPER.win_edit('RED_OUT'+_par);
      VAR.STRING:=TOPER.TTOUT().NA;
      VAR.A_PFAZ:=TOPER.PFAZ;
      {? TOPER.ACT='N'
      || _result:='TOPER#02#02'
      || _result:='TOPER#01#04'
      ?}
   || ~~
   ?}
?};
_result


\legenda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2008]
:: OPIS: Legenda w oknie operacji (tabela TOPER)
::  OLD: \legenda/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.A_KTL().TORW='W'
|| exec('legenda','color','TOPER#01#','#OPER#')
|| exec('legenda','color','TOPER#01#','TOPER#02#','#OPER#')
?}


\TOPER_kasuj
::----------------------------------------------------------------------------------------------------------------------
::  MOD: [TS] - 2002/06/28
::  MOD: MKO [8.70]
:: OPIS: Kasuje  wszystkie operacje do karty
::       Użyte w TKTL_kasuj/tech_head oraz tktl_copy/tech_arch (w obu przypadkach w transakcji)
::   WE: _a - TKTL.ref()
::       [_b] - czy wyswietlać komunikaty (domyślnie 1) czy nie (ładowane do KOMM - 0)
::   WY: 0 / 1
::  OLD: \TOPER/tkasuj.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
{? var_pres('_b')=type_of(0) || _display:=_b || _display:=1 ?};

_result:=1;
_can_continue:=1;

TOPER.clear();
TOPER.index('NNN');
TOPER.prefix(_tktl);
{? TOPER.first()
|| {!
   |? exec('UAT_kasuj','tech_atr','TOPER',TOPER.ref());
      exec('del_nastoper','tech_oper',TOPER.ref(),'T');
      exec('del_nastoper','tech_oper',TOPER.ref(),'N');
      exec('toper_clean','px_stage');
      DocLib.del('TOPER',TOPER.ref());
      _unrop:=TOPER.UNROP;
      exec('ae_topde','tech_oper',_unrop);
      {? TOPER.count()>0
      || _msg:='Operacji '+exec('get_oper_nr','tech_oper',TOPER.UNROP)+' nie udało się usunąć — należy sprawdzić powiązania.';
         {? _display
         || FUN.emsg(_msg)
         || KOMM.add(_msg,2,,1)
         ?};
         _result:=0
      || _can_continue:=TOPER.del()
      ?};
      _result>0 & _can_continue>0
   !}
?};
_result


\TOPER_TREE_kasuj
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: kasuje operację i wszystko do niej podpięte
::  OLD: \TOPER_TREE/tkasuj.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.GRUPA='T' | FUN.ask('Czy usunąć całą operację i dane z nią powiązane?')
|| _tktl_locked_s:=exec('tktl_lock','tech_common',VAR.A_KTL,'S',1);
   _tktl_locked_p:=exec('tktl_lock','tech_common',VAR.A_KTL,'P',1);
   do();
   TOPER.cntx_psh();
   exec('toper_clean','px_stage');
   DocLib.del('TOPER',TOPER.ref());
   exec('TOPER_ONE_kasuj','tech_oper',VAR.A_KTL,TOPER.ref(),_tktl_locked_s,_tktl_locked_p);
   TOPER.cntx_pop();
   TOPER.del();
   end();
   {? _tktl_locked_s || exec('tktl_unlock','tech_common',VAR.A_KTL,'S') ?};
   {? _tktl_locked_p || exec('tktl_unlock','tech_common',VAR.A_KTL,'P') ?};
   VAR.A_OP:=null()
?};
0


\TOPER_ONE_kasuj
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Kasuje dane powiązane z jedną operacją - zamienniki, surowce, narzędzia, tpz, atrybuty
::       Użyte w TOPER_TREE_kasuj/tech_oper (w transakcji)
::   WE: _a - TKTL.ref()
::       _b - TOPER.ref()
::       _c - czy udało się zablokować redagowanie surowców
::       _d - czy udało się zablokować redagowanie danych pozostałych
::  OLD: \TOPER_ONE/tkasuj.fml
::----------------------------------------------------------------------------------------------------------------------
_karta:=_a;
_operacja:=_b;
_tktl_locked_s:=_c;
_tktl_locked_p:=_d;

TOPER.cntx_psh();
TOPER.clear();
{? TOPER.seek(_operacja)
|| _unrop:=TOPER.UNROP;
   TCHMAT.index('SL');
   TMAT.clear();
   TMAT.index('NNL');
   TMAT.prefix(_karta,_operacja);
   {? TMAT.first()
   || {? TKTL.STAT_S='T'
      || {? VAR.GRUPA='T'
         || KOMM.add(
               'Nie można usunąć operacji '+exec('get_oper_nr','tech_oper',_unrop)+
               ' z powiązanymi surowcami. Zakończono już redagowanie surowców.',,,1
            );
            undo()
         || undo('Nie można usunąć operacji z powiązanymi surowcami.\nZakończono już redagowanie surowców.')
         ?}
      ?};
      {? _tktl_locked_s
      || {!
         |? TCHMAT.clear();
            TCHMAT.prefix(TMAT.ref());
            {? TCHMAT.first()
            || {!
               |?
                  DocLib.del('TCHMAT',TCHMAT.ref());
                  exec('usuntchpar','tech_param');
                  TCHMAT.del()
               !}
            ?};
            DocLib.del('TMAT',TMAT.ref());
            exec('usuntpar','tech_param');
            TMAT.del()
         !}
      || {? VAR.GRUPA='T'
         || KOMM.add(
               'Nie można usunąć operacji '+exec('get_oper_nr','tech_oper',_unrop)+
               ' z powiązanymi surowcami. Surowce są redagowane w innej sesji programu.',,,1
            );
            undo()
         || undo('Nie można usunąć operacji z powiązanymi surowcami.\nSurowce są redagowane w innej sesji programu.')
         ?}
      ?}
   ?};

   TACTTLS.clear();
   TACTTLS.index('KNROP');
   TACTTLS.prefix(_karta,_operacja);
   {? TACTTLS.first()
   || {? TKTL.STAT_P='T'
      || {? VAR.GRUPA='T'
         || KOMM.add(
               'Nie można usunąć operacji '+exec('get_oper_nr','tech_oper',_unrop)+
               ' z powiązanymi N-P-U. Zakończono już redagowanie pozostałych danych.',,,1
            );
            undo()
         || undo('Nie można usunąć operacji z powiązanymi N-P-U.\nZakończono już redagowanie pozostałych danych.')
         ?}
      ?};
      {? _tktl_locked_p
      || {!
         |?
            DocLib.del('TACTTLS',TACTTLS.ref());
            TACTTLS.del()
         !}
      || {? VAR.GRUPA='T'
         || KOMM.add(
               'Nie można usunąć operacji '+exec('get_oper_nr','tech_oper',_unrop)+
               ' z powiązanymi N-P-U. Pozostałe dane karty są redagowane w innej sesji programu.',,,1
            );
            undo()
         || undo('Nie można usunąć operacji z powiązanymi N-P-U.\nPozostałe dane karty są redagowane w innej sesji programu.')
         ?}
      ?}
   ?};

   exec('toper_clean','px_stage',_operacja);
   TECHZAMS.cntx_psh();
   TECHZAMS.index('TL');
   TECHZAMS.prefix(TOPER.ref());
   {? TECHZAMS.first()
   || {! |? TECHZAMS.del() !}
   ?};
   TECHZAMS.cntx_pop();

   TOPER.cntx_psh();
   TOPER.index('TPZ');
   TOPER.prefix('T',TOPER.UNROP);
   {? TOPER.first()
   || TOPER.del()
   ?};
   TOPER.cntx_pop();
   exec('del_nastoper','tech_oper',TOPER.ref());
   TOPER.cntx_psh();
   TOPER.clear();
   TOPER.index('NNN');
   TOPER.prefix(_karta,_unrop);
   {? TOPER.first()
   || {!
      |?
         DocLib.del('TOPER',TOPER.ref());
         exec('TOPER_ONE_kasuj','tech_oper',_karta,TOPER.ref(),_tktl_locked_s,_tktl_locked_p);
         TOPER.del()
      !}
   ?};
   TOPER.cntx_pop();
   exec('UAT_kasuj','tech_atr','TOPER',TOPER.ref())
?};
TOPER.cntx_pop();
~~


\zm_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: Zmiana - usunięcie (dezaktualizacja)/przywrócenie operacji na zatwierdzonej technologii
::   WE: _a - _a - usuwanie-czy z dialogiem (1/0), przywracanie-czy z dialogiem (3/2)
::      [_b] - data
::      [_c] - przyczyna TTXCAUSE.ref()
::      [_d] - znacznik czasowy
::  OLD: \zm_usun/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
:: czy tryb przywracania
_przywr:=_a>1;
:: czy z oknem dialogowym
_bDialog:=_a-2*_przywr;

{? var_pres('_b')=type_of(date()) || _dData:=_b || _dData:=date() ?};
{? var_pres('_c')=type_of(null()) || _rCause:=_c || _rCause:=null() ?};
{? var_pres('_d')=type_of(0) || _tmstamp:=_d || _tmstamp:=TOPER.tm_stamp() ?};
{? var_pres('_e')=type_of(0) || _oldstamp:=_e || _oldstamp:=TOPER.MOD_TIME ?};

{? _przywr
|| {? TOPER.ACT='T'
   || {? _bDialog || FUN.emsg('Element aktywny — nie można go przywracać.'@) ?};
      return()
   ?}
|| {? TOPER.ACT='N'
   || {? _bDialog || FUN.emsg('Element nieaktywny — nie można modyfikować.'@) ?};
      return()
   ?}
?};
VAR.KOR:=1;
_win_edit:=TOPER.win_edit('?');

{? _przywr
|| TOPER.win_edit('PRZYWR')
|| TOPER.win_edit('USUN')
?};

{? ~_bDialog
      |
   FUN.ask(
      'Modyfikacja zatwierdzonej karty technologicznej.'@+'\n\n'+
      {? _przywr || 'Czy na pewno przywrócić element?'@ || 'Czy na pewno usunąć (dezaktywować) element?'@ ?}
   )
|| TTXCAUSE.win_sel('WER');
   TTXCAUSE.actions('WER','','T:d');
   TOPER.OD:=_dData;
   {? _rCause<>null()
   || TOPER.CAUSE:=_rCause
   || TOPER.CAUSE:=exec('ttxcause_default','tech_common')
   ?};
   {? ~_bDialog | TOPER.edit("
         {? TOPER.CAUSE=null()
         || FUN.info('Podaj przyczynę zmiany.'@);
            'CAUSE'
         || ''
         ?}
        ")
   ||
      {? _bDialog | ~_przywr | TOPER.MOD_TIME=_oldstamp
      || _dData:=TOPER.OD;
         TOPER.ACT:={? _przywr || 'T' || 'N' ?};
         TOPER.USER:=OPERATOR.USER;
         TOPER.MOD_TIME:=_tmstamp;
         {? TOPER.put()
         || _rCause:=TTXCAUSE.ref();
            TMAT.index('NNL');
            TMAT.prefix(VAR.A_KTL,TOPER.ref());
            {? TMAT.first()
            || {!
               |?
                  exec('zm_m_usun','tech_mater',{? _przywr || 2 || 0 ?},_dData,_rCause,_tmstamp,_oldstamp);
                  TMAT.next()
               !}
            ?};
            TACTTLS.index('KNROP');
            TACTTLS.prefix(VAR.A_KTL,TOPER.ref());
            {? TACTTLS.first()
            || {!
               |?
                  exec('zm_usun','tech_tool',{? _przywr || 2 || 0 ?},_dData,_rCause,_tmstamp,_oldstamp);
                  TACTTLS.next()
               !}
            ?};
            _unrop:=TOPER.UNROP;
            TOPER.cntx_psh();
            TOPER.index('TPZ');
            TOPER.prefix('T',_unrop);
            {? TOPER.first()
            || TOPER.ACT:={? _przywr || 'T' || 'N' ?};
               TOPER.OD:=_dData;
               {? _rCause<>null()
               || TOPER.CAUSE:=_rCause
               || TOPER.CAUSE:=exec('ttxcause_default','tech_common')
               ?};
               TOPER.USER:=OPERATOR.USER;
               TOPER.MOD_TIME:=_tmstamp;
               TOPER.put()
            ?};
            TOPER.cntx_pop();
            TOPER.cntx_psh();
            TOPER.index('NNN');
            TOPER.prefix(VAR.A_KTL,_unrop);
            {? TOPER.first()
            || {!
               |? exec('zm_usun','tech_oper',{? _przywr || 2 || 0 ?},_dData,_rCause,_tmstamp,_oldstamp);
                  TOPER.next()
               !}
            ?};
            TOPER.cntx_pop()
         ?};
         {? _bDialog
         || {? FUN.choice(
                  'Należy zmodyfikować strukturę operacji.\nStrukturę można wygenerować automatycznie.'@,,'Generuj'@
               )
            || exec('er_tab','tech_oper',VAR.A_KTL);
               exec('gen_pow','tech_oper',VAR.A_KTL);
               exec('po_nast','tech_oper')
            ?}
         ?}
      ?}
   ?}
?};
TOPER.win_edit(_win_edit);
VAR.KOR:=0;
~~


\dnd_renum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2010]
:: OPIS: Akcja renumerująca operacje za pomoca d&d
::   WE: _a - obiekt "jtree"
::  OLD: \dnd_renum/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_used:=params_get().env_oper.used;

{? _used | (TKTL.TORW='Z' & TKTL.STAT_N='T')
|| FUN.info('Dostęp do operacji w trybie podglądu — nie można zmieniać kolejności.'@);
   return()
?};

TOPER.clear();

_obj.TAB.cntx_psh();

_records:=dnd_info('dropped_records');

_dest_rec:=dnd_info('dest_record');

{? _dest_rec=null()
||
:: Obsługa upuszczania na pusty obszar okna (za wszystkimi rekordami)
:: - narazie nic nie robimy
   _obj.TAB.cntx_pop();
   return()
||
:: Obsługa upuszczania na konkretny rekord (czyli przejmujemy jego numer)

   {? _obj.TAB.seek(_dest_rec)
   ||
:: TOPER.ref() rekordu na który drop
      _ref_drop:=_obj.TAB.REF;
:: TOPER.NROP rekordu na który drop
      {? TOPER.seek(_ref_drop,) || _poz:=TOPER.NROP; _ref:=TOPER.ref() || _poz:=0; _ref:=null() ?};
:: Rekord nadrzędny w TREE.TAB
      _parent:=_obj.TAB.UPNODE;

      {? _obj.TAB.seek(_records.REF,)
      ||
:: Tutaj obsługa dla upuszczania na tej samej gałęzi drzewa
         {? _parent=_obj.TAB.UPNODE
         ||
:: Te rekordy będą podlagać renumeracji - ładujemy do tabeli pomocniczej jak w formule zmien_lp/dragdrop
            _tab_nr:=tab_tmp(1
               ,'REF','INTEGER','Reference'
               ,'P','INTEGER','Pozycja'
               ,'PNEW','INTEGER','Nowa pozycja'
               ,'NUM','STRING[1]','Czy numerowano'
            );
            {? TOPER.seek(_obj.TAB.REF,)
            || TOPER.index('NNN');
               TOPER.prefix(TOPER.NRK,TOPER.NRNOP,'N');
               {? TOPER.first()
               ||
                  {!
                  |? _tab_nr.blank();
                     _tab_nr.REF:=#TOPER.ref();
                     _tab_nr.P:=TOPER.NROP;
                     _tab_nr.NUM:='N';
                     _tab_nr.PNEW:=0;
                     _tab_nr.add();
                     TOPER.next()
                  !};

                  _ost_nr:=TOPER.NROP;

                  {? _records.first()
                  ||
                     _lp:=0;
                     {!
                     |?
                        {? _obj.TAB.seek(_records.REF,) &
                           _tab_nr.find_key(_obj.TAB.REF)
                        ||
                           {? _lp=0 || _pod:=_tab_nr.P ?};
                           {? _poz>=_pod
                           ||
                              _tab_nr.PNEW:=_poz+_lp-(_records.size()-1)
                           ||
                              _tab_nr.PNEW:=_poz+_lp
                           ?};
                           _tab_nr.put();
                           _lp+=1;
                           1
                        ?};
                        _records.next()
                     !};

:: Ustawienie numeracji dla pozostałych rekordów
                     _num:=_tab_nr.ndx_tmp('',,'NUM',,,'P',,);
                     _pnew:=_tab_nr.ndx_tmp('',,'PNEW',,,'P',,);
                     _tab_nr.index(_num);
                     _tab_nr.prefix('N');
                     {? _tab_nr.first()
                     ||
                        {!
                        |?
                           _nr_new:=0;
                           _tab_nr.cntx_psh();
                           _tab_nr.index(_pnew);
                           _nfind:=0;
                           _nr:=_tab_nr.P;
                           {? ~_tab_nr.find_key(_nr)
                           ||
                              _nfind:=1;
                              _nr_new:=_tab_nr.P
                           ?};

                           {? _nfind
                           ||
                              _tab_nr.prefix(0);
                              {? _tab_nr.first
                              ||
                                 _tab_nr.clear();
                                 _tab_nr.PNEW:=_nr_new;
                                 _tab_nr.put()
                              ?}
                           ?};
                           _tab_nr.cntx_pop();
                           _tab_nr.cntx_psh();
                           _tab_nr.clear();
                           _tab_nr.get();
                           _tab_nr.NUM:='T';
                           _tab_nr.put();
                           _tab_nr.cntx_pop();
                           _tab_nr.first
                        !}
                     ?};
                     _tab_nr.prefix();

:: Ustawienie nowej numeracji
                     TOPER.last();
                     {! |? TOPER.NROP:=TOPER.NROP+_ost_nr; TOPER.put(); TOPER.prev() !};
                     {? _tab_nr.last()
                     ||
                        {!
                        |?
                           {? _tab_nr.PNEW<>0
                           || {? TOPER.seek(_tab_nr.REF,)
                              || TOPER.NROP:=_tab_nr.PNEW;
                                 {? TOPER.put()
                                 || exec('nastopernum','tech_oper',TOPER.ref())
                                 ?}
                              ?}
                           ?};
                           _tab_nr.prev()
                        !}
                     ?};

:: I jeszcze nadanie takich samych numerow na Tpz
                     {? TOPER.first()
                     || {!
                        |?
                           _nrop:=TOPER.NROP;
                           TOPER.cntx_psh();
                           TOPER.index('TPZ');
                           TOPER.prefix('T',TOPER.UNROP);
                           {? TOPER.first() || TOPER.NROP:=_nrop; TOPER.put() ?};
                           TOPER.cntx_pop();
                           TOPER.next()
                        !}
                     ?}
                  ?}
               ?}
            ?};
            _obj.TAB.sel_del()
         ?}
      ?}
   ?}
?};

_obj.replica();
_obj.load();
_obj.update();

_obj.TAB.clear();
{? _obj.TAB.first()
|| {!
   |?
      _obj.TAB1.blank();
      _obj.TAB1.REF:=_obj.TAB.REF;
      {? _obj.TAB1.find_rec()
      || _obj.TAB.HIDDEN:=_obj.TAB1.HIDDEN;
         _obj.TAB.EXPANDED:=_obj.TAB1.EXPANDED;
         _obj.tab_txt();
         _obj.TAB.put()
      || _obj.TAB.HIDDEN:=0;
         _obj.TAB.EXPANDED:=0;
         _obj.tab_txt();
         _obj.TAB.put()
      ?};
      _obj.TAB.next()
   !}
?};
_obj.TAB.cntx_pop();
_obj.TAB.blank();
_obj.TAB.REF:=_ref;
_obj.TAB.find_rec();
~~


\topernum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.50]
:: OPIS: Przenumerowanie operacji (normalizacja, domyślnie od 10 co 10)
::       KONTEKST: bieżąca dziedzina TOPER
::----------------------------------------------------------------------------------------------------------------------
undefine();
define('OD',10,'od...'@,'Numeruj od...'@,5,5,0);
define('CO',10,'co...'@,'Numeruj co...'@,5,5,0);
def_btn('text=%1'['Zapisz'@],'key:F2');
def_btn('text=%1'['Anuluj'@],'key:Esc');
{? def_edit("
      {? DEFINE.OD<=0
      || FUN.emsg('Początek numeracji musi być większy od zera.'@);'OD'
      || {? DEFINE.CO<=0
         || FUN.emsg('Krok numeracji musi być większy od zera.'@);'CO'
         || 1
         ?}
      ?}
   ",'|--|'+'Numeruj operacje'@)
||
   do();
   _od:=DEFINE.OD$0;
   _co:=DEFINE.CO$0;
   TOPER.cntx_psh();
   TOPER.index('NNN');
   TOPER.prefix(TOPER.NRK,TOPER.NRNOP,'N');
   _it:=999999;
   {? TOPER.last()
   || {!
      |? TOPER.NROP:=_it;
         TOPER.put();
         _it-=1;
         TOPER.prev()
      !}
   ?};
   _it:=_od;
   {? TOPER.first()
   || {!
      |? TOPER.NROP:=_it;
         {? TOPER.put()
         || TOPER.cntx_psh();
            TOPER.index('TPZ');
            TOPER.prefix('T',TOPER.UNROP);
            {? TOPER.first()
            || TOPER.NROP:=_it;
               TOPER.put()
            ?};
            TOPER.cntx_pop();
            exec('nastopernum','tech_oper',TOPER.ref())
         ?};
         _it+=_co;
         TOPER.next()
      !}
   ?};
   TOPER.cntx_pop();
   end();
   0
|| 1
?}


\nastopernum
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przenumerowanie ścieżek w następnikach operacji
::   WE: _a - TOPER.ref()
::----------------------------------------------------------------------------------------------------------------------
_toper:=_a;

TOPER.cntx_psh();
NASTOPER.index('NASTOP');
NASTOPER.prefix('T',_toper);
{? NASTOPER.first()
|| {!
   |? NASTOPER.SCIEZKA:=exec('get_oper_nr','tech_oper',NASTOPER.NRNAST().UNROP);
      NASTOPER.put();
      NASTOPER.next()
   !}
?};
TOPER.index('NNN');
TOPER.prefix(TOPER.NRK,exec('FindAndGet','#table',TOPER,_toper,,"UNROP",0));
{? TOPER.first()
|| {!
   |? exec('nastopernum','tech_oper',TOPER.ref());
      TOPER.next()
   !}
?};
TOPER.cntx_pop();
~~


\ust_pola_tpz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Ustawia pola do porównania
::   WE: _a - obj_new() - pola do porównania
::  OLD: \ust_pola/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_obj.TPZ:=VAR1.TPZ;
_obj.ZAW:=VAR1.ZAW;
_obj.COEF:=VAR1.COEF1;
_obj.FCOEF:=VAR1.FCOEF1;
_obj.NTIME:=VAR1.NTIME1;
_obj.FNTIME:=VAR1.FNTIME1;
_obj.STAWKA:=VAR1.STAWKA1;
_obj.CIAGLA:=VAR1.CIAGLA;
~~


\comp_tpz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Porównuje zawartość pól
::   WE: _a - obj_new() - pola do porównania
::  OLD: \comp_tpz/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
{? _obj.TPZ<>VAR1.TPZ        |
   _obj.ZAW<>VAR1.ZAW        |
   _obj.COEF<>VAR1.COEF1     |
   _obj.FCOEF<>VAR1.FCOEF1   |
   _obj.NTIME<>VAR1.NTIME1   |
   _obj.FNTIME<>VAR1.FNTIME1 |
   _obj.STAWKA<>VAR1.STAWKA1 |
   _obj.CIAGLA<>VAR1.CIAGLA
|| 0
|| 1
?}


\warn_toper_plnh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Po redakcji stawki godzinowej na TOPER jeśli są kalkulacje, wyświetla ostrzeżenie żeby
::       przeliczyć kalkulację
::       Kontekst pracy - TOPER
::   WY: 0 - nie bylo kalkulacji
::       1 - są kalkulacje, komunikat został wyświetlony
::  OLD: \warn_toper_plnh/tex_ope1.fml
::  TAG: <PRIVATE>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

KKTL.cntx_psh();
KKTL.index('KZ');
KKTL.prefix(TOPER.NRK);
{? KKTL.size()>0
|| _msg:='Zmieniono płacę na godzinę dla operacji. Wymagane ponowne przeliczenie kalkulacji TKW.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
   || FUN.emsg(_msg)
   ?}
?};
KKTL.cntx_pop();
~~


\warn_toper_cena
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Po redakcji ceny kooperacji na TOPER jeśli są kalkulacje, wyświetla ostrzeżenie żeby
::       przeliczyć kalkulację
::       Kontekst pracy - TOPER
::   WY: 0 - nie było kalkulacji
::       1 - są kalkulacje, komunikat został wyświetlony
::  OLD: \warn_toper_cena/tex_ope1.fml
::  TAG: <PRIVATE>
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

KKTL.cntx_psh();
KKTL.index('KZ');
KKTL.prefix(TOPER.NRK);
{? KKTL.size()>0
|| _msg:='Zmieniono cenę usługi dla kooperacji. Wymagane ponowne przeliczenie kalkulacji TKW.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
   || FUN.emsg(_msg)
   ?}
?};
KKTL.cntx_pop();
~~


\ae_topde
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Po usunięciu TOPER - usuwa Tpz
::   WE: _a: TOPER.UNROP
::  OLD: \ae_topde/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
TOPER.cntx_psh();
TOPER.index('TPZ');
TOPER.prefix('T',_a);
{? TOPER.first()
|| TOPER.del()
?};
TOPER.cntx_pop()


\tpz_names
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca kod i nazwę operacji głównej dla Tpz
::   WE: _a - $TOPER.ref()
::  OLD: \tpz_names/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_toper:=_a;

_res:=obj_new('KOD','NA');
_res.KOD:='???';
_res.NA:='???';

TOPER.cntx_psh();
TOPER.clear();
{? TOPER.seek(_toper)
|| TOPER.index('UNROP');
   TOPER.prefix(TOPER.TPZREF);
   {? TOPER.first()
   || _res.KOD:=TOPER.OPER().KOD;
      _res.NA:=TTOPER.NA+' (Tpz)'
   ?}
?};
TOPER.cntx_pop();

_res


::======================================================================================================================
:: Obsługa zamienników - tabela TECHZAMS
::======================================================================================================================


\tech_zam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Selekcja zamienników stanowisk
::  OLD: \tech_zam/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
_used:=params_get().env_oper.used;

{? TOPER.PZ='Z' | TOPER.WEW='N'
|| FUN.info('Redagowanie zamienników stanowisk dostępne jest dla operacji wewnętrznych prostych.'@)
|| _wer:='WER_'+TKTL.TORW;
   TECHZAMS.cntx_psh();
   TECHZAMS.index('ATL');
   TECHZAMS.prefix('T',TOPER.ref());
   TECHZAMS.win_sel(_wer);
   {? _used | TKTL.ARCH='T' | TKTL.STAT_N='N' & TKTL.TORW<>'Z' | TKTL.TORW='Z' & TKTL.PLRELWYR<>null()
   || _keys:='dpu:d'; _default:=''; _tail:=' — '+'PODGLĄD'@
   |? TKTL.STAT_O='N'
   || _keys:=':'; _default:='d:d'; _tail:=''
   || {? TKTL.STAN='N'
      || _keys:='dpu:d'; _default:=''; _tail:=' — '+'PODGLĄD'@
      || {? (TKTL.TORW='W' | TKTL.TORW='Z' | ~exec('can_modify','tech_common'))
         || _keys:='dpu:d'; _default:=''; _tail:=' — '+'PODGLĄD'@
         || _keys:=':'; _default:='d:d'; _tail:=''
         ?}
      ?}
   ?};
   TECHZAMS.actions(_wer,_keys,_default);
   VAR.A_OP:=TOPER.ref();
   VAR.A_KTL:=TKTL.ref();
   VAR.A_WYD:=TOPER.PFAZ().WYD;
::              {? TOPER.GRPOJ='S'
::              || TOPER.PLACE().WYD
::              || TOPER.GRUPA().WYD
::              ?};
   exec('twrkplc_filter_wyd','zasoby');
   TECHZAMS.hdr_sel();
   TECHZAMS.hdr_sel(_tail);
   TECHZAMS.select();
   TECHZAMS.hdr_sel();
   TECHZAMS.cntx_pop()
?};
~~


\a_twrkpl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Wartość początkowa pola TECHZAMS.TWRKPLC
::  OLD: \a_twrkpl/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.A_OP().GRPOJ='P'
|| TOPER.PLACE
|| TOPER.TWRKPLG().ELEMENT
?}


\wrkpl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Blank TECHZAMS.LP
::  OLD: \wrkpl/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
TECHZAMS.cntx_psh();
_res:={? TECHZAMS.last()
      || TECHZAMS.LP+1
      || 1
      ?};
TECHZAMS.cntx_pop();
_res


\be_wsp
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Przed redakcją pól współczynników.
::   WE: _a - Pole z formułą (np. 'TECHZAMS.FNTIME')
::  OLD: \be_wsp/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
{? TKTL.STAT_O='N' | VAR.KOR
|| _red:=TECHZAMS.win_edit('?');
   {? ($_a)()<>'' & _red<>'RED_N'
   || fld(tpar.calc(($_a)()));
      0
   || 1
   ?}
|| 0
?}


\ae_zamntim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2008]
:: OPIS: po redakcji TECHZAMS.NTIME
::  OLD: \ae_zamntim/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
{? fld(fld()$5); fld()>=0
|| TECHZAMS.PLNX:=(TECHZAMS.PLNH*TECHZAMS.NTIME)$4
|| FUN.emsg('Norma nie może być ujemna.'@);
   return(0)
?};
exec('efld_opt','tech_oper',TECHZAMS);
1


\aeztopco
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2008]
:: OPIS: po redakcji TECHZAMS.COEF
::  OLD: \aeztopco/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
{? fld(fld()$5); (fld()<0)
|| FUN.emsg('Współczynnik musi większy od zera.'@);
   0
|| TECHZAMS.PLNH:=TECHZAMS.COEF*TECHZAMS.OPER().STAWKA;
   1
?}


\formzcoef
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: po redakcji TOPER.FCOEF
::  OLD: \formzcoef/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
{? fld()=''
|| 1
|| {? tpar.chk(fld())
   || {? TKTL.STAT_O='N' | VAR.KOR
      || TECHZAMS.COEF:=tpar.RESULT;
         {? TECHZAMS.COEF>=0
         || TECHZAMS.PLNH:=(TECHZAMS.OPER().STAWKA*TECHZAMS.COEF)$4;
            VAR1.STAWKA1:=(TECHZAMS.OPER().STAWKA)$4;
            1
         || exec('err_form_ltzero','tech_common');
            0
         ?}
      ?}
   ?}
?}


\formzntime
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: po redakcji TOPER.FNTIME
::  OLD: \formzntime/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
{? fld()<>''
|| {? tpar.chk(fld())
   || {? TKTL.STAT_O='N' | VAR.KOR
      || TECHZAMS.NTIME:=tpar.RESULT;
         {? TECHZAMS.NTIME>=0
         || TECHZAMS.PLNX:=(TECHZAMS.PLNH*TECHZAMS.NTIME)$4
         || exec('err_form_ltzero','tech_common');
            _res:=0
         ?}
      ?}
   || _res:=0
   ?}
?};
exec('efld_opt','tech_oper',TECHZAMS);
_res


\aezmitime
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2008]
:: OPIS: po redakcji TECHZAMS.MTIME
::  OLD: \aezmtitime/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
{? fld(fld()$5); fld()>=0
|| TECHZAMS.KH:={? TECHZAMS.GRPOJ='G'
                || TECHZAMS.TWRKPLG().ELEMENT().KH
                || TECHZAMS.PLACE().KH
                ?};
   TECHZAMS.KX:=(TECHZAMS.KH*TECHZAMS.MTIME)$4
|| FUN.emsg('Czas maszynowy nie może być ujemny.'@);
   return(0)
?};
exec('efld_opt','tech_oper',TECHZAMS);
1


\formzmtime
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: po redakcji TOPER.FNTIME
::  OLD: \formzmtime/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
{? fld()<>''
|| {? tpar.chk(fld())
   || {? TKTL.STAT_O='N' | VAR.KOR
      || TECHZAMS.MTIME:=tpar.RESULT;
         {? TECHZAMS.MTIME>=0
         || TECHZAMS.KX:=(TECHZAMS.KH*TECHZAMS.MTIME)$4
         || exec('err_form_ltzero','tech_common');
            _res:=0
         ?}
      ?}
   || _res:=0
   ?}
?};
exec('efld_opt','tech_oper',TECHZAMS);
_res


\aezmtte
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2008]
:: OPIS: Po redakcji pola czasu transportu międzyoperacyjnego.
::  OLD: \aezmtte/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
{? fld(fld()$5); fld()>=0
|| 1
|| FUN.emsg('Czas odczekania nie może być ujemny.'@);
   0
?}


\formzttm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2008]
:: OPIS: Po redakcji pola TECHZAMS.FTTM.
::   WY: 0 / 1
::  OLD: \formzttm/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
{? fld()<>''
|| {? tpar.chk(fld())
   || {? TKTL.STAT_O='N' | VAR.KOR
      || TECHZAMS.TTM:=tpar.RESULT;
         {? TECHZAMS.TTM>=0
         || 1
         || exec('err_form_ltzero','tech_common');
            _res:=0
         ?}
      ?}
   || _res:=0
   ?}
?};
_res


\aeznko
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2008]
:: OPIS: Po redakcji pola czasu nakładkowania operacji.
::  OLD: \aeznko/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
fld(fld()$5);
{? fld()>TECHZAMS.NTIME |
   fld()>TECHZAMS.MTIME
|| FUN.emsg('Czas nakładkowania nie może być większy niż norma czasowa lub czas maszynowy.'@);
   0
|? fld()>=0
|| 1
|| FUN.emsg('Czas nakładkowania nie może być ujemny.'@);
   0
?}


\formznko
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2008]
:: OPIS: Po redakcji pola TECHZAMS.FNKO.
::   WY: 0 / 1
::  OLD: \formznko/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
{? fld()<>''
|| {? tpar.chk(fld())
   || {? TKTL.STAT_O='N' | VAR.KOR
      || TECHZAMS.NKO:=tpar.RESULT;
         {? TECHZAMS.NKO>=0
         || 1
         || exec('err_form_ltzero','tech_common');
            _res:=0
         ?}
      ?}
   || _res
   ?}
?};
_res


\pr_tchza
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2009+]
:: OPIS: Akcja na rekord przed dla listy zamienników stanowisk dla operacji technologicznych.
::  OLD: \pr_tchza/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
{? TECHZAMS.GRPOJ='G'
|| VAR.TYMCZAS:=TECHZAMS.TWRKPLG().KOD_;
   VAR.STRING:=TECHZAMS.TWRKPLG().NAZ_
|| VAR.TYMCZAS:=TECHZAMS.PLACE().KOD;
   VAR.STRING:=TECHZAMS.PLACE().NA
?};
~~


\chk_zam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2008]
:: OPIS: Obsługa po redakcji okienka zamienników stanowiska
::  OLD: \chk_zam/wrkplc.fml
::  TAG: <CHK>
::----------------------------------------------------------------------------------------------------------------------
_par:=TECHZAMS.NRK().TYP().PAR='T';
{? TECHZAMS.FCOEF<>'' & TECHZAMS.TOPER().NRK().TYP().PAR='T' || TECHZAMS.COEF:=tpar.calc(TECHZAMS.FCOEF) ?};
{? TECHZAMS.FNTIME<>'' || TECHZAMS.NTIME:=tpar.calc(TECHZAMS.FNTIME) ?};
{? (TECHZAMS.FCOEF<>'')|(TECHZAMS.FNTIME<>'')
|| TECHZAMS.KH:={? TECHZAMS.GRPOJ='G'
                || TECHZAMS.TWRKPLG().ELEMENT().KH
                || TECHZAMS.PLACE().KH
                ?};
   TECHZAMS.PLNX:=(TECHZAMS.PLNH*TECHZAMS.NTIME)$4
?};
{? TECHZAMS.FMTIME<>''
|| TECHZAMS.MTIME:=tpar.calc(TECHZAMS.FMTIME);
   TECHZAMS.KX:=(TECHZAMS.KH*TECHZAMS.MTIME)$4
?};
{? TECHZAMS.FTTM<>'' || TECHZAMS.TTM:=tpar.calc(TECHZAMS.FTTM) ?};
{? TECHZAMS.FNKO<>'' || TECHZAMS.NKO:=tpar.calc(TECHZAMS.FNKO) ?};
TECHZAMS.TOPER();
{? TECHZAMS.GRPOJ='G'
|| _res:=__CHK.record(TECHZAMS,,'GRUPA','TWRKPLG','COEF')
|| _res:=__CHK.record(TECHZAMS,,'PLACE','COEF')
?};
{? _res='COEF' & _par || _res:='FCOEF' ?};
{? _res='' & TECHZAMS.MTIME=0 & TECHZAMS.NTIME=0
|| FUN.emsg('Czas maszynowy lub norma czasowa musi być różna od zera.'@);
   _res:={? _par || {? TECHZAMS.FNTIME<>'' || 'FNTIME' || 'NTIME' ?} || 'NTIME' ?}
?};
{? _res='' & TECHZAMS.NTIME<0
||  FUN.emsg('Norma czasowa nie może być ujemna.'@);
    _res:={? _par || {? TECHZAMS.FNTIME<>'' || 'FNTIME' || 'NTIME' ?} || 'NTIME' ?}
?};
{? _res='' & TECHZAMS.MTIME<0
||  FUN.emsg('Czas maszynowy nie może być ujemny.'@);
    _res:={? _par || {? TECHZAMS.FMTIME<>'' || 'FMTIME' || 'MTIME' ?} || 'MTIME' ?}
?};
{? _res='' & TECHZAMS.TTM<0
||  FUN.emsg('Czas odczekania nie może być ujemny.'@);
    _res:={? _par || {? TECHZAMS.FTTM<>'' || 'FTTM' || 'TTM' ?} || 'TTM' ?}
?};
{? _res='' & TECHZAMS.NKO<0
||  FUN.emsg('Czas nakładkowania nie może być ujemny.'@);
    _res:={? _par || {? TECHZAMS.FNKO<>'' || 'FNKO' || 'NKO' ?} || 'NKO' ?}
?};
{? _res='' & TECHZAMS.COEF<=0
|| FUN.emsg('Współczynnik musi być większy od zera.'@);
   {? _par || {? TECHZAMS.FCOEF='' || _res:='COEF' || _res:='FCOEF' ?} || _res:='COEF' ?}
?};
{? _res=''
|| _place:={? TOPER.GRPOJ='G'
           || TOPER.TWRKPLG().ELEMENT
           || TOPER.PLACE
           ?};
   {? TECHZAMS.GRPOJ='S' & _place=TECHZAMS.PLACE | TECHZAMS.GRPOJ='G' & _place=TECHZAMS.TWRKPLG().ELEMENT
   || FUN.emsg('Stanowisko zamiennika nie powinno być takie samo jak stanowisko operacji źródłowej.'@)
   |? TECHZAMS.GRPOJ='G' & TECHZAMS.GRUPA=TOPER.GRUPA
   || FUN.emsg('Gniazdo zamiennika nie powinno być takie samo jak gniazdo operacji źródłowej.'@)
   ?};
   _msc:={? TECHZAMS.GRPOJ='G'
         || $TECHZAMS.GRUPA
         || $TECHZAMS.PLACE
         ?};
   _tab:=sql('
      select
         count(*) as LP
      from TECHZAMS
      where (TECHZAMS.GRPOJ=''S'' and TECHZAMS.PLACE='':_a'' or TECHZAMS.GRPOJ=''G'' and TECHZAMS.GRUPA='':_a'')
         and TECHZAMS.NTIME=:_b
         and TECHZAMS.MTIME=:_c
         and TECHZAMS.COEF=:_d
         and TECHZAMS.TTM=:_e
         and TECHZAMS.NKO=:_f
         and TECHZAMS.TOPER=:_g',
      _msc,TECHZAMS.NTIME,TECHZAMS.MTIME,TECHZAMS.COEF,TECHZAMS.TTM,TECHZAMS.NKO,TOPER.ref()
   );
   {? _tab.first() & _tab.LP>{? -menu_txt()='popraw' || 1 || 0 ?}
   || FUN.info('Zamiennik o podanych parametrach już istnieje.'@);
      _res:={? TECHZAMS.GRPOJ='G' || 'GRUPA' || 'PLACE' ?}
   ?}
?};
{? _res=''
|| _pwyd:=TOPER.PFAZ().WYD;
   {? TECHZAMS.PLACE<>null() & _pwyd<>null() & TECHZAMS.PLACE().WYD<>null() & _pwyd<>TECHZAMS.PLACE().WYD & TECHZAMS.GRPOJ='S'
   || FUN.emsg('Stanowisko jest przypisane do innego wydziału niż wybrana faza produkcji.'@);
      _res:='PLACE'
   |? TECHZAMS.GRUPA<>null() & _pwyd<>null() & TECHZAMS.GRUPA().WYD<>null() & _pwyd<>TECHZAMS.GRUPA().WYD & TECHZAMS.GRPOJ='G'
   || FUN.emsg('Gniazdo jest przypisane do innego wydziału niż wybrana faza produkcji.'@);
      _res:='GRUPA'
   ?}
?};
_res


\techzams_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obsługa na 'Wyświetl'
::----------------------------------------------------------------------------------------------------------------------
exec('efld_opt','tech_oper',TECHZAMS);
TECHZAMS.display();
~~


\techzams_bf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obsługa przed 'Dołącz' i 'Popraw'
::----------------------------------------------------------------------------------------------------------------------
{? menu_txt()='Dołącz' || TECHZAMS.GRPOJ:='S' ?};
{? VAR.A_KTL().STAN<>'T'
|| VAR.KOR:=0
|| VAR.KOR:=1
?};
exec('efld_opt','tech_oper',TECHZAMS);
1


\TECHZAMS_kasuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Usuwa zamienniki operacji
::   WE: _a - TKTL.ref
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \TECHZAMS/tkasuj.fml
::  TAG: <PRIVATE>
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

_result:=0;
_can_continue:=1;

TECHZAMS.cntx_psh();
TECHZAMS.index('TTL');
TECHZAMS.prefix(_tktl);
{? TECHZAMS.first()
|| {!
   |? _can_continue:=TECHZAMS.del(,1);
      TECHZAMS.first() & _can_continue>0
   !}
?};
TECHZAMS.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\placechg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2008]
:: OPIS: Zamiana stanowiska na zamiennik w karcie technologicznej zlecenia.
::  OLD: \placechg/wrkplc.fml
::----------------------------------------------------------------------------------------------------------------------
{? {? TOPER.GRPOJ='S'
   || TOPER.PLACE<>null()
   || TOPER.TWRKPLG().ELEMENT<>null()
   ?}
|| exec('pokaz_zam_place','tech_oper')
?};
~~


\pokaz_zam_place
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Pokazuje zamienniki stanowisk dla operacji.
::  OLD: \pokaz_zam_place/tmp_obj.fml
::----------------------------------------------------------------------------------------------------------------------
:: Tabela robocza
_tab:=tab_tmp(2,
   'LP','INTEGER','lp',
   'KOD','STRING[20]','Kod stanowiska',
   'NAZWA','STRING[60]','Nazwa stanowiska',
   'TEKST','STRING[22]','Tekst',
   'TECHZAMS','STRING[16]','$TECHZAMS.ref() - zamiennik stanowiska (do TOPER)',
   'TWRKPLC','STRING[16]','$TWRKPLC.ref() - stanowisko',
   'TWRKZBR','STRING[16]','$TWRKZBR.ref() - gniazdo',
   'TWRKZPO','STRING[16]','$TWRKZPO.ref() - element gniazda'
);
_wer:=_tab.mk_sel('Dostępne stanowiska'@,,0,'zampla_wer',,10,23);
_tab.win_fld(_wer,,'KOD',,,20,,,'Kod stanowiska'@);
_tab.win_fld(_wer,,'NAZWA',,,40,,,'Nazwa stanowiska'@);
_tab.win_fld(_wer,,'TEKST',,,19,,,'Zamiennik'@);
_tab.win_act(_wer,0,'Formuła','&Wybierz'@@,,,"sel_exit()",,1,,,,'W');
_tab.win_act(_wer,0,'Wyświetl',,,,"
   {? TWRKPLC.seek(cur_tab(1,1).TWRKPLC)
   || TWRKPLC.win_edit('RED');
      TWRKPLC.display()
   ?}"
);
_tab.win_act(_wer,0,'Rekord',,,,"{? cur_tab(1,1).TWRKPLC=place || exec('findtmp','#color') || '' ?}");
_tab.win_sel(_wer);

TOPER.cntx_psh();

place:={? TOPER.GRPOJ='S'
       || $TOPER.PLACE
       || $TOPER.TWRKPLG().ELEMENT
       ?};
_src:=TOPER.SRC;

:: wypelnienie tebeli roboczej _tab
_lp:=1;

:: - elementy gniazda (ze zrodlowej technologii)
_gr:=exec('FindAndGet','#table',TOPER,TOPER.SRC,,"GRUPA",null());
{? _gr<>null()
|| TWRKZPO.index('GRUPA');
   TWRKZPO.prefix(_gr);
   {? TWRKZPO.first()
   || {!
      |? _tab.LP:=_lp;
         _tab.NAZWA:=TWRKZPO.NAZ_;
         _tab.KOD:=TWRKZPO.KOD_;
         _tab.TEKST:='ELEMENT GNIAZDA';
         _tab.TECHZAMS:='';
         _tab.TWRKPLC:=$TWRKZPO.ELEMENT;
         _tab.TWRKZBR:=$TWRKZPO.GRUPA;
         _tab.TWRKZPO:=$TWRKZPO.ref();
         _tab.add();
         TWRKZPO.next()
      !}
   ?}

:: - pojedyncze stanowisko (ze zrodlowej technologii)
|? _gr=null() & TOPER.SRC<>''
||  _tab.LP:=_lp;
    _tab.NAZWA:=exec('FindAndGet','#table',TOPER,TOPER.SRC,,"PLACE().NA",'');
    _tab.KOD:=exec('FindAndGet','#table',TOPER,TOPER.SRC,,"PLACE().KOD",'');
    _tab.TEKST:='';
    _tab.TECHZAMS:='';
    _tab.TWRKPLC:=exec('FindAndGet','#table',TOPER,TOPER.SRC,,"$PLACE",'');
    _tab.TWRKZBR:='';
    _tab.TWRKZPO:='';
    _tab.add()
?};

:: - elementy gniazda (z biezacej technologii - o ile inna niz zrodlowa)
{? TOPER.GRPOJ='G'
|| {? TOPER.GRUPA<>_gr
   || _lp+=1;
      TWRKZPO.index('GRUPA');
      TWRKZPO.prefix(TOPER.GRUPA);
      {? TWRKZPO.first()
      || {!
         |? _tab.LP:=_lp;
            _tab.NAZWA:=TWRKZPO.NAZ_;
            _tab.KOD:=TWRKZPO.KOD_;
            _tab.TEKST:='ELEMENT GNIAZDA';
            _tab.TECHZAMS:='';
            _tab.TWRKPLC:=$TWRKZPO.ELEMENT;
            _tab.TWRKZBR:=$TWRKZPO.GRUPA;
            _tab.TWRKZPO:=$TWRKZPO.ref();
            _tab.add();
            TWRKZPO.next()
         !}
      ?}
   ?}
?};

:: - zamienniki (z biezacej technologii, bo moga podlegac modyfikacji)
TECHZAMS.cntx_psh();
TECHZAMS.index('ATL');
TECHZAMS.prefix('T',TOPER.ref());
{? TECHZAMS.first()
|| {!
   |? _lp+=1;
      {? TECHZAMS.GRPOJ='S'
      || _tab.LP:=_lp;
         _tab.NAZWA:=TECHZAMS.PLACE().NA;
         _tab.KOD:=TECHZAMS.PLACE().KOD;
         _tab.TEKST:='ZAMIENNIK';
         _tab.TECHZAMS:=$TECHZAMS.ref();
         _tab.TWRKPLC:=$TECHZAMS.PLACE;
         _tab.TWRKZBR:='';
         _tab.TWRKZPO:='';
         _tab.add()
      || TWRKZPO.index('GRUPA');
         TWRKZPO.prefix(TECHZAMS.GRUPA);
         {? TWRKZPO.first()
         || {!
            |? _tab.LP:=_lp;
               _tab.NAZWA:=TWRKZPO.NAZ_;
               _tab.KOD:=TWRKZPO.KOD_;
               _tab.TEKST:='ZAM. - ELEMENT GNIAZDA';
               _tab.TECHZAMS:=$TECHZAMS.ref();
               _tab.TWRKPLC:=$TWRKZPO.ELEMENT;
               _tab.TWRKZBR:=$TWRKZPO.GRUPA;
               _tab.TWRKZPO:=$TWRKZPO.ref();
               _tab.add();
               TWRKZPO.next()
            !}
         ?}
      ?};
      TECHZAMS.next()
   !}
?};
TECHZAMS.cntx_pop();
TOPER.cntx_pop();

{? _tab.select()
||
:: Zamiennik albo element gniazda dla zamiennika
   {? _tab.TEKST='ZAMIENNIK' | _tab.TEKST='ZAM. - ELEMENT GNIAZDA'
   || {? TWRKPLC.seek(_tab.TWRKPLC)
      || TECHZAMS.clear();
         {? TECHZAMS.seek(_tab.TECHZAMS,8+_tab.TECHZAMS)
         || _fcoef:=TECHZAMS.FCOEF;
            _coef:={? TECHZAMS.FCOEF<>'' || tpar.calc(TECHZAMS.FCOEF)$5 || TECHZAMS.COEF ?};
            _fntime:=TECHZAMS.FNTIME;
            _ntime:={? TECHZAMS.FNTIME<>'' || tpar.calc(TECHZAMS.FNTIME)$5 || TECHZAMS.NTIME ?};
            _fmtime:=TECHZAMS.FMTIME;
            _mtime:={? TECHZAMS.FMTIME<>'' || tpar.calc(TECHZAMS.FMTIME)$5 || TECHZAMS.MTIME ?};
            _fttm:=TECHZAMS.FTTM;
            _ttm:={? TECHZAMS.FTTM<>'' || tpar.calc(TECHZAMS.FTTM)$5 || TECHZAMS.TTM ?};
            _fnko:=TECHZAMS.FNKO;
            _nko:={? TECHZAMS.FNKO<>'' || tpar.calc(TECHZAMS.FNKO)$5 || TECHZAMS.NKO ?}
         || _fcoef:='';
            _coef:=1;
            _fntime:='';
            _ntime:=0;
            _fmtime:='';
            _mtime:=0;
            _fttm:='';
            _ttm:=0;
            _fnko:='';
            _nko:=0
         ?};
         _change:=0;
         {? _tab.TEKST='ZAM. - ELEMENT GNIAZDA' & TWRKZPO.seek(_tab.TWRKZPO)
         || TOPER.GRPOJ:='G';
            {? TOPER.GRUPA<>TWRKZPO.GRUPA || _change:=1 ?};
            TOPER.GRUPA:=TWRKZPO.GRUPA;
            TOPER.TWRKPLG:=TWRKZPO.ref();
            TOPER.PLACE:=null()
         || TOPER.GRPOJ:='S';
            _change:=1;
            TOPER.GRUPA:=null();
            TOPER.TWRKPLG:=null();
            TOPER.PLACE:=TWRKPLC.ref()
         ?};
::       Jesli zmiana gniazda albo pojedyncze stanowisko, to zmiana norm
         {? _change
         || TOPER.FCOEF:=_fcoef;
            TOPER.COEF:=_coef;
            TOPER.FNKO:=_fnko;
            TOPER.NKO:=_nko;
            TOPER.FTTM:=_fttm;
            TOPER.TTM:=_ttm;
            TOPER.FNTIME:=_fntime;
            TOPER.NTIME:=_ntime;
            TOPER.FMTIME:=_fmtime;
            TOPER.MTIME:=_mtime;
            TOPER.PLNH:=(TOPER.OPER().STAWKA*_coef)$4;
            TOPER.PLNX:=(TOPER.PLNH*_ntime)$4;
            TOPER.KX:=(TWRKPLC.KH*_mtime)$4;
            TOPER.KH:=(TWRKPLC.KH)$4
         ?};
         {? TOPER.put()
         || _place:=TOPER.PLACE;
            _grpoj:=TOPER.GRPOJ;
            _grupa:=TOPER.GRUPA;
            _twrkplg:=TOPER.TWRKPLG;
            TOPER.cntx_psh();
            TOPER.index('TPZ');
            TOPER.prefix('T',TOPER.UNROP);
            {? TOPER.first()
            || TOPER.PLACE:=_place;
               TOPER.GRPOJ:=_grpoj;
               TOPER.GRUPA:=_grupa;
               TOPER.TWRKPLG:=_twrkplg;
               TOPER.put()
            ?};
            TOPER.cntx_pop()
         ?}
      ?}

:: Operacja zrodlowa albo element gniazda dla operacji zrodlowej
   || {? TWRKPLC.seek(_tab.TWRKPLC)
      || exec('tktl_cntx_psh','tech_common');
         exec('tktl_use','tech_common',(8+_src)+3);
         TOPER.clear();
::       skok do technologii zrodlowej
         {? TOPER.seek(_src)
         || _fcoef:=TOPER.FCOEF;
            _coef:={? TOPER.FCOEF<>'' || tpar.calc(TOPER.FCOEF)$5 || TOPER.COEF ?};
            _fntime:=TOPER.FNTIME;
            _ntime:={? TOPER.FNTIME<>'' || tpar.calc(TOPER.FNTIME)$5 || TOPER.NTIME ?};
            _fmtime:=TOPER.FMTIME;
            _mtime:={? TOPER.FMTIME<>'' || tpar.calc(TOPER.FMTIME)$5 || TOPER.MTIME ?};
            _fttm:=TOPER.FTTM;
            _ttm:={? TOPER.FTTM<>'' || tpar.calc(TOPER.FTTM)$5 || TOPER.TTM ?};
            _fnko:=TOPER.FNKO;
            _nko:={? TOPER.FNKO<>'' || tpar.calc(TOPER.FNKO)$5 || TOPER.NKO ?}
         || _fcoef:='';
            _coef:=1;
            _fntime:='';
            _ntime:=0;
            _fmtime:='';
            _mtime:=0;
            _fttm:='';
            _ttm:=0;
            _fnko:='';
            _nko:=0
         ?};
         exec('tktl_cntx_pop','tech_common');

         _change:=0;
         {? _tab.TEKST='ELEMENT GNIAZDA' & TWRKZPO.seek(_tab.TWRKZPO)
         || TOPER.GRPOJ:='G';
            {? TOPER.GRUPA<>TWRKZPO.GRUPA || _change:=1 ?};
            TOPER.GRUPA:=TWRKZPO.GRUPA;
            TOPER.TWRKPLG:=TWRKZPO.ref();
            TOPER.PLACE:=null()
         || TOPER.GRPOJ:='S';
            _change:=1;
            TOPER.GRUPA:=null();
            TOPER.TWRKPLG:=null();
            TOPER.PLACE:=TWRKPLC.ref()
         ?};
::       Jesli zmiana gniazda albo pojedyncze stanowisko, to zmiana norm
         {? _change
         || TOPER.FCOEF:=_fcoef;
            TOPER.COEF:=_coef;
            TOPER.FNKO:=_fnko;
            TOPER.NKO:=_nko;
            TOPER.FTTM:=_fttm;
            TOPER.TTM:=_ttm;
            TOPER.FNTIME:=_fntime;
            TOPER.NTIME:=_ntime;
            TOPER.FMTIME:=_fmtime;
            TOPER.MTIME:=_mtime;
            TOPER.PLNH:=(TOPER.OPER().STAWKA*_coef)$4;
            TOPER.PLNX:=(TOPER.PLNH*_ntime)$4;
            TOPER.KX:=(TWRKPLC.KH*_mtime)$4;
            TOPER.KH:=(TWRKPLC.KH)$4
         ?};
         {? TOPER.put()
         || _place:=TOPER.PLACE;
            _grpoj:=TOPER.GRPOJ;
            _grupa:=TOPER.GRUPA;
            _twrkplg:=TOPER.TWRKPLG;
            TOPER.cntx_psh();
            TOPER.index('TPZ');
            TOPER.prefix('T',TOPER.UNROP);
            {? TOPER.first()
            || TOPER.PLACE:=_place;
               TOPER.GRPOJ:=_grpoj;
               TOPER.GRUPA:=_grupa;
               TOPER.TWRKPLG:=_twrkplg;
               TOPER.put()
            ?};
            TOPER.cntx_pop()
         ?}
      ?}
   ?}
?};

&place;
~~


::======================================================================================================================
:: Obsługa następników operacji - tabela NASTOPER
::======================================================================================================================


\er_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Kasuje całą strukturę powiazań między operacjami dla danej karty technologicznej.
::   WE: _a - TKTL.ref()
::  OLD: \er_tab/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

NASTOPER.index('OPER');
NASTOPER.prefix('T',_tktl);
{? NASTOPER.first()
|| {! |? NASTOPER.del() !}
?};
~~


\gen_pow
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Tworzy tabelę tymczasową służącą do przechowywania schematu powiązan między operacjami.
::   WE: _a - TKTL.ref()
::  OLD: \gen_pow/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

__TOPER:=tab_tmp(1,
   'NUIN','REAL','nr operacji nadrzędnej',
   'UIN','REAL','ref do operacji',
   'RS','STRING[1]','Szeregowo/równolegle',
   'NAST','INTEGER','Ref następnika',
   'NR','INTEGER','nr operacji'
);
TOPER.cntx_psh();
TOPER.index('NNN');
TOPER.prefix(_tktl);
__SIZE:=0;
{? TOPER.first() || {! |? {? TOPER.ACT='T' || __SIZE+=1 ?}; TOPER.next() !} ?};
__R:='N';
_wer:=__TOPER.mk_sel('','N',1,'tree_oper');
__TOPER.win_sel(_wer);
exec('gen_ope','tech_oper',0,'N',0,0,_tktl);
__TOPER.prefix();
exec('save_str','tech_oper',_tktl);
obj_del(__TOPER);
TOPER.cntx_pop();
~~


\po_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Po akcji w oknie następników operacji - aktualizacja diagramu zależnosci operacji
::       oraz stempluje kartę technologiczną użytkownikem i czasem modyfikacji operacji
::   WY: 1
::  OLD: \po_nast/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('graph_oper','tech_oper',0);
1


\graph_oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2009]
:: OPIS: Generuje (i ewentualnie wyświetla) graf operacji technologii
::       Kontekst: VAR.A.KTL
::   WE: [_a] - 0 / 1 - czy wyświetlać diagram (domyślnie = 1)
::  OLD: \graph_oper/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
{? _<1 || _display:=1 || _display:=_a ?};

_out_kind:='png';
_orientation:='TB';

_dia:=exec('dot_obj','#graph','dot1');
_dia.out_kind:=_out_kind;
_dia.debug:=0;
_dia.display:=_display;

{? _dia.open()
|| _graph:=_dia.cr_graph();
   _sub:=_dia.cr_sub();
   _node:=_dia.cr_node();
   _edge:=_dia.cr_edge();

   _graph.rankdir:=_orientation;
   _graph.fontsize:='20.0';
   _graph.fontname:='Arial';
   {? _display>0
   || _graph.bgcolor:=_dia.enum.color.white
   || _graph.bgcolor:=_dia.enum.color.transparent
   ?};
   _dia.add_graph('toper',_graph);

   TOPER.cntx_psh();

   TOPER.index('ANNN');
   TOPER.prefix('T','N',VAR.A_KTL);
   {? ~TOPER.first()
   || FUN.emsg('Brak operacji do wyświetlenia.'@);
      TOPER.cntx_pop();
      return('')
   ?};

   _torw:=VAR.A_KTL().TORW;

   NASTOPER.cntx_psh();

   {? TOPER.first()
   ||
      _label:=
         '<\n<TABLE CELLPADDING="10" CELLSPACING="0" BORDER="1">'
         +exec('gen_tabline4','#graph',{? _torw='W' || 'Wzorzec' || 'Karta technologiczna' ?},'c','#EAEAEA',2)
         +exec('gen_tabline','#graph','Symbol:','r','#EAEAEA',TOPER.NRK().NRK,'l','')
         +exec('gen_tabline','#graph','Nazwa:','r','#EAEAEA',TOPER.NRK().OPIS,'l','')
         +exec('gen_tabline','#graph','Wersja:','r','#EAEAEA',TOPER.NRK().WER,'l','')
         +'</TABLE>\n>';
      _dia.clean(_node);
      _node.shape:='box';
      _node.style:='filled';
      _node.fillcolor:=_dia.enum.color.white;
      _node.label:=_label;
      _node.fontsize:='14.0';
      _dia.add_node('"00000"',_node);

      _dia.clean(_node);
      _node.shape:='Mrecord';
      _node.style:='filled';
      _node.fontsize:='14.0';
      {!
      |? {? TOPER.PZ='P'
         || _zewn:=0;
            _operna:=exec('get_oper_nr','tech_oper',TOPER.UNROP,'.','s')
                    +{? TOPER.WEW='N'
                     || _zewn:=1;
                        ' (zewnętrzna)'
                     || ''
                     ?};
            _node.label:='"'
               +exec('get_oper_nr','tech_oper',TOPER.UNROP,'.','n')+' |{'
               +exec('txt_just','#graph',_operna,20,1)+'}"';
::          Oznaczenie kolorem operacji zewnętrznej
            {? _zewn
            || _node.fillcolor:='"#FFFFA0"'
            || _node.fillcolor:='"#F5F5F5"'
            ?};
            _dia.add_node('"'+$#TOPER.ref()+'"',_node);
            ~~
         ?};
         TOPER.next()
      !}
   ?};

   _dia.clean(_edge);
   _edge.color:='"#58585A"';
   _edge.arrowsize:=0.6;
   NASTOPER.index('OPER');
   NASTOPER.prefix('T',VAR.A_KTL);
   {? NASTOPER.first()
   || {!
      |? _dia.add_edge('"'+$#NASTOPER.OPER+'"','"'+$#NASTOPER.NRNAST+'"',_edge);
         _te:=sql('select * from NASTOPER where NASTOPER.NRNAST=:_a',NASTOPER.OPER);
         {? _te.first()=0 || _dia.add_edge('"00000"','"'+$#NASTOPER.OPER+'"') ?};
         obj_del(_te);
         NASTOPER.next()
      !}
   || {? TOPER.first() & TOPER.PZ='P'
      || _dia.add_edge('"00000"','"'+$#TOPER.ref()+'"',_edge)
      ?}
   ?};

   TOPER.cntx_pop();
   NASTOPER.cntx_pop();

   _tktl_sym:=gsub(exec('record','#to_string',VAR.A_KTL),'/','_');
   _tktl_sym:=gsub(_tktl_sym,'\\','_');
   _file_download:='diagram_%1.png'[_tktl_sym];
   {? _dia.run(_file_download)
   || _file:=_dia.get_name_source();
      TKTL.bl_put('DIAG_OP',_file,0)
   ?}
?};
''


\del_nastoper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Usuwa tabelę elementów następników i odpowiednio wiąże pozostałe rekordy.
::   WE: _a - TOPER.ref()
::       [_b] - STRING - czy usuwać aktywne czy nieaktywne
::  OLD: \del_nast/tkasuj.fml
::----------------------------------------------------------------------------------------------------------------------
_toper:=_a;
_akt:='T';
{? var_pres('_b')=type_of('')
|| _akt:=_b
?};
NASTOPER.index('NASTOP');
NASTOPER.prefix(_akt,_toper);
{? NASTOPER.first()
|| {!
   |? _oper:=NASTOPER.OPER;
      NASTOPER.cntx_psh();
      NASTOPER.index('OPNAST');
      NASTOPER.prefix('T',_toper);
      {? NASTOPER.first()
      || {!
         |? NASTOPER.cntx_psh();
            NASTOPER.OPER:=_oper;
            NASTOPER.prefix();
            NASTOPER.add(1);
            NASTOPER.cntx_pop();
            NASTOPER.next()
         !}
      ?};
      NASTOPER.cntx_pop();
      NASTOPER.del();
      NASTOPER.first()
   !}
?};
NASTOPER.index('OPNAST');
NASTOPER.prefix(_akt,_toper);
{? NASTOPER.first()
|| {! |? NASTOPER.del() !}
?};
NASTOPER.clear();
~~


\be_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Przed redakcją pola NASTOPER.SCIEZKA
::  OLD: \be_nast/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.SCIEZKA:=NASTOPER.SCIEZKA


\nastlist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Lista możliwych następników.
::   WE: _a - TKTL.ref()
::   WY: scieżka wybranej operacji
::  OLD: \nastlist/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

TOPER.cntx_psh();
exec('utw_nast','tech_oper',_tktl);
__NAST.prefix();
{? __NAST.select()
|| exec('add_nast','tech_oper',__NAST.UIN,__NAST.SCIEZKA,_tktl);
   _res:=__NAST.SCIEZKA
|| {? menu_txt()='Popraw'
   || _res:=NASTOPER.SCIEZKA
   || _res:=''
   ?}
?};
exec('er_nast','tech_oper');
TOPER.cntx_pop();
_res


\ponast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Po redakcji scieżki dla następnika. Należy sprawdzić czy rekord znajduje się
::       na liście  następników, jeżeli tak to ustalamy wartość pozostałych pól tabeli następników.
::   WE: _a - TKTL.ref()
::   WY: 0/1
::  OLD: \ponast/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

_sciezka:=fld();
{? _sciezka='' || FUN.emsg('Proszę wypełnić pole.'@); return(0) ?};
{? _sciezka=VAR.SCIEZKA || return(1) ?};

_ok:=1;
_nast:=null();
exec('utw_nast','tech_oper',_tktl);
_ndx:=__NAST.ndx_tmp(,1,'SCIEZKA',,);
__NAST.index(_ndx);
__NAST.prefix(_sciezka);
{? ~__NAST.first()
|| _ok:=0;
   FUN.emsg('Operacja o tym numerze nie może być następnikiem lub brak operacji o takim numerze.'@)
|| TOPER.cntx_psh();
   TOPER.index('UNROP');
   TOPER.prefix(__NAST.UIN);
   {? TOPER.first()
   || _nast:=TOPER.ref();
      VAR.STRING3:={? TOPER.WEW='T' || TOPER.OPER().KOD || TOPER.TTOUT().KOD ?};
      VAR.STRING2:={? TOPER.WEW='T' || TOPER.OPER().NA || TOPER.TTOUT().NA ?}
   || _nast:=null();
      VAR.STRING3:=VAR.STRING2:=''
   ?};
   TOPER.cntx_pop();
   NASTOPER.KTL:=_tktl;
   NASTOPER.OPER:=VAR.A_OP;
   NASTOPER.NRNAST:=_nast;
   NASTOPER.SCIEZKA:=__NAST.SCIEZKA
?};
__NAST.ndx_drop(_ndx);
_ndx;
exec('er_nast','tech_oper');

_ok


\pred_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Rekord przed dla tabeli następników (NASTOPER)
::  OLD: \pred_sel/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
TOPER.cntx_psh();
TOPER.clear();
{? TOPER.seek(NASTOPER.NRNAST)
|| VAR.STRING3:={? TOPER.WEW='T' || TOPER.OPER().KOD || TOPER.TTOUT().KOD ?};
   VAR.STRING2:={? TOPER.WEW='T' || TOPER.OPER().NA || TOPER.TTOUT().NA ?}
?};
TOPER.cntx_pop();
~~


\prep_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Rekord przed dla tabeli następników (NASTOPER)
::  OLD: \prep_sel/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
TOPER.cntx_psh();
TOPER.clear();
{? TOPER.seek(NASTOPER.OPER)
|| VAR.STRING3:={? TOPER.WEW='T' || TOPER.OPER().KOD || TOPER.TTOUT().KOD ?};
   VAR.STRING2:={? TOPER.WEW='T' || TOPER.OPER().NA || TOPER.TTOUT().NA ?};
   VAR.STRING:=exec('get_oper_nr','tech_oper',TOPER.UNROP)
?};
TOPER.cntx_pop();
~~


\be_nastop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Dolacz nastoper
::  OLD: \be_nastop/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.STRING2:=VAR.STRING3:='';
1


\utw_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Tworzy tabelę tymczasową zawierającą możliwe następniki operacji
::   WE: _a - TKTL.ref()
::  OLD: \utw_nast/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

NASTOPER.cntx_psh();
VAR_DEL.delete('__NAST');
__NAST:=tab_tmp(1,
   'UIN','REAL','Uin.następnika',
   'REF','INTEGER','Ref.do nastoper',
   'NROP','INTEGER','Nr operacji',
   'NAZ','STRING[100]','Nazwa operacji',
   'KOD','STRING[10]','Kod operacji',
   'SCIEZKA','STRING[20]','Ścieżka',
   'WEW','STRING[1]','Wewnętrzna',
   'PL_GRP','STRING[1]','Grupowa'
);
__NAST.fld_attr('UIN',2);
__NAST.fld_attr('REF',2);
__NAST.fld_attr('NROP',2);
__WER:=__NAST.mk_sel('Dostępne operacje'@,'N',0,'nastepniki',,5,,,'U');
__NAST.win_fld(__WER,,'SCIEZKA',,,10,,,'Numer operacji'@,,,,1);
__NAST.win_fld(__WER,,'NAZ',,,50,,,'Nazwa operacji'@);
__NAST.win_fld(__WER,,'KOD',,,10,,,'Kod'@);
__NAST.win_fld(__WER,,'WEW',,,2,,,'W',,'Operacja wewnętrzna'@);

_fb:="
   _result:=1;
   {? VAR.A_OP().PL_GRP='T'
   || {? __NAST.PL_GRP='T'
      || FUN.info('Następnikiem operacji planowanej grupowo nie może być operacja planowana grupowo.'@);
         _result:=0
      ?}
   ?};
   {? _result>0
   || sel_exit()
   ?}
";

__NAST.win_act(__WER,0,'Formuła','&Wybierz'@@,,,_fb,,1,,,,'W');
__NAST.win_sel(__WER);
_pz:=TOPER.ndx_tmp(,1,'ACT',,,'NRK',,,'PZ',,,'TPZ',,);

TOPER.cntx_psh();
TOPER.index(_pz);
TOPER.prefix('T',_tktl,'P','N');
{? TOPER.first()
|| {!
   |?
      {? TOPER.ref()<>VAR.A_OP
      || __NAST.UIN:=TOPER.UNROP;
         __NAST.NROP:=TOPER.NROP;
         __NAST.NAZ:={? TOPER.WEW='T' || TOPER.OPER().NA || TOPER.TTOUT().NA ?};
         __NAST.KOD:={? TOPER.WEW='T' || TOPER.OPER().KOD || TOPER.TTOUT().KOD ?};
         __NAST.WEW:=TOPER.WEW;
         __NAST.SCIEZKA:=exec('get_oper_nr','tech_oper',TOPER.UNROP);
         __NAST.PL_GRP:=TOPER.PL_GRP;
         __NAST.add()
      ?};
      TOPER.next()
   !}
?};
TOPER.cntx_pop();

TOPER.ndx_drop(_pz);
&_pz;

exec('del_nast','tech_oper',VAR.A_OP,_tktl);
exec('del_exist','tech_oper',VAR.A_OP);
:: Następnikiem operacji planowanej grupowo nie może być operacja planowana grupowo
{? VAR.A_OP().PL_GRP='T' || exec('del_grop','tech_oper') ?};
NASTOPER.cntx_pop();
~~


\del_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Usuwa z listy następników rekordy które nie mogą być następnikami
::   WE: _a - TOPER.ref() - operacja główna
::       _b - TKTL.ref()
::  OLD: \del_nast/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_oper:=_a;
_tktl:=_b;

NASTOPER.cntx_psh();
NASTOPER.index('UNROP');
NASTOPER.prefix('T',_tktl,_oper);
{? NASTOPER.first()
|| {!
   |?
      exec('del_nast','tech_oper',NASTOPER.OPER,_tktl);
      __NAST.prefix(NASTOPER.OPER().UNROP);
      {? __NAST.first()
      || __NAST.del()
      ?};
      NASTOPER.next()
   !}
?};
NASTOPER.cntx_pop();
~~


\del_exist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Usuwa niepotrzebne pozycje z listy możliwych następników
::       (te, które już są na liście następników tej operacji)
::   WE: _a - TOPER.ref() - operacja główna
::  OLD: \del_exist/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_oper:=_a;

_ndx:=NASTOPER.ndx_tmp(,1,'OPER',,,'NRNAST','UNROP',);
__NAST.prefix();
__NAST.first();
NASTOPER.index(_ndx);
{!
|? NASTOPER.prefix(_oper,__NAST.UIN);
   {? NASTOPER.first()
   || __NAST.del()
   || __NAST.next()
   ?}
!};
NASTOPER.clear();
NASTOPER.ndx_drop(_ndx);
&_ndx;
~~


\del_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Usuwa operacje grupowe z możliwych następników
::  OLD: \del_grop/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
__NAST.clear();
{? __NAST.first()
|| {!
   |? {? __NAST.PL_GRP='T' || __NAST.del() || __NAST.next() ?}
   !}
?};
~~


\add_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Wypełnia podstawowe dane dotyczące nowego następnika
::   WE: _a - unikalny numer operacji nastepnika
::       _b - scieżka do następnika operacji.
::       _c - TKTL.ref()
::  OLD: \add_nast/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_unrop:=_a;
_sciezka:=_b;
_tktl:=_c;

_nast:=null();
NASTOPER.KTL:=_tktl;
NASTOPER.OPER:=VAR.A_OP;
TOPER.cntx_psh();
TOPER.index('UNROP');
TOPER.prefix(_unrop);
{? TOPER.first()
|| _nast:=TOPER.ref()
|| _nast:=null()
?};
TOPER.cntx_pop();
NASTOPER.NRNAST:=_nast;
NASTOPER.SCIEZKA:=_sciezka;
~~


\er_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Usuwa tabelę następników
::  OLD: \er_nast/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
obj_del(__NAST);
&__WER;
~~


\gen_dom
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Utworzenie domyślnej struktury powiązań operacji.
::       Obsługa funkcji w oknie NASTOPER umieszczonym w oknie grupowymm TREE.
::  OLD: \gen_dom/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_obj:=params_get().env_oper.obj;

NASTOPER.cntx_psh();
NASTOPER.index('OPER');
NASTOPER.prefix('T',TKTL.ref());
_is_nast:=NASTOPER.first();
{? FUN.ask(
      {? _is_nast || 'Wprowadzono już powiązania między operacjami.'@+'\n\n' || '' ?}+
      'Czy na pewno wygenerować domyślną strukturę powiązań operacji?'@
   )
|| exec('er_tab','tech_oper',TKTL.ref());
   exec('gen_pow','tech_oper',TKTL.ref())
?};
NASTOPER.cntx_pop();
grp_disp(NASTOPER,'SLOPOP');
NASTOPER.index('OPNAST');
NASTOPER.prefix('T',VAR.A_OP);
NASTOPER.first();
exec('graph_oper','tech_oper',0);
::{? TKTL.STAT_O='T' & TREE.DIAP
::|| grp_edisp(TREE.DIA,TREE.REDD)
::?};
_ref:=_obj.TAB.ref();
_obj.load();
_obj.TAB.seek(_ref);
grp_disp(_obj.TAB,_obj.WERT);
~~


\save_str
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Zapisuje dane z tabeli tymczasowej __TOPER do struktury operacji karty
::   WE: _a - TKTL.ref()
::   WY: ~~
::  OLD: \save_str/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

TOPER.cntx_psh();
__TOPER.prefix();
{? __TOPER.first()
|| TOPER.clear();
   {!
   |? {? TOPER.seek(__TOPER.UIN,)
      || NASTOPER.blank();
         NASTOPER.KTL:=_tktl;
         NASTOPER.OPER:=TOPER.ref();
         {? TOPER.seek(__TOPER.NAST,)
         || NASTOPER.NRNAST:=TOPER.ref();
            NASTOPER.SCIEZKA:=exec('get_oper_nr','tech_oper',TOPER.UNROP);

            _can_add:=1;
            TOPER.cntx_psh();
            {? NASTOPER.OPER().PL_GRP='T' & NASTOPER.NRNAST().PL_GRP='T'
            || _can_add:=0
            ?};
            TOPER.cntx_pop();
            {? _can_add>0
            || NASTOPER.add()
            ?}
         ?}
      ?};
      __TOPER.next()
   !}
?};
TOPER.cntx_pop();
~~


\gen_ope
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Tworzy schemat powiązań między operacjami
::   WE: _a: numer operacji nadrzędnej
::       _b: 'N'- szeregowo,'T' - równolegle
::       _c: numer operacji nastepującej
::       _d: poziom zgłębienia struktury
::       _e: TKTL.ref()
::   WY: numer następnika lub numery następników
::  OLD: \gen_ope/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
TOPER.cntx_psh();
TOPER.index('ANNN');
TOPER.prefix('T','N',_e,_a);
_nrnast:=_c;
_level:=_d;
{? __SIZE>0
|| _nrn1:=obj_new(__SIZE)
|| _nrn1:=obj_new(1)
?};
{! _licznik:=1..__SIZE |! _nrn1[_licznik]:=0 !};
{? TOPER.last()
|| _it:=0;
   _size:=TOPER.size();
   {!
   |? {? TOPER.PZ='P'
      || _add:=0;
         __TOPER.NUIN:=_a;
         __TOPER.UIN:=#TOPER.ref();
         __TOPER.NR:=TOPER.NROP;
         __TOPER.RS:=_b;
         {? type_of(_nrnast)=1
         || __TOPER.NAST:=_nrnast;
            __TOPER.add()
         || {! _licznik:=1..obj_len(_nrnast)
            |? _nrnast[_licznik]<>0
            |! __TOPER.NAST:=_nrnast[_licznik];
               _add:=1;
               __R:='T';
               __TOPER.add()
            !};
            {? _add=0
            || __TOPER.NAST:=0;
               __TOPER.add()
            ?}
         ?};
         {? _b='N'
         || {? type_of(_nrnast)<>1
            || obj_del(_nrnast)
            ?};
            _nrnast:=#TOPER.ref()
         || _it+=1;
            _nrn1[_it]:=#TOPER.ref()
         ?}
      || __R:='N';
         _nr:=exec('gen_ope','tech_oper',TOPER.UNROP,TOPER.ALL,{? (_b='T'  & _level<>0) | _level=0 | __R='N'  || _nrnast || _nrn1 ?},_level+1,_e);
         {? (_b='N' & _level<>0) | _level=0
         || {? type_of(_nrnast)=1
            || &_nrnast
            || obj_del(_nrnast)
            ?};
            _nrnast:=_nr
         || {? type_of(_nr)=1
            || _it+=1;
               _nrn1[_it]:=_nr
            || {! _licznik:=1..obj_len(_nr)
               |? _nr[_licznik]<>0
               |! _it+=1;
                  _nrn1[_it]:=_nr[_licznik]
               !}
            ?}
         ?};
         {? type_of(_nr)=1
         || &_nr
         || __R:='N'; obj_del(_nr)
         ?}
      ?};
      TOPER.prev()
   !}
?};
TOPER.cntx_pop();

{? _b='T'
|| _nrn1
|| _nrnast
?}


\valid_str
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Sprawdza poprawność struktury operacji technologii
::       - operacje planowane grupowo nie mogą wystąpić bezpośrednio po sobie
::   WE: _a - TKTL.ref
::       [_b] - INTEGER - 0/[1] - czy wyświetlać dialogi
::   WY: 0 / 1
::  OLD: \valid_str/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_dialog:=1;
{? var_pres('_b')=type_of(0)
|| _dialog:=_b
?};
Cntx.psh(TOPER,NASTOPER);

NASTOPER.index('KTLIDOD');
NASTOPER.prefix(_a);
{? NASTOPER.first()
|| {!
   |?
      {? NASTOPER.OPER().PL_GRP='T' & NASTOPER.NRNAST().PL_GRP='T'
      || {? _dialog
         ||
            FUN.emsg(
               'Operacje: %1 oraz %2 '
               'nie mogą być obie operacjami grupowanymi.\n\n'
               'Należy usunąć jedną z operacji, zmienić znacznik planowania grupowego,\n'
               'wstawić dodatkową operację między nimi albo zmienić kolejność operacji.'@
               [exec('get_oper_nr','tech_oper',NASTOPER.OPER().UNROP,'\\\\'),
                exec('get_oper_nr','tech_oper',NASTOPER.NRNAST().UNROP,'\\\\')]
            )
         ?};
         Cntx.pop(TOPER,NASTOPER);
         return(0)
      ?};
      NASTOPER.next()
   !}
?};

Cntx.pop(TOPER,NASTOPER);
1


\valid_oper_plgr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy aktualny TOPER może być planowany grupowo czyli czy nie ma następników albo poprzedników
::       które mają już zaznaczone grupowe planowanie
::   WE: [_a] - TOPER.ref() - operacja technologi
::   WY: 1 - sukces
::       0 - porażka
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(TOPER.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

TOPER.cntx_psh();
{? _ref<>null()
|| TOPER.prefix();
   {? TOPER.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0 & TOPER.PL_GRP='T'
||
   NASTOPER.cntx_psh();

:: Następniki
   NASTOPER.index('OPNAST');
   NASTOPER.prefix('T',TOPER.ref());
   {? NASTOPER.first()
   || {!
      |? TOPER.cntx_psh();
         {? NASTOPER.NRNAST().PL_GRP='T'
         || _can_continue:=0
         ?};
         TOPER.cntx_pop();
         NASTOPER.next() & _can_continue>0
      !}
   ?};

:: Poprzedniki
   NASTOPER.index('NASTOP');
   NASTOPER.prefix('T',TOPER.ref());
   {? NASTOPER.first()
   || {!
      |? TOPER.cntx_psh();
         {? NASTOPER.OPER().PL_GRP='T'
         || _can_continue:=0
         ?};
         TOPER.cntx_pop();
         NASTOPER.next() & _can_continue>0
      !}
   ?};
   NASTOPER.cntx_pop();

   {? _can_continue=0
   || _msg:='Operacja: %1 nie może być operacją planowaną grupową '
            'ponieważ posiada następniki lub poprzednki planowane grupowo'@[exec('record','#to_string',TOPER.ref())];
      {? VAR.GRUPA='T'
      || KOMM.add(exec('grp_mod_msg','tech_oper',0)+_msg)
      || FUN.emsg(_msg)
      ?}
   ?};
   ~~
?};

TOPER.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\action_pattern_4oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Rejestracja wzorca technologii - akcja tworzenia wzorca z poziomu operacji karty technologicznej/wzorca
::----------------------------------------------------------------------------------------------------------------------
exec('tktl_cntx_psh','tech_common');
_var_torw:=VAR.A_TORW;

_args:=exec('mp_run_a','#b__box');
_args.ACT_UID:='TTE_WTE_DRTE';
_args.AKCJA:='NOWY_WZORZEC_DO_OPERACJI';
_args.PROC_START:='T';
_args.CONTEXT:=obj_new('TKTL','TOPER'); _args.CONTEXT.TKTL:=TKTL.ref(); _args.CONTEXT.TOPER:=TOPER.ref();
exec('mp_run','#b__box',_args);

VAR.A_TORW:=_var_torw;
exec('tktl_cntx_pop','tech_common')


\toper_dalej
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obsługa przycisku 'Zakończ' w oknie wertowania operacji karty/wzorca
::       Zatwierdza operacje i popycha proces dalej
::       Kontekst wywołania - rekord TKTL
::----------------------------------------------------------------------------------------------------------------------
_torw:=TKTL.TORW;
_torw_txt:={? _torw='W' || 'wzorca technologii' || 'karty technologicznej' ?};
_torw_cal:={? _torw='W' || 'całego' || 'całej' ?};

{? TKTL.STAT_O='T'
|| FUN.info('Rejestracja operacji %1 została już zakończona.'@[_torw_txt])
|? TKTL.STAT_N='N'
|| FUN.info('Nie zakończono redagowania nagłówka %1.'@[_torw_txt])
||
:: Generuje następniki, jeżeli brak
   TOPER.cntx_psh();
   TOPER.index('NNN');
   TOPER.prefix(TKTL.ref());
   {? TOPER.first()
   || NASTOPER.cntx_psh();
      NASTOPER.index('OPER');
      NASTOPER.prefix('T',TKTL.ref());
      {? ~NASTOPER.first()
      || exec('er_tab','tech_oper',TKTL.ref());
         exec('gen_pow','tech_oper',TKTL.ref());
         exec('graph_oper','tech_oper',0)
      ?};
      NASTOPER.cntx_pop()
   ?};
   TOPER.cntx_pop();

   {? exec('valid_op1','tech_oper',TKTL.ref())
         &
      exec('valid_op','tech_oper',TKTL.ref(),0,1)
         &
      exec('valid_str','tech_oper',TKTL.ref())
         &
      exec('spr_pdok','magdok_prod','TOPER','DOK',TKTL.ref(),'',1,1)
         &
      FUN.ask('Czy zakończyć rejestrację operacji dla %1 %2?'@[_torw_cal,_torw_txt])
   ||
::    Rekord mógł być zmodyfikowany przez inne czynności, więc go ponownie wczytuję
      {? TKTL.get()
      || TKTL.STAT_O:='T';
         TKTL.STAN:='P';
         {? TKTL.put()
         || sel_exit()
         ?}
      ?}
   ?}
?};
~~


\action_oper_button
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Podgląd operacji dla wzorca technologii - obsługa przycisku w oknie redagowania TKTL w czynnościach
::----------------------------------------------------------------------------------------------------------------------
exec('toper_main','tech_oper',TKTL.ref(),0);
''


\is_zamiennik
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Sprawdza czy podany TOPER pokrywa się z jakimkolwiek swoim zamiennikiem
::   WE: [_a] - TOPER.ref lub bieżący rekord
::   WY: 0 - nie jest zamieniony
::       1 - jest zamieniony
::  OLD: \is_zamiennik/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(TOPER.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

TOPER.cntx_psh();
{? _ref<>null()
|| TOPER.clear();
   {? TOPER.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   TECHZAMS.cntx_psh();
   TECHZAMS.index('ATL');
   TECHZAMS.prefix('T',TOPER.ref());
   {? TECHZAMS.first()
   || {!
      |? {? TECHZAMS.PLACE=TOPER.PLACE & TECHZAMS.GRUPA=TOPER.GRUPA
         || _result:=1;
            _can_continue:=0
         ?};
         TECHZAMS.next() & _can_continue>0
      !}
   ?};
   TECHZAMS.cntx_pop();
   ~~
?};
TOPER.cntx_pop();
_result


\toper_kontrola_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MagLak[12.46]
:: OPIS: Przed redakcja pola TOPER/TTOPER.KONTROLA, TOPER/TTOPER.KJ_BAD
::   WE: [_a] - tabela, dla której uruchamiana: [TOPER]/TTOPER
::   WY: 0 / 1
::  OLD: \toper_kontrola_be/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:={? var_pres('_a')=type_of(TOPER) || _a || TOPER ?};
{? _tab.PL_GRP='T'
|| 0
|| 1
?}


\toper_badseh_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Przed wyświetl pola TOPER/TTOPER.BADSEH
::   WE: [_a] - tabela, dla której uruchamiana: [TOPER]/TTOPER
::   WY: 0/1
::  TAG: <MBUILDER>
::  OLD: \toper_badseh_bd/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:={? var_pres('_a')=type_of(TOPER) || _a || TOPER ?};
_result:=~~;
{? _tab.KJ_BAD<>'B'
|| _result:=exec('findfnrd','color')
?};
_result


\toper_badseh_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Przed redakcja pola TOPER/TTOPER.BADSEH
::   WE: [_a] - tabela, dla której uruchamiana: [TOPER]/TTOPER
::   WY: 0/1
::  TAG: <MBUILDER>
::  OLD: \toper_badseh_be/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:={? var_pres('_a')=type_of(TOPER) || _a || TOPER ?};
BADVAR.TYP_BAD:='O';
_result:=1;
{? _tab.KJ_BAD<>'B'
|| _result:=0
?};
{? _result>0 & _tab.PL_GRP='T'
|| _result:=0
?};
{? _result>0
||
:: ponieważ redagowanie jest dla jednego typu operacji, to w oknie BADSEH.RED blokujemy pole TYP oraz AKT do redakcji
   BADSEH.efld_opt('RED','editable=grayed',,'TYP');
   BADSEH.efld_opt('RED','editable=grayed',,'AKT');
:: usuwam akcje aktywuj/dezaktywuj
   BADSEH.actions('WER','AE')
?};
_result


\toper_badseh_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Po redakcji pola TOPER/TTOPER.BADSEH
::   WE: [_a] - tabela, dla której uruchamiana: [TOPER]/TTOPER
::   WY: 0/1
::  TAG: <MBUILDER>
::  OLD: \toper_badseh_ae/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
::_tab:={? var_pres('_a')=type_of(TOPER) || _a || TOPER ?};
BADVAR.TYP_BAD:='M';
: przywracam stan zablokowanych pól
BADSEH.efld_opt('RED','editable=1',,'TYP');
BADSEH.efld_opt('RED','editable=1',,'AKT');
:: przywracam akcje
BADSEH.actions('WER','');
1


\toper_kjbad_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Po redakcji pola TOPER/TTOPER.KJ_BAD
::   WE: [_a] - tabela, dla której uruchamiana: [TOPER]/TTOPER
::   WY: 0/1
::  TAG: <MBUILDER>
::  OLD: \toper_kjbad_ae/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:={? var_pres('_a')=type_of(TOPER) || _a || TOPER ?};
{? _tab.KJ_BAD<>'B'
|| _tab.BADSEH:=null()
?};
win_disp();
1


\ttoper_kjbad_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Przed redakcą pola TTOPER.KJ_BAD
::----------------------------------------------------------------------------------------------------------------------
exec('toper_kontrola_be','tech_oper',TTOPER)


\ttoper_kjbad_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Po redakcji pola TTOPER.KJ_BAD
::  TAG: <MBUILDER>
::  OLD: \ttoper_kjbad_ae/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('toper_kjbad_ae','tech_oper',TTOPER)


\ttope_badseh_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Przed wyświetleniem pola TTOPER.BADSEH
::   WY: 0/1
::  TAG: <MBUILDER>
::  OLD: \ttope_badseh_bd/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('toper_badseh_bd','tech_oper',TTOPER)


\ttope_badseh_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Przed redakcja pola TTOPER.BADSEH
::   WY: 0/1
::  TAG: <MBUILDER>
::  OLD: \ttope_badseh_be/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('toper_badseh_be','tech_oper',TTOPER)


\ttope_badseh_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Po redakcji pola TTOPER.BADSEH
::   WY: 0/1
::  TAG: <MBUILDER>
::  OLD: \ttope_badseh_ae/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
exec('toper_badseh_ae','tech_oper',TTOPER)


\struktura
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Struktura operacji dla karty technologicznej
::----------------------------------------------------------------------------------------------------------------------
exec('ntimex_a','tech_oper',1,'O')


\elementarne
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Operacje/stanowiska elementarne dla karty technologicznej
::   WE: 'O', 'S'
::----------------------------------------------------------------------------------------------------------------------
exec('ntimex_a','tech_oper',0,_a)


\obciazenia
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Obciążenia zawodów/stanowisk
::   WE: 'Z', 'W'
::----------------------------------------------------------------------------------------------------------------------
exec('ntimex','tech_oper',_a)


\obciazenia_zawodow_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS:
::----------------------------------------------------------------------------------------------------------------------
{? ZL.RTKTL<>''
|| VAR.A_KTL:=exec('FindAndGet','#table',TKTL,ZL.RTKTL);
   exec('ntimex','tech_oper','Z')
|? ZL.RKTL<>''
|| VAR.A_KTL:=exec('FindAndGet','#table',TKTL,ZL.RKTL);
   exec('ntimex','tech_oper','Z')
?};
~~


\obciazenia_stanowisk_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS:
::----------------------------------------------------------------------------------------------------------------------
{? ZL.RTKTL<>''
|| VAR.A_KTL:=exec('FindAndGet','#table',TKTL,ZL.RTKTL);
   exec('ntimex','tech_oper','W')
|? ZL.RKTL<>''
|| VAR.A_KTL:=exec('FindAndGet','#table',TKTL,ZL.RKTL);
   exec('ntimex','tech_oper','W')
?};
~~


\ntimex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.60]
:: OPIS: lista czasow wymaganych dla zawodow lub stanowisk
::   WE: _a='Z' - lista zawodow
::       _a='W' - lista stanowisk
::  OLD: \ntimex/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
:: deklaracja klasy NTIMEX
::----------------------------------------------------------------------------------------------------------------------
exec('tktl_cntx_psh','tech_common');
exec('tktl_use','tech_common',ref_name(VAR.A_KTL)+3);
TKTL.prefix();
{? TKTL.seek(VAR.A_KTL)
||
   exec('ntimex_decl','tech_oper');
::----------------------------------------------------------------------------------------------------------------------
:: inicjowanie obiektu klasy NTIMEX i selekcja listy zawodow/stanowisk
::----------------------------------------------------------------------------------------------------------------------
   {? var_pres('__NTIME',@)>0 || obj_del(__NTIME) ?};
   {? _a='W'
   || _opcja:=FUN.choice('Proszę wybrać opcję wyświetlania stanowisk'@,3,'Stanowiska domyślne'@,'Gniazda'@)
   || _opcja:=1
   ?};
   {? _opcja=1
   || __NTIME:=obj_new(@.CLASS.NTIMEX,TKTL.ref(),'ST',,,,1)
   || __NTIME:=obj_new(@.CLASS.NTIMEX,TKTL.ref(),'GT',,,,1)
   ?};
   __NTIME.select(_a);
   obj_del(__NTIME)
?};
exec('tktl_cntx_pop','tech_common');
~~


\ntimex_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.60]
:: OPIS: Lista czasow wymaganych dla zawodow lub stanowisk.
::       Lista operacji elementarnych albo struktura w postaci drzewa
::   WE: _a - 1 - drzewo operacji, 0 - operacje elementarne
::       _b - 'O' - lista operacji, 'S' - lista stanowisk
::  OLD: \ntimex_a/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
: deklaracja klasy NTIMEX
:-------------------------------------------------------------------------
exec('ntimex_decl','tech_oper');
:-------------------------------------------------------------------------
: inicjowanie obiektu klasy NTIMEX i selekcja listy zawodow/stanowisk
:-------------------------------------------------------------------------
VAR_DEL.delete('__NTIME');

{? _a=1
|| _fazy:=0
|| _fazy:=choice('Czy wyświetlać z rozbiciem na fazy produkcji?'@,FUN.TYT,'ASK',1,1,,'Tak'@,'Nie'@,'Anuluj'@)
?};
{? _fazy>1 || return() ?};
exec('env_create','tech_structure',1);
_env:=__ENV_STR;
::  Rozpoczynam pętle
_exit:=1;
{!
|?
   {? var_press('TAB',__ENV_STR.CHECK) > 0 || _env.CHECK.TAB.erase ?};
   {? var_pres('__NTIME',@)>0 || obj_del(__NTIME) ?};
   __NTIME:=obj_new(@.CLASS.NTIMEX,VAR.A_KTL,'TO',_a,~_fazy,_b);
::     Wyświetlam tabelę z problemami i uzupełniam tabelę zamienników
   _ok:=1;
   {? _env.CHECK.TAB.size()>0
   || _env.CHECK.TAB.win_sel(_env.CHECK.WERA);
      _ok:=exec('tktl_chck_sel','tech_structure'
            ,{? cur_tab(1,1).name(1)*'txktl' || 1 |? cur_tab(1,1).name(1)*'txktw' || 2 || 0 ?} );
      {? _ok=0 || _exit:=0 ?}
   || _exit:=0
   ?};
_exit
!};
::Koniec petli

{? _ok
|| {? _a=1
   || exec('set_tree','tech_oper');
:   __NTIME.sel1(0,_a,_b);
      __NTIME.tree()
   || __NTIME.sel2(_a,_b)
   ?}
?};
obj_del(__NTIME);
exec('env_delete','tech_structure');
~~


\ntimex_decl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.60]
:: OPIS: Obiekt klasy NTIMEX uzywa tabel tymczasowych do wyswietlenia
::       listy wszystkich zawodow/stanowisk eliminujac powtorzenia.
::   WE: _a - wskazanie na obiekt NTIME
::       _b - ref() odpowiednio karty technologicznej lub wykonawczej
::            dla zlecenia albo naglowka planu probnego (patrz arg. _c).
::       _c - Zastosowanie dla listy surowcow do karty technologicznej
::            (_c='T') lub karty wykonawczej zlecenia (_c='Z'),
::            listy zlecen (_c='A') lub produkcji probnej (_c='P')
::       _d - drzewo / elemetarne (1 / 0)
::       _e - faza produkcji
::       _f - lista operacji/lista stanowisk ('O' / 'S')
::  OLD: \ntimex_decl/ntim_obj.fml
::----------------------------------------------------------------------------------------------------------------------
:: deklaracja klasy 'NTIMEX'
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('NTIMEX',@.CLASS) < 0
|| obj_decl('NTIMEX',
::     czy Technologia, czy Zlecenie...
obj_fld('TZ',''),
obj_fld('TZZ',''),
::     czy Grupa czy domyslne stanowiska...
obj_fld('TGR',''),
::     wskazanie na obiekt - sam na siebie
obj_fld('ME',null()),
::     tabele tymczasowe - zawody i stanowiska
obj_fld('TABZ',null()),
obj_fld('TABZS',null()),
obj_fld('TABW',null()),
obj_fld('TABWS',null()),
obj_fld('ZTABZ',null()),
obj_fld('ZTABW',null()),
obj_fld('TABO',null()),
obj_fld('TABO1',null()),
obj_fld('SKL',null()),
::     indeksy tabel tymczasowych
obj_fld('NDXZ1',''),
obj_fld('NDXW1',''),
obj_fld('NDXZ2',''),
obj_fld('NDXW2',''),
obj_fld('NDXZ3',''),
obj_fld('NDXW3',''),
obj_fld('NDX2',''),
obj_fld('NDX2TP',''),
obj_fld('NDXO3',''),
obj_fld('NDXO4',''),
obj_fld('NDXO5',''),
obj_fld('NDXOU',''),
obj_fld('NDX5',''),
obj_fld('NDX4',''),
obj_fld('NDX3',''),
obj_fld('NDX6',''),
obj_fld('NDG1',''),
obj_fld('NDG2',''),
::     okna tabel tymczasowych
obj_fld('REDZ1',''),
obj_fld('REDW1',''),
obj_fld('WERZ1',''),
obj_fld('WERU1',''),
obj_fld('WERW1',''),
obj_fld('WERW2',''),
obj_fld('WERSKL',''),
::     roboczy nr wezla i up-node
obj_fld('NODE',0),
obj_fld('UPNODE',0),
::     roboczy kod towaru, ktorego lista jest rozpisywana
obj_fld('UP_T',0),
::     roboczy kod technologii, ktorej lista jest rozpisywana
obj_fld('UP_KTL',0),
::    karta technologiczna lub naglowek planu
obj_fld('KTL',0),
::     aktualne przeliczniki dla normy netto i brutto
obj_fld('COEFN',1),
obj_fld('COEFB',1),
obj_fld('TIME',1),
obj_fld('TIMEM',1),
obj_fld('TPZ',1),
obj_fld('FAZ',1),
obj_fld('NUMER',''),

obj_fld('LP',1),

obj_meth('__init',"

   .ME:=_a;
   _ktl:=_b;
   _tz:=_c;

   _tree:=0;
   {? var_pres('_d')=type_of(0)
   || _tree:=_d
   ?};

   _faz:=0;
   {? var_pres('_e')=type_of(0)
   || _faz:=_e
   ?};

   _mode:='';
   {? var_pres('_f')=type_of('')
   || _mode:=_f
   ?};

   _loadpar:=0;
   {? var_pres('_g')=type_of(0)
   || _loadpar:=_g
   ?};

   {? var_pres('ppar',@)>0 || obj_del(ppar) ?};
   ppar:=obj_new(@.CLASS.TPAr);

   {? _loadpar>0
   ||
      ppar.TABLE:=TPAR;
      ppar.INDEX:='NN';
      ppar.PREFIX:=_ktl;
::    Laduje domyslne wartosci obiektu do obslugi parametrow
      ppar.loadp(ref_name(_ktl)+3)
   ?};

   .KTL:=.UP_KTL:=_ktl;
   .TGR:='S';
   {? 1+_tz='S'
   || .TZ:=_tz+1
   |? 1+_tz='G'
   || .TZ:=_tz+1;
      .TGR:='G'
   || .TZ:=_tz
   ?};
   .tabele();
   .indeksy();
   .cntxpsh();

   {? .TZ='T'
   ||
      _msk:=((8+ref_name(_ktl))+3);

::    Wszystkim tabelom zwiazanym z technologiami otwieram odpowiednia maske
      exec('tktl_use','tech_common',_msk);

      {? _tree=0
      || .t_load(_ktl)
      || .t_load(_ktl,_tree)
      ?}
   |? .TZ='Z' || .l_load(_ktl)
   |? .TZ='A' || .a_load()
   |? .TZ='P' || .p_load()
   |? .TZ='H' || .h_load()
   |? .TZ='TO'
   ||
      _msk:=((8+ref_name(_ktl))+3);

::    Wszystkim tabelom zwiazanym z technologiami otwieram odpowiednia maske
      exec('tktl_use','tech_common',_msk);

      .FAZ:=_faz;
      .to_load(_ktl,'',_mode);
      .count(0);
      .sumtabo(0,_tree)
   |? .TZ='PO' || .FAZ:=_faz; .po_load(_ktl,0,_tree,_mode)
   ?};
~~
"),

obj_meth('tabele',"
   .TABO:=tab_tmp(2,
      'UPNODE','TREE_REF','Up-node',
      'LP','REAL','Lp',
      'SCIEZKA','STRING[20]','path',
      'OPER_S','STRING[60]','STR.OPER',
      'TOPER','INTEGER','Toper',
      'NODE','INTEGER','Node',
      'OPER','INTEGER','Operacje',
      'PFAZ','INTEGER','Faza',
      'PFAZ_S','STRING[10]','KOD',
      'TIME','REAL','Czas operacji',
      'TIMEM','REAL','Czas maszynowy',
      'KTL','INTEGER','KTL',
      'RKTL','STRING[16]','$TKTL.ref()',
      'PT','INTEGER','Pt',
      'UP_T','INTEGER','UpT',
      'UP_KTL','INTEGER','Up',
      'UP_RKTL','STRING[16]','Up',
      'T_S','STRING[100]','Kod towaru',
      'T_NAZ','STRING[100]','Nazwa towaru',
      'ILO','REAL','Ilość',
      'TMAT','STRING[16]','Ref do TMAT',
      'POD','INTEGER','Zawiera podrzędne',
      'WEW','STRING[1]','Wewnętrzna',
      'TPZ','REAL','Czas Tpz',
      'UNROP','REAL','Unrop'
   );
   {? sec_superuser()=0 || .TABO.fld_attr(,2) ?};

   .TABO1:=tab_tmp(1,
      'LP','INTEGER','Lp',
      'OPER','INTEGER','Operacje',
      'OPER_S','STRING[60]','STR.OPER',
      'PFAZ','INTEGER','Faza',
      'PFAZ_S','STRING[10]','KOD',
      'TIME','REAL','Czas operacji',
      'TIMEM','REAL','Czas maszynowy',
      'TPZ','REAL','Czas tpz'
   );

   .TABZ:=tab_tmp(1,
      'ZAWOD','INTEGER','Ref zawodu',
      'S_ZAWOD','STRING[30]','Zawód',
      'NTIME','REAL','Czas jednostkowy',
      'TPZ','REAL','Czas Tpz',
      'ZLNTIME','REAL','Obciąz.dla zleceń',
      'ZLTPZ','REAL','Tpz dla zleceń',
      'TIMEP','REAL','Czas planowany',
      'TIMER','REAL','Czas rzeczywisty',
      'LP','INTEGER','Lp',
      'TIMEKAL','REAL','time_kal'
   );
   .TABZ.fld_attr(,2);
   .TABZS:=tab_tmp(1,
      'NTIME','REAL','Czas jednostkowy',
      'TPZ','REAL','Czas Tpz',
      'ZLNTIME','REAL','Obciąz.dla zleceń',
      'ZLTPZ','REAL','Tpz dla zleceń',
      'TIMEP','REAL','Czas planowany',
      'TIMER','REAL','Czas rzeczywisty'
   );

   .TABW:=tab_tmp(1,
      'PLACE','STRING[16]','Ref stanowiska/gniazda',
      'S_PLACE','STRING[20]','Kod stanowiska/gniazda',
      'N_PLACE','STRING[60]','Nazwa stanowiska/gniazda',
      'MTIME','REAL','Czas maszynowy',
      'ZLMTIME','REAL','Obciaz.dla zlecen',
      'TIMEP','REAL','Czas planowany',
      'TIMER','REAL','Czas rzeczywisty',
      'LP','INTEGER','Lp',
      'TIMEKAL','REAL','time_kal'
   );
   .TABW.fld_attr(,2);
   .TABWS:=tab_tmp(1,
      'MTIME','REAL','Czas maszynowy',
      'ZLMTIME','REAL','Obciaz.dla zlecen',
      'TIMEP','REAL','Czas planowany',
      'TIMER','REAL','Czas rzeczywisty',
      'TIMEKAL','REAL','time_kal'
   );

   .ZTABW:=tab_tmp(2,
      'PLACE','STRING[16]','Ref.stan',
      'ZL','STRING[20]','Zlecenie',
      'OPER','STRING[30]','OPER',
      'KTM','STRING[50]','ktm',
      'IL','REAL','Ilość',
      'MTIME','REAL','Cz.mas',
      'TIMEP','REAL','Cz.plan'
   );
   .ZTABW.fld_attr(,2);

   .ZTABZ:=tab_tmp(2,
      'ZAWOD','INTEGER','Ref.zaw.',
      'ZL','STRING[20]','ZLecenie',
      'OPER','STRING[30]','OPER',
      'KTM','STRING[50]','ktm',
      'IL','REAL','Ilość',
      'TIMEP','REAL','Cz.plan.'
   );
   .ZTABZ.fld_attr(,2);

   .SKL:=tab_tmp(2,
      'GNIAZDO','STRING[16]','Ref.stan',
      'PLACE','STRING[16]','Ref.place',
      'ZLMTIME','REAL','Obciaz.dla zlecen',
      'TIMEP','REAL','Czas planowany',
      'TIMER','REAL','Czas rzeczywisty'
   );
   .SKL.fld_attr(,2);
   ~~
"),

obj_meth('__done',"

:: Wszystkim tabelom dot. technologii przywracam kontekst
   exec('tktl_cntx_pop','tech_common');

   PFAZ.cntx_pop();
   ZL.cntx_pop();
   ZLGD.cntx_pop();
   ZGH.cntx_pop();
   ZGP.cntx_pop();
   {? var_pres('ppar')>0
   || obj_del(ppar)
   ?}
"),

obj_meth('cntxpsh',"

:: Wszystkim tabelom dot. technologii odkladam kontekst
   exec('tktl_cntx_psh','tech_common');

   ZL.cntx_psh();
   ZLGD.cntx_psh();
   ZGH.cntx_psh();
   ZGP.cntx_psh();
   PFAZ.cntx_psh();
   ~~
"),

obj_meth('indeksy',"
   .NDXZ1:=.TABZ.ndx_tmp('',1,'ZAWOD',,);
   .NDXZ2:=.TABZ.ndx_tmp('',1,'S_ZAWOD',,1);

   .NDX2:=.TABO.ndx_tmp('Faza+Towar',1,'UPNODE',,,'PFAZ',,,'UP_T',,,'RKTL',,,'OPER',,,'UNROP',,);
   .NDX2TP:=.TABO.ndx_tmp('Faza+Towar',1,'UPNODE',,,'PFAZ',,,'UP_T',,,'RKTL',,,'UNROP',,);
   .NDXO3:=.TABO.ndx_tmp('oper',1,'POD',,,'LP',,,'OPER_S',,);

   .NDX3:=.TABO1.ndx_tmp('oper',1,'LP',,,'OPER_S',,);
: .NDXO4:=.TABO.ndx_tmp('',1,'UPNODE',,,'SCIEZKA',,,'OPER_S',,);
   .NDXO4:=.TABO.index('?');
   .NDXO5:=.TABO.ndx_tmp('',1,'POD',,,'LP',,,'PFAZ_S',,,'OPER_S',,);

   .NDXOU:=.TABO.ndx_tmp('',1,'UNROP',,);

   .NDXZ3:=.TABZ.ndx_tmp('',1,'LP',,);

   .NDXW1:=.TABW.ndx_tmp('',1,'PLACE',,);
   .NDXW2:=.TABW.ndx_tmp('',1,'S_PLACE',,1);

   .NDX4:=.TABO.ndx_tmp('OPER_S',0,'OPER_S',,,'PFAZ',,);
   .NDX5:=.TABO.ndx_tmp('NODE',0,'NODE',,);

   .NDXW3:=.TABW.ndx_tmp('',1,'LP',,);

   .NDX6:=.TABO.ndx_tmp('',1,'UPNODE',,,'TOPER',,);

   .NDG1:=.SKL.ndx_tmp('',1,'GNIAZDO',,,'PLACE',,);
   .NDG2:=.SKL.ndx_tmp('',1,'PLACE',,)
"),

obj_meth('win_sel',"
   _timedok:=exec('get','#params',500604,1);
   .win5_sel();
   .WERW1:=.TABW.mk_sel(
      {? .TZ='T' || 'Obciążenia stanowisk dla karty: %1 wersja: %2'@[TKTL.NRK,TKTL.WER]
      |? .TZ='Z' || 'Obciążenia stanowisk dla zlecenia: %1'@[ZKTL.ZLEC().SYM]
      |? .TZ='A' || 'Obciążenia stanowisk dla zleceń'@
      |? .TZ='P' || 'Obciążenia stanowisk dla analizy'@
      || 'Obciążenia stanowisk'@
      ?},'N',0,-.TZ+'_werw1',,,,,'U',,,,,,,'on');
   .TABW.win_fld(.WERW1,@.VAR,'STRING',,,-3,,,'Gniazdo/Stanowisko'@);
   .TABW.win_fld(.WERW1,,'S_PLACE',,,20,,,'Kod'@);
   .TABW.win_fld(.WERW1,,'N_PLACE',,,60,,,'Nazwa'@);
   .TABW.win_fld(.WERW1,,'MTIME',,,12,_timedok,,'Obciążenie'@);
   {? .TZ='P'
   || .TABW.win_fld(.WERW1,,'ZLMTIME',,,12,_timedok,,'Obc.dla zleceń'@)
   ?};
   {? (.TZ='A'|.TZ='Z') & ZL.STAN='O'
   || .TABW.win_fld(.WERW1,,'TIMEP',,,12,_timedok,,'Wyk.wg planu'@);
      .TABW.win_fld(.WERW1,,'TIMER',,,12,_timedok,,'Wyk w rzecz.'@)
   ?};

   .WERZ1:=.TABZ.mk_sel(
      {? .TZ='T' || 'Obciążenia zawodów dla karty: %1 wer. %2'@[TKTL.NRK,TKTL.WER]
      |? .TZ='Z' || 'Obciążenia zawodów dla zlecenia: %1'@[ZKTL.ZLEC().SYM]
      |? .TZ='A' || {? ZL.STAN='O'
                    || 'Obciążenia zawodów dla zleceń otwartych'@
                    || 'Obciążenia zawodów dla zleceń w przygotowaniu'@
                    ?}
      |? .TZ='P' || 'Obciążenia zawodów dla analizy'@
      || 'Obciążenia zawodów'@
      ?},'N',0,-.TZ+'_werz1',,,,,'U',,,,,,,'on');
   .TABZ.win_fld(.WERZ1,@.ZAW,'KOD',,,7,,,'Kod'@);
   .TABZ.win_fld(.WERZ1,,'S_ZAWOD',,,30,,,'Zawód'@);
   .TABZ.win_fld(.WERZ1,,'NTIME',,,12,_timedok,,'Obciążenie'@);
   .TABZ.win_fld(.WERZ1,,'TPZ',,,12,_timedok,,'Tpz'@);
   {?.TZ='P'
   || .TABZ.win_fld(.WERZ1,,'ZLNTIME',,,12,_timedok,,'Obc.dla zleceń'@);
      .TABZ.win_fld(.WERZ1,,'ZLTPZ',,,12,_timedok,,'Tpz dla zleceń'@)
   ?};
   {? (.TZ='A' | .TZ='Z') & ZL.STAN='O'
   || .TABZ.win_fld(.WERZ1,,'TIMEP',,,12,_timedok,,'Wyk.wg planu'@);
      .TABZ.win_fld(.WERZ1,,'TIMER',,,12,_timedok,,'Wyk w rzecz.'@)
   ?};
   {? .TZ='H'
   || .TABW.win_act(.WERW1,0,'Formuła','Zlecenia'@@,,,$(\"
         {? \"+!.ME+\".TABW.S_PLACE<>'  RAZEM:'
         || \"+!.ME+\".ZTABW.prefix(\"+!.ME+\".TABW.PLACE);
            \"+!.ME+\".win3_sel(); \"+!.ME+\".ZTABW.select()
         ?};~~\"),,1);
      .TABW.win_fld(.WERW1,,'TIMEKAL',,,12,_timedok,,'Kalendarz'@)
   ?};
   .TABZ.win_act(.WERZ1,0,'Rekord',,,,$(\"
      {? ~ZAW.seek(\"+!.ME+\".TABZ.ZAWOD,'zawody') || ZAW.blank() ?};
      {? \"+!.ME+\".TABZ.S_ZAWOD='  RAZEM:'
      || \"+!.ME+\".TABZ.win_edit();
         \"+!.ME+\".TABZ.actions_grayed(cur_win(1,1),'O');
         exec('findtmp','#color')
      || \"+!.ME+\".TABZ.win_edit(\"+!.ME+\".REDZ1);
         \"+!.ME+\".TABZ.actions_grayed(cur_win(1,1),'');
         ''
      ?}\"));
   .TABW.win_act(.WERW1,0,'Rekord',,,,$(\"
      VAR.STRING:={? 8+(\"+!.ME+\".TABW.PLACE)='tworkplc' || 'S' |? 8+(\"+!.ME+\".TABW.PLACE)='' || '' || 'G' ?};
      {? \"+!.ME+\".TABW.S_PLACE='  RAZEM:'
      || \"+!.ME+\".TABW.win_edit();
         \"+!.ME+\".TABW.actions_grayed(cur_win(1,1),'SO');
         exec('findtmp','#color')
      || \"+!.ME+\".TABW.win_edit(\"+!.ME+\".REDW1);
         \"+!.ME+\".TABW.actions_grayed(cur_win(1,1),'');
         ''
      ?} \"));
   {? .TGR='G'
   || .TABW.win_act(.WERW1,0,'Formuła','Składowe'@@,,,$(\"{? 8+(\"+!.ME+\".TABW.PLACE)='tworkplc'
                                                       || FUN.info('Funkcja dostępna tylko dla grupy.'@)
                                                       || \"+!.ME+\".SKL.index(\"+!.ME+\".NDG1);
                                                          \"+!.ME+\".SKL.prefix(\"+!.ME+\".TABW.PLACE);
                                                          \"+!.ME+\".SKL.select()
                                                       ?}\"))
   ?};
::   {? .TZ='A' || .TABZ.win_act(.WERZ1,0,'Formuła','Druku&j'@@,,,\" exec('drkzlz','drukujp');~~\");
::                 .TABZ.win_act(.WERZ1,0,'Formuła','Operacje'@@,,,$(\"exec('grselop','zl_zoper',\"+!.ME+\".TABZ.ZAWOD,\"+!.ME+\".TGR,'Z');~~\"))
::   |? .TZ='P' || .TABZ.win_act(.WERZ1,0,'Formuła','Druku&j'@@,,,\" exec('drkan','drukujp');~~\");
::                 .TABZ.win_act(.WERZ1,0,'Formuła','Operacje'@@,,,$(\"exec('selop','zl_zoper',\"+!.ME+\".TABZ.ZAWOD,\"+!.ME+\".TGR,'Z');~~\"))
::   |? .TZ='T' || .TABZ.win_act(.WERZ1,0,'Formuła','Operacje'@@,,,$(\"exec('selop','tech_oper',\"+!.ME+\".TABZ.ZAWOD,\"+!.ME+\".TGR,'Z');~~\"))
::   |? .TZ='Z' || .TABZ.win_act(.WERZ1,0,'Formuła','Operacje'@@,,,$(\"exec('zlselop','zl_zoper',\"+!.ME+\".TABZ.ZAWOD,\"+!.ME+\".TGR,'Z');~~\"))
::   ?};
::
::   {? .TZ='A' || .TABW.win_act(.WERW1,0,'Formuła','Druku&j'@@,,,\" exec('drkzlw','drukujp');~~\");
::                 .TABW.win_act(.WERW1,0,'Formuła','Operacje'@@,,,$(\"exec('grselop','zl_zoper',\"+!.ME+\".TABW.PLACE,\"+!.ME+\".TGR,'S');~~\"))
::   |? .TZ='P' || .TABW.win_act(.WERW1,0,'Formuła','Druku&j'@@,,,\" exec('drkanw','drukujp');~~\");
::                 .TABW.win_act(.WERW1,0,'Formuła','Operacje'@@,,,$(\"exec('selop','zl_zoper',\"+!.ME+\".TABW.PLACE,\"+!.ME+\".TGR,'S');~~\"))
::   |? .TZ='T' || .TABW.win_act(.WERW1,0,'Formuła','Operacje'@@,,,$(\"exec('selop','tech_oper',\"+!.ME+\".TABW.PLACE,\"+!.ME+\".TGR,'S');~~\"))
::   |? .TZ='Z' || .TABW.win_act(.WERW1,0,'Formuła','Operacje'@@,,,$(\"exec('zlselop','zl_zoper',\"+!.ME+\".TABW.PLACE,\"+!.ME+\".TGR,'S');~~\"))
::   ?};
   ~~
"),

obj_meth('win_edit',"
   _timedok:=exec('get','#params',500604,1);
   .REDW1:=.TABW.mk_edit(
      {? .TZ='T' || 'Obciążenia stanowisk dla karty: %1 wer. %2'@[TKTL.NRK,TKTL.WER]
      |? .TZ='Z' || 'Obciążenia stanowisk dla zlecenia: %1'@[ZKTL.ZLEC().SYM]
      |? .TZ='A' || {? ZL.STAN='O'
                    || 'Obciążenia stanowisk dla zleceń otwartych'@
                    || 'Obciążenia stanowisk dla zleceń w przygotowaniu'@
                    ?}
      |? .TZ='P' || 'Obciążenia stanowisk dla analizy'@
      || 'Stanowiska'
      ?},0,-.TZ+'_redw1');
   .TABW.win_efld(.REDW1,,'S_PLACE',,,20,,,'Stanowisko/gniazdo'@);
   .TABW.win_efld(.REDW1,,'N_PLACE',,,60,,,'Nazwa'@);
   .TABW.win_efld(.REDW1,@.TWRKPLC,'KH',,,15,2,,'Koszt godziny'@);
   .TABW.win_efld(.REDW1,,'MTIME',,,15,_timedok,,'Obciążenie'@);
   {? .TZ='P'
   || .TABW.win_efld(.REDW1,,'ZLMTIME',,,15,_timedok,,'Obciążenie dla zleceń'@)
   ?};
   {? (.TZ='A' | .TZ='Z') & ZL.STAN='O'
   || .TABW.win_efld(.REDW1,,'TIMEP',,,15,_timedok,,'Wykonanie wg planu'@);
      .TABW.win_efld(.REDW1,,'TIMER',,,15,_timedok,,'Wykonanie rzeczywiste'@)
   ?};
   .REDZ1:=.TABZ.mk_edit(
      {? .TZ='T' || 'Obciążenia zawodów dla karty: %1 wer. %2'@[TKTL.NRK,TKTL.WER]
      |? .TZ='Z' || 'Obciążenia zawodów dla zlecenia: %1'@[ZKTL.ZLEC().SYM]
      |? .TZ='A' || 'Obciążenia zawodów dla zleceń'@
      |? .TZ='P' || 'Obciążenia zawodów dla analizy'@
      || 'Stanowiska'@
      ?},0,-.TZ+'_redz1');
   .TABZ.win_efld(.REDZ1,@.ZAW,'KOD',,,7,,,'Kod'@);
   .TABZ.win_efld(.REDZ1,,'S_ZAWOD',,,30,,,'Zawód'@);
   .TABZ.win_efld(.REDZ1,,'NTIME',,,15,_timedok,,'Obciążenie'@);
   {? .TZ='T' | .TZ='Z' | .TZ='A' | .TZ='P'
   || .TABZ.win_efld(.REDZ1,,'TPZ',,,15,_timedok,,'Obciążenie Tpz'@)
   ?};
   {? .TZ='P'
   || .TABZ.win_efld(.REDZ1,,'ZLNTIME',,,15,_timedok,,'Obciążenie dla zleceń'@);
      .TABZ.win_efld(.REDZ1,,'ZLTPZ',,,15,_timedok,,'Tpz dla zleceń'@)
   ?};
   {? (.TZ='A' | .TZ='Z')& ZL.STAN='O'
   || .TABZ.win_efld(.REDZ1,,'TIMEP',,,15,_timedok,,'Wykonanie wg planu'@);
      .TABZ.win_efld(.REDZ1,,'TIMER',,,15,_timedok,,'Wykonanie rzeczywiste'@)
   ?};
   ~~
"),

obj_meth('t_load',"
:: WE: _a - TKTL.ref()
::     [_b] - ilosc
   .TABZ.index(.NDXZ1);
   .TABW.index(.NDXW1);
   TOPER.index('NNN');
   TOPER.prefix(_a);
   {? TOPER.first()
   || {? _>1 || _il:=_b || _il:=TOPER.NRK().XJM ?};
      _wsp:=_il/TOPER.NRK().XJM;
      {!
      |?
         {? TOPER.ACT='T' || .addtop(_wsp) ?};
         TOPER.next()
      !};
      {? .TZ='T' || .utwsume() ?}
   ?};
   ~~
"),

obj_meth('addtop',"
   {? TOPER.TPZ='T'
   || _wsp:=1
   || _wsp:=_a
   ?};
   {? TOPER.PZ='P' & TOPER.WEW='T'
   || {? TOPER.TPZ='T'
      || .TABZ.prefix(TOPER.ZAW)
      || .TABZ.prefix(TOPER.OPER().ZAWOD)
      ?};
      {? .TABZ.first()
      || {? TOPER.FNTIME<>'' & .TZ='P'
         || _wart:=ppar.calc(TOPER.FNTIME)*_wsp
         || _wart:=TOPER.NTIME*_wsp
         ?};
         {? TOPER.TPZ='T'
         || .TABZ.TPZ+=_wart
         || .TABZ.NTIME+=_wart
         ?};
         .TABZ.put()
      || .TABZ.blank();
         {? TOPER.TPZ='T'
         || .TABZ.ZAWOD:=TOPER.ZAW;
            .TABZ.S_ZAWOD:=TOPER.ZAW().ZD
         || .TABZ.ZAWOD:=TOPER.OPER().ZAWOD;
            .TABZ.S_ZAWOD:=TOPER.OPER().ZAWOD().ZD
         ?};
         {? .TABZ.S_ZAWOD='' || .TABZ.S_ZAWOD:='  < bez zawodu >' ?};
         {? TOPER.FNTIME<>'' & .TZ='P'
         || _wart:=ppar.calc(TOPER.FNTIME)*_wsp
         || _wart:=TOPER.NTIME*_wsp
         ?};
         {? TOPER.TPZ='T'
         || .TABZ.TPZ:=_wart
         || .TABZ.NTIME:=_wart
         ?};
         _can_add:=1;
         {? TOPER.EXIST<>''
         || _can_add:=ppar.calc(TOPER.EXIST)
         ?};
         {? _can_add>0
         || .TABZ.add()
         ?}
      ?};
      {? TOPER.TPZ='N'
      || .addw(_wsp)
      ?}
   ?};~~
"),

obj_meth('addw',"
   _wsp:=_a;
   {? .TGR<>'G'
   || {? TOPER.GRPOJ='S'
      || _place:=$TOPER.PLACE;
         _placek:=TOPER.PLACE().KOD;
         _placen:=TOPER.PLACE().NA
      || _place:=$TOPER.TWRKPLG().ELEMENT;
         _placek:=TOPER.TWRKPLG().KOD_;
         _placen:=TOPER.TWRKPLG().ELEMENT().NA
      ?}
   || {? TOPER.GRPOJ='S'
      || _place:=$TOPER.PLACE;
         _placek:=TOPER.PLACE().KOD;
         _placen:=TOPER.PLACE().NA
      || _place:=$TOPER.GRUPA;
         _placek:=TOPER.GRUPA().SYMBOL;
         _placen:=TOPER.GRUPA().NAZWA
      ?}
   ?};
   .TABW.prefix(_place);
   {? .TABW.first()
   || {? TOPER.FMTIME<>'' & .TZ='P'
      || _wart:=ppar.calc(TOPER.FMTIME)*_wsp || _wart:=TOPER.MTIME*_wsp
      ?};
      .TABW.MTIME+=_wart;
      .TABW.put()
   || .TABW.blank();
      .TABW.PLACE:=_place;
      .TABW.S_PLACE:=_placek;
      .TABW.N_PLACE:=_placen;
      {? TOPER.FMTIME<>'' & .TZ='P'
      || _wart:=ppar.calc(TOPER.FMTIME)*_wsp || _wart:=TOPER.MTIME*_wsp
      ?};
      .TABW.MTIME:=_wart;
      _can_add:=1;
      {? TOPER.EXIST<>''
      || _can_add:=ppar.calc(TOPER.EXIST)
      ?};
      {? _can_add>0
      || .TABW.add()
      ?};
      {? (8+_place)='tworkzbr'
      || .skladd(_place)
      ?}
   ?}
"),

obj_meth('z_load',"
:: WE: _a - TKTL.ref()
   .TABZ.index(.NDXZ1);
   .TABW.index(.NDXW1);
   TOPER.index('NNN');
   TOPER.prefix(_a);
   {? TOPER.first()
   || {? _>1 || _il:=_b || _il:=TOPER.NRK().XJM ?};
      _wsp:=_il/TOPER.NRK().XJM;
      {!
      |? .add(_wsp);
         {? .TZ='H'
         || .addzl(_wsp)
         ?};
         TOPER.next()
      !}
   ?};
   {? .TZ<>'H'
   || .zlprzy_czas()
   ?};
   ~~
"),

obj_meth('addzl',"
   _wsp:=_a;
   _place:={? TOPER.GRPOJ='S'
           || $TOPER.PLACE
           || {? .TGR='G'
              || $TOPER.GRUPA
              || $TOPER.TWRKPLG().ELEMENT
           ?}
        ?};
   {? _place<>''
   || .ZTABW.prefix(_place,TOPER.NRK().ZL().SYM);
      {? .ZTABW.first
      || .ZTABW.MTIME+=(TOPER.MTIME*_wsp);
         {? TOPER.TPZ='T'
         || .ZTABW.TPZ+=TOPER.NTIME
         || .ZTABW.TIMEP+=(TOPER.NTIME*_wsp)
         ?};
         .ZTABW.put()
      || .ZTABW.ZL:=TOPER.NRK().ZL().SYM;
         .ZTABW.PLACE:=_place;
         .ZTABW.OPER:=TOPER.OPER().NA;
         .ZTABW.KTM:=TOPER.NRK().ZL().KTM().KTM;
         .ZTABW.IL:=ZL.IL;
         .ZTABW.MTIME:=(TOPER.MTIME*_wsp);
         {? TOPER.TPZ='T'
         || .ZTABW.TPZ:=TOPER.NTIME
         || .ZTABW.TIMEP:=(TOPER.NTIME*_wsp)
         ?};
         .ZTABW.add()
      ?}
   ?};
   {? TOPER.OPER<>null()
   || .ZTABZ.prefix(TOPER.OPER().ZAWOD,TOPER.NRK().ZL().SYM);
      {? ~.ZTABZ.first()
      || .ZTABZ.ZAWOD:=TOPER.OPER().ZAWOD;
         .ZTABZ.ZL:=TOPER.NRK().ZL().SYM;
         {? TOPER.TPZ='T'
         || .ZTABZ.TPZ:=TOPER.NTIME
         || .ZTABZ.TIMEP:=(TOPER.NTIME*_wsp)
         ?};
         .ZTABZ.OPER:=TOPER.OPER().NA;
         .ZTABZ.KTM:=TOPER.NRK().ZL().KTM().KTM;
         .ZTABZ.IL:=ZL.IL;
         .ZTABZ.add()
      || {? TOPER.TPZ='T'
         || .ZTABZ.TPZ+=TOPER.NTIME
         || .ZTABZ.TIMEP+=(TOPER.NTIME*_wsp)
         ?};
         .ZTABZ.put()
      ?}
   ?};
   ~~
"),

obj_meth('add',"
  _wsp:=_a;
  {? TOPER.PZ='P' & TOPER.WEW='T'
  || {? TOPER.TPZ='T'
     || .TABZ.prefix(TOPER.ZAW)
     || .TABZ.prefix(TOPER.OPER().ZAWOD)
     ?};
     _can_add:=1;
     {? TOPER.EXIST<>''
     || _can_add:=ppar.calc(TOPER.EXIST)
     ?};
     {? .TABZ.first()
     || {? TOPER.TPZ='T'
        || .TABZ.TPZ+=(TOPER.NTIME)
        || .TABZ.NTIME+=(TOPER.NTIME*_wsp)
        ?};
        .TABZ.put()
     || .TABZ.blank();
        {? TOPER.TPZ='T'
        || .TABZ.ZAWOD:=TOPER.ZAW;
           .TABZ.S_ZAWOD:=TOPER.ZAW().ZD
        || .TABZ.ZAWOD:=TOPER.OPER().ZAWOD;
           .TABZ.S_ZAWOD:=TOPER.OPER().ZAWOD().ZD
        ?};
        {? .TABZ.S_ZAWOD='' || .TABZ.S_ZAWOD:='  < bez zawodu >' ?};
        {? TOPER.TPZ='T'
        || .TABZ.TPZ+=(TOPER.NTIME)
        || .TABZ.NTIME+=(TOPER.NTIME*_wsp)
        ?};
        {? _can_add>0
        || .TABZ.add()
        ?}
     ?};
     _place:=
        {? TOPER.GRPOJ='S'
        || $TOPER.PLACE
        || {? .TGR='G'
           || $TOPER.GRUPA
           || $TOPER.TWRKPLG().ELEMENT
           ?}
        ?};
     _placek:=
        {? TOPER.GRPOJ='S'
        || TOPER.PLACE().KOD
        || {? .TGR='G'
           || TOPER.GRUPA().SYMBOL
           || TOPER.TWRKPLG().ELEMENT().KOD
           ?}
        ?};
     _placen:=
        {? TOPER.GRPOJ='S'
        || TOPER.PLACE().NA
        || {? .TGR='G'
           || TOPER.GRUPA().NAZWA
           || TOPER.TWRKPLG().ELEMENT().NA
           ?}
        ?};
     .TABW.prefix(_place);
     {? .TABW.first()
     || .TABW.MTIME+=(TOPER.MTIME*_wsp);
        .TABW.put()
     || .TABW.blank();
        .TABW.PLACE:=_place;
        .TABW.S_PLACE:=_placek;
        .TABW.N_PLACE:=_placen;
        .TABW.MTIME:=(TOPER.MTIME*_wsp);
        {? _can_add>0
        || .TABW.add()
        ?};
        {? (8+_place)='tworkzbr'
        || .skladd(_place)
        ?}
     ?}
  ?};~~
"),

obj_meth('l_load',"
: bez parametru - przetwarzane rekordy ZL wg aktualnego kontekstu tabeli
   ZL.seek(_a);

   _loadpar:=0;
   {? var_pres('_b')=type_of(0)
   || _loadpar:=_b
   ?};

   {? ZL.RODZAJ='Z' |  ZL.RODZAJ='N' | ZL.RODZAJ='O'
   || ZL.cntx_psh();
      ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? {? ZL.TKTL<>null()
            ||
               {? _loadpar>0
               || {? var_pres('ppar',@)>0 || obj_del(ppar) ?};
                  ppar:=obj_new(@.CLASS.TPAr);
                  ppar.TABLE:=TPAR;
                  ppar.INDEX:='NN';
                  ppar.PREFIX:=ZL.TKTL;
::                Laduje domyslne wartosci obiektu do obslugi parametrow
                  ppar.loadp(ref_name(ZL.TKTL)+3)
               ?};
               .z_load(ZL.TKTL,ZL.IL)
            ?};
            ZL.next()
         !}
      ?};
      ZL.cntx_pop()
   || {? ZL.TKTL<>null()
      ||
         {? _loadpar>0
         || {? var_pres('ppar',@)>0 || obj_del(ppar) ?};
            ppar:=obj_new(@.CLASS.TPAr);
            ppar.TABLE:=TPAR;
            ppar.INDEX:='NN';
            ppar.PREFIX:=ZL.TKTL;
::          Laduje domyslne wartosci obiektu do obslugi parametrow
            ppar.loadp(ref_name(ZL.TKTL)+3)
         ?};
         .z_load(ZL.TKTL,ZL.IL)
      ?}
   ?};
   .utwsume()
"),

obj_meth('a_load',"
::----------------------------------------------------------------------------------------------------------------------
::  MOD: TS [8.60] akcje dla grup rekordow
:: OPIS: przetwarzanie zaznaczonych rekordow w tabeli ZL
::   WE: zmienna globalna __GRUPA zawierajaca dane zaznaczonych rekordow
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
   ZL.cntx_psh();
   ZL.clear();
   __GRUPA.clear();
   {? __GRUPA.first()
   || {!
      |? {? ZL.seek(__GRUPA.REF,'zlec_akt')
         || {? ZL.RODZAJ='Z' |  ZL.RODZAJ='N' | ZL.RODZAJ='O'
            || ZL.cntx_psh();
               ZL.index('NRNZL');
               ZL.prefix(ZL.UNRZL);
               {? ZL.first()
               || {!
                  |? {? ZL.KTLZ<>null()
                     || .z_load(ZL.KTLZ,ZL.IL)
                     || .t_load(ZL.KTL,ZL.IL)
                     ?};
                     ZL.next()
                  !}
               ?};
               ZL.cntx_pop()
            || {? ZL.KTLZ<>null()
               || .z_load(ZL.KTLZ,ZL.IL)
               || .t_load(ZL.KTL,ZL.IL)
               ?}
            ?}
         ?};
         __GRUPA.next()
      !};
      .utwsume()
   ?};
   ZL.cntx_pop();
   ~~
"),

obj_meth('h_load',"
::----------------------------------------------------------------------------------------------------------------------
::  MOD: MKO [8.70]
:: OPIS: Dla grupy harmonogramowanych zlecen. Funkcja przetwarza w biezacej dziedzinie.
::----------------------------------------------------------------------------------------------------------------------
   __ZL.prefix();
   {? __ZL.first()
   || {!
      |?
         {? 1+__ZL.ZKTL='z'
         || ZKTL.prefix();
            {? ZKTL.seek(__ZL.ZKTL)
            || .z_load(ZKTL.ref(),__ZL.IL)
            ?}
         || TKTL.prefix();
            {? TKTL.seek(__ZL.ZKTL)
            || .t_load(TKTL.ref(),__ZL.IL)
            ?}
         ?};
         __ZL.next()
      !};
      .utwsume()
   ?};
   ~~
"),

obj_meth('skladd',"
::----------------------------------------------------------------------------------------------------------------------
::  MOD: MKO [8.70]
:: OPIS: Dla grupy harmonogramowanych zlecen. Funkcja przetwarza w biezacej dziedzinie.
::----------------------------------------------------------------------------------------------------------------------
   TWRKZBR.clear();
   .SKL.index(.NDG1);
   {? TWRKZBR.seek(_a,'tworkzbr')
   || TWRKZPO.cntx_psh();
      TWRKZPO.index('GRUPA');
      TWRKZPO.prefix(TWRKZBR.ref());
      {? TWRKZPO.first()
      || {!
         |? .SKL.prefix(_a,$TWRKZPO.ELEMENT);
            {? ~.SKL.first()
            || .SKL.blank();
               .SKL.GNIAZDO:=_a;
               .SKL.PLACE:=$TWRKZPO.ELEMENT;
               .SKL.ZLMTIME:=0;
               .SKL.add()
            ?};
            TWRKZPO.next()
         !}
      ?};
      TWRKZPO.cntx_pop()
   ?};
   ~~
"),

obj_meth('utwsume',"
   _zntime:=_ztpz:=_zlntime:=_zltpz:=_ztimep:=_ztimer:=_sntime:=_slntime:=_stimep:=_stimer:=_zkal:=0;

   .TABZ.index(.NDXZ2);
   .TABZ.prefix();
   {? .TABZ.first()
   || .TABZ.LP:=0;
      {!
      |? _zntime+=.TABZ.NTIME;
         _ztpz+=.TABZ.TPZ;
         _zlntime+=.TABZ.ZLNTIME;
         _zltpz+=.TABZ.ZLTPZ;
         _ztimep+=.TABZ.TIMEP;
         _ztimer+=.TABZ.TIMER;
         .TABZ.LP+=1;
         .TABZ.put();
         .TABZ.next()
      !}
   ?};

   .TABW.index(.NDXW2);
   .TABW.prefix();
   {? .TABW.first()
   || .TABW.LP:=0;
      {!
      |? _sntime+=.TABW.MTIME;
         _slntime+=.TABW.ZLMTIME;
         _stimep+=.TABW.TIMEP;
         _stimer+=.TABW.TIMER;
         _zkal+=.TABW.TIMEKAL;
         .TABW.LP+=1;
         .TABW.put();
         .TABW.next()
      !}
   ?};

   .TABZS.NTIME:=_zntime;
   .TABZS.TPZ:=_ztpz;
   .TABZS.ZLNTIME:=_zlntime;
   .TABZS.ZLTPZ:=_zltpz;
   .TABZS.TIMEP:=_ztimep;
   .TABZS.TIMER:=_ztimer;
   .TABZS.add();

   .TABWS.MTIME:=_sntime;
   .TABWS.ZLMTIME:=_slntime;
   .TABWS.TIMEP:=_stimep;
   .TABWS.TIMER:=_stimer;
   .TABWS.TIMEKAL:=_zkal;
   .TABWS.add()
"),

obj_meth('zlprzy_czas',"
   ZLGD.cntx_psh();
   {! _rok:=ZL.OD~1 .. ST.AR
   |!
      .zlprzy1_czas(_rok)
   !};
   ZLGD.cntx_pop()
"),

obj_meth('zlprzy1_czas',"
::----------------------------------------------------------------------------------------------------------------------
:: WE: _a - numer roku
::----------------------------------------------------------------------------------------------------------------------
   _oddzial:=ST.ODDZ;
   _rok:=2-$_a;
   ZLGD.use('zlgd_'+_oddzial+_rok);
   'godziny na zlecenia';
   ZLGD.index('ZLECENIE');
   ZLGD.prefix(ZL.ref());
   {? ZLGD.first()
   ||
      {!
      |?
         .TABZ.prefix(ZLGD.ZGP().TOPER().OPER().ZAWOD);
         {? .TABZ.first()
         || .TABZ.TIMEP+=ZLGD.TIME_P;
            .TABZ.TIMER+=ZLGD.TIME;
            .TABZ.put()
         ?};
         _place:={? ZLGD.ZGP().TOPER().GRPOJ='S'
                 || $ZLGD.ZGP().PLACE
                 || {? .TGR='G'
                    || $ZLGD.ZGP().TOPER().GRUPA
                    || $ZLGD.ZGP().PLACE
                    ?}
                 ?};
         .TABW.prefix(_place);
         {? .TABW.first()
         || .TABW.TIMEP+=ZLGD.TIME_P;
            .TABW.TIMER+=ZLGD.TIME;
            .TABW.put()
         ?};
         {? (8+_place)='tworkplc'
         || .SKL.index(.NDG2);
            .SKL.prefix(_place);
            {? .SKL.first()
            || {!
               |? .SKL.TIMEP+=ZLGD.TIME_P;
                  .SKL.TIMER+=ZLGD.TIME;
                  .SKL.put();
                  .SKL.next()
               !}
            ?}
         ?};
         ZLGD.next()
      !}
   ?};~~
"),

obj_meth('p_load',"
:: Kontekst wywolania - ustawiona dziedzina tabeli PLRELWYR
   ZLGD.cntx_psh();
   PLRELWYR.cntx_psh();
   {? PLRELWYR.first()
   || _ok:=0;
      {!
      |? {? _ok || .ltpar1() || _ok:=.ltpar() ?};
         _tktl:=exec('FindAndGet','#table',TKTL,PLRELWYR.RTKTL,,,null());
         .t_load(_tktl,PLRELWYR.ILOSC);
         PLRELWYR.next()
      !};
      .zlc()
   ?};
   .utwsume();
   PLRELWYR.cntx_pop();
   ZLGD.cntx_pop()
"),

obj_meth('ltpar',"
   TPAR.clear();
   {? TPAR.find_key(PLRELWYR.TKTL)
   || ppar.TABLE:=TPAR;
      ppar.INDEX:='NN';
      ppar.PREFIX:=PLRELWYR.TKTL;
      ppar.loadp();
      1
   || 0
   ?}
"),

obj_meth('ltpar1',"
   TPAR.clear();
   {? TPAR.find_key(PLRELWYR.TKTL)
   || ppar.PREFIX:=PLRELWYR.TKTL;
      ppar.reloadp();
      1
   || 0
   ?}
"),

obj_meth('zlc',"
   ZL.cntx_psh();
   ZL.index('STAN');
   ZL.prefix('N','O',0);
   {? ZL.first()
   || {!
      |? {? ZL.TYP().WP='P'
         || ZGH.index('ZLNR');
            ZGH.prefix(ZL.ref());
            {? ZGH.first()
            || {!
               |? {? ZGH.STAN='N'
                  || .przyp_zgp()
                  ?};
                  ZGH.next()
               !}
            ?}
         ?};
         ZL.next()
      !}
   ?};
   ZL.cntx_pop();
   ~~
"),

obj_meth('przyp_zgp',"
   ZGP.index('NRPP');
   ZGP.prefix(ZGH.ref());
   {? ZGP.first()
   || _msk:={? ZGP.TOPER<>null() || (8+$ZGP.TOPER)+3 || '___' ?};
      exec('tktl_cntx_psh','tech_common');
      exec('tktl_use','tech_common',_msk);
      {!
      |? _ilosc:=ZGP.IL;
         _nt:={? ZGP.TPZ='T' | ZGH.ZLEC().TYP().WP='W'
              || ZGP.NTIME
              || {? ZGP.ILOSC=0 || 0 || ZGP.NTIME*(ZGP.ILOSC-_ilosc)/ZGP.ILOSC ?}
              ?};
         _nt1:={? ZGP.TPZ='T' | ZGH.ZLEC().TYP().WP='W'
               || ZGP.MTIME
               || {? ZGP.ILOSC=0 || 0 || ZGP.MTIME*(ZGP.ILOSC-_ilosc)/ZGP.ILOSC ?}
               ?};
         .TABZ.prefix(ZGP.TOPER().OPER().ZAWOD);
         {? .TABZ.first()
         || {? ZGP.TPZ='T'
            || .TABZ.ZLTPZ+=_nt
            || .TABZ.ZLNTIME+=_nt
            ?};
            .TABZ.put()
         ?};
         {? ZGP.TOPER().GRPOJ<>'' & ZGP.WEW='T'
         || _place:={? ZGP.TOPER().GRPOJ='S'
                    || $ZGP.TOPER().PLACE
                    || {? .TGR='G'
                       || $ZGP.TOPER().GRUPA
                       || $ZGP.TOPER().TWRKPLG().ELEMENT
                       ?}
                    ?};
            _place1:={? ZGP.TOPER().GRPOJ='S'
                     || $ZGP.TOPER().PLACE
                     || $ZGP.TOPER().TWRKPLG().ELEMENT
                     ?};
            {? _place<>'' & _place1<>''
            || .TABW.prefix(_place);
               {? .TABW.first()
               || .TABW.ZLMTIME+=_nt;
                  .TABW.put()
               ?};
               .SKL.index(.NDG2);
               .SKL.prefix(_place1);
               {? .SKL.first()
               || {!
                  |? .SKL.ZLMTIME+=_nt;
                     .SKL.put();
                     .SKL.next();
                     0
                  !}
               ?}
            ?}
         ?};
         ZGP.next()
      !};
      exec('tktl_cntx_pop','tech_common')
   ?}
"),

obj_meth('select',"
   .win_sel();
   .win_edit();
   {? _a='Z'
   || .TABZ.index(.NDXZ3);
      .TABZ.prefix();
      .TABZ.win_sel(.WERZ1);
      .TABZ.win_edit(.REDZ1);
      .TABZ.select()
   |? _a='W'
   || .TABW.index(.NDXW3);
      .TABW.prefix();
      .TABW.win_sel(.WERW1);
      .TABW.win_edit(.REDW1);
      .TABW.select()
   ?}
"),

obj_meth('select1',"
   .sel_grp();
   .TABW.prefix();
   .TABZ.prefix();
   .TABZ.first();
   .TABW.first();
   __UTIL.index(__NDX);
   __UTIL.prefix();
   __UTIL.first();
   .TABW.select()
"),

obj_meth('to_load',"
   _tktl:=_a;
   _tmat:=_b;

:: Tryb wyswietlania zawartosci - 'O' - lista operacji; 'S' - lista stanowisk
   _mode:=_c;

   _tpar_parent:=~~;
   {? var_pres('_d')>100
   || _tpar_parent:=_d
   ?};

   TKTL.cntx_psh();
   TMAT.cntx_psh();

   {? _tktl<>null()
   ||
      _mask:=ref_name(_tktl);

      {? _mask<>''
      ||
         {? TKTL.name()<>_mask
         ||
            TKTL.use(_mask);
            _msk_tmat:=form((TMAT.name()-3)+(_mask+3));
            TMAT.use(_msk_tmat)
         ?}
      ?};
      TKTL.clear();

      {? TKTL.seek(_tktl)
      ||
::       Jesli argument _d nie zostal podany to inicjuje TPAr wyzszego poziomu z
::       biezacej technologii pobierajac wartosci domyslne dla karty
         {? type_of(_tpar_parent)<100 & TKTL.TYP().PAR='T'
         || _tpar_parent:=obj_new(@.CLASS.TPAr);
            _tpar_parent.TABLE:=TPAR;
            _tpar_parent.INDEX:='NN';
            _tpar_parent.PREFIX:=TKTL.ref();
::          Laduje domyslne wartosci
            _tpar_parent.loadp(ref_name(TKTL.ref())+3)
         ?};

         .UP_T:=TKTL.KTM;
         .NUMER:='';

         .sciezka(_tktl,_tmat,_mode,0,_tpar_parent);
         TMAT.index('NNL');
         TMAT.clear();
         TMAT.prefix(TKTL.ref());
         {? TMAT.first()
         || {!
            |? _added:=0;
               _arch:='N';
               {? var_pres('__ENV_STR')>0 & var_pres('TAB_ZAM',__ENV_STR.CHECK)>0 & __ENV_STR.CHECK.TAB_ZAM.find_tab(,'TMAT',,'=',$TMAT.ref)
               || _ktl:=exec('FindAndGet','#table',TKTL,__ENV_STR.CHECK.TAB_ZAM.KTLW,,,null())
               ||
                  {? TMAT.DFLT_KTL='T'
                  || _ktl:=exec('dflt_ktl','tech_prod',{? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?},,1);
                     {? _ktl=null()
                     || _txt:='Brak karty domyślnej';
                        _added:=1
                     |? ~exec('tktl_act','tech_head',,$_ktl)
                     || _txt:='Karta domyślna nieaktualna'@;
                        _added:=1
                     ?}
                  || _ktl:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,,null());
                     {? _ktl<> null
                     || _arch:=exec('FindAndGet','#table',TKTL,_ktl,,'ARCH','N');
                        {? _arch<>'N'
                        || _txt:='Karta archiwalna'@;
                           _added:=1
                        |? ~exec('tktl_act','tech_head',4)
                        || _txt:='Karta nieaktualna'@;
                           _added:=1
                        ?}
                     ?}
                  ?}
               ?};
               {? _added=1
               || exec('tktl_chck_add','tech_structure',$_ktl,$TMAT.ref,_txt,TMAT.PT().N,
                        exec('FindAndGet','#table',TKTL,_ktl,,'NRK',''),exec('FindAndGet','#table',TKTL,_ktl,,'WER',''),
                        $TMAT.PT,{? _arch<>'N' || 'T' || 'N' ?})
               ?};

               {? TMAT.ACT='T' & TMAT.MAG<>'T' & _ktl<>null()
               || .TABO.cntx_psh();
                  .TABO.prefix();
                  TMAT.cntx_psh();
                  TKTL.cntx_psh();

::                  .UPNODE:=0;
                  .TABO.cntx_psh();
                  _unrop:=TMAT.NROP().UNROP;
                  {? _unrop=0
                  || .LP+=1
                  || .TABO.index(.NDXOU);
                     .TABO.prefix(_unrop);
                     {? .TABO.first()
                     || .LP:=.TABO.LP-0.1
                     || .LP+=1
                     ?}
                  ?};
                  .TABO.cntx_pop();

                  .tabadd(_tpar_parent);
                  .UPNODE:=.NODE;
                  _t:=.UP_T;

                  {? var_pres('_tpar_my')>100
                  || obj_del(_tpar_my)
                  ?};

                  {? TKTL.TYP().PAR='T'
                  ||
::                   Obsluga translacji parametrow
::                   Tworze obiekt z parametrami na moim poziomie
                     _tpar_my:=obj_new(@.CLASS.TPAr,TMAT.PT);
                     _tpar_my.TABLE:=TPAR;
                     _tpar_my.INDEX:='NN';
::                   Ładuje obiekt z parametrami na moim poziomie
                     _tpar_my.PREFIX:=_ktl;
                     _tpar_my.loadp(ref_name(_ktl)+3);
::                   Przeliczam wartosci uwzgledniajac translacje
                     _tpar_my.mod_tra(TMAT.ref(),,_tpar_parent,ref_name(TMAT.ref())+3)
                  || _tpar_my:=~~
                  ?};

::                !!! REKURENCJA !!!
                  {? _added=0 || .to_load(_ktl,$TMAT.ref(),_c,_tpar_my) ?};
                  TKTL.cntx_pop();
                  TMAT.cntx_pop();
                  .TABO.cntx_pop();
                  .UPNODE:=.TABO.UPNODE;
                  .UP_T:=_t
               ?};
               TMAT.next()
            !}
         ?}
      ?}
   ?};
   TKTL.cntx_pop();
   TMAT.cntx_pop();

~~"),

obj_meth('sciezka',"

   _tktl:=_a;
   _tmat:=_b;
:: Tryb wyswietlania zawartosci - 'O' - lista operacji; 'S' - lista stanowisk
   _mode:=_c;
   _parent:=_d;

   _tpar_parent:=_e;

   TOPER.cntx_psh();

:: Otwieram odpowiednia maske TOPERa
   _mask:=ref_name(TKTL.ref());
   _msk_toper:=form((TOPER.name()-3)+(_mask+3));
   TOPER.use(_msk_toper);

   TOPER.index('NNN');
   TOPER.prefix(TKTL.ref(),_parent);
   {? TOPER.first()
   || {!
      |? {? TOPER.ACT='T'
         || {? TOPER.PZ='P'
            || .przytab(_tktl,_tmat,_mode,_tpar_parent)
            || {? TOPER.NRNOP=0
               || .NUMER:=form(TOPER.NROP,,,'9.')
               || .NUMER+='.'+form(TOPER.NROP,,,'9.')
               ?};

::             !!! REKURENCJA !!!
               .sciezka(_tktl,_tmat,_mode,TOPER.UNROP,_tpar_parent);
               .NUMER-=(+(form(TOPER.NROP,,,'9.'))+1)
            ?}
         ?};
         TOPER.next()
      !}
   ?};
   TOPER.cntx_pop();
   ~~
"),

obj_meth('przytab',"

   _tktl:=_a;
   _tmat:=_b;
:: Tryb wyswietlania zawartosci - 'O' - lista operacji; 'S' - lista stanowisk
   _mode:=_c;

   _tpar_parent:=_d;

   {? TOPER.TPZ='N' | _mode<>'O'
   || .TABO.index(.NDX2)
   || .TABO.index(.NDX2TP)
   ?};
   {? _mode='O'
   || {? TOPER.TPZ='N'
      || {? .FAZ=1
         || .TABO.prefix(.UPNODE,#TOPER.PFAZ,#.UP_T,$TOPER.NRK,#TOPER.OPER,TOPER.UNROP)
         || .TABO.prefix(.UPNODE,0,#.UP_T,$TOPER.NRK,#TOPER.OPER,TOPER.UNROP)
         ?}
      || {? .FAZ=1
         || .TABO.prefix(.UPNODE,#TOPER.PFAZ,#.UP_T,$TOPER.NRK,TOPER.TPZREF)
         || .TABO.prefix(.UPNODE,0,#.UP_T,$TOPER.NRK,TOPER.TPZREF)
         ?}
      ?}
   || {? TOPER.GRPOJ='S'
      || _place:=TOPER.PLACE
      || _place:=TOPER.TWRKPLG().ELEMENT
      ?};
      {? .FAZ=1
      || .TABO.prefix(.UPNODE,#TOPER.PFAZ,#.UP_T,$TOPER.NRK,#_place)
      || .TABO.prefix(.UPNODE,0,#.UP_T,$TOPER.NRK,#_place)
      ?}
   ?};
   {? .TABO.first()
   || .przypwar(_tpar_parent);
      .TABO.put()
   || .TABO.prefix();
      .TABO.TMAT:=_tmat;
      .LP+=1;
      .addtabo(_mode,_tpar_parent)
   ?};
   ~~
"),


obj_meth('przypwar',"
:: Obiekt TPAr zawierajacy przeliczone wartosci parametrow z wyzszego poziomu
   _tpar:=_a;
   TOPER.cntx_psh();
   {? TOPER.FNTIME<>''
   || {? TOPER.TPZ='T'
      || .TABO.TPZ+=_tpar.calc(TOPER.FNTIME)
      || .TABO.TIME+=_tpar.calc(TOPER.FNTIME)
      ?}
   || {? TOPER.TPZ='T'
      || .TABO.TPZ+=TOPER.NTIME
      || .TABO.TIME+=TOPER.NTIME
      ?}
   ?};
   {? TOPER.FMTIME<>''
   || .TABO.TIMEM+=_tpar.calc(TOPER.FMTIME)
   || .TABO.TIMEM+=TOPER.MTIME
   ?};
   TOPER.cntx_pop();
   ~~
"),


obj_meth('po_load',"
:: WE: _a - PLRELWYR.ref()
   .UPNODE:=0;
   .NODE:=0;
   PLRELWYR.first();
   .UP_T:=PLRELWYR.TOWAR;
   .UP_KTL:=PLRELWYR.TKTL;
   {? PLRELWYR.first()
   || _i:=0; _ok:=.ltpar();
      {!
      |? .TABO.index(.NDX2);
         M.cntx_psh();
         M.clear();
         {? M.seek(PLRELWYR.TOWAR)
         || _pt:=M.ref(); _pt_s:=M.KTM
         || _pt:=null(); _pt_s:=''
         ?};
         M.cntx_pop();
         .TABO.prefix(.UPNODE,0,#.UP_T,PLRELWYR.RTKTL,0);
         {? .TABO.first()
         || .TABO.ILO+=PLRELWYR.ILOSC;.TABO.put()
         || .TABO.blank();
            _i+=1;
            .NODE+=1;
            .TABO.UPNODE:=.UPNODE;
            .TABO.NODE:=.NODE;
            .TABO.SCIEZKA:='…';
            .TABO.LP+=1;
            .TABO.ILO:=PLRELWYR.ILOSC;
            .TABO.PT:=#_a;
            .TABO.PFAZ:=null();
            .TABO.PFAZ_S:='';
            .TABO.KTL:=#PLRELWYR.TKTL;
            .TABO.RKTL:=PLRELWYR.RTKTL;
            .TABO.UP_T:=#.UP_T;
            .TABO.UP_KTL:=#.UP_KTL;
            .TABO.UP_RKTL:=$.UP_KTL;
            .TABO.POD:=1;
            .TABO.TPZ:=0;
            .TABO.UNROP:=0;
            {? _ok || .ltpar1() || _ok:=.ltpar() ?};
            {? .TABO.add()
            || {? PLRELWYR.RTKTL<>''
               || .TABO.cntx_psh();
                  PLRELWYR.cntx_psh();
                  .UPNODE:=.NODE;
                  TMAT.clear();
                  _tktl:=exec('FindAndGet','#table',TKTL,PLRELWYR.RTKTL,,,null());
                  .to_load(_tktl,'',_d,.TABO.ILO);
                  .TABO.cntx_pop();
                  PLRELWYR.cntx_pop();
                  .UPNODE:=.TABO.UPNODE
               ?}
            ?}
         ?};
         PLRELWYR.next()
      !}
   ?};
   .count(0);
   .sumtabo(0,_c);
   .utwtab1();
   ~~
"),

obj_meth('utwtab1',"
   .TABO.index(.NDX4);
   .TABO.first();
   _zm:=.TABO.OPER_S;
   _faza:=.TABO.PFAZ;
   _ilosc:=0;
   _ilosc1:=0;
   _tpz:=0;
   _pierwszy:=1;
   {!
   |? {? .TABO.OPER<>0 | .TABO.OPER_S='  RAZEM:'
      || {? _zm<>.TABO.OPER_S & (.FAZ=0 | _faza<>.TABO.PFAZ)
         || {? _pierwszy=0
            || .TABO1.TIME:=|_ilosc;
               .TABO1.TIMEM:=|_ilosc1;
               .TABO1.TPZ:=|_tpz;
               .TABO1.add()
            ?};
            _ilosc:=.TABO.TIME;
            _ilosc1:=.TABO.TIMEM;
            _tpz:=.TABO.TPZ;
            _pierwszy:=1;
            _zm:=.TABO.OPER_S;
            _faza:=.TABO.PFAZ
         || _ilosc+=.TABO.TIME;
            _ilosc1+=.TABO.TIMEM;
            _tpz+=.TABO.TPZ
         ?};
         {? _pierwszy
         || .TABO1.LP:=.TABO.LP;
            .TABO1.OPER:=.TABO.OPER;
            .TABO1.OPER_S:=.TABO.OPER_S;
            _pierwszy:=0
         ?}
      || _zm:=.TABO.T_S;
         _faza:=.TABO.PFAZ
      ?};
      .TABO.next()
   !};
   {? _pierwszy=0
   ||.TABO1.TIME:=|_ilosc;
     .TABO1.TIMEM:=|_ilosc1;
     .TABO1.TPZ:=|_tpz;
     .TABO1.add()
   ?};
   ~~
"),


obj_meth('tabadd',"

   _tpar:=_a;

  .NODE+=1;
  .TABO.UPNODE:=.UPNODE;
  .TABO.NODE:=.NODE;
  .TABO.OPER:=0;
  .TABO.POD:=1;
  .TABO.WEW:='T';
  _added:=0;
  _arch:='N';
   {? var_pres('__ENV_STR')>0 & var_pres('TAB_ZAM',__ENV_STR.CHECK)>0 & __ENV_STR.CHECK.TAB_ZAM.find_tab(,'TMAT',,'=',$TMAT.ref)
   || _ktl:=exec('FindAndGet','#table',TKTL,__ENV_STR.CHECK.TAB_ZAM.KTLW,,,null())
   ||
      {? TMAT.DFLT_KTL='T'
      || _ktl:=exec('dflt_ktl','tech_prod',{? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?},,1);
         {? _ktl=null()
         || _txt:='Brak karty domyślnej'@;
            _added:=1
         |? ~exec('tktl_act','tech_head',,$_ktl)
         || _txt:='Karta domyślna nieaktualna'@;
            _added:=1
         ?}
      || _ktl:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,,null());
         {? _ktl<> null
         || _arch:=exec('FindAndGet','#table',TKTL,_ktl,,'ARCH','N');
            {? _arch<>'N'
            || _txt:='Karta archiwalna'@;
               _added:=1
            |? ~exec('tktl_act','tech_head',4)
            || _txt:='Karta nieaktualna'@;
               _added:=1
            ?}
         ?}
      ?}
   ?};
   {? _added=1
   || exec('tktl_chck_add','tech_structure',$_ktl,$TMAT.ref,_txt,TMAT.PT().N,
         exec('FindAndGet','#table',TKTL,_ktl,,'NRK',''),exec('FindAndGet','#table',TKTL,_ktl,,'WER',''),
         $TMAT.PT,{? _arch<>'N' || 'T' || 'N' ?})
   ?};
   TKTL.cntx_psh();
   {? _ktl<>null()
   ||
      _mask:=ref_name(_ktl);
      {? TKTL.name()<>_mask
      || TKTL.use(_mask)
      ?}
   ?};
   TKTL.clear();
   {? TKTL.seek(_ktl)
   || .TABO.T_S:=TKTL.KTM().KTM;
      .TABO.T_NAZ:=TKTL.KTM().N
   || .TABO.T_S:='';
      .TABO.T_NAZ:=''
   ?};
   TKTL.cntx_pop();
   .TABO.OPER_S:='Produkcja półfabrykatu: '+.TABO.T_NAZ;
   .TABO.SCIEZKA:=.TABO.T_S;
   .TABO.TOPER:=#TMAT.NROP;
   {? TMAT.FORMB<>''
   || .TABO.ILO:=_tpar.calc(TMAT.FORMB)
   || .TABO.ILO:=TMAT.WARB
   ?};
   .TABO.TIME:=0;
   .TABO.TPZ:=0;
   .TABO.UNROP:=0;
   .TABO.TIMEM:=0;'tutaj jeszcze moze byc z wykorzystaniem parametru';
   .TABO.PFAZ:={? .FAZ=1 || #TMAT.PFAZ || 0 ?};
   .TABO.PFAZ_S:={? .FAZ=1 || TMAT.PFAZ().KOD || ''?};
   .TABO.KTL:=#_ktl;
   .TABO.RKTL:=$_ktl;
   .TABO.UP_T:=#.UP_T;
   .TABO.UP_KTL:=#.UP_KTL;
   .TABO.LP:=.LP;
   .TABO.add();
   ~~
"),


obj_meth('addtabo',"

:: Obiekt TPAr zawierajacy przeliczone wartosci parametrow z wyzszego poziomu
   _tpar:=_b;

   TMAT.cntx_psh();
   {? TOPER.GRPOJ='S'
   || _place:=TOPER.PLACE;
      _placen:=TOPER.PLACE().NA
   || _place:=TOPER.TWRKPLG().ELEMENT;
      _placen:=TOPER.TWRKPLG().ELEMENT().NA
   ?};
   .NODE+=1;
   .TABO.UPNODE:=.UPNODE;
   .TABO.NODE:=.NODE;
   {? _a='O'
   || .TABO.OPER:=#TOPER.OPER;
      {? TOPER.WEW='T'
      || .TABO.OPER_S:=TOPER.OPER().NA
      || .TABO.OPER_S:=TOPER.TTOUT().NA
      ?}
   || .TABO.OPER:=#_place;
      .TABO.OPER_S:=_placen
   ?};
   .TABO.POD:=0;
   .TABO.WEW:=TOPER.WEW;
   .TABO.SCIEZKA:={? .NUMER<>'' || .NUMER+'.'+form(TOPER.NROP,,,'9.') || form(TOPER.NROP,,,'9.') ?};
   .TABO.T_S:=TKTL.KTM().KTM;
   .TABO.T_NAZ:=TKTL.KTM().N;
   .TABO.TIME:=0;
   .TABO.TIMEM:=0;'tutaj jeszcze moze byc z wykorzystaniem parametru';
   .przypwar(_tpar);
   .TABO.PFAZ:={? .FAZ=1 || #TOPER.PFAZ || 0 ?};
   .TABO.PFAZ_S:={? .FAZ=1 || TOPER.PFAZ().KOD || '' ?};
   .TABO.KTL:=#TOPER.NRK;
   .TABO.RKTL:=$TOPER.NRK;
   .TABO.UP_T:=#.UP_T;
   .TABO.UP_KTL:=#.UP_KTL;
   .TABO.TOPER:=#TOPER.ref();
   .TABO.UNROP:=TOPER.UNROP;
   .TABO.LP:=.LP;
   .TABO.add();
   TMAT.cntx_pop()
"),

obj_meth('sel1',"
   .TZZ:=_c;
   {? .WERW1=''
   || .win1_sel(_b);
      .win1_edit(_b);
      .TABO.win_sel(.WERW1);
      .TABO.win_edit(.REDW1)
   ?};
   .TABO.index(.NDXO4);
   .TABO.prefix(_a);
   .TABO.select()
"),

obj_meth('sel2',"
   .TZZ:=_b;
   {? .WERW1=''
   || .win1_sel(_a);
      .win1_edit(_a);
      .TABO.win_sel(.WERW1);
      .TABO.win_edit(.REDW1)
   ?};
   {? .FAZ
   || .TABO.index(.NDXO5)
   || .TABO.index(.NDXO3)
   ?};
   .TABO.prefix(0);
   .TABO.win_fml(.WERW1,,'OPER_S',,'ICON_BEFORE',$(\"
                                                  {?\"+!.ME+\".TABO.WEW='T'
                                                  || 'xwin16.png:33'
                                                  || 'xwin16.png:90'
                                                  ?}
                                                 \"));
   .TABO.select();
   .TABO.win_fml(.WERW1,,'OPER_S',,'ICON_BEFORE',\"''\");
   ~~
"),

obj_meth('sel3',"
   {? .WERW1=''
   || .win2_sel(_a);
      .win2_edit(_a);
      .TABO1.win_sel(.WERW1);
      .TABO1.win_edit(.REDW1)
   ?};
   .TABO1.index(.NDX3);
   .TABO1.prefix();
   .TABO1.select()
"),

obj_meth('count',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: PRIVATE
::       Metoda przelicza cale drzewo operacji wg norm z kart wyzszego rzedu - uzyta w __init()
::   WE: _a - up-node
::----------------------------------------------------------------------------------------------------------------------
   {? _a=0 || .COEFN:=1 ?};
   .TIME:=.TIMEM:=.TPZ:=0;
   .TABO.cntx_psh();
   .TABO.index(.NDX2);
   .TABO.prefix(_a);
   {? .TABO.first()
   || {!
      |?
         .TABO.TIME:=.TABO.TIME*.COEFN;
         .TABO.TIMEM:=.TABO.TIMEM*.COEFN;
         .TABO.put();
         .TIME+=.TABO.TIME;
         .TIMEM+=.TABO.TIMEM;
         .TPZ+=.TABO.TPZ;
         {? .TABO.OPER=0
         || TKTL.cntx_psh();
            {? .TABO.RKTL<>''
            || TKTL.use(form(8+.TABO.RKTL));
               {? TKTL.seek(.TABO.RKTL)
               || _xjm:=TKTL.XJM
               || _xjm:=1
               ?}
            || _xjm:=1
            ?};
            TKTL.cntx_pop();
            _cfn:=.COEFN;
            .COEFN:=_cfn*.TABO.ILO/_xjm;
            {? .TIME<>0 | .TIMEM<>0
            || _time:=.TIME;
               _timem:=.TIMEM
            ?};
            .count(.TABO.NODE);
            .TABO.TIME:=.TIME;
            .TABO.TIMEM:=.TIMEM;
            .TABO.TPZ:=.TPZ;
            .TABO.put();
            {? var_pres('_time')>0
            || .TIME+=_time;
               .TIMEM+=_timem
            ?};
            .COEFN:=_cfn
         ?};
         .TABO.next()
      !}
   ?};
   .TABO.cntx_pop();
   ~~
",1),

obj_meth('sumtabo',"
:: --> Wylaczone dzialanie tej formuly, gdyz sa drzewka "po nowemu"
   return();
   .TABO.cntx_psh();
   _time:=_timem:=0;
   .TABO.index(.NDX2);
   {? _b=0
   || .TABO.prefix()
   || .TABO.prefix(_a)
   ?};
   .TABO.first();
   {!
   |?
      {? .TABO.OPER<>0 | .TABO.OPER_S='Produkcja półfabrykatu' & _b=1
      || _time+=.TABO.TIME;
         _timem+=.TABO.TIMEM
      ?};
      .TABO.next()
   !};
   .TABO.index(.NDXO4);
   .TABO.prefix(_a,'…','  RAZEM:');
   {? ~.TABO.first
   || .TABO.SCIEZKA:='…';
      .TABO.OPER_S:='  RAZEM:';
      .TABO.UPNODE:=_a;
      .TABO.OPER:=0;
      .TABO.TIME:=_time;
      .TABO.TIMEM:=_timem;
      .TABO.TPZ:=0;
      .TABO.PFAZ_S:='';
      .TABO.LP+=1;
      .TABO.add()
   || .TABO.TIME:=_time;
      .TABO.TIMEM:=_timem;
      .TABO.put()
   ?};
   .TABO.cntx_pop()
"),

obj_meth('win3_sel',"
   _timedok:=exec('get','#params',500604,1);
   .WERW1:=.ZTABW.mk_sel('Stanowiska do zlecenia'@,,,'ztabw_werw1',,10);
   .ZTABW.win_fld(.WERW1,,'KTM',,,15,,,'Towar'@);
   .ZTABW.win_fld(.WERW1,,'ZL',,,15,,,'Zlecenie'@);
   .ZTABW.win_fld(.WERW1,,'IL',,,10,,,'Ilość'@);
   .ZTABW.win_fld(.WERW1,,'OPER',,,30,,,'Operacja'@);
   .ZTABW.win_fld(.WERW1,,'MTIME',,,-10,_timedok,,'Czas operacji'@);
   .ZTABW.win_fld(.WERW1,,'TIMEP',,,-10,_timedok,,'Czas maszynowy'@);
   .ZTABW.win_sel(.WERW1);
   ~~
"),

obj_meth('win4_sel',"
   _timedok:=exec('get','#params',500604,1);
   .WERW1:=.ZTABZ.mk_sel('Zawody do zlecenia'@,,,'ztabz_werw1');
   .ZTABZ.win_fld(.WERW1,@.ZAW,'KOD',,,10,,,'Kod stanowiska'@);
   .ZTABZ.win_fld(.WERW1,@.ZAW,'ZD',,,20,,,'Nazwa stanowiska'@);
   .ZTABZ.win_fld(.WERW1,,'ZL',,,10,,,'Zlecenie'@);
   .ZTABZ.win_fld(.WERW1,,'TIMEP',,,-10,_timedok,,'Czas maszynowy'@);
   ~~
"),

obj_meth('win5_sel',"
   _timedok:=exec('get','#params',500604,1);
   .WERSKL:=.SKL.mk_sel('Stanowiska'@,,,'grupa_skl1');
   .SKL.win_fld(.WERSKL,@.TWRKPLC,'KOD',,,10,,,'Kod stanowiska'@);
   .SKL.win_fld(.WERSKL,@.TWRKPLC,'NA',,,20,,,'Nazwa stanowiska'@);
   {? .TZ='P' ||.SKL.win_fld(.WERSKL,,'ZLMTIME',,,12,_timedok,,'Obc.dla zleceń'@) ?};
   {? (.TZ='A'|.TZ='Z') & ZL.STAN='O'
   || .SKL.win_fld(.WERSKL,,'TIMEP',,,12,_timedok,,'Wyk.wg planu'@);
      .SKL.win_fld(.WERSKL,,'TIMER',,,12,_timedok,,'Wyk w rzecz.'@)
   ?};
   .SKL.win_act(.WERSKL,0,'Rekord',,,,$(\"
   {? ~TWRKPLC.seek(\"+!.ME+\".SKL.PLACE,'tworkplc') || TWRKPLC.blank() ?} \"));
   .SKL.win_sel(.WERSKL);
   ~~
"),

obj_meth('win2_sel',"
   _timedok:=exec('get','#params',500604,1);
   {? _a='O'
   || .WERW1:=.TABO1.mk_sel('Operacje elementarne'@,,,'tabo1_werw1_o'+$.FAZ);
      .TABO1.win_fld(.WERW1,@.TTOPER,'KOD',,,10,,,'Kod operacji'@)
   || .WERW1:=.TABO1.mk_sel('Stanowiska elementarne'@,,,'tabo1_werw1_s'+$.FAZ);
      .TABO1.win_fld(.WERW1,@.TWRKPLC,'KOD',,,10,,,'Kod stanowiska'@)
   ?};
   .TABO1.win_fld(.WERW1,,'OPER_S',,,60,,,'Nazwa '@);
   .TABO1.win_fld(.WERW1,,'TIME',,,-10,_timedok,,'Czas operacji'@);
   {? _a='O' || .TABO1.win_fld(.WERW1,,'TPZ',,,12,_timedok,,'TPZ'@) ?};
   .TABO1.win_fld(.WERW1,,'TIMEM',,,-10,_timedok,,'Czas maszynowy'@);
   {? .FAZ=1 || .TABO1.win_fld(.WERW1,,'PFAZ_S',,,-10,,,'Faza produkcji'@)?};
   {? _a='O'
   || .TABO1.win_act(.WERW1,0,'Rekord',,,,$(\"
         TTOPER.clear;
         {? ~TTOPER.seek(\"+!.ME+\".TABO1.OPER,'ttoper')
         || TTOPER.KOD:=''
         ?};
         {? \"+!.ME+\".TABO1.OPER_S='  RAZEM:' | \"+!.ME+\".TABO.OPER_S='Produkcja półfabrykatu'
         || \"+!.ME+\".TABO1.win_edit();
            exec('findtmp','#color')
         || \"+!.ME+\".TABO1.win_edit(\"+!.ME+\".REDW1);''
         ?}\"))
   || .TABO1.win_act(.WERW1,0,'Rekord',,,,$(\"
         TWRKPLC.clear;
         {? ~TWRKPLC.seek(\"+!.ME+\".TABO1.OPER,'tworkplc')
         || TWRKPLC.KOD:=''
         ?};
         {? \"+!.ME+\".TABO1.OPER_S='  RAZEM:' | \"+!.ME+\".TABO.OPER_S='Produkcja półfabrykatu'
         || \"+!.ME+\".TABO1.win_edit();
            exec('findtmp','#color')
         || \"+!.ME+\".TABO1.win_edit(\"+!.ME+\".REDW1);''
         ?}\"))
   ?};
   .TABO1.win_act(.WERW1,0,'Formuła','Druku&j'@@,,,
         {? _a='O' || \"rep_exec('an_oper');~~\" || \"rep_exec('an_stano');~~\" ?});
   ~~
"),

obj_meth('win2_edit',"
   {? _a='O'
   || .REDW1:=.TABO1.mk_edit('Obciążenia operacji dla karty: %1 wer. %2'@[TKTL.NRK,TKTL.WER],
                             0,'tabo1_redw1_o'+$.FAZ)
   || .REDW1:=.TABO1.mk_edit('Obciążenia stanowisk dla karty: %1 wer. %2'@[TKTL.NRK,TKTL.WER],
                             0,'tabo1_redw1_s'+$.FAZ)
   ?};
   {? _a='O'
   || .TABO1.win_efld(.REDW1,@.TTOPER,'KOD',,,15,,,'Kod'@)
   || .TABO1.win_efld(.REDW1,@.TWRKPLC,'KOD',,,15,,,'Kod'@)
   ?};
   .TABO1.win_efld(.REDW1,,'OPER_S',,,25,,,'Nazwa'@);
   {? .FAZ=1
   || .TABO1.win_efld(.REDW1,,'PFAZ_S',,,15,,,'Faza produkcji'@)
   ?};
   ~~
"),

obj_meth('win1_sel',"
   _timedok:=exec('get','#params',500604,1);
   {? _a=0
   || .WERW1:=.TABO.mk_sel({? .TZZ='O' || 'Operacje elementarne'@ || 'Stanowiska elementarne'@ ?}+
         {? .TZ='ZO' || ' dla zlecenia: '+ ZL.SYM || ' dla karty: ' +TKTL.NRK+' wer. '+TKTL.WER ?},'P',
         0,'#tabo_werw1o0',,,,,'U')
   || .WERW1:=.TABO.mk_sel('Obciążenia '+{? .TZZ='O' || 'operacji' || 'stanowisk' ?}+
         {? .TZ='ZO' || ' dla zlecenia: '+ ZL.SYM || ' dla karty: ' +TKTL.NRK+' wer. '+TKTL.WER ?},'P',
         0,'#tabo_werw1o1',,,,,'U')
   ?};
   .TABO.win_fld(.WERW1,,'OPER_S',,,50,,,'Nazwa'@);
   .TABO.win_fld(.WERW1,,'TIME',,,-10,_timedok,,'Czas operacji'@);
   {? .TZZ='O'
   || .TABO.win_fld(.WERW1,,'TPZ',,,10,_timedok,,'TPZ'@)
   ?};
   .TABO.win_fld(.WERW1,,'TIMEM',,,-10,_timedok,,'Czas maszynowy'@);
   .TABO.win_fld(.WERW1,,'T_S',,,20,,,'Do produktu'@);
   {? .FAZ=1 || .TABO.win_fld(.WERW1,,'PFAZ_S',,,-10,,,'Faza produkcji'@) ?};
   {? _a=1 ||.TABO.win_act(.WERW1,0,'Formuła',{? .TZZ='O' || 'Dalsze operacje'@@ || 'Dalsze stanowiska'@@ ?},,,$(\"
      {? \"+!.ME+\".TABO.OPER=0 & \"+!.ME+\".TABO.OPER_S<>'  RAZEM:'
      || \"+!.ME+\".TABO.cntx_psh(); \"+!.ME+\".sumtabo( \"+!.ME+\".TABO.NODE,1);
         \"+!.ME+\".sel1(\"+!.ME+\".TABO.NODE,1,\"+!.ME+\".TZZ);
         \"+!.ME+\".sumtabo(0,1);
         \"+!.ME+\".TABO.cntx_pop()
      || FUN.emsg({? \"+!.ME+\".TZZ='O' || 'Brak dalszych operacji.'@ || 'Brak dalszych stanowisk.'@ ?})
      ?}\"),,1)
   ?};
::   {? .TZZ='S'
::   ||.TABO.win_act(.WERW1,0,'Formuła','Operacje',,,$(\"exec('selop','tech_oper',\"+!.ME+\".TABO.OPER,'S','W');~~\"))
::   ?};
   .TABO.win_act(.WERW1,,'Kolejność');
   .TABO.win_act(.WERW1,0,'Rekord',,,,$(\"{? \"+!.ME+\".TZZ='O'
   || TTOPER.clear;{? ~TTOPER.seek(\"+!.ME+\".TABO.OPER,'ttoper')
                   || TTOPER.KOD:='­'\
                   ?}
   || TWRKPLC.clear;{? ~TWRKPLC.seek(\"+!.ME+\".TABO.OPER,'tworkplc')
                   || TWRKPLC.KOD:='­'\
                   ?}
   ?};
   {? \"+!.ME+\".TABO.OPER_S='  RAZEM:' | \"+!.ME+\".TABO.OPER_S='Produkcja półfabrykatu'
   || \"+!.ME+\".TABO.win_edit();exec('findtmp','#color')
   || \"+!.ME+\".TABO.win_edit(\"+!.ME+\".REDW1);''
   ?}\"));
   ~~
"),

obj_meth('win1_edit',"
   {? _a=0
   || .REDW1:=.TABO.mk_edit({? .TZZ='O' || 'Operacja elementarna'@ || 'Stanowisko elementarne'@ ?}+
         ' dla karty: '+TKTL.NRK+' wer. '+TKTL.WER,0,-.TZZ+'_tabo_redw10_'+$.FAZ)
   || .REDW1:=.TABO.mk_edit('Obciążenia'+{? .TZZ='O' || ' operacji' || ' stanowisk' ?}+
         ' dla karty: '+TKTL.NRK+' wer. '+TKTL.WER,0,-.TZZ+'_tabo_redw11_'+$.FAZ)
   ?};
   {? .TZZ='O'
   || .TABO.win_efld(.REDW1,@.TTOPER,'KOD',,,15,,,'Kod'@)
   || .TABO.win_efld(.REDW1,@.TWRKPLC,'KOD',,,15,,,'Kod'@)
   ?};
   .TABO.win_efld(.REDW1,,'OPER_S',,,50,,,'Nazwa'@);
   .TABO.win_efld(.REDW1,,'SCIEZKA',,,15,,,'Numer operacji'@);
   {? .FAZ=1
   || .TABO.win_efld(.REDW1,,'PFAZ_S',,,15,,,'Faza produkcji'@)
   ?};
   .TABO.win_efld(.REDW1,,'T_S',,,20,,,'Kod produktu'@);
   .TABO.win_efld(.REDW1,,'T_NAZ',,,40,,,'Nazwa produktu'@);
   ~~
"),

obj_meth('sel_grp',"
   _timedok:=exec('get','#params',500604,1);
   .WERW2:=.TABW.mk_sel('Stanowiska dla planu okresowego'@,,,'ztabw_werw3',,10);
   .TABW.win_fld(.WERW2,,'S_PLACE',,,15,,,'Kod'@);
   .TABW.win_fld(.WERW2,@.TWRKPLC,'NA',,,60,,,'Stanowisko'@);
   .TABW.win_fld(.WERW2,,'MTIME',,,15,_timedok,,'Czas maszynowy'@);
   .TABW.win_fld(.WERW2,,'TIMEKAL',,,15,_timedok,,'Czas kalendarzowy'@);
   .TABW.win_act(.WERW2,0,'Rekord',,,,$(\"
      {? ~TWRKPLC.seek(\"+!.ME+\".TABW.PLACE,'tworkplc') || TWRKPLC.blank() ?};
      {? \"+!.ME+\".TABW.S_PLACE='  RAZEM:'
      || \"+!.ME+\".TABW.win_edit();
         exec('findtmp','#color')
      || \"+!.ME+\".TABW.win_edit(\"+!.ME+\".REDW1);''
      ?} \"));

   .WERZ1:=.TABZ.mk_sel('Zawody dla planu okresowego'@,,,'ztabz_werw2');
   .TABZ.win_fld(.WERZ1,@.ZAW,'KOD',,,10,,,'Kod'@);
   .TABZ.win_fld(.WERZ1,,'S_ZAWOD',,,67,,,'Zawód'@);
   .TABZ.win_fld(.WERZ1,,'NTIME',,,10,,,'Czas operacji'@);
   .TABZ.win_fld(.WERZ1,,'TPZ',,,10,,,'TPZ'@);
   .TABZ.win_fld(.WERZ1,,'TIMEKAL',,,10,_timedok,,'Czas kalendarzowy'@);
   .TABZ.win_act(.WERZ1,0,'Rekord',,,,$(\"
      {? ~ZAW.seek(\"+!.ME+\".TABZ.ZAWOD,'zawody') || ZAW.blank() ?};
      {? \"+!.ME+\".TABZ.S_ZAWOD='  RAZEM:'
      || \"+!.ME+\".TABZ.win_edit();
         exec('findtmp','#color')
      || \"+!.ME+\".TABZ.win_edit(\"+!.ME+\".REDW1);''
      ?} \"));

   .WERU1:=__UTIL.mk_sel('Narzędzia dla planu okresowego'@,,0,'pl_util',,3);
   __UTIL.win_fld(.WERU1,,'KOD',,,10,,,'Kod'@);
   __UTIL.win_fld(.WERU1,,'NAZ',,,46,,,'Narzędzie'@);
   __UTIL.win_fld(.WERU1,,'EGZ',,,10,,,'Liczba ezgemplarzy'@);
   __UTIL.win_fld(.WERU1,,'TIME',,,15,_timedok,,'Czas planowany'@);
   __UTIL.win_fld(.WERU1,,'KALTIME',,,15,_timedok,,'Czas kalendarzowy'@);
   __UTIL.win_act(.WERU1,0,'Rekord',,,,\"
      {? __UTIL.KOD='  RAZEM:'
      || exec('findtmp','#color')
      || ''
      ?}\");

   .WERW1:=.TABW.grp_make('Obciążenia dla planu okresowego'@,,'ztabw_werw2');
   .TABW.grp_sel(.WERW1,,.WERW2,'Stanowiska'@,,,0,26,,,,,'maximized_with_title');
   .TABW.grp_sel(.WERW1,.TABZ,.WERZ1,'Zawody'@,,,0,26,,,,,'maximized_with_title');
   .TABW.grp_sel(.WERW1,__UTIL,.WERU1,'N-P-U'@,,,0,26,,,,,'maximized_with_title');
   .TABW.win_sel(.WERW1)
"),

obj_virt('tree',"
   FUN.info('tree/ntim_obj - brak metody wirtualnej.'@)
"),

obj_meth('cleantab',"
   .TABO.erase();
   .TABO1.erase();
   .TABZ.erase();
   .TABW.erase();
   .ZTABW.erase();
   .ZTABZ.erase();
   .SKL.erase();
   .TABO.blank();
   .TABO1.blank();
   .TABZ.blank();
   .TABW.blank();
   .ZTABW.blank();
   .ZTABZ.blank();
   .SKL.blank();
   ~~
")
)
?}


\set_tree
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [2006]
:: OPIS: definiuje metode wirtualna tree do wyswietlania drzewa operacji
::  OLD: \set_tree/tex_ope1.fml
::----------------------------------------------------------------------------------------------------------------------
set_virt(__NTIME,'tree',"
   _timedok:=exec('get','#params',500604,1);
   _wer:=.TABO.mk_sel('Struktura operacji dla karty: %1 wer. %2'@[TKTL.NRK,TKTL.WER],'N',,'#tree_oper_str',,5,,1);
   .TABO.index(.NDXO4);
   .TABO.win_fld(_wer,,'SCIEZKA',,,11,,,'Numer operacji'@);
   .TABO.win_fld(_wer,,'OPER_S',,,49,,,'Operacja'@);
   .TABO.win_fld(_wer,,'TIME',,,-10,_timedok,,'Czas operacji'@);
   .TABO.win_fld(_wer,,'TPZ',,,-10,_timedok,,'TPZ'@);
   .TABO.win_fld(_wer,,'TIMEM',,,-10,_timedok,,'Czas maszynowy'@);
   .TABO.win_fld(_wer,,'T_S',,,20,,,'Do produktu'@);
   .TABO.win_sel(_wer);
   .TABO.win_act(_wer,,'Formuła','Zwiń/roz&wiń'@@,,'Zwiń/rozwiń wszystkie rekordy'@,
      \"exec('zwrw_all','#tree','__NTIME.TABO','UPNODE')\",,1);
   _display:=\"
      _tab:=cur_tab(1,1);
      {? _tab.TOPER<>0 & _tab.POD=0
      || TOPER.cntx_psh();
         TOPER.clear();
         {? TOPER.seek(_tab.TOPER)
         || _par:=exec('FindAndGet','#table',TKTL,TOPER.NRK,,\\\"TYP().PAR\\\",'N');
            {? TOPER.PZ='P' & TOPER.WEW='T'
            || TOPER.win_edit('RED_SIM'+_par);
               VAR.STRING:=TOPER.OPER().NA;
               VAR.A_PFAZ:=TOPER.PFAZ
            |? TOPER.PZ='Z' & TOPER.WEW='T'
            || TOPER.win_edit('RED_ADW'+_par);
               VAR.STRING:=TOPER.NA;
               VAR.A_PFAZ:=TOPER.PFAZ
            |? TOPER.PZ='P' & TOPER.WEW='N'
            || TOPER.win_edit('RED_OUT'+_par);
               VAR.STRING:=TOPER.TTOUT().NA;
               VAR.A_PFAZ:=TOPER.PFAZ
            || TOPER.cntx_pop();
               return()
            ?};
            exec('prep_ch','tech_oper');
            exec('efld_opt','tech_oper',TOPER);
            TOPER.display()
         ?};
         TOPER.cntx_pop()
      ?};
      ~~
   \";
   .TABO.win_act(_wer,,'Wyświetl',,,,_display);


   .TABO.win_fml(_wer,,'SCIEZKA',,'ICON_BEFORE',\"
                                                  {? __NTIME.TABO.WEW='N'
                                                  || 'xwin16.png:90'
                                                  |? __NTIME.TABO.POD=0
                                                  || 'xwin16.png:33'
                                                  |? __NTIME.TABO.POD=1
                                                  || {? __NTIME.TABO.tr_state()=0
                                                     || 'xwin16.png:32'
                                                     || 'xwin16.png:32'
                                                     ?}
                                                  || ''
                                                  ?}
                                                \");
  .TABO.win_fml(_wer,,'TIME',,'ICON_BEFORE',\"
                                                  {? __NTIME.TABO.WEW='N'
                                                  || 'xwin16.png:90'
                                                  |? __NTIME.TABO.POD=0
                                                  || 'xwin16.png:33'
                                                  |? __NTIME.TABO.POD=1
                                                  || {? __NTIME.TABO.tr_state()=0
                                                     || 'xwin16.png:32'
                                                     || 'xwin16.png:32'
                                                     ?}
                                                  || ''
                                                  ?}
                                                \");

   .TABO.select();
   .TABO.win_fml(_wer,,'SCIEZKA',,'ICON_BEFORE',\"''\");
   ~~
");
~~


\selop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Lista operacji technologii na ktorej wystepuje stanowisko
::   WE: _a - Ref sql stanowiska/gniazda lub zawodu
::       _b - G/S (gniazdo/stanowisko) - ma znaczenie dla _c='S'
::       _c - Z/S (zawod/stanowisko)
::       Kontekst - tabela NTIME.TAB
::  OLD: \selop/tex_oper.fml
::----------------------------------------------------------------------------------------------------------------------
:: Zawody
{? _c='Z'
|| ZAW.cntx_psh();
   ZAW.clear();
   {? ZAW.seek(_a,)
   || _zaw:=ZAW.ref()
   || _zaw:=null()
   ?};
   ZAW.cntx_pop();
   _tab:=sql('
      select
         case when TOPER.TPZ=''N'' then TTOPER.KOD else TPTTOPER.KOD end as KOD,
         case when TOPER.TPZ=''N'' then TTOPER.NA else ''TPZ - '' || TPTTOPER.NA end as NA,
         TOPER.UNROP
      from TOPER
      left join TOPER as TPZOPER using(TOPER.TPZREF,TPZOPER.UNROP)
      left join TTOPER using(TOPER.OPER,TTOPER.REFERENCE)
      left join TTOPER as TPTTOPER using(TPZOPER.OPER,TPTTOPER.REFERENCE)
      where (TTOPER.ZAWOD=:_a or TOPER.ZAW=:_a or TTOPER.ZAWOD is null and TOPER.ZAW is null and :_a is null)
            and TOPER.NRK=:_b and TOPER.PZ=''P'' and TOPER.WEW=''T''
   ',_zaw,VAR.A_KTL)

:: Stanowiska/gniazda
||
:: Stanowisko
   {? 8+_a='tworkplc'
   || _twrkplc:=exec('FindAndGet','#table',TWRKPLC,_a);
      _tab:=sql('
         select
            TTOPER.KOD,
            TTOPER.NA,
            TOPER.UNROP
         from TOPER
         join TTOPER using(TOPER.OPER,TTOPER.REFERENCE)
         left join TWRKPLC using(TOPER.PLACE,TWRKPLC.REFERENCE)
         where TWRKPLC.REFERENCE=:_a and TOPER.GRPOJ=''S'' and TOPER.NRK=:_b

         union all

         select
            TTOPER.KOD,
            TTOPER.NA,
            TOPER.UNROP
         from TOPER
         join TTOPER using(TOPER.OPER,TTOPER.REFERENCE)
         left join TWRKZPO using(TOPER.TWRKPLG,TWRKZPO.REFERENCE)
         left join TWRKPLC using(TWRKZPO.ELEMENT, TWRKPLC.REFERENCE)
         where TWRKPLC.REFERENCE=:_a and TOPER.GRPOJ=''G'' and TOPER.NRK=:_b
      ',_twrkplc,VAR.A_KTL)

:: Gniazdo
   || _twrkzbr:=exec('FindAndGet','#table',TWRKZBR,_a);
      _tab:=sql('
         select
            TTOPER.KOD,
            TTOPER.NA,
            TOPER.UNROP
         from TOPER
         join TTOPER using(TOPER.OPER,TTOPER.REFERENCE)
         left join TWRKPLC using(TOPER.PLACE,TWRKPLC.REFERENCE)
         left join TWRKZBR using(TOPER.GRUPA, TWRKZBR.REFERENCE)
         where (TWRKZBR.REFERENCE=:_a and TOPER.GRPOJ=''G'') and TOPER.NRK=:_b
      ',_twrkzbr,VAR.A_KTL)
   ?}
?};
_wer:=_tab.mk_sel('Operacje technologii'@,,0,'selop');
_tab.win_fld(_wer,@.VAR,'SCIEZKA',,,,,,'Numer operacji'@,,,,1);
_tab.win_fld(_wer,,'KOD',,,,,,'Kod operacji'@,,,,1);
_tab.win_fld(_wer,,'NA',,,,,,'Nazwa operacji'@,,,,1);
_tab.win_act(_wer,0,'Rekord',,,,"VAR.SCIEZKA:=exec('get_oper_nr','tech_oper',cur_tab(1,1).UNROP);~~",,1);
_tab.win_sel(_wer);
_tab.select();
~~


\pfaz_blank
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wartość początkowa pola TOPER.PFAZ
::----------------------------------------------------------------------------------------------------------------------
{? VAR.A_UNROP=0
|| _res:=null();
   _wyd:=TKTL.JORG
|| _res:=VAR.A_PFAZ;
   _wyd:=
      {? VAR.A_PFAZ().WYD<>null()
      || VAR.A_PFAZ().WYD
      || TKTL.JORG
      ?}
?};
exec('set_a_wyd','tte',_wyd);

_res


\pola_tpz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.22]
:: OPIS: Zwraca strukturę pól operacji Tpz
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new('TPZ','ZAW','COEF','FCOEF','NTIME','FNTIME','STAWKA','CIAGLA');
_obj


\get_tpz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Dla operacji zwraca czas TPZ jeśli występuje
::   WE: [_a] - TOPER.ref - operacja lub bieżący rekord
::   WY: REAL
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(TOPER.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

TOPER.cntx_psh();
{? _ref<>null()
|| TOPER.prefix();
   {? TOPER.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   TOPER.cntx_psh();
   TOPER.index('TPZ');
   TOPER.prefix('T',TOPER.UNROP);
   {? TOPER.first()
   || _result:=TOPER.NTIME
   ?};
   TOPER.cntx_pop()
?};
TOPER.cntx_pop();
_result


\has_oper_prev
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Sprawdza czy dana operacja ma jakies poprzedniki
::   WE: [_a] - TOPER.ref
::   WY: 0 - nie ma
::       1 - ma
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(TOPER.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

TOPER.cntx_psh();
{? _ref<>null()
|| TOPER.prefix();
   {? TOPER.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   NASTOPER.cntx_psh();
   NASTOPER.index('NASTOP');
   NASTOPER.prefix('T',TOPER.ref());
   {? NASTOPER.size()>0
   || _result:=1
   ?};
   NASTOPER.cntx_pop();
   ~~
?};
TOPER.cntx_pop();
_result


\has_oper_next
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Sprawdza czy dana operacja ma jakies poprzedniki
::   WE: [_a] - TOPER.ref
::   WY: 0 - nie ma
::       1 - ma
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(TOPER.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

TOPER.cntx_psh();
{? _ref<>null()
|| TOPER.prefix();
   {? TOPER.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   NASTOPER.cntx_psh();
   NASTOPER.index('OPNAST');
   NASTOPER.prefix('T',TOPER.ref());
   {? NASTOPER.size()>0
   || _result:=1
   ?};
   NASTOPER.cntx_pop();
   ~~
?};
TOPER.cntx_pop();
_result


\oper_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Tworzy tablice tymczasową zawierającą etapy
::   WY: tab_tmp
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_result:=tab_tmp(1,
   'REF','STRING[16]','Ref operacji',
   'NR','INTEGER','Nr operacji',
   'NAME','STRING[100]','Nazwa operacji'
);
_result


\oper_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Dodaje do tabeli z etapami bieżącego TOPERa o ile jeszcze go tam nie ma
::   WE: _a - tab_tmp - tabelka do której dodawać
::       [_b] - TOPER.ref() - etap który dodać lub bieżący rekord
::   WY: 0/1
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;

_ref:=null();
{? var_pres('_b')=type_of(TOPER.ref())
|| _ref:=_b
?};

_result:=1;
_can_continue:=1;

TOPER.cntx_psh();
{? _ref<>null()
|| TOPER.prefix();
   {? TOPER.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _tab.prefix($TOPER.ref());
   {? _tab.size()=0
   ||
      _tab.blank();
      _tab.NR:=TOPER.NROP;
      _tab.REF:=$TOPER.ref();
      _tab.NAME:=TOPER.OPER().NA;
      _result:=_tab.add()
   ?}
?};
TOPER.cntx_pop();
_result


\opers_next
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Zwraca następniki podanej operacji
::   WE: [_a] - TOPER.ref lub bieżący rekord
::       [_b] - INTEGER - -1/[1] - czy zwracać następniki operacji (1), czy poprzedniki (-1)
::   WY: tab_tmp - tabelka zawierająca etapy początkowe w danym przepisie, pola: NR,REF,NAME,PX_SET,SET_DEF
::                 wynik działania exec('oper_tab','tech_oper')
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(TOPER.ref())
|| _ref:=_a
?};

_dir:=1;
{? var_pres('_b')=type_of(0)
|| _dir:=_b
?};

_result:=exec('oper_tab','tech_oper');
_can_continue:=1;

TOPER.cntx_psh();
{? _ref<>null()
|| TOPER.prefix();
   {? TOPER.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   NASTOPER.cntx_psh();
   {? _dir>0
   || NASTOPER.index('OPNAST')
   |? _dir<0
   || NASTOPER.index('NASTOP')
   ?};
   NASTOPER.prefix('T',TOPER.ref());
   {? NASTOPER.first()
   || {!
      |?
         _oper:=null();

         {? _dir>0
         || _oper:=NASTOPER.NRNAST
         |? _dir<0
         || _oper:=NASTOPER.OPER
         ?};

         {? _oper<>null()
         || exec('oper_add','tech_oper',_result,_oper)
         ?};
         NASTOPER.next()
      !}
   ?};
   NASTOPER.cntx_pop();
   ~~
?};
TOPER.cntx_pop();
_result


\opers_starting_ending
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Zwraca tabelkę zawierającą wszystkie operacje bez poprzedników (strartowe w danym przepisie)
::   WE: [_a] - TKTL.ref()   - karta technologiczna
::       [_b] - INTEGER - -1/[1] - czy zwracać początkowe operacje (1), czy końcowe (-1)
::   WY: tab_tmp - tabelka zawierająca etapy początkowe w danym przepisie, pola: NR,REF,NAME,PX_SET,SET_DEF
::                 wynik działania exec('oper_tab','tech_oper')
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(TKTL.ref())
|| _ref:=_a
?};

_dir:=1;
{? var_pres('_b')=type_of(0)
|| _dir:=_b
?};

_result:=exec('oper_tab','tech_oper');
_ndx_nr:=_result.ndx_tmp(,,'NR',,);

_can_continue:=1;

{? _can_continue>0
||
   TOPER.cntx_psh();
   TOPER.index('ANNN');
   TOPER.prefix('T','N',_ref);
   {? TOPER.first()
   || {!
      |?
         {? TOPER.PZ<>'Z'
         ||
            _has_next:=0;
            {? _dir>0
            || _has_next:=exec('has_oper_prev','tech_oper')
            |? _dir<0
            || _has_next:=exec('has_oper_next','tech_oper')
            ?};

            {? _has_next=0
            ||
::          Jeśli nie ma poprzedników to znak że startowy/końcowy
               exec('oper_add','tech_oper',_result)
            ?}
         ?};
         TOPER.next()
      !}
   ?};
   TOPER.cntx_pop();
   ~~
?};
_result.index(_ndx_nr);
_result.prefix();
_result


\walk_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Argumenty dla funkcji walk
::   WY: obj_new - tablica nazwana
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
::             Operacja startowa - TOPER.ref
               'START'
::             Czym prefisowac TOPER (TKTL.ref)
               ,'TKTL'
::             Kierunek w ktorym isc
               ,'DIR'
::             Formula ktora wykonac dla kazdego etapu - formula jako _a dostanie te tablice
               ,'FORMULA'
::             Tablica z refami odwiedzonych etapow
               ,'VISITED'
::             Czy jestem na poczatku sciezki
               ,'PATH_START'
::             Oczekiwany rezultat formuly - jesli inny niz oczekiwany to koncze chodzenie
               ,'EXPECTED'
::             Przebyta odleglosc
               ,'DISTANCE'
::             Argumenty dla formuły
               ,'ARGS'
::             Podwójna iteracja - najpierw dla samych moich następników, a następnie dla ich ścieżek
               ,'DOUBLE'
              );
_args.START:=null();
_args.TKTL:=null();
_args.DIR:=0;
_args.FORMULA:="";
_args.VISITED:=exec('ref_table','#table');
_args.PATH_START:=0;
_args.EXPECTED:=~~;
_args.DISTANCE:=0;
_args.ARGS:=~~;
_args.DOUBLE:=0;
_args


\walk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Przechodzi po kolejnych operacjach wg nastepstwa i wykonuje dla kazdego etapu formule
::       Kontekst pracy TOPER
::   WE: _a   - _args - argumenty dla funkcji, wynik dzialania exec('walk_a','px_stage')
::       [_b] - INTEGER - 0/[1] - czy mogę uruchamiać formułę
::       [_c] - INTEGER - 0/[1] - czy mogę uruchamiać rekurencję
::   WY: 0 - przerwano chodzenie bo formula zwrocila 0 lub wynik niezgodny z oczekiwaniem
::       1 - doszlo do konca sciezki
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_can_run:=1;
{? var_pres('_b')=type_of(0)
|| _can_run:=_b
?};
_can_rec:=1;
{? var_pres('_c')=type_of(0)
|| _can_rec:=_c
?};
TOPER.cntx_psh();

_can_continue:=1;
_result:=0;

{? _can_run>0
||
   {? _args.VISITED.r_find(TOPER.ref())=0
   ||
      _args.DISTANCE+=1;
::    Wykonuje przekazana formule
      _fml_res:=_args.FORMULA(_args);
      {? type_of(_args.EXPECTED)>0
      ||
         {? _args.EXPECTED=_fml_res
         || _can_continue:=1
         || _can_continue:=0
         ?}
      || {? _fml_res>0
         || _can_continue:=1
         || _can_continue:=0
         ?}
      ?}
   ?}
?};

{? _can_continue>0 & _can_rec>0
||
   _opers_next:=exec('opers_next','tech_oper',,_args.DIR);
   {? _args.DOUBLE=0
   ||
::    Bez podwójnej iteracji - uruchamiam formuły dla ścieżek następników
      {? _opers_next.first()
      || {!
         |? TOPER.prefix();
            {? TOPER.seek(_opers_next.REF)
            ||
               {? _args.VISITED.r_find(TOPER.ref())=0
               ||
::                !!! REKURENCJA !!!
                  _args.PATH_START:=0;
                  _can_continue:=exec('walk','tech_oper',_args);
                  _args.VISITED.add(TOPER.ref())
               ?}
            ?};
            _opers_next.next() & _can_continue>0
         !}
      ?}
   |? _args.DOUBLE=1
   ||
::    Podwójna iteracja - najpierw uruchamiam formuły dla następników
::    a następnie dla ich ścieżek

::    Pierwszy przebieg - tylko dla następników

      {? _opers_next.first()
      || {!
         |? TOPER.prefix();
            {? TOPER.seek(_opers_next.REF)
            ||
::             !!! REKURENCJA !!!
               _result:=exec('walk','tech_oper',_args,1,0)
            ?};
            _opers_next.next() & _can_continue>0
         !}
      ?};

::    Drugi przebieg - tylko dla ścieżek następników
      {? _opers_next.first()
      || {!
         |? TOPER.prefix();
            {? TOPER.seek(_opers_next.REF)
            ||
::             !!! REKURENCJA !!!
               {? _args.VISITED.r_find(TOPER.ref())=0
               || _result:=exec('walk','tech_oper',_args,0,1);
                  _args.VISITED.add(TOPER.ref())
               ?}
            ?};
            _opers_next.next() & _can_continue>0
         !}
      ?}
   ?}
?};
TOPER.cntx_pop();
TOPER.get();
{? _can_continue>0
|| _result:=1
?};
_result


\toper_bad_op_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Przed redakcja pola TOPER.BAD_OP
::   WE: [_a] - tabela, dla której uruchamiana: [TOPER]/TTOPER
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_tab:={? var_pres('_a')=type_of(TOPER) || _a || TOPER ?};
BADVAR.TYP_BAD:='O';
_result:=1;
{? _tab.PL_GRP='T'
|| _result:=0
?};

{? _result>0
||
:: ponieważ redagowanie jest dla jednego typu operacji, to w oknie BADSEH.RED blokujemy pola TYP, AKT oraz ATEST
   BADSEH.efld_opt('RED','editable=grayed',,'TYP');
   BADSEH.efld_opt('RED','editable=grayed',,'AKT');
   BADSEH.efld_opt('RED','editable=grayed',,'ATEST');
:: usuwam akcje aktywuj/dezaktywuj
   BADSEH.actions('WER','AE')
?};
_result


\toper_bad_op_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Po redakcji pola TOPER.BAD_OP
::   WE: [_a] - tabela, dla której uruchamiana: [TOPER]/TTOPER
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
::_tab:={? var_pres('_a')=type_of(TOPER) || _a || TOPER ?};
BADVAR.TYP_BAD:='M';
: przywracam stan zablokowanych pól
BADSEH.efld_opt('RED','editable=1',,'TYP');
BADSEH.efld_opt('RED','editable=1',,'AKT');
BADSEH.efld_opt('RED','editable=1',,'ATEST');
:: przywracam akcje
BADSEH.actions('WER','');
1


\toper_where_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Po redakcji pola TOPER.WHERE
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
{? TOPER.WHERE<>'W'
||
   _sur:=exec('FindAndGet','#table',TKTL,TOPER.NRK,,"TYP().SUR",'');
:: Dla technologii, w której surowce przypisywane są do operacji sprawdzam, czy operacja ma przypisane surowce,
:: do któych będzie generowane podzlecenie (na ten moment wszystkie karty obsługiwane jako OO)
   {? 1
::      _sur='O'
   || TMAT.cntx_psh();
      TMAT.index('ANNL');
      TMAT.prefix('T',TOPER.NRK,TOPER.ref());
      {? TMAT.first()
      || {!
         |?
            {? (TMAT.RKTL<>'' | TMAT.DFLT_KTL='T') & TMAT.MAG<>'T'
            || FUN.info('Do operacji są przypisane surowce, z których będą generowane podzlecenia.\n'
                        'Taka operacja musi znajdować się na wszystkich przewodnikach.'@);
               TOPER.WHERE:='W';
               _result:=0
            ?} ;
            _result=1 & TMAT.next()
         !}
      ?};
      TMAT.cntx_pop()
   ?}
?};
_result


\toper_modify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Popraw dla operacji technologicznej
::   WE: [_a] - miejsce wywołania: [0] - wewnątrz obiektu - struktrura drzewiasta
::                                  1  - okno wertowania ALL - lista wszystkich operacji technologicznych
::       [_b] - obiekt, wewnątrz którego uruchamiana jest formuła (_gdy _a=0)
::   WY: 0/1 - czy zaktualizowano rekord - wynik TOPER.put()
::----------------------------------------------------------------------------------------------------------------------
_where:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_obj:={? var_pres('_b')>100 & _where=0 || _b || ~~ ?};
{? VAR.GRP_MOD='' ||  VAR.GRP_MOD:='N' ?};
_p500369:=exec('get','#params',500369,type_of(''));
_res:=0;
{? TOPER.ACT='N'
|| _msg:='Element nieaktywny — nie można modyfikować.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
   || FUN.info(_msg)
   ?};
   ~~
|? params_exec('can_modify','tech_oper')=0
|| _msg:='Stan technologii lub operacji nie pozwala na modyfikację elementu.'@;
   {? VAR.GRUPA='T'
   || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
   || FUN.info(_msg)
   ?};
   _ok:=0
|? TKTL.STAT_O='N'
||
   _ok:={? VAR.ZM_ROPER='T'
        ||
::         Akcja Zmiana rodzaju operacji - ustalenie wartości pól dla TOPER
           exec('wew_change','tech_oper')
        || 1
        ?};
   _plnh_bef:=TOPER.PLNH;
   _cena_bef:=TOPER.CENA;
   _ref:={? _where=0 || _obj.TAB.REF || TOPER.ref() ?};
   VAR.A_WYD:={? TOPER.PFAZ<>null() || TOPER.PFAZ().WYD || TKTL.JORG ?};
   exec('toper_be','tech_oper');
   exec('efld_opt','tech_oper',TOPER);
   {? _ok>0 & TOPER.memo_get(,'OPISMEMO') & (VAR.GRP_MOD='T' | TOPER.edit("exec('topearec','tech_oper')"))
   || _ok:=1;
      {? VAR.GRP_MOD='T'
      || _ok:=exec('toper_modify_frombfr','tech_oper',__BUFF_GRP)
      ?};
      {? _ok>0 & TOPER.put()
      || _res:=1;
         TOPER.memo_put(,'OPISMEMO');
         exec('pfazred','tech_common');

         NASTOPER.cntx_psh();
         NASTOPER.index('NASTOP');
         NASTOPER.prefix('T',TOPER.ref());
         {? NASTOPER.first()
         || _sciezka:=exec('get_oper_nr','tech_oper',TOPER.UNROP);
            {!
            |? NASTOPER.SCIEZKA:=_sciezka;
               NASTOPER.put();
               NASTOPER.next()
            !}
         ?};
         NASTOPER.cntx_pop();

         {? TOPER.WEW='T' & _plnh_bef<>TOPER.PLNH
         || exec('warn_toper_plnh','tech_oper')
         ?};

         {? TOPER.WEW='N' & _cena_bef<>TOPER.CENA
         || exec('warn_toper_cena','tech_oper')
         ?};
::       Aktualizacja przepisu planistycznego technologii (jeżeli istnieje)
         {? _p500369='T' & TOPER.NRK<>null() & exec('get_tex_tktl','px_tex',$TOPER.NRK)
         || exec('tktl_tex_update','px_tex',TOPER.NRK,0,1,exec('get','#params',500367)='T',,1,1)
         ?};
         {? _where=0
         || _obj.TAB.cntx_psh();
            _obj.replica();
            _obj.load();
            _obj.update();
            _obj.TAB.clear();
            {? _obj.TAB.first()
            || {!
               |?
                 _obj.TAB1.blank();
                 _obj.TAB1.REF:=_obj.TAB.REF;
                 {? _obj.TAB1.find_rec()
                 || _obj.TAB.HIDDEN:=_obj.TAB1.HIDDEN;
                    _obj.TAB.EXPANDED:=_obj.TAB1.EXPANDED;
                    _obj.tab_txt();
                    _obj.TAB.put()
                 ?};
                 _obj.TAB.next()
                !}
            ?};
            _obj.TAB.cntx_pop();
            _obj.TAB.blank();
            _obj.TAB.REF:=_ref;
            _obj.TAB.find_rec()
         ?}
      ?}
   ?};
   ~~
||
   TOPER.hdr_edit(' — '+'MODYFIKACJA ZATWIERDZONEJ KARTY'@);
   VAR.KOR:=1;
   _plnh_bef:=TOPER.PLNH;
   _cena_bef:=TOPER.CENA;
   _ok:={? VAR.ZM_ROPER='T'
        ||
::         Akcja Zmiana rodzaju operacji - ustalenie wartości pól dla TOPER
           exec('wew_change','tech_oper')
        || 1
        ?};
   VAR.A_WYD:={? TOPER.PFAZ<>null() || TOPER.PFAZ().WYD || TKTL.JORG ?};
   exec('toper_be','tech_oper');
   _ref:={? _where=0 || _obj.TAB.REF || TOPER.ref() ?};
   {? VAR.GRP_MOD<>'T'
   || _buffer:=exec('buffer','tech_oper');
      _buffer.get();
      TOPER.OD:=date();
      TOPER.USER:=OPERATOR.USER;
      TOPER.CAUSE:=exec('ttxcause_default','tech_common');
      TOPER.MOD_TIME:=TOPER.tm_stamp();
      _POLA:=exec('pola_tpz','tech_oper');
      exec('ust_pola_tpz','tech_oper',_POLA);
      params_set('buffer',_buffer,'POLA',_POLA)
   ?};
   exec('efld_opt','tech_oper',TOPER);
   {? _ok>0 & TOPER.memo_get(,'OPISMEMO') & (VAR.GRP_MOD='T' |
      TOPER.edit("
         _buffer:=exec('buffer','tech_oper');
         _buffer.get();
         {? exec('compare','#table',_buffer,params_get().buffer,1,'OD','USER','CAUSE','MOD_TIME')
            & exec('comp_tpz','tech_oper',params_get().POLA)
         || FUN.info('Nic nie zostało zmienione.\nNie można zatwierdzić zmian.'@);
            0
         || exec('topearec','tech_oper')
         ?}
      "))
   || _ok:=1;
      {? VAR.GRP_MOD='T'
      || _ok:=exec('toper_modify_frombfr','tech_oper',__BUFF_GRP)
      ?};
      {? _ok>0
      || {? TOPER.put()
         || _res:=1;
            TOPER.memo_put(,'OPISMEMO');
            exec('pfazred','tech_common');

            NASTOPER.cntx_psh();
            NASTOPER.index('NASTOP');
            NASTOPER.prefix('T',TOPER.ref());
            {? NASTOPER.first()
            || _sciezka:=exec('get_oper_nr','tech_oper',TOPER.UNROP);
               {!
               |? NASTOPER.SCIEZKA:=_sciezka;
                  NASTOPER.put();
                  NASTOPER.next()
               !}
            ?};
            NASTOPER.cntx_pop()
         ?};

         {? TOPER.WEW='T' & _plnh_bef<>TOPER.PLNH
         || exec('warn_toper_plnh','tech_oper')
         ?};

         {? TOPER.WEW='N' & _cena_bef<>TOPER.CENA
         || exec('warn_toper_cena','tech_oper')
         ?};
::       Aktualizacja przepisu planistycznego technologii (jeżeli istnieje)
         {? _p500369='T' & TOPER.NRK<>null() & exec('get_tex_tktl','px_tex',$TOPER.NRK)
         || exec('tktl_tex_update','px_tex',TOPER.NRK,0,1,exec('get','#params',500367)='T',,1,1)
         ?};
         {? _where=0
         || _obj.TAB.cntx_psh();
            _obj.replica();
            _obj.load();
            _obj.update();
            _obj.TAB.clear();
            {? _obj.TAB.first()
            || {!
               |?
                  _obj.TAB1.blank();
                  _obj.TAB1.REF:=_obj.TAB.REF;
                  {? _obj.TAB1.find_rec()
                  || _obj.TAB.HIDDEN:=_obj.TAB1.HIDDEN;
                     _obj.TAB.EXPANDED:=_obj.TAB1.EXPANDED;
                     _obj.tab_txt();
                     _obj.TAB.put()
                  ?};
                  _obj.TAB.next()
               !}
            ?};
            _obj.TAB.cntx_pop();
            _obj.TAB.blank();
            _obj.TAB.REF:=_ref;
            _obj.TAB.find_rec()
         ?}
      ?}
   ?};
   TOPER.hdr_edit();
   VAR.KOR:=0;
   ~~
?};
_res


\set_filter
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Ustawia filtr programowy dla okna ALL tabeli TOPER (wszystkie operacje aktywnych technologii)
::   WY: ~~
::----------------------------------------------------------------------------------------------------------------------
_exit:="
   exec('err_psql','#sql');
   exec('empty_f_set','#table',TOPER)
";
:: Zdjęcie filtru użytkownika
TKTL.f_clear(2);
TKTLW.f_clear(2);
:: Ustawienie filtru na technologie
{? ZAKR.TKTL_A='W'
||
:: Aktywne i nieaktywne
   exec('set_afilter','tech_head')
|? ZAKR.TKTL_A='N'
||
:: Nieaktywne
   exec('set_nfilter','tech_head')
||
:: Aktywne (bieżące)
   exec('set_filter','tech_head')
?};
TOPER.clear();
TOPER.index('TKTL');
TOPER.f_clear(1);
_sort:='';
_from:='';
_where:='TOPER.NRK in (select T1.REFERENCE as REF from TKTL T1 join filter_of(TKTL) T2) and TOPER.TPZ=\'N\'';

{? ~TOPER.f_set(_sort,_from,_where)
|| _exit()
?};
~~


\toper_all_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Operacje inicjujące dla okna ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_formikon:="
   {? TOPER.WEW='N'
   || 'xwin16.png:90'
   |? TOPER.PZ='Z'
   || 'xwin16.png:32'
   |? TOPER.PZ='P'
   || {? TOPER.KJ_BAD='B'
      || 'xwin16.png:93'
      |? TOPER.KJ_BAD='P'
      || 'xwin16.png:94'
      |? TOPER.KONTROLA='T'
      || 'xwin16.png:95'
      || 'xwin16.png:33'
      ?}
   || ''
   ?}
";
TOPER.win_fml('ALL',TOPER,'NAZWA',,'ICON_BEFORE',_formikon,1);
_formikon:="
   {? TOPER.DOK<>null()
   || 'xwin16.png:190'
   || exec('pusta','#icon')
   ?}
";
TOPER.win_fml('ALL',TOPER,'NTIME',,'ICON_BEFORE',_formikon,1);
~~


\toper_all_zam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Zamienniki w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_locked:=exec('toper_all_start','tech_oper');
_env_oper:=exec('env_oper','tech_oper');
_env_oper.used:=~_locked;
params_set('env_oper',_env_oper);
exec('tech_zam','tech_oper');
{? _locked || exec('toper_all_stop','tech_oper') ?}


\toper_all_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Surowce w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_locked:=exec('toper_all_start','tech_oper');
_env_oper:=exec('env_oper','tech_oper');
_env_oper.used:=~_locked;
params_set('env_oper',_env_oper);
exec('action_oper','tech_mater',_env_oper.used,_env_oper.zakl);
{? _locked || exec('toper_all_stop','tech_oper') ?}


\toper_all_npu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja N-P-U w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_locked:=exec('toper_all_start','tech_oper');
_env_oper:=exec('env_oper','tech_oper');
_env_oper.used:=~_locked;
params_set('env_oper',_env_oper);
exec('action_tools','tech_tool',0,'',_env_oper.used);
{? _locked || exec('toper_all_stop','tech_oper') ?}


\toper_all_atr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Atrybuty operacji w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_locked:=exec('toper_all_start','tech_oper');
_env_oper:=exec('env_oper','tech_oper');
_env_oper.used:=~_locked;
params_set('env_oper',_env_oper);
exec('TOPER','tech_atr');
{? _locked || exec('toper_all_stop','tech_oper') ?}


\toper_all_dok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Dokumentacja w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_locked:=exec('toper_all_start','tech_oper');
_env_oper:=exec('env_oper','tech_oper');
_env_oper.used:=~_locked;
params_set('env_oper',_env_oper);
exec('TOPER','tech_doc');
{? _locked || exec('toper_all_stop','tech_oper') ?}


\toper_all_zm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Zmiany w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
exec('zmiany','#syslog',TOPER)


\toper_all_zmt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Zmiany Tpz w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
TOPER.cntx_psh();
TOPER.index('TPZ');
TOPER.prefix('T',TOPER.UNROP);
{? TOPER.first()
|| exec('zmiany','#syslog',TOPER)
|| FUN.info('Brak operacji Tpz.'@)
?};
TOPER.cntx_pop()


\toper_all_leg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Legenda w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','tech_oper')


\toper_all_disp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Wyświetl w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
exec('prep_ch','tech_oper');
exec('efld_opt','tech_oper',TOPER);
TOPER.display();
~~


\toper_all_mod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Popraw w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_locked:=exec('toper_all_start','tech_oper');
{? _locked
|| exec('toper_modify','tech_oper',1);
   exec('toper_all_stop','tech_oper')
?}


\toper_all_rec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Rekord w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
VAR.A_KTL:=TOPER.NRK;
VAR.SCIEZKA:=exec('get_oper_nr','tech_oper',TOPER.UNROP);
{? _a
|| TOPER.NRK();
   exec('s_tktl','tech_head');
   _locked:=exec('tktl_lock','tech_common',,'O');
   _used:=~_locked;
   VAR.A_OP:=TOPER.ref();
::   VAR.A_KTL();
:: Akcje dla "TOPER" - wyszarzone w zależności od rekordu
   _keys:=':';
   {? exec('can_modify','tech_oper',_used)=0
   || _keys:={? TOPER.sel_size()>0 || '' || 'PR:' ?}
   || _keys:=':'
   ?};
   {? TKTL.TYP().UTIL='N' || _keys:='N'+_keys ?};
   {? TOPER.ACT<>'T' || {? TOPER.sel_size()>0 || _keys:=''+_keys || _keys:='PR'+_keys ?} ?};
   {? TOPER.PZ='Z' || _keys:='ZCNR'+_keys ?};
   {? TOPER.WEW='N' || _keys:='ZN'+_keys ?};
   TOPER.actions_grayed('ALL',_keys);
   {? _locked || exec('tktl_unlock','tech_common',,'O') ?}
?};
_res:=Color.rekprzed('TOPER#01#01');
_res


\toper_all_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Formuła inicjująca dla akcji zawartych w oknie ALL tabeli TOPER (wszystkie operacje technologiczne) -
::       Blokowanie rekordów, inicjajca obiektu tpar
::   WY: 0/1 - czy udało się zablokować rekord
::----------------------------------------------------------------------------------------------------------------------
_locked:=0;
{? TKTL.ref()<>null()
|| _locked:=exec('tktl_lock','tech_common',,'O');
   exec('start_tpar','tech_param',TKTL.KTM)
?};
_used:=~_locked;
_locked


\toper_all_stop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Formuła czyszcząca dla akcji zawartych w oknie ALL tabeli TOPER (wszystkie operacje technologiczne) -
::       Oblokowanie rekordów, zwolnienie obiektu tpar
::----------------------------------------------------------------------------------------------------------------------
exec('tktl_unlock','tech_common',,'O');
exec('stop_tpar','tech_param')


\toper_all_zakr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Zmień Zakres w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_win_red:=exec('zakr_win','tech_common');
ZAKR.win_edit(_win_red);
{? ZAKR.TKTL_A='' || ZAKR.TKTL_A:='A' ?};
{? ZAKR.edit()
|| exec('zakr_set','tech_common');
   exec('set_filter','tech_oper')
?};
~~


\nastepniki
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Wyświetla następniki/poprzedniki dla operacji technologicznej
::       Działa na aktualnych buforach tabel TOPER i TKTL.
::----------------------------------------------------------------------------------------------------------------------
_used:=params_get().env_oper.used;
_torw:=TKTL.TORW;

_grpbefore:="
      grp_disp(NASTOPER,'SLOPOP');
      grp_disp(NASTOPER,'WER_T');
      ~~
   ";
_grp:=NASTOPER.grp_make('Następstwo operacji: %1'@[VAR.SCIEZKA+'. '+TOPER.NAZWA],_grpbefore,'#toper_nast',,,,,'normal');
_ar:="";
_fb:="
   NASTOPER.index('NASTOP');
   NASTOPER.prefix('T',VAR.A_OP);
   NASTOPER.first();
   ~~
";
_fa:="
   ~~
";
NASTOPER.grp_sel(_grp,,'SLOPOP',,_ar,,,10,_fb,_fa,,,'maximized_with_title');
NASTOPER.grp_splt(_grp,,'horizontal','bottom');
_ar:="";
_fb:="
   NASTOPER.index('OPNAST');
   NASTOPER.prefix('T',VAR.A_OP);
   NASTOPER.first();
   ~~
";
_fa:="
   ~~
";
_wer:='WER_'+_torw;
NASTOPER.grp_sel(_grp,,_wer,,_ar,,,10,_fb,_fa,,,'maximized_with_title');
NASTOPER.win_sel(_grp);
:: Wyszarzanie akcji dla NASTOPER
_keys:='G:G'; _default:='D:D';
{? TKTL.ARCH='T'
      |
   _used
      |
   _torw='Z' & TKTL.PLRELWYR<>null()
      |
   _torw='T' & VAR.A_ZLEC<>null()
      |
   TKTL.STAN='T' & _torw='T' & ~exec('can_modify','tech_common') & TOPER.ACT='T'
      |
   TKTL.STAN='T' & _torw='W'
      |
   TKTL.STAN='T' & _torw='Z'
|| _keys:='DPUG'+_keys+'DG'
?};
{? TOPER.PZ='Z' || _keys:='D'+_keys+'D' ?};
NASTOPER.actions(_wer,_keys,_default,1);

NASTOPER.select();
~~


\toper_all_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Następniki w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_locked:=exec('toper_all_start','tech_oper');
_env_oper:=exec('env_oper','tech_oper');
_env_oper.used:=~_locked;
params_set('env_oper',_env_oper);
exec('nastepniki','tech_oper');
{? _locked || exec('toper_all_stop','tech_oper') ?}


\TOPER_trigger
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Triggery dla tabeli TOPER
::----------------------------------------------------------------------------------------------------------------------
:: Aktualizacja pola NAZWA (nazwa operacji)
TOPER.NAZWA:=exec('toper_nazwa','tech_oper');
1


\toper_trig_add_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Trigger przed add dla tabeli TOPER
::----------------------------------------------------------------------------------------------------------------------
exec('TOPER_trigger','tech_oper')


\toper_trig_put_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Trigger przed put dla tabeli TOPER
::----------------------------------------------------------------------------------------------------------------------
exec('TOPER_trigger','tech_oper')


\toper_nazwa
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Ustala i zwraca nazwę operacji technologicznej. Działa na aktualnym buforze tabeli TOPER.
::   WY: Nazwa operacji
::----------------------------------------------------------------------------------------------------------------------
TTOPER.cntx_psh();
TTOUT.cntx_psh();
_nazwa:=
   {? TOPER.PZ='P' & TOPER.WEW='T'
   || TOPER.OPER().NA
   |? TOPER.PZ='Z' & TOPER.WEW='T'
   || TOPER.NA
   |? TOPER.PZ='P' & TOPER.WEW='N'
   || TOPER.TTOUT().NA
   || ''
   ?};
TTOPER.cntx_pop();
TTOUT.cntx_pop();
_nazwa


\ttoper_bad_op_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Przed redakcja pola TTOPER.BAD_OP
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
exec('toper_bad_op_be','tech_oper',TTOPER)


\ttoper_bad_op_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Po redakcji pola TTOPER.BAD_OP
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
exec('toper_bad_op_ae','tech_oper',TTOPER)


\toper_sel_rec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Akcja Rekord w oknie SEL tabeli TOPER (wybór operacji technologicznej)
::----------------------------------------------------------------------------------------------------------------------
::VAR.A_KTL:=TOPER.NRK;
VAR.SCIEZKA:=exec('get_oper_nr','tech_oper',TOPER.UNROP);
_res:=Color.rekprzed('TOPER#01#01');
_res


\toper_sel_leg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Akcja Legenda w oknie SEL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','tech_oper')


\toper_sel_disp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Akcja Wyświetl w oknie SEL tabeli TOPER (wybór operacji technologicznej)
::----------------------------------------------------------------------------------------------------------------------
exec('prep_ch','tech_oper');
exec('efld_opt','tech_oper',TOPER);
TOPER.display();
~~


\toper_modify_gpr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Grupa przed dla akcji Popraw w oknach wertowania dla operacji technologicznych
::   WE: [_a] - miejsce uruchomienia: 1 - okno wszystkich surowców (okno ALL), [0] - okno surowców (obiekt Objt)
::----------------------------------------------------------------------------------------------------------------------
_where:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_continue:=1;
TOPER.cntx_psh();
_tab:={? _where=0 || Objt.TAB || TOPER ?};
{? _tab.sel_size()>1
|| _continue:=FUN.ask('Ilość zaznaczonych operacji: %1. Czy poprawić wybrane operacje technologiczne?'@
      [form(_tab.sel_size())]);
   {? _continue>0
   ||
      TOPER.seek(null(),,,1);
      TOPER.blank(1);
      VAR.GRP_MOD:='P';
::    Sprawdzenie typu operacji oraz czy są zaznaczone zatwierdzone operacje
      _tab_sel:=_tab.sel_aget();
      _kor:=0;
      _pz:='';
      _wew:='';
      {? _tab_sel.first()
      || TOPER.cntx_psh();
         TKTL.cntx_psh();
         TOPER.prefix();
         {!
         |?
            _ref:={? _where=0 || exec('FindAndGet','#table',Objt.TAB,_tab_sel.REF,,"REF",null()) || _tab_sel.REF ?};
            {? TOPER.seek(_ref)
            ||
::             Sprawdzenie zgodności typów operacji
               {? _pz='' | _wew=''
               || _pz:=TOPER.PZ;
                  _wew:=TOPER.WEW;
                  {? _pz='Z'
                  || _continue:=0;
                     FUN.emsg('Nie można grupowo poprawiać operacji złożonych.'@)
                  ?}
               ?};
               {? _pz<>TOPER.PZ | _wew<>TOPER.WEW
               || _continue:=0;
                  FUN.emsg('Nie można grupowo poprawiać operacji różnych typów (wewnętrznych, zewnętrznych).'@)
               ||
::                Sprawdzenie, czy modyfikowana zatwierdzona operacja
                  {? _kor=0 & TOPER.NRK().STAT_O='T'
                  || _kor:=1
                  ?}
               ?}
            ?};
            _continue>0 & _tab_sel.next()
         !};
         TOPER.cntx_pop();
         TKTL.cntx_pop()
      ?};
      TOPER.GRPOJ:='S';
      TOPER.PZ:=_pz;
      TOPER.WEW:=_wew;
      _kor_bf:=VAR.KOR;
      VAR.KOR:=_kor;
      {? _continue>0
      || _buffer:=exec('buffer','tech_oper');
         _buffer.get();
         params_set('buffer',_buffer);
         {? TOPER.WEW='T'
         || TOPER.win_edit('GRP_WEW')
         || TOPER.win_edit('GRP_ZEW')
         ?};
         _valid:="
            _res:=1;
            params_set(params_get());
            _buffer:=exec('buffer','tech_oper');
            _buffer.get();
            {? exec('compare','#table',_buffer,params_get().buffer,0
                  ,'OPER','PFAZ','PLACE','GRUPA','TWRKPLG','KONTROLA','BRYG','PL_GRP','DOK','TTOUT','KONTRAH','SRW'
                  ,'PX_KONT','DAYS_K','FAST_WYK','NO_START'
               )
            || FUN.info('Przynajmniej jedno z pól musi zostać określone.'@);
               _res:=0
            ?};
            {? _res>0
            || _res:=exec('topearec','tech_oper')
            ?};
            _res
         ";
         exec('efld_opt','tech_oper',TOPER);
         _continue:=TOPER.edit(_valid);
         {? _continue>0
         || _buffer_grp:=exec('buffer','tech_oper');
            _buffer_grp.get();
            {? var_pres('__BUFF_GRP')>100
            || VAR_DEL.delete('__BUFF_GRP')
            ?};
            __BUFF_GRP:=_buffer_grp;
            sel_nchk();
            KOMM.init(255,,'Grupowa modyfikacja operacji technologicznych'@);
            VAR.GRP_MOD:='T';
            VAR.GRUPA:='T'
         || VAR.GRP_MOD:='N';
            VAR.GRUPA:='N';
            {? var_pres('__BUFF_GRP')>100
            || VAR_DEL.delete('__BUFF_GRP')
            ?}
         ?}
      ?};
      VAR.KOR:=_kor_bf
   ?}
?};
TOPER.cntx_pop();
_continue


\toper_modify_gpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Grupa po dla akcji Popraw w oknach wertowania dla operacji technologicznych
::----------------------------------------------------------------------------------------------------------------------
{? VAR.GRP_MOD='T'
|| VAR.GRUPA:='N';
   VAR.GRP_MOD:='N';
   {? var_pres('__BUFF_GRP')>100
   || VAR_DEL.delete('__BUFF_GRP')
   ?};
   KOMM.select()
?};
~~


\toper_all_mod_gpr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Grupa przed dla akcji Popraw w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
::_env_oper:=exec('env_oper','tech_oper');
::params_set('env_oper',_env_oper);
exec('toper_modify_gpr','tech_oper',1)


\toper_all_mod_gpo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Grupa po dla akcji Popraw w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
params_exec('toper_modify_gpo','tech_oper')


\grp_mod_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Zwraca informacje o technologii, operacji którego będzie dotyczył komunikat błędu.
::       Działa na aktualnym buforze tabeli TOPER
::   WE: [_a] - INTEGER - dodać informację o operacji: [1] - tak, 0 -nie
::   WY: STRING z informacją o technologii, operacji
::----------------------------------------------------------------------------------------------------------------------
_grp_msg:='';
_oper:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_nrk:=exec('FindAndGet','#table',TKTL,TOPER.NRK,,"NRK+' (wer.'+WER+')'",'');
_grp_msg:=
   'Technologia %1'@[_nrk]+
   {? _oper>0
   || ', operacja: %1'@[exec('get_oper_nr','tech_oper',TOPER.UNROP)]
   || ''
   ?}
   +' - ';
_grp_msg


\toper_modify_frombfr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Modyfikuje aktualny bufor tabeli TOPER na podstawie innego bufora (podczas grupowej modyfikacji danych)
::   WE: _a - bufor tabeli TOPER
::   WY: 0 - wystąpił błędy, rekord nie zostanie zmodfikowany / 1 - ok
::----------------------------------------------------------------------------------------------------------------------
_ok:=1;
_buffer_grp:={? var_pres('_a')>100 || _a || return(0) ?};

{? TOPER.PZ='P' & TOPER.WEW='T'
||
:: Operacja wewnętrzna
   {? _buffer_grp.OPER<>null() & TOPER.OPER<>_buffer_grp.OPER
   || TOPER.OPER:=_buffer_grp.OPER;
      exec('ae_ttoper','tech_oper',1)
   ?};
:: Stanowisko/gniazdo
   {? (_buffer_grp.GRPOJ='G' & _buffer_grp.GRUPA<>null()  & _buffer_grp.TWRKPLG<>null())
      | (_buffer_grp.GRPOJ='S' & _buffer_grp.PLACE<>null())
   || TOPER.GRPOJ:=_buffer_grp.GRPOJ;
      TOPER.GRUPA:=null();
      TOPER.TWRKPLG:=null();
      TOPER.PLACE:=null();
      {? TOPER.GRPOJ='G'
      || TOPER.GRUPA:=_buffer_grp.GRUPA;
         TOPER.TWRKPLG:=_buffer_grp.TWRKPLG;
         exec('ae_twzpo','tech_oper',TOPER)
      || TOPER.PLACE:=_buffer_grp.PLACE;
         exec('ae_twrkplc','tech_oper',TOPER)
      ?}
   ?};
:: Parametry
   {? _ok>0
   ||
::    Brygada
      {? _buffer_grp.BRYG<>'' & TOPER.BRYG<>_buffer_grp.BRYG
      || TOPER.BRYG:=_buffer_grp.BRYG
      ?};
::    Kontrola jakości
      {? _buffer_grp.KONTROLA<>'' & TOPER.KONTROLA<>_buffer_grp.KONTROLA
      || TOPER.KONTROLA:=_buffer_grp.KONTROLA
      ?};
::    Grupowe planowanie
      {? _buffer_grp.PL_GRP<>'' & TOPER.PL_GRP<>_buffer_grp.PL_GRP
      || TOPER.PL_GRP:=_buffer_grp.PL_GRP;
         _ok:=exec('plgrp_ae','tech_oper')
      ?}
   ?}
|? TOPER.PZ='P' & TOPER.WEW='N'
||
:: Operacja zewwnętrzna
   {? _buffer_grp.TTOUT<>null() & TOPER.TTOUT<>_buffer_grp.TTOUT
   || TOPER.TTOUT:=_buffer_grp.TTOUT;
      exec('ttout_ae','tech_oper',1)
   ?};
:: Kontrahent
   {? _buffer_grp.KONTRAH<>null() & TOPER.KONTRAH<>_buffer_grp.KONTRAH
   || TOPER.KONTRAH:=_buffer_grp.KONTRAH
   ?};
:: Sposób rejestracji
   {? _buffer_grp.SRW<>'' & TOPER.SRW<>_buffer_grp.SRW
   || TOPER.SRW:=_buffer_grp.SRW
   ?};
:: Dane do planowania
   {? _buffer_grp.DAYS_K<>0 & TOPER.DAYS_K<>_buffer_grp.DAYS_K
   || TOPER.DAYS_K:=_buffer_grp.DAYS_K
   ?};
   {? _buffer_grp.PX_KONT<>null() & TOPER.PX_KONT<>_buffer_grp.PX_KONT
   || TOPER.PX_KONT:=_buffer_grp.PX_KONT;
      _ok:=exec('kooperacyjny','px_kont',TOPER.PX_KONT)
   ?}
?};

{? _ok>0
||
:: Typ dokumentu
   {? _buffer_grp.DOK<>null() & _buffer_grp.DOK<>TOPER.DOK
   || TOPER.DOK:=_buffer_grp.DOK
   ?};
:: Faza produkcji
   {? _buffer_grp.PFAZ<>null() & _buffer_grp.PFAZ<>TOPER.PFAZ
   || {? TOPER.NRNOP<>0
      || _ok:=0;
         _msg:='Nie można modyfikować fazy produkcji operacji podrzędnej.'@;
         {? VAR.GRUPA='T'
         || KOMM.add(exec('grp_mod_msg','tech_oper')+_msg)
         || FUN.emsg(_msg)
         ?}
      || TOPER.PFAZ:=_buffer_grp.PFAZ;
         _ok:=exec('toper_po_pfaz','tech_oper')
      ?}
   ?}
?};

:: Dla zatwierdzonych operacji przypisanie przyczyny zmiany
_tktl_stan:=exec('FindAndGet','#table',TKTL,TOPER.NRK,,"TKTL.STAT_O",'');
{? _ok>0 & _tktl_stan='T'
|| TOPER.OD:=date();
   TOPER.USER:=OPERATOR.USER;
   TOPER.CAUSE:=_buffer_grp.CAUSE;
   TOPER.MOD_TIME:=TOPER.tm_stamp()
?};
{? _ok>0
||
:: Końcowa walidacja TOPERA
   _res:=exec('topearec','tech_oper');
   {? (type_of(_res)=type_of(0) & _res=0) | (type_of(_res)=type_of('') & _res<>'')
   || _ok:=0
   ?}
?};
_ok


\can_modify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Sprawdza, czy operacja może być modyfikowana.
::       Działa na aktualnym buforze tabeli TOPER oraz TKTL
::   WE: [_a] - czy element wykorzystywany przez innego użytkownika: [0] - nie, 1 - tak
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
_used:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_act:=(TOPER.ACT='T');
_arc:=(TKTL.ARCH='T');
{? (_used | _arc | ~_act | TKTL.STAN='N' & TKTL.TORW<>'Z' | TKTL.STAN='P' & TKTL.STAT_O='T')
   | (TKTL.STAN='T' & (TKTL.TORW='W' | TKTL.TORW='Z' | ~exec('can_modify','tech_common')))
|| _res:=0
?};
_res


\toper_wew_change
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Zmienia rodzaj operacji - wewnętrzna/zewnętrzna (zmiana znacznika TOPER.WEW).
::       Działa na aktualnym rekordzie tabeli TOPER (lub obiektu)
::   WE: [_a] - miejsce wywołania: [0] - wewnątrz obiektu - struktrura drzewiasta
::                                  1  - okno wertowania ALL - lista wszystkich operacji technologicznych
::       [_b] - obiekt, wewnątrz którego uruchamiana jest formuła (_gdy _a=0)
::   WY: Czy zmieniono rodzaj operacji: 1 - tak, 0 - nie
::----------------------------------------------------------------------------------------------------------------------
_where:={? var_pres('_a')=type_of(0) || _a || 0 ?};
_obj:={? var_pres('_b')>100 & _where=0 || _b || ~~ ?};
_toper:={? _where=0 || _obj.TAB.REF || TOPER.ref() ?};
_res:=0;
{? _toper<>null()
|| TOPER.cntx_psh();
   TOPER.prefix();
   {? TOPER.seek(_toper)
   || _ok:=1;
      {? TOPER.PZ='Z'
      || _ok:=0;
         FUN.info('Akcja niedostępna dla operacji złożonych.'@)
      ?};
      {? _ok>0
      || _tpzref:=null();
         _unrop:=0;
         _px_stage:=TOPER.PX_STAGE;
::       Ustalenie refa TPZ
         {? TOPER.WEW='T'
         || TOPER.cntx_psh();
            TOPER.index('TPZ');
            TOPER.prefix('T',TOPER.UNROP);
            {? TOPER.first()
            || _tpzref:=TOPER.ref();
               _unrop:=TOPER.TPZREF
            ?};
            TOPER.cntx_pop()
         ?};
         VAR.ZM_ROPER:='T';
::       Wywołanie formuły na Popraw dla TOPER
         {? exec('toper_modify','tech_oper',_where,_obj)
         || _res:=1;
::          Jeżeli wcześniej była przypisana operacja TPZ, a zmieniono na kooperację, to usuwam TPZ
            {? _tpzref<>null() & TOPER.WEW='N'
            || TOPER.cntx_psh();
               TOPER.prefix();
               {? TOPER.seek(_tpzref)
               || TOPER.del()
               ?};
               TOPER.cntx_pop()
            ?}
         ?};
         VAR.ZM_ROPER:=''
      ?}
   ?};
   TOPER.cntx_pop()
?};
_res


\wew_change
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Ustalenie (wyczyszczenie) wartości dla TOPER, podczas zmiany rodzaju operacji
::       Działa na aktualnym rekordzie tabeli TOPER
::   WY: 0/1 - wynik FUN.ask, czy zmieniać rodzaj operacji
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_wew:=TOPER.WEW;
_txt_wew:='wewnętrzna'@;
_txt_zew:='zewnętrzna (kooperacja)'@;
_msg:='Aktualny rodzaj operacji: %1.\n\nCzy zmienić rodzaj operacji na: %2?'@
   [{? _wew='T' || _txt_wew || _txt_zew ?},{? _wew<>'T' || _txt_wew || _txt_zew ?}];
_p500369:=exec('get','#params',500369,type_of(''));
{? TOPER.PX_STAGE<>null() & _p500369='T'
|| _msg+='\n\nUwaga. Po modyfikacji operacji zostanie zaktualizowany przepis planistyczny technologii.'@
?};
{? FUN.ask(_msg)
|| _res:=1;
   _buffer:=exec('buffer','tech_oper');
   _buffer.get();
   {? _wew='T'
   || VAR.A_WEW:='N'
   || VAR.A_WEW:='T'
   ?};
::  Wyczyszczenie wartości pól
   TOPER.blank();
:: Przywrócenie wartości pól, które pozostają po zmianie rodzaju operacji
   TOPER.IDADD:=_buffer.IDADD;
   TOPER.NRK:=_buffer.NRK;
   TOPER.NROP:=_buffer.NROP; TOPER.UNROP:=_buffer.UNROP; TOPER.NRNOP:=_buffer.NRNOP;
   TOPER.COEF:=_buffer.COEF; TOPER.FCOEF:=_buffer.FCOEF;
   TOPER.EXIST:=_buffer.EXIST;
   TOPER.PFAZ:=_buffer.PFAZ;
   TOPER.OPIS:=_buffer.OPIS;
   TOPER.DOK:=_buffer.DOK;
   TOPER.ACT:=_buffer.ACT;
   TOPER.CRE_TIME:=_buffer.CRE_TIME; TOPER.MOD_TIME:=_buffer.MOD_TIME;
   TOPER.OD:=_buffer.OD; TOPER.USER:=_buffer.USER; TOPER.CAUSE:=_buffer.CAUSE;
   TOPER.WHERE:=_buffer.WHERE;
   TOPER.TKTL_KTM:=_buffer.TKTL_KTM;
   TOPER.PZ:=_buffer.PZ;
:: Uruchomienie akcji na rekord przed - ustawienie zmiennych i okienek
   exec('toperbre','tech_oper')
?};
_res


\toper_all_wew_change
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Akcja Zmiana rodzaju operacji w oknie ALL tabeli TOPER (wszystkie operacje technologiczne)
::----------------------------------------------------------------------------------------------------------------------
_locked:=exec('toper_all_start','tech_oper');
{? _locked
|| exec('toper_wew_change','tech_oper',1);
   exec('toper_all_stop','tech_oper')
?}


\nastoper_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Obsługa 'Dołącz' w oknie NASTOPER
::----------------------------------------------------------------------------------------------------------------------
{? exec('be_nastop','tech_oper')
|| NASTOPER.win_edit('RED');
   NASTOPER.blank();
   {? NASTOPER.edit()
   || {? NASTOPER.add()
      || exec('po_nast','tech_oper');
         params_exec('tree_refresh','tech_oper')
      ?}
   ?}
?};
1


\nastoper_modify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Obsługa 'Popraw' w oknie NASTOPER
::----------------------------------------------------------------------------------------------------------------------
NASTOPER.win_edit('RED');
{? NASTOPER.edit()
|| {? NASTOPER.put()
   || exec('po_nast','tech_oper');
      params_exec('tree_refresh','tech_oper')
   ?}
?};
1


\nastoper_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Obsługa 'Usuń' w oknie NASTOPER
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Czy usunąć bieżący następnik?'@)
|| NASTOPER.del();
   exec('po_nast','tech_oper');
   params_exec('tree_refresh','tech_oper')
?};
1


\tree_refresh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Odświeża zapis operacji w drzewie po zmianach w następnikach
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_obj:=params_get().env_oper.obj;
_obj.TAB.NAST:=exec('get_nast_nums','tech_oper',VAR.A_OP);
_obj.TAB.put();
grp_disp(_obj.TAB,_obj.WERT);
~~


\ttoper_zmien_kolor
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Akcja Zmien kolor w TTOPER
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_q:=exec('edit_color','#edit',TTOPER.KOLOR);
{? _q<>''
|| TTOPER.KOLOR:=_q;
   TTOPER.put()
?};
~~


\ttoper_kolor_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Przed wyswietl pola tabeli TTOPER.KOLOR
::   WY: String koloru
::----------------------------------------------------------------------------------------------------------------------
_wyn:=TTOPER.KOLOR+','+TTOPER.KOLOR;
_wyn


:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:37 7a931da05c20b2f6c82be7ce812220c07899695b746f7aa9b0004637b783e318592bdcdd00505f574873d6c5a5740af1e74c14f71a34a14e550215400ab64cc9e1fc5c9a272af9c1de0642d97db8f9a97f43e0d5d3c9bd817c9789dca7b5a72a8c7f1dfb4cba9779db55821348f231026f9a7362100b3a7ea0a68f3018926071
