:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: tech_kalk.fml
:: Utworzony: 22.12.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły do obsługi kalkulacji technologii - część biblioteczna czynności TTE_TEC_KKTL
::======================================================================================================================


\KKTL_new
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: dodaje nową kalkulację dla danej karty
::   WE: _a - TKTL.ref()
::       _b - KWAR.ref()
::       _c - TKTLW.ref()
::       [_d] - 'N'/'T'/'B'
::   WY: 0 / 1
::  OLD: \KKTL_new/tex_kalk.fml
::----------------------------------------------------------------------------------------------------------------------
{? _b=null() || return(0) ?};

tmp_k:=VAR.A_KTL;
tmp_o:=VAR.A_WAR;
tmp_w:=VAR.A_TKTLW;
VAR.A_KTL:=_a;
VAR.A_WAR:=_b;
VAR.A_TKTLW:=_c;
KKTL.blank();
KKTL.NRK:=VAR.A_KTL;
KKTL.OPC:=VAR.A_WAR;
KKTL.TKTLW:=VAR.A_TKTLW;
KKTL.STAN:={? _>3 || form(_d) || 'N' ?};
_ok:=KKTL.add();
VAR.A_KTL:=tmp_k;
VAR.A_WAR:=tmp_o;
VAR.A_TKTLW:=tmp_w;
_ok


\KKTL_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: aktualizuje dane dotyczące kalkulacji
::   WE: [_a] - KKTL.ref()
::  OLD: \KKTL_update/tex_kalk.fml
::----------------------------------------------------------------------------------------------------------------------
{? _>0 || KKTL.seek(_a) ?};
KKTL.DT:=date();
{? KKTL.DW=date(0,0,0) || KKTL.DW:=date()+KKTL.OPC().DW ?};
KKTL.MADE:=OPERATOR.USER;
KKTL.put()


\tech_kalw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.53] OWwPR018/5.2
:: OPIS: KALKULACJA TECHNOLOGII - dla wybranego wyrobu
::   WE: _a - M.ref()
::  OLD: \tech_kalw/tech.fml
::----------------------------------------------------------------------------------------------------------------------
M.cntx_psh();

M.clear();
{? ~M.seek(_a) || M.cntx_pop(); return() ?};
{? M.R<>'W' & M.R<>'P' || FUN.info('Funkcja dostępna tylko dla produktów.'@); M.cntx_pop(); return() ?};
{? M.RODZ='U' || FUN.info('Funkcja nie jest dostępna dla usług.'@); M.cntx_pop(); return() ?};

VAR.GRUPA:='N';
VAR.DATE:=date(0,0,0);
VAR.A_TORW:='T';
TKTL.index('KARC');

TKTLW.index('KARC');
TKTLW.prefix('T',_a,'N');

{? TKTLW.first()
|| VAR.ACTION:='5';
   TKTLW.win_sel('WER_W');
   TKTLW.win_edit('RED_K');
   KKTL.win_sel('WER');
   TKTLW.select()
|| FUN.info(
      'Brak karty technologicznej dla tego produktu,\n'
      'wyświetlone zostaną wszystkie karty prototypowe.'@
   );
   VAR.ACTION:='2';
   KKTL.win_sel('WER');
   TKTL.win_sel('WERP');
   TKTL.index('KARC');
   TKTL.prefix('T',null(),'N');
   {? TKTL.first()
   || {!
      |? {? TKTL.NRK*'dodawana'>0 &
            TKTL.TYP=null() &
            TKTL.count()=0
         || TKTL.del()
         || TKTL.next()
         ?}
      !}
   ?};
   TKTL.select()
?};
TKTL.clear();
TKTLW.clear();
M.cntx_pop();
~~


\anzp_cmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.60]
:: OPIS: Kalkulacja TKW do porównania z kalkulacją/analizą zlecenia
::  OLD: \anzp_cmp0/zlecanal.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZL.RKTL<>''
|| exec('tktl_cntx_psh','tech_common');
   _msk:=(8+ZL.RKTL)+3;
   exec('tktl_use','tech_common',_msk);
   _a_ktl:=VAR.A_KTL;
   VAR.A_KTL:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,"ref()",null());

   KKTL.index('KZ');
   KKTL.prefix(VAR.A_KTL,'T',ZL.KTM);
   {? KKTL.first()
   ||
::    powinna być tylko jedna aktywnie zatwierdzona kalkulacja
      KPOZK.index('KR');
      KPOZK.prefix(KKTL.ref());
      _jk_mat:=VAR.JK_MAT;
      _jk_rob:=VAR.JK_ROB;
      exec('kj_licz','tech_kalk');
      _wer:='WERA';
      KPOZK.win_sel(_wer);
      KPOZK.win_fml(_wer,,'RUBR','NR','ICON_BEFORE',"
         KFORM.index('WR');
         KFORM.prefix(KKTL.OPC,KPOZK.RUBR().NR);
         {? KFORM.first()
         || {? KFORM.FRS=''
            || ''
            || 'xwin16.png:42'
            ?}
         || ''
         ?}
      ");
      params_set(params_get());
      KPOZK.select(,,,'pWC');
      KPOZK.win_fml(_wer,,'RUBR','NR','ICON_BEFORE',"''");
      VAR.JK_MAT:=_jk_mat;
      VAR.JK_ROB:=_jk_rob
   || FUN.info('Brak aktywnej kalkulacji dla technologii: %1 wersja: %2'@[VAR.A_KTL().NRK,VAR.A_KTL().WER])
   ?};
   VAR.A_KTL:=_a_ktl;
   exec('tktl_cntx_pop','tech_common')
||
:: nie ma prototypu - nie ma kalkulacji!
   FUN.info('Brak karty prototypowej dla tego zlecenia.'@)
?};
~~


\kj_licz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.53] Uwaga 68
:: OPIS: wylicza zawartość pól VAR.JK_MAT i VAR.JK_ROB w oknie kalkulacji TKW
::  OLD: \kj_licz/tex_kalk.fml
::----------------------------------------------------------------------------------------------------------------------
KPOZK.cntx_psh();
KPOZK.index('KR');
KPOZK.prefix();
{? KPOZK.find_key(KKTL.ref(),KKTL.NRK().TYP().CRUBIL) || _il:=KPOZK.WART || _il:=0 ?};
{? KPOZK.find_key(KKTL.ref(),KKTL.NRK().TYP().CRUBMAT) || _mat:=KPOZK.WART || _mat:=0 ?};
{? KPOZK.find_key(KKTL.ref(),KKTL.NRK().TYP().CRUBROB) || _rob:=KPOZK.WART || _rob:=0 ?};
{? _il<>0
|| VAR.JK_MAT:=_mat/_il;
   VAR.JK_ROB:=_rob/_il
|| VAR.JK_MAT:=VAR.JK_ROB:=0
?};
KPOZK.cntx_pop();
~~


::======================================================================================================================
:: Parametryzacja kalkulacji
::======================================================================================================================


\sv_load4tech
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: ustalenie parametrów obiektu kalkulacyjnego dla KALKULACJI technologii
::  OLD: \sv_load4tech/prodobi.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_obj.KalAna:=_obj.Header:='Kalkulacja technologii'@;
set_virt(_obj,'load',"exec('load4tech','tech_kalk',.ME,{? _>0 || {? type_of(_a)>6 || _a || KKTL.ref() ?} || KKTL.ref()?},0)");
set_virt(_obj,'save',"exec('save4tech','tech_kalk',.ME)");
exec('set_fun4_kalk','tech_kalk',_obj);
~~


\sv_kload4tech
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: ustalenie parametrów obiektu kalkulacyjnego dla KALKULACJI technologii z tabel tymczasowych
::  OLD: \sv_kload4tech/prodobi.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_obj.KalAna:=_obj.Header:='Kalkulacja technologii'@;
set_virt(_obj,'load',"exec('load4tech','tech_kalk',.ME,{? _>0 || {? type_of(_a)>6 || _a || KKTL.ref() ?} || KKTL.ref()?},1)");
set_virt(_obj,'save',"exec('save4tech','tech_kalk',.ME)");
exec('set_fun4_kalk','tech_kalk',_obj);
~~


\sv_load4air
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: ustalenie parametrów obiektu kalkulacyjnego dla KALKULACJI technologii (w powietrze)
::  OLD: \sv_load4air/prodobi.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_obj.KalAna:=_obj.Header:='Kalkulacja technologii'@;
set_virt(_obj,'load',"exec('load4air','tech_kalk',.ME,{?_>0 || {? type_of(_a)>6 || _a || TKTL.ref()?} || TKTL.ref()?})");
set_virt(_obj,'save',"exec('save4tech','tech_kalk',.ME)");
exec('set_fun4_kalk','tech_kalk',_obj);
~~


\load4tech
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Ładowanie danych dla kalkulacji technologii
::   WE: _a - wskazanie na obiekt kalkulacyjny
::       _b - KKTL.ref()
::       _c - 0 - dane pobierane z tabel
::            1 - dane pobierane są z tymczasowych struktur
::  OLD: \load4tech/prodobi.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_kktl:=_b;
_tmp:=_c;

KKTL.cntx_psh();
KKTL.index('NR');
KKTL.prefix();
{? ~KKTL.seek(_kktl)
|| FUN.error('Nie udało się załadować danych do kalkulacji.'@)
|| _obj.KALK:=KKTL.ref();
   _obj.KTL:=KKTL.NRK;
   _obj.Desc:=KKTL.NRK().NRK+' wer.'+KKTL.NRK().WER;
   _obj.KalAna+=' '+_obj.Desc+':';
   VAR.A_KTL:=_obj.KTL;
   _obj.X:=KKTL.NRK().XJM;

:: Ile ładujemy kalkulacji
   KKTL.prefix(_obj.KTL);
   _obj.WST:=KKTL.size()-1;

   VAR.A_TPKTL:=KKTL.NRK().TYP;
   _typ:=VAR.A_WAR;
   echo('Trwa ładowanie danych do pamięci'@,'Proszę czekać...'@);
:: sprawdźmy ile potrzeba rubryk
   KRUB.clear();
   KRUB.index('NR');
   {? KRUB.last() || _obj.MAX:=KRUB.NR ?};
   _obj.alloc();

:: ładujemy formuły - tabele stałe
   {? _tmp=0
   || KFORM.clear();
      KFORM.index('WR');
      KFORM.prefix(_typ);
      {? KFORM.first()
      || {!
         |? _nr:=KFORM.NRUB().NR;
            _obj.F[_nr]:=KFORM.FRM;
            _obj.G[_nr]:=1;
            KFORM.next()
         !}
      ?};
::    stałe
      KKS.clear();
      KKS.index('WR');
      KKS.prefix(_typ);
      {? KKS.first()
      || {!
         |? _nr:=KKS.RUBR().NR;
            _obj.S[_nr]:=KKS.WAR;
            _obj.G[_nr]:=1;
            KKS.next()
         !}
      ?}

:: ładujemy formuły - tabele tymczasowe
   || __KFORM.clear();
      {? __KFORM.first()
      || {!
         |? _nr:=__KFORM.NR;
            _obj.F[_nr]:=__KFORM.FORM;
            _obj.G[_nr]:=1;
            __KFORM.next()
         !}
      ?};
::    stałe
      __KKS.clear();
      {? __KKS.first()
      || {!
         |? _nr:=__KKS.NR;
            _obj.S[_nr]:=__KKS.WAR;
            _obj.G[_nr]:=1;
            __KKS.next()
         !}
      ?}
   ?};

:: rubryki
   KRUB.clear();
   KRUB.index('NR');
   {? KRUB.first()
   || {!
      |? _nr:=KRUB.NR;
         _obj.R[_nr]:=KRUB.ref();
         _obj.G[_nr]:=1;
         KRUB.next()
      !}
   ?};

:: materiały "z paluszka"
   KKALKH.clear();
   KKALKH.index('KR');
   KKALKH.prefix(_obj.KALK);
   {? KKALKH.first()
   || {!
      |? _nr:=KKALKH.RUBR().NR;
         _obj.H[_nr]:=KKALKH.WAR;
         KKALKH.next()
      !}
   ?};

:: zmodyfikowane wartości
   KPOZK.index('KR');
   KPOZK.prefix(KKTL.ref());
   {? KPOZK.first()
   || {!
      |? _nr:=KPOZK.RUBR().NR;
         {? KPOZK.MANUAL='T'
         || _obj.M[_nr]:='T';
            _obj.V[_nr]:=KPOZK.WART
         ?};
         KPOZK.next()
      !}
   ?};

:: jesli mamy coś wstecz to też załadujemy :)
   _obj.WSTr:=_obj.WST;
   {? _obj.WST>0
   || {! _i:=1..(_obj.WST)
      |! {? KKTL.prev()
         || KPOZK.clear();
            KPOZK.index('KR');
            KPOZK.prefix(KKTL.ref());
            {? KPOZK.first()
            || {!
               |? _obj.L[_i+1][KPOZK.RUBR().NR]:=KPOZK.WART;
                  KPOZK.next()
               !}
            ?}
         || _obj.WSTr:=(_i-1)
         ?}
      !}
::      {? _obj.WSTr<>_obj.WST
::      || KOMM.msg('Nie udało się załadować obliczeń z kalkulacji powyżej '+form(_obj.WST-_obj.WSTr)+' wstecz.')
::      ?}
   ?};

:: teraz powołamy anxm-y
   _obj.anm:=obj_new(@.CLASS.ANK_MAT,'M'      ,'KALMAT'); _obj.anm.K:=_obj.KALK;
   _obj.ant:=obj_new(@.CLASS.ANK_MAT,'TTOPER' ,'KALTTO'); _obj.ant.K:=_obj.KALK;
   _obj.anw:=obj_new(@.CLASS.ANK_MAT,'TWRKPLC','KALWRK'); _obj.anw.K:=_obj.KALK;
   _obj.ano:=obj_new(@.CLASS.ANK_MAT,'TTOUT'  ,'KALTOU'); _obj.ano.K:=_obj.KALK;
   _obj.anu:=obj_new(@.CLASS.ANK_MAT,'M'      ,'KALTLS'); _obj.anu.K:=_obj.KALK;

:: a teraz jeszcze parametry technologii
   {? KKTL.seek(_obj.KALK)
   || KPAR.clear();
      KPAR.index('KN');
      KPAR.prefix(KKTL.ref());
      {? KPAR.first()
      || _obj.tpar:=obj_new(@.CLASS.TPAr);
         _obj.tpar.TABLE:=KPAR;
         _obj.tpar.INDEX:='KN';
         _obj.tpar.PREFIX:=KKTL.ref();
         _obj.tpar.loadp();
         1
      || {? TKTL.seek(KKTL.NRK)
         || TPAR.clear();
            TPAR.index('NN');
            TPAR.prefix(TKTL.ref());
            TPAR.first();
            _obj.tpar:=obj_new(@.CLASS.TPAr,KKTL.TKTLW().KTM);
            _obj.tpar.TABLE:=TPAR;
            _obj.tpar.INDEX:='NN';
            _obj.tpar.PREFIX:=VAR.A_KTL;
            _obj.tpar.loadp()
         ?}
      ?}
   || {? TKTL.seek(KKTL.NRK)
      || TPAR.clear();
         TPAR.index('NN');
         TPAR.prefix(TKTL.ref());
         TPAR.first();
         _obj.tpar:=obj_new(@.CLASS.TPAr,KKTL.TKTLW().KTM);
         _obj.tpar.TABLE:=TPAR;
         _obj.tpar.INDEX:='NN';
         _obj.tpar.PREFIX:=VAR.A_KTL;
         _obj.tpar.loadp()
      || _obj.tpar:=obj_new(@.CLASS.TPAr,KKTL.TKTLW().KTM);
         _obj.tpar.TABLE:=TPAR;
         _obj.tpar.INDEX:='NN';
         _obj.tpar.PREFIX:=VAR.A_KTL;
         1
      ?}
   ?};

   echo('Ładowanie danych do pamięci zakończone'@,'')
?};

KKTL.cntx_pop();
echo();
1


\load4air
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Ładowanie danych dla 'tymczasowej' kalkulacji technologii
::   WE: _a - wskazanie na obiekt kalkulacyjny
::       _b - TKTL.ref()
::  OLD: \load4air/prodobi.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

TKTL.seek(_b);
VAR.A_KTL:=_obj.KTL:=TKTL.ref();
_obj.X:=TKTL.XJM;
_obj.WST:=0;
VAR.A_TPKTL:=TKTL.TYP;
_typ:=VAR.A_WAR:={? TKTL.DEF_OPCK=null() || TKTL.TYP().DEF_OPCK || TKTL.DEF_OPCK ?};

_obj.Desc:=TKTL.NRK+' wer.'+TKTL.WER;
_obj.KalAna+=' '+_obj.Desc+':';

echo('Trwa ładowanie danych do pamięci'@,'Proszę czekać...'@);
:: sprawdźmy ile potrzeba rubryk
KRUB.clear();
KRUB.index('NR');
{? KRUB.last() || _obj.MAX:=KRUB.NR ?};
_obj.alloc();

:: ładujemy formuły
KFORM.clear();
KFORM.index('WR');
KFORM.prefix(_typ);
{? KFORM.first()
|| {!
   |? _nr:=KFORM.NRUB().NR;
      _obj.F[_nr]:=KFORM.FRM;
      _obj.G[_nr]:=1;
      KFORM.next()
   !}
?};

:: stałe
KKS.clear();
KKS.index('WR');
KKS.prefix(_typ);
{? KKS.first()
|| {!
   |? _nr:=KKS.RUBR().NR;
      _obj.S[_nr]:=KKS.WAR;
      _obj.G[_nr]:=1;
      KKS.next()
   !}
?};

:: rubryki
KRUB.clear();
KRUB.index('NR');
{? KRUB.first
|| {!
   |? _nr:=KRUB.NR;
      _obj.R[_nr]:=KRUB.ref();
      _obj.G[_nr]:=1;
      KRUB.next()
   !}
?};

:: teraz powołamy anxm-y
_obj.anm:=obj_new(@.CLASS.ANK_MAT,'M'      ,'KALMAT'); _obj.anm.K:=_obj.KALK;
_obj.ant:=obj_new(@.CLASS.ANK_MAT,'TTOPER' ,'KALTTO'); _obj.ant.K:=_obj.KALK;
_obj.anw:=obj_new(@.CLASS.ANK_MAT,'TWRKPLC','KALWRK'); _obj.anw.K:=_obj.KALK;
_obj.ano:=obj_new(@.CLASS.ANK_MAT,'TTOUT'  ,'KALTOU'); _obj.ano.K:=_obj.KALK;
_obj.anu:=obj_new(@.CLASS.ANK_MAT,'M'      ,'KALTLS'); _obj.anu.K:=_obj.KALK;

:: a teraz jeszcze parametry technologii
{? TKTL.seek(_obj.KTL)
|| TPAR.clear();
   TPAR.index('NN');
   TPAR.prefix(TKTL.ref);
   TPAR.first();
   _obj.tpar:=obj_new(@.CLASS.TPAr);
   _obj.tpar.TABLE:=TPAR;
   _obj.tpar.INDEX:='NN';
   _obj.tpar.PREFIX:=VAR.A_KTL;
   _obj.tpar.loadp()
|| _obj.tpar:=obj_new(@.CLASS.TPAr);
   _obj.tpar.TABLE:=TPAR;
   _obj.tpar.INDEX:='NN';
   _obj.tpar.PREFIX:=VAR.A_KTL;
   1
?};
echo('Ładowanie danych do pamięci zakończone'@,'');
echo();
1


\save4tech
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Zapisanie wyników dla kalkulacji technologii
::   WE: _a - wskazanie na obiekt kalkulacyjny
::  OLD: \save4tech/prodobi.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

echo('Trwa zapisywanie danych.'@,'Proszę czekać...'@);
KKALKH.clear();
KKALKH.index('KR');
KKALKH.prefix(_obj.KALK);
{? KKALKH.first() || {! |? KKALKH.del() !} ?};
exec('poz_del','tech_kalk',_obj.KALK);
KPOZK.clear();
{! _i:=1..(_obj.MAX)
|! {? _obj.G[_i]=2
   || KPOZK.blank();
      KPOZK.KALK:=_obj.KALK;
      KPOZK.RUBR:=_obj.R[_i];
      KPOZK.WART:=_obj.L[1][_i];
      KPOZK.MANUAL:=_obj.M[_i];
      KPOZK.add();
      KKALKH.blank();
      KKALKH.KALK:=_obj.KALK;
      KKALKH.RUBR:=_obj.R[_i];
      KKALKH.WAR:=_obj.H[_i];
      {? KKALKH.WAR<>0 || KKALKH.add()?}
   ?}
!};
_obj.anm.save();
_obj.ant.save();
_obj.anw.save();
_obj.ano.save();
_obj.anu.save();
_obj.tpar.save('KPAR','KKTL',KKTL.ref());
echo('Dane zapisane.'@);
echo();
1


\set_fun4_kalk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Ustala funkcje load_X dla kalkulacji
::   WE: _a - wskazanie na obiekt kalkulacyjny
::  OLD: \set_fun4_kalk/prodobi.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;

set_virt(_obj,'r',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: r() - robocizna
::   WE: [_a] - faza produkcji
::       [_b] - 'T'=Tpz, 'N'=nie Tpz, ''=suma
::       [_c] - ilość kalkulowana, dla jakiej skalować wynik. Gdy nie podana to przeliczana wg ilości na technologii
::----------------------------------------------------------------------------------------------------------------------
   _wynik:='Blad';
   _param1:={? var_pres('_a')>0 || _a || '' ?};
   _param2:={? var_pres('_b')>0 || _b || '' ?};
   _param3:={? var_pres('_c')>0 || _c || 0 ?};
   {? type_of(_param1)<>2
   || .ko('1')
   |? type_of(_param2)<>2
   || .ko('2')
   |? type_of(_param3)<>1
   || .ko('3')
   || {? type_of(.FAZY)<7 || .get_pfaz() ?};
      {? type_of(.ROB)<7
      || _xjm:=exec('FindAndGet','#table',TKTL,.KTL,,\"XJM\",0);
         _coef:={? _xjm=0 | _param3<=0 || 1 || _param3/_xjm ?};
         {? var_pres('__TOPER')>0
         || .ROB:=exec('get1_proc_price','kalk_oper',.ME,.KTL,'R')
         || .ROB:=exec('get_proc_price','kalk_oper',.ME,.KTL,'R',_coef,_param3)
         ?}
      ?};
      _wynik:=0;
      {? _param1<>''
      || _faza:=.seekpfaz(_param1);
         {? _faza<>(-1)
         || _wynik:={? _param2='T' | _param2='' || .ROB[_faza][2] || 0 ?}+
                    {? _param2='N' | _param2='' || .ROB[_faza][1] || 0 ?}
         || _wynik:=0
         ?}
      || {! _i:=1..obj_len(.FAZY)
         |! _wynik+={? _param2='T' | _param2='' || .ROB[_i][2] || 0 ?}+
                    {? _param2='N' | _param2='' || .ROB[_i][1] || 0 ?}
         !}
      ?}
   ?};
   _wynik
");

set_virt(_obj,'g',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: g() - godziny
::   WE: [_a] - faza produkcji
::       [_b] - 'T'=Tpz, 'N'=nie Tpz, ''=suma
::----------------------------------------------------------------------------------------------------------------------
   _wynik:='Blad';
   _param1:={? var_pres('_a')>0 || _a || '' ?};
   _param2:={? var_pres('_b')>0 || _b || '' ?};
   {? type_of(_param1)<>2
   || .ko('1')
   |? type_of(_param2)<>2
   || .ko('2')
   || {? type_of(.FAZY)<7 || .get_pfaz() ?};
      {? type_of(.GODZ)<7
      || {? var_pres('__TOPER')>0
         || .GODZ:=exec('get1_proc_price','kalk_oper',.ME,.KTL,'G')
         || .GODZ:=exec('get_proc_price','kalk_oper',.ME,.KTL,'G')
         ?}
      ?};
      _wynik:=0;
      {? _param1<>''
      || _faza:=.seekpfaz(_param1);
         {? _faza<>(-1)
         || _wynik:={? _param2='T' | _param2='' || .GODZ[_faza][2] || 0 ?}+
                    {? _param2='N' | _param2='' || .GODZ[_faza][1] || 0 ?}
         || _wynik:=0
         ?}
      || {! _i:=1..obj_len(.FAZY)
         |! _wynik+={? _param2='T' | _param2='' || .GODZ[_i][2] || 0 ?}+
                    {? _param2='N' | _param2='' || .GODZ[_i][1] || 0 ?}
         !}
      ?}
   ?};
   _wynik
");

set_virt(_obj,'u',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: u() - usługi (kooperacja)
::   WE: [_a] - faza produkcji
::       [_b] - ilość kalkulowana, dla jakiej skalować wynik. Gdy nie podana to przeliczana wg ilości na technologii
::----------------------------------------------------------------------------------------------------------------------
   _wynik:='Blad';
   _param1:={? _>=1 || {? _a=~~ || '' || _a ?} || '' ?};
   _param2:={? _>=2 || {? _b=~~ || 0 || _b ?} || 0 ?};
   {? type_of(_param1)<>2
   || .ko('1')
   |? type_of(_param2)<>1
   || .ko('2')
   || {? type_of(.FAZY)<7 || .get_pfaz() ?};
      {? type_of(.USL)<7
      || _xjm:=exec('FindAndGet','#table',TKTL,.KTL,,\"XJM\",0);
         _coef:={? _xjm=0 | _param2<=0 || 1 || _param2/_xjm ?};
         .USL:=exec('get_proc_price','kalk_oper',.ME,.KTL,'U',_coef)
      ?};
      _wynik:=0;
      {? _param1<>''
      || _faza:=.seekpfaz(_param1);
         {? _faza<>(-1) || _wynik:=.USL[_faza][1] || _wynik:=0 ?}
      || {! i:=1..obj_len(.FAZY)
         |! _wynik+=.USL[i][1]
         !}
      ?}
   ?};
   _wynik
");

set_virt(_obj,'w',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: w() - koszt stanowisk
::   WE: [_a] - faza produkcji
::       [_b] - ilość kalkulowana, dla jakiej skalować wynik. Gdy nie podana to przeliczana wg ilości na technologii
::----------------------------------------------------------------------------------------------------------------------
   _wynik:='Blad';
   _param1:={? var_pres('_a')>0 || _a || '' ?};
::   _param2:={? var_pres('_b')>0 || _b || '' ?};
   _param2:='';
   _param3:={? var_pres('_b')>0 || _b || 0 ?};
   {? type_of(_param1)<>2
   || .ko('1')
   |? type_of(_param2)<>2
   || .ko('2')
   |? type_of(_param3)<>1
   || .ko('3')
   || {? type_of(.FAZY)<7 || .get_pfaz() ?};
      {? type_of(.WRK)<7
      || _xjm:=exec('FindAndGet','#table',TKTL,.KTL,,\"XJM\",0);
         _coef:={? _xjm=0 | _param3<=0 || 1 || _param3/_xjm ?};
         {? var_pres('__TOPER')>0
         || .WRK:=exec('get1_proc_price','kalk_oper',.ME,.KTL,'W')
         || .WRK:=exec('get_proc_price','kalk_oper',.ME,.KTL,'W',_coef)
         ?}
      ?};
      _wynik:=0;
      {? _param1<>''
      || _faza:=.seekpfaz(_param1);
         {? _faza<>(-1)
         || _wynik:={? _param2='T' | _param2='' || .WRK[_faza][2] || 0 ?}+
                    {? _param2='N' | _param2='' || .WRK[_faza][1] || 0 ?}
         || _wynik:=0
         ?}
      || {! i:=1..obj_len(.FAZY)
         |! _wynik+={? _param2='T' | _param2='' || .WRK[i][2] || 0 ?}+
                    {? _param2='N' | _param2='' || .WRK[i][1] || 0 ?}
         !}
      ?}
   ?};
   _wynik
");

set_virt(_obj, 'm',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: m() - materiały
::----------------------------------------------------------------------------------------------------------------------
   _wyn:='Blad';
   _p1:={? _>=1 || {? _a=~~ || '' || _a ?} || '' ?};
   _p2:={? _>=2 || {? _b=~~ || '' || _b ?} || '' ?};
   _p3:={? _>=3 || {? _c=~~ || '' || _c ?} || '' ?};
   _p4:={? _>=4
        || {? _d=~~
           || 0
           || {? type_of(_d)=2
              || {? _d=''
                 || 0
                 || ~(-(_d))
                 ?}
              || _d
              ?}
           ?}
        || 0
        ?};
   _p5:={? _>=5 || {? _e=~~ || 0 || _e ?} || 0 ?};
   _p6:={? _>=6 || {? _f=~~ || 0 || _f ?} || 0 ?};
   _p7:={? _>=7 || {? _g=~~ || 0 || _g ?} || 0 ?};
   _p8:={? _>=8 || {? _h=~~ || 0 || _h ?} || 0 ?};
   _p9:={? _>=9 || {? _i=~~ || '' || _i ?} || '' ?};
   _p10:={? _>=10 || {? _j=~~ || 0 || _j ?} || 0 ?};
   {? type_of(_p1)<>2 ||.ko('1')
   |? type_of(_p2)<>2 ||.ko('2')
   |? type_of(_p3)<>2 ||.ko('3')
   |? type_of(_p4)<>1 & type_of(_p4)<>2 ||.ko('4')
   |? type_of(_p4)=2 & exec('instring','#string','STHDL',_p4)=0 || .ko('4 — niewłaściwy znak '@)
   |? type_of(_p5)<>1 ||.ko('5')
   |? type_of(_p6)<>1 ||.ko('6')
   |? type_of(_p7)<>1 ||.ko('7')
   |? type_of(_p8)<>1 ||.ko('8')
   |? type_of(_p9)<>2 ||.ko('9')
   |? type_of(_p10)<>1 ||.ko('10')
   || {? type_of(.FAZY)<7 || .get_pfaz() ?};
::    Jeżeli każde użycie funkcji m() miałoby alokować od nowa obiekt z cenami, to należałoby skasować poprzednią instancję
::      {? type_of(.MAT)>7 || obj_del(.MAT) ?};
      {? type_of(.MAT)<7
      || .MAT:=exec('get_src_price','kalk_mater',.ME,.KTL,_p4,KKTL.DT_D,_p6,_p5,_p7,_p8,_p10)
      ?};
      _di:=_dj:=_dk:=_dl:=1;
      _ui:=3;
      _uj:=_ul:=2;
      _uk:=(obj_len(.FAZY));
      {? _p2='M' | _p2='m' || _di:=_ui:=1
      |? _p2='P' | _p2='p' || _di:=_ui:=2
      |? _p2='W' | _p2='w' || _di:=3
      ?};
      {? _p3='N' | _p3='n' || _dj:=2
      |? _p3='T' | _p3='t' || _uj:=1
      ?};
      {? _p1<>''
      || _faza:=.seekpfaz(_p1);
         {? _faza<>(-1) || _dk:=_uk:=_faza || _dk:=_uk:=0 ?}
      ?};
      {? _p9='O' | _p9='o' || _dl:=2
      |? _p9='S' | _p9='s' || _ul:=1
      ?};
      _wyn:=.mat_cost(_di,_ui,_dj,_uj,_dk,_uk,_dl,_ul,1,1)
   ?};
   .run1m:=0;
   _wyn
");

set_virt(_obj,'n',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: n() - narzędzia
::   WE: [_a] - faza produkcji
::       [_b] - rodzaj narzędzia ('N','P','U')
::       [_c] - ilość kalkulowana, dla jakiej skalować wynik. Gdy nie podana to przeliczana wg ilości na technologii
::----------------------------------------------------------------------------------------------------------------------
   _wynik:='Blad';
   _param1:={? _>0 || {? _a=~~ || '' || _a ?} || '' ?};
   _param2:={? _>1 || {? _b=~~ || '' || _b ?} || '' ?};
   _param3:={? _>2 || {? _c=~~ || 0 || _c ?} || 0 ?};
   {? type_of(_param1)<>2 || .ko('1')
   |? type_of(_param2)<>2 || .ko('2')
   |? type_of(_param3)<>1 || .ko('3')
   || {? type_of(.FAZY)<7 || .get_pfaz() ?};
      {? type_of(.TOOL)<7
      || _xjm:=exec('FindAndGet','#table',TKTL,.KTL,,\"XJM\",0);
         _coef:={? _xjm=0 | _param3<=0 || 1 || _param3/_xjm ?};
         .TOOL:=exec('get_utils_price','kalk_tool',.ME,.KTL,,_coef)
      ?};
      _d_i:=_d_j:=1;
      _u_i:=3;_u_j:=obj_len(.FAZY);
      {? _param2='N' || _u_i:=1
      |? _param2='P' || _d_i:=_u_i:=2
      |? _param2='U' || _d_i:=3
      ?};
      {? _param1<>''
      || _faza:=.seekpfaz(_param1);
         {? _faza<>(-1)
         || _d_j:=_u_j:=_faza
         || _d_j:=_u_j:=0
         ?}
      ?};
      _wynik:=.tool_cost(_d_i,_u_i,_d_j,_u_j)
   ?};
   _wynik
");
~~


\poz_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: kasowanie pozycji kalkulacji
::   WE: _a - KKTL.ref()
::  OLD: \poz_del/pkalk.fml
::----------------------------------------------------------------------------------------------------------------------
KKTL.cntx_psh();
KPOZK.clear();
KPOZK.index('KR');
KPOZK.prefix(_a);
{? KPOZK.first() || {! |? KPOZK.del() !} ?};
KKTL.cntx_pop();
0


\chk_krub
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Walidacja rekordu tabeli KRUB (rubryki kalkulacyjne) - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(KRUB);
{? _chk=''
|| {? KRUB.NR<=0
   || FUN.info('Numer rubryki musi być większy od zera.'@);
      'NR'
   || {? __CHK.index(KRUB,_a)='' || '' || 'NR' ?}
   ?}
|| _chk
?}


\chk_kwar
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Walidacja rekordu tabeli KWAR (rubryki kalkulacyjne) - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(KWAR,,'NAZ');
{? _chk=''
|| {? KWAR.DW<0
   || FUN.info('Wartość parametru ''Dni ważności'' nie może być ujemna.'@);
      'DW'
   || {? __CHK.index(KWAR,_a)='' || '' || 'NAZ' ?}
   ?}
|| _chk
?}


\chk_kform
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Walidacja rekordu tabeli KFORM (formuły kalkulacji) - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record2(KFORM,'NRUB','Rubryka'@,'FRM','Wyliczanie wartości pozycji'@);
{? _chk=''
|| {? __CHK.index(KFORM,_a)='' || '' || 'NRUB' ?}
|| _chk
?}


\chk_kks
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Walidacja rekordu tabeli KKS (stałe kalkulacji) - wołana z poziomu okna oraz funkcji importujących
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::   WY: akronim pola / ''
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(KKS);
{? _chk=''
|| {? __CHK.index(KKS,_a)='' || '' || 'RUBR' ?}
|| _chk
?}

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:38 aa742018d43e5ab8eea11d03409658136b695f2f8abb6a76fad8d6271914e55c05c9eb7b3a308c3342a929799bfae559493cb5d6d57f84401f88efcae86963eeb79cc0b4e728935beaa66145730b77b887a3142fa9b45be8c0cce5f23521cb1863a97b296760974569ab822c693b1abb08f1683b5493a53e6ae4ad25fb66a5b5
