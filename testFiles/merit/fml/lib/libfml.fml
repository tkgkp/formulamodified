:!UTF-8
::(c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: libfml.fml [12.10]
:: Utworzony: 2010/11/22
:: Autor: jerry
::======================================================================================================================
:: Zawartość: biblioteka formuł - czasami alternatyw dla _libfml
::
:: Wymagania: powołany obiekt Class klasy Class (class.fml)
::======================================================================================================================


\cStrConv
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Obiekt konwersji - teoretycznie powinień być wydajniejszy niż standardowy w _string.fml
::
::  Deklarowanie klasy jStrConv, raz przed utworzeniem obiektów tej klasy.
::     exec('cStrConv','libfml')
::  Powołanie obiektu:
::     Conv:=obj_new(@.CLASS.cStrConv [,max_char_num])
::
::       max_char_num - maksymalna liczba znaków (obecnie 256, gdy przyjdzie UTF może trzeba będzie zmienić)
::
::  Ustalenie metody konwersji
::     Conv.setConv(rodzaj_konwersji)
::
::       rodzaj_kowersji - np. 'maz2w95', dowolne kombinacje maz,w95,pln,iso,oem
::
::     Conv.setConv(listaznakowZ, listaznakowD)
::
::       listaznakowZ - lista znaków, które należy przekonwertować
::       listaznakowD - lista znaków, na które należy przekonwertować
::       UWAGA: parametry musza być tej samej długości
::
::  Ustalenie konwersji dla pojedynczego znaku
::     Conv.setchar(znak, wartość)
::
::       znak - znak, który ma zostać zastąpiony
::       wartość - wartość, która ma zostać zwrócona dla znak (dopuszczalne: tekst albo liczba)
::
::  Konwersja pojedynczego znaku
::     Conv.convchar(znak)
::
::       znak - znak, który ma zostać zastąpiony
::
::  Konwersja tekstu
::     Conv.convstr(tekst)
::
::       tekst - konwertowany tekst
::----------------------------------------------------------------------------------------------------------------------
::
::  WE: [_a] - tworzyć obiekt (domyślnie 0)
::----------------------------------------------------------------------------------------------------------------------
_genobj:={?_>0 & type_of(_a)=1 || _a<>0 || 0 ?};

_cl_name:=@.Class.get_name('cStrConv');
{? var_pres(_cl_name,@.CLASS)<0
||
   obj_decl(_cl_name
   ,obj_fld('this'    ,~~)
   ,obj_fld('ConvTab' ,~~)
   ,obj_fld('ConvTabS',256)
   ,obj_fld('CurConvF','')
   ,obj_fld('CurConvT','')

   ,obj_meth('__init'  ,"
      _a.this:=_a;
      {? _>1 & type_of(_b)=1 & _b>0 || _a.ConvTabS:=int(_b) ?};
      _a.ConvTab:=obj_new(_a.ConvTabS);
      {! _ct:=1.._a.ConvTabS |! _a.ConvTab[_ct]:=%(_ct-1) !};
      1
     "
     )

   ,obj_meth('setConv' ,"{! _cc:=1.. .ConvTabS |! .ConvTab[_cc]:=%(_cc-1) !}",-1,-1)

   ,obj_meth('setConv' ,"
      _kind:=_a;

      _maz:='ąćęłńóśżźĄĆĘŁŃÓŚŻŹ';
      _w95:='╣µΩ│±≤Ł┐ƒŃ╞╩Ó╤╙î»Ą';
      _pln:='acelnoszzACELNOSZZ';
      _iso:='▒µΩ│±≤╢┐╝Ż╞╩Ó╤╙ź»¼';
      _oem:='Ńą⌐êΣóŚ╛½ńĄ¿¥παù╜ć';

::    'switch' nie jest wydajny, ale raczej nie powinien występować w pętli, więc nie powinno to wpłynąć na wydajność
      {? _kind='maz2w95' || _A:=_maz; _B:=_w95
      |? _kind='maz2pln' || _A:=_maz; _B:=_pln
      |? _kind='maz2iso' || _A:=_maz; _B:=_iso
      |? _kind='maz2oem' || _A:=_maz; _B:=_oem

      |? _kind='w952maz' || _A:=_w95; _B:=_maz
      |? _kind='w952pln' || _A:=_w95; _B:=_pln
      |? _kind='w952iso' || _A:=_w95; _B:=_iso
      |? _kind='w952oem' || _A:=_w95; _B:=_oem

      |? _kind='pln2w95' || _A:=_pln; _B:=_w95
      |? _kind='pln2maz' || _A:=_pln; _B:=_maz
      |? _kind='pln2iso' || _A:=_pln; _B:=_iso
      |? _kind='pln2oem' || _A:=_pln; _B:=_oem

      |? _kind='iso2w95' || _A:=_iso; _B:=_w95
      |? _kind='iso2pln' || _A:=_iso; _B:=_pln
      |? _kind='iso2maz' || _A:=_iso; _B:=_maz
      |? _kind='iso2oem' || _A:=_iso; _B:=_oem

      |? _kind='oem2w95' || _A:=_oem; _B:=_w95
      |? _kind='oem2pln' || _A:=_oem; _B:=_pln
      |? _kind='oem2iso' || _A:=_oem; _B:=_iso
      |? _kind='oem2oem' || _A:=_oem; _B:=_maz

                         || _A:=_B:=''
      ?};
      .setConv(_A,_B)
     "
     ,type_of('')
     )

   ,obj_meth('setConv' ,"
      _convF:=_a;
      _convT:=_b;
      {? +_convF=+_convT
       & +_convF
      || {? .CurConvF<>_convF
          | .CurConvT<>_convT
         || .setConv();

            {!_cc:=1..+_convF
            |! _char:=(_cc+_convF)+1;
               .ConvTab[%_char+1]:=(_cc+_convT)+1
            !};

            .CurConvF:=_convF;
            .CurConvT:=_convT
         ?};
         1
      ?}
     "
     ,type_of('')
     ,type_of('')
     )

   ,obj_meth('setchar'  ,".ConvTab[%(1+_a)+1]:=_b",type_of(''),type_of(0) )
   ,obj_meth('setchar'  ,".ConvTab[%(1+_a)+1]:=_b",type_of(''),type_of(''))


   ,obj_meth('convchar' ,".ConvTab[%(1+_a)+1]",type_of(''),-1)

   ,obj_meth('convstr' ,"
      _res:='';
      _src:=_a;
      _tab:=.ConvTab;
      {? type_of(_tab)>100 & +_src
      || {!
         |? _char:=1+_src;
             _src:=1-_src;
            _res:=_res+_tab[(%_char)+1];
            +_src
         !}
      ?};
      _res
     "
     )
   );
   ~~
?};
{? @.Class.setclass('cStrConv',_cl_name)
|| {? _genobj
   || obj_new(@.Class.cStrConv)
   || 1
   ?}
|| 0
?}


\cHex
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Deklaracja obiektu do obsługi systemu F ( .sqlint() wykonuje sie krócej o okolo 39% wzgledem BIT.sqlint()
::----------------------------------------------------------------------------------------------------------------------
_CL_NAME:='cHex';
_cl_name:=@.Class.get_name(_CL_NAME);
{? var_pres(_cl_name,@.CLASS)<=0
|| obj_decl(_cl_name
   ,obj_fld('this'    ,'Wskazanie na siebie';~~)
   ,obj_fld('T'       ,'Tablica konwersji znakow na liczby';~~)
   ,obj_fld('zera'    ,'tekst zerowy';'')
   ,obj_fld('Tx'      ,'Maksymalna szerokosc tablicy T';8)

   ,obj_meth('__init','konstruktor';"
             _a.this:=_a;

             _a.T:=obj_new(_a.Tx);
             _a.zera:='0'*_a.Tx;

             {! _tt:=1.._a.Tx
             |! _base:=pow(16,(_tt-1));
                _a.T[_tt]:=obj_new(255);
                {! _i:=1..255
                |! _a.T[_tt][_i]:=0
                !};
                _a.T[_tt][ 48]:= 0;
                _a.T[_tt][ 49]:= 1*_base;
                _a.T[_tt][ 50]:= 2*_base;
                _a.T[_tt][ 51]:= 3*_base;
                _a.T[_tt][ 52]:= 4*_base;
                _a.T[_tt][ 53]:= 5*_base;
                _a.T[_tt][ 54]:= 6*_base;
                _a.T[_tt][ 55]:= 7*_base;
                _a.T[_tt][ 56]:= 8*_base;
                _a.T[_tt][ 57]:= 9*_base;

                _a.T[_tt][ 65]:=10*_base;
                _a.T[_tt][ 66]:=11*_base;
                _a.T[_tt][ 67]:=12*_base;
                _a.T[_tt][ 68]:=13*_base;
                _a.T[_tt][ 69]:=14*_base;
                _a.T[_tt][ 70]:=15*_base;

                _a.T[_tt][ 97]:=10*_base;
                _a.T[_tt][ 98]:=11*_base;
                _a.T[_tt][ 99]:=12*_base;
                _a.T[_tt][100]:=13*_base;
                _a.T[_tt][101]:=14*_base;
                _a.T[_tt][102]:=15*_base;
                ~~
             !}
            "
            )

   ,_hex2int:="
               _txt:=(.zera+form(_a))+.Tx;

                .T[ 1][%(1+(_txt+ 1))]
               +.T[ 2][%(1+(_txt+ 2))]
               +.T[ 3][%(1+(_txt+ 3))]
               +.T[ 4][%(1+(_txt+ 4))]
               +.T[ 5][%(1+(_txt+ 5))]
               +.T[ 6][%(1+(_txt+ 6))]
               +.T[ 7][%(1+(_txt+ 7))]
               +.T[ 8][%(1+(_txt+ 8))]
::             +.T[ 9][%(1+(_txt+ 9)]
::             +.T[10][%(1+(_txt+10)]
::             +.T[11][%(1+(_txt+11)]
::             +.T[12][%(1+(_txt+12)]
::             +.T[13][%(1+(_txt+13)]
::             +.T[14][%(1+(_txt+14)]
::             +.T[15][%(1+(_txt+15)]
::             +.T[16][%(1+(_txt+16)]
            ";
    obj_meth('sqlint'  ,'';_hex2int,type_of(''))
   ,obj_meth('to_int'  ,'';_hex2int,type_of(''))

   );
   @.Class.setclass(_CL_NAME,_cl_name)
?};
~~


\cNSystem
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Klasa do obslugi systemow liczbowych
::----------------------------------------------------------------------------------------------------------------------
_CL_NAME:='cNSystem';
_cl_name:=@.Class.get_name(_CL_NAME);
{? var_pres(_cl_name,@.CLASS)<0
||
   obj_decl(_cl_name
   ,obj_fld('this'    ,~~)
   ,obj_fld('Base'    ,0)
::                      0123456789abcdefghijklmnopqrstuvwxyz_ABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^`{|}
   ,obj_fld('BChars'  ,'0123456789abcdefghijklmnopqrstuvwxyz_')
   ,obj_fld('C2N'     ,null())
   ,obj_fld('N2C'     ,null())
   ,obj_fld('bPOW'    ,null())
   ,obj_fld('bPOWs'   ,8)

   ,obj_meth('__init',"
      _a.this:=_a;
      _bchars:={? _>1
               || {? type_of(_b)=2 & +_b  || _b
                  |? type_of(_b)=1 & _b>0 || _b+_a.BChars
                                          || _a.BChars
                  ?}
               || _a.BChars
               ?};
      {| _a
      |! BChars:=_bchars;
         Base:=+BChars;

         bPOW:=obj_new(bPOWs); bPOW[1]:=1; {! _bp:=2..bPOWs |! bPOW[_bp]:=bPOW[_bp-1]*Base !};

         C2N:=obj_new(255); {!_cc:=1..255 |! C2N[_cc]:=0 !};

         N2C:=obj_new(Base);
         {! _nn:=1..Base
         |! N2C[_nn]:=(_nn+BChars)+1;
            C2N[(%N2C[_nn])]:=_nn-1
         !};

         ~~
      |};
      ~~
      ")

   ,obj_meth('str2num' ,'zwraca liczbe dla tekstu';"
         _txt:=_a;
         _val:=0;
         {! _cc:=1..+_txt
         |! _cn:=(1+(_txt+_cc));
            _val+=.C2N[%_cn]*.bPOW[_cc]
         !};
         _val
      "
      ,type_of('')
      )

   ,obj_meth('num2str' ,'zwraca tekst dla liczby';"
         _num:=_a#0;
         _txt:='';
         {! _pp:=.bPOWs//-1..1
         |! _txt+={? _num>=.bPOW[_pp]
                  || _nmb:=_num%.bPOW[_pp];
                     _num-=_nmb*.bPOW[_pp];
                     .N2C[_nmb+1]
                  || .N2C[1]
                  ?}
         !};
         _txt
      "
      ,type_of(1)
      )

   ,obj_meth('max_val' ,'maksymalna wartosc dla zadanej liczby znakow';"
         _cnum:={? _>0
                || {? type_of(_a)=1 || _a
                   |? type_of(_a)=2 || +_a
                                    || .bPOWs
                   ?}
                || .bPOWs
                ?};
         {? _cnum>.bPOWs || _cnum:=.bPOWs ?};
         {? _cnum || .bPOW[_cnum]*.Base   ?}
      "
      )
   );
   @.Class.setclass(_CL_NAME,_cl_name)
?}


\cFPars
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry & tommro [12.10]
:: OPIS: Klasa do obsługi parametrów formuł
::
:: Formuła wykorzystująca mechanizm musi mieć nastepującą linie kodu
:: {? _||{! _index:=1.._ |! FParams.decode(_args,_[_index])!}; &_index?};
:: gdzie _args - wskazanie na tablice z elementami nazwanymi lub obiekt
::
:: Przykład użycia
:: cFPars_demo_fml - formuła wykorzystujaca mechanizm
:: cFPars_demo_exe - wywolanie formuły wykorzystującej mechanizm
::----------------------------------------------------------------------------------------------------------------------
_CL_NAME:='cFPars';
_cl_name:=@.Class.get_name(_CL_NAME);
{? var_pres(_cl_name,@.CLASS)<=0
|| obj_decl(_cl_name
::   ,obj_fld('this'    ,'Wskazanie na siebie';~~)
   ,obj_meth('code'     ,'pakuje dane do przekazania w parametrze. UWAGA: brak kontroli typów, _a musi byc typu STRING';"
      _par:=obj_new('key','value');
      _par.key:=_a;
      _par.value:=_b;
      _par
      ")
   ,obj_meth('decode'   ,'nanosi dane z parametru przekazanego (_b) do tablicy parametrow (_a)';"
      {? type_of(_b)>100
       & var_pres('key',_b)>-1
       & var_pres('value',_b)>-1
       & var_pres(_b.key,_a)>-1
      || ($('_a.'+_b.key+':=_b.value'))(_a,_b)
      || ~~
      ?}
      ")
   );
   @.Class.setclass(_CL_NAME,_cl_name)
?};
{? var_pres('FParams')>100 || obj_del('FParams') ?};
FPars:=obj_new(@.Class.cFPars);
~~


\cFPars_demo_fml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: PRZYKLAD użycia cFPars - formuła wykorzystująca mechanizm
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('material','ilosc','cena','wartosc','kolor','obwod','rodzaj','opis');
:: ustalenie wartosci domyslnych
_args.material:=null();
_args.ilosc:=0;
_args.cena:=1;
_args.wartosc:=0;
_args.kolor:='Pomarańczowy';
_args.obwod:=80;
_args.rodzaj:='X';
_args.opis:='Opis standardowy';
:: przyjecie parametrow
{? _||{! _index:=1.._ |! FPars.decode(_args,_[_index])!}; &_index?};
:: wykorzystanie parametrow
_txt:='Nie przekazano materiału';
{? _args.material<>null()
|| M.cntx_psh();
   M.clear();
   {? M.seek(_args.material)
   || _txt:='('+M.KTM+') '+M.N
   ?};
   M.cntx_pop();
   ~~
?};
FUN.info(exec('form','#string','L'
             ,'Materiał: '+_txt
             ,'Ilość:    '+form(_args.ilosc)
             ,'Cena:     '+form(_args.cena)
             ,'Wartość:  '+form(_args.wartosc)
             ,'Kolor:    '+form(_args.kolor)
             ,'Obwód:    '+form(_args.obwod)
             ,'Rodzaj:   '+form(_args.rodzaj)
             ,'Opis:     '+form(_args.opis)
             )
        );
~~


\cFPars_demo_exe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: PRZYKLAD użycia cFPars - wywołanie formuły wykorzystującej mechanizm
::----------------------------------------------------------------------------------------------------------------------
_cena:=1.1;
_ilosc:=12;
M.first();
exec('cFPars_demo_fml','libfml',FPars.code('material',M.ref()              )
                               ,FPars.code('ilosc'   ,_ilosc               )
                               ,FPars.code('cena'    ,_cena                )
                               ,FPars.code('wartosc' ,_ilosc*_cena         )
                               ,FPars.code('opis'    ,'Pierwsze wywołanie' )
    );

exec('cFPars_demo_fml','libfml',FPars.code('material',M.ref()              )
                               ,FPars.code('kolor'   ,'Biały'              )
                               ,FPars.code('rodzaj'  ,'Y'                  )
                               ,FPars.code('wartosc' ,_ilosc*_cena         )
                               ,FPars.code('opis'    ,'Drugie wywołanie'   )
    );

exec('cFPars_demo_fml','libfml',FPars.code('obwod'   ,75                   )
                               ,FPars.code('kolor'   ,'Biały'              )
                               ,FPars.code('wartosc' ,_ilosc*_cena         )
                               ,FPars.code('opis'    ,'Trzecie wywołanie'  )
    );
~~


\exec_with_msg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Wykonuje formułe podana w parametrze, ale gdy formula zwroci tekst, to zostanie on wyswietlony i zwrocone _c
::   WE: _a - FORMULA - formuła do wykonania
::       _b - ANY     - wartość do zwrócenia, gdy formuła zwróci tekst
::   WY: wynik formuły albo _b
::----------------------------------------------------------------------------------------------------------------------
_fml:={? _>0 & type_of(_a)=type_of("") || _a || ~~ ?};
_ret:={? _>1                           || _b || ~~ ?};

{? _fml<>~~
|| _result:=_fml();
   {? type_of(_result)=2 || FUN.emsg(_result); _ret
                         ||                    _result
   ?}
|| _ret
?}


\ile_miesiecy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: wyznacza liczbe miesięcy między dwiema datami
::   WE: DATE _a - data początkowa
::       DATE _b - data końcowa
::   WY: REAL liczba miesiecy pomiedzy datami
::----------------------------------------------------------------------------------------------------------------------
_od:={?_>0 & type_of(_a)=type_of(date()) || _a || date() ?};
_do:={?_>1 & type_of(_b)=type_of(date()) || _b || date() ?};

{? _do<_od || _do==_od ?};

_ar:=_od~1;
_am:=_od~2;
_ad:=_od~3;
_ae:=1.0*(date(_ar,_am,0)~3);

_br:=_do~1;
_bm:=_do~2;
_bd:=_do~3;
_be:=1.0*(date(_br,_bm,0)~3);

 (_br*12+_bm+(_bd/_be))
-(_ar*12+_am+(_ad/_ae))


\cResult
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: deklaracja klasy wyniku
::----------------------------------------------------------------------------------------------------------------------
_CL_NAME:='cResult';
_cl_name:=@.Class.get_name(_CL_NAME);
{? var_pres(_cl_name,@.CLASS)<=0
|| obj_decl(_cl_name
   ,obj_fld('State'  ,'Status wyniku 0-niepowodzenie' ;0)
   ,obj_fld('Result' ,'Wynik';~~)
   ,obj_fld('Message','Komunikat dla uzytkownika';'')
   ,obj_fld('WdrMsg' ,'Komunikat dla wdrożeniowca, np. szczegolowa informacja o bledzie';'')
   ,obj_fld('Result2','Dodatkowy wynik';~~)
   ,obj_fld('Result3','Dodatkowy wynik';~~)
   );
   @.Class.setclass(_CL_NAME,_cl_name)
?};
~~


\mbTables
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Wyświetla tabele systemu
::----------------------------------------------------------------------------------------------------------------------
_tables:=tab_tmp(1
                ,'ACRONYM','STRING[8]','AKRONIM'@
                ,'AKRONIM','STRING[8]','akronim'
                ,'NAME'   ,'STRING[8]','Maska'@
                ,'COMMENT','STRING[60]','Komentarz'@
                ,'REAL'   ,'STRING[1]','Tabela'@
                ,'NR'     ,'INTEGER','Nr'@
                ,'READ'   ,'STRING[1]','R'
                ,'WRITE'  ,'STRING[1]','W'
                ,'LOCAL'   ,'STRING[1]','L'@
                );
_loc_path:=pth_dir(':ąąąąąąąą.mdb');
{! _tt:=1..tab_num()
|! _tables.blank();
   _acr:=tab_acr(_tt);
   _tables.NR:=_tt;
   _tables.ACRONYM:=_acr;
   _tables.AKRONIM:=-_acr;
   _tables.NAME:=($_acr)().name(1);
   _tables.COMMENT:=($_acr)().comment();
   _tables.REAL:={? tab_real(_tt) || 'T' || 'Z' ?};
   _tables.READ:={? ($_acr)().tab_read() || 'T' || 'N' ?};
   _tables.WRITE:={? ($_acr)().tab_mod() || 'T' || 'N' ?};
   _tables.LOCAL:={? pth_dir(':%1.mdb' [gsub(_tables.NAME,'?','_')])=_loc_path || 'T' || 'N' ?};
   _tables.add()
!};

_win:=_tables.mk_sel('Tabele i zmienne'@,'P',0,'libtabsandvars',1,1,,,'U');
_tables.win_sel(_win);
_tables.win_fld(_win,,'REAL'    ,,,3,,,'T',,'Tabela?'@,2,,"'T'","'Z'");
_tables.win_fld(_win,,'NAME'    ,,,8);
_tables.win_fld(_win,,'ACRONYM' ,,,8);
::_tables.win_fld(_win,,'AKRONIM' ,,,8);
_tables.win_fld(_win,,'COMMENT' ,,,40);
_tables.win_fld(_win,,'READ'    ,,,3,,,,,'Czytalna?'@   ,2,,"'T'","'N'");
_tables.win_fld(_win,,'WRITE'   ,,,3,,,,,'Zapisywalna?'@,2,,"'T'","'N'");
_tables.win_fld(_win,,'LOCAL'   ,,,3,,,,,'Lokalna?'@,2,,"'T'","'N'");

_tables.win_act(_win,,'Formuła','&Pola'@@      ,,,"exec('mbTabFields'  ,'libfml',cur_tab(1,1).ACRONYM)",,1,,,,'P');
_tables.win_act(_win,,'Formuła','&Indeksy'@@   ,,,"exec('mbTabIndexes' ,'libfml',cur_tab(1,1).ACRONYM)",,,,,,'I');
_tables.win_act(_win,,'Formuła','&Maski'@@     ,,,"exec('mbTabNames'   ,'libfml',cur_tab(1,1).ACRONYM)",,,,,,'M');
_tables.win_act(_win,,'Formuła','&Triggery'@@,,,"exec('mbTabTriggers','libfml',cur_tab(1,1).ACRONYM)",,,,,,'T');

'Selekcja niedostępna dla zmiennej.'@;
_sElect:="
          {? cur_tab(1,1).REAL='T'
          || _tab:=($cur_tab(1,1).ACRONYM)();
             _tab.cntx_psh(); _tab.clear();
             exec('select','#table',_tab,ask('Czy struktura drzewiasta?'@));
             _tab.cntx_pop();
             ~~
          || FUN.info('Selekcja niedostępna dla zmiennej.'@)
          ?};
          ~~";

_tables.win_act(_win,,'Formuła','S&elect'@@  ,,,_sElect,,,,,,'E');

_win_menu:='Generuj formułę'@;
_tables.win_act(_win,,'Menu',_win_menu,,'Generuje formułę na podstawie tabeli'@);
_tables.win_act(_win,,'Formuła','&Tabela tymczasowa'@@,_win_menu,
                  ,"exec('table2tab_tmp','libfml',($cur_tab(1,1).ACRONYM)())",,,,,,'T');
_tables.win_act(_win,,'Formuła','Tablica &bufor'@@,_win_menu,
                  ,"exec('table2buffer' ,'libfml',($cur_tab(1,1).ACRONYM)(),cur_tab(1,1).ACRONYM)",,,,,,'B');
::_tables.win_act(_win,,'Formuła','&Komentarz'@@,_win_menu,
::                  ,"exec('table2fml_comm','libfml',($cur_tab(1,1).ACRONYM)())",,,,,,'K');
_tables.win_act(_win,,'Formuła','--X',_win_menu);
_tables.win_act(_win,,'Formuła','&Formuła tworząca bufor'@@,_win_menu,
                  ,"exec('table2bufmlcomp' ,'libfml',($cur_tab(1,1).ACRONYM)(),cur_tab(1,1).ACRONYM)",,,,,,'F');

::_tables.win_act(_win,,'Rekord',,,,"{? cur_tab(1,1).REAL='T' || ',240:255:240' || ',240:240:255' ?}");

_tables.win_act(_win,,'Kolejność');
_tables.win_act(_win,,'Szukaj');

_tables.select()


\mbTabFields
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Wyświetla pola dla podanej tabeli
::   WE: tabela (alias, akronim, numer)
::----------------------------------------------------------------------------------------------------------------------
_Tab:={?_>0
      || {? type_of(_a)=type_of(SYSLOG) || _a
         |? type_of(_a)=type_of('')     || ($_a)()
         |? type_of(_a)=type_of(1)      || ($tab_acr(_a))()
                                        || ~~
         ?}
      || ~~
      ?};

{? type_of(_Tab)
||
   _mbTable:=~~;
   {? var_pres('mbTable')>100 || _mbTable:=mbTable; obj_del(mbTable) ?};
   mbTable:=_Tab;

   _tpos:=0;
   {! _tt:=1..tab_num() |? _tpos=0 |! {? ($tab_acr(_tt))()=_Tab || _tpos:=_tt ?} !};

   _TabIstab:=1;
   _TabIsTmp:=0;
   _TabAcr:=~~;
   {? _tpos>0
   || _TabAcr:=tab_acr(_tpos);
      {? tab_real(_tpos)
      || _TabIsTmp:=0; _TabIstab:=1; _whatisTab:='Tabela: '+_TabAcr
      || _TabIsTmp:=0; _TabIstab:=0; _whatisTab:='Zmienna: '+_TabAcr
      ?}
   ||    _TabIsTmp:=1; _TabIstab:=1; _whatisTab:='Tabela tymczasowa'
   ?};
   _tab:=exec('mbTabFields_tab','#table',_Tab);
   _devel:=0;
   {? _devel
   || _tab.win_edit(_tab.mk_edit(,1))
   || _tab.prefix('F')
   ?};
   _title:=_whatisTab+' - '+_Tab.name();
   _tab.cntx_psh();
   {? _tab.last()
   || {? _tab.SIZE>0
      || _title+=' (Rozmiar bufora fizycznego: '+$_tab.SIZE+' bajtów)'
      ?}
   ?};
   _tab.cntx_pop();

   _win:=_tab.mk_sel(_title
                    ,'P',0,'libfieldsoftab',,,,,'U'
                    );
   _tab.win_sel(_win);
   _tab.win_fld(_win,,'FLD_POS' ,,,3);
   _tab.win_fld(_win,,'FLD_NAME',,,20);
   _tab.win_fld(_win,,'FLD_ACR' ,,,8);
   _tab.win_fld(_win,,'FLD_TYPE',,,9);
   _tab.win_fld(_win,,'FLD_COMM',,,30);
   _tab.win_fld(_win,,'FLD_VAL' ,,,30);

   _ff:="{? 1+cur_tab(1,1).FLD_TYPE='_' || exec('mbTabFields','libfml',(1-cur_tab(1,1).FLD_TYPE)) ?};~~";
   _tab.win_act(_win,,'Formuła','&Pola'@@,,,_ff,,1,,,,'P');
   {? _TabIstab
   ||
      {? _TabIsTmp=0
      || _tab.win_act(_win,,'Formuła','&Indeksy'@@,,,"exec('mbTabIndexes' ,'libfml',mbTable)",,,,,,'I')
      ?};
      _tab.win_act(_win,,'Formuła','&Triggery'@@,,,"exec('mbTabTriggers','libfml',mbTable)",,,,,,'T');
      _tab.win_act(_win,,'Formuła','&Maski'@@,,,"exec('mbTabNames'   ,'libfml',mbTable)",,,,,,'M');
      _tab.win_act(_win,,'Formuła','&Uniq'@@,,,"exec('UniqFldValues','libfml',mbTable,cur_tab(1,1).FLD_ACR)",,,,,,'U');
      ~~
   ?};
   _win_menu:='Generuj formułę'@@;
   _tab.win_act(_win,,'Menu',_win_menu,,'Generuje formułę na podstawie tabeli'@,,,,,,,'G');
   _tab.win_act(_win,,'Formuła','&Tabela tymczasowa'@@,'#G',,"exec('table2tab_tmp','libfml',mbTable)",,,,,,'T');
   _tab.win_act(_win,,'Formuła','Tablica &bufor'@@,'#G',
                ,$("exec('table2buffer' ,'libfml',mbTable,"+{? _TabAcr<>~~ || ''''+_TabAcr+'''' || '' ?}+")"),,,,,,'B');
   _tab.win_act(_win,,'Formuła','&Komentarz'@@,'#G',,"exec('table2fml_comm','libfml',cur_tab(1,1))",,,,,,'K');
   _tab.win_act(_win,,'Formuła','--X','#G');
   _tab.win_act(_win,,'Formuła','&Formuła tworząca bufor'@@,'#G',
                ,$("exec('table2bufmlcomp','libfml',mbTable,"+{? _TabAcr<>~~ || ''''+_TabAcr+'''' || '' ?}+")")
                ,,,,,,'F');
   _tab.win_act(_win,,'Formuła','Formuły dla pola',,'Prezentacja formuł obsługi i formatu pola'@,
      "exec('mbTabFieldFormulas','libfml',mbTable,cur_tab(1,1).FLD_ACR)",,,,,,'F');
   _tab.win_act(_win,,'Kolejność');
   _tab.win_act(_win,,'Rekord',,,
      ," _tab:=cur_tab(1,1);
         {? 1+_tab.FLD_TYPE='_'
         || _ga:=':';
            _ret:='0:0:64,255:255:192'
         || _ga:='P';
            _ret:=~~
         ?};
         _tab.actions_grayed(cur_win(1,1),_ga);
         _ret
      "
   );
   _sel_res:=_tab.select();
   {? type_of(_mbTable)>0
   || {? type_of(mbTable)>100 || obj_del(mbTable) ?};
      mbTable:=_mbTable
   ?};
   _sel_res
|| 'Błędny typ argumentu'
?}


\mbTabIndexes
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Wyswietla liste indeksow tabeli
::   WE: tabela (alias, akronim, numer)
::----------------------------------------------------------------------------------------------------------------------
_Tab:={?_>0
      || {? type_of(_a)=type_of(SYSLOG) || _a
         |? type_of(_a)=type_of('')     || ($_a)()
         |? type_of(_a)=type_of(1)      || ($tab_acr(_a))()
                                        || ~~
         ?}
      || ~~
      ?};
{? type_of(_Tab)
|| _tpos:=0;
   {! _tt:=1..tab_num() |? _tpos=0 |! {? ($tab_acr(_tt))()=_Tab || _tpos:=_tt ?} !};

   _tab:=tab_tmp(1
                ,'NDX_NUM' ,'INTEGER'   ,'Lp.'@
                ,'NDX_ACR' ,'STRING[8]' ,'Akronim'@
                ,'NDX_UNIQ','STRING[9]' ,'Unik.'@
                );
   {!_ff:=1.._Tab.ndx_num()
   |!  _tab.NDX_NUM:=_ff;
       _tab.NDX_ACR:=_Tab.ndx_acr(_ff);
      _tab.NDX_UNIQ:={? _Tab.ndx_uniq(_ff) || 'T' || 'N' ?};
      _tab.add(1)
   !};
   _win:=_tab.mk_sel('Indeksy tabeli '@+tab_acr(_tpos)+' - '+_Tab.name()
                    ,'P',0,'libtabindexes',3,3
                    );
   _tab.win_sel(_win);
   _tab.win_fld(_win,,'NDX_NUM' ,,,3);
   _tab.win_fld(_win,,'NDX_ACR' ,,,8);
   _tab.win_fld(_win,,'NDX_UNIQ',,,5,,,,,,2,,$'''T''',$'''N''');

   _tab.win_act(_win,,'Formuła','&Pola'@@,,
                    ,$("exec('mbTabNdxFields','libfml','"+tab_acr(_tpos)+"',cur_tab(1,1).NDX_NUM)"),,1,,,,'P');
   _tab.win_act(_win,,'Kolejność');
   _tab.select();
   1
|| 'Błędny typ argumentu'
?}


\mbTabNdxFields
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Wyświetla liste pól indeksu tabeli
::   WE: tabela (alias, akronim, numer)
::       numer indeksu
::----------------------------------------------------------------------------------------------------------------------
_Tab:={?_>0
      || {? type_of(_a)=type_of(SYSLOG) || _a
         |? type_of(_a)=type_of('')     || ($_a)()
         |? type_of(_a)=type_of(1)      || ($tab_acr(_a))()
                                        || ~~
         ?}
      || ~~
      ?};
_Ndx:={?_>1
      || {? type_of(_b)=1 || _b
         |? type_of(_b)=2
          & type_of(_Tab) || _Tab.ndx_no(_b)
         ?}
      || 0
      ?};
{? type_of(_Tab) & _Ndx
|| _tpos:=0;

   _tab:=tab_tmp(1
                ,'NDX_NFLD' ,'INTEGER'  ,'Lp.'@
                ,'NDX_AFLD','STRING[8]' ,'Akronim'@
                ,'NDX_JFLD','STRING[9]' ,'Złączenie'@
                ,'NDX_UP'  ,'STRING[1]' ,'Rosn.'@
                );
   {! _ff:=1.._Tab.ndx_nfld(_Ndx)
   |! _tab.NDX_NFLD:=_ff;
      _tab.NDX_AFLD:=_Tab.ndx_afld(_Ndx,_ff);
      _tab.NDX_JFLD:=_Tab.ndx_jfld(_Ndx,_ff);
        _tab.NDX_UP:={? _Tab.ndx_up(_Ndx,_ff) || 'T' || 'N' ?};
      _tab.add(1)
   !};
   _win:=_tab.mk_sel('Pola indeksu %1 tabela: %2'@[_Tab.ndx_acr(_Ndx),_Tab.name()]
                    ,'P',0,'libtabndxflds',5,5
                    );
   _tab.win_sel(_win);
   _tab.win_fld(_win,,'NDX_NFLD',,,3);
   _tab.win_fld(_win,,'NDX_AFLD',,,8);
   _tab.win_fld(_win,,'NDX_JFLD',,,8);
   _tab.win_fld(_win,,'NDX_UP'  ,,,5,,,,,,2,,$'''T''',$'''N''');

   _tab.win_act(_win,,'Kolejność');
   _tab.select();
   1
|| 'Błędny typ argumentów'
?}


\mbTabTriggers
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [2011]
:: OPIS: Wyświetla liste triggerów dla podanej tabeli
::   WE: _a - tabela jako wskazanie lub jako string
::----------------------------------------------------------------------------------------------------------------------
_tab:={? _>0
      || {? type_of(_a)=2               || ($_a)()
         |? type_of(_a)=type_of(SYSLOG) || _a
                                        || ~~
         ?}
      || ~~
      ?};
{? type_of(_tab)
|| _trigger:=_tab.triggers();

   _we:=_trigger.mk_edit('Trigger dla tabeli: '@+_tab.name(1));
   _trigger.win_esep(_we,'Dane podstawowe'@);
   _trigger.win_efld(_we,,'TYPE'   ,,,40,,,'Typ'@,,'Rodzaj wyzwalacza'@);
   _trigger.win_efld(_we,,'ORDER'  ,,,40,,,'Kolejność'@,,'Pole określa kolejność wykonywania wyzwalaczy'@);
   _trigger.win_efld(_we,,'ID'     ,,,40,,,'Identyfikator'@,,'Nazwa wyzwalacza'@);
   _trigger.win_efld(_we,,'MB'     ,,, 3,,,'MacroBUILDER'@,,'Wyzwalacz zdefiniowany w MacroBUILDER-ze',
      'check-box','check_label="%1"' ['Tak, wyzwalacz zdefiniowany pod MacroBUILDER-em'],"'T'","'N'");
   _trigger.win_efld(_we,,'ACTIVE' ,,, 3,,,'Aktywny'@,,'Wyzwalacz jest aktywny',
      'check-box','check_label="%1"' ['Tak, wyzwalacz jest aktywny'],"'T'","'N'");
   _trigger.win_efld(_we,,'FORMULA',,,120,-7,,,,'Pełna treść formuły wyzwalacza'@);
   _trigger.win_edit(_we);

   _size:=_trigger.size();
   _size:={? _size<30 || _size+2 || 30 ?};
   _win:=_trigger.mk_sel('Triggery dla tabeli: '@+_tab.name(1),'P',0,'#trigger',1,1,_size,,'U');
   _trigger.win_fld(_win,,'TYPE'  ,,,14,,,'Typ'@,,'Rodzaj wyzwalacza'@);
   _trigger.win_fld(_win,,'ORDER' ,,, 3,,,'Kolejność'@,,'Pole określa kolejność wykonywania wyzwalaczy'@);
   _trigger.win_fld(_win,,'ID'    ,,,15,,,'Identyfikator'@,,'Nazwa wyzwalacza'@);
   _trigger.win_fld(_win,,'MB'    ,,, 3,,,'MB'@,,'Wyzwalacz zdefiniowany w MacroBUILDER-ze [T/N]'@,2,,"'T'","'N'");
   _trigger.win_fld(_win,,'ACTIVE',,, 3,,,'Aktywny'@,,'Wyzwalacz jest aktywny [T/N]'@,2,,"'T'","'N'");
   _trigger.win_fld(_win,,'FM'    ,,,80,,,'Formuła'@,,'Początkowy fragment formuły wyzwalacza'@);
   _trigger.win_act(_win,,'Wyświetl',,,,"cur_tab(1,1).display()");
   _trigger.win_sel(_win);

   _trigger.select()
?}


\mbTabNames
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Wyswietla pola dla podanej tabeli
::   WE: tabela (alias, akronim, numer)
::----------------------------------------------------------------------------------------------------------------------
_Tab:={?_>0
      || {? type_of(_a)=type_of(SYSLOG) || _a
         |? type_of(_a)=type_of('')     || ($_a)()
         |? type_of(_a)=type_of(1)      || ($tab_acr(_a))()
                                        || ~~
         ?}
      || ~~
      ?};
_tab:=_Tab.names();
_win:=_tab.mk_sel('Maski tabeli'@);
_tab.win_sel(_win);
_tab.win_fld(_win,,'NAME'    ,,, 8,,,'Nazwa'@);
_tab.win_fld(_win,,'SIZE'    ,,,14,,,'rek. w masce'@,,'Liczba rekordów w danej masce'@);
_tab.win_fld(_win,,'DEL_SIZE',,,14,,,'rek. skasow.'@,,'Liczba rekordów skasowana w danej masce'@);
_tab.win_act(_win,,'Kolejność');
{? type_of(_a)=2
|| _tab.win_act(_win,,'Formuła' ,'&Sortuj'@@,,'Odtwarza indeksy w masce.'@
                     ,$("exec('sort_mask','libfml',"+_a+",cur_tab(1,1).NAME)")
               ,,,1,,,'S');
   {? ($(_a+".name(1)*'?'"))(_a)
   ||
      _tab.win_act(_win,,'Formuła' ,'S&elect',,'Wyświetla zawartość maski.'@
                        ,$("exec('select','#table',"+_a+",ask('Czy struktura drzewiasta?'),cur_tab(1,1).NAME)")
                  ,,1,,,,'E')
   ?};
   ~~
?};
_tab.select();
~~


\sort_mask
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Sortuje podaną maskę podanej tabeli
::   WE: _a - alias tabeli
::       _b - maska tabeli
::----------------------------------------------------------------------------------------------------------------------
_Tab:={?_>0
      || {? type_of(_a)=type_of(SYSLOG) || _a
         |? type_of(_a)=type_of('')     || ($_a)()
         |? type_of(_a)=type_of(1)      || ($tab_acr(_a))()
                                        || ~~
         ?}
      || ~~
      ?};
_Mask:=_b;

_Tab.cntx_psh();
_Tab.use(_Mask);
_Tab.sort(1);
_Tab.cntx_pop();
~~


\array_copy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: kopiuje wskazania w obiekcie _src do obiektu _dest
::   WE: DICT _src  - obiekt źródłowy
::       DICT _dest - obiekt docelowy
::       NUMBER [_start] - pozycja początkowa (domyślnie 1)
::       NUMBER [_length] - liczba elementów do przekopiowania (domyślnie większa liczba elementów)
::   WY: 1/0
::UWAGA: brak kontroli typów
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('ObjSrc','ObjDest','StartPos','Length');
_args.ObjSrc:=_a;
_args.ObjDest:=_b;
_args.StartPos:={?_>2 & type_of(_c)=1 || _c || 1 ?};
_args.Length:={?_>3 & type_of(_d)=1 || _d || obj_len(_args.ObjSrc) ?};

_loc:=obj_new('LenSrc','LenDest','MaxPos','StopPos');
_loc.LenSrc:=obj_len(_args.ObjSrc);
_loc.LenDest:=obj_len(_args.ObjDest);
:: ustalamy jaka jest maksymalna współrzedna, do której możemy dojść
_loc.MaxPos:=_loc.LenSrc;
{? _loc.MaxPos>_loc.LenDest || _loc.MaxPos:=_loc.LenDest ?};

:: ustalamy koniec zakresu
_loc.StopPos:={? _args.StartPos<=_loc.MaxPos
              || {? _args.Length>(_loc.MaxPos-_args.StartPos+1) || _loc.MaxPos || _args.StartPos+_args.Length-1 ?}
              ?};
{! _pos:=_args.StartPos.._loc.StopPos |! _args.ObjDest[_pos]:=_args.ObjSrc[_pos] !}


\cContext
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Klasa do pomocy przy kontekstach dużej liczby tabel i zmiennych
::----------------------------------------------------------------------------------------------------------------------
_CL_NAME:='cContext';
_cl_name:=@.Class.get_name(_CL_NAME);
{? var_pres(_cl_name,@.CLASS)<0
||
   obj_decl(_cl_name
   ,obj_meth('psh' ,'Wykonuje cntx_psh() dla kazdego parametru';"{! __:=1.._ |! _[__].cntx_psh() !}")
   ,obj_meth('pop' ,'Wykonuje cntx_pop() dla kazdego parametru';"{! __:=1.._ |! _[__].cntx_pop() !}")
   ,obj_meth('clr' ,'Wykonuje cntx_psh() dla kazdego parametru';"{! __:=1.._ |! _[__].clear()    !}")
   );
   @.Class.setclass(_CL_NAME,_cl_name)
?};
{? var_pres('Cntx')>100 || obj_del(Cntx) ?};
Cntx:=obj_new(@.Class.cContext);
~~


\GetWrongCharsIn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.10]
:: OPIS: Zwraca błędne znaki w podanym tekscie wg podanych
::   WE: STRING _a - badany element
::       STRING _b - prawidłowe znaki
::   WY: STRING nieprawidłowe znaki w badanym elemencie
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_txt_test:=_a;
_txt_patt:=_b;
_txt_err:='';
{!_tt:=1..+_txt_test
|! _char:=(_tt+_txt_test)+1;
   {? _txt_patt*_char=0 || _txt_err+=_char ?}
!};
_txt_err


\bfld
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: odpowiednik bfld() w trig_a
::   WE: _a - uchwyt tabeli
::       _b - akronim pola
::   WY: wartość pola
::UWAGA:Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_fld_fml:=$('_a.'+_b);
_tab.cntx_psh();
_tab.clear();
_result:={? _tab.get() || _fld_fml(_tab) || ~~ ?};
_tab.cntx_pop();
_result


\demo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Zwraca informacje, czy system jest w wersji demonstracyjnej
::   WY: 1 - jeżeli demo, 0 - pełna wersja systemu
::----------------------------------------------------------------------------------------------------------------------
user(8)='0000/00/00' | user(9)='0000/00/00'


\charset
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wyświetla tablice znaków UTF
::----------------------------------------------------------------------------------------------------------------------
_tab:=supp_chr();

_tab1:=sql('
   select
      CODE,
      NAME,
      \' \' as LETTER
   from :_a'
,_tab);

{? _tab1.first()
|| {!
   |?
      _tab1.LETTER:=^_tab1.CODE;
      _tab1.put();
      _tab1.next()
   !}
?};
_wer:=_tab1.mk_sel('Tablica znaków UTF'@,,0,'tablicautf',1,1,,,'U','T');
_tab1.win_fld(_wer,,'CODE',,,,,,'Kod'@);
_tab1.win_fld(_wer,,'NAME',,,50,,,'Nazwa'@);
_tab1.win_fld(_wer,,'LETTER',,,,,,'Znak'@);
_tab1.win_sel(_wer);
_tab1.win_act(_wer,,'Formuła','&Często używane'@@,,,"exec('often_used_chr','libfml')",,1,,,,'C');
_tab1.win_act(_wer,,'Kolejność');
_tab1.win_act(_wer,,'Szukaj');
_tab1.select();
~~


\often_used_chr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wyświetla często używane znaki
::----------------------------------------------------------------------------------------------------------------------
VAR_DEL.delete('__Tab');
__Tab:=tab_tmp(1,
   'CODE','INTEGER','Kod',
   'NAME','STRING[50]','Nazwa',
   'LETTER','STRING[1]','Znak'
);
_add:="__Tab.CODE:=_a; __Tab.NAME:=_b; __Tab.LETTER:=_c; __Tab.add(); ~~";

_add(161,'INVERTED EXCLAMATION MARK','¡');
_add(162,'CENT SIGN','¢');
_add(163,'POUND SIGN','£');
_add(167,'SECTION SIGN','§');
_add(169,'COPYRIGHT SIGN','©');
_add(171,'LEFT-POINTING DOUBLE ANGLE QUOTATION MARK','«');
_add(174,'REGISTERED SIGN','®');
_add(176,'DEGREE SIGN','°');
_add(177,'PLUS-MINUS SIGN','±');
_add(178,'SUPERSCRIPT TWO','²');
_add(179,'SUPERSCRIPT THREE','³');
_add(181,'MICRO SIGN','µ');
_add(185,'SUPERSCRIPT ONE','¹');
_add(187,'RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK','»');
_add(188,'VULGAR FRACTION ONE QUARTER','¼');
_add(189,'VULGAR FRACTION ONE HALF','½');
_add(190,'VULGAR FRACTION THREE QUARTERS','¾');
_add(191,'INVERTED QUESTION MARK','¿');
_add(215,'MULTIPLICATION SIGN','×');
_add(247,'DIVISION SIGN','÷');
_add(8210,'FIGURE DASH','‒');
_add(8211,'EN DASH','–');
_add(8212,'EM DASH','—');
_add(8213,'HORIZONTAL BAR','―');
_add(8220,'LEFT DOUBLE QUOTATION MARK','“');
_add(8221,'RIGHT DOUBLE QUOTATION MARK','”');
_add(8222,'DOUBLE LOW-9 QUOTATION MARK','„');
_add(8223,'DOUBLE HIGH-REVERSED-9 QUOTATION MARK','‟');
_add(8224,'DAGGER','†');
_add(8225,'DOUBLE DAGGER','‡');
_add(8226,'BULLET','•');
_add(8230,'HORIZONTAL ELLIPSIS','…');
_add(8240,'PER MILLE SIGN','‰');
_add(8242,'PRIME','′');
_add(8243,'DOUBLE PRIME','″');
_add(8244,'TRIPLE PRIME','‴');
_add(8252,'DOUBLE EXCLAMATION MARK','‼');
_add(8260,'FRACTION SLASH','⁄');
_add(8304,'SUPERSCRIPT ZERO','⁰');
_add(8364,'EURO SIGN','€');
_add(8470,'NUMERO SIGN','№');
_add(8482,'TRADE MARK SIGN','™');
_add(8592,'LEFTWARDS ARROW','←');
_add(8593,'UPWARDS ARROW','↑');
_add(8594,'RIGHTWARDS ARROW','→');
_add(8595,'DOWNWARDS ARROW','↓');
_add(8596,'LEFT RIGHT ARROW','↔');
_add(8597,'UP DOWN ARROW','↕');
_add(8616,'UP DOWN ARROW WITH BASE','↨');
_add(8721,'N-ARY SUMMATION','∑');
_add(8722,'MINUS SIGN','−');
_add(8725,'DIVISION SLASH','∕');
_add(8729,'BULLET OPERATOR','∙');
_add(8730,'SQUARE ROOT','√');
_add(8734,'INFINITY','∞');
_add(8776,'ALMOST EQUAL TO','≈');
_add(8800,'NOT EQUAL TO','≠');
_add(8804,'LESS-THAN OR EQUAL TO','≤');
_add(8805,'GREATER-THAN OR EQUAL TO','≥');
::9552   BOX DRAWINGS DOUBLE HORIZONTAL   ═
::9553   BOX DRAWINGS DOUBLE VERTICAL   ║
::9554   BOX DRAWINGS DOWN SINGLE AND RIGHT DOUBLE   ╒
::9555   BOX DRAWINGS DOWN DOUBLE AND RIGHT SINGLE   ╓
::9556   BOX DRAWINGS DOUBLE DOWN AND RIGHT   ╔
::9557   BOX DRAWINGS DOWN SINGLE AND LEFT DOUBLE   ╕
::9558   BOX DRAWINGS DOWN DOUBLE AND LEFT SINGLE   ╖
::9559   BOX DRAWINGS DOUBLE DOWN AND LEFT   ╗
::9560   BOX DRAWINGS UP SINGLE AND RIGHT DOUBLE   ╘
::9561   BOX DRAWINGS UP DOUBLE AND RIGHT SINGLE   ╙
::9562   BOX DRAWINGS DOUBLE UP AND RIGHT   ╚
::9563   BOX DRAWINGS UP SINGLE AND LEFT DOUBLE   ╛
::9564   BOX DRAWINGS UP DOUBLE AND LEFT SINGLE   ╜
::9565   BOX DRAWINGS DOUBLE UP AND LEFT   ╝
::9566   BOX DRAWINGS VERTICAL SINGLE AND RIGHT DOUBLE   ╞
::9567   BOX DRAWINGS VERTICAL DOUBLE AND RIGHT SINGLE   ╟
::9568   BOX DRAWINGS DOUBLE VERTICAL AND RIGHT   ╠
::9569   BOX DRAWINGS VERTICAL SINGLE AND LEFT DOUBLE   ╡
::9570   BOX DRAWINGS VERTICAL DOUBLE AND LEFT SINGLE   ╢
::9571   BOX DRAWINGS DOUBLE VERTICAL AND LEFT   ╣
::9572   BOX DRAWINGS DOWN SINGLE AND HORIZONTAL DOUBLE   ╤
::9573   BOX DRAWINGS DOWN DOUBLE AND HORIZONTAL SINGLE   ╥
::9574   BOX DRAWINGS DOUBLE DOWN AND HORIZONTAL   ╦
::9575   BOX DRAWINGS UP SINGLE AND HORIZONTAL DOUBLE   ╧
::9576   BOX DRAWINGS UP DOUBLE AND HORIZONTAL SINGLE   ╨
::9577   BOX DRAWINGS DOUBLE UP AND HORIZONTAL   ╩
::9578   BOX DRAWINGS VERTICAL SINGLE AND HORIZONTAL DOUBLE   ╪
::9579   BOX DRAWINGS VERTICAL DOUBLE AND HORIZONTAL SINGLE   ╫
::9580   BOX DRAWINGS DOUBLE VERTICAL AND HORIZONTAL   ╬
_add(9600,'UPPER HALF BLOCK'         ,'▀');
_add(9604,'LOWER HALF BLOCK'         ,'▄');
_add(9608,'FULL BLOCK'               ,'█');
_add(9609,'LEFT SEVEN EIGHTHS BLOCK' ,'▉');
_add(9610,'LEFT THREE QUARTERS BLOCK','▊');
_add(9611,'LEFT FIVE EIGHTHS BLOCK'  ,'▋');
_add(9612,'LEFT HALF BLOCK'          ,'▌');
_add(9613,'LEFT THREE EIGHTHS BLOCK' ,'▍');
_add(9614,'LEFT ONE QUARTER BLOCK'   ,'▎');
_add(9615,'LEFT ONE EIGHTH BLOCK'    ,'▏');
_add(9616,'RIGHT HALF BLOCK'         ,'▐');
_add(9617,'LIGHT SHADE','░');
_add(9618,'MEDIUM SHADE','▒');
_add(9619,'DARK SHADE','▓');
_add(9632,'BLACK SQUARE','■');
_add(9633,'WHITE SQUARE','□');
_add(9642,'BLACK SMALL SQUARE','▪');
_add(9643,'WHITE SMALL SQUARE','▫');
_add(9644,'BLACK RECTANGLE','▬');
_add(9650,'BLACK UP-POINTING TRIANGLE','▲');
_add(9658,'BLACK RIGHT-POINTING POINTER','►');
_add(9660,'BLACK DOWN-POINTING TRIANGLE','▼');
_add(9668,'BLACK LEFT-POINTING POINTER','◄');
_add(9674,'LOZENGE','◊');
_add(9675,'WHITE CIRCLE','○');
_add(9676,'DOTTED CIRCLE','◌');
_add(9679,'BLACK CIRCLE','●');
_add(9688,'INVERSE BULLET','◘');
_add(9689,'INVERSE WHITE CIRCLE','◙');
_add(9702,'WHITE BULLET','◦');
_add(9786,'WHITE SMILING FACE','☺');
_add(9787,'BLACK SMILING FACE','☻');
_add(9788,'WHITE SUN WITH RAYS','☼');
_add(9792,'FEMALE SIGN','♀');
_add(9794,'MALE SIGN','♂');
_add(9824,'BLACK SPADE SUIT','♠');
_add(9827,'BLACK CLUB SUIT','♣');
_add(9829,'BLACK HEART SUIT','♥');
_add(9830,'BLACK DIAMOND SUIT','♦');
_add(9834,'EIGHTH NOTE','♪');
_add(9835,'BEAMED EIGHTH NOTES','♫');

_wer:=__Tab.mk_sel('Często używane znaki UTF'@,,1,'oftenusedchr',5,5);
__Tab.win_sel(_wer);
__Tab.select();
VAR_DEL.delete('__Tab');
~~


\progress_table
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: tabela wymagane przez progress_text
::   WE:
::   WY:
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_max_pos:=100;
_basnum:=4;
_str_wid:=ceil(_max_pos/_basnum);

_rest:=obj_new(_basnum+1);
_rest[ 1]:=^8212;
_rest[ 2]:='░';
_rest[ 3]:='▒';
_rest[ 4]:='▓';
_rest[ 5]:='█';

_first:=_rest[1];
_last:=_rest[_basnum+1];

_tab:=obj_new(_max_pos+1);
exec('array_blank','#array',_tab,_str_wid*_last);

_base:=_str_wid*_first;
{! _tt:=0.._max_pos
|! _div:=(1.0*_tt)/_basnum;
   _int:=int(_div);
   _frac:=frac(_div)*_basnum;
   _tab[_tt+1]:=_str_wid+(_int*_last+_rest[_frac+1]+_base)
!};
_tab


\progress_text
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: zwraca tekst postępu dla zadanej wartości procentowej
::   WE: NUMBER _a - procent
::   WY: STRING
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_tab:=exec('progress_table','libfml');
{! _tt:=0..98
|! msg('Postęp prac: ['+_tab[_tt+1]+']'
    +'\nPostęp prac: ['+_tab[_tt+2]+']'
    +'\nPostęp prac: ['+_tab[_tt+3]+']'
      ,$_tt)
!}


\file_cmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Porownuje dwa obiekty plikowe tekstowe co do zawartości
::       W przypadku różnicy zwraca fragmenty różniace się, w przypadku jednakowych plików zwraca fragment początkowy
::   WE: _a - FILE
::       _b - FILE
::   WY: [1] - 0/1
::       [2] - fragment tekstu z pierwszego pliku
::       [3] - fragment tekstu z drugiego pliku
::----------------------------------------------------------------------------------------------------------------------
_res:=obj_new(3);
_res[1]:=1;
_res[2]:='';
_res[3]:='';
_first:=1;
{!
|?
   _linia1:=_a.fread();
   _linia2:=_b.fread();
   {? _first
   || _first1:=_linia1;
      _first2:=_linia2;
      _first:=0
   ?};
   {? _linia1<>_linia2
   || _res[1]:=0;
      _res[2]:='...'+_linia1+'...';
      _res[3]:='...'+_linia2+'...';
      return(_res)
   ?};
   _linia1<>'\n'
!};
{? _res[1]=1
|| _res[2]:=_first1+'...';
   _res[3]:=_first2+'...'
?};
_res


\to_file
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: zrzuca do pliku wartości podanych parametrów
::   WE: [_a] - nazwa pliku [$SYSLOG.tm_stamp()]
::       [_b] - dopisywać do pliku? [1-tak]
::       [_c,_d] - _c - co zapisać,
::                 _d - opcja zapisu (dla tabeli [0] - czy zapisać wszystkie rekordy z dziedziny(1), czy tylko bieżący(0)?
::       ...
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_f_name:={? var_pres('_a')=2 || _a || $SYSLOG.tm_stamp() ?}+'.l0g';
_append:={? var_pres('_b')=1 || _b || 1 ?};

_file:=fopen(_f_name,'u'+{?_append || 'a' || 'w' ?}, 1, 0, 1);
{? _file.is_open()
|| _tm_stamp:=19+tm_form(SYSLOG.tm_stamp());
   _file.fwrite('<session start='+_tm_stamp+'>');
   {? _<2 | _%*2
   || _file.fwrite('\t<error> BŁĘDNA LICZBA PARAMETRÓW: '+$_+', a powinna być parzysta i większa od 2.</error>')
   || {! __:=3//2.._
      |!
         {? type_of(_[__])=type_of(SYSLOG)
         ||
            _file.fwrite('\t<var nr='+form(__,-3)+' type=table'+{? _[__+1]=1 || ' param=prefix' || '' ?}+'>');
            _[__].cntx_psh();
            {? _[__+1]=0
            || _file.fwrite('\t\t'+exec('to_string','#convert',_[__],'\t','',''))
            |? _[__].first()
            || {!
               |?
                  _file.fwrite('\t\t'+exec('to_string','#convert',_[__],'\t','',''));
                  _[__].next()
               !}
            ?};
            _[__].cntx_pop();
            _file.fwrite('\t</var>')

         |? type_of(_[__])>100
         || _file.fwrite('\t<var nr='+form(__,-3)+' type=object>');
            _file.fwrite('\t\t'+exec('to_string','#convert',_[__],'\t','',''));
            _file.fwrite('\t</var>')

         || _file.fwrite('\t<var nr='+form(__,-3)+' type=simple>');
            _file.fwrite('\t\t'+exec('to_string','#convert',_[__],'\t','',''));
            _file.fwrite('\t</var>')
         ?}
      !}
   ?};
   _file.fwrite('</session>\n');
   _file.fclose()
?}


\ask4nmemo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30] - wersja rozwijana
:: OPIS: Pyta użytkownika  o wprowadzenie tekstu i jeżeli został wprowadzony, to go zwraca
::   WE: STRING _a - tytuł okienka edycyjnego
::       STRING _b - nazwa pola memo
::       [STRING _?] - kolejne pola memo
::   WY: STRING, gdy tylko jedno pole, tablica[_-1] wartosci pol
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_title:=_a;
_flds_num:=0;
{! __:=2 .. _ |! {? type_of(_[__])=2 || _flds_num+=1 ?} !};
_fld_name:=obj_new(_flds_num);
_fld_acr:=obj_new(_flds_num);
_results:=obj_new(_flds_num);
_flds_num:=0;
{! __:=2 .. _
|! {? type_of(_[__])=2
   || _flds_num+=1;
      _fld_name[_flds_num]:=_[__];
      _fld_acr[_flds_num]:='F'+form(_flds_num,-7,,'9');
      _results[_flds_num]:=''
   ?}
!};
_ftab:="tab_tmp(1,'LP','INTEGER',''";
_fwin:="_tab:=_a; _edit:=_tab.mk_edit('"+_title+"',,,1); _tab.win_edit(_edit)";
{! _ff:=1.._flds_num
|! _ftab+=",'"+_fld_acr[_ff]+"','SYS_MEMO','"+_fld_name[_ff]+"'";
   _fwin+=";\n _tab.win_efld(_edit,,'"+_fld_acr[_ff]+"',,,100,-3)"
!};
_tab:=($(_ftab+')'))();
($(''+_fwin))(_tab);
{? _tab.edit()
|| {! _ff:=1.._flds_num
   |! _results[_ff]:=_tab.memo_txt(,0,_fld_acr[_ff])
   !}
?};
{? _flds_num=1
|| _results[1]
|| _results
?}


\chainget
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca wartość uwzgledniajac łaćcuch złączeń
::   WE: _a - formuła do wykonania
::      [_b] - alias tabeli do zachowania kontekstu
::      ...
::   WY:
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_result:=~~;
{! __:=2.._ |! _[__].cntx_psh() !};
_result:=_a();
{! __:=2.._ |! _[__].cntx_pop() !};
_result


\slash
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca odpowiedni slash
::   WE: ~~
::   WY: [1] - Client
::       [2] - AS
::       [3] - Server
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_slash:=obj_new('client','appserv','server');
_slash.client:={? sys_name(0)='U_LINUX' || '/' || '\\' ?};
_slash.appserv:={?sys_name(1)='U_LINUX' || '/' || '\\' ?};
_slash.server:={? sys_name(2)='U_LINUX' || '/' || '\\' ?};
_slash


\get_formula
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca treść podanej formuły
::   WE: _a  [STRING] - formuła
::       _b  [STRING] - nazwa pliu
::      [_c] [NUMBER] - uwzględniać linie komentarza [domyślnie: 0]
::   WY: STRING treść formuły
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_comment:=var_pres('_c')=type_of(0) & _c;

_mode:="
         _mode:='r';
         _fml:=fopen(_a+'.fml','r',1,0,1);
::       sprawdzam co to za plik
         {? _fml.is_open()
         || _line:=_fml.fread();
            {? _line*':!UTF-8' || _mode:='ur' ?};
            _fml.fclose()
         ?};
         _mode
       ";
_fml:=fopen(_b+'.fml',_mode(_b),1,0,1);
_form_txt:='';
_formula:='\\'+_a;
_formnsiz:=+_formula;
{? _fml.is_open()
|| _line:='\n';
   {!
   |? _line:=_fml.fread();
      _line<>'\n'
      & ( 1+_line<>'\\'
        | ( (_pos:=_line*' '; form(_pos+_line)<>_formula)
          & (_pos:=_line*'\t'; form(_pos+_line)<>_formula)
          & form(_line)<>_formula
          )
        )
   !};
:: mamy juz linijke z \formula
   {? ((_formnsiz+_line)=_formula)
   || {!
      |? _line:=_fml.fread();
         _line<>'\n'
         & (1+_line)<>'\\'
      |!
         {? _comment | (1+_line<>':')
         || _form_txt+=_line+'\n'
         ?}
      !}
   ?};
   _fml.fclose()
?};
form(_form_txt)


\table2tab_tmp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: tworzy zapis przydatny dla stworzenia tabeli tymczasowej z podanej tabeli
::   WE: _a - alias tabeli
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_tab:=exec('mbTabFields_tab','#table',_a);
_size:=0;
_result:="tab_tmp(1";
{? _tab.first()
|| {!
   |?
      _acr:=''''+_tab.FLD_ACR+'''';
      _typ:=''''+{? 1+_tab.FLD_TYPE='_' || 'STRING[16]' || _tab.FLD_TYPE ?}+'''';
      _nam:=''''+_tab.FLD_NAME+'''';
      _result+="\n::      "+form(_tab.FLD_COMM)+{? 1+_tab.FLD_TYPE='_' || ' (oryginalny typ: '+_tab.FLD_TYPE+')' || '' ?};
      _result+="\n       ,"+form(_acr,10)+","+form(_typ,13)+","+form(_nam);
      _tab.next()
   !};
   _size:=_tab.size();
   _size:=_size*2;
   _result+="\n       )"
|| _result:=''
?};
_size+=2;
exec('edit_memo','#edit',_result,,'Propozycja tab_tmp - skopiuj i wklej do formuły',,{? _size<40 || _size || 40 ?});
_result


\table2buffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: tworzy zapis przydatny dla stworzenia bufora podanej tabeli
::   WE:  _a - alias tabeli
::       [_b] - akronim tabeli ['_a']
::       [_c] - pokazywać w okienku? [1]/0
::       [_d] - dodawać komentarze [1]/0
::       [_e] - formuła dodajaca dodatkowe pola (musi przyjmować parametr _a - obiekt bufora)
::       [_f] - czy podana tabelka jest już wynikiem exec('mbTabFields_tab','#table',_a)
::       [_g] - STRING - nazwa pliku w którym znajdzie się formuła bufora
::       [_h] - nowe działanie - powołuje sie na formułę z pliku #buf.fml [0]/1
::   WY: STRING - treść formuły tworzącej bufor
::----------------------------------------------------------------------------------------------------------------------
_Tab:={? var_pres('_b')=2 || _b || _Tab:=exec('tab_acr','#table',_a); {? _Tab<>'' || _Tab || '_a' ?} ?};
_show:={? var_pres('_c')=1 || _c || 1 ?};
_comments:={? var_pres('_d')=1 || _d || 0 ?};
_extra:={? var_pres('_e')>0 || _e || ~~ ?};
_tab_ready:={? var_pres('_f')=1 || _f || 0 ?};
_filename:={? var_pres('_g')=type_of('') || _g || '' ?};
_new_buf:={? var_pres('_h')=type_of(0) || _h || 0 ?};

_tab:={? _tab_ready=1
      || _a
      || exec('mbTabFields_tab','#table',_a,_Tab)
      ?};
_bufname:='_buffer';
_bufspac:=' ';
exec('buffer_prepare','libfml',_tab,_Tab,_bufname,_extra,_filename);

_size:=0;
_result:='';
_tab.clear();
{? _tab.first()
|| {? _new_buf
   || _result:='{? var_pres(\'_a\')=3\r\n';
      _result+='|| _buffer:=exec(\'obj_new\',\'#buf\',\''+_Tab+'\',_a)\r\n';
      _result+='|| _buffer:=exec(\'obj_new\',\'#buf\',\''+_Tab+'\',)\r\n';
      _result+='?};\r\n';
      _result+='_buffer\r\n\r\n'
   || _result:={? _comments || '::               '+_Tab+'.ref()\r\n' || '' ?};
      _result+=_bufname+':=$("obj_new(''Ref''\r\n';
      {!
      |?
         {? _comments
         || _result+=_tab.F_COMMO+'\r\n'
         ?};
::             _bufspac+':=$("obj_new(
         _result+=_bufspac+','''+_tab.FLD_ACR+'''\r\n';
         _tab.next()
      !};
::          _bufspac+':=$("obj_new(
      _result+=_bufspac+'     "+{? var_pres(''_a'')=3 & form(_a)<>\'\' || ","+_a || "" ?}+"\r\n';
      _result+=_bufspac+'     )");\r\n';
      _result+=_bufname+':='+_bufname+'();\r\n\r\n';
      _tab.prefix('m');
      {? _tab.first()
      || _result+=':: metody - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\r\n';
         {!
         |?
            _result+='\r\n'+form(_tab.memo_txt(,1,'M_BODY'))+'\r\n';
            _tab.next()
         !}
      ?};
      _result+={? _comments || ':: czyszczenie bufora\r\n' || '' ?};
      _result+=_bufname+'.bl_void();\r\n\r\n';
      _result+={? _comments || ':: zwracam bufor\r\n' || '' ?};
      _result+=_bufname+'\r\n\r\n';
      ~~
   ?}
|| _result:=''
?};
_size:=40;
{? _show
|| exec('edit_memo','#edit',_result,,'Propozycja _buffer''a - skopiuj i wklej do formuły',,{? _size<40 || _size || 40 ?})
?};
_result


\buffer_prepare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Przygotowuje tabele dla bufora
::   WE: _a - tab_tmp() - tabela z listą pól - wynik exec('mbTabFields_tab','#table')
::       _b - STRING    - akronim tabeli do wykorzystania w metodach
::       _c - STRING    - nazwa zmiennej bufora
::       _d - STRING    - formuła do wykonania po wstępnym przygotowaniu metod standardowych
::       _e - STRING    - nazwa pliku w którym znajdzie się formuła bufora
::   WY: 1-ok / -<nr_bledu> - jeżeli coś nie tak, to po numerze błędu można dojść do przyczyny
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_op:=obj_new('tab','Tab','bufname','bufspac','Lp','addf','addm');
_op.tab:=_a;
_op.Tab:=_b;
_op.bufname:=_c;
_op.bufspac:=' ';
::_op.bufspac:=(+_op.bufname)*' ';
_extra:=_d;
_filename:=_e;

_op.Lp:=_op.tab.size();
_op.addf:="
           .tab.cntx_psh();
           .tab.prefix();
           .tab.blank(1);
           .tab.F_KIND:='f';
           .tab.FLD_POS:=(.Lp+=1);
           .tab.FLD_ACR:=_a;
           .tab.FLD_TYPE:={? var_pres('_b')=2 || _b || '' ?};
           .tab.F_COMMH:={? var_pres('_c')=2 || _c || '' ?};
           .tab.F_COMMO:={? var_pres('_d')=2 || _d || '' ?};
           .tab.add();
           .tab.cntx_pop()
          ";

_op.addm:="
           .tab.cntx_psh();
           .tab.prefix();
           .tab.blank(1);
           .tab.F_KIND:='m';
           .tab.FLD_POS:=(.Lp+=1);
           .tab.FLD_ACR:=_a;
           .tab.FLD_TYPE:='finish';
           .tab.F_COMMH:={? var_pres('_b')=2 || _b || '' ?};
           .tab.F_COMMO:={? var_pres('_c')=2 || _c || '' ?};
           .tab.MBUFSIZE:=(+(.bufname+'.'+.tab.FLD_ACR+':='))*' ';
           .tab.add();
           {? ( var_pres('_d')=2 | var_pres('_d')=3 )
            & form(_d)<>''
           || .tab.memo_set(_d,'M_BODY');
              .tab.memo_put(,'M_BODY')
           ?};
           .tab.cntx_pop()
          ";
{? _op.tab.first()
||
   _tab:=_op.tab;
   _Tab:=_op.Tab;
   _bufname:=_op.bufname;
   _bufspac:=_op.bufspac;

   _tab.prefix('F');

   _sysmemo:=0;
   {? _tab.first()
   || {!
      |? _sysmemo:=_tab.FLD_TYPE='_SYSMEMO';
         _sysmemo=0 & _tab.next()
      !}
   ?};

   {? _tab.first()
   ||
::        _blk:=_bufspac+'.bl_void:="\n';
::        _blv:=_bufspac+'.bl_table:="\n';
::        _akr:=_bufspac+'.acronyms:="\n';
::      _types:=_bufspac+'.types:="\n';
::        _get:=_bufspac+'.get:="\n';
::        _set:=_bufspac+'.set:="\n';
::        _fet:=_bufspac+'.setf:="\n';
::   _cntx_get:=_bufspac+'.cntx_get:="\n';
        _blk:='';
        _blv:='';
        _akr:='';
      _types:='';
        _get:={? _sysmemo
              || _bufspac+'     {? var_pres(\'_a\')=type_of(0) || _database:=_a || _database:=0 ?};\n'
              || ''
              ?};
        _set:='';

       _mask:=_bufspac+'     {? var_pres(\'_a\')>100 || _target:=_a || _target:='+_Tab+' ?};\n\n';

    _voidize:=_bufspac+'     {? exec(\'is_empty_value\',\'#var\',.Ref)>0 || .Ref:=~~ ?};\n';

    _maskSet:=_bufspac+'     _val1:=($(\'_a\'+_b))(_a,_b); _val2:=($_b)();\n'+
              _bufspac+'     {? type_of(_val1)<>type_of(_val2)&type_of(_val1)=2\n'+
              _bufspac+'     || ($(\'_a\'+_b+\':=$\'+_b))(_a,_b)\n'+
              _bufspac+'     || ($(\'_a\'+_b+\':=\'+_b))(_a,_b)\n'+
              _bufspac+'     ?};\n';

        _fet:='';
   _cntx_get:='';

      _index:=1;
      {!
      |?
         _akr+=_bufspac+'     '+'_tab['+$(_index+1)+']:=\''+_tab.FLD_ACR+'\';\n';
         _types+=_bufspac+'     '+'_tab['+$(_index+1)+']:=\''+_tab.FLD_TRAW+'\';\n';
         _acr:='.'+_tab.FLD_ACR;
::             _bufspac+'.bl_void:="
         _blk+=_bufspac+'     '+_acr+':=~~;\n';
::             _bufspac+'.get:="
         {? _tab.FLD_TYPE='_SYSMEMO'
         || _get+=_bufspac+'     '+_acr+':='+_Tab+'.memo_txt(,_database,'''+_tab.FLD_ACR+''');\n'
         || _get+=_bufspac+'     '+_acr+':='+_Tab+_acr+';\n'
         ?};
::             _bufspac+'.set:="
         {? _tab.FLD_TYPE='_SYSMEMO'
         || _set+=_bufspac+'     {? '+form(_acr+'<>~~',15)+' || '+_Tab+'.memo_set('+_acr+','''+_tab.FLD_ACR+''') ?};\n'
         || _set+=_bufspac+'     {? '+form(_acr+'<>~~',15)+' || '+_Tab+_acr+':='+_acr+' ?};\n'
         ?};
         {? _tab.FLD_TYPE='_SYSMEMO'
         || _mask+=_bufspac+'     {? '+form(_acr+'<>~~',15)+' || _target'+'.memo_set('+_acr+','''+_tab.FLD_ACR+''') ?};\n'
         || _mask+=_bufspac+'     {? '+form(_acr+'<>~~',15)+' || .maskSet(_target,\''+_acr+'\') ?};\n'
         ?};

         _voidize+=_bufspac+'     {? exec(\'is_empty_value\',\'#var\','+_acr+')>0 || '+_acr+':=~~ ?};\n';

::             _bufspac+'.setf:="
         {? _tab.FLD_TYPE='_SYSMEMO'
         || _fet+=_bufspac+'     '+_Tab+'.memo_set('+_acr+','''+_tab.FLD_ACR+''');\n'
         || _fet+=_bufspac+'     '+_Tab+_acr+':='+_acr+';\n'
         ?};
         _index+=1;
         _tab.next()
      !};

::      _result+="\n";
::      _result+="\n";
::      _result+="::       REFERENCE ref() - zwraca .Ref";

      _op.addm('blank'
               ,'::            VOID blank() - czyści tablicę buforową'
               ,'::  metoda          czyszczenie bufora blank(), gdy podany parametr ~~, to bl_void()'
::                           .blank:="
               ,   _bufspac+'     {? var_pres(\'_a\')=0   || .bl_void()\n'
                  +_bufspac+'     |? var_pres(\'_a\')>100 || .bl_table(_a)\n'
                  +_bufspac
                  +{? _Tab<>'_a'
                   ||       '     || .bl_table('+_Tab+')\n'
                   ||       '     || 0\n'
                   ?}
                  +_bufspac+'     ?}\n'
               );

      _op.addm('bl_void'
               ,'::          VOID bl_void() - czyści tablicę buforową wartościami pustymi ~~'
               ,'::  metoda          czyszczenie bufora typem pustym bl_void()'
::                          .bl_void:="
               ,  _blk
                 +_bufspac+'     .Ref:=null();\n'
               );
      _op.addm('bl_table'
               ,'::         VOID bl_table() - czyści tablicę buforową za pomocą bufora tabeli'
               ,'::  metoda          czyszczenie bufora za pomocą bufora tabeli bl_table('+{?_Tab='_a'||'alias_tabeli'||''?}+')'
::                _bufspac+'.bl_void:="
               ,  _bufspac+'     _tab:='+_Tab+';\n'
                 +_bufspac+'     _tab.cntx_psh();\n'
                 +_bufspac+'     _tab.blank(1);\n'
                 +_bufspac+'     .get(1);\n'
                 +_bufspac+'     _tab.cntx_pop();\n'
                 +_bufspac+'     _tab.get();\n'
                 +_bufspac+'     .Ref:=null();\n'
               );
      _op.addm('voidize'
               ,'::            VOID voidize() - przypisuje moim polom wartości void (~~) jeżeli pole ma pustą wartość swojego typu'
               ,'::  metoda          '+_bufname+'.voidize('+{?_Tab='_a'||'alias_tabeli'||''?}+') - void dla pustych pól bufora'
               ,_voidize
               );

      _op.addm('get'
               ,'::            THIS get() - pobiera wartości z bufora tabeli do tablicy buforowej - zwraca wskazanie do tablicy buforowej'
               ,'::  metoda          '+_bufname+'.get('+{?_Tab='_a'||'alias_tabeli'||''?}+') - pobieranie zawartości bufora'
::                _bufspac+'.get:="
               ,  _get
                 +_bufspac+'     .Ref:='+{? exec('tab_or_var','#table',_Tab)<>2|| 'null();\n' || _Tab+'.ref();\n' ?}
               );

      _op.addm('set'
               ,'::            VOID set() - wpisuje niepuste wartości z tablicy do bufora tabeli'
               ,'::  metoda          '+_bufname+'.set('+{?_Tab='_a'||'alias_tabeli'||''?}+') - pola<>~~ nanoszone do tabeli'
               ,_set
               );

      _op.addm('mask'
               ,'::            VOID mask() - przypisuje moim polom wartości niepuste z bufora przekazanego jako _a'
               ,'::  metoda          '+_bufname+'.mask('+{?_Tab='_a'||'alias_tabeli'||''?}+') - pola<>~~ nanoszone do bufora'
               ,_mask
               );

      _op.addm('maskSet'
               ,'::            VOID maskSet() - funkcja technicza - wykorzystywana w metodzie mask()'
               ,'::  metoda          '+_bufname+'.maskSet('+{?_Tab='_a'||'alias_tabeli'||''?}+') - pola<>~~ nanoszone do bufora'
               ,_maskSet
               );

      _op.addm('setf'
               ,'::            VOID setf() - wpisuje wszystkie wartości z tablicy do bufora tabeli'
               ,'::  metoda          '+_bufname+'.setf('+{?_Tab='_a'||'alias_tabeli'||''?}+') - wszystkie pola nanoszone do tabeli'
               ,_fet
               );

      _op.addm('cntx_get'
               ,'::            THIS cntx_get(tab/ref/#ref,ref/mask,mask) - jak .get(), ale dla podanego rekordu.'
               ,'::  metoda          '+_bufname+'.cntx_get('+{?_Tab='_a'||'alias_tabeli,'||''?}+'ref()/#ref()[,maska]) - wczytuje bufor wg podanych parametrów'
               ,
::                  _bufspac+'.cntx_get:="
                _cntx_get
               +{? _Tab='_a'
                ||
                    _bufspac+"     _tab:=_a;\n"
                   +_bufspac+"     {? type_of(_b)=7 || _ref:=#_b; _mask:=ref_name(_b)\n"
                   +_bufspac+"     |? type_of(_b)=1 || _ref:=_b;  _mask:={? var_pres('_c')=2 || _c || _tab.name() ?}\n"
                   +_bufspac+"     || .blank(~~); return(.)\n"
                   +_bufspac+"     ?};\n"
                   +{? _sysmemo
                    || _bufspac+"     {? var_pres('_d')=type_of(0) || _database:=_d || _database:=0 ?};\n"
                    || ''
                    ?}
                ||
                    _bufspac+"     _tab:="+_Tab+";\n"
                   +_bufspac+"     {? type_of(_a)=7 || _ref:=#_a; _mask:=ref_name(_a)\n"
                   +_bufspac+"     |? type_of(_a)=1 || _ref:=_a;  _mask:={? var_pres('_b')=2 || _b || _tab.name() ?}\n"
                   +_bufspac+"     || .blank(~~); return(.)\n"
                   +_bufspac+"     ?};\n"
                   +{? _sysmemo
                    || _bufspac+"     {? var_pres('_c')=type_of(0) || _database:=_c || _database:=0 ?};\n"
                    || ''
                    ?}
                ?}
                   +_bufspac+"     _tab.cntx_psh();\n"
                   +_bufspac+"     {? {? _tab.name()<>_mask\n"
                   +_bufspac+"        || _tab.use(_mask)\n"
                   +_bufspac+"        || 1\n"
                   +_bufspac+"        ?}\n"
                   +_bufspac+"     || _tab.prefix();\n"
                   +_bufspac+"        {? _tab.seek(_ref,)\n"
                   +{? _sysmemo
                    || _bufspac+"        || .get(_database)\n"
                    || _bufspac+"        || .get()\n"
                    ?}
                   +_bufspac+"        || .blank(~~)\n"
                   +_bufspac+"        ?}\n"
                   +_bufspac+"     || .blank(~~)\n"
                   +_bufspac+"     ?};\n"
                   +_bufspac+"     _tab.cntx_pop();\n"
               );

      _op.addm('ref'
               ,'::       REFERENCE ref() - zwraca .Ref'
               ,'::  metoda          '+_bufname+'.ref() - zwraca wartosc .Ref'
               ,_bufname+'.ref:=".Ref";'
               );

      _op.addm('name'
               ,'::       STRING name() - zwraca akronim tabeli której dotyczy bufor'
               ,'::  metoda          '+_bufname+'.name() - zwraca akronim tabeli której dotyczy bufor'
               ,_bufname+'.name:="\''+_Tab+'\'";'
               );

      _op.addm('this'
               ,'::       STRING this() - zwraca formułę która utworzy ten bufor'
               ,'::  metoda          '+_bufname+'.this() - zwraca formułę która utworzy ten bufor'
               ,_bufname+'.this:="exec(\''+_Tab+'\',\''+gsub(_filename,'.fml','')+'\')";'
               );

      _op.addm('acronyms'
               ,'::          VOID acronyms() - zwraca tablicę z akronimami pól bufora ~~'
               ,'::  metoda          pobiera tablicę z akronimami pól bufora. Uwaga! Pierwszym elementem jest Ref'
::                          .bl_void:="
               , _bufspac+'     _tab:=obj_new('+$(_tab.size()+1)+');\n'
                 +_bufspac+'     _tab[1]:=\'Ref\';\n'
                 +_akr
               );
      _op.addm('types'
               ,'::          VOID acronyms() - zwraca tablicę z typami pól bufora ~~'
               ,'::  metoda          pobiera tablicę z typami pól bufora. Uwaga! Pierwszym elementem jest STRING - SQL ref rekordu reprezentowanego przez bufor'
::                          .bl_void:="
               , _bufspac+'     _tab:=obj_new('+$(_tab.size()+1)+');\n'
                 +_bufspac+'     _tab[1]:=\'_'+_Tab+'\';\n'
                 +_types
               );
      ~~
   ?};
   {? type_of(_extra)=3
   || _extra(_op)
   ?};
   _tab.prefix('m');
   {? _tab.first()
   ||
      {!
      |?
         {? _tab.FLD_TYPE='finish'
         ||
::            _before:=(+(_bufname+'.'+_tab.FLD_ACR+':='))*' ';
            _before:='      ';
            {? _tab.FLD_ACR='blank'
            || _tab.memo_set(_bufname+'.'+_tab.FLD_ACR+':="\n'
                            +_tab.memo_txt(,1,'M_BODY')
                            +_before+'";'
                            ,'M_BODY'
                            );
               _tab.memo_put(,'M_BODY')

            |? _tab.FLD_ACR='bl_void'
            || _tab.memo_set(_bufname+'.'+_tab.FLD_ACR+':="\n'
                            +_tab.memo_txt(,1,'M_BODY')
                            +_before+'1\n'
                            +_before+'";'
                            ,'M_BODY'
                            );
               _tab.memo_put(,'M_BODY')
            |? _tab.FLD_ACR='acronyms'
            || _tab.memo_set(_bufname+'.'+_tab.FLD_ACR+':="\n'
                            +_tab.memo_txt(,1,'M_BODY')
                            +_before+'_tab\n'
                            +_before+'";'
                            ,'M_BODY'
                            );
               _tab.memo_put(,'M_BODY')
            |? _tab.FLD_ACR='types'
            || _tab.memo_set(_bufname+'.'+_tab.FLD_ACR+':="\n'
                            +_tab.memo_txt(,1,'M_BODY')
                            +_before+'_tab\n'
                            +_before+'";'
                            ,'M_BODY'
                            );
               _tab.memo_put(,'M_BODY')
            |? _tab.FLD_ACR='bl_table'
            || _tab.memo_set(_bufname+'.'+_tab.FLD_ACR+':="\n'
                            +_tab.memo_txt(,1,'M_BODY')
                            +_before+'1\n'
                            +_before+'";'
                            ,'M_BODY'
                            );
               _tab.memo_put(,'M_BODY')

            |? _tab.FLD_ACR='get'
            || _tab.memo_set(_bufname+'.'+_tab.FLD_ACR+':="\n'
                            +_tab.memo_txt(,1,'M_BODY')
                            +_before+'(.)\n'
                            +_before+'";'
                            ,'M_BODY'
                            );
               _tab.memo_put(,'M_BODY')

            |? _tab.FLD_ACR='set'
            || _tab.memo_set(_bufname+'.'+_tab.FLD_ACR+':="\n'
                            +_tab.memo_txt(,1,'M_BODY')
                            +_before+'~~\n'
                            +_before+'";'
                            ,'M_BODY'
                            );
               _tab.memo_put(,'M_BODY')

            |? _tab.FLD_ACR='mask'
            || _tab.memo_set(_bufname+'.'+_tab.FLD_ACR+':="\n'
                            +_tab.memo_txt(,1,'M_BODY')
                            +_before+'~~\n'
                            +_before+'";'
                            ,'M_BODY'
                            );
               _tab.memo_put(,'M_BODY')

            |? _tab.FLD_ACR='maskSet'
            || _tab.memo_set(_bufname+'.'+_tab.FLD_ACR+':="\n'
                            +_tab.memo_txt(,1,'M_BODY')
                            +_before+'~~\n'
                            +_before+'";'
                            ,'M_BODY'
                            );
               _tab.memo_put(,'M_BODY')

            |? _tab.FLD_ACR='voidize'
            || _tab.memo_set(_bufname+'.'+_tab.FLD_ACR+':="\n'
                            +_tab.memo_txt(,1,'M_BODY')
                            +_before+'~~\n'
                            +_before+'";'
                            ,'M_BODY'
                            );
               _tab.memo_put(,'M_BODY')

            |? _tab.FLD_ACR='setf'
            || _tab.memo_set(_bufname+'.'+_tab.FLD_ACR+':="\n'
                            +_tab.memo_txt(,1,'M_BODY')
                            +_before+'~~\n'
                            +_before+'";'
                            ,'M_BODY'
                            );
               _tab.memo_put(,'M_BODY')

            |? _tab.FLD_ACR='cntx_get'
            || _tab.memo_set(_bufname+'.'+_tab.FLD_ACR+':="\n'
                            +_tab.memo_txt(,1,'M_BODY')
                            +_before+'(.)\n'
                            +_before+'";'
                            ,'M_BODY'
                            );
               _tab.memo_put(,'M_BODY')

            ?}
         ?};
         _tab.next()
      !}
   ?}
?}


\table2fml_comm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: tworzy zapis przydatny do wstawienia jako komentarz do formuły
::   WE: _a - alias tabeli
::       _b - pokazywac w okienku? [1]/0
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_show:={? var_pres('_b')=1 || _b || 1 ?};

_size:=0;
_result:='';
_tab.cntx_psh();
{? _tab.first()
|| {!
   |?
::              ::   WY:
      _result+="::       "+form(_tab.FLD_TYPE,-12)+' '+form(_tab.FLD_ACR,-8)+' - '+_tab.FLD_NAME+'\n';
      _tab.next()
   !};
   _size:=_tab.size();
   _size:=_size*2;
   ~~
|| _result:=''
?};
_tab.cntx_pop();
_size+=2;
{? _show
|| exec('edit_memo','#edit',_result,,'Propozycja komentarza do wyjścia - skopiuj i wklej do formuły',,{? _size<40 || _size || 40 ?})
?};
_result


\table2bufmlcomp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Tworzy zapis pełnej formuły buforowej
::   WE:  _a - alias tabeli
::       [_b] - akronim tabeli ['_a']
::       [_c] - pokazywać w okienku? [1]/0
::       [_d] - nazwa formuły ['buffer']
::       [_e] - kto utworzył ['']
::       [_f] - wersja ['']
::       [_g] - dodatkowe pola obiektu np. "'Pole1','Pole2'" ['']
::       [_h] - STRING - nazwa pliku w którym znajdzie się formuła bufora
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_Tab:={? var_pres('_b')=2 || _b || _Tab:=exec('tab_acr','#table',_tab); {? _Tab<>'' || _Tab || '_a' ?} ?};
_show:={? var_pres('_c')=1 || _c || 1 ?};
_f_naz:={? var_pres('_d')=2 || _d || 'buffer' ?};
_f_utw:={? var_pres('_e')=2 || _e || '' ?};
_f_wer:={? var_pres('_f')=2 || _f || '' ?};
_extra:={? var_pres('_g')=3 || _g || ~~ ?};
_filename:={? var_pres('_h')=type_of('') || _h || '' ?};

_tabelka:=exec('mbTabFields_tab','#table',_tab,_Tab);
_fml_body:=exec('table2buffer','libfml',_tabelka,_Tab,0,,_extra,1,_filename,1);

_result:=
'\\'+_f_naz
+'\r\n'+'::----------------------------------------------------------------------------------------------------------------------'
+'\r\n'+'::  UTW: '+_f_utw+{? _f_wer<>'' || ' ['+_f_wer+']' || '' ?}
+'\r\n'+':: OPIS: bufor tabeli '+_Tab
+'\r\n'+'::   WE: [_a] FORMULA - dodatkowe pola do obiektu - umieszczane na końcu - nie obsługiwane przez standardowe metody [""]'
+'\r\n'+'::   WY: obj_new'
+'\r\n'+'::----------------------------------------------------------------------------------------------------------------------'
+'\r\n'+_fml_body
+'';
{? _show
|| exec('edit_memo','#edit',_result,,'Propozycja _buffer''a - skopiuj i wklej do formuły',140,40)
?};
_result


\str2tm_stamp
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca tm_stamp z argumentu typu STRING
::   WE: _a - STRING w formacie 'YYYY/MM/DD HH:MM:SS'
::   WY: REAL - tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_str:=_a;
_result:=0;
{? _str<>''
|| _result:=tm_stamp(#(4+_str),
                     #(2+(5-_str)),
                     #(2+(8-_str)),
                     #(2+(11-_str)),
                     #(2+(14-_str)),
                     #(_str+2),
                     0)
?};
_result


\integer_max
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: zwraca maksymalna wartość INTEGER'a
::   WY:
::----------------------------------------------------------------------------------------------------------------------
2147483647


\integer_min
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: zwraca minimalna wartość INTEGER'a
::   WY:
::----------------------------------------------------------------------------------------------------------------------
-2147483648


\UID_generator
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Generuje UID na podstawie tm_stamp
::   WY: UID
::----------------------------------------------------------------------------------------------------------------------
$SYSLOG.tm_stamp()


\ses_id
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Blank ses_id()
::   WY: SYSLOG.sys_id()
::----------------------------------------------------------------------------------------------------------------------
SYSLOG.ses_id()


\frames
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca tablice podwójnych ramek
::----------------------------------------------------------------------------------------------------------------------
_frames:=obj_new('TL','TC','TR'
                ,'ML','MC','MR'
                ,'BL','BC','BR'
                );
_frames.TL:=^9600;
_frames.TC:=^9600;
_frames.TR:=' ';
_frames.ML:=' ';
_frames.MC:=' ';
_frames.MR:=' ';
_frames.BL:=^9604;
_frames.BC:=^9604;
_frames.BR:=' ';
_frames


\frame_it
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Okłada ramką podany tekst
::   WE: _tekst
::   WY: obramowany tekst
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_txts:=spli_str(_a,'\n');
_frames:={? var_pres('_b')>100 || _b || exec('frames','libfml') ?};
_mx_len:=0;
{! _ll:=1..obj_len(_txts) |! {? +_txts[_ll]>_mx_len || _mx_len:=+_txts[_ll] ?} !};
_result:=_frames.TL+(_mx_len*_frames.TC)+_frames.TR+'\n';
{! _ll:=1..obj_len(_txts)
|! _result+=_frames.ML+_mx_len+(_txts[_ll]+(_mx_len*' '))+_frames.MR+'\n'
!};
_result+=_frames.BL+(_mx_len*_frames.BC)+_frames.BR+'\n';
_result


\sel_fml
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Wyświetla listę plików z formułami
::   WE: [_a] - maska pliku
::----------------------------------------------------------------------------------------------------------------------
_mask:={? var_pres('_a')=2 || _a || '*' ?};
_files:=files(_mask+'.fml');
_win:=_files.mk_sel('Lista plików z formułami'@,'P',1,,1,1,,,'U','T');
_files.win_sel(_win);
_var_name:=exec('uniqvarname','#var','libfml');
($(_var_name+':=""'))();
_ff:=$(_var_name+":=_result:=exec('sel_fmls','libfml',cur_tab(1,1).FILENAME);{? _result<>'' || sel_exit() ?}");
_files.win_act(_win,,'Formuła','&Formuły'@@,,,_ff,,1,,,,'F');
_files.win_act(_win,,'Wyświetl','Txt_view',,,"txt_view(cur_tab.FILENAME,1)");
:: Ze względu na niejasności w obsłudze warstw i brak wsparcia technologicznego Edycja zostaje wyłączona (do odwołania).
::_files.win_act(_win,,'Formuła','Txt_&edit'@@,,,"{? FUN.ask('Czy edytować plik?'@) || txt_edit(cur_tab.FILENAME,1) ?}"
::                   ,,,,,,'E');
_files.select();
_result:=($_var_name)();
($('&'+_var_name))();
{? _result<>''
 & var_pres('expr',@.DEFINE)>0
|| DEFINE.expr:=_result
?};
_result


\sel_fmls
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Wyświetla listę formuł w podanym pliku
::   WE: _a - nazwa pliku
::----------------------------------------------------------------------------------------------------------------------
_mode:='ur';
_fname:=_a;
_pos:=_fname*'.c.fml';
{? _pos=0 || _pos:=_fname*'.m.fml' ?};
{? _pos=0 || _pos:=_fname*'.fml' ?};
_fnwoext:=(_pos-1)+_fname;
_result:='';
_file:=fopen(_fname,_mode,1,1,1,1);
{? _file.is_open()
|| _line:=fread(_file);
   {? _line<>':!UTF-8'
   || _mode:='r'
   ?};
   fclose(_file)
|| _mode:=''
?};
obj_del(_file);
{? _mode<>''
||
   _file:=fopen(_fname,_mode,1,1,1,1);
   {? _file.is_open
   ||
      _tab:=tab_tmp(1
                   ,'FML','STRING[31]' ,'Formuła'@
                   ,'DESC','SYS_MEMO'  ,'Opis'@
                   ,'PARAMS','SYS_MEMO','Parametry'@
                   ,'RESULT','SYS_MEMO','Wynik'@
                   ,'EXEC'  ,'STRING[255]','Wykonaj'
                   );
      _cur_state:='FORMULA';

      _val:=obj_new('desc','params','result');
      _val.desc:='';
      _val.params:='';
      _val.result:='';

      {!
      |? _line:=_file.fread();
         _line<>'\n'
      |!

         {? 1+_line='\\'
         ||
            _line:=1-_line;
            {? (_pos:=_line*' '; _pos>0)
             | (_pos:=_line*'\t';_pos>0)
             | (_pos:=+_line;    _pos>0)
            || _line:=form(_pos+_line)
            ?};
            {? _line<>''
            || _cur_state:='FORM_NAME';
               _tab.blank(1);
               _tab.FML:=_line;
               _tab.EXEC:="exec('"+_tab.FML+"','"+(-_fnwoext)+"'";
               _val.desc:='';
               _val.params:='';
               _val.result:='';
               _tab.add()
            ?}

         |? _cur_state<>'FORMULA'
         || {? 2+_line='::'
            || _line:=2-_line;

               {? (_pos:=_line*'OPIS:';_pos>0 & _pos<8) || _cur_state:='DESC';   _pos:=_line*':'; _val.desc:=form(_pos-_line)
               |? (_pos:=_line*'WE:';  _pos>0 & _pos<8) || _cur_state:='PARAMS'; _pos:=_line*':'; _val.params:=form(_pos-_line)
               |? (_pos:=_line*'WY:';  _pos>0 & _pos<8) || _cur_state:='RESULT'; _pos:=_line*':'; _val.result:=form(_pos-_line)
               |? 5+_line='-----'     || ''
               |? _cur_state='DESC'   || _val.desc+='\n'+form(_line)
               |? _cur_state='PARAMS' || _val.params+='\n'+form(_line)
               |? _cur_state='RESULT' || _val.result+='\n'+form(_line)
               ?}

            |? form(_line)<>''
            || _cur_state:='FORMULA';
               _tab.memo_set(_val.desc,'DESC');    _tab.memo_put(,'DESC');
               _tab.memo_set(_val.params,'PARAMS');_tab.memo_put(,'PARAMS');
               _tab.memo_set(_val.result,'RESULT');_tab.memo_put(,'RESULT');
               ~~
            ?}
         ?}
      !};
      _file.fclose();
      _win:=_tab.mk_sel('Formuły pliku: %1'@[_fname],,,,,1,,,'U','T');
      _tab.win_sel(_win);
      _tab.win_fld(_win,,'FML');
      _tab.win_fld(_win,,'DESC',,,30);
      _tab.win_act(_win,,'Formuła','&Wykonaj'@@,,,"sel_exit()",,1,,,,'W');

      _red:=_tab.mk_edit('Formuła'@);
      _tab.win_edit(_red);
      _tab.win_efld(_red,,'FML');
      _tab.win_efld(_red,,'DESC',,,100,-15);
      _tab.win_efld(_red,,'PARAMS',,,100,-10);
      _tab.win_efld(_red,,'RESULT',,,100,-5);

      {? _tab.select()
      || _result:=_tab.EXEC
      ?}
   ?}
?};
_result


\sel_prc
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Wyswietla liste plików z procedurami
::   WE: [_a] - maska pliku
::----------------------------------------------------------------------------------------------------------------------
_mask:={? var_pres('_a')=2 || _a || '*' ?};
_files:=files(_mask+'.prc');
_win:=_files.mk_sel('Lista plików z procedurami'@,'P',1,,1,1);
_files.win_sel(_win);
_var_name:=exec('uniqvarname','#var','libfml');
($(_var_name+':=""'))();
_ff:=$(_var_name+":=_result:=exec('sel_prcs','libfml',cur_tab(1,1).FILENAME);{? _result<>'' || sel_exit() ?}");
_files.win_act(_win,,'Formuła','&Procedury'@@,,,_ff,,1,,,,'P');
_files.select();
_result:=($_var_name)();
($('&'+_var_name))();
{? _result<>''
 & var_pres('expr',@.DEFINE)>0
|| DEFINE.expr:=_result
?};
_result


\sel_prcs
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Wyświetla listę formuł w podanym pliku
::   WE: _a - nazwa pliku
::----------------------------------------------------------------------------------------------------------------------
_mode:='ur';
_fname:=_a;
_pos:=_fname*'.c.prc';
{? _pos=0 || _pos:=_fname*'.m.fml' ?};
{? _pos=0 || _pos:=_fname*'.prc' ?};
_fnwoext:=(_pos-1)+_fname;
_result:='';
_file:=fopen(_fname,_mode,1,1,1,1);
{? _file.is_open()
|| _line:=fread(_file);
   {? _line<>':!UTF-8'
   || _mode:='r'
   ?};
   fclose(_file)
|| _mode:=''
?};
obj_del(_file);
{? _mode<>''
||
   _file:=fopen(_fname,_mode,1,1,1,1);
   {? _file.is_open
   ||
      _tab:=tab_tmp(1
                   ,'FML','STRING[15]' ,'Procedury'@
                   ,'DESC','SYS_MEMO'  ,'Opis'@
                   ,'PARAMS','SYS_MEMO','Parametry'@
                   ,'RESULT','SYS_MEMO','Wynik'@
                   ,'EXEC'  ,'STRING[255]','Wykonaj'
                   );
      _cur_state:='FORMULA';

      _val:=obj_new('desc','params','result');
      _val.desc:='';
      _val.params:='';
      _val.result:='';

      {!
      |? _line:=_file.fread();
         _line<>'\n'
      |!

         {? 4+_line='proc'
         ||
            _line:=form(4-_line);
            {? (_pos:=_line*' '; _pos>0)
             | (_pos:=_line*'\t';_pos>0)
             | (_pos:=+_line;    _pos>0)
            || _line:=form(_pos+_line)
            ?};
            {? _line<>''
            || _cur_state:='FORM_NAME';
               _tab.blank(1);
               _tab.FML:=_line;
               _tab.EXEC:="proc_exe('"+_tab.FML+"'@'"+(-_fnwoext)+"'";
               _val.desc:='';
               _val.params:='';
               _val.result:='';
               _tab.add()
            ?}

         |? _cur_state<>'FORMULA'
         || {? 2+_line='::'
            || _line:=2-_line;

               {? (_pos:=_line*'OPIS:';_pos>0 & _pos<8) || _cur_state:='DESC';   _pos:=_line*':'; _val.desc:=form(_pos-_line)
               |? (_pos:=_line*'WE:';  _pos>0 & _pos<8) || _cur_state:='PARAMS'; _pos:=_line*':'; _val.params:=form(_pos-_line)
               |? (_pos:=_line*'WY:';  _pos>0 & _pos<8) || _cur_state:='RESULT'; _pos:=_line*':'; _val.result:=form(_pos-_line)
               |? 5+_line='-----'     || ''
               |? _cur_state='DESC'   || _val.desc+='\n'+form(2-_line)
               |? _cur_state='PARAMS' || _val.params+='\n'+form(2-_line)
               |? _cur_state='RESULT' || _val.result+='\n'+form(2-_line)
               ?}

            |? form(_line)<>''
            || _cur_state:='FORMULA';
               _tab.memo_set(_val.desc,'DESC');    _tab.memo_put(,'DESC');
               _tab.memo_set(_val.params,'PARAMS');_tab.memo_put(,'PARAMS');
               _tab.memo_set(_val.result,'RESULT');_tab.memo_put(,'RESULT');
               ~~
            ?}
         ?}
      !};
      _file.fclose();
      _win:=_tab.mk_sel('Procedury pliku: %1'@[_fname],,,,,1);
      _tab.win_sel(_win);
      _tab.win_fld(_win,,'FML');
      _tab.win_fld(_win,,'DESC',,,30);
      _tab.win_act(_win,,'Formuła','&Wykonaj'@@,,,"sel_exit()",,1,,,,'W');

      _red:=_tab.mk_edit('Formuła'@);
      _tab.win_edit(_red);
      _tab.win_efld(_red,,'FML');
      _tab.win_efld(_red,,'DESC',,,100,-15);
      _tab.win_efld(_red,,'PARAMS',,,100,-10);
      _tab.win_efld(_red,,'RESULT',,,100,-5);

      {? _tab.select()
      || _result:=_tab.EXEC
      ?}
   ?}
?};
_result


\move_tree
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR & jerry [12.30]
:: OPIS: Przenosi elementy podrzędne wskazanego elementu do jego rodzica
::   WE: TABLE   _a  - tabela
::       STRING  _b  - akronim pola TREE_REF
::       STRING [_c] - akronim indeksu, w którym pierwsze pole jest _b, [ tworzony własny indeks tymczasowy ]
::       INTEGER _d - wskazanie na węzeł z którego przenosimy elementy podrzedne
::   WY: 1-ok / 0 - nie udało sie przenieść wszystkich elementów podrzędnych
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_tree:=obj_new('tab','move','parent');
_tree.tab:=_a;
_fld:=_b;
_ndx:={? var_pres('_c')=2 || _c || '' ?};
_parent:=_d;
_trans:=(do_state()=0);
{?_trans || do ?};

_tree.move:=$("
                .tab.cntx_psh();
                .tab.prefix(_a);
                _result:=1;
                {? .tab.first()
                ||
                   {!
                   |?
                      .tab.cntx_psh();
                      .tab."+_fld+":=_b;
                      .tab.prefix();
                      _result*=.tab.put();
                      .tab.cntx_pop();
                      .tab.first()
                   !}
                || 1
                ?};
                .tab.cntx_pop();
                _result
                  ");
_tree.parent:=$(".tab."+_fld);

_result:=1;
_tree.tab.cntx_psh();
_ndx_drop:=0;
{? _ndx='' || _ndx_drop:=1; _ndx:=_tree.tab.ndx_tmp(,,_fld,,) ?};
_tree.tab.index(_ndx);
{? _tree.tab.seek(_parent,)
|| _new_par:=_tree.parent();
   {? ~(_result:=_tree.move(_parent,_new_par))
   || undo()
   ?};
   {? _trans || end() ?}
?};
_tree.tab.cntx_pop();
{? _ndx_drop || _tree.tab.ndx_drop(_ndx) ?};
_result


\UniqFldValues
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Wyświetla unikalne wartości dla podanego pola w tabeli
::   WE: ALIAS _a - tabela
::       STRING _b - akrnim pola
::----------------------------------------------------------------------------------------------------------------------
exec('select','#table'
    ,sql("select "+_b+", count("+_b+") from @:_a group by "+_b,_a)
    )


\tab_tmp_vfn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Tworzy tabele tymczasowa ze zmienną liczbą początkowych pól na podstawie podanych parametrów
::   WE: _a - liczba pól iterowanych
::       _b - typ pola iterowanego
::       _c - prefiks nazwy pola iterowanego
::       [_d] - kolejne pola do doklejenia o konstrukcji: ",'FLD_ACR','TYPE','Nazwa'"
::       ...
::   WY: formuła do utworzenia tabeli tymczasowej z ustawionym domyślnie indeksem na pierwsze pole
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_tab_tmp:="tab_tmp(1";
{! _fi:=1.._a |! _tab_tmp+="\n,'FLD"+form(_fi,-5,,'99')+"','"+_b+"','"+_c+form(_fi)+"'" !};
{! __:=4.._   |! _tab_tmp+="\n"+_[__] !};
$(_tab_tmp+')')


\tab_tmp_vfn_tst
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Test exec('tab_tmp_test','libfml')
::----------------------------------------------------------------------------------------------------------------------
_tab_tmp:=exec('tab_tmp_vfn','libfml'
              ,10,'STRING[16]','Obiekt '
              ,",'DATE','DATE','Data'"
              ,",'TIME','TIME','Godzina'"
              ,",'INT' ,'INTEGER','Liczba'"
              );
_tab:=_tab_tmp();
_tab[1]:='test';
_tab[2]:='test2';
_tab.DATE:=date(0,0,0);
exec('to_string','#convert',_tab)


\randomask
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Tablica do losowego pytania o...
::   WE: _a - liczba pytań w obiekcie
::   WY: 1/0
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_size:=_a;

_arr:=obj_new('questions','answers','size','build','qadd','ask','ask_fml');
_arr.build:=".size:=_a; .questions:=obj_new(.size); .answers:=obj_new(.size);~~";
_arr.qadd:=".questions[_a]:=_b; .answers[_a]:=_c;1";

_arr.ask_fml:="FUN.ask(_a)";
_arr.ask:="_num:=_a;
   _res:=1;
   _bylo:=',';
   _pos:=1;
   {!
   |?
      {? _bylo*(','+$_pos+',')=0
      || _bylo+=($_pos+',');
         _res*=.ask_fml(.questions[_pos])=.answers[_pos];
         _num-=1
      ?};
      _pos:=int(rand()*.size)+1;
      _num>0 & _res=1
   !};
   _res
";
_arr.build(_size);
_arr


\getFldPos
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Zwraca pozycję podanego akronimu w podanej tabeli
::   WE: _tab - alias tabeli
::       _acr = akronim pola
::   WY: pozycja akronimu
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_acr:=_b;
_pos:=0;
{! _ff:=1.._tab.fld_num()
|? {? _tab.fld_acr(_ff)=_acr || _pos:=_ff; 0 || 1 ?}
!};
_pos


\freefreerec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Kasuje rekordy z podanej tabeli, które nie mają powiązań
::   WE: TABLE   _a  - wskazanie na tabelę
::       NUMBER [_b] - bieżąca dziedzina? [1]-tak, 0-nie
::       STRING [_c] - akronim pola TREE_REF, jezeli róźne od '', to stosuję del_tree_branch
::   WY: liczba pozostałych rekordów / -<nr_bledu> - jeżeli coś nie tak, to po numerze bledu mozna dojść do przyczyny
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_cntx:={? var_pres('_b')=1 || _b || 1 ?};
_tree_fld:={? var_pres('_c')=2 || _c || '' ?};
{? _cntx=0 || _tab.clear() ?};
{? _tab.first()
||
   {? _tree_fld<>''
   ||
      {!
      |?
         {? _tab.count()=0
          & exec('del_tree_branch','#tree',_tab,_tree_fld,,#_tab.ref(),"{? .tab.count()=0 || .tab.del() ?}")
         || _tab.del()
         || _tab.next()
         ?}
      !}
   ||
      {!
      |?
         {? _tab.count()=0
         || _tab.del()
         || _tab.next()
         ?}
      !}
   ?};
   _tab.size()
|| 0
?}


\del_sel_rec
::----------------------------------------------------------------------------------------------------------------------
::  UTW: jerry [12.30]
:: OPIS: Kasuje zaznaczone rekordy dla podanej tabeli
::   WE: TABLE _a - wskazanie na tabele
::       TABLE [_b] - tabela zaznaczonych rekordow
::   WY: 1-ok / -<nr_bledu> - jeżeli cos nie tak, to po numerze błędu można dojść do przyczyny
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpic błąd.
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_sel:={? var_pres('_b')>100 || _b || _tab.sel_aget() ?};
{? _sel.first()
|| {!
   |?
      {? _tab.seek(_sel.REF,)
      || _tab.del()
      ?};
      _sel.next()
   !}
?}


\getTreeFld4Tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja sprawdza czy w tabeli jest pole typu tree_ref i zwraca je
::   WE: _a - [TABLE] - tabela do sprawdzenia
::   WY: '' lub nazwa pola tree_ref
::----------------------------------------------------------------------------------------------------------------------
_tab:={? var_pres('_a')=type_of(SYSLOG) || _a || return('') ?};
_treeFld:='';
{! _ff:=1.._tab.fld_num()
|! {? var_pres(_tab.fld_acr(_ff),_tab)=32
   || _treeFld:=_tab.fld_acr(_ff)
   ?}
!};
_treeFld


\dnd_grp_clear
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja do usuwania sposród rekordów przenoszonych grupowo, rekordow podrezdnych.
::   WE: _a - [TABLE] - tabela z zaznaczonymi grupowo rekordami (dnd_info('dropped_records'))
::       _b - [STRING] - maska
::       _c - [TABLE] - tabela źródłowa
::       _d - [STRING] - nazwa pola z tree refem
::   WY: tabela _a po usunieciu rekordów podrzędnych
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new('tabDnD','tabSrc','mask','tree','isInDnD');
_obj.tabDnD:={? var_pres('_a')=type_of(SYSLOG) || _a || return(0) ?};
_obj.mask:={? var_pres('_b')=type_of('')    || _b || return(0) ?};
_obj.tabSrc:={? var_pres('_c')=type_of(SYSLOG) || _c || return(0) ?};
_obj.tree:={? var_pres('_d')=type_of('')    || _d || return(0) ?};
_obj.isInDnD:=$("_parent:=0;
                 _res:=0;
                 {? .tabSrc.seek(_a,_b)
                 || _parent:=.tabSrc."+_obj.tree+"
                 ?};

                 {? _parent<>0
                 || {? .tabDnD.first()
                    || {!
                       |? _res:=(.tabDnD.REF=_parent);
                          ~_res & .tabDnD.next()
                       !}
                    ?};
                    {? _res=0
                    || _res:=.isInDnD(_parent,_b)
                    ?}
                 ?};
                _res");

_obj.tabSrc.cntx_psh();
{? _obj.tabDnD.first()
|| {!
   |? _obj.tabDnD.cntx_psh();
      _res:=(_obj.isInDnD)(_obj.tabDnD.REF,_obj.mask);
      _obj.tabDnD.cntx_pop();
      {? _res
      || _del:=_obj.tabDnD.del(,1);
        _del=2
      || _obj.tabDnD.next()
      ?}
   !}
?};
_obj.tabSrc.cntx_pop();
_obj.tabDnD


\dnd_tree_grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.30]
:: OPIS: Funkcja do obsługi drag'n'drop dla grupy rekordow tabeli z polem tree_ref - przenoszenie rekordów w ramach
::       tej samej tabeli
::   WE: _a - [TABLE]   - wskazanie na tabele
::       _b - [RULE]    - formuła zwracajaca stringa do pytania dla rekordu żródłowego
::       _c - [RULE]    - formuła zwracajaca stringa do pytania dla rekordu docelowego
::       _d - [INTEGER] - czy wyswietlać komunikaty
::----------------------------------------------------------------------------------------------------------------------
 _tabSrc:={? var_pres('_a')=type_of(SYSLOG) || _a || return(~~) ?};
_ruleSrc:={? var_pres('_b')=type_of("")     || _b || ""         ?};
_ruleDst:={? var_pres('_c')=type_of("")     || _c || ""         ?};
    _msg:={? var_pres('_d')=type_of(0)      || _d || 0          ?};
::sprawdzenie czy w przekazanej tabeli jest pole typu tree_ref
_treeFld:=exec('getTreeFld4Tab','libfml',_tabSrc);
{? _treeFld=''
|| return(~~)
?};
_tabSrc.cntx_psh();
_mask:=dnd_info('table_name');
_tabDnD:=dnd_info('dropped_records');
exec('dnd_grp_clear','libfml',_tabDnD,_mask,_tabSrc,_treeFld);
_recSrc:='';
_recDst:='';
_refDst:=0;
{? _tabDnD.first()
|| _ref:=dnd_info('dest_record');
   {? {? _ref=null
      || {? _msg
         || {? _tabDnD.size()=1
            || FUN.ask('Czy przenoszony rekord ma być elementem głównym?'@)
            |? _tabDnD.size()>1
            || FUN.ask('Czy przenoszone rekordy mają być elementami głównymi?'@)
            ?}
         || 1
         ?}
      |? _tabDnD.size()=1
      || {? _tabSrc.seek(_tabDnD.REF,_mask)
         || {? _ref=_tabSrc.ref()
            || 0
            || _recSrc:=_ruleSrc();
               {? _tabSrc.seek(_ref)
               || _recDst:=_ruleDst();
                  {? _msg || FUN.ask('Czy chcesz przypisać rekord: %1\n\ndo rekordu: %2?'@[_recSrc,_recDst]) || 1 ?}
               ?}
            ?}
         ?}
      |? _tabDnD.size()>1
      || {? _tabSrc.seek(_ref)
         || _recDst:=_ruleDst();
            {? _msg || FUN.ask('Czy przypisać zaznaczone rekordy do rekordu: %1?'@[_recDst]) || 1 ?}
         ?}
      ?}
   ||
      {? (_ref<>null) & _tabSrc.seek(_ref)
      || _refDst:=#_tabSrc.ref()
      ?};
      {? _tabDnD.first()
      || _move:=$("_a."+_treeFld+":=_b; _a.put(1)");
         {!
         |? {? _tabSrc.seek(_tabDnD.REF,_mask)
            ||
               {? ~_move(_tabSrc,_refDst)
               || {? _msg
                  || FUN.emsg('Przypisanie rekordów nie jest możliwe\n'
                              'ze względu na istniejące między nimi powiązania.\n'@,
                              ' — '+'Uwaga!'@,'EXCLAM')
                  || 1
                  ?}
               ?}
            ?};
            _tabDnD.next()
         !}
      ?}
   ?}
|| {? _msg || FUN.info('Brak rekorów do przeniesienia'@) ?}
?};
_tabSrc.cntx_pop();
~~


\mbTabFieldFormulas
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [21.14]
:: OPIS: Wyświetla formuły obsługi podanego pola.
::   WE: _a [TABLE]  - Uchwyt tabeli.
::       _b [STRING] - Akronim pola.
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_TAB:=_a;
_acr:=_b;

_jestF3:=',20,21,22,27,29,'*',%1,'[$var_pres(_acr,_TAB)];

:: Teoretycznie metoda fld_fml() może zwrócić napis dłuższy niż 255 znaków i należałoby użyć typu
:: SYS_MEMO zamiast STRING[255], ale ponieważ analizujemy tabele stałe, dla których formuły definiowane są w
:: MacroBUILDER-ze, to pozostańmy przy STRING[255].
_VIEW:=tab_tmp(1
   ,'PT','STRING[255]','Wzorzec'@
   ,'BL','STRING[255]','Wartość początkowa'@
   ,'BD','STRING[255]','Przed wyświetleniem'@
   ,'BE','STRING[255]','Przed redagowaniem'@
   ,'F3','STRING[255]','Wybór F3'@
   ,'AE','STRING[255]','Po redagowaniu'@
   ,'DF','STRING[255]','Format wyświetlania'@
   ,'EF','STRING[255]','Format redagowania'@
);

_VIEW.blank();
_VIEW.PT:=$_TAB.fld_fml(_acr,'*PATTERN');
_VIEW.BL:=$_TAB.fld_fml(_acr,'*BLANK');
_VIEW.BD:=$_TAB.fld_fml(_acr,'*BEFORE_DISPLAY');
_VIEW.BE:=$_TAB.fld_fml(_acr,'*BEFORE_EDIT');
{? _jestF3
|| _VIEW.F3:=$_TAB.fld_fml(_acr,'*F3')
?};
_VIEW.AE:=$_TAB.fld_fml(_acr,'*AFTER_EDIT');
_VIEW.DF:=$_TAB.fld_fml(_acr,'*DISPLAY_FORMAT');
_VIEW.EF:=$_TAB.fld_fml(_acr,'*EDIT_FORMAT');

_szer:=120;
_title:='Formuły dla pola: %1.%2'@ [2-!_TAB,_acr];
_we:=_VIEW.mk_edit(_title,,'#mbtabfieldfmls');
_VIEW.win_esep(_we,'Dane podstawowe'@);
_VIEW.win_efld(_we,,'PT',,,_szer);
_VIEW.win_efld(_we,,'BL',,,_szer);
_VIEW.win_efld(_we,,'BD',,,_szer);
_VIEW.win_efld(_we,,'BE',,,_szer);
_VIEW.win_efld(_we,,'F3',,,_szer);
_VIEW.win_efld(_we,,'AE',,,_szer);
_VIEW.win_efld(_we,,'DF',,,_szer);
_VIEW.win_efld(_we,,'EF',,,_szer);
_VIEW.win_edit(_we);

_VIEW.efld_opt(_we,'enable=%1'[$_jestF3],,'F3');

_VIEW.display();

~~


\Struct
::----------------------------------------------------------------------------------------------------------------------
::  UTW: [rr] [23.25]
:: OPIS: Wyświetla tabele systemu
::   WE: [_a] - powiązane ze wskazanym akronimem
::       [_b] - pole do przypisania danych
::       [_c] - 0(domyślnie) - klawisz F3, 1-kontrola, 2-F3-indeks, 3-kontrola-indeks, 4-F3-pola
::----------------------------------------------------------------------------------------------------------------------
_uptab:={? var_pres('_a')=type_of('') || _a || '' ?};
_field:={? var_pres('_b')=type_of('') || _b || '' ?};
_check:={? var_pres('_c')=type_of(0)  || _c || 0  ?};
_fldtb:=_check=4;
_index:={? ~_fldtb & _check>1 || 1 || 0 ?};
_check:=_check%*2;
_res:='';

_tables:=tab_tmp(1
                ,'ACRONYM','STRING[8]','AKRONIM'@
                ,'COMMENT','STRING[60]','Komentarz'@
                ,'NR'     ,'INTEGER','Nr'@
                );
{? ~_index & ~_fldtb
|| {! _tt:=1..tab_num()
   |! _acr:=tab_acr(_tt);
      {? tab_real(_tt) & _uptab<>_acr
      || {? _uptab=''
         || _tables.blank();
            _tables.NR:=_tt;
            _tables.ACRONYM:=_acr;
            _tables.COMMENT:=($_acr)().comment();
            _tables.add()
         || _xxx:=($_acr)();
            {! _ff:=1.._xxx.fld_num()
            |! {? _xxx.fld_join(_ff)=_uptab
               || _tables.prefix(_acr,);
                  {? ~_tables.first()
                  || _tables.blank();
                     _tables.NR:=_tt;
                     _tables.ACRONYM:=_acr;
                     _tables.COMMENT:=($_acr)().comment();
                     _tables.add()
                  ?}
               ?}
            !};
            obj_del(_xxx)
         ?}
      ?}
   !}
|? _fldtb & _uptab<>''
|| _xxx:=($_uptab)();
   {! _ff:=1.._xxx.fld_num()
   |! _tables.blank();
      _tables.NR:=_ff;
      _tables.ACRONYM:=_xxx.fld_acr(_ff);
      _tables.COMMENT:=_xxx.fld_name(_ff);
      _tables.add()
   !}
|? _index & _uptab<>''
|| _xxx:=($_uptab)();
   {! _ii:=1.._xxx.ndx_num()
   |! _tables.blank();
      _tables.NR:=_ii;
      _tables.ACRONYM:=_xxx.ndx_acr(_ii);
      _jfld:=_xxx.ndx_jfld(_ii,1);
      _tables.COMMENT:='Pierwsze pole: '+_xxx.ndx_afld(_ii,1)+{? _jfld<>'' || ' [%1]'[_jfld] || '' ?};
      _tables.add()
   !}
?};

_win:=_tables.mk_sel({? _index || 'Indeksy'@
                     |? _fldtb || 'Pola tabeli'@
                     || 'Tabele'@
                     ?},'P',0,'#tabwyb',1,1,,,'U');
_tables.win_sel(_win);
_tables.win_fld(_win,,'ACRONYM' ,,,8);
_tables.win_fld(_win,,'COMMENT' ,,,40);
_tables.win_act(_win,,'Formuła','&Wybierz'@@      ,,,"sel_exit()",,1,,,,'W');
_tables.win_act(_win,,'Kolejność');
_tables.win_act(_win,,'Szukaj');

{? ~_check
|| _tables.prefix();
   {? _tables.select()
   || {? _field<>'' || ($_field)():=_tables.ACRONYM ?};
      _res:=_tables.ACRONYM
   ?}
|| {? _field<>''
   || _tables.prefix(($_field)(),);
      {? _tables.first() || _res:=_tables.ACRONYM ?}
   ?}
?};
_res

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:35 16826eade195951e60e1d1f8dc96d5467bb161923e34084e97d003210546c3cbd8a11200416052bbbbd1ff780e71ac13aa95799306c093aa7b8e3d4e4649f4ed6f032c5f95e4b21274fe71a360b0c789a725411ef9e4047da270d14c055b75c73cd1ef4aa199296588ebc582df73b73792150f1771bed6022444be430b9ba41d
