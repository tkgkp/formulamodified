:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: px_nast.fml
:: Utworzony: 24.11.2015
:: Autor: AJ
::======================================================================================================================
:: Zawartość: plan strategiczny obsługa tabeli px_nast, następniki i poprzedniki operacji w przepisie planistycznym
::======================================================================================================================


\pxnasttab
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: Obiekt do obsługi powiazan operacji i etapow (następniki)
::   WY: obj_new - tablica nazwana
::---------------------------------------------------------------------------------------------------------------------
_nast:=obj_new('tab'
               ,'ntoper'
               ,'add'
               ,'ndx1'
               ,'ndx2'
               ,'drop'
               ,'polfabr'
               ,'put'
               ,'stage');
_nast.tab:=tab_tmp(1,'STAGE','STRING[16]','PX_STAGE'
               ,'NRK','STRING[16]','NRK'
               ,'TKTL','INTEGER','TKTL'
               ,'TOPER','STRING[16]','TOPER'
               ,'RTOPER','INTEGER','RTOPER'
               ,'NTOPER','STRING[16]','poprzednik'
               ,'REF','INTEGER','REF'
               ,'U','INTEGER','czy uzyty'
               ,'NR','INTEGER','PX_STAGE.NR'
              );
_nast.ntoper:=0;
_nast.add:=".tab.index(.ndx1);
            .tab.prefix($_a);
            {? ~.tab.first()
            || .tab.STAGE:=$_a;
               .tab.TOPER:=$_b;
               .tab.RTOPER:=#_b;
               .tab.NTOPER:=$_d;
               .tab.NRK:=$_c;
               .tab.TKTL:=#_c;
               .tab.NR:=exec('FindAndGet','#table',PX_STAGE,_a,,$'NR',0);
               {? .tab.add()
               || .tab.REF:=#.tab.ref;
                  .tab.put()
               ?}
            ?};
            .tab.clear()
           ";
_nast.put:="
             .tab.cntx_psh();
             .tab.index(.ndx1);
             .tab.prefix(_a,$_b,$_c);
             {? ~.tab.first()
             || .tab.blank();
                .tab.clear;
                .tab.STAGE:=_a;
                .tab.TOPER:=$_b;
                .tab.RTOPER:=#_b;
                .tab.NTOPER:=$_d;
                .tab.NRK:=$_c;
                .tab.TKTL:=#_c;
                {? .tab.add()
                || .tab.REF:=#.tab.ref;
                   .tab.put()
                ?}
             ||
                .tab.prefix(_a,$_b,$_c,'',);
                {? .tab.first()
                || .tab.clear();
                   .tab.NTOPER:=$_d;
                   .tab.put()
                || .tab.blank();
                   .tab.clear;
                   .tab.STAGE:=_a;
                   .tab.TOPER:=$_b;
                   .tab.RTOPER:=#_b;
                   .tab.NTOPER:=$_d;
                   .tab.NRK:=$_c;
                   .tab.TKTL:=#_c;
                   {? .tab.add()
                   || .tab.REF:=#.tab.ref;
                      .tab.put()
                   ?}
                ?}
             ?};
             .tab.clear();
             .tab.cntx_pop()
           ";
_nast.stage:="
               _tktl:=_c;
               _stage:=exec('FindAndGet','#table',PX_STAGE,_a,,,null());
               _stagenext:=exec('FindAndGet','#table',PX_STAGE,_b,,,null());
               {? _stage<>null() & _stagenext<>null()
               || exec('add','px_nast',_stage,_stagenext,_tktl)
               ?}
             ";
_nast.ndx1:=_nast.tab.ndx_tmp(,,'STAGE',,,'TOPER',,,'NRK',,,'NTOPER',,);
_nast.ndx2:=_nast.tab.ndx_tmp(,,'TOPER',,,'STAGE',,);
_nast.drop:=".tab.ndx_drop(.ndx1);
             .tab.ndx_drop(.ndx2)
            ";
_nast


\px_join_a
::---------------------------------------------------------------------------------------------------------------------
::  UTW: WW  [12.46]
:: OPIS: Dane do funkcji powiazan etapow
::   WY: struktura dynamiczna na dane
::---------------------------------------------------------------------------------------------------------------------
_oper:=obj_new('stg','stg_ind1','stg_ind2','stg_add','stg_find',
               'firstop',
               'instan','ins_ind1','ins_ind2','inst_ad','set_own',
               'sciezki','sciez_er','sciez_ad','sciez_bl',
               'nast','nast_ad','nast_er',
               'done');
::tabela powiazan etapow w ramach uruwnoleglenia
_oper.stg:=tab_tmp(1
      ,'NR','INTEGER','PX_STAGE.NR'
      ,'STAGE','STRING[16]','$PX_STAGE.ref()'
      ,'STAGER','INTEGER','#PX_STAGE.ref()'
      ,'TKTL','STRING[16]','$TKTL.ref()'
      ,'TKTLR','INTEGER','#TKTL.ref()'
      ,'TOPER','STRING[16]','$TOPER.ref()'
      ,'TOPERR','INTEGER','#TOPER.ref()'
      ,'INSTAN','INTEGER','Instancja'
   );
_oper.stg_ind1:=_oper.stg.index('?');
_oper.stg_ind2:=_oper.stg.ndx_tmp(,,'TKTL',,,'TOPER',,,'INSTAN',,);
::dodanie rekordu do .stg
_oper.stg_add:=
   "  .stg.blank();
      .stg.NR:=_a;
      .stg.STAGE:=_b;
      .stg.STAGER:=BIT.sqlint(.stg.STAGE);
      .stg.TKTL:=$_c;
      .stg.TKTLR:=#_c;
      .stg.TOPER:=$_d;
      .stg.TOPERR:=#_d;
      .stg.INSTAN:=_e;
      .stg.add()
   ";
::zwrocenie #PX_STAGE.ref() odpowiadajacego danej operacji
_oper.stg_find:=
   "
::    parametry _a i _b moga przyjsc w postaci #ref lub ref
      _tktl:={? type_of(_a)=type_of('') || _a || $_a ?};
      _toper:={? type_of(_b)=type_of('') || _b || $_b ?};
      _ins:=_c;
      _stg:='';
      {? (+_tktl) & (+_toper)
      || .stg.cntx_psh(); .stg.index(.stg_ind2); .stg.prefix();
         {? .stg.find_key(_tktl,_toper,_ins) || _stg:=.stg.STAGE ?};
         .stg.cntx_pop()
      ?};
      _stg
   ";
::wykaz pierwszych operacji kazdej technologii wchodzacej do struktury
_oper.firstop:=tab_tmp(2
         ,'TKTL','STRING[16]','$TKTL.ref()'
         ,'TOPER','STRING[16]','$Toper.ref'
   );
::wykaz instancji poszczegolnych w kolejnosci etapow technologii w ramach struktury
::w  OWNER=PX_STAGE, do ktorego wchodzi polfabrykat identyfikowany przez pozostale dwa pola
_oper.instan:=tab_tmp(2
         ,'TKTL','STRING[16]','$TKTL.ref()'
         ,'INST','INTEGER','Nr instancji'
         ,'OWNER','STRING[16]','$PX_STAGE.ref()'
   );
_oper.ins_ind1:=_oper.instan.index('?');
_oper.ins_ind2:=_oper.instan.ndx_tmp(,,'TKTL',,,'OWNER',,,'INST',,);
::ustalenie, czy podana _a=TOPER.ref z danej _b=TKTL.ref rozpoczyna nowa instancje (brak rekordu w tabeli)
::jezeli tak to dopisanie, jezeli nie to zwrocenie numeru instancji biezacej dla danej _b
::jezeli tak to zwrocenie numeru instacni jezeji nie ma to 0
_oper.inst_ad:=
   "  _tktl:=$_b; _toper:=$_a;
      .instan.index(.ins_ind1);
      {? .firstop.find_key(_tktl,_toper,)
      ||
::       pojawienie sie nowej instancji technologii (pierwsza operacja z karty)
         .instan.prefix(_tktl);
         _nr:={? .instan.last() || .instan.INST || 0 ?}+1;
         .instan.prefix();
         .instan.TKTL:=_tktl; .instan.INST:=_nr;
         .instan.add();
         _nr
      ||
::       to nie jest pierwsza operacja karty, szukamy ostatniej instancji TKTL w wykazie
         .instan.prefix(_tktl);
::       zabezpieczenie, raczej zera nigdy nie powinno zwrocic
         _nr:={? .instan.last() || .instan.INST || 0 ?};
         .instan.prefix();
         _nr
      ?}
   ";
::wyszukanie instancji technologii i uzupelnenie pola OWNER
_oper.set_own:=
   "  _tktl:=$_a; _owner:=_b;
      .instan.cntx_psh(); .instan.index(.ins_ind2); .instan.prefix(_tktl,'',);
      {? .instan.first()
      || .instan.cntx_psh(); .instan.prefix();
         .instan.OWNER:=_owner; .instan.put();
         .instan.cntx_pop()
      ?};
      .instan.cntx_pop()
   ";
::lista sciezek przebiegu procesu technologicznego w ramach instancji
::tabela wykorzystywan do analizy powiazan operacji z uwzglednieniem zrownoleglenia
::liczba rekordow odpowiada licznie rozgalezien operacji w danym "przekroju" procesu technologicznego
_oper.sciezki:=tab_tmp(2
      ,'OPERPOP','STRING[16]','$TOPER.ref()'
      ,'OPERNAST','STRING[16]','$TOPER.ref()'
      ,'STAGEPOP','STRING[16]','$STAGE.ref()'
      ,'STAGENAS','STRING[16]','$STAGE.ref()'
      ,'USED','INTEGER','Czy pozycja wykorzystana'
   );
::kasowanie zawartosci .sciezki (przez del a nie erase, aby dzialalo w ewentualnej transakcji
_oper.sciez_er:=".sciezki.clear(); {! |? .sciezki.first() |! .sciezki.del() !}";
::dodanie rownoleglego lacznika sciezki
_oper.sciez_ad:=
   "  _poprz:=$_a; _nast:=$_b;
      _tktl:=.instan.TKTL; _ins:=.instan.INST;
      {? ~.sciezki.find_key(_poprz,_nast,)
      || .sciezki.blank();
         .sciezki.OPERPOP:=_poprz;
         .sciezki.OPERNAST:=_nast;
         .sciezki.STAGEPOP:=.stg_find(_tktl,_poprz,_ins);
         .sciezki.STAGENAS:=.stg_find(_tktl,_nast,_ins);
         .sciezki.add()
      ?}
   ";
::zablokowanie rekordu sciezki przed ponownym wykorzystaniem
_oper.sciez_bl:=
   "  .sciezki.cntx_psh(); .sciezki.prefix();
      {? .sciezki.seek(_a) || .sciezki.USED:=1; .sciezki.put() ?};
      .sciezki.cntx_pop()
   ";
::tabela z danymi do utworzenie struktury PX_NAST dla danej technologi
_oper.nast:=tab_tmp(2
      ,'STGPOP','STRING[16]','$PX_STAGE.ref()'
      ,'STGNAST','STRING[16]','$PX_STAGE.ref()'
      ,'TKTL','STRING[16]','$TKTL.ref()'
   );
::dodanie nowego rekordu do .nast z elemenacja powtorzen, lub niekompletnych danych
_oper.nast_ad:=
   "  _stgpop:=_a; _stgnast:=_b;
      _tktl:={? type_of(_c)=type_of('') || _c || $_c ?};
      {? (_stgpop<>'')&(_stgnast<>'')
         &(~.nast.find_key(_stgpop,_stgnast,))
      || .nast.blank();
         .nast.STGPOP:=_stgpop;
         .nast.STGNAST:=_stgnast;
         .nast.TKTL:=_tktl;
         .nast.add()
      ?}
   ";
::erase dla .nast (dziala w transakcji)
_oper.nast_er:=".nast.clear(); {! |? .nast.first() |! .nast.add() !}";
::destruktor
_oper.done:="obj_del(.stg); obj_del(.firstop); obj_del(.instan); obj_del(.sciezki); obj_del(.nast)";
_oper


\importtoper
::---------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Powiazanie etapow poprzez rekordy PX_NAST
::       Dizlanie tylko w obrebie listy etapow zawartych w _nast
::   WE: _a - wektor z danymi do ulozenia kolejnosci etapow
::---------------------------------------------------------------------------------------------------------------------
_nast:=_a;

::otwiera maske technologii na podstawie SQLREFA dowolnej tabeli maskowalnej zwiazanej z danymi technologicznymi
_open:="exec('tktl_use','tech_common',form(8+_a)+3); Cntx.clr(TKTL,TOPER,NASTOPER,TMAT)";
exec('tktl_cntx_psh','tech_common');
_oper:=exec('px_join_a','px_nast');
Cntx.psh(TKTL,TOPER,TMAT,NASTOPER);
Cntx.clr(TKTL,TOPER,TMAT);
::aby uniknac wielokrotnego rozwijania surowcow przy kazdej operacji karty gdy sa do karty
::a jednoczesnie uwzglednic je ponownie gdy podzespol przywolywany kilkakrotnie w ramach struktury
::najpierw zapamietanie pierwszej w kolejnosci operacji w kazdej technologii bioracej udzial w przepisie
{? _nast.tab.first()
||
   {!
   |? _open(_nast.tab.TOPER); NASTOPER.index('NASTOP');
      {? TOPER.seek(_nast.tab.RTOPER,8+_nast.tab.TOPER)
      ||  _toper:=TOPER.ref(); _tktl:=TOPER.NRK;
          NASTOPER.prefix('T',_toper);
          {? (NASTOPER.first()=0) & (_oper.firstop.find_key($_tktl,)=0)
          || _oper.firstop.TKTL:=$_tktl; _oper.firstop.TOPER:=$_toper; _oper.firstop.add()
          ?}
      ?};
      _nast.tab.next()
   !}
?};
::przepisanie danych z tabeli wejsciowej do tabeli z danymi operacyjnymi uwzgledniajacej instancje
::utworzenie listy instancji
{? _nast.tab.first()
|| {!
   |? _open(_nast.tab.TOPER);
      {? TOPER.seek(_nast.tab.RTOPER,8+_nast.tab.TOPER)
      ||
         _ins:=_oper.inst_ad(TOPER.ref(),TOPER.NRK);
         _oper.stg_add(_nast.tab.NR,_nast.tab.STAGE,TOPER.NRK,TOPER.ref(),_ins)
      ||
::       zapis awaryjny, gdy nie znaleziono operacji (nie powinien wystapic)
         _oper.stg_add(_nast.tab.NR,_nast.tab.STAGE,null(),null(),0,_nast.tab.ref())
      ?};
      _nast.tab.next()
   !}
?};
::jezeli wersja przepisu zlozonego
:: tworzenie struktury powiazan pomiedzy poszczegolnymi instancjami technologii
:: czyli wypelnianie pola _oper.instan.OWNER
{? _nast.polfabr=1
||
:: wyszukanie refa technologii wskazywanej przez biezacy polfabykat
   Cntx.psh(TKTL,TOPER,TMAT,NASTOPER);
   {? _nast.tab.first()
   || {!
      |? _open(_nast.tab.TOPER); NASTOPER.clear(); TMAT.index('ANNL');
         {? TOPER.seek(_nast.tab.RTOPER,8+_nast.tab.TOPER)
         || _stage:=_nast.tab.STAGE;
::          musze sprawdzic czy sa polfabrykaty (zawsze idzie ścieżka surowców powiązanych z operacją)
            {? 1
::               TOPER.NRK().TYP().SUR='O'
            ||
::             jezeli surowce do operacji
               TMAT.prefix('T',TOPER.NRK,TOPER.ref);
               {? TMAT.first()
               || {!
                  |? _ptktl:=exec('get_zktl4TMAT','px_oper',TMAT.ref());
                     {? _ptktl<>null() || _oper.set_own(_ptktl,_stage) ?};
                     TMAT.next()
                  !}
               ?};
::             jezeli są surowce bez operacji (tylko gdy dotyczy "pierwszej" operacji)
               TMAT.prefix('T',TOPER.NRK,null());
               {? TMAT.first() & _oper.firstop.find_key($TOPER.NRK,$TOPER.ref(),)
               || {!
                  |? _ptktl:=exec('get_zktl4TMAT','px_oper',TMAT.ref());
                     {? _ptktl<>null() || _oper.set_own(_ptktl,_stage) ?};
                     TMAT.next()
                  !}
               ?}
            ||
::             !!ścieżka nieobsługiwana!!
::             liste surowcow mozna rozwijac tylko gdy dotyczy "pierwszej" operacji niepowiazanym przepisie
               TMAT.prefix('T',TOPER.NRK,null());
               {? TMAT.first() & _oper.firstop.find_key($TOPER.NRK,$TOPER.ref(),)
               || {!
                  |? _ptktl:=exec('get_zktl4TMAT','px_oper',TMAT.ref());
                     {? _ptktl<>null() || _oper.set_own(_ptktl,_stage) ?};
                     TMAT.next()
                  !}
               ?}
            ?}
         ?};
         _nast.tab.next()
      !}
   ?};
   Cntx.pop(TKTL,TOPER,TMAT,NASTOPER)
?};
::ustalanie kolejnosci etapow w ramach technologii prostych
::zaklada sie, ze kazda aktywna operacja bue TPZ w technologii ma swoj etap w procesie
::zaklada sie, ze jezeli w technologii nie ma struktury nastepnikow, to anliza w kolejnosci prostych operacji nie TPZ
_oper.instan.index(_oper.ins_ind1); _oper.instan.prefix();
{? _oper.instan.first()
||
   Cntx.psh(TKTL,TOPER,TMAT,NASTOPER);
   {!
   |? _open(_oper.instan.TKTL); NASTOPER.index('OPER');
      {? TKTL.seek(_oper.instan.TKTL)
      || _toper:=null();
         NASTOPER.prefix('T',TKTL.ref());
         TOPER.index('ANNN'); TOPER.prefix('T','N',TKTL.ref());
         _oper.sciez_er();
         {? NASTOPER.first()
         ||
::          jest struktura, to szukamy wg nastepnikow - konieczna zabawa w sciezki
::          wyszukanie poczatkowych/wej operacji technologii
::          poniewaz moze byc kilka operacji rownoleglych od ktorych zaczyna sie proces
::          wylapanie wszyskich nieposiadajacych porzednikow
            {? TOPER.first()
            ||
               {!
               |?
                  {? TOPER.PZ<>'Z'
                  ||
                     TOPER.cntx_psh();
                     _toper:=TOPER.ref();
                     NASTOPER.index('OPER');  NASTOPER.prefix('T',TKTL.ref(),_toper);
                     _nastto:={? NASTOPER.first() || NASTOPER.NRNAST || null() ?};
                     NASTOPER.index('NASTOP'); NASTOPER.prefix('T',_toper);
                     {!
                     |? NASTOPER.first()
                     |! _toper:=NASTOPER.OPER; _nastto:=NASTOPER.NRNAST;
                        NASTOPER.prefix('T',_toper)
                     !};
::                   zapisanie poczatku sciezki, jezeli _nast=null to znaczy ze operacja zaczyna i konczy proces (raczej nie powinno wystapic)
                     {? _toper<>null() || _oper.sciez_ad(_toper,_nastto) ?};
                     TOPER.cntx_pop()
                  ?};
                  TOPER.next()
               !}
            ?};
::          kazdy rekord w _oper.sciez_ad trzyma ID operacji od ktorej trzeba sprawdzic strukture
            Cntx.psh(TOPER,NASTOPER);
            NASTOPER.index('OPER'); _oper.sciezki.prefix();
::          analiza przebiega wg zapisow w .sciezki, ktore w kazdej iteracji sa aktualizowane
::          dzieki polu USED wykluczone jest powtorzenie analizy dla juz sprawdzonego rekordu
::          wykorzystanych rekordow nie mozna usuwac az do wykorzystania wszystkich, bo powstanie zapetlenie programu
            {!
            |? {? _oper.sciezki.first()
               || {! |? (_oper.sciezki.USED=1) & _oper.sciezki.next() !};
                  _oper.sciezki.USED=0
               || 0
               ?}
            |! _ref:=_oper.sciezki.ref();
               TOPER.prefix();
::             zapis sciezek wychodzacych z badanej operacji
               {? TOPER.seek(_oper.sciezki.OPERPOP)
               || NASTOPER.prefix('T',TKTL.ref(),TOPER.ref());
                  {? NASTOPER.first()
                  ||
::                   sa nastepniki wyszukanie wszystkich i dodanie do .sciezki
                     {! |? _oper.sciez_ad(NASTOPER.OPER,NASTOPER.NRNAST); NASTOPER.next() !}
                  ?}
               ?};
::             zapis danych dla PX_NAST i badanie rozgalezien operacji nastepnej
               {? _oper.sciezki.seek(_ref)
               || _oper.nast_ad(_oper.sciezki.STAGEPOP,_oper.sciezki.STAGENAS,TKTL.ref());
                  {? TOPER.seek(_oper.sciezki.OPERNAST)
                  || NASTOPER.prefix('T',TKTL.ref(),TOPER.ref());
                     {? NASTOPER.first()
                     ||
::                      zapamietanie poczatkow sciezek wychadzacych z nastepnej operacji
                        {! |? _oper.sciez_ad(NASTOPER.OPER,NASTOPER.NRNAST); NASTOPER.next() !}
                     ||
::                      brak nastepnikow kolejnej operacji to nalezy polaczyc ja podzespolem wyzszego rzedu
                        {?_oper.instan.OWNER<>''
                        || _oper.nast_ad(_oper.sciezki.STAGENAS,_oper.instan.OWNER,_oper.instan.TKTL)
                        ?}
                     ?}
                  ?};
::                pozycja wykorzystana nie moze byc drugi raz uzyta
                  _oper.sciez_bl(_ref)
               ?}
            !};
            Cntx.pop(TOPER,NASTOPER)
         ||
::          brak struktury - kolejnosc wg numerow operacji
::          wyszukanie poczatkowej operacji prostej, nie TPZ technologii
            {? TOPER.first()
            || _stgpop:=_oper.stg_find(TKTL.ref(),TOPER.ref(),_oper.instan.INST);
               _stgnast:='';
               {!
               |? TOPER.next()
               |! _stgnast:=_oper.stg_find(TKTL.ref(),TOPER.ref(),_oper.instan.INST);
                  _oper.nast_ad(_stgpop,_stgnast,TKTL.ref());
                  _stgpop:=_stgnast
               !};
::             ewentuane dopisanie powiazania z elementem wyzszego rzedu
               {? _oper.instan.OWNER<>'' || _oper.nast_ad(_stgpop,_oper.instan.OWNER,_oper.instan.TKTL) ?}
            ?}
         ?}
      ?};
::    usuniecie wykorzystanych sciezek przed naliza kolejnej karty technologicznej
      _oper.sciez_er();
      _oper.instan.next()
   !};
   Cntx.pop(TKTL,TOPER,TMAT,NASTOPER)
?};
_oper.nast.prefix();
{? _oper.nast.first()
|| {!
   |?
      _stgpop:=exec('FindAndGet','#table',PX_STAGE,_oper.nast.STGPOP,,,null());
      _stgnast:=exec('FindAndGet','#table',PX_STAGE,_oper.nast.STGNAST,,,null());
      {? _stgpop<>null() & _stgnast<>null()
      || exec('add','px_nast',_stgpop,_stgnast)
      ?};
      _oper.nast.next()
   !}
?};
_oper.done(); obj_del(_oper);
Cntx.pop(TKTL,TOPER,TMAT,NASTOPER);
exec('tktl_cntx_pop','tech_common');
1


\add
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [1246]
:: OPIS: na podstawie przekazanych etapow nakrecamy px_nast
::   WE:  _a - PX_STAGE.ref() - etap operacji
::        _b - PX_STAGE.ref() - etap nastepny
::        [_c] - TKTL.ref()
::   WY: 0/1 czy udało się dodać kolejny etap
::  OLD: \pxnastadd/px_nast.fml
::---------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;
_px_next:=_b;

_tktl:=null();
{? var_pres('_c')=type_of(TKTL.ref())
|| _tktl:=_c
?};
_can_continue:=1;
Cntx.psh(PX_STAGE,PX_TEX,ZGP);
PX_NAST.index('PX');
PX_NAST.prefix(_px_stage,_px_next);
:: sprawdzamy czy juz taki etap istnieje
{? ~PX_NAST.first()
|| PX_NAST.clear();
   PX_NAST.blank(1);
   PX_NAST.PX_STAGE:=_px_stage;
   PX_NAST.PX_NEXT:=_px_next;
   PX_NAST.TKTL:={? _tktl<>null() || _tktl || PX_NAST.PX_STAGE().TKTL ?};

   PX_NAST.PX_TEX:=PX_NAST.PX_STAGE().PX_TEX;

   PX_NAST.ZL:={? PX_NAST.PX_TEX<>null || PX_NAST.PX_TEX().ZL || null() ?};

   _can_continue:=PX_NAST.add()
?};
Cntx.pop(PX_STAGE,PX_TEX,ZGP);
_can_continue


\switch4stage
::---------------------------------------------------------------------------------------------------------------------
::  UTW: WH  [12.46]
:: OPIS: Tworzy nowe powiązania pomiędzy etapami, omijając etap który za chwilę będzie usunięty
::   WE: _a - PX_STAGE.ref - etap który będzie usuwany, analizowane są jego poprzedniki które zostaną połączone z etapem
::                           docelowym
::       _b - PX_STAGE.ref() - etap docelowy z którym utworzyć nowe powiązanie
::---------------------------------------------------------------------------------------------------------------------
_src:=_a;
_dst:=_b;

_result:=0;
_can_continue:=1;

PX_NAST.cntx_psh();
PX_NAST.index('NEXT');
PX_NAST.prefix(_src);
{? PX_NAST.first()
|| {!
   |?
      _new_src:=PX_NAST.PX_STAGE;

::    Sprawdzam czy mogę utworzyć dane powiązanie (czy przypadkiem takiego już nie ma)
      _create:=1;
      PX_NAST.cntx_psh();
      PX_NAST.index('PX');
      PX_NAST.prefix(_new_src,_dst);
      {? PX_NAST.size()>0
      || _create:=0
      ?};
      PX_NAST.cntx_pop();

      {? _create>0
      || _can_continue:=exec('add','px_nast',_new_src,_dst)
      ?};
      PX_NAST.next() & _can_continue>0
   !}
?};
PX_NAST.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\clean4stage
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: Usuwa powiązania poprzedników z podanym etapem, przepina powiązania w taki sposób aby omijały usuwany etap
::   WE: _a - PX_STAGE.ref - etap, który usuwamy
::---------------------------------------------------------------------------------------------------------------------
_px_stage:=_a;

_result:=0;
_can_continue:=1;

PX_NAST.cntx_psh();
PX_NAST.index('PX');
PX_NAST.prefix(_px_stage);
{? PX_NAST.first()
||
   {? PX_NAST.PX_STAGE=PX_NAST.PX_NEXT
   ||
::    To mi wygląda na zabezpieczenie usuwające nieprawidłowe następniki które pochodzą i wskazują na tę samą operację
      PX_NAST.del(,1)
   ||
::    Tworzymy nowe powiązania omijające usuwany etap
      {!
      |? _can_continue:=exec('switch4stage','px_nast',_px_stage,PX_NAST.PX_NEXT);
         PX_NAST.next() & _can_continue>0
      !}
   ?}
?};

:: Usuwamy powiązania które wychodzą i wskazują na dany etap
PX_NAST.index('PX');
PX_NAST.prefix(_px_stage);
{? PX_NAST.first()
|| {!
   |? _can_continue:=PX_NAST.del(,1);
      _can_continue>0 & PX_NAST.first()
   !}
?};
PX_NAST.index('NEXT');
PX_NAST.prefix(_px_stage);
{? PX_NAST.first()
|| {!
   |? _can_continue:=PX_NAST.del(,1);
      _can_continue>0 & PX_NAST.first()
   !}
?};
PX_NAST.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\zlnad
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: dla podanego unikalnego nr zlecenia okreslamy jego zlecenie nadrzedne, jesli jest to zlecenie na wyrob zlecenia
::       to zwracamy zero
::   WE: _a nr zlecena nadrzednego
::       _b produkt podzlecenia
::   WY: 0/1
::---------------------------------------------------------------------------------------------------------------------
_wyn:=0;
_nrnzl:=_a;
_ktm:=_b;
_mat:=null();
ZL.cntx_psh();
ZL.clear();
ZL.index('UNRZL');
ZL.prefix(_nrnzl);
{? ZL.first()
|| _mat:=ZL.KTM
?};
:: jesli _ktm=_mat to analizujemy zlecenie na wyrób zlecenia nadrzednego to nie moze byc wyzej i zwracamy zero
{? _ktm<>_mat
|| ZL.index('NRNZL');
   ZL.prefix(_nrnzl,1);
   {? ZL.first()
   || {!
      |? {? _mat=ZL.KTM
         || _wyn:=ZL.UNRZL
         ?};
         ZL.next() & _wyn=0
     !}
  ?}
?};
ZL.cntx_pop();
_wyn


\zgp2stage
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: Uzupełnienie nastepnikow dla etapów przepisu zlecenia na podstawie NASZGP
::   WE: _a - ZL.ref
::       _b - INTEGER - 0/[1] - czy generować powiazania miedzy zleceniami
::       _c - INTEGER - 0/[1] - czy usuwać wcześniej istniejące powiązania i dopiero robić nowe
::   WY: INTEGER - czy operacja przebiegla pomyslnie
::---------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(null()) || return(0) ?};

Cntx.psh(ZL,ZGH,ZGP,NASZGP,PX_NAST,PX_STAGE);
_zl:=_a;
_interzlec:=1;
{? var_pres('_b')=type_of(0)
|| _interzlec:=_b
?};

_clean:=1;
{? var_pres('_c')=type_of(0)
|| _clean:=_c
?};

_can_continue:=1;
_result:=0;

{? _clean>0
||
:: usuniecie wczesniejszych PX_NAST dla zlecenia

   PX_NAST.cntx_psh();
   PX_NAST.index('ZLON');
   PX_NAST.prefix(_zl);
   {? PX_NAST.first()
   || {!
      |? _can_continue:=PX_NAST.del(,1);
         PX_NAST.first() & _can_continue>0
      !}
   ?};
   PX_NAST.cntx_pop();
   ~~
?};

{? _can_continue>0
||
   NASZGP.index('ZLPOPNA');
   NASZGP.prefix(_zl);
   {? NASZGP.first()
   || {!
      |? _create:=1;
         {? NASZGP.ZLNAST<>NASZGP.KTL
         || _create:=_interzlec
         ?};
         {? _create>0
         || _px_stage:=NASZGP.OPER().PX_STAGE;
            _px_next:=NASZGP.NRNAST().PX_STAGE;
            {? _px_stage<>null() & _px_next<>null()
            || _can_continue:=exec('add','px_nast',_px_stage,_px_next)
            ?}
         ?};
         NASZGP.next() & _can_continue>0
      !}
   ?}
?};
Cntx.pop(ZL,ZGH,ZGP,NASZGP,PX_NAST,PX_STAGE);
{? _can_continue>0
|| _result:=1
?};
_result


\px_nast_fd
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: Format wyświetlania dla pól tabeli PX_NAST
::   WY: STRING
::---------------------------------------------------------------------------------------------------------------------
''


\transferzlec
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: formula potransferowa uzupelniajaca brakujace zapisy w px_nast dla zleceń
::---------------------------------------------------------------------------------------------------------------------

~~


\action
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: akcja dla dodawnych nowych etapow
::   WE:
::   WY:
::---------------------------------------------------------------------------------------------------------------------
_PxTex:=_a;
PX_STAGE.cntx_psh();
{? PX_VAR.PX_STAGE().TKTL<>null()
|| PX_STAGE.index('TKTL_NR');
   PX_STAGE.prefix(PX_VAR.PX_STAGE().RTKTL)
|| PX_STAGE.index('TEX_NR');
   PX_STAGE.prefix(PX_VAR.PX_STAGE().PX_TEX)
?};
_ok:=0;
{? PX_STAGE.first()
|| {!
   |? _ok:=PX_STAGE.CONN_OK='T';
      _ok=0 & PX_STAGE.next()
   !}
?};
PX_STAGE.cntx_pop();
{? _ok=0
|| _PxTex.TieTabN.actions(_PxTex.TieSelN,'DUP:D','')
|| _PxTex.TieTabN.actions(_PxTex.TieSelN,'','')
?}


\tieadd
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: dodajemy nowe powiazanie miedzy etapami
::   WY: scieżka wybranej operacji
::---------------------------------------------------------------------------------------------------------------------
{? PX_VAR.PX_STAGE<>null()
||
   exec('nastlist','px_nast',VAR.A_KTL);
   exec('reload_procesy','px_tex')
|| FUN.emsg('Brak etapu planistycznego do którego dodać następnik.'@)
?};
~~


\del_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ [12.46]
:: OPIS: Usuwa z listy nastepnikow rekordy ktore nie moga byc nastepnikami
::       pracujemy w konteksicie PX_STAGE.ref
::   WE: _a - PX_STAGE.ref()
::       _b - ref_table - tablica refów z odwiedzonymi już PX_STAGEami
::----------------------------------------------------------------------------------------------------------------------
_oper:=_a;
_visited:=_b;
PX_NAST.cntx_psh();
PX_NAST.index('NEXT');
{? _visited.r_find(_oper)=0
|| _visited.add(_oper);
   PX_NAST.prefix(_oper);
   {? PX_NAST.first()
   || {!
      |?
::       !!! REKURENCJA !!!
         exec('del_nast','px_nast',PX_NAST.PX_STAGE,_visited);
         __NAST.prefix(PX_NAST.PX_STAGE().NR);
         {? __NAST.first()
         || __NAST.del()
         ?};
         PX_NAST.next()
     !}
   ?}
?};
PX_NAST.cntx_pop();
~~


\add_nast
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: Wypelnia podstawowe dane dotyczace nowego nastepnika
::   WE: _a: ref etapu
::       _b: refsql nastepnika
::---------------------------------------------------------------------------------------------------------------------
_stage:=_a;
_stagenext:=exec('FindAndGet','#table',PX_STAGE,_b,,,null());
{? _stage<>null() & _stagenext<>null()
|| exec('add','px_nast',_stage,_stagenext)
?};
{? var_pres('PxTex')>0
|| exec('load_tie_toper','px_tex',PxTex,_stage)
?};
~~


\tieup
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: akcja przed popraw nastepnikow
::   WY: 1
::---------------------------------------------------------------------------------------------------------------------
PxTex.TieVar.rsql:=cur_tab(1,1).NSQL_REF;
PxTex.TieVar.nr:=0;
1


\tieupae
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: akcja po popraw nastepnikow
::   WY: 0/1
::---------------------------------------------------------------------------------------------------------------------

{? PxTex.TieVar.nr=0
||
:: nr wpisalismy z palucha a nie wybieralismy z listy trzeba sprawdzic czy mozemy w tym zakresie dzialac
   _nr:=cur_tab(1,1).NR;
   exec('utw_nast','px_nast',VAR.A_KTL);
   __NAST.prefix();
   {? __NAST.first()
   || _ok:=0;
      {!
      |? {? #__NAST.SCIEZKA =_nr
         || _ok:=1;
            exec('add_nast','px_nast',PX_VAR.PX_STAGE,__NAST.SQLREF);
            exec('tie_del','px_nast',PxTex,$PX_VAR.PX_STAGE,PxTex.TieVar.rsql,1);
            0
         || __NAST.next()
         ?}
      !};
      {? _ok=0
      || FUN.emsg('Podany następnik jest niepoprawny.'@);
         cur_tab(1,1).NR:=exec('FindAndGet','#table',PX_STAGE,PxTex.TieVar.rsql,,"NR",_nr);
         cur_tab(1,1).put;
         0
      || 1
      ?}
   || FUN.emsg('Podany następnik jest niepoprawny.'@);
      cur_tab(1,1).NR:=exec('FindAndGet','#table',PX_STAGE,PxTex.TieVar.rsql,,"NR",_nr);
      cur_tab(1,1).put;
      0
   ?}
||
   exec('tie_del','px_nast',PxTex,$PX_VAR.PX_STAGE,PxTex.TieVar.rsql,1);
   1
?}


\tie_del
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: usuwanie nastepnika etapu
::   WE: _a PxTex
::       _b refsql etap na ktorym jestesmy
::       _c refsql etap do ktorego usuniemy powiazanie
::     [_d] dialogi
::---------------------------------------------------------------------------------------------------------------------
_PxTex:=_a;
_stg:=_b;
_stgn:=_c;
_dialog:={? _>3 || _d || 0 ?};
{? _dialog | FUN.ask('Czy usunąć bieżący wiersz?'@)
||
   _stage:=exec('FindAndGet','#table',PX_STAGE,_stg,,,null());
   _stagenext:=exec('FindAndGet','#table',PX_STAGE,_stgn,,,null());

   {? _stage<>null() & _stagenext<>null()
   || PX_NAST.index('PX');
      PX_NAST.prefix(_stage,_stagenext);
      {? PX_NAST.first()
      || PX_NAST.del();
         exec('load_tie_toper','px_tex',_PxTex,_stage)
      ?}
   ?}
?};
exec('reload_procesy','px_tex');
~~


\ilprocesow
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: formula zwracajaca tablice z iloscia 'procesow'
::   WE: _a PxTex
::   WY: tab_tmp
::---------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_tab:=tab_tmp(1,'IP','INTEGER','Ilosc procesów'
               ,'START','STRING[16]','START'
               ,'END','STRING[16]','END'
               );

_stages:=exec('ref_table','#table');

{? _pxtex.TKTL<>null()
|| PX_NAST.index('TKON');
   PX_NAST.prefix($_pxtex.TKTL)
|| PX_NAST.index('PXON');
   PX_NAST.prefix(_pxtex.PX_TEX)
?};

{? PX_NAST.first()
|| {!
   |? _px_stage:=PX_NAST.PX_STAGE;
::    trzeba sprawdzic czy nie jest to etap ze srodka
      PX_NAST.cntx_psh();
      PX_NAST.index('NEXT');
      PX_NAST.prefix(_px_stage);
      _ok:=~PX_NAST.first();
      PX_NAST.cntx_pop();
      {? _ok
      || _obj:=exec('next','px_nast');
         _tab.blank();
         _tab.START:=$PX_NAST.PX_STAGE;
         _tab.END:=$_obj.end;
         _tab.IP:=_obj.ip;
         _tab.add();

::       Dodaje do tablicy przetworzonych PX_STAGE
         _stages.add(PX_NAST.PX_STAGE);
         _stages.add(PX_NAST.PX_NEXT);

         obj_del(_obj)
      ?};
      PX_NAST.next()
   !}
?};

:: Dodajemy wszystkie ktore nie sa powiazane na poczatek procesu
PX_STAGE.cntx_psh();
{? PxTex.TKTL<>null()
|| PX_STAGE.index('TKTL_NR');
   PX_STAGE.prefix($_pxtex.TKTL)
|| PX_STAGE.index('TEX_NR');
   PX_STAGE.prefix(_pxtex.PX_TEX)
?};
{? PX_STAGE.first()
|| {!
   |?
      {? _stages.r_find(PX_STAGE.ref())=0
      || _tab.blank();
         _tab.START:=$PX_STAGE.ref;
         _tab.END:=$PX_STAGE.ref();
         _tab.IP:=0;
         _tab.add()
      ?};
      PX_STAGE.next()
   !}
?};
PX_STAGE.cntx_pop();
_tab


\next
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: sprawdzenie czy sa kolejne etapy, pracujemy w kontekscie PX_NAST
::   WY: obj_new - obiekt zawierający dane o kolejnych etapach
::---------------------------------------------------------------------------------------------------------------------
_px_stage:=PX_NAST.PX_NEXT;
_obj:=obj_new('start'
               ,'end'
               ,'ip'
               ,'stage');
_obj.ip:=1;
PX_NAST.cntx_psh();
PX_NAST.index('PX');
PX_NAST.prefix(_px_stage);
{? PX_NAST.first()
|| _obj_next:=exec('next','px_nast');
   _obj.ip+=_obj_next.ip;
   _obj.end:=_obj_next.end
|| _obj.end:=_px_stage
?};
PX_NAST.cntx_pop();
_obj


\verify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.46]
:: OPIS: Sprawdza poprawność połączenia - powinno prowadzić od etapu o mniejszym numerze do etapu o numerze
::       większym, ponieważ etapy są planowane w kolejności i jak użytkownik coś namiesza to może
::       się nieprawidłowo zaplanować
::   WE: [_a] - PX_NAST.ref() lub bieżacy rekord
::   WY: -1 - powiązanie etapów nieprawidłowe - któryś z etapów jest nullem
::        0 - powiązanie etapów niepoprawidłowe - nie zgadzają się numery
::        1 - powiązanie etapów ok
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_NAST.ref())
|| _ref:=_a
?};

_result:=1;
_can_continue:=1;

PX_NAST.cntx_psh();
{? _ref<>null()
|| PX_NAST.prefix();
   {? PX_NAST.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   {? PX_NAST.PX_STAGE=null() | PX_NAST.PX_NEXT=null()
   || _result:=-1
   ||
      _nr_src:=PX_NAST.PX_STAGE().NR;
      _nr_dst:=PX_NAST.PX_NEXT().NR;

      {? _nr_src>_nr_dst
      || _result:=0
      ?}
   ?}
?};
PX_NAST.cntx_pop();
_result


\pxnast2pxkont
::---------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: dla danego etapu ustawlenie kojnego i wypelnienie zapisow do wizualizacji procesow
::   WE: _a - PxTex - obiekt do obsługi przepisów
:        _b - PX_STAGE.ref()s
::       _c - obj_new - objekt pomocniczy
::       _d - INTEGER - nr etapu
::---------------------------------------------------------------------------------------------------------------------
_pxtex:=_a;
_px_stage:=_b;
_var:=_c;
_etap:=_d;

_ip:=1;
PX_NAST.cntx_psh();
PX_OPER.cntx_psh();
PX_NAST.index('PX');
PX_OPER.index('UNIQALL');
PX_OPER.prefix(_px_stage);
{? PX_OPER.first()
|| {!
   |? _tree:=_var.tree(_pxtex.EtapTab,#PX_OPER.PX_KONT);
      _var.add(_pxtex.EtapTab
               ,'Etap: '+$PX_OPER.PX_STAGE().NR+' - '+PX_OPER.PX_STAGE().NAZWA
               ,_tree
               ,PX_OPER.PX_STAGE
               ,_etap
               ,PX_OPER.PX_STAGE().KOLOR
              );
      PX_OPER.next()
   !}
?};
PX_NAST.prefix(_px_stage);
{? PX_NAST.first()
|| {!
   |? exec('pxnast2pxkont','px_nast',_pxtex,PX_NAST.PX_NEXT,_var,_etap+1);
      PX_NAST.next()
   !}
?};
PX_OPER.cntx_pop();
PX_NAST.cntx_pop();
~~


\nastlist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Lista mozliwych nastepnikow.
::   WE: _a -  TKTL.ref() - ref technologii
::   WY: sciezka wybranej operacji
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
PX_STAGE.cntx_psh();
exec('utw_nast','px_nast',_tktl);
__NAST.prefix();
{? __NAST.select()
|| exec('add_nast','px_nast',PX_VAR.PX_STAGE,__NAST.SQLREF);
   cur_tab(1,1).NR:=#__NAST.SCIEZKA;
   PxTex.TieVar.nr:=#__NAST.SCIEZKA;
   _res:=__NAST.SCIEZKA
|| {? menu_txt='Popraw'
   || _res:=PX_NAST.SCIEZKA
   || _res:=''
   ?}
?};
obj_del(__NAST);
&__WER;
PX_STAGE.cntx_pop();
_res


\utw_nast
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Tworzy tabele tymczasowa zawierajaca mozliwe nastepniki operacji
::   WE: _a -  TKTL.ref() - ref technologii
::       [_b] - STRING - tytuł okienka, domyślnie: Dostępne operacje
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

_title:='Dostępne operacje';
{? var_pres('_b')=type_of('')
|| _title:=_b
?};

PX_NAST.cntx_psh();

VAR_DEL.delete('__NAST');
__NAST:=tab_tmp(1,
   'UIN','REAL','Uin.następnika',
   'REF','INTEGER','Ref.do nastoper',
   'NROP','INTEGER','Nr operacji',
   'NAZ','STRING[100]','Nazwa operacji',
   'KOD','STRING[10]','Kod operacji',
   'SCIEZKA','STRING[20]','Ścieżka',
   'WEW','STRING[1]','Wewnętrzna',
   'PL_GRP','STRING[1]','Grupowa',
   'KONTROLA','STRING[1]','Kontrola jakości',
   'ILOSC','REAL','Ilość na operacji',
   'SQLREF','STRING[16]','Ref SQL operacji',
   'NAPRAW','STRING[1]','Czy operacja naprawcza',
   'NAPR_TYP','STRING[20]','Typ operacji naprawczej');

__NAST.fld_attr('UIN',2);
__NAST.fld_attr('REF',2);
__NAST.fld_attr('NROP',2);
__WER:=__NAST.mk_sel(_title,'T',0,'#nast_px',,5,,,'U');
__NAST.win_fld(__WER,,'SCIEZKA',,,10,,,'Nr operacji'@,,'Nr operacji'@,,1);
__NAST.win_fld(__WER,,'NAZ',,,50,,,'Nazwa operacji'@,,'Nazwa operacji'@);
__NAST.win_fld(__WER,,'KOD',,,10,,,'Kod'@,,'Kod operacji'@);
__NAST.win_act(__WER,0,'Formuła','Wybierz'@@,,,"sel_exit()",,1);
__NAST.win_act(__WER,0,'Kolejność');
__NAST.win_sel(__WER);

PX_STAGE.cntx_psh();
{? PX_VAR.PX_STAGE().TKTL<>null()
|| PX_STAGE.index('TKTL_NR');
   PX_STAGE.prefix($PX_VAR.PX_STAGE().TKTL)
|| PX_STAGE.index('TEX_NR');
   PX_STAGE.prefix(PX_VAR.PX_STAGE().PX_TEX)
?};
{? PX_STAGE.first()
|| {!
   |?
      {? PX_STAGE.ref()<>PX_VAR.PX_STAGE
      || __NAST.UIN:=PX_STAGE.NR;
         __NAST.SQLREF:=$PX_STAGE.ref();
         __NAST.NROP:=PX_STAGE.NR;
         __NAST.NAZ:=PX_STAGE.NAZWA;
         __NAST.KOD:='Etap '+$PX_STAGE.NR;
         __NAST.WEW:='';
         __NAST.SCIEZKA:=$(PX_STAGE.NR);
         __NAST.PL_GRP:='N';
         __NAST.KONTROLA:='N';
         __NAST.add()
      ?};
      PX_STAGE.next()
   !}
?};
PX_STAGE.cntx_pop();
_visited:=exec('ref_table','#table');
exec('del_nast','px_nast',PX_VAR.PX_STAGE,_visited);
exec('del_exist','px_nast',PX_VAR.PX_STAGE);
PX_NAST.cntx_pop();
~~


\del_exist
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Usuwa niepotrzebne pozycje z listy możliwych następników
::       (te, które już są na liście następników tej operacji)
::   WE: _a - PX_STAGE.ref() - operacja główna
::----------------------------------------------------------------------------------------------------------------------
_oper:=_a;

_ndx:=PX_NAST.ndx_tmp(,1,'PX_STAGE',,,'PX_NEXT','NR',);
__NAST.prefix();
__NAST.first();
PX_NAST.index(_ndx);
{!
|? PX_NAST.prefix(_oper,__NAST.UIN);
   {? PX_NAST.first()
   || __NAST.del()
   || __NAST.next()
   ?}
!};
PX_NAST.clear();
PX_NAST.ndx_drop(_ndx);
&_ndx;
~~


\stage
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AJ  [12.46]
:: OPIS: zbieranie danych do trzepaczki
::   WY: obj_new()
::----------------------------------------------------------------------------------------------------------------------
_stage:=obj_new('tab','add');
_stage.tab:=tab_tmp(2,'REF'   ,'STRING[16]','Ref'
                     ,'REFZ'  ,'STRING[16]','Zasób'
                     ,'PARENT','INTEGER'   ,'Gdzie podpiąć'
                     ,'ETAP'  ,'STRING[50]','Etap'
                     ,'NUM'   ,'INTEGER'   ,'Kolejność w procesie lub kolejność planowania'
                     ,'UID'   ,'REAL'      ,'UID'
                     ,'ZASOB' ,'STRING[50]','Zasób'
                     );
_stage.add:="_tab:=.tab;
             _tab.prefix(_a,_b);
             {? ~_tab.first()
             || _tab.clear();
                _tab.blank();
                _tab.REF:=_a;
                _tab.REFZ:=_b;
                _tab.PARENT:=_c;
                _tab.ETAP:=_d;
                _tab.NUM:=_e;
                _tab.UID:=_f;
                _tab.ZASOB:=_g;
                _tab.add()
             ?};
             _tab.clear()
            ";
_stage


\trigger_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Trigger przed put i przed add dla tabeli PX_NAST
::   WY: 1
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? PX_NAST.TKTL<>null() & PX_NAST.RTKTL<>$PX_NAST.TKTL
|| PX_NAST.RTKTL:=$PX_NAST.TKTL
?};
1


\nast4oper
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Dla podanego etapu zwraca listę następników (w postaci stringa)
::   WE: _a - PX_STAGE.ref()
::   WY: STRING - lista następników oddzielona przecinkami
::----------------------------------------------------------------------------------------------------------------------
_nast:='';
_pxstage:={? var_pres('_a')=type_of(null()) || _a || null() ?};
PX_STAGE.cntx_psh();
PX_STAGE.clear();
PX_NAST.cntx_psh();
PX_NAST.clear();
{? PX_STAGE.seek(_pxstage)
|| PX_NAST.index('PX');
   PX_NAST.prefix(_pxstage);
   {? PX_NAST.first()
   || {!
      |?
         _nast+=$PX_NAST.PX_NEXT().NR+',';
         PX_NAST.next()
      !}
   ?}
?};
PX_STAGE.cntx_pop();
PX_NAST.cntx_pop();
_nast:=_nast-1;
_nast

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:35 b4b867f0c25767ad68ecca13359e9766db4b9db540efa80c2ec1ed83be3d915ccf0532f77c0e15043f4261c0344f7caa7a7d3f5937e15cb6d20c9f01a0ee9955c9c7c87790415157fd1d3393b7458b4bb0d908bc0c3a4711a14f85ae9fc60584f6b9a7dfe8e46963e70260e057def00fe991ba4a1853c9c6acc6f9c4786f1b6f
