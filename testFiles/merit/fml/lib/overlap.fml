:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: overlap.fml [1998]
:: Utworzony: 1999/06/10
:: Autor: GS
::======================================================================================================================
:: Zawartość: Definicje funkcji wykorzystywanych podczas edycji kartotek.
::            Funkcje głównie dla akcji "Rekord - po" tabel zawierających dane chronologiczne -
::            kontrola "nakładania się" okresów.
::            Zakłada się, że w strukturze badanej tabeli istnieją pola określające początek i koniec okresu
::            (typu DATE). Akronimy tych pól można określić parametrami.
::======================================================================================================================


\alert
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
::       RWR [17.00]
:: OPIS: Komunikat o "nakładaniu się" okresów.
::   WE: _a - Treść komunikatu (opcjonalnie).
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_msg:={? var_pres('_a')=type_of('') || _a || 'Wprowadzono niespójne daty.'@ ?};
FUN.info(_msg);
0


\is
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
::       RWR [17.00]
:: OPIS: Formuła badająca poprawność przekazanych argumentów z zawartością bieżącego rekordu.
::       Uwaga.
::       Poprawność argumentów NIE jest weryfikowana.
::   WE:  _a  [TABLE]   - Uchwyt analizowanej tabeli.
::        _b  [DATE]    - Początek okresu (data od).
::        _c  [DATE]    - Koniec okresu (data do).
::       [_d] [STRING]  - Akronim pola - początku okresu [domyślnie: 'OD'].
::       [_e] [STRING]  - Akronim pola - końca okresu [domyślnie: 'DO'].
::       [_f] [ARRAY]   - Tablica z dodatkowymi parametrami.
::                        Dla _a=N
::                            NB       - Wskazanie rubryki;
::                            PARTDAY  - Czy nieobecność na część dnia?
::   WY: 0 - Brak konfliktu.
::       1 - Konflikt.
::----------------------------------------------------------------------------------------------------------------------
_TAB:=obj_new('TAB','OD','DO');
{? var_pres('_a')=type_of(SYSLOG)
|| _TAB.TAB:=_a
|| return(1)
?};

_d0:=date(0,0,0);
{? var_pres('_b')=type_of(_d0)
|| _od:=_b
|| return(1)
?};
{? var_pres('_c')=type_of(_d0)
|| _do:=_c
|| return(1)
?};

{? var_pres('_d')<>type_of('')
|| _d:='OD'
?};
{? var_pres(_d,_TAB.TAB)=21
|| _TAB.OD:=($('_a.'+_d))(_TAB.TAB)
|| return(1)
?};
{? var_pres('_e')<>type_of('')
|| _e:='DO'
?};
{? var_pres(_e,_TAB.TAB)=21
|| _TAB.DO:=($('_a.'+_e))(_TAB.TAB)
|| return(1)
?};

{? (_TAB.TAB=H | _TAB.TAB=H_UM) & _TAB.DO=_d0 & _TAB.OD<_od || 0
|? _TAB.OD=_d0 | _do=_d0 || _od<=_TAB.DO | _od=_d0 | _TAB.DO=_d0
|? _TAB.DO=_d0 | _od=_d0 || _TAB.OD<=_do | _do=_d0 | _TAB.OD=_d0
|? _TAB.TAB=N
|| {? (__RUB.sys_attr(N.NB,122722) | __RUB.sys_attr(N.NB,122742)) &
::    ^ Bieżąca nieobecność jest urlopem macierzyńskim typu praca i
::    v sprawdzana nieobecność nie jest urlopem macierzyńskim, bezpłatnym, wychowawczym, służbą wojskową.
      var_pres('_f')>100 & var_pres('NB',_f)=type_of(null())
      &
      ~(__RUB.sys_attr(_f.NB,1227) | __RUB.sys_attr(_f.NB,112) | __RUB.sys_attr(_f.NB,114) | __RUB.sys_attr(_f.NB,1323))
   || 0
   |? var_pres('_f')>100 & var_pres('NB',_f)=type_of(null()) &
      (__RUB.sys_attr(_f.NB,122722) | __RUB.sys_attr(_f.NB,122742)) &
::    ^ Sprawdzana nieobecność jest urlopem macierzyńskim typu praca i
::    v bieżąca nieobecność nie jest urlopem macierzyńskim, bezpłatnym, wychowawczym, służbą wojskową.
      ~(__RUB.sys_attr(N.NB,1227) | __RUB.sys_attr(N.NB,112) | __RUB.sys_attr(N.NB,114) | __RUB.sys_attr(N.NB,1323))
   || 0
   |? _od=N.OD & _do=N.DO & N.PARTDAY='T' & var_pres('_f')>100 & var_pres('PARTDAY',_f)=type_of('') & _f.PARTDAY='T'
::    ^ Nieobecność sprawdzana i bieżąca dotyczą tego samego okresu (dnia) i obie są na część dnia.
   || 0
   || _od<=N.DO & _do>=N.OD
   ?}
|| _od<=_TAB.DO & _do>=_TAB.OD
?}


\check
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Sprawdzenie rozłączności przedziałów czasowych. Formuła weryfikuje, czy okres wyznaczony datami w buforze
::       tabeli nie koliduje z okresami wyznaczonymi przez daty w rekordach na dysku.
::       Formuła do wykorzystania w akcji "Rekord - po" zarówno dla akcji typu "Dołącz" jak i "Popraw".
::       Uwagi.
::        - Przed wywołaniem bieżącej formuły należy zweryfikować wypełnienie pola z początkiem okresu, a jeżeli okres
::          nie może być otwarty - również pola z końcem okresu.
::        - Poprawność pól związanych z nakładanym prefiksem nie jest weryfikowana.
::   WE:  _a  [REFERENCE] - Ref poprawianego rekordu lub null() jeżeli rekord jest tworzony.
::        _b  [TABLE]     - Uchwyt analizowanej tabeli.
::       [_c] [STRING]    - Akronim pola - początku okresu [domyślnie: 'OD'].
::       [_d] [STRING]    - Akronim pola - końca okresu [domyślnie: 'DO'].
::       [_e] [INTEGER]   - Sposób obsługi komunikatów:
::             0 - Tradycyjny [domyślnie];
::             1 - Bez komunikatów (wynikiem będzie akronim pola);
::             2 - Bez komunikatów (wynikiem będzie tekst komunikatu).
::       [_f] [FORMULA]   - Dodatkowy warunek sprawdzany na poziomie badanych rekordów [domyślnie: "1"].
::       [_g] [REFERENCE] - Wskazanie rubryki - parametr opcjonalny, wykorzystywany dla _b=N.
::        _h  [STRING]    - Akronim indeksu według którego ma odbywać się sprawdzenie.
::       [_i] [ANY]       - Kolejne wartości wchodzące w skład prefiksu (parametry opcjonalne).
::       [_j] [ANY]       - Kolejne wartości wchodzące w skład prefiksu (parametry opcjonalne).
::       [_k] [ANY]       - Kolejne wartości wchodzące w skład prefiksu (parametry opcjonalne).
::       [_l] [ANY]       - Kolejne wartości wchodzące w skład prefiksu (parametry opcjonalne).
::       [_m] [ANY]       - Kolejne wartości wchodzące w skład prefiksu (parametry opcjonalne).
::       [_n] [ANY]       - Kolejne wartości wchodzące w skład prefiksu (parametry opcjonalne).
::       [_?] [ANY]       - Kolejne wartości wchodzące w skład prefiksu (parametry opcjonalne).
::   WY: 0 - Błędne argumenty wywołania (w szczególności pola OD i DO są nieredagowalne).
::       Akronim pola z początkiem okresu (jeżeli jest redagowalne) lub
::       akronim pola z końcem okresu (jeżeli jest redagowalne) w przypadku błędu lub konfliktu dat.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _ref:=_a
|| return(0)
?};
{? var_pres('_b')=type_of(SYSLOG)
|| _TAB:=_b
|| return(0)
?};
{? var_pres('_c')<>type_of('')
|| _c:='OD'
?};
{? var_pres(_c,_TAB)=21
|| _od:=obj_new('acr','val','name');
   _od.acr:=_c;
   _od.val:=($('_a.'+_od.acr))(_TAB)
|| return(0)
?};
{? var_pres('_d')<>type_of('')
|| _d:='DO'
?};
{? var_pres(_d,_TAB)=21
|| _do:=obj_new('acr','val','name');
   _do.acr:=_d;
   _do.val:=($('_a.'+_do.acr))(_TAB)
|| return(0)
?};
_batch:={? var_pres('_e')=type_of(0) || _e ?};
_war:={? var_pres('_f')=type_of("") || _f || "1" ?};
_par:={? var_pres('_g')>0 || _g || ~~ ?};
{? var_pres('_h')=type_of('')
|| _NDX:=_h
|| return(0)
?};

_fret:=
   {? _batch
   || "_a"
   || "exec('alert','overlap',_a); _b"
   ?};


{? _do.val<>date(0,0,0) & _od.val>_do.val
|| {! _lp:=1 .. _TAB.fld_num()
   |? _od.name=~~ | _do.name=~~
   |! _acr:=_TAB.fld_acr(_lp);
      {? _od.acr=_acr
      || _od.name:=_TAB.fld_name(_lp)
      |? _do.acr=_acr
      || _do.name:=_TAB.fld_name(_lp)
      ?}
   !};
   return(_fret('"%1" nie może być wcześniejsza niż "%2".'@ [_do.name,_od.name],_od.acr))
?};

_err:='';
_TAB.cntx_psh();
_TAB.index(_NDX);
{? _<9
|| _TAB.prefix()
|| _prfx:='';
   _arr:=obj_new(_);
   {! _lp:=9 .. _
   |! _arr[_lp]:=_[_lp];
      _prfx+='_b['+$_lp+'],'
   !};
   {? type_of(_[_])<>type_of('') || _prfx:=_prfx-1 ?};
   ($('_a.prefix('+_prfx+')'))(_TAB,_arr)
?};
{? _TAB.first()
|| {!
   |? {? _war() & _TAB.ref()<>_ref & exec('is','overlap',_TAB,_od.val,_do.val,_od.acr,_do.acr,_par)
      || _err:=($('_a.'+_od.acr))(_TAB)$1+' - '+($('_a.'+_do.acr))(_TAB)$1
      ?};
      _err='' & _TAB.next()
   !};
   {? _err<>''
   || _err:=
         {? _ref=null()
         || 'W dołączanym zapisie okres: %1 - %2\nnie jest rozłączny z okresem: %3.'@ [$_od.val,$_do.val,_err]
         || 'W poprawianym zapisie okres: %1 - %2\nnie jest rozłączny z okresem: %3.'@ [$_od.val,$_do.val,_err]
         ?};
      {? ~_batch
      || exec('alert','overlap',_err)
      ?}
   ?}
?};
_TAB.cntx_pop();
{? _err=''
|| ''

|? _batch=2
|| _err

|? _val:=_TAB.fld_fml(_od.acr,'*BEFORE_EDIT')();
   ~(type_of(_val)=type_of(0) & _val=0)
|| _od.acr

|? _val:=_TAB.fld_fml(_do.acr,'*BEFORE_EDIT')();
   ~(type_of(_val)=type_of(0) & _val=0)
|| _do.acr

:: Jest błąd, daty OD i DO nie są redagowalne. Właściwie formuła nie powinna być wywołana. Zamiast spodziewanego
:: akronimu pola, zwrócimy 0.
|| 0
?}


\n
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [17.00]
:: OPIS: Sprawdzenie rozłączności przedziałów czasowych tabeli N.
::       Założenia takie jak dla funkcji \\check/overlap.fml.
::   WE:  _a  [REFERENCE] - Ref poprawianego rekordu lub null() jeżeli rekord jest tworzony.
::       [_b] [INTEGER]   - Tryb wsadowy (brak komunikatów):
::             0 - Nie [domyślnie];
::             1 - Tak.
::   WY: 0 - Błędne argumenty wywołania.
::       Akronim pola z początkiem okresu w przypadku błędu lub konfliktu dat.
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _ref:=_a
|| return(0)
?};
_batch:=var_pres('_b')=type_of(0) & _b;
_fld:="{? N.UW='T' & _a='DO' || 'DT' || _a ?}";

_par:=obj_new('NB','PARTDAY');
_par.NB:=N.NB;
_par.PARTDAY:=N.PARTDAY;

_ret:=exec('check','overlap',_ref,N,,,_batch,,_par,'NIEOBECN','N',N.P);
{? (type_of(_ret)=type_of(0) & ~_ret) | (type_of(_ret)=type_of('') & _ret<>'')
|| return(_fld(_ret))
?};

{? ~N.N_KOR
|| _ret:=exec('check','overlap',_ref,N,,,_batch,"N.RODZAJ<>'W'",,'NIEOBECN','T',N.P);
   {? (type_of(_ret)=type_of(0) & ~_ret) | (type_of(_ret)=type_of('') & _ret<>'')
   || return(_fld(_ret))
   ?}
?};

''


\h
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
::       RWR [12.30]
:: OPIS: Formuła sprawdza spójność dat H.OD i H.DO bieżącego rekordu.
::   WE:
::   WY: Akronim pola do poprawy ('OD' lub 'DO') lub
::       1 - Dane są wypełnione prawidłowo, lub
::       0 - Dane nie są wypełnione prawidłowo, ale żadne z pol 'OD', 'DO' nie jest dostępne do redakcji.
::----------------------------------------------------------------------------------------------------------------------
_kod:=H.KZ().KZ='Z';
_od:=H.OD;
_do:=H.DO;
_chk:=0;
{? H.DO<>#0 & H.OD>H.DO
|| exec('alert','overlap');
   {? H.fld_fml('OD','*BEFORE_EDIT')() || 'OD'
   |? H.fld_fml('DO','*BEFORE_EDIT')() || 'DO'
:     OD i DO są nieredagowalne
   || 0
   ?}
|? H.cntx_psh();
   H.index('_HISTDAT');
   H.prefix(P.ref());
   {? H.first()
   || {!
      |? {? {? _kod || H.KZ().KZ='Z' || H.KZ().KZ<>'Z' ?} & H.ref()<>VAR.H
         || _chk+=exec('is','overlap',H,_od,_do)
         ?};
         H.next() & ~_chk
      !}
   ?};
   H.cntx_pop();
   _chk
|| exec('alert','overlap');
   {? H.fld_fml('OD','*BEFORE_EDIT')() || 'OD'
   |? H.fld_fml('DO','*BEFORE_EDIT')() || 'DO'
:     OD i DO są nieredagowalne
   || 0
   ?}
|? {? ~_kod
   || N.cntx_psh();
      N.index('NIEOBECN');
      N.prefix('N',P.ref());
      {? N.first()
      || {! |? _chk+=exec('is','overlap',N,_od,_do); N.next() & ~_chk !}
      ?};
      N.cntx_pop();
      _chk
   ?}
|| exec('alert','overlap',
        '\n'+'Wprowadzono nieprawidłowe daty.'@+
        '\n'+'(konflikt z nieobecnościami)'@+'\n'
   );
   {? H.fld_fml('OD','*BEFORE_EDIT')() || 'OD'
   |? H.fld_fml('DO','*BEFORE_EDIT')() || 'DO'
:     OD i DO są nieredagowalne
   || 0
   ?}
|| 1
?}


\os_zwpod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: DG [12.51]
:: OPIS: Sprawdzenie czy nie pokrywaja sie zwolnienia podatkowe
::   WE: [_a] [STRING] - Znacznik operacji (D-dołącz / P-popraw, domyślnie 'P')
::       [_b] zastrzeżone (Xpertis)
::       [_c] zastrzeżone (Xpertis)
::   WY:
::----------------------------------------------------------------------------------------------------------------------
_action:={? var_pres('_a')=type_of('') || _a || 'P' ?};
_od:=OS_ZWPOD.D_OB;
_ref:={? _action='P' || OS_ZWPOD.ref() || null() ?};
OS_ZWPOD.cntx_psh();
_ret:=1;
_firma:=exec('ref_firma','ustawienia');
{? OS_ZWPOD.REZYGN<>'T'
|| {? OS_ZWPOD.OS_ZWSLO().KOD='ZWPOD'
   || OS_ZWPOD.index('TYP');
      OS_ZWPOD.prefix(_firma,P.OSOBA,OS_ZWPOD.OS_ZWSLO);
      {? OS_ZWPOD.find_le(OS_ZWPOD.D_OB)
      || {? {? _ref=OS_ZWPOD.ref() || OS_ZWPOD.prev() || 1 ?}
         || {! |? {? OS_ZWPOD.AKTYWNY='N' || OS_ZWPOD.prev() ?} !};
            {? OS_ZWPOD.AKTYWNY='T'
            || {? OS_ZWPOD.REZYGN='T'
               || _ret:=0
               ?}
            ?}
         || _ret:=0
         ?}
      || _ret:=0
      ?}
   || _ret:=+exec('os_zwpod_find','overlap',OS_ZWPOD.D_OB,_ref)
   ?}
|| OS_ZWPOD.index('TYP');
   OS_ZWPOD.prefix(_firma,P.OSOBA,OS_ZWPOD.OS_ZWSLO);
   {? OS_ZWPOD.find_le(OS_ZWPOD.D_OB)
   || {? {? _ref=OS_ZWPOD.ref() || OS_ZWPOD.prev() || 1 ?}
      || {! |? {? OS_ZWPOD.AKTYWNY='N' || OS_ZWPOD.prev() ?} !};
         {? OS_ZWPOD.AKTYWNY='T'
         || {? OS_ZWPOD.REZYGN<>'T'
            || _ret:=0
            ?}
         ?}
      ?}
   ?}
?};
OS_ZWPOD.cntx_pop();
_ret


\os_zwpod_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.51]
:: OPIS: Wyszukanie istniejącego zapisu aktywnego na dany dzień. Nie dotyczy młodych pracowników.
::   WE: _a [data] - data wyszukiwania
::       [_b] [REFERENCE] - bez rekordu poprawianego
::       [_c] [STRING] - kod płatnika
::       [_d] [INTEGER] - 1 - dla młodego pracownika
::   WY: STRING - kod płatnika lub pusty ciąg znaków jeśli nie znaleziono
::----------------------------------------------------------------------------------------------------------------------
_data_badania:={? var_pres('_a')=type_of(date()) || _a || return('') ?};
_ref:={? var_pres('_b')=type_of(null()) || _b || null() ?};
_platnik:={? var_pres('_c')=type_of('') || _c || '' ?};
_rok:=_a~1;
_ret:='';
_data_pom:=#0;
_mp:={? var_pres('_d')=type_of(0) || _d ?};
_firma:=exec('ref_firma','ustawienia');

{? _platnik=''
|| _tab:=sql('
         select OS_ZWPOD.REFERENCE REF, OS_ZWPOD.D_OB D_OB, \'\' PLATNIK
         from  OS_ZWPOD join OS_ZWSLO join OSOBA
         where OS_ZWPOD.AKTYWNY=\'T\' and OS_ZWPOD.DOK_WYC=0 and
               OS_ZWPOD.REFERENCE <> :_a and OS_ZWPOD.OSOBA = :_b and OS_ZWPOD.D_OB <= to_date(:_c) and
               OS_ZWPOD.FIRMA = :_d',
         _ref,P.OSOBA,_data_badania,_firma
         )
||
   _tab:=sql('
         select OS_ZWPOD.REFERENCE REF, OS_ZWPOD.D_OB D_OB, SLO_KOD.KOD PLATNIK
         from  OS_ZWPOD join OS_ZWSLO join OSOBA left join OS_GRPRZ left join
               SLO_KOD using(OS_GRPRZ.SLO_KOD,SLO_KOD.REFERENCE)
         where OS_ZWPOD.AKTYWNY=\'T\' and  OS_ZWPOD.DOK_WYC=0 and
               (SLO_KOD is null or SLO_KOD.KOD = \':_d\') and
               OS_ZWPOD.REFERENCE <> :_a and OS_ZWPOD.OSOBA = :_b and
               OS_ZWPOD.D_OB <= to_date(:_c) and
               OS_ZWPOD.FIRMA = :_e',
         _ref,P.OSOBA,_data_badania,_platnik,_firma
         )
?};
_wynik:=0;
OS_ZWPOD.cntx_psh();
OS_ZWPOD.index('DOK_WYC');
OS_ZWPOD.prefix(_firma);
{? _tab.first()
|| {!
   |? _ZWPOD_ref:=BIT.sqlint(_tab.REF);
      {? OS_ZWPOD.seek(_ZWPOD_ref)
      || {? _mp & OS_ZWPOD.OS_ZWSLO().KOD='ZWPOD'
         || {? OS_ZWPOD.find_key(_ZWPOD_ref)
            || {? OS_ZWPOD.D_OB>_data_badania
               || _ret:='ZWPOD'
               ?}
            || _ret:='ZWPOD'
            ?}
         |? ~_mp & OS_ZWPOD.OS_ZWSLO().KOD<>'ZWPOD'
         || {? OS_ZWPOD.ROK_Z=0 | OS_ZWPOD.ROK_Z>=_data_badania~1
            || {? OS_ZWPOD.find_key(_ZWPOD_ref)
               || {? OS_ZWPOD.D_OB>_data_badania
                  || _wynik:=1
                  ?}
               || _wynik:=1
               ?};
               {? _wynik & OS_ZWPOD.seek(_ZWPOD_ref)
               || {? exec('czy_aktywna_umowa','osoba',P.OSOBA,_data_badania,OS_ZWPOD.ref(),_platnik)
                  || _ret:=OS_ZWPOD.OS_ZWSLO().KOD
                  || _wynik:=0
                  ?}
               ?}
            ?}
         ?}
      ?};
      ~_wynik & _tab.next()
   !}
?};
OS_ZWPOD.cntx_pop();
_ret


\os_zwzal_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: PK [12.51]
:: OPIS: Wyszukanie istniejącego zapisu wniosku aktywnego na dany dzień. Nie dotyczy młodych pracowników.
::   WE: _a [data] - data wyszukiwania
::       [_b] [REFERENCE] - bez rekordu poprawianego
::       [_c] [STRING] - kod płatnika
::       [_d] [STRING] - kod wniosku
::   WY: STRING - kod płatnika lub pusty ciąg znaków jeśli nie znaleziono
::----------------------------------------------------------------------------------------------------------------------
_data_badania:={? var_pres('_a')=type_of(date()) || _a || return('') ?};
_ref:={? var_pres('_b')=type_of(null()) || _b || null() ?};
_platnik:={? var_pres('_c')=type_of('') || _c || '' ?};
_wniosek:={? var_pres('_d')=type_of('') || _d || '' ?};
_rok:=_a~1;
_ret:='';
_data_pom:=#0;
_firma:=exec('ref_firma','ustawienia');

{? _platnik=''
|| _sql:='select OS_ZWZAL.REFERENCE REF, OS_ZWZAL.D_OB D_OB, \'\' PLATNIK '
         'from  OS_ZWZAL join OS_ZWSLO using(OS_ZWZAL.OS_ZWSLO, OS_ZWSLO.REFERENCE) join '
         '      OSOBA using(OS_ZWZAL.OSOBA,OSOBA.REFERENCE) '
         'where OS_ZWZAL.AKTYWNY=\'T\' and OS_ZWZAL.DOK_WYC=0 and '
         '      OS_ZWZAL.REFERENCE <> :_a and OS_ZWZAL.OSOBA = :_b and OS_ZWZAL.D_OB <= to_date(:_c) and '
         '      OS_ZWZAL.FIRMA = :_d and (OS_ZWSLO.DO_OB is null or OS_ZWSLO.DO_OB>=to_date(:_c)) ';
   {? _wniosek<>'' || _sql+=' and OS_ZWSLO.KOD = \':_e\' ' ?};
   _tab:=sql(_sql,_ref,P.OSOBA,_data_badania,_firma,_wniosek)
|| _sql:='select OS_ZWZAL.REFERENCE REF, OS_ZWZAL.D_OB D_OB, SLO_KOD.KOD PLATNIK '
         'from  OS_ZWZAL join OS_ZWSLO using(OS_ZWZAL.OS_ZWSLO, OS_ZWSLO.REFERENCE) join '
         '      OSOBA using(OS_ZWZAL.OSOBA,OSOBA.REFERENCE) left join '
         '      OS_GRPRZ using(OS_ZWZAL.REFERENCE, OS_GRPRZ.OS_ZWZAL) left join '
         '      SLO_KOD using(OS_GRPRZ.SLO_KOD,SLO_KOD.REFERENCE) '
         'where OS_ZWZAL.AKTYWNY=\'T\' and  OS_ZWZAL.DOK_WYC=0 and '
         '      (OS_GRPRZ.SLO_KOD is null or SLO_KOD.KOD = \':_d\') and '
         '      OS_ZWZAL.REFERENCE <> :_a and OS_ZWZAL.OSOBA = :_b and '
         '      OS_ZWZAL.D_OB <= to_date(:_c) and OS_ZWZAL.FIRMA = :_e and '
         '      (OS_ZWSLO.DO_OB is null or OS_ZWSLO.DO_OB>=to_date(:_c)) ';
  {? _wniosek<>'' || _sql+=' and OS_ZWSLO.KOD = \':_f\' ' ?};
  _tab:=sql(_sql,_ref,P.OSOBA,_data_badania,_platnik,_firma,_wniosek)
?};
_wynik:=0;
OS_ZWZAL.cntx_psh();
OS_ZWZAL.index('DOK_WYC');
OS_ZWZAL.prefix(_firma);
{? _tab.first()
|| {!
   |? _ZWPOD_ref:=BIT.sqlint(_tab.REF);
      {? OS_ZWZAL.seek(_ZWPOD_ref)
      || {? OS_ZWZAL.OS_ZWSLO().KOD<>'ZWPOD'
         || {? OS_ZWZAL.ROK=0 | OS_ZWZAL.ROK=_data_badania~1
            || {? OS_ZWZAL.find_key(_ZWPOD_ref)
               || {? OS_ZWZAL.D_OB>_data_badania
                  || _wynik:=1
                  ?}
               || _wynik:=1
               ?};
               {? _wynik & OS_ZWZAL.seek(_ZWPOD_ref)
               || {? exec('czy_aktywna_umowa','osoba',P.OSOBA,_data_badania,OS_ZWZAL.ref(),_platnik)
                  || _ret:=OS_ZWZAL.OS_ZWSLO().KOD
                  || _wynik:=0
                  ?}
               ?}
            ?}
         ?}
      ?};
      ~_wynik & _tab.next()
   !}
?};
OS_ZWZAL.cntx_pop();
_ret


\ppsf_po
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.51]
::  MOD: MicKoc [22.26]
:: OPIS: Weryfikacja (nie)pokrywania się okresów. Formuła zakłada prawidłowo wypełniony bufor tabeli.
::   WE: [_a] [NUMBER] - Specyfikacja testu:
::             0 - Dołącz [domyślnie];
::             1 - Popraw.
::       [_b] [NUMBER] - Rodzaj i typ wyniku:
::             0 - Rezultat weryfikacji [0/1] [domyślnie];
::             1 - Komunikat o błędzie lub ''.
::   WY: Czy zapis jest konfliktowy?
::       w zależności od parametru _b funkcja zwraca:
::          [0/1] - wartość liczbową
::          ''    - komunikat błędu
::  OLD: \ppsf_po/overlap.fml
::----------------------------------------------------------------------------------------------------------------------
_put:=var_pres('_a')=type_of(0) & _a;
_ret_kom:=var_pres('_b')=type_of(0) & _b;

_od:=PPSF_PO.OD;
_do:=PPSF_PO.DO;
_ref:={? _put || PPSF_PO.ref() || null() ?};

_ret:='';
PPSF_PO.cntx_psh();
PPSF_PO.index('UNIQUE');
PPSF_PO.prefix(PPSF_PO.PPSF_NO,PPSF_PO.P);
{? PPSF_PO.first()
|| {!
   |? {? _ref<>PPSF_PO.ref()
      || {? exec('is','overlap',PPSF_PO,_od,_do)
         || _ret:='Okres obowiązywania oświadczenia nie jest rozłączny z istniejącymi zapisami (%1 - %2).'@
                  [PPSF_PO.OD$1,PPSF_PO.DO$1]
         ?}
      ?};
      _ret='' & PPSF_PO.next()
   !}
?};
PPSF_PO.cntx_pop();
{? _ret_kom
|| return(_ret)

|? _ret<>''
|| __CHK.err_msg('err_msg');
   1
?}


\nwopo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: IS [12.51]
:: OPIS: Weryfikacja (nie)pokrywania się okresów. Formuła zakłada prwidłowo wypełniony bufor tabeli.
::   WE: [_a] [NUMBER] - Specyfikacja testu:
::             0 - Dołącz [domyślnie];
::             1 - Popraw.
::       [_b] [NUMEBR] - 0*/1 Czy brać po uwagę zapisy niezweryfikowane?
::       [_c] [NUMBER] - Rodzaj i typ wyniku:
::             0 - Rezultat weryfikacji [0/1] [domyślnie];
::             1 - Komunikat o błędzie lub ''.
::   WY: Czy zapis jest konfliktowy?
::       w zależności od parametru _b funkcja zwraca:
::          [0/1] - wartość liczbową
::          ''    - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
_put:=var_pres('_a')=type_of(0) & _a;
_sprNieZwer:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_ret_kom:={? var_pres('_c')=type_of(0) || _c || 0 ?};
_od:=NWOPO.OD;
_do:=NWOPO.DO;

_ref:={? _put || NWOPO.ref() || null() ?};

_chk:={? _ret_kom || '' || 0 ?};
NWOPO.cntx_psh();
NWOPO.index('POD');
NWOPO.prefix(NWOPO.P);
{? NWOPO.first()
|| {!
   |? {? _ref<>NWOPO.ref() & (_sprNieZwer | NWOPO.AZ='T')
      || {? exec('is','overlap',NWOPO,_od,_do)
         || _text:='Okres obowiązywania oświadczenia nie jest rozłączny z istniejącymi zapisami (%1 - %2).'@
                  [NWOPO.OD$1,NWOPO.DO$1];
            {? _ret_kom
            || _chk:=_text
            || __CHK.err_msg(_text);
               _chk:=1
            ?}
         ?}
      ?};
      {? _ret_kom || _chk='' || _chk=0 ?} & NWOPO.next()
   !}
?};
NWOPO.cntx_pop();
_chk


\ppsf_adr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RWR [12.51]
:: OPIS: Weryfikacja (nie)pokrywania się okresów. Formuła zakłada prawidłowo wypełniony bufor tabeli.
::   WE: [_a] [NUMBER] - Specyfikacja testu:
::             0 - Dołącz [domyślnie];
::             1 - Popraw.
::       [_b] [NUMBER] - Rodzaj i typ wyniku:
::             0 - Rezultat weryfikacji [0/1] [domyślnie];
::             1 - Komunikat o błędzie lub ''.
::             2 - null lub ref kolidującego zapisu
::   WY: Czy zapis jest konfliktowy?
::       w zależności od parametru _b funkcja zwraca:
::          [0/1] - wartość liczbową
::          ''    - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
_put:=var_pres('_a')=type_of(0) & _a;
_ret_kom:={? var_pres('_b')=type_of(0) & _b>0 || _b || 0 ?};

_ret:='';
_ret_ref:=null();
PPSF_TA.cntx_psh();
PPSF_TA.prefix();
{? PPSF_ADR.A='T' & PPSF_ADR.TYP().K='T'
|| _od:=PPSF_ADR.OD;
   _do:=PPSF_ADR.DO;
   _ref:={? _put || PPSF_ADR.ref() || null() ?};
   PPSF_ADR.cntx_psh();
   PPSF_ADR.index('PRAC_TA');
   PPSF_ADR.prefix(PPSF_ADR.P,PPSF_ADR.TYP,'T',);
   {? PPSF_ADR.first()
   || {!
      |? {? _ref<>PPSF_ADR.ref()
         || {? exec('is','overlap',PPSF_ADR,_od,_do)
            || _ret_ref:=PPSF_ADR.ref();
               _ret:=
                  'Okres obowiązywania adresu nie jest rozłączny z istniejącymi zapisami (%1 - %2).'@
                  [PPSF_ADR.OD$1,PPSF_ADR.DO$1]
            ?}
         ?};
         _ret='' & PPSF_ADR.next()
      !}
   ?};
   PPSF_ADR.cntx_pop()
?};

PPSF_TA.cntx_pop();
{? _ret_kom=1
|| return(_ret)

|? _ret_kom=2
|| return(_ret_ref)

|? _ret<>''
|| __CHK.err_msg(_ret);
   1
?}


\ppsf_h
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TMR [12.51]
:: OPIS: Weryfikacja (nie)pokrywania się okresów. Formuła zakłada prawidłowo wypełniony bufor tabeli.
::   WE: [_a] [NUMBER] - Specyfikacja testu:
::             0 - Dołącz [domyślnie];
::             1 - Popraw.
::       [_b] [NUMBER] - Rodzaj i typ wyniku:
::             0 - Rezultat weryfikacji [0/1] [domyślnie];
::             1 - Komunikat o błędzie lub ''.
::   WY: Czy zapis jest konfliktowy?
::       w zależności od parametru _b funkcja zwraca:
::          [0/1] - wartość liczbową
::          ''    - komunikat błędu
::----------------------------------------------------------------------------------------------------------------------
_put:=var_pres('_a')=type_of(0) & _a;
_ret_kom:=var_pres('_b')=type_of(0) & _b;

_ref:={? _put || PPSF_H.ref() || null() ?};
_ret:='';

_d0:=#0;
_max_date:=date(9999,12,0);
_odCur:=PPSF_H.OD;
_doCur:={? PPSF_H.DO=_d0
        || _max_date
        || {? PPSF_H.WYC_DATA<>_d0 || PPSF_H.WYC_DATA || PPSF_H.DO ?}
        ?};

PPSF_H.cntx_psh();
PPSF_H.index('PRAC');
PPSF_H.prefix(PPSF_H.P);
{? PPSF_H.first()
|| {!
   |? {? _ref<>PPSF_H.ref()
      || {? _doCur<PPSF_H.OD |
            _odCur>{? PPSF_H.DO=_d0 || _max_date || {? PPSF_H.WYC_DATA<>_d0 || PPSF_H.WYC_DATA || PPSF_H.DO ?} ?}
         || _loop:=PPSF_H.next()
         || _ret:=
               {? PPSF_H.WYC='T'
               || 'Istnieje już zapis dotyczący pracy zdalnej w okresie od %1 do %2\nz datą wycofania: %3.'@
                  [$PPSF_H.OD,$PPSF_H.DO,$PPSF_H.WYC_DATA]
               || 'Istnieje już zapis dotyczący pracy zdalnej w okresie od %1 do %2.'@
                  [$PPSF_H.OD,$PPSF_H.DO]
               ?};
            _loop:=0
         ?}
      || _loop:=PPSF_H.next()
      ?};
      _loop
   !}
?};
PPSF_H.cntx_pop();

{? _ret_kom
|| return(_ret)

|? _ret<>''
|| __CHK.err_msg(_ret);
   1
?}

:Sign Version 2.0 jowisz:1045 2023/08/25 11:56:13 d1d74183349dacf162e1ac9feb9f0ebfaf71a418df34bdc58dc8e3183ffd112e6b02aa7f9fff31dc238f542d47a449f98e9f354aeefac5174c214823e2df8a8c5b9b21d82ed42d5b8f06182da40429336761f88373d241aa5565f213c52140d0e5fccd8763fedef5c65529ce0d366a095febf8a9ce4a6f2c080977d97dfddc7f
