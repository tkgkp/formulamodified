:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: kalkulator.fml
:: Utworzony: 11.05.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Obsługa funkcji kalkulacyjnych (kalkulacje TKW, wstępne kalkulacje zleceń, analizy zleceń)
::            Plik biblioteczny - wspólna obsługa dla TTE_TEC, TTE_PZL
::======================================================================================================================


\declare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JM [7.22]
:: OPIS: Deklaracja obiektu kalkulacyjnego
::  OLD: \anka_dekl/prodobi.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('ANKA',@.CLASS)<=0
||
   obj_decl('ANKA',
      obj_fld('ME'      ,"Wskazanie na samego siebie"),
      obj_fld('prog',    ('czy wyświetlać progress';0)),
      obj_fld('L',       ('rubryki               ';0)),
      obj_fld('F',       ('formuły               ';0)),
      obj_fld('S',       ('stałe                 ';0)),
      obj_fld('G',       ('wykorzystane          ';0)),
      obj_fld('R',       ('ref''y rubryk         ';0)),
      obj_fld('H',       ('z palucha             ';0)),
      obj_fld('M',       ('ręcznie zmodyfikowane ';0)),
      obj_fld('V',       ('wartości przed przel. ';0)),
      obj_fld('ROB',     ('robocizna             ';0)),
      obj_fld('GODZ',    ('godziny               ';0)),
      obj_fld('HOUR',    ('godziny ogółem        ';0)),
      obj_fld('USL',     ('usługi                ';0)),
      obj_fld('WRK',     ('koszt stanowiska      ';0)),
      obj_fld('MAT',     ('materiały             ';0)),
      obj_fld('TOOL',    ('n-p-u                 ';0)),
      obj_fld('FAZY',    ('fazy                  ';0)),
      obj_fld('FAZYt',   ('fazy tabela           ';0)),
      obj_fld('EXTRA',   ('dodatkowe koszty      ';0)),
      obj_fld('KALK',    ('ref kalkulacji/analizy';0)),
      obj_fld('KTL'     ,"ref technologii TKTL";null()),
      obj_fld('MAX',     ('długość tabel         ';0)),
      obj_fld('WST',     ('ilość obliczeń wstecz ';0)),
      obj_fld('WSTr',    ('wstecz - realne       ';0)),
      obj_fld('POZ',     ('aktualna pozycja      ';0)),
      obj_fld('STR',     ('aktualne wywołanie MATA';'')),
      obj_fld('NEXT_POZ',('następna pozycja      ';0)),
      obj_fld('ERR',     ('wystąpienie błędu     ';0)),
      obj_fld('AM',      ('aktualny okres        ';0)),
      obj_fld('X',       ('ilość do wykon lub XJM';0)),
      obj_fld('pTMAT'   ,"kiedys pTMAT, teraz w obiekcie"),
      obj_fld('KalAna'  ,'Komunikat dla .echo()';''),
      obj_fld('Header'  ,'Nagłówek (.win_esep) w oknach wyświetlanych podczas obliczeń';''),
      obj_fld('Desc'    ,'Opis pod nagłówkiem w oknach wyświetlanych podczas obliczeń';''),
      obj_fld('SAVE'    ,"flaga określająca czy wyniki kalkulacji mają się zapisać czy nie";0),
:      obj_fld('MOV'     ,"przesunięcie w log'u";0),
      obj_fld('anm'     ,"kiedys anXm";0),
      obj_fld('ant'     ,"kiedys anXt";0),
      obj_fld('anw'     ,"kiedys anXw";0),
      obj_fld('ano',                   0),
      obj_fld('anu',                   0),
      obj_fld('tpar'    ,"lokalnie w obiekcie parametry";0),
      obj_fld('run1m'   ,"znacznik pierwszego przebiegu funkcji m()";1),
      obj_fld('err'     ,"błędna wartość liczbowa"; -999999999999999999999999999999),

      obj_meth('__init',"_a.ME:=_a; _a.AM:=ST.AM; _a.prog:=1; 1"),

::======================================================================================================================
:: Metody prywatne
::======================================================================================================================

      obj_meth('mat_cost',"
::----------------------------------------------------------------------------------------------------------------------
         {? type_of(.MAT)<7 || return(0) ?};
         _wynik:=0;
         {? _a<>0 & _b<>0 & _c<>0 & _d<>0 & _e<>0 & _f<>0 & _g<>0 & _h<>0 & _i<>0 & _j<>0
         || _down_i:=_a; _up_i:=_b;
            _down_j:=_c; _up_j:=_d;
            _down_k:=_e; _up_k:=_f;
            _down_l:=_g; _up_l:=_h;
            _down_m:=_i; _up_m:=_j;
            {! _i:=(_down_i)..(_up_i)
            |! {! _j:=(_down_j)..(_up_j)
               |! {! _k:=(_down_k)..(_up_k)
                  |! {! _l:=(_down_l)..(_up_l)
                     |! {! _m:=(_down_m)..(_up_m)
                        |! _wynik+=.MAT[_i][_j][_k][_l][_m]
                        !}
                     !}
                  !}
               !}
            !}
         ?};
         _wynik
      ",1,1),

      obj_meth('scal_mat',"
         {? type_of(.MAT)<7
         || .MAT:=MAT1
         || {! _i:=(1)..(3)
            |! {! _j:=(1)..(2)
               |! {! _k:=(1)..(obj_len(.FAZY))
                  |! {! _l:=(1)..(2)
                     |! {! _m:=(1)..(2)
                        |! .MAT[_i][_j][_k][_l][_m]+=MAT1[_i][_j][_k][_l][_m]
                        !}
                     !}
                  !}
               !}
            !}
         ?}
      "),

      obj_meth('make_mat',"
         {? type_of(.MAT)<7
         || .MAT:=obj_new(3);
            {! _i:=1..3
            |! .MAT[_i]:=obj_new(2);
               {! _j:=1..2
               |! .MAT[_i][_j]:=obj_new(obj_len(.FAZY));
                  {! _k:=1..(obj_len(.FAZY))
                  |! .MAT[_i][_j][_k]:=obj_new(2);
                      {! _l:=1..2
                      |! .MAT[_i][_j][_k][_l]:=obj_new(2);
                         {! _m:=1..2
                         |! .MAT[_i][_j][_k][_l][_m]:=0
                         !}
                      !}
                  !}
               !}
            !}
         ?}
      "),

      obj_meth('make_tool',"
         {? type_of(.TOOL)<7
         || .TOOL:=obj_new(3);
            {! _i:=1..3
            |! .TOOL[_i]:=obj_new(obj_len(.FAZY));
               {! _j:=1..obj_len(.FAZY) |! .TOOL[_i][_j]:=0 !}
            !}
         ?}
      "),

      obj_meth('make_rob',"
         {? type_of(.ROB)<7
         || .ROB:=obj_new(obj_len(.FAZY));
            {! _i:=1..obj_len(.FAZY)
            |! .ROB[_i]:=obj_new(4); .ROB[_i][1]:=0; .ROB[_i][2]:=0; .ROB[_i][3]:=0; .ROB[_i][4]:=0
            !}
         ?};
         ~~
      "),

      obj_meth('scal_rob',"
         {? type_of(.ROB)<7
         || .ROB:=ROB1
         || {! _i:=(1)..(obj_len(.FAZY))
            |!
               {! _j:=1..4 |! .ROB[_i][_j]+=ROB1[_i][_j] !}
            !}
         ?}
      "),

      obj_meth('make_godz',"
         {? type_of(.GODZ)<7
         || .GODZ:=obj_new(obj_len(.FAZY));
            {! _i:=1..obj_len(.FAZY)
            |! .GODZ[_i]:=obj_new(4); .GODZ[_i][1]:=0; .GODZ[_i][2]:=0; .GODZ[_i][3]:=0; .GODZ[_i][4]:=0
            !}
         ?};
         ~~
      "),

      obj_meth('scal_godz',"
         {? type_of(.GODZ)<7
         || .GODZ:=GODZ1
         || {! _i:=(1)..(obj_len(.FAZY))
            |!
               {! _j:=1..4 |! .GODZ[_i][_j]+=GODZ1[_i][_j] !}
            !}
         ?}
      "),

      obj_meth('scal_hour',"
         {? type_of(.HOUR)<7
         || .HOUR:=HOUR1
         || {! _i:=(1)..(obj_len(.FAZY))
            |!
               {! _j:=1..4 |! .HOUR[_i][_j]+=HOUR1[_i][_j] !}
            !}
         ?}
      "),

      obj_meth('make_wrk',"
         {? type_of(.WRK)<7
         || .WRK:=obj_new(obj_len(.FAZY));
            {! _i:=1..obj_len(.FAZY)
            |! .WRK[_i]:=obj_new(4); .WRK[_i][1]:=0; .WRK[_i][2]:=0; .WRK[_i][3]:=0; .WRK[_i][4]:=0
            !}
         ?};
         ~~
      "),

      obj_meth('scal_wrk',"
         {? type_of(.WRK)<7
         || .WRK:=WRK1
         || {! _i:=(1)..(obj_len(.FAZY))
            |!
               {! _j:=1..4 |! .WRK[_i][_j]+=WRK1[_i][_j] !}
            !}
         ?}
      "),

      obj_meth('make_usl',"
         {? type_of(.USL)<7
         || .USL:=obj_new(obj_len(.FAZY));
            {! _i:=1..obj_len(.FAZY) |! .USL[_i]:=obj_new(2); .USL[_i][1]:=0; .USL[_i][2]:=0 !}
         ?};
         ~~
      "),

      obj_meth('scal_usl',"
         {? type_of(.USL)<7
         || .USL:=USL1
         || {! _i:=(1)..(obj_len(.FAZY))
            |!
               {! _j:=1..2 |! .USL[_i][_j]+=USL1[_i][_j] !}
            !}
         ?}
      "),

      obj_meth('uz_cost',"
         _wynik:=0;
         _param1:=_a;
         {? _param1<>''
         || _faza:=.seekpfaz(_param1);
            {? _faza<>(-1) || _wynik:=USL1[_faza][1] || _wynik:=0 ?}
         || {! i:=1..obj_len(.FAZY)
            |! _wynik+=USL1[i][1]
            !}
         ?};
         _wynik
      ",2),

      obj_meth('scal_tool',"
         {? type_of(.TOOL)<7
         || .TOOL:=TOOL1
         || {! _i:=(1)..(3)
            |! {! _j:=(1)..(obj_len(.FAZY))
               |! .TOOL[_i][_j]+=TOOL1[_i][_j]
               !}
            !}
         ?}
      "),

      obj_meth('tool_cost',"
         _wynik:=0;
         {? _a<>0&_b<>0&_c<>0&_d<>0
         || _down_i:=_a; _up_i:=_b;
            _down_j:=_c; _up_j:=_d;
            {! _i:=(_down_i)..(_up_i)
            |! {! _j:=(_down_j)..(_up_j)
               |! _wynik+=.TOOL[_i][_j]
               !}
            !}
         ?};
         _wynik
      ",1,1),

      obj_meth('t1cost',"
         _wynik:=0;
         {? _a<>0&_b<>0&_c<>0&_d<>0
         || _down_i:=_a; _up_i:=_b;
            _down_j:=_c; _up_j:=_d;
            {! _i:=(_down_i)..(_up_i)
            |! {! _j:=(_down_j)..(_up_j)
               |! _wynik+=TOOL1[_i][_j]
               !}
            !}
         ?};
         _wynik
      ",1,1),

      obj_meth('tzcost',"
::----------------------------------------------------------------------------------------------------------------------
::   Jak widac poniżej metoda zmienia zawartość 3 pierwszych parametrów wejściowych i UWAGA: zmienione oddaje wyżej.
::   _a - _mpr
::   _b - _tcst
::   _c - _stab
::   _d - całość zlecenia
::   _e - NPU od
::   _f - NPU do
::   _g - Faza od
::   _h - Faza do
::----------------------------------------------------------------------------------------------------------------------
         _i:=1;

         _mpr:=_a;
         _tcst:=_b;
         _stab:=_c;
         _p3:=_d;
         _d_i:=_e;
         _u_i:=_f;
         _d_j:=_g;
         _u_j:=_h;

         ZL.cntx_psh();
         {? ZL.first()
         || {!
            |? {? ZL.RTKTL<>'' || TOOL1:=exec('get_utils_price','kalk_tool',.ME,ZL.RTKTL)
               |? ZL.RKTL<>'' || TOOL1:=exec('get_utils_price','kalk_tool',.ME,ZL.RKTL)
               || ZL.cntx_pop(); return()
               ?};
               _mpr[_i]:={? ZL.IL
                         || {? _p3
                            || ZL.ILWYK
                            || .made()
                            ?}/ZL.IL
                         ?};

               _stab[1]+=_mpr[_i];
               _tcst[_i]:=.t1cost(_d_i,_u_i,_d_j,_u_j);
               _i+=1;
               obj_del(TOOL1);
               ZL.next()
            !}
         ?};
         ZL.cntx_pop()
      "),

      obj_meth('seekpfaz',"
         _k:=1;
         _nomore:=1;
         _seek:=_a;
         {!
         |? VAR.A_PFAZ:=.FAZY[_k];
            {? VAR.A_PFAZ().KOD <> _seek
            || _k+=1
            || _nomore:=0
            ?};
            (_k<=(obj_len(.FAZY)))&(_nomore=1)
         !};
         {? _nomore || -1 || _k ?}
      ",2),

      obj_meth('get_pfaz',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Ładowanie faz produkcyjnych
::----------------------------------------------------------------------------------------------------------------------
         .FAZYt:=sql('
                     SELECT
                        REFERENCE AS REF
                       ,KOD       AS KOD
                       ,0         AS LP
                     FROM
                       PFAZ
                     ORDER BY
                       KOD
                    ');
         _size:=.FAZYt.size();
         .FAZY:=obj_new(_size+1);
         _i:=0;
         {? .FAZYt.first()
         || {!
            |?
               _i+=1;
               PFAZ.seek(.FAZYt.REF,form(8+.FAZYt.REF));
               .FAZY[_i]:=PFAZ.ref();
               .FAZYt.LP:=_i;
               .FAZYt.put();
               .FAZYt.next()
            !}
         ?};
         .FAZY[_size+1]:=null();
         .FAZYt.REF:=16*'_';
         .FAZYt.KOD:='<brak>';
         .FAZYt.LP:=_size+1;
         .FAZYt.add()
      "),

: end of private methods [PK]

      obj_meth('echo',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Wyświetla przygotowany tekst
::----------------------------------------------------------------------------------------------------------------------
         _txtA:={? _>0 & type_of(_a)=2 || _a || '' ?};
         _txtB:={? _>1 & type_of(_b)=2 || _b || '' ?};
         echo(.KalAna+': '+_txtA,_txtB)
      "),

      obj_virt('load',"1"),

      obj_virt('save',"1"),

      obj_meth('calc__',"
         TKTL.cntx_psh();
         KKTL.cntx_psh();
         ANZH.cntx_psh();
         _error:=0;
         .POZ:=1;
         KOMM.sect_beg('Wykonywanie formuł — obliczanie wartości rubryk'@,,1);
         {? .prog>0
         || _fun:=obj_new(@.CLASS.FUN_CLASS);
            _fun.prg_start(.MAX,'Obliczanie kalkulacji'@)
         ?};
         _exit:=0;
         {!
         |?
            {? _exit | (var_pres('EXIT')>0 & EXIT>0)
            || _error:=1
            || .NEXT_POZ:=(.POZ+1);
               {? .F[.POZ]<>''
               || {? .prog>0
                  || _exit:=~_fun.prg_next(,'Trwa obliczanie: %1'@[form(.POZ)])
                  ?};
                  {? _exit>0
                  || {? var_pres('EXIT')>0
                     || EXIT:=1
                     ?}
                  ||
                     .echo('Trwa obliczanie rubryki: %1'@[form(.POZ)],'Proszę czekać...'@);
                     on_error();
                     on_error(1);

                     {? .M[.POZ]='T'
                     || _f:=.V[.POZ]
                     || _f:=($('{|_a|!'+.F[.POZ]+'|}'))(.ME)
                     ?};
                     {? .ERR
                     || _error:=1
                     |? (~in_error())
                     || {? (type_of(_f)=1)
                        || .set_l(.POZ,1,_f)
                        || {? type_of(_f)<>2
                           || KOMM.error('Błędny typ wyniku formuły obliczeniowej dla rubryki %1'@[form(.POZ)])
                           ?};
                           _error:=1
                        ?}
                     || KOMM.error('Błędna formuła obliczeniowa dla rubryki %1'@[form(.POZ)]);
                        _error:=1
                     ?}
                  ?}
               || 0
               ?}
            ?};
            .POZ:=.NEXT_POZ;
            (.POZ<=.MAX) & (_error=0)
         !};
         {? .prog>0
         || _fun.prg_stop()
         ?};
         on_error(0);
         echo();
         ANZH.cntx_pop();
         KKTL.cntx_pop();
         TKTL.cntx_pop();
         {? ~_error
         || KOMM.add('zakończone pomyślnie'@,1,'0:128:0,255,255,255')
         || KOMM.add('zakończone niepowodzeniem'@,2,'128:0:0,255,255,255')
         ?};
         KOMM.sect_end();
         ~_error
      "),

      obj_meth('calculate',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Uruchomienie kalkulacji
::   WE: _a - czy wyświetlać parametry do modyfikacji
::----------------------------------------------------------------------------------------------------------------------
         _shwp:={? _>=1 & type_of(_a)=1 || _a || 0 ?};
         _error:=0;
         {? .load()
         || {? _shwp & type_of(.tpar)>6 || .tpar.change(.Header,'Symbol',.Desc) ?};
            .calc__()
         || 0
         ?}
      "),

      obj_meth('set_l',"
         {? .G[_a]>0
         || .L[_b][_a]:=_c;
            .G[_a]:=2
         || KOMM.error('Próba zapisu do nieistniejącej rubryki %1'@[form(_a)])
         ?}
      "),

      obj_meth('msg_k',"KOMM.error('Błąd %1 parametru funkcji k():\n%2'@[_a,_b]); .ERR:=1; ~~"),

      obj_meth('alloc',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: alokuje struktury
::----------------------------------------------------------------------------------------------------------------------
         .L:=obj_new(.WST+1);
         {! _i:=1..(.WST+1)
         |! .L[_i]:=obj_new(.MAX);
            {! _j:=1..(.MAX) |! .L[_i][_j]:=0 !}
         !};
         .G:=obj_new(.MAX);
         .F:=obj_new(.MAX);
         .S:=obj_new(.MAX);
         .R:=obj_new(.MAX);
         .H:=obj_new(.MAX);
         .M:=obj_new(.MAX);
         .V:=obj_new(.MAX);
         {! _j:=1..(.MAX)
         |! .G[_j]:=.S[_j]:=.R[_j]:=.H[_j]:=.V[_j]:=0;
            .F[_j]:='';
            .M[_j]:='N'
         !};
         ~~
      "),

      obj_meth('ko',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Komunikat błędnego parametru
::----------------------------------------------------------------------------------------------------------------------
        KOMM.error('Błędny typ argumentu formuły obliczeniowej\ndla rubryki %1 parametr %2'@[form(.POZ),_a])
      "),

::======================================================================================================================
:: Funkcje/metody dostępne dla użytkownika
::======================================================================================================================

      obj_meth('l',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: l([p1],[p2],[o1],[o2]) - zwraca sumę wartości rubryk (po prostokącie od (p1,o1) do (p2,o2))
::----------------------------------------------------------------------------------------------------------------------
         .ERR:=0;
         _wyn:=0;

         _p1:={? _>0 & type_of(_a)=1 || _a || .POZ ?};
         _p2:={? _>1 & type_of(_b)=1 || _b || _p1  ?};

         _o1:={? _>2 & type_of(_c)=1 || _c || 0   ?};
         _o2:={? _>3 & type_of(_d)=1 || _d || _o1 ?};

         {? _>4 || KOMM.error('Zbyt duża liczba (%1) parametrów funkcji l()'@[$_]); .ERR:=1 ?};

         {?.ERR=0
         || {? _p1>_p2  || KOMM.error('pierwszy parametr musi być mniejszy od drugiego'@);.ERR:=1 ?};
            {? _o1>_o2  || KOMM.error('trzeci parametr musi być mniejszy od czwartego'@); .ERR:=1 ?};
            {? _p2>.MAX || KOMM.error('Odwołanie poza zakres (rubryki)'@);                .ERR:=1 ?};
            {? _o2>.WST || KOMM.error('Odwołanie poza zakres (poprzednie obliczenia)'@);  .ERR:=1 ?}
         ?};
         {? .ERR=0
         || {! _poz:=_p1.._p2
            |! {? .G[_poz]>0
               || {! _okr:=_o1.._o2
                  |! _wyn+=.L[_okr+1][_poz]
                  !}
               ?}
            !}
         ?};
         _wyn
      "),

      obj_meth('s',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: s(nr) - zwraca stałą o numerze nr
::----------------------------------------------------------------------------------------------------------------------
         {? _=1 & type_of(_a)=1 & _a>0 & (_a#0=_a)
         || .S[_a]
         || KOMM.error('Funkcja s() przyjmuje tylko jeden parametr — liczbę naturalną'@);
            ~~
         ?}
      "),

      obj_meth('get',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: get(text, default_value, precision) - zwraca pobraną od użytkownika wartość o nazwie text, wartości początkowej
::       default_value z dokładnością do precision
::----------------------------------------------------------------------------------------------------------------------
         _text:={? _>0 & type_of(_a)=2 || _a || '' ?};
         {? +_text<20 || _text+=(20-(+_text))*' ' ?};
         _dval:={? _>1 & type_of(_b)=1 || _b || .H[.POZ] ?};
         _prec:={? _>2 & type_of(_c)=1 || _c || 4 ?};

         _result:=_dval;
         _tab:=tab_tmp(,
            'WYN','REAL','Wartość wynikowa'@,
            'SYM','STRING[100]','Symbol'
         );
         _tab.SYM:=.Desc;
         _tab.WYN:=_dval;
         _red:=_tab.mk_edit(FUN.TYT,,'redget');
         _tab.win_esep(_red,.Header);
         _tab.win_efld(_red,,'SYM',,,100,,1);
         _tab.win_esep(_red,'Wartość'@);
         _tab.win_efld(_red,,'WYN',,,15,_prec,,_text);
         _tab.win_ebtn(_red,'text=%1'['Zapisz'@],'key:F2');
         _tab.win_ebtn(_red,'text=%1'['Anuluj'@],'key:Esc');
         _tab.win_edit(_red);
         {? _tab.edit()
         || .H[.POZ]:=_result:=_tab.WYN
         ?};
         _result
      "),

      obj_meth('jump2',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: jump2(nr) - określa następny wiersz do wykonania
::----------------------------------------------------------------------------------------------------------------------
         {? _>0 & .ERR=0 & type_of(_a)=1
         || {? _a<=.MAX
            || .NEXT_POZ:=_a
            || KOMM.error('Próba skoku poza zakres.'@);
               .ERR:=1
            ?}
         ?};
         0
      "),

      obj_virt('n',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Funkcja własna n() - NPU
::----------------------------------------------------------------------------------------------------------------------
         0
      "),

      obj_virt('r', "
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Funkcja własna r() - robocizna
::----------------------------------------------------------------------------------------------------------------------
         0
      "),

      obj_virt('g', "
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Funkcja własna g() - godziny
::----------------------------------------------------------------------------------------------------------------------
         0
      "),

      obj_virt('h', "
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Funkcja własna h() - godziny ogółem
::----------------------------------------------------------------------------------------------------------------------
         0
      "),

      obj_virt('u'       ,"0"),
      obj_virt('w'       ,"0"),
      obj_virt('mat'     ,"0"),
      obj_virt('robwyn'  ,"0"),
      obj_virt('godzwyn', "0"),
      obj_virt('hourwyn', "0"),
      obj_virt('rob'     ,"0"),
      obj_virt('usl'     ,"0"),
      obj_virt('wrk'     ,"0"),
      obj_virt('m'       ,"0"),
      obj_virt('made'    ,"0"),

      obj_meth('k', "
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Funkcja własna k() - pobiera wartości z kont księgowych
::----------------------------------------------------------------------------------------------------------------------
         {? exec('fks_lic','fks')='N'
         || KOMM.error('Niemożliwe użycie funkcji k().\nBrak licencji dla obszaru FKS.'@);
            .ERR:=1;
            ~~
         || {? _>6 || {? type_of(_g)=2 || 1 || .msg_k('siódmego'@,'kodu wyróżnika konta'@) ?} || _g:='' ?};
            {? _>5 || {? type_of(_f)=2 || 1 || .msg_k('szóstego'@,'słownika wyróżnika konta'@) ?} || _f:='' ?};
            {? _>4 || {? type_of(_e)=2 || 1 |? type_of(_e)=0 || _e:='' || .msg_k('piątego'@,'waluty konta'@) ?} || _e:='' ?};
            {? _>3 || {? type_of(_d)=1 || 1 |? type_of(_d)=0 || _d:=.AM|| .msg_k('czwartego'@,'okresu końcowego'@) ?} || _d:=.AM ?};
            {? _>2 || {? type_of(_c)=1 || 1 |? type_of(_c)=0 || _c:=.AM|| .msg_k('trzeciego'@,'okresu począkowego'@) ?} || _c:=.AM ?};
            {? _>1 || {? type_of(_b)=2 || 1 |? type_of(_b)=0 || _b:='' || .msg_k('drugiego'@,'strony konta'@) ?} || _b:='' ?};
            {? _>0 || {? type_of(_a)=2 || 1 |? type_of(_a)=0 || _a:='' || .msg_k('pierwszego'@,'symbolu konta'@) ?} || _a:='' ?};
            {? .ERR=0
            || exec('fun_k','kalkulator',.,_a,_b,_c,_d,_e,_f,_g)
            || ~~
            ?}
         ?}
      "),

      obj_meth('p', "
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Pobiera wartość parametru
::----------------------------------------------------------------------------------------------------------------------
         _wynik:='Blad';
         {? _=1 & type_of(_a)=1
         || _wynik:=.tpar.p('N',_a)
         || KOMM.error('Funkcja p() — błędna liczba lub typ parametrów.'@); .ERR:=1
         ?};
         _wynik
      ")
   )

?};
1


\fun_k
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Funkcja k() obiektu kalkulacyjnego
::   WE: _a - obiekt kalkulacyjny
::       _b - symbol konta
::       _c - strona WN/MA (domyślnie WN)
::       _d - od okresu (domyślnie okres bieżący)
::       _e - do okresu (domyślnie okres bieżący)
::       _f - waluta (domyślnie waluta narodowa)
::       _g - kod słownika wyróżników
::       _h - kod wyróżnika
:: OGRANICZENIA: parametry _b lub _g i _h muszą być określone
::  OLD: \fun_k/prodobi.fml
::----------------------------------------------------------------------------------------------------------------------
_obj:=_a;
_konto:=_b;
_strona:=~-_c;
_od_okr:=_d;
_do_okr:=_e;
_waluta:=_f;
_wyr_slo:=_g;
_wyr_kod:=_h;
_wyn:=~~;

:: czy jest wybrany okres
ROZNE.ROKKON:=exec('rok_find','edkonto',date(ST.AR,ST.AM,1));
{? ROZNE.ROKKON=null()
|| KOMM.error('Błąd funkcji k(): Brak okresu księgowego w danych.'@);
   _obj.ERR:=1;
   return()
?};

:: badanie argumentów...
{? _konto='' & (_wyr_slo='' | _wyr_kod='')
|| KOMM.error('Błąd funkcji k(): Konto lub wyróżnik muszą być określone.'@);
   _obj.ERR:=1;
   return()
?};
{? _strona='' || _strona:='WN' ?};
{? 'WN,MA'*_strona=0
|| KOMM.error('Drugi parametr funkcji k() może przyjmować jedynie następujące wartości: \'WN\', \'MA\'.'@);
   _obj.ERR:=1;
   return()
?};
{? _waluta<>''
|| SLO.clear();
   SLO.index('SL');
   SLO.prefix(XINFO.SLWAL,_waluta);
   {? SLO.first()
   || _wal_ref:=SLO.ref()
   || KOMM.error('Podana waluta %1 nie występuje w systemie.'@[_waluta]);
      return()
   ?}
|| _wal_ref:=INFO.NAROD;
   _waluta:=INFO.NAROD().KOD
?};

:: zasadnicza część formuły...
{? _konto<>'' & (_wyr_slo='' | _wyr_kod='')
:: wariant bez wyróżników
||
   AN.use('koan__'+ROZNE.ROKKON().KOD);
   OBR.use('obroty'+ROZNE.ROKKON().KOD);
   _konto:=gsub(gsub(_konto,'?','_'),'*','%');
   _tab:=sql('
     select
      sum(OBR.WN) as SWN,
      sum(OBR.MA) as SMA
     from OBR
      join AN using(OBR.AN, AN.REFERENCE)
       join SLO using(AN.WAL, SLO.REFERENCE)
        join OKRO_F using(OBR.OKRO, OKRO_F.REFERENCE)
         join ROK_F using(OKRO_F.ROK, ROK_F.REFERENCE)
     where AN.SYM like '':_a%''
      and SLO.KOD='':_b''
       and ROK_F.FIRMA=:_e
        and OKRO_F.NR>=:_c and OKRO_F.NR<=:_d
    ', _konto, _waluta, _od_okr, _do_okr, REF.FIRMA);
   {? _tab.first()
   || {? _strona='WN'
      || _wyn:=_tab.SWN
      |? _strona='MA'
      || _wyn:=_tab.SMA
      || _wyn:=0
      ?}
   || _wyn:=0
   ?}
|? _wyr_slo<>'' & _wyr_kod<>''
:: wariant z wyróżnikami (z kontem i bez konta)
|| _rok:=ROZNE.ROKKON().KOD;
   _od_msk:=_rok+form(_od_okr,-2,0);
   _do_msk:=_rok+form(_do_okr,-2,0);
   _konto:=gsub(gsub(_konto,'?','_'),'*','%');
   _tab:=sql('
     select
      sum (POW.KW) as SUMA
     from @POW
      join @POZ using(POW.POZ, POZ.REFERENCE)
       join @DOK using(POZ.DOK, DOK.REFERENCE)
        join ODD using(DOK.ODD, ODD.REFERENCE)
         join SLUAPPL using(POW.SLU, SLUAPPL.REFERENCE)
          join SLU using(SLUAPPL.SLU, SLU.REFERENCE)
           join SLO using(POW.SLO, SLO.REFERENCE)
     where
      ODD.FIRMA=:_g
       and substr(POZ.STR,1,1)=substr('':_d'',1,1)
        and POZ.KON like '':_a%''
         and substr(POW.REFERENCE,1,8)>=''pow_:_b'' and substr(POW.REFERENCE,1,8)<=''pow_:_c''
          and SLUAPPL.GDZIE=''F''
           and SLU.NAZ='':_e''
            and SLO.KOD='':_f''
    ', _konto, _od_msk, _do_msk, _strona, _wyr_slo, _wyr_kod, REF.FIRMA);
   {? _tab.first()
   || _wyn:=_tab.SUMA
   || _wyn:=0
   ?}
|| return()
:: w przeciwnym wypadku (nigdy tu nie powinno dojść)
?};
_wyn


\ANK_MAT_declare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: deklaracja obiektu ANK_MAT
:: #POLA
:: --PRYWATNE
::    me      - wskazanie na tabele surowcow/operacji
::    save2           - nazwa tabeli, do ktorej piszemy wynik
::    K       - wskazanie na kalkulacje
::    M       - wskazanie na surowiec/operacje
::    N       - liczba elementow
::    P       - cena surowca/stawka operacji
::    S       - zrodlo ceny (dla surowca)
::    T       - karta technologiczna (dla surowca)
::    ILNB    - ilosc norma brutto
:: --PUBLICZNE
::    <brak>
:: #METODY
:: --PRYWATNE
::    add(a,b[,c,d])- dodaje kolejny element o "refie" 'a' oraz cenie 'b',  zrodle ceny 'c', technologii 'd'
::    del()   - kasuje ostatni element
::    chk(a,b,c)- sprawdza czy jest taki element 'a' o zrodle ceny 'b' technologii 'c'
::    save(a) - zapisuje dane do tabeli .save2
:: --PUBLICZNE
::    __init - argument: _b -> .me
::             argument: _c -> .save2
::  OLD: \ANK_MAT_dekl/prodobi.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('ANK_MAT',@.CLASS)<=0
|| obj_decl('ANK_MAT',
      obj_fld('me',''),
      obj_fld('ME',"wskazanie na siebie"),
      obj_fld('save2',''),
      obj_fld('K',0),
      obj_fld('M',0),
      obj_fld('N',0),
      obj_fld('P',0),
      obj_fld('S',0),
      obj_fld('T',0),
      obj_fld('IB',0),
      obj_fld('WYD',0),
      obj_fld('err',"bledna wartosc liczbowa";-999999999999999999999999999999),

      obj_meth('__init',"
         _a.me:=_b; _a.save2:=_c; _a.ME:=_a;
         ~~
      ",2,2),

      obj_meth('add',"
: _a - robocza tabela, np. M, TTOPER,...
: _b - cena jednostkowa, stawka
: _c - pochodzenie
: _d - ktl
: _e - norma brutto (ilość)
: _f - wydzial jezeli podano parametr _e
         {| ($.me)()
         |! _ok:=seek(_a);
            {? _ok
            || _M:=obj_new(.N+1);
               _P:=obj_new(.N+1);
               {? var_pres('_c')>0 || _S:=obj_new(.N+1); _T:=obj_new(.N+1) ?};
               {! _i:=1...N
               |! _M[_i]:=.M[_i];
                  _P[_i]:=.P[_i];
                  {? var_pres('_c')>0 || _S[_i]:=.S[_i]; _T[_i]:=.T[_i] ?}
               !};
               {? .N>0
               || obj_del(.M);
                  obj_del(.P);
                  {? var_pres('_c')>0 || obj_del(.S); obj_del(.T) ?}
               ?};
               .M:=_M;
               .P:=_P;
               {? var_pres('_c')>0 || .S:=_S; .T:=_T ?};
               .M[.N+1]:=ref();
               .P[.N+1]:=_b;
               {? var_pres('_c')>0 || .S[.N+1]:=_c; .T[.N+1]:=null() ?};
               {? var_pres('_d')>0 || .T[.N+1]:=_d ?};
               {? var_pres('_e')>0 || _IB:=obj_new(.N+1);
                                      {! _i:=1...N |! _IB[_i]:=.IB[_i] !};
                                      {? .N>0 || obj_del(.IB) ?};
                                      .IB:=_IB;
                                      .IB[.N+1]:=_e
               ?};
               {? var_pres('_f')>0 || _WYD:=obj_new(.N+1);
                                      {! _i:=1...N |! _WYD[_i]:=.WYD[_i] !};
                                      {? .N>0 || obj_del(.WYD) ?};
                                      .WYD:=_WYD;
                                      .WYD[.N+1]:=_f
               ?};
               .N+=1
            ?}
         |}
      "),

      obj_meth('del',"
         {| ($.me)()
         |! _M:=obj_new(.N-1);
            _P:=obj_new(.N-1);
            _IB:=obj_new(.N-1);
            _WYD:=obj_new(.N-1);
            {! _i:=1..(.N-1) |! _M[_i]:=.M[_i]; _P[_i]:=.P[_i]; _IB[_i]:=.IB[_i]; _WYD[_i]:=.WYD[_i] !};
            {?.N>0
            || obj_del(.M);
               obj_del(.P);
               obj_del(.IB);
               obj_del(.WYD)
            ?};
            .M:=_M;
            .P:=_P;
            .IB:=_IB;
            .WYD:=_WYD;
            .N-=1
         |}
      "),

      obj_meth('chk',"
: _a - pt
: _b - cena
: _c - pochodzenie
: _d - ktl
         _w:=.err;
         {! _i:=1...N
         |! {? (.M[_i]=_a) & (.S[_i]=_b) & (.T[_i]=_c)
            || _w:=.P[_i]
            ?}
         !};
         _w
      "),

      obj_meth('save',"
         {? .save2='KALMAT'
         || KALMAT.cntx_psh();
            KALMAT.index('KS');
            {! _i:=1...N
            |! KALMAT.prefix(.K,.M[_i],.S[_i],$.T[_i]);
               {? KALMAT.first()
               || KALMAT.IL+={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=KALMAT.put(1)
               || KALMAT.blank();
                  KALMAT.KKTL:=.K;
                  KALMAT.PT:=.M[_i];
                  KALMAT.PRICE:=.P[_i];
                  KALMAT.POCH:=.S[_i];
                  KALMAT.TKTL:=.T[_i];
                  KALMAT.IL:={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=KALMAT.add(1)
               ?};
               {? _ok=0 || _i:=.N ?}
            !};
            KALMAT.cntx_pop()

         |? .save2='ANZMAT'
         || ANZMAT.cntx_psh();
            ANZMAT.index('AS');
            {! _i:=1...N
            |! ANZMAT.prefix(.K,.M[_i],.S[_i],$.T[_i]);
               {? ANZMAT.first()
               || ANZMAT.IL+={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=ANZMAT.put(1)
               || ANZMAT.blank();
                  ANZMAT.ANZH:=.K;
                  ANZMAT.T:=.M[_i];
                  ANZMAT.PRICE:=.P[_i];
                  ANZMAT.POCH:=.S[_i];
                  ANZMAT.TKTL:=.T[_i];
                  ANZMAT.IL+={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=ANZMAT.add(1)
               ?};
               {? _ok=0 || _i:=.N ?}
            !};
            ANZMAT.cntx_pop()

         |? .save2='KALTTO'
         || KALTTO.cntx_psh();
            KALTTO.index('KO');
            {! _i:=1...N
            |! KALTTO.prefix(.K,.M[_i],.P[_i]);
               {? KALTTO.first()
               || KALTTO.IL+={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=KALTTO.put(1)
               || KALTTO.blank();
                  KALTTO.KKTL:=.K;
                  KALTTO.TTOPER:=.M[_i];
                  KALTTO.STAWKA:=.P[_i];
                  KALTTO.IL:={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=KALTTO.add(1)
               ?};
               {? _ok=0 || _i:=.N ?}
            !};
            KALTTO.cntx_pop()

         |? .save2='ANZTTO'
         || ANZTTO.cntx_psh();
            ANZTTO.index('AO');
            {! _i:=1...N
            |! ANZTTO.prefix(.K,.M[_i],.P[_i]);
               {? ANZTTO.first()
               || ANZTTO.IL+={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=ANZTTO.put(1)
               || ANZTTO.blank();
                  ANZTTO.ANZH:=.K;
                  ANZTTO.TTOPER:=.M[_i];
                  ANZTTO.STAWKA:=.P[_i];
                  ANZTTO.IL:={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=ANZTTO.add(1)
               ?};
               {? _ok=0 || _i:=.N ?}
            !};
            ANZTTO.cntx_pop()

         |? .save2='KALWRK'
         || KALWRK.cntx_psh();
            KALWRK.index('KP');
            {! _i:=1...N
            |! KALWRK.prefix(.K,.M[_i]);
               {? KALWRK.first()
               || KALWRK.IL+={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=KALWRK.put(1)
               || KALWRK.blank();
                  KALWRK.KKTL:=.K;
                  KALWRK.PLACE:=.M[_i];
                  KALWRK.KH:=.P[_i];
                  KALWRK.IL:={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=KALWRK.add(1)
               ?};
               {? _ok=0 || _i:=.N ?}
            !};
            KALWRK.cntx_pop()

         |? .save2='ANZWRK'
         || ANZWRK.cntx_psh();
            ANZWRK.index('AP');
            {! _i:=1...N
            |! ANZWRK.prefix(.K,.M[_i]);
               {? ANZWRK.first()
               || ANZWRK.IL+={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=ANZWRK.put(1)
               || ANZWRK.blank();
                  ANZWRK.ANZH:=.K;
                  ANZWRK.PLACE:=.M[_i];
                  ANZWRK.KH:=.P[_i];
                  ANZWRK.IL:={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=ANZWRK.add(1)
               ?};
               {? _ok=0 || _i:=.N ?}
            !};
            ANZWRK.cntx_pop()

         |? .save2='KALTOU'
         || KALTOU.cntx_psh();
            KALTOU.index('KT');
            {! _i:=1...N
            |! KALTOU.prefix(.K,.M[_i]);
               {? KALTOU.first()
               || KALTOU.IL+={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=KALTOU.put(1)
               || KALTOU.blank();
                  KALTOU.KKTL:=.K;
                  KALTOU.TTOUT:=.M[_i];
                  KALTOU.CENA:=.P[_i];
                  KALTOU.IL:={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=KALTOU.add(1)
               ?};
               {? _ok=0 || _i:=.N ?}
            !};
            KALTOU.cntx_pop()

         |? .save2='ANZTOU'
         || ANZTOU.cntx_psh();
            ANZTOU.index('AT');
            {! _i:=1...N
            |! ANZTOU.prefix(.K,.M[_i]);
               {? ANZTOU.first()
               || ANZTOU.IL+={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=ANZTOU.put(1)
               || ANZTOU.blank();
                  ANZTOU.ANZH:=.K;
                  ANZTOU.TTOUT:=.M[_i];
                  ANZTOU.CENA:=.P[_i];
                  ANZTOU.IL:={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=ANZTOU.add(1)
               ?};
               {? _ok=0 || _i:=.N ?}
            !};
            ANZTOU.cntx_pop()

         |? .save2='KALTLS'
         || KALTLS.cntx_psh();
            KALTLS.index('KT');
            {! _i:=1...N
            |! KALTLS.prefix(.K,.M[_i]);
               {? KALTLS.first()
               || KALTLS.IL+={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=KALTLS.put(1)
               || KALTLS.blank();
                  KALTLS.KKTL:=.K;
                  KALTLS.M:=.M[_i];
                  KALTLS.KOSZT:=.P[_i];
                  KALTLS.IL:={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=KALTLS.add(1)
               ?};
               {? _ok=0 || _i:=.N ?}
            !};
            KALTLS.cntx_pop()

         |? .save2='ANZTLS'
         || ANZTLS.cntx_psh();
            ANZTLS.index('AT');
            {! _i:=1...N
            |! ANZTLS.prefix(.K,.M[_i]);
               {? ANZTLS.first()
               || ANZTLS.IL+={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=ANZTLS.put(1)
               || ANZTLS.blank();
                  ANZTLS.ANZH:=.K;
                  ANZTLS.M:=.M[_i];
                  ANZTLS.KOSZT:=.P[_i];
                  ANZTLS.IL:={? type_of(.IB)>6 || .IB[_i] || 0 ?};
                  _ok:=ANZTLS.add(1)
               ?};
               {? _ok=0 || _i:=.N ?}
            !};
            ANZTLS.cntx_pop()
         ?}
      "),
   )
?};
1


::----------------------------------------------------------------------------------------------------------------------
:: Obsługa tabeli SL_WAL - słownik walidacji wyrażeń
::----------------------------------------------------------------------------------------------------------------------


\fparse
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RS [2011]
:: OPIS: proste testownanie poprawności wyrażenia na podstawie słownika zakazanych podwyrażen
::   WE: _a - string, _b - dziedzina wyrażenia-nazwa słownika SL_WAL
::   WY: 1 - ok, 0 - zle
::  OLD: \fparse/fkalk.fml
::----------------------------------------------------------------------------------------------------------------------
_exit:="FUN.emsg(_a)";
{? _<1 || return(0)?};
_expr:=_a;

{? ~exec('valid_formula','#field',_expr)
|| return(0)
?};

:: dla osób uprawnionych jest to koniec procedury testowania, do tego służy poniższe sprawdzenie
{? sec_superuser()>0
||
   return(1)
?};

:: odrzucić wyrażenia zawierające treść w której po . nie występuje liczba
{? exec('dotnotnum','#string',_expr)>0
||
   _exit('Wyrażenie zawiera odwołania do pól lub metod. Nie należy używać liter bezpośrednio po kropce.'@);
   return(0)
?};
:: WERYFIKUJEMY CZY WYSTĄPILY ZAKAZANE SŁOWA
:: usuwamy spacje
_expr2:=exec('repl_substr','#string',_expr,' ','');

SL_WAL.clear();
:: jeśli nie ma słowników to inicjalizujemy je w tle w trybie silent
{? SL_WAL.first()=0
||
   exec('slwal_init','kalkulator')
?};
:: przeglądamy słownik globalny
SL_WAL.index('SL_WAL');
SL_WAL.prefix('ogo',);
{? SL_WAL.first()
||
   {! |?
     {? ((_expr*SL_WAL.TR)>0) | ((_expr2*SL_WAL.TR)>0)
     ||
        _exit('Ciąg znaków \"%1\" nie może wystąpić w tym wyrażeniu.'@[SL_WAL.TR]);
        return(0)
     ?};
     SL_WAL.next()
   !}
?};
:: jeśli w parametrze _b określono dziedzinę użycia sprawdzamy w słowniku wystąpienia tych wartości
{? _>1
||
   SL_WAL.clear();
   SL_WAL.prefix(_b);
   {? SL_WAL.first()
   ||
      {! |?
        {? ((_expr*SL_WAL.TR)>0) | ((_expr2*SL_WAL.TR)>0)
        ||
           _exit('Ciąg znaków \"%1\" nie może wystąpić w tym wyrażeniu.'@[SL_WAL.TR]);
           return(0)
        ?};
        SL_WAL.next()
      !}
   ?}
?};
1


\slwal_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RS [2011]
:: OPIS: inicjalizacja SL_WAL zbiorem podstawowych wartości
::  OLD: \slwal_init/fkalk.fml
::----------------------------------------------------------------------------------------------------------------------
_slwaladd:="
   SL_WAL.TR:=_a;
   SL_WAL.add(1)
";

on_error(2);
no_msg(1);
SL_WAL.clear();
:: ogólne
SL_WAL.DU:='ogo';
_slwaladd('exec');
_slwaladd('system');
_slwaladd('break');
_slwaladd('.add');
_slwaladd('.put');
_slwaladd('.del');
_slwaladd('.erase');
_slwaladd('.select');
_slwaladd('.clear');
_slwaladd('.edit');
_slwaladd('.index');
_slwaladd('.prefix');
:: pętla
_slwaladd('{!');
:: instrukcja wiążąca
_slwaladd('{|');
:: operatory przypisania
_slwaladd(':=');
_slwaladd('+=');
_slwaladd('-=');
_slwaladd('*=');
_slwaladd('/=');
:: sklejanie ciągow i procedur
_slwaladd('\'+\'');
_slwaladd('\"+\"');
_slwaladd('\'+\"');
_slwaladd('\"+\'');
no_msg(0);
on_error(0);
1


\slwal_ed
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RS [2011]
:: OPIS: otwarcie okna wertowania/edycji słownika walidacji
::       ogo - ogólne, fka - dot. kalkulacji, fkz - dot. kalk. zleceń, fpa - dotyczące parametrów
::  OLD: \slwal_ed/fkalk.fml
::----------------------------------------------------------------------------------------------------------------------
SL_WAL.clear();
:: jeśli nie ma słowników to inicjalizujemy je w tle w trybie silent
{? SL_WAL.first()=0
|| exec('slwal_init','kalkulator')
?};
:: aby przetestować w trybie użytkownika dodać na końcu warunku ;0
{? sec_superuser()>0
|| SL_WAL.actions('WER','','',1)
|| SL_WAL.actions('WER','dup:d','',1)
?};
SL_WAL.select();
~~


\slwal_pored
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RS [2011]
:: OPIS: po redakcji pól tabeli SL_WAL
::  OLD: \slwal_pored/fkalk.fml
::----------------------------------------------------------------------------------------------------------------------
_ret:=1;
{? cur_afld()='DU'
|| {? ~((+SL_WAL.DU>0) & (('ogo|fka|fkz|fpa'*SL_WAL.DU)>=1))
   || FUN.error(
         'Niewłaściwa dziedzina użycia.\n\n'
         'Dopuszczalne wartości:\n'
         'ogo - wykluczenie używane do walidacji w każdym przypadku,\n'
         'fka - wykluczenie używane do walidacji w formułach kalkulacji technologii,\n'
         'fkz - wykluczenie używane do walidacji w formułach kalkulacji zleceń,\n'
         'fpa - wykluczenie używane do walidacji w formułach parametryzacji zleceń.'@
      );
      _ret:=0
   || _tab:=exec('slwal_slo','kalkulator');
      _tab.prefix(fld(),);
      {? _tab.first()
      || VAR.STRING:=_tab.TXT
      ?}
   ?}

||
:: treść musi być niepusta
   {? +SL_WAL.TR>0
   ||
:: jeśli zmieniła się od ostatniego razu
      {? ~(var_pres('SLWALTMP') & (SLWALTMP=SL_WAL.TR))
      ||
         _ttab:=sql('select * from SL_WAL where DU=\':_a\' and TR=\':_b\'',SL_WAL.DU,SL_WAL.TR);
         {? ~(_ttab.first()=0)
         ||
            FUN.error('Znaleziono wystąpienie wpisu o podanej treści.\nProszę wprowadzić inną treść.'@);
            _ret:=0
         ?}
      ?}
   ||
      FUN.emsg('Proszę wypełnić pole.'@);
      _ret:=0
   ?};
   {? _ret=1
   || VAR_DEL.delete('SLWALTMP')
   ?}
?};
_ret


\slwal_trprred
::----------------------------------------------------------------------------------------------------------------------
::  UTW: RS [2011]
:: OPIS: przed redakcją pola TR tabeli SL_WAL
::  OLD: \slwal_trprred/fkalk.fml
::----------------------------------------------------------------------------------------------------------------------
SLWALTMP:=SL_WAL.TR;
1


\slwal_slo
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Słownik dziedzin użycia
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(1,'DU','STRING[3]','Dziedzina użycia','TXT','STRING[80]','');
_tab.DU:='ogo'; _tab.TXT:='ogo - wykluczenie używane do walidacji w każdym przypadku'@; _tab.add();
_tab.DU:='fka'; _tab.TXT:='fka - wykluczenie używane do walidacji w formułach kalkulacji technologii'@; _tab.add();
_tab.DU:='fkz'; _tab.TXT:='fkz - wykluczenie używane do walidacji w formułach kalkulacji zleceń'@; _tab.add();
_tab.DU:='fpa'; _tab.TXT:='fpa - wykluczenie używane do walidacji w formułach parametryzacji zleceń'@; _tab.add();
_tab


\slwal_du_f3
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: F3 w polu SL_WAL.DU
::  OLD: \slwal_du_f3/fkalk.fml
::----------------------------------------------------------------------------------------------------------------------
_tab:=exec('slwal_slo','kalkulator');
_wer:=_tab.mk_sel('Dziedzina użycia'@,,,'slwaldu',10,10,10);
_tab.win_fld(_wer,,'TXT',,,60,,,'');
_tab.win_act(_wer,,'Formuła','Wybierz'@@,,,"sel_exit()",,1);
_tab.win_sel(_wer);
{? _tab.select()
|| fld(_tab.DU)
|| ~~
?}


\slwal_du_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Przed wyświetleniem pola SL_WAL.DU
::----------------------------------------------------------------------------------------------------------------------
{? fld()<>''
|| _tab:=exec('slwal_slo','kalkulator');
   _tab.prefix(fld(),);
   {? _tab.first()
   || VAR.STRING:=_tab.TXT
   ?}
|| VAR.STRING:=''
?};
1


\slwal_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Po rekord w oknie SL_WAL
::----------------------------------------------------------------------------------------------------------------------
_chk:=__CHK.record(SL_WAL,,'DU','TR');
{? _chk=''
|| __CHK.index(SL_WAL,-menu_txt()='popraw')=''
|| _chk
?}


\slwal_before_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS:
::----------------------------------------------------------------------------------------------------------------------
SL_WAL.efld_opt('RED','enable=1',VAR,'STRING');
1


\slwal_before_modify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS:
::----------------------------------------------------------------------------------------------------------------------
SL_WAL.efld_opt('RED','enable=1',VAR,'STRING');
1


\slwal_before_find
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS:
::----------------------------------------------------------------------------------------------------------------------
SL_WAL.efld_opt('RED','enable=0',VAR,'STRING');
1

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:39 e5149bd97fd8b6b0d2f4e92004f2677d0e08fa4ccfe36a0486797d5d4d5add41187b48bfd1a53b7f2ec6a13f3d2b56abded603555c636bc742e29d01927b593096e9b498512d1f9302538d9db975f3c68cc7a4ed1af9ed1da66eea0f4a0c1b42283767b87b2cb80419e4d5e7e02003475434e565d19e6ca68af341eb338cadd8
