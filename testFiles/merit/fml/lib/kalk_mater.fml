:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: kalk_mater.fml
:: Utworzony: 12.05.2015
:: Autor: TS
::======================================================================================================================
:: Zawartość: Formuły do obsługi kalkulacji surowców kart technologicznych, technologii zlecenia,
::            oraz ilości produktu na zleceniu
::            (biblioteka wspólna dla TTE_TEC, TTE_PZL)
::======================================================================================================================


\ProDpric_start
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Stworzenie funkcji do oblugi cen
::  OLD: \ProDpric_start/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('ProDpric',@)>0 || obj_del(ProDpric) ?};
ProDpric:=tab_tmp(2
   ,'TKTL'  ,'INTEGER'  ,'#TKTL.ref()'
   ,'PT'    ,'INTEGER'  ,'#M.ref()'
   ,'PR'    ,'REAL'     ,'Cena'
);
ProD_add:="
:: dodaje cenę do ProDpric
:: _a - TKTL.ref()
:: _b - M.ref()
:: _c - cena
{| ProDpric
|! _cena:=ProD_get(_a,_b);
   {? _cena=-999999999999999999999999999999
   || TKTL:=#_a;
      PT:=#_b;
      PR:=_c;
      add(1)
   || _cena=_c
   ?}
|}
";
ProD_get:="
:: pobiera cene z ProDpric
:: _a - TKTL.ref()
:: _b - M.ref()
{| ProDpric
|! clear();
   prefix(#_a,#_b);
   {? first()
   || PR
   || -999999999999999999999999999999
   ?}
|}
";
1


\ProDpric_stop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Usunięcie funkcji do obsługi cen
::  OLD: \ProDpric_stop/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('ProDpric',@)>0 || obj_del(ProDpric) ?};
{? var_pres('ProD_add',@)>0 || &ProD_add ?};
{? var_pres('ProD_get',@)>0 || &ProD_get ?};
1


\get_src_price
::----------------------------------------------------------------------------------------------------------------------
::  UTW: JM [2002/10/08]
:: OPIS: funkcja m() w obiekcie kalkulacyjnym dla kalkulacji
::   WE: _a - wskazanie na obiekt kalkulacyjny
::       _b - TKTL.ref() albo $TKTL.ref()
::       _c - Kolejność analizy (0,1) albo STRING
::       _d - data cen do kalkulacji ()
::       _e - ilość miesięcy do analizy ceny (dla _b=3,4)
::       _f - czy cena jest pobierana ze stanów, czy uśredniana z dokumentów
::       _g - czy wprowadzane z ręki ceny zapamiętywane są w PTC.
::       _h - rekurencja (dla półfabrykatow)
::       _i - ilość kalkulowana (xjm), do jakiej skalować wynik. Gdy równa zeru to skalowanie wg ilości na technologii
::   WY: _wynik[_i][_j][_k][_l][m]
::        _i - przemieszczanie się po osi: M (surowce, wyroby handlowe), P (półfabrykaty, wyroby), (inne)
::        _j - oś limowane/nielimitowane
::        _k - oś faz produkcji
::        _l - oś 'S'urowiec, 'O'dpad
::        _m - zawsze 1 (zgodnosc z funkcja analizy zlecenia)
::  OLD: \get_src_price/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_kl:=_a;
_tktl_ref:=_b;
_parametr:=_c;
_miesiace:=_e;
_wariant:=_f;
_cena:=_g;
_rek:=_h;
_xjm:=_i;
_calc:=0;
_wynik:=0;
exec('TMAT_get_src','kalk_mater');
{? type_of(_kl.pTMAT)>6 || obj_del(_kl.pTMAT) ?};
_kl.pTMAT:=obj_new(@.CLASS.TMAT_get_src);
{? type_of(_kl.pTMAT)>6
|| _kl.pTMAT.set_TKTL(_kl,_tktl_ref);
   _kl.pTMAT.DATA:={? _d=date(0,0,0) || date() || _d ?};
   _calc:=1;
   {| _kl.pTMAT
   |! HAND:=1;
      SELECT:=1;
      PTC:={? type_of(_parametr)=1
           || {? _parametr=0
              || {? _wariant=0
                 || 'LTH'
                 || 'DTH'
                 ?}
              |? _parametr=1
              || {? _wariant=0
                 || 'TLH'
                 || 'TDH'
                 ?}
              |? _parametr=2
              || 'TH'
              |? _parametr=3
              || {? _wariant=0
                 || 'LH'
                 || 'DH'
                 ?}
              ?}
           || _parametr
           ?};
      S:=_wariant;
      MC:=_miesiace;
      REK:=_rek;
      XJM:=_xjm;
      ADD:=_cena
   |};
   _wynik:={? _calc
           || {? var_pres('__TMAT')>0 & var_pres('__LEVEL')>0 & __LEVEL=1
              || _kl.pTMAT.get1_all_prices()
              || _kl.pTMAT.get_all_prices()
              ?}
           || 0
           ?};
:Rlog.add('usuniety obiekt pTMAT');
   obj_del(_kl.pTMAT)
|| FUN.error('Błędne działanie formuły.'@)
?};
_wynik


\TMAT_get_src
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: deklaracja obiektu do wyciagania ceny
::       POLA OBIEKTU
::       <!> KL    - wskazanie na obiekt kalkulacyjny
::       <!> TKTL  - wskazanie na kartę technologiczną
::       <!> TMAT  - wskazanie na konkretny surowiec karty technologicznej
::       < > PT    - wskazanie na produkt
::       < > S     - czy ma szukać ceny w stanach (różne algorytmy 1,2...)
::       < > MC    - jeżeli S=2, to oznacza ile miesięcy analizować
::       < > HAND  - Czy ma sie pytać o podanie ceny ręcznie?
::       < > PTC   - Czy ma sprawdzać cenę w PTC? Jeżeli=2 to przed "S"
::       < > ADD   - Czy ma dodawać wprowadzoną cenę do PTC?
::       < > ERROR - Wystapił błąd... kontynuować poszukiwania ceny
::       < > PRICE - Cena surowca
::       < > PRICE_ALL - Suma cen surowców jakie do tej pory były pobrane
::       < > LIM - Czy ilośc surowca ma być pobierana z limitów(ZLIM) czy z technologii (TMAT)
::       < > POCH - Pochodzenie ceny surowca S-tabela S, T-tabela PTC, H-cena wpr.ręcznie
::       < > KTL - wskazanie na kartę technologiczną półfabrykatu
::       < > XJM - ilość kalkulowana (xjm), dla jakiej skalować wynik. Gdy nie podana to wg xjm na technologii
::
::       METODY OBIEKTU
::       <_PUBLIC> set_TKTL       - ustawia obiekt dla karty technologicznej i konkretnej kalkulacji
::       <PRIVATE> reset_obj      - ustawia zmienne domyślne dla obiektu
::       <_PUBLIC> get_price      - pobiera cenę surowca wskazanego przez TMAT.ref()
::       <_PUBLIC> get_all_prices - pobiera cenę wszystkich surowców karty
::       <PRIVATE> get_S          - pobiera cenę surowca z tabeli S
::       <PRIVATE> get_PTC        - pobiera cenę surowca z tabeli PTC
::       <PRIVATE> get_HAND       - pobiera cenę surowca "z łapki"
::  OLD: \TMAT_get_src/tex_tmat.fml
::  OLD: \ZMAT_get_src/zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('TMAT_get_src',@.CLASS)>=0 || return(0) ?};

obj_decl('TMAT_get_src',
   obj_fld('KL'       ,"Wskazanie na kalkulację nadrzędną!!! nie odwoływać się bezpośrenio do KL!!!";null()),
   obj_fld('ME'       ,null()),
   obj_fld('TKTL'     ,null()),
   obj_fld('TMAT'     ,null()),
   obj_fld('PT'       ,null()),
   obj_fld('HAND'     ,0),
   obj_fld('SELECT'   ,0),
   obj_fld('REK'      ,0),
   obj_fld('PTC'      ,0),
   obj_fld('S'        ,0),
   obj_fld('MC'       ,0),
   obj_fld('ADD'      ,0),
   obj_fld('LIM'      ,0),
   obj_fld('OK'       ,1),
   obj_fld('NEXT'     ,1),
   obj_fld('POCH'     ,''),
   obj_fld('DATA'     ,date()),
   obj_fld('PRICE'    ,0),
   obj_fld('PRICE_ALL',0),
   obj_fld('KTL', null()),
   obj_fld('ZAM',0),
   obj_fld('XJM',0),

   obj_meth('__init',"_a.ME:=_a"),

   obj_meth('set_TKTL',".KL:=_a; .TKTL:=_b; .reset_obj()"),

   obj_meth('reset_obj',"
      .TMAT:=null();
      .PT:=null();
      .HAND:=0;
      .SELECT:=0;
      .PTC:=0;
      .S:=0;
      .MC:=0;
      .LIM:=0;
      .ADD:=0;
      .OK:=1;
      .NEXT:=1;
      .POCH:='';
      .DATA:=date();
      .PRICE:=0;
      .ZAM:=0;
      .KTL:=null();
      .XJM:=0;
      .PRICE_ALL:=obj_new(3);
      {! _i:=1..3
      |! .PRICE_ALL[_i]:=obj_new(2);
         {! _j:=1..2
         |! .PRICE_ALL[_i][_j]:=obj_new(obj_len(.KL.FAZY));
            {! _k:=1..(obj_len(.KL.FAZY))
            |! .PRICE_ALL[_i][_j][_k]:=obj_new(2);
               {! _l:=1..2
               |! .PRICE_ALL[_i][_j][_k][_l]:=obj_new(2);
                  {! _m:=1..2
                  |! .PRICE_ALL[_i][_j][_k][_l][_m]:=0
                  !}
               !}
            !}
         !}
      !};
      1
   "),

   obj_meth('get_price',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Pobiera cenę surowca (kalkulacja technologii)
::----------------------------------------------------------------------------------------------------------------------
      TMAT.cntx_psh();
      TMAT.clear();
      M.clear();
      .PRICE:=0;
      .OK:=1;
      .NEXT:=1;
      {? TMAT.seek(.TMAT)
      || .KTL:=TMAT.KTL;
::       Sprawdzam czy karta technologiczna na półfabrykat znajduje się w archiwum
::       i jeśli tak to dodaję ostrzeżenie do KOMMów
         _arch:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,\"ARCH\",'N');
         {? _arch='T'
         ||
            M.cntx_psh();
            _msg:='Półfabrykat: %1 używa archiwalnej karty technologicznej,'
                  ' przez co został skalkulowany jak surowiec.'@[TMAT.PT().KTM];
            {? var_pres('KOMW')>100
            ||
               KOMW.add(_msg,'xwin16.png:7')
            ?};
            KOMM.add(_msg,'xwin16.png:7');
            M.cntx_pop()
         ?};
         {? TMAT.KTL<>null() | TMAT.DFLT_KTL='T'
         || _war:=VAR.A_WAR; _ktl:=VAR.A_KTL;
            .POCH:='K';
            {? _w:=.KL.anm.chk({? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?},.POCH,.KTL);
               _w<=0
            ||
               {? TMAT.DFLT_KTL='T'
               || _ktlz:=exec('dflt_ktl','tech_prod',{? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?})
               || _ktlz:=TMAT.KTL
               ?};
               {? _ktlz<>null()
               || _w:=exec('get_prod_price','kalk_mater',.ME,_ktlz,TMAT.ref())
               || _w:=0
               ?}
            ?};
            {? _w>0 || .PRICE:=_w; .OK:=1; .NEXT:=0
            |? _w<0 || .PRICE:=0; .OK:=1; .NEXT:=0
:: gdy _w = 0 to jak widać
:: .NEXT=1
:: do tego jesli .OK=1 to, poszukiwania ceny trwają dalej ;)
            ?};
            VAR.A_WAR:=_war; VAR.A_KTL:=_ktl
         ?};
         _can_continue:=.OK>0 & .NEXT>0;
         {? _can_continue>0 & var_pres('EXIT')>0
         || {? EXIT>0
            || _can_continue:=0
            ?}
         ?};
         {? _can_continue>0
         || .PT:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};
            .OK:=M.seek(.PT);
            _licznik:=1;
            {!
            |? {? .OK & .NEXT
               || _w:=(_licznik-1)-(_licznik+.PTC);
                  {? _w='S'
                  || .get_S(0)
                  |? _w='T'
                  || .get_PTC()
                  |? _w='H'
                  || .get_HAND()
                  |? _w='D'
                  || .get_S(1)
                  |? _w='L'
                  || .get_S(2)
                  ?}
               ?};
               _licznik+=1;
               _licznik<=+.PTC
            !};
            {? .POCH='' || .POCH:='R' ?};
            {? .OK & .ADD=1234 || exec('PTCaddfromKL','material_prod',.PT,.PRICE,.DATA); .ADD:=1 ?}
         ?}
      ?};
      TMAT.cntx_pop();
      .PRICE
   "),

   obj_meth('get2_price',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Pobiera cenę surowca, analiza zlecenia lub kalkulacja zlecenia dla trybu wg limitów
::       Kontekst: ustawione pole .PT
::   WE: [_a] - ZL.ref() - zlecenie powiazane z pólfabrykatem (wypełniane podczas kalkulacji zlecenia)
::----------------------------------------------------------------------------------------------------------------------
      _zlim_zlec:={? var_pres('_a')=type_of(null()) || _a || null() ?};
      .PRICE:=0;
      .OK:=1;
      .NEXT:=1;

      {? _zlim_zlec<>null()
      || .POCH:='K';
         {? _w:=.KL.anm.chk(.PT,.POCH,.KTL);_w<=0
         || _w:=exec('get_prod_price2','kalk_mater',_zlim_zlec)
         ?};
         {? _w>0
         || .PRICE:=_w;
            .OK:=1;
            .NEXT:=0
         |? _w<0
         || .PRICE:=0;
            .OK:=1;
            .NEXT:=0
         ?}
      ?};

      {? .OK & .NEXT
      || _licznik:=1;
         {!
         |?
            {? .OK & .NEXT
            || _w:=(_licznik-1)-(_licznik+.PTC);
               {? _w='S'
               || .get_S(0)
               |? _w='T'
               || .get_PTC()
               |? _w='H'
               || .get_HAND()
               |? _w='D'
               || .get_S(1)
               |? _w='L'
               || .get_S(2)
               ?}
            ?};
            _licznik+=1;
            _licznik<=+.PTC
         !};
         {? .POCH='' || .POCH:='R' ?};
         {? .OK & .ADD=1234
         || exec('PTCaddfromKL','material_prod',.PT,.PRICE,.DATA);
            .ADD:=1
         ?}
      ?};
      .PRICE
   "),

   obj_meth('get1_price',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Pobiera cenę surowca
::----------------------------------------------------------------------------------------------------------------------
      .PRICE:=0;
      .OK:=1;
      .NEXT:=1;
      {? .ZAM=0
      || TMAT.cntx_psh();
         TMAT.clear();
         {? TMAT.seek(.TMAT)
         || .KTL:=TMAT.KTL;
::          Sprawdzam czy karta technologiczna na półfabrykat znajduje się w archiwum
::          i jeśli tak to dodaję ostrzeżenie do KOMMów
            _arch:=exec('FindAndGet','#table',TKTL,TMAT.RKTL,,\"ARCH\",'N');
            {? _arch='T'
            ||
               M.cntx_psh();
               _msg:='Półfabrykat: %1 używa archiwalnej karty technologicznej,'
                     ' przez co został skalkulowany jak surowiec.'@[TMAT.PT().KTM];
               {? var_pres('KOMW')>100
               ||
                  KOMW.add(_msg,'xwin16.png:7')
               ?};
               KOMM.add(_msg,'xwin16.png:7');
               M.cntx_pop()
            ?};

            {? .KTL<>null()
            || .POCH:='K';
               {? _w:=.KL.anm.chk({? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?},.POCH,.KTL);_w<=0
               || _w:=exec('get_prod_price','kalk_mater',.ME,.KTL,TMAT.ref())
               ?};
               {? _w>0
               || .PRICE:=_w;
                  .OK:=1;
                  .NEXT:=0
               |? _w<0
               || .PRICE:=0;
                  .OK:=1;
                  .NEXT:=0
               ?}
            ?}
         ?};
         TMAT.cntx_pop()
      || TCHMAT.cntx_psh();
         TCHMAT.clear();
         {? TCHMAT.seek(.TMAT)
         ||
::          Sprawdzam czy karta technologiczna na półfabrykat znajduje się w archiwum
::          i jeśli tak to dodaję ostrzeżenie do KOMMów
            _arch:=exec('FindAndGet','#table',TKTL,TCHMAT.RKTL,,\"ARCH\",'N');
            {? _arch='T'
            ||
               M.cntx_psh();
               _msg:='Półfabrykat: %1 używa archiwalnej karty technologicznej,';
                     ' przez co został skalkulowany jak surowiec.'@[TMAT.PT().KTM];
               {? var_pres('KOMW')>100
               ||
                  KOMW.add(_msg,'xwin16.png:7')
               ?};
               KOMM.add(_msg,'xwin16.png:7');
               M.cntx_pop()
            ?};

            .KTL:=TCHMAT.KTL;
            {?.KTL<>null()
            || .POCH:='K';
               {? _w:=.KL.anm.chk({? TCHMAT.GRKTM='G' || TCHMAT.TGDFLT().PT || TCHMAT.PT ?},.POCH,.KTL);_w<=0
               || _w:=exec('get_prod_price','kalk_mater',.ME,.KTL,TCHMAT.ref())
               ?};
               {? _w>0
               || .PRICE:=_w;
                  .OK:=1;
                  .NEXT:=0
               |? _w<0
               || .PRICE:=0;
                  .OK:=1;
                  .NEXT:=0
               ?}
            ?}
         ?};
         TCHMAT.cntx_pop()
      ?};
      {? .OK & .NEXT
      || M.clear();
         .OK:=M.seek(__TMAT.PTREF,);
         .PT:=M.ref();
         _licznik:=1;
         {!
         |?
            {? .OK & .NEXT
            || _w:=(_licznik-1)-(_licznik+.PTC);
               {? _w='S'
               || .get_S(0)
               |? _w='T'
               || .get_PTC()
               |? _w='H'
               || .get_HAND()
               |? _w='D'
               || .get_S(1)
               |? _w='L'
               || .get_S(2)
               ?}
            ?};
            _licznik+=1;
            _licznik<=+.PTC
         !};
         {? .POCH='' || .POCH:='R' ?};
         {? .OK & .ADD=1234
         || exec('PTCaddfromKL','material_prod',.PT,.PRICE,.DATA);
            .ADD:=1
         ?}
      ?};
      .PRICE
   "),

   obj_meth('get1_all_prices',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Pobiera cenę surowca, kalkulowanie rekurencyjne
::----------------------------------------------------------------------------------------------------------------------
      __TMAT.cntx_psh();
      __TMAT.clear();
      {? __TMAT.first()
      || {!
         |? TMAT.seek(__TMAT.REF,8+__TMAT.REF);
            {? {? __TMAT.TCHMAT=''
               || .ZAM:=0;
                  TMAT.POW='N' & .KL.tpar.calc(TMAT.EXIST)
               || TCHMAT.seek(__TMAT.TCHMAT,8+__TMAT.TCHMAT);
                  .ZAM:=1;
                  TCHMAT.POW='N' & .KL.tpar.calc(TCHMAT.EXIST)
               ?}
            || M.seek(__TMAT.PTREF,);
               {? __TMAT.TCHMAT='' || .TMAT:=TMAT.ref() || .TMAT:=TCHMAT.ref() ?};
               M.cntx_psh();
               _p:=.get1_price();
               M.cntx_pop();
               {? .ZAM=0
               || _warb:={? TMAT.FORMB<>''
                         || .KL.tpar.calc(TMAT.FORMB)$ exec('round_abe','tech_mater',TMAT,1)
                         || TMAT.WARB
                         ?};
                  _warn:={? TMAT.FORMN<>''
                         || .KL.tpar.calc(TMAT.FORMN)$ exec('round_abe','tech_mater',TMAT,1)
                         || TMAT.WARN
                         ?}
               || _warb:={? TCHMAT.FORMB<>''
                         || .KL.tpar.calc(TCHMAT.FORMB)$ exec('round_abe','tech_mater',TCHMAT,1)
                         || TCHMAT.WARB
                         ?};
                  _warn:={? TCHMAT.FORMN<>''
                         || .KL.tpar.calc(TCHMAT.FORMN)$ exec('round_abe','tech_mater',TCHMAT,1)
                         || TCHMAT.WARN
                         ?}
               ?};
               {? __TMAT.WPM='S' | __TMAT.WPM='H' || _i:=1
               |? __TMAT.WPM='P' | __TMAT.WPM='W' || _i:=2
                                                  || _i:=3
               ?};
               {? __TMAT.L='T' || _j:=1 || _j:=2 ?};
               {! _l:=1..(obj_len(.KL.FAZY))
               |! {? .KL.FAZY[_l]=TMAT.PFAZ || _k:=_l ?}
               !};
               {? __TMAT.SO='S' || _m:=1; _s:=1 || _m:=2; _s:=-1 ?};
               .KL.anm.add(
                  M.ref(),
                  .PRICE,
                  .POCH,
                  .KTL,
                  _s*_warb,
                  {? .ZAM=0 || TMAT.WYD().KOD || TCHMAT.SRC().WYD().KOD ?}
               );
               .PRICE_ALL[_i][_j][_k][_m][1]+=.PRICE*_warb*_s
            ?};
            __TMAT.next()
         !}
      ?};
      __TMAT.cntx_pop();
      .PRICE_ALL
   "),

   obj_meth('get2_all_prices',"
:: get1_all_prices z zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Wyciaga cene materialu dla kalkulacji zlecenia
::   WE: [_a] - jezeli jest, to obliczenia tylko dla tego zlecenia, wpp dla podzlecen
::----------------------------------------------------------------------------------------------------------------------
      {? _>0 || __TMAT.prefix(#ZL.ref()) || __TMAT.prefix() ?};
      M.clear();
      {? __TMAT.first()
      || {!
         |? TMAT.seek(__TMAT.REF,8+__TMAT.REF);
            {? {? __TMAT.TCHMAT=''
               || .ZAM:=0;
                  .TMAT:=TMAT.ref();
                  _tmat:=TMAT;
                  TMAT.POW='N'
               || .ZAM:=1;
                  TCHMAT.seek(__TMAT.TCHMAT,8+__TMAT.TCHMAT);
                  .TMAT:=TCHMAT.ref();
                  _tmat:=TCHMAT;
                  TCHMAT.POW='N'
               ?}
            || M.seek(__TMAT.PTREF,'material');
               .get1_price();
               ZL.seek(__TMAT.ZLEC,'zlec_akt');
               _zl:=ZL.ref();
               _warb:=0;
               {? __TMAT.L='T' & .LIM=1
               || {? TKTL.ZL().GENLIM='N' & TKTL.ZL().NRNZL<>0
                  || ZLIM.index('ZKP'); ZLIM.prefix(_zl,'T',M.ref())
                  || ZLIM.index('ZKN'); ZLIM.prefix(_zl,'T',M.ref())
                  ?};
                  {? ZLIM.first()
                  || {!
                     |? _warb+=ZLIM.LIL;
                        ZLIM.next()
                     !}
                  ?}
               || _dokl:=exec('jaka_dok_m','jm',_tmat.PT);
                  _warb:={? _dokl>0
                         || _tmat.WARB * ZL.IL/ZL.TKTL().XJM $ _dokl
                         || ceil(_tmat.WARB * ZL.IL/ZL.TKTL().XJM)
                         ?}
               ?};
               {? __TMAT.WPM='S' | __TMAT.WPM='H' || _i:=1
               |? __TMAT.WPM='P' | __TMAT.WPM='W' || _i:=2
                                                  || _i:=3
               ?};
               {? __TMAT.L='T' || _j:=1 || _j:=2 ?};
               {! _l:=1..(obj_len(.KL.FAZY))
               |! {? .KL.FAZY[_l]=TMAT.PFAZ || _k:=_l ?}
               !};
               {? __TMAT.SO='S' || _m:=1; _s:=1 || _m:=2; _s:=-1 ?};
               .KL.anm.add(M.ref(),.PRICE,.POCH,.KTL,_s*_warb);
               .PRICE_ALL[_i][_j][_k][_m][1]+=.PRICE*_warb*_s
            ?};
            obj_del(_tmat);
            __TMAT.next()
         !}
      ?};
      .PRICE_ALL
   "),

   obj_meth('get3_all_prices',"
:: get_all_prices w zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Metoda do pobierania ceny surowca
::   WE: [_a] - jezeli jest, to obliczenia tylko dla tego zlecenia, wpp dla podzleceń więc nie pobiera półfabrykatów
::----------------------------------------------------------------------------------------------------------------------
      {? .LIM=0
      || TMAT.cntx_psh();
         TMAT.index('NNL');
         TMAT.prefix(.TKTL);
         {? TMAT.first()
         ||
            {? .XJM<=0 || .XJM:=ZL.IL ?};
            _coef:={? TMAT.NRK().XJM=0 || 1 || .XJM/TMAT.NRK().XJM ?};
            {!
            |?
::             aktywne i nie powierzone
               {? TMAT.ACT='T' & TMAT.POW='N'
               || {? ~((TMAT.PT().R='P' | M.R='W') & TMAT.MAG<>'T' & _>0)
                  || .TMAT:=TMAT.ref();
                     .get_price();
                     {? TMAT.GRKTM='K'
                     || _dokl:=exec('jaka_dok_m','jm',TMAT.PT);
                        {? TMAT.PT().R='S' | M.R='H' || _i:=1
                        |? TMAT.PT().R='P' | M.R='W' || _i:=2
                                                     || _i:=3
                        ?}
                     || _dokl:=exec('jaka_dok_m','jm',TMAT.TGDFLT().PT);
                        {? TMAT.TGDFLT().PT().R='S' | M.R='H' || _i:=1
                        |? TMAT.TGDFLT().PT().R='P' | M.R='W' || _i:=2
                                                              || _i:=3
                        ?}
                     ?};
                     _rm:=roundmet();
                     roundmet(2);
                     _warb:={? TMAT.NRK().XJM=0 || 0 || (TMAT.WARB*_coef)$_dokl ?};
                     roundmet(_rm);
                     {? TMAT.LIMIT='T' || _j:=1 || _j:=2 ?};
                     {! _l:=1..(obj_len(.KL.FAZY))
                     |! {? .KL.FAZY[_l]=TMAT.PFAZ || _k:=_l ?}
                     !};
                     {? TMAT.SO='S' || _m:=1; _s:=1 || _m:=2; _s:=-1 ?};
                     _il:=_s*_warb;
                     .KL.anm.add({? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?},.PRICE,.POCH,.KTL,_il);
                     .PRICE_ALL[_i][_j][_k][_m][1]+=.PRICE*_il
                  ?}
               ?};
               TMAT.next()
            !}
         ?};
         TMAT.cntx_pop()

      || {? VAR.A_TPZL().WP='W' | TKTL.seek(.TKTL)
         || _zl:=VAR.A_ZLEC;
            _warb:=0;
            {? .XJM<=0 || .XJM:=VAR.A_ZLEC().IL ?};
            _coef:={? VAR.A_ZLEC().IL=0 || 1 ||  .XJM/VAR.A_ZLEC().IL ?};
            {? VAR.A_ZLEC().RODZAJ='P'
            || ZLIM.index('ZKN'); ZLIM.prefix(_zl)
            || ZLIM.index('ZKP'); ZLIM.prefix(_zl)
            ?};

            {? ZLIM.first()
            || {!
               |? .PT:=ZLIM.KTM;
                  _zlim_zlec:=null();
::                Sprawdzenie, do surowca wygenerowane zostało podzlecenie
                  {? ZLIM.RTMAT<>''
                  || ZL.cntx_psh();
                     ZL.index('RTMATSRC');
                     ZL.prefix(ZLIM.RTMAT,ZLIM.ZLEC().UNRZL);
                     {? ZL.first()
                     || _zlim_zlec:=ZL.ref()
                     ?};
                     ZL.cntx_pop()
                  ?};
                  .get2_price(_zlim_zlec);
                  {! _l:=1..(obj_len(.KL.FAZY))
                  |! {? .KL.FAZY[_l]=ZLIM.PFAZ || _k:=_l ?}
                  !};
                  {? ZLIM.KTM().R='S' | M.R='H' || _i:=1
                  |? ZLIM.KTM().R='P' | M.R='W' || _i:=2
                                                || _i:=3
                  ?};
                  {? ZLIM.SO='S' || _m:=1; _s:=1 || _m:=2; _s:=-1 ?};
                  {? ZLIM.LIMIT='T' || _j:=1 || _j:=2 ?};
                  {? ZLIM.ZGP().NAPRAW='T' || _n:=2 || _n:=1 ?};
::                Przeskalowanie norm do ilości kalkulowanej
                  _dokl:=exec('jaka_dok_m','jm',ZLIM.KTM);
                  _rm:=roundmet();
                  roundmet(2);
                  _il:=(_s*ZLIM.LIL*_coef)$_dokl;
                  roundmet(_rm);
                  .KL.anm.add(.PT,.PRICE,.POCH,.KTL,_il);
                  .PRICE_ALL[_i][_j][_k][_m][_n]+=.PRICE*_il;
                  ZLIM.next()
               !}
            ?}
         ?}
      ?};
      .PRICE_ALL
   "),

   obj_meth('get_all_prices',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Pobiera cenę surowca, kalkulowanie rekurencyjne
::----------------------------------------------------------------------------------------------------------------------
      TMAT.cntx_psh();
      TMAT.clear();
      TMAT.index('NL');
      TMAT.prefix(.TKTL);
      {? TMAT.first()
      || _xjm:=exec('FindAndGet','#table',TKTL,.TKTL,,\"XJM\",0);
         {? .XJM<=0 || .XJM:=_xjm ?};
         _coef:={? _xjm<>0 || .XJM/_xjm || 1 ?};
         {!
         |?
::          aktywne i nie powierzone
            {? TMAT.ACT='T' & TMAT.POW='N' & .KL.tpar.calc(TMAT.EXIST)
            || .TMAT:=TMAT.ref();
               _p:=.get_price();
               _warb:={? TMAT.FORMB<>'' || .KL.tpar.calc(TMAT.FORMB)$ exec('round_abe','tech_mater',TMAT,1) || TMAT.WARB ?};
               _warn:={? TMAT.FORMN<>'' || .KL.tpar.calc(TMAT.FORMN)$ exec('round_abe','tech_mater',TMAT,1) || TMAT.WARN ?};
::             Przeskalowanie norm do ilości kalkulowanej
               _rm:=roundmet();
               roundmet(2);
               _warb:=(_warb*_coef)$ exec('round_abe','tech_mater',TMAT,1);
               _warn:=(_warn*_coef)$ exec('round_abe','tech_mater',TMAT,1);
               roundmet(_rm);

               .KL.anm.add(
                  {? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?},
                  .PRICE,
                  .POCH,
                  .KTL,
                  {? TMAT.SO='S' || 1 || -1 ?}*_warb,
                  TMAT.WYD().KOD
               );
               {? TMAT.GRKTM='K'
               || {? TMAT.PT().R='S' | M.R='H' || _i:=1
                  |? TMAT.PT().R='P' | M.R='W' || _i:=2
                                               || _i:=3
                  ?}
               || {? TMAT.TGDFLT().PT().R='S' | M.R='H' || _i:=1
                  |? TMAT.TGDFLT().PT().R='P' | M.R='W' || _i:=2
                                                        || _i:=3
                  ?}
               ?};
               {? TMAT.LIMIT='T' || _j:=1 || _j:=2 ?};
               {! _l:=1..(obj_len(.KL.FAZY))
               |! {? .KL.FAZY[_l]=TMAT.PFAZ || _k:=_l ?}
               !};
               {? TMAT.SO='S' || _m:=1; _s:=1 || _m:=2; _s:=-1 ?};
               .PRICE_ALL[_i][_j][_k][_m][1]+=.PRICE*_warb*_s
            ?};
            TMAT.next()
         !}
      ?};
      TMAT.cntx_pop();
      .PRICE_ALL
   "),

   obj_meth('get_S',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Pobiera cene surowca ze stanow magazynowych
::----------------------------------------------------------------------------------------------------------------------
      M.clear();
      M.seek(.PT);
      _t_ref:=M.ref();
      _w:=exec('get_S','kalk_mater',_t_ref,.ME,_a);
      {? type_of(_w)<>2
      || {? _w<>0
         || .PRICE:=_w;
            .OK:=1;
            .NEXT:=0;
            {? _a=0
            || .POCH:='L'
            |? _a=1
            || .POCH:='D'
            |? _a=2
            || .POCH:='L'
            ?}
         || .OK:=1;
            .NEXT:=1
         ?}
      || .OK:=1;
         .NEXT:=1
      ?}
   "),

   obj_meth('get_PTC',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Pobiera cene surowca z tableli towarow produkcyjnych.
::----------------------------------------------------------------------------------------------------------------------
      _w:='####';
      PTC.clear();
      PTC.index('TO');
      PTC.prefix(.PT);
      {? PTC.last()
      || {!
         |? _prev:=0;
            {? .DATA=date(0,0,0)
            || _w:=PTC.PRICE
            || {? .DATA>=PTC.DOD
               || {? ~((.DATA>PTC.DDO)&(PTC.DDO<>date(0,0,0))) || _w:=PTC.PRICE ?}
               || _prev:=1
               ?}
            ?};
            {? _prev || PTC.prev() ?}
         !}
      ?};
      {? type_of(_w)<>2
      || .PRICE:=_w;
         .OK:=1;
         .NEXT:=0;
         .POCH:='T'
      || .OK:=1;
         .NEXT:=1
      ?}
   "),

   obj_meth('get_HAND',"
::----------------------------------------------------------------------------------------------------------------------
:: OPIS: Pobiera cenę surowca wpisaną przez użytkownika
::----------------------------------------------------------------------------------------------------------------------
      _w:=.KL.anm.chk(.PT,'H',.KTL);
      {?
         _w>0 | .KL.run1m=0
      || .PRICE:={? _w<0 || 0 || _w ?};
         .OK:=1;
         .NEXT:=0;
         .POCH:={? _w<0 || 'R' || 'H' ?}
      ||
         M.clear();
         _ok:=M.seek(.PT);
         _tab:=tab_tmp(,
            'WYN','REAL','Cena'@,
            'SYM','STRING[100]','Symbol',
            'KTM','STRING[50]','Indeks'@,
            'N','STRING[100]','Nazwa'@,
            'TKTL','STRING[100]','Technologia'@
         );
         _tab.SYM:=.KL.Desc;
         _tab.KTM:=M.KTM;
         _tab.N:=M.N;
         _tab.TKTL:=exec('FindAndGet','#table',TKTL,.KTL,,\"NRK+' / '+WER\",'');
         _red:=_tab.mk_edit(FUN.TYT,,'redrecznie');
         _tab.win_esep(_red,.KL.Header);
         _tab.win_efld(_red,,'SYM',,,100,,1);
         _tab.win_esep(_red,'Materiał'@);
         _tab.win_efld(_red,,'KTM',,,100,,1);
         _tab.win_efld(_red,,'N',,,100,,1);
         {? _tab.TKTL<>'' || _tab.win_efld(_red,,'TKTL',,,100,,1) ?};
         _tab.win_efld(_red,,'WYN',,,15,4);
         _tab.win_ebtn(_red,'text=%1'['Zapisz'@],'key:F2');
         _tab.win_ebtn(_red,'text=%1'['Anuluj'@],'key:Esc');
         _tab.win_edit(_red);
         {? _tab.edit()
         || .PRICE:=_tab.WYN;
            .OK:=1;
            .NEXT:=0;
            .POCH:='H';
            {? .ADD=1 || .ADD:=1234 ?}
         || .POCH:='R';
            .OK:=0;
            .NEXT:=0
         ?};
         undefine()
      ?};
      0
   ")

);
1


::======================================================================================================================
:: Wydzielone funkcje
::======================================================================================================================


\get_S
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Wylicza cenę surowca - wywołanie w metodzie get_S
::       - Dla wariantu "1" bierzemy pod uwagę dokumenty przychodowe (PZ) wyliczając cenę średnią jako:
::         [suma wartości] / [suma ilości]. Jeżeli parametr: <ilość miesięcy wstecz> jest większy od zera, to sumowanie
::         następuje po tych miesiącach, ale tylko w zakresie bieżącego roku. Jeżeli parametr: <ilość miesięcy wstecz>
::         jest równy zero, to analiza następuje wstecz do miesiąca, w którym znajdzie się cena.
::       - Dla wariantu "0,2" bierzemy pod uwage ostatnią dostawę do magazynu Parametr <ilość miesięcy wtecz> traktowany
::         jest identycznie jak w punkcie poprzednim.
::
::   WE: _a - M.ref()
::       _b - obiekt kalkulacyjny
::       _c - wariant liczenia ceny: 0,1,2
::   WY: wyznaczona cena lub tekst '####' gdy nie wyznaczono
::  OLD: \get_S/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
::msg('get_S\nsposob: '+$_b.S+'\nmiesiecy: '+$_b.MC);
_t_ref:=_a;
_wariant:=_c;
_mies:=_b.MC;
_sel:=_b.SELECT;
_first:=1;
_dalej:=1;
M.clear();
M.seek(_t_ref);
_wynik:='####';
{? _wariant=1
|| _wartosc:=0;
   _ilosc:=0;
:: Tutaj iteracja po okresach wstecz
   _rok:=ST.AR;
   _okres:=ST.AM;
   _i:=0;
   {? _mies<0
   || _mies:=-_mies;
      _poc:=1
   || _poc:=0
   ?};
   {!
   |?
::    Pierwszy obrabiany okres - pobieram ceny z roku do zmiennej __SumaC oraz dosumowuję wartości i ilości z miesiąca
      {? _first=1
      || exec('wyb_cene','kalk_mater',M.KTM,_rok);
         __SumaC.prefix();
         {? __SumaC.first()
         || {!
            |? {? __SumaC.DOST~2=_okres
               || _wartosc+=__SumaC.WAR;
                  _ilosc+=__SumaC.IL
               ?};
               __SumaC.next()
            !}
         ?};
         _first:=0;
         _okres-=1;
         _i+=1

::    Każdy kolejny okres wstecz - dosumowuję wartości i ilości z miesiąca
      || __SumaC.prefix();
         {? __SumaC.first()
         || {!
            |? {? __SumaC.DOST~2=_okres
               || _wartosc+=__SumaC.WAR;
                  _ilosc+=__SumaC.IL
               ?};
               __SumaC.next()
            !}
         ?};
         _i+=1;
         _okres-=1
      ?};

::    Okres zerowy...
      {? _okres=0
      ||
::       Cofam rok i pobieram ponownie ceny do zmiennej __SumaC
         {? _poc=0
         || _i+=1;
            _rok-=1;
            _okres:=12;
            exec('wyb_cene','kalk_mater',M.KTM,_rok)
::       Jeżeli nie pobieram cen z poprzedn iego roku, to już kończę
         || _i:=_mies
         ?}
      ?};
      _i<_mies
   !};
   {? _ilosc>0 || _wynik:=(_wartosc/_ilosc)$2 || _wynik:=0 ?}
|? _wariant=0 | _wariant=2
|| _wynik:='####';
   _wartosc:=0;
   _ilosc:=0;
   _rok:=ST.AR;
   _okres:=ST.AM;
   _i:=0;
   _wynik:=0;
   {? _mies<0
   || _mies:=-_mies;
      _poc:=1
   || _poc:=0
   ?};
   {!
   |? {? _okres>0
      || _wynik:=exec('cena_SS','kalk_mater',_t_ref,_okres,_rok);
         _i+=1;
         _okres-=1
      || {? _poc=0
         || _okres:=12;
            _rok-=1;
            exec('open','open_tab',ST.ODDZ,2-$_rok);
            _wynik:=exec('cena_SS','kalk_mater',_t_ref,_okres,_rok)
         || _i:=_mies
         ?}
      ?};
      _wynik=0 & _i<_mies
   !};
   exec('open','open_tab',ST.ODDZ,2-$ST.AR);
   {? _wynik=0 || _wynik:='####' ?}
?};
_wynik


\wyb_cene
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2008]
:: OPIS: Wybiera pozycje przychodowych zaakceptowanych dokumentów magazynowych z danego roku
::   WE: _a - kod towaru
::       _b - rok
::   WY: wynik umieszczany jest w zmiennej globalnej __SumaC
::  OLD: \wyb_cene/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__SumaC')>0 || obj_del(__SumaC) ?};
_par:=exec('get','#params',500003,2);
_par:=gsub(_par,' ','\''+','+'\'');
_par:='\''+_par-2;
__SumaC:=sql(''
           +"
              select
                 DK.DOST
                ,DK.WAR
                ,DK.IL
              from
                @DK
                join M using (DK.M,M.REFERENCE)
                join @ND using(DK.N,ND.REFERENCE)
                join TYPYDOK using(ND.TYP,TYPYDOK.REFERENCE)
              where
                    DK.PLUS='T'
                and M.KTM like ':_a'
                and DK.AR=:_b
                and DK.Z='T'
            "
           +{? _par<>''
            || " and TYPYDOK.T in (:_c) "
            || ""
            ?}
           ,gsub(_a,'\'','\'\'')
           ,_b
           ,_par
           );
~~


\cena_SS
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: Wybiera cenę z ostatniej dostawy w kolejności
::   WE: _a - M.ref()
::       _b - okres (numer miesiąca)
::       _c - rok (numer roku)
::   WY: cena ostatniej dostawy
::  OLD: \cena_SS/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
_par:=exec('get','#params',500003,2);
_par:=STR.gsub(_par,' ','\''+','+'\'');
_par:='\''+_par-2;
_wynik:=sql(''+"
   select
      SC.D,
      SC.C,
      SC.REFERENCE as REF,
      TYPYDOK.T
   from
      @SC
      join M using(SC.M,M.REFERENCE)
      join @DK using(SC.PRDK,DK.REFERENCE)
      join @ND using(DK.N,ND.REFERENCE)
      join TYPYDOK using(ND.TYP,TYPYDOK.REFERENCE)
   where
      SC.D<=to_date(':_a') and
      SC.D>=to_date(':_b') and
      M.REFERENCE=:_c"
  +{? _par<>''
   || " and TYPYDOK.T in (:_d) "
   || " "
   ?}
  +"order by 1,2"
   ,
   $date(_c,_b,0),$date(_c,_b,1),_a,_par
);

{? type_of(_wynik)=type_of(~~) || exec('err_sql','#sql'); return(0) ?};

SC.cntx_psh();
{? _wynik.last()
|| _ndx:=_wynik.ndx_tmp(,1,'D',,);
   _wynik.index(_ndx);
   _wynik.last();
   SC.clear();
   {? SC.seek(_wynik.REF,8+_wynik.REF)
   || _cena:=exec('cena_mag','ceny',_a,SC.RDK,SC.NDK,,SC.C)
   || _cena:=0
   ?}
|| _cena:=0
?};
SC.cntx_pop();
_cena


\get_prod_price
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.70]
:: OPIS: Pobiera cenę półfabrykatu.
::   WE: _a: Wskazanie do obiektu pTMAT
::       _b: TKTL surowca
::       _c: ref() surowca
::   WY: ~~
::  OLD: \get_prod_price/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
::TODO:
::_cena:=ProD_get(_b,null());
_cena:=0;
:: jedynie w get_prod_price dodawane są pozycje ProDpric,
:: więc nie ma sensu dwa razy sprawdzać warunku, czy technologia może być dodana do tabelki, czy nie
:: jeśli technologia ma parametry, to nie powinna sie pojawi w ProDpric!
_w:=0;
{? _cena>0
|| _cena
|| _save:=_a.KL.SAVE;
   _calc:=_a.REK;
   _a_ktl:=VAR.A_KTL;
   exec('tktl_cntx_psh','tech_common');
   _msk:=((8+ref_name(_b))+3);
   exec('tktl_use','tech_common',_msk);
   TKTL.clear();
   TKTL.seek(_b);
:: ustalona TKTL
:: pobieramy rubrykę ceny
   _crub:=TKTL.TYP().CRUB;
::{? TKTL.seek(_b);(5+TKTL.NRK)='00000' || msg('get_prod_price')?};
:: hmm... czy surowiec ma tablicę translacji?
   TPARTRA.clear();
   TPARTRA.index('SUR');
   {? _a.ZAM=0
   || TPARTRA.prefix(_c,null())
   || TPARTRA.prefix(null(),_c)
   ?};
   {? TPARTRA.first()
:: jest translacja, czyli jeśli rekurencja to liczymy
   || _save:=0
:: nie ma translacji, czyli technologia nie ma parametrów,
:: więc sprawdzmy czy jest aktualna zatwierdzona kalkulacja
   || TKTL.clear();
      KKTL.clear();
      {? TKTL.seek(_b)
      || KKTL.index('KZ');
         KKTL.prefix(TKTL.ref(),'T',TKTL.KTM);
         _chkd:=1;
         {? KKTL.first()
::          jest kalkulacja zatwierdzona
         || {? KKTL.DW>=date()
::             kalkulacja jest aktualna
            || KPOZK.clear();
               KPOZK.index('KR');
               KPOZK.prefix(KKTL.ref(),_crub);
               {? KPOZK.first || _calc:=0; _chkd:=0; _w:=KPOZK.WART ?}
            ?}
         ?};
         {? _chkd
::          nie ma zatwierdzonej kalkulacji, więc...
::          poszukamy wśród "Do zatwierdzenia"
         || KKTL.prefix(TKTL.ref(),'D',TKTL.KTM);
            {? KKTL.first()
::             aha... jest...
            || {? KKTL.DW>=date()
::                kalkulacja jest aktualna
               || KPOZK.clear();
                  KPOZK.index('KR');
                  KPOZK.prefix(KKTL.ref(),_crub);
                  {? KPOZK.first || _calc:=0; _w:=KPOZK.WART ?}
               ?}
            ?}
         ?}
     ?}
   ?};
   {| _a.KL
   |!
      {? _calc
::       jeśli mamy kalkulować, no to zaczynajmy
      || _KL:=obj_new(@.CLASS.ANKA);
         {? var_pres('__LEVEL')>0 || __LEVEL+=1 ?};
         exec('sv_load4air','tech_kalk',_KL);
         KOMM.sect_beg(' '+'Kalkulacja: <tymczasowa>, technologia: %1 wersja: %2'@[TKTL.NRK,TKTL.WER]);
         {? _KL.load(_b)
         || TPAR.clear();
            {? TPARTRA.first()
            || {!
               |? _KL.tpar.set(TPARTRA.PAR().NRP, tpar.calc(TPARTRA.TRANS));
                  TPARTRA.next()
               !}
            ?};
:            _KL.MOV:=MOV+1;
:            _KL.MSG:=' Kalkulacja: <tymczasowa>, technologia: '+TKTL.NRK+' wersja: '+TKTL.WER;
            _KL.SAVE:=_save;
            _tktl:=@.TKTL.ref();
            {? _KL.calc__()
            || _w:=_KL.L[1][_crub];
               {? (_KL.tpar.N<=0) & (_w>0)
: jesli technologia nie ma parametrow, a wynik jest dodatni, to wrzucim go do tabelki (po co kilka razy liczyc to samo)
               || ProD_add(_tktl,null(),_w)
               ?}
            ?};
            TKTL.clear();
            {? _save & TKTL.seek(_b)
            || exec('KKTL_new','tech_kalk',TKTL.ref(),{? TKTL.DEF_OPCK=null() || TKTL.TYP().DEF_OPCK || TKTL.DEF_OPCK ?},TKTL.KTM,'D');
               _KL.KALK:=KKTL.ref();
               _KL.save();
               exec('KKTL_update','tech_kalk',_KL.KALK);
               1
            ?}
         ?};
         KOMM.sect_end()
      ?}
   |};
   exec('tktl_cntx_pop','tech_common');
   VAR.A_KTL:=_a_ktl;
   _w
?}



\get_prod_price2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Pobiera cenę półfabrykatu dla kalkulacji zlecenia złożonego (z kalkulacji zlecenia półfabrykatu).
::   WE: _a: ZL.ref() - zlecenie surowca (półfabrykatu)
::   WY: wartość (cena) półfabrykatu
::----------------------------------------------------------------------------------------------------------------------
_w:=0;
_zl:={? var_pres('_a')=type_of(null()) || _a || null() ?};
ZL.cntx_psh();
ZL.prefix();
{? ZL.seek(_zl)
||
:: pobranie rubryki z ceną jednostkową
   _crub:=ZL.TYP().CRUBJEDN;
:: Sprawdzenie, czy jest aktywna kalkulacja
   ANZH.cntx_psh();
   ANZP.cntx_psh();
   ANZH.index('ZNA');
   ANZH.prefix('0',ZL.ref(),'T');
   {? ANZH.first()
   || ANZP.index('NRARUB');
      ANZP.prefix(ANZH.ref(),_crub);
      {? ANZP.first
      || _w:=ANZP.WAR
      ?}
   ?};
   ANZH.cntx_pop();
   ANZP.cntx_pop()
?};
ZL.cntx_pop();
_w


\get_mat_price
::----------------------------------------------------------------------------------------------------------------------
::  UTW: ???
:: OPIS: pobiera wartość pobranych materiałów na zlecenie
::   WE: _a - wskazanie na obiekt ANKA
::       _b - ZL.ref()
::       _c - okres analizy ANZH.OKR (0), wszystko od początku zlecenia (1)
::   WY: _wynik - 1. wymiar - 'W','P','S', ('H' - nie powinno wystąpić)
::                2. wymiar - limitowany/nielimitowany
::                3. wymiar - fazy produkcji
::                4. wymiar - 'S', 'O'
::                5. wymiar - 'N', 'T' - surowce pobrane do operacji naprawczych
::  OLD: \get_mat_price/zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
_wynik:=obj_new(4);
{! _ii:=1..4
|! _wynik[_ii]:=obj_new(2);
   {! _jj:=1..2
   |! _wynik[_ii][_jj]:=obj_new(obj_len(_a.FAZY));
      {! _kk:=1..(obj_len(_a.FAZY))
      |! _wynik[_ii][_jj][_kk]:=obj_new(2);
         {! _mm:=1..2
         |! _wynik[_ii][_jj][_kk][_mm]:=obj_new(2);
            {! _nn:=1..2
            |! _wynik[_ii][_jj][_kk][_mm][_nn]:=0
            !}
         !}
      !}
   !}
!};
_ii:=_jj:=kk:=_mm:=nn:=0;

exec('openmask','zl_common',_b);
ZLIM.index('ZMW');
VAR.A_ZLEC:=_b;
{? VAR.A_ZLEC().GENLIM='N' & VAR.A_ZLEC().NRNZL<>0
|| ZLIM.prefix(VAR.A_ZLNAD)
|| ZLIM.prefix(_b)
?};
{? ZLIM.first()
|| {!
   |? {? ZLIM.KOR=0
      || _wpm:=ZLIM.KTM().R;
         {? _wpm='S' || _ii:=1
         |? _wpm='P' || _ii:=2
         |? _wpm='W' || _ii:=3
         |? _wpm='H' || _ii:=4
         ?};
         {? ZLIM.LIMIT='T' || _jj:=1 || _jj:=2 ?};
         {! _ll:=1..(obj_len(_a.FAZY))
         |! {? ZLIM.PFAZ=_a.FAZY[_ll] || _kk:=_ll ?}
         !};
         {? ZLIM.SO='S' || _mm:=1 || _mm:=2 ?};
         {? _c
         || _pob:=exec('zlim_pob_il','zl_limit',$ZLIM.ref())
         || _pob:=exec('zlim_pob_il','zl_limit',$ZLIM.ref(),ANZH.OKR().ROK,ANZH.OKR().MC)
         ?};
         {? ZLIM.ZGP().NAPRAW='T' || _nn:=2 || _nn:=1 ?};
         _wynik[_ii][_jj][_kk][_mm][_nn]+=_pob.WAR_RW;
         _wynik[_ii][_jj][_kk][_mm][_nn]-=_pob.WAR_ZW;
         obj_del(_pob)
      ?};
      ZLIM.next()
   !}
?};
_wynik


\get1_src_price
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [7.60] OWwPR032
:: OPIS: funkcja m() w obiekcie ANKA dla kalkulacji zlecenia
::       (dziala jak get_src_price/kalk_mater, ale dla kalkulacji wstępnej zlecenia)
::   WE: _a=AN
::       _b=TKTL.ref()
::       _c=kolejność ustalania ceny
::       _d=materiał/półprodukt/wyrób
::       _e=faza produkcyjna (lub jej nieokresloność)
::       _f=ilość miesięcy do analizy ceny.
::       _g=czy cena jest pobierana ze stanów, czy uśredniana z dokumentów
::       _h=czy wprowadzane z ręki ceny zapamiętywane są w PTC.
::       _i=inf. czy ilość surowca ma być pobierana z limitów czy z technologi wykonawczej zlecenia.
::       _j=inf. czy obliczenia dotyczą tylko tego zlecenia (1) czy wszystkich podzleceń (0)
::       _k=ilość kalkulowana (xjm), do jakiej skalować wynik. Gdy równa zeru to skalowanie wg ilości na zleceniu
::   WY: _wynik[_i][_j][_k][_l][m]
::       _i - przemieszczanie sie po osi: M (surowce, wyroby handlowe), P (półfabrykaty, wyroby), (inne)
::       _j - os limowane/nielimitowane
::       _k - os faz produkcji
::       _l - 'S'urowiec, 'O'dpad
::       _m - 'N', 'T' - surowce pobrane do operacji naprawczych (tylko przy pobieraniu norm z limitow)
::  OLD: \get_src_price/zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
_an:=_a;

{? var_pres('_b')=type_of('')
|| _ref:=BIT.sqlint(_b);
   _msk:=(8+_b)+3
|? var_pres('_b')=type_of(null())
|| _ref:=#_b;
   _msk:=ref_name(_b)+3
|| _ref:=0;
   _msk:='___'
?};

_parametr:=_c;
_miesiace:=_f;
_wariant:=_g;
_add:=_h;
_pobier_il:=_i;
_xjm:=_k;
_calc:=0;
_wynik:=0;

exec('tktl_cntx_psh','tech_common');
exec('tktl_use','tech_common',_msk);

_can_continue:=1;
{? _ref>0
|| _can_continue:=TKTL.seek(_ref,)
?};

{? _can_continue>0
||
   _tktl_ref:=null();
   {? _ref>0
   || _tktl_ref:=TKTL.ref()
   ?};

   exec('TMAT_get_src','kalk_mater');
   {? var_pres('pZMAT',@)>0 || obj_del(pZMAT) ?};
   pZMAT:='TEST';
   pZMAT:=obj_new(@.CLASS.TMAT_get_src);
   {? type_of(pZMAT)<>2
   || pZMAT.set_TKTL(_an,_tktl_ref);
      _calc:=1;
      {| pZMAT
      |! HAND:=1;
         NO_ESC:=1;
         SELECT:=1;
         LIM:=_pobier_il;
         PTC:={? type_of(_parametr)=1
              || {? _parametr=0
                 || {? _wariant=0
                    || 'LTH'
                    || 'DTH'
                    ?}
                 |? _parametr=1
                 || {? _wariant=0
                    || 'TLH'
                    || 'TDH'
                    ?}
                 |? _parametr=2
                 || 'TH'
                 |? _parametr=3
                 || {? _wariant=0
                    || 'LH'
                    || 'DH'
                    ?}
                 ?}
               || _parametr
               ?};
         S:=_wariant;
         MC:=_miesiace;
         XJM:=_xjm;
         ADD:=_add
      |};
      {? _tktl_ref<>null()
      || TKTL.clear();
         TKTL.seek(_tktl_ref)
      ?};
      _wynik:={? _calc
              ||
                 {? var_pres('__TMAT')>0 & var_pres('__LEVEL')>0 & __LEVEL=1
                 || {? VAR.A_ZLEC().NRNZL<>0 & _j=1
                    || pZMAT.get2_all_prices('1')
                    || pZMAT.get2_all_prices()
                    ?}

                 || {? VAR.A_ZLEC().NRNZL<>0 & _j=1
                    || pZMAT.get3_all_prices('1')
                    || pZMAT.get3_all_prices()
                    ?}
                 ?}
               || 0
               ?};
      obj_del(pZMAT)
   || FUN.emsg('Błędne działanie formuły.'@)
   ?}
?};

exec('tktl_cntx_pop','tech_common');
_wynik


\madezl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [2006]
:: OPIS: Pobiera ilości wykonanych/zwróconych wyrobów.
::   WE: _a: '+' raporty z produkcji
::           '-' zwroty na produkcje
::       _b: 0 - dokumenty tylko z okresu analizy, 1 - dokumenty od początku zlecenia
::       _c: symbol zlecenia
::       _d: okres prowadzenia analizy
::     [_e]: symbole typów dokumentu branych pod uwagę (domyślnie FO:500701(+) i FO:500703(-))
::   WY: ilosc wykonanych/zwróconych produktów
::
::UWAGA: symbole typów muszą być podane w postaci jak w FO.TR, czyli 'TYP TYP2 ... TYPN ' (spacja na koncu!)
::  OLD: \madezl/zlec4.fml
::----------------------------------------------------------------------------------------------------------------------
_wynik:=0;

_plusmin:={? _>0 & type_of(_a)=2 & _a='-' || _a || '+' ?};

_frombeg:={? _>1 & type_of(_b)=1 || _b || 0 ?};
  _ZLSYM:={? _>2 & type_of(_c)=2 || _c || '' ?};
 _OKRref:={? _>3 & type_of(_d)=7 || _d || null() ?};

 _TypDok:={? _>4 & type_of(_e)=2 || _e || {? _plusmin='-'
                                          || exec('get','#params',500703,2,null())
                                          || exec('get','#params',500701,2,null())
                                          ?}
          ?};

ND.cntx_psh();
DK.cntx_psh();
OKR.cntx_psh();
OKR.clear();

{? OKR.seek(_OKRref)
|| _ar:=OKR.ROK; _am:=OKR.MC
|| _ar:=ST.AR;   _am:=ST.AM
?};

_D:=sql(''
       +"
           SELECT
              SUM(DK.IL) IL
             ,ZL.SYM
           FROM
              @DK
              JOIN ZL  USING(DK.ZL, ZL.REFERENCE)
              JOIN @ND USING(DK.N,  ND.REFERENCE)
              JOIN TYPYDOK USING(ND.TYP, TYPYDOK.REFERENCE)
           WHERE 1=1
              AND ND.Z='T'
              AND ND.TYP IN (SELECT SQLREF FROM :_a)
              AND ZL.SYM=':_b'
              AND ZL.KTM=DK.M
        "
       +{? _frombeg=0
        || ""
        || "
              AND ND.AR=:_c
              AND ND.AM=:_d
           "
        ?}
       +"
           GROUP BY
              ZL.SYM
        "
       ,exec('GetTabFromList','#table','TYPYDOK','T',_TypDok)
       ,_ZLSYM
       ,_ar
       ,_am
       );

{? type_of(_D)=type_of(SYSLOG)
 & _D.first()
|| _wynik:=_D.IL
?};

OKR.cntx_pop();
ND.cntx_pop();
DK.cntx_pop();

_wynik


::======================================================================================================================
:: Zamienniki w symulacji what-if
::======================================================================================================================


\sur_kalk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MK [8.10]
:: OPIS: Utworzenie i wypełnienie tabeli tymczasowej surowców technologii.
::  OLD: \sur_kalk/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__TMAT')<=0
|| __TMAT:=tab_tmp(1,
      'LP','INTEGER','Lp.',
      'REF','STRING[16]','$TMAT.ref()',
      'PTREF','INTEGER','#M.ref()',
      'KOD','STRING[50]','Kod surowca',
      'NAZ','STRING[100]','Nazwa surowca',
      'TKTL','STRING[16]','$TKTL.ref()',
      'WPM','STRING[1]','WPM',
      'P','STRING[1]','Podstawowy',
      'L','STRING[1]','Limitowany',
      'SO','STRING[1]','Surowiec/odpad',
      'TCHMAT','STRING[16]','$TCHMAT.ref()'
   );
   __TMAT.fld_attr(,2);

   TMAT.clear();
   TMAT.index('NNL');
   TMAT.prefix(VAR.A_KKTL().NRK);
   {? TMAT.first()
   || _i:=1;
      {!
      |?
         __TMAT.LP:=_i;
         __TMAT.REF:=$TMAT.ref();
         {? TMAT.GRKTM='K'
         || __TMAT.PTREF:=#TMAT.PT;
            __TMAT.KOD:=TMAT.PT().KTM;
            __TMAT.NAZ:=TMAT.PT().N;
            __TMAT.WPM:=TMAT.PT().R
         || __TMAT.PTREF:=#TMAT.TGDFLT().PT;
            __TMAT.KOD:=TMAT.TGDFLT().PT().KTM;
            __TMAT.NAZ:=TMAT.TGDFLT().PT().N;
            __TMAT.WPM:=TMAT.TGDFLT().PT().R
         ?};
         __TMAT.TKTL:=$TMAT.KTL;
         __TMAT.P:=TMAT.PODST;
         __TMAT.L:=TMAT.LIMIT;
         __TMAT.SO:=TMAT.SO;
         __TMAT.TCHMAT:='';
         _i+=1;
         __TMAT.add();
         TMAT.next()
      !}
   ?}
?};
_wertmat:=__TMAT.mk_sel('Surowce kalkulowanej technologii'@,'N',0,'tmat_wer',,5,29);
__TMAT.win_fld(_wertmat,,'LP',,,4,,,'Lp.'@);
__TMAT.win_fld(_wertmat,,'KOD',,,20,,,'Kod'@);
__TMAT.win_fld(_wertmat,,'NAZ',,,40,,,'Nazwa'@);
__TMAT.win_fld(_wertmat,,'WPM',,,2,,,'W'@);
__TMAT.win_fld(_wertmat,,'P',,,2,,,'P'@);
__TMAT.win_fld(_wertmat,,'L',,,2,,,'L'@);
__TMAT.win_fld(_wertmat,,'SO',,,2,,,'SO'@);
__TMAT.win_act(_wertmat,0,'Formuła','Zamienniki'@@,,,"exec('zamsur','kalk_mater')",,1);
__TMAT.win_sel(_wertmat);
__TMAT.prefix();
__TMAT.first();
__TMAT.select();
~~


\zamsur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MK [8.10]
:: OPIS: Pokazuje zamienniki podczas kalkulowania karty
::  OLD: \zamsur/tex_tmat.fml
::----------------------------------------------------------------------------------------------------------------------
TMAT.prefix();
{? TMAT.seek(__TMAT.REF)
|| _env_mater:=exec('env_mater','tech_mater');
   _env_mater.fields.MAT:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};
   params_set('env_mater',_env_mater);
   exec('pokaz_zam_mech','tech_mater',3)
?};
~~


\anzamsur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MKO [8.10]
:: OPIS: Pokazuje zamienniki podczas kalkulowania/analizowania zlecenia
::  OLD: \anzamsur/zl_zmat.fml
::----------------------------------------------------------------------------------------------------------------------
{? __TMAT.REF<>''
|| TMAT.prefix();
   {? TMAT.seek(__TMAT.REF)
   || _env_mater:=exec('env_mater','tech_mater');
      _env_mater.fields.MAT:={? TMAT.GRKTM='G' || TMAT.TGDFLT().PT || TMAT.PT ?};
      params_set('env_mater',_env_mater);
      exec('pokaz_zam_mech','tech_mater',4)
   ?}
|| FUN.emsg('Surowiec nie posiada odpowiednika w prototypowej karcie technologicznej.'@)
?}

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:37 8081438104f5463392dde72a7575c54ee26daca44e3713fd512ef7146ffb2cd8000a9d6eeae8967f72951c1b89bb36c0f0519cf79f49d44f0c53fce3715bf384c194108bc8f3a9f08fdc5ac618a3ac5aca95dcf04c1fb380560e678b9dad9832286c01614ec2e2dcfd19a18eb6ba5af96ce058489af7f417ed894ad6a31c7631
