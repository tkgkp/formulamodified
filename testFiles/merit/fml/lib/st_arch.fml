:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: st_arch.fml
:: Utworzony: 01.06.2020
:: Autor: WJ
::======================================================================================================================
:: Zawartość: Obsługa masek dla systemu Statystyki
::======================================================================================================================

\params
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Zwraca stałe wartości parametrów potrzebne do mechanizmu maskowania:
::       - Rozmiary buforow maskowalnych tabel, po to by użyć ich w obliczeniach ile
::         rekordów można jeszcze w pliku maski zmieścić
::       - Akronimy tabel maskowanych
::       - Początki nazw masek tabel maskowanych
::       - Maksymalny rozmiar pliku *.mdb
::       - Procent wolnego miejsca jaki powinien zostać w masce (po to żeby po dodaniu
::          pola w przyszlej wersji rozmiar pliki mdb sie nie przekroczył i udał się transfer)
::
::       Aby dodać nową tabele do mechanizmu archiwizacji należy wypelnić jej tutaj
::       parametry oraz dopisać do formuły exec('get_mask_tables','st_arch')
::   WY: obj_new
::  OLD: \params/stat_arch.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('ST_ARCH_PAR')<100
||
   ST_ARCH_PAR:=obj_new(

::    Rozmiary buforów tabel maskowalnych w bajtach
      'buffers'

::    Akronimy tabel maskowalnych
      ,'tables'

::    Poczatki nazw masek
      ,'msk_prefix'

::    Maksymalny rozmiar maski w bajtach
      ,'FILESIZE'

::    Maksymalna liczba rekordów w masce
      ,'REC_MAX'

::    Procent wolnego miejsca jaki powinien zostać jeszcze w masce
      ,'FREE_PROC'
   );

   _ff:=exec('get_mask_tables','st_arch');
:: Tworze tablice nazwane o polach nazywajacych się tak jak wszystkie nazwane tablice
   ST_ARCH_PAR.buffers:=_ff();
   ST_ARCH_PAR.tables:=_ff();
   ST_ARCH_PAR.msk_prefix:=_ff();

:: Przypisuje aliasy tabel
   ST_ARCH_PAR.tables.ST_SRC:=ST_SRC;
   ST_ARCH_PAR.tables.ST_LOG:=ST_LOG;
   ST_ARCH_PAR.tables.ST_SEST2:=ST_SEST2;
   ST_ARCH_PAR.tables.ST_SESJ2:=ST_SESJ2;

:: Przypisuje początki nazw masek
   ST_ARCH_PAR.msk_prefix.ST_SRC:='st_z';
   ST_ARCH_PAR.msk_prefix.ST_LOG:='st_l';
   ST_ARCH_PAR.msk_prefix.ST_SEST2:='st_t';
   ST_ARCH_PAR.msk_prefix.ST_SESJ2:='st_e';

:: Dla każdej tableli obliczam rozmiar bufora
   {! _it:=1..obj_len(ST_ARCH_PAR.tables)
   |! ST_ARCH_PAR.buffers[_it]:=exec('tab_buffer_size','#table',ST_ARCH_PAR.tables[_it])
   !};

::----------------GB--MB---KB---B--
   ST_ARCH_PAR.FILESIZE:=28*1024*1024*1024;

:: póki co 30 mln
   ST_ARCH_PAR.REC_MAX:=30000000;
::   ST_ARCH_PAR.REC_MAX:=20000;

:: Dopełniamy maski do 60% - 40% zostaje wolnego na poczet przyszłych transferów i rozrostu tabel
   ST_ARCH_PAR.FREE_PROC:=40;
::   ST_ARCH_PAR.FREE_PROC:=0;
   ~~
?};
ST_ARCH_PAR


\get_mask_tables
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Zwraca formułę która utworzy tablicę nazwaną, której pola nazywają się tak jak
::       wszystkie maskowane tabele
::   WY: FORMULA
::  OLD: \get_mask_tables/stat_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_ff:="
   obj_new('ST_SRC','ST_LOG','ST_SESJ2','ST_SEST2')
";
_ff


\open
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Otwiera maski tabel
::   WE: [_a] - STRING - maska która otworzyć, jeśli nie podane to otwierana jest ostatnia maska
::       [_b] - czy sprawdzać istnienie obiektu parametrów i go ewentualnie inicjować (domyślnie 1 - tak)
::       [_c] - INTEGER - tryb komunikatów: 0, brak, [1] - na ekran, 2 - KOMM
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \open/stat_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_can_continue:=1;

_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};

ST_ARCH.cntx_psh();
ST_ARCH.index('MASK');
{? var_pres('_a')=type_of('')
|| _msk:=_a
|| _msk:='';

:: Sprawdzam czy maska początkowa istnieje, jeżeli nie to ją zakładam
   _msk:=exec('last','st_arch');
   {? _msk=''
   || _ref:=exec('new_arch','st_arch');
      {? _ref<>null()
      || ST_ARCH.prefix();
         {? ST_ARCH.seek(_ref)
         || _msk:=ST_ARCH.MASK
         ?}
      || _can_continue:=0;
         _msg:='Nie powiodło się założenie nowej maski.'@;
         {? _dialog=1
         || FUN.emsg(_msg)
         |? _dialog=2
         || KOMM.add(_msg,2,,1)
         ?}
      ?}
   ?}
?};
{? var_pres('_b')=type_of(0)
|| _spr_par:=_b
|| _spr_par:=1
?};

{? _can_continue>0
||
:: Sprawdzam czy dana maska jest w archiwum
   ST_ARCH.prefix(_msk,);
   {? ST_ARCH.first()=0
   || _can_continue:=0;
      _msg:='Nie powiodło się otwarcie maski: %1'@[_msk];
      {? _dialog=1
      || FUN.emsg(_msg)
      |? _dialog=2
      || KOMM.add(_msg,2,,1)
      ?}
   ?}
?};

{? _can_continue>0
||
:: Otwieranie maski
   _params:={? _spr_par || exec('params','st_arch') || ST_ARCH_PAR ?};
   {! _it:=1..obj_len(_params.tables)
   |! _params.tables[_it].use(_params.msk_prefix[_it]+_msk)
   !}
?};
ST_ARCH.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\buffer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Zwraca obiekt nazwany - bufor tabeli ST_ARCH
::   WE: [_a] FORMULA - dodatkowe pola do obiektu - umieszczane na końcu - nie obsługiwane przez standardowe metody [""]
::   WY: obj_new()
::  OLD: \buffer/stat_arch.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=3
|| _buffer:=exec('obj_new','#buf','ST_ARCH',_a)
|| _buffer:=exec('obj_new','#buf','ST_ARCH',)
?};
_buffer


\add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Funkcja dodająca wpis do tabeli ST_ARCH
::   WE: _a - obj_new - tablica nazwana bedaca buforem tabeli exec('buffer','st_arch')
::   WY: ST_ARCH.ref() - wskazanie na dodany rekord (lub już istniejący)
::  OLD: \add/stat_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_buffer:={? var_pres('_a')>100 || _a || return(null) ?};

_res:=null();
ST_ARCH.cntx_psh();
ST_ARCH.prefix();
_buffer.set();
{? ST_ARCH.add()
|| _buffer.get();
   _res:=_buffer.ref()
?};
ST_ARCH.cntx_pop();
_res


\new_arch
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH[20.42]
:: OPIS: Nadaje nową maske tabeli ST_ARCH i dodaje nowe archiwum
::   WY: ref ST_ARCH lub null()
::  OLD: \new_arch/stat_arch.fml
::----------------------------------------------------------------------------------------------------------------------

_res:=null();

:: ciag znakowy - znaki dostępne w masce (kolejność ich jest isotna)
_chars:=''; {! _i:=48..57 |! _chars+=%_i !}; {! _i:=97..122 |! _chars+=%_i !};

:: powołanie obiektu generującego maski
exec('declGenMask','#bi_arch');
_mask:=obj_new(@.CLASS.GENMASK,4,_chars);

_lp:=0;
ST_ARCH.cntx_psh();
ST_ARCH.index('MASK');
ST_ARCH.prefix();
{? ST_ARCH.last()
|| _num:=_mask.maskNum(ST_ARCH.MASK)+1;
   _lp:=ST_ARCH.LP_LAST
|| _num:=1
?};
ST_ARCH.cntx_pop();

_buffer:=exec('buffer','st_arch');
ST_ARCH.blank();
_buffer.get();

_buffer.LP:=_num;
_buffer.LP_LAST:=_lp;
_buffer.MASK:=_mask.numMask(_num);
_buffer.TM_ADD:=ST_ARCH.tm_stamp();
_buffer.DESC:='MASKA: <'+_buffer.MASK+'>';
exec('add','st_arch',_buffer);
_res:=_buffer.Ref;

obj_del(_mask);
obj_del(_buffer);
_res


\last
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Zwraca ostatnią maskę z archiwum
::   WY: STRING - ostatnia maska lub '' jeżeli archiwa puste
::  TAG: <PUBLICZNA>
::  OLD: \last/stat_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_result:='';
ST_ARCH.cntx_psh();
ST_ARCH.index('MASK');
{? ST_ARCH.last()
|| _result:=ST_ARCH.MASK
?};
ST_ARCH.cntx_pop();
_result


\left_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Sprawdza ile rekordów zmieści się jeszcze w archiwum (we wszystkich tabelach maskowanych)
::   WE: [_a] - STRING - maska archiwum, jeśli nie podana to ostatnia w archiwum
::   WY: obj_new - tablica nazwana z liczbą rekordów które jeszcze sie zmieszcza w masce każdej tabeli
::  OLD: \left_all/stat_arch.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('')
|| _msk:=_a
|| _msk:=exec('last','st_arch')
?};

_ff:=exec('get_mask_tables','st_arch');
_result:=_ff();
_can_continue:=1;

:: Pobieram parametry [stałe wartości]
_params:=exec('params','st_arch');

exec('cntx_psh','st_arch');
:: Otwieram archiwum
exec('open','st_arch',_msk);

{! _it:=1..obj_len(_params.tables)
|!
:: Pobieram liczbe rekordów
   {? var_pres('_tab')>100
   || obj_del(_tab)
   ?};
   _tab:=_params.tables[_it];
   _tab.clear();
   _size:=_tab.size();

:: Pobieram rozmiar bufora
   _buf_size:=_params.buffers[_it];

:: Obliczam ile rekordów zmiesci sie w maksymalnym rozmiarze pliku mdb
   _max_recs:=floor(_params.FILESIZE/_buf_size);
   _max_recs:=exec('min','#math',_max_recs,_params.REC_MAX);

:: Obliczam ile nowych rekordów można dodać zanim zostanie osiagniety maksymalny rozmiaru pliku
   _left:=_max_recs-_size;
   _left:=exec('max','#math',0,_left);

:: Uwzględniam margines bezpieczeństwa
   _left:=_left-(_max_recs*_params.FREE_PROC/100);
   _left:=floor(_left);
   _left:=exec('max','#math',0,_left);

   _result[_it]:=_left
!};
exec('cntx_pop','st_arch');
_result


\size_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Sprawdza ile jest rekordów wszystkich tabel w podanej masce
::   WE: [_a] - STRING - maska archiwum, jeśli nie podana to ostatnia w archiwum
::   WY: REAL - ilość rekordów
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('')
|| _msk:=_a
|| _msk:=exec('last','st_arch')
?};

_ff:=exec('get_mask_tables','st_arch');
_result:=0;
_can_continue:=1;

:: Pobieram parametry [stałe wartości]
_params:=exec('params','st_arch');

exec('cntx_psh','st_arch');
:: Otwieram archiwum
exec('open','st_arch',_msk);

{! _it:=1..obj_len(_params.tables)
|!
:: Pobieram liczbe rekordów
   {? var_pres('_tab')>100
   || obj_del(_tab)
   ?};
   _tab:=_params.tables[_it];
   _tab.clear();
   _result+=_tab.size()
!};
exec('cntx_pop','st_arch');
_result


\check_arch
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [20.42]
:: OPIS: Sprawdza czy dany plik zmieści się w podanej masce archiwum
::   WE: _a - STRING - maska docelowa
::       _b - INTEGER - ilość wierszy w pliku
::   WY: 0 - nie zmieści sie
::       1 - zmiesci sie
::  OLD: \check_arch/stat_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_msk:=_a;
_filesize:=_b;

_result:=1;
_can_continue:=1;

{? _can_continue>0
||
:: Obliczam ile jest wolnego w danej masce
   _left:=exec('left_all','st_arch',_msk);

:: Sprawdzam czy plik zmieści się w wolnym miejscu
   {! _it:=1..obj_len(_left)
   |? _result>0
   |!
      {? _left[_it]<_filesize
      ||
::       Jeśli w jakiejś tabeli ilość wolnego miejsca w masce mniejsza niż liczba rekordów
::       to zwracam info że nie zmieści się i przerywam dalszą analizę
         _result:=0
      ?}
   !}
?};
_result


\cntx_psh
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Odkłada kontekst w maskowanych tabelach
::   WE: [_a] - czy sprawdzać istnienie obiektu parametrów i go ewentualnie inicjować (domyślnie 1 - tak)
::  OLD: \cntx_psh/stat_arch.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _spr_par:=_a || _spr_par:=1 ?};

_params:={? _spr_par || exec('params','st_arch') || ST_ARCH_PAR ?};
{! _it:=1..obj_len(_params.tables)
|! _params.tables[_it].cntx_psh()
!};
~~


\cntx_pop
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [20.42]
:: OPIS: Przywraca kontekst w maskowanych tabelach
::   WE: _a - czy sprawdzać istnienie obiektu parametrów i go ewentualnie inicjować (domyślnie 1 - tak)
::  OLD: \cntx_pop/stat_arch.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _spr_par:=_a || _spr_par:=1 ?};

_params:={? _spr_par || exec('params','st_arch') || ST_ARCH_PAR ?};
{! _it:=1..obj_len(_params.tables)
|! _params.tables[_it].cntx_pop()
!};
~~


\get_mask
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Zwraca maskę dostępnego archiwum (tworzy nowe maski jeżeli potrzebne)
::   WE: _a - INTEGER - ilość wierszy w pliku
::  OLD: \get_mask/stat_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_lines:=_a;
_result:='';

_last:=exec('last','st_arch');
ST_ARCH.cntx_psh();
ST_ARCH.index('MASK');
ST_ARCH.prefix(_last,);
{? ST_ARCH.first()
||
   {? exec('check_arch','st_arch',ST_ARCH.MASK,_lines)>0
   || _result:=ST_ARCH.MASK
   ?}
?};

{? _result=''
||
:: Nie było maski, albo plik się w niej nie zmieści, więc zakładam nową
   _ref:=exec('new_arch','st_arch');
   {? _ref<>null()
   || ST_ARCH.prefix();
      {? ST_ARCH.seek(_ref)
      || _result:=ST_ARCH.MASK
      ?}
   ?}
?};
ST_ARCH.cntx_pop();
_result


\clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Czyści powiązania do rekordu tabeli ST_ARCH
::   WE: _a - ST_ARCH.ref()
::   WY: >0  -wyczyszczone,
::       <=0 -niewyczyszczone
::  TAG: <PRYWATNA><CLEAN>
::UWAGA: Parametry bez [] są wymagane, formuła może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=0;
_can_continue:=1;

_mydo:=do_state()=0;
{? _mydo || do() ?};
:: --- powiązania do ---

:: --- wszystkie powiazania usuniete? ---

{? _can_continue>0
|| _result:=1
|| undo()
?};

{? _mydo || end() ?};

_result


\delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Kasuje podany rekord tabeli ST_ARCH (wykonywane w transakcji!!!)
::   WE: _a - ST_ARCH.ref()
::   WY: >0 -wyczyszczone,
::       <=0 -niewyczyszczone
::  TAG: <PUBLICZNA><DEL>
::UWAGA: Parametry bez [] są wymagane, formula może nie sprawdzać czy zostały podane i może wystąpić błąd.
::----------------------------------------------------------------------------------------------------------------------
:: jeżeli transakcja została zerwana, to nie ma sensu przetwarzać formuły
{? do_state()=2 || return(-100) ?};

_ref:=_a;

_result:=0;
_can_continue:=1;

:: sprawdzam, czy to w tej formule będę zakładał transakcję, czy już jest założona
_mydo:=do_state()=0;
{? _mydo || do() ?};
ST_ARCH.cntx_psh(); ST_ARCH.clear();
{? ST_ARCH.seek(_ref)
||
   _can_delete:=exec('can_delete','st_arch',_ref);
   {? _can_delete>0
   ||
      {? exec('clean','st_arch',_ref)>0
      || {? ST_ARCH.del(,1)>0
         || _result:=1
         || undo();
            _result:=-3
         ?}
      || _result:=-2
      ?}
   || _result:=-1
   ?}
|| _result:=0
?};

{? _result<0
|| undo()
?};

ST_ARCH.cntx_pop();
{? _mydo || end() ?};
_result


\can_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Sprawdza czy można usunąć archiwum
::   WE: _a - ST_ARCH.ref
::   WY: 0 - nie można
::       1 - można
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=_a;

_result:=1;

ST_ARCH.cntx_psh(); ST_ARCH.prefix();
{? ST_ARCH.seek(_ref)
|| _size:=exec('size_all','st_arch',ST_ARCH.MASK);
   {? _size>0
   || _result:=0
   ?};
   ~~
?};
ST_ARCH.cntx_pop();
_result


\st_arch_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Akcja Dołącz dla ST_ARCH
::----------------------------------------------------------------------------------------------------------------------
ST_ARCH.win_edit('RED');
ST_ARCH.blank();
{? ST_ARCH.edit()
|| ST_ARCH.add()
?};
~~


\st_arch_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Akcja Usuń dla ST_ARCH
::----------------------------------------------------------------------------------------------------------------------

_result:=0;
_can_continue:=1;

{? VAR.GRUPA<>'T'
|| _can_continue:=FUN.ask('Czy usunąć bieżący wiersz?'@)
?};

{? _can_continue>0
|| {? exec('delete','st_arch',ST_ARCH.ref())<=0
   || _msg:='Usunięcie maski: %1 zakończone niepowodzeniem.'@[ST_ARCH.MASK];
      {? VAR.GRUPA='T'
      || KOMM.add(_msg,2,,1)
      || FUN.emsg(_msg)
      ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
_result


\st_arch_del_gr1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Akcja Grupa przed Usuń dla ST_ARCH
::----------------------------------------------------------------------------------------------------------------------
sel_nchk();
{? FUN.ask('Usunąć wszystkie zaznaczone archiwa?'@)
|| VAR.GRUPA:='T';
   KOMM.init(200,,'Usuwanie archiwów'@);
   1
|| 0
?}


\st_arch_del_gr2
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [20.42]
:: OPIS: Akcja Grupa po Usuń dla ST_ARCH
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\st_arch_mod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Akcja Popraw dla ST_ARCH
::----------------------------------------------------------------------------------------------------------------------
ST_ARCH.win_edit('RED');
{? ST_ARCH.edit()
|| ST_ARCH.put()
?};
~~


\st_arch_br
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Akcja Rekord przed dla ST_ARCH
::----------------------------------------------------------------------------------------------------------------------
_result:='';
:: Kolorowanie
{? ST_ARCH.ACTIVE<>'T'
|| _result:=Color.fnd_kol('ST_ARCH#01')
?};
_result


\akt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Akcja Aktywuj w oknie wertowania archiwum statystyk (tabela ST_ARCH)
::----------------------------------------------------------------------------------------------------------------------
{? ST_ARCH.ACTIVE<>'T'
|| {? VAR.GRUPA='T' | FUN.ask('Aktywować wybrane archiwum?'@)
   || ST_ARCH.ACTIVE:='T';
      ST_ARCH.put()
   ?}
|| {? VAR.GRUPA<>'T'
   || FUN.info('Wybrane archiwum jest już aktywne.'@)
   || KOMM.add('Archiwum %1 jest już aktywne.'@[ST_ARCH.MASK])
   ?}
?};
~~

\akt_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Przed akcją Aktywuj dla grupy rekordów
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Aktywować wybrane archiwa?'@)
|| VAR.GRUPA:='T';
   KOMM.init(200,,'Aktywowanie archiwów'@);
   1
|| 0
?}



\akt_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Po akcji Aktywuj dla grupy rekordów
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\dakt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Akcja Dezaktywuj w oknie wertowania archiwum statystyk (tabela ST_ARCH)
::----------------------------------------------------------------------------------------------------------------------
{? ST_ARCH.ACTIVE<>'N'
|| {? VAR.GRUPA='T' | FUN.ask('Dezaktywować wybrane archiwum?'@)
   || ST_ARCH.ACTIVE:='N';
      ST_ARCH.put()
   ?}
|| {? VAR.GRUPA<>'T'
   || FUN.info('Wybrane archiwum jest już nieaktywne.'@)
   || KOMM.add('Archiwum %1 jest już nieaktywne'@[ST_ARCH.MASK])
   ?}
?};
~~


\dakt_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Przed akcją Dezaktywuj dla grupy rekordów
::----------------------------------------------------------------------------------------------------------------------
{? FUN.ask('Dezaktywować wybrane archiwa?'@)
|| VAR.GRUPA:='T';
   KOMM.init(200,,'Dezaktywowanie archiwów'@);
   1
|| 0
?}


\dakt_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Po akcji Dezaktywuj dla grupy rekordów
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select();
~~


\legenda
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.42]
:: OPIS: Akcja Legenda dla ST_ARCH
::----------------------------------------------------------------------------------------------------------------------
exec('legenda','color','ST_ARCH#')


\delete_not_used
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Usuwa wszystkie nieużywane rekordy
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------

_result:=0;
_can_continue:=1;

_mydo:=do_state()=0;
{? _mydo || do() ?};

ST_ARCH.cntx_psh();
ST_ARCH.index('STARTD');
ST_ARCH.prefix();
{? ST_ARCH.first()
|| {!
   |? _next:=0;
      _ref_nxt:=null();
      ST_ARCH.cntx_psh();
      {? ST_ARCH.next()
      || _ref_nxt:=ST_ARCH.ref()
      ?};
      ST_ARCH.cntx_pop();

      {? exec('can_delete','st_arch',ST_ARCH.ref())>0
      || _can_continue:=exec('delete','st_arch',ST_ARCH.ref())
      ?};

      {? _ref_nxt<>null()
      || _next:=ST_ARCH.seek(_ref_nxt)
      ?};
      _next>0 & _can_continue>0
   !}
?};
ST_ARCH.cntx_pop();
{? _can_continue>0
|| _result:=1
|| undo()
?};
{? _mydo || end() ?};
_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:38 1bd5a88517f065ba2f26aed11c0d121154409cbfe7b1eafabfa3bc8df9bde23310fad5ab92bc9974f110bb2f748e4902cbc4dc14ffad9ddac54c8dda8838b3e4abfcbe5de44f46281dd0083eef113cc123ba3178ea01728f04bbe9e6dcd72f891f073d990cf8ec2c4adee6ab582f997b5919a35931134bae672b00ea5a5b129f
