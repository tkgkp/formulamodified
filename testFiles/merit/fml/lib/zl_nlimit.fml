:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: zl_nlimit.fml
:: Utworzony: 11.03.2021
:: Autor: TS
::======================================================================================================================
:: Zawartość: Obsługa zapotrzebowań do zlecenia - dedykowane TYLKO dla surowców nielimitowanych i odpadów
::            Plik biblioteczny - wspólna obsługa dla czynności obszaru roboczego TTE_PZL
::======================================================================================================================


\__NLIM_actions
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Ustala akcje w oknie surowców nielimitowanych
::       Obsługiwane akcje: DPUGZBTF(SAT)OH:DGZ
::----------------------------------------------------------------------------------------------------------------------
_ZLIMp:=params_get().env.env_limit.ZLIMp;
_used:=params_get().env.env_limit.used;

_zl:=_ZLIMp.ZL;
_grop:=_ZLIMp.GROP;

ZL.cntx_psh(); GROP.cntx_psh();
ZL.prefix(); GROP.prefix();

{? _zl<>null() & ZL.seek(_zl)
|| _grayed:=':';

:: używane przez innego operatora albo z góry zdefiniowane, że tylko podgląd
   {? _used
   || _grayed:='DPUGZF(W)'+_grayed+'DGZ'
   ?};

:: zlecenie zamknięte - bez redagowania i analiz
   {? ZL.STAN='Z'
   || _grayed:='DPUGZF(AW)'+_grayed+'DGZ'
:: zlecenia otwarte - bez zakańczania
   |? ZL.STAN='O'
   || _grayed:='Z'+_grayed+'Z'
:: zlecenia w przygotowaniu - bez wydań
   |? ZL.STAN='N'
   || _grayed:='F(W)'+_grayed
   ?};

:: niezatwierdzona technologia zlecenia produkcyjnego - tylko podgląd, bez kończenia
   {? ZL.TYP().TECH='T' & ZL.TYP().WP='P' & ZL.STAT_T='N'
   || _grayed:='DPUGZ'+_grayed+'DGZ'
   ?};

:: warsztatowe - bez generowania
   {? ZL.TYP().WP='W'
   || _grayed:='G'+_grayed+'G'
   ?};

:: W kontekście przewodnika - ustawiona zmienna VAR.A_NRZLP
   {? VAR.A_NRZLP<>null()
   || ZGH.cntx_psh();
      ZGH.prefix();
      {? ZGH.seek(VAR.A_NRZLP)
      ||
::       zakończony przewodnik - bez kończenia
         {? ZGH.STAT_L='T'
         || _grayed:='Z'+_grayed+'Z'
         ?};
::       oddany przewodnik - bez redagowania i korekt
         {? ZGH.STAN='T'
         || _grayed:='DPUOG'+_grayed+'DG'
         ?}
      ?};
      ZGH.cntx_pop()
:: W kontekście przewodnika
   |? _ZLIMp.ZGH<>null()
   || ZGH.cntx_psh();
      ZGH.prefix();
      {? ZGH.seek(_ZLIMp.ZGH)
      ||
::       zakończony przewodnik - bez kończenia
         {? ZGH.STAT_L='T'
         || _grayed:='Z'+_grayed+'Z'
         ?};
::       oddany przewodnik - bez redagowania i korekt
         {? ZGH.STAN='T'
         || _grayed:='PUO'+_grayed+''
         ?}
      ?};
      ZGH.cntx_pop()
:: W kontekście ZLIMa
   ||
::    W kontekście zlecenia prostego - zakończone wszystkie przewodniki
      {? ZL.RODZAJ='P' & exec('stat_l','zl_limit',ZL.ref())='T'
      || _grayed:='Z'+_grayed+'Z'
      ?};
      ZGH.cntx_psh();
      {? ZLIM.ZGP().NRZLP().STAN='T'
      ||
::       oddany przewodnik - bez redagowania i korekt
         _grayed:='PUO'+_grayed+''
      ?};
      ZGH.cntx_pop()
   ?};
   {? ZLIM.AUTO<>'T'
   || _grayed:='OH'+_grayed+''
   || _grayed:='P'+_grayed+''
   ?};
   ZLIM.actions_grayed(cur_win(1,1),_grayed);

:: Akcja domyślna dla niepustej dziedziny: Pobrania, dla pustej dziedziny: Generuj
   _default:='B:G';
   ZLIM.actions(cur_win(1,1),,_default,1)

|? _grop<>null() & GROP.seek(_grop)
|| _grayed:=':';

:: bez generowania, zakańczania, zamienników, rezerwacji
   _grayed:='GZNE'+_grayed+'GZ';

:: używane przez innego operatora albo z góry zdefiniowane, że tylko podgląd
   {? _used
   || _grayed:='DPUGZF(W)'+_grayed+'DGZ'
   ?};

:: grupy zamknięte
   {? GROP.STATUS='Z'
   || _grayed:='F(W)'+_grayed
:: grupy otwarte
   |? GROP.STATUS='O'
   || ~~
:: grupy w przygotowaniu
   |? GROP.STATUS='N'
   || _grayed:='F(W)'+_grayed
   ?};
:: Grupy niezaakceptowane
   {? GROP.AKC<>'T'
   || _grayed:='F(W)'+_grayed
   ?};

   ZLIM.actions_grayed(cur_win(1,1),_grayed);

:: Akcja domyślna dla niepustej dziedziny: Pobrania, dla pustej dziedziny brak
   _default:='B:';
   ZLIM.actions(cur_win(1,1),,_default,1)

?};
ZL.cntx_pop(); GROP.cntx_pop();
~~


\nlim_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Poprawianie surowca nielimitowanego
::  OLD: \nlim_popraw/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLIM.ZGP<>null() & ZLIM.ZGP().NRZLP().STAT_L='T' & exec('FindAndGet','#table',ZL,ZLIM.ZLEC,,"STAN",'N')='N'
|| FUN.emsg('Przewodnik %1 jest zatwierdzony pod względem limitów.'@[ZGH.NRPRZ]);
   return()
?};

:: Zakladam filtr na slownik materialow
{? exec('get','#params',500740,2)='N'
|| exec('filter_clear','material')
|| exec('filter','material','PS')
?};

PFAZ.clear();
PFAZ.f_set('KOD');

ATR.MJS:='ZLIM';
ATR.M_ATR:=ZLIM.KTM().M_ATR;
ATR.UZUP:=exec('wz_uzup','mat_atr',ATR.M_ATR);
ATR.FLAG:=0;
ATR.FLAG_ED:=0;
{? ZLIM.DK_C<>null() & ZLIM.DK_C().M_ATR<>null()
|| {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=($('ZLIM.DK_C().WAR'+form(_i,-2,,'99')))() !}
|| {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !}
?};

{? ZLIM.AUTO='T'
||
:: tylko magazyn
   _red:=ZLIM.mk_edit('|--|'+'Zapotrzebowanie surowca — zmiana magazynu'@,,'magazynnlimitu');
   ZLIM.win_efld(_red,,'MG','SYM','*',,,,'Magazyn'@);
   ZLIM.win_efld(_red,,'MG','NAZ',,,,,' ');
   ZLIM.win_ebtn(_red,'icon='+exec('ok','#icon')+',text='+'OK'@,'key:F2');
   ZLIM.win_ebtn(_red,'icon='+exec('anuluj','#icon')+',text='+'Anuluj'@,'key:Esc');
   ZLIM.win_edit(_red);
   ZLIM.efld_opt(_red,'mark=1',,'MG','SYM');
   _valid:="
      _chk:=__CHK.record(ZLIM,,'MG')
   ";
   {? ZLIM.edit(_valid)
   || ZLIM.put()
   ?};
   MG.f_clear()
||
:: wszystko
   ZLIM.win_edit('RED_NLI');
   exec('efld_opt','zl_limit1');
   {? ZLIM.edit("exec('nlim_valid','zl_nlimit',1)")
   || ZLIM.put()
   ?}
?};

:: Przywracam tytul i akcje w slowniku materialow
exec('filter_clear','material');
~~


\nlim_dod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Dodanie surowca nielimitowanego do listy.
::  OLD: \nlim_dod/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
{? VAR.A_ZLEC<>null() & VAR.A_ZLEC().TYP().WP='W'
|| FUN.emsg('Surowców nielimitowanych nie można dołączać do zlecenia warsztatowego.'@);
   return()
?};

ZLIM.win_edit('RED_NLI');
M_ATR.blank();
ZLIM.blank();
ZLIM.LIMIT:='N';
ZLIM.AUTO:='N';

PFAZ.clear();
PFAZ.f_set('KOD');

_ok:=1;

:: Zlecenie
{? VAR.A_ZLEC<>null()
|| _rodzaj:=VAR.A_ZLEC().RODZAJ;
:: Proste
   {? _rodzaj='P'
   || _zldod:=VAR.A_ZLNAD;
      ZLIM.ZLDOD:=_zldod
:: Złożone
   || ZL.cntx_psh();
      ZL.clear();
      ZL.index('NRNZL');
      ZL.prefix(VAR.A_ZLEC().UNRZL);
      _wer:=ZL.mk_sel('Wybierz zlecenie podrzędne'@,'P',0,'podzlec',,,10,,'U');
      ZL.win_fld(_wer,,'SYM');
      ZL.win_fld(_wer,,'OPIS',,,50,,,'Opis'@);
      ZL.win_fld(_wer,,'STAN',,,,,,'Stan'@);
      ZL.win_act(_wer,,'Formuła','Wybierz'@@,,,,"
         {? ZL.STAN<>'Z'
         || sel_exit()
         || FUN.info('Zlecenie zamknięte.'@)
         ?}
      ",1);
      ZL.win_sel(_wer);
      {? ZL.select()
      ||
         {? exec('stat_l','zl_limit',ZL.ref())='T' & ZL.STAN='N'
         || FUN.emsg(
               'Zlecenie %1 (wszystkie przewodniki) jest zatwierdzone pod względem limitów '
               '— dodanie pozycji nie jest możliwe.'@[ZL.SYM]
            );
            _zlec:=null();
            _ok:=0
         || _zlec:=ZL.ref()
         ?}
      || _zlec:=null();
         _ok:=0
      ?};
      ZL.cntx_pop();
      {? _zlec=null() || return() || ZLIM.ZLEC:=_zlec; ZLIM.ZLDOD:=exec('top_level','zl_link',_zlec) ?}
   ?};

   {? _ok
   ||
      {? VAR.A_NRZLP<>null()
      || _Zgh:=VAR.A_NRZLP
      ||
::    Wybór przewodnika
         ZGH.cntx_psh();
         ZGH.index('ZLNR');
         ZGH.prefix(ZLIM.ZLEC);
         {? ZGH.size()=1
         || ZGH.first();
            {? ZGH.STAN='T'
            || FUN.info('Przewodnik %1 jest oddany.'@[ZGH.NRPRZ]);
               _ok:=0
            |? ZGH.STAT_L='T'
            || {? FUN.ask(
                     'Zakończono rejestrację zapotrzebowań do przewodnika %1.'@[ZGH.NRPRZ]+
                     '\n\n'+'Czy dołączyć nową pozycję?'@
                  )
               || _Zgh:=ZGH.ref()
               || _ok:=0
               ?}
            || _Zgh:=ZGH.ref()
            ?}
         |? ZGH.first()
         || _wer:=ZGH.mk_sel('Wybierz przewodnik'@,'P',0,'naglowkiprzew',,,10,,'U');
            ZGH.win_fld(_wer,,'NRPRZ');
            ZGH.win_fld(_wer,,'STAT_L',,,,,,,,,2,,"'T'","'N'");
            ZGH.win_act(_wer,,'Formuła','Wybierz'@@,,,,"sel_exit()",1);
            ZGH.win_act(_wer,,'Formuła','Legenda'@@,,,,"exec('legenda','color','ZGH#01#')");
            ZGH.win_act(_wer,,'Rekord',,,,"exec('rkprz_zgh','zl_guide')");
            ZGH.win_act(_wer,,'Wyświetl',,,,"exec('zgh_display','zl_guide')");
            ZGH.win_sel(_wer);
            {? ZGH.select()
            || {? ZGH.STAN='T'
               || FUN.info('Przewodnik %1 jest oddany.'@[ZGH.NRPRZ]);
                  _ok:=0
               |? ZGH.STAT_L='T'
               || {? FUN.ask(
                        'Zakończono rejestrację zapotrzebowań do przewodnika %1.'@[ZGH.NRPRZ]+
                        '\n\n'+'Czy dołączyć nową pozycję?'@
                     )
                  || _Zgh:=ZGH.ref()
                  || _ok:=0
                  ?}
               || _Zgh:=ZGH.ref()
               ?}
            || _ok:=0
            ?}
         || FUN.emsg('Zlecenie musi mieć co najmniej jeden przewodnik, aby dołączać limity.'@);
            _ok:=0
         ?};
         ZGH.cntx_pop()
      ?}
   ?};

   {? _ok
   ||
      {? VAR.A_ZGP<>null()
      || ZLIM.ZGP:=VAR.A_ZGP
      ||
::    Wybor pozycji przewodnika
         ZGP.cntx_psh();
         ZGP.index('PNRPP');
         ZGP.prefix(_Zgh,'N');
         {? ZGP.size()=1
         || ZGP.first();
            ZLIM.ZGP:=ZGP.ref()
         |? ZGP.first()
         || _wer:=ZGP.mk_sel('Wybierz pozycję przewodnika'@,'P',0,'pozycjeprzew',,,10,,'U');
            ZGP.win_fld(_wer,,'NRP',,,,,,'Lp'@);
            ZGP.win_fld(_wer,,'OPIS');
            ZGP.win_act(_wer,,'Formuła','Wybierz'@@,,,,"sel_exit()",1);
            ZGP.win_sel(_wer);
            {? ZGP.select()
            || ZLIM.ZGP:=ZGP.ref()
            || _ok:=0
            ?}
         || FUN.emsg('Przewodnik musi mieć co najmniej jedną pozycję, aby dołączać limity.'@);
            _ok:=0
         ?};
         ZGP.cntx_pop()
      ?}
   ?};

   {? _ok
   ||
::    Wymagany termin
      _dt:=exec('datetime','zl_limit',ZLIM.ZGP);
      ZLIM.STARTD:=_dt.DATE;
      ZLIM.STARTT:=_dt.TIME
   ?}

:: Grupa operacji
|? VAR.A_GROP<>null()
||
   ZLIM.GROP:=VAR.A_GROP;
:: Wymagany termin
   _dt:=exec('datetime','zl_limit',null(),ZLIM.GROP);
   ZLIM.STARTD:=_dt.DATE;
   ZLIM.STARTT:=_dt.TIME
?};

:: Zakładam filtr na słownik materiałów
{? exec('get','#params',500740,2)='N'
|| exec('filter_clear','material')
|| exec('filter','material','PS')
?};

VAR.LIL:=0;
ATR.MJS:='ZLIM';
ATR.M_ATR:=ZLIM.KTM().M_ATR;
ATR.UZUP:=exec('wz_uzup','mat_atr',ATR.M_ATR);
ATR.FLAG:=0;
ATR.FLAG_ED:=0;
{? ZLIM.DK_C<>null() & ZLIM.DK_C().M_ATR<>null()
|| {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=($('ZLIM.DK_C().WAR'+form(_i,-2,,'99')))() !}
|| {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !}
?};
exec('efld_opt','zl_limit1');
{? _ok & ZLIM.edit("exec('nlim_valid','zl_nlimit',0)")
|| ZLIM.NR:=exec('ZLIM_NR_blank','zl_limit',ZLIM.ZLEC,ZLIM.LIMIT,ZLIM.GROP);
   {? ZLIM.add()
   || {? ZLIM.f_active()
      || ZLIM.f_add()
      ?}
   ?}
?};
:: Przywracam tytul i akcje w slowniku materialow
exec('filter_clear','material');
~~


\nlim_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.20]
:: OPIS: Walidacja surowca nielimitowanego
::   WE: _a - specyfikacja testu: 1-poprawianie, 0-dołączanie
::  OLD: \nlim_valid/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
_modify:=_a;
_res:='';

{? _modify || _ref:=ZLIM.ref() ?};

{? ZLIM.KTM=null()
|| _res:='KTM'
|? ZLIM.LIL<=0
|| _res:='LIL'
|| ZLIM.cntx_psh();

   {? ZLIM.GROP<>null()
   || ZLIM.index('GROPKM');
      ZLIM.prefix(ZLIM.GROP,'T',0,ZLIM.KTM)
   || ZLIM.index('ZGP_KM');
      ZLIM.prefix(ZLIM.ZGP,'T',0,ZLIM.KTM)
   ?};
   {? ZLIM.first()
   || _res:='KTMX1'
   ?};

   {? ZLIM.GROP<>null()
   || ZLIM.index('GROPKM');
      ZLIM.prefix(ZLIM.GROP,'N',0,ZLIM.KTM)
   || ZLIM.index('ZGP_KM');
      ZLIM.prefix(ZLIM.ZGP,'N',0,ZLIM.KTM)
   ?};
   {? ZLIM.first() & {? _modify || _ref<>ZLIM.ref() || 1 ?}
   || _res:='KTMX2'
   ?};

   ZLIM.cntx_pop()
?};
{? _res='' & _modify & ZLIM.LIL<>exec('FindAndGet','#table',ZLIM,ZLIM.ref(),,"ZLIM.LIL",0)
||
::  Sprawdzam czy sa jakies dokumenty do zlima
   {? ZLIM.IL_RW+ZLIM.IL_ZW>ZLIM.LIL
   || _res:='IL_DOK'
   ?}
?};

{? _res='KTM'
|| FUN.emsg('Należy wypełnić pole Indeks.'@)
|? _res='KTMX1'
|| {? ZLIM.GROP<>null()
   || FUN.emsg(
         'Materiał o indeksie: %1 występuje już na liście limitów dla grupy operacji: %2.'@
         [ZLIM.KTM().KTM,exec('record','#to_string',ZLIM.GROP)]
      )
   || FUN.emsg(
         'Materiał o indeksie: %1 występuje już na liście limitów dla pozycji przewodnika: %2.'@
         [ZLIM.KTM().KTM,exec('record','#to_string',ZLIM.ZGP)]
      )
   ?};
   _res:='KTM'
|? _res='KTMX2'
|| {? ZLIM.GROP<>null()
   || FUN.emsg(
         'Materiał o indeksie: %1 występuje już jako surowiec nielimitowany dla grupy operacji: %2.'@
         [ZLIM.KTM().KTM,exec('record','#to_string',ZLIM.GROP)]
      )
   || FUN.emsg(
         'Materiał o indeksie: %1 występuje już jako surowiec nielimitowany dla pozycji przewodnika: %2.'@
         [ZLIM.KTM().KTM,exec('record','#to_string',ZLIM.ZGP)]
      )
   ?};
   _res:='KTM'
|? _res='IL_DOK'
|| FUN.emsg('Ilość po modyfikacji nie może być mniejsza od ilości rozliczonej na dokumentach\n.'
            'Minimalna ilość: %1'@[$(ZLIM.IL_RW+ZLIM.IL_ZW)]);
   _res:='LIL'
|? _res='LIL'
|| FUN.emsg('Ilość musi być większa od zera.'@)
?};
{? _res='' & ZLIM.ZGP().STARTD=date(0,0,0) & ZLIM.STARTD=date(0,0,0)
|| FUN.info('Proszę podać termin zapotrzebowania.'@);
   _res:='STARTD'
?};
{? _res='' & ((1+ZLIM.MG().TYP)='D' | ZLIM.MG=null()) & ATR.FLAG_ED & ATR.FLAG<>1
|| exec('akcepatr','mat_atr',0,1)
?};

{? _res=''
||
:: Obsługa usług
   _res:=exec('valid_nlim','zl_uslugi')
?};
_res


\nlim_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Usunięcie surowca nielimitowanego z listy.
::  OLD: \nlim_del/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
{? ZLIM.ZGP<>null() & ZLIM.ZGP().NRZLP().STAT_L='T' & exec('FindAndGet','#table',ZL,ZLIM.ZLEC,,"STAN",'N')='N'
|| FUN.emsg('Przewodnik %1 jest zatwierdzony pod względem limitów.'@[ZGH.NRPRZ]);
   return()
?};
_zlim:=$ZLIM.ref();
{? exec('FindAndGet','#table',ZL,#ZLIM.ZLEC,ZL.name(),"STAN",'')='O'
      |
   exec('FindAndGet','#table',ZL,#ZLIM.ZLDOD,ZL.name(),"STAN",'')='O'
|| {? ZLIM.AKC<>'T' & ZLIM.AUTO<>'T'
   || _tmp:=exec('zlim_pob_il','zl_limit',$ZLIM.ref(),,,0);
      {? _tmp.RW+_tmp.ZW>0
      || FUN.emsg('Nie można usunąć pozycji, do której są utworzone dokumenty magazynowe.'@)
      |? FUN.ask('Czy usunąć tę pozycję?'@)
      || {? ZLIM.del(,1)
         || exec('zlim_kor_del','zl_limit',_zlim);
            exec('rej_mat_del','zl_nlimit',_zlim)
         ?}
      ?}
   |? ZLIM.AUTO='T'
   || FUN.info('Pozycja została wygenerowana automatycznie. Nie można usunąć.'@)
   || FUN.emsg('Usuwać można jedynie pozycje niezaakceptowane.'@)
   ?}
|| {? ZLIM.AKC<>'T' & ZLIM.AUTO<>'T'
   || {? FUN.ask('Czy usunąć tę pozycję?'@)
      || {? ZLIM.del(,1)
         || exec('zlim_kor_del','zl_limit',_zlim);
            exec('rej_mat_del','zl_nlimit',_zlim)
         ?}
      ?}
   |? ZLIM.AUTO='T'
   || {? FUN.ask('Pozycja została wygenerowana automatycznie.\nCzy usunąć tę pozycję?'@)
      || {? ZLIM.del(,1)
         || exec('zlim_kor_del','zl_limit',_zlim);
            exec('rej_mat_del','zl_nlimit',_zlim)
         ?}
      ?}
   || FUN.emsg('Usuwać można jedynie pozycje niezaakceptowane.'@)
   ?}
?};
~~


\zgp_nlim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wyświetla surowce nielimitowane do pozycji przewodnika
::   WE: [_a] - ZGP.ref() - gdy brak, to aktualny
::   WY: czy w oknie zakończono rejestrację (1), czy nie (0)
::  OLD: \zgp_nlim/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_zgp:={? _>0 & type_of(_a)=type_of(ZGP.ref()) || _a || ZGP.ref() ?};

_res:=0;

ZGP.cntx_psh();
ZGP.clear();
{? _zgp<>null() & ZGP.seek(_zgp)
||
   VAR.cntx_psh();
   VAR.A_ZLEC:=ZGP.NRZLP().ZLEC;
   _res:=exec('sur_nlim','zl_limit',,VAR.A_ZLEC,ZGP.NRZLP,ZGP.ref());
   VAR.cntx_pop()
?};
ZGP.cntx_pop();
_res


\zgh_nlim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wyświetla surowce nielimitowane do przewodnika
::   WE: [_a] - ZGH.ref() - gdy brak, to aktualny
::   WY: czy w oknie zakończono rejestrację (1), czy nie (0)
::  OLD: \zgh_nlim/zl_guid1.fml
::----------------------------------------------------------------------------------------------------------------------
_zgh:={? _>0 & type_of(_a)=type_of(ZGH.ref()) || _a || ZGH.ref() ?};

_res:=0;

ZGH.cntx_psh();
ZGH.clear();
{? _zgh<>null() & ZGH.seek(_zgh)
||
   VAR.cntx_psh();
   VAR.A_ZLEC:=ZGH.ZLEC;
   _res:=exec('sur_nlim','zl_limit',,VAR.A_ZLEC,ZGH.ref());
   VAR.cntx_pop()
?};
ZGH.cntx_pop();
_res


\nlim_generuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Generowanie surowców nielimitowanych zlecenia
::  OLD: \generuj/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
_ZLIMp:=params_get().env.env_limit.ZLIMp;
_generuj:=0;
ZGH.cntx_psh();
{? ZL.RODZAJ='P'
|| ZGH.index('ZLNR');
   ZGH.prefix(_ZLIMp.ZL)
|| ZGH.index('UID_VIEW');
   ZGH.prefix(exec('FindAndGet','#table',ZL,_ZLIMp.ZL,,"uidref()",''))
?};
{? ZGH.first() || _generuj:=1 ?};
ZGH.cntx_pop();
{? _generuj>0
|| _result:=exec('zlim_gen4__Z','zl_limit','N',_ZLIMp.ZL,_ZLIMp);
:: Dla zleceń otwartych zakończenie czynności zaraz po generowaniu

:: --- zakomentowane z powodu błędu przy podwójnym generowaniu - za drugim razem problem z PARSES
::   {? _result>0 & exec('FindAndGet','#table',ZL,_ZLIMp.ZL,,"STAN='O'",0)
::   || {? _ZLIMp.ZGH=null()
::      || _args:=exec('mp_run_a','#b__box');
::         _args.ACT_UID:='TTE_PZL_DLIM';
::         _args.UIDREF:=exec('FindAndGet','#table',ZL,_ZLIMp.ZL,,"uidref()",'');
::         _args.AKCJA:='ZAKOŃCZ';
::         _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
::         exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',_ZLIMp.ZL);
::         exec('mp_run','#b__box',_args)
::      || _args:=exec('mp_run_a','#b__box');
::         _args.ACT_UID:='TTE_PZL_DLIM';
::         _args.UIDREF:=exec('FindAndGet','#table',ZL,_ZLIMp.ZL,,"uidref()",'');
::         _args.AKCJA:='ZAKOŃCZ_ZGH';
::         _args.CONTEXT:=obj_new('RESULT');
::         _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
::         exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',_ZLIMp.ZL);
::         exec('mp_run','#b__box',_args)
::      ?}
::   ?};
   ~~
|| FUN.info('Zlecenie musi mieć co najmniej jeden przewodnik, aby generować surowce nielimitowane.'@)
?};
~~


\find_nd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Wyszukuje dokumenty raportujące, które nie są powiązane z dokumentami rozchodu surowców nielimitowanych
::       albo przychodu odpadów.
::       Kontekst wywołania - rekord tabeli ZL
::  OLD: \find_nd/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
_env_gen:=__ENV_GEN;
params_set('env_gen',_env_gen);
_gen:=_env_gen.GEN;

{? _gen='NLI'
|| {? ~exec('czy_sa_nielimity','zl_nlimit',ZL.ref(),1)
   || KOMM.add('Zlecenie %1 nie ma zdefiniowanych surowców nielimitowanych.'@[ZL.SYM]);
      return()
   ?}
|? _gen='ODP'
|| {? ~exec('czy_sa_odpady','zl_nlimit',ZL.ref())
   || KOMM.add('Zlecenie %1 nie ma zdefiniowanych odpadów/koproduktów.'@[ZL.SYM]);
      return()
   ?}
?};

_ok:=1;

_dk:=_env_gen.DK.TAB;
_dk_ndxsym:=_env_gen.DK.NDXSYM;
_dk_ndxzl:=_env_gen.DK.NDXZL;
_sur:=_env_gen.SUR.TAB;
{? exec('top_rodzaj','zl_link',ZL.ref())='N'
|| _top:=ZL.ref();
   _top_sym:=ZL.SYM
|| {? ZL.RP='T' & ZL.TREE_TYP='F'
   || _top:=ZL.ref();
      _top_sym:=ZL.SYM
   || _top:=exec('top_level','zl_link',ZL.ref());
      _top_sym:=exec('FindAndGet','#table',ZL,_top,,"SYM",'')
   ?}
?};

:: ZASILENIE
ND.cntx_psh();
DK.cntx_psh();
DK.index('GENZL');

:: Dokumenty raportujące
_typydok:=exec('typydok_rap','zl_common',ZL.ref());

TYPYDOK.cntx_psh();
TYPYDOK.clear();
_dk.index(_dk_ndxsym);
{? _typydok.first()
|| {!
   |? {? TYPYDOK.seek(_typydok.REF,)
      || DK.prefix(ZL.ref(),_typydok.REF);
         {? DK.first()
         || {!
            |? {? DK.N().STAT_REJ='T' & ND.AM=ST.AM & ~exec('rozliczone','zl_limit',DK.N,{? _gen='NLI' || 'N' || 'T' ?})
               || {? ~exec('find_p_dk','zl_limit',$DK.N,_top,_gen)
                  || _dk.prefix(ND.SYM,$ND.ref(),$DK.M,_top_sym);
                     {? _dk.first()
                     || _dk.IL+=DK.IL;
                        _dk.POZ+=', '+form(DK.P);
                        _dk.put()
                     || _dk.blank();
                        _dk.SYMBOL:=ND.SYM;
                        _dk.REF:=$ND.ref();
                        _dk.MREF:=$DK.M;
                        _dk.POZ:=form(DK.P);
                        _dk.M:=DK.M().KTM;
                        _dk.JM:=DK.M().J().KOD;
                        _dk.REFDK:=$DK.ref();
                        _dk.ZLEC:=ZL.SYM;
::                        _top_sym;
                        _dk.IL:=DK.IL;
                        _dk.NDNAME:=ND.name();
                        _dk.O:=ND.O;
                        _dk.DT:=ND.D;
                        _dk.AKC:='N';
                        _dk.WYD:=DK.WYD().KOD;
                        _dk.WYDZ:=#DK.WYD;
                        _dk.ZL_REF:=$ZL.ref();
::                        $_top;
                        _dk.ZGH_REF:=$DK.ZGH;
                        _dk.ZPARN:=$DK.PARTIA;
                        _dk.add()
                     ?};
                     _ok:=exec('sur_ra','zl_nlimit',_top,DK.WYD,DK.IL,DK.ZGH);
                     {? _ok<=0
                     || _dk.del()
                     ?}
                  ?}
               ?};
               DK.next() & _ok<>-1
            !}
         ?}
      ?};
      _typydok.next()
   !}
?};
_dk.index(_dk_ndxzl);
_dk.prefix($ZL.ref());
{? _dk.first()
|| {? ~exec('zl_lock','zl_common',#ZL.ref(),'L',1)
   || KOMM.add('Zapotrzebowania do zlecenia %1 obsługuje inny użytkownik.'@[ZL.SYM]);
      {!
      |? _dk.del()
      !}
   || {!
      |? {? ~ND.r_lock(1,1,1,ref_num(_dk.REF),ref_name(_dk.REF))
         || KOMM.add('Dokument %1 do zlecenia %2 obsługuje inny użytkownik.'@[_dk.SYMBOL,ZL.SYM]);
            _dk.del()
         || _dk.next()
         ?}
      !}
   ?}
?};
TYPYDOK.cntx_pop();
DK.cntx_pop();
ND.cntx_pop();
~~


\gen_ra
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: generowanie dokumentów rozliczających
::       - element formuły głównej czynności: TTE_WYK_DGRW, TTE_WYK_DGRO, TTE_WYK_DGZW
::   WE: _a - TYPYDOK.ref() / null()
::   WY: STRING[15] - tm_stamp którym zostały ostemplowane utworzone dokumenty rozliczające
::  OLD: \gen_ra/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env_gen:=params_get().env_gen;
_dk:=_env_gen.DK.TAB;
_sur:=_env_gen.SUR.TAB;
_pob:=_env_gen.POB.TAB;

_typdok:=_a;
:: Sprawdzenie, czy przekazano typ dokumentu
{? _typdok=null()
|| _formnr:=
      {? _env_gen.GEN*'NLI'>0
      || 500708
      |? _env_gen.GEN*'ODP'>0
      || 500706
      |? _env_gen.GEN*'ZWR'>0
      || 500710
      || FUN.wdrerror('Błędny parametr wywołania formuły \\gen_ra/zl_limit.');
         return()
      ?};
   _typdok:=~~;
   _typydok:=exec('GetTabFromList','#table','TYPYDOK','T',exec('get','#params',_formnr,2,null()));
   {? _typydok.first()
   || TYPYDOK.cntx_psh();
      TYPYDOK.clear();
      {? TYPYDOK.seek(_typydok.REF,) || _typdok:=TYPYDOK.ref() ?};
      TYPYDOK.cntx_pop()
   ?};
   {? type_of(_typdok)=type_of(~~)
   ||
::    Dla akcji grupowej musi być ustawiony typ domyślny
      {? VAR.GRUPA='T'
      || FUN.emsg('Nie ustawiono parametru %1.\nNależy uzupełnić konfigurację systemu.'@[$_formnr]);
         return(~~)
      || _formnr:=
         {? _env_gen.GEN*'NLI'>0
         || 500707
         |? _env_gen.GEN*'ODP'>0
         || 500705
         |? _env_gen.GEN*'ZWR'>0
         || 500709
         || FUN.wdrerror('Błędny parametr wywołania formuły \gen_ra/zl_limit.');
            return()
         ?};
         _TypDok:=exec('get','#params',_formnr,2);
         {? _TypDok<>''
         || _Typdok:=gsub(form(_TypDok),' ','\',\'');
            _TypDok:='\''+_Typdok+'\'';
            _warunek:='"TYPYDOK".T in ('+_TypDok+') '
         || _warunek:='0=1'
         ?};
         _typdok:=exec('typ_dok','lmg',_warunek,,,0,0,
            'Nie ustawiono parametru %1.\nNależy uzupełnić konfigurację systemu.'@[$_formnr],,,,0
         )
      ?}
   ?}
?};
_typsym:='';
{? type_of(_typdok)=type_of(null())
|| _typsym:=exec('FindAndGet','#table',TYPYDOK,_typdok,,"TYPYDOK.T",'')
?};
_dalej:=1;
{? VAR.GRUPA<>'T'
|| KOMM.init(150,,'Generowanie dokumentów'@,'')
?};

{? _env_gen.GEN='ODP' | _env_gen.GEN='ODP_ZL'
||
:: Sprawdzenie czy odpady są partiowane i czy zlecenie ma partie
:: jeżeli odpad musi mieć partię, a zlecenie nie ma to nie tworzymy dokumentów
:: bo nie będą mogły mieć cechy z partią
   ZL.cntx_psh();
   ZL.prefix();
   {? ZL.seek(_dk.ZL_REF)
   ||
      {? exec('zlec_party','zl_common',ZL.ref())=0
      ||
         _sur.cntx_psh();
         _sur.index(_env_gen.SUR.NDXMAG);
         _sur.prefix(#_dk.ref());
         {? _sur.first()
         || {!
            |? _ktm:=exec('FindAndGet','#table',M,_sur.MAT,M.name(),,null());
               {? exec('material_party','material',_ktm)>0
               || _msg:='Odpad/koprodukt: %1 jest partiowany ale powstał na zleceniu bez partii. '
                        'Generacja dokumentu niemożliwa.'@[_sur.KTM];
                  KOMM.add(_msg,2);
                  _dalej:=0
               ?};
               _sur.next() & _dalej
            !}
         ?};
         _sur.cntx_pop()
      ?}
   ?};
   ZL.cntx_pop()
|? _env_gen.GEN='ODP_GROP' | _env_gen.GEN='ODP_ZGROP'
||
:: Sprawdzenie czy odpady są partiowane, jeżeli są to nie tworzymy dokumentów
:: bo nie będą mogły mieć cechy z partią
   GROP.cntx_psh();
   GROP.prefix();
   {? GROP.seek(_dk.GROP_REF)
   || _sur.cntx_psh();
      _sur.index(_env_gen.SUR.NDXMAG);
      _sur.prefix(#_dk.ref());
      {? _sur.first()
      || {!
         |? _ktm:=exec('FindAndGet','#table',M,_sur.MAT,M.name(),,null());
            {? exec('material_party','material',_ktm)>0
            || _msg:='Odpad/koprodukt: %1 jest partiowany. Generacja dokumentu niemożliwa.'@[_sur.KTM];
               KOMM.add(_msg,2);
               _dalej:=0
            ?};
            _sur.next() & _dalej
         !}
      ?};
      _sur.cntx_pop()
   ?};
   GROP.cntx_pop()
|? _env_gen.GEN*'ZWR'>0
||
:: Sprawdzenie czy uzupełniono ilość na przynajmniej jednym surowcu
   _sur.cntx_psh();
   _sur.index(_env_gen.SUR.NDXMAG);
   _sur.prefix(#_dk.ref());
   _jest:=0;
   {? _sur.first()
   || {!
      |?
         {? _sur.ILOSC>0
         || _jest:=1
         ?};
         _sur.next() & _jest=0
      !}
   ?};
   _sur.cntx_pop();
   {? _jest=0
   || FUN.info('Ilość zwracana musi być określona na przynajmniej jednym surowcu.'@);
      _dalej:=0
   ?}
?};

{? _dalej>0 & (_env_gen.GEN='NLI_ZL' | _env_gen.GEN='ODP_ZL' | _env_gen.GEN='NLI_ZGROP' | _env_gen.GEN='ODP_ZGROP')
||
:: Sprawdzenie, czy są surowce z nierozpisaną ilością
   _all_set:=1;
   _sur.cntx_psh();
   _sur.index(_env_gen.SUR.NDXLIM);
   _sur.prefix(#_dk.ref());
   {? _sur.first()
   || {!
      |?
         {? _sur.ILOSC<=0
         || _all_set:=0
         ?};
         _all_set>0 & _sur.next()
      !};
      {? _all_set=0
      || _msg:='Ilość na wszystkich surowcach musi być określona.'@;
         FUN.emsg(_msg);
         _dalej:=0
      ?}
   ?};
   _sur.cntx_pop()
?};
{? _dalej>0 & VAR.GRUPA<>'T'
|| {? _env_gen.GEN*'NLI'>0
   || _dalej:=FUN.ask('Czy generować dokumenty rozchodu surowców?'@)
   |? _env_gen.GEN*'ODP'>0
   ||
::    Sprawdzenie, czy są surowce z nierozpisaną cechą dostawy
      _all_set:=1;
      _sur.cntx_psh();
      _sur.index(_env_gen.SUR.NDXSET);
      _sur.prefix(0,#_dk.ref());
      {? _sur.size()>0
      || _all_set:=0
      ?};
      _sur.cntx_pop();
      {? _env_gen.GEN*'GROP'>0 & _all_set=0
      || _msg:='Atrybuty cechy dostawy nie zostały rozpisane dla wszystkich odpadów/koproduktów.\n'
               'Należy uzupełnić brakujące dane.'@;
         FUN.emsg(_msg);
         _dalej:=0
      || _msg:={? _all_set>0
               || 'Czy generować dokumenty przyjęcia odpadów/koproduktów?'@
               || 'Atrybuty cechy dostawy nie zostały rozpisane dla wszystkich odpadów/koproduktów.\n'
                  'Wymagane będzie ich późniejsze uzupełnienie na dokumencie magazynowym.\n\n'
                  'Czy mimo to generować dokumenty przyjęcia odpadów/koproduktów?'@
               ?};
         _dalej:=FUN.ask(_msg)
      ?}
   || _dalej:=FUN.ask('Czy generować dokumenty zwrotu surowców?'@)
   ?}
?};

_tm_stamp:='';
{? _dalej=1
||
::   do();
   DK.cntx_psh(); DK.prefix();
   ND.cntx_psh(); ND.prefix();
   ZL.cntx_psh(); ZL.prefix();
   GROP.cntx_psh(); GROP.prefix();

   {? _env_gen.GEN='ZWR'
   || {? ZL.seek(_dk.ZL_REF)
      || {? exec('zl_lock','zl_common',,,1)
         || _tm_stamp:=exec('gen_dok','zl_nlimit',_typdok)
         || KOMM.sect_beg('Generowanie dokumentu %1 do zlecenia %2'@[_typsym,ZL.SYM]);
            KOMM.error('Zlecenie %1 jest redagowane przez innego użytkownika, '
                       'wygenerowanie dokumentu %2 nie było możliwe.'@
                       [ZL.SYM,_typsym],0,1);
            KOMM.sect_end()
         ?}
      ?}
   |? _env_gen.GEN='ZWR_GROP'
   || {? GROP.seek(_dk.GROP_REF)
      || {? exec('blk_lock','#table','GROP',GROP.ref(),,,'Grupa operacji %1 jest blokowana'@[GROP.KOD])
         || _tm_stamp:=exec('gen_dok','zl_nlimit',_typdok)
         || KOMM.sect_beg('Generowanie dokumentu %1 do grupy operacji %2'@[_typsym,GROP.KOD]);
            KOMM.error('Grupa operacji %1 jest redagowane przez innego użytkownika, '
                       'wygenerowanie dokumentu %2 nie było możliwe.'@
                       [GROP.KOD,_typsym],0,1);
            KOMM.sect_end()
         ?};
         exec('blk_unlock','#table','GROP',GROP.ref())
      ?}
   |? _env_gen.GEN='NLI' | _env_gen.GEN='ODP'
   || {? ND.seek(_dk.REF) & DK.seek(_dk.REFDK)
      ||
         {? exec('rozliczone','zl_limit',ND.ref(),{? _env_gen.GEN='NLI' || 'N' || 'T' ?})
         || KOMM.sect_beg('Generowanie dokumentu %1 do: %2 poz. %3 (%4) %5'@
                             [_typsym,ND.SYM,form(DK.P),DK.M().KTM,DK.M().N],,,1);
            KOMM.error('Do dokumentu raportującego %1 zostały już wystawione dokumenty rozliczające.'@[ND.SYM]);
            KOMM.sect_end()
         |? DK.r_lock(1,1,1)
         || {? ~exec('find_p_dk','zl_limit',$ND.ref(),DK.ZL,_env_gen.GEN)
            || _tm_stamp:=exec('gen_dok','zl_nlimit',_typdok)
            || _tm_stamp:='x';
               KOMM.sect_beg('Generowanie dokumentu %1 do: %2 poz. %3 (%4) %5'@
                             [_typsym,ND.SYM,form(DK.P),DK.M().KTM,DK.M().N],,,1);
               KOMM.info('Do pozycji utworzono w międzyczasie dokument %1.'@[_typsym],0,1);
               KOMM.sect_end()
            ?};
            DK.r_unlock()
         || KOMM.sect_beg('Generowanie dokumentu %1 do: %2 poz. %3 (%4) %5'@
                          [_typsym,ND.SYM,form(DK.P),DK.M().KTM,DK.M().N],,,1);
            KOMM.error('Pozycja dokumentu %1 jest redagowana przez innego użytkownika, '
                       'wygenerowanie dokumentu %2, nie było możliwe.'@
                       [ND.SYM,_typsym],0,1);
            KOMM.sect_end()
         ?}
      ?}
   || _tm_stamp:=exec('gen_dok','zl_nlimit',_typdok)
   ?};

   {?
::      end()
      _tm_stamp<>''
   || exec('zl_unlock','zl_common',BIT.sqlint(_dk.ZL_REF));
      _dk.del()
   ?};

   DK.cntx_pop();
   ND.cntx_pop();
   ZL.cntx_pop();
   GROP.cntx_pop()
?};
{? VAR.GRUPA<>'T'
|| KOMM.select()
?};
_tm_stamp


\sur_ra
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Surowce do generowania
::   WE: _a - ZL.ref() (DK.ZL)
::       _b - SLO.ref() (DK.WYD) - niewykorzystywany
::       _c - DK.IL
::       [_d] - ZGH.ref() (DK.ZGH)
::  OLD: \sur_ra/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
_env_gen:=params_get().env_gen;
_dk:=_env_gen.DK.TAB;
_sur:=_env_gen.SUR.TAB;
_gen:=_env_gen.GEN;
_zlim_tab:=_env_gen.ZLIM;
_chk_zlim:={? var_pres('_zlim_tab')>100 & _zlim_tab.size()>0 || 1 || 0 ?};
_zl:=_a;
::_wyd:=_b;
_ilosc:=_c;
_zgh:={? var_pres('_d')=type_of(null) || _d || null() ?};
_result:=0;

_typdokt:='';

_mode_nlim:=(_gen*'NLI');
_mode_odp:=(_gen*'ODP');

_buf_matr:=~~;
_zparn:=null();
{? _mode_odp>0
|| _buf_matr:=exec('buffer','mat_atr');
   _zparn:=exec('FindAndGet','#table',ZPARN,_dk.ZPARN,,,null())
?};

ZL.cntx_psh(); ZL.clear();

{? _zl<>null() & ZL.seek(_zl)
||
   _nadzl_il:=ZL.IL;

   ZLIM.cntx_psh();
   VAR.cntx_psh();
   VAR.A_ZLEC:=_zl;
   exec('openmask','zl_common',_zl);
   exec('s_nlim','zl_common');
   {? ZL.RODZAJ='P'
   || ZL.index('UNRZL');
      ZL.prefix(ZL.UNRZL)
   || ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL)
   ?};
   {? ZL.first()
   || {!
      |? _zl_il:=ZL.IL;
         ZLIM.index('ZNR');
         {? _mode_nlim>0
         || {? _gen='NLI_ZL'
            || ZLIM.prefix(ZL.ref(),'N')
            || ZLIM.prefix(ZL.ref(),'N','N')
            ?}
         |? _mode_odp>0
         || ZLIM.prefix(ZL.ref(),'T')
         ?};
         {? ZLIM.first()
         || {!
            |?
               _zgh_il:=ZLIM.ZGP().NRZLP().ILNPRZ;
               _mag:=ZLIM.MG;
               ZLIM.MG();
               _magsym:=MG.SYM;
               _magname:=MG.NAZ;
               {? (ZLIM.SO='S' & _mode_nlim | ZLIM.SO='O' & _mode_odp)
                  & ZLIM.KOR=0
::                  & ZLIM.ZGP().NRZLP().UID_VIEW=exec('FindAndGet','#table',ZGH,_zgh,,"UID_VIEW",'')
                  & (_zgh=null() | ZLIM.ZGP().NRZLP=_zgh
                     | ZLIM.ZGP().NRZLP().UID_SRC=exec('FindAndGet','#table',ZGH,_zgh,,"UID",''))
                  & (ZLIM.PODZL='' | (ZLIM.PODZL='T' & ZL.ref()=_zl) | (ZLIM.PODZL='N' & ZL.ref()<>_zl))
                  & (_chk_zlim=0 | _zlim_tab.find_tab(,'REF',,'=',$ZLIM.ref()))
               || _result:=1;

                  _dokl:=exec('jaka_dok_m','jm',ZLIM.KTM);
                  _lil:=exec('sum_il','zl_limit',ZLIM.ref());
                  _il:={? _dokl>0
                       || ((_lil*_ilosc)/_zgh_il*_zl_il/_nadzl_il)$ _dokl
                       || ceil(((_lil*_ilosc)/_zgh_il*_zl_il/_nadzl_il))
                       ?};
                  _lim:=1;
                  _dalej:=0;
                  _ok:={? (ZLIM.SO='O' & ZLIM.LIL=0) | _gen='NLI_ZL' | _gen='ODP_ZL' || 1 || _il>0 ?};
                  {? _ok>0
                  || _sur.index(_env_gen.SUR.NDXLIM);
                     _sur.prefix(#_dk.ref(),$ZLIM.ref());
                     {? _sur.first()
                     || _sur.ILOSC+=_il;
                        _sur.RAP_IL+=_ilosc;
                        _sur.put()
                     || _sur.blank();
                        _sur.REFDK:=#_dk.ref();
                        _sur.MAT:=#ZLIM.KTM;
                        _sur.ZLIM:=$ZLIM.ref();
                        _sur.KTM:=ZLIM.KTM().KTM;
                        _sur.NAZ:=ZLIM.KTM().N;
                        _sur.JM:=ZLIM.KTM().J().KOD;
                        _sur.ILOSC:=_il;
                        _sur.ILL:=ZLIM.LIL;
                        _sur.ILP:=ZLIM.IL_RW-ZLIM.IL_ZW;
                        _sur.ILZ:=ZLIM.IL_ZW;
                        _sur.ILR:=_sur.ILL-_sur.ILP;
                        {? _sur.ILR<0 || _sur.ILR:=0 ?};
                        _sur.ZL:=#ZLIM.ZLEC;
                        _sur.ZL_SYM:=ZLIM.ZLEC().SYM;
                        _sur.ZL_REF:=$ZLIM.ZLEC;
                        _sur.WYD:=#ZLIM.WYD;
                        _sur.MAG:=#_mag;
                        _sur.MAGNAME:=_magname;
                        _sur.MAGSYM:=_magsym;
                        _sur.AUTO:='T';
                        _sur.M_ATR:={? _mode_odp>0 || $ZLIM.KTM().M_ATR || '' ?};
                        _sur.DK_C:=$ZLIM.DK_C;
                        _sur.ZLEC:=#ZLIM.ZLEC;
                        _sur.ZLDOD:=#ZLIM.ZLDOD;
                        _sur.ZGH_REF:=$ZLIM.ZGP().NRZLP;
                        _sur.ZGP:=#ZLIM.ZGP;
                        _sur.ZGP_NAME:=ZLIM.ZGP().NRZLP().NRPRZ+' '+exec('separator','zl_limit')+' '+$ZGP.NRP;
                        _sur.ZGP_OPIS:=ZLIM.ZGP().OPIS;
                        _sur.ZGH_IL:=ZGH.ILNPRZ;
                        _sur.RAP_IL:=_ilosc;
                        _sur.ZPARN:=_dk.ZPARN;
                        _sur.PARSYM:=exec('FindAndGet','#table',ZPARN,_sur.ZPARN,,"ZPARN.SYM",'');
::                      Sprawdzenie, czy do surowca istnieją rezerwacje dedykowana do nielimitów
                        {? ZLIM.LIMIT='N' & exec('zlim_il_rez','zl_nlimit',$ZLIM.ref())
                        || _sur.CZY_REZ:=1
                        ?};
                        _sur.ALL_SET:=1;
::                      Obsługa cech dostaw dla odpadów
                        {? _mode_odp>0
                        || _buf_matr.blank();
                           {? _sur.M_ATR<>''
                           || M_ATR.cntx_psh();
                              M_ATR.clear();
                              ZLIM.KTM().M_ATR();
                              _buf_matr.get_matr();
                              M_ATR.cntx_pop();

                              {? ZLIM.DK_C<>null()
                              || DK_C.cntx_psh();
                                 DK_C.use(ref_name(ZLIM.DK_C));
                                 ZLIM.DK_C();
                                 _buf_matr.get_dkc();
                                 DK_C.cntx_pop()
                              ?};
                              {? _zparn<>null()
                              || _buf_matr.set_part(_zparn)
                              ?};
                              _buf_matr.set_tab(_sur);
                              _sur.ALL_SET:=_buf_matr.all_set()
                           || _buf_matr.set_tab(_sur)
                           ?}
                        ?};
                        _sur.add()
                     ?}
                  ?}
               ?};
               ZLIM.next()
            !}
         ?};
         ZL.next()
      !}
   ?};
   VAR.cntx_pop();
   ZLIM.cntx_pop()
?};
ZL.cntx_pop();
_result


\sur_edit
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Dodanie/poprawienie surowca do dokumentu rozliczającego
::   WE: _a - TYPYDOK.ref() (NIEUŻYWANY)
::       _b - 0 - poprawianie
::            1 - dołączanie
::  OLD: \sur_edit/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env_gen:=params_get().env_gen;
_dk:=_env_gen.DK.TAB;
_sur:=_env_gen.SUR.TAB;
_pob:=_env_gen.POB.TAB;
_gen:=_env_gen.GEN;

_dolacz:=_b;

M.index('RODZ');
M.prefix();
M.f_clear();
MG.cntx_psh(); MG.clear(); MG.f_clear();
M_ATR.cntx_psh(); M_ATR.clear();
ZLIM.cntx_psh(); ZLIM.clear();

_wmag:=HELP.WMAG;
HELP.WMAG:=3;

:: Ustawienie okien dla M
exec('slo_m_ok','material','T',0,,'W');

:: Filtrowanie kartoteki M
exec('filter','material','PS');

:: Header w oknie wertowania M
exec('wpm_opis','material','PS',' — '+exec('zakr_naz','material',ZAKR.MATU));

{? _dolacz
|| {? _gen*'NLI'>0
   || VAR.A_MAG:=exec('FindAndGet','#table',MG,_sur.MAG,MG.name(),,null())
   || VAR.A_MAG:=INFO.MGO
   ?}
|| VAR.A_MAG:=exec('FindAndGet','#table',MG,_sur.MAG,MG.name(),,null())
?};

_sur.win_edit(_env_gen.SUR.RED);
{? _dolacz
|| _sur.last();
   _sur.ILOSC:=0;
   {? _gen*'GROP'>0
   || _sur.GROP:=#exec('FindAndGet','#table',GROP,_dk.GROP_REF);
      _sur.GROP_REF:=_dk.GROP_REF;
      _sur.GROP_KOD:=exec('FindAndGet','#table',GROP,_dk.GROP_REF,,"KOD",'');
      _sur.GROP_OP:=exec('FindAndGet','#table',GROP,_dk.GROP_REF,,"OPIS",'')
   || _sur.ZL_SYM:=_dk.ZLEC;
      {? _gen='NLI_ZL' | _gen='ODP_ZL'
      || _sur.ZGH_REF:='';
         _sur.ZGP:=0;
         _sur.ZGP_NAME:='';
         _sur.ZGP_OPIS:=''
      ?}
   ?};
   VAR.A_T:=null()
|| VAR.A_T:=exec('FindAndGet','#table',M,_sur.MAT,M.name(),,null())
?};

:: Blokada zmiany magazynu jak przypisana dostawa
{? _gen='NLI_ZLGD' & (_sur.SCEAN<>'' | _sur.KODPAL<>'') & ~_dolacz
|| _sur.efld_opt(_env_gen.SUR.RED,'editable=0,mark=0',@.VAR,'A_T','KTM');
   _sur.efld_opt(_env_gen.SUR.RED,'editable=0,mark=0',@.VAR,'A_MAG','SYM')
|| _sur.efld_opt(_env_gen.SUR.RED,'editable=1,mark=1',@.VAR,'A_T','KTM');
   _sur.efld_opt(_env_gen.SUR.RED,'editable=1,mark=1',@.VAR,'A_MAG','SYM')
?};

_valid:="
   _env_gen:=params_get().env_gen;
   _gen:=_env_gen.GEN;
   _sur:=cur_tab(1,1);
   _wyn:='';
   {? _gen*'ZWR'=0
   || _wyn:=__CHK.record3(VAR,'A_T','Indeks'@,VAR,'A_MAG','Magazyn'@);
      {? _wyn=''
      || {? VAR.A_MAG().KOOP='T'
         || FUN.info('Należy wybrać magazyn nie służący do rejestracji kooperacji.'@);
            _wyn:='A_MAG'
         ?}
      ?}
   ?};
   _dokl:=exec('jaka_dok_m','jm',VAR.A_T);
   {? _wyn=''
   || {? exec('itsPositive','#field',{? _gen*'ZWR'=0 || 1 || 0 ?},'T',_sur.ILOSC)
      || {? _dokl>0
         || _sur.ILOSC:=_sur.ILOSC $ _dokl
         || _sur.ILOSC:=ceil(_sur.ILOSC)
         ?}
      || _wyn:='ILOSC'
      ?}
   ?};
   {? _wyn='' & (_gen*'ZWR'>0)
   || {? _sur.ILOSC>_sur.ILR
      || FUN.info('Maksymalna ilość surowca jaką można zwrócić to: %1 %2.'@[form(_sur.ILR,,_dokl),_sur.JM]);
         _wyn:='ILOSC'
      ?}
   ?};
:: Walidacja cech atrybutów dostawy (wymagane wypełnienie wszystkich cech jak ręczna modyfikacja)
   {? _wyn='' & _sur.M_ATR<>''
   || _diff:=0;
      _buff1:=exec('buffer','mat_atr');
      _buff2:=exec('buffer','mat_atr');
      M_ATR.cntx_psh();
      M_ATR.clear();
      {? M_ATR.seek(_sur.M_ATR)
      || _buff1.get_matr()
      ?};
      M_ATR.cntx_pop();
      _buff1.get_atr();
      _buff1.clear_part();
      {? _sur.DK_C<>''
      || DK_C.cntx_psh();
         DK_C.use(ref_name(_sur.DK_C));
         DK_C.clear();
         {? DK_C.seek(_sur.DK_C)
         || _buff2.get_dkc()
         ?};
         DK_C.cntx_pop();
         _buff2.clear_part();
         _diff:=_buff1.compare(_buff2)<=0
      || _diff:=1
      ?};
::    Sprawdzenie, czy nie zmienił się indeks materiałwowy
      {? _diff=0
      || _diff:=_sur.MAT<>#VAR.A_T
      ?};
::    Jeżeli zmieniono cechy (lub indeks materiałowy) to wszystko musi być uzupełnione
      {? _diff>0
      || {? _buff1.is_empty()=0
         || {? _sur.ZPARN<>'' & _buff1.can_part()
            || _zparn:=exec('FindAndGet','#table',ZPARN,_sur.ZPARN,,,null());
               _buff1.set_part(_zparn)
            ?};
            {? _buff1.all_set()=0
            || FUN.info('Należy rozpisać wszystkie atrybuty cechy dostawy.'@);
               _wyn:=0
            ?}
         ?}
      ?}
   ?};
   _wyn
";

_tit:=
   {? _dolacz & _gen*'NLI'>0 || 'Dołączanie surowca'@
   |? _dolacz & _gen*'ODP'>0 || 'Dołączanie odpadu/koproduktu'@
   |? ~_dolacz & _gen*'NLI'>0 || 'Poprawianie surowca'@
   |? ~_dolacz & _gen*'ODP'>0 || 'Poprawianie odpadu/koproduktu'@
   || ''
   ?};

:: Obsługa atrybutów dla opadów
{? _gen*'ODP'>0
|| ATR.M_ATR:=null();
   _flag_ed:=ATR.FLAG_ED;
   _flag:=ATR.FLAG;
::   ATR.FLAG_ED:=0;
::   ATR.FLAG:=1;
::   ATR.FLAG_PAR:=0;
   ATR.FLAG_PAR:=1;
   _m_atr:={? _dolacz || null() || exec('FindAndGet','#table',M_ATR,_sur.M_ATR,,,null()) ?};
   ATR.ZPARN_DK:=exec('FindAndGet','#table',ZPARN,_dk.ZPARN,,,null());
   {? M_ATR.seek(_m_atr,,,1)
   || ATR.M_ATR:=M_ATR.ref();
      ATR.FLAG_ED:=(exec('FindAndGet','#table',MG,_sur.MAG,,"1+TYP",'')='D' | _sur.MAG=0) & ATR.M_ATR().EDIT;
      ATR.FLAG:={? ATR.FLAG_ED || 2 || 0 ?};
      {? ATR.FLAG_ED || ATR.FLAG_ED:=2 ?};
      ATR.SUR_DKC:=_dk_c:=exec('FindAndGet','#table',DK_C,_sur.DK_C,,,null());
      {? ZLIM.seek(_sur.ZLIM,8+_sur.ZLIM,1)
      || ATR.MJS:='ZLIM';
::       podczytanie/czyszczenie wartosci atrybutow
         {? _dk_c<>null()
         || exec('ustawatr','mat_atr',,_dk_c)
         || {! _i:=1.. exec('il_atr','mat_atr') |! ($('ATR.WAR'+form(_i,-2,0,'99')))():='' !}
         ?};
::       Partie na zleceniu
         {? _gen='ODP' & exec('partia_num_matr','mat_atr',ATR.M_ATR)>0 & exec('zlec_party','zl_common',ZLIM.ZLEC)>0
         ||
::          Ustawiam wartosc zmiennej ATR na symbol wybranej partii
            _sym_part:=exec('dkc_partia_sym','zl_partie',_dk_c);
            {? _sym_part<>''
            || exec('atr_set_partia','mat_atr',_m_atr,_sym_part)
            || exec('atr_set_partia','mat_atr',_m_atr,ATR.ZPARN_DK().SYM)
            ?};
            ATR.SUR_DKC:=ZLIM.DK_C:=null()
         ?};
         exec('set_efld_opt','mat_atr',ATR.MJS,DK_C,'RED_ATRC')
      ?}
   || ATR.MJS:='M_ATR';
::    czyszczenie wartosci atrybutow
      {! _i:=1.. exec('il_atr','mat_atr') |! ($('ATR.WAR'+form(_i,-2,0,'99')))():='' !}
   ?}
?};

KOMM.init(150,,_tit);
_il_before:=_sur.ILOSC;
_mag_before:=_sur.MAG;
{? _sur.edit(_valid,,{? _dolacz || '' || 'ILOSC' ?})
|| {? _gen*'NLI'>0
   || exec('spr_no_lim','zl_nlimit','S',_dolacz)
   |? _gen*'ODP'>0
   || exec('spr_no_lim','zl_nlimit','O',_dolacz)
   |? _gen*'ZWR'>0
   || {? exec('spr_no_lim','zl_nlimit','S',_dolacz)
      || _change_il:=_il_before<>_sur.ILOSC;
         _change_mag:=_mag_before<>_sur.MAG;
         {? _change_il>0 | _change_mag>0
         ||
::          Rozpisanie nowej ilości/magazynu na pozycjach
            _pob.cntx_psh();
            _p500713:=exec('get','#params',500713,type_of(''));
            {? _p500713='M'
            || _pob.index(_env_gen.POB.NDXDOSTM)
            || _pob.index(_env_gen.POB.NDXDOSTR)
            ?};
            _pob.prefix(#_sur.ref());
            {? _pob.first()
            || _dorozp:=_sur.ILOSC;
               {!
               |?
                  {? _change_il>0
                  || _ilosc:=exec('min','#math',_pob.ILP,_dorozp,exec('pob_il_valid','zl_nlimit',0,0));
                     _pob.ILOSC:=_ilosc
                  ?};
                  {? _change_mag>0
                  || _pob.MAG:=_sur.MAG;
                     _pob.MAGSYM:=_sur.MAGSYM;
                     _pob.MAGNAME:=_sur.MAGNAME
                  ?};
                  {? _pob.put()
                  || {? _change_il>0
                     || _dorozp-=_ilosc
                     ?}
                  ?};
                  _pob.next()
               !};
               {? _change_il>0 & _dorozp>0
               || _sur.ILOSC-=_dorozp;
                  {? _sur.ILOSC<0 || _sur.ILOSC:=0 ?};
                  _dokl:=exec('jaka_dok_m','jm',VAR.A_T);
                  FUN.info('Maksymalna ilość surowca jaką można zwrócić to: %1 %2. Ilość została skorygowana.'@
                     [form(_sur.ILOSC,,_dokl),_sur.JM]);
                  _sur.put()
               ?}
            ?};
            _pob.cntx_pop()
         ?}
      ?}
   ?}
?};
KOMM.select();

HELP.WMAG:=_wmag;
{? _gen*'ODP'>0
|| ATR.FLAG_PAR:=0;
   ATR.FLAG_ED:=_flag_ed;
   ATR.FLAG:=_flag
?};

M.f_clear();
MG.cntx_pop();
M_ATR.cntx_pop();
ZLIM.cntx_pop();
_sur.win_edit();
~~


\action_ra_generate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Generowanie dokumentu rozliczającego - akcja 'utwórz dokumenty' w panelu rozliczania
::----------------------------------------------------------------------------------------------------------------------
_env_gen:=params_get().env_gen;
_dk:=_env_gen.DK.TAB;
_gen:=_env_gen.GEN;

_nd:=exec('FindAndGet','#table',ND,_dk.REF,,,null());

{? (_gen='NLI' | _gen='ODP') & exec('rozliczone','zl_limit',_nd,{? _gen='NLI' || 'N' || 'T' ?})
|| FUN.info('Dokument %1 został już rozliczony.'@[_dk.SYMBOL]);
   exec('zl_unlock','zl_common',BIT.sqlint(_dk.ZL_REF));
   _dk.del()

|| _args:=exec('mp_run_a','#b__box');
   _args.ACT_UID:={? _gen*'NLI'>0 || 'TTE_WYK_DGRW'
                  |? _gen*'ZWR'>0 || 'TTE_WYK_DGZW' || 'TTE_WYK_DGRO' ?};
   _args.AKCJA:='GENERUJ';
   _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
   _args.PROC_START:='T';
   _args.CONTEXT:=obj_new('ENV_GEN','ND');
      _args.CONTEXT.ENV_GEN:=_env_gen;
      _args.CONTEXT.ND:=_nd;
   _args.GRUPA:=VAR.GRUPA;
   _args.B_PREL:=_env_gen.B_PREL;

   {? _gen='NLI_ZLGD'
   || exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',exec('FindAndGet','#table',ZL,_dk.ZL_REF));
      _zgp:=exec('FindAndGet','#table',ZLGD,_dk.REF,,"ZLGD.ZGP",null());
      _zl:=exec('FindAndGet','#table',ZLGD,_dk.REF,,"ZLGD.ZL",null());
      exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZGP',_zgp);
::    Sprawdzenie czy przetwarzany ZLGD jest ostatnim zapisem robocizny przewodnika, który posiada rozpiskę rozliczeń
      _zlgd:=exec('FindAndGet','#table',ZLGD,_dk.REF,,"ZLGD.ref()",null());
      REZ.cntx_psh();
      _rez_mask:=(REZ.name()-2)+'__';
      {? REZ.name()<>_rez_mask || REZ.use(_rez_mask) ?};
      REZ.index('ZLREZP2');
      REZ.prefix(_zl,'S','R','T',$_zgp,);
      _zgp_size:=REZ.size();
      REZ.index('ZLREZR');
      REZ.prefix(_zl,'S','R',$_zlgd,);
      _zlgd_size:=REZ.size();
      {? _zgp_size=_zlgd_size
      ||
::       Przetwarzany ZLGD jest ostatnim z zapisaną rozpiską rozliczeń surowców,
::       jeżeli jest czynność na ToDo to uruchamiam ją
         _args.UIDREF:=exec('FindAndGet','#table',ZGP,_zgp,,"uidref()",'')
      ?};
      REZ.cntx_pop()

   |? _gen*'GROP'
   || _grop:=exec('FindAndGet','#table',GROP,_dk.GROP_REF);
      exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'GROP',_grop);
      _args.UIDREF:=exec('FindAndGet','#table',GROP,_grop,,"uidref()",'')
   |? _gen='NLI' | _gen='ODP'
   || exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',exec('FindAndGet','#table',ZL,_dk.ZL_REF));
      _args.UIDREF:=exec('FindAndGet','#table',ND,_nd,,"uidref()",'')
::      exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ND',_nd)

   || _zl:=exec('FindAndGet','#table',ZL,_dk.ZL_REF);
      exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',_zl);
      _args.UIDREF:=exec('FindAndGet','#table',ZL,_zl,,"uidref()",'')
   ?};
   exec('mp_run','#b__box',_args);

   _env_gen.B_PREL:=_args.B_PREL
?};
~~


\action_ra_generate_group_after
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Po grupowym generowanie dokumentu rozliczającego
::  OLD: \af_ra/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='N';
KOMM.select()


\action_ra_generate_group_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Przed grupowym utworzeniem dokumentu rozliczającego
::  OLD: \bf_ra/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
_gen:=params_get().env_gen.GEN;
_ok:=1;
{? _gen*'NLI'>0
|| _txt:='Czy generować dokumenty rozchodu surowców?'@
|? _gen*'ZWR'>0
|| _txt:='Czy generować dokumenty zwrotu surowców?'@
||
:: Odpady
:: Sprawdzenie, czy są surowce z nierozpisaną cechą dostawy
   _env_gen:=params_get().env_gen;
   _dk:=_env_gen.DK.TAB;
   _sur:=_env_gen.SUR.TAB;
   _all_set:=1;
   _tab:=_dk.sel_aget();
   {? _tab.first()
   ||
      _sur.cntx_psh();
      _sur.index(_env_gen.SUR.NDXSET);
      {!
      |?
         _sur.prefix(0,_tab.REF);
         {? _sur.size()>0
         || _all_set:=0
         ?};
         _tab.next() & _all_set>0
      !};
      _sur.cntx_pop()
   ?};
   {? _gen*'GROP'>0 & _all_set=0
   || _ok:=0;
      _txt:='Atrybuty cechy dostawy nie zostały rozpisane dla wszystkich odpadów/koproduktów.\n'
            'Należy uzupełnić brakujące dane.'@;
      FUN.emsg(_txt)
   || _txt:={? _all_set>0
            || 'Czy generować raporty odpadów/koproduktów?'@
            || 'Atrybuty cechy dostawy nie zostały rozpisane dla wszystkich odpadów/koproduktów.\n'
               'Wymagane będzie ich późniejsze uzupełnienie na dokumencie magazynowym.\n\n'
               'Czy mimo to generować raporty odpadów/koproduktów?'@
            ?}
   ?}
?};
{? _ok>0 & FUN.ask(_txt)
|| VAR.GRUPA:='T';
   KOMM.init(150,,'Generowanie dokumentów.'@,'')
?}


\spr_no_lim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Sprawdzenie czy dodawany surowiec znajduje się na liście nielimitów zlecenia/ odpad - (nie)limitów zlecenia.
::       Kontrolowane jest przypisanie do konkretnej pozycji przewodnika zlecenia albo grupy operacji.
::   WE: _a: 'S','O'
::       _b: 0 - poprawianie, 1 - dołączanie
::       Kontekst wywołania: ustawiony bufor tabeli _sur (__ENV_GEN.SUR.TAB)
::   WY: 0 / 1
::  OLD: \spr_lim/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
_env_gen:=params_get().env_gen;
_dk:=_env_gen.DK.TAB;
_sur:=_env_gen.SUR.TAB;
_gen:=_env_gen.GEN;

_so:=_a;
_dolacz:=_b;
_limit:={? _so='S' || 'N' || 'T' ?};
_res:=0;

ZL.cntx_psh();
ZLIM.cntx_psh();
GROP.cntx_psh();
ZL.clear();

:: Wyszukuje zlecenie, grupę do którego rozliczany jest dokument/robocizna
{? _gen*'GROP'>0
|| VAR.A_GROP:=exec('FindAndGet','#table',GROP,_dk.GROP_REF,GROP.name(),,null());
   exec('openmask','zl_common',,VAR.A_GROP)
|| VAR.A_ZLEC:=exec('FindAndGet','#table',ZL,_dk.ZL_REF,ZL.name(),,null());
   exec('openmask','zl_common',VAR.A_ZLEC)
?};

_can_continue:=1;

:: Wstępna walidacja
{? _gen*'ZWR'=0
|| {? _sur.GROP<>0
   || ZLIM.index('GROPKM');
      {? ZLIM.prefix(_sur.GROP,'N',0,VAR.A_T);
         _so='O' & ZLIM.first()
      || FUN.info(
            'Wskazany materiał (%1) jest surowcem nielimitowanym i nie można go przypisać'
            ' jako odpadu/koproduktu do grupy operacji.'@[VAR.A_T().KTM]
         );
         _can_continue:=0
      |? ZLIM.prefix(_sur.GROP,'T',0,VAR.A_T);
         _so='S' & ZLIM.first()
      || FUN.info(
            'Wskazany materiał (%1) jest surowcem limitowanym i nie można go przypisać'
            ' jako nielimitu do grupy operacji.'@[VAR.A_T().KTM]
         );
         _can_continue:=0
      ?}
   |? _sur.ZGP<>0
   || ZLIM.index('ZGP_KM');
      {? ZLIM.prefix(_sur.ZGP,'N',0,VAR.A_T);
         _so='O' & ZLIM.first()
      || FUN.info(
            'Wskazany materiał (%1) jest surowcem nielimitowanym i nie można go przypisać'
            ' jako odpadu/koproduktu do pozycji przewodnika zlecenia.'@[VAR.A_T().KTM]
         );
         _can_continue:=0
      |? ZLIM.index('ZGP_KM');
         ZLIM.prefix(_sur.ZGP,'T',0,VAR.A_T);
         _so='S' & ZLIM.first()
      || FUN.info(
            'Wskazany materiał (%1) jest surowcem limitowanym i nie można go przypisać'
            ' jako nielimitu do pozycji przewodnika zlecenia.'@[VAR.A_T().KTM]
         );
         _can_continue:=0
      ?}
   ?}
?};

{? _can_continue>0
||
   {? {? _gen*'ZWR'=0
      || {? _sur.GROP<>0
         || ZLIM.index('GROPKM');
            ZLIM.prefix(_sur.GROP,_limit,0,VAR.A_T)
         || ZLIM.index('ZGP_KM');
            ZLIM.prefix(_sur.ZGP,_limit,0,VAR.A_T)
         ?};
         ZLIM.first()
      || 1
      ?}
   || {? _so='O' & ZLIM.SO<>'O'
      || FUN.info(
            'Wskazany materiał (%1) jest surowcem limitowanym i nie można go przypisać'
            ' jako odpadu/koproduktu do pozycji przewodnika zlecenia.'@[VAR.A_T().KTM]
         )

      || _sur.REFDK:=#_dk.ref();
         _sur.KTM:=VAR.A_T().KTM;
         _sur.NAZ:=VAR.A_T().N;
         _sur.MAT:=#VAR.A_T;
         _sur.MAG:=#VAR.A_MAG;
         _sur.MAGSYM:=VAR.A_MAG().SYM;
         _sur.MAGNAME:=VAR.A_MAG().NAZ;
         {? _gen*'ZWR'=0
         || _sur.ZLIM:=$ZLIM.ref();
            _sur.M_ATR:={? _so='O' || $ZLIM.KTM().M_ATR || '' ?};
            {? _dolacz
            || _sur.DK_C:=$ZLIM.DK_C
            ?}
         ?};
         _changed:=0;
::       Obsługa cech dla odpadów
         {? _so='O'
         || _buf_matr:=exec('buffer','mat_atr');
            {? _sur.M_ATR<>''
            || _buf_matr.get_matr();
               _buf_matr.get_atr();
               _buf_matr.set_tab(_sur);
::            Czyszczę atrybuty z partią, w tym etapie tworzone są cechy z wyłączeniem atrybutów typu partia
::            Partia na cesze przypisywana na etapie tworzenia pozycji dokumentów magazynowych
               _buf_matr.clear_part();
               _all_set:=_sur.ALL_SET;
               _zparn:=exec('FindAndGet','#table',ZPARN,_sur.ZPARN,,,null());
               {? _buf_matr.is_empty()=0
               ||
::               Zakładam ceche, lub zwracam istniejącą
                  _dk_c:=exec('m_atr_sprdod','mat_atr',_buf_matr.WAR01
                                                      ,_buf_matr.WAR02
                                                      ,_buf_matr.WAR03
                                                      ,_buf_matr.WAR04
                                                      ,_buf_matr.WAR05
                                                      ,_buf_matr.WAR06
                                                      ,_buf_matr.WAR07
                                                      ,_buf_matr.WAR08
                                                      ,_buf_matr.WAR09
                                                      ,_buf_matr.WAR10
                                                      ,_buf_matr.M_ATR
                                                      );
                  _sur.DK_C:=$_dk_c;
                  _buf_matr.set_part(_zparn);
                  _sur.ALL_SET:=_buf_matr.all_set()
               ||
::               Cecha z niewypełnionymi wartościami, jeżeli cecha posiada wyłącznie atrybut z partią,
::                to zostanie oznaczana jako rozpisana
                  _sur.DK_C:='';
                  _buf_matr.set_part(_zparn);
                  _sur.ALL_SET:=_buf_matr.all_set()
               ?};
               _changed:=(_dolacz>0 & _sur.ALL_SET=0) | _all_set<>_sur.ALL_SET
            ||
::            Surowiec bez wzorca atrybutów dostaw, przypisywane puste wartości
               _buf_matr.blank();
               _buf_matr.set_tab(_sur);
               _all_set:=_sur.ALL_SET;
               _sur.ALL_SET:=1;
               _changed:=_all_set<>_sur.ALL_SET
            ?}
         ?};
         {? _dolacz
         || _sur.AUTO:='N';
            _sur.ZGH_IL:=ZLIM.ZGP().NRZLP().ILNPRZ;
            _sur.RSC:='';
            _sur.SCEAN:='';
            _sur.KODPAL:='';
            _sur.EANL:='';
            _sur.REJ_MAT:='N';
            _sur.GROP_IL:=ZLIM.GROP().IL;
            _res:=_sur.add()
         || _res:=_sur.put()
         ?};
         {? _so='O' & _changed>0
         ||
::          Odświeżenie okna z dokumentami (mógł się zmienić znacznik uzupełnienia cech)
            params_set(params_get());
            grp_disp(_dk,_env_gen.DK.WER,0)
         ?}
      ?}
   || {? _sur.GROP<>0
      || _sur.GROP_IL:=exec('FindAndGet','#table',GROP,_sur.GROP,,"IL",0);
         _sur.RAP_IL:=_dk.IL;
         _dokl:=VAR.A_T().DOKL;
         _lil:=_sur.ILOSC*_sur.GROP_IL/_sur.RAP_IL;
         {? _dokl=0 || _lil:=ceil(_lil) || _lil:=_lil$_dokl ?};
         _can_continue:=FUN.ask(
            'Wskazanego surowca (%1) nie ma na zapotrzebowaniu do grupy operacji.'@[VAR.A_T().KTM]+
            '\n\n'+
            'Ilość wpisana w odniesieniu do zarejestrowanej ilości uruchomień [%1]: %2 %3'@
            [form(_sur.RAP_IL),form(_sur.ILOSC,,_dokl,'.,'),VAR.A_T().J().KOD]+
            '\n'+
            'Ilość wyskalowana do ilości uruchomień grupy operacji [%1]: %2 %3.'@
            [form(_sur.GROP_IL),form(_lil,,_dokl,'.,'),VAR.A_T().J().KOD]+
            '\n\n'+
            'Czy dodać do listy %1 %2 (do zapotrzebowania zostanie dodane %3 %4)?'@
            [form(_sur.ILOSC,,_dokl,'.,'),VAR.A_T().J().KOD,form(_lil,,_dokl,'.,'),VAR.A_T().J().KOD]
         )
      || _sur.ZGH_IL:=exec('FindAndGet','#table',ZGP,_sur.ZGP,,"NRZLP().ILNPRZ",0);
         _sur.RAP_IL:=_dk.IL;
         _dokl:=VAR.A_T().DOKL;
         _lil:=_sur.ILOSC*_sur.ZGH_IL/_sur.RAP_IL;
         {? _dokl=0 || _lil:=ceil(_lil) || _lil:=_lil$_dokl ?};
         _can_continue:=FUN.ask(
            {? _so='S'
            || 'Wskazanego surowca (%1) nie ma na zapotrzebowaniu do pozycji przewodnika zlecenia.'@[VAR.A_T().KTM]
            || 'Wskazanego odpadu/koproduktu (%1) nie ma na zapotrzebowaniu do pozycji przewodnika zlecenia.'@
               [VAR.A_T().KTM]
            ?}+
            '\n\n'+
            'Ilość wpisana w odniesieniu do dokumentu [%1]: %2 %3.'@
            [form(_sur.RAP_IL),form(_sur.ILOSC,,_dokl,'.,'),VAR.A_T().J().KOD]+
            '\n'+
            'Ilość wyskalowana do ilości produktu na przewodniku [%1]: %2 %3.'@
            [form(_sur.ZGH_IL),form(_lil,,_dokl,'.,'),VAR.A_T().J().KOD]+
            '\n\n'+
            'Czy dodać do listy %1 %2 (do zapotrzebowania zostanie dodane %3 %4)?'@
            [form(_sur.ILOSC,,_dokl,'.,'),VAR.A_T().J().KOD,form(_lil,,_dokl,'.,'),VAR.A_T().J().KOD]
         )
      ?};
      {? _can_continue>0
      || ZLIM.blank();
         ZLIM.LIMIT:=_limit;
         ZLIM.AUTO:='N';
::       Dodaje zapotrzebowania do zlecenia, dla którego rozliczam dokument lub robociznę
         ZLIM.ZLEC:=exec('FindAndGet','#table',ZL,_dk.ZL_REF,ZL.name(),,null());
         ZLIM.ZLDOD:=exec('FindAndGet','#table',ZL,_sur.ZLDOD,ZL.name(),,null());
         ZLIM.TMAT:=null();
         ZLIM.KTM:=VAR.A_T;
         ZLIM.PFAZ:=null();
         ZLIM.WYD:={? _sur.GROP<>0 || exec('GetZLIM_WYD','zl_limit') || VAR.A_ZLEC().JORG ?};
         ZLIM.MG:=VAR.A_MAG;
         ZLIM.LIL:=_lil;
         ZLIM.SO:=_so;
         {? _limit='N'
         || ZLIM.NR:=exec('bl_nlrlim','zl_limit')
         || ZLIM.NR:=exec('bl_nrlim','zl_limit')
         ?};
         ZLIM.PARTIA:='N';
         ZLIM.ZGP:=exec('FindAndGet','#table',ZGP,_sur.ZGP,ZGP.name(),,null());
         ZLIM.GROP:=exec('FindAndGet','#table',GROP,_sur.GROP,GROP.name(),,null());
         _dt:=exec('datetime','zl_limit',ZLIM.ZGP,ZLIM.GROP);
         ZLIM.STARTD:=_dt.DATE;
         ZLIM.STARTT:=_dt.TIME;
         obj_del(_dt);

         _dodane:=0;

::       Dla odpadów z wzorcem atrybutów dostaw utworzenie i przypisanie cechy do ZLIM
         {? _so='O'
         || _buf_matr:=exec('buffer','mat_atr');
            {? VAR.A_T().M_ATR<>null()
            || _buf_matr.get_matr();
               _buf_matr.get_atr();
::             Czyszczę atrybuty z partią, w tym etapie tworzone są cechy z wyłączeniem atrybutów typu partia
::             Partia na cesze przypisywana na etapie tworzenia pozycji dokumentów magazynowych
               _buf_matr.clear_part();
               {? _buf_matr.is_empty()=0
               ||
::                Zakładam ceche, lub zwracam istniejącą
                  _dk_c:=exec('m_atr_sprdod','mat_atr',_buf_matr.WAR01
                                                      ,_buf_matr.WAR02
                                                      ,_buf_matr.WAR03
                                                      ,_buf_matr.WAR04
                                                      ,_buf_matr.WAR05
                                                      ,_buf_matr.WAR06
                                                      ,_buf_matr.WAR07
                                                      ,_buf_matr.WAR08
                                                      ,_buf_matr.WAR09
                                                      ,_buf_matr.WAR10
                                                      ,_buf_matr.M_ATR
                                                      );
                  ZLIM.DK_C:=_dk_c
               ?}
            ?}
         ?};

::       Dla odpadów ze standardową redakcją musi być zapis zerowy + korekta
         {? _limit='T' & exec('get','#params',500660,2)='N'
         || _lil:=ZLIM.LIL; ZLIM.LIL:=0;
            ZLIM.AKC:='T';
            {? ZLIM.add()
            || _nr:=ZLIM.NR;
               ZLIM.KOR:=_nr;
               {? _limit='N'
               || ZLIM.NR:=exec('bl_nlrlim','zl_limit')
               || ZLIM.NR:=exec('bl_nrlim','zl_limit')
               ?};
               ZLIM.LIL:=_lil;
               ZLSTW.prefix('~KOR_ROZLO');
               {? ZLSTW.first()
               || _why:=ZLSTW.ref()
               || ZLSTW.KOD:='~KOR_ROZLO';
                  ZLSTW.NAZ:='Korekta podczas rozliczania odpadów/koproduktów';
                  {? ZLSTW.add() || _why:=ZLSTW.ref() || _why:=null() ?}
               ?};
               ZLIM.WHY:=_why;
               ZLIM.AKC:='N';
               ZLIM.prefix();
               {? ZLIM.add()
               || _dodane:=1
               ?}
            ?}
         || {? ZLIM.add()
            || _dodane:=1
            ?}
         ?};

         {? _dodane
         || {? _limit='T'
            || exec('ZLIM_akc','zl_limit',2)
            ?};
            _sur.REFDK:=#_dk.ref();
            _sur.KTM:=VAR.A_T().KTM;
            _sur.NAZ:=VAR.A_T().N;
            _sur.MAT:=#VAR.A_T;
            _sur.MAG:=#ZLIM.MG;
            _sur.MAGSYM:=ZLIM.MG().SYM;
            _sur.MAGNAME:=ZLIM.MG().NAZ;
            _sur.DK_C:=$ZLIM.DK_C;
            _sur.ZLIM:=$ZLIM.ref();
            _sur.ZGH_IL:=ZLIM.ZGP().NRZLP().ILNPRZ;
            _sur.RAP_IL:=_dk.IL;
            _sur.M_ATR:={? _so='O' || $ZLIM.KTM().M_ATR || '' ?};
            _changed:=0;
::          Obsługa cech dla odpadów
            {? _so='O'
            || {? _sur.M_ATR<>''
               || _all_set:=_sur.ALL_SET;
                  _zparn:=exec('FindAndGet','#table',ZPARN,_sur.ZPARN,,,null());
                  {? _buf_matr.is_empty()=0
                  || _buf_matr.set_part(_zparn);
                     _buf_matr.set_tab(_sur);
                     _sur.ALL_SET:=_buf_matr.all_set()
                  ||
::                   Cecha z niewypełnionymi wartościami, jeżeli cecha posiada wyłącznie atrybut z partią,
::                   to zostanie oznaczana jako rozpisana
                     _sur.DK_C:='';
                     _buf_matr.set_part(_zparn);
                     _buf_matr.set_tab(_sur);
                     _sur.ALL_SET:=_buf_matr.all_set()
                  ?};
                  _changed:=(_dolacz>0 & _sur.ALL_SET=0) | _all_set<>_sur.ALL_SET
               ||
::                Surowiec bez wzorca atrybutów dostaw, przypisywane puste wartości
                  _buf_matr.blank();
                  _buf_matr.set_tab(_sur);
                  _all_set:=_sur.ALL_SET;
                  _sur.ALL_SET:=1;
                  _changed:=_all_set<>_sur.ALL_SET
               ?}
            ?};

            {? _dolacz=1
            || _sur.AUTO:='N';
               _sur.RSC:='';
               _sur.SCEAN:='';
               _sur.KODPAL:='';
               _sur.EANL:='';
               _sur.REJ_MAT:='N';
               _res:=_sur.add()
            || _res:=_sur.put()
            ?};
            {? _so='O' & _changed>0
            ||
::             Odświeżenie okna z dokumentami (mógł się zmienić znacznik uzupełnienia cech)
               params_set(params_get());
               grp_disp(_dk,_env_gen.DK.WER,0)
            ?}
         || FUN.emsg('Nie udało się dodać.'@)
         ?}
      ?}
   ?}
?};
GROP.cntx_pop();
ZLIM.cntx_pop();
ZL.cntx_pop();
_res


\gen_dok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: MLAK [2011]
:: OPIS: Tworzy właściwe dokumenty rozchodu surowców nielimitowanych.
::       Powstaje tyle dokumentów, ile różnych magazynów zdefiniowanych na pozycjach __ENV_GEN.SUR.TAB (_sur)
::       Kontekst wywołania - rekord __ENV_GEN.DK.TAB (_dk)
::   WE: _a - Typ dokumentu rozliczającego
::   WY: STRING[15] - tm_stamp którym zostały ostemplowane utworzone dokumenty rozliczające
::                    '' - dokument nie powstał
::  OLD: \gen_dok/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
_env_gen:=params_get().env_gen;
_dk:=_env_gen.DK.TAB;
_sur:=_env_gen.SUR.TAB;
_pob:=_env_gen.POB.TAB;
_gen:=_env_gen.GEN;

_ref:=null();
_typdok:=_a;
_niel:=exec('FindAndGet','#table',TYPYDOK,_typdok,,"P",'')='N';
_buf_matr:={? _gen*'ODP'>0 || exec('buffer','mat_atr') || ~~ ?};

{? _dk.GROP_REF<>''
|| KOMM.sect_beg('Grupa operacji: %1'@[_dk.ZLEC],,,1)
|| KOMM.sect_beg('Dokument: %1 poz. %2, zlecenie: %3 (%4)'@[_dk.SYMBOL,_dk.POZ,_dk.ZLEC,_dk.M],,,1)
?};

_sur.cntx_psh();
_dk.cntx_psh();
_pob.cntx_psh();

Cntx.psh(ND,DK,M,SLO,ZKTL,ZL,MG,REZ);
_rez_mask:=(REZ.name()-2)+'__';
{? REZ.name()<>_rez_mask || REZ.use(_rez_mask) ?};
Cntx.clr(ND,DK,M,SLO,ZKTL,ZL,MG,REZ);

_tm_stamp:=tm_stamp();

_data:={? date()>date(ST.AR,ST.AM,0)
       || date(ST.AR,ST.AM,0)
       |? date()<date(ST.AR,ST.AM,1)
       || _dk.DT
       || date()
       ?};
_zlgd:={? _dk.REF*'zlgd'>0 || exec('FindAndGet','#table','ZLGD',_dk.REF,,,null()) || null() ?};
:: Tabele przechowująca ilość zarazerwowaną dla konkretnych dostaw
:: Wykorzystywna w przypadku rozliczania nielimitów z przypisaną dostawą
{? var_pres('_tab_rez')>100 || obj_del(_tab_rez) ?};
_tab_rez:=exec('tab_rez_create','zl_nlimit');
_ndx1:=_tab_rez.index('?');
_ndx2:=_tab_rez.ndx_tmp(,,'TYP',,,'ZLREF',,,'MREF',,,'ZLIM',,,'REF',,);
_ndx3:=_tab_rez.ndx_tmp(,,'SCEAN',,,'TYP',,1);
_ndx4:=_tab_rez.ndx_tmp(,,'SRDK',,,'TYP',,1);

:: Tabela przechowująca refy pozycji dokumentów utworzonych na podstawie dedykowanych rezerwacji do nielimitów
{? var_pres('_dk_rez')>100 || obj_del(_dk_rez) ?};
_dk_rez:=tab_tmp(1,
   'REF','STRING[16]','Ref pozycji $DK.ref()'
);
_kodmsk:='';

_can_continue:=1;

{? _gen*'ZWR'>0
|| _pob.index(_env_gen.POB.NDXREFDK)
?};
_tab:={? _gen*'ZWR'=0 || _sur || _pob ?};

:: 1. Pętla po surowcach - weryfikacja magazynów
_tab.prefix(_dk.ref());
{? _tab.first()
|| {!
   |? {? _tab.MAG=0
      || {? _tab=_sur
         || _msg:='Nie przypisano magazynu do surowca: %1.'@[_sur.KTM]
         || _msg:='Nie przypisano magazynu do przynajmniej jednej z pozycji surowca: %1.'@
            [exec('FindAndGet','#table',_sur,_pob.REFSUR,,"KTM",'')]
         ?};
         KOMM.add(_msg,4,,1);
         _can_continue:=0
      ?};
      _tab.next()
   !}
?};

:: 2. Zbieranie listy magazynów
_mag:=sql('select distinct SUR.MAG as REF from prefixed_table(:_a) as SUR where SUR.ILOSC>0',_tab);

:: 3. Pętla po magazynach - sprawdzenie dostępności typów dokumentów
MG.clear();
{? _mag.first()
|| {!
   |? {? MG.seek(_mag.REF,)
      || _magtab:=obj_new(1); _magtab[1]:=MG.ref();
         _typdok_sym:=exec('FindAndGet','#table',TYPYDOK,_typdok,,"T",'');
         _typy_ok:=exec('typ_dok','lmg','"TYPYDOK".T=\''+_typdok_sym+'\'',,,1,_magtab,,,0);
         {? _typy_ok=''
         || _msg:='Brak dostępu do dokumentu: %1 na magazynie: %2.'@[_typdok_sym,MG.SYM];
            KOMM.add(_msg,4,,1);
            _can_continue:=0
         ?};
         obj_del(_magtab)
      ?};
      _mag.next()
   !}
?};


:: 4. Pętla po magazynach - weryfikacja dostępności surowców (tylko dla rozchodów, rozliczenie surowców nielimitowanych)
_sur.index(_env_gen.SUR.NDXMAG);
_sur.prefix(_dk.ref());
MG.clear();
{? _can_continue>0 & _gen*'NLI'>0
|| {? _mag.first()
   || {!
      |? {? MG.seek(_mag.REF,)
         || _sur.prefix(_dk.ref(),_mag.REF);
            {? _sur.first()
            || {!
               |?
                  _ktm:=exec('FindAndGet','#table','M',_sur.MAT,'material',,null());
                  _mg:=exec('FindAndGet','#table','MG',_sur.MAG,'mag_s',,null());
::                Sprawdzam stan surowca
                  _stan:=0;
                  {? _sur.REJ_MAT<>'T'
                  || _dk_c:=exec('FindAndGet','#table','DK_C',_sur.DK_C,,,null());
                     {? _dk_c<>null()
                     || exec('obl_stan','magazyn_stan',_ktm,1,MG.ref(),,,_data,-2,,,,_dk_c)
                     || exec('obl_stan','magazyn_stan',_ktm,1,MG.ref(),,,_data,-2)
                     ?};
                     _stan+=BEER.SD;
::                   Doliczenie stanu dedykowanych rezerwacji dla surowców nielimitowanych
                     {? _sur.CZY_REZ>0
                     || _stan+=exec('zlim_il_rez','zl_nlimit',_sur.ZLIM)
                     ?}
                  || {? var_pres('_sctab')>100 || obj_del(_sctab) ?};
                     {? _sur.RSC<>''
                     || {? _sur.KODPAL<>''
                        || _sctab:=exec('sc_tmp_scean','magazyn_stan',null(),,,,_sur.RSC)
                        || _sctab:=exec('sc_tmp_scean','magazyn_stan',null(),_sur.SCEAN)
                        ?};
                        _sctab.prefix()
                     || _sctab:=~~
                     ?};
                     _stan+=exec('rej_mat_chk_stan','zl_common',_zlgd,_sur.ZLIM,$_mg,_sur.ZL,_sur.RSC
                                     ,_sur.EANL,'ZLGD','N',1,_sctab,_tab_rez,,,_sur.KODPAL)
                  ?};
                  {? _sur.CZY_REZ>0
                  || _zl:=exec('FindAndGet','#table',ZL,_sur.ZL_REF,,,null());
::                   Wypełnienie tabeli z ilościami zarezerowowanymi (tylko raz dla pary materiał/zlecenie)
                     {? ~_tab_rez.find_tab('first','MREF',,'=',$_ktm,'ZLREF',,'=',$_zl,'TYP',,'=','D')
                     || exec('tab_rez_fill','zl_nlimit',_tab_rez,_zl,_ktm)
                     ?}
                  ?};
                  {? _stan<_sur.ILOSC
                  || {? _sur.SCEAN='' & _sur.KODPAL=''
                     || _msg:='Brak surowca: %1 w magazynie: %2.'@[_sur.KTM,_sur.MAGSYM]
                     |? _sur.EANL=''
                     || {? _sur.KODPAL<>''
                        || _msg:='Brak surowca: %1 w magazynie: %2 i kodzie palety %3.'@
                                 [_sur.KTM,_sur.MAGSYM,_sur.KODPAL]
                        || _msg:='Brak surowca: %1 w magazynie: %2 i kodzie dostawy %3.'@
                                 [_sur.KTM,_sur.MAGSYM,_sur.SCEAN]
                        ?}
                     || _str_lok:=exec('FindAndGet','#table','EANL',_sur.EANL,,"EANL.KOD",'');
                        {? _sur.KODPAL<>''
                        || _msg:='Brak surowca: %1 w magazynie: %2, lokalizacji %3 i kodzie palety %4.'@
                                 [_sur.KTM,_sur.MAGSYM,_str_lok,_sur.KODPAL]
                        || _msg:='Brak surowca: %1 w magazynie: %2, lokalizacji %3 i kodzie dostawy %4.'@
                                 [_sur.KTM,_sur.MAGSYM,_str_lok,_sur.SCEAN]
                        ?}
                     ?};
                     KOMM.add(_msg,4,,1);
                     _can_continue:=0
                  ?};
                  _sur.next()
               !}
            ?}
         ?};
         _mag.next()
      !}
   ?}
?};
:: Dla zwrotów walidacja ilości
{? _gen*'ZWR'>0
|| {? _pob.first()
   || _zlim_tab:=sql('select ZLIM as REF, sum(ILOSC) as IL from prefixed_table(:_a) group by ZLIM',_pob);
      {? type_of(_zlim_tab)>0 & _zlim_tab.first()
      || {!
         |?
            _zlim_max:=exec('FindAndGet','#table',ZLIM,_zlim_tab.REF,,"ZLIM.IL_RW-ZLIM.IL_ZW",0);
            {? _zlim_tab.IL>_zlim_max
            || {? _gen='ZWR'
               || _msg:='Ilość zwracana towaru %1 ponad ilość pobrań na zleceniu %2.'@[_pob.KTM,_pob.ZL_SYM]
               || _msg:='Ilość zwracana towaru %1 ponad ilość pobrań na grupie %2.'@[_pob.KTM,_pob.GROP_KOD]
               ?};
               KOMM.add(_msg,4,,1);
               _can_continue:=0
            ?};
            _zlim_tab.next()
         !}
      ?}
   ?}
?};
:: 5. Pętla po magazynach - wystawianie dokumentów
{? _can_continue>0 & _mag.first()
|| {!
   |?
      _ok:=1;
      _first:=1;
      _ref:=null();
      _lockref:=0;

      _tab.prefix(_dk.ref(),_mag.REF);
      {? _gen*'ZWR'>0
      || _sur.prefix(_dk.ref(),)
      ?};

::    Sprawdzam czy na wszystkich surowcach jest to samo zlecenie, jeśli tak to można je dodać
::    do nagłówka dokumentu - jeśli są różne to nagłówek dokumentu będzie bez zlecenia
      {? _can_continue>0 & _tab.first()
      || _zl_nag:=_tab.ZL_REF;
         {!
         |? {? _zl_nag<>_tab.ZL_REF
            || _zl_nag:=''
            ?};
            _tab.next() & _zl_nag<>''
         !}
      ?};

      {? _can_continue>0 & _tab.first()
      || {!
         |? {? _tab.ILOSC>0
               & {? _gen*'ZWR'=0 || 1 || _sur.seek(_pob.REFSUR) ?}
               & M.seek(_sur.MAT,)
               & MG.seek(_mag.REF,)
               & (_tab.WYD=0 | SLO.seek(_tab.WYD,))
            || _dalej:=1;
               {? _tab.WYD=0 || _wyd:=null() || _wyd:=SLO.ref() ?};
               {? _dalej=1
               || {? _first=1
                   & _ok
                  || _ref:=null();
::                     do();
                     _zl:=null();
                     {? _zl_nag<>''
                     || _zl:=exec('FindAndGet','#table',ZL,_zl_nag,,,null())
                     ?};
                     _ref:=_nd:=exec('addnag','magdok_nag',
                        MG.ref(),ST.AR,ST.AM,_typdok,'N',,_data,,,,BIT.sqlint(_dk.REF),_dk.NDNAME,_dk.O,_zl,_wyd,,,,1
                     );
::                   Jeżeli transakcja została zerwana, to _nd musi być null()
                     {?
::                        end() &
                        _nd<>null()
                     || ND.clear();
                        {? ND.seek(_nd)
                        || _kodmsk:=ND.name()+3;
                           KOMM.add('Utworzono dokument: %1 na magazynie %2'@[ND.SYM,MG.SYM]);
                           _lockref:=ND.r_lock(1,1);
                           {? _lockref=0
                           || _ok:=0;
                              KOMM.add('Nie udało się zablokować dokumentu - zmiany zostaną wycofane.'@,2)
                           || ND.GRP_KEY:=_tm_stamp+'1';
                              ND.put()
                           ?}
                        ?}

                     || KOMM.add('Wystąpił błąd podczas tworzenia nagłówka dokumentu magazynowego.'@,2,,1);
                        _ok:=0;
                        _nd:=null()
                     ?};
                     _first:=0
                  ?};

                  {? _ok & _nd<>null()
                  || _dk_c:=exec('FindAndGet','#table',DK_C,_tab.DK_C,,,null());
                     _zlim:=exec('FindAndGet','#table',ZLIM,_tab.ZLIM,,,null());
                     _zparn:=exec('FindAndGet','#table',ZPARN,_tab.ZPARN,,"ZPARN.ref()",null());
                     _zgh:=exec('FindAndGet','#table',ZGP,_tab.ZGP,,"ZGP.NRPRZ",null());
                     _zgp:=exec('FindAndGet','#table',ZGP,_tab.ZGP,,"ZGP.ref()",null());
                     _zl:=exec('FindAndGet','#table',ZL,_tab.ZL_REF,,,null());
                     _grop:=exec('FindAndGet','#table',GROP,_sur.GROP,,,null());
::                   Sprawdzam czy magazyn typu dostawy
                     {? _dk_c<>null()
                     || _mag_typ:=exec('FindAndGet','#table',ND,_nd,,"MAG().TYP",'');
                        {? ~(_mag_typ*'DOST')
                        || KOMM.add('Surowiec %1 posiada atrybuty, więc wymaga '
                                    'magazynu typu \'DOSTAWY\' lub \'DOSTEWI\'.'@[M.KTM],2,,1);
                           _ok:=0
                        ?}
                     ?};
                     {? _zl=null() & _grop=null()
                     || _ok:=0
                     ?};
::                   Sprawdzam czy surowiec nie powinien być rozliczany do innego zlecenia
                     {? _gen*'ZWR'=0 & _dk.REF*'nagdo'>0
                     || _zl_type:=exec('FindAndGet','#table',ND,_dk.REF,,"ND.ZL().TREE_TYP",'');
                        {? _zl_type<>'P'
                        || {? _zlim<>null()
                           || _podzl:=exec('FindAndGet','#table',ZLIM,_zlim,,"ZLIM.PODZL",'');
                              {? (_zl_type='F' & _podzl='N') | (_zl_type='M' & _podzl='T')
                              || _ok:=0;
                                 {? _podzl='N'
                                 || KOMM.add('Surowiec %1 może być rozliczany wyłącznie na zleceniu montażowym'@
                                    [M.KTM],2,,1)
                                 || KOMM.add('Surowiec %1 może być rozliczany wyłącznie na powiązanym z '
                                             'surowcem podzleceniu'@
                                    [M.KTM],2,,1)
                                 ?}

                              ?}
                           ?}
                        ?}
                     ?};
                     {? _ok>0
                     ||
::                      Obsługa cech dostaw dla odpadów (uzupełnienie atrybutu partii, jeżeli nie przypisana)
                        {? _gen='ODP' & _sur.M_ATR<>'' & _zparn<>null()
                        || _buf_matr.blank();
                           _dalej:=0;
                           M_ATR.cntx_psh();
                           M_ATR.clear();
                           {? M_ATR.seek(_sur.M_ATR)
                           ||
::                                  Sprawdzenie czy wzorzec posiada atrybut typu partia
                              _dalej:=exec('partia_num_matr','mat_atr',M_ATR.ref());
                              {? _dalej>0
                              || _buf_matr.get_matr()
                              ?}
                           ?};
                           M_ATR.cntx_pop();
                           {? _dalej>0
                           || {? _dk_c<>null()
                              || DK_C.cntx_psh();
                                 DK_C.use(ref_name(_dk_c));
                                 DK_C.clear();
                                 {? DK_C.seek(_dk_c)
                                 || _buf_matr.get_dkc()
                                 ?};
                                 DK_C.cntx_pop()
                              ?};
                              {? _buf_matr.has_part()=0
                              || _buf_matr.set_part(_zparn);
::                                     Zakładam nową ceche tylko, gdy wszystkie atrybuty uzupełnione
                                 {? _buf_matr.all_set()>0
                                 || _dk_c:=exec('m_atr_sprdod','mat_atr'
                                       ,_buf_matr.WAR01
                                       ,_buf_matr.WAR02
                                       ,_buf_matr.WAR03
                                       ,_buf_matr.WAR04
                                       ,_buf_matr.WAR05
                                       ,_buf_matr.WAR06
                                       ,_buf_matr.WAR07
                                       ,_buf_matr.WAR08
                                       ,_buf_matr.WAR09
                                       ,_buf_matr.WAR10
                                       ,_buf_matr.M_ATR
                                       ,_zparn
                                    )
                                 ?}
                              ?}
                           ?}
                        ?};
                        _dorozp:=_tab.ILOSC;
::                      Suma zarezerwowanej ilości na rozpiskach
                        _sum_rezr:=0;
                        _sum_rezd:=0;
::                      Ilość dodatkową, która należy rozliczyć
                        _il_add_d:=0;
::                        _il_add_f:=0;
::                      Jeżeli zapis powstał na podstawie rozpiski rozliczeń nielimitów to na początku
::                      tworzone pozycje dokumentów na ich podstawie, w drugiej kolejności brane pod uwagę są
::                      dedykowane rezerwacje do nielimitów
                        {? _sur.REJ_MAT='T' & (_sur.SCEAN<>'' | _sur.KODPAL<>'')
                        || {? _sur.KODPAL<>''
                           || _tab_rez.index(_ndx4);
                              _tab_rez.prefix(_sur.RSC)
                           || _tab_rez.index(_ndx3);
                              _tab_rez.prefix(_sur.SCEAN)
                           ?};
                           {? _tab_rez.first()
                           || {!
                              |?
                                 {? _tab_rez.TYP='R'
                                 || _sum_rezr+=exec('rej_mat_il_rez','zl_common',_dk.REF,$_zlim,MG.ref()
                                       ,_tab_rez.SRDK,,'ZLGD',,_sur.KODPAL)
                                 || _sum_rezd+=exec('sc_il_rez','zl_nlimit',_tab_rez.SRDK,$_zlim)
                                 ?};
                                 _tab_rez.next()
                              !}
                           ?};
                           _il_add:=_dorozp-_sum_rezr;
                           {? _il_add<0 || _il_add:=0 ?};
                           {? _il_add>0
                           || _il_add_d:={? _il_add>_sum_rezd || _sum_rezd || _il_add ?}
::                              _il_add_f:=_il_add-_il_add_d;
::                              {? _il_add_f<0 || _il_add_f:=0 ?}
                           ?};
                           _czy_rez:=2
::                      Jeżeli istnieją rezerwacje dedykowane do nielimitów (do konkretnych dostaw),
::                      to na początku tworzone pozycje dokumentów na podstawie zarezerwowanych wcześniej dostaw
                        |? _sur.CZY_REZ>0
                        || _tab_rez.index(_ndx2);
                           _tab_rez.prefix('D',$_zl,$M.ref(),$_zlim);
                           _czy_rez:=1
::                      Brak dodatkowych rozpisek/rezerwacji, rozliczanie FIFO
                        || _czy_rez:=0
                        ?};
                        _first2:=1;
                        {!
                        |?
                           _scean:=_sur.SCEAN;
                           _kodpal:=_sur.KODPAL;
                           {? _czy_rez>0
                           || {? _first2>0
                              || _loop:=_tab_rez.first();
                                 _first2:=0
                              || _loop:=_tab_rez.next()
                              ?}
                           || _loop:=0
                           ?};
                           {? _loop>0
                           || {? _czy_rez=2
                              || {? _tab_rez.TYP='D'
                                 || _scean:='';
                                    _kodpal:=''
                                 ?};
                                 _sta_d:=exec('sc_il_rez','zl_nlimit',_tab_rez.SRDK,$_zlim);
                                 _sta_r:=exec('rej_mat_il_rez','zl_common',_dk.REF,$_zlim,MG.ref()
                                             ,_tab_rez.SRDK,,'ZLGD',,_kodpal);
                                 _ilr:={? _tab_rez.TYP='R' || _sta_r || _sta_d ?};
                                 {? _tab_rez.TYP='R' & _il_add_d>0 & _sta_d>0
                                 || _ilr:=_ilr+{? _il_add_d>_sta_d || _sta_d || _il_add_d ?}
                                 ?};
::                                 {? _il_add_f>0
::                                 || _sta_f:=exec('FindAndGet','#table',SC,_tab_rez.REF,,
::                                       "exec('obl_stsc','magazyn_stan')",0);
::                                    _ilr:=_ilr+{? _il_add_f>_sta_f || _sta_f || _il_add_f ?}
::                                 ?};
                                 _il:={? _dorozp>_ilr || _ilr || _dorozp ?};
                                 _sc:=_tab_rez.REF
                              || _ilr:=exec('sc_il_rez','zl_nlimit',_tab_rez.SRDK,$_zlim);
                                 _il:={? _dorozp>_ilr || _ilr || _dorozp ?};
                                 _sc:=_tab_rez.REF
                              ?}
                           || _il:=_dorozp;
                              _sc:={? _gen*'ZWR'=0 || '' || _pob.SC ?}
                           ?};
                           {? _il>0
                           || _prdk:={? _gen*'ZWR'>0 & _tab.MAG=_tab.MAG_SRC || _tab.PRDK || '' ?};
::                            TWORZENIE POZYCJI DOKUMENTU MAGAZYNOWEGO
                              {? var_pres('_res_dk')>100
                              || obj_del(_res_dk)
                              ?};
                              _res_dk:=exec('adddk4zl','magdok_prod'
                                               ,_zl
                                               ,_wyd
                                               ,_il
                                               ,M.ref()
                                               ,_nd
                                               ,MG.ref()
                                               ,_prdk
                                               ,_dk_c
                                               ,_zlim
                                               ,
                                               ,_zgh
                                               ,_zparn
                                               ,_zgp
                                               ,_tab_rez
                                               ,_sur.EANL
                                               ,_scean
                                               ,{? _scean<>'' | _kodpal<>'' || 'Z' || '' ?}
                                               ,
                                               ,_sc
                                               ,_dk_rez
                                               ,_dk.REF
                                               ,_grop
                                               ,_zlgd
                                               ,_kodpal
                                           );
                              _can_continue:=_res_dk.RESULT;
                              {? _can_continue>0
                              || _dorozp-=_il;
::                               Aktualizacja dodatkowych ilości do rozpisania
                                 {? _loop>0 & _czy_rez=2
                                 || _ilosc:=_il;
                                    {? _tab_rez.TYP='R'
                                    || _sta_r:=exec('rej_mat_il_rez','zl_common',_dk.REF,$_zlim,MG.ref()
                                                   ,_tab_rez.SRDK,,'ZLGD',,_kodpal);
                                       _diff:=_tab_rez.ILR-_sta_r;
                                       _tab_rez.ILR:=_sta_r;
                                       _tab_rez.put();
                                       _ilosc-=_diff
                                    ?};
                                    {? _ilosc>0 & _il_add_d>0
                                    || _ild:={? _ilosc>_sta_d || _sta_d || _ilosc ?};
                                       _ilosc-=_ild;
                                       _il_add_d-=_ild
                                    ?}
::                                    {? _ilosc>0 & _il_add_f>0
::                                    || _ilf:={? _ilosc>_sta_f || _sta_f || _ilosc ?};
::                                       _ilosc-=_ilf;
::                                       _il_add_f-=_ilf
::                                    ?}
                                 ?}
                              ?}
                           || _can_continue:=0
                           ?};
                           _loop>0 & _dorozp>0
                        !};
                        {? ~_can_continue
                        || {? _dk_c<>null()
                           || KOMM.add('Brak surowca %1 na magazynie %2 o wymaganych wartościach atrybutów'@
                                 [M.KTM,MG.SYM],2,,1)
                           || KOMM.add('Brak surowca %1 na magazynie %2'@
                                 [M.KTM,MG.SYM],2,,1)
                           ?};
                           _ok:=0
                        ||
::                         Określam sposób rozliczania nielimitu/odpadu (rozliczany do podzlecenia/montażowego)
                           {? _dk.REF*'nagdo'>0
                           || _zl_type:=exec('FindAndGet','#table',ND,_dk.REF,,"ND.ZL().TREE_TYP",'');
                              {? _zl_type<>'P'
                              || {? _zlim<>null()
                                 || ZLIM.cntx_psh();
                                    ZLIM.use(ref_name(_zlim));
                                    ZLIM.clear();
                                    {? ZLIM.seek(_zlim)
                                    || ZLIM.PODZL:={? _zl_type='F' || 'T' || 'N' ?};
                                       ZLIM.put()
                                    ?};
                                    ZLIM.cntx_pop()
                                 ?}
                              ?}
                           ?}
                        ?}
                     ?};
                     exec('FindAndGet','#table',ND,_nd,,"r_unlock()")
                  || _ok:=0
                  ?}
               || KOMM.add('Brak surowca %1 na magazynie %2'@[M.KTM,MG.SYM],,,1);
                  _ok:=0
               ?}
            || {? _gen*'ZWR'=0
               || KOMM.add('Problem z generowaniem dokumentu (zerowa ilość surowca albo nieokreślony magazyn)'@,2,,1);
                  _ok:=0
               |? _tab.ILOSC>0
               || KOMM.add('Problem z generowaniem dokumentu (nieokreślony magazyn)'@,2,,1);
                  _ok:=0
               ?}
            ?};
            _tab.next() & _ok
         !}
      ?};
      {? _ok=0
      ||
::       Jeżeli wystąpił błąd, to trzeba odkręcić dokument
         {? _ref<>null()
         || ND.clear();
            {? ND.seek(_ref)
            || _sym:=ND.SYM;
               {? exec('n_usun','magdok_nag',0,1,,,,,,_dk_rez)
               || KOMM.add('Usunięto dokument '+_sym,1)
               ?}
            ?}
         ?};
         _can_continue:=0;
::   undo()
         ~~
      ||
::       Rozpisanie dokumentu wg lokalizacji (uzupełnienie)
         {? exec('FindAndGet','#table',MG,_mag.REF,,"MG.SL='T'",0)
         || ND.cntx_psh(); ND.clear();
            {? ND.seek(_nd)
            || exec('rozpdk_l','magdok_poz',,ND.MAG,,,ND.DLAKH,,,,,0)
            ?};
            ND.cntx_pop()
         ?}
      ?};
      _mag.next() & _can_continue>0
   !};
:: Czyszczę rezerwacje (rozpiskę surowców) dla robocizny
   {? _can_continue>0 & _dk.REF*'zlgd'>0
   || exec('del4ZLGD','zl_limit',0,exec('FindAndGet','#table',ZLGD,_dk.REF,,"ZLGD.ref()",null()),_kodmsk)
   ?}
?};
_sur.cntx_pop();
_dk.cntx_pop();
_pob.cntx_pop();

Cntx.pop(ND,DK,M,SLO,ZKTL,ZL,MG,REZ);
KOMM.sect_end();

{? _can_continue || _tm_stamp || '' ?}


\utwdok
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.30]
:: OPIS: Tworzy dokumenty rozchodowe dla surowców nielimitowanych zlecenia, przychodowe odpadów zlecenia
::       albo zwrotów surowca.
::       Powstaje tyle dokumentów ile jest różnych magazynów zdefiniowanych na pozycjach.
::       Dotyczy automatycznego generowania dokumentów rozchodowych w czynności:
::       TTE_WYK_DGRW, TTE_WYK_DGRO i TTE_WYK_DGZW.
::       Formuła działa w kontekście aktywnego dokumentu ND (raportu produkcji) albo aktywnego zlecenia (ZL dla zwrotów)
::       UWAGA: Na podstawie formuły powstała: utwdok_zgp/!tte_wyk_dgrw.fml (w razie poprawek modyfikować obie).
::   WE: _a - TYPYDOK.ref() - jeżeli nie określony,
::            to wg pametrów 500707 i 500708 albo 500705 i 500706 albo 500709 i 500710
::       _b - 'NLI' rozliczanie surowców nielimitowanych, 'ODP' - rozliczanie odpadów, 'ZWR' - zwroty surowców
::       [_c] - NUMBER - Czy uwzględniać tylko surowce nieoznaczone jako "rozliczane z operacją":
::            1 - tak, [0] - nie (uwzględniać wszystkie surowce)
::   WY: STRING[15] - tm_stamp którym zostały osteplowane utworzone dokumenty rozliczające
::                  - '' dokumenty nie powstały
::                  - 'y' dokumenty nie powstały, ponieważ nie było pozycji do rozliczenia
::  OLD: \utwdok/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_b')=type_of('')
|| _mode:=_b
|| FUN.wdrerror('Błędny parametr _b wywołania formuły \\utwdok/zl_nlimit.fml.');
   return()
?};
{? var_pres('_a')=type_of(null()) & _a<>null()
|| _typydok:=_a
|| _typydok:=exec('Get_TYPYDOK','magdok_wspolne',_mode)
?};
{? _typydok=null()
|| {? _mode='ODP'
   || _msg:='Brak określonego domyślnego typu dokumentu przychodu odpadu/koproduktu ze zlecenia (parametry %1, %2). '
            'Dokument przyjęcia odpadów/koproduktów nie został utworzony.'@['500705','500706']
   |? _mode='NLI'
   || _msg:='Brak określonego domyślnego typu dokumentu rozchodowego na zlecenie (parametry %1, %2). '
            'Dokument rozchodujący surowce nielimitowane nie został utworzony.'@['500707','500708']
   || _msg:='Brak określonego domyślnego typu dokumentu zwrotu surowców ze zlecenia (parametry %1, %2). '
            'Dokument przyjęcia zwracanych surowców nie został utworzony.'@['500709','500710']
   ?};
   KOMM.add(_msg,7,,1);
   return('')
?};
_mrdok:=exec('FindAndGet','#table',TYPYDOK,_typydok,,"T",'');
_typ:={? var_pres('_c')=type_of(0) || _c || 0 ?};

_result:='';
_ok:=1;
_first:=1;
_lim:=0;
_ref:=-1;
_buf_matr:={? _mode<>'ODP' || ~~ || exec('buffer','mat_atr') ?};

_mags:=tab_tmp(1,
:: 'POLE','TYP','Nazwa w oknie',
   'REF','STRING[16]','Sql ref magazynu',
   'SYM','STRING[10]','Symbol magazynu',
   'NAZ','STRING[60]','Nazwa magazynu',
   'TYP','STRING[8]' ,'Typ magazynu'
);

_can_continue:=1;
_tm_stamp:=tm_stamp();
_ilosc_nd:=0;

:: Tabele przechowująca ilość zarazerwowaną dla konkretnych dostaw
:: Wykorzystywna w przypadku rozliczania nielimitów z przypisaną dostawą
{? var_pres('_tab_rez')>100 || obj_del(_tab_rez) ?};
_tab_rez:=exec('tab_rez_create','zl_nlimit');
_ndx1:=_tab_rez.index('?');
_ndx2:=_tab_rez.ndx_tmp(,,'TYP',,,'ZLREF',,,'MREF',,,'ZLIM',,,'REF',,);
_ndx3:=_tab_rez.ndx_tmp(,,'SCEAN',,,'TYP',,1);
:: Tabela przechowująca refy pozycji dokumentów utworzonych na podstawie dedykowanych rezerwacji do nielimitów
{? var_pres('_dk_rez')>100 || obj_del(_dk_rez) ?};
_dk_rez:=tab_tmp(1,
   'REF','STRING[16]','Ref pozycji $DK.ref()'
);

:: Iteracja po pozycjach dokumentu raportującego
DK.prefix(ND.ref());
{? DK.first()
|| ND.cntx_psh();
   {!
   |?
      {? exec('FindAndGet','#table',ZL,DK.ZL,,"
         (ZL.RP='T' & ZL.TREE_TYP='F') | exec('top_rodzaj','zl_link',ZL.ref())='N'",0)
      || _zl:=DK.ZL
      || _zl:=exec('top_level','zl_link',DK.ZL)
      ?};
      _zgh:=DK.ZGH;
      _ilosc:=DK.IL;
      _data:=ND.D;
      _dalej:=1;
      DK.cntx_psh();
      ZL.cntx_psh(); ZL.clear();
      ZLIM.cntx_psh();
      {? _zl<>null() & ZL.seek(_zl)
      || VAR.cntx_psh();
         VAR.A_ZLEC:=_zl;
         _nadzl_il:=ZL.IL;
         exec('openmask','zl_common',VAR.A_ZLEC);
         exec('s_nlim','zl_common');

::       1. W tabeli _mags zbieram listę magazynów
::          - to mi określi ile nagłówków dokumentów należy utworzyć (dla każdego zlecenia)
         MG.cntx_psh(); MG.clear();
         M.cntx_psh();
         _mags.clear();
::         _mags.erase();
         {? _mags.first() || {! |? _mags.del() !} ?};

         ZL.cntx_psh();
         {? ZL.RODZAJ='P'
         || ZL.index('UNRZL');
            ZL.prefix(ZL.UNRZL)
         || ZL.index('NRNZL');
            ZL.prefix(ZL.UNRZL)
         ?};
::       Zbieram ilość pozycji do wygenerowania
         _count:=0;
         {? ZL.first()
         || {!
            |? _zl_il:=ZL.IL;
               ZLIM.index('ZNR');
               {? _mode='ODP'
               || ZLIM.prefix(ZL.ref(),'T')
               || {? _typ
                  || ZLIM.prefix(ZL.ref(),'N','N')
                  || ZLIM.prefix(ZL.ref(),'N')
                  ?}
               ?};
               {? ZLIM.first()
               || {!
                  |? {? (ZLIM.LIMIT='N' | ZLIM.LIMIT='T' & ZLIM.SO='O')
                        & (ZLIM.ZGP().NRZLP=_zgh | ZLIM.ZGP().NRZLP().UID_SRC=exec('FindAndGet','#table',ZGH,_zgh,,"UID",''))
                        & (ZLIM.PODZL='' | (ZLIM.PODZL='T' & ZL.ref()=_zl) | (ZLIM.PODZL='N' & ZL.ref()<>_zl))
                     ||
                        _count+=1;
                        _zgh_il:=ZLIM.ZGP().NRZLP().ILNPRZ;
                        {? ZLIM.MG<>null()
                        ||
::                         Podczytuję magazyn
                           ZLIM.MG();

::                         Wyliczam dostępny stan magazynowy dla podanej pozycji
                           {? _mode='NLI'
                           || {? ZLIM.DK_C<>null()
                              || exec('obl_stan','magazyn_stan',ZLIM.KTM,1,ZLIM.MG,,,_data,-2,,,,ZLIM.DK_C)
                              || exec('obl_stan','magazyn_stan',ZLIM.KTM,1,ZLIM.MG,,,_data,-2)
                              ?}
                           ?};
::                         Doliczenie stanu dedykowanych rezerwacji dla surowców nielimitowanych
                           {? ZLIM.LIMIT='N'
                           || BEER.SD+=exec('zlim_il_rez','zl_nlimit',$ZLIM.ref());
::                            Wypełnienie tabeli z ilościami zarezerowowanymi (tylko raz dla pary materiał/zlecenie)
                              {? ~_tab_rez.find_tab('first','MREF',,'=',$ZLIM.KTM,'ZLREF',,'=',$ZL.ref(),'TYP',,'=','D')
                              || exec('tab_rez_fill','zl_nlimit',_tab_rez,ZL.ref(),ZLIM.KTM)
                              ?}
                           ?};

                           _dokl:=exec('jaka_dok_m','jm',ZLIM.KTM);
                           _lil:=exec('sum_il','zl_limit',ZLIM.ref());
                           _il:={? _dokl>0
                                || ((_lil*_ilosc)/_zgh_il*_zl_il/_nadzl_il)$ _dokl
                                || ceil(((_lil*_ilosc)/_zgh_il*_zl_il/_nadzl_il))
                                ?};

::                         Sprawdzam dostępny stan magazynowy
                           {? _mode='NLI' & BEER.SD<_il
                           || {? ZLIM.DK_C<>null()
                              || _msg:='Brak surowca: %1 w magazynie: %2 o wymaganych wartościach atrybutów. '
                                       'Dokumenty %3 nie zostały utworzone.'@
                                       [ZLIM.KTM().KTM,MG.SYM,form(_mrdok)]
                              || _msg:='Brak surowca: %1 w magazynie: %2. '
                                       'Dokumenty %3 nie zostały utworzone.'@
                                       [ZLIM.KTM().KTM,MG.SYM,form(_mrdok)]
                              ?};
                              KOMM.add(_msg,4,,1);
                              _can_continue:=0
                           ?};

                           {? _can_continue>0
                           || _mags.cntx_psh();
                              _mags.prefix($ZLIM.MG);
                              {? _mags.size()=0
                              || _mags.blank();
                                 _mags.REF:=$MG.ref();
                                 _mags.SYM:=MG.SYM;
                                 _mags.NAZ:=MG.NAZ;
                                 _mags.TYP:=MG.TYP;
                                 _mags.add()
                              ?};
                              _mags.cntx_pop()
                           ?}
                        ||
                           KOMM.add('Nie przypisano magazynu do surowca %1. Dokumenty %2 nie zostały utworzone.'@
                                    [ZLIM.KTM().KTM,form(_mrdok)],4,,1);
                           _can_continue:=0
                        ?}
                     ?};
                     ZLIM.next()
                  !}
               ?};
               ZL.next()
            !}
         ?};
         ZL.cntx_pop();

         {? _count=0
         || KOMM.add(
               {? _mode='NLI'
               || 'Zlecenie %1 nie ma zdefiniowanych surowców nielimitowanych.'@[VAR.A_ZLEC().SYM]
               || 'Zlecenie %1 nie ma zdefiniowanych odpadów/koproduktów.'@[VAR.A_ZLEC().SYM]
               ?}+' '+
               'Dokumenty %1 nie zostały utworzone.'@[form(_mrdok)],4,,1
            );
            _can_continue:=-3
         ?};

::       Pętla po magazynach - sprawdzenie dostępności typów dokumentów
         MG.clear();
         {? _mags.first()
         || {!
            |? {? MG.seek(_mags.REF,)
               || _magtab:=obj_new(1); _magtab[1]:=MG.ref();
                  _typydok_sym:=exec('FindAndGet','#table',TYPYDOK,_typydok,,"T",'');
                  _typy_ok:=exec('typ_dok','lmg','"TYPYDOK".T=\''+_typydok_sym+'\'',,,1,_magtab,,,0);
                  {? _typy_ok=''
                  || _msg:='Brak dostępu do dokumentu: %1 na magazynie: %2.'@[_typydok_sym,MG.SYM];
                     KOMM.add(_msg,4,,1);
                     _can_continue:=0
                  ?};
                  obj_del(_magtab)
               ?};
               _mags.next()
            !}
         ?};

::       2. W pętli po magazynach tworzę nagłówki dokumentów, a do nich pozycje na podstawie nielimitów, odpadów
         {? _can_continue>0
         ||
            {? _mags.first()
            ||
               ZLIM.index('MAG');
               {!
               |? _mg:=exec('FindAndGet','#table',MG,_mags.REF,,,null());

::                TWORZĘ NAGŁÓWEK DOKUMENTU MAGAZYNOWEGO (zawsze bez wykorzystywania wolnych numerów)
                  _nd:=exec('addnag','magdok_nag',
                     _mg,ST.AR,ST.AM,_typydok,'N',,_data,,,,#ND.ref(),ND.name(),ND.O,_zl,,,,,0
                  );

                  {? _nd<>null()
                  ||
::                   Ostemplowanie nagłówka GRP_KEY
::                   - jedna paczka dokumentów w ramach czynności TTE_WYK_DGRW, TTE_WYK_DGRO
                     ND.cntx_psh();
                     ND.prefix();
                     {? ND.seek(_nd) || ND.GRP_KEY:=_tm_stamp+'1'; ND.put() ?};
                     ND.cntx_pop();

                     ZL.cntx_psh();
                     {? ZL.RODZAJ='P'
                     || ZL.index('UNRZL');
                        ZL.prefix(ZL.UNRZL)
                     || ZL.index('NRNZL');
                        ZL.prefix(ZL.UNRZL)
                     ?};

                     {? ZL.first()
                     || {!
                        |? _zl_il:=ZL.IL;
                           {? _typ &  _mode='NLI'
                           || ZLIM.prefix(ZL.ref(),_mg,'N','S','N')
                           || ZLIM.prefix(ZL.ref(),_mg,{? _mode='NLI' || 'N' || 'T' ?},{? _mode='NLI' || 'S' || 'O' ?})
                           ?};
                           {? ZLIM.first()
                           || {!
                              |? {? (ZLIM.ZGP().NRZLP=_zgh | ZLIM.ZGP().NRZLP().UID_SRC=exec('FindAndGet','#table',ZGH,_zgh,,"UID",''))
                                    & (ZLIM.PODZL='' | (ZLIM.PODZL='T' & ZL.ref()=_zl) | (ZLIM.PODZL='N' & ZL.ref()<>_zl))
                                 ||
                                    _zgh_il:=ZLIM.ZGP().NRZLP().ILNPRZ;
                                    _dokl:=exec('jaka_dok_m','jm',ZLIM.KTM);
                                    _lil:=exec('sum_il','zl_limit',ZLIM.ref());
                                    _il:={? _dokl>0
                                         || ((_lil*_ilosc)/_zgh_il*_zl_il/_nadzl_il)$ _dokl
                                         || ceil(((_lil*_ilosc)/_zgh_il*_zl_il/_nadzl_il))
                                         ?};
                                    {? _il>0
                                    || _zparn:=DK.PARTIA;
                                       _dk_c:=ZLIM.DK_C;
::                                     Obsługa cech dostaw dla odpadów (uzupełnienie atrybutu partii)
                                       {? _mode='ODP' & ZLIM.KTM().M_ATR & _zparn<>null()
                                       || _buf_matr.blank();
::                                        Sprawdzenie czy wzorzec posiada atrybut typu partia
                                          _dalej:=exec('partia_num_matr','mat_atr',ZLIM.KTM().M_ATR);
                                          {? _dalej>0
                                          || M_ATR.cntx_psh();
                                             ZLIM.KTM().M_ATR();
                                             _buf_matr.get_matr();
                                             M_ATR.cntx_pop()
                                          ?};
                                          {? _dalej>0
                                          || {? ZLIM.DK_C<>null()
                                             || DK_C.cntx_psh();
                                                DK_C.use(ref_name(ZLIM.DK_C));
                                                DK_C.clear();
                                                {? DK_C.seek(ZLIM.DK_C)
                                                || _buf_matr.get_dkc()
                                                ?};
                                                DK_C.cntx_pop()
                                             ?};
                                             {? _buf_matr.has_part()=0
                                             || _buf_matr.set_part(_zparn);
::                                                 Zakładam nową ceche tylko, gdy wszystkie atrybuty uzupełnione
                                                {? _buf_matr.all_set()>0
                                                || _dk_c:=exec('m_atr_sprdod','mat_atr'
                                                      ,_buf_matr.WAR01
                                                      ,_buf_matr.WAR02
                                                      ,_buf_matr.WAR03
                                                      ,_buf_matr.WAR04
                                                      ,_buf_matr.WAR05
                                                      ,_buf_matr.WAR06
                                                      ,_buf_matr.WAR07
                                                      ,_buf_matr.WAR08
                                                      ,_buf_matr.WAR09
                                                      ,_buf_matr.WAR10
                                                      ,_buf_matr.M_ATR
                                                      ,_zparn
                                                   )
                                                ?}
                                             ?}
                                          ?}
                                       ?};
                                       _czy_rez:=0;
::                                     Sprawdzenie, czy do surowca istnieją rezerwacje dedykowane do nielimitów
                                       {? ZLIM.LIMIT='N' & exec('zlim_il_rez','zl_nlimit',$ZLIM.ref())>0
                                       || _czy_rez:=1
                                       ?};
                                       _dorozp:=_il;
::                                     Jeżeli istnieją rezerwacje dedykowane do nielimitów (zlecenia utworzone
::                                     na podst. stanów mag.),  to na początku tworzone pozycje dokumentów na
::                                     podstawie zarezerwowanych wcześniej dostaw
                                       {? _czy_rez>0
                                       || _tab_rez.index(_ndx2);
                                          _tab_rez.prefix('D',$ZL.ref(),$ZLIM.KTM,$ZLIM.ref())
                                       ?};
                                       _first:=1;
                                       {!
                                       |?
                                          {? _czy_rez>0
                                          || {? _first>0
                                             || _loop:=_tab_rez.first();
                                                _first:=0
                                             || _loop:=_tab_rez.next()
                                             ?}
                                          || _loop:=0
                                          ?};
                                          {? _loop>0
                                          || _ilr:=exec('sc_il_rez','zl_nlimit',_tab_rez.SRDK,$ZLIM.ref());
                                             _il:={? _dorozp>_ilr || _ilr || _dorozp ?};
                                             _sc:=_tab_rez.REF
                                          || _il:=_dorozp;
                                             _sc:=''
                                          ?};
                                          {? _il>0
                                          ||
::                                           TWORZĘ POZYCJĘ DOKUMENTU MAGAZYNOWEGO
                                             {? var_pres('_res_dk')>100
                                             || obj_del(_res_dk)
                                             ?};
                                             _res_dk:=exec('adddk4zl','magdok_prod',  ZL.ref()
                                                                                    ,ZLIM.WYD
                                                                                    ,_il
                                                                                    ,ZLIM.KTM
                                                                                    ,_nd
                                                                                    ,_mg
                                                                                    ,
                                                                                    ,_dk_c
                                                                                    ,ZLIM.ref()
                                                                                    ,_tm_stamp
                                                                                    ,ZLIM.ZGP().NRPRZ
                                                                                    ,_zparn
                                                                                    ,ZLIM.ZGP
                                                                                    ,,,,,
                                                                                    ,_sc
                                                                                    ,_dk_rez);
                                             _can_continue:=_res_dk.RESULT;
::                                           zapis o wymiarach o ile istnieją
                                             {? _res_dk.RESULT>0
                                             || _dorozp-=_il;
                                                DK.cntx_psh();
                                                DK.prefix();
                                                {? DK.seek(_res_dk.DK) & DK.PLUS='T' & DK.N().MAG().SL='T'
                                                || _pal:=null();
                                                   _eanl:=DK.N().MAG().EANL;
                                                   _tw:={? DK.TW<>date(0,0,0) || DK.TW || DK.PARTIA().TW ?};
                                                   exec('add2dk_l','magdok_wspolne',DK.ref(),null(),_eanl,null()
                                                    ,_tw,date(0,0,0),DK.IL,ND.MAG,DK.M,,,_pal)
                                                ?};
                                                DK.cntx_pop()
                                             ?}
                                          ?};
                                          _loop>0 & _dorozp>0
                                       !};
                                       {? _can_continue=0
                                       || _msg:=
                                             'Nie udało się utworzenie pozycji dokumentu magazynowego dla surowca: %1'@
                                             [ZLIM.KTM().KTM];
                                          KOMM.add(_msg,2,,1)
                                       ||
::                                        Określam sposób rozliczania nielimitu/odpadu
                                          _zl_type:=exec('FindAndGet','#table',ZL,_zl,,"ZL.TREE_TYP",'');
                                          {? _zl_type<>'P'
                                          || ZLIM.PODZL:={? _zl_type='F' || 'T' || 'N' ?};
                                             ZLIM.put()
                                          ?}
                                       ?}
                                    ?}
                                 ?};
                                 _can_continue>0 & ZLIM.next()
                              !}
                           ?};
                           _can_continue>0 & ZL.next()
                        !}
                     ?};
                     ZL.cntx_pop()

                  || _can_continue:=0
                  ?};
                  {? _can_continue>0
                  || _nd_sym:=exec('FindAndGet','#table',ND,_nd,,"SYM",'');
                     _msg:='Utworzono dokument o symbolu: %1 na magazynie: %2'@[_nd_sym,_mags.SYM];
                     KOMM.add(_msg,7,,1);
                     _ilosc_nd+=1
                  || _msg:='Nie udało się utworzyć dokumentu: %1 na magazynie: %2'@[form(_mrdok),_mags.SYM];
                     KOMM.add(_msg,2,,1);
                     {? _nd<>null()
                     ||
::                      Jeśli nagłówek powstał to go usuwam
                        ND.cntx_psh(); ND.clear();
                        {? ND.seek(_nd)
                        || exec('n_usun','magdok_nag',0,0,,,,,,_dk_rez)
                        ?};
                        ND.cntx_pop();
                        ~~
                     ?}
                  ?};
                  _can_continue>0 & _mags.next()
               !}
            ?}
         ?};
         M.cntx_pop();
         MG.cntx_pop();
         VAR.cntx_pop()
      ?};
      ZL.cntx_pop();
      ZLIM.cntx_pop();
      DK.cntx_pop();
      _can_continue>0 & DK.next()
   !};
   ND.cntx_pop()
?};

{? _can_continue>0
|| _result:=_tm_stamp
|? _can_continue=-3
|| _result:='y'
?};
_result


\nlim_analiza_b
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'przed' dla tabeli ZLIM (surowce nielimitowane)
::  OLD: \nlim_analiza_b/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('is_pdbuf','plan_dostaw')
||
   {? ZLIM.sel_size()=0
   ||
      exec('env_create','plan_dostaw')
   ?};

   ZL.cntx_psh(); GROP.cntx_psh();
   ZL.clear(); GROP.clear();

   _args:=exec('pda_a','plan_dostaw');
   _args.M:=ZLIM.KTM;
   _args.TM_STAMP:=SYSLOG.tm_stamp();
   {? ZLIM.GROP<>null()
   || {? exec('create','#tm_stamp',ZLIM.GROP().PL_DATA,GROP.PL_TIME)>=SYSLOG.tm_stamp()
      || _args.DK:=GROP.PL_DATA;
         _args.TK:=GROP.PL_TIME
      ?}
   || {? exec('create','#tm_stamp',ZLIM.ZLEC().PL_DATA,ZL.PL_TIME)>=SYSLOG.tm_stamp()
      || _args.DK:=ZL.PL_DATA;
         _args.TK:=ZL.PL_TIME
      ?}
   ?};
   _args.IL:=ZLIM.LIL-(ZLIM.IL_RW-ZLIM.IL_ZW);
   _args.DW:=ZLIM.STARTD;
   _args.TW:=ZLIM.STARTT;
   _args.DISP:=0;
   _args.skip_add($ZLIM.ref());
   _res:=exec('pda','plan_dostaw',_args);

   _argse:=exec('an_add_a','plan_dostaw');
   _argse.M:=_args.M;
   _argse.IL:=_args.IL;
   _argse.DW:=_args.DW;
   _argse.TW:=_args.TW;
   _argse.DOSTEPNY:=_res.DOSTEPNY;
   _argse.IL_DOST:=_res.IL_DOST;
   _argse.DM:=_res.NA_KIEDY;
   _argse.skip_add($ZLIM.ref());
   exec('an_add','plan_dostaw',_argse);

   ZL.cntx_pop(); GROP.cntx_pop();

   {? ZLIM.sel_size()=0
   ||
      exec('an_select','plan_dostaw');
      exec('env_delete','plan_dostaw')
   ?}
?};
~~


\nlim_analiza_a
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'po' dla tabeli ZLIM (surowce nielimitowane)
::  OLD: \nlim_analiza_a/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
~~


\nlim_analiza_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'przed grupą' dla tabeli ZLIM (surowce nielimitowane)
::  OLD: \nlim_analiza_bg/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
{? exec('is_pdbuf','plan_dostaw')
|| exec('env_create','plan_dostaw')
|| 0
?}


\nlim_analiza_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Analiza dostępności materiałów w czasie - akcja 'po grupie' dla tabeli ZLIM (surowce nielimitowane)
::  OLD: \nlim_analiza_ag/sur_nlim.fml
::----------------------------------------------------------------------------------------------------------------------
exec('an_select','plan_dostaw');
exec('env_delete','plan_dostaw')


\czy_sa_nielimity
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdzenie, czy dla zlecenia są surowce nielimitowane
::   WE: _a - ZL.ref()
::       [_b] - NUMBER - Czy uwzględniać tylko surowce nieoznaczone jako "rozliczane z operacją":
::            1 - tak, [0] - nie (uwzględniać wszystkie surowce nielimitowane)
::   WY: 1 - dla zlecenia wygenerowano surowce nielimitowane
::       0 - zlecenie nie posiada surowców nielimitowanych
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_result:=0;
_typ:={? var_pres('_b')=type_of(0) || _b || 0 ?};

{? (ZL.RP='T' & ZL.TREE_TYP='F') | exec('top_rodzaj','zl_link',ZL.ref())='N'
|| _top:=ZL.ref()
|| _top:=exec('top_level','zl_link',_zl)
?};
_zl_rodz:=exec('FindAndGet','#table',ZL,_top,,"ZL.TREE_TYP",'');

ZL.cntx_psh();
ZLIM.cntx_psh();
ZL.prefix();
{? ZL.seek(_top)
|| exec('openmask','zl_common',ZL.ref());
   {? ZL.RODZAJ='P'
   || ZLIM.index('ZNR');
      {? _typ
      || ZLIM.prefix(ZL.ref(),'N','N')
      || ZLIM.prefix(ZL.ref(),'N')
      ?};
      {? _zl_rodz='Z'
      || {? ZLIM.find_tab(,'PODZL',,'<>','T')
         || _result:=1
         ?}
      |? _zl_rodz='F'
      || {? ZLIM.find_tab(,'PODZL',,'<>','N')
         || _result:=1
         ?}
      || {? ZLIM.first()
         || _result:=1
         ?}
      ?}
   || ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? ZLIM.index('ZNR');
            {? _typ
            || ZLIM.prefix(ZL.ref(),'N','N')
            || ZLIM.prefix(ZL.ref(),'N')
            ?};
            {? _zl_rodz='Z'
            || {? ZLIM.find_tab(,'PODZL',,'<>','T')
               || _result:=1
               ?}
            |? _zl_rodz='F'
            || {? ZLIM.find_tab(,'PODZL',,'<>','N')
               || _result:=1
               ?}
            || {? ZLIM.first()
               || _result:=1
               ?}
            ?};
            _result=0 & ZL.next()
         !}
      ?}
   ?}
?};
ZL.cntx_pop();
ZLIM.cntx_pop();
_result


\czy_sa_nielimity_zgp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Sprawdzenie, czy dla pozycji przewodnika są surowce nielimitowane
::   WE: _a - ZGP.ref()
::       [_b] - NUMBER - Czy uwzględniać tylko surowce oznaczone jako "rozliczane z operacją":
::            1 - tak, [0] - nie (uwzględniać wszystkie surowce nielimitowane)
::   WY: 1 - dla zlecenia wygenerowano surowce nielimitowane
::       0 - zlecenie nie posiada surowców nielimitowanych
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;
_typ:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_result:=0;

ZGP.cntx_psh();
ZLIM.cntx_psh();
ZGP.prefix();
{? ZGP.seek(_zgp)
|| exec('openmask','zl_common',ZGP.ZL);
   ZLIM.index('ZGP_ROZ');
   {? _typ=1
   || ZLIM.prefix(_zgp,'N','T')
   || ZLIM.prefix(_zgp,'N')
   ?};
   {? ZLIM.first()
   || {? _typ=1
      ||
::       Jeżeli uwzględniane tylko surowce rozliczane z operacją to sprawdzam czy są rezerwacje pod surowce
         REZ.cntx_psh();
         _mask:=(REZ.name()-2)+'__';
         {? REZ.name()<>_mask || REZ.use(_mask) ?};
         REZ.index('ZLREZP2');
         REZ.prefix(ZGP.ZL,'S','R','T',$ZGP.ref(),);
         {? REZ.first()
         || _result:=1
         ?};
         REZ.cntx_pop()
      || _result:=1
      ?}
   ?}
?};
ZGP.cntx_pop();
ZLIM.cntx_pop();
_result


\czy_sa_odpady
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Sprawdzenie, czy dla zlecenia są odpady
::   WE: _a - ZL.ref()
::   WY: 1 - dla zlecenia wygenerowano listę odpadów
::       0 - zlecenie nie posiada listy odpadów
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_result:=0;

{? (ZL.RP='T' & ZL.TREE_TYP='F') | exec('top_rodzaj','zl_link',ZL.ref())='N'
|| _top:=ZL.ref()
|| _top:=exec('top_level','zl_link',_zl)
?};
_zl_rodz:=exec('FindAndGet','#table',ZL,_top,,"ZL.TREE_TYP",'');

ZL.cntx_psh();
ZLIM.cntx_psh();
ZL.prefix();
{? ZL.seek(_top)
|| exec('openmask','zl_common',ZL.ref());
   {? ZL.RODZAJ='P'
   || ZLIM.index('ZNO');
      ZLIM.prefix(ZL.ref(),'T','O');
      {? _zl_rodz='Z'
      || {? ZLIM.find_tab(,'PODZL',,'<>','T','KOR',,'=',0)
         || _result:=1
         ?}
      |? _zl_rodz='F'
      || {? ZLIM.find_tab(,'PODZL',,'<>','N','KOR',,'=',0)
         || _result:=1
         ?}
      || {? ZLIM.first()
         || _result:=1
         ?}
      ?}
   || ZL.index('NRNZL');
      ZL.prefix(ZL.UNRZL);
      {? ZL.first()
      || {!
         |? ZLIM.index('ZNO');
            ZLIM.prefix(ZL.ref(),'T','O');
            {? _zl_rodz='Z'
            || {? ZLIM.find_tab(,'PODZL',,'<>','T','KOR',,'=',0)
               || _result:=1
               ?}
            |? _zl_rodz='F'
            || {? ZLIM.find_tab(,'PODZL',,'<>','N','KOR',,'=',0)
               || _result:=1
               ?}
            || {? ZLIM.first()
               || _result:=1
               ?}
            ?};
            _result=0 & ZL.next()
         !}
      ?}
   ?}
?};
ZL.cntx_pop();
ZLIM.cntx_pop();
_result


\action_zgp_nlim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Rejestrowanie zapotrzebowań do zlecenia - akcja 'Surowce nielimitowane' do pozycji przewodnika zlecenia
::  OLD: \action_zgp_nlim/!tte_pzl_dlim.fml
::----------------------------------------------------------------------------------------------------------------------
_zl:=exec('FindAndGet','#table',ZGH,ZGP.NRZLP,,"ZLEC",null());

{? exec('FindAndGet','#table',ZL,_zl,,"STAN",'')='Z'
|| exec('zgp_nlim','zl_nlimit',ZGP.ref())
|| {? exec('zl_lock','zl_common',_zl,'L')
   || _args:=exec('mp_run_a','#b__box');
      _args.ACT_UID:='TTE_PZL_DLIM';
      _args.UIDREF:=exec('FindAndGet','#table',ZGH,ZGP.NRZLP,,"uidref()",'');
      _args.AKCJA:='ZGP_NIELIMITOWANE';
      _args.CONTEXT:=obj_new('ZGP'); _args.CONTEXT.ZGP:=ZGP.ref();
      _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
      exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',_zl);
      exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZGH',ZGP.NRZLP);

      exec('mp_run','#b__box',_args)
   ?};
   exec('zl_unlock','zl_common',_zl,'L')
?};
''


\rej_mat_bud
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Przed akcją Utwórz dokument w oknie pobrań surowców do robocizny.
::       Pracuje na aktualnym rekordzie ZLGD
::----------------------------------------------------------------------------------------------------------------------
_zlgd:=ZLGD.ref();
{? var_pres('__ENV_GEN')>100 || obj_del(__ENV_GEN) ?};
_env_gen:=exec('env_gen','zl_limit','NLI_ZLGD');
params_set('env_gen',_env_gen);
{? exec('fill_zlgd','zl_wyk',_zlgd)
|| exec('action_ra_generate','zl_nlimit');
:: Jeżeli utworzono dokument (nie ma zapisanych rozpisek do danego ZLGD) to zamykam okno
   _zl:=ZLGD.ZL;
   REZ.cntx_psh();
   _rez_mask:=(REZ.name()-2)+'__';
   {? REZ.name()<>_rez_mask || REZ.use(_rez_mask) ?};
   REZ.index('ZLREZR');
   REZ.prefix(_zl,'S','R',$_zlgd,);
   {? ~REZ.first()
   || sel_exit()
   ?};
   REZ.cntx_pop()
?};
~~


\rej_mat_bg_ud
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Przed akcją grupową Utwórz dokument dla tabeli REJ_MAT
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
exec('rej_mat_bud','zl_nlimit');
0


\spr_nlim
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Sprawdzenie czy dodawany surowiec znajduje się na liście nielimitów zlecenia.
::       Wywoływane przy korekcji nielimitów (pobrań) do rejestracji wykonania.
::       Konteks wywołania - konkretny rekord tabeli REZ i ZLGD
::   WE: _a - ZL.ref()
::       _b - ZLGD.ref()
::       [_c] - konekst wywołania: [0] - akceptacja rezerwacji (dodanie surowca do zapotrzebowań, gdy go nie ma)
::                                  1 - zmiana indeksu w oknie rezeracji (uzupełnienie pól na rezerwacji)
::   WY: ZLIM.ref() - gdy jest surowiec lub został pomyślnie dołączony, null(), gdy się nie udało dołączyć surowca
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
ZLIM.cntx_psh();
ZL.clear();

VAR.A_T:=REZ.M;
VAR.A_ZLEC:=_a;
_zlgd:=_b;
_res:=null();
_where:={? var_pres('_c')=type_of(0) || _c || 0 ?};

exec('openmask','zl_common',VAR.A_ZLEC);

ZLIM.index('ZGP_KM');
ZLIM.prefix(ZLGD.ZGP,'N',0,VAR.A_T);
{? ~ZLIM.first()
|| {? _where=1
   || __zkpdkc:=REZ.DK_C:=ATR.DKCZKP:=null();
      REZ.REFSQL:=REZ.ZLIM:=''
   || _zgh_il:=ZLGD.ZGP().NRZLP().ILNPRZ;
      _zlgd_il:=exec('FindAndGet','#table',ZLGD,_zlgd,,"ZLGD.IL+ZLGD.IL_BRAK+ZLGD.DEK_IL+ZLGD.DEK_BR",1);
      _dokl:=VAR.A_T().DOKL;
      _ilr:=REZ.ILR;
      _lil:=_ilr*_zgh_il/_zlgd_il;
      {? _dokl=0 || _lil:=ceil(_lil) || _lil:=_lil$_dokl ?};
      {? FUN.ask(
            'Wskazanego surowca (%1) nie ma na zapotrzebowaniu do pozycji przewodnika zlecenia.'@[VAR.A_T().KTM]
            +'\n\n'+
            'Ilość wpisana w odniesieniu do zapisu robocizny [%1]: %2 %3.'@
            [form(_zlgd_il),form(_ilr,,_dokl,'.,'),VAR.A_T().J().KOD]+
            '\n'+
            'Ilość wyskalowana do ilości produktu na przewodniku [%1]: %2 %3.'@
            [form(_zgh_il),form(_lil,,_dokl,'.,'),VAR.A_T().J().KOD]+
            '\n\n'+
            'Czy dodać do listy %1 %2 (do zapotrzebowania zostanie dodane %3 %4)?'@
            [form(_ilr,,_dokl,'.,'),VAR.A_T().J().KOD,form(_lil,,_dokl,'.,'),VAR.A_T().J().KOD]
         )
      || ZLIM.blank();
         ZLIM.LIMIT:='N';
         ZLIM.AUTO:='N';
         ZLIM.ZLEC:=VAR.A_ZLEC;
         ZLIM.TMAT:=null();
         ZLIM.KTM:=VAR.A_T;
         ZLIM.PFAZ:=null();
         ZLIM.WYD:=VAR.A_ZLEC().JORG;
         ZLIM.MG:=REZ.MG;
         ZLIM.LIL:=_lil;
         ZLIM.SO:='S';
         ZLIM.NR:=exec('bl_nlrlim','zl_limit');
         ZLIM.PARTIA:='N';
         ZLIM.ZGP:=ZLGD.ZGP;
         ZLIM.ROZ:='T';
         _dt:=exec('datetime','zl_limit',ZLIM.ZGP);
         ZLIM.STARTD:=_dt.DATE;
         ZLIM.STARTT:=_dt.TIME;
         obj_del(_dt);
         {? ZLIM.add()
         || _res:=ZLIM.ref()
         ?}
      ?}
   ?}
|| _res:=ZLIM.ref();
   {? _where=1
   || {? ZLIM.MG<>null()
      || __zkpmag:=REZ.MG:=ZLIM.MG
      ?};
      __zkpdkc:=REZ.DK_C:=ATR.DKCZKP:=ZLIM.DK_C;
      REZ.REFSQL:=REZ.ZLIM:=$ZLIM.ref()
   ?}
?};
ZLIM.cntx_pop();
ZL.cntx_pop();
_res


\chk_nlim_roz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Sprawdza czy dla danej operacji są nielimitowane surowce rozliczane z operacją
::   WE: _a - ZGP.ref
::       _b - ZL.ref
::   WY: 1 - są, 0 - nie ma
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_zgp:={? var_pres('_a')=type_of(null()) & _a<>null() || _a || return(0) ?};
_zl:={? var_pres('_b')=type_of(null()) & _b<>null() || _b || return(0) ?};
ZLIM.cntx_psh();
exec('openmask','zl_common',_zl);
ZLIM.index('ZGP_ROZ');
ZLIM.prefix(_zgp,'N','T');
{? ZLIM.first()
|| _result:=1
?};
ZLIM.cntx_pop();
_result


\chk_rej_mat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [20.14]
:: OPIS: Sprawdza rozpiskę rozliczeń surowców podczas rejestracji operacji
::       (czy wszystkie materiały są dostępne na magazynie)
::   WY: STRING - nazwa materiału, którego brakuje na stanie wskazanego magazynu. Ciąg pusty ('') jeżeli nie ma błędu
::----------------------------------------------------------------------------------------------------------------------
_res:='';
{? var_pres('__ENV_REJ')<100 | __ENV_REJ.TYPE<>0 || return(_res) ?};
_tab:=__ENV_REJ.TAB;
:: Aktualizacja stanów magazynowych rozpiski
{? VEK.TERM<>'T'
|| {? _tab.first()
   || {!
      |?
         _ktm:=exec('FindAndGet','#table','M',_tab.MREF,,"M.ref",null);
         _mg:=exec('FindAndGet','#table','MG',_tab.MGREF,,"MG.ref",null);
         _dk_c:=exec('FindAndGet','#table','DK_C',_tab.DKCREF,,"DK_C.ref",null);
         _zl:=exec('FindAndGet','#table','ZL',_tab.ZLREF,,"ZL.ref",null);
::       Sprawdzam dostępny stan magazynowy dla podanej pozycji
         {? _dk_c<>null()
         || exec('obl_stan','magazyn_stan',_ktm,1,_mg,,,date(),-2,,,,_dk_c)
         || exec('obl_stan','magazyn_stan',_ktm,1,_mg,,,date(),-2)
         ?};
         _tab.STAN:=BEER.SD;
         _tab.STAN+=exec('zlim_il_rez','zl_nlimit',_tab.ZLIMREF);
         _tab.put();
         _tab.next()
      !}
   ?};
:: Sprawdzenie zgodności ilości ze stanem magazynowym
   {? _tab.first()
   || {!
      |?
         {? _tab.IL>_tab.STAN
         || _res:=_tab.M
         ?};
         _res='' & _tab.next()
      !}
   ?}
?};
_res


\rej_mat_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Usuwa pobrania (rezerwacje) do surowców nielimitowanych.
::       Wywoływana po usunięciu nielimitu z listy zapotrzebowań zlecenia.
::   WE: _a - $ZLIM.ref()
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_pres('_a')=type_of('str') || _a || '' ?};
{? _ref<>''
|| REZ.cntx_psh();
   _rez_mask:=(REZ.name()-2)+'__';
   {? REZ.name()<>_rez_mask || REZ.use(_rez_mask) ?};
   REZ.index('ZLIMA');
   REZ.prefix(_ref,);
   {? REZ.first()
   || {!
      |?
         _ktm:=REZ.M;
         _mg:=REZ.MG;
         _loop:=REZ.del(,1)=2;
         exec('obl_stan','magazyn_stan',_ktm,1,_mg);
         _loop
      !}
   ?};
   REZ.cntx_pop()
?};
~~


\czy_rozliczone_nielimity
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Sprawdza, czy do wszystkich dokumentów raportujących produkcję zostały rozliczone surowce nielimitowane
::   WE: _a - ZL.ref()
::----------------------------------------------------------------------------------------------------------------------
exec('czy_rozliczone_x','zl_nlimit',_a,'NLI')


\czy_rozliczone_odpady
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Sprawdza, czy do wszystkich dokumentów raportujących produkcję zostały rozliczone odpady
::----------------------------------------------------------------------------------------------------------------------
exec('czy_rozliczone_x','zl_nlimit',_a,'ODP')


\czy_rozliczone_x
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [21.14]
:: OPIS: Sprawdza, czy do wszystkich dokumentów raportujących produkcję zostały rozliczone nielimity/odpady
::   WE: _a - ZL.ref()
::       _b - rodzaj rozliczenia: 'NLI', 'ODP'
::   WY: 1-wszytko jest rozliczone, 0-cokolwiek nie jest rozliczone
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_gen:=_b;

_result:=1;

DK.cntx_psh();

_typydok:=exec('typydok_rap','zl_common',_zl);

_names:=DK.names();
{? _names.first()
|| {!
   |? DK.use(_names.NAME);
      DK.index('GENZL');
      {? _typydok.first()
      || {!
         |? DK.prefix(_zl,_typydok.REF);
            {? DK.first()
            || {!
               |? {? exec('FindAndGet','#table',ND,DK.N,,"ND.STAT_REJ='T'",0)
                     & ~exec('rozliczone','zl_limit',DK.N,{? _gen='NLI' || 'N' || 'T' ?})
                  || _result:=0
                  ?};
                  _result>0 & DK.next()
               !}
            ?};
            _result>0 & _typydok.next()
         !}
      ?};
      _result>0 & _names.next()
   !}
?};

DK.cntx_pop();

_result


\nlim_kor
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Akcja Korekta w oknie surowców nielimitowanych
::----------------------------------------------------------------------------------------------------------------------
exec('zlim_kor','zl_limit',#ZLIM.ref())


\sur_show_zam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Wyświetla listę zamienników surowca nielimitowanego podczas rozliczania surowców nielimitowanych.
::   WE: [_a] - INTEGER - miejsce wywołania: 0 - rozliczanie podczas rejestracji wykonania produkcji
::                                          [1] - rozliczanie do zlecenia (do RP lub zarejestrowanych wykonań)
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_where:={? var_pres('_a')=type_of(0) || _a || 1 ?};
{? _where=0
|| {? var_pres('__ENV_REJ')>100
   || _env:=__ENV_REJ;
      _sur:=_env.TAB;
      _zam:=_env.TAB_Z;
      _zlim:=_sur.ZLIMREF
   || FUN.emsg('Błąd wywołania. Nie powołano obiektu do rozliczania surowców nielimitowanych.'@);
      return()
   ?}
|| _env:=params_get().env_gen;
   _dk:=_env.DK.TAB;
   _sur:=_env.SUR.TAB;
   _zam:=_env.ZAM.TAB;
   _zlim:=_sur.ZLIM
?};

_zam.erase();
{? _where=0
|| _zam.index(_env.NDX_Z2)
|| _zam.index(_env.ZAM.NDXMREF)
?};
:: Tworzenie tabeli przechowującej stany wg magazynów
exec('addsmmag','magazyn_stan');

:: Wypełnienie tabeli zamienników
M.cntx_psh();
ZLIM.cntx_psh();
ZLIM.clear();
{? ZLIM.seek(_zlim,8+_zlim,1)
||
:: Zamiennniki technologiczne
   {? ZLIM.TMAT<>null()
   || TMAT.cntx_psh();
      TMAT.clear();
      {? TMAT.seek(ZLIM.TMAT,ref_name(ZLIM.TMAT),1)
      || TCHMAT.cntx_psh();
         TCHMAT.use((6+TCHMAT.name())+(TMAT.name()+2));
         TCHMAT.index('NSGL');
         TCHMAT.prefix(TMAT.NRK,TMAT.ref());

         {? TCHMAT.first()
         || ZL.cntx_psh();
            ZGH.cntx_psh();
            ZGP.cntx_psh();
            TTG.cntx_psh();
            TTGP.cntx_psh();
            ZLIM.ZLEC();
            ZLIM.ZGP().NRZLP();
            _xjm:=1;
            {? ZL.RTKTL<>''
            || _xjm:=exec('FindAndGet','#table',TKTL,ZL.RTKTL,,"XJM",1)
            |? ZL.RKTL<>''
            || _xjm:=exec('FindAndGet','#table',TKTL,ZL.RKTL,,"XJM",1)
            ?};
            {? _where=0
            || _ilosc:=ZLIM.ZGP().ILOSC
            || _ilosc:=_dk.IL
            ?};
            _wsp:=_ilosc/_xjm;

            _tktl:={? ZL.RTKTL<>''
                   || exec('FindAndGet','#table',TKTL,ZL.RTKTL,,,null())
                   || exec('FindAndGet','#table',TKTL,ZL.RKTL,,,null())
                   ?};
            exec('stop_tpar','tech_param');
            tpar:=obj_new(@.CLASS.TPAr);
            tpar.TABLE:=TPAR;
            tpar.INDEX:='NN';
            tpar.PREFIX:=_tktl;
            tpar.KTM:=ZL.KTM;
            tpar.loadp();
            _par:=exec('get','#params',500001,2);
            {!
            |?
               {? TCHMAT.ACT='T'
               ||
                  {? TCHMAT.PT<>null()
                  ||
::                   Pojedynczy surowiec
                     exec('zam_add','zl_nlimit',TCHMAT.PT,'T',_wsp,_where)
                  |? _par='T' | _par='P' & TCHMAT.TGRP().ZAMIENN='T'
                  ||
::                   Grupa technologiczna - wszystkie surowce grupy
                     TTGP.clear();
                     TTGP.index('GS');
                     TTGP.prefix(TCHMAT.TGRP);
                     {? TTGP.first()
                     || {!
                        |?
                           exec('zam_add','zl_nlimit',TTGP.PT,'T',_wsp,_where);
                           TTGP.next()
                        !}
                     ?}
                  ||
::                   Grupa technologiczna - tylko materiał domyślny
                     exec('zam_add','zl_nlimit',TCHMAT.TGDFLT().PT,'T',_wsp,_where)
                  ?}
               ?};
               TCHMAT.next()
            !};
            ZL.cntx_pop();
            ZGH.cntx_pop();
            ZGP.cntx_pop();
            TTG.cntx_pop();
            TTGP.cntx_pop()
         ?};
         TCHMAT.cntx_pop()
      ?};
      TMAT.cntx_pop()
   ?};
:: Zamienniki materiałowe
   MZ.cntx_psh();
   MZ.index('MZ');
   MZ.prefix(ZLIM.KTM);
   {? MZ.first()
   || {!
      |?
         exec('zam_add','zl_nlimit',MZ.MZ,'M',,_where);
         MZ.next()
      !}
   ?};
   MZ.cntx_pop()
?};
ZLIM.cntx_pop();
M.cntx_pop();
{? _zam.first()
|| {? _where=0
   || _zam.index(_env.NDX_Z1)
   || _zam.index(_env.ZAM.NDXKTM)
   ?};
   _a_t:=VAR.A_T;
   _hide:='';
:: W przypadku rozliczania nielimitów do wykonań blokowana akcja Wybierz/Popraw w oknie zamienników
:: dla rekordów powstałych na e-kiosku poprzez zeskanowanie dostawy
   {? _where=1 & _sur.RSC<>''
   || _hide:='WP'
   ?};
   {? _zam.select(,,,_hide)
   ||
::    Tutaj już nic nie jest robione, cała logika (aktualizacja/dodawanie rekordów) wykonywana jest wewnątrz
::    formuł exec('spr_zam','zl_nlimit') lub exec('spr_no_lim','zl_nlimit') uruchamianej po wywołaniu akcji Wybierz
      ~~
   ||
::    Zrezygnowano z wyboru zamiennika, przywrócenie do zmiennej dotychczasowych wartości
      VAR.A_T:=_a_t
   ?}
|| FUN.info('Brak zdefiniowanych zamienników surowca.'@)
?};
~~


\zam_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Dodaje rekordy do listy zamienników na podstawie danego zammiennika technologicznego lub materiałowego.
::       Działa na aktualnym buforze tabeli TCHMAT/MZ oraz tabel DK,SUR,ZAM środowiska exec('env_gen','zl_limit')
::   WE: _a - M.ref() - indeks materiałowy dodawany do zamienników
::       _b - rodzaj zamiennika: 'T' - technologiczny (TCHMAT), 'M' - materiałowy (MZ)
::       [_c] - REAL - współczynnik do przeliczania ilości wg technologii, tylko gdy _b='T'
::       [_d] - INTEGER - miejsce wywołania: 0 - rozliczanie podczas rejestracji wykonania produkcji
::                                          [1] - rozliczanie do zlecenia (do RP lub zarejestrowanych wykonań)
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_where:={? var_pres('_d')=type_of(0) || _d || 1 ?};
{? _where=0
|| {? var_pres('__ENV_REJ')>100
   || _env:=__ENV_REJ;
      _sur:=_env.TAB;
      _zam:=_env.TAB_Z
   || return()
   ?}
|| _env:=params_get().env_gen;
   _dk:=_env.DK.TAB;
   _sur:=_env.SUR.TAB;
   _zam:=_env.ZAM.TAB
?};
_mref:={? var_pres('_a')=type_of(null()) || _a || return() ?};
_typ:={? var_pres('_b')=type_of('') || _b || return() ?};
_wsp:={? var_pres('_c')=type_of(0) || _c || 0 ?};

M.cntx_psh();
M.clear();
{? M.seek(_mref)
||
:: Sprawdzenie, czy materiał został już dodany do tabeli zamienników
   _zam.cntx_psh();
   {? ~_zam.find_key($M.ref())
   || _zam.KTM:=M.KTM;
      _zam.NAZ:=M.N;
      _zam.MREF:=$M.ref();
      _zam.JM:=M.J().KOD;
      {? _typ='T'
      || _zam.GRP:={? TCHMAT.TGRP<>null() || TCHMAT.TGRP().GR || '' ?};
         {? _zam.GRP<>''
         || _zam.TYP:='Grupy technologicznej'
         || _zam.TYP:='Technologiczny'
         ?};
::       Wyznaczenie ilości wg norm zamiennika technologicznego
         _dokl:=exec('jaka_dok_m','jm',M.ref());
         {? _dokl>0
         || _rm:=roundmet();
            roundmet(2);
            {? TCHMAT.FORMB<>''
            || _lil:=(tpar.calc(TCHMAT.FORMB)*_wsp)$_dokl
            || _lil:=TCHMAT.WARB*_wsp
            ?};
            roundmet(_rm)
         || {? TCHMAT.FORMB<>''
            || _il_raw:=tpar.calc(TCHMAT.FORMB)*_wsp;
               _lil:=exec('ceil','#math',_il_raw)
            || _il_raw:=TCHMAT.WARB*_wsp;
               _lil:=exec('ceil','#math',_il_raw)
            ?}
         ?};
         _il:={? _dokl>0
              || (_lil)$ _dokl
              || ceil(_lil)
              ?};
         {? _where=0
         || _zam.ILOSC:=_sur.IL;
            _zam.LIL:=_il
         || _zam.ILOSC:=_il
::            _zam.LIL:=_sur.ILOSC*_sur.ZGH_IL/_sur.RAP_IL
         ?}
      |? _typ='M'
      || _zam.TYP:='Materiałowy';
         _zam.GRP:='';
         {? _where=0
         || _zam.ILOSC:=_sur.IL;
            _zam.LIL:=_sur.LIL
         || _zam.ILOSC:=_sur.ILOSC
::            _zam.LIL:=_sur.ILOSC*_sur.ZGH_IL/_sur.RAP_IL
         ?}
      ?};
::    Wyliczenie stanu na poszczególnych magazynach
      exec('zwr_stan','magazyn_stan',M.ref(),5,null(),1,,1);

      _add:=0;
::    Dodanie rekordów w rozbiciu na magazyny (tworzone wyłącznie rekordy dla magazynów z dodatnim stanem)
      {? __smmag.first()
      || {!
         |?
            {? __smmag.STAN>0
            ||
               _koop:=exec('FindAndGet','#table',MG,__smmag.RSQL,,"MG.KOOP",'');
               {? _koop<>'T'
               || _zam.SD:=__smmag.STAN;
                  _zam.MAGSYM:=__smmag.MAG;
                  _zam.MAG:=__smmag.RSQL;
                  {? _zam.add()
                  || _add:=1
                  ?}
               ?}
            ?};
            __smmag.next()
         !}
      ?};
::    Jeżeli brak dostępnego stanu surowca na wszystkich magazynach to tworzony 1 rekord z zerowym stanem i
::    magazynem zgodnym z redagowanym surowcem
      {? _add=0
      || _zam.SD:=0;
         {? _where=0
         || _zam.MAG:=_sur.MGREF;
            _zam.MAGSYM:=_sur.MG
         || _zam.MAGSYM:=_sur.MAGSYM;
            _zam.MAG:=exec('FindAndGet','#table',MG,_sur.MAG,,"$MG.ref()",'')
         ?};
         _zam.add()
      ?}
   ?};
   _zam.cntx_pop()
?};
M.cntx_pop();
~~


\spr_zam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdzenie czy dodawany surowiec (zamiennik) znajduje się na liście (nie)limitów zlecenia/odpad.
::       Kontrolowane jest przypisanie do konkretnej pozycji przewodnika zlecenia.
::       Kontekst wywołania: ustawiony bufor tabeli __ENV_REJ.TAB,__ENV_REJ.TAB_Z
::   WY: 0 - nie udało się podmienić zamiennika / 1 - udało się zmienić surowiec na zamiennik
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__ENV_REJ')>100
|| _env:=__ENV_REJ;
   _tab:=_env.TAB;
   _zam:=_env.TAB_Z
|| return(0)
?};

_valid:='';
:: Podstawowa walidacja (taka sama jak po redakcji rekordu)
_valid:=exec('zam_valid','zl_nlimit',_zam,0);
:: Dodatkowa walidacja
{? _valid=''
|| _tab.cntx_psh();
   {? _tab.find_tab(,'MREF',,'=',_zam.MREF,'MGREF',,'=',_zam.MAG)
   || FUN.info('Na liście surowców do pobrania znajduje się już zapis dotyczący materiału \'%1\' i magazynu \'%2\'.'@
               [_zam.KTM,_zam.MAGSYM]);
      _valid:=0
   ?};
   _tab.cntx_pop()
?};
{? (type_of(_valid)=type_of('') & _valid<>'') | (type_of(_valid)=type_of(0) & _valid=0)
|| return(0)
?};

M.cntx_psh();
ZL.cntx_psh();
ZLIM.cntx_psh();
VAR.cntx_psh();
ZL.clear();

:: Wyszukuje zlecenie
VAR.A_ZLEC:=exec('FindAndGet','#table',ZL,_tab.ZLREF,ZL.name(),,null());
exec('openmask','zl_common',VAR.A_ZLEC);
:: Wyszukanie operacji, do któej przypisywane są zapotrzebowania
_zgp:=exec('FindAndGet','#table',ZLIM,_tab.ZLIMREF,,"ZLIM.ZGP",null());
::VAR.A_T:=exec('FindAndGet','#table',M,_zam.MREF,,,null());

_res:=0;

ZLIM.index('ZGP_KM');
{? ZLIM.prefix(_zgp,'T',0,VAR.A_T);
   ZLIM.first()
|| FUN.info(
      'Materiał o indeksie: %1 występuje już na liście limitów dla pozycji przewodnika: %2.'@
      [VAR.A_T().KTM,exec('record','#to_string',_zgp)]
   )
|? ZLIM.prefix(_zgp,'N',0,VAR.A_T);
   ZLIM.first()
|| {? ZLIM.ROZ<>'T'
   || FUN.info(
         'Materiał o indeksie: %1 występuje już jako surowiec nielimitowany rozliczany do dokumnetów '
         'raportujących produkcję dla pozycji przewodnika: %2.'@
         [VAR.A_T().KTM,exec('record','#to_string',_zgp)]
      )
   ||
::    Jest już ZLIM do danego materiału, który jest rozliczany z operacją
      _tab.KTM:=ZLIM.KTM().KTM;
      _tab.M:=ZLIM.KTM().N;
      _tab.JM:=ZLIM.KTM().J().KOD;
      _tab.LIL:=ZLIM.LIL;
      _tab.MG:=_zam.MAGSYM;
      _tab.MGREF:=_zam.MAG;
      _tab.MREF:=$ZLIM.KTM;
      _tab.TMATREF:=$ZLIM.TMAT;
      _tab.ZLIMREF:=$ZLIM.ref();
      _tab.ZLREF:=$ZLIM.ZLEC;
      _tab.DKCREF:={? ZLIM.DK_C<>null || $ZLIM.DK_C || '' ?};

      _mg:=exec('FindAndGet','#table',MG,_zam.MAG,,,null());
::    Sprawdzam dostępny stan magazynowy dla podanej pozycji
      {? ZLIM.DK_C<>null()
      || exec('obl_stan','magazyn_stan',ZLIM.KTM,1,_mg,,,date(),-2,,,,ZLIM.DK_C)
      || exec('obl_stan','magazyn_stan',ZLIM.KTM,1,_mg,,,date(),-2)
      ?};
      _tab.STAN:=BEER.SD;
      _tab.STAN+=exec('zlim_il_rez','zl_nlimit',_tab.ZLIMREF);
      _tab.IL:=_zam.ILOSC;
::    Dodatkowe sprawdzenie stanu - jeżeli ZLIM ma przypisaną cechę to spradzenie stanu pod daną cechę
      {? ZLIM.DK_C=null() | (ZLIM.DK_C<>null() & _tab.IL<=_tab.STAN)
      || _res:=_tab.put()
      || FUN.info('W wybranym magazynie nie ma wystarczającej ilości surowca o danej cesze dostawy '
                  '(aktualny stan: %1).\n'
                  'Należy wskazać inny magazyn lub zmniejszyć ilość rozliczanego surowca.'@[$_tab.STAN])
      ?}
   ?}
||
:: Nie ma ZLIM-a powiązanego z wybranym materiałem, pytanie czy utworzyć
   _dokl:=VAR.A_T().DOKL;
   {? FUN.ask(
         'Wskazanego surowca (%1) nie ma na zapotrzebowaniu do pozycji przewodnika zlecenia.'@[VAR.A_T().KTM]+
         '\n\n'+
         'Czy dodać surowiec do listy zapotrzebowań na %1 %2?'@
         [form(_zam.LIL,,_dokl,'.,'),VAR.A_T().J().KOD]
      )
   || ZLIM.blank();
      ZLIM.LIMIT:='N';
      ZLIM.AUTO:='N';
      ZLIM.ZLEC:=VAR.A_ZLEC;
      ZLIM.TMAT:=null();
      ZLIM.KTM:=VAR.A_T;
      ZLIM.PFAZ:=null();
      ZLIM.WYD:=VAR.A_ZLEC().JORG;
      ZLIM.MG:=exec('FindAndGet','#table',MG,_zam.MAG,,,null());
      ZLIM.LIL:=_zam.LIL;
      ZLIM.SO:='S';
      ZLIM.NR:=exec('bl_nlrlim','zl_limit');
      ZLIM.PARTIA:='N';
      ZLIM.ZGP:=_zgp;
      _dt:=exec('datetime','zl_limit',ZLIM.ZGP);
      ZLIM.STARTD:=_dt.DATE;
      ZLIM.STARTT:=_dt.TIME;
      ZLIM.ROZ:='T';
      obj_del(_dt);

      {? ZLIM.add()
      || _tab.LIL:=ZLIM.LIL;
         _tab.MREF:=$ZLIM.KTM;
         _tab.TMATREF:='';
         _tab.ZLIMREF:=$ZLIM.ref();
         _tab.ZLREF:=$ZLIM.ZLEC;
         _tab.DKCREF:='';
         _tab.KTM:=ZLIM.KTM().KTM;
         _tab.M:=ZLIM.KTM().N;
         _tab.JM:=ZLIM.KTM().J().KOD;
         _tab.MG:=_zam.MAGSYM;
         _tab.MGREF:=_zam.MAG;
         _tab.STAN:=_zam.SD;
         _tab.IL:=_zam.ILOSC;
         _res:=_tab.put()
      || FUN.emsg('Nie udało się dodać zapotrzebowania.'@)
      ?}
   ?}
?};
ZLIM.cntx_pop();
ZL.cntx_pop();
M.cntx_pop();
VAR.cntx_pop();
_res


\zam_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Walidacja dla rekordu w tabeli zamienników surowca (podczas rozliczania surowców nielimitowanych)
::   WE: _a - uchwyt do tabeli zamienników
::       [_b] - miejsce wywołania: [1] - rozliczanie do zarejestrowanych RP/wykonań,
::                                  0 - rozliczanie podczas rejestracji wykonania produkcji
::   WY: '' lub akronim pola, do redakcji którego należy powrócić
::---------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_where:={? var_pres('_b')=type_of(0) || _b || 1 ?};

_res:='';
{? _where=0 & _tab.LIL<0
|| FUN.info('Należy podać wartość większą od zera.'@);
   _res:='LIL'
|? _tab.ILOSC<0
|| FUN.info('Należy podać wartość większą od zera.'@);
   _res:='ILOSC'
|? _where=0 & _tab.LIL=0
|| FUN.info('Norma brutto musi być określona.'@);
   _res:='LIL'
|? _tab.ILOSC=0
|| FUN.info('Ilość musi być określona.'@);
   _res:='ILOSC'
::|? _where=0 & _tab.LIL<_tab.ILOSC
::|| FUN.info('Norma brutto nie może być mniejsza od ilości pobranej.'@);
::   _res:='LIL'
|? _where=0 & _tab.ILOSC>_tab.SD
|| FUN.info('W wybranym magazynie nie ma wystarczającej ilości surowca.\n'
            'Należy wskazać inny magazyn lub zmniejszyć ilość rozliczanego surowca.'@);
   _res:='ILOSC'
?};
_res


\zlim_il_rez
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Zwraca ilość, na jaką zdefiniowane są dedykowane rezerwacje dla surowców nielimitowanych
::   WE: _a - $ZLIM.ref()
::   WY: zarezerwowana ilość
::----------------------------------------------------------------------------------------------------------------------
_zlim:={? var_pres('_a')=type_of('') || _a || '' ?};
_result:=0;
{? _zlim<>''
|| ZLIM.cntx_psh();
   _mask:=ref_name(_zlim);
   {? _mask<>ZLIM.name() || ZLIM.use(_mask) ?};
   ZLIM.clear();
   {? ZLIM.seek(_zlim)
   || REZ.cntx_psh();
      REZ.use((REZ.name()-2)+'__');
      REZ.index('ZLMREZ2');
      REZ.prefix(ZLIM.ZLEC,'S','B',ZLIM.KTM,'P',$ZLIM.ref(),);
      {? REZ.first()
      || {!
         |?
            _result+=REZ.ILR;
            REZ.next()
         !}
      ?};
      REZ.cntx_pop()
   ?};
   ZLIM.cntx_pop()
?};
_result


\tab_rez_fill
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Wypełnia tabelę z rezerwacjami o ilościach zarezerwowanych do poszczególnych dostawach
::       (rezerwacje dedykowane do nielimitów)
::   WE: _a - tabela tymczasowa z listą zarezerwowanych ilości pod konkretne dostawy
::       _b - ZL.ref()
::       _c - M.ref()
::----------------------------------------------------------------------------------------------------------------------
_tab_rez:={? var_press('_a')>100 || _a || return() ?};
_zl:={? var_pres('_b')=type_of(null()) || _b || return() ?};
_ktm:={? var_pres('_c')=type_of(null()) || _c || return() ?};
REZ.cntx_psh();
_rez_mask:=(REZ.name()-2)+'__';
{? REZ.name()<>_rez_mask || REZ.use(_rez_mask) ?};
REZ.index('ZLMREZ');
REZ.prefix(_zl,'S','B',_ktm,'P');
{? REZ.first()
|| SC.cntx_psh();
   _msk:=SC.name()-2;
   {!
   |?
      {? REZ.SC<>'' & 'dokma'=(5+REZ.SC)
      || SC.use(_msk+(form(8+REZ.SC)+2));
         SC.index('SRDK');
         SC.prefix(REZ.SC,REZ.SC);
         {? SC.first()
         || {? _tab_rez.find_key($SC.ref(),'D',REZ.ZLIM)
            || _tab_rez.ILR+=REZ.ILR;
               _tab_rez.put()
            || _tab_rez.REF:=$SC.ref();
               _tab_rez.ILR+=REZ.ILR;
               _tab_rez.MREF:=$REZ.M;
               _tab_rez.ZLREF:=$REZ.ZL;
               _tab_rez.SRDK:=REZ.SC;
               _tab_rez.TYP:='D';
               _tab_rez.ZLIM:=REZ.ZLIM;
               _tab_rez.SCEAN:=SC.SCEAN;
::               _tab_rez.KODPAL:=REZ.KODPAL;
               _tab_rez.add()
            ?}
         ?}
      ?};
      REZ.next()
   !};
   SC.cntx_pop()
?};
REZ.cntx_pop();
~~


\tab_rez_create
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Tworzy tabelę z rezerwacjami o ilościach zarezerwowanych do poszczególnych dostawach
::   WY: utworzona tabela tymczasowa
::----------------------------------------------------------------------------------------------------------------------
_tab_rez:=tab_tmp(3,
   'REF','STRING[16]','Ref dostawy',
   'TYP','STRING[1]','R(Rezerwacja do robocizny), D(dedykowana rez)',
   'ZLIM','STRING[16]','$ZLIM.ref()',
   'ILR','REAL','Ilość zarezerwowana (aktualny stan)',
   'MREF','STRING[16]','Ref materiału',
   'SRDK','STRING[16]','srdk',
   'ZLREF','STRING[16]','Ref zlecenia',
   'SCEAN','STRING[128]','Kod dostawy'
::   'KODPAL','STRING[30]','Kod palety'
);
_tab_rez


\update_rezerwacje
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Przepina dedykowane rezerwacje nielimitów do pozycji dokumentu rozchodowego RW.
::       Praca na aktualnym rekordzie DK
::   WE: _a - ref dokumentu dostawy w postaci SQL (SC.SRDK) - gdy '' to przetwarzane rezerwacje bez przypisanej dostawy
::       _b - ilość do rozpisania
::       [_c] - ref elementu, na podstawie którego wygenerowany został dokument ($ZLGD.ref(), $ZGP.ref, $ND.ref())
::   WY: REAL - Ilość, jaka została rozpisana (przepięta) na rezerwacjach
::----------------------------------------------------------------------------------------------------------------------
_srdk:={? var_pres('_a')=type_of('') || _a || return(0) ?};
_il_start:=_dorozp:=_b;
_src_ref:={? var_pres('_c')=type_of('') || _c || '' ?};
_where:={? _src_ref*'zlgd' || 2 |? _src_ref*'zguidep' || 1 || 0 ?};
_res:=0;
REZ.cntx_psh();
_rez_mask:=(REZ.name()-2)+'__';
{? REZ.name()<>_rez_mask || REZ.use(_rez_mask) ?};
REZ.index('ZLMREZ2');
:: W pierwszej kolejności przetwarzane rezerwacje pod robociznę
REZ.prefix(DK.ZL,'S','B',DK.M,'R',$DK.ZLIM);
{? REZ.first()
|| {!
   |?
      {? (_where=0 | _where=1 & REZ.ZGP=_src_ref & REZ.BTERM='T' | _where=2 & REZ.REFREA=_src_ref)
         & ((_srdk='' & REZ.SC=_srdk) | (_srdk<>'' & REZ.SC=_srdk & 'dokma'=(5+REZ.SC)))
      || _ilr:={? _dorozp>REZ.ILR || REZ.ILR || _dorozp ?};
         {? exec('zrez_tym','rezerwacje','M',REZ.ref(),_ilr,,DK.ref())
         || _dorozp-=_ilr
         ?}
      ?};
      _dorozp>0 & REZ.next()
   !}
?};
:: Jeżeli jest jeszcze coś do ropzisania to sprawdzane rezerwacje pod nielimity
{? _dorozp>0
|| REZ.prefix(DK.ZL,'S','B',DK.M,'P',$DK.ZLIM);
   {? REZ.first()
   || {!
      |?
         {? (_srdk='' & REZ.SC=_srdk) | (_srdk<>'' & REZ.SC=_srdk & 'dokma'=(5+REZ.SC))
         || _ilr:={? _dorozp>REZ.ILR || REZ.ILR || _dorozp ?};
            {? exec('zrez_tym','rezerwacje','M',REZ.ref(),_ilr,,DK.ref())
            || _dorozp-=_ilr
            ?}
         ?};
         _dorozp>0 & REZ.next()
      !}
   ?}
?};
REZ.cntx_pop();
_res:=_il_start-_dorozp;
_res


\sc_il_rez
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Zwraca łączną ilość zarezerwowaną dla dostawy z dedykowanych rezerwacji dla surowców nielimitowanych
::   WE: _a - SC.SRDK (jak '', to zliczane rezerwacje bez przypisanej dostawy)
::       _b - $ZLIM.ref()
::       [_c] - MG.ref() - magazyn, dla którego sprawdzać rezerwacje. Wymagany, gdy _a=''
::   WY: Łączna ilość zarezerwowana
::----------------------------------------------------------------------------------------------------------------------
_srdk:={? var_pres('_a')=type_of('') || _a || return(0) ?};
_zlim:={? var_pres('_b')=type_of('') || _b || return(0) ?};
_mg:={? var_pres('_c')=type_of(null()) || _c || null() ?};
{? _zlim<>''
|| ZLIM.cntx_psh();
   ZLIM.clear();
   _mask:=ref_name(_zlim);
   {? _mask<>ZLIM.name() || ZLIM.use(_mask) ?};
   {? ZLIM.seek(_zlim)
   || _zl:=ZLIM.ZLEC;
      _ktm:=ZLIM.KTM;
      _ilr:=0;
      REZ.cntx_psh();
      _rez_mask:=(REZ.name()-2)+'__';
      {? REZ.name()<>_rez_mask || REZ.use(_rez_mask) ?};
      REZ.index('ZLMREZ2');
      REZ.prefix(_zl,'S','B',_ktm,'P',$ZLIM.ref(),);
      {? REZ.first()
      || {!
         |?
            {? ((_srdk='' & REZ.SC=_srdk & REZ.MG=_mg) | (_srdk<>'' & REZ.SC=_srdk & 'dokma'=(5+REZ.SC)))
            || _ilr+=REZ.ILR
            ?};
            REZ.next()
         !}
      ?};
      REZ.cntx_pop()
   ?};
   ZLIM.cntx_pop()
?};
_ilr


\nlim_sel_rez
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Przeglad rezerwacji tymczasowych dla podanego materialu (surowaca nielimitowanego)
::   WE: [_a] - $ZLIM.ref() - jak nie podany to pobierany z aktualnego bufora
::----------------------------------------------------------------------------------------------------------------------
_zlim:={? var_pres('_a')=type_of('') || _a || $ZLIM.ref() ?};
{? _zlim<>''
||
   ZLIM.cntx_psh();
   _mask:=ref_name(_zlim);
   {? _mask<>ZLIM.name() || ZLIM.use(_mask) ?};
   ZLIM.clear();
   {? ZLIM.seek(_zlim)
   || exec('rozpirez','rezerwacje',,1);
      ~~
   ?};
   ZLIM.cntx_pop()
?};
~~


\is_rej_mat
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, czy do surowca nielimitowanego (ZLIM) istnieje rezerwacja do surowca, na podsatwie której
::       nie utworzono jeszcze dokumentu rozchodowego
::   WE: _a - $ZLIM.ref()
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_ref:={? var_pres('_a')=type_of('str') || _a || '' ?};
_res:=0;
{? _ref<>''
|| REZ.cntx_psh();
   _rez_mask:=(REZ.name()-2)+'__';
   {? REZ.name()<>_rez_mask || REZ.use(_rez_mask) ?};
   _zl:=exec('FindAndGet','#table',ZLIM,_ref,,"ZLIM.ZLEC",null());
   REZ.index('ZLREZR');
   REZ.prefix(_zl,'S','R');
   {? REZ.find_tab('first','ZLIM',,'=',_ref)
   || _res:=1
   ?};
   REZ.cntx_pop()
?};
_res


\icon_zam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Ikonka dla zamienników surowca limitowanego/nielimitowanego
::   WY: ikonka
::----------------------------------------------------------------------------------------------------------------------
_icon:=exec('pusta','#icon');
_tab:=cur_tab(1,1);
_rtmat:=_tab.RTMAT;
{? _rtmat<>''
|| {? exec('tmat_has_zam','tech_mater',_rtmat)>0
   || _icon:='xwin16.png:92'
   ?}
?};
_icon


\sur_cecha_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Przed redakcją pola ATR.SUR_DKC - redagowanie cechy surowca podczas rozliczania odpadów
::----------------------------------------------------------------------------------------------------------------------
_sur:=cur_tab(1,1);
ATR.MJS:='ZLIM';
_mat:={? ATR.MJS<>'' || exec('acr2acr','mat_atr') || 'M' ?};

ATR.FLAG_TEX:=0;
_result:=0;
_atr:=($(ATR.MJS+'.'+_mat+'().M_ATR'))( );
{? _atr<>null()
   & {? exec('rozm_atr','mat_atr',_atr)=1 || ($(ATR.MJS+'.'+_mat+'().M_ATR().SL_01().TYP'))()<>'P' || 1 ?}
|| _result:=1;
   exec('dk_atr_dict','mat_atr');
   ZLIM.DK_C:=ATR.SUR_DKC;
   ~~
?};
{? _result || _result:=ATR.FLAG_ED<>2 ?};
_result


\sur_cecha_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Po redakcji pola ATR.SUR_DKC - redagowanie cechy surowca podczas rozliczania odpadów
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
_sur:=cur_tab(1,1);
_aft_atr:=exec('buffer','mat_atr');
_aft_atr.get_dkc();

{? _result>0
||
:: Sprawdzam czy atrybut zawiera partie - jeśli tak to ponawiam redagowanie
:: Partia musi być zgodna z dokumentem RP, do którego rozliczany jest odpad (nie ma sensu przpisanie cechy z partią)
   {? ATR.SUR_DKC<>null() & _aft_atr.has_part()>0
   || FUN.emsg('Cecha surowca nie może zawierać wartości typu: \'Partia\'.'@);
      _result:=0
   ?}
?};

ATR.FLAG_TEX:=0;
{? ATR.SUR_DKC<>null() & ATR.SUR_DKC().M_ATR<>null()
|| {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():=($('ATR.SUR_DKC().WAR'+form(_i,-2,,'99')))() !}
|| {! _i:=1..10 |! ($('ATR.WAR'+form(_i,-2,,'99')))():='' !}
?};
ZLIM.DK_C:=ATR.SUR_DKC;
:: Partie na zleceniu
_zl:=exec('FindAndGet','#table',ZL,_sur.ZL_REF,,,null());
{? exec('zlec_party','zl_common',_zl)>0
||
:: Ustawiam wartosc zmiennej ATR na symbol partii
   exec('atr_set_partia','mat_atr',ATR.M_ATR,ATR.ZPARN_DK().SYM)
?};
win_disp();
_result


\sur_cecha_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Przed wyświetleniem pola ATR.SUR_DKC - redagowanie cechy surowca podczas rozliczania odpadów
::----------------------------------------------------------------------------------------------------------------------
ATR.SUR_DKC:=ZLIM.DK_C;
~~


\sur_all
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Surowce do zlecenia (limity i nielimity)
::   WE: [_a] - ZL.ref()
::       [_b] - ZGH.ref()
::       [_c] - ZGP.ref()
::       [_d] - INTEGER - [0] redakcja / 1 - tylko podgląd
::       [_e] - GROP.ref()
::       Uwaga: _a albo _e musi być podane
::   WY: wynik .select()
::----------------------------------------------------------------------------------------------------------------------
_zl:={? var_pres('_a')=type_of(ZL.ref()) || _a || null() ?};
_zgh_ref:={? var_pres('_b')=type_of(ZGH.ref()) || _b || null() ?};
_zgp_ref:={? var_pres('_c')=type_of(ZGP.ref()) || _c || null() ?};
_view:={? var_pres('_d')=type_of(0) || _d || 0 ?};
_grop:={? var_pres('_e')=type_of(GROP.ref()) || _e || null() ?};

{? _zl=null() & _grop=null() || return() ?};

_res:=0;
_ok:=1;

ZL.cntx_psh();
GROP.cntx_psh();
VAR.cntx_psh();
VAR.A_ZLEC:=_zl;
VAR.A_GROP:=_grop;
_wp:={? _grop<>null() || 'P' || VAR.A_ZLEC().TYP().WP ?};
_env:=obj_new('env_limit','ZL','GROP');
_env_limit:=exec('env_limit','zl_limit',1);
_env.env_limit:=_env_limit;
_env.ZL:=_zl;
_env.GROP:=_grop;
_lim:=exec('kart_lim','zl_limit',9,_zl,'T',_zgh_ref,_zgp_ref,_wp,,_env_limit,_grop);
_ok:=var_pres('_lim')>100;

{? _ok>0
||
   _env.env_limit.used:=_view;
   _ZLIMp:=_env_limit.ZLIMp;
   _ZLIM:=_ZLIMp.ZLIM;
   _wer_lim:={? _wp='P' || _ZLIMp.WERP || _ZLIMp.WERW ?};
   params_set('env',_env);

   VAR.A_NRZLP:=null();
   VAR.A_ZGP:=null();
   exec('openmask','zl_common',VAR.A_ZLEC,VAR.A_GROP);
   {? VAR.A_ZLEC().RTKTL<>''
   || VAR.A_KTL:=exec('FindAndGet','#table',TKTL,VAR.A_ZLEC().RTKTL,,"ref()",null())
   || VAR.A_KTL:=exec('FindAndGet','#table',TKTL,VAR.A_ZLEC().RKTL,,"ref()",null())
   ?};
   exec('s_nlim','zl_common');
   ZLIM.cntx_psh();
   ST.cntx_psh();
::   VAR.P_NKTM:='';

   _sufix:='';
   {? _view || _sufix:=' — '+'PODGLĄD'@ ?};
:: Podczytanie danych przewodnika i jego pozycji - do wyświetlenia w tytule okna
   _head:=
      {? VAR.A_GROP=null()
      || ' — zlecenie '+VAR.A_ZLEC().SYM
      || ' — grupa operacji '+VAR.A_GROP().KOD
      ?};
   ZGH.cntx_psh(); ZGP.cntx_psh();
   ZGH.clear(); ZGP.clear();
   {? _zgh_ref<>null()
   || {? ZGH.seek(_zgh_ref)
      || _head:=' — '+'przewodnik %1'@[ZGH.NRPRZ];
         {? VAR.A_ZLEC().RODZAJ='P' || VAR.A_NRZLP:=ZGH.ref() ?}
      ?}
   ?};
   {? _zgp_ref<>null()
   || {? ZGP.seek(_zgp_ref)
      || _head:=' — '+'przewodnik %1 poz. %2'@[ZGP.NRZLP().NRPRZ,$ZGP.NRP];
         VAR.A_ZGP:=ZGP.ref();
         VAR.A_NRZLP:=ZGP.NRZLP
      ?}
   ?};
   ZGH.cntx_pop(); ZGP.cntx_pop();

:: Tworzenie okna grupowego
   _fb:="
      _p8504:=params_get().env.env_limit.p8504;
      _ZLIMp:=params_get().env.env_limit.ZLIMp;
      _WER:={? _ZLIMp.WP='P' || _ZLIMp.WERP || _ZLIMp.WERW ?};
      {? _p8504='T'
      || _ZLIMp.ZLIM.tr_set(1,_WER,1,0)
      || _ZLIMp.ZLIM.tr_set(0,_WER,1,0)
      ?};
      ~~
   ";
   _grp:=ZLIM.grp_make('Surowce '@+_head+_sufix,_fb,'#_all_sur_grp',,,,,'html_maximized');
:: Okno z limitami
   {? _wp='P'
   || _after_refresh:="
         params_set(params_get());
         exec('__ZLIM_actions','zl_limit');
         exec('nlim_all_load','zl_nlimit',VAR.A_ZLEC,VAR.A_NRZLP,VAR.A_ZGP,VAR.A_GROP);
         grp_disp(ZLIM,'WERNL',1,1)
      "
   || _after_refresh:="
         params_set(params_get());
         exec('__ZLIM_actions','zl_limit')
      "
   ?};
   _fb:="";
   _fa:="";
   ZLIM.grp_sel(_grp,_ZLIM,_wer_lim,,_after_refresh,,,10,_fb,_fa,,,'maximized_with_title');

:: Okno z nielimitami
   {? _wp='P'
   || ZLIM.grp_splt(_grp,'','horizontal','tab1');
      _after_refresh:="params_exec('__NLIM_actions','zl_nlimit')";
      _fb:="exec('nlim_all_load','zl_nlimit',VAR.A_ZLEC,VAR.A_NRZLP,VAR.A_ZGP,VAR.A_GROP)";
      _fa:="";
      ZLIM.grp_sel(_grp,,'WERNL',,_after_refresh,,,,_fb,_fa,,,'maximized_with_title');
      ZLIM.win_fml('WERNL',,'KTM','KTM','ICON_BEFORE',"exec('icon_zam','zl_nlimit')")
   ?};
   ZLIM.win_sel(_grp);

   _res:=ZLIM.select();
   ZLIM.f_clear();
   ZLIM.cntx_pop();
   ST.cntx_pop()
?};

:: Oznaczenie zlecenia jako 'Ulepszenie'
{? _view=0
|| _formula:="
      _improve:=ZL.IMPROVE;
      {? exec('is_improvement','zl_head',ZL.ref())
      || ZL.IMPROVE:='T'
      || ZL.IMPROVE:='N'
      ?};
      {? _improve<>ZL.IMPROVE || ZL.put() ?}
   ";
   exec('FindAndGet','#table',ZL,VAR.A_ZLEC,,_formula,~~)
?};
ZL.cntx_pop();
GROP.cntx_pop();
VAR.cntx_pop();
_res


\nlim_all_load
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: "Zasilenie" okna tabeli ZLIM - ustawienie odpowiedniego prefixu/filtru dla okien z surowcami nielimitowanymi
::       lub wszystkimi surowcami zlecenia/przewodnika/grupy operacji
::   WE: _a - ZL.ref()
::       [_b] - ZGH.ref()
::       [_c] - ZGP.ref()
::       [_d] - GROP.ref()
::----------------------------------------------------------------------------------------------------------------------
_zl:={? var_pres('_a')=type_of(ZL.ref()) || _a || return() ?};
_zgh_ref:={? var_pres('_b')=type_of(ZGH.ref()) || _b || null() ?};
_zgp_ref:={? var_pres('_c')=type_of(ZGP.ref()) || _c || null()  ?};
_grop:={? var_pres('_d')=type_of(GROP.ref()) || _d || null() ?};
{? _grop<>null()
|| ZLIM.index('GROPKM');
   ZLIM.prefix(_grop,'N')
|? _zgp_ref<>null()
|| ZLIM.index('ZGP_KM');
   ZLIM.prefix(_zgp_ref,'N')
|? _zgh_ref<>null()
|| ZLIM.prefix();
   ZLIM.f_set(
      'KTM(KTM)',
      'join ZGP using(ZLIM.ZGP,ZGP.REFERENCE)',
      'ZLIM.LIMIT=\'N\' and (ZGP.NRZLP=:_a or ZGP.NRPRZ=:_a)',
      _zgh_ref
   )
|? exec('FindAndGet','#table',ZL,_zl,,"ZL.RODZAJ",'P')='P'
|| ZLIM.index('ZN');
   ZLIM.prefix(VAR.A_ZLEC,'N')
|| ZLIM.index('ZPN');
   ZLIM.prefix(VAR.A_ZLEC,'N')
?};
~~


\zgh_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Wyświetla surowce do przewodnika (limity i nielimity)
::   WE: [_a] - ZGH.ref() - gdy brak, to aktualny
::   WY: czy w oknie zakończono rejestrację (1), czy nie (0)
::----------------------------------------------------------------------------------------------------------------------
_zgh:={? _>0 & type_of(_a)=type_of(ZGH.ref()) || _a || ZGH.ref() ?};

_res:=0;

ZGH.cntx_psh();
ZGH.clear();
{? _zgh<>null() & ZGH.seek(_zgh)
|| _res:=exec('sur_all','zl_nlimit',ZGH.ZLEC,ZGH.ref())
?};
ZGH.cntx_pop();
_res


\action_zgp_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Rejestrowanie zapotrzebowań do zlecenia - akcja 'Zapotrzebowania' do pozycji przewodnika zlecenia
::----------------------------------------------------------------------------------------------------------------------
_zl:=exec('FindAndGet','#table',ZGH,ZGP.NRZLP,,"ZLEC",null());

{? exec('FindAndGet','#table',ZL,_zl,,"STAN",'')='Z'
|| exec('zgp_sur','zl_nlimit',ZGP.ref(),,'T')
|| {? exec('zl_lock','zl_common',_zl,'L')
   || _args:=exec('mp_run_a','#b__box');
      _args.ACT_UID:='TTE_PZL_DLIM';
      _args.UIDREF:=exec('FindAndGet','#table',ZGH,ZGP.NRZLP,,"uidref()",'');
      _args.AKCJA:='ZGP_SUROWCE';
      _args.CONTEXT:=obj_new('ZGP'); _args.CONTEXT.ZGP:=ZGP.ref();
      _args.PORTS_IN:=exec('portsIn','#b__box',_args.ACT_UID);
      exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZL',_zl);
      exec('portsInSet','#b__box',_args.PORTS_IN,_args.ACT_UID,'ZGH',ZGP.NRZLP);

      exec('mp_run','#b__box',_args)
   ?};
   exec('zl_unlock','zl_common',_zl,'L')
?};
''


\zgp_sur
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Wyświetla surowce do pozycji przewodnika (limity i nielimity)
::   WE: [_a] - ZGP.ref() - gdy brak, to aktualny
::   WY: czy w oknie zakończono rejestrację (1), czy nie (0)
::----------------------------------------------------------------------------------------------------------------------
_zgp:={? var_pres('_a')=type_of(ZGP.ref()) || _a || ZGP.ref() ?};

_res:=0;

ZGP.cntx_psh();
ZGP.clear();
{? _zgp<>null() & ZGP.seek(_zgp)
|| _res:=exec('sur_all','zl_nlimit',ZGP.NRZLP().ZLEC,ZGP.NRZLP,ZGP.ref())
?};
ZGP.cntx_pop();
_res


\slo_m4zam
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Tworzy i ustawia okno grupowe dla materiałów podczas przeprowadzania korekty na zamiennik
::----------------------------------------------------------------------------------------------------------------------
_grp:=M.grp_make('Materiały'@,,'slo_m4zam',,,,,'normal');
::_is_zamm:=exec('czy_zam','material',VAR.A_TOW);
::_is_zamt:=exec('tmat_has_zam','tech_mater',$VAR.A_TMAT);
_par:=exec('get','#params',8507,2,OPERATOR.USER);
_is_zamt:=(1+_par)='T';
_is_zamm:=(_par+1)='T';
_before:="
   _win:=cur_win(1,1);
   M.actions(_win,'W',,1);
   ~~
";
M.grp_sel(_grp,,'NL_WERST',{? _is_zamm>0 | _is_zamt>0 || 'Wszystkie'@ || '' ?},,,,,_before,,,,'maximized','m4zam_all');
{? _is_zamt>0
|| _before:="
      TCHMAT.index('SL');
      TCHMAT.prefix(VAR.A_TMAT);
      TCHMAT.first();
      ~~
   ";
   M.grp_sel(_grp,TCHMAT,'WER_ZLIM','Zamienniki technologiczne'@,,,,,_before,,,,'maximized','m4zam_zamt')
?};
{? _is_zamm>0
|| _before:="
      MZ.index('MZ');
      MZ.prefix(VAR.A_TOW);
      MZ.first();
      ~~
   ";
   M.grp_sel(_grp,MZ,'WER_ZLIM','Zamienniki materiałowe'@,,,,,_before,,,,'maximized','m4zam_zamm')
?};
M.win_sel(_grp);
M.win_dict(_grp);
~~


\zlim_kor_wyb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Akcja Wybierz podczas przeprowadzania korekty na zamiennik
::----------------------------------------------------------------------------------------------------------------------
_tab:=cur_tab(1,1);
_res:=0;
{? _tab=TCHMAT
|| _par:=exec('get','#params',500001,2);
   {? TCHMAT.ACT='T'
   || TTG.cntx_psh();
      TTGP.cntx_psh();
      {? TCHMAT.PT<>null()
      || VAR.A_T:=TCHMAT.PT;
         _res:=1
      |? _par='T' | _par='P' & TCHMAT.TGRP().ZAMIENN='T'
      ||
::       Grupa technologiczna - wyświetlenie surowców grupy
         TTGP.clear();
         TTGP.index('GS');
         TTGP.prefix(TCHMAT.TGRP);
         TTGP.win_sel('WER');
         {? TTGP.first()
         || TTGP.actions(TTGP.win_sel('?'),,'W');
            {? TTGP.select()
            || VAR.A_T:=TTGP.PT;
               _res:=1
            ?}
         ?}
      ||
::       Grupa technologiczna - tylko materiał domyślny
         VAR.A_T:=TCHMAT.TGDFLT().PT;
         _res:=1
      ?};
      TTG.cntx_pop();
      TTGP.cntx_pop()
   ?}
|? _tab=MZ
|| VAR.A_T:=MZ.MZ;
   _res:=1
|| VAR.A_T:=M.ref();
   _res:=1
?};
{? _res>0
|| __ZLIM2ZAM:=2;
   VAR.A_T();
   sel_exit()
?};
~~


\update_ildok4ZLIM
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Aktualizacja pól z ilościami/wartościami pobrań/zwrotów tabeli ZLIM
::       na podstawie pozycji dokumentów magazynowych DK
::   WE: [_a] - tryb działania: [0] - aktualizuje wyłącznie ZLIMy, do których są powiązane DK
::                               1 - aktualizuje wszystkie ZLIMy (funkcja naprawcza)
::----------------------------------------------------------------------------------------------------------------------
_tryb:={? var_pres('_a')=type_of(0) || _a || 0 ?};
__ZLIM:=tab_tmp(,
   'MZLIM','STRING[8]','Maska',
   'ZLIM','STRING[16]','Ref',
   'IL_RW','REAL','Il. RW',
   'WAR_RW','REAL','War. RW',
   'IL_ZW','REAL','Il. ZW',
   'WAR_ZW','REAL','War. ZW'
);
_msk:=DK.names();
_msk.clear();
DK.trig_off('*', '*');
{? _msk.first()
|| {!
   |? DK.cntx_psh();
      DK.use(_msk.NAME);
      DK.prefix();
      DK.f_set(,,'DK.ZLIM is not null and DK.Z=\'T\'');
      {? DK.f_first()
      ||
         {!
         |?
            {? __ZLIM.find_key(DK.M_ZLIM,$DK.ZLIM)
            || {? DK.PLUS='T'
               || __ZLIM.IL_ZW+=DK.IL;
                  __ZLIM.WAR_ZW+=DK.WAR
               || __ZLIM.IL_RW+=DK.IL;
                  __ZLIM.WAR_RW+=DK.WAR
               ?};
               __ZLIM.put()
            || {? DK.M_ZLIM='' || DK.M_ZLIM:=ref_name(DK.ZLIM); DK.put() ?};
               __ZLIM.MZLIM:=DK.M_ZLIM;
               __ZLIM.ZLIM:=$DK.ZLIM;
               {? DK.PLUS='T'
               || __ZLIM.IL_RW:=0;
                  __ZLIM.WAR_RW:=0;
                  __ZLIM.IL_ZW:=DK.IL;
                  __ZLIM.WAR_ZW:=DK.WAR
               || __ZLIM.IL_RW:=DK.IL;
                  __ZLIM.WAR_RW:=DK.WAR;
                  __ZLIM.IL_ZW:=0;
                  __ZLIM.WAR_ZW:=0
               ?};
               __ZLIM.add()
            ?};
            DK.f_next()
         !}
      ?};
      DK.cntx_pop();
      _msk.next()
   !}
?};
DK.trig_on('*', '*');

{? _tryb=0
|| ZLIM.cntx_psh();
   ZLIM.prefix();
   ZLIM.trig_off('*', '*');
   {? __ZLIM.first()
   ||
      {!
      |?
         {? ZLIM.name()<>__ZLIM.MZLIM || ZLIM.use(__ZLIM.MZLIM); ZLIM.prefix() ?};
         {? ZLIM.seek(__ZLIM.ZLIM)
         || ZLIM.IL_RW:=__ZLIM.IL_RW;
            ZLIM.WAR_RW:=__ZLIM.WAR_RW;
            ZLIM.IL_ZW:=__ZLIM.IL_ZW;
            ZLIM.WAR_ZW:=__ZLIM.WAR_ZW;
            ZLIM.put()
         ?};
         __ZLIM.next()
      !}
   ?};
   ZLIM.trig_on('*', '*');
   ZLIM.cntx_pop()
|? _tryb=1
|| {? var_pres('_msk')>100 || obj_del(_msk) ?};
   _msk:=ZLIM.names();
   _msk.clear();
   ZLIM.trig_off('*', '*');
   {? _msk.first()
   ||
      {!
      |? ZLIM.cntx_psh();
         ZLIM.use(_msk.NAME);
         ZLIM.prefix();
         ZLIM.for_each("
            {? __ZLIM.find_key(ref_name(ZLIM.ref()),$ZLIM.ref())
            || ZLIM.IL_RW:=__ZLIM.IL_RW;
               ZLIM.WAR_RW:=__ZLIM.WAR_RW;
               ZLIM.IL_ZW:=__ZLIM.IL_ZW;
               ZLIM.WAR_ZW:=__ZLIM.WAR_ZW
            || ZLIM.IL_RW:=0;
               ZLIM.WAR_RW:=0;
               ZLIM.IL_ZW:=0;
               ZLIM.WAR_ZW:=0
            ?};
            ZLIM.put()
         ",1);
         ZLIM.cntx_pop();
         _msk.next()
      !}
   ?};
   ZLIM.trig_on('*', '*')
?};
VAR_DEL.delete('__ZLIM');
~~


\obj4rez
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Tworzy obiekt wykorzystywany podczas generowania rezerwacji do nielimitów
::   WY: utworzony obiekt
::----------------------------------------------------------------------------------------------------------------------
_obj:=obj_new(
:: $ZLGD.ref() - robocizna
   'ZLGD',
:: Znacznik, czy bezterminowa: N - nie, niezakończona rejestracja wykonania (ekiosk), T - tak, rejestracja zakończona
   'BTERM',
:: Znacznik dydykowanych rezerwacji: 'R' - robocizna (rezerwacje do ZLGD - pobranie surowców podczas rejestracji)
::                                   'T'
::                                   'P'
   'ZL_REZ',
:: Kod palety
   'KODPAL'
);
_obj.ZLGD:='';
_obj.BTERM:='';
_obj.ZL_REZ:='';
_obj.KODPAL:='';

_obj


\czy_sa_nielimity_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [23.25]
:: OPIS: Sprawdzenie, czy dla grupy operacji są surowce nielimitowane
::   WE: _a - GROP.ref()
::       [_b] - NUMBER - Czy uwzględniać tylko surowce oznaczone jako "rozliczane z operacją":
::            1 - tak, [0] - nie (uwzględniać wszystkie surowce nielimitowane)
::   WY: 1 - dla grupy operacji wygenerowano surowce nielimitowane
::       0 - grupa operacji nie posiada surowców nielimitowanych
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;
_typ:={? var_pres('_b')=type_of(0) || _b || 0 ?};
_result:=0;

GROP.cntx_psh();
ZLIM.cntx_psh();
GROP.prefix();
{? GROP.seek(_grop)
|| exec('openmask','zl_common',null(),GROP.ref());
   ZLIM.index('GROPROZ');
   {? _typ=1
   || ZLIM.prefix(_grop,'N','T')
   || ZLIM.prefix(_grop,'N')
   ?};
   {? ZLIM.first()
   || {? _typ=1
      || _result:=1
::       Jeżeli uwzględniane tylko surowce rozliczane z operacją to sprawdzam czy są rezerwacje pod surowce
::         REZ.cntx_psh();
::         _mask:=(REZ.name()-2)+'__';
::         {? REZ.name()<>_mask || REZ.use(_mask) ?};
::         REZ.index('ZLREZP2');
::         REZ.prefix(ZGP.ZL,'S','R','T',$ZGP.ref(),);
::         {? REZ.first()
::         || _result:=1
::         ?};
::         REZ.cntx_pop()
      || _result:=1
      ?}
   ?}
?};
GROP.cntx_pop();
ZLIM.cntx_pop();
_result


\pob4zlim_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Tworzy tabelę pobrań dla surowca (dokumentów RW dla ZLIM).
::   WY: tabela
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(4,
   'REFSUR','INTEGER','#_sur.ref()',
   'ZL_SYM','STRING[25]','Symbol zlecenia',
   'ZGH_NR','STRING[30]','Numer przewodnika',
   'ZGP_POZ','STRING[20]','Nr. pozycji przewodnika',
   'DT','DATE','Data dostawy',
   'DOST','STRING[80]','Dostawa',
   'ILOSC','REAL','Ilość',
   'ILP','REAL','Pobrano',
   'ILZ','REAL','Zwrócono',
   'ILR','REAL','Pozostało',
   'WYDK','STRING[20]','Kod wydziału',
   'WYD','INTEGER','Wydział (#SLO.ref())',
   'ZL_REF','STRING[16]','$ZL.ref()',
   'ZGH_REF','STRING[16]','$ZGH.ref()',
   'ZGP','INTEGER','Pozycja przewodnika (#ZGP.ref())',
   'ZGP_OPIS','STRING[60]','Opis pozycji przewodnika',
   'ZPARN','STRING[16]','$ZPARN.ref()',
   'GROP_REF','STRING[16]','Grupa operacji ($GROP.ref())',
   'GROP_KOD','STRING[10]','Kod grupy operacji',
   'GROP_OP','STRING[60]','Opis grupy operacji',
   'ZLIM','STRING[16]','$ZLIM.ref()',
   'PRDK','STRING[16]','prdk',
   'SRDK','STRING[16]','srdk',
   'SC','STRING[16]','$SC.ref()',
   'DK_C','STRING[16]','$DK_C.ref()',
   'MAG','INTEGER','Magazyn (#MG.ref())',
   'MAGSYM','STRING[8]','Symbol magazynu',
   'MAGNAME','STRING[60]','Nazwa magazynu',
   'MAG_SRC','INTEGER','Magazyn źródłowy (#MG.ref())',
   'REFDK','INTEGER','#_dk.ref()',
   'MAT','INTEGER','#M.ref()',
   'KTM','STRING[50]','Indeks materiału',
   'NAZ','STRING[100]','Nazwa materiału'
);
_tab


\zwr_gen_pob
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Zwroty do generowania - tworzy listę powiązań surowców z dokumentami rozchodowymi zlecenia
::   WE: _a - ZL.ref()/GROP.ref() (w przypadku zleceń złożonych zlecenie na najwyższym poziomie)
::       [_b] - tabela z listą refów do ZLIM, których dokumenty rozchodowe brać pod uwgagę - pole REF z $ZLIM.ref()
::       [_c] - INTEGER - miejsce uruchomienia: [0] - zlecenia (ZL), 1 - grupy operacji (GROP)
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_env_gen:=params_get().env_gen;
::_dk:=_env_gen.DK.TAB;
_sur:=_env_gen.SUR.TAB;
_pob:=_env_gen.POB.TAB;

_ref:={? var_pres('_a')=type_of(null()) || _a || null() ?};
_zlim_tab:={? var_pres('_b')>100 || _b || ~~ ?};
_where:={? var_pres('_c')=type_of(0) || _c || 0 ?};

_zl:=_grop:=null();
{? _where=0 || _zl:=_ref || _grop:=_ref ?};

ZL.cntx_psh(); ZL.clear();
GROP.cntx_psh(); GROP.clear();

{? (_where=0 & _zl<>null() & ZL.seek(_zl)) | (_where=1 & _grop<>null() & GROP.seek(_grop))
|| VAR.cntx_psh();
   VAR.A_ZLEC:=_zl;
   VAR.A_GROP:=_grop;
   exec('openmask','zl_common',_zl,_grop);
   exec('s_nlim','zl_common');
   _continue:=0;
   {? _where=0
   || {? ZL.RODZAJ='P'
      || ZL.index('UNRZL');
         ZL.prefix(ZL.UNRZL)
      || ZL.index('NRNZL');
         ZL.prefix(ZL.UNRZL)
      ?};
      _continue:=ZL.first()
   || _continue:=1
   ?};
   {? _continue>0
   || Cntx.psh(DK,ND);
      _rule:="
         _ref:=_b.REF;
         _top_ref:=_b.TOP_REF;
         _tab:=_b.TAB;
         _sur:=_b.SUR;
         _zlim_tab:=_b.ZLIM;
         _czy_grop:=_b.WHERE;
         DK.prefix();
         _sort:=_where:=_from:='';
         _sort:='PLUS';
         {? _czy_grop=0
         || _where:='ZL=:_a '
         || _where:='GROP=:_a '
         ?};
         _where+='and ZLIM is not null and Z=\\'T\\' ';
         {? type_of(_zlim_tab)>0
         || _where+=' and DK.ZLIM in (select REF from :_b) '
         ?};
         DK.f_set(_sort,_from,_where,_ref,_zlim_tab);
         {? DK.f_first()
         || _nd_mask:=5+ND.name()+(DK.name()+3);
            {? _nd_mask<>ND.name() || ND.use(_nd_mask) ?};
            {!
            |?
               _ref_acr:={? _czy_grop=0 || 'ZL_REF' || 'GROP_REF' ?};
               {? _sur.find_tab(,_ref_acr,,'=',$_top_ref,'MAT',,'=',#DK.M)
               ||
                  {? ~_tab.find_tab(,'ZLIM',,'=',$DK.ZLIM,'SRDK',,'=',DK.SRDK,'MAG',,'=',#DK.N().MAG)
                  ||
::                   Pominięcie zwrotów niepowiązanych z dostawą
                     {? DK.PLUS<>'T'
                     || _tab.blank();
                        _tab.REFSUR:=#_sur.ref();
                        _tab.REFDK:=_sur.REFDK;
                        _tab.MAT:=_sur.MAT;
                        _tab.KTM:=_sur.KTM;
                        _tab.NAZ:=_sur.NAZ;
                        {? DK.PLUS='T'
                        || _tab.ILZ:=DK.IL;
                           _tab.ILR:=DK.IL*(-1)
                        || _tab.ILP:=DK.IL;
                           _tab.ILR:=DK.IL
                        ?};
                        _tab.ILOSC:=0;
                        _tab.WYDK:=DK.WYD().KOD;
                        _tab.WYD:=#DK.WYD;
                        {? _czy_grop=0
                        || _tab.ZL_REF:=$DK.ZL;
                           _tab.ZL_SYM:=DK.ZL().SYM;
                           _tab.ZGH_REF:=$DK.ZGH;
                           _zgp:={? DK.ZGP<>null()
                              || DK.ZGP
                              || exec('FindAndGet','#table',ZLIM,DK.ZLIM,,\"ZLIM.ZGP\",null())
                              ?};
                           ZGP.cntx_psh();
                           ZGP.prefix();
                           {? ZGP.seek(_zgp)
                           || _tab.ZGP_POZ:=form(ZGP.NRP);
                              _tab.ZGH_NR:=ZGP.NRZLP().NRPRZ;
                              _tab.ZGP:=#ZGP.ref();
                              _tab.ZGP_OPIS:=ZGP.OPIS
                           ?};
                           ZGP.cntx_pop()
                        || _tab.GROP_REF:=$DK.GROP;
                           _tab.GROP_KOD:=DK.GROP().KOD;
                           _tab.GROP_OP:=DK.GROP().OPIS
                        ?};
                        _tab.ZPARN:=$DK.PARTIA;
                        _tab.ZLIM:=$DK.ZLIM;
                        _tab.PRDK:=DK.PRDK;
                        _tab.SRDK:=DK.SRDK;
                        SC.cntx_psh();
                        SC.use((5+SC.name())+(ref_name(_tab.SRDK)+3));
                        SC.index('SRDK');
                        SC.prefix(_tab.SRDK,_tab.SRDK);
                        {? SC.first()
                        || _sc:=$SC.ref();
                           _tab.SC:=_sc;
                           _nd:=exec('FindAndGet','#table',DK,SC.SRDK,,\"DK.N\",null());
                           _dost1:=exec('FindAndGet','#table',ND,_nd,,\"ND.KH().KOD+' '+ND.TYP().T+' - '+$ND.NR\",'');
                           _dost2:=exec('FindAndGet','#table',DK,SC.SRDK,,\"' poz.'+$DK.P\",'');
                           _tab.DOST:=_dost1+_dost2;
                           _tab.DT:=SC.D
                        ?};
                        SC.cntx_pop();
                        _tab.DK_C:=$DK.DK_C;
                        _tab.MAG:=#DK.N().MAG;
                        _tab.MAG_SRC:=#DK.N().MAG;
                        _tab.MAGSYM:=DK.N().MAG().SYM;
                        _tab.MAGNAME:=DK.N().MAG().NAZ;
                        _tab.add()
                     ?}
                  || {? DK.PLUS='T'
                     || _tab.ILZ+=DK.IL;
                        _tab.ILR-=DK.IL
                     || _tab.ILP+=DK.IL;
                        _tab.ILR+=DK.IL
                     ?};
                     _tab.put()
                  ?}
               ?};
               DK.f_next()
            !}
         ?};
         {? DK.f_active() || DK.f_clear() ?}
      ";
      _param:=obj_new('REF','TOP_REF','TAB','SUR','ZLIM','WHERE');
      _param.TAB:=_pob;
      _param.TOP_REF:={? _where=0 || _zl || _grop ?};
      _param.SUR:=_sur;
      _param.ZLIM:=_zlim_tab;
      _param.WHERE:=_where;
      {!
      |?
         _name:=5+DK.name();
         _msk_end:=~~;
         {? _where=0
         || _param.REF:=ZL.ref();
            _msk_start:=_name+ZL.ODDZ+(2-$(ZL.OD~1));
            {? ZL.STAN='Z'
            || _rok:=exec('max','#math',ZL.ROK_MAX,ZL.DO~1);
               _msk_end:=_name+ZL.ODDZ+(2-$(_rok))
            || _rok:=exec('max','#math',ZL.ROK_MAX,date()~1,ST.AR);
               _msk_end:=_name+ZL.ODDZ+(2-$(_rok))
            ?}
         || _param.REF:=GROP.ref();
            _msk_start:=_name+GROP.ODDZ+(2-$(GROP.DATA~1));
            _rok:=exec('max','#math',GROP.ROK_MAX,GROP.DATA~1);
            _msk_end:=_name+GROP.ODDZ+(2-$(_rok))
         ?};
         exec('for_each_mask','#table',DK,_rule,_msk_start,_msk_end,_param);
         _loop:={? _where=0 || ZL.next() || 0 ?};
         _loop
      !};
      Cntx.pop(DK,ND)
   ?};
   VAR.cntx_pop();
:: Uzupełnienie ilości/magazynu na surowcach
   _sur.cntx_psh(); _sur.prefix();
   _pob.cntx_psh();
   _p500713:=exec('get','#params',500713,type_of(''));
   {? _p500713='M'
   || _pob.index(_env_gen.POB.NDXDOSTM)
   || _pob.index(_env_gen.POB.NDXDOSTR)
   ?};
   _pob.prefix();
   {? _sur.first() & _pob.first()
   || {!
      |?
         _dorozp:=_sur.ILOSC;
         _mag:=0;
         _mag_sym:=_mag_name:='';
         _pob.prefix(#_sur.ref());
         {? _pob.first()
         || _mag:=_pob.MAG;
            _mag_sym:=_pob.MAGSYM;
            _mag_name:=_pob.MAGNAME;
            _chk_mag:=1;
            {!
            |?
               {? _chk_mag>0 & _mag<>_pob.MAG
               || _chk_mag:=0;
                  _mag:=0;
                  _mag_sym:=_mag_name:=''
               ?};
               _ilosc:=exec('min','#math',_pob.ILP,_dorozp,exec('pob_il_valid','zl_nlimit',0,0));
               _pob.ILOSC:=_ilosc;
               {? _pob.put()
               || _dorozp-=_ilosc
               ?};
               _pob.next()
            !};
            {? _dorozp>0
            || _sur.ILOSC-=_dorozp;
               {? _sur.ILOSC<0 || _sur.ILOSC:=0 ?}
            ?};
            _sur.MAG:=_mag;
            _sur.MAGSYM:=_mag_sym;
            _sur.MAGNAME:=_mag_name;
            _sur.put()
         ?};
         _sur.next()
      !}
   ?};
   _sur.cntx_pop(); _pob.cntx_pop()
?};
ZL.cntx_pop();
GROP.cntx_pop();
~~


\pob_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Zwroty do generowania - walidacja pozycji surowca. Działa na aktualnych rekordach tabel:
::       __ENV_GEN.POB.TAB (_pob) oraz __ENV_GEN.SUR.TAB (_sur) środowiska __ENV_GEN.
::   WE: [_a] - czy wyświetlać dialogi: [1] - na ekran, 2 - do KOMM, 0 - nie wyświetlać
::   WY: STRING - akronim pola, w którym wystąpił błąd lub '' gdy wszystko ok
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
_dialog:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_env_gen:=params_get().env_gen;
_pob:=_env_gen.POB.TAB;
_sur:=_env_gen.SUR.TAB;
_wyn:='';

_mag:=VAR.A_MAG;
VAR.A_MAG:=exec('FindAndGet','#table',MG,_pob.MAG,,,null());
_wyn:=__CHK.record3(VAR,'A_MAG','Magazyn'@);
{? _wyn=''
|| {? VAR.A_MAG().KOOP='T'
   || _msg:='Należy wybrać magazyn nie służący do rejestracji kooperacji.'@;
      {? _dialog=2
      || KOMM.add('Surowciec %1, dostawa %2 - %3'@[_pob.KTM,_pob.DOST,_msg])
      |? _dialog=1
      || FUN.info(_msg)
      ?};
      _wyn:='A_MAG'
   ?}
?};
{? _wyn=''
|| _wyn:=exec('pob_il_valid','zl_nlimit',1,_dialog)
?};
VAR.A_MAG:=_mag;
_wyn


\pob_il_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Zwroty do generowania - walidacja ilości dla pozycji surowca. Działa na aktualnych rekordach tabel:
::       __ENV_GEN.POB.TAB (_pob) oraz __ENV_GEN.SUR.TAB (_sur) środowiska __ENV_GEN.
::   WE: [_a] - co zwracać - [1] - wynik walidacji , 0 - maksymalną ilosć jaką można przypisać do pozycji
::       [_b] - czy wyświetlać dialogi: [1] - na ekran, 2 - do KOMM, 0 - nie wyświetlać
::   WY: _gdy _a=0: STRING - akronim pola, w którym wystąpił błąd lub '' gdy wszystko ok
::       _gdy _a=1: REAL - maksymalną ilosć jaką można przypisać do pozycji
::----------------------------------------------------------------------------------------------------------------------
_valid:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_dialog:={? var_pres('_b')=type_of(0) || _b || 1 ?};
_env_gen:=params_get().env_gen;
_pob:=_env_gen.POB.TAB;
_sur:=_env_gen.SUR.TAB;
_wyn:='';

_mat:=VAR.A_T;
VAR.A_T:=exec('FindAndGet','#table',M,_pob.MAT,M.name(),,null());
{? _valid>0
|| {? _pob.ILOSC<0
   || _msg:='Należy podać wartość większą lub równą zero.'@;
      {? _dialog=2
      || KOMM.add('Surowciec %1, dostawa %2 - %3'@[_pob.KTM,_pob.DOST,_msg])
      |? _dialog=1
      || FUN.info(_msg)
      ?};
      _wyn:='ILOSC'
   ?}
?};
{? _wyn=''
|| _dokl:=exec('jaka_dok_m','jm',VAR.A_T);
   _zlim_max:=exec('FindAndGet','#table',ZLIM,_pob.ZLIM,,"ZLIM.IL_RW-ZLIM.IL_ZW",0);
   _sur_max:=_sur.ILR;
   _sum_il:=_sum_zlim:=0;
   _il_max:=0;
   _ref:=_pob.ref();
   _zlim_ref:=_pob.ZLIM;
:: Wyznaczenie ilości już rozpisanej na pozycjach
   _pob.cntx_psh();
   {? _pob.first()
   || {!
      |?
         {? _pob.ref()<>_ref
         || {? _pob.ZLIM=_zlim_ref
            || _sum_zlim+=_pob.ILOSC
            ?};
            _sum_il+=_pob.ILOSC
         ?};
         _pob.next()
      !}
   ?};
   _pob.cntx_pop();
   _il_max:=exec('min','#math',_pob.ILR,_sur_max-_sum_il,_zlim_max-_sum_zlim);
   {? _il_max<0 || _il_max:=0 ?};
   {? _valid>0
   || {? _pob.ILOSC>_il_max
      ||
::       Walidacja wg ilości na surowcu zlecenia (ZLIM)
         {? _pob.ILOSC>_zlim_max-_sum_zlim
         || _msg:=
               'Łączna ilość surowca jaka może zostać zwrócona do zlecenia nie może przekroczyć: %1 %2.\n'
               'Maksymalna ilość surowca jaką można zwrócić do danej dostawy: %3 %2.'@
               [form(_zlim_max,,_dokl),VAR.A_T().J().KOD,form((_il_max),,_dokl)]
::       Walidacja wg ilości na indeksie materiałowym
         |? _pob.ILOSC>_sur_max-_sum_il
         || _msg:=
               'Łączna ilość surowca jaka może zostać zwrócona nie może przekroczyć: %1 %2.\n'
               'Maksymalna ilość surowca jaką można zwrócić do danej dostawy: %3 %2.'@
               [form(_sur_max,,_dokl),VAR.A_T().J().KOD,form((_il_max),,_dokl)]
::       Walidacja wg ilości na dostawie
         || _msg:='Maksymalna ilość surowca jaką można zwrócić do dostawy: %1 %2.'@
            [form(_il_max,,_dokl),VAR.A_T().J().KOD]
         ?};
         {? _dialog=2
         || KOMM.add('Surowciec %1, dostawa %2 - %3'@[_pob.KTM,_pob.DOST,_msg])
         |? _dialog=1
         || FUN.info(_msg)
         ?};
         _wyn:='ILOSC'
      ?}
   || _wyn:=_il_max
   ?}
?};
VAR.A_T:=_mat;
_wyn


\zlim_chk4il
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Sprawdza, czy do podanego surowca (ZLIM) można zarejestrować ilość zerową
::       (ilość zerowa dozwolona dla odpadów/koproduktów)
::   WE: [_a] - ZLIM.ref() - jak nie podany to aktualny bufor ZLIM
::   WY: 1 - można/ 0 - nie można
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
{? var_pres('_a')=type_of(null())
|| _zlim:=_a;
   _found:=0
|| _zlim:=ZLIM.ref();
   _found:=1
?};
{? _zlim<>null()
|| ZLIM.cntx_psh();
   {? _found=0
   || _mask:=ref_name(_zlim);
      {? ZLIM.name()<>_mask || ZLIM.use(_mask) ?};
      ZLIM.prefix();
      {? ZLIM.seek(_zlim)
      || _found:=1
      ?}
   ?};
   {? _found>0
   || {? ZLIM.SO='O'
      || {? ZLIM.KOR<>0
         ||
::          W przypadku korekt sprawdzane, czy koreka dołącza nowy odpad, czy modyfikuje ilość aktualnego odpadu
            ZLIM.index('ZGP_KM');
            ZLIM.prefix(ZLIM.ZGP,'T',ZLIM.KOR);
            {? ZLIM.first() & ZLIM.size()=1
            ||
::             Korekta jest jedyną korektą do ZLIM
               ZLIM.index('ZKN');
               ZLIM.prefix(ZLIM.ZLEC,ZLIM.LIMIT,ZLIM.KTM,ZLIM.KOR);
               {? ZLIM.first()
               ||
::                Jedyna korekta do ZLIMa z zerową ilością, który powstał na zleceniu otwartym  = korekta tworzący odpad
                  {? ZLIM.BORNSTAT='O' & ZLIM.LIL=0
                  || _res:=1
                  ?}
               ?}
            ?}
         || _res:=1
         ?}
      ?}
   ?};
   ZLIM.cntx_pop()
?};
_res


\czy_sa_odpady_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Sprawdzenie, czy dla grupy operacji są odpady/koprodukty
::   WE: _a - GROP.ref()
::   WY: 1 - dla grupy operacji wygenerowano odpady/koprodukty
::       0 - grupa operacji nie posiada odpadów/koproduktów
::----------------------------------------------------------------------------------------------------------------------
_grop:=_a;
_result:=0;

GROP.cntx_psh();
ZLIM.cntx_psh();
GROP.prefix();
{? GROP.seek(_grop)
|| exec('openmask','zl_common',null(),GROP.ref());
   ZLIM.index('GROPLSK');
   ZLIM.prefix(_grop,'T','O');
   {? ZLIM.first()
   || _result:=1
   ?}
?};
GROP.cntx_pop();
ZLIM.cntx_pop();
_result


\find_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Wyszukuje surowce do rozliczenia dla zlecenia.
::       Kontekst wywołania - rekord tabeli ZL
::----------------------------------------------------------------------------------------------------------------------
_env_gen:=__ENV_GEN;
params_set('env_gen',_env_gen);
_gen:=_env_gen.GEN;

{? _gen='NLI_ZL'
|| {? ~exec('czy_sa_nielimity','zl_nlimit',ZL.ref())
   || KOMM.add('Zlecenie %1 nie ma zdefiniowanych surowców nielimitowanych.'@[ZL.SYM]);
      return()
   ?}
|? _gen='ODP_ZL'
|| {? ~exec('czy_sa_odpady','zl_nlimit',ZL.ref())
   || KOMM.add('Zlecenie %1 nie ma zdefiniowanych odpadów/koproduktów.'@[ZL.SYM]);
      return()
   ?}
|? _gen='ZWR'
|| {? ~exec('czy_sa_limity','zl_limit',ZL.ref(),1)
   || KOMM.add('Zlecenie %1 nie ma zdefiniowanych surowców limitowanych.'@[ZL.SYM]);
      return()
   |? exec('zl_chk4zw','magdok_prod',ZL.ref())
   || KOMM.add(
         'Do zlecenia %1 przypisane są niezaakceptowane dokumenty zwrotu surowców. '
         'Zalecana jest ich wcześniejsza obsługa.'@[ZL.SYM])
   ?}
?};

_ok:=1;

_dk:=_env_gen.DK.TAB;
_dk_ndxzl:=_env_gen.DK.NDXZL;
_sur:=_env_gen.SUR.TAB;
::{? exec('top_rodzaj','zl_link',ZL.ref())='N'
::|| _top:=ZL.ref();
::   _top_sym:=ZL.SYM
::|| {? ZL.TREE_TYP='F'
::   || _top:=ZL.ref();
::      _top_sym:=ZL.SYM
::   || _top:=exec('top_level','zl_link',ZL.ref());
::      _top_sym:=exec('FindAndGet','#table',ZL,_top,,"SYM",'')
::   ?}
::?};
_top:=ZL.ref();
:: Dodanie rekordu nagłówka
_dk.prefix();
_dk.blank(1);
_dk.ZLEC:=ZL.SYM;
_dk.M:=ZL.KTM().KTM;
_dk.JM:=ZL.KTM().J().KOD;
_dk.IL:=ZL.IL;
_dk.ILDOK:=ZL.ILDOK;
_dk.ILWYK:=ZL.ILWYK;
_dk.DT:=ZL.DTR;
_dk.ZL_REF:=$ZL.ref();
_dk.add();

:: ZASILENIE
{? _gen='ZWR'
||
:: Zwroty
   _ok:=exec('sur_ra_zwr','zl_nlimit',_top);
   {? _ok<=0
   ||
::    Brak surowców do zwrotu, usunięcie nagłówka zlecenia
      _dk.del()
   ?}
||
:: Odpady/nielimity
   _ok:=exec('sur_ra','zl_nlimit',_top,,0);
   {? _ok<=0 || _dk.del() ?}
?};
_dk.index(_dk_ndxzl);
_dk.prefix($ZL.ref());
{? _dk.first()
|| {? ~exec('zl_lock','zl_common',#ZL.ref(),'L',1)
   || KOMM.add('Zapotrzebowania do zlecenia %1 obsługuje inny użytkownik.'@[ZL.SYM]);
      {!
      |? _dk.del()
      !}
   ?}
?};
~~


\sur_ra_zwr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Surowce do zwrotu
::   WE: _a - ZL.ref()/GROP.ref()
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_env_gen:=params_get().env_gen;
_dk:=_env_gen.DK.TAB;
_sur:=_env_gen.SUR.TAB;
_gen:=_env_gen.GEN;

_ref:=_a;
_result:=0;

_zlim:=_env_gen.ZLIM;
_kontr_lim:=exec('kontr_lim','zl_limit','T',1,,,0,{? _zlim.size()>0 || _zlim || ~~ ?},_gen='ZWR_GROP');
{? var_pres('_kontr_lim')>100
|| _kontr_lim.TAB.prefix();
   {? _kontr_lim.TAB.first()
   || {!
      |?
         _ilosc:=_kontr_lim.TAB.ILP;
         {? _ilosc>0
         ||
::          Dodanie rekordu pozycji (surowiec do zwrotu)
            _sur.blank(1);
            _sur.REFDK:=#_dk.ref();
            _sur.ZLIM:='';
            _sur.MAT:=_kontr_lim.TAB.T;
            _sur.KTM:=exec('FindAndGet','#table',M,_sur.MAT,,"KTM",'');
            _sur.NAZ:=exec('FindAndGet','#table',M,_sur.MAT,,"N",'');
            _sur.JM:=exec('FindAndGet','#table',M,_sur.MAT,,"J().KOD",'');
            _sur.MAG:=0;
            _sur.MAGSYM:='';
            _sur.MAGNAME:='';
            _dokl:=exec('FindAndGet','#table',M,_sur.MAT,,"exec('jaka_dok_m','jm',M.ref())",0);
            _sur.ILL:=
               {? _dokl>0
               || _kontr_lim.TAB.ILL$_dokl
               || ceil( _kontr_lim.TAB.ILL)
               ?};
            _ilosc:=_kontr_lim.TAB.ILP-_sur.ILL;
            _sur.ILOSC:={? _ilosc>0 || _ilosc || 0 ?};
            _sur.ILP:=_kontr_lim.TAB.ILRW;
            _sur.ILZ:=_kontr_lim.TAB.ILZW;
            _sur.ILR:=_sur.ILP-_sur.ILZ;
            {? _gen='ZWR_GROP'
            || _sur.GROP_REF:=_dk.GROP_REF;
               _sur.GROP:=#exec('FindAndGet','#table',GROP,_dk.GROP_REF)
            || _sur.ZL_REF:=_dk.ZL_REF
            ?};
            _sur.add()
         ?};
         _kontr_lim.TAB.next()
      !}
   ?}
?};
:: Uzupełnienie powiązań surowców z dokumentami rozchodowymi
_sur.cntx_psh();
_sur.index(_env_gen.SUR.NDXLIM);
_sur.prefix(#_dk.ref());
{? _sur.first()
|| _result:=1;
   {? var_pres('__ZLIM4LIM')>100
   || _zlim_tab:=__ZLIM4LIM;
      _zlim_tab.prefix()
   || _zlim_tab:=~~
   ?};
   params_exec('zwr_gen_pob','zl_nlimit',_ref,_zlim_tab,_gen='ZWR_GROP')
?};
_sur.cntx_pop();
_result


\nlim_wyd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Akcja Wydanie dla surowca nielimitowanego
::       Kontekst wywołania - zanaczone rekordy ZLIM (nielimity), VAR.A_ZLEC/VAR.A_GROP
::       [_a] - miesjce wywołania: [0] - okno surowców nielimitowanych
::                                  1 - kontrola zamknięcia zlecenia
::----------------------------------------------------------------------------------------------------------------------
_where:={? var_pres('_a')=type_of(0) || _a || 0 ?};
{? VAR.A_GROP<>null()
|| _tab:=GROP;
   _ref:=VAR.A_GROP
|| _tab:=ZL;
   _ref:=VAR.A_ZLEC
?};

{? _where=1
||
:: kontrola, czy pozycje nielimitów pochodzą tylko z jednego lub wielu zleceń
   _tab2:=cur_tab(1,1);
   _tab2.cntx_psh();
   _tab_zlim:=__ZLIM4NLIM;
   _tab_zlim.cntx_psh();
   _ndx:=_tab_zlim.ndx_tmp(,,'TAB_REF',,,'M_REF',,);
   _tab_zlim.index(_ndx);
:: Tabela z listą zleceń/grup
   _tab_zl:=tab_tmp(,'REF','STRING[16]','$ZL.ref()');
   {? _tab2.sel_size()
   || _tab_sel:=_tab2.sel_aget()
   || _tab_sel:=tab_tmp(,'REF','INTEGER','');
      _tab_sel.REF:=_tab2.ref();
      _tab_sel.add()
   ?};
   {? _tab_sel.first()
   || {!
      |?
         {? _tab2.seek(_tab_sel.REF)
         ||
            _tab_zlim.prefix($_tab2.ref(),_tab2.T);
            {? _tab_zlim.first()
            || {!
               |?
::                Wypełnienie tabeli z listą zleceń/grup
                  _zlec:={? _tab=ZL || _tab_zlim.ZL_SQL || _tab_zlim.GROP_SQL ?};
                  {? ~_tab_zl.find_key(_zlec,)
                  || _tab_zl.REF:=_zlec;
                     _tab_zl.add()
                  ?};
                  _tab_zlim.next()
               !}
            ?}
         ?};
         _tab_sel.next()
      !}
   ?};
   _tab_zlim.ndx_drop(_ndx);
   _tab_zlim.cntx_pop();
   _tab2.cntx_pop();
:: Wybór zlecenia, do którego wydawać nielimity
   _ref:=null();
   {? _tab_zl.first()
   || {? _tab_zl.size()=1
      || _ref:=exec('FindAndGet','#table',_tab,_tab_zl.REF,,,null())
      ||
::       Więcej niż jedno zlecenie, wyświetlenie okna z wyborem zlecenia
         {? _tab=ZL
         || VAR.cntx_psh();
            ZL.cntx_psh();
            ZL.index('SYM');
            ZL.prefix();
            ZL.win_sel('SLO_SL');
            ZL.actions('SLO_SL','XY','W');
            ZL.f_set(,,'ZL.REFERENCE in (select REF from :_a)',_tab_zl);
            {? ZL.select()
            || _ref:=ZL.ref()
            ?};
            ZL.actions('SLO_SL','','?');
            ZL.f_clear(1);
            ZL.cntx_pop();
            VAR.cntx_pop()
         ?}
      ?}
   || {? _tab=ZL
      || FUN.emsg('Nie znaleziono powiązanych zleceń produkcyjnych.'@)
      || FUN.emsg('Nie znaleziono powiązanej grupy operacji.'@)
      ?}
   ?}
?};
_f500707:=exec('get','#params',500707,2);
_tab.cntx_psh();
_tab.prefix();
{? _tab.seek(_ref)
|| {? _tab=ZL & ZL.ST_Z='T'
   || FUN.info('Zlecenie jest zamknięte.\nOperacja niemożliwa.'@)
   |? _tab=GROP & GROP.STATUS='Z'
   || FUN.info('Grupa operacji jest zamknięta.\nOperacja niemożliwa.'@)
   |? _f500707=''
   || FUN.emsg('Nie ustawiono parametru %1.\nNależy uzupełnić konfigurację systemu.'@['500707'])
   ||
::    kontrola, czy zaznaczono pozycje limitów do jednego zlecenia
      _can_continue:=1;
      {? _where=0
      || {? _tab=ZL
         || {? exec('ctrlSelNLIM','zl_nlimit')=0
            || FUN.info('Zaznaczono nielimity z różnych zleceń.\nOperacja niemożliwa.'@);
               _can_continue:=0
            ?}
         ?}
      ?};
      {? _can_continue>0
      ||
         KOMM.init(,,'Rozliczenie surowców'@);
         VAR_DEL.delete('__ENV_GEN');
         __ENV_GEN:=exec('env_gen','zl_limit',{? _tab=GROP || 'NLI_ZGROP' || 'NLI_ZL' ?});
         _zlim_tab:=__ENV_GEN.ZLIM;
::       Wypełnienie tabeli z listą ZLIMów
         {? _where=1
         || _tab_zlim.cntx_psh();
            {? _tab=ZL
            || _ndx:=_tab_zlim.ndx_tmp(,,'ZL_REF',,,'TAB_REF',,,'M_REF',,)
            || _ndx:=_tab_zlim.ndx_tmp(,,'GROP_REF',,,'TAB_REF',,,'M_REF',,)
            ?};
            _tab_zlim.index(_ndx);
            {? _tab_sel.first()
            || {!
               |?
                  {? _tab2.seek(_tab_sel.REF)
                  ||
                     _tab_zlim.prefix(#_tab.ref(),$_tab2.ref(),_tab2.T);
                     {? _tab_zlim.first()
                     || {!
                        |?
                           {? ~_zlim_tab.find_key(_tab_zlim.REF,)
                           || _zlim_tab.REF:=_tab_zlim.REF;
                              _zlim_tab.MREF:=_tab_zlim.M_REF;
                              _zlim_tab.add()
                           ?};
                           _tab_zlim.next()
                        !}
                     ?}
                  ?};
                  _tab_sel.next()
               !}
            ?};
            _tab_zlim.ndx_drop(_ndx);
            _tab_zlim.cntx_pop()
         || ZLIM.cntx_psh();
            {? ~ZLIM.sel_size()
            || _zlim_tab.REF:=$ZLIM.ref();
               _zlim_tab.MREF:=#ZLIM.KTM;
               _zlim_tab.add()
            || _tabsel:=ZLIM.sel_aget();
               {? _tabsel.first()
               || {!
                  |?
                     {? ZLIM.seek(_tabsel.REF)
                     || _zlim_tab.REF:=$ZLIM.ref();
                        _zlim_tab.MREF:=#ZLIM.KTM;
                        _zlim_tab.add()
                     ?};
                     _tabsel.next()
                  !}
               ?}
            ?};
            ZLIM.cntx_pop()
         ?};
         {? _tab=GROP
         || exec('find_grop','zl_grop')
         || exec('find_zl','zl_nlimit')
         ?};
         VAR.cntx_psh();
         exec('select_gen','zl_limit');
         VAR.cntx_pop();
         VAR_DEL.delete('__ENV_GEN','__ZLIM4NLIM');
         {? _where=1
         ||
::          Odświeżenie danych
            exec('kontr_nli','zl_limit','T',0,,cur_tab(1,1),{? _tab=GROP || 1 || 0 ?})
         ?}
      ?}
   ?}
?};
_tab.cntx_pop();
~~


\nlim_wyd_gb
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Akcja Wydanie dla surowca nielimitowanego - grupa przed
::       [_a] - miesjce wywołania: [0] - okno surowców nielimitowanych
::                                  1 - kontrola zamknięcia zlecenia
::----------------------------------------------------------------------------------------------------------------------
_where:={? var_pres('_a')=type_of(0) || _a || 0 ?};
sel_nchk();
exec('nlim_wyd','zl_nlimit',_where);
{? _where=0
|| {? ZLIM.sel_size() || ZLIM.sel_adel() ?}
|| _tab:=cur_tab(1,1);
   {? _tab.sel_size() || _tab.sel_adel() ?}
?};
~~


\nlim_wyd_ga
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Akcja Wydanie dla surowca nielimitowanego - grupa po
::----------------------------------------------------------------------------------------------------------------------
~~


\ctrlSelNLIM
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Kontrola zaznaczonych nielimitów - czy dotyczą jednego zlecenia
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_res:=1;
{? ZLIM.sel_size()>0
|| _zl:=null();
   ZLIM.cntx_psh();
   ZLIM.prefix();
   _tabsel:=ZLIM.sel_aget();
   {? _tabsel.first()
   || {!
      |? {? ZLIM.seek(_tabsel.REF)
         || {? _zl=null()
            || _zl:=ZLIM.ZLEC
            |? _zl<>ZLIM.ZLEC
            || _res:=0
            ?}
         ?};
         _res>0 & _tabsel.next()
      !}
   ?};
   ZLIM.cntx_pop()
?};
_res

:Sign Version 2.0 jowisz:1045 2024/02/05 12:18:36 8e997dcfc17b458c1e07b649b24c2d738adf47a03c4eb8307660c690137ca2713f2c22cb896710991bdd1f85e576622cf64c5c91c72b4dbcf8604609c662bb2c0e2b5a4fb9f62bd8a332bbf576528fd4b50f7ac6f12ffdb593315d3208801586e59c13f0140f69058fabff630b9ffd85701d2271eebb5df2459fe1e8b9a098df
