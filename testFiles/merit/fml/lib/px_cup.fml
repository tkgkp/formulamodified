:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzezone
::======================================================================================================================
:: Nazwa pliku:  px_cup.fml [12.10]
:: Utworzony: 2011-08-17
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Formuly do obslugi pojemnikow w planie strategicznym (wielowymiarowym planie pojemnosciowym)
::======================================================================================================================


\clone_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Tablica parametrow dla clone
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('SOURCE',
               'PX_VER',
               'PX_KONT',
               'MODE'
               );
_args.SOURCE:=null();
_args.PX_VER:=null();
_args.PX_KONT:=null();

:: 0 - nie klonuje zadnych pozycji planu, ale klonuje zajete pojemnosci pojemnika
:: 1 - klonuje tylko zablokowane pozycje planu, pojemnosci pojemnikow ustawia na nowo
:: 2 - klonuje wszystkie pozycje planu i pojemnosci pojemnikow
_args.MODE:=0;
_args


\clone
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Klonuje pojemnik
::   WE: _a - _args  - argumenty funkcji wynik dzialania exec('clone_a','px_cup')
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_args:={?_=1 || _a || exec('clone_a','px_cup') ?};
_result:=0;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

PX_CUP.cntx_psh();
PX_POZ.cntx_psh();
PX_CUP.clear();
{? PX_CUP.seek(_args.SOURCE)
||
   _msg:='Duplikowanie pojemnika: '+PX_CUP.SYMBOL;
   pxkomm.sect_beg(_msg);
   PX_CUP.PX_VER:=_args.PX_VER;
   PX_CUP.PX_KONT:=_args.PX_KONT;
:: zapamietuje identyfikator pojemnika na podstawie ktorego powstalem
   PX_CUP.UID_SRC:=PX_CUP.UID;
   PX_CUP.UID:=exec('uid','#blank');
:: kasuje niepoprawne powiązania
   PX_CUP.UID_PAR:='';

:: jesli potrzeba to zeruje pojemnosci klona - domyslnie ta opcja jest aktywna
:: ale mozna ja wylaczyc np. w przypadku potrzeby szybkiego okreslenia terminu wykonania obiektu
   _il_wym:=PX_CUP.PX_KONT().IL_WYM;

   {? _args.MODE=1
   || {! _it:=1.._il_wym
      |! _rule:=$('PX_CUP.CAP_USE'+$_it+':=0');
         _rule()
      !}
   ?};

   _ok:=PX_CUP.add();
   _cloned:=null();
   {? _ok>0
   || _cloned:=PX_CUP.ref()
   ?};

:: klonowanie pozycji planu
   {? _ok>0 & (_args.MODE=1 | _args.MODE=2)
   ||
      _argspoz:=exec('clone_pxpoz_a','px_cup');
      _argspoz.PX_VER:=_args.PX_VER;
      _argspoz.PX_KONT:=_args.PX_KONT;
      _argspoz.CUP_SRC:=_args.SOURCE;
      _argspoz.CUP_DST:=_cloned;

      _argspz2:=exec('clone_a','px_poz');
      _argspz2.PX_VER:=_argspoz.PX_VER;
      _argspz2.PX_KONT:=_argspoz.PX_KONT;
      _argspz2.PX_CUP:=_argspoz.CUP_DST;

     {? _args.MODE=1
     ||
::       klonuje zablokowane pozycje planu
         _argspoz.BLK:='T';
         _argspoz.STATUS:=exec('status_normal','px_poz');
         _ok:=exec('clone_pxpoz','px_cup',_argspoz,_argspz2);
         _argspoz.BLK:='N';
::       klonuje wykonywane pozycje planu
         {? _ok>0
         || _argspoz.STATUS:=exec('status_wyk1','px_poz');
            _ok:=exec('clone_pxpoz','px_cup',_argspoz,_argspz2);
            _argspoz.STATUS:=''
         ?};
::       klonuje wykonane pozycje planu
         {? _ok>0
         || _argspoz.STATUS:=exec('status_wyk2','px_poz');
            _ok:=exec('clone_pxpoz','px_cup',_argspoz,_argspz2);
            _argspoz.STATUS:=''
         ?};
::       klonuje pozycje planu utworzone na podstawie planu operacyjnego
         {? _ok>0
         || _argspoz.OPER:='T';
            _argspoz.STATUS:=exec('status_normal','px_poz');
            _ok:=exec('clone_pxpoz','px_cup',_argspoz,_argspz2);
            _argspoz.OPER:='N'
         ?}
     |? _args.MODE=2
     ||
::       klonuje wszystkie pozycje planu bez wzgledu na status
         _argspoz.STATUS:='';
         _ok:=exec('clone_pxpoz','px_cup',_argspoz,_argspz2);
         {? _ok>0 & PX_VAR.NAST_ALG=2
         || _ok:=exec('clone','px_cal',_args.SOURCE,_cloned)
         ?}
     ?}
   ?};
   {? _ok>0 & _args.MODE=0 & PX_VAR.NAST_ALG=2
   || _ok:=exec('clone','px_cal',_args.SOURCE,_cloned)
   ?};

:: jesli czyscilem ilosci zajete to po sklonowaniu pozycji planu musze odtworzyc te ilosci
   {? _args.MODE=1
   ||
      _eaten:=exec('cap_eaten','px_cup');
      _sum:=exec('array_sum','#array',_eaten);
      {? _sum>0
      ||
         {! _it:=1.._il_wym
         |! _rule:=$('_eaten:=_a;PX_CUP.CAP_USE'+$_it+':=_eaten['+$_it+']');
            _rule(_eaten)
         !};
         _ok:=PX_CUP.put()
      ?};
::    renumeracja pozycji planu - w MODE=1 klonuja sie tylko zablowane pozycje wiec trzeba im
::    zregenerowac numerki
      exec('renumerate','px_poz',PX_CUP.ref());

      {? _ok>0 & PX_VAR.NAST_ALG=2
      || _ok:=exec('rebuild4cup','px_cal',_cloned)
      ?}
   ?};

   pxkomm.sect_end()
|| _msg:='Nie znaleziono pojemnika do duplikowania: '+$_args.SOURCE;
   pxkomm.error(_msg)
?};
{? _ok>0
|| _result:=1
?};

PX_CUP.cntx_pop();
PX_POZ.cntx_pop();
_result


\clone_pxpoz_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Tablica parametrów dla clone_pxpoz
::   WY: _args
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new('PX_VER',
               'PX_KONT',
               'CUP_SRC',
               'CUP_DST',
               'STATUS',
               'BLK',
               'OPER'
               );
_args.PX_VER:=null();
_args.PX_KONT:=null();
_args.CUP_SRC:=null();
_args.CUP_DST:=null();
_args.STATUS:='';
_args.BLK:='N';
_args.OPER:='N';
:: zwracamy deklaracje argumentow
_args


\clone_pxpoz
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Klonuje pozucje planu na pojemniku - moze sklonowac wszystkie pozycje planu, lub tylko o okreslonym statusie
::   WE: _a - _args - wynik formuly exec('clone_pxpoz_a','px_cup')
::       [_b] _args2 - wynik formuly exec('clone_a','px_poz')
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('clone_pxpoz_a','px_cup')
?};

{? var_pres('_b')>100
|| _argspoz:=_b
|| _argspoz:=exec('clone_a','px_poz');
   _argspoz.PX_VER:=_args.PX_VER;
   _argspoz.PX_KONT:=_args.PX_KONT;
   _argspoz.PX_CUP:=_args.CUP_DST;
   ~~
?};

_argspoz.SOURCE:=null();
_argspoz.PX_GRP:=null();

_can_continue:=1;
_result:=0;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

_msg:='Duplikowanie pozycji planu do pojemnika: '+PX_CUP.SYMBOL;
pxkomm.sect_beg(_msg);

PX_POZ.cntx_psh();
{? _args.BLK='T'
|| PX_POZ.index('BLK');
   {? _args.STATUS<>''
   || PX_POZ.prefix(_args.CUP_SRC,_args.BLK,_args.STATUS)
   || PX_POZ.prefix(_args.CUP_SRC,_args.BLK)
   ?}
|? _args.OPER='T'
|| PX_POZ.index('OPER');
   _kont:=exec('FindAndGet','#table',PX_CUP,_args.CUP_SRC,,"PX_KONT",null());
   {? _args.STATUS<>''
   || PX_POZ.prefix(_args.OPER,_kont,_args.CUP_SRC,_args.STATUS)
   || PX_POZ.prefix(_args.OPER,_kont,_args.CUP_SRC)
   ?}
|? _args.STATUS<>''
|| PX_POZ.index('STATUS');
   PX_POZ.prefix(_args.CUP_SRC,_args.STATUS)
|| PX_POZ.index('LP');
   PX_POZ.prefix(_args.CUP_SRC)
?};
{? PX_POZ.first()
||
   {!
   |? _argspoz.SOURCE:=PX_POZ.ref();

::    trzeba powiazac klonowana pozycje planu z PX_GRP ktore rowniez zostalo wczesniej sklonowane
::    klonujac PX_GRP nawija sie pole PX_GRP.UID_SRC dzieki ktoremu stojac na pozycji planu ktora ma
::    byc klonowana moge odszukac klony PX_GRP i powiazac z nimi pozycje planu
      PX_GRP.cntx_psh();
      PX_GRP.index('UID_SRC');
      {? PX_POZ.PX_GRP<>null()
      ||
         PX_GRP.prefix(_args.PX_VER,PX_POZ.PX_GRP().UID);
         {? PX_GRP.first()
         || _argspoz.PX_GRP:=PX_GRP.ref()
         ||
::          jeśli nie da sie przepiac px_poza do innego px_grp to zostawiam mu PX_GRP
::          taki jaki byl ustawiony do tej pory, bo byc moze byl przepiety juz wczesniej
            _argspoz.PX_GRP:=PX_POZ.PX_GRP
         ?}
      ?};
      PX_GRP.cntx_pop();

::    !!! KLONOWANIE POZYCJI PLANU !!!
      _can_continue:=exec('clone','px_poz',_argspoz);
       PX_POZ.next() & _can_continue>0
   !}
?};
{? _can_continue>0
|| _result:=1
?};
PX_POZ.cntx_pop();
pxkomm.sect_end();
_result


\cap_eaten
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Zwraca zajeta pojemnosc na pojemniku we wszystkich wymiarach
::       Kontekst pracy - PX_CUP - pojemnik,
::   WE: [_a] - INTEGER -  0 - zbierac z pojemnosci wyliczonych na pojemniku
::                        [1] - iterowac po pozycjach planu
::   WY: DICT - tablica  - zajeta pojemnosc we wszystkich wymiarach
::----------------------------------------------------------------------------------------------------------------------
_mode:=1;
{? var_pres('_a')=type_of(0)
|| _mode:=_a
?};

_il_wym:=PX_CUP.PX_KONT().IL_WYM;
_result:=obj_new(_il_wym);

::inicjuje tablice
{! _it:=1.._il_wym
|! _result[_it]:=0
!};

{? _il_wym>0
||
   {? _mode=0
   ||
      {! _it:=1.._il_wym
      |! _cap_use:=($('PX_CUP.CAP_USE'+$_it))();
         _result[_it]+=_cap_use
      !}
   |? _mode=1
   ||
      PX_POZ.cntx_psh();
      PX_POZ.index('LP');
      PX_POZ.prefix(PX_CUP.ref());
      {? PX_POZ.first()
      || {!
         |?
            {! _it:=1.._il_wym
            |! _cap_eat:=($('PX_POZ.CAP_EAT'+$_it))();
               _result[_it]+=_cap_eat
            !};
            PX_POZ.next()
         !}
      ?};
      PX_POZ.cntx_pop()
   ?}
?};
_result


\cap_wyk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.10]
:: OPIS: Zwraca wykonana pojemnosc na pojemniku we wszystkich wymiarach
::       Kontekst pracy - PX_CUP - pojemnik,
::   WY: DICT - tablica  - zajeta pojemnosc we wszystkich wymiarach
::----------------------------------------------------------------------------------------------------------------------
_il_wym:=PX_CUP.PX_KONT().IL_WYM;
_result:=obj_new(_il_wym);

::inicjuje tablice
{! _it:=1.._il_wym
|! _result[_it]:=0
!};

{? _il_wym>0
|| PX_POZ.cntx_psh();
   PX_POZ.index('LP');
   PX_POZ.prefix(PX_CUP.ref());
   {? PX_POZ.first()
   || {!
      |?
         {! _it:=1.._il_wym
         |! _cap_eat:=($('PX_POZ.CAP_WYK'+$_it))();
            _result[_it]+=_cap_eat
         !};
         PX_POZ.next()
      !}
   ?};
   PX_POZ.cntx_pop()
?};
_result


\cap_max
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca maksymalna pojemnosc pojemnika we wszystkich wymiarach
::       Kontekst pracy - PX_CUP - pojemnik
::   WY: DICT - tablica  - maksymalna pojemnosc we wszystkich wymiarach
::----------------------------------------------------------------------------------------------------------------------

_il_wym:=PX_CUP.PX_KONT().IL_WYM;
_result:=obj_new(_il_wym);

::inicjuje tablice
{! _it:=1.._il_wym
|! _result[_it]:=0
!};

{? _il_wym>0
|| {! _it:=1.._il_wym
   |! _cap_max:=($('PX_CUP.CAP_MAX'+$_it))();
      _result[_it]+=_cap_max
   !}
?};
_result


\cap_min
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Zwraca minimalna pojemnosc pojemnika we wszystkich wymiarach
::       Kontekst pracy - PX_CUP - pojemnik
::   WY: DICT - tablica  - maksymalna pojemnosc we wszystkich wymiarach
::----------------------------------------------------------------------------------------------------------------------

_il_wym:=PX_CUP.PX_KONT().IL_WYM;
_result:=obj_new(_il_wym);

::inicjuje tablice
{! _it:=1.._il_wym
|! _result[_it]:=0
!};

{? _il_wym>0
|| {! _it:=1.._il_wym
   |! _cap_min:=($('PX_CUP.CAP_MIN'+$_it))();
      _result[_it]+=_cap_min
   !}
?};
_result


\px_cup_cap_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed wyswietl dla pol PX_CUP.CAP*
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_dim:=#(_fld+1);
_result:='';
_infinity:=exec('infinity_array','px_kont',PX_CUP.PX_KONT);
{? PX_CUP.PX_KONT().IL_WYM<_dim
|| _result:=exec('color_noavail','px_param')
|? (7+_fld='CAP_MAX' | 7+_fld='CAP_MIN') & _infinity[_dim]>0
|| _result:=exec('color_noavail','px_param')
?};
_result


\px_cup_cap_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed redakcja dla pol PX_CUP.CAP*
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_dim:=#(_fld+1);
{? PX_CUP.PX_KONT().IL_WYM<_dim || 0 || 1 ?}


\px_cup_cap_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Po redakcji dla pol PX_CUP.CAP*
::----------------------------------------------------------------------------------------------------------------------
{? fld()<0
|| FUN.emsg('Pojemność nie może być ujemna.'@);
   0
|| 1
?}


\px_cup_cap_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Format wyswietlania dla pol PX_CUP.CAP*
::----------------------------------------------------------------------------------------------------------------------
_wymiar:=cur_afld()+1;
'out_prec='+$($('PX_CUP.PX_KONT().PREC'+_wymiar))()


\px_cup_cap_fe
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Format redagowania dla pol PX_CUP.CAP*
::----------------------------------------------------------------------------------------------------------------------
''


\px_cup_start_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed redakcja dla pol PX_CUP.START*
::----------------------------------------------------------------------------------------------------------------------
{? -menu_txt()='dołącz' || 1 || 0 ?}


\px_cup_start_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Po redakcji dla pol PX_CUP.START*
::----------------------------------------------------------------------------------------------------------------------
1


\px_cup_end_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed redakcja dla pol PX_CUP.END*
::----------------------------------------------------------------------------------------------------------------------
{? -menu_txt()='dołącz' || 1 || 0 ?}


\px_cup_end_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Po redakcji dla pol PX_CUP.END*
::----------------------------------------------------------------------------------------------------------------------
1


\px_cup_symb_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed redakcja dla pola PX_CUP.SYMBOL, PX_CUP.LABEL
::----------------------------------------------------------------------------------------------------------------------
{? -menu_txt()='dołącz' || 1 || 0 ?}


\px_cup_symb_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Po redakcji dla pola PX_CUP.SYMBOL, PX_CUP.LABEL
::----------------------------------------------------------------------------------------------------------------------
1


\px_cup_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wyświetla szczegóły pojemnika
::       Kontekst pracy - PX_POZ
::----------------------------------------------------------------------------------------------------------------------
DATY.cntx_psh();
PX_CUP.cntx_psh();
PX_CUP.index('UID');
PX_CUP.prefix(PX_POZ.PX_CUP().UID);
PX_CUP.win_edit('RED');
::PX_CUP.select(,,,{? exec('mainversion_vie','px_ver') & PX_VAR.EDIT=1 || 'p' || 'Wp' ?});
PX_CUP.btn_eopt('RED','WYKONANIE',
   {? exec('mainversion_vie','px_ver') & PX_VAR.EDIT=1 & exec('get','#params',500613,2)='T'
   || 'state=normal'
   || 'state=grayed'
   ?}
);
exec('px_cup_efld_opt','px_cup');
{? PX_CUP.first() || PX_CUP.display() ?};
PX_CUP.cntx_pop();
DATY.cntx_pop();
~~


\px_cup_popraw
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Poprawianie pojemnosci pojemnika
::----------------------------------------------------------------------------------------------------------------------
_pre_max:=exec('cap_max','px_cup');
_pre_min:=exec('cap_min','px_cup');

_cap_mod:=0;

PX_CUP.win_edit('RED');
{? PX_CUP.edit()
|| _post_max:=exec('cap_max','px_cup');
   _post_min:=exec('cap_min','px_cup');

   _il_wym:=PX_CUP.PX_KONT().IL_WYM;


   {? _il_wym>0
   || _can_continue:=1;
      {! _it:=1.._il_wym
      |? _can_continue>0
      |! {? _pre_max[_it]<>_post_max[_it] |
            _pre_min[_it]<>_post_min[_it]
         || _cap_mod:=1;
            _can_continue:=0
         ?}
      !}
   ?};

   {? _cap_mod>0
   || PX_CUP.MANUAL:='T'
   ?};

   {? PX_CUP.put()>0
   || {? exec('cup_cap','px_gen')>0
      ||
::       po udanym poprawieniu pojemnika rzeczywistego modyfikuje pojemniki widokowe ktorych
::       pojemnosc zalezy od tego rzeczywistego
         {? _cap_mod>0
         ||
            _can_continue:=1;
            PX_CUP.cntx_psh();
            PX_CUP.index('PARENT');
            PX_CUP.prefix(PX_CUP.UID);
            {? PX_CUP.first()
            || {!
               |? _can_continue:=exec('cup_cap','px_gen');
                  PX_CUP.next() & _can_continue>0
               !}
            ?};
            PX_CUP.cntx_pop()
         ?}
      ?}
   ?}
?};
~~


\cap_default
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Przywraca pojemnikowi domyslna pojemnosc
::       Kontekst pracy - biezacy pojemnik
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_can_continue:=1;

_group:=0;
{? PX_CUP.sel_size()>0
|| _group:=1
?};

{? _group=0
|| _can_continue:=FUN.ask('Inicjować pojemność domyślną dla: %1?'@[PX_CUP.SYMBOL])
?};

_msg:='Przywrócenie pojemności domyślnej dla: %1 nie powiodło się.'@[PX_CUP.SYMBOL];

{? _can_continue>0
||
   PX_CUP.MANUAL:='N';
   _can_continue:=PX_CUP.put();
   {? _can_continue>0
   ||
      _can_continue:=exec('cup_cap','px_gen');
      {? _can_continue>0
      ||
::       po udanym poprawieniu pojemnika rzeczywistego modyfikuje pojemniki widokowe ktorych
::       pojemnosc zalezy od tego rzeczywistego
         _can_continue:=1;
         PX_CUP.cntx_psh();
         PX_CUP.index('PARENT');
         PX_CUP.prefix(PX_CUP.UID);
         {? PX_CUP.first()
         || {!
            |? _can_continue:=exec('cup_cap','px_gen');
               PX_CUP.next() & _can_continue>0
            !}
         ?};
         PX_CUP.cntx_pop()
      ||
::       Nie udało się więc wyświetlam komunikat ostrzegawczy
         {? _group=0
         || FUN.emsg(_msg)
         || KOMM.add(_msg,2)
         ?}
      ?}
   ||
::    Nie udało się więc wyświetlam komunikat ostrzegawczy
      {? _group=0
      || FUN.emsg(_msg)
      || KOMM.add(_msg,2)
      ?}
   ?}
?};
{? _can_continue>0
|| _result:=1
?};
_result


\cap_default_gr1
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Grupa przed akcja 'pojemnosc domyslna'
::----------------------------------------------------------------------------------------------------------------------
_ok:=0;
{? FUN.ask('Zaznaczonych pojemników: %1. Czy inicjować im pojemność domyślną?'@[$PX_CUP.sel_size()])
|| _ok:=1;
:: deklaracje obiektow dla komunikatow
   exec('JCQ_decl','#message');
   {? var_pres('KOMM')<100 || KOMM:=obj_new(@.CLASS.JCQ) ?};
   KOMM.init(200,,'Przywracanie domyślnej pojemności'@)
?};
_ok


\cap_default_gr2
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Grupa po akcji 'pojemnosc domyslna'
::----------------------------------------------------------------------------------------------------------------------
KOMM.select();
~~


\ico_fill
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Zwraca ikone symbolizujaca wypelnienie pojemnika
::   WE: _a - nr pojemnika w oknie (w zasadzie znaczenie tylko dla widokowych) lub 0 (biezacy PX_CUP)
::       [_b] - nr wymiaru
::       _c - czy pojemnik rzeczywisty (1), czy widok planu (0)
::       _d - czy patrzec na aktywny wymiar (1), czy nie (0 - wtedy nie ma znaczenia _b)
::----------------------------------------------------------------------------------------------------------------------
_cup:=_a;
{? var_pres('_b')=type_of(0) || _dim:=_b || _dim:=PX_VAR.IL_WYM+1 ?};
_real:=_c;
_one_dim:=_d;

_cap_use:=_cap_min:=_cap_max:=0;

{? _one_dim
||
   PX_KONT.cntx_psh();
   _infinity:=exec('infinity_array','px_kont');
   {? _real
   ||
::    Pojemnik rzeczywisty, dane bezposrednio z PX_CUP
      {? _dim<=PX_VAR.IL_WYM
      ||
         _prec:=($('PX_CUP.PX_KONT().PREC'+$_dim))();
         _cap_use:=($('PX_CUP.CAP_USE'+$_dim))()$_prec;
         _cap_min:=($('PX_CUP.CAP_MIN'+$_dim))()$_prec;
         _cap_max:=($('PX_CUP.CAP_MAX'+$_dim))()$_prec;
         _inf:=_infinity[_dim]
      ?}
   ||
::    Widok planu, czyli dane wyszukiwane wg numeru kolumny w oknie
      {? _dim<=PX_VAR.IL_WYM
      ||
         _prec:=($('PX_KONT.PREC'+$_dim))();
         _cap_use:=($('PX_VAR.USE'+$_cup))()$_prec;
         _cap_min:=($('PX_VAR.MIN'+$_cup))()$_prec;
         _cap_max:=($('PX_VAR.MAX'+$_cup))()$_prec;
         _inf:=_infinity[_dim]
      ?}
   ?};
   PX_KONT.cntx_pop();

   {? (_cap_max=0 | _inf=1) & _cap_use=0
   ||
::    bez max i min lub nieskonczony, ale nic nie wlane - pusty kubek
      'xwin16.png:191'
   |? _inf=1 & _cap_use<>0
   ||
::    nieskonczony, ale cos wlane - pelny kubek
      'xwin16.png:201'
   ||
      {? _cap_use>=0 & _cap_use<=_cap_max
      ||
         _used:=int(_cap_use/_cap_max*10);
         {? _cap_use<_cap_min
         || 'xwin16.png:'+$(202+_used)
         || 'xwin16.png:'+$(191+_used)
         ?}
      || 'xwin16.png:223'
      ?}
   ?}
||
   PX_KONT.cntx_psh();
   {? _real
   ||
      _prop:=obj_new(PX_VAR.IL_WYM);
      {! _it:=1..PX_VAR.IL_WYM
      |! _prop[_it]:=0
      !};

      _infinity:=exec('infinity_array','px_kont',PX_CUP.PX_KONT);
::    Pojemnik rzeczywisty, dane bezposrednio z PX_CUP
      {! _it:=1..PX_VAR.IL_WYM
      |!
         _prec:=($('PX_CUP.PX_KONT().PREC'+$_it))();
         _cap_use:=($('PX_CUP.CAP_USE'+$_it))()$_prec;
         _cap_min:=($('PX_CUP.CAP_MIN'+$_it))()$_prec;
         _cap_max:=($('PX_CUP.CAP_MAX'+$_it))()$_prec;
         _inf:=_infinity[_it];

         {? (_cap_max=0 | _inf=1) & _cap_use=0
         ||
::          bez max i min lub nieskonczony, ale nic nie wlane - pusty kubek
            _prop[_it]:=0
         |? (_cap_max=0 | _inf=1) & _cap_use<>0
         ||
::          bez max lub nieskonczony, ale cos wlane - pelny kubek
            _prop[_it]:=1
         ||
            {? _cap_use>=0 & _cap_use<=_cap_max
            ||
               _prop[_it]:=_cap_use/_cap_max
            || _prop[_it]:=2
            ?}
         ?}
      !}
   ?};
   PX_KONT.cntx_pop();

   _max:=exec('array_max','#array',_prop);
   {? _max=0
   ||
::    pusty kubek
      'xwin16.png:191'
   |? _max=1
   ||
::    pełny kubek
      'xwin16.png:201'

   |? _max>0 & _max<1
   ||
::    kubek zapełniony w części
      _used:=int(_max*10);
      'xwin16.png:'+$(191+_used)
   |? _max>1
   ||
::    kubek przepełniony
      'xwin16.png:223'
   ?}
?}


\status_change
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Zmiana statusu pojemnika
::----------------------------------------------------------------------------------------------------------------------
_choice:=FUN.choice('Wybierz status.'@,,'Normalny'@,'Zaakceptowany'@,'Zablokowany'@);
{? _choice=0
|| return()
|? _choice=1
|| PX_CUP.STATUS:='N'
|? _choice=2
|| PX_CUP.STATUS:='A'
|? _choice=3
|| PX_CUP.STATUS:='B'
?};
PX_CUP.put();
~~


\px_cup_kolor_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed wyswietleniem PX_CUP.KOLOR
::   WY: STRING[11] - kolor w formacie '128:128:128'
::----------------------------------------------------------------------------------------------------------------------
_result:='255:255:255';
{? PX_CUP.KOLOR<>''
|| _split:=spli_str(PX_CUP.KOLOR,',');
   {? obj_len(_split)>1
   || _result:=_split[2]+','+_split[2]
   ?}
?};
_result


\px_cup_kolor_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Format wyswietlania pola PX_CUP.KOLOR
::----------------------------------------------------------------------------------------------------------------------
'empty=0'


\kont_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja pojemnikow dla kontenera
::   WE: _a - PX_KONT.ref()
::----------------------------------------------------------------------------------------------------------------------
PX_KONT.cntx_psh();
PX_CUP.cntx_psh();

PX_KONT.clear();
{? PX_KONT.seek(_a)
|| _what:=exec('record','#to_string',PX_KONT.ref());
   PX_CUP.index('TM_START');
   PX_CUP.prefix(PX_KONT.ref());
   {? PX_CUP.first()
   || _kind:=PX_CUP.PX_KONT().KIND;
      PX_VAR.IL_WYM:=PX_KONT.IL_WYM
   || FUN.info('Brak pojemników zasobu: %1'@[_what]);
      PX_KONT.cntx_pop();
      PX_CUP.cntx_pop();
      return()
   ?};

   _wer:=PX_CUP.mk_sel('Pojemniki'@,'P',,'#pxcupsel',,10,25,,'U',,,,1);
   PX_CUP.win_fld(_wer,,'SYMBOL');
   PX_CUP.win_fld(_wer,,'STARTD','DATA',,,,,'Od'@);
   PX_CUP.win_fld(_wer,,'STARTT',,,,,,,1);
   PX_CUP.win_fld(_wer,,'ENDD','DATA',,,,,'Do'@);
   PX_CUP.win_fld(_wer,,'ENDT',,,,,,,1);
   PX_CUP.win_fld(_wer,,'MANUAL',,,-5,,,'Ręcznie modyfikowany?'@,,,2,,"'T'","'N'");

   {? exec('mainversion_vie','px_ver')
      & PX_VAR.EDIT=1
   ||
      PX_CUP.win_act(_wer,,'Formuła','&Dołącz'@@,,'Dołączenie dodatkowego pojemnika'@,$("exec('px_cup_dolacz','px_cup',"+$#_a+")"),,,,,,'D');
      task_attach('TPP_PPS_DPLA');
      PX_CUP.win_act(_wer,,'Formuła','&Popraw'@@,,'Korekta pojemności'@,"exec('px_cup_popraw','px_cup')",,,,,,'P');
      task_attach('TPP_PPS_DPLA');
      PX_CUP.win_act(_wer,,'Formuła','&Usuń'@@,,'Usunięcie pojemnka'@,"exec('px_cup_usun','px_cup')",,,,,,'U');
      task_attach('TPP_PPS_DPLA');
      _gr1:="exec('cap_default_gr1','px_cup')";
      _gr2:="exec('cap_default_gr2','px_cup')";
      PX_CUP.win_act(_wer,,'Formuła','Pojemność do&myślna'@@,,'Wykonuje formułę na pojemność'@,"exec('cap_default','px_cup')",,,1,_gr1,_gr2,'M');
      task_attach('TPP_PPS_DPLA')
   ?};
   PX_CUP.win_act(_wer,,'Formuła','Po&zycje'@@,,,"exec('select_cup','px_poz')",,1,,,,'Z');
   PX_CUP.win_act(_wer,,'Formuła','Komu&nikaty'@@,,,"exec('select_cup','px_komm',PX_CUP.ref())",,,,,,'N');
   {? exec('is_oper_nast_time','px_param')
   || PX_CUP.win_act(_wer,,'Formuła','Kal&endarz'@@,,,"exec('select4cup','px_cal')",,,,,,'E')
   ?};

   PX_CUP.win_act(_wer,,'Formuła','&Legenda'@@,,,"exec('legenda','color','#PX_POZ#01','@PX_KOMM#01#')",,,,,,'L');
   PX_CUP.win_act(_wer,,'Rekord',,,,$("{? '"+_kind+"'='W' || PX_CUP.UID_PAR='' || ~~ ?}"));
   PX_CUP.win_fml(_wer,,'SYMBOL',,'ICON_BEFORE',"exec('ico_fill','px_cup',0,,1,0)");
   PX_CUP.win_sel(_wer);
   PX_CUP.win_edit('RED');

   PX_CUP.find_le(PX_CUP.tm_stamp());

   PX_CUP.select(,1,5)
|| FUN.info('Nie znaleziono zasobu: %1'@[$_a])
?};
PX_KONT.cntx_pop();
PX_CUP.cntx_pop();
~~


\px_cup_update
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przeliczenie sumy na pojemniku - liczy tylko wykonanie, pozostale ilosci naliczane sa w innych miejscach
::   WE: _a - PX_CUP.ref()
::----------------------------------------------------------------------------------------------------------------------
PX_CUP.cntx_psh();
PX_POZ.cntx_psh();
PX_CUP.clear();
{? PX_CUP.seek(_a)
|| _il_wym:=PX_CUP.PX_KONT().IL_WYM;
   {! _it:=1.._il_wym |! ($('PX_CUP.CAP_WYK'+$_it+':=0'))() !};
   PX_POZ.index('LP');
   PX_POZ.prefix(_a);
   {? PX_POZ.first()
   || {!
      |?
         {! _it:=1.._il_wym |! ($('PX_CUP.CAP_WYK'+$_it+'+=PX_POZ.CAP_WYK'+$_it))() !};
         PX_POZ.next()
      !}
   ?};
   PX_CUP.put()
?};
PX_POZ.cntx_pop();
PX_CUP.cntx_pop();
PX_CUP.get();
~~


\delete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Usuwa dany pojemnik
::   WE: _a - PX_CUP.ref() - pojemnik do usuniecia
::   WY: 0 - porazka
::      >0 - sukces
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_px_cup:=_a;
_can_continue:=1;

:: inicjalizacja komunikatow, jesli nie zainicjowane
{? var_pres('pxkomm')<=0
|| exec('pxkomm_init','px_logix')
?};

PX_CUP.cntx_psh();
PX_POZ.cntx_psh();
PX_CUP.clear();
{? PX_CUP.seek(_px_cup)
||
::   msg('deleting cup: '+PX_CUP.SYMBOL);
   _msg:='Usuwanie pojemnika: '+PX_CUP.SYMBOL;
   pxkomm.sect_beg(_msg);

:: 1. Usuwam pozycje planu nalezace do pojemnika
   PX_POZ.index('LP');
   PX_POZ.prefix(PX_CUP.ref);
   {? PX_POZ.first()
   || {!
      |? _can_continue:=exec('delete','px_poz',PX_POZ.ref(),0);
         PX_POZ.first() & _can_continue>0
      !}
   ?};

:: 2. Usuwam komunikaty
   {? _can_continue>0
   || _can_continue:=exec('del_cup','px_komm',PX_CUP.ref())
   ?};

:: 3. Usuwam zapisy kalendarza
   {? _can_continue>0
   || _can_continue:=exec('delete4cup','px_cal',PX_CUP.ref())
   ?};

:: 4. Usuwam pojemnik
   {? _can_continue>0
   || _result:=PX_CUP.del(,1);
      {? _result=0
      || _msg:='Nie udało się usunięcie pojemnika: '+PX_CUP.SYMBOL;
         pxkomm.error(_msg)
      ?}
   ?};
   pxkomm.sect_end()
|| _msg:='Nie znaleziono pojemnika: '+$_px_cup;
   pxkomm.error(_msg)
?};
PX_POZ.cntx_pop();
PX_CUP.cntx_pop();
_result


\status_normal
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status normalny
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'N'


\status_accepted
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status zaakceptowany
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'A'


\status_blocked
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status zablokowany
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'B'


\status_todelete
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Status do usuniecia
::   WY: STRING
::----------------------------------------------------------------------------------------------------------------------
'D'


\px_cup_dolacz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Dolaczanie dodatkowego pojemnika
::   WE: _a - #PX_KONT.ref()
::----------------------------------------------------------------------------------------------------------------------
PX_CUP.cntx_psh();
PX_KONT.cntx_psh();
PX_KONT.clear();
{? PX_KONT.seek(_a,)
||
   PX_CUP.blank();
   PX_CUP.PX_VER:=exec('get_mainversion','px_ver');
   PX_CUP.PX_KONT:=PX_KONT.ref();
   PX_CUP.MANUAL:='T';

   PX_CUP.win_edit('RED');
   {? PX_CUP.edit("exec('px_cup_valid','px_cup')")
   ||
      PX_CUP.TM_START:=exec('create','#tm_stamp',PX_CUP.STARTD().DATA,PX_CUP.STARTT);
      PX_CUP.TM_END:=exec('create','#tm_stamp',PX_CUP.ENDD().DATA,PX_CUP.ENDT);
      PX_CUP.TM_WALL1:=PX_CUP.TM_START;
      PX_CUP.TM_WALL2:=PX_CUP.TM_END;
      PX_CUP.KOLOR:=exec('cup_color','px_gen',PX_CUP.TM_START);
      PX_CUP.CAL_LVL:=1;
      {? PX_CUP.add()>0
      ||
::       po udanym dolaczeniu pojemnika rzeczywistego dogenerowuje okoliczne, dzieki czemu aktualizuje widokowe
         KOMM.init();
         exec('cup_generator','px_gen',PX_KONT.ref(),PX_CUP.STARTD().DATA,PX_CUP.ENDD().DATA);
         KOMM.select()
      ?}
   ?}
?};
PX_CUP.cntx_pop();
PX_KONT.cntx_pop();
~~


\px_cup_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Walidacja rekordu PX_CUP - sprawdzenie, czy zakres znacznikow czasowych jest dostepny
::       oraz czy spelnia wymagania parametrow 500351 (rozdzielczosc) i 500359 (offset)
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
_res:=chk_rec('SYMBOL','LABEL','STARTD','ENDD');
{? _res=''
||
   _step:=exec('get','#params',500351,1);
   _minute_stamp:=exec('minute','#tm_stamp');
   _step_stamp:=_minute_stamp*_step;

   _tmstart:=exec('create','#tm_stamp',PX_CUP.STARTD().DATA,PX_CUP.STARTT);
   _tmend:=exec('create','#tm_stamp',PX_CUP.ENDD().DATA,PX_CUP.ENDT);
   _interval:=_tmend-_tmstart;

:: Sprawdzenie zaleznosci miedzy poczatkiem i koncem pojemnika
   {? _interval<=0
   || FUN.emsg('Próba dodania pojemnika o zerowym lub ujemnym czasie trwania.'@);
      return('ENDD')
   ?};

:: Sprawdzenie czy pojemnik nie ma dluzszego czasu niz okreslone na kontenerze
   PX_KONT.cntx_psh();
   {? exec('chk_max_dur','px_cup',_interval,PX_CUP.PX_KONT().MAX_CDUR)=0
   || FUN.emsg('Próba dodania pojemnika czasie trwania dłuższym niż dozwolony na zasobie.'@);
      PX_KONT.cntx_pop();
      return('ENDD')
   ?};
   PX_KONT.cntx_pop();

:: Nie sprawdzamy, czy poczatek jest zgodny z offsetem planu +- rodzielczosc
:: - ustalone, ze pojemniki rzeczywiste moga miec inne przesuniecie niz widokowe


:: Sprawdzenie czasu trwania pojemnika
   {? _interval<_step_stamp
   || FUN.emsg('Próba dodania pojemnika o czasie trwania mniejszym niż globalna rozdzielczość planu.'@);
      return('ENDD')
   ?};
   {? _interval%*_step_stamp<>0
   || FUN.emsg('Próba dodania pojemnika o czasie trwania, który nie jest wielokrotnością globalnej rozdzielczości planu.'@);
      return('ENDD')
   ?};

:: Znajdz pierwszy zaczynajacy sie wczesniej i sprawdz jego koniec
   PX_CUP.cntx_psh();
   PX_CUP.index('TM_START');
   PX_CUP.prefix(PX_CUP.PX_KONT);
   {? PX_CUP.find_le(_tmstart)
   || {? PX_CUP.TM_END>_tmstart
      || FUN.emsg(
            'Wprowadzony pojemnik: %1 ÷ %2\n'
            'pokrywa się z poprzednim: %3 ÷ %4'@[(19+tm_form(_tmstart)),(19+tm_form(_tmend)),(19+tm_form(PX_CUP.TM_START)),(19+tm_form(PX_CUP.TM_END))]
         );
         PX_CUP.cntx_pop();
         return('STARTD')
      ?}
   ?};
   PX_CUP.cntx_pop();

:: Znajdz pierwszy konczacy sie pozniej i sprawdz jego poczatek
   PX_CUP.cntx_psh();
   PX_CUP.index('TM_END');
   PX_CUP.prefix(PX_CUP.PX_KONT);
   {? PX_CUP.find_ge(_tmend)
   || {? PX_CUP.TM_START<_tmend
      || FUN.emsg(
            'Wprowadzony pojemnik: %1 ÷ %2\n'
            'pokrywa się z następnym: %3 ÷ %4'@[(19+tm_form(_tmstart)),(19+tm_form(_tmend)),(19+tm_form(PX_CUP.TM_START)),(19+tm_form(PX_CUP.TM_END))]
         );
         PX_CUP.cntx_pop();
         return('STARTD')
      ?}
   ?};
   PX_CUP.cntx_pop()

|| _res
?}


\update
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Uaktualnia ilosci zuzyte i wykonane na pojemniku rzeczywistym i powiazanych z nim pojemnikach widokowych
::   WE: _a - PX_CUP.ref() - pojemnik ktory aktualizuje
::       [_b] - INTEGER:  [0] - nie inicjowac pojemnosci pojemnika
::                         1 - inicjowac pojemnosc pojemnika
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_px_cup:=_a;
_init:=0;
{? var_pres('_b')=type_of(1)
|| _init:=_b
?};
_result:=0;

_can_continue:=0;

PX_CUP.cntx_psh();
PX_POZ.cntx_psh();
PX_CUP.clear();
{? PX_CUP.seek(_px_cup)
|| _il_wym:=PX_CUP.PX_KONT().IL_WYM;

   {? _init>0
   ||
::    uaktualniam wszystkie ilosci
      _can_continue:=exec('cup_cap','px_gen');
      {? _can_continue>0
      ||
         PX_CUP.cntx_psh();
         PX_CUP.index('PARENT');
         PX_CUP.prefix(PX_CUP.UID);
         {? PX_CUP.first()
         || {!
            |? exec('cup_cap','px_gen');
               PX_CUP.next()
            !}
         ?};
         PX_CUP.cntx_pop()
      ?}
   ||
::    uaktualniam tylko ilosci zajete i wykonane
      _cap_use:=exec('cap_eaten','px_cup');
      _cap_wyk:=exec('cap_wyk','px_cup');
      _sum1:=exec('array_sum','#array',_cap_use);
      _sum2:=exec('array_sum','#array',_cap_wyk);
      _can_continue:=exec('set_cap_used','px_cup',_cap_use);
      {? _can_continue>0
      || exec('set_cap_wyk','px_cup',_cap_wyk)
      ?};

      {? _can_continue>0
      ||
::       wszystkim pojemnikom widokowym ktore wskazuja na ten pojemnik ustawiam rowniez nowe
::       ilosci na podstawie ilosci pojemnika rzeczywistego
         PX_CUP.cntx_psh();
         PX_CUP.index('PARENT');
         PX_CUP.prefix(PX_CUP.UID);
         {? PX_CUP.first()
         || {!
            |?
               {? var_pres('_view_use')>100
               || obj_del(_view_use)
               ?};
               {? var_pres('_view_wyk')>100
               || obj_del(_view_wyk)
               ?};
               _view_use:=exec('array_copy','#array',_cap_use);
               _view_wyk:=exec('array_copy','#array',_cap_wyk);

               exec('array_multiply','#array',_view_use,PX_CUP.DIVIDER);
               exec('array_multiply','#array',_view_wyk,PX_CUP.DIVIDER);

               _can_continue:=exec('set_cap_used','px_cup',_view_use);
               {? _can_continue>0
               || exec('set_cap_wyk','px_cup',_view_wyk)
               ?};
               PX_CUP.next() & _can_continue>0
            !}
         ?};
         PX_CUP.cntx_pop()
      ?}
   ?}
?};

{? _can_continue>0
|| _result:=1
?};

PX_CUP.cntx_pop();
PX_POZ.cntx_pop();
_result


\uid_par4clone
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Dla sklonowanego pojemnika widokowego odszukuje pojemnik rzeczywisty
::       KONTEKST PRACY - pojemnik widokowy ktorego nalezy powiazac z rzeczywistym
::   WE: _a - PX_KONT.ref() - kontener rzeczywisty w ktorym znajduje sie pojemnik do powiazania z biezacym
::   WY: STRING - UID pojemnika rzeczywistego
::----------------------------------------------------------------------------------------------------------------------
_kont_real:=_a;
_result:='';
PX_CUP.cntx_psh();
PX_CUP.index('UID');
PX_CUP.prefix(PX_CUP.UID_SRC);
_src_tm_real:=0;
{? PX_CUP.first()
||
:: stoje na pojemiku widokowym zrodlowym
   {? PX_CUP.UID_PAR<>''
   ||
      PX_CUP.prefix(PX_CUP.UID_PAR);
      {? PX_CUP.first()
      ||
::       stoje na pojemniku rzeczywistym powiazanym ze zrodlem widokowym
::       zapamietuje tm_stamp pojemnika rzeczywistego ktory byl powiazany z widokowym zrodlem
         _src_tm_real:=PX_CUP.TM_START
      ?}
   ?};

   {? _src_tm_real>0
   ||
::    w swoim kontenerze rzeczywistym szukam pojemnika o ktory sie rozpoczyna w znalezionym czasie
      PX_CUP.index('TM_START');
      PX_CUP.prefix(_kont_real,_src_tm_real);
      {? PX_CUP.first()
      || _result:=PX_CUP.UID
      ?}
   ?}
?};
PX_CUP.cntx_pop();
_result


\set_cap_used
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Ustawia pojemnikowi zuzyte pojemnosci
::       KONTEKST PRACY - Pojemnik ktoremu te pojemnosci nawinac
::   WE: _a - obj_new() - tablica ze zuzytymi pojemnosciami w kolejnych wymiarach
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_caps:=_a;

_result:=0;

_il_wym:=PX_CUP.PX_KONT().IL_WYM;
{! _it:=1.._il_wym
|! _rule:=$('  _cap:=_a;
               PX_CUP.CAP_USE'+$_it+':=_cap
           ');
   _rule(_caps[_it])
!};
_result:=PX_CUP.put();

_result


\set_cap_wyk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.30]
:: OPIS: Ustawia pojemnikowi wykonane pojemnosci
::       KONTEKST PRACY - Pojemnik ktoremu te pojemnosci nawinac
::   WE: _a - obj_new() - tablica z wykonanymi pojemnosciami w kolejnych wymiarach
::   WY: 0 - porazka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_caps:=_a;

_result:=0;

_il_wym:=PX_CUP.PX_KONT().IL_WYM;
{! _it:=1.._il_wym
|! _rule:=$('  _cap:=_a;
               PX_CUP.CAP_WYK'+$_it+':=_cap
           ');
   _rule(_caps[_it])
!};
_result:=PX_CUP.put();

_result


\px_cup_usun
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Usuniecie pojemnika - w kontekscie okna wertowania i pojemnikow rzeczywistych
::----------------------------------------------------------------------------------------------------------------------
:: Sprawdzenie, czy sa powiazania do pojemnika
PX_POZ.index('LP');
PX_POZ.prefix(PX_CUP.ref());
{? PX_POZ.first()
|| FUN.info('Nie można usunąć pojemnika z pozycjami.'@)
|| {? FUN.ask('Czy usunąć pojemnik?'@)
   ||
::    Wlasciwe usuniecie pojemnika rzeczywistego
      exec('delete','px_cup',PX_CUP.ref())
   ?}
?};
~~


\chk_max_dur
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Sprawdza czy przekazany interwal czasu nie przekroczy max czasu trwania okreslonego na kontenerze
::       Jesli interwal czasu nie podany to go obliczam na podstawie aktualnego rekordu PX_CUP
::       KONTEKST PRACY - PX_CUP, PX_KONT
::   WE: [_a] - REAL - dlugosc interwalu
::       _b - STRING - PX_KONT.MAX_CDUR
::   WY: 0 - interwal czasu przekracza maksimum
::       1 - interwal nie przekracza maksimum
::----------------------------------------------------------------------------------------------------------------------
_interval:=0;
{? var_pres('_a')=type_of(0)
|| _interval:=_a
|| _interval:=PX_CUP.TM_END-PX_CUP.TM_START
?};

_level:=_b;

_result:=1;

{? _level='M'
|| _month:=exec('month','#tm_stamp');
   {? _interval>_month
   || _result:=0
   ?}
|? _level='T'
|| _week:=exec('week','#tm_stamp');
   {? _interval>_week
   || _result:=0
   ?}
|? _level='D'
|| _day:=exec('day','#tm_stamp');
   {? _interval>_day
   || _result:=0
   ?}
?};
_result


\view_filter
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Prefiksuje tabele PX_CUP na podstawie przekazanego interwalu czasu
::   WE: _a - REAL - tm_stamp poczatkowy
::       _b - REAK - tm_stamp koncowy
::       _c - PX_KONT.ref()
::   WY: 0/1 - czy filtr zostal nalozony, czy nie
::----------------------------------------------------------------------------------------------------------------------
_start:=_a;
_end:=_b;
_px_kont:=_c;

_aa:='NOT(PX_CUP.TM_END>:_f      AND PX_CUP.TM_END<:_g)';
_bb:='NOT(PX_CUP.TM_START>=:_f   AND PX_CUP.TM_END<=:_g)';
_cc:='NOT(PX_CUP.TM_START>=:_f   AND PX_CUP.TM_START<:_g)';
_dd:='NOT(PX_CUP.TM_START<:_f    AND PX_CUP.TM_END>:_g)';
_ee:='PX_CUP.PX_KONT=:_h';

_result:=PX_CUP.f_set('TM_START' ,
                                 ,
                                 'NOT (:_a AND :_b AND :_c AND :_d) AND :_e',
                                 _aa,_bb,_cc,_dd,_ee,_start,_end,_px_kont
                                 );
_result


\kolor_komm
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MBUILDER
::  UTW: WH [17.00]
:: OPIS: Przed wyswietleniem pola PX_CUP.SYMBOL
::   WY: STRING lub ~~
::----------------------------------------------------------------------------------------------------------------------
_result:=~~;

_can_continue:=1;

{? cur_tab(1,1)=PX_CUP
|| PX_KOMM.cntx_psh();
   PX_KOMM.index('PX_CUP');

:: 1. Sprawdzam czy sa bledy
   PX_KOMM.prefix(PX_CUP.ref(),exec('type_error','px_komm'));
   {? PX_KOMM.size()>0
   || _result:=Color.fnd_kol('PX_KOMM#01#KOM_ERR');
      _can_continue:=0
   ?};
   {? _can_continue>0
   ||
::    2. Sprawdzam czy sa ostrzezenia
      PX_KOMM.prefix(PX_CUP.ref(),exec('type_warning','px_komm'));
      {? PX_KOMM.size()>0
      || _result:=Color.fnd_kol('PX_KOMM#01#KOM_WARN');
         _can_continue:=0
      ?}
   ?};
   {? _can_continue>0
   ||
::    3. Sprawdzam czy sa informacje
      PX_KOMM.prefix(PX_CUP.ref(),exec('type_info','px_komm'));
      {? PX_KOMM.size()>0
      || _result:=Color.fnd_kol('PX_KOMM#01#KOM_INFO');
         _can_continue:=0
      ?}
   ?};
   PX_KOMM.cntx_pop()
?};
_result


\cup_level
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Zwraca 'poziom' pojemnika na podstawie jego czasu trwania
::   WE: [_a] - PX_CUP.ref - pojemnik ktory badac lub aktualny pojemnik jesli nie podane
::   WY: STRING - poziom widoku pojemnika 'R','M','T','D'
::----------------------------------------------------------------------------------------------------------------------
_px_cup:=null();
{? var_pres('_a')=type_of(PX_CUP.ref())
|| _px_cup:=_a
?};

_can_continue:=1;
_result:='';

PX_CUP.cntx_psh();
PX_CUP.clear();
{? _px_cup<>null()
|| {? PX_CUP.seek(_px_cup)
   || _can_continue:=1
   ?}
?};

{? _can_continue>0
||
   _result:='D';
:: Obliczam czas trwania pojemnika
   _duration:=PX_CUP.TM_END-PX_CUP.TM_START;

   {? _duration>exec('day','#tm_stamp')
   || _result:='T'
   ?};
   {? _duration>exec('week','#tm_stamp')
   || _result:='M'
   ?};
   {? _duration>exec('month','#tm_stamp')
   || _result:='K'
   ?};
   {? _duration>exec('quarter','#tm_stamp')
   || _result:='R'
   ?}
?};
PX_CUP.cntx_pop();
_result


\px_cup_efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Opcje pól w oknach redagowania PX_CUP
::----------------------------------------------------------------------------------------------------------------------
{! _it:=1..exec('il_wym','px_param')
|! {? _it<=PX_KONT.IL_WYM || _enable:='1' || _enable:='0' ?};
   PX_CUP.efld_opt('RED','enable='+_enable,PX_KONT,'JM'+$_it);
   PX_CUP.efld_opt('RED','enable='+_enable,,'CAP_MIN'+$_it);
   PX_CUP.efld_opt('RED','enable='+_enable,,'CAP_MAX'+$_it);
   PX_CUP.efld_opt('RED','enable='+_enable,,'CAP_USE'+$_it);
   PX_CUP.efld_opt('RED','enable='+_enable,,'CAP_WYK'+$_it)
!};
~~


\put_time
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Ustala pojemnikowi nowe granice czasowe
::   WE: [_a] - PX_CUP.ref lub bieżący rekord
::       _b - REAL - nowy początek
::       _c - REAL - nowy koniec
::       [_d] - INTEGER - 0/1 - czy odtwarzać kalendarz
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_CUP.ref())
|| _ref:=_a
?};
_tm_start:=_b;
_tm_end:=_c;
_rebuild_cal:=1;
{? var_pres('_d')=type_of(0)
|| _rebuild_cal:=_d
?};

_result:=0;
_can_continue:=1;

PX_CUP.cntx_psh();
{? _ref<>null()
|| PX_CUP.prefix();
   {? PX_CUP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   PX_CUP.TM_START:=_tm_start;
   PX_CUP.TM_END:=_tm_end;
   PX_CUP.TM_WALL1:=_tm_start;
   PX_CUP.TM_WALL2:=_tm_end;
   PX_CUP.STARTD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',_tm_start));
   PX_CUP.STARTT:=exec('tm_stamp2time','#tm_stamp',_tm_start);
   PX_CUP.ENDD:=exec('get','daty',exec('tm_stamp2date','#tm_stamp',_tm_end));
   PX_CUP.ENDT:=exec('tm_stamp2time','#tm_stamp',_tm_end);
   _can_continue:=PX_CUP.put();

   {? _rebuild_cal>0 & _can_continue>0 & PX_VAR.NAST_ALG=2
   || exec('rebuild4cup','px_cal',,0)
   ?}
?};
PX_CUP.cntx_pop();
PX_CUP.get();
{? _can_continue>0
|| _result:=1
?};
_result


\compress_pxpoz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.42]
:: OPIS: Zwraca tabelkę tymczasową skompresowanych pozycji. Jeżeli kilka pozycji
::       zazębia się ze sobą równolegle, to w tabelce wystąpią jako jeden rekord
::       który jest sumą czasu wszystkich zazębionych pozycji
::   WE: _a - PX_CUP.ref
::       _b - INTEGER - poziom kalendarza
::   WY: tab_tmp
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_px_cup:=_a;
_lane:=_b;

_poz:=tab_tmp(2
:: 'POLE','TYP','Nazwa w oknie',
   ,'TM_START','REAL','Czas rozpoczęcia'
   ,'TM_END','REAL','Czas zakończenia'
   ,'STATUS','STRING[20]','Status - dla kompatybilności z PX_POZ'
   ,'REF','STRING[16]','SQL ref PX_POZ'
);

_res:=tab_tmp(2
:: 'POLE','TYP','Nazwa w oknie',
   ,'TM_START','REAL','Czas rozpoczęcia'
   ,'TM_END','REAL','Czas zakończenia'
   ,'STRSTART','STRING[20]','Czas rozpoczęcia (string)'
   ,'STREND','STRING[20]','Czas zakończenia (string)'
   ,'STATUS','STRING[20]','Status - dla kompatybilności z PX_POZ'
   ,'REF','STRING[16]','SQL ref PX_POZ'
);

PX_POZ.cntx_psh();
PX_POZ.index('LANE');
PX_POZ.prefix(_px_cup,_lane);
{? PX_POZ.first()
|| {!
   |? {? PX_POZ.STATUS<>exec('status_wyk2','px_poz')
      || _poz.blank();
         _poz.TM_START:=PX_POZ.TM_START;
         _poz.TM_END:=PX_POZ.TM_END;
         _poz.REF:=$PX_POZ.ref();
         _poz.add()
      ?};
      PX_POZ.next()
   !}
?};
_ndx_start:=_res.ndx_tmp(,,'TM_START',,,'TM_END',,);
_ndx_end:=_res.ndx_tmp(,,'TM_END',,,'TM_START',,);

_res.cntx_psh();
_res.index(_ndx_end);
_res.prefix();
{? _poz.first()
||
   _interval_res:=exec('interval','#interval');
   _interval_poz:=exec('interval','#interval');
   {!
   |?
      _interval_poz.START:=_poz.TM_START;
      _interval_poz.END:=_poz.TM_END;
      {? _res.size()=0
      ||
::       Jeżeli wynikowa pusta, to przepisuję rekord
         _res.blank();
         _res.TM_START:=_poz.TM_START;
         _res.TM_END:=_poz.TM_END;
         _res.REF:=_poz.REF;
         _res.STRSTART:=tm_form(_res.TM_START);
         _res.STREND:=tm_form(_res.TM_END);
         _res.add()
      ||
         {? _res.find_ge(_poz.TM_START)
         ||
            {!
            |?
               _next:=0;
               _ref_nxt:=null();
               _res.cntx_psh();
               {? _res.next()
               || _ref_nxt:=_res.ref()
               ?};
               _res.cntx_pop();

               {? _poz.REF<>_res.REF
               ||
                  _interval_res.START:=_res.TM_START;
                  _interval_res.END:=_res.TM_END;
                  {? var_pres('_sum')>100
                  || obj_del(_sum)
                  ?};
                  _sum:=exec('intervals_sum','#interval',_interval_res,_interval_poz);
                  {? exec('interval_dur','#interval',_sum)>0
                  ||
::                   Badana pozycja konfliktuje z tym co jest już w _res
::                   więc wydłużam rekord w _res
                     _res.TM_START:=_sum.START;
                     _res.TM_END:=_sum.END;
                     _res.STRSTART:=tm_form(_res.TM_START);
                     _res.STREND:=tm_form(_res.TM_END);
                     _res.put()
                  ||
::                   Brak konfliktu, sprawdzam czy można dodać do wynikowej pozycję o takich czasach
                     _res.cntx_psh();
                     _res.index(_ndx_start);
                     _res.prefix(_poz.TM_START,_poz.TM_END);
                     {? _res.first()=0
                     || _res.blank();
                        _res.TM_START:=_poz.TM_START;
                        _res.TM_END:=_poz.TM_END;
                        _res.REF:=_poz.REF;
                        _res.add()
                     ?};
                     _res.cntx_pop()
                  ?};
                  {? _ref_nxt<>null()
                  || _next:=_res.seek(_ref_nxt)
                  ?}
               ?};
               _next>0 & _can_continue>0 & _poz.TM_START<_res.TM_END
            !}
         ||
::          Jeżeli wynikowa nie znalazła find_ge, to przepisuję rekord
            _res.blank();
            _res.TM_START:=_poz.TM_START;
            _res.TM_END:=_poz.TM_END;
            _res.REF:=_poz.REF;
            _res.STRSTART:=tm_form(_res.TM_START);
            _res.STREND:=tm_form(_res.TM_END);
            _res.add()
         ?}
      ?};
      _can_continue:=_poz.del(,1);
      _poz.first() & _can_continue>0
   !}
?};

::{? PX_POZ.first()
::|| _interval_px:=exec('interval','#interval');
::   _interval_poz:=exec('interval','#interval');
::   {!
::   |? _interval_px.START:=PX_POZ.TM_START;
::      _interval_px.END:=PX_POZ.TM_END;
::      {? _poz.find_ge(PX_POZ.TM_START)
::      ||
::         {? _poz.first()
::         || {!
::            |? _next:=0;
::               _ref_nxt:=null();
::               _poz.cntx_psh();
::               {? _poz.next()
::               || _ref_nxt:=_poz.ref()
::               ?};
::               _poz.cntx_pop();
::
::               _interval_poz.START:=_poz.TM_START;
::               _interval_poz.END:=_poz.TM_END;
::               _sum:=exec('intervals_sum','#interval',_interval_px,_interval_poz);
::               {? exec('interval_dur','#interval',_sum)>0
::               ||
::                  _poz.TM_START:=_sum.START;
::                  _poz.TM_END:=_sum.END;
::                  _poz.put()
::               ?};
::               {? _ref_nxt<>null()
::               || _next:=_poz.seek(_ref_nxt)
::               ?};
::               _next>0 & _can_continue>0 & _poz.TM_START<PX_POZ.TM_END
::            !}
::         ?}
::      ?};
::      PX_POZ.next()
::   !}
::?};
PX_POZ.cntx_pop();
_res.ndx_drop(_ndx_start);
_res.ndx_drop(_ndx_end);
_res.cntx_pop();
_res.prefix();
_res

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:39 460a76edfa2842454d3e108d733faf80a938253475d11b1edfa4e497b21225f6b30d6b4a3d6cda0822353c74f55fbb14b42570627774756c3f6ab6bc59a4f23eff4ca37626c19877de672f7343fedf7641bc5218b9ce15228c7be103f3b10d5a278944c9127b0fe02257e4354736b619b9c76b7144b50feb938712736b9e85ee
