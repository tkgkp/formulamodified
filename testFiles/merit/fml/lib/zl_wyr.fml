:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: zl_wyr.fml
:: Utworzony: 30.11.2021
:: Autor: AKUL
::======================================================================================================================
:: Zawartość: Obsługa funkcjonalności wielu produktów do zlecenia
::======================================================================================================================


\zl_wyr_add
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Przed Dołącz dla tabeli ZL_WYR
::----------------------------------------------------------------------------------------------------------------------
ZL_WYR.win_edit('RED');

ZL_WYR.blank();
{? ZL_WYR.edit("exec('zl_wyr_valid','zl_wyr',1)")
|| ZL_WYR.M_KTM:=ZL_WYR.KTM().KTM;
   {? ZL_WYR.add()
   ||
::    Dołączenie wyrobu na produkt główny zlecenia (jeżeli jeszcze nie ma)
      {? exec('zl_wyr_add_main','zl_wyr',ZL_WYR.ZL)=1
      || FUN.info('Automatycznie dołączono definicję na produkt główny zlecenia.'@)
      ?}
   ?}
?};
~~


\zl_wyr_modify
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Przed Popraw dla tabeli ZL_WYR
::----------------------------------------------------------------------------------------------------------------------
{? exec('zl_wyr_can_mod','zl_wyr')>0
|| ZL_WYR.win_edit('RED');
   {? ZL_WYR.edit("exec('zl_wyr_valid','zl_wyr',0)")
   || ZL_WYR.M_KTM:=ZL_WYR.KTM().KTM;
      ZL_WYR.put()
   ?}
|| FUN.info('Modyfikacja niemożliwa. Wyrób został już wykorzystany w systemie.'@)
?};
~~


\zl_wyr_del
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Przed Usuń dla tabeli ZL_WYR
::----------------------------------------------------------------------------------------------------------------------
{? exec('zl_wyr_can_mod','zl_wyr')>0
|| {? FUN.ask('Czy usunąć wybrany produkt?'@)
   ||
::    Sprawdzenie, czy usuwana jest definicja produktu głównego zlecenia
::    (musi zostać przynajmniej jeden zapis na produkt główny zlecenia)
      _can_del:=1;
      {? ZL_WYR.size()>1
      || _ref:=ZL_WYR.ref();
         ZL_WYR.cntx_psh();
         ZL.cntx_psh();
         ZL_WYR.index('ZL');
         ZL_WYR.prefix(ZL_WYR.ZL,ZL_WYR.ZL().KTM);
         {? ZL_WYR.first()
         || {? ZL_WYR.size()=1 & ZL_WYR.ref()=_ref
            || _msg:='Nie można usunąć rekordu.\n'
                     'Zlecenie musi posiadać przynajmniej jeden zdefiniowany wyrób, '
                     'który jest zgodny z produktem głównym zlecenia.'@;
               FUN.emsg(_msg);
               _can_del:=0
            ?}
         ?};
         ZL.cntx_pop();
         ZL_WYR.cntx_pop()
      ?};
      {? _can_del>0
      || ZL_WYR.del()
      ?}
   ?}
|| FUN.info('Usunięcie niemożliwe. Wyrób został już wykorzystany w systemie.'@)
?};
~~


\zl_wyr_can_mod
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, czy dla danego produktu zlecenia (ZL_WYR) może być wykonana operacja modyfikacji/usunięcia.
::       Działa na aktualnym buforze tabeli ZL_WYR
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_result:=1;
:: Sprawdzenie, czy do wyrobu zlecenia został już wygenerowany zapis robocizny w rozbiciu na produkty
ZL.cntx_psh();
_name:=5+ZL_WYR.name();
_msk_start:=_name+ZL_WYR.ZL().ODDZ+(2-$(ZL_WYR.ZL().OD~1));
_msk_end:=~~;
_args:=obj_new('ZL_WYR');
_args.ZL_WYR:=ZL_WYR.ref();
_rule:="
   _result:=1;
   _args:=_b;
   _zl_wyr:=_args.ZL_WYR;
   ZL_WYRGD.cntx_psh();
   ZL_WYRGD.index('ZL_WYR');
   ZL_WYRGD.prefix(_zl_wyr);
   {? ZL_WYRGD.first()
   || _result:=0
   ?};
   ZL_WYRGD.cntx_pop();
   _result
";
_result:=exec('for_each_mask','#table',ZL_WYRGD,_rule,_msk_start,_msk_end,_args,1);
ZL.cntx_pop();
:: Sprawdzenie wykorzystania w grupach operacji
{? _result=1
|| _result:=~exec('zl_wyr_czy_grop','zl_wyr',ZL_WYR.ref())
?};
_result


\zl_wyr_bl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Blank w tabeli ZL_WYR
::----------------------------------------------------------------------------------------------------------------------
_field:=cur_afld();
_res:=~~;
{? _field='ZL'
|| _res:=VAR.A_ZLEC
|? _field='MG'
|| _res:=VAR.A_ZLEC().MG
|? _field='EANL'
|| {? VAR.A_ZLEC().MG().SL='T'
   || _res:={? VAR.A_ZLEC().EANL<>null() || VAR.A_ZLEC().EANL || VAR.A_ZLEC().MG().EANL ?}
   || _res:=null()
   ?}
?};
_res


\zl_wyr_be
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Przed redagowaniem pól w tabeli ZL_WYR
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
_res:=1;
{? _fld='KTM'
||
:: Sprawdzam czy modyfikowany zapis na produkt główny zlecenia
   M.cntx_psh();
   {? -menu_txt()='popraw' & ZL_WYR.KTM=ZL_WYR.ZL().KTM
   || ZL_WYR.cntx_psh();
      ZL_WYR.index('ZL');
      ZL_WYR.prefix(ZL_WYR.ZL,ZL_WYR.ZL().KTM);
      {? ZL_WYR.size()<=1
      || _res:=0
::       Jeżeli tylko 1 zapis na proudkt główny to blokowane pole z indeksem
::       (aktualnie modyfkowany produkt jest ostatnim zapisem na produkt główny zlecenia)
      ?};
      ZL_WYR.cntx_pop()
   ?};
   M.cntx_pop();
:: Ustawienie okienka i filtra
   {? _res>0
   || exec('slo_m_ok','material','T',0,,'WEDPIUORJN(ZS)');
      exec('ktm_f_set','zl_wyr')
   ?}
|? _fld='EANL'
|| {? ZL_WYR.MG().SL='T'
   || EANX.MG:=ZL_WYR.MG;
      EANX.WYLZAL:={? EANX.MG().MWS='T' & EANX.MG().P_ALL || '' || 'T' ?};
      _res:=1
   || _res:=0
   ?}
|| ~~
?};
_res


\zl_wyr_ae
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Po redagowaniu pól w tabeli ZL_WYR
::----------------------------------------------------------------------------------------------------------------------
_fld:=cur_afld();
{? _fld='KTM'
|| {? M.f_active() || M.f_clear() ?}
|? _fld='MG'
|| {? ZL_WYR.MG().SL='T'
   || {? ZL_WYR.EANL=null() | (ZL_WYR.EANL<>null() & ZL_WYR.EANL().MG<>ZL_WYR.MG)
      ||
::       Podpowiadam lokalizację domyślną po zmianie magazynu
          ZL_WYR.EANL:=ZL_WYR.MG().EANL
      ?};
      EANX.MG:=ZL_WYR.MG;
      EANX.WYLZAL:={? EANX.MG().MWS='T' & EANX.MG().P_ALL || '' || 'T' ?}
   || ZL_WYR.EANL:=null()
   ?}
?};
1


\zl_wyr_valid
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Formuła na walidację dla produktu zlecenia (ZL_WYR)
::   WE: [_a] - miejsce wywołania: [1] - dołączanie, 0 - modyfikowanie
::       [_b] - czy wyświetlać komunikaty: [1] - tak, 0 - nie
::   WY: 1/0 lub akronim pola, które należy uzupełnić
::----------------------------------------------------------------------------------------------------------------------
_add:={? var_press('_a')=type_of(0) || _a || 1 ?};
_komm:={? var_press('_b')=type_of(0) || _a || 1 ?};
_res:='';
_res:=__CHK.record(ZL_WYR,{? _komm || ~~ || 0 ?},'ZL','KTM','MG');
:: Sprawdzenie unikalności indeksów
{? _res=''
|| _ref:={? _add>0 || null() || ZL_WYR.ref() ?};
   ZL_WYR.cntx_psh();
   ZL_WYR.index('UNIQUE');
   ZL_WYR.prefix(ZL_WYR.ZL,ZL_WYR.KTM,ZL_WYR.MG,ZL_WYR.EANL);
   {? ZL_WYR.first()
   || _res:=~(ZL_WYR.ref()<>_ref | ZL_WYR.next());
      {? _komm>0 & _res=0
      || {? ZL_WYR.EANL<>null()
         || _msg:='Produkt: \'%1\', magazyn: \'%2\', lokalizacja: \'%3\' - taki zapis już istnieje.'@
               [ZL_WYR.KTM().KTM,ZL_WYR.MG().SYM,ZL_WYR.EANL().KOD]
         || _msg:='Produkt: \'%1\', magazyn: \'%2\' - taki zapis już istnieje.'@[ZL_WYR.KTM().KTM,ZL_WYR.MG().SYM]
         ?};
         FUN.emsg(_msg)
      ?}
   ?};
   ZL_WYR.cntx_pop()
?};
_res


\zl_wyr_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Selekcja zdefiniowanych do zlecenia produktów (akcja Definicje-> Produkty)
::----------------------------------------------------------------------------------------------------------------------
ZL_WYR.win_sel('WER');
ZL_WYR.index('ZL');
ZL_WYR.prefix(VAR.A_ZLEC);
::exec('ktm_f_set','zl_wyr');
ZL_WYR.select();
{? M.f_active() || M.f_clear() ?};
~~


\ktm_f_set
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Ustawia filtr dla pola ZL_WYR.KTM/VPRODREJ.KTM /ZPARN.KTM - ustala listę półwybrobów,
::       które można przypisać jako produkty danego zlec. Działa kontekście zlecenia VAR.A_ZLEC.
::----------------------------------------------------------------------------------------------------------------------
M.cntx_psh();
_jm:=VAR.A_ZLEC().KTM().J;
_m_atr:=VAR.A_ZLEC().KTM().M_ATR;
M.cntx_pop();

_where:='A=\'T\' and R_PROD=\'T\' and RODZ=\'T\' and J=:_a ';
{? _m_atr=null()
|| _where+='and M_ATR is NULL '
|| _where+='and M_ATR=:_b'
?};
_sort:='KTM';
_from:='';

M.clear();
M.f_set(_sort,_from,_where,_jm,_m_atr);
~~


\zl_czy_wyr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, czy podane zlecenie ma zdefiniowane wielu produktów w tabeli ZL_WYR
::       (czy obsługuje funkcjonalność raportowania różnych wyrobów zlecenia)
::   WE: [_a] - ZL.ref() - jak nie podany to bieżace zlecenie
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_zl:={? var_press('_a')=type_of(null()) || _a || ZL.ref() ?};
ZL_WYR.cntx_psh();
ZL_WYR.index('ZL');
ZL_WYR.prefix(_zl);
{? ZL_WYR.first()
|| _res:=1
?};
ZL_WYR.cntx_pop();
_res


\zgp_czy_wyr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, czy do podanej operacji można rozpisać wykonanie produkcji na wiele wyrobów
::       (czy obsługuje funkcjonalność rejestrowania różnych wyrobów zlecenia)
::   WE: _a - ZGP.ref()
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_zgp:=_a;
ZGP.cntx_psh();
ZGP.clear();
{? ZGP.seek(_zgp)
|| {? ZGP.TPZ='N' & ZGP.DOK<>null() & ZGP.WEW='T' & exec('zl_czy_wyr','zl_wyr',ZGP.ZL)
   || _res:=1
   ?}
?};
ZGP.cntx_pop();
_res


\zgp_has_wyrgd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [22.26]
:: OPIS: Zwraca czy są danego ZGP są zapisy na ZL_WYRGD (używane przy poprawianiu DK)
::   WE: [_a] - ZGP.ref lub bieżący rekord
::   WY: 0 - brak zapisów
::       1 - są zapisy na ZL_WYRGD
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(ZGP.ref())
|| _ref:=_a
?};

_result:=0;
_can_continue:=1;

ZGP.cntx_psh();
{? _ref<>null()
|| ZGP.prefix();
   {? ZGP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
||
   _args:=obj_new('ZGP','RESULT');
   _args.ZGP:=ZGP.ref();
   _args.RESULT:=0;
   _fml:="
      _args:=_b;
      _result:=0;
      ZL_WYRGD.cntx_psh();
      ZL_WYRGD.index('ZGP');
      ZL_WYRGD.prefix(_args.ZGP);
      {? ZL_WYRGD.first()
      || _args.RESULT:=1;
         _result:=1
      ?};
      ZL_WYRGD.cntx_pop();
      _result
   ";
   exec('for_each_mask','#table',ZL_WYRGD,_fml,,,_args,0);
   _result:=_args.RESULT
?};
ZGP.cntx_pop();
_result


\env
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Buduje środowisko do rozpisywania wykonania produkcji na wiele produktów zlecenia
::   WE: [_a] - miejsce wywołania: [0] - rejestracja wykonania,
::                                  1 - popraw na ZLGD,
::                                  2 - Kontrola jakości,
::                                  3 - Rejestracja RP bez powiązania z robocizną
::   WY: utworzone środkowisko
::----------------------------------------------------------------------------------------------------------------------
{? var_press('__ENV_WYR')>100 || obj_del(__ENV_WYR) ?};
__ENV_WYR:=_env:=obj_new('TAB_P','WER_P','RED_P','INFO','ID_SUR','ID_BAD','ID_POP','NDX_01',
                         'WHERE','FULL','ZGP','ZL','ZLGD','PARTY','TYPYDOK');
_env.WHERE:=_where:={? var_press('_a')=type_of(0) || _a || 0 ?};
:: Czy włączony szegółowy panel rejestracji (praca na ZLGD)
_env.FULL:=_full:={? _where>0 || 1 || VEK.TERM<>'T' & VAR1.ZAK_EK<>'T' & exec('get','#params',500602)='T' ?};
:: Operacja, zlecenie dla której tworzona będzie rozpiska wykonania wg produktów
_env.ZGP:=null();
_env.ZL:=null();
:: Modyfikowany rekord ZLGD
_env.ZLGD:=null();
:: Czy zlecenie partiowane
_env.PARTY:=0;
_env.ID_SUR:=_env.ID_BAD:=_env.ID_POP:='';
:: Typ dokumentu (podczas raportowania produkcji)
_env.TYPYDOK:=null();

_env.TAB_P:=_tab:=tab_tmp(4,
   'KTM','STRING[50]','Indeks materiału',
   'M','STRING[100]','Nazwa materiału',
   'MG','STRING[8]','Magazyn',
   'EANL','STRING[20]','Lokalizacja',
   'PARTIA','STRING[25]','Partia',
   'IL','REAL','Ilość dobra',
   'IL_BRAK','REAL','Ilość braków',
   'TIME','REAL','Czas',
   'DEK_IL','REAL','Ilość deklarowana',
   'DEK_BR','REAL','Ilość deklarowana braków',
   'MREF','STRING[16]','$M.ref()',
   'MGREF','STRING[16]','$MG.ref()',
   'ZLREF','STRING[16]','$ZL.ref()',
   'ZPARN','STRING[16]','$ZPARN.ref()',
   'ZL_WYR','STRING[16]','$ZL_WYR.ref()',
   'EANLREF','STRING[16]','$EANL.ref()'
);
_tab.fld_attr(,2);
_tab.fld_attr('EANL',3);
_env.NDX_01:=_tab.ndx_tmp(,,'MREF',,,'MGREF',,,'EANLREF',,);

:: Formuły dla pól
_tab.fld_fml('IL','EDIT_FORMAT',"'in_prec='+$ST.DOKL");
_tab.fld_fml('IL_BRAK','EDIT_FORMAT',"'in_prec='+$ST.DOKL");
_tab.fld_fml('PARTIA','BEFORE_DISPLAY',"{? __ENV_WYR.PARTY>0 || 1 || 0 ?}");
_tab.fld_fml('PARTIA','BEFORE_EDIT',"{? __ENV_WYR.PARTY>0 || 1 || 0 ?}");
{? _where<>3
|| _ae:="
      _res:=1;
      _env:=__ENV_WYR;
      _tab:=_env.TAB_P;
      _full:=_env.FULL;
      {? _full>0
      || _il:=_tab.IL;
         _ilb:=_tab.IL_BRAK;
         _var_il:=VAR1.IL;
         _var_br:=VAR1.IL_BRAK;
::       Sprawdzam o ile zmieniły się wartości ilości dobrych i braków (przy poprawianiu zapisu)
         {? -menu_txt()='popraw'
         || _tab.cntx_psh();
            _tab.get();
            _il-=_tab.IL;
            _ilb-=_tab.IL_BRAK;
            _tab.cntx_pop()
         ?};
::       Dodaje różnice do wartości zmiennych
         VAR1.IL+=_il;
         VAR1.IL_BRAK+=_ilb;
         _res:=exec('po_zg_is','zl_wyk');
::       Przywracam stan początkowy wartości zmiennych
         VAR1.IL:=_var_il;
         VAR1.IL_BRAK:=_var_br
      ?};
      _res
   ";
   _tab.fld_fml('IL','BEFORE_EDIT',"{? __ENV_WYR.FULL>0 || exec('p_red_zi','zl_wyk') || 1 ?}");
   _tab.fld_fml('IL','AFTER_EDIT',_ae);
   _tab.fld_fml('IL_BRAK','BEFORE_EDIT',"{? __ENV_WYR.FULL>0 || exec('p_red_zi','zl_wyk') || 1 ?}");
   _tab.fld_fml('IL_BRAK','AFTER_EDIT',_ae)
?};

:: Okna wertowania
_env.WER_P:=_wer:=_tab.mk_sel('Rozpisanie wykonania wg wyrobów'@,'P',,'wyr_werp',,,,,
   {? VEK.TERM<>'T' || 'U' || 'N' ?},'T');
_tab.win_fld(_wer,,'KTM',,,15,,1,'Kod produktu'@);
_tab.win_fld(_wer,,'M',,,{? VEK.TERM='T' || 15 || 20 ?},,1,'Nazwa produktu'@);
_tab.win_fld(_wer,,'MG',,,-7,,1,'Magazyn'@);
_tab.win_fld(_wer,,'EANL',,,-10,,1,'Lokalizacja'@);
_tab.win_fld(_wer,,'IL',,,-12,ST.DOKL,,'Ilość dobra'@);
{? _where<>3
|| _tab.win_fld(_wer,,'IL_BRAK',,,-12,ST.DOKL,,'Ilość braków'@)
?};
{? _where=2
|| _tab.win_fld(_wer,,'DEK_IL',,,-15,ST.DOKL,,'Dekl. ilość dobra'@);
   _tab.win_fld(_wer,,'DEK_BR',,,-15,ST.DOKL,,'Dekl. ilość braków'@)
?};
::_tab.win_fld(_wer,,'TIME',,,-12,ST.DOKL,,'Czas'@);
{? _where<>3
|| _tab.win_fld(_wer,,'PARTIA',,,25,,1,'Partia'@)
?};

::Akcje
{? VEK.TERM<>'T' | VAR1.ZAK_EK='T'
||
   _before:="
      _add:={? -menu_txt()='dołącz' || 1 || 0 ?};
      _env:=__ENV_WYR;
      _full:=_env.FULL;
      _where:=_env.WHERE;
      _tab:=cur_tab(1,1);
      {? _add>0
      || _tab.blank();
         VPRODREJ.KTM:=null();
         {? _where<>3
         || VPRODREJ.ZPARN:=null()
         ?};
         VPRODREJ.ZL_WYR:=null();
         VPRODREJ.MG:=null();
         VPRODREJ.EANL:=null()
      ?};

      {? _where=3 & (_tab.IL+_tab.IL_BRAK=0) & VPRODREJ.ZPARN<>null()
      ||
::       Podpowiadanie ilości
         {? _env.PARTY>0
         || _left:=exec('ilosc_left','zl_partie',VPRODREJ.ZPARN,'M')
         || _left:=exec('ilosc_left','zl_guide',_env.ZGP,'M')
         ?};
         _sum:=exec('env_sum_il','zl_wyr',1);
         _il:=_left-_sum.IL;
         {? _il<0 || _il:=0 ?};
         _tab.IL:=_il
      ?};
      exec('env_efld_opt','zl_wyr');
      _valid:=\"
         _res:='';
         _add:={? -menu_txt()='dołącz' || 1 || 0 ?};
         _env:=__ENV_WYR;
         _full:=_env.FULL;
         _zl:=_env.ZL;
         _tab:=cur_tab(1,1);
         _res:=__CHK.record2(VPRODREJ,'KTM','Produkt'@,'MG','Magazyn'@);
         {? _res=''
         || {? _tab.IL<0
            || FUN.emsg('Ilość musi być większa od zera.'@);
               _res:='IL'
            |? _tab.IL_BRAK<0
            || FUN.emsg('Ilość musi być większa od zera.'@);
               _res:='IL_BRAK'
            |? _tab.IL+_tab.IL_BRAK<=0
            || FUN.emsg('Ilość musi być określona.'@);
               _res:='IL'
            |? _env.WHERE=2 & _tab.DEK_IL+_tab.DEK_BR<>_tab.IL+_tab.IL_BRAK
            || FUN.emsg('Łączna ilość zakwalifikowana (dobre + braki) musi być zgodna z łączną ilością deklarowaną.'@);
               _res:='IL'
            ?}
         ?};
         {? _res='' & _env.PARTY>0
         || _res:=__CHK.record(VPRODREJ,,'ZPARN');
::          Sprawdzenie zgodności KTM wyrobu i partii (przy poprawianiu zapisu ZLGD)
            {? _res='' & _env.WHERE=1 & VPRODREJ.KTM<>VPRODREJ.ZPARN().KTM
            || FUN.emsg('Produkt partii niezgodny z wyrobem zlecenia.'@);
               _res:='ZPARN'
            ?}
         ?};
         {? _res=''
         ||
:           Sprawdzenie unikalności rekordów
            _ref:={? _add=0 || _tab.ref() || null() ?};
            _tab.cntx_psh();
            _tab.index(_env.NDX_01);
            _tab.prefix($VPRODREJ.KTM,$VPRODREJ.MG,$VPRODREJ.EANL,);
            {? _tab.first()
            || {? _add>0 | (_add=0 & {? _ref<>_tab.ref() || 1 || _tab.next() ?})
               || _msg:='Istnieje już zapis dotyczący produktu: %1, magazynu: %2'@[VPRODREJ.KTM().KTM,VPRODREJ.MG().SYM]
                        +{? VPRODREJ.EANL<>null() || ', lokalizacji: %1.'@[VPRODREJ.EANL().KOD] || '.' ?};
                  FUN.emsg(_msg);
                  _res:='MG'
               ?}
            ?};
            _tab.cntx_pop()
         ?};
         _res
      \";
      {? _tab.edit(_valid,,{? _add>0 || '' || 'IL' ?})
      || {? $VPRODREJ.ZPARN<>_tab.ZPARN
         || _tab.ZPARN:=$VPRODREJ.ZPARN;
            _tab.PARTIA:=VPRODREJ.ZPARN().SYM
         ?};
::         VPRODREJ.ZL_WYR();
         {? _tab.ZL_WYR=''
         ||
::          Dodawanie/modyfikacja wpisów wprowadzonych ręcznie (nie powiązanych z ZL_WYR)
            {? _add>0
            || _tab.ZLREF:=$_env.ZL
            ?};
            _tab.KTM:=VPRODREJ.KTM().KTM;
            _tab.M:=VPRODREJ.KTM().N;
            _tab.MREF:=$VPRODREJ.KTM
         ?};
         _tab.MG:=VPRODREJ.MG().SYM;
         _tab.MGREF:=$VPRODREJ.MG;
         _tab.EANL:=VPRODREJ.EANL().KOD;
         _tab.EANLREF:=$VPRODREJ.EANL;
         {? {? _add>0 || _tab.add() || _tab.put()?}
         ||
            {? _where<>3
            ||
::             Wyliczenie sumy ilości dobrych i braków
               exec('env_sum_il','zl_wyr');
               {? _full>0
               || exec('po_zg_is','zl_wyk')
               || exec('vprod_ilbr_ae','prod_rej')
               ?};
               grp_edisp(_tab,_env.INFO,_where=2)
            ?}
         ?}
      || {? _where<>3
         || {? _full>0
            || exec('po_zg_is','zl_wyk')
            || exec('vprod_ilbr_ae','prod_rej')
            ?};
            grp_edisp(_tab,_env.INFO,_where=2)
         ?}
      ?};
      ~~
   ";
   {? _env.WHERE<>2
   || _tab.win_act(_wer,0,'Formuła','&Dołącz'@,,,_before);
      _tab.win_act(_wer,1,'Formuła','&Dołącz'@,,,_before)
   ?};
   _tab.win_act(_wer,,'Formuła','&Popraw'@,,,_before,,1);

   _before:="
      _env:=__ENV_WYR;
      _full:=_env.FULL;
      _where:=_env.WHERE;
      _tab:=cur_tab(1,1);
      {? FUN.ask('Czy usunąć zaznaczony rekord?'@)
      || {? _tab.del(,1)
         || {? _where<>3
            ||
::             Wyliczenie sumy ilości dobrych i braków
               exec('env_sum_il','zl_wyr');
               {? _full>0
               || exec('po_zg_is','zl_wyk')
               || exec('vprod_ilbr_ae','prod_rej')
               ?};
               grp_edisp(_tab,_env.INFO)
            ?}
         ?}
      ?};
      ~~
   ";
   {? _env.WHERE<>2
   || _tab.win_act(_wer,,'Formuła','&Usuń'@,,,_before)
   ?};

   _before:="
:: Podczytanie zmiennych
      _env:=__ENV_WYR;
      _tab:=_env.TAB_P;
::      VPRODREJ.ZL_WYR:=exec('FindAndGet','#table',ZL_WYR,_tab.ZL_WYR,,,null());
::      {? VPRODREJ.ZL_WYR<>null() || VPRODREJ.ZL_WYR() ?};
      VPRODREJ.KTM:=exec('FindAndGet','#table',M,_tab.MREF,,,null());
      VPRODREJ.MG:=exec('FindAndGet','#table',MG,_tab.MGREF,,,null());
      VPRODREJ.EANL:=exec('FindAndGet','#table',EANL,_tab.EANLREF,,,null());
      VPRODREJ.ZPARN:=exec('FindAndGet','#table',ZPARN,_tab.ZPARN,,,null());
      ~~
   ";
   _tab.win_act(_wer,,'Rekord',,,,_before);
   {? _where=3
   || _before:="
         _can_continue:=1;
::       Walidacja okna z rozpiską
         _env:=__ENV_WYR;
         _tab:=_env.TAB_P;
         _tab.cntx_psh();
         {? _tab.first()
         || _typydok:=_env.TYPYDOK;
::          Sprawdzenie uprawnień do typu dokumentu na magazynach
            _tab.cntx_psh();
            {!
            |?
               {? _tab.IL>0
               ||
                  _mg:=exec('FindAndGet','#table',MG,_tab.MGREF,,,null());
                  {? ~exec('chk_mg4typ','magdok_wspolne',_mg,_typydok)
                  || _mg_sym:=exec('FindAndGet','#table',MG,_mg,,\"SYM\",'');
                     _typydok_sym:=exec('FindAndGet','#table',TYPYDOK,_typydok,,\"T\",'');
                     _msg:='Brak dostępu do dokumentu: %1 na magazynie: %2.'@[_typydok_sym,_mg_sym];
                     FUN.emsg(_msg);
                     _can_continue:=0
                  ?}
               ?};
               _tab.next()
            !};
            _tab.cntx_pop();

            {? _can_continue>0
            || _sum:=exec('env_sum_il','zl_wyr',1);

               _left:=0;
               _allowed:=0;
               _ilrap:=0;

               _zparn_il:=0;
               {? _tab.ZPARN<>''
               || _zparn:=exec('FindAndGet','#table',ZPARN,_tab.ZPARN,,,null());
                  _zparn_il:=exec('FindAndGet','#table',ZPARN,_tab.ZPARN,,\"IL\",0);

                  _ilrap:=exec('get_ilosc_rp','zl_partie',_zparn);
                  _left:=exec('ilosc_left','zl_partie',_zparn,'M');
                  _allowed:=_left;
                  ~~
               ||
                  _zgh:=exec('FindAndGet','#table',ZGP,_env.ZGP,,\"NRPRZ\",null());
                  _allowed:=exec('FindAndGet','#table',ZGH,_zgh,,\"ILNPRZ\",0);

                  _args_rp:=exec('ilosc_dk_a','zl_common');
                  _args_rp.ZGH:=_zgh;
                  _args_rp.ZL:=exec('FindAndGet','#table',ZGH,_zgh,,\"ZLEC\",0);

                  _args_rp.RP:=1;
                  _ilosc_rp:=exec('get_ilosc_dk','zl_common',_args_rp);
                  _args_rp.RP:=0;
                  _args_rp.ZP:=1;
                  _ilosc_zp:=exec('get_ilosc_dk','zl_common',_args_rp);
                  _ilrap:=_ilosc_rp-_ilosc_zp;
                  _left:=_allowed-_ilrap;
                  _left:=exec('max','#math',0,_left)
               ?}
            ?};

            {? _can_continue>0 & _zparn_il>0
            || {? _sum.IL>_zparn_il
               || _msg:='Ilość wpisana (%1) przekracza ilość na partii (%2)'@[$_sum.IL,$_zparn_il];
                  _can_continue:=FUN.ask(_msg+
                         '\n\n'+'Czy na pewno wystawić dokument?'@)
               ?}
            ?};

            {? _can_continue>0 & _sum.IL>_left
            || _msg:='Łączna ilość wpisana (%1) i zaraportowana (%2) nie powinna być większa niż dozwolona (%3).'@[$_sum.IL,$_ilrap,$_allowed];
               _can_continue:=FUN.ask(_msg+
                      '\n\n'+'Czy na pewno wystawić dokument?'@)
            ?};

            {? _can_continue>0
            ||
               {? _sum.IL+_sum.IL_BRAK<=0
               || FUN.emsg('Należy rozpisać ilości na przynajmniej jednym produkcie.'@);
                  _can_continue:=0
               ?}
            ?};
            {? _can_continue>0
            ||
::             Przeszła walidacja, usuwanie rekordów z zerową ilością
               {!
               |?
                  {? _tab.IL+_tab.IL_BRAK<=0
                  || _next:=_tab.del(,1)=2
                  || _next:=_tab.next()
                  ?};
                  _next
               !}
            ?}
         || FUN.emsg('Należy rozpisać wykonanie na przynajmniej jeden produkt.'@)
         ?};
         _tab.cntx_pop();
         {? _can_continue>0
         || sel_exit()
         ?}
      ";
      _tab.win_act(_wer,,'Formuła','&Akceptuj'@,,,_before);
      _tab.win_btn(_wer,'text=%1,btn_label_align=center,panel=bottom,align=end'['&Akceptuj'@],'menu:A')
   ?};
   _tab.win_act(_wer,,'Kolejność')
?};

:: Okna redagowania
_env.RED_P:=_red:=_tab.mk_edit('Rejestracja wykonania dla produktu'@,,'wyr_redp');
_tab.win_esep(_red,'Dane podstawowe'@);
_tab.win_efld(_red,VPRODREJ,'KTM','KTM','*',40,,,'Produkt'@);
_tab.win_efld(_red,VPRODREJ,'KTM','N',,40,,,' ');
_tab.win_efld(_red,VPRODREJ,'MG','SYM','MAG',15,,,'Magazyn'@);
_tab.win_efld(_red,VPRODREJ,'EANL','KOD','MGDOK2',15,,,'Lokalizacja'@);
{? _where<>2
|| _tab.win_esep(_red,'Wykonanie'@);
   _tab.win_efld(_red,,'IL',,,15,ST.DOKL,,'Ilość — dobre'@);
   {? _where<>3
   || _tab.win_efld(_red,,'IL_BRAK',,,15,ST.DOKL,,'Ilość — braki'@)
   ?};
   _tab.win_efld(_red,VPRODREJ,'ZPARN','SYM','ZGH3',40,,,'Partia'@)
|| _tab.win_efld(_red,VPRODREJ,'ZPARN','SYM','ZGH3',40,,1,'Partia'@);
   _tab.win_esep(_red,'Ilości deklarowane'@);
   _tab.win_efld(_red,,'DEK_IL',,,15,ST.DOKL,1,'Dobre'@);
   _tab.win_efld(_red,,'DEK_BR',,,15,ST.DOKL,1,'Braki'@);
   _tab.win_esep(_red,'Ilości zakwalifikowane'@);
   _tab.win_efld(_red,,'IL',,,15,ST.DOKL,,'Dobre'@);
   _tab.win_efld(_red,,'IL_BRAK',,,15,ST.DOKL,,'Braki'@)
?};
exec('ok_esc','#window',_tab,_red);
_tab.win_edit(_red);

:: Okna informacyjne (poglądowe okno redagowania)
_win:=_tab.mk_edit(''@,,'wyr_info'+_where);
_tab.win_ewin(_win,{? _full>0 || ZLGD || VPRODREJ ?},{? _where=2 || 'KWALIFIK' |? _full>0 || 'WYR_INFO' ||
   {? VAR1.ZAK_EK<>'T' || 'ZL_WYR' || exec('vprod_win_ek','zl_wyk') ?} ?});
{? _where<>2 & _where<>3
||
   _rule:="
      _env:=__ENV_WYR;
      _full:=_env.FULL;
      {? _full>0
      || _tab:=ZLGD
      || _tab:=VPRODREJ
      ?};
      _valid:=\"
         _res:='';
         _tab:=cur_tab(1,1);
         {? _tab=VPRODREJ
         || _res:=__CHK.record(_tab,,'PLACE')
         |? _tab=ZLGD
         || _res:=__CHK.record(_tab,,'PLACE','ZMIANA')
         ?};
         _res
      \";
      exec('env_efld_opt','zl_wyr');
      {? _tab.edit(_valid)
      || 'ok'
      ?};
      ''
   ";
   _tab.win_ebtn(_win,'text="%1",panel=bottom,align=begin,edit=1,display=1'['Popraw'@],_rule);
   {? VAR1.ZAK_EK<>'T'
   || _env.ID_BAD:=_tab.win_ebtn(_win,'text="%1",panel=bottom,align=begin,edit=1,display=1'['Badanie'@],
         "exec('vp_btn_badanie','prod_rej')");
      _env.ID_SUR:=_tab.win_ebtn(_win,'text="%1",panel=bottom,align=begin,edit=1,display=1'['Surowce'@],
         "exec('vp_btn_surowce','prod_rej')")
   ?};
   _rule:="
:: Walidacja okna nagłówkowego (formuła jak przy "zwyczajnej" rejestracji)
      _validated:=__valid();
      {? (type_of(_validated)=2 & _validated='' | type_of(_validated)=1 & _validated=1)
      || _result:=1;
::       Dodatkowa walidacja przy zakańczaniu rozpoczętych operacji
         {? VAR1.ZAK_EK='T'
         || _result:=exec('setEndVar','ekioski',__valid)
         ?};
         {? _result>0
         ||
::          Walidacja okna z rozpiską
            _env:=__ENV_WYR;
            _tab:=_env.TAB_P;
            {? _tab.first()
            ||
               {!
               |?
::                Walidacja
                  _tab.next() & _result=1
               !}
            || FUN.emsg('Należy rozpisać wykonanie na przynajmniej jeden produkt.'@)
            ?}
         ?};
         {? _result>0
         || sel_exit()
         ?}
      ?};
      ''
   "
||
:: Kontrola jakości - dodanie przycisku popraw
   {? _where=2
   || _rule:="
         _env:=__ENV_WYR;
         _win:='KWALIFIK';
         ZLGD.win_edit(_win);
         ZLGD.efld_opt(_win,'editable=0',VAR1,'IL');
         ZLGD.efld_opt(_win,'editable=0',VAR1,'IL_BRAK');
         {? ZLGD.edit()
         || 'ok'
         ?};
         ZLGD.efld_opt(_win,'editable=1',VAR1,'IL');
         ZLGD.efld_opt(_win,'editable=1',VAR1,'IL_BRAK');
         ''
      ";
      _env.ID_POP:=_tab.win_ebtn(_win,'text="%1",panel=bottom,align=begin,edit=1,display=1'['Popraw'@],_rule)
   ?};

   _rule:="
:: Walidacja okna nagłówkowego (formuła jak przy "zwyczajnej" rejestracji)
   _validated:=__valid();
   {? (type_of(_validated)=2 & _validated='' | type_of(_validated)=1 & _validated=1)
   || _result:=1;
::    Walidacja okna z rozpiską
      _env:=__ENV_WYR;
      _tab:=_env.TAB_P;
      {? _tab.first()
      ||
         {!
         |?
::          Walidacja
            _tab.next() & _result=1
         !}
      || FUN.emsg('Należy rozpisać wykonanie na przynajmniej jeden produkt.'@)
      ?};
      {? _result>0
      || sel_exit()
      ?}
   ?};
   ''
   "
?};
_tab.win_ebtn(_win,'text="%1",panel=bottom,align=end,edit=1,display=1'['OK'@],_rule);
_tab.win_ebtn(_win,'text="%1",panel=bottom,align=end,edit=1,display=1'['Anuluj'@],"'key:Esc'");
_env.INFO:=_win;

:: Okno grupowe
{? _where<>3
|| _before:="
      _env:=__ENV_WYR;
      exec('env_sum_il','zl_wyr');
      {? _env.WHERE=2
      ||
::       Zaincjowanie danych przy kontroli jakości
         exec('p_red_zi','zl_wyk');
         exec('po_zg_is','zl_wyk')
      ?};
      grp_edisp(_env.TAB_P,_env.INFO);
      grp_disp(_env.TAB_P,_env.WER_P,0)
   "
|| _before:=""
?};
_grp:=_tab.grp_make('Rejestracja wykonania'@,_before,'wyr_grp',,,,,'html_maximized');
{? _where<>3
|| _ar:="";
   {? _where=2
   || _ar:="
         exec('env_efld_opt','zl_wyr');
         ~~
      "
   ?};
   _tab.grp_edit(_grp,,_env.INFO,,_ar,,,,'maximized');
   _tab.grp_splt(_grp,,'vertical','wyr_poz');
   _tab.grp_sel(_grp,,_wer,,,,,,,,,,'maximized')
||
:: Okno wyłącznie z sekcją do rozpisywania produktów
   _tab.grp_sel(_grp,,_wer,,,,,,,,,,'maximized')
?};
_tab.win_sel(_grp);
{? _full>0
|| ZLGD.win_edit('ZL_WYR')
|| {? VAR1.ZAK_EK<>'T'
   || VPRODREJ.win_edit('ZL_WYR')
   || VPRODREJ.win_edit(exec('vprod_win_ek','zl_wyk'))
   ?}
?};
ZL_WYR.win_sel('WER');

exec('env_efld_opt','zl_wyr');

_env


\fill_env
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Wypełnia tabelę środowiska __ENV_WYR dla podanej operacji - uzupełnia rekordy wyrobów do rejestracji wykonania
::   WE: _a - ZGP.ref()
::       [_b] - ZLGD.ref() - jeżeli podany, to tabela wypełniana na podstawie utworzonych wcześniej rekordów ZL_WYRGD
::       [_c] - wynik przeprowazdonej kontroli jakości: ['P'] - pozytywnie, 'N' - negatywnie
::       [_d] - ZPARN.ref() - partia domyślna, która będzie przypisana (podpowiadana) do wszystkich wyrobów
::       [_e] - ProdRej.GROPP.TAB - jeżeli podana, to tabela wypełniana na podstawie zawartości tabeli wypełnionej
::              podczas potwierdzania grupy operacji (tabela musi być odpowiedni wcześniej zprefixowana)
::----------------------------------------------------------------------------------------------------------------------
_zgp:=_a;
_zlgd:={? var_pres('_b')=type_of(null()) || _b || null() ?};
_mode:={? var_pres('_c')=type_of('') || _c || 'P' ?};
_zparn_def:={? var_pres('_d')=type_of(null()) || _d || null() ?};
_gropp_tab:={? var_pres('_e')>100 || _e || ~~ ?};
ZGP.cntx_psh();
ZGP.clear();
{? ZGP.seek(_zgp)
|| {? var_press('__ENV_WYR')<100
   || exec('env','zl_wyr')
   || __ENV_WYR.TAB_P.erase()
   ?};
   _env:=__ENV_WYR;
   _full:=_env.FULL;
   _env.ZGP:=ZGP.ref();
   _env.ZL:=ZGP.ZL;
   {? VAR.A_ZLEC=null() || VAR.A_ZLEC:=_env.ZL ?};
   _env.ZLGD:=_zlgd;
   VPRODREJ.PROD_REJ:=exec('FindInSet','#table','PROD_REJ','ZGP',ZGP.ref(),'ZL',,,,null());
   _env.PARTY:=exec('party_req','zl_wyk',ZGP.ZL);
   _tab:=_env.TAB_P;
   M.cntx_psh();
   MG.cntx_psh();
:: Utworzenie rekordów rejestracji w rozbiciu na wyrobu (na podstawie ZL_WYR);
   {? var_pres('_gropp_tab')>100
   ||
::    Potwierdzanie grupy operacji
      _gropp_tab.cntx_psh();
      ZL_WYR.cntx_psh();
      ZL_WYR.clear();
      {? _gropp_tab.first()
      || {!
         |?
            {? ZL_WYR.seek(_gropp_tab.ZL_WYR)
            || _tab.blank();
               _tab.KTM:=ZL_WYR.KTM().KTM;
               _tab.M:=ZL_WYR.KTM().N;
               _tab.MREF:=$ZL_WYR.KTM;
               _tab.IL:=_gropp_tab.IL_WYK;
               _tab.IL_BRAK:=_gropp_tab.IL-_gropp_tab.IL_WYK;
::            _tab.TIME:=ZL_WYRGD.TIME;
               _tab.ZPARN:=exec('FindAndGet','#table',ZPARN,_gropp_tab.ZPARN,,"$ZPARN.ref()",'');
               _tab.PARTIA:={? _tab.ZPARN<>'' || exec('FindAndGet','#table',ZPARN,_tab.ZPARN,,"ZPARN.SYM",'')  || '' ?};
               _tab.MG:=ZL_WYR.MG().SYM;
               _tab.MGREF:=$ZL_WYR.MG;
               {? ZL_WYR.EANL<>null()
               || _tab.EANL:=ZL_WYR.EANL().KOD;
                  _tab.EANLREF:=$ZL_WYR.EANL
               ?};
               _tab.ZLREF:=$ZGP.ZL;
               _tab.ZL_WYR:=$ZL_WYR.ref();
               _tab.add()
            ?};
            _gropp_tab.next()
         !}
      ?};
      ZL_WYR.cntx_pop();
      _gropp_tab.cntx_pop()
   |? _zlgd=null()
   ||
::    Rejestracja wykonania produkcji
      _zparn:='';
      _zparn_sym:='';
      _zgh:=ZGP.NRZLP;
      {? _zgh<>null()
      || _party_zgh:=exec('party_first_zgh','zl_guide',_zgh)
      || _party_zgh:=null()
      ?};
      {? _party_zgh<>null()
      || _party_zl:=exec('FindAndGet','#table',ZGH,_zgh,,"ZGH.ZLEC",null())
      || _party_zl:=null()
      ?};
::    Sprawdzenie, czy podano partię domyślną i może ona zostać przypisana
      {? _zparn_def<>null() & _party_zgh<>null()
      || ZPARN.cntx_psh();
         ZPARN.clear();
         {? ZPARN.seek(_zparn_def)
         || _zparn:=$ZPARN.ref();
            _zparn_sym:=ZPARN.SYM;
            {? _env.WHERE=3
            || VPRODREJ.ZPARN:=ZPARN.ref()
            ?}
         ?};
         ZPARN.cntx_pop()
      ?};
::    Sprawdzenie, czy możliwe jest podpowiedzenie partii (tylko 1 partia do przewodnika)
      {? _zparn='' & _party_zgh<>null()
      || ZPARN.cntx_psh();
         ZPARN.index('ZGH');
         ZPARN.prefix(_party_zgh);
         {? ZPARN.size()=1
         || {? ZPARN.first()
            || _zparn:=$ZPARN.ref();
               _zparn_sym:=ZPARN.SYM
            ?}
         ?};
         ZPARN.cntx_pop()
      ?};

      ZL_WYR.cntx_psh();
      ZL_WYR.index('ZL');
      ZL_WYR.prefix(ZGP.ZL);
      {? ZL_WYR.first()
      || ZPARN.cntx_psh();
         ZPARN.index('ZGH3');
         {!
         |?
            _filled_zparn:=0;
            _tab.KTM:=ZL_WYR.KTM().KTM;
            _tab.M:=ZL_WYR.KTM().N;
            _tab.MREF:=$ZL_WYR.KTM;
            _tab.IL:=0;
            _tab.IL_BRAK:=0;
            _tab.TIME:=0;
::          Sprawdzenie, czy możliwe jest podpowiedzenie partii (tylko 1 partia do przewodnika na dany KTM)
            {? _zparn='' & _party_zgh<>null() & _party_zl<>null();0
            || ZPARN.prefix(_party_zl,_party_zgh,ZL_WYR.KTM);
               {? ZPARN.first() & ZPARN.size()=1
               || _filled_zparn:=1;
                  _tab.PARTIA:=ZPARN.SYM;
                  _tab.ZPARN:=$ZPARN.ref()
               ?}
            ?};
            {? _filled_zparn=0
            || _tab.PARTIA:=_zparn_sym;
               _tab.ZPARN:=_zparn
            ?};
            _tab.MG:=ZL_WYR.MG().SYM;
            _tab.MGREF:=$ZL_WYR.MG;
            _tab.ZLREF:=$ZL_WYR.ZL;
            _tab.EANL:=ZL_WYR.EANL().KOD;
            _tab.EANLREF:=$ZL_WYR.EANL;
            _tab.ZL_WYR:=$ZL_WYR.ref();
            _tab.add();
            ZL_WYR.next()
         !};
         ZPARN.cntx_pop()
      ?};
      _tab.first();
      ZL_WYR.cntx_pop()
   ||
::    Poprawianie zapisu robocizny
      ZL_WYR.cntx_psh();
      ZL_WYRGD.cntx_psh();
      _mask:=(5+ZL_WYRGD.name())+(ref_name(_zlgd)+3);
      {? ZL_WYRGD.name()<>_mask
      || ZL_WYRGD.use(_mask)
      ?};
      ZL_WYRGD.index('ZLGD');
      ZL_WYRGD.prefix(_zlgd);
      {? ZL_WYRGD.first()
      || {!
         |?
            _tab.blank();
            _tab.KTM:=ZL_WYRGD.KTM().KTM;
            _tab.M:=ZL_WYRGD.KTM().N;
            _tab.MREF:=$ZL_WYRGD.KTM;
            {? _env.WHERE=2
            ||
::             Kontrola jakości
               {? _mode='P'
               || _tab.IL:=_tab.DEK_IL:=ZL_WYRGD.DEK_IL;
                  _tab.IL_BRAK:=_tab.DEK_BR:=ZL_WYRGD.DEK_BR
               || _tab.DEK_IL:=ZL_WYRGD.DEK_IL;
                  _tab.DEK_BR:=ZL_WYRGD.DEK_BR;
                  _tab.IL:=0;
                  _tab.IL_BRAK:=_tab.DEK_IL+_tab.DEK_BR
               ?}
            || _tab.IL:=ZL_WYRGD.IL+ZL_WYRGD.DEK_IL;
               _tab.IL_BRAK:=ZL_WYRGD.IL_BRAK+ZL_WYRGD.DEK_BR
            ?};
::            _tab.TIME:=ZL_WYRGD.TIME;
            _tab.ZPARN:=$ZL_WYRGD.ZPARN;
            _tab.PARTIA:={? _tab.ZPARN<>'' || exec('FindAndGet','#table',ZPARN,_tab.ZPARN,,"ZPARN.SYM",'')  || '' ?};
            _tab.MG:=ZL_WYRGD.MG().SYM;
            _tab.MGREF:=$ZL_WYRGD.MG;
            {? ZL_WYRGD.EANL<>null()
            || _tab.EANL:=ZL_WYRGD.EANL().KOD;
               _tab.EANLREF:=$ZL_WYRGD.EANL
            ?};
            _tab.ZLREF:=$ZL_WYRGD.ZGP().ZL;
            {? ZL_WYRGD.ZL_WYR<>null()
            || _tab.ZL_WYR:=$ZL_WYRGD.ZL_WYR
            ?};
            _tab.add();
            ZL_WYRGD.next()
         !}
      ?};
      _tab.first();
      ZL_WYRGD.cntx_pop();
      ZL_WYR.cntx_pop()
   ?};
   MG.cntx_pop();
   M.cntx_pop()
?};
ZGP.cntx_pop();
~~


\env_efld_opt
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Określa opcje wyświetlania pól dla okien środowiska rejestracji wykonania do wielu wyrobów
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('__ENV_WYR')<100 || return() ?};
_env:=__ENV_WYR;
_tab:=_env.TAB_P;
_red:=_env.RED_P;
_info:=_env.INFO;
_full:=_env.FULL;

_tab.efld_opt(_red,'mark=1,editable=1',,'IL');
_tab.efld_opt(_red,'mark=1,editable=1',,'IL_BRAK');
:: Partia
{? _env.PARTY>0 & _env.WHERE<>2
|| {? _env.WHERE<>3
   || _tab.efld_opt(_red,'mark=1,editable=1',VPRODREJ,'ZPARN','SYM')
   || _tab.efld_opt(_red,'mark=1,editable=grayed',VPRODREJ,'ZPARN','SYM')
   ?}
|| _tab.efld_opt(_red,'editable=0',VPRODREJ,'ZPARN','SYM')
?};
{? _env.WHERE<>2
|| _tab.efld_opt(_red,'mark=1,editable=1',VPRODREJ,'MG','SYM')
|| _tab.efld_opt(_red,'editable=0',VPRODREJ,'MG','SYM')
?};
{? -menu_txt()='dołącz'
|| _tab.efld_opt(_red,'mark=1,editable=1',VPRODREJ,'ZL_WYR','M_KTM')
|| _tab.efld_opt(_red,'mark=0,editable=0',VPRODREJ,'ZL_WYR','M_KTM')
?};
{? _tab.ZL_WYR=''
|| _tab.efld_opt(_red,'mark=1,editable=1',VPRODREJ,'KTM','KTM')
|| _tab.efld_opt(_red,'mark=0,editable=0',VPRODREJ,'KTM','KTM')
?};

::Wyszarzanie przycisków
{? _env.WHERE<>2
|| {? _env.ID_SUR<>''
   || {? var_pres('__ENV_REJ')>100
      || {? _full>0
         || ZLGD.btn_eopt('ZL_WYR','SUROWCE','state=normal')
         || VPRODREJ.btn_eopt('ZL_WYR','SUROWCE','state=normal')
         ?};
         _tab.btn_eopt(_info,_env.ID_SUR,'state=normal')
      || {? _full>0
         || ZLGD.btn_eopt('ZL_WYR','SUROWCE','state=grayed')
         || VPRODREJ.btn_eopt('ZL_WYR','SUROWCE','state=grayed')
         ?};
         _tab.btn_eopt(_info,_env.ID_SUR,'state=grayed')
      ?}
   ?};
   {? _env.ID_BAD<>''
   || {? var_pres('__ENV_BAD')>100
      || {? _full>0
         || ZLGD.btn_eopt('ZL_WYR','BADANIE','state=normal')
         || VPRODREJ.btn_eopt('ZL_WYR','BADANIE','state=normal')
         ?};
         _tab.btn_eopt(_info,_env.ID_BAD,'state=normal')
      || {? _full>0
         || ZLGD.btn_eopt('ZL_WYR','BADANIE','state=grayed')
         || VPRODREJ.btn_eopt('ZL_WYR','BADANIE','state=grayed')
         ?};
         _tab.btn_eopt(_info,_env.ID_BAD,'state=grayed')
      ?}
   ?}
||
:: Kontrola jakości
   {? VAR1.IL_BRAK>0
   || _tab.btn_eopt(_info,_env.ID_POP,'state=normal')
   || _tab.btn_eopt(_info,_env.ID_POP,'state=grayed')
   ?}
?};
{? _env.WHERE=1
|| ZLGD.efld_opt('ZL_WYR','enable=0',VPRODREJ,'AUTO');
   _tab.efld_opt(_env.INFO,'enable=0',VPRODREJ,'AUTO')
|| {? _full>0
   || ZLGD.efld_opt('ZL_WYR','enable=1',VPRODREJ,'AUTO');
      _tab.efld_opt(_env.INFO,'enable=0',VPRODREJ,'AUTO')
   ?}
?};
~~

\env_sum_il
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sumuje ilości dobrych i braków ze wszystkich zapisów robocizny w rozbiciu na produkty.
::       Sumy zapisywane są w zmiennych VAR1.IL/VAR1.IL_BRAK lub VPRODREJ.IL/VPRODREJ.IL_BRAK
::   WE: _a - miejsce zapisu wyniku: [0] - do zmiennych VAR1/VPRODREJ.IL,IL_BRAK, 1 - do obiektu wyjściowego result
::   WY: ~~ lub okiekt(gdy _a=1) z polami IL oraz IL_BRAK
::----------------------------------------------------------------------------------------------------------------------
_where:={? var_pres('_a')=type_of(0) || _a || 0 ?};
{? _where=0 || _result:=~~ || _result:=obj_new('IL','IL_BRAK'); _result.IL:=0; _result.IL_BRAK:=0 ?};
{? var_pres('__ENV_WYR')<100 || return(_result) ?};
_env:=__ENV_WYR;
_tab:=_env.TAB_P;
_full:=_env.FULL;
_sum_il:=_sum_br:=0;
_tab.cntx_psh();
{? _tab.first()
|| {!
   |?
      _sum_il+=_tab.IL;
      _sum_br+=_tab.IL_BRAK;
      _tab.next()
   !}
?};
_tab.cntx_pop();
{? _where=0
|| {? _full>0
   || VAR1.IL:=_sum_il;
      VAR1.IL_BRAK:=_sum_br
   || VPRODREJ.IL:=_sum_il;
      VPRODREJ.IL_BRAK:=_sum_br
   ?}
|| _result.IL:=_sum_il;
   _result.IL_BRAK:=_sum_br
?};
_result


\zl_wyrgd_from_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Tworzy/aktualizuje rekordy ZL_WYRGD (Wykonanie produkcji rozbite wg  wyrobów)
::       na podstawie wypełnionej tabeli tymczasowej. Działa na aktywnym buforze tabeli ZLGD.
::   WY: ~~ lub tabela z ropiską na produkty (jeżeli wywołano przy rejestacji RP bez powiązania z robocizną)
::----------------------------------------------------------------------------------------------------------------------
{? var_press('__ENV_WYR')<100 || return() ?};
_result:=~~;
_env:=__ENV_WYR;
_tab:=_env.TAB_P;
_where:=_env.WHERE;
_update:=_env.ZLGD<>null();
:: Tabela z ilościami, na jakie będzie trzeba wydzielić nowe partie dla danego wyrobu
_zparn_tab:=tab_tmp(,'ZPARN','STRING[16]','ZPARN.ref() - wydzielana partia',
                     'MREF','STRING[16]','M.ref()',
                     'IL','REAL','Ilość do wydzielenia',
                     'OVER','INTEGER','Czy jednorazowa rejestracja powyżej ilości na partii');
_ndx1:=_zparn_tab.ndx_tmp(,,'ZPARN',,,'MREF',,,'IL',,);
_ndx2:=_zparn_tab.ndx_tmp(,,'OVER',,1,'ZPARN',,,'IL',,1);
_zparn_tab.index(_ndx1);
:: Tabela mapująca dla partii - jeżeli wydzielona została nowa partia po rejestracji wykonania
_zparn_map:=tab_tmp(,'TYP','STRING[1]','Rodzaj podziału',
                     'OLD','STRING[16]','Partia przed podziałem',
                     'MREF','STRING[16]','$M.ref()',
                     'NEW','STRING[16]','Partia po podziale');
:: Rodzaj podziału: O - przez zmianę pracownika, W - przez inny wyrób na partii
ZPARN.cntx_psh();
ZL_WYRGD.cntx_psh();
_mask:=(5+ZL_WYRGD.name())+(ZLGD.name()+3);
{? ZL_WYRGD.name()<>_mask
|| ZL_WYRGD.use(_mask)
?};
{? _update>0
||
:: Aktualizacja rekordów ZL_WYRGD po modyfikacji rekordu ZLGD i jego rozpiski w rozbiciu na wyroby
   ZL_WYRGD.index('ZLGD');
   ZL_WYRGD.prefix(ZLGD.ref());
:: Na początek przechodzę po już istniejących rekordach i je aktualizuje
   {? ZL_WYRGD.first()
   || {!
      |?
         _next:=1;
::       Sprawdzenie, czy aby zapis powiązany z danym ZL_WYRGD nie został usunięty z rozpiski
         {? _tab.find_tab(,'MREF',,'=',$ZL_WYRGD.KTM,'MGREF',,'=',$ZL_WYRGD.MG,'EANLREF',,'=',$ZL_WYRGD.EANL)
            & _tab.IL+_tab.IL_BRAK>0
         ||
::          Jest rekord - aktualizacja danych
            {? _where=2
            ||
::             Kontrola jakości - przypisanie ilości zakwalifikowanych
               ZL_WYRGD.IL:=_tab.IL;
               ZL_WYRGD.IL_BRAK:=_tab.IL_BRAK
            ||
               ZL_WYRGD.ZL_WYR:=exec('FindAndGet','#table',ZL_WYR,_tab.ZL_WYR,,,null());
::               ZL_WYRGD.KTM:=exec('FindAndGet','#table',M,_tab.MREF,,,null());
               {? ZLGD.ZGP().KJ_BAD='N'
               || ZL_WYRGD.IL:=_tab.IL;
                  ZL_WYRGD.IL_BRAK:=_tab.IL_BRAK
               || ZL_WYRGD.DEK_IL:=_tab.IL;
                  ZL_WYRGD.DEK_BR:=_tab.IL_BRAK
               ?};
               ZL_WYRGD.TIME:=_tab.TIME;
               ZL_WYRGD.ZPARN:=exec('FindAndGet','#table',ZPARN,_tab.ZPARN,,,null())
            ?};
            {? ZL_WYRGD.put()
            || _tab.del();
               _next:=ZL_WYRGD.next()
            ?}
         ||
::          Nie ma rekordu w tabeli tymczasowej - usunięcie ZL_WYRGD
            _next:=ZL_WYRGD.del(,1)=2
         ?};
         _next
      !}
   ?}
?};
ZL_WYRGD.clear();
{? _tab.first()
||
   {? _env.PARTY>0
   ||
::    Zebranie informacji o ilości, na jakie trzeba wydzielić nowe partie
      {!
      |?
         {? _tab.IL+_tab.IL_BRAK>0
         || {? ~_zparn_tab.find_key(_tab.ZPARN,_tab.MREF,)
            || _zparn_tab.ZPARN:=_tab.ZPARN;
               _zparn_tab.MREF:=_tab.MREF;
               _zparn_tab.IL:=_tab.IL+_tab.IL_BRAK;
               _zparn_tab.OVER:=
                  {? _tab.IL+_tab.IL_BRAK>exec('FindAndGet','#table',ZPARN,_tab.ZPARN,,"ZPARN.IL",0)
                  || 1
                  || 0
                  ?};
               _zparn_tab.add()
            || _zparn_tab.IL+=_tab.IL+_tab.IL_BRAK;
               _zparn_tab.OVER:=
                  {? _tab.IL+_tab.IL_BRAK>exec('FindAndGet','#table',ZPARN,_tab.ZPARN,,"ZPARN.IL",0)
                  || 1
                  || 0
                  ?};
               _zparn_tab.put()
            ?}
         ?};
         _tab.next()
      !};
::    Wydzielenie nowych partii
      _zparn_tab.index(_ndx2);
      {? _zparn_tab.first()
      || {!
         |?
            _zparn:=exec('FindAndGet','#table',ZPARN,_zparn_tab.ZPARN,,,null());
::          1. Sprawdzam czy wymagany jest podział partii ze względu na osobę rejestrującą (par 500771)
::             Wywoływane tylko raz dla danej partii
            {? _where<>3 & exec('get','#params',500771)='T' & VPRODREJ.AUTO='T'
               & ~_zparn_map.find_key('O',_zparn_tab.ZPARN,)
            ||
::             Wydzielenie nowej parti
               _new_ref:=exec('zparn_split','zl_wyk',null(),_zparn,ZLGD.ZGP,
                              {? ZLGD.ZGP().BRYG='T' || ZLGD.B || ZLGD.P ?});
::             Dodanie rekordu do tabeli mapującej
               _zparn_map.TYP:='O';
               _zparn_map.OLD:=_zparn_tab.ZPARN;
               _zparn_map.MREF:='';
               {? _new_ref<>null()
               ||
::                  zmiana partii "bazowej", z której teraz będą wydzielane pozostałe partie
                  _zparn_map.NEW:=$_new_ref
               || _zparn_map.NEW:=_zparn_tab.ZPARN
               ?};
               _zparn_map.add()
            ?};
::          2. Sprawdzam czy wymagany jest podział partii ze względu na przypisany materiał partii
::          Sprawdzenie, czy wczesniej już nie wydzielono partię dla danego materiału
            {? ~_zparn_map.find_key('W',_zparn_tab.ZPARN,_zparn_tab.MREF,)
            ||
::             Sprawdzenie, czy nie zmieniła się partia "bazowa" po zmianie pracownika/brygady
               {? _zparn_map.find_key('O',_zparn_tab.ZPARN,)
               || _zparn_tab.ZPARN:=_zparn_map.NEW
               ?};
::             Pobranie materiału partii
               _zparn_ktm:=exec('FindAndGet','#table',ZPARN,_zparn_tab.ZPARN,,"$ZPARN.KTM",null());
               {? _zparn_ktm<>_zparn_tab.MREF
               ||
::                Jeżeli materiał na partii inny niż na zapisie rozpiski robocziny w rozbiciu na wyroby
::                to wydzielana nowa partia (na inny materiał)
                  _il:=_zparn_tab.IL;
                  _ktm:=exec('FindAndGet','#table',M,_zparn_tab.MREF,,,null());
::                Wyznaczenie ilości zarezerwowanej (na jaką zarejestrowano wykonanie na produkt główny partii)
                  _il_rez:=0;
                  _zparn_tab.cntx_psh();
                  _zparn_tab.index(_ndx1);
                  {? _zparn_tab.find_key(_zparn_tab.ZPARN,_zparn_ktm)
                  || _il_rez:=_zparn_tab.IL
                  ?};
                  _zparn_tab.cntx_pop();
::                Wydzielenie nowej partii
                  _new_ref:=exec('zparn_split','zl_wyr',_zparn,_il,_ktm,_il_rez);
::                Dodanie rekordu do tabeli mapującej
                  _zparn_map.TYP:='W';
                  _zparn_map.OLD:=_zparn_tab.ZPARN;
                  _zparn_map.MREF:=_zparn_tab.MREF;
                  {? _new_ref<>null()
                  || _zparn_map.NEW:=$_new_ref
                  || _zparn_map.NEW:=_zparn_tab.ZPARN
                  ?};
                  _zparn_map.add()
               ?}
            ?};
            _zparn_tab.next()
         !}
      ?}
   ?};
   _tab.first();
:: Dołączenie rekordów ZL_WYRGD do tworzonego ZLGD
   {!
   |?
      {? _where=2
      ||
::       Kontrola jakości - na ten moment ścieżka nieobsługiwana
::       (brak możliwości dodania/usunięcia zapisu przez kontrolera)
         ~~
      |? _where=3
      ||
::       Rejestracja RP bez powiązania z robocizną (aktualizacja partii, nie są tworzone rekordy ZL_WYRGD)
         {? _tab.ZPARN<>''
         || {? _zparn_map.find_key('W',_tab.ZPARN,_tab.MREF,)
            || _tab.ZPARN:=_zparn_map.NEW;
               _tab.put()
            ?}
         ?}
      |? _tab.IL+_tab.IL_BRAK>0
      || ZL_WYRGD.blank();
         ZL_WYRGD.ZLGD:=ZLGD.ref();
         ZL_WYRGD.ZL_WYR:=exec('FindAndGet','#table',ZL_WYR,_tab.ZL_WYR,,,null());
         ZL_WYRGD.KTM:=exec('FindAndGet','#table',M,_tab.MREF,,,null());
         ZL_WYRGD.ZGP:=ZLGD.ZGP;
         ZL_WYRGD.MG:=exec('FindAndGet','#table',MG,_tab.MGREF,,,null());
         ZL_WYRGD.EANL:=exec('FindAndGet','#table',EANL,_tab.EANLREF,,,null());
         {? ZLGD.ZGP().KJ_BAD='N'
         || ZL_WYRGD.IL:=_tab.IL;
            ZL_WYRGD.IL_BRAK:=_tab.IL_BRAK
         || ZL_WYRGD.DEK_IL:=_tab.IL;
            ZL_WYRGD.DEK_BR:=_tab.IL_BRAK
         ?};
         ZL_WYRGD.TIME:=_tab.TIME;
         {? _tab.ZPARN<>''
         || {? _zparn_map.find_key('W',_tab.ZPARN,_tab.MREF,)
            || ZL_WYRGD.ZPARN:=exec('FindAndGet','#table',ZPARN,_zparn_map.NEW,,,null())
            ||
::             Nie powinno tu wejść, partia powinna być pobrana z wcześniej przygotowanej tabeli mapującej
               ZL_WYRGD.ZPARN:=exec('FindAndGet','#table',ZPARN,_tab.ZPARN,,,null())
            ?}
         ?};
         ZL_WYRGD.add()
      ?};
      _tab.next()
   !}
?};
ZL_WYRGD.cntx_pop();
ZPARN.cntx_pop();
{? _where=3
||
:: Wystawienie tabeli na wyjście
   _result:=__ENV_WYR.TAB_P
?};
:: Czyszczenie zmienncyh oraz środowiska do rejetracji w rozbiciu na wyroby
VAR_DEL.delete('__ENV_WYR');
VAR1.REJ_WYR:='N';
_result


\del4ZLGD
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Usuwa rozpiskę w rozbiciu na produkty (ZL_WYRGD) dla aktualnego rekordu robocizny
::----------------------------------------------------------------------------------------------------------------------
ZL_WYRGD.cntx_psh();
_mask:=(5+ZL_WYRGD.name())+(ZLGD.name()+3);
{? ZL_WYRGD.name()<>_mask
|| ZL_WYRGD.use(_mask)
?};
ZL_WYRGD.index('ZLGD');
ZL_WYRGD.prefix(ZLGD.ref());
{? ZL_WYRGD.first()
|| {!
   |?
      ZL_WYRGD.del()
   !}
?};
ZL_WYRGD.cntx_pop();
~~


\del4ZL
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Usuwa zdefiniowane produkty zlecenia (ZL_WYR) dla podanego zlecenia
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_result:=0;
_can_continue:=1;

ZL.cntx_psh();
ZL.prefix();

{? ZL.seek(_zl)
|| ZL_WYR.cntx_psh();
   ZL_WYR.index('ZL');
   ZL_WYR.prefix(ZL.ref());
   {? ZL_WYR.first()
   || {!
      |?
         _del:=1;
         {? ~exec('zl_wyr_can_mod','zl_wyr')
         || _can_continue:=0
         || _del:=ZL_WYR.del()
         ?};
         _del>0 & _can_continue>0
      !}
   ?};
   ZL_WYR.cntx_pop()
?};

{? _can_continue>0
|| _result:=1
?};

ZL.cntx_pop();
_result


\zl_wyrgd_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Selekcja zapisów robocizny w rozbicu na produkty dla podanego rekordu ZLGD
::   WE: _a - ZLGD, jak nie podany to bieżący rekord
::----------------------------------------------------------------------------------------------------------------------
_zlgd:={? var_press('_a')=type_of(null()) || _a || ZLGD.ref() ?};
ZLGD.cntx_psh();
{? ZLGD.name()<>ref_name(_zlgd)
|| ZLGD.use(ref_name(_zlgd))
?};
ZLGD.clear();
{? ZLGD.seek(_zlgd)
|| ZL_WYRGD.cntx_psh();
   _mask:=(5+ZL_WYRGD.name())+(ZLGD.name()+3);
   {? ZL_WYRGD.name()<>_mask
   || ZL_WYRGD.use(_mask)
   ?};
   ZL_WYRGD.win_sel('WER');
   ZL_WYRGD.index('ZLGD');
   ZL_WYRGD.prefix(_zlgd);
   ZL_WYRGD.select();
   ZL_WYRGD.cntx_pop()
?};
ZLGD.cntx_pop();
~~


\zlgd_czy_wyr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, czy do podanej rejestracji robocizny zostały wygerowane zapisy ZL_WYRGD - rozbicie wykonania
::       wg produktów
::   WE: _a - ZLGD.ref()/$ZLGD.ref()
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
_zlgd:=_a;
ZLGD.cntx_psh();
{? ZLGD.name()<>ref_name(_zlgd)
|| ZLGD.use(ref_name(_zlgd))
?};
ZLGD.clear();
{? ZLGD.seek(_zlgd)
|| ZL_WYRGD.cntx_psh();
   _mask:=(5+ZL_WYRGD.name())+(ZLGD.name()+3);
   {? ZL_WYRGD.name()<>_mask
   || ZL_WYRGD.use(_mask)
   ?};
   ZL_WYRGD.win_sel('WER');
   ZL_WYRGD.index('ZLGD');
   ZL_WYRGD.prefix(ZLGD.ref());
   {? ZL_WYRGD.first()
   || _res:=1
   ?};
   ZL_WYRGD.cntx_pop()
?};
ZLGD.cntx_pop();
_res


\odkwalifikuj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Wycofanie kwalifikacji jakościowej rozpiski robocizny wg produktów
::       Kontekst pracy - rekord ZLGD
::----------------------------------------------------------------------------------------------------------------------
ZL_WYRGD.cntx_psh();
_mask:=(5+ZL_WYRGD.name())+(ZLGD.name()+3);
{? ZL_WYRGD.name()<>_mask
|| ZL_WYRGD.use(_mask)
?};
ZL_WYRGD.index('ZLGD');
ZL_WYRGD.prefix(ZLGD.ref());
{? ZL_WYRGD.first()
|| {!
   |?
      ZL_WYRGD.IL:=0;
      ZL_WYRGD.IL_BRAK:=0;
      ZL_WYRGD.put();
      ZL_WYRGD.next()
   !}
?};
ZL_WYRGD.cntx_pop();
~~


\zparn_split
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Wydziela nową partię po zarejestrowaniu wykonania produkcji w rozbiciu na produkty
::       _a - ZPARN.ref() - dzielona partia
::       _b - ilość na nowej partii
::       _c - M.ref() - indeks materiałowy, na jaki wydzielić partię
::       [_d] - REAL - ilość zarezerwowana, doliczana do minimalnej ilości jaka może pozostać na dzielonej partii
::   WY: ZPARN.ref() lub null(), gdy partia nie powstała
::----------------------------------------------------------------------------------------------------------------------
_zparn:=_a;
_il_new:=_b;
_ktm:=_c;
_il_rez:={? var_pres('_d')=type_of(0) || _d || 0 ?};
_il_over:=0;
_new_ref:=null();
:: Wydzielam nową partię na ilość pozostałą
_zparn_il:=exec('FindAndGet','#table',ZPARN,_zparn,,"IL",0);
_zparn_ilrp:=exec('get_ilosc_rp','zl_partie',_zparn);
_zparn_ilzlgd:=exec('get_ilosc_zlgd','zl_partie',_zparn,,,1);
_zparn_ilw:=exec('max','#math',_zparn_ilrp,_zparn_ilzlgd)+_il_rez;
:: Ilość na dzielonej partii nie może być większa od dotychczasowej ilości na partii
{? _zparn_ilw>_zparn_il || _zparn_ilw:=_zparn_il ?};
:: Wyznaczenie ilości, jaka ma pozostać na dzielonej partii
_il_old:=_zparn_il-_il_new;
:: Ilość na dzielonej nie może być mniejsza od ilości zarejestrowanej robocziny
{? _il_old<_zparn_ilw
||
:: Wyznaczenie ilości dodatkowej (jeżeli nie da się wydzielić pełnej ilości z danej partii)
   _il_over:=_zparn_ilw-_il_old;
   _il_old:=_zparn_ilw
?};
:: Jeżeli wcześniej do partii nie zarejestrowano wykonań, a rejestracja na całą ilość partii (lub więcej)
:: to nie wydzialem partii, tylko zmieniam KTM na bieżącej
{? _zparn_ilw=0 & _il_new>=_zparn_il
|| ZPARN.cntx_psh();
   ZPARN.clear();
   {? ZPARN.seek(_zparn)
   || ZPARN.KTM:=_ktm;
      ZPARN.put();
      _new_ref:=ZPARN.ref()
   ?};
   ZPARN.cntx_pop()
|? _il_over>0 | _il_old<>_zparn_il
|| {? exec('split','zl_partie',_zparn,_il_old,0,_ktm,1,_il_over)
   ||
::    znalezienie refa nowo utworzonej partii
      ZPARN.cntx_psh();
      _srcid:=exec('FindAndGet','#table',ZPARN,_zparn,,"IDADD",0);
      ZPARN.index('IDSRC_ID');
      ZPARN.prefix(_srcid);
      {? ZPARN.last() || _new_ref:=ZPARN.ref() ?};
      ZPARN.cntx_pop()
   ?}
?};
_new_ref


\zl_wyrgd_add_main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Dla zapisu robocizny (ZLGD) dodaje zapis ZL_WYRGD (Wykonanie produkcji rozbite wg wyrobów)
::       na produkt główny zlecenia (na całą ilośc robocizny). Działa na bieżącym buforze tabeli ZLGD.
::----------------------------------------------------------------------------------------------------------------------
_found:=0;
ZL.cntx_psh();
ZL.clear();
{? ZL.seek(ZLGD.ZL)
|| ZGP.cntx_psh();
   ZL_WYRGD.cntx_psh();
   _mask:=(5+ZL_WYRGD.name())+(ZLGD.name()+3);
   {? ZL_WYRGD.name()<>_mask
   || ZL_WYRGD.use(_mask)
   ?};
   ZL_WYRGD.clear();
:: Odnalezienie rekordu ZL_WYR na produkt główny (zawsze powinien być)
   ZL_WYR.cntx_psh();
   ZL_WYR.index('UNIQUE');
   ZL_WYR.prefix(ZL.ref(),ZL.KTM,ZL.MG,ZL.EANL);
   {? ZL_WYR.first()
   || _found:=1
   ?};
   ZL_WYRGD.blank();
   ZL_WYRGD.ZLGD:=ZLGD.ref();
   ZL_WYRGD.ZGP:=ZLGD.ZGP;
   {? _found>0
   || ZL_WYRGD.ZL_WYR:=ZL_WYR.ref();
      ZL_WYRGD.KTM:=ZL_WYR.KTM;
      ZL_WYRGD.MG:=ZL_WYR.MG;
      ZL_WYRGD.EANL:=ZL_WYR.EANL
   ||
::    Nie ma powiązanego ZL_WYR, pobieram dane ze zlecenia
      ZL_WYRGD.ZL_WYR:=null();
      ZL_WYRGD.KTM:=ZL.KTM;
      ZL_WYRGD.MG:=ZL.MG;
      ZL_WYRGD.EANL:=ZL.EANL
   ?};

   {? ZLGD.ZGP().KJ_BAD='N'
   || ZL_WYRGD.IL:=ZLGD.IL;
      ZL_WYRGD.IL_BRAK:=ZLGD.IL_BRAK
   || ZL_WYRGD.DEK_IL:=ZLGD.DEK_IL;
      ZL_WYRGD.DEK_BR:=ZLGD.DEK_BR
   ?};
:: ZL_WYRGD.TIME:=ZLGD.TIME;
   ZL_WYRGD.ZPARN:=exec('FindAndGet','#table',ZPARN,VPRODREJ.ZPARN,,,null());
   ZL_WYRGD.add();
   ZL_WYRGD.cntx_pop();
   ZL_WYR.cntx_pop();
   ZGP.cntx_pop()
?};
ZL.cntx_pop();
~~


\env_show_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Wyświetla okno do rozpisania ilości, na jakie powstałe poszczególne wyroby zlecenia.
::       Formuła wywoływana, gdy rozpisywanie na produkty nie jest powiązane z robocizną (ZLGD)
::   WE: [_a] - ZGP.ref - pozycja przewodnika, jeżeli nie podane to określane na podstawie PROD_REJ.ZGP
::       [_b] - ZPARN.ref() - partia, do której będzie raportowana produkcja
::       [_c] - TYPYDOK.ref() - typ dokumentu raprtującego produkcję
::   WY: uzupełniona tabela z ropiską ilości na poszczególne produkty (__ENV_WYR.TAB_P)
::       lub ~~ jak przerwano rozpisywanie (nie zaakceptowano okna)
::----------------------------------------------------------------------------------------------------------------------
_zgp:=PROD_REJ.ZGP;
{? var_pres('_a')=type_of(ZGP.ref())
|| _zgp:=_a
?};
_zparn:=null();
{? var_pres('_b')=type_of(ZPARN.ref())
|| _zparn:=_b
?};
_typydok:=null();
{? var_pres('_c')=type_of(TYPYDOK.ref())
|| _typydok:=_c
?};
_result:=~~;
{? _zgp<>null() & _zparn<>null()
|| _zgh_zgp:=exec('FindAndGet','#table',ZGP,_zgp,,"ZGP.NRZLP",null());
   _zgh_zparn:=exec('FindAndGet','#table',ZPARN,_zparn,,"ZPARN.ZGH",null());
   {? _zgh_zgp=_zgh_zparn
   || _env_wyr:=exec('env','zl_wyr',3);
      exec('fill_env','zl_wyr',_zgp,,,_zparn);
      _env_wyr.TYPYDOK:=_typydok;
      {? _env_wyr.TAB_P.select()
      ||
::       Dzielenie partii
         _result:=exec('zl_wyrgd_from_tab','zl_wyr')
      ?}
   ||
::    Błąd danych wejściowych (inny przewodnika na partii i operacji)
      FUN.emsg('Błąd wywołania formuły.\n'
               'Przewodnik operacji zlecenia nie jest zgodny z przewodnikiem, do którego przypisana jest partia.'@)
   ?}
|| FUN.emsg('Błąd wywołania formuły.\nNie przekazano wymaganych parametrów.'@)
?};
_result


\zl_wyr_from_tab
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Tworzy rekordy ZL_WYR (Produkty zlecenia) na podstawie przekazanego obiektu/tabeli.
::       Działa na aktywnym buforze tabeli ZL.
::   WE: _a - obiekt utworzonej wewnątrz wtyczki ZL_WYR_GEN_001 lub tabela tymczasowa o strukturze:
::            tab_tmp(,'KTM','STRING[50]','Indeks mat.','MG','STRING[8]','Magazyn','EANL','STRING[20]','Lokalizacja')
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_continue:=1;
{? var_pres('_a')=117
|| _obj:=1
|? var_pres('_a')=118
|| _obj:=0
|| _continue:=0
?};

_result:=0;

ZL_WYR.cntx_psh();
ZL_WYR.clear();
{? _continue>0
|| Cntx.psh(M,MG,EANL);
   _tab:=_a;
   _size:={? _obj>0 || obj_len(_tab) || _tab.size() ?};
   {? _obj=0 || _tab.first() ?};
   _added:=0;
   {! _it:=1.._size
   |!
      _can_continue:=1;
      _ktm_str:={? _obj>0 || _tab[_it].KTM || _tab.KTM ?};
      _mg_str:={? _obj>0 || _tab[_it].MG || _tab.MG ?};
      _eanl_str:={? _obj>0 || _tab[_it].EANL || _tab.EANL ?};
::    Sprawdzenie czy przekazano wymagane pola i czy są odpowiedniego typu
      {? type_of(_ktm_str)<>type_of('') | type_of(_mg_str)<>type_of('') | type_of(_eanl_str)<>type_of('')
         | _ktm_str='' | _mg_str=''
      || _can_continue:=0
      ?};
      {? _can_continue>0
      || _ktm:=exec('FindInSet','#table','M','MATKTM',_ktm_str,,,1,,null());
         _mg:=exec('FindInSet','#table','MG','MAGAZYNY',_mg_str,,,1,,null());
         _eanl:=null();
         {? _eanl_str<>''
         || _eanl:=exec('FindInSet','#table','EANL','KOD',_eanl_str,,,1,,null())
         ?};
         {? _ktm=null() | _mg=null() | (_eanl_str<>'' & _eanl=null())
         || _can_continue:=0
         ?};
::       Sprawdzenie, czy dany indeks materiałowy może być wyrobem zlecenia (zgodność materiału z produktem zlecenia)
         {? _can_continue>0
         || _can_continue:=exec('ktm_compare','zl_wyr',ZL.KTM,_ktm)
         ?};
         {? _can_continue>0
         || ZL_WYR.blank(1);
            ZL_WYR.ZL:=ZL.ref();
            ZL_WYR.KTM:=_ktm;
            ZL_WYR.MG:=_mg;
            ZL_WYR.EANL:=_eanl;
            ZL_WYR.M_KTM:=ZL_WYR.KTM().KTM;
::          Sprawdzenie czy dodawany rekord jest unikalny
            ZL_WYR.cntx_psh();
            ZL_WYR.index('UNIQUE');
            ZL_WYR.prefix(ZL_WYR.ZL,ZL_WYR.KTM,ZL_WYR.MG,ZL_WYR.EANL);
            {? ~ZL_WYR.first()
            || {? ZL_WYR.add()
               || _added:=1
               ?}
            ?};
            ZL_WYR.cntx_pop()
         ?}
      ?};
      {? _obj=0 || _tab.next() ?}
   !};
:: Dołączenie wyrobu na produkt główny zlecenia (jeżeli jeszcze nie ma)
   {? _added>0
   || _result:=1;
      exec('zl_wyr_add_main','zl_wyr',ZL.ref())
   ?};
   Cntx.pop(M,MG,EANL)
?};
ZL_WYR.cntx_pop();
_result


\ktm_compare
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, indeks materiałowy może być zdefiniowany jako produkt zlecenia
::       (czy materiał jest zgodne pod względem charakterystyki względem produktu zlecenia)
::   WE: _a - M.ref() - produkt zlecenia
::       _b - M.ref() - porównywany materiał
::   WY: 1/0
::----------------------------------------------------------------------------------------------------------------------
_ktm:=_a;
_m:=_b;
_res:=0;
_continue:=1;
{? type_of(_ktm)<>type_of(M.ref()) | type_of(_m)<>type_of(M.ref()) || return(0) ?};

_jm:=null();
_m_atr:=null();
M.cntx_psh();
M.clear();
{? M.seek(_ktm)
|| _jm:=M.J;
   _m_atr:=M.M_ATR
|| _continue:=0
?};
M.cntx_pop();

{? _continue>0
|| M.cntx_psh();
   M.clear();
   {? M.seek(_m)
   || {? _jm=M.J & _m_atr=M.M_ATR & M.A='T' & M.RODZ='T' & M.R_PROD='T'
      || _res:=1
      ?}
   || _continue:=0
   ?};
   M.cntx_pop()
?};

_res


\zl_wyr_add_main
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Dodaje do zlecenia definicję wyrobu (ZL_WYR) na produkt główny zlecenia (o ile nie został wcześniej dodany)
::   WE: _a - ZL.ref()
::   WY: 1 - dodano, 0 - nie dodano, -1 - wyrób na produkt główny już istnieje
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_res:=0;
ZL.cntx_psh();
ZL.clear();
{? ZL.seek(_zl)
|| ZL_WYR.cntx_psh();
   ZL_WYR.index('UNIQUE');
   ZL_WYR.prefix(ZL.ref(),ZL.KTM);
   {? ~ZL_WYR.first()
   || M.cntx_psh();
      ZL_WYR.blank(1);
      ZL_WYR.ZL:=ZL.ref();
      ZL_WYR.KTM:=ZL.KTM;
      ZL_WYR.MG:=ZL.MG;
      ZL_WYR.EANL:=ZL.EANL;
      ZL_WYR.M_KTM:=ZL.KTM().KTM;
      _res:=ZL_WYR.add();
      M.cntx_pop()
   || _res:=-1
   ?};
   ZL_WYR.cntx_pop()
?};
ZL.cntx_pop();
_res


\zl_wyr_czy_grop
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, czy produkt zlecenia jest wykorzystany w grupach operacji
::   WE: _a - ZL_WYR.ref()
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
GROPP.cntx_psh();
GROPP.index('ZL_WYR');
GROPP.prefix(_a);
_res:=GROPP.first();
GROPP.cntx_pop();
_res


\zl_wyrgd_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Format wyświetlenia dla pól tabeli ZL_WYRGD
::----------------------------------------------------------------------------------------------------------------------
_afld:=cur_afld();
_form:='';
{? _afld='IL' | _afld='IL_BRAK' | _afld='DEK_IL' | _afld='DEK_BR'
|| _form:='out_prec='+{? (2+cur_kwin())='e_' || $ZL_WYRGD.KTM().DOKL || $ST.DOKL_P ?}
?};
_form


\zl_chk_ktm
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Sprawdza, czy podany materiał znajduje się na liście zdefiniowanych produktów zlecenia
::   WE: _a - ZL.ref()
::       _b - M.ref()
::   WY: 0/1
::----------------------------------------------------------------------------------------------------------------------
_res:=0;
ZL_WYR.cntx_psh();
ZL_WYR.index('ZL');
ZL_WYR.prefix(_a,_b);
_res:=ZL_WYR.first();
ZL_WYR.cntx_pop();
_res


\m_win
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [22.26]
:: OPIS: Tworzy okno wertowania wyświetlające listę produktów zlecenia. Okno wykorzystywane podczas redagowania
::       dokumentu RP dla zleceń z wieloma wyrobami.
::   WE: _a - tabela tymczasowa, dla której utworzyć okno
::   WY: utworzone okno
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_win:=_tab.mk_sel('Materiały'@,'P',0,'mqnl_wer',1,1,32,0,'U','T',0,0,0,'','','on');
_tab.win_fld(_win,,'KTM','','',30,0,0,'',0,'',,);
_tab.win_fld(_win,,'N','','',72,0,0,'',0,'',,);
_tab.win_fld(_win,,'JM',,'',10,0,1,'jm'@@,0,'',,);
_tab.win_act(_win,0,'Formuła','&Wybierz'@@,'','Wybór pozycji ze słownika'@,"exec('sel_exit_','#window')","",1,0,"","",'W',0,'mobile=1,target=record');
_tab.win_act(_win,0,'Formuła','Przeli&czniki'@@,'','Przeliczniki jednostek miary'@,"exec('przelicz_m','jm')","",0,0,"","",'C',0,'mobile=1,target=record');
_tab.win_act(_win,0,'Menu','Fu&nkcje'@@,'','',"","",0,0,"","",'N',0,'mobile=1,target=record');
_tab.win_act(_win,0,'Formuła','Szcz&egóły indeksu'@@,'#N','',"exec('m_info','material')","",0,0,"","",'E',0,'mobile=1');
task_attach('LMG_MAG_ZPSM');
_tab.win_act(_win,0,'Formuła','Zamienniki'@@,'#N','',"exec('zamien','material',0)","",0,0,"","",'Z',0,'mobile=1');
_tab.win_act(_win,0,'Formuła','Składowe indeksu'@@,'#N','',"exec('m_sklad','material')","",0,0,"","",'S',0,'mobile=1');
_tab.win_act(_win,0,'Formuła','Wyko&rzystanie indeksu'@@,'#N','',"exec('wykorzyst','material')","",0,0,"","",'R',0,'mobile=1');
_tab.win_act(_win,0,'Formuła','Pobierz rysunek'@@,'#N','',"exec('pobrys_m','material')","",0,0,"","",'P',0,'mobile=1');
_tab.win_act(_win,0,'Formuła','De&finicje dla controllingu'@@,'#N','Definicje controllingowe dla materiałów'@,"exec('con_def','!ctr_pco_zldk','T')","",0,0,"","",'F',0,'mobile=1');
task_attach('CTR_PCO_ZLDK');
_tab.win_act(_win,0,'Formuła','Opła&ty dodatkowe'@@,'#N','Opłaty dodatkowe dla indeksu'@,"exec('def_mopl','!zws_par_oplm')","",0,0,"","",'T',0,'mobile=1');
task_attach('ZWS_PAR_OPLM');
_tab.win_act(_win,0,'Formuła','--Q'@@,'#N','',"","",0,0,"","",'Q',0,'mobile=1');
_tab.win_act(_win,0,'Formuła','Ceny do &kalkulacji'@@,'#N','',"exec('pt_price','material_prod')","",0,0,"","",'K',0,'mobile=1');
_tab.win_act(_win,0,'Formuła','Propozycje &cen produktów'@@,'#N','',"exec('tow_prop','material_prod')","",0,0,"","",'C',0,'mobile=1');
_tab.win_act(_win,0,'Formuła','--X'@@,'#N','',"","",0,0,"","",'X',0,'mobile=1');
_tab.win_act(_win,0,'Menu','Dokumenty magazynowe'@@,'#N','',"","",0,0,"","",'D',0,'mobile=1');
task_attach('LMG_MAG_DAPZ');
task_attach('LMG_MAG_DWYD');
task_attach('LMG_MAG_PMAG');
_tab.win_act(_win,0,'Formuła','Przychodowe'@@,'#ND','Dokumenty przychodowe powiązane z danym towarem'@,"exec('inf_mmag','!zws_par_kmtr','T')","",0,0,"","",'P',0,'mobile=1');
task_attach('LMG_MAG_DAPZ');
task_attach('LMG_MAG_PMAG');
_tab.win_act(_win,0,'Formuła','Rozchodowe'@@,'#ND','Dokumenty rozchodowe powiązane z danym towarem'@,"exec('inf_mmag','!zws_par_kmtr','N')","",0,0,"","",'R',0,'mobile=1');
task_attach('LMG_MAG_DWYD');
task_attach('LMG_MAG_PMAG');
_tab.win_act(_win,0,'Formuła','Wszystkie'@@,'#ND','Dokumenty magazynowe powiązane z danym towarem'@,"exec('inf_mmag','!zws_par_kmtr','')","",0,0,"","",'W',0,'mobile=1');
task_attach('LMG_MAG_DAPZ');
task_attach('LMG_MAG_DWYD');
task_attach('LMG_MAG_PMAG');
_tab.win_act(_win,0,'Menu','Koszt w&ytworzenia'@@,'#N','',"","",0,0,"","",'Y',0,'mobile=1');
task_attach('TTE_PZL_KANA');
task_attach('TTE_PZL_KKAL');
task_attach('TTE_PZL_PANA');
task_attach('TTE_PZL_PKAL');
task_attach('TTE_TEC_KTKW');
task_attach('TTE_TEC_PTKW');
_tab.win_act(_win,0,'Formuła','TKW'@@,'#NY','Techniczny koszt wytworzenia produktu'@,"exec('tech_kalw','tech_kalk',M.ref())","",0,0,"","",'T',0,'mobile=1');
task_attach('TTE_TEC_KTKW');
task_attach('TTE_TEC_PTKW');
_tab.win_act(_win,0,'Formuła','--X'@@,'#NY','',"","",0,0,"","",'X',0,'mobile=1');
_tab.win_act(_win,0,'Formuła','Wg &kalkulacji zleceń'@@,'#NY','Planowany koszt wytworzenia produktu'@,"exec('zl_anwa','zl_kalk',M.ref(),'0')","",0,0,"","",'K',0,'mobile=1');
task_attach('TTE_PZL_KKAL');
task_attach('TTE_PZL_PKAL');
_tab.win_act(_win,0,'Formuła','Wg &analizy zleceń'@@,'#NY','Faktyczny koszt wytworzenia produktu'@,"exec('zl_anwa','zl_kalk',M.ref(),'1')","",0,0,"","",'A',0,'mobile=1');
task_attach('TTE_PZL_KANA');
task_attach('TTE_PZL_PANA');
_tab.win_act(_win,0,'Formuła','--X'@@,'#N','',"","",0,0,"","",'Ą',0,'mobile=1');
_tab.win_act(_win,0,'Formuła','Identyfikacja na urządzeniach'@@,'#N','Definiowanie identyfikacji na urządzeniach mobilnych'@,"exec('init_idm','!zws_par_kmtr')","",0,0,"","",'I',0,'mobile=1');
task_attach('ZWS_PAR_KMTR');
_tab.win_act(_win,0,'Formuła','Aktualizuj grupy'@@,'#N','Aktualizacja informacji o grupach materiałowych'@,"exec('all_mgr','!zws_par_kmtr')","",0,0,"","",'A',0,'mobile=1');
task_attach('ZWS_PAR_KMTR');
_tab.win_act(_win,0,'Formuła','Ewide&ncja dodatkowa'@@,'#N','Włączenie ewidencji w drugiej jednostce'@,"exec('init_jm2','material')","",0,0,"","",'N',0,'mobile=1');
task_attach('ZWS_PAR_KMTR');
_tab.win_act(_win,0,'Formuła','--X'@@,'#N','',"","",0,0,"","",'Ź',0,'mobile=1');
_tab.win_act(_win,0,'Formuła','Zmiany&'@@,'#N','Historia zmian danych'@,"exec('zmiany','#syslog')","",0,0,"","",'Ć',0,'mobile=1');
_tab.win_act(_win,0,'Formuła','Druku&j'@@,'','',"exec('material_druk','!zws_par_kmtp')","",0,0,"","",'J',0,'mobile=1,target=window');
task_attach('ZWS_PAR_KMTP');
task_attach('ZWS_PAR_KMTR');
_tab.win_act(_win,0,'Formuła','Zadania&'@@,'','Zadania związane z bieżącym zapisem'@,"exec('todo_select','#b__box',M.uidref())","",0,0,"","",'Ń',0,'mobile=1,target=record');
_tab.win_act(_win,0,'Formuła','S&zukaj wg kodu'@@,'','',"exec('m_kod_szuk','kody_kresk')","",0,0,"","",'Z',0,'mobile=1,target=record');
_tab.win_act(_win,0,'Szukaj','','','',"","",0,0,"","",'',0,'mobile=1,target=window');
_tab.win_act(_win,0,'Kolejność','','','',"","",0,0,"","",'',0,'mobile=1,target=window');
_tab.win_act(_win,0,'Formuła','Legenda'@@,'','',"exec('legenda','color','M#01')","",0,0,"","",'L',0,'mobile=1,target=window');
_before:="
:: Podczytanie M
   _tab:=cur_tab(1,1);
   {? M.seek(_tab.REF)
   || exec('m_rek_przed','!zws_par_kmtr',_a)
   || ''
   ?}
";
_tab.win_act(_win,0,'Rekord','','','',_before,"",0,0,"","",'',0,'mobile=1,target=window');
_before:="
   M.display();
   ~~
";
_tab.win_act(_win,0,'Wyświetl','','','',_before,"",0,0,"","",'',0,'mobile=1,target=window');
btn1:=_tab.win_btn(_win,'text="%1",btn_label_align=center,panel=right,align=begin'['Dołącz'@@],'menu:D',,,0,,,'');
_tab.btn_sopt(_win,btn1,'tooltip="%1"'['Dołącz zapis'@]);
btn2:=_tab.win_btn(_win,'text="%1",btn_label_align=center,panel=right,align=begin'['Popraw'@@],'menu:P',,,0,,,'noempty');
_tab.btn_sopt(_win,btn2,'tooltip="%1"'['Popraw zapis'@]);
btn3:=_tab.win_btn(_win,'text="%1",btn_label_align=center,panel=right,align=begin'['Usuń'@@],'menu:U',,,0,,,'noempty');
_tab.btn_sopt(_win,btn3,'tooltip="%1"'['Usuń zapis'@]);
btn4:=_tab.win_btn(_win,'text="%1",btn_label_align=center,panel=right,align=begin'['K&opiuj'@@],'menu:O',,,0,,,'noempty');
_tab.win_sel(_win);
_tab


\zlzam2zlwyr
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Na podstawie ZLZAM podanego zlecenia tworzy listę produktów zlecenia (ZLWYR)
::   WE: _a - ZL.ref()
::       _b - źródło pochodzenia: 'Z' - zamówienie sprzedaży, 'D' - plan dostaw, 'S' - plan sprzedaży
::   WY: 0 - porażka
::       1 - sukces
::----------------------------------------------------------------------------------------------------------------------
_zl:={? var_pres('_a')=type_of(ZL.ref()) || _a || null() ?};
_src:={? var_pres('_b')=type_of('') || _b || '' ?};

_result:=0;

{? _zl<>null() & _src<>''
|| ZL.cntx_psh();
   ZL.prefix();
   {? ZL.seek(_zl)
   || _tab_wyr:=tab_tmp(,'KTM','STRING[50]','Indeks mat.','MG','STRING[8]','Magazyn','EANL','STRING[20]','Lokalizacja');
      ZLZAM.cntx_psh();
      ZLZAM.index('ZLPD');
      ZLZAM.prefix(ZL.ref(),_src);
      {? ZLZAM.first()
      || M.cntx_psh();
::       Zamówienia sprzedaży
         {? _src='Z'
         || ZK_P.cntx_psh();
            ZK_P.prefix();
            {!
            |?
               {? ZK_P.seek(ZLZAM.ZAMPOZ,ref_name(ZLZAM.ZAMPOZ),1)
               || _tab_wyr.KTM:=ZK_P.M().KTM;
                  _tab_wyr.MG:=ZK_P.MG().SYM;
                  {? _tab_wyr.MG=''
                  || _tab_wyr.MG:=ZL.MG().SYM
                  ?};
                  _tab_wyr.EANL:='';
                  {? ~_tab_wyr.find_rec()
                  || _tab_wyr.add()
                  ?}
               ?};
               ZLZAM.next()
            !};
            ZK_P.cntx_pop()
::       Plan dostaw
         |? _src='D'
         || PD_K.cntx_psh();
            PD_K.prefix();
            {!
            |?
               {? PD_K.seek(ZLZAM.ZAMPOZ,ref_name(ZLZAM.ZAMPOZ),1)
               || _tab_wyr.KTM:=PD_K.M().KTM;
                  _tab_wyr.MG:=PD_K.MG().SYM;
                  {? _tab_wyr.MG=''
                  || _tab_wyr.MG:=ZL.MG().SYM
                  ?};
                  _tab_wyr.EANL:='';
                  {? ~_tab_wyr.find_rec()
                  || _tab_wyr.add()
                  ?}
               ?};
               ZLZAM.next()
            !};
            PD_K.cntx_pop()
::       Plan sprzedaży
         |? _src='S'
         || PSP.cntx_psh();
            PSP.prefix();
            {!
            |?
               {? PSP.seek(ZLZAM.ZAMPOZ,ref_name(ZLZAM.ZAMPOZ),1)
               || _tab_wyr.KTM:=PSP.M().KTM;
                  {? _tab_wyr.MG=''
                  || _tab_wyr.MG:=ZL.MG().SYM
                  ?};
                  _tab_wyr.EANL:='';
                  {? ~_tab_wyr.find_rec()
                  || _tab_wyr.add()
                  ?}
               ?};
               ZLZAM.next()
            !};
            PSP.cntx_pop()
         ?};
         M.cntx_pop()
      ?};
      ZLZAM.cntx_pop();
      {? _tab_wyr.size()>1
      || _result:=exec('zl_wyr_from_tab','zl_wyr',_tab_wyr)
      ?}
   ?};
   ZL.cntx_pop()
?};
_result

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:35 bb681129147a821b54a19b35a40edad92d4c15edcd837141b9ac6d1ad5b22f795536c4c0f218c0bff16a63a7ee1e36dc5949d5acd14c77b5726a9878100513cf4587b01f356e0a6838dfd8ec1bb579fa0be972d128f677045b3ab39f1c6ca66daf3941df0d1d1d1cf70551d3a545ce775ade3b4bfbf028a7c663c7678206dbaf
