:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku: tech_arch.fml
:: Utworzony: 26.03.2014
:: Autor: WH
::======================================================================================================================
:: Zawartosc: Obsługa archiwizacji i kopiowania kart technologicznych
::            Plik biblioteczny - wspólna obsługa dla TTE_TEC, TTE_WTE, TTE_PZL
::======================================================================================================================


\args_copy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Argumenty dla funkcji kopiujących technologie/wzorce i przesuwających między maskami
::   WY: obj_new() - tablica nazwana
::  TAG: <PRYWATNA><TECHNOLOGIE><WZORCE_TECH><ARCHIWIZACJA><KOPIOWANIE><ARGUMENTY>
::  OLD: \args_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
::             Technologia źródłowa
               'TKTL_SRC'
::             Technologia docelowa
               ,'TKTL_DST'

::             Symbol technologii docelowej
               ,'DST_SYM'
::             Wersja technologii docelowej
               ,'DST_WER'
::             Zlecenie technologii docelowej
               ,'DST_ZL'
::             Zlecenie nadrzędne technologii docelowej
               ,'DST_ZLNAD'
::             Pozycja analizy wykonania technologii docelowej
               ,'DST_PL'
::             Maska technologii docelowej
               ,'DST_TMASK'
::             Rodzaj technologii docelowej
               ,'DST_TORW'

::             Stan technologii docelowej
               ,'DST_STAN'
::             Status rejestracji nagłówka technologii docelowej
               ,'DST_STAT_N'
::             Status rejestracji operacji technologii docelowej
               ,'DST_STAT_O'
::             Status rejestracji surowców technologii docelowej
               ,'DST_STAT_S'
::             Status rejestracji danych pozostałych technologii docelowej
               ,'DST_STAT_P'

::             Terminy obowiązywania technologii (od - do)
               ,'DST_T_OD'
               ,'DST_T_DO'

::             Typ technologii docelowej
               ,'DST_TYP'

::             Operacja źródłowa
               ,'TOPER_SRC'
::             Operacja docelowa
               ,'TOPER_DST'

::             Surowiec źródłowy
               ,'TMAT_SRC'
::             Surowiec docelowy
               ,'TMAT_DST'

::             Parametr źródłowy
               ,'TPAR_SRC'
::             Parametr docelowy
               ,'TPAR_DST'

::             Maska źródłowa - suffiks (ostatnie trzy znaki)
               ,'MASK_SRC'
::             Maska docelowa - suffiks (ostatnie trzy znaki)
               ,'MASK_DST'

::             Kalkulacja źródłowa
               ,'KKTL_SRC'
::             Kalkulacja docelowa
               ,'KKTL_DST'

::             Czy usuwać rekordy źródłowe po skopiowaniu? 0/1
               ,'DELETE'

::             Kierunek przesylania: 'ARCHIWUM', 'KARTOTEKA'
               ,'DIR'

::             Czy kopiowanie przeprowadzać w transakcji
               ,'TRANS'

::             Tabela zawierąjaca informacje jak z nowej operacji trafić do starej
               ,'TOPER_TAB'
::             Tabela zawierąjaca informacje jak z nowego parametru trafić do starego
               ,'TPAR_TAB'

::             Czy kopiować operacje
               ,'COPY_OPER'

::             Czy kopiować następniki operacji
               ,'COPY_NAST'

::             Czy kopiować surowce
               ,'COPY_SUR'

::             Czy kopiować NPU
               ,'COPY_NPU'

::             Czy kopiować atrybuty
               ,'COPY_UAT'

::             Czy kopiować produkty karty?
               ,'COPY_PROD'

::             Czy kopiować główny produkt karty (TKTL.KTM)
               ,'COPY_KTM'

::             Czy kopiować dokumentację karty?
               ,'COPY_DOK'

::             Czy kopiować zatwierdzenia?
               ,'COPY_ZATW'

::             Czy kopiować kalkulacje?
               ,'COPY_KALK'

::             Czy kopiować tylko aktualne elementy (uwaga jesli=1 to opcja DELETE musi=0)
               ,'COPY_ACT'

::             Czy przed kopiowaniem pytać o nowe wartości parametrów?
               ,'TPAR_ASK'
::             Po kopiowaniu informacja, czy redakcja parametrów została zatwierdzona
               ,'TPAR_EDITED'

::             Tabela zawierajaca nowe wartości parametrów
               ,'TPAR_VAL'

::             Produkt (M.ref), który jeśli jest podany spowoduje że do nowej karty
::             zostanie skopiowany tylko jeden TKTLW - właśnie na ten produkt
::             Poza tym jeśli będzie pytanie o parametry, to również zapyta tylko o ten
::             jeden produkt
               ,'M_ONLY'

::             Produkt (M.ref), którego wartości parametrów staną się wartościami
::             domyślnymi w docelowej karcie
               ,'M_VALS'

::             Numer operacji (TOPER.NROP) ktorą kopiować - jeśli podane to kopiowana
::             jest tylko ta jedna operacja
               ,'TOPER_NR'

::             Czy wypełniać TMATom i TOPERom pola SRC, które prowadzą do źródłowych
::             TMATów i TOPERów na podstawie których powstały
               ,'FILL_SRC'

::             Zlecenie któremu przypisać skopiowaną technologię
               ,'ZL_SET'

::             Czy przenosić statusy rejestracji i czasy modyfikacji
               ,'STATUS_COPY'

::             Czy aktualizować ilości na surowcach/zamiennikach (skalowanie do ilości na nagłówku karty)
               ,'SUR_UPDATE'

::             Czy aktualizować pola z procentową zawartością na surowcach/zamiennikach
::             (po zmianie jednostki miary na karcie/wzorcu)
               ,'XJMP_UPDATE'

::             Czy kopiowane tylko surowce
               ,'SUR_ONLY'
::             Czy kopiowane tylko operacje
               ,'OPER_ONLY'
::             Czy kopiowane tylko NPU
               ,'NPU_ONLY'

::             Czy nadawać nowe numery operacjom (gdy operacje kopiowane do karty, w której istnieją już operacje)
               ,'OPER_RENUM'
              );
_args.TKTL_SRC:=null();
_args.TKTL_DST:=null();
_args.DST_SYM:='';
_args.DST_WER:='';
_args.DST_ZL:=null();
_args.DST_ZLNAD:=null();
_args.DST_PL:=null();
_args.DST_TMASK:='';
_args.DST_TORW:='';
_args.DST_STAN:='';
_args.DST_STAT_N:='';
_args.DST_STAT_O:='';
_args.DST_STAT_S:='';
_args.DST_STAT_P:='';
_args.DST_T_OD:=date(0,0,0);
_args.DST_T_DO:=date(0,0,0);
_args.DST_TYP:=null();
_args.TOPER_SRC:=null();
_args.TOPER_DST:=null();
_args.TMAT_SRC:=null();
_args.TMAT_DST:=null();
_args.TPAR_SRC:=null();
_args.TPAR_DST:=null();
_args.MASK_SRC:='___';
_args.MASK_DST:='___';
_args.KKTL_SRC:=null();
_args.KKTL_DST:=null();
_args.DELETE:=0;
_args.DIR:='';
_args.TRANS:=1;
_args.TOPER_TAB:=exec('tab_history','tech_arch');
_args.TPAR_TAB:=exec('tab_history','tech_arch');
_args.COPY_OPER:=1;
_args.COPY_NAST:=1;
_args.COPY_SUR:=1;
_args.COPY_NPU:=1;
_args.COPY_UAT:=1;
_args.COPY_PROD:=1;
_args.COPY_KTM:=1;
_args.COPY_DOK:=1;
_args.COPY_ZATW:=0;
_args.COPY_KALK:=0;
_args.COPY_ACT:=1;
_args.TPAR_ASK:=0;
_args.TPAR_EDITED:=1;
_args.TPAR_VAL:=exec('tab_tpars','tech_arch');
_args.M_ONLY:=null();
_args.M_VALS:=null();
_args.TOPER_NR:=-1;
_args.FILL_SRC:=0;
_args.ZL_SET:=null();
_args.STATUS_COPY:=1;
_args.SUR_UPDATE:=0;
_args.XJMP_UPDATE:=0;
_args.SUR_ONLY:=0;
_args.OPER_ONLY:=0;
_args.NPU_ONLY:=0;
_args.OPER_RENUM:=1;
_args


\tab_history
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Tworzy tabelkę tymczasową łącząca nowe i stare rekordy
::   WY: tab_tmp
::  OLD: \tab_history/tex_arch.fml
::  TAG: <PRIVATE>
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(2,
   'REF_OLD','STRING[16]','Ref starego rekordu',
   'REF_NEW','STRING[16]','Ref nowego rekordu'
);
_tab


\tab_tpars
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Tworzy tabelkę tymczasową zawierającą nowe wartości parametrów
::   WY: tab_tmp
::  OLD: \tab_tpars/tex_arch.fml
::  TAG: <PRIVATE>
::----------------------------------------------------------------------------------------------------------------------
_tab:=tab_tmp(2,
   'TPAR','STRING[16]','Ref SQL starego parametru',
   'TKTLW','STRING[16]','Ref SQL starego produktu karty',
   'VALUE','REAL','Nowa wartość parametru',
   'DEFAULT','STRING[1]','Czy nowa wartość ma zostać domyślną?'
);
_tab


\tktl_copy_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Akcja kopiowania karty technologicznej
::   WE: _a - TKTL.ref()
::       [_b] - _args - tablica nazwana z parametrami dla funkcji kopiującej - wynik exec('args_copy','tech_arch')
::       [_c] - 'Technologia', 'Wersja', 'Wzorzec'
::       [_d] - INTEGER - 0/[1] - czy wyświetlać dialogi
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PUBLICZNA><TECHNOLOGIE><ARCHIWIZACJA><KOPIOWANIE><AKCJA>
::  OLD: \tktl_copy_act/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

{? var_pres('_b')>100
|| _args:=_b
|| _args:=exec('args_copy','tech_arch')
?};

_rodzaj:='';
{? var_pres('_c')=type_of('')
|| _rodzaj:=_c
?};

_dialog:=1;
{? var_pres('_d')=type_of(0)
|| _dialog:=_d
?};

_result:=0;
_can_continue:=1;

_change_view:=0;
_torw:='';

TKTL.cntx_psh(); TKTL.clear();
{? TKTL.seek(_tktl)
|| _uidref:=TKTL.uidref();
   _torw:=TKTL.TORW;
   _what:=TKTL.NRK+' wersja: '+TKTL.WER;
   _arch:=TKTL.ARCH;

   _args.TKTL_SRC:=TKTL.ref();
   _args.DELETE:=0;
   _args.TRANS:=1;
   _args.DST_TMASK:=exec('samejedynki','#blank',23);
   _args.DIR:='KARTOTEKA';
   _args.MASK_SRC:=ref_name(TKTL.ref())+3;
   _args.MASK_DST:='___';
   {? _args.DST_SYM=''
   || _args.DST_SYM:=TKTL.NRK
   ?};
   {? _args.DST_WER=''
   || _args.DST_WER:=TKTL.WER
   ?};
   _args.DST_STAN:='N';
   _args.STATUS_COPY:=0;

   {? _can_continue>0 & _dialog>0
   ||
      {? _rodzaj=''
      ||
::       Pytam na co skopiować nową kartę
         {? TKTL.TORW='T'
         || {? TKTL.TYP=exec('ref_k_res','tech_head')
            ||
::             Technologia kompletacyjna
               _msg:='Czy skopiować kartę kompletacyjną produktu: %1 na:'@[TKTL.KTM().KTM];
               _choice:=FUN.choice(_msg,,'Nową &technologię'@);
               {? _choice=0
               || _can_continue:=0
               || _rodzaj:='Technologia'
               ?}
            ||
::             Technologia zwykła
               _msg:='Czy skopiować kartę technologiczną: \'%1\' na:'@[_what];
               _choice:=FUN.choice(_msg,,'Nową &technologię'@,'Nową &wersję'@);
               {? _choice=0
               || _can_continue:=0
               |? _choice=1
               || _rodzaj:='Technologia'
               |? _choice=2
               || _rodzaj:='Wersja'
               ?}
            ?}
         |? TKTL.TORW='Z'
         ||
::          Karta technologiczna zlecenia
            _msg:='Czy skopiować kartę technologiczną zlecenia: %1 na:'@[TKTL.ZL().SYM];
            _choice:=FUN.choice(_msg,,'Nową &technologię'@);
            {? _choice=0
            || _can_continue:=0
            || _rodzaj:='Technologia'
            ?}
         ||
::          Wzorzec
            _msg:='Czy skopiować wzorzec technologii: \'%1\' na'@[_what];
            _choice:=FUN.choice(_msg,,'Nowy w&zorzec'@,'Nową &wersję'@);
            {? _choice=0
            || _can_continue:=0
            |? _choice=1
            || _rodzaj:='Technologia'
            |? _choice=2
            || _rodzaj:='Wersja'
            ?}
         ?}
      ?};

      _tab:=tab_tmp(,
         'NRK','STRING[50]','Numer karty'@,
         'WER','STRING[6]','Wersja'@,
         'TYP','STRING[3]','Typ karty'@,
         'TYP_REF','STRING[16]','$TPKTL.ref()',
         'STAT_N','STRING[1]','Status rejestracji nagłówka'@
      );
      _tab.fld_fml('TYP','F3',"
         _tab:=cur_tab(1,1);
         TPKTL.win_sel('WERSLO');
         TPKTL.f_set('TYP',,'TPKTL.DJ=\'\'P\'\' ');
         {? TPKTL.select()
         || _tab.TYP:=TPKTL.TYP;
            _tab.TYP_REF:=$TPKTL.ref()
         ?}
      ");
::      _tab.fld_fml('TYP','AFTER_EDIT',"
::         _tab:=cur_tab(1,1);
::         TPKTL.f_set('TYP',,'TPKTL.DJ=\'\'P\'\' and TPKTL.SUR=\'\'K\'\' and TPKTL.TYP=\'\':_a\'\'',_tab.TYP);
::         {? TPKTL.f_first()
::         || _tab.TYP_REF:=$TPKTL.ref();
::            1
::         || FUN.info('Brak typu %1.'[_tab.TYP]);
::            0
::         ?}
::      ");

      {? _can_continue>0
      ||
         _can_continue:=0;

         {? _rodzaj='Technologia'
         || {? _args.DST_TORW=''
            || _args.DST_TORW:={? TKTL.TORW='W' || 'W' || 'T' ?}
            ?};
            _red:=_tab.mk_edit(FUN.TYT,,'#new_tech',,,'normal');
            _tab.win_efld(_red,,'NRK',,,,,,
               {? TKTL.TORW='T' | TKTL.TORW='Z'
               || 'Podaj symbol nowej technologii'@
               || 'Podaj symbol nowego wzorca'@
               ?}
            );
            {? TKTL.TYP=exec('ref_k_res','tech_head')
            || _tab.win_efld(_red,,'TYP',,,,,,,,,,'F3_button=1')
            ?};
            _tab.win_ebtn(_red,'text=%1'['Zakończ'@],"cur_tab().STAT_N:='T'; 'key:F2'");
            _btn2:=_tab.win_ebtn(_red,'text=%1'['Za&pisz'@],"'key:F2'");
            _tab.btn_eopt(_red,_btn2,'tooltip='+exec('help_red_ok','#window'));
            _tab.win_ebtn(_red,'text=%1'['Anuluj'@],"'key:Esc'");
            _tab.win_edit(_red);
            _tab.NRK:=TKTL.NRK+' - kopia';
            {? _tab.edit("chk_rec()")
            || {? VAR.FILTER='T' & FILTER.NRK<>''
               || {? _dl:=+FILTER.NRK;
                     _dl+_tab.NRK=_dl+FILTER.NRK
                  || _args.DST_SYM:=_tab.NRK;
                     _args.DST_WER:=exec('tktl_wer_bl','tech_head');
                     {? TKTL.TYP=exec('ref_k_res','tech_head')
                     || _args.DST_TYP:=exec('FindAndGet','#table',TPKTL,_tab.TYP_REF)
                     ?};
                     _args.DST_STAT_N:=_tab.STAT_N;
                     _can_continue:=1
                  || FUN.emsg({? VAR.A_TORW='T'
                              || 'Zgodnie z ustawieniami filtra\nnumer karty musi zaczynać się od znaków:\n\'%1\''@[FILTER.NRK]
                              || 'Zgodnie z ustawieniami filtra\nsymbol wzorca musi zaczynać się od znaków:\n\'%1\''@[FILTER.NRK] ?})
                  ?}
               || _args.DST_SYM:=_tab.NRK;
                  _args.DST_WER:=exec('tktl_wer_bl','tech_head');
                  {? TKTL.TYP=exec('ref_k_res','tech_head')
                  || _args.DST_TYP:=exec('FindAndGet','#table',TPKTL,_tab.TYP_REF)
                  ?};
                  _args.DST_STAT_N:=_tab.STAT_N;
                  _can_continue:=1
               ?}
            ?}

         |? _rodzaj='Wersja'
         || _args.DST_TORW:=TKTL.TORW;
            _red:=_tab.mk_edit(FUN.TYT,,'new_wer',,,'normal');
            _tab.win_efld(_red,,'WER',,,,,,'Podaj symbol nowej wersji'@);
            _tab.win_ebtn(_red,'text=%1'['Zakończ'@],"cur_tab().STAT_N:='T'; 'key:F2'");
            _btn2:=_tab.win_ebtn(_red,'text=%1'['Za&pisz'@],"'key:F2'");
            _tab.btn_eopt(_red,_btn2,'tooltip='+exec('help_red_ok','#window'));
            _tab.win_ebtn(_red,'text=%1'['Anuluj'@],"'key:Esc'");
            _tab.win_edit(_red);
            _new_wer:=exec('find_wer','tech_head',TKTL.TORW,TKTL.NRK,TKTL.WER);
            {? _new_wer<>''
            || _tab.WER:=_new_wer
            || _tab.WER:=TKTL.WER
            ?};
            _valid:="
               _result:=chk_rec();
               {? _result=''
               || _chk:=exec('chk_symbol','tech_head',TKTL.TORW,TKTL.NRK,cur_tab(1,1).WER);
                  {? _chk=0
                  || FUN.emsg('Wprowadzony symbol/wersja musi być unikalny w ramach całej kartoteki (również w ramach archiwum).');
                     _result:='WER'
                  ?}
               ?};
               _result
            ";
            {? _tab.edit(_valid)
            || _args.DST_WER:=_tab.WER;
               _args.DST_STAT_N:=_tab.STAT_N;
               _can_continue:=1
            ?}

         |? _rodzaj='Wzorzec'
         || _args.DST_TORW:='W';
            _red:=_tab.mk_edit(FUN.TYT,,'new_wzor',,,'normal');
            _tab.win_efld(_red,,'NRK',,,,,,'Podaj symbol nowego wzorca'@);
            _tab.win_ebtn(_red,'text=%1'['Zakończ'@],"cur_tab().STAT_N:='T'; 'key:F2'");
            _btn2:=_tab.win_ebtn(_red,'text=%1'['Za&pisz'@],"'key:F2'");
            _tab.btn_eopt(_red,_btn2,'tooltip='+exec('help_red_ok','#window'));
            _tab.win_ebtn(_red,'text=%1'['Anuluj'@],"'key:Esc'");
            _tab.win_edit(_red);
            _tmp_sym:=exec('tmp_sym','tech_head');
            _tab.NRK:=_tmp_sym+$TKTL.tm_stamp();
            {? _tab.edit("chk_rec()")
            || _args.DST_SYM:=_tab.NRK;
               _args.DST_WER:=exec('tktl_wer_bl','tech_head');
               _args.DST_STAT_N:=_tab.STAT_N;
               _can_continue:=1
            ?}
         ?}
      ?}
   ?};

:: Sprawdzenie, czy kopiowana karta jest jeszcze dostępna
   {? ~TKTL.seek(_uidref)
   || FUN.info('Kopiowana karta została usunięta albo zarchiwizowana. Utworzenie kopii nie jest możliwe.'@);
      _can_continue:=0
   ?};

   {? _can_continue>0
   ||
::    Sprawdzam czy symbol jest unikalny w ramach wszystkich masek
      {? exec('chk_symbol','tech_head',_args.DST_TORW,_args.DST_SYM,_args.DST_WER)=0
      || _can_continue:=0;
         FUN.emsg('Wprowadzony symbol/wersja musi być unikalny w ramach całej kartoteki (również w ramach archiwum).'@)
      ?};
::    Sprawdzana możliwość zablokowania karty w każdym zakresie
      {? _can_continue>0 &
         ~(exec('tktl_lock','tech_common',#_tktl,'N',1) &
           exec('tktl_lock','tech_common',#_tktl,'O',1) &
           exec('tktl_lock','tech_common',#_tktl,'S',1) &
           exec('tktl_lock','tech_common',#_tktl,'P',1))
      || _can_continue:=0;
         FUN.emsg('Kopiowana karta jest redagowana. Utworzenie kopii nie jest możliwe.'@)
      ?};
      {? _can_continue>0
      ||
::       Jądro kopiujące
         _can_continue:=exec('tktl_copy','tech_arch',_args);

::       Komunikaty po kopiowaniu
         {? _dialog>0
         || {? _can_continue>0
            ||
               TKTL.use(ref_name(_args.TKTL_DST));
               TKTL.clear();
               {? TKTL.seek(_args.TKTL_DST)
               || _what:=TKTL.NRK+' wersja '+TKTL.WER;
                  {? _arch='T'
                  || {? _rodzaj='Wzorzec'
                     || FUN.info(
                           'Kopiowanie zakończone, utworzono wzorzec: \'%1\'.'@[_what])+
                           '\n\n'+'Nowy wzorzec znajduje się w zbiorze wzorców niearchiwalnych.'@
                     |? _torw='W'
                     ||
                        FUN.info(
                           'Kopiowanie zakończone, utworzono wzorzec: \'%1\'.'@[_what]+
                           '\n\n'+'Nowy wzorzec znajduje się w zbiorze wzorców niearchiwalnych.'@
                        )
                     || FUN.info(
                           'Kopiowanie zakończone, utworzono kartę: \'%1\'.'@[_what]+
                           '\n\n'+'Nowa karta znajduje się w zbiorze kart niearchiwalnych.'@
                        )
                     ?}
                  ||
                     {? TKTL.f_active()>1 & ~TKTL.f_test()
                     || _msg:='\n\n'+
                              'Dodany zapis nie znajduje się w bieżącym filtrze użytkownika.\nNależy zmienić filtr.'@
                     || _msg:=''
                     ?};
                     {? TKTL.TORW='T'
                     || FUN.info('Kopiowanie zakończone, utworzono kartę: \'%1\'.'@[_what]+_msg)
                     || FUN.info('Kopiowanie zakończone, utworzono wzorzec: \'%1\'.'@[_what]+_msg)
                     ?};
                     {? TKTL.f_active()=1 | (TKTL.f_active()>1 & TKTL.f_test()) || TKTL.f_add() ?}
                  ?}
               || FUN.emsg('Kopiowanie zakończone niepowodzeniem.'@)
               ?}
            || FUN.emsg('Kopiowanie zakończone niepowodzeniem.'@)
            ?}
         ?}
      ?};
      exec('tktl_unlock','tech_common',#_tktl,'N');
      exec('tktl_unlock','tech_common',#_tktl,'O');
      exec('tktl_unlock','tech_common',#_tktl,'S');
      exec('tktl_unlock','tech_common',#_tktl,'P')
   ?}
?};
TKTL.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result


\tktl_copy
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Kopiuje kartę technologiczną (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
::  TAG: <PRYWATNA><TECHNOLOGIE><ARCHIWIZACJA><KOPIOWANIE>
::  OLD: \tktl_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

:: Sprawdzam poprawność argumentów
{? _args.DELETE=1 & _args.COPY_ACT=1
||
:: Nie można kasować źródła i jednocześnie kopiować tylko aktywnych elementów
:: bo tylko aktywne elementy zostałyby usunięte i usunięcie całej karty by się nie powiodło
   FUN.wdrerror('Nieprawidłowe argumenty formuły tktl_copy/tech_arch.fml'@)
?};
{? _args.DELETE=1 & _args.FILL_SRC=1
||
:: Nie można kasować źródła i jednocześnie wypełniać TMATom i TOPERom pol SRC, bo
:: od razu prowadziłyby one do rekordów które za chwilę zostaną usunięte
   FUN.wdrerror('Nieprawidłowe argumenty formuły tktl_copy/tech_arch.fml'@)
?};

_result:=0;
_can_continue:=1;

TKTL.cntx_psh();
TPKTL.cntx_psh();

_mask_src:=form((TKTL.name()-3)+_args.MASK_SRC);
_mask_dst:=form((TKTL.name()-3)+_args.MASK_DST);

:: Przed rozpoczęciem kopiowania pytam o parametry i zapisuje je w _args.TPAR_TAB
{? _args.TPAR_ASK>0
|| exec('tpar_val_ask','tech_arch',_args)
?};

:: Rozpoczynam transakcje jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| do();
   _tran_started:=1
?};

:: Otwieram maske źródłową
TKTL.use(_mask_src);
TKTL.clear();
{? TKTL.seek(_args.TKTL_SRC)
||
:: Stoję na karcie którą chcę przesunąć do innej maski

:: Otwieram maske docelową
   TKTL.use(_mask_dst);
   TKTL.clear();

:: Przypisuję pola skopiowanej technologi
   {? _args.DST_SYM<>''
   || TKTL.NRK:=_args.DST_SYM
   ?};

   {? _args.DST_WER<>''
   || TKTL.WER:=_args.DST_WER
   ?};

   {? _args.DST_ZL<>null()
   || TKTL.ZL:=_args.DST_ZL
   ?};

   {? _args.DST_PL<>null()
   || TKTL.PLRELWYR:=_args.DST_PL
   || TKTL.PLRELWYR:=null()
   ?};

   {? _args.DST_TMASK<>''
   || TKTL.TMASK:=_args.DST_TMASK
   ?};

   {? _args.DST_TORW<>''
   || TKTL.TORW:=_args.DST_TORW
   ?};

   {? _args.DST_STAN<>''
   || TKTL.STAN:=_args.DST_STAN
   ?};

   {? _args.DST_TYP<>null()
   || TKTL.TYP:=_args.DST_TYP
   ?};

   {? _args.DIR='ARCHIWUM'
   || TKTL.ARCH:='T'
   ?};

   {? _args.DIR='KARTOTEKA'
   || TKTL.ARCH:='N'
   ?};

:: Skopiowana nigdy nie jest domyślna
   TKTL.DEFAULT:='N';

:: Skopiowana nie dziedziczy diagramu
   TKTL.DIAG_OP:=null();

:: Czyszczę statusy i czasy modyfikacji karty technologicznej
   {? _args.STATUS_COPY=0
   || TKTL.STAT_N:='N';
      TKTL.TM_MOD_N:=0;
      TKTL.US_MOD_N:=null();
      TKTL.STAT_O:='N';
      TKTL.TM_MOD_O:=0;
      TKTL.US_MOD_O:=null();
      TKTL.STAT_S:='N';
      TKTL.TM_MOD_S:=0;
      TKTL.US_MOD_S:=null();
      TKTL.STAT_P:='N';
      TKTL.TM_MOD_P:=0;
      TKTL.US_MOD_P:=null();
      ~~
   ?};

   {? _args.DST_STAT_N<>''
   || TKTL.STAT_N:=_args.DST_STAT_N;
      {? TKTL.STAT_N='T' || TKTL.STAN:='P' ?}
   ?};

:: Czyszczę lub wypełniam terminy obowiązywania
   TKTL.TERM_OD:=_args.DST_T_OD;
   TKTL.TERM_DO:=_args.DST_T_DO;

:: Czyszczę indeks produktu
   {? _args.COPY_KTM=0
   || TKTL.KTM:=null()
   ?};

:: Wyczyszczenie znacznika, czy karta jest rodzaju 'Ulepszenie', gdy nie są kopiowanie surowce lub produkty
   {? _args.COPY_SUR=0 | _args.COPY_PROD=0
   || TKTL.IMPROVE:='N'
   ?};

:: Dodaję rekord do maski docelowej
   _can_continue:=TKTL.add();

   {? _can_continue>0
   ||
::    Zaczynam przepinać zawartość do maski docelowej
      _args.TKTL_DST:=TKTL.ref();

::    Kopiujemy najpierw te rzeczy które mają najmniej powiązań
      {? _can_continue>0
      ||
::       Parametry
         _can_continue:=exec('tpar_copy','tech_arch',_args)
      ?};
      {? _can_continue>0 & _args.COPY_PROD>0
      ||
::       Produkty karty, wartości parametrów, powiązane kalkulacje
         _can_continue:=exec('tktlw_copy','tech_arch',_args)
      ?};
      {? _can_continue>0 & _args.COPY_KALK>0
      ||
::       Kopiujemy kalkulacje prototypowe
         _can_continue:=exec('kktl_copy','tech_arch',_args)
      ?};
      {? _can_continue>0 & _args.COPY_UAT>0
      ||
::       Atrybuty do karty
         _can_continue:=exec('uat_copy','tech_arch',_args,'TKTL',_args.TKTL_SRC,_args.TKTL_DST)
      ?};
      {? _can_continue>0 & _args.COPY_DOK>0
      ||
::       Dokumentacja do karty
         _can_continue:=DocLib.copy('TKTL',_args.TKTL_SRC,'TKTL',_args.TKTL_DST);

         {? _can_continue>0 & _args.DELETE>0
         || DocLib.del('TKTL',_args.TKTL_SRC)
         ?}
      ?};
      {? _can_continue>0 & _args.COPY_OPER>0
      ||
::       Operacje technologiczne
         _can_continue:=exec('toper_copy','tech_arch',_args)
      ?};

      {? _can_continue>0 & _args.COPY_NAST>0
      ||
::       Następniki operacji
         _can_continue:=exec('nastoper_copy','tech_arch',_args)
      ?};

      {? _can_continue>0 & _args.COPY_SUR>0
      ||
::       Surowce do karty
         _can_continue:=exec('tmat_copy','tech_arch',_args)
      ?};

      {? _can_continue>0 & _args.COPY_NPU>0
      ||
::       Narzędzia do karty
         _can_continue:=exec('tacttls_copy','tech_arch',_args)
      ?};

::    Przepinanie złączeń

::    Tutaj są używane następujace indeksy:
::    ZL.index('RKTL');
::    ZL.index('RTKTL');
::    ANZMAT.index('RTKTL');
::    PL_PART.index('RTKTL');
::    KALMAT.index('RTKTL');
::    PLRELWYR.index('RTKTL');
::    TCHMAT.index('RKTL');
::    TMAT.index('RKTL');
::    TMAT.index('SRC');
::    PX_TEX.index('RTKTL');
::    PX_STAGE.index('RTKTL');
::    PX_NAST.index('RTKTL');
      _args_upd:=exec('fields_upd_a','tech_arch');
      _args_upd.DIR:=_args.DIR;
      _args_upd.REF_SRC:=_args.TKTL_SRC;
      _args_upd.REF_DST:=_args.TKTL_DST;
::
      {? _can_continue>0 & _args.DELETE>0
      ||
         _args_upd.ACR_TAB:='ZL';
         _args_upd.INDEX:='RKTL';
         _can_continue:=exec('fields_upd','tech_arch' ,_args_upd)
      ?};
      {? _can_continue>0 & _args.DELETE>0
      ||
         _args_upd.ACR_TAB:='ZL';
         _args_upd.INDEX:='RTKTL';
         _can_continue:=exec('fields_upd','tech_arch' ,_args_upd)
      ?};
      {? _can_continue>0 & _args.DELETE>0
      ||
         _args_upd.ACR_TAB:='ANZMAT';
         _args_upd.INDEX:='RTKTL';
         _can_continue:=exec('fields_upd','tech_arch' ,_args_upd)
      ?};
      {? _can_continue>0 & _args.DELETE>0
      ||
         _args_upd.ACR_TAB:='PL_PART';
         _args_upd.INDEX:='RTKTL';
         _can_continue:=exec('fields_upd','tech_arch' ,_args_upd)
      ?};
      {? _can_continue>0 & _args.DELETE>0
      ||
         _args_upd.ACR_TAB:='KALMAT';
         _args_upd.INDEX:='RTKTL';
         _can_continue:=exec('fields_upd','tech_arch',_args_upd)
      ?};
      {? _can_continue>0 & _args.DELETE>0
      ||
         _args_upd.ACR_TAB:='PLRELWYR';
         _args_upd.INDEX:='RTKTL';
         _can_continue:=exec('fields_upd','tech_arch' ,_args_upd)
      ?};
      {? _can_continue>0 & _args.DELETE>0
      ||
         _args_upd.ACR_TAB:='PLRELWYR';
         _args_upd.INDEX:='RKTL';
         _args_upd.FLD_REL:='TECH';
         _can_continue:=exec('fields_upd','tech_arch' ,_args_upd);
         _args_upd.FLD_REL:=''
      ?};
::
      {? _can_continue>0 & _args.DELETE>0
      ||
         _args_upd.ACR_TAB:='TCHMAT';
         _args_upd.INDEX:='RKTL';
         _can_continue:=exec('fields_upd','tech_arch',_args_upd)
      ?};
      {? _can_continue>0 & _args.DELETE>0
      ||
         _args_upd.ACR_TAB:='TMAT';
         _args_upd.INDEX:='RKTL';
         _can_continue:=exec('fields_upd','tech_arch',_args_upd)
      ?};
      {? _can_continue>0 & _args.DELETE>0
      ||
         _args_upd.ACR_TAB:='PX_TEX';
         _args_upd.INDEX:='RTKTL';
         _can_continue:=exec('fields_upd','tech_arch' ,_args_upd)
      ?};
      {? _can_continue>0 & _args.DELETE>0
      ||
         _args_upd.ACR_TAB:='PX_STAGE';
         _args_upd.INDEX:='RTKTL';

         _can_continue:=exec('fields_upd','tech_arch' ,_args_upd)
      ?};
      {? _can_continue>0 & _args.DELETE>0
      ||
         _args_upd.ACR_TAB:='PX_NAST';
         _args_upd.INDEX:='RTKTL';

         _can_continue:=exec('fields_upd','tech_arch' ,_args_upd)
      ?};
      {? _can_continue>0 & _args.DELETE>0
      ||
         _args_upd.ACR_TAB:='PX_TAG';
         _args_upd.INDEX:='RTKTL';

         _can_continue:=exec('fields_upd','tech_arch' ,_args_upd)
      ?};

::
::    Automatycznie dezaktywuje/aktywuje przepisy planistyczne bazujace na tej karcie
      {? _can_continue>0
      || _can_continue:=exec('px_tex_akt','tech_arch',_args.TKTL_DST,_args.DIR)
      ?};
::
::    Kasowanie pozostałej zawartości karty technologicznej źródłowej
      {? _can_continue>0 & _args.DELETE>0
      ||
         TOPER.cntx_psh();
         _mask_toper:=form((TOPER.name()-3)+_args.MASK_SRC);
         TOPER.use(_mask_toper);
         _can_continue:=exec('TOPER_kasuj','tech_oper',_args.TKTL_SRC,0);
         TOPER.cntx_pop()
      ?};
      {? _can_continue>0 & _args.DELETE>0
      ||
         TPAR.cntx_psh();
         _mask_tpar:=form((TPAR.name()-3)+_args.MASK_SRC);
         TPAR.use(_mask_tpar);
         _can_continue:=exec('TPAR_kasuj','tech_param',_args.TKTL_SRC);
         TPAR.cntx_pop()
      ?};
      {? _can_continue>0 & _args.DELETE>0
      || _can_continue:=DocLib.del('TKTL',_args.TKTL_SRC)
      ?};

::    Kasowanie karty technologicznej źródłowej
      {? _can_continue>0 & _args.DELETE>0
      || TKTL.cntx_psh();
         TKTL.use(_mask_src);
         TKTL.clear();
         {? TKTL.seek(_args.TKTL_SRC)
         ||
::          Jeśli to się nie uda to znak że nie usunięto całej zawartości karty, lub
::          nie przepięto wszystkich złączeń na SQL ref
            {? TKTL.count()>0
            || KOMM.add('Źródłowej karty %1 wer. %2 nie udało się usunąć — należy sprawdzić powiązania.'@[TKTL.NRK,TKTL.WER],2,,1);
               _can_continue:=0
            || _can_continue:=TKTL.del(,1)
            ?}
         ?};
         TKTL.cntx_pop()
      ?};

      {? _can_continue>0 & (_args.TPAR_ASK>0 | _args.M_VALS<>null())
      ||
::       Jeśli technologia docelowa jest parametryzowalna i wartości parametrów mogły ulec zmianie
::       to przeliczam wszystkie normy i czasy
         TKTL.cntx_psh();
         TKTL.use(_mask_dst);
         TKTL.clear();
         {? TKTL.seek(_args.TKTL_DST)
         ||
            {? TKTL.TYP().PAR='T'
            ||
               {? var_pres('tpar',@)>0 || obj_del(tpar) ?};
               tpar:=obj_new(@.CLASS.TPAr);
               tpar.TABLE:=TPAR;
               tpar.INDEX:='NN';
               tpar.PREFIX:=TKTL.ref();
               tpar.loadp();
               exec('recalculate','tech_param',TKTL.ref());
               exec('stop_tpar','tech_param')
            ?}
         ?};
         TKTL.cntx_pop()
      ?};
      ~~
   ?}
?};
TPKTL.cntx_pop();
TKTL.cntx_pop();

:: Przypisuję zleceniu skopiowaną technologię
{? _can_continue>0 & _args.ZL_SET<>null()
|| ZL.cntx_psh(); ZL.clear();
   {? ZL.seek(_args.ZL_SET)
   || ZL.TKTL:=_args.TKTL_DST;
      _can_continue:=ZL.put()
   ?};
   ZL.cntx_pop();
   ZL.get()
?};

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\toper_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje wszystkie operacje technologiczne danej karty (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::       [_b] - tablica z refami rekordów TOPER do przekopiowania.
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \toper_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_records:={? var_pres('_b')>100 || _b || ~~ ?};

_from_tab:={? var_pres('_records')>100 & _records.size()>0 || 1 || 0 ?};
_nop_src:=exec('FindAndGet','#table','TOPER',_args.TOPER_SRC,,"UNROP",0);
_nop_dst:=exec('FindAndGet','#table','TOPER',_args.TOPER_DST,,"UNROP",0);

_result:=0;
_can_continue:=1;

_mask_src:=form((TOPER.name()-3)+_args.MASK_SRC);
_mask_dst:=form((TOPER.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| do();
   _tran_started:=1
?};

_old_src:=_args.TOPER_SRC;
_old_dst:=_args.TOPER_DST;

TOPER.cntx_psh();
:: Otwieram maskę źródłową
TOPER.use(_mask_src);

TOPER.index('NNN');
{? _args.TOPER_NR>=0
|| TOPER.prefix(_args.TKTL_SRC,_nop_src,'N',_args.TOPER_NR)
|| {? _args.OPER_ONLY>0
   || TOPER.index('ANNN');
      TOPER.prefix('T','N',_args.TKTL_SRC)
   || TOPER.prefix(_args.TKTL_SRC,_nop_src,'N')
   ?}
?};
{? TOPER.first()
||
   _args_upd:=exec('fields_upd_a','tech_arch');
   _args_upd.DIR:=_args.DIR;

:: W przypadku gdy TOPERy są wkopiowywane do istniejacej technologii (import wzorca)
:: trzeba okreslić nowy nr dla wkopiowywanych operacji na podstawie tego co już istnieje
   _hop:=0;
   {? _args.TOPER_NR<0 & _args.OPER_RENUM>0
   || TOPER.cntx_psh();
      TOPER.use(_mask_dst);
      {? _args.TOPER_DST<>null()
      || TOPER.index('NNN');
         TOPER.prefix(_args.TKTL_DST,_nop_dst,'N')
      || TOPER.index('NNN');
         TOPER.prefix(_args.TKTL_DST,0,'N')
      ?};
      {? TOPER.last()
      || _hop:=TOPER.NROP+1;

         _id_tktl:=exec('FindAndGet','#table',TKTL
                                             ,_args.TKTL_DST
                                             ,
                                             ,"NRK+' wer. '+WER"
                                             ,'');
         KOMM.add('W karcie %1 są już wpisane operacje. '
                  'Nowe operacje zostaną wpisane od pozycji nr %2.'@[_id_tktl,$(_hop)],7,,1)
      || _args.OPER_RENUM:=0
      ?};
      TOPER.cntx_pop()
   ?};

   {!
   |?
      {? _from_tab=0 | (_from_tab>0 & _records.find_tab(,'REF',,'=',#TOPER.ref()))
      ||
::       Pobranie notatki
         TOPER.memo_get(,'OPISMEMO',0);

         _next:=0;
         _act:=1;
         {? _args.COPY_ACT>0
         ||
::          Sprawdzam status aktywności elementu który chcę skopiować
            {? TOPER.ACT='T'
            || _act:=1
            || _act:=0
            ?}
         ?};

         {? _act>0
         ||
            _args.TOPER_SRC:=TOPER.ref();
::          Stoję na źródłowej operacji, otwieram maskę docelową
            TOPER.cntx_psh();
            TOPER.use(_mask_dst);
            TOPER.clear();
            TOPER.NRK:=_args.TKTL_DST;
            TOPER.UNROP:=exec('boperunr','tech_oper');
            TOPER.NRNOP:=_nop_dst;
            {? _args.OPER_RENUM>0
            || TOPER.NROP:=_hop
            ?};

            {? _args.FILL_SRC>0
            || TOPER.SRC:=$_args.TOPER_SRC
            ?};
            {? _args.STATUS_COPY=0
            || TOPER.CRE_TIME:=0;
               TOPER.MOD_TIME:=0;
               TOPER.USER:=null();
               TOPER.CAUSE:=null()
            ?};
            TOPER.TKTL_KTM:=exec('FindAndGet','#table',TKTL,TOPER.NRK,,"KTM",null());
            _can_continue:=TOPER.add();
            {? _can_continue>0
            ||
               {? _args.OPER_RENUM>0
               || _hop+=1
               ?};
::             Tworzę rekord do historii, żebym później mógł trafić z nowego TOPERa
::             do starego
               _args.TOPER_TAB.prefix($_args.TOPER_SRC,$TOPER.ref());
               {? _args.TOPER_TAB.size()=0
               || _args.TOPER_TAB.blank();
                  _args.TOPER_TAB.REF_NEW:=$TOPER.ref();
                  _args.TOPER_TAB.REF_OLD:=$_args.TOPER_SRC;
                  _args.TOPER_TAB.add()
               ?};

::             Kopiuję MEMO
               TOPER.memo_put(,'OPISMEMO');
               _args.TOPER_DST:=TOPER.ref()
            ?};

            TOPER.cntx_pop();

            {? _can_continue>0
            ||
::             1. Kopiuję operacje podrzędne

::             !!! REKURENCJA !!!
               _oper_nr:=_args.TOPER_NR;
               _oper_only:=_args.OPER_ONLY;
               _oper_renum:=_args.OPER_RENUM;
::             Na czas rekurencyjnego wołania czyszczę TOPER_NR oraz znacznik OPER_ONLY żeby skopiować wszystkie
::             operacje podrzędne a nie tylko jedną
               _args.TOPER_NR:=-1;
               _args.OPER_ONLY:=0;
               _args.OPER_RENUM:=0;
               _can_continue:=exec('toper_copy','tech_arch',_args);
               _args.TOPER_NR:=_oper_nr;
               _args.OPER_ONLY:=_oper_only;
               _args.OPER_RENUM:=_oper_renum
            ?};

            {? _can_continue>0
            ||
::             2. Kopiuje TMATy
               _can_continue:=exec('tmat_copy','tech_arch',_args)
            ?};

            {? _can_continue>0
            ||
::             2. Kopiuje TACTTLS
               _can_continue:=exec('tacttls_copy','tech_arch',_args)
            ?};

            {? _can_continue>0
            ||
::             3. Kopiuje TCHMAT
               _can_continue:=exec('tchmat_copy','tech_arch',_args)
            ?};

            {? _can_continue>0
            ||
::             4. Kopiuje TECHZAMS
               _can_continue:=exec('techzams_copy','tech_arch',_args)
            ?};

            {? _can_continue>0
            ||
::             5. Kopiuje TPZty
               _can_continue:=exec('tpz_copy','tech_arch',_args)
            ?};

            {? _can_continue>0
            ||
::             6. Kopiuje dokumentację
               _can_continue:=DocLib.copy('TOPER',_args.TOPER_SRC,'TOPER',_args.TOPER_DST);

               {? _can_continue>0 & _args.DELETE>0
               || DocLib.del('TOPER',_args.TOPER_SRC)
               ?}
            ?};

            {? _can_continue>0
            ||
::             7. Kopiuje atrybuty
               _can_continue:=exec('uat_copy','tech_arch',_args,'TOPER',_args.TOPER_SRC,_args.TOPER_DST)
            ?};

::          Przepinanie złączeń
            _args_upd.REF_SRC:=_args.TOPER_SRC;
            _args_upd.REF_DST:=_args.TOPER_DST;
            _args_upd.INDEX:='RTOPER';

::          Tutaj są używane następujące indeksy
::          PL_OPER.index('RTOPER');
::          ZGP.index('RTOPER');
::          TOPER.index('SRC');
::          PX_STAGE.index('RTOPER');

            {? _can_continue>0 & _args.DELETE>0
            ||
               _args_upd.ACR_TAB:='PL_OPER';
               _can_continue:=exec('fields_upd','tech_arch',_args_upd)
            ?};

            {? _can_continue>0 & _args.DELETE>0
            ||
               _args_upd.ACR_TAB:='PX_STAGE';
               _can_continue:=exec('fields_upd','tech_arch',_args_upd)
            ?};

            {? _can_continue>0 & _args.DELETE>0
            ||
               _args_upd.ACR_TAB:='ZGP';
               _can_continue:=exec('fields_upd','tech_arch',_args_upd)
            ?};
            {? _can_continue>0 & _args.DELETE>0
            ||
               _args_upd.ACR_TAB:='TOPER';
               _args_upd.INDEX:='SRC';
               _args_upd.REL_UPD:=0;
               _can_continue:=exec('fields_upd','tech_arch',_args_upd);
               _args_upd.REL_UPD:=1
            ?}
         ?}
      ?};
      TOPER.next() & _can_continue>0
   !}
?};
_args.TOPER_SRC:=_old_src;
_args.TOPER_DST:=_old_dst;
TOPER.cntx_pop();
{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\tpz_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje wszystkie TPZty należące do przekazanej operacji
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \tpz_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_args_upd:=exec('fields_upd_a','tech_arch');
_args_upd.DIR:=_args.DIR;
_args_upd.INDEX:='RTOPER';

_result:=0;
_can_continue:=1;

_mask_src:=form((TOPER.name()-3)+_args.MASK_SRC);
_mask_dst:=form((TOPER.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| do();
   _tran_started:=1
?};

TOPER.cntx_psh();
:: Otwieram maske źródłową
TOPER.use(_mask_src);

TOPER.index('TPZ');
_nop_src:=exec('FindAndGet','#table','TOPER',_args.TOPER_SRC,,"UNROP",0);
_nop_dst:=exec('FindAndGet','#table','TOPER',_args.TOPER_DST,,"UNROP",0);
TOPER.prefix('T',_nop_src);
{? TOPER.first()
|| {!
   |?
      _act:=1;
      {? _args.COPY_ACT>0
      ||
::       Sprawdzam status aktywności elementu który chcę skopiować
         {? TOPER.ACT='T'
         || _act:=1
         || _act:=0
         ?}
      ?};

      {? _act>0
      ||
         _args_upd.REF_SRC:=TOPER.ref();
::       Stoję na źródłowym TPZ, otwieram maskę docelowa
         TOPER.cntx_psh();
         TOPER.use(_mask_dst);
         TOPER.clear();
         TOPER.NRK:=_args.TKTL_DST;
         TOPER.UNROP:=exec('boperunr','tech_oper');
::       Nowy TPZ musi odziedziczyć NRNOP z operacji do której należy
         TOPER.NRNOP:=exec('FindAndGet','#table','TOPER',_args.TOPER_DST,,"NRNOP",0);
         TOPER.TPZREF:=_nop_dst;
         TOPER.TKTL_KTM:=exec('FindAndGet','#table',TKTL,TOPER.NRK,,"KTM",null());
         _can_continue:=TOPER.add();

         {? _can_continue>0 & _args.DELETE>0
         ||
            _args_upd.ACR_TAB:='ZGP';
            _args_upd.REF_DST:=TOPER.ref();
            _can_continue:=exec('fields_upd','tech_arch',_args_upd)
         ?};

         TOPER.cntx_pop()
      ?};
      TOPER.next() & _can_continue>0
   !}
?};
TOPER.cntx_pop();
{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\nastoper_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje wszystkie następniki operacji dla danej technologii (być może do innej maski)
::       Wymaga aby tablica _args.TOPER_TAB była wypełniona
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \nastoper_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mask_src:=form((NASTOPER.name()-3)+_args.MASK_SRC);
_mask_dst:=form((NASTOPER.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcje jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| _tran_started:=do()
?};

_tab:=_args.TOPER_TAB;
_tab.cntx_psh();
TOPER.cntx_psh();
NASTOPER.cntx_psh();
:: Otwieram maskę źródłową
NASTOPER.use(_mask_src);
NASTOPER.index('KTLIDSTR');
NASTOPER.prefix(_args.TKTL_SRC);
{? NASTOPER.first()
|| {!
   |?
      _next:=0;
      _act:=1;
      {? _args.COPY_ACT>0
      ||
::       Sprawdzam status aktywności elementu który chcę skopiować
         {? NASTOPER.ACT='T'
         || _act:=1
         || _act:=0
         ?}
      ?};

      {? _act>0
      ||
::       Stoję na źródłowym następniku, otwieram maske docelową i zakładam nowy następnik
         _path_src:=NASTOPER.SCIEZKA;

         _found:=1;
         _tab.prefix($NASTOPER.OPER);
         {? _tab.first()
         ||
::          Tworzę nowego NASTOPERa
            NASTOPER.cntx_psh();
            NASTOPER.use(_mask_dst);
            NASTOPER.clear();

            NASTOPER.SCIEZKA:=_path_src;
            NASTOPER.KTL:=_args.TKTL_DST;

::          Znajduję docelową operację
            NASTOPER.OPER:=exec('FindAndGet','#table','TOPER',_tab.REF_NEW,,,null());

::          Znajduję docelową operację następną
            _tab.cntx_psh();
            _tab.prefix($NASTOPER.NRNAST);
            {? _tab.first()
            || NASTOPER.NRNAST:=exec('FindAndGet','#table','TOPER',_tab.REF_NEW,,,null())
            || _can_continue:=0
            ?};
            _tab.cntx_pop();

            {? _can_continue>0
            || _can_continue:=NASTOPER.add()
            ?};
            NASTOPER.cntx_pop()
         || _found:=0
         ?};

         {? _can_continue>0
         ||
            {? _args.DELETE>0 & _found>0
            ||
::             Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
               {? NASTOPER.del(,1)>0
               || _next:=NASTOPER.first()
               || _can_continue:=0;
                  _next:=0
               ?}
            ||
::             Opcja bez kasowania, ustawiam sie na następnym rekordzie
               _next:=NASTOPER.next()
            ?}
         ?}
      ||
::       Stoję na nieaktywnym następniku, ustawiam się na następny
         _next:=NASTOPER.next()
      ?};
      _next>0 & _can_continue>0
   !}
?};
_tab.cntx_pop();
TOPER.cntx_pop();
NASTOPER.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\fields_upd_a
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Argumenty dla funkcji fields_upd
::   WY: obj_new() - tablica nazwana
::  OLD: \fields_upd_a/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=obj_new(
::             Kierunek kopiowania: ARCHIWUM, KARTOTEKA
                'DIR'
::             Akronim tabeli ktorej pola podmieniac
               ,'ACR_TAB'
::             Akronim indeksu za pomoca ktorego szukac rekordow np RTKTL
               ,'INDEX'
::             Rekord tabeli przesuwany do archiwum/przywracany z archiwum
               ,'REF_SRC'
::             Nowy rekord tabeli w archiwum/kartotece
               ,'REF_DST'
::             Akronim pola zlaczeniowego ktore uaktualniac - jesli nie podane, to
::             tworzone automatycznie: 'R'-_args.INDEX
               ,'FLD_REL'
::             Akronim pola sql ref ktore uaktualniac - jesli nie podane, to
::             to rowne INDEX
               ,'FLD_SQL'
::             Czy uaktualniac pole zlaczeniowe?
               ,'REL_UPD'
               );
_args.DIR:='';
_args.ACR_TAB:='';
_args.INDEX:='';
_args.REF_SRC:=null();
_args.REF_DST:=null();
_args.FLD_REL:='';
_args.FLD_SQL:='';
_args.REL_UPD:=1;
_args


\fields_upd
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Podmienia pola zlaczeniowe i SQL refowe przy przywracaniu/dodawaniu do archiwum
::       W przypadku przesuwania do archiwum:
::          - pole zlaczeniowe jest nullowane
::          - pole ref sqlowe jest wypelniane
::       W przypadku przywracania z archiwum:
::          - pole zlaczeniowe jest wypelniane
::          - pole ref sqlowe jest czyszczone
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('fields_upd_a','tech_arch')
::   WY: 0 - porazka
::       1 - sukces
::  OLD: \fields_upd/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_tab:=($_args.ACR_TAB)();

_result:=0;

:: Tworzę formułę którą wykonam we wszystkich maskach
_ff:="
      _args:=_b;
      _tab:=($_args.ACR_TAB)();

      _fld_rel:='';
      {? _args.INDEX*'R'=1
      || _fld_rel:=1-_args.INDEX
      ?};

      {? _args.FLD_REL<>''
      || _fld_rel:=_args.FLD_REL
      ?};

      _fld_sql:=_args.INDEX;
      {? _args.FLD_SQL<>''
      || _fld_sql:=_args.FLD_SQL
      ?};

      _result:=0;
      _can_continue:=1;

      _tab.cntx_psh();
      _tab.clear();

      _tab.index(_args.INDEX);
      _tab.prefix($_args.REF_SRC,);
      {? _tab.first()
      || {!
         |?
            _tab.cntx_psh();
            _tab.clear();
::          Uaktualniam pole z sql refem
            _ff_sql:=$(_args.ACR_TAB+'.'+_fld_sql+':=_a');
            _ff_sql($_args.REF_DST);

::          Uaktualniam pole złączeniowe
            {? _fld_rel<>'' & _args.REL_UPD>0
            ||
               _ff_rel:=$(_args.ACR_TAB+'.'+_fld_rel+':=_a');
               {? _args.DIR='KARTOTEKA'
               || _ff_rel(_args.REF_DST)
               |? _args.DIR='ARCHIWUM'
               ||
::                Jesli rekord idzie do archiwum to pole zlaczeniowe jest nullowane
::                aby nie sypalo bledami o niepoprawnej masce np w oknach wertowania (gdzie moglo)
::                zostac wstawione przez uzytkownika jako dodatkowa kolumna
                  _ff_rel(null())
               ?}
            ?};
            _can_continue:=_tab.put();
            _tab.cntx_pop();
            _tab.first() & _can_continue>0
         !}
      ?};
      _tab.cntx_pop();
      {? _can_continue>0
      || _result:=1
      ?};
      _result
";
:: Uruchamiam formułę we wszystkich maskach
_result:=exec('for_each_mask','#table',_tab,_ff,,,_args,1);
_result


\techzams_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje wszystkie zamienniki stanowisk dla danej operacji (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \techzams_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mask_src:=form((TECHZAMS.name()-3)+_args.MASK_SRC);
_mask_dst:=form((TECHZAMS.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| do();
   _tran_started:=1
?};

TECHZAMS.cntx_psh();
:: Otwieram maskę źródłową
TECHZAMS.use(_mask_src);

TECHZAMS.index('TL');
TECHZAMS.prefix(_args.TOPER_SRC);
{? TECHZAMS.first()
|| {!
   |?
      _next:=0;
      _act:=1;
      {? _args.COPY_ACT>0
      ||
::       Sprawdzam status aktywności elementu który chcę skopiować
         {? TECHZAMS.ACT='T'
         || _act:=1
         || _act:=0
         ?}
      ?};

      {? _act>0
      ||
::       Stoję na źródłowym zamienniku, otwieram maskę docelową i zakładam nowy zamiennik
         TECHZAMS.cntx_psh();
         TECHZAMS.use(_mask_dst);
         TECHZAMS.clear();
         TECHZAMS.NRK:=_args.TKTL_DST;
         TECHZAMS.TOPER:=_args.TOPER_DST;
         {? _args.STATUS_COPY=0
         || TECHZAMS.CRE_TIME:=0;
            TECHZAMS.MOD_TIME:=0;
            TECHZAMS.USER:=null();
            TECHZAMS.CAUSE:=null()
         ?};
         _can_continue:=TECHZAMS.add();
         TECHZAMS.cntx_pop();

         {? _can_continue>0
         ||
            {? _args.DELETE>0
            ||
::             Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
               {? TECHZAMS.del(,1)>0
               || _next:=TECHZAMS.first()
               || _can_continue:=0;
                  _next:=0
               ?}
            ||
::             Opcja bez kasowania, ustawiam się na następnym rekordzie
               _next:=TECHZAMS.next()
            ?}
         ?}
      ||
::       Stoję na nieaktywnym zamienniku, idę na następny
         _next:=TECHZAMS.next()
      ?};
      _next>0 & _can_continue>0
   !}
?};

TECHZAMS.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Konczę transakcję
{? _tran_started>0
|| end()
?};
_result


\tpar_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuję wszystkie parametry karty technologicznej (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \tpar_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mask_src:=form((TPAR.name()-3)+_args.MASK_SRC);
_mask_dst:=form((TPAR.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| do();
   _tran_started:=1
?};

TPAR.cntx_psh();
:: Otwieram maskę źródłową
TPAR.use(_mask_src);

TPAR.index('NN');
TPAR.prefix(_args.TKTL_SRC);
{? TPAR.first()
||
   _args_upd:=exec('fields_upd_a','tech_arch');
   _args_upd.DIR:=_args.DIR;

   {!
   |?
      _already:=0;

::    Sprawdzam czy w docelowej karcie jest już parametr o takim numerze
      TPAR.cntx_psh();
      TPAR.use(_mask_dst);
      TPAR.index('NN');
      TPAR.prefix(_args.TKTL_DST,TPAR.NRP);
      {? TPAR.first()
      || _already:=1;
         KOMM.add('W karcie występuje już parametr nr %1. Poprzednia wartość zostaje zachowana.'@[$TPAR.NRP],7,,1)
      ?};
      TPAR.cntx_pop();

      {? _already=0
      ||
::       Stoje na źródłowym parametrze, otwieram maskę docelową i zakładam nowy parametr
         _src:=TPAR.ref();
         _dst:=null();
         TPAR.cntx_psh();
         TPAR.use(_mask_dst);
         TPAR.clear();
         TPAR.NRK:=_args.TKTL_DST;
         _can_continue:=TPAR.add();

         {? _can_continue>0
         || _dst:=TPAR.ref();
            _args.TPAR_TAB.prefix($_src,$TPAR.ref,);
            {? _args.TPAR_TAB.size()=0
            || _args.TPAR_TAB.blank();
               _args.TPAR_TAB.REF_NEW:=$TPAR.ref();
               _args.TPAR_TAB.REF_OLD:=$_src;
               _args.TPAR_TAB.add()
            ?}
         ?};
         TPAR.cntx_pop();

::       Przepinanie złączeń
         _args_upd.REF_SRC:=_src;
         _args_upd.REF_DST:=_dst;
         _args_upd.INDEX:='RTPAR';

::       Tutaj są używane następujące indeksy
::       TPARTRA.index('RTPAR');

         {? _can_continue>0 & _args.DELETE>0
         ||
            _args_upd.ACR_TAB:='TPARTRA';
            _args_upd.FLD_REL:='PAR';
            _can_continue:=exec('fields_upd','tech_arch',_args_upd);
            _args_upd.FLD_REL:=''
         ?}
      ?};
      TPAR.next() & _can_continue>0
   !}
?};

TPAR.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\tktlw_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuję wszystkie produkty karty technologicznej (być może do innej maski)
::       Kontekst pracy - skopiowane wcześniej TPARy
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porazka
::       1 - sukces
::  OLD: \tktlw_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mask_src:=form((TKTLW.name()-3)+_args.MASK_SRC);
_mask_dst:=form((TKTLW.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| do();
   _tran_started:=1
?};

TKTLW.cntx_psh();
:: Otwieram maske źródłową
TKTLW.use(_mask_src);

TKTLW.index('REF');
TKTLW.prefix(_args.TKTL_SRC);
{? TKTLW.first()
|| {!
   |?
      _can_copy:=1;
      {? _args.M_ONLY<>null() & _args.M_ONLY<>TKTLW.KTM
      ||
::       Jeśli w argumentach podany produkt który kopiować, to jeśli się różni
::       nie kopiuję TKTLW
         _can_copy:=0
      ?};

      {? _can_copy>0
      ||
::       Stoję na źródłowym produkcie karty, otwieram maskę docelową i zakładam nowy produkt
         _src:=TKTLW.ref();
         _dst:=null();
         TKTLW.cntx_psh();
         TKTLW.use(_mask_dst);
         TKTLW.index('ASTN');
         TKTLW.clear();

::       Kopiując TKTLW zawsze ustawiam że niedomyślna
         TKTLW.DEFAULT:='N';

         TKTLW.TKTL:=_args.TKTL_DST;
         _can_continue:=TKTLW.add();
         {? _can_continue>0
         || _dst:=TKTLW.ref()
         ?};
         TKTLW.cntx_pop();

         {? _can_continue>0
         ||
::          Kopiujemy wartości parametrów
            _can_continue:=exec('twpar_copy','tech_arch',_args,_src,_dst)
         ?};

         {? _can_continue>0 & _args.COPY_KALK>0
         ||
::          Kopiujemy kalkulacje
            _can_continue:=exec('kktl_copy','tech_arch',_args,_src,_dst)
         ?};

         _next:=0;
         {? _can_continue>0
         || {? _args.DELETE>0
            ||
::             Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
               {? TKTLW.del(,1)>0
               || _next:=TKTLW.first()
               || _can_continue:=0;
                  _next:=0
               ?}
            ||
::             Opcja bez kasowania, ustawiam sie na następnym rekordzie
               _next:=TKTLW.next()
            ?}
         ?}
      ||
::       Nie kopiowałem, więc przechodzę na następny rekord
         _next:=TKTLW.next()
      ?};
      _next>0 & _can_continue>0
   !}
?};

TKTLW.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Konczę transakcję
{? _tran_started>0
|| end()
?};
_result


\twpar_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje wartosci parametrów karty technologicznej dla danego wyrobu (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::       _b - TKTLW.ref - źródłowy produkt karty
::       _c - TKTLW.ref - docelowy produkt karty
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \twpar_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_lw_src:=_b;
_lw_dst:=_c;

_result:=0;
_can_continue:=1;

_mask_src:=form((TWPAR.name()-3)+_args.MASK_SRC);
_mask_dst:=form((TWPAR.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| do();
   _tran_started:=1
?};

TKTLW.cntx_psh();
:: Otwieram źródłową maskę TKTLW
_mask_lw:=ref_name(_lw_src);
TKTLW.use(_mask_lw);

TKTLW.clear();
TPAR.cntx_psh();
TWPAR.cntx_psh();

:: Otwieram źródłową maskę TWPAR
TWPAR.use(_mask_src);

TWPAR.index('TPR');

_tpar_vals:=_args.TPAR_VAL;

{? TKTLW.seek(_lw_src)
||
   TWPAR.prefix(_lw_src);
   {? TWPAR.first()
   || {!
      |?
::       Stoję na źródłowej wartości, otwieram maske docelową i zakładam nową wartość
         _src:=$TWPAR.ref();
         _src_tpar:=TWPAR.TPAR;
         TWPAR.cntx_psh();
         TWPAR.use(_mask_dst);
         TWPAR.clear();

::       Otwieram źródłową maskę TPAR i podczytuję numer TPARa
         _mask_tpar:=ref_name(TWPAR.TPAR);
         {? _mask_tpar<>''
         || TPAR.use(_mask_tpar)
         ?};
         _nr:=TWPAR.TPAR().NRP;

::       Otwieram docelową maskę TPAR i dodaję mu wartość
         _mask_tpar:=form((TPAR.name()-3)+_args.MASK_DST);
         TPAR.use(_mask_tpar);

         TPAR.index('NN');
         TPAR.prefix(_args.TKTL_DST,_nr);
         {? TPAR.first()
         || TWPAR.TKTLW:=_lw_dst;
            TWPAR.KTM:=TKTLW.KTM;
            TWPAR.TPAR:=TPAR.ref();

::          Sprawdzam czy w tabeli tymczasowej z wartościami parametrów znajduje
::          sie jakaś wartość, jeśli tak to ją wykorzystuję
            _tpar_vals.prefix($_src_tpar,$_lw_src);
            {? _tpar_vals.first()
            || TWPAR.VAL:=_tpar_vals.VALUE;

::             Jeśli wartość ma się stać wartością domyślną to ją wpisuję do docelowego TPARa
               {? _tpar_vals.DEFAULT='T'
               || TPAR.DEFAULT1:=_tpar_vals.VALUE;
                  _can_continue:=TPAR.put()
               ?}
            |? _args.M_VALS=TWPAR.KTM
            ||
::             Jeśli kopiowany tylko jeden produkt to podmieniam wartość domyślną parametru
               TPAR.DEFAULT1:=TWPAR.VAL;
               _can_continue:=TPAR.put()
            ?};
::          Dodaję nowy rekord TWPAR
            {? _can_continue>0
            || _can_continue:=TWPAR.add()
            ?}
         ?};
         TWPAR.cntx_pop();

         _next:=0;
         {? _can_continue>0
         || {? _args.DELETE>0
            ||
::             Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
               {? TWPAR.del(,1)>0
               || _next:=TWPAR.first()
               || _can_continue:=0;
                  _next:=0
               ?}
            ||
::             Opcja bez kasowania, ustawiam się na następnym rekordzie
               _next:=TWPAR.next()
            ?}
         ?};
         _next>0 & _can_continue>0
      !}
   ?}
?};
TKTLW.cntx_pop();
TWPAR.cntx_pop();
TPAR.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Konczę transakcję
{? _tran_started>0
|| end()
?};
_result


\tpartra_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje tabelę translacji parametrów, być może do innej maski
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::       [_b] - TCHMAT.ref() - źródłowy zamiennik surowca
::       [_c] - TCHMAT.ref() - docelowy zamiennik surowca
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \tpartra_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_tchmat:=null();
{? var_pres('_b')=type_of(TCHMAT.ref())
|| _tchmat:=_b
?};

_tchmat_dest:=null();
{? var_pres('_c')=type_of(TCHMAT.ref())
|| _tchmat_dest:=_c
?};

_result:=0;
_can_continue:=1;

_mask_src:=form((TPARTRA.name()-3)+_args.MASK_SRC);
_mask_dst:=form((TPARTRA.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczeta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| do();
   _tran_started:=1
?};

TPARTRA.cntx_psh();
:: Otwieram maske źródłową
TPARTRA.use(_mask_src);

TPARTRA.index('SUR');
{? _tchmat<>null()
|| TPARTRA.prefix(null(),_tchmat)
|? _args.TMAT_SRC<>null()
|| TPARTRA.prefix(_args.TMAT_SRC)
?};
{? TPARTRA.first()
|| {!
   |?
::    Stoję na źródłowej translacji, otwieram maskę docelową i zakładam nową translację
      _src:=$TPARTRA.ref();
      TPARTRA.cntx_psh();
      TPARTRA.use(_mask_dst);
      TPARTRA.clear();
      TPARTRA.SUR:={? _tchmat=null() || _args.TMAT_DST || null() ?};
      TPARTRA.ZAM:=_tchmat_dest;
      _can_continue:=TPARTRA.add();
      TPARTRA.cntx_pop();

      _next:=0;
      {? _can_continue>0
      ||
         {? _args.DELETE>0
         ||
::          Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
            {? TPARTRA.del(,1)>0
            || _next:=TPARTRA.first()
            || _can_continue:=0;
               _next:=0
            ?}
         ||
::          Opcja bez kasowania, ustawiam się na następnym rekordzie
            _next:=TPARTRA.next()
         ?}
      ?};
      _next>0 & _can_continue>0
   !}
?};

TPARTRA.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\tmat_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje wszystkie surowce technologiczne należące do danej karty lub operacji
::       (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::       [_b] - tablica z refami rekordów TMAT do przekopiowania.
::             Wymagana podczas kopiowania poprzez metodę drag & drop (wynik formuły dnd_info('dropped_records')
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \tmat_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_records:={? var_pres('_b')>100 || _b || ~~ ?};

_dnd:={? var_pres('_records')>100 & _records.size()>0 || 1 || 0 ?};
_result:=0;
_can_continue:=1;

_mask_src:=form((TMAT.name()-3)+_args.MASK_SRC);
_mask_dst:=form((TMAT.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| do();
   _tran_started:=1
?};

M.cntx_psh();
TMAT.cntx_psh();
TKTL.cntx_psh();
:: Otwieram maskę źródłową
TMAT.use(_mask_src);

TMAT.index('NNL');
{? _args.SUR_ONLY>0
|| TMAT.prefix(_args.TKTL_SRC)
|? _args.TOPER_SRC<>null()
|| TMAT.prefix(_args.TKTL_SRC,_args.TOPER_SRC)
|| TMAT.prefix(_args.TKTL_SRC,null())
?};

{? TMAT.first()
||
:: Przełączam się na chwilę na maskę docelową i sprawdzam czy tam są jakieś TMATy
   TMAT.cntx_psh();
:: Otwieram maskę docelową
   TMAT.use(_mask_dst);
   TMAT.index('NNL');

:: W przypadku gdy TMATy są wkopiowywane do istniejacej technologii (import wzorca)
:: trzeba okreslić nowy LP dla wkopiowywanych surowców na podstawie tego co już istnieje
   _hop:=1;
   {? _args.TOPER_DST<>null()
   || TMAT.prefix(_args.TKTL_DST,_args.TOPER_DST)
   || TMAT.prefix(_args.TKTL_DST,null())
   ?};
   {? TMAT.last()
   || _hop:=TMAT.LP+1;

      _id_tktl:=exec('FindAndGet','#table',TKTL
                                          ,_args.TKTL_DST
                                          ,
                                          ,"NRK+' wer. '+WER"
                                          ,'');
      _id_tope:=exec('FindAndGet','#table',TOPER
                                          ,_args.TOPER_DST
                                          ,
                                          ,"' dla operacji: '+$NROP"
                                          ,'');
      KOMM.add('W karcie %1%2 są już wpisane surowce. '
               'Nowe surowce zostaną wpisane od pozycji nr %3.'@[_id_tktl,_id_tope,$(_hop)],7,,1)
   ?};
   TMAT.cntx_pop();

   _args_upd:=exec('fields_upd_a','tech_arch');
   _args_upd.DIR:=_args.DIR;

:: Ustawiam się na technologii docelowej
   {? TKTL.ref()<>_args.TKTL_DST
   || {? TKTL.name()<>ref_name(_args.TKTL_DST)
      || TKTL.use(ref_name(_args.TKTL_DST))
      ?};
      TKTL.prefix();
      TKTL.seek(_args.TKTL_DST)
   ?};
   {!
   |?
      {? _dnd=0 | (_dnd>0 & _records.find_tab(,'REF',,'=',#TMAT.ref()))
      ||
         _next:=0;
         _act:=1;
         {? _args.COPY_ACT>0
         ||
::          Sprawdzam status aktywności elementu który chcę skopiować
            {? TMAT.ACT='T'
            || _act:=1
            || _act:=0
            ?}
         ?};

         {? _act>0 & _args.DIR='KARTOTEKA'
         ||
::          Sprawdzenie, czy materiał nie zostanie powielony w ramach karty/operacji
::          lub czy nie jest produktem karty docelowej
            {? TMAT.GRKTM='G'
            || _ktm:=TMAT.TGDFLT().PT
            || _ktm:=TMAT.PT
            ?};
            TMAT.cntx_psh();

::          Otwieram docelową maskę
            TMAT.use(_mask_dst);
            TMAT.index('ANNL_KTM');
::          Sprawdzam czy jest już taki materiał w docelowej karcie/operacji
            TMAT.prefix('T',_args.TKTL_DST,_args.TOPER_DST,_ktm);
            {? TMAT.first()
            || {? KOMM.is_inited()
               || KOMM.add('Materiał %1 nie został zaimportowany — występuje już na liście surowców.'@
                  [TMAT.PT().KTM],2,,1)
               ?};
               _act:=0
            ?};
::          Sprawdzam, czy ten sam surowiec nie jest jednocześnie surowcem do operacji i bez operacji
            {? _act>0
            || _is_null:=_args.TOPER_DST=null();
               {? _is_null>0
               || TMAT.index('ANP');
                  TMAT.prefix('T',_args.TKTL_DST,_ktm)
               || TMAT.index('ANNL_KTM');
                  TMAT.prefix('T',_args.TKTL_DST,null(),_ktm)
               ?};
               {? TMAT.first()
               || {? KOMM.is_inited()
                  || {? _is_null>0
                     || KOMM.add('Materiał %1 nie został zaimportowany — występuje już na liście surowców '
                        'jako surowiec przypisany do operacji.'@[TMAT.PT().KTM],2,,1)
                     || KOMM.add('Materiał %1 nie został zaimportowany — występuje już na liście surowców '
                        'jako surowiec bez przypisanej operacji.'@[TMAT.PT().KTM],2,,1)
                     ?}
                  ?};
                  _act:=0
               ?}
            ?};
            TMAT.cntx_pop();

::          Kontrola wyłączona, obecnie można utworzyć kartę, której surowcem jest jej produkt
::            {? _act>0 & TMAT.PT=exec('FindAndGet','#table',TKTL,_args.TKTL_DST,,"TKTL.KTM",null())
::            || {? KOMM.is_inited()
::               || KOMM.add('Materiał %1 nie został zaimportowany — jest taki sam jak produkt technologii.'@
::                  [TMAT.PT().KTM],2,,1)
::               ?};
::               _act:=0
::            ?};
            ~~
         ?};

         {? _act>0
         ||
            _args.TMAT_SRC:=TMAT.ref();
::          Stoję na źródłowym surowcu, otwieram maskę docelową i zakładam nowy surowiec
            TMAT.cntx_psh();
            TMAT.use(_mask_dst);
            TMAT.clear();
            TMAT.NRK:=_args.TKTL_DST;
            {? _args.TOPER_DST<>null()
            || TMAT.NROP:=_args.TOPER_DST
            || TMAT.NROP:=null()
            ?};
            {? _args.FILL_SRC>0
            || TMAT.SRC:=$_args.TMAT_SRC
            ?};
            {? _args.STATUS_COPY=0
            || TMAT.CRE_TIME:=0;
               TMAT.MOD_TIME:=0;
               TMAT.USER:=null();
               TMAT.CAUSE:=null()
            ?};
::          Zwiększam numer jeśli wkopiowuje do już istniejących surowców
            TMAT.LP:=_hop;
            TMAT.TKTL_KTM:=exec('FindAndGet','#table',TKTL,TMAT.NRK,,"KTM",null());
            _can_continue:=TMAT.add();
            {? _can_continue>0
            || _args.TMAT_DST:=TMAT.ref();
               _hop+=1;
::             Sprawdam zgosność jednoski miary z nagłówkiem karty i modyfikuję procentową zawartość surowca
               {? _args.XJMP_UPDATE>0
               || exec('xjmp_update_single','tech_mater',TMAT,_args.SUR_UPDATE)
               ?};
::             Przeliczam ilości wg ilości na nagłówku karty
               {? _args.SUR_UPDATE>0
               || exec('sur_update_single','tech_mater',TMAT)
               ?}
            ?};
            TMAT.cntx_pop();

            {? _can_continue>0
            ||
::             1. Kopiuje zamienniki
               _can_continue:=exec('tchmat_copy','tech_arch',_args)
            ?};

            {? _can_continue>0
            ||
::             2. Kopiuje tabelę translacji parametrów
               _can_continue:=exec('tpartra_copy','tech_arch',_args)
            ?};

            {? _can_continue>0
            ||
::             3. Kopiuje dokumentację
               _can_continue:=DocLib.copy('TMAT',_args.TMAT_SRC,'TMAT',_args.TMAT_DST);

               {? _can_continue>0 & _args.DELETE>0
               || DocLib.del('TMAT',_args.TMAT_SRC)
               ?}
            ?};

::          Przepinanie złączeń
            _args_upd.REF_SRC:=_args.TMAT_SRC;
            _args_upd.REF_DST:=_args.TMAT_DST;
            _args_upd.INDEX:='RTMAT';

::       Tutaj są używane następujące indeksy
::          ZLIM.index('RTMAT');
::          TMAT.index('SRC');
::          ZL.index('RTMATSRC')

            {? _can_continue>0 & _args.DELETE>0
            ||
               _args_upd.ACR_TAB:='ZLIM';
               _can_continue:=exec('fields_upd','tech_arch' ,_args_upd)
            ?};
            {? _can_continue>0 & _args.DELETE>0
            ||
               _args_upd.ACR_TAB:='ZL';
               _args_upd.INDEX:='RTMATSRC';
               _args_upd.FLD_REL:='TMAT_SRC';
               _can_continue:=exec('fields_upd','tech_arch' ,_args_upd);
               _args_upd.FLD_REL:=''
            ?};
            {? _can_continue>0 & _args.DELETE>0
            ||
               _args_upd.ACR_TAB:='TMAT';
               _args_upd.INDEX:='SRC';
               _args_upd.REL_UPD:=0;
               _can_continue:=exec('fields_upd','tech_arch' ,_args_upd);
               _args_upd.REL_UPD:=1
            ?};

            {? _can_continue>0
            || {? _args.DELETE>0
               ||
::                Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
                  DocLib.del('TMAT',TMAT.ref());
                  {? TMAT.del(,1)>0
                  || _next:=TMAT.first()
                  || _can_continue:=0;
                     _next:=0
                  ?}
               ||
::                Opcja bez kasowania, ustawiam się na następnym rekordzie
                  _next:=TMAT.next()
               ?}
            ?}
         ||
::          Nieaktywny lub powielony surowiec, przechodzę do następnego
            _next:=TMAT.next()
         ?}
      ||
::       Surowiec nie zawarty w przekazanej tabeli (np. nie był zaznaczony przy przenoszeniu poprzez drag & drop)
         _next:=TMAT.next()
      ?};
      _next>0 & _can_continue>0
   !}
?};
_args.TMAT_DST:=null();
_args.TMAT_SRC:=null();
TMAT.cntx_pop();
M.cntx_pop();
TKTL.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\tchmat_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje wszystkie zamienniki należące do surowca technologicznego (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \tchmat_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mask_src:=form((TCHMAT.name()-3)+_args.MASK_SRC);
_mask_dst:=form((TCHMAT.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| do();
   _tran_started:=1
?};

TCHMAT.cntx_psh();

:: Otwieram maske źródłową
TCHMAT.use(_mask_src);

TCHMAT.index('SL');
TCHMAT.prefix(_args.TMAT_SRC);

{? TCHMAT.first()
|| {!
   |?
      _next:=0;
      _act:=1;
      {? _args.COPY_ACT>0
      ||
::       Sprawdzam status aktywności elementu który chcę skopiować
         {? TCHMAT.ACT='T'
         || _act:=1
         || _act:=0
         ?}
      ?};

      {? _act>0
      ||
         _tchmat:=TCHMAT.ref();
::       Stoję na źródłowym zamienniku, otwieram maskę docelową i zakładam nowy zamiennik
         TCHMAT.cntx_psh();
         TCHMAT.use(_mask_dst);
         TCHMAT.clear();
         TCHMAT.NRK:=_args.TKTL_DST;
         {? _args.TOPER_DST<>null()
         || TCHMAT.NROP:=_args.TOPER_DST
         ?};
         {? _args.TMAT_DST<>null()
         || TCHMAT.SRC:=_args.TMAT_DST
         ?};
         {? _args.STATUS_COPY=0
         || TCHMAT.CRE_TIME:=0;
            TCHMAT.MOD_TIME:=0;
            TCHMAT.USER:=null();
            TCHMAT.CAUSE:=null()
         ?};

         _can_continue:=TCHMAT.add();
         {? _can_continue
         || _dest:=TCHMAT.ref();
::          Sprawdam zgodność jednoski miary z nagłówkiem karty i modyfikuję procentową zawartość zamiennika surowca
            {? _args.XJMP_UPDATE>0
            || exec('xjmp_update_single','tech_mater',TCHMAT,_args.SUR_UPDATE)
            ?};
::          Przeliczam ilości wg ilości na nagłówku karty
            {? _args.SUR_UPDATE>0
            || exec('sur_update_single','tech_mater',TCHMAT)
            ?}
         || _dest:=null()
         ?};
         TCHMAT.cntx_pop();

         {? _can_continue>0
         ||
::          1. Kopiuję tabelę translacji parametrów
            _can_continue:=exec('tpartra_copy','tech_arch',_args,_tchmat,_dest)
         ?};

         {? _can_continue>0
         ||
::          2. Kopiuje dokumentację
            _can_continue:=DocLib.copy('TCHMAT',TCHMAT.ref(),'TCHMAT',_dest)
         ?};

         {? _can_continue>0
         ||
            {? _args.DELETE>0
            ||
               DocLib.del('TCHMAT',TCHMAT.ref());
::             Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
               {? TCHMAT.del(,1)>0
               || _next:=TCHMAT.first()
               || _can_continue:=0;
                  _next:=0
               ?}
            ||
::             Opcja bez kasowania, ustawiam się na następnym rekordzie
               _next:=TCHMAT.next()
            ?}
         ?}
      ||
::       Stoję na nieaktywnym zamienniku, idę na następny
         _next:=TCHMAT.next()
      ?};
      _next>0 & _can_continue>0
   !}
?};
TCHMAT.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\uat_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje atrybuty należące do danego rekordu
::   WE: [_a] - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::       _b - STRING - akronim tabeli
::       _c - TAB.ref() - rekord tabeli źródłowej
::       _d - TAB.ref() - rekord tabeli docelowej
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \uat_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')>100
|| _args:=_a
|| _args:=exec('args_copy','tech_arch')
?};
_tab:=_b+'*';
_ref_src:=_c;
_msk_src:=ref_name(_ref_src);
_ref_dst:=_d;
_msk_dst:=ref_name(_ref_dst);

_result:=0;
_can_continue:=1;

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| do();
   _tran_started:=1
?};

UAT.cntx_psh();
UAT.clear();
UAT.index('TR');
UAT.prefix(_tab,#_ref_src,_msk_src,);
{? UAT.first()
|| {!
   |?
      {? UAT.ACT<>'N' | _args.DIR<>'KARTOTEKA' | _args.DELETE>0
      || _already:=0;

::    Sprawdzam czy w docelowej karcie jest już atrybut o takim numerze
         UAT.cntx_psh();
         UAT.index('TR');
         UAT.prefix(_tab,#_ref_dst,_msk_dst,UAT.LP);
         {? UAT.first()
         || _already:=1;
            KOMM.add('W karcie występuje już atrybut nr %1. Poprzednia wartość zostaje zachowana.'@[$UAT.LP],7,,1)
         ?};
         UAT.cntx_pop();

         {? _already=0
         ||
            UAT.cntx_psh();
            UAT.clear();
            UAT.REF:=#_ref_dst;
            UAT.MSK:=_msk_dst;
            _can_continue:=UAT.add();
            UAT.cntx_pop()
         ?}
      ?};

      _next:=0;
      {? _can_continue>0
      ||
         {? _args.DELETE>0
         ||
::          Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
            {? UAT.del(,1)>0
            || _next:=UAT.first()
            || _can_continue:=0;
               _next:=0
            ?}
         ||
::          Opcja bez kasowania, ustawiam sie na następnym rekordzie
            _next:=UAT.next()
         ?}
      ?};
      _next>0 & _can_continue>0
   !}
?};
UAT.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\tacttls_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje wszystkie NPU należące do danej karty lub operacji
::       (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::       [_b] - tablica z refami rekordów TACTTLS do przekopiowania.
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \tacttls_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_records:={? var_pres('_b')>100 || _b || ~~ ?};

_from_tab:={? var_pres('_records')>100 & _records.size()>0 || 1 || 0 ?};
_result:=0;
_can_continue:=1;

_mask_src:=form((TACTTLS.name()-3)+_args.MASK_SRC);
_mask_dst:=form((TACTTLS.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| do();
   _tran_started:=1
?};

M.cntx_psh();
PFAZ.cntx_psh();
TACTTLS.cntx_psh();
:: Otwieram maske źródłową
TACTTLS.use(_mask_src);

TACTTLS.index('KNROP');
{? _args.NPU_ONLY>0
|| TACTTLS.prefix(_args.TKTL_SRC)
|| TACTTLS.prefix(_args.TKTL_SRC,_args.TOPER_SRC)
?};

{? TACTTLS.first()
|| {!
   |?
      {? _from_tab=0 | (_from_tab>0 & _records.find_tab(,'REF',,'=',#TACTTLS.ref()))
      ||
         _next:=0;
         _act:=1;
         {? _args.COPY_ACT>0
         ||
::          Sprawdzam status aktywności elementu który chcę skopiować
            {? TACTTLS.ACT='T'
            || _act:=1
            || _act:=0
            ?}
         ?};

         {? _act>0 & _args.DIR='KARTOTEKA'
         ||
::          Sprawdzenie, czy NPU nie zostanie powielony w ramach karty/operacji
            _ktm:=TACTTLS.M;
            _pfaz:=TACTTLS.PFAZ;

            _id_tktl:=exec('FindAndGet','#table',TKTL
                                                ,_args.TKTL_DST
                                                ,
                                                ,"NRK+' wer. '+WER"
                                                ,'');
            _id_tope:=exec('FindAndGet','#table',TOPER
                                                ,_args.TOPER_DST
                                                ,
                                                ,"' dla operacji: '+$NROP"
                                                ,'');
            TACTTLS.cntx_psh();

::          Otwieram docelową maskę
            TACTTLS.use(_mask_dst);

            TACTTLS.index('UNIQ');

::          Sprawdzam czy jest już takie NPU w docelowej karcie/operacji
            TACTTLS.prefix(_args.TKTL_DST,_args.TOPER_DST,_ktm,_pfaz);
            {? TACTTLS.first()
            ||
               _faz_txt:='';
               {? TACTTLS.PFAZ<>null()
               || _faz_txt:=' w fazie '+TACTTLS.PFAZ().KOD
               ?};
               KOMM.add('W karcie %1%2 występuje już N-P-U '
                        '%3%4. N-P-U nie zostało zaimportowane.'@[_id_tktl,_id_tope,TACTTLS.M().KTM,_faz_txt],14,,1);
               _act:=0
            ?};
            TACTTLS.cntx_pop()
         ?};

         {? _act>0
         ||
::          Stoję na źródłowym narzędziu, otwieram maskę docelową i zakładam nowe narzędzie
            TACTTLS.cntx_psh();
            TACTTLS.use(_mask_dst);
            TACTTLS.clear();
            TACTTLS.NRK:=_args.TKTL_DST;
            TACTTLS.NROP:=_args.TOPER_DST;
            {? _args.STATUS_COPY=0
            || TACTTLS.CRE_TIME:=0;
               TACTTLS.MOD_TIME:=0;
               TACTTLS.USER:=null();
               TACTTLS.CAUSE:=null()
            ?};
            _can_continue:=TACTTLS.add();
            {? _can_continue || _dest:=TACTTLS.ref() || _dest:=null() ?};
            TACTTLS.cntx_pop();

            {? _can_continue>0
            ||
::             Kopiuje dokumentację
               _can_continue:=DocLib.copy('TACTTLS',TACTTLS.ref(),'TACTTLS',_dest)
            ?};

            {? _can_continue>0
            || {? _args.DELETE>0
               ||
                  DocLib.del('TACTTLS',TACTTLS.ref());
::                Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
                  {? TACTTLS.del(,1)>0
                  || _next:=TACTTLS.first()
                  || _can_continue:=0;
                     _next:=0
                  ?}
               ||
::                Opcja bez kasowania, ustawiam się na następnym rekordzie
                  _next:=TACTTLS.next()
               ?}
            ?}
         ||
::          Stoje na nieaktywnym lub powielonym narzędziu, idę do kolejnego
            _next:=TACTTLS.next()
         ?}
      ||
::       Narzędzie niezawarte w przekazanej tabeli
         _next:=TACTTLS.next()
      ?};
      _next>0 & _can_continue>0
   !}
?};
TACTTLS.cntx_pop();
M.cntx_pop();
PFAZ.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\tktl_arch_act
::----------------------------------------------------------------------------------------------------------------------
:: DOST: MENU KONTEKSTOWE
::  UTW: WH [12.41]
:: OPIS: Akcja przenoszenia karty technologicznej do archiwum/przywracania z archiwum
::   WE: _a - TKTL.ref()
::       _b - STRING - kierunek: 'ARCHIWUM', 'KARTOTEKA'
::       [_c] - INTEGER - czy wyświetlać dialogi
::   WY: null   - porażka
::       TKTL.ref - sukces, przekazuje ref technologii docelowej
:: OLD: \tktl_arch_act/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
_dir:=_b;

_dialog:=1;
{? var_pres('_c')=type_of(0)
|| _dialog:=_c
?};

_result:=null();
_can_continue:=1;

TKTL.cntx_psh(); TKTL.clear();
{? TKTL.seek(_tktl)
||
   _what:=TKTL.NRK+' wersja: '+TKTL.WER;
   {? _dir='ARCHIWUM'
   ||
      {? VAR.GRUPA='N'
      || KOMM.init(250,,'Archiwizacja karty technologicznej: \'%1\''@[_what])
      ?}

::    sprawdzanie powiązania w planie zasobów
::      {? exec('tktl_used','pl_okr3',TKTL.ref())>0
::      || {? VAR.GRUPA='T'
::         || KOMM.add('Technologia '+TKTL.NRK+' / '+TKTL.WER+' jest używana w planie operacyjnym.',2)
::         || FUN.emsg('Technologia jest używana w planie operacyjnym.\nPrzesunięcie do archiwum niemożliwe.')
::         ?};
::         _can_continue:=0
::      ?}
   |? _dir='KARTOTEKA'
   || {? VAR.GRUPA='N'
      || KOMM.init(250,,'Przywracanie z archiwum karty technologicznej: \'%1\''@[_what])
      ?};
::    Pokazuje listę nieaktywnych surowców
      {? exec('surnakt','tech_mater',1,TKTL.ref())>0
      || _can_continue:=1
      ||
::       Jeśli są jakieś nieaktywne indeksy to uniemożliwiamy przywrócenie z archiwum
         _can_continue:=0
      ?}
   ?};

   {? _can_continue>0
   ||
      {? _dialog>0
      || _torw:={? TKTL.TORW='W' || 'wzorzec' || 'kartę' ?};
         {? _dir='ARCHIWUM'
         || _can_continue:=FUN.ask(
               {? TKTL.TORW='W'
               || 'Czy przesunąć wzorzec: \'%1\' do archiwum?'@[_what]
               || 'Czy przesunąć kartę: \'%1\' do archiwum?'@[_what]
               ?}
            )
         |? _dir='KARTOTEKA'
         || _can_continue:=FUN.ask(
               {? TKTL.TORW='W'
               || 'Czy przywrócić wzorzec: \'%1\' z archiwum?'@[_what]
               || 'Czy przywrócić kartę: \'%1\' z archiwum?'@[_what]
               ?}
            )
         ?}
      ?};

      {? _can_continue>0 & _dir='ARCHIWUM'
      ||
::       Sprawdzam czy moge przesuwać do archiwum (czy są powiązania z innymi kartami)
         {? exec('whohasme','tech_mater',3)
         || _can_continue:=0
         ?}
      ?};

      {? _can_continue>0
      ||
         _args:=exec('args_copy','tech_arch');
         _args.TKTL_SRC:=TKTL.ref();
         _args.DELETE:=1;
         _args.TRANS:=1;
         _args.DIR:=_dir;
         _args.COPY_ZATW:=1;
         _args.COPY_KALK:=1;
         _args.COPY_ACT:=0;
         _args.DST_T_OD:=TKTL.TERM_OD;
         _args.DST_T_DO:=TKTL.TERM_DO;

         {? _dir='ARCHIWUM'
         || _args.MASK_SRC:=ref_name(TKTL.ref())+3;

::          Maska docelowa archiwum jest maską typu _14 gdzie 14 to rok przesunięcia
            _args.MASK_DST:='_'+(($(date()~1))+2)
         |? _dir='KARTOTEKA'
         || _args.MASK_SRC:=ref_name(TKTL.ref())+3;
            _args.MASK_DST:='___'
         ?};
         _can_continue:=exec('tktl_copy','tech_arch',_args);

         {? _can_continue>0
         ||
::          Odświeżam filtr
            {? VAR.GRUPA='N' & TKTL.f_active()>0
            || TKTL.f_del()
            ?}
         ?}
      ?}
   ?};
   {? VAR.GRUPA='N'
   || KOMM.select()
   ?}
|| _can_continue:=0
?};
TKTL.cntx_pop();

{? _can_continue>0
|| VAR.A_KTL:=null();
   VAR.A_KKTL:=null();
   _result:=_args.TKTL_DST
?};
_result


\kktl_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje wszystkie kalkulacje karty technologicznej dotyczące produktu
::       (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::       [_b] - TKTLW.ref() - ref wyrobu źródłowego
::       [_c] - TKTLW.ref() - ref wyrobu docelowego
::   WY: 0 - porażka
::       1 - sukces
:: OLD: \kktl_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_lw_src:={? var_pres('_b')=type_of(null()) || _b || null() ?};
_lw_dst:={? var_pres('_c')=type_of(null()) || _c || null() ?};

_result:=0;
_can_continue:=1;

_mask_src:=form((KKTL.name()-3)+_args.MASK_SRC);
_mask_dst:=form((KKTL.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| _tran_started:=do()
?};

KKTL.cntx_psh();
:: Otwieram maskę źródłową
KKTL.use(_mask_src);

KKTL.index('KWN');
KKTL.prefix(_args.TKTL_SRC,_lw_src);
{? KKTL.first()
||
   _args_upd:=exec('fields_upd_a','tech_arch');
   _args_upd.DIR:=_args.DIR;

   {!
   |?
::    Stoję na źródłowej kalkulacji, otwieram maskę docelową i zakładam nową kalkulację
      _args.KKTL_SRC:=KKTL.ref();
      KKTL.cntx_psh();
      KKTL.use(_mask_dst);
      KKTL.clear();
      KKTL.NRK:=_args.TKTL_DST;
      KKTL.TKTLW:=_lw_dst;
      _can_continue:=KKTL.add();
      {? _can_continue>0
      || _args.KKTL_DST:=KKTL.ref()
      ?};

      KKTL.cntx_pop();

      {? _can_continue>0
      ||
::       Kopiujemy ceny surowców
         _can_continue:=exec('kalmat_copy','tech_arch',_args)
      ?};

      {? _can_continue>0
      ||
::       Kopiujemy stawki operacji
         _can_continue:=exec('kaltto_copy','tech_arch',_args)
      ?};

      {? _can_continue>0
      ||
::       Kopiujemy koszty godzin
         _can_continue:=exec('kalwrk_copy','tech_arch',_args)
      ?};

      {? _can_continue>0
      ||
::       Kopiujemy stawki usług
         _can_continue:=exec('kaltou_copy','tech_arch',_args)
      ?};

      {? _can_continue>0
      ||
::       Kopiujemy ceny NPU
         _can_continue:=exec('kaltls_copy','tech_arch',_args)
      ?};

      {? _can_continue>0
      ||
::       Kopiujemy wartości parametrów
         _can_continue:=exec('kpar_copy','tech_arch',_args)
      ?};

      {? _can_continue>0
      ||
::       Kopiujemy wartości wprowadzone ręcznie
         _can_continue:=exec('kkalkh_copy','tech_arch',_args)
      ?};

      {? _can_continue>0
      ||
::       Kopiujemy pozycje kalkulacji
         _can_continue:=exec('kpozk_copy','tech_arch',_args)
      ?};

::    Przepinanie złączeń
      _args_upd.REF_SRC:=_args.KKTL_SRC;
      _args_upd.REF_DST:=_args.KKTL_DST;
      _args_upd.INDEX:='RKKTL';

::    Tutaj są używane następujące indeksy
::    MPTZ.index('RKKTL');
      {? _can_continue>0 & _args.DELETE>0
      ||
         _args_upd.ACR_TAB:='MPTZ';
         _can_continue:=exec('fields_upd','tech_arch',_args_upd)
      ?};

      _next:=0;
      {? _can_continue>0
      ||
         {? _args.DELETE>0
         ||
::          Jeśli opcja z kasowaniem, to kasuję i ustawiam sie na pierwszym rekordzie
            {? KKTL.del(,1)>0
            || _next:=KKTL.first()
            || _can_continue:=0;
               _next:=0
            ?}
         ||
::          Opcja bez kasowania, ustawiam się na następnym rekordzie
            _next:=KKTL.next()
         ?}
      ?};
      _next>0 & _can_continue>0
   !}
?};

KKTL.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\kalmat_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje wszystkie ceny surowców do kalkulacji (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
:: OLD: \kalmat_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mask_src:=form((KALMAT.name()-3)+_args.MASK_SRC);
_mask_dst:=form((KALMAT.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| _tran_started:=do()
?};

KALMAT.cntx_psh();
:: Otwieram maskę źródłową
KALMAT.use(_mask_src);

KALMAT.index('KS');
KALMAT.prefix(_args.KKTL_SRC);
{? KALMAT.first()
|| {!
   |?
::    Stoję na źródłowej cenie, otwieram maskę docelową i zakładam nową cenę
      _src:=KALMAT.ref();
      _dst:=null();
      KALMAT.cntx_psh();
      KALMAT.use(_mask_dst);
      KALMAT.clear();
      KALMAT.KKTL:=_args.KKTL_DST;
      _can_continue:=KALMAT.add();

      KALMAT.cntx_pop();

      _next:=0;
      {? _can_continue>0
      ||
         {? _args.DELETE>0
         ||
::          Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
            {? KALMAT.del(,1)>0
            || _next:=KALMAT.first()
            || _can_continue:=0;
               _next:=0
            ?}
         ||
::          Opcja bez kasowania, ustawiam się na następnym rekordzie
            _next:=KALMAT.next()
         ?}
      ?};
      _next>0 & _can_continue>0
   !}
?};

KALMAT.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\kaltto_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuję wszystkie stawki operacji wykorzystane w kalkulacji (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
:: OLD: \kaltto_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mask_src:=form((KALTTO.name()-3)+_args.MASK_SRC);
_mask_dst:=form((KALTTO.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| _tran_started:=do()
?};

KALTTO.cntx_psh();
:: Otwieram maske źrodlowa
KALTTO.use(_mask_src);

KALTTO.index('KO');
KALTTO.prefix(_args.KKTL_SRC);
{? KALTTO.first()
|| {!
   |?
::    Stoję na źródłowej stawce, otwieram maskę docelową i zakładam nową stawkę
      KALTTO.cntx_psh();
      KALTTO.use(_mask_dst);
      KALTTO.clear();
      KALTTO.KKTL:=_args.KKTL_DST;
      _can_continue:=KALTTO.add();

      KALTTO.cntx_pop();

      _next:=0;
      {? _can_continue>0
      ||
         {? _args.DELETE>0
         ||
::          Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
            {? KALTTO.del(,1)>0
            || _next:=KALTTO.first()
            || _can_continue:=0;
               _next:=0
            ?}
         ||
::          Opcja bez kasowania, ustawiam się na następnym rekordzie
            _next:=KALTTO.next()
         ?}
      ?};
      _next>0 & _can_continue>0
   !}
?};

KALTTO.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\kalwrk_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuję wszystkie koszty godziny pracy wykorzystane w kalkulacji (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
:: OLD: \kalwrk_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mask_src:=form((KALWRK.name()-3)+_args.MASK_SRC);
_mask_dst:=form((KALWRK.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| _tran_started:=do()
?};

KALWRK.cntx_psh();
:: Otwieram maske źródłową
KALWRK.use(_mask_src);

KALWRK.index('KP');
KALWRK.prefix(_args.KKTL_SRC);
{? KALWRK.first()
|| {!
   |?
::    Stoje na źródłowym koszcie, otwieram maskę docelową i zakładam nowy koszt
      KALWRK.cntx_psh();
      KALWRK.use(_mask_dst);
      KALWRK.clear();
      KALWRK.KKTL:=_args.KKTL_DST;
      _can_continue:=KALWRK.add();

      KALWRK.cntx_pop();

      _next:=0;
      {? _can_continue>0
      ||
         {? _args.DELETE>0
         ||
::          Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
            {? KALWRK.del(,1)>0
            || _next:=KALWRK.first()
            || _can_continue:=0;
               _next:=0
            ?}
         ||
::          Opcja bez kasowania, ustawiam się na następnym rekordzie
            _next:=KALWRK.next()
         ?}
      ?};
      _next>0 & _can_continue>0
   !}
?};

KALWRK.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\kaltou_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje wszystkie stawki usług wykorzystane w kalkulacji (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
:: OLD: \kaltou_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mask_src:=form((KALTOU.name()-3)+_args.MASK_SRC);
_mask_dst:=form((KALTOU.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| _tran_started:=do()
?};

KALTOU.cntx_psh();
:: Otwieram maskę źródłową
KALTOU.use(_mask_src);

KALTOU.index('KT');
KALTOU.prefix(_args.KKTL_SRC);
{? KALTOU.first()
|| {!
   |?
::    Stoję na źródłowej stawce, otwieram maskę docelową i zakładam nową stawkę
      KALTOU.cntx_psh();
      KALTOU.use(_mask_dst);
      KALTOU.clear();
      KALTOU.KKTL:=_args.KKTL_DST;
      _can_continue:=KALTOU.add();

      KALTOU.cntx_pop();

      _next:=0;
      {? _can_continue>0
      ||
         {? _args.DELETE>0
         ||
::          Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
            {? KALTOU.del(,1)>0
            || _next:=KALTOU.first()
            || _can_continue:=0;
               _next:=0
            ?}
         ||
::          Opcja bez kasowania, ustawiam się na następnym rekordzie
            _next:=KALTOU.next()
         ?}
      ?};
      _next>0 & _can_continue>0
   !}
?};
KALTOU.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\kaltls_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje wszystkie ceny NPU wykorzystane w kalkulacji (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
:: OLD: \kaltls_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mask_src:=form((KALTLS.name()-3)+_args.MASK_SRC);
_mask_dst:=form((KALTLS.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| _tran_started:=do()
?};

KALTLS.cntx_psh();
:: Otwieram maske źródłową
KALTLS.use(_mask_src);

KALTLS.index('KT');
KALTLS.prefix(_args.KKTL_SRC);
{? KALTLS.first()
|| {!
   |?
::    Stoje na źródłowej cenie, otwieram maskę docelową i zakładam nową cenę
      KALTLS.cntx_psh();
      KALTLS.use(_mask_dst);
      KALTLS.clear();
      KALTLS.KKTL:=_args.KKTL_DST;
      _can_continue:=KALTLS.add();

      KALTLS.cntx_pop();

      _next:=0;
      {? _can_continue>0
      ||
         {? _args.DELETE>0
         ||
::          Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
            {? KALTLS.del(,1)>0
            || _next:=KALTLS.first()
            || _can_continue:=0;
               _next:=0
            ?}
         ||
::          Opcja bez kasowania, ustawiam się na następnym rekordzie
            _next:=KALTLS.next()
         ?}
      ?};
      _next>0 & _can_continue>0
   !}
?};
KALTLS.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\kpar_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje wartości parametrów wykorzystane w kalkulacji (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
:: OLD: \kpar_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mask_src:=form((KPAR.name()-3)+_args.MASK_SRC);
_mask_dst:=form((KPAR.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| _tran_started:=do()
?};

KPAR.cntx_psh();
:: Otwieram maske źródłową
KPAR.use(_mask_src);

KPAR.index('KN');
KPAR.prefix(_args.KKTL_SRC);
{? KPAR.first()
|| {!
   |?
::    Stoję na źródłowej wartości, otwieram maskę docelową i zakładam nową wartość
      KPAR.cntx_psh();
      KPAR.use(_mask_dst);
      KPAR.clear();
      KPAR.KKTL:=_args.KKTL_DST;
      _can_continue:=KPAR.add();

      KPAR.cntx_pop();

      _next:=0;
      {? _can_continue>0
      ||
         {? _args.DELETE>0
         ||
::          Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
            {? KPAR.del(,1)>0
            || _next:=KPAR.first()
            || _can_continue:=0;
               _next:=0
            ?}
         ||
::          Opcja bez kasowania, ustawiam się na następnym rekordzie
            _next:=KPAR.next()
         ?}
      ?};
      _next>0 & _can_continue>0
   !}
?};
KPAR.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\kkalkh_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuję wartości wprowadzone ręcznie w kalkulacji (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
:: OLD: \kkalkh_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mask_src:=form((KKALKH.name()-3)+_args.MASK_SRC);
_mask_dst:=form((KKALKH.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| _tran_started:=do()
?};

KKALKH.cntx_psh();
:: Otwieram maskę źródłową
KKALKH.use(_mask_src);

KKALKH.index('KR');
KKALKH.prefix(_args.KKTL_SRC);
{? KKALKH.first()
|| {!
   |?
::    Stoję na źródłowej wartości, otwieram maskę docelową i zakładam nowa wartość
      KKALKH.cntx_psh();
      KKALKH.use(_mask_dst);
      KKALKH.clear();
      KKALKH.KALK:=_args.KKTL_DST;
      _can_continue:=KKALKH.add();

      KKALKH.cntx_pop();

      _next:=0;
      {? _can_continue>0
      ||
         {? _args.DELETE>0
         ||
::          Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
            {? KKALKH.del(,1)>0
            || _next:=KKALKH.first()
            || _can_continue:=0;
               _next:=0
            ?}
         ||
::          Opcja bez kasowania, ustawiam się na następnym rekordzie
            _next:=KKALKH.next()
         ?}
      ?};
      _next>0 & _can_continue>0
   !}
?};
KKALKH.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\kpozk_copy
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Kopiuje pozycje kalkulacji (być może do innej maski)
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
:: OLD: \kpozk_copy/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_mask_src:=form((KPOZK.name()-3)+_args.MASK_SRC);
_mask_dst:=form((KPOZK.name()-3)+_args.MASK_DST);

:: Rozpoczynam transakcję jeśli jeszcze nie rozpoczęta
_tran_started:=0;
{? do_state()=0 & _args.TRANS>0
|| _tran_started:=do()
?};

KPOZK.cntx_psh();
:: Otwieram maske źródłową
KPOZK.use(_mask_src);

KPOZK.index('KR');
KPOZK.prefix(_args.KKTL_SRC);
{? KPOZK.first()
|| {!
   |?
::    Stoje na źródłowej pozycji, otwieram maskę docelową i zakładam nową pozycję
      KPOZK.cntx_psh();
      KPOZK.use(_mask_dst);
      KPOZK.clear();
      KPOZK.KALK:=_args.KKTL_DST;
      _can_continue:=KPOZK.add();

      KPOZK.cntx_pop();

      _next:=0;
      {? _can_continue>0
      ||
         {? _args.DELETE>0
         ||
::          Jeśli opcja z kasowaniem, to kasuję i ustawiam się na pierwszym rekordzie
            {? KPOZK.del(,1)>0
            || _next:=KPOZK.first()
            || _can_continue:=0;
               _next:=0
            ?}
         ||
::          Opcja bez kasowania, ustawiam się na następnym rekordzie
            _next:=KPOZK.next()
         ?}
      ?};
      _next>0 & _can_continue>0
   !}
?};
KPOZK.cntx_pop();

{? _can_continue>0
|| _result:=1
||
:: Wycofuję transakcję
   undo()
?};

:: Kończę transakcję
{? _tran_started>0
|| end()
?};
_result


\tpar_val_ask
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Pyta o nowe wartości dla parametrów karty technologicznej
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \tpar_val_ask/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;

_result:=0;
_can_continue:=1;

_tab:=_args.TPAR_VAL;

TPKTL.cntx_psh();
TKTL.cntx_psh();
TKTLW.cntx_psh();
TPAR.cntx_psh();
TWPAR.cntx_psh();

_mask_src:=form((TKTLW.name()-3)+_args.MASK_SRC);
_mask_dst:=form((TKTLW.name()-3)+_args.MASK_DST);

:: Otwieram maskę źródłową TKTLW
TKTLW.use(_mask_src);

:: Otwieram maskę źródłową TKTL
_msk_tktl:=form((TKTL.name()-3)+_args.MASK_SRC);
TKTL.use(_msk_tktl);

TKTLW.index('REF');
{? _args.M_ONLY<>null()
|| TKTLW.prefix(_args.TKTL_SRC,_args.M_ONLY)
|| TKTLW.prefix(_args.TKTL_SRC)
?};
{? TKTLW.first()
||
   _tpar:=obj_new(@.CLASS.TPAr);

   _tpar.TABLE:=TPAR;
   _tpar.INDEX:='NN';
   _tpar.PREFIX:=TKTLW.TKTL;

   {!
   |? {? TKTLW.TKTL().TYP().PAR='T'
      ||
         _tpar.KTM:=TKTLW.KTM;

         _tpar.reloadp();

         _label1:='Karta'; _value1:=TKTLW.TKTL().NRK;
         _label2:='Produkt'; _value2:=TKTLW.KTM().KTM;
         _label3:=''; _value3:='';

         {? _args.DST_ZLNAD<>null() & _args.DST_ZL<>null()
         || _tpartra:=exec('podzlec_tpartra','tech_arch',_args,_tpar,_args.DST_ZL);
            {? _tpartra>0
            || _value3:='wartości wynikają z tabeli translacji parametrów'@
            ?}
         || _tpartra:=0
         ?};

::       Wyświetlam okno modyfikacji parametrów, jak brak to oświadczam, że "były zredagowane"
         {? _tpar.N>0 & _tpartra=0
         || _args.TPAR_EDITED:=_tpar.change('Karta technologiczna',_label1,_value1,_label2,_value2,_label3,_value3)
         || _args.TPAR_EDITED:=1
         ?};

::       Nawet jeśli użytkownik wyszedł z okna za pomocą 'ANULUJ', to i tak zapisuję w tabeli wartości
::       ponieważ w nowej technologii powinny zostać ustawione wartości z karty źródłowej
         {! _it:=1.._tpar.N
         |? _can_continue>0
         |!
::          Iteruję po parametrach i dodaję je do tabeli tymczasowej
            _tab.cntx_psh();
            _tpar_ref:=_tpar.P.TPAR[_it];
            _tab.prefix(_tpar_ref,$TKTLW.ref());
            {? _tab.size()=0
            || _tab.blank();
               _tab.TPAR:=_tpar_ref;
               _tab.TKTLW:=$TKTLW.ref();
               _tab.VALUE:=_tpar.P.VAL[_it];

               {? _args.M_VALS<>null() & _args.M_VALS=TKTLW.KTM
               || _tab.DEFAULT:='T'
               || _tab.DEFAULT:='N'
               ?};
               _can_continue:=_tab.add()
            ?};
            _tab.cntx_pop();
            ~~
         !}
      ?};
      TKTLW.next() & _can_continue>0
   !};
   obj_del(_tpar)
?};

{? _can_continue=0
|| FUN.emsg('Kopiowanie parametrów zostało przerwane.'@)
?};

TWPAR.cntx_pop();
TPAR.cntx_pop();
TKTLW.cntx_pop();
TKTL.cntx_pop();
TPKTL.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\toper2wzor
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Na podstawie bieżącego TOPERa tworzy nowy wzorzec technologii
::   WE: _a - TOPER.ref()
::       [_b] - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \toper2wzor/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_toper:=_a;

{? var_pres('_b')>100
|| _args:=_b
|| _args:=exec('args_copy','tech_arch')
?};

_can_continue:=1;
_result:=0;

TKTL.cntx_psh(); TKTL.clear();
TOPER.cntx_psh(); TOPER.clear();
{? TOPER.seek(_toper)
||
   _msg:={? TOPER.NRNOP=0 || 'Zakres elementów tworzonego wzorca'@ || 'Zakres elementów tworzonego wzorca (operacje na tym poziomie):'@ ?};

   _choice:=FUN.choice(_msg,,'Bieżąca operacja'@,'Wszystkie operacje'@);

   {? _choice=1 & TOPER.ACT='T' | _choice=2
   ||
      _arch:=TOPER.NRK().ARCH;

      {? _arch='T'
      || FUN.info('Nowy wzorzec zostanie umieszczony w zbiorze wzorców niearchiwalnych.'@)
      ?};

      _tmp_sym:=exec('tmp_sym','tech_head');
      undefine();
      define('H1',~~);
      define('TMP',_tmp:=$TKTL.tm_stamp(),'Podaj symbol nowego wzorca: %1'@[_tmp_sym],,50-(+_tmp_sym),50-(+_tmp_sym));
      define('H2',~~);
      def_btn('text=%1'['Zapisz'@],'key:F2');
      def_btn('text=%1'['Anuluj'@],'key:Esc');
      {? def_edit("{? DEFINE.TMP='' || FUN.info('Proszę wypełnić pole.'@); 0 || 1 ?}",FUN.TYT)
      || _args.DST_SYM:=exec('tmp_sym','tech_head')+DEFINE.TMP;
         _args.DST_WER:=exec('tktl_wer_bl','tech_head');
         _can_continue:=1
      || _can_continue:=0
      ?};

      {? _can_continue>0
      ||
         _args.STATUS_COPY:=0;
         _args.TKTL_SRC:=TOPER.NRK;
         _args.MASK_SRC:=ref_name(TOPER.NRK)+3;
         _args.MASK_DST:='___';
         {? _choice=1
         || _args.TOPER_SRC:={? TOPER.NRNOP<>0 || exec('FindInSet','#table','TOPER','UNROP',TOPER.NRNOP) || null() ?};
            _args.TOPER_NR:=TOPER.NROP
         ?};

         _args.DELETE:=0;
         _args.TRANS:=1;
         _args.DIR:='KARTOTEKA';
         _args.DST_TORW:='W';
         _args.DST_TMASK:=exec('samejedynki','#blank',23);
         _args.DST_STAN:='N';

         _args.COPY_OPER:=1;
         _args.COPY_UAT:=1;

         _args.COPY_NAST:={? _choice=1 || 0 || 1 ?};
         _args.COPY_SUR:=0;
         _args.COPY_NPU:=0;
         _args.COPY_PROD:=0;
         _args.COPY_KTM:=0;
         _args.COPY_DOK:=0;

         {? _can_continue>0
         ||
::          Sprawdzam czy symbol jest unikalny w ramach wszystkich masek
            {? exec('chk_symbol','tech_head','W',_args.DST_SYM,_args.DST_WER)=0
            || _can_continue:=0;
               FUN.emsg('Wprowadzony symbol musi być unikalny w ramach całej kartoteki (również w ramach archiwum).'@)
            ?};
            {? _can_continue>0
            ||
::             Jądro kopiujące
               _can_continue:=exec('tktl_copy','tech_arch',_args);

               {? _can_continue>0
               ||
::                Komunikaty po kopiowaniu
                  TKTL.use(ref_name(_args.TKTL_DST));
                  TKTL.clear();
                  {? TKTL.seek(_args.TKTL_DST)
                  || _what:=TKTL.NRK+' wersja '+TKTL.WER;
                     FUN.info('Kopiowanie zakończone, utworzono wzorzec: \'%1\'.'@[_what])
                  || FUN.emsg('Kopiowanie zakończone niepowodzeniem.'@)
                  ?}
               || FUN.emsg('Kopiowanie zakończone niepowodzeniem.'@)
               ?}
            ?}
         ?}
      ?}
   |? _choice=1
   || FUN.emsg('Wzorzec można utworzyć tylko z aktywnej operacji.'@)
   ?}
?};

TKTL.cntx_pop(); TOPER.cntx_pop();

{? _can_continue>0
|| _result:=1
?};
_result


\tktl2wzor
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Na podstawie bieżącej technologii tworzy nowy wzorzec technologii
::   WE: _a - TKTL.ref()
::       [_b] - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::   WY: 0 - porażka
::       1 - sukces
::  OLD: \tktl2wzor/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;

{? var_pres('_b')>100
|| _args:=_b
|| _args:=exec('args_copy','tech_arch')
?};

_result:=0;

TKTL.cntx_psh(); TKTL.clear();
{? TKTL.seek(_tktl)
||
   {? TKTL.TYP=exec('ref_k_res','tech_head')
   ||
      FUN.info('Nie można utworzyć wzorca z karty kompletacyjnej.'@)
   ||
      _args.STATUS_COPY:=0;

      _sur:=(TKTL.TYP().SUR='K');
      _util:=(TPKTL.UTIL='K');
      _oper:=(TPKTL.OPER='T');
::    Na ten moment wszystkie karty obsługiwane jak OO - tworzony wzorzec na całość
      {? 1
::         _oper & ~_sur & ~_util
      || _choice:=~FUN.ask('Czy utworzyć wzorzec na podstawie bieżącej karty?'@)
      || _choice:='choice(\'Zakres elementów tworzonego wzorca:\',FUN.TYT,\'ASK\',,,,
                      \'Całość\','+
                      {? _oper & (_sur|_util) || '\'Operacje\',' || '' ?}+
                      {? _sur || '\'Surowce\',' || '' ?}+
                      {? _util || '\'N-P-U\',' || '' ?}+
                      '\'Anuluj\')';
         _choice:=($_choice)()
      ?};

::    Całość
      {? _choice=0
      ||
         _args.COPY_PROD:=0;
         _args.COPY_KTM:=0;
         _result:=exec('tktl_copy_act','tech_arch',TKTL.ref(),_args,'Wzorzec')

::    Operacje
      |? _choice={? _sur|_util || 1 || 99 ?}
      ||
         _args.COPY_OPER:=1;
         _args.COPY_UAT:=0;

         _args.COPY_NAST:=1;
         _args.COPY_SUR:=0;
         _args.COPY_NPU:=0;
         _args.COPY_PROD:=0;
         _args.COPY_KTM:=0;
         _args.COPY_DOK:=0;

         _result:=exec('tktl_copy_act','tech_arch',TKTL.ref(),_args,'Wzorzec')

::    Materiały
      |? _choice={? _oper & _sur || 2 |? _sur || 1 || 99 ?}
      ||
         _args.COPY_OPER:=0;
         _args.COPY_UAT:=0;

         _args.COPY_NAST:=0;
         _args.COPY_SUR:=1;
         _args.COPY_NPU:=0;
         _args.COPY_PROD:=0;
         _args.COPY_KTM:=0;
         _args.COPY_DOK:=0;

         _result:=exec('tktl_copy_act','tech_arch',TKTL.ref(),_args,'Wzorzec')

::    NPU
      |? _choice={? _oper & _sur & _util || 3 |? _sur & _util | _oper & _util || 2 |? _util || 1 || 99 ?}
      ||
         _args.COPY_OPER:=0;
         _args.COPY_UAT:=0;

         _args.COPY_NAST:=0;
         _args.COPY_SUR:=0;
         _args.COPY_NPU:=1;
         _args.COPY_PROD:=0;
         _args.COPY_KTM:=0;
         _args.COPY_DOK:=0;

         _result:=exec('tktl_copy_act','tech_arch',TKTL.ref(),_args,'Wzorzec')

      ?}
   ?}
?};

TKTL.cntx_pop();

_result


\insert_tbx
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Wstawia dane ze wzorca/innej technologii - domyślnie własne wzorce tymczasowe
::   WE: [_a] - TOPER.NRNOP (0, jeżeli korzeń (domyślne))
::       [_b] - Tryb wstawiania do operacji (1), czy do karty (domyślnie 0)
::       [_c] - TKTL.ref() - wzorzec/technologia, z którego wstawiać dane. Jak nie podany to wyświetlane okno seleckji
::       [_d] - argumenty kopiowania, wynik formuły exec('args_copy','tech_arch')
::       [_e] - tabela z listą elementów do skopiowania
::   WY: 0 / 1
::  OLD: \insert_tbx/tex_wzor.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _unrop:=_a || _unrop:=0 ?};
{? var_pres('_b')=type_of(0) || _oper:=_b || _oper:=0 ?};
{? var_pres('_c')=type_of(null()) || _tbox:=_c || _tbox:=null() ?};
{? var_pres('_d')>100 || _args:=_d || _args:=exec('args_copy','tech_arch') ?};
{? var_pres('_e')>100 || _records:=_e || _records:=~~ ?};

_czy_wzor:={? _tbox<>null() || exec('FindAndGet','#table',TKTL,_tbox,,"TKTL.TORW='W'",1) || 1 ?};

{? _czy_wzor>0
|| KOMM.init(250,,'Wstawianie wzorca'@,'');
   _txt_imp:='Import wzorca został przerwany. Wszystkie zmiany zostały wycofane.'@
|| KOMM.init(250,,'Kopiowanie z technologii'@,'');
   _txt_imp:='Kopiowanie z technologii zostało przerwane. Wszystkie zmiany zostały wycofane.'@
?};
KOMM.sect_beg(_txt_imp);

TOPER.cntx_psh();

VAR_DEL.delete('__PRZEJ');
__PRZEJ:=tab_tmp(1,'TOPER','INTEGER','ref.toper',
                   'OPER','INTEGER','ref.zoper');

_tktl:=TKTL.ref();
_jm:=TKTL.JM().KOD;
_xjm:=TKTL.XJM;
_arch:=TKTL.ARCH;
::_t_util:=TKTL.TYP().UTIL;
::_t_sur:=TPKTL.SUR;
_t_par:=TPKTL.PAR;
_t_oper:=TPKTL.OPER;

_stat_o:=TKTL.STAT_O;
_stat_s:=TKTL.STAT_S;
_stat_p:=TKTL.STAT_P;

{? VAR.A_TORW='Z'
|| _role_o:=_role_s:=_role_p:=exec('chk_role','#b__box',OPERATOR.USER,'TTE_PZL_DTEC')
|| _role_o:=exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRTO');
   _role_s:=exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRTS');
   _role_p:=exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRDP')
?};

VAR_DEL.delete('B_FILTER','B_VAR');
B_FILTER:=obj_new(@.CLASS.BUFFER,'FILTER');
B_VAR:=obj_new(@.CLASS.BUFFER,'VAR');

_filter:=VAR.FILTER;
VAR.FILTER:='N';
_torw:=VAR.A_TORW;
_tmp:=exec('tmp_sym','tech_head');
FILTER.blank();
VAR.TOW_USL:='T';
VAR.ACTION:='1';
VAR.A_TORW:='W';
VAR.ARCH:='N';
VAR.GRUPA:='N';
TKTL.cntx_psh();
TKTL.f_clear(1);
exec('set_filter','tech_head');
:TKTL.index('NRK');
:TKTL.prefix('W');
TKTL.win_sel('SLO_');
TKTL.win_patt('WZOR_');
{? _tbox=null()
|| _ok:=TKTL.select();
   _tbox:=TKTL.ref()
|| _ok:=TKTL.seek(_tbox,ref_name(_tbox),1);
   {? ~_ok
   || FUN.emsg('Nie odnaleziono przekazanego wzorca technologii.'@)
   ?}
?};
_sur_update:=0;
_xjmp_update:=TKTL.JM().KOD<>_jm;
_is_tmat:=exec('is_tmat','tech_head',_tbox);

:: Sprawdzana ilość produktu na jaką zaprojektowany jest wzorzec i docelowa karta
{? _ok & _args.COPY_SUR>0
|| {? TKTL.XJM<>_xjm
   || _txt:={? _czy_wzor>0
            || 'Ilość produktu, na który projektowana jest karta (%1) jest inna niż we wstawianym wzorcu (%2).'@
               [$_xjm,$TKTL.XJM]+'\n'
            || 'Ilość produktu, na który projektowana jest karta (%1) jest inna niż wskazanej technologii (%2).'@
               [$_xjm,$TKTL.XJM]+'\n'
            ?}+
            'Czy wstawić surowce i przeliczyć ilości surowców według zdefiniowanego składu procentowego?\n'
            '(pominięcie przeliczenia spowoduje wyznaczanie nowych procentowych zawartości '
            'surowców oraz zamienników technologii)\n'@;
       {? TKTL.JM().KOD<>_jm & _is_tmat>0
       || _txt+='\nUWAGA!\n'@+
                {? _czy_wzor>0
                || 'Jednostka miary projektowanej karty jest inna niż we wstawianym wzorcu. '@
                || 'Jednostka miary projektowanej karty jest inna niż we wskazanej technologii. '@
                ?}+
                'Zawartość procentowa kopiowanych surowców zostanie przeliczona względem jednostki '
                'miary projektowanej technologii.'@
       ?};
      _ok:=FUN.choice(_txt,,'Wstaw i przelicz'@,'Wstaw i nie przeliczaj'@);
      {? _ok=1
      || _sur_update:=1
      |? _ok=2
      || _xjmp_update:=1
      ?}
   |? TKTL.JM().KOD<>_jm & _is_tmat>0
   || _txt:={? _czy_wzor>0
            || 'Jednostka miary projektowanej karty jest inna niż we wstawianym wzorcu. '@
            || 'Jednostka miary projektowanej karty jest inna niż we wskazanej technologii. '@
            ?}+
            'Zawartość procentowa kopiowanych surowców zostanie przeliczona względem jednostki '
            'miary projektowanej technologii.\n'
            'Czy mimo to kontynuować?'@;
      _ok:=FUN.ask(_txt)
   ?}
?};

:: Sprawdzana możliwość zablokowania karty w każdym zakresie
{? _ok
|| {? ~(exec('tktl_lock','tech_common',#_tktl,'N',1) &
        exec('tktl_lock','tech_common',#_tktl,'O',1) &
        exec('tktl_lock','tech_common',#_tktl,'S',1) &
        exec('tktl_lock','tech_common',#_tktl,'P',1))
   || _ok:=0;
      FUN.emsg('Karta jest redagowana. Wstawienie wzorca nie jest możliwe.'@)
   ?}
?};

{? _ok
|| TKTL.TYP();

   _is_toper:=exec('is_toper','tech_head',_tbox);
   _is_ttls:=exec('is_ttls','tech_head',_tbox);
   _is_param:=exec('is_param','tech_head',_tbox);
   _is_atr:=exec('is_atr','tech_head',_tbox);
   _is_doc:=exec('is_doc','tech_head',_tbox);

   _ok1:=1;
::   Na ten moment typ przypisania N-P-U nie ma znaczenia, można przypisywać dowolnie
::   {? _is_ttls>0
::   ||
::    Jeżeli wzorzec ma jakieś narzędzia to karta do której go wkładam
::    musi być w typie przypisania narzędzi zgodna ze wzorcem
::      _ok1:=(_t_util=TPKTL.UTIL)
::   ?};

   _ok2:=1;
::   Na ten moment typ przypisania surowca nie ma znaczenia, można przypisywać dowolnie
::   {? _is_tmat>0
::   ||
::    Jeżeli wzorzec ma jakieś opearcje to karta do której go wkładam
::    musi być w typie przypisania surowców zgodna ze wzorcem
::      _ok2:=(_t_sur=TPKTL.SUR)
::   ?};

:: Wymagana zgodność parametryzacji, albo kopiowanie wzorca nieparametryzowanego na kartę parametryzowaną
   _ok3:=(_t_par=TPKTL.PAR | (_t_par='T' & TPKTL.PAR='N'));

   _ok4:=1;
   {? _is_toper>0 & _t_oper='N'
   ||
::    Nie mogę wsadzić wzorca który ma operacje do karty której typ nie przewiduje istnienia operacji
      _ok4:=0
   ?};

   _ok5:=_args.COPY_OPER=0 | (~(_stat_o='T' & _is_toper));
   _ok6:=_args.COPY_SUR=0 | (~(_stat_s='T' & _is_tmat));
   _ok7:=_args.COPY_NPU=0 | (~(_stat_p='T' & _is_ttls));
   _ok8:=~(_stat_p='T' & _is_param);
   _ok9:=~(_stat_p='T' & _is_atr);
   _ok10:=~(_stat_p='T' & _is_doc);

   _ok11:=_args.COPY_OPER=0 | (~_is_toper | (_role_o & _is_toper));
   _ok12:=_args.COPY_SUR=0 | (~_is_tmat | (_role_s & _is_tmat));
   _ok13:=_args.COPY_NPU=0 | (~_is_ttls | (_role_p & _is_ttls));
   _ok14:=~_is_param | (_role_p & _is_param);
   _ok15:=~_is_atr | (_role_p & _is_atr);
   _ok16:=~_is_doc | (_role_p & _is_doc);

   _ok:=_ok1*_ok2*_ok3*_ok4*_ok5*_ok6*_ok7*_ok8*_ok9*_ok10*_ok11*_ok12*_ok13*_ok14*_ok15*_ok16;
   {? ~_ok
   || _torw_name:={? _czy_wzor>0 || 'Wzorzec'@ || 'Technologia'@ ?};
::      {? ~_ok2
::      || KOMM.add('Wzorzec i karta muszą być zgodne pod względem przypisania surowców.'@,2)
::      ?};
::      {? ~_ok1
::      || KOMM.add('Wzorzec i karta muszą być zgodne pod względem przypisania N-P-U.'@,2)
::      ?};
      {? ~_ok3
      || {? _czy_wzor>0
         || KOMM.add('Wzorzec i karta muszą być zgodne pod względem parametryzowania.'@,2)
         || KOMM.add('Technologie muszą być zgodne pod względem parametryzowania.'@,2)
         ?}
      ?};
      {? ~_ok4
      || {? _czy_wzor>0
         || KOMM.add('Wzorzec i karta muszą być zgodne pod względem występowania operacji.'@,2)
         || KOMM.add('Technologie muszą być zgodne pod względem występowania operacji.'@,2)
         ?}
      ?};
      {? ~_ok5
      || KOMM.add(_torw_name+' zawiera operacje, a na karcie zakończono redagowanie operacji.'@,2)
      ?};
      {? ~_ok6
      || KOMM.add(_torw_name+' zawiera surowce, a na karcie zakończono redagowanie surowców.'@,2)
      ?};
      {? ~_ok7
      || KOMM.add(_torw_name+' zawiera N-P-U, a na karcie zakończono redagowanie danych pozostałych.'@,2)
      ?};
      {? ~_ok8
      || KOMM.add(_torw_name+' zawiera parametry, a na karcie zakończono redagowanie danych pozostałych.'@,2)
      ?};
      {? ~_ok9
      || KOMM.add(_torw_name+' zawiera atrybuty, a na karcie zakończono redagowanie danych pozostałych.'@,2)
      ?};
      {? ~_ok10
      || KOMM.add(_torw_name+' zawiera dokumentację, a na karcie zakończono redagowanie danych pozostałych.'@,2)
      ?};
      {? ~_ok11
      || KOMM.add(_torw_name+' zawiera operacje, ale brak uprawnień redagowania operacji.'@,2)
      ?};
      {? ~_ok12
      || KOMM.add(_torw_name+' zawiera surowce, ale brak uprawnień do redagowania surowców.'@,2)
      ?};
      {? ~_ok13
      || KOMM.add(_torw_name+' zawiera N-P-U, ale brak uprawnień do redagowania danych pozostałych.'@,2)
      ?};
      {? ~_ok14
      || KOMM.add(_torw_name+' zawiera parametry, ale brak uprawnień do redagowania danych pozostałych.'@,2)
      ?};
      {? ~_ok15
      || KOMM.add(_torw_name+' zawiera atrybuty, ale brak uprawnień do redagowania danych pozostałych.'@,2)
      ?};
      {? ~_ok16
      || KOMM.add(_torw_name+' zawiera dokumentację, ale brak uprawnień do redagowania danych pozostałych.'@,2)
      ?}
   ?}
|| KOMM.del(_txt_imp)
?};
TKTL.clear();
VAR.FILTER:=_filter;
VAR.A_TORW:=_torw;
{? _ok
||
   _args.DELETE:=0;
   _args.TRANS:=1;
   _args.SUR_UPDATE:=_sur_update;
   _args.XJMP_UPDATE:=_xjmp_update;

   {? _arch='T'
   || _arch.DIR:='ARCHIWUM'
   || _args.DIR:='KARTOTEKA'
   ?};
   _args.MASK_SRC:=ref_name(_tbox)+3;
   _args.MASK_DST:=ref_name(_tktl)+3;

   _args.TKTL_SRC:=_tbox;
   _args.TKTL_DST:=_tktl;

   do();

:: 1. Kopiujemy parametry
   _ok:=exec('tpar_copy','tech_arch',_args);

   {? _ok>0 & _args.COPY_UAT>0 & _oper=0
   ||
::    2. Kopiujemy atrybuty do karty
      _ok:=exec('uat_copy','tech_arch',_args,'TKTL',_args.TKTL_SRC,_args.TKTL_DST)
   ?};
   exec('start_tpar','tech_param',exec('FindAndGet','#table',TKTL,_args.TKTL_DST,,"TKTL.KTM",null())
        ,exec('FindAndGet','#table',TKTL,_args.TKTL_DST,,,null));
   {? _ok>0 & _args.COPY_DOK>0 & _oper=0
   ||
::    3. Kopiujemy dokumentację do karty
      _ok:=DocLib.copy('TKTL',_args.TKTL_SRC,'TKTL',_args.TKTL_DST)
   ?};

   {? _ok>0 & _args.COPY_OPER>0
   ||
::    4. Kopiujemy operacje
      {? _unrop>0
      || TOPER.cntx_psh();
         TOPER.index('UNROP');
         TOPER.prefix(_unrop);
         {? TOPER.first()
         || _args.TOPER_DST:=TOPER.ref()
         ?};
         TOPER.cntx_pop()
      ?};
      _ok:=exec('toper_copy','tech_arch',_args,_records);
      _args.TOPER_DST:=null()
   ?};

   {? _ok>0 & _args.COPY_SUR>0 & _oper=0
   ||
::    5. Kopiujemy surowce
      _ok:=exec('tmat_copy','tech_arch',_args,_records)
   ?};

   {? _ok>0 & _args.COPY_NPU>0 & _oper=0
   ||
::    6. Kopiujemy NPU
      _ok:=exec('tacttls_copy','tech_arch',_args,_records)
   ?};

:: Kończę transakcje
   {? _ok=0
   || undo()
   ?};
   end();

   {? _ok>0 & _args.COPY_NAST>0
   ||
::    5. Kopiujemy NASTOPER

::    Na czas kopiowania NASTOPER robię nową transakcję, bo to kopiowanie może się nie powieść
::    a nie chciałbym aby wywaliło całą transakcję i wszystko zniknęło
      do();
      _nast:=exec('nastoper_copy','tech_arch',_args);
      {? _nast=0
      || undo();
         end();
         FUN.emsg('Struktura operacji jest nieaktualna i nie została przekopiowana.'@)
      || end()
      ?}
   ?}
?};

obj_del(__PRZEJ);
{? _ok
|| KOMM.del(_txt_imp);
   KOMM.sect_clr();
   {? TKTL.seek(_tktl)
   || {? _czy_wzor>0
      || KOMM.add('Import wzorca zakończony.'@,13)
      || KOMM.add('Kopiowanie z technologii zakończone.'@,13)
      ?}
   ?}
?};
KOMM.select();
TKTL.cntx_pop();
B_FILTER.restore(); obj_del(B_FILTER);
B_VAR.restore(); obj_del(B_VAR);
TKTL.f_clear(1);
{? VAR.A_TABKTL='W'
|| exec('set_wfilter','tech_head')
|? VAR.A_TABKTL='N'
|| exec('set_nfilter','tech_head')
|| exec('set_filter','tech_head')
?};
TOPER.cntx_pop();

exec('tktl_unlock','tech_common',#_tktl,'N');
exec('tktl_unlock','tech_common',#_tktl,'O');
exec('tktl_unlock','tech_common',#_tktl,'S');
exec('tktl_unlock','tech_common',#_tktl,'P');

~_ok


\insert_tbx_button
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Wstawia dane ze wzorca - akcja przycisku w oknie redakcyjnym nagłówka technologii
::----------------------------------------------------------------------------------------------------------------------
exec('insert_tbx','tech_arch');
''


\insert_tbox_o
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [8.70]
:: OPIS: Wstawia dane ze wzorca na poziomie operacji - domyślnie własne wzorce tymczasowe
::   WE: [_a] - TKTL.ref() - wzorzec/technologia, z którego wstawiać dane. Jak nie podany to wyświetlane okno seleckji
::       [_b] - argumenty kopiowania, wynik formuły exec('args_copy','tech_arch')
::       [_c] - tabela z listą elementów do skopiowania
::   WY: 0 / 1
::  OLD: \insert_tbox_o/tex_wzor.fml
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null()) || _tbox:=_a || _tbox:=null() ?};
{? var_pres('_b')>100 || _args:=_b || _args:=~~ ?};
{? var_pres('_c')>100 || _records:=_c || _records:=~~ ?};
{? VAR.A_OP=null()
|| exec('insert_tbx','tech_arch',0,1,_tbox,_args,_records)
|? TOPER.PZ='Z'
|| {? _ask:=choice('Operacje wzorca wstawiane będą:'@,FUN.TYT,'ASK',0,1,,
         'Jako składowe operacji złożonej'@,
         'Na tym poziomie'@,
         'Anuluj'@);
      _ask=2
   || return(1)
   |? _ask=0
   || exec('insert_tbx','tech_arch',TOPER.UNROP,1,_tbox,_args,_records)
   |? _ask=1
   || exec('insert_tbx','tech_arch',TOPER.NRNOP,1,_tbox,_args,_records)
   ?}
|| exec('insert_tbx','tech_arch',TOPER.NRNOP,1,_tbox,_args,_records)
?}


\podzlec_tpartra
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Uwzględnia translacje parametrów dla podzlecenia
::   WE: _a - _args - tablica nazwana z parametrami - wynik exec('args_copy','tech_arch')
::       _b - obiekt TPAR który wypełnić wartościami parametrów na podstawie translacji
::       _c - ZL.ref - zlecenie podrzędne
::   WY: 0 - nie znaleziono żadnych translacji, nic nie przeliczono
::       1 - znaleziono translacje i w _b znajdują się wartości je uwzgledniające
::  OLD: \podzlec_tpartra/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_args:=_a;
_tpar:=_b;

_podzlec:=_c;

_result:=0;

TPAR.cntx_psh();
TCHMAT.cntx_psh();
TCHMAT.index('NSL');
TPARTRA.cntx_psh();
TPARTRA.index('SUR');
TMAT.cntx_psh();
TMAT.index('PT');
ZL.cntx_psh(); ZL.clear();
{? ZL.seek(_podzlec)
||
:: Stoję na podzleceniu
   _ktm_podzlec:=ZL.KTM;

:: Znajduję nadzlecenie bezpośrednio nade mną lub podzlecenie na wyrób, jeśli jestem
:: na pierwszym poziomie
   _nadzlec:=exec('get_nadzlec','zl_link',ZL.ref());
   ZL.clear();
   {? ZL.seek(_nadzlec)
   ||
::    Stoję na nadzleceniu

::    Znajduję TMATa na półfabrykat podzlecenia
      TMAT.prefix(ZL.TKTL,_ktm_podzlec);
      {? TMAT.first()
      ||
         {? var_pres('_zpar',@)>0 || obj_del(_zpar) ?};
         _zpar:=obj_new(@.CLASS.TPAr,ZL.KTM);
         _zpar.TABLE:=TPAR;
         _zpar.INDEX:='NN';
         _zpar.PREFIX:=ZL.TKTL;
         _zpar.loadp();
         _kod:={? TMAT.GRKTM='K' || TMAT.PT || TMAT.TGDFLT().PT ?};
         {? _kod=TMAT.PT
         || _result:=_tpar.mod_tra(TMAT.ref,,_zpar)
         ||
            TCHMAT.cntx_psh();
            TCHMAT.prefix(TMAT.NRK,TMAT.ref());
            {? TCHMAT.first()
            || {!
               |?
                  _ktm:={? TCHMAT.GRKTM='K' || TCHMAT.PT || TCHMAT.TGDFLT().PT ?};
                   {? _ktm=TMAT.KTM & TCHMAT.ACT='T'
                   || 0
                   || TCHMAT.next()
                   ?}
               !};
               _wynik:=TCHMAT.ref()
            || _wynik:=null()
            ?};
            TCHMAT.cntx_pop();
            _result:=_tpar.mod_tra(,_wynik,_zpar)
         ?}
      ?}
   ?}
?};
ZL.cntx_pop();
TMAT.cntx_pop();
TPARTRA.cntx_pop();
TCHMAT.cntx_pop();
TPAR.cntx_pop();
_result


\px_tex_akt
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [12.41]
:: OPIS: Aktywuje/dezaktywuje przepisy planistyczne podczas przenoszenia TKTL do/z archiwum
::   WE: _a - TKTL.ref() - ref nowej karty technologicznej w archiwum/kartotece
::       _b - STRING - kierunek kopiowania
::   WY: 0 - porazka
::       1 - suces
::  OLD: \px_tex_akt/tex_arch.fml
::----------------------------------------------------------------------------------------------------------------------
_tktl:=_a;
_dir:=_b;

_result:=0;
_can_continue:=1;

PX_TEX.cntx_psh();
PX_TEX.index('RTKTL');
PX_TEX.prefix($_tktl);
{? PX_TEX.first()
|| {!
   |?
      {? _dir='ARCHIWUM'
      || {? PX_TEX.AKT='T'
         || PX_TEX.AKT:='N';
            _can_continue:=PX_TEX.put()
         ?}
      |? _dir='KARTOTEKA'
      || {? PX_TEX.AKT='N'
         || PX_TEX.AKT:='T';
            _can_continue:=PX_TEX.put()
         ?}
      ?};
      PX_TEX.next() & _can_continue>0
   !}
?};
PX_TEX.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\insert_tbox_s
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [21.14]
:: OPIS: Kopiuje surowce do karty technologicznej (poprzez drag & drop lub import z wzorca) z poziomu surowców
::   WE: _a - typ wywołania - [1] - import z wzorca, [0] - drag & drop]
::       [_b] - tablica z refami rekordów TMAT, wynik formuły dnd_info('dropped_records') - wymagana podczas
::             kopiowania poprzez metodę drag & drop
::----------------------------------------------------------------------------------------------------------------------
_type:={? var_pres('_a')=type_of(0) || _a || 1 ?};
_records:={? var_pres('_b')>100 || _b || ~~ ?};

_ok:=1;
_tktl_src:=null();
::_tktl_dest:=VAR.A_KTL;

:: Otwieram okno z wzorcami
{? _ok>0 & _type>0
|| VAR_DEL.delete('B_FILTER','B_VAR');
   B_FILTER:=obj_new(@.CLASS.BUFFER,'FILTER');
   B_VAR:=obj_new(@.CLASS.BUFFER,'VAR');

   _filter:=VAR.FILTER;
   VAR.FILTER:='N';
   _torw:=VAR.A_TORW;
::_tmp:=exec('tmp_sym','tech_head');
   FILTER.blank();
   VAR.TOW_USL:='T';
   VAR.ACTION:='1';
   VAR.A_TORW:='W';
   VAR.ARCH:='N';
   VAR.GRUPA:='N';
   TKTL.cntx_psh();
   TKTL.f_clear(1);
   exec('set_filter','tech_head');
   TKTL.win_sel('SLO_');
   TKTL.win_patt('WZOR_');
   _ok:=TKTL.select();
   {? _ok>0
   || _tktl_src:=TKTL.ref()
   ?};
   TKTL.cntx_pop();
   B_FILTER.restore(); obj_del(B_FILTER);
   B_VAR.restore(); obj_del(B_VAR);
   TKTL.f_clear(1);
   {? VAR.A_TABKTL='W'
   || exec('set_wfilter','tech_head')
   |? VAR.A_TABKTL='N'
   || exec('set_nfilter','tech_head')
   || exec('set_filter','tech_head')
   ?}
?};

:: Sprawdzana możliwość zablokowania karty w każdym zakresie
{? _ok>0
|| {? ~(exec('tktl_lock','tech_common',#VAR.A_KTL,'N',1) &
        exec('tktl_lock','tech_common',#VAR.A_KTL,'O',1) &
        exec('tktl_lock','tech_common',#VAR.A_KTL,'S',1) &
        exec('tktl_lock','tech_common',#VAR.A_KTL,'P',1))
   || _ok:=0;
      {? _type>0
      || FUN.emsg('Karta jest redagowana. Wstawienie wzorca nie jest możliwe.'@)
      || FUN.emsg('Karta jest redagowana. Kopiowanie surowców nie jest możliwe.'@)
      ?}
   ?};

   {? _ok>0
   ||
      {? _type>0
      || KOMM.init(250,,'Wstawianie wzorca'@,'');
         _txt_imp:='Import wzorca został przerwany. Wszystkie zmiany zostały wycofane.'@
      || KOMM.init(250,,'Kopiowanie surowców'@,'');
         _txt_imp:='Kopiowanie surowców zostało przerwane. Wszystkie zmiany zostały wycofane.'@

      ?};
      KOMM.sect_beg(_txt_imp);

      {? _type=0
      || _tktl_src:=exec('FindAndGet','#table',TMAT,_records.REF,dnd_info('table_name'),"TMAT.NRK",null())
      ?};

::    Sprawdzam uprawnienia i zgodność wg statusów karty
      {? VAR.A_TORW='Z'
      || _role_p:=_role_s:=exec('chk_role','#b__box',OPERATOR.USER,'TTE_PZL_DTEC')
      || _role_s:=exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRTS');
         _role_p:=exec('chk_role','#b__box',OPERATOR.USER,'TTE_TEC_DRDP')
      ?};

      _t_par:=exec('FindAndGet','#table',TKTL,_tktl_src,,"TKTL.TYP().PAR",'');
      _t_par_dst:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.TYP().PAR",'');
      _stat_s:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.STAT_S",'');
      _stat_p:=exec('FindAndGet','#table',TKTL,VAR.A_KTL,,"TKTL.STAT_P",'');

      _is_tmat:=exec('is_tmat','tech_head',_tktl_src);
      _is_param:=exec('is_param','tech_head',_tktl_src);
      _is_atr:=exec('is_atr','tech_head',_tktl_src);
      _is_doc:=exec('is_doc','tech_head',_tktl_src);

::    Wymagana zgodność parametryzacji, albo kopiowanie wzorca nieparametryzowanego na kartę parametryzowaną
      _ok3:=(_t_par=_t_par_dst | (_t_par='N' & _t_par_dst='T'));

      _ok6:=~(_stat_s='T' & _is_tmat);
      _ok8:=~(_stat_p='T' & _is_param);
      _ok9:=~(_stat_p='T' & _is_atr);
      _ok10:=~(_stat_p='T' & _is_doc);

      _ok12:=~_is_tmat | (_role_s & _is_tmat);
      _ok14:=~_is_param | (_role_p & _is_param);
      _ok15:=~_is_atr | (_role_p & _is_atr);
      _ok16:=~_is_doc | (_role_p & _is_doc);

      _ok:=_ok3*_ok6*_ok8*_ok9*_ok10*_ok12*_ok14*_ok15*_ok16;
      {? ~_ok
      || {? ~_ok3
         || KOMM.add('Technologia źródłowa i docelowa muszą być zgodne pod względem parametryzowania.'@,2)
         ?};
         {? ~_ok6
         || KOMM.add('Technologia zawiera surowce, a na karcie zakończono redagowanie surowców.'@,2)
         ?};
         {? ~_ok8
         || KOMM.add('Technologia zawiera parametry, a na karcie zakończono redagowanie danych pozostałych.'@,2)
         ?};
         {? ~_ok9
         || KOMM.add('Technologia zawiera atrybuty, a na karcie zakończono redagowanie danych pozostałych.'@,2)
         ?};
         {? ~_ok10
         || KOMM.add('Technologia zawiera dokumentację, a na karcie zakończono redagowanie danych pozostałych.'@,2)
         ?};
         {? ~_ok12
         || KOMM.add('Technologia zawiera surowce, ale brak uprawnień do redagowania surowców.'@,2)
         ?};
         {? ~_ok14
         || KOMM.add('Technologia zawiera parametry, ale brak uprawnień do redagowania danych pozostałych.'@,2)
         ?};
         {? ~_ok15
         || KOMM.add('Technologia zawiera atrybuty, ale brak uprawnień do redagowania danych pozostałych.'@,2)
         ?};
         {? ~_ok16
         || KOMM.add('Technologia zawiera dokumentację, ale brak uprawnień do redagowania danych pozostałych.'@,2)
         ?}
      || KOMM.del(_txt_imp)
      ?}
   ?};
:: Wszystko ok, można kopiować
   {? _ok>0
   || _args:=exec('args_copy','tech_arch');
      _args.DELETE:=0;
      _args.TRANS:=1;
      _args.DIR:='KARTOTEKA';
      _args.SUR_ONLY:=1;

      _args.TKTL_SRC:=_tktl_src;
      _args.TKTL_DST:=VAR.A_KTL;
      _args.MASK_SRC:=ref_name(_args.TKTL_SRC)+3;
      _args.MASK_DST:=ref_name(_args.TKTL_DST)+3;
      _args.TOPER_DST:=VAR.A_OP;

      _xjm_src:=exec('FindAndGet','#table',TKTL,_args.TKTL_SRC,,"TKTL.XJM",0);
      _xjm_dst:=VAR.A_KTL().XJM;

      _jm_src:=exec('FindAndGet','#table',TKTL,_args.TKTL_SRC,,"TKTL.JM",null());
      _jm_dst:=VAR.A_KTL().JM;
      _is_jm:={? _jm_src<>_jm_dst || 1 || 0 ?};
      _args.XJMP_UPDATE:=_is_jm;

      {? _xjm_src<>_xjm_dst
      || _txt:='Ilość produktu, na który projektowana jest karta (%1) jest inna niż na karcie źródłowej (%2).\n'
               'Czy wstawić surowce i przeliczyć ilości według zdefiniowanego składu procentowego? '
               '(pominięcie przeliczenia spowoduje wyznaczanie nowych procentowych zawartości '
               'surowców oraz zamienników technologii)\n'@
               [$_xjm_dst,$_xjm_src];

         _is_form:=exec('is_form','tech_head',_args.TKTL_SRC);
         {? _is_jm>0 | _is_form>0
         || _txt+='\nUWAGA!\n'@;
            {? _is_jm>0
            || _txt+='Jednostka miary projektowanej karty jest inna niż na karcie źródłowej. Zawartość procentowa '
                     'kopiowanych surowców zostanie przeliczona względem jednostki miary projektowanej technologii.'@
            |? _is_form>0
            || _txt+='Surowce/zamienniki technologii źródłowej mają zdefiniowane formuły na wartości norm '
                     'netto/brutto. Zawartość procentowa kopiowanych surowców może ulec zmianie.'@
            ?}
         ?};
         _ok:=FUN.choice(_txt,,'Wstaw i przelicz'@,'Wstaw i nie przeliczaj'@);
         {? _ok=1
         || _args.SUR_UPDATE:=1
         |? _ok=2
         || _args.XJMP_UPDATE:=1
         ?}
      |? _jm_dst<>_jm_src
      || _txt:='Jednostka miary projektowanej karty jest inna niż niż na karcie źródłowej. Zawartość procentowa '
               'kopiowanych surowców zostanie przeliczona względem jednostki miary projektowanej technologii.\n'
               'Czy mimo to wstawić surowce?'@;
         _ok:=FUN.ask(_txt)
      ?};
      {? _ok>0
      ||
::       1. Kopiujemy parametry
         _ok:=exec('tpar_copy','tech_arch',_args)
      ?};
      {? _ok>0
      ||
::       2. Kopiujemy atrybuty do karty
         _ok:=exec('uat_copy','tech_arch',_args,'TKTL',_args.TKTL_SRC,_args.TKTL_DST)
      ?};
      exec('start_tpar','tech_param',exec('FindAndGet','#table',TKTL,_args.TKTL_DST,,"TKTL.KTM",null())
           ,exec('FindAndGet','#table',TKTL,_args.TKTL_DST,,,null));
      {? _ok>0
      ||
::       3. Kopiujemy surowce
         {? _type>0
         || _ok:=exec('tmat_copy','tech_arch',_args)
         || _ok:=exec('tmat_copy','tech_arch',_args,_records)
         ?}
      ?};
      {? _ok>0
      || KOMM.del(_txt_imp);
         KOMM.sect_clr();
         {? _type>0
         || KOMM.add('Import wzorca zakończony.'@,13)
         || KOMM.add('Kopiowanie surowców zakończone.'@,13)
         ?}
      ?}
   ?};
   KOMM.select();
   exec('tktl_unlock','tech_common',#VAR.A_KTL,'N');
   exec('tktl_unlock','tech_common',#VAR.A_KTL,'O');
   exec('tktl_unlock','tech_common',#VAR.A_KTL,'S');
   exec('tktl_unlock','tech_common',#VAR.A_KTL,'P')
?};
~~


\insert_from_tktl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Kopiuje surowce/operacje/NPU do karty technologicznej z innej technologii.
::       Działa w oparciu o VAR.A_KTL, VAR.A_OP
::   WE: _a - kopiowany element technologii: 0 - operacje, 1 - surowce, 2 - NPU
::   WY: 0/1 - wynik formuły exec('insert_tbx','tech_arch')
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
_what:=_a;
_tab:={? _what=0 || TOPER |? _what=1 || TMAT || TACTTLS  ?};
_tktl:=null();

_ktl:=VAR.A_KTL;
_torw:=exec('FindAndGet','#table',TKTL,_ktl,,"TORW",'T');
TKTL.cntx_psh();
TKTL.clear();
TKTL.f_clear(1);
:: Ustalenie filtru na technologie wg wtyczki
{? Plugin.runnable('TKTL_INSERT_FILTER_001')
|| Plugin.run('TKTL_INSERT_FILTER_001',exec('tab_acr','#table',_tab),_torw)
?};
{? TKTL.f_active()=0 | TKTL.f_active()=2
||
:: Jeżeli nie ma wtyczki lub wtyczka nie ustaliła filtru, to ustawienie filtru standardowego
   _torw:=VAR.A_TORW;
   _arch:=VAR.ARCH;
   _filter:=VAR.FILTER;
   VAR.A_TORW:='T';
   VAR.ARCH:='N';
   VAR.FILTER:='N';
   exec('set_filter','tech_head',_what);
   VAR.A_TORW:=_torw;
   VAR.ARCH:=_arch;
   VAR.FILTER:=_filter
?};

TKTL.win_sel('SLO');
:: Selekcja technologii
{? TKTL.select()
|| _tktl:=TKTL.ref()
?};
TKTL.cntx_pop();
VAR.A_KTL:=_ktl;

{? _tktl<>null()
||
   TKTL.cntx_psh();
   _tab.cntx_psh();
   {? _tab=TOPER
   || TOPER.index('ANNN');
      TOPER.prefix('T','N',_tktl)
   |? _tab=TMAT
   || TMAT.index('ANNL');
      TMAT.prefix('T',_tktl)
   || TACTTLS.index('AKNROPR');
      TACTTLS.prefix('T',_tktl)
   ?};
:: Utworzenie okna selekcji
   exec('insert_tktl_wer','tech_arch',_tab);
:: Utworzenie tabeli z refami wybranych elementów
   _ref_table:=tab_tmp(,'REF','INTEGER','#TAB.ref()','UNROP','REAL','Unikalny nr op.','NRNOP','REAL','Nr op. nadrz.');
   params_set('ref_table',_ref_table);
   _continue:=0;
:: Selekcja elementów
   {? _tab.select()
   || _continue:=1;
::    Usunięcie nadmiarowych zapisów opercji technologicznych - usunięcie zapisu o operacji podrzędnej
::    jeżeli kopiowana operacja nadrzędna
      {? _tab=TOPER
      || {? _ref_table.first()
         || {!
            |?
               {? _ref_table.NRNOP<>0
               || _del:=0;
                  _ref_table.cntx_psh();
                  {? _ref_table.find_tab(,'UNROP',,'=',_ref_table.NRNOP)
                  || _del:=1
                  ?};
                  _ref_table.cntx_pop();
                  {? _del>0
                  || _next:=_ref_table.del(,1)=2
                  || _next:=_ref_table.next()
                  ?}
               || _next:=_ref_table.next()
               ?};
               _next
            !}
         ?}
      ?}
   ?};
   _tab.cntx_pop();
   TKTL.cntx_pop();
   VAR.A_KTL:=_ktl;
   {? _continue>0
   || {? _ref_table.first()
      || _args:=exec('args_copy','tech_arch');
         _args.COPY_DOK:=0;
         _args.COPY_NAST:=0;
         {? _tab=TOPER
         || _args.OPER_ONLY:=1;
            _args.COPY_SUR:=0;
            _args.COPY_NPU:=0
         |? _tab=TMAT
         || _args.SUR_ONLY:=1;
            _args.COPY_OPER:=0;
            _args.COPY_NPU:=0;
            _args.TOPER_DST:=VAR.A_OP
         || _args.NPU_ONLY:=1;
            _args.COPY_SUR:=0;
            _args.COPY_OPER:=0;
            _args.TOPER_DST:=VAR.A_OP
         ?};
         {? _tab=TOPER
         || _result:=exec('insert_tbox_o','tech_arch',_tktl,_args,_ref_table)
         || _result:=exec('insert_tbx','tech_arch',,,_tktl,_args,_ref_table)
         ?}
      ?}
   ?}
?};
VAR.A_KTL:=_ktl;
:: Odtworzenie filtra na technologii
{? VAR.A_TABKTL='W'
|| exec('set_wfilter','tech_head')
|? VAR.A_TABKTL='N'
|| exec('set_nfilter','tech_head')
|| exec('set_filter','tech_head')
?};
_result


\insert_tktl_wer
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Tworzy i ustawia okno selekcji surowców/operacji/NPU podczas kopiowania z innej technologii
::   WE: _a - tabela, dla której tworzyć okno: TOPER/TMAT/TACTTLS
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a;
_win:=_tab.mk_sel({? _tab=TOPER || 'Operacje'@ |? _tab=TMAT || 'Surowce'@ || 'Narzędzia'?},,
   ,'#tktlins_'+(4+-exec('tab_acr','#table',_tab)),,,,,'U',,,,,'html_maximized');
_tab.win_act(_win,0,'Formuła','&Wybierz'@@,,,"params_exec('insert_tktl_sel','tech_arch')"
   ,"exec('sel_exit_','#window')",1,1,"",,'W',0,'target=window');
{? _tab=TOPER
|| TOPER.win_fld(_win,VAR,'SCIEZKA',,,4,0,0,'Lp'@@,0,'',,);
   TOPER.win_fld(_win,TOPER,'NAZWA',,,25,0,1,'Operacja'@@,0,'',,);
   TOPER.win_fld(_win,TOPER,'NTIME',,,15,0,0,'',0,'',,);
   TOPER.win_fld(_win,TOPER,'MTIME',,,15,0,0,'',0,'',,);
   TOPER.win_fld(_win,TOPER,'PFAZ','KOD','*','10,10,10',0,1,'Faza produkcji'@@,0,'',,);
   TOPER.win_act(_win,0,'Rekord','','','',"exec('toper_sel_rec','tech_oper',_a)"
      ,"",0,0,"","",'',0,'mobile=1,target=window');
   TOPER.win_act(_win,0,'Wyświetl','','','',"exec('toper_sel_disp','tech_oper')"
      ,"",0,0,"","",'',0,'mobile=1,target=record');
   TOPER.win_act(_win,0,'Szukaj','','','',"","",0,0,"","",'',0,'mobile=1,target=window');
   TOPER.win_act(_win,0,'Kolejność','','','',"","",0,0,"","",'',0,'mobile=1,target=window');
   TOPER.win_act(_win,0,'Formuła','Legenda'@@,'','Legenda kolorowania wierszy i pól okna wertowania'@
      ,"exec('toper_sel_leg','tech_oper')","",0,0,"","",'L',0,'mobile=1,target=window')
|? _tab=TMAT
|| TMAT.win_fld(_win,VAR,'STRING',,,10,0,1,'Nr operacji'@@,0,'Numer operacji procesu technologicznego'@,,);
   TMAT.win_fld(_win,TMAT,'LP',,,3,0,0,'Lp'@@,0,'',,);
   TMAT.win_fld(_win,VAR,'K_NKTM',,,20,0,1,'Indeks'@@,0,'Indeks surowca'@,,);
   TMAT.win_fld(_win,VAR,'P_NKTM',,,25,0,1,'Nazwa'@@,0,'Zawartość wolnego pola Nazwa/KTM'@,,);
   TMAT.win_fld(_win,TMAT,'WARN',,,15,4,1,'Norma netto'@@,0,'Norma materiałowa netto'@,,);
   TMAT.win_fld(_win,TMAT,'WARB',,,15,4,1,'Norma brutto'@@,0,'Norma materiałowa brutto'@,,);
   TMAT.win_fld(_win,M,'J','KOD','*','10,10,10',0,1,'Jednostka miary'@@,0,'Kod jednostki miary'@,,);
   TMAT.win_fld(_win,TMAT,'PODST',,,'3,7,7',0,0,'Podstawowy'@@,0,'Surowiec podstawowy (T - tak, N - nie)'@,2,,"mb_exec('''T''')","mb_exec('''N''')","");
   TMAT.win_fld(_win,TMAT,'LIMIT',,,'3,7,7',0,0,'Limitowany'@@,0,'Surowiec limitowany (T - tak, N - nie)'@,2,,"mb_exec('''T''')","mb_exec('''N''')","");
   TMAT.win_fld(_win,TMAT,'SO',,,'3,7,7',0,1,'Odpad?'@@,0,'Znacznik odpadu (O - odpad/koprodukt, S - surowiec)'@,2,,"mb_exec('''O''')","mb_exec('''S''')","");
   TMAT.win_fld(_win,TMAT,'PFAZ','KOD','*','10,10,10',0,1,'Faza produkcji'@@,0,'Kod fazy produkcji'@,,);
   TMAT.win_fld(_win,TMAT,'WYD','KOD','*',8,0,1,'Wydział'@@,0,'Kod pozycji w słowniku'@,,);
   TMAT.win_act(_win,0,'Rekord','','','',"exec('rekprzed','color','TMAT#01#01')"
      ,"exec('tchm_edt','tech_mater',TMAT)",0,0,"","",'',0,'mobile=1,target=window');
   TMAT.win_act(_win,0,'Wyświetl','','','',"exec('tmat_display','tech_mater')"
      ,"",0,0,"","",'',0,'mobile=1,target=record');
   TMAT.win_act(_win,0,'Formuła','Zmiany&'@@,'','Historia zmian danych'@
      ,"exec('zmiany','#syslog')","",0,0,"","",'Ć',0,'mobile=1,target=record');
   TMAT.win_act(_win,0,'Menu','Szukaj'@@,'','Szukanie zapisu zgodnego ze zredagowanym wzorcem'@
      ,"","",0,0,"","",'S',0,'mobile=1,target=record');
   TMAT.win_act(_win,0,'Formuła','Szukaj dokładnie'@@,'#S','',"exec('tmat_szukaj','tech_mater',0)"
      ,"",0,0,"","",'S',0,'mobile=1');
   TMAT.win_act(_win,0,'Formuła','Szukaj &kontekstowo'@@,'#S','',"exec('tmat_szukaj','tech_mater',1)"
      ,"",0,0,"","",'K',0,'mobile=1');
   TMAT.win_act(_win,0,'Kolejność','','','',"","",0,0,"","",'',0,'mobile=1,target=window');
   TMAT.win_act(_win,0,'Formuła','Legenda'@@,'','Legenda kolorowania wierszy i pól okna wertowania'@
      ,"exec('leg_tmat','tech_mater')","",0,0,"","",'L',0,'mobile=1,target=window')
|| TACTTLS.win_fld(_win,VAR,'STRING',,,10,0,1,'Nr operacji'@@,0,'Numer operacji procesu technologicznego'@,,);
   TACTTLS.win_fld(_win,TACTTLS,'M','KTM','MATKTM',10,0,0,'Symbol'@@,0,'Indeks materiałowy'@,,);
   TACTTLS.win_fld(_win,M,'N',,,30,0,1,'Nazwa'@@,0,'Nazwa indeksu materiałowego'@,,);
   TACTTLS.win_fld(_win,M,'MGR','KOD','*',9,0,1,'Grupa'@@,0,'Kod grupy'@,,);
   TACTTLS.win_fld(_win,TACTTLS,'ILE',,,5,0,0,'Ilość'@@,0,'Ilość narzędzia potrzebna w procesie technologicznym'@,,);
   TACTTLS.win_fld(_win,TACTTLS,'ZXJM',,,'14,14,14',4,0,'Zużycie na serię produktu'@@,0
      ,'Zużycie narzędzia po wykonaniu ilości produktu na karcie'@,,);
   TACTTLS.win_fld(_win,TACTTLS,'ZH',,,'14,14,14',4,0,'Zużycie na godzinę'@@,0
      ,'Zużycie N-P-U na godzinę pracy'@,,);
   TACTTLS.win_act(_win,0,'Rekord','','','',"exec('rekprzed','color','TACTTLS#01#01')"
      ,"exec('TACTWERr','tech_tool')",0,0,"","",'',0,'mobile=1,target=window');
   TACTTLS.win_act(_win,0,'Wyświetl','','','',"exec('display_tacttls','tech_tool')",""
      ,0,0,"","",'',0,'mobile=1,target=record');
   TACTTLS.win_act(_win,0,'Kolejność','','','',"","",0,0,"","",'',0,'mobile=1,target=window')
?};
_tab.win_sel(_win);
~~


\insert_tktl_sel
::----------------------------------------------------------------------------------------------------------------------
::  UTW: AKUL [23.25]
:: OPIS: Akcja Wybierz w oknach selekcji surowców/operacji/NPU podczas kopiowania z innej technologii
::----------------------------------------------------------------------------------------------------------------------
_ref_table:=params_get().ref_table;
_tab:=cur_tab(1,1);
_ref_table.REF:=#_tab.ref();
{? _tab=TOPER
|| _ref_table.UNROP:=TOPER.UNROP;
   _ref_table.NRNOP:=TOPER.NRNOP
?};
_ref_table.add();
~~


:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:37 2a2c56fffbbab7d0c383703727d4a4154a4c597183f786605e618b6cbb584b3275051cf1020077e12744b38f3c25dc44a7a4a270045e20e0cfcbf34be93af413545c5577bedba086ab0ead58590dd6a1e178ed1adcc49fffdf482feeab42693bb0b0b1bcdbeba23490767d145120de01837869e8044cd69d3d6560d8adf9a7b7
