:!UTF-8
:: (c) Macrologic S.A. Wszelkie prawa zastrzeżone
::======================================================================================================================
:: Nazwa pliku:  px_plan.fml [12.10]
:: Utworzony: 2011-06-13
:: Autor: WH
::======================================================================================================================
:: Zawartość: Zbiór różnych funkcji dla planu strategicznego
::======================================================================================================================


\px_menu
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Wyswietla menu kontekstowe wielowymiarowego planu pojemnosciowego
::----------------------------------------------------------------------------------------------------------------------
:: inicjalizacja wszystkich zmiennych itp. rzeczy dla PXow
exec('init_all','px_init');

:: Uzupelnienie akcji
PX_WYK.fld_fml('CAP_WYK1','AFTER_EDIT',"exec('px_wyk_wyk_ae','px_wyk')");

:: czyszcze wersje 'smieci'
exec('garbage','px_ver');

:: sprawdzam czy jest zalozona glowna wersja planu, jesli nie to ja zakladam
exec('mainversion_chk','px_ver');

::exec('m_tmp','skid_mk',1,'WWPP');
~~


\pxselect
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Deklaruje obiekt w ktorym przechowywany jest kontekst okna
::   WE: [_a] - INTEGER - czy praca na jednej wersji planu: 1 - tak, [0] - nie
::   WY: obj_new - tablica nazwana
::----------------------------------------------------------------------------------------------------------------------
_one_ver:=0;
{? var_pres('_a')=type_of(0)
|| _one_ver:=_a
?};

_pxselect:=obj_new(
:: Komponent sterujacy wymiarami planu
                     'PX_WYM',
:: Okno wertowania wymiarow planu
                     'wx_WYM',
::                     'wx_OBJ',
::                     'wx_GRP',
:: Okno opoznionych pozycji planu
                     'wx_POZ',
:: Tabela tymczasowa do zapamietywania wybranych wymiarow dla kontenerow
                     'PX_WK',
:: Zakladka z widokiem drzewa agregowanym wg obiektow
                     'Tab_OBJ',
:: Zakladka z widokiem drzewa agregowanym wg kontenerow
                     'Tab_KONT',
                     'Pxgrp',
                     'Pxgrp1',
                     'Pxconn',
                     'mask',
                     'VER_QUE',
                     'VER_QUE1',
                     'QueCmp',
                     'VIE_CUP',
                     'VIE_KONT',
                     'VIE_VER',
                     'VIE_DATE',
::                   PX_VIEW.ref - ref aktualnie wyswietlanego w oknie widoku
                     'VIEW',
::                   Id comboboxa w kontrolce do zmiany widoku
                     'ID_VIEW',
::                   Id radiobuttona kafelki:start w w kontrolce do zmiany widoku
                     'ID_KAF_S',
::                   Id radiobuttona kafelki:koniec w w kontrolce do zmiany widoku
                     'ID_KAF_E',
::                   Id comboboxa w kontrolce do zmiany zestawu
                     'ID_SET',

::                   Czy widok ma sie opierac o date startowa czy koncowa
                     'VIEW_S',
                     'EDIT',
                     'save',
                     'restore',
:: Kontrolki nawigacyjne
                     'PX_NAVI',
                     'PXQ_NAVI',
:: Kontrolka wyszukiwania obiektow
                     'OBJ_FIND',
:: Obsluga zaznaczen rekordow w oknie obiektow
                     'OBJ_sget',
                     'OBJ_sdel',
                     'Menu',
:: Kontekst wywolania dla menu kontekstowych:
:: glowny panel planu (PX), panel dla symulacji zlecenia (ZL), dla zamowienia (ZAM), podglad wersji (VER)
:: dodane '|MENU' jezeli wolane z poziomu kolejnego menu
:: dodane '|WIN' jezeli wolane z okna oderwanego od okna glownego planu
:: dodane '|NAV' jezeli dostepny panel nawigacyjny
                     'Context',
:: Aktywna zakładka
                     'CUR_TAB'
                  );
{? _one_ver>0
|| _pxselect.ID_VIEW:='1c9nml2ihie8m934jdibjnglii5ee';
   _pxselect.ID_SET:='4cbe4m26d9l00a9kj6n1gk3m1919';
   _pxselect.ID_KAF_S:='1inldn0lhiecfl5a42l3k2751n1h7';
   _pxselect.ID_KAF_E:='29k37f429n0n78bfa5c5k862809kf'
|| _pxselect.ID_VIEW:='1c9nml2ihie8m934jdibjnglii5ee';
   _pxselect.ID_KAF_S:='1inldn0lhiecfl5a42l3k2751n1h7';
   _pxselect.ID_KAF_E:='29k37f429n0n78bfa5c5k862809kf'
?};
_pxselect.VIEW_S:='S';
_pxselect.Context:='';
_pxselect.save:="
                  PX_KONT.cntx_psh();
                  PX_GRP.cntx_psh();
                  PX_OBJ.cntx_psh();
                  PX_CONN.cntx_psh();
                  PX_TASK.cntx_psh();
                  .VER_QUE:=PX_VAR.VER_QUE;
                  .VIE_CUP:=PX_VAR.VIE_CUP;
                  .VIE_KONT:=PX_VAR.VIE_KONT;
                  .VIE_VER:=PX_VAR.VIE_VER;
                  .VIE_DATE:=PX_VAR.VIE_DATE;
                  .EDIT:=PX_VAR.EDIT;
                  .VIEW:=PX_VAR.PX_VIEW;
                  ~~
               ";

_pxselect.restore:="
                     PX_KONT.cntx_pop();
                     PX_GRP.cntx_pop();
                     PX_OBJ.cntx_pop();
                     PX_CONN.cntx_pop();
                     PX_TASK.cntx_pop();
                     PX_VAR.VER_QUE:=.VER_QUE;
                     PX_VAR.VIE_CUP:=.VIE_CUP;
                     PX_VAR.VIE_KONT:=.VIE_KONT;
                     PX_VAR.VIE_VER:=.VIE_VER;
                     PX_VAR.EDIT:=.EDIT;
                     PX_VAR.VIE_DATE:=.VIE_DATE;
                     PX_VAR.PX_VIEW:=.VIEW;
                     exec('dnd_init','px_plan');
                     ~~
                  ";
_pxselect


\select_action
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [12.41]
:: OPIS: Akcja 'Plan główny - edycja' wywolywana z menu kontekstowego
::----------------------------------------------------------------------------------------------------------------------
exec('trigger_on','px_grp');
_one_version:=exec('is_one_version','px_param');
PX_VAR.MAINVER:=exec('get_mainversion','px_ver');
{? _one_version>0
|| exec('select','px_plan',exec('get_mainversion','px_ver'),0,,,_one_version)
|| exec('select','px_plan',exec('get_mainversion','px_ver'),1)
?};
exec('trigger_off','px_grp');
~~


\select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja panelu planowania
::   WE: _a - PX_VER.ref() - wersja planu ktora ogladam
::       [_b] - 0 / 1 - 1=kolejka ma byc z wersji tymczasowej; 0=z tej ktora ogladam (domyslnie)
::       [_c] - -1: podglad, panel zaawansowania przeliczania pozwala tylko zaakceptowac symulacje
::               0: podglad, bez panelu zaawansowania przeliczania
::              [1]: redagowanie planu
::       [_d] - kontekst wywolania, domyslnie 'PX'
::       [_e] - INTEGER - czy praca na jednej wersji planu: 1 - tak, [0] - nie
::   WY:  0 - okno zostalo zamkniete przez operatora
::       >0 - okno zamkniete funkcja sel_exit()
::----------------------------------------------------------------------------------------------------------------------
_result:=0;
{? var_pres('_a')<>type_of(null())
|| FUN.emsg('Niepoprawna lista parametrów. Nie określono wersji planu, którą wyświetlić.'@);
   return()
?};
_version:=_a;
exec('icon_before','px_plan');

{? ~exec('ver_borders_ok','px_ver',_version) || return() ?};

{? var_pres('_b')=type_of(0) || _temp_queue:=_b || _temp_queue:=0 ?};
{? var_pres('_c')=type_of(0) || _edit:=_c || _edit:=1 ?};
{? var_pres('_d')=type_of('')|| _context:=_d || _context:='PX' ?};
{? var_pres('_e')=type_of(0) || _one_ver:=_e || _one_ver:=0 ?};

_delete:="
   VAR_DEL.delete('PxSelect')
";
_delete();

:: - obiekt do obsługi drzewa operacji
exec('declare','tech_tree');

:: Inicjalizacja obiektu pamietajacego stan okienka
PxSelect:=exec('pxselect','px_plan',_one_ver);
PxSelect.OBJ_sdel:=0;

PxSelect.save();

PxSelect.Context:=_context;

PX_VAR.VIE_VER:=_version;
PX_VAR.VER_QUE:=_version;
PxSelect.VER_QUE:=_version;

exec('opernast_init','px_init');

PX_VAR.PX_SET:=null();
PX_VAR.EDIT:=(_edit=1) & exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPLA');
{? _edit>0 & exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DOPL')>0
|| PX_VAR.EDIT_QUE:=1
|| PX_VAR.EDIT_QUE:=0
?};
PX_VAR.ZNACZNIK:=exec('txt_plan_nul','px_param');

:: Sprawdzam, czy sa zdefiniowane widoki planu
PX_VIEW.index('SYMBOL');
PX_VIEW.clear();
{? PX_VIEW.size()=0
|| _msg:='Nie zdefiniowano żadnych widoków planu.\n'
         'Aby wyświetlić plan należy utworzyć przynajmniej jeden widok w obszarze roboczym \'ZWS_PAR - Ustawienia i parametryzacja\'.'@;
   FUN.emsg(_msg);
   PxSelect.restore();
   return()
?};

:: Sprawdzam, czy wszystkie kontentenery (zasoby) maja ustawiony maksymalny czas trwania pojemikow
:: (potrzebne dla widokow planu, na zakladkach Obiekty/Zasoby)
{? exec('chk_maxdur','px_kont',_version)=0
|| _msg:='Nie wszystkie zasoby w wyświetlanej wersji planu mają określoną \'Optymalną długość pojemników\'.\n'
         'Aby wyświetlić plan należy ustawić wszystkim zasobom ten parametr w obszarze roboczym \'ZWS_PAR - Ustawienia i parametryzacja\'.'@;
   FUN.emsg(_msg);
   PxSelect.restore();
   return()
?};

:: Sprawdzam, czy wszystkie kontenery (zasoby) sa przypisane do zestawow planistycznych
:: (potrzebne gdy praca na jednej wersji)
{? _one_ver & exec('chk_set','px_kont',_version)=0
|| _msg:='Nie wszystkie zasoby w wyświetlanej wersji planu są przypisane do \'Zestawów planistycznych\'.\n'
         'Aby wyświetlić plan należy ustawić wszystkim zasobom ten parametr w obszarze roboczym \'ZWS_PAR - Ustawienia i parametryzacja\'.'@;
   FUN.emsg(_msg);
   PxSelect.restore();
   return()
?};

:: Sprawdzam, czy wszystkie kontenery (zasoby) NIE sa przypisane do zestawow planistycznyc
:: (potrzebne gdy praca na wielu wersjach)
{? ~_one_ver & exec('chk_set1','px_kont',_version)=0
|| _msg:='Niektóre zasoby w wyświetlanej wersji planu są przypisane do \'Zestawów planistycznych\'.\n'
         'Aby wyświetlić plan należy usunąć wszystkim zasobom ten parametr w obszarze roboczym \'ZWS_PAR - Ustawienia i parametryzacja\'.\n'
         'Uwaga: do redagowania powiązań z zestawami należy parametr 500365 ustawić na wartość \'T\'.'@;
   FUN.emsg(_msg);
   PxSelect.restore();
   return()
?};

:: Ustawiam domyslny widok dla usera
_default_view:=exec('default_view','px_view');
PX_VAR.PX_VIEW:=_default_view;

:: Blokuje widok planu
exec('lock','px_view',PX_VAR.PX_VIEW);

:: Ustawiam domyslny zestaw dla usera (gdy symulacja to null())
{? exec('is_px_set','px_param')>0
|| {? exec('mainversion_vie','px_ver')
   || _default_set:=exec('default_set','px_setu');
      PX_VAR.PX_SET:=_default_set
   || PX_VAR.PX_SET:=null()
   ?}
?};

:: Blokuje zestaw planistyczny
exec('lock','px_set',PX_VAR.PX_SET);

:: Ustawiam tryb prefiksowania kafelkow
PX_VAR.KAF_MODE:='S';

:: Podczytuje do zmiennej maksymalna dlugosc pojemnikow dla widoku 'Obiekty' (szybszy dostep)
PX_VAR.OBJ_CDUR:=exec('get','#params',500363,2);

PX_VAR.IL_KOL:=exec('il_kol','px_plan');
:: Poczatkowy kontekst pracy - szukamy biezacego pojemnika w (dowolnym - pierwszym) kontenerze widokowym
_tm_curr:=SYSLOG.tm_stamp();
{? PX_VAR.VIE_VER().TM_START>=_tm_curr
|| _data:=PX_VAR.VIE_VER().STARTD().DATA
|? PX_VAR.VIE_VER().TM_END<=_tm_curr
|| _data:=PX_VAR.VIE_VER().ENDD().DATA-1
|| _data:=date()
?};
{? ~exec('go_cup_date','px_plan',_data) || PxSelect.restore(); return() ?};

{? _temp_queue>0
||
:: tworze tymczasowa wersje planu, po to by od razu pokazywac tymczasowa wersje kolejki ktora
:: uzytkownik moze z marszu edytowac, nie psujac kolejki planu glownego
   _ver_tmp:=exec('px_ver_temp','px_ver');
   PX_VAR.VER_QUE:=_ver_tmp;
   PxSelect.VER_QUE:=_ver_tmp
|| _ver_tmp:=null()
?};

{? _one_ver=0
||
:: blokuje ogladana wersje po to zeby mi jej ktos nie usunal przypadkiem
   exec('lock','px_ver',PX_VAR.VER_QUE)
?};

:: Tabela tymczasowa do zapamietywania wybranych wymiarow dla kontenerow
PxSelect.PX_WK:=tab_tmp(1,'KONTENER','STRING[16]','Kontener','WYMIAR','INTEGER','Wymiar');

:: Inicjowanie ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
:: tytul okna
{? _context='PX'
|| _title:=''
|| _title:='Panel planowania: '+PX_VAR.VIE_VER().SYMBOL
?};
:: kontenery w widoku drzewa
_tree_kont:=exec('tree_kont','px_param');
:: Kolejka i obiekty do planowania w zakladkach
_que_tab:=exec('queue_in_tabs','px_param');
:: Rozne wymiary
_h_podz:={? _que_tab || 14 || 14 ?};
_h_nav:={? _que_tab || 35 || 10 ?};

:: Widok pozycji w kolejce ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
PX_GRP.index('LP');
{? _ver_tmp<>null()
|| PX_GRP.prefix(_ver_tmp)
|| PX_GRP.prefix(_version)
?};
{? _one_ver
|| exec('panel','px_grps');
   exec('actions_set','px_grps');
   exec('dnd','px_grps');
   exec('panel','px_conn');
   exec('actions','px_conn');
   exec('dnd','px_conn')
|| exec('px_grp_tmp','px_grp')
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Komponent sterujacy wymiarami planu - definicje ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
PxSelect.PX_WYM:=tab_tmp(1,'LP','INTEGER','Lp','JM','STRING[10]','Wymiar');
PxSelect.wx_WYM:=PxSelect.PX_WYM.mk_sel('Wymiar'@,,,'wymiarywer');
PxSelect.PX_WYM.win_fld(PxSelect.wx_WYM,,'JM',,,5,,,'jm'@);
PxSelect.PX_WYM.win_act(PxSelect.wx_WYM,,'Rekord',,,,"exec('rekprzed','color','PX_WYM#01#')");
PxSelect.PX_WYM.win_act(PxSelect.wx_WYM,,'Formuła','Legenda'@@,,,"exec('legenda','color','PX_WYM#01#')");
_far:="
   PX_KONT.cntx_psh();
   PX_VAR.SEL_KONT();
   {? PxSelect.PX_WYM.LP<>0
   ||
      PX_VAR.JM:=($('PX_KONT.JM'+$PxSelect.PX_WYM.LP))();
      PxSelect.PX_WK.prefix($PX_KONT.ref());
      {? PxSelect.PX_WK.first()
      || PxSelect.PX_WK.WYMIAR:=PxSelect.PX_WYM.LP;
         PxSelect.PX_WK.put()
      ?};
::    Uwaga: ze wzgledu na narzuty w przetwarzaniu - odswiezanie zakladki pojemnosci mozna wylaczyc, ale ryzykowne
      grp_disp(PX_KONT,{? exec('tree_kont','px_param') || 'PX_WERT' || 'PX_WER' ?},0,1);
::    Uwaga: ze wzgledu na powolnie dzialanie - odswiezanie lepiej wylaczyc dla zakladki obiektow ew. kontenerow
:      grp_disp(PxSelect.Tab_OBJ.TAB,PxSelect.Tab_OBJ.WER,0,1);
:      grp_disp(PxSelect.Tab_KONT.TAB,PxSelect.Tab_KONT.WER,0,1);

::    Podczytuje widok
      PX_VAR.PX_VIEW();
      _offset:=exec('time','#tm_stamp',PX_VIEW.OFFSET);
      _infinity:=exec('infinity_array','px_kont');
      _cap_inf:=_infinity[PxSelect.PX_WK.WYMIAR];
      _prec:=($('PX_KONT.PREC'+$PxSelect.PX_WK.WYMIAR))();
      _il_kol:=exec('il_kol','px_plan');
::    Dla kafelkow na dole musze obliczyc dostepne/zajete pojemnosci
      {! _it:=1.._il_kol
      |! exec('caps_var','px_plan',_it,PX_KONT.ref(),_offset,_prec,_cap_inf)
      !};
      exec('kafelki_reload','px_plan');
      ~~
   ?};
   PX_KONT.cntx_pop();
   ~~
";
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Komponowanie panelow obszaru roboczego - okno grupowe =--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
_before:="
   _one_ver:=exec('is_one_version','px_param');
   _chk_role:=exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPLA');
   _elements:=exec('elements_table_navi','px_plan',_one_ver);
   _simulation:={? exec('mainversion_vie','px_ver') || 0 || 1 ?};

   _whatif:=0;
   {? exec('is_whatif','px_ver',PX_VAR.VIE_VER)>0
   || _whatif:=1;
      _simulation:=0
   ?};
   {? _one_ver>0
   ||
      {? _simulation>0
      ||
::       Jesli wyswietlana wersja nie jest wersja glowna (np przeliczona symulacja),
::       albo użytkownik nie ma roli
::       to znikam caly panel dot. przeliczania w panelu nawigacji
         exec('set_visible_grp','#desktop','','nawigacja','przelicz_one_ver',0,_elements)
      ?};
::    w zależności od tego czy użytkownik nie ma roli - wyłączam przyciski do przeliczania, akceptacji
      {? _chk_role=0 | _simulation>0
      || exec('set_visible_grp','#desktop','','nawigacja','4m7hj5gf3h00459d84nlcj9in707',0,_elements)
      || exec('set_visible_grp','#desktop','','nawigacja','4m7hj5gf3h00459d84nlcj9in707',1,_elements)
      ?};
      {? _chk_role=0 | _simulation>0 | _whatif>0
      || exec('set_visible_grp','#desktop','','nawigacja','btn_whatif@przelicz_one_ver',0,_elements)
      || exec('set_visible_grp','#desktop','','nawigacja','btn_whatif@przelicz_one_ver',1,_elements)
      ?};
      exec('load','#desktop','nawigacja','px_navi_one.dsk',,,,,_elements)
   ||
::    w zależności od tego czy użytkownik nie ma roli - wyłączam przyciski do przeliczania, akceptacji
      {? _chk_role=0
      ||
         exec('set_visible_grp','#desktop','','nawigacja','btn_que_akc@px_navi',0,_elements);
         exec('set_visible_grp','#desktop','','nawigacja','btn_cancel@px_navi',0,_elements);
         exec('set_visible_grp','#desktop','','nawigacja','btn_akc@px_navi',0,_elements)
      || exec('set_visible_grp','#desktop','','nawigacja','btn_que_akc@px_navi',1,_elements);
         exec('set_visible_grp','#desktop','','nawigacja','btn_cancel@px_navi',1,_elements);
         exec('set_visible_grp','#desktop','','nawigacja','btn_akc@px_navi',1,_elements)
      ?};

      exec('set_visible_grp','#desktop','','nawigacja','1337858577279',_chk_role,_elements);

      exec('set_visible_grp','#desktop','','nawigacja','1337953017188',_chk_role,_elements);
      exec('set_visible_grp','#desktop','','nawigacja','1337953216379',_chk_role,_elements);
      exec('set_visible_grp','#desktop','','nawigacja','1337953548168',_chk_role,_elements);
      exec('set_visible_grp','#desktop','','nawigacja','1337953586542',_chk_role,_elements);

      exec('load','#desktop','nawigacja','px_navi.dsk',,,,,_elements)
   ?};
   exec('px_navi_opt','px_task',_one_ver);

:: Ustawiam widok w combobox
   _view:=PX_VAR.PX_VIEW;
   {? _view<>null()
   ||
      _view_sym:=exec('FindAndGet','#table',PX_VIEW,_view,,\"SYMBOL\",'');
      {? _view_sym<>''
      || exec('set_value','#desktop','','nawigacja',PxSelect.ID_VIEW,_view_sym)
      ?}
   || exec('set_enabled','#desktop','','nawigacja',PxSelect.ID_VIEW,0)
   ?};

:: Ustawiam zestaw w combobox
   {? _one_ver
   || {? PX_VAR.PX_SET<>null()
      || exec('set_value','#desktop','','nawigacja',PxSelect.ID_SET,PX_VAR.PX_SET().SYMBOL)
      || exec('set_value','#desktop','','nawigacja',PxSelect.ID_SET,'-- brak --')
      ?}
   ?};

::   exec('debug_string','desktop','','nawigacja',PX_VAR.VIE_VER().SYMBOL);
   ~~
";
_winid:='#workplacegrp0'+$_que_tab;
:: Takie czary, żeby zadziałały tłumaczenia poniżej (teksty MUSZĄ być identyczne)
'Czy zamknąć panel symulacji planu?\n\n'
'• Zawartość wyświetlanej wersji planu (symulacji)\n'
'  nie zostanie zapamiętana.'@;
'Czy zamknąć panel symulacji planu? Nienaniesione zmiany zostaną utracone.'@;
{? exec('is_whatif','px_ver',_version)>0
|| PX_KONT.actions({? exec('tree_kont','px_param') || 'PX_WERT' || 'PX_WER' ?},,'R');
   _winid:='#whatif0'+$_que_tab;
   _close:="
      {? _a='sel_exit'
      || 1
      || FUN.ask(
            'Czy zamknąć panel symulacji planu? Nienaniesione zmiany zostaną utracone.'@
         )
      ?}
   "
|? _edit=-1 & PxSelect.Context='PX'
|| _close:="
      {? _a='sel_exit'
      || 1
      || FUN.ask(
            'Czy zamknąć panel symulacji planu?\n\n'
            '• Zawartość wyświetlanej wersji planu (symulacji)\n'
            '  nie zostanie zapamiętana.'@
         )
      ?}
   "
|| _close:="exec('exit','zws',_a)"
?};

_grp:=PX_KONT.grp_make(_title,_before,_winid,1,1,_close,,,'jterm');
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Glowne okno selekcji planu --==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
_before:="
   PX_VAR.IL_KOL:=exec('il_kol','px_plan');
   grp_disp(PX_OBJ,'WER');
   grp_disp(PX_TAG,'WER');
   {? exec('is_grop','px_param')>0
   ||
      {? PxSelect.Pxgrp.curr_WERT_G<>null()
      || {? PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT_G)=0
         || PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT_G_PREV)=0
         ?}
      ?};
      PX_GRPS.cntx_psh();
      PX_GRP.cntx_psh();
      grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT_G,1);
      PX_GRPS.cntx_pop();
      PX_GRP.cntx_pop()
   ?};
   {? var_pres('curr_WERT',PxSelect.Pxgrp)>0 & PxSelect.Pxgrp.curr_WERT<>null()
   || {? PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT)=0
      || PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT_PREV)
      ?}
   ?};
   PX_GRPS.cntx_psh();
   PX_GRP.cntx_psh();
   grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT,1);
   PX_GRPS.cntx_pop();
   PX_GRP.cntx_pop();
   {? _a>0
   || exec('navi_enable','px_plan',1)
   ?}
";

PX_KONT.grp_sel(_grp,,{? _tree_kont || 'PX_WERT' || 'PX_WER' ?},'Pojemności'@,"exec('after_rfr_poj','px_plan')",,,,_before,,,,'maximized');
_il_kol:=exec('il_kol','px_plan');
{! _it:=1.._il_kol
|! _fi:=$("{? PX_VAR.WAR"+$_it+"='' || '' || exec('ico_fill','px_cup',"+$_it+",PxSelect.PX_WK.WYMIAR,0,1)?}");
   PX_KONT.win_fml({? _tree_kont || 'PX_WERT' || 'PX_WER' ?},PX_VAR,'WAR'+$_it,,'ICON_BEFORE',_fi)
!};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Komponent sterujacy wymiarami planu ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? _que_tab
|| PX_KONT.tab_splt(_grp,,'horizontal','kafelek0',_h_podz);
   PX_KONT.grp_sel(_grp,PxSelect.PX_WYM,PxSelect.wx_WYM,,_far,,,,,,,,'maximized_with_title')
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok szczegolow dla kolumn zestawienia - "kafelki" -==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? _que_tab
|| {! _it:=1.._il_kol
   |! _before:=$('exec(\'kafelek_bf\',\'px_plan\','+$_it+')');
      PX_KONT.tab_splt(_grp,'kafelek'+$(_it-1),'vertical','kafelek'+$_it);
      PX_KONT.grp_sel(_grp,PX_POZ,'KAFELEK'+$_it,,,,,,_before,,,,'maximized_with_title');
      _fi:=$('exec(\'kafelek_ico_fil\',\'px_plan\','+$_it+')');
      PX_POZ.win_fml('KAFELEK'+$_it,PX_VAR,'ICON',,'ICON_BEFORE',_fi)
   !}
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Zaawansowanie przeliczania planu ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? _edit<>0
||
   exec('add','px_task',PX_VAR.VER_QUE);
   PX_TASK.index('PX_VER');
   PX_TASK.prefix(PX_VAR.VER_QUE);
   PX_TASK.first();
   _alert:=exec('get','#params',500355,2);
   {? _alert='T'
   ||
      {? _one_ver>0
      || PX_KONT.timer('sel',_grp,5,"exec('px_navi_opt','px_task',1);~~",1)
      || PX_KONT.timer('sel',_grp,5,"exec('px_navi_opt','px_task',0);~~",1)
      ?}
   || {? _one_ver>0
      || PX_KONT.timer('sel',_grp,5,"exec('px_navi_opt','px_task',1);~~",1)
      ?}
   ?}
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Zakladka z widokiem drzewa agregowanym wg obiektow --==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
_dnd:=1;
{? PxSelect.Context*'ZL'>0 | PxSelect.Context*'ZAM'>0 | ~exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPLA')
||
:: Dla symulacji zlecenia/zamowienia wylaczamy d'n'd
   _dnd:=0
?};

PxSelect.Tab_OBJ:=exec('select_obj','px_plan','PxSelect.Tab_OBJ',1,_dnd);
PX_VAR.IL_KOL:=exec('il_kol_wide','px_plan');
_before:="
   PX_VAR.IL_KOL:=exec('il_kol_wide','px_plan');
   {? _a>0
   || exec('navi_enable','px_plan',1)
   ?};
   {! _it:=1..PX_VAR.IL_KOL
   |!
      _war:=($('PX_VAR.TIT'+$_it))();
      cur_tab(1,1).fld_opt(cur_win(1,1),'col_name=%1'[_war],PX_VAR,'WAR'+$_it);
      _help:=exec('col_help','px_plan',_it);
      cur_tab(1,1).fld_opt(cur_win(1,1),'col_help=%1'[_help],PX_VAR,'WAR'+$_it)
   !};
   ~~
";
_used_obj:="exec('obj_find_used','px_obj',PX_VAR.VIE_VER,PX_VAR.PX_SET)";
PxSelect.Tab_OBJ.load(_used_obj,0,0);
PX_KONT.grp_sel(_grp,PxSelect.Tab_OBJ.TAB,PxSelect.Tab_OBJ.WER,'Obiekty'@,"exec('after_rfr_obj','px_plan')",,,,_before,,,,'maximized');
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Komponent sterujacy wymiarami planu ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? _que_tab
|| PX_KONT.tab_splt(_grp,,'horizontal','kafelek0',_h_podz);
   PX_KONT.grp_sel(_grp,PxSelect.PX_WYM,PxSelect.wx_WYM,,_far,,,,,,,,'maximized_with_title')
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok szczegolow dla kolumn zestawienia - "kafelki" -==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? _que_tab
|| _width:=28;
   {! _it:=1.._il_kol
   |!
      _before:=$('exec(\'kafelek_bf\',\'px_plan\','+$_it+')');
      PX_KONT.tab_splt(_grp,'kafelek'+$(_it-1),'vertical','kafelek'+$_it);
      PX_KONT.grp_sel(_grp,PX_POZ,'KAFELEK'+$_it,,,,,,_before,,,,'maximized_with_title');
      _fi:=$('exec(\'kafelek_ico_fil\',\'px_plan\','+$_it+')');
      PX_POZ.win_fml('KAFELEK'+$_it,PX_VAR,'ICON',,'ICON_BEFORE',_fi)
   !}
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Zakladka z widokiem drzewa agregowanym wg kontenerow ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
:: UWAGA: zakladka musi byc ladowana po zakladce z obiektami, zeby ustawiac date() a nie poczatek ostatniego obiektu
PxSelect.Tab_KONT:=exec('select_kont','px_plan','PxSelect.Tab_KONT',1,_dnd);
PX_VAR.IL_KOL:=exec('il_kol_wide','px_plan');
_before:="
   PX_VAR.IL_KOL:=exec('il_kol_wide','px_plan');
   {? _a>0
   || exec('navi_enable','px_plan',1)
   ?};
   {! _it:=1..PX_VAR.IL_KOL
   |!
      _war:=($('PX_VAR.TIT'+$_it))();
      cur_tab(1,1).fld_opt(cur_win(1,1),'col_name=%1'[_war],PX_VAR,'WAR'+$_it);
      _help:=exec('col_help','px_plan',_it);
      cur_tab(1,1).fld_opt(cur_win(1,1),'col_help=%1'[_help],PX_VAR,'WAR'+$_it)
   !};
   ~~
";
_used_kont:="exec('kont_find_all','px_kont')";
PxSelect.Tab_KONT.load(_used_kont,0,0);
PX_KONT.grp_sel(_grp,PxSelect.Tab_KONT.TAB,PxSelect.Tab_KONT.WER,'Zasoby'@,"exec('after_rfr_zas','px_plan')",,,,_before,,,,'maximized');
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Komponent sterujacy wymiarami planu ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? _que_tab
|| PX_KONT.tab_splt(_grp,,'horizontal','kafelek0',_h_podz);
   PX_KONT.grp_sel(_grp,PxSelect.PX_WYM,PxSelect.wx_WYM,,_far,,,,,,,,'maximized_with_title')
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok szczegolow dla kolumn zestawienia - "kafelki" -==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? _que_tab
|| _width:=28;
   {! _it:=1.._il_kol
   |!
      _before:=$('exec(\'kafelek_bf\',\'px_plan\','+$_it+')');
      PX_KONT.tab_splt(_grp,'kafelek'+$(_it-1),'vertical','kafelek'+$_it);
      PX_KONT.grp_sel(_grp,PX_POZ,'KAFELEK'+$_it,,,,,,_before,,,,'maximized_with_title');
      _fi:=$('exec(\'kafelek_ico_fil\',\'px_plan\','+$_it+')');
      PX_POZ.win_fml('KAFELEK'+$_it,PX_VAR,'ICON',,'ICON_BEFORE',_fi)
   !}
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Zakladka z kolejka i obiektami do planowania ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? _que_tab
||
:: Widok pozycji w kolejce ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
   _tab_name:='Kolejka'@;
   {? exec('is_grop','px_param')>0
   ||
::    Jeżeli planowanie grup operacji to na samej górze dodatkowa kolejka dla grup
      _after_rfr:="

      ";
      _before:="

         {? _a
         || PX_VAR.SEL_KONT:=null();
            exec('after_rfr_wym','px_plan',null());
            exec('kafelki_reload','px_plan');
            exec('navi_enable','px_plan',0)
         ?};
         PX_GRPS.index('LP1');
         PX_GRPS.prefix('T',PX_VAR.VIE_VER,PX_VAR.PX_SET,'G');
         {? PxSelect.Pxgrp.curr_WERT_G<>null()
         || {? PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT_G)=0
            || PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT_G_PREV)
            ?}
         ?};
         ~~
      ";
      PX_KONT.grp_sel(_grp,PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT_G,_tab_name,_after_rfr,,,,_before,,,,'maximized_with_title');
      _tab_name:='';

::    Widok obiektow do kolejki =--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
      exec('win_px_obj','px_plan',_grp);
      PX_KONT.tab_splt(_grp,'tab0','horizontal','kolejka_dol',12);
      ~~
   ?};
   _after_rfr:="

      {? exec('is_one_version','px_param')
      ||
         PX_CONN.index('PX_GRP');
         PX_CONN.prefix(PX_GRPS.PX_GRP);
         PX_CONN.first();

         PX_OBJ.cntx_psh();
         {? type_of(PxSelect.Pxconn)>0 & var_pres('WER',PxSelect.Pxconn)>0
         || grp_disp(PX_CONN,PxSelect.Pxconn.WER)
         ?};
         PX_OBJ.cntx_pop()
      ?};
      grp_disp(PX_OBJ,'WER',,0)
   ";
   _before:="
      {? _a
      || PX_VAR.SEL_KONT:=null();
         exec('after_rfr_wym','px_plan',null());
         exec('kafelki_reload','px_plan');
         exec('navi_enable','px_plan',0)
      ?};
      PX_GRPS.index('LP1');
      PX_GRPS.prefix('T',PX_VAR.VIE_VER,PX_VAR.PX_SET,'Z');
      {? var_pres('curr_WERT',PxSelect.Pxgrp)>0 & PxSelect.Pxgrp.curr_WERT<>null()
      || {? PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT)=0
         || PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT_PREV)
         ?}
      ?};
      ~~
   ";
   PX_KONT.grp_sel(_grp,PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT,_tab_name,_after_rfr,,,,_before,,,,'maximized_with_title');

   {? exec('is_grop','px_param')=0
   ||
::    Widok obiektow do kolejki =--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
      exec('win_px_obj','px_plan',_grp)
   ?};
   PX_OBJ.win_fml('WER',PX_OBJ,'SYMBOL',,'ICON_BEFORE',"exec('icon_symbol','px_obj')");
   PX_OBJ.clear();

   _px_obj_filter:=exec('get','#params',8064,type_of(''),OPERATOR.USER);
   {? _px_obj_filter<>''
   || exec('px_obj_run_filter','px_obj',_px_obj_filter)
   || exec('filter_all_act','px_obj')
   ?};

   PX_OBJ.f_first();
   _hid_act:='';
   {? PX_VAR.EDIT=0
   || _hid_act+='U'
   ?};
   {? PX_VAR.EDIT_QUE=0
   || _hid_act+='D'
   ?};
   {? ~_one_ver
   || _hid_act+='E'
   || ''
   ?};
   {? ~exec('mainversion_vie','px_ver') || _hid_act+='TE' ?};

   PX_OBJ.actions('WER',_hid_act);

:: Widok polaczen grupujacych --==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
   {? _one_ver
   || _panel:='tab0';
      {? exec('is_grop','px_param')>0
      || _panel:='kolejka_dol'
      ?};
      PX_KONT.tab_splt(_grp,_panel,'horizontal','poz_kolejki',12);
      _fb:="
      ";
      _fa:="
      ";
      PX_KONT.grp_sel(_grp,PX_CONN,PxSelect.Pxconn.WER,,,,,2,_fb,_fa,,,'maximized_with_title')
   ?}
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok opoznionych pozycji planu ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? _que_tab
||
:: PX_KONT.grp_splt(_grp,'obiekty','vertical','opoznione');
   PxSelect.wx_POZ:=PX_POZ.mk_sel('Opóźnione pozycje'@,,,'pxpozwer',,,,,'U');
   PX_POZ.win_fld(PxSelect.wx_POZ,PX_OBJ,'KOLOR',,,2,,,' ');
   PX_POZ.win_fld(PxSelect.wx_POZ,PX_POZ,'PX_OBJ','SYMBOL',,30,,,'Obiekt'@);
   PX_POZ.win_fld(PxSelect.wx_POZ,PX_POZ,'PX_KONT','SYMBOL',,30,,,'Zasób'@);
   PX_POZ.win_fld(PxSelect.wx_POZ,PX_CUP,'STARTD','DATA',,,,,'Od'@);
   PX_POZ.win_fld(PxSelect.wx_POZ,PX_CUP,'STARTT',,,,,,,1);
   PX_POZ.win_fld(PxSelect.wx_POZ,PX_CUP,'ENDD','DATA',,,,,'Do'@);
   PX_POZ.win_fld(PxSelect.wx_POZ,PX_CUP,'ENDT',,,,,,,1);
   PX_POZ.win_act(PxSelect.wx_POZ,,'Formuła','Zmień status'@@,,,"exec('status_delay_del','px_poz')",,,1,"exec('status_delay_del_gr1','px_poz')","exec('status_delay_del_gr2','px_poz')");
   PX_POZ.win_act(PxSelect.wx_POZ,,'Formuła','Legenda'@@,,,"exec('px_poz_op_leg','px_poz')");
   PX_POZ.win_act(PxSelect.wx_POZ,,'Rekord',,,,"exec('px_poz_op_rkprz','px_poz')");
   PX_POZ.win_act(PxSelect.wx_POZ,,'Wyświetl',,,,"exec('px_poz_op_disp','px_poz')");
   _ico:="'xwin16.png:'+$exec('ikona_res','po_plan',PX_KONT.PL_RES().TYP)";
   PX_POZ.win_fml(PxSelect.wx_POZ,PX_POZ,'PX_KONT','SYMBOL','ICON_BEFORE',_ico);
   _before:="
      PX_POZ.index('VSTATUS');
      {? exec('is_px_set','px_param')>0 & PX_VAR.PX_SET<>null()
      || PX_POZ.prefix(PX_VAR.VIE_VER,exec('status_delay','px_poz'),PX_VAR.PX_SET)
      || PX_POZ.prefix(PX_VAR.VIE_VER,exec('status_delay','px_poz'))
      ?};
      {? _a
      || PX_VAR.SEL_KONT:=null();
         exec('after_rfr_wym','px_plan',null());
         exec('navi_enable','px_plan',0)
      ?}
   ";
   PX_KONT.grp_sel(_grp,PX_POZ,PxSelect.wx_POZ,'Opóźnione pozycje'@,,,,,_before,,,,'maximized')
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok przepisow planistycznych --==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? _que_tab &
   (exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_PPPL') | exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPPL'))
|| _ar:="exec('grayed','px_tex','WER4GRP')";
   _before:="
      {? _a
      || PX_VAR.SEL_KONT:=null();
         exec('after_rfr_wym','px_plan',null());
         exec('kafelki_reload','px_plan');
         exec('navi_enable','px_plan',0)
      ?}
   ";
   PX_KONT.grp_sel(_grp,PX_TEX,'WER4GRP','Przepisy planistyczne'@,_ar,,,,_before,,,,'maximized')
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok komunikatow do wersji planu =--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? _que_tab
|| _before:="
      PX_KOMM.index('PX_VER');
      PX_KOMM.prefix(PX_VAR.VIE_VER);
      {? _a
      || PX_VAR.SEL_KONT:=null();
         exec('after_rfr_wym','px_plan',null());
         exec('kafelki_reload','px_plan');
         exec('navi_enable','px_plan',0)
      ?}
   ";
   PX_KONT.grp_sel(_grp,PX_KOMM,'WER','Komunikaty'@,,,,,_before,,,,'maximized')
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Panel nawigacyjny =--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
PX_KONT.grp_splt(_grp,,'horizontal','nawigacja',_h_nav);
PxSelect.PX_NAVI:=exec('create','#desktop',PX_KONT,'nawigacja',_grp,2);

:: dnd test
::exec('dnd_install','desktop',PX_KONT,PxSelect.PX_NAVI,'nawigacja','records.PX_POZ');

::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Komponent sterujacy wymiarami planu ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? ~_que_tab
|| PX_KONT.grp_splt(_grp,,'horizontal','kafelek0',_h_podz);
   PX_KONT.grp_sel(_grp,PxSelect.PX_WYM,PxSelect.wx_WYM,,_far,,,,,,,,'maximized_with_title')
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok szczegolow dla kolumn zestawienia - "kafelki" -==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? ~_que_tab
|| {! _it:=1.._il_kol
   |! _before:=$('exec(\'kafelek_bf\',\'px_plan\','+$_it+')');
      PX_KONT.grp_splt(_grp,'kafelek'+$(_it-1),'vertical','kafelek'+$_it);
      PX_KONT.grp_sel(_grp,PX_POZ,'KAFELEK'+$_it,,,,,,_before,,,,'maximized_with_title');
      _fi:=$('exec(\'kafelek_ico_fil\',\'px_plan\','+$_it+')');
      PX_POZ.win_fml('KAFELEK'+$_it,PX_VAR,'ICON',,'ICON_BEFORE',_fi)
   !}
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok pozycji w kolejce ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
_panel_kolejki:='kolejki';
{? ~_que_tab
|| PX_KONT.grp_splt(_grp,,'horizontal','kolejki',25);
   {? _one_ver
   ||
      {? exec('is_grop','px_param')>0
      ||
         _after_rfr:="
            PX_GRPS.actions(cur_win(1,1),'CF(DGL):',,1);
            ~~
         ";
         _before:="
            PX_GRPS.index('LP1');
            PX_GRPS.prefix('T',PX_VAR.VIE_VER,PX_VAR.PX_SET,'G');
            {? PxSelect.Pxgrp.curr_WERT_G<>null()
            || {? PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT_G)=0
               || PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT_G_PREV)
               ?}
            ?};
            ~~
         ";
         PX_KONT.grp_sel(_grp,PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT_G,,_after_rfr,,,,_before,,,,'maximized_with_title');
         ~~
      ||
         _after_rfr:="

            {? exec('is_one_version','px_param')
            ||
               PX_CONN.index('PX_GRP');
               PX_CONN.prefix(PX_GRPS.PX_GRP);
               PX_CONN.first();

               PX_OBJ.cntx_psh();
               {? type_of(PxSelect.Pxconn)>0 & var_pres('WER',PxSelect.Pxconn)>0
               || grp_disp(PX_CONN,PxSelect.Pxconn.WER)
               ?};
               PX_OBJ.cntx_pop()
            ?};
            grp_disp(PX_OBJ,'WER',,0)
         ";
         _fb:="
            PX_GRPS.index('LP1');
            PX_GRPS.prefix('T',PX_VAR.VIE_VER,PX_VAR.PX_SET,'Z');
            {? var_pres('curr_WERT',PxSelect.Pxgrp)>0 & PxSelect.Pxgrp.curr_WERT<>null()
            || {? PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT)=0
               || PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT_PREV)
               ?}
            ?};
            ~~
         ";
         PX_KONT.grp_sel(_grp,PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT,,_after_rfr,,,,_fb,,,,'maximized_with_title')
      ?}
   || _after_rfr:="
         grp_disp(PX_OBJ,'WER',,0)
      ";
      PX_KONT.grp_sel(_grp,PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT,,_after_rfr,,,,,,,,'maximized_with_title')
   ?}
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

{? ~_que_tab
|| PX_KONT.grp_splt(_grp,'kolejki','vertical','obiekty')
::   PxSelect.OBJ_FIND:=exec('create','#desktop',PX_KONT,'obj_find',_grp,2,,,'Obiekty do kolejki')
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok obiektow do kolejki =--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? ~_que_tab
||
::   PX_KONT.tab_splt(_grp,'tab0','horizontal','obj_find');
   _fb:="
      _activate:=_a;
      {? _activate>0
      || PxSelect.CUR_TAB:='PX_OBJ'
      ?};

      {? PxSelect.OBJ_sdel
      || PX_OBJ.sel_adel()
      ?};
      {? _activate>0
      ||
         PX_VAR.PX_TAG:=null();
         _px_obj_filter:=exec('get','#params',8064,type_of(''),OPERATOR.USER);
         {? _px_obj_filter<>''
         || exec('px_obj_run_filter','px_obj',_px_obj_filter)
         || exec('filter_all_act','px_obj')
         ?}
      ?};
      ~~
   ";
   _fa:="
      {? var_pres('OBJ_sget',PxSelect)>100 || obj_del(PxSelect.OBJ_sget) ?};
      PxSelect.OBJ_sdel:=0;
      PxSelect.OBJ_sget:=PX_OBJ.sel_aget()
   ";
   PX_KONT.grp_sel(_grp,PX_OBJ,'WER','Obiekty do kolejki'@,,,,,_fb,_fa,,,'maximized');
   PX_OBJ.win_fml('WER',PX_OBJ,'SYMBOL',,'ICON_BEFORE',"exec('icon_symbol','px_obj')");
   PX_OBJ.clear();
   _px_obj_filter:=exec('get','#params',8064,type_of(''),OPERATOR.USER);
   {? _px_obj_filter<>''
   || exec('px_obj_run_filter','px_obj',_px_obj_filter)
   || exec('filter_all_act','px_obj')
   ?};
   PX_OBJ.f_first();
   _hid_act:='';
   {? PX_VAR.EDIT=0
   || _hid_act+='U'
   ?};
   {? PX_VAR.EDIT_QUE=0
   || _hid_act+='D'
   ?};
   {? ~_one_ver
   || _hid_act+='E'
   || ''
   ?};
   {? ~exec('mainversion_vie','px_ver') || _hid_act+='TE' ?};

   PX_OBJ.actions('WER',_hid_act);
   ~~
?};

:: Widok zgrupowanych obiektów =--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? ~_que_tab
||
   _fb:="
      _activate:=_a;
      {? _activate>0
      || PxSelect.CUR_TAB:='PX_TAG'
      ?};
      ~~
   ";
   _fa:="
      ~~
   ";
   _after_rfr:="
      exec('after_refresh','px_tag');
      grp_disp(PX_OBJ,'WYK',1);
      ~~
   ";
   PX_KONT.grp_sel(_grp,PX_TAG,'WER','Grupy obiektów do kolejki'@,_after_rfr,,,,_fb,_fa,,,'maximized','px_tag_wer');
   PX_TAG.win_fml('WER',PX_TAG,'ID',,'ICON_BEFORE',"exec('icon_id','px_tag')");
   PX_TAG.index('KIND');
   PX_TAG.prefix('N',);
   _hid_act:='';
   {? PX_VAR.EDIT=0
   || _hid_act+='U'
   ?};
   {? PX_VAR.EDIT_QUE=0
   || _hid_act+='D'
   ?};
   PX_TAG.actions('WER',_hid_act);

   PX_KONT.tab_splt(_grp,,'horizontal','px_grp_obj');

   _fb:="
      _result:=~~;
      {? grp_empty('px_tag_wer','WER',1,)>0
      || _result:='#disable'
      ?};
      _result
   ";
   _fa:="
      ~~
   ";
   PX_KONT.grp_sel(_grp,PX_OBJ,'WYK',,,,,,_fb,_fa,,,'maximized');
   ~~
?};

::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok opoznionych pozycji planu ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? ~_que_tab
||
:: PX_KONT.grp_splt(_grp,'obiekty','vertical','opoznione');
   PxSelect.wx_POZ:=PX_POZ.mk_sel('Opóźnione pozycje'@,,,'pxpozwer',,,,,'U');
   PX_POZ.win_fld(PxSelect.wx_POZ,PX_OBJ,'KOLOR',,,2,,,' ');
   PX_POZ.win_fld(PxSelect.wx_POZ,PX_POZ,'PX_OBJ','SYMBOL',,30,,,'Obiekt'@);
   PX_POZ.win_fld(PxSelect.wx_POZ,PX_POZ,'PX_KONT','SYMBOL',,30,,,'Zasób'@);
   PX_POZ.win_fld(PxSelect.wx_POZ,PX_CUP,'STARTD','DATA',,,,,'Od'@);
   PX_POZ.win_fld(PxSelect.wx_POZ,PX_CUP,'STARTT',,,,,,,1);
   PX_POZ.win_fld(PxSelect.wx_POZ,PX_CUP,'ENDD','DATA',,,,,'Do'@);
   PX_POZ.win_fld(PxSelect.wx_POZ,PX_CUP,'ENDT',,,,,,,1);
   PX_POZ.win_act(PxSelect.wx_POZ,,'Formuła','Zmień status'@@,,,"exec('status_delay_del','px_poz')",,,1,"exec('status_delay_del_gr1','px_poz')","exec('status_delay_del_gr2','px_poz')");
   PX_POZ.win_act(PxSelect.wx_POZ,,'Formuła','Legenda'@@,,,"exec('px_poz_op_leg','px_poz')");
   PX_POZ.win_act(PxSelect.wx_POZ,,'Rekord',,,,"exec('px_poz_op_rkprz','px_poz')");
   PX_POZ.win_act(PxSelect.wx_POZ,,'Wyświetl',,,,"exec('px_poz_op_disp','px_poz')");
   _ico:="'xwin16.png:'+$exec('ikona_res','po_plan',PX_KONT.PL_RES().TYP)";
   PX_POZ.win_fml(PxSelect.wx_POZ,PX_POZ,'PX_KONT','SYMBOL','ICON_BEFORE',_ico);
   _before:="
      _activate:=_a;
      {? _activate>0
      || PxSelect.CUR_TAB:='PX_DELAYS'
      ?};
      PX_POZ.index('VSTATUS');
      {? exec('is_px_set','px_param')>0 & PX_VAR.PX_SET<>null()
      || PX_POZ.prefix(PX_VAR.VIE_VER,exec('status_delay','px_poz'),PX_VAR.PX_SET)
      || PX_POZ.prefix(PX_VAR.VIE_VER,exec('status_delay','px_poz'))
      ?}
   ";
   PX_KONT.grp_sel(_grp,PX_POZ,PxSelect.wx_POZ,'Opóźnione pozycje'@,,,,,_before,,,,'maximized')
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok przepisow planistycznych --==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? ~_que_tab &
   (exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_PPPL') | exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPPL'))
|| _ar:="exec('grayed','px_tex','WER4GRP')";
   _before:="
      _activate:=_a;
      {? _activate>0
      || PxSelect.CUR_TAB:='PX_TEX'
      ?};
      ~~
   ";
   PX_KONT.grp_sel(_grp,PX_TEX,'WER4GRP','Przepisy planistyczne'@,_ar,,,,_before,,,,'maximized')
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok komunikatow do wersji planu =--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? ~_que_tab
|| _before:="
      _activate:=_a;
      {? _activate>0
      || PxSelect.CUR_TAB:='PX_KOMM'
      ?};

      PX_KOMM.index('PX_VER');
      PX_KOMM.prefix(PX_VAR.VIE_VER)
   ";
   PX_KONT.grp_sel(_grp,PX_KOMM,'WER','Komunikaty'@,,,,,_before,,,,'maximized')
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok kolejki jeżeli jest włączone planowanie grup operacji
{? ~_que_tab & _one_ver & exec('is_grop','px_param')
||
   PX_KONT.grp_splt(_grp,_panel_kolejki,'horizontal','kolejki_dol');
   _panel_kolejki:='kolejki_dol';
   _after_rfr:="
      {? exec('is_one_version','px_param')
      ||
         PX_CONN.index('PX_GRP');
         PX_CONN.prefix(PX_GRPS.PX_GRP);
         PX_CONN.first();

         PX_OBJ.cntx_psh();
         {? type_of(PxSelect.Pxconn)>0 & var_pres('WER',PxSelect.Pxconn)>0
         || grp_disp(PX_CONN,PxSelect.Pxconn.WER)
         ?};
         PX_OBJ.cntx_pop()
      ?};
      grp_disp(PX_OBJ,'WER',,0)
   ";
   _fb:="
      PX_GRPS.index('LP1');
      PX_GRPS.prefix('T',PX_VAR.VIE_VER,PX_VAR.PX_SET,'Z');
      {? var_pres('curr_WERT',PxSelect.Pxgrp)>0 & PxSelect.Pxgrp.curr_WERT<>null()
      || PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT)
      ?};
      ~~
   ";
   PX_KONT.grp_sel(_grp,PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT,,_after_rfr,,,,_fb,,,,'maximized_with_title')
?};

:: Widok polaczen grupujacych --==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? ~_que_tab & _one_ver
|| PX_KONT.grp_splt(_grp,_panel_kolejki,'horizontal','poz_kolejki');
   _fb:="
      {? _a
      || {? var_pres('curr_WERT',PxSelect.Pxgrp)>0 & PxSelect.Pxgrp.curr_WERT<>null()
         || PX_GRPS.cntx_psh();
            PX_GRP.cntx_psh();
            PX_GRPS.prefix();
            {? PX_GRPS.seek(PxSelect.Pxgrp.curr_WERT)
            || exec('px_grp_bre','px_grp',,,PX_GRP)
            ?};
            PX_GRPS.cntx_pop();
            PX_GRP.cntx_pop()
         ?}
      ?}
   ";
   PX_KONT.grp_sel(_grp,PX_CONN,PxSelect.Pxconn.WER,,,,,5,_fb,,,,'maximized_with_title')
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: przywrocenie ilosci kolumn dla kafelkow, bo funkcje load() widoku szczegolowego moga ja zmienic
PX_VAR.IL_KOL:=exec('il_kol','px_plan');

exec('dnd_init','px_plan');

PX_KONT.win_sel(_grp);
PX_KONT.win_edit('DISP');

{? _context='PX' & exec('mainversion_vie','px_ver')
|| AreaTitle.setTabWin(PX_KONT,_grp);
   AreaTitle.setTitle()
?};

:: wyswietlenie obszaru roboczego
{? _tree_kont
|| PX_KONT.index('ACTT');
   PX_KONT.prefix('T',_version)
|? PX_VAR.PX_SET=null()
|| PX_KONT.index('ACT');
   PX_KONT.prefix('T',_version)
|| PX_KONT.index('ACTS');
   PX_KONT.prefix('T',_version,PX_VAR.PX_SET)
?};
_result:=PX_KONT.select();

PX_KONT.win_edit();
PX_KONT.win_sel();
PX_KONT.win_del(_grp);

:: Odblokowuje widok planu
exec('unlock','px_view',PX_VAR.PX_VIEW);

:: Odblokowuje zestaw planistyczny
exec('unlock','px_set',PX_VAR.PX_SET);

:: Przywracanie kontekstów
PxSelect.restore();

:: Kasowanie obiektow
_delete();

:: przy zamykaniu okna usuwam wersje tymczasowa planu o ile nie zostala przeliczona
{? PX_VAR.VER_QUE<>null()
|| PX_VER.cntx_psh();
   {? PX_VER.seek(PX_VAR.VER_QUE)
   || {? PX_VER.STATUS=exec('status_temp','px_ver')
      || exec('delete','px_ver',PX_VAR.VER_QUE,0)
      ?}
   ?};
   PX_VER.cntx_pop();
:: po wychodzeniu z okna odblokowuje wersje tymczasowa
   {? _one_ver=0
   || exec('unlock','px_ver',PX_VAR.VER_QUE)
   ?}
?};
_result


\px_kont_rkprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed rekord w oknie PX_KONT.PX_WER, PX_KONT.PX_WERT
::----------------------------------------------------------------------------------------------------------------------
exec('rekprzed','color','PX_KONT#01#')


\px_kont_bre
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wlasciwa obsluga przed rekord w oknie PX_KONT.PX_WER, PX_KONT.PX_WERT
::----------------------------------------------------------------------------------------------------------------------

_il_kol:=exec('il_kol','px_plan');
:: Dodanie rekordu okreslajacego wybrany wymiar dla kontenera (domyslnie 1.)
PxSelect.PX_WK.prefix($PX_KONT.ref());
{? ~PxSelect.PX_WK.first()
||
   PxSelect.PX_WK.KONTENER:=$PX_KONT.ref();
   PxSelect.PX_WK.WYMIAR:=1;
   PxSelect.PX_WK.add()
?};

:: Wybrany wymiar okresla aktywna jednostke miary
PX_VAR.JM:=($('PX_KONT.JM'+$PxSelect.PX_WK.WYMIAR))();

:: Utworzenie tabelki z jednostkami miary dla wymiarow i jej wyswietlenie
PX_VAR.IL_WYM:=PX_KONT.IL_WYM;
PxSelect.PX_WYM.erase();
{! _it:=1..PX_KONT.IL_WYM
|! PxSelect.PX_WYM.LP:=_it;
   PxSelect.PX_WYM.JM:=($('PX_KONT.JM'+$_it+'().KOD'))();
   PxSelect.PX_WYM.add()
!};

:: Skoczyc do zapamietanej pozycji
{? PxSelect.Context*'|WIN'=0
|| PxSelect.PX_WYM.find_key(PxSelect.PX_WK.WYMIAR);
   win_set('cur_row_pos='+$PxSelect.PX_WK.WYMIAR,PxSelect.PX_WYM,PxSelect.wx_WYM)
?};

{? PxSelect.Context*'|WIN'=0
|| grp_disp(PxSelect.PX_WYM,PxSelect.wx_WYM)
?};

:: Ustawienie wyswietlania w gornej czesci okna - pojemniki widokowe
::    czyszcze wartosci celi
{! _it:=1.._il_kol |! ($('PX_VAR.WAR'+$_it))():='' !};

PX_CUP.cntx_psh();
PX_CUP.index('TM_END');
{? PX_VAR.VIE_DATE<>null() & PX_VAR.PX_VIEW<>null()
||
:: Podczytuje rekord dat i widoku
   PX_VAR.VIE_DATE();
   PX_VAR.PX_VIEW();
   _it:=1;
   _offset:=exec('time','#tm_stamp',PX_VIEW.OFFSET);
   _infinity:=exec('infinity_array','px_kont');
   _cap_inf:=_infinity[PxSelect.PX_WK.WYMIAR];
   _prec:=($('PX_KONT.PREC'+$PxSelect.PX_WK.WYMIAR))();
   {!
   |?
::    Dla aktualnej kolumny widoku obliczam zajmowane, dostepne pojemnosci
      exec('caps_var','px_plan',_it,PX_KONT.ref(),_offset,_prec,_cap_inf,1);

::    ustawiam wyszarzenie dla komorki, jezeli pojemnik widokowy bez rzeczywistego, wpp kolor pojemnika
::      {? PX_CUP.UID_PAR=''
::      || ($('PX_VAR.KOL'+$_it))():=exec('color_noavail','px_param')
::      || ($('PX_VAR.KOL'+$_it))():=PX_CUP.KOLOR
::      ?};
      _it+=1;
      _it<=_il_kol
   !};
:: jak cos jeszcze zostalo (koncowka planu, nie mam juz pojemnikow), to wyszarzamy
   {! _it1:=_it+1.._il_kol
   |! ($('PX_VAR.KOL'+$_it1))():=exec('color_noavail','px_param')
   !};
   ~~
||
:: Brak widoku, albo nieustawiona data - wszystko wyszarzone
   {! _it:=1.._il_kol
   |! ($('PX_VAR.KOL'+$_it))():=exec('color_noavail','px_param')
   !};
   ~~
?};
PX_CUP.cntx_pop();

:: Kolorowanie - jezeli kopia/symulacja to inny kolor tla
{? PX_KONT.PX_VER=PX_VAR.MAINVER || '' || 'PX_KONT#01#01' ?}


\caps_var
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Wypelnia zmienna PX_VAR wartosciami dot. pojemnosci w pojemnikach
::       KONTEKST PRACY -  wypelnione pola PX_VAR.DATYxx
::                         PX_VIEW - aktualny widok planu
::   WE: _a - INTEGER - numer kolumny
::       _b - PX_KONT.ref()
::       _c - REAL - tm_stamp - przesuniecie widoku
::       _d - REAL - precyzja na kontenerze w aktualnie wybranym wymiarze
::       _e - INTEFER - 0/1 - czy altualnie wybrany wymiar jest nieskonczony
::       [_f] - INTEGER - [0]/1  - czy ustawiac kolory na podstawie wartosci pojemnosci
::       [_g] - INTEGER -  0/[1] - czy ustawiac zmienna PX_VAR.WARxx widoczna w kolumnach na
::                                 zakladce 'Pojemnosci'
::----------------------------------------------------------------------------------------------------------------------
_it:=_a;
_px_kont:=_b;
_offset:=_c;
_prec:=_d;
_cap_inf:=_e;
_colorize:=0;

{? var_pres('_f')=type_of(0)
|| _colorize:=_f
?};

_pojwars:=1;
{? var_pres('_g')=type_of(0)
|| _pojwars:=_g
?};

_cap_max:=0;
_cap_use:=0;
_cap_min:=0;
($('PX_VAR.KOL'+$_it))():=exec('flddisp','color','PX_CUP#01#04');

:: Pobieram daty w kolumnie biezacej i nastepnej
_daty1:=($('PX_VAR.DATY'+$_it))();
_daty2:=($('PX_VAR.DATY'+$(_it+1)))();

:: Tworze interwal czasowy z dat
_int_daty:=exec('create_interval','daty',_daty1,_daty2,_offset);
_dur_daty:=exec('interval_dur','#interval',_int_daty);
_cups:=0;
PX_CUP.cntx_psh();
PX_CUP.index('TM_END');
PX_CUP.prefix(_px_kont);
{? PX_CUP.find_ge(_int_daty.START)
||
   {? PX_CUP.TM_START<_int_daty.END
   ||
      {!
      |?
         {? PX_CUP.TM_END>_int_daty.START
         ||
::          Iteruje po pojemnikach ktore przecinaja interwal widokowy

::          Tworze interwal pojemnikowy
            {? var_pres('_int_cup')>100
            || obj_del(_int_cup)
            ?};
            _int_cup:=exec('interval','#interval');
            _int_cup.START:=PX_CUP.TM_START;
            _int_cup.END:=PX_CUP.TM_END;
            _dur_cup:=exec('interval_dur','#interval',_int_cup);

::          Wyznaczam czesc wspolna wyswietlanego interwalu i interwalu pojemnika
            {? var_pres('_int_and')>100
            || obj_del(_int_and)
            ?};
            _int_and:=exec('intervals_and','#interval',_int_daty,_int_cup);
            _dur_and:=exec('interval_dur','#interval',_int_and);

            {? _dur_and>0
            ||
::             Obliczam proporcje czasu trwania
               _prop:=1;
               {? _dur_daty<_dur_and
               ||
::                Okres czasu wyswietlany jest mniejszy niz czas pojemnika
                  _prop:=_dur_daty/_dur_and
               ||
::                Okres czasy wyswietlany wiekszy niz czas pojemnika
                  _prop:=_dur_and/_dur_cup
               ?};
               _max:=($('PX_CUP.CAP_MAX'+$PxSelect.PX_WK.WYMIAR+'*_a'))(_prop);
               _min:=($('PX_CUP.CAP_MIN'+$PxSelect.PX_WK.WYMIAR+'*_a'))(_prop);
               _use:=($('PX_CUP.CAP_USE'+$PxSelect.PX_WK.WYMIAR+'*_a'))(_prop);
               _cap_max+=_max;
               _cap_min+=_min;
               _cap_use+=_use;
               _cups+=1
            ?}
         ?};
         PX_CUP.next() & PX_CUP.TM_START<_int_daty.END
      !}
   ?}
?};
PX_CUP.cntx_pop();
{? _cups=0
||
:: Nie bylo zadnych pojemnikow, wyszarzam kolumne
   ($('PX_VAR.KOL'+$_it))():=exec('color_noavail','px_param');
   ~~
?};
_infinity:=exec('infinity_array','px_kont');
_inf:=_infinity[PxSelect.PX_WK.WYMIAR];

_main:='';
_sim_diff:=0;
{? exec('is_whatif','px_ver',PX_KONT.PX_VER)>0
|| PX_KONT.cntx_psh();
   PX_KONT.index('UID');
   {? PX_KONT.UID_SRC<>''
   || PX_KONT.prefix(PX_KONT.UID_SRC,);
      {? PX_KONT.first()
      ||
         _main:=exec('caps_var','px_plan',_it,PX_KONT.ref(),_offset,_prec,_cap_inf,0,0)
      ?}
   ?};
   PX_KONT.cntx_pop();
   ~~
?};


:: Ustawiam wartosci w zmiennej zeby inne formuly, np na ikonke tez mogly skorzystac
($('PX_VAR.MAX'+$_it))():=_cap_max;
($('PX_VAR.USE'+$_it))():=_cap_use;
($('PX_VAR.MIN'+$_it))():=_cap_min;
_string:=|form(_cap_use,27,_prec,'9,')+' / '+ {? _cap_inf || '∞' || |form(_cap_max,27,_prec,'9,') ?};

{? _main<>'' & _main<>_string
||
::   _string:='!'+_string;
   _sim_diff:=1
?};

{? _pojwars>0
||
:: jesli jest co wyswietlic to wyswietlam
   {? _cap_max>0 | _cap_use>0
   || ($('PX_VAR.WAR'+$_it))():=_string
   |? _inf>0
   || ($('PX_VAR.WAR'+$_it))():='∞'
   ?}
?};
{? _colorize>0
||
:: Kolorowanie pól
   {? _sim_diff>0
   ||
::    Symulacja różni się od planu głównego
      ($('PX_VAR.KOL'+$_it))():=exec('flddisp','color','PX_CUP#01#05')
   |? (_cap_max>0 & _cap_max=_cap_use) | (_inf>0 & _cap_use>0)
   ||
::    Pojemnosc max ok
      ($('PX_VAR.KOL'+$_it))():=exec('flddisp','color','PX_CUP#01#03')
   |? _cap_use>_cap_max
   ||
::    Pojemnosc max przekroczona
      ($('PX_VAR.KOL'+$_it))():=exec('flddisp','color','PX_CUP#01#01')
   |? _cap_min>0 & _cap_use<_cap_min
   ||
::    Pojemnosc min niewystarczajaca
      ($('PX_VAR.KOL'+$_it))():=exec('flddisp','color','PX_CUP#01#02')
   ?}
?};
_string


\kafelki_reload
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przeladowanie informacji w kafalkach (PX_POZ.KAFELEK)
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('PxSelect')>100
||
   {? PxSelect.Context*'|WIN'>0 | PxSelect.Context*'|MENU'>0 | 1+menu_pth()='E'
   || ~~
   || PX_KONT.cntx_psh();
      PX_CUP.cntx_psh();
::      _no_msg:=no_msg(1);
      {! _it:=1..exec('il_kol','px_plan')
      |! grp_disp(PX_POZ,'KAFELEK'+$_it)
      !};
::      no_msg(_no_msg);
      PX_KONT.cntx_pop();
      PX_CUP.cntx_pop();
      PX_CUP.get()
   ?}
?};
~~


\cup_point_check
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Odszukuje w kontenerze pojemnik ktory czasowo w jakims stopniu zazebia sie z przekazanym
::       w argumencie punktem czasu. Jesli znajdzie to ustawia sie na tym pojemniku
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - badany punkt czasu
::       [_c] - INTEGER - kierunek poszukiwania pojemnika:
::                        [1] - do przodu -  zwracany jest pojemnik ktory zaczyna sie w podanym
::                                           punkcie lub trwa w jego trakcie (ale nie konczy sie w podanym punkcie)::                        [1] - w przod - zwracany jest pojemnik ktory zaczyna sie w podanym
::                         0  - wstecz    -  zwracany jest pojemnik ktory konczy sie w podanym
::                                           punkcie lub trwa w jego trakcie (ale nie zaczyna sie w podanym punkcie)
::       [_d] - TABLE - tabela w której będzie poszukiwany rekord (domyślnie PX_CUP)
::       [_e] - PL_RES.ref() - tylko dla tabeli PX_CAL, jeżeli jest podany to prefiksuję PX_CALe
::                             tym zasobem
::       [_f] - INTEGER - poziom kalendarza. Tylko dla tabeli PX_CAL, jeżeli jest podany to prefiksuję PX_CALe
::                             tym poziomem
::   WY:
::       =0 - brak pojemika przecinajacego podany okres
::       =1 - znaleziono pojemnik przecinajacy podany okres
::----------------------------------------------------------------------------------------------------------------------
{? _<2
|| return(0)
?};

_result:=0;
_kont:=_a;
_time:=_b;
_dir:=1;
{? var_pres('_c')=type_of(0)
|| _dir:=_c
?};

_tab:=~~;
{? var_pres('_d')>0
|| _tab:=_d
|| _tab:=PX_CUP
?};
_plres:=null();
{? var_pres('_e')=type_of(PL_RES.ref())
|| _plres:=_e
?};
_lane:=0;
{? var_pres('_f')=type_of(0)
|| _lane:=_f
?};

{? _dir>0
||
   {? _tab=PX_CAL & _plres<>null()
   || _tab.index('PO_START');
      _px_ver:=exec('FindAndGet','#table',PX_KONT,_kont,,"PX_VER",null());
      _tab.prefix(_plres,_kont,_px_ver)
   |? _tab=PX_CAL & _lane>0
   || _tab.index('LV_START');
      _tab.prefix(_kont,_lane)
   ||
      _tab.index('TM_START');
      _tab.prefix(_kont)
   ?};
:: odnajduje ostatni pojemnik ktory sie zaczyna przed koncem zadanego okresu
   {? _tab.last()
   ||
::    jesli ostatni pojemnik w kontenerze posortowanym pod wzgledem czasu jest wczesniejszy niz szukany okres
::    to znak ze nie ma sensu szukac bo i tak sie nie znajdzie
      {? _tab.TM_START<_time & _tab.TM_END<=_time
      || _result:=0
      || {? _tab.find_le(_time)
         || _can_continue:=1;
            {? _tab=PX_CAL
            ||
::             Specjalna obsługa dla PX_CAL
               _tab.cntx_psh();
               _tab.prefix(_kont,_tab.TM_START);
               _jump:=null;
               {? _tab.size()>1
               ||
::                Jeżeli jest kilka o tym samym czasie to biorę ten o najniższym poziomie
                  {? _tab.first()
                  || _jump:=_tab.ref()
                  ?}
               ?};
               _tab.cntx_pop();
               {? _jump<>null()
               || _can_continue:=_tab.seek(_jump)
               ?}
            ?};
            {? _can_continue>0
            ||
               {!
               |? _start1:=_tab.TM_START;
                  _end1:=_tab.TM_END;
                  {? _time>=_start1 & _time<_end1
                  || _result:=1
                  ?};
                  _result=0 & _tab.next()
               !}
            ?}
         ?}
      ?}
   ?}
|? _dir<0
||
   {? _tab=PX_CAL & _plres<>null()
   || _tab.index('PO_END');
      _px_ver:=exec('FindAndGet','#table',PX_KONT,_kont,,"PX_VER",null());
      _tab.prefix(_plres,_kont,_px_ver)
   |? _tab=PX_CAL & _lane>0
   || _tab.index('LV_END');
      _tab.prefix(_kont,_lane)
   ||
      _tab.index('TM_END');
      _tab.prefix(_kont)
   ?};
:: odnajduje pierwszy pojemnik ktory sie zaczyna przed koncem zadanego okresu
   {? _tab.last()
   ||
::    jesli pierwszy pojemnik w kontenerze posortowanym pod wzgledem czasu jest wczesniejszy niz szukany okres
::    to znak ze nie ma sensu szukac bo i tak sie nie znajdzie
      {? _tab.TM_START<_time & _tab.TM_END<=_time
      || _result:=0
      || {? _tab.find_ge(_time)
         ||
            _can_continue:=1;
            {? _tab=PX_CAL
            ||
::             Specjalna obsługa dla PX_CAL
               _tab.cntx_psh();
               _tab.prefix(_kont,_tab.TM_END);
               _jump:=null;
               {? _tab.size()>1
               ||
::                Jeżeli jest kilka o tym samym czasie to biorę ten o najwyższym poziomie
                  {? _tab.last()
                  || _jump:=_tab.ref()
                  ?}
               ?};
               _tab.cntx_pop();
               {? _jump<>null()
               || _can_continue:=_tab.seek(_jump)
               ?}
            ?};
            {? _can_continue>0
            ||
               {!
               |? _start1:=_tab.TM_START;
                  _end1:=_tab.TM_END;
                  {? _time>_start1 & _time<=_end1
                  || _result:=1
                  ?};
                  _result=0 & _tab.prev()
               !}
            ?}
         ?}
      ?}
   ?}
?};

{? _result>0 & _tab=PX_CAL
||
:: Podczytuję również PX_CUP
   PX_CAL.PX_CUP()
?};
_result


\cup_time_check
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Odszukuje w kontenerze pojemnik ktory czasowo w jakims stopniu zazebia sie z przekazanym
::       w argumencie okresem czasu. Jesli znajdzie to ustawia sie na tym pojemniku i zwraca
::       wynik mowiacy w jaki sposob pojemnik przecina zadany okres
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - Poczatek badanego okresu
::       _c - tm_stamp() - Koniec badanego okresu
::       [_d] -1 / 1 - Kierunek przetwarzania -1=od konca +1=od poczatku (domyslnie)
::   WY:
::       =0 - brak pojemika przecinajacego podany okres
::       =1
::                               |-------------------------------------------|
::                               |+++++++++++++++++++    PX_CUP              |
::                               |-------------------------------------------|
::          |----------------------------------------|
::          |  argument (_b.._c)  +++++++++++++++++++|
::          |----------------------------------------|
::
::       =2
::          |-----------------------------------------------------------------------|
::          |            ++++++++++++++++++++++++++++    PX_CUP                     |
::          |-----------------------------------------------------------------------|
::                      |----------------------------|
::                      |+++  argument (_b.._c) +++++|
::                      |----------------------------|
::
::       =3
::          |------------------------------------|
::          | PX_CUP              +++++++++++++++|
::          |------------------------------------|
::                               |-----------------------------------|
::                               |+++++++++++++++  argument (_b.._c) |
::                               |-----------------------------------|
::       =4
::                      |------------------|
::                      |+++++PX_CUP+++++++|
::                      |------------------|
::          |-----------------------------------------------------------------------|
::          |            ++++++++++++++++++           argument (_b.._c)             |
::          |-----------------------------------------------------------------------|
::
::----------------------------------------------------------------------------------------------------------------------
{? _<3
|| return(0)
?};

_result:=0;
_kont:=_a;
_start2:=_b;
_end2:=_c;
_direction:=1;

{? _>3
|| _direction:=_d
?};

::kierunek 'od tylu' - typowy dla dodawania nowego kolejnego pojemnika
{? _direction=-1
|| PX_CUP.index('TM_START');
   PX_CUP.prefix(_kont);
:: odnajduje ostatni pojemnik ktory sie zaczyna przed koncem zadanego okresu
   {? PX_CUP.last()
   ||
::    jesli ostatni pojemnik w kontenerze posortowanym pod wzgledem czasu jest wczesniejszy niz szukany okres
::    to znak ze nie ma sensu szukac bo i tak sie nie znajdzie
      {? PX_CUP.TM_START<_start2 & PX_CUP.TM_END<=_start2
      || _result:=0
      || {? PX_CUP.find_le(_end2)
         || {!
            |? _start1:=PX_CUP.TM_START;
               _end1:=PX_CUP.TM_END;
::             Przypadek 1
               {? _start2<_start1 & _end2<_end1 & _end2>=_start1
               || _result:=1
               ?};
::             Przypadek 2
               {? _start2>=_start1 & _end2<_end1
               || _result:=2
               ?};
::             Przypadek 3
               {? _start1<_start2 & _end1<_end2 & _end1>_start2
               || _result:=3
               ?};
::             Przypadek 4
               {? _start1>=_start2 & _end1<=_end2
               || _result:=4
               ?};
               _result=0 & PX_CUP.prev()
             !}
         ?}
      ?}
   ?}
?};

::kierunek 'od przodu' - typowy gdy chcemy odszukac kontener w podanym przedziale
{? _direction=1
|| PX_CUP.index('TM_END');
   PX_CUP.prefix(_kont);
:: odnajduje pierwszy pojemnik ktory sie zaczyna przed koncem zadanego okresu
   {? PX_CUP.first()
   ||
::    jesli pierwszy pojemnik w kontenerze posortowanym pod wzgledem czasu jest pozniejszy niz szukany okres
::    to znak ze nie ma sensu szukac bo i tak sie nie znajdzie
      {? PX_CUP.TM_START>_end2 & PX_CUP.TM_END>_end2
      || _result:=0
      || {? PX_CUP.find_ge(_start2)
         || {!
            |? _start1:=PX_CUP.TM_START;
               _end1:=PX_CUP.TM_END;
::             Przypadek 1
               {? _start2<_start1 & _end2<_end1 & _end2>=_start1
               || _result:=1
               ?};
::             Przypadek 2
               {? _start2>=_start1 & _end2<_end1
               || _result:=2
               ?};
::             Przypadek 3
               {? _start1<_start2 & _end1<_end2 & _end1>_start2
               || _result:=3
               ?};
::             Przypadek 4
               {? _start1>=_start2 & _end1<=_end2
               || _result:=4
               ?};
               _result=0 & PX_CUP.next()
            !}
         ?}
      ?}
   ?}
?};
_result


\intervals_chk
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Bada zaleznosc pomiedzy dwoma interwalami czasowymi
::   WE: _a - REAL - tm_stamp() START  interwal1
::       _b - REAL - tm_stamp() END    interwal1
::       _c - REAL - tm_stamp() START  interwal2
::       _d - REAL - tm_stamp() END    interval2
::   WY:
::       =0 - interwaly sie nie przecinaja w zaden sposob ze soba
::       =1
::                               |-------------------------------------------|
::                               |+++++++++++++++++++ interwal1 (_a.._b)     |
::                               |-------------------------------------------|
::          |----------------------------------------|
::          |  interwal2 (_c.._d) +++++++++++++++++++|
::          |----------------------------------------|
::
::       =2
::          |-----------------------------------------------------------------------|
::          |            ++++++++++++++++++++++++++++  interwal1 (_a.._b)           |
::          |-----------------------------------------------------------------------|
::                      |----------------------------|
::                      |+++ interwal2 (_c.._d) +++++|
::                      |----------------------------|
::
::       =3
::          |------------------------------------|
::          | interwal1 (_a.._b)  +++++++++++++++|
::          |------------------------------------|
::                               |-----------------------------------|
::                               |+++++++++++++++  interwal2 (_c.._d)|
::                               |-----------------------------------|
::       =4
::                      |-------------------------------|
::                      |+++++interwal1 (_a.._b) +++++++|
::                      |-------------------------------|
::          |-----------------------------------------------------------------------|
::          |            +++++++++++++++++++++++++++++++  interwal2 (_c.._d)        |
::          |-----------------------------------------------------------------------|
::----------------------------------------------------------------------------------------------------------------------

_result:=0;

_start1:=_a;
_end1:=_b;
_start2:=_c;
_end2:=_d;

{? _start2<_start1 & _end2<_end1 & _end2>=_start1
|| _result:=1
?};
{? _start2>=_start1 & _end2<=_end1
|| _result:=2
?};
{? _start1<_start2 & _end1<_end2 & _end1>=_start2
|| _result:=3
?};
{? _start1>=_start2 & _end1<=_end2
|| _result:=4
?};
_result


\intervals_sum
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca interwal ktory jest czescia wspolna dwoch podanych interwalow
::   WE: _a - REAL - tm_stamp() START  interwal1
::       _b - REAL - tm_stamp() END    interwal1
::       _c - REAL - tm_stamp() START  interwal2
::       _d - REAL - tm_stamp() END    interval2
::   WY: obj_new(2) - tablica zawierajaca tm_stampy poczatku i konca interwalu ktory jest suma
::----------------------------------------------------------------------------------------------------------------------

_result:=obj_new(2);
_result[1]:=0;
_result[2]:=0;

_start1:=_a;
_end1:=_b;
_start2:=_c;
_end2:=_d;

:: zwracam sume tylko jesli interwaly sie przecinaja
{? exec('intervals_chk','px_plan',_start1,_end1,_start2,_end2)>0
||
:: max startu
   {? _start1>_start2
   || _result[1]:=_start1
   || _result[1]:=_start2
   ?};
:: min konca
   {? _end1<_end2
   || _result[2]:=_end1
   || _result[2]:=_end2
   ?}
?};
_result


\interval_len
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Zwraca dlugosc przekazanego interwalu czasowego
::   WE: _a - obj_new(2) - tablica zawierajaca tm_stampy poczatku i konca interwalu
::   WY: REAL - dlugosc interwalu w nomenklaturze tm_stamp
::----------------------------------------------------------------------------------------------------------------------
_interval:=_a;
_start:=0;
_end:=0;
_result:=0;

_start:=_interval[1];
_end:=_interval[2];

_result:=_end-_start;
{? _result<0
|| _result:=_result*(-1)
?};
_result


\cup_time_side
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza polozenie punktu czasowego wzgledem pojemnika
::   WE: _a - REAL - punkt czasowy ktory sprawdzam
::       KONTEKST PRACY - rekord PX_CUP
::   WY: 0 - wystapil jakis blad bo ta funkcja nie powinna zwracac 0
::       1 - punkt czasowy z lewej strony pojemnika (wczesniej)
::       2 - punkt czasowy wewnatrz pojemnika
::       3 - punkt czaspwy z prawej strony pojemnika (pozniej)
::----------------------------------------------------------------------------------------------------------------------
_result:=0;

_time:=_a;

_cup_start:=PX_CUP.TM_START;
_cup_end:=PX_CUP.TM_END;

{? _time>=_cup_start & _time<_cup_end
|| _result:=2
|? _time<_cup_start & _time<_cup_end
|| _result:=1
|? _time>_cup_start & _time>=_cup_end
|| _result:=3
?};
_result


\cup_closest
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Znajduje najblizszy pojemnik dla podanego punktu czasowego zgodnie z kierunkiem
::   WE: _a - PX_KONT.ref()
::       _b - tm_stamp() - punkt czasowy
::       _c - zwrot: -1 - w tyl, 1 w przod
::       [_d] - TABLE - tabela w której będzie poszukiwany rekord (domyślnie PX_CUP)
::       [_e] - INTEGER - poziom kalendarza. Tylko dla tabeli PX_CAL, jeżeli jest podany to prefiksuję PX_CALe
::                             tym poziomem
::   WY: 0 / 1 - sukces czy porazka
::----------------------------------------------------------------------------------------------------------------------
_kont:=_a;
_start:=_b;
_direction:=_c;
_lane:=0;
{? var_pres('_e')=type_of(0)
|| _lane:=_e
?};

_tab:=~~;
{? var_pres('_d')>0
|| _tab:=_d
|| _tab:=PX_CUP
?};

_result:=0;

::szukam kafelka w czasie trwania punktu czasowego
_during:=exec('cup_point_check','px_plan',_kont,_start,_direction,_tab,,_lane);

{? _during>0
|| _result:=1
||
:: jesli nie znalazlem to znajduje nastepny lub poprzedni kafelek zgodny z kierunkiem szukania
   _tab.clear();
:: kierunek 'w tyl'
   {? _direction<0
   ||
      {? _tab=PX_CAL & _lane>0
      || _tab.index('LV_END');
         _tab.prefix(_kont,_lane)
      ||
         _tab.index('TM_END');
         _tab.prefix(_kont)
      ?};
      {? _tab.find_le(_start)
      || _result:=1
      ?}
   ?};

:: kierunek 'w przod'
   {? _direction>0
   ||
      {? _tab=PX_CAL & _lane>0
      || _tab.index('LV_START');
         _tab.prefix(_kont,_lane)
      ||
         _tab.index('TM_START');
         _tab.prefix(_kont)
      ?};
      {? _tab.find_ge(_start)
      || _result:=1
      ?}
   ?}
?};
{? _result>0 & _tab=PX_CAL
||
:: Podczytuję również PX_CUP
   PX_CAL.PX_CUP()
?};
_result


\il_kol
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Zwraca ilosc kolumn widoku planu (zwiekszenie powyzej 7 wymaga dodania dodania okna PX_POZ.KAFELEK*).
::       Kazda zmiana wymaga modyfikacji okna PX_KONT.PX_WER, PX_KONT.PX_WERT
::----------------------------------------------------------------------------------------------------------------------
7


\il_kol_wide
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Zwraca ilosc kolumn widoku planu w strukturze drzewa dla obiektow i kontenerow
::----------------------------------------------------------------------------------------------------------------------
_res:=exec('get','#params',500353,1);
{? _res>40
|| FUN.emsg('Błąd konfiguracji systemu.\n\nWartość parametru 500353 nie może być większa niż 40.'@);
   _res:=40
?};
_res


\area_wide
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.14]
:: OPIS: Zwraca szerokość obszaru dla widoku planu w strukturze drzewa dla obiektow i kontenerów
::----------------------------------------------------------------------------------------------------------------------
160


\set_col_names
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Ustawia tytuly kolumn w widokach planu
::       Kontekst wywolania: ustawione zmienne PX_VAR.VIE_KONT, PX_VAR.VIE_DATE
::----------------------------------------------------------------------------------------------------------------------
PX_VIEW.cntx_psh(); PX_VIEW.clear();
_il_kol:=exec('il_kol','px_plan');
_il_kol_w:=exec('il_kol_wide','px_plan');
{! _it:=1.._il_kol_w |! ($('PX_VAR.TIT'+$_it))():='<brak okresu>' !};
{! _it:=1.._il_kol |! ($('PX_VAR.TYT'+$_it))():='<brak okresu>' !};

:: Czyszcze pola dat, bo mogly zostać ustawione jeszcze w poprzednim widoku
{! _it:=1.._il_kol_w |! ($('PX_VAR.DATY'+$_it))():=null() !};

{? PX_VIEW.seek(PX_VAR.PX_VIEW)
||
   {? PX_VAR.VIE_DATE<>null()
   ||
::    Podczytuje rekord tabeli DATY
      PX_VAR.VIE_DATE();
      _it:=1;
      {!
      |? _str_normal:=exec('to_string','daty',PX_VIEW.LEVEL,1);
         _str_short:=exec('to_string','daty',PX_VIEW.LEVEL,2);
         ($('PX_VAR.TIT'+$_it))():=_str_short;
         {? _it<=_il_kol
         || ($('PX_VAR.TYT'+$_it))():=_str_normal
         ?};

::       Ustawiam wyswietlana date w zmiennej - szybszy dostep do danych
         ($('PX_VAR.DATY'+$_it+':=DATY.ref()'))();

         _it+=1;
         _it<=_il_kol_w & exec('find_next','daty',PX_VIEW.LEVEL)
      !}
   || FUN.emsg('Nie ustawiono daty początkowej widoku.'@)
   ?}
|| FUN.emsg('Nie znaleziono widoku planu.'@)
?};
PX_VIEW.cntx_pop();
~~


\prev_cups
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przechodzi do poprzednich pojemnikow w kontenetrze
::       Kontekst wywolania: ustawione zmienne PX_VAR.VIE_KONT, PX_VAR.VIE_CUP
::       Zmienia: PX_VAR.VIE_CUP
::       Ustawia tytuly kolumn w widoku planu
::   WE: [_a] - ilosc kolumn - domyslnie exec('il_kol','px_plan')
::       [_b] - identyfikator kontekstu odswiezania ('px', 'xpl', 'zpl')
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _il_kol:=_a || _il_kol:=exec('il_kol','px_plan') ?};
{? var_pres('_b')=type_of('') || _grp_disp:=_b || _grp_disp:='' ?};

PX_VAR.LAST_DAT:=null();
DATY.clear();
_can_continue:=1;
{? DATY.seek(PX_VAR.VIE_DATE)
||
   {! _it:=1.._il_kol
   |! _can_continue:=exec('find_next','daty',PX_VAR.PX_VIEW().LEVEL,-1)
   !};
   {? PX_VAR.VIE_DATE=DATY.ref()
   || FUN.info('Osiągnięto koniec planu.'@)
   ?};
   PX_VAR.VIE_DATE:=DATY.ref()
?};
exec('set_col_names','px_plan');

{? _grp_disp='px'
||
   grp_disp(PX_KONT,{? exec('tree_kont','px_param') || 'PX_WERT' || 'PX_WER' ?},1,1);
   grp_disp(PxSelect.Tab_OBJ.TAB,PxSelect.Tab_OBJ.WER,1,1);
   grp_disp(PxSelect.Tab_KONT.TAB,PxSelect.Tab_KONT.WER,1,1)
|? _grp_disp='xpl'
||
   grp_disp(__pplan.TAB,__pplan.WER)
|? _grp_disp='zpl'
||
   grp_disp(__plan.TAB,__plan.WER)
|? _grp_disp='grop'
|| _env_grops:=params_get().env_grops;
   grp_disp(_env_grops.PLAN_VIEW1.TAB,_env_grops.PLAN_VIEW1.WER,1);
   grp_disp(_env_grops.PLAN_VIEW2.TAB,_env_grops.PLAN_VIEW2.WER,1);
   ~~
|? _grp_disp='cmp'
|| grp_disp(PX_KONT,'PX_WER',1,1)
?};
~~


\next_cups
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przechodzi do nastepnych pojemnikow w kontenetrze
::       Kontekst wywolania: ustawione zmienne PX_VAR.VIE_KONT, PX_VAR.VIE_CUP
::       Zmienia: PX_VAR.VIE_CUP
::       Ustawia tytuly kolumn w widoku planu
::   WE: [_a] - ilosc kolumn - domyslnie exec('il_kol','px_plan')
::       [_b] - identyfikator kontekstu odswiezania ('px', 'xpl', 'zpl')
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(0) || _il_kol:=_a || _il_kol:=exec('il_kol','px_plan') ?};
{? var_pres('_b')=type_of('') || _grp_disp:=_b || _grp_disp:='' ?};

PX_VAR.LAST_DAT:=null();
DATY.clear();
_can_continue:=1;
{? DATY.seek(PX_VAR.VIE_DATE)
||
   {! _it:=1.._il_kol
   |! _can_continue:=exec('find_next','daty',PX_VAR.PX_VIEW().LEVEL)
   !};
   {? PX_VAR.VIE_DATE=DATY.ref()
   || FUN.info('Osiągnięto koniec planu.'@)
   ?};
   PX_VAR.VIE_DATE:=DATY.ref()
?};
exec('set_col_names','px_plan');

{? _grp_disp='px'
||
   grp_disp(PX_KONT,{? exec('tree_kont','px_param') || 'PX_WERT' || 'PX_WER' ?},1,1);
   grp_disp(PxSelect.Tab_OBJ.TAB,PxSelect.Tab_OBJ.WER,1,1);
   grp_disp(PxSelect.Tab_KONT.TAB,PxSelect.Tab_KONT.WER,1,1)
|? _grp_disp='xpl'
||
   grp_disp(__pplan.TAB,__pplan.WER)
|? _grp_disp='zpl'
||
   grp_disp(__plan.TAB,__plan.WER)
|? _grp_disp='grop'
|| _env_grops:=params_get().env_grops;
   grp_disp(_env_grops.PLAN_VIEW1.TAB,_env_grops.PLAN_VIEW1.WER,1);
   grp_disp(_env_grops.PLAN_VIEW2.TAB,_env_grops.PLAN_VIEW2.WER,1);
   ~~
|? _grp_disp='cmp'
|| grp_disp(PX_KONT,'PX_WER',1,1)
?};
~~


\curr_cup
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przechodzi do pojemnika w kontenetrze zgodnego z biezaca data
::       Kontekst wywolania: ustawiona zmienna PX_VAR.VIE_KONT
::       Zmienia: PX_VAR.VIE_CUP
::       Ustawia tytuly kolumn w widoku planu
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
exec('go_cup_date','px_plan',date())


\go_cup_date
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przechodzi do pojemnika w kontenetrze zgodnego z podana data
::       Kontekst wywolania - ustawione zmienne:
::          - PX_VAR.VIE_KONT
::          - PX_VAR.VIE_CUP
::          - PX_VAR.VIE_VER
::       Ustawia tytuly kolumn w widoku planu
::   WE: [_a] - data
::   WY: 0 / 1
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(date())
|| _data:=_a
|| undefine();
   define('DATE',date(),%255+'Podaj datę'@);
   def_btn('text=%1'['&Zapisz'@],'key:F2');
   def_btn('text=%1'['&Anuluj'@],'key:Esc');
   {? def_edit("chk_rec()",'|--|'+FUN.TYT)
   || _data:=DEFINE.DATE
   || _data:=date()
   ?};
   undefine()
?};

PX_VAR.LAST_DAT:=null();
PX_VER.cntx_psh();

:: Jesli przekazana data jest zerowa, to ustawiam sie na poczatku wyswietlanej wersji
{? _data=date(0,0,0)
|| _data:=PX_VAR.VIE_VER().STARTD().DATA
?};
:: Jeśli nadal zerowa to ustawiam się na dzisiaj
{? _data=date(0,0,0)
|| _data:=date()
?};

PX_KONT.cntx_psh();
PX_KONT.index('ACT');
PX_KONT.prefix('T',PX_VAR.VIE_VER);
{? PX_KONT.first()
||
   PX_VAR.VIE_KONT:=PX_KONT.ref();
   {? _data=date()
   || _t1:=time();
      _t2:=time()
   || _t1:=time(0,0,0);
      _t2:=time(23,59,59)
   ?};
   _start:=tm_stamp(_data~1,_data~2,_data~3,_t1~1,_t1~2,_t1~3,0);
   _end:=tm_stamp(_data~1,_data~2,_data~3,_t2~1,_t2~2,_t2~3,0);


   _daty:=exec('get','daty',_data);
   {? _daty=null()
   ||
      {? _data=date()
      || _txt:='bieżącą datą'
      || _txt:='datą '+$_data
      ?};
      FUN.emsg(
         'Brak w tabeli dat rekordu z %1. Proszę uzupełnić parametryzację systemu (wygenerować brakujące rekordy w tabeli DATY)'@[_txt]
      );
      PX_KONT.cntx_pop();
      PX_VER.cntx_pop();
      return(0)
   ||
      {? PX_VAR.PX_VIEW<>null()
      ||
::       Jesli widok ustawiony, to zaokraglam to podanego poziomu
         PX_VAR.VIE_DATE:=exec('round_start','daty',_daty,PX_VAR.PX_VIEW().LEVEL)
      || PX_VAR.VIE_DATE:=_daty
      ?}
   ?}
||
   FUN.emsg('Brak zasobów planistycznych.\n'
            'Proszę uzupełnić parametryzację systemu w obszarze roboczym \'ZWS_PAR - Ustawienia i parametryzacja\'.'@);
   PX_KONT.cntx_pop();
   PX_VER.cntx_pop();
   return(0)
?};
PX_KONT.cntx_pop();
PX_VER.cntx_pop();
exec('set_col_names','px_plan');
1


\kafelek_bf
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed wyswietleniem kafelka - ustawia niezbedne zmienne oraz indeks i prefiks dla PX_POZ
::   WE: _a - numer kafelka
::----------------------------------------------------------------------------------------------------------------------
_number:=_a;
_date:=($('PX_VAR.DATY'+$_number))();
_cup:=($('PX_VAR.REA_CUP'+$_a))();

PX_POZ.win_sel('KAFELEK'+$_number);
PX_POZ.hdr_sel();
PX_POZ.actions('KAFELEK'+$_number,,,1);

_result:='';
_disable:=0;

{? PX_VAR.SEL_KONT<>null()
||
:: Podczytanie widoku
   PX_VAR.PX_VIEW();

:: Podczytanie kontenera
   PX_VAR.SEL_KONT();

   {? PX_VAR.NAST_ALG<>2
   || PX_POZ.actions('KAFELEK'+$_number,'E:E',,1)
   ?};

:: Podczytanie rekordu tabeli DATY
   ($('PX_VAR.DATY'+$_number+'()'))();

   _interval:=exec('interval','#interval');
   _interval.START:=DATY.STAMP_S;

   {? PX_VAR.PX_VIEW().LEVEL='D'
   || _interval.END:=DATY.STAMP_E
   || DATY.cntx_psh();

::    Podczytanie następnego rekordu tabeli DATY
      ($('PX_VAR.DATY'+$(_number+1)+'()'))();
      _interval.END:=DATY.STAMP_S;
      DATY.cntx_pop()
   ?};

:: Podczytanie pojemnika
   _time_chk:=exec('cup_time_check','px_plan',PX_KONT.ref(),_interval.START,_interval.END,1);
   {? _time_chk=0
   ||
      _result:='#disable';
      _disable:=1;
      ~~
   ||
      {? PX_CUP.TM_START<>PX_CUP.TM_END
      ||
::       Jest pojemnik ale sprawdzam czy zazębia się więcej niż nic

         _interval_cup:=exec('interval','#interval');
         _interval_cup.START:=PX_CUP.TM_START;
         _interval_cup.END:=PX_CUP.TM_END;

         _interval_and:=exec('intervals_and','#interval',_interval,_interval_cup);

         {? exec('interval_dur','#interval',_interval_and)=0
         || _result:='#disable';
            _disable:=1
         ?}
      ?}
   ?};

::   ($('PX_VAR.REA_CUP'+$_a+'()'))();

:: Porównuje poziom widoku z poziomem pojemnikow
   _cup_level:=exec('cup_level','px_cup');
   {? _cup_level<>''
   || _compare:=exec('level_compare','px_view',_cup_level,PX_VIEW.LEVEL)
   || _compare:=exec('level_compare','px_view',PX_KONT.MAX_CDUR,PX_VIEW.LEVEL)
   ?};

   _symbol:='';
   {? _compare=-1 & _disable=0
   ||
::    Przypadek w ktorym kontener zawiera pojemniki np tygodniowe a widok jest dzienny
::    wtedy niestety nie ma sensu prefiksowanie pozycji planu tak jak jest wyswietlany widok
::    bo nie jestesmy w stanie zlapac tych pozycji planu, ktore zaczynaja sie w innych dniach
::    niz poczatek albo koniec tygodnia
::    W takim przypadku kafelki wyswietlaja pojemniki rzeczywiste - tak jak bylo przed wprowadzeniem
::    widokow planu

      _symbol:=PX_CUP.SYMBOL;

      PX_VAR.CUPSTART:=PX_CUP.STARTD().DATA;
      PX_VAR.CUPEND:=PX_CUP.ENDD().DATA;
      PX_VAR.CUP_T_S:=PX_CUP.STARTT;
      PX_VAR.CUP_T_E:=PX_CUP.ENDT;

      _wymiar:=PxSelect.PX_WK.WYMIAR;

      PX_VAR.CAPACITY:=($('PX_CUP.CAP_MAX'+$_wymiar))();
      PX_VAR.SUMA:=($('PX_CUP.CAP_USE'+$_wymiar))();
      PX_VAR.MADE:=($('PX_CUP.CAP_WYK'+$_wymiar))();

::    Prefiksowanie PX_POZ
      PX_POZ.index('LP');
      PX_POZ.prefix(_cup);
      PX_POZ.first();
      ~~
   ||
      _symbol:=exec('to_string','daty',PX_VIEW.LEVEL);

      PX_VAR.CUP_T_S:=PX_VIEW.OFFSET;
      PX_VAR.CUP_T_E:=PX_VIEW.OFFSET;

      PX_VAR.CUPSTART:=DATY.DATA;

      _next:=null();
      DATY.cntx_psh();
      {? exec('find_next','daty',PX_VIEW.LEVEL)
      || _next:=DATY.ref();
         PX_VAR.CUPEND:=DATY.DATA
      ?};
      DATY.cntx_pop();
      PX_VAR.CAPACITY:=($('PX_VAR.MAX'+$_number))();
      PX_VAR.SUMA:=($('PX_VAR.USE'+$_number))();

::    Prefiksowanie PX_POZ
      exec('view_prefix','px_poz',PX_VAR.SEL_KONT().PX_VER,DATY.ref(),PX_VAR.SEL_KONT,PX_VAR.KAF_MODE);
      PX_POZ.first();
      ~~
   ?};
   PX_VAR.CUPTITLE:=_symbol;
   PX_POZ.hdr_sel(_symbol)
||
:: Uzytkownik nie stoi na kontenerze, wiec trzeba wyczyscic kafelek
   PX_VAR.CUPSTART:=date(0,0,0);
   PX_VAR.CUPEND:=date(0,0,0);
   PX_VAR.CUP_T_S:=time(0,0,0);
   PX_VAR.CUP_T_E:=time(0,0,0);
   PX_VAR.CAPACITY:=0;
   PX_VAR.SUMA:=0;
   PX_VAR.MADE:=0;
:: Prefiksowanie PX_POZ
   PX_POZ.index('LP');
   PX_POZ.prefix(null());
   PX_POZ.first();
   PX_VAR.CUPTITLE:='';
   ~~
?};
_result


\px_wym_bre
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wlasciwa akcja przed rekord w oknie __PX_WYM
::----------------------------------------------------------------------------------------------------------------------
{? exec('mainversion_vie','px_ver') || '' || 'PX_POZ#01#01' ?}


\select_zkn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja drzewa planu dla wszystkich pozycji zamowienia od strony naglowka zamowienia (funkcja Inne -> Plan)
::       Uzyta w formule \zam_plan/zk2
::   WY: _plan.TAB - tabela tymczasowa z planem
::       _plan.WER - okno tymczasowe do prezentacji danych
::       _plan.load - funkcja ladujaca dane i (opcjonalnie) odswiezajaca okno w grupie
::----------------------------------------------------------------------------------------------------------------------
:: "blankuje" PX_VAR - po to zeby sie zblankowalo PX_VAR.GREY
PX_VAR.GREY:=exec('findfnv','#color');
::ustawienie glownej wersji planu
_mainver:=exec('get_mainversion','px_ver');
PX_VAR.VIE_VER:=_mainver;

:: Ustawiam domyslny widok dla usera
PX_VAR.PX_VIEW:=exec('default_view','px_view');

:: Ustawiam tryb prefiksowania kafelkow
PX_VAR.KAF_MODE:='S';

:: Podczytuje do zmiennej maksymalna dlugosc pojemnikow dla widoku 'Obiekty' (szybszy dostep)
PX_VAR.OBJ_CDUR:=exec('get','#params',500363,2);
_plan:=exec('select_obj','px_plan',,,0);
_plan


\select_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja drzewa planu dla zlecenia od strony menu zlecenia (bez parametru = wersja główna)
::       lub dla symulacji zlecenia (z parametrem = wersja tymczasowa)
::   WE: [_a] - PX_VER.ref()
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<0 || _a:=~~ ?};
exec('select_any_core','px_plan',_a,ZL,0);
~~


\select_cont_1
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja drzewa planu dla kontenera/kontenerow - procedura elementarna
::----------------------------------------------------------------------------------------------------------------------
_before:="
   _elements:=exec('elements_table_navi','px_plan',0);

:: Ustawiam widok w combobox
   _view:=PX_VAR.PX_VIEW;
   {? _view<>null()
   ||
      _view_sym:=exec('FindAndGet','#table',PX_VIEW,_view,,\"SYMBOL\",'');
      {? _view_sym<>''
      || exec('set_value_grp','#desktop','','nawigacja','combo_view@px_navi',_view_sym,,_elements)
      ?}
   || exec('set_enabled_grp','#desktop','','nawigacja','combo_view@px_navi',0,_elements)
   ?};
   exec('load','#desktop','nawigacja','zpl_navi.dsk',,,,,_elements);
   ~~
";
_grp:=__plan.TAB.grp_make('Plan zasobu'@,_before,'#kontplanwer');
_before:="
   _il_kol:=exec('il_kol_wide','px_plan');
   {! _it:=1.._il_kol
   |! _war:=($('PX_VAR.TIT'+$_it))();
      cur_tab(1,1).fld_opt(cur_win(1,1),'col_name=%1'[_war],PX_VAR,'WAR'+$_it);
      _help:=exec('col_help','px_plan',_it);
      cur_tab(1,1).fld_opt(cur_win(1,1),'col_help=%1'[_help],PX_VAR,'WAR'+$_it);
      ~~
   !};
   ~~
";
__plan.TAB.grp_sel(_grp,,__plan.WER,,,,,20,_before,,,,'maximized');
__plan.TAB.grp_splt(_grp,,'horizontal','nawigacja','0,75%');

exec('create','#desktop',__plan.TAB,'nawigacja',_grp,2);

__plan.TAB.win_sel(_grp);
__plan.TAB.select();

VAR_DEL.delete('__plan');
~~


\select_cont
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja drzewa planu dla kontenera
::----------------------------------------------------------------------------------------------------------------------
{? VAR.GRUPA<>'T'
||
   PX_CUP.index('TM_START');
   PX_CUP.prefix(PX_KONT.ref());
   {? ~PX_CUP.first()
   || FUN.info('Brak pojemników zasobu (kontenera) '+PX_KONT.SYMBOL+' ['+PX_KONT.NAZWA+'].');
      return()
   ?};

   PX_VAR.IL_KOL:=exec('il_kol_wide','px_plan');
:: ustawienie glownej wersji planu
   _mainver:=exec('get_mainversion','px_ver');
   PX_VAR.VIE_VER:=_mainver;

:: Ustawiam domyslny widok dla usera
   PX_VAR.PX_VIEW:=exec('default_view','px_view');

:: Ustawiam tryb prefiksowania kafelkow
   PX_VAR.KAF_MODE:='S';

:: Podczytuje do zmiennej maksymalna dlugosc pojemnikow dla widoku 'Obiekty' (szybszy dostep)
   PX_VAR.OBJ_CDUR:=exec('get','#params',500363,2);

   VAR_DEL.delete('__plan');
   __plan:=exec('select_kont','px_plan',,,0);

   _px_kont:="
      _tab:=exec('kont_find_tab','px_kont');
      _tab.REF:=#PX_KONT.ref();
      _tab.add();
      _tab
   ";
   __plan.load(_px_kont,0);

   exec('select_cont_1','px_plan')
?};
~~


\select_cont_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja drzewa planu dla kontenerow - przed grupa
::----------------------------------------------------------------------------------------------------------------------
VAR.GRUPA:='T';

PX_VAR.IL_KOL:=exec('il_kol_wide','px_plan');
:: ustawienie glownej wersji planu
_mainver:=exec('get_mainversion','px_ver');
PX_VAR.VIE_VER:=_mainver;

:: Ustawiam domyslny widok dla usera
PX_VAR.PX_VIEW:=exec('default_view','px_view');

:: Ustawiam tryb prefiksowania kafelkow
PX_VAR.KAF_MODE:='S';

:: Podczytuje do zmiennej maksymalna dlugosc pojemnikow dla widoku 'Obiekty' (szybszy dostep)
PX_VAR.OBJ_CDUR:=exec('get','#params',500363,2);

VAR_DEL.delete('__plan');
__plan:=exec('select_kont','px_plan');

_px_kont:="
   _tab:=exec('kont_find_tab','px_kont');
   _sel_aget:=PX_KONT.sel_aget();
   {? _sel_aget.first()
   || {!
      |?
         _tab.REF:=_sel_aget.REF;
         _tab.add();
         _sel_aget.next()
      !}
   ?};
   _tab
";
__plan.load(_px_kont,0);
1


\select_cont_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Selekcja drzewa planu dla kontenerow - po grupie
::----------------------------------------------------------------------------------------------------------------------
exec('select_cont_1','px_plan');
VAR.GRUPA:='N';
~~


\select_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Struktura do selekcji planowanych obiektów
::   WE: [_a] - nazwa zmiennej, do której przypisany będzie wynik, jeśli pusta, to nie zadziała część funkcji
::       [_b] - 1=widok do panalu planowania, 0=widok "luzem" (domyslnie)
::       [_c] - INTEGER 0/[1] - czy drag'n'drop dostepny w oknie czy nie, domyslnie tak
::       [_d] - STRING - tytuł okienka
::   WY: _plan.TAB - tabela tymczasowa z planem
::       _plan.WER - okno tymczasowe do prezentacji danych
::       _plan.load - funkcja ladujaca dane i (opcjonalnie) odswiezajaca okno w grupie
::       _plan.reload - funkcja odswiezajaca dane i (opcjonalnie) odswiezajaca okno w grupie
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') || _obj_name:=_a || _obj_name:='' ?};
{? var_pres('_b')=type_of(0) || _ppanel:=_b || _ppanel:=0 ?};
{? var_pres('_c')=type_of(0) || _dnd:=_c || _dnd:=1 ?};
_title:='Plan produkcji'@;
{? var_pres('_d')=type_of('') & _d<>''
|| _title:=_d
?};
_plan:=obj_new('TAB','NdxP','NdxO','WER','load','reload','Formula','Grp_disp','Arg');
_plan.TAB:="tab_tmp(2,
   'PARENT'    ,'TREE_REF'    ,'Parent',
   'OPIS'      ,'STRING[100]' ,'Opis',
   'TAB'       ,'STRING[8]'   ,'Tabela źródłowa: PX_OBJ, PX_KONT',
   'REF'       ,'INTEGER'     ,'#.ref() w tabeli źródłowej (j.w.)',
   'KONT_REF'  ,'INTEGER'     ,'#.ref() PX_KONT dla PX_OBJ (parent)',
   'GRP_REF'   ,'INTEGER'     ,'#.ref() PX_GRP',
   'STG_REF'   ,'INTEGER'     ,'#.ref() PX_STAGE',
   'OBJ_REF'   ,'INTEGER'     ,'#.ref() PX_OBJ',
   'RES_TYP'   ,'STRING[1]'   ,'Typ zasobu'";
{! _it:=1..40
|! _plan.TAB+=",'KOL"+$_it+"','STRING[23]','Kolor kolumny'"
!};
_plan.TAB+=")";
_plan.TAB:=($_plan.TAB)();
_plan.TAB.fld_attr(,2);
_plan.NdxP:=_plan.TAB.index('?');
_plan.NdxO:=_plan.TAB.ndx_tmp(,,'OPIS',,);
_wid:='#px_obj_plan';
_plan.WER:=_plan.TAB.mk_sel(_title,'P',0,_wid,1,,,1,,,,,1);
_plan.TAB.win_fld(_plan.WER,,'OPIS',,,27,,,'Opis'@);
_plan.TAB.win_fld(_plan.WER,PX_VAR,'JM','KOD',,5,,,'jm'@);
_il_kol:=exec('il_kol_wide','px_plan');
_area_wide:=exec('area_wide','px_plan');
_szer_kol:=floor((_area_wide/_il_kol)-1);
{! _it:=1.._il_kol
|! _plan.TAB.win_fld(_plan.WER,PX_VAR,'WAR'+$_it,,,_szer_kol,,,$_it,0);
   _war:=($('PX_VAR.TIT'+$_it))();
   _plan.TAB.fld_opt(_plan.WER,'col_name=%1'[_war],PX_VAR,'WAR'+$_it);
   _help:=exec('col_help','px_plan',_it);
   _plan.TAB.fld_opt(_plan.WER,'col_help=%1'[_help],PX_VAR,'WAR'+$_it);
   ~~
!};
_plan.TAB.win_act(_plan.WER,,'Formuła','Zwiń/roz&wiń'@@,,'Zwiń/rozwiń wszystkie rekordy'@
   ,$("exec('zwrw_all','#tree',cur_tab(1,1),'PARENT','"+_plan.WER+"')"));
_bf:="
   {? cur_tab(1,1).TAB=''
   || FUN.info('Funkcja niedostępna.'@)
   || exec('select','px_poz',cur_tab(1,1).OBJ_REF,cur_tab(1,1).KONT_REF)
   ?}
";
_plan.TAB.win_act(_plan.WER,,'Formuła','Po&zycje'@@,,,_bf,,1,,,,'Z');
_f_curr:="exec('curr_cup','px_plan')";
_plan.TAB.win_act(_plan.WER,,'Formuła','&Bieżąca data'@@,,,_f_curr,,,,,,'B');
_f_godt:="
   {? cur_tab(1,1).TAB=''
   || exec('go_cup_date','px_plan')
   || exec('go_date','px_plan',cur_tab(1,1).OBJ_REF,
         {? cur_tab(1,1).TAB='PX_KONT' || cur_tab(1,1).REF || 0 ?}
      )
   ?}
";
_plan.TAB.win_act(_plan.WER,,'Formuła','&Do daty'@@,,,_f_godt,,,,,,'D');
_bf:="
   {? cur_tab(1,1).TAB='PX_KONT'
   || PX_KONT.cntx_psh();
      PX_KONT.clear();
      {? PX_KONT.seek(cur_tab(1,1).KONT_REF,)
      || exec('kont_select','px_cup',PX_KONT.ref())
      || FUN.info('Nie znaleziono zasobu.'@)
      ?};
      PX_KONT.cntx_pop();
      ~~
   || FUN.info('Funkcja niedostępna.'@)
   ?}
";
_plan.TAB.win_act(_plan.WER,,'Formuła','P&ojemniki'@@,,,_bf,,,,,,'O');
_bf:="
   {? cur_tab(1,1).TAB=''
   || FUN.info('Funkcja niedostępna.'@)
   || exec('select','px_sur',cur_tab(1,1).OBJ_REF,
         {? cur_tab(1,1).TAB='PX_KONT' || cur_tab(1,1).REF || 0 ?}
      )
   ?}
";
_plan.TAB.win_act(_plan.WER,,'Formuła','Surow&ce'@@,,,_bf,,,,,,'C');
{? _obj_name<>''
|| _formula:=$(_obj_name+'.reload()');
   _plan.TAB.win_act(_plan.WER,,'Formuła','Odświ&eż'@@,,,_formula,,,,,,'E');
   _plan.TAB.win_act(_plan.WER,1,'Formuła','Odświ&eż'@@,,,_formula,,,,,,'E')
?};
_plan.TAB.win_act(_plan.WER,,'Szukaj');
_plan.TAB.win_act(_plan.WER,,'Kolejność');
_bf:=$("exec('legenda','color','#PX_KONT#02',"+ {? _ppanel || "'PX_OBJ#02')" || "'PX_OBJ#03')" ?});
_plan.TAB.win_act(_plan.WER,,'Formuła','&Legenda'@@,,,_bf,,,,,,'L');
_plan.TAB.win_act(_plan.WER,,'Rekord',,,,$("exec('px_obj_rkprz','px_plan',"+$_ppanel+")"));
_plan.TAB.win_act(_plan.WER,,'Wyświetl',,,,"exec('px_display','px_plan')");
_fm:="{? cur_tab(1,1).RES_TYP='' || '' || 'xwin16.png:'+$exec('ikona_res','po_plan',cur_tab(1,1).RES_TYP) ?}";
_plan.TAB.win_fml(_plan.WER,,'OPIS',,'ICON_BEFORE',_fm);
_plan.TAB.win_btn(_plan.WER,'text=%1, panel=left'['Bieżąca data'@],'menu:B',,,,,,'noempty');
_plan.TAB.win_btn(_plan.WER,'text=%1, panel=left'['Do daty'@],'menu:D',,,,,,'noempty');
{? _obj_name<>''
|| _plan.TAB.win_btn(_plan.WER,'text=%1, panel=left'['Odświ&eż'@],'menu:E')
?};

:: Obsługa dnd
{? _dnd>0
|| _plan.TAB.dnd_sel(_plan.WER,,'records.'+_wid,"exec('dnd_points','px_plan')")
?};

_plan.load:="
:: Ladowanie danych do okna
:: _a - formula tworzaca tabela tymczasowa z referencjami obiektow PX_OBJ
::     (schemat tworzony w formule exec('obj_find_tab','px_obj') )
:: _b - czy odswiezac okno w grupie
:: [_c] - INTEGER - 0/[1] - czy skakac do poczatkowej daty obiektu
   .Formula:=_a;
   .Grp_disp:=_b;

   _go_cup:=1;
   {? var_pres('_c')=type_of(0)
   || _go_cup:=_c
   ?};

   _tab:=.Formula();
   PX_VAR.IL_KOL:=exec('il_kol_wide','px_plan');

   .TAB.index(.NdxO);
   .TAB.clear(); {? .TAB.first() || {! |? .TAB.PARENT:=0; .TAB.put(); .TAB.next() !} ?};
   .TAB.erase();
   {? _tab.first()
   ||
      {!
      |?
::       znajdz obiekt planistyczny
         PX_OBJ.cntx_psh();
         PX_OBJ.clear();
         {? PX_OBJ.seek(_tab.REF,)
         ||
            .TAB.blank();
            .TAB.PARENT:=0;
            .TAB.TAB:='PX_OBJ';
            .TAB.OBJ_REF:=#PX_OBJ.ref();
            .TAB.REF:=.TAB.OBJ_REF:=#PX_OBJ.ref();
            .TAB.OPIS:=PX_OBJ.SYMBOL+' - '+PX_OBJ.NAZWA;
            .TAB.RES_TYP:='';
            .TAB.add();
            _parent:=#.TAB.ref();
            _parent2:=0;
            _parent3:=0;
::          Kontenery aktywne i etapy w wyswietlanej wersji planu
            _px_kont:=exec('tree_view_obj','px_obj',PX_VAR.VIE_VER,PX_OBJ.ref(),PX_VAR.PX_SET);
            _px_kont.prefix('G');
            {? _px_kont.first()
            || {!
               |?
::                Pierwszy poziom drzewa - grupy
                  .TAB.blank();
                  .TAB.PARENT:=_parent;
                  .TAB.TAB:='PX_GRP';
                  .TAB.OBJ_REF:=#PX_OBJ.ref();
                  .TAB.GRP_REF:=_px_kont.REF_GRP;
                  .TAB.OPIS:='Grupa: '+_px_kont.SYMBOL;
                  .TAB.add();
                  _parent2:=#.TAB.ref();

                  _px_kont.cntx_psh();
                  _px_kont.prefix('S',_px_kont.UID);
                  {? _px_kont.first()
                  ||
                     {!
                     |?
::                      Drugi poziom drzewa - etapy dla obiektu
                        .TAB.blank();
                        .TAB.PARENT:=_parent2;
                        .TAB.TAB:='PX_STAGE';
                        .TAB.REF:=_px_kont.REF_STG;
                        .TAB.OBJ_REF:=#PX_OBJ.ref();
                        .TAB.GRP_REF:=_px_kont.REF_GRP;
                        .TAB.STG_REF:=_px_kont.REF_STG;
                        .TAB.OPIS:='Etap: '+_px_kont.SYMBOL;
                        .TAB.RES_TYP:=_px_kont.RES_TYP;
                        .TAB.add();
                        _parent3:=#.TAB.ref();

                        _px_kont.cntx_psh();
                        _px_kont.prefix('K',_px_kont.UID);
                        {? _px_kont.first()
                        ||
::                         Trzeci poziom drzewa - kontenery dla etapu
                           {!
                           |? .TAB.blank();
                              .TAB.PARENT:=_parent3;
                              .TAB.TAB:='PX_KONT';
                              .TAB.REF:=_px_kont.REF_KONT;
                              .TAB.GRP_REF:=_px_kont.REF_GRP;
                              .TAB.KONT_REF:=_px_kont.REF_KONT;
                              .TAB.OBJ_REF:=#PX_OBJ.ref();
                              .TAB.STG_REF:=_px_kont.REF_STG;
                              .TAB.OPIS:='Zasób: '+_px_kont.SYMBOL+' - '+_px_kont.NAZWA;
                              .TAB.RES_TYP:=_px_kont.RES_TYP;
                              .TAB.add();
                              _px_kont.next()
                           !}
                        ?};
                        _px_kont.cntx_pop();
                        _px_kont.next()
                     !}
                  ?};
                  _px_kont.cntx_pop();
                  _px_kont.next()
               !}
            ?};
::          z ostatniego kontenera ustawiany kontekst widoku
            PX_KONT.cntx_psh();
            PX_KONT.clear();
            {? PX_KONT.seek(_px_kont.REF_KONT,)
            || PX_VAR.VIE_KONT:=PX_KONT.ref()
            || PX_VAR.VIE_KONT:=null()
            ?};
            PX_KONT.cntx_pop();
            {? _go_cup>0
            ||
::             skok do poczatkowej daty obiektu
               _borders:=exec('borders','px_obj',PX_VAR.VIE_VER,PX_OBJ.ref());
               exec('go_cup_date','px_plan',_borders.OD);
               obj_del(_borders)
            ?};

            obj_del(_px_kont);
            ~~
         ||
            .TAB.PARENT:=0;
            .TAB.OPIS:='< brak obiektu planistycznego >';
            .TAB.add()
         ?};
         PX_OBJ.cntx_pop();
         _tab.next()
      !}
   ?};
   .TAB.index(.NdxP);
   .TAB.first();
   .TAB.tr_set(1,.WER,1,0);
   {? .Grp_disp || grp_disp(.TAB,.WER) ?};
   ~~
";

_plan.reload:="
:: Przeladowanie danych w oknie
:: [_a] - INTEGER - 0/[1] - czy skakac do poczatkowej daty obiektu

   _go_cup:=1;
   {? var_pres('_a')=type_of(0)
   || _go_cup:=_a
   ?};

   .load(.Formula,.Grp_disp,_go_cup)
";

_plan


\px_obj_rkprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed rekord w oknie selekcji utworzonym w formule \select_obj/px_plan
::   WE: _a - 1=widok do panalu planowania, 0=widok "luzem"
::----------------------------------------------------------------------------------------------------------------------
{? _a
|| exec('rekprzed','color','PX_OBJ#02#')
|| exec('rekprzed','color','PX_OBJ#03#')
?}


\px_obj_bre
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed rekord w oknie selekcji utworzonym w formule \select_obj/px_plan - wlasciwa obsluga
::   WE: _a - 1=widok do panalu planowania, 0=widok "luzem"
::----------------------------------------------------------------------------------------------------------------------
_ppanel:=_a;
_txt_point:=exec('txt_point','px_param');
_poi_sign:=exec('txt_point_sin','px_param');

_txt_error:=exec('txt_error','px_param');
_err_sign:=exec('txt_err_sin','px_param');
_txt_min:=exec('txt_point_min','px_param');
_txt_max:=exec('txt_point_max','px_param');

:: Ustawienie wyswietlania - pojemniki widokowe

:: czyszcze wartosci celi
{! _it:=1..PX_VAR.IL_KOL |! ($('PX_VAR.WAR'+$_it+':=\'\'; PX_VAR.KOL'+$_it+':=\'\''))() !};

PX_CUP.cntx_psh();
_start:=PX_VAR.VIE_DATE().STAMP_S;
_il_kol:=exec('il_kol','px_plan');

PX_OBJ.cntx_psh();
PX_OBJ.clear();
PX_POINT.cntx_psh();
PX_POINT.index('PX_GRP');

PX_VAR.JM:=null();

{? PX_OBJ.seek(cur_tab(1,1).OBJ_REF,)
||
   _max_cdur:=PX_VAR.OBJ_CDUR;
   _px_kont:=null();
   _px_stage:=null();
   _px_grp:=null();
   _px_obj:=PX_OBJ.ref();
   _rea_obj:=PX_OBJ.TM_REA;
   {? cur_tab(1,1).GRP_REF>0
   || _px_grp:=exec('FindAndGet','#table' ,PX_GRP
                                          ,cur_tab(1,1).GRP_REF
                                          ,exec('mask_current','px_grp')
                                          ,
                                          ,null())
   ?};
   {? cur_tab(1,1).STG_REF>0
   || _px_stage:=exec('FindAndGet','#table'  ,PX_STAGE
                                             ,cur_tab(1,1).STG_REF
                                             ,exec('mask_current','px_stage')
                                             ,
                                             ,null())
   ?};

   {? cur_tab(1,1).KONT_REF>0
   || _px_kont:=exec('FindAndGet','#table',PX_KONT
                                          ,cur_tab(1,1).KONT_REF
                                          ,exec('mask_current','px_kont')
                                          ,
                                          ,null())
   ?};
   {? cur_tab(1,1).TAB='PX_KONT'
   ||
::    Przypadek dla kontenera w widoku wg obiektow - rozwiniecie galezi
      PX_KONT.cntx_psh();
      PX_KONT.clear();
      {? PX_KONT.seek(cur_tab(1,1).REF,)
      ||
         _max_cdur:=PX_KONT.MAX_CDUR;
         {? _ppanel
         ||
::          Wybrany wymiar okresla aktywna jednostke miary
            PX_VAR.JM:=($('PX_KONT.JM'+$PxSelect.PX_WK.WYMIAR))()
         ||
::          jednostka miary z pierwszego wymiaru
            PX_VAR.JM:=PX_KONT.JM1
         ?}
      ?};
      PX_KONT.cntx_pop()
   ?};
:: Czyszcze wartosci celi - teksty i kolory
   {! _it:=1..PX_VAR.IL_KOL
   |! ($('PX_VAR.WAR'+$_it+':=\'\'; PX_VAR.KOL'+$_it+':=\'\''))()
   !};

:: Iteracja po datach widokowych - zarazem kolumnach widoku

:: Podczytuje aktualny widok planu
   PX_VAR.PX_VIEW();
   _it:=0;
   {!
   |? _it+=1;

::    Sprawdzam czy dla daty w danej kolumnie znajduja sie jakies pozycje planu
      _daty:=($('PX_VAR.DATY'+$_it))();
      _poz:='';
      _poi:='';
      _war:='';
      _err:='';
      {? _daty<>null()
      || _poz:=exec('view_chk','px_poz',PX_VAR.VIE_VER
                                       ,_daty
                                       ,'OBJ'
                                       ,_max_cdur
                                       ,_px_kont
                                       ,_px_obj
                                       ,_px_grp
                                       ,_px_stage
                                       ,PX_VAR.PX_SET
                                       )
      ?};

::    Sprawdzam czy sa jakies punkty czasowe
      {? _daty<>null() & _px_grp<>null() & _px_stage<>null()
      || _poi:=exec('view_chk','px_point',_px_grp,_px_stage,_daty)
      ?};

      {? _poz<>'' & _poi=''
      || _war:=_poz
      |? _poz='' & _poi<>''
      || _war:=_poi
      |? _poz<>'' & _poi<>''
      || _war:=_poi+(2+_poz)
      ?};

      {? _daty<>null() & _war<>'' & _px_obj<>null()
      ||
::       Sprawdzam czy wyswietlana kolumna przekracza termin realizacji obiektu
         _rea_daty:=exec('FindAndGet','#table',DATY,_daty,,"STAMP_S");
         {? _rea_obj>0 & _rea_daty>_rea_obj
         || _err:=_txt_error
         ?}
      ?};
      {? _err<>''
      || {? _war*_poi_sign>0
         || {? _war*_txt_min>0 | _war*_txt_max>0
            ||
::             Wartosc pola zawiera info i punkcie czasowym i cos jeszcze
               _war:=_poi+(2+_err)
            || _war:=_err
            ?}
         || _war:=_err
         ?}
      ?};

      ($('PX_VAR.WAR'+$_it))():=_war;

::    ustawiam kolor dla komorki
      {? _poz<>''
      || {? _war*_poi_sign>0 & _war*_err_sign=0
         ||
            _color_txt:=exec('contrast','#color',PX_OBJ.KOLOR);
::          Jesli wartosc komorki wskazuje na punkt czasowy, to kolor tekstu ustawiam
::          inny zeby byl widoczny punkt czasowy
            ($('PX_VAR.KOL'+$_it))():=_color_txt+','+PX_OBJ.KOLOR
         |? _war*_err_sign>0
         ||
::          Jesli wartosc w komorce wskazuje na problem, to kolor tekstu ustawiam
::          na czerwono
            _color_txt:='255:0:0';
            ($('PX_VAR.KOL'+$_it))():=_color_txt+','+PX_OBJ.KOLOR
         || ($('PX_VAR.KOL'+$_it))():=PX_OBJ.KOLOR+','+PX_OBJ.KOLOR
         ?}
      ?};
      _it<PX_VAR.IL_KOL
   !}
?};
PX_OBJ.cntx_pop();
PX_CUP.cntx_pop();
PX_POINT.cntx_pop();

:: Kolorowanie - jezeli kopia/symulacja to inny kolor tla
{? exec('mainversion_vie','px_ver') || '' || {? _ppanel || 'PX_OBJ#02#01' || 'PX_OBJ#03#01' ?} ?}


\select_kont
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Struktura do selekcji planowanych kontenerow
::   WE: [_a] - nazwa zmiennej, do ktorej przypisany bedzie wynik, jesli pusta, to nie zadziala czesc funkcji
::       [_b] - 1=widok do panalu planowania, 0=widok "luzem" (domyslnie)
::       [_c] - INTEGER 0/[1] - czy drag'n'drop dostepny w oknie czy nie, domyslnie tak
::   WY: _plan.TAB - tabela tymczasowa z planem
::       _plan.WER - okno tymczasowe do prezentacji danych
::       _plan.load - funkcja ladujaca dane i (opcjonalnie) odswiezajaca okno w grupie
::       _plan.reload - funkcja odswiezajaca dane i (opcjonalnie) odswiezajaca okno w grupie
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of('') || _obj_name:=_a || _obj_name:='' ?};
{? var_pres('_b')=type_of(0) || _ppanel:=_b || _ppanel:=0 ?};
{? var_pres('_c')=type_of(0) || _dnd:=_c || _dnd:=1 ?};

_plan:=obj_new('TAB','NdxP','NdxO','WER','load','reload','Formula','Grp_disp');
_plan.TAB:="tab_tmp(2,
   'PARENT'    ,'TREE_REF'    ,'Parent',
   'OPIS'      ,'STRING[100]' ,'Opis',
   'TAB'       ,'STRING[8]'   ,'Tabela źródłowa: PX_OBJ, PX_KONT',
   'REF'       ,'INTEGER'     ,'#.ref() w tabeli źródłowej (j.w.)',
   'KONT_REF'  ,'INTEGER'     ,'#.ref() PX_KONT dla PX_OBJ (parent)',
   'GRP_REF'   ,'INTEGER'     ,'#.ref() PX_GRP',
   'STG_REF'   ,'INTEGER'     ,'#.ref() PX_STAGE',
   'OBJ_REF'   ,'INTEGER'     ,'#.ref() PX_OBJ',
   'RES_TYP'   ,'STRING[1]'   ,'Typ zasobu'";
{! _it:=1..40
|! _plan.TAB+=",'KOL"+$_it+"','STRING[23]','Kolor kolumny'"
!};
_plan.TAB+=")";
_plan.TAB:=($_plan.TAB)();
_plan.TAB.fld_attr(,2);

_plan.NdxP:=_plan.TAB.index('?');
_plan.NdxO:=_plan.TAB.ndx_tmp(,,'OPIS',,);
_wid:='#px_kont_plan';
_plan.WER:=_plan.TAB.mk_sel('Plan produkcji'@,'P',0,_wid,1,,,1,,,,,1);
_plan.TAB.win_fld(_plan.WER,,'OPIS',,,27,,,'Opis'@);
_plan.TAB.win_fld(_plan.WER,PX_VAR,'JM','KOD',,5,,,'jm'@);
_il_kol:=exec('il_kol_wide','px_plan');
_area_wide:=exec('area_wide','px_plan');
_szer_kol:=floor((_area_wide/_il_kol)-1);
{! _it:=1.._il_kol
|! _plan.TAB.win_fld(_plan.WER,PX_VAR,'WAR'+$_it,,,_szer_kol,,,$_it,0);
   _war:=($('PX_VAR.TIT'+$_it))();
   _plan.TAB.fld_opt(_plan.WER,'col_name=%1'[_war],PX_VAR,'WAR'+$_it);
   _help:=exec('col_help','px_plan',_it);
   _plan.TAB.fld_opt(_plan.WER,'col_help=%1'[_help],PX_VAR,'WAR'+$_it);
   ~~
!};
_plan.TAB.win_act(_plan.WER,,'Formuła','Zwiń/roz&wiń'@@,,'Zwiń/rozwiń wszystkie rekordy'@
   ,$("exec('zwrw_all','#tree',cur_tab(1,1),'PARENT','"+_plan.WER+"')"),,,,,,'W');
_bf:="
   exec('select','px_poz',
      {? cur_tab(1,1).TAB='PX_OBJ' || cur_tab(1,1).REF || 0 ?},cur_tab(1,1).KONT_REF
   )
";
_plan.TAB.win_act(_plan.WER,,'Formuła','Po&zycje'@@,,,_bf,,1,,,,'Z');
_f_curr:="exec('curr_cup','px_plan')";
_plan.TAB.win_act(_plan.WER,,'Formuła','&Bieżąca data'@@,,,_f_curr,,,,,,'B');
_f_godt:="
   exec('go_date','px_plan',
      {? cur_tab(1,1).TAB='PX_OBJ' || cur_tab(1,1).REF || 0 ?},cur_tab(1,1).KONT_REF
   )
";
_plan.TAB.win_act(_plan.WER,,'Formuła','&Do daty'@@,,,_f_godt,,,,,,'D');
_bf:="
   PX_KONT.cntx_psh(); PX_KONT.clear();
   {? PX_KONT.seek(cur_tab(1,1).KONT_REF,)
   || exec('kont_select','px_cup',PX_KONT.ref())
   ?};
   PX_KONT.cntx_pop();
   ~~
";
_plan.TAB.win_act(_plan.WER,,'Formuła','P&ojemniki'@@,,,_bf,,,,,,'O');
_bf:="
   exec('select','px_sur',
      {? cur_tab(1,1).TAB='PX_OBJ' || cur_tab(1,1).REF || 0 ?},cur_tab(1,1).KONT_REF
   )
";
_plan.TAB.win_act(_plan.WER,,'Formuła','Surow&ce'@@,,,_bf,,,,,,'C');
{? _obj_name<>''
|| _formula:=$(_obj_name+'.reload()');
   _plan.TAB.win_act(_plan.WER,,'Formuła','Odświ&eż'@@,,,_formula,,,,,,'E');
   _plan.TAB.win_act(_plan.WER,1,'Formuła','Odświ&eż'@@,,,_formula,,,,,,'E')
?};
_plan.TAB.win_act(_plan.WER,,'Szukaj');
_plan.TAB.win_act(_plan.WER,,'Kolejność');
_bf:=$("exec('legenda','color',"+ {? _ppanel || '\'#PX_KONT#02#\'' || '\'#PX_KONT#03#\'' ?}+",'PX_KONT#02')");
_plan.TAB.win_act(_plan.WER,,'Formuła','&Legenda'@@,,,_bf,,,,,,'L');
_plan.TAB.win_act(_plan.WER,,'Rekord',,,,$("exec('px_cont_rkprz','px_plan',"+$_ppanel+")"));
_plan.TAB.win_act(_plan.WER,,'Wyświetl',,,,"exec('px_display','px_plan')");
_fm:="{? cur_tab(1,1).RES_TYP='' || '' || 'xwin16.png:'+$exec('ikona_res','po_plan',cur_tab(1,1).RES_TYP) ?}";
_plan.TAB.win_fml(_plan.WER,,'OPIS',,'ICON_BEFORE',_fm);
_plan.TAB.win_btn(_plan.WER,'text=%1, panel=left'['Bieżąca data'@],'menu:B');
_plan.TAB.win_btn(_plan.WER,'text=%1, panel=left'['Do daty'@],'menu:D');
{? _obj_name<>''
|| _plan.TAB.win_btn(_plan.WER,'text=%1, panel=left'['Odświ&eż'@],'menu:E')
?};

:: Obsługa dnd
{? _dnd>0
|| _plan.TAB.dnd_sel(_plan.WER,,'records.'+_wid,"exec('dnd_points','px_plan')")
?};

_plan.load:="
:: Ladowanie danych do okna
:: _a - formula tworzaca tabela tymczasowa z referencjami obiektow PX_OBJ
::     (schemat tworzony w formule exec('kont_find_tab','px_kont') )
:: _b - czy odswiezac okno w grupie
:: [_c] - INTEGER - 0/[1] - czy skakac do poczatkowej daty obiektu
   .Formula:=_a;
   .Grp_disp:=_b;

   _go_cup:=1;
   {? var_pres('_c')=type_of(0)
   || _go_cup:=_c
   ?};

   _tab:=.Formula();

   PX_VAR.IL_KOL:=exec('il_kol_wide','px_plan');

   .TAB.index(.NdxO);
   .TAB.clear(); {? .TAB.first() || {! |? .TAB.PARENT:=0; .TAB.put(); .TAB.next() !} ?};
   .TAB.erase();
   {? _tab.first()
   ||
      {!
      |?
::       znajdz kontener
         PX_KONT.cntx_psh();
         PX_KONT.clear();
         {? PX_KONT.seek(_tab.REF,)
         ||
            .TAB.blank();
            .TAB.PARENT:=0;
            .TAB.TAB:='PX_KONT';
            .TAB.REF:=.TAB.KONT_REF:=#PX_KONT.ref();
            .TAB.OPIS:=PX_KONT.SYMBOL+' - '+PX_KONT.NAZWA;
            .TAB.RES_TYP:=PX_KONT.PL_RES().TYP;
            .TAB.add();
            _parent:=#.TAB.ref();
            _parent2:=0;
            _parent3:=0;
::          aktywne obiekty dla kontenera w glownej wersji planu
            _px_obj:=exec('tree_view_res','px_kont',PX_KONT.ref());
            _px_obj.prefix('O');
            {? _px_obj.first()
            || {!
               |?
::                Pierwszy poziom drzewa - obiekty dla kontenera
                  .TAB.blank();
                  .TAB.PARENT:=_parent;
                  .TAB.TAB:='PX_OBJ';
                  .TAB.REF:=_px_obj.REF_OBJ;
                  .TAB.KONT_REF:=#PX_KONT.ref();
                  .TAB.OBJ_REF:=_px_obj.REF_OBJ;
                  .TAB.OPIS:='Obiekt: '+_px_obj.SYMBOL+' - '+_px_obj.NAZWA;
                  .TAB.RES_TYP:='';
                  .TAB.add();
                  _parent2:=#.TAB.ref();

                  _px_obj.cntx_psh();
                  _px_obj.prefix('G',_px_obj.UID);
                  {? _px_obj.first()
                  ||
::                   Drugi poziom drzewa - grupy
                     {!
                     |? .TAB.blank();
                        .TAB.PARENT:=_parent2;
                        .TAB.TAB:='PX_GRP';
                        .TAB.REF:=_px_obj.REF_GRP;
                        .TAB.OBJ_REF:=_px_obj.REF_OBJ;
                        .TAB.KONT_REF:=#PX_KONT.ref();
                        .TAB.GRP_REF:=_px_obj.REF_GRP;
                        .TAB.OPIS:='Grupa: '+_px_obj.SYMBOL;
                        .TAB.RES_TYP:='';
                        .TAB.add();
                        _parent3:=#.TAB.ref();

                        _px_obj.cntx_psh();
                        _px_obj.prefix('S',_px_obj.UID);
                        {? _px_obj.first()
                        ||
::                         Trzeci poziom drzewa - etapy
                           {!
                           |? .TAB.blank();
                              .TAB.PARENT:=_parent3;
                              .TAB.TAB:='PX_STAGE';
                              .TAB.REF:=_px_obj.REF_STG;
                              .TAB.STG_REF:=_px_obj.REF_STG;
                              .TAB.OBJ_REF:=_px_obj.REF_OBJ;
                              .TAB.KONT_REF:=#PX_KONT.ref();
                              .TAB.GRP_REF:=_px_obj.REF_GRP;
                              .TAB.OPIS:='Etap: '+_px_obj.SYMBOL;
                              .TAB.RES_TYP:='';
                              .TAB.add();
                              _px_obj.next()
                           !}
                        ?};
                        _px_obj.cntx_pop();
                        _px_obj.next()
                     !}
                  ?};
                  _px_obj.cntx_pop();
                  _px_obj.next()
               !}
            ?};
::          z ostatniego kontenera ustawiany kontekst widoku
            PX_VAR.VIE_KONT:=PX_KONT.ref();

::          skok do poczatkowej daty obiektu
            {? _go_cup>0
            ||
               _tm_curr:=SYSLOG.tm_stamp();
               {? PX_VAR.VIE_VER().TM_START>=_tm_curr
               || _data:=PX_VAR.VIE_VER().STARTD().DATA
               |? PX_VAR.VIE_VER().TM_END<=_tm_curr
               || _data:=PX_VAR.VIE_VER().ENDD().DATA-1
               || _data:=date()
               ?};
               exec('go_cup_date','px_plan',_data)
            ?};

            obj_del(_px_obj);
            ~~
         ||
            .TAB.PARENT:=0;
            .TAB.OPIS:='< brak zasobu planistycznego >';
            .TAB.add()
         ?};
         PX_KONT.cntx_pop();
         _tab.next()
      !}
   ?};
   .TAB.index(.NdxP);
   .TAB.first();
   .TAB.tr_set(1,.WER,1,0);
   {? .Grp_disp || grp_disp(.TAB,.WER) ?};
   ~~
";

_plan.reload:="
:: Przeladowanie danych w oknie
:: [_a] - INTEGER - 0/[1] - czy skakac do poczatkowej daty obiektu

   _go_cup:=1;
   {? var_pres('_a')=type_of(0)
   || _go_cup:=_a
   ?};

   .load(.Formula,.Grp_disp,_go_cup)
";

_plan


\px_cont_rkprz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed rekord w oknie selekcji utworzonym w formule \select_kont/px_plan
::   WE: _a - 1=widok do panalu planowania, 0=widok "luzem"
::----------------------------------------------------------------------------------------------------------------------
{? _a
|| exec('rekprzed','color','PX_KONT#02#')
|| exec('rekprzed','color','PX_KONT#03#')
?}


\px_cont_bre
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed rekord w oknie selekcji utworzonym w formule \select_kont/px_plan - wlasciwa obsluga
::   WE: _a - 1=widok do panalu planowania, 0=widok "luzem"
::----------------------------------------------------------------------------------------------------------------------
_ppanel:=_a;

_txt_nul:=exec('txt_plan_nul','px_param');
_txt_point:=exec('txt_point','px_param');
_poi_sign:=exec('txt_point_sin','px_param');

_txt_error:=exec('txt_error','px_param');
_err_sign:=exec('txt_err_sin','px_param');

_txt_min:=exec('txt_point_min','px_param');
_txt_max:=exec('txt_point_max','px_param');

PX_POINT.cntx_psh();
PX_POINT.index('PX_GRP');
PX_KONT.cntx_psh();
PX_KONT.clear();
{? PX_KONT.seek(cur_tab(1,1).KONT_REF,)
||
:: Ustawienie wyswietlania w gornej czesci okna - pojemniki widokowe
:: czyszcze wartosci celi
   {! _it:=1..PX_VAR.IL_KOL |! ($('PX_VAR.WAR'+$_it+':=\'\'; PX_VAR.KOL'+$_it+':=\'\''))() !};

:: Podczytuje aktualny widok planu
   PX_VAR.PX_VIEW();
   _it:=0;
   _max_cdur:=PX_KONT.MAX_CDUR;
   _px_grp:=null();
   _px_stage:=null();
   _px_obj:=null();
   _px_kont:=PX_KONT.ref();
   {? cur_tab(1,1).GRP_REF>0
   || _px_grp:=exec('FindAndGet','#table' ,PX_GRP
                                          ,cur_tab(1,1).GRP_REF
                                          ,exec('mask_current','px_grp')
                                          ,
                                          ,null())
   ?};
   {? cur_tab(1,1).STG_REF>0
   || _px_stage:=exec('FindAndGet','#table'  ,PX_STAGE
                                             ,cur_tab(1,1).STG_REF
                                             ,exec('mask_current','px_stage')
                                             ,
                                             ,null())
   ?};

   _txt:='';
   _obj_kolor:='';
   _rea_obj:=0;
   {? cur_tab(1,1).OBJ_REF>0
   ||
::    Galaz ktora ma PX_OBJ
      {? PX_OBJ.seek(cur_tab(1,1).OBJ_REF,)
      ||
         _px_obj:=PX_OBJ.ref();
         _rea_obj:=PX_OBJ.TM_REA;
         _obj_kolor:=PX_OBJ.KOLOR;
         PX_VAR.JM:=null();
         ~~
      ?}
   ||
::    Galaz ktora nie ma PX_OBJ - np glowna
      {? _ppanel
      ||
::       Wybrany wymiar okresla aktywna jednostke miary
         PX_VAR.JM:=($('PX_KONT.JM'+$PxSelect.PX_WK.WYMIAR))()
      ||
::       jednostka miary z pierwszego wymiaru kontenera
         PX_VAR.JM:=PX_KONT.JM1
      ?}
   ?};

   _it:=0;
   {!
   |?
      _it+=1;
::    Sprawdzam czy dla daty w danej kolumnie znajduja sie jakies pozycje planu
      _daty:=($('PX_VAR.DATY'+$_it))();

      _poz:='';
      _poi:='';
      _war:='';
      _err:='';
      {? _daty<>null()
      || _poz:=exec('view_chk','px_poz',PX_VAR.VIE_VER
                                       ,_daty
                                       ,'KONT'
                                       ,_max_cdur
                                       ,_px_kont
                                       ,_px_obj
                                       ,_px_grp
                                       ,_px_stage
                                       )
      ?};

::    Sprawdzam czy sa jakies punkty czasowe
      {? _daty<>null() & _px_grp<>null() & _px_stage<>null()
      || _poi:=exec('view_chk','px_point',_px_grp,_px_stage,_daty)
      ?};

      {? _poz<>'' & _poi=''
      || _war:=_poz
      |? _poz='' & _poi<>''
      || _war:=_poi
      |? _poz<>'' & _poi<>''
      || _war:=_poi+(2+_poz)
      ?};

      {? _daty<>null() & _war<>'' & _px_obj<>null()
      ||
::       Sprawdzam czy wyswietlana kolumna przekracza termin realizacji obiektu
         _rea_daty:=exec('FindAndGet','#table',DATY,_daty,,"STAMP_S");
         {? _rea_obj>0 & _rea_daty>_rea_obj
         || _err:=_txt_error
         ?}
      ?};
      {? _err<>''
      || {? _war*_poi_sign>0
         || {? _war*_txt_min>0 | _war*_txt_max>0
            ||
::             Wartosc pola zawiera info i punkcie czasowym i cos jeszcze
               _war:=_poi+(2+_err)
            || _war:=_err
            ?}
         || _war:=_err
         ?}
      ?};


      {? cur_tab(1,1).TAB='PX_KONT'
      ||
::       Galaz glowna czyli kontener musi miec inne kolorowanie i inne znaczki, bo jest ogolna
         {? _poz<>''
         || _war:=_txt_nul
         ?};
         {? _poz<>''
         || ($('PX_VAR.KOL'+$_it))():=exec('findtmp','#color')
         ?}
      ?};
::    ustawiam kolor dla komorki
      {? _poz<>'' & _obj_kolor<>''
      || _color_txt:=exec('contrast','#color',_obj_kolor);
         {? _war*_poi_sign>0 & _war*_err_sign=0
         ||
::          Jesli wartosc komorki wskazuje na punkt czasowy, to kolor tekstu ustawiam
::          inny zeby byl widoczny punkt czasowy
            ($('PX_VAR.KOL'+$_it))():=_color_txt+','+_obj_kolor
         |? _war*_err_sign>0
         ||
::          Jesli wartosc w komorce wskazuje na problem, to kolor tekstu ustawiam
::          na czerwono
            _color_txt:='255:0:0';
            ($('PX_VAR.KOL'+$_it))():=_color_txt+','+_obj_kolor
         || ($('PX_VAR.KOL'+$_it))():=_obj_kolor+','+_obj_kolor
         ?}
      ?};

::    Ustawiam tekst w komorce
      ($('PX_VAR.WAR'+$_it))():=_war;

      _it<PX_VAR.IL_KOL
   !}
?};

PX_KONT.cntx_pop();
PX_POINT.cntx_pop();

:: Kolorowanie - jezeli kopia/symulacja to inny kolor tla
{? exec('mainversion_vie','px_ver') || '' || {? _ppanel || 'PX_KONT#02#01' || 'PX_KONT#03#01' ?} ?}


\terminy_zkn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wyswietla i umozliwia potwierdzenie, ustawienie terminu/terminow realizacji zamowienia/pozycji zamowienia
::   WE: _a - PX_VER.ref()
::       _b - tabela tymczasowa zgodna z ZK_P.sel_aget()
::----------------------------------------------------------------------------------------------------------------------
_sel:=_b;

_tab:=tab_tmp(1,
   'SYM','STRING[20]','Symbol',
   'POZ','INTEGER','Poz.',
   'REF','INTEGER','Ref',
   'KTM','STRING[50]','Indeks',
   'N','STRING[100]','Nazwa',
   'IL','REAL','Ilość',
   'ODD','DATE','Od dnia',
   'ODT','TIME','Od godziny',
   'ODS','REAL','Od (tm_stamp)',
   'DOD','DATE','Do dnia',
   'DOT','TIME','Do godziny',
   'DOS','REAL','Do (tm_stamp)',
   'PROBLEMS','STRING[20]','Problemy'
);

ZK_N.cntx_psh(); ZK_P.cntx_psh();
PX_OBJ.cntx_psh(); PX_POZ.cntx_psh();

ZK_P.prefix();
{? _sel.first()
|| {!
   |? {? ZK_P.seek(_sel.REF)
      || PX_OBJ.index('ZK_P');
         PX_OBJ.prefix(ref_name(ZK_P.ref()),ZK_P.ref());
         {? PX_OBJ.first()
         || _is_poz:=0;
            _tab.SYM:=ZK_P.N().SYM;
            _tab.POZ:=ZK_P.POZ;
            _tab.REF:=PX_OBJ.ref();
            _tab.KTM:=ZK_P.M().KTM;
            _tab.N:=M.N;
            _tab.IL:=ZK_P.ILZ;
            PX_POZ.index('TM_VOBJ');
            PX_POZ.prefix(_a,PX_OBJ.ref());
            {? PX_POZ.first()
            || _is_poz:=1;
               _tab.ODD:=exec('tm_stamp2date','#tm_stamp',PX_POZ.TM_START);
               _tab.ODT:=exec('tm_stamp2time','#tm_stamp',PX_POZ.TM_START);
               _tab.ODS:=PX_POZ.TM_START;
               _tab.PROBLEMS:=PX_POZ.PX_GRP().PROBLEMS;
               PX_POZ.index('TM_VOBJ2');
               PX_POZ.prefix(_a,PX_OBJ.ref());
               {? PX_POZ.last()
               || _tab.DOD:=exec('tm_stamp2date','#tm_stamp',PX_POZ.TM_END);
                  _tab.DOT:=exec('tm_stamp2time','#tm_stamp',PX_POZ.TM_END);
                  _tab.DOS:=PX_POZ.TM_END
               ?};
               {? _is_poz>0 || _tab.add() ?}
            ?}
         ?}
      ?};
      _sel.next()
   !};

   _wer:=_tab.mk_sel('Proponowane terminy realizacji pozycji zamówień'@,,,'#terminy_zkn',10,10,20);
   _tab.win_fld(_wer,,'SYM',,,20,,,'Zamówienie'@);
   _tab.win_fld(_wer,,'POZ',,,-3,,1,'Poz.'@);
   _tab.win_fld(_wer,,'KTM',,,20,,1,'Indeks'@);
   _tab.win_fld(_wer,,'N',,,30,,1,'Nazwa'@);
   _tab.win_fld(_wer,,'IL',,,15,ST.DOKL,1,'Ilość'@);
   _tab.win_fld(_wer,,'ODD',,,,,1,'Od dnia'@);
   _tab.win_fld(_wer,,'ODT',,,,,1,'Od godziny'@);
   _tab.win_fld(_wer,,'DOD',,,,,0,'Do dnia'@);
   _tab.win_fld(_wer,,'DOT',,,,,0,'Do godziny'@);
   _tab.win_fld(_wer,,'PROBLEMS',,,,,1,'Problemy'@);
   _tab.win_act(_wer,,'Popraw');
   _tab.win_act(_wer,,'Formuła','Ustal &termin'@@,,,"exec('ustal_termin_zk','px_plan',cur_tab(1,1))",,1,,,,'T');
   _tab.win_act(_wer,,'Formuła','Pozy&cje'@@,,,"exec('select','px_poz',cur_tab(1,1).REF,0)",,,,,,'C');
   _tab.win_act(_wer,,'Formuła','&Zapotrzebowania'@@,,'Zapotrzebowania na surowce do symulacji'@,"exec('sel_sur_pxver','px_sur',PX_VAR.VIE_VER)",,,,,,'Z');
   _tab.win_act(_wer,,'Kolejność');
   _tab.win_sel(_wer);
   _tab.select()
?};

ZK_N.cntx_pop(); ZK_P.cntx_pop();
PX_OBJ.cntx_pop(); PX_POZ.cntx_pop();
~~


\ustal_termin_zk
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wyswietla i umozliwia potwierdzenie, ustawienie terminu/terminow realizacji zamowienia/pozycji zamowienia
::       Funkcja wykorzystywana w exec('terminy_zkn','px_plan')
::       Kontekst wywołania: rekord ZK_N
::   WE: _a - tabela tymczasowa z przeanalizowanymi pozycjami zamowienia
::----------------------------------------------------------------------------------------------------------------------
{? ZK_N.STAT_REJ='Z'
|| FUN.emsg('Zamówienie jest już zakończone. Modyfikacja terminów realizacji niedozwolona.'@);
   return()
?};
{? ZK_N.AKC='T'
|| FUN.emsg('Zamówienie jest już zaakceptowane. Modyfikacja terminów realizacji niedozwolona.'@);
   return()
?};

_choice:=FUN.choice(
   'Ustalenie wewnętrznego terminu realizacji zamówienia:\n\n\n'
   '● Osobne terminy dla pozycji zamówienia, termin dla całego\n'
   '  zamówienia najpóźniejszy z wyliczonych dla pozycji.\n\n'
   '● Jeden termin realizacji wszystkich pozycji\n'
   '  i całego zamówienia najpóźniejszy z wyliczonych dla pozycji.'@,,
   'Osobne terminy'@,'Jeden termin'@
);

_maxd:=date(0,0,0);
_maxt:=time(0,0,0);
_maxs:=0;

_a.cntx_psh();
{? _a.first()
|| {!
   |?
      {? _a.DOS>_maxs || _maxd:=_a.DOD; _maxt:=_a.DOT; _maxs:=_a.DOS ?};
      _a.next()
   !}
?};
_a.cntx_pop();
KOMM.init(250,,'Ustalanie terminów zamówienia'@);
_can_continue:=1;
{? _choice=1
|| {? FUN.ask('Wpisać terminy realizacji zamówienia i jego pozycji?'@)
   ||
      _mydo:=do_state()=0;
      {? _mydo || do() ?};

      ZK_N.DT:=_maxd;
      ZK_N.PL_DATA:=_maxd;
      ZK_N.PL_TIME:=_maxt;
      ZK_N.put();
      {? _a.first()
      || {!
         |?
            ZK_P.index('TYPN');
            ZK_P.prefix('A','Z',ZK_N.ref(),1,_a.POZ);
            {? ZK_P.first()
            || ZK_P.DT:=_a.DOD;
               ZK_P.PL_DATA:=_a.DOD;
               ZK_P.PL_TIME:=_a.DOT;
               {? exec('po_zkp_pldata','zamsiw_poz',2)>0
               || _can_continue:=ZK_P.put()
               || _can_continue:=0
               ?}
            ?};
            _a.next() & _can_continue>0
         !}
      ?};
      {? _can_continue<=0
      || undo()
      ?};
      {? _mydo || end() ?};
      ~~
   ?}
|? _choice=2
|| {? FUN.ask('Ustalić termin realizacji zamówienia i wszystkich jego pozycji na %1 %2?'@[$_maxd,$_maxt])
   ||
      _mydo:=do_state()=0;
      {? _mydo || do() ?};
      ZK_N.DT:=_maxd;
      ZK_N.PL_DATA:=_maxd;
      ZK_N.PL_TIME:=_maxt;
      ZK_N.put();
      ZK_P.index('TYPN');
      ZK_P.prefix('A','Z',ZK_N.ref(),1);
      {? ZK_P.first()
      || {!
         |?
            ZK_P.DT:=_maxd;
            ZK_P.PL_DATA:=_maxd;
            ZK_P.PL_TIME:=_maxt;
            {? exec('po_zkp_pldata','zamsiw_poz',2)>0
            || _can_continue:=ZK_P.put()
            || _can_continue:=0
            ?};
            ZK_P.next() & _can_continue>0
         !}
      ?};
      {? _can_continue<=0
      || undo()
      ?};
      {? _mydo || end() ?};
      ~~
   ?}
?};
KOMM.select();
~~


\terminy_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Wyswietla i umozliwia potwierdzenie, ustawienie terminu/terminow realizacji zlecenia/zlecen
::   WE: _a - PX_VER.ref()
::       _b - tabela tymczasowa zgodna z ZL.sel_aget()
::----------------------------------------------------------------------------------------------------------------------
_sel:=_b;

_tab:=tab_tmp(1,
   'SYMBOL','STRING[20]','Symbol zlecenia',
   'REF','INTEGER','#PX_OBJ.ref()',
   'ZL_REF','INTEGER','#ZL.ref()',
   'KTM','STRING[50]','Indeks',
   'N','STRING[100]','Nazwa',
   'IL','REAL','Ilość',
   'ODD','DATE','Od dnia',
   'ODT','TIME','Od godziny',
   'ODS','REAL','Od (tm_stamp)',
   'DOD','DATE','Do dnia',
   'DOT','TIME','Do godziny',
   'DOS','REAL','Do (tm_stamp)',
   'PROBLEMS','STRING[20]','Problemy'
);

ZL.cntx_psh();
PX_OBJ.cntx_psh();
PX_POZ.cntx_psh();

_form:="
   _tab:=_b;
   _ver:=_a;
   PX_OBJ.index('ZL');
   PX_OBJ.prefix(ZL.ref());
   {? PX_OBJ.first()
   || _is_poz:=0;
      _tab.SYMBOL:=ZL.SYM;
      _tab.REF:=#PX_OBJ.ref();
      _tab.ZL_REF:=#ZL.ref();
      _tab.KTM:=ZL.KTM().KTM;
      _tab.N:=M.N;
      _tab.IL:=ZL.IL;
      PX_POZ.index('TM_VOBJ');
      PX_POZ.prefix(_ver,PX_OBJ.ref());
      {? PX_POZ.first()
      || _is_poz:=1;
         _tab.ODD:=exec('tm_stamp2date','#tm_stamp',PX_POZ.TM_START);
         _tab.ODT:=exec('tm_stamp2time','#tm_stamp',PX_POZ.TM_START);
         _tab.ODS:=PX_POZ.TM_START;
         _tab.PROBLEMS:=PX_POZ.PX_GRP().PROBLEMS;
         PX_POZ.index('TM_VOBJ2');
         PX_POZ.prefix(_ver,PX_OBJ.ref());
         {? PX_POZ.last()
         || _tab.DOD:=exec('tm_stamp2date','#tm_stamp',PX_POZ.TM_END);
            _tab.DOT:=exec('tm_stamp2time','#tm_stamp',PX_POZ.TM_END);
            _tab.DOS:=PX_POZ.TM_END
         ?}
      ?};
      {? _is_poz>0 || _tab.add() ?}
   ?}
";

_wer:=_tab.mk_sel('Proponowane terminy realizacji zleceń'@,,,'#terminy_zl',10,10,20);
_tab.win_fld(_wer,,'SYMBOL',,,20,,1,'Zlecenie'@);
_tab.win_fld(_wer,,'KTM',,,20,,1,'Indeks'@);
_tab.win_fld(_wer,,'N',,,30,,1,'Nazwa'@);
_tab.win_fld(_wer,,'IL',,,15,ST.DOKL,1,'Ilość'@);
_tab.win_fld(_wer,,'ODD',,,,,1);
_tab.win_fld(_wer,,'ODT',,,,,1);
_tab.win_fld(_wer,,'DOD',,,,,0);
_tab.win_fld(_wer,,'DOT',,,,,0);
_tab.win_fld(_wer,,'PROBLEMS',,,,,1);
_tab.win_act(_wer,,'Popraw');
_tab.win_act(_wer,,'Formuła','Ustal &termin'@@,,,"exec('ustal_termin_zl','px_plan',cur_tab(1,1))",,1,,,,'T');
_tab.win_act(_wer,,'Formuła','&Zapotrzebowania'@@,,'Zapotrzebowania na surowce do symulacji'@,"exec('sel_sur_pxver','px_sur',PX_VAR.VIE_VER)",,,,,,'Z');
_tab.win_act(_wer,,'Formuła','Pozy&cje'@@,,,"exec('select','px_poz',cur_tab(1,1).REF,0)",,,,,,'C');
_tab.win_act(_wer,,'Kolejność');
_tab.win_sel(_wer);

ZL.clear();
{? _sel.first()
|| {!
   |? {? ZL.seek(_sel.REF)
      || {? ZL.RODZAJ='P' | ZL.RODZ_TEX='Z'
         || _form(_a,_tab)
         || ZL.cntx_psh();
            ZL.index('NRNZL');
            ZL.prefix(ZL.UNRZL);
            {? ZL.first()
            || {!
               |? _form(_a,_tab);
                  ZL.next()
               !}
            ?};
            ZL.cntx_pop()
         ?}
      ?};
      _sel.next()
   !};
   _tab.select()
?};

ZL.cntx_pop();
PX_OBJ.cntx_pop();
PX_POZ.cntx_pop();
~~


\dnd_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Obslugi d'n'd w oknach skladowych planu
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('PxSelect')>0
||
:: obsluga d'n'd w oknach "kafelkow"
::   exec('dnd_init','px_poz',PX_VAR.EDIT<>1);
:: obsluga d'n'd w oknie kontenerow widokowych
::   exec('dnd_init','px_kont',PX_VAR.EDIT<>1);
:: obsluga d'n'd w kolejce
   exec('dnd_init','px_grp')
?};
~~


\px_kont_menu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Menu uzytkownika w oknie PX_KONT.PX_WER, PX_KONT.PX_WERT (pojemnosci)
::----------------------------------------------------------------------------------------------------------------------
::exec('m_tmp','skid_mk',1,'PX_KONT');
~~


\px_kontx_menu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Menu uzytkownika w oknie szczegolowym planu wg kontenerow
::----------------------------------------------------------------------------------------------------------------------
{? cur_tab(1,1).TAB='' | cur_tab(1,1).TAB='PX_STAGE'
|| FUN.info('Funkcja niedostępna.'@)
||
::   exec('m_tmp','skid_mk',1,cur_tab(1,1).TAB);
:: Odswiezam okno kolejki
   {? var_pres('PxSelect')>100
   || {? PxSelect.Context*'WIN'=0
      || grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT)
      ?}
   ?}
?};
~~


\px_objx_menu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Menu uzytkownika w oknie szczegolowym planu wg obiektow
::----------------------------------------------------------------------------------------------------------------------
{? cur_tab(1,1).TAB='' | cur_tab(1,1).TAB='PX_STAGE'
|| FUN.info('Funkcja niedostępna.'@)
||
::   exec('m_tmp','skid_mk',1,cur_tab(1,1).TAB);
:: Odswiezam okno kolejki
   {? var_pres('PxSelect')>100 & var_pres('Pxgrp',PxSelect)>100
   || {? PxSelect.Context*'WIN'=0
      || grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT)
      ?}
   ?}
?};
~~


\px_obj_menu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Menu uzytkownika w oknie PX_OBJ.WER (obiekty do kolejki)
::----------------------------------------------------------------------------------------------------------------------
::exec('m_tmp','skid_mk',1,'PX_OBJX');
{? var_pres('PxSelect')>100
||
   {? PxSelect.Context='PX'
   || grp_disp(PxSelect.Pxgrp.TAB,PxSelect.Pxgrp.WERT)
   ?};
:: Odswiezam zakladki obiekty i zasoby
   {? PxSelect.Context*'|MENU'=0
   || grp_disp(PxSelect.Tab_OBJ.TAB,PxSelect.Tab_OBJ.WER,1,1);
      grp_disp(PxSelect.Tab_KONT.TAB,PxSelect.Tab_KONT.WER,1,1)
   ?}
?};
~~


\px_poz_menu
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Menu uzytkownika w oknie PX_POZ.KAFELEK* (pozycje planu)
::----------------------------------------------------------------------------------------------------------------------
::exec('m_tmp','skid_mk',1,'PX_POZ');
~~


\px_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Obsluga 'Wyswietl' w oknach planu szczegolowych wg obiektow i kontenerow
::----------------------------------------------------------------------------------------------------------------------
{? cur_tab(1,1).TAB='PX_OBJ'
|| PX_OBJ.cntx_psh();
   PX_OBJ.clear();
   {? PX_OBJ.seek(cur_tab(1,1).OBJ_REF,)
   ||
      PX_OBJ.win_edit('RED');
      PX_OBJ.display()
   ?};
   PX_OBJ.cntx_pop()
|? cur_tab(1,1).TAB='PX_KONT'
|| PX_KONT.cntx_psh(); PX_KONT.clear();
   {? PX_KONT.seek(cur_tab(1,1).KONT_REF,)
   || PX_KONT.win_edit('DISP');
      PX_KONT.display()
   ?};
   PX_KONT.cntx_pop()
|? cur_tab(1,1).TAB='PX_STAGE'
|| PX_STAGE.cntx_psh(); PX_STAGE.clear();
   {? PX_STAGE.seek(cur_tab(1,1).STG_REF,)
   || {? exec('is_oper_nast_time','px_param')
      || PX_STAGE.win_edit('RED_NAKL')
      || PX_STAGE.win_edit('RED')
      ?};
      PX_STAGE.display()
   ?};
   PX_STAGE.cntx_pop()
|? cur_tab(1,1).TAB='PX_GRP'
|| PX_GRP.cntx_psh(); PX_GRP.clear();
   {? PX_GRP.seek(cur_tab(1,1).GRP_REF,)
   || PX_GRP.win_edit('RED');
      PX_GRP.display()
   ?};
   PX_GRP.cntx_pop()
?};
~~


\zl_utilization
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.10]
:: OPIS: Sprawdza czy zlecenie jest zaplanowane w planie strategicznym (WPP)
::   WE: _a - ZL.ref() - zlecenie
::       [_b] - INTEGER - [0] - sprawdzać tylko w wersji głównej
::                         1 - sprawdzac we wszysktich wersjach
::       [_c] - obj_new(1), w której ustawiany jest zwrotnie znacznik potwierdzenia planu
::   WY: 0 - nie jest zaplanowane
::       1 - jest zaplanowane, są pozycje planu
::       2 - ma być zaplanowane, jest w kolejce ale nie ma jeszcze pozycji planu (plan jest nieprzeliczony)
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;

_ver_chk:=0;
{? var_pres('_b')=type_of(0)
|| _ver_chk:=_b
?};

{? var_pres('_c')=type_of(obj_new(1))
|| _confirm:=_c
|| _confirm:=obj_new(1);
   _confirm[1]:='N'
?};

_result:=0;
_mainver:=exec('get_mainversion','px_ver');

_can_continue:=0;

ZL.cntx_psh();
PX_OBJ.cntx_psh();
PX_POZ.cntx_psh();

ZL.clear();
{? ZL.seek(_zl)
||
   PX_OBJ.index('ZL');
   PX_OBJ.prefix(ZL.ref());
   {? PX_OBJ.first()
   ||
::    1. Sprawdzam powiązania pod wzgledem pozycji planu
      {? _ver_chk=0
      ||
         PX_POZ.index('TM_VOBJ');
         PX_POZ.prefix(_mainver,PX_OBJ.ref())
      || PX_POZ.index('PX_OBJ3');
         PX_POZ.prefix(PX_OBJ.ref())
      ?};
      {? PX_POZ.size()>0
      || _result:=1
      ?};
      PX_CONN.cntx_psh();
      {? _ver_chk=0
      || PX_CONN.index('VER');
         PX_CONN.prefix(_mainver,PX_OBJ.ref())
      || PX_CONN.index('PX_OBJ');
         PX_CONN.prefix(PX_OBJ.ref())
      ?};
::    2. Sprawdzam powiązania pod względem pozycji w kolejce
::    (ważne dla nieprzeliczonego planu)
      {? _result=0
      || {? PX_CONN.size()>0
         || _result:=2
         ?}
      ?};
::    3. Utalenie znacznika potwierdzenia planu
      _c_n:=_c_p:=_c_t:=0;
      {? PX_CONN.first()
      || {!
         |? _cc:=PX_CONN.PX_GRP().CONFIRM;
            {? _cc='N' || _c_n+=1
            |? _cc='P' || _c_p+=1
            |? _cc='T' || _c_t+=1
            ?};
            PX_CONN.next()
         !}
      ?};
      {? _c_n=0 & _c_p=0 & _c_t>0 & _confirm[1]='N'
      || _confirm[1]:='T'
      |? _c_p>0 | _c_t>0
      || _confirm[1]:='P'
      || _confirm[1]:='N'
      ?};
      PX_CONN.cntx_pop()
   ?};
:: Jeśli zlecenie złożone to rekurencyjnie sprawdzam też podzlecenia
   {? _result=0
   || _can_continue:=0;
      {? ZL.RODZAJ<>'P' & ZL.UNRZL<>0
      || ZL.cntx_psh();
         ZL.index('NRNZL');
         ZL.prefix(ZL.UNRZL);
         {? ZL.first()
         || {!
            |? _can_continue:=exec('zl_utilization','px_plan',ZL.ref(),,_confirm);
               ZL.next() & _can_continue=0
            !}
         ?};
         ZL.cntx_pop()
      ?};
      _result:=_can_continue
   ?}
?};
PX_POZ.cntx_pop();
PX_OBJ.cntx_pop();
ZL.cntx_pop();
_result


\zl_utilizat_sql
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.30]
:: OPIS: Sprawdza czy zlecenie zostalo zaplanowane w planie strategicznym
::   WE: _a - $ZL.ref() - SQL ref zlecenia do sprawdzenia
::   WY: 0 - w wersji glownej planu nie ma takiego zlecenia
::       1 - w wersji glownej planu znajduje sie takie zlecenie
::----------------------------------------------------------------------------------------------------------------------
_zlec_sql:=_a;
_result:=0;

_zlec_ref:=exec('FindAndGet','#table',ZL,_zlec_sql,,,null());
{? _zlec_ref<>null()
|| _result:=exec('zl_utilization','px_plan',_zlec_ref)
?};
_result


\zl_delete
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Usunięcie powiązań zlecenia z planu strategicznego (WPP)
::       UWAGA: usuwa wszystkie pozycje z wszystkich symulacji oprócz wersji głównej
::   WE: _a - ZL.ref()
::       0 - nie udało się usunąć powiązań w planie
::       1 - usunięto wszystkie powiązania w planie
::----------------------------------------------------------------------------------------------------------------------
_zl:=_a;
_mainver:=exec('get_mainversion','px_ver');

_result:=0;
_can_continue:=1;

PX_TEX.cntx_psh();
PX_OBJ.cntx_psh();
PX_GRP.cntx_psh();
ZL.cntx_psh();

PX_OBJ.index('ZL');
PX_OBJ.prefix(_zl);
{? PX_OBJ.first()
||
:: 1. Usuwam powiazania do obiektu we wszystkich wersjach poza planem głównym
   PX_VER.index('SYM');
   PX_VER.prefix(0);
   {? PX_VER.first()
   ||
      {!
      |?
::       Czyszczę powiązania w wersji planu dla danego PX_OBJ
         _can_continue:=exec('clean_from_ver','px_obj',PX_OBJ.ref(),PX_VER.ref());
         PX_VER.next() & _can_continue>0
      !}
   ?};

:: 2. Usuwam powiązania z komunikatami
   {? _can_continue>0
   || _can_continue:=exec('del_obj','px_komm',PX_OBJ.ref())
   ?};

:: 3. Usuwam powiązania między obiektami
   {? _can_continue>0
   || _can_continue:=exec('del_obj','px_con_o',PX_OBJ.ref())
   ?};

:: 4. Usuwam PX_OBJ o ile się da (nie uda się jeśli są powiązania w planie głównym, ale tak ma być)
   {? _can_continue>0
   || _can_continue:={? PX_OBJ.count() || 0 || PX_OBJ.del(,1) ?}
   ?}
?};

{? _can_continue>0
||
   PX_TEX.index('ZLASYM');
   PX_TEX.prefix(_zl);
   {? PX_TEX.first()
   || {!
      |? _can_continue:=exec('PX_TEX_delete','px_tex',PX_TEX.ref());
         PX_TEX.first() & _can_continue>0
      !}
   ?}
?};

PX_OBJ.cntx_pop();
PX_GRP.cntx_pop();
ZL.cntx_pop();
PX_TEX.cntx_pop();
{? _can_continue>0
|| _result:=1
?};
_result


\px_stat_normal
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Status planowania dla zlecenia, zamówienia, pozycji zamówienia - normalny (wartość początkowa)
::----------------------------------------------------------------------------------------------------------------------
'NORMALNY'


\px_stat_bd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Przed wyświetl dla pól: ZK_N.PX_STAT, ZK_P.PX_STAT, ZL.PX_STAT
::----------------------------------------------------------------------------------------------------------------------
''


\px_stat_fd
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.10]
:: OPIS: Format wyświetlania dla pól: ZK_N.PX_STAT, ZK_P.PX_STAT, ZL.PX_STAT
::----------------------------------------------------------------------------------------------------------------------
''


\select_grp_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Selekcja okna grupowego z kolejka i obiektami do planowania
::       Wywolanie w kontekscie panelu planowania - zaalokowana tablica PxSelect
::----------------------------------------------------------------------------------------------------------------------

:: Widok pozycji w kolejce ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
_before:="
   {? PX_VAR.EDIT=1
   ||
      _one_ver:=exec('is_one_version','px_param');
      _chk_role:=exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPLA');
      _elements:=exec('elements_table_navi','px_plan',_one_ver);
      {? _one_ver>0
      || {? _chk_role=0
         ||
::          użytkownik nie ma roli - wyłączam przyciski do przeliczania, akceptacji
            exec('set_visible_grp','#desktop','','nawigacja','4m7hj5gf3h00459d84nlcj9in707',0,_elements)
         ?};
         exec('load','#desktop','nawigacja','pxq_navi_one.dsk',,,,,_elements)

      || {? _chk_role>0
         ||
::          Jeśli użytkownik nie ma roli to nie ładuję całego pulpitu
            exec('load','#desktop','nawigacja','pxq_navi.dsk',,,,,_elements)
         ?}
      ?};
      exec('pxq_navi_opt','px_task',_one_ver)
   ?};
   grp_disp(PX_OBJ,'WER')
";
_grp:=PxSelect.Pxgrp.TAB.grp_make('Panel planowania: %1'@[PX_VAR.VIE_VER().SYMBOL],_before,'#pxgrpobjwer');
PxSelect.Pxgrp.TAB.grp_sel(_grp,,PxSelect.Pxgrp.WERT,,,,,,,,,,'maximized_with_title');
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Zaawansowanie przeliczania planu ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

{? PX_VAR.EDIT=1
|| _one_ver:=exec('is_one_version','px_param');
   PxSelect.Pxgrp.TAB.grp_splt(_grp,,'horizontal','progres',27);
   PxSelect.PXQ_NAVI:=exec('create','#desktop',PxSelect.Pxgrp.TAB,'nawigacja',_grp,2,8);

   _alert:=exec('get','#params',500355,2);
   {? _alert='T'
   ||
      _formula:="";
      {? _one_ver>0
      || _formula:=" exec('pxq_navi_opt','px_task',1);
                     ~~"
      || _formula:=" PX_TASK.prefix(PX_VAR.VER_QUE);
                     exec('pxq_navi_opt','px_task',0);
                     ~~"
      ?};
      PxSelect.Pxgrp.TAB.timer('sel',_grp,5,_formula,1)
   || {? _one_ver>0
      || _formula:=" exec('pxq_navi_opt','px_task',1);
                     ~~";
         PxSelect.Pxgrp.TAB.timer('sel',_grp,5,_formula,1)
      ?}
   ?}
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok obiektow do kolejki =--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
PxSelect.Pxgrp.TAB.grp_splt(_grp,,'vertical','obiekty');
PxSelect.Pxgrp.TAB.grp_sel(_grp,PX_OBJ,'WER','Obiekty do kolejki'@,,,,,,,,,'maximized');
PX_OBJ.win_fml('WER',PX_OBJ,'SYMBOL',,'ICON_BEFORE',"exec('icon_symbol','px_obj')");
PX_OBJ.clear();
exec('filter_all_act','px_obj');
PX_OBJ.f_first();
PX_OBJ.actions('WER',{? PX_VAR.EDIT=1 || '' || 'UD' ?});
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

:: Widok przepisow planistycznych ==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--
{? exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_PPPL') | exec('chk_role','#b__box',OPERATOR.USER,'TPP_PPS_DPPL')
|| _before:="";
   PxSelect.Pxgrp.TAB.grp_sel(_grp,PX_TEX,'WER4GRP','Przepisy planistyczne'@,,,,,_before,,,,'maximized')
?};
::--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--==--

PxSelect.Pxgrp.TAB.win_sel(_grp);

_context:=PxSelect.Context;
PxSelect.Context:=_context+'|MENU|NAV';

PxSelect.Pxgrp.TAB.select();
PxSelect.Context:=_context;
~~


\go_date
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wywoluje dialog w celu przejscia do okreslonej daty w planie
::   WE: _a - #PX_OBJ.ref() (0 - bez obiektu)
::       _b - #PX_KONT.ref() (0 - bez kontenera)
::----------------------------------------------------------------------------------------------------------------------
_start:=date(2999,0,0);
_stop:=date(0,0,0);
_ok:=0;

PX_OBJ.cntx_psh(); PX_KONT.cntx_psh();
PX_OBJ.clear(); PX_KONT.clear();
{? _a=0
||
:: widok pozycji planu dla kontenera (rozne obiekty)
   {? PX_KONT.seek(_b,)
   ||
      PX_POZ.index('TM_KONT');
      PX_POZ.prefix(_b)
   ?}
|? _b=0
||
:: widok pozycji planu dla obiektu (rozne kontenery)
   {? PX_OBJ.seek(_a,)
   ||
      PX_POZ.index('TM_VOBJ');
      PX_POZ.prefix(PX_VAR.VIE_VER,_a)
   ?}
||
:: widok pozycji planu dla kontenera i obiektu
   {? PX_OBJ.seek(_a,) & PX_KONT.seek(_b,)
   ||
      PX_POZ.index('TM_VOBJK');
      PX_POZ.prefix(PX_VAR.VIE_VER,_a,_b)
   ?}
?};
{? PX_POZ.first()
|| _start:=exec('str2date','#convert',10+tm_form(PX_POZ.TM_START));
   _ok:=1;
   {? PX_POZ.last()
   || _stop:=exec('str2date','#convert',10+tm_form(PX_POZ.TM_START))
   ?}
?};
PX_OBJ.cntx_pop(); PX_KONT.cntx_pop();

{? _ok
||
   undefine();
   define('H1',~~,%255+'Przejdź w planie do daty zgodnej z:'@);
   define('H2',~~,%255+'● '+'pierwszą pozycją planu — %1 (początek)'@[$_start]);
   define('H3',~~,%255+'● '+'ostatnią pozycją planu — %1 (koniec)'@[$_stop]);
   define('DATE',date(),%255+'● '+'podaj datę:'@);
   _rule:="'key:F2'";
   _btn:=def_btn('text=%1'['Zapisz'@],_rule);
   def_bopt(_btn,'default=1');
   _rule:=$('DEFINE.DATE:=date('+$(_start~1)+','+$(_start~2)+','+$(_start~3)+');\'key:F2\'');
   def_btn('text=%1'['Początek'@],_rule);
   _rule:=$('DEFINE.DATE:=date('+$(_stop~1)+','+$(_stop~2)+','+$(_stop~3)+');\'key:F2\'');
   def_btn('text=%1'['Koniec'@],_rule);
   _rule:="'key:Esc'";
   def_btn('text=%1'['Anuluj'@],_rule);

   {? def_edit("chk_rec()",'|--|'+FUN.TYT)
   || _data:=DEFINE.DATE; _ok:=1
   || _ok:=0
   ?};
   undefine();

   {? _ok>0
   ||
      exec('go_cup_date','px_plan',_data)
   ?}
||
   exec('go_cup_date','px_plan')
?};
~~


\res_utilization
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wyswietla wykorzystanie zasobu w planie zasobow
::   WE: _a - 0 - wyswietlanie
::            1 - sprawdza, czy jest wykorzystanie
::   WY: dla _a=0: ~~
::       dla _a=1: 1 - wykorzystany, 0 - brak zapisow
::----------------------------------------------------------------------------------------------------------------------
{? PX_KONT.PL_RES=null()
|| {? _a || 0 || ~~ ?}
|| exec('res_utilization','po_plan',_a)
?}


\px_obj_display
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wyswietla biezacy rekord PX_OBJ (obluga w zakladkach widoku szczegolowego planu wg obiektow i zasobow)
::   WE: _a - tabela, ktorej odnosi sie obsluga - cur_tab(1,1)
::----------------------------------------------------------------------------------------------------------------------
PX_OBJ.cntx_psh();
PX_OBJ.clear();
PX_OBJ.seek(_a.REF,);
exec('px_obj_display','px_obj');
PX_OBJ.cntx_pop();
~~


\ustal_termin_zl
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wyswietla i umozliwia potwierdzenie, ustawienie terminu/terminow realizacji zlecenia/zlecen
::       Funkcja wykorzystywana w exec('terminy_zl','px_plan')
::   WE: _a - tabela tymczasowa z przeanalizowanymi zleceniami
::----------------------------------------------------------------------------------------------------------------------
ZL.cntx_psh();
ZL.clear();

:: Czy to jest lista podzlecen zlecnie zlozonego (badam tylko pierwsze)
_complex:=0;
{? _a.first()
|| {? ZL.seek(_a.ZL_REF,)
   || _complex:=(ZL.NRNZL<>0)
   ?}
?};

{? _complex
||
   _choice:=FUN.choice(
      'Ustalenie wewnętrznego terminu realizacji zlecenia:\n\n\n'
      '● Osobne terminy dla podzleceń, termin dla całego\n'
      '  zlecenia najpóźniejszy z wyliczonych dla podzleceń.\n\n'
      '● Jeden termin realizacji wszystkich podzleceń\n'
      '  i całego zlecenia najpóźniejszy z wyliczonych dla podzleceń.'@,,
      'Osobne terminy'@,'Jeden termin'@
   )
||
   _choice:=3
?};

_maxd:=date(0,0,0);
_maxt:=time(0,0,0);
_maxs:=0;

_a.cntx_psh();
{? _a.first()
|| {!
   |?
      {? _a.DOS>_maxs || _maxd:=_a.DOD; _maxt:=_a.DOT; _maxs:=_a.DOS ?};
      _a.next()
   !}
?};

{? _choice=1
|| {? FUN.ask('Wpisać wewnętrzne terminy realizacji zlecenia i podzleceń?'@)
   ||
      {? _a.first()
      || {!
         |?
            {? ZL.seek(_a.ZL_REF,)
            || ZL.PL_DATA:=_a.DOD;
               ZL.PL_TIME:=_a.DOT;
               ZL.put()
            ?};
            _a.next()
         !}
      ?};

      ZL.index('UNRZL');
      ZL.prefix(ZL.NRNZL);
      {? ZL.first()
      ||
         ZL.PL_DATA:=_maxd;
         ZL.PL_TIME:=_maxt;
         ZL.put()
      ?}
   ?}
|? _choice=2
|| {? FUN.ask('Ustalić wewnętrzny termin realizacji zlecenia i wszystkich podzleceń na %1 %2?'@[$_maxd,$_maxt])
   ||
      {? _a.first()
      || {!
         |?
            {? ZL.seek(_a.ZL_REF,)
            || ZL.PL_DATA:=_maxd;
               ZL.PL_TIME:=_maxt;
               ZL.put()
            ?};
            _a.next()
         !}
      ?};

      ZL.index('UNRZL');
      ZL.prefix(ZL.NRNZL);
      {? ZL.first()
      ||
         ZL.PL_DATA:=_maxd;
         ZL.PL_TIME:=_maxt;
         ZL.put()
      ?}
   ?}
|? _choice=3
|| {? FUN.ask('Ustalić wewnętrzny termin realizacji zlecenia na %1 %2?'@[$_maxd,$_maxt])
   ||
      {? _a.first()
      || {!
         |?
            {? ZL.seek(_a.ZL_REF,)
            || ZL.PL_DATA:=_maxd;
               ZL.PL_TIME:=_maxt;
               ZL.put()
            ?};
            _a.next()
         !}
      ?}
   ?}
?};

_a.cntx_pop();
ZL.cntx_pop();
~~


\tab_obj_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wyswietlenie planu w ukladzie obiektów w osobnym oknie
::----------------------------------------------------------------------------------------------------------------------
_context:=PxSelect.Context;
PxSelect.Context:=_context+'|WIN';
PxSelect.Tab_OBJ.TAB.win_sel(PxSelect.Tab_OBJ.WER);

PX_OBJ.cntx_psh();
PX_KONT.cntx_psh();
PxSelect.Tab_KONT.TAB.cntx_psh();
PxSelect.Tab_OBJ.TAB.cntx_psh();

PxSelect.Tab_OBJ.TAB.select();

PX_OBJ.cntx_pop();
PX_KONT.cntx_pop();
PxSelect.Tab_KONT.TAB.cntx_pop();
PxSelect.Tab_OBJ.TAB.cntx_pop();

PxSelect.Context:=_context;
~~


\tab_kont_select
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Wyswietlenie planu w ukladzie zasobów w osobnym oknie
::----------------------------------------------------------------------------------------------------------------------
_context:=PxSelect.Context;
PxSelect.Context:=_context+'|WIN';
PxSelect.Tab_KONT.TAB.win_sel(PxSelect.Tab_KONT.WER);

PX_OBJ.cntx_psh();
PX_KONT.cntx_psh();
PxSelect.Tab_KONT.TAB.cntx_psh();
PxSelect.Tab_OBJ.TAB.cntx_psh();

PxSelect.Tab_KONT.TAB.select();

PX_OBJ.cntx_pop();
PX_KONT.cntx_pop();
PxSelect.Tab_KONT.TAB.cntx_pop();
PxSelect.Tab_OBJ.TAB.cntx_pop();

PxSelect.Context:=_context;
~~


\src_obj_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Aktualizacja terminow na obiektach zrodlowych dla wersji planu
::       Uzyte w formule exec('accept','px_ver')
::   WE: _a - PX_VER.ref()
::      [_b] - _args - argumenty dla funkcji raportujacej progress
::                     wynik dzialania exec('plan_progress_a','px_logix')
::----------------------------------------------------------------------------------------------------------------------
_px_ver:=_a;
_argsprog:={? _>=2 || _b || exec('plan_progress_a','px_logix') ?};

_can_continue:=1;

Cntx.psh(PX_CONN);

PX_CONN.index('VER');
PX_CONN.prefix(_px_ver);
{? PX_CONN.first()
|| {!
   |?
      _can_continue:=exec('one_conn_act','px_plan',PX_CONN.PX_OBJ,_px_ver);

::    raportuje progress
      {? _can_continue>0
      || _argsprog.PROGLOC+=1;
         _can_continue:=exec('plan_progress','px_logix',_argsprog,1)
      ?};
      _can_continue & PX_CONN.next()
   !}
?};

Cntx.pop(PX_CONN);
~~


\zgh_utilization
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Sprawdza czy przewodnik należy do zlecenia, które jest zaplanowane w planie strategicznym (WPP)
::   WE: _a - ZGH.ref() - przewodnik
::   WY: 0 - nie jest zaplanowane
::       1 - jest zaplanowane, są pozycje planu
::       2 - ma być zaplanowane, jest w kolejce ale nie ma jeszcze pozycji planu (plan jest nieprzeliczony)
::----------------------------------------------------------------------------------------------------------------------
_res:=exec('zl_utilization','px_plan',ZGH.ZLEC);
_res


\zgp_utilization
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.30]
:: OPIS: Sprawdza czy pozycja przewodnika należy do zlecenia, które jest zaplanowane w planie strategicznym (WPP)
::   WE: _a - ZGP.ref() - pozycja przewodnika
::   WY: 0 - nie jest zaplanowane
::       1 - jest zaplanowane, są pozycje planu
::       2 - ma być zaplanowane, jest w kolejce ale nie ma jeszcze pozycji planu (plan jest nieprzeliczony)
::----------------------------------------------------------------------------------------------------------------------
ZGH.cntx_psh();
_res:=exec('zl_utilization','px_plan',ZGP.NRPRZ().ZLEC);
ZGH.cntx_pop();
_res


\after_rfr_poj
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Formula po odswiezeniu w oknie zasobow na zakladce: Pojemnosci
::----------------------------------------------------------------------------------------------------------------------
PX_VAR.SEL_KONT:=PX_KONT.ref();

_il_kol:=exec('il_kol','px_plan');
_start:=PX_VAR.VIE_DATE().STAMP_S;

PX_CUP.cntx_psh();
:: Ustawienie pojemnikow skojarzonych z kafelkami
{! _it:=1.._il_kol
|! ($('PX_VAR.REA_CUP'+$_it))():=null()
!};

{? exec('cup_closest','px_plan',PX_KONT.ref(),_start,1)<>0
|| PX_VAR.REA_CUP1:=PX_CUP.ref();
   {! _it:=2.._il_kol
   |! {? PX_CUP.next()
      || ($('PX_VAR.REA_CUP'+$_it))():=PX_CUP.ref()
      ?}
   !}
?};
PX_CUP.cntx_pop();

:: Obsluga radiobuttonow kafelki:start/koniec
exec('kafelki_enable','px_plan');

:: Odswiezenie kafelkow
exec('kafelki_reload','px_plan');
~~


\after_rfr_obj
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Formula po odswiezeniu w oknie zasobow na zakladce: Obiekty
::   WE: [_a] - INTEGER - 0/[1] - robic odwiezanie kafelkow czy nie
::----------------------------------------------------------------------------------------------------------------------
_il_kol:=exec('il_kol','px_plan');
_start:=PX_VAR.VIE_DATE().STAMP_S;
_kafelki:=1;
{? var_pres('_a')=type_of(0)
|| _kafelki:=_a
?};

{? cur_tab(1,1).TAB='PX_KONT'
||
:: Stoje w drzewie na elemencie typu kontener
   PX_KONT.cntx_psh();
   PX_KONT.clear();
   {? PX_KONT.seek(cur_tab(1,1).REF,)
   || PX_VAR.SEL_KONT:=PX_KONT.ref();

::    Ustawienie pojemnikow skojarzonych z kafelkami
      PX_CUP.cntx_psh();
      {! _it:=1.._il_kol
      |! ($('PX_VAR.REA_CUP'+$_it))():=null()
      !};

      {? exec('cup_closest','px_plan',PX_KONT.ref(),_start,1)<>0
      || PX_VAR.REA_CUP1:=PX_CUP.ref();
         {! _it:=2.._il_kol
         |! {? PX_CUP.next()
            || ($('PX_VAR.REA_CUP'+$_it))():=PX_CUP.ref()
            ?}
         !}
      ?};
      PX_CUP.cntx_pop();

      {? _kafelki>0
      ||
         _infinity:=exec('infinity_array','px_kont');
         _offset:=exec('time','#tm_stamp',PX_VIEW.OFFSET);
         _cap_inf:=_infinity[PxSelect.PX_WK.WYMIAR];
         _prec:=($('PX_KONT.PREC'+$PxSelect.PX_WK.WYMIAR))();

::       Dla kafelkow na dole musze obliczyc dostepne/zajete pojemnosci
         {! _it:=1.._il_kol
         |! exec('caps_var','px_plan',_it,PX_KONT.ref(),_offset,_prec,_cap_inf,,0)
         !}
      ?};
      ~~
   || PX_VAR.SEL_KONT:=null()
   ?};
   PX_KONT.cntx_pop()
|| PX_VAR.SEL_KONT:=null()
?};

{? _kafelki>0
||
:: Obsluga radiobuttonow kafelki:start/koniec
   exec('kafelki_enable','px_plan');

:: Obsluga tabelki wymiarow
   exec('after_rfr_wym','px_plan',PX_VAR.SEL_KONT);

:: Odswiezenie kafelkow
   exec('kafelki_reload','px_plan')
?};
~~


\after_rfr_zas
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Formula po odswiezeniu w oknie zasobow na zakladce: Zasoby
::   WE: [_a] - INTEGER - 0/[1] - czy wykonywac obsluge kafelkow - odswiezanie itp
::----------------------------------------------------------------------------------------------------------------------
_il_kol:=exec('il_kol','px_plan');
_start:=PX_VAR.VIE_DATE().STAMP_S;

_kaf_rfr:=1;
{? var_pres('_a')=type_of(0)
|| _kaf_rfr:=_a
?};

PX_KONT.cntx_psh();
PX_KONT.clear();
{? PX_KONT.seek(cur_tab(1,1).KONT_REF,)
|| PX_VAR.SEL_KONT:=PX_KONT.ref();

:: Ustawienie pojemnikow skojarzonych z kafelkami
   PX_CUP.cntx_psh();
   {! _it:=1.._il_kol
   |! ($('PX_VAR.REA_CUP'+$_it))():=null()
   !};

   {? exec('cup_closest','px_plan',PX_KONT.ref(),_start,1)<>0
   || PX_VAR.REA_CUP1:=PX_CUP.ref();
      {! _it:=2.._il_kol
      |! {? PX_CUP.next()
         || ($('PX_VAR.REA_CUP'+$_it))():=PX_CUP.ref()
         ?}
      !}
   ?};
   PX_CUP.cntx_pop();

   {? var_pres('PxSelect')>100 & var_pres('PX_WK',PxSelect)>100
   ||
      _offset:=exec('time','#tm_stamp',PX_VIEW.OFFSET);
      _infinity:=exec('infinity_array','px_kont');
      _cap_inf:=_infinity[PxSelect.PX_WK.WYMIAR];
      _prec:=($('PX_KONT.PREC'+$PxSelect.PX_WK.WYMIAR))();
      _il_kol:=exec('il_kol','px_plan');
::    Dla kafelkow na dole musze obliczyc dostepne/zajete pojemnosci
      {! _it:=1.._il_kol
      |! exec('caps_var','px_plan',_it,PX_KONT.ref(),_offset,_prec,_cap_inf,,0)
      !}
   ?}
|| PX_VAR.SEL_KONT:=null()
?};
PX_KONT.cntx_pop();

{? _kaf_rfr>0
||
:: Obsluga radiobuttonow kafelki:start/koniec
   exec('kafelki_enable','px_plan');

:: Obsluga tabelki wymiarow
   exec('after_rfr_wym','px_plan',PX_VAR.SEL_KONT);

:: Odswiezenie kafelkow
   exec('kafelki_reload','px_plan')
?};
~~


\after_rfr_wym
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Obsluga tabelki z wymiarami po odswiezeniu w oknie na zakladkach: Obiekty, Zasoby
::   WE: _a - PX_KONT.ref()
::----------------------------------------------------------------------------------------------------------------------
_px_kont:=_a;

_il_kol:=exec('il_kol','px_plan');
_start:=PX_VAR.VIE_DATE().STAMP_S;

{? _px_kont<>null()
||
:: Kontener podany, wypełniam tabelke z wymiarami
   PX_KONT.cntx_psh(); PX_KONT.clear();
   {? PX_KONT.seek(_px_kont)
   ||
::    Dodanie rekordu okreslajacego wybrany wymiar dla kontenera (domyslnie 1.)
      PxSelect.PX_WK.prefix($PX_KONT.ref());
      {? ~PxSelect.PX_WK.first()
      ||
         PxSelect.PX_WK.KONTENER:=$PX_KONT.ref();
         PxSelect.PX_WK.WYMIAR:=1;
         PxSelect.PX_WK.add()
      ?};

::    Ustawienie pojemnikow skojarzonych z kafelkami (ilosc kolumn z widoku kalefkow!)
      {! _it:=1.._il_kol
      |! ($('PX_VAR.REA_CUP'+$_it))():=null()
      !};

      {? exec('cup_closest','px_plan',PX_KONT.ref(),_start,1)<>0
      || PX_VAR.REA_CUP1:=PX_CUP.ref();
         {! _it:=2.._il_kol
         |! {? PX_CUP.next()
            || ($('PX_VAR.REA_CUP'+$_it))():=PX_CUP.ref()
            ?}
         !}
      ?};

::    Utworzenie tabelki z jednostkami miary dla wymiarow i jej wyswietlenie
      PX_VAR.IL_WYM:=PX_KONT.IL_WYM;
      PxSelect.PX_WYM.erase();
      {! _it:=1..PX_KONT.IL_WYM
      |! PxSelect.PX_WYM.LP:=_it;
         PxSelect.PX_WYM.JM:=($('PX_KONT.JM'+$_it+'().KOD'))();
         PxSelect.PX_WYM.add()
      !};

::    Skoczyc do zapamietanej pozycji
      {? PxSelect.Context*'|WIN'=0
      || PxSelect.PX_WYM.find_key(PxSelect.PX_WK.WYMIAR);
         win_set('cur_row_pos='+$PxSelect.PX_WK.WYMIAR,PxSelect.PX_WYM,PxSelect.wx_WYM)
      ?};

::    Wyswietlic okno z wymiarami
      {? PxSelect.Context*'|WIN'=0
      || grp_disp(PxSelect.PX_WYM,PxSelect.wx_WYM)
      ?}
   ?};
   PX_KONT.cntx_pop();
   ~~
||
:: Kontener nie podany, czyszcze tabelke z wymiarami
:: Usuniecie powiazan z pojemnikami powiazanymi z kafelkami, bo w tym kontekscie brak kontenera
   {! _it:=1.._il_kol
   |! ($('PX_VAR.REA_CUP'+$_it))():=null()
   !};
:: Usuniecie zawartosci tabelki z jednostkami miary dla wymiarow i jej wyswietlenie
   PxSelect.PX_WYM.erase();
   {? PxSelect.Context*'|WIN'=0
   || grp_disp(PxSelect.PX_WYM,PxSelect.wx_WYM)
   ?};

:: czysci przypisania pojemnikow do zmiennej - dla obiektu nieuzywane
   {! _it:=1.._il_kol |! ($('PX_VAR.PX_CUP'+$_it+':=null()'))() !};
   ~~
?};

~~


\kafelek_ico_fil
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Formula przed ikona w kazdym z kafelkow
::   WE: _a - INTEGER - numerek kafelka
::   WY: STRING - identyfikator ikonki
::----------------------------------------------------------------------------------------------------------------------
_kafelek:=_a;

_result:='';

:: Podczytanie widoku
PX_VAR.PX_VIEW();

PX_KONT.cntx_psh();

{? PX_VAR.SEL_KONT<>null()
||
:: Podczytanie zaznaczonego kontenera
   PX_VAR.SEL_KONT();

:: Porównuje poziom widoku z poziomem pojemnikow
   _compare:=exec('level_compare','px_view',PX_KONT.MAX_CDUR,PX_VIEW.LEVEL);

   {? _compare=-1
   ||
::    Przypadek w ktorym kontener zawiera pojemniki np tygodniowe a widok jest dzienny
::    wtedy niestety nie ma sensu prefiksowanie pozycji planu tak jak jest wyswietlany widok
::    bo nie jestesmy w stanie zlapac tych pozycji planu, ktore zaczynaja sie w innych dniach
::    niz poczatek albo koniec tygodnia
::    W takim przypadku kafelki wyswietlaja pojemniki rzeczywiste - tak jak bylo przed wprowadzeniem
::    widokow planu

      _result:=exec('ico_fill','px_cup',0,PxSelect.PX_WK.WYMIAR,1,1)
   ||
      _result:=exec('ico_fill','px_cup',_kafelek,PxSelect.PX_WK.WYMIAR,0,1)
   ?}
?};
PX_KONT.cntx_pop();
_result


\dnd_points
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [17.00]
:: OPIS: Obsluga drag'n'drop na zakladce 'Obiekty','Zasoby'
::       Pozwala dla etapow ustawiac punkty czasowe
::----------------------------------------------------------------------------------------------------------------------

_records:=dnd_info('dropped_records');

_can_continue:=1;

_tab:=cur_tab(1,1);

{? _records.first()
||
:: 1. Sprawdzam czy przeciagniety zostal etap
   _tab.cntx_psh(); _tab.clear();
   {? _tab.seek(_records.REF,)
   || {? _tab.TAB='PX_STAGE'
      ||
         _src_ndx:=dnd_info('source_column_ndx');
         {? _src_ndx>2
         ||
            _src_col:=dnd_info('source_field_acronym');
::          Pobieram wartość z przeciąganej celi
            _scr_val:=($('PX_VAR.'+_src_col))();
            {? _scr_val<>''
            ||
::             Pobieram na ktora kolumne upuscilem
               _dest_col:=dnd_info('dest_column_ndx');

               {? _dest_col>2
               || _dest_date:=($('PX_VAR.DATY'+$(_dest_col-2)))();

                  {? _dest_date<>null()
                  || DATY.cntx_psh(); DATY.clear();
                     {? DATY.seek(_dest_date)
                     ||
::                      Ustawiam sie w kontekscie PX_GRP i PX_STAGE
                        PX_STAGE.cntx_psh(); PX_STAGE.clear();
                        PX_GRP.cntx_psh(); PX_GRP.clear();

                        {? PX_STAGE.seek(_tab.STG_REF,) & PX_GRP.seek(_tab.GRP_REF,)
                        || exec('edit_drop','px_point',DATY.ref(),PX_GRP.ref(),PX_STAGE.ref(),_scr_val)
                        ?};
                        PX_GRP.cntx_pop();
                        PX_STAGE.cntx_pop();
                        ~~
                     ?};
                     DATY.cntx_pop()
                  ?}
               || FUN.emsg('Aby ustalić punkt czasowy należy etap upuścić na kolumnę z datą.'@);
                  _can_continue:=0
               ?}
            || FUN.emsg('Aby ustalić punkt czasowy dla etapu, należy złapać którąś z jego pozycji planu lub znacznik istniejącego punktu.'@);
               _can_continue:=0
            ?}
         || FUN.emsg('Aby ustalić punkt czasowy dla etapu, należy złapać którąś z jego pozycji planu lub znacznik istniejącego punktu.'@);
            _can_continue:=0
         ?}
      ||
         FUN.emsg('Punkty czasowe można ustalać tylko dla etapów.'@);
         _can_continue:=0
      ?}
   ?};
   _tab.cntx_pop();
   ~~
?};
~~


\kafelki_enable
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PRIVATE
::  UTW: WH [17.00]
:: OPIS: Wlacza/wylacza radiobuttony kafelki:start/koniec na panelu nawigacyjnym w zaleznosci
::       od tego czy w oknie na kafelku jest prefiksowanie na podstawie dat, czy po staremu czyli
::       na podstawie PX_CUP
::   WE:
::   WY:
::----------------------------------------------------------------------------------------------------------------------
:: Wylaczam radiobuttony kafelki:start/koniec na panelu nawigacyjnym jesli niepotrzebne
{? PX_VAR.SEL_KONT<>null()
||
:: Porównuje poziom widoku z poziomem pojemnikow
   PX_KONT.cntx_psh();

   _compare:=exec('level_compare','px_view',PX_VAR.SEL_KONT().MAX_CDUR,PX_VIEW.LEVEL);
   {? _compare=-1
   ||
::    Przypadek w ktorym kontener zawiera pojemniki np tygodniowe a widok jest dzienny
::    wtedy kafelki wyswietlaja pojemniki a nie widokowe okresy i opcja zmiany trybu prefiskowania
::    na kafelkach traci sens
      exec('set_enabled','#desktop','','nawigacja',PxSelect.ID_KAF_S,0);
      exec('set_enabled','#desktop','','nawigacja',PxSelect.ID_KAF_E,0)
   || exec('set_enabled','#desktop','','nawigacja',PxSelect.ID_KAF_S,1);
      exec('set_enabled','#desktop','','nawigacja',PxSelect.ID_KAF_E,1)
   ?};
   PX_KONT.cntx_pop();
   ~~
|| exec('set_enabled','#desktop','','nawigacja',PxSelect.ID_KAF_S,1);
   exec('set_enabled','#desktop','','nawigacja',PxSelect.ID_KAF_E,1)
?};
~~


\navi_enable
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [12.41]
:: OPIS: Wlacza/wylacza elementy nawigacyjne na panelu nawigacyjnym
::   WE: _a - 1 wlacza, 0 wylacza
::----------------------------------------------------------------------------------------------------------------------
_on:=_a;
_one_ver:=exec('is_one_version','px_param');
exec('set_enabled','#desktop','','nawigacja','px_navi',_on);
exec('set_enabled','#desktop','','nawigacja','przelicz_one_ver',1);
exec('px_navi_opt','px_task',_one_ver);
{? _one_ver
|| {? exec('mainversion_vie','px_ver')
   || {? type_of(PxSelect.ID_SET)=type_of('')
      || exec('set_enabled','#desktop','','nawigacja',PxSelect.ID_SET,1)
      ?}
   || {? type_of(PxSelect.ID_SET)=type_of('')
      || exec('set_enabled','#desktop','','nawigacja',PxSelect.ID_SET,0)
      ?}
   ?}
?};
{? exec('is_whatif','px_ver',PX_VAR.VIE_VER)>0
|| exec('set_enabled','#desktop','','nawigacja',PxSelect.ID_VIEW,0)
?};
~~


\one_conn_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [17.00]
:: OPIS: Aktualizuje jeden zrodlowy obiekt
::       Aktualizacja dotyczy tylko obiektow powiazanych ze zleceniami nie zaplanowanymi operacyjnie
::   WE: _a - PX_OBJ.ref()
::       _b - PX_VER.ref()
::   WY: 1 / 0 - czy aktualizacja sie powiodla
::----------------------------------------------------------------------------------------------------------------------
_px_obj:=_a;
_px_ver:=_b;

Cntx.psh(PX_OBJ,ZL,ZGH,ZGP,GROP);
Cntx.clr(PX_OBJ,ZL        ,GROP);

_can_continue:=1;
{? PX_OBJ.seek(_px_obj)
||
   _zl:=PX_OBJ.ZL;
   _grop:=PX_OBJ.GROP;
   {? _zl<>null() & ~exec('zl_utilization','po_plan',1,_zl) & ZL.seek(_zl)
   ||
      _z_start:=0;
      _z_end:=0;
      {? (ZL.RODZAJ='Z') & (ZL.RODZ_TEX='Z')
      ||
         Cntx.psh(PX_OBJ,ZL,ZGH,ZGP);
         ZL.index('NRNZL'); ZL.prefix(ZL.UNRZL);
         {? ZL.first()
         ||
            _limes:=obj_new('zpstart','zpend');
            _limes.zpstart:=0; _limes.zpend:=0;
            {!
            |?
               {? ~exec('zl_utilization','po_plan',1,ZL.ref())
               || _can_continue:=exec('zgh_one_zl_act','px_plan',ZL.ref,_limes,_px_obj,_px_ver);
                  {? _can_continue>0
                  ||
                     {? _limes.zpstart=0 || ZL.STARTD:=date(0,0,0) || ZL.STARTD:=exec('tm_stamp2date','#tm_stamp',_limes.zpstart) ?};
                     {? _limes.zpstart=0 || ZL.STARTT:=time(0,0,0) || ZL.STARTT:=exec('tm_stamp2time','#tm_stamp',_limes.zpstart) ?};
                     {? _z_start=0 | _z_start>_limes.zpstart || _z_start:=_limes.zpstart ?};
                     {? _limes.zpend=0 || ZL.ENDD:=date(0,0,0) || ZL.ENDD:=exec('tm_stamp2date','#tm_stamp',_limes.zpend) ?};
                     {? _limes.zpend=0 || ZL.ENDT:=time(0,0,0) || ZL.ENDT:=exec('tm_stamp2time','#tm_stamp',_limes.zpend) ?};
                     {? _z_end=0 | _z_end<_limes.zpend || _z_end:=_limes.zpend ?};
                     _can_continue:=ZL.put()
                  ?}
               ?};
               (_can_continue>0) & ZL.next()
            !};
            obj_del(_limes)
         ?};
         Cntx.pop(PX_OBJ,ZL,ZGH,ZGP);
         {? _can_continue>0
         ||
            {? _z_start=0 || ZL.STARTD:=date(0,0,0) || ZL.STARTD:=exec('tm_stamp2date','#tm_stamp',_z_start) ?};
            {? _z_start=0 || ZL.STARTT:=time(0,0,0) || ZL.STARTT:=exec('tm_stamp2time','#tm_stamp',_z_start) ?};
            {? _z_end=0 || ZL.ENDD:=date(0,0,0) || ZL.ENDD:=exec('tm_stamp2date','#tm_stamp',_z_end) ?};
            {? _z_end=0 || ZL.ENDT:=time(0,0,0) || ZL.ENDT:=exec('tm_stamp2time','#tm_stamp',_z_end) ?};
            _can_continue:=ZL.put()
         ?}
      ||
         _limes:=obj_new('zpstart','zpend');
         _limes.zpstart:=0; _limes.zpend:=0;
         _can_continue:=exec('zgh_one_zl_act','px_plan',_zl,_limes,_px_obj,_px_ver);
         {? _can_continue>0
         ||
            {? _limes.zpstart=0 || ZL.STARTD:=date(0,0,0) || ZL.STARTD:=exec('tm_stamp2date','#tm_stamp',_limes.zpstart) ?};
            {? _limes.zpstart=0 || ZL.STARTT:=time(0,0,0) || ZL.STARTT:=exec('tm_stamp2time','#tm_stamp',_limes.zpstart) ?};
            {? _limes.zpend=0 || ZL.ENDD:=date(0,0,0) || ZL.ENDD:=exec('tm_stamp2date','#tm_stamp',_limes.zpend) ?};
            {? _limes.zpend=0 || ZL.ENDT:=time(0,0,0) || ZL.ENDT:=exec('tm_stamp2time','#tm_stamp',_limes.zpend) ?};
            _can_continue:=ZL.put()
         ?};
         obj_del(_limes)
      ?}
   |? _grop<>null() & GROP.seek(_grop) & exec('grop_tm_start','po_ogr',_grop)=0
   || PX_POZ.cntx_psh();
      _tm_start:=0;
      _tm_end:=0;
      PX_POZ.index('TM_VOBJ');
      PX_POZ.prefix(_px_ver,_px_obj);
      {? PX_POZ.first()
      || _tm_start:=PX_POZ.TM_START
      ?};
      PX_POZ.index('TM_VOBJ2');
      PX_POZ.prefix(_px_ver,_px_obj);
      {? PX_POZ.last()
      || _tm_end:=PX_POZ.TM_END
      ?};
      {? _tm_start>0
      || GROP.STARTD:=exec('tm_stamp2date','#tm_stamp',_tm_start);
         GROP.STARTT:=exec('tm_stamp2time','#tm_stamp',_tm_start)
      || GROP.STARTD:=date(0,0,0);
         GROP.STARTT:=time(0,0,0)
      ?};
      {? _tm_end>0
      || GROP.ENDD:=exec('tm_stamp2date','#tm_stamp',_tm_end);
         GROP.ENDT:=exec('tm_stamp2time','#tm_stamp',_tm_end)
      || GROP.ENDD:=date(0,0,0);
         GROP.ENDT:=time(0,0,0)
      ?};
      _can_continue:=GROP.put();
      {? _can_continue>0
      || exec('zlim_dates_upd','zl_limit',null(),GROP.ref())
      ?};
      PX_POZ.cntx_pop();
      ~~
   ?}
?};
Cntx.pop(PX_OBJ,ZL,ZGH,ZGP,GROP);
{? _can_continue>0 || 1 || 0 ?}


\zgh_one_zl_act
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WW [12.46]
:: OPIS: Aktualizacja planowanych terminow wykonania w przewodnikach zlecenia
::       Kontekst pracy - PX_CONN
::   WE: [_a] - ZL.ref()
::        _b - wektor na wyniki funkcji
::        _c - PX_OBJ.ref()
::        _d - PX_VER.ref()
::   WY: 1 - powodzenie, 0 - porazka
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<>type_of(ZL) || _a:=ZL.ref() ?};
_zl:=_a;
{? var_pres('_b')=type_of(0) || return(0) ?};
_wyn:=_b;
_px_obj:=_c;
_px_ver:=_d;
_zpstart:=_wyn.zpstart;
_zpend:=_wyn.zpend;

_can_continue:=1;
ZGH.cntx_psh();
ZGP.cntx_psh();
ZGP.index('PNRPP');
ZGH.index('ZLNR');
ZGH.prefix(_zl);
_times_start:=tab_tmp(1,'TM','REAL','Czas');
_times_end:=tab_tmp(1,'TM','REAL','Czas');
{? ZGH.first()
|| {!
   |?
      _h_start:=0;
      _h_end:=0;
::    Operacje glowne przewodnika
      ZGP.prefix(ZGH.ref(),'N');
      {? ZGP.first()
      || {!
         |?
            _startd:=date(0,0,0);
            _startt:=time(0,0,0);
            _endd:=date(0,0,0);
            _endt:=time(0,0,0);
            _px_kont:=null();

            {? ZGP.PL_GRP='T' & exec('is_grop','px_param') & exec('is_grop_member','zl_grop',ZL.ref())
            || _times_start.erase();
               _times_end.erase();
               exec('get_times_zgp','zl_grop',,2,_times_start,_px_ver);
               exec('get_times_zgp','zl_grop',,1,_times_end,_px_ver);

               {? _times_start.first()
               || _startd:=exec('tm_stamp2date','#tm_stamp',_times_start.TM);
                  _startt:=exec('tm_stamp2time','#tm_stamp',_times_start.TM);
                  {? _h_start=0 | _h_start>_times_start.TM || _h_start:=_times_start.TM ?}
               ?};
               {? _times_end.last()
               || _endd:=exec('tm_stamp2date','#tm_stamp',_times_end.TM);
                  _endt:=exec('tm_stamp2time','#tm_stamp',_times_end.TM);
                  {? _h_end=0 | _h_end<_times_end.TM || _h_end:=_times_end.TM ?}
               ?}
            ?};

            PX_POZ.index('PX_STAG5');
            PX_POZ.prefix(_px_ver,_px_obj,ZGP.PX_STAGE);
            {? PX_POZ.first()
            || _px_kont:=PX_POZ.PX_KONT;
               _startd:=exec('tm_stamp2date','#tm_stamp',PX_POZ.TM_START);
               _startt:=exec('tm_stamp2time','#tm_stamp',PX_POZ.TM_START);
               {? _h_start=0 | _h_start>PX_POZ.TM_START || _h_start:=PX_POZ.TM_START ?}
            ?};
            PX_POZ.index('PX_STAG6');
            PX_POZ.prefix(_px_ver,_px_obj,ZGP.PX_STAGE);
            {? PX_POZ.last()
            || _endd:=exec('tm_stamp2date','#tm_stamp',PX_POZ.TM_END);
               _endt:=exec('tm_stamp2time','#tm_stamp',PX_POZ.TM_END);
               {? _h_end=0 | _h_end<PX_POZ.TM_END || _h_end:=PX_POZ.TM_END ?}
            ?};

            {? ZGP.WEW='N' & ZGH.STAN<>'T' & ZGP.KOOP_AKC<>'T'
            ||
::             Nanoszenie danych do planowania dla kooperacji
               ZGP.STARTDK:=_startd;
               ZGP.STARTTK:=_startt;
               ZGP.ENDDK:=_endd;
               ZGP.ENDTK:=_endt;
               {? _px_kont<>null()
               || ZGP.PX_KONT:=_px_kont
               ?}
            ?};
            ZGP.STARTD:=_startd;
            ZGP.STARTT:=_startt;
            ZGP.ENDD:=_endd;
            ZGP.ENDT:=_endt;
            _can_continue:=ZGP.put();
::          Aktualizacja operacji Tpz
            {? _can_continue>0
            ||
               ZGP.cntx_psh();
               ZGP.index('TPZ');
               ZGP.prefix('T',ZGP.UID);
               {? ZGP.first()
               || ZGP.STARTD:=_startd;
                  ZGP.STARTT:=_startt;
                  ZGP.ENDD:=_endd;
                  ZGP.ENDT:=_endt;
                  _can_continue:=ZGP.put()
               ?};
               ZGP.cntx_pop()
            ?};
            exec('zlim_dates_upd','zl_limit',ZGP.ref());
            _can_continue>0 & ZGP.next()
         !}
      ?};
      {? _can_continue>0
      ||
         {? _h_start=0 || ZGH.STARTD:=date(0,0,0) || ZGH.STARTD:=exec('tm_stamp2date','#tm_stamp',_h_start) ?};
         {? _h_start=0 || ZGH.STARTT:=time(0,0,0) || ZGH.STARTT:=exec('tm_stamp2time','#tm_stamp',_h_start) ?};
         {? _zpstart=0 | _zpstart>_h_start || _zpstart:=_h_start ?};
         {? _h_end=0 || ZGH.ENDD:=date(0,0,0) || ZGH.ENDD:=exec('tm_stamp2date','#tm_stamp',_h_end) ?};
         {? _h_end=0 || ZGH.ENDT:=time(0,0,0) || ZGH.ENDT:=exec('tm_stamp2time','#tm_stamp',_h_end) ?};
         {? _zpend=0 | _zpend<_h_end || _zpend:=_h_end ?};
         _can_continue:=ZGH.put()
      ?};
      _can_continue>0 & ZGH.next()
   !}
?};
ZGH.cntx_pop();
ZGP.cntx_pop();
ZGP.get();
_wyn.zpstart:=_zpstart;
_wyn.zpend:=_zpend;
_can_continue


\przelicz_btn
::----------------------------------------------------------------------------------------------------------------------
:: DOST: PUBLIC
::  UTW: WH [12.41]
:: OPIS: Aktualizuje statusy przyciskow w panelu 'przeliczania pojedynczej wesji'
::----------------------------------------------------------------------------------------------------------------------
{? (PxSelect.Context*'|MENU'=0 | PxSelect.Context*'|NAV'<>0)
||
   _ico_ok:='ico_przeliczona';
   _ico_bulb:='ico_przelicz';
   _fld_status:='field_status';
   _fld_user:='field_user';

   _desk_name:='przelicz_one_ver';
   _ctr_id:='nawigacja';

   PX_VER.cntx_psh();
   USERS.cntx_psh();

:: Podczytanie wersji
   PX_VAR.VIE_VER();

   {? PX_VER.ref()=exec('get_mainversion','px_ver') | exec('is_whatif','px_ver')>0
   ||
::    Aktualizuje pulpit tylko jesli wyswietlana wersja jest wersja glowna
      _id:=_fld_user+'@'+_desk_name;
      {? PX_VER.MOD_USER<>null()
      || _user:=PX_VER.MOD_USER().DANE;
         _tm_mod:=19+tm_form(PX_VER.MOD_TM_Q);
         exec('set_value','#desktop','',_ctr_id,_id,_user+' '+_tm_mod)
      ?};

      _chk:=exec('mod_chk_queue','px_ver',PX_VAR.VIE_VER);
      {? _chk=0
      ||
::       Wersja ma nieprzeliczona kolejke
         _id:=_fld_status+'@'+_desk_name;
         exec('set_value','#desktop','',_ctr_id,_id,'wymaga przeliczenia'@);

         _id:=_ico_ok+'@'+_desk_name;
         exec('set_visible','#desktop','',_ctr_id,_id,0);
         _id:=_ico_bulb+'@'+_desk_name;
         exec('set_visible','#desktop','',_ctr_id,_id,1)
      |? _chk=1
      ||
::       Wersja ma przeliczona kolejke
         _id:=_fld_status+'@'+_desk_name;
         exec('set_value','#desktop','',_ctr_id,_id,'przeliczona'@);

         _id:=_ico_ok+'@'+_desk_name;
         exec('set_visible','#desktop','',_ctr_id,_id,1);
         _id:=_ico_bulb+'@'+_desk_name;
         exec('set_visible','#desktop','',_ctr_id,_id,0)
      ?}
   ?};
   USERS.cntx_pop();
   PX_VER.cntx_pop()
?};
~~


\view_act_queue
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podgląd kolejki w osobnym oknie
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('PxSelect')>0 & PxSelect.Context='PX'
|| exec('px_grp_select','px_grp')
|| FUN.info('Funkcja niedostępna.'@)
?};
~~


\view_act_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podgląd obiektów do kolejki w osobnym oknie
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('PxSelect')>0 & PxSelect.Context='PX'
|| exec('px_obj_select','px_obj',0)
|| FUN.info('Funkcja niedostępna.'@)
?};
~~


\view_act_queue_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podgląd kolejki i obiektów do kolejki w osobnym oknie
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('PxSelect')>0 & PxSelect.Context='PX'
|| exec('select_grp_obj','px_plan')
|| FUN.info('Funkcja niedostępna.'@)
?};
~~


\view_act_zasoby
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podgląd planu zasobów w osobnym oknie
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('PxSelect')>0
|| exec('tab_kont_select','px_plan')
|| FUN.info('Funkcja niedostępna.'@)
?};
~~


\view_act_obiekty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podgląd planu obiektów w osobnym oknie
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('PxSelect')>0
|| exec('tab_obj_select','px_plan')
|| FUN.info('Funkcja niedostępna.'@)
?};
~~


\view_act_versions
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podgląd wersji planu w osobnym oknie
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? exec('wersje_visible','px_ver')>0
||
   _actions_show:=1;
   {? var_pres('PxSelect')>100
   || _actions_show:=0
   ?};
   exec('select','px_ver',_actions_show,_actions_show,_actions_show)
|| FUN.info('Funkcja niedostępna.'@)
?};
~~


\view_act_zapotrzebowania
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podgląd zapotrzebowań w osobnym oknie
::   WE: [_a] - PX_VER.ref() - domyslnie wersja glowna planu
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')=type_of(null())
|| _px_ver:=_a
|| _px_ver:=exec('get_mainversion','px_ver')
?};
exec('sel_sur_pxver','px_sur',_px_ver);
~~


\admin_wersje
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Podgląd wersji planu
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
exec('init','tpp');
exec('select','px_ver');
''


\admin_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Aktualizacja obiektów do kolejki
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('mp_run_a','#b__box');
_args.ACT_UID:='TPP_PPS_OUPD';
_args.AKCJA:='URUCHOM';
exec('mp_run','#b__box',_args);
''


\admin_poz
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Aktualizacja pozycji - oznaczanie opóźnień
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('mp_run_a','#b__box');
_args.ACT_UID:='TPP_PPS_PUPD';
_args.AKCJA:='URUCHOM';
exec('mp_run','#b__box',_args);
''


\admin_zas
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Aktualizacja zasobów - ponowne wyliczenie pojemności
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('mp_run_a','#b__box');
_args.ACT_UID:='TPP_PPS_KUPD';
_args.AKCJA:='URUCHOM';
exec('mp_run','#b__box',_args);
''


\admin_clean
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Czyści kolejkę planu głównego i usuwa wszystkie pozycje planu
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
exec('clean_queue','px_grp',exec('get_mainversion','px_ver'));
''


\icon_before
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [17.00]
:: OPIS: Formuły na ICON_BEFORE dla okien planu strategicznego
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
PX_GRP.win_fml('WER',,'DIR',,'ICON_BEFORE',"{? fld()=1 || 'xwin16.png:22' || 'xwin16.png:85' ?}");
_formikon:="'xwin16.png:'+$exec('ikona_res','po_plan',PX_KONT.PL_RES().TYP)";
PX_KONT.win_fml('WER',,'PL_RES','TYP','ICON_BEFORE',_formikon);
PX_KONT.win_fml('WYB',,'PL_RES','TYP','ICON_BEFORE',_formikon);
PX_KONT.win_fml('SEL',,'PL_RES','TYP','ICON_BEFORE',_formikon);
PX_KONT.win_fml('SLO',,'PL_RES','TYP','ICON_BEFORE',_formikon);
PX_KONT.win_fml('PX_WER',,'SYMBOL',,'ICON_BEFORE',_formikon);
PX_KONT.win_fml('PX_WERT',,'SYMBOL',,'ICON_BEFORE',_formikon);
PX_KONT.win_fml('WYK',,'PL_RES','TYP','ICON_BEFORE',_formikon);
_formikon:="
   {? PX_KOMM.TYP=exec('type_error','px_komm')
   || 'xwin16.png:3'
   |? PX_KOMM.TYP=exec('type_warning','px_komm')
   || 'xwin16.png:4'
   |? PX_KOMM.TYP=exec('type_info','px_komm')
   || 'xwin16.png:19'
   || 'xwin16.png:110'
   ?}
";
PX_KOMM.win_fml('WER',,'MESSAGE',,'ICON_BEFORE',_formikon);
_formikon:="
   PX_KOMM.index('PX_CUP');
   PX_KOMM.prefix(PX_CUP.ref());
   {? PX_KOMM.first() || 'xwin16.png:3' || '' ?}
";
PX_CUP.win_efml('RED',,'SYMBOL',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK',PX_VAR,'CUPTITLE',,'ICON_BEFORE',_formikon);
_formikon:="{? PX_POZ.BLK='T' || 'xwin16.png:157' || 'xwin16.png:110' ?}";
PX_POZ.win_fml('KAFELEK',PX_VAR,'ICONP1',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK1',PX_VAR,'ICONP1',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK2',PX_VAR,'ICONP1',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK3',PX_VAR,'ICONP1',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK4',PX_VAR,'ICONP1',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK5',PX_VAR,'ICONP1',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK6',PX_VAR,'ICONP1',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK7',PX_VAR,'ICONP1',,'ICON_BEFORE',_formikon);
PX_POZ.win_efml('RED',PX_VAR,'ICONP1',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('WER_K',PX_VAR,'ICONP1',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('WER_KO',PX_VAR,'ICONP1',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('WER_O',PX_VAR,'ICONP1',,'ICON_BEFORE',_formikon);
_formikon:="{? PX_POZ.SRC_OPER='T' || exec('pl_plan','icon') || exec('pusta','#icon') ?}";
PX_POZ.win_fml('KAFELEK',PX_VAR,'ICONP2',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK1',PX_VAR,'ICONP2',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK2',PX_VAR,'ICONP2',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK3',PX_VAR,'ICONP2',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK4',PX_VAR,'ICONP2',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK5',PX_VAR,'ICONP2',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK6',PX_VAR,'ICONP2',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK7',PX_VAR,'ICONP2',,'ICON_BEFORE',_formikon);
PX_POZ.win_efml('RED',PX_VAR,'ICONP2',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('WER_K',PX_VAR,'ICONP2',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('WER_KO',PX_VAR,'ICONP2',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('WER_O',PX_VAR,'ICONP2',,'ICON_BEFORE',_formikon);
_formikon:="{? PX_POZ.KOOP='T' || 'xwin16.png:90' || 'xwin16.png:110' ?}";
PX_POZ.win_fml('KAFELEK',PX_VAR,'ICONP3',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK1',PX_VAR,'ICONP3',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK2',PX_VAR,'ICONP3',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK3',PX_VAR,'ICONP3',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK4',PX_VAR,'ICONP3',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK5',PX_VAR,'ICONP3',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK6',PX_VAR,'ICONP3',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK7',PX_VAR,'ICONP3',,'ICON_BEFORE',_formikon);
PX_POZ.win_efml('RED',PX_VAR,'ICONP3',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('WER_K',PX_VAR,'ICONP3',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('WER_KO',PX_VAR,'ICONP3',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('WER_O',PX_VAR,'ICONP3',,'ICON_BEFORE',_formikon);
_formikon:="exec('ico_px_poz','px_mat')";
PX_POZ.win_fml('KAFELEK',PX_VAR,'ICONP4',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK1',PX_VAR,'ICONP4',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK2',PX_VAR,'ICONP4',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK3',PX_VAR,'ICONP4',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK4',PX_VAR,'ICONP4',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK5',PX_VAR,'ICONP4',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK6',PX_VAR,'ICONP4',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('KAFELEK7',PX_VAR,'ICONP4',,'ICON_BEFORE',_formikon);
PX_POZ.win_efml('RED',PX_VAR,'ICONP4',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('WER_K',PX_VAR,'ICONP4',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('WER_KO',PX_VAR,'ICONP4',,'ICON_BEFORE',_formikon);
PX_POZ.win_fml('WER_O',PX_VAR,'ICONP4',,'ICON_BEFORE',_formikon);

_formikon:="
   {? PX_VAR.POI_MAX<>'' & PX_VAR.POI_TYP='A'
   || 'xwin16.png:134'
   |? PX_VAR.POI_MAX<>'' & (PX_VAR.POI_TYP='R' | PX_VAR.POI_TYP='P')
   || 'xwin16.png:133'
   || exec('pusta','#icon')
   ?}
";
PX_STAGE.win_fml('PX_POI',PX_VAR,'POI_MAX',,'ICON_BEFORE',_formikon);
PX_STAGE.win_fml('PX_SET',PX_VAR,'POI_MAX',,'ICON_BEFORE',_formikon);
_formikon:="
   {? PX_VAR.POI_MIN<>'' & PX_VAR.POI_TYP='A'
   || 'xwin16.png:134'
   |? PX_VAR.POI_MIN<>'' & (PX_VAR.POI_TYP='R' | PX_VAR.POI_TYP='P')
   || 'xwin16.png:133'
   || exec('pusta','#icon')
   ?}
";
PX_STAGE.win_fml('PX_POI',PX_VAR,'POI_MIN',,'ICON_BEFORE',_formikon);
PX_STAGE.win_fml('PX_SET',PX_VAR,'POI_MIN',,'ICON_BEFORE',_formikon);
~~


\elements_table_navi
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [18.22]
:: OPIS: Zwraca przetłumaczoną tablicę elementów pulpitu
::   WE: _a - INTEGER - czy praca na jednej wersji
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());

_one_ver:=_a;

_elements:=exec('elements_table','#desktop');

_elements.blank();
_elements.ID_SYS:='label_view@px_navi';
_elements.NAME:='Widok'@;
_elements.add();

_elements.blank();
_elements.ID_SYS:='label_set@px_navi';
_elements.NAME:='Zestaw'@;
_elements.add();

_elements.blank();
_elements.ID_SYS:='radio_start@px_navi';
_elements.NAME:='kafelki: start'@;
_elements.add();

_elements.blank();
_elements.ID_SYS:='radio_end@px_navi';
_elements.NAME:='kafelki: koniec'@;
_elements.add();

{? _one_ver>0
||
   _elements.blank();
   _elements.ID_SYS:='btn_przelicz@przelicz_one_ver';
   _elements.NAME:='Przelicz plan'@;
   _elements.add();

   _elements.blank();
   _elements.ID_SYS:='btn_whatif@przelicz_one_ver';
   _elements.NAME:='Symulacja what-if'@;
   _elements.add();

   _elements.blank();
   _elements.ID_SYS:='lbl_status@przelicz_one_ver';
   _elements.NAME:='Status kolejki'@;
   _elements.add();

   _elements.blank();
   _elements.ID_SYS:='lbl_mod@przelicz_one_ver';
   _elements.NAME:='Ostatnio modyfikował kolejkę:'@;
   _elements.add()
||
   _elements.blank();
   _elements.ID_SYS:='btn_que_akc@px_navi';
   _elements.NAME:='Akceptuj kolejkę'@;
   _elements.add();

   _elements.blank();
   _elements.ID_SYS:='btn_que_akc@px_navi';
   _elements.NAME:='Akceptuj kolejkę'@;
   _elements.add();

   _elements.blank();
   _elements.ID_SYS:='btn_cancel@px_navi';
   _elements.NAME:='Przerwij'@;
   _elements.add();

   _elements.blank();
   _elements.ID_SYS:='btn_akc@px_navi';
   _elements.NAME:='Akceptuj plan'@;
   _elements.add();

   _elements.blank();
   _elements.ID_SYS:='progress@px_navi';
   _elements.NAME:='Przeliczanie w tle'@;
   _elements.add();

   _elements.blank();
   _elements.ID_SYS:='req_start@px_navi';
   _elements.NAME:='Żądanie uruchomienia'@;
   _elements.add();

   _elements.blank();
   _elements.ID_SYS:='req_stop@px_navi';
   _elements.NAME:='Żądanie przerwania'@;
   _elements.add();

   _elements.blank();
   _elements.ID_SYS:='status_run@px_navi';
   _elements.NAME:='Uruchomione'@;
   _elements.add();

   _elements.blank();
   _elements.ID_SYS:='status_done@px_navi';
   _elements.NAME:='Przeliczono'@;
   _elements.add();

   ~~
?};

_debug:=0;

{? _debug>0
|| {? _elements.first()
   || {!
      |?
         _elements.NAME:='1'+_elements.NAME;
         _elements.put();
         _elements.next()
      !}
   ?}
?};
_elements


\admin_cup
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [18.42]
:: OPIS: Aktualizacja pojemników
::  TAG: <MBUILDER>
::----------------------------------------------------------------------------------------------------------------------
_args:=exec('mp_run_a','#b__box');
_args.ACT_UID:='TPP_PPS_CUPD';
_args.AKCJA:='URUCHOM';
exec('mp_run','#b__box',_args);
''


\select_plan_zkn
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Funkcja, która pokazuje jak zaplanowane są poszczególne pozycje zamówienia/zamówień
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());
exec('select_plan_zkn_init','px_plan');
_tab:=_env.PX.TAB;

_zk_n:=ZK_N.ref();
PX_VAR.ZNACZNIK:=exec('txt_plan_nul','px_param');

_mainversion:=exec('get_mainversion','px_ver');

{? ZK_N.sel_size()=0 || _tab.erase() ?};

ZK_N.cntx_psh(); ZK_P.cntx_psh();
ZK_P.index('NAG');
ZK_P.prefix(_zk_n);
SM.cntx_psh();
{? ZK_P.first()
|| {!
   |?
      _can_add:=0;
      {? ZK_P.M().RODZ='T' & 'PW'*ZK_P.M().R>0
      || _can_add:=1
      ?};

      {? _can_add>0
      ||
         _tab.blank();
         _tab.SYM:=ZK_N.SYM;
         _tab.POZ:=ZK_P.POZ;
         _tab.ZKP_REF:=$ZK_P.ref();
         _tab.ZKN_REF:=$ZK_N.ref();
         _tab.KTM:=ZK_P.M().KTM;
         _tab.M_REF:=$M.ref();
         _tab.KTM_NAZ:=M.N;
         _tab.DT:=ZK_P.DT;
         _tab.ILZ:=ZK_P.ILP-ZK_P.ILRB;
         _tab.DIR:=ZK_P.PL_DIR;
         _tab.KOLOR:=ZK_N.KOLOR;
         _tab.KH_KOD:=ZK_N.KH().KOD;
         _tab.KH_SKR:=ZK_N.KH().SKR;
         _tab.ILZPX:=exec('zkp_planned','px_obj',ZK_P.ref(),_mainversion);
         _tab.ILZPO:=exec('zam_planned','po_plan',$ZK_P.ref());

         {? ZK_P.RODZ='Z'
         ||
::          Zamówienie sprzedaży
            exec('zwr_stan','magazyn_stan',ZK_P.M,4,null(),0);
            _tab.SM:=BEER.SD;
            _tab.D:=BEER.WDR
         |? ZK_P.RODZ='W'
         ||
::          Zamówienie wewnętrzne
            exec('zwr_stan','magazyn_stan',ZK_P.M,10,null(),0);
            _tab.SM:=BEER.SD;
            _tab.D:=BEER.WDR
         ?};
         ZLZAM.index('ZMZL');
         ZLZAM.prefix($ZK_P.ref());
         {? ZLZAM.first()
         || {!
            |? _tab.ILZL+=ZLZAM.ILZL;
               _px:=exec('zl_planned','px_obj',ZLZAM.ZL,_mainversion);
               _po:=exec('zlec_planned','po_plan',$ZLZAM.ZL);
               {? _po>0
               || _tab.ILZLPL:=1
               |? _px>0
               || _tab.ILZLPL:=1
               ?};
               ZLZAM.next()
            !}
         ?};
         {? _tab.ILZ>0
         || _tab.add()
         ?}
      ?};
      ZK_P.next()
   !}
?};
ZK_N.cntx_pop(); ZK_P.cntx_pop();
SM.cntx_pop();

{? ZK_N.sel_size()=0
|| _tab.hdr_sel();
   _tab.hdr_sel('Pozycje zamówienia'@);
   {? _tab.size()>0
   || _tab.select()
   || FUN.info(exec('msg_zkn_empty','px_plan',1))
   ?}
?};
~~


\select_plan_zkn_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Funkcja, która pokazuje jak zaplanowane są poszczególne pozycje zamówienia/zamówień (przed grupą rekordów)
::----------------------------------------------------------------------------------------------------------------------
params_set(params_get());
exec('select_plan_zkn_init','px_plan');
params_get().env.PX.TAB.erase();
1


\select_plan_zkn_ag
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Funkcja, która pokazuje jak zaplanowane są poszczególne pozycje zamówienia/zamówień (po grupie rekordów)
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
params_set(params_get());
_tab:=_env.PX.TAB;
_tab.hdr_sel();
_tab.hdr_sel('Pozycje zamówień'@);
{? _tab.size()>0
|| _tab.select()
||
   FUN.info(exec('msg_zkn_empty','px_plan',2))
?};
~~


\msg_zkn_empty
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [19.02]
:: OPIS: Zwraca komunikat że nie ma co symulować
::   WE: _a - INTEGER - 1/2 - tryb 1 - pojedyncze zamówienie, 2 - grupowe zaznacznie
::   WY: STRING
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------

_mode:=_a;
_prfx:='';
{? _mode=1
|| _prfx:='Wybrane zamówienie nie posiada żadnych pozycji'@
|? _mode=2
|| _prfx:='Nie zaznaczono żadnych zamówień'@
?};

_msg:='%1 możliwych do symulowania w planie produkcji.\n\n'
         'Zamówienie do symulacji musi posiadać przynajmniej jedną pozycję:\n'
         '1. Nie zrealizowaną w całości\n'
         '2. Nie zarezerwowaną w całości bezwarunkowo na magazynach\n'
         '3. Z indeksem materiałowym rodzaju: wyrób lub półfabrykat.'@[_prfx];
_msg


\select_plan_zkn_init
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Inicjuje środowisko
::----------------------------------------------------------------------------------------------------------------------
_env:=params_get().env;
{? var_pres('PX',_env)<100
|| _env.PX:=obj_new('TAB','WER','TAB_WDR','WER_WDR','INFZAM');
   _env.PX.TAB_WDR:=tab_tmp(1
      ,'MAG','STRING[8]',''
      ,'OP','STRING[255]',''
      ,'IL','REAL',''
   );
   _env.PX.WER_WDR:=_env.PX.TAB_WDR.mk_sel('Ilość w drodze'@,'T',,'#zam_planaccx3',,,,,'U');
   _env.PX.TAB_WDR.win_fld(_env.PX.WER_WDR,,'MAG',,,8,,1,'Magazyn'@);
   _env.PX.TAB_WDR.win_fld(_env.PX.WER_WDR,,'OP',,,40,,1,'Informacje'@);
   _env.PX.TAB_WDR.win_fld(_env.PX.WER_WDR,,'IL',,,18,3,1,'Ilość w drodze'@);
   _env.PX.TAB_WDR.win_sel(_env.PX.WER_WDR);

   _tab:=_env.PX.TAB:=tab_tmp(2
      ,'SYM','STRING[20]','Zamówienie'@
      ,'POZ','INTEGER','Pozycja'@
      ,'ZKP_REF','STRING[16]','$ZK_P.ref()'
      ,'ZKN_REF','STRING[16]','$ZK_N.ref()'
      ,'M_REF','STRING[16]','$M.ref()'
      ,'KTM','STRING[50]','Indeks'@
      ,'KTM_NAZ','STRING[200]','Nazwa indeksu'@
      ,'DT','DATE','Termin realizacji'@
      ,'ILZ','REAL','Zamówione'@
      ,'SM','REAL','W magazynach'@
      ,'D','REAL','W drodze'@
      ,'DIR','INTEGER','Zwrot'@
      ,'KOLOR','STRING[11]','Kolor'@
      ,'KH_KOD','STRING[20]','Kod kontrahenta'@
      ,'KH_SKR','STRING[20]','Skrót kontrahenta'@
      ,'ILZPX','REAL','W planie strateg.'@
      ,'ILZPO','REAL','W planie oper.'@
      ,'ILZL','REAL','Zlecone'@
      ,'ILZLPL','REAL','Zlecone i zaplanowane'@
   );

   _formula:="{? fld()=0 || 'empty=1' || 'empty=0' ?}";
   _tab.fld_fml('ILZPX','DISPLAY_FORMAT',_formula);
   _tab.fld_fml('ILZPO','DISPLAY_FORMAT',_formula);
   _tab.fld_fml('ILZL','DISPLAY_FORMAT',_formula);
   _tab.fld_fml('ILZLPL','DISPLAY_FORMAT',_formula);
   _tab.fld_fml('SM','DISPLAY_FORMAT',_formula);
   _tab.fld_fml('D','DISPLAY_FORMAT',_formula);

   _wer:=_env.PX.WER:=_tab.mk_sel(,,,'#plan_zkn',,,,,'U',,,,,'html_maximized');
   _tab.win_fld(_wer,,'SYM',,,-10);
   _tab.win_fld(_wer,,'POZ',,,-5);
   _tab.win_fld(_wer,,'KTM',,,-20);
   _tab.win_fld(_wer,PX_VAR,'ZNACZNIK',,,-5,,,'Zwrot'@);
   _tab.win_fld(_wer,,'DT',,,-10);
   _tab.win_fld(_wer,,'ILZ',,,-15,ST.DOKL);
   _tab.win_fld(_wer,,'ILZPX',,,-15,ST.DOKL);
   _tab.win_fld(_wer,,'ILZPO',,,-15,ST.DOKL);
   _tab.win_fld(_wer,,'ILZL',,,-15,ST.DOKL);
   _tab.win_fld(_wer,,'ILZLPL',,,-15,,,,,,2,,"1","0");
   _tab.win_fld(_wer,,'SM',,,-15,ST.DOKL);
   _tab.win_fld(_wer,,'D',,,-15,ST.DOKL);

   _formula:="
      _tab:=tab_tmp(1,'REF','INTEGER','#ZK_P.ref()');
      _sel:=cur_tab(1,1);
      _sel.cntx_psh();
      _sel.prefix();
      {? _sel.first()
      || {!
         |? _tab.blank();
            _tab.REF:=BIT.sqlint(_sel.ZKP_REF);
            _tab.add();
            _sel.next()
         !};
         exec('zkp_simulation2','px_logix',_tab)
      || FUN.emsg('Brak zamówień do symulowania'@)
      ?};
      _sel.cntx_pop();
      ~~
   ";
   _tab.win_act(_wer,,'Formuła','Symuluj &wszystko'@@,,,_formula,,,,,,'W');
   _tab.win_btn(_wer,'text=%1,panel=bottom,align=begin'['Symuluj &wszystko'@],'menu:W');

   _formula:="
      _tab:=tab_tmp(1,'REF','INTEGER','#ZK_P.ref()');
      _tab.REF:=BIT.sqlint(cur_tab(1,1).ZKP_REF);
      _tab.add();
      exec('zkp_simulation2','px_logix',_tab);
      ~~
   ";
   _formula_bg:="
      _tab:=tab_tmp(1,'REF','INTEGER','#ZK_P.ref()');
      _sel:=cur_tab(1,1).sel_aget();
      {? _sel.first()
      || {!
         |? _zkp:=exec('FindAndGet','#table',cur_tab(1,1),_sel.REF,,\"ZKP_REF\",'');
            _tab.REF:=BIT.sqlint(_zkp);
            _tab.add();
            _sel.next()
         !};
         exec('zkp_simulation2','px_logix',_tab)
      ?};
      cur_tab(1,1).sel_adel();
      0
   ";
   _tab.win_act(_wer,,'Formuła','S&ymuluj zamówienie'@@,,,_formula,,1,1,_formula_bg,,'Y');
   _tab.win_btn(_wer,'text=%1,panel=right,align=begin'['S&ymuluj zamówienie'@],'menu:Y');

   _formula:="
      _tab:=cur_tab(1,1);
      ZK_N.cntx_psh(); ZK_P.cntx_psh();
      ZK_N.use(ref_name(_tab.ZKN_REF)); ZK_P.use(ref_name(_tab.ZKP_REF));
      ZK_N.clear(); ZK_P.clear();

      {? ZK_N.seek(_tab.ZKN_REF) & ZK_P.seek(_tab.ZKP_REF)
      || {? ZK_N.LIM='T'
         || FUN.info('Zamówienie wygenerowane na podstawie limitów zleceń — nie można modyfikować.'@)
         |? ZK_N.STAT_REJ='Z'
         || FUN.emsg('Zamówienie jest już zakończone. Modyfikacja terminów realizacji niedozwolona.'@)
         |? ZK_N.AKC='T'
         ||  FUN.emsg('Zamówienie jest już zaakceptowane. Modyfikacja terminów realizacji niedozwolona.'@)
         || {? ZK_N.r_lock(1,1,1)
            || _can_continue:=1;
               _before:=ZK_N.DT;
               ZK_N.DT:=date(0,0,0);
               ZK_N.put();
               D_HELP.M_ZKP:=ZK_P.M().KTM;
               {? exec('pop_pozy','zamsiw_poz',1)
               || ZK_P.get();
                  _tab.DT:=ZK_P.DT;
                  _tab.DIR:=ZK_P.PL_DIR;
                  _tab.put()
               || _can_continue:=0
               ?};
               ZK_N.DT:=_before;
               {? _can_continue>0
               ||
                  _max_dt:=date(0,0,0);
                  _max_pl:=0;
                  ZK_P.cntx_psh();
                  ZK_P.index('TYPN');
                  ZK_P.prefix('A','Z',ZK_N.ref(),1);
                  {? ZK_P.first()
                  || {!
                     |? {? ZK_P.DT>_max_dt
                        || _max_dt:=ZK_P.DT
                        ?};
                        _tm_stamp:=exec('create','#tm_stamp',ZK_P.PL_DATA,ZK_P.PL_TIME);
                        {? _tm_stamp>_max_pl
                        || _max_pl:=_tm_stamp
                        ?};
                        ZK_P.next()
                     !}
                  ?};
                  {? _max_dt>date(0,0,0)
                  || ZK_N.DT:=_max_dt
                  ?};
                  {? _max_pl>0
                  || ZK_N.PL_DATA:=exec('tm_stamp2date','#tm_stamp',_max_pl);
                     ZK_N.PL_TIME:=exec('tm_stamp2time','#tm_stamp',_max_pl)
                  ?};
                  ZK_P.cntx_pop()
               ?};
               ZK_N.put();
               ZK_N.r_unlock()
            || FUN.info('Zamówienie redagowane przez innego użytkownika — nie można modyfikować.'@)
            ?}
         ?}
      ?};

      ZK_N.cntx_pop(); ZK_P.cntx_pop();
      ~~
   ";
   _tab.win_act(_wer,,'Formuła','Popraw &termin'@@,,,_formula,,,,,,'T');
   _tab.win_btn(_wer,'text=%1,panel=right,align=begin'['Popraw &termin'@],'menu:T');

   _tab.win_act(_wer,,'Menu','P&odgląd planu'@@,,,,,,,,,'O');
   _btn:=_tab.win_btn(_wer,'text=%1,panel=right,align=begin'['P&odgląd planu'@],'Menu');
   _formula:="
      _tab:=tab_tmp(1,'REF','INTEGER','#ZK_P.ref()');
      _tab.REF:=BIT.sqlint(cur_tab(1,1).ZKP_REF);
      _tab.add();
      exec('select_any_core','px_plan',,ZK_P,_tab);
      ~~
   ";
   _formula_bg:="
      _tab:=tab_tmp(1,'REF','INTEGER','#ZK_P.ref()');
      _sel:=cur_tab(1,1).sel_aget();
      {? _sel.first()
      || {!
         |? _zkp:=exec('FindAndGet','#table',cur_tab(1,1),_sel.REF,,\"ZKP_REF\",'');
            _tab.REF:=BIT.sqlint(_zkp);
            _tab.add();
            _sel.next()
         !};
         exec('select_any_core','px_plan',,ZK_P,_tab)
      ?};
      cur_tab(1,1).sel_adel();
      0
   ";
   _tab.win_act(_wer,,'Formuła','Plan strategiczny'@@,'#O',,_formula,,,1,_formula_bg,,'P');
::   _tab.win_btn(_wer,'text=%1,panel=right,align=begin'['Plan strategiczny'@],'menu:OP');
   _tab.btn_menu(_wer,_btn,'menu:OP');
   task_attach('TPP_PPS_PPLA');
   task_attach('TPP_PPS_DPLA');
   _formula:="
      exec('zkp_utilization','po_plan',0,cur_tab(1,1).ZKP_REF)
   ";
   _tab.win_act(_wer,,'Formuła','Plan &operacyjny'@@,'#O',,_formula,,,,,,'O');
::   _tab.win_btn(_wer,'text=%1,panel=right,align=begin'['Plan &operacyjny'@],'menu:OO');
   _tab.btn_menu(_wer,_btn,'menu:OO');
   task_attach('TPP_PPO_PPPL');
   task_attach('TPP_PPO_DPPL');
   _formula:="
      ZK_P.cntx_psh();
      ZK_P.prefix();
      {? ZK_P.seek(cur_tab(1,1).ZKP_REF)
      || exec('zk_p_zl','zl_gen')
      || FUN.emsg('Nie znaleziono pozycji zamówienia.'@)
      ?};
      ZK_P.cntx_pop()
   ";
   _tab.win_act(_wer,,'Formuła','Zlecenia'@@,,,_formula,,,,,,'Z');
   task_attach('TTE_PZL_PZLE');
   task_attach('TTE_PZL_DZWE');
   _formula:="
      M.cntx_psh();
      M.clear();
      {? M.seek(cur_tab(1,1).M_REF,) || exec('info_zam','magazyn_stan',5) ?};
      M.cntx_pop()

   ";
   _tab.win_act(_wer,,'Formuła','Sz&czegóły stanu'@@,,,_formula,,,,,,'C');

   _formula:="

::    Bazuje na formułce exec('il_wdr','zamsiw_rea')
      VAR_DEL.delete('INFZAM');
      INFZAM:=tab_tmp(4
         ,'TREE','TREE_REF',''
         ,'LP','INTEGER',''
         ,'NR','INTEGER',''
         ,'SZ','INTEGER',''
         ,'OP','STRING[255]',''
         ,'IL','REAL',''
         ,'REF','STRING[20]',''
         ,'ICO','STRING[16]',''
         ,'IL2','REAL',''
      );
      _tab_wdr:=params_get().env.PX.TAB_WDR;
      _tab_wdr.erase();
      M.cntx_psh();
      M.clear();
      {? M.seek(cur_tab(1,1).M_REF,)
      ||
         exec('tree_del','#tree',INFZAM,0);
         exec('pob_dane2','magazyn_stan',M.ref(),2);
         _ndx:=INFZAM.ndx_tmp(,,'LP',,,'NR',,,'SZ',,);
         INFZAM.index(_ndx);
         INFZAM.prefix(9,2);
         {? INFZAM.first()
         ||
            _sum:=0;
            {!
            |? _sz:=INFZAM.SZ;
               INFZAM.cntx_psh();
               INFZAM.prefix(9,1,_sz);
               {? INFZAM.first()
               || _mag:=(INFZAM.OP*' ')-INFZAM.OP
               ?};
               INFZAM.cntx_pop();

               _tab_wdr.blank();
               _tab_wdr.MAG:=_mag;
               _tab_wdr.OP:=INFZAM.OP;
               _tab_wdr.IL:=INFZAM.IL;
               _tab_wdr.add();

               _sum+=_tab_wdr.IL;

               INFZAM.next()
            !};

            _tab_wdr.blank();
            _tab_wdr.MAG:='~~';
            _tab_wdr.OP:='   S U M A:';
            _tab_wdr.IL:=_sum;
            _tab_wdr.add()
         ?}
      ?};
      _tab_wdr.select();
      M.cntx_pop();
      VAR_DEL.delete('INFZAM')
   ";
   _tab.win_act(_wer,,'Formuła','Ilość w &drodze'@@,,,_formula,,,,,,'D');

   _tab.win_act(_wer,,'Kolejność');

   _formula:="
      {? _a
      || _tab:=cur_tab(1,1);
         _grayed:=':';
         {? _tab.sel_size()=0
         ||
            {? _tab.ILZPX=0
            || _grayed:='O(P)'+_grayed
            ?};
            {? _tab.ILZL=0
            || _grayed:='Z'+_grayed
            ?};
            {? _tab.ILZPO=0
            || _grayed:='O(O)'+_grayed
            ?}
         ?};
         _tab.actions_grayed(cur_win(1,1),_grayed);
         ~~
      ?};
      ~~
   ";
   _tab.win_act(_wer,,'Rekord',,,,_formula);

   _formula:="
      ZK_P.cntx_psh();
      ZK_P.prefix();
      {? ZK_P.seek(cur_tab(1,1).ZKP_REF)
      || params_exec('wys_pozy','zamsiw_poz')
      || FUN.emsg('Nie znaleziono pozycji zamówienia.'@)
      ?};
      ZK_P.cntx_pop();
      ~~
   ";

   _tab.win_act(_wer,,'Wyświetl',,,,_formula);

   _tab.win_sel(_wer)
?};
~~


\select_any_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Wspólna część formuł wyświetlających plan zlecenia/zleceń albo pozycji zamówień
::   WE: [_a] - PX_VER.ref()
::       _b - tabela, której plan jest wyświetlany (ZL, ZK_P)
::       [_c] - kontekst wywołania (tab_tmp - grupa rekordów, np. ZL.sel_aget(), wpp - jedno zlecenie VAR.A_ZLEC)
::       [_d] - INTEGER - [1]/2: 1 - wykonywać select
::                               2 - zwracać obiekt celem umieszczenia widoku w innym oknie grupowym
::       [_e] - STRING - akronim okna grupowego do którego dodać widok
::       [_f] - STRING - nazwa zakładki na jakiej umieścić okno
::       [_g] - STRING - nazwa panelu który dzielić dla panelplus
::       [_h] - STRING - nazwa panelu który tworzyć dla paneplus
::       [_i] - TABLE - uchwyt do tabeli dla której jest utworzony widok
::       [_j] - INTEGER - wysokość okna z planem
::       [_k] - INTEGER - wysokość okna z kontrolką, jeżeli 0 to kontrolka nie jest dodawana
::       [_l] - STRING - tytuł okienka z planem
:        [_m] - INTEGER - czy aktywować okno po zmianie zakładki
::----------------------------------------------------------------------------------------------------------------------
:: ustawienie głównej wersji planu
exec('get_mainversion','px_ver');

_cntx:=(var_pres('_c')>100);
_mode:=1;
{? var_pres('_d')=type_of(0)
|| _mode:=_d
?};
_grp:='';
{? var_pres('_e')=type_of('')
|| _grp:=_e
?};
_tab_name:='';
{? var_pres('_f')=type_of('')
|| _tab_name:=_f
?};
_split_what:='';
{? var_pres('_g')=type_of('')
|| _split_what:=_g
?};
_split_new:='nawigacja';
{? var_pres('_h')=type_of('')
|| _split_new:=_h
?};
_height_wer:=20;
{? var_pres('_j')=type_of(0)
|| _height_wer:=_j
?};
_height_ctrl:=2;
{? var_pres('_k')=type_of(0)
|| _height_ctrl:=_k
?};
_title:='';
{? var_pres('_l')=type_of('')
|| _title:=_l
?};
_activate:=0;
{? var_pres('_m')=type_of(0)
|| _activate:=_m
?};

{? var_pres('_a')<>type_of(null()) || _px_ver:=PX_VAR.MAINVER || _px_ver:=_a ?};
:: "blankuje" PX_VAR - po to żeby się zblankowało PX_VAR.GREY
PX_VAR.GREY:=exec('findfnv','#color');
PX_VAR.IL_KOL:=exec('il_kol_wide','px_plan');
PX_VAR.VIE_VER:=_px_ver;

:: Ustawiam domyślny widok dla usera
PX_VAR.PX_VIEW:=exec('default_view','px_view');

:: Ustawiam tryb prefiksowania kafelków
PX_VAR.KAF_MODE:='S';

:: Podczytuję do zmiennej maksymalną długość pojemników dla widoku 'Obiekty' (szybszy dostęp)
PX_VAR.OBJ_CDUR:=exec('get','#params',500363,2);

VAR_DEL.delete('__plan');
__plan:=exec('select_obj','px_plan',,,0,_title);

_tab:=~~;
{? var_pres('_i')>100
|| _tab:=_i
|| _tab:=__plan.TAB
?};

{? _cntx
|| __plan.Arg:=_c;
   {? _b=ZL
   || _px_obj:="exec('obj_find_zl','px_obj',.Arg)"
   |? _b=ZK_P
   || _px_obj:="exec('obj_find_zkp','px_obj',.Arg)"
   |? _b=GROP
   || _px_obj:="exec('obj_find_grop','px_obj',.Arg)"
   ?}
|| _px_obj:="exec('obj_find_zl','px_obj',VAR.A_ZLEC)"
?};
__plan.load(_px_obj,0);

{? _grp=''
|| _before:="
      _elements:=exec('elements_table_navi','px_plan',0);

::    Ustawiam widok w combobox
      _view:=PX_VAR.PX_VIEW;
      {? _view<>null()
      ||
         _view_sym:=exec('FindAndGet','#table',PX_VIEW,_view,,\"SYMBOL\",'');
         {? _view_sym<>''
         || exec('set_value_grp','#desktop','','nawigacja','combo_view@px_navi',_view_sym,,_elements)
         ?}
      || exec('set_enabled_grp','#desktop','','nawigacja','combo_view@px_navi',0,_elements)
      ?};
      exec('load','#desktop','nawigacja','zpl_navi.dsk',,,,,_elements);
      ~~
   ";
   _grp:=__plan.TAB.grp_make(
      {? PX_VAR.VIE_VER=PX_VAR.MAINVER
      || {? _cntx || 'Plan zleceń'@ || 'Plan zlecenia'@ ?}
      || {? _cntx || 'Symulacja zleceń'@ || 'Symulacja zlecenia'@ ?}
      ?},
      _before,'#zlecplanwerx',,,,,'html_maximized'
   )
?};
_before:="
   _il_kol:=exec('il_kol_wide','px_plan');
   {! _it:=1.._il_kol
   |! _war:=($('PX_VAR.TIT'+$_it))();
      cur_tab(1,1).fld_opt(cur_win(1,1),'col_name=%1'[_war],PX_VAR,'WAR'+$_it);
      _help:=exec('col_help','px_plan',_it);
      cur_tab(1,1).fld_opt(cur_win(1,1),'col_help=%1'[_help],PX_VAR,'WAR'+$_it);
      ~~
   !};
   ~~
";
_height:=20;
{? _mode=2
|| _height:=_height_wer
?};
_grp_mode:='maximized';
{? _title<>''
|| _grp_mode:='maximized_with_title'
?};
_tab.grp_sel(_grp,__plan.TAB,__plan.WER,_tab_name,"exec('after_rfr_zas','px_plan',0)",,,_height,_before,,,_activate,_grp_mode);

{? _height_ctrl>0
||
   {? _mode=2
   || _tab.tab_splt(_grp,_split_what,'horizontal',_split_new,_height_wer+_height_ctrl+1)
   || _tab.grp_splt(_grp,_split_what,'horizontal',_split_new,',90%')
   ?};
   exec('create','#desktop',_tab,_split_new,_grp,_height_ctrl)
?};

{? _mode=1
||
   __plan.TAB.win_sel(_grp);
   __plan.TAB.select();

   VAR_DEL.delete('__plan');
   ~~
|? _mode=2
|| __plan
?}


\select_zl_bg
::----------------------------------------------------------------------------------------------------------------------
::  UTW: TS [19.02]
:: OPIS: Przed grupą rekordów dla funkcji Analizy->Plan w oknach wertowania zleceń
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('_a')<0 || _a:=~~ ?};
exec('select_any_core','px_plan',_a,ZL,ZL.sel_aget());
ZL.sel_adel();
0


\col_help
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [21.37]
:: OPIS: Zwraca test do tooltipa dla kolumny pseudo harmonogramu w tabeli wertowania
::   WE: _a - INTEGER - nr kolumny
::   WY:
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_it:=_a;
_help:=($('PX_VAR.DATY'+$_it+'();exec(\'to_string\',\'daty\',PX_VAR.PX_VIEW().LEVEL,1)'))();
_help


\win_px_obj
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Tworzy okienko obiektów do kolejki
::   WE: _a - STRING - akronim okna grupowego
::  TAG: <PRYWATNA>
::----------------------------------------------------------------------------------------------------------------------
_grp:=_a;
PX_KONT.tab_splt(_grp,'tab0','vertical','obiekty');

exec('add_system_notag','px_tag');
_after_rfr:="
   exec('after_refresh','px_tag');
   grp_disp(PX_OBJ,'WER');
   ~~
";
_fb:="
   ~~
";
_fa:="

   ~~
";
PX_KONT.grp_sel(_grp,PX_TAG,'WER',,_after_rfr,,,,_fb,_fa,,,'maximized');
PX_TAG.index('ID');
PX_TAG.prefix();
PX_TAG.win_fml('WER',PX_TAG,'ID',,'ICON_BEFORE',"exec('icon_id','px_tag')");

PX_KONT.tab_splt(_grp,'obiekty','horizontal','obiekty_dol');
_fb:="
  {? PxSelect.OBJ_sdel
  || PX_OBJ.sel_adel()
  ?};
  ~~
";
_fa:="
   {? var_pres('OBJ_sget',PxSelect)>100 || obj_del(PxSelect.OBJ_sget) ?};
   PxSelect.OBJ_sdel:=0;
   PxSelect.OBJ_sget:=PX_OBJ.sel_aget()
";
PX_KONT.grp_sel(_grp,PX_OBJ,'WER',,,,,,_fb,_fa,,,'maximized');
~~


\select_grops4grp
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Wyświetla pozycje planu dla grupy i wszystkich powiązanych zleceń
::   WE: [_a] - PX_GRP.ref() - grupa w kolejce lub bieżący rekord
::   WY:
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_ref:=null();
{? var_pres('_a')=type_of(PX_GRP.ref())
|| _ref:=_a
?};

_can_continue:=1;
PX_KONT.cntx_psh();
PX_GRP.cntx_psh();
{? _ref<>null()
|| PX_GRP.prefix();
   {? PX_GRP.seek(_ref)
   || _can_continue:=1
   || _can_continue:=0
   ?}
?};

{? _can_continue>0
|| GROPS.cntx_psh();
   _ref_table_grops:=exec('ref_table','#table');
   {? PX_GRP.GROPS<>null()
   ||
      _ref_table_grops.add(PX_GRP.GROPS);
      exec('select_grops_core','px_plan',_ref_table_grops);
      ~~
   || _ref_table_zl:=exec('ref_table','#table');
      GROPP.cntx_psh();
      GROPS.index('GROP');
      GROPP.index('ZL');
      PX_CONN.cntx_psh();
      PX_CONN.index('PX_GRP');
      PX_CONN.prefix(PX_GRP.ref());
      {? PX_CONN.first()
      || {!
         |? {? PX_CONN.PX_OBJ().ZL<>null()
            || _ref_table_zl.add(PX_CONN.PX_OBJ().ZL);

               {? PX_CONN.PX_OBJ().ZL().RODZAJ<>'P'
               ||
                  ZL.cntx_psh();
                  ZL.index('NRNZL');
                  ZL.prefix(PX_CONN.PX_OBJ().ZL().UNRZL);
                  {? ZL.first()
                  || {!
                     |?
                        GROPP.prefix(ZL.ref());
                        {? GROPP.first()
                        || {!
                           |? GROPS.prefix(GROPP.GROP);
                              {? GROPS.first()
                              || {!
                                 |? _ref_table_grops.add(GROPS.ref());
                                    GROPS.next()
                                 !}
                              ?};
                              GROPP.next()
                           !}
                        ?};
                        ZL.next()
                     !}
                  ?};
                  ZL.cntx_pop()

               ||

                  GROPP.prefix(PX_CONN.PX_OBJ().ZL);
                  {? GROPP.first()
                  || {!
                     |? GROPS.prefix(GROPP.GROP);
                        {? GROPS.first()
                        || {!
                           |? _ref_table_grops.add(GROPS.ref());
                              GROPS.next()
                           !}
                        ?};
                        GROPP.next()
                     !}
                  ?}
               ?}
            ?};
            PX_CONN.next()
         !}
      ?};
      PX_CONN.cntx_pop();
      GROPP.cntx_pop();
      exec('select_grops_core','px_plan',_ref_table_grops,_ref_table_zl);
      ~~
   ?};
   GROPS.cntx_pop()
?};
PX_GRP.cntx_pop();
PX_KONT.cntx_pop();
~~


\select_grops_core
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Wyświetla pozycje planu dla grupy i wszystkich powiązanych zleceń - jądro
::   WE: _a - ref_table - tablica refów GROPSów które załadować do widoku
::       [_b] - ref_table - tablica refów zleceń które załadować do widoku, jeżeli nie podana
::                          to ładowane będą wszystkie zlecenia wchodzące w skład podanych grup operacji
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
_tab:=_a.tab;
{? var_pres('_b')>100
|| _ref_table_zl:=_b
|| _ref_table_zl:=exec('ref_table','#table')
?};

GROPS.cntx_psh();
GROPS.prefix();
GROP.cntx_psh();
GROPP.cntx_psh();
GROPP.index('GROP');
PX_GRP.cntx_psh();
PX_GRP.index('GROPS');

PX_POZ.cntx_psh();
PX_POZ.index('TM_GRP');

PX_CONN.cntx_psh();
PX_CONN.index('VER');
ZL.cntx_psh();
ZL.prefix();

PX_OBJ.cntx_psh();

_env_grops:=obj_new('POZ_GROP','POZ_ZL','OBJ_GROP','OBJ_ZL','PLAN_VIEW1','PLAN_VIEW2');

_mainver:=exec('get_mainversion','px_ver');
_poz_grop:=exec('ref_table','#table');
_poz_zl:=exec('ref_table','#table');
_obj_grop:=tab_tmp(1,'REF','INTEGER','#GROP.ref()');
_obj_zl:=tab_tmp(1,'REF','INTEGER','#ZL.ref()');

_load_grop_zl:=1;
{? _ref_table_zl.tab.size()>0
|| _load_grop_zl:=0
?};

_tab.prefix();
{? _tab.first()
|| {!
   |? {? GROPS.seek(_tab.SQL)
      ||
         _obj_grop.prefix(#GROPS.GROP);
         {? _obj_grop.first()=0
         || _obj_grop.blank();
            _obj_grop.REF:=#GROPS.GROP;
            _obj_grop.add()
         ?};
         PX_GRP.index('GROPS');
         PX_GRP.prefix(_mainver,GROPS.ref());
         {? PX_GRP.first()
         || {!
            |? PX_POZ.index('TM_GRP');
               PX_POZ.prefix(PX_GRP.ref());
               {? PX_POZ.first()
               || {!
                  |? _poz_grop.add(PX_POZ.ref());
                     PX_POZ.next()
                  !}
               ?};
               PX_GRP.next()
            !}
         ?};

         {? _load_grop_zl>0
         ||
            GROPP.prefix(GROPS.GROP);
            {? GROPP.first()
            || {!
               |? {? GROPP.ZL<>null()
                  || _ref_table_zl.add(GROPP.ZL)
                  ?};
                  GROPP.next()
               !}
            ?}
         ?}
      ?};
      _tab.next()
   !}
?};

_tab_zl:=_ref_table_zl.tab;
_tab_zl.prefix();
{? _tab_zl.first()
|| {!
   |? {? ZL.seek(_tab_zl.SQL)
      ||
         _obj_zl.prefix(#ZL.ref());
         {? _obj_zl.first()=0
         || _obj_zl.blank();
            _obj_zl.REF:=#ZL.ref();
            _obj_zl.add()
         ?};
         _px_obj:=exec('get_zl_object','px_obj',ZL.ref());
         {? _px_obj<>null()
         ||
            PX_POZ.index('TM_VOBJ');
            PX_POZ.prefix(_mainver,_px_obj);
            {? PX_POZ.first()
            || {!
               |? _poz_zl.add(PX_POZ.ref());
                  PX_POZ.next()
               !}
            ?}
         ?};
         _top_level:=exec('top_level','zl_link',ZL.ref());
         {? _top_level<>null()
         || _obj_zl.prefix(#_top_level);
            {? _obj_zl.first()=0
            || _obj_zl.blank();
               _obj_zl.REF:=#_top_level;
               _obj_zl.add()
            ?};

            _px_obj2:=exec('get_zl_object','px_obj',_top_level);
            {? _px_obj2<>null()
            ||
               PX_POZ.index('TM_VOBJ');
               PX_POZ.prefix(_mainver,_px_obj2);
               {? PX_POZ.first()
               || {!
                  |? _poz_zl.add(PX_POZ.ref());
                     PX_POZ.next()
                  !}
               ?}
            ?}
         ?}
       ?};
      _tab_zl.next()
   !}
?};
_obj_grop.prefix();
_obj_zl.prefix();

_env_grops.POZ_GROP:=_poz_grop.tab;
_env_grops.POZ_ZL:=_poz_zl.tab;
_env_grops.OBJ_GROP:=_obj_grop;
_env_grops.OBJ_ZL:=_obj_zl;

_grpbefore:="
   params_set(params_get());
   _env_grops:=params_get().env_grops;
   _elements:=exec('elements_table_navi','px_plan',0);

:: Ustawiam widok w combobox
   _view:=PX_VAR.PX_VIEW;
   {? _view<>null()
   ||
      _view_sym:=exec('FindAndGet','#table',PX_VIEW,_view,,\"SYMBOL\",'');
      {? _view_sym<>''
      || exec('set_value_grp','#desktop','','nawigacja','combo_view@px_navi',_view_sym,1,_elements)
      ?}
   || exec('set_enabled_grp','#desktop','','nawigacja','combo_view@px_navi',0,_elements)
   ?};
   exec('load','#desktop','nawigacja','grop_navi.dsk',,,,,_elements);
   grp_disp(PX_POZ,'WER_GROP',,0);
   grp_disp(_env_grops.PLAN_VIEW1.TAB,_env_grops.PLAN_VIEW1.WER,1);
   grp_disp(_env_grops.PLAN_VIEW2.TAB,_env_grops.PLAN_VIEW2.WER,1);
   ~~
";
_grp:=PX_POZ.grp_make('Pozycje planu grup operacji'@,_grpbefore,'#pxgropv',,,,,'html_maximized');

_before:="
   _env_grops:=params_get().env_grops;
   _where:='PX_POZ.REFERENCE in (select :_a.SQL from :_a)';
   PX_POZ.prefix();
   PX_POZ.f_set('WHEN','',_where,_env_grops.POZ_GROP);
   PX_POZ.f_first();
   ~~
";
PX_POZ.grp_sel(_grp,,'WER_GROP','Pozycje planu'@,,,,10,_before,,,,'maximized','poz_grop');

PX_POZ.tab_splt(_grp,,'horizontal','dolny');

_before:="
   _env_grops:=params_get().env_grops;
   _where:='PX_POZ.REFERENCE in (select :_a.SQL from :_a)';
   PX_POZ.prefix();
   PX_POZ.f_set('WHEN','',_where,_env_grops.POZ_ZL);
   PX_POZ.f_first();
   ~~
";
PX_POZ.grp_sel(_grp,,'WER_GROP',,,,,10,_before,,,,'maximized','poz_zl');

_env_grops.PLAN_VIEW1:=exec('select_any_core','px_plan',_mainver,GROP,_obj_grop,2,_grp,'Widok planu'@,,,PX_POZ,20,0,'Grupy operacji'@,1);
PX_POZ.tab_splt(_grp,,'horizontal','dolny');
_env_grops.PLAN_VIEW2:=exec('select_any_core','px_plan',_mainver,ZL,_obj_zl,2,_grp,,'dolny','nawigacja',PX_POZ,10,2,'Zlecenia'@);

PX_POZ.win_sel(_grp);
::PX_POZ.hdr_sel('Pozycje planu dla grupy %1'@[PX_GRP.SYMBOL]);

params_set('env_grops',_env_grops);
PX_VAR.PX_WER:='WER_GROP';
PX_POZ.select();
PX_VAR.PX_WER:='';


PX_OBJ.cntx_pop();
ZL.cntx_pop();
PX_CONN.cntx_pop();
PX_POZ.cntx_pop();
PX_POZ.f_clear();
GROPP.cntx_pop();
GROP.cntx_pop();
GROPS.cntx_pop();
PX_GRP.cntx_pop();
~~


\one_ver_simulate
::----------------------------------------------------------------------------------------------------------------------
::  UTW: WH [23.25]
:: OPIS: Przygotowuje wersję planu do symulacji przy pracy na jednej wersji
::  TAG: <PUBLICZNA>
::----------------------------------------------------------------------------------------------------------------------
{? var_pres('PxSelect')>100
|| _pxselect:=PxSelect
|| _pxselect:=exec('pxselect','px_plan')
?};
PX_GRP.cntx_psh();
PX_GRPS.cntx_psh();
_old_view:=PX_VAR.PX_VIEW;
PX_VAR.cntx_psh();
_level:=PX_VAR.PX_VIEW().LEVEL;
exec('init','tpp');
::exec('trigger_on','px_grp');
_source:=exec('get_mainversion','px_ver');
_ver_tmp:=exec('px_ver_temp','px_ver',1,'T');

:: Okreslam granice czasowe klonowania
_start:=PX_GRP.tm_stamp();
_end:=0;

_can_continue:=1;

_argsprog:=exec('plan_progress_a','px_logix');
_argsprog.PX_VER:=_ver_tmp;
_argsprog.MODE:=2;

_argsclone:=exec('clone_a','px_ver');
_argsclone.SOURCE:=_source;
_argsclone.DEST:=_ver_tmp;
{? _level<>''
||
   _daty:=exec('round_start','daty',exec('get','daty',date()),_level);
   {? _daty<>null()
   || DATY.cntx_psh(); DATY.prefix();
      {? DATY.seek(_daty)
      || _argsclone.TM_START:=exec('create','#tm_stamp',DATY.DATA,time(0,0,0))
      ?};
      DATY.cntx_pop()
   || _argsclone.TM_START:=exec('create','#tm_stamp',date(),time(0,0,0))
   ?}
|| _argsclone.TM_START:=exec('create','#tm_stamp',date(),time(0,0,0))
?};
_argsclone.TM_END:=_end;
_argsclone.MODE:=2;
_argsclone.STARTMOD:=exec('start_curcup','px_param');
_clone_size:=exec('task_size_clone','px_logix',_source);

{? _clone_size>0
|| _argsprog.MULTI.add_progress('Przygotowywanie wersji planu'@,_clone_size)
?};
exec('start','#progress',_argsprog.MULTI);

{? _can_continue>0
||
   {? _argsprog.MODE=2
   || _argsprog.MULTI.next_phase()
   ?};
   _can_continue:=exec('clone','px_ver',_argsclone,_argsprog);
   ~~
?};
exec('stop','#progress',_argsprog.MULTI);
{? _can_continue>0
|| exec('mod_stamp_queue','px_ver',_ver_tmp);
   exec('mod_stamp','px_ver',_ver_tmp);
   exec('select','px_plan',_ver_tmp,0,1,'WHATIF',1)
?};

:: przywracam poprzednie ustawienia okna - tablice ktora ma wszystkie tymczasowe tabelki i okna
{? var_pres('_pxselect')>100
|| VAR_DEL.delete('PxSelect');
   PxSelect:=_pxselect
?};
::exec('trigger_off','px_grp');
PX_VAR.cntx_pop();
PX_GRP.cntx_pop();
PX_GRPS.cntx_pop();

exec('prenumber','px_grp',exec('get_mainversion','px_ver'));

:: Odświeżenie z powrotem głównego okna z planu żeby konteksty się poprawnie ustawiły
{? exec('tree_kont','px_param')
|| grp_disp(PX_KONT,'PX_WERT',1)
|| grp_disp(PX_KONT,'PX_WER',1)
?};
{? var_pres('PxSelect')>100 || exec('przelicz_btn','px_plan') ?};
exec('delete','px_ver',_ver_tmp,0);
PX_VAR.PX_VIEW:=_old_view;
~~

:Sign Version 2.0 jowisz:1048 2023/06/23 14:14:37 1fdafca212df6606b6477e010121247bd8762d490cde4ce22cab58ac99bfcbe9903280264f110c81578a463c132ce182a97a4f846b09d7a427c05a03990c1873ef94c49319d2a1a20eba72dc3cd08ab6ba0222a63f4f3b2d8be90b407ef849e1c0c506254c906eca38385752be7bc0adb048c1cf66d825792248a104fe112459
